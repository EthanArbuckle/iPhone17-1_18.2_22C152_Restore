CA::Render::FlattenManager *CA::Render::FlattenManager::layer_is_flattened(CA::Render::FlattenManager *this, const CA::Render::Layer *a2)
{
  uint64_t v2;
  CA::Render::FlattenManager *result;
  uint64_t v5;

  v2 = *((void *)this + 18);
  if (!v2) {
    return 0;
  }
  result = (CA::Render::FlattenManager *)*(unsigned int *)(v2 + 72);
  if (!result) {
    return result;
  }
  if ((*(unsigned char *)(v2 + 13) & 0x20) == 0) {
    return 0;
  }
  v5 = *((void *)this + 5);
  if ((v5 & 0x80000) == 0)
  {
    CA::Render::FlattenManager::flattened_cache_remove_surface(result);
    result = 0;
    *(_DWORD *)(v2 + 12) &= ~0x2000u;
    return result;
  }
  return (CA::Render::FlattenManager *)((v5 & 0x100000) == 0);
}

uint64_t CA::Render::Surface::protection_options(CA::Render::Surface *this)
{
  return *((void *)this + 17);
}

uint64_t CA::compare_contexts(CA *this, const void *a2, const void *a3)
{
  uint64_t v3 = *(void *)this;
  int v4 = *(_DWORD *)(*(void *)this + 140);
  int v5 = *(_DWORD *)(*(void *)a2 + 140);
  uint64_t result = (v5 - v4);
  if (v5 == v4) {
    return (*(_DWORD *)(*(void *)a2 + 8) - *(_DWORD *)(v3 + 8));
  }
  return result;
}

unint64_t compare_sel(unsigned char *a1, unsigned char *a2)
{
  return (unint64_t)(a1 - a2) >> 3;
}

uint64_t compareInfo(_DWORD *a1, _DWORD *a2)
{
  return (*a1 - *a2);
}

void CA::Render::Updater::prepare_transform_layers(uint64_t a1, CA::Render::LayerNode *a2)
{
  v2 = (CA::Render::LayerNode *)*((void *)a2 + 1);
  if (v2 != a2)
  {
    do
    {
      uint64_t v5 = *(void *)v2;
      v6 = (CA::Render::LayerNode *)*((void *)v2 + 1);
      *(void *)(v5 + 8) = v6;
      *(void *)v6 = v5;
      *(void *)v2 = v2;
      *((void *)v2 + 1) = v2;
      if ((*(_DWORD *)(*(void *)a1 + 1084) & 4) == 0 && (*((unsigned char *)v2 + 27) & 4) == 0)
      {
        v7 = *(int32x2_t **)(*((void *)v2 + 4) + 144);
        if (v7)
        {
          unint64_t v8 = (unint64_t)v7[12];
          if ((v8 & 0x3C) != 0)
          {
            CA::Render::Updater::update_handle(*(CA::Render::Updater **)a1, v7, *(CA::Render::Handle **)(a1 + 16), (CA::Render::Context *)*(unsigned int *)(a1 + 8));
            uint64_t v9 = *((void *)v2 + 4);
            uint64_t v10 = *(void *)(v9 + 104);
            if ((*(unsigned char *)(v9 + 13) & 0x20) != 0)
            {
              if (v10)
              {
                v14 = *(int32x2_t **)(v10 + 144);
                if (v14) {
                  CA::BoundsImpl::Union(v7 + 14, v14[14], v14[15]);
                }
              }
            }
            else if (v10)
            {
              uint64_t v11 = *(unsigned int *)(v10 + 16);
              if (v11)
              {
                uint64_t v12 = v10 + 24;
                do
                {
                  if (*(void *)v12)
                  {
                    v13 = *(int32x2_t **)(*(void *)v12 + 144);
                    if (v13) {
                      CA::BoundsImpl::Union(v7 + 14, v13[14], v13[15]);
                    }
                  }
                  v12 += 8;
                  --v11;
                }
                while (v11);
              }
            }
            unint64_t v8 = (unint64_t)v7[12];
            uint64_t v15 = v8 | 4;
            if ((v8 & 0x300) == 0) {
              uint64_t v15 = (uint64_t)v7[12];
            }
            uint64_t v16 = *(void *)&v7[12] & 0x300 | v15 & 0x100;
            unint64_t v17 = v15 | ((unint64_t)(v15 & 0x100) >> 5);
            if (v16) {
              unint64_t v8 = v17;
            }
            v7[11] = 0;
          }
          v7[12] = (int32x2_t)(v8 & 0xFFFFFFFFFFFFFFFDLL);
        }
      }
      *((void *)v2 + 11) = 0;
      if (atomic_fetch_add((atomic_uint *volatile)v2 + 4, 0xFFFFFFFF) == 1) {
        CA::Render::LayerNode::delete_node(v2, a2);
      }
      v2 = v6;
    }
    while (v6 != a2);
  }
}

void CA::Render::Updater::update_handle(CA::Render::Updater *this, int32x2_t *a2, CA::Render::Handle *a3, CA::Render::Context *a4)
{
  if (a2[10].i32[0] != a4)
  {
    __int32 v4 = (int)a4;
    int32x2_t v6 = a2[12];
    if (v6.i8[0])
    {
      a2[12] = (int32x2_t)(*(void *)&v6 & 0xFFFFFFFFFFFFFFFELL);
      CA::Render::Context::invalidate(a3, a2 + 14, a3);
      CA::Render::Update::invalidate_backdrops(this, (const CA::Bounds *)&a2[14], 0, 0xFFFFFFFF);
      int32x2_t v6 = a2[12];
    }
    a2[10].i32[0] = v4;
    a2[12] = (int32x2_t)(*(void *)&v6 & 0xFBF83E000E3FFF83);
    a2[13] = v6;
    a2[14] = 0;
    a2[15] = 0;
  }
}

uint64_t CA::OGL::LayerNode::add_roi(int32x2_t *this, int32x2_t *a2)
{
  v7[2] = *(int32x2_t *)MEMORY[0x1E4F143B8];
  uint64_t result = CA::OGL::ImagingNode::add_roi(this, a2);
  int32x2_t v4 = this[2];
  if ((*(unsigned char *)(*(void *)&v4 + 33) & 2) != 0
    && (*(_DWORD *)(*(void *)(*(void *)&v4 + 16) + 24) & 0x18000) != 0)
  {
    uint64_t result = CA::OGL::LayerNode::prepare_sublayers_roi_if_needed((uint64_t)this);
    for (i = (void *)this[29]; i; i = (void *)*i)
    {
      uint64_t v6 = i[14];
      if (v6)
      {
        v7[0] = 0;
        v7[1] = 0;
        CA::Shape::get_bounds(v6 + 144, (int *)v7);
        uint64_t result = CA::OGL::ImagingNode::add_roi(this, v7);
        this[27].i32[0] |= *(_DWORD *)(v6 + 216) & 0x40;
      }
    }
  }
  return result;
}

uint64_t CA::OGL::prepare_layers_roi(const Rect **a1, void *a2, uint64_t a3)
{
  uint64_t v94 = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 0;
  }
  uint64_t v3 = a3;
  int32x2_t v4 = a2;
  char v5 = *(unsigned char *)(a3 + 69) & (BYTE11(ca_debug_options) == 0);
  uint64_t v6 = *(void *)(a2[1] + 16);
  if (v6)
  {
    uint64_t v7 = *(void *)(*(void *)(v6 + 32) + 144);
    if (v7)
    {
      if ((*(unsigned char *)(v7 + 98) & 0x30) != 0) {
        char v5 = 0;
      }
    }
  }
  char v86 = 0;
  uint64_t v8 = 0;
  v92 = *(CA::Shape **)(a3 + 8);
  float64x2_t v84 = (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL);
  float64x2_t v85 = (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000);
  uint64_t v9 = a2;
  do
  {
    while (1)
    {
      uint64_t v10 = v8;
      uint64_t v8 = (uint64_t)v9;
      if (v9 != v4)
      {
        unsigned int v11 = *(_DWORD *)(v9[2] + 112);
        if (((v11 != 0) & v5) == 1)
        {
          uint64_t v12 = a1[1];
          unsigned int v13 = *(_DWORD *)&v12[64].top;
          if (v13)
          {
            if (v13 < v11) {
              unsigned int v11 = *(_DWORD *)&v12[64].top;
            }
            uint64_t v14 = *(void *)(*(void *)&v12[67] + 8 * (v11 - 1));
            if (v14)
            {
              if (v14)
              {
                if (v14 == 1) {
                  goto LABEL_20;
                }
              }
              else if (*(_DWORD *)(v14 + 4) == 6)
              {
                goto LABEL_20;
              }
              if ((v86 & 1) == 0) {
                v92 = (CA::Shape *)CA::Shape::ref((unint64_t)v92);
              }
              uint64_t v15 = (CA::Shape **)CA::Shape::intersect(v14, *(void *)(v3 + 8));
              CA::shape_union(&v92, v15, v16);
              CA::Shape::unref((CA::Shape *)v15);
              char v86 = 1;
            }
          }
        }
      }
LABEL_20:
      uint64_t v9 = (void *)*v9;
      uint64_t v17 = *(void *)(*(void *)(v8 + 16) + 24) & 0x4001000;
      if (!v17)
      {
        if (v92)
        {
          if (v92 == (CA::Shape *)1) {
            goto LABEL_118;
          }
        }
        else if (*((_DWORD *)v92 + 1) == 6)
        {
          goto LABEL_118;
        }
      }
      unint64_t v18 = CA::Shape::ref((unint64_t)v92);
      *(void *)(v8 + 96) = v18;
      v20 = (uint64_t *)(v8 + 96);
      uint64_t v21 = *(void *)(*(void *)(v8 + 24) + 144);
      if (v21
        && (*(_WORD *)(v3 + 68) & 0x100) != 0
        && (*(unsigned char *)(v8 + 34) & 4) == 0
        && (*(_DWORD *)&a1[1][135].bottom & 4) == 0
        && (*(unsigned char *)(*(void *)(v8 + 16) + 27) & 4) == 0)
      {
        if (((*a1)[54].top & 0x10) != 0)
        {
          if (!v17)
          {
            *(_OWORD *)v90 = *(_OWORD *)(v21 + 112);
            if (!CA::Shape::intersects(v18, (int32x2_t *)v90)) {
              goto LABEL_118;
            }
          }
        }
        else
        {
          *(_OWORD *)v90 = *(_OWORD *)(v21 + 112);
          CA::shape_intersect((CA::Shape **)(v8 + 96), v90, v19);
          if (!v17)
          {
            uint64_t v22 = *v20;
            if (*v20)
            {
              if (v22 == 1) {
                goto LABEL_118;
              }
            }
            else if (*(_DWORD *)(v22 + 4) == 6)
            {
              goto LABEL_118;
            }
          }
        }
      }
      uint64_t v23 = *(void *)(v8 + 24);
      if ((*(unsigned char *)(v23 + 40) & 0x40) == 0) {
        goto LABEL_50;
      }
      float64x2_t v24 = *(float64x2_t *)(v23 + 64);
      float64x2_t v25 = *(float64x2_t *)(v23 + 80);
      *(float64x2_t *)v90 = v24;
      float64x2_t v91 = v25;
      uint64_t v26 = *(void *)(v8 + 16);
      v27 = *(float64x2_t **)(v26 + 56);
      if (v27) {
        CA::Mat4Impl::mat4_apply_to_rect(v27, (int8x16_t *)v90, (double *)v19);
      }
      else {
        *(float64x2_t *)v90 = vaddq_f64(*(float64x2_t *)(v26 + 64), v24);
      }
      CA::Rect::apply_transform((int8x16_t *)v90, *(const CA::Transform **)(v3 + 24), (double *)v19);
      v93[0] = 0;
      v93[1] = 0;
      if (*(unsigned char *)(v8 + 32))
      {
        int64x2_t v29 = vceqzq_f64(v91);
        if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v29, 1), (int8x16_t)v29).u64[0] & 0x8000000000000000) == 0)
        {
          int8x16_t v30 = vorrq_s8((int8x16_t)vcltzq_f64(v91), (int8x16_t)vcgezq_f64(v91));
          if ((vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v30), 1), v30).u64[0] & 0x8000000000000000) == 0)
          {
            int32x4_t v31 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(*(float64x2_t *)v90, v85));
            *(int32x4_t *)v93 = vuzp1q_s32(v31, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(*(float64x2_t *)v90, v91), v84)), (int64x2_t)v31));
          }
        }
      }
      else
      {
        CA::OGL::Context::raster_round_rect((CA::OGL::Context *)v93, *a1, (double *)v90);
      }
      CA::shape_intersect((CA::Shape **)(v8 + 96), v93, v28);
      if (v17) {
        goto LABEL_50;
      }
      uint64_t v77 = *v20;
      if ((*v20 & 1) == 0) {
        break;
      }
      if (v77 != 1) {
        goto LABEL_50;
      }
LABEL_118:
      CA::OGL::Renderer::dealloc_layer((CA::OGL::Renderer *)a1, v8);
      uint64_t v8 = v10;
      if (!v9) {
        goto LABEL_141;
      }
    }
    if (*(_DWORD *)(v77 + 4) == 6) {
      goto LABEL_118;
    }
LABEL_50:
    v89 = v9;
    uint64_t v33 = *(void *)(v8 + 96);
    v32 = *(int32x2_t **)(v8 + 104);
    v93[0] = 0;
    v93[1] = 0;
    CA::Shape::get_bounds(v33, (int *)v93);
    int32x2_t v34 = v32[1];
    int v35 = *(_DWORD *)(*(void *)&v34 + 96);
    if ((v35 + 1) > 1) {
      unsigned int v36 = v35 + 1;
    }
    else {
      unsigned int v36 = 1;
    }
    *(_DWORD *)(*(void *)&v34 + 96) = v36;
    CA::OGL::ImagingNode::init_roi((uint64_t)v32, v36);
    v37 = 0;
    v32[5] = 0;
    v38 = v32;
    do
    {
      v39 = (int32x2_t *)v38[5];
      v38[5] = 0;
      if (v37) {
        v37[5] = (int32x2_t)v38;
      }
      uint64_t v40 = 0;
      char v41 = 1;
      do
      {
        char v42 = v41;
        int32x2_t v43 = v38[v40 + 3];
        if (v43)
        {
          int v44 = *(_DWORD *)(*(void *)&v43 + 144) - 1;
          *(_DWORD *)(*(void *)&v43 + 144) = v44;
          if (!v44)
          {
            *(void *)(*(void *)&v43 + 40) = v39;
            v39 = (int32x2_t *)v43;
          }
        }
        char v41 = 0;
        uint64_t v40 = 1;
      }
      while ((v42 & 1) != 0);
      v37 = v38;
      v38 = v39;
    }
    while (v39);
    uint64_t v45 = v3;
    (*(void (**)(int32x2_t *, CA::Shape **))(*(void *)v32 + 56))(v32, v93);
    CA::BoundsImpl::Union(v32 + 24, (int32x2_t)v93[0], (int32x2_t)v93[1]);
    if (v32[5])
    {
      v46 = v32 + 16;
      v47 = v32;
      do
      {
        v90[0] = 0;
        v90[1] = 0;
        CA::Shape::get_bounds((uint64_t)&v47[18], (int *)v90);
        if (v47 == v32)
        {
          if (v32[17].i32[0] < 0) {
            (*(void (**)(int32x2_t *, int32x2_t *))(*(void *)v32 + 40))(v32, v32 + 16);
          }
          uint32x2_t v56 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, (int32x2_t)v90[1]);
          if ((vpmax_u32(v56, v56).u32[0] & 0x80000000) == 0)
          {
            int32x2_t v57 = v32[17];
            uint32x2_t v58 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v57);
            if ((vpmax_u32(v58, v58).u32[0] & 0x80000000) != 0
              || (*(int32x2_t *)&long long v59 = vmax_s32((int32x2_t)v90[0], *v46),
                  int32x2_t v60 = vsub_s32(vmin_s32(vadd_s32((int32x2_t)v90[0], (int32x2_t)v90[1]), vadd_s32(*v46, v57)), *(int32x2_t *)&v59), v61 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v60), (vpmax_u32(v61, v61).u32[0] & 0x80000000) != 0))
            {
              v90[1] = 0;
            }
            else
            {
              *((int32x2_t *)&v59 + 1) = v60;
              *(_OWORD *)v90 = v59;
            }
          }
        }
        else
        {
          (*(void (**)(int32x2_t *, CA::Shape **))(*(void *)v47 + 48))(v47, v90);
          v48 = v47 + 16;
          if (v47[17].i32[0] < 0) {
            (*(void (**)(int32x2_t *, int32x2_t *))(*(void *)v47 + 40))(v47, v47 + 16);
          }
          v49 = v90[1];
          uint32x2_t v50 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, (int32x2_t)v90[1]);
          if ((vpmax_u32(v50, v50).u32[0] & 0x80000000) == 0)
          {
            int32x2_t v51 = v47[17];
            uint32x2_t v52 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v51);
            if ((vpmax_u32(v52, v52).u32[0] & 0x80000000) != 0
              || (int32x2_t v53 = vadd_s32(*v48, v51),
                  *(int32x2_t *)&long long v54 = vmax_s32((int32x2_t)v90[0], *v48),
                  v49 = (CA::Shape *)vsub_s32(vmin_s32(vadd_s32((int32x2_t)v90[0], (int32x2_t)v90[1]), v53), *(int32x2_t *)&v54), uint32x2_t v55 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, (int32x2_t)v49), (vpmax_u32(v55, v55).u32[0] & 0x80000000) != 0))
            {
              v49 = 0;
              v90[1] = 0;
            }
            else
            {
              *((void *)&v54 + 1) = v49;
              *(_OWORD *)v90 = v54;
            }
          }
          if ((v47[26].i16[2] & 0x200) != 0)
          {
            int v62 = HIDWORD(v49);
            if ((int)v49 <= SHIDWORD(v49)) {
              int v63 = HIDWORD(v49);
            }
            else {
              int v63 = (int)v49;
            }
            if ((int)v49 < SHIDWORD(v49)) {
              int v62 = (int)v49;
            }
            if (v63 <= 1073741822 && v62 >= 1)
            {
              v65 = (CA::Shape *)vadd_s32((int32x2_t)v90[0], (int32x2_t)-1);
              int8x8_t v66 = (int8x8_t)vadd_s32((int32x2_t)v49, (int32x2_t)0x200000002);
              if (v66.i32[1] < 1 || v66.i32[0] < 1) {
                unsigned int v68 = -1;
              }
              else {
                unsigned int v68 = 0;
              }
              v90[0] = v65;
              v90[1] = (CA::Shape *)vbic_s8(v66, (int8x8_t)vdup_n_s32(v68));
            }
          }
          CA::Shape::operator=((uint64_t)&v47[18], v90);
        }
        (*(void (**)(int32x2_t *, CA::Shape **))(*(void *)v47 + 64))(v47, v90);
        (*(void (**)(int32x2_t *, int32x2_t *))(*(void *)v47 + 72))(v47, v47 + 24);
        v47 = (int32x2_t *)v47[5];
      }
      while (v47);
    }
    while ((v32[26].i16[2] & 0x100) != 0)
      v32 = (int32x2_t *)v32[3];
    v32[8] = (int32x2_t)v33;
    uint64_t v3 = v45;
    uint64_t v9 = v89;
    if (!v89)
    {
      int32x2_t v4 = a2;
      goto LABEL_135;
    }
    int32x2_t v4 = a2;
    if ((v5 & 1) == 0) {
      goto LABEL_124;
    }
    if ((*(unsigned char *)(v8 + 34) & 0x10) != 0
      || (uint64_t v69 = *(void *)(v8 + 16), (v70 = *(const CA::Shape **)(v69 + 208)) == 0))
    {
      char v5 = 1;
    }
    else
    {
      v71 = v92;
      if (CA::Shape::intersects(*(void *)(v69 + 208), (uint64_t)v92))
      {
        v74 = (CA::Shape *)CA::Shape::subtract(v71, v70, v72, v73);
        v75 = v74;
        if ((v74 & 1) != 0 || *((int *)v74 + 1) <= 64)
        {
          if (v86) {
            CA::Shape::unref(v71);
          }
          v92 = v75;
          uint64_t v76 = *(void *)(v8 + 112);
          char v5 = 1;
          if (!v76)
          {
            char v86 = 1;
            uint64_t v9 = v89;
            goto LABEL_126;
          }
          uint64_t v9 = v89;
          goto LABEL_139;
        }
        uint64_t v78 = *(void *)(*(void *)(v8 + 24) + 144);
        uint64_t v9 = v89;
        if (v78) {
          *(void *)(v78 + 96) |= 0x200000uLL;
        }
        CA::Shape::unref(v74);
LABEL_124:
        char v5 = 0;
        goto LABEL_125;
      }
      char v5 = 1;
      uint64_t v9 = v89;
    }
LABEL_125:
    uint64_t v76 = *(void *)(v8 + 112);
    if (!v76) {
      goto LABEL_126;
    }
    if ((v86 & 1) == 0)
    {
      v92 = (CA::Shape *)CA::Shape::ref((unint64_t)v92);
      uint64_t v76 = *(void *)(v8 + 112);
    }
LABEL_139:
    v90[0] = 0;
    v90[1] = 0;
    CA::Shape::get_bounds(v76 + 144, (int *)v90);
    CA::shape_union(&v92, v90, v82);
    char v86 = 1;
LABEL_126:
    if (((*a1)[54].top & 0x10) != 0)
    {
      v79 = v92;
      if ((v92 & 1) == 0)
      {
        int v80 = *((_DWORD *)v92 + 1);
        if (v80 != 6 && v80 != 12)
        {
          v90[0] = 0;
          v90[1] = 0;
          CA::Shape::get_bounds((uint64_t)v92, (int *)v90);
          if (v86) {
            CA::Shape::unref(v79);
          }
          v92 = (CA::Shape *)CA::Shape::new_shape((unsigned int *)v90);
          char v86 = 1;
        }
      }
    }
LABEL_135:
    *(void *)uint64_t v8 = v10;
    (*(void (**)(void))(**(void **)(v8 + 104) + 96))(*(void *)(v8 + 104));
  }
  while (v9);
LABEL_141:
  if (v86) {
    CA::Shape::unref(v92);
  }
  return v8;
}

uint64_t CA::BoundsImpl::Union(int32x2_t *a1, int32x2_t a2, int32x2_t a3)
{
  int32x2_t v3 = a1[1];
  uint32x2_t v4 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v3);
  uint32x2_t v5 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, a3);
  unsigned __int32 v6 = vpmax_u32(v5, v5).u32[0];
  if ((vpmax_u32(v4, v4).u32[0] & 0x80000000) == 0)
  {
    if ((v6 & 0x80000000) != 0) {
      return 1;
    }
    int32x2_t v7 = vadd_s32(a2, a3);
    a2 = vmin_s32(*a1, a2);
    a3 = vsub_s32(vmax_s32(vadd_s32(*a1, v3), v7), a2);
LABEL_5:
    *a1 = a2;
    a1[1] = a3;
    return 1;
  }
  if ((v6 & 0x80000000) == 0) {
    goto LABEL_5;
  }
  return 0;
}

unint64_t CA::Shape::ref(unint64_t this)
{
  v1 = (int *)this;
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if ((this & 1) == 0)
  {
    if (*(_DWORD *)this)
    {
      atomic_fetch_add((atomic_uint *volatile)this, 1u);
    }
    else
    {
      uint64_t v2 = *(unsigned int *)(this + 4);
      if (v2 == 6)
      {
        return 1;
      }
      else if (v2 == 12)
      {
        unsigned int v3 = *(_DWORD *)(this + 20);
        int v4 = *(_DWORD *)(this + 32);
        v10[0] = *(_DWORD *)(this + 28);
        v10[1] = v3;
        unsigned int v5 = *(_DWORD *)(this + 36) - v3;
        v10[2] = v4 - v10[0];
        v10[3] = v5;
        return CA::Shape::new_shape(v10);
      }
      else if ((v2 & 0x80000000) != 0)
      {
        return 0;
      }
      else
      {
        malloc_zone = (malloc_zone_t *)get_malloc_zone();
        this = (unint64_t)malloc_type_zone_malloc(malloc_zone, 4 * v2, 0x8BB15036uLL);
        if (this)
        {
          if (v2)
          {
            int v7 = v2;
            uint64_t v8 = (_DWORD *)this;
            do
            {
              int v9 = *v1++;
              *v8++ = v9;
              --v7;
            }
            while (v7);
          }
          *(_DWORD *)this = 1;
          *(_DWORD *)(this + 8) = v2;
        }
      }
    }
  }
  return this;
}

uint64_t CA::OGL::LayerNode::prepare_sublayers_roi_if_needed(uint64_t this)
{
  if ((*(unsigned char *)(this + 224) & 2) == 0)
  {
    uint64_t v1 = this;
    CA::OGL::LayerNode::prepare_sublayers_if_needed((void *)this);
    this = CA::OGL::prepare_layers_roi(*(const Rect ***)(v1 + 8), *(void **)(v1 + 232), v1 + 56);
    *(void *)(v1 + 232) = this;
    *(unsigned char *)(v1 + 224) |= 2u;
  }
  return this;
}

BOOL CA::Shape::intersects(uint64_t this, int32x2_t *a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (a2[1].i32[0]) {
    BOOL v2 = a2[1].i32[1] == 0;
  }
  else {
    BOOL v2 = 1;
  }
  if (!v2)
  {
    if (this)
    {
      if (this != 1)
      {
        v6.i32[0] = this >> 48;
        v6.i32[1] = (int)((unint64_t)this >> 16) >> 16;
        v7.i32[0] = this >> 17;
        unsigned int v8 = (this >> 2) & 0x7FFF;
LABEL_14:
        v7.i32[1] = v8;
        uint32x2_t v9 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v7);
        if ((vpmax_u32(v9, v9).u32[0] & 0x80000000) == 0)
        {
          int32x2_t v10 = a2[1];
          uint32x2_t v11 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v10);
          if ((vpmax_u32(v11, v11).u32[0] & 0x80000000) == 0)
          {
            uint32x2_t v12 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, vsub_s32(vmin_s32(vadd_s32(v6, v7), vadd_s32(*a2, v10)), vmax_s32(v6, *a2)));
            return vpmax_u32(v12, v12).i32[0] >= 0;
          }
        }
      }
    }
    else
    {
      int v5 = *(_DWORD *)(this + 4);
      if (v5 != 6)
      {
        if (v5 != 12)
        {
          memset(v13, 0, sizeof(v13));
          CA::Shape::operator=((uint64_t)v13, a2);
          return CA::Shape::intersects(this, (uint64_t)v13);
        }
        v6.i32[0] = *(_DWORD *)(this + 28);
        v6.i32[1] = *(_DWORD *)(this + 20);
        v7.i32[0] = *(_DWORD *)(this + 32) - v6.i32[0];
        unsigned int v8 = *(_DWORD *)(this + 36) - v6.i32[1];
        goto LABEL_14;
      }
    }
  }
  return 0;
}

uint64_t CA::Shape::get_bounds(uint64_t result, int *a2)
{
  if (result)
  {
    *a2 = result >> 48;
    a2[1] = (int)((unint64_t)result >> 16) >> 16;
    a2[2] = result >> 17;
    a2[3] = (result >> 2) & 0x7FFF;
  }
  else
  {
    int v2 = *(_DWORD *)(result + 4);
    if (v2 == 12)
    {
      *a2 = *(_DWORD *)(result + 28);
      a2[1] = *(_DWORD *)(result + 20);
      a2[2] = *(_DWORD *)(result + 32) - *(_DWORD *)(result + 28);
      int v3 = *(_DWORD *)(result + 36) - *(_DWORD *)(result + 20);
    }
    else
    {
      if (v2 == 6)
      {
        *(void *)a2 = 0;
        *((void *)a2 + 1) = 0;
        return result;
      }
      int v4 = *(_DWORD *)(result + 12);
      result += 12;
      int v5 = *(_DWORD *)(result + 8);
      if (v4 == 0x7FFFFFFF)
      {
        signed int v6 = 0x80000000;
        int v7 = 0x7FFFFFFF;
        int v8 = *(_DWORD *)(result + 8);
      }
      else
      {
        signed int v6 = 0x80000000;
        int v8 = *(_DWORD *)(result + 8);
        int v7 = 0x7FFFFFFF;
        do
        {
          uint64_t v9 = *(int *)(result + 4);
          int32x2_t v10 = (int *)(result + 4 * v9);
          if (v9 != 2)
          {
            if (*(_DWORD *)(result + 8) < v7) {
              int v7 = *(_DWORD *)(result + 8);
            }
            if (*(v10 - 1) > v6) {
              signed int v6 = *(v10 - 1);
            }
            int v8 = *v10;
          }
          result += 4 * v9;
        }
        while (*v10 != 0x7FFFFFFF);
      }
      *a2 = v7;
      a2[1] = v5;
      int v3 = v8 - v5;
      a2[2] = v6 - v7;
    }
    a2[3] = v3;
  }
  return result;
}

uint64_t CA::OGL::ImagingNode::init_roi(uint64_t this, unsigned int a2)
{
  int v2 = *(_DWORD *)(this + 208);
  if (v2 != a2)
  {
    uint64_t v4 = this;
    if (v2)
    {
      *(_DWORD *)(this + 216) = *(_DWORD *)(this + 216) & 0xFFC00000 | 0xF;
      *(_WORD *)(this + 212) &= 0xFCFFu;
    }
    if ((*(unsigned char *)(*(void *)(*(void *)(this + 16) + 16) + 25) & 4) != 0
      || (uint64_t v5 = *(void *)(this + 88), v5 != 0x3C003C003C003C00)
      && ((short float v6 = COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)),
           *((short float *)&v5 + 2) <= COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
        ? (BOOL v7 = *(short float *)&v5 <= v6)
        : (BOOL v7 = 0),
          v7 ? (BOOL v8 = *((short float *)&v5 + 1) <= v6) : (BOOL v8 = 0),
          !v8))
    {
      *(_DWORD *)(this + 216) |= 0x1000u;
    }
    uint64_t v9 = 0;
    *(_DWORD *)(this + 208) = a2;
    *(_DWORD *)(this + 144) = 0;
    char v10 = 1;
    *(void *)(this + 64) = 0;
    do
    {
      char v11 = v10;
      uint64_t v12 = v4 + 8 * v9;
      uint64_t v14 = *(void *)(v12 + 24);
      uint64_t v13 = v12 + 24;
      this = v14;
      if (v14)
      {
        this = CA::OGL::ImagingNode::init_roi((CA::OGL::ImagingNode *)this, a2);
        ++*(_DWORD *)(*(void *)v13 + 144);
      }
      char v10 = 0;
      uint64_t v9 = 1;
    }
    while ((v11 & 1) != 0);
  }
  return this;
}

void CA::shape_union(CA::Shape **this, CA::Shape **a2, const CA::Shape *a3)
{
  if (a2)
  {
    if (a2 == (CA::Shape **)1) {
      return;
    }
LABEL_5:
    uint64_t v4 = *this;
    if (*this)
    {
      if (v4 == (CA::Shape *)1) {
        goto LABEL_7;
      }
    }
    else if (*((_DWORD *)v4 + 1) == 6)
    {
LABEL_7:
      unint64_t v5 = CA::Shape::ref((unint64_t)a2);
LABEL_10:
      *this = (CA::Shape *)v5;
      return;
    }
    unint64_t v5 = CA::Shape::Union((uint64_t)*this, (uint64_t)a2);
    CA::Shape::unref(v4);
    goto LABEL_10;
  }
  if (*((_DWORD *)a2 + 1) != 6) {
    goto LABEL_5;
  }
}

uint64_t CA::OGL::ImagingNode::add_roi(int32x2_t *this, int32x2_t *a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (!*(void *)&this[8])
  {
    this[8] = (int32x2_t)CA::Shape::operator=((uint64_t)&this[18], a2);
    goto LABEL_10;
  }
  int32x2_t v12 = 0;
  int32x2_t v13 = 0;
  CA::Shape::get_bounds((uint64_t)&this[18], (int *)&v12);
  int32x2_t v4 = a2[1];
  uint32x2_t v5 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v13);
  uint32x2_t v6 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v4);
  unsigned __int32 v7 = vpmax_u32(v6, v6).u32[0];
  if ((vpmax_u32(v5, v5).u32[0] & 0x80000000) != 0)
  {
    if ((v7 & 0x80000000) == 0)
    {
      int32x2_t v8 = *a2;
      goto LABEL_8;
    }
  }
  else if ((v7 & 0x80000000) == 0)
  {
    int32x2_t v8 = vmin_s32(v12, *a2);
    int32x2_t v4 = vsub_s32(vmax_s32(vadd_s32(v12, v13), vadd_s32(*a2, v4)), v8);
LABEL_8:
    int32x2_t v12 = v8;
    int32x2_t v13 = v4;
  }
  CA::Shape::operator=((uint64_t)&this[18], &v12);
LABEL_10:
  int32x2_t v9 = *a2;
  int32x2_t v10 = a2[1];

  return CA::BoundsImpl::Union(this + 24, v9, v10);
}

uint64_t CA::Shape::operator=(uint64_t result, _DWORD *a2)
{
  if ((int)a2[2] < 1 || (int)a2[3] < 1)
  {
    *(void *)uint64_t result = 0x600000000;
    int v2 = 0x80000000;
    uint64_t v3 = 5;
    uint64_t v4 = 4;
    uint64_t v5 = 3;
  }
  else
  {
    *(void *)uint64_t result = 0xC00000000;
    *(void *)(result + 12) = 0x280000000;
    *(_DWORD *)(result + 20) = a2[1];
    *(_DWORD *)(result + 24) = 4;
    *(_DWORD *)(result + 28) = *a2;
    *(_DWORD *)(result + 32) = a2[2] + *a2;
    int v2 = a2[3] + a2[1];
    uint64_t v3 = 11;
    uint64_t v4 = 10;
    uint64_t v5 = 9;
  }
  *(_DWORD *)(result + 4 * v5) = v2;
  *(_DWORD *)(result + 4 * v4) = 2;
  *(_DWORD *)(result + 4 * v3) = 0x7FFFFFFF;
  return result;
}

unint64_t CA::Shape::Union(uint64_t this, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v3 = this;
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  if (this)
  {
    if (this == 1)
    {
LABEL_38:
      unint64_t v19 = v2;
      goto LABEL_39;
    }
  }
  else if (*(_DWORD *)(this + 4) == 6)
  {
    goto LABEL_38;
  }
  if (a2)
  {
    if (a2 == 1) {
      goto LABEL_33;
    }
  }
  else if (*(_DWORD *)(a2 + 4) == 6)
  {
    goto LABEL_33;
  }
  unint64_t v50 = 0;
  unint64_t v51 = 0;
  if ((this & 1) == 0)
  {
    if (*(_DWORD *)(this + 4) != 12) {
      goto LABEL_11;
    }
LABEL_15:
    if (a2)
    {
      if (a2 == 1)
      {
LABEL_17:
        if (this)
        {
          uint64_t v8 = this >> 48;
          uint64_t v7 = this << 16 >> 48;
          unsigned int v9 = this >> 17;
          unsigned int v10 = (this >> 2) & 0x7FFF;
        }
        else
        {
          LODWORD(v7) = *(_DWORD *)(this + 20);
          LODWORD(v8) = *(_DWORD *)(this + 28);
          unsigned int v9 = *(_DWORD *)(this + 32) - v8;
          unsigned int v10 = *(_DWORD *)(this + 36) - v7;
        }
        unint64_t v50 = __PAIR64__(v7, v8);
        unint64_t v51 = __PAIR64__(v10, v9);
        if (CA::Shape::contains(a2, (const CA::Bounds *)&v50)) {
          goto LABEL_38;
        }
        goto LABEL_44;
      }
    }
    else if (*(_DWORD *)(a2 + 4) != 12)
    {
      goto LABEL_17;
    }
    if (this)
    {
      uint64_t v12 = this >> 48;
      uint64_t v11 = this << 16 >> 48;
      int v14 = ((this >> 2) & 0x7FFF) + v11;
      int v13 = (this >> 48) + (this >> 17);
      if (a2) {
        goto LABEL_22;
      }
    }
    else
    {
      LODWORD(v11) = *(_DWORD *)(this + 20);
      LODWORD(v12) = *(_DWORD *)(this + 28);
      int v13 = *(_DWORD *)(this + 32);
      int v14 = *(_DWORD *)(this + 36);
      if (a2)
      {
LABEL_22:
        uint64_t v15 = a2 >> 48;
        uint64_t v16 = a2 << 16 >> 48;
        int v17 = ((a2 >> 2) & 0x7FFF) + v16;
        int v18 = (a2 >> 48) + (a2 >> 17);
        goto LABEL_29;
      }
    }
    LODWORD(v16) = *(_DWORD *)(a2 + 20);
    LODWORD(v15) = *(_DWORD *)(a2 + 28);
    int v18 = *(_DWORD *)(a2 + 32);
    int v17 = *(_DWORD *)(a2 + 36);
LABEL_29:
    if ((int)v12 <= (int)v15 && (int)v11 <= (int)v16 && v13 >= v18 && v14 >= v17) {
      goto LABEL_33;
    }
    if ((int)v12 >= (int)v15 && (int)v11 >= (int)v16 && v13 <= v18 && v14 <= v17) {
      goto LABEL_38;
    }
    goto LABEL_44;
  }
  if (this != 1) {
    goto LABEL_15;
  }
LABEL_11:
  if ((a2 & 1) == 0)
  {
    if (*(_DWORD *)(a2 + 4) == 12)
    {
      int v4 = *(_DWORD *)(a2 + 20);
      int v5 = *(_DWORD *)(a2 + 32);
      LODWORD(v50) = *(_DWORD *)(a2 + 28);
      HIDWORD(v50) = v4;
      LODWORD(v51) = v5 - v50;
      unsigned int v6 = *(_DWORD *)(a2 + 36) - v4;
      goto LABEL_25;
    }
LABEL_44:
    long long v56 = xmmword_184998410;
    int v57 = 2;
    uint64_t v21 = (int *)v58;
    uint32x2_t v52 = &v56;
    int32x2_t v53 = (int *)v58;
    long long v54 = (int *)v58;
    uint32x2_t v55 = (char *)&v56 + 12;
    *(void *)&v58[2028] = 0;
    long long v62 = 0u;
    long long v63 = 0u;
    long long v61 = 0u;
    if (v3)
    {
      long long v61 = xmmword_184998420;
      LODWORD(v62) = 2;
      DWORD1(v62) = (int)((unint64_t)v3 >> 16) >> 16;
      DWORD2(v62) = 4;
      HIDWORD(v62) = v3 >> 48;
      LODWORD(v63) = HIDWORD(v62) + (v3 >> 17);
      DWORD1(v63) = ((v3 >> 2) & 0x7FFF) + DWORD1(v62);
      *((void *)&v63 + 1) = 0x7FFFFFFF00000002;
      uint64_t v3 = (uint64_t)&v61;
    }
    long long v60 = 0uLL;
    memset(v59, 0, sizeof(v59));
    if (v2)
    {
      *(void *)&v59[3] = 0x280000000;
      v59[1] = 12;
      v59[5] = (int)((unint64_t)v2 >> 16) >> 16;
      v59[6] = 4;
      v59[7] = v2 >> 48;
      LODWORD(v60) = v59[7] + (v2 >> 17);
      DWORD1(v60) = ((v2 >> 2) & 0x7FFF) + v59[5];
      *((void *)&v60 + 1) = 0x7FFFFFFF00000002;
      uint64_t v2 = (uint64_t)v59;
    }
    int v24 = *(_DWORD *)(v3 + 12);
    uint64_t v22 = v3 + 12;
    int v23 = v24;
    float64x2_t v25 = (int *)(v2 + 12);
    if (v24 == 0x7FFFFFFF)
    {
      uint64_t v26 = (int *)(v2 + 12);
LABEL_50:
      v27 = v26;
      return CA::ShapeHandle::finish((CA::ShapeHandle *)&v52, v27);
    }
    v28 = (int *)(v2 + 12);
    v27 = (const int *)v22;
    while (1)
    {
      int v29 = *v28;
      if (*v28 == 0x7FFFFFFF) {
        return CA::ShapeHandle::finish((CA::ShapeHandle *)&v52, v27);
      }
      if (v23 - v29 >= 1) {
        break;
      }
      uint64_t v30 = v27[1];
      if (((v23 - v29) & 0x80000000) == 0)
      {
        uint64_t v22 = (uint64_t)v27;
        v27 += v30;
        goto LABEL_58;
      }
      LODWORD(v31) = v25[1];
      uint64_t v22 = (uint64_t)v27;
      v27 += v30;
      uint64_t v26 = v28;
LABEL_59:
      int v32 = v30 - 2;
      unsigned int v33 = v30 - 2 + v31;
      if (*((int *)v52 + 2) < ((char *)&v21[v33] - (char *)v52) >> 2)
      {
        if (!CA::ShapeHandle::grow((CA::ShapeHandle *)&v52, v33))
        {
          if (*v27 != 0x7FFFFFFF) {
            return CA::ShapeHandle::finish((CA::ShapeHandle *)&v52, v27);
          }
          goto LABEL_50;
        }
        uint64_t v21 = v53;
      }
      int v34 = v31 - 2;
      *uint64_t v21 = v23;
      int v35 = v21 + 2;
      int32x2_t v53 = v21 + 2;
      v21[1] = 0;
      unsigned int v36 = (int *)(v22 + 8);
      v37 = v25 + 2;
      if (v32 && v31 != 2)
      {
        int v38 = 0;
        while (1)
        {
          int v39 = *v36;
          int v40 = *v37;
          int v41 = *v36 - *v37;
          if (*v36 > *v37) {
            break;
          }
          int v42 = v38 ^ 1;
          ++v36;
          --v32;
          if ((v41 & 0x80000000) == 0) {
            goto LABEL_68;
          }
          int v40 = v39;
          if (v38)
          {
LABEL_69:
            if (v42) {
              goto LABEL_71;
            }
          }
LABEL_70:
          *v35++ = v40;
          int32x2_t v53 = v35;
LABEL_71:
          if (v32)
          {
            int v38 = v42;
            if (v34) {
              continue;
            }
          }
          goto LABEL_76;
        }
        int v42 = v38;
LABEL_68:
        v42 ^= 2u;
        ++v37;
        --v34;
        if (v38) {
          goto LABEL_69;
        }
        goto LABEL_70;
      }
LABEL_76:
      if (v32) {
        int v34 = v32;
      }
      if (v34)
      {
        if (!v32) {
          unsigned int v36 = v37;
        }
        do
        {
          int v43 = *v36++;
          *v35++ = v43;
          --v34;
        }
        while (v34);
        int32x2_t v53 = v35;
      }
      int v44 = v54;
      uint64_t v45 = v55;
      unint64_t v46 = (unint64_t)((char *)v35 - (char *)v54) >> 2;
      v54[1] = v46;
      if (v45 && *((_DWORD *)v45 + 1) == v46)
      {
        uint64_t v47 = 2;
        while (v46 != v47)
        {
          int v48 = v44[v47];
          int v49 = *(_DWORD *)&v45[4 * v47++];
          if (v48 != v49) {
            goto LABEL_88;
          }
        }
        int32x2_t v53 = v44;
        int v35 = v44;
      }
      else
      {
LABEL_88:
        long long v54 = v35;
        uint32x2_t v55 = (char *)v44;
      }
      int v23 = *v27;
      uint64_t v21 = v35;
      v28 = v26;
      if (*v27 == 0x7FFFFFFF) {
        goto LABEL_50;
      }
    }
    LODWORD(v30) = *(_DWORD *)(v22 + 4);
LABEL_58:
    uint64_t v31 = v28[1];
    uint64_t v26 = &v28[v31];
    float64x2_t v25 = v28;
    int v23 = *v28;
    goto LABEL_59;
  }
  if (a2 == 1) {
    goto LABEL_44;
  }
  LODWORD(v50) = a2 >> 48;
  HIDWORD(v50) = (int)((unint64_t)a2 >> 16) >> 16;
  LODWORD(v51) = a2 >> 17;
  unsigned int v6 = (a2 >> 2) & 0x7FFF;
LABEL_25:
  HIDWORD(v51) = v6;
  if (!CA::Shape::contains(this, (const CA::Bounds *)&v50)) {
    goto LABEL_44;
  }
LABEL_33:
  unint64_t v19 = v3;
LABEL_39:

  return CA::Shape::ref(v19);
}

void CA::OGL::render_layers(uint64_t *a1, uint64_t a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    uint64_t v2 = a2;
    uint64_t v4 = *a1;
    while (1)
    {
      uint64_t v5 = *(void *)(v2 + 104);
      *(void *)(v4 + 824) = v2;
      *(_WORD *)(v4 + 832) &= ~0x800u;
      if (BYTE3(xmmword_1EB2ACC70)) {
        uint64_t v6 = mach_continuous_time();
      }
      else {
        uint64_t v6 = 0;
      }
      if (byte_1EB2ACBE1) {
        *(_DWORD *)(v5 + 220) = *(_DWORD *)(v5 + 220) & 0xFFF1FFFF | 0xA0000;
      }
      uint64_t v7 = *(void *)(v2 + 112);
      BOOL v8 = v7 != 0;
      if (v7)
      {
        uint64_t v9 = *(void *)(v4 + 272);
        if (v9 != *(void *)(v4 + 264)) {
          goto LABEL_9;
        }
        if (v9) {
          LODWORD(v9) = (*(unsigned __int8 *)(v9 + 72) >> 1) & 0x1F;
        }
        if (*(_DWORD *)(v4 + 260) != v9) {
LABEL_9:
        }
          CA::OGL::Context::prepare_destination_((CA::OGL::Context *)v4);
        if ((*(_WORD *)(v4 + 832) & 0x200) != 0) {
          CA::OGL::Context::flatten_detached_layers_(v4);
        }
        *(void *)(*(void *)(v2 + 112) + 224) = *(void *)(v4 + 264);
      }
      if ((*(_WORD *)(v2 + 40) & 8) != 0)
      {
        uint64_t v10 = *(void *)(v4 + 272);
        if (v10 != *(void *)(v4 + 264)) {
          goto LABEL_18;
        }
        if (v10) {
          LODWORD(v10) = (*(unsigned __int8 *)(v10 + 72) >> 1) & 0x1F;
        }
        if (*(_DWORD *)(v4 + 260) != v10) {
LABEL_18:
        }
          CA::OGL::Context::prepare_destination_((CA::OGL::Context *)v4);
        if ((*(_WORD *)(v4 + 832) & 0x200) != 0) {
          CA::OGL::Context::flatten_detached_layers_(v4);
        }
        CA::OGL::capture_backdrop((CA::OGL *)a1, (void *)v2);
        if (byte_1EB2ACBEB) {
          *(_DWORD *)(v5 + 220) = *(_DWORD *)(v5 + 220) & 0xFFF1FFFF | 0xA0000;
        }
        BOOL v8 = 1;
      }
      CA::OGL::ImagingNode::render(v5, 0, 0);
      uint64_t v11 = *(void *)(v2 + 112);
      if (v11) {
        *(void *)(v11 + 224) = 0;
      }
      uint64_t v12 = *(void *)(*(void *)(v2 + 24) + 144);
      if (!v12) {
        goto LABEL_41;
      }
      int v13 = *(unsigned __int16 *)(v2 + 298);
      int v14 = *(_DWORD *)(v2 + 300);
      int v15 = v14 & 0x1FFFF;
      if (*(_WORD *)(v2 + 298) || v15) {
        goto LABEL_34;
      }
      if (*(_DWORD *)(v12 + 92) >> 28) {
        break;
      }
LABEL_41:
      if (v6 && (v8 || (*(_WORD *)(v4 + 832) & 0x800) != 0))
      {
        if (CA::OGL::trace_log(void)::once != -1) {
          dispatch_once(&CA::OGL::trace_log(void)::once, &__block_literal_global_37);
        }
        os_signpost_id_t v20 = *(unsigned int *)(a1[1] + 248);
        if (v20)
        {
          uint64_t v21 = CA::OGL::trace_log(void)::log;
          if (os_signpost_enabled((os_log_t)CA::OGL::trace_log(void)::log))
          {
            uint64_t v22 = *(void *)(v2 + 24);
            if (v22)
            {
              uint64_t v22 = *(void *)(v22 + 120);
              if (v22)
              {
                int v23 = *(_DWORD *)(v22 + 24);
                v22 += 28;
                if (!v23) {
                  uint64_t v22 = 0;
                }
              }
            }
            *(_DWORD *)buf = 136446466;
            uint64_t v26 = v22;
            __int16 v27 = 2050;
            uint64_t v28 = v6;
            _os_signpost_emit_with_name_impl(&dword_184668000, v21, OS_SIGNPOST_EVENT, v20, "RenderLayer", "ID is update layer=%{public,name=layer}s begin=%{public,signpost.description:begin_time}llu", buf, 0x16u);
          }
        }
      }
      *(void *)(v4 + 824) = *(void *)(v2 + 8);
      *(_WORD *)(v4 + 832) &= ~0x800u;
      uint64_t v24 = *(void *)v2;
      CA::OGL::Renderer::dealloc_layer((CA::OGL::Renderer *)a1, v2);
      uint64_t v2 = v24;
      if (!v24) {
        return;
      }
    }
    int v15 = 0;
LABEL_34:
    int v16 = *(_DWORD *)(*a1 + 228);
    if (*(_DWORD *)(v12 + 88) == v16)
    {
      unsigned int v17 = *(_DWORD *)(v12 + 92);
    }
    else
    {
      unsigned int v17 = 0;
      *(_DWORD *)(v12 + 88) = v16;
    }
    unsigned int v18 = v13 + (v17 >> 28);
    if (v18 >= 0xF) {
      int v19 = -268435456;
    }
    else {
      int v19 = v18 << 28;
    }
    *(_DWORD *)(v12 + 92) = (v17 | v14) & 0xFFE0000 | v17 & 0x1FFFF | v15 | v19;
    goto LABEL_41;
  }
}

void CA::OGL::Renderer::dealloc_layer(CA::OGL::Renderer *a1, uint64_t a2)
{
  uint64_t v4 = *(_WORD **)(a2 + 104);
  if (v4)
  {
    __int16 v5 = v4[106] - 1;
    *((unsigned char *)v4 + 212) = v4[106] - 1;
    if (!(_BYTE)v5) {
      CA::OGL::ImagingNode::finalize((CA::OGL::ImagingNode *)v4, a1);
    }
  }
  uint64_t v6 = *(_WORD **)(a2 + 112);
  if (v6)
  {
    __int16 v7 = v6[106] - 1;
    *((unsigned char *)v6 + 212) = v6[106] - 1;
    if (!(_BYTE)v7) {
      CA::OGL::ImagingNode::finalize((CA::OGL::ImagingNode *)v6, a1);
    }
  }
  if (*(void *)(a2 + 120)) {
    CA::OGL::Renderer::dealloc_layer(a1);
  }
  if ((*(_WORD *)(a2 + 40) & 0x20) != 0) {
    free(*(void **)(a2 + 88));
  }
  uint64_t v8 = *(unsigned __int16 *)(a2 + 296);
  if (*(_WORD *)(a2 + 296))
  {
    uint64_t v9 = *(void **)(a2 + 128);
    uint64_t v10 = (void *)*((void *)a1 + 10);
    do
    {
      uint64_t v11 = v10;
      uint64_t v10 = v9;
      uint64_t v9 = (void *)*v9;
      *uint64_t v10 = v11;
      --v8;
    }
    while (v8);
    *((void *)a1 + 10) = v10;
  }
  uint64_t v12 = *(CA::Shape **)(a2 + 96);
  if (v12) {
    CA::Shape::unref(v12);
  }
  *(void *)a2 = *((void *)a1 + 8);
  *((void *)a1 + 8) = a2;
}

void CA::Shape::unref(CA::Shape *this)
{
  if ((this & 1) == 0
    && *(_DWORD *)this
    && atomic_fetch_add((atomic_uint *volatile)this, 0xFFFFFFFF) == 1)
  {
    *(void *)((char *)this + 4) = -1;
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(malloc_zone, this);
  }
}

uint64_t CA::OGL::ImagingNode::finalize(CA::OGL::ImagingNode *this, CA::OGL::Renderer *a2)
{
  uint64_t v4 = 0;
  char v5 = 1;
  do
  {
    char v6 = v5;
    __int16 v7 = (_WORD *)*((void *)this + v4 + 3);
    if (v7)
    {
      __int16 v8 = v7[106] - 1;
      *((unsigned char *)v7 + 212) = v7[106] - 1;
      if (!(_BYTE)v8) {
        CA::OGL::ImagingNode::finalize((CA::OGL::ImagingNode *)v7, a2);
      }
    }
    char v5 = 0;
    uint64_t v4 = 1;
  }
  while ((v6 & 1) != 0);
  uint64_t v9 = *((void *)this + 6);
  if (v9) {
    CA::OGL::Context::release_surface(*(void *)a2, v9);
  }
  uint64_t result = (**(uint64_t (***)(CA::OGL::ImagingNode *))this)(this);
  *(void *)this = *((void *)a2 + 9);
  *((void *)a2 + 9) = this;
  return result;
}

void CA::OGL::LayerNode::~LayerNode(CA::OGL::LayerNode *this)
{
  *(void *)this = &unk_1ED02C768;
  uint64_t v1 = (void *)*((void *)this + 29);
  if (v1)
  {
    uint64_t v2 = (CA::OGL::Renderer *)*((void *)this + 1);
    do
    {
      uint64_t v3 = (void *)*v1;
      CA::OGL::Renderer::dealloc_layer(v2, (uint64_t)v1);
      uint64_t v1 = v3;
    }
    while (v3);
  }
}

{
  CA::OGL::LayerNode::~LayerNode(this);
  abort();
}

void CA::OGL::ImagingNode::render(uint64_t a1, uint64_t a2, unsigned int a3)
{
  v39[2] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a1 + 8);
  if (*(unsigned char *)(v3 + 101)) {
    return;
  }
  uint64_t v6 = *(void *)v3;
  if ((*(_WORD *)(a1 + 212) & 0x100) != 0)
  {
    ++*(_DWORD *)(v6 + 740);
    CA::OGL::ImagingNode::render(*(void *)(a1 + 24), a2);
    --*(_DWORD *)(v6 + 740);
    return;
  }
  v39[0] = 0;
  v39[1] = 0;
  uint64_t v38 = 0x3F8000003F800000;
  unsigned int v7 = *(_DWORD *)(a1 + 220);
  if (a2) {
    int v8 = HIBYTE(v7) & 1;
  }
  else {
    int v8 = 0;
  }
  float v9 = 1.0;
  if (v8 == 1)
  {
    if ((v7 & 0x2200000) != 0x2000000)
    {
      LOBYTE(v8) = 0;
      goto LABEL_22;
    }
    uint64_t v10 = 0;
    char v11 = 1;
    do
    {
      char v12 = v11;
      uint64_t v13 = a1 + 8 * v10;
      int v16 = *(CA::OGL::ImagingNode **)(v13 + 24);
      uint64_t v15 = v13 + 24;
      int v14 = v16;
      if (v16)
      {
        CA::OGL::ImagingNode::remove_feature_passthrough_aware(v14, a2);
        unsigned int v17 = *(void **)v15;
        uint64_t v18 = *(void *)(*(void *)v15 + 48);
        int v19 = (float *)&v39[-1] + v10;
        if (v18)
        {
          float *v19 = 1.0;
          *(void *)(v17[1] + 88) -= *(int *)(v18 + 28) * (uint64_t)*(int *)(v18 + 24) * (*(unsigned char *)(v18 + 74) & 0x1F);
          v17[6] = 0;
          float v20 = 1.0;
        }
        else
        {
          uint64_t v18 = (*(uint64_t (**)(void *, char *, void))(*v17 + 80))(v17, (char *)&v39[-1] + 4 * v10, *(_DWORD *)(a1 + 220) & 0x1FFFF);
          float v20 = *v19;
        }
        v39[v10] = v18;
        if (v20 > v9 && v20 < 1.0) {
          float v9 = v20;
        }
      }
      char v11 = 0;
      uint64_t v10 = 1;
    }
    while ((v12 & 1) != 0);
  }
  if (!a2) {
    goto LABEL_24;
  }
LABEL_22:
  if ((*(uint64_t (**)(uint64_t, void, float))(*(void *)a2 + 16))(a2, a3, v9))
  {
    if (v8)
    {
LABEL_31:
      uint64_t v28 = *(void *)(a1 + 64);
      memset(v37, 0, sizeof(v37));
      if (v9 != 1.0)
      {
        CA::Shape::operator=((uint64_t)v37, (_DWORD *)(*(void *)(v6 + 264) + 32));
        *(void *)(a1 + 64) = v37;
      }
      *(void *)(a1 + 56) = CA::OGL::Context::set_gstate(v6, a1 + 56);
      uint64_t v36 = 0;
      memset(v35, 0, sizeof(v35));
      if ((*(unsigned char *)(a1 + 222) & 0x20) != 0) {
        CA::OGL::MaskCorners::begin((float32x2_t *)v35, (CA::OGL::ImagingNode *)a1, v29);
      }
      (*(void (**)(uint64_t, void *, uint64_t *, float))(*(void *)a1 + 104))(a1, v39, &v38, v9);
      if ((*(unsigned char *)(a1 + 222) & 0x20) != 0) {
        CA::OGL::MaskCorners::finish((CA::OGL::MaskCorners *)v35, (CA::OGL::ImagingNode *)a1);
      }
      CA::OGL::Context::set_gstate(v6, **(void **)(v6 + 248));
      *(void *)(a1 + 64) = v28;
      goto LABEL_38;
    }
LABEL_24:
    uint64_t v22 = 0;
    char v23 = 1;
    do
    {
      char v24 = v23;
      float64x2_t v25 = *(void **)(a1 + 8 * v22 + 24);
      if (v25)
      {
        uint64_t v26 = v25[6];
        __int16 v27 = (_DWORD *)&v39[-1] + v22;
        if (v26)
        {
          _DWORD *v27 = 1065353216;
          *(void *)(v25[1] + 88) -= *(int *)(v26 + 28) * (uint64_t)*(int *)(v26 + 24) * (*(unsigned char *)(v26 + 74) & 0x1F);
          v25[6] = 0;
        }
        else
        {
          uint64_t v26 = (*(uint64_t (**)(void *, _DWORD *, void))(*v25 + 80))(v25, v27, *(_DWORD *)(a1 + 220) & 0x1FFFF);
        }
        v39[v22] = v26;
      }
      char v23 = 0;
      uint64_t v22 = 1;
    }
    while ((v24 & 1) != 0);
    goto LABEL_31;
  }
LABEL_38:
  uint64_t v30 = 0;
  char v31 = 1;
  do
  {
    char v32 = v31;
    uint64_t v33 = v39[v30];
    if (v33) {
      CA::OGL::Context::release_surface(v6, v33);
    }
    char v31 = 0;
    uint64_t v30 = 1;
  }
  while ((v32 & 1) != 0);
}

uint64_t CA::OGL::Context::set_gstate(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void *)(a1 + 248);
  if (result != a2)
  {
    uint64_t v4 = *(void *)(a1 + 16);
    *(unsigned char *)(v4 + 480) = *(unsigned char *)(a2 + 68);
    *(void *)(v4 + 288) = *(void *)(a2 + 40);
    *(void *)(*(void *)(a1 + 16) + 296) = *(void *)(a2 + 48);
    *(void *)(*(void *)(a1 + 16) + 280) = *(void *)(a2 + 56);
    uint64_t v5 = *(void *)(a2 + 8);
    if (v5)
    {
      if (v5 == 1) {
        goto LABEL_4;
      }
    }
    else if (*(_DWORD *)(v5 + 4) != 12)
    {
LABEL_4:
      __int16 v6 = 0;
      __int16 v7 = 0;
      goto LABEL_9;
    }
    if ((*(_WORD *)(a1 + 832) & 8) != 0 && *(void *)(result + 8) == v5) {
      goto LABEL_10;
    }
    __int16 v7 = 8;
    __int16 v6 = 16;
LABEL_9:
    *(unsigned char *)(a1 + 64) = 0;
    *(_WORD *)(a1 + 832) = v7 | v6 | *(_WORD *)(a1 + 832) & 0xFFE7;
LABEL_10:
    *(void *)(a1 + 248) = a2;
  }
  return result;
}

void CA::OGL::LayerNode::apply(CA::OGL::LayerNode *this, double a2, float32x4_t a3, int8x16_t a4, uint64_t a5, double *a6, const int *a7)
{
  v15[3] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *((void *)this + 2);
  uint64_t v8 = *(void *)(v7 + 32);
  if ((v8 & 8) == 0)
  {
    uint64_t v10 = (uint64_t *)*((void *)this + 1);
    if ((v8 & 0x200005120) != 0)
    {
      CA::OGL::render_contents_background(*((CA::OGL::Context ***)this + 1), v7, (uint64_t)a6, a7, a2, a3, a4);
      uint64_t v8 = *(void *)(v7 + 32);
    }
    if ((v8 & 0x2000) != 0)
    {
      uint64_t v11 = **(void **)(*(void *)(v7 + 24) + 128);
      v15[0] = &unk_1ED030FE0;
      v15[1] = v10;
      v15[2] = v7;
      (*(void (**)(uint64_t, void *))(*(void *)v11 + 232))(v11, v15);
      uint64_t v8 = *(void *)(v7 + 32);
    }
    if ((v8 & 0x200) != 0)
    {
      CA::OGL::LayerNode::prepare_sublayers_roi_if_needed((uint64_t)this);
      CA::OGL::render_layers(v10, *((void *)this + 29));
      *((void *)this + 29) = 0;
      *((unsigned char *)this + 224) &= 0xFCu;
      uint64_t v8 = *(void *)(v7 + 32);
    }
    if ((v8 & 0x1080) != 0)
    {
      CA::OGL::render_border((CA::OGL::Context *)*v10, v7, a6);
      if ((*(unsigned char *)(v7 + 33) & 0x10) != 0 && (*(unsigned char *)(*(void *)(v7 + 24) + 44) & 2) != 0)
      {
        int v14 = (CA::OGL::Context *)*v10;
        CA::OGL::render_shadow_path(v14, v7, v12, v13);
      }
    }
  }
}

uint64_t CA::Shape::intersect(uint64_t this, uint64_t a2)
{
  uint64_t v2 = (long long *)this;
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  if (this)
  {
    if (this == 1) {
      return 1;
    }
  }
  else if (*(_DWORD *)(this + 4) == 6)
  {
    return 1;
  }
  if (a2)
  {
    if (a2 == 1) {
      return 1;
    }
  }
  else if (*(_DWORD *)(a2 + 4) == 6)
  {
    return 1;
  }
  if (this)
  {
    if (this == 1)
    {
LABEL_15:
      long long v48 = xmmword_184998410;
      int v49 = 2;
      uint64_t v4 = v50;
      int v44 = &v48;
      uint64_t v45 = v50;
      unint64_t v46 = v50;
      uint64_t v47 = (char *)&v48 + 12;
      *(void *)&v50[2028] = 0;
      long long v54 = 0u;
      long long v55 = 0u;
      long long v53 = 0u;
      if (this)
      {
        long long v53 = xmmword_184998420;
        LODWORD(v54) = 2;
        DWORD1(v54) = (int)((unint64_t)this >> 16) >> 16;
        DWORD2(v54) = 4;
        HIDWORD(v54) = this >> 48;
        LODWORD(v55) = HIDWORD(v54) + (this >> 17);
        DWORD1(v55) = ((this >> 2) & 0x7FFF) + DWORD1(v54);
        *((void *)&v55 + 1) = 0x7FFFFFFF00000002;
        uint64_t v2 = &v53;
      }
      long long v52 = 0uLL;
      memset(v51, 0, sizeof(v51));
      if (a2)
      {
        *(void *)&v51[3] = 0x280000000;
        v51[1] = 12;
        v51[5] = (int)((unint64_t)a2 >> 16) >> 16;
        v51[6] = 4;
        v51[7] = a2 >> 48;
        LODWORD(v52) = v51[7] + (a2 >> 17);
        DWORD1(v52) = ((a2 >> 2) & 0x7FFF) + v51[5];
        *((void *)&v52 + 1) = 0x7FFFFFFF00000002;
        a2 = (uint64_t)v51;
      }
      int v7 = *((_DWORD *)v2 + 3);
      uint64_t v5 = (_DWORD *)v2 + 3;
      int v6 = v7;
      if (v7 == 0x7FFFFFFF) {
        return CA::ShapeHandle::finish((CA::ShapeHandle *)&v44, 0);
      }
      uint64_t v8 = (char *)(a2 + 12);
      float v9 = (_DWORD *)(a2 + 12);
      uint64_t v10 = v5;
      while (1)
      {
        int v11 = *v9;
        if (*v9 == 0x7FFFFFFF) {
          return CA::ShapeHandle::finish((CA::ShapeHandle *)&v44, 0);
        }
        if (v6 - v11 >= 1) {
          break;
        }
        uint64_t v12 = (int)v10[1];
        if (((v6 - v11) & 0x80000000) == 0)
        {
          uint64_t v5 = v10;
          v10 += v12;
          goto LABEL_27;
        }
        LODWORD(v13) = *((_DWORD *)v8 + 1);
        uint64_t v5 = v10;
        v10 += v12;
        int v14 = v9;
LABEL_28:
        int v15 = v12 - 2;
        unsigned int v16 = v12 - 2 + v13;
        if (*((int *)v44 + 2) < ((char *)&v4[v16] - (char *)v44) >> 2)
        {
          if (!CA::ShapeHandle::grow((CA::ShapeHandle *)&v44, v16)) {
            return CA::ShapeHandle::finish((CA::ShapeHandle *)&v44, 0);
          }
          uint64_t v4 = v45;
        }
        *uint64_t v4 = v6;
        unsigned int v17 = v4 + 2;
        uint64_t v45 = v4 + 2;
        v4[1] = 0;
        if (v15)
        {
          int v18 = v13 - 2;
          if (v13 != 2)
          {
            int v19 = 0;
            float v20 = (int *)(v8 + 8);
            uint64_t v21 = v5 + 2;
            while (1)
            {
              int v22 = *v21;
              int v23 = *v20;
              int v24 = *v21 - *v20;
              if (*v21 > *v20) {
                break;
              }
              ++v21;
              --v15;
              int v25 = v19 ^ 1;
              if ((v24 & 0x80000000) == 0) {
                goto LABEL_37;
              }
              int v23 = v22;
LABEL_38:
              if (v19 == 3 || v25 == 3)
              {
                *v17++ = v23;
                uint64_t v45 = v17;
              }
              if (v15)
              {
                int v19 = v25;
                if (v18) {
                  continue;
                }
              }
              goto LABEL_45;
            }
            int v25 = v19;
LABEL_37:
            ++v20;
            --v18;
            v25 ^= 2u;
            goto LABEL_38;
          }
        }
LABEL_45:
        uint64_t v26 = v46;
        __int16 v27 = v47;
        unint64_t v28 = (unint64_t)((char *)v17 - v46) >> 2;
        *((_DWORD *)v46 + 1) = v28;
        if (v27 && *((_DWORD *)v27 + 1) == v28)
        {
          uint64_t v29 = 2;
          while (v28 != v29)
          {
            int v30 = *(_DWORD *)&v26[4 * v29];
            int v31 = *(_DWORD *)&v27[4 * v29++];
            if (v30 != v31) {
              goto LABEL_50;
            }
          }
          uint64_t v45 = v26;
          unsigned int v17 = v26;
        }
        else
        {
LABEL_50:
          unint64_t v46 = v17;
          uint64_t v47 = v26;
        }
        int v6 = *v10;
        uint64_t v4 = v17;
        float v9 = v14;
        if (*v10 == 0x7FFFFFFF) {
          return CA::ShapeHandle::finish((CA::ShapeHandle *)&v44, 0);
        }
      }
      LODWORD(v12) = v5[1];
LABEL_27:
      uint64_t v13 = (int)v9[1];
      int v14 = &v9[v13];
      uint64_t v8 = (char *)v9;
      int v6 = *v9;
      goto LABEL_28;
    }
  }
  else if (*(_DWORD *)(this + 4) != 12)
  {
    goto LABEL_15;
  }
  if (a2)
  {
    if (a2 == 1) {
      goto LABEL_15;
    }
  }
  else if (*(_DWORD *)(a2 + 4) != 12)
  {
    goto LABEL_15;
  }
  if (this)
  {
    uint64_t v33 = this >> 48;
    uint64_t v32 = this << 16 >> 48;
    int v35 = ((this >> 2) & 0x7FFF) + v32;
    int v34 = (this >> 48) + (this >> 17);
    if (a2) {
      goto LABEL_58;
    }
LABEL_60:
    LODWORD(v37) = *(_DWORD *)(a2 + 20);
    LODWORD(v36) = *(_DWORD *)(a2 + 28);
    int v39 = *(_DWORD *)(a2 + 32);
    int v38 = *(_DWORD *)(a2 + 36);
    goto LABEL_61;
  }
  LODWORD(v32) = *(_DWORD *)(this + 20);
  LODWORD(v33) = *(_DWORD *)(this + 28);
  int v34 = *(_DWORD *)(this + 32);
  int v35 = *(_DWORD *)(this + 36);
  if ((a2 & 1) == 0) {
    goto LABEL_60;
  }
LABEL_58:
  uint64_t v36 = a2 >> 48;
  uint64_t v37 = a2 << 16 >> 48;
  int v38 = ((a2 >> 2) & 0x7FFF) + v37;
  int v39 = (a2 >> 48) + (a2 >> 17);
LABEL_61:
  if ((int)v33 >= (int)v36 && (int)v32 >= (int)v37 && v34 <= v39 && v35 <= v38) {
    return CA::Shape::ref(this);
  }
  if ((int)v33 <= (int)v36 && (int)v32 <= (int)v37 && v34 >= v39 && v35 >= v38)
  {
    this = a2;
    return CA::Shape::ref(this);
  }
  if ((int)v33 <= (int)v36) {
    LODWORD(v33) = v36;
  }
  if ((int)v32 <= (int)v37) {
    LODWORD(v32) = v37;
  }
  if (v34 >= v39) {
    int v40 = v39;
  }
  else {
    int v40 = v34;
  }
  if (v35 >= v38) {
    int v41 = v38;
  }
  else {
    int v41 = v35;
  }
  uint64_t result = 1;
  if (v40 > (int)v33)
  {
    BOOL v42 = __OFSUB__(v41, v32);
    int v43 = v41 - v32;
    if (!((v43 < 0) ^ v42 | (v43 == 0)))
    {
      int v44 = (long long *)__PAIR64__(v32, v33);
      LODWORD(v45) = v40 - v33;
      HIDWORD(v45) = v43;
      return CA::Shape::new_shape((unsigned int *)&v44);
    }
  }
  return result;
}

uint64_t CA::OGL::LayerNode::compute_dod(uint64_t this, int32x2_t *a2, double *a3)
{
  uint64_t v102 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(this + 16);
  *a2 = 0;
  a2[1] = 0;
  uint64_t v4 = *(void *)(v3 + 32);
  if ((v4 & 8) != 0) {
    return this;
  }
  uint64_t v6 = this;
  if ((v4 & 0x1000) != 0 && (*(unsigned char *)(*(void *)(v3 + 24) + 44) & 2) != 0)
  {
    *(_OWORD *)a2->i8 = xmmword_184998040;
    return this;
  }
  if ((v4 & 0x40A0) == 0)
  {
    float64x2_t v100 = 0u;
    float64x2_t v101 = 0u;
    if ((v4 & 0x100) != 0) {
      goto LABEL_27;
    }
LABEL_11:
    if ((v4 & 0x200) == 0) {
      goto LABEL_48;
    }
    goto LABEL_28;
  }
  uint64_t v7 = *(void *)(v3 + 24);
  float64x2_t v8 = *(float64x2_t *)(v7 + 80);
  float64x2_t v100 = *(float64x2_t *)(v7 + 64);
  float64x2_t v101 = v8;
  uint64_t v9 = v3;
  if ((v4 & 0x80) != 0)
  {
    uint64_t v10 = *(void *)(v7 + 128);
    uint64_t v9 = v3;
    if (v10)
    {
      float v11 = *(float *)(v10 + 232);
      uint64_t v9 = v3;
      if (v11 > 0.0)
      {
        this = (uint64_t)CA::BoundsImpl::inset(v100.f64, (float)-v11, (float)-v11);
        uint64_t v9 = *(void *)(v6 + 16);
      }
    }
  }
  if ((*(_WORD *)(v9 + 40) & 8) != 0)
  {
    if (*(unsigned char *)(**(void **)(v7 + 128) + 12) == 3) {
      uint64_t v12 = **(void **)(v7 + 128);
    }
    else {
      uint64_t v12 = 0;
    }
    memset(v99, 0, 32);
    this = (*(uint64_t (**)(uint64_t, uint64_t, int8x16_t *, void))(*(void *)v12 + 184))(v12, v7, v99, 0);
    if (this)
    {
      float64x2_t v13 = (float64x2_t)v99[1];
      int64x2_t v14 = vclezq_f64(v101);
      int64x2_t v15 = vclezq_f64((float64x2_t)v99[1]);
      int32x2_t v16 = vmovn_s64(vcltzq_s64((int64x2_t)vorrq_s8((int8x16_t)vzip1q_s64(v15, v14), (int8x16_t)vzip2q_s64(v15, v14))));
      if (v16.i8[4])
      {
        if (v16.i8[0]) {
          goto LABEL_26;
        }
        float64x2_t v17 = (float64x2_t)v99[0];
      }
      else
      {
        if (v16.i8[0]) {
          goto LABEL_26;
        }
        float64x2_t v17 = vminnmq_f64(v100, (float64x2_t)v99[0]);
        float64x2_t v13 = vsubq_f64(vmaxnmq_f64(vaddq_f64(v100, v101), vaddq_f64((float64x2_t)v99[0], (float64x2_t)v99[1])), v17);
      }
      float64x2_t v100 = v17;
      float64x2_t v101 = v13;
    }
LABEL_26:
    uint64_t v4 = *(void *)(v3 + 32);
    if ((v4 & 0x100) != 0) {
      goto LABEL_27;
    }
    goto LABEL_11;
  }
  if ((v4 & 0x100) == 0) {
    goto LABEL_11;
  }
LABEL_27:
  v99[0] = 0uLL;
  CA::OGL::compute_contents_dod((uint64_t)v99, v3, v6 + 56, *(void *)(*(void *)(v3 + 16) + 48));
  this = CA::BoundsImpl::Union(a2, *(int32x2_t *)v99[0].i8, (int32x2_t)v99[0].u64[1]);
  if ((*(void *)(v3 + 32) & 0x200) == 0) {
    goto LABEL_48;
  }
LABEL_28:
  this = (uint64_t)CA::OGL::LayerNode::prepare_sublayers_if_needed((void *)v6);
  int v18 = *(uint64_t ***)(v6 + 232);
  if (v18)
  {
    float64x2_t v95 = (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL);
    float64x2_t v96 = (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000);
    do
    {
      int v19 = (int32x2_t *)v18[13];
      __int32 v20 = v19[17].i32[0];
      if (v20 < 0)
      {
        (*(void (**)(uint64_t *, int32x2_t *))(*(void *)v19 + 40))(v18[13], v19 + 16);
        __int32 v20 = v19[17].i32[0];
      }
      *(int32x2_t *)v21.i8 = v19[16];
      v21.i32[2] = v20;
      v21.i32[3] = v19[17].i32[1];
      if (((_BYTE)v18[4] & 3) == 0)
      {
        int v22 = v18[3];
        if ((v22[5] & 0x40) != 0)
        {
          int32x2_t v97 = v19[16];
          int8x16_t v98 = v21;
          float64x2_t v23 = *((float64x2_t *)v22 + 4);
          int8x16_t v24 = *((int8x16_t *)v22 + 5);
          v99[0] = (int8x16_t)v23;
          v99[1] = v24;
          int v25 = v18[2];
          uint64_t v26 = (float64x2_t *)v25[7];
          if (v26) {
            CA::Mat4Impl::mat4_apply_to_rect(v26, v99, a3);
          }
          else {
            v99[0] = (int8x16_t)vaddq_f64(*((float64x2_t *)v25 + 4), v23);
          }
          CA::Rect::apply_transform(v99, *(const CA::Transform **)(v6 + 80), a3);
          int64x2_t v27 = vceqzq_f64((float64x2_t)v99[1]);
          int8x16_t v28 = 0uLL;
          if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v27, 1), (int8x16_t)v27).u64[0] & 0x8000000000000000) != 0)
          {
            int8x16_t v21 = v98;
          }
          else
          {
            int8x16_t v29 = vorrq_s8((int8x16_t)vcltzq_f64((float64x2_t)v99[1]), (int8x16_t)vcgezq_f64((float64x2_t)v99[1]));
            int8x16_t v21 = v98;
            if ((vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v29), 1), v29).u64[0] & 0x8000000000000000) == 0)
            {
              int32x4_t v30 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64((float64x2_t)v99[0], v96));
              int8x16_t v28 = (int8x16_t)vuzp1q_s32(v30, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64((float64x2_t)v99[0], (float64x2_t)v99[1]), v95)), (int64x2_t)v30));
            }
          }
          int32x2_t v31 = (int32x2_t)vextq_s8(v21, v21, 8uLL).u64[0];
          uint32x2_t v32 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v31);
          if ((vpmax_u32(v32, v32).u32[0] & 0x80000000) == 0)
          {
            int32x2_t v33 = (int32x2_t)vextq_s8(v28, v28, 8uLL).u64[0];
            uint32x2_t v34 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v33);
            if ((vpmax_u32(v34, v34).u32[0] & 0x80000000) != 0)
            {
              int8x16_t v21 = (int8x16_t)(unint64_t)v97;
            }
            else
            {
              *(int32x2_t *)v21.i8 = vmax_s32(v97, *(int32x2_t *)v28.i8);
              int32x2_t v35 = vsub_s32(vmin_s32(vadd_s32(v97, v31), vadd_s32(*(int32x2_t *)v28.i8, v33)), *(int32x2_t *)v21.i8);
              uint32x2_t v36 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v35);
              if ((vpmax_u32(v36, v36).u32[0] & 0x80000000) != 0) {
                int8x16_t v21 = (int8x16_t)(unint64_t)v97;
              }
              else {
                v21.u64[1] = (unint64_t)v35;
              }
            }
          }
        }
      }
      this = CA::BoundsImpl::Union(a2, *(int32x2_t *)v21.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v21, v21, 8uLL));
      int v18 = (uint64_t **)*v18;
    }
    while (v18);
  }
LABEL_48:
  if ((*(unsigned char *)(v3 + 33) & 0x20) == 0) {
    goto LABEL_72;
  }
  uint64_t v37 = **(void **)(*(void *)(v3 + 24) + 128);
  if ((*(uint64_t (**)(uint64_t))(*(void *)v37 + 176))(v37))
  {
    memset(v99, 0, sizeof(v99));
    this = (*(uint64_t (**)(uint64_t, void, int8x16_t *))(*(void *)v37 + 192))(v37, *(void *)(v3 + 24), v99);
    if (this)
    {
      CA::Volume::apply_transform((CA::Volume *)v99, *(float64x2_t **)(v6 + 80), a3);
      float64x2_t v38 = vsubq_f64(*(float64x2_t *)((char *)&v99[1] + 8), (float64x2_t)v99[0]);
      if (v38.f64[0] >= v38.f64[1]) {
        double v39 = v38.f64[1];
      }
      else {
        double v39 = v38.f64[0];
      }
      BOOL v40 = v39 <= 0.0;
      float64x2_t v41 = 0uLL;
      float64x2_t v42 = 0uLL;
      if (!v40)
      {
        if (v38.f64[0] <= v38.f64[1]) {
          double v43 = v38.f64[1];
        }
        else {
          double v43 = v38.f64[0];
        }
        if (v43 >= 1.79769313e308)
        {
          float64x2_t v41 = (float64x2_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
          float64x2_t v42 = (float64x2_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
        }
        else
        {
          float64x2_t v42 = v38;
          float64x2_t v41 = (float64x2_t)v99[0];
        }
      }
      int64x2_t v49 = vceqzq_f64(v42);
      unint64_t v50 = vorrq_s8((int8x16_t)vdupq_laneq_s64(v49, 1), (int8x16_t)v49).u64[0];
      int8x16_t v51 = 0uLL;
      if ((v50 & 0x8000000000000000) == 0)
      {
        int8x16_t v52 = vorrq_s8((int8x16_t)vcltzq_f64(v42), (int8x16_t)vcgezq_f64(v42));
        if ((vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v52), 1), v52).u64[0] & 0x8000000000000000) == 0)
        {
          int32x4_t v53 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v41, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
          int8x16_t v51 = (int8x16_t)vuzp1q_s32(v53, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v41, v42), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v53));
        }
      }
      this = CA::BoundsImpl::Union(a2, *(int32x2_t *)v51.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v51, v51, 8uLL));
    }
  }
  else
  {
    memset(v99, 0, 32);
    this = (*(uint64_t (**)(uint64_t, void, int8x16_t *, void))(*(void *)v37 + 184))(v37, *(void *)(v3 + 24), v99, 0);
    if (!this) {
      goto LABEL_72;
    }
    float64x2_t v44 = (float64x2_t)v99[1];
    int64x2_t v45 = vclezq_f64(v101);
    int64x2_t v46 = vclezq_f64((float64x2_t)v99[1]);
    int32x2_t v47 = vmovn_s64(vcltzq_s64((int64x2_t)vorrq_s8((int8x16_t)vzip1q_s64(v46, v45), (int8x16_t)vzip2q_s64(v46, v45))));
    if (v47.i8[4])
    {
      if (v47.i8[0]) {
        goto LABEL_72;
      }
      float64x2_t v48 = (float64x2_t)v99[0];
    }
    else
    {
      if (v47.i8[0]) {
        goto LABEL_72;
      }
      float64x2_t v48 = vminnmq_f64(v100, (float64x2_t)v99[0]);
      float64x2_t v44 = vsubq_f64(vmaxnmq_f64(vaddq_f64(v100, v101), vaddq_f64((float64x2_t)v99[0], (float64x2_t)v99[1])), v48);
    }
    float64x2_t v100 = v48;
    float64x2_t v101 = v44;
  }
LABEL_72:
  uint64_t v54 = *(void *)(v3 + 32);
  if ((v54 & 0x1000) == 0) {
    goto LABEL_92;
  }
  uint64_t v55 = *(void *)(v3 + 24);
  if ((*(unsigned char *)(v55 + 44) & 4) != 0)
  {
    uint64_t v58 = v55 + 64;
  }
  else
  {
    uint64_t v56 = *(void *)(v55 + 128);
    if (v56) {
      int v57 = *(CA::Render::Path **)(v56 + 120);
    }
    else {
      int v57 = 0;
    }
    uint64_t v58 = CA::Render::Path::bounding_rect(v57);
    uint64_t v55 = *(void *)(v3 + 24);
  }
  int8x16_t v59 = *(int8x16_t *)(v58 + 16);
  v99[0] = *(int8x16_t *)v58;
  v99[1] = v59;
  uint64_t v60 = *(void *)(v55 + 128);
  if (v60) {
    double v61 = *(float *)(v60 + 224) * -2.8;
  }
  else {
    double v61 = -8.4;
  }
  this = (uint64_t)CA::BoundsImpl::inset((double *)v99[0].i64, v61, v61);
  long long v62 = *(float32x2_t **)(v55 + 128);
  if (v62) {
    float64x2_t v63 = vcvtq_f64_f32(v62[27]);
  }
  else {
    float64x2_t v63 = (float64x2_t)xmmword_184997EE0;
  }
  float64x2_t v64 = (float64x2_t)v99[1];
  float64x2_t v65 = vaddq_f64((float64x2_t)v99[0], v63);
  int64x2_t v66 = vclezq_f64(v101);
  int64x2_t v67 = vclezq_f64((float64x2_t)v99[1]);
  int32x2_t v68 = vmovn_s64(vcltzq_s64((int64x2_t)vorrq_s8((int8x16_t)vzip1q_s64(v67, v66), (int8x16_t)vzip2q_s64(v67, v66))));
  if (v68.i8[4])
  {
    if (v68.i8[0]) {
      goto LABEL_91;
    }
    goto LABEL_90;
  }
  if ((v68.i8[0] & 1) == 0)
  {
    float64x2_t v69 = vaddq_f64(v65, (float64x2_t)v99[1]);
    float64x2_t v65 = vminnmq_f64(v100, v65);
    float64x2_t v64 = vsubq_f64(vmaxnmq_f64(vaddq_f64(v100, v101), v69), v65);
LABEL_90:
    float64x2_t v100 = v65;
    float64x2_t v101 = v64;
  }
LABEL_91:
  uint64_t v54 = *(void *)(v3 + 32);
LABEL_92:
  if ((v54 & 0x200000000) == 0)
  {
    double v70 = v101.f64[0];
    goto LABEL_103;
  }
  v71 = *(int8x16_t **)(v3 + 24);
  int8x16_t v72 = v71[5];
  v99[0] = v71[4];
  v99[1] = v72;
  uint64_t v73 = v71[8].i64[0];
  if (v73) {
    double v74 = *(float *)(v73 + 300);
  }
  else {
    double v74 = 0.0;
  }
  this = (uint64_t)CA::BoundsImpl::inset((double *)v99[0].i64, -v74, -v74);
  double v70 = v101.f64[0];
  float64x2_t v75 = (float64x2_t)v99[1];
  int64x2_t v76 = vclezq_f64(v101);
  int64x2_t v77 = vclezq_f64((float64x2_t)v99[1]);
  int32x2_t v78 = vmovn_s64(vcltzq_s64((int64x2_t)vorrq_s8((int8x16_t)vzip1q_s64(v77, v76), (int8x16_t)vzip2q_s64(v77, v76))));
  if (v78.i8[4])
  {
    if (v78.i8[0]) {
      goto LABEL_103;
    }
    float64x2_t v79 = (float64x2_t)v99[0];
  }
  else
  {
    if (v78.i8[0]) {
      goto LABEL_103;
    }
    float64x2_t v79 = vminnmq_f64(v100, (float64x2_t)v99[0]);
    float64x2_t v75 = vsubq_f64(vmaxnmq_f64(vaddq_f64(v100, v101), vaddq_f64((float64x2_t)v99[0], (float64x2_t)v99[1])), v79);
  }
  float64x2_t v100 = v79;
  float64x2_t v101 = v75;
  double v70 = v75.f64[0];
LABEL_103:
  if (v70 != 0.0)
  {
    CA::Rect::apply_transform((int8x16_t *)&v100, *(const CA::Transform **)(v6 + 80), a3);
    if ((*(_WORD *)(v3 + 40) & 0x3C0) != 0)
    {
      double v80 = v101.f64[1];
      double v81 = v101.f64[0] <= v101.f64[1] ? v101.f64[1] : v101.f64[0];
      if (v81 < 1.79769313e308)
      {
        if (v101.f64[0] < v101.f64[1]) {
          double v80 = v101.f64[0];
        }
        if (v80 > 0.0)
        {
          float64x2_t v82 = vrndmq_f64(v100);
          float64x2_t v83 = vsubq_f64(vrndpq_f64(vaddq_f64(v100, v101)), v82);
          float64x2_t v100 = v82;
          float64x2_t v101 = v83;
        }
      }
    }
    CA::OGL::Context::raster_round_rect((CA::OGL::Context *)v99, **(const Rect ***)(v6 + 8), v100.f64);
    if (v99[0].i32[2] <= v99[0].i32[3]) {
      int v84 = v99[0].i32[3];
    }
    else {
      int v84 = v99[0].i32[2];
    }
    double v85 = (double)v99[0].i32[2];
    double v86 = (double)v99[0].i32[3];
    if (v84 > 1073741822)
    {
      double v85 = 1.79769313e308;
      double v86 = 1.79769313e308;
    }
    v101.f64[0] = v85;
    v101.f64[1] = v86;
    int64x2_t v87 = vceqzq_f64(v101);
    unint64_t v88 = vorrq_s8((int8x16_t)vdupq_laneq_s64(v87, 1), (int8x16_t)v87).u64[0];
    int32x4_t v89 = 0uLL;
    if ((v88 & 0x8000000000000000) == 0)
    {
      int8x16_t v90 = vorrq_s8((int8x16_t)vcltzq_f64(v101), (int8x16_t)vcgezq_f64(v101));
      int32x4_t v91 = (int32x4_t)vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v90), 1), v90);
      if ((v91.i64[0] & 0x8000000000000000) == 0)
      {
        v89.i32[0] = 1073741822;
        v91.i32[0] = v84;
        v92.i64[0] = v99[0].i32[0];
        v92.i64[1] = v99[0].i32[1];
        float64x2_t v93 = (float64x2_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v91, v89), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v92));
        int32x4_t v94 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v93, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
        int32x4_t v89 = vuzp1q_s32(v94, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v93, v101), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v94));
      }
    }
    return CA::BoundsImpl::Union(a2, *(int32x2_t *)v89.i8, (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v89, (int8x16_t)v89, 8uLL));
  }
  return this;
}

uint64_t CA::ShapeHandle::finish(CA::ShapeHandle *this, const int *a2)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  if (!a2) {
    goto LABEL_26;
  }
  uint64_t v3 = a2;
  int v4 = *a2;
  if (*a2 == 0x7FFFFFFF) {
    goto LABEL_26;
  }
  uint64_t v5 = *((unsigned int *)a2 + 1);
  uint64_t v6 = (int *)*((void *)this + 1);
  if (*(int *)(*(void *)this + 8) >= ((uint64_t)&v6[v5] - *(void *)this) >> 2) {
    goto LABEL_6;
  }
  if (CA::ShapeHandle::grow(this, v5))
  {
    uint64_t v6 = (int *)*((void *)this + 1);
LABEL_6:
    int *v6 = v4;
    uint64_t v7 = v6 + 2;
    *((void *)this + 1) = v6 + 2;
    v6[1] = 0;
    int v8 = v3[1] - 2;
    if (v3[1] != 2)
    {
      uint64_t v9 = (int *)(v3 + 2);
      do
      {
        int v10 = *v9++;
        *v7++ = v10;
        --v8;
      }
      while (v8);
      *((void *)this + 1) = v7;
    }
    uint64_t v11 = *((void *)this + 2);
    uint64_t v12 = *((void *)this + 3);
    unint64_t v13 = ((unint64_t)v7 - v11) >> 2;
    *(_DWORD *)(v11 + 4) = v13;
    if (v12 && *(_DWORD *)(v12 + 4) == v13)
    {
      uint64_t v14 = 2;
      while (v13 != v14)
      {
        int v15 = *(_DWORD *)(v11 + 4 * v14);
        int v16 = *(_DWORD *)(v12 + 4 * v14++);
        if (v15 != v16) {
          goto LABEL_15;
        }
      }
      *((void *)this + 1) = v11;
    }
    else
    {
LABEL_15:
      *((void *)this + 2) = v7;
      *((void *)this + 3) = v11;
    }
    v3 += v3[1];
  }
  if (*v3 == 0x7FFFFFFF) {
    goto LABEL_26;
  }
  unsigned int v17 = 0;
  int v18 = v3;
  do
  {
    uint64_t v19 = v18[1];
    v17 += v19;
    v18 += v19;
  }
  while (*v18 != 0x7FFFFFFF);
  __int32 v20 = (_DWORD *)*((void *)this + 1);
  if (*(int *)(*(void *)this + 8) < ((uint64_t)&v20[v17] - *(void *)this) >> 2)
  {
    if (!CA::ShapeHandle::grow(this, v17)) {
      goto LABEL_26;
    }
    __int32 v20 = (_DWORD *)*((void *)this + 1);
  }
  for (; v17; --v17)
  {
    int v21 = *v3++;
    *v20++ = v21;
  }
  *((void *)this + 1) = v20;
LABEL_26:
  float64x2_t v23 = *(int **)this;
  int v22 = (char *)*((void *)this + 1);
  int8x16_t v24 = &v22[-*(void *)this];
  if (v24 == (char *)20)
  {
    if (v23 != (int *)((char *)this + 32))
    {
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(malloc_zone, v23);
    }
    uint64_t v26 = (void *)*((void *)this + 260);
    if (!v26) {
      return 1;
    }
LABEL_40:
    unint64_t v27 = 0;
    *uint64_t v26 = 0;
    v26[1] = 0;
    return v27;
  }
  if (v23[2] >= (uint64_t)(v24 + 8) >> 2
    || (v28 = CA::ShapeHandle::grow(this, 2), int v22 = (char *)*((void *)this + 1), v28))
  {
    *(_DWORD *)int v22 = 0x7FFFFFFF;
    v22 += 4;
    *((void *)this + 1) = v22;
  }
  int8x16_t v29 = *(_DWORD **)this;
  if (**(_DWORD **)this != 1)
  {
    if (v29 != (_DWORD *)((char *)this + 32))
    {
      int32x2_t v33 = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(v33, v29);
    }
    uint64_t v26 = (void *)*((void *)this + 260);
    if (!v26) {
      return 0;
    }
    goto LABEL_40;
  }
  int64_t v30 = v22 - (char *)v29;
  unint64_t v31 = (unint64_t)(v22 - (char *)v29) >> 2;
  v29[1] = v31;
  uint32x2_t v32 = (int *)*((void *)this + 260);
  if (v32)
  {
    CA::Shape::get_bounds((uint64_t)v29, v32);
    unint64_t v27 = 0;
    goto LABEL_53;
  }
  if (v31 != 12) {
    goto LABEL_48;
  }
  uint64_t v43 = 0;
  uint64_t v44 = 0;
  CA::Shape::get_bounds((uint64_t)v29, (int *)&v43);
  unint64_t v27 = 1;
  if ((int)v44 >= 1 && SHIDWORD(v44) >= 1)
  {
    if (!((HIDWORD(v44) | v44) >> 15) && v43 == __PAIR64__(SWORD2(v43), (__int16)v43))
    {
      unint64_t v27 = ((unint64_t)v43 << 48) | ((unint64_t)WORD2(v43) << 32) | ((unint64_t)v44 << 17) | (4 * (WORD2(v44) & 0x7FFF)) | 1;
      goto LABEL_53;
    }
LABEL_48:
    uint32x2_t v34 = (malloc_zone_t *)get_malloc_zone();
    int32x2_t v35 = malloc_type_zone_malloc(v34, v30 & 0x3FFFFFFFCLL, 0x8BB15036uLL);
    unint64_t v27 = (unint64_t)v35;
    if (v35)
    {
      if (v31)
      {
        uint32x2_t v36 = *(int **)this;
        int v37 = v31;
        float64x2_t v38 = v35;
        do
        {
          int v39 = *v36++;
          *v38++ = v39;
          --v37;
        }
        while (v37);
      }
      v35[1] = v31;
      v35[2] = v31;
    }
  }
LABEL_53:
  BOOL v40 = *(void **)this;
  if (*(CA::ShapeHandle **)this != (CA::ShapeHandle *)((char *)this + 32))
  {
    float64x2_t v41 = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(v41, v40);
  }
  return v27;
}

void CA::Render::Layer::~Layer(CA::Render::Layer *this, const CA::Render::Object *a2)
{
  CA::Render::Layer::~Layer(this, a2);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  atomic_uint *v3;
  atomic_uint *v4;
  atomic_uint *v5;
  atomic_uint *v6;
  CA::Render::Layer::Ext *v7;
  atomic_uint *v8;
  atomic_uint *v9;

  *(void *)this = &unk_1ED02F440;
  uint64_t v3 = (atomic_uint *)*((void *)this + 13);
  if (v3 && atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v3 + 16))(v3);
  }
  if ((*((unsigned char *)this + 13) & 2) == 0)
  {
    int v4 = (atomic_uint *)*((void *)this + 14);
    if (v4)
    {
      if (atomic_fetch_add(v4 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
      }
    }
  }
  uint64_t v5 = (atomic_uint *)*((void *)this + 18);
  if (v5 && atomic_fetch_add(v5 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v5 + 16))(v5);
  }
  uint64_t v6 = (atomic_uint *)*((void *)this + 17);
  if (v6 && atomic_fetch_add(v6 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v6 + 16))(v6);
  }
  uint64_t v7 = (CA::Render::Layer::Ext *)*((void *)this + 16);
  if (v7) {
    CA::Render::Layer::Ext::unref(v7);
  }
  int v8 = (atomic_uint *)*((void *)this + 15);
  if (v8 && atomic_fetch_add(v8 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v8 + 16))(v8);
  }
  uint64_t v9 = (atomic_uint *)*((void *)this + 12);
  if (v9 && atomic_fetch_add(v9 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v9 + 16))(v9);
  }
  --dword_1EB2ADE3C;
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  }
}

uint64_t get_malloc_zone(void)
{
  if (get_malloc_zone(void)::once != -1) {
    dispatch_once_f(&get_malloc_zone(void)::once, 0, (dispatch_function_t)malloc_zone_init);
  }
  return malloc_zone;
}

void CA::Render::LayerNode::update_frame_transform(uint64_t a1, double *a2)
{
  uint64_t v3 = *(float64x2_t **)(a1 + 88);
  if ((*(unsigned char *)(a1 + 26) & 2) == 0)
  {
    if (v3)
    {
      uint64_t v5 = *(void *)&v3[2].f64[0];
      uint64_t v6 = *(float64x2_t **)&v3[3].f64[1];
      uint64_t v7 = v3 + 4;
      if (*(void *)&v3[5].f64[1]) {
        BOOL v8 = (*(unsigned char *)(v5 + 13) & 9) != 0;
      }
      else {
        BOOL v8 = 0;
      }
    }
    else
    {
      uint64_t v6 = 0;
      uint64_t v7 = 0;
      BOOL v8 = 0;
      uint64_t v5 = 0;
    }
    uint64_t v9 = *(float64x2_t **)(a1 + 56);
    if (*(void *)(a1 + 144)
      || !CA::Render::Layer::compute_frame_offset(*(void *)(a1 + 32), v5, (float64x2_t *)(a1 + 64)))
    {
      if (!v9)
      {
        malloc_zone = (malloc_zone_t *)get_malloc_zone();
        uint64_t v9 = (float64x2_t *)malloc_type_zone_malloc(malloc_zone, 0x80uLL, 0x8BB15036uLL);
      }
      CA::Render::Layer::compute_frame_transform(*(void *)(a1 + 32), v5, (CA::Mat4Impl *)v9, *(const double **)(a1 + 144));
      if (a2) {
        CA::Mat4Impl::mat4_get_scale((CA::Mat4Impl *)v9, a2, a2 + 1, v23);
      }
      if (v8)
      {
        if (v6)
        {
          CA::Mat4Impl::mat4_concat(v9, v9->f64, v6->f64, v23);
        }
        else
        {
          v24.f64[0] = v7[1].f64[0];
          float64x2_t v25 = v9[1];
          float64x2_t v26 = v9[3];
          float64x2_t v27 = v9[5];
          float64x2_t v28 = v9[7];
          float64x2_t v29 = vmlaq_laneq_f64(v9[2], *v7, v26, 1);
          float64x2_t v30 = vmlaq_laneq_f64(v9[4], *v7, v27, 1);
          float64x2_t v31 = vmlaq_laneq_f64(v9[6], *v7, v28, 1);
          *uint64_t v9 = vmlaq_laneq_f64(*v9, *v7, v25, 1);
          v9[1] = vmlaq_laneq_f64(v25, v24, v25, 1);
          v9[2] = v29;
          v9[3] = vmlaq_laneq_f64(v26, v24, v26, 1);
          v9[4] = v30;
          v9[5] = vmlaq_laneq_f64(v27, v24, v27, 1);
          v9[6] = v31;
          v9[7] = vmlaq_laneq_f64(v28, v24, v28, 1);
        }
      }
      if ((*(unsigned char *)(*(void *)(a1 + 32) + 41) & 0x10) != 0
        && v9[4].f64[0] * v9[4].f64[0] + v9[4].f64[1] * v9[4].f64[1] + v9[5].f64[0] * v9[5].f64[0] == 0.0)
      {
        v9[6] = 0u;
        v9[7] = 0u;
        v9[4] = 0u;
        v9[5] = 0u;
        v9[2] = 0u;
        v9[3] = 0u;
        *uint64_t v9 = 0u;
        v9[1] = 0u;
      }
      goto LABEL_25;
    }
    if (v8)
    {
      if (v6)
      {
        if (!v9)
        {
          int v10 = (malloc_zone_t *)get_malloc_zone();
          uint64_t v9 = (float64x2_t *)malloc_type_zone_malloc(v10, 0x80uLL, 0x8BB15036uLL);
        }
        float64x2_t v11 = *v6;
        float64x2_t v12 = v6[1];
        float64x2_t v13 = v6[2];
        float64x2_t v14 = v6[3];
        *uint64_t v9 = *v6;
        v9[1] = v12;
        v9[2] = v13;
        v9[3] = v14;
        float64x2_t v15 = v6[4];
        float64x2_t v16 = v6[5];
        float64x2_t v17 = v6[6];
        float64x2_t v18 = v6[7];
        v9[4] = v15;
        v9[5] = v16;
        v9[6] = v17;
        v9[7] = v18;
        double v19 = *(double *)(a1 + 64);
        double v20 = *(double *)(a1 + 72);
        double v21 = *(double *)(a1 + 80);
        v9[6] = vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(v17, v11, v19), v13, v20), v15, v21);
        v9[7] = vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(v18, v12, v19), v14, v20), v16, v21);
LABEL_25:
        *(void *)(a1 + 56) = v9;
        goto LABEL_26;
      }
      double v47 = *(double *)(a1 + 72);
      *(double *)(a1 + 64) = *(double *)(a1 + 64) + v7->f64[0];
      *(double *)(a1 + 72) = v47 + v7->f64[1];
      *(double *)(a1 + 80) = *(double *)(a1 + 80) + v7[1].f64[0];
    }
    if (v9)
    {
      float64x2_t v48 = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(v48, v9);
      uint64_t v9 = 0;
    }
    goto LABEL_25;
  }
LABEL_26:
  uint64_t v32 = *(void *)(a1 + 32);
  uint64_t v33 = *(void *)(v32 + 144);
  if (!v33)
  {
    if (v3)
    {
      uint64_t v35 = *(void *)&v3[1].f64[1] & 0x1000001;
      goto LABEL_43;
    }
LABEL_42:
    uint64_t v35 = 0;
    goto LABEL_43;
  }
  if (!v3) {
    goto LABEL_42;
  }
  float64_t v34 = v3[1].f64[1];
  uint64_t v35 = LODWORD(v34) & 0x1000001;
  if ((*(unsigned char *)(v33 + 13) & 1) != 0
    && ((LODWORD(v34) ^ HIBYTE(LODWORD(v34))) & 1) != 0
    && (*(unsigned char *)(a1 + 26) & 2) == 0)
  {
    if ((LODWORD(v34) & 0x800000) != 0)
    {
      v35 ^= 0x1000000uLL;
    }
    else
    {
      uint32x2_t v36 = *(void **)(a1 + 56);
      if (!v36)
      {
        int v37 = (malloc_zone_t *)get_malloc_zone();
        uint32x2_t v36 = malloc_type_zone_malloc(v37, 0x80uLL, 0x8BB15036uLL);
        uint64_t v38 = *(void *)(a1 + 80);
        long long v39 = *(_OWORD *)(a1 + 64);
        *(_OWORD *)uint32x2_t v36 = xmmword_184997D50;
        *((void *)v36 + 2) = 0;
        *((void *)v36 + 3) = 0;
        *((_OWORD *)v36 + 2) = xmmword_184997D60;
        *((_OWORD *)v36 + 3) = 0u;
        *((_OWORD *)v36 + 4) = 0u;
        *((_OWORD *)v36 + 5) = xmmword_184997D50;
        *((_OWORD *)v36 + 6) = v39;
        *((_OWORD *)v36 + 7) = xmmword_184997D60;
        *((void *)v36 + 14) = v38;
        *(void *)(a1 + 56) = v36;
        uint64_t v32 = *(void *)(a1 + 32);
      }
      v35 ^= 1uLL;
      double v40 = *(double *)(v32 + 64);
      double v41 = *(double *)(v32 + 72);
      if (v40 != 0.0 || v41 != 0.0)
      {
        CA::Mat4Impl::mat4_translate((float64x2_t *)v36, a2, v40, v41, 0.0);
        double v40 = *(double *)(v32 + 64);
      }
      double v42 = *(double *)(v32 + 88);
      float64x2_t v43 = *((float64x2_t *)v36 + 2);
      float64x2_t v44 = *((float64x2_t *)v36 + 3);
      float64x2_t v45 = vmlaq_n_f64(*((float64x2_t *)v36 + 7), v44, v42);
      *((float64x2_t *)v36 + 6) = vmlaq_n_f64(*((float64x2_t *)v36 + 6), v43, v42);
      *((float64x2_t *)v36 + 7) = v45;
      *((float64x2_t *)v36 + 2) = vnegq_f64(v43);
      *((float64x2_t *)v36 + 3) = vnegq_f64(v44);
      double v46 = *(double *)(v32 + 72);
      if (v40 != 0.0 || v46 != 0.0) {
        CA::Mat4Impl::mat4_translate((float64x2_t *)v36, a2, -v40, -v46, 0.0);
      }
    }
  }
LABEL_43:
  *(void *)(a1 + 24) = (*(void *)(*(void *)(a1 + 32) + 40) >> 9) & 1 ^ v35 | *(void *)(a1 + 24) & 0xFFFFFFFFFEFFFFFELL;
}

uint64_t CA::Render::Layer::compute_frame_offset(uint64_t a1, uint64_t a2, float64x2_t *a3)
{
  uint64_t v3 = *(void *)(a1 + 128);
  if (v3 && *(void *)(v3 + 16)) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 40);
  if ((v4 & 0x2200) != 0) {
    return 0;
  }
  if (a2)
  {
    uint64_t v6 = *(void *)(a2 + 128);
    if (v6)
    {
      if (*(void *)(v6 + 24)) {
        return 0;
      }
    }
  }
  if (v3)
  {
    float64x2_t v7 = vsubq_f64(*(float64x2_t *)(a1 + 48), vmlaq_f64(*(float64x2_t *)(a1 + 64), *(float64x2_t *)(a1 + 80), *(float64x2_t *)(v3 + 168)));
    double v8 = *(double *)(v3 + 192) - *(double *)(v3 + 184);
  }
  else
  {
    float64x2_t v9 = 0uLL;
    if ((v4 & 0x400000000000) == 0)
    {
      __asm { FMOV            V1.2D, #0.5 }
      float64x2_t v9 = vmulq_f64(*(float64x2_t *)(a1 + 80), _Q1);
    }
    float64x2_t v7 = vsubq_f64(*(float64x2_t *)(a1 + 48), vaddq_f64(v9, *(float64x2_t *)(a1 + 64)));
    double v8 = 0.0;
  }
  *a3 = v7;
  a3[1].f64[0] = v8;
  return 1;
}

void CA::Render::Layer::Ext::unref(CA::Render::Layer::Ext *this)
{
  if (atomic_fetch_add((atomic_uint *volatile)this + 82, 0xFFFFFFFF) == 1)
  {
    uint64_t v2 = (atomic_uint *)*((void *)this + 18);
    if (v2 && atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v2 + 16))(v2);
    }
    uint64_t v3 = (atomic_uint *)*((void *)this + 17);
    if (v3 && atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v3 + 16))(v3);
    }
    uint64_t v4 = (atomic_uint *)*((void *)this + 16);
    if (v4 && atomic_fetch_add(v4 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
    }
    uint64_t v5 = (atomic_uint *)*((void *)this + 15);
    if (v5 && atomic_fetch_add(v5 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v5 + 16))(v5);
    }
    uint64_t v6 = (atomic_uint *)*((void *)this + 14);
    if (v6 && atomic_fetch_add(v6 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v6 + 16))(v6);
    }
    float64x2_t v7 = (atomic_uint *)*((void *)this + 13);
    if (v7 && atomic_fetch_add(v7 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v7 + 16))(v7);
    }
    double v8 = (atomic_uint *)*((void *)this + 12);
    if (v8 && atomic_fetch_add(v8 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v8 + 16))(v8);
    }
    float64x2_t v9 = (atomic_uint *)*((void *)this + 11);
    if (v9 && atomic_fetch_add(v9 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v9 + 16))(v9);
    }
    int v10 = (atomic_uint *)*((void *)this + 10);
    if (v10 && atomic_fetch_add(v10 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v10 + 16))(v10);
    }
    float64x2_t v11 = (atomic_uint *)*((void *)this + 9);
    if (v11 && atomic_fetch_add(v11 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v11 + 16))(v11);
    }
    float64x2_t v12 = (atomic_uint *)*((void *)this + 8);
    if (v12 && atomic_fetch_add(v12 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v12 + 16))(v12);
    }
    float64x2_t v13 = (atomic_uint *)*((void *)this + 7);
    if (v13 && atomic_fetch_add(v13 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v13 + 16))(v13);
    }
    float64x2_t v14 = (atomic_uint *)*((void *)this + 6);
    if (v14 && atomic_fetch_add(v14 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v14 + 16))(v14);
    }
    float64x2_t v15 = (atomic_uint *)*((void *)this + 5);
    if (v15 && atomic_fetch_add(v15 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v15 + 16))(v15);
    }
    float64x2_t v16 = (atomic_uint *)*((void *)this + 4);
    if (v16 && atomic_fetch_add(v16 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v16 + 16))(v16);
    }
    float64x2_t v17 = (atomic_uint *)*((void *)this + 3);
    if (v17 && atomic_fetch_add(v17 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v17 + 16))(v17);
    }
    float64x2_t v18 = (atomic_uint *)*((void *)this + 2);
    if (v18 && atomic_fetch_add(v18 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v18 + 16))(v18);
    }
    double v19 = (atomic_uint *)*((void *)this + 1);
    if (v19 && atomic_fetch_add(v19 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v19 + 16))(v19);
    }
    double v20 = *(atomic_uint **)this;
    if (*(void *)this && atomic_fetch_add(v20 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v20 + 16))(v20);
    }
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(malloc_zone, this);
  }
}

uint64_t CA::Render::LayerSubclass::has_depth(CA::Render::LayerSubclass *this)
{
  return 0;
}

BOOL CA::Shape::intersects(uint64_t this, uint64_t a2)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  if (this)
  {
    if (this == 1) {
      return 0;
    }
  }
  else if (*(_DWORD *)(this + 4) == 6)
  {
    return 0;
  }
  if (a2)
  {
    if (a2 == 1) {
      return 0;
    }
  }
  else if (*(_DWORD *)(a2 + 4) == 6)
  {
    return 0;
  }
  if (this)
  {
    if (this == 1)
    {
      long long v33 = 0u;
      long long v34 = 0u;
      long long v32 = 0u;
LABEL_21:
      long long v35 = xmmword_184998420;
      LODWORD(v36) = 2;
      DWORD1(v36) = (int)((unint64_t)this >> 16) >> 16;
      DWORD2(v36) = 4;
      HIDWORD(v36) = this >> 48;
      LODWORD(v37) = HIDWORD(v36) + (this >> 17);
      DWORD1(v37) = ((this >> 2) & 0x7FFF) + DWORD1(v36);
      *((void *)&v37 + 1) = 0x7FFFFFFF00000002;
      this = (uint64_t)&v35;
      goto LABEL_22;
    }
  }
  else if (*(_DWORD *)(this + 4) != 12)
  {
    long long v36 = 0u;
    long long v37 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
LABEL_22:
    uint64_t v6 = (char *)(this + 12);
    if (a2)
    {
      long long v32 = xmmword_184998420;
      LODWORD(v33) = 2;
      DWORD1(v33) = (int)((unint64_t)a2 >> 16) >> 16;
      DWORD2(v33) = 4;
      HIDWORD(v33) = a2 >> 48;
      LODWORD(v34) = HIDWORD(v33) + (a2 >> 17);
      DWORD1(v34) = ((a2 >> 2) & 0x7FFF) + DWORD1(v33);
      *((void *)&v34 + 1) = 0x7FFFFFFF00000002;
      a2 = (uint64_t)&v32;
    }
    int v7 = *(_DWORD *)v6;
    if (*(_DWORD *)v6 == 0x7FFFFFFF) {
      return 0;
    }
    double v8 = (char *)(a2 + 12);
    float64x2_t v9 = (char *)(this + 12);
    int v10 = (char *)(a2 + 12);
    while (1)
    {
      int v11 = *(_DWORD *)v10;
      if (*(_DWORD *)v10 == 0x7FFFFFFF) {
        return 0;
      }
      int v12 = v7 - v11;
      if (v7 - v11 >= 1) {
        break;
      }
      uint64_t v13 = *((int *)v6 + 1);
      float64x2_t v14 = &v6[4 * v13];
      if ((v12 & 0x80000000) == 0)
      {
        float64x2_t v9 = v6;
        goto LABEL_31;
      }
      LODWORD(v15) = *((_DWORD *)v8 + 1);
      float64x2_t v9 = v6;
LABEL_32:
      int v16 = 0;
      uint64_t v6 = v14;
      int v17 = v13 - 2;
      int v18 = v15 - 2;
      double v19 = v9 + 8;
      double v20 = v8 + 8;
      while (v17 && v18)
      {
        int v21 = *v19 - *v20;
        int v22 = v21 < 1;
        v19 += v21 < 1;
        v17 -= v22;
        v16 ^= v22;
        v20 += v21 >= 0;
        v18 -= v21 >= 0;
        if (v21 >= 0) {
          v16 ^= 2u;
        }
        if (v16 == 3) {
          return 1;
        }
      }
      BOOL result = 0;
      int v7 = *(_DWORD *)v6;
      if (*(_DWORD *)v6 == 0x7FFFFFFF) {
        return result;
      }
    }
    LODWORD(v13) = *((_DWORD *)v9 + 1);
    float64x2_t v14 = v6;
LABEL_31:
    uint64_t v15 = *((int *)v10 + 1);
    double v8 = v10;
    v10 += 4 * v15;
    goto LABEL_32;
  }
  if (a2)
  {
    if (a2 == 1)
    {
LABEL_15:
      long long v36 = 0u;
      long long v37 = 0u;
      long long v34 = 0u;
      long long v35 = 0u;
      long long v32 = 0u;
      long long v33 = 0u;
      if ((this & 1) == 0) {
        goto LABEL_22;
      }
      goto LABEL_21;
    }
  }
  else if (*(_DWORD *)(a2 + 4) != 12)
  {
    goto LABEL_15;
  }
  if (this)
  {
    uint64_t v3 = this >> 48;
    uint64_t v2 = this << 16 >> 48;
    unsigned int v4 = this >> 17;
    unsigned int v5 = (this >> 2) & 0x7FFF;
  }
  else
  {
    LODWORD(v2) = *(_DWORD *)(this + 20);
    LODWORD(v3) = *(_DWORD *)(this + 28);
    unsigned int v4 = *(_DWORD *)(this + 32) - v3;
    unsigned int v5 = *(_DWORD *)(this + 36) - v2;
  }
  int32x2_t v24 = (int32x2_t)__PAIR64__(v5, v4);
  if (a2)
  {
    uint64_t v26 = a2 >> 48;
    uint64_t v25 = a2 << 16 >> 48;
    unsigned int v27 = a2 >> 17;
    unsigned int v28 = (a2 >> 2) & 0x7FFF;
  }
  else
  {
    LODWORD(v25) = *(_DWORD *)(a2 + 20);
    LODWORD(v26) = *(_DWORD *)(a2 + 28);
    unsigned int v27 = *(_DWORD *)(a2 + 32) - v26;
    unsigned int v28 = *(_DWORD *)(a2 + 36) - v25;
  }
  uint32x2_t v29 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v24);
  if ((vpmax_u32(v29, v29).u32[0] & 0x80000000) == 0)
  {
    uint32x2_t v30 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, (int32x2_t)__PAIR64__(v28, v27));
    if ((vpmax_u32(v30, v30).u32[0] & 0x80000000) == 0)
    {
      uint32x2_t v31 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, vsub_s32(vmin_s32(vadd_s32((int32x2_t)__PAIR64__(v2, v3), v24), vadd_s32((int32x2_t)__PAIR64__(v25, v26), (int32x2_t)__PAIR64__(v28, v27))), vmax_s32((int32x2_t)__PAIR64__(v2, v3), (int32x2_t)__PAIR64__(v25, v26))));
      return vpmax_u32(v31, v31).i32[0] >= 0;
    }
  }
  return 0;
}

void CA::Render::BackdropLayer::~BackdropLayer(CA::Render::BackdropLayer *this, const CA::Render::Object *a2)
{
  *(void *)this = &unk_1ED02D828;
  uint64_t v3 = (atomic_uint *)*((void *)this + 11);
  if (v3 && atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v3 + 16))(v3);
  }
  unsigned int v4 = (atomic_uint *)*((void *)this + 3);
  if (v4 && atomic_fetch_add(v4 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
  }
  --dword_1EB2ADDD4;
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  atomic_uint *v3;
  atomic_uint *v4;

  *(void *)this = &unk_1ED02D828;
  uint64_t v3 = (atomic_uint *)*((void *)this + 11);
  if (v3 && atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v3 + 16))(v3);
  }
  unsigned int v4 = (atomic_uint *)*((void *)this + 3);
  if (v4 && atomic_fetch_add(v4 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
  }
  --dword_1EB2ADDD4;
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  }
}

uint64_t CA::OGL::ImagingNode::propagate_soft_roi(uint64_t result, int32x2_t *a2)
{
  uint64_t v3 = result;
  uint64_t v4 = 0;
  char v5 = 1;
  do
  {
    char v6 = v5;
    int v7 = *(int32x2_t **)(v3 + 8 * v4 + 24);
    if (v7) {
      BOOL result = CA::BoundsImpl::Union(v7 + 24, *a2, a2[1]);
    }
    char v5 = 0;
    uint64_t v4 = 1;
  }
  while ((v6 & 1) != 0);
  return result;
}

void CA::Render::GradientLayer::~GradientLayer(CA::Render::GradientLayer *this)
{
  *(void *)this = &unk_1ED02D9A0;
  uint64_t v2 = (const void *)*((void *)this + 17);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (const void *)*((void *)this + 16);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = (atomic_uint *)*((void *)this + 15);
  if (v4 && atomic_fetch_add(v4 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
  }
  char v5 = (atomic_uint *)*((void *)this + 14);
  if (v5 && atomic_fetch_add(v5 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v5 + 16))(v5);
  }
  CA::Render::InterpolatedFunction::~InterpolatedFunction((void **)this + 2);
  --dword_1EB2ADE18;
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, v6);
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  const void *v2;
  const void *v3;
  atomic_uint *v4;
  atomic_uint *v5;
  const CA::Render::Object *v6;

  *(void *)this = &unk_1ED02D9A0;
  uint64_t v2 = (const void *)*((void *)this + 17);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (const void *)*((void *)this + 16);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = (atomic_uint *)*((void *)this + 15);
  if (v4 && atomic_fetch_add(v4 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
  }
  char v5 = (atomic_uint *)*((void *)this + 14);
  if (v5 && atomic_fetch_add(v5 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v5 + 16))(v5);
  }
  CA::Render::InterpolatedFunction::~InterpolatedFunction((void **)this + 2);
  --dword_1EB2ADE18;
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, v6);
  }
}

void CA::Render::InterpolatedFunction::~InterpolatedFunction(void **this)
{
  *this = &unk_1ED02EC98;
  free(this[4]);
  free(this[6]);
  --dword_1EB2ADE10;
  *this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate((CA::Render::Encoder::ObjectCache *)this, v2);
  }
}

{
  malloc_zone_t *malloc_zone;
  uint64_t vars8;

  CA::Render::InterpolatedFunction::~InterpolatedFunction(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

uint64_t CA::OGL::CacheNode::propagate_roi(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 56))(*(void *)(a1 + 24));
  *(_DWORD *)(*(void *)(a1 + 24) + 216) = *(_DWORD *)(*(void *)(a1 + 24) + 216) & 0xFFC00000 | *(_DWORD *)(a1 + 216) & 0x3FFFFF;
  *(_DWORD *)(*(void *)(a1 + 24) + 216) |= 0x400u;
  *(_WORD *)(*(void *)(a1 + 24) + 212) = *(_WORD *)(*(void *)(a1 + 24) + 212) & 0xFDFF | *(_WORD *)(a1 + 212) & 0x200;
  *(_WORD *)(*(void *)(a1 + 24) + 212) = *(_WORD *)(*(void *)(a1 + 24) + 212) & 0xC3FF | *(_WORD *)(a1 + 212) & 0x3C00;
  return result;
}

uint64_t CA::OGL::QuadNode::apply(uint64_t result, uint64_t *a2, int32x4_t a3, int32x4_t a4, uint64_t a5, double *a6)
{
  v63[2] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *a2;
  if (*a2)
  {
    uint64_t v8 = result;
    float64x2_t v9 = **(CA::OGL::Context ***)(result + 8);
    int v10 = *(_DWORD *)(v6 + 40);
    int v11 = *(_DWORD *)(v6 + 44);
    if (v10 <= v11) {
      int v12 = *(_DWORD *)(v6 + 44);
    }
    else {
      int v12 = *(_DWORD *)(v6 + 40);
    }
    a3.i32[0] = 1073741822;
    a4.i32[0] = v12;
    int8x16_t v13 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(a4, a3), 0);
    uint64_t v14 = *(void *)(v6 + 32);
    v15.i64[0] = (int)v14;
    v15.i64[1] = SHIDWORD(v14);
    int8x16_t v16 = vbslq_s8(v13, (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v15));
    double v17 = (double)v10;
    double v18 = (double)v11;
    if (v12 > 1073741822)
    {
      double v17 = 1.79769313e308;
      double v18 = 1.79769313e308;
    }
    int8x16_t v61 = v16;
    v62.f64[0] = v17;
    v62.f64[1] = v18;
    v63[0] = 0;
    v19.n128_f64[1] = v18;
    float64x2_t v50 = v62;
    float64x2_t v51 = (float64x2_t)v16;
    v19.n128_u64[0] = (unint64_t)vcvt_f32_f64(v62);
    v63[1] = v19.n128_u64[0];
    uint64_t v20 = *((void *)v9 + 2);
    unsigned int v21 = *(unsigned __int8 *)(v20 + 480);
    if (v21 >= 2 && (v21 != 3 || (*(_WORD *)(v6 + 75) & 0x800) == 0))
    {
      *(unsigned char *)(v20 + 481) |= 1u;
      uint64_t v20 = *((void *)v9 + 2);
    }
    *(void *)(v20 + 8) = *(void *)(result + 88);
    double v59 = 1.0;
    double v60 = 1.0;
    if ((*(_WORD *)(result + 224) & 0xF) == 0xA)
    {
      uint64_t v22 = *(void *)(result + 80);
      if ((*(unsigned char *)(v22 + 144) & 0x10) != 0)
      {
        v19.n128_f64[0] = CA::Mat4Impl::mat4_get_scale((CA::Mat4Impl *)v22, &v60, &v59, a6);
      }
      else
      {
        v19.n128_u64[0] = *(void *)(v22 + 128);
        double v59 = v19.n128_f64[0];
        double v60 = v19.n128_f64[0];
      }
    }
    int v23 = (*(uint64_t (**)(CA::OGL::Context *, uint64_t, __n128))(*(void *)v9 + 184))(v9, 29, v19);
    uint64_t v24 = *a2;
    if (v23) {
      BOOL v25 = v60 < 1.0;
    }
    else {
      BOOL v25 = 0;
    }
    if (v25 && v59 < 1.0)
    {
      double v55 = v60;
      double v56 = v59;
      uint64_t result = (*(uint64_t (**)(CA::OGL::Context *, uint64_t, double *, void, uint64_t, double))(*(void *)v9 + 864))(v9, v24, &v55, *(void *)(v8 + 80), 2, 0.0);
    }
    else
    {
      CA::OGL::Context::bind_surface((uint64_t)v9, v24, 0, *(_WORD *)(v8 + 224) & 0xF, *(_WORD *)(v8 + 224) >> 4, *(float *)(v8 + 228));
      int v27 = *(unsigned __int8 *)(v8 + 225);
      unsigned int v28 = *(float64x2_t **)(v8 + 80);
      double v55 = COERCE_DOUBLE(&v61);
      double v56 = *(double *)&v28;
      uint64_t v30 = CA::OGL::transform_filter_bits(v28, v29, 1.0, 1.0);
      v31.i64[0] = 1.0;
      LODWORD(v57) = CA::OGL::rect_filter_bits(v28, v30, v32, v51, v50, v31, 1.0);
      DWORD1(v57) = v27;
      long long v58 = 0uLL;
      *((void *)&v57 + 1) = 0;
      CA::OGL::fill_rect_tex(v9, (uint64_t)&v55, (uint64_t)v63, v33);
      uint64_t result = CA::OGL::Context::unbind_surface(v9, *a2, 0);
    }
    *(unsigned char *)(*((void *)v9 + 2) + 481) &= ~1u;
    unsigned int v37 = *(_DWORD *)(v8 + 220);
    if ((v37 & 0xE0000) != 0)
    {
      int v38 = *(_DWORD *)(*a2 + 40);
      int v39 = *(_DWORD *)(*a2 + 44);
      if (v38 <= v39) {
        int v40 = *(_DWORD *)(*a2 + 44);
      }
      else {
        int v40 = *(_DWORD *)(*a2 + 40);
      }
      v35.i32[0] = 1073741822;
      v36.i32[0] = v40;
      int8x16_t v41 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v36, v35), 0);
      uint64_t v42 = *(void *)(*a2 + 32);
      v43.i64[0] = (int)v42;
      v43.i64[1] = SHIDWORD(v42);
      int8x16_t v45 = (int8x16_t)vcvtq_f64_s64(v43);
      int8x16_t v44 = vbslq_s8(v41, (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), v45);
      v45.i64[0] = 0x7FEFFFFFFFFFFFFFLL;
      if (v40 <= 1073741822) {
        double v46 = (double)v38;
      }
      else {
        double v46 = 1.79769313e308;
      }
      if (v40 <= 1073741822) {
        *(double *)v45.i64 = (double)v39;
      }
      int8x16_t v52 = v44;
      double v53 = v46;
      uint64_t v54 = v45.i64[0];
      double v47 = *(double *)(v8 + 80);
      double v55 = COERCE_DOUBLE(&v52);
      double v56 = v47;
      long long v57 = 0u;
      long long v58 = 0u;
      unsigned int v48 = ((v37 >> 17) & 7) - 1;
      if (v48 > 6) {
        int64x2_t v49 = 0;
      }
      else {
        int64x2_t v49 = (double *)dword_1849A40A4[v48];
      }
      return CA::OGL::fill_color_rect((uint64_t)v9, (uint64_t)&v55, v49, v34, 0.0, v45);
    }
  }
  return result;
}

void CA::OGL::render_border(CA::OGL::Context *this, uint64_t a2, double *a3)
{
  uint64_t v95 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a2 + 24);
  uint64_t v4 = *(float32x4_t **)(v3 + 128);
  if (v4)
  {
    float v5 = v4[14].f32[3];
    if (v5 > 0.001)
    {
      uint64_t v8 = v4[8].i64[0];
      uint64_t v9 = *((void *)this + 31);
      double v10 = COERCE_DOUBLE(vcvt_f16_f32(v4[15]));
      float16x4_t v11 = *(float16x4_t *)(v9 + 32);
      _ZF = *(void *)&v11 == 0x3C003C003C003C00;
      double v13 = COERCE_DOUBLE(vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16(v11), vcvtq_f32_f16(*(float16x4_t *)&v10))));
      if (*(void *)&v11 == 0x3C003C003C003C00) {
        double v14 = v10;
      }
      else {
        double v14 = v13;
      }
      double v15 = v10;
      if (!_ZF) {
        double v15 = v13;
      }
      if (v15 != 0.0 || CA::OGL::Context::need_transparent_source(this))
      {
        if (byte_1EB2ACC6F) {
          double v14 = 1.10008404e-19;
        }
        float64x2_t v17 = *(float64x2_t *)(v3 + 64);
        float64x2_t v16 = *(float64x2_t *)(v3 + 80);
        float64x2_t v93 = v17;
        float64x2_t v94 = v16;
        double v18 = v5;
        double v19 = v4[14].f32[1];
        if ((*(unsigned char *)(a2 + 32) & 1) != 0 || (uint64_t v20 = *(void *)(a2 + 104)) != 0 && (*(unsigned char *)(v20 + 222) & 0x20) != 0)
        {
          if (v16.f64[0] <= v16.f64[1]) {
            double v21 = v16.f64[1];
          }
          else {
            double v21 = v16.f64[0];
          }
          if (v21 < 1.79769313e308)
          {
            double v22 = v16.f64[0] >= v16.f64[1] ? v16.f64[1] : v16.f64[0];
            if (v22 > 0.0)
            {
              __asm { FMOV            V3.2D, #-1.0 }
              float64x2_t v93 = vaddq_f64(v17, _Q3);
              v94.f64[0] = v16.f64[0] + 2.0;
              v94.f64[1] = v16.f64[1] + 2.0;
              if (v16.f64[0] + 2.0 <= 0.0 || v16.f64[1] + 2.0 <= 0.0) {
                float64x2_t v94 = 0uLL;
              }
            }
          }
          double v19 = v19 + 1.0;
          double v18 = v18 + 1.0;
        }
        float v27 = v4[14].f32[2];
        if (v27 != 0.0)
        {
          double v28 = v27;
          if (v19 + v28 >= 0.0) {
            double v19 = v19 + v28;
          }
          else {
            double v19 = 0.0;
          }
          CA::BoundsImpl::inset(v93.f64, -v28, -v28);
        }
        float64x2_t v86 = v93;
        float64x2_t v91 = v93;
        float64x2_t v92 = v94;
        float64x2_t v85 = v94;
        CA::Rect::apply_transform((int8x16_t *)&v91, *(const CA::Transform **)(v9 + 24), a3);
        int64x2_t v29 = vceqzq_f64(v92);
        unint64_t v30 = vorrq_s8((int8x16_t)vdupq_laneq_s64(v29, 1), (int8x16_t)v29).u64[0];
        float64x2_t v84 = v92;
        float64x2_t v83 = v91;
        if ((v30 & 0x8000000000000000) != 0
          || (int8x16_t v31 = vorrq_s8((int8x16_t)vcltzq_f64(v92), (int8x16_t)vcgezq_f64(v92)),
              (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v31), 1), v31).u64[0] & 0x8000000000000000) != 0))
        {
          int32x4_t v88 = 0uLL;
        }
        else
        {
          int32x4_t v32 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v91, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
          int32x4_t v88 = vuzp1q_s32(v32, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v91, v92), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v32));
        }
        if (CA::Shape::intersects(*(void *)(v9 + 8), (int32x2_t *)&v88))
        {
          long long v34 = *(float64x2_t **)(v9 + 24);
          uint64_t v35 = CA::OGL::transform_filter_bits(v34, v33, 1.0, 1.0);
          v36.i64[0] = 1.0;
          int v38 = CA::OGL::rect_filter_bits(v34, v35, v37, v86, v85, v36, 1.0);
          int v39 = v38;
          if (v8)
          {
            uint64_t v40 = *(void *)(a2 + 24);
            int v41 = *(_DWORD *)(v40 + 36);
            if ((v41 & 0xFu) > 0xA) {
              unsigned int v42 = 1;
            }
            else {
              unsigned int v42 = CA::OGL::texture_filter(CA::Render::ImageFilter)::filters[v41 & 0xF];
            }
            uint64_t v49 = v41 >> 4;
            if (v49 > 0xA) {
              int v50 = 1;
            }
            else {
              int v50 = CA::OGL::texture_filter(CA::Render::ImageFilter)::filters[v49];
            }
            uint64_t v51 = *(void *)(v40 + 128);
            if (v51) {
              float v52 = *(float *)(v51 + 292);
            }
            else {
              float v52 = 0.0;
            }
            uint64_t v53 = *(void *)(a2 + 16);
            if ((v30 & 0x8000000000000000) != 0
              || (int8x16_t v54 = vorrq_s8((int8x16_t)vcltzq_f64(v84), (int8x16_t)vcgezq_f64(v84)),
                  (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v54), 1), v54).u64[0] & 0x8000000000000000) != 0))
            {
              int32x4_t v87 = 0uLL;
            }
            else
            {
              int32x4_t v55 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v83, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
              int32x4_t v87 = vuzp1q_s32(v55, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v83, v84), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v55));
            }
            float64_t v56 = *(double *)(v53 + 24);
            long long v57 = (CA::Shape *)CA::Shape::intersect(*(CA::Shape **)(v9 + 8), (const CA::Bounds *)&v87);
            CA::Shape::get_bounds((uint64_t)v57, v87.i32);
            uint64_t v58 = (*(uint64_t (**)(CA::OGL::Context *, uint64_t, int32x4_t *, uint64_t))(*(void *)this + 656))(this, 1, &v87, 15);
            if (v58)
            {
              double v59 = (_DWORD *)v58;
              v86.f64[0] = v56;
              MEMORY[0x1F4188790](v58);
              uint64_t v78 = 0x3C003C003C003C00;
              uint64_t v81 = 0;
              uint64_t v82 = 0;
              uint64_t v79 = 0;
              uint64_t v80 = 0;
              long long v76 = *(_OWORD *)(v9 + 8);
              uint64_t v77 = *(void *)(v9 + 24);
              LODWORD(v82) = *(_DWORD *)(v9 + 64);
              WORD2(v82) = *(_WORD *)(v9 + 68) & 0x500 | 4;
              uint64_t v75 = 0;
              *(void *)&long long v76 = v57;
              uint64_t v75 = CA::OGL::Context::set_gstate((uint64_t)this, (uint64_t)&v75);
              CA::OGL::Context::push_surface((uint64_t)this, (uint64_t)v59, 1u, 2, 0);
              *(void *)(*((void *)this + 2) + 8) = 0x3C003C003C003C00;
              uint64_t v60 = *(void *)(a2 + 24);
              uint64_t v61 = *(void *)(v60 + 128);
              if (v61 && (uint64_t v62 = *(void *)(v61 + 72)) != 0)
              {
                int v71 = (*(unsigned __int16 *)(a2 + 40) >> 6);
                float64_t v72 = *(double *)(v9 + 24);
                v88.i64[0] = (uint64_t)&v93;
                *(float64_t *)&v88.i64[1] = v72;
                int v89 = v39;
                *(_DWORD *)int8x16_t v90 = v71;
                memset(&v90[4], 0, 24);
                CA::OGL::stroke_uneven_round_rect((uint64_t)this, (float64x2_t **)&v88, (double *)(v62 + 24), (double *)(*(_DWORD *)(v60 + 40) & 3), v18);
              }
              else
              {
                int v63 = (*(unsigned __int16 *)(a2 + 40) >> 6);
                float64_t v64 = *(double *)(v9 + 24);
                v88.i64[0] = (uint64_t)&v93;
                *(float64_t *)&v88.i64[1] = v64;
                int v89 = v39;
                *(_DWORD *)int8x16_t v90 = v63;
                memset(&v90[4], 0, 24);
                CA::OGL::stroke_round_rect(this, (float64x2_t **)&v88, (double *)(*(_WORD *)(v60 + 38) & 0xF), (double *)(*(_DWORD *)(v60 + 40) & 3), v19, v18);
              }
              *(unsigned char *)(*((void *)this + 2) + 481) |= 1u;
              *(double *)(*((void *)this + 2) + 8) = v14;
              int32x4_t v88 = 0uLL;
              CA::OGL::fill_pattern_rect((uint64_t)this, v8, (uint64_t)&v93, (float64x2_t *)&v88, *(void *)(*((void *)this + 31) + 24), &v91, v42, v50, v52, LOBYTE(v86.f64[0]) & 1, 0);
              *(unsigned char *)(*((void *)this + 2) + 481) &= ~1u;
              CA::OGL::Context::pop_surface(this);
              CA::OGL::Context::set_gstate((uint64_t)this, **((void **)this + 31));
              uint64_t v65 = *((void *)this + 2);
              if (*(unsigned __int8 *)(v65 + 480) >= 2u) {
                *(unsigned char *)(v65 + 481) |= 1u;
              }
              int64x2_t v66 = *(CA::Shape **)(v9 + 8);
              int32x4_t v88 = 0uLL;
              CA::OGL::emit_combine((uint64_t)this, 1u, v59, 0, v66, (unsigned int *)&v88);
              *(unsigned char *)(*((void *)this + 2) + 481) &= ~1u;
              CA::OGL::Context::release_surface((uint64_t)this, (uint64_t)v59);
            }
            CA::Shape::unref(v57);
            if (byte_1EB2ACBE1)
            {
              float64_t v70 = *(double *)(v9 + 24);
              v88.i64[0] = (uint64_t)&v93;
              *(float64_t *)&v88.i64[1] = v70;
              int v89 = v39;
              memset(v90, 0, sizeof(v90));
              CA::OGL::fill_color_rect((uint64_t)this, (uint64_t)&v88, (double *)0x80800080, v67, v68, v69);
            }
          }
          else
          {
            uint64_t v43 = *((void *)this + 2);
            if (*(unsigned __int8 *)(v43 + 480) >= 2u)
            {
              *(unsigned char *)(v43 + 481) |= 1u;
              uint64_t v43 = *((void *)this + 2);
            }
            *(double *)(v43 + 8) = v14;
            uint64_t v44 = *(void *)(a2 + 24);
            uint64_t v45 = *(void *)(v44 + 128);
            if (v45 && (uint64_t v46 = *(void *)(v45 + 72)) != 0)
            {
              int v73 = (*(unsigned __int16 *)(a2 + 40) >> 6);
              float64_t v74 = *(double *)(v9 + 24);
              v88.i64[0] = (uint64_t)&v93;
              *(float64_t *)&v88.i64[1] = v74;
              int v89 = v38;
              *(_DWORD *)int8x16_t v90 = v73;
              memset(&v90[4], 0, 24);
              CA::OGL::stroke_uneven_round_rect((uint64_t)this, (float64x2_t **)&v88, (double *)(v46 + 24), (double *)(*(_DWORD *)(v44 + 40) & 3), v18);
            }
            else
            {
              int v47 = (*(unsigned __int16 *)(a2 + 40) >> 6);
              float64_t v48 = *(double *)(v9 + 24);
              v88.i64[0] = (uint64_t)&v93;
              *(float64_t *)&v88.i64[1] = v48;
              int v89 = v38;
              *(_DWORD *)int8x16_t v90 = v47;
              memset(&v90[4], 0, 24);
              CA::OGL::stroke_round_rect(this, (float64x2_t **)&v88, (double *)(*(_WORD *)(v44 + 38) & 0xF), (double *)(*(_DWORD *)(v44 + 40) & 3), v19, v18);
            }
            *(unsigned char *)(*((void *)this + 2) + 481) &= ~1u;
          }
        }
      }
    }
  }
}

uint64_t CA::OGL::RenderSurface::set_dest(CA::OGL::RenderSurface *this, float a2, int a3)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  if (*((void *)this + 3)) {
    return 1;
  }
  uint64_t v7 = *((void *)this + 1);
  uint64_t v8 = **(void **)(v7 + 8);
  int8x16_t v49 = 0uLL;
  CA::Shape::get_bounds(v7 + 144, v49.i32);
  int32x2_t v12 = *(int32x2_t *)v49.i8;
  int8x16_t v48 = v49;
  int32x2_t v13 = (int32x2_t)vextq_s8(v48, v48, 8uLL).u64[0];
  if (a2 != 1.0)
  {
    int v14 = v49.i32[3];
    if (v49.i32[2] > v49.i32[3]) {
      int v14 = v49.i32[2];
    }
    v9.i32[0] = 1073741822;
    v10.i32[0] = v14;
    v15.i64[0] = v49.i32[0];
    v15.i64[1] = v49.i32[1];
    int8x16_t v16 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v10, v9), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v15));
    v15.i64[0] = v13.i32[0];
    v15.i64[1] = v13.i32[1];
    int8x16_t v17 = (int8x16_t)vcvtq_f64_s64(v15);
    int32x2_t v18 = vdup_n_s32(v14 > 1073741822);
    v15.i64[0] = v18.u32[0];
    v15.i64[1] = v18.u32[1];
    int8x16_t v19 = vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v15, 0x3FuLL)), (int8x16_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL), v17);
    double v20 = a2;
    v11.f64[0] = 1.79769313e308;
    int8x16_t v21 = (int8x16_t)vdupq_lane_s64(vcgtq_f64(v11, (float64x2_t)v19).i64[0], 0);
    v22.i64[1] = v16.i64[1];
    *(double *)v22.i64 = a2 * *(double *)v16.i64;
    float64x2_t v23 = (float64x2_t)vbslq_s8(v21, v22, v16);
    v22.i64[1] = v19.i64[1];
    *(double *)v22.i64 = a2 * *(double *)v19.i64;
    float64x2_t v24 = (float64x2_t)vbslq_s8(v21, v22, v19);
    if (v24.f64[1] < 1.79769313e308)
    {
      v23.f64[1] = vmuld_lane_f64(v20, v23, 1);
      v24.f64[1] = v24.f64[1] * v20;
    }
    int64x2_t v25 = vceqzq_f64(v24);
    if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v25, 1), (int8x16_t)v25).u64[0] & 0x8000000000000000) != 0
      || (int8x16_t v26 = vorrq_s8((int8x16_t)vcltzq_f64(v24), (int8x16_t)vcgezq_f64(v24)),
          (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v26), 1), v26).u64[0] & 0x8000000000000000) != 0))
    {
      int8x16_t v49 = 0uLL;
      int32x2_t v12 = 0;
      int32x2_t v13 = 0;
    }
    else
    {
      float64x2_t v27 = vmaxnmq_f64(v23, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000));
      float64x2_t v28 = vminnmq_f64(vaddq_f64(v23, v24), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL));
      int32x4_t v29 = (int32x4_t)vcvtmq_s64_f64(v27);
      int32x4_t v30 = (int32x4_t)vsubq_s64(vcvtpq_s64_f64(v28), (int64x2_t)v29);
      int8x16_t v49 = (int8x16_t)vuzp1q_s32(v29, v30);
      int32x2_t v12 = vmovn_s64((int64x2_t)v29);
      int32x2_t v13 = vmovn_s64((int64x2_t)v30);
    }
  }
  uint64_t v31 = *((void *)this + 1);
  unsigned int v32 = (*(unsigned __int16 *)(v31 + 212) >> 10) & 0xF;
  unsigned int v33 = 32 * v32;
  if (v32)
  {
    int32x2_t v34 = vadd_s32((int32x2_t)vand_s8((int8x8_t)v12, (int8x8_t)vdup_n_s32(v32 - 1)), vdup_n_s32(v32));
    *(int32x2_t *)v49.i8 = vsub_s32(v12, v34);
    v49.u64[1] = (unint64_t)vadd_s32(v34, vadd_s32(v13, vdup_n_s32(v33)));
  }
  __int16 v35 = *(_WORD *)(v31 + 124);
  if ((v35 & 0x200) != 0 || (uint64_t v36 = *(void *)(*(void *)(*(void *)(v31 + 16) + 16) + 208)) == 0)
  {
    __int16 v40 = 0;
    uint64_t v39 = *((unsigned int *)this + 5);
  }
  else
  {
    BOOL v37 = CA::Shape::contains(v36, (const CA::Bounds *)&v48);
    unsigned int v38 = *((_DWORD *)this + 5);
    if (v37) {
      uint64_t v39 = v38 & 0xFFFFFFF7;
    }
    else {
      uint64_t v39 = v38;
    }
    if (v37) {
      __int16 v40 = 2048;
    }
    else {
      __int16 v40 = 0;
    }
  }
  uint64_t v41 = (*(uint64_t (**)(uint64_t, void, int8x16_t *, uint64_t))(*(void *)v8 + 656))(v8, *((unsigned int *)this + 4), &v49, v39);
  *((void *)this + 3) = v41;
  if (!v41) {
    return 0;
  }
  if (v32)
  {
    *(int32x2_t *)(v41 + 40) = vsub_s32(*(int32x2_t *)(v41 + 40), vdup_n_s32(v33));
    *(_WORD *)(v41 + 75) = *(_WORD *)(v41 + 75) & 0xFFF0 | v32;
  }
  if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v8 + 184))(v8, 25))
  {
    int32x2_t v42 = vmax_s32(vsub_s32(vadd_s32(*(int32x2_t *)(*((void *)this + 1) + 200), *(int32x2_t *)(*((void *)this + 1) + 192)), vadd_s32(*(int32x2_t *)v49.i8, (int32x2_t)v49.u64[1])), 0);
    if (v32)
    {
      v43.i64[0] = v42.u32[0];
      v43.i64[1] = v42.u32[1];
      int8x16_t v44 = (int8x16_t)vcvtq_f64_s64(v43);
      int8x16_t v45 = (int8x16_t)vdupq_lane_s64(COERCE__INT64((double)v32 * 32.0), 0);
      int32x2_t v42 = vmovn_s64(vcvtq_s64_f64((float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v44, (float64x2_t)v45), v44, v45)));
    }
    (*(void (**)(uint64_t, void, void, void))(*(void *)v8 + 704))(v8, *((void *)this + 3), v42.u32[0], v42.u32[1]);
  }
  *((float *)this + 8) = a2;
  *(_WORD *)(*((void *)this + 3) + 75) = *(_WORD *)(*((void *)this + 3) + 75) & 0xFBFF | (2 * (v35 & 0x200));
  *(_WORD *)(*((void *)this + 3) + 75) = *(_WORD *)(*((void *)this + 3) + 75) & 0xF7FF | v40;
  uint64_t v46 = *((void *)this + 3);
  uint64_t v3 = 1;
  CA::OGL::Context::push_surface(v8, v46, 1u, a3, 0);
  return v3;
}

uint64_t CA::OGL::CombineNode::propagate_roi(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = 0;
  char v5 = 1;
  do
  {
    char v6 = v5;
    uint64_t result = *(void *)(a1 + 8 * v4 + 24);
    if (result) {
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 56))(result, a2);
    }
    char v5 = 0;
    uint64_t v4 = 1;
  }
  while ((v6 & 1) != 0);
  uint64_t v8 = *(void *)(a1 + 24);
  if (v8)
  {
    if (*(void *)(a1 + 32))
    {
      if (*(unsigned char *)(a1 + 224) != 5)
      {
        *(_WORD *)(v8 + 212) |= 0x200u;
        *(_WORD *)(*(void *)(a1 + 32) + 212) |= 0x200u;
        return result;
      }
      *(_DWORD *)(v8 + 220) |= 0x1000000u;
      *(_DWORD *)(*(void *)(a1 + 32) + 220) |= 0x1000000u;
      uint64_t v8 = *(void *)(a1 + 32);
    }
    if ((*(unsigned char *)(v8 + 222) & 0x10) == 0) {
      *(_DWORD *)(v8 + 216) |= 0x800u;
    }
  }
  return result;
}

void CA::OGL::MaskNode::~MaskNode(CA::OGL::MaskNode *this)
{
  *(void *)this = &unk_1ED02BFF0;
  uint64_t v1 = (void *)*((void *)this + 29);
  if (v1)
  {
    uint64_t v2 = (CA::OGL::Renderer *)*((void *)this + 1);
    do
    {
      uint64_t v3 = (void *)*v1;
      CA::OGL::Renderer::dealloc_layer(v2, (uint64_t)v1);
      uint64_t v1 = v3;
    }
    while (v3);
  }
}

{
  CA::OGL::MaskNode::~MaskNode(this);
  abort();
}

void CA::OGL::MaskNode::apply(uint64_t a1, const double *a2)
{
  uint64_t v86 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(const Rect ***)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  char v5 = (Rect *)*v4;
  if (!*(void *)(a1 + 24))
  {
    uint64_t v30 = *(void *)(v3 + 32);
    if ((v30 & 2) != 0)
    {
      if (*(unsigned char *)(a1 + 224))
      {
        uint64_t v31 = *(void **)(a1 + 232);
      }
      else
      {
        uint64_t v31 = (void *)CA::OGL::prepare_layer(*(void *)(a1 + 8), *(void *)(*(void *)(v3 + 16) + 128), (const CA::Render::TransitionSubclass *)v3, a1 + 56, 0x4000000, (*(_DWORD *)(a1 + 220) >> 22) & 1);
        *(void *)(a1 + 232) = v31;
        *(unsigned char *)(a1 + 224) |= 1u;
      }
      uint64_t v32 = CA::OGL::prepare_layers_roi(v4, v31, a1 + 56);
      CA::OGL::render_layers((uint64_t *)v4, v32);
      *(void *)(a1 + 232) = 0;
      *(unsigned char *)(a1 + 224) &= ~1u;
      uint64_t v30 = *(void *)(v3 + 32);
      if (v30)
      {
        *(unsigned char *)(*(void *)&v5[2] + 481) |= 1u;
        uint64_t v30 = *(void *)(v3 + 32);
      }
    }
    if ((v30 & 1) == 0) {
      goto LABEL_52;
    }
    *(void *)(*(void *)&v5[2] + 8) = 0x3C003C003C003C00;
    uint64_t v33 = *(void *)(v3 + 24);
    float64x2_t v69 = *(float64x2_t *)(v33 + 80);
    float64x2_t v75 = *(float64x2_t *)(v33 + 64);
    float64x2_t v68 = v75;
    float64x2_t v76 = v69;
    int v34 = (*(unsigned __int16 *)(v3 + 40) >> 6);
    __int16 v35 = *(float64x2_t **)(a1 + 80);
    *(void *)&v84[0] = &v75;
    *((void *)&v84[0] + 1) = v35;
    uint64_t v36 = CA::OGL::transform_filter_bits(v35, a2, 1.0, 1.0);
    v37.i64[0] = 1.0;
    LODWORD(v84[1]) = CA::OGL::rect_filter_bits(v35, v36, v38, v68, v69, v37, 1.0);
    DWORD1(v84[1]) = v34;
    v84[2] = 0uLL;
    *((void *)&v84[1] + 1) = 0;
    float v44 = 0.0;
    uint64_t v45 = *(void *)(v33 + 128);
    if (v45)
    {
      uint64_t v46 = *(void *)(v45 + 72);
      if (v46)
      {
        CA::OGL::fill_uneven_round_rect((CA::OGL::Context *)v5, (uint64_t)v84, (double *)(v46 + 24), (double *)(*(_DWORD *)(v33 + 40) & 3), 0.0, v39, v40, v41, v42, v43);
LABEL_52:
        *(unsigned char *)(*(void *)&v5[2] + 481) &= ~1u;
        return;
      }
      uint64_t v59 = *(void *)(v45 + 56);
      if (v59)
      {
        uint64_t v60 = (double *)(*(uint64_t (**)(uint64_t, double))(*(void *)v59 + 80))(v59, 0.0);
        uint64_t v61 = *(void *)(v3 + 24);
        uint64_t v62 = *(void *)(v61 + 128);
        if (v62)
        {
          uint64_t v63 = *(void *)(v62 + 64);
          if (v63)
          {
            if (*(_DWORD *)(v63 + 16) > 3u)
            {
              float64x2_t v67 = vsubq_f64(*(float64x2_t *)(v63 + 40), *(float64x2_t *)(v63 + 24));
              long long v82 = *(_OWORD *)(v63 + 24);
              float64x2_t v83 = v67;
            }
            else
            {
              long long v82 = 0u;
              float64x2_t v83 = 0u;
            }
          }
          else
          {
            __asm { FMOV            V0.2D, #0.5 }
            long long v82 = _Q0;
            float64x2_t v83 = 0uLL;
          }
          float v65 = *(float *)(v62 + 228);
        }
        else
        {
          __asm { FMOV            V0.2D, #0.5 }
          long long v82 = _Q0;
          float64x2_t v83 = 0uLL;
          float v65 = 0.0;
        }
        CA::OGL::fill_corner_rect((uint64_t)v5, (double **)v84, v60, (double *)&v82, *(_DWORD *)(*(void *)(v3 + 16) + 24) & 1, (*(void *)(v61 + 40) >> 41) & 1, *(_WORD *)(v61 + 38) & 0xF, v65, v65);
        goto LABEL_52;
      }
      float v44 = *(float *)(v45 + 228);
    }
    CA::OGL::fill_round_rect((uint64_t)v5, (float64x2_t **)v84, (double *)(*(_WORD *)(v33 + 38) & 0xF), (double *)(*(_DWORD *)(v33 + 40) & 3), v44, v44);
    goto LABEL_52;
  }
  uint64_t v7 = *(float64x2_t **)(v3 + 24);
  float64x2_t v8 = v7[5];
  float64x2_t v80 = v7[4];
  float64x2_t v81 = v8;
  Rect v9 = v5[2];
  if (*(unsigned __int8 *)(*(void *)&v9 + 480) >= 2u)
  {
    *(unsigned char *)(*(void *)&v9 + 481) |= 1u;
    Rect v9 = v5[2];
  }
  *(void *)(*(void *)&v9 + 8) = *(void *)(a1 + 88);
  float v10 = 0.0;
  CA::OGL::Context::bind_surface((uint64_t)v5, *(void *)a2, 0, 0, 0, 0.0);
  float64x2_t v11 = (CA::Shape *)CA::Shape::intersect(*(CA::Shape **)(a1 + 64), (const CA::Bounds *)(*(void *)a2 + 32));
  memset(v84, 0, sizeof(v84));
  uint64_t v85 = 0;
  *(_OWORD *)((char *)v84 + 8) = *(_OWORD *)(a1 + 64);
  uint64_t v12 = *(void *)(a1 + 80);
  uint64_t v13 = *(void *)(a1 + 88);
  *(_OWORD *)((char *)&v84[2] + 8) = *(_OWORD *)(a1 + 96);
  uint64_t v14 = *(void *)(a1 + 112);
  *((void *)&v84[1] + 1) = v12;
  *(void *)&v84[2] = v13;
  *((void *)&v84[3] + 1) = v14;
  LOWORD(v13) = *(_WORD *)(a1 + 124) & 0x5FF;
  LODWORD(v85) = *(_DWORD *)(a1 + 120);
  WORD2(v85) = v13;
  *((void *)&v84[0] + 1) = v11;
  *(void *)&v84[0] = CA::OGL::Context::set_gstate((uint64_t)v5, (uint64_t)v84);
  int v15 = (*(unsigned __int16 *)(v3 + 40) >> 6);
  uint64_t v16 = *(void *)a2 + 32;
  int8x16_t v17 = (float64x2_t *)*((void *)&v84[1] + 1);
  *(void *)&v75.f64[0] = &v80;
  v75.f64[1] = *((float64_t *)&v84[1] + 1);
  uint64_t v19 = CA::OGL::transform_filter_bits(*((float64x2_t **)&v84[1] + 1), v18, 1.0, 1.0);
  v20.i64[0] = 1.0;
  LODWORD(v76.f64[0]) = CA::OGL::rect_filter_bits(v17, v19, v21, v80, v81, v20, 1.0);
  HIDWORD(v76.f64[0]) = v15;
  v76.f64[1] = 0.0;
  uint64_t v78 = 0;
  uint64_t v79 = v16;
  uint64_t v77 = CA::OGL::MaskNode::MaskRectState::map_;
  uint64_t v22 = *(void *)(v3 + 24);
  uint64_t v23 = *(void *)(v22 + 128);
  if (v23)
  {
    uint64_t v24 = *(void *)(v23 + 72);
    if (v24)
    {
      CA::OGL::fill_uneven_round_rect_tex((CA::OGL::Context *)v5, (uint64_t)&v75, (float64_t *)(v24 + 24), (uint64_t)&CA::OGL::MaskNode::apply(float,CA::OGL::Surface **,float *)::identity_st, *(_DWORD *)(v22 + 40) & 3);
      goto LABEL_28;
    }
    uint64_t v25 = *(void *)(v23 + 56);
    if (v25)
    {
      int8x16_t v26 = (uint32x2_t *)(*(uint64_t (**)(uint64_t))(*(void *)v25 + 80))(v25);
      uint64_t v27 = *(void *)(v3 + 24);
      uint64_t v28 = *(void *)(v27 + 128);
      if (v28)
      {
        uint64_t v29 = *(void *)(v28 + 64);
        if (v29)
        {
          if (*(_DWORD *)(v29 + 16) > 3u)
          {
            float64x2_t v54 = vsubq_f64(*(float64x2_t *)(v29 + 40), *(float64x2_t *)(v29 + 24));
            long long v73 = *(_OWORD *)(v29 + 24);
            float64x2_t v74 = v54;
          }
          else
          {
            long long v73 = 0u;
            float64x2_t v74 = 0u;
          }
        }
        else
        {
          __asm { FMOV            V0.2D, #0.5 }
          long long v73 = _Q0;
          float64x2_t v74 = 0uLL;
        }
        float v52 = *(float *)(v28 + 228);
      }
      else
      {
        __asm { FMOV            V0.2D, #0.5 }
        long long v73 = _Q0;
        float64x2_t v74 = 0uLL;
        float v52 = 0.0;
      }
      CA::OGL::fill_corner_rect_tex((CA::OGL::Context *)v5, (double **)&v75, v26, (double *)&v73, *(_DWORD *)(*(void *)(v3 + 16) + 24) & 1, (*(void *)(v27 + 40) >> 41) & 1, (uint64_t)&CA::OGL::MaskNode::apply(float,CA::OGL::Surface **,float *)::identity_st, *(_WORD *)(v27 + 38) & 0xF, v52, v52, 0);
      goto LABEL_28;
    }
    float v10 = *(float *)(v23 + 228);
  }
  CA::OGL::fill_round_rect_tex((CA::OGL::Context *)v5, (float64x2_t **)&v75, (uint64_t)&CA::OGL::MaskNode::apply(float,CA::OGL::Surface **,float *)::identity_st, (double *)(*(_WORD *)(v22 + 38) & 0xF), *(_DWORD *)(v22 + 40) & 3, 0, v10, v10);
LABEL_28:
  CA::OGL::Context::unbind_surface(v5, *(void *)a2, 0);
  *(unsigned char *)(*(void *)&v5[2] + 481) &= ~1u;
  uint64_t v57 = 2147500096;
  switch((*(_DWORD *)(a1 + 220) >> 17) & 7)
  {
    case 1:
      goto LABEL_37;
    case 2:
      goto LABEL_33;
    case 3:
      unsigned __int16 v58 = 128;
      goto LABEL_35;
    case 5:
      if (*(void *)a2 && (*(unsigned char *)(*(void *)a2 + 69) & 8) != 0) {
LABEL_33:
      }
        uint64_t v57 = 8388736;
      else {
        uint64_t v57 = 2155872384;
      }
      goto LABEL_37;
    case 6:
      unsigned __int16 v58 = -32640;
LABEL_35:
      uint64_t v57 = v58 | 0x80000000;
      goto LABEL_37;
    case 7:
      uint64_t v57 = 8421504;
LABEL_37:
      v70[0] = &v80;
      v70[1] = *((void *)&v84[1] + 1);
      long long v71 = 0u;
      long long v72 = 0u;
      CA::OGL::fill_color_rect((uint64_t)v5, (uint64_t)v70, (double *)v57, v55, 0.0, v56);
      break;
    default:
      break;
  }
  CA::OGL::Context::set_gstate((uint64_t)v5, **(void **)&v5[31]);
  if (v11) {
    CA::Shape::unref(v11);
  }
}

void CA::OGL::FilterNode::~FilterNode(CA::OGL::FilterNode *this)
{
  *(void *)this = &unk_1ED02A350;
  CA::OGL::finalize_filter(*((void **)this + 29));
}

{
  *(void *)this = &unk_1ED02A350;
  CA::OGL::finalize_filter(*((void **)this + 29));
  abort();
}

uint64_t CA::OGL::AsynchronousNode::propagate_roi(CA::OGL::AsynchronousNode *this, const CA::Bounds *a2, float a3, double a4, double a5, double a6, float64x2_t a7)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *(void *)(*((void *)this + 2) + 24);
  uint64_t v9 = *(void *)(v8 + 128);
  if (v9)
  {
    float v10 = *(float *)(v9 + 288);
  }
  else
  {
    LOBYTE(a3) = *(unsigned char *)(v8 + 35);
    float v10 = (float)LODWORD(a3);
  }
  float64x2_t v11 = *(float64x2_t *)(v8 + 64);
  float64x2_t v12 = *(float64x2_t *)(v8 + 80);
  if (v10 != 1.0)
  {
    double v13 = v10;
    a7.f64[0] = 1.79769313e308;
    int8x16_t v14 = (int8x16_t)vdupq_lane_s64(vcgtq_f64(a7, v12).i64[0], 0);
    v15.i64[1] = *(void *)(v8 + 72);
    *(double *)v15.i64 = v13 * v11.f64[0];
    float64x2_t v11 = (float64x2_t)vbslq_s8(v14, v15, (int8x16_t)v11);
    v15.i64[1] = *(void *)(v8 + 88);
    *(double *)v15.i64 = v13 * v12.f64[0];
    float64x2_t v12 = (float64x2_t)vbslq_s8(v14, v15, (int8x16_t)v12);
    if (v12.f64[1] < 1.79769313e308)
    {
      v11.f64[1] = vmuld_lane_f64(v13, v11, 1);
      v12.f64[1] = v12.f64[1] * v13;
    }
  }
  uint64_t v16 = *((void *)this + 3);
  int64x2_t v17 = vceqzq_f64(v12);
  if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v17, 1), (int8x16_t)v17).u64[0] & 0x8000000000000000) != 0
    || (int8x16_t v18 = vorrq_s8((int8x16_t)vcltzq_f64(v12), (int8x16_t)vcgezq_f64(v12)),
        (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v18), 1), v18).u64[0] & 0x8000000000000000) != 0))
  {
    int32x4_t v23 = 0uLL;
  }
  else
  {
    float64x2_t v19 = vmaxnmq_f64(v11, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000));
    float64x2_t v20 = vminnmq_f64(vaddq_f64(v11, v12), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL));
    int32x4_t v21 = (int32x4_t)vcvtmq_s64_f64(v19);
    int32x4_t v23 = vuzp1q_s32(v21, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(v20), (int64x2_t)v21));
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, int32x4_t *))(*(void *)v16 + 56))(v16, &v23);
  *(_DWORD *)(*((void *)this + 3) + 216) = *(_DWORD *)(*((void *)this + 3) + 216) & 0xFFC00000 | *((_DWORD *)this + 54) & 0x3FFFFF;
  *(_DWORD *)(*((void *)this + 3) + 216) |= 0x1000u;
  return result;
}

void CA::Render::SecureIndicatorLayer::~SecureIndicatorLayer(CA::Render::SecureIndicatorLayer *this, const CA::Render::Object *a2)
{
  --dword_1EB2ADE7C;
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  --dword_1EB2ADE7C;
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  }
}

void CA::Render::ReplicatorLayer::~ReplicatorLayer(CA::Render::ReplicatorLayer *this, const CA::Render::Object *a2)
{
  *(void *)this = &unk_1ED02E208;
  uint64_t v3 = (atomic_uint *)*((void *)this + 3);
  if (v3 && atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v3 + 16))(v3);
  }
  --dword_1EB2ADE78;
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  atomic_uint *v3;

  *(void *)this = &unk_1ED02E208;
  uint64_t v3 = (atomic_uint *)*((void *)this + 3);
  if (v3 && atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v3 + 16))(v3);
  }
  --dword_1EB2ADE78;
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  }
}

void CA::Render::PortalLayer::~PortalLayer(CA::Render::PortalLayer *this, const CA::Render::Object *a2)
{
  *(void *)this = &unk_1ED02D0D0;
  uint64_t v3 = (atomic_uint *)*((void *)this + 7);
  if (v3 && atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v3 + 16))(v3);
  }
  uint64_t v4 = (atomic_uint *)*((void *)this + 6);
  if (v4 && atomic_fetch_add(v4 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
  }
  --dword_1EB2ADE68;
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  atomic_uint *v3;
  atomic_uint *v4;

  *(void *)this = &unk_1ED02D0D0;
  uint64_t v3 = (atomic_uint *)*((void *)this + 7);
  if (v3 && atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v3 + 16))(v3);
  }
  uint64_t v4 = (atomic_uint *)*((void *)this + 6);
  if (v4 && atomic_fetch_add(v4 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
  }
  --dword_1EB2ADE68;
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  }
}

uint64_t CA::OGL::MeshNode::propagate_soft_roi(CA::OGL::MeshNode *this, const CA::Bounds *a2, int32x4_t a3, int32x4_t a4)
{
  v8[2] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (int32x2_t *)*((void *)this + 3);
  CA::OGL::MeshNode::unmap_bounds((CA::OGL::MeshNode *)v8, (const CA::Transform **)this, (uint64_t)a2, a3, a4);
  int32x2_t v5 = (int32x2_t)v8[0];
  int32x2_t v6 = (int32x2_t)v8[1];

  return CA::BoundsImpl::Union(v4 + 24, v5, v6);
}

uint64_t CA::OGL::MeshNode::propagate_roi(CA::OGL::MeshNode *this, const CA::Bounds *a2, int32x4_t a3, int32x4_t a4)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *((void *)this + 3);
  CA::OGL::MeshNode::unmap_bounds((CA::OGL::MeshNode *)v7, (const CA::Transform **)this, (uint64_t)a2, a3, a4);
  uint64_t result = (*(uint64_t (**)(uint64_t, unsigned char *))(*(void *)v5 + 56))(v5, v7);
  if ((*((unsigned char *)this + 224) & 0xF) == 2) {
    *(_DWORD *)(*((void *)this + 3) + 216) |= 0x40u;
  }
  if (!*(unsigned char *)(*((void *)this + 29) + 108)) {
    *(_WORD *)(*((void *)this + 3) + 212) |= 0x200u;
  }
  return result;
}

void CA::OGL::MeshNode::apply(uint64_t a1, uint64_t *a2, double a3)
{
  LODWORD(a3) = *(_DWORD *)(a1 + 240);
  CA::OGL::fill_surface_mesh(**(void **)(a1 + 8), *(os_unfair_lock_s **)(a1 + 232), *(void *)(*(void *)(a1 + 16) + 24) + 64, *a2, *(unsigned char *)(a1 + 224) & 0xF, *(unsigned __int8 *)(a1 + 224) >> 4, 0, a3, *(float *)(a1 + 244));
}

uint64_t CA::OGL::ShadowNode::add_roi(CA::Bounds **this, int32x2_t *a2, double a3, int32x4_t a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = (CA::OGL::ShadowNode *)this;
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *((void *)this[2] + 3);
  if ((*(unsigned char *)(v6 + 44) & 4) == 0)
  {
    uint64_t v7 = *(void *)(v6 + 128);
    if (!v7 || !*(void *)(v7 + 120))
    {
      int32x4_t v23 = *(int32x4_t *)a2->i8;
      int32x4_t v24 = v23;
      CA::OGL::ShadowNode::map_bounds((CA::OGL::ShadowNode *)v6, this[10], (uint64_t)&v24, 0, v23, a4);
      v9.i32[1] = v23.i32[3];
      __int32 v8 = v23.i32[2];
      uint32x2_t v10 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, (int32x2_t)v24.u64[1]);
      uint32x2_t v11 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, (int32x2_t)v23.u64[1]);
      unsigned __int32 v12 = vpmax_u32(v11, v11).u32[0];
      if ((vpmax_u32(v10, v10).u32[0] & 0x80000000) != 0)
      {
        if ((v12 & 0x80000000) == 0)
        {
          v24.i64[0] = v23.i64[0];
          goto LABEL_10;
        }
      }
      else if ((v12 & 0x80000000) == 0)
      {
        int32x2_t v13 = vmin_s32(*(int32x2_t *)v24.i8, *(int32x2_t *)v23.i8);
        int32x2_t v9 = vsub_s32(vmax_s32(vadd_s32(*(int32x2_t *)v24.i8, (int32x2_t)v24.u64[1]), vadd_s32(*(int32x2_t *)v23.i8, (int32x2_t)v23.u64[1])), v13);
        *(int32x2_t *)v24.i8 = v13;
        __int32 v8 = v9.i32[0];
LABEL_10:
        v24.i32[2] = v8;
        *(_DWORD *)((unint64_t)&v24 | 0xC) = v9.i32[1];
      }
      a2 = (int32x2_t *)&v24;
      this = (CA::Bounds **)v5;
    }
  }
  uint64_t result = CA::OGL::ImagingNode::add_roi((int32x2_t *)this, a2);
  uint64_t v17 = *(void *)(v6 + 128);
  if (v17 && *(float *)(v17 + 300) != 0.0)
  {
    int32x4_t v24 = *(int32x4_t *)v4->i8;
    CA::OGL::ShadowNode::map_bounds_rim(v5, (CA::Bounds *)&v24, v15, v24, v16);
    int32x2_t v18 = v4[1];
    uint32x2_t v19 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, (int32x2_t)v24.u64[1]);
    uint32x2_t v20 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v18);
    unsigned __int32 v21 = vpmax_u32(v20, v20).u32[0];
    if ((vpmax_u32(v19, v19).u32[0] & 0x80000000) != 0)
    {
      if ((v21 & 0x80000000) == 0)
      {
        int32x2_t v22 = *v4;
        goto LABEL_19;
      }
    }
    else if ((v21 & 0x80000000) == 0)
    {
      int32x2_t v22 = vmin_s32(*(int32x2_t *)v24.i8, *v4);
      int32x2_t v18 = vsub_s32(vmax_s32(vadd_s32(*(int32x2_t *)v24.i8, (int32x2_t)v24.u64[1]), vadd_s32(*v4, v18)), v22);
LABEL_19:
      *(int32x2_t *)v24.i8 = v22;
      v24.u64[1] = (unint64_t)v18;
    }
    return CA::OGL::ImagingNode::add_roi((int32x2_t *)v5, (int32x2_t *)&v24);
  }
  return result;
}

void CA::Render::Interpolator::~Interpolator(CA::Render::Interpolator *this, const CA::Render::Object *a2)
{
  *(void *)this = &unk_1ED02D4F8;
  uint64_t v3 = (atomic_uint *)*((void *)this + 5);
  if (v3 && atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v3 + 16))(v3);
  }
  uint64_t v4 = (atomic_uint *)*((void *)this + 4);
  if (v4 && atomic_fetch_add(v4 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
  }
  uint64_t v5 = (atomic_uint *)*((void *)this + 3);
  if (v5 && atomic_fetch_add(v5 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v5 + 16))(v5);
  }
  uint64_t v6 = (atomic_uint *)*((void *)this + 2);
  if (v6 && atomic_fetch_add(v6 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v6 + 16))(v6);
  }
  --dword_1EB2ADE30;
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  atomic_uint *v3;
  atomic_uint *v4;
  atomic_uint *v5;
  atomic_uint *v6;

  *(void *)this = &unk_1ED02D4F8;
  uint64_t v3 = (atomic_uint *)*((void *)this + 5);
  if (v3 && atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v3 + 16))(v3);
  }
  uint64_t v4 = (atomic_uint *)*((void *)this + 4);
  if (v4 && atomic_fetch_add(v4 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
  }
  uint64_t v5 = (atomic_uint *)*((void *)this + 3);
  if (v5 && atomic_fetch_add(v5 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v5 + 16))(v5);
  }
  uint64_t v6 = (atomic_uint *)*((void *)this + 2);
  if (v6 && atomic_fetch_add(v6 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v6 + 16))(v6);
  }
  --dword_1EB2ADE30;
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  }
}

void CA::Render::GainMapLayer::~GainMapLayer(CA::Render::GainMapLayer *this, const CA::Render::Object *a2)
{
  --dword_1EB2ADE14;
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  --dword_1EB2ADE14;
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  }
}

uint64_t CA::OGL::FilterNode::grow_roi(CA::OGL::FilterNode *this, int32x2_t *a2)
{
  uint64_t result = CA::OGL::filter_flags(*((void *)this + 29), *((void *)this + 2));
  if ((result & 0x20) != 0)
  {
    if ((*((_DWORD *)this + 34) & 0x80000000) != 0) {
      (*(void (**)(CA::OGL::FilterNode *, char *))(*(void *)this + 40))(this, (char *)this + 128);
    }
    int32x2_t v5 = *(int32x2_t *)((char *)this + 128);
    int32x2_t v6 = *(int32x2_t *)((char *)this + 136);
    return CA::BoundsImpl::Union(a2, v5, v6);
  }
  return result;
}

uint64_t CA::Layer::collect_animations_(uint64_t a1, double *a2, uint64_t a3, int8x16_t a4, int8x16_t a5)
{
  double v7 = *(double *)a4.i64;
  v66[1] = *(CA::Render::Timing **)MEMORY[0x1E4F143B8];
  uint64_t v9 = *(unsigned int *)(*(void *)a3 + 96);
  if ((v9 & 0x80000000) != 0 || (uint64_t v10 = a1 + 4 * v9, (v11 = *(_DWORD *)(v10 + 272)) == 0))
  {
    unsigned __int32 v12 = CA::Layer::thread_flags_((CA::Layer *)a1, *(CA::Transaction **)a3);
    int v11 = *v12;
  }
  else
  {
    unsigned __int32 v12 = (_DWORD *)(v10 + 272);
  }
  *unsigned __int32 v12 = v11 | *(_DWORD *)(a1 + 4) & 0x800;
  int v13 = *(_DWORD *)(a3 + 12);
  if ((v11 & 0x80000) != 0) {
    *(_DWORD *)(a3 + 12) = ++v13;
  }
  if (!v13 && (*((unsigned char *)v12 + 1) & 8) == 0) {
    return 0;
  }
  float v15 = *(float *)(a3 + 8);
  double v65 = v7;
  uint64_t v61 = v12;
  if ((*(unsigned char *)(a1 + 56) & 0x80) != 0)
  {
    CA::Layer::render_timing((uint64_t)v66, (CA::Transaction *)a1, *(CA::Transaction **)a3);
    int32x4_t v16 = v66[0];
    if (v66[0])
    {
      double v65 = fmin(fmax(v7, *((double *)v66[0] + 5)), CA::Render::Timing::end_time(v66[0]));
      CA::Render::Timing::map_time(v16, &v65, 0);
      *(float *)a4.i32 = *((float *)v16 + 4) * *(float *)(a3 + 8);
      *(_DWORD *)(a3 + 8) = a4.i32[0];
      double v17 = v65;
      goto LABEL_16;
    }
    a4.i32[0] = *(_DWORD *)(a3 + 8);
  }
  else
  {
    int32x4_t v16 = 0;
    *(float *)a4.i32 = v15;
  }
  double v17 = v7;
LABEL_16:
  double v64 = 0.0;
  *(double *)a4.i64 = *(float *)a4.i32;
  a5.i64[0] = 0x7FF0000000000000;
  v18.f64[0] = NAN;
  v18.f64[1] = NAN;
  int8x16_t v63 = vbslq_s8((int8x16_t)vnegq_f64(v18), a5, a4);
  uint32x2_t v19 = *(CA::Render::Timing **)(a1 + 280);
  v66[0] = v19;
  uint64_t v14 = v19 != 0;
  if (!v19) {
    goto LABEL_110;
  }
  if ((*(_DWORD *)(a1 + 4) & 0x1800000) != 0)
  {
    atomic_fetch_and((atomic_uint *volatile)(a1 + 4), 0xFE7FFFFF);
    uint32x2_t v20 = v66[0];
    if (!v66[0])
    {
      uint64_t v62 = 0;
      int v21 = 0;
      int v22 = *(_DWORD *)(a1 + 4);
      goto LABEL_89;
    }
  }
  else
  {
    uint32x2_t v20 = v19;
  }
  uint64_t v60 = v16;
  int v23 = 0;
  int v24 = 0;
  uint64_t v62 = 0;
  uint64_t v25 = v66;
  do
  {
    int8x16_t v26 = (CA::Render::Timing ***)v25;
    uint64_t v25 = (CA::Render::Timing **)v20;
    while (1)
    {
      __int16 v27 = *((_WORD *)v25 + 28);
      if ((v27 & 2) == 0) {
        break;
      }
      if ((v27 & 8) != 0) {
        break;
      }
      uint64_t v28 = (double *)v25[4];
      if (!v28) {
        break;
      }
      double v29 = v28[5];
      double v30 = CA::Render::Timing::end_time((CA::Render::Timing *)v28);
      unsigned int v31 = *((_DWORD *)v25[4] + 3);
      float v32 = *(float *)(a3 + 8);
      if (v32 == 0.0)
      {
        BOOL v41 = v30 > v17 || (*((_DWORD *)v25[4] + 3) & 0x200) != 0;
        if (v29 > v17) {
          BOOL v41 = (*((_DWORD *)v25[4] + 3) & 0x400) != 0;
        }
        goto LABEL_70;
      }
      int v33 = (v31 >> 10) & 1;
      int v34 = (v31 >> 9) & 1;
      if (v32 < 0.0) {
        double v35 = v30;
      }
      else {
        double v35 = v29;
      }
      if (v32 < 0.0)
      {
        int v36 = (v31 >> 9) & 1;
      }
      else
      {
        double v29 = v30;
        int v36 = (v31 >> 10) & 1;
      }
      if (v32 < 0.0) {
        int v37 = v33;
      }
      else {
        int v37 = v34;
      }
      BOOL v38 = v35 > v17;
      if (v32 <= 0.0) {
        BOOL v38 = v35 < v17;
      }
      if (v38)
      {
        if (((_WORD)v25[7] & 0x1080) == 0)
        {
          if (((_WORD)v25[7] & 0x2000) != 0 || (double v35 = *(double *)v63.i64, v25[6])) {
            double v35 = v29;
          }
        }
        BOOL v41 = v36 != 0;
        double v29 = v35;
LABEL_62:
        int8x16_t v42 = v63;
LABEL_65:
        BOOL v43 = v29 < *(double *)v42.i64;
        if (*(float *)(a3 + 8) <= 0.0) {
          BOOL v43 = v29 > *(double *)v42.i64;
        }
        if (v43) {
          *(double *)v42.i64 = v29;
        }
        int8x16_t v63 = v42;
LABEL_70:
        __int16 v44 = *((_WORD *)v25 + 28);
        if ((v44 & 0x80) != 0 && v41)
        {
          v24 |= (unsigned __int16)(v44 & 0x200) >> 9;
          v23 |= (unsigned __int16)(v44 & 0x400) >> 10;
        }
        break;
      }
      BOOL v39 = v29 > v17;
      if (v32 <= 0.0) {
        BOOL v39 = v29 < v17;
      }
      if (v39)
      {
        schedule_start_callback(v25, (uint64_t)&animation_state);
        if (((_WORD)v25[7] & 0x2000) != 0 || v25[6])
        {
          BOOL v41 = 1;
          goto LABEL_62;
        }
        BOOL v41 = 1;
        goto LABEL_64;
      }
      *((_DWORD *)v25[1] + 4) |= 2u;
      schedule_stop_callback((uint64_t)v25, (uint64_t *)&animation_state);
      if (((_WORD)v25[7] & 1) == 0)
      {
        BOOL v41 = v37 != 0;
LABEL_64:
        int8x16_t v42 = v63;
        double v29 = *(double *)v63.i64;
        goto LABEL_65;
      }
      *int8x16_t v26 = (CA::Render::Timing **)*v25;
      *uint64_t v25 = (CA::Render::Timing *)qword_1EB2A8C20;
      qword_1EB2A8C20 = (uint64_t)v25;
      uint64_t v25 = *v26;
      if (!*v26) {
        goto LABEL_80;
      }
    }
    if (v25[3] == (CA::Render::Timing *)kContentsStringHash)
    {
      int v45 = [(CA::Render::Timing *)v25[2] isEqualToString:@"contents"];
      uint64_t v46 = v62;
      if (v45) {
        uint64_t v46 = v25;
      }
      uint64_t v62 = v46;
    }
    uint32x2_t v20 = *v25;
  }
  while (*v25);
LABEL_80:
  int v22 = *(_DWORD *)(a1 + 4);
  if ((v24 & 1) == 0)
  {
    if ((v23 & 1) == 0)
    {
      int v21 = 0;
      int32x4_t v16 = v60;
      uint64_t v14 = v19 != 0;
LABEL_89:
      int v47 = v22 & 0x3000;
      if (v21 == v47)
      {
        if (!v21) {
          goto LABEL_109;
        }
        goto LABEL_91;
      }
LABEL_94:
      int8x16_t v48 = *(void **)(a1 + 16);
      atomic_fetch_or((atomic_uint *volatile)(a1 + 4), v21 & ~v47);
      atomic_fetch_and((atomic_uint *volatile)(a1 + 4), v21 | ~v47);
      if (!v21)
      {
        [v48 _cancelAnimationTimer];
        if ((v22 & 0x1000) != 0) {
          [v48 setNeedsLayout];
        }
        if ((v22 & 0x2000) == 0) {
          goto LABEL_109;
        }
        goto LABEL_108;
      }
      goto LABEL_95;
    }
    int v21 = 0x2000;
LABEL_85:
    int32x4_t v16 = v60;
    uint64_t v14 = v19 != 0;
    atomic_fetch_or((atomic_uint *volatile)(a1 + 4), 0x800000u);
    goto LABEL_89;
  }
  atomic_fetch_or((atomic_uint *volatile)(a1 + 4), 0x1000000u);
  if (v23)
  {
    int v21 = 12288;
    goto LABEL_85;
  }
  int v47 = v22 & 0x3000;
  int v21 = 4096;
  int32x4_t v16 = v60;
  uint64_t v14 = v19 != 0;
  if (v47 != 4096) {
    goto LABEL_94;
  }
LABEL_91:
  if (*(float *)(a3 + 8) == 0.0 && !*(_DWORD *)(a3 + 12)) {
    goto LABEL_109;
  }
  int8x16_t v48 = *(void **)(a1 + 16);
LABEL_95:
  if ([v48 _scheduleAnimationTimer])
  {
    if ((v21 & 0x1000) != 0) {
      [v48 setNeedsLayout];
    }
    if ((v21 & 0x2000) == 0)
    {
      *(double *)v63.i64 = v17;
      goto LABEL_109;
    }
    if (v62) {
      [v48 performSelectorOnMainThread:sel_removeAnimationForKey_ withObject:@"contents" waitUntilDone:0];
    }
    *(double *)v63.i64 = v17;
LABEL_108:
    [v48 setNeedsDisplay];
    *(_DWORD *)(a1 + 52) |= 0x800000u;
  }
LABEL_109:
  CA::Layer::set_animations((void *)a1, (uint64_t)v66[0]);
LABEL_110:
  double v64 = *(double *)v63.i64;
  int8x16_t v49 = *(uint64_t **)(a1 + 24);
  if (!v49) {
    goto LABEL_121;
  }
  BOOL v50 = v19 != 0;
  uint64_t v51 = v49 + 1;
  uint64_t v52 = v49[2];
  if (v52 == 1)
  {
    if (!v49[3])
    {
LABEL_116:
      double v53 = v65;
      do
      {
        if (CA::Layer::collect_animations_(*(void *)(*v51 + 16), &v64, a3, v53)) {
          BOOL v50 = 1;
        }
        ++v51;
        --v52;
      }
      while (v52);
      goto LABEL_120;
    }
LABEL_115:
    uint64_t v51 = (uint64_t *)*v51;
    goto LABEL_116;
  }
  if (v52) {
    goto LABEL_115;
  }
LABEL_120:
  uint64_t v14 = v50;
LABEL_121:
  uint64_t v54 = *(void *)(a1 + 32);
  if (v54) {
    uint64_t v14 = CA::Layer::collect_animations_(*(void *)(v54 + 16), &v64, a3, v65) | v14;
  }
  double v55 = v64;
  if ((*(void *)&v64 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    if (v16)
    {
      CA::Render::Timing::inverse_map_time((uint64_t)v16, &v64, v7);
      double v55 = v64;
    }
    BOOL v56 = v15 < 0.0;
    if (v55 <= *a2) {
      BOOL v56 = 0;
    }
    if (v15 > 0.0) {
      BOOL v56 = v55 < *a2;
    }
    if (v56) {
      *a2 = v55;
    }
  }
  *(float *)(a3 + 8) = v15;
  uint64_t v57 = (atomic_uint *)(a1 + 4);
  if (v14)
  {
    atomic_fetch_or(v57, 0x800u);
    if ((*v61 & 0x80000) == 0) {
      goto LABEL_137;
    }
    goto LABEL_136;
  }
  atomic_fetch_and(v57, 0xFFFFF7FF);
  unsigned int v58 = *v61 & 0xFFFFF7FF;
  *uint64_t v61 = v58;
  if ((v58 & 0x80000) != 0) {
LABEL_136:
  }
    --*(_DWORD *)(a3 + 12);
LABEL_137:
  if (v16 && atomic_fetch_add((atomic_uint *volatile)v16 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(CA::Render::Timing *))(*(void *)v16 + 16))(v16);
  }
  return v14;
}

void sub_184671C7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
}

void *schedule_start_callback(void *result, uint64_t a2)
{
  if ((result[7] & 0x1000) != 0)
  {
    uint64_t v3 = result;
    uint64_t v4 = *(void *)(a2 + 8);
    uint64_t v5 = result[1];
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    double v7 = malloc_type_zone_malloc(malloc_zone, 0x10uLL, 0x8BB15036uLL);
    void *v7 = v5;
    v7[1] = v4;
    *(void *)(a2 + 8) = v7;
    uint64_t result = CFRetain((CFTypeRef)v3[1]);
    *((_WORD *)v3 + 28) &= ~0x1000u;
  }
  return result;
}

void CA::Layer::set_animations(void *value, uint64_t a2)
{
  if ((*((unsigned char *)value + 54) & 0x10) == 0)
  {
    uint64_t v4 = value[35];
    if (!a2 || v4)
    {
      if (!a2 && v4 && non_visible_animating_layers) {
        CFSetRemoveValue((CFMutableSetRef)non_visible_animating_layers, value);
      }
    }
    else
    {
      add_non_visible_animating_layer(value);
    }
  }
  value[35] = a2;
}

void sub_184671EB8(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

void CA::Layer::insert_sublayer(CA::Layer *this, CA::Transaction *a2, CALayer *a3, unint64_t a4)
{
  __src[1] = *(void **)MEMORY[0x1E4F143B8];
  double v7 = (CALayerArray *)*((void *)this + 3);
  if (v7) {
    unint64_t var0 = v7->_ivars.var0;
  }
  else {
    unint64_t var0 = 0;
  }
  if (var0 >= a4) {
    uint64_t v9 = a4;
  }
  else {
    uint64_t v9 = var0;
  }
  uint64_t v10 = (CA::Layer *)CA::Layer::retain_parent((CA::Layer *)a3->_attr.layer, a2);
  int v33 = v10;
  if (v10 != this)
  {
    int v13 = (atomic_uint *)v10;
    if (!v10)
    {
      CFRetain(a3);
      CA::Layer::remove_from_context((CA::Layer *)a3->_attr.layer);
      uint32x2_t v20 = 0;
LABEL_26:
      uint64_t v23 = -1;
      goto LABEL_27;
    }
    CA::Layer::remove_sublayer(v10, a2, a3, v11, v12);
    while (1)
    {
      atomic_uint v14 = *v13;
      if (!*v13) {
        break;
      }
      atomic_uint v15 = *v13;
      atomic_compare_exchange_strong(v13, (unsigned int *)&v15, v14 - 1);
      if (v15 == v14)
      {
        if (v14 != 1) {
          break;
        }
        CA::Layer::destroy((CA::Layer *)v13);
        CA::Layer::~Layer((CA::AttrList **)v13);
        malloc_zone = (malloc_zone_t *)get_malloc_zone();
        double v17 = (CA::Layer *)v13;
        goto LABEL_24;
      }
    }
LABEL_25:
    uint32x2_t v20 = 0;
    int v33 = 0;
    goto LABEL_26;
  }
  if (*((CALayer **)this + 4) == a3)
  {
    CA::Layer::remove_sublayer(this, a2, a3, v11, v12);
    while (1)
    {
      int v21 = *(_DWORD *)this;
      if (!*(_DWORD *)this) {
        goto LABEL_25;
      }
      int v22 = *(_DWORD *)this;
      atomic_compare_exchange_strong((atomic_uint *volatile)this, (unsigned int *)&v22, v21 - 1);
      if (v22 == v21)
      {
        if (v21 == 1)
        {
          CA::Layer::destroy(this);
          CA::Layer::~Layer((CA::AttrList **)this);
          malloc_zone = (malloc_zone_t *)get_malloc_zone();
          double v17 = this;
LABEL_24:
          malloc_zone_free(malloc_zone, v17);
        }
        goto LABEL_25;
      }
    }
  }
  p_ivars = &v7->_ivars;
  unint64_t v19 = v7->_ivars.var0;
  if (v19 == 1)
  {
    if (!v7->_ivars.capacity)
    {
LABEL_46:
      uint64_t v23 = 0;
      while (*((CALayer **)&p_ivars->layers + v23) != a3)
      {
        if (v19 == ++v23) {
          goto LABEL_49;
        }
      }
      goto LABEL_50;
    }
LABEL_45:
    p_ivars = (_CALayerArrayIvars *)p_ivars->layers;
    goto LABEL_46;
  }
  if (v19) {
    goto LABEL_45;
  }
LABEL_49:
  uint64_t v23 = -1;
LABEL_50:
  uint32x2_t v20 = (atomic_uint *)this;
  if (v23 == v9)
  {
    uint32x2_t v20 = (atomic_uint *)this;
    goto LABEL_37;
  }
LABEL_27:
  float v32 = 0;
  CA::Layer::begin_change(this, a2, @"sublayers", (objc_object *)&v32, v12);
  if (v23 != -1)
  {
    CALayerArrayRemoveValue((char *)v7, v23);
    uint64_t v9 = (__PAIR128__(v9, v23) - (unint64_t)v9) >> 64;
  }
  if (!v7)
  {
    double v7 = objc_alloc_init(CALayerArray);
    *((void *)this + 3) = v7;
  }
  __src[0] = a3;
  CALayerArrayInsertValues((uint64_t)v7, v9, __src, 1);
  if (!v20)
  {
    layer = (CA::Layer *)a3->_attr.layer;
    int v25 = CA::Layer::ancestor_context_id(this, a2);
    CA::Layer::update_added_sublayer(layer, a2, this, v25);
    int8x16_t v26 = (CA::Layer *)a3->_attr.layer;
    uint64_t v27 = *((unsigned int *)a2 + 24);
    if ((v27 & 0x80000000) != 0 || (int v28 = *((_DWORD *)v26 + v27 + 68)) == 0) {
      int v28 = *CA::Layer::thread_flags_(v26, a2);
    }
    CA::Layer::update_for_changed_sublayers((atomic_uint *)this, a2, v28);
  }
  CA::Layer::end_change((id *)this, a2, 547, (objc_object *)@"sublayers", v32);
  if (v20)
  {
LABEL_37:
    while (1)
    {
      atomic_uint v29 = *v20;
      if (!*v20) {
        break;
      }
      atomic_uint v30 = *v20;
      atomic_compare_exchange_strong(v20, (unsigned int *)&v30, v29 - 1);
      if (v30 == v29)
      {
        if (v29 == 1)
        {
          CA::Layer::destroy((CA::Layer *)v20);
          CA::Layer::~Layer((CA::AttrList **)v20);
          unsigned int v31 = (malloc_zone_t *)get_malloc_zone();
          malloc_zone_free(v31, v20);
        }
        return;
      }
    }
  }
}

void sub_18467221C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  X::Ref<CA::Layer>::~Ref((atomic_uint **)va);
  _Unwind_Resume(a1);
}

CA::Layer *CA::Layer::ensure_transaction_recursively(CA::Layer *this, CA::Transaction *a2)
{
  uint64_t v3 = this;
  uint64_t v4 = *((unsigned int *)a2 + 24);
  if ((v4 & 0x80000000) != 0 || !*((_DWORD *)this + v4 + 68)) {
    this = (CA::Layer *)CA::Layer::thread_flags_(this, a2);
  }
  int v5 = *((_DWORD *)v3 + 13);
  if ((v5 & 0x2000000) != 0)
  {
    this = (CA::Layer *)[MEMORY[0x1E4F1CA00] raise:@"CALayerInvalid", @"layer %@ is a part of cycle in its layer tree", *((void *)v3 + 2) format];
    int v5 = *((_DWORD *)v3 + 13);
  }
  *((_DWORD *)v3 + 13) = v5 | 0x2000000;
  int32x2_t v6 = (void *)*((void *)v3 + 3);
  if (v6)
  {
    double v7 = v6 + 1;
    uint64_t v8 = v6[2];
    if (v8 == 1)
    {
      if (!v6[3])
      {
        do
        {
LABEL_12:
          uint64_t v9 = *v7++;
          this = (CA::Layer *)CA::Layer::ensure_transaction_recursively(*(CA::Layer **)(v9 + 16), a2);
          --v8;
        }
        while (v8);
        goto LABEL_13;
      }
    }
    else if (!v8)
    {
      goto LABEL_13;
    }
    double v7 = (uint64_t *)*v7;
    goto LABEL_12;
  }
LABEL_13:
  uint64_t v10 = *((void *)v3 + 4);
  if (v10) {
    this = (CA::Layer *)CA::Layer::ensure_transaction_recursively(*(CA::Layer **)(v10 + 16), a2);
  }
  *((_DWORD *)v3 + 13) &= ~0x2000000u;
  return this;
}

uint64_t CA::Layer::ancestor_context_id(CA::Layer *this, CA::Transaction *a2)
{
  int v4 = *((_DWORD *)a2 + 25);
  *((_DWORD *)a2 + 25) = v4 + 1;
  if (!v4) {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
  }
  uint64_t v5 = *((unsigned int *)this + 67);
  int32x2_t v6 = CA::Layer::retain_parent(this, a2);
  if (v6)
  {
    double v7 = (unsigned int *)v6;
    do
    {
      uint64_t v5 = v7[67];
      unsigned __int32 v12 = CA::Layer::retain_parent((CA::Layer *)v7, a2);
      while (1)
      {
        unsigned int v8 = *v7;
        if (!*v7) {
          break;
        }
        unsigned int v9 = *v7;
        atomic_compare_exchange_strong((atomic_uint *volatile)v7, &v9, v8 - 1);
        if (v9 == v8)
        {
          if (v8 == 1)
          {
            CA::Layer::destroy((CA::Layer *)v7);
            CA::Layer::~Layer((CA::AttrList **)v7);
            malloc_zone = (malloc_zone_t *)get_malloc_zone();
            malloc_zone_free(malloc_zone, v7);
          }
          break;
        }
      }
      double v7 = (unsigned int *)v12;
    }
    while (v12);
  }
  CA::Transaction::unlock(a2);
  return v5;
}

void sub_184672428(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, atomic_uint *a9)
{
  X::Ref<CA::Layer>::~Ref(&a9);
  CA::Transaction::unlock(v9);
  _Unwind_Resume(a1);
}

void CALayerArrayInsertValues(uint64_t a1, uint64_t a2, void **__src, uint64_t a4)
{
  int v4 = (void **)(a1 + 8);
  if (*(unsigned char *)(a1 + 40)) {
    abort();
  }
  uint64_t v7 = *(void *)(a1 + 16);
  unint64_t v8 = *(void *)(a1 + 24);
  unsigned int v9 = (void *)(v7 + a4);
  if (v7 + a4 == 1 && v8 == 0)
  {
    *int v4 = *__src;
LABEL_23:
    v4[1] = v9;
    v4[3] = (char *)v4[3] + 1;
    return;
  }
  if ((unint64_t)v9 <= v8)
  {
    if (v7 != a2) {
      memmove((char *)*v4 + 8 * a2 + 8 * a4, (char *)*v4 + 8 * a2, 8 * (v7 - a2));
    }
    if (a4 == 1) {
      *((void *)*v4 + a2) = *__src;
    }
    else {
      memcpy((char *)*v4 + 8 * a2, __src, 8 * a4);
    }
    goto LABEL_23;
  }
  unint64_t v12 = a4 + v8 + 7;
  if (!(v12 >> 61))
  {
    unint64_t v24 = v12 & 0xFFFFFFFFFFFFFFF8;
    size_t v14 = 8 * (v12 & 0xFFFFFFFFFFFFFFF8);
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    int32x4_t v16 = (char *)malloc_type_zone_malloc(malloc_zone, v14, 0x8BB15036uLL);
    if (v16)
    {
      double v17 = v16;
      if (a2)
      {
        float64x2_t v18 = (void *)(a1 + 8);
        if (*(void *)(a1 + 16) != 1 || *(void *)(a1 + 24)) {
          float64x2_t v18 = (void *)*v18;
        }
        memcpy(v16, v18, 8 * a2);
      }
      uint64_t v23 = v17;
      unint64_t v19 = &v17[8 * a2];
      memcpy(v19, __src, 8 * a4);
      if (v7 != a2)
      {
        uint32x2_t v20 = (void *)(a1 + 8);
        if (*(void *)(a1 + 16) != 1 || *(void *)(a1 + 24)) {
          uint32x2_t v20 = (void *)*v20;
        }
        memcpy(&v19[8 * a4], &v20[a2], 8 * (v7 - a2));
      }
      if (v8)
      {
        int v21 = *v4;
        int v22 = (malloc_zone_t *)get_malloc_zone();
        malloc_zone_free(v22, v21);
      }
      *int v4 = v23;
      v4[2] = (void *)v24;
      goto LABEL_23;
    }
  }
}

CALayer *CA::Layer::superlayer(CA::Layer *this, CA::Transaction *a2)
{
  int v4 = *((_DWORD *)this + 1) & 0x60000;
  int v5 = *((_DWORD *)a2 + 25);
  *((_DWORD *)a2 + 25) = v5 + 1;
  if (!v5)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
    if (v4) {
      goto LABEL_3;
    }
LABEL_8:
    uint64_t v7 = (CA::Layer *)*((void *)this + 1);
    if (v7) {
      goto LABEL_9;
    }
LABEL_10:
    unint64_t v8 = 0;
    goto LABEL_11;
  }
  if (!v4) {
    goto LABEL_8;
  }
LABEL_3:
  int32x2_t v6 = CA::Layer::model_layer(this, a2);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = (CA::Layer *)*((void *)v6 + 1);
  if (!v7) {
    goto LABEL_10;
  }
  if (v4 != 0x20000)
  {
LABEL_9:
    unint64_t v8 = (CALayer *)*((void *)v7 + 2);
    goto LABEL_11;
  }
  unint64_t v8 = CA::Layer::presentation_layer(v7, (CA::Transaction::Shared **)a2);
LABEL_11:
  CA::Transaction::unlock(a2);
  return v8;
}

void sub_18467278C(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

_DWORD *CA::Layer::thread_flags_(CA::Layer *this, CA::Transaction *a2)
{
  if (!**((_DWORD **)a2 + 13)) {
    CA::Transaction::ensure_implicit(a2, 1);
  }
  int v4 = *((_DWORD *)a2 + 25);
  *((_DWORD *)a2 + 25) = v4 + 1;
  if (!v4) {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
  }
  uint64_t v5 = *((unsigned int *)a2 + 24);
  if ((v5 & 0x80000000) != 0)
  {
    uint64_t v8 = x_hash_table_lookup(*(void *)a2, (uint64_t)this, 0);
    if (v8)
    {
      uint64_t v7 = (_DWORD *)v8;
      goto LABEL_10;
    }
  }
  else
  {
    int32x2_t v6 = (char *)this + 4 * v5;
    if (*((_DWORD *)v6 + 68))
    {
      uint64_t v7 = v6 + 272;
LABEL_10:
      CA::Transaction::unlock(a2);
      return v7;
    }
  }
  uint64_t v9 = *((void *)this + 2);
  if (v9 && (uint64_t v10 = *((void *)a2 + 13), CALayerRetain(v9)))
  {
    do
    {
      int v11 = *(_DWORD *)this;
      if (!*(_DWORD *)this) {
        break;
      }
      int v12 = *(_DWORD *)this;
      atomic_compare_exchange_strong((atomic_uint *volatile)this, (unsigned int *)&v12, v11 + 1);
    }
    while (v12 != v11);
    uint64_t v13 = *((unsigned int *)a2 + 24);
    if ((v13 & 0x80000000) != 0)
    {
      size_t v14 = *(uint64_t **)(v10 + 128);
      unint64_t v15 = v14[2];
      BOOL v16 = v15 >= 8;
      unint64_t v17 = v15 - 8;
      if (v16)
      {
        uint64_t v7 = (_DWORD *)v14[1];
        v14[1] = (uint64_t)(v7 + 2);
        v14[2] = v17;
      }
      else
      {
        uint64_t v7 = (_DWORD *)x_heap_malloc_small_(v14, 8uLL);
      }
      hash_table_modify(*(int **)a2, (uint64_t)this, (uint64_t)v7, 0);
    }
    else
    {
      uint64_t v7 = (_DWORD *)((char *)this + 4 * v13 + 272);
    }
    float64x2_t v18 = *(uint64_t **)(v10 + 128);
    unint64_t v19 = v18[2];
    unint64_t v20 = v19 - 16;
    if (v19 >= 0x10)
    {
      int v21 = (void *)v18[1];
      v18[1] = (uint64_t)(v21 + 2);
      v18[2] = v20;
    }
    else
    {
      int v21 = (void *)x_heap_malloc_small_(v18, 0x10uLL);
    }
    uint64_t v22 = *(void *)(v10 + 208);
    *int v21 = this;
    v21[1] = v22;
    *(void *)(v10 + 208) = v21;
    CA::Transaction::unlock(a2);
    if ((*((unsigned char *)a2 + 116) & 4) != 0)
    {
      _DWORD *v7 = *((_DWORD *)this + 1) & 0xFBDFF480 | 1;
    }
    else
    {
      do
      {
        int v23 = *((_DWORD *)this + 1);
        if ((v23 & 0xFFFFFED7) == v23) {
          break;
        }
        int v24 = *((_DWORD *)this + 1);
        atomic_compare_exchange_strong((atomic_uint *volatile)this + 1, (unsigned int *)&v24, v23 & 0xFFFFFED7);
      }
      while (v24 != v23);
      _DWORD *v7 = v23 | 1;
      if ((v23 & 0x18) != 0) {
        int v25 = (4 * ((v23 & 6) != 0)) | 0x10;
      }
      else {
        int v25 = 4 * ((v23 & 6) != 0);
      }
      if ((v23 & 0x60) != 0) {
        v25 |= 0x40u;
      }
      if ((v23 & 0x300) != 0) {
        int v26 = v25 | 0x200;
      }
      else {
        int v26 = v25;
      }
      uint64_t v27 = CA::Layer::retain_parent(this, a2);
      if (v27)
      {
        int v28 = (CA::Layer *)v27;
        while (1)
        {
          uint64_t v29 = *((unsigned int *)a2 + 24);
          if ((v29 & 0x80000000) != 0 || (atomic_uint v30 = (char *)v28 + 4 * v29, (v31 = *((_DWORD *)v30 + 68)) == 0))
          {
            float v32 = (int *)CA::Layer::thread_flags_(v28, a2);
            int v31 = *v32;
          }
          else
          {
            float v32 = (int *)(v30 + 272);
          }
          if ((v26 & ~v31) == 0) {
            break;
          }
          int *v32 = v31 | v26;
          double v40 = CA::Layer::retain_parent(v28, a2);
          while (1)
          {
            int v33 = *(_DWORD *)v28;
            if (!*(_DWORD *)v28) {
              break;
            }
            int v34 = *(_DWORD *)v28;
            atomic_compare_exchange_strong((atomic_uint *volatile)v28, (unsigned int *)&v34, v33 - 1);
            if (v34 == v33)
            {
              if (v33 == 1)
              {
                CA::Layer::destroy(v28);
                CA::Layer::~Layer((CA::AttrList **)v28);
                malloc_zone = (malloc_zone_t *)get_malloc_zone();
                malloc_zone_free(malloc_zone, v28);
              }
              break;
            }
          }
          int v28 = (CA::Layer *)v40;
          if (!v40) {
            return v7;
          }
        }
        while (1)
        {
          int v37 = *(_DWORD *)v28;
          if (!*(_DWORD *)v28) {
            break;
          }
          int v36 = *(_DWORD *)v28;
          atomic_compare_exchange_strong((atomic_uint *volatile)v28, (unsigned int *)&v36, v37 - 1);
          if (v36 == v37)
          {
            if (v37 == 1)
            {
              CA::Layer::destroy(v28);
              CA::Layer::~Layer((CA::AttrList **)v28);
              BOOL v39 = (malloc_zone_t *)get_malloc_zone();
              malloc_zone_free(v39, v28);
            }
            return v7;
          }
        }
      }
    }
  }
  else
  {
    CA::Transaction::unlock(a2);
    return (_DWORD *)((char *)this + 4);
  }
  return v7;
}

void sub_184672AC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, atomic_uint *a9)
{
}

atomic_uint *CA::Layer::retain_parent(CA::Layer *this, CA::Transaction *a2)
{
  int v4 = *((_DWORD *)a2 + 25);
  *((_DWORD *)a2 + 25) = v4 + 1;
  if (!v4) {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
  }
  uint64_t v5 = (atomic_uint *)*((void *)this + 1);
  if (v5)
  {
    while (1)
    {
      atomic_uint v6 = *v5;
      if (!*v5) {
        break;
      }
      atomic_uint v7 = *v5;
      atomic_compare_exchange_strong(v5, (unsigned int *)&v7, v6 + 1);
      if (v7 == v6) {
        goto LABEL_8;
      }
    }
    uint64_t v5 = 0;
  }
LABEL_8:
  CA::Transaction::unlock(a2);
  return v5;
}

CA::Transaction *CALayerGetSuperlayer(CA::Transaction *a1)
{
  uint64_t v1 = a1;
  if (a1)
  {
    uint64_t v2 = *(CA::Transaction **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 576);
    if (!v2) {
      uint64_t v2 = (CA::Transaction *)CA::Transaction::create(a1);
    }
    int v3 = *((_DWORD *)v2 + 25);
    *((_DWORD *)v2 + 25) = v3 + 1;
    if (!v3) {
      os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
    }
    uint64_t v4 = *(void *)(*((void *)v1 + 2) + 8);
    if (v4) {
      uint64_t v1 = *(CA::Transaction **)(v4 + 16);
    }
    else {
      uint64_t v1 = 0;
    }
    CA::Transaction::unlock(v2);
  }
  return v1;
}

void CA::Transaction::unlock(CA::Transaction *this)
{
  int v1 = *((_DWORD *)this + 25);
  if (v1)
  {
    int v3 = v1 - 1;
    *((_DWORD *)this + 25) = v3;
    if (!v3)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
      uint64_t v4 = (void *)*((void *)this + 4);
      if (v4)
      {
        *((void *)this + 4) = 0;
        CA::release_objects(v4);
      }
    }
  }
}

uint64_t CALayerRetain(uint64_t a1)
{
  uint64_t v1 = a1;
  do
  {
    int v2 = *(_DWORD *)(a1 + 8);
    if ((v2 - 1) > 0xFFFFFFFD) {
      return 0;
    }
    int v3 = *(_DWORD *)(a1 + 8);
    atomic_compare_exchange_strong((atomic_uint *volatile)(a1 + 8), (unsigned int *)&v3, v2 + 1);
  }
  while (v3 != v2);
  if (*MEMORY[0x1E4F1CBC0]) {
    NSRecordAllocationEvent();
  }
  return v1;
}

void CA::Layer::update_for_changed_sublayers(atomic_uint *this, CA::Transaction *a2, int a3)
{
  if (a3)
  {
    uint64_t v4 = (CA::Layer *)this;
    if ((a3 & 0x18) != 0) {
      int v5 = (4 * ((a3 & 6) != 0)) | 0x10;
    }
    else {
      int v5 = 4 * ((a3 & 6) != 0);
    }
    if ((a3 & 0x60) != 0) {
      v5 |= 0x40u;
    }
    if ((a3 & 0x300) != 0) {
      v5 |= 0x200u;
    }
    int v6 = v5 | a3 & 0x800;
    while (1)
    {
      atomic_uint v7 = *this;
      if (!*this) {
        break;
      }
      atomic_uint v8 = *this;
      atomic_compare_exchange_strong(this, (unsigned int *)&v8, v7 + 1);
      if (v8 == v7)
      {
        unint64_t v20 = this;
        while (1)
        {
          uint64_t v9 = *((unsigned int *)a2 + 24);
          if ((v9 & 0x80000000) != 0 || (uint64_t v10 = (char *)v4 + 4 * v9, (v11 = *((_DWORD *)v10 + 68)) == 0))
          {
            int v12 = CA::Layer::thread_flags_(v4, a2);
            int v11 = *v12;
            uint64_t v4 = (CA::Layer *)v20;
          }
          else
          {
            int v12 = (int *)(v10 + 272);
          }
          if ((v6 & ~v11) == 0) {
            break;
          }
          *int v12 = v11 | v6;
          uint64_t v13 = CA::Layer::retain_parent(v4, a2);
          unint64_t v20 = v13;
          if (v4)
          {
            while (1)
            {
              int v14 = *(_DWORD *)v4;
              if (!*(_DWORD *)v4) {
                break;
              }
              int v15 = *(_DWORD *)v4;
              atomic_compare_exchange_strong((atomic_uint *volatile)v4, (unsigned int *)&v15, v14 - 1);
              if (v15 == v14)
              {
                if (v14 == 1)
                {
                  CA::Layer::destroy(v4);
                  CA::Layer::~Layer((CA::AttrList **)v4);
                  malloc_zone = (malloc_zone_t *)get_malloc_zone();
                  malloc_zone_free(malloc_zone, v4);
                }
                break;
              }
            }
            uint64_t v4 = (CA::Layer *)v20;
            if (!v20) {
              return;
            }
          }
          else
          {
            uint64_t v4 = (CA::Layer *)v13;
            if (!v13) {
              return;
            }
          }
        }
        if (v4)
        {
          while (1)
          {
            int v17 = *(_DWORD *)v4;
            if (!*(_DWORD *)v4) {
              break;
            }
            int v18 = *(_DWORD *)v4;
            atomic_compare_exchange_strong((atomic_uint *volatile)v4, (unsigned int *)&v18, v17 - 1);
            if (v18 == v17)
            {
              if (v17 == 1)
              {
                CA::Layer::destroy(v4);
                CA::Layer::~Layer((CA::AttrList **)v4);
                unint64_t v19 = (malloc_zone_t *)get_malloc_zone();
                malloc_zone_free(v19, v4);
              }
              return;
            }
          }
        }
        return;
      }
    }
  }
}

void sub_184672E84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, atomic_uint *a9)
{
}

CA::Layer *CA::Layer::update_added_sublayer(CA::Layer *this, CA::Transaction *a2, CA::Layer *a3, int a4)
{
  int v8 = *((_DWORD *)this + 67);
  int v9 = *((_DWORD *)a2 + 25);
  *((_DWORD *)a2 + 25) = v9 + 1;
  if (!v9) {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
  }
  *((void *)this + 1) = a3;
  *((_DWORD *)this + 67) = 0;
  CA::Transaction::unlock(a2);
  CA::Layer::mark_visible(this, a2, (*((_DWORD *)a3 + 13) >> 20) & 1);
  CA::Transaction::remove_root(a2, (atomic_uint *)this);
  if (v8 && v8 != a4) {
    CA::Layer::mark_context_changed((atomic_uint *)this, (CA::Transaction **)a2);
  }
  int v10 = *((_DWORD *)a3 + 1) & 0x400000;
  if ((*((_DWORD *)this + 12) & 0x800) != 0) {
    v10 ^= 0x400000u;
  }
  if ((*((_DWORD *)this + 1) & 0x400000) != v10) {
    CA::Layer::toggle_flipped(this, a2);
  }
  uint64_t result = (CA::Layer *)dyld_program_sdk_at_least();
  if (result)
  {
    return CA::Layer::ensure_transaction_recursively(this, a2);
  }
  return result;
}

void CA::Transaction::remove_root(CA::Transaction *this, atomic_uint *a2)
{
  uint64_t v2 = *((void *)this + 6);
  if (v2 && x_hash_table_remove_ptr(v2, (uint64_t)a2))
  {
    while (1)
    {
      atomic_uint v4 = *a2;
      if (!*a2) {
        break;
      }
      atomic_uint v5 = *a2;
      atomic_compare_exchange_strong(a2, (unsigned int *)&v5, v4 - 1);
      if (v5 == v4)
      {
        if (v4 == 1)
        {
          CA::Layer::destroy((CA::Layer *)a2);
          CA::Layer::~Layer((CA::AttrList **)a2);
          malloc_zone = (malloc_zone_t *)get_malloc_zone();
          malloc_zone_free(malloc_zone, a2);
        }
        return;
      }
    }
  }
}

void CA::Layer::remove_from_context(CA::Layer *this)
{
  if ((*((unsigned char *)this + 54) & 0x10) != 0)
  {
    uint64_t v2 = CA::Layer::retain_context(this);
    if (v2)
    {
      int v3 = (CA::Context *)v2;
      if (*((void *)v2 + 12) == *((void *)this + 2))
      {
        atomic_uint v4 = *(CA::Transaction **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 576);
        if (!v4) {
          atomic_uint v4 = (CA::Transaction *)CA::Transaction::create((CA::Transaction *)v2);
        }
        CA::Transaction::unlock(v4);
        CA::Context::set_layer(v3, 0);
        int v5 = *((_DWORD *)v4 + 25);
        *((_DWORD *)v4 + 25) = v5 + 1;
        if (!v5) {
          os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
        }
      }
      CA::Context::unref(v3, 0);
    }
  }
}

void sub_1846730E4(_Unwind_Exception *exception_object)
{
  int v3 = *(_DWORD *)(v1 + 100);
  *(_DWORD *)(v1 + 100) = v3 + 1;
  if (!v3) {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
  }
  _Unwind_Resume(exception_object);
}

void CAMediaTimingInvalidate(uint64_t a1)
{
  if (a1 && timing_cache)
  {
    unint64_t v1 = a1 ^ 0x8000000000000000;
    os_unfair_lock_lock((os_unfair_lock_t)&timing_lock);
    x_hash_table_remove(timing_cache, v1);
    os_unfair_lock_unlock((os_unfair_lock_t)&timing_lock);
  }
}

uint64_t x_hash_table_remove_ptr(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 24))
  {
    atomic_uint v4 = (void *)(*(void *)(a1 + 16) + 8
                                         * (*(void *)(a1 + 8) & (*(uint64_t (**)(uint64_t))(a1 + 32))(a2)));
    while (1)
    {
      int v5 = v4;
      atomic_uint v4 = (void *)*v4;
      if (!v4) {
        break;
      }
      if (v4[2] == a2)
      {
        *int v5 = *v4;
        uint64_t v6 = v4[3];
        atomic_uint v7 = *(void (**)(void))(a1 + 48);
        if (v7) {
          v7(v4[2]);
        }
        int v8 = *(void (**)(uint64_t))(a1 + 56);
        if (v8) {
          v8(v6);
        }
        uint64_t v9 = *(void *)(a1 + 72);
        if (v9)
        {
          *atomic_uint v4 = *(void *)(v9 + 8);
          *(void *)(v9 + 8) = v4;
        }
        else
        {
          malloc_zone = (malloc_zone_t *)get_malloc_zone();
          malloc_zone_free(malloc_zone, v4);
        }
        --*(void *)(a1 + 24);
        return v6;
      }
    }
  }
  return 0;
}

uint64_t x_hash_table_remove(uint64_t a1, uint64_t a2)
{
  if (!*(void *)(a1 + 24)) {
    return 0;
  }
  if ((*(unsigned char *)(a1 + 80) & 2) != 0)
  {
    return x_hash_table_remove_ptr(a1, a2);
  }
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(a1 + 32))(a2);
  int v5 = (void **)(*(void *)(a1 + 16) + 8 * (*(void *)(a1 + 8) & v4));
  uint64_t v6 = *v5;
  if (!*v5) {
    return 0;
  }
  uint64_t v7 = v4;
  while (v6[1] != v7)
  {
LABEL_8:
    int v5 = (void **)v6;
    uint64_t v6 = (void *)*v6;
    if (!v6) {
      return 0;
    }
  }
  if ((*(unsigned int (**)(void, uint64_t))(a1 + 40))(v6[2], a2))
  {
    uint64_t v6 = *v5;
    goto LABEL_8;
  }
  *int v5 = (void *)*v6;
  uint64_t v8 = v6[3];
  int v10 = *(void (**)(void))(a1 + 48);
  if (v10) {
    v10(v6[2]);
  }
  int v11 = *(void (**)(uint64_t))(a1 + 56);
  if (v11) {
    v11(v8);
  }
  uint64_t v12 = *(void *)(a1 + 72);
  if (v12)
  {
    void *v6 = *(void *)(v12 + 8);
    *(void *)(v12 + 8) = v6;
  }
  else
  {
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(malloc_zone, v6);
  }
  --*(void *)(a1 + 24);
  return v8;
}

void CA::Layer::collect_non_visible_callback(CA::Layer *this, uint64_t **a2, void *a3)
{
  int v5 = (_WORD *)*((void *)this + 35);
  int v24 = v5;
  if (v5)
  {
    uint64_t v6 = &v24;
    do
    {
      schedule_stop_callback((uint64_t)v5, (uint64_t *)&animation_state);
      __int16 v7 = v5[28];
      if ((v7 & 0x41) == 1)
      {
        void *v6 = *(void *)v5;
        free_non_deferred_animation(v5, 1);
      }
      else
      {
        v5[28] = v7 & 0xFFFB | (4 * ((v7 & 5) != 0));
        uint64_t v6 = v5;
      }
      int v5 = (_WORD *)*v6;
    }
    while (*v6);
    uint64_t v8 = v24;
    *((void *)this + 35) = v24;
    if (v8) {
      return;
    }
  }
  else
  {
    *((void *)this + 35) = 0;
  }
  int v10 = *a2;
  uint64_t v9 = a2[1];
  uint64_t v11 = v9 - *a2;
  unint64_t v12 = (unint64_t)a2[3];
  if (v12 < v11 + 1)
  {
    uint64_t v13 = a2[2];
    unint64_t v14 = (v12 + 1) | ((v12 + 1) >> 1) | (((v12 + 1) | ((v12 + 1) >> 1)) >> 2);
    unint64_t v15 = v14 | (v14 >> 4) | ((v14 | (v14 >> 4)) >> 8);
    unint64_t v16 = v15 | (v15 >> 16) | ((v15 | (v15 >> 16)) >> 32);
    if (v16 + 1 > v11 + 1) {
      uint64_t v17 = v16 + 1;
    }
    else {
      uint64_t v17 = v11 + 1;
    }
    int v18 = (uint64_t *)malloc_type_malloc(8 * v17, 0x2004093837F09uLL);
    unint64_t v19 = v18;
    unint64_t v20 = *a2;
    int v21 = a2[1];
    if (*a2 != v21)
    {
      uint64_t v22 = v18;
      do
      {
        uint64_t v23 = *v20++;
        *v22++ = v23;
      }
      while (v20 != v21);
    }
    if (v10 != v13) {
      free(*a2);
    }
    uint64_t v9 = &v19[v11];
    *a2 = v19;
    a2[1] = v9;
    a2[3] = (uint64_t *)v17;
  }
  *uint64_t v9 = (uint64_t)this;
  ++a2[1];
}

void schedule_stop_callback(uint64_t a1, uint64_t *a2)
{
  if ((*(_WORD *)(a1 + 56) & 0x1000) != 0) {
    schedule_start_callback((void *)a1, (uint64_t)a2);
  }
  uint64_t v4 = *(dispatch_block_t **)(a1 + 48);
  if (v4)
  {
    CA::Transaction::Continuation::unref(v4);
    *(void *)(a1 + 48) = 0;
  }
  if ((*(_WORD *)(a1 + 56) & 0x2000) != 0)
  {
    uint64_t v5 = *a2;
    uint64_t v6 = *(void *)(a1 + 8);
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    uint64_t v8 = malloc_type_zone_malloc(malloc_zone, 0x10uLL, 0x8BB15036uLL);
    *uint64_t v8 = v6;
    v8[1] = v5;
    *a2 = (uint64_t)v8;
    CFRetain(*(CFTypeRef *)(a1 + 8));
    *(_WORD *)(a1 + 56) &= ~0x2000u;
  }
}

const char *_CAInternAtomWithCString(const char *__s)
{
  if (__s)
  {
    unint64_t v1 = __s;
    uint64_t v2 = *(unsigned __int8 *)__s;
    if (*__s && (int v3 = strlen(__s), v4 = v3 - 1, (v3 - 1) <= 0x2D))
    {
      switch(v3)
      {
        case 1:
          goto LABEL_9;
        case 2:
        case 3:
        case 4:
          goto LABEL_8;
        case 5:
          goto LABEL_7;
        case 6:
        case 7:
        case 8:
        case 9:
          goto LABEL_6;
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
          goto LABEL_5;
        default:
          v3 += hash_asso_values[*((unsigned __int8 *)v1 + 24)];
LABEL_5:
          v3 += hash_asso_values[*((unsigned __int8 *)v1 + 9)];
LABEL_6:
          v3 += hash_asso_values[*((unsigned __int8 *)v1 + 5) + 1];
LABEL_7:
          v3 += hash_asso_values[*((unsigned __int8 *)v1 + 4)];
LABEL_8:
          v3 += hash_asso_values[*((unsigned __int8 *)v1 + 1)];
LABEL_9:
          uint64_t v5 = v3 + hash_asso_values[v2] + hash_asso_values[v1[v4]];
          if (v5 > 0x652) {
            return 0;
          }
          if (*((__int16 *)&wordlist
               + 2 * v3
               + 2 * hash_asso_values[v2]
               + 2 * hash_asso_values[v1[v4]]) < 0)
            return 0;
          uint64_t v6 = &stringpool_contents[*((unsigned __int16 *)&wordlist
                                    + 2 * v3
                                    + 2 * hash_asso_values[v2]
                                    + 2 * hash_asso_values[v1[v4]])];
          if (v2 != *v6 || strcmp(v1 + 1, v6 + 1)) {
            return 0;
          }
          __s = (const char *)*((unsigned __int16 *)&wordlist + 2 * v5 + 1);
          break;
      }
    }
    else
    {
      return 0;
    }
  }
  return __s;
}

CA::Render *CA::Render::key_path_set(CA::Render *this, CFStringRef theString, const __CFString *a3)
{
  int v3 = this;
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (theString)
  {
    memset(v13, 0, sizeof(v13));
    if (CFStringGetCString(theString, buffer, 1024, 0x8000100u))
    {
      uint64_t v6 = 0;
      __int16 v7 = buffer;
      while (2)
      {
        uint64_t v8 = (CA::Render *)v7;
        do
        {
          int v10 = *v7++;
          int v9 = v10;
          if (!v10)
          {
            if (v7 <= (char *)v8) {
              return (CA::Render *)CA::Render::key_path_set_atoms(v3, v6, v13, v5);
            }
            int v12 = CA::Render::parse_index(v8, v7, v4);
            if (v12 || (int v12 = CAInternAtomWithCString((const char *)v8)) != 0)
            {
              *((_DWORD *)v13 + (void)v6) = v12;
              uint64_t v6 = (void **)((char *)v6 + 1);
              return (CA::Render *)CA::Render::key_path_set_atoms(v3, v6, v13, v5);
            }
            goto LABEL_16;
          }
        }
        while (v9 != 46);
        *(v7 - 1) = 0;
        int v11 = CA::Render::parse_index(v8, v7, v4);
        if (!v11)
        {
          int v11 = CAInternAtomWithCString((const char *)v8);
          if (!v11) {
            goto LABEL_16;
          }
        }
        *((_DWORD *)v13 + (void)v6) = v11;
        uint64_t v6 = (void **)((char *)v6 + 1);
        if (v6 != (void **)16) {
          continue;
        }
        break;
      }
    }
    else
    {
LABEL_16:
      uint64_t v6 = 0;
    }
    return (CA::Render *)CA::Render::key_path_set_atoms(v3, v6, v13, v5);
  }
  else
  {
    *(void *)this = 0;
  }
  return this;
}

uint64_t CA::Render::parse_index(CA::Render *this, const char *a2, const char *a3)
{
  v9[1] = *(char **)MEMORY[0x1E4F143B8];
  if (a2 - (const char *)this < 9) {
    return 0;
  }
  if (*(unsigned char *)this != 64) {
    return 0;
  }
  int v4 = (char *)(a2 - 2);
  if (*(a2 - 2) != 41 || strncmp((const char *)this, "@index(", 7uLL)) {
    return 0;
  }
  v9[0] = 0;
  int v6 = strtol((const char *)this + 7, v9, 10);
  if (v6 >> 30) {
    BOOL v7 = 1;
  }
  else {
    BOOL v7 = v6 <= -1;
  }
  if (!v7 && v9[0] == v4) {
    return v6 | 0x40000000u;
  }
  else {
    return 0;
  }
}

CA::Render::PresentationModifier *CA::Render::PresentationModifier::PresentationModifier(CA::Render::PresentationModifier *this, CA::Render::Decoder *a2)
{
  *(void *)this = &unk_1ED02F670;
  *((_DWORD *)this + 2) = 1;
  *((_DWORD *)this + 3) = (CA::Render::Decoder::decode_int32(a2) << 8) | 0x2A;
  ++dword_1EB2ADE70;
  *(void *)this = &unk_1ED02ED30;
  *((void *)this + 2) = CA::Render::Decoder::decode_object(a2, 47);
  *((void *)this + 3) = CA::Render::Decoder::decode_size_t(a2);
  *((void *)this + 4) = CA::Render::Decoder::decode_keypath(a2);
  *((_DWORD *)this + 10) = CA::Render::Decoder::decode_int32(a2);
  return this;
}

uint64_t CA::Render::Decoder::decode_keypath(CA::Render::Decoder *this)
{
  v12[1] = *MEMORY[0x1E4F143B8];
  v12[0] = 0;
  if ((*((unsigned char *)this + 18) & 1) == 0)
  {
    uint64_t v2 = CA::Render::Decoder::decode_int16(this);
    int v3 = (void **)v2;
    if (v2 >= 0x401)
    {
      uint64_t v5 = malloc_type_malloc(4 * v2, 0x6FA2ED0BuLL);
      if (!v5)
      {
        CA::Render::Decoder::set_fatal_error(this, "%s - atoms = NULL", "decode_keypath");
        v12[0] = 0;
        return v12[0];
      }
    }
    else
    {
      MEMORY[0x1F4188790](v2);
      uint64_t v5 = (_DWORD *)((char *)v12 - v4);
      bzero((char *)v12 - v4, v6);
      if (!v3)
      {
        CA::Render::key_path_set_atoms((CA::Render *)v12, v3, v5, v7);
        return v12[0];
      }
    }
    uint64_t v8 = 0;
    do
    {
      if (CA::Render::Decoder::decode_int8(this)) {
        unsigned int v9 = CA::Render::Decoder::decode_int32(this) | 0x40000000;
      }
      else {
        unsigned int v9 = CA::Render::Decoder::decode_atom(this);
      }
      v5[(void)v8] = v9;
      uint64_t v8 = (void **)((char *)v8 + 1);
    }
    while (v3 != v8);
    CA::Render::key_path_set_atoms((CA::Render *)v12, v3, v5, v10);
    if (v3 > 0x400) {
      free(v5);
    }
  }
  return v12[0];
}

UInt8 *CA::Render::Decoder::decode_atom(CA::Render::Decoder *this)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (*((unsigned char *)this + 18)) {
    return 0;
  }
  uint64_t v2 = CA::Render::Decoder::decode_int8(this);
  int v3 = (UInt8 *)v2;
  if (v2 > 0xFD)
  {
    if (v2 == 254) {
      return (UInt8 *)CA::Render::Decoder::decode_int16(this);
    }
    CFIndex numBytes = 0;
    int v3 = (UInt8 *)CA::Render::Decoder::decode_data(this, v7, 0x100uLL, (unint64_t *)&numBytes, 0x400uLL);
    if (!v3)
    {
      CA::Render::Decoder::set_fatal_error(this, "%s - ptr = NULL", "decode_atom");
      return v3;
    }
    CFStringRef v4 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF98], v3, numBytes, 0x8000100u, 1u);
    if (v3 != v7) {
      free(v3);
    }
    if (v4)
    {
      int v3 = (UInt8 *)CAInternAtom(v4, 1);
      CFRelease(v4);
      return v3;
    }
    CA::Render::Decoder::set_fatal_error(this, "%s - string = NULL", "decode_atom");
    return 0;
  }
  return v3;
}

uint64_t CA::Render::key_path_set_atoms(CA::Render *this, void **a2, _DWORD *a3, const unsigned int *a4)
{
  if (a2)
  {
    if (a2 == (void **)1)
    {
      uint64_t result = (2 * *a3) | 1u;
    }
    else
    {
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      uint64_t result = (uint64_t)malloc_type_zone_malloc(malloc_zone, 4 * (void)a2 + 4, 0x8BB15036uLL);
      unsigned int v9 = 0;
      *(_DWORD *)uint64_t result = a2;
      do
      {
        *(_DWORD *)(result + 4 * (void)v9 + 4) = a3[(void)v9];
        unsigned int v9 = (void **)((char *)v9 + 1);
      }
      while (a2 != v9);
    }
  }
  else
  {
    uint64_t result = 0;
  }
  *(void *)this = result;
  return result;
}

atomic_uint *CA::Render::Layer::set_single_sublayer(uint64_t a1, atomic_uint *a2)
{
  uint64_t v2 = a2;
  int v4 = *(_DWORD *)(a1 + 12);
  uint64_t result = *(atomic_uint **)(a1 + 104);
  if ((v4 & 0x2000) != 0)
  {
    if (result == a2) {
      return result;
    }
    if (result && atomic_fetch_add(result + 2, 0xFFFFFFFF) == 1) {
      uint64_t result = (atomic_uint *)(*(uint64_t (**)(atomic_uint *))(*(void *)result + 16))(result);
    }
    if (!v2) {
      goto LABEL_15;
    }
    goto LABEL_13;
  }
  if (result)
  {
    if (atomic_fetch_add(result + 2, 0xFFFFFFFF) == 1) {
      uint64_t result = (atomic_uint *)(*(uint64_t (**)(atomic_uint *))(*(void *)result + 16))(result);
    }
    int v4 = *(_DWORD *)(a1 + 12);
  }
  *(void *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 12) = v4 | 0x2000;
  if (v2)
  {
LABEL_13:
    size_t v6 = v2 + 2;
    if (!atomic_fetch_add(v2 + 2, 1u))
    {
      uint64_t v2 = 0;
      atomic_fetch_add(v6, 0xFFFFFFFF);
    }
LABEL_15:
    *(void *)(a1 + 104) = v2;
  }
  return result;
}

void CA::Render::Filter::~Filter(CA::Render::Filter *this, const CA::Render::Object *a2)
{
  CA::Render::Filter::~Filter(this, a2);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  atomic_uint *v3;
  atomic_uint *v4;

  *(void *)this = &unk_1ED02F590;
  int v3 = (atomic_uint *)*((void *)this + 5);
  if (v3 && atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v3 + 16))(v3);
  }
  int v4 = (atomic_uint *)*((void *)this + 4);
  if (v4 && atomic_fetch_add(v4 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
  }
  --dword_1EB2ADE0C;
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  }
}

void CA::Render::Array::finalize(CA::Render::Array *this)
{
  (**(void (***)(CA::Render::Array *))this)(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

void CA::Render::Array::~Array(CA::Render::Array *this, const CA::Render::Object *a2)
{
  *(void *)this = &unk_1ED02F158;
  int v3 = *((_DWORD *)this + 3);
  if ((v3 & 0x100) == 0)
  {
    unint64_t v4 = *((unsigned int *)this + 4);
    if (v4)
    {
      for (unint64_t i = 0; i < v4; ++i)
      {
        size_t v6 = (atomic_uint *)*((void *)this + i + 3);
        if (v6)
        {
          if (atomic_fetch_add(v6 + 2, 0xFFFFFFFF) == 1) {
            (*(void (**)(atomic_uint *))(*(void *)v6 + 16))(v6);
          }
          unint64_t v4 = *((unsigned int *)this + 4);
        }
      }
      int v3 = *((_DWORD *)this + 3);
    }
  }
  --dword_1EB2ADDCC;
  *(void *)this = &unk_1ED02F670;
  if (v3 < 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  }
}

{
  malloc_zone_t *malloc_zone;
  uint64_t vars8;

  CA::Render::Array::~Array(this, a2);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

void CA::Render::KeyValue::~KeyValue(CA::Render::KeyValue *this, const CA::Render::Object *a2)
{
  *(void *)this = &unk_1ED02FFB8;
  int v3 = (atomic_uint *)*((void *)this + 3);
  if (v3 && atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v3 + 16))(v3);
  }
  --dword_1EB2ADE38;
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  atomic_uint *v3;

  *(void *)this = &unk_1ED02FFB8;
  int v3 = (atomic_uint *)*((void *)this + 3);
  if (v3 && atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v3 + 16))(v3);
  }
  --dword_1EB2ADE38;
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  }
}

void CA::Render::Vector::finalize(CA::Render::Vector *this)
{
  (**(void (***)(CA::Render::Vector *))this)(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

void CA::Render::Vector::~Vector(CA::Render::Vector *this, const CA::Render::Object *a2)
{
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  }
}

{
  malloc_zone_t *malloc_zone;
  uint64_t vars8;

  --dword_1EB2ADEA8;
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

void *CA::Render::Update::release_objects(void *this)
{
  unint64_t v1 = (void *)this[40];
  if (v1)
  {
    uint64_t v2 = this;
    do
    {
      int v3 = v1;
      atomic_compare_exchange_strong(v2 + 40, (unint64_t *)&v3, 0);
      if (v3 == v1)
      {
        do
        {
          this = (void *)*v1;
          if (atomic_fetch_add((atomic_uint *volatile)(*v1 + 8), 0xFFFFFFFF) == 1) {
            this = (void *)(*(uint64_t (**)(void *))(*this + 16))(this);
          }
          unint64_t v1 = (void *)v1[1];
        }
        while (v1);
      }
      unint64_t v1 = (void *)v2[40];
    }
    while (v1);
  }
  return this;
}

uint64_t CA::Render::Object::finalize(uint64_t this)
{
  if (this) {
    return (*(uint64_t (**)(void))(*(void *)this + 8))();
  }
  return this;
}

void CA::Render::PresentationModifier::~PresentationModifier(CA::Render **this, void **a2)
{
  CA::Render::PresentationModifier::~PresentationModifier(this, a2);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  const CA::Render::Object *v3;
  atomic_uint *v4;

  *this = (CA::Render *)&unk_1ED02ED30;
  CA::Render::key_path_free(this[4], a2);
  unint64_t v4 = (atomic_uint *)this[2];
  if (v4 && atomic_fetch_add(v4 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
  }
  --dword_1EB2ADE70;
  *this = (CA::Render *)&unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate((CA::Render::Encoder::ObjectCache *)this, v3);
  }
}

void CA::Render::key_path_free(CA::Render *this, void **a2)
{
  if (this && (this & 1) == 0)
  {
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(malloc_zone, this);
  }
}

void CA::Render::String::finalize(CA::Render::String *this)
{
  uint64_t v2 = (const void *)*((void *)this + 2);
  if (v2) {
    CFRelease(v2);
  }
  (**(void (***)(CA::Render::String *))this)(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

void CA::Render::String::~String(CA::Render::String *this, const CA::Render::Object *a2)
{
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  }
}

{
  malloc_zone_t *malloc_zone;
  uint64_t vars8;

  --dword_1EB2ADE8C;
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

void CA::Render::Timing::~Timing(CA::Render::Timing *this, const CA::Render::Object *a2)
{
  --dword_1EB2ADE98;
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  --dword_1EB2ADE98;
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  }
}

atomic_uint *release_timing(atomic_uint *result)
{
  if (result)
  {
    if (atomic_fetch_add(result + 2, 0xFFFFFFFF) == 1) {
      return (atomic_uint *)(*(uint64_t (**)(void))(*(void *)result + 16))();
    }
  }
  return result;
}

uint64_t CA::Transaction::ensure_implicit(CA::Transaction *this, int a2)
{
  if (BYTE7(ca_debug_options))
  {
    pthread_t v10 = pthread_self();
    NSLog(&cfstr_StartedImplici.isa, v10);
  }
  Current = (__CFRunLoop *)*((void *)this + 7);
  if (!Current)
  {
    Current = CFRunLoopGetCurrent();
    *((void *)this + 7) = Current;
  }
  if (!*((void *)this + 8))
  {
    BOOL v7 = CFRunLoopObserverCreate(0, 0xA0uLL, 1u, 2000000, (CFRunLoopObserverCallBack)CA::Transaction::observer_callback, 0);
    *((void *)this + 8) = v7;
    if (!v7) {
      goto LABEL_17;
    }
    CFRunLoopAddObserver(*((CFRunLoopRef *)this + 7), v7, (CFRunLoopMode)*MEMORY[0x1E4F1D410]);
    if (!*((void *)this + 8)) {
      goto LABEL_17;
    }
    Current = (__CFRunLoop *)*((void *)this + 7);
  }
  CFRunLoopMode v5 = CFRunLoopCopyCurrentMode(Current);
  if (v5)
  {
    CFStringRef v6 = v5;
    if (v5 != (CFRunLoopMode)*MEMORY[0x1E4F1D418])
    {
      if (!CA::Transaction::ensure_implicit(BOOL)::tracking_mode && CFEqual(v5, @"UITrackingRunLoopMode"))
      {
        CA::Transaction::ensure_implicit(BOOL)::tracking_mode = (uint64_t)CFRetain(v6);
        CFRunLoopAddObserver(*((CFRunLoopRef *)this + 7), *((CFRunLoopObserverRef *)this + 8), v6);
      }
      if (v6 != (const __CFString *)CA::Transaction::ensure_implicit(BOOL)::tracking_mode) {
        CFRunLoopAddObserver(*((CFRunLoopRef *)this + 7), *((CFRunLoopObserverRef *)this + 8), v6);
      }
    }
    CFRelease(v6);
  }
LABEL_17:
  CA::Transaction::push(this, 1, a2);
  *(unsigned char *)(*((void *)this + 13) + 204) |= 1u;
  uint64_t result = *(void *)(*((void *)this + 13) + 112);
  if (result)
  {
    unsigned int v9 = *(uint64_t (**)(void))(result + 16);
    return v9();
  }
  return result;
}

uint64_t CA::Transaction::push(CA::Transaction *this, BOOL a2, int a3)
{
  uint64_t v4 = *((void *)this + 13);
  if (atomic_fetch_add((atomic_uint *volatile)v4, 1u))
  {
    if (!*((void *)this + 11))
    {
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      *((void *)this + 11) = malloc_type_zone_calloc(malloc_zone, 1uLL, 0x20uLL, 0x743898A5uLL);
    }
    CFStringRef v6 = (malloc_zone_t *)get_malloc_zone();
    uint64_t result = (uint64_t)malloc_type_zone_calloc(v6, 1uLL, 0x20uLL, 0x743898A5uLL);
    *(void *)uint64_t result = *((void *)this + 11);
    *((void *)this + 11) = result;
    return result;
  }
  *(unsigned char *)(v4 + 204) &= 0xFCu;
  *(void *)(v4 + 144) = 0;
  uint64_t v9 = mach_absolute_time();
  *(double *)(v4 + 152) = CATimeWithHostTime(v9);
  *(void *)(v4 + 232) = 0;
  *((void *)this + 46) = 0;
  *((void *)this + 47) = (char *)this + 400;
  *((_OWORD *)this + 24) = xmmword_184998260;
  *(void *)(v4 + 128) = (char *)this + 368;
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::slot_lock);
  if (CA::Transaction::slot_mask)
  {
    if ((CA::Transaction::slot_mask & 2) != 0)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&CA::Transaction::slot_lock);
      uint64_t result = (uint64_t)x_hash_table_new_(0, 0, 0, 0, 0, 0);
      *(void *)(v4 + 8) = result;
      int v10 = *(_DWORD *)(v4 + 4);
      goto LABEL_11;
    }
    int v11 = 2;
    int v10 = 1;
  }
  else
  {
    int v10 = 0;
    int v11 = 1;
  }
  CA::Transaction::slot_mask |= v11;
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Transaction::slot_lock);
  *(_DWORD *)(v4 + 4) = v10;
  uint64_t result = *(void *)(v4 + 8);
LABEL_11:
  *((_DWORD *)this + 24) = v10;
  *(void *)this = result;
  if (BYTE9(xmmword_1EB2ACC10)) {
    uint64_t result = kdebug_trace();
  }
  if (CA::Transaction::_debug_transactions)
  {
    int v12 = (void **)malloc_type_malloc(0x1000uLL, 0x80040B8603338uLL);
    *(void *)(v4 + 240) = v12;
    uint64_t result = backtrace(v12, 512);
    *(_WORD *)(v4 + 206) = result;
  }
  if (CA::Transaction::_assert_transactions)
  {
    if (a3)
    {
      uint64_t result = pthread_main_np();
      if (!result && (*((unsigned char *)this + 116) & 8) == 0) {
        CA::CA_ABORT_ON_NON_MAIN_THREAD_TRANSACTION_PUSH((CA *)result);
      }
    }
  }
  return result;
}

uint64_t CA::Render::Timing::map_time(CA::Render::Timing *this, double *a2, unsigned int *a3)
{
  uint64_t v6 = CA::Render::Timing::map_parent_to_active(this, a2, 0);
  if (v6)
  {
    CA::Render::Timing::map_active_to_local((uint64_t)this, a2, a3);
  }
  else if (a3)
  {
    *a3 = 0;
  }
  return v6;
}

void CA::OGL::iosurface_textures_destroy_value(id *a1)
{
  JUMPOUT(0x185323DA0);
}

void CA::Render::Updater::FlattenZOp::map_transform(uint64_t a1, uint64_t a2)
{
  if ((*(unsigned char *)(a2 + 144) & 0x10) != 0)
  {
    *(void *)(a2 + 16) = 0;
    *(void *)(a2 + 48) = 0;
    *(void *)(a2 + 80) = 0x3FF0000000000000;
    *(void *)(a2 + 112) = 0;
  }
}

uint64_t CA::Render::BackdropLayer::visit_subclass(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 32))(a2, a1);
}

uint64_t CA::Render::Updater::FilterOp::copy(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = x_heap_malloc_small_(a2, 0x38uLL);
  uint64_t v5 = v4;
  if (v4)
  {
    *(_WORD *)(v4 + 16) = 1;
    *(unsigned char *)(v4 + 18) = 0;
    *(void *)uint64_t v4 = &unk_1ED02FE40;
  }
  uint64_t v6 = x_heap_malloc_small_(a2, 0x28uLL);
  if (v6)
  {
    BOOL v7 = *(long long **)(a1 + 24);
    long long v8 = *v7;
    long long v9 = v7[1];
    *(void *)(v6 + 32) = *((void *)v7 + 4);
    *(_OWORD *)uint64_t v6 = v8;
    *(_OWORD *)(v6 + 16) = v9;
  }
  *(void *)(v5 + 24) = v6;
  uint64_t v10 = *(void *)(a1 + 32);
  if (v10)
  {
    int v11 = (atomic_uint *)(v10 + 8);
    if (!atomic_fetch_add((atomic_uint *volatile)(v10 + 8), 1u))
    {
      uint64_t v10 = 0;
      atomic_fetch_add(v11, 0xFFFFFFFF);
    }
  }
  *(void *)(v5 + 32) = v10;
  uint64_t v12 = *(void *)(a1 + 40);
  if (v12)
  {
    uint64_t v13 = (atomic_uint *)(v12 + 8);
    if (!atomic_fetch_add((atomic_uint *volatile)(v12 + 8), 1u))
    {
      uint64_t v12 = 0;
      atomic_fetch_add(v13, 0xFFFFFFFF);
    }
  }
  *(void *)(v5 + 40) = v12;
  *(unsigned char *)(v5 + 48) = *(unsigned char *)(a1 + 48);
  return v5;
}

float64_t CA::Render::Layer::append_contents_transform(uint64_t a1, CA::Transform *a2, float64x2_t *a3, _OWORD *a4)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *(void *)(a1 + 128);
  if (v8)
  {
    uint64_t v9 = *(void *)(v8 + 32);
    if (v9)
    {
      unsigned int v10 = *(_DWORD *)(v9 + 16);
      int v11 = (double *)(v9 + 24);
      uint64_t v12 = (double *)(v9 + 40);
      uint64_t v13 = (double *)(v9 + 56);
      BOOL v14 = v10 >= 6;
      if (v10 < 6) {
        uint64_t v13 = (double *)(MEMORY[0x1E4F1DAB8] + 32);
      }
      uint64_t v15 = (double *)(MEMORY[0x1E4F1DAB8] + 16);
      if (v14) {
        uint64_t v15 = v12;
      }
      if (!v14) {
        int v11 = (double *)MEMORY[0x1E4F1DAB8];
      }
      CA::Transform::set_affine((CA::Transform *)v23, *v11, v11[1], *v15, v15[1], *v13, v13[1]);
      CA::Transform::concat_left(a2, v23, v16, v17);
    }
  }
  v23[0] = 0uLL;
  long long v22 = 0uLL;
  char v18 = CA::Render::compute_gravity_transform((unsigned __int16)*(_DWORD *)(a1 + 36) >> 12, (double *)(a1 + 64), a3, (uint64_t)v23, (uint64_t)&v22);
  float64x2_t v19 = CA::Transform::translate(a2, v23[0].f64[0], v23[0].f64[1], 0.0);
  if ((v18 & 1) == 0)
  {
    *(void *)&v19.f64[0] = v22;
    if (*(double *)&v22 == *((double *)&v22 + 1)) {
      goto LABEL_13;
    }
    if (*(double *)&v22 < 0.0 != *((double *)&v22 + 1) >= 0.0)
    {
      unint64_t v20 = v22 - *((void *)&v22 + 1);
      if ((uint64_t)(v22 - *((void *)&v22 + 1)) < 0) {
        unint64_t v20 = *((void *)&v22 + 1) - v22;
      }
      if (v20 <= 3)
      {
LABEL_13:
        *(void *)&long long v22 = *((void *)&v22 + 1);
        v19.f64[0] = *((float64_t *)&v22 + 1);
      }
    }
    v19.f64[0] = CA::Transform::scale((float64x2_t *)a2, v19, *((double *)&v22 + 1), 1.0);
  }
  if (a4)
  {
    *(void *)&v19.f64[0] = v22;
    *a4 = v22;
  }
  return v19.f64[0];
}

void *CA::OGL::prepare_layers(uint64_t a1, const CA::Render::TransitionSubclass *a2, void **a3, uint64_t a4, int a5, unsigned char *a6, unsigned char *a7)
{
  BOOL v7 = *a3;
  if (*a3 == a3) {
    return 0;
  }
  uint64_t v15 = 0;
  do
  {
    uint64_t v16 = (void *)CA::OGL::prepare_layer(a1, (uint64_t)v7, a2, a4, (unint64_t)(v15 == 0) << 29, a5);
    if (v16)
    {
      *uint64_t v16 = v15;
      uint64_t v17 = v16[13];
      *a7 |= (*(_DWORD *)(v17 + 220) & 0x300000) != 0;
      *a6 |= (*(_DWORD *)(v17 + 220) & 0x800000) != 0;
      uint64_t v15 = v16;
    }
    BOOL v7 = (void *)*v7;
  }
  while (v7 != a3);
  return v15;
}

uint64_t CA::OGL::prepare_layer(uint64_t a1, uint64_t a2, const CA::Render::TransitionSubclass *a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v236 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(a2 + 32);
  if (!v6) {
    return 0;
  }
  uint64_t v8 = *(void *)(a2 + 24);
  if ((v8 & 0x18) != 0 && (*(void *)(a2 + 24) & 0x1000) == 0) {
    return 0;
  }
  if ((v8 & 0x81000) == 0)
  {
    int32x2_t v18 = *(int32x2_t *)(a1 + 40);
    uint32x2_t v19 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v18);
    if ((vpmax_u32(v19, v19).u32[0] & 0x80000000) != 0) {
      return 0;
    }
    int32x2_t v20 = *(int32x2_t *)(a2 + 184);
    uint32x2_t v21 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v20);
    if ((vpmax_u32(v21, v21).u32[0] & 0x80000000) != 0) {
      return 0;
    }
    uint32x2_t v22 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, vsub_s32(vmin_s32(vadd_s32(*(int32x2_t *)(a1 + 32), v18), vadd_s32(*(int32x2_t *)(a2 + 176), v20)), vmax_s32(*(int32x2_t *)(a1 + 32), *(int32x2_t *)(a2 + 176))));
    if ((vpmax_u32(v22, v22).u32[0] & 0x80000000) != 0) {
      return 0;
    }
  }
  if ((a5 & 0x4000000) != 0 || (uint64_t v14 = *(void *)(a2 + 120)) == 0)
  {
    uint64_t v23 = CA::OGL::Renderer::alloc_layer(a1, a2, (uint64_t)a3, a4);
    *(void *)(v23 + 32) = a5;
    uint64_t v28 = CA::OGL::prepare_layer_image((void *)a1, (int8x8_t *)v23, (const CA::Transform *)a4, v24);
  }
  else
  {
    uint64_t v15 = CA::Render::Transition::subclass(*(CA::Render::Transition **)(a2 + 120), a2, a3);
    if (v15)
    {
      int v16 = ((uint64_t (*)(uint64_t (***)(CA::Render::BuiltinTransition *__hidden, const CA::Render::TransitionAnimation *, CA::Render::Layer *, unsigned int, float), uint64_t))(*v15)[6])(v15, v14);
      BOOL v17 = 0;
    }
    else
    {
      BOOL v17 = *(void *)(v14 + 32) == 0;
      if (*(void *)(v14 + 32)) {
        int v16 = 3;
      }
      else {
        int v16 = 0;
      }
    }
    uint64_t v202 = 0;
    uint64_t v203 = 0;
    *(void *)&long long v213 = 0;
    long long v211 = 0u;
    long long v212 = 0u;
    long long v209 = 0u;
    float64x2_t v210 = 0u;
    float64x2_t v207 = 0u;
    float64x2_t v208 = 0u;
    float64x2_t v205 = 0u;
    float64x2_t v206 = 0u;
    float64x2_t v204 = 0u;
    uint64_t v200 = 0;
    uint64_t v201 = 0;
    uint64_t v195 = 0;
    uint64_t v196 = 0;
    long long v197 = *(_OWORD *)(a4 + 8);
    LODWORD(v203) = *(_DWORD *)(a4 + 64);
    __int16 v29 = *(_WORD *)(a4 + 68) & 0x500 | 1;
    WORD2(v203) = v29;
    uint64_t v31 = *(void *)(a4 + 24);
    uint64_t v30 = *(void *)(a4 + 32);
    v198 = (float64x2_t *)v31;
    uint64_t v199 = v30;
    long long v193 = 0u;
    long long v194 = 0u;
    long long v191 = 0u;
    long long v192 = 0u;
    long long v189 = 0u;
    long long v190 = 0u;
    long long v187 = 0u;
    float64x2_t v188 = 0u;
    float64x2_t v186 = 0u;
    if (CA::OGL::test_source_requirement(v16, (CA::Mat4Impl *)v31))
    {
      long long v35 = *(_OWORD *)(v31 + 16);
      float64x2_t v36 = *(float64x2_t *)(v31 + 32);
      long long v37 = *(_OWORD *)(v31 + 48);
      float64x2_t v186 = *(float64x2_t *)v31;
      long long v187 = v35;
      float64x2_t v188 = v36;
      long long v189 = v37;
      long long v38 = *(_OWORD *)(v31 + 80);
      long long v39 = *(_OWORD *)(v31 + 96);
      long long v40 = *(_OWORD *)(v31 + 112);
      long long v190 = *(_OWORD *)(v31 + 64);
      long long v191 = v38;
      long long v192 = v39;
      long long v193 = v40;
      long long v194 = *(_OWORD *)(v31 + 128);
      LOBYTE(v195) = *(unsigned char *)(v31 + 144) & 0x1F;
      CA::Transform::invert((int8x16_t *)&v186, v32, v33);
    }
    else
    {
      float64x2_t v41 = (float64x2_t)xmmword_184997D50;
      float64x2_t v204 = (float64x2_t)xmmword_184997D50;
      float64x2_t v205 = 0u;
      float64x2_t v42 = (float64x2_t)xmmword_184997D60;
      float64x2_t v206 = (float64x2_t)xmmword_184997D60;
      float64x2_t v207 = 0u;
      float64x2_t v208 = 0u;
      long long v209 = xmmword_184997D50;
      float64x2_t v210 = 0u;
      long long v211 = xmmword_184997D60;
      __asm { FMOV            V0.2D, #1.0 }
      long long v212 = _Q0;
      LOBYTE(v213) = 0;
      v198 = &v204;
      WORD2(v203) = v29 & 0xFC01 | 0x200;
      float64x2_t v186 = (float64x2_t)xmmword_184997D50;
      float64x2_t v188 = (float64x2_t)xmmword_184997D60;
      long long v189 = 0u;
      long long v190 = 0u;
      long long v191 = xmmword_184997D50;
      long long v193 = xmmword_184997D60;
      long long v194 = _Q0;
      if (v16 != 7)
      {
        if ((*(unsigned char *)(v31 + 144) & 0x10) != 0)
        {
          double scale = CA::Mat4Impl::mat4_get_scale((CA::Mat4Impl *)v31, 0, 0, v34);
          float64x2_t v42 = (float64x2_t)xmmword_184997D60;
          float64x2_t v41 = (float64x2_t)xmmword_184997D50;
        }
        else
        {
          double scale = *(double *)(v31 + 128);
        }
        if (scale != 1.0)
        {
          *(double *)&long long v212 = scale;
          *((double *)&v212 + 1) = 1.0 / scale;
          LOBYTE(v213) = 8;
          float64x2_t v204 = vmulq_n_f64(v41, scale);
          float64x2_t v206 = vmulq_n_f64(v42, scale);
        }
        double v47 = 1.0 / scale;
        if (1.0 / scale != 1.0)
        {
          *(double *)&long long v194 = 1.0 / scale;
          *((double *)&v194 + 1) = scale;
          LOBYTE(v195) = 8;
          float64x2_t v186 = vmulq_n_f64(v41, v47);
          float64x2_t v188 = vmulq_n_f64(v42, v47);
        }
      }
    }
    uint64_t v23 = CA::OGL::Renderer::alloc_layer(a1, a2, (uint64_t)a3, (uint64_t)&v196);
    CA::OGL::prepare_layer_image((void *)a1, (int8x8_t *)v23, (const CA::Transform *)&v196, v48);
    uint64_t v49 = *(void *)(a2 + 24);
    if ((v49 & 0x4000000) == 0 && *(_DWORD *)(v14 + 72)) {
      *(void *)(v23 + 104) = CA::OGL::cache_node(a1, v23, (void *)(v14 + 72), *(void *)(v23 + 104));
    }
    uint64_t v50 = CA::OGL::Renderer::alloc_layer(a1, *(void *)(a2 + 136), (uint64_t)a3, (uint64_t)&v196);
    *(void *)(v50 + 32) = 0x4000000;
    CA::OGL::prepare_layer_image((void *)a1, (int8x8_t *)v50, (const CA::Transform *)&v196, v51);
    if ((v49 & 0x4000000) == 0 && *(_DWORD *)(v14 + 64)) {
      *(void *)(v50 + 104) = CA::OGL::cache_node(a1, v50, (void *)(v14 + 64), *(void *)(v50 + 104));
    }
    uint64_t v52 = *(void *)(v23 + 104);
    if (v17)
    {
      uint64_t v53 = CA::OGL::combine_node((uint64_t **)a1, v23, 7, a4, *(void *)(v23 + 104), *(CA::OGL::ImagingNode **)(v50 + 104), *(float *)(v14 + 48), *(float *)(v14 + 48), *(float *)(v14 + 48), *(float *)(v14 + 48));
      *(void *)(v23 + 104) = v53;
      *(_DWORD *)(v53 + 220) = *(_DWORD *)(v53 + 220) & 0xFFFE0000 | 0x20;
    }
    else
    {
      uint64_t v54 = *(void *)(v50 + 104);
      uint64_t v55 = *(void *)(a1 + 72);
      if (v55) {
        *(void *)(a1 + 72) = *(void *)v55;
      }
      else {
        uint64_t v55 = x_heap_malloc_small_(*(uint64_t **)(a1 + 56), 0xF8uLL);
      }
      *(void *)(v55 + 8) = a1;
      *(void *)(v55 + 16) = v23;
      *(void *)(v55 + 48) = 0;
      *(void *)(v55 + 192) = 0;
      *(void *)(v55 + 200) = 0;
      *(_DWORD *)(v55 + 208) = 0;
      *(_WORD *)(v55 + 212) = *(_WORD *)(v55 + 212) & 0xC000 | 1;
      unsigned int v56 = *(_DWORD *)(v55 + 220) & 0xFC000000;
      *(_DWORD *)(v55 + 216) = *(_DWORD *)(v55 + 216) & 0xFFC00000 | 0xF;
      *(_DWORD *)(v55 + 220) = v56;
      *(void *)(v55 + 24) = v54;
      *(void *)(v55 + 32) = v52;
      *(_DWORD *)(v55 + 136) = -1;
      *(void *)uint64_t v55 = &unk_1ED02B660;
      *(void *)(v55 + 224) = v14;
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      unsigned int v58 = malloc_type_zone_malloc(malloc_zone, 0x98uLL, 0x8BB15036uLL);
      if (v58)
      {
        long long v59 = v187;
        float64x2_t v60 = v188;
        long long v61 = v189;
        *unsigned int v58 = v186;
        v58[1] = v59;
        v58[2] = v60;
        v58[3] = v61;
        long long v62 = v191;
        long long v63 = v192;
        long long v64 = v193;
        v58[4] = v190;
        v58[5] = v62;
        v58[6] = v63;
        v58[7] = v64;
        v58[8] = v194;
        *((unsigned char *)v58 + 144) = v58[9] & 0xE0 | v195 & 0x1F;
      }
      *(void *)(v55 + 232) = v58;
      CA::OGL::init_gstate(v55 + 56, a4);
      *(_DWORD *)(v55 + 220) = (*(_DWORD *)(v55 + 220) & 0xFFEE0000 | 0x100040) - 32;
      *(void *)(v23 + 104) = v55;
    }
    *(void *)(v23 + 120) = v50;
    *(void *)(v50 + 104) = 0;
    uint64_t v28 = *(void *)(v23 + 104) + 56;
  }
  uint64_t v65 = *(void *)(v23 + 32);
  if ((v65 & 0x4000000) != 0)
  {
    LOBYTE(v73) = 1;
    uint64_t v74 = v28;
    goto LABEL_169;
  }
  uint64_t v66 = *(void *)(v23 + 16);
  uint64_t v67 = *(void *)(v23 + 24);
  if (*(void *)(v66 + 128))
  {
    if ((v65 & 0x2C0000) != 0 || (*(unsigned char *)(v66 + 25) & 0x20) == 0)
    {
      *(void *)(v23 + 32) = v65 | 2;
      goto LABEL_49;
    }
LABEL_108:
    uint64_t v77 = 0;
    uint64_t v73 = 0;
    goto LABEL_122;
  }
  if ((*(unsigned char *)(v67 + 40) & 0x40) == 0) {
    goto LABEL_108;
  }
  if ((v65 & 0x2C0000) != 0) {
    goto LABEL_49;
  }
  if ((*(unsigned char *)(v66 + 25) & 0x20) != 0) {
    goto LABEL_108;
  }
  if ((v65 & 0x300007FE0) != 0x100
    || (v65 & 0x10) == 0
    || (uint64_t v75 = *(void *)(v66 + 48)) == 0
    || (uint64_t v76 = (*(uint64_t (**)(void))(*(void *)v75 + 80))(*(void *)(v66 + 48))) == 0)
  {
    if ((v65 & 0x300003F40) == 0) {
      goto LABEL_108;
    }
    goto LABEL_49;
  }
  uint64_t v235 = 0;
  long long v233 = 0u;
  long long v234 = 0u;
  long long v231 = 0u;
  long long v232 = 0u;
  long long v229 = 0u;
  long long v230 = 0u;
  long long v227 = 0u;
  long long v228 = 0u;
  long long v225 = 0u;
  long long v226 = 0u;
  long long v223 = 0u;
  long long v224 = 0u;
  long long v221 = 0u;
  long long v222 = 0u;
  long long v219 = 0u;
  long long v220 = 0u;
  long long v217 = 0u;
  long long v218 = 0u;
  long long v215 = 0u;
  long long v216 = 0u;
  long long v213 = 0u;
  long long v214 = 0u;
  long long v211 = 0u;
  long long v212 = 0u;
  long long v209 = 0u;
  float64x2_t v210 = 0u;
  float64x2_t v207 = 0u;
  float64x2_t v208 = 0u;
  float64x2_t v205 = 0u;
  float64x2_t v206 = 0u;
  float64x2_t v204 = 0u;
  CA::OGL::ContentsGeometry::ContentsGeometry((uint64_t)&v204, v23, a4, v76, v75, 0);
  uint64_t v77 = 0;
  if ((v65 & 0x300003F40) == 0)
  {
    uint64_t v73 = 0;
    goto LABEL_122;
  }
  uint64_t v73 = 0;
  if (!BYTE10(v234))
  {
LABEL_49:
    uint64_t v68 = *(void *)(v23 + 32);
    if ((*(unsigned char *)(v67 + 40) & 0x40) != 0)
    {
      if ((v68 & 0x1000000) != 0
        || ((float64x2_t v69 = *(CA::Mat4Impl **)(v66 + 56)) != 0 && !CA::Mat4Impl::mat4_is_rectilinear(v69, v25)
         || (float64_t v70 = *(CA::Mat4Impl **)(a4 + 24), (*((unsigned char *)v70 + 144) & 0x10) != 0)
         && !CA::Mat4Impl::mat4_is_rectilinear(v70, v25))
        && ((v68 & 0x300007AE0) != 0
         || (v68 & 0x100) != 0 && (int v71 = (unsigned __int16)*(_DWORD *)(v67 + 36) >> 12, v71 != 9) && v71 != 10))
      {
        if ((*(_WORD *)(v23 + 40) & 0x3C0) != 0)
        {
          uint64_t v72 = 1;
        }
        else
        {
          float64x2_t v206 = 0u;
          float64x2_t v207 = 0u;
          float64x2_t v204 = 0u;
          float64x2_t v205 = 0u;
          CA::OGL::map_layer_corners(v23, a4, v204.f64);
          uint64_t v78 = 0;
          uint64_t v72 = 0x8000000;
          do
          {
            if ((*(void *)&v204.f64[v78] & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
              || (*(void *)&v204.f64[v78 + 1] & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
            {
              uint64_t v72 = 1;
            }
            v78 += 2;
          }
          while (v78 != 8);
          uint64_t v68 = *(void *)(v23 + 32);
        }
        v68 |= v72;
        *(void *)(v23 + 32) = v68;
      }
      if ((*(_WORD *)(v23 + 40) & 0x3C0) != 0 && (v68 & 1) == 0)
      {
        float64x2_t v79 = *(float64x2_t *)(v67 + 64);
        float64x2_t v80 = *(float64x2_t *)(v67 + 80);
        float64x2_t v204 = v79;
        float64x2_t v205 = v80;
        float64x2_t v81 = *(float64x2_t **)(v66 + 56);
        if (v81) {
          CA::Mat4Impl::mat4_apply_to_rect(v81, (int8x16_t *)&v204, v26);
        }
        else {
          float64x2_t v204 = vaddq_f64(*(float64x2_t *)(v66 + 64), v79);
        }
        CA::Rect::apply_transform((int8x16_t *)&v204, *(const CA::Transform **)(a4 + 24), v26);
        uint64_t v68 = *(void *)(v23 + 32);
        if (vaddvq_f64(vabdq_f64(v204, vrndaq_f64(v204)))
           + vabdd_f64(v205.f64[0], round(v205.f64[0]))
           + vabdd_f64(v205.f64[1], round(v205.f64[1])) >= 0.000004)
        {
          v68 |= 1uLL;
          *(void *)(v23 + 32) = v68;
        }
      }
      if ((v68 & 0x11) == 0x10)
      {
        if ((v68 & 0x1480002) != 0) {
          goto LABEL_104;
        }
        if (!(*(unsigned int (**)(void))(**(void **)(v23 + 104) + 24))(*(void *)(v23 + 104))) {
          goto LABEL_104;
        }
        uint64_t v82 = *(void *)(v23 + 104);
        uint64_t v83 = *(void *)(v82 + 80);
        if ((*(unsigned char *)(v83 + 144) & 0x10) != 0 && (*(double *)(v83 + 24) != 0.0 || *(double *)(v83 + 56) != 0.0)) {
          goto LABEL_104;
        }
        uint64_t v84 = *(void *)(v23 + 24);
        uint64_t v85 = *(void *)(v84 + 128);
        if (v85)
        {
          if (*(void *)(v85 + 72)) {
            CA::Render::Layer::max_corner_radii(*(void *)(v84 + 128));
          }
          else {
            double v86 = *(float *)(v85 + 228);
          }
        }
        else
        {
          double v86 = 0.0;
        }
        double v88 = *(double *)(v84 + 80);
        double v87 = *(double *)(v84 + 88);
        double v89 = v88 >= v87 ? *(double *)(v84 + 88) : *(double *)(v84 + 80);
        if ((v90 = *(_DWORD *)(v84 + 36), int v91 = HIWORD(v90) & 0xF, v91 == 15)
          || v85 && *(void *)(v85 + 72)
          || v91 == 9
          || v91 == 6)
        {
          double v92 = v89 * 0.5;
        }
        else
        {
          BOOL v177 = (~v90 & 0xC0000) == 0 || (~v90 & 0x30000) == 0;
          double v178 = v88 * 0.5;
          if (v177 && v178 < v89) {
            double v89 = v178;
          }
          BOOL v180 = (~v90 & 0x50000) == 0 || (~v90 & 0xA0000) == 0;
          double v92 = v87 * 0.5;
          if (!v180 || v92 >= v89) {
            double v92 = v89;
          }
        }
        if (v86 > v92 * 1.00001 || v85 && *(void *)(v85 + 56) && (*(unsigned char *)(v84 + 45) & 2) != 0)
        {
LABEL_104:
          uint64_t v68 = *(void *)(v23 + 32) | 1;
          *(void *)(v23 + 32) = v68;
        }
        else
        {
          *(_DWORD *)(v82 + 220) |= 0x200000u;
          uint64_t v68 = *(void *)(v23 + 32);
        }
      }
    }
    if ((v68 & 3) != 0)
    {
      uint64_t v77 = *(void *)(a1 + 72);
      if (v77) {
        *(void *)(a1 + 72) = *(void *)v77;
      }
      else {
        uint64_t v77 = x_heap_malloc_small_(*(uint64_t **)(a1 + 56), 0xF8uLL);
      }
      *(void *)(v77 + 8) = a1;
      *(void *)(v77 + 16) = v23;
      *(void *)(v77 + 48) = 0;
      *(void *)(v77 + 192) = 0;
      *(void *)(v77 + 200) = 0;
      *(_DWORD *)(v77 + 208) = 0;
      *(_WORD *)(v77 + 212) = *(_WORD *)(v77 + 212) & 0xC000 | 1;
      *(void *)(v77 + 24) = 0;
      *(void *)(v77 + 32) = 0;
      *(_DWORD *)(v77 + 136) = -1;
      *(void *)uint64_t v77 = &unk_1ED02BFF0;
      *(unsigned char *)(v77 + 224) &= ~1u;
      *(void *)(v77 + 232) = 0;
      *(void *)(v77 + 88) = 0x3C003C003C003C00;
      *(void *)(v77 + 96) = 0;
      *(void *)(v77 + 104) = 0;
      __int16 v93 = *(_WORD *)(v77 + 124);
      *(void *)(v77 + 112) = 0;
      *(_OWORD *)(v77 + 72) = 0u;
      *(_OWORD *)(v77 + 56) = 0u;
      *(_DWORD *)(v77 + 120) = 1065353216;
      __int16 v94 = v93 & 0xF800 | 0x401;
      *(_WORD *)(v77 + 124) = v94;
      *(int8x8_t *)(v77 + 216) = vorr_s8(vand_s8(*(int8x8_t *)(v77 + 216), (int8x8_t)0xFC000000FFC00000), (int8x8_t)0x1000000000FLL);
      __int16 v95 = v94 | *(_WORD *)(a4 + 68) & 0x100;
      *(_WORD *)(v77 + 124) = v95;
      if ((~*(_DWORD *)(v23 + 32) & 3) == 0) {
        *(_WORD *)(v77 + 124) = v95 & 0xFD00 | 4;
      }
      *(void *)&long long v213 = 0;
      long long v211 = 0uLL;
      long long v212 = 0uLL;
      long long v209 = 0uLL;
      float64x2_t v210 = 0uLL;
      float64x2_t v207 = 0uLL;
      float64x2_t v208 = 0uLL;
      float64x2_t v205 = 0uLL;
      float64x2_t v206 = 0uLL;
      float64x2_t v204 = 0uLL;
      float64x2_t v96 = *(CA::Mat4Impl **)(v66 + 56);
      if (v96)
      {
        CA::Transform::set((uint64_t)&v204, v96, 1);
      }
      else
      {
        double v97 = *(double *)(v66 + 80);
        if (fabs(v97) < 0.001)
        {
          uint64_t v98 = *(void *)(a4 + 24);
          float64x2_t v99 = *(float64x2_t *)(v98 + 16);
          float64x2_t v100 = *(float64x2_t *)(v98 + 32);
          float64x2_t v101 = *(float64x2_t *)(v98 + 48);
          float64x2_t v204 = *(float64x2_t *)v98;
          float64x2_t v205 = v99;
          float64x2_t v206 = v100;
          float64x2_t v207 = v101;
          float64x2_t v102 = *(float64x2_t *)(v98 + 80);
          float64x2_t v103 = *(float64x2_t *)(v98 + 96);
          float64x2_t v104 = *(float64x2_t *)(v98 + 112);
          float64x2_t v208 = *(float64x2_t *)(v98 + 64);
          long long v209 = (__int128)v102;
          float64x2_t v210 = v103;
          long long v211 = (__int128)v104;
          long long v212 = *(_OWORD *)(v98 + 128);
          LOBYTE(v213) = *(unsigned char *)(v98 + 144) & 0x1F;
          CA::Transform::translate((CA::Transform *)&v204, *(double *)(v66 + 64), *(double *)(v66 + 72), 0.0);
          uint64_t v73 = v77;
LABEL_119:
          uint64_t v107 = v23 + 144;
          if (!CA::Transform::operator==((uint64_t)&v204, v23 + 144))
          {
            uint64_t v107 = x_heap_malloc_small_(*(uint64_t **)(a1 + 56), 0x98uLL);
            float64x2_t v108 = v205;
            float64x2_t v109 = v206;
            float64x2_t v110 = v207;
            *(float64x2_t *)uint64_t v107 = v204;
            *(float64x2_t *)(v107 + 16) = v108;
            *(float64x2_t *)(v107 + 32) = v109;
            *(float64x2_t *)(v107 + 48) = v110;
            float64x2_t v111 = (float64x2_t)v209;
            float64x2_t v112 = v210;
            float64x2_t v113 = (float64x2_t)v211;
            *(float64x2_t *)(v107 + 64) = v208;
            *(float64x2_t *)(v107 + 80) = v111;
            *(float64x2_t *)(v107 + 96) = v112;
            *(float64x2_t *)(v107 + 112) = v113;
            *(_OWORD *)(v107 + 128) = v212;
            *(unsigned char *)(v107 + 144) = *(unsigned char *)(v107 + 144) & 0xE0 | v213 & 0x1F;
          }
          *(void *)(v77 + 80) = v107;
          goto LABEL_122;
        }
        float64x2_t v204 = (float64x2_t)xmmword_184997D50;
        float64x2_t v205 = 0uLL;
        float64x2_t v206 = (float64x2_t)xmmword_184997D60;
        float64x2_t v207 = 0u;
        float64x2_t v208 = 0u;
        long long v209 = xmmword_184997D50;
        long long v211 = xmmword_184997D60;
        float64x2_t v210 = *(float64x2_t *)(v66 + 64);
        *(double *)&long long v211 = v97;
        __asm { FMOV            V1.2D, #1.0 }
        long long v212 = _Q1;
        LOBYTE(v213) = 16 * (v97 != 0.0);
      }
      uint64_t v73 = v77;
      if ((CA::OGL::maybe_concatenate((CA::OGL *)&v204, *(CA::Transform **)(a4 + 24), (const CA::Transform *)v26, v27) & 1) == 0)
      {
        *(_WORD *)(v77 + 124) = *(_WORD *)(v77 + 124) & 0xFCFF | 0x200;
        CA::OGL::quad_node(a1, v23, v77, 1, 1, 0, 0.0);
        uint64_t v73 = v106;
        *(void *)(v106 + 80) = *(void *)(a4 + 24);
        *(_WORD *)(v106 + 124) = *(_WORD *)(v106 + 124) & 0xFEFF | *(_WORD *)(a4 + 68) & 0x100;
        *(_DWORD *)(v106 + 220) = *(_DWORD *)(v106 + 220) & 0xFFFE0000 | 0x80;
      }
      goto LABEL_119;
    }
    goto LABEL_108;
  }
LABEL_122:
  v114 = *(void **)(v23 + 104);
  uint64_t v115 = *(void *)(v23 + 32);
  if ((v115 & 0x480000) != 0 || v73 && (v115 & 0x200000) != 0)
  {
    int v116 = HIBYTE(*(unsigned __int16 *)(v23 + 42));
    if (v116 != 3)
    {
      *(_OWORD *)(v23 + 64) = *(_OWORD *)(v23 + 48);
      *(void *)(v23 + 88) = *(void *)(v23 + 80);
      *(_WORD *)(v23 + 42) = v116 | 0x300;
      *(void *)(v23 + 32) = v115 | 0x100000;
    }
    uint64_t v77 = *(void *)(v23 + 112);
    if (!v77)
    {
      uint64_t v77 = *(void *)(a1 + 72);
      if (v77) {
        *(void *)(a1 + 72) = *(void *)v77;
      }
      else {
        uint64_t v77 = x_heap_malloc_small_(*(uint64_t **)(a1 + 56), 0xF8uLL);
      }
      *(void *)(v77 + 8) = a1;
      *(void *)(v77 + 16) = v23;
      *(void *)(v77 + 48) = 0;
      *(void *)(v77 + 192) = 0;
      *(void *)(v77 + 200) = 0;
      *(_DWORD *)(v77 + 208) = 0;
      *(_WORD *)(v77 + 212) = *(_WORD *)(v77 + 212) & 0xC000 | 1;
      *(void *)(v77 + 24) = 0;
      *(void *)(v77 + 32) = 0;
      *(_DWORD *)(v77 + 136) = -1;
      *(void *)uint64_t v77 = &unk_1ED02AEA8;
      *(void *)(v77 + 224) = 0;
      *(int8x8_t *)(v77 + 216) = vorr_s8(vand_s8(*(int8x8_t *)(v77 + 216), (int8x8_t)0xFC000000FFC00000), (int8x8_t)0x8000000000000FLL);
      *(void *)(v23 + 112) = v77;
    }
    ++*(unsigned char *)(v77 + 212);
    for (unint64_t i = *(void **)(v23 + 136); i; unint64_t i = (void *)*i)
      uint64_t v77 = CA::OGL::filter_node(a1, v23, (uint64_t)i, a4, 0, v77);
    if ((*(unsigned char *)(v23 + 34) & 0x40) != 0)
    {
      uint64_t v126 = *(void *)(v6 + 128);
      if (v126) {
        uint64_t v127 = *(void *)(v126 + 88);
      }
      else {
        uint64_t v127 = 0;
      }
      uint64_t v74 = v28;
      uint64_t v128 = *(void *)(a1 + 72);
      if (v128) {
        *(void *)(a1 + 72) = *(void *)v128;
      }
      else {
        uint64_t v128 = x_heap_malloc_small_(*(uint64_t **)(a1 + 56), 0xF8uLL);
      }
      *(void *)(v128 + 8) = a1;
      *(void *)(v128 + 16) = v23;
      *(void *)(v128 + 48) = 0;
      *(void *)(v128 + 192) = 0;
      *(void *)(v128 + 200) = 0;
      *(_DWORD *)(v128 + 208) = 0;
      *(_WORD *)(v128 + 212) = *(_WORD *)(v128 + 212) & 0xC000 | 1;
      unsigned int v129 = *(_DWORD *)(v128 + 220) & 0xFC000000;
      *(_DWORD *)(v128 + 216) = *(_DWORD *)(v128 + 216) & 0xFFC00000 | 0xF;
      *(_DWORD *)(v128 + 220) = v129;
      *(void *)(v128 + 24) = v114;
      *(void *)(v128 + 32) = v77;
      *(_DWORD *)(v128 + 136) = -1;
      *(void *)uint64_t v128 = &unk_1ED02B578;
      *(void *)(v128 + 224) = v127;
      CA::OGL::init_gstate(v128 + 56, a4);
      *(_DWORD *)(v128 + 220) = *(_DWORD *)(v128 + 220) & 0xFFEE0000 | 0x100040;
      uint64_t v77 = v128;
    }
    else
    {
      __int16 v121 = *(_WORD *)(v23 + 42);
      uint64_t v122 = *(void *)(v23 + 88);
      int v123 = *((_DWORD *)v114 + 34);
      if (v123 < 0)
      {
        (*(void (**)(void *, void *))(*v114 + 40))(v114, v114 + 16);
        int v123 = *((_DWORD *)v114 + 34);
      }
      if (v123 >= *((_DWORD *)v114 + 35)) {
        int v123 = *((_DWORD *)v114 + 35);
      }
      if (v123 > 0 || (v121 & 0xF0 | (0x3ACCu >> v121) & 1) == 0)
      {
        uint64_t v125 = *(void *)(a1 + 72);
        if (v125) {
          *(void *)(a1 + 72) = *(void *)v125;
        }
        else {
          uint64_t v125 = x_heap_malloc_small_(*(uint64_t **)(a1 + 56), 0xF8uLL);
        }
        *(void *)(v125 + 8) = a1;
        *(void *)(v125 + 16) = v23;
        *(void *)(v125 + 48) = 0;
        *(void *)(v125 + 192) = 0;
        *(void *)(v125 + 200) = 0;
        *(_DWORD *)(v125 + 208) = 0;
        *(_WORD *)(v125 + 212) = *(_WORD *)(v125 + 212) & 0xC000 | 1;
        unsigned int v130 = *(_DWORD *)(v125 + 220) & 0xFC000000;
        *(_DWORD *)(v125 + 216) = *(_DWORD *)(v125 + 216) & 0xFFC00000 | 0xF;
        *(_DWORD *)(v125 + 220) = v130;
        *(void *)(v125 + 24) = v77;
        *(void *)(v125 + 32) = v114;
        *(_DWORD *)(v125 + 136) = -1;
        *(void *)uint64_t v125 = &unk_1ED02C1A0;
        CA::OGL::init_gstate(v125 + 56, a4);
        *(_WORD *)(v125 + 124) = v121 | (*(unsigned __int8 *)(v125 + 125) << 8);
        *(void *)(v125 + 96) = *(void *)(v23 + 64);
        *(void *)(v125 + 104) = *(void *)(v23 + 72);
        *(void *)(v125 + 112) = v122;
        *(_DWORD *)(v125 + 220) = *(_DWORD *)(v125 + 220) & 0xFFEE0000 | 0x100040;
        uint64_t v77 = v125;
      }
      else
      {
        __int16 v176 = *((_WORD *)v114 + 106) - 1;
        *((unsigned char *)v114 + 212) = *((_WORD *)v114 + 106) - 1;
        if (!(_BYTE)v176) {
          CA::OGL::ImagingNode::finalize((CA::OGL::ImagingNode *)v114, (CA::OGL::Renderer *)a1);
        }
      }
      uint64_t v74 = v28;
    }
    if (v73)
    {
      *(_DWORD *)(v73 + 220) |= 0x100000u;
      ++*(unsigned char *)(v73 + 212);
      uint64_t v131 = CA::OGL::combine_node((uint64_t **)a1, v23, 5, a4, v77, (CA::OGL::ImagingNode *)v73, 0.0, 0.0, 0.0, 0.0);
      uint64_t v132 = *(void *)(v23 + 112);
      ++*(unsigned char *)(v132 + 212);
      v133 = (CA::OGL::ImagingNode *)CA::OGL::combine_node((uint64_t **)a1, v23, 6, a4, v132, (CA::OGL::ImagingNode *)v73, 0.0, 0.0, 0.0, 0.0);
      uint64_t v77 = CA::OGL::combine_node((uint64_t **)a1, v23, 10, a4, v131, v133, 0.0, 0.0, 0.0, 0.0);
      *(_DWORD *)(v77 + 220) = *(_DWORD *)(v77 + 220) & 0xFFFE0000 | 0x100;
    }
    LOBYTE(v73) = 1;
  }
  else
  {
    if (v73)
    {
      int v117 = HIBYTE(*(unsigned __int16 *)(v23 + 42));
      if (v117 != 3)
      {
        *(_OWORD *)(v23 + 64) = *(_OWORD *)(v23 + 48);
        *(void *)(v23 + 88) = *(void *)(v23 + 80);
        *(_WORD *)(v23 + 42) = v117 | 0x300;
        v115 |= 0x100000uLL;
        *(void *)(v23 + 32) = v115;
      }
      if (v77 == v73
        && (v118 = *(CA::Mat4Impl **)(v77 + 80), v118 == (CA::Mat4Impl *)v114[10])
        && ((*((unsigned char *)v118 + 144) & 0x10) == 0 || CA::Mat4Impl::mat4_is_2d_affine(v118, v25))
        && (v115 & 2) == 0)
      {
        LOBYTE(v73) = 0;
        *(void *)(v77 + 24) = v114;
        *(_DWORD *)(v77 + 220) |= 0x100000u;
      }
      else
      {
        if ((*(void *)(v6 + 40) & 0x80) != 0) {
          int v119 = 6;
        }
        else {
          int v119 = 5;
        }
        uint64_t v77 = CA::OGL::combine_node((uint64_t **)a1, v23, v119, a4, (uint64_t)v114, (CA::OGL::ImagingNode *)v73, 0.0, 0.0, 0.0, 0.0);
        LOBYTE(v73) = 0;
        *(_DWORD *)(v77 + 220) = *(_DWORD *)(v77 + 220) & 0xFFFE0000 | 0x100;
      }
    }
    else
    {
      uint64_t v77 = *(void *)(v23 + 104);
    }
    uint64_t v74 = v28;
  }
  *(void *)(v23 + 104) = v77;
LABEL_169:
  if (*(void *)(*(void *)(v23 + 16) + 152) | *(void *)(a4 + 16)) {
    uint64_t v134 = 1;
  }
  else {
    uint64_t v134 = (*(unsigned __int8 *)(v23 + 35) >> 3) & 1;
  }
  uint64_t v135 = *(void *)(v23 + 104);
  __int16 v136 = *(_WORD *)(v135 + 124);
  uint64_t v138 = *(void *)(v135 + 96);
  uint64_t v137 = *(void *)(v135 + 104);
  uint64_t v139 = *(void *)(v135 + 112);
  if ((v73 & 1) == 0)
  {
    *(_WORD *)(v135 + 124) = v136 & 0xFF00 | *(unsigned __int8 *)(v23 + 42);
    *(void *)(*(void *)(v23 + 104) + 96) = *(void *)(v23 + 64);
    *(void *)(*(void *)(v23 + 104) + 104) = *(void *)(v23 + 72);
    uint64_t v135 = *(void *)(v23 + 104);
    *(void *)(v135 + 112) = *(void *)(v23 + 88);
  }
  int v140 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v135 + 16))(v135, v134);
  uint64_t v142 = *(void *)(v23 + 104);
  if (v140)
  {
    *(unsigned char *)(v142 + 124) = v136;
    *(void *)(*(void *)(v23 + 104) + 96) = v138;
    *(void *)(*(void *)(v23 + 104) + 104) = v137;
    uint64_t v143 = *(void *)(v23 + 104);
    *(void *)(v143 + 112) = v139;
    uint64_t v144 = CA::OGL::combine_node((uint64_t **)a1, v23, 1, v74, v143, 0, 0.0, 0.0, 0.0, 0.0);
    *(void *)(v23 + 104) = v144;
    *(_DWORD *)(v144 + 220) = *(_DWORD *)(v144 + 220) & 0xFFFE0000 | 0x10;
    uint64_t v142 = *(void *)(v23 + 104);
    if ((v73 & 1) == 0)
    {
      *(unsigned char *)(v142 + 124) = *(unsigned char *)(v23 + 42);
      *(void *)(*(void *)(v23 + 104) + 96) = *(void *)(v23 + 64);
      *(void *)(*(void *)(v23 + 104) + 104) = *(void *)(v23 + 72);
      uint64_t v142 = *(void *)(v23 + 104);
      *(void *)(v142 + 112) = *(void *)(v23 + 88);
    }
  }
  *(void *)(v142 + 72) = *(void *)(a4 + 16);
  if (*(void *)(*(void *)(v23 + 16) + 152))
  {
    float64x2_t v210 = 0u;
    long long v211 = 0u;
    float64x2_t v208 = 0u;
    long long v209 = 0u;
    float64x2_t v206 = 0u;
    float64x2_t v207 = 0u;
    float64x2_t v204 = 0u;
    float64x2_t v205 = 0u;
    long long v192 = 0u;
    long long v193 = 0u;
    long long v190 = 0u;
    long long v191 = 0u;
    float64x2_t v188 = 0u;
    long long v189 = 0u;
    float64x2_t v186 = 0u;
    long long v187 = 0u;
    CA::Mat4Impl::mat4_invert((CA::Mat4Impl *)&v186, *(CA::Mat4Impl **)(a4 + 24), v141);
    CA::Mat4Impl::mat4_transpose((CA::Mat4Impl *)&v204, v186.f64, v145);
    CA::Mat4Impl::mat4_invert((CA::Mat4Impl *)&v186, *(CA::Mat4Impl **)(v74 + 24), v146);
    for (j = *(float64x2_t **)(*(void *)(v23 + 16) + 152); j; j = *(float64x2_t **)&j->f64[0])
    {
      float64x2_t v148 = j[1];
      float64x2_t v149 = j[2];
      float64x2_t v150 = vmlaq_laneq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(v205, v148.f64[0]), v207, v148, 1), (float64x2_t)v209, v149.f64[0]), (float64x2_t)v211, v149, 1);
      double v184 = -v150.f64[0] / *(double *)&v191;
      float64x2_t v185 = vmlaq_laneq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(v204, v148.f64[0]), v206, v148, 1), v208, v149.f64[0]), v210, v149, 1);
      *(void *)&v151.f64[0] = v187;
      float64_t v152 = v150.f64[1] + *(double *)&v193 * v184;
      *(void *)&v151.f64[1] = v189;
      float64x2_t v183 = v151;
      uint64_t v153 = CA::OGL::Renderer::add_clip_plane(a1, v23);
      *(float32x2_t *)(v153 + 12) = vcvt_f32_f64(vmlaq_n_f64(v185, v183, v184));
      *(_DWORD *)(v153 + 20) = 0;
      float v154 = v152;
      *(float *)(v153 + 24) = v154;
    }
  }
  if ((*(unsigned char *)(v23 + 35) & 8) != 0)
  {
    float64x2_t v206 = 0u;
    float64x2_t v207 = 0u;
    float64x2_t v204 = 0u;
    float64x2_t v205 = 0u;
    CA::OGL::map_layer_corners(v23, a4, v204.f64);
    uint64_t v155 = 0;
    uint64_t v156 = 0;
    float64x2_t v188 = 0u;
    long long v189 = 0u;
    LODWORD(v157) = 3;
    float64x2_t v186 = 0u;
    long long v187 = 0u;
    while (1)
    {
      v158 = &v204.f64[2 * v157];
      uint64_t v157 = v155;
      v159 = &v204.f64[2 * v155];
      double v160 = *v159;
      double v161 = v159[1];
      double v162 = *v159 - *v158;
      double v163 = v161 - v158[1];
      if (v162 != 0.0) {
        break;
      }
      if (v163 != 0.0)
      {
        double v166 = v162 / v163;
        double v165 = v160 - v166 * v161;
        double v164 = -1.0;
        goto LABEL_186;
      }
      uint64_t v155 = v157 + 1;
LABEL_189:
      if (v155 == 4)
      {
        if (v156)
        {
          v171 = (int8x16_t *)&v186;
          do
          {
            uint64_t v172 = CA::OGL::Renderer::add_clip_plane(a1, v23);
            long long v173 = (__int128)*v171++;
            *(_OWORD *)(v172 + 12) = v173;
            --v156;
          }
          while (v156);
        }
        goto LABEL_195;
      }
    }
    double v164 = v163 / v162;
    double v165 = v161 - v164 * v160;
    double v166 = -1.0;
LABEL_186:
    uint64_t v155 = v157 + 1;
    if (v165 + v204.f64[2 * ((v157 + 1) & 3)] * v164 + v204.f64[2 * ((v157 + 1) & 3) + 1] * v166 < 0.0)
    {
      double v164 = -v164;
      double v166 = -v166;
      double v165 = -v165;
    }
    float v167 = v164;
    v168 = (int8x16_t *)(&v186 + v156);
    *(float *)&__int32 v169 = v166;
    *(float *)v168->i32 = v167;
    v168->i32[1] = v169;
    v168->i32[2] = 0;
    *(float *)&__int32 v170 = v165;
    v168->i32[3] = v170;
    ++v156;
    goto LABEL_189;
  }
LABEL_195:
  v174 = *(_DWORD **)(v23 + 104);
  if (a6)
  {
    v174[55] |= 0x400000u;
    v174 = *(_DWORD **)(v23 + 104);
  }
  (*(void (**)(_DWORD *))(*(void *)v174 + 88))(v174);
  return v23;
}

void *CA::OGL::LayerNode::prepare_sublayers_if_needed(void *this)
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  if ((this[28] & 1) == 0)
  {
    unint64_t v1 = this;
    __int16 v2 = 0;
    this = CA::OGL::prepare_layers(this[1], (const CA::Render::TransitionSubclass *)this[2], (void **)(*(void *)(this[2] + 16) + 96), (uint64_t)(v1 + 7), (*((_DWORD *)v1 + 55) >> 22) & 1, &v2, (unsigned char *)&v2 + 1);
    v1[29] = this;
    *((unsigned char *)v1 + 224) |= 1u;
    if (HIBYTE(v2)) {
      *((_DWORD *)v1 + 55) |= 0x100000u;
    }
    if ((_BYTE)v2) {
      *((_DWORD *)v1 + 55) |= 0x800000u;
    }
  }
  return this;
}

uint64_t CA::OGL::prepare_layer_image(void *a1, int8x8_t *a2, const CA::Transform *a3, const double *a4)
{
  uint64_t v4 = a3;
  uint64_t v269 = *MEMORY[0x1E4F143B8];
  BOOL v7 = (float *)*a1;
  int8x8_t v9 = a2[2];
  int8x8_t v8 = a2[3];
  int8x8_t v10 = a2[13];
  uint64_t v11 = *(void *)(*(void *)&v8 + 128);
  v246 = a3;
  if (v11 && (a2[4].i8[3] & 4) == 0)
  {
    a3 = *(const CA::Transform **)(v11 + 88);
    if (a3)
    {
      if (*((unsigned char *)a3 + 13)) {
        CA::OGL::prepare_compositing_filter(a1, a2, (uint64_t)a3, 0);
      }
    }
    else
    {
      uint64_t v12 = *(void *)(v11 + 96);
      if (v12)
      {
        if (CA::OGL::vibrancy_strength_reduction(CA::OGL::Context &,CA::OGL::Layer *,CA::Render::TypedArray<CA::Render::Filter> const*)::once != -1) {
          dispatch_once(&CA::OGL::vibrancy_strength_reduction(CA::OGL::Context &,CA::OGL::Layer *,CA::Render::TypedArray<CA::Render::Filter> const*)::once, &__block_literal_global_2776);
        }
        if (*(void *)(*(void *)&a2[2] + 104) == *(void *)(*(void *)&a2[2] + 96)
          && *(_DWORD *)(v12 + 16) == 1)
        {
          uint64_t v13 = *(void *)(v12 + 24);
          if (*(unsigned char *)(v13 + 13))
          {
            uint64_t v14 = *(_DWORD **)(v13 + 40);
            if (v14) {
              BOOL v15 = CA::Render::KeyValueArray::get_int_key(*(CA::Render::KeyValueArray **)(v13 + 40), 313, 0) != 0;
            }
            else {
              BOOL v15 = 0;
            }
            int v16 = *(_DWORD *)(v13 + 24);
            if (v16 == 592)
            {
              if (!(*(unsigned int (**)(float *, uint64_t))(*(void *)v7 + 184))(v7, 30)) {
                goto LABEL_42;
              }
              int8x8_t v241 = v9;
              uint64_t v14 = *(_DWORD **)(v13 + 40);
              uint32x2_t v19 = &CA::OGL::vibrancy_strength_reduction(CA::OGL::Context &,CA::OGL::Layer *,CA::Render::TypedArray<CA::Render::Filter> const*)::vibrant_color_matrix_name;
              int v18 = 593;
            }
            else
            {
              if (v16 == 594)
              {
                int8x8_t v241 = v9;
                _ZF = !v15;
                if (v15) {
                  int v18 = 596;
                }
                else {
                  int v18 = 595;
                }
                uint32x2_t v19 = &CA::OGL::vibrancy_strength_reduction(CA::OGL::Context &,CA::OGL::Layer *,CA::Render::TypedArray<CA::Render::Filter> const*)::vibrant_dark_name;
                int32x2_t v20 = &CA::OGL::vibrancy_strength_reduction(CA::OGL::Context &,CA::OGL::Layer *,CA::Render::TypedArray<CA::Render::Filter> const*)::vibrant_dark_reversed_name;
              }
              else
              {
                if (v16 != 597) {
                  goto LABEL_42;
                }
                int8x8_t v241 = v9;
                _ZF = !v15;
                if (v15) {
                  int v18 = 599;
                }
                else {
                  int v18 = 598;
                }
                uint32x2_t v19 = &CA::OGL::vibrancy_strength_reduction(CA::OGL::Context &,CA::OGL::Layer *,CA::Render::TypedArray<CA::Render::Filter> const*)::vibrant_light_name;
                int32x2_t v20 = &CA::OGL::vibrancy_strength_reduction(CA::OGL::Context &,CA::OGL::Layer *,CA::Render::TypedArray<CA::Render::Filter> const*)::vibrant_light_reversed_name;
              }
              if (!_ZF) {
                uint32x2_t v19 = v20;
              }
            }
            uint32x2_t v21 = (atomic_uint *)*v19;
            if (v14) {
              uint32x2_t v22 = CA::Render::Array::new_array((CA::Render::Array *)v14[4], v14 + 6, (CA::Render::Object *const *)1, v14[3] >> 8);
            }
            else {
              uint32x2_t v22 = 0;
            }
            uint64_t v23 = (CA::Render::Filter *)x_mem_alloc0(0x38uLL);
            uint64_t v24 = (atomic_uint *)v23;
            if (v23) {
              CA::Render::Filter::Filter(v23, v18, v21, v22);
            }
            if (v22 && atomic_fetch_add(v22 + 2, 0xFFFFFFFF) == 1) {
              (*(void (**)(atomic_uint *))(*(void *)v22 + 16))(v22);
            }
            int8x8_t v9 = v241;
            uint64_t v4 = v246;
            if (v24)
            {
              CA::OGL::prepare_compositing_filter(a1, a2, (uint64_t)v24, 0);
              if (atomic_fetch_add(v24 + 2, 0xFFFFFFFF) == 1) {
                (*(void (**)(atomic_uint *))(*(void *)v24 + 16))(v24);
              }
              *(void *)&a2[4] |= 0x8000uLL;
            }
          }
        }
      }
    }
  }
LABEL_42:
  int v25 = (int8x8_t *)a2[1];
  if (v25[5].u8[3] << 8 != 768)
  {
    *(void *)&a2[4] |= 0x100000uLL;
    a2[5].i8[2] = v25[5].i8[3];
    a2[8] = v25[6];
    a2[9] = v25[7];
    a2[11] = v25[10];
    v25[5].i8[3] = 3;
  }
  int v26 = *(_DWORD *)(*(void *)&v9 + 116);
  unint64_t v27 = *((void *)v4 + 4);
  if (v26) {
    BOOL v28 = v27 == 0;
  }
  else {
    BOOL v28 = 1;
  }
  if ((v28
     || ((*(void *)(*(void *)&v9 + 24) & 0x18) != 0
       ? (BOOL v29 = (*(void *)(*(void *)&v9 + 24) & 0x1000) == 0)
       : (BOOL v29 = 0),
         v29))
    && (int8x8_t v30 = a2[4], (v30.i32[0] & 0x200000) == 0))
  {
    a2[4] = (int8x8_t)(*(void *)&v30 | 8);
  }
  else
  {
    if ((_BYTE)v26 == 0xFF)
    {
      int v31 = HIWORD(v27);
    }
    else
    {
      *(void *)&a2[4] |= 4uLL;
      a2[5].i16[0] |= 1u;
      LOWORD(v31) = *((_WORD *)v4 + 19);
    }
    if (*(short float *)&v31 != COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
    {
      *(void *)&a2[4] |= 4uLL;
      a2[5].i16[0] = a2[5].i16[0] & 0xFFFD | (*(_WORD *)(*(void *)&a2[1] + 40) >> 1) & 2;
    }
  }
  a2[5].i16[0] &= (*(_WORD *)(*(void *)&v8 + 36) >> 2) | 0xFC3F;
  uint64_t v32 = *(float32x4_t **)(*(void *)&v8 + 128);
  if (!v32) {
    goto LABEL_95;
  }
  if (v32[14].f32[1] > 0.001 && (*(unsigned char *)(*(void *)&v8 + 38) & 0xF) != 0 || v32[4].i64[1]) {
    *(void *)&a2[4] |= 0x10uLL;
  }
  int8x8_t v33 = a2[4];
  if ((v33.i8[0] & 8) != 0) {
    goto LABEL_95;
  }
  if (v32[14].f32[3] > 0.001
    && (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqzq_f32(v32[15])))) & 1) != 0)
  {
    if ((*(unsigned char *)(*(void *)&v8 + 44) & 0x20) != 0)
    {
      uint64_t v34 = 128;
    }
    else
    {
      uint64_t v34 = 128;
      if (!v32[8].i64[0]) {
        uint64_t v34 = 64;
      }
    }
    *(void *)&v33 |= v34;
    a2[4] = v33;
  }
  if (v32[18].f32[3] > 0.001
    && (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqzq_f32(v32[19])))) & 1) != 0
    && v32[20].f32[0] != 0.0)
  {
    uint64_t v35 = 0x200000000;
    if ((*(void *)(*(void *)&v8 + 40) & 0x1000000000) == 0) {
      uint64_t v35 = 0x100000000;
    }
    *(void *)&v33 |= v35;
    a2[4] = v33;
  }
  if ((*(void *)&v33 & 0x100000040) != 0) {
    a2[4] = (int8x8_t)((*(void *)&v33 >> 1) & 0x100000040 | *(void *)&v33 & 0xFFFFFFFDFFFFFF7FLL);
  }
  if (!v32[5].i64[0] && !v32[8].i64[0]
    || (*(_DWORD *)(*(void *)&a2[13] + 220) |= 0x100000u, (uint64_t v32 = *(float32x4_t **)(*(void *)&v8 + 128)) != 0))
  {
    uint64_t v36 = v32->i64[0];
    if (v32->i64[0])
    {
      v250.i64[0] = (uint64_t)&unk_1ED031038;
      v250.i64[1] = (uint64_t)a1;
      *(void *)&long long v251 = a2;
      (*(void (**)(uint64_t, int8x16_t *))(*(void *)v36 + 232))(v36, &v250);
    }
  }
  if ((a2[5].i16[0] & 8) == 0) {
    goto LABEL_95;
  }
  uint64_t v37 = *(void *)(*(void *)&a2[2] + 256);
  if (v37)
  {
    long long v38 = (os_unfair_lock_s *)(v37 + 36);
    os_unfair_lock_lock((os_unfair_lock_t)(v37 + 36));
    uint64_t v39 = *(void *)(v37 + 40);
    if (!v39 || (uint64_t v40 = *(void *)(v39 + 64), v41 = *(void *)(v39 + 72), v40 == v41))
    {
LABEL_93:
      os_unfair_lock_unlock((os_unfair_lock_t)(v37 + 36));
    }
    else
    {
      while (*(void *)v40 != *(void *)(v37 + 24))
      {
        v40 += 168;
        if (v40 == v41) {
          goto LABEL_93;
        }
      }
      if (*(unsigned char *)(v40 + 161))
      {
        int v93 = *(unsigned __int8 *)(v40 + 160);
        os_unfair_lock_unlock(v38);
        if (!v93) {
          goto LABEL_94;
        }
      }
      else
      {
        os_unfair_lock_unlock((os_unfair_lock_t)(v37 + 36));
      }
      *(_DWORD *)(*(void *)&a2[13] + 220) |= 0x100000u;
    }
  }
LABEL_94:
  *(_DWORD *)(*(void *)&a2[13] + 220) |= 0x800000u;
LABEL_95:
  int8x8_t v42 = a2[4];
  if ((v42.i8[0] & 8) != 0) {
    goto LABEL_154;
  }
  if ((*(unsigned char *)(*(void *)&v8 + 45) & 4) != 0)
  {
    *(void *)&v42 |= 0x20uLL;
    a2[4] = v42;
  }
  BOOL v43 = *(unsigned char **)(*(void *)&a2[2] + 48);
  if (v43 && (*(unsigned char *)(*(void *)&v9 + 27) & 2) == 0)
  {
    a2[4] = (int8x8_t)(*(void *)&v42 | 0x100);
    if (v43[12] == 26) {
      *(_DWORD *)(*(void *)&a2[13] + 220) |= 0x100000u;
    }
    if ((*(unsigned char *)(*(void *)&v8 + 41) & 0x80) != 0 && (*(unsigned char *)(*(void *)&a2[3] + 43) & 4) != 0) {
      *(_DWORD *)(*(void *)&a2[13] + 220) |= 0x100000u;
    }
    if ((*(unsigned char *)(*(void *)&v8 + 36) & 0xE) != 0) {
      *(_DWORD *)(*(void *)&a2[13] + 220) |= 0x100000u;
    }
    __int16 v44 = (unsigned char *)(*(uint64_t (**)(unsigned char *))(*(void *)v43 + 80))(v43);
    if (v44)
    {
      int v45 = v44;
      if ((v44[14] & 4) == 0
        && ((*(uint64_t (**)(unsigned char *))(*(void *)v44 + 200))(v44)
         || (*(unsigned int (**)(float *, unsigned char *))(*(void *)v7 + 568))(v7, v45)))
      {
        *(_DWORD *)(*(void *)&a2[13] + 220) |= 0x100000u;
      }
      int8x8_t v46 = a2[4];
      if ((v46.i8[0] & 0x20) != 0 && (v45[13] & 0x10) != 0 && (*(_DWORD *)(*(void *)&v8 + 36) & 0xD000) == 0x9000)
      {
        uint64_t v47 = *(void *)(*(void *)&v8 + 128);
        if (!v47 || !*(void *)(v47 + 32) && *(float *)(v47 + 280) == 1.0) {
          a2[4] = (int8x8_t)(*(void *)&v46 & 0xFFFFFFFFFFFFFFDFLL);
        }
      }
    }
  }
  if (*(unsigned char *)(*(void *)&v8 + 33))
  {
    uint64_t v48 = *(void *)(*(void *)&v8 + 128);
    if (v48) {
      float32x4_t v49 = *(float32x4_t *)(v48 + 200);
    }
    else {
      float32x4_t v49 = (float32x4_t)xmmword_184997DF0;
    }
    if (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqzq_f32(v49)))))
    {
      uint64_t v50 = *(void *)(*(void *)&v8 + 40);
      if ((v50 & 0x200000000) != 0
        || (uint64_t v51 = *(void *)(*(void *)&a2[2] + 208)) == 0
        || !CA::Shape::contains(v51, (const CA::Bounds *)(a1 + 4)))
      {
        if ((v50 & 0x400000000) != 0 || v48 && *(void *)(v48 + 120))
        {
          *(void *)&a2[4] |= 0x1000uLL;
          int v52 = (*(uint64_t (**)(void, uint64_t))(*(void *)*a1 + 184))(*a1, 4) - 64;
          if ((*(unsigned char *)(*(void *)&v8 + 44) & 4) != 0)
          {
            uint64_t v56 = *(void *)&v8 + 64;
          }
          else
          {
            uint64_t v54 = *(void *)(*(void *)&v8 + 128);
            if (v54) {
              uint64_t v55 = *(CA::Render::Path **)(v54 + 120);
            }
            else {
              uint64_t v55 = 0;
            }
            uint64_t v56 = CA::Render::Path::bounding_rect(v55);
          }
          double v57 = *(double *)(v56 + 16);
          uint64_t v58 = *(void *)(*(void *)&v8 + 128);
          if (v58)
          {
            float v59 = *(float *)(v58 + 284);
          }
          else
          {
            LOBYTE(v53) = *(unsigned char *)(*(void *)&v8 + 34);
            float v59 = (float)v53;
          }
          double v60 = v59;
          if (v57 <= *(double *)(v56 + 24)) {
            double v57 = *(double *)(v56 + 24);
          }
          if (v57 * v60 > (double)v52) {
            *(_DWORD *)(*(void *)&a2[13] + 220) |= 0x100000u;
          }
        }
        else
        {
          *(void *)&a2[4] |= 0x800uLL;
        }
      }
    }
  }
  uint64_t v61 = *(void *)(*(void *)&v9 + 104);
  if (v61 == *(void *)&v9 + 96)
  {
LABEL_154:
    uint64_t v62 = 0;
    goto LABEL_155;
  }
  uint64_t v62 = 0;
  while (1)
  {
    if ((*(void *)(v61 + 24) & 0x18) != 0 && (*(void *)(v61 + 24) & 0x1000) == 0) {
      goto LABEL_152;
    }
    int8x8_t v64 = a2[4];
    if ((v64.i16[0] & 0x200) != 0) {
      break;
    }
    a2[4] = (int8x8_t)(*(void *)&v64 | 0x200);
    uint64_t v62 = v61;
LABEL_152:
    uint64_t v61 = *(void *)(v61 + 8);
    if (v61 == *(void *)&v9 + 96) {
      goto LABEL_155;
    }
  }
  uint64_t v62 = 0;
  a2[4] = (int8x8_t)(*(void *)&v64 | 0x400);
LABEL_155:
  uint64_t v65 = *(CA::Mat4Impl **)(*(void *)&v9 + 56);
  if (v65)
  {
    CA::Transform::set((uint64_t)&a2[18], v65, 1);
LABEL_160:
    if ((CA::OGL::maybe_concatenate((CA::OGL *)&a2[18], *((CA::Transform **)v4 + 3), a3, a4) & 1) == 0)
    {
      *(void *)&a2[4] |= 0x1800000uLL;
      a2[37].i32[1] |= 0x20000u;
      *(_WORD *)(*(void *)&v10 + 124) = *(_WORD *)(*(void *)&v10 + 124) & 0xFCFF | 0x200;
    }
  }
  else
  {
    double v66 = *(double *)(*(void *)&v9 + 80);
    if (fabs(v66) >= 0.001)
    {
      long long v72 = *(_OWORD *)(*(void *)&v9 + 64);
      *(_OWORD *)a2[18].i8 = xmmword_184997D50;
      a2[20] = 0;
      a2[21] = 0;
      *(_OWORD *)a2[22].i8 = xmmword_184997D60;
      *(_OWORD *)a2[24].i8 = 0u;
      *(_OWORD *)a2[26].i8 = 0u;
      *(_OWORD *)a2[28].i8 = xmmword_184997D50;
      *(_OWORD *)a2[30].i8 = v72;
      *(_OWORD *)a2[32].i8 = xmmword_184997D60;
      *(double *)&a2[32] = v66;
      __asm { FMOV            V1.2D, #1.0 }
      *(_OWORD *)a2[34].i8 = _Q1;
      a2[36].i8[0] = a2[36].i8[0] & 0xE0 | (16 * (v66 != 0.0));
      goto LABEL_160;
    }
    CA::Transform::operator=((uint64_t)&a2[18], *((void *)v4 + 3));
    float64x2_t v70 = CA::Transform::translate(v67, *(double *)(*(void *)&v9 + 64), *(double *)(*(void *)&v9 + 72), 0.0);
  }
  uint64_t v77 = *(void *)(*(void *)&v8 + 40);
  uint64_t v78 = v77 & 0xC0000;
  uint64_t v79 = *(void *)(*(void *)&v8 + 128);
  if (v79)
  {
    float v80 = *(float *)(v79 + 288);
    if (!v78) {
      goto LABEL_169;
    }
  }
  else
  {
    LOBYTE(v70.f64[0]) = *(unsigned char *)(*(void *)&v8 + 35);
    float v80 = (float)LODWORD(v70.f64[0]);
    if (!v78) {
      goto LABEL_169;
    }
  }
  if ((v77 & 0x200000) != 0
    && (float)((float)*(unsigned int *)(a1[1] + 312) / (float)(*(_DWORD *)(a1[1] + 204) * *(_DWORD *)(a1[1] + 200))) >= 0.95)
  {
LABEL_169:
    int v81 = 0;
  }
  else
  {
    a2[37].i32[1] |= 0x1000000u;
    uint64_t v79 = *(void *)(*(void *)&v8 + 128);
    int v81 = 1;
  }
  uint64_t v245 = *(void *)&v10 + 56;
  double v82 = v80;
  if (!v79 || !*(void *)(v79 + 112))
  {
LABEL_186:
    BOOL v90 = v80 <= 0.0;
    double v91 = 1.0;
    if (v90) {
      double v82 = 1.0;
    }
    if (((*(void *)(*(void *)&v9 + 264) == 0) & ~v81) == 0)
    {
      double v92 = v246;
      goto LABEL_200;
    }
    int v240 = 0;
    v239 = 0;
    double v92 = v246;
    goto LABEL_208;
  }
  if ((v81 & 1) == 0
    && (a2[5].i16[0] & 8) != 0
    && ((a2[36].i8[0] & 0x10) == 0 || CA::Mat4Impl::mat4_is_rectilinear((CA::Mat4Impl *)&a2[18], v68)))
  {
    uint64_t v83 = *(void *)(*(void *)&a2[3] + 128);
    if (v83)
    {
      uint64_t v84 = *(void *)(v83 + 112);
      if (v84)
      {
        if (*(unsigned char *)(v84 + 108))
        {
          if (*(float *)(v83 + 228) <= 0.0)
          {
            CA::Render::Layer::max_corner_radii(v83);
            if (v70.f64[0] <= 0.0)
            {
              uint64_t v85 = *(void *)(*(void *)&a2[2] + 256);
              if (v85)
              {
                int8x8_t v242 = v9;
                double v86 = (os_unfair_lock_s *)(v85 + 36);
                os_unfair_lock_lock((os_unfair_lock_t)(v85 + 36));
                uint64_t v87 = *(void *)(v85 + 40);
                if (!v87)
                {
                  os_unfair_lock_unlock((os_unfair_lock_t)(v85 + 36));
                  int8x8_t v9 = v242;
                  goto LABEL_199;
                }
                double v88 = (os_unfair_lock_s *)(v87 + 40);
                os_unfair_lock_lock((os_unfair_lock_t)(v87 + 40));
                uint64_t v89 = *(void *)(v87 + 72) - *(void *)(v87 + 64);
                os_unfair_lock_unlock(v88);
                os_unfair_lock_unlock(v86);
                _ZF = v89 == 168;
                int8x8_t v9 = v242;
                if (_ZF)
                {
                  a2[5].i16[0] |= 0x10u;
                  goto LABEL_186;
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_199:
  a2[37].i32[1] |= 0x4000000u;
  double v94 = 1.0;
  double v92 = v246;
  if (v80 <= 0.0) {
    goto LABEL_202;
  }
LABEL_200:
  if (v82 <= 0.0)
  {
    __int16 v95 = 0;
  }
  else
  {
    double v94 = v82;
LABEL_202:
    *(void *)&a2[4] |= 0x800000uLL;
    *(_WORD *)(*(void *)&v10 + 124) = *(_WORD *)(*(void *)&v10 + 124) & 0xFCFF | 0x200;
    __int16 v95 = (CA::Transform *)x_heap_malloc_small_((uint64_t *)a1[7], 0x98uLL);
    CA::Transform::operator=((uint64_t)v95, (uint64_t)&a2[18]);
    float64x2_t v70 = (float64x2_t)CA::Transform::operator=((uint64_t)&a2[18], (uint64_t)&CA::identity_transform);
    double v82 = v94;
  }
  double v91 = 1.0;
  v239 = v95;
  if (v82 == 1.0)
  {
    int v240 = 1;
  }
  else
  {
    v70.f64[0] = v82;
    float64x2_t v96 = CA::Transform::scale_2d((CA::Transform *)&a2[18], v70);
    v96.f64[0] = 1.0 / v82;
    CA::Transform::scale_2d(v95, v96);
    int v240 = 1;
    double v91 = v82;
  }
  double v82 = 1.0;
LABEL_208:
  v238 = (CA::Mat4Impl *)&a2[18];
  *(void *)(*(void *)&v10 + 80) = a2 + 18;
  unint64_t v97 = (unint64_t)a2[4];
  if ((v97 & 0x2000000) != 0)
  {
    unint64_t v102 = v97 & 0xFFFFFFFCFFFFE7BFLL;
    a2[4] = (int8x8_t)(v97 & 0xFFFFFFFCFFFFE7BFLL);
  }
  else
  {
    int8x8_t v243 = v9;
    v250.i32[0] = 0;
    uint64_t v98 = *(void *)(*(void *)&v8 + 128);
    if (v98)
    {
      float64x2_t v99 = 0;
      int v100 = 0;
      if ((v97 & 0x8000) == 0)
      {
        float64x2_t v101 = *(unsigned int **)(v98 + 96);
        if (v101)
        {
          float64x2_t v99 = CA::OGL::prepare_filters((CA::Render::Update **)a1, (uint64_t)a2, v101, 0, v250.i32, 0);
          unint64_t v97 = (unint64_t)a2[4];
          int v100 = v250.i32[0];
        }
      }
    }
    else
    {
      int v100 = 0;
      float64x2_t v99 = 0;
    }
    if ((v97 & 0x100000840) != 0)
    {
      if (v100 <= 1) {
        int v100 = 1;
      }
      v250.i32[0] = v100;
    }
    if (CA::OGL::test_source_requirement(v100, *(CA::Mat4Impl **)(*(void *)&v10 + 80)))
    {
      v237 = 0;
      int v236 = 0;
      uint64_t v235 = 0;
      if (!v99) {
        goto LABEL_266;
      }
LABEL_228:
      long long v234 = v7;
      unint64_t v112 = v97 | 0x40000;
      if ((v97 & 0x1000) != 0) {
        unint64_t v112 = v97 & 0xFFFFFFFFFFFBE7FFLL | 0x40800;
      }
      if ((v112 & 0x200000000) != 0) {
        unint64_t v112 = v112 & 0xFFFFFFFCFFFFFFFFLL | 0x100000000;
      }
      a2[4] = (int8x8_t)v112;
      if (*((_DWORD *)v99 + 10))
      {
        char v113 = 0;
        a2[13] = (int8x8_t)CA::OGL::cache_node((uint64_t)a1, (uint64_t)a2, v99 + 5, *(void *)&a2[13]);
      }
      else
      {
        v114 = v99;
        do
        {
          BOOL can_filter_in_place = CA::OGL::can_filter_in_place(v114);
          char v113 = can_filter_in_place;
          v114 = (void *)*v114;
        }
        while (v114 && can_filter_in_place);
      }
      while (2)
      {
        if (v99[1]) {
          goto LABEL_238;
        }
        int v117 = (CA::ColorMatrix *)v99[6];
        if (v117)
        {
          if (!CA::ColorMatrix::is_alpha_identity(v117)) {
            goto LABEL_238;
          }
        }
        uint64_t v118 = v99[2];
        if (v118)
        {
          uint64_t v119 = *(void *)(v118 + 48);
          if (v119)
          {
            if ((*(uint64_t (**)(uint64_t))(*(void *)v119 + 40))(v119)) {
              goto LABEL_239;
            }
LABEL_238:
            *(void *)&a2[4] |= 0x40000000uLL;
          }
          else if ((*(_DWORD *)(v118 + 12) & 0x40100) == 0x100)
          {
            uint64_t v124 = 0;
            while (*(_DWORD *)(v118 + 24) != (unsigned __int16)CA::Render::Filter::is_opacity_commutative(void)const::atoms[v124])
            {
              if (++v124 == 3) {
                goto LABEL_238;
              }
            }
          }
        }
LABEL_239:
        if (v99[1] || (v120 = (CA::ColorMatrix *)v99[6]) != 0 && !CA::ColorMatrix::is_diagonal(v120))
        {
LABEL_240:
          *(void *)&a2[4] |= 0x400000000uLL;
        }
        else
        {
          uint64_t v121 = v99[2];
          if (v121 && !*(void *)(v121 + 48) && (*(_DWORD *)(v121 + 12) & 0x40100) == 0x100)
          {
            uint64_t v122 = 0;
            int v123 = *(_DWORD *)(v121 + 24);
            while (v123 != (unsigned __int16)CA::Render::Filter::is_color_scale_commutative(void)const::atoms[v122])
            {
              if (++v122 == 4) {
                goto LABEL_240;
              }
            }
          }
        }
        v113 &= *v99 != 0;
        a2[13] = (int8x8_t)CA::OGL::filter_node((uint64_t)a1, (uint64_t)a2, (uint64_t)v99, *(void *)&a2[13] + 56, v113, *(void *)&a2[13]);
        uint64_t v116 = v99[2];
        if (v116 && *(_DWORD *)(v116 + 24) == 421) {
          *(_WORD *)(*(void *)&v10 + 124) &= ~0x100u;
        }
        float64x2_t v99 = (void *)*v99;
        if (!v99)
        {
          unint64_t v97 = (unint64_t)a2[4];
          BOOL v7 = v234;
          double v92 = v246;
          goto LABEL_266;
        }
        continue;
      }
    }
    uint64_t v103 = x_heap_malloc_small_((uint64_t *)a1[7], 0x98uLL);
    uint64_t v104 = x_heap_malloc_small_((uint64_t *)a1[7], 0x98uLL);
    *(_OWORD *)uint64_t v103 = xmmword_184997D50;
    *(_OWORD *)(v103 + 16) = 0u;
    *(_OWORD *)(v103 + 32) = xmmword_184997D60;
    *(_OWORD *)(v103 + 48) = 0u;
    *(_OWORD *)(v103 + 64) = 0u;
    *(_OWORD *)(v103 + 80) = xmmword_184997D50;
    *(_OWORD *)(v103 + 96) = 0u;
    *(_OWORD *)(v103 + 112) = xmmword_184997D60;
    __asm { FMOV            V0.2D, #1.0 }
    *(_OWORD *)(v103 + 128) = _Q0;
    *(unsigned char *)(v103 + 144) &= 0xE0u;
    v237 = (CA::Transform *)v104;
    __n128 v107 = CA::Transform::operator=(v104, *(void *)(*(void *)&v10 + 80));
    if (v100 != 7)
    {
      uint64_t v108 = *(void *)(*(void *)&v10 + 80);
      if ((*(unsigned char *)(v108 + 144) & 0x10) != 0) {
        v107.n128_f64[0] = CA::Mat4Impl::mat4_get_scale((CA::Mat4Impl *)v108, 0, 0, v106);
      }
      else {
        v107.n128_u64[0] = *(void *)(v108 + 128);
      }
      double v109 = round(v107.n128_f64[0] * 65536.0);
      v107.n128_f64[0] = v109 * 0.0000152587891;
      float64x2_t v110 = CA::Transform::scale_2d((CA::Transform *)v103, (float64x2_t)v107);
      v110.f64[0] = 65536.0 / v109;
      CA::Transform::scale_2d(v237, v110);
    }
    unsigned int v111 = *(unsigned __int16 *)(*(void *)&v10 + 124);
    int v236 = (v111 >> 8) & 1;
    *(_WORD *)(*(void *)&v10 + 124) = v111 & 0xFCFF | 0x200;
    uint64_t v235 = *(void *)(*(void *)&v10 + 72);
    *(void *)(*(void *)&v10 + 72) = 0;
    *(void *)(*(void *)&v10 + 80) = v103;
    unint64_t v97 = (unint64_t)a2[4];
    if (v99) {
      goto LABEL_228;
    }
LABEL_266:
    unint64_t v125 = v97 & 0xFFFFFFFFFFFFE7FFLL | 0x800;
    if ((v97 & 0x100000800) == 0 || (v97 & 0x1000) == 0) {
      unint64_t v125 = v97;
    }
    if ((v97 & 0x100000800) != 0 && (v125 & 0x200000000) != 0) {
      unint64_t v126 = v125 & 0xFFFFFFFCFFFFFFFFLL | 0x100000000;
    }
    else {
      unint64_t v126 = v125;
    }
    int8x8_t v9 = v243;
    if ((v97 & 0x100000800) != 0 && (v97 & 0x1000) != 0 || (v97 & 0x100000800) != 0 && (v125 & 0x200000000) != 0) {
      a2[4] = (int8x8_t)v126;
    }
    if ((v126 & 0x100000840) != 0)
    {
      int8x8_t v127 = a2[13];
      uint64_t v128 = a1[9];
      if (v128) {
        a1[9] = *(void *)v128;
      }
      else {
        uint64_t v128 = x_heap_malloc_small_((uint64_t *)a1[7], 0xF8uLL);
      }
      *(void *)(v128 + 8) = a1;
      *(void *)(v128 + 16) = a2;
      *(void *)(v128 + 48) = 0;
      *(void *)(v128 + 192) = 0;
      *(void *)(v128 + 200) = 0;
      *(_DWORD *)(v128 + 208) = 0;
      *(_WORD *)(v128 + 212) = *(_WORD *)(v128 + 212) & 0xC000 | 1;
      unsigned int v129 = *(_DWORD *)(v128 + 220) & 0xFC000000;
      *(_DWORD *)(v128 + 216) = *(_DWORD *)(v128 + 216) & 0xFFC00000 | 0xF;
      *(_DWORD *)(v128 + 220) = v129;
      *(int8x8_t *)(v128 + 24) = v127;
      *(void *)(v128 + 32) = 0;
      *(_DWORD *)(v128 + 136) = -1;
      *(void *)uint64_t v128 = &unk_1ED02A3D8;
      CA::OGL::init_gstate(v128 + 56, *(void *)&v127 + 56);
      if ((*(void *)(*(void *)&a2[3] + 40) & 0x200000000) != 0) {
        char v130 = 7;
      }
      else {
        char v130 = 3;
      }
      *(unsigned char *)(v128 + 124) = v130;
      *(_DWORD *)(v128 + 220) = *(_DWORD *)(v128 + 220) & 0xFFEE0000 | 0x100001;
      a2[13] = (int8x8_t)v128;
      double v92 = v246;
    }
    if (v237)
    {
      CA::OGL::quad_node((uint64_t)a1, (uint64_t)a2, *(void *)&a2[13], 1, 1, 0, 0.0);
      uint64_t v245 = *(void *)&v131 + 56;
      *(void *)(*(void *)&v131 + 72) = v235;
      *(void *)(*(void *)&v131 + 80) = v237;
      if (v236) {
        __int16 v132 = 256;
      }
      else {
        __int16 v132 = 512;
      }
      *(_WORD *)(*(void *)&v131 + 124) = v132 | *(_WORD *)(*(void *)&v131 + 124) & 0xFCFF;
      *(void *)(*(void *)&v131 + 88) = *(void *)(*(void *)&v10 + 88);
      *(void *)(*(void *)&v10 + 88) = 0x3C003C003C003C00;
      a2[13] = v131;
    }
    unint64_t v102 = (unint64_t)a2[4];
  }
  if ((v102 & 0x6000000) == 0)
  {
    if (*(void *)(*(void *)&a2[1] + 24))
    {
      uint64_t v144 = *(void *)(*(void *)&v8 + 128);
      if (v144)
      {
        uint64_t v69 = *(void *)(v144 + 104);
        if (v69)
        {
          v250.i32[0] = 0;
          v145 = CA::OGL::prepare_filters((CA::Render::Update **)a1, (uint64_t)a2, (unsigned int *)v69, 1, v250.i32, 0);
          a2[17] = (int8x8_t)v145;
          unint64_t v102 = (unint64_t)a2[4];
          if (v145)
          {
            v102 |= 0x80000uLL;
            a2[4] = (int8x8_t)v102;
          }
        }
      }
    }
  }
  if ((v102 & 0x200008) == 8)
  {
    unint64_t v133 = v102;
  }
  else
  {
    unint64_t v133 = v102 | 0x10000;
    uint64_t v134 = v102 & 0x300007FE0;
    if ((v102 & 0x300007FE0) == 0) {
      unint64_t v133 = v102;
    }
    uint8x8_t v135 = (uint8x8_t)vcnt_s8((int8x8_t)v134);
    v135.i16[0] = vaddlv_u8(v135);
    if (v135.u32[0] > 1uLL) {
      v133 |= 0x20000uLL;
    }
    if (v134 || v135.u32[0] >= 2uLL)
    {
      a2[4] = (int8x8_t)v133;
      unint64_t v102 = v133;
    }
  }
  uint64_t v136 = *(void *)(*(void *)&v9 + 24);
  if ((v136 & 0x18000) != 0)
  {
    unint64_t v102 = v133 | 0x800000;
    a2[4] = (int8x8_t)(v133 | 0x800000);
    if ((v136 & 0x8000) != 0)
    {
      a2[37].i32[1] |= 0x40000u;
      uint64_t v136 = *(void *)(*(void *)&v9 + 24);
    }
    if ((v136 & 0x10000) != 0)
    {
      a2[37].i32[1] |= 0x80000u;
      uint64_t v136 = *(void *)(*(void *)&v9 + 24);
    }
    v133 |= 0x800000uLL;
  }
  if ((v136 & 0x4000) != 0 && (v133 & 0x40000) == 0)
  {
    if ((*(unsigned char *)(*(void *)&a2[3] + 43) & 0x40) != 0
      || (int v137 = (*(uint64_t (**)(float *))(*(void *)v7 + 760))(v7),
          unint64_t v133 = (unint64_t)a2[4],
          unint64_t v102 = v133,
          v137))
    {
      unint64_t v102 = v133 | 0x800000;
      a2[4] = (int8x8_t)(v133 | 0x800000);
      a2[37].i32[1] |= 0x100000u;
      v133 |= 0x800000uLL;
    }
  }
  if ((~v133 & 0x20004) == 0 && (*(unsigned char *)(*(void *)&v9 + 26) & 0x10) == 0)
  {
    __int16 v138 = a2[5].i16[0];
    if ((v138 & 2) != 0
      || (v138 & 1) != 0
      && (*(unsigned char *)(*(void *)&a2[3] + 43) & 0x20) != 0
      && (*(unsigned char *)(*a1 + 432) & 4) == 0
      && (*(unsigned char *)(*(void *)&a2[2] + 24) & 0x80) == 0)
    {
      unint64_t v102 = v133 | 0x800000;
      a2[4] = (int8x8_t)(v133 | 0x800000);
      a2[37].i32[1] |= 0x200000u;
      v133 |= 0x800000uLL;
    }
  }
  if ((~v133 & 0x40000004) == 0)
  {
    unint64_t v102 = v133 | 0x800000;
    a2[4] = (int8x8_t)(v133 | 0x800000);
    a2[37].i32[1] |= 0x400000u;
    v133 |= 0x800000uLL;
  }
  if ((v133 & 0x400000000) != 0)
  {
    short float v139 = *((short float *)v92 + 17);
    if (*((short float *)v92 + 16) != v139
      || (short float v140 = *((short float *)v92 + 18), v139 != v140)
      || v140 != *((short float *)v92 + 19))
    {
      unint64_t v102 = v133 | 0x800000;
      a2[4] = (int8x8_t)(v133 | 0x800000);
      a2[37].i32[1] |= 0x400000u;
      v133 |= 0x800000uLL;
    }
  }
  uint64_t v141 = *((void *)v92 + 4);
  if (v141 != 0x3C003C003C003C00
    && (*((short float *)&v141 + 2) > COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))
     || *(short float *)&v141 > COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))
     || *((short float *)&v141 + 1) > COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))))
  {
    unint64_t v102 = v133 | 0x1000000000;
    a2[4] = (int8x8_t)(v133 | 0x1000000000);
    v133 |= 0x1000000000uLL;
  }
  if (*(unsigned char *)(*(void *)&a2[3] + 43))
  {
    unint64_t v102 = v133 | 0x800000;
    a2[4] = (int8x8_t)(v133 | 0x800000);
    v133 |= 0x800000uLL;
    if ((v133 & 0x100000) != 0) {
      goto LABEL_347;
    }
LABEL_331:
    if ((v133 & 0x800000) == 0) {
      goto LABEL_332;
    }
  }
  else
  {
    if ((v133 & 0x100000) == 0) {
      goto LABEL_331;
    }
LABEL_347:
    if (v62)
    {
      uint64_t v146 = *(void *)(v62 + 32);
      uint64_t v147 = *(void *)(v146 + 128);
      if (v147 && *(void *)(v147 + 96))
      {
        LOBYTE(v62) = 0;
      }
      else
      {
        long long v267 = 0u;
        long long v268 = 0u;
        long long v265 = 0u;
        long long v266 = 0u;
        long long v263 = 0u;
        long long v264 = 0u;
        long long v261 = 0u;
        long long v262 = 0u;
        long long v259 = 0u;
        long long v260 = 0u;
        long long v257 = 0u;
        long long v258 = 0u;
        long long v255 = 0u;
        long long v256 = 0u;
        long long v253 = 0u;
        long long v254 = 0u;
        long long v251 = 0u;
        long long v252 = 0u;
        int8x16_t v250 = 0u;
        WORD5(v252) = 3;
        uint64_t v148 = *(void *)(v146 + 128);
        if (v148)
        {
          uint64_t v69 = *(void *)(v148 + 88);
          if (v69 && (*(unsigned char *)(v69 + 13) & 1) != 0)
          {
            CA::OGL::prepare_compositing_filter(a1, (int8x8_t *)&v250, v69, 1);
            LODWORD(v148) = v252;
            unint64_t v102 = (unint64_t)a2[4];
            LODWORD(v133) = v102;
          }
          else
          {
            LODWORD(v148) = 0;
          }
        }
        LOBYTE(v62) = (v148 & 0x100000) == 0;
      }
    }
    if ((v133 & 0x80820000) != 0) {
      goto LABEL_358;
    }
    if ((v133 & 0x200000) != 0 && (a2[5].i16[0] & 8) == 0)
    {
      if ((v133 & 0x30000) != 0x10000
        || (v133 & 0x6120) == 0
        || (v133 & 0x100) != 0 && (*(_DWORD *)(*(void *)&a2[3] + 36) & 0xF000) != 0x9000
        || (*((_WORD *)v92 + 34) & 0x100) == 0
        || (a2[36].i8[0] & 0x10) != 0 && !CA::Mat4Impl::mat4_is_rectilinear(v238, v68))
      {
        goto LABEL_358;
      }
      int8x8_t v152 = a2[3];
      long long v153 = *(_OWORD *)(*(void *)&v152 + 80);
      int8x16_t v250 = *(int8x16_t *)(*(void *)&v152 + 64);
      long long v251 = v153;
      *(double *)v154.i64 = CA::Rect::apply_transform(&v250, v238, (double *)v69);
      int v156 = *((_DWORD *)a1 + 10);
      int v157 = *((_DWORD *)a1 + 11);
      if (v156 <= v157) {
        int v158 = *((_DWORD *)a1 + 11);
      }
      else {
        int v158 = *((_DWORD *)a1 + 10);
      }
      v154.i32[0] = 1073741822;
      v155.i32[0] = v158;
      int8x16_t v159 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v155, v154), 0);
      uint64_t v160 = a1[4];
      v161.i64[0] = (int)v160;
      v161.i64[1] = SHIDWORD(v160);
      int8x16_t v162 = vbslq_s8(v159, (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v161));
      double v163 = (double)v156;
      if (v158 > 1073741822) {
        double v163 = 1.79769313e308;
      }
      int8x16_t v247 = v162;
      double v164 = v158 <= 1073741822 ? (double)v157 : 1.79769313e308;
      double v248 = v163;
      double v249 = v164;
      if (!CA::BoundsImpl::contains((double *)v250.i64, (double *)v247.i64))
      {
        int8x8_t v209 = a2[1];
        if (!*(void *)&v209
          || (*(unsigned char *)(*(void *)&v209 + 288) & 0x10) != 0
          && !CA::Mat4Impl::mat4_is_rectilinear((CA::Mat4Impl *)(*(void *)&v209 + 144), v68))
        {
          goto LABEL_358;
        }
        uint64_t v210 = *(void *)(*(void *)&v209 + 16);
        if (!v210) {
          goto LABEL_358;
        }
        int v211 = *(_DWORD *)(v210 + 168);
        int v212 = *(_DWORD *)(v210 + 172);
        if (v211 <= v212) {
          int v213 = *(_DWORD *)(v210 + 172);
        }
        else {
          int v213 = *(_DWORD *)(v210 + 168);
        }
        v166.i32[0] = 1073741822;
        v71.i32[0] = v213;
        int8x16_t v214 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v71, v166), 0);
        uint64_t v215 = *(void *)(v210 + 160);
        v216.i64[0] = (int)v215;
        v216.i64[1] = SHIDWORD(v215);
        int8x16_t v217 = vbslq_s8(v214, (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v216));
        double v218 = (double)v211;
        if (v213 > 1073741822) {
          double v218 = 1.79769313e308;
        }
        int8x16_t v247 = v217;
        double v219 = v213 <= 1073741822 ? (double)v212 : 1.79769313e308;
        double v248 = v218;
        double v249 = v219;
        CA::Rect::apply_transform(&v247, (const CA::Transform *)(*(void *)&v209 + 144), v165);
        if (!CA::BoundsImpl::contains((double *)v250.i64, (double *)v247.i64)) {
          goto LABEL_358;
        }
      }
    }
    char v167 = (v102 & 0x200) != 0 ? v62 : 1;
    if ((v167 & 1) == 0)
    {
LABEL_358:
      a2[4] = (int8x8_t)(v102 | 0x800000);
      a2[37].i32[1] |= 0x800000u;
      goto LABEL_359;
    }
    if (!((v62 ^ 1) & 1 | (v102 >> 18) & 1))
    {
      __int16 v168 = a2[5].i16[1];
      *(_OWORD *)a2[6].i8 = *(_OWORD *)a2[8].i8;
      a2[10] = a2[11];
      a2[5].i16[1] = (v168 << 8) | 3;
      unint64_t v133 = v102 & 0xFFFFFFFFFFEFFFFFLL;
      a2[4] = (int8x8_t)(v102 & 0xFFFFFFFFFFEFFFFFLL);
      if ((v102 & 0x800000) != 0) {
        goto LABEL_359;
      }
LABEL_332:
      if ((v133 & 4) != 0)
      {
        __int16 v142 = a2[5].i16[0];
        if ((v142 & 2) != 0
          || (v142 & 1) != 0
          && (*(unsigned char *)(*(void *)&a2[3] + 43) & 0x20) != 0
          && (*(unsigned char *)(*a1 + 432) & 4) == 0
          && (*(unsigned char *)(*(void *)&a2[2] + 24) & 0x80) == 0)
        {
          a2[5].i16[0] = v142 | 4;
        }
      }
      uint64_t v143 = v245;
      if ((v133 & 0x210000) == 0x200000)
      {
        v133 |= 0x10020uLL;
        goto LABEL_437;
      }
      goto LABEL_438;
    }
    unint64_t v133 = v102;
    if ((v102 & 0x800000) == 0) {
      goto LABEL_332;
    }
  }
LABEL_359:
  uint64_t v149 = (uint64_t)a2[13];
  if (!v240) {
    goto LABEL_429;
  }
  uint64_t v150 = *(void *)(*(void *)&v8 + 40);
  if ((v150 & 0x80000) != 0)
  {
    uint64_t v169 = *(void *)(*(void *)&v8 + 144);
    if (v169)
    {
      unsigned int v170 = *(_DWORD *)(v169 + 72);
      if (!v170)
      {
        unsigned int v170 = atomic_fetch_add(CA::Render::next_cache_id(void)::cache_id, 1u) + 1;
        *(void *)(v169 + 72) = v170;
      }
      uint64_t v171 = a1[9];
      if (v171)
      {
        a1[9] = *(void *)v171;
      }
      else
      {
        uint64_t v171 = x_heap_malloc_small_((uint64_t *)a1[7], 0xF8uLL);
        unsigned int v170 = *(_DWORD *)(v169 + 72);
      }
      *(void *)(v171 + 8) = a1;
      *(void *)(v171 + 16) = a2;
      *(void *)(v171 + 48) = 0;
      *(void *)(v171 + 192) = 0;
      *(void *)(v171 + 200) = 0;
      *(_DWORD *)(v171 + 208) = 0;
      *(_WORD *)(v171 + 212) = *(_WORD *)(v171 + 212) & 0xC000 | 1;
      unsigned int v172 = *(_DWORD *)(v171 + 220) & 0xFC000000;
      *(_DWORD *)(v171 + 216) = *(_DWORD *)(v171 + 216) & 0xFFC00000 | 0xF;
      *(_DWORD *)(v171 + 220) = v172;
      *(void *)(v171 + 24) = v149;
      *(void *)(v171 + 32) = 0;
      *(_DWORD *)(v171 + 136) = -1;
      *(void *)uint64_t v171 = &unk_1ED02A4F0;
      *(_DWORD *)(v171 + 224) = v170;
      *(_DWORD *)(v149 + 220) |= 0x400000u;
      CA::OGL::copy_gstate(v171 + 56, v149 + 56);
      *(_DWORD *)(v171 + 220) = *(_DWORD *)(v171 + 220) & 0xFFEE0000 | 0x101000;
      uint64_t v149 = v171;
    }
  }
  else if ((v150 & 0x240000) == 0x40000 && (*(_DWORD *)(a1[1] + 1084) & 4) == 0)
  {
    uint64_t v151 = *(void *)(*(void *)&v8 + 144);
    if (v151)
    {
      if (!*(_DWORD *)(v151 + 72)) {
        *(void *)(v151 + 72) = atomic_fetch_add(CA::Render::next_cache_id(void)::cache_id, 1u) + 1;
      }
      uint64_t v149 = CA::OGL::cache_node((uint64_t)a1, (uint64_t)a2, (void *)(v151 + 72), v149);
    }
  }
  int8x8_t v244 = v9;
  int v173 = *(_DWORD *)(*(void *)&v8 + 36);
  if ((v173 & 0xFu) > 0xA) {
    char v174 = 1;
  }
  else {
    char v174 = CA::OGL::texture_filter(CA::Render::ImageFilter)::filters[v173 & 0xF];
  }
  v175 = v7;
  uint64_t v176 = v173 >> 4;
  if (v176 > 0xA) {
    char v177 = 1;
  }
  else {
    char v177 = CA::OGL::texture_filter(CA::Render::ImageFilter)::filters[v176];
  }
  uint64_t v178 = *(void *)(*(void *)&v8 + 128);
  if (v178) {
    float v179 = *(float *)(v178 + 292);
  }
  else {
    float v179 = 0.0;
  }
  int8x8_t v180 = *(int8x8_t *)(*(void *)&a2[2] + 264);
  if (v180)
  {
    v181 = (int8x8_t *)a1[9];
    if (v181) {
      a1[9] = *v181;
    }
    else {
      v181 = (int8x8_t *)x_heap_malloc_small_((uint64_t *)a1[7], 0xF8uLL);
    }
    v181[1] = (int8x8_t)a1;
    v181[2] = (int8x8_t)a2;
    v181[6] = 0;
    v181[24] = 0;
    v181[25] = 0;
    v181[26].i32[0] = 0;
    v181[26].i16[2] = v181[26].i16[2] & 0xC000 | 1;
    v181[3] = (int8x8_t)v149;
    v181[4] = 0;
    v181[17].i32[0] = -1;
    int8x8_t *v181 = (int8x8_t)&unk_1ED02B728;
    v181[28] = v180;
    v181[27] = vorr_s8(vand_s8(v181[27], (int8x8_t)0xFC000000FFC00000), (int8x8_t)0x4000000000000FLL);
    CA::OGL::copy_gstate((uint64_t)&v181[7], v149 + 56);
    v181[27].i32[1] = v181[27].i32[1] & 0xFFEE0000 | 0x110000;
    uint64_t v178 = *(void *)(*(void *)&v8 + 128);
    if (v178)
    {
LABEL_418:
      uint64_t v182 = *(void *)(v178 + 112);
      if (v182)
      {
        os_unfair_lock_lock((os_unfair_lock_t)(v182 + 16));
        CA::Render::MeshTransform::update_locked((CA::Render::MeshTransform *)v182, 1);
        os_unfair_lock_unlock((os_unfair_lock_t)(v182 + 16));
        uint64_t v149 = a1[9];
        if (v149) {
          a1[9] = *(void *)v149;
        }
        else {
          uint64_t v149 = x_heap_malloc_small_((uint64_t *)a1[7], 0xF8uLL);
        }
        *(void *)(v149 + 8) = a1;
        *(void *)(v149 + 16) = a2;
        *(void *)(v149 + 48) = 0;
        *(void *)(v149 + 192) = 0;
        *(void *)(v149 + 200) = 0;
        *(_DWORD *)(v149 + 208) = 0;
        *(_WORD *)(v149 + 212) = *(_WORD *)(v149 + 212) & 0xC000 | 1;
        unsigned int v187 = *(_DWORD *)(v149 + 220) & 0xFC000000;
        *(_DWORD *)(v149 + 216) = *(_DWORD *)(v149 + 216) & 0xFFC00000 | 0xF;
        *(_DWORD *)(v149 + 220) = v187;
        *(void *)(v149 + 24) = v181;
        *(void *)(v149 + 32) = 0;
        *(_DWORD *)(v149 + 136) = -1;
        *(void *)uint64_t v149 = &unk_1ED02C080;
        *(unsigned char *)(v149 + 224) = v174 & 0xF | (16 * v177);
        *(void *)(v149 + 232) = v182;
        float v183 = v91;
        *(float *)(v149 + 240) = v183;
        *(float *)(v149 + 244) = v179;
        CA::OGL::init_gstate(v149 + 56, (uint64_t)&v181[7]);
        *(_DWORD *)(v149 + 220) = *(_DWORD *)(v149 + 220) & 0xFFEE0000 | 0x102000;
        v188.f64[0] = v91;
        float64x2_t v189 = CA::Transform::scale_2d(v239, v188);
        __int16 v190 = 0;
        *(void *)(v149 + 80) = v239;
        double v92 = v246;
        if ((*((_WORD *)v246 + 34) & 0x100) != 0) {
          __int16 v190 = ~a2[4].i16[1] & 0x100;
        }
        *(_WORD *)(v149 + 124) = *(_WORD *)(v149 + 124) & 0xFEFF | v190;
        uint64_t v191 = *(void *)(*(void *)&a2[2] + 24);
        BOOL v7 = v175;
        int8x8_t v9 = v244;
        if ((v191 & 0x18000) == 0
          && ((v191 & 0x4000) == 0
           || (*(unsigned char *)(*(void *)&a2[3] + 43) & 0x40) == 0
           && ((*(uint64_t (**)(float *, float64x2_t))(*(void *)v175 + 760))(v175, v189) & 1) == 0))
        {
          BOOL v186 = *(double *)(v182 + 168) != *(double *)(v182 + 192) && (*(void *)&a2[4] & 0x100004) != 0;
          goto LABEL_430;
        }
LABEL_429:
        BOOL v186 = 1;
        goto LABEL_430;
      }
    }
  }
  else
  {
    v181 = (int8x8_t *)v149;
    if (v178) {
      goto LABEL_418;
    }
  }
  CA::OGL::quad_node((uint64_t)a1, (uint64_t)a2, (uint64_t)v181, v174, v177, (a2[5].u16[0] >> 6), v179);
  uint64_t v149 = v184;
  *(void *)(v184 + 80) = v239;
  double v92 = v246;
  if ((*((_WORD *)v246 + 34) & 0x100) != 0) {
    __int16 v185 = ~a2[4].i16[1] & 0x100;
  }
  else {
    __int16 v185 = 0;
  }
  BOOL v7 = v175;
  int8x8_t v9 = v244;
  BOOL v186 = 0;
  *(_WORD *)(v184 + 124) = *(_WORD *)(v184 + 124) & 0xFEFF | v185;
LABEL_430:
  if (a2[4].i8[3])
  {
    uint64_t v192 = *((void *)v92 + 3);
    if (v82 != 1.0)
    {
      long long v193 = (CA::Transform *)x_heap_malloc_small_((uint64_t *)a1[7], 0x98uLL);
      __n128 v194 = CA::Transform::operator=((uint64_t)v193, v192);
      v194.n128_f64[0] = v82;
      CA::Transform::scale_2d_right(v238, v194, v195, v196, v197);
      v198.f64[0] = 1.0 / v82;
      CA::Transform::scale_2d(v193, v198);
      uint64_t v192 = (uint64_t)v193;
    }
    CA::OGL::quad_node((uint64_t)a1, (uint64_t)a2, v149, 1, 1, 0, 0.0);
    uint64_t v149 = v199;
    *(void *)(v199 + 80) = v192;
    *(void *)(v199 + 72) = *((void *)v92 + 2);
    *(_WORD *)(v199 + 124) = *(_WORD *)(v199 + 124) & 0xFEFF | *((_WORD *)v92 + 34) & 0x100;
  }
  else if (v186)
  {
    uint64_t v149 = CA::OGL::combine_node((uint64_t **)a1, (uint64_t)a2, 3, v149 + 56, v149, 0, 0.0, 0.0, 0.0, 0.0);
    *(_DWORD *)(v149 + 220) = *(_DWORD *)(v149 + 220) & 0xFFFE0000 | 0x200;
  }
  *(void *)(v149 + 88) = *(void *)(v245 + 32);
  *(void *)(v245 + 32) = 0x3C003C003C003C00;
  uint64_t v143 = v149 + 56;
  a2[13] = (int8x8_t)v149;
  unint64_t v133 = *(void *)&a2[4] & 0xFFFFFFEFFFFFFFFFLL;
LABEL_437:
  a2[4] = (int8x8_t)v133;
LABEL_438:
  uint64_t v200 = v143;
  if ((v133 & 0x840000) == 0x40000) {
    uint64_t v200 = *(void *)&a2[13] + 56;
  }
  unsigned int v201 = *(_DWORD *)(*(void *)&v9 + 116);
  if (v201 != -1)
  {
    unsigned int v202 = bswap32(v201);
    v71.i32[0] = v202;
    v71.i32[1] = v202 >> 8;
    v71.i32[2] = HIWORD(v202);
    v203.i64[0] = 0xFF000000FFLL;
    v203.i64[1] = 0xFF000000FFLL;
    int32x4_t v204 = (int32x4_t)vandq_s8((int8x16_t)v71, v203);
    v204.i32[3] = vshrq_n_u32((uint32x4_t)vdupq_n_s32(v202), 0x18uLL).i32[3];
    float16x4_t v205 = vcvt_f16_f32(vmulq_f32(vcvtq_f32_s32(v204), (float32x4_t)vdupq_n_s32(0x3B808081u)));
    if (*(void *)(v143 + 32) != 0x3C003C003C003C00) {
      float16x4_t v205 = vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16(v205), vcvtq_f32_f16(*(float16x4_t *)(v200 + 32))));
    }
    *(float16x4_t *)(v200 + 32) = v205;
  }
  uint64_t v206 = *(void *)(*(void *)&v8 + 128);
  if (v206)
  {
    float v207 = *(float *)(v206 + 296);
    if (v207 != 1.0)
    {
      CA::Render::Update::render_edr_factor((CA::Render::Update *)a1[1], (const CA::Render::LayerNode *)v68);
      float v221 = 1.0 / v220;
      float v222 = *(float *)(v200 + 64);
      if (v222 >= v221) {
        float v223 = v221;
      }
      else {
        float v223 = *(float *)(v200 + 64);
      }
      float v224 = v222 * v207;
      *(float *)(v200 + 64) = v224;
      if (v224 < v221) {
        float v221 = v224;
      }
      float v225 = v221 / v223;
      if (v225 > 0.0)
      {
        float v226 = powf(v225, 1.0 / v7[38]);
        _H1 = *(_WORD *)(v200 + 32);
        __asm { FCVT            S1, H1 }
        _S1 = v226 * _S1;
        __asm { FCVT            H1, S1 }
        *(_WORD *)(v200 + 32) = LOWORD(_S1);
        LOWORD(_S1) = *(_WORD *)(v200 + 34);
        __asm { FCVT            S1, H1 }
        _S1 = v226 * _S1;
        __asm { FCVT            H1, S1 }
        *(_WORD *)(v200 + 34) = LOWORD(_S1);
        LOWORD(_S1) = *(_WORD *)(v200 + 36);
        __asm { FCVT            S1, H1 }
        _S0 = v226 * _S1;
        __asm { FCVT            H0, S0 }
        *(_WORD *)(v200 + 36) = LOWORD(_S0);
      }
    }
  }
  return v143;
}

__n128 CA::Transform::operator=(uint64_t a1, uint64_t a2)
{
  long long v2 = *(_OWORD *)(a2 + 16);
  long long v3 = *(_OWORD *)(a2 + 32);
  long long v4 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v2;
  *(_OWORD *)(a1 + 32) = v3;
  *(_OWORD *)(a1 + 48) = v4;
  long long v5 = *(_OWORD *)(a2 + 80);
  long long v6 = *(_OWORD *)(a2 + 96);
  long long v7 = *(_OWORD *)(a2 + 112);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 80) = v5;
  *(_OWORD *)(a1 + 96) = v6;
  *(_OWORD *)(a1 + 112) = v7;
  __n128 result = *(__n128 *)(a2 + 128);
  *(__n128 *)(a1 + 128) = result;
  int v9 = *(unsigned char *)(a1 + 144) & 0xF8 | *(unsigned char *)(a2 + 144) & 7;
  *(unsigned char *)(a1 + 144) = v9;
  unsigned int v10 = v9 & 0xFFFFFFF7 | (8 * ((*(unsigned __int8 *)(a2 + 144) >> 3) & 1));
  *(unsigned char *)(a1 + 144) = v10;
  *(unsigned char *)(a1 + 144) = v10 & 0xEF | *(unsigned char *)(a2 + 144) & 0x10;
  return result;
}

float64x2_t CA::Transform::translate(CA::Transform *this, double a2, double a3, double a4)
{
  char v4 = *((unsigned char *)this + 144);
  if ((v4 & 0x10) != 0)
  {
    float64x2_t v13 = vmlaq_n_f64(vmlaq_n_f64(*((float64x2_t *)this + 6), *(float64x2_t *)this, a2), *((float64x2_t *)this + 2), a3);
    float64x2_t v14 = vmlaq_n_f64(vmlaq_n_f64(*((float64x2_t *)this + 7), *((float64x2_t *)this + 1), a2), *((float64x2_t *)this + 3), a3);
    float64x2_t result = *((float64x2_t *)this + 4);
    float64x2_t v15 = vmlaq_n_f64(v14, *((float64x2_t *)this + 5), a4);
    *((float64x2_t *)this + 6) = vmlaq_n_f64(v13, result, a4);
    *((float64x2_t *)this + 7) = v15;
  }
  else
  {
    if ((*((unsigned char *)this + 144) & 8) != 0)
    {
      double v5 = *((double *)this + 16);
      a2 = v5 * a2;
      a3 = v5 * a3;
    }
    double v6 = -a3;
    if ((*((unsigned char *)this + 144) & 4) == 0)
    {
      double v6 = a2;
      a2 = a3;
    }
    double v7 = -v6;
    if ((*((unsigned char *)this + 144) & 2) == 0) {
      double v7 = v6;
    }
    if (*((unsigned char *)this + 144)) {
      a2 = -a2;
    }
    result.f64[0] = a2 + *((double *)this + 13);
    *((double *)this + 12) = v7 + *((double *)this + 12);
    *((void *)this + 13) = *(void *)&result.f64[0];
    if (a4 != 0.0)
    {
      *((double *)this + 14) = *((double *)this + 14) + a4;
      __asm { FMOV            V0.2D, #1.0 }
      *((float64x2_t *)this + 8) = result;
      *((unsigned char *)this + 144) = v4 & 0xE0 | 0x10;
    }
  }
  return result;
}

uint64_t CA::OGL::ImagingNode::needs_surface(CA::OGL::ImagingNode *this)
{
  return 0;
}

BOOL CA::OGL::test_source_requirement(int a1, CA::Mat4Impl *this)
{
  switch(a1)
  {
    case 1:
      if ((*((unsigned char *)this + 144) & 0x10) == 0) {
        return 1;
      }
      if (*((double *)this + 3) == 0.0)
      {
        double v2 = *((double *)this + 7);
        return v2 == 0.0;
      }
      return 0;
    case 2:
      if ((*((unsigned char *)this + 144) & 0x10) == 0) {
        return 1;
      }
      return CA::Mat4Impl::mat4_is_affine_with_z_translate(this, (const double *)this);
    case 3:
      if ((*((unsigned char *)this + 144) & 0x10) == 0) {
        return 1;
      }
      return CA::Mat4Impl::mat4_is_affine(this, (const double *)this);
    case 4:
      if ((*((unsigned char *)this + 144) & 0x10) == 0) {
        return 1;
      }
      return CA::Mat4Impl::mat4_is_rectilinear(this, (const double *)this);
    case 5:
      return (*((unsigned char *)this + 144) & 0x17) == 0;
    case 6:
      return (*((unsigned char *)this + 144) & 0x1F) == 0;
    case 7:
      BOOL result = 0;
      if ((*((unsigned char *)this + 144) & 0x1F) != 0 || *((double *)this + 12) != 0.0) {
        return result;
      }
      double v2 = *((double *)this + 13);
      return v2 == 0.0;
    default:
      return 1;
  }
}

uint64_t CA::OGL::Renderer::alloc_layer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(a1 + 64);
  if (v8) {
    *(void *)(a1 + 64) = *(void *)v8;
  }
  else {
    uint64_t v8 = x_heap_malloc_small_(*(uint64_t **)(a1 + 56), 0x130uLL);
  }
  *(void *)uint64_t v8 = 0;
  *(void *)(v8 + 8) = a3;
  uint64_t v9 = *(void *)(a2 + 32);
  *(void *)(v8 + 16) = a2;
  *(void *)(v8 + 24) = v9;
  *(void *)(v8 + 32) = 0;
  __int16 v10 = *(_WORD *)(v8 + 40);
  *(_WORD *)(v8 + 40) = v10 & 0xFFC0;
  if ((*(unsigned char *)(v9 + 43) & 4) == 0
    || (*(unsigned char *)(*(void *)a1 + 432) & 8) != 0
    || (*(void *)(a2 + 24) & 0x100) != 0)
  {
    __int16 v11 = 0;
  }
  else
  {
    __int16 v11 = 16320;
  }
  *(_WORD *)(v8 + 40) = v11 | v10 & 0xC000;
  *(_WORD *)(v8 + 42) = 771;
  *(_DWORD *)(v8 + 296) = 0;
  *(_OWORD *)(v8 + 64) = 0u;
  *(_OWORD *)(v8 + 80) = 0u;
  *(_OWORD *)(v8 + 96) = 0u;
  *(_OWORD *)(v8 + 112) = 0u;
  *(_OWORD *)(v8 + 128) = 0u;
  *(_DWORD *)(v8 + 300) &= 0xF0000000;
  uint64_t v12 = *(void *)(a1 + 72);
  if (v12) {
    *(void *)(a1 + 72) = *(void *)v12;
  }
  else {
    uint64_t v12 = x_heap_malloc_small_(*(uint64_t **)(a1 + 56), 0xF8uLL);
  }
  *(void *)(v12 + 8) = a1;
  *(void *)(v12 + 16) = v8;
  *(void *)(v12 + 48) = 0;
  *(void *)(v12 + 192) = 0;
  *(void *)(v12 + 200) = 0;
  *(_DWORD *)(v12 + 208) = 0;
  *(_WORD *)(v12 + 212) = *(_WORD *)(v12 + 212) & 0xC000 | 1;
  unsigned int v13 = *(_DWORD *)(v12 + 220) & 0xFC000000;
  *(_DWORD *)(v12 + 216) = *(_DWORD *)(v12 + 216) & 0xFFC00000 | 0xF;
  *(_DWORD *)(v12 + 220) = v13;
  *(void *)(v12 + 24) = 0;
  *(void *)(v12 + 32) = 0;
  *(_DWORD *)(v12 + 136) = -1;
  *(void *)uint64_t v12 = &unk_1ED02C768;
  *(unsigned char *)(v12 + 224) &= 0xFCu;
  *(void *)(v12 + 232) = 0;
  *(void *)(v8 + 104) = v12;
  *(void *)(v12 + 64) = 0;
  *(void *)(v12 + 72) = 0;
  __int16 v14 = (*(unsigned __int8 *)(v12 + 125) << 8) | 3;
  uint64_t v15 = *(void *)(a4 + 32);
  *(_WORD *)(v12 + 124) = v14;
  *(void *)(v12 + 88) = v15;
  *(void *)(v12 + 96) = 0;
  *(void *)(v12 + 104) = 0;
  *(void *)(v12 + 112) = 0;
  *(_DWORD *)(v12 + 120) = *(_DWORD *)(a4 + 64);
  __int16 v16 = v14 & 0xFCFF | *(_WORD *)(a4 + 68) & 0x100;
  *(_WORD *)(v12 + 124) = v16;
  *(_WORD *)(v12 + 124) = v16 & 0xFBFF | *(_WORD *)(a4 + 68) & 0x400;
  return v8;
}

uint64_t x_heap_malloc_small_(uint64_t *a1, unint64_t a2)
{
  unint64_t v4 = a1[2];
  if (v4 < a2)
  {
    double v5 = malloc_type_malloc(a1[3], 0x9F16532FuLL);
    uint64_t v6 = a1[3];
    a1[1] = (uint64_t)v5;
    a1[2] = v6;
    uint64_t v7 = *a1;
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    uint64_t v9 = malloc_type_zone_malloc(malloc_zone, 0x10uLL, 0x8BB15036uLL);
    *uint64_t v9 = v5;
    v9[1] = v7;
    *a1 = (uint64_t)v9;
    unint64_t v4 = a1[2];
  }
  uint64_t result = a1[1];
  a1[1] = result + a2;
  a1[2] = v4 - a2;
  return result;
}

uint64_t CA::Render::Layer::apply_contents_transform(uint64_t a1, uint64_t a2, float64x2_t *a3, int a4)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  float64x2_t v29 = 0uLL;
  double v27 = 0.0;
  double v28 = 0.0;
  char v7 = CA::Render::compute_gravity_transform((unsigned __int16)*(_DWORD *)(a1 + 36) >> 12, (double *)(a1 + 64), a3, (uint64_t)&v29, (uint64_t)&v27);
  uint64_t v8 = *(void *)(a1 + 128);
  if (v8 && (uint64_t v9 = *(void *)(v8 + 32)) != 0)
  {
    uint64_t v32 = 0;
    memset(v31, 0, sizeof(v31));
    CA::Transform::set_affine_rectilinear((CA::Transform *)v31, v27, v28, v29.f64[0], v29.f64[1]);
    unsigned int v10 = *(_DWORD *)(v9 + 16);
    __int16 v11 = (double *)(v9 + 24);
    uint64_t v12 = (double *)(v9 + 40);
    _CF = v10 >= 6;
    if (v10 >= 6) {
      __int16 v14 = (double *)(v9 + 56);
    }
    else {
      __int16 v14 = (double *)(MEMORY[0x1E4F1DAB8] + 32);
    }
    if (!_CF)
    {
      uint64_t v12 = (double *)(MEMORY[0x1E4F1DAB8] + 16);
      __int16 v11 = (double *)MEMORY[0x1E4F1DAB8];
    }
    CA::Transform::set_affine((CA::Transform *)v30, *v11, v11[1], *v12, v12[1], *v14, v14[1]);
    CA::Transform::concat((CA::Transform *)v31, v30, v15, v16);
    CA::Rect::apply_transform((int8x16_t *)a2, (const CA::Transform *)v31, v17);
    return 0;
  }
  else
  {
    if ((v7 & 1) == 0)
    {
      CA::BoundsImpl::scale((double *)a2, v27, v28);
      if (a4)
      {
        float64x2_t v19 = (float64x2_t)vdupq_n_s64(0x412E848000000000uLL);
        __asm { FMOV            V3.2D, #0.5 }
        float64x2_t v24 = vrndmq_f64(vmlaq_f64(_Q3, v19, *(float64x2_t *)a2));
        float64x2_t v25 = vrndmq_f64(vmlaq_f64(_Q3, v19, *(float64x2_t *)(a2 + 16)));
        float64x2_t v26 = (float64x2_t)vdupq_n_s64(0x3EB0C6F7A0B5ED8DuLL);
        *(float64x2_t *)a2 = vmulq_f64(v24, v26);
        *(float64x2_t *)(a2 + 16) = vmulq_f64(v25, v26);
      }
    }
    *(float64x2_t *)a2 = vaddq_f64(*(float64x2_t *)a2, v29);
    return 1;
  }
}

uint64_t CA::Render::compute_gravity_transform(unsigned int a1, double *a2, float64x2_t *a3, uint64_t a4, uint64_t a5)
{
  switch(a1)
  {
    case 0u:
    case 1u:
    case 2u:
      __asm { FMOV            V0.2D, #1.0; jumptable 0000000184679500 cases 0-2 }
      *(_OWORD *)a5 = _Q0;
      double v10 = *a2 + (a2[2] - a3->f64[0]) * 0.5;
      goto LABEL_5;
    case 3u:
    case 5u:
    case 7u:
      __asm { FMOV            V0.2D, #1.0; jumptable 0000000184679500 cases 3,5,7 }
      *(_OWORD *)a5 = _Q0;
      double v10 = *a2;
      goto LABEL_5;
    case 4u:
    case 6u:
    case 8u:
      __asm { FMOV            V0.2D, #1.0; jumptable 0000000184679500 cases 4,6,8 }
      *(_OWORD *)a5 = _Q0;
      double v10 = a2[2] + *a2 - a3->f64[0];
LABEL_5:
      *(double *)a4 = v10;
      *(void *)(a4 + 8) = 0;
      char v13 = 1;
      if (a1 > 8) {
        return v13 & 1;
      }
      if (((1 << a1) & 0x19) != 0)
      {
        double v14 = a2[1] + (a2[3] - a3->f64[1]) * 0.5;
      }
      else if (((1 << a1) & 0x62) != 0)
      {
        double v14 = a2[3] + a2[1] - a3->f64[1];
      }
      else
      {
        double v14 = a2[1];
      }
      char v13 = 1;
      break;
    case 0xAu:
      double v19 = a2[2];
      double v20 = a2[3];
      double v21 = v19 / a3->f64[0];
      if (v21 >= v20 / a3->f64[1]) {
        double v21 = v20 / a3->f64[1];
      }
      goto LABEL_18;
    case 0xBu:
      double v19 = a2[2];
      double v20 = a2[3];
      double v21 = v19 / a3->f64[0];
      if (v21 <= v20 / a3->f64[1]) {
        double v21 = v20 / a3->f64[1];
      }
LABEL_18:
      *(double *)a5 = v21;
      *(double *)(a5 + 8) = v21;
      double v22 = a3->f64[1];
      double v23 = a2[1];
      *(double *)a4 = *a2 + (v19 - a3->f64[0] * v21) * 0.5;
      char v13 = v21 == 1.0;
      double v14 = v23 + (v20 - v21 * v22) * 0.5;
      break;
    default:
      float64x2_t v15 = *(float64x2_t *)(a2 + 2);
      int64x2_t v16 = vceqq_f64(v15, *a3);
      int32x2_t v17 = vmovn_s64(v16);
      __asm { FMOV            V1.2D, #1.0 }
      char v13 = v17.i8[4] & v17.i8[0];
      *(int8x16_t *)a5 = vbslq_s8((int8x16_t)v16, _Q1, (int8x16_t)vdivq_f64(v15, *a3));
      double v14 = a2[1];
      *(double *)a4 = *a2;
      break;
  }
  *(double *)(a4 + 8) = v14;
  return v13 & 1;
}

double CA::BoundsImpl::scale(double *a1, double result, double a3)
{
  if (result != 1.0)
  {
    double v3 = a1[2];
    if (v3 < 1.79769313e308)
    {
      *a1 = *a1 * result;
      uint64_t result = v3 * result;
      a1[2] = result;
    }
  }
  if (a3 != 1.0)
  {
    uint64_t result = a1[3];
    if (result < 1.79769313e308)
    {
      a1[1] = a1[1] * a3;
      uint64_t result = result * a3;
      a1[3] = result;
    }
  }
  return result;
}

float64x2_t CA::Transform::scale_2d(CA::Transform *this, float64x2_t result)
{
  if (result.f64[0] != 1.0)
  {
    char v2 = *((unsigned char *)this + 144);
    if ((v2 & 0x10) != 0)
    {
      float64x2_t v5 = vmulq_n_f64(*(float64x2_t *)this, result.f64[0]);
      float64x2_t v6 = vmulq_n_f64(*((float64x2_t *)this + 1), result.f64[0]);
      float64x2_t v7 = vmulq_n_f64(*((float64x2_t *)this + 2), result.f64[0]);
      uint64_t result = vmulq_n_f64(*((float64x2_t *)this + 3), result.f64[0]);
      *(float64x2_t *)this = v5;
      *((float64x2_t *)this + 1) = v6;
      *((float64x2_t *)this + 2) = v7;
      *((float64x2_t *)this + 3) = result;
    }
    else
    {
      double v3 = *((double *)this + 16) * result.f64[0];
      double v4 = *((double *)this + 17) / result.f64[0];
      *((double *)this + 16) = v3;
      *((double *)this + 17) = v4;
      *((unsigned char *)this + 144) = v2 & 0xF7 | (8 * (v3 != 1.0));
      *(float64x2_t *)this = vmulq_n_f64(*(float64x2_t *)this, result.f64[0]);
      uint64_t result = vmulq_n_f64(*((float64x2_t *)this + 2), result.f64[0]);
      *((float64x2_t *)this + 2) = result;
    }
  }
  return result;
}

_DWORD *CA::OGL::prepare_compositing_filter(_DWORD *result, int8x8_t *a2, uint64_t a3, char a4)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  int v5 = *(_DWORD *)(a3 + 24);
  if (v5 <= 390)
  {
    if (v5 <= 217)
    {
      switch(v5)
      {
        case 162:
          char v7 = 30;
          goto LABEL_101;
        case 163:
          char v6 = 49;
          goto LABEL_105;
        case 164:
        case 165:
        case 166:
        case 174:
        case 175:
        case 176:
        case 177:
        case 178:
        case 179:
        case 180:
        case 181:
        case 182:
        case 183:
        case 184:
          goto LABEL_102;
        case 167:
          char v6 = 2;
          goto LABEL_105;
        case 168:
          char v15 = 10;
          goto LABEL_73;
        case 169:
          char v16 = 8;
          goto LABEL_93;
        case 170:
        case 171:
          char v6 = 9;
          goto LABEL_105;
        case 172:
          char v7 = 7;
          goto LABEL_101;
        case 173:
          char v7 = 36;
          goto LABEL_101;
        case 185:
          char v7 = 38;
          goto LABEL_101;
        default:
          switch(v5)
          {
            case 'Z':
              a2[5].i16[1] = a2[5].u8[3] << 8;
              goto LABEL_94;
            case '[':
            case '\\':
            case ']':
            case '_':
            case 'a':
              goto LABEL_102;
            case '^':
              char v7 = 53;
              goto LABEL_101;
              char v7 = 33;
              goto LABEL_101;
            case 'b':
              char v7 = 32;
              goto LABEL_101;
            default:
              if (v5 != 142) {
                goto LABEL_102;
              }
              char v15 = 1;
              break;
          }
          goto LABEL_73;
      }
    }
    if (v5 > 359)
    {
      if (v5 <= 361)
      {
        if (v5 == 360) {
          char v7 = 39;
        }
        else {
          char v7 = 19;
        }
        goto LABEL_101;
      }
      switch(v5)
      {
        case 362:
          char v7 = 40;
          goto LABEL_101;
        case 371:
          char v7 = 54;
          goto LABEL_101;
        case 384:
          char v7 = 18;
          goto LABEL_101;
      }
    }
    else if (v5 <= 263)
    {
      if (v5 == 218)
      {
        char v7 = 20;
        goto LABEL_101;
      }
      if (v5 == 254)
      {
        char v7 = 35;
        goto LABEL_101;
      }
    }
    else
    {
      switch(v5)
      {
        case 264:
          char v7 = 51;
          goto LABEL_101;
        case 350:
          char v7 = 31;
          goto LABEL_101;
        case 351:
          char v7 = 50;
LABEL_101:
          a2[5].i8[2] = v7;
          goto LABEL_102;
      }
    }
    goto LABEL_102;
  }
  if (v5 > 514)
  {
    if (v5 <= 549)
    {
      switch(v5)
      {
        case 515:
          char v7 = 34;
          goto LABEL_101;
        case 516:
        case 517:
        case 519:
        case 521:
        case 522:
          goto LABEL_102;
        case 518:
          char v6 = 6;
          goto LABEL_105;
        case 520:
          char v16 = 4;
          goto LABEL_93;
        case 523:
          char v15 = 5;
          goto LABEL_73;
        case 524:
          goto LABEL_104;
        default:
          if (v5 == 548)
          {
            char v7 = 37;
            goto LABEL_101;
          }
          if (v5 == 549)
          {
            char v15 = 14;
LABEL_73:
            a2[5].i8[2] = v15;
            *(void *)&a2[4] |= 0x200000uLL;
          }
          break;
      }
      goto LABEL_102;
    }
    if ((v5 - 593) <= 0x10)
    {
      if (((1 << (v5 - 81)) & 0x6C) != 0)
      {
        uint64_t v8 = *(CA::Render::KeyValueArray **)(a3 + 40);
        float32x4_t v28 = 0uLL;
        int float_color_key = CA::Render::KeyValueArray::get_float_color_key(v8, 287, &v28);
        int8x8_t v10 = (int8x8_t)vcvt_f16_f32(v28);
        if (float_color_key) {
          unsigned int v11 = -1;
        }
        else {
          unsigned int v11 = 0;
        }
        a2[8] = vbsl_s8((int8x8_t)vdup_n_s16(v11), v10, (int8x8_t)0x3C003C003C003C00);
        uint64_t result = (_DWORD *)CA::Render::KeyValueArray::get_float_color_key(v8, 288, &v28);
        int8x8_t v12 = (int8x8_t)vcvt_f16_f32(v28);
        if (result) {
          unsigned int v13 = -1;
        }
        else {
          unsigned int v13 = 0;
        }
        a2[9] = vbsl_s8((int8x8_t)vdup_n_s16(v13), v12, (int8x8_t)0x3C003C003C003C00);
        if ((v5 - 595) > 4) {
          __int16 v14 = 3;
        }
        else {
          __int16 v14 = word_18499B0AA[v5 - 595];
        }
        a2[5].i16[1] = v14 | (a2[5].u8[3] << 8);
        goto LABEL_106;
      }
      if (v5 == 593)
      {
        if ((a4 & 1) == 0)
        {
          long long v31 = 0u;
          long long v32 = 0u;
          long long v29 = 0u;
          long long v30 = 0u;
          float32x4_t v28 = 0u;
          CA::OGL::get_filter_color_matrix(*(CA::OGL **)(a3 + 40), (const CA::Render::Filter *)&v28, (CA::ColorMatrix *)a3);
          uint64_t result = malloc_type_malloc(0x50uLL, 0x100004052888210uLL);
          __int32 v18 = v28.i32[1];
          uint64_t v19 = v29;
          *uint64_t result = v28.i32[0];
          result[1] = HIDWORD(v19);
          int v20 = HIDWORD(v30);
          uint64_t v21 = *((void *)&v31 + 1);
          result[2] = DWORD2(v30);
          result[3] = HIDWORD(v21);
          uint64_t v22 = *((void *)&v29 + 1);
          result[4] = v18;
          result[5] = v22;
          uint64_t v23 = v32;
          result[6] = v20;
          result[7] = v23;
          __int32 v24 = v28.i32[3];
          result[8] = v28.i32[2];
          result[9] = HIDWORD(v22);
          int v25 = DWORD1(v31);
          result[10] = v31;
          result[11] = HIDWORD(v23);
          uint64_t v26 = v30;
          result[12] = v24;
          result[13] = v26;
          uint64_t v27 = *((void *)&v32 + 1);
          result[14] = v25;
          result[15] = v27;
          result[16] = v19;
          result[17] = HIDWORD(v26);
          result[18] = v21;
          result[19] = HIDWORD(v27);
          a2[11] = (int8x8_t)result;
          a2[5].i16[0] |= 0x20u;
        }
        char v6 = 42;
        goto LABEL_105;
      }
      if (v5 == 609)
      {
        char v7 = 11;
        goto LABEL_101;
      }
    }
    if (v5 == 550)
    {
      char v6 = 13;
LABEL_105:
      a2[5].i8[2] = v6;
      goto LABEL_106;
    }
    goto LABEL_102;
  }
  if (v5 > 423)
  {
    if (v5 <= 432)
    {
      if (v5 == 424)
      {
        char v7 = 41;
        goto LABEL_101;
      }
      if (v5 == 431)
      {
        char v7 = 26;
        goto LABEL_101;
      }
    }
    else
    {
      switch(v5)
      {
        case 433:
          a2[5].i8[2] = 12;
          uint64_t result = (_DWORD *)(*(uint64_t (**)(void, uint64_t))(**(void **)result + 184))(*(void *)result, 33);
          if (result)
          {
            int8x8_t v17 = a2[2];
            if (!*(void *)&v17 || (*(unsigned char *)(*(void *)&v17 + 25) & 4) == 0)
            {
              char v7 = 56;
              goto LABEL_101;
            }
          }
          break;
        case 485:
          char v7 = 52;
          goto LABEL_101;
        case 490:
          char v7 = 16;
          goto LABEL_101;
      }
    }
    goto LABEL_102;
  }
  if (v5 > 394)
  {
    switch(v5)
    {
      case 395:
        char v7 = 28;
        goto LABEL_101;
      case 403:
LABEL_104:
        char v6 = 3;
        goto LABEL_105;
      case 418:
        char v7 = 29;
        goto LABEL_101;
    }
LABEL_102:
    if ((a2[4].i8[3] & 0x20) == 0 || (*(void *)(*(void *)&a2[1] + 32) & 0x300807920) != 0x800000) {
      goto LABEL_106;
    }
    goto LABEL_104;
  }
  if (v5 == 391)
  {
    char v16 = 17;
  }
  else
  {
    if (v5 != 394) {
      goto LABEL_102;
    }
    char v16 = 15;
  }
LABEL_93:
  a2[5].i8[2] = v16;
LABEL_94:
  *(void *)&a2[4] |= 0x200000uLL;
LABEL_106:
  if (a2[5].i8[2] != 3) {
    *(void *)&a2[4] |= 0x100000uLL;
  }
  return result;
}

uint64_t CA::OGL::prepare_layer_image(CA::OGL::Renderer &,CA::OGL::Layer *,CA::OGL::Gstate const&)::visitor::visit_subclass(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 16);
  uint64_t v3 = *(void *)(*(void *)(v2 + 16) + 256);
  if (v3)
  {
    int v5 = *(_DWORD *)(v3 + 56);
    int v4 = *(_DWORD *)(v3 + 60);
    if (v5 < v4) {
      int v4 = v5;
    }
    if (v4 >= 1)
    {
      int v6 = *(_DWORD *)(a2 + 12);
      if ((v6 & 0x100) != 0)
      {
        *(void *)(v2 + 32) |= 0x4000uLL;
        int v6 = *(_DWORD *)(a2 + 12);
      }
      if ((v6 & 0x500) != 0) {
        *(_WORD *)(v2 + 40) |= 8u;
      }
    }
  }
  if ((*(unsigned char *)(a2 + 13) & 0x10) != 0) {
    *(void *)(v2 + 32) |= 0x8000uLL;
  }
  return result;
}

{
  if (*(unsigned char *)(a2 + 16) == 3) {
    *(void *)(*(void *)(result + 16) + 32) |= 0x4000uLL;
  }
  return result;
}

{
  if (*(float *)(a2 + 28) > 0.0) {
    *(void *)(*(void *)(result + 16) + 32) = *(void *)(*(void *)(result + 16) + 32) & 0xFFFFFFFFFFFFBFDFLL | 0x4000;
  }
  return result;
}

uint64_t CA::OGL::LayerNode::layer_node_p(CA::OGL::LayerNode *this)
{
  return 1;
}

int8x8_t CA::OGL::quad_node(uint64_t a1, uint64_t a2, uint64_t a3, char a4, char a5, __int16 a6, float a7)
{
  uint64_t v14 = *(void *)(a1 + 72);
  if (v14) {
    *(void *)(a1 + 72) = *(void *)v14;
  }
  else {
    uint64_t v14 = x_heap_malloc_small_(*(uint64_t **)(a1 + 56), 0xF8uLL);
  }
  *(void *)(v14 + 8) = a1;
  *(void *)(v14 + 16) = a2;
  *(void *)(v14 + 48) = 0;
  *(void *)(v14 + 192) = 0;
  *(void *)(v14 + 200) = 0;
  *(_DWORD *)(v14 + 208) = 0;
  *(_WORD *)(v14 + 212) = *(_WORD *)(v14 + 212) & 0xC000 | 1;
  *(void *)(v14 + 24) = a3;
  *(void *)(v14 + 32) = 0;
  *(_DWORD *)(v14 + 136) = -1;
  *(void *)uint64_t v14 = &unk_1ED02C110;
  *(_WORD *)(v14 + 224) = a4 & 0xF | (16 * a5) | (a6 << 8);
  *(float *)(v14 + 228) = a7;
  *(void *)(v14 + 88) = 0x3C003C003C003C00;
  *(void *)(v14 + 96) = 0;
  *(void *)(v14 + 104) = 0;
  __int16 v15 = *(_WORD *)(v14 + 124);
  *(void *)(v14 + 112) = 0;
  *(_OWORD *)(v14 + 56) = 0u;
  *(_OWORD *)(v14 + 72) = 0u;
  *(_DWORD *)(v14 + 120) = 1065353216;
  *(_WORD *)(v14 + 124) = v15 & 0xF800 | 0x401;
  int8x8_t result = vorr_s8(vand_s8(*(int8x8_t *)(v14 + 216), (int8x8_t)0xFC000000FFC00000), (int8x8_t)0x1000800000000FLL);
  *(int8x8_t *)(v14 + 216) = result;
  return result;
}

uint16x4_t CA::OGL::prepare_layer_image(CA::OGL::Renderer &,CA::OGL::Layer *,CA::OGL::Gstate const&)::visitor::visit_subclass(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  BOOL v3 = *(float *)(a2 + 24) == 0.0;
  if (*(float *)(a2 + 28) != 0.0) {
    BOOL v3 = 0;
  }
  if (*(float *)(a2 + 32) != 0.0) {
    BOOL v3 = 0;
  }
  if (*(float *)(a2 + 36) != 0.0) {
    BOOL v3 = 0;
  }
  uint16x4_t result = (uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqzq_f32(*(float32x4_t *)(a2 + 48))));
  result.i16[0] = vmaxv_u16(result);
  if ((result.i8[0] & 1) == 0 || (uint16x4_t result = *(uint16x4_t *)(a2 + 88), *(double *)&result == 0.0))
  {
    if (!v3) {
      *(void *)(v2 + 32) |= 0x2000uLL;
    }
  }
  else
  {
    uint64_t v5 = *(void *)(v2 + 32);
    *(void *)(v2 + 32) = v5 | 0x2000;
    if (!v3)
    {
      *(void *)(v2 + 32) = v5 | 0x22000;
      *(_WORD *)(v2 + 40) |= 2u;
    }
  }
  if (*(void *)(a2 + 40) || (uint16x4_t result = *(uint16x4_t *)(a2 + 88), *(double *)&result != 0.0) && *(void *)(a2 + 64)) {
    *(_DWORD *)(*(void *)(v2 + 104) + 220) |= 0x100000u;
  }
  return result;
}

uint64_t CA::OGL::FilterNode::needs_surface(CA::OGL::FilterNode *this)
{
  uint64_t v2 = *((void *)this + 29);
  BOOL v3 = (void *)*((void *)this + 1);
  uint64_t v4 = *((void *)this + 2);
  __int16 v5 = *((_WORD *)this + 62);
  if (v5 & 0xF0) == 0 && ((0xC533u >> v5)) {
    goto LABEL_15;
  }
  uint64_t v6 = *(void *)(v2 + 16);
  if (!v6)
  {
    if (*(void *)(v2 + 48))
    {
      int v8 = 1;
      return v8 ^ 1u;
    }
LABEL_15:
    int v8 = 0;
    return v8 ^ 1u;
  }
  uint64_t v7 = *(void *)(v6 + 48);
  if (v7 && (*(unsigned int (**)(void))(*(void *)v7 + 72))(*(void *)(v6 + 48)))
  {
    int v8 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, char *))(*(void *)v7 + 88))(v7, v6, *(void *)(v4 + 24), *v3, (char *)this + 56);
    return v8 ^ 1u;
  }
  int v9 = *(_DWORD *)(v6 + 24);
  int v8 = 1;
  if (v9 <= 58)
  {
    if (v9 != 23 && v9 != 25) {
      return v8 ^ 1u;
    }
LABEL_19:
    int v11 = *((unsigned __int8 *)this + 124);
    int v8 = v11 != 12 && (v11 - 1) < 0x19;
    return v8 ^ 1u;
  }
  if (v9 == 262) {
    goto LABEL_19;
  }
  if (v9 == 59) {
    int v8 = *((void *)this + 11) == 0x3C003C003C003C00;
  }
  return v8 ^ 1u;
}

BOOL CA::OGL::BlurFilter::can_render(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return *(void *)(a5 + 16) == 0;
}

BOOL CA::OGL::BlurFilter::is_opacity_commutative(CA::OGL::BlurFilter *this, CA::Render::KeyValueArray **a2)
{
  return CA::Render::KeyValueArray::get_int_key(a2[5], 305, 0) == 0;
}

BOOL CA::OGL::MaskNode::needs_surface(CA::OGL::MaskNode *this)
{
  return *((void *)this + 3) == 0;
}

uint64_t CA::OGL::ImagingNode::layer_node_p(CA::OGL::ImagingNode *this)
{
  return 0;
}

BOOL CA::OGL::ShadowNode::needs_surface(CA::OGL::ShadowNode *this, char a2)
{
  if ((a2 & 1) == 0
    && ((uint64_t v3 = *(void *)(*((void *)this + 2) + 24), (*(unsigned char *)(v3 + 44) & 4) != 0)
     || (uint64_t v4 = *(void *)(v3 + 128)) != 0 && *(void *)(v4 + 120)))
  {
    return *((unsigned char *)this + 124) != 3;
  }
  else
  {
    return 1;
  }
}

uint64_t CA::OGL::Renderer::add_clip_plane(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void *)(a1 + 80);
  if (result) {
    *(void *)(a1 + 80) = *(void *)result;
  }
  else {
    uint64_t result = x_heap_malloc_small_(*(uint64_t **)(a1 + 56), 0x20uLL);
  }
  *(void *)(a2 + 128) = result;
  ++*(_WORD *)(a2 + 296);
  uint64_t v5 = *(void *)(a2 + 104);
  uint64_t v6 = *(void *)(v5 + 72);
  if (v6) {
    int v7 = *(_DWORD *)(v6 + 8) + 1;
  }
  else {
    int v7 = 1;
  }
  *(_DWORD *)(result + 8) = v7;
  *(void *)uint64_t result = v6;
  *(void *)(v5 + 72) = result;
  return result;
}

CA::Render::Update *CA::Render::Update::Update(CA::Render::Update *this, void *a2, unint64_t a3, double a4, const CVTimeStamp *a5, unsigned int a6, int a7, int a8, const CA::Bounds *a9, unsigned int a10)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 8) = 0u;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *((void *)this + 19) = 0;
  *((_OWORD *)this + 12) = *(_OWORD *)a9;
  unsigned int v13 = (unsigned int *)((char *)this + 192);
  uint64_t v14 = (unsigned int *)((char *)this + 1084);
  *((double *)this + 9) = a4;
  *((void *)this + 10) = 0x7FF0000000000000;
  *((double *)this + 13) = a4;
  *((void *)this + 14) = 0x3F91111111111111;
  *((void *)this + 20) = a5;
  *((void *)this + 21) = 0;
  *((void *)this + 22) = -1;
  *((void *)this + 23) = 0;
  *((void *)this + 26) = 0;
  if (!a6) {
    a6 = atomic_fetch_add(&CA::Render::Update::_update_counter, 1u) + 1;
  }
  *((_DWORD *)this + 62) = a6;
  *((_DWORD *)this + 63) = a7;
  *((_DWORD *)this + 64) = a8;
  *((_DWORD *)this + 65) = CA::Render::LayerHost::_seed[0];
  *((void *)this + 33) = 0;
  *((_DWORD *)this + 68) = a10;
  *((void *)this + 35) = 0;
  *((_OWORD *)this + 18) = 0uLL;
  *((void *)this + 38) = -1;
  *((_DWORD *)this + 90) = 0;
  *(_OWORD *)((char *)this + 312) = 0uLL;
  *(_OWORD *)((char *)this + 328) = 0uLL;
  *(_OWORD *)((char *)this + 344) = 0uLL;
  *(_OWORD *)((char *)this + 364) = xmmword_184997E20;
  *((_DWORD *)this + 95) = 1065353216;
  *((_OWORD *)this + 24) = xmmword_184997E30;
  *((_WORD *)this + 204) = 0;
  *((void *)this + 50) = 0;
  *(void *)((char *)this + 412) = 0x100000001;
  *(_OWORD *)((char *)this + 420) = 0uLL;
  *(_OWORD *)((char *)this + 436) = 0uLL;
  *((unsigned char *)this + 452) = 0;
  *((_DWORD *)this + 114) = 1065353216;
  *(_OWORD *)((char *)this + 460) = 0uLL;
  *((_DWORD *)this + 119) = -1;
  *((void *)this + 63) = 0;
  *((_DWORD *)this + 128) = 0;
  *(_OWORD *)((char *)this + 484) = 0uLL;
  *((void *)this + 65) = 1;
  *((void *)this + 66) = 1;
  *(_OWORD *)((char *)this + 536) = 0uLL;
  *((void *)this + 69) = (char *)this + 584;
  *((void *)this + 70) = (char *)this + 584;
  *((void *)this + 71) = (char *)this + 584;
  *((_OWORD *)this + 36) = 0uLL;
  *((_OWORD *)this + 37) = 0uLL;
  *((_OWORD *)this + 46) = 0uLL;
  *((_OWORD *)this + 47) = 0uLL;
  *((void *)this + 106) = 0;
  *((void *)this + 105) = 0;
  *((_OWORD *)this + 48) = xmmword_184998170;
  *((_OWORD *)this + 49) = 0uLL;
  *((_OWORD *)this + 50) = 0uLL;
  *((_OWORD *)this + 51) = 0uLL;
  *((void *)this + 104) = (char *)this + 840;
  *((void *)this + 109) = 0;
  *((void *)this + 108) = 0;
  *((void *)this + 107) = (char *)this + 864;
  *((void *)this + 114) = 0;
  *((_OWORD *)this + 55) = 0uLL;
  *((_OWORD *)this + 56) = 0uLL;
  *((void *)this + 115) = (char *)this + 952;
  *((void *)this + 116) = (char *)this + 952;
  *((void *)this + 117) = (char *)this + 952;
  *((void *)this + 118) = 16;
  *((void *)this + 133) = 0;
  *(_OWORD *)((char *)this + 1032) = 0uLL;
  *(_OWORD *)((char *)this + 1048) = 0uLL;
  *(_OWORD *)((char *)this + 1016) = 0uLL;
  unint64_t v15 = *((unsigned int *)this + 271) | ((unint64_t)*((unsigned __int16 *)this + 544) << 32);
  *((void *)this + 134) = 0x3F8000007F800000;
  v15 &= 0xFFFFF80000000020;
  *((_DWORD *)this + 270) = 0;
  unint64_t v16 = v15 | (a10 >> 4) & 0x100000 ^ 0x140000;
  *((_WORD *)this + 544) = WORD2(v15);
  unsigned int *v14 = v16;
  if (BYTE12(xmmword_1EB2ACC50))
  {
    uint64_t v17 = 0;
  }
  else
  {
    if (CA::CAPSEProcessor::needs_processing(this)) {
      uint64_t v17 = 0x80000000000;
    }
    else {
      uint64_t v17 = 0;
    }
    unint64_t v16 = *v14 | ((unint64_t)*((unsigned __int16 *)v14 + 2) << 32);
  }
  uint64_t v18 = v16 & 0xC7FFFFFFFFFFLL | v17;
  unsigned int *v14 = v18;
  *((_WORD *)v14 + 2) = WORD2(v18);
  if (a2 && a3 > 0x1F)
  {
    *a2 = 0;
    a2[1] = a2 + 4;
    a2[2] = a3 - 32;
    a2[3] = 0x2000;
    *(void *)this = a2;
  }
  else
  {
    uint64_t v19 = x_heap_new(0x2000uLL);
    *(void *)this = v19;
    if (!v19) {
      return this;
    }
  }
  if (initialized != -1) {
    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
  }
  unsigned int v20 = byte_1EB2ACC0D;
  if (byte_1EB2ACC0D) {
    unsigned int v20 = *(float *)&dword_1EB2ACB80;
  }
  *((_DWORD *)this + 120) = v20;
  *((void *)this + 27) = (char *)this + 216;
  *((void *)this + 28) = (char *)this + 216;
  *((void *)this + 30) = 0;
  if (BYTE11(xmmword_1EB2ACBF0) | BYTE12(ca_debug_options)) {
    unint64_t v21 = CA::Shape::new_shape(v13);
  }
  else {
    unint64_t v21 = 1;
  }
  *((void *)this + 2) = v21;
  *((void *)this + 4) = 1;
  *((void *)this + 5) = 1;
  *((void *)this + 6) = 1;
  *((void *)this + 7) = 1;
  *((void *)this + 8) = 1;
  *((_DWORD *)this + 103) = 0;
  memset(v23, 0, sizeof(v23));
  int v24 = 1065353216;
  std::vector<std::unordered_map<void *,CA::Render::LayerNode *>>::push_back[abi:nn180100]((uint64_t *)this + 100, (uint64_t *)v23);
  std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)v23);
  return this;
}

uint64_t CA::CAPSEProcessor::needs_processing(CA::CAPSEProcessor *this)
{
  if (CA::CAPSEProcessor::needs_processing(void)::once[0] != -1) {
    dispatch_once(CA::CAPSEProcessor::needs_processing(void)::once, &__block_literal_global_9941);
  }
  if (!CA::CAPSEProcessor::needs_processing(void)::has_class) {
    return 0;
  }
  unint64_t v1 = (void *)MEMORY[0x1E4F91378];

  return [v1 needsProcessing];
}

void *x_heap_new(unint64_t a1)
{
  uint64_t v1 = 2048;
  if (a1 > 0x800) {
    uint64_t v1 = a1;
  }
  if (a1) {
    size_t v2 = v1;
  }
  else {
    size_t v2 = 0x4000;
  }
  uint64_t v3 = malloc_type_malloc(v2, 0xF92BB69DuLL);
  if (v3)
  {
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    uint64_t v5 = malloc_type_zone_malloc(malloc_zone, 0x10uLL, 0x8BB15036uLL);
    *uint64_t v5 = v3;
    v5[1] = 0;
    *uint64_t v3 = v5;
    v3[1] = v3 + 4;
    v3[2] = v2 - 32;
    v3[3] = v2;
  }
  return v3;
}

void CA::Render::Updater::prepare_replicator(uint64_t a1, uint64_t a2, uint64_t a3, const double *a4)
{
  uint64_t v4 = (float *)a3;
  uint64_t v95 = *MEMORY[0x1E4F143B8];
  float v7 = *(float *)(a3 + 32);
  uint64_t v8 = *(void *)(*(void *)(*(void *)a2 + 32) + 128);
  if (v8 && (uint64_t v9 = *(void *)(v8 + 8)) != 0)
  {
    char v85 = 0;
    uint64_t v82 = v9;
    double v84 = *(double *)(v9 + 32);
  }
  else
  {
    uint64_t v82 = 0;
    char v85 = 1;
    double v84 = INFINITY;
  }
  double v10 = v7;
  float v11 = *(float *)(a2 + 56);
  if (v11 != 0.0)
  {
    if (v7 <= 0.0)
    {
      if (v7 >= 0.0 || v84 >= INFINITY) {
        goto LABEL_29;
      }
      double v12 = v84 - *(double *)(a2 + 16);
    }
    else
    {
      double v12 = *(double *)(a2 + 16);
    }
    double v14 = v12 / v10;
    double v15 = ceil(v14);
    double v16 = floor(v14);
    if (v11 > 0.0) {
      double v16 = v15;
    }
    if (v16 < (double)*(int *)(a3 + 16))
    {
      double v17 = v16 * v10;
      if (v7 <= 0.0) {
        double v18 = v84 - v17;
      }
      else {
        double v18 = v17;
      }
      double v19 = *(double *)(a2 + 32);
      *(void *)(a2 + 48) |= 0x10000000000uLL;
      if (v19 >= INFINITY)
      {
        BOOL v20 = v19 != v18;
      }
      else if (v11 <= 0.0)
      {
        if (v19 > v18) {
          goto LABEL_29;
        }
        BOOL v20 = v19 < v18;
      }
      else
      {
        if (v19 < v18) {
          goto LABEL_29;
        }
        BOOL v20 = v19 > v18;
      }
      _ZF = v18 == 0.0 || !v20;
      uint64_t v21 = 0x10000000000;
      if (_ZF) {
        uint64_t v21 = *(void *)(a2 + 40) | 0x10000000000;
      }
      *(void *)(a2 + 40) = v21;
      *(double *)(a2 + 32) = v18;
    }
  }
LABEL_29:
  memset(&v94[16], 0, 32);
  *(_OWORD *)double v94 = 0u;
  uint64_t v92 = a3;
  v93[0] = xmmword_184997D50;
  v93[1] = 0u;
  v93[2] = xmmword_184997D60;
  memset(&v93[3], 0, 32);
  v93[5] = xmmword_184997D50;
  v93[6] = 0u;
  v93[7] = xmmword_184997D60;
  __asm { FMOV            V3.2D, #1.0 }
  v93[8] = _Q3;
  int8x16_t v25 = (int8x16_t)vcvtq_f64_f32(*(float32x2_t *)(a3 + 36));
  int8x16_t v26 = (int8x16_t)vcvtq_f64_f32(*(float32x2_t *)(a3 + 44));
  *(int8x16_t *)&v94[8] = v25;
  *(int8x16_t *)&v94[24] = v26;
  *(void *)(a2 + 96) = &v92;
  uint64_t v27 = (void *)(a2 + 40);
  uint64_t v83 = *(void *)(a2 + 40);
  double v28 = *(double *)(a2 + 24);
  double v86 = *(double *)(a2 + 32);
  uint64_t v29 = *(void *)(a2 + 48);
  double v30 = *(double *)(a2 + 16);
  if (*(int *)(a3 + 16) <= 1) {
    int v31 = 1;
  }
  else {
    int v31 = *(_DWORD *)(a3 + 16);
  }
  uint64_t v32 = *(void *)(a3 + 24);
  if (v32)
  {
    unsigned int v33 = *(_DWORD *)(v32 + 16);
    uint64_t v34 = (long long *)(v32 + 24);
    if (v33 <= 0xF) {
      uint64_t v34 = &CA::Mat4Impl::mat4_identity_double;
    }
    long long v35 = v34[1];
    long long v36 = v34[2];
    long long v37 = v34[3];
    v89[0] = *v34;
    v89[1] = v35;
    v89[2] = v36;
    v89[3] = v37;
    long long v38 = v34[5];
    long long v39 = v34[6];
    long long v40 = v34[7];
    v89[4] = v34[4];
    v89[5] = v38;
    v89[6] = v39;
    v89[7] = v40;
    int8x16_t v87 = v25;
    int8x16_t v81 = v26;
    CA::Transform::set((uint64_t)v90, (CA::Mat4Impl *)v89, 1);
    int8x16_t v26 = v81;
    int8x16_t v25 = v87;
  }
  else
  {
    v90[0] = (float64x2_t)xmmword_184997D50;
    v90[1] = 0uLL;
    v90[2] = (float64x2_t)xmmword_184997D60;
    memset(&v90[3], 0, 32);
    v90[5] = (float64x2_t)xmmword_184997D50;
    v90[6] = 0uLL;
    v90[7] = (float64x2_t)xmmword_184997D60;
    v90[8] = _Q3;
    char v91 = 0;
  }
  int v41 = 0;
  double v42 = *(double *)&v26.i64[1];
  *(_DWORD *)&v94[40] = 0;
  float64x2_t v43 = (float64x2_t)vextq_s8(v25, v26, 8uLL);
  __asm { FMOV            V2.2D, #0.5 }
  float64x2_t v88 = _Q2;
  double v45 = 0.0;
  do
  {
    double v46 = v42 * 255.0;
    int v47 = (int)vmlad_n_f64(0.5, v46, v43.f64[0]);
    int v48 = v47 & ~(v47 >> 31);
    if (v48 >= 255) {
      int v48 = 255;
    }
    *(void *)&v43.f64[0] = v25.i64[0];
    *(uint32x2_t *)&v43.f64[0] = vshl_u32((uint32x2_t)vmin_s32(vmax_s32(vmovn_s64(vcvtq_s64_f64(vmlaq_n_f64(v88, v43, v46))), 0), (int32x2_t)0xFF000000FFLL), (uint32x2_t)0x800000018);
    int v49 = LODWORD(v43.f64[0]) | (v48 << 16);
    int v50 = (int)(v46 + 0.5) & ~((int)(v46 + 0.5) >> 31);
    if (v50 >= 255) {
      int v50 = 255;
    }
    int v51 = v49 | v50 | HIDWORD(v43.f64[0]);
    *(_DWORD *)&v94[44] = v51;
    double v52 = v45 + v30;
    *(double *)(a2 + 16) = v45 + v30;
    *(double *)(a2 + 24) = v45 + v28;
    if (v45 + v30 >= 0.0)
    {
      if (v52 >= v84)
      {
        double v52 = -1.0;
        if ((v85 & 1) == 0)
        {
          double v52 = v84 + -0.000001;
          if ((*(unsigned char *)(v82 + 13) & 2) == 0) {
            double v52 = -1.0;
          }
        }
        *(double *)(a2 + 16) = v52;
      }
    }
    else
    {
      if (v85) {
        int v53 = 0;
      }
      else {
        int v53 = (*(unsigned __int8 *)(v82 + 13) >> 2) & 1;
      }
      double v52 = (double)(~v53 << 31 >> 31);
      *(double *)(a2 + 16) = v52;
      *(void *)(a2 + 72) |= 0x800uLL;
    }
    *(void *)(a2 + 32) = 0x7FF0000000000000;
    void *v27 = 0;
    *(void *)(a2 + 48) = 0;
    if (v41 || (v51 == -1 ? (_ZF = v52 == v30) : (_ZF = 0), !_ZF)) {
      ++*(_DWORD *)(a2 + 132);
    }
    if (*(_DWORD *)(a2 + 60) <= 0xC0u)
    {
      uint64_t v55 = *(void *)(*(void *)a2 + 32);
      if (!*(void *)(a2 + 96)
        && (uint64_t v68 = *(void *)(v55 + 128)) != 0
        && *(void *)v68
        && *(unsigned char *)(*(void *)v68 + 12) == 44)
      {
        CA::Render::Updater::prepare_replicator(a1, a2);
      }
      else
      {
        a3 = *(void *)(v55 + 104);
        if ((*(unsigned char *)(v55 + 13) & 0x20) != 0)
        {
          if (a3) {
            CA::Render::Updater::prepare_sublayer0((void *)a1, a2, a3);
          }
        }
        else if (a3)
        {
          uint64_t v56 = *(unsigned int *)(a3 + 16);
          if (v56)
          {
            double v57 = (uint64_t *)(a3 + 24);
            do
            {
              a3 = *v57;
              if (*v57) {
                CA::Render::Updater::prepare_sublayer0((void *)a1, a2, a3);
              }
              ++v57;
              --v56;
            }
            while (v56);
          }
        }
        uint64_t v58 = *(CA::Render::Context **)(a2 + 88);
        if (v58)
        {
          uint64_t v59 = CA::Render::Context::root_layer_handle(v58);
          if (v59)
          {
            a3 = *(void *)(v59 + 16);
            if (a3)
            {
              uint64_t v60 = *(void *)(*(void *)a2 + 24);
              uint64_t v61 = *(void *)(*(void *)a2 + 88);
              if (v61 && (*(unsigned char *)(v61 + 27) & 0x20) != 0) {
                *(void *)(*(void *)a2 + 24) = v60 | 0x4000000;
              }
              uint64_t v62 = v60 & 0x4000000;
              uint64_t v63 = *(void *)(a1 + 24);
              *(void *)(a1 + 24) = *(void *)(a2 + 88);
              CA::Render::Updater::prepare_sublayer0((void *)a1, a2, a3);
              *(void *)(*(void *)a2 + 24) = *(void *)(*(void *)a2 + 24) & 0xFFFFFFFFFBFFFFFFLL | v62;
              *(void *)(a1 + 24) = v63;
            }
          }
          if ((*(_DWORD *)(*(void *)a1 + 1084) & 4) == 0)
          {
            int8x8_t v64 = (CA::Shape **)CA::Render::Context::copy_dirty_shape(*(CA::Render::Context **)(a2 + 88));
            if (v64)
            {
              uint64_t v65 = (CA::Shape *)v64;
              CA::Render::Context::invalidate(*(CA::Render::Context **)(a1 + 16), v64, (const CA::Shape *)a3);
              CA::Shape::unref(v65);
              uint64_t v66 = *(void *)(a2 + 88);
              uint64_t v67 = *(CA::Shape **)(v66 + 576);
              if (v67) {
                CA::Shape::unref(v67);
              }
              *(void *)(v66 + 576) = 1;
            }
          }
        }
      }
    }
    double v69 = *(double *)(a2 + 32);
    if (v69 < INFINITY)
    {
      double v70 = v69 - v45;
      v29 |= *(void *)(a2 + 48);
      if (v86 >= v70)
      {
        BOOL v71 = v86 <= v70 || v70 == 0.0;
        uint64_t v72 = v83;
        if (!v71) {
          uint64_t v72 = 0;
        }
        uint64_t v83 = *v27 | v72;
        double v86 = v70;
      }
    }
    CA::Transform::concat_left((CA::Transform *)v93, v90, a3, a4);
    double v74 = *(double *)&v94[8] + v4[13];
    if (v74 >= 0.0) {
      double v75 = *(double *)&v94[8] + v4[13];
    }
    else {
      double v75 = 0.0;
    }
    if (v74 <= 1.0) {
      *(double *)v25.i64 = v75;
    }
    else {
      *(double *)v25.i64 = 1.0;
    }
    float v73 = v4[14];
    double v76 = *(double *)&v94[16] + v73;
    if (v76 >= 0.0) {
      double v77 = *(double *)&v94[16] + v73;
    }
    else {
      double v77 = 0.0;
    }
    if (v76 <= 1.0) {
      v43.f64[0] = v77;
    }
    else {
      v43.f64[0] = 1.0;
    }
    *(void *)&v94[8] = v25.i64[0];
    *(float64_t *)&v94[16] = v43.f64[0];
    double v78 = *(double *)&v94[24] + v4[15];
    double v42 = 1.0;
    double v79 = 1.0;
    if (v78 <= 1.0)
    {
      double v79 = 0.0;
      if (v78 >= 0.0) {
        double v79 = *(double *)&v94[24] + v4[15];
      }
    }
    *(double *)&v94[24] = v79;
    double v80 = v4[16];
    if (*(double *)&v94[32] + v80 <= 1.0)
    {
      double v42 = 0.0;
      if (*(double *)&v94[32] + v80 >= 0.0) {
        double v42 = *(double *)&v94[32] + v80;
      }
    }
    *(double *)&v94[32] = v42;
    int v41 = *(_DWORD *)&v94[40] + 1;
    *(_DWORD *)&v94[40] = v41;
    double v45 = v45 - v10;
    v43.f64[1] = v79;
  }
  while (v41 < v31);
  *(double *)(a2 + 24) = v28;
  *(double *)(a2 + 32) = v86;
  *(void *)(a2 + 40) = v83;
  *(void *)(a2 + 48) = v29;
  *(double *)(a2 + 16) = v30;
  *(void *)(a2 + 96) = 0;
}

void CA::Transform::set_affine(CA::Transform *this, double a2, double a3, double a4, double a5, double a6, double a7)
{
  if (a3 == 0.0 && a3 == a4)
  {
    CA::Transform::set_affine_rectilinear(this, a2, a5, a6, a7);
    return;
  }
  __asm { FMOV            V6.2D, #1.0 }
  *((_OWORD *)this + 8) = _Q6;
  char v12 = *((unsigned char *)this + 144) & 0xE0;
  if (a2 == 0.0 && a2 == a5)
  {
    double v15 = -a3;
    if (a3 >= 0.0) {
      double v15 = a3;
    }
    double v16 = -v15;
    if (v15 == a4) {
      int v17 = 7;
    }
    else {
      int v17 = 16;
    }
    if (v16 == a4) {
      unsigned int v18 = 5;
    }
    else {
      unsigned int v18 = v17;
    }
    if (v15 == a4) {
      int v19 = 6;
    }
    else {
      int v19 = 16;
    }
    if (v16 == a4) {
      int v19 = 4;
    }
    if (v15 == a3) {
      unsigned int v18 = v19;
    }
    char v20 = v12 | v18;
    *((unsigned char *)this + 144) = v20;
    if (v15 == 1.0 || v18 > 0xF) {
      goto LABEL_32;
    }
    *((double *)this + 16) = v15;
    *((double *)this + 17) = 1.0 / v15;
    char v14 = v20 | 8;
  }
  else
  {
    char v14 = v12 | 0x10;
  }
  *((unsigned char *)this + 144) = v14;
LABEL_32:
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = xmmword_184997D50;
  *((_OWORD *)this + 7) = xmmword_184997D60;
  *(double *)this = a2;
  *((double *)this + 1) = a3;
  *((double *)this + 4) = a4;
  *((double *)this + 5) = a5;
  *((double *)this + 12) = a6;
  *((double *)this + 13) = a7;
}

void CA::Render::Updater::prepare_portal(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v167 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a4 + 56);
  if (v4)
  {
    if ((*(unsigned char *)(v4 + 13) & 1) == 0)
    {
      unint64_t v5 = *(void *)(v4 + 48);
      if (v5)
      {
        uint64_t v7 = a3;
        int v9 = byte_1EB2ACC8E;
        uint64_t v10 = *a1;
        float v11 = (unsigned int *)(*a1 + 1084);
        int v136 = *v11;
        float v154 = 1.0;
        uint64_t v153 = 0;
        float64x2_t v165 = 0u;
        float64x2_t v166 = 0u;
        float64x2_t v163 = 0u;
        float64x2_t v164 = 0u;
        *(unsigned char *)(v4 + 213) = 0;
        if ((*(unsigned char *)(a4 + 13) & 0x20) != 0)
        {
          *(void *)(v10 + 96) |= 0x4000000000uLL;
          double v120 = *(double *)(v10 + 72);
          double v121 = *(double *)(v10 + 80);
          if (v121 >= v120)
          {
            if (v120 == 0.0 || v121 <= v120) {
              uint64_t v123 = *(void *)(v10 + 88) | 0x4000000000;
            }
            else {
              uint64_t v123 = 0x4000000000;
            }
            *(void *)(v10 + 88) = v123;
            *(double *)(v10 + 80) = v120;
          }
          *(void *)(a2 + 64) |= 0x10000007uLL;
          if ((*v11 & 4) == 0)
          {
            uint64_t v124 = a3;
            do
            {
              uint64_t v125 = v124;
              uint64_t v124 = *(void *)(v124 + 88);
            }
            while (v124);
            uint64_t v126 = *(void *)(v125 + 40);
            if (v126) {
              *(void *)(v126 + 96) |= 0x1000000000000000uLL;
            }
          }
          long long v161 = 0u;
          long long v162 = 0u;
          long long v159 = 0u;
          long long v160 = 0u;
          long long v157 = 0u;
          long long v158 = 0u;
          memset(buf, 0, sizeof(buf));
          matched = CA::Render::PortalState::match_cross_display_layer(v4, buf, &v154, &v153);
          if (matched)
          {
            uint64_t v32 = (uint64_t)matched;
            uint64_t v129 = *(void *)(*((void *)matched + 18) + 24);
            if (v129) {
              LODWORD(v129) = *(_DWORD *)(v129 + 16);
            }
            if (v129 == *(_DWORD *)(v4 + 28))
            {
              double v130 = *((double *)matched + 9);
              double v131 = *((double *)matched + 10);
              double v132 = *((double *)matched + 11);
              v163.f64[0] = *((float64_t *)matched + 8);
              v163.f64[1] = v130;
              v164.f64[0] = v131 + v163.f64[0];
              v164.f64[1] = v130;
              v165.f64[0] = v131 + v163.f64[0];
              v165.f64[1] = v132 + v130;
              v166.f64[0] = v163.f64[0];
              v166.f64[1] = v132 + v130;
              long long v145 = xmmword_184997D50;
              long long v146 = 0u;
              long long v147 = xmmword_184997D60;
              long long v148 = 0u;
              long long v149 = 0u;
              long long v150 = xmmword_184997D50;
              long long v151 = 0u;
              long long v152 = xmmword_184997D60;
              *(void *)&v155[0] = &unk_1ED0301F0;
              *(void *)&v155[1] = &v145;
              unint64_t v133 = *(CA::Render::LayerNode **)(v7 + 88);
              if (v133) {
                CA::Render::LayerNode::MapGeometry::map((uint64_t)v155, 0, v133);
              }
              CA::Mat4Impl::mat4_concat(buf, buf[0].f64, (const double *)&v145, v128);
              for (uint64_t i = 0; i != 8; i += 2)
                CA::Mat4Impl::mat4_apply_to_point2(buf, &v163.f64[i], v134);
              double v16 = a1;
              char v17 = v136;
LABEL_40:
              *(_DWORD *)(v4 + 12) |= 0x100u;
              *(unsigned char *)(v4 + 213) = 1;
              long long v143 = *(_OWORD *)(a2 + 32);
              uint64_t v144 = *(void *)(a2 + 48);
              uint64_t v40 = *(void *)(a2 + 16);
              ++*(_DWORD *)(a2 + 132);
              *(void *)(a2 + 40) = 0;
              *(void *)(a2 + 48) = 0;
              *(void *)(a2 + 32) = 0x7FF0000000000000;
              *(void *)(a2 + 16) = *(void *)(v4 + 56);
              int v41 = (uint64_t *)(*v16 + 800);
              memset(buf, 0, sizeof(buf));
              LODWORD(v157) = 1065353216;
              std::vector<std::unordered_map<void *,CA::Render::LayerNode *>>::push_back[abi:nn180100](v41, (uint64_t *)buf);
              std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)buf);
              CA::Render::Layer::set_modifiers(v32, 0);
              uint64_t v45 = *(void *)(v7 + 88);
              if (v45)
              {
                uint64_t v46 = *(void *)(v32 + 128);
                if (v46)
                {
                  double v48 = *(double *)(v46 + 168);
                  double v47 = *(double *)(v46 + 176);
                }
                else
                {
                  double v47 = 0.0;
                  if ((*(unsigned char *)(v32 + 45) & 0x40) == 0) {
                    double v47 = 0.5;
                  }
                  double v48 = v47;
                }
                v141[0] = v48;
                v141[1] = v47;
                float64x2_t v49 = vmlaq_n_f64(v163, vsubq_f64(v164, v163), v48);
                int64x2_t v50 = (int64x2_t)vmlaq_n_f64(v49, vmlaq_n_f64(vsubq_f64(v166, v49), vsubq_f64(v165, v166), v48), v47);
                float64x2_t v142 = (float64x2_t)v50;
                float64x2_t v137 = (float64x2_t)v50;
                if ((*(unsigned char *)(a4 + 13) & 8) != 0)
                {
                  uint64_t v51 = 0;
                  memset(v155, 0, sizeof(v155));
                  float64x2_t v52 = (float64x2_t)vdupq_lane_s64(v50.i64[0], 0);
                  float64x2_t v53 = (float64x2_t)vdupq_laneq_s64(v50, 1);
                  do
                  {
                    uint64_t v54 = &v163.f64[v51];
                    float64x2x2_t v168 = vld2q_f64(v54);
                    v169.val[0] = vsubq_f64(v168.val[0], v52);
                    v169.val[1] = vsubq_f64(v168.val[1], v53);
                    uint64_t v55 = &v155[v51];
                    vst2q_f64(v55, v169);
                    v51 += 4;
                  }
                  while (v51 != 8);
                  long long v161 = 0u;
                  long long v162 = 0u;
                  long long v159 = 0u;
                  long long v160 = 0u;
                  long long v157 = 0u;
                  long long v158 = 0u;
                  memset(buf, 0, sizeof(buf));
                  long long v140 = *(_OWORD *)(v32 + 80);
                  CA::Mat4Impl::mat4_set_corner_matrix((uint64_t)buf, v155, (double *)&v140, v141);
                  unsigned int v139 = 568;
                  CA::Render::Layer::set_property_value((CA::Render::Layer *)v32, &v139, (double *)1, 0, (CA::Render::Vector *)0x10, buf[0].f64, v56);
                  if ((v17 & 4) == 0)
                  {
                    long long v57 = *(_OWORD *)(v4 + 96);
                    long long v58 = *(_OWORD *)(v4 + 112);
                    long long v59 = *(_OWORD *)(v4 + 128);
                    long long v145 = *(_OWORD *)(v4 + 80);
                    long long v146 = v57;
                    long long v147 = v58;
                    long long v60 = *(_OWORD *)(v4 + 144);
                    long long v44 = *(_OWORD *)(v4 + 160);
                    long long v61 = *(_OWORD *)(v4 + 176);
                    long long v62 = *(_OWORD *)(v4 + 192);
                    long long v148 = v59;
                    long long v149 = v60;
                    long long v150 = v44;
                    long long v151 = v61;
                    long long v152 = v62;
                    if (*(double *)&v145 == buf[0].f64[0])
                    {
                      uint64_t v116 = 1;
                      while (v116 != 16)
                      {
                        uint64_t v117 = v116;
                        double v118 = *((double *)&v145 + v116);
                        double v119 = buf[0].f64[v116++];
                        if (v118 != v119)
                        {
                          if ((unint64_t)(v117 - 1) <= 0xE) {
                            goto LABEL_52;
                          }
                          break;
                        }
                      }
                    }
                    else
                    {
LABEL_52:
                      *(void *)(a2 + 64) |= 0x10000003uLL;
                      float64x2_t v63 = buf[1];
                      long long v44 = v157;
                      long long v64 = v158;
                      long long v65 = v159;
                      long long v66 = v160;
                      long long v67 = v161;
                      long long v68 = v162;
                      *(float64x2_t *)(v4 + 80) = buf[0];
                      *(float64x2_t *)(v4 + 96) = v63;
                      *(_OWORD *)(v4 + 112) = v44;
                      *(_OWORD *)(v4 + 128) = v64;
                      *(_OWORD *)(v4 + 144) = v65;
                      *(_OWORD *)(v4 + 160) = v66;
                      *(_OWORD *)(v4 + 176) = v67;
                      *(_OWORD *)(v4 + 192) = v68;
                    }
                  }
                  *(void *)(v32 + 40) &= ~0x200uLL;
                }
                else
                {
                  CA::Render::Layer::set_transform(v32, 0);
                }
                if ((*(unsigned char *)(a4 + 13) & 4) != 0)
                {
                  if ((*(unsigned char *)(*(void *)(v45 + 32) + 13) & 9) != 0)
                  {
                    uint64_t v72 = *(float64x2_t **)(v45 + 56);
                    if (v72) {
                      CA::Mat4Impl::mat4_apply_to_point2(v72, v142.f64, (double *)v43);
                    }
                    else {
                      float64x2_t v142 = vaddq_f64(v137, *(float64x2_t *)(v45 + 64));
                    }
                  }
                  uint64_t v79 = *(void *)(v7 + 56);
                  if (v79)
                  {
                    float64x2_t v80 = *(float64x2_t *)(v79 + 16);
                    long long v81 = *(_OWORD *)(v79 + 32);
                    long long v82 = *(_OWORD *)(v79 + 48);
                    buf[0] = *(float64x2_t *)v79;
                    buf[1] = v80;
                    long long v157 = v81;
                    long long v158 = v82;
                    long long v83 = *(_OWORD *)(v79 + 80);
                    long long v84 = *(_OWORD *)(v79 + 96);
                    long long v85 = *(_OWORD *)(v79 + 112);
                    long long v159 = *(_OWORD *)(v79 + 64);
                    long long v160 = v83;
                    long long v161 = v84;
                    long long v162 = v85;
                    CA::Mat4Impl::mat4_invert((CA::Mat4Impl *)buf, (CA::Mat4Impl *)buf, (const double *)v43);
                    CA::Mat4Impl::mat4_unapply_inverse_to_point2(buf, v142.f64, v86);
                  }
                  else
                  {
                    float64x2_t v142 = vsubq_f64(v142, *(float64x2_t *)(v7 + 64));
                  }
                }
                else
                {
                  uint64_t v69 = *(void *)(v7 + 32);
                  uint64_t v70 = *(void *)(v69 + 128);
                  if (v70)
                  {
                    float64x2_t v71 = *(float64x2_t *)(v70 + 168);
                  }
                  else
                  {
                    double v73 = 0.0;
                    if ((*(unsigned char *)(v69 + 45) & 0x40) == 0) {
                      double v73 = 0.5;
                    }
                    float64x2_t v71 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v73, 0);
                  }
                  float64x2_t v142 = vmulq_f64(*(float64x2_t *)(v69 + 80), v71);
                  __asm { FMOV            V0.2D, #0.5 }
                  buf[0] = _Q0;
                  CA::Render::Layer::set_anchor_point((void *)v32, (uint64_t)buf);
                }
                if ((v17 & 4) == 0)
                {
                  double v87 = *(double *)(v4 + 64);
                  if (v87 != v142.f64[0])
                  {
                    if (v87 < 0.0 == v142.f64[0] >= 0.0) {
                      goto LABEL_80;
                    }
                    unint64_t v90 = *(void *)&v87 - *(void *)&v142.f64[0];
                    if ((uint64_t)(*(void *)&v87 - *(void *)&v142.f64[0]) < 0) {
                      unint64_t v90 = *(void *)&v142.f64[0] - *(void *)&v87;
                    }
                    if (v90 > 3) {
                      goto LABEL_80;
                    }
                  }
                  double v88 = *(double *)(v4 + 72);
                  if (v88 != v142.f64[1])
                  {
                    if (v88 < 0.0 == v142.f64[1] >= 0.0) {
                      goto LABEL_80;
                    }
                    unint64_t v89 = *(void *)&v88 - *(void *)&v142.f64[1];
                    if ((uint64_t)(*(void *)&v88 - *(void *)&v142.f64[1]) < 0) {
                      unint64_t v89 = *(void *)&v142.f64[1] - *(void *)&v88;
                    }
                    if (v89 >= 4)
                    {
LABEL_80:
                      *(void *)(a2 + 64) |= 0x10000003uLL;
                      *(float64x2_t *)(v4 + 64) = v142;
                    }
                  }
                }
                *(float64x2_t *)(v32 + 48) = v142;
              }
              if ((*(unsigned char *)(a4 + 13) & 2) != 0)
              {
                uint64_t v92 = *(void *)(v7 + 88);
                if (v92)
                {
                  float v93 = 1.0;
                  do
                  {
                    LOBYTE(v44) = *(unsigned char *)(*(void *)(v92 + 32) + 32);
                    *(float *)&long long v44 = (float)v44;
                    float v93 = (float)(v93 * 0.0039216) * *(float *)&v44;
                    uint64_t v92 = *(void *)(v92 + 88);
                  }
                  while (v92);
                }
                else
                {
                  float v93 = 1.0;
                }
                float v94 = v154 / v93;
                int v95 = fabs(v154 / v93);
                float v96 = 0.0;
                if (v95 < 2139095040)
                {
                  if (v94 > 1.0) {
                    float v94 = 1.0;
                  }
                  if (v94 >= 0.0) {
                    float v96 = v94;
                  }
                }
                if ((v17 & 4) == 0 && *(float *)(v4 + 208) != v96)
                {
                  *(void *)(a2 + 64) |= 0x10000003uLL;
                  *(float *)(v4 + 208) = v96;
                }
                int v91 = (int)(float)((float)(v96 * 255.0) + 0.5);
              }
              else
              {
                LOBYTE(v91) = -1;
              }
              *(unsigned char *)(v32 + 32) = v91;
              uint64_t v97 = *(void *)(a4 + 48);
              if (v97)
              {
                uint64_t v98 = *(unsigned int *)(v97 + 16);
                if (v98)
                {
                  float64x2_t v99 = (uint64_t *)(v97 + 24);
                  uint64_t v100 = 8 * v98;
                  do
                  {
                    uint64_t v101 = *v99;
                    int v102 = *(_DWORD *)(*v99 + 16);
                    if (v102) {
                      *(void *)&float64_t v103 = (2 * v102) | 1u;
                    }
                    else {
                      float64_t v103 = 0.0;
                    }
                    buf[0].f64[0] = v103;
                    int is_object = CA::Render::Layer::keypath_is_object((CA::Render::Layer *)v32, (const CA::Render::Layer **)buf, (void *const *)v43);
                    uint64_t v43 = *(void *)(v101 + 24);
                    if (is_object)
                    {
                      CA::Render::Layer::set_keypath_object((CA::Render::Layer *)v32, (const CA::Render::Layer **)buf, (void *const *)v43);
                    }
                    else if (*(unsigned char *)(v43 + 12) == 56)
                    {
                      CA::Render::Layer::set_keypath_value((CA::Render::Layer *)v32, (unint64_t *)buf, 0, (CA::Render::Vector *)*(unsigned int *)(v43 + 16), (double *)(v43 + 24));
                    }
                    ++v99;
                    v100 -= 8;
                  }
                  while (v100);
                }
              }
              uint64_t v105 = *(void *)a2;
              uint64_t v106 = *(void *)(*(void *)a2 + 24);
              if ((*(_DWORD *)(a4 + 12) & 0x1000) != 0) {
                uint64_t v107 = *(void *)(*(void *)a2 + 24);
              }
              else {
                uint64_t v107 = v106 | 0x8000000;
              }
              uint64_t v108 = v107 | 0x24000000;
              *(void *)(v105 + 24) = v108;
              if ((*(unsigned char *)(a4 + 13) & 8) != 0)
              {
                uint64_t v109 = *(void *)(v7 + 88);
                if (v109) {
                  *(void *)(v105 + 24) = (*(_DWORD *)(v109 + 24) ^ v153) & 1 ^ (unint64_t)v108;
                }
              }
              uint64_t v110 = v106 & 0xC000001;
              int v111 = *(_DWORD *)(v32 + 12);
              if ((v111 & 0x1000) != 0 || !CA::Render::Layer::is_containerable((CA::Render::Layer *)v32, v42)) {
                unsigned int v112 = v111 & 0xFFFFF7FF;
              }
              else {
                unsigned int v112 = v111 | 0x800;
              }
              *(_DWORD *)(v32 + 12) = v112;
              uint64_t v113 = *(void *)(*a1 + 1056);
              *(void *)(*a1 + 1056) = a4;
              CA::Render::Updater::prepare_sublayer0(a1, a2, v32);
              v114 = (CA::Render::Update *)*a1;
              *((void *)v114 + 132) = v113;
              *(void *)(*(void *)a2 + 24) = *(void *)(*(void *)a2 + 24) & 0xFFFFFFFFF3FFFFFELL | v110;
              CA::Render::Update::pop_dependence_group(v114, v115);
              *(void *)(a2 + 16) = v40;
              *(_OWORD *)(a2 + 32) = v143;
              *(void *)(a2 + 48) = v144;
              --*(_DWORD *)(a2 + 132);
              *(_DWORD *)(v4 + 12) &= ~0x100u;
            }
            if (atomic_fetch_add((atomic_uint *volatile)(v32 + 8), 0xFFFFFFFF) == 1) {
              (*(void (**)(uint64_t))(*(void *)v32 + 16))(v32);
            }
          }
        }
        else
        {
          char v12 = *(void **)(v10 + 808);
          unsigned int v13 = *(void **)(v10 + 800);
          do
          {
            if (v12 == v13)
            {
              if ((*v11 & 4) == 0)
              {
                do
                {
                  uint64_t v18 = v7;
                  uint64_t v7 = *(void *)(v7 + 88);
                }
                while (v7);
                uint64_t v19 = *(void *)(v18 + 40);
                if (v19) {
                  *(void *)(v19 + 96) |= 0x1000000000000000uLL;
                }
              }
              goto LABEL_16;
            }
            v12 -= 5;
            char v14 = std::__hash_table<std::__hash_value_type<CA::Render::Object *,x_link_struct>,std::__unordered_map_hasher<CA::Render::Object *,std::__hash_value_type<CA::Render::Object *,x_link_struct>,std::hash<CA::Render::Object *>,std::equal_to<CA::Render::Object *>,true>,std::__unordered_map_equal<CA::Render::Object *,std::__hash_value_type<CA::Render::Object *,x_link_struct>,std::equal_to<CA::Render::Object *>,std::hash<CA::Render::Object *>,true>,std::allocator<std::__hash_value_type<CA::Render::Object *,x_link_struct>>>::find<CA::Render::Object *>(v12, v5);
          }
          while (!v14);
          uint64_t v15 = v14[3];
          CA::Render::Update::mark_root_dependence((CA::Render::LayerNode *)(*v11 | ((unint64_t)*((unsigned __int16 *)v11 + 2) << 32)), (CA::Render::LayerNode *)v15, (CA::Render::LayerNode *)v7);
          if (v15)
          {
            double v16 = a1;
            char v17 = v136;
            if (v9)
            {
              if (x_log_hook_p())
              {
                x_log_();
              }
              else
              {
                int v24 = x_log_category_render;
                if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v25 = *(void *)(a4 + 24);
                  uint64_t v26 = *(void *)(a4 + 32);
                  int v27 = *(_DWORD *)(a4 + 40);
                  LODWORD(buf[0].f64[0]) = 134218496;
                  *(void *)((char *)buf[0].f64 + 4) = v25;
                  WORD2(buf[0].f64[1]) = 2048;
                  *(void *)((char *)&buf[0].f64[1] + 6) = v26;
                  HIWORD(buf[1].f64[0]) = 1024;
                  LODWORD(buf[1].f64[1]) = v27;
                  _os_log_impl(&dword_184668000, v24, OS_LOG_TYPE_DEFAULT, "Portal %lx found source %lx from context %x", (uint8_t *)buf, 0x1Cu);
                }
              }
            }
            uint64_t v28 = *(void *)(v15 + 40);
            if (v28 && (*(void *)(v28 + 96) & 0x10000001) != 0) {
              *(void *)(a2 + 64) |= 0x10000001uLL;
            }
            if (*(unsigned char *)(v4 + 212))
            {
              *(void *)(a2 + 64) |= 0x10000001uLL;
              *(unsigned char *)(v4 + 212) = 0;
            }
            malloc_zone = (malloc_zone_t *)get_malloc_zone();
            double v30 = malloc_type_zone_calloc(malloc_zone, 1uLL, 0x98uLL, 0x743898A5uLL);
            uint64_t v32 = (uint64_t)v30;
            if (v30) {
              CA::Render::Layer::Layer((uint64_t)v30, *(void *)(v15 + 32));
            }
            int v33 = *(_DWORD *)(a4 + 12);
            if ((v33 & 0x100) != 0)
            {
              *(_DWORD *)(v15 + 116) = 0;
              int v33 = *(_DWORD *)(a4 + 12);
            }
            if ((v33 & 0x200) != 0)
            {
              float v34 = 1.0;
              uint64_t v35 = v15;
              do
              {
                LOBYTE(v31) = *(unsigned char *)(*(void *)(v35 + 32) + 32);
                float v31 = (float)LODWORD(v31);
                float v34 = v31 * (float)(0.0039216 * v34);
                uint64_t v35 = *(void *)(v35 + 88);
              }
              while (v35);
              float v154 = v34;
            }
            uint64_t v153 = *(void *)(v15 + 24);
            double v36 = *(double *)(v32 + 72);
            double v37 = *(double *)(v32 + 80);
            double v38 = *(double *)(v32 + 88);
            v163.f64[0] = *(float64_t *)(v32 + 64);
            v163.f64[1] = v36;
            v164.f64[0] = v37 + v163.f64[0];
            v164.f64[1] = v36;
            v165.f64[0] = v37 + v163.f64[0];
            v165.f64[1] = v38 + v36;
            v166.f64[0] = v163.f64[0];
            v166.f64[1] = v38 + v36;
            long long v39 = *(CA::Render::LayerNode **)(v7 + 88);
            if (v39)
            {
              *(void *)&buf[0].f64[0] = &unk_1ED030230;
              *(void *)&buf[0].f64[1] = 4;
              *(void *)&buf[1].f64[0] = &v163;
              CA::Render::LayerNode::MapGeometry::map((uint64_t)buf, (CA::Render::LayerNode *)v15, v39);
            }
            goto LABEL_40;
          }
LABEL_16:
          if (v9)
          {
            if (x_log_hook_p())
            {
              x_log_();
            }
            else
            {
              char v20 = x_log_category_render;
              if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v21 = *(void *)(a4 + 24);
                uint64_t v22 = *(void *)(a4 + 32);
                int v23 = *(_DWORD *)(a4 + 40);
                LODWORD(buf[0].f64[0]) = 134218496;
                *(void *)((char *)buf[0].f64 + 4) = v21;
                WORD2(buf[0].f64[1]) = 2048;
                *(void *)((char *)&buf[0].f64[1] + 6) = v22;
                HIWORD(buf[1].f64[0]) = 1024;
                LODWORD(buf[1].f64[1]) = v23;
                _os_log_impl(&dword_184668000, v20, OS_LOG_TYPE_DEFAULT, "Portal %lx cannot find source %lx from context %x", (uint8_t *)buf, 0x1Cu);
              }
            }
          }
          *(void *)(a2 + 64) |= 1uLL;
        }
      }
    }
  }
}

void CA::Render::Updater::prepare_sublayer0(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void **)a2;
  char v26 = 0;
  uint64_t v7 = CA::Render::Updater::layer_node(a3, (CA::Render::LayerNode *)a1, a2, &v26);
  v7[11] = v6;
  uint64_t v8 = 268435466;
  if ((*(_DWORD *)(v6[4] + 12) & 0x900) == 0) {
    uint64_t v8 = 8;
  }
  CA::Render::Updater::prepare_layer0(a1, v7, a3, a2, v8 & *(void *)(a2 + 64));
  if (v7[11])
  {
    uint64_t v10 = v7[4];
    unint64_t v11 = v7[3] & 0xFFFFFFFFFFFFFC7FLL;
    int32x2_t v7[3] = v11;
    uint64_t v12 = v6[3] & 0x200 | *(void *)(a1[3] + 24) | v11;
    int32x2_t v7[3] = v12;
    if ((*(unsigned char *)(v10 + 13) & 9) != 0)
    {
      if ((v12 & 0x20) != 0) {
        v6[3] |= 0x20uLL;
      }
      unsigned int v13 = v7 + 12;
      char v14 = (void *)v7[13];
      if (v14 != v7 + 12)
      {
        if ((*(unsigned char *)(v10 + 13) & 1) != 0 && (*(unsigned char *)(v10 + 41) & 0x10) != 0)
        {
          CA::Render::LayerNode::depth_sort_sublayers((CA::Render::LayerNode *)v7);
          char v14 = (void *)v7[13];
        }
        if (v14 != v13)
        {
          uint64_t v15 = v14;
          do
          {
            v15[11] = v6;
            uint64_t v16 = v15[17];
            if (v16) {
              *(void *)(v16 + 88) = v6;
            }
            uint64_t v15 = (void *)v15[1];
          }
          while (v15 != v13);
        }
        char v17 = (void *)v6[13];
        v6[13] = v14;
        *(void *)v7[13] = v6 + 12;
        uint64_t v18 = v7[12];
        *(void *)(v18 + 8) = v17;
        *char v17 = v18;
        v7[12] = v7 + 12;
        v7[13] = v13;
      }
      uint64_t v21 = (void *)a1[4];
      char v20 = a1 + 4;
      uint64_t v19 = v21;
      void *v20 = v7;
      void *v7 = v21;
      v7[1] = v20;
      uint64_t v22 = v7;
    }
    else
    {
      uint64_t v22 = (void *)v6[13];
      v6[13] = v7;
      void *v7 = v6 + 12;
      *uint64_t v22 = v7;
      uint64_t v19 = v7;
    }
    v19[1] = v22;
    if (!v26) {
      atomic_fetch_add((atomic_uint *volatile)v7 + 4, 1u);
    }
    __int16 v23 = *(_WORD *)(a2 + 136);
    if ((v23 & 0x40) == 0)
    {
      int v24 = (double *)v7[7];
      if (v24)
      {
        if (v24[2] != 0.0 || v24[6] != 0.0 || v24[10] != 1.0)
        {
LABEL_34:
          *(_WORD *)(a2 + 136) = v23 | 0x40;
          return;
        }
        double v25 = v24[14];
      }
      else
      {
        double v25 = *((double *)v7 + 10);
      }
      if (v25 == 0.0) {
        return;
      }
      goto LABEL_34;
    }
  }
  else if (v26 && atomic_fetch_add((atomic_uint *volatile)v7 + 4, 0xFFFFFFFF) == 1)
  {
    CA::Render::LayerNode::delete_node((CA::Render::LayerNode *)v7, v9);
  }
}

void *CA::Render::Updater::layer_node(uint64_t a1, CA::Render::LayerNode *a2, uint64_t a3, char *a4)
{
  if (*(_DWORD *)(a3 + 132))
  {
    uint64_t v6 = CA::Render::LayerNodeAllocator::alloc_node((CA::Render::LayerNodeAllocator *)a1);
    uint64_t v7 = *(void *)(a3 + 96);
    if (v7)
    {
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      int v9 = malloc_type_zone_malloc(malloc_zone, 0x80uLL, 0x8BB15036uLL);
      v6[18] = v9;
      long long v10 = *(_OWORD *)(v7 + 24);
      long long v11 = *(_OWORD *)(v7 + 40);
      long long v12 = *(_OWORD *)(v7 + 56);
      *int v9 = *(_OWORD *)(v7 + 8);
      v9[1] = v10;
      v9[2] = v11;
      v9[3] = v12;
      long long v13 = *(_OWORD *)(v7 + 88);
      long long v14 = *(_OWORD *)(v7 + 104);
      long long v15 = *(_OWORD *)(v7 + 120);
      v9[4] = *(_OWORD *)(v7 + 72);
      v9[5] = v13;
      v9[6] = v14;
      v9[7] = v15;
    }
    *a4 = 1;
    return v6;
  }
  uint64_t v17 = *(void *)(a1 + 144);
  if (v17 && *(void *)(v17 + 16) == a1)
  {
    uint64_t v6 = *(void **)(v17 + 40);
    if (v6)
    {
      if ((*((_DWORD *)v6 + 4) == 1 || (*((unsigned char *)v6 + 25) & 8) != 0)
        && (*(_DWORD *)(v17 + 12) & 0x400) == 0
        && (((*(_DWORD *)(*(void *)a2 + 1084) >> 27) & 1 ^ ((*(_DWORD *)(v17 + 12) & 0x200u) >> 9)) & 1) == 0)
      {
        if (v6[11] != *(void *)(a3 + 8) && (*(unsigned char *)(a1 + 13) & 9) == 0)
        {
          *(void *)(v17 + 96) |= 4uLL;
          v6[3] |= 4uLL;
        }
        uint64_t v19 = v6[3];
        if ((v19 & 0x800) != 0)
        {
          uint64_t v22 = *v6;
          uint64_t v21 = (void *)v6[1];
          *(void *)(v22 + 8) = v21;
          *uint64_t v21 = v22;
          void *v6 = v6;
          v6[1] = v6;
          v6[3] = v19 & 0xFFFFFFFFFFFFF7FFLL;
          v6[11] = 0;
          char v20 = 1;
        }
        else
        {
          char v20 = 0;
        }
        *a4 = v20;
        __int16 v23 = (void *)v6[19];
        if (v23)
        {
          do
          {
            int v24 = (void *)*v23;
            free(v23);
            __int16 v23 = v24;
          }
          while (v24);
          v6[19] = 0;
          *(void *)(v17 + 96) |= 8uLL;
        }
        return v6;
      }
      v6[5] = 0;
      if (atomic_fetch_add((atomic_uint *volatile)v6 + 4, 0xFFFFFFFF) == 1) {
        CA::Render::LayerNode::delete_node((CA::Render::LayerNode *)v6, a2);
      }
      *(void *)(v17 + 40) = 0;
    }
    uint64_t v6 = CA::Render::LayerNodeAllocator::alloc_node((CA::Render::LayerNodeAllocator *)a1);
    v6[3] |= 0x40uLL;
    v6[5] = v17;
    *(void *)(v17 + 40) = v6;
    *(_DWORD *)(v17 + 12) = (*(_DWORD *)(*(void *)a2 + 1084) >> 18) & 0x200 | *(_DWORD *)(v17 + 12) & 0xFFFFF9FF;
    *(void *)(v17 + 96) |= 4uLL;
    *a4 = 0;
    return v6;
  }
  *a4 = 1;

  return CA::Render::LayerNodeAllocator::alloc_node((CA::Render::LayerNodeAllocator *)a1);
}

void *CA::Render::LayerNodeAllocator::alloc_node(CA::Render::LayerNodeAllocator *this)
{
  if (CA::Render::LayerNodeAllocator::alloc_node(void)::once[0] != -1) {
    dispatch_once(CA::Render::LayerNodeAllocator::alloc_node(void)::once, &__block_literal_global_8670);
  }
  if (CA::Render::LayerNodeAllocator::_free_offsets_count)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::LayerNodeAllocator::_lock);
    int v1 = CA::Render::LayerNodeAllocator::_free_offsets_count;
    if (CA::Render::LayerNodeAllocator::_free_offsets_count)
    {
      --CA::Render::LayerNodeAllocator::_free_offsets_count;
      unsigned int v2 = *(unsigned __int16 *)(CA::Render::LayerNodeAllocator::_free_offsets + 2 * (v1 - 1));
      os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::LayerNodeAllocator::_lock);
      uint64_t v3 = CA::Render::LayerNodeAllocator::_data;
      uint64_t result = (void *)(CA::Render::LayerNodeAllocator::_data + 280 * v2);
      if (CA::Render::LayerNodeAllocator::_data)
      {
        result[34] = 0;
        *((_OWORD *)result + 15) = 0u;
        *((_OWORD *)result + 16) = 0u;
        *((_OWORD *)result + 13) = 0u;
        *((_OWORD *)result + 14) = 0u;
        *((_OWORD *)result + 11) = 0u;
        *((_OWORD *)result + 12) = 0u;
        *((_OWORD *)result + 9) = 0u;
        *((_OWORD *)result + 10) = 0u;
        *((_OWORD *)result + 7) = 0u;
        *((_OWORD *)result + 8) = 0u;
        *((_OWORD *)result + 5) = 0u;
        *((_OWORD *)result + 6) = 0u;
        *((_OWORD *)result + 3) = 0u;
        *((_OWORD *)result + 4) = 0u;
        *((_OWORD *)result + 1) = 0u;
        *((_OWORD *)result + 2) = 0u;
      }
      *uint64_t result = result;
      result[1] = result;
      unint64_t v5 = (int64x2_t *)(v3 + 280 * v2);
      v5[6] = vdupq_n_s64((unint64_t)&v5[6]);
      v5[1].i32[0] = 1;
      uint64_t v6 = &v5[1].i64[1];
      goto LABEL_12;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::LayerNodeAllocator::_lock);
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  uint64_t result = malloc_type_zone_calloc(malloc_zone, 1uLL, 0x118uLL, 0x743898A5uLL);
  if (result)
  {
    result[34] = 0;
    *((_OWORD *)result + 15) = 0u;
    *((_OWORD *)result + 16) = 0u;
    *((_OWORD *)result + 13) = 0u;
    *((_OWORD *)result + 14) = 0u;
    *((_OWORD *)result + 11) = 0u;
    *((_OWORD *)result + 12) = 0u;
    *((_OWORD *)result + 9) = 0u;
    *((_OWORD *)result + 10) = 0u;
    *((_OWORD *)result + 7) = 0u;
    *((_OWORD *)result + 8) = 0u;
    *((_OWORD *)result + 5) = 0u;
    *((_OWORD *)result + 6) = 0u;
    *((_OWORD *)result + 3) = 0u;
    *((_OWORD *)result + 4) = 0u;
    *((_OWORD *)result + 1) = 0u;
    *((_OWORD *)result + 2) = 0u;
  }
  *uint64_t result = result;
  result[1] = result;
  result[12] = result + 12;
  result[13] = result + 12;
  uint64_t v6 = result + 3;
  *((_DWORD *)result + 4) = 1;
LABEL_12:
  uint64_t *v6 = 4;
  return result;
}

void std::vector<std::unordered_map<void *,CA::Render::LayerNode *>>::push_back[abi:nn180100](uint64_t *a1, uint64_t *a2)
{
  unint64_t v4 = a1[1];
  unint64_t v5 = a1[2];
  if (v4 < v5)
  {
    uint64_t v6 = std::__hash_table<std::__hash_value_type<std::string,void (*)(CALayer *,CA::Render::Layer const*,CA::Render::Layer const*,std::string const&,ReverseSerializationState const&)>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,void (*)(CALayer *,CA::Render::Layer const*,CA::Render::Layer const*,std::string const&,ReverseSerializationState const&)>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,void (*)(CALayer *,CA::Render::Layer const*,CA::Render::Layer const*,std::string const&,ReverseSerializationState const&)>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,void (*)(CALayer *,CA::Render::Layer const*,CA::Render::Layer const*,std::string const&,ReverseSerializationState const&)>>>::__hash_table(v4, a2)+ 40;
    goto LABEL_20;
  }
  unint64_t v7 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v4 - *a1) >> 3);
  if (v7 + 1 > 0x666666666666666) {
    abort();
  }
  unint64_t v8 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v5 - *a1) >> 3);
  uint64_t v9 = 2 * v8;
  if (2 * v8 <= v7 + 1) {
    uint64_t v9 = v7 + 1;
  }
  if (v8 >= 0x333333333333333) {
    unint64_t v10 = 0x666666666666666;
  }
  else {
    unint64_t v10 = v9;
  }
  if (v10)
  {
    if (v10 > 0x666666666666666) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    long long v11 = (char *)operator new(40 * v10);
  }
  else
  {
    long long v11 = 0;
  }
  long long v12 = &v11[40 * v10];
  uint64_t v13 = std::__hash_table<std::__hash_value_type<std::string,void (*)(CALayer *,CA::Render::Layer const*,CA::Render::Layer const*,std::string const&,ReverseSerializationState const&)>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,void (*)(CALayer *,CA::Render::Layer const*,CA::Render::Layer const*,std::string const&,ReverseSerializationState const&)>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,void (*)(CALayer *,CA::Render::Layer const*,CA::Render::Layer const*,std::string const&,ReverseSerializationState const&)>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,void (*)(CALayer *,CA::Render::Layer const*,CA::Render::Layer const*,std::string const&,ReverseSerializationState const&)>>>::__hash_table((uint64_t)&v11[40 * v7], a2);
  uint64_t v6 = v13 + 40;
  long long v15 = (uint64_t *)*a1;
  long long v14 = (uint64_t *)a1[1];
  if (v14 == (uint64_t *)*a1)
  {
    *a1 = v13;
    a1[1] = v6;
    a1[2] = (uint64_t)v12;
    if (!v14) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
  do
  {
    v14 -= 5;
    uint64_t v13 = std::__hash_table<std::__hash_value_type<std::string,void (*)(CALayer *,CA::Render::Layer const*,CA::Render::Layer const*,std::string const&,ReverseSerializationState const&)>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,void (*)(CALayer *,CA::Render::Layer const*,CA::Render::Layer const*,std::string const&,ReverseSerializationState const&)>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,void (*)(CALayer *,CA::Render::Layer const*,CA::Render::Layer const*,std::string const&,ReverseSerializationState const&)>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,void (*)(CALayer *,CA::Render::Layer const*,CA::Render::Layer const*,std::string const&,ReverseSerializationState const&)>>>::__hash_table(v13 - 40, v14);
  }
  while (v14 != v15);
  uint64_t v16 = (uint64_t *)*a1;
  long long v14 = (uint64_t *)a1[1];
  *a1 = v13;
  a1[1] = v6;
  a1[2] = (uint64_t)v12;
  if (v14 != v16)
  {
    do
    {
      v14 -= 5;
      std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)v14);
    }
    while (v14 != v16);
    long long v14 = v16;
  }
  if (v14) {
LABEL_19:
  }
    operator delete(v14);
LABEL_20:
  a1[1] = v6;
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,void (*)(CALayer *,CA::Render::Layer const*,CA::Render::Layer const*,std::string const&,ReverseSerializationState const&)>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,void (*)(CALayer *,CA::Render::Layer const*,CA::Render::Layer const*,std::string const&,ReverseSerializationState const&)>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,void (*)(CALayer *,CA::Render::Layer const*,CA::Render::Layer const*,std::string const&,ReverseSerializationState const&)>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,void (*)(CALayer *,CA::Render::Layer const*,CA::Render::Layer const*,std::string const&,ReverseSerializationState const&)>>>::__hash_table(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *a2 = 0;
  *(void *)uint64_t result = v2;
  *(void *)(result + 8) = a2[1];
  a2[1] = 0;
  uint64_t v5 = a2[2];
  uint64_t v3 = a2 + 2;
  uint64_t v4 = v5;
  *(void *)(result + 16) = v5;
  uint64_t v6 = v3[1];
  *(void *)(result + 24) = v6;
  *(_DWORD *)(result + 32) = *((_DWORD *)v3 + 4);
  if (v6)
  {
    unint64_t v7 = *(void *)(v4 + 8);
    unint64_t v8 = *(void *)(result + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        v7 %= v8;
      }
    }
    else
    {
      v7 &= v8 - 1;
    }
    *(void *)(v2 + 8 * v7) = result + 16;
    *uint64_t v3 = 0;
    v3[1] = 0;
  }
  return result;
}

uint64_t CA::Render::Update::pop_dependence_group(CA::Render::Update *this, CA::Render::LayerNode *a2)
{
  uint64_t v3 = *((void *)this + 101);
  uint64_t v4 = *(void **)(v3 - 24);
  if (v4)
  {
    do
    {
      uint64_t v5 = (atomic_uint *)v4[3];
      if (atomic_fetch_add(v5 + 4, 0xFFFFFFFF) == 1) {
        CA::Render::LayerNode::delete_node((CA::Render::LayerNode *)v5, a2);
      }
      uint64_t v4 = (void *)*v4;
    }
    while (v4);
    uint64_t v3 = *((void *)this + 101);
  }
  uint64_t result = std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table(v3 - 40);
  *((void *)this + 101) = result;
  return result;
}

void *CA::Render::Layer::set_anchor_point(void *result, uint64_t a2)
{
  if (result[16]) {
    goto LABEL_2;
  }
  double v3 = *(double *)(a2 + 8);
  if (*(double *)a2 == 0.5 && v3 == 0.5)
  {
    unint64_t v5 = result[5] & 0xFFFFBFFFFFFFFFFFLL;
  }
  else
  {
    if (*(double *)a2 != 0.0 || v3 != 0.0)
    {
LABEL_2:
      uint64_t result = CA::Render::Layer::ensure_ext((CA::Render::Layer *)result);
      *(_OWORD *)(result + 21) = *(_OWORD *)a2;
      return result;
    }
    unint64_t v5 = result[5] | 0x400000000000;
  }
  result[5] = v5;
  return result;
}

void CA::Render::Updater::union_opaque_rect(uint64_t a1, uint64_t a2, const CA::Bounds *a3, float64x2_t a4, float64x2_t a5)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  int64x2_t v6 = vceqzq_f64(a5);
  if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v6, 1), (int8x16_t)v6).u64[0] & 0x8000000000000000) != 0
    || (int8x16_t v7 = vorrq_s8((int8x16_t)vcltzq_f64(a5), (int8x16_t)vcgezq_f64(a5)),
        (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v7), 1), v7).u64[0] & 0x8000000000000000) != 0))
  {
    int32x4_t v15 = 0uLL;
  }
  else
  {
    float64x2_t v8 = vmaxnmq_f64(a4, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000));
    float64x2_t v9 = vminnmq_f64(vaddq_f64(a4, a5), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL));
    int32x4_t v10 = (int32x4_t)vcvtpq_s64_f64(v8);
    int32x4_t v15 = vuzp1q_s32(v10, (int32x4_t)vsubq_s64(vcvtmq_s64_f64(v9), (int64x2_t)v10));
  }
  long long v11 = (CA::Shape **)(a2 + 56);
  CA::shape_union((CA::Shape **)(a2 + 56), (CA::Shape **)&v15, a3);
  long long v14 = *(CA::Shape ***)(*(void *)a1 + 64);

  CA::shape_subtract(v11, v14, v12, v13);
}

void CA::OGL::anonymous namespace'::clear_backdrop_edges(CA::OGL::_anonymous_namespace_ *this, CA::OGL::Context *a2, const CA::Shape *a3, const CA::Shape *a4, float a5)
{
  v18[3] = *MEMORY[0x1E4F143B8];
  *(unsigned char *)(*((void *)this + 2) + 16) = 0;
  *((void *)this + 16) = 0;
  float64x2_t v8 = (char *)this + 834;
  *((void *)this + 12) = (char *)this + 834;
  *(_OWORD *)((char *)this + 104) = xmmword_184997E70;
  float64x2_t v9 = (CA::Shape *)CA::Shape::dilate((uint64_t)a2, (int)(16.0 / a5 + 1.0), (int)(16.0 / a5 + 1.0));
  long long v12 = (CA::Shape *)CA::Shape::subtract(v9, a3, v10, v11);
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  v18[1] = 0;
  v18[2] = 0;
  v18[0] = (uint64_t)v12;
  while (CA::ShapeIterator::iterate(v18, (int *)&v16))
  {
    if (*((_DWORD *)this + 23)) {
      uint64_t v13 = 6;
    }
    else {
      uint64_t v13 = 4;
    }
    if ((unint64_t)(*((void *)this + 16) + 4) > *((void *)this + 17)
      || (unint64_t v14 = *((void *)this + 14)) != 0 && *((void *)this + 13) + v13 > v14)
    {
      *((_WORD *)this + 416) |= 0x20u;
      CA::OGL::Context::array_flush((uint64_t)this);
      *((void *)this + 16) = 0;
      *((void *)this + 12) = v8;
      *(_OWORD *)((char *)this + 104) = xmmword_184997E70;
    }
    CA::OGL::Context::array_rect(this, floorf((float)(int)v16 * a5), floorf((float)SHIDWORD(v16) * a5), ceilf((float)(v17 + v16) * a5), ceilf((float)(HIDWORD(v17) + HIDWORD(v16)) * a5));
    uint64_t v15 = *((void *)this + 15) + 48 * *((void *)this + 16);
    *(void *)(v15 - 160) = 0;
    *(void *)(v15 - 112) = 0;
    *(void *)(v15 - 64) = 0;
    *(void *)(v15 - 16) = 0;
  }
  CA::OGL::Context::array_flush((uint64_t)this);
  if (v12) {
    CA::Shape::unref(v12);
  }
  if (v9)
  {
    CA::Shape::unref(v9);
  }
}

uint64_t CA::OGL::PingPongState::clear_edges(CA::OGL::PingPongState *this, float a2, float a3, float a4, float a5, float a6)
{
  *(unsigned char *)(*((void *)this + 2) + 16) = 0;
  *((void *)this + 16) = 0;
  long long v12 = (char *)this + 834;
  *((void *)this + 12) = (char *)this + 834;
  *(_OWORD *)((char *)this + 104) = xmmword_184997E70;
  if (*((void *)this + 17) <= 7uLL)
  {
    *((_WORD *)this + 416) |= 0x20u;
    CA::OGL::Context::array_flush((uint64_t)this);
    *((void *)this + 16) = 0;
    *((void *)this + 12) = v12;
    *(_OWORD *)((char *)this + 104) = xmmword_184997E70;
  }
  float v13 = a3 - a2;
  CA::OGL::Context::array_rect(this, a3 - a2, a4, a3, a6);
  uint64_t v14 = *((void *)this + 15) + 48 * *((void *)this + 16);
  *(void *)(v14 - 160) = 0;
  *(void *)(v14 - 112) = 0;
  *(void *)(v14 - 64) = 0;
  *(void *)(v14 - 16) = 0;
  float v15 = a5 + a2;
  CA::OGL::Context::array_rect(this, a5, a4, a5 + a2, a6);
  uint64_t v16 = *((void *)this + 15) + 48 * *((void *)this + 16);
  *(void *)(v16 - 160) = 0;
  *(void *)(v16 - 112) = 0;
  *(void *)(v16 - 64) = 0;
  *(void *)(v16 - 16) = 0;
  uint64_t v17 = 12;
  if (!*((_DWORD *)this + 23)) {
    uint64_t v17 = 8;
  }
  if ((unint64_t)(*((void *)this + 16) + 8) > *((void *)this + 17)
    || (unint64_t v18 = *((void *)this + 14)) != 0 && *((void *)this + 13) + v17 > v18)
  {
    *((_WORD *)this + 416) |= 0x20u;
    CA::OGL::Context::array_flush((uint64_t)this);
    *((void *)this + 16) = 0;
    *((void *)this + 12) = v12;
    *(_OWORD *)((char *)this + 104) = xmmword_184997E70;
  }
  float v19 = a4 - a2;
  CA::OGL::Context::array_rect(this, a3, a4 - a2, a5, a4);
  uint64_t v20 = *((void *)this + 15) + 48 * *((void *)this + 16);
  *(void *)(v20 - 160) = 0;
  *(void *)(v20 - 112) = 0;
  *(void *)(v20 - 64) = 0;
  *(void *)(v20 - 16) = 0;
  float v21 = a6 + a2;
  CA::OGL::Context::array_rect(this, a3, a6, a5, v21);
  uint64_t v22 = *((void *)this + 15) + 48 * *((void *)this + 16);
  *(void *)(v22 - 160) = 0;
  *(void *)(v22 - 112) = 0;
  *(void *)(v22 - 64) = 0;
  *(void *)(v22 - 16) = 0;
  uint64_t v23 = 12;
  if (!*((_DWORD *)this + 23)) {
    uint64_t v23 = 8;
  }
  if ((unint64_t)(*((void *)this + 16) + 8) > *((void *)this + 17)
    || (unint64_t v24 = *((void *)this + 14)) != 0 && *((void *)this + 13) + v23 > v24)
  {
    *((_WORD *)this + 416) |= 0x20u;
    CA::OGL::Context::array_flush((uint64_t)this);
    *((void *)this + 16) = 0;
    *((void *)this + 12) = v12;
    *(_OWORD *)((char *)this + 104) = xmmword_184997E70;
  }
  CA::OGL::Context::array_rect(this, v13, v19, a3, a4);
  uint64_t v25 = *((void *)this + 15) + 48 * *((void *)this + 16);
  *(void *)(v25 - 160) = 0;
  *(void *)(v25 - 112) = 0;
  *(void *)(v25 - 64) = 0;
  *(void *)(v25 - 16) = 0;
  CA::OGL::Context::array_rect(this, a5, v19, v15, a4);
  uint64_t v26 = *((void *)this + 15) + 48 * *((void *)this + 16);
  *(void *)(v26 - 160) = 0;
  *(void *)(v26 - 112) = 0;
  *(void *)(v26 - 64) = 0;
  *(void *)(v26 - 16) = 0;
  uint64_t v27 = 12;
  if (!*((_DWORD *)this + 23)) {
    uint64_t v27 = 8;
  }
  if ((unint64_t)(*((void *)this + 16) + 8) > *((void *)this + 17)
    || (unint64_t v28 = *((void *)this + 14)) != 0 && *((void *)this + 13) + v27 > v28)
  {
    *((_WORD *)this + 416) |= 0x20u;
    CA::OGL::Context::array_flush((uint64_t)this);
    *((void *)this + 16) = 0;
    *((void *)this + 12) = v12;
    *(_OWORD *)((char *)this + 104) = xmmword_184997E70;
  }
  CA::OGL::Context::array_rect(this, v13, a6, a3, v21);
  uint64_t v29 = *((void *)this + 15) + 48 * *((void *)this + 16);
  *(void *)(v29 - 160) = 0;
  *(void *)(v29 - 112) = 0;
  *(void *)(v29 - 64) = 0;
  *(void *)(v29 - 16) = 0;
  CA::OGL::Context::array_rect(this, a5, a6, v15, v21);
  uint64_t v30 = *((void *)this + 15) + 48 * *((void *)this + 16);
  *(void *)(v30 - 160) = 0;
  *(void *)(v30 - 112) = 0;
  *(void *)(v30 - 64) = 0;
  *(void *)(v30 - 16) = 0;

  return CA::OGL::Context::array_flush((uint64_t)this);
}

void *CA::OGL::Context::array_rect(void *this, float a2, float a3, float a4, float a5)
{
  uint64_t v6 = this[15];
  uint64_t v5 = this[16];
  this[16] = v5 + 4;
  uint64_t v7 = v6 + 48 * v5;
  *(float *)uint64_t v7 = a2;
  *(float *)(v7 + 4) = a3;
  *(void *)(v7 + 8) = 0x3F80000000000000;
  *(float *)(v7 + 48) = a4;
  *(float *)(v7 + 52) = a3;
  *(void *)(v7 + 56) = 0x3F80000000000000;
  *(float *)(v7 + 96) = a4;
  *(float *)(v7 + 100) = a5;
  *(void *)(v7 + 104) = 0x3F80000000000000;
  *(float *)(v7 + 144) = a2;
  *(float *)(v7 + 148) = a5;
  *(void *)(v7 + 152) = 0x3F80000000000000;
  if (this[12]) {
    return (void *)CA::OGL::Context::array_indices((uint64_t)this, v5);
  }
  return this;
}

uint64_t CA::Shape::scale_and_dilate(CA::Shape *this, float32x2_t a2, float32_t a3, unsigned int a4, unsigned int a5)
{
  _OWORD v13[3] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = 1;
  v13[0] = (uint64_t)this;
  v11[0] = 0;
  v11[1] = 0;
  v13[1] = 0;
  v13[2] = 0;
  a2.f32[1] = a3;
  float32x2_t v10 = a2;
  int32x2_t v9 = (int32x2_t)__PAIR64__(a5, a4);
  while (CA::ShapeIterator::iterate(v13, (int *)v11))
  {
    float32x2_t v6 = vcvt_f32_s32((int32x2_t)v11[0]);
    *(int32x2_t *)&long long v7 = vsub_s32(vcvtm_s32_f32(vmul_f32(v10, v6)), v9);
    *((int32x2_t *)&v7 + 1) = vsub_s32(vadd_s32(vcvtp_s32_f32(vmul_f32(vadd_f32(vcvt_f32_s32((int32x2_t)v11[1]), v6), v10)), v9), *(int32x2_t *)&v7);
    *(_OWORD *)long long v11 = v7;
    CA::shape_union((CA::Shape **)&v12, v11, v5);
  }
  return v12;
}

uint64_t CA::OGL::ContentsGeometry::fill_and_unbind(uint64_t a1, int32x2_t *a2, uint64_t a3, double *a4)
{
  uint64_t v80 = *MEMORY[0x1E4F143B8];
  long long v7 = (float32x2_t *)(a1 + 276);
  float64x2_t v8 = (CA::Transform *)(a1 + 104);
  v58[0] = (double *)(a1 + 8);
  v58[1] = (double *)(a1 + 104);
  int32x2_t v9 = *(float **)(a1 + 308);
  long long v59 = v9;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  uint64_t v62 = a1 + 40;
  if (!*(unsigned char *)(a1 + 339))
  {
    unsigned int v10 = *(unsigned __int8 *)(a1 + 336);
    long long v57 = v9;
    unsigned int v11 = (*(uint64_t (**)(int32x2_t *))(*(void *)a2 + 1032))(a2);
    int32x2_t v9 = v57;
    if (v11 < v10)
    {
      *(unsigned char *)(*(void *)&a2[2] + 481) |= 2u;
      *(_DWORD *)(*(void *)&a2[2] + 352) = 1065353216;
    }
  }
  char v12 = BYTE4(v9);
  char v13 = (char)v9;
  if (*(unsigned char *)(a1 + 338))
  {
    if (*(unsigned char *)(a1 + 337))
    {
      double v14 = *(double *)(a1 + 24);
      if (v14 >= *(double *)(a1 + 32)) {
        double v14 = *(double *)(a1 + 32);
      }
      if (v14 > 0.0)
      {
        if ((v12 & 0xF) != 0 && (v13 & 9) != 0)
        {
          v77.i64[0] = (uint64_t)&unk_1ED030FC0;
          v77.i64[1] = a1 + 276;
          *(void *)&long long v78 = a1 + 344;
          *((void *)&v78 + 1) = a1 + 376;
          *(void *)&long long v79 = a1 + 320;
LABEL_50:
          goto LABEL_51;
        }
      }
    }
    else if ((*(_WORD *)(a3 + 58) & 0x18) != 8 || (v7[4].i8[1] & 4) != 0)
    {
      double v42 = *(double *)(a1 + 24);
      if (v42 >= *(double *)(a1 + 32)) {
        double v42 = *(double *)(a1 + 32);
      }
      if (v42 > 0.0)
      {
        if ((v12 & 0xF) != 0 && (v13 & 9) != 0)
        {
          v77.i64[0] = (uint64_t)&unk_1ED030FA8;
          v77.i64[1] = a1 + 276;
          *(void *)&long long v78 = a1 + 320;
          goto LABEL_50;
        }
      }
    }
    else
    {
      v31.f64[0] = *(float64_t *)(a1 + 320);
      v32.f64[0] = *(float64_t *)(a1 + 264);
      v31.f64[1] = v32.f64[0];
      v32.f64[1] = *(float64_t *)(a1 + 328);
      v33.i64[0] = (int)*(void *)a1;
      v33.i64[1] = (int)HIDWORD(*(void *)a1);
      __asm { FMOV            V4.2D, #1.0 }
      float64x2_t v38 = vdivq_f64(_Q4, vcvtq_f64_s64(v33));
      float32x4_t v39 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmulq_f64(*(float64x2_t *)(a1 + 8), v38)), vmulq_f64(vmlaq_f64(*(float64x2_t *)(a1 + 8), v32, vmulq_f64(v31, *(float64x2_t *)(a1 + 24))), v38));
      *(float32x2_t *)v40.f32 = *v7;
      *(float32x2_t *)&v32.f64[0] = vsub_f32(v7[1], *v7);
      v32.f64[1] = v32.f64[0];
      *(float32x2_t *)&v40.u32[2] = *v7;
      float32x4_t v41 = vmlaq_f32(v40, v39, (float32x4_t)v32);
      *(float32x2_t *)v39.f32 = vrndm_f32(*(float32x2_t *)v41.f32);
      v39.i64[1] = v39.i64[0];
      float32x4_t v77 = vsubq_f32(v41, v39);
      CA::OGL::fill_rect_tex((CA::OGL::Context *)a2, (uint64_t)v58, (uint64_t)&v77, a4);
    }
  }
  else if (*(unsigned char *)(a1 + 337))
  {
    double v16 = *(double *)(a1 + 24);
    double v17 = *(double *)(a1 + 32);
    if (v16 >= v17) {
      double v18 = *(double *)(a1 + 32);
    }
    else {
      double v18 = *(double *)(a1 + 24);
    }
    if (v18 > 0.0)
    {
      double v63 = 0.0;
      double v64 = 0.0;
      CA::Transform::get_scale_recip((uint64_t)v8, &v64, &v63);
      double v23 = v17 * v16 / (v63 * v64);
      if ((v12 & 0xF) == 0 || (v13 & 9) == 0)
      {
        float32x4_t v77 = 0uLL;
        long long v78 = 0uLL;
        long long v74 = 0uLL;
        long long v75 = 0uLL;
        double v71 = 0.0;
        uint64_t v72 = 0;
        double v68 = 0.0;
        uint64_t v69 = 0;
        int32x2_t v25 = a2[2];
        unint64_t v26 = *(void *)(*(void *)&v25 + 16) & 0xFFFFFF00FF00FF00;
        if (*(void *)(*(void *)&v25 + 8) == 0x3C003C003C003C00) {
          int v27 = 1;
        }
        else {
          int v27 = 3;
        }
        *(_DWORD *)(*(void *)&v25 + 16) = v27 | v26;
        *(_DWORD *)(*(void *)&v25 + 20) = HIDWORD(v26);
        CA::OGL::emit_n_part_rect((uint64_t)a2, (uint64_t)v58, v28, v30, (float64_t *)v77.i64, (uint64_t)&v74, &v71, (uint64_t)&v68, 0, 0, (v23 >= *(double *)&a2[9]) << 16);
      }
      else
      {
        long long v78 = 0uLL;
        long long v79 = 0uLL;
        long long v76 = 0uLL;
        float32x4_t v77 = 0uLL;
        long long v74 = 0uLL;
        long long v75 = 0uLL;
        double v71 = 0.0;
        uint64_t v72 = 0;
        uint64_t v73 = 0;
        double v68 = 0.0;
        uint64_t v69 = 0;
        uint64_t v70 = 0;
        memset(v67, 0, sizeof(v67));
        memset(v66, 0, sizeof(v66));
        uint64_t v65 = 0;
        *(unsigned char *)(*(void *)&a2[2] + 16) = 5;
        BOOL v44 = !CA::Transform::is_isotropic(v8, 0.0, v19, v20, v21);
        (*(void (**)(int32x2_t *, uint64_t, BOOL, void, uint64_t *))(*(void *)a2 + 448))(a2, 1, v44, 0, &v65);
        double v48 = *(double *)(a1 + 24);
        double v49 = *(double *)(a1 + 32);
        if (v64 + v64 >= v48 * 0.5) {
          v46.f64[0] = v48 * 0.5;
        }
        else {
          v46.f64[0] = v64 + v64;
        }
        if (v63 + v63 >= v49 * 0.5) {
          double v50 = v49 * 0.5;
        }
        else {
          double v50 = v63 + v63;
        }
        v52.f64[0] = v50;
        CA::OGL::emit_n_part_rect((uint64_t)a2, (uint64_t)v58, v51, v55, (float64_t *)v77.i64, (uint64_t)&v74, &v71, (uint64_t)&v68, v67, (uint64_t)v66, (v23 >= *(double *)&a2[9]) << 16);
        (*(void (**)(int32x2_t *, void, uint64_t))(*(void *)a2 + 520))(a2, 0, 1);
      }
      *(unsigned char *)(*(void *)&a2[2] + 16) = 0;
    }
  }
  else
  {
    CA::OGL::ContentsGeometry::fill_geometry(a1, (CA::OGL::Context *)a2, v58, (float32x2_t *)(a1 + 276));
  }
LABEL_51:
  uint64_t result = (*(uint64_t (**)(int32x2_t *, uint64_t, void))(*(void *)a2 + 520))(a2, a3, 0);
  *(unsigned char *)(*(void *)&a2[2] + 481) &= ~2u;
  return result;
}

CA::OGL::Context *CA::OGL::fill_rect_tex(CA::OGL::Context *result, uint64_t a2, uint64_t a3, double *a4)
{
  uint64_t v6 = (uint64_t)result;
  uint64_t v179 = *MEMORY[0x1E4F143B8];
  int v7 = *(_DWORD *)(a2 + 16);
  int v8 = *(_DWORD *)(a2 + 20);
  BOOL v9 = (v8 & 0xF) == 0;
  if ((v7 & 9) == 0) {
    BOOL v9 = 1;
  }
  int v10 = v7 & 0x100000;
  if (v9 && v10 == 0) {
    goto LABEL_18;
  }
  char v12 = *(float64x2_t **)a2;
  double v13 = *(double *)(*(void *)a2 + 16);
  if (v13 >= *(double *)(*(void *)a2 + 24)) {
    double v13 = *(double *)(*(void *)a2 + 24);
  }
  if (v13 > 0.0)
  {
    double v14 = *(const CA::Transform **)(a2 + 8);
    if ((*((unsigned char *)v14 + 144) & 0x1F) != 0 || *(void *)(a2 + 24) != 0 || *(void *)(a2 + 32) != 0)
    {
      if (!v9)
      {
        memset(v164, 0, 32);
        memset(v174, 0, 32);
        double v159 = 0.0;
        uint64_t v160 = 0;
        *(unsigned char *)(*((void *)result + 2) + 16) = 5;
        BOOL v67 = !CA::Transform::is_isotropic(*(CA::Transform **)(a2 + 8), 0.0, (uint64_t)v14, a3, a4);
        (*(void (**)(uint64_t, uint64_t, BOOL, void, uint64_t *))(*(void *)v6 + 448))(v6, 1, v67, 0, &v160);
        double v68 = *(float64x2_t **)a2;
        double v69 = v68[1].f64[1];
        float v70 = 1.0 / v68[1].f64[0];
        v71.i32[1] = *(_DWORD *)&v164[12];
        v71.i32[0] = *(_DWORD *)a3;
        v72.i32[0] = *(_DWORD *)(a3 + 4);
        float v73 = *(float *)(a3 + 8);
        float v74 = *(float *)(a3 + 12);
        *(float32x2_t *)((char *)v177.f64 + 4) = vmla_n_f32((float32x2_t)vdup_lane_s32(v71, 0), vcvt_f32_f64(vmulq_n_f64(vsubq_f64(*(float64x2_t *)&v164[8], (float64x2_t)vdupq_lane_s64(*(uint64_t *)v164, 0)), v70)), v73 - *(float *)a3);
        *(float *)&v176.i32[3] = v74;
        LODWORD(v177.f64[0]) = v71.i32[0];
        *((float *)&v177.f64[1] + 1) = v73;
        float v75 = 1.0 / v69;
        *(float32x2_t *)((char *)v176.i64 + 4) = vmla_n_f32((float32x2_t)vdup_lane_s32(v72, 0), vcvt_f32_f64(vmulq_n_f64(vsubq_f64(*(float64x2_t *)&v174[8], (float64x2_t)vdupq_lane_s64(*(uint64_t *)v174, 0)), v75)), v74 - *(float *)v72.i32);
        v176.i32[0] = v72.i32[0];
        float v76 = *(float *)&v160;
        int v77 = *(_DWORD *)(a2 + 20);
        if (v77) {
          float v78 = *(float *)&v160;
        }
        else {
          float v78 = *(float *)&v160 + (float)((float)(*((float *)&v160 + 1) - *(float *)&v160) * 0.5);
        }
        *(float *)v172.i32 = v78;
        *(float *)&v172.i32[1] = *(float *)&v160 + (float)((float)(*((float *)&v160 + 1) - *(float *)&v160) * 0.5);
        if ((v77 & 2) != 0) {
          float v79 = *((float *)&v160 + 1);
        }
        else {
          float v79 = *(float *)&v160 + (float)((float)(*((float *)&v160 + 1) - *(float *)&v160) * 0.5);
        }
        *(float *)&uint64_t v173 = *(float *)&v160 + (float)((float)(*((float *)&v160 + 1) - *(float *)&v160) * 0.5);
        *((float *)&v173 + 1) = v79;
        if ((v77 & 4) == 0) {
          float v76 = *(float *)&v160 + (float)((float)(*((float *)&v160 + 1) - *(float *)&v160) * 0.5);
        }
        *(float *)&uint64_t v161 = v76;
        *((float *)&v161 + 1) = *(float *)&v160 + (float)((float)(*((float *)&v160 + 1) - *(float *)&v160) * 0.5);
        if ((v77 & 8) != 0) {
          float v80 = *((float *)&v160 + 1);
        }
        else {
          float v80 = *(float *)&v160 + (float)((float)(*((float *)&v160 + 1) - *(float *)&v160) * 0.5);
        }
        float v162 = *(float *)&v160 + (float)((float)(*((float *)&v160 + 1) - *(float *)&v160) * 0.5);
        float v163 = v80;
        CA::OGL::emit_nine_part_rect(v6, a2, (uint64_t)v164, (uint64_t)v174, (uint64_t)&v177, (uint64_t)&v176, (uint64_t)&v172, (uint64_t)&v161, (v159 >= *(double *)(v6 + 72)) << 16);
        uint64_t result = (CA::OGL::Context *)(*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v6 + 520))(v6, 0, 1);
        goto LABEL_22;
      }
LABEL_18:
      uint64_t v17 = *((void *)result + 2);
      unint64_t v18 = *(void *)(v17 + 16) & 0xFFFFFF00FF00FF00;
      if (*(void *)(v17 + 8) == 0x3C003C003C003C00) {
        int v19 = 1;
      }
      else {
        int v19 = 3;
      }
      *(_DWORD *)(v17 + 16) = v19 | v18;
      *(_DWORD *)(v17 + 20) = HIDWORD(v18);
      uint64_t result = CA::OGL::emit_one_part_rect(result, a2, (const CA::Transform *)a3, 0, 0);
LABEL_22:
      *(unsigned char *)(*(void *)(v6 + 16) + 16) = 0;
      return result;
    }
    float64x2_t v20 = v12[1];
    float64x2_t v177 = *v12;
    float64x2_t v178 = v20;
    CA::Rect::apply_transform((int8x16_t *)&v177, v14, (double *)a3);
    float v21 = *(float16x4_t **)(v6 + 16);
    float16x4_t v22 = v21[1];
    double v23 = v178.f64[0] + v177.f64[0];
    double v24 = v178.f64[1] + v177.f64[1];
    double v25 = round(v177.f64[0]);
    double v26 = floor(v177.f64[0]);
    double v27 = ceil(v177.f64[0]);
    if (v8) {
      float64_t v28 = v27;
    }
    else {
      float64_t v28 = v25;
    }
    if (v8) {
      float64_t v29 = v26;
    }
    else {
      float64_t v29 = v25;
    }
    double v30 = round(v23);
    v31.f64[0] = floor(v23);
    double v32 = ceil(v23);
    if ((v8 & 2) == 0)
    {
      double v32 = v30;
      v31.f64[0] = v30;
    }
    double v153 = v32;
    double v154 = v29;
    v33.f64[0] = v29;
    double v157 = v31.f64[0];
    double v158 = v28;
    v33.f64[1] = v28;
    v31.f64[1] = v32;
    double v34 = round(v177.f64[1]);
    double v35 = floor(v177.f64[1]);
    double v36 = ceil(v177.f64[1]);
    if ((v8 & 4) != 0) {
      float64_t v37 = v36;
    }
    else {
      float64_t v37 = v34;
    }
    if ((v8 & 4) != 0) {
      float64_t v38 = v35;
    }
    else {
      float64_t v38 = v34;
    }
    double v39 = round(v24);
    v40.f64[0] = floor(v24);
    double v41 = ceil(v24);
    if ((v8 & 8) == 0)
    {
      double v41 = v39;
      v40.f64[0] = v39;
    }
    double v146 = v38;
    double v147 = v41;
    v42.f64[0] = v38;
    double v155 = v40.f64[0];
    double v156 = v37;
    v42.f64[1] = v37;
    v40.f64[1] = v41;
    float v43 = *(float *)(a3 + 4);
    double v44 = (float)(*(float *)(a3 + 12) - v43);
    double v137 = v177.f64[0];
    float64x2_t v45 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v177.f64[0], 0);
    float64x2_t v46 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(*(float *)a3), 0);
    double v150 = v177.f64[1];
    float64x2_t v47 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v177.f64[1], 0);
    double v48 = (float)(*(float *)(a3 + 8) - *(float *)a3);
    float64x2_t v49 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(v43), 0);
    float64x2_t v50 = vmulq_n_f64(vsubq_f64(v33, v45), v48);
    float64x2_t v51 = vmulq_n_f64(vsubq_f64(v31, v45), v48);
    __asm { FMOV            V7.2D, #1.0 }
    float64x2_t v56 = vdivq_f64(_Q7, (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v178.f64[0], 0));
    float32x4_t v145 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmlaq_f64(v46, v56, v50)), vmlaq_f64(v46, v56, v51));
    float64x2_t v57 = vdivq_f64(_Q7, (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v178.f64[1], 0));
    float32x4_t v144 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmlaq_f64(v49, v57, vmulq_n_f64(vsubq_f64(v42, v47), v44))), vmlaq_f64(v49, v57, vmulq_n_f64(vsubq_f64(v40, v47), v44)));
    int64x2_t v58 = vceqzq_f64(v178);
    if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v58, 1), (int8x16_t)v58).u64[0] & 0x8000000000000000) != 0
      || (int8x16_t v59 = vorrq_s8((int8x16_t)vcltzq_f64(v178), (int8x16_t)vcgezq_f64(v178)),
          (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v59), 1), v59).u64[0] & 0x8000000000000000) != 0))
    {
      int32x4_t v176 = 0uLL;
    }
    else
    {
      int32x4_t v60 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v177, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
      int32x4_t v176 = vuzp1q_s32(v60, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v177, v178), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v60));
    }
    BOOL v61 = CA::OGL::Context::need_transparent_source((CA::OGL::Context *)v6);
    unsigned int v62 = *(_DWORD *)(a2 + 16) & 0x40000;
    v21[2].i8[0] = 3;
    int v63 = *(_DWORD *)(a2 + 16);
    uint64_t v64 = *(void *)(v6 + 16);
    if ((v63 & 0x10000) != 0)
    {
      unint64_t v81 = *(void *)(v64 + 16) & 0xFFFFFF00FF00FF00;
      if (*(void *)(v64 + 8) == 0x3C003C003C003C00) {
        int v82 = 1;
      }
      else {
        int v82 = 3;
      }
      *(_DWORD *)(v64 + 16) = v82 | v81;
      *(_DWORD *)(v64 + 20) = HIDWORD(v81);
      uint64_t v64 = *(void *)(v6 + 16);
      char v66 = *(unsigned char *)(v64 + 481);
      if ((v66 & 1) == 0)
      {
        char v83 = 1;
        goto LABEL_68;
      }
      if ((*(unsigned char *)(a2 + 17) & 0x80) == 0)
      {
        char v83 = 0;
        goto LABEL_68;
      }
    }
    else
    {
      int v65 = 1;
      if ((v63 & 0x8000) == 0 || (char v66 = *(unsigned char *)(v64 + 481), (v66 & 1) == 0))
      {
LABEL_85:
        int v92 = v61 | (v62 >> 18);
        long long v175 = 0u;
        uint64_t v93 = *(void *)(*(void *)(v6 + 248) + 8);
        *(void *)char v174 = v6;
        *(void *)&v174[8] = v93;
        memset(&v174[16], 0, 24);
        *(_WORD *)&v174[32] = 256;
        *(void *)&long long v175 = &v176;
        CA::OGL::Context::ClippedArray::start((CA::OGL::Context::ClippedArray *)v174);
        uint64_t v173 = 0;
        int32x2_t v172 = 0;
        uint64_t v94 = v6 + 834;
        float v95 = v146;
        float v96 = v156;
        float v152 = v96;
        float v97 = v156 - v150;
        *(float *)&uint64_t v102 = v155;
        float v151 = *(float *)&v102;
        *(float *)&uint64_t v102 = v154;
        float v141 = *(float *)&v102;
        float v143 = v95;
        *(float *)&uint64_t v102 = v158;
        float v149 = *(float *)&v102;
        *(float *)&uint64_t v102 = v147;
        float v139 = *(float *)&v102;
        float v98 = v158 - v137;
        float v99 = v24 - v155;
        float v133 = v98 * v99;
        float v134 = v99;
        float v100 = v157;
        *(float *)&uint64_t v102 = v153;
        float v138 = *(float *)&v102;
        float v101 = v23 - v157;
        float v131 = v101 * v99;
        float v132 = v101;
        float v135 = v98;
        float v136 = v97;
        float v130 = v98 * v97;
        LODWORD(v102) = v145.i32[0];
        float v129 = v101 * v97;
        if (v157 > v158) {
          int v103 = v65;
        }
        else {
          int v103 = 0;
        }
        HIDWORD(v102) = v144.i32[1];
        uint64_t v128 = v102;
        while (1)
        {
          uint64_t result = (CA::OGL::Context *)CA::OGL::Context::ClippedArray::next_rect((CA::OGL::Context::ClippedArray *)v174, &v172);
          if (!result) {
            break;
          }
          if (v156 > v146)
          {
            if (*(_DWORD *)(v6 + 92)) {
              uint64_t v104 = 18;
            }
            else {
              uint64_t v104 = 12;
            }
            if ((unint64_t)(*(void *)(v6 + 128) + 12) > *(void *)(v6 + 136)
              || (unint64_t v105 = *(void *)(v6 + 112)) != 0 && *(void *)(v6 + 104) + v104 > v105)
            {
              *(_WORD *)(v6 + 832) |= 0x20u;
              CA::OGL::Context::array_flush(v6);
              *(void *)(v6 + 128) = 0;
              *(void *)(v6 + 96) = v94;
              *(_OWORD *)(v6 + 104) = xmmword_184997E70;
            }
            if (v158 > v154)
            {
              CA::OGL::Context::array_rect((void *)v6, v141, v143, v149, v152);
              uint64_t v106 = *(void *)(v6 + 120) + 48 * *(void *)(v6 + 128);
              *(_DWORD *)(v106 - 176) = v145.i32[0];
              *(_DWORD *)(v106 - 172) = v144.i32[0];
              *(_DWORD *)(v106 - 128) = v145.i32[1];
              *(_DWORD *)(v106 - 124) = v144.i32[0];
              *(_DWORD *)(v106 - 80) = v145.i32[1];
              *(_DWORD *)(v106 - 76) = v144.i32[1];
              *(_DWORD *)(v106 - 32) = v145.i32[0];
              *(_DWORD *)(v106 - 28) = v144.i32[1];
              float16x4_t v107 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(v22), v130));
              *(float16x4_t *)(v106 - 160) = v107;
              *(float16x4_t *)(v106 - 112) = v107;
              *(float16x4_t *)(v106 - 64) = v107;
              *(float16x4_t *)(v106 - 16) = v107;
            }
            if (v157 > v158)
            {
              CA::OGL::Context::array_rect((void *)v6, v149, v143, v100, v152);
              uint64_t v108 = *(void *)(v6 + 120) + 48 * *(void *)(v6 + 128);
              *(_DWORD *)(v108 - 176) = v145.i32[1];
              *(_DWORD *)(v108 - 172) = v144.i32[0];
              *(_DWORD *)(v108 - 128) = v145.i32[2];
              *(_DWORD *)(v108 - 124) = v144.i32[0];
              *(_DWORD *)(v108 - 80) = v145.i32[2];
              *(_DWORD *)(v108 - 76) = v144.i32[1];
              *(_DWORD *)(v108 - 32) = v145.i32[1];
              *(_DWORD *)(v108 - 28) = v144.i32[1];
              float16x4_t v109 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(v22), v136));
              *(float16x4_t *)(v108 - 160) = v109;
              *(float16x4_t *)(v108 - 112) = v109;
              *(float16x4_t *)(v108 - 64) = v109;
              *(float16x4_t *)(v108 - 16) = v109;
            }
            if (v153 > v157)
            {
              CA::OGL::Context::array_rect((void *)v6, v100, v143, v138, v152);
              uint64_t v110 = *(void *)(v6 + 120) + 48 * *(void *)(v6 + 128);
              *(_DWORD *)(v110 - 176) = v145.i32[2];
              *(_DWORD *)(v110 - 172) = v144.i32[0];
              *(_DWORD *)(v110 - 128) = v145.i32[3];
              *(_DWORD *)(v110 - 124) = v144.i32[0];
              *(_DWORD *)(v110 - 80) = v145.i32[3];
              *(_DWORD *)(v110 - 76) = v144.i32[1];
              *(_DWORD *)(v110 - 32) = v145.i32[2];
              *(_DWORD *)(v110 - 28) = v144.i32[1];
              float16x4_t v111 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(v22), v129));
              *(float16x4_t *)(v110 - 160) = v111;
              *(float16x4_t *)(v110 - 112) = v111;
              *(float16x4_t *)(v110 - 64) = v111;
              *(float16x4_t *)(v110 - 16) = v111;
            }
          }
          if (v155 > v156)
          {
            if (*(_DWORD *)(v6 + 92)) {
              uint64_t v112 = 18;
            }
            else {
              uint64_t v112 = 12;
            }
            if ((unint64_t)(*(void *)(v6 + 128) + 12) > *(void *)(v6 + 136)
              || (unint64_t v113 = *(void *)(v6 + 112)) != 0 && *(void *)(v6 + 104) + v112 > v113)
            {
              *(_WORD *)(v6 + 832) |= 0x20u;
              CA::OGL::Context::array_flush(v6);
              *(void *)(v6 + 128) = 0;
              *(void *)(v6 + 96) = v94;
              *(_OWORD *)(v6 + 104) = xmmword_184997E70;
            }
            if (v158 > v154)
            {
              CA::OGL::Context::array_rect((void *)v6, v141, v152, v149, v151);
              uint64_t v114 = *(void *)(v6 + 120) + 48 * *(void *)(v6 + 128);
              *(void *)(v114 - 176) = v128;
              *(_DWORD *)(v114 - 128) = v145.i32[1];
              *(_DWORD *)(v114 - 124) = v144.i32[1];
              *(_DWORD *)(v114 - 80) = v145.i32[1];
              *(_DWORD *)(v114 - 76) = v144.i32[2];
              *(_DWORD *)(v114 - 32) = v145.i32[0];
              *(_DWORD *)(v114 - 28) = v144.i32[2];
              float16x4_t v115 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(v22), v135));
              *(float16x4_t *)(v114 - 160) = v115;
              *(float16x4_t *)(v114 - 112) = v115;
              *(float16x4_t *)(v114 - 64) = v115;
              *(float16x4_t *)(v114 - 16) = v115;
            }
            if (v103)
            {
              CA::OGL::Context::array_rect((void *)v6, v149, v152, v100, v151);
              uint64_t v116 = *(void *)(v6 + 120) + 48 * *(void *)(v6 + 128);
              *(_DWORD *)(v116 - 176) = v145.i32[1];
              *(_DWORD *)(v116 - 172) = v144.i32[1];
              *(_DWORD *)(v116 - 128) = v145.i32[2];
              *(_DWORD *)(v116 - 124) = v144.i32[1];
              *(_DWORD *)(v116 - 80) = v145.i32[2];
              *(_DWORD *)(v116 - 76) = v144.i32[2];
              *(_DWORD *)(v116 - 32) = v145.i32[1];
              *(_DWORD *)(v116 - 28) = v144.i32[2];
              *(float16x4_t *)(v116 - 160) = v22;
              *(float16x4_t *)(v116 - 112) = v22;
              *(float16x4_t *)(v116 - 64) = v22;
              *(float16x4_t *)(v116 - 16) = v22;
            }
            if (v153 > v157)
            {
              CA::OGL::Context::array_rect((void *)v6, v100, v152, v138, v151);
              uint64_t v117 = *(void *)(v6 + 120) + 48 * *(void *)(v6 + 128);
              *(_DWORD *)(v117 - 176) = v145.i32[2];
              *(_DWORD *)(v117 - 172) = v144.i32[1];
              *(_DWORD *)(v117 - 128) = v145.i32[3];
              *(_DWORD *)(v117 - 124) = v144.i32[1];
              *(_DWORD *)(v117 - 80) = v145.i32[3];
              *(_DWORD *)(v117 - 76) = v144.i32[2];
              *(_DWORD *)(v117 - 32) = v145.i32[2];
              *(_DWORD *)(v117 - 28) = v144.i32[2];
              float16x4_t v118 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(v22), v132));
              *(float16x4_t *)(v117 - 160) = v118;
              *(float16x4_t *)(v117 - 112) = v118;
              *(float16x4_t *)(v117 - 64) = v118;
              *(float16x4_t *)(v117 - 16) = v118;
            }
          }
          if (v147 > v155)
          {
            if (*(_DWORD *)(v6 + 92)) {
              uint64_t v119 = 18;
            }
            else {
              uint64_t v119 = 12;
            }
            if ((unint64_t)(*(void *)(v6 + 128) + 12) > *(void *)(v6 + 136)
              || (unint64_t v120 = *(void *)(v6 + 112)) != 0 && *(void *)(v6 + 104) + v119 > v120)
            {
              *(_WORD *)(v6 + 832) |= 0x20u;
              CA::OGL::Context::array_flush(v6);
              *(void *)(v6 + 128) = 0;
              *(void *)(v6 + 96) = v94;
              *(_OWORD *)(v6 + 104) = xmmword_184997E70;
            }
            if (v158 > v154)
            {
              CA::OGL::Context::array_rect((void *)v6, v141, v151, v149, v139);
              uint64_t v121 = *(void *)(v6 + 120) + 48 * *(void *)(v6 + 128);
              *(_DWORD *)(v121 - 176) = v145.i32[0];
              *(_DWORD *)(v121 - 172) = v144.i32[2];
              *(_DWORD *)(v121 - 128) = v145.i32[1];
              *(_DWORD *)(v121 - 124) = v144.i32[2];
              *(_DWORD *)(v121 - 80) = v145.i32[1];
              *(_DWORD *)(v121 - 76) = v144.i32[3];
              *(_DWORD *)(v121 - 32) = v145.i32[0];
              *(_DWORD *)(v121 - 28) = v144.i32[3];
              float16x4_t v122 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(v22), v133));
              *(float16x4_t *)(v121 - 160) = v122;
              *(float16x4_t *)(v121 - 112) = v122;
              *(float16x4_t *)(v121 - 64) = v122;
              *(float16x4_t *)(v121 - 16) = v122;
            }
            if (v157 > v158)
            {
              CA::OGL::Context::array_rect((void *)v6, v149, v151, v100, v139);
              uint64_t v123 = *(void *)(v6 + 120) + 48 * *(void *)(v6 + 128);
              *(_DWORD *)(v123 - 176) = v145.i32[1];
              *(_DWORD *)(v123 - 172) = v144.i32[2];
              *(_DWORD *)(v123 - 128) = v145.i32[2];
              *(_DWORD *)(v123 - 124) = v144.i32[2];
              *(_DWORD *)(v123 - 80) = v145.i32[2];
              *(_DWORD *)(v123 - 76) = v144.i32[3];
              *(_DWORD *)(v123 - 32) = v145.i32[1];
              *(_DWORD *)(v123 - 28) = v144.i32[3];
              float16x4_t v124 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(v22), v134));
              *(float16x4_t *)(v123 - 160) = v124;
              *(float16x4_t *)(v123 - 112) = v124;
              *(float16x4_t *)(v123 - 64) = v124;
              *(float16x4_t *)(v123 - 16) = v124;
            }
            if (v153 > v157)
            {
              CA::OGL::Context::array_rect((void *)v6, v100, v151, v138, v139);
              uint64_t v125 = *(void *)(v6 + 120) + 48 * *(void *)(v6 + 128);
              *(_DWORD *)(v125 - 176) = v145.i32[2];
              *(_DWORD *)(v125 - 172) = v144.i32[2];
              *(_DWORD *)(v125 - 128) = v145.i32[3];
              *(_DWORD *)(v125 - 124) = v144.i32[2];
              *(_DWORD *)(v125 - 80) = v145.i32[3];
              *(_DWORD *)(v125 - 76) = v144.i32[3];
              *(_DWORD *)(v125 - 32) = v145.i32[2];
              *(_DWORD *)(v125 - 28) = v144.i32[3];
              float16x4_t v126 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(v22), v131));
              *(float16x4_t *)(v125 - 160) = v126;
              *(float16x4_t *)(v125 - 112) = v126;
              *(float16x4_t *)(v125 - 64) = v126;
              *(float16x4_t *)(v125 - 16) = v126;
            }
          }
        }
        if (v92)
        {
          *(double *)float64x2_t v164 = v154;
          *(double *)&v164[8] = v146;
          *(_OWORD *)&v164[16] = xmmword_184997D60;
          *(double *)&v164[32] = v153;
          *(double *)float64x2_t v165 = v146;
          *(_OWORD *)&v165[8] = xmmword_184997D60;
          double v166 = v153;
          double v167 = v147;
          long long v168 = xmmword_184997D60;
          double v169 = v154;
          double v170 = v147;
          long long v171 = xmmword_184997D60;
          if ((*(unsigned char *)(a2 + 18) & 4) != 0) {
            uint64_t v127 = *(void *)(*(void *)(v6 + 16) + 8);
          }
          else {
            uint64_t v127 = 0;
          }
          uint64_t v161 = v127;
          uint64_t result = (CA::OGL::Context *)CA::OGL::emit_quad_surround(v6, (const double *)v164, &v161);
        }
        goto LABEL_22;
      }
    }
    char v83 = 0;
    *(unsigned char *)(v64 + 481) = v66 & 0xFE;
LABEL_68:
    if (v155 > v156 && v157 > v158)
    {
      unsigned int v140 = v62;
      double v142 = v24;
      double v148 = v23;
      *(_OWORD *)float64x2_t v165 = 0u;
      uint64_t v84 = *(void *)(*(void *)(v6 + 248) + 8);
      *(void *)float64x2_t v164 = v6;
      *(void *)&v164[8] = v84;
      memset(&v164[16], 0, 24);
      *(_WORD *)&v164[32] = 256;
      *(void *)float64x2_t v165 = &v176;
      CA::OGL::Context::ClippedArray::start((CA::OGL::Context::ClippedArray *)v164);
      *(_OWORD *)char v174 = 0uLL;
      while (CA::OGL::Context::ClippedArray::next_rect((CA::OGL::Context::ClippedArray *)v164, (int32x2_t *)v174))
      {
        if (*(_DWORD *)(v6 + 92)) {
          uint64_t v89 = 6;
        }
        else {
          uint64_t v89 = 4;
        }
        if ((unint64_t)(*(void *)(v6 + 128) + 4) > *(void *)(v6 + 136)
          || (unint64_t v90 = *(void *)(v6 + 112)) != 0 && *(void *)(v6 + 104) + v89 > v90)
        {
          *(_WORD *)(v6 + 832) |= 0x20u;
          CA::OGL::Context::array_flush(v6);
          *(void *)(v6 + 128) = 0;
          *(void *)(v6 + 96) = v6 + 834;
          *(_OWORD *)(v6 + 104) = xmmword_184997E70;
        }
        float v85 = v158;
        float v86 = v156;
        float v87 = v157;
        float v88 = v155;
        CA::OGL::Context::array_rect((void *)v6, v85, v86, v87, v88);
        uint64_t v91 = *(void *)(v6 + 120) + 48 * *(void *)(v6 + 128);
        *(_DWORD *)(v91 - 176) = v145.i32[1];
        *(_DWORD *)(v91 - 172) = v144.i32[1];
        *(_DWORD *)(v91 - 128) = v145.i32[2];
        *(_DWORD *)(v91 - 124) = v144.i32[1];
        *(_DWORD *)(v91 - 80) = v145.i32[2];
        *(_DWORD *)(v91 - 76) = v144.i32[2];
        *(_DWORD *)(v91 - 32) = v145.i32[1];
        *(_DWORD *)(v91 - 28) = v144.i32[2];
        *(float16x4_t *)(v91 - 160) = v22;
        *(float16x4_t *)(v91 - 112) = v22;
        *(float16x4_t *)(v91 - 64) = v22;
        *(float16x4_t *)(v91 - 16) = v22;
      }
      double v23 = v148;
      double v24 = v142;
      unsigned int v62 = v140;
    }
    if ((v83 & 1) == 0) {
      *(unsigned char *)(*(void *)(v6 + 16) + 481) |= 1u;
    }
    int v65 = 0;
    if (*(unsigned char *)(a2 + 18)) {
      *(unsigned char *)(*(void *)(v6 + 16) + 16) = 3;
    }
    goto LABEL_85;
  }
  return result;
}

CA::OGL::Context *CA::OGL::emit_one_part_rect(CA::OGL::Context *result, uint64_t a2, const CA::Transform *a3, uint64_t a4, int a5)
{
  v38[4] = *(double *)MEMORY[0x1E4F143B8];
  uint64_t v5 = *(double **)a2;
  double v7 = *(double *)(*(void *)a2 + 16);
  double v6 = *(double *)(*(void *)a2 + 24);
  if (v7 >= v6) {
    double v8 = *(double *)(*(void *)a2 + 24);
  }
  else {
    double v8 = *(double *)(*(void *)a2 + 16);
  }
  if (v8 > 0.0)
  {
    double v13 = result;
    v29[0] = 0;
    v29[1] = 0;
    double v15 = v5[1];
    v38[0] = *v5;
    double v14 = v38[0];
    v38[1] = v15;
    double v16 = v38[0] + v7;
    double v17 = v15 + v6;
    v38[2] = v38[0] + v7;
    v38[3] = v15 + v6;
    unsigned int v18 = CA::OGL::Context::need_transparent_source(result) | ((a5 & 0x40000u) >> 18);
    if (*(_OWORD *)(a2 + 24) == 0)
    {
      *(_OWORD *)float64x2_t v31 = 0u;
      BOOL v19 = ((*(unsigned __int8 *)(*(void *)(a2 + 8) + 144) >> 4) & 1) == 0;
      uint64_t v20 = *(void *)(*((void *)v13 + 31) + 8);
      v30[0] = v13;
      v30[1] = v20;
      memset(&v30[2], 0, 24);
      LOBYTE(v30[4]) = v19;
      BYTE1(v30[4]) = 1;
      CA::OGL::Context::ClippedArray::start((CA::OGL::Context::ClippedArray *)v30);
      while (1)
      {
        uint64_t result = (CA::OGL::Context *)CA::OGL::Context::ClippedArray::next_rect((CA::OGL::Context::ClippedArray *)v30, v29);
        if (!result) {
          break;
        }
        CA::OGL::emit_quad(v13, (CA::OGL::Context *)v38, (const double *)v29, *(const CA::Bounds **)(a2 + 8), a3, (float *)a4, v21);
      }
    }
    else
    {
      float16x4_t v22 = (float32x4_t *)*((void *)v13 + 15);
      *(double *)double v30 = v38[0];
      *(double *)&v30[1] = v15;
      *(double *)&v30[4] = v16;
      *(double *)float64x2_t v31 = v15;
      double v32 = v38[0];
      double v33 = v17;
      double v35 = v16;
      double v36 = v17;
      long long v37 = xmmword_184997D60;
      long long v34 = xmmword_184997D60;
      *(_OWORD *)&v31[8] = xmmword_184997D60;
      *(_OWORD *)&v30[2] = xmmword_184997D60;
      if (a3)
      {
        v22[1].i32[0] = *(_DWORD *)a3;
        v22[1].i32[1] = *((_DWORD *)a3 + 1);
        v22[4].i32[0] = *((_DWORD *)a3 + 2);
        v22[4].i32[1] = *((_DWORD *)a3 + 1);
        v22[7].i32[0] = *(_DWORD *)a3;
        v22[7].i32[1] = *((_DWORD *)a3 + 3);
        v22[10].i32[0] = *((_DWORD *)a3 + 2);
        v22[10].i32[1] = *((_DWORD *)a3 + 3);
      }
      if (a4)
      {
        v22[1].i32[2] = *(_DWORD *)a4;
        v22[1].i32[3] = *(_DWORD *)(a4 + 4);
        v22[4].i32[2] = *(_DWORD *)(a4 + 8);
        v22[4].i32[3] = *(_DWORD *)(a4 + 4);
        v22[7].i32[2] = *(_DWORD *)a4;
        v22[7].i32[3] = *(_DWORD *)(a4 + 12);
        v22[10].i32[2] = *(_DWORD *)(a4 + 8);
        v22[10].i32[3] = *(_DWORD *)(a4 + 12);
      }
      uint64_t v23 = *(void *)(*((void *)v13 + 2) + 8);
      for (uint64_t i = 2; i != 14; i += 3)
        v22[i].i64[0] = v23;
      double v25 = *(void (**)(uint64_t, void *, float32x4_t *, uint64_t))(a2 + 24);
      if (v25) {
        v25(a2, v30, v22, 4);
      }
      CA::OGL::transform_vertices((float64x2_t *)v30, v22, (const double *)4, *(float64x2_t **)(a2 + 8));
      double v26 = *(void (**)(uint64_t, float32x4_t *, uint64_t))(a2 + 32);
      if (v26) {
        v26(a2, v22, 4);
      }
      uint64_t result = (CA::OGL::Context *)CA::OGL::emit_quad_indices((uint64_t)v13, *(float64x2_t **)(a2 + 40), CA::OGL::emit_one_part_rect(CA::OGL::Context &,CA::OGL::RectState const&,float const*,float const*,unsigned int)::indices, 4uLL, 4u);
    }
    if (v18)
    {
      *(double *)double v30 = v14;
      *(double *)&v30[1] = v15;
      *(double *)&v30[4] = v16;
      *(double *)float64x2_t v31 = v15;
      double v32 = v16;
      double v33 = v17;
      double v35 = v14;
      double v36 = v17;
      long long v37 = xmmword_184997D60;
      long long v34 = xmmword_184997D60;
      *(_OWORD *)&v31[8] = xmmword_184997D60;
      *(_OWORD *)&v30[2] = xmmword_184997D60;
      CA::Transform::apply_to_point4(*(void *)(a2 + 8), (float64x2_t *)v30, (float64x2_t *)v30, (const double *)4);
      if ((a5 & 0x40000) != 0) {
        uint64_t v27 = *(void *)(*((void *)v13 + 2) + 8);
      }
      else {
        uint64_t v27 = 0;
      }
      uint64_t v28 = v27;
      return (CA::OGL::Context *)CA::OGL::emit_quad_surround((uint64_t)v13, (const double *)v30, &v28);
    }
  }
  return result;
}

uint64_t CA::OGL::Context::ClippedArray::next_rect(CA::OGL::Context::ClippedArray *this, int32x2_t *a2)
{
  uint64_t v4 = *(void *)this;
  if (*((unsigned char *)this + 48))
  {
    if (*((unsigned char *)this + 33))
    {
      if (!*((unsigned char *)this + 50))
      {
        CA::OGL::Context::array_flush(*(void *)this);
        if ((*(_WORD *)(v4 + 832) & 0x20) == 0)
        {
          while (1)
          {
            while (1)
            {
              if (!CA::ShapeIterator::iterate((uint64_t *)this + 1, (int *)a2)) {
                goto LABEL_14;
              }
              uint64_t v5 = (int32x2_t *)*((void *)this + 5);
              if (v5) {
                break;
              }
              int v11 = a2->i32[0];
LABEL_12:
              *(_DWORD *)(v4 + 32) = v11;
              *(_DWORD *)(v4 + 36) = a2->i32[1];
              *(_DWORD *)(v4 + 40) = a2[1].i32[0];
              *(_DWORD *)(v4 + 44) = a2[1].i32[1];
              CA::OGL::Context::array_flush(v4);
            }
            int32x2_t v6 = v5[1];
            uint32x2_t v7 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v6);
            if ((vpmax_u32(v7, v7).u32[0] & 0x80000000) == 0)
            {
              int32x2_t v8 = a2[1];
              uint32x2_t v9 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v8);
              if ((vpmax_u32(v9, v9).u32[0] & 0x80000000) == 0)
              {
                uint32x2_t v10 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, vsub_s32(vmin_s32(vadd_s32(*v5, v6), vadd_s32(*a2, v8)), vmax_s32(*v5, *a2)));
                if ((vpmax_u32(v10, v10).u32[0] & 0x80000000) == 0)
                {
                  int v11 = (int)*a2;
                  goto LABEL_12;
                }
              }
            }
          }
        }
      }
    }
LABEL_14:
    while (*((unsigned char *)this + 49) && CA::ShapeIterator::iterate((uint64_t *)this + 1, (int *)a2))
    {
      char v12 = (int32x2_t *)*((void *)this + 5);
      if (v12)
      {
        int32x2_t v13 = v12[1];
        uint32x2_t v14 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v13);
        if ((vpmax_u32(v14, v14).u32[0] & 0x80000000) != 0) {
          continue;
        }
        int32x2_t v15 = a2[1];
        uint32x2_t v16 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v15);
        if ((vpmax_u32(v16, v16).u32[0] & 0x80000000) != 0) {
          continue;
        }
        uint32x2_t v17 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, vsub_s32(vmin_s32(vadd_s32(*v12, v13), vadd_s32(*a2, v15)), vmax_s32(*v12, *a2)));
        if ((vpmax_u32(v17, v17).u32[0] & 0x80000000) != 0) {
          continue;
        }
      }
      if (!*((unsigned char *)this + 50))
      {
        *(_DWORD *)(v4 + 32) = a2->i32[0];
        *(_DWORD *)(v4 + 36) = a2->i32[1];
        *(_DWORD *)(v4 + 40) = a2[1].i32[0];
        *(_DWORD *)(v4 + 44) = a2[1].i32[1];
        if (*((unsigned char *)this + 33))
        {
          *(void *)(v4 + 128) = 0;
          *(void *)(v4 + 96) = v4 + 834;
          *(_OWORD *)(v4 + 104) = xmmword_184997E70;
          *(_WORD *)(v4 + 832) &= ~0x20u;
        }
      }
      return 1;
    }
    if (*((unsigned char *)this + 33) && *((unsigned char *)this + 50)) {
      CA::OGL::Context::array_flush(v4);
    }
    if ((*(_WORD *)(v4 + 832) & 8) == 0) {
      *(unsigned char *)(v4 + 64) = 0;
    }
    if (!BYTE4(ca_debug_options)) {
      return 0;
    }
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 800))(v4);
    if (result)
    {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 408))(v4, 1);
      return 0;
    }
  }
  else
  {
    *((unsigned char *)this + 48) = 1;
    if (*((unsigned char *)this + 49)) {
      goto LABEL_14;
    }
    *(_OWORD *)a2->i8 = xmmword_184998040;
    return 1;
  }
  return result;
}

uint64_t CA::ShapeIterator::iterate(uint64_t *a1, int *a2)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    if (v2 == 1 || a1[1] == 1) {
      return 0;
    }
    *a2 = v2 >> 48;
    a2[1] = (int)((unint64_t)v2 >> 16) >> 16;
    a2[2] = v2 >> 17;
    a2[3] = (v2 >> 2) & 0x7FFF;
    uint64_t v9 = 1;
    a1[1] = 1;
  }
  else
  {
    uint64_t v3 = a1[1];
    if (v3)
    {
      uint64_t v4 = (int *)(v2 + 4 * v3);
      uint64_t v5 = a1[2];
      int32x2_t v6 = &v4[2 * v5 + 2];
      int v7 = *v4;
      uint64_t v8 = v5 + 1;
    }
    else
    {
      uint64_t v4 = (int *)(v2 + 12);
      int v7 = 0x7FFFFFFF;
      if (*(_DWORD *)(v2 + 12) != 0x7FFFFFFF)
      {
        int v7 = *(_DWORD *)(v2 + 12);
        if (*(_DWORD *)(v2 + 16) == 2)
        {
          uint32x2_t v10 = (int *)(v2 + 20);
          while (1)
          {
            uint64_t v4 = v10;
            int v7 = *v10;
            if (*v10 == 0x7FFFFFFF) {
              break;
            }
            v10 += 2;
            if (v4[1] != 2) {
              goto LABEL_14;
            }
          }
          int v7 = 0x7FFFFFFF;
        }
      }
LABEL_14:
      a1[1] = ((uint64_t)v4 - v2) >> 2;
      a1[2] = 0;
      int32x2_t v6 = v4 + 2;
      uint64_t v8 = 1;
    }
    if (v7 == 0x7FFFFFFF) {
      return 0;
    }
    int v11 = *v6;
    *a2 = *v6;
    a2[2] = v6[1] - v11;
    int v12 = *v4;
    a2[1] = *v4;
    a2[3] = v4[v4[1]] - v12;
    a1[2] = v8;
    uint64_t v13 = v4[1];
    if (v8 == ((int)v13 - 2) >> 1)
    {
      uint32x2_t v14 = &v4[v13];
      for (int i = *v14; i != 0x7FFFFFFF && v14[1] == 2; int i = v16)
      {
        int v16 = v14[2];
        v14 += 2;
      }
      a1[1] = ((uint64_t)v14 - v2) >> 2;
      a1[2] = 0;
    }
    return 1;
  }
  return v9;
}

uint64_t CA::OGL::Context::array_flush(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 104);
  if (v1) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t, void, void, void, void, void))(*(void *)this + 280))(this, *(unsigned int *)(this + 92), v1, *(void *)(this + 96), *(void *)(this + 120), 0, *(unsigned int *)(this + 128), *(void *)(*(void *)(this + 248) + 16));
  }
  uint64_t v2 = *(void *)(this + 128);
  if (v2) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t, void, void, void, void, void))(*(void *)this + 280))(this, *(unsigned int *)(this + 92), v2, 0, *(void *)(this + 120), 0, *(void *)(this + 128), *(void *)(*(void *)(this + 248) + 16));
  }
  return this;
}

uint64_t CA::OGL::Context::ClippedArray::start(CA::OGL::Context::ClippedArray *this)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)this;
  uint64_t v3 = *(void *)(*(void *)this + 248);
  uint64_t result = *(void *)(v3 + 8);
  if ((result & 1) == 0 && *(_DWORD *)(result + 4) == 12)
  {
    unsigned int v5 = *(_DWORD *)(result + 32) - *(_DWORD *)(result + 28);
    if (v5 <= *(_DWORD *)(result + 36) - *(_DWORD *)(result + 20)) {
      unsigned int v5 = *(_DWORD *)(result + 36) - *(_DWORD *)(result + 20);
    }
    if (v5 >= 0x3FFFFFFF)
    {
      LOBYTE(v6) = 0;
      *((unsigned char *)this + 49) = 0;
      int v7 = (char *)this + 49;
      uint64_t v8 = (char *)this + 32;
LABEL_15:
      *((unsigned char *)this + 50) = 1;
LABEL_18:
      if (*((unsigned char *)this + 33))
      {
        *(void *)(v2 + 128) = 0;
        *(void *)(v2 + 96) = v2 + 834;
        *(_OWORD *)(v2 + 104) = xmmword_184997E70;
        __int16 v13 = *(_WORD *)(v2 + 832) & 0xFFDF;
        *(_WORD *)(v2 + 832) = v13;
        LOBYTE(v6) = *v7;
      }
      else
      {
        __int16 v13 = *(_WORD *)(v2 + 832);
      }
      __int16 v12 = v13 & 0xFFBF | ((v6 & 3) << 6);
      goto LABEL_22;
    }
  }
  uint64_t v9 = (const CA::Bounds *)*((void *)this + 5);
  if (v9)
  {
    uint64_t result = CA::Shape::contains(result, v9);
    int v6 = result ^ 1;
  }
  else
  {
    int v6 = 1;
  }
  *((unsigned char *)this + 49) = v6;
  int v7 = (char *)this + 49;
  uint64_t v8 = (char *)this + 32;
  if (*((unsigned char *)this + 32)) {
    BOOL v10 = 1;
  }
  else {
    BOOL v10 = v6 == 0;
  }
  if (v10) {
    goto LABEL_15;
  }
  __int16 v11 = *(_WORD *)(v2 + 832);
  *((unsigned char *)this + 50) = (v11 & 8) != 0;
  if ((v11 & 8) != 0) {
    goto LABEL_18;
  }
  *(unsigned char *)(v2 + 64) = 1;
  __int16 v12 = *(_WORD *)(v2 + 832) & 0xFFBF;
LABEL_22:
  *(_WORD *)(v2 + 832) = v12;
  if (!*v8 && *v7 && (v12 & 0x10) != 0)
  {
    *(_OWORD *)uint32x2_t v14 = 0uLL;
    uint64_t result = CA::Shape::get_bounds(*(void *)(v3 + 8), v14);
    *(_OWORD *)(v2 + 32) = *(_OWORD *)v14;
    *(unsigned char *)(v2 + 64) = 1;
    *(_WORD *)(v2 + 832) &= ~0x10u;
  }
  *((unsigned char *)this + 48) = 0;
  return result;
}

BOOL CA::OGL::Context::need_transparent_source(CA::OGL::Context *this)
{
  if ((*(_WORD *)(*((void *)this + 31) + 68) & 0x400) == 0) {
    return 0;
  }
  uint64_t v2 = *((void *)this + 2);
  if ((*(unsigned char *)(v2 + 16) & 0xFE) != 0x10)
  {
    unsigned int v3 = *(unsigned __int8 *)(v2 + 480);
    BOOL v4 = v3 > 0x19;
    int v5 = (1 << v3) & 0x300C533;
    if (v4 || v5 == 0) {
      return 0;
    }
  }
  uint64_t v7 = *((void *)this + 33);
  return !v7 || (*(_WORD *)(v7 + 75) & 0x60) == 0;
}

void CA::OGL::emit_quad(CA::OGL *this, CA::OGL::Context *a2, const double *a3, const CA::Bounds *a4, const CA::Transform *a5, float *a6, const float *a7)
{
  uint64_t v173 = *MEMORY[0x1E4F143B8];
  if ((*((unsigned char *)a4 + 144) & 0x1F) == 0)
  {
    double v61 = *((double *)a4 + 12);
    double v62 = *((double *)a4 + 13);
    float v63 = v61 + *(double *)a2;
    float v64 = v62 + *((double *)a2 + 1);
    float v65 = *((double *)a2 + 2) + v61;
    float v66 = *((double *)a2 + 3) + v62;
    if (v65 <= v63 || v66 <= v64) {
      return;
    }
    float v68 = 0.0;
    float v69 = 0.0;
    float v70 = 0.0;
    float v71 = 0.0;
    float v72 = 0.0;
    if (a5)
    {
      float v72 = *(float *)a5;
      float v71 = *((float *)a5 + 1);
      float v70 = *((float *)a5 + 2);
      float v69 = *((float *)a5 + 3);
    }
    float v73 = 0.0;
    float v74 = 0.0;
    float v75 = 0.0;
    if (a6)
    {
      float v75 = *a6;
      float v68 = a6[1];
      float v73 = a6[2];
      float v74 = a6[3];
    }
    __int16 v76 = *((_WORD *)this + 416);
    if ((v76 & 0x40) == 0)
    {
      float v158 = v73;
      float v159 = v74;
      float v160 = v75;
      float v161 = v68;
LABEL_59:
      uint64_t v77 = 6;
      if (!*((_DWORD *)this + 23)) {
        uint64_t v77 = 4;
      }
      uint64_t v78 = *((void *)this + 16);
      if ((unint64_t)(v78 + 4) > *((void *)this + 17)
        || (unint64_t v79 = *((void *)this + 14)) != 0 && *((void *)this + 13) + v77 > v79)
      {
        *((_WORD *)this + 416) = v76 | 0x20;
        CA::OGL::Context::array_flush((uint64_t)this);
        uint64_t v78 = 0;
        *((void *)this + 12) = (char *)this + 834;
        *(_OWORD *)((char *)this + 104) = xmmword_184997E70;
      }
      unsigned int v45 = v78;
      uint64_t v46 = *((void *)this + 15);
      uint64_t v47 = v46 + 48 * v78;
      *((void *)this + 16) = v78 + 4;
      CA::OGL::Context::array_indices((uint64_t)this, v78);
      uint64_t v48 = *(void *)(*((void *)this + 2) + 8);
      *(float *)uint64_t v47 = v63;
      *(float *)(v47 + 4) = v64;
      *(void *)(v47 + 8) = 0x3F80000000000000;
      *(float *)(v47 + 48) = v65;
      *(float *)(v47 + 52) = v64;
      *(void *)(v47 + 56) = 0x3F80000000000000;
      *(float *)(v47 + 96) = v65;
      *(float *)(v47 + 100) = v66;
      *(void *)(v47 + 104) = 0x3F80000000000000;
      *(float *)(v47 + 144) = v63;
      *(float *)(v47 + 148) = v66;
      *(void *)(v47 + 152) = 0x3F80000000000000;
      if (a5)
      {
        uint64_t v80 = v46 + 48 * v45;
        *(float *)(v80 + 16) = v72;
        *(float *)(v80 + 20) = v71;
        *(float *)(v47 + 64) = v70;
        *(float *)(v47 + 68) = v71;
        *(float *)(v47 + 112) = v70;
        *(float *)(v47 + 116) = v69;
        *(float *)(v47 + 160) = v72;
        *(float *)(v47 + 164) = v69;
      }
      if (a6)
      {
        uint64_t v81 = v46 + 48 * v45;
        *(float *)(v81 + 24) = v160;
        *(float *)(v81 + 28) = v161;
        *(float *)(v47 + 72) = v158;
        *(float *)(v47 + 76) = v161;
        *(float *)(v47 + 120) = v158;
        *(float *)(v47 + 124) = v159;
        *(float *)(v47 + 168) = v160;
        *(float *)(v47 + 172) = v159;
      }
      goto LABEL_69;
    }
    int v108 = *(_DWORD *)a3;
    int v107 = *((_DWORD *)a3 + 1);
    double v109 = (double)*(int *)a3;
    double v110 = (double)v107;
    double v111 = (double)*((int *)a3 + 2) + v109;
    double v112 = (double)*((int *)a3 + 3) + (double)v107;
    double v113 = v65;
    double v114 = v63;
    BOOL v115 = v65 <= v109 || v111 <= v114;
    double v116 = v66;
    BOOL v117 = v115 || v116 <= v110;
    double v118 = v64;
    if (v117 || v112 <= v118) {
      return;
    }
    if (a6)
    {
      if (v114 < v109)
      {
        float v120 = (v109 - v114) / (float)(v65 - v63);
        float v72 = v72 + (float)((float)(v70 - v72) * v120);
        float v75 = v75 + (float)((float)(v73 - v75) * v120);
        float v63 = (float)v108;
      }
      if (v111 < v113)
      {
        float v121 = (v113 - v111) / (float)(v65 - v63);
        float v70 = v70 + (float)((float)(v72 - v70) * v121);
        float v73 = v73 + (float)((float)(v75 - v73) * v121);
        float v65 = v111;
      }
      if (v118 < v110)
      {
        float v122 = (v110 - v118) / (float)(v66 - v64);
        float v71 = v71 + (float)((float)(v69 - v71) * v122);
        float v68 = v68 + (float)((float)(v74 - v68) * v122);
        float v64 = (float)v107;
      }
      float v158 = v73;
      float v160 = v75;
      float v161 = v68;
      if (v112 >= v116)
      {
        float v159 = v74;
        goto LABEL_59;
      }
      float v123 = (v116 - v112) / (float)(v66 - v64);
      float v69 = v69 + (float)((float)(v71 - v69) * v123);
      float v159 = v74 + (float)((float)(v68 - v74) * v123);
    }
    else
    {
      float v160 = v75;
      float v161 = v68;
      float v158 = v73;
      float v159 = v74;
      if (a5)
      {
        if (v114 < v109)
        {
          float v154 = (v109 - v114) / (float)(v65 - v63);
          float v72 = v72 + (float)((float)(v70 - v72) * v154);
          float v63 = (float)v108;
        }
        if (v111 < v113)
        {
          float v155 = (v113 - v111) / (float)(v65 - v63);
          float v70 = v70 + (float)((float)(v72 - v70) * v155);
          float v65 = v111;
        }
        if (v118 < v110)
        {
          float v156 = (v110 - v118) / (float)(v66 - v64);
          float v71 = v71 + (float)((float)(v69 - v71) * v156);
          float v64 = (float)v107;
        }
        if (v112 >= v116) {
          goto LABEL_59;
        }
        float v157 = (v116 - v112) / (float)(v66 - v64);
        float v69 = v69 + (float)((float)(v71 - v69) * v157);
      }
      else
      {
        if (v114 < v109) {
          float v63 = (float)v108;
        }
        if (v111 < v113) {
          float v65 = v111;
        }
        if (v118 < v110) {
          float v64 = (float)v107;
        }
        if (v112 >= v116) {
          goto LABEL_59;
        }
      }
    }
    float v66 = v112;
    goto LABEL_59;
  }
  if ((*((unsigned char *)a4 + 144) & 0x10) != 0)
  {
    double v82 = *((double *)a2 + 2);
    float64_t v83 = *(double *)a2;
    if (v82 <= *(double *)a2) {
      return;
    }
    double v84 = *((double *)a2 + 3);
    double v85 = *((double *)a2 + 1);
    if (v84 <= v85) {
      return;
    }
    v162.f64[0] = *(float64_t *)a2;
    v162.f64[1] = v85;
    v164.f64[0] = v82;
    v164.f64[1] = v85;
    v166.f64[0] = v83;
    v166.f64[1] = v84;
    v168.f64[0] = v82;
    v168.f64[1] = v84;
    long long v169 = xmmword_184997D60;
    float64x2_t v167 = (float64x2_t)xmmword_184997D60;
    float64x2_t v165 = (float64x2_t)xmmword_184997D60;
    float64x2_t v163 = (float64x2_t)xmmword_184997D60;
    CA::Transform::apply_to_point4((uint64_t)a4, &v162, &v162, (const double *)4);
    __int16 v86 = *((_WORD *)this + 416);
    if ((v86 & 0x40) != 0)
    {
      double v128 = 1.0;
      double v129 = 1.0;
      if (fabs(v163.f64[1] + -1.0) >= 0.001)
      {
        if (v163.f64[1] <= 0.0) {
          double v129 = INFINITY;
        }
        else {
          double v129 = 1.0 / v163.f64[1];
        }
      }
      if (fabs(v165.f64[1] + -1.0) >= 0.001)
      {
        if (v165.f64[1] <= 0.0) {
          double v128 = INFINITY;
        }
        else {
          double v128 = 1.0 / v165.f64[1];
        }
      }
      double v134 = 1.0;
      double v135 = 1.0;
      if (fabs(v167.f64[1] + -1.0) >= 0.001)
      {
        if (v167.f64[1] <= 0.0) {
          double v135 = INFINITY;
        }
        else {
          double v135 = 1.0 / v167.f64[1];
        }
      }
      if (fabs(*((double *)&v169 + 1) + -1.0) >= 0.001)
      {
        if (*((double *)&v169 + 1) <= 0.0) {
          double v134 = INFINITY;
        }
        else {
          double v134 = 1.0 / *((double *)&v169 + 1);
        }
      }
      double v137 = v162.f64[0] * v129;
      double v138 = v162.f64[1] * v129;
      double v139 = v164.f64[0] * v128;
      double v140 = v164.f64[1] * v128;
      double v141 = v166.f64[0] * v135;
      double v142 = v166.f64[1] * v135;
      double v143 = v168.f64[0] * v134;
      double v144 = v168.f64[1] * v134;
      if (v137 >= v139) {
        double v145 = v139;
      }
      else {
        double v145 = v137;
      }
      if (v141 >= v143) {
        double v146 = v143;
      }
      else {
        double v146 = v141;
      }
      if (v145 >= v146) {
        double v145 = v146;
      }
      if (v142 >= v144) {
        double v147 = v144;
      }
      else {
        double v147 = v142;
      }
      if (v142 > v144) {
        double v144 = v142;
      }
      if (v138 >= v140) {
        double v148 = v140;
      }
      else {
        double v148 = v138;
      }
      if (v138 <= v140) {
        double v138 = v140;
      }
      if (v148 >= v147) {
        double v149 = v147;
      }
      else {
        double v149 = v148;
      }
      if (v138 > v144) {
        double v144 = v138;
      }
      int v150 = *((_DWORD *)a3 + 1);
      double v151 = (double)*(int *)a3;
      if (v145 >= v151)
      {
        if ((double)*((int *)a3 + 2) + v151 <= v145) {
          return;
        }
      }
      else
      {
        if (v137 > v139) {
          double v139 = v137;
        }
        if (v141 <= v143) {
          double v152 = v143;
        }
        else {
          double v152 = v141;
        }
        if (v139 <= v152) {
          double v139 = v152;
        }
        if (v139 <= v151) {
          return;
        }
      }
      double v153 = (double)v150;
      if (v149 >= (double)v150)
      {
        if ((double)*((int *)a3 + 3) + v153 <= v149) {
          return;
        }
      }
      else if (v144 <= v153)
      {
        return;
      }
    }
    uint64_t v87 = 6;
    if (!*((_DWORD *)this + 23)) {
      uint64_t v87 = 4;
    }
    uint64_t v88 = *((void *)this + 16);
    if ((unint64_t)(v88 + 4) > *((void *)this + 17)
      || (unint64_t v89 = *((void *)this + 14)) != 0 && *((void *)this + 13) + v87 > v89)
    {
      *((_WORD *)this + 416) = v86 | 0x20;
      CA::OGL::Context::array_flush((uint64_t)this);
      uint64_t v88 = 0;
      *((void *)this + 12) = (char *)this + 834;
      *(_OWORD *)((char *)this + 104) = xmmword_184997E70;
    }
    uint64_t v90 = *((void *)this + 15) + 48 * v88;
    *((void *)this + 16) = v88 + 4;
    float32x4_t v91 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v164), v165);
    float32x4_t v92 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v168), (float64x2_t)v169);
    float32x4_t v93 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v166), v167);
    *(float32x4_t *)uint64_t v90 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v162), v163);
    *(float32x4_t *)(v90 + 48) = v91;
    *(float32x4_t *)(v90 + 96) = v92;
    *(float32x4_t *)(v90 + 144) = v93;
    if (*((void *)this + 12)) {
      CA::OGL::Context::array_indices((uint64_t)this, v88);
    }
    uint64_t v94 = *((void *)this + 15);
    uint64_t v95 = *((void *)this + 16);
    if (a5)
    {
      float v96 = *(float *)a5;
      int v97 = *((_DWORD *)a5 + 1);
      int v98 = *((_DWORD *)a5 + 2);
      int v99 = *((_DWORD *)a5 + 3);
      uint64_t v100 = v94 + 48 * v95;
      *(_DWORD *)(v100 - 176) = *(_DWORD *)a5;
      *(_DWORD *)(v100 - 172) = v97;
      *(_DWORD *)(v100 - 128) = v98;
      *(_DWORD *)(v100 - 124) = v97;
      *(_DWORD *)(v100 - 80) = v98;
      *(_DWORD *)(v100 - 76) = v99;
      *(float *)(v100 - 32) = v96;
      *(_DWORD *)(v100 - 28) = v99;
    }
    if (a6)
    {
      int v101 = *(_DWORD *)a6;
      int v102 = *((_DWORD *)a6 + 1);
      int v103 = *((_DWORD *)a6 + 2);
      int v104 = *((_DWORD *)a6 + 3);
      uint64_t v105 = v95 - 4;
      uint64_t v106 = v94 + 48 * v105;
      *(float *)(v106 + 24) = *a6;
      *(_DWORD *)(v106 + 28) = v102;
      *(_DWORD *)(v106 + 72) = v103;
      *(_DWORD *)(v106 + 76) = v102;
      *(_DWORD *)(v106 + 120) = v103;
      *(_DWORD *)(v106 + 124) = v104;
      *(_DWORD *)(v106 + 168) = v101;
      *(_DWORD *)(v106 + 172) = v104;
    }
    else
    {
      uint64_t v105 = v95 - 4;
    }
    uint64_t v130 = *(void *)(*((void *)this + 2) + 8);
    float v131 = (void *)(v94 + 48 * v105);
    v131[4] = v130;
    v131[10] = v130;
    v131[16] = v130;
    v131[22] = v130;
    return;
  }
  double v12 = *((double *)a2 + 1);
  double v13 = *((double *)a2 + 2);
  double v14 = *((double *)a2 + 3);
  if (v13 > *(double *)a2 && v14 > v12)
  {
    double v16 = *((double *)a4 + 16);
    if ((*((unsigned char *)a4 + 144) & 8) == 0) {
      double v16 = 1.0;
    }
    double v17 = v16 * v12;
    double v18 = v16 * *(double *)a2;
    double v19 = -(v16 * v12);
    if ((*((unsigned char *)a4 + 144) & 4) != 0)
    {
      double v17 = v16 * *(double *)a2;
      double v18 = v19;
    }
    double v20 = v16 * v14;
    double v21 = v16 * v13;
    double v22 = -(v16 * v14);
    if ((*((unsigned char *)a4 + 144) & 4) != 0) {
      double v23 = v21;
    }
    else {
      double v23 = v20;
    }
    if ((*((unsigned char *)a4 + 144) & 4) != 0) {
      double v21 = v22;
    }
    if ((*((unsigned char *)a4 + 144) & 2) != 0) {
      double v24 = -v18;
    }
    else {
      double v24 = v18;
    }
    double v25 = -v17;
    if ((*((unsigned char *)a4 + 144) & 2) != 0) {
      double v21 = -v21;
    }
    if ((*((unsigned char *)a4 + 144) & 1) == 0) {
      double v25 = v17;
    }
    double v26 = *((double *)a4 + 12);
    double v27 = *((double *)a4 + 13);
    double v28 = v24 + v26;
    double v29 = v25 + v27;
    if (*((unsigned char *)a4 + 144)) {
      double v23 = -v23;
    }
    double v30 = v21 + v26;
    double v31 = v23 + v27;
    if (v30 >= v28) {
      double v32 = v30;
    }
    else {
      double v32 = v28;
    }
    if (v30 >= v28) {
      double v33 = v28;
    }
    else {
      double v33 = v30;
    }
    float64x2_t v162 = 0uLL;
    long long v172 = 0uLL;
    if (v31 >= v29) {
      double v34 = v23 + v27;
    }
    else {
      double v34 = v29;
    }
    long long v171 = 0uLL;
    if (v31 >= v29) {
      double v35 = v29;
    }
    else {
      double v35 = v23 + v27;
    }
    long long v170 = 0uLL;
    CA::OGL::simple_texcoords(a5, (float *)&v162, (float *)&v172, (float *)a4, a5);
    CA::OGL::simple_texcoords((CA::OGL *)a6, (float *)&v171, (float *)&v170, (float *)a4, v36);
    __int16 v37 = *((_WORD *)this + 416);
    if ((v37 & 0x40) == 0)
    {
      double v38 = v34;
      double v39 = v32;
      double v40 = v35;
      double v41 = v33;
LABEL_39:
      uint64_t v42 = 6;
      if (!*((_DWORD *)this + 23)) {
        uint64_t v42 = 4;
      }
      uint64_t v43 = *((void *)this + 16);
      if ((unint64_t)(v43 + 4) > *((void *)this + 17)
        || (unint64_t v44 = *((void *)this + 14)) != 0 && *((void *)this + 13) + v42 > v44)
      {
        *((_WORD *)this + 416) = v37 | 0x20;
        CA::OGL::Context::array_flush((uint64_t)this);
        uint64_t v43 = 0;
        *((void *)this + 12) = (char *)this + 834;
        *(_OWORD *)((char *)this + 104) = xmmword_184997E70;
      }
      unsigned int v45 = v43;
      uint64_t v46 = *((void *)this + 15);
      uint64_t v47 = v46 + 48 * v43;
      *((void *)this + 16) = v43 + 4;
      CA::OGL::Context::array_indices((uint64_t)this, v43);
      uint64_t v48 = *(void *)(*((void *)this + 2) + 8);
      float v49 = v41;
      float v50 = v40;
      *(float *)uint64_t v47 = v49;
      *(float *)(v47 + 4) = v50;
      *(void *)(v47 + 8) = 0x3F80000000000000;
      float v51 = v39;
      *(float *)(v47 + 48) = v51;
      *(float *)(v47 + 52) = v50;
      *(void *)(v47 + 56) = 0x3F80000000000000;
      float v52 = v38;
      *(float *)(v47 + 96) = v51;
      *(float *)(v47 + 100) = v52;
      *(void *)(v47 + 104) = 0x3F80000000000000;
      *(float *)(v47 + 144) = v49;
      *(float *)(v47 + 148) = v52;
      *(void *)(v47 + 152) = 0x3F80000000000000;
      if (a5)
      {
        uint64_t v53 = v46 + 48 * v45;
        uint64_t v54 = v172;
        *(_DWORD *)(v53 + 16) = LODWORD(v162.f64[0]);
        *(_DWORD *)(v53 + 20) = v54;
        *(_DWORD *)(v47 + 64) = HIDWORD(v162.f64[0]);
        *(_DWORD *)(v47 + 68) = HIDWORD(v54);
        uint64_t v55 = *((void *)&v172 + 1);
        *(_DWORD *)(v47 + 112) = LODWORD(v162.f64[1]);
        *(_DWORD *)(v47 + 116) = v55;
        *(_DWORD *)(v47 + 160) = HIDWORD(v162.f64[1]);
        *(_DWORD *)(v47 + 164) = HIDWORD(v55);
      }
      if (a6)
      {
        int v56 = DWORD1(v171);
        uint64_t v57 = v46 + 48 * v45;
        uint64_t v58 = v170;
        *(_DWORD *)(v57 + 24) = v171;
        *(_DWORD *)(v57 + 28) = v58;
        *(_DWORD *)(v47 + 72) = v56;
        *(_DWORD *)(v47 + 76) = HIDWORD(v58);
        int v59 = HIDWORD(v171);
        uint64_t v60 = *((void *)&v170 + 1);
        *(_DWORD *)(v47 + 120) = DWORD2(v171);
        *(_DWORD *)(v47 + 124) = v60;
        *(_DWORD *)(v47 + 168) = v59;
        *(_DWORD *)(v47 + 172) = HIDWORD(v60);
      }
LABEL_69:
      *(void *)(v46 + 48 * v45 + 32) = v48;
      *(void *)(v47 + 80) = v48;
      *(void *)(v47 + 128) = v48;
      *(void *)(v47 + 176) = v48;
      return;
    }
    double v41 = (double)*(int *)a3;
    double v40 = (double)*((int *)a3 + 1);
    double v39 = (double)*((int *)a3 + 2) + v41;
    double v38 = (double)*((int *)a3 + 3) + v40;
    if (v32 > v41 && v33 < v39 && v34 > v40 && v35 < v38)
    {
      if (v33 >= v41)
      {
        double v41 = v33;
      }
      else
      {
        float v127 = (v41 - v33) / (v32 - v33);
        if (a5)
        {
          *(float *)v162.f64 = *(float *)v162.f64
                             + (float)((float)(*((float *)v162.f64 + 1) - *(float *)v162.f64) * v127);
          *((float *)&v162.f64[1] + 1) = *((float *)&v162.f64[1] + 1)
                                       + (float)((float)(*(float *)&v162.f64[1] - *((float *)&v162.f64[1] + 1)) * v127);
          *(float *)&long long v172 = *(float *)&v172 + (float)((float)(*((float *)&v172 + 1) - *(float *)&v172) * v127);
          *((float *)&v172 + 3) = *((float *)&v172 + 3)
                                + (float)((float)(*((float *)&v172 + 2) - *((float *)&v172 + 3)) * v127);
        }
        if (a6)
        {
          *((float *)&v170 + 3) = *((float *)&v170 + 3)
                                + (float)((float)(*((float *)&v170 + 2) - *((float *)&v170 + 3)) * v127);
          *(float *)&long long v171 = *(float *)&v171 + (float)((float)(*((float *)&v171 + 1) - *(float *)&v171) * v127);
          *((float *)&v171 + 3) = *((float *)&v171 + 3)
                                + (float)((float)(*((float *)&v171 + 2) - *((float *)&v171 + 3)) * v127);
          *(float *)&long long v170 = *(float *)&v170 + (float)((float)(*((float *)&v170 + 1) - *(float *)&v170) * v127);
        }
      }
      if (v32 <= v39)
      {
        double v39 = v32;
      }
      else
      {
        float v132 = (v32 - v39) / (v32 - v41);
        if (a5)
        {
          *(float32x2_t *)((char *)v162.f64 + 4) = vmla_n_f32(*(float32x2_t *)((char *)v162.f64 + 4), vsub_f32((float32x2_t)__PAIR64__(HIDWORD(v162.f64[1]), LODWORD(v162.f64[0])), *(float32x2_t *)((char *)v162.f64 + 4)), v132);
          *(float32x2_t *)((char *)&v172 + 4) = vmla_n_f32(*(float32x2_t *)((char *)&v172 + 4), vsub_f32((float32x2_t)__PAIR64__(HIDWORD(v172), v172), *(float32x2_t *)((char *)&v172 + 4)), v132);
        }
        if (a6)
        {
          *(float32x2_t *)((char *)&v171 + 4) = vmla_n_f32(*(float32x2_t *)((char *)&v171 + 4), vsub_f32((float32x2_t)__PAIR64__(HIDWORD(v171), v171), *(float32x2_t *)((char *)&v171 + 4)), v132);
          *(float32x2_t *)((char *)&v170 + 4) = vmla_n_f32(*(float32x2_t *)((char *)&v170 + 4), vsub_f32((float32x2_t)__PAIR64__(HIDWORD(v170), v170), *(float32x2_t *)((char *)&v170 + 4)), v132);
        }
      }
      if (v35 >= v40)
      {
        double v40 = v35;
      }
      else
      {
        float v133 = (v40 - v35) / (v34 - v35);
        if (a5)
        {
          *(float32x2_t *)&v162.f64[0] = vmla_n_f32(*(float32x2_t *)&v162.f64[0], vsub_f32((float32x2_t)vrev64_s32(*(int32x2_t *)&v162.f64[1]), *(float32x2_t *)&v162.f64[0]), v133);
          *(float32x2_t *)&long long v172 = vmla_n_f32(*(float32x2_t *)&v172, vsub_f32((float32x2_t)vrev64_s32(*(int32x2_t *)((char *)&v172 + 8)), *(float32x2_t *)&v172), v133);
        }
        if (a6)
        {
          *(float32x2_t *)&long long v171 = vmla_n_f32(*(float32x2_t *)&v171, vsub_f32((float32x2_t)vrev64_s32(*(int32x2_t *)((char *)&v171 + 8)), *(float32x2_t *)&v171), v133);
          *(float32x2_t *)&long long v170 = vmla_n_f32(*(float32x2_t *)&v170, vsub_f32((float32x2_t)vrev64_s32(*(int32x2_t *)((char *)&v170 + 8)), *(float32x2_t *)&v170), v133);
        }
      }
      if (v34 <= v38)
      {
        double v38 = v34;
      }
      else
      {
        float v136 = (v34 - v38) / (v34 - v40);
        if (a5)
        {
          *(float32x2_t *)&v162.f64[1] = vmla_n_f32(*(float32x2_t *)&v162.f64[1], vsub_f32((float32x2_t)vrev64_s32(*(int32x2_t *)&v162.f64[0]), *(float32x2_t *)&v162.f64[1]), v136);
          *((float32x2_t *)&v172 + 1) = vmla_n_f32(*(float32x2_t *)((char *)&v172 + 8), vsub_f32((float32x2_t)vrev64_s32(*(int32x2_t *)&v172), *(float32x2_t *)((char *)&v172 + 8)), v136);
        }
        if (a6)
        {
          *((float32x2_t *)&v171 + 1) = vmla_n_f32(*(float32x2_t *)((char *)&v171 + 8), vsub_f32((float32x2_t)vrev64_s32(*(int32x2_t *)&v171), *(float32x2_t *)((char *)&v171 + 8)), v136);
          *((float32x2_t *)&v170 + 1) = vmla_n_f32(*(float32x2_t *)((char *)&v170 + 8), vsub_f32((float32x2_t)vrev64_s32(*(int32x2_t *)&v170), *(float32x2_t *)((char *)&v170 + 8)), v136);
        }
      }
      goto LABEL_39;
    }
  }
}

uint64_t CA::OGL::Context::array_indices(uint64_t this, __int16 a2)
{
  uint64_t v2 = *(void *)(this + 104);
  unsigned int v3 = (_WORD *)(*(void *)(this + 96) + 2 * v2);
  int v4 = *(_DWORD *)(this + 92);
  if (v4 == 1)
  {
    *unsigned int v3 = a2;
    v3[1] = a2 + 1;
    v3[2] = a2 + 2;
    v3[3] = a2 + 2;
    uint64_t v5 = 6;
    uint64_t v6 = 5;
    v3[4] = a2 + 3;
  }
  else
  {
    if (v4) {
      return this;
    }
    *unsigned int v3 = a2;
    v3[1] = a2 + 1;
    v3[2] = a2 + 2;
    a2 += 3;
    uint64_t v5 = 4;
    uint64_t v6 = 3;
  }
  v3[v6] = a2;
  *(void *)(this + 104) = v2 + v5;
  return this;
}

int8x16_t CA::OGL::simple_texcoords(CA::OGL *this, float *a2, float *a3, float *a4, const CA::Transform *a5)
{
  if (this)
  {
    char v5 = *((unsigned char *)a4 + 144);
    *a2 = *(float *)this;
    if ((v5 & 4) != 0)
    {
      *a3 = *((float *)this + 3);
      a2[1] = *(float *)this;
      uint64_t v6 = (float *)((char *)this + 4);
      a3[1] = *((float *)this + 1);
      uint64_t v7 = (const float *)((char *)this + 8);
    }
    else
    {
      *a3 = *((float *)this + 1);
      a2[1] = *((float *)this + 2);
      a3[1] = *((float *)this + 1);
      uint64_t v6 = (float *)((char *)this + 12);
      uint64_t v7 = (const float *)this;
    }
    a2[2] = *((float *)this + 2);
    a3[2] = *v6;
    a2[3] = *v7;
    result.i32[0] = *((_DWORD *)this + 3);
    a3[3] = *(float *)result.i32;
    char v9 = *((unsigned char *)a4 + 144);
    if ((v9 & 2) != 0)
    {
      *(int32x4_t *)a2 = vrev64q_s32(*(int32x4_t *)a2);
      int8x16_t result = (int8x16_t)vrev64q_s32(*(int32x4_t *)a3);
      *(int8x16_t *)a3 = result;
      char v9 = *((unsigned char *)a4 + 144);
    }
    if (v9)
    {
      int8x16_t v10 = (int8x16_t)vrev64q_s32(*(int32x4_t *)a2);
      *(int8x16_t *)a2 = vextq_s8(v10, v10, 8uLL);
      int8x16_t v11 = (int8x16_t)vrev64q_s32(*(int32x4_t *)a3);
      int8x16_t result = vextq_s8(v11, v11, 8uLL);
      *(int8x16_t *)a3 = result;
    }
  }
  else
  {
    *(void *)a2 = 0;
    *((void *)a2 + 1) = 0;
    *(void *)a3 = 0;
    *((void *)a3 + 1) = 0;
  }
  return result;
}

CA::OGL::Context *CA::OGL::ContentsGeometry::fill_geometry(uint64_t a1, CA::OGL::Context *a2, double **a3, float32x2_t *a4)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 490))
  {
    uint64_t v7 = a1 + 292;
    *(float32x2_t *)v8.f32 = *a4;
    *(float32x2_t *)v9.f32 = vsub_f32(a4[1], *a4);
    v9.i64[1] = v9.i64[0];
    *(float32x2_t *)&v8.u32[2] = *a4;
    float32x4_t v15 = vmlaq_f32(v8, *(float32x4_t *)(a1 + 292), v9);
    uint64_t v10 = *(void *)(a1 + 448);
    if (v10)
    {
      int8x16_t v11 = (uint32x2_t *)(*(uint64_t (**)(uint64_t))(*(void *)v10 + 80))(v10);
      long long v12 = *(_OWORD *)(v7 + 180);
      v14[0] = *(_OWORD *)(v7 + 164);
      v14[1] = v12;
      return CA::OGL::fill_corner_rect_tex(a2, a3, v11, (double *)v14, *(unsigned __int8 *)(a1 + 488), *(unsigned __int8 *)(a1 + 489), (uint64_t)&v15, *(_DWORD *)(a1 + 440), *(double *)(a1 + 424), *(double *)(a1 + 432), (double *)(a1 + 72));
    }
    else
    {
      return CA::OGL::fill_round_rect_tex(a2, (float64x2_t **)a3, (uint64_t)&v15, (double *)*(unsigned int *)(a1 + 440), *(unsigned int *)(a1 + 444), (double *)(a1 + 72), *(float64_t *)(a1 + 424), *(float64_t *)(a1 + 432));
    }
  }
  else
  {
    return CA::OGL::fill_rect_tex(a2, (uint64_t)a3, (uint64_t)a4, (double *)a4);
  }
}

uint64_t CA::OGL::MetalContext::destination_bit_depth(CA::OGL::MetalContext *this)
{
  unsigned int v1 = *(_DWORD *)(*((void *)this + 33) + 120);
  char v2 = v1 - 70;
  if (v1 - 70 > 0x2D) {
    goto LABEL_2;
  }
  if (((1 << v2) & 0x3D0000000000) != 0) {
    return 16;
  }
  if (((1 << v2) & 0xC03) != 0) {
    return 8;
  }
  if (((1 << v2) & 0x1100000) == 0)
  {
LABEL_2:
    if (v1 <= 0x2B)
    {
      if (((1 << v1) & 0xC0000C02) != 0) {
        return 8;
      }
      if (((1 << v1) & 0xA0000000000) != 0) {
        return 5;
      }
    }
    if (v1 - 550 < 6) {
      return 9;
    }
    return 8;
  }
  return 10;
}

void CA::Render::Update::invalidate_backdrops(CA::Render::Update *this, const CA::Bounds *a2, CA::Render::BackdropState *a3, unsigned int a4)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  int v4 = *((_DWORD *)a2 + 2);
  if (v4 >= *((_DWORD *)a2 + 3)) {
    int v4 = *((_DWORD *)a2 + 3);
  }
  if (v4 >= 1)
  {
    uint64_t v6 = (int32x2_t *)*((void *)this + 63);
    if (v6)
    {
      while (1)
      {
        __int32 v10 = v6[12].i32[0];
        if ((v10 & 0x40000000) != 0 && (v10 & 0xFFFFFFFu) <= a4) {
          goto LABEL_44;
        }
        int8x16_t v11 = *(void **)(*(void *)&v6[1] + 256);
        uint64_t v12 = v11[5];
        double v13 = (os_unfair_lock_s *)(v12 + 40);
        os_unfair_lock_lock((os_unfair_lock_t)(v12 + 40));
        uint64_t v15 = *(void *)(v12 + 480);
        int32x2_t v16 = v6[2];
        uint64_t v17 = *(void *)(*(void *)&v16 + 16);
        if (v15 == v17)
        {
          if ((v6[12].i8[3] & 0x20) != 0)
          {
            long long v43 = 0uLL;
            CA::Shape::get_bounds(v15, (int *)&v43);
            *(_OWORD *)v6[3].i8 = v43;
          }
          goto LABEL_43;
        }
        if (!a3 || *((void *)a3 + 5) != v12)
        {
          long long v18 = *(_OWORD *)a2;
          long long v42 = v18;
          int v19 = DWORD2(v18);
          uint32x2_t v20 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)((char *)&v18 + 8));
          unsigned __int32 v21 = vpmax_u32(v20, v20).u32[0];
          int32x2_t v22 = (int32x2_t)v18;
          if ((v21 & 0x80000000) != 0)
          {
            int v31 = HIDWORD(v18);
          }
          else
          {
            int32x2_t v23 = (int32x2_t)v11[7];
            uint32x2_t v24 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v23);
            if ((vpmax_u32(v24, v24).u32[0] & 0x80000000) != 0
              || (int32x2_t v25 = (int32x2_t)v11[6],
                  int32x2_t v26 = vadd_s32(*(int32x2_t *)&v18, *(int32x2_t *)((char *)&v18 + 8)),
                  int32x2_t v27 = vmax_s32(*(int32x2_t *)&v18, v25),
                  int32x2_t v28 = vsub_s32(vmin_s32(v26, vadd_s32(v25, v23)), v27),
                  uint32x2_t v29 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v28),
                  (vpmax_u32(v29, v29).u32[0] & 0x80000000) != 0))
            {
              int v31 = 0;
              int v19 = 0;
              *((void *)&v42 + 1) = 0;
            }
            else
            {
              *(int32x2_t *)&long long v30 = v27;
              *((int32x2_t *)&v30 + 1) = v28;
              long long v42 = v30;
              int v19 = v28.i32[0];
              int v31 = v28.i32[1];
              int32x2_t v22 = v27;
            }
          }
          int v32 = v19 >= v31 ? v31 : v19;
          if (v32 >= 1) {
            break;
          }
        }
LABEL_43:
        os_unfair_lock_unlock(v13);
LABEL_44:
        uint64_t v6 = (int32x2_t *)*v6;
        if (!v6) {
          return;
        }
      }
      float v33 = *(float *)(v12 + 60);
      float v34 = 0.0;
      if (v33 != 1.0) {
        float v34 = ceilf(0.5 / v33);
      }
      if (v19 <= v31) {
        int v35 = v31;
      }
      else {
        int v35 = v19;
      }
      if (v35 <= 1073741822)
      {
        unsigned int v36 = (int)(float)-v34;
        *(int32x2_t *)&long long v42 = vadd_s32(v22, vdup_n_s32(v36));
        signed int v37 = v31 - 2 * v36;
        DWORD2(v42) = v19 - 2 * v36;
        HIDWORD(v42) = v37;
        if (SDWORD2(v42) < 1 || v37 <= 0) {
          *((void *)&v42 + 1) = 0;
        }
      }
      if ((v6[12].i8[3] & 0x20) != 0)
      {
        CA::BoundsImpl::Union(v6 + 3, *(int32x2_t *)&v42, *(int32x2_t *)((char *)&v42 + 8));
        int32x2_t v16 = v6[2];
        uint64_t v17 = *(void *)(*(void *)&v16 + 16);
      }
      double v39 = (CA::Shape **)(*(void *)&v16 + 16);
      if (v17)
      {
        CA::shape_union((CA::Shape **)(*(void *)&v16 + 16), (CA::Shape **)&v42, v14);
        double v40 = *v39;
        if ((*v39 & 1) != 0 || *((int *)v40 + 1) < 65) {
          goto LABEL_42;
        }
        long long v43 = 0uLL;
        CA::Shape::get_bounds((uint64_t)v40, (int *)&v43);
        CA::Shape::unref(*v39);
        double v41 = (unsigned int *)&v43;
      }
      else
      {
        double v41 = (unsigned int *)&v42;
      }
      CA::Render::LayerNode *v39 = (CA::Shape *)CA::Shape::new_shape(v41);
LABEL_42:
      goto LABEL_43;
    }
  }
}

void CA::shape_union(CA::Shape **this, CA::Shape **a2, const CA::Bounds *a3)
{
  char v5 = *this;
  if (*this)
  {
    if (v5 == (CA::Shape *)1) {
      goto LABEL_3;
    }
LABEL_5:
    unint64_t v6 = CA::Shape::Union(*this, (const CA::Bounds *)a2);
    CA::Shape::unref(v5);
    goto LABEL_6;
  }
  if (*((_DWORD *)v5 + 1) != 6) {
    goto LABEL_5;
  }
LABEL_3:
  CA::Shape::unref(*this);
  unint64_t v6 = CA::Shape::new_shape((unsigned int *)a2);
LABEL_6:
  *this = (CA::Shape *)v6;
}

unint64_t CA::Shape::new_shape(unsigned int *a1)
{
  uint64_t v1 = a1[2];
  int v2 = a1[3];
  if ((int)v1 < 1 || v2 < 1) {
    return 1;
  }
  if (!((v2 | v1) >> 15))
  {
    uint64_t v6 = *a1;
    if (v6 == (__int16)v6 && a1[1] == (__int16)a1[1]) {
      return (v6 << 48) | ((unint64_t)(unsigned __int16)a1[1] << 32) | (v1 << 17) | (4 * (v2 & 0x7FFF)) | 1;
    }
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  unint64_t result = (unint64_t)malloc_type_zone_malloc(malloc_zone, 0x30uLL, 0x8BB15036uLL);
  if (result)
  {
    unint64_t result = CA::Shape::operator=(result, a1);
    *(_DWORD *)unint64_t result = 1;
    *(_DWORD *)(result + 8) = 12;
  }
  return result;
}

unint64_t CA::Shape::Union(CA::Shape *this, const CA::Bounds *a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (*((_DWORD *)a2 + 2)) {
    BOOL v3 = *((_DWORD *)a2 + 3) == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3)
  {
    if (this)
    {
      if (this == (CA::Shape *)1) {
        goto LABEL_11;
      }
    }
    else if (*((_DWORD *)this + 1) == 6)
    {
LABEL_11:
      return CA::Shape::new_shape((unsigned int *)a2);
    }
    memset(v5, 0, sizeof(v5));
    CA::Shape::operator=((uint64_t)v5, a2);
    return CA::Shape::Union((uint64_t)this, (uint64_t)v5);
  }

  return CA::Shape::ref((unint64_t)this);
}

uint64_t CA::Render::anonymous namespace'::invalidate_rasterized_backdrops(uint64_t result, uint64_t a2, int a3)
{
  if ((*(unsigned char *)(result + 99) & 0x20) != 0)
  {
    if (*(_DWORD *)(a2 + 80) == a3)
    {
      uint64_t v3 = *(void *)(result + 16);
      int v4 = *(_DWORD *)(v3 + 40);
      if (*(_DWORD *)(a2 + 76) == v4) {
        return result;
      }
    }
    else
    {
      uint64_t v3 = *(void *)(result + 16);
      int v4 = *(_DWORD *)(v3 + 40);
    }
    *(_DWORD *)(a2 + 76) = v4;
    *(_DWORD *)(a2 + 80) = a3;
    uint64_t v5 = *(void *)(result + 8);
    if (v5)
    {
      uint64_t v6 = *(void *)(v3 + 32);
      do
      {
        uint64_t v7 = *(void *)(v5 + 40);
        if (v7) {
          *(_DWORD *)(v7 + 76) = a3;
        }
        if (v5 == v6) {
          break;
        }
        uint64_t v5 = *(void *)(v5 + 88);
      }
      while (v5);
    }
  }
  return result;
}

BOOL CA::Transform::is_isotropic(CA::Transform *this, double a2, uint64_t a3, uint64_t a4, double *a5)
{
  v10[1] = *(double *)MEMORY[0x1E4F143B8];
  if ((*((unsigned char *)this + 144) & 0x10) == 0) {
    return 1;
  }
  if (*((double *)this + 15) != 1.0) {
    return 0;
  }
  double v9 = 0.0;
  v10[0] = 0.0;
  CA::Mat4Impl::mat4_get_scale(this, v10, &v9, a5);
  double v6 = fabs(v10[0]);
  double v7 = fabs(v9);
  if (v6 <= v7) {
    double v8 = v7;
  }
  else {
    double v8 = v6;
  }
  if (v6 >= v7) {
    double v6 = v7;
  }
  return v8 / v6 <= 2.0;
}

double CA::Mat4Impl::mat4_get_scale(CA::Mat4Impl *this, double *a2, double *a3, double *a4)
{
  double v4 = *(double *)this * *(double *)this + *((double *)this + 1) * *((double *)this + 1);
  double v5 = *((double *)this + 4) * *((double *)this + 4) + *((double *)this + 5) * *((double *)this + 5);
  double v6 = *((double *)this + 15);
  if (v6 != 1.0)
  {
    double v7 = 1.0 / (v6 * v6);
    double v4 = v7 * v4;
    double v5 = v7 * v5;
  }
  BOOL v8 = v4 != 1.0;
  if (v5 != 1.0) {
    BOOL v8 = 1;
  }
  double v9 = sqrt(v4);
  double v10 = sqrt(v5);
  if (v8) {
    double v5 = v10;
  }
  if (a2)
  {
    if (v8) {
      double v4 = v9;
    }
    *a2 = v4;
  }
  if (a3) {
    *a3 = v5;
  }
  double result = (v10 + v9) * 0.5;
  if (!v8) {
    return 1.0;
  }
  return result;
}

double CA::OGL::Context::bind_square(CA::OGL::Context *this, unsigned int a2, BOOL a3, BOOL a4, float *a5)
{
  uint64_t v5 = *((void *)this + 2);
  *(_OWORD *)(v5 + 16 * a2 + 96) = xmmword_184997ED0;
  *(unsigned char *)(v5 + a2 + 17) = 9;
  double result = 0.00781250557;
  *(void *)a5 = 0x3F800000BF800000;
  return result;
}

double CA::OGL::anonymous namespace'::rect_nine_part_source_xy(double *a1, CA::Transform *this, double *a3, double *a4, double *a5)
{
  v18[1] = *(double *)MEMORY[0x1E4F143B8];
  double v17 = 0.0;
  v18[0] = 0.0;
  CA::Transform::get_scale_recip((uint64_t)this, v18, &v17);
  double result = v18[0];
  double v10 = a1[2] * 0.5;
  if (result + result < v10) {
    double v10 = v18[0] + v18[0];
  }
  double v11 = v17;
  double v12 = a1[3] * 0.5;
  if (v11 + v11 < v12) {
    double v12 = v17 + v17;
  }
  double v13 = *a1;
  *a3 = *a1;
  double v14 = a1[2] + v13;
  a3[1] = v13 + v10;
  a3[2] = v14 - v10;
  a3[3] = v14;
  double v15 = a1[1];
  *a4 = v15;
  double v16 = a1[3] + v15;
  a4[1] = v15 + v12;
  a4[2] = v16 - v12;
  a4[3] = v16;
  if (a5)
  {
    double result = a1[3] * a1[2] / (v11 * result);
    *a5 = result;
  }
  return result;
}

uint64_t CA::Transform::get_scale_recip(uint64_t this, double *a2, double *a3)
{
  if ((*(unsigned char *)(this + 144) & 0x10) != 0)
  {
    double v4 = *(double *)this * *(double *)this + *(double *)(this + 8) * *(double *)(this + 8);
    double v5 = *(double *)(this + 32) * *(double *)(this + 32) + *(double *)(this + 40) * *(double *)(this + 40);
    double v6 = *(double *)(this + 120);
    double v7 = 1.0;
    if (v6 != 1.0)
    {
      double v8 = 1.0 / (v6 * v6);
      double v4 = v8 * v4;
      double v5 = v8 * v5;
    }
    BOOL v9 = v4 == 1.0 && v5 == 1.0;
    double v3 = 1.0;
    if (!v9)
    {
      double v7 = 1.0 / sqrt(v4);
      double v3 = 1.0 / sqrt(v5);
    }
    if (a2) {
      *a2 = v7;
    }
    if (a3) {
      goto LABEL_16;
    }
  }
  else
  {
    if (a2) {
      *a2 = *(double *)(this + 136);
    }
    if (a3)
    {
      double v3 = *(double *)(this + 136);
LABEL_16:
      *a3 = v3;
    }
  }
  return this;
}

uint64_t CA::Shape::dilate(uint64_t this, unsigned int a2, unsigned int a3)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (a3 | a2)
  {
    if (this)
    {
      if (this != 1)
      {
        uint64_t v6 = this >> 48;
        uint64_t v5 = this << 16 >> 48;
        LODWORD(v18) = this >> 48;
        HIDWORD(v18) = (int)((unint64_t)this >> 16) >> 16;
        signed int v8 = this >> 17;
        LODWORD(v19) = this >> 17;
        signed int v9 = (this >> 2) & 0x7FFF;
        goto LABEL_10;
      }
    }
    else if (*(_DWORD *)(this + 4) == 12)
    {
      LODWORD(v5) = *(_DWORD *)(this + 20);
      LODWORD(v6) = *(_DWORD *)(this + 28);
      int v7 = *(_DWORD *)(this + 32);
      unint64_t v18 = __PAIR64__(v5, v6);
      signed int v8 = v7 - v6;
      LODWORD(v19) = v8;
      signed int v9 = *(_DWORD *)(this + 36) - v5;
LABEL_10:
      HIDWORD(v19) = v9;
      if (v8 <= v9) {
        int v11 = v9;
      }
      else {
        int v11 = v8;
      }
      if (v8 >= v9) {
        int v12 = v9;
      }
      else {
        int v12 = v8;
      }
      if (v11 <= 1073741822 && v12 >= 1)
      {
        LODWORD(v18) = v6 - a2;
        HIDWORD(v18) = v5 - a3;
        LODWORD(v19) = v8 + 2 * a2;
        HIDWORD(v19) = v9 + 2 * a3;
        if ((int)v19 < 1 || (int)(v9 + 2 * a3) <= 0) {
          uint64_t v19 = 0;
        }
      }
      return CA::Shape::new_shape((unsigned int *)&v18);
    }
    int32x2_t v16 = 0;
    uint64_t v17 = 1;
    double v15 = 0;
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    unint64_t v18 = this;
    int32x2_t v13 = vadd_s32((int32x2_t)__PAIR64__(a3, a2), (int32x2_t)__PAIR64__(a3, a2));
    while (CA::ShapeIterator::iterate((uint64_t *)&v18, (int *)&v15))
    {
      LODWORD(v15) = v15 - a2;
      HIDWORD(v15) -= a3;
      int32x2_t v16 = vadd_s32(v16, v13);
      CA::shape_union((CA::Shape **)&v17, &v15, v14);
    }
    return v17;
  }

  return CA::Shape::ref(this);
}

float CA::OGL::anonymous namespace'::GradientRectState::map_(uint64_t a1, double a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *(void *)(a1 + 48);
  int v6 = *(_DWORD *)(v5 + 104);
  if (v6 == 117)
  {
    double v17 = *(double *)(v5 + 72);
    double v16 = *(double *)(v5 + 80);
    a2 = *(double *)(v5 + 88) - v17;
    double v18 = *(double *)(v5 + 96) - v16;
    float v19 = sqrt(a2 * a2 + v18 * v18);
    double v20 = 0.0;
    if (v19 != 0.0) {
      double v20 = (float)(-1.0 / v19);
    }
    if (a5)
    {
      *(float *)&a2 = v20 * a2;
      float v21 = v20 * v18;
      float v22 = v17 * 2.0 + -1.0;
      float v23 = v16 * 2.0 + -1.0;
      uint32x2_t v24 = (float *)(a4 + 20);
      do
      {
        float v25 = *(v24 - 1) - v22;
        float v26 = *v24 + v23;
        *(v24 - 1) = -(float)((float)(v26 * v21) - (float)(v25 * *(float *)&a2));
        *uint32x2_t v24 = (float)(v25 * v21) + (float)(v26 * *(float *)&a2);
        v24 += 12;
        --a5;
      }
      while (a5);
    }
  }
  else if (v6 == 51)
  {
    *(float *)&a2 = *(double *)(v5 + 72);
    float v7 = *(double *)(v5 + 80);
    float v8 = *(double *)(v5 + 88) - *(float *)&a2;
    float v9 = *(double *)(v5 + 96) - v7;
    float v10 = (float)(v8 * v8) + (float)(v9 * v9);
    float v11 = 1.0 / v10;
    if (v10 == 0.0) {
      float v11 = (float)(v8 * v8) + (float)(v9 * v9);
    }
    if (a5)
    {
      int v12 = *(float **)(a1 + 56);
      float v13 = *v12;
      float v14 = v11 * (float)(v12[2] - *v12);
      double v15 = (float *)(a4 + 20);
      do
      {
        *(v15 - 1) = v13
                   + (float)(v14
                           * (float)((float)((float)(*(v15 - 1) - *(float *)&a2) * v8) + (float)((float)(*v15 - v7) * v9)));
        *double v15 = v12[1];
        v15 += 12;
        --a5;
      }
      while (a5);
    }
  }
  return *(float *)&a2;
}

uint64_t CA::OGL::MaskNode::MaskRectState::map_(uint64_t result, float32x2_t *a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v3 = **(void **)(result + 48);
    v4.i64[0] = (int)v3;
    v4.i64[1] = SHIDWORD(v3);
    float64x2_t v5 = vcvtq_f64_s64(v4);
    int v6 = a2 + 2;
    do
    {
      float64x2_t v7 = vcvtq_f64_f32(v6[-2]);
      float v8 = v6[-1].f32[1];
      if (v8 != 1.0) {
        float64x2_t v7 = vmulq_n_f64(v7, 1.0 / v8);
      }
      float32x2_t *v6 = vcvt_f32_f64(vsubq_f64(v7, v5));
      v6 += 6;
      --a3;
    }
    while (a3);
  }
  return result;
}

BOOL CAFrameRateRangeIsEqualToRange(CAFrameRateRange range, CAFrameRateRange other)
{
  return range.minimum == other.minimum && range.maximum == other.maximum && range.preferred == other.preferred;
}

uint64_t CA::Transaction::get_value(uint64_t result, int a2, const CGAffineTransform *a3, CA::Mat4Impl *this)
{
  if (result)
  {
    float64x2_t v7 = (void *)result;
    while (1)
    {
      uint64_t v8 = v7[2];
      if (v8)
      {
        if (CA::AttrList::get(v8, a2, a3, this)) {
          break;
        }
      }
      float64x2_t v7 = (void *)*v7;
      if (!v7) {
        return 0;
      }
    }
    return 1;
  }
  return result;
}

void CA::Layer::mark_visible(CA::Layer *this, CA::Transaction *a2, BOOL a3)
{
  int v3 = *((_DWORD *)this + 13);
  if (a3 == (v3 & 0x100000u) >> 20) {
    return;
  }
  unsigned int v7 = v3 & 0xFFEFFFFF;
  if (a3) {
    int v8 = 0x100000;
  }
  else {
    int v8 = 0;
  }
  *((_DWORD *)this + 13) = v7 | v8;
  if (*((void *)this + 35))
  {
    if (a3)
    {
      if (non_visible_animating_layers) {
        CFSetRemoveValue((CFMutableSetRef)non_visible_animating_layers, this);
      }
    }
    else
    {
      add_non_visible_animating_layer(this);
    }
    CA::Layer::mark(this, a2, 2099208, 2064);
    if (!**((_DWORD **)a2 + 13)) {
      CA::Transaction::ensure_implicit(a2, 1);
    }
  }
  float v9 = (void *)*((void *)this + 2);
  if ([v9 _defersDidBecomeVisiblePostCommit])
  {
    uint64_t v11 = *((void *)a2 + 10);
    if (v11)
    {
      while (*(CA::Layer **)v11 != this)
      {
        uint64_t v11 = *(void *)(v11 + 8);
        if (!v11) {
          goto LABEL_18;
        }
      }
    }
    else
    {
      do
      {
LABEL_18:
        int v13 = *(_DWORD *)this;
        if (!*(_DWORD *)this) {
          break;
        }
        int v12 = *(_DWORD *)this;
        atomic_compare_exchange_strong((atomic_uint *volatile)this, (unsigned int *)&v12, v13 + 1);
      }
      while (v12 != v13);
      uint64_t v14 = *((void *)a2 + 10);
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      double v16 = malloc_type_zone_malloc(malloc_zone, 0x10uLL, 0x8BB15036uLL);
      *double v16 = this;
      v16[1] = v14;
      *((void *)a2 + 10) = v16;
    }
  }
  else
  {
    [v9 layerDidBecomeVisible:a3];
  }
  double v17 = (void *)*((void *)this + 3);
  if (v17)
  {
    double v18 = v17 + 1;
    uint64_t v19 = v17[2];
    if (v19 == 1)
    {
      if (!v17[3])
      {
        do
        {
LABEL_27:
          uint64_t v20 = *v18++;
          CA::Layer::mark_visible(*(CA::Layer **)(v20 + 16), a2, a3, v10);
          --v19;
        }
        while (v19);
        goto LABEL_28;
      }
    }
    else if (!v19)
    {
      goto LABEL_28;
    }
    double v18 = (uint64_t *)*v18;
    goto LABEL_27;
  }
LABEL_28:
  uint64_t v21 = *((void *)this + 4);
  if (v21) {
    CA::Layer::mark_visible(*(CA::Layer **)(v21 + 16), a2, a3, v10);
  }
  float v22 = (void *)*((void *)this + 2);
  if (v22)
  {
    float v23 = (const void *)[*((id *)this + 2) contents];
    if (v23)
    {
      uint64_t v24 = (uint64_t)v23;
      CFTypeID v25 = CFGetTypeID(v23);
      if (CABackingStoreGetTypeID::once[0] != -1) {
        dispatch_once(CABackingStoreGetTypeID::once, &__block_literal_global_907);
      }
      if (v25 == CABackingStoreGetTypeID::type)
      {
        __int16 v26 = *(_WORD *)(v24 + 492);
        char v27 = CABackingStoreSetVolatile(v24, a3 ^ 1);
        if (!a3 || (v27 & 1) != 0)
        {
          if (!a3 || (v26 & 0x100) != 0) {
            CA::Layer::mark(this, a2, 1032, 16);
          }
        }
        else
        {
          [v22 setNeedsDisplay];
        }
        if (a3)
        {
          int32x2_t v28 = (CGColorSpace *)[*((id *)this + 2) _retainColorSpace];
          if (CABackingStoreSetColorSpace(v24, v28)) {
            [v22 setNeedsDisplay];
          }
          CGColorSpaceRelease(v28);
        }
      }
      else if (v25 == CGImageGetTypeID() && a3)
      {
        [v22 setContentsChanged];
      }
    }
  }
  if (a3) {
    uint32x2_t v29 = @"onOrderIn";
  }
  else {
    uint32x2_t v29 = @"onOrderOut";
  }
  long long v30 = (char *)a2 + 88;
  while (1)
  {
    long long v30 = *(char **)v30;
    if (!v30) {
      break;
    }
    if (v30[28])
    {
      if (v30[24]) {
        return;
      }
      break;
    }
  }
  int v31 = (void *)[v9 actionForKey:v29];
  if (v31)
  {
    [v31 runActionForKey:v29 object:v9 arguments:0];
  }
}

void CA::Layer::begin_change(CA::Layer *this, CA::Transaction *a2, void *a3, objc_object *a4, objc_object **a5)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if (!**((_DWORD **)a2 + 13)) {
    CA::Transaction::ensure_implicit(a2, 1);
  }
  if (byte_1EB2ACBEF)
  {
    if (x_log_hook_p())
    {
      uint64_t v17 = [a3 UTF8String];
      Class isa = a4->isa;
      double v15 = a2;
      double v16 = this;
      x_log_();
    }
    else
    {
      int v12 = x_log_category_api;
      if (os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v13 = [a3 UTF8String];
        Class v14 = a4->isa;
        *(_DWORD *)buf = 134218754;
        uint64_t v20 = a2;
        __int16 v21 = 2048;
        float v22 = this;
        __int16 v23 = 2080;
        uint64_t v24 = v13;
        __int16 v25 = 2048;
        Class v26 = v14;
        _os_log_impl(&dword_184668000, v12, OS_LOG_TYPE_DEFAULT, "Began transaction (%p) change on layer %p for %s, %p", buf, 0x2Au);
      }
    }
  }
  if ((*((_DWORD *)this + 1) & 0x8000) != 0) {
    [MEMORY[0x1E4F1CA00] raise:@"CALayerReadOnly", @"attempting to modify read-only layer %@", a5, *((void *)this + 2) format];
  }
  if ((*((_DWORD *)this + 1) & 0x60000) != 0)
  {
    a4->Class isa = 0;
  }
  else
  {
    float v9 = (void *)*((void *)this + 2);
    BOOL v10 = (char *)a2 + 88;
    do
    {
      BOOL v10 = *(char **)v10;
      if (!v10) {
        goto LABEL_12;
      }
    }
    while ((v10[28] & 1) == 0);
    if ((v10[24] & 1) == 0)
    {
LABEL_12:
      uint64_t v11 = (objc_class *)objc_msgSend(v9, "actionForKey:", a3, a4, a5, v15, v16, v17, isa);
      goto LABEL_14;
    }
    uint64_t v11 = 0;
LABEL_14:
    a4->Class isa = v11;
    objc_msgSend(v9, "willChangeValueForKey:", a3, v15);
  }
}

void sub_184680E38(_Unwind_Exception *exception_object)
{
}

void CA::Layer::setter(CA::Transaction *a1, const void *a2, const CGAffineTransform *a3, double *a4)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  int v8 = CA::Transaction::ensure_compat(a1);
  int v9 = *((_DWORD *)v8 + 25);
  *((_DWORD *)v8 + 25) = v9 + 1;
  if (!v9) {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
  }
  long long v49 = 0u;
  long long v50 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v46 = 0u;
  memset(&v45, 0, sizeof(v45));
  uint64_t v10 = *((void *)a1 + 9);
  if (!v10 || (CA::AttrList::get(v10, (int)a2, a3, (CA::Mat4Impl *)&v45) & 1) == 0) {
    CA::Layer::default_value((id *)a1, a2, a3, (uint64_t)&v45);
  }
  switch((int)a3)
  {
    case 1:
    case 4:
    case 5:
    case 13:
    case 14:
    case 15:
    case 16:
      if (*(void *)&v45.a != *(void *)a4) {
        goto LABEL_55;
      }
      goto LABEL_58;
    case 2:
    case 3:
      uint64_t v13 = *(const void **)a4;
      if (*(void *)&v45.a != *(void *)a4 && (!*(void *)&v45.a || !v13 || !CFEqual(*(CFTypeRef *)&v45.a, v13))) {
        goto LABEL_55;
      }
      goto LABEL_58;
    case 6:
    case 7:
    case 8:
      int a_low = LOBYTE(v45.a);
      int v12 = *(unsigned __int8 *)a4;
      goto LABEL_17;
    case 9:
    case 10:
      int a_low = LOWORD(v45.a);
      int v12 = *(unsigned __int16 *)a4;
      goto LABEL_17;
    case 11:
    case 12:
      int a_low = LODWORD(v45.a);
      int v12 = *(_DWORD *)a4;
LABEL_17:
      if (a_low == v12) {
        goto LABEL_58;
      }
      goto LABEL_55;
    case 17:
      if (*(float *)&v45.a != *(float *)a4) {
        goto LABEL_55;
      }
      goto LABEL_58;
    case 18:
      double a = v45.a;
      double v16 = *a4;
      goto LABEL_28;
    case 19:
    case 20:
      if (v45.a != *a4 || v45.b != a4[1]) {
        goto LABEL_55;
      }
      goto LABEL_58;
    case 21:
      v52.origin = *(CGPoint *)&v45.a;
      v52.size = *(CGSize *)&v45.c;
      if (CGRectEqualToRect(v52, *(CGRect *)a4)) {
        goto LABEL_58;
      }
      goto LABEL_55;
    case 22:
      long long v39 = v47;
      long long v40 = v48;
      long long v41 = v49;
      long long v42 = v50;
      *(_OWORD *)&v35[0].Class isa = *(_OWORD *)&v45.a;
      long long v36 = *(_OWORD *)&v45.c;
      long long v37 = *(_OWORD *)&v45.tx;
      long long v38 = v46;
      long long v17 = *(_OWORD *)a4;
      long long v18 = *((_OWORD *)a4 + 1);
      long long v19 = *((_OWORD *)a4 + 3);
      v34[2] = *((_OWORD *)a4 + 2);
      v34[3] = v19;
      v34[0] = v17;
      v34[1] = v18;
      long long v20 = *((_OWORD *)a4 + 4);
      long long v21 = *((_OWORD *)a4 + 5);
      long long v22 = *((_OWORD *)a4 + 7);
      v34[6] = *((_OWORD *)a4 + 6);
      v34[7] = v22;
      v34[4] = v20;
      v34[5] = v21;
      if (v45.a != *(double *)v34) {
        goto LABEL_55;
      }
      uint64_t v23 = 1;
      break;
    case 23:
      CGAffineTransform t1 = v45;
      long long v27 = *((_OWORD *)a4 + 1);
      *(_OWORD *)&t2.double a = *(_OWORD *)a4;
      *(_OWORD *)&t2.c = v27;
      *(_OWORD *)&t2.tx = *((_OWORD *)a4 + 2);
      if (CGAffineTransformEqualToTransform(&t1, &t2)) {
        goto LABEL_58;
      }
      goto LABEL_55;
    case 24:
      BOOL v28 = v45.a == *a4 && v45.b == a4[1];
      if (!v28 || v45.c != a4[2]) {
        goto LABEL_55;
      }
      goto LABEL_58;
    case 25:
      if (*(double *)&v46 != a4[6]
        || *((double *)&v46 + 1) != a4[7]
        || v45.tx != a4[4]
        || v45.ty != a4[5]
        || v45.a != *a4
        || v45.b != a4[1]
        || v45.c != a4[2])
      {
        goto LABEL_55;
      }
      double a = v45.d;
      double v16 = a4[3];
LABEL_28:
      if (a != v16) {
        goto LABEL_55;
      }
      goto LABEL_58;
    default:
      goto LABEL_55;
  }
  while (v23 != 16)
  {
    uint64_t v24 = v23;
    Class isa = v35[v23].isa;
    double v26 = *((double *)v34 + v23++);
    if (*(double *)&isa != v26)
    {
      if ((unint64_t)(v24 - 1) <= 0xE)
      {
LABEL_55:
        v35[0].Class isa = 0;
        String = (objc_object *)CAAtomGetString(a2);
        CA::Layer::begin_change(a1, v8, String, v35, v30);
        int v31 = CA::Layer::writable_state(a1, v8);
        int v32 = (CA::AttrList *)*((void *)v31 + 4);
        if (!v32)
        {
          malloc_zone = (malloc_zone_t *)get_malloc_zone();
          int v32 = (CA::AttrList *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x10uLL, 0x743898A5uLL);
        }
        *((void *)v31 + 4) = CA::AttrList::set(v32, a2, (int)a3, (unsigned __int8 *)a4);
        CA::Layer::end_change((id *)a1, v8, (int)a2, String, (objc_object *)v35[0].isa);
      }
      break;
    }
  }
LABEL_58:
  CA::Transaction::unlock(v8);
}

void sub_184681214(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_184681354(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

void CA::Layer::getter(CA::Transaction *a1, unsigned int a2, const CGAffineTransform *a3, id *a4)
{
  int v8 = CA::Transaction::ensure_compat(a1);
  int v9 = *((_DWORD *)v8 + 25);
  *((_DWORD *)v8 + 25) = v9 + 1;
  if (!v9) {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
  }
  uint64_t v10 = *((void *)a1 + 9);
  if (v10 && CA::AttrList::get(v10, a2, a3, (CA::Mat4Impl *)a4))
  {
    if ((a3 & 0xFFFFFFFE) == 2) {
      id v11 = *a4;
    }
  }
  else
  {
    CA::Layer::default_value((id *)a1, a2, a3, (uint64_t)a4);
  }

  CA::Transaction::unlock(v8);
}

void sub_184681428(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

CA::Transaction *CA::Transaction::ensure_compat(CA::Transaction *this)
{
  uint64_t v1 = *(CA::Transaction **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 576);
  if (!v1) {
    uint64_t v1 = (CA::Transaction *)CA::Transaction::create(this);
  }
  if ((*((unsigned char *)v1 + 116) & 0x10) != 0 && !**((_DWORD **)v1 + 13)) {
    CA::Transaction::ensure_implicit(v1, 1);
  }
  return v1;
}

uint64_t CAObject_defaultValueForAtom(objc_class *a1, int a2, const CGAffineTransform *a3, uint64_t a4)
{
  uint64_t result = classDescription(a1);
  if (result)
  {
    int v8 = (void *)result;
    while (1)
    {
      uint64_t result = v8[(a2 & 7) + 6];
      if (result)
      {
        uint64_t result = CA::AttrList::get(result, a2, a3, (CA::Mat4Impl *)a4);
        if (result) {
          break;
        }
      }
      int v8 = (void *)*v8;
      if (!v8) {
        goto LABEL_6;
      }
    }
  }
  else
  {
LABEL_6:
    switch((int)a3)
    {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 13:
      case 14:
      case 15:
      case 16:
      case 18:
        *(void *)a4 = 0;
        return result;
      case 6:
      case 7:
      case 8:
        *(unsigned char *)a4 = 0;
        return result;
      case 9:
      case 10:
        *(_WORD *)a4 = 0;
        return result;
      case 11:
      case 12:
      case 17:
        *(_DWORD *)a4 = 0;
        return result;
      case 19:
        int v9 = (long long *)MEMORY[0x1E4F1DAD8];
        goto LABEL_13;
      case 20:
        int v9 = (long long *)MEMORY[0x1E4F1DB30];
LABEL_13:
        long long v10 = *v9;
        goto LABEL_20;
      case 21:
        long long v10 = *MEMORY[0x1E4F1DB20];
        long long v11 = *(_OWORD *)(MEMORY[0x1E4F1DB20] + 16);
        goto LABEL_17;
      case 22:
        *(CATransform3D *)a4 = CATransform3DIdentity;
        return result;
      case 23:
        long long v10 = *MEMORY[0x1E4F1DAB8];
        long long v11 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
        *(_OWORD *)(a4 + 32) = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 32);
LABEL_17:
        *(_OWORD *)(a4 + 16) = v11;
        goto LABEL_20;
      case 24:
        *(void *)a4 = 0;
        *(void *)(a4 + 8) = 0;
        *(void *)(a4 + 16) = 0;
        return result;
      case 25:
        long long v10 = 0uLL;
        *(_OWORD *)(a4 + 32) = 0u;
        *(_OWORD *)(a4 + 48) = 0u;
        *(_OWORD *)(a4 + 16) = 0u;
LABEL_20:
        *(_OWORD *)a4 = v10;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t CA::AttrList::get(uint64_t result, int a2, const CGAffineTransform *a3, CA::Mat4Impl *this)
{
  while (1)
  {
    uint64_t result = *(void *)result;
    if (!result) {
      return result;
    }
    unsigned int v5 = *(_DWORD *)(result + 8);
    if ((v5 & 0xFFFFFF) == a2)
    {
      if (!this) {
        return 1;
      }
      switch(HIBYTE(v5) & 0x7F)
      {
        case 1:
          if ((a3 - 1) > 3) {
            goto LABEL_40;
          }
          uint64_t v8 = **(void **)(result + 16);
          goto LABEL_21;
        case 2:
        case 3:
          if ((a3 - 1) > 3) {
            goto LABEL_40;
          }
          goto LABEL_20;
        case 4:
          if ((a3 - 1) > 3) {
            goto LABEL_40;
          }
          uint64_t v9 = *(void *)(result + 16);
          if (*(unsigned char *)(v9 + 8)) {
            id Weak = objc_loadWeak((id *)v9);
          }
          else {
            id Weak = *(id *)v9;
          }
          *(void *)this = Weak;
          return 1;
        case 5:
          if (a3 != 5) {
            goto LABEL_40;
          }
LABEL_20:
          uint64_t v8 = *(void *)(result + 16);
LABEL_21:
          *(void *)this = v8;
          return 1;
        case 6:
        case 7:
        case 8:
        case 9:
        case 0xA:
        case 0xB:
        case 0xC:
        case 0xD:
        case 0xE:
          switch((int)a3)
          {
            case 6:
              goto LABEL_41;
            case 7:
            case 8:
              goto LABEL_6;
            case 9:
            case 10:
              goto LABEL_10;
            case 11:
            case 12:
              goto LABEL_13;
            case 13:
            case 14:
            case 15:
            case 16:
              goto LABEL_20;
            case 17:
              float v26 = (float)*(uint64_t *)(result + 16);
              goto LABEL_47;
            case 18:
              double v6 = (double)*(uint64_t *)(result + 16);
              goto LABEL_49;
            default:
              goto LABEL_40;
          }
        case 0xF:
        case 0x10:
          switch((int)a3)
          {
            case 6:
LABEL_41:
              BOOL v25 = *(void *)(result + 16) == 0;
              goto LABEL_42;
            case 7:
            case 8:
LABEL_6:
              *(unsigned char *)this = *(void *)(result + 16);
              return 1;
            case 9:
            case 10:
LABEL_10:
              *(_WORD *)this = *(void *)(result + 16);
              return 1;
            case 11:
            case 12:
LABEL_13:
              *(_DWORD *)this = *(void *)(result + 16);
              return 1;
            case 13:
            case 14:
            case 15:
            case 16:
              goto LABEL_20;
            case 17:
              float v26 = (float)*(unint64_t *)(result + 16);
              goto LABEL_47;
            case 18:
              double v6 = (double)*(unint64_t *)(result + 16);
              goto LABEL_49;
            default:
              goto LABEL_40;
          }
        case 0x11:
        case 0x12:
          double v6 = *(double *)(result + 16);
          switch((int)a3)
          {
            case 6:
              BOOL v25 = v6 == 0.0;
LABEL_42:
              LOBYTE(v7) = !v25;
              goto LABEL_45;
            case 7:
            case 8:
              int v7 = (int)v6;
LABEL_45:
              *(unsigned char *)this = v7;
              return 1;
            case 9:
            case 10:
              *(_WORD *)this = (int)v6;
              return 1;
            case 11:
              int v27 = (int)v6;
              goto LABEL_61;
            case 12:
              int v27 = v6;
LABEL_61:
              *(_DWORD *)this = v27;
              break;
            case 13:
            case 15:
              uint64_t v8 = (uint64_t)v6;
              goto LABEL_21;
            case 14:
            case 16:
              uint64_t v8 = (unint64_t)v6;
              goto LABEL_21;
            case 17:
              float v26 = v6;
LABEL_47:
              *(float *)this = v26;
              return 1;
            case 18:
LABEL_49:
              *(double *)this = v6;
              return 1;
            default:
              goto LABEL_40;
          }
          return 1;
        case 0x13:
          if (a3 != 19) {
            goto LABEL_40;
          }
          goto LABEL_32;
        case 0x14:
          if (a3 != 20) {
            goto LABEL_40;
          }
LABEL_32:
          long long v12 = *(_OWORD *)*(void *)(result + 16);
          goto LABEL_39;
        case 0x15:
          if (a3 != 21) {
            goto LABEL_40;
          }
          long long v11 = *(long long **)(result + 16);
          long long v12 = *v11;
          long long v13 = v11[1];
          goto LABEL_36;
        case 0x16:
          if (a3 == 23)
          {
            CA::Mat4Impl::mat4_set_transform(this, *(double **)(result + 16), a3);
            return 1;
          }
          if (a3 == 22)
          {
            Class v14 = *(_OWORD **)(result + 16);
            long long v15 = v14[1];
            long long v16 = v14[2];
            long long v17 = v14[3];
            *(_OWORD *)this = *v14;
            *((_OWORD *)this + 1) = v15;
            *((_OWORD *)this + 2) = v16;
            *((_OWORD *)this + 3) = v17;
            long long v18 = v14[5];
            long long v19 = v14[6];
            long long v20 = v14[7];
            *((_OWORD *)this + 4) = v14[4];
            *((_OWORD *)this + 5) = v18;
            *((_OWORD *)this + 6) = v19;
            *((_OWORD *)this + 7) = v20;
            return 1;
          }
LABEL_40:
          uint64_t result = 0;
          break;
        case 0x17:
          if (a3 != 23) {
            goto LABEL_40;
          }
          uint64_t v23 = *(long long **)(result + 16);
          long long v12 = *v23;
          long long v13 = v23[1];
          long long v22 = v23[2];
          goto LABEL_35;
        case 0x18:
          if (a3 != 24) {
            goto LABEL_40;
          }
          uint64_t v24 = *(long long **)(result + 16);
          long long v12 = *v24;
          *((void *)this + 2) = *((void *)v24 + 2);
          goto LABEL_39;
        case 0x19:
          if (a3 != 25) {
            goto LABEL_40;
          }
          long long v21 = *(long long **)(result + 16);
          long long v12 = *v21;
          long long v13 = v21[1];
          long long v22 = v21[2];
          *((_OWORD *)this + 3) = v21[3];
LABEL_35:
          *((_OWORD *)this + 2) = v22;
LABEL_36:
          *((_OWORD *)this + 1) = v13;
LABEL_39:
          *(_OWORD *)this = v12;
          return 1;
        default:
          goto LABEL_40;
      }
      return result;
    }
  }
}

uint64_t classDescription(objc_class *a1)
{
  v9[1] = *MEMORY[0x1E4F143B8];
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  uint64_t v3 = *(void *)(StatusReg + 584);
  if (!v3 || *(objc_class **)(v3 + 8) != a1)
  {
    pthread_mutex_lock(&class_table_lock);
    if (!class_table)
    {
      int64x2_t v4 = (int *)x_hash_table_new_(0, 0, 0, 0, 0, 0);
      class_table = (uint64_t)v4;
      uint64_t v5 = objc_opt_class();
      hash_table_modify(v4, v5, 0, 0);
      pthread_key_init_np();
      double v6 = getenv("CA_LOG_CLASS_DESCRIPTIONS");
      if (v6) {
        log_class_descriptions = atoi(v6) != 0;
      }
    }
    v9[0] = 0;
    uint64_t v7 = x_hash_table_lookup(class_table, (uint64_t)a1, v9);
    if (!v9[0]) {
      uint64_t v7 = classDescription_locked(a1);
    }
    uint64_t v3 = v7;
    *(void *)(StatusReg + 584) = v7;
    pthread_mutex_unlock(&class_table_lock);
  }
  return v3;
}

void sub_184681A0C(_Unwind_Exception *a1)
{
}

double CA::Layer::default_value(id *this, unsigned int a2, const CGAffineTransform *a3, uint64_t a4)
{
  v11[1] = *(objc_object **)MEMORY[0x1E4F143B8];
  if (a2 != 545
    && (this[7] & 0x100) != 0
    && (v11[0] = 0, CA::Layer::style_value((CA::Layer *)this, a2, v11)))
  {
    long long v10 = v11[0];
    return CAValueObjCUnbox(v10, (int)a3, a4);
  }
  else
  {
    Class = object_getClass(this[2]);
    CAObject_defaultValueForAtom(Class, a2, a3, a4);
  }
  return result;
}

CA::AttrList *CA::AttrList::set(CA::AttrList *this, const void *a2, int a3, unsigned __int8 *a4)
{
  int v6 = (int)a2;
  uint64_t v7 = this;
  int v8 = *((_DWORD *)this + 2) & 7;
  if (v8)
  {
    do
    {
      uint64_t v9 = (CA::AttrList *)CA::AttrList::copy_(v7);
      *((void *)v7 + 1) = *((void *)v7 + 1) & 0xFFFFFFFFFFFFFFF8 | (v8 - 1);
      uint64_t v7 = v9;
      int v8 = *((_DWORD *)v9 + 2) & 7;
    }
    while (v8);
  }
  else
  {
    uint64_t v9 = this;
  }
  long long v10 = *(void ***)v9;
  if (!*(void *)v9)
  {
LABEL_14:
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    long long v10 = (void **)malloc_type_zone_malloc(malloc_zone, 0x18uLL, 0x8BB15036uLL);
    *((_DWORD *)v10 + 2) = v6 & 0xFFFFFF;
    double v10[2] = 0;
    *long long v10 = *(void **)v9;
    *(void *)uint64_t v9 = v10;
    goto LABEL_15;
  }
  int v11 = *((_DWORD *)v10 + 2);
  if ((v11 & 0xFFFFFF) != v6)
  {
    char v12 = 0;
    Class v14 = *(void ***)v9;
    while (1)
    {
      long long v10 = (void **)*v14;
      if (!*v14) {
        goto LABEL_14;
      }
      v12 |= v11 < 0;
      int v11 = *((_DWORD *)v10 + 2);
      long long v13 = v14;
      Class v14 = (void **)*v14;
      if ((v11 & 0xFFFFFF) == v6) {
        goto LABEL_11;
      }
    }
  }
  char v12 = 0;
  long long v13 = v9;
LABEL_11:
  if ((v12 & 1) != 0 || v11 < 0)
  {
    long long v15 = (malloc_zone_t *)get_malloc_zone();
    long long v16 = malloc_type_zone_malloc(v15, 0x18uLL, 0x8BB15036uLL);
    v16[2] = v6 & 0xFFFFFF;
    *((void *)v16 + 2) = 0;
    void *v13 = *v10;
    *(void *)long long v16 = *(void *)v9;
    *(void *)uint64_t v9 = v16;
    CA::AttrList::splice_shared_node((uint64_t)v9, v10);
    long long v10 = (void **)v16;
  }
LABEL_15:
  if ((*((unsigned char *)v10 + 11) & 0x7F) != a3)
  {
    CA::AttrList::Node::free_memory((CA::AttrList::Node *)v10, a2);
    CA::AttrList::Node::alloc_memory(v10, a3);
  }
  switch(a3)
  {
    case 1:
      *(void *)double v10[2] = *(void *)a4;
      return v9;
    case 2:
      long long v21 = *(const void **)a4;
      long long v22 = v10[2];
      if (v22 != v21)
      {
        if (v22) {
          CA::Transaction::cf_release(v22, a2);
        }
        if (v21) {
          uint64_t v23 = (uint64_t)CFRetain(v21);
        }
        else {
          uint64_t v23 = 0;
        }
        goto LABEL_55;
      }
      return v9;
    case 3:
      uint64_t v24 = *(void **)a4;
      BOOL v25 = v10[2];
      if (v25 != v24)
      {
        if (v25) {
          CA::Transaction::cf_release(v25, a2);
        }
        uint64_t v23 = CAValueCopyPointer(v24);
        goto LABEL_55;
      }
      return v9;
    case 4:
      X::WeakDetails::Ptr::set((id *)v10[2], *(id *)a4, 1);
      return v9;
    case 5:
      id v26 = *(id *)a4;
      id v27 = v10[2];
      if (v26 != v27)
      {
        if (v27) {
          _Block_release(v27);
        }
        if (v26)
        {
          uint64_t v23 = (uint64_t)_Block_copy(v26);
LABEL_55:
          double v10[2] = (void *)v23;
        }
        else
        {
          double v10[2] = 0;
        }
      }
      return v9;
    case 6:
    case 8:
      unint64_t v18 = *a4;
      goto LABEL_42;
    case 7:
      unint64_t v18 = (char)*a4;
      goto LABEL_42;
    case 9:
      unint64_t v18 = *(__int16 *)a4;
      goto LABEL_42;
    case 10:
      unint64_t v18 = *(unsigned __int16 *)a4;
      goto LABEL_42;
    case 11:
      unint64_t v18 = *(int *)a4;
      goto LABEL_42;
    case 12:
      unint64_t v18 = *(unsigned int *)a4;
      goto LABEL_42;
    case 13:
    case 14:
    case 15:
    case 16:
      unint64_t v18 = *(void *)a4;
LABEL_42:
      double v10[2] = (void *)v18;
      return v9;
    case 17:
      double v28 = *(float *)a4;
      goto LABEL_45;
    case 18:
      double v28 = *(double *)a4;
LABEL_45:
      *((double *)v10 + 2) = v28;
      return v9;
    case 19:
    case 20:
      long long v19 = v10[2];
      long long v20 = *(_OWORD *)a4;
      goto LABEL_50;
    case 21:
      uint32x2_t v29 = v10[2];
      long long v30 = *(_OWORD *)a4;
      long long v31 = *((_OWORD *)a4 + 1);
      goto LABEL_53;
    case 22:
      int v32 = v10[2];
      long long v33 = *((_OWORD *)a4 + 1);
      long long v34 = *((_OWORD *)a4 + 2);
      long long v35 = *((_OWORD *)a4 + 3);
      _OWORD *v32 = *(_OWORD *)a4;
      v32[1] = v33;
      v32[2] = v34;
      v32[3] = v35;
      long long v36 = *((_OWORD *)a4 + 5);
      long long v37 = *((_OWORD *)a4 + 6);
      long long v38 = *((_OWORD *)a4 + 7);
      v32[4] = *((_OWORD *)a4 + 4);
      v32[5] = v36;
      v32[6] = v37;
      v32[7] = v38;
      return v9;
    case 23:
      uint32x2_t v29 = v10[2];
      long long v30 = *(_OWORD *)a4;
      long long v31 = *((_OWORD *)a4 + 1);
      long long v39 = *((_OWORD *)a4 + 2);
      goto LABEL_52;
    case 24:
      long long v19 = v10[2];
      long long v20 = *(_OWORD *)a4;
      v19[2] = *((void *)a4 + 2);
LABEL_50:
      *(_OWORD *)long long v19 = v20;
      break;
    case 25:
      uint32x2_t v29 = v10[2];
      long long v30 = *(_OWORD *)a4;
      long long v31 = *((_OWORD *)a4 + 1);
      long long v39 = *((_OWORD *)a4 + 2);
      v29[3] = *((_OWORD *)a4 + 3);
LABEL_52:
      int32x2_t v29[2] = v39;
LABEL_53:
      *uint32x2_t v29 = v30;
      v29[1] = v31;
      break;
    default:
      return v9;
  }
  return v9;
}

void CA::AttrList::Node::free_memory(CA::AttrList::Node *this, const void *a2)
{
  switch(*((unsigned char *)this + 11) & 0x7F)
  {
    case 1:
      uint64_t v3 = (unsigned char *)*((void *)this + 2);
      if (v3) {
        goto LABEL_3;
      }
      break;
    case 2:
    case 3:
      uint64_t v5 = (const void *)*((void *)this + 2);
      if (v5) {
        CA::Transaction::cf_release(v5, a2);
      }
      break;
    case 4:
      uint64_t v3 = (unsigned char *)*((void *)this + 2);
      if (v3)
      {
        if (*(void *)v3)
        {
          if (v3[8]) {
            objc_storeWeakOrNil(*((id **)this + 2), 0);
          }
          else {
            *(void *)uint64_t v3 = 0;
          }
        }
        goto LABEL_3;
      }
      break;
    case 5:
      int v6 = (const void *)*((void *)this + 2);
      if (v6) {
        _Block_release(v6);
      }
      break;
    case 0x13:
    case 0x14:
    case 0x15:
    case 0x16:
    case 0x17:
    case 0x18:
    case 0x19:
      uint64_t v3 = (unsigned char *)*((void *)this + 2);
LABEL_3:
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(malloc_zone, v3);
      break;
    default:
      break;
  }
  *((_DWORD *)this + 2) &= 0x80FFFFFF;
}

unsigned char *CA::AttrList::Node::alloc_memory(unsigned char *result, int a2)
{
  char v2 = a2;
  uint64_t v3 = result;
  switch(a2)
  {
    case 19:
    case 20:
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      size_t v5 = 16;
      goto LABEL_12;
    case 21:
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      size_t v5 = 32;
      goto LABEL_12;
    case 22:
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      size_t v5 = 128;
      goto LABEL_12;
    case 23:
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      size_t v5 = 48;
      goto LABEL_12;
    case 24:
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      size_t v5 = 24;
      goto LABEL_12;
    case 25:
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      size_t v5 = 64;
LABEL_12:
      double result = malloc_type_zone_malloc(malloc_zone, v5, 0x8BB15036uLL);
      goto LABEL_13;
    default:
      if (a2 == 4)
      {
        uint64_t v7 = (malloc_zone_t *)get_malloc_zone();
        double result = malloc_type_zone_malloc(v7, 0x10uLL, 0x8BB15036uLL);
        if (result)
        {
          *(void *)double result = 0;
          result[8] = 0;
        }
      }
      else
      {
        if (a2 != 1) {
          goto LABEL_14;
        }
        int v6 = (malloc_zone_t *)get_malloc_zone();
        double result = malloc_type_zone_malloc(v6, 8uLL, 0x8BB15036uLL);
        if (result) {
          *(void *)double result = 0;
        }
      }
LABEL_13:
      *((void *)v3 + 2) = result;
LABEL_14:
      *((_DWORD *)v3 + 2) = *((_DWORD *)v3 + 2) & 0x80FFFFFF | ((v2 & 0x7F) << 24);
      return result;
  }
}

void CA::Layer::set_bounds(CA::Layer *this, const CA::Rect *a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  size_t v5 = CA::Transaction::ensure_compat(this);
  int v6 = *((_DWORD *)v5 + 25);
  *((_DWORD *)v5 + 25) = v6 + 1;
  if (!v6) {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
  }
  if (*((double *)this + 12) == *(double *)a2
    && *((double *)this + 13) == *((double *)a2 + 1)
    && *((double *)this + 14) == *((double *)a2 + 2)
    && *((double *)this + 15) == *((double *)a2 + 3))
  {
    int v8 = (char *)this + 40;
  }
  else
  {
    v12[0].Class isa = 0;
    CA::Layer::begin_change(this, v5, @"bounds", v12, v4);
    uint64_t v7 = CA::Layer::writable_state(this, v5);
    int v8 = v7;
    *(_OWORD *)(v7 + 56) = *(_OWORD *)a2;
    *(_OWORD *)(v7 + 72) = *((_OWORD *)a2 + 1);
    if (*((double *)a2 + 1) == 0.0 && *(double *)a2 == 0.0) {
      int v10 = 0;
    }
    else {
      int v10 = 0x4000000;
    }
    *((_DWORD *)v7 + 3) = *((_DWORD *)v7 + 3) & 0xFBFFFFFF | v10;
    CA::Layer::end_change((id *)this, v5, 74, (objc_object *)@"bounds", (objc_object *)v12[0].isa);
  }
  if ((v8[18] & 8) == 0)
  {
    int v11 = CA::Layer::writable_state(this, v5);
    *((_DWORD *)v11 + 4) |= 0x80000u;
  }

  CA::Transaction::unlock(v5);
}

void sub_184682578(_Unwind_Exception *exception_object)
{
}

void CA::Layer::set_position(double *a1, uint64_t a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  size_t v5 = CA::Transaction::ensure_compat((CA::Transaction *)a1);
  int v6 = *((_DWORD *)v5 + 25);
  *((_DWORD *)v5 + 25) = v6 + 1;
  if (!v6) {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
  }
  if (a1[10] == *(double *)a2 && a1[11] == *(double *)(a2 + 8))
  {
    uint64_t v7 = (char *)(a1 + 5);
  }
  else
  {
    v9[0].Class isa = 0;
    CA::Layer::begin_change((CA::Layer *)a1, v5, @"position", v9, v4);
    uint64_t v7 = CA::Layer::writable_state((CA::Layer *)a1, v5);
    *(_OWORD *)(v7 + 40) = *(_OWORD *)a2;
    CA::Layer::end_change((id *)a1, v5, 438, (objc_object *)@"position", (objc_object *)v9[0].isa);
  }
  if ((v7[18] & 4) == 0)
  {
    int v8 = CA::Layer::writable_state((CA::Layer *)a1, v5);
    *((_DWORD *)v8 + 4) |= 0x40000u;
  }

  CA::Transaction::unlock(v5);
}

void sub_184682814(_Unwind_Exception *exception_object)
{
}

void CA::Layer::set_bit(CA::Transaction *a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5, unint64_t a6, uint64_t a7)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = CA::Transaction::ensure_compat(a1);
  int v14 = *((_DWORD *)v13 + 25);
  *((_DWORD *)v13 + 25) = v14 + 1;
  if (!v14) {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
  }
  long long v15 = (char *)a1 + 40;
  uint64_t v16 = a3 >> 5;
  int v17 = 1 << a3;
  if (((*((_DWORD *)a1 + v16 + 11) & (1 << a3)) != 0) != a5)
  {
    v27.Class isa = 0;
    String = (objc_object *)CAAtomGetString(a2);
    CA::Layer::begin_change(a1, v13, String, &v27, v19);
    long long v15 = CA::Layer::writable_state(a1, v13);
    long long v20 = &v15[4 * v16];
    if (a5) {
      int v21 = *((_DWORD *)v20 + 1) | v17;
    }
    else {
      int v21 = *((_DWORD *)v20 + 1) & ~v17;
    }
    *((_DWORD *)v20 + 1) = v21;
    if (a7 & 1 | a6)
    {
      long long v22 = (void *)((char *)a1 + (a7 >> 1));
      if (a7) {
        a6 = *(void *)(*v22 + a6);
      }
      ((void (*)(void *, CA::Transaction *))a6)(v22, v13);
    }
    CA::Layer::end_change((id *)a1, v13, a2, String, (objc_object *)v27.isa);
  }
  uint64_t v23 = a4 >> 5;
  int v24 = 1 << a4;
  if ((*(_DWORD *)&v15[4 * v23 + 4] & v24) == 0)
  {
    BOOL v25 = CA::Layer::writable_state(a1, v13);
    *(_DWORD *)&v25[4 * v23 + 4] |= v24;
  }

  CA::Transaction::unlock(v13);
}

void sub_1846829F4(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

void CA::Layer::end_change(id *this, CA::Transaction *a2, int a3, objc_object *a4, objc_object *a5)
{
  CA::Layer::property_did_change(this, a2, a3);
  if ((*((_DWORD *)this + 1) & 0x60000) != 0)
  {
    if (!a5) {
      return;
    }
  }
  else
  {
    [this[2] didChangeValueForKey:a4];
    if (!a5) {
      return;
    }
  }
  id v8 = this[2];

  [(objc_object *)a5 runActionForKey:a4 object:v8 arguments:0];
}

void CA::Layer::property_did_change(id *this, CA::Transaction *a2, int a3)
{
  uint64_t v108 = *MEMORY[0x1E4F143B8];
  uint64_t v88 = CA::Layer::writable_state((CA::Layer *)this, a2);
  long long v101 = 0u;
  long long v102 = 0u;
  long long v99 = 0u;
  long long v100 = 0u;
  long long v97 = 0u;
  long long v98 = 0u;
  long long v95 = 0u;
  long long v96 = 0u;
  long long v93 = 0u;
  memset(&v94, 0, sizeof(v94));
  long long v92 = 0u;
  double v91 = 0.0;
  int v6 = 0x8000;
  float v90 = 0.0;
  uint64_t v7 = &stru_1ED039300;
  int v8 = byte_1EB2ACBEF;
  if (a3 > 256)
  {
    if (a3 <= 476)
    {
      if (a3 > 396)
      {
        if (a3 > 437)
        {
          switch(a3)
          {
            case 444:
            case 456:
            case 457:
            case 458:
              goto LABEL_76;
            case 445:
            case 447:
            case 448:
            case 449:
            case 450:
            case 452:
            case 453:
            case 454:
            case 455:
              goto LABEL_172;
            case 446:
              int v6 = 0x4000;
              goto LABEL_76;
            case 451:
              goto LABEL_75;
            default:
              if ((a3 - 469) < 2) {
                goto LABEL_104;
              }
              if (a3 != 438) {
                goto LABEL_172;
              }
              goto LABEL_100;
          }
        }
        if (a3 == 397)
        {
          char v16 = 0;
          char v17 = 0;
          goto LABEL_195;
        }
        if (a3 != 409)
        {
          if (a3 == 411) {
            goto LABEL_76;
          }
          goto LABEL_172;
        }
        CA::Layer::getter((CA::Transaction *)this, 0x199u, (const CGAffineTransform *)0x11, (id *)&v90);
        float v26 = v90;
        *((_DWORD *)v88 + 3) = *((_DWORD *)v88 + 3) & 0xF7FFFFFF | ((v90 != 1.0) << 27);
        if (v8)
        {
          uint64_t v22 = objc_msgSend(NSString, "stringWithFormat:", @" to %f", v26);
          goto LABEL_99;
        }
      }
      else
      {
        if (a3 > 363)
        {
          switch(a3)
          {
            case 376:
              goto LABEL_95;
            case 377:
            case 390:
              goto LABEL_76;
            case 378:
LABEL_137:
              int v6 = 16;
              goto LABEL_76;
            case 379:
            case 380:
            case 381:
            case 382:
            case 383:
            case 384:
            case 385:
            case 387:
            case 388:
              goto LABEL_172;
            case 386:
              int v6 = 0x40000;
              goto LABEL_76;
            case 389:
              uint64_t v28 = (__CFString *)[this[2] minificationFilter];
              if (v28 != @"linear")
              {
                CFStringRef v29 = v28;
                if (CAInternAtom(v28, 0) == 341) {
                  CA::Layer::ensure_mipmaps((CFTypeID)this);
                }
                int v30 = CAInternAtom(v29, 0);
                if (v30 == 574 || v30 == 341) {
                  CA::Layer::prevent_subtextures((CFTypeID)this);
                }
                uint64_t v7 = &stru_1ED039300;
              }
              goto LABEL_76;
            default:
              if (a3 != 364 && a3 != 373) {
                goto LABEL_172;
              }
              goto LABEL_76;
          }
        }
        if (a3 > 270)
        {
          switch(a3)
          {
            case 271:
              goto LABEL_76;
            case 334:
LABEL_95:
              int v6 = 4;
              goto LABEL_76;
            case 335:
LABEL_75:
              int v6 = 0x2000;
              goto LABEL_76;
          }
          goto LABEL_172;
        }
        if ((a3 - 260) < 2) {
          goto LABEL_76;
        }
        if (a3 != 257)
        {
          if (a3 == 266)
          {
            int v6 = 0x100000;
            goto LABEL_76;
          }
          goto LABEL_172;
        }
      }
    }
    else
    {
      if (a3 <= 544)
      {
        switch(a3)
        {
          case 501:
          case 502:
          case 503:
          case 504:
          case 505:
          case 506:
          case 516:
            goto LABEL_75;
          case 507:
          case 511:
          case 512:
          case 513:
          case 514:
          case 515:
          case 518:
          case 519:
          case 520:
          case 521:
          case 522:
          case 523:
          case 524:
          case 525:
            goto LABEL_172;
          case 508:
          case 509:
          case 510:
            goto LABEL_76;
          case 517:
            goto LABEL_108;
          case 526:
            goto LABEL_104;
          default:
            if ((a3 - 477) < 4) {
              goto LABEL_75;
            }
            if (a3 != 493) {
              goto LABEL_172;
            }
            goto LABEL_76;
        }
      }
      if (a3 <= 567)
      {
        if (a3 > 557)
        {
          if ((a3 - 562) < 2) {
            goto LABEL_76;
          }
          if (a3 != 558) {
            goto LABEL_172;
          }
          goto LABEL_104;
        }
        if (a3 == 545)
        {
          *((_DWORD *)v88 + 4) |= 0x100u;
          CA::Layer::fetch_defaults((CA::Layer *)this);
          char v16 = 0;
          char v17 = 0;
          int v6 = 0x1FFFFF;
          goto LABEL_195;
        }
        if (a3 != 546)
        {
          if (a3 == 547)
          {
            char v16 = 0;
            char v17 = 32;
            int v6 = 2;
            goto LABEL_195;
          }
          goto LABEL_172;
        }
        CA::Layer::getter((CA::Transaction *)this, 0x222u, (const CGAffineTransform *)0x16, (id *)&v95);
        uint64_t v49 = v95;
        if (*(double *)&v95 == 1.0)
        {
          uint64_t v57 = 1;
          do
          {
            if (v57 == 16)
            {
              long long v50 = (unsigned int *)(v88 + 12);
              unsigned int v51 = *((_DWORD *)v88 + 3) & 0xDFFFFFFF;
              goto LABEL_185;
            }
            uint64_t v58 = v57;
            double v59 = *((double *)&v95 + v57);
            double v60 = *(&CATransform3DIdentity.m11 + v57++);
          }
          while (v59 == v60);
          long long v50 = (unsigned int *)(v88 + 12);
          unsigned int v51 = *((_DWORD *)v88 + 3) & 0xDFFFFFFF;
          if ((unint64_t)(v58 - 1) < 0xF) {
            goto LABEL_168;
          }
LABEL_185:
          int v52 = 0;
        }
        else
        {
          long long v50 = (unsigned int *)(v88 + 12);
          unsigned int v51 = *((_DWORD *)v88 + 3) & 0xDFFFFFFF;
LABEL_168:
          int v52 = 0x20000000;
        }
        *long long v50 = v51 | v52;
        if (v8)
        {
          uint64_t v7 = (__CFString *)objc_msgSend(NSString, "stringWithFormat:", @" to [%f %f %f %f; %f %f %f %f; %f %f %f %f; %f %f %f %f]",
                               v49,
                               *((void *)&v95 + 1),
                               v96,
                               v97,
                               v98,
                               v99,
                               v100,
                               v101,
                               v102);
          char v16 = 0;
          char v17 = 0;
          int v6 = 64;
          goto LABEL_195;
        }
        char v16 = 0;
        char v17 = 0;
        int v6 = 64;
LABEL_194:
        uint64_t v7 = &stru_1ED039300;
        goto LABEL_195;
      }
      if (a3 <= 581)
      {
        if (a3 != 568)
        {
          if (a3 == 573)
          {
LABEL_91:
            [this[2] setContentsChanged];
            goto LABEL_76;
          }
          goto LABEL_172;
        }
        CA::Layer::getter((CA::Transaction *)this, 0x238u, (const CGAffineTransform *)0x16, (id *)&v95);
        uint64_t v53 = v95;
        if (*(double *)&v95 == 1.0)
        {
          uint64_t v61 = 1;
          do
          {
            if (v61 == 16)
            {
              uint64_t v54 = (unsigned int *)(v88 + 12);
              unsigned int v55 = *((_DWORD *)v88 + 3) & 0xEFFFFFFF;
              goto LABEL_190;
            }
            uint64_t v62 = v61;
            double v63 = *((double *)&v95 + v61);
            double v64 = *(&CATransform3DIdentity.m11 + v61++);
          }
          while (v63 == v64);
          uint64_t v54 = (unsigned int *)(v88 + 12);
          unsigned int v55 = *((_DWORD *)v88 + 3) & 0xEFFFFFFF;
          if ((unint64_t)(v62 - 1) < 0xF) {
            goto LABEL_171;
          }
LABEL_190:
          int v56 = 0;
        }
        else
        {
          uint64_t v54 = (unsigned int *)(v88 + 12);
          unsigned int v55 = *((_DWORD *)v88 + 3) & 0xEFFFFFFF;
LABEL_171:
          int v56 = 0x10000000;
        }
        char v17 = 64;
        *uint64_t v54 = v55 | v56;
        if (v8)
        {
          uint64_t v7 = (__CFString *)objc_msgSend(NSString, "stringWithFormat:", @" to [%f %f %f %f; %f %f %f %f; %f %f %f %f; %f %f %f %f]",
                               v53,
                               *((void *)&v95 + 1),
                               v96,
                               v97,
                               v98,
                               v99,
                               v100,
                               v101,
                               v102);
          char v16 = 0;
          int v6 = 32;
          goto LABEL_195;
        }
        char v16 = 0;
        int v6 = 32;
        goto LABEL_194;
      }
      if (a3 == 582) {
        goto LABEL_108;
      }
      if (a3 == 602) {
        goto LABEL_76;
      }
      if (a3 != 615) {
        goto LABEL_172;
      }
      CA::Layer::getter((CA::Transaction *)this, 0x267u, (const CGAffineTransform *)0x12, (id *)&v91);
      double v21 = v91;
      *((_DWORD *)v88 + 4) = *((_DWORD *)v88 + 4) & 0xFFFFFFBF | ((v91 != 0.0) << 6);
      if (v8)
      {
        uint64_t v22 = objc_msgSend(NSString, "stringWithFormat:", @" to %f", *(void *)&v21);
LABEL_99:
        uint64_t v7 = (__CFString *)v22;
      }
    }
LABEL_100:
    char v16 = 0;
    char v17 = 0;
    int v6 = 8;
    goto LABEL_195;
  }
  if (a3 <= 118)
  {
    if (a3 > 53)
    {
      switch(a3)
      {
        case '6':
        case '7':
        case 'B':
        case 'C':
        case 'E':
          break;
        case '8':
          int v6 = 1024;
          break;
        case '9':
          goto LABEL_104;
        case ':':
        case ';':
        case '<':
        case '=':
        case '>':
        case '?':
        case '@':
        case 'A':
        case 'F':
        case 'G':
        case 'H':
        case 'I':
          goto LABEL_172;
        case 'D':
          goto LABEL_75;
        case 'J':
          char v16 = 0;
          char v17 = 96;
          goto LABEL_109;
        default:
          if (a3 != 113) {
            goto LABEL_172;
          }
          int v6 = 2048;
          break;
      }
LABEL_76:
      int v23 = *((_DWORD *)this + 1);
      if ((v23 & 0x10000) != 0)
      {
        id v24 = this[2];
        String = CAAtomGetString(a3);
        NSLog(&cfstr_ChangingProper.isa, v24, String);
      }
      char v17 = 0;
      char v16 = 0;
      if (!v8) {
        goto LABEL_206;
      }
      goto LABEL_196;
    }
    switch(a3)
    {
      case 11:
      case 13:
      case 15:
      case 16:
      case 17:
        goto LABEL_76;
      case 12:
        goto LABEL_91;
      case 14:
      case 18:
      case 19:
      case 20:
      case 21:
      case 22:
      case 23:
      case 24:
      case 25:
      case 26:
        goto LABEL_172;
      case 27:
        if (!byte_1EB2ACBEF) {
          goto LABEL_108;
        }
        [this[2] anchorPoint];
        uint64_t v20 = [NSString stringWithFormat:@" to (%f, %f)", v18, v19];
        break;
      case 28:
        CA::Layer::getter((CA::Transaction *)this, 0x1Cu, (const CGAffineTransform *)0x12, (id *)&v91);
        double v27 = v91;
        *((_DWORD *)v88 + 4) = *((_DWORD *)v88 + 4) & 0xFFFFFFDF | (32 * (v91 != 0.0));
        if (!v8) {
          goto LABEL_108;
        }
        uint64_t v20 = objc_msgSend(NSString, "stringWithFormat:", @" to %f", *(void *)&v27);
        break;
      default:
        if (a3 == 49) {
          goto LABEL_104;
        }
        goto LABEL_172;
    }
    uint64_t v7 = (__CFString *)v20;
  }
  else
  {
    if (a3 <= 190)
    {
      switch(a3)
      {
        case 119:
          goto LABEL_119;
        case 120:
        case 122:
        case 124:
        case 125:
        case 131:
        case 132:
        case 133:
        case 145:
        case 146:
        case 148:
        case 149:
        case 164:
        case 180:
        case 183:
        case 186:
          goto LABEL_76;
        case 121:
          BOOL v9 = byte_1EB2ACBEF == 0;
          CA::Layer::getter((CA::Transaction *)this, 0x79u, (const CGAffineTransform *)0x15, (id *)&v92);
          long long v10 = v92;
          long long v11 = v93;
          if (*((double *)&v93 + 1) == 1.0
            && *(double *)&v93 == 1.0
            && *((double *)&v92 + 1) == 0.0
            && *(double *)&v92 == 0.0)
          {
            int v15 = 0;
          }
          else
          {
            int v15 = 0x40000000;
          }
          *((_DWORD *)v88 + 3) = *((_DWORD *)v88 + 3) & 0xBFFFFFFF | v15;
          if (!v9) {
            uint64_t v7 = (__CFString *)[NSString stringWithFormat:@" to (%f, %f, %f, %f)", v10, v11];
          }
          int v6 = 0x20000;
          goto LABEL_76;
        case 123:
          *((_DWORD *)v88 + 4) |= 0x200u;
LABEL_119:
          int v6 = 1;
          goto LABEL_76;
        case 134:
          goto LABEL_137;
        case 135:
          BOOL v31 = byte_1EB2ACBEF == 0;
          CA::Layer::getter((CA::Transaction *)this, 0x87u, (const CGAffineTransform *)0x15, (id *)&v92);
          long long v32 = v92;
          long long v33 = v93;
          if (*((double *)&v93 + 1) == 1.0
            && *(double *)&v93 == 1.0
            && *((double *)&v92 + 1) == 0.0
            && *(double *)&v92 == 0.0)
          {
            unsigned int v37 = 0;
          }
          else
          {
            unsigned int v37 = 0x80000000;
          }
          *((_DWORD *)v88 + 3) = v37 & 0x80000000 | *((_DWORD *)v88 + 3) & 0x7FFFFFFF;
          if (!v31) {
            uint64_t v7 = (__CFString *)[NSString stringWithFormat:@" to (%f, %f, %f, %f)", v32, v33];
          }
          int v6 = 256;
          goto LABEL_76;
        case 136:
          if (byte_1EB2ACBEF)
          {
            [this[2] contentsScale];
            double v91 = *(double *)&v38;
            uint64_t v7 = (__CFString *)objc_msgSend(NSString, "stringWithFormat:", @" to %f", v38);
          }
          goto LABEL_137;
        case 137:
          long long v39 = (__CFString *)[this[2] contentsScaling];
          if (v39 != @"stretch"
            && (v39 == @"repeat"
             || [(__CFString *)v39 isEqualToString:@"repeat"]))
          {
            CA::Layer::prevent_subtextures((CFTypeID)this);
          }
          goto LABEL_76;
        case 138:
          goto LABEL_91;
        case 139:
          BOOL v40 = byte_1EB2ACBEF == 0;
          CA::Layer::getter((CA::Transaction *)this, 0x8Bu, (const CGAffineTransform *)0x17, (id *)&v94);
          CGAffineTransform v89 = v94;
          if (CGAffineTransformIsIdentity(&v89)) {
            int v41 = 0;
          }
          else {
            int v41 = 2;
          }
          *((_DWORD *)v88 + 4) = *((_DWORD *)v88 + 4) & 0xFFFFFFFD | v41;
          if (!v40) {
            uint64_t v7 = (__CFString *)objc_msgSend(NSString, "stringWithFormat:", @" to [%f %f %f %f %f %f]", *(_OWORD *)&v94.a, *(_OWORD *)&v94.c, *(_OWORD *)&v94.tx);
          }
          int v6 = 128;
          goto LABEL_76;
        case 143:
          goto LABEL_162;
        case 144:
          BOOL v42 = byte_1EB2ACBEF == 0;
          CA::Layer::getter((CA::Transaction *)this, 0x90u, (const CGAffineTransform *)0x15, (id *)&v92);
          long long v43 = v92;
          long long v44 = v93;
          if (*((double *)&v93 + 1) == 0.0
            && *(double *)&v93 == 0.0
            && *((double *)&v92 + 1) == 0.5
            && *(double *)&v92 == 0.5)
          {
            int v48 = 0;
          }
          else
          {
            int v48 = 4;
          }
          *((_DWORD *)v88 + 4) = *((_DWORD *)v88 + 4) & 0xFFFFFFFB | v48;
          if (!v42) {
            uint64_t v7 = (__CFString *)[NSString stringWithFormat:@" to (%f, %f, %f, %f)", v43, v44];
          }
LABEL_162:
          int v6 = 0x80000;
          break;
        case 147:
          *((_DWORD *)v88 + 4) |= 0x1000000u;
          goto LABEL_76;
        case 165:
          int v6 = 0;
          *((_DWORD *)v88 + 3) |= 0x1000000u;
          goto LABEL_173;
        default:
          goto LABEL_172;
      }
      goto LABEL_76;
    }
    if (a3 <= 227)
    {
      if (a3 > 222)
      {
        if (a3 != 223)
        {
          if (a3 == 226)
          {
            int v6 = 512;
            goto LABEL_76;
          }
          goto LABEL_172;
        }
      }
      else if (a3 != 191)
      {
        if (a3 == 194) {
          goto LABEL_76;
        }
LABEL_172:
        int v6 = 0;
LABEL_173:
        char v17 = 0;
        char v16 = 1;
        goto LABEL_195;
      }
LABEL_104:
      *((_DWORD *)v88 + 4) |= 0x80u;
      CAMediaTimingInvalidate((uint64_t)this[2]);
      char v16 = 0;
      char v17 = 0;
      int v6 = 4096;
      goto LABEL_195;
    }
    if (a3 > 245)
    {
      if (a3 == 246) {
        goto LABEL_76;
      }
      if (a3 != 248) {
        goto LABEL_172;
      }
    }
    else if (a3 != 228)
    {
      if (a3 == 244)
      {
        int v6 = 0x400000;
        goto LABEL_76;
      }
      goto LABEL_172;
    }
  }
LABEL_108:
  char v16 = 0;
  char v17 = 0;
LABEL_109:
  int v6 = 16;
LABEL_195:
  int v23 = *((_DWORD *)this + 1);
  if (v8)
  {
LABEL_196:
    if (x_log_hook_p())
    {
      if (v16) {
        float v65 = "NOT";
      }
      else {
        float v65 = (const char *)[(__CFString *)CAAtomGetString(a3) UTF8String];
      }
      __int16 v86 = v65;
      uint64_t v87 = [(__CFString *)v7 UTF8String];
      double v85 = a2;
      x_log_();
    }
    else
    {
      float v66 = x_log_category_api;
      if (os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_DEFAULT))
      {
        if (v16) {
          BOOL v67 = "NOT";
        }
        else {
          BOOL v67 = (const char *)[(__CFString *)CAAtomGetString(a3) UTF8String];
        }
        uint64_t v68 = [(__CFString *)v7 UTF8String];
        *(_DWORD *)buf = 134218498;
        *(void *)&uint8_t buf[4] = a2;
        __int16 v104 = 2080;
        uint64_t v105 = v67;
        __int16 v106 = 2080;
        uint64_t v107 = v68;
        _os_log_impl(&dword_184668000, v66, OS_LOG_TYPE_DEFAULT, "Transaction (%p) property %s changed %s", buf, 0x20u);
      }
    }
  }
LABEL_206:
  if ((v23 & 0x60000) != 0) {
    return;
  }
  if (v16)
  {
    uint64_t v69 = *((unsigned int *)a2 + 24);
    if ((v69 & 0x80000000) != 0 || !*((_DWORD *)this + v69 + 68)) {
      CA::Layer::thread_flags_((CA::Layer *)this, a2);
    }
  }
  else
  {
    if (v6) {
      int v70 = 1032;
    }
    else {
      int v70 = 8;
    }
    *((_DWORD *)this + 10) |= v6 & 0x7FFFFE;
    CA::Layer::mark((CA::Layer *)this, a2, v70, 16);
  }
  if ((v6 & 2) != 0)
  {
    uint64_t v71 = *(void *)(*((void *)a2 + 13) + 216);
    if (v71)
    {
      uint64_t v72 = x_hash_table_lookup(v71, (uint64_t)this, 0);
      if (v72)
      {
        uint64_t v73 = *(void *)(v72 + 16);
        float v74 = *(const void **)(v73 + 24);
        if (v74)
        {
          CA::Transaction::release_object(a2, v74);
          *(void *)(v73 + 24) = 0;
        }
      }
    }
  }
  if ((v17 & 0x40) != 0)
  {
    float v75 = (CA::Layer *)CA::Layer::retain_parent((CA::Layer *)this, a2);
    *(void *)buf = v75;
    if (v75)
    {
      __int16 v76 = v75;
      if (!CA::Layer::layout_is_active(v75, a2, 1))
      {
        uint64_t v77 = (void *)*((void *)v76 + 2);
        if ([v77 needsLayoutOnGeometryChange]) {
          [v77 setNeedsLayout];
        }
      }
      while (1)
      {
        atomic_uint v78 = *(_DWORD *)v76;
        if (!*(_DWORD *)v76) {
          break;
        }
        atomic_uint v79 = *(_DWORD *)v76;
        atomic_compare_exchange_strong((atomic_uint *volatile)v76, (unsigned int *)&v79, v78 - 1);
        if (v79 == v78)
        {
          if (v78 == 1)
          {
            CA::Layer::destroy(v76);
            CA::Layer::~Layer((CA::AttrList **)v76);
            malloc_zone = (malloc_zone_t *)get_malloc_zone();
            malloc_zone_free(malloc_zone, v76);
          }
          break;
        }
      }
    }
  }
  if (v88[17] & 8) != 0 && (uint64_t v81 = (objc_class *)objc_opt_class(), (CAObject_needsLayoutForKey(v81, a3)) {
    || (v17 & 0x20) != 0 && [this[2] needsLayoutOnGeometryChange])
  }
  {
    if ((CA::Layer::layout_is_active((CA::Layer *)this, a2, 1) & 1) == 0) {
      [this[2] setNeedsLayout];
    }
  }
  if ((v88[17] & 4) != 0)
  {
    double v82 = (objc_class *)objc_opt_class();
    if (CAObject_needsDisplayForKey(v82, a3)) {
      goto LABEL_245;
    }
  }
  if (a3 == 74)
  {
    if (![this[2] needsDisplayOnBoundsChange]) {
      return;
    }
    goto LABEL_245;
  }
  if (a3 == 126)
  {
    float64_t v83 = (const void *)*((void *)v88 + 13);
    if (v83)
    {
      CFTypeID v84 = CFGetTypeID(v83);
      if (CABackingStoreGetTypeID::once[0] != -1) {
        dispatch_once(CABackingStoreGetTypeID::once, &__block_literal_global_907);
      }
      if (v84 == CABackingStoreGetTypeID::type) {
LABEL_245:
      }
        objc_msgSend(this[2], "setNeedsDisplay", v85, v86, v87);
    }
  }
}

void sub_1846838E0(_Unwind_Exception *a1)
{
  X::Ref<CA::Layer>::~Ref((atomic_uint **)(v1 - 144));
  _Unwind_Resume(a1);
}

char *CA::Layer::writable_state(CA::Layer *this, CA::Transaction *a2)
{
  int v3 = *((_DWORD *)this + 1);
  if ((v3 & 0x100000) != 0) {
    return (char *)this + 40;
  }
  if (*((void *)this + 32)) {
    CA::Transaction::release_object(a2, *((CFTypeRef *)this + 32));
  }
  CFTypeRef v4 = (CFTypeRef)*((void *)this + 18);
  if (v4) {
    CFTypeRef v4 = CFRetain(v4);
  }
  *((void *)this + 32) = v4;
  size_t v5 = (CA::AttrList *)*((void *)this + 23);
  if (v5) {
    CA::AttrList::free(v5, a2);
  }
  int v6 = (CA::AttrList *)*((void *)this + 9);
  if (v6)
  {
    uint64_t v7 = *((void *)v6 + 1) & 7;
    if (v7 == 7) {
      int v6 = (CA::AttrList *)CA::AttrList::copy_(v6);
    }
    else {
      *((void *)v6 + 1) = *((void *)v6 + 1) & 0xFFFFFFFFFFFFFFF8 | (v7 + 1);
    }
  }
  int v8 = (char *)this + 40;
  *((void *)this + 23) = v6;
  if (*((unsigned char *)this + 55))
  {
    BOOL v9 = (id *)((char *)this + 128);
    if (*((unsigned char *)this + 136))
    {
      id Weak = objc_loadWeak(v9);
      BOOL v11 = *((unsigned char *)this + 136) != 0;
    }
    else
    {
      BOOL v11 = 0;
      id Weak = *v9;
    }
    X::WeakDetails::Ptr::set((id *)this + 30, Weak, v11);
    *((_DWORD *)this + 13) &= ~0x1000000u;
  }
  for (uint64_t i = 0; i != 24; i += 4)
    *(_DWORD *)((char *)this + i + 156) = *(_DWORD *)((char *)this + i + 44);
  *((_DWORD *)this + 38) = *((_DWORD *)this + 10);
  long long v13 = *((_OWORD *)this + 6);
  *((_OWORD *)this + 12) = *((_OWORD *)this + 5);
  *((_OWORD *)this + 13) = v13;
  *((_OWORD *)this + 14) = *((_OWORD *)this + 7);
  *((_DWORD *)this + 1) = v3 | 0x100000;
  return v8;
}

void CA::Layer::mark(CA::Layer *this, CA::Transaction *a2, int a3, int a4)
{
  uint64_t v8 = *((unsigned int *)a2 + 24);
  if ((v8 & 0x80000000) != 0 || (BOOL v9 = (char *)this + 4 * v8, (v10 = *((_DWORD *)v9 + 68)) == 0))
  {
    BOOL v11 = CA::Layer::thread_flags_(this, a2);
    int v10 = *v11;
  }
  else
  {
    BOOL v11 = (int *)(v9 + 272);
  }
  if ((a3 & ~v10) != 0)
  {
    *BOOL v11 = v10 | a3;
    while (1)
    {
      int v12 = *(_DWORD *)this;
      if (!*(_DWORD *)this) {
        break;
      }
      int v13 = *(_DWORD *)this;
      atomic_compare_exchange_strong((atomic_uint *volatile)this, (unsigned int *)&v13, v12 + 1);
      if (v13 == v12)
      {
        int v14 = this;
        goto LABEL_11;
      }
    }
    int v14 = 0;
LABEL_11:
    long long v44 = (atomic_uint *)v14;
    int v15 = CA::Layer::retain_parent(this, a2);
    long long v43 = (CA::Layer *)v15;
    if (v15)
    {
      _X22 = (CA::Layer *)v15;
      while (1)
      {
        __asm { PRFM            #0, [X22,#0x110] }
        uint64_t v22 = *((unsigned int *)a2 + 24);
        if ((v22 & 0x80000000) != 0 || (int v23 = (char *)_X22 + 4 * v22, (v24 = *((_DWORD *)v23 + 68)) == 0))
        {
          BOOL v25 = CA::Layer::thread_flags_(_X22, a2);
          int v24 = *v25;
        }
        else
        {
          BOOL v25 = (int *)(v23 + 272);
        }
        if ((a4 & ~v24) == 0) {
          break;
        }
        *BOOL v25 = v24 | a4;
        if (v44 == (atomic_uint *)_X22)
        {
          long long v43 = (CA::Layer *)CA::Layer::retain_parent(_X22, a2);
          goto LABEL_33;
        }
        if (v44)
        {
          while (1)
          {
            atomic_uint v26 = *v44;
            if (!*v44) {
              break;
            }
            atomic_uint v27 = *v44;
            atomic_compare_exchange_strong(v44, (unsigned int *)&v27, v26 - 1);
            if (v27 == v26)
            {
              if (v26 == 1)
              {
                CA::Layer::destroy((CA::Layer *)v44);
                CA::Layer::~Layer((CA::AttrList **)v44);
                malloc_zone = (malloc_zone_t *)get_malloc_zone();
                malloc_zone_free(malloc_zone, v44);
              }
              break;
            }
          }
          _X22 = v43;
          if (v43) {
            goto LABEL_25;
          }
          BOOL v31 = 0;
        }
        else
        {
LABEL_25:
          while (1)
          {
            int v29 = *(_DWORD *)_X22;
            if (!*(_DWORD *)_X22) {
              break;
            }
            int v30 = *(_DWORD *)_X22;
            atomic_compare_exchange_strong((atomic_uint *volatile)_X22, (unsigned int *)&v30, v29 + 1);
            if (v30 == v29) {
              goto LABEL_30;
            }
          }
          _X22 = 0;
LABEL_30:
          BOOL v31 = _X22;
          _X22 = v43;
        }
        long long v44 = (atomic_uint *)v31;
        long long v32 = CA::Layer::retain_parent(_X22, a2);
        long long v43 = (CA::Layer *)v32;
        if (_X22)
        {
LABEL_33:
          while (1)
          {
            int v33 = *(_DWORD *)_X22;
            if (!*(_DWORD *)_X22) {
              break;
            }
            int v34 = *(_DWORD *)_X22;
            atomic_compare_exchange_strong((atomic_uint *volatile)_X22, (unsigned int *)&v34, v33 - 1);
            if (v34 == v33)
            {
              if (v33 == 1)
              {
                CA::Layer::destroy(_X22);
                CA::Layer::~Layer((CA::AttrList **)_X22);
                long long v35 = (malloc_zone_t *)get_malloc_zone();
                malloc_zone_free(v35, _X22);
              }
              break;
            }
          }
          _X22 = v43;
          if (!v43) {
            goto LABEL_40;
          }
        }
        else
        {
          _X22 = (CA::Layer *)v32;
          if (!v32) {
            goto LABEL_40;
          }
        }
      }
      while (1)
      {
        int v38 = *(_DWORD *)_X22;
        if (!*(_DWORD *)_X22) {
          break;
        }
        int v37 = *(_DWORD *)_X22;
        atomic_compare_exchange_strong((atomic_uint *volatile)_X22, (unsigned int *)&v37, v38 - 1);
        if (v37 == v38)
        {
          if (v38 == 1)
          {
            CA::Layer::destroy(_X22);
            CA::Layer::~Layer((CA::AttrList **)_X22);
            long long v39 = (malloc_zone_t *)get_malloc_zone();
            malloc_zone_free(v39, _X22);
          }
          break;
        }
      }
    }
    else
    {
LABEL_40:
      if ((a3 & 8) != 0)
      {
        long long v36 = v44;
        if (!v44[67]) {
          goto LABEL_49;
        }
        CA::Transaction::add_root(a2, v44);
      }
    }
    long long v36 = v44;
    if (v44)
    {
LABEL_49:
      while (1)
      {
        atomic_uint v40 = *v36;
        if (!*v36) {
          break;
        }
        atomic_uint v41 = *v36;
        atomic_compare_exchange_strong(v36, (unsigned int *)&v41, v40 - 1);
        if (v41 == v40)
        {
          if (v40 == 1)
          {
            CA::Layer::destroy((CA::Layer *)v36);
            CA::Layer::~Layer((CA::AttrList **)v36);
            BOOL v42 = (malloc_zone_t *)get_malloc_zone();
            malloc_zone_free(v42, v36);
          }
          return;
        }
      }
    }
  }
}

void sub_184683D18(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  int v3 = va_arg(va1, atomic_uint *);
  X::Ref<CA::Layer>::~Ref((atomic_uint **)va);
  X::Ref<CA::Layer>::~Ref((atomic_uint **)va1);
  _Unwind_Resume(a1);
}

void sub_184683F68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, atomic_uint *a9)
{
  X::Ref<CA::Layer>::~Ref(&a9);
  CA::Transaction::unlock(v9);
  _Unwind_Resume(a1);
}

uint64_t CA::Layer::invalidate_layout(uint64_t this)
{
  uint64_t v1 = *(uint64_t ***)(this + 72);
  if (v1)
  {
    while (1)
    {
      uint64_t v1 = (uint64_t **)*v1;
      if (!v1) {
        break;
      }
      if ((v1[1] & 0xFFFFFF) == 0x202) {
        return objc_msgSend(*(id *)(this + 16), "setSizeRequisition:", *MEMORY[0x1E4F1DB30], *(double *)(MEMORY[0x1E4F1DB30] + 8));
      }
    }
  }
  return this;
}

uint64_t CA::Layer::layout_is_active(CA::Layer *this, CA::Transaction *a2, int a3)
{
  uint64_t v6 = *((unsigned int *)a2 + 24);
  if ((v6 & 0x80000000) != 0 || (uint64_t v7 = (char *)this + 4 * v6, !*((_DWORD *)v7 + 68)))
  {
    uint64_t v8 = CA::Layer::thread_flags_(this, a2);
    if (!a3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v8 = v7 + 272;
    if (!a3) {
      goto LABEL_7;
    }
  }
  if ((*(unsigned char *)v8 & 0x20) != 0) {
    return 1;
  }
LABEL_7:
  uint64_t v9 = *((void *)a2 + 9);
  if (v9)
  {
    if (*(unsigned char *)(v9 + 32))
    {
      if ((*(unsigned char *)v8 & 0x80) != 0) {
        return 1;
      }
    }
    else
    {
      while (1)
      {
        BOOL v11 = *(atomic_uint ***)(v9 + 16);
        if (v11) {
          break;
        }
LABEL_16:
        uint64_t result = 0;
        uint64_t v9 = *(void *)(v9 + 8);
        if (!v9) {
          return result;
        }
      }
      int v12 = *(atomic_uint **)(v9 + 24);
      while (*v11 != (atomic_uint *)this)
      {
        if (*v11 != v12)
        {
          BOOL v11 = (atomic_uint **)v11[1];
          if (v11) {
            continue;
          }
        }
        goto LABEL_16;
      }
      while (1)
      {
        atomic_uint v13 = *v12;
        if (!*v12) {
          break;
        }
        atomic_uint v14 = *v12;
        atomic_compare_exchange_strong(v12, (unsigned int *)&v14, v13 + 1);
        if (v14 == v13)
        {
          while (v12 != (atomic_uint *)this)
          {
            double v21 = CA::Layer::retain_parent((CA::Layer *)v12, a2);
            while (1)
            {
              atomic_uint v15 = *v12;
              if (!*v12) {
                break;
              }
              atomic_uint v16 = *v12;
              atomic_compare_exchange_strong(v12, (unsigned int *)&v16, v15 - 1);
              if (v16 == v15)
              {
                if (v15 == 1)
                {
                  CA::Layer::destroy((CA::Layer *)v12);
                  CA::Layer::~Layer((CA::AttrList **)v12);
                  malloc_zone = (malloc_zone_t *)get_malloc_zone();
                  malloc_zone_free(malloc_zone, v12);
                }
                break;
              }
            }
            int v12 = v21;
            if (!v21) {
              return 0;
            }
          }
          while (1)
          {
            int v19 = *(_DWORD *)this;
            if (!*(_DWORD *)this) {
              break;
            }
            int v18 = *(_DWORD *)this;
            atomic_compare_exchange_strong((atomic_uint *volatile)this, (unsigned int *)&v18, v19 - 1);
            if (v18 == v19)
            {
              if (v19 == 1)
              {
                CA::Layer::destroy(this);
                CA::Layer::~Layer((CA::AttrList **)this);
                uint64_t v20 = (malloc_zone_t *)get_malloc_zone();
                malloc_zone_free(v20, this);
              }
              return 1;
            }
          }
          return 1;
        }
      }
    }
  }
  return 0;
}

void sub_18468419C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, atomic_uint *a9)
{
}

uint64_t CA::Render::Context::context_by_server_port(CA::Render::Context *this)
{
  if (!this) {
    return 0;
  }
  unsigned int v1 = this;
  os_unfair_lock_lock(&CA::Render::Context::_context_lock);
  if (!CA::Render::Context::_port_table)
  {
    os_unfair_lock_unlock(&CA::Render::Context::_context_lock);
    return 0;
  }
  uint64_t v2 = x_hash_table_lookup(CA::Render::Context::_port_table, v1, 0);
  os_unfair_lock_unlock(&CA::Render::Context::_context_lock);
  if (!v2) {
    return v2;
  }
  if ((*(unsigned char *)(v2 + 13) & 4) != 0) {
    return 0;
  }
  int v3 = (atomic_uint *)(v2 + 8);
  if (!atomic_fetch_add((atomic_uint *volatile)(v2 + 8), 1u))
  {
    uint64_t v2 = 0;
    atomic_fetch_add(v3, 0xFFFFFFFF);
  }
  return v2;
}

uint64_t x_hash_table_lookup(uint64_t a1, uint64_t a2, void *a3)
{
  if (*(void *)(a1 + 24))
  {
    uint64_t v6 = (*(uint64_t (**)(uint64_t))(a1 + 32))(a2);
    uint64_t v7 = *(void **)(*(void *)(a1 + 16) + 8 * (*(void *)(a1 + 8) & v6));
    if ((*(unsigned char *)(a1 + 80) & 2) != 0)
    {
      if (v7)
      {
        while (v7[2] != a2)
        {
          uint64_t v7 = (void *)*v7;
          if (!v7) {
            goto LABEL_12;
          }
        }
        if (a3) {
          *a3 = a2;
        }
        return v7[3];
      }
    }
    else if (v7)
    {
      uint64_t v8 = v6;
      while (v7[1] != v8 || (*(unsigned int (**)(void, uint64_t))(a1 + 40))(v7[2], a2))
      {
        uint64_t v7 = (void *)*v7;
        if (!v7) {
          goto LABEL_12;
        }
      }
      if (a3) {
        *a3 = v7[2];
      }
      return v7[3];
    }
  }
LABEL_12:
  uint64_t result = 0;
  if (a3) {
    *a3 = 0;
  }
  return result;
}

unint64_t x_pointer_hash(uint64_t a1)
{
  unint64_t v1 = (~(a1 << 32) + a1) ^ ((unint64_t)(~(a1 << 32) + a1) >> 22);
  unint64_t v2 = 9 * ((v1 + ~(v1 << 13)) ^ ((v1 + ~(v1 << 13)) >> 8));
  unint64_t v3 = (v2 ^ (v2 >> 15)) + ~((v2 ^ (v2 >> 15)) << 27);
  return v3 ^ (v3 >> 31);
}

void CA::Transaction::release_object(CA::Transaction *this, CFTypeRef cf)
{
  if (*((_DWORD *)this + 25))
  {
    uint64_t v4 = *((void *)this + 4);
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    uint64_t v6 = malloc_type_zone_malloc(malloc_zone, 0x10uLL, 0x8BB15036uLL);
    void *v6 = cf;
    v6[1] = v4;
    *((void *)this + 4) = v6;
  }
  else
  {
    CFRelease(cf);
  }
}

unint64_t hash_cf(const void *a1)
{
  CFHashCode v1 = CFHash(a1);
  CFHashCode v2 = (v1 + ~(v1 << 32)) ^ ((v1 + ~(v1 << 32)) >> 22);
  unint64_t v3 = 9 * ((v2 + ~(v2 << 13)) ^ ((v2 + ~(v2 << 13)) >> 8));
  unint64_t v4 = (v3 ^ (v3 >> 15)) + ~((v3 ^ (v3 >> 15)) << 27);
  return v4 ^ (v4 >> 31);
}

void CA::Transaction::cf_release(CFTypeRef cf, const void *a2)
{
  unint64_t v3 = *(CA::Transaction **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 576);
  if (v3) {
    CA::Transaction::release_object(v3, cf);
  }
  else {
    CFRelease(cf);
  }
}

BOOL compare_cf(const void *a1, const void *a2)
{
  return a1 != a2 && CFEqual(a1, a2) == 0;
}

void sub_1846846B4(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t CA::AttrList::splice_shared_node(uint64_t result, _DWORD *a2)
{
  int v2 = a2[2];
  if (v2 < 0)
  {
    a2[2] = v2 & 0x7FFFFFFF;
    if (*(void *)a2)
    {
      *(_DWORD *)(*(void *)a2 + 8) |= 0x80000000;
    }
    else
    {
      uint64_t v4 = *(void *)(result + 8);
      *(void *)(result + 8) = v4 & 7;
      *(void *)((v4 & 0xFFFFFFFFFFFFFFF8) + 8) &= 7uLL;
    }
  }
  else
  {
    unint64_t v3 = (void *)(*(void *)(result + 8) & 0xFFFFFFFFFFFFFFF8);
    *(void *)a2 = *v3;
    *unint64_t v3 = a2;
  }
  return result;
}

void sub_184684914(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_184684B50(_Unwind_Exception *a1)
{
}

uint64_t CABackingStoreInvalidate(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  if (a2)
  {
    if (!*(void *)(a1 + 440)) {
      *(void *)(a1 + 440) = CGSBoundingShapeCreate();
    }
    CGSBoundingShapeAddRect();
    __int16 v5 = *(_WORD *)(a1 + 492) & 0xFDFF;
  }
  else
  {
    __int16 v5 = *(_WORD *)(a1 + 492) & 0xF9FF | 0x400;
  }
  *(_WORD *)(a1 + 492) = v5;

  return pthread_mutex_unlock(v4);
}

uint64_t CABackingStoreSetVolatile(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  __int16 v5 = *(_WORD *)(a1 + 492);
  if ((((v5 & 0x100) == 0) ^ a2)) {
    goto LABEL_11;
  }
  if (a2) {
    __int16 v6 = 256;
  }
  else {
    __int16 v6 = 0;
  }
  __int16 v7 = v5 & 0xFEFF | v6;
  *(_WORD *)(a1 + 492) = v7;
  if (a2)
  {
    for (uint64_t i = 0; i != 216; i += 72)
      *(void *)(a1 + 232 + i) = 0;
    *(void *)(a1 + 472) = 0;
    __int16 v9 = v7 & 0xFF00 | 6;
    goto LABEL_9;
  }
  uint64_t v10 = *(void *)(a1 + 400);
  if (*(unsigned char *)(v10 + 65))
  {
LABEL_11:
    a2 = 1;
    goto LABEL_12;
  }
  int v12 = *(CA::Render::Shmem **)(v10 + 16);
  if (v12)
  {
    if (CA::Render::Shmem::set_volatile(v12, 0, 0)) {
      goto LABEL_11;
    }
  }
  else
  {
    atomic_uint v13 = *(os_unfair_lock_s **)(v10 + 24);
    if (!v13)
    {
      a2 = 0;
      goto LABEL_12;
    }
    if (CA::CG::AccelDrawable::set_volatile(v13, 0)) {
      goto LABEL_11;
    }
  }
  CABackingStoreReleaseImages((CABackingStore *)a1);
  CABackingStoreDeleteBuffer((void *)v10);
  __int16 v9 = *(_WORD *)(a1 + 492) & 0xF9FF | 0x400;
LABEL_9:
  *(_WORD *)(a1 + 492) = v9;
LABEL_12:
  pthread_mutex_unlock(v4);
  return a2;
}

CFTypeID CA::Layer::prevent_subtextures(CFTypeID this)
{
  if ((*(unsigned char *)(this + 54) & 0x40) == 0)
  {
    CFTypeID v1 = this;
    this = [*(id *)(this + 16) contents];
    if (this)
    {
      CFTypeID v2 = CFGetTypeID((CFTypeRef)this);
      this = CGImageGetTypeID();
      if (v2 == this)
      {
        unint64_t v3 = *(void **)(v1 + 16);
        return [v3 setContentsChanged];
      }
    }
  }
  return this;
}

uint64_t CA::Render::GradientLayer::visit_subclass(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 8))(a2, a1);
}

uint64_t CA::Render::ImageQueue::is_protected(CA::Render::ImageQueue *this)
{
  char v1 = atomic_load((unint64_t *)(*(void *)(*((void *)this + 2) + 24) + 8));
  if ((v1 & 4) != 0) {
    return 1;
  }
  uint64_t v2 = *((void *)this + 8);
  if (v2) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 232))(v2);
  }
  uint64_t v2 = *((void *)this + 10);
  if (v2) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 232))(v2);
  }
  uint64_t v2 = *((void *)this + 3);
  if (v2) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 232))(v2);
  }
  else {
    return 0;
  }
}

void CA::OGL::MetalContext::draw_lines(CA::OGL::Context *a1, int a2, unsigned int a3, char *a4)
{
  if (*(unsigned __int8 *)(*((void *)a1 + 2) + 16) - 83 <= 9) {
    __assert_rtn("draw_lines", "ogl-metal.mm", 8268, "get_texture_function() < OGL_TEX_PATH_FIRST || get_texture_function() > OGL_TEX_PATH_LAST");
  }
  CA::OGL::MetalContext::draw(a1, 1, a3, 1u, a4, 0x10uLL, 8u, a2, a3, 0, 0, 0);
}

uint64_t CA::OGL::Context::unbind_surface(void *a1, uint64_t a2, uint64_t a3)
{
  (*(void (**)(void *, uint64_t, void, uint64_t))(*a1 + 784))(a1, a2, 0, a3);
  uint64_t result = (*(uint64_t (**)(void *, void, uint64_t))(*a1 + 520))(a1, 0, a3);
  if ((*(_WORD *)(a2 + 75) & 0x200) != 0) {
    *(unsigned char *)(a1[2] + 481) &= ~2u;
  }
  return result;
}

int8x8_t CA::OGL::Context::unbind_image(CA::OGL::Context *this, uint64_t *a2, uint64_t a3)
{
  unsigned int v3 = a3;
  if (a2 && (uint64_t v6 = a2[3]) != 0)
  {
    CA::OGL::Context::unbind_surface(this, v6, a3);
    CA::OGL::Context::release_surface((uint64_t)this, a2[3]);
    a2[3] = 0;
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(malloc_zone, a2);
  }
  else
  {
    CA::OGL::Context::color_program((uint64_t *)this, a3, 0);
    uint64_t v9 = *((void *)this + 2);
    unsigned int v10 = CA::OGL::state_image_texture_unit(v9, v3);
    uint64_t v12 = CA::OGL::image_plane_count[*(unsigned __int8 *)(v9 + 17 + v3)];
    if (CA::OGL::image_plane_count[*(unsigned __int8 *)(v9 + 17 + v3)])
    {
      do
      {
        *(_WORD *)(v9 + 2 * v10 + 144) = 0;
        *(void *)(v9 + 8 * v10++ + 176) = 0;
        --v12;
      }
      while (v12);
    }
    *(unsigned char *)(v9 + 17 + v3) = 0;
    *(unsigned char *)(*((void *)this + 2) + v3 + 19) = 0;
    uint64_t v13 = *((void *)this + 2);
    v11.i32[0] = *(_DWORD *)(v13 + 304);
    int16x8_t v14 = (int16x8_t)vmovl_u8(v11);
    *(int8x8_t *)v14.i8 = vand_s8(*(int8x8_t *)v14.i8, (int8x8_t)vdup_n_s16(~(1 << v3)));
    int8x8_t result = vmovn_s16(v14);
    *(_DWORD *)(v13 + 304) = result.i32[0];
    *(unsigned char *)(v13 + 308) &= ~(1 << v3);
  }
  return result;
}

uint64_t *CA::OGL::Context::color_program(uint64_t *this, unsigned int a2, const CA::ColorProgram::Program *a3)
{
  __int16 v5 = this;
  uint64_t v6 = this[2];
  uint64_t v7 = v6 + 8 * a2;
  uint64_t v10 = *(void *)(v7 + 40);
  uint64_t v8 = (void *)(v7 + 40);
  uint64_t v9 = v10;
  if (v10)
  {
    this = (uint64_t *)CA::OGL::state_image_texture_unit(this[2], a2 + 1);
    uint64_t v11 = *(void *)(v9 + 80);
    BOOL v12 = v11 == 0;
    uint64_t v13 = v11 != 0;
    if (v11) {
      int v14 = -1;
    }
    else {
      int v14 = 0;
    }
    int v15 = *(_DWORD *)(v9 + 56);
    if (v12) {
      int v16 = -1;
    }
    else {
      int v16 = -2;
    }
    uint64_t v17 = 1;
    if (!v12) {
      uint64_t v17 = 2;
    }
    if (v15) {
      int v14 = v16;
    }
    unsigned int v18 = v14 + this;
    if (v15) {
      uint64_t v13 = v17;
    }
    for (; v13; ++v18)
    {
      *(_WORD *)(v6 + 2 * v18 + 144) = 0;
      *(void *)(v6 + 8 * v18 + 176) = 0;
      --v13;
    }
  }
  *uint64_t v8 = a3;
  if (a3)
  {
    uint64_t v19 = a2;
    this = (uint64_t *)CA::OGL::state_image_texture_unit(v5[2], a2 + 1);
    uint64_t v20 = *((void *)a3 + 10);
    if (v20) {
      char v21 = -1;
    }
    else {
      char v21 = 0;
    }
    if (v20) {
      char v22 = -2;
    }
    else {
      char v22 = -1;
    }
    if (*((_DWORD *)a3 + 14)) {
      char v21 = v22;
    }
    char v23 = v21 + (_BYTE)this;
    if (*((void *)a3 + 8))
    {
      *(unsigned char *)(v6 + a2 + 56) = v23;
      char v24 = v23 + 1;
      this = (uint64_t *)(*(uint64_t (**)(uint64_t *))(*v5 + 536))(v5);
      uint64_t v20 = *((void *)a3 + 10);
      char v23 = v24;
    }
    if (v20)
    {
      *(unsigned char *)(v6 + v19 + 58) = v23;
      BOOL v25 = *(uint64_t (**)(uint64_t *))(*v5 + 528);
      return (uint64_t *)v25(v5);
    }
  }
  return this;
}

void CA::OGL::MetalContext::draw_elements(CA::OGL::Context *a1, int a2, unsigned int a3, unsigned __int16 *a4, char *a5, int a6, int a7, void *a8)
{
  if (!a2) {
    __assert_rtn("draw_elements", "ogl-metal.mm", 8242, "mode != OGL_PRIMITIVE_QUADS");
  }
  if (*(unsigned __int8 *)(*((void *)a1 + 2) + 16) - 83 <= 9) {
    __assert_rtn("draw_elements", "ogl-metal.mm", 8244, "get_texture_function() < OGL_TEX_PATH_FIRST || get_texture_function() > OGL_TEX_PATH_LAST");
  }
  if (a2 == 1) {
    uint64_t v8 = 3;
  }
  else {
    uint64_t v8 = 4;
  }
  if (a4) {
    CA::OGL::MetalContext::draw(a1, v8, a3, 1u, a5, 0x30uLL, 0x10u, a6, a7 - a6, a4, a8, 0);
  }
  else {
    CA::OGL::MetalContext::draw(a1, v8, a3, 1u, a5, 0x30uLL, 0x10u, 0, a3, 0, a8, 0);
  }
}

void CA::OGL::MetalContext::draw(CA::OGL::Context *this, uint64_t a2, unsigned int a3, unsigned int a4, char *a5, size_t a6, unsigned int a7, int a8, int a9, unsigned __int16 *a10, void *a11, uint64_t a12)
{
  uint64_t v505 = *MEMORY[0x1E4F143B8];
  uint64_t v12 = *((void *)this + 33);
  if (!v12) {
    __assert_rtn("draw", "ogl-metal.mm", 8140, "current_metal_surface () != nullptr");
  }
  uint64_t v19 = this;
  if (*((void *)this + 34) != v12 || *((_DWORD *)this + 65) != ((*(unsigned __int8 *)(v12 + 72) >> 1) & 0x1F)) {
    CA::OGL::Context::prepare_destination_(this);
  }
  if ((*((_WORD *)v19 + 416) & 0x200) != 0) {
    CA::OGL::Context::flatten_detached_layers_((uint64_t)v19);
  }
  if (!CA::OGL::MetalContext::start_render_encoder(v19)) {
    return;
  }
  uint64_t v20 = *((void *)v19 + 33);
  if ((*(unsigned char *)(v20 + 69) & 8) != 0 && (*(_WORD *)(v20 + 75) & 0x20) != 0)
  {
    CA::OGL::MetalContext::clear_memoryless_texture_((uint64_t)v19, v20);
    uint64_t v20 = *((void *)v19 + 33);
  }
  *(_OWORD *)v493 = 0u;
  long long v494 = 0u;
  if (*(void *)(v20 + 200)) {
    uint64_t v21 = *(void *)(v20 + 200);
  }
  else {
    uint64_t v21 = v20;
  }
  char v22 = (unsigned __int8 *)*((void *)v19 + 2);
  uint64_t v23 = v22[16];
  char v24 = &CA::OGL::MetalContext::texture_function_info[-v23];
  int v25 = CA::OGL::MetalContext::texture_function_info[8 * v23 - v23] & 0x3F;
  if (a2) {
    int v26 = a2 == 1;
  }
  else {
    int v26 = 2;
  }
  _ZF = (CA::OGL::MetalContext::texture_function_info[8 * v23 - v23] & 0x3F) != 0 || v20 == 0;
  if (_ZF || ((v28 = *(float *)(v20 + 64), v28 != 0.0) ? (BOOL v29 = v28 == 1.0) : (BOOL v29 = 1), v29)) {
    __int16 v30 = 0;
  }
  else {
    __int16 v30 = (*((float *)v19 + 734) != 1.0) << 10;
  }
  uint64_t v31 = v23 & 0x7F;
  BYTE6(v493[1]) = v23 & 0x7F;
  if (v22[480])
  {
    char v32 = v22[480];
    if ((*(_WORD *)&v24[8 * v23 + 5] & 8) == 0)
    {
      char v32 = 58;
      if (v22[481])
      {
        if (v22[480] == 1) {
          char v32 = 58;
        }
        else {
          char v32 = v22[480];
        }
      }
    }
  }
  else
  {
    char v32 = 0;
  }
  HIBYTE(v493[1]) = v32 & 0x3F;
  char v33 = (8 * v26) & 0x9F | (32 * (*(unsigned char *)(v21 + 232) & 3));
  LOBYTE(v494) = v33;
  if (((0x40000020388001uLL >> v25) & ((v22[481] & 2) >> 1)) != 0) {
    __int16 v34 = 8;
  }
  else {
    __int16 v34 = 0;
  }
  unsigned int v35 = *((_DWORD *)v19 + 681);
  int v36 = (v35 >> 7) & 0x20;
  int v37 = (v35 >> 15) & 0x10;
  __int16 v38 = v36 | v37 | v34;
  *(_WORD *)((char *)&v494 + 1) = v38;
  int v39 = *(_DWORD *)(v21 + 120);
  int v40 = (16 * *(_DWORD *)(v21 + 68)) & 0x20000 | ((*(_WORD *)(v21 + 214) != 0) << 16);
  WORD4(v494) = v39 & 0x3FF | 0xE800;
  BYTE10(v494) = BYTE2(v40);
  v488 = v19;
  __src = a5;
  uint64_t v477 = a2;
  int v473 = a8;
  unsigned int v474 = a4;
  size_t v475 = a6;
  unsigned int v472 = a7;
  if (v25)
  {
    if (v26) {
      __assert_rtn("get_pipeline_spec", "ogl-metal.mm", 5724, "layout == VertexLayout_Surface");
    }
    if ((0xFEE1FE7FFC7FFFFuLL >> v25))
    {
      if ((*(_WORD *)&v24[8 * v23 + 5] & 0x10) == 0 && *(_WORD *)(v20 + 212)) {
        __assert_rtn("get_pipeline_spec", "ogl-metal.mm", 5732, "surf->backing_attachment == 0");
      }
    }
    else
    {
      *(_WORD *)((char *)&v494 + 1) = *(_WORD *)(v20 + 212) & 3 | v38;
    }
    if (CA::OGL::tex_image_count[v31])
    {
      unint64_t v49 = 0;
      long long v50 = v493;
      do
      {
        __int16 v51 = *((_WORD *)v50 + 2);
        int v52 = *(_DWORD *)v50 | 0xE000;
        *((unsigned char *)v50 + 6) = *((unsigned char *)v50 + 6);
        *((_WORD *)v50 + 2) = v51;
        *(_DWORD *)long long v50 = v52;
        long long v50 = (CA::OGL::MetalContext::FragmentShader::Spec **)((char *)v50 + 7);
        ++v49;
      }
      while (v49 < CA::OGL::tex_image_count[BYTE6(v493[1]) & 0x7F]);
    }
    CA::OGL::MetalContext::Pipeline::Spec::lift_blend_function((uint64_t)v493);
    if ((HIBYTE(v493[1]) & 0x3F) != 0x3A) {
      __assert_rtn("get_pipeline_spec", "ogl-metal.mm", 5741, "spec.fragment.blend_function == OGL_BLEND_NONE");
    }
    *(_DWORD *)((char *)&v494 + 3) = 0;
    int v53 = (16 * *(unsigned __int16 *)((char *)&v494 + 1)) & 0x100 | (((*(unsigned __int16 *)((char *)&v494 + 1) >> 2) & 1) << 7);
    if ((BYTE1(v494) & 4) == 0)
    {
      uint64_t v54 = BYTE6(v493[1]) & 0x7F;
      *(_WORD *)((char *)&v494 + 5) = v53 | (uint64_t)CA::OGL::MetalContext::fragment_shader_type_info[2 * (CA::OGL::MetalContext::texture_function_info[8 * v54 - v54] & 0x3F) + 1] & 0x1F | (32 * ((v494 >> 3) & 3));
      uint64_t v55 = CA::OGL::tex_image_count[v54];
      if (CA::OGL::tex_image_count[v54])
      {
        int v56 = (char *)&v494 + 3;
        uint64_t v57 = v493;
        do
        {
          int v58 = *(_DWORD *)v57;
          uint64_t v57 = (CA::OGL::MetalContext::FragmentShader::Spec **)((char *)v57 + 7);
          *int v56 = *v56 & 0xFC | byte_18499EBD8[v58 & 0x3F] & 3;
          ++v56;
          --v55;
        }
        while (v55);
      }
      goto LABEL_99;
    }
LABEL_98:
    *(_WORD *)((char *)&v494 + 5) = v53;
    uint64_t v19 = v488;
    goto LABEL_99;
  }
  LOBYTE(v494) = (*((unsigned __int16 *)v19 + 416) >> 12) & 7 | v33;
  uint64_t v41 = *(void *)(v20 + 120);
  __int16 v42 = (unint64_t)(v41 - 550) < 6;
  if (v41 == 125 || v41 == 115) {
    __int16 v44 = 128;
  }
  else {
    __int16 v44 = 0;
  }
  __int16 v45 = v44 | (v42 << 6) | *(_WORD *)(v20 + 212) & 3 | v38;
  __int16 v46 = (v22[307] != 0) << 8;
  __int16 v47 = v30 | ((v22[305] != 0) << 9);
  if (v37)
  {
    if (CADeviceUseCIF10::once != -1) {
      dispatch_once(&CADeviceUseCIF10::once, &__block_literal_global_12019);
    }
    __int16 v48 = CADeviceUseCIF10::enable_cif10 << 11;
  }
  else
  {
    __int16 v48 = 2048;
  }
  double v59 = v488;
  *(_WORD *)((char *)&v494 + 1) = (*((_WORD *)v488 + 252) << 11) & 0x3000 | v47 | v48 | v45 | v46;
  if (CA::OGL::tex_image_count[v31])
  {
    unint64_t v60 = 0;
    uint64_t v61 = v493;
    do
    {
      uint64_t v62 = *((void *)v59 + 2);
      char v63 = *(unsigned char *)(v62 + v60 + 17);
      int v64 = *((unsigned __int8 *)v61 + 6);
      uint64_t v65 = *((unsigned __int16 *)v61 + 2) | (v64 << 16);
      unint64_t v66 = *(_DWORD *)v61 & 0xFFFF1E00 | (unint64_t)(v65 << 32) | v63 & 0x3F | ((unint64_t)(*(unsigned char *)(v62 + v60 + 19) & 7) << 6);
      unint64_t v67 = v66 | 0xE000;
      *((unsigned char *)v61 + 6) = v64;
      *((_WORD *)v61 + 2) = v65;
      *(_DWORD *)uint64_t v61 = v66 | 0xE000;
      if ((0x42000FFE00uLL >> v63))
      {
        unint64_t v68 = 0;
      }
      else
      {
        unint64_t v68 = *(void *)(v62 + 8 * CA::OGL::state_image_texture_unit(v62, v60) + 176) & 0xFFFFFFFFFFFFFFFCLL;
        if (v68)
        {
          char v69 = 0;
          unint64_t v67 = v66 | ((unint64_t)(*(unsigned char *)(v68 + 125) & 7) << 13);
          *((unsigned char *)v61 + 6) = BYTE6(v66);
          *((_WORD *)v61 + 2) = WORD2(v66);
          *(_DWORD *)uint64_t v61 = v67;
          goto LABEL_70;
        }
      }
      char v69 = 1;
LABEL_70:
      uint64_t v70 = *(void *)(v62 + 8 * v60 + 40);
      if (v70)
      {
        unsigned int v71 = *(_DWORD *)(v70 + 36);
        uint64_t v485 = (v71 >> 10) & 0x1F;
        unint64_t v72 = v67 & 0xFFFC00000000FFFFLL | (v71 << 19) & 0xF80000 | (v71 << 19) & 0x1F000000 | (v485 << 29);
        uint64_t v73 = (v71 >> 15) & 0x1F;
        uint64_t v74 = (v71 >> 20) & 0x1F;
        uint64_t v75 = (v71 >> 25) & 0x1F;
        char v76 = v69;
        char NumberOfComponents = CGColorSpaceGetNumberOfComponents(*(CGColorSpaceRef *)(v70 + 16));
        char v69 = v76;
        unint64_t v78 = v72 | (v73 << 34) | (v74 << 39) | (v75 << 44);
        unint64_t v79 = v78 | ((unint64_t)(*(_DWORD *)(v70 + 36) >> 31) << 49);
        *((_WORD *)v61 + 2) = WORD2(v78);
        *(_DWORD *)uint64_t v61 = v72 | ((NumberOfComponents & 7) << 16);
        *((unsigned char *)v61 + 6) = BYTE6(v79);
        if ((v71 & 0x1F) <= 0x14 && ((1 << (v71 & 0x1F)) & 0x148000) != 0) {
          goto LABEL_73;
        }
        if ((unsigned int v85 = (v71 >> 5) & 0x1F, v85 <= 0x14) && ((1 << v85) & 0x148000) != 0
          || v485 <= 0x14 && ((1 << ((v71 >> 10) & 0x1F)) & 0x148000) != 0
          || v73 <= 0x14 && ((1 << ((v71 >> 15) & 0x1F)) & 0x148000) != 0
          || v74 <= 0x14 && ((1 << ((v71 >> 20) & 0x1F)) & 0x148000) != 0
          || v75 <= 0x14 && ((1 << ((v71 >> 25) & 0x1F)) & 0x148000) != 0)
        {
LABEL_73:
          *(_WORD *)((char *)&v494 + 1) |= 0x800u;
        }
      }
      if (v69)
      {
        LOBYTE(v80) = 0;
      }
      else
      {
        unsigned int v81 = *(_DWORD *)(v68 + 52);
        unsigned int v82 = HIWORD(v81) & 0xF;
        unsigned int v80 = (v81 >> 20) & 0xF;
        if (v82 > v80) {
          LOBYTE(v80) = v82;
        }
        if ((v80 & 0xFC) == 0) {
          LOBYTE(v80) = 0;
        }
      }
      double v59 = v488;
      __int16 v83 = *((_WORD *)v61 + 2);
      unsigned int v84 = *(_DWORD *)v61 & 0xFFFFE1FF | (v80 << 9);
      *((unsigned char *)v61 + 6) = *((unsigned char *)v61 + 6);
      *((_WORD *)v61 + 2) = v83;
      *(_DWORD *)uint64_t v61 = v84;
      uint64_t v61 = (CA::OGL::MetalContext::FragmentShader::Spec **)((char *)v61 + 7);
      ++v60;
    }
    while (v60 < CA::OGL::tex_image_count[BYTE6(v493[1]) & 0x7F]);
  }
  CA::OGL::MetalContext::Pipeline::Spec::lift_blend_function((uint64_t)v493);
  *(_DWORD *)((char *)&v494 + 3) = 0;
  int v53 = (16 * *(unsigned __int16 *)((char *)&v494 + 1)) & 0x100 | (((*(unsigned __int16 *)((char *)&v494 + 1) >> 2) & 1) << 7);
  if ((BYTE1(v494) & 4) != 0) {
    goto LABEL_98;
  }
  uint64_t v86 = BYTE6(v493[1]) & 0x7F;
  *(_WORD *)((char *)&v494 + 5) = v53 | (uint64_t)CA::OGL::MetalContext::fragment_shader_type_info[2
                                                                                                * (CA::OGL::MetalContext::texture_function_info[8 * v86 - v86] & 0x3F)
                                                                                                + 1] & 0x1F | (32 * ((v494 >> 3) & 3));
  uint64_t v87 = CA::OGL::tex_image_count[v86];
  uint64_t v19 = v488;
  if (CA::OGL::tex_image_count[v86])
  {
    uint64_t v88 = (char *)&v494 + 3;
    CGAffineTransform v89 = v493;
    do
    {
      int v90 = *(_DWORD *)v89;
      CGAffineTransform v89 = (CA::OGL::MetalContext::FragmentShader::Spec **)((char *)v89 + 7);
      *uint64_t v88 = *v88 & 0xFC | byte_18499EBD8[v90 & 0x3F] & 3;
      ++v88;
      --v87;
    }
    while (v87);
  }
LABEL_99:
  long long v491 = 0u;
  long long v492 = 0u;
  int v91 = *((_DWORD *)v19 + 108);
  int v92 = *((_DWORD *)v19 + 735);
  if ((v91 & 0x40000) != 0)
  {
    int v94 = 0;
LABEL_108:
    BOOL v95 = 0;
    memset(buf, 0, sizeof(buf));
    goto LABEL_113;
  }
  if (byte_1EB2ACC26) {
    BOOL v93 = 1;
  }
  else {
    BOOL v93 = byte_1EB2ACC27 == 0;
  }
  int v94 = !v93;
  if ((v91 & 0x80000) == 0 && byte_1EB2ACC26) {
    goto LABEL_108;
  }
  v94 |= (v91 & 0x80000u) >> 19;
  int v96 = CA::OGL::MetalContext::texture_function_info[8 * (BYTE6(v493[1]) & 0x7F) - (BYTE6(v493[1]) & 0x7F)] & 0x3F;
  BOOL v95 = v96 == 0;
  memset(buf, 0, sizeof(buf));
  if (v94 == 1 && v96 == 0)
  {
    BOOL v105 = 0;
    int v434 = 0;
    v435 = 0;
    long long v497 = 0uLL;
    long long v498 = 0uLL;
    int v94 = 1;
    goto LABEL_674;
  }
LABEL_113:
  long long v98 = std::__hash_table<std::__hash_value_type<CA::OGL::MetalContext::Pipeline::Spec,CA::OGL::MetalContext::Pipeline*>,std::__unordered_map_hasher<CA::OGL::MetalContext::Pipeline::Spec,std::__hash_value_type<CA::OGL::MetalContext::Pipeline::Spec,CA::OGL::MetalContext::Pipeline*>,CA::OGL::MetalContext::StructHasher<CA::OGL::MetalContext::Pipeline::Spec>,std::equal_to<CA::OGL::MetalContext::Pipeline::Spec>,true>,std::__unordered_map_equal<CA::OGL::MetalContext::Pipeline::Spec,std::__hash_value_type<CA::OGL::MetalContext::Pipeline::Spec,CA::OGL::MetalContext::Pipeline*>,std::equal_to<CA::OGL::MetalContext::Pipeline::Spec>,CA::OGL::MetalContext::StructHasher<CA::OGL::MetalContext::Pipeline::Spec>,true>,std::allocator<std::__hash_value_type<CA::OGL::MetalContext::Pipeline::Spec,CA::OGL::MetalContext::Pipeline*>>>::find<CA::OGL::MetalContext::Pipeline::Spec>((void *)v19 + 261, v493);
  BOOL v105 = v98 != 0;
  if (!v98)
  {
    if (v91 & 0x400000 | v92 & 8)
    {
      uint64_t v436 = mach_continuous_time();
      v437 = (NSString *)CA::OGL::MetalContext::Pipeline::Spec::name((CA::OGL::MetalContext::Pipeline::Spec *)v493);
      uint64_t pipeline_state = CA::OGL::MetalContext::load_pipeline_state(v488, v437);
      if (pipeline_state)
      {
        unint64_t v439 = pipeline_state;
        malloc_zone = (malloc_zone_t *)get_malloc_zone();
        v441 = (CA::OGL::MetalContext::Pipeline *)malloc_type_zone_malloc(malloc_zone, 0x20uLL, 0x8BB15036uLL);
        __int16 v106 = v441;
        if (v441)
        {
          *(void *)v441 = 0;
          *((void *)v441 + 1) = 0;
          *((_WORD *)v441 + 12) = 0;
          *((void *)v441 + 2) = 0;
          *((unsigned char *)v441 + 26) = 1;
        }
        std::__hash_table<std::__hash_value_type<CA::OGL::MetalContext::Pipeline::Spec,CA::OGL::MetalContext::Pipeline*>,std::__unordered_map_hasher<CA::OGL::MetalContext::Pipeline::Spec,std::__hash_value_type<CA::OGL::MetalContext::Pipeline::Spec,CA::OGL::MetalContext::Pipeline*>,CA::OGL::MetalContext::StructHasher<CA::OGL::MetalContext::Pipeline::Spec>,std::equal_to<CA::OGL::MetalContext::Pipeline::Spec>,true>,std::__unordered_map_equal<CA::OGL::MetalContext::Pipeline::Spec,std::__hash_value_type<CA::OGL::MetalContext::Pipeline::Spec,CA::OGL::MetalContext::Pipeline*>,std::equal_to<CA::OGL::MetalContext::Pipeline::Spec>,CA::OGL::MetalContext::StructHasher<CA::OGL::MetalContext::Pipeline::Spec>,true>,std::allocator<std::__hash_value_type<CA::OGL::MetalContext::Pipeline::Spec,CA::OGL::MetalContext::Pipeline*>>>::__emplace_unique_key_args<CA::OGL::MetalContext::Pipeline::Spec,std::piecewise_construct_t const&,std::tuple<CA::OGL::MetalContext::Pipeline::Spec const&>,std::tuple<>>((float *)v19 + 522, v493, v493)[6] = v441;
        uint64_t v442 = *((void *)v488 + 267);
        *((void *)v488 + 267) = v442 + 1;
        *((void *)v106 + 2) = v442;
        if (atomic_load((unint64_t *)v106)) {
          __assert_rtn("set_pipeline_state", "ogl-metal.mm", 1455, "!is_complete ()");
        }
        atomic_store(v439, (unint64_t *)v106);
        *((unsigned char *)v106 + 25) = 1;
        ++*((_DWORD *)v488 + 532);
        os_signpost_id_t v444 = CA::OGL::MetalContext::begin_new_render_pipeline((CA::OGL::MetalContext *)v437, (NSString *)1, v436);
        CA::OGL::MetalContext::end_new_render_pipeline(v488, v444, (char *)0x24, 1);
        long long v491 = *(_OWORD *)v493;
        long long v492 = v494;
        uint64_t v19 = v488;
        goto LABEL_118;
      }
    }
    v446 = (malloc_zone_t *)get_malloc_zone();
    v447 = (CA::OGL::MetalContext::Pipeline *)malloc_type_zone_malloc(v446, 0x20uLL, 0x8BB15036uLL);
    __int16 v106 = v447;
    if (v447)
    {
      *(void *)v447 = 0;
      *((void *)v447 + 1) = 0;
      *((_WORD *)v447 + 12) = 0;
      *((void *)v447 + 2) = 0;
      *((unsigned char *)v447 + 26) = 1;
    }
    std::__hash_table<std::__hash_value_type<CA::OGL::MetalContext::Pipeline::Spec,CA::OGL::MetalContext::Pipeline*>,std::__unordered_map_hasher<CA::OGL::MetalContext::Pipeline::Spec,std::__hash_value_type<CA::OGL::MetalContext::Pipeline::Spec,CA::OGL::MetalContext::Pipeline*>,CA::OGL::MetalContext::StructHasher<CA::OGL::MetalContext::Pipeline::Spec>,std::equal_to<CA::OGL::MetalContext::Pipeline::Spec>,true>,std::__unordered_map_equal<CA::OGL::MetalContext::Pipeline::Spec,std::__hash_value_type<CA::OGL::MetalContext::Pipeline::Spec,CA::OGL::MetalContext::Pipeline*>,std::equal_to<CA::OGL::MetalContext::Pipeline::Spec>,CA::OGL::MetalContext::StructHasher<CA::OGL::MetalContext::Pipeline::Spec>,true>,std::allocator<std::__hash_value_type<CA::OGL::MetalContext::Pipeline::Spec,CA::OGL::MetalContext::Pipeline*>>>::__emplace_unique_key_args<CA::OGL::MetalContext::Pipeline::Spec,std::piecewise_construct_t const&,std::tuple<CA::OGL::MetalContext::Pipeline::Spec const&>,std::tuple<>>((float *)v19 + 522, v493, v493)[6] = v447;
    uint64_t v19 = v488;
    uint64_t v448 = *((void *)v488 + 267);
    *((void *)v488 + 267) = v448 + 1;
    *((void *)v106 + 2) = v448;
    *((unsigned char *)v106 + 25) = 1;
    goto LABEL_671;
  }
  __int16 v106 = (CA::OGL::MetalContext::Pipeline *)v98[6];
  uint64_t v107 = *((void *)v19 + 267);
  *((void *)v19 + 267) = v107 + 1;
  *((void *)v106 + 2) = v107;
  if (!atomic_load((unint64_t *)v106))
  {
    if (*((void *)v106 + 1))
    {
      int v434 = 0;
      BOOL v105 = 0;
LABEL_672:
      long long v497 = 0u;
      long long v498 = 0u;
      if (!v95)
      {
        long long v495 = 0uLL;
        long long v496 = 0uLL;
        goto LABEL_678;
      }
      v435 = v106;
LABEL_674:
      CA::OGL::MetalContext::Pipeline::Spec::get_generic((uint64_t)&v497, (uint64_t)v493);
      uint64_t v19 = v488;
      v449 = std::__hash_table<std::__hash_value_type<CA::OGL::MetalContext::Pipeline::Spec,CA::OGL::MetalContext::Pipeline*>,std::__unordered_map_hasher<CA::OGL::MetalContext::Pipeline::Spec,std::__hash_value_type<CA::OGL::MetalContext::Pipeline::Spec,CA::OGL::MetalContext::Pipeline*>,CA::OGL::MetalContext::StructHasher<CA::OGL::MetalContext::Pipeline::Spec>,std::equal_to<CA::OGL::MetalContext::Pipeline::Spec>,true>,std::__unordered_map_equal<CA::OGL::MetalContext::Pipeline::Spec,std::__hash_value_type<CA::OGL::MetalContext::Pipeline::Spec,CA::OGL::MetalContext::Pipeline*>,std::equal_to<CA::OGL::MetalContext::Pipeline::Spec>,CA::OGL::MetalContext::StructHasher<CA::OGL::MetalContext::Pipeline::Spec>,true>,std::allocator<std::__hash_value_type<CA::OGL::MetalContext::Pipeline::Spec,CA::OGL::MetalContext::Pipeline*>>>::find<CA::OGL::MetalContext::Pipeline::Spec>((void *)v488 + 261, &v497);
      v450 = v449;
      BOOL v451 = v449 == 0;
      if (v449)
      {
        v452 = (void *)v449[6];
        long long v495 = 0u;
        long long v496 = 0u;
        if (!v452)
        {
          __int16 v106 = v435;
LABEL_678:
          v435 = 0;
          long long v491 = *(_OWORD *)v493;
          long long v492 = v494;
          BOOL v451 = v434;
          BOOL v453 = v105;
          goto LABEL_679;
        }
      }
      else
      {
        v454 = (malloc_zone_t *)get_malloc_zone();
        v455 = malloc_type_zone_malloc(v454, 0x20uLL, 0x8BB15036uLL);
        v452 = v455;
        if (v455)
        {
          void *v455 = 0;
          v455[1] = 0;
          *((_WORD *)v455 + 12) = 0;
          v455[2] = 0;
          *((unsigned char *)v455 + 26) = 1;
        }
        std::__hash_table<std::__hash_value_type<CA::OGL::MetalContext::Pipeline::Spec,CA::OGL::MetalContext::Pipeline*>,std::__unordered_map_hasher<CA::OGL::MetalContext::Pipeline::Spec,std::__hash_value_type<CA::OGL::MetalContext::Pipeline::Spec,CA::OGL::MetalContext::Pipeline*>,CA::OGL::MetalContext::StructHasher<CA::OGL::MetalContext::Pipeline::Spec>,std::equal_to<CA::OGL::MetalContext::Pipeline::Spec>,true>,std::__unordered_map_equal<CA::OGL::MetalContext::Pipeline::Spec,std::__hash_value_type<CA::OGL::MetalContext::Pipeline::Spec,CA::OGL::MetalContext::Pipeline*>,std::equal_to<CA::OGL::MetalContext::Pipeline::Spec>,CA::OGL::MetalContext::StructHasher<CA::OGL::MetalContext::Pipeline::Spec>,true>,std::allocator<std::__hash_value_type<CA::OGL::MetalContext::Pipeline::Spec,CA::OGL::MetalContext::Pipeline*>>>::__emplace_unique_key_args<CA::OGL::MetalContext::Pipeline::Spec,std::piecewise_construct_t const&,std::tuple<CA::OGL::MetalContext::Pipeline::Spec const&>,std::tuple<>>((float *)v488 + 522, &v497, &v497)[6] = v455;
        uint64_t v19 = v488;
        uint64_t v456 = *((void *)v488 + 267);
        *((void *)v488 + 267) = v456 + 1;
        v452[2] = v456;
        *((unsigned char *)v452 + 25) = 0;
        long long v495 = 0u;
        long long v496 = 0u;
      }
      unint64_t v457 = atomic_load(v452);
      if (v457 || v94 && *((unsigned char *)v452 + 26))
      {
        CA::OGL::MetalContext::Pipeline::Spec::push_blend_function((uint64_t)v493);
        long long v491 = v497;
        long long v492 = v498;
        BOOL v453 = 0;
        if (v434)
        {
          long long v495 = *(_OWORD *)buf;
          long long v496 = *(_OWORD *)&buf[4];
        }
        else
        {
          v435 = 0;
          LOBYTE(v105) = 0;
        }
        __int16 v106 = (CA::OGL::MetalContext::Pipeline *)v452;
        uint64_t v19 = v488;
        goto LABEL_694;
      }
      long long v491 = *(_OWORD *)v493;
      long long v492 = v494;
      if (v450)
      {
        __int16 v106 = v435;
        BOOL v451 = v434;
        BOOL v453 = v105;
        v435 = 0;
      }
      else
      {
        __int16 v106 = v435;
        long long v495 = v497;
        long long v496 = v498;
        BOOL v451 = v434;
        BOOL v453 = v105;
        v435 = (CA::OGL::MetalContext::Pipeline *)v452;
      }
LABEL_679:
      LOBYTE(v105) = 0;
LABEL_694:
      if (!atomic_load((unint64_t *)v106))
      {
        v459 = NSString;
        uint64_t v460 = CA::OGL::MetalContext::Pipeline::Spec::encode_segment((CA::OGL::MetalContext::Pipeline::Spec *)&v491);
        v461 = (CA::OGL::MetalContext *)[v459 stringWithFormat:@"%@_%@", v460, CA::OGL::MetalContext::FragmentShader::Spec::name((CA::OGL::MetalContext::FragmentShader::Spec *)&v491)];
        unsigned int v489 = 32;
        os_signpost_id_t v462 = CA::OGL::MetalContext::begin_new_render_pipeline(v461, (NSString *)1, 0);
        if (v453) {
          unsigned int v489 = 160;
        }
        if (v451)
        {
          unint64_t v463 = CA::OGL::MetalContext::create_pipeline_state((uint64_t)v488, (CA::OGL::MetalContext::Pipeline::Spec *)&v491, &v489, 0);
          if (atomic_load((unint64_t *)v106)) {
            __assert_rtn("set_pipeline_state", "ogl-metal.mm", 1455, "!is_complete ()");
          }
          atomic_store(v463, (unint64_t *)v106);
          v465 = v488;
          ++*((_DWORD *)v488 + 532);
          v466 = (char *)v489;
        }
        else
        {
          CA::OGL::MetalContext::Pipeline::wait_for_completion(v106);
          v466 = (char *)(v489 | 8);
          v465 = v488;
        }
        CA::OGL::MetalContext::end_new_render_pipeline(v465, v462, v466, 0);
        uint64_t v19 = v488;
        ++*((_DWORD *)v488 + 180);
      }
      if (v435) {
        CA::OGL::MetalContext::dispatch_async_pipeline((dispatch_queue_t *)v19, (const CA::OGL::MetalContext::Pipeline::Spec *)&v495, v435, 0, v105);
      }
      if (!atomic_load((unint64_t *)v106)) {
        __assert_rtn("get_pipeline", "ogl-metal.mm", 7074, "pipeline && pipeline->is_complete ()");
      }
      uint64_t v468 = *((void *)v19 + 267);
      *((void *)v19 + 267) = v468 + 1;
      *((void *)v106 + 2) = v468;
      goto LABEL_118;
    }
LABEL_671:
    *(_OWORD *)buf = *(_OWORD *)v493;
    *(_OWORD *)&uint8_t buf[4] = v494;
    int v434 = 1;
    goto LABEL_672;
  }
  if (*((unsigned char *)v106 + 24))
  {
    v445 = (NSString *)CA::OGL::MetalContext::Pipeline::Spec::name((CA::OGL::MetalContext::Pipeline::Spec *)v493);
    uint64_t v19 = v488;
    CA::OGL::MetalContext::emit_new_render_pipeline(v488, v445);
    *((unsigned char *)v106 + 24) = 0;
  }
  long long v491 = *(_OWORD *)v493;
  long long v492 = v494;
  CA::OGL::MetalContext::Pipeline::wait_for_completion(v106);
LABEL_118:
  if (!atomic_load((unint64_t *)v106)) {
    return;
  }
  uint64_t v110 = atomic_load((unint64_t *)v106);
  if (*((void *)v19 + 420) != v110)
  {
    *((void *)v19 + 420) = v110;
    (*((void (**)(void, char *))v19 + 376))(*((void *)v19 + 373), sel_setRenderPipelineState_);
    uint64_t v19 = v488;
  }
  uint64_t v111 = *((void *)v19 + 33);
  double v112 = *(void *)(v111 + 200) ? *(int32x2_t **)(v111 + 200) : (int32x2_t *)*((void *)v19 + 33);
  int32x2_t v113 = v112[23];
  char v114 = *((unsigned char *)v19 + 64);
  if (v114)
  {
    int32x2_t v115 = *(int32x2_t *)((char *)v19 + 40);
    int v116 = *((_DWORD *)v19 + 9);
    if ((v112[29].i16[0] & 0x200) != 0)
    {
      int v116 = v113.i32[1] - (v116 + v115.i32[1]);
      int v117 = v112[4].i32[1];
    }
    else
    {
      int v117 = -v112[4].i32[1];
    }
    int v118 = v117 + v116;
    if ((v112[29].i16[0] & 0x400) != 0)
    {
      v119.i32[0] = v112[5].i32[1] - v115.i32[1] - v118;
      v119.i32[1] = *((_DWORD *)v19 + 8) - v112[4].i32[0];
      int32x2_t v115 = vrev64_s32(v115);
    }
    else
    {
      v119.i32[0] = *((_DWORD *)v19 + 8) - v112[4].i32[0];
      v119.i32[1] = v118;
    }
    int32x2_t v122 = vmin_s32(v113, vadd_s32(v115, v119));
    int32x2_t v121 = vmax_s32(v119, 0);
    int32x2_t v113 = vsub_s32(v122, v121);
  }
  else
  {
    unsigned int v120 = (*(unsigned __int8 *)(v111 + 72) >> 1) & 0x1F;
    if (v120) {
      int32x2_t v113 = vmax_s32(vshl_s32(v113, vneg_s32(vdup_n_s32(v120))), (int32x2_t)0x100000001);
    }
    int32x2_t v121 = 0;
  }
  BOOL v124 = v113.i32[0] > 0 && v113.i32[1] > 0;
  if (*(void *)&v121 != *((void *)v19 + 6) || *(void *)&v113 != *((void *)v19 + 7))
  {
    if (v124)
    {
      int32x2_t v484 = v121;
      int32x2_t v486 = v113;
      *(void *)&long long v125 = v121.u32[0];
      *((void *)&v125 + 1) = v121.u32[1];
      long long v126 = v125;
      float v127 = (void (*)(uint64_t, char *, _DWORD *))*((void *)v19 + 379);
      uint64_t v128 = *((void *)v19 + 373);
      *(void *)&long long v125 = v113.u32[0];
      *((void *)&v125 + 1) = v113.u32[1];
      *(_OWORD *)buf = v126;
      *(_OWORD *)&uint8_t buf[4] = v125;
      v127(v128, sel_setScissorRect_, buf);
      uint64_t v19 = v488;
      char v114 = *((unsigned char *)v488 + 64);
      int32x2_t v121 = v484;
      int32x2_t v113 = v486;
    }
    *((int32x2_t *)v19 + 6) = v121;
    *((int32x2_t *)v19 + 7) = v113;
    *((_DWORD *)v19 + 824) |= 0x40u;
  }
  *((unsigned char *)v19 + 65) = *((unsigned char *)v19 + 65) & 0xFE | v114;
  if (!v124) {
    return;
  }
  unsigned int v129 = *(unsigned __int16 *)((char *)&v492 + 1);
  if ((BYTE1(v492) & 4) != 0)
  {
    uint64_t v130 = CA::OGL::MetalBufferPool::alloc_fragment_arg(*((void *)v19 + 505), 0, 0x34u, 4u);
    uint64_t v19 = v488;
    if (v130)
    {
      CA::OGL::MetalContext::FragmentShader::Spec::get_config((uint64_t)buf, (int *)v493);
      *uint64_t v130 = *(_OWORD *)buf;
      v130[1] = *(_OWORD *)&buf[4];
      v130[2] = v501;
      *((unsigned char *)v130 + 48) = v502;
    }
  }
  float v131 = (char *)v19 + 3456;
  uint64_t v132 = BYTE6(v493[1]) & 0x7F;
  if ((CA::OGL::MetalContext::texture_function_info[8 * v132 - v132] & 0x3F) != 0)
  {
    int v133 = 0;
    double v134 = (char *)v19 + 3456;
    goto LABEL_246;
  }
  unint64_t v100 = 0;
  long long v99 = 0;
  __int16 v104 = (const char *)&v497;
  long long v503 = 0u;
  long long v504 = 0u;
  long long v501 = 0u;
  long long v502 = 0u;
  memset(buf, 0, sizeof(buf));
  uint64_t v135 = *((void *)v19 + 2);
  char v136 = BYTE1(v494);
  double v137 = *(unsigned int **)(v135 + 360);
  LOBYTE(v110) = 1;
  do
  {
    char v138 = v110;
    double v139 = &buf[12 * v100];
    if (v137)
    {
      if ((v136 & 4) != 0
        || (unint64_t v101 = CA::OGL::tex_image_count[v132], v100 < v101)
        && (LOBYTE(v103) = 8 * v100,
            unint64_t v102 = CA::OGL::MetalContext::image_function_info[*(_DWORD *)((unsigned char *)&v493[v100] - v100) & 0x3F],
            (v102 & 1) != 0))
      {
        uint64_t v140 = *v137;
        if ((v140 - 1) >= 4) {
          __assert_rtn("encode_uniform_image_arg", "ogl-metal.mm", 8818, "rs->op >= RenderState::distance_fill && rs->op <= RenderState::distance_outer_stroke");
        }
        if (*((unsigned char *)v137 + 4)) {
          float v141 = -1.0;
        }
        else {
          float v141 = 1.0;
        }
        *(float *)double v139 = v141;
        v139[1] = v137[4];
        if (v140 == 1)
        {
          v139[2] = v137[2];
          v139[3] = 0;
        }
        else
        {
          long long v497 = 0uLL;
          uint64_t v499 = 0x3F80000000000000;
          *(void *)&long long v498 = 0x3F000000BF000000;
          *((void *)&v498 + 1) = 3212836864;
          double v143 = (const float *)(v137 + 2);
          float32x2_t v144 = vld1_dup_f32(v143);
          float32x2_t v145 = vmla_n_f32(v144, *(float32x2_t *)((char *)&v497 + 8 * v140), *((float *)v137 + 3));
          *((float32x2_t *)v139 + 1) = v145;
          if (v145.f32[1] < v145.f32[0])
          {
            v139[2] = v145.i32[1];
            v139[3] = v145.i32[0];
          }
        }
        goto LABEL_175;
      }
    }
    else
    {
      unint64_t v101 = CA::OGL::tex_image_count[v132];
    }
    if (v100 >= v101) {
      goto LABEL_176;
    }
    unint64_t v102 = 8 * v100;
    unint64_t v101 = CA::OGL::MetalContext::image_function_info[*(_DWORD *)((unsigned char *)&v493[v100] - v100) & 0x3F];
    if ((v101 & 0x10) != 0)
    {
      *(_OWORD *)double v139 = *(_OWORD *)(v135 + 48 * v100 + 416);
      if ((v101 & 0x20) == 0) {
        goto LABEL_175;
      }
      goto LABEL_174;
    }
    if ((v101 & 0x20) != 0)
    {
      *(_OWORD *)double v139 = *(_OWORD *)(v135 + 48 * v100 + 416);
LABEL_174:
      uint64_t v146 = v135 + 48 * v100;
      long long v147 = *(_OWORD *)(v146 + 400);
      *((_OWORD *)v139 + 1) = *(_OWORD *)(v146 + 384);
      *((_OWORD *)v139 + 2) = v147;
      goto LABEL_175;
    }
    if ((v101 & 0x40) == 0) {
      goto LABEL_176;
    }
    uint64_t v142 = v135 + 48 * v100;
    *(_OWORD *)double v139 = *(_OWORD *)(v142 + 384);
    *(_OWORD *)(v139 + 3) = *(_OWORD *)(v142 + 396);
LABEL_175:
    long long v99 = (const CA::OGL::MetalContext::FragmentShader::Spec *)buf;
LABEL_176:
    uint64_t v110 = 0;
    unint64_t v100 = 1;
  }
  while ((v138 & 1) != 0);
  unint64_t v148 = ((unint64_t)v19 + 3471) & 0xFFFFFFFFFFFFFFF0;
  if (v99)
  {
    uint64_t v149 = 0;
    int v133 = 0;
    do
    {
      float v150 = *(float *)((char *)v99 + v149);
      if (*(float *)(v148 + v149) != v150)
      {
        *(float *)(v148 + v149) = v150;
        int v133 = 1;
      }
      v149 += 4;
    }
    while (v149 != 96);
  }
  else
  {
    int v133 = 0;
  }
  if ((CA::OGL::MetalContext::blend_function_info[HIBYTE(v493[1]) & 0x3F] & 2) != 0)
  {
    uint64_t v152 = 0;
    float32x4_t v153 = vcvtq_f32_f16(*(float16x4_t *)(v135 + 296));
    *(float32x4_t *)buf = vcvtq_f32_f16(*(float16x4_t *)(v135 + 288));
    *(float32x4_t *)&uint8_t buf[4] = v153;
    unint64_t v151 = (v148 + 103) & 0xFFFFFFFFFFFFFFF0;
    do
    {
      _S0 = buf[v152];
      __asm { FCVT            H0, S0 }
      if (*(short float *)(v151 + 2 * v152) != _H0)
      {
        *(short float *)(v151 + 2 * v152) = _H0;
        int v133 = 1;
      }
      ++v152;
    }
    while (v152 != 8);
  }
  else
  {
    unint64_t v151 = (v148 + 103) & 0xFFFFFFFFFFFFFFF0;
  }
  __int16 v158 = *(_WORD *)((char *)&v494 + 1);
  if ((*(_WORD *)((unsigned char *)&v494 + 1) & 0x200) != 0)
  {
    char v169 = *(unsigned char *)(v135 + 305);
    float v170 = 1.0;
    float v171 = 1.0;
    if (v169)
    {
      float v171 = *(float *)(v135 + 312);
      if ((*(unsigned char *)(v135 + 306) & 1) == 0) {
        float v171 = powf(v171, 1.0 / *((float *)v488 + 38));
      }
    }
    *(float *)buf = v171;
    if ((v169 & 2) != 0)
    {
      float v170 = *(float *)(v135 + 316);
      if ((*(unsigned char *)(v135 + 306) & 2) == 0) {
        float v170 = powf(*(float *)(v135 + 316), 1.0 / *((float *)v488 + 38));
      }
    }
    char v172 = 0;
    uint64_t v173 = 0;
    *(float *)&buf[1] = v170;
    unint64_t v159 = (v151 + 17) & 0xFFFFFFFFFFFFFFF0;
    do
    {
      char v174 = v172;
      _S0 = buf[v173];
      __asm { FCVT            H0, S0 }
      if (*(short float *)(v159 + 2 * v173) != _H0)
      {
        *(short float *)(v159 + 2 * v173) = _H0;
        int v133 = 1;
      }
      char v172 = 1;
      uint64_t v173 = 1;
    }
    while ((v174 & 1) == 0);
    __int16 v158 = *(_WORD *)((char *)&v494 + 1);
    uint64_t v19 = v488;
    if ((*(_WORD *)((unsigned char *)&v494 + 1) & 0x400) == 0) {
      goto LABEL_209;
    }
LABEL_192:
    float v160 = fmaxf(*((float *)v19 + 734), 0.000001);
    float v161 = 1.0 / *((float *)v19 + 38);
    buf[0] = powf(v160, v161);
    float v162 = powf(1.0 / v160, v161);
    char v163 = 0;
    uint64_t v164 = 0;
    *(float *)&buf[1] = v162;
    uint64_t v165 = v159 | 4;
    do
    {
      char v166 = v163;
      _S0 = buf[v164];
      __asm { FCVT            H0, S0 }
      if (*(short float *)(v165 + 2 * v164) != _H0)
      {
        *(short float *)(v165 + 2 * v164) = _H0;
        int v133 = 1;
      }
      char v163 = 1;
      uint64_t v164 = 1;
    }
    while ((v166 & 1) == 0);
    __int16 v158 = *(_WORD *)((char *)&v494 + 1);
    if ((*(_WORD *)((unsigned char *)&v494 + 1) & 0x100) != 0)
    {
LABEL_210:
      int v177 = *(unsigned __int8 *)(v135 + 307);
      if (*(unsigned __int8 *)(v165 + 4) != v177)
      {
        *(unsigned char *)(v165 + 4) = v177;
        __int16 v158 = *(_WORD *)((char *)&v494 + 1);
        int v133 = 1;
      }
    }
  }
  else
  {
    unint64_t v159 = (v151 + 17) & 0xFFFFFFFFFFFFFFF0;
    if ((*(_WORD *)((unsigned char *)&v494 + 1) & 0x400) != 0) {
      goto LABEL_192;
    }
LABEL_209:
    uint64_t v165 = v159 | 4;
    if ((v158 & 0x100) != 0) {
      goto LABEL_210;
    }
  }
  if ((v158 & 0x200) != 0)
  {
    int v178 = *(unsigned __int8 *)(*((void *)v19 + 2) + 306);
    if (*(unsigned __int8 *)(v165 + 5) != v178)
    {
      *(unsigned char *)(v165 + 5) = v178;
      int v133 = 1;
    }
  }
  *(void *)buf = 0x3F80000000000000;
  uint64_t v179 = BYTE6(v493[1]) & 0x7F;
  if ((*(_WORD *)&CA::OGL::MetalContext::texture_function_info[8 * v179 - v179 + 5] & 4) == 0
    && (CA::OGL::MetalContext::blend_function_info[HIBYTE(v493[1]) & 0x3F] & 2) == 0)
  {
    unint64_t v180 = (v165 + 9) & 0xFFFFFFFFFFFFFFFCLL;
    goto LABEL_227;
  }
  uint64_t v181 = *(void *)(*((void *)v19 + 33) + 120);
  if (v181 == 125 || v181 == 115)
  {
    float32x2_t v182 = (float32x2_t)0x7F800000FF800000;
    goto LABEL_221;
  }
  if ((unint64_t)(v181 - 550) > 5)
  {
    float32x2_t v335 = (float32x2_t)0x3F80000000000000;
  }
  else
  {
    float32x2_t v335 = (float32x2_t)0x3FA00000BF400000;
    *(void *)buf = 0x3FA00000BF400000;
  }
  if ((*(_WORD *)((unsigned char *)&v494 + 1) & 0x400) != 0)
  {
    float32x2_t v182 = vmul_n_f32(v335, powf(1.0 / fmaxf(*((float *)v19 + 734), 0.000001), 1.0 / *((float *)v19 + 38)));
LABEL_221:
    *(float32x2_t *)buf = v182;
  }
  char v183 = 0;
  uint64_t v184 = 0;
  unint64_t v180 = (v165 + 9) & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    char v185 = v183;
    _S0 = buf[v184];
    __asm { FCVT            H0, S0 }
    if (*(short float *)(v180 + 2 * v184) != _H0)
    {
      *(short float *)(v180 + 2 * v184) = _H0;
      int v133 = 1;
    }
    char v183 = 1;
    uint64_t v184 = 1;
  }
  while ((v185 & 1) == 0);
  uint64_t v179 = BYTE6(v493[1]) & 0x7F;
LABEL_227:
  unint64_t v188 = CA::OGL::tex_image_count[v179];
  if (v188)
  {
    if ((CA::OGL::MetalContext::texture_filter_info[((unint64_t)LODWORD(v493[0]) >> 9) & 0xF] & 1) == 0)
    {
      unint64_t v189 = 0;
      __int16 v190 = (unsigned int *)((char *)v493 + 7);
      while (v188 - 1 != v189)
      {
        unsigned int v191 = *v190;
        __int16 v190 = (unsigned int *)((char *)v190 + 7);
        ++v189;
        if (CA::OGL::MetalContext::texture_filter_info[((unint64_t)v191 >> 9) & 0xF])
        {
          if (v189 >= v188) {
            goto LABEL_238;
          }
          goto LABEL_233;
        }
      }
      goto LABEL_238;
    }
LABEL_233:
    uint64_t v192 = 0;
    uint64_t v193 = *((void *)v19 + 2) + 320;
    unint64_t v194 = (v180 + 19) & 0xFFFFFFFFFFFFFFF0;
    do
    {
      float v195 = *(float *)(v193 + v192);
      if (*(float *)(v194 + v192) != v195)
      {
        *(float *)(v194 + v192) = v195;
        int v133 = 1;
      }
      v192 += 4;
    }
    while (v192 != 32);
  }
  else
  {
LABEL_238:
    unint64_t v194 = (v180 + 19) & 0xFFFFFFFFFFFFFFF0;
  }
  if (CA::OGL::MetalContext::coord_function_info[((unint64_t)LODWORD(v493[0]) >> 6) & 7])
  {
    uint64_t v197 = 0;
    uint64_t v198 = *((void *)v19 + 2) + 368;
    unint64_t v196 = (v194 + 47) & 0xFFFFFFFFFFFFFFF0;
    do
    {
      float v199 = *(float *)(v198 + v197);
      if (*(float *)(v196 + v197) != v199)
      {
        *(float *)(v196 + v197) = v199;
        int v133 = 1;
      }
      v197 += 4;
    }
    while (v197 != 16);
  }
  else
  {
    unint64_t v196 = (v194 + 47) & 0xFFFFFFFFFFFFFFF0;
  }
  double v134 = (char *)(v196 + 16);
  uint64_t v132 = BYTE6(v493[1]) & 0x7F;
LABEL_246:
  __int16 v200 = CA::OGL::MetalContext::blend_function_info[HIBYTE(v493[1]) & 0x3F];
  __int16 v201 = *(_WORD *)&CA::OGL::MetalContext::texture_function_info[8 * v132 - v132 + 5];
  if ((v200 & 4) != 0)
  {
    if ((v201 & 1) != 0 || (CA::OGL::MetalContext::texture_function_info[8 * v132 - v132 + 1] & 0x78) != 0) {
      __assert_rtn("encode_uniform_function_args", "ogl-metal.mm", 9077, "!tex_info.arg && tex_info.layout.fields[0].count == 0");
    }
    uint64_t v132 = 20;
  }
  else if (v201)
  {
    uint64_t v202 = 0;
    uint64_t v203 = *((void *)v19 + 2) + 24;
    unint64_t v204 = (unint64_t)(v134 + 7) & 0xFFFFFFFFFFFFFFF8;
    do
    {
      _S0 = *(_DWORD *)(v203 + 4 * v202);
      __asm { FCVT            H0, S0 }
      if (*(short float *)(v204 + 2 * v202) != _H0)
      {
        *(short float *)(v204 + 2 * v202) = _H0;
        int v133 = 1;
      }
      ++v202;
    }
    while (v202 != 4);
    double v134 = (char *)(v204 + 8);
    goto LABEL_281;
  }
  uint64_t v207 = 0;
  float64x2_t v208 = &CA::OGL::MetalContext::texture_function_info[8 * v132 - v132 + 1];
  do
  {
    unsigned int v209 = v208[v207];
    if ((v209 & 0x78) == 0) {
      break;
    }
    uint64_t v210 = (v200 & 4) != 0 ? *(float **)(*((void *)v19 + 2) + 280) : (float *)((char *)v19 + 80 * v207 + 2256);
    uint64_t v211 = v209 & 7;
    uint64_t v212 = ((v209 >> 3) & 0xF) * (v209 & 7);
    if ((v209 & 0x80) != 0)
    {
      uint64_t v220 = 2 * v211 - 1;
      float v221 = &v134[v220];
      unint64_t v222 = (unint64_t)v221 / (2 * v211) * 2 * v211;
      uint64_t v216 = (unint64_t)v221 & (-2 * v211);
      if ((v220 & (2 * v211)) != 0) {
        uint64_t v216 = v222;
      }
      if (v212 && v210)
      {
        float v223 = (short float *)v216;
        uint64_t v224 = ((v209 >> 3) & 0xF) * (v209 & 7);
        do
        {
          _S0 = *v210;
          __asm { FCVT            H0, S0 }
          if (*v223 != _H0)
          {
            *float v223 = _H0;
            int v133 = 1;
          }
          ++v223;
          ++v210;
          --v224;
        }
        while (v224);
      }
      char v219 = 1;
    }
    else
    {
      uint64_t v213 = 4 * v211 - 1;
      int8x16_t v214 = &v134[v213];
      unint64_t v215 = (unint64_t)v214 / (4 * v211) * 4 * v211;
      uint64_t v216 = (unint64_t)v214 & (-4 * v211);
      if ((v213 & (4 * v211)) != 0) {
        uint64_t v216 = v215;
      }
      if (v212 && v210)
      {
        int8x16_t v217 = (float *)v216;
        uint64_t v218 = ((v209 >> 3) & 0xF) * (v209 & 7);
        do
        {
          if (*v217 != *v210)
          {
            *int8x16_t v217 = *v210;
            int v133 = 1;
          }
          ++v217;
          ++v210;
          --v218;
        }
        while (v218);
      }
      char v219 = 2;
    }
    double v134 = (char *)(v216 + (v212 << v219));
    ++v207;
  }
  while (v207 != 4);
LABEL_281:
  if ((unint64_t)(v134 - v131) >= 0xE1) {
    __assert_rtn("encode_fragment_uniforms", "ogl-metal.mm", 8785, "uintptr_t (dst) - uintptr_t (_encoded.frag_uniform) <= uniform_size");
  }
  if (v133 || (*((unsigned char *)v19 + 3408) & 2) == 0)
  {
    int v227 = CA::OGL::MetalBufferPool::encode_fragment_arg(*((CA::OGL::MetalBufferPool **)v19 + 505), 1, v131, 0xE0u, 0x10u);
    uint64_t v19 = v488;
    if (v227)
    {
      *((unsigned char *)v488 + 3408) |= 2u;
      goto LABEL_286;
    }
    return;
  }
LABEL_286:
  if ((v129 & 4) != 0)
  {
LABEL_293:
    if (*((unsigned __int16 *)v19 + 1872) != *(unsigned __int16 *)(*((void *)v19 + 2) + 60))
    {
      long long v232 = CA::OGL::MetalBufferPool::alloc_fragment_arg(*((void *)v19 + 505), 3, 0x30u, 8u);
      uint64_t v19 = v488;
      if (!v232) {
        return;
      }
      uint64_t v233 = 0;
      uint64_t v234 = *((void *)v488 + 2);
      char v235 = 1;
      do
      {
        uint64_t v236 = 0;
        char v237 = v235;
        uint64_t v238 = v234 + v233;
        uint64_t v239 = *(unsigned __int8 *)(v234 + v233 + 60);
        LODWORD(v238) = *(unsigned __int8 *)(v238 + 62);
        unsigned __int8 v240 = v239 - 1;
        _ZF = v238 == 0;
        unsigned __int8 v241 = v238 - 1;
        BOOL v242 = _ZF || v239 == 0;
        int8x8_t v243 = (char *)&CA::OGL::ycbcr_matrices + 48 * v239;
        int8x8_t v244 = (char *)&CA::OGL::ycbcr_matrix_book + 96 * v240 + 48 * v241;
        if (v242) {
          int8x8_t v244 = v243;
        }
        unint64_t v245 = ((unint64_t)v232 + 7) & 0xFFFFFFFFFFFFFFF8;
        do
        {
          _S0 = *(_DWORD *)&v244[4 * v236];
          __asm { FCVT            H0, S0 }
          if (*(short float *)(v245 + 2 * v236) != _H0) {
            *(short float *)(v245 + 2 * v236) = _H0;
          }
          ++v236;
        }
        while (v236 != 12);
        char v235 = 0;
        long long v232 = (void *)(v245 + 24);
        uint64_t v233 = 1;
      }
      while ((v237 & 1) != 0);
    }
    goto LABEL_306;
  }
  unint64_t v228 = CA::OGL::tex_image_count[BYTE14(v491) & 0x7F];
  if (CA::OGL::tex_image_count[BYTE14(v491) & 0x7F])
  {
    if ((CA::OGL::MetalContext::image_function_info[v491 & 0x3F] & 2) != 0) {
      goto LABEL_293;
    }
    unint64_t v229 = 0;
    long long v230 = (int *)((char *)&v491 + 7);
    do
    {
      if (v228 - 1 == v229) {
        goto LABEL_306;
      }
      int v231 = *v230;
      long long v230 = (int *)((char *)v230 + 7);
      ++v229;
    }
    while ((CA::OGL::MetalContext::image_function_info[v231 & 0x3F] & 2) == 0);
    if (v229 < v228) {
      goto LABEL_293;
    }
LABEL_306:
    if ((v129 & 4) != 0)
    {
LABEL_309:
      unint64_t v249 = CA::OGL::tex_image_count[BYTE6(v493[1]) & 0x7F];
      if (*((_DWORD *)v19 + 948) == -1)
      {
        BOOL v252 = v249 == 0;
      }
      else
      {
        int v250 = (*((unsigned __int8 *)v19 + 3408) >> 4) & 1;
        int v251 = (v129 >> 11) & 1;
        BOOL v252 = v249 == 0;
        LOBYTE(v253) = v251 != v250;
        if (v251 == v250 && v249 != 0)
        {
          unint64_t v255 = 0;
          do
          {
            uint64_t v253 = *(void *)(*((void *)v19 + 2) + 40 + 8 * v255);
            if (v253) {
              LOBYTE(v253) = *(_DWORD *)(v253 + 8) != *((_DWORD *)v19 + v255 + 948);
            }
            if (v253) {
              break;
            }
            ++v255;
          }
          while (v255 < v249);
        }
        if ((v253 & 1) == 0) {
          goto LABEL_352;
        }
      }
      if ((v129 & 0x800) != 0) {
        unsigned int v256 = 1344;
      }
      else {
        unsigned int v256 = 672;
      }
      if ((v129 & 0x800) != 0) {
        unsigned int v257 = 16;
      }
      else {
        unsigned int v257 = 8;
      }
      long long v258 = CA::OGL::MetalBufferPool::alloc_fragment_arg(*((void *)v19 + 505), 4, v256, v257);
      uint64_t v19 = v488;
      if (!v258) {
        return;
      }
      if (!v252)
      {
        uint64_t v259 = 0;
        uint64_t v260 = *((void *)v488 + 2);
        char v261 = 3;
        if ((v129 & 0x800) != 0) {
          char v261 = 4;
        }
        do
        {
          long long v262 = (char *)v488 + 4 * v259;
          *((_DWORD *)v262 + 948) = 0;
          uint64_t v263 = *(void *)(v260 + 8 * v259 + 40);
          if (v263)
          {
            uint64_t v264 = 0;
            long long v265 = v262 + 3792;
            long long v99 = *(const CA::OGL::MetalContext::FragmentShader::Spec **)(v263 + 48);
            uint64_t v110 = *(unsigned int *)(v263 + 36);
            do
            {
              uint64_t v266 = (v110 >> (5 * v264)) & 0x1FLL;
              unint64_t v101 = (unint64_t)v258 + ((42 * v259) << v261) + ((7 * v264) << v261);
              unint64_t v100 = 4 * CA::ColorProgram::kOpcodeParamCount[v266];
              LODWORD(v103) = v99 != 0;
              unint64_t v102 = v103 & (0x1FE7FEuLL >> v266);
              if ((v129 & 0x800) != 0)
              {
                if (v102)
                {
                  unint64_t v101 = (v101 + 15) & 0xFFFFFFFFFFFFFFF0;
                  unint64_t v102 = v100;
                  int v103 = v99;
                  do
                  {
                    if (*(float *)v101 != *(float *)v103) {
                      *(_DWORD *)unint64_t v101 = *v103;
                    }
                    v101 += 4;
                    ++v103;
                    --v102;
                  }
                  while (v102);
                }
              }
              else if (v102)
              {
                unint64_t v101 = (v101 + 7) & 0xFFFFFFFFFFFFFFF8;
                unint64_t v102 = (unint64_t)v99;
                int v103 = (_DWORD *)v100;
                do
                {
                  _S0 = *(_DWORD *)v102;
                  __asm { FCVT            H0, S0 }
                  if (*(short float *)v101 != _H0) {
                    *(short float *)unint64_t v101 = _H0;
                  }
                  v101 += 2;
                  v102 += 4;
                  int v103 = (_DWORD *)((char *)v103 - 1);
                }
                while (v103);
              }
              long long v99 = (const CA::OGL::MetalContext::FragmentShader::Spec *)((char *)v99 + 4 * v100);
              ++v264;
            }
            while (v264 != 6);
            *long long v265 = *(_DWORD *)(v263 + 8);
          }
          ++v259;
        }
        while (v259 != v249);
      }
      if (v249 <= 1)
      {
        do
        {
          unint64_t v269 = v249;
          *((_DWORD *)v488 + v249 + 948) = 0;
          unint64_t v249 = 1;
        }
        while (!v269);
      }
      *((unsigned char *)v488 + 3408) = (v129 >> 7) & 0x10 | *((unsigned char *)v488 + 3408) & 0xEF;
LABEL_352:
      if ((v129 & 4) == 0) {
        goto LABEL_353;
      }
      uint64_t v479 = 2;
      goto LABEL_362;
    }
  }
  unint64_t v248 = CA::OGL::tex_image_count[BYTE14(v491) & 0x7F];
  if (CA::OGL::tex_image_count[BYTE14(v491) & 0x7F])
  {
    if (((v491 | ((unint64_t)(WORD2(v491) | (BYTE6(v491) << 16)) << 32)) & 0x1FFFFFFF80000) == 0)
    {
      unint64_t v331 = 0;
      v332 = (char *)&v491 + 7;
      do
      {
        if (v248 - 1 == v331) {
          goto LABEL_352;
        }
        uint64_t v333 = *((unsigned __int16 *)v332 + 2) | (v332[6] << 16);
        unsigned int v334 = *(_DWORD *)v332;
        v332 += 7;
        ++v331;
      }
      while (((v334 | (unint64_t)(v333 << 32)) & 0x1FFFFFFF80000) == 0);
      if (v331 >= v248) {
        goto LABEL_352;
      }
    }
    goto LABEL_309;
  }
LABEL_353:
  uint64_t v479 = CA::OGL::tex_image_count[BYTE14(v491) & 0x7F];
  if (CA::OGL::tex_image_count[BYTE14(v491) & 0x7F])
  {
LABEL_362:
    unint64_t v273 = 0;
    v274 = &selRef_averagePixelTable;
    unsigned int v275 = 3;
    v276 = &selRef_averagePixelTable;
    while (1)
    {
      unint64_t v277 = 0;
      v278 = (unsigned int *)((char *)&v491 + 8 * v273 - v273);
      v483 = (unsigned int *)((char *)v493 + 7 * v273);
      v487 = (uint64_t *)((char *)v19 + 8 * v273 + 3928);
      v481 = v274[121];
      v482 = v276[122];
      unsigned int v480 = v275;
      do
      {
        if ((BYTE1(v492) & 4) == 0
          && (v273 >= CA::OGL::tex_image_count[BYTE14(v491) & 0x7F]
           || v277 >= CA::OGL::image_plane_count[*v278 & 0x3FLL]
           || (*v278 & 0x8000) == 0))
        {
          goto LABEL_431;
        }
        uint64_t v279 = *((void *)v19 + 2);
        uint64_t v280 = *(void *)(v279
                         + 8 * (v277 + CA::OGL::state_image_texture_unit(v279, v273))
                         + 176);
        if ((BYTE1(v494) & 4) == 0
          && (CA::OGL::tex_image_count[BYTE6(v493[1]) & 0x7F] <= v273
           || v277 >= CA::OGL::image_plane_count[*v483 & 0x3FLL]
           || (*v483 & 0x8000) == 0))
        {
          int v281 = CA::OGL::MetalContext::encode_placeholder_texture((uint64_t)v19, v275);
          uint64_t v19 = v488;
          v276 = &selRef_averagePixelTable;
          if (!v281) {
            return;
          }
          if (!v277)
          {
            uint64_t v110 = *((void *)v488 + 366);
            if (!v110)
            {
              uint64_t v110 = [*((id *)v488 + 369) newSamplerStateWithDescriptor:(id)objc_opt_new()];
              uint64_t v19 = v488;
              *((void *)v488 + 366) = v110;
              v276 = &selRef_averagePixelTable;
              if (!v110) {
                return;
              }
            }
            if (*v487 != v110)
            {
              uint64_t *v487 = v110;
              (*((void (**)(void, char *))v19 + 378))(*((void *)v19 + 373), v482);
LABEL_430:
              uint64_t v19 = v488;
              v276 = &selRef_averagePixelTable;
              goto LABEL_431;
            }
          }
          goto LABEL_431;
        }
        unint64_t v282 = v280 & 0xFFFFFFFFFFFFFFFCLL;
        v276 = &selRef_averagePixelTable;
        if ((v280 & 0xFFFFFFFFFFFFFFFCLL) == 0) {
          return;
        }
        unint64_t v283 = v282 + 8 * (v280 & 3);
        uint64_t v285 = *(void *)(v283 + 64);
        v284 = (uint64_t *)(v283 + 64);
        if (!v285) {
          return;
        }
        int v286 = *(unsigned __int16 *)(v282 + 123);
        if ((v286 & 8) == 0)
        {
          uint64_t v287 = 0;
          goto LABEL_419;
        }
        v288 = (void *)*((void *)v19 + 342);
        if (!v288)
        {
          v288 = malloc_type_calloc(8uLL, 0x100uLL, 0xC1573CA8uLL);
          uint64_t v19 = v488;
          *((void *)v488 + 342) = v288;
          int v286 = *(unsigned __int8 *)(v282 + 123);
          v276 = &selRef_averagePixelTable;
        }
        uint64_t v289 = (8 * v286) & 0x80 | ((v286 & 1) << 6) | (*(_DWORD *)(v282 + 52) >> 18) & 0xC | HIWORD(*(_DWORD *)(v282 + 52)) & 3 | (16 * ((*(unsigned __int8 *)(v282 + 58) >> 3) & 3u));
        uint64_t v287 = v288[v289];
        if (!v287)
        {
          v290 = objc_opt_new();
          v291 = v290;
          if ((*((unsigned char *)v488 + 2725) & 8) != 0)
          {
            __int16 v293 = *(_WORD *)(v282 + 123);
            BOOL v292 = (v293 & 0x10) == 0 && (v293 & 1) == 0;
          }
          else
          {
            BOOL v292 = 0;
          }
          int v294 = *(_WORD *)(v282 + 54) & 0xF;
          if ((*(_WORD *)(v282 + 54) & 0xF) == 0 || v294 == 8)
          {
            uint64_t v296 = 0;
          }
          else if (v294 == 3 && v292)
          {
            uint64_t v296 = 2;
          }
          else
          {
            uint64_t v296 = 1;
          }
          [v290 setMinFilter:v296];
          int v297 = (*(_DWORD *)(v282 + 52) >> 20) & 0xF;
          if (v297) {
            BOOL v298 = v297 == 8;
          }
          else {
            BOOL v298 = 1;
          }
          if (v298)
          {
            uint64_t v299 = 0;
          }
          else if (v297 == 3 && v292)
          {
            uint64_t v299 = 2;
          }
          else
          {
            uint64_t v299 = 1;
          }
          [v291 setMagFilter:v299];
          int v300 = (*(unsigned __int8 *)(v282 + 58) >> 3) & 3;
          if (v300 == 3)
          {
            x_log_crash("Invalid TextureEdgeMode 0x%x", 3);
            abort();
          }
          uint64_t v301 = (2 * v300);
          [v291 setTAddressMode:v301];
          [v291 setSAddressMode:v301];
          __int16 v302 = *(_WORD *)(v282 + 123);
          if (v302)
          {
            uint64_t v303 = *(_WORD *)(v282 + 54) & 0xF;
            if (v303 == 2) {
              goto LABEL_415;
            }
            if (v303 == 7)
            {
              uint64_t v303 = 1;
LABEL_415:
              [v291 setMipFilter:v303];
              __int16 v302 = *(_WORD *)(v282 + 123);
            }
          }
          if ((v302 & 0x10) != 0) {
            [v291 setMaxAnisotropy:8];
          }
          uint64_t v287 = [*((id *)v488 + 369) newSamplerStateWithDescriptor:v291];

          uint64_t v19 = v488;
          *(void *)(*((void *)v488 + 342) + 8 * v289) = v287;
          v276 = &selRef_averagePixelTable;
        }
LABEL_419:
        unint64_t v304 = atomic_load((unint64_t *)v19 + 503);
        *(void *)(v282 + 112) = v304;
        if ((*(_WORD *)(v282 + 123) & 0x20) != 0)
        {
          if (v277) {
            __assert_rtn("encode_image_plane", "ogl-metal.mm", 9242, "plane == 0");
          }
          uint64_t v110 = *v284;
          v306 = (char *)v19 + 8 * v275;
          if (*((void *)v306 + 476) != *v284 || *v487 != v287)
          {
            *((void *)v306 + 476) = v110;
            uint64_t *v487 = v287;
            objc_msgSend(*((id *)v19 + 373), "setFragmentTexture:atTextureIndex:samplerState:atSamplerIndex:");
            goto LABEL_430;
          }
        }
        else
        {
          uint64_t v110 = *v284;
          v305 = (char *)v19 + 8 * v275;
          if (*((void *)v305 + 476) != *v284)
          {
            *((void *)v305 + 476) = v110;
            (*((void (**)(void, char *))v19 + 377))(*((void *)v19 + 373), v481);
            uint64_t v19 = v488;
            v276 = &selRef_averagePixelTable;
          }
          if (!v277 && v287 && *v487 != v287)
          {
            uint64_t *v487 = v287;
            (*((void (**)(void, char *, uint64_t, void))v19 + 378))(*((void *)v19 + 373), v482, v287, v273);
            goto LABEL_430;
          }
        }
LABEL_431:
        ++v277;
        v275 += 2;
      }
      while (v277 != 3);
      if ((BYTE1(v492) & 4) != 0
        || (unint64_t v307 = *v278 | ((unint64_t)(*((unsigned __int16 *)v278 + 2) | (*((unsigned __int8 *)v278 + 6) << 16)) << 32),
            int8x16_t v308 = (int8x16_t)vdupq_n_s64(v307),
            (vmaxv_u16((uint16x4_t)vmovn_s32(vuzp1q_s32((int32x4_t)vceqq_s64((int64x2_t)vandq_s8(v308, (int8x16_t)xmmword_1849982C0), (int64x2_t)xmmword_1849982E0), (int32x4_t)vceqq_s64((int64x2_t)vandq_s8(v308, (int8x16_t)xmmword_1849982D0), (int64x2_t)xmmword_1849982F0)))) & 1) != 0)|| ((uint64_t v309 = v307 & 0xF8000000000, v310 = v307 & 0x1F00000000000, v309 != 0x38000000000)? (v311 = v310 == 0x700000000000): (v311 = 1), v311))
      {
        unint64_t v100 = (v273 + 10);
        if ((BYTE1(v494) & 4) != 0
          || (unint64_t v312 = *v483 | ((unint64_t)(*((unsigned __int16 *)v483 + 2) | (*((unsigned __int8 *)v483 + 6) << 16)) << 32),
              int8x16_t v313 = (int8x16_t)vdupq_n_s64(v312),
              (vmaxv_u16((uint16x4_t)vmovn_s32(vuzp1q_s32((int32x4_t)vceqq_s64((int64x2_t)vandq_s8(v313, (int8x16_t)xmmword_1849982C0), (int64x2_t)xmmword_1849982E0), (int32x4_t)vceqq_s64((int64x2_t)vandq_s8(v313, (int8x16_t)xmmword_1849982D0), (int64x2_t)xmmword_1849982F0)))) & 1) != 0)|| ((uint64_t v314 = v312 & 0xF8000000000, v315 = v312 & 0x1F00000000000, v314 != 0x38000000000)? (v316 = v315 == 0x700000000000): (v316 = 1), v316))
        {
          unint64_t v318 = *(void *)(*((void *)v19 + 2)
                           + 8 * *(unsigned __int8 *)(*((void *)v19 + 2) + v273 + 56)
                           + 176) & 0xFFFFFFFFFFFFFFFCLL;
          unint64_t v319 = atomic_load((unint64_t *)v19 + 503);
          *(void *)(v318 + 112) = v319;
          uint64_t v110 = *(void *)(v318 + 64);
          v320 = (char *)v19 + 8 * v100;
          if (*((void *)v320 + 476) != v110)
          {
            *((void *)v320 + 476) = v110;
            (*((void (**)(void, char *))v19 + 377))(*((void *)v19 + 373), sel_setFragmentTexture_atIndex_);
            uint64_t v19 = v488;
            v276 = &selRef_averagePixelTable;
          }
        }
        else
        {
          int v317 = CA::OGL::MetalContext::encode_placeholder_texture((uint64_t)v19, (int)v273 + 10);
          uint64_t v19 = v488;
          v276 = &selRef_averagePixelTable;
          if (!v317) {
            return;
          }
        }
        if ((BYTE1(v492) & 4) == 0) {
          goto LABEL_451;
        }
        goto LABEL_457;
      }
      if ((BYTE1(v492) & 4) != 0) {
        goto LABEL_457;
      }
LABEL_451:
      uint64_t v321 = *v278;
      if (((v321 >> 19) & 0x1F) - 8 < 3
        || (BYTE3(v321) & 0x1F) - 8 < 3u
        || (unint64_t v322 = v321 | ((unint64_t)(*((unsigned __int16 *)v278 + 2) | (*((unsigned __int8 *)v278 + 6) << 16)) << 32),
            ((v322 >> 29) & 0x1F) - 8 < 3)
        || ((v322 >> 34) & 0x1F) - 8 < 3
        || ((v322 >> 39) & 0x1F) - 8 < 3
        || ((v322 >> 44) & 0x1F) - 8 < 3
        || (int8x16_t v328 = (int8x16_t)vdupq_n_s64(v322),
            (vmaxv_u16((uint16x4_t)vmovn_s32(vuzp1q_s32((int32x4_t)vceqq_s64((int64x2_t)vandq_s8(v328, (int8x16_t)xmmword_1849982C0), (int64x2_t)xmmword_184998300), (int32x4_t)vceqq_s64((int64x2_t)vandq_s8(v328, (int8x16_t)xmmword_1849982D0), (int64x2_t)xmmword_184998310)))) & 1) != 0)|| (v322 & 0xF8000000000) == 0x98000000000|| (v322 & 0x1F00000000000) == 0x1300000000000)
      {
LABEL_457:
        unint64_t v100 = (v273 + 12);
        if ((BYTE1(v494) & 4) != 0
          || (uint64_t v323 = *v483, ((v323 >> 19) & 0x1F) - 8 < 3)
          || (BYTE3(v323) & 0x1F) - 8 < 3u
          || (unint64_t v324 = v323 | ((unint64_t)(*((unsigned __int16 *)v483 + 2) | (*((unsigned __int8 *)v483 + 6) << 16)) << 32),
              ((v324 >> 29) & 0x1F) - 8 < 3)
          || ((v324 >> 34) & 0x1F) - 8 < 3
          || ((v324 >> 39) & 0x1F) - 8 < 3
          || ((v324 >> 44) & 0x1F) - 8 < 3
          || (int8x16_t v329 = (int8x16_t)vdupq_n_s64(v324),
              (vmaxv_u16((uint16x4_t)vmovn_s32(vuzp1q_s32((int32x4_t)vceqq_s64((int64x2_t)vandq_s8(v329, (int8x16_t)xmmword_1849982C0), (int64x2_t)xmmword_184998300), (int32x4_t)vceqq_s64((int64x2_t)vandq_s8(v329, (int8x16_t)xmmword_1849982D0), (int64x2_t)xmmword_184998310)))) & 1) != 0)|| (v324 & 0xF8000000000) == 0x98000000000|| (v324 & 0x1F00000000000) == 0x1300000000000)
        {
          unint64_t v325 = *(void *)(*((void *)v19 + 2)
                           + 8 * *(unsigned __int8 *)(*((void *)v19 + 2) + v273 + 58)
                           + 176) & 0xFFFFFFFFFFFFFFFCLL;
          unint64_t v326 = atomic_load((unint64_t *)v19 + 503);
          *(void *)(v325 + 112) = v326;
          uint64_t v110 = *(void *)(v325 + 64);
          v327 = (char *)v19 + 8 * v100;
          if (*((void *)v327 + 476) != v110)
          {
            *((void *)v327 + 476) = v110;
            (*((void (**)(void, char *))v19 + 377))(*((void *)v19 + 373), sel_setFragmentTexture_atIndex_);
            uint64_t v19 = v488;
            v276 = &selRef_averagePixelTable;
          }
        }
        else
        {
          int v330 = CA::OGL::MetalContext::encode_placeholder_cube((uint64_t)v19, (int)v273 + 12);
          uint64_t v19 = v488;
          v276 = &selRef_averagePixelTable;
          if (!v330) {
            return;
          }
        }
      }
      ++v273;
      unsigned int v275 = v480 + 1;
      v274 = &selRef_averagePixelTable;
      if (v273 == v479)
      {
        if ((BYTE1(v492) & 4) != 0) {
          goto LABEL_488;
        }
        goto LABEL_355;
      }
    }
  }
  if ((v129 & 4) != 0) {
    goto LABEL_488;
  }
LABEL_355:
  uint64_t v270 = BYTE14(v491) & 0x7F;
  if ((*(_WORD *)&CA::OGL::MetalContext::texture_function_info[8 * v270 - v270 + 5] & 0x20) == 0)
  {
    uint64_t v271 = CA::OGL::tex_image_count[v270];
    if (v271)
    {
      v272 = &v491;
      while (((0x42000FFE00uLL >> *(_DWORD *)v272) & 1) != 0)
      {
        v272 = (long long *)((char *)v272 + 7);
        if (!--v271) {
          goto LABEL_501;
        }
      }
LABEL_488:
      uint64_t v336 = CA::OGL::tex_image_count[BYTE6(v493[1]) & 0x7F];
      v337 = (char *)v19 + 3800;
      char v338 = 0;
      if (CA::OGL::tex_image_count[BYTE6(v493[1]) & 0x7F])
      {
        uint64_t v339 = 0;
        uint64_t v340 = *((void *)v19 + 2);
        do
        {
          unint64_t v341 = *(void *)(v340 + 8 * CA::OGL::state_image_texture_unit(v340, v339) + 176) & 0xFFFFFFFFFFFFFFFCLL;
          if (v341)
          {
            float v342 = *(float *)(v341 + 48);
            if (*(float *)&v337[4 * v339] != v342)
            {
              *(float *)&v337[4 * v339] = v342;
              char v338 = 1;
            }
          }
          ++v339;
        }
        while (v336 != v339);
      }
      if (v338)
      {
        if ((BYTE1(v494) & 4) != 0) {
          unsigned int v343 = 8;
        }
        else {
          unsigned int v343 = 4 * v336;
        }
        int v344 = CA::OGL::MetalBufferPool::encode_fragment_arg(*((CA::OGL::MetalBufferPool **)v19 + 505), 2, (char *)v19 + 3800, v343, 4u);
        uint64_t v19 = v488;
        if (!v344) {
          return;
        }
        if (v336 <= 1) {
          *((_DWORD *)v488 + v336 + 950) = 2143289344;
        }
      }
    }
  }
LABEL_501:
  __int16 v345 = *(_WORD *)((char *)&v492 + 1);
  if ((BYTE1(v492) & 0xC) == 0
    || CA::OGL::MetalContext::encode_noise_texture(v19, (uint64_t)v99, v110, v100, v101, (const unsigned __int8 *)v102, (BOOL)v103, v104)&& (uint64_t v19 = v488, CA::OGL::MetalContext::encode_noise_scale(v488, v346)))
  {
    uint64_t v347 = BYTE14(v491) & 0x7F;
    __int16 v348 = *(_WORD *)&CA::OGL::MetalContext::texture_function_info[8 * v347 - v347 + 5];
    if ((v348 & 0x40) == 0 || (v349 = CA::OGL::MetalContext::encode_edr_resolve(v19, v99), uint64_t v19 = v488, v349))
    {
      if (!(v345 & 0x204 | v348 & 0x80))
      {
        unint64_t v351 = CA::OGL::tex_image_count[v347];
        if (!CA::OGL::tex_image_count[v347]) {
          goto LABEL_547;
        }
        unsigned int v352 = (v491 >> 19) & 0x1F;
        if (v352 != 11)
        {
          unsigned int v353 = BYTE3(v491) & 0x1F;
          if (v353 != 11)
          {
            unint64_t v354 = v491 | ((unint64_t)(WORD2(v491) | (BYTE6(v491) << 16)) << 32);
            uint64_t v355 = (v354 >> 29) & 0x7FFFFFF;
            uint64_t v356 = (v354 >> 34) & 0x3FFFFF;
            uint64_t v357 = (v354 >> 39) & 0x1FFFF;
            uint64_t v358 = (v354 >> 44) & 0xFFF;
            v359 = (unsigned int *)((char *)&v491 + 7);
            unint64_t v360 = 1;
            BOOL v361 = 1;
            do
            {
              int v362 = v355 & 0x1F;
              int v363 = v356 & 0x1F;
              BOOL v364 = v362 == 11 || v363 == 11;
              int v365 = v357 & 0x1F;
              BOOL v366 = v364 || v365 == 11;
              int v367 = v358 & 0x1F;
              if (v366
                || v367 == 12
                || v365 == 12
                || v363 == 12
                || v362 == 12
                || v353 == 12
                || v367 == 11
                || v352 == 12)
              {
                break;
              }
              BOOL v361 = v360 < v351;
              if (v351 == v360) {
                break;
              }
              uint64_t v375 = *v359;
              unsigned int v352 = (v375 >> 19) & 0x1F;
              if (v352 == 11) {
                break;
              }
              unint64_t v376 = v375 | ((unint64_t)(*((unsigned __int16 *)v359 + 2) | (*((unsigned __int8 *)v359 + 6) << 16)) << 32);
              uint64_t v358 = (v376 >> 44) & 0xFFF;
              uint64_t v357 = (v376 >> 39) & 0x1FFFF;
              uint64_t v356 = (v376 >> 34) & 0x3FFFFF;
              uint64_t v355 = (v376 >> 29) & 0x7FFFFFF;
              unsigned int v353 = BYTE3(v375) & 0x1F;
              v359 = (unsigned int *)((char *)v359 + 7);
              ++v360;
            }
            while (v353 != 11);
            if (!v361) {
              goto LABEL_547;
            }
          }
        }
      }
      int v350 = CA::OGL::MetalContext::encode_gamma_luts(v19);
      uint64_t v19 = v488;
      if (v350)
      {
LABEL_547:
        if ((v345 & 4) != 0) {
          goto LABEL_552;
        }
        unint64_t v377 = CA::OGL::tex_image_count[v347];
        if (!CA::OGL::tex_image_count[v347]) {
          goto LABEL_553;
        }
        if ((CA::OGL::MetalContext::texture_filter_info[((unint64_t)v491 >> 9) & 0xF] & 2) != 0)
        {
LABEL_552:
          int v381 = CA::OGL::MetalContext::encode_asg77_weights(v19, v99);
          uint64_t v19 = v488;
          if (!v381) {
            return;
          }
        }
        else
        {
          unint64_t v378 = 0;
          v379 = (unsigned int *)((char *)&v491 + 7);
          while (v377 - 1 != v378)
          {
            unsigned int v380 = *v379;
            v379 = (unsigned int *)((char *)v379 + 7);
            ++v378;
            if ((CA::OGL::MetalContext::texture_filter_info[((unint64_t)v380 >> 9) & 0xF] & 2) != 0)
            {
              if (v378 >= v377) {
                break;
              }
              goto LABEL_552;
            }
          }
        }
LABEL_553:
        int v382 = v345 & 4;
        if (v382 | v348 & 0x100)
        {
          CA::OGL::MetalContext::encode_fragment_data(*((void *)v19 + 505), a12);
          uint64_t v19 = v488;
        }
        if (v382 | v348 & 0x200)
        {
          int v383 = CA::OGL::MetalContext::encode_lut_texture(v19, (const CA::OGL::MetalContext::FragmentShader::Spec *)BYTE6(v493[1]), SBYTE1(v494));
          uint64_t v19 = v488;
          if (!v383) {
            return;
          }
        }
        if ((v345 & 4) != 0) {
          unsigned int v384 = 2;
        }
        else {
          unsigned int v384 = CA::OGL::tex_image_count[BYTE6(v493[1]) & 0x7F];
        }
        unsigned int v385 = *(unsigned __int16 *)((char *)&v492 + 5);
        if ((BYTE5(v492) & 0x80) != 0)
        {
          v387 = CA::OGL::MetalBufferPool::alloc_vertex_arg(*((void *)v19 + 505), 0, 4u, 4u);
          uint64_t v19 = v488;
          if (v387) {
            _DWORD *v387 = BYTE3(v494) & 3 | ((BYTE4(v494) & 3) << 8) | (((*(unsigned __int16 *)((char *)&v494 + 5) >> 5) & 3) << 16);
          }
        }
        else
        {
          LOBYTE(v386) = 0;
          if ((BYTE5(v492) & 0x60) != 0 || (*(_WORD *)((unsigned char *)&v492 + 3) & 0x303) == 0) {
            goto LABEL_579;
          }
        }
        if (v384)
        {
          uint64_t v388 = 0;
          uint64_t v389 = 0;
          uint64_t v390 = *((void *)v19 + 2);
          do
          {
            *(_OWORD *)((char *)v19 + v388 + 2576) = *(_OWORD *)(v390 + v388 + 96);
            if (((0x42000FFE00uLL >> *(unsigned char *)(v390 + v389 + 17)) & 1) == 0)
            {
              unint64_t v391 = *(void *)(v390 + 8 * CA::OGL::state_image_texture_unit(v390, v389) + 176) & 0xFFFFFFFFFFFFFFFCLL;
              if (v391)
              {
                if ((*(_WORD *)(v391 + 123) & 0x100) != 0)
                {
                  v392 = (float *)((char *)v19 + v388);
                  v392[645] = -*(float *)((char *)v19 + v388 + 2580);
                  v392[647] = 1.0 - *(float *)((char *)v19 + v388 + 2588);
                }
              }
            }
            ++v389;
            v388 += 16;
          }
          while (v384 != v389);
        }
        if (v384 > 1 || (*((unsigned char *)v19 + 3408) & 1) == 0 || memcmp((char *)v19 + 3376, (char *)v19 + 2576, 16 * v384))
        {
          v393 = (char *)v19 + 2576;
          int v394 = CA::OGL::MetalBufferPool::encode_vertex_arg(*((CA::OGL::MetalBufferPool **)v19 + 505), 3, (char *)v19 + 2576, 16 * v384, 0x10u);
          uint64_t v19 = v488;
          if (!v394) {
            return;
          }
          memcpy((char *)v488 + 3376, v393, 16 * v384);
          *((unsigned char *)v488 + 3408) = *((unsigned char *)v488 + 3408) & 0xFE | v384 & 1;
        }
        int v386 = (v385 >> 7) & 1;
LABEL_579:
        if (v386 & 1) != 0 || ((0x27F90uLL >> (v385 & 0x1F)))
        {
          int v395 = BYTE5(v494) & 0x1F;
          if ((vminvq_u32((uint32x4_t)vceqq_f32(*((float32x4_t *)v19 + 214), *((float32x4_t *)v19 + 141))) & 0x80000000) == 0
            || v395 == 7
            && (vminvq_u32((uint32x4_t)vceqq_f32(*((float32x4_t *)v19 + 215), *((float32x4_t *)v19 + 142))) & 0x80000000) == 0)
          {
            char v396 = (char)CA::OGL::MetalContext::vertex_shader_type_info[3 * (BYTE5(v494) & 0x1F) + 2];
            int v397 = CA::OGL::MetalBufferPool::encode_vertex_arg(*((CA::OGL::MetalBufferPool **)v19 + 505), 5, (char *)v19 + 2256, 4 * (v396 & 0xFu), 4 * (v396 & 0xFu));
            uint64_t v19 = v488;
            if (!v397) {
              return;
            }
            if ((0x5806FuLL >> v395))
            {
              *((_DWORD *)v488 + 856) = 2143289344;
            }
            else
            {
              *((_OWORD *)v488 + 214) = *((_OWORD *)v488 + 141);
              if (v395 == 7) {
                *((_OWORD *)v488 + 215) = *((_OWORD *)v488 + 142);
              }
            }
          }
        }
        if (*((_DWORD *)v19 + 842) != *((_DWORD *)v19 + 64) || a11)
        {
          v398 = (float32x4_t *)CA::OGL::MetalBufferPool::alloc_vertex_arg(*((void *)v19 + 505), 2, 0x40u, 0x10u);
          uint64_t v19 = v488;
          if (!v398) {
            return;
          }
          if (a11 || (v403 = (float *)*((void *)v488 + 102)) == 0)
          {
            float32x4_t v400 = *(float32x4_t *)((char *)v488 + 2184);
            float32x4_t v401 = *(float32x4_t *)((char *)v488 + 2200);
            float32x4_t v402 = *(float32x4_t *)((char *)v488 + 2232);
            v398[2] = *(float32x4_t *)((char *)v488 + 2216);
            v398[3] = v402;
            float32x4_t *v398 = v400;
            v398[1] = v401;
          }
          else
          {
            CA::Mat4Impl::mat4_concat(v398, v403, (const double *)v488 + 273, v399);
          }
          *((_DWORD *)v488 + 842) = *((_DWORD *)v488 + 64);
        }
        if ((v385 & 0x80) != 0 || (v385 & 0x60) == 0 && (*(_WORD *)((unsigned char *)&v492 + 3) & 0x202) != 0)
        {
          uint64_t v404 = *((void *)v19 + 2);
          uint64_t v406 = *(void *)(v404 + 64);
          uint64_t v407 = *(void *)(v404 + 72);
          v405 = (void *)(v404 + 64);
          BOOL v408 = *((void *)v19 + 470) == v406 && *((void *)v19 + 471) == v407;
          BOOL v409 = v408 && *((void *)v19 + 472) == v405[2];
          if (!v409 || *((void *)v19 + 473) != v405[3])
          {
            int v411 = CA::OGL::MetalBufferPool::encode_vertex_arg(*((CA::OGL::MetalBufferPool **)v19 + 505), 4, v405, 0x20u, 0x10u);
            uint64_t v19 = v488;
            if (!v411) {
              return;
            }
            uint64_t v412 = *((void *)v488 + 2);
            long long v413 = *(_OWORD *)(v412 + 80);
            *((_OWORD *)v488 + 235) = *(_OWORD *)(v412 + 64);
            *((_OWORD *)v488 + 236) = v413;
          }
        }
        v414 = a10;
        if (a11)
        {
          if (v477 == 3) {
            uint64_t v415 = 1;
          }
          else {
            uint64_t v415 = 2;
          }
          v416 = (float64x2_t *)*((void *)v19 + 102);
          v490[0] = &unk_1ED030D68;
          v490[1] = v19;
          v490[3] = v490;
          int v417 = CA::OGL::clip_primitives(v415, a3, (uint64_t)a10, (uint64_t)__src, 0, a11, v416, 0, 0, (uint64_t)v490, 1u);
          std::__function::__value_func<BOOL ()(CA::OGL::Vertex *,unsigned int)>::~__value_func[abi:nn180100](v490);
          if (!v417) {
            return;
          }
          ++*((_DWORD *)v19 + 64);
          goto LABEL_650;
        }
        if (v475)
        {
          unsigned int v418 = a9 + v473;
          if (a10 && v477 == 3 && v418 > a3)
          {
            v419 = (char *)CA::OGL::MetalBufferPool::alloc_vertex_arg(*((void *)v19 + 505), 1, v475 * a3, 0x10u);
            if (!v419) {
              return;
            }
            if (a3)
            {
              uint64_t v420 = a3;
              do
              {
                unsigned int v421 = *v414++;
                memcpy(v419, &__src[v421 * v475], v475);
                v419 += v475;
                --v420;
              }
              while (v420);
            }
            goto LABEL_648;
          }
          if (!CA::OGL::MetalBufferPool::encode_vertex_arg(*((CA::OGL::MetalBufferPool **)v19 + 505), 1, __src, v418 * v475, v472))return; {
        }
          }
        else
        {
          uint64_t v422 = *((void *)v19 + 505);
          uint64_t v423 = *((void *)__src + 4);
          uint64_t v424 = *(void *)(v422 + 192);
          if (*(void *)(v422 + 72) == v423)
          {
            (*(void (**)(uint64_t, char *, void, uint64_t))(v422 + 216))(v424, sel_setVertexBufferOffset_atIndex_, *((unsigned int *)__src + 10), 1);
          }
          else
          {
            (*(void (**)(uint64_t, char *, void, void, uint64_t))(v422 + 200))(v424, sel_setVertexBuffer_offset_atIndex_, *((void *)__src + 4), *((unsigned int *)__src + 10), 1);
            *(void *)(v422 + 72) = v423;
          }
        }
        if (!a10)
        {
LABEL_648:
          (*((void (**)(void, char *, uint64_t, void, void, void))v488 + 380))(*((void *)v488 + 373), sel_drawPrimitives_vertexStart_vertexCount_instanceCount_, v477, 0, a3, v474);
          goto LABEL_649;
        }
        if (v474 != 1) {
          __assert_rtn("encode_draw", "ogl-metal.mm", 9702, "instance_count == 1");
        }
        uint64_t v425 = *((void *)v488 + 505);
        size_t v426 = 2 * a3;
        uint64_t v427 = *(void *)(v425 + 8);
        if (v427)
        {
          if (*(_DWORD *)(v425 + 44) <= 4u) {
            int v428 = 4;
          }
          else {
            int v428 = *(_DWORD *)(v425 + 44);
          }
          int v429 = *(_DWORD *)(v425 + 24);
          unsigned int v430 = *(_DWORD *)(v425 + 28);
          unsigned int v431 = (v428 + v429 - 1) & -v428;
          _CF = v430 != v431 && v430 >= v431 + v426;
          if (_CF || !v429)
          {
LABEL_647:
            memcpy((void *)(*(void *)(v425 + 32) + v431), a10, v426);
            *(_DWORD *)(v425 + 24) = v431 + v426;
            (*(void (**)(void, char *, uint64_t, void, void, void, void))(v425 + 232))(*(void *)(v425 + 192), sel_drawIndexedPrimitives_indexCount_indexType_indexBuffer_indexBufferOffset_, v477, a3, 0, *(void *)(v425 + 8), v431);
LABEL_649:
            uint64_t v19 = v488;
LABEL_650:
            ++*((_DWORD *)v19 + 177);
            if (v382) {
              ++*((_DWORD *)v19 + 181);
            }
            if (BYTE3(xmmword_1EB2ACC70))
            {
              os_signpost_id_t v469 = *((unsigned int *)v19 + 57);
              if (v469)
              {
                v470 = CA::OGL::MetalContext::_metal_trace_log;
                if (os_signpost_enabled((os_log_t)CA::OGL::MetalContext::_metal_trace_log))
                {
                  v471 = CA::OGL::MetalContext::TextureFunction_codes[BYTE6(v493[1]) & 0x7F];
                  buf[0] = 136446466;
                  *(void *)&buf[1] = v471;
                  LOWORD(buf[3]) = 1026;
                  *(_DWORD *)((char *)&buf[3] + 2) = a3;
                  _os_signpost_emit_with_name_impl(&dword_184668000, v470, OS_SIGNPOST_EVENT, v469, "Draw", "ID is update texture_function=%{public,name=texture_function}s draw_count=%{public,name=draw_count}d", (uint8_t *)buf, 0x12u);
                }
              }
            }
            CA::OGL::Context::marked_destination(v19);
            return;
          }
          CA::OGL::MetalBufferPool::retire_metal_buffer(*((void *)v488 + 505), v427);
          *(void *)(v425 + 8) = 0;
          *(void *)(v425 + 24) = 0;
          *(void *)(v425 + 32) = 0;
        }
        buffer = CA::OGL::MetalBufferPool::allocate_buffer((os_unfair_lock_s *)v425, v426);
        *(void *)(v425 + 8) = buffer;
        if (!buffer) {
          return;
        }
        ++*(_DWORD *)(v425 + 40);
        *(void *)(v425 + 32) = [buffer contents];
        unsigned int v431 = 0;
        *(_DWORD *)(v425 + 28) = [*(id *)(v425 + 8) length];
        goto LABEL_647;
      }
    }
  }
}

uint64_t CA::OGL::state_image_texture_unit(uint64_t result, int a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t v2 = result;
  uint64_t v3 = 0;
  LODWORD(result) = 0;
  do
  {
    int8x8_t result = result + CA::OGL::image_plane_count[*(unsigned __int8 *)(v2 + v3 + 17)];
    uint64_t v4 = *(void *)(v2 + 8 * v3 + 40);
    if (v4)
    {
      uint64_t v5 = *(void *)(v4 + 80);
      BOOL v6 = v5 == 0;
      BOOL v7 = v5 != 0;
      int v8 = *(_DWORD *)(v4 + 56);
      if (v6) {
        int v9 = 1;
      }
      else {
        int v9 = 2;
      }
      if (v8) {
        int v10 = v9;
      }
      else {
        int v10 = v7;
      }
      int8x8_t result = (v10 + result);
    }
    ++v3;
  }
  while (a2 != v3);
  return result;
}

uint64_t CA::OGL::MetalBufferPool::encode_vertex_arg(CA::OGL::MetalBufferPool *this, uint64_t a2, const void *__src, unsigned int a4, unsigned int a5)
{
  if ((a5 & (a5 - 1)) != 0) {
    __assert_rtn("get_buffer", "ogl-metal.mm", 3197, "x_power_of_two (alignment)");
  }
  uint64_t v9 = *((void *)this + 1);
  if (v9)
  {
    unsigned int v10 = *((_DWORD *)this + 11);
    if (v10 <= a5) {
      unsigned int v10 = a5;
    }
    int v11 = *((_DWORD *)this + 6);
    unsigned int v12 = *((_DWORD *)this + 7);
    unsigned int v13 = (v10 + v11 - 1) & -v10;
    if (v12 != v13 && v12 >= v13 + a4 || v11 == 0) {
      goto LABEL_15;
    }
    int v16 = (void *)((char *)this + 24);
    CA::OGL::MetalBufferPool::retire_metal_buffer((uint64_t)this, v9);
    *((void *)this + 1) = 0;
    *int v16 = 0;
    *((void *)this + 4) = 0;
  }
  uint64_t result = (uint64_t)CA::OGL::MetalBufferPool::allocate_buffer((os_unfair_lock_s *)this, a4);
  *((void *)this + 1) = result;
  if (!result) {
    return result;
  }
  ++*((_DWORD *)this + 10);
  *((void *)this + 4) = [(id)result contents];
  unsigned int v13 = 0;
  *((_DWORD *)this + 7) = [*((id *)this + 1) length];
LABEL_15:
  if (__src) {
    memcpy((void *)(*((void *)this + 4) + v13), __src, a4);
  }
  *((_DWORD *)this + 6) = v13 + a4;
  uint64_t v18 = *((void *)this + 1);
  uint64_t v19 = (char *)this + 8 * a2;
  uint64_t v21 = *((void *)v19 + 8);
  uint64_t v20 = v19 + 64;
  uint64_t v22 = *((void *)this + 24);
  if (v21 == v18)
  {
    (*((void (**)(uint64_t, char *, void, uint64_t))this + 27))(v22, sel_setVertexBufferOffset_atIndex_, v13, a2);
  }
  else
  {
    (*((void (**)(uint64_t, char *, void, void, uint64_t))this + 25))(v22, sel_setVertexBuffer_offset_atIndex_, *((void *)this + 1), v13, a2);
    void *v20 = v18;
  }
  return 1;
}

uint64_t CA::OGL::MetalContext::start_render_encoder(CA::OGL::MetalContext *this)
{
  LOBYTE(v2) = 0;
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  uint64_t v41 = sel_drawPrimitives_vertexStart_vertexCount_instanceCount_;
  uint64_t v3 = (char *)this + 3960;
  for (uint64_t i = *((void *)this + 373); ; uint64_t i = 0)
  {
    if (i && (uint64_t v5 = *((void *)this + 499)) != 0 && *(unsigned __int16 *)(v5 + 216) != *(unsigned __int16 *)(v5 + 214))
    {
      LODWORD(v6) = 1;
    }
    else
    {
      uint64_t v6 = *((void *)this + 2);
      if (v6) {
        LODWORD(v6) = (*(unsigned __int8 *)(v6 + 481) >> 2) & 1;
      }
    }
    uint64_t v7 = *((void *)this + 33);
    int v8 = (_DWORD *)*((void *)this + 505);
    unsigned int v9 = (*((_WORD *)this + 416) & 1) != 0 ? 2 : 8;
    unsigned int v10 = v8[10];
    if (v10 <= v9)
    {
      if (v10 != v9) {
        goto LABEL_17;
      }
      BOOL v11 = v8[6] > (v8[7] - (v8[7] >> 4));
    }
    else
    {
      BOOL v11 = 1;
    }
    if (((!v11 | v6) & 1) == 0)
    {
      CA::OGL::MetalContext::flush(this, 0);
      uint64_t i = *((void *)this + 373);
    }
LABEL_17:
    if (i) {
      return 1;
    }
    char v42 = v2;
    uint64_t v12 = *((void *)this + 499);
    if (v12) {
      BOOL v13 = *(void *)(v7 + 200) == v12;
    }
    else {
      BOOL v13 = 0;
    }
    if (v13) {
      uint64_t v14 = *((void *)this + 499);
    }
    else {
      uint64_t v14 = v7;
    }
    unsigned int v15 = *(unsigned __int16 *)(v14 + 75);
    if ((v15 & 0x20) != 0) {
      uint64_t v16 = 2;
    }
    else {
      uint64_t v16 = (v15 >> 7) & 1;
    }
    if ((__int16)(*(_WORD *)(v7 + 232) << 12) >= 1)
    {
      uint64_t v17 = 0;
      do
      {
        unint64_t v18 = *((void *)this + 33);
        if (v18) {
          unint64_t v18 = ((unint64_t)*(unsigned __int8 *)(v18 + 72) >> 1) & 0x1F;
        }
        int v19 = *(unsigned __int16 *)(v7 + 214);
        BOOL v20 = ((1 << v17) & v19) == 0;
        if (((1 << v17) & v19) != 0) {
          uint64_t v21 = 0;
        }
        else {
          uint64_t v21 = v16;
        }
        if (v20) {
          unint64_t v22 = v18;
        }
        else {
          unint64_t v22 = 0;
        }
        if (((v17 == 2) & ((*(_DWORD *)(v7 + 68) & 0x2000u) >> 13)) != 0) {
          uint64_t v23 = 2;
        }
        else {
          uint64_t v23 = v21;
        }
        char v24 = *(void **)&v3[8 * v17];
        objc_msgSend(v24, "setLoadAction:", v23, v41);
        [v24 setLevel:v22];
        ++v17;
      }
      while (v17 < *(unsigned __int16 *)(v7 + 232) << 28 >> 28);
    }
    [*((id *)this + 494) setFineGrainedBackgroundVisibilityEnabled:*(_WORD *)(v7 + 214) != 0];
    CA::OGL::MetalContext::stop_encoders(this);
    if ((CA::OGL::MetalContext::start_command_buffer(this, *((void *)this + 386), v25) & 1) == 0) {
      return 0;
    }
    id v26 = (id)[*((id *)this + 372) renderCommandEncoderWithDescriptor:*((void *)this + 494)];
    *((void *)this + 373) = v26;
    if (!v26) {
      break;
    }
    if (BYTE3(xmmword_1EB2ACC70))
    {
      uint64_t v27 = mach_continuous_time();
      id v26 = (id)*((void *)this + 373);
    }
    else
    {
      uint64_t v27 = 0;
    }
    *((void *)this + 388) = v27;
    ++*((_DWORD *)this + 736);
    *((void *)this + 376) = objc_msgSend(v26, "methodForSelector:", sel_setRenderPipelineState_, v41);
    *((void *)this + 377) = [*((id *)this + 373) methodForSelector:sel_setFragmentTexture_atIndex_];
    *((void *)this + 378) = [*((id *)this + 373) methodForSelector:sel_setFragmentSamplerState_atIndex_];
    *((void *)this + 379) = [*((id *)this + 373) methodForSelector:sel_setScissorRect_];
    *((void *)this + 380) = [*((id *)this + 373) methodForSelector:v41];
    CA::OGL::MetalBufferPool::set_encoder(*((void *)this + 505), *((objc_object **)this + 373));
    __int16 v28 = *(_WORD *)(v7 + 75);
    *(_WORD *)(v7 + 75) = v28 | 0x80;
    int v29 = *(_DWORD *)(v7 + 68);
    if ((v28 & 0x20) != 0 && (v29 & 0x800) == 0)
    {
      *(_WORD *)(v7 + 75) = v28 & 0xFF1F | 0xC0;
      *(void *)(v7 + 192) = *(void *)(v7 + 184);
    }
    if ((v29 & 0x40) != 0) {
      *(_WORD *)(v7 + 232) |= 0x100u;
    }
    uint64_t v30 = *((void *)this + 103);
    if (v30)
    {
      int v31 = *(_DWORD *)(v30 + 300) & 0x1FFFF;
      *((_DWORD *)this + 778) = v31;
      *((void *)this + 390) = 0;
      *((_DWORD *)this + 782) = 0;
      if (BYTE3(xmmword_1EB2ACC70))
      {
        unsigned int v35 = *(CA::Render::Object **)(v30 + 24);
        if (v35) {
          *((void *)this + 390) = CA::Render::Object::render_id(v35);
        }
        uint64_t v36 = *(void *)(v30 + 16);
        if (v36)
        {
          uint64_t v37 = *(void *)(v36 + 40);
          if (v37)
          {
            uint64_t v38 = *(void *)(v37 + 24);
            if (v38) {
              LODWORD(v38) = *(_DWORD *)(v38 + 16);
            }
            *((_DWORD *)this + 782) = v38;
          }
        }
      }
      if (v31) {
        char v32 = @"com.apple.coreanimation.offscreen-encoder";
      }
      else {
        char v32 = @"com.apple.coreanimation.assembly-encoder";
      }
    }
    else
    {
      *((_DWORD *)this + 778) = 0;
      *((void *)this + 390) = 0;
      char v32 = @"com.apple.coreanimation.assembly-encoder";
      *((_DWORD *)this + 782) = 0;
    }
    [*((id *)this + 373) setLabel:v32];
    CA::OGL::MetalContext::update_encoder_state((uint64_t)this, v7, 0, v33, v34);
    if (v42) {
      return 1;
    }
    if (v16 != 1)
    {
      CA::OGL::Context::marked_destination(this);
      if ((v15 & 0x20) != 0) {
        *(_WORD *)(v7 + 75) |= 0x40u;
      }
    }
    uint64_t v2 = 1;
    if (*((void *)this + 373)) {
      return v2;
    }
  }
  if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    int v40 = x_log_category_ogl_metal;
    if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_184668000, v40, OS_LOG_TYPE_ERROR, "Unable to start render command encoder\n", buf, 2u);
    }
  }
  return 0;
}

void CA::OGL::Context::marked_destination(CA::OGL::Context *this)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  *((_WORD *)this + 416) |= 0x880u;
  uint64_t v1 = *((void *)this + 33);
  if (v1)
  {
    CA::OGL::Context::marked_surface((uint64_t)this, v1);
  }
  else
  {
    if (*((_DWORD *)this + 115)) {
      BOOL v2 = BYTE1(xmmword_1EB2ACBF0) == 0;
    }
    else {
      BOOL v2 = 1;
    }
    if (!v2)
    {
      long long v4 = 0u;
      long long v5 = 0u;
      memset(v3, 0, 32);
      v3[2] = *(_OWORD *)((char *)this + 200);
      long long v4 = 0uLL;
      *(void *)&long long v5 = 0;
      BYTE8(v5) = 1;
      *(_WORD *)((char *)&v5 + 11) = 128;
      CA::OGL::export_surface((uint64_t)this, (uint64_t)v3, "dest");
    }
  }
}

void CA::OGL::Context::marked_surface(uint64_t a1, uint64_t a2)
{
  *(_WORD *)(a2 + 75) = *(_WORD *)(a2 + 75) & 0xFF3F | 0x80;
  uint64_t v2 = *(void *)(a1 + 216);
  if (v2) {
    *(_DWORD *)(a2 + 4) = *(_DWORD *)(v2 + 248);
  }
  if (*(_DWORD *)(a1 + 460)) {
    BOOL v3 = BYTE1(xmmword_1EB2ACBF0) == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3) {
    CA::OGL::export_surface(a1, a2, "surf");
  }
}

void *std::__hash_table<std::__hash_value_type<CA::OGL::MetalContext::Pipeline::Spec,CA::OGL::MetalContext::Pipeline*>,std::__unordered_map_hasher<CA::OGL::MetalContext::Pipeline::Spec,std::__hash_value_type<CA::OGL::MetalContext::Pipeline::Spec,CA::OGL::MetalContext::Pipeline*>,CA::OGL::MetalContext::StructHasher<CA::OGL::MetalContext::Pipeline::Spec>,std::equal_to<CA::OGL::MetalContext::Pipeline::Spec>,true>,std::__unordered_map_equal<CA::OGL::MetalContext::Pipeline::Spec,std::__hash_value_type<CA::OGL::MetalContext::Pipeline::Spec,CA::OGL::MetalContext::Pipeline*>,std::equal_to<CA::OGL::MetalContext::Pipeline::Spec>,CA::OGL::MetalContext::StructHasher<CA::OGL::MetalContext::Pipeline::Spec>,true>,std::allocator<std::__hash_value_type<CA::OGL::MetalContext::Pipeline::Spec,CA::OGL::MetalContext::Pipeline*>>>::find<CA::OGL::MetalContext::Pipeline::Spec>(void *a1, void *a2)
{
  unint64_t v4 = CA::OGL::MetalContext::StructHasher<CA::OGL::MetalContext::Pipeline::Spec>::operator()((uint64_t)a2);
  int8x8_t v5 = (int8x8_t)a1[1];
  if (!*(void *)&v5) {
    return 0;
  }
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v5);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = v4;
    if (v4 >= *(void *)&v5) {
      unint64_t v7 = v4 % *(void *)&v5;
    }
  }
  else
  {
    unint64_t v7 = (*(void *)&v5 - 1) & v4;
  }
  uint64_t i = *(void **)(*a1 + 8 * v7);
  if (i)
  {
    for (uint64_t i = (void *)*i; i; uint64_t i = (void *)*i)
    {
      unint64_t v9 = i[1];
      if (v9 == v4)
      {
        if (i[2] == *a2 && i[3] == a2[1] && i[4] == a2[2] && i[5] == a2[3]) {
          return i;
        }
      }
      else
      {
        if (v6.u32[0] > 1uLL)
        {
          if (v9 >= *(void *)&v5) {
            v9 %= *(void *)&v5;
          }
        }
        else
        {
          v9 &= *(void *)&v5 - 1;
        }
        if (v9 != v7) {
          return 0;
        }
      }
    }
  }
  return i;
}

unint64_t CA::OGL::MetalContext::StructHasher<CA::OGL::MetalContext::Pipeline::Spec>::operator()(uint64_t a1)
{
  uint64_t v1 = 0;
  unint64_t v2 = 0xB492B66FBE98F273;
  do
  {
    unint64_t v2 = 5
       * __ROR8__((461845907* ((0xCBE41013C0000000 * *(void *)(a1 + v1)) | ((0x9AE16A3B2F90404FLL * *(void *)(a1 + v1)) >> 34))) ^ v2, 38)+ 3864292196;
    v1 += 8;
  }
  while (v1 != 32);
  unint64_t v3 = (0xBF58476D1CE4E5B9 * (v2 ^ (v2 >> 30) ^ 0x20)) ^ ((0xBF58476D1CE4E5B9 * (v2 ^ (v2 >> 30) ^ 0x20)) >> 27);
  return (0x94D049BB133111EBLL * v3) ^ ((0x94D049BB133111EBLL * v3) >> 31);
}

uint64_t CA::OGL::MetalContext::Pipeline::Spec::lift_blend_function(uint64_t this)
{
  __int16 v1 = *(_WORD *)(this + 17);
  if ((v1 & 4) != 0) {
    __assert_rtn("lift_blend_function", "ogl-metal.mm", 5838, "!fragment.generic");
  }
  __int16 v2 = *(unsigned __int8 *)(this + 15);
  int v3 = v2 & 0x3F;
  if (v3 == 3 || v3 == 58) {
    goto LABEL_4;
  }
  uint64_t v6 = *(_WORD *)(this + 24) & 0x3FF;
  if ((*(_WORD *)(this + 17) & 0x440) == 0 && v3 == 56 && v6 != 115 && v6 != 125)
  {
    __int16 v2 = v2 & 0xC0 | 0xC;
    *(unsigned char *)(this + 15) = v2;
  }
  if ((v6 != 125 && v6 != 115 || (CA::OGL::MetalContext::blend_function_info[v2 & 0x3F] & 0x10) == 0)
    && (v2 & 0x3Eu) <= 0x19)
  {
    if ((v1 & 0x400) != 0)
    {
      unsigned int v7 = v2 & 0x3F;
      if (v7 == 12 || (CA::OGL::MetalContext::blend_function_info[v2 & 0x3F] & 8) != 0) {
        return this;
      }
    }
    else if (v6 == 115 || v6 == 125)
    {
      unsigned int v7 = v2 & 0x3F;
      if (v7 == 12) {
        return this;
      }
    }
    else
    {
      unsigned int v7 = v2 & 0x3F;
    }
    if (v7 && ((*(unsigned char *)(this + 16) & 7) == 0 || (CA::OGL::MetalContext::blend_function_info[v7] & 1) == 0))
    {
LABEL_4:
      if ((*(_WORD *)&CA::OGL::MetalContext::texture_function_info[8 * (*(unsigned char *)(this + 14) & 0x7F)
                                                                  - (*(unsigned char *)(this + 14) & 0x7F)
                                                                  + 5] & 8) == 0)
      {
        int v4 = *(unsigned __int16 *)(this + 24);
        this += 24;
        unsigned int v5 = v4 & 0xFFFF03FF | (*(unsigned __int8 *)(this + 2) << 16);
        *(_WORD *)this = v4 & 0x3FF | (v2 << 10);
        *(unsigned char *)(this + 2) = BYTE2(v5);
        *(unsigned char *)(this - 9) = v2 & 0xC0 | 0x3A;
      }
    }
  }
  return this;
}

void CA::OGL::MetalContext::Pipeline::wait_for_completion(CA::OGL::MetalContext::Pipeline *this)
{
  __int16 v2 = (void *)*((void *)this + 1);
  if (v2)
  {
    dispatch_block_wait(v2, 0xFFFFFFFFFFFFFFFFLL);
    _Block_release(*((const void **)this + 1));
    *((void *)this + 1) = 0;
  }
}

uint64_t CA::OGL::MetalContext::unbind_surface_impl(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(a2 + 208) = *(_DWORD *)(result + 2944);
  return result;
}

double CA::OGL::MetalContext::update_encoder_state(uint64_t a1, uint64_t a2, int a3, double a4, double a5)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  unsigned int v7 = *(void **)(a1 + 2984);
  if (v7)
  {
    v16[0] = 0;
    v16[1] = 0;
    uint64_t v8 = 28;
    if ((*(_WORD *)(a2 + 232) & 0x400) == 0) {
      uint64_t v8 = 24;
    }
    int v9 = *(_DWORD *)(a2 + v8);
    uint64_t v10 = *(void *)(a1 + 264);
    if (v10)
    {
      int v11 = *(unsigned __int8 *)(v10 + 72) >> 1;
      LOBYTE(v10) = v11 & 0x1F;
      v9 >>= v11;
    }
    uint64_t v12 = 24;
    if ((*(_WORD *)(a2 + 232) & 0x400) == 0) {
      uint64_t v12 = 28;
    }
    double v13 = (double)(*(int *)(a2 + v12) >> v10);
    *(double *)&v16[2] = (double)v9;
    *(double *)&v16[3] = v13;
    long long v17 = xmmword_184997D60;
    [v7 setViewport:v16];
    *(_DWORD *)(a1 + 3296) |= 2u;
  }
  if ((a3 & 4) != 0)
  {
    [*(id *)(a1 + 2984) setFrontFacingWinding:0];
    if ((a3 & 8) == 0)
    {
LABEL_11:
      if ((a3 & 0x20) == 0) {
        goto LABEL_12;
      }
      goto LABEL_20;
    }
  }
  else if ((a3 & 8) == 0)
  {
    goto LABEL_11;
  }
  [*(id *)(a1 + 2984) setCullMode:0];
  if ((a3 & 0x20) == 0)
  {
LABEL_12:
    if ((a3 & 0x80) == 0) {
      goto LABEL_13;
    }
    goto LABEL_21;
  }
LABEL_20:
  LODWORD(a5) = 1.0;
  [*(id *)(a1 + 2984) setDepthBias:0.0 slopeScale:a5 clamp:0.0];
  if ((a3 & 0x80) == 0)
  {
LABEL_13:
    if ((a3 & 0x100) == 0) {
      goto LABEL_14;
    }
    goto LABEL_22;
  }
LABEL_21:
  [*(id *)(a1 + 2984) setTriangleFillMode:0];
  if ((a3 & 0x100) == 0)
  {
LABEL_14:
    if ((a3 & 0x200) == 0) {
      goto LABEL_15;
    }
LABEL_23:
    [*(id *)(a1 + 2984) setDepthStencilState:*(void *)(a1 + 3984)];
    if ((a3 & 0x400) == 0) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }
LABEL_22:
  [*(id *)(a1 + 2984) setBlendColorRed:0.0 green:0.0 blue:0.0 alpha:0.0];
  if ((a3 & 0x200) != 0) {
    goto LABEL_23;
  }
LABEL_15:
  if ((a3 & 0x400) != 0) {
LABEL_16:
  }
    [*(id *)(a1 + 2984) setVisibilityResultMode:0 offset:0];
LABEL_17:
  *(_DWORD *)(a1 + 3296) |= a3;
  *(_DWORD *)(a1 + 3368) = -1;
  *(void *)(a1 + 3360) = 0;
  char v14 = *(unsigned char *)(a1 + 3408);
  *(_DWORD *)(a1 + 3424) = 2143289344;
  *(_DWORD *)(a1 + 3800) = 2143289344;
  *(void *)(a1 + 3412) = 0x7FC000007FC00000;
  *(unsigned char *)(a1 + 3744) = 9;
  *(_DWORD *)(a1 + 3760) = 2143289344;
  *(void *)(a1 + 3792) = -1;
  double result = 0.0;
  *(_OWORD *)(a1 + 3808) = 0u;
  *(_OWORD *)(a1 + 3824) = 0u;
  *(_OWORD *)(a1 + 3840) = 0u;
  *(_OWORD *)(a1 + 3856) = 0u;
  *(_OWORD *)(a1 + 3872) = 0u;
  *(_OWORD *)(a1 + 3888) = 0u;
  *(_OWORD *)(a1 + 3904) = 0u;
  *(_OWORD *)(a1 + 3920) = 0u;
  *(void *)(a1 + 3936) = 0;
  *(unsigned char *)(a1 + 3408) = v14 & 0xE0;
  *(unsigned char *)(a1 + 65) = *(unsigned char *)(a1 + 65) & 0xFE | ((a3 & 0x40) != 0);
  *(_DWORD *)(a1 + 48) = -1;
  return result;
}

uint64_t CA::OGL::MetalContext::encode_noise_texture(CA::OGL::MetalContext *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const unsigned __int8 *a6, BOOL a7, const char *a8)
{
  if (!*((void *)this + 485))
  {
    uint64_t v9 = *((void *)this + 357);
    if (v9)
    {
      uint64_t v10 = 0;
    }
    else
    {
      uint64_t result = CA::OGL::MetalContext::create_texture((id *)this, 80, 1uLL, (MTLPixelFormat)&noise_data, (uint64_t)"noise", a6, a7, a8);
      *((void *)this + 357) = result;
      if (!result) {
        return result;
      }
      *(_WORD *)(result + 123) &= ~8u;
      *(_DWORD *)(*((void *)this + 357) + 52) &= 0xFF0FFFFF;
      *(_DWORD *)(*((void *)this + 357) + 52) &= 0xFFF0FFFF;
      uint64_t v9 = *((void *)this + 357);
      uint64_t v10 = *((void *)this + 485);
    }
    uint64_t v12 = *(void *)(v9 + 64);
    if (v10 != v12)
    {
      *((void *)this + 485) = v12;
      (*((void (**)(void, char *))this + 377))(*((void *)this + 373), sel_setFragmentTexture_atIndex_);
    }
  }
  return 1;
}

uint64_t CA::OGL::MetalContext::encode_gamma_luts(CA::OGL::MetalContext *this)
{
  char v1 = *((unsigned char *)this + 3408);
  if ((v1 & 4) == 0)
  {
    uint64_t v3 = *((void *)this + 506);
    if (!v3)
    {
      uint64_t result = (uint64_t)CA::OGL::create_gamma_lut_buffer(*((void **)this + 369));
      *((void *)this + 506) = result;
      if (!result) {
        return result;
      }
      uint64_t v3 = result;
      char v1 = *((unsigned char *)this + 3408);
    }
    *((unsigned char *)this + 3408) = v1 | 4;
    [*((id *)this + 373) setFragmentBuffer:v3 offset:0 atIndex:7];
  }
  return 1;
}

uint64_t CA::OGL::MetalContext::encode_placeholder_texture(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)(a1 + 2912);
  if (!v4)
  {
    unsigned int v5 = objc_msgSend(*(id *)(a1 + 2952), "newTextureWithDescriptor:", objc_msgSend(MEMORY[0x1E4F35330], "texture2DDescriptorWithPixelFormat:width:height:mipmapped:", 80, 1, 1, 0));
    *(void *)(a1 + 2912) = v5;
    [v5 setLabel:@"com.apple.coreanimation.placeholder-texture"];
    uint64_t v4 = *(void *)(a1 + 2912);
    if (!v4) {
      return 0;
    }
  }
  uint64_t v6 = a1 + 8 * a2;
  if (*(void *)(v6 + 3808) != v4)
  {
    *(void *)(v6 + 3808) = v4;
    (*(void (**)(void, char *))(a1 + 3016))(*(void *)(a1 + 2984), sel_setFragmentTexture_atIndex_);
  }
  return 1;
}

uint64_t CA::OGL::MetalContext::encode_placeholder_cube(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)(a1 + 2920);
  if (!v4)
  {
    unsigned int v5 = (void *)[MEMORY[0x1E4F35330] texture2DDescriptorWithPixelFormat:80 width:1 height:1 mipmapped:0];
    [v5 setTextureType:7];
    uint64_t v6 = (void *)[*(id *)(a1 + 2952) newTextureWithDescriptor:v5];
    *(void *)(a1 + 2920) = v6;
    [v6 setLabel:@"com.apple.coreanimation.placeholder-cube"];
    uint64_t v4 = *(void *)(a1 + 2920);
    if (!v4) {
      return 0;
    }
  }
  uint64_t v7 = a1 + 8 * a2;
  if (*(void *)(v7 + 3808) != v4)
  {
    *(void *)(v7 + 3808) = v4;
    (*(void (**)(void, char *))(a1 + 3016))(*(void *)(a1 + 2984), sel_setFragmentTexture_atIndex_);
  }
  return 1;
}

float64x2_t CA::Mat4Impl::mat4_concat(float32x4_t *this, float *a2, const double *a3, const float *a4)
{
  float64x2_t v4 = *(float64x2_t *)(a2 + 4);
  float64x2_t v6 = *(float64x2_t *)(a2 + 8);
  float64x2_t v5 = *(float64x2_t *)(a2 + 12);
  float64x2_t v8 = *(float64x2_t *)(a2 + 16);
  float64x2_t v7 = *(float64x2_t *)(a2 + 20);
  float64x2_t v10 = *(float64x2_t *)(a2 + 24);
  float64x2_t v9 = *(float64x2_t *)(a2 + 28);
  float32x4_t v11 = *(float32x4_t *)(a3 + 2);
  float64x2_t v12 = vcvt_hight_f64_f32(*(float32x4_t *)a3);
  float64x2_t v13 = vcvtq_f64_f32(*(float32x2_t *)a3);
  float64x2_t v14 = vmulq_n_f64(v13, *(double *)a2);
  float64x2_t v15 = vmulq_n_f64(v12, *(double *)a2);
  float64x2_t v16 = vmulq_n_f64(v13, v6.f64[0]);
  float64x2_t v17 = vmulq_n_f64(v12, v6.f64[0]);
  float64x2_t v18 = vmulq_n_f64(v13, v8.f64[0]);
  float64x2_t v19 = vmulq_n_f64(v12, v8.f64[0]);
  float64x2_t v20 = vmulq_n_f64(v13, v10.f64[0]);
  float64x2_t v21 = vmulq_n_f64(v12, v10.f64[0]);
  float64x2_t v22 = vcvt_hight_f64_f32(v11);
  float64x2_t v23 = vcvtq_f64_f32(*(float32x2_t *)v11.f32);
  float64x2_t v24 = vmlaq_laneq_f64(v16, v23, v6, 1);
  float64x2_t v25 = vmlaq_laneq_f64(v17, v22, v6, 1);
  float64x2_t v26 = vmlaq_laneq_f64(v18, v23, v8, 1);
  float64x2_t v27 = vmlaq_laneq_f64(v19, v22, v8, 1);
  float32x4_t v28 = *(float32x4_t *)(a3 + 4);
  float32x4_t v29 = *(float32x4_t *)(a3 + 6);
  float64x2_t v30 = vcvt_hight_f64_f32(v28);
  float64x2_t v31 = vcvtq_f64_f32(*(float32x2_t *)v28.f32);
  float64x2_t v32 = vmlaq_n_f64(vmlaq_laneq_f64(v14, v23, *(float64x2_t *)a2, 1), v31, v4.f64[0]);
  float64x2_t v33 = vmlaq_n_f64(v24, v31, v5.f64[0]);
  float64x2_t v34 = vmlaq_n_f64(v26, v31, v7.f64[0]);
  float64x2_t v35 = vmlaq_n_f64(vmlaq_laneq_f64(v20, v23, v10, 1), v31, v9.f64[0]);
  float64x2_t v36 = vcvt_hight_f64_f32(v29);
  float64x2_t v37 = vcvtq_f64_f32(*(float32x2_t *)v29.f32);
  float64x2_t result = vmlaq_laneq_f64(vmlaq_n_f64(vmlaq_laneq_f64(v21, v22, v10, 1), v30, v9.f64[0]), v36, v9, 1);
  *this = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmlaq_laneq_f64(v32, v37, v4, 1)), vmlaq_laneq_f64(vmlaq_n_f64(vmlaq_laneq_f64(v15, v22, *(float64x2_t *)a2, 1), v30, v4.f64[0]), v36, v4, 1));
  this[1] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmlaq_laneq_f64(v33, v37, v5, 1)), vmlaq_laneq_f64(vmlaq_n_f64(v25, v30, v5.f64[0]), v36, v5, 1));
  this[2] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmlaq_laneq_f64(v34, v37, v7, 1)), vmlaq_laneq_f64(vmlaq_n_f64(v27, v30, v7.f64[0]), v36, v7, 1));
  this[3] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmlaq_laneq_f64(v35, v37, v9, 1)), result);
  return result;
}

uint64_t CA::OGL::MetalContext::Pipeline::Spec::get_generic(uint64_t result, uint64_t a2)
{
  *(_OWORD *)float64x2_t result = 0u;
  *(_OWORD *)(result + 16) = 0u;
  if ((CA::OGL::MetalContext::texture_function_info[8 * (*(unsigned char *)(a2 + 14) & 0x7F) - (*(unsigned char *)(a2 + 14) & 0x7F)] & 0x3F) != 0) {
    __assert_rtn("get_generic", "ogl-metal.mm", 6086, "texture_function_info[texture_function].is_fixed ()");
  }
  char v2 = *(unsigned char *)(a2 + 16) & 0x60;
  __int16 v3 = *(_WORD *)(a2 + 17) & 0x30 | 0x804;
  *(void *)float64x2_t result = 0;
  *(void *)(result + 7) = 0;
  *(unsigned char *)(result + 15) = 58;
  *(unsigned char *)(result + 16) = v2;
  *(_WORD *)(result + 17) = v3;
  __int16 v4 = *(_WORD *)(a2 + 21);
  if ((v4 & 0x1F) != 0) {
    __assert_rtn("get_generic", "ogl-metal.mm", 6322, "type == VertexShader::Type_Fixed");
  }
  *(_DWORD *)(result + 19) = ((v4 & 0x11F) << 16) | 0x800000;
  *(unsigned char *)(result + 23) = 0;
  int v5 = *(unsigned __int16 *)(a2 + 24) | (*(unsigned __int8 *)(a2 + 26) << 16);
  *(unsigned char *)(result + 26) = BYTE2(v5) & 3;
  *(_WORD *)(result + 24) = v5 & 0x3FF | 0xE800;
  return result;
}

uint64_t CA::OGL::MetalContext::Pipeline::Spec::push_blend_function(uint64_t this)
{
  unsigned int v1 = *(unsigned __int16 *)(this + 24);
  if (v1 >> 10 != 58)
  {
    char v2 = *(unsigned char *)(this + 15);
    if ((v2 & 0x3F) != 0x3A) {
      __assert_rtn("push_blend_function", "ogl-metal.mm", 5910, "fragment.blend_function == OGL_BLEND_NONE");
    }
    int v3 = *(unsigned __int8 *)(this + 26);
    *(unsigned char *)(this + 15) = v2 & 0xC0 | (v1 >> 10);
    *(unsigned char *)(this + 26) = (v1 & 0xFFFF03FF | (v3 << 16)) >> 16;
    *(_WORD *)(this + 24) = v1 & 0x3FF | 0xE800;
  }
  return this;
}

void *CA::OGL::MetalContext::encode_fragment_data(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = *(void *)(a2 + 32);
    uint64_t v4 = *(unsigned int *)(a2 + 40);
    uint64_t v6 = *(void *)(a1 + 184);
    uint64_t v5 = *(void *)(a1 + 192);
    if (v6 == v3)
    {
      float64x2_t v8 = *(uint64_t (**)(uint64_t, char *, uint64_t, uint64_t))(a1 + 224);
      return (void *)v8(v5, sel_setFragmentBufferOffset_atIndex_, v4, 9);
    }
    else
    {
      float64x2_t result = (void *)(*(uint64_t (**)(uint64_t, char *, uint64_t, uint64_t, uint64_t))(a1 + 208))(v5, sel_setFragmentBuffer_offset_atIndex_, v3, v4, 9);
      *(void *)(a1 + 184) = v3;
    }
  }
  else
  {
    return CA::OGL::MetalBufferPool::alloc_fragment_arg(a1, 9, 4u, 4u);
  }
  return result;
}

uint64_t CA::OGL::MetalContext::encode_lut_texture(CA::OGL::MetalContext *this, const CA::OGL::MetalContext::FragmentShader::Spec *a2, char a3)
{
  if ((a3 & 4) != 0
    || (*(_WORD *)&CA::OGL::MetalContext::texture_function_info[8 * (a2 & 0x7F)
                                                              - (a2 & 0x7F)
                                                              + 5] & 0x200) != 0)
  {
    unint64_t v4 = *(void *)(*((void *)this + 2) + 8 * *(unsigned __int8 *)(*((void *)this + 2) + 308) + 176) & 0xFFFFFFFFFFFFFFFCLL;
    unint64_t v5 = atomic_load((unint64_t *)this + 503);
    *(void *)(v4 + 112) = v5;
    uint64_t v6 = *(void *)(v4 + 64);
    if (*((void *)this + 490) != v6)
    {
      *((void *)this + 490) = v6;
      (*((void (**)(void, char *))this + 377))(*((void *)this + 373), sel_setFragmentTexture_atIndex_);
    }
    return 1;
  }
  else
  {
    return CA::OGL::MetalContext::encode_placeholder_cube((uint64_t)this, 0xEu);
  }
}

void *std::__hash_table<std::__hash_value_type<CA::OGL::MetalContext::Pipeline::Spec,CA::OGL::MetalContext::Pipeline*>,std::__unordered_map_hasher<CA::OGL::MetalContext::Pipeline::Spec,std::__hash_value_type<CA::OGL::MetalContext::Pipeline::Spec,CA::OGL::MetalContext::Pipeline*>,CA::OGL::MetalContext::StructHasher<CA::OGL::MetalContext::Pipeline::Spec>,std::equal_to<CA::OGL::MetalContext::Pipeline::Spec>,true>,std::__unordered_map_equal<CA::OGL::MetalContext::Pipeline::Spec,std::__hash_value_type<CA::OGL::MetalContext::Pipeline::Spec,CA::OGL::MetalContext::Pipeline*>,std::equal_to<CA::OGL::MetalContext::Pipeline::Spec>,CA::OGL::MetalContext::StructHasher<CA::OGL::MetalContext::Pipeline::Spec>,true>,std::allocator<std::__hash_value_type<CA::OGL::MetalContext::Pipeline::Spec,CA::OGL::MetalContext::Pipeline*>>>::__emplace_unique_key_args<CA::OGL::MetalContext::Pipeline::Spec,std::piecewise_construct_t const&,std::tuple<CA::OGL::MetalContext::Pipeline::Spec const&>,std::tuple<>>(float *a1, void *a2, _OWORD *a3)
{
  unint64_t v6 = CA::OGL::MetalContext::StructHasher<CA::OGL::MetalContext::Pipeline::Spec>::operator()((uint64_t)a2);
  unint64_t v7 = v6;
  unint64_t v8 = *((void *)a1 + 1);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v10 = v6;
      if (v6 >= v8) {
        unint64_t v10 = v6 % v8;
      }
    }
    else
    {
      unint64_t v10 = (v8 - 1) & v6;
    }
    float32x4_t v11 = *(void ***)(*(void *)a1 + 8 * v10);
    if (v11)
    {
      for (uint64_t i = *v11; i; uint64_t i = (void *)*i)
      {
        unint64_t v13 = i[1];
        if (v13 == v6)
        {
          if (i[2] == *a2 && i[3] == a2[1] && i[4] == a2[2] && i[5] == a2[3]) {
            return i;
          }
        }
        else
        {
          if (v9.u32[0] > 1uLL)
          {
            if (v13 >= v8) {
              v13 %= v8;
            }
          }
          else
          {
            v13 &= v8 - 1;
          }
          if (v13 != v10) {
            break;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v10 = 0;
  }
  uint64_t i = operator new(0x38uLL);
  void *i = 0;
  i[1] = v7;
  long long v17 = a3[1];
  *((_OWORD *)i + 1) = *a3;
  *((_OWORD *)i + 2) = v17;
  i[6] = 0;
  float v18 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v19 = a1[8];
  if (!v8 || (float)(v19 * (float)v8) < v18)
  {
    BOOL v20 = 1;
    if (v8 >= 3) {
      BOOL v20 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v21 = v20 | (2 * v8);
    unint64_t v22 = vcvtps_u32_f32(v18 / v19);
    if (v21 <= v22) {
      int8x8_t prime = (int8x8_t)v22;
    }
    else {
      int8x8_t prime = (int8x8_t)v21;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v8 = *((void *)a1 + 1);
    }
    if (*(void *)&prime > v8) {
      goto LABEL_40;
    }
    if (*(void *)&prime < v8)
    {
      unint64_t v30 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v8 < 3 || (uint8x8_t v31 = (uint8x8_t)vcnt_s8((int8x8_t)v8), v31.i16[0] = vaddlv_u8(v31), v31.u32[0] > 1uLL))
      {
        unint64_t v30 = std::__next_prime(v30);
      }
      else
      {
        uint64_t v32 = 1 << -(char)__clz(v30 - 1);
        if (v30 >= 2) {
          unint64_t v30 = v32;
        }
      }
      if (*(void *)&prime <= v30) {
        int8x8_t prime = (int8x8_t)v30;
      }
      if (*(void *)&prime >= v8)
      {
        unint64_t v8 = *((void *)a1 + 1);
      }
      else
      {
        if (prime)
        {
LABEL_40:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          float64x2_t v24 = operator new(8 * *(void *)&prime);
          float64x2_t v25 = *(void **)a1;
          *(void *)a1 = v24;
          if (v25) {
            operator delete(v25);
          }
          uint64_t v26 = 0;
          *((int8x8_t *)a1 + 1) = prime;
          do
            *(void *)(*(void *)a1 + 8 * v26++) = 0;
          while (*(void *)&prime != v26);
          float64x2_t v27 = (void *)*((void *)a1 + 2);
          if (v27)
          {
            unint64_t v28 = v27[1];
            uint8x8_t v29 = (uint8x8_t)vcnt_s8(prime);
            v29.i16[0] = vaddlv_u8(v29);
            if (v29.u32[0] > 1uLL)
            {
              if (v28 >= *(void *)&prime) {
                v28 %= *(void *)&prime;
              }
            }
            else
            {
              v28 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)a1 + 8 * v28) = a1 + 4;
            float64x2_t v33 = (void *)*v27;
            if (*v27)
            {
              do
              {
                unint64_t v34 = v33[1];
                if (v29.u32[0] > 1uLL)
                {
                  if (v34 >= *(void *)&prime) {
                    v34 %= *(void *)&prime;
                  }
                }
                else
                {
                  v34 &= *(void *)&prime - 1;
                }
                if (v34 != v28)
                {
                  if (!*(void *)(*(void *)a1 + 8 * v34))
                  {
                    *(void *)(*(void *)a1 + 8 * v34) = v27;
                    goto LABEL_65;
                  }
                  void *v27 = *v33;
                  *float64x2_t v33 = **(void **)(*(void *)a1 + 8 * v34);
                  **(void **)(*(void *)a1 + 8 * v34) = v33;
                  float64x2_t v33 = v27;
                }
                unint64_t v34 = v28;
LABEL_65:
                float64x2_t v27 = v33;
                float64x2_t v33 = (void *)*v33;
                unint64_t v28 = v34;
              }
              while (v33);
            }
          }
          unint64_t v8 = (unint64_t)prime;
          goto LABEL_69;
        }
        int v39 = *(void **)a1;
        *(void *)a1 = 0;
        if (v39) {
          operator delete(v39);
        }
        unint64_t v8 = 0;
        *((void *)a1 + 1) = 0;
      }
    }
LABEL_69:
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        unint64_t v10 = v7 % v8;
      }
      else {
        unint64_t v10 = v7;
      }
    }
    else
    {
      unint64_t v10 = (v8 - 1) & v7;
    }
  }
  float64x2_t v35 = *(void **)a1;
  float64x2_t v36 = *(void **)(*(void *)a1 + 8 * v10);
  if (v36)
  {
    void *i = *v36;
LABEL_82:
    *float64x2_t v36 = i;
    goto LABEL_83;
  }
  void *i = *((void *)a1 + 2);
  *((void *)a1 + 2) = i;
  v35[v10] = a1 + 4;
  if (*i)
  {
    unint64_t v37 = *(void *)(*i + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v37 >= v8) {
        v37 %= v8;
      }
    }
    else
    {
      v37 &= v8 - 1;
    }
    float64x2_t v36 = (void *)(*(void *)a1 + 8 * v37);
    goto LABEL_82;
  }
LABEL_83:
  ++*((void *)a1 + 3);
  return i;
}

void sub_18468A06C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void CA::OGL::MetalContext::dispatch_async_pipeline(dispatch_queue_t *this, const CA::OGL::MetalContext::Pipeline::Spec *a2, CA::OGL::MetalContext::Pipeline *a3, char a4, char a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  long long v7 = *((_OWORD *)a2 + 1);
  long long v10 = *(_OWORD *)a2;
  long long v11 = v7;
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 3321888768;
  objc_object v9[2] = ___ZN2CA3OGL12MetalContext23dispatch_async_pipelineERKNS1_8Pipeline4SpecEPS2_bb_block_invoke;
  v9[3] = &__block_descriptor_82_e8_40c41_ZTSN2CA3OGL12MetalContext8Pipeline4SpecE_e5_v8__0l;
  char v13 = a5;
  char v14 = a4;
  v9[4] = this;
  float64x2_t v12 = a3;
  dispatch_block_t v8 = dispatch_block_create(DISPATCH_BLOCK_DETACHED, v9);
  *((void *)a3 + 1) = v8;
  dispatch_async(this[268], v8);
}

void CA::OGL::AsynchronousDispatcher::tick(CA::OGL::AsynchronousDispatcher *this)
{
  MEMORY[0x1F4188790](this);
  uint64_t v2 = v1;
  uint64_t v180 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(v1 + 40);
  long long v178 = *(_OWORD *)(v2 + 72);
  uint64_t v179 = *(void *)(v2 + 88);
  CADisplayTimerAlignPhase(v3, &v178);
  unint64_t v4 = *(void *)(v2 + 48);
  if (v4 >= *(void *)(v2 + 88) >> 1) {
    unint64_t v5 = v4 - (*(void *)(v2 + 88) >> 1);
  }
  else {
    unint64_t v5 = 0;
  }
  uint64_t v6 = mach_absolute_time();
  double v7 = CATimeWithHostTime(v6);
  double v8 = CATimeWithHostTime(v5);
  uint64_t v9 = mach_continuous_time();
  long long v10 = (os_unfair_lock_s *)(v2 + 4);
  os_unfair_lock_lock((os_unfair_lock_t)(v2 + 4));
  uint64_t v12 = *(void *)(v2 + 8);
  if (!v12)
  {
    CA::OGL::AsynchronousDispatcher::stop_timer((CFTypeRef *)v2);
    goto LABEL_8;
  }
  double v13 = v8 + v7;
  uint64_t v14 = *(unsigned int *)(v2 + 16);
  uint64_t v122 = v14;
  if (v14 <= 0x55)
  {
    int v133 = (os_unfair_lock_s *)(v2 + 4);
    MEMORY[0x1F4188790](v11);
    float64x2_t v16 = (char *)&v120 - ((v15 + 15) & 0x7FFFFFFFF0);
    bzero(v16, v15);
    goto LABEL_14;
  }
  long long v17 = (char *)malloc_type_malloc(48 * v14, 0x10200401CD0EA8FuLL);
  if (!v17)
  {
LABEL_8:
    os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 4));
    return;
  }
  float64x2_t v16 = v17;
  uint64_t v12 = *(void *)(v2 + 8);
  if (v12)
  {
    int v133 = (os_unfair_lock_s *)(v2 + 4);
LABEL_14:
    unsigned int v18 = 0;
    uint64_t v19 = v9 + v5;
    do
    {
      uint64_t v20 = v12;
      uint64_t v12 = *(void *)(v12 + 192);
      if (*(void *)(v20 + 16))
      {
        BOOL v21 = v13 >= *(double *)(v20 + 368) || *(unsigned char *)(v20 + 356) != 0;
        os_unfair_lock_lock((os_unfair_lock_t)(v20 + 376));
        uint64_t v22 = *(void *)(v20 + 384);
        if (!v22 || (float64x2_t v23 = *(char **)v22, v24 = *(void *)(v22 + 8), *(void *)v22 == v24))
        {
          uint64_t v33 = *(void *)(v20 + 536);
          unint64_t v32 = v19;
          if (v33) {
            unint64_t v32 = *(void *)(v20 + 520) + v33;
          }
        }
        else
        {
          uint64_t v25 = v24 - (void)v23;
          unint64_t v26 = (unint64_t)(v24 - (void)v23) >> 3;
          int v27 = v26 & ((int)v26 >> 31);
          unint64_t v28 = &v23[(v25 & 0x7FFFFFFF8) - 8];
          int v29 = v26;
          while (1)
          {
            _VF = __OFSUB__(v29--, 1);
            if (v29 < 0 != _VF) {
              break;
            }
            uint64_t v31 = *(void *)v28;
            v28 -= 8;
            if (v31 > v19)
            {
              int v27 = v29 + 1;
              break;
            }
          }
          if (v27 >= (int)v26)
          {
            unint64_t v32 = -1;
          }
          else
          {
            unint64_t v32 = *(void *)&v23[8 * v27];
            std::vector<unsigned long long>::resize((char **)v22, v27);
          }
        }
        os_unfair_lock_unlock((os_unfair_lock_t)(v20 + 376));
        if (v19 >= v32 && v21)
        {
          atomic_fetch_add((atomic_uint *volatile)(v20 + 8), 1u);
          *(void *)&v16[48 * v18] = v20;
          uint64_t v35 = *(void *)(v20 + 16);
          float64x2_t v36 = (atomic_uint *)(v35 + 8);
          if (!atomic_fetch_add((atomic_uint *volatile)(v35 + 8), 1u))
          {
            uint64_t v35 = 0;
            atomic_fetch_add(v36, 0xFFFFFFFF);
          }
          unint64_t v37 = &v16[48 * v18];
          *((void *)v37 + 1) = v35;
          *(void *)(v20 + 536) = v32;
          *((void *)v37 + 2) = v32;
          ++v18;
        }
      }
    }
    while (v12);
    long long v10 = v133;
    if (v18 > v122) {
      __assert_rtn("tick", "ogl-asynchronous.cpp", 486, "valid_item_count <= item_count");
    }
    goto LABEL_39;
  }
  unsigned int v18 = 0;
LABEL_39:
  os_unfair_lock_unlock(v10);
  unsigned int v38 = v18;
  int v39 = &v16[48 * v18];
  int v40 = (CA::OGL::Renderer *)CA::OGL::AsynchronousDispatcher::renderer((CA::OGL::AsynchronousDispatcher *)v2);
  long long v126 = v16;
  uint64_t v132 = v40;
  int v133 = (os_unfair_lock_s *)v39;
  if (v40)
  {
    unsigned int v121 = v38;
    if (v38)
    {
      uint64_t v41 = (unsigned int *)v177;
      float v123 = v162;
      BOOL v124 = v155;
      float64x2_t v131 = (float64x2_t)xmmword_184997D60;
      float64x2_t v130 = (float64x2_t)xmmword_184997D50;
      __asm { FMOV            V0.2D, #1.0 }
      long long v120 = _Q0;
      __int16 v45 = v16;
      long long v125 = (unsigned int *)v177;
      while (1)
      {
        uint64_t v46 = *(void *)v45;
        uint64_t v47 = CA::Render::Context::context_by_id((CA::Render::Context *)*(unsigned int *)(*(void *)v45 + 12));
        if (v47) {
          break;
        }
        unint64_t v68 = 0;
        int v69 = 0;
        uint64_t v70 = 0;
LABEL_92:
        *((void *)v45 + 3) = v70;
        *((void *)v45 + 4) = v68;
        *((_DWORD *)v45 + 10) = v69;
        *((_DWORD *)v45 + 11) = 0;
        v45 += 48;
        if (v45 >= v39) {
          goto LABEL_93;
        }
      }
      uint64_t v48 = v47;
      bzero(v161, 0x448uLL);
      CA::Render::Update::Update((CA::Render::Update *)v161, &v178, 0x2000uLL, v13, 0, 0, *(_DWORD *)(v46 + 360), *(_DWORD *)(v46 + 360), (const CA::Bounds *)(v46 + 336), 0);
      if (!v161[0])
      {
        uint64_t v70 = 0;
LABEL_90:
        unint64_t v68 = CA::Shape::ref((unint64_t)v162[0]);
        int v69 = v163;
        CA::Render::Update::~Update((CA::Render::Update *)v161, v100);
        if (atomic_fetch_add((atomic_uint *volatile)(v48 + 8), 0xFFFFFFFF) == 1) {
          (*(void (**)(uint64_t))(*(void *)v48 + 16))(v48);
        }
        goto LABEL_92;
      }
      uint64_t v49 = *v41;
      unint64_t v50 = v49 & 0xFFFFFFFFFFEFFFFFLL | ((unint64_t)*((unsigned __int16 *)v41 + 2) << 32);
      *uint64_t v41 = v49 & 0xFFEFFFFF;
      *((_WORD *)v41 + 2) = WORD2(v50);
      float v127 = (unsigned int *)(v46 + 336);
      if (CADeviceNeedsP3ShapeTracking::once != -1) {
        dispatch_once(&CADeviceNeedsP3ShapeTracking::once, &__block_literal_global_59);
      }
      int v51 = 150994944;
      if (!CADeviceNeedsP3ShapeTracking::p3_tracking) {
        int v51 = 0x8000000;
      }
      *uint64_t v41 = v51 | *v41 & 0xF6FFFFFF;
      CA::Render::Update::set_display_attributes((uint64_t)v161, (float *)(v46 + 24));
      uint64_t v166 = *(void *)(v46 + 168);
      os_unfair_lock_lock((os_unfair_lock_t)(v46 + 376));
      long long v52 = *(_OWORD *)(v46 + 408);
      long long v53 = *(_OWORD *)(v46 + 424);
      long long v54 = *(_OWORD *)(v46 + 440);
      float64x2_t v143 = *(float64x2_t *)(v46 + 392);
      long long v144 = v52;
      long long v145 = v53;
      long long v146 = v54;
      long long v55 = *(_OWORD *)(v46 + 472);
      long long v56 = *(_OWORD *)(v46 + 488);
      long long v57 = *(_OWORD *)(v46 + 504);
      long long v147 = *(_OWORD *)(v46 + 456);
      long long v148 = v55;
      long long v149 = v56;
      long long v150 = v57;
      os_unfair_lock_unlock((os_unfair_lock_t)(v46 + 376));
      long long v141 = 0u;
      float64x2_t v142 = v131;
      double v58 = *(float *)(v46 + 352);
      float64x2_t v135 = vmulq_n_f64(v130, v58);
      float64x2_t v136 = vmulq_n_f64((float64x2_t)0, v58);
      float64x2_t v137 = vmulq_n_f64(v131, v58);
      float64x2_t v138 = v136;
      long long v139 = 0u;
      float64x2_t v140 = v130;
      CA::Mat4Impl::mat4_concat(&v143, v143.f64, v135.f64, v59);
      float64x2_t v168 = v143;
      long long v169 = v144;
      long long v170 = v145;
      long long v171 = v146;
      long long v172 = v147;
      long long v173 = v148;
      long long v174 = v149;
      long long v175 = v150;
      uint64_t v160 = 0;
      float64x2_t v158 = 0u;
      long long v159 = 0u;
      long long v156 = 0u;
      long long v157 = 0u;
      memset(v155, 0, sizeof(v155));
      long long v154 = 0u;
      memset(v153, 0, sizeof(v153));
      float v60 = *(float *)(v46 + 352);
      uint64_t v61 = v124;
      *BOOL v124 = 0u;
      v61[1] = 0u;
      *(double *)&long long v159 = v60;
      *((double *)&v159 + 1) = 1.0 / v60;
      uint64_t v62 = v132;
      v153[1] = v130.f64[1];
      *(float64_t *)&long long v154 = v131.f64[0];
      *((void *)&v156 + 1) = *(void *)&v130.f64[1];
      float64x2_t v158 = v131;
      v153[0] = v60;
      *((double *)&v154 + 1) = v60;
      *(void *)&long long v156 = 0x3FF0000000000000;
      LOBYTE(v160) = 8 * (v60 != 1.0);
      pthread_mutex_lock((pthread_mutex_t *)(v48 + 72));
      if (*(double *)(v46 + 368) == 0.0)
      {
        uint64_t v63 = CA::Render::Context::root_layer_handle((CA::Render::Context *)v48);
        if (v63) {
          *(void *)(v63 + 96) |= 8uLL;
        }
      }
      uint64_t v64 = CA::Render::Context::root_layer_handle((CA::Render::Context *)v48);
      if (v64 && (uint64_t v65 = *(CA::Render::Layer **)(v64 + 16)) != 0)
      {
        memset(v134, 0, sizeof(v134));
        CA::Render::Layer::compute_frame_transform((uint64_t)v65, 0, (CA::Mat4Impl *)v134, 0);
        CA::Transform::set((uint64_t)v151, (CA::Mat4Impl *)v134, 1);
        CA::Transform::concat_left((CA::Transform *)v153, v151, v66, v67);
        CA::Render::Update::add_context((CA::Render::Update *)v161, (CA::Render::Context *)v48, v65, (const CA::Transform *)v153);
        int v128 = 0;
      }
      else
      {
        CA::Render::Update::add_context((CA::Render::Update *)v161, (CA::Render::Context *)v48, 0, (const CA::Transform *)v153);
        int v128 = 1;
      }
      pthread_mutex_unlock((pthread_mutex_t *)(v48 + 72));
      CA::Render::Update::added_all_contexts(v161, v71, v72);
      unsigned int v129 = (void *)MEMORY[0x185324A30](v73, v74);
      uint64_t v75 = *(void *)v62;
      CA::Render::Update::render_edr_factor((CA::Render::Update *)v161, v76);
      float v78 = v77;
      os_unfair_lock_lock((os_unfair_lock_t)(v46 + 376));
      int v79 = *(unsigned __int8 *)(v46 + 528);
      os_unfair_lock_unlock((os_unfair_lock_t)(v46 + 376));
      if (v79) {
        float v78 = 1.0;
      }
      (*(void (**)(uint64_t, float))(*(void *)v75 + 1048))(v75, v78);
      *(_OWORD *)(v75 + 200) = *(_OWORD *)(v46 + 336);
      *(_WORD *)(v75 + 832) |= 2u;
      uint64_t v80 = v167;
      os_unfair_lock_lock((os_unfair_lock_t)(v46 + 208));
      uint64_t v81 = 0;
      uint64_t v70 = 0;
      while (*(_DWORD *)(v46 + v81 + 236))
      {
        if (!v70 || *(_DWORD *)(v46 + v81 + 232) < *(_DWORD *)(v70 + 16)) {
          uint64_t v70 = v46 + v81 + 216;
        }
        v81 += 56;
        if (v81 == 112) {
          goto LABEL_67;
        }
      }
      uint64_t v70 = v46 + v81 + 216;
LABEL_67:
      *(_DWORD *)(v70 + 20) = 1;
      os_unfair_lock_unlock((os_unfair_lock_t)(v46 + 208));
      os_unfair_lock_lock((os_unfair_lock_t)(v46 + 376));
      int v82 = *(unsigned __int8 *)(v46 + 528);
      os_unfair_lock_unlock((os_unfair_lock_t)(v46 + 376));
      os_unfair_lock_lock((os_unfair_lock_t)(v46 + 376));
      int v83 = *(unsigned __int8 *)(v46 + 529);
      os_unfair_lock_unlock((os_unfair_lock_t)(v46 + 376));
      dispatch_semaphore_wait(*(dispatch_semaphore_t *)(v70 + 32), 0xFFFFFFFFFFFFFFFFLL);
      dispatch_semaphore_wait(*(dispatch_semaphore_t *)(v70 + 24), 0xFFFFFFFFFFFFFFFFLL);
      float64x2_t v16 = v126;
      if (*(void *)v70)
      {
        if (IOSurfaceGetProtectionOptions() == v80
          && *(unsigned __int8 *)(v70 + 54) == v82
          && *(unsigned __int8 *)(v70 + 55) == v83)
        {
          uint64_t v86 = *(CA::Shape ***)(v70 + 8);
          if (v86)
          {
LABEL_79:
            *(void *)(v70 + 40) = v80;
            int v89 = v165;
            *(unsigned char *)(v70 + 52) = (v165 & 0x8000) != 0;
            *(unsigned char *)(v70 + 53) = (v89 & 0x80000) != 0;
            *(_DWORD *)(v70 + 48) = v176;
            *(unsigned char *)(v70 + 54) = v82;
            *(unsigned char *)(v70 + 55) = v83;
            CA::shape_union(v123, v86, v85);
            int v90 = v132;
            CA::OGL::Renderer::prepare_clip_shape(v132, v162[0]);
            (*(void (**)(uint64_t, void, void, void))(*(void *)v75 + 32))(v75, *(void *)v70, 0, 0);
            if (CADeviceHasBacklight::once != -1) {
              dispatch_once(&CADeviceHasBacklight::once, &__block_literal_global_120);
            }
            int v39 = (char *)v133;
            if (CADeviceHasBacklight::has_backlight == 1 && *(void *)v70)
            {
              int v152 = 0;
              memset(v151, 0, sizeof(v151));
              *(int8x8_t *)((char *)&v151[5].f64[1] + 4) = vand_s8((int8x8_t)(vcvts_n_s32_f32(v78, 0x14uLL) | 0x10000000000000), (int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(v78 != 0.0), 0x1FuLL)));
              IOSurfaceSetBulkAttachments2();
            }
            CA::OGL::Renderer::render(v90, (const CA::Render::Update *)v161, 0, v91);
            (*(void (**)(uint64_t, void))(*(void *)v75 + 408))(v75, 0);
            (*(void (**)(uint64_t, void, void, void))(*(void *)v75 + 32))(v75, 0, 0, 0);
            int v92 = (CA::Shape *)*((void *)v90 + 2);
            if (v92)
            {
              CA::Shape::unref(v92);
              *((void *)v90 + 2) = 0;
            }
            BOOL v93 = v162[7];
            int v94 = *(void **)v90;
            int v95 = v164;
            *((_DWORD *)v94 + 57) = v163;
            *((_DWORD *)v94 + 58) = v95;
            CA::Render::Update::release_objects(v161);
            int v96 = *(void **)v90;
            v96[30] = v93;
            (*(void (**)(void *, void))(*v96 + 216))(v96, 0);
            *(_DWORD *)(v46 + 360) = v163;
            *(const CA::Render::Update **)(v46 + 368) = v162[8];
            *(unsigned char *)(v46 + 356) = 0;
            if ((v128 & 1) == 0)
            {
              long long v98 = CA::Render::Update::build_hit_test_tree((CA::Render::Update *)v161, 0, v97, (float)(1.0 / *(float *)(v46 + 352)));
              os_unfair_lock_lock((os_unfair_lock_t)(v46 + 180));
              long long v99 = *(CA::Render::HitTestTree **)(v46 + 184);
              *(void *)(v46 + 184) = v98;
              float64x2_t v16 = v126;
              os_unfair_lock_unlock((os_unfair_lock_t)(v46 + 180));
              if (v99) {
                CA::Render::HitTestTree::unref(v99);
              }
            }
            uint64_t v41 = v125;
            goto LABEL_90;
          }
LABEL_77:
          uint64_t v86 = (CA::Shape **)CA::Shape::new_shape(v127);
          uint64_t v88 = *(CA::Shape **)(v70 + 8);
          *(void *)(v70 + 8) = v86;
          if (v88)
          {
            CA::Shape::unref(v88);
            uint64_t v86 = *(CA::Shape ***)(v70 + 8);
          }
          goto LABEL_79;
        }
        if (*(void *)v70) {
          CA::OGL::release_iosurface(*(CA::OGL **)v70, v84);
        }
      }
      *(void *)uint64_t v70 = CA::OGL::create_iosurface((CA::OGL *)*(int *)(v46 + 344), *(int *)(v46 + 348), v80, v82 != 0, v83 != 0);
      uint64_t v87 = *(CA::Shape **)(v70 + 8);
      if (v87)
      {
        CA::Shape::unref(v87);
        *(void *)(v70 + 8) = 0;
      }
      goto LABEL_77;
    }
LABEL_93:
    (*(void (**)(void))(**(void **)v132 + 416))(*(void *)v132);
    unsigned int v38 = v121;
  }
  if (!v38) {
    goto LABEL_127;
  }
  unint64_t v101 = v16;
  do
  {
    uint64_t v102 = *((void *)v101 + 3);
    if (v102)
    {
      uint64_t v103 = *((void *)v101 + 4);
      if (v103)
      {
        __int16 v104 = *(os_unfair_lock_s **)v101;
        dispatch_semaphore_signal(*(dispatch_semaphore_t *)(v102 + 24));
        dispatch_semaphore_signal(*(dispatch_semaphore_t *)(v102 + 32));
        os_unfair_lock_lock(v104 + 52);
        uint64_t v105 = 0;
        *(_DWORD *)(v102 + 20) = 2;
        *(_DWORD *)(v102 + 16) = *((_DWORD *)v101 + 10);
        while (1)
        {
          __int16 v106 = &v104[v105];
          if (&v104[v105 + 54] == (os_unfair_lock_s *)v102)
          {
            double v109 = *(CA::Shape **)(v102 + 8);
            *(void *)(v102 + 8) = 1;
            if (!v109) {
              goto LABEL_103;
            }
          }
          else
          {
            uint64_t v107 = *(void *)&v106[56]._os_unfair_lock_opaque;
            if (!v107) {
              goto LABEL_103;
            }
            unint64_t v108 = CA::Shape::Union(v107, v103);
            double v109 = *(CA::Shape **)&v106[56]._os_unfair_lock_opaque;
            *(void *)&v106[56]._os_unfair_lock_opaque = v108;
            if (!v109) {
              goto LABEL_103;
            }
          }
          CA::Shape::unref(v109);
LABEL_103:
          v105 += 14;
          if (v105 == 28)
          {
            os_unfair_lock_unlock(v104 + 52);
            int v39 = (char *)v133;
            break;
          }
        }
      }
    }
    v101 += 48;
  }
  while (v101 < v39);
  float64x2_t v16 = v126;
  uint64_t v110 = v126;
  do
  {
    if (*((void *)v110 + 3))
    {
      if (*((void *)v110 + 4))
      {
        uint64_t v111 = (CA::Render::Handle *)*((void *)v110 + 1);
        double v112 = (CA::Render::Context *)CA::Render::Handle::retain_context(v111);
        if (v112)
        {
          int32x2_t v113 = (atomic_uint *)v112;
          CA::Render::Context::will_commit(v112);
          CA::Render::Handle::set_update_flags(v111, 7);
          CA::Render::Context::did_commit((unint64_t)v113, 1, 0, 1, 0, 0);
          if (atomic_fetch_add(v113 + 2, 0xFFFFFFFF) == 1) {
            (*(void (**)(atomic_uint *))(*(void *)v113 + 16))(v113);
          }
        }
      }
    }
    v110 += 48;
  }
  while (v110 < v39);
  char v114 = v16;
  do
  {
    int32x2_t v115 = (CA::Shape *)*((void *)v114 + 4);
    if (v115) {
      CA::Shape::unref(v115);
    }
    int v116 = (atomic_uint *)*((void *)v114 + 1);
    if (atomic_fetch_add(v116 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v116 + 16))(v116);
    }
    uint64_t v117 = *(void *)v114;
    unsigned int add = atomic_fetch_add((atomic_uint *volatile)(*(void *)v114 + 8), 0xFFFFFFFF);
    if (v117) {
      _ZF = add == 1;
    }
    else {
      _ZF = 0;
    }
    if (_ZF) {
      (*(void (**)(uint64_t))(*(void *)v117 + 8))(v117);
    }
    v114 += 48;
  }
  while (v114 < v39);
LABEL_127:
  if (v122 > 0x55) {
    free(v16);
  }
}

float64x2_t CA::Render::Layer::compute_frame_transform(uint64_t a1, uint64_t a2, CA::Mat4Impl *this, const double *a4)
{
  uint64_t v7 = *(void *)(a1 + 128);
  if (a2)
  {
    uint64_t v8 = *(void *)(a2 + 128);
    int v9 = (*(unsigned __int8 *)(a2 + 45) >> 6) & 1;
    if (v7)
    {
LABEL_3:
      float64x2_t v10 = vmulq_f64(*(float64x2_t *)(v7 + 168), *(float64x2_t *)(a1 + 80));
      double v11 = *(double *)(v7 + 184);
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v8 = 0;
    LOBYTE(v9) = 0;
    if (v7) {
      goto LABEL_3;
    }
  }
  float64x2_t v10 = 0uLL;
  double v11 = 0.0;
  if ((*(unsigned char *)(a1 + 45) & 0x40) == 0)
  {
    __asm { FMOV            V1.2D, #0.5 }
    float64x2_t v10 = vmulq_f64(*(float64x2_t *)(a1 + 80), _Q1);
  }
LABEL_7:
  if (v8) {
    uint64_t v17 = *(void *)(v8 + 24);
  }
  else {
    uint64_t v17 = 0;
  }
  if (!((unint64_t)a4 | v17))
  {
    if (v7)
    {
      uint64_t v18 = *(void *)(v7 + 16);
      if (v18) {
        goto LABEL_16;
      }
      *(_OWORD *)this = xmmword_184997D50;
      *((_OWORD *)this + 1) = 0u;
      *((_OWORD *)this + 2) = xmmword_184997D60;
      *((_OWORD *)this + 3) = 0u;
      *((_OWORD *)this + 4) = 0u;
      *((_OWORD *)this + 5) = xmmword_184997D50;
      *((_OWORD *)this + 6) = 0u;
      *((_OWORD *)this + 7) = xmmword_184997D60;
      float64x2_t result = vsubq_f64(*(float64x2_t *)(a1 + 48), v10);
      *((float64x2_t *)this + 6) = result;
      double v43 = *(double *)(v7 + 192);
    }
    else
    {
      *(_OWORD *)this = xmmword_184997D50;
      *((_OWORD *)this + 1) = 0u;
      *((_OWORD *)this + 2) = xmmword_184997D60;
      *((_OWORD *)this + 3) = 0u;
      *((_OWORD *)this + 4) = 0u;
      *((_OWORD *)this + 5) = xmmword_184997D50;
      *((_OWORD *)this + 6) = 0u;
      *((_OWORD *)this + 7) = xmmword_184997D60;
      float64x2_t result = vsubq_f64(*(float64x2_t *)(a1 + 48), v10);
      *((float64x2_t *)this + 6) = result;
      double v43 = 0.0;
    }
    *((double *)this + 14) = v43 - v11;
    float64x2_t v35 = (float64x2_t)xmmword_184997D60;
    float64x2_t v38 = (float64x2_t)xmmword_184997D50;
    float64x2_t v37 = 0uLL;
    float64x2_t v34 = 0uLL;
    float64x2_t v33 = (float64x2_t)xmmword_184997D50;
    float64x2_t v36 = 0uLL;
    goto LABEL_37;
  }
  if (v7)
  {
    uint64_t v18 = *(void *)(v7 + 16);
    if (v18)
    {
LABEL_16:
      unsigned int v20 = *(_DWORD *)(v18 + 16);
      uint64_t v19 = (long long *)(v18 + 24);
      if (v20 <= 0xF) {
        uint64_t v19 = &CA::Mat4Impl::mat4_identity_double;
      }
      goto LABEL_18;
    }
  }
  uint64_t v19 = &CA::Mat4Impl::mat4_identity_double;
LABEL_18:
  float64x2_t v22 = (float64x2_t)*v19;
  float64x2_t v21 = (float64x2_t)v19[1];
  float64x2_t v23 = (float64x2_t)v19[2];
  float64x2_t v24 = (float64x2_t)v19[3];
  *(_OWORD *)this = *v19;
  *((float64x2_t *)this + 1) = v21;
  *((float64x2_t *)this + 2) = v23;
  *((float64x2_t *)this + 3) = v24;
  float64x2_t v26 = (float64x2_t)v19[4];
  float64x2_t v25 = (float64x2_t)v19[5];
  float64x2_t v27 = (float64x2_t)v19[6];
  float64x2_t v28 = (float64x2_t)v19[7];
  *((float64x2_t *)this + 4) = v26;
  *((float64x2_t *)this + 5) = v25;
  float64x2_t v29 = vmlsq_lane_f64(vmlsq_lane_f64(vmlsq_lane_f64(v27, v22, v10.f64[0], 0), v23, v10.f64[1], 0), v26, v11, 0);
  float64x2_t v30 = vmlsq_lane_f64(vmlsq_lane_f64(vmlsq_lane_f64(v28, v21, v10.f64[0], 0), v24, v10.f64[1], 0), v25, v11, 0);
  *((float64x2_t *)this + 6) = v29;
  *((float64x2_t *)this + 7) = v30;
  float64x2_t v31 = *(float64x2_t *)(a1 + 48);
  if (v7) {
    unint64_t v32 = *(void *)(v7 + 192);
  }
  else {
    unint64_t v32 = 0;
  }
  float64x2_t v33 = vmlaq_laneq_f64(v22, v31, v21, 1);
  float64x2_t v34 = vmlaq_laneq_f64(v21, (float64x2_t)v32, v21, 1);
  float64x2_t v35 = vmlaq_laneq_f64(v23, v31, v24, 1);
  float64x2_t v36 = vmlaq_laneq_f64(v24, (float64x2_t)v32, v24, 1);
  float64x2_t v37 = vmlaq_laneq_f64(v26, v31, v25, 1);
  float64x2_t v38 = vmlaq_laneq_f64(v25, (float64x2_t)v32, v25, 1);
  float64x2_t result = vmlaq_laneq_f64(v29, v31, v30, 1);
  *(float64x2_t *)this = v33;
  *((float64x2_t *)this + 1) = v34;
  *((float64x2_t *)this + 2) = v35;
  *((float64x2_t *)this + 3) = v36;
  *((float64x2_t *)this + 4) = v37;
  *((float64x2_t *)this + 5) = v38;
  float64x2_t v40 = vmlaq_laneq_f64(v30, (float64x2_t)v32, v30, 1);
  *((float64x2_t *)this + 6) = result;
  *((float64x2_t *)this + 7) = v40;
  if ((unint64_t)a4 | v17)
  {
    if (v8)
    {
      float64x2_t v41 = vmulq_f64(*(float64x2_t *)(v8 + 168), *(float64x2_t *)(a2 + 80));
      double v42 = *(double *)(v8 + 184);
    }
    else
    {
      float64x2_t v41 = 0uLL;
      double v42 = 0.0;
      if ((v9 & 1) == 0)
      {
        __asm { FMOV            V16.2D, #0.5 }
        float64x2_t v41 = vmulq_f64(*(float64x2_t *)(a2 + 80), _Q16);
      }
    }
    float64x2_t v60 = vaddq_f64(*(float64x2_t *)(a2 + 64), v41);
    double v61 = v42;
    *(float64x2_t *)this = vmlsq_laneq_f64(v33, v60, v34, 1);
    *((float64x2_t *)this + 1) = vmlaq_laneq_f64(v34, (float64x2_t)COERCE_UNSIGNED_INT64(-v42), v34, 1);
    *((float64x2_t *)this + 2) = vmlsq_laneq_f64(v35, v60, v36, 1);
    *((float64x2_t *)this + 3) = vmlaq_laneq_f64(v36, (float64x2_t)COERCE_UNSIGNED_INT64(-v42), v36, 1);
    *((float64x2_t *)this + 4) = vmlsq_laneq_f64(v37, v60, v38, 1);
    *((float64x2_t *)this + 5) = vmlaq_laneq_f64(v38, (float64x2_t)COERCE_UNSIGNED_INT64(-v42), v38, 1);
    *((float64x2_t *)this + 6) = vmlsq_laneq_f64(result, v60, v40, 1);
    *((float64x2_t *)this + 7) = vmlaq_laneq_f64(v40, (float64x2_t)COERCE_UNSIGNED_INT64(-v42), v40, 1);
    if (v17)
    {
      unsigned int v45 = *(_DWORD *)(v17 + 16);
      uint64_t v46 = (const double *)(v17 + 24);
      if (v45 <= 0xF) {
        uint64_t v47 = (const double *)&CA::Mat4Impl::mat4_identity_double;
      }
      else {
        uint64_t v47 = v46;
      }
      CA::Mat4Impl::mat4_concat((float64x2_t *)this, (double *)this, v47, a4);
      double v42 = v61;
    }
    if (a4)
    {
      CA::Mat4Impl::mat4_concat((float64x2_t *)this, (double *)this, a4, a4);
      double v42 = v61;
    }
    float64x2_t v48 = *((float64x2_t *)this + 1);
    float64x2_t v49 = *((float64x2_t *)this + 3);
    float64x2_t v50 = *((float64x2_t *)this + 5);
    float64x2_t v51 = *((float64x2_t *)this + 7);
    float64x2_t v33 = vmlaq_laneq_f64(*(float64x2_t *)this, v60, v48, 1);
    float64x2_t v34 = vmlaq_laneq_f64(v48, (float64x2_t)*(unint64_t *)&v42, v48, 1);
    float64x2_t v35 = vmlaq_laneq_f64(*((float64x2_t *)this + 2), v60, v49, 1);
    float64x2_t v36 = vmlaq_laneq_f64(v49, (float64x2_t)*(unint64_t *)&v42, v49, 1);
    float64x2_t v37 = vmlaq_laneq_f64(*((float64x2_t *)this + 4), v60, v50, 1);
    float64x2_t v38 = vmlaq_laneq_f64(v50, (float64x2_t)*(unint64_t *)&v42, v50, 1);
    float64x2_t result = vmlaq_laneq_f64(*((float64x2_t *)this + 6), v60, v51, 1);
    *(float64x2_t *)this = v33;
    *((float64x2_t *)this + 1) = v34;
    *((float64x2_t *)this + 2) = v35;
    *((float64x2_t *)this + 3) = v36;
    *((float64x2_t *)this + 4) = v37;
    *((float64x2_t *)this + 5) = v38;
    *((float64x2_t *)this + 6) = result;
    *((float64x2_t *)this + 7) = vmlaq_laneq_f64(v51, (float64x2_t)*(unint64_t *)&v42, v51, 1);
  }
LABEL_37:
  uint64_t v52 = *(void *)(a1 + 40);
  if ((v52 & 0x200) != 0)
  {
    double v53 = *(double *)(a1 + 88);
    float64x2_t result = vmlaq_n_f64(result, v35, v53);
    float64x2_t v54 = vmlaq_n_f64(*((float64x2_t *)this + 7), v36, v53);
    *((float64x2_t *)this + 6) = result;
    *((float64x2_t *)this + 7) = v54;
    *((float64x2_t *)this + 2) = vnegq_f64(v35);
    *((float64x2_t *)this + 3) = vnegq_f64(v36);
    uint64_t v52 = *(void *)(a1 + 40);
  }
  if ((v52 & 0x2000) != 0)
  {
    double v58 = *(double *)(a1 + 80);
    float64x2_t result = vmlaq_n_f64(result, v33, v58);
    float64x2_t v59 = vmlaq_n_f64(*((float64x2_t *)this + 7), v34, v58);
    *((float64x2_t *)this + 6) = result;
    *((float64x2_t *)this + 7) = v59;
    *(float64x2_t *)this = vnegq_f64(v33);
    *((float64x2_t *)this + 1) = vnegq_f64(v34);
  }
  double v56 = *(double *)(a1 + 64);
  double v55 = *(double *)(a1 + 72);
  if (v56 != 0.0 || v55 != 0.0)
  {
    float64x2_t result = vmlaq_f64(vmlsq_lane_f64(vmlsq_lane_f64(result, *(float64x2_t *)this, v56, 0), *((float64x2_t *)this + 2), v55, 0), (float64x2_t)0, v37);
    float64x2_t v57 = vmlaq_f64(vmlsq_lane_f64(vmlsq_lane_f64(*((float64x2_t *)this + 7), *((float64x2_t *)this + 1), v56, 0), *((float64x2_t *)this + 3), v55, 0), (float64x2_t)0, v38);
    *((float64x2_t *)this + 6) = result;
    *((float64x2_t *)this + 7) = v57;
  }
  return result;
}

uint64_t CA::Render::Updater::get_rotation_flags(CA::Render::Updater *this, CA::Transform *a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  LOBYTE(v2) = *((unsigned char *)this + 144);
  if ((v2 & 0x10) != 0)
  {
    float64x2_t v4 = *((float64x2_t *)this + 3);
    int8x16_t v17 = *((int8x16_t *)this + 2);
    int8x16_t v18 = *(int8x16_t *)this;
    float64x2_t v22 = *((float64x2_t *)this + 1);
    v23[0] = *(_OWORD *)this;
    v23[1] = v22;
    int8x16_t v24 = v17;
    float64x2_t v21 = v4;
    long long v5 = *((_OWORD *)this + 4);
    long long v6 = *((_OWORD *)this + 5);
    long long v7 = *((_OWORD *)this + 6);
    long long v8 = *((_OWORD *)this + 7);
    float64x2_t v25 = v4;
    long long v26 = v5;
    double v19 = *((double *)&v8 + 1);
    double v20 = *(double *)&v6;
    long long v27 = v6;
    long long v28 = v7;
    long long v29 = v8;
    if (CA::Mat4Impl::mat4_is_affine(this, (const double *)a2))
    {
      int8x16_t v12 = v17;
      int8x16_t v11 = v18;
      v10.i64[0] = v18.i64[1];
      v9.i64[0] = v17.i64[1];
      if (fabs(*(double *)&v18.i64[1]) >= 1.0e-15 || fabs(*(double *)v17.i64) >= 1.0e-15)
      {
        if (fabs(*(double *)v18.i64) < 1.0e-15 && fabs(*(double *)&v17.i64[1]) < 1.0e-15)
        {
          v24.i64[1] = 0;
          *(void *)&v23[0] = 0;
          v9.i64[0] = 0;
          v11.i64[0] = 0;
        }
      }
      else
      {
        v24.i64[0] = 0;
        *((void *)&v23[0] + 1) = 0;
        v12.i64[0] = 0;
        v10.i64[0] = 0;
      }
      if (vabdd_f64(fabs(*(double *)v10.i64), fabs(*(double *)v12.i64)) >= 1.0e-15)
      {
        if (vabdd_f64(fabs(*(double *)v11.i64), fabs(*(double *)v9.i64)) < 1.0e-15)
        {
          v15.f64[0] = NAN;
          v15.f64[1] = NAN;
          v24.i64[1] = vbslq_s8((int8x16_t)vnegq_f64(v15), v11, v9).u64[0];
        }
      }
      else
      {
        v14.f64[0] = NAN;
        v14.f64[1] = NAN;
        v24.i64[0] = vbslq_s8((int8x16_t)vnegq_f64(v14), v10, v12).u64[0];
      }
      CA::Transform::set((uint64_t)this, (CA::Mat4Impl *)v23, 1);
      unsigned int v2 = *((unsigned __int8 *)this + 144);
      int v13 = (v2 >> 4) & 1;
    }
    else
    {
      int v13 = 1;
    }
    if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqzq_f64(v22), (int32x4_t)vceqzq_f64(v21))))) & 1) == 0&& v20 == 1.0&& v13&& v19 == 1.0)
    {
      *(void *)&long long v29 = 0;
      long long v26 = 0uLL;
      long long v27 = xmmword_184997D50;
      CA::Transform::set((uint64_t)this, (CA::Mat4Impl *)v23, 1);
      LOBYTE(v2) = *((unsigned char *)this + 144);
    }
  }
  if ((v2 & 0x10) != 0) {
    return 0;
  }
  else {
    return v2 & 7;
  }
}

double CA::Transform::set_affine_rectilinear(CA::Transform *this, double result, double a3, double a4, double a5)
{
  __asm { FMOV            V4.2D, #1.0 }
  char v9 = *((unsigned char *)this + 144) & 0xE0;
  *((unsigned char *)this + 144) = v9;
  *(_OWORD *)this = xmmword_184997D50;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((_OWORD *)this + 2) = xmmword_184997D60;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = xmmword_184997D50;
  *((_OWORD *)this + 7) = xmmword_184997D60;
  *((_OWORD *)this + 8) = _Q4;
  *((double *)this + 12) = a4;
  *((double *)this + 13) = a5;
  if (result == 1.0 && result == a3) {
    return result;
  }
  *(double *)this = result;
  *((double *)this + 5) = a3;
  double v10 = -result;
  if (result >= 0.0) {
    double v10 = result;
  }
  if (v10 != result)
  {
    if (-v10 == a3) {
      char v12 = 3;
    }
    else {
      char v12 = 16;
    }
    if (v10 == a3) {
      char v11 = 2;
    }
    else {
      char v11 = v12;
    }
    goto LABEL_16;
  }
  if (v10 != a3)
  {
    if (-v10 == a3) {
      char v11 = 1;
    }
    else {
      char v11 = 16;
    }
LABEL_16:
    v9 |= v11;
    *((unsigned char *)this + 144) = v9;
  }
  float64x2_t result = 1.0;
  if (v10 != 1.0 && (v9 & 0x10) == 0)
  {
    float64x2_t result = 1.0 / v10;
    *((double *)this + 16) = v10;
    *((double *)this + 17) = 1.0 / v10;
    *((unsigned char *)this + 144) = v9 | 8;
  }
  return result;
}

void CA::Layer::map_geometry(CA::Transaction *a1, CALayer *a2, void (*a3)(uint64_t, long long *), void (*a4)(void, void), uint64_t a5)
{
  char v9 = (uint64_t *)a1;
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  double v10 = CA::Transaction::ensure_compat(a1);
  int v11 = *((_DWORD *)v10 + 25);
  *((_DWORD *)v10 + 25) = v11 + 1;
  if (!v11) {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
  }
  uint64_t v39 = a5;
  char v12 = (CALayer *)[v9 ancestorSharedWithLayer:a2];
  int v13 = (uint64_t *)v12;
  if (v12 != (CALayer *)v9)
  {
    float64x2_t v36 = a4;
    char v14 = 0;
    int v15 = 0;
    double v16 = 0.0;
    long long v48 = xmmword_184997D50;
    long long v49 = 0u;
    double v17 = 0.0;
    long long v50 = xmmword_184997D60;
    long long v51 = 0u;
    long long v52 = 0u;
    long long v53 = xmmword_184997D50;
    long long v37 = xmmword_184997D60;
    long long v38 = xmmword_184997D50;
    long long v54 = 0u;
    long long v55 = xmmword_184997D60;
    while (v9 != v13)
    {
      long long v46 = 0u;
      long long v47 = 0u;
      long long v44 = 0u;
      long long v45 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      long long v40 = 0u;
      long long v41 = 0u;
      CA::Layer::get_frame_transform(v9[2], (float64x2_t *)&v40, 0, 0, 0.0, v16, v17);
      unsigned int v20 = *(_DWORD *)(v9[2] + 4);
      if (v14)
      {
        if (v15 | v20 & 0x10000 || CA::Mat4Impl::mat4_is_affine((CA::Mat4Impl *)&v40, v18))
        {
          CA::Mat4Impl::mat4_concat((float64x2_t *)&v48, (double *)&v48, (const double *)&v40, v19);
          char v14 = 1;
        }
        else
        {
          a3(v39, &v48);
          a3(v39, &v40);
          char v14 = 0;
          long long v48 = v38;
          long long v49 = 0u;
          long long v51 = 0u;
          long long v52 = 0u;
          long long v50 = v37;
          long long v53 = v38;
          long long v54 = 0u;
          long long v55 = v37;
        }
      }
      else
      {
        long long v48 = v40;
        long long v49 = v41;
        long long v50 = v42;
        long long v51 = v43;
        long long v52 = v44;
        long long v53 = v45;
        char v14 = 1;
        long long v54 = v46;
        long long v55 = v47;
      }
      int v15 = HIWORD(v20) & 1;
      char v12 = CA::Layer::superlayer((CA::Layer *)v9[2], v10);
      char v9 = (uint64_t *)v12;
    }
    if (v14) {
      char v12 = (CALayer *)((uint64_t (*)(uint64_t, long long *))a3)(v39, &v48);
    }
    a4 = v36;
  }
  if (v13 != (uint64_t *)a2)
  {
    uint64_t v21 = v39;
    do
    {
      MEMORY[0x1F4188790](v12);
      float64x2_t v22 = &v35 - 2;
      *(&v35 - 2) = (uint64_t)a2;
      *(&v35 - 1) = v23;
      if (a2)
      {
        char v12 = CA::Layer::superlayer((CA::Layer *)a2->_attr.layer, v10);
        a2 = v12;
      }
    }
    while (a2 != (CALayer *)v13);
    int v24 = 0;
    char v25 = 0;
    double v26 = 0.0;
    long long v48 = xmmword_184997D50;
    long long v49 = 0u;
    double v27 = 0.0;
    long long v50 = xmmword_184997D60;
    long long v51 = 0u;
    long long v52 = 0u;
    long long v53 = xmmword_184997D50;
    long long v37 = xmmword_184997D60;
    long long v38 = xmmword_184997D50;
    long long v54 = 0u;
    long long v55 = xmmword_184997D60;
    while (1)
    {
      uint64_t v28 = *v22;
      long long v46 = 0u;
      long long v47 = 0u;
      long long v44 = 0u;
      long long v45 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      long long v40 = 0u;
      long long v41 = 0u;
      CA::Layer::get_frame_transform(*(void *)(v28 + 16), (float64x2_t *)&v40, 0, 0, 0.0, v26, v27);
      unsigned int v32 = *(_DWORD *)(*(void *)(v28 + 16) + 4);
      if ((v25 & 1) == 0) {
        break;
      }
      if (v24 | v32 & 0x10000 || CA::Mat4Impl::mat4_is_affine((CA::Mat4Impl *)&v40, v29))
      {
        CA::Mat4Impl::mat4_concat((float64x2_t *)&v48, (double *)&v40, (const double *)&v48, v31);
LABEL_27:
        int v24 = HIWORD(v32) & 1;
        float64x2_t v22 = (uint64_t *)v22[1];
        char v25 = 1;
        if (!v22)
        {
          CA::Mat4Impl::mat4_invert((CA::Mat4Impl *)&v48, (CA::Mat4Impl *)&v48, v30);
          a4(v21, &v48);
          goto LABEL_30;
        }
      }
      else
      {
        CA::Mat4Impl::mat4_invert((CA::Mat4Impl *)&v48, (CA::Mat4Impl *)&v48, v33);
        a4(v21, &v48);
        CA::Mat4Impl::mat4_invert((CA::Mat4Impl *)&v40, (CA::Mat4Impl *)&v40, v34);
        a4(v21, &v40);
        int v24 = 0;
        char v25 = 0;
        double v27 = *(double *)&v37;
        double v26 = 0.0;
        long long v48 = v38;
        long long v49 = 0u;
        long long v51 = 0u;
        long long v52 = 0u;
        long long v50 = v37;
        long long v53 = v38;
        long long v54 = 0u;
        long long v55 = v37;
        float64x2_t v22 = (uint64_t *)v22[1];
        if (!v22) {
          goto LABEL_30;
        }
      }
    }
    long long v48 = v40;
    long long v49 = v41;
    long long v50 = v42;
    long long v51 = v43;
    double v26 = *(double *)&v45;
    double v27 = *(double *)&v46;
    long long v52 = v44;
    long long v53 = v45;
    long long v54 = v46;
    long long v55 = v47;
    goto LABEL_27;
  }
LABEL_30:
  CA::Transaction::unlock(v10);
}

void sub_18468B8EC(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

float64x2_t CA::Mat4Impl::mat4_concat(float64x2_t *this, double *a2, const double *a3, const double *a4)
{
  float64x2_t v4 = *(float64x2_t *)(a2 + 2);
  float64x2_t v5 = *(float64x2_t *)(a2 + 4);
  float64x2_t v6 = *(float64x2_t *)(a2 + 6);
  float64x2_t v7 = *(float64x2_t *)(a2 + 8);
  float64x2_t v8 = *(float64x2_t *)(a2 + 10);
  float64x2_t v10 = *(float64x2_t *)(a2 + 12);
  float64x2_t result = *(float64x2_t *)(a2 + 14);
  float64x2_t v11 = *(float64x2_t *)(a3 + 2);
  float64x2_t v12 = *(float64x2_t *)(a3 + 4);
  float64x2_t v13 = *(float64x2_t *)(a3 + 6);
  float64x2_t v14 = vmlaq_laneq_f64(vmulq_n_f64(*(float64x2_t *)a3, v5.f64[0]), v12, v5, 1);
  float64x2_t v15 = vmlaq_laneq_f64(vmulq_n_f64(v11, v5.f64[0]), v13, v5, 1);
  float64x2_t v16 = *(float64x2_t *)(a3 + 8);
  float64x2_t v17 = *(float64x2_t *)(a3 + 10);
  float64x2_t v18 = vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(*(float64x2_t *)a3, *a2), v12, *(float64x2_t *)a2, 1), v16, v4.f64[0]);
  float64x2_t v19 = vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(v11, *a2), v13, *(float64x2_t *)a2, 1), v17, v4.f64[0]);
  float64x2_t v20 = vmlaq_n_f64(v14, v16, v6.f64[0]);
  float64x2_t v21 = vmlaq_n_f64(v15, v17, v6.f64[0]);
  float64x2_t v22 = vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(*(float64x2_t *)a3, v7.f64[0]), v12, v7, 1), v16, v8.f64[0]);
  float64x2_t v23 = vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(v11, v7.f64[0]), v13, v7, 1), v17, v8.f64[0]);
  float64x2_t v24 = vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(*(float64x2_t *)a3, v10.f64[0]), v12, v10, 1), v16, result.f64[0]);
  float64x2_t v25 = vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(v11, v10.f64[0]), v13, v10, 1), v17, result.f64[0]);
  float64x2_t v26 = *(float64x2_t *)(a3 + 12);
  float64x2_t v27 = *(float64x2_t *)(a3 + 14);
  *this = vmlaq_laneq_f64(v18, v26, v4, 1);
  this[1] = vmlaq_laneq_f64(v19, v27, v4, 1);
  this[2] = vmlaq_laneq_f64(v20, v26, v6, 1);
  this[3] = vmlaq_laneq_f64(v21, v27, v6, 1);
  this[4] = vmlaq_laneq_f64(v22, v26, v8, 1);
  this[5] = vmlaq_laneq_f64(v23, v27, v8, 1);
  this[6] = vmlaq_laneq_f64(v24, v26, result, 1);
  this[7] = vmlaq_laneq_f64(v25, v27, result, 1);
  return result;
}

__n128 CA::Transform::set(uint64_t a1, CA::Mat4Impl *this, int a3)
{
  if (a3 && CA::Mat4Impl::mat4_is_affine(this, (const double *)this))
  {
    double v5 = *(double *)this;
    double v6 = *((double *)this + 1);
    double v7 = *((double *)this + 4);
    double v8 = *((double *)this + 5);
    double v9 = *((double *)this + 12);
    double v10 = *((double *)this + 13);
    CA::Transform::set_affine((CA::Transform *)a1, v5, v6, v7, v8, v9, v10);
  }
  else
  {
    long long v12 = *((_OWORD *)this + 1);
    long long v13 = *((_OWORD *)this + 2);
    long long v14 = *((_OWORD *)this + 3);
    *(_OWORD *)a1 = *(_OWORD *)this;
    *(_OWORD *)(a1 + 16) = v12;
    *(_OWORD *)(a1 + 32) = v13;
    *(_OWORD *)(a1 + 48) = v14;
    long long v15 = *((_OWORD *)this + 5);
    long long v16 = *((_OWORD *)this + 6);
    long long v17 = *((_OWORD *)this + 7);
    *(_OWORD *)(a1 + 64) = *((_OWORD *)this + 4);
    *(_OWORD *)(a1 + 80) = v15;
    *(_OWORD *)(a1 + 96) = v16;
    *(_OWORD *)(a1 + 112) = v17;
    __asm { FMOV            V0.2D, #1.0 }
    *(__n128 *)(a1 + 128) = result;
    *(unsigned char *)(a1 + 144) = *(unsigned char *)(a1 + 144) & 0xE0 | 0x10;
  }
  return result;
}

BOOL CA::Mat4Impl::mat4_is_affine(CA::Mat4Impl *this, const double *a2)
{
  return *((double *)this + 2) == 0.0
      && *((double *)this + 3) == 0.0
      && *((double *)this + 6) == 0.0
      && *((double *)this + 7) == 0.0
      && *((double *)this + 8) == 0.0
      && *((double *)this + 9) == 0.0
      && *((double *)this + 10) == 1.0
      && *((double *)this + 11) == 0.0
      && *((double *)this + 14) == 0.0
      && *((double *)this + 15) == 1.0;
}

void CA::Layer::get_frame_transform(uint64_t a1, float64x2_t *a2, char a3, const double *a4, double a5, double a6, double a7)
{
  uint64_t v92 = *MEMORY[0x1E4F143B8];
  double v8 = *(CA::Layer ***)(a1 + 16);
  if (!v8)
  {
    *a2 = (float64x2_t)xmmword_184997D50;
    a2[1] = 0u;
    a2[2] = (float64x2_t)xmmword_184997D60;
    a2[3] = 0u;
    a2[4] = 0u;
    a2[5] = (float64x2_t)xmmword_184997D50;
    a2[6] = 0u;
    a2[7] = (float64x2_t)xmmword_184997D60;
    return;
  }
  uint64_t v11 = a1;
  int v12 = *(_DWORD *)(a1 + 56);
  if ((v12 & 8) != 0)
  {
    a1 = [*(id *)(a1 + 16) anchorPoint];
    double v14 = v15;
    double v13 = a6;
    int v12 = *(_DWORD *)(v11 + 56);
  }
  else
  {
    double v13 = 0.5;
    double v14 = 0.5;
  }
  double v16 = *(double *)(v11 + 112);
  double v17 = *(double *)(v11 + 120);
  double v18 = 0.0;
  double v19 = 0.0;
  if ((v12 & 0x20) != 0)
  {
    a1 = objc_msgSend(v8, "anchorPointZ", 0.0, a6, a7, 0.0);
    double v18 = 0.0;
    int v12 = *(_DWORD *)(v11 + 56);
  }
  double v74 = v19;
  if ((v12 & 0x40) != 0)
  {
    a1 = [v8 zPosition];
    double v18 = v20;
  }
  if ((*(unsigned char *)(v11 + 55) & 0x10) == 0)
  {
    *a2 = (float64x2_t)xmmword_184997D50;
    a2[1] = 0u;
    a2[2] = (float64x2_t)xmmword_184997D60;
    a2[3] = 0u;
    a2[4] = 0u;
    a2[5] = (float64x2_t)xmmword_184997D50;
    a2[6] = 0u;
    a2[7] = (float64x2_t)xmmword_184997D60;
    a2[6].f64[0] = *(double *)(v11 + 80) - v16 * v14;
    a2[6].f64[1] = *(double *)(v11 + 88) - v17 * v13;
    a2[7].f64[0] = v18 - v74;
    if (a3) {
      goto LABEL_29;
    }
LABEL_14:
    unsigned int v32 = *(CA::Transaction **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 576);
    if (!v32) {
      unsigned int v32 = (CA::Transaction *)CA::Transaction::create((CA::Transaction *)a1);
    }
    float64x2_t v33 = CA::Layer::superlayer(v8[2], v32);
    if (v33)
    {
      uint64_t v35 = v33;
      layer = v33->_attr.layer;
      if (a4 || (*((_DWORD *)layer + 13) & 0x20000000) != 0)
      {
        int v37 = *((_DWORD *)layer + 14);
        if ((v37 & 8) != 0)
        {
          [(CALayer *)v33 anchorPoint];
          int v37 = *((_DWORD *)layer + 14);
          _Q0.f64[1] = v43;
        }
        else
        {
          __asm { FMOV            V0.2D, #0.5 }
        }
        float64x2_t v75 = vmlaq_f64(*((float64x2_t *)layer + 6), _Q0, *((float64x2_t *)layer + 7));
        double v44 = 0.0;
        if ((v37 & 0x20) != 0) {
          [(CALayer *)v35 anchorPointZ];
        }
        double v73 = v44;
        float64x2_t v45 = a2[1];
        float64x2_t v46 = a2[3];
        float64x2_t v47 = a2[5];
        float64x2_t v48 = a2[7];
        float64x2_t v49 = vmlsq_laneq_f64(a2[2], v75, v46, 1);
        float64x2_t v50 = vmlsq_laneq_f64(a2[4], v75, v47, 1);
        float64x2_t v51 = vmlsq_laneq_f64(a2[6], v75, v48, 1);
        *a2 = vmlsq_laneq_f64(*a2, v75, v45, 1);
        a2[1] = vmlaq_laneq_f64(v45, (float64x2_t)COERCE_UNSIGNED_INT64(-v44), v45, 1);
        a2[2] = v49;
        a2[3] = vmlaq_laneq_f64(v46, (float64x2_t)COERCE_UNSIGNED_INT64(-v44), v46, 1);
        a2[4] = v50;
        a2[5] = vmlaq_laneq_f64(v47, (float64x2_t)COERCE_UNSIGNED_INT64(-v44), v47, 1);
        a2[6] = v51;
        a2[7] = vmlaq_laneq_f64(v48, (float64x2_t)COERCE_UNSIGNED_INT64(-v44), v48, 1);
        if ((*((unsigned char *)layer + 55) & 0x20) != 0)
        {
          [(CALayer *)v35 sublayerTransform];
          float64x2_t v84 = v76;
          float64x2_t v85 = v77;
          float64x2_t v86 = v78;
          float64x2_t v87 = v79;
          float64x2_t v88 = v80;
          float64x2_t v89 = v81;
          float64x2_t v90 = v82;
          float64x2_t v91 = v83;
          CA::Mat4Impl::mat4_concat(a2, a2->f64, v84.f64, v52);
        }
        if (a4) {
          CA::Mat4Impl::mat4_concat(a2, a2->f64, a4, v34);
        }
        float64x2_t v53 = a2[1];
        float64x2_t v54 = a2[3];
        float64x2_t v55 = a2[5];
        float64x2_t v56 = a2[7];
        float64x2_t v57 = vmlaq_laneq_f64(a2[2], v75, v54, 1);
        float64x2_t v58 = vmlaq_laneq_f64(a2[4], v75, v55, 1);
        float64x2_t v59 = vmlaq_laneq_f64(a2[6], v75, v56, 1);
        *a2 = vmlaq_laneq_f64(*a2, v75, v53, 1);
        a2[1] = vmlaq_laneq_f64(v53, (float64x2_t)*(unint64_t *)&v73, v53, 1);
        a2[2] = v57;
        a2[3] = vmlaq_laneq_f64(v54, (float64x2_t)*(unint64_t *)&v73, v54, 1);
        a2[4] = v58;
        a2[5] = vmlaq_laneq_f64(v55, (float64x2_t)*(unint64_t *)&v73, v55, 1);
        a2[6] = v59;
        a2[7] = vmlaq_laneq_f64(v56, (float64x2_t)*(unint64_t *)&v73, v56, 1);
      }
    }
    goto LABEL_29;
  }
  double v72 = v18;
  a1 = [v8 transform];
  float64x2_t v21 = v84;
  float64x2_t v22 = v85;
  float64x2_t v23 = v86;
  float64x2_t v24 = v87;
  *a2 = v84;
  a2[1] = v22;
  a2[2] = v23;
  a2[3] = v24;
  float64x2_t v25 = v88;
  float64x2_t v26 = v89;
  float64x2_t v27 = v90;
  float64x2_t v28 = v91;
  a2[4] = v88;
  a2[5] = v26;
  float64x2_t v29 = vmlsq_lane_f64(vmlsq_lane_f64(vmlsq_lane_f64(v27, v21, v16 * v14, 0), v23, v17 * v13, 0), v25, v74, 0);
  float64x2_t v30 = vmlsq_lane_f64(vmlsq_lane_f64(vmlsq_lane_f64(v28, v22, v16 * v14, 0), v24, v17 * v13, 0), v26, v74, 0);
  a2[6] = v29;
  a2[7] = v30;
  float64x2_t v31 = *(float64x2_t *)(v11 + 80);
  *a2 = vmlaq_laneq_f64(v21, v31, v22, 1);
  a2[1] = vmlaq_laneq_f64(v22, (float64x2_t)*(unint64_t *)&v72, v22, 1);
  a2[2] = vmlaq_laneq_f64(v23, v31, v24, 1);
  a2[3] = vmlaq_laneq_f64(v24, (float64x2_t)*(unint64_t *)&v72, v24, 1);
  a2[4] = vmlaq_laneq_f64(v25, v31, v26, 1);
  a2[5] = vmlaq_laneq_f64(v26, (float64x2_t)*(unint64_t *)&v72, v26, 1);
  a2[6] = vmlaq_laneq_f64(v29, v31, v30, 1);
  a2[7] = vmlaq_laneq_f64(v30, (float64x2_t)*(unint64_t *)&v72, v30, 1);
  if ((a3 & 1) == 0) {
    goto LABEL_14;
  }
LABEL_29:
  int v60 = *(_DWORD *)(v11 + 48);
  if ((v60 & 0x800) != 0)
  {
    double v61 = *(double *)(v11 + 120);
    float64x2_t v62 = a2[2];
    float64x2_t v63 = a2[3];
    float64x2_t v64 = vmlaq_f64(vmlaq_n_f64(vmlaq_f64(a2[7], (float64x2_t)0, a2[1]), v63, v61), (float64x2_t)0, a2[5]);
    a2[6] = vmlaq_f64(vmlaq_n_f64(vmlaq_f64(a2[6], (float64x2_t)0, *a2), v62, v61), (float64x2_t)0, a2[4]);
    a2[7] = v64;
    a2[2] = vnegq_f64(v62);
    a2[3] = vnegq_f64(v63);
    int v60 = *(_DWORD *)(v11 + 48);
  }
  if ((v60 & 0x10000000) != 0)
  {
    double v68 = *(double *)(v11 + 112);
    float64x2_t v69 = *a2;
    float64x2_t v70 = a2[1];
    float64x2_t v71 = vmlaq_n_f64(a2[7], v70, v68);
    a2[6] = vmlaq_n_f64(a2[6], *a2, v68);
    a2[7] = v71;
    *a2 = vnegq_f64(v69);
    a2[1] = vnegq_f64(v70);
  }
  if ((*(unsigned char *)(v11 + 55) & 4) != 0)
  {
    double v65 = *(double *)(v11 + 96);
    double v66 = *(double *)(v11 + 104);
    float64x2_t v67 = vmlaq_f64(vmlsq_lane_f64(vmlsq_lane_f64(a2[7], a2[1], v65, 0), a2[3], v66, 0), (float64x2_t)0, a2[5]);
    a2[6] = vmlaq_f64(vmlsq_lane_f64(vmlsq_lane_f64(a2[6], *a2, v65, 0), a2[2], v66, 0), (float64x2_t)0, a2[4]);
    a2[7] = v67;
  }
}

void CA::Render::Update::add_context(CA::Render::Update *this, CA::Render::Context *a2, CA::Render::Layer *a3, const CA::Transform *a4)
{
  uint64_t v132 = *MEMORY[0x1E4F143B8];
  *((void *)a2 + 78) = 0;
  double v8 = (void *)MEMORY[0x185324A30]();
  int v9 = BYTE9(xmmword_1EB2ACC10);
  if (BYTE9(xmmword_1EB2ACC10)) {
    kdebug_trace();
  }
  if (a3)
  {
    uint64_t v10 = *((void *)a2 + 52);
    if ((!v10 || (*((_DWORD *)this + 271) & 0x8000) != 0 || (*(unsigned char *)(v10 + 13) & 4) != 0)
      && CA::Render::Update::allowed_in_secure_update(this, a2, 0)
      && CA::Render::Update::allowed_to_include_context((uint64_t)this, (uint64_t)a2)
      && *((float *)a2 + 48) <= *((float *)this + 268)
      && CA::Render::Update::allowed_in_update(this, a2, a3))
    {
      CA::Render::Update::add_included_context(this, (os_unfair_lock_s *)a2, 0);
      uint64_t v14 = *((unsigned int *)this + 271);
      unint64_t v15 = v14 | ((unint64_t)*((unsigned __int16 *)this + 544) << 32);
      if ((v14 & 4) != 0) {
        uint64_t v99 = 0;
      }
      else {
        uint64_t v99 = *((void *)a3 + 18);
      }
      double v16 = (_DWORD *)((char *)this + 1084);
      uint64_t v107 = 0;
      int v17 = *((_DWORD *)a2 + 3);
      if ((v17 & 0x2000) != 0)
      {
        uint64_t v107 = 8;
        *((_DWORD *)a2 + 3) = v17 & 0xFFFFDFFF;
        LOWORD(v15) = *v16;
        char v18 = (unint64_t)*v16 >> 17;
      }
      else
      {
        char v18 = v15 >> 17;
      }
      unint64_t v101 = (int32x2_t *)this;
      uint64_t v102 = 0;
      LODWORD(v102) = *((_DWORD *)this + 62);
      uint64_t v103 = a2;
      __int16 v104 = a2;
      uint64_t v105 = (uint64_t)&v105;
      __int16 v106 = &v105;
      HIDWORD(v102) = v18 & 1;
      uint64_t bounds = *((void *)this + 1);
      memset(v100, 0, sizeof(v100));
      long long v98 = (uint64_t *)((char *)this + 8);
      if (bounds)
      {
        long long v118 = 0uLL;
        CA::Shape::get_interior_bounds(bounds, &v118);
        *(_OWORD *)&v100[120] = v118;
        uint64_t bounds = CA::Shape::get_bounds(*((void *)this + 1), (int *)&v118);
        v21.i32[1] = HIDWORD(v118);
        v22.i64[0] = (int)v118;
        v22.i64[1] = SDWORD1(v118);
        int64x2_t v23 = v22;
        int v24 = HIDWORD(v118);
        v22.i64[0] = SDWORD2(v118);
        v22.i64[1] = SHIDWORD(v118);
        int64x2_t v25 = v22;
        if (SDWORD2(v118) > SHIDWORD(v118)) {
          int v24 = DWORD2(v118);
        }
        v21.i32[0] = v24;
        v20.i32[0] = 1073741822;
        int8x16_t v26 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v21, v20), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v23));
        int8x16_t v27 = (int8x16_t)vcvtq_f64_s64(v25);
        int32x2_t v28 = vdup_n_s32(v24 > 1073741822);
        v29.i64[0] = v28.u32[0];
        v29.i64[1] = v28.u32[1];
        *(int8x16_t *)&v100[88] = v26;
        *(int8x16_t *)&v100[104] = vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v29, 0x3FuLL)), (int8x16_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL), v27);
        if ((*v16 & 4) == 0)
        {
          float64x2_t v30 = (CA::Shape *)*((void *)a2 + 71);
          if (!v30)
          {
            uint64_t v107 = 8;
            goto LABEL_34;
          }
          uint64_t bounds = CA::Shape::equal(*((void *)a2 + 71), *v98);
          if ((bounds & 1) == 0)
          {
            uint64_t v107 = 8;
            CA::Shape::unref(v30);
LABEL_34:
            uint64_t bounds = CA::Shape::ref(*v98);
LABEL_37:
            *((void *)a2 + 71) = bounds;
          }
        }
      }
      else
      {
        int v31 = *((void *)this + 25);
        *(_OWORD *)&v100[120] = *((_OWORD *)this + 12);
        if (*(int *)&v100[128] <= *(int *)&v100[132]) {
          int v31 = *(_DWORD *)&v100[132];
        }
        v12.i32[0] = 1073741822;
        v13.i32[0] = v31;
        v32.i64[0] = *(int *)&v100[120];
        v32.i64[1] = *(int *)&v100[124];
        int8x16_t v33 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v13, v12), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v32));
        v32.i64[0] = *(int *)&v100[128];
        v32.i64[1] = *(int *)&v100[132];
        int8x16_t v34 = (int8x16_t)vcvtq_f64_s64(v32);
        int32x2_t v35 = vdup_n_s32(v31 > 1073741822);
        v32.i64[0] = v35.u32[0];
        v32.i64[1] = v35.u32[1];
        *(int8x16_t *)&v100[88] = v33;
        *(int8x16_t *)&v100[104] = vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v32, 0x3FuLL)), (int8x16_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL), v34);
        if ((v15 & 4) == 0)
        {
          float64x2_t v36 = (CA::Shape *)*((void *)a2 + 71);
          if (v36)
          {
            uint64_t bounds = CA::Shape::equal(*((void *)a2 + 71), (_DWORD *)this + 48);
            if (bounds) {
              goto LABEL_38;
            }
            uint64_t v107 = 8;
            CA::Shape::unref(v36);
          }
          else
          {
            uint64_t v107 = 8;
          }
          uint64_t bounds = CA::Shape::new_shape((unsigned int *)this + 48);
          goto LABEL_37;
        }
      }
LABEL_38:
      if (!v99 || BYTE4(v102) && (*(unsigned char *)(v99 + 98) & 2) != 0) {
        uint64_t v107 = 8;
      }
      unsigned int v97 = *((_DWORD *)this + 128);
      long long v118 = 0uLL;
      uint64_t v37 = *((void *)a2 + 70);
      uint64_t v119 = *((void *)this + 9);
      uint64_t v120 = v37;
      uint64_t v122 = 0;
      uint64_t v123 = 0;
      uint64_t v121 = 0x7FF0000000000000;
      long long v125 = 0u;
      memset(v126, 0, sizeof(v126));
      __asm { FMOV            V0.2D, #1.0 }
      long long v96 = _Q0;
      long long v127 = _Q0;
      int v124 = 1065353216;
      uint64_t v128 = 0;
      uint64_t v43 = *v16;
      uint64_t v44 = *((void *)a3 + 5) & 0xCLL;
      int v129 = 0;
      unsigned int v130 = (v43 >> 2) & 1;
      uint64_t v45 = *((unsigned __int16 *)this + 544);
      __int16 v46 = v131 & 0xF800 | ((v44 == 8) << 8) | 0x208;
      __int16 v131 = v46;
      uint64_t v47 = v99;
      if (!v99)
      {
        __int16 v131 = v46 & 0xF308;
        float64x2_t v48 = (atomic_uint *)CA::Render::LayerNodeAllocator::alloc_node((CA::Render::LayerNodeAllocator *)bounds);
        uint64_t v51 = *((void *)v48 + 3);
        goto LABEL_54;
      }
      __int16 v131 = (*(void *)(v99 + 96) >> 49) & 0x800 | v46 & 0xF308;
      float64x2_t v48 = *(atomic_uint **)(v99 + 40);
      if (v48)
      {
        if ((((v43 | (unint64_t)(v45 << 32)) >> 27) & 1) == (*(unsigned char *)(v99 + 13) & 2) >> 1)
        {
LABEL_48:
          if (*((void *)v48 + 11))
          {
            uint64_t v50 = *(void *)v48;
            float64x2_t v49 = (void *)*((void *)v48 + 1);
            *(void *)(v50 + 8) = v49;
            void *v49 = v50;
            *(void *)float64x2_t v48 = v48;
            *((void *)v48 + 1) = v48;
            if (atomic_fetch_add(v48 + 4, 0xFFFFFFFF) == 1) {
              CA::Render::LayerNode::delete_node((CA::Render::LayerNode *)v48, v11);
            }
            *((void *)v48 + 11) = 0;
          }
          uint64_t v51 = *((void *)v48 + 3) | 0x40;
          *((void *)v48 + 3) = v51;
LABEL_54:
          *((void *)v48 + 3) = *((void *)a2 + 3) | v51 & 0xFFFFFFFFFFFFFC7FLL;
          if (a4) {
            CA::Render::LayerNode::set_frame_transform((CA::Render::LayerNode *)v48, a4);
          }
          if (BYTE9(xmmword_1EB2ACC10))
          {
            if (!atomic_load((unsigned int *)a2 + 57))
            {
              if (*((_DWORD *)a2 + 63)) {
                pid_t v91 = 0;
              }
              else {
                pid_t v91 = getpid();
              }
              int v94 = 0;
              atomic_compare_exchange_strong((atomic_uint *volatile)a2 + 57, (unsigned int *)&v94, v91);
            }
            kdebug_trace();
          }
          CA::Render::Updater::prepare_layer0(&v101, (CA::Render::LayerNode *)v48, a3, (uint64_t)&v118, v107);
          if (BYTE9(xmmword_1EB2ACC10))
          {
            if (!atomic_load((unsigned int *)a2 + 57))
            {
              if (*((_DWORD *)a2 + 63)) {
                pid_t v93 = 0;
              }
              else {
                pid_t v93 = getpid();
              }
              int v95 = 0;
              atomic_compare_exchange_strong((atomic_uint *volatile)a2 + 57, (unsigned int *)&v95, v93);
            }
            kdebug_trace();
          }
          if (!v99 && !*((void *)v48 + 4))
          {
            if (atomic_fetch_add(v48 + 4, 0xFFFFFFFF) == 1) {
              CA::Render::LayerNode::delete_node((CA::Render::LayerNode *)v48, v52);
            }
            goto LABEL_147;
          }
          uint64_t v54 = *((void *)this + 43);
          if (v54) {
            (*(void (**)(uint64_t, CA::Render::Context *))(*(void *)v54 + 40))(v54, a2);
          }
          double v55 = *(double *)&v121;
          uint64_t v56 = v122;
          *((void *)this + 12) |= v123;
          double v57 = *((double *)this + 10);
          if (v57 >= v55)
          {
            if (v55 == 0.0 || v57 <= v55) {
              v56 |= *((void *)this + 11);
            }
            *((void *)this + 11) = v56;
            *((double *)this + 10) = v55;
          }
          if ((*v16 & 8) == 0)
          {
            memset(v108, 0, sizeof(v108));
            long long v109 = v96;
            v110 &= 0xF0u;
            uint64_t v111 = 0;
            uint64_t v112 = 0;
            char v116 = -1;
            uint64_t v114 = 0;
            uint64_t v115 = 0;
            uint64_t v113 = v107;
            v117 &= 0x40u;
            CA::Render::Updater::prepare_layer(&v101, (const CA::Render::Layer *)v108, (uint64_t)v48, (uint64_t)v100, &v107);
          }
          float64x2_t v58 = (CA::Shape **)&v105;
          if (v106 != &v105) {
            CA::Render::Updater::prepare_transform_layers((uint64_t)&v101, (CA::Render::LayerNode *)&v105);
          }
          if (v99)
          {
            int v59 = *(_DWORD *)(v99 + 120);
            if (v59 >= *(_DWORD *)(v99 + 124)) {
              int v59 = *(_DWORD *)(v99 + 124);
            }
            if (v59 <= 0
              && (*v16 & 8) == 0
              && (*((unsigned char *)this + 271) & 0x10) == 0
              && (*((unsigned char *)v48 + 26) & 0x40) == 0)
            {
LABEL_130:
              if ((*v16 & 4) == 0)
              {
                *((void *)a2 + 70) = *((void *)this + 9);
                float64x2_t v80 = (CA::Shape **)*((void *)a2 + 72);
                float64x2_t v81 = (CA::Shape **)((char *)this + 16);
                if (v80) {
                  CA::shape_union(v81, v80, v53);
                }
                else {
                  CA::shape_union(v81, (CA::Shape **)a2 + 73, v53);
                }
                if ((*v16 & 0x400000) != 0)
                {
                  float64x2_t v84 = (CA::Shape *)*((void *)v48 + 28);
                  if (v84)
                  {
                    v108[0] = (CA::Shape **)CA::Shape::subtract(v84, *((const CA::Shape **)this + 5), (uint64_t)v82, v83);
                    CA::shape_intersect((CA::Shape **)v108, (CA::Shape **)this + 24, v85);
                    float64x2_t v86 = (CA::Shape *)v108[0];
                    CA::shape_union((CA::Shape **)this + 4, v108[0], v87);
                    CA::Shape::unref(v86);
                  }
                  float64x2_t v58 = (CA::Shape **)*((void *)v48 + 29);
                  if (v58) {
                    CA::shape_union((CA::Shape **)this + 5, v58, v82);
                  }
                }
                float64x2_t v88 = (CA::Shape *)*((void *)a2 + 72);
                if (v88) {
                  CA::Shape::unref(v88);
                }
                *((void *)a2 + 72) = 1;
              }
              if (!v99 && atomic_fetch_add(v48 + 4, 0xFFFFFFFF) == 1) {
                CA::Render::LayerNode::delete_node((CA::Render::LayerNode *)v48, (CA::Render::LayerNode *)v58);
              }
              if (BYTE4(v102)) {
                *v16 |= 0x20000u;
              }
LABEL_147:
              uint64_t v89 = *(void *)&v126[3];
              if (*(void *)&v126[3]
                && atomic_fetch_add((atomic_uint *volatile)(*(void *)&v126[3] + 8), 0xFFFFFFFF) == 1)
              {
                (*(void (**)(uint64_t))(*(void *)v89 + 16))(v89);
              }
              goto LABEL_13;
            }
          }
          uint64_t v60 = *((void *)this + 27);
          *((void *)v48 + 1) = (char *)this + 216;
          *((void *)this + 27) = v48;
          *(void *)float64x2_t v48 = v60;
          *(void *)(v60 + 8) = v48;
          atomic_fetch_add(v48 + 4, 1u);
          uint64_t v61 = x_heap_malloc_small_(*(uint64_t **)this, 0x10uLL);
          *(_DWORD *)(v61 + 8) = *((_DWORD *)a2 + 4);
          *(void *)uint64_t v61 = 0;
          float64x2_t v64 = (uint64_t *)((char *)this + 208);
          do
          {
            double v65 = v64;
            float64x2_t v64 = (uint64_t *)*v64;
          }
          while (v64);
          uint64_t *v65 = v61;
          int v66 = HIDWORD(v125);
          uint64_t v67 = *(void *)((unsigned char *)&v125 + 12) & 0x28000;
          if ((*(void *)((unsigned char *)&v125 + 12) & 0x28000) != 0) {
            *((_DWORD *)this + 67) |= 2u;
          }
          if ((v66 & 0x40000) != 0) {
            *((_DWORD *)this + 67) |= 4u;
          }
          uint64_t v68 = v107;
          if ((v107 & 0x1000000) != 0) {
            *((_DWORD *)this + 67) |= 0x20u;
          }
          if ((v68 & 0x400000) != 0 || v67 && (*v16 & 0x40000) == 0) {
            *((_DWORD *)this + 67) |= 8u;
          }
          if ((v68 & 0x800000) != 0)
          {
            *((_DWORD *)this + 67) |= 0x10u;
            uint64_t v69 = *v16;
            unint64_t v70 = v69 & 0xFFFFFFFFFFFBFFFFLL | ((unint64_t)*((unsigned __int16 *)this + 544) << 32);
            *double v16 = v69 & 0xFFFBFFFF;
            *((_WORD *)this + 544) = WORD2(v70);
          }
          if ((v68 & 0xC0000000) != 0) {
            *((_DWORD *)this + 67) |= 0x1000u;
          }
          if ((v68 & 0x600000000) != 0) {
            *((_DWORD *)this + 67) |= 0x2000u;
          }
          if ((v68 & 0x7800000000) != 0) {
            *((_DWORD *)this + 67) |= 0x8000u;
          }
          if ((v68 & 0x1800000000) != 0) {
            *((_DWORD *)this + 67) |= 0x10000u;
          }
          if ((v68 & 0x4000000000000) != 0) {
            *((_DWORD *)this + 67) |= 0x20000u;
          }
          if ((v68 & 0x18000000000) != 0) {
            *((_DWORD *)this + 67) |= 0x80000u;
          }
          unint64_t v71 = v68 & 0x3800000000000;
          if (v71)
          {
            *((_DWORD *)this + 67) |= 0x4000u;
            *((void *)this + 36) |= v71 >> 47;
          }
          uint64_t v72 = *((void *)v48 + 26);
          if (v72)
          {
            if (v72)
            {
              if (v72 == 1) {
                goto LABEL_125;
              }
            }
            else if (*(_DWORD *)(v72 + 4) == 6)
            {
              goto LABEL_125;
            }
            if ((*v16 & 8) == 0)
            {
              if (!*v98)
              {
                if ((*v16 & 4) != 0) {
                  unint64_t v73 = CA::Shape::new_shape((unsigned int *)&v100[120]);
                }
                else {
                  unint64_t v73 = CA::Shape::ref(*((void *)a2 + 71));
                }
                *long long v98 = v73;
                uint64_t v72 = *((void *)v48 + 26);
              }
              CA::shape_subtract((CA::Shape **)v98, (CA::Shape **)v72, v62, v63);
              for (uint64_t i = (uint64_t *)*((void *)this + 63); i; uint64_t i = (uint64_t *)*i)
              {
                int v76 = *((_DWORD *)i + 24);
                if ((v76 & 0x40000000) == 0 && (v76 & 0xFFFFFFFu) > v97) {
                  CA::shape_union((CA::Shape **)v98, (CA::Shape **)(*(void *)(i[1] + 256) + 48), v74);
                }
              }
            }
          }
LABEL_125:
          float64x2_t v77 = (__int32 *)*((void *)this + 116);
          float64x2_t v78 = wmemchr(*((__int32 **)this + 115), *((_DWORD *)a2 + 66), ((uint64_t)v77 - *((void *)this + 115)) >> 2);
          if (v78) {
            float64x2_t v79 = v78;
          }
          else {
            float64x2_t v79 = v77;
          }
          if (v79 == *((__int32 **)this + 116))
          {
            LODWORD(v108[0]) = *((_DWORD *)a2 + 66);
            X::small_vector_base<unsigned int>::push_back((uint64_t)this + 920, v108);
          }
          goto LABEL_130;
        }
        *((void *)v48 + 5) = 0;
        uint64_t v47 = v99;
        if (atomic_fetch_add(v48 + 4, 0xFFFFFFFF) == 1) {
          CA::Render::LayerNode::delete_node((CA::Render::LayerNode *)v48, v11);
        }
      }
      float64x2_t v48 = (atomic_uint *)CA::Render::LayerNodeAllocator::alloc_node((CA::Render::LayerNodeAllocator *)bounds);
      *((void *)v48 + 5) = v47;
      *(void *)(v47 + 40) = v48;
      *(_DWORD *)(v47 + 12) = *(_DWORD *)(v47 + 12) & 0xFFFFFDFF | (((*v16 >> 27) & 1) << 9);
      *(void *)(v47 + 96) |= 4uLL;
      goto LABEL_48;
    }
  }
LABEL_13:
  if (v9) {
    kdebug_trace();
  }
}

BOOL CA::Render::Update::allowed_in_update(CA::Render::Update *this, CA::Render::Context *a2, const CA::Render::Layer *a3)
{
  uint64_t v4 = *((unsigned int *)this + 271);
  unint64_t v5 = v4 | ((unint64_t)*((unsigned __int16 *)this + 544) << 32);
  unsigned int v6 = (*((_DWORD *)a3 + 9) >> 20) & 0x100;
  if ((v4 & 0x100) == 0) {
    unsigned int v6 = (*((_DWORD *)a3 + 9) >> 20) & 0x7FF;
  }
  if (v6)
  {
    if ((v4 & 0x50000000) == 0x10000000 && (v6 & 2) != 0) {
      return 0;
    }
    int v8 = *((_DWORD *)this + 68) & 0x10000;
    if ((v6 & 4) != 0)
    {
      if (v8) {
        return 0;
      }
    }
    if ((v6 & 8) != 0 && !v8
      || (v4 & 0x40000000) != 0 && (v6 & 0x20) != 0 && (*((_WORD *)a2 + 276) & 8) != 0
      || (v4 & 0x80) != 0 && (v6 & 0x40) != 0)
    {
      return 0;
    }
    if ((v5 & 0x200000000) != 0
      && ((v6 & 0x100) != 0 || (v6 & 0x10) != 0 && ((v6 > 0x3FF) & (v4 >> 9)) == 0))
    {
      BOOL result = 0;
      *((_DWORD *)this + 271) = v5;
      *((_WORD *)this + 544) = (v5 | 0x400000000) >> 32;
      return result;
    }
    if ((v4 & 0x20000000) != 0 && (v6 & 0x200) != 0) {
      return 0;
    }
  }
  if ((v4 & 4) == 0) {
    return 1;
  }
  uint64_t v10 = *((void *)a3 + 16);
  if (!v10) {
    return 1;
  }
  uint64_t v11 = *(void *)(v10 + 144);
  if (!v11) {
    return 1;
  }
  if (!*((void *)this + 114)) {
    return 1;
  }
  uint64_t v12 = *(unsigned int *)(v11 + 16);
  if (!v12) {
    return 1;
  }
  int32x4_t v13 = (CA::Render::String **)(v11 + 24);
  uint64_t v14 = 8 * v12 - 8;
  do
  {
    unint64_t v15 = *v13++;
    CFSetRef v16 = (const __CFSet *)*((void *)this + 114);
    int v17 = (const void *)CA::Render::String::unsafe_cf_string(v15);
    int v18 = CFSetContainsValue(v16, v17);
    BOOL result = v18 == 0;
    if (v18) {
      BOOL v19 = 1;
    }
    else {
      BOOL v19 = v14 == 0;
    }
    v14 -= 8;
  }
  while (!v19);
  return result;
}

uint64_t CA::Render::Update::allowed_to_include_context(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 344);
  if (!v4 || (uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v4 + 32))(v4, a2), result))
  {
    int v6 = *(_DWORD *)(a1 + 316);
    if (v6)
    {
      unsigned int v7 = atomic_load((unsigned int *)(a2 + 228));
      if (!v7)
      {
        if (*(_DWORD *)(a2 + 252)) {
          pid_t v8 = 0;
        }
        else {
          pid_t v8 = getpid();
        }
        unsigned int v7 = 0;
        atomic_compare_exchange_strong((atomic_uint *volatile)(a2 + 228), &v7, v8);
        if (!v7) {
          unsigned int v7 = v8;
        }
      }
      return v6 == v7;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t CA::Render::Update::allowed_in_secure_update(CA::Render::Update *this, CA::Render::Context *a2, const CA::Render::LayerHost *a3)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  __int16 v3 = *((_DWORD *)this + 271);
  if ((*((_DWORD *)this + 271) & 0x80) == 0) {
    return 1;
  }
  if ((*((_WORD *)a2 + 276) & 4) != 0) {
    return 1;
  }
  if (a3)
  {
    uint64_t v7 = *((void *)a3 + 10);
    if (v7)
    {
      if ((*(_WORD *)(v7 + 552) & 4) != 0 && (*((unsigned char *)a3 + 13) & 2) != 0) {
        return 1;
      }
    }
  }
  uint64_t result = 0;
  if ((*((unsigned char *)a2 + 14) & 4) == 0 && (v3 & 4) == 0)
  {
    x_log_begin();
    if (x_log_hook_p())
    {
      if (!atomic_load((unsigned int *)a2 + 57))
      {
        if (*((_DWORD *)a2 + 63)) {
          pid_t v10 = 0;
        }
        else {
          pid_t v10 = getpid();
        }
        int v15 = 0;
        atomic_compare_exchange_strong((atomic_uint *volatile)a2 + 57, (unsigned int *)&v15, v10);
      }
      CA::Render::Context::process_path(a2);
      x_log_();
    }
    else
    {
      uint64_t v11 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
      {
        int v12 = *((_DWORD *)a2 + 4);
        unsigned int v13 = atomic_load((unsigned int *)a2 + 57);
        if (!v13)
        {
          if (*((_DWORD *)a2 + 63)) {
            pid_t v14 = 0;
          }
          else {
            pid_t v14 = getpid();
          }
          unsigned int v16 = 0;
          atomic_compare_exchange_strong((atomic_uint *volatile)a2 + 57, &v16, v14);
          if (v16) {
            unsigned int v13 = v16;
          }
          else {
            unsigned int v13 = v14;
          }
        }
        *(_DWORD *)buf = 67109634;
        *(_DWORD *)uint64_t v45 = v12;
        *(_WORD *)&v45[4] = 1024;
        *(_DWORD *)&v45[6] = v13;
        LOWORD(v46) = 2080;
        *(void *)((char *)&v46 + 2) = CA::Render::Context::process_path(a2) + 7;
        _os_log_impl(&dword_184668000, v11, OS_LOG_TYPE_ERROR, "CoreAnimation: insecure context %x - pid %u [%s].\n", buf, 0x18u);
        if (!a3)
        {
LABEL_46:
          uint64_t v43 = a3;
          long long v42 = (void **)x_stream_pop_(0);
          int64x2_t v29 = x_stream_get(v42);
          int v30 = 0;
LABEL_47:
          uint64_t v31 = 0;
          int64x2_t v32 = &v29[v30];
          int v33 = -1;
          while (1)
          {
            if (v32[v31] == 10)
            {
              int v33 = v31;
            }
            else if (!v32[v31])
            {
              unsigned int v34 = v31;
LABEL_53:
              if (v33 <= -1 || v32[v34] == 0) {
                int v36 = v34;
              }
              else {
                int v36 = v33 + 1;
              }
              if (v36 > 0)
              {
                if (x_log_hook_p())
                {
                  x_log_();
                }
                else
                {
                  uint64_t v37 = x_log_category_render;
                  if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = 136315650;
                    if (v30) {
                      long long v38 = "continued...\n";
                    }
                    else {
                      long long v38 = "";
                    }
                    *(void *)uint64_t v45 = v38;
                    *(_WORD *)&v45[8] = 1040;
                    LODWORD(v46) = v36;
                    WORD2(v46) = 2080;
                    *(void *)((char *)&v46 + 6) = &v29[v30];
                    _os_log_impl(&dword_184668000, v37, OS_LOG_TYPE_ERROR, "%s%.*s", buf, 0x1Cu);
                  }
                }
                v30 += v36;
                goto LABEL_47;
              }
              x_log_end_free_(v42);
              if (v43)
              {
                uint64_t v39 = *((void *)v43 + 10);
                if (v39)
                {
                  unsigned int v40 = atomic_load((unsigned int *)(v39 + 228));
                  if (!v40)
                  {
                    unsigned int v41 = *(_DWORD *)(v39 + 252) ? 0 : getpid();
                    unsigned int v40 = 0;
                    atomic_compare_exchange_strong((atomic_uint *volatile)(v39 + 228), &v40, v41);
                    if (!v40) {
                      unsigned int v40 = v41;
                    }
                  }
                  *((_DWORD *)a2 + 75) = v40;
                  *((_DWORD *)a2 + 76) = *(_DWORD *)(*((void *)v43 + 10) + 16);
                }
              }
              uint64_t result = 0;
              *((_DWORD *)a2 + 3) |= 0x40000u;
              *((_DWORD *)this + 67) |= 0x200u;
              return result;
            }
            ++v31;
            unsigned int v34 = 32512;
            if (v31 == 32512) {
              goto LABEL_53;
            }
          }
        }
LABEL_29:
        if (*((void *)a3 + 10))
        {
          if (x_log_hook_p())
          {
            uint64_t v17 = *((void *)a3 + 10);
            if (!atomic_load((unsigned int *)(v17 + 228)))
            {
              if (*(_DWORD *)(v17 + 252)) {
                pid_t v19 = 0;
              }
              else {
                pid_t v19 = getpid();
              }
              int v26 = 0;
              atomic_compare_exchange_strong((atomic_uint *volatile)(v17 + 228), (unsigned int *)&v26, v19);
            }
            CA::Render::Context::process_path(*((CA::Render::Context **)a3 + 10));
            x_log_();
          }
          else
          {
            int32x4_t v20 = x_log_category_render;
            if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
            {
              int v21 = *((_DWORD *)a2 + 4);
              int64x2_t v22 = (_DWORD *)*((void *)a3 + 10);
              int v23 = v22[4];
              unsigned int v24 = atomic_load(v22 + 57);
              if (!v24)
              {
                if (v22[63]) {
                  pid_t v25 = 0;
                }
                else {
                  pid_t v25 = getpid();
                }
                unsigned int v27 = 0;
                atomic_compare_exchange_strong(v22 + 57, &v27, v25);
                if (v27) {
                  unsigned int v24 = v27;
                }
                else {
                  unsigned int v24 = v25;
                }
              }
              int32x2_t v28 = CA::Render::Context::process_path(*((CA::Render::Context **)a3 + 10));
              *(_DWORD *)buf = 67109890;
              *(_DWORD *)uint64_t v45 = v21;
              *(_WORD *)&v45[4] = 1024;
              *(_DWORD *)&v45[6] = v23;
              LOWORD(v46) = 1024;
              *(_DWORD *)((char *)&v46 + 2) = v24;
              WORD3(v46) = 2080;
              *((void *)&v46 + 1) = v28 + 7;
              _os_log_impl(&dword_184668000, v20, OS_LOG_TYPE_ERROR, "Cannot host %x in context %x - pid %u [%s].\n", buf, 0x1Eu);
            }
          }
        }
        goto LABEL_46;
      }
    }
    if (!a3) {
      goto LABEL_46;
    }
    goto LABEL_29;
  }
  return result;
}

void *CA::Render::Updater::apply_shapes_ops(void *this, CA::Render::Updater::LayerShapesOp *a2, CA::Rect *a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)a2;
  uint64_t v5 = *((void *)a2 + 1);
  uint64_t v9 = *(void *)a2;
  uint64_t v10 = v5;
  uint64_t v6 = *((void *)a2 + 2);
  uint64_t v7 = *((void *)a2 + 3);
  uint64_t v11 = v6;
  uint64_t v12 = v7;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  uint64_t v16 = 0;
  if (this)
  {
    pid_t v8 = this;
    do
    {
      this = (void *)(*(uint64_t (**)(void *, uint64_t *, void))(*v8 + 24))(v8, &v9, 0);
      pid_t v8 = (void *)v8[1];
    }
    while (v8);
    uint64_t v4 = v9;
    uint64_t v5 = v10;
    uint64_t v6 = v11;
    uint64_t v7 = v12;
  }
  *(void *)a2 = v4;
  *((void *)a2 + 1) = v5;
  *((void *)a2 + 2) = v6;
  *((void *)a2 + 3) = v7;
  return this;
}

void CA::Render::Updater::FlattenZOp::map_bounds(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
}

void CA::Render::Updater::FilterOp::map_bounds(CA::Render::Updater::FilterOp *this, CA::Render::Updater::LayerShapes *a2, int a3)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (*((void *)this + 5))
  {
    CA::Render::Updater::FilterOp::apply_filter(this, (__n128 *)a2, a3);
    if (*((void *)a2 + 8)) {
      CA::shape_map((CA::Shape **)a2 + 8, (CA::Shape **)this, (void (*)(CA::Rect *, void *))CA::Render::Updater::FilterOp::map_bounds(CA::Render::Updater::LayerShapes &,BOOL)::$_0::__invoke, v5, v6);
    }
  }
  uint64_t v7 = (CA::Shape *)*((void *)a2 + 7);
  if (v7)
  {
    if (v7)
    {
      if (v7 == (CA::Shape *)1) {
        goto LABEL_12;
      }
    }
    else if (*((_DWORD *)v7 + 1) == 6)
    {
      goto LABEL_12;
    }
    uint64_t v8 = *((void *)this + 5);
    if (!v8) {
      goto LABEL_11;
    }
    if (*((unsigned char *)this + 48)) {
      goto LABEL_11;
    }
    uint64_t v11 = *(void *)(v8 + 48);
    if (!v11) {
      goto LABEL_11;
    }
    if ((*(unsigned int (**)(void))(*(void *)v11 + 24))(*(void *)(v8 + 48)))
    {
      uint64_t v7 = (CA::Shape *)*((void *)a2 + 7);
LABEL_11:
      CA::Shape::unref(v7);
      *((void *)a2 + 7) = 1;
      goto LABEL_12;
    }
    uint64_t v12 = *(void *)(*((void *)this + 5) + 48);
    if (!v12 || ((*(uint64_t (**)(uint64_t))(*(void *)v12 + 32))(v12) & 1) == 0)
    {
      int32x4_t v29 = 0uLL;
      CA::Shape::get_interior_bounds(*((void *)a2 + 7), &v29);
      if (v29.i32[2] <= v29.i32[3]) {
        int v15 = v29.i32[3];
      }
      else {
        int v15 = v29.i32[2];
      }
      v13.i32[0] = 1073741822;
      v14.i32[0] = v15;
      v16.i64[0] = v29.i32[0];
      v16.i64[1] = v29.i32[1];
      double v17 = (double)v29.i32[2];
      __n128 v18 = (__n128)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v14, v13), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v16));
      double v19 = (double)v29.i32[3];
      if (v15 > 1073741822)
      {
        double v17 = 1.79769313e308;
        double v19 = 1.79769313e308;
      }
      float64x2_t v27 = (float64x2_t)v18;
      v28.f64[0] = v17;
      v28.f64[1] = v19;
      v18.n128_f64[0] = fmax(v17, v19);
      if (v18.n128_f64[0] < 1.79769313e308) {
        v18.n128_f64[0] = CA::Rect::unapply_transform(v27.f64, *((void *)this + 3));
      }
      uint64_t v20 = *(void *)(*((void *)this + 5) + 48);
      if (v20)
      {
        (*(void (**)(uint64_t, __n128))(*(void *)v20 + 56))(v20, v18);
        double v21 = v28.f64[1];
        double v22 = v28.f64[0];
      }
      else
      {
        float64x2_t v27 = 0u;
        float64x2_t v28 = 0u;
        double v21 = 0.0;
        double v22 = 0.0;
      }
      if (v22 > v21) {
        double v21 = v22;
      }
      if (v21 < 1.79769313e308) {
        CA::Rect::apply_transform(v27.f64, *((void *)this + 3));
      }
      int64x2_t v23 = vceqzq_f64(v28);
      if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v23, 1), (int8x16_t)v23).u64[0] & 0x8000000000000000) != 0
        || (int8x16_t v24 = vorrq_s8((int8x16_t)vcltzq_f64(v28), (int8x16_t)vcgezq_f64(v28)),
            (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v24), 1), v24).u64[0] & 0x8000000000000000) != 0))
      {
        int32x4_t v29 = 0uLL;
      }
      else
      {
        int32x4_t v25 = (int32x4_t)vcvtpq_s64_f64(vmaxnmq_f64(v27, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
        int32x4_t v29 = vuzp1q_s32(v25, (int32x4_t)vsubq_s64(vcvtmq_s64_f64(vminnmq_f64(vaddq_f64(v27, v28), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v25));
      }
      int v26 = (CA::Shape *)*((void *)a2 + 7);
      if (!CA::Shape::equal((uint64_t)v26, &v29))
      {
        CA::Shape::unref(v26);
        *((void *)a2 + 7) = CA::Shape::new_shape((unsigned int *)&v29);
      }
    }
  }
LABEL_12:
  if (*((void *)this + 5))
  {
    uint64_t v9 = *((void *)a2 + 6);
    if (v9)
    {
      *(unsigned char *)(v9 + 16) = 1;
      uint64_t v10 = *(void **)(v9 + 8);
      if (v10)
      {
        CA::GenericRectTree<CA::Rect>::Pool::delete_node(*(void *)v9, v10);
        *(void *)(v9 + 8) = 0;
      }
    }
  }
}

void CA::Render::Updater::TransformOp::map_bounds(CA::Render::Updater::TransformOp *this, CA::Render::Updater::LayerShapes *a2, double *a3)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  double v5 = *((double *)a2 + 4);
  double v6 = *((double *)a2 + 5);
  if (v5 == 0.0 && v6 == 0.0)
  {
    *(double *)v8.i64 = CA::Rect::apply_transform((int8x16_t *)a2, (CA::Render::Updater::TransformOp *)((char *)this + 24), a3);
  }
  else
  {
    float64x2_t v9 = *((float64x2_t *)a2 + 1);
    float64x2_t v29 = *(float64x2_t *)a2;
    *(float64x2_t *)&v30[8] = vaddq_f64(v9, v29);
    *(double *)uint64_t v30 = v5;
    double v31 = v6;
    CA::Volume::apply_transform((CA::Volume *)&v29, (float64x2_t *)((char *)this + 24), a3);
    uint64_t v10 = *(void *)&v29.f64[1];
    double v11 = *(double *)&v30[8] - v29.f64[0];
    double v12 = *(double *)&v30[16] - v29.f64[1];
    if (*(double *)&v30[8] - v29.f64[0] >= *(double *)&v30[16] - v29.f64[1]) {
      double v13 = *(double *)&v30[16] - v29.f64[1];
    }
    else {
      double v13 = *(double *)&v30[8] - v29.f64[0];
    }
    if (v13 <= 0.0)
    {
      v8.i64[1] = 0;
      *(_OWORD *)a2 = 0u;
      *((_OWORD *)a2 + 1) = 0u;
    }
    else
    {
      if (v11 <= v12) {
        double v14 = *(double *)&v30[16] - v29.f64[1];
      }
      else {
        double v14 = *(double *)&v30[8] - v29.f64[0];
      }
      if (v14 >= 1.79769313e308)
      {
        int32x4_t v8 = (int32x4_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
        *(int32x4_t *)a2 = v8;
        *((int64x2_t *)a2 + 1) = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      }
      else
      {
        *(float64_t *)a2 = v29.f64[0];
        *((void *)a2 + 1) = v10;
        *((double *)a2 + 2) = v11;
        *((double *)a2 + 3) = v12;
      }
    }
    v8.i64[0] = *(void *)v30;
    double v15 = v31;
    *((void *)a2 + 4) = *(void *)v30;
    *((double *)a2 + 5) = v15;
  }
  if (!*((unsigned char *)this + 176)) {
    CA::BoundsImpl::inset((double *)a2, -1.0, -1.0);
  }
  uint64_t v16 = *((void *)a2 + 7);
  if (v16)
  {
    if (v16)
    {
      if (v16 == 1) {
        goto LABEL_38;
      }
    }
    else if (*(_DWORD *)(v16 + 4) == 6)
    {
      goto LABEL_38;
    }
    int32x4_t v28 = 0uLL;
    CA::Shape::get_interior_bounds(v16, &v28);
    if (v28.i32[2] <= v28.i32[3]) {
      int v19 = v28.i32[3];
    }
    else {
      int v19 = v28.i32[2];
    }
    v17.i32[0] = 1073741822;
    v18.i32[0] = v19;
    v20.i64[0] = v28.i32[0];
    v20.i64[1] = v28.i32[1];
    int8x16_t v21 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v18, v17), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v20));
    double v22 = (double)v28.i32[2];
    if (v19 > 1073741822) {
      double v22 = 1.79769313e308;
    }
    float64x2_t v29 = (float64x2_t)v21;
    if (v19 <= 1073741822) {
      double v23 = (double)v28.i32[3];
    }
    else {
      double v23 = 1.79769313e308;
    }
    *(double *)uint64_t v30 = v22;
    *(double *)&v30[8] = v23;
    CA::Rect::apply_transform_interior((int8x16_t *)&v29, (CA::Render::Updater::TransformOp *)((char *)this + 24));
    int64x2_t v24 = vceqzq_f64(*(float64x2_t *)v30);
    if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v24, 1), (int8x16_t)v24).u64[0] & 0x8000000000000000) != 0
      || (int8x16_t v25 = vorrq_s8((int8x16_t)vcltzq_f64(*(float64x2_t *)v30), (int8x16_t)vcgezq_f64(*(float64x2_t *)v30)),
          (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v25), 1), v25).u64[0] & 0x8000000000000000) != 0))
    {
      int32x4_t v28 = 0uLL;
    }
    else
    {
      int32x4_t v26 = (int32x4_t)vcvtpq_s64_f64(vmaxnmq_f64(v29, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
      int32x4_t v28 = vuzp1q_s32(v26, (int32x4_t)vsubq_s64(vcvtmq_s64_f64(vminnmq_f64(vaddq_f64(v29, *(float64x2_t *)v30), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v26));
    }
    if (!*((unsigned char *)this + 176)) {
      CA::BoundsImpl::inset((double *)a2, 1.0, 1.0);
    }
    CA::Shape::unref(*((CA::Shape **)a2 + 7));
    *((void *)a2 + 7) = CA::Shape::new_shape((unsigned int *)&v28);
  }
LABEL_38:
  if (*((void *)a2 + 8)) {
    CA::shape_map((CA::Shape **)a2 + 8, (CA::Shape **)this, (void (*)(CA::Rect *, void *))CA::Render::Updater::TransformOp::map_bounds(CA::Render::Updater::LayerShapes &,BOOL)::$_0::__invoke, v7, v8);
  }
  uint64_t v27 = *((void *)a2 + 6);
  if (v27)
  {
    if (*(void *)(v27 + 8)) {
      *(unsigned char *)(v27 + 17) = 1;
    }
  }
}

void CA::Render::Updater::FilterOp::apply_filter(CA::Render::Updater::FilterOp *this, __n128 *a2, int a3)
{
  __n128 v6 = a2[1];
  double v7 = a2[1].n128_f64[1];
  float64x2_t v18 = *(float64x2_t *)a2;
  float64x2_t v19 = (float64x2_t)v6;
  if (v6.n128_f64[0] <= v7) {
    v6.n128_u64[0] = a2[1].n128_u64[1];
  }
  if (v6.n128_f64[0] < 1.79769313e308) {
    v6.n128_f64[0] = CA::Rect::unapply_transform(a2->n128_f64, *((void *)this + 3));
  }
  uint64_t v8 = *((void *)this + 5);
  uint64_t v9 = *(void *)(v8 + 48);
  if (v9)
  {
    uint64_t v10 = *((void *)this + 4);
    if (((*(uint64_t (**)(void, void, uint64_t, __n128))(*(void *)v9 + 8))(*(void *)(v8 + 48), *((void *)this + 5), v10, v6) & 1) == 0)(*(void (**)(uint64_t, uint64_t, uint64_t, __n128 *))(*(void *)v9 + 48))(v9, v8, v10, a2); {
  }
    }
  double v11 = a2[1].n128_f64[0];
  if (v11 <= a2[1].n128_f64[1]) {
    double v11 = a2[1].n128_f64[1];
  }
  if (v11 < 1.79769313e308) {
    CA::Rect::apply_transform(a2->n128_f64, *((void *)this + 3));
  }
  if (*((unsigned char *)this + 48) || a3)
  {
    float64x2_t v12 = (float64x2_t)a2[1];
    int64x2_t v13 = vclezq_f64(v12);
    int64x2_t v14 = vclezq_f64(v19);
    int32x2_t v15 = vmovn_s64(vcltzq_s64((int64x2_t)vorrq_s8((int8x16_t)vzip1q_s64(v14, v13), (int8x16_t)vzip2q_s64(v14, v13))));
    if (v15.i8[4])
    {
      if (v15.i8[0]) {
        return;
      }
      *a2 = (__n128)v18;
      a2[1].n128_u64[0] = *(void *)&v19.f64[0];
    }
    else
    {
      if (v15.i8[0]) {
        return;
      }
      float64x2_t v16 = vminnmq_f64(*(float64x2_t *)a2, v18);
      float64x2_t v17 = vsubq_f64(vmaxnmq_f64(vaddq_f64(*(float64x2_t *)a2, v12), vaddq_f64(v18, v19)), v16);
      *a2 = (__n128)v16;
      a2[1].n128_u64[0] = *(void *)&v17.f64[0];
      double v7 = v17.f64[1];
    }
    a2[1].n128_f64[1] = v7;
  }
}

double CA::Rect::unapply_transform(double *a1, uint64_t a2)
{
  double v3 = a1[2];
  double result = a1[3];
  if (v3 <= result) {
    double v4 = a1[3];
  }
  else {
    double v4 = a1[2];
  }
  if (v4 < 1.79769313e308)
  {
    double v5 = a1[1];
    double v6 = *a1 - *(double *)a2;
    *a1 = v6;
    double v7 = v5 - *(double *)(a2 + 8);
    a1[1] = v7;
    char v8 = *(unsigned char *)(a2 + 32);
    if (v8)
    {
      double v7 = -(v7 + result);
      a1[1] = v7;
      char v8 = *(unsigned char *)(a2 + 32);
      if ((v8 & 2) == 0)
      {
LABEL_7:
        if ((v8 & 4) == 0) {
          goto LABEL_8;
        }
        goto LABEL_12;
      }
    }
    else if ((*(unsigned char *)(a2 + 32) & 2) == 0)
    {
      goto LABEL_7;
    }
    double v6 = -(v6 + v3);
    *a1 = v6;
    char v8 = *(unsigned char *)(a2 + 32);
    if ((v8 & 4) == 0)
    {
LABEL_8:
      double v9 = result;
      double result = v3;
      double v10 = v7;
      double v7 = v6;
      if ((v8 & 8) == 0) {
        return result;
      }
LABEL_13:
      *a1 = v7 * *(double *)(a2 + 24);
      a1[1] = v10 * *(double *)(a2 + 24);
      a1[2] = result * *(double *)(a2 + 24);
      double result = v9 * *(double *)(a2 + 24);
      a1[3] = result;
      return result;
    }
LABEL_12:
    double v10 = -(v6 + v3);
    *a1 = v7;
    a1[1] = v10;
    a1[2] = result;
    a1[3] = v3;
    double v9 = v3;
    if ((*(unsigned char *)(a2 + 32) & 8) == 0) {
      return result;
    }
    goto LABEL_13;
  }
  return result;
}

uint64_t CA::Render::FilterSubclass::identity_DOD()
{
  return 0;
}

void CA::Render::LayerNode::MapPoints::apply(uint64_t a1, float64x2_t *this, double *a3)
{
  if (*(void *)(a1 + 8))
  {
    uint64_t v5 = 0;
    unint64_t v6 = 0;
    do
    {
      CA::Mat4Impl::mat4_apply_to_point2(this, (double *)(*(void *)(a1 + 16) + v5), a3);
      ++v6;
      v5 += 16;
    }
    while (v6 < *(void *)(a1 + 8));
  }
}

void CA::Mat4Impl::mat4_apply_to_rect(float64x2_t *this, int8x16_t *a2, double *a3)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  double v4 = *(double *)a2[1].i64;
  double v3 = *(double *)&a2[1].i64[1];
  if (v4 <= v3) {
    double v5 = *(double *)&a2[1].i64[1];
  }
  else {
    double v5 = *(double *)a2[1].i64;
  }
  if (v5 < 1.79769313e308)
  {
    uint64_t v8 = 0;
    double v9 = *(double *)&a2->i64[1];
    *(void *)&v22.f64[0] = a2->i64[0];
    v22.f64[1] = v9;
    v23.f64[0] = v4 + v22.f64[0];
    v23.f64[1] = v9;
    v24.f64[0] = v4 + v22.f64[0];
    v24.f64[1] = v3 + v9;
    v25.f64[0] = v22.f64[0];
    v25.f64[1] = v3 + v9;
    do
    {
      CA::Mat4Impl::mat4_apply_to_point2(this, &v22.f64[v8], a3);
      v8 += 2;
    }
    while (v8 != 8);
    int8x16_t v10 = vbslq_s8((int8x16_t)vcgtq_f64(v23, v22), (int8x16_t)v22, (int8x16_t)v23);
    int8x16_t v11 = vbslq_s8((int8x16_t)vcgtq_f64(v22, v23), (int8x16_t)v22, (int8x16_t)v23);
    int8x16_t v12 = vbslq_s8((int8x16_t)vcgtq_f64(v25, v24), (int8x16_t)v24, (int8x16_t)v25);
    int64x2_t v13 = (int64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v24, v25), (int8x16_t)v24, (int8x16_t)v25);
    int8x16_t v14 = vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v12, (float64x2_t)v10), v10, v12);
    int64x2_t v15 = vcgtq_f64((float64x2_t)v11, (float64x2_t)v13);
    int8x16_t v16 = (int8x16_t)vsubq_f64((float64x2_t)vbslq_s8((int8x16_t)v15, v11, (int8x16_t)v13), (float64x2_t)v14);
    *(double *)v13.i64 = vaddvq_f64((float64x2_t)v16);
    BOOL v17 = (v13.i64[0] & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000;
    v13.i64[0] &= ~0x8000000000000000;
    v15.i64[0] = 0x7FF0000000000000;
    int8x16_t v18 = vbslq_s8((int8x16_t)vdupq_lane_s64(vcgtq_s64(v15, v13).i64[0], 0), v16, (int8x16_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL));
    unsigned int v19 = v17;
    int32x2_t v20 = vdup_n_s32(v19);
    v21.i64[0] = v20.u32[0];
    v21.i64[1] = v20.u32[1];
    *a2 = vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v21, 0x3FuLL)), v14, (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL));
    a2[1] = v18;
  }
}

float64x2_t CA::Mat4Impl::mat4_apply_to_point2(float64x2_t *this, double *a2, double *a3)
{
  double v3 = a2[1];
  double v4 = this[7].f64[1] + this[1].f64[1] * *a2 + this[3].f64[1] * v3;
  if (fabs(v4 + -1.0) >= 0.000001)
  {
    if (v4 <= 0.0) {
      double v4 = INFINITY;
    }
    else {
      double v4 = 1.0 / v4;
    }
  }
  float64x2_t result = vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(this[6], *this, *a2), this[2], v3), v4);
  *(float64x2_t *)a2 = result;
  return result;
}

BOOL CA::Shape::equal(uint64_t a1, _DWORD *a2)
{
  if (a1)
  {
    if (a1 == 1) {
      goto LABEL_7;
    }
    uint64_t v3 = a1 >> 48;
    uint64_t v4 = a1 << 16 >> 48;
    unsigned int v5 = a1 >> 17;
    unsigned int v6 = (a1 >> 2) & 0x7FFF;
  }
  else
  {
    int v2 = *(_DWORD *)(a1 + 4);
    if (v2 != 12)
    {
      if (v2 != 6) {
        return 0;
      }
LABEL_7:
      int v7 = a2[2];
      if (v7 >= a2[3]) {
        int v7 = a2[3];
      }
      return v7 < 1;
    }
    LODWORD(v4) = *(_DWORD *)(a1 + 20);
    LODWORD(v3) = *(_DWORD *)(a1 + 28);
    unsigned int v5 = *(_DWORD *)(a1 + 32) - v3;
    unsigned int v6 = *(_DWORD *)(a1 + 36) - v4;
  }
  if (*a2 != v3 || a2[1] != v4 || a2[2] != v5) {
    return 0;
  }
  return a2[3] == v6;
}

void X::small_vector_base<unsigned int>::push_back(uint64_t a1, _DWORD *a2)
{
  uint64_t v4 = *(_DWORD **)(a1 + 8);
  unint64_t v5 = (((uint64_t)v4 - *(void *)a1) >> 2) + 1;
  if (*(void *)(a1 + 24) < v5)
  {
    X::small_vector_base<unsigned int>::grow((int **)a1, v5);
    uint64_t v4 = *(_DWORD **)(a1 + 8);
  }
  *uint64_t v4 = *a2;
  *(void *)(a1 + 8) = v4 + 1;
}

void applyRect(int8x16_t *a1, float64x2_t *this, double *a3)
{
}

double unapplyVec2r(double *a1, float64x2_t *this, double *a3)
{
  *(void *)&double result = *(_OWORD *)&CA::Mat4Impl::mat4_unapply_inverse_to_point2(this, a1, a3);
  return result;
}

void CA::shape_map(CA::Shape **this, CA::Shape **a2, void (*a3)(CA::Rect *, void *), void (*a4)(CA::Rect *, void *), int32x4_t a5)
{
  unsigned int v6 = *this;
  if (*this)
  {
    if (v6 == (CA::Shape *)1) {
      return;
    }
    goto LABEL_5;
  }
  if (*((_DWORD *)v6 + 1) != 6)
  {
LABEL_5:
    uint64_t v7 = CA::Shape::map(*this, a2, a3, a5);
    CA::Shape::unref(v6);
    *this = (CA::Shape *)v7;
  }
}

uint64_t CA::Shape::map(CA::Shape *this, void *a2, void (*a3)(CA::Rect *, void *), int32x4_t a4)
{
  v25[3] = *MEMORY[0x1E4F143B8];
  uint64_t v24 = 1;
  v25[0] = (uint64_t)this;
  v23[0] = 0;
  v23[1] = 0;
  v25[1] = 0;
  v25[2] = 0;
  a4.i32[0] = 1073741822;
  int32x4_t v20 = a4;
  float64x2_t v18 = (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000);
  int8x16_t v19 = (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
  float64x2_t v17 = (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL);
  while (CA::ShapeIterator::iterate(v25, (int *)v23))
  {
    if (SLODWORD(v23[1]) <= SHIDWORD(v23[1])) {
      int v7 = HIDWORD(v23[1]);
    }
    else {
      int v7 = (int)v23[1];
    }
    v6.i32[0] = v7;
    v8.i64[0] = SLODWORD(v23[0]);
    v8.i64[1] = SHIDWORD(v23[0]);
    int8x16_t v9 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v6, v20), 0), v19, (int8x16_t)vcvtq_f64_s64(v8));
    double v10 = (double)SLODWORD(v23[1]);
    if (v7 > 1073741822) {
      double v10 = 1.79769313e308;
    }
    float64x2_t v21 = (float64x2_t)v9;
    if (v7 <= 1073741822) {
      double v11 = (double)SHIDWORD(v23[1]);
    }
    else {
      double v11 = 1.79769313e308;
    }
    v22.f64[0] = v10;
    v22.f64[1] = v11;
    a3((CA::Rect *)&v21, a2);
    int64x2_t v13 = vceqzq_f64(v22);
    if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v13, 1), (int8x16_t)v13).u64[0] & 0x8000000000000000) != 0
      || (int8x16_t v14 = vorrq_s8((int8x16_t)vcltzq_f64(v22), (int8x16_t)vcgezq_f64(v22)),
          (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v14), 1), v14).u64[0] & 0x8000000000000000) != 0))
    {
      v23[0] = 0;
      v23[1] = 0;
    }
    else
    {
      int32x4_t v15 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v21, v18));
      *(int32x4_t *)float64x2_t v23 = vuzp1q_s32(v15, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v21, v22), v17)), (int64x2_t)v15));
    }
    CA::shape_union((CA::Shape **)&v24, v23, v12);
  }
  return v24;
}

uint64_t CA::Shape::get_interior_bounds(uint64_t result, _DWORD *a2)
{
  if (result)
  {
    *a2 = result >> 48;
    a2[1] = (int)((unint64_t)result >> 16) >> 16;
    a2[2] = result >> 17;
    a2[3] = (result >> 2) & 0x7FFF;
  }
  else
  {
    int v2 = *(_DWORD *)(result + 4);
    if (v2 == 12)
    {
      *a2 = *(_DWORD *)(result + 28);
      a2[1] = *(_DWORD *)(result + 20);
      a2[2] = *(_DWORD *)(result + 32) - *(_DWORD *)(result + 28);
      a2[3] = *(_DWORD *)(result + 36) - *(_DWORD *)(result + 20);
    }
    else if (v2 == 6)
    {
      *(void *)a2 = 0;
      *((void *)a2 + 1) = 0;
    }
    else
    {
      int v4 = *(_DWORD *)(result + 12);
      result += 12;
      int v3 = v4;
      if (v4 != 0x7FFFFFFF)
      {
        uint64_t v5 = -1;
        do
        {
          uint64_t v6 = result;
          uint64_t v7 = *(int *)(result + 4);
          result += 4 * v7;
          int v8 = v7 - 2;
          int v9 = *(_DWORD *)result;
          if (v8 >= 2)
          {
            int v10 = v8 >> 1;
            int v11 = v9 - v3;
            int8x16_t v12 = (_DWORD *)(v6 + 12);
            do
            {
              int v13 = *(v12 - 1);
              int v14 = *v12 - v13;
              if (v5 < v14 * v11)
              {
                uint64_t v5 = v14 * v11;
                *a2 = v13;
                a2[1] = v3;
                a2[2] = v14;
                a2[3] = v11;
              }
              v12 += 2;
              --v10;
            }
            while (v10);
            int v9 = *(_DWORD *)result;
          }
          int v3 = v9;
        }
        while (v9 != 0x7FFFFFFF);
      }
    }
  }
  return result;
}

float64_t CA::OGL::Renderer::render(CA::Render::Update const*,unsigned long,CA::WindowServer::SharedEvent *)::$_0::__invoke(float64x2_t *a1)
{
  double v1 = a1[1].f64[0];
  if (v1 < 1.79769313e308)
  {
    a1->f64[0] = a1->f64[0] * 0.03125;
    a1[1].f64[0] = v1 * 0.03125;
  }
  double v2 = a1[1].f64[1];
  if (v2 < 1.79769313e308)
  {
    a1->f64[1] = a1->f64[1] * 0.03125;
    a1[1].f64[1] = v2 * 0.03125;
  }
  float64x2_t v3 = a1[1];
  double v4 = a1[1].f64[1];
  if (v3.f64[0] <= v4) {
    double v5 = a1[1].f64[1];
  }
  else {
    double v5 = a1[1].f64[0];
  }
  if (v5 < 1.79769313e308)
  {
    if (v3.f64[0] < v4) {
      double v4 = a1[1].f64[0];
    }
    if (v4 > 0.0)
    {
      float64x2_t v6 = vrndmq_f64(*a1);
      float64x2_t v3 = vsubq_f64(vrndpq_f64(vaddq_f64(*a1, v3)), v6);
      *a1 = v6;
      a1[1] = v3;
    }
  }
  if (v3.f64[0] < 1.79769313e308)
  {
    a1->f64[0] = a1->f64[0] * 32.0;
    a1[1].f64[0] = v3.f64[0] * 32.0;
  }
  v3.f64[0] = v3.f64[1];
  if (v3.f64[1] < 1.79769313e308)
  {
    a1->f64[1] = a1->f64[1] * 32.0;
    v3.f64[0] = v3.f64[1] * 32.0;
    a1[1].f64[1] = v3.f64[1] * 32.0;
  }
  return v3.f64[0];
}

BOOL CA::Shape::equal(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1;
  }
  if ((a2 | a1)) {
    return 0;
  }
  int v2 = *(_DWORD *)(a1 + 4);
  if (v2 != *(_DWORD *)(a2 + 4)) {
    return 0;
  }
  float64x2_t v3 = (int *)(a1 + 12);
  double v4 = (int *)(a2 + 12);
  int v5 = v2 - 3;
  while (1)
  {
    BOOL result = v5 == 0;
    if (!v5) {
      break;
    }
    --v5;
    int v8 = *v3++;
    int v7 = v8;
    int v9 = *v4++;
    if (v7 != v9) {
      return 0;
    }
  }
  return result;
}

void unapplyRect(int8x16_t *a1, float64x2_t *this, double *a3)
{
}

double applyVec2r(double *a1, float64x2_t *this, double *a3)
{
  *(void *)&double result = *(_OWORD *)&CA::Mat4Impl::mat4_apply_to_point2(this, a1, a3);
  return result;
}

void CA::Render::Updater::FilterOp::map_bounds(CA::Render::Updater::LayerShapes &,BOOL)::$_0::__invoke(__n128 *a1, CA::Render::Updater::FilterOp *this)
{
}

double *CA::Render::Updater::RasterizationOp::map_bounds(CA::Render::Updater::LayerShapes &,BOOL)::$_0::__invoke(double *a1, _DWORD *a2)
{
  return CA::BoundsImpl::inset(a1, (double)-*a2, (double)-*a2);
}

double CA::Render::Updater::TransformOp::map_bounds(CA::Render::Updater::LayerShapes &,BOOL)::$_0::__invoke(int8x16_t *a1, uint64_t a2, double *a3)
{
  return CA::Rect::apply_transform(a1, (const CA::Transform *)(a2 + 24), a3);
}

void CA::Render::LayerNode::set_frame_transform(CA::Render::LayerNode *this, const CA::Transform *a2)
{
  double v4 = (_OWORD *)*((void *)this + 7);
  if ((*((unsigned char *)a2 + 144) & 0x1F) != 0)
  {
    if (!v4)
    {
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      double v4 = malloc_type_zone_malloc(malloc_zone, 0x80uLL, 0x8BB15036uLL);
      *((void *)this + 7) = v4;
    }
    long long v6 = *((_OWORD *)a2 + 1);
    long long v7 = *((_OWORD *)a2 + 2);
    long long v8 = *((_OWORD *)a2 + 3);
    *double v4 = *(_OWORD *)a2;
    v4[1] = v6;
    v4[2] = v7;
    v4[3] = v8;
    long long v9 = *((_OWORD *)a2 + 5);
    long long v10 = *((_OWORD *)a2 + 6);
    long long v11 = *((_OWORD *)a2 + 7);
    v4[4] = *((_OWORD *)a2 + 4);
    v4[5] = v9;
    v4[6] = v10;
    v4[7] = v11;
  }
  else
  {
    if (v4)
    {
      int8x16_t v12 = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(v12, v4);
      *((void *)this + 7) = 0;
    }
    *((void *)this + 8) = *((void *)a2 + 12);
    *((void *)this + 9) = *((void *)a2 + 13);
    *((void *)this + 10) = 0;
  }
  *((void *)this + 3) |= 0x20000uLL;
}

uint64_t map_unfun(uint64_t a1, _OWORD *a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  long long v2 = a2[1];
  long long v3 = a2[2];
  long long v4 = a2[3];
  v9[0] = *a2;
  v9[1] = v2;
  objc_object v9[2] = v3;
  v9[3] = v4;
  long long v5 = a2[5];
  long long v6 = a2[6];
  long long v7 = a2[7];
  v9[4] = a2[4];
  void v9[5] = v5;
  v9[6] = v6;
  v9[7] = v7;
  return (*(uint64_t (**)(void, _OWORD *))(a1 + 16))(*(void *)a1, v9);
}

void ___ZN2CA3OGL12MetalContext12delete_imageEPNS0_5ImageE_block_invoke_2(uint64_t a1)
{
}

_OWORD *CA::OGL::Context::bind_image(uint64_t a1, unsigned int a2, uint32x2_t *a3, double *a4, unsigned int a5, int a6, uint64_t a7, CA::OGL::ContentsGeometry *a8, float a9, float32x4_t *a10, uint64_t a11)
{
  LODWORD(v13) = a6;
  uint64_t v105 = *MEMORY[0x1E4F143B8];
  float32x2_t v93 = 0;
  float32x2_t v94 = 0;
  int8x16_t v19 = &v93;
  if (((unsigned __int16)a4 & 0x400) == 0) {
    int8x16_t v19 = (float32x2_t *)a10;
  }
  float64x2_t v90 = (float32x4_t *)v19;
  int v20 = a3[1].i32[1] & 0x40000;
  int v21 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 184))(a1, 20);
  BOOL v89 = v21 == 0;
  float64x2_t v88 = a8;
  if (!(v20 | (unsigned __int16)a4 & 0x1000))
  {
    int v32 = v21;
    if (!a8 || !*((unsigned char *)a8 + 337) && !*((unsigned char *)a8 + 338))
    {
      int v33 = (CA::Render::TiledTexture *)(*(uint64_t (**)(uint32x2_t *))(*(void *)a3 + 200))(a3);
      if (v33)
      {
        uint64_t v104 = 0;
        long long v102 = 0u;
        long long v103 = 0u;
        long long v100 = 0u;
        long long v101 = 0u;
        long long v98 = 0u;
        long long v99 = 0u;
        long long v96 = 0u;
        long long v97 = 0u;
        *(_OWORD *)keyExistsAndHasValidFormat = 0u;
        CA::OGL::TiledImageGeometry::TiledImageGeometry((uint64_t)keyExistsAndHasValidFormat, v33, a1, a4, a5, v13, a8, a9);
        unsigned int v23 = a2;
        uint64_t v26 = CA::OGL::TiledImageGeometry::bind_image((int32x2_t **)keyExistsAndHasValidFormat, a2, v90);
        goto LABEL_24;
      }
      if ((*(unsigned int (**)(uint64_t, uint32x2_t *))(*(void *)a1 + 568))(a1, a3))
      {
        *(_DWORD *)keyExistsAndHasValidFormat = 0;
        unsigned int v92 = 0;
        if ((*(uint64_t (**)(uint32x2_t *, Boolean *, unsigned int *))(*(void *)a3 + 216))(a3, keyExistsAndHasValidFormat, &v92))
        {
          if (((*(uint64_t (**)(uint64_t, uint32x2_t *, void, void))(*(void *)a1 + 576))(a1, a3, *(unsigned int *)keyExistsAndHasValidFormat, v92) & 1) == 0)
          {
            (*(void (**)(uint64_t, void, void))(*(void *)a1 + 520))(a1, 0, a2);
            return 0;
          }
          uint64_t v42 = (*(uint64_t (**)(uint32x2_t *))(*(void *)a3 + 104))(a3);
          uint64_t v43 = (*(uint64_t (**)(uint64_t, uint64_t, void, void))(*(void *)a1 + 200))(a1, v42, *(unsigned int *)keyExistsAndHasValidFormat, v92);
          uint64_t v44 = (CA::Render::TiledTexture *)(*(uint64_t (**)(uint32x2_t *, uint64_t, void))(*(void *)a3 + 208))(a3, v43, (a4 >> 11) & 1);
          if (v44)
          {
            uint64_t v45 = (atomic_uint *)v44;
            unsigned int v23 = a2;
            uint64_t v26 = CA::OGL::bind_tiled_image(a1, a2, v44, a4, a5, v13, v88, v90, a9);
            if (atomic_fetch_add(v45 + 2, 0xFFFFFFFF) == 1) {
              (*(void (**)(atomic_uint *))(*(void *)v45 + 16))(v45);
            }
LABEL_24:
            if (!v26) {
              return v26;
            }
            if (!v32) {
              goto LABEL_119;
            }
            goto LABEL_97;
          }
        }
      }
    }
  }
  if (((unsigned __int16)a4 & 0x43F) != 0) {
    uint64_t v13 = v13;
  }
  else {
    uint64_t v13 = 0;
  }
  if (((unsigned __int16)a4 & 0x43F) != 0) {
    uint64_t v22 = a5;
  }
  else {
    uint64_t v22 = 0;
  }
  unsigned int v23 = a2;
  uint64_t v24 = CA::OGL::state_image_texture_unit(*(void *)(a1 + 16), a2);
  uint64_t v25 = (*(uint64_t (**)(uint64_t, uint64_t, uint32x2_t *, double *, uint64_t, uint64_t, uint64_t, float32x4_t *, float, uint64_t))(*(void *)a1 + 584))(a1, v24, a3, a4, v22, v13, a7, v90, a9, a11);
  uint64_t v26 = (_OWORD *)v25;
  if (v25)
  {
    int v27 = *(unsigned char *)(v25 + 55) & 0x3F;
    uint64_t v28 = *(void *)(a1 + 16);
    uint64_t v29 = *(void *)(v28 + 360);
    if (v29)
    {
      char v30 = v89;
      if ((*(_DWORD *)v29 - 1) <= 3)
      {
        if (*(_DWORD *)v29 == 1) {
          int v31 = 24;
        }
        else {
          int v31 = 26;
        }
        char v30 = 1;
        if (*(float *)(v29 + 16) > 0.0) {
          int v27 = v31 | 1;
        }
        else {
          int v27 = v31;
        }
      }
    }
    else
    {
      char v30 = v89;
    }
    if (v27 > 20)
    {
      switch(v27)
      {
        case ' ':
        case '\'':
          uint64_t v34 = v28 + a2;
          *(unsigned char *)(v34 + 60) = *(unsigned char *)(v25 + 57) & 0xF;
          *(unsigned char *)(v34 + 62) = (*(unsigned char *)(v25 + 57) >> 4) & 3;
          break;
        case '!':
        case '""':
        case '#':
        case '$':
        case '&':
          break;
        case '%':
        case '(':
          goto LABEL_59;
        default:
          if (v27 == 21)
          {
            if (a3[1].i32[1] & 0x1000 | (unsigned __int16)a4 & 0x200
              && (((unsigned __int16)a4 & 0x100) != 0
               || (*(unsigned int (**)(uint64_t))(*(void *)a1 + 400))(a1)))
            {
              LOBYTE(v27) = 29;
            }
            else
            {
              LOBYTE(v27) = 21;
            }
          }
          else if (v27 == 22)
          {
LABEL_59:
            uint64_t v38 = v28 + a2;
            *(unsigned char *)(v38 + 60) = *(unsigned char *)(v25 + 57) & 0xF;
            *(unsigned char *)(v38 + 62) = (*(unsigned char *)(v25 + 57) >> 4) & 3;
            unsigned int v39 = (*(_WORD *)(v25 + 58) & 7) - 2;
            if (v39 > 4)
            {
              float v41 = 0.0;
              v40.i32[0] = 0.5;
            }
            else
            {
              v40.i32[0] = dword_18499AE28[v39];
              float v41 = flt_18499AE3C[v39];
            }
            float v46 = v90->f32[1];
            float v47 = v90->f32[3];
            uint64_t v48 = v28 + 16 * a2;
            *(float *)(v48 + 76) = v41;
            float64x2_t v49 = (float *)(v48 + 76);
            *(v49 - 1) = v40.f32[0];
            uint64_t v50 = (float32x2_t *)(v49 - 1);
            __int16 v51 = *(_WORD *)(v25 + 58);
            if ((v51 & 0x40) != 0)
            {
              v40.f32[0] = v40.f32[0] * 0.5;
              v50->i32[0] = v40.i32[0];
              __int16 v51 = *(_WORD *)(v25 + 58);
            }
            if ((v51 & 0x80) != 0)
            {
              float v41 = v41 * 0.5;
              float *v49 = v41;
            }
            if (v46 > v47)
            {
              float v41 = -v41;
              float *v49 = v41;
            }
            long long v52 = (float *)(v28 + 16 * a2 + 64);
            unsigned int v53 = *(unsigned __int16 *)(v25 + 58);
            if ((v53 & 0x100) != 0)
            {
              *long long v52 = 1.0;
              v40.f32[1] = v41;
              *uint64_t v50 = vdiv_f32(v40, vcvt_f32_u32(vshl_u32(a3[2], (uint32x2_t)vneg_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v53), (uint32x2_t)0xFFFFFFF9FFFFFFFALL), (int8x8_t)0x100000001)))));
              float v54 = 1.0;
            }
            else
            {
              float v54 = 0.5;
              if ((v53 & 0x40) != 0) {
                float v55 = 0.5;
              }
              else {
                float v55 = 1.0;
              }
              *long long v52 = v55;
              if ((*(_WORD *)(v25 + 58) & 0x80) == 0) {
                float v54 = 1.0;
              }
            }
            *(float *)(v28 + 16 * a2 + 68) = v54;
          }
          break;
      }
LABEL_83:
      if ((*((_WORD *)v26 + 29) & 0x800) != 0)
      {
        if ((*((_WORD *)v26 + 29) & 0x100) != 0)
        {
          *(float32x2_t *)v62.f32 = vcvt_f32_u32(a3[2]);
          __asm { FMOV            V1.2S, #1.0 }
          _D8 = vdiv_f32(_D1, *(float32x2_t *)v62.f32);
          v62.i64[1] = v62.i64[0];
          *float64x2_t v90 = vmulq_f32(*v90, v62);
        }
        else
        {
          __asm { FMOV            V8.2S, #1.0 }
        }
        uint64_t v56 = *(void *)(a1 + 16);
        *(unsigned char *)(v56 + 304) |= 1 << a2;
      }
      else
      {
        uint64_t v56 = *(void *)(a1 + 16);
        __asm { FMOV            V8.2S, #1.0 }
      }
      float64x2_t v64 = (float32x2_t *)(v56 + 16 * a2);
      float32x2_t v65 = vcvt_f32_u32(a3[2]);
      __asm { FMOV            V1.2S, #1.0 }
      v64[40] = v65;
      v64[41] = vdiv_f32(_D1, v65);
      float v67 = (*(float (**)(uint32x2_t *))(*(void *)a3 + 152))(a3);
      uint64_t v68 = *(unsigned char **)(a1 + 16);
      if (v67 != 1.0)
      {
        *(float *)&v68[4 * a2 + 312] = 1.0 / v67;
        v68[305] |= 1 << a2;
        if ((*(uint64_t (**)(uint32x2_t *))(*(void *)a3 + 160))(a3))
        {
          uint64_t v68 = *(unsigned char **)(a1 + 16);
          if (*(float *)(a1 + 152) != 1.0) {
            v68[306] |= 1 << a2;
          }
        }
        else
        {
          uint64_t v68 = *(unsigned char **)(a1 + 16);
        }
      }
      if ((*((_WORD *)v26 + 29) & 0x20) != 0) {
        v68[307] |= 1 << a2;
      }
      v68[a2 + 17] = v27;
      uint64_t v69 = *(void *)(a1 + 16) + 16 * a2;
      *(float32x2_t *)(v69 + 96) = _D8;
      *(void *)(v69 + 104) = 0;
      if (v30) {
        goto LABEL_119;
      }
LABEL_97:
      uint64_t v70 = (uint64_t)a3[6];
      if (v70)
      {
        if ((*(unsigned char *)(a1 + 432) & 0x80) == 0)
        {
          unsigned __int32 v71 = a3[1].u32[1];
          if ((v71 & 0x80000) == 0 && (!v88 || !*((unsigned char *)v88 + 340)))
          {
            if ((CA::OGL::Context::lookup_color_program(CGColorSpace *,BOOL,BOOL)::initialized & 1) == 0)
            {
              keyExistsAndHasValidFormat[0] = 0;
              int AppBooleanValue = CFPreferencesGetAppBooleanValue(@"CADisableColorMatching", (CFStringRef)*MEMORY[0x1E4F1D3D8], keyExistsAndHasValidFormat);
              if (keyExistsAndHasValidFormat[0]) {
                CA::OGL::Context::lookup_color_program(CGColorSpace *,BOOL,BOOL)::disable_colormatch = AppBooleanValue != 0;
              }
              unint64_t v73 = getenv("CA_DISABLE_COLOR_MATCHING");
              if (v73) {
                CA::OGL::Context::lookup_color_program(CGColorSpace *,BOOL,BOOL)::disable_colormatch = atoi(v73) != 0;
              }
              CA::OGL::Context::lookup_color_program(CGColorSpace *,BOOL,BOOL)::initialized = 1;
            }
            if (!CA::OGL::Context::lookup_color_program(CGColorSpace *,BOOL,BOOL)::disable_colormatch
              && (*(unsigned char *)(a1 + 504) & 1) == 0)
            {
              double v74 = CA::OGL::Context::color_program_cache((CA::OGL::Context *)a1);
              uint64_t v75 = *(void *)(a1 + 216);
              if (v75)
              {
                uint64_t v76 = v75 + 352;
                if ((CACGColorSpaceIsRec709(v70) & 1) == 0) {
                  goto LABEL_127;
                }
                if (*(unsigned char *)(v75 + 404))
                {
                  unsigned int v77 = 19;
LABEL_126:
                  uint64_t v70 = CAGetColorSpace(v77);
LABEL_127:
                  if (v70 == CAGetColorSpace(9u)) {
                    int v81 = 1;
                  }
                  else {
                    int v81 = CGColorSpaceEqualToColorSpaceIgnoringRange();
                  }
                  if (v81 && v76 && !*(unsigned char *)(v76 + 54)) {
                    uint64_t v70 = CAGetColorSpace(0x1Fu);
                  }
                  if ((CACGColorSpaceIsRec601NTSC(v70) & 1) != 0 || CACGColorSpaceIsRec601PAL(v70))
                  {
                    if (v76 && *(unsigned char *)(v76 + 52) && *(unsigned char *)(v76 + 54))
                    {
                      if (CACGColorSpaceIsRec601NTSC(v70)) {
                        unsigned int v82 = 24;
                      }
                      else {
                        unsigned int v82 = 25;
                      }
                      uint64_t v70 = CAGetColorSpace(v82);
                      goto LABEL_145;
                    }
                    uint64_t v70 = CAGetColorSpace(0x1Du);
                  }
                  if (!v76)
                  {
                    int v83 = (v71 >> 12) & 1;
                    float64x2_t v84 = (CGColorSpace **)v74;
                    float64x2_t v85 = (CGColorSpace *)v70;
                    uint64_t v86 = 0;
                    goto LABEL_147;
                  }
LABEL_145:
                  int v83 = (v71 >> 12) & 1;
                  *((unsigned char *)v74 + 63) = *(unsigned char *)(v76 + 54);
                  float64x2_t v84 = (CGColorSpace **)v74;
                  float64x2_t v85 = (CGColorSpace *)v70;
                  uint64_t v86 = v76;
LABEL_147:
                  float64x2_t v87 = (const CA::ColorProgram::Program *)CA::ColorProgram::Cache::lookup(v84, v85, v83, v86);
                  CA::OGL::Context::color_program((uint64_t *)a1, v23, v87);
                  if (v88 && v87) {
                    *((unsigned char *)v88 + 495) = 1;
                  }
                  goto LABEL_119;
                }
              }
              else
              {
                uint64_t v76 = 0;
                if ((CACGColorSpaceIsRec709(v70) & 1) == 0) {
                  goto LABEL_127;
                }
              }
              unsigned int v77 = 29;
              goto LABEL_126;
            }
            CA::OGL::Context::color_program((uint64_t *)a1, v23, 0);
          }
        }
      }
LABEL_119:
      *((_DWORD *)v26 + 5) = *(_DWORD *)(a1 + 228);
      if (((unsigned __int16)a4 & 0x400) != 0)
      {
        *(float32x2_t *)v78.f32 = v93;
        *(float32x2_t *)v79.f32 = vsub_f32(v94, v93);
        v79.i64[1] = v79.i64[0];
        *(float32x2_t *)&v78.u32[2] = v93;
        *a10 = vmlaq_f32(v78, *a10, v79);
      }
      return v26;
    }
    if (v27 <= 2)
    {
      if (v27)
      {
        if (v27 != 1)
        {
          if (v27 != 2) {
            goto LABEL_83;
          }
          goto LABEL_47;
        }
        goto LABEL_39;
      }
LABEL_47:
      if ((*(unsigned int (**)(uint32x2_t *))(*(void *)a3 + 136))(a3) <= 3
        && a3[1].i32[1] & 0x1000 | (unsigned __int16)a4 & 0x200
        && (((unsigned __int16)a4 & 0x100) != 0 || (*(unsigned int (**)(uint64_t))(*(void *)a1 + 400))(a1)))
      {
        if (v27 == 2) {
          char v37 = 3;
        }
        else {
          char v37 = 5;
        }
        if (v27) {
          LOBYTE(v27) = v37;
        }
        else {
          LOBYTE(v27) = 1;
        }
      }
      goto LABEL_83;
    }
    if (v27 != 3)
    {
      if (v27 == 4) {
        goto LABEL_47;
      }
      if (v27 != 5) {
        goto LABEL_83;
      }
    }
LABEL_39:
    if (((unsigned __int16)a4 & 0x100) == 0)
    {
      char v35 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 400))(a1);
      if (v27 == 3) {
        char v36 = 2;
      }
      else {
        char v36 = 4;
      }
      if (v27 == 1) {
        char v36 = 0;
      }
      if ((v35 & 1) == 0) {
        LOBYTE(v27) = v36;
      }
    }
    goto LABEL_83;
  }
  return v26;
}

void CA::Render::Updater::prepare_layer_contents(unsigned char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v134 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 80))(a3);
  if (v8)
  {
    long long v9 = (void *)v8;
    *(void *)char v110 = 0;
    if ((*(unsigned char *)(v8 + 13) & 0x64) != 0)
    {
      CA::Render::Texture::displayed_size_(v8, &v110[1], v110);
    }
    else
    {
      unsigned int v28 = *(_DWORD *)(v8 + 16);
      v110[0] = *(_DWORD *)(v8 + 20);
      v110[1] = v28;
    }
    if (*(unsigned char *)(a3 + 12) == 50)
    {
      unsigned int v29 = *(_DWORD *)(a3 + 32);
      v110[0] = *(_DWORD *)(a3 + 36);
      v110[1] = v29;
    }
    unsigned int v30 = (*(uint64_t (**)(void *))(*v9 + 104))(v9);
    if (v30 <= 0x23 && ((0xF9FE26000uLL >> v30) & 1) != 0) {
      *(void *)(a2 + 72) |= 0x40000000uLL;
    }
    if ((*(unsigned char *)(*(void *)(a2 + 56) + 43) & 2) != 0) {
      *(void *)(a2 + 72) |= 0x200000000uLL;
    }
    if (*(unsigned char *)(a3 + 12) != 25 || !CA::Render::ImageQueue::is_protected((CA::Render::ImageQueue *)a3)) {
      goto LABEL_38;
    }
    uint64_t v33 = *(void *)(a3 + 64);
    if (!v33)
    {
      uint64_t v33 = *(void *)(a3 + 80);
      if (!v33)
      {
        if (!*(void *)(a3 + 24)) {
          goto LABEL_38;
        }
        uint64_t v33 = *(void *)(a3 + 80);
        if (!v33) {
          uint64_t v33 = *(void *)(a3 + 24);
        }
      }
    }
    *(void *)(a2 + 72) |= ((*(uint64_t (**)(uint64_t))(*(void *)v33 + 240))(v33) << 47) & 0x3000000000000 | 0x800000000000;
LABEL_38:
    int v34 = *((_DWORD *)v9 + 3);
    if (v34 == 51)
    {
      *(void *)(a2 + 72) |= ((*(uint64_t (**)(void *))(*v9 + 240))(v9) & 7) << 47;
      int v34 = *((_DWORD *)v9 + 3);
    }
    if ((v34 & 0x10000) != 0) {
      *(void *)(a2 + 72) |= 0x1000000uLL;
    }
    uint64_t v35 = *(void *)(a2 + 56);
    if ((v34 & 0x1000) == 0 && (*(unsigned char *)(v35 + 42) & 2) == 0) {
      goto LABEL_49;
    }
    char v36 = *(float **)(v35 + 128);
    if (v36)
    {
      if (!*(void *)v36) {
        goto LABEL_48;
      }
      int v37 = (*(uint64_t (**)(void, void))(**(void **)v36 + 216))(*(void *)v36, *(void *)(a2 + 56));
      uint64_t v35 = *(void *)(a2 + 56);
      if (!v37)
      {
LABEL_49:
        int v38 = 0;
        goto LABEL_51;
      }
      char v36 = *(float **)(v35 + 128);
      if (v36)
      {
LABEL_48:
        if (v36[70] < 1.0) {
          goto LABEL_49;
        }
      }
    }
    int v38 = 1;
LABEL_51:
    LODWORD(v31) = v110[1];
    double v39 = (double)v31;
    LODWORD(v31) = v110[0];
    double v40 = (double)v31;
    float64x2_t v108 = 0uLL;
    v109.f64[0] = v39;
    v109.f64[1] = v40;
    uint64_t v41 = *(void *)(v35 + 128);
    if (v41)
    {
      float v42 = *(float *)(v41 + 284);
    }
    else
    {
      LOBYTE(v32) = *(unsigned char *)(v35 + 34);
      float v42 = (float)v32;
    }
    if (v42 != 1.0)
    {
      if (v42 != 0.0)
      {
        double v51 = v42;
        double v39 = v39 / v51;
        double v40 = v40 / v51;
        v109.f64[0] = v39;
        v109.f64[1] = v40;
        if (v41)
        {
LABEL_58:
          uint64_t v43 = *(double **)(v41 + 40);
          if (v43)
          {
            double v39 = (v43[5] - v43[3]) * v39;
            double v40 = (v43[6] - v43[4]) * v40;
            v109.f64[0] = v39;
            v109.f64[1] = v40;
          }
        }
LABEL_60:
        v107.f64[0] = v39;
        v107.f64[1] = v40;
        if ((*(_DWORD *)(v35 + 36) & 0xF000) != 0x9000
          || *(double *)(v35 + 64) != 0.0
          || *(double *)(v35 + 72) != 0.0
          || v41 && *(void *)(v41 + 32)
          || *(double *)(v35 + 80) != v39
          || *(double *)(v35 + 88) != v40)
        {
          v38 &= CA::Render::Layer::apply_contents_transform(v35, (uint64_t)&v108, &v107, *(unsigned __int8 *)(a3 + 12) == 25);
        }
        CA::Rect::apply_transform(v108.f64, a2 + 8);
        if (*(unsigned char *)(v35 + 42))
        {
          __asm { FMOV            V0.2D, #1.0 }
          float64x2_t v111 = _Q0;
          uint64_t v48 = *(void **)a2;
          if (*(void *)a2)
          {
            do
            {
              (*(void (**)(void *, float64x2_t *))(*v48 + 48))(v48, &v111);
              uint64_t v48 = (void *)v48[1];
            }
            while (v48);
            double v50 = v111.f64[1];
            double v49 = v111.f64[0];
          }
          else
          {
            double v50 = 1.0;
            double v49 = 1.0;
          }
          CA::BoundsImpl::inset(v108.f64, -0.5 / v49, -0.5 / v50);
        }
        float64x2_t v100 = v109;
        float64x2_t v101 = v108;
        v106[0] = v108;
        v106[1] = v109;
        CA::Render::Updater::LayerShapes::union_bounds((__n128 *)a4, &v108, (const CA::Bounds *)((*(void *)(a2 + 64) & 0x8000) == 0));
        if ((*(unsigned char *)(a2 + 65) & 0x80) != 0 && *(void *)(a4 + 72))
        {
          float64x2_t v56 = v100;
          float64x2_t v111 = v101;
          float64x2_t v112 = v100;
          double v57 = *(void **)a2;
          if (*(void *)a2)
          {
            do
            {
              (*(void (**)(void *, float64x2_t *))(*v57 + 40))(v57, &v111);
              double v57 = (void *)v57[1];
            }
            while (v57);
            float64x2_t v56 = v112;
          }
          if (v56.f64[0] <= v56.f64[1]) {
            double v58 = v56.f64[1];
          }
          else {
            double v58 = v56.f64[0];
          }
          if (v58 < 1.79769313e308)
          {
            double v59 = v56.f64[0] >= v56.f64[1] ? v56.f64[1] : v56.f64[0];
            if (v59 > 0.0)
            {
              float64x2_t v111 = vaddq_f64(v111, (float64x2_t)vdupq_n_s64(0xBF50000000000000));
              v112.f64[0] = v56.f64[0] + 0.001953125;
              v112.f64[1] = v56.f64[1] + 0.001953125;
              if (v56.f64[0] + 0.001953125 <= 0.0 || v56.f64[1] + 0.001953125 <= 0.0) {
                float64x2_t v112 = 0uLL;
              }
            }
          }
          float64x2_t v60 = v112;
          int64x2_t v61 = vclezq_f64(v112);
          if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v61, 1), (int8x16_t)v61).u64[0] & 0x8000000000000000) == 0)
          {
            float64x2_t v62 = *(float64x2_t *)(a4 + 104);
            int64x2_t v63 = vclezq_f64(v62);
            if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v63, 1), (int8x16_t)v63).u64[0] & 0x8000000000000000) != 0
              || (float64x2_t v64 = *(float64x2_t *)(a4 + 88),
                  float64x2_t v65 = vaddq_f64(v64, v62),
                  float64x2_t v66 = vmaxnmq_f64(v111, v64),
                  float64x2_t v60 = vsubq_f64(vminnmq_f64(vaddq_f64(v111, v112), v65), v66),
                  int64x2_t v67 = vclezq_f64(v60),
                  (vorrq_s8((int8x16_t)vdupq_laneq_s64(v67, 1), (int8x16_t)v67).u64[0] & 0x8000000000000000) != 0))
            {
              float64x2_t v112 = 0uLL;
              float64x2_t v60 = 0uLL;
            }
            else
            {
              float64x2_t v111 = v66;
              float64x2_t v112 = v60;
            }
          }
          int64x2_t v68 = vceqzq_f64(v60);
          if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v68, 1), (int8x16_t)v68).u64[0] & 0x8000000000000000) != 0
            || (int8x16_t v69 = vorrq_s8((int8x16_t)vcltzq_f64(v60), (int8x16_t)vcgezq_f64(v60)),
                (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v69), 1), v69).u64[0] & 0x8000000000000000) != 0))
          {
            v103[0] = 0;
            v103[1] = 0;
          }
          else
          {
            int32x4_t v70 = (int32x4_t)vcvtpq_s64_f64(vmaxnmq_f64(v111, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
            *(int32x4_t *)long long v103 = vuzp1q_s32(v70, (int32x4_t)vsubq_s64(vcvtmq_s64_f64(vminnmq_f64(vaddq_f64(v111, v60), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v70));
          }
          CA::shape_union((CA::Shape **)(a4 + 72), v103, v55);
        }
        if (*(unsigned char *)(a3 + 12) != 25 && (*(float (**)(void *))(*v9 + 152))(v9) != 1.0)
        {
          uint64_t v71 = 0x2000000000;
          if ((*(void *)(a2 + 64) & 0x8000) == 0) {
            uint64_t v71 = 0x800000000;
          }
          *(void *)(a2 + 72) |= v71;
        }
        uint64_t v72 = v9[5];
        if (v72 && (*(_DWORD *)(*(void *)a1 + 1084) & 4) == 0)
        {
          float64x2_t v111 = (float64x2_t)xmmword_184997D50;
          float64x2_t v112 = 0u;
          long long v113 = xmmword_184997D60;
          *(_OWORD *)uint64_t v114 = 0u;
          *(_OWORD *)uint64_t v115 = 0u;
          long long v116 = xmmword_184997D50;
          long long v117 = 0u;
          long long v118 = xmmword_184997D60;
          __asm { FMOV            V0.2D, #1.0 }
          v119[0] = _Q0;
          LOBYTE(v119[1]) &= 0xE0u;
          if (CA::Render::Layer::append_texture_transform(*(CA::Render::Layer **)(a2 + 56), (CA::Transform *)&v111, (CA::Render::Texture *)v9, (CA::Render::Object *)a3))
          {
            CA::Transform::concat((uint64_t)&v111, a2 + 8);
            v103[0] = (CA::Shape *)&v111;
            v103[1] = (CA::Shape *)v106;
            *(void *)&v104.f64[0] = a2;
            *(void *)&v104.f64[1] = a4;
            uint64_t v105 = a1;
            if ((v119[1] & 0x10) != 0 && !CA::Mat4Impl::mat4_is_rectilinear((CA::Mat4Impl *)&v111, v74))
            {
              uint64_t v131 = 0;
              uint64_t v132 = 0;
              CA::Shape::get_bounds(v72, (int *)&v131);
              CA::Render::Updater::prepare_layer_contents(CA::Render::Updater::GlobalState &,CA::Render::Updater::LocalState &,CA::Render::Object *,CA::Render::Updater::LayerShapes &)::$_0::operator()((uint64_t)v103, (uint64_t)&v131, v77, v78, v79);
            }
            else
            {
              uint64_t v132 = 0;
              uint64_t v133 = 0;
              uint64_t v131 = v72;
              v102[0] = 0;
              v102[1] = 0;
              while (CA::ShapeIterator::iterate(&v131, (int *)v102))
                CA::Render::Updater::prepare_layer_contents(CA::Render::Updater::GlobalState &,CA::Render::Updater::LocalState &,CA::Render::Object *,CA::Render::Updater::LayerShapes &)::$_0::operator()((uint64_t)v103, (uint64_t)v102, (double *)v55, v75, v76);
            }
          }
          else
          {
            *(void *)(a2 + 64) |= 2uLL;
          }
          if ((*(unsigned char *)(*(void *)(a2 + 48) + 24) & 0x40) != 0)
          {
            float64x2_t v80 = (CA::Shape *)v9[5];
            if (v80)
            {
              CA::Shape::unref(v80);
              void v9[5] = 0;
            }
          }
        }
        char v81 = v38 ^ 1;
        if (!*(void *)(a4 + 56)) {
          char v81 = 1;
        }
        if ((v81 & 1) == 0) {
          CA::Render::Updater::union_opaque_rect((uint64_t)a1, a4, v55, v101, v100);
        }
        if (!v9[6]
          && (*(unsigned int (**)(void *))(*v9 + 104))(v9) != 9
          && BYTE2(xmmword_1EB2ACBF0) == 0)
        {
          uint64_t v83 = *(void *)(*(void *)(a2 + 56) + 144);
          if (v83)
          {
            uint64_t v84 = *(void *)(v83 + 24);
            if (v84)
            {
              if ((*(_WORD *)(v84 + 552) & 2) != 0) {
                (*(void (**)(void *))(*v9 + 96))(v9);
              }
            }
          }
        }
        uint64_t v85 = *(void *)(a2 + 64);
        if ((v85 & 0x8000) != 0)
        {
          if (a1[12])
          {
            v85 |= 2uLL;
            *(void *)(a2 + 64) = v85;
          }
          uint64_t v86 = *(_DWORD **)a1;
          if (*(_DWORD *)(a4 + 120) != *(_DWORD *)(*(void *)a1 + 192)
            || *(_DWORD *)(a4 + 124) != v86[49]
            || *(_DWORD *)(a4 + 128) != v86[50]
            || *(_DWORD *)(a4 + 132) != v86[51])
          {
            float64x2_t v87 = *(float64x2_t *)(a4 + 16);
            float64x2_t v111 = *(float64x2_t *)a4;
            float64x2_t v112 = v87;
            CA::Render::Updater::apply_shapes_ops(*(void **)a2, (CA::Render::Updater::LayerShapesOp *)&v111, v55);
            float64x2_t v88 = vrndaq_f64(v111);
            if (vaddvq_f64(vabdq_f64(v111, v88))
               + vabdd_f64(v112.f64[0], round(v112.f64[0]))
               + vabdd_f64(v112.f64[1], round(v112.f64[1])) < 0.004)
            {
              double v89 = v112.f64[1];
              double v90 = v112.f64[0] <= v112.f64[1] ? v112.f64[1] : v112.f64[0];
              if (v90 < 1.79769313e308)
              {
                if (v112.f64[0] < v112.f64[1]) {
                  double v89 = v112.f64[0];
                }
                if (v89 > 0.0)
                {
                  float64x2_t v91 = vsubq_f64(vrndaq_f64(vaddq_f64(v111, v112)), v88);
                  float64x2_t v111 = v88;
                  float64x2_t v112 = v91;
                }
              }
            }
            float64x2_t v92 = *(float64x2_t *)(a4 + 88);
            float64x2_t v93 = *(float64x2_t *)(a4 + 104);
            *(float64x2_t *)long long v103 = v92;
            float64x2_t v104 = v93;
            float64x2_t v94 = vrndaq_f64(v92);
            if (vaddvq_f64(vabdq_f64(v92, v94))
               + vabdd_f64(v93.f64[0], round(v93.f64[0]))
               + vabdd_f64(v93.f64[1], round(v93.f64[1])) < 0.004)
            {
              double v95 = v93.f64[0] <= v93.f64[1] ? v93.f64[1] : v93.f64[0];
              if (v95 < 1.79769313e308)
              {
                double v96 = v93.f64[0] >= v93.f64[1] ? v93.f64[1] : v93.f64[0];
                if (v96 > 0.0)
                {
                  *(float64x2_t *)long long v103 = v94;
                  float64x2_t v104 = vsubq_f64(vrndaq_f64(vaddq_f64(v92, v93)), v94);
                }
              }
            }
            if (!CA::BoundsImpl::contains((double *)v103, v111.f64)) {
              *(void *)(a2 + 72) |= 0x20C00000uLL;
            }
            uint64_t v85 = *(void *)(a2 + 64);
          }
        }
        else
        {
          *(void *)(a2 + 72) |= 0x20C00000uLL;
        }
        if ((v85 & 0x80) != 0 && *(unsigned char *)(a3 + 12) == 25)
        {
          long long v118 = 0u;
          memset(v119, 0, 24);
          long long v116 = 0u;
          long long v117 = 0u;
          *(_OWORD *)uint64_t v114 = 0u;
          *(_OWORD *)uint64_t v115 = 0u;
          float64x2_t v112 = 0u;
          long long v113 = 0u;
          float64x2_t v111 = 0u;
          v98.n128_f64[0] = CA::Transform::set((CA::Transform *)&v111, a2 + 8);
          long long v99 = *(void **)a2;
          if (*(void *)a2)
          {
            do
            {
              (*(void (**)(void *, float64x2_t *, __n128))(*v99 + 56))(v99, &v111, v98);
              long long v99 = (void *)v99[1];
            }
            while (v99);
          }
          *(unsigned char *)(*(void *)(*(void *)(a3 + 16) + 24) + 92) = ((*(_DWORD *)(*(void *)a1 + 272) & 2) != 0) ^ CA::Render::Updater::get_rotation_flags((CA::Render::Updater *)&v111, v97) ^ ((*(void *)(*(void *)(a2 + 48) + 24) & 1) == 0);
        }
        return;
      }
      float64x2_t v109 = 0uLL;
      double v40 = 0.0;
      double v39 = 0.0;
    }
    if (v41) {
      goto LABEL_58;
    }
    goto LABEL_60;
  }
  int v10 = *(unsigned __int8 *)(a3 + 12);
  if (v10 == 25)
  {
    long long v52 = *(atomic_uint **)(a3 + 32);
    if (v52)
    {
      unsigned int v53 = v52 + 2;
      if (atomic_fetch_add(v52 + 2, 1u))
      {
        CA::Render::Updater::prepare_layer_contents(a1, a2, v52, a4);
        if (atomic_fetch_add(v53, 0xFFFFFFFF) == 1)
        {
          float v54 = *(void (**)(atomic_uint *))(*(void *)v52 + 16);
          v54(v52);
        }
      }
      else
      {
        atomic_fetch_add(v53, 0xFFFFFFFF);
      }
    }
  }
  else if (v10 == 26)
  {
    uint64_t v11 = *(void *)(a4 + 56);
    *(_OWORD *)uint64_t v115 = 0u;
    long long v116 = 0u;
    long long v118 = 0u;
    memset(v119, 0, sizeof(v119));
    long long v117 = 0u;
    long long v113 = 0u;
    *(_OWORD *)uint64_t v114 = 0u;
    float64x2_t v111 = 0u;
    float64x2_t v112 = 0u;
    int8x16_t v12 = (CA::Shape **)(a4 + 64);
    BOOL v13 = *(void *)(a4 + 64) != 0;
    v114[1] = (CA::Shape *)(v11 != 0);
    v115[0] = (CA::Shape **)v13;
    v115[1] = 0;
    *(void *)&long long v116 = 0;
    unint64_t v14 = *(void *)(a4 + 96);
    *((void *)&v116 + 1) = *(void *)(a4 + 88);
    *(void *)&long long v117 = v14;
    uint64_t v15 = *(void *)(a4 + 112);
    *((void *)&v117 + 1) = *(void *)(a4 + 104);
    *(void *)&long long v118 = v15;
    unsigned int v16 = *(_DWORD *)(a4 + 124);
    DWORD2(v118) = *(_DWORD *)(a4 + 120);
    HIDWORD(v118) = v16;
    int v17 = *(_DWORD *)(a4 + 132);
    LODWORD(v119[0]) = *(_DWORD *)(a4 + 128);
    DWORD1(v119[0]) = v17;
    double v120 = 0.0;
    uint64_t v121 = 0;
    uint64_t v122 = v114[1];
    uint64_t v123 = (CA::Shape **)v13;
    uint64_t v124 = 0;
    unsigned long long v125 = __PAIR128__(*((unint64_t *)&v116 + 1), 0);
    unsigned long long v126 = __PAIR128__(*((unint64_t *)&v117 + 1), v14);
    uint64_t v127 = v15;
    int v128 = DWORD2(v118);
    unint64_t v129 = __PAIR64__(v119[0], v16);
    int v130 = v17;
    CA::Render::Updater::prepare_layer_contents(a1, a2, *(void *)(a3 + 24), &v111);
    CA::Render::Updater::prepare_layer_contents(a1, a2, *(void *)(a3 + 32), (char *)v119 + 8);
    CA::Render::Updater::LayerShapes::union_bounds((__n128 *)a4, &v111, (const CA::Bounds *)1);
    CA::Render::Updater::LayerShapes::union_bounds((__n128 *)a4, (float64x2_t *)((char *)v119 + 8), (const CA::Bounds *)1);
    long long v19 = v113;
    double v20 = *(double *)(a4 + 32);
    if (v20 > *(double *)&v113)
    {
      *(void *)(a4 + 32) = v113;
      double v20 = *(double *)&v19;
    }
    double v21 = *(double *)(a4 + 40);
    if (v21 < *((double *)&v19 + 1))
    {
      *(void *)(a4 + 40) = *((void *)&v19 + 1);
      double v21 = *((double *)&v19 + 1);
    }
    double v22 = v120;
    if (v20 > *((double *)&v119[2] + 1)) {
      *(void *)(a4 + 32) = *((void *)&v119[2] + 1);
    }
    if (v21 < v22) {
      *(double *)(a4 + 40) = v22;
    }
    if (*(void *)(a4 + 56))
    {
      unsigned int v23 = (CA::Shape **)CA::Shape::intersect((uint64_t)v114[1], (uint64_t)v122);
      CA::Shape::unref(v114[1]);
      CA::Shape::unref(v122);
      CA::shape_union((CA::Shape **)(a4 + 56), v23, v24);
      CA::Shape::unref((CA::Shape *)v23);
    }
    if (*v12)
    {
      CA::shape_union((CA::Shape **)(a4 + 64), v115[0], v18);
      uint64_t v26 = (uint64_t)*v12;
      if ((*v12 & 1) == 0)
      {
        if (*(int *)(v26 + 4) < 257) {
          goto LABEL_21;
        }
        v103[0] = 0;
        v103[1] = 0;
        CA::Shape::get_bounds(v26, (int *)v103);
        CA::Shape::unref(*v12);
        uint64_t v26 = CA::Shape::new_shape((unsigned int *)v103);
        *int8x16_t v12 = (CA::Shape *)v26;
      }
      if (!v26)
      {
LABEL_24:
        CA::Shape::unref((CA::Shape *)v115[0]);
        CA::Shape::unref((CA::Shape *)v123);
        return;
      }
LABEL_21:
      CA::shape_union((CA::Shape **)(a4 + 64), v123, v25);
      int v27 = *v12;
      if ((*v12 & 1) == 0 && *((int *)v27 + 1) >= 257)
      {
        v103[0] = 0;
        v103[1] = 0;
        CA::Shape::get_bounds((uint64_t)v27, (int *)v103);
        CA::Shape::unref(*v12);
        *int8x16_t v12 = (CA::Shape *)CA::Shape::new_shape((unsigned int *)v103);
      }
      goto LABEL_24;
    }
  }
}

uint64_t CA::Render::Updater::LayerShapes::union_bounds(__n128 *this, float64x2_t *a2, const CA::Bounds *a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  __n128 v5 = this[1];
  float64x2_t v6 = a2[1];
  int64x2_t v7 = vclezq_f64((float64x2_t)v5);
  __n128 v8 = (__n128)vclezq_f64(v6);
  __n128 v9 = (__n128)vcltzq_s64((int64x2_t)vorrq_s8((int8x16_t)vzip1q_s64((int64x2_t)v8, v7), (int8x16_t)vzip2q_s64((int64x2_t)v8, v7)));
  v9.n128_u64[0] = (unint64_t)vmovn_s64((int64x2_t)v9);
  if (v9.n128_u8[4])
  {
    if ((v9.n128_u8[0] & 1) == 0)
    {
      __n128 v5 = *(__n128 *)a2;
LABEL_6:
      *this = v5;
      this[1] = (__n128)v6;
    }
  }
  else if ((v9.n128_u8[0] & 1) == 0)
  {
    __n128 v9 = *this;
    __n128 v8 = *(__n128 *)a2;
    float64x2_t v10 = vaddq_f64(*(float64x2_t *)this, (float64x2_t)v5);
    __n128 v5 = (__n128)vminnmq_f64(*(float64x2_t *)this, *a2);
    float64x2_t v6 = vsubq_f64(vmaxnmq_f64(v10, vaddq_f64(*a2, v6)), (float64x2_t)v5);
    goto LABEL_6;
  }
  if (a3)
  {
    uint64_t v11 = (CA::Shape **)&this[4];
    if (this[4].n128_u64[0])
    {
      float64x2_t v12 = a2[1];
      int64x2_t v13 = vceqzq_f64(v12);
      if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v13, 1), (int8x16_t)v13).u64[0] & 0x8000000000000000) != 0
        || (int8x16_t v14 = vorrq_s8((int8x16_t)vcltzq_f64(v12), (int8x16_t)vcgezq_f64(v12)),
            (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v14), 1), v14).u64[0] & 0x8000000000000000) != 0))
      {
        int32x4_t v18 = 0uLL;
      }
      else
      {
        int32x4_t v15 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(*a2, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
        int32x4_t v18 = vuzp1q_s32(v15, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(*a2, v12), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v15));
      }
      CA::shape_union(v11, (CA::Shape **)&v18, a3);
    }
  }
  uint64_t result = this[3].n128_i64[0];
  if (result && !*(unsigned char *)(result + 16))
  {
    double v17 = a2->f64[0];
    v5.n128_u64[0] = *(void *)&a2->f64[1];
    v9.n128_f64[0] = a2[1].f64[0] + a2->f64[0];
    v8.n128_f64[0] = a2[1].f64[1] + v5.n128_f64[0];
    return CA::GenericRectTree<CA::Rect>::insert_node(result, (uint64_t *)(result + 8), v17, v5, v9, v8);
  }
  return result;
}

uint64_t CA::Render::Image::image_format(CA::Render::Image *this)
{
  return *((unsigned __int8 *)this + 152);
}

double CA::Rect::apply_transform(double *a1, uint64_t a2)
{
  double v3 = a1[2];
  double result = a1[3];
  if (v3 <= result) {
    double v4 = a1[3];
  }
  else {
    double v4 = a1[2];
  }
  if (v4 >= 1.79769313e308) {
    return result;
  }
  char v5 = *(unsigned char *)(a2 + 32);
  if ((v5 & 8) != 0)
  {
    double v6 = a1[1];
    *a1 = *a1 * *(double *)(a2 + 16);
    a1[1] = v6 * *(double *)(a2 + 16);
    double v3 = *(double *)(a2 + 16) * v3;
    a1[2] = v3;
    double result = *(double *)(a2 + 16) * result;
    a1[3] = result;
    char v5 = *(unsigned char *)(a2 + 32);
  }
  if ((v5 & 4) == 0)
  {
    double v7 = result;
    double result = v3;
    if ((v5 & 2) == 0) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
  double v8 = *a1;
  *a1 = -(result + a1[1]);
  a1[1] = v8;
  a1[2] = result;
  a1[3] = v3;
  char v5 = *(unsigned char *)(a2 + 32);
  double v7 = v3;
  if ((v5 & 2) != 0)
  {
LABEL_11:
    *a1 = -(result + *a1);
    char v5 = *(unsigned char *)(a2 + 32);
  }
LABEL_12:
  double v9 = a1[1];
  if (v5)
  {
    double v9 = -(v7 + v9);
    a1[1] = v9;
  }
  *a1 = *a1 + *(double *)a2;
  double result = v9 + *(double *)(a2 + 8);
  a1[1] = result;
  return result;
}

float CA::Render::Texture::edr_factor(CA::Render::Texture *this)
{
  return 1.0;
}

BOOL CA::Render::Texture::is_protected(CA::Render::Texture *this)
{
  return (*(uint64_t (**)(CA::Render::Texture *))(*(void *)this + 240))(this) != 0;
}

uint64_t CA::OGL::MetalContext::get(uint64_t a1, int a2)
{
  uint64_t result = 0x10000;
  switch(a2)
  {
    case 0:
    case 8:
      uint64_t result = 0;
      break;
    case 1:
    case 2:
      return result;
    case 3:
      uint64_t result = *(unsigned int *)(a1 + 2688);
      break;
    case 4:
      uint64_t result = *(unsigned int *)(a1 + 2704);
      break;
    case 5:
      uint64_t v4 = *(void *)(a1 + 2712);
      if (v4) {
        uint64_t result = v4;
      }
      else {
        uint64_t result = 0x2000;
      }
      break;
    case 6:
      uint64_t result = *(unsigned int *)(a1 + 2720);
      break;
    case 7:
      uint64_t result = *(unsigned int *)(a1 + 2696);
      break;
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 16:
    case 18:
    case 19:
    case 20:
    case 22:
    case 23:
    case 24:
    case 25:
    case 29:
    case 30:
    case 31:
    case 37:
    case 39:
      uint64_t result = 1;
      break;
    case 15:
      uint64_t result = 27;
      break;
    case 17:
      uint64_t result = (*(_DWORD *)(a1 + 2724) >> 11) & 1;
      break;
    case 21:
      uint64_t result = (*(_DWORD *)(a1 + 2724) >> 15) & 1;
      break;
    case 26:
      uint64_t result = (*(_DWORD *)(a1 + 2724) >> 20) & 1;
      break;
    case 27:
      uint64_t result = (*(unsigned __int16 *)(a1 + 3328) >> 3) & 1;
      break;
    case 32:
      uint64_t result = (*(unsigned __int16 *)(a1 + 3328) >> 4) & 1;
      break;
    case 33:
      BOOL v5 = BYTE1(qword_1EB2ACC90) == 0;
      goto LABEL_21;
    case 34:
      uint64_t result = (BYTE7(xmmword_1EB2ACC50) == 0) & (*(unsigned __int8 *)(a1 + 2726) >> 6);
      break;
    case 35:
      uint64_t result = (*(_DWORD *)(a1 + 2724) >> 23) & 1;
      break;
    case 36:
      uint64_t result = (BYTE8(xmmword_1EB2ACC50) == 0) & (*(unsigned __int8 *)(a1 + 2725) >> 5);
      break;
    case 38:
      if ((~*(_DWORD *)(a1 + 2724) & 0x1400000) != 0) {
        uint64_t result = 0;
      }
      else {
        uint64_t result = BYTE7(xmmword_1EB2ACC50) ^ 1u;
      }
      break;
    case 40:
      uint64_t result = (*(_DWORD *)(a1 + 2724) >> 26) & 1;
      break;
    default:
      BOOL v5 = a2 == 28 || a2 == 16;
LABEL_21:
      uint64_t result = v5;
      break;
  }
  return result;
}

void CA::OGL::render_contents_background(CA::OGL::Context **a1, uint64_t a2, uint64_t a3, const int *a4, double a5, float32x4_t a6, int8x16_t a7)
{
  double v8 = a1;
  uint64_t v313 = *MEMORY[0x1E4F143B8];
  double v9 = *a1;
  uint64_t v10 = *((void *)*a1 + 31);
  uint64_t v262 = 0;
  double v11 = 0.0;
  memset(v261, 0, sizeof(v261));
  uint64_t v12 = *(void *)(v10 + 8);
  uint64_t v13 = *(void *)(a2 + 32) & 0x200005020;
  BOOL v14 = v13 == 0;
  uint64_t v15 = *(void *)(a2 + 16);
  unsigned int v16 = *(const CA::Shape **)(v15 + 216);
  uint64_t v17 = v12;
  int32x4_t v18 = (_OWORD *)v10;
  if (!v16) {
    goto LABEL_9;
  }
  __int16 v19 = *(_WORD *)(v10 + 68);
  uint64_t v17 = *(void *)(v10 + 8);
  int32x4_t v18 = (_OWORD *)v10;
  if ((v19 & 0x100) == 0) {
    goto LABEL_9;
  }
  _ZF = !*(_DWORD *)(v15 + 112) && BYTE11(ca_debug_options) == 0;
  uint64_t v17 = *(void *)(v10 + 8);
  int32x4_t v18 = (_OWORD *)v10;
  if (!_ZF || (uint64_t v17 = *(void *)(v10 + 8), v18 = (_OWORD *)v10, (*(_DWORD *)(v15 + 24) & 0x1C000) != 0))
  {
LABEL_9:
    if ((v17 & 1) == 0) {
      goto LABEL_10;
    }
LABEL_17:
    if (v17 == 1) {
      goto LABEL_29;
    }
    goto LABEL_18;
  }
  *(_OWORD *)((char *)v261 + 8) = *(_OWORD *)(v10 + 8);
  uint64_t v21 = *(void *)(v10 + 32);
  *((void *)&v261[1] + 1) = *(void *)(v10 + 24);
  *(void *)&v261[2] = v21;
  *(_OWORD *)((char *)&v261[2] + 8) = *(_OWORD *)(v10 + 40);
  *((void *)&v261[3] + 1) = *(void *)(v10 + 56);
  LODWORD(v262) = *(_DWORD *)(v10 + 64);
  WORD2(v262) = v19 & 0x5FF;
  unint64_t v22 = CA::Shape::subtract(*((CA::Shape **)&v261[0] + 1), v16, a3, a4);
  *((void *)&v261[0] + 1) = v22;
  if ((*((unsigned char *)v9 + 432) & 0x10) != 0)
  {
    uint64_t v23 = *(void *)(v10 + 8);
    if ((v23 & 1) == 0)
    {
      if (*(_DWORD *)(v23 + 4) == 12) {
        goto LABEL_16;
      }
      goto LABEL_15;
    }
    if (v23 == 1)
    {
LABEL_15:
      v285[0] = 0uLL;
      CA::Shape::get_bounds(v22, (int *)v285);
      CA::Shape::unref(*((CA::Shape **)&v261[0] + 1));
      *((void *)&v261[0] + 1) = CA::Shape::new_shape((unsigned int *)v285);
    }
  }
LABEL_16:
  int32x4_t v18 = v261;
  *(void *)&v261[0] = CA::OGL::Context::set_gstate((uint64_t)v9, (uint64_t)v261);
  uint64_t v17 = *((void *)&v261[0] + 1);
  if (BYTE8(v261[0])) {
    goto LABEL_17;
  }
LABEL_10:
  if (*(_DWORD *)(v17 + 4) == 6) {
    goto LABEL_29;
  }
LABEL_18:
  if ((*(unsigned char *)(a2 + 33) & 1) == 0) {
    goto LABEL_27;
  }
  uint64_t v24 = *(void *)(a2 + 16);
  if ((*(unsigned char *)(v24 + 27) & 2) != 0) {
    __assert_rtn("render_contents_background", "ogl-layer.cpp", 3154, "!(l->node->flags & Render::kLayerNodeIgnoreContents)");
  }
  uint64_t v25 = *(void *)(v24 + 48);
  if (!v25) {
    goto LABEL_27;
  }
  uint64_t v26 = (*(uint64_t (**)(uint64_t))(*(void *)v25 + 80))(v25);
  unsigned int v256 = v18;
  if (!v26)
  {
    if (*(unsigned char *)(v25 + 12) == 26)
    {
      CA::OGL::render_background(v8, a2, v11, a6, a7);
      *(void *)&long long v252 = *v8;
      uint64_t v254 = *(void *)(v252 + 248);
      unsigned int v32 = *(unsigned char **)(v25 + 24);
      unint64_t v31 = *(unsigned char **)(v25 + 32);
      if (v31) {
        uint64_t v33 = (*(uint64_t (**)(void))(*(void *)v31 + 80))(*(void *)(v25 + 32));
      }
      else {
        uint64_t v33 = 0;
      }
      int v251 = v32;
      if (!v32) {
        goto LABEL_29;
      }
      int64x2_t v61 = (double *)v33;
      float64x2_t v62 = (double *)(*(uint64_t (**)(unsigned char *))(*(void *)v251 + 80))(v251);
      if (!v61 || !v62) {
        goto LABEL_29;
      }
      int v250 = v62;
      uint64_t v312 = 0;
      long long v311 = 0u;
      long long v310 = 0u;
      long long v309 = 0u;
      long long v308 = 0u;
      long long v307 = 0u;
      long long v306 = 0u;
      long long v305 = 0u;
      long long v304 = 0u;
      long long v303 = 0u;
      long long v302 = 0u;
      long long v301 = 0u;
      long long v300 = 0u;
      long long v299 = 0u;
      long long v298 = 0u;
      long long v297 = 0u;
      long long v296 = 0u;
      long long v295 = 0u;
      long long v294 = 0u;
      long long v293 = 0u;
      long long v292 = 0u;
      long long v291 = 0u;
      long long v290 = 0u;
      long long v289 = 0u;
      long long v288 = 0u;
      long long v287 = 0u;
      long long v286 = 0u;
      memset(v285, 0, sizeof(v285));
      CA::OGL::ContentsGeometry::ContentsGeometry((uint64_t)v285, a2, v254, (uint64_t)v61, (uint64_t)v31, v252);
      unint64_t v255 = v8;
      if ((_BYTE)v298) {
        DWORD1(v300) |= 0x100u;
      }
      else {
        int64x2_t v61 = 0;
      }
      uint64_t v284 = 0;
      long long v282 = 0u;
      long long v283 = 0u;
      long long v280 = 0u;
      long long v281 = 0u;
      long long v278 = 0u;
      long long v279 = 0u;
      long long v276 = 0u;
      long long v277 = 0u;
      long long v274 = 0u;
      long long v275 = 0u;
      long long v272 = 0u;
      long long v273 = 0u;
      memset(v271, 0, sizeof(v271));
      CA::OGL::ContentsGeometry::ContentsGeometry((uint64_t)v271, a2, v254, (uint64_t)v250, (uint64_t)v251, v252);
      int v96 = LOBYTE(v271[17]);
      if (LOBYTE(v271[17]))
      {
        DWORD1(v272) |= 0x100u;
        LODWORD(v253) = v61 != 0;
      }
      else
      {
        if (!v61) {
          goto LABEL_29;
        }
        int v250 = 0;
        LODWORD(v253) = 1;
      }
      float64x2_t v97 = *(float64x2_t *)((char *)&v285[2] + 8);
      float64x2_t v98 = *(float64x2_t *)((char *)&v285[3] + 8);
      v99.f64[1] = *(float64_t *)&v271[4];
      int64x2_t v100 = vclezq_f64(*(float64x2_t *)((char *)&v285[3] + 8));
      int64x2_t v101 = vclezq_f64(*(float64x2_t *)((char *)&v271[3] + 8));
      int32x2_t v102 = vmovn_s64(vcltzq_s64((int64x2_t)vorrq_s8((int8x16_t)vzip1q_s64(v101, v100), (int8x16_t)vzip2q_s64(v101, v100))));
      if (v102.i8[4])
      {
        if (v102.i8[0]) {
          unint64_t v103 = -1;
        }
        else {
          unint64_t v103 = 0;
        }
        int8x16_t v104 = (int8x16_t)vdupq_n_s64(v103);
        float64x2_t v98 = (float64x2_t)vbslq_s8(v104, *(int8x16_t *)((char *)&v285[3] + 8), *(int8x16_t *)((char *)&v271[3] + 8));
        float64x2_t v97 = (float64x2_t)vbslq_s8(v104, *(int8x16_t *)((char *)&v285[2] + 8), *(int8x16_t *)((char *)&v271[2] + 8));
      }
      else if ((v102.i8[0] & 1) == 0)
      {
        float64x2_t v97 = vminnmq_f64(*(float64x2_t *)((char *)&v285[2] + 8), *(float64x2_t *)((char *)&v271[2] + 8));
        float64x2_t v99 = vmaxnmq_f64(vaddq_f64(*(float64x2_t *)((char *)&v285[2] + 8), *(float64x2_t *)((char *)&v285[3] + 8)), vaddq_f64(*(float64x2_t *)((char *)&v271[2] + 8), *(float64x2_t *)((char *)&v271[3] + 8)));
        float64x2_t v98 = vsubq_f64(v99, v97);
      }
      v99.f64[0] = *(float64_t *)(v25 + 48);
      *(float *)v99.f64 = v99.f64[0];
      if (*(float *)v99.f64 > 1.0) {
        *(float *)v99.f64 = 1.0;
      }
      if (*(float *)v99.f64 < 0.0) {
        *(float *)v99.f64 = 0.0;
      }
      float64x2_t v247 = v98;
      float64x2_t v248 = v99;
      int64x2_t v105 = vceqzq_f64(v98);
      unint64_t v106 = vorrq_s8((int8x16_t)vdupq_laneq_s64(v105, 1), (int8x16_t)v105).u64[0];
      float64x2_t v246 = v97;
      if ((v106 & 0x8000000000000000) != 0
        || (int8x16_t v107 = vorrq_s8((int8x16_t)vcltzq_f64(v98), (int8x16_t)vcgezq_f64(v98)),
            (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v107), 1), v107).u64[0] & 0x8000000000000000) != 0))
      {
        *(void *)uint64_t v266 = 0;
        *(void *)&v266[8] = 0;
      }
      else
      {
        int32x4_t v108 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v97, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
        *(int32x4_t *)uint64_t v266 = vuzp1q_s32(v108, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v97, v98), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v108));
      }
      if (!CA::Shape::intersects(*(void *)(v254 + 8), (int32x2_t *)v266))
      {
        uint64_t v115 = (CA::OGL::Context *)v252;
        long long v116 = v61;
LABEL_350:
        *(float *)&double v228 = CA::OGL::ContentsGeometry::fill_debug((uint64_t)v285, (uint64_t)v115, a2, v116, 0, v109, v110);
        CA::OGL::ContentsGeometry::fill_debug((uint64_t)v271, (uint64_t)v115, a2, v250, 0, v228, v229);
        goto LABEL_29;
      }
      float64x2_t v111 = (CA::Render::Image *)v61;
      if (v253 && *((unsigned char *)v61 + 12) == 51)
      {
        (*(void (**)(double *))(*(void *)v61 + 280))(v61);
        float64x2_t v111 = (CA::Render::Image *)v61;
      }
      if (v96 && *((unsigned char *)v250 + 12) == 51)
      {
        (*(void (**)(double *))(*(void *)v250 + 280))(v250);
        float64x2_t v111 = (CA::Render::Image *)v61;
      }
      uint64_t v112 = *(void *)(a2 + 24);
      int v113 = *(_DWORD *)(v112 + 36);
      if ((v113 & 0xFu) > 0xA) {
        int v114 = 1;
      }
      else {
        int v114 = CA::OGL::texture_filter(CA::Render::ImageFilter)::filters[v113 & 0xF];
      }
      uint64_t v122 = v113 >> 4;
      if (v122 > 0xA) {
        int v123 = 1;
      }
      else {
        int v123 = CA::OGL::texture_filter(CA::Render::ImageFilter)::filters[v122];
      }
      int v245 = v123;
      uint64_t v124 = *(void *)(v112 + 128);
      if (v124) {
        float v125 = *(float *)(v124 + 292);
      }
      else {
        float v125 = 0.0;
      }
      unsigned __int8 v260 = v114;
      unsigned __int8 v259 = v114;
      if (v114 == 11)
      {
        unint64_t v126 = v106;
        uint64_t v127 = CA::OGL::Context::tile_cache_load((double *)v252, (uint64_t)v285, v111, &v260);
        int v128 = (double *)CA::OGL::Context::tile_cache_load((double *)v252, (uint64_t)v271, (CA::Render::Image *)v250, &v259);
        float64x2_t v111 = v127;
        unint64_t v106 = v126;
        uint64_t v124 = *(void *)(*(void *)(a2 + 24) + 128);
      }
      else
      {
        int v128 = v250;
      }
      float16x4_t v129 = *(float16x4_t *)(v254 + 32);
      if (v124)
      {
        float16x4_t v130 = vcvt_f16_f32(*(float32x4_t *)(v124 + 268));
        char v131 = *(unsigned char *)(v124 + 324);
        int v132 = v131 & 1;
        if (v131)
        {
          int v133 = 1;
          BYTE4(v302) = 1;
          BYTE4(v274) = 1;
        }
        else
        {
          int v133 = 0;
        }
        BOOL v244 = (v131 & 1) == 0;
        if (*(void *)&v130 != 0x3C003C003C003C00) {
          float16x4_t v129 = vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16(v130), vcvtq_f32_f16(v129)));
        }
      }
      else
      {
        int v133 = 0;
        int v132 = 0;
        BOOL v244 = 1;
      }
      unint64_t v249 = v111;
      int v250 = v128;
      if (!v111 || !v128)
      {
        LODWORD(v254) = v132;
        unsigned int v142 = (float)((float)(*(float *)v248.f64 * 255.0) + 0.5);
        if (!v111) {
          unsigned int v142 = 255 - v142;
        }
        LODWORD(v256) = v142;
        if (v111) {
          uint64_t v143 = (uint64_t)v111;
        }
        else {
          uint64_t v143 = (uint64_t)v128;
        }
        if (v111) {
          long long v144 = v31;
        }
        else {
          long long v144 = v251;
        }
        if (v111) {
          long long v145 = v285;
        }
        else {
          long long v145 = v271;
        }
        if (v111) {
          long long v146 = &v260;
        }
        else {
          long long v146 = &v259;
        }
        unsigned int v147 = *v146;
        uint64_t v148 = *(void *)(v252 + 16);
        if (*(unsigned __int8 *)(v148 + 480) >= 2u) {
          *(unsigned char *)(v148 + 481) |= 1u;
        }
        CA::OGL::prepare_color_program_cache(v255, a2, v143, (uint64_t)v144);
        long long v149 = (double *)*((unsigned int *)v145 + 77);
        uint64_t v115 = (CA::OGL::Context *)v252;
        LODWORD(v255) = v147;
        long long v150 = (uint32x2_t **)CA::OGL::Context::bind_image(v252, 0, (uint32x2_t *)v143, v149, v147, v245, 0, (CA::OGL::ContentsGeometry *)v145, v125, (float32x4_t *)((char *)v145 + 276), 0);
        if (v150)
        {
          unint64_t v151 = v150;
          _Q1 = vcvtq_f32_f16(v129);
          float16x4_t v153 = vcvt_f16_f32(vmulq_n_f32(_Q1, (float)v256));
          if ((*(unsigned char *)(v143 + 14) & 0x10) != 0)
          {
            _Q1.i32[0] = *(_DWORD *)(v143 + 60);
            _S2 = *(_DWORD *)(v143 + 64);
            __asm
            {
              FCVT            H1, S1
              FCVT            H2, S2
            }
            uint64_t v155 = _Q1.u32[0];
            uint64_t v156 = _S2;
            _Q1.i64[0] = *(void *)(v143 + 68);
            unint64_t v157 = vmovl_u16((uint16x4_t)vcvt_f16_f32(_Q1)).u64[0];
            v158.i64[0] = v157;
            v158.i64[1] = HIDWORD(v157);
            v159.i64[0] = 0xFFFFLL;
            v159.i64[1] = 0xFFFFLL;
            int64x2_t v160 = (int64x2_t)vshlq_u64((uint64x2_t)vandq_s8(v158, v159), (uint64x2_t)xmmword_184997FE0);
            float16x4_t v153 = vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)(vorrq_s8((int8x16_t)vdupq_laneq_s64(v160, 1), (int8x16_t)v160).u64[0] | (v156 << 16) | v155)), vcvtq_f32_f16(v153)));
          }
          uint64_t v115 = (CA::OGL::Context *)v252;
          *(float16x4_t *)(*(void *)(v252 + 16) + 8) = v153;
          if (!v244)
          {
            if ((v254 & 1) == 0) {
              __assert_rtn("set_swizzle", "ogl-layer.cpp", 2184, "swizzle == Render::kLayerContentsSwizzleAAAA");
            }
            int v161 = (*(uint64_t (**)(CA::OGL::Context *, uint64_t))(*(void *)v115 + 184))(v115, 28);
            uint64_t v162 = *((void *)v115 + 2);
            if (v161)
            {
              char v163 = CA::OGL::swizzle_to_image_function(CA::Render::LayerContentsSwizzle,CA::OGL::ImageFunction)::AAAA_functions[*(unsigned __int8 *)(v162 + 17)];
              if (!v163) {
                char v163 = 33;
              }
            }
            else
            {
              char v163 = 21;
            }
            *(unsigned char *)(v162 + 17) = v163;
          }
          CA::OGL::ContentsGeometry::fill_and_unbind((uint64_t)v145, (uint64_t)v115, v151, (double *)v255, v125);
        }
        *(unsigned char *)(*((void *)v115 + 2) + 481) &= ~1u;
LABEL_282:
        long long v116 = (double *)v249;
        goto LABEL_350;
      }
      if (((BYTE4(v272) | BYTE4(v300)) & 0x3F) != 0 && (*(_WORD *)(a2 + 40) & 0x3C0) != 0) {
        goto LABEL_314;
      }
      if (*(void *)&v129 != 0x3C003C003C003C00) {
        goto LABEL_314;
      }
      if (BYTE1(v302) | BYTE1(v274)) {
        goto LABEL_314;
      }
      if (*((double *)v285 + 1) != *((double *)v271 + 1)) {
        goto LABEL_314;
      }
      if (*(double *)&v285[1] != *(double *)&v271[1]) {
        goto LABEL_314;
      }
      if (*((double *)&v285[1] + 1) != *((double *)&v271[1] + 1)) {
        goto LABEL_314;
      }
      if (*(double *)&v285[2] != *(double *)&v271[2]) {
        goto LABEL_314;
      }
      if (!CA::Transform::operator==((uint64_t)&v287 + 8, (uint64_t)&v271[6] + 8)) {
        goto LABEL_314;
      }
      if (BYTE10(v311)) {
        goto LABEL_314;
      }
      if (BYTE10(v283)) {
        goto LABEL_314;
      }
      __asm { FMOV            V0.4S, #1.0 }
      if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqq_f32(*(float32x4_t *)((char *)v249 + 60), _Q0)))) & 1) != 0|| (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqq_f32(*(float32x4_t *)((char *)v250 + 60), _Q0)))) & 1) != 0|| v31[12] == 50|| v251[12] == 50)
      {
LABEL_314:
        __n128 i = 0uLL;
        CA::Shape::get_bounds(*(void *)(v254 + 8), (int *)&i);
        __n128 v203 = 0uLL;
        if ((v106 & 0x8000000000000000) == 0)
        {
          int8x16_t v204 = vorrq_s8((int8x16_t)vcltzq_f64(v247), (int8x16_t)vcgezq_f64(v247));
          if ((vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v204), 1), v204).u64[0] & 0x8000000000000000) == 0)
          {
            int32x4_t v205 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v246, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
            __n128 v203 = (__n128)vuzp1q_s32(v205, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v246, v247), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v205));
          }
        }
        uint32x2_t v206 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)&i.n128_i8[8]);
        uint64_t v115 = (CA::OGL::Context *)v252;
        if ((vpmax_u32(v206, v206).u32[0] & 0x80000000) == 0)
        {
          int32x2_t v207 = (int32x2_t)vextq_s8((int8x16_t)v203, (int8x16_t)v203, 8uLL).u64[0];
          uint32x2_t v208 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v207);
          if ((vpmax_u32(v208, v208).u32[0] & 0x80000000) != 0
            || (int32x2_t v209 = vadd_s32((int32x2_t)v203.n128_u64[0], v207),
                v203.n128_u64[0] = (unint64_t)vmax_s32((int32x2_t)i.n128_u64[0], (int32x2_t)v203.n128_u64[0]),
                int32x2_t v210 = vsub_s32(vmin_s32(vadd_s32((int32x2_t)i.n128_u64[0], *(int32x2_t *)&i.n128_i8[8]), v209), (int32x2_t)v203.n128_u64[0]), v211 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v210), (vpmax_u32(v211, v211).u32[0] & 0x80000000) != 0))
          {
            i.n128_u64[1] = 0;
          }
          else
          {
            *(int32x2_t *)&v203.n128_i8[8] = v210;
            __n128 i = v203;
          }
        }
        uint64_t v212 = *(void *)(a2 + 24);
        if ((*(unsigned char *)(v212 + 36) & 0xE) != 0
          || (*(unsigned char *)(v212 + 41) & 0x80) != 0
          || (*((unsigned char *)v249 + 14) & 4) == 0
          && ((*(uint64_t (**)(__n128))(*(void *)v249 + 200))(v203)
           || ((*(uint64_t (**)(void, CA::Render::Image *))(*(void *)v252 + 568))(v252, v249) & 1) != 0)
          || (*((unsigned char *)v250 + 14) & 4) == 0
          && ((*(uint64_t (**)(double *, __n128))(*(void *)v250 + 200))(v250, v203)
           || (*(unsigned int (**)(void, double *))(*(void *)v252 + 568))(v252, v250)))
        {
          uint64_t v213 = 15;
        }
        else
        {
          uint64_t v213 = 2063;
        }
        uint64_t v214 = (*(uint64_t (**)(void, uint64_t, __n128 *, uint64_t, __n128))(*(void *)v252 + 656))(v252, 1, &i, v213, v203);
        if (v214)
        {
          unint64_t v215 = (_DWORD *)v214;
          int v243 = v133;
          LODWORD(v253) = *(_DWORD *)(v214 + 68);
          *((void *)&v267 + 1) = 0x3C003C003C003C00;
          long long v268 = 0uLL;
          uint64_t v269 = 0;
          uint64_t v270 = 0;
          *(_OWORD *)&v266[8] = *(_OWORD *)(v254 + 8);
          uint64_t v216 = *(void *)(v254 + 24);
          *(void *)uint64_t v266 = 0;
          *(void *)&long long v267 = v216;
          LODWORD(v270) = *(_DWORD *)(v254 + 64);
          __int16 v217 = *(_WORD *)(v254 + 68) & 0x500;
          float64x2_t v264 = 0u;
          long long v265 = 0u;
          long long v263 = 0u;
          CA::Shape::operator=((uint64_t)&v263, &i);
          *(void *)&v266[8] = &v263;
          uint64_t v115 = (CA::OGL::Context *)v252;
          WORD2(v270) = v217 | 0xC;
          *(void *)uint64_t v266 = CA::OGL::Context::set_gstate(v252, (uint64_t)v266);
          unsigned int v256 = v215;
          CA::OGL::Context::push_surface(v252, (uint64_t)v215, 1u, 32, 0);
          uint64_t v218 = v255;
          CA::OGL::prepare_color_program_cache(v255, a2, (uint64_t)v249, (uint64_t)v31);
          char v219 = (uint32x2_t **)CA::OGL::Context::bind_image(v252, 0, (uint32x2_t *)v249, (double *)DWORD1(v300), v260, v245, 0, (CA::OGL::ContentsGeometry *)v285, v125, (float32x4_t *)((char *)&v298 + 4), 0);
          if (v219)
          {
            uint64_t v220 = v219;
            *(float16x4_t *)(*(void *)(v252 + 16) + 8) = vcvt_f16_f32(vmulq_n_f32(*(float32x4_t *)((char *)v249 + 60), *(float *)v248.f64));
            if (!v244) {
              CA::OGL::set_swizzle(v115, 0, v243);
            }
            CA::OGL::ContentsGeometry::fill_and_unbind((uint64_t)v285, (uint64_t)v115, v220, (double *)v260, v125);
          }
          CA::OGL::prepare_color_program_cache(v218, a2, (uint64_t)v250, (uint64_t)v251);
          float v221 = (uint32x2_t **)CA::OGL::Context::bind_image((uint64_t)v115, 0, (uint32x2_t *)v250, (double *)DWORD1(v272), v259, v245, 0, (CA::OGL::ContentsGeometry *)v271, v125, (float32x4_t *)((char *)&v271[17] + 4), 0);
          if (v221)
          {
            unint64_t v222 = v221;
            *(float16x4_t *)(*((void *)v115 + 2) + 8) = vcvt_f16_f32(vmulq_n_f32(*(float32x4_t *)((char *)v250 + 60), 1.0 - *(float *)v248.f64));
            if (!v244) {
              CA::OGL::set_swizzle(v115, 0, v243);
            }
            *(unsigned char *)(*((void *)v115 + 2) + 481) |= 1u;
            CA::OGL::ContentsGeometry::fill_and_unbind((uint64_t)v271, (uint64_t)v115, v222, (double *)v259, v125);
            *(unsigned char *)(*((void *)v115 + 2) + 481) &= ~1u;
          }
          CA::OGL::Context::pop_surface(v115);
          CA::OGL::Context::set_gstate((uint64_t)v115, **((void **)v115 + 31));
          if (*(void *)&v129 == 0x3C003C003C003C00)
          {
            unsigned int v223 = 1;
          }
          else
          {
            *(float16x4_t *)(*((void *)v115 + 2) + 8) = v129;
            unsigned int v223 = 3;
          }
          uint64_t v225 = *((void *)v115 + 2);
          if (*(unsigned __int8 *)(v225 + 480) >= 2u) {
            *(unsigned char *)(v225 + 481) |= 1u;
          }
          float v226 = *(CA::Shape **)(v254 + 8);
          v257[0] = 0;
          v257[1] = 0;
          int v227 = v256;
          CA::OGL::emit_combine((uint64_t)v115, v223, v256, 0, v226, (unsigned int *)v257);
          *(unsigned char *)(*((void *)v115 + 2) + 481) &= ~1u;
          CA::OGL::Context::release_surface((uint64_t)v115, (uint64_t)v227);
          if ((v253 & 0x800) != 0) {
            uint64_t v224 = 8388736;
          }
          else {
            uint64_t v224 = 2155872384;
          }
        }
        else
        {
          uint64_t v224 = 2155872384;
        }
        long long v116 = (double *)v249;
        if (!byte_1EB2ACBE1) {
          goto LABEL_350;
        }
        *(void *)uint64_t v266 = (char *)v285 + 8;
        *(void *)&v266[8] = (char *)&v287 + 8;
        *(void *)&v266[16] = *(void *)((char *)&v300 + 4);
        long long v267 = 0uLL;
        *(void *)&long long v268 = (char *)&v285[2] + 8;
        CA::OGL::fill_color_rect((uint64_t)v115, (uint64_t)v266, (double *)v224, (double *)v249, *(double *)((char *)&v300 + 4), v110);
        goto LABEL_282;
      }
      unint64_t v239 = v106;
      int v243 = v133;
      uint64_t v253 = v12;
      uint64_t v135 = v252;
      *(unsigned char *)(*(void *)(v252 + 16) + 16) = 7;
      CA::OGL::prepare_color_program_cache(v255, a2, (uint64_t)v249, (uint64_t)v31);
      BOOL v242 = (const CA::Transform *)((char *)&v298 + 4);
      float64x2_t v136 = CA::OGL::Context::bind_image(v135, 0, (uint32x2_t *)v249, (double *)DWORD1(v300), v260, v245, 0, (CA::OGL::ContentsGeometry *)v285, v125, (float32x4_t *)((char *)&v298 + 4), 0);
      CA::OGL::prepare_color_program_cache(v255, a2, (uint64_t)v250, (uint64_t)v251);
      unsigned __int8 v240 = v136;
      unsigned __int8 v241 = CA::OGL::Context::bind_image(v252, 1u, (uint32x2_t *)v250, (double *)DWORD1(v272), v259, v245, 0, (CA::OGL::ContentsGeometry *)v271, v125, (float32x4_t *)((char *)&v271[17] + 4), 0);
      if (v136 && v241)
      {
        if ((*(uint64_t (**)(void))(*(void *)v252 + 984))(v252))
        {
          _D0 = *(int16x4_t *)&v248.f64[0];
          __asm { FCVT            H0, S0 }
          *(int16x4_t *)(*(void *)(v252 + 16) + 8) = vdup_lane_s16(_D0, 0);
          if (!v244)
          {
            CA::OGL::set_swizzle((void *)v252, 0, v243);
            CA::OGL::set_swizzle((void *)v252, 1u, v243);
          }
          uint64_t v138 = *(void *)(v252 + 16);
          unsigned int v139 = *(unsigned __int8 *)(v138 + 480);
          if (v139 >= 2
            && (v139 != 3
             || !(*((_DWORD *)v249 + 3) & 0x1000 | WORD2(v300) & 0x200)
             || !(*((_DWORD *)v250 + 3) & 0x1000 | WORD2(v272) & 0x200)))
          {
            *(unsigned char *)(v138 + 481) |= 1u;
          }
          long long v263 = *(_OWORD *)((char *)v285 + 8);
          float64x2_t v264 = vaddq_f64(*(float64x2_t *)((char *)&v285[1] + 8), *(float64x2_t *)((char *)v285 + 8));
          long long v268 = 0u;
          uint64_t v140 = *(void *)(*(void *)(v252 + 248) + 8);
          *(void *)uint64_t v266 = v252;
          *(void *)&v266[8] = v140;
          long long v267 = 0u;
          *(void *)&v266[16] = 0;
          BYTE8(v267) = ((BYTE8(v296) >> 4) & 1) == 0;
          BYTE9(v267) = 1;
          CA::OGL::Context::ClippedArray::start((CA::OGL::Context::ClippedArray *)v266);
          for (__n128 i = 0uLL;
                CA::OGL::Context::ClippedArray::next_rect((CA::OGL::Context::ClippedArray *)v266, (int32x2_t *)&i);
                CA::OGL::emit_quad((CA::OGL *)v252, (CA::OGL::Context *)&v263, i.n128_f64, (const CA::Bounds *)((char *)&v287 + 8), v242, (float *)&v271[17] + 1, v141))
          {
            ;
          }
          uint64_t v115 = (CA::OGL::Context *)v252;
          *(unsigned char *)(*(void *)(v252 + 16) + 481) &= ~1u;
          uint64_t v230 = *((void *)v115 + 2);
          *(void *)(v230 + 24) = 0;
          *(void *)(v230 + 32) = 0;
          (*(void (**)(CA::OGL::Context *, _OWORD *, uint64_t))(*(void *)v115 + 520))(v115, v241, 1);
          (*(void (**)(CA::OGL::Context *, _OWORD *, void))(*(void *)v115 + 520))(v115, v240, 0);
          *(unsigned char *)(*((void *)v115 + 2) + 16) = 0;
          long long v116 = (double *)v249;
          uint64_t v12 = v253;
          int32x4_t v18 = v256;
          goto LABEL_350;
        }
      }
      else if (!v241)
      {
LABEL_311:
        if (v240) {
          (*(void (**)(void, _OWORD *, void))(*(void *)v252 + 520))(v252, v240, 0);
        }
        *(unsigned char *)(*(void *)(v252 + 16) + 16) = 0;
        uint64_t v12 = v253;
        int32x4_t v18 = v256;
        int v133 = v243;
        unint64_t v106 = v239;
        goto LABEL_314;
      }
      (*(void (**)(void, _OWORD *, uint64_t))(*(void *)v252 + 520))(v252, v241, 1);
      goto LABEL_311;
    }
LABEL_27:
    if (!v13) {
      goto LABEL_29;
    }
    goto LABEL_28;
  }
  uint64_t v253 = v12;
  int v27 = (CA::Render::Image *)v26;
  unint64_t v255 = v8;
  if ((*(unsigned int (**)(CA::OGL::Context *))(*(void *)v9 + 88))(v9))
  {
    uint64_t v28 = (uint64_t)v27;
    uint64_t v29 = (*(uint64_t (**)(CA::Render::Image *))(*(void *)v27 + 240))(v27);
    uint64_t v30 = (*(uint64_t (**)(CA::OGL::Context *))(*(void *)v9 + 96))(v9) & v29;
    LODWORD(v254) = v30 == (*(uint64_t (**)(CA::Render::Image *))(*(void *)v27 + 240))(v27);
  }
  else
  {
    LODWORD(v254) = 1;
    uint64_t v28 = (uint64_t)v27;
  }
  uint64_t v34 = *(void *)(*(void *)(a2 + 24) + 96);
  CA::OGL::prepare_color_program_cache(v255, a2, v28, v34);
  uint64_t v312 = 0;
  long long v311 = 0u;
  long long v310 = 0u;
  long long v309 = 0u;
  long long v308 = 0u;
  long long v307 = 0u;
  long long v306 = 0u;
  long long v305 = 0u;
  long long v304 = 0u;
  long long v303 = 0u;
  long long v302 = 0u;
  long long v301 = 0u;
  long long v300 = 0u;
  long long v299 = 0u;
  long long v298 = 0u;
  long long v297 = 0u;
  long long v296 = 0u;
  long long v295 = 0u;
  long long v294 = 0u;
  long long v293 = 0u;
  long long v292 = 0u;
  long long v291 = 0u;
  long long v290 = 0u;
  long long v289 = 0u;
  long long v288 = 0u;
  long long v287 = 0u;
  long long v286 = 0u;
  memset(v285, 0, sizeof(v285));
  uint64_t v35 = CA::OGL::ContentsGeometry::ContentsGeometry((uint64_t)v285, a2, (uint64_t)v256, v28, v25, (uint64_t)v9);
  if ((_BYTE)v298)
  {
    uint64_t v39 = *(void *)(a2 + 24);
    int v40 = *(_DWORD *)(v39 + 36);
    if ((v40 & 0xFu) > 0xA) {
      int v41 = 1;
    }
    else {
      int v41 = CA::OGL::texture_filter(CA::Render::ImageFilter)::filters[v40 & 0xF];
    }
    int32x4_t v18 = v256;
    LOBYTE(v263) = v41;
    uint64_t v43 = v40 >> 4;
    if (v43 > 0xA) {
      int v44 = 1;
    }
    else {
      int v44 = CA::OGL::texture_filter(CA::Render::ImageFilter)::filters[v43];
    }
    LODWORD(v251) = v44;
    uint64_t v45 = *(void *)(v39 + 128);
    if (v45) {
      float v46 = *(float *)(v45 + 292);
    }
    else {
      float v46 = 0.0;
    }
    if (v41 == 11)
    {
      uint64_t v35 = (uint64_t)CA::OGL::Context::tile_cache_load((double *)v9, (uint64_t)v285, v27, &v263);
      uint64_t v47 = v35;
      uint64_t v45 = *(void *)(*(void *)(a2 + 24) + 128);
    }
    else
    {
      uint64_t v47 = (uint64_t)v27;
    }
    uint64_t v12 = v253;
    if (v45) {
      _Q0 = *(__n128 *)(v45 + 268);
    }
    else {
      __asm { FMOV            V0.4S, #1.0 }
    }
    *(void *)&long long v38 = *((void *)v256 + 4);
    _Q0.n128_u64[0] = (unint64_t)vcvt_f16_f32((float32x4_t)_Q0);
    if (_Q0.n128_u64[0] != 0x3C003C003C003C00)
    {
      a6 = vcvtq_f32_f16(*(float16x4_t *)&v38);
      _Q0 = (__n128)vmulq_f32(vcvtq_f32_f16((float16x4_t)_Q0.n128_u64[0]), a6);
      *(float16x4_t *)&long long v38 = vcvt_f16_f32((float32x4_t)_Q0);
    }
    int v52 = *(_DWORD *)(v47 + 12);
    if ((v52 & 0x100000) != 0)
    {
      _Q0.n128_u32[0] = *(_DWORD *)(v47 + 60);
      _S1 = *(_DWORD *)(v47 + 64);
      __asm
      {
        FCVT            H0, S0
        FCVT            H1, S1
      }
      uint64_t v54 = _Q0.n128_u32[0];
      uint64_t v55 = _S1;
      _Q0.n128_u64[0] = *(void *)(v47 + 68);
      unint64_t v56 = vmovl_u16((uint16x4_t)vcvt_f16_f32((float32x4_t)_Q0)).u64[0];
      v57.i64[0] = v56;
      v57.i64[1] = HIDWORD(v56);
      v58.i64[0] = 0xFFFFLL;
      v58.i64[1] = 0xFFFFLL;
      int64x2_t v59 = (int64x2_t)vshlq_u64((uint64x2_t)vandq_s8(v57, v58), (uint64x2_t)xmmword_184997FE0);
      a6 = vcvtq_f32_f16((float16x4_t)(vorrq_s8((int8x16_t)vdupq_laneq_s64(v59, 1), (int8x16_t)v59).u64[0] | (v55 << 16) | v54));
      _Q0 = (__n128)vmulq_f32(a6, vcvtq_f32_f16(*(float16x4_t *)&v38));
      *(float16x4_t *)&long long v38 = vcvt_f16_f32((float32x4_t)_Q0);
    }
    _Q0.n128_u16[0] = WORD3(v38);
    *(short float *)a6.i16 = COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0));
    if (*((short float *)&v38 + 3) != COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)) || (*(unsigned char *)(a2 + 35) & 0x10) != 0) {
      goto LABEL_74;
    }
    if ((v52 & 0x1000) != 0)
    {
      if (!v254)
      {
LABEL_74:
        int v63 = 0;
        goto LABEL_75;
      }
      char v60 = BYTE4(v300);
    }
    else
    {
      char v60 = BYTE4(v300);
      if ((v254 & (DWORD1(v300) >> 9)) != 1) {
        goto LABEL_74;
      }
    }
    if ((v60 & 9) != 0)
    {
      int v63 = 1;
      if ((*(_WORD *)(a2 + 40) & 0x3C0) == 0 && !BYTE10(v311))
      {
        int v64 = 1;
        int v65 = 1;
        if (v13)
        {
LABEL_76:
          uint64_t v66 = v47;
          long long v252 = v38;
          uint64_t v35 = (uint64_t)CA::OGL::render_background(v255, a2, _Q0.n128_f64[0], a6, a7);
          *(void *)&long long v38 = v252;
          uint64_t v47 = v66;
          int32x4_t v18 = v256;
          int v65 = v64;
        }
LABEL_77:
        if ((*(unsigned char *)(a2 + 35) & 0x10) != 0)
        {
          MEMORY[0x1F4188790](v35);
          LODWORD(v238) = 0;
          uint64_t v236 = 0;
          int32x2_t v237 = 0;
          LODWORD(v236) = v68[2].i32[0];
          BYTE4(v236) = v68[1].i8[5] & 1;
          int32x2_t v69 = v68[3];
          LODWORD(v238) = v68[4].i32[0];
          uint64_t v67 = *((void *)v9 + 2);
          *(void *)(v67 + 360) = &v236;
          v70.i32[0] = bswap32(v68[2].u32[1]);
          v70.i32[1] = (unsigned __int32)v70.i32[0] >> 8;
          int32x2_t v237 = vrev64_s32(v69);
          v70.i32[2] = HIWORD(v70.i32[0]);
          v71.i64[0] = 0xFF000000FFLL;
          v71.i64[1] = 0xFF000000FFLL;
          int32x4_t v72 = (int32x4_t)vandq_s8(v70, v71);
          v72.i32[3] = vshrq_n_u32((uint32x4_t)vdupq_n_s32(*(unsigned int *)&v70), 0x18uLL).i32[3];
          a6 = vcvtq_f32_f16(*(float16x4_t *)&v38);
          _Q0 = (__n128)vmulq_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_f32(vcvtq_f32_s32(v72), (float32x4_t)vdupq_n_s32(0x3B808081u)))), a6);
          *(float16x4_t *)&long long v38 = vcvt_f16_f32((float32x4_t)_Q0);
        }
        else
        {
          uint64_t v67 = *((void *)v9 + 2);
        }
        unsigned int v73 = *(unsigned __int8 *)(v67 + 480);
        if (v73 >= 2 && (v73 != 3 || (v65 & 1) == 0))
        {
          *(unsigned char *)(v67 + 481) |= 1u;
          uint64_t v67 = *((void *)v9 + 2);
          if (v63)
          {
            unsigned int v74 = *(unsigned __int8 *)(v67 + 480);
            if (v74 <= 3 && v74 != 2) {
              DWORD1(v300) |= 0x8000u;
            }
          }
        }
        *(void *)(v67 + 8) = v38;
        uint64_t v75 = *(void *)(a2 + 24);
        uint64_t v76 = *(void *)(v75 + 128);
        if (v76) {
          int v77 = *(unsigned char *)(v76 + 324) & 1;
        }
        else {
          int v77 = 0;
        }
        LODWORD(v252) = v65;
        if (!v254)
        {
          char v81 = (double *)v47;
          goto LABEL_106;
        }
        if (*(unsigned char *)(v47 + 12) != 51 || (*(unsigned char *)(v75 + 43) & 2) == 0 || v77)
        {
          char v81 = (double *)v47;
          goto LABEL_98;
        }
        if (*(CA::OGL::Context **)(v47 + 88) != v9 || (uint64_t v80 = *(void *)(v47 + 80)) == 0)
        {
          uint64_t v78 = v47;
          uint64_t v79 = CA::OGL::Context::lookup_image_(v9, (CA::Render::Texture *)v47, 1);
          uint64_t v47 = v78;
          uint64_t v80 = v79;
        }
        uint64_t v117 = v47;
        BOOL v118 = CA::OGL::detach_contents((uint64_t *)v255, a2, v47, v80, (uint64_t)v285, v263, (int)v251);
        int v119 = (*(uint64_t (**)(uint64_t))(*(void *)v117 + 280))(v117);
        if (v34
          && v119
          && *(unsigned char *)(v34 + 12) == 25
          && (uint64_t v120 = *(void *)(*(void *)(a2 + 24) + 144)) != 0
          && *(void *)(v120 + 24))
        {
          uint64_t v121 = *((void *)v9 + 27);
          int v91 = v252;
          if (v118)
          {
            ++*(_DWORD *)(v121 + 496);
LABEL_187:
            int v42 = 1;
            char v81 = (double *)v117;
            int32x4_t v18 = v256;
            goto LABEL_127;
          }
          char v81 = *(double **)(v117 + 160);
          if (!v81)
          {
            if (BYTE12(xmmword_1EB2ACC30))
            {
              uint64_t v231 = *((void *)v9 + 27);
              if (x_log_hook_p())
              {
                int v235 = *(_DWORD *)(v117 + 104);
                x_log_();
                uint64_t v121 = v231;
              }
              else
              {
                long long v232 = x_log_category_ogl;
                BOOL v233 = os_log_type_enabled((os_log_t)x_log_category_ogl, OS_LOG_TYPE_DEBUG);
                uint64_t v121 = v231;
                if (v233)
                {
                  int v234 = *(_DWORD *)(v117 + 104);
                  LODWORD(v271[0]) = 67109120;
                  DWORD1(v271[0]) = v234;
                  _os_log_impl(&dword_184668000, v232, OS_LOG_TYPE_DEBUG, "Cannot Display TM (did not detach), OnDemand MSR/GPU TM on surface (0x%x)", (uint8_t *)v271, 8u);
                  uint64_t v121 = v231;
                }
              }
            }
            memset(v271, 0, 144);
            long long v175 = *(atomic_uint **)(v117 + 168);
            if (v175)
            {
              atomic_fetch_add(v175 + 4, 1u);
              long long v176 = *(_OWORD *)(v117 + 176);
              *(_OWORD *)((char *)&v271[1] + 8) = *(_OWORD *)(v117 + 192);
              long long v177 = *(_OWORD *)(v117 + 224);
              *(_OWORD *)((char *)&v271[2] + 8) = *(_OWORD *)(v117 + 208);
              *(_OWORD *)((char *)v271 + 8) = v176;
              long long v178 = *(_OWORD *)(v117 + 256);
              *(_OWORD *)((char *)&v271[4] + 8) = *(_OWORD *)(v117 + 240);
              *(_OWORD *)((char *)&v271[3] + 8) = v177;
              long long v179 = *(_OWORD *)(v117 + 272);
              *(_OWORD *)((char *)&v271[7] + 8) = *(_OWORD *)(v117 + 288);
              *(_OWORD *)((char *)&v271[6] + 8) = v179;
              *(void *)&v271[0] = v175;
              int v250 = (double *)v271 + 1;
              BYTE8(v271[8]) = *(unsigned char *)(v117 + 304);
              *(_OWORD *)((char *)&v271[5] + 8) = v178;
              uint64_t v180 = v121;
              LODWORD(v248.f64[0]) = (*(uint64_t (**)(atomic_uint *, uint64_t))(*(void *)v175 + 56))(v175, v121);
              LODWORD(v249) = BYTE8(v271[8]);
              uint64_t v181 = (*(uint64_t (**)(uint64_t))(*(void *)v117 + 256))(v117);
              LOWORD(v235) = 1;
              float32x2_t v182 = (CA::Render::Surface *)(*(uint64_t (**)(atomic_uint *, uint64_t, uint64_t, double *, void, void, void, uint64_t, float, int))(*(void *)v175 + 24))(v175, v117, v180, v250, LODWORD(v248.f64[0]), 0, v249, v181, 1.0, v235);
              if (v182)
              {
                char v183 = (atomic_uint *)v182;
                CA::Render::Surface::set_tonemapped_surface((CA::Render::Surface *)v117, v182);
                unsigned int add = atomic_fetch_add(v183 + 2, 0xFFFFFFFF);
                uint64_t v12 = v253;
                if (add == 1) {
                  (*(void (**)(atomic_uint *))(*(void *)v183 + 16))(v183);
                }
                goto LABEL_299;
              }
              if (x_log_hook_p()) {
                goto LABEL_293;
              }
              uint64_t v197 = x_log_category_ogl;
              BOOL v198 = os_log_type_enabled((os_log_t)x_log_category_ogl, OS_LOG_TYPE_ERROR);
              uint64_t v12 = v253;
              if (v198)
              {
                int v199 = *(_DWORD *)(v117 + 104);
                *(_DWORD *)uint64_t v266 = 67109120;
                *(_DWORD *)&v266[4] = v199;
                unint64_t v194 = "Failed to tonemap surface 0x%x";
                float v195 = v197;
                uint32_t v196 = 8;
                goto LABEL_298;
              }
            }
            else
            {
              long long v188 = *(_OWORD *)(v117 + 240);
              *(_OWORD *)((char *)&v271[5] + 8) = *(_OWORD *)(v117 + 256);
              long long v189 = *(_OWORD *)(v117 + 288);
              *(_OWORD *)((char *)&v271[6] + 8) = *(_OWORD *)(v117 + 272);
              *(_OWORD *)((char *)&v271[7] + 8) = v189;
              long long v190 = *(_OWORD *)(v117 + 176);
              *(_OWORD *)((char *)&v271[1] + 8) = *(_OWORD *)(v117 + 192);
              long long v191 = *(_OWORD *)(v117 + 224);
              *(_OWORD *)((char *)&v271[2] + 8) = *(_OWORD *)(v117 + 208);
              *(_OWORD *)((char *)&v271[3] + 8) = v191;
              *(_OWORD *)((char *)&v271[4] + 8) = v188;
              BYTE8(v271[8]) = *(unsigned char *)(v117 + 304);
              *(_OWORD *)((char *)v271 + 8) = v190;
              if (x_log_hook_p())
              {
LABEL_293:
                x_log_();
                uint64_t v12 = v253;
                goto LABEL_299;
              }
              uint64_t v192 = x_log_category_ogl;
              BOOL v193 = os_log_type_enabled((os_log_t)x_log_category_ogl, OS_LOG_TYPE_ERROR);
              uint64_t v12 = v253;
              if (v193)
              {
                *(_WORD *)uint64_t v266 = 0;
                unint64_t v194 = "Could not tonemap surface because of invalid configuration";
                float v195 = v192;
                uint32_t v196 = 2;
LABEL_298:
                _os_log_impl(&dword_184668000, v195, OS_LOG_TYPE_ERROR, v194, v266, v196);
              }
            }
LABEL_299:
            uint64_t v200 = *(void *)&v271[0];
            if (*(void *)&v271[0]
              && atomic_fetch_add((atomic_uint *volatile)(*(void *)&v271[0] + 16), 0xFFFFFFFF) == 1)
            {
              (*(void (**)(uint64_t))(*(void *)v200 + 8))(v200);
            }
            char v81 = *(double **)(v117 + 160);
            if (!v81)
            {
              if (x_log_hook_p())
              {
                x_log_();
              }
              else
              {
                __int16 v201 = x_log_category_ogl;
                if (os_log_type_enabled((os_log_t)x_log_category_ogl, OS_LOG_TYPE_ERROR))
                {
                  int v202 = *(_DWORD *)(v117 + 104);
                  LODWORD(v271[0]) = 67109120;
                  DWORD1(v271[0]) = v202;
                  _os_log_impl(&dword_184668000, v201, OS_LOG_TYPE_ERROR, "No valid tonemapped surface available for 0x%x", (uint8_t *)v271, 8u);
                }
              }
              char v81 = (double *)v117;
              uint64_t v12 = v253;
            }
          }
        }
        else
        {
          int v91 = v252;
          if (v118) {
            goto LABEL_187;
          }
          char v81 = (double *)v117;
        }
LABEL_98:
        if ((WORD2(v300) & 0x400) != 0)
        {
          int32x4_t v18 = v256;
        }
        else
        {
          int32x4_t v18 = v256;
          if (*(void *)(*((void *)v9 + 2) + 8) == 0x3C003C003C003C00
            && !*(_WORD *)((char *)&v302 + 1)
            && ((BYTE4(v300) & 9) == 0 || (*(_WORD *)(a2 + 40) & 0x3C0) == 0))
          {
            unsigned int v82 = (CA::Render::TiledTexture *)(*(uint64_t (**)(double *, __n128))(*(void *)v81 + 200))(v81, _Q0);
            if (v82)
            {
              CA::OGL::draw_tiled_image((uint64_t)v9, v82, v263, (char)v251, (CA::OGL::ContentsGeometry *)v285, 0, v46);
LABEL_126:
              int v42 = 0;
              int v91 = v252;
LABEL_127:
              *(unsigned char *)(*((void *)v9 + 2) + 481) &= ~1u;
              DWORD1(v300) &= ~0x8000u;
              *(float *)&double v11 = CA::OGL::ContentsGeometry::fill_debug((uint64_t)v285, (uint64_t)v9, a2, v81, v91, _Q0.n128_f64[0], (int8x16_t)a6);
              BOOL v14 = 1;
              goto LABEL_128;
            }
            if ((*(unsigned int (**)(CA::OGL::Context *, double *))(*(void *)v9 + 568))(v9, v81))
            {
              LODWORD(v271[0]) = 0;
              *(_DWORD *)uint64_t v266 = 0;
              if ((*(uint64_t (**)(double *, _OWORD *, unsigned char *))(*(void *)v81 + 216))(v81, v271, v266))
              {
                uint64_t v171 = (*(uint64_t (**)(double *))(*(void *)v81 + 104))(v81);
                uint64_t v172 = (*(uint64_t (**)(CA::OGL::Context *, uint64_t, void, void))(*(void *)v9 + 200))(v9, v171, LODWORD(v271[0]), *(unsigned int *)v266);
                long long v173 = (CA::Render::TiledTexture *)(*(uint64_t (**)(double *, uint64_t, void))(*(void *)v81 + 208))(v81, v172, (DWORD1(v300) >> 11) & 1);
                if (v173)
                {
                  long long v174 = (atomic_uint *)v173;
                  CA::OGL::draw_tiled_image((uint64_t)v9, v173, v263, (char)v251, (CA::OGL::ContentsGeometry *)v285, 0, v46);
                  if (atomic_fetch_add(v174 + 2, 0xFFFFFFFF) == 1) {
                    (*(void (**)(atomic_uint *))(*(void *)v174 + 16))(v174);
                  }
                  goto LABEL_126;
                }
              }
            }
            DWORD1(v300) |= 0x1000u;
          }
        }
LABEL_106:
        uint64_t v83 = 0;
        if (BYTE2(v302) && !BYTE1(v302)) {
          uint64_t v83 = (*(uint64_t (**)(CA::OGL::Context *, double *, uint64_t, __n128))(*(void *)v9 + 608))(v9, v81, 1, _Q0);
        }
        if (v77) {
          BYTE4(v302) = 1;
        }
        if (v254)
        {
          uint64_t v84 = *(void *)(a2 + 24);
          if (v84)
          {
            uint64_t v84 = *(void *)(v84 + 120);
            if (v84)
            {
              int v85 = *(_DWORD *)(v84 + 24);
              v84 += 28;
              if (!v85) {
                uint64_t v84 = 0;
              }
            }
          }
          uint64_t v86 = (uint32x2_t **)CA::OGL::Context::bind_image((uint64_t)v9, 0, (uint32x2_t *)v81, (double *)DWORD1(v300), v263, (int)v251, v83, (CA::OGL::ContentsGeometry *)v285, v46, (float32x4_t *)((char *)&v298 + 4), v84);
          if (v86)
          {
            float64x2_t v87 = v86;
            if (v77)
            {
              int v88 = (*(uint64_t (**)(CA::OGL::Context *, uint64_t))(*(void *)v9 + 184))(v9, 28);
              uint64_t v89 = *((void *)v9 + 2);
              if (v88)
              {
                char v90 = CA::OGL::swizzle_to_image_function(CA::Render::LayerContentsSwizzle,CA::OGL::ImageFunction)::AAAA_functions[*(unsigned __int8 *)(v89 + 17)];
                if (!v90) {
                  char v90 = 33;
                }
              }
              else
              {
                char v90 = 21;
              }
              *(unsigned char *)(v89 + 17) = v90;
            }
            CA::OGL::ContentsGeometry::fill_and_unbind((uint64_t)v285, (uint64_t)v9, v87, (double *)v263, v46);
          }
        }
        else
        {
          *(void *)&v271[0] = (char *)v285 + 8;
          *((void *)&v271[0] + 1) = (char *)&v287 + 8;
          v271[1] = *(unint64_t *)((char *)&v300 + 4);
          *(void *)&v271[2] = 0;
          *((void *)&v271[2] + 1) = (char *)&v285[2] + 8;
          CA::OGL::fill_color_rect((uint64_t)v9, (uint64_t)v271, (double *)0xFF, v37, *(double *)((char *)&v300 + 4), (int8x16_t)a6);
        }
        goto LABEL_126;
      }
LABEL_75:
      int v64 = 0;
      int v65 = 0;
      DWORD1(v300) |= 0x100u;
      if (!v13) {
        goto LABEL_77;
      }
      goto LABEL_76;
    }
    if (BYTE10(v311))
    {
      int v63 = 1;
      goto LABEL_75;
    }
    if (!v13)
    {
      int v63 = 1;
      int v65 = 1;
      goto LABEL_77;
    }
    long long v252 = v38;
    uint64_t v164 = v47;
    *(void *)uint64_t v266 = 0;
    *(void *)&v266[8] = 0;
    CA::Bounds::set_exterior((int32x4_t *)v266, v36, *(float64x2_t *)((char *)&v285[2] + 8), *(float64x2_t *)((char *)&v285[3] + 8));
    int v165 = (CA::Shape *)*((void *)v256 + 1);
    uint64_t v35 = CA::Bounds::contains((CA::Bounds *)v266, (uint64_t)v165);
    if (v35)
    {
LABEL_289:
      int v63 = 1;
      int v65 = 1;
      uint64_t v47 = v164;
      int32x4_t v18 = v256;
      *(void *)&long long v38 = v252;
      goto LABEL_77;
    }
    unint64_t v166 = CA::Shape::subtract(v165, (const CA::Bounds *)v266);
    long long v170 = (CA::Shape *)v166;
    if (v166)
    {
      if (v166 != 1) {
        goto LABEL_285;
      }
    }
    else if (*(_DWORD *)(v166 + 4) == 12)
    {
      goto LABEL_285;
    }
    if ((*((unsigned char *)v9 + 432) & 0x10) != 0)
    {
      CA::OGL::render_background(v255, a2, v167, v168, v169);
      goto LABEL_288;
    }
LABEL_285:
    memset(v271, 0, 72);
    CA::OGL::copy_gstate((uint64_t)v271, (uint64_t)v256);
    *((void *)&v271[0] + 1) = v170;
    *(void *)&v271[0] = CA::OGL::Context::set_gstate((uint64_t)v9, (uint64_t)v271);
    CA::OGL::render_background(v255, a2, v185, v186, v187);
    CA::OGL::Context::set_gstate((uint64_t)v9, **((void **)v9 + 31));
LABEL_288:
    CA::Shape::unref(v170);
    goto LABEL_289;
  }
  int v42 = 0;
  uint64_t v12 = v253;
  int32x4_t v18 = v256;
LABEL_128:
  if (v34 && *(unsigned char *)(v34 + 12) == 25)
  {
    uint64_t v92 = *(void *)(*(void *)(v34 + 16) + 24);
    unint64_t v93 = atomic_load((unint64_t *)(v92 + 8));
    if ((v93 & 0x800000000000000) != 0) {
      int v94 = 0;
    }
    else {
      int v94 = v42;
    }
    if (v94 == 1)
    {
      atomic_fetch_or((atomic_ullong *volatile)(v92 + 8), 0x800000000000000uLL);
    }
    else
    {
      if ((v93 & 0x800000000000000) != 0) {
        char v95 = v42;
      }
      else {
        char v95 = 1;
      }
      if ((v95 & 1) == 0) {
        atomic_fetch_and((atomic_ullong *volatile)(v92 + 8), 0xF7FFFFFFFFFFFFFFLL);
      }
    }
    if (v42) {
      CA::Render::ImageQueue::tag_detached_samples(*(void *)(*(void *)(v34 + 16) + 24), *(_DWORD *)(v34 + 180));
    }
    if (!*((_DWORD *)v255[1] + 66)) {
      *(_DWORD *)(*(void *)(*(void *)(v34 + 16) + 24) + 68) = *(_DWORD *)(*(void *)(*(void *)(v34 + 16)
    }
                                                                                            + 24)
                                                                                + 64);
  }
  *(void *)(*((void *)v9 + 2) + 360) = 0;
  double v8 = v255;
  if (!v14) {
LABEL_28:
  }
    CA::OGL::render_background(v8, a2, v11, a6, a7);
LABEL_29:
  if (v18 != (_OWORD *)v10)
  {
    CA::OGL::Context::set_gstate((uint64_t)v9, **((void **)v9 + 31));
    CA::Shape::unref(*((CA::Shape **)v18 + 1));
  }
  *(void *)(v10 + 8) = v12;
}

uint64_t CA::Render::Texture::protection_options(CA::Render::Texture *this)
{
  return 0;
}

uint64_t CA::OGL::MetalContext::bind_image_impl(CA::OGL::Context *this, int a2, CA::Render::Texture *a3, __int16 a4, int a5, char a6, int a7, uint64_t a8, float a9, uint64_t a10)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  if (*((CA::OGL::Context **)a3 + 11) != this || (uint64_t v19 = *((void *)a3 + 10)) == 0)
  {
    uint64_t v19 = CA::OGL::Context::lookup_image_(this, a3, 1);
    if (!v19) {
      return v19;
    }
  }
  if (*((unsigned char *)a3 + 12) == 23 && !*(_WORD *)(v19 + 52)) {
    *(_WORD *)(v19 + 123) |= 2u;
  }
  double v20 = CA::OGL::MetalContext::retain_image((uint64_t)this, v19, a3, 0);
  if (!v20) {
    return 0;
  }
  unint64_t v22 = v20;
  if (*(void *)(v19 + 64))
  {
    if (*(unsigned char *)(v19 + 122))
    {
      uint64_t v23 = *(void *)(v19 + 8);
      if (v23)
      {
        if (*(_DWORD *)(v19 + 16) != *(_DWORD *)(v23 + 36))
        {
          *(_DWORD *)(v19 + 52) = *(_DWORD *)(v19 + 52) & 0xFFF0FFFF | ((a5 & 0xF) << 16);
          int v24 = *(unsigned __int8 *)(v23 + 12);
          if (v24 == 51)
          {
            CA::OGL::MetalContext::update_surface((uint64_t)this, v19, (unsigned int *)v23, a2, a10);
          }
          else if (v24 == 23)
          {
            CA::OGL::MetalContext::update_image((uint64_t)this, v19, v23, a2, a10);
          }
        }
      }
    }
    goto LABEL_32;
  }
  unint64_t v25 = *((void *)this + 338);
  if (v25 < *((unsigned int *)v20 + 4) || v25 < *((unsigned int *)v20 + 5))
  {
    if (x_log_hook_p())
    {
LABEL_19:
      x_log_();
      return 0;
    }
    uint64_t v26 = x_log_category_ogl_metal;
    if (!os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_DEFAULT)) {
      return 0;
    }
    int v27 = *((_DWORD *)v22 + 4);
    int v28 = *((_DWORD *)v22 + 5);
    *(_DWORD *)buf = 67109376;
    int v40 = v27;
    __int16 v41 = 1024;
    int v42 = v28;
    uint64_t v29 = "%d by %d image is too large for GPU, ignoring\n";
    uint64_t v30 = v26;
    uint32_t v31 = 14;
LABEL_22:
    _os_log_impl(&dword_184668000, v30, OS_LOG_TYPE_DEFAULT, v29, buf, v31);
    return 0;
  }
  if (*((unsigned char *)v20 + 12) == 23)
  {
    unint64_t v32 = *((void *)this + 339);
    if (v32)
    {
      if (*((void *)v20 + 20) > v32)
      {
        if (x_log_hook_p()) {
          goto LABEL_19;
        }
        uint64_t v37 = x_log_category_ogl_metal;
        if (!os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_DEFAULT)) {
          return 0;
        }
        *(_WORD *)buf = 0;
        uint64_t v29 = "Image stride is too large for GPU, ignoring\n";
        uint64_t v30 = v37;
        uint32_t v31 = 2;
        goto LABEL_22;
      }
    }
  }
  if (a5 == 2) {
    *(_DWORD *)(v19 + 52) = *(_DWORD *)(v19 + 52) & 0xFFF0FFFF | 0x20000;
  }
  CA::OGL::MetalContext::update_texture((uint64_t)this, v19, (uint64_t)v20, a2, a10, v21);
LABEL_32:
  uint64_t v33 = *(unsigned __int8 *)(v19 + 122);
  if (!*(unsigned char *)(v19 + 122)) {
    return 0;
  }
  uint64_t v34 = 0;
  uint64_t v35 = *((void *)this + 2);
  do
  {
    if (v34 == 3) {
      __assert_rtn("create_image_binding", "ogl-metal.mm", 4004, "plane < OGL_MAX_PLANES_PER_IMAGE");
    }
    unsigned int v36 = a2 + v34;
    *(_WORD *)(v35 + 2 * v36 + 144) = *(_DWORD *)(v19 + 52);
    *(void *)(v35 + 8 * v36 + 176) = v34++ | v19;
  }
  while (v33 != v34);
  if (a5 == 2)
  {
    if (*(_WORD *)(v19 + 123)) {
      LOBYTE(a5) = 2;
    }
    else {
      LOBYTE(a5) = 1;
    }
  }
  *(_DWORD *)(v19 + 52) = *(_DWORD *)(v19 + 52) & 0xFF00FFFF | ((a5 & 0xF) << 16) & 0xFF0FFFFF | ((a6 & 0xF) << 20);
  *(float *)(v19 + 48) = a9;
  if (a7 == 1) {
    a7 = (*(unsigned __int8 *)(v19 + 123) >> 1) & 1;
  }
  *(_WORD *)(v19 + 58) = *(_WORD *)(v19 + 58) & 0xFFE7 | (8 * (a7 & 3));
  *(_OWORD *)a8 = xmmword_184998030;
  if (((a4 & 0x800) == 0) != (*((unsigned char *)v22 + 13) & 8) >> 3)
  {
    *(_DWORD *)(a8 + 4) = 1065353216;
    *(_DWORD *)(a8 + 12) = 0;
  }
  return v19;
}

float CA::OGL::ContentsGeometry::fill_debug(uint64_t a1, uint64_t a2, uint64_t a3, double *a4, int a5, double a6, int8x16_t a7)
{
  uint64_t v68 = *MEMORY[0x1E4F143B8];
  if (options_are_visual != 1) {
    return *(float *)&a6;
  }
  double v9 = (double *)(a1 + 308);
  int v10 = *(_DWORD *)(a1 + 308);
  if ((v10 & 0x36) == 0
    || ((int v11 = BYTE1(xmmword_1EB2ACC30), !(_BYTE)xmmword_1EB2ACC30) ? (_ZF = BYTE1(xmmword_1EB2ACC30) == 0) : (_ZF = 0),
        _ZF))
  {
    if (*(unsigned char *)(a1 + 494)) {
      BOOL v13 = BYTE2(xmmword_1EB2ACC30) == 0;
    }
    else {
      BOOL v13 = 1;
    }
    if (!v13 || (v10 & 9) != 0 && BYTE14(ca_debug_options))
    {
      uint64_t v62 = a1 + 8;
      uint64_t v63 = a1 + 104;
      double v38 = *v9;
      double v64 = *v9;
      uint64_t v65 = 0;
      uint64_t v66 = 0;
      uint64_t v67 = a1 + 40;
      uint64_t v39 = a2;
      uint64_t v37 = 2155872384;
    }
    else
    {
      if (byte_1EB2ACBE8 && *(unsigned char *)(a1 + 495))
      {
        uint64_t v62 = a1 + 8;
        uint64_t v63 = a1 + 104;
        double v38 = *v9;
        double v64 = *v9;
        uint64_t v65 = 0;
        uint64_t v66 = 0;
        uint64_t v67 = a1 + 40;
        uint64_t v39 = a2;
        uint64_t v37 = 4294901888;
        goto LABEL_95;
      }
      if (byte_1EB2ACBE9 && *(unsigned char *)(a1 + 496))
      {
        uint64_t v62 = a1 + 8;
        uint64_t v63 = a1 + 104;
        double v38 = *v9;
        double v64 = *v9;
        uint64_t v65 = 0;
        uint64_t v66 = 0;
        uint64_t v67 = a1 + 40;
        uint64_t v39 = a2;
        uint64_t v37 = 16777088;
        goto LABEL_95;
      }
      if (BYTE1(ca_debug_options) && a4 && (*((_DWORD *)a4 + 3) & 0x8000FF) == 0x800017)
      {
        uint64_t v62 = a1 + 8;
        uint64_t v63 = a1 + 104;
        double v38 = *v9;
        double v64 = *v9;
        uint64_t v65 = 0;
        uint64_t v66 = 0;
        uint64_t v67 = a1 + 40;
        uint64_t v39 = a2;
        uint64_t v37 = 8421504;
        goto LABEL_95;
      }
      if (BYTE2(ca_debug_options))
      {
        uint64_t v62 = a1 + 8;
        uint64_t v63 = a1 + 104;
        double v38 = *v9;
        if (a5) {
          uint64_t v37 = 8388736;
        }
        else {
          uint64_t v37 = 2147483776;
        }
        goto LABEL_94;
      }
      if (byte_1EB2ACBE2)
      {
        if (a3)
        {
          if (a4)
          {
            uint64_t v40 = *(void *)(a3 + 24);
            if (v40)
            {
              if ((*(unsigned char *)(v40 + 43) & 2) != 0)
              {
                uint64_t v41 = *(void *)(v40 + 144);
                if (v41)
                {
                  if ((*(unsigned char *)(v41 + 97) & 0x80) == 0)
                  {
LABEL_77:
                    uint64_t v62 = a1 + 8;
                    uint64_t v63 = a1 + 104;
                    double v38 = *v9;
                    double v64 = *v9;
                    uint64_t v65 = 0;
                    uint64_t v66 = 0;
                    uint64_t v67 = a1 + 40;
                    uint64_t v39 = a2;
                    uint64_t v37 = 2147483776;
                    goto LABEL_95;
                  }
                }
              }
            }
          }
        }
      }
      if (byte_1EB2ACBE4)
      {
        if (a4)
        {
          unsigned int v43 = (*(uint64_t (**)(double *))(*(void *)a4 + 104))(a4);
          if (*((unsigned char *)a4 + 12) == 9) {
            goto LABEL_85;
          }
          if (v43 > 0x1C || ((0x17826000u >> v43) & 1) == 0)
          {
            uint64_t v37 = 2155872384;
            if (v43 - 33 >= 3)
            {
              if (v43 <= 0x10 && ((0x1980Fu >> v43) & 1) != 0)
              {
                uint64_t v37 = 2151678080;
              }
              else if ((v43 & 0xFFFFFFFE) == 0x12)
              {
                uint64_t v37 = 2151710848;
              }
              else
              {
                if (v43 > 0x1A || ((0x6000700u >> v43) & 1) == 0) {
                  return *(float *)&a6;
                }
                uint64_t v37 = 1077952640;
              }
            }
LABEL_92:
            uint64_t v62 = a1 + 8;
            uint64_t v63 = a1 + 104;
LABEL_93:
            double v38 = *v9;
LABEL_94:
            double v64 = v38;
            uint64_t v65 = 0;
            uint64_t v66 = 0;
            uint64_t v67 = a1 + 40;
            uint64_t v39 = a2;
            goto LABEL_95;
          }
LABEL_66:
          uint64_t v37 = 32896;
          goto LABEL_92;
        }
      }
      else if (byte_1EB2ACBE5 && a4)
      {
        int v44 = (CGColorSpace *)*((void *)a4 + 6);
        if (!v44) {
          return *(float *)&a6;
        }
        s = (CGColorSpace *)*((void *)a4 + 6);
        if (CGColorSpaceIsHLGBased(v44))
        {
          uint64_t v37 = 2155872384;
          goto LABEL_92;
        }
        if (CGColorSpaceContainsFlexGTCInfo())
        {
LABEL_85:
          uint64_t v37 = 8388736;
          goto LABEL_92;
        }
        if (CGColorSpaceIsPQBased(s))
        {
LABEL_91:
          uint64_t v37 = 2147516544;
          goto LABEL_92;
        }
        if (!CGColorSpaceUsesExtendedRange(s)) {
          return *(float *)&a6;
        }
        LODWORD(a6) = *((_DWORD *)a4 + 14);
        a7.i32[0] = 1.0;
        if (*(float *)&a6 <= 1.0) {
          return *(float *)&a6;
        }
        goto LABEL_66;
      }
      if (!BYTE3(xmmword_1EB2ACBF0))
      {
        if (byte_1EB2ACC24 && a4)
        {
          if (!(*(unsigned int (**)(double *))(*(void *)a4 + 128))(a4)) {
            return *(float *)&a6;
          }
          goto LABEL_77;
        }
LABEL_24:
        if (!byte_1EB2ACC4D) {
          return *(float *)&a6;
        }
        if (!a3) {
          return *(float *)&a6;
        }
        uint64_t v45 = *(void *)(a3 + 24);
        if (!v45) {
          return *(float *)&a6;
        }
        uint64_t v46 = *(void *)(v45 + 144);
        if (!v46) {
          return *(float *)&a6;
        }
        unint64_t v47 = *(void *)(v46 + 96);
        if ((v47 & 0xE0000000000000) == 0) {
          return *(float *)&a6;
        }
        if ((v47 & 0xE0000000000000) >> 53 <= 4)
        {
          uint64_t v37 = CA::OGL::fill_color_rect(CA::OGL::Context &,CA::Rect const&,unsigned int,BOOL,BOOL,CA::Render::VelocityBucket)::velocity_colors[((v47 >> 53) & 7) - 1];
          goto LABEL_92;
        }
        goto LABEL_91;
      }
      if (!a4) {
        goto LABEL_24;
      }
      if ((*((_DWORD *)a4 + 3) & 0x100000) == 0 || *((_DWORD *)a4 + 3) == 51) {
        return *(float *)&a6;
      }
      uint64_t v62 = a1 + 8;
      uint64_t v63 = a1 + 104;
      double v38 = *v9;
      double v64 = *v9;
      uint64_t v65 = 0;
      uint64_t v66 = 0;
      uint64_t v67 = a1 + 40;
      uint64_t v39 = a2;
      uint64_t v37 = 2150914688;
    }
LABEL_95:
    CA::OGL::fill_color_rect(v39, (uint64_t)&v62, (double *)v37, a4, v38, a7);
    return *(float *)&a6;
  }
  uint64_t v14 = a1 + 104;
  double v15 = *(double *)(a1 + 264);
  double v16 = v15 / *(double *)(a1 + 256);
  double v17 = 1.0 / *(double *)(a1 + 224);
  double v18 = sqrt(*(double *)(a1 + 104) * *(double *)(a1 + 104) + *(double *)(a1 + 112) * *(double *)(a1 + 112)) * v17;
  double v19 = sqrt(*(double *)(a1 + 136) * *(double *)(a1 + 136) + *(double *)(a1 + 144) * *(double *)(a1 + 144)) * v17;
  double v20 = v16 / v18;
  if (v16 / v18 <= v15 / v19) {
    double v20 = v15 / v19;
  }
  double v21 = v18 / v16;
  double v22 = v19 / v15;
  if (v21 <= v22) {
    double v21 = v22;
  }
  float v23 = v21;
  int v24 = &off_184996000;
  if ((_BYTE)xmmword_1EB2ACC30)
  {
    float v25 = v20;
    double v26 = v25;
    if (v26 > 1.001)
    {
      double v48 = v26 * 0.333333333 + -0.333333333;
      BOOL v49 = v48 > 1.0 || v48 < 0.0;
      double v50 = 0.0;
      if (v48 >= 0.0 || v48 > 1.0) {
        double v50 = 0.699999988;
      }
      double v51 = v48 * 0.699999988;
      if (v49) {
        double v51 = v50;
      }
      _D1 = 0.699999988 - v51;
      LOWORD(v60) = 14746;
      __asm { FCVT            H1, D1 }
      HIWORD(v60) = LOWORD(_D1);
      int v61 = 966393856;
      float v58 = v23;
      unsigned int v53 = CA::OGL::ExtendedColor::word32((CA::OGL::ExtendedColor *)&v60);
      uint64_t v62 = a1 + 8;
      uint64_t v63 = a1 + 104;
      double v64 = *v9;
      uint64_t v65 = 0;
      uint64_t v66 = 0;
      uint64_t v67 = a1 + 40;
      CA::OGL::fill_color_rect(a2, (uint64_t)&v62, (double *)bswap32(v53), v54, v64, v55);
      int v24 = &off_184996000;
      float v23 = v58;
      uint64_t v14 = a1 + 104;
      int v11 = BYTE1(xmmword_1EB2ACC30);
    }
  }
  a6 = v23;
  if (a6 > *((double *)v24 + 490) && v11 != 0)
  {
    double v28 = a6 * 0.333333333 + -0.333333333;
    BOOL v29 = v28 > 1.0 || v28 < 0.0;
    float v30 = 0.7;
    if (v28 < 0.0 && v28 <= 1.0) {
      float v30 = 0.2;
    }
    _S0 = v28 * 0.5 + 0.200000003;
    if (v29) {
      _S0 = v30;
    }
    int v60 = 0;
    __asm { FCVT            H0, S0 }
    LOWORD(v61) = _H0;
    HIWORD(v61) = _H0;
    uint64_t v36 = v14;
    uint64_t v37 = bswap32(CA::OGL::ExtendedColor::word32((CA::OGL::ExtendedColor *)&v60));
    uint64_t v62 = a1 + 8;
    uint64_t v63 = v36;
    goto LABEL_93;
  }
  return *(float *)&a6;
}

uint64_t CA::OGL::MetalContext::enforces_protection(CA::OGL::MetalContext *this)
{
  return 1;
}

void CA::OGL::ContentsGeometry::fill_and_unbind(uint64_t a1, uint64_t a2, uint32x2_t **a3, double *a4, float a5)
{
  int v6 = (int)a4;
  uint64_t v110 = *MEMORY[0x1E4F143B8];
  int v10 = (double *)(a1 + 308);
  if (*(unsigned char *)(a1 + 491))
  {
    float32x4_t v11 = *(float32x4_t *)(a1 + 392);
    if ((*((_WORD *)a3 + 29) & 0x100) == 0 && *a3)
    {
      *(float32x2_t *)v64.f32 = vcvt_f32_u32((*a3)[2]);
      v64.i64[1] = v64.i64[0];
      float32x4_t v11 = vmulq_f32(v11, v64);
    }
    *(unsigned char *)(*(void *)(a2 + 16) + 19) = 5;
    *(float32x4_t *)(*(void *)(a2 + 16) + 368) = v11;
  }
  if (*(unsigned char *)(a1 + 494))
  {
    uint64_t v12 = *(float32x2_t **)(a2 + 16);
    float32x2_t v13 = v12[12];
    v12[13] = vmla_f32(v12[13], *(float32x2_t *)(a1 + 416), v13);
    v12[12] = vmul_f32(*(float32x2_t *)(a1 + 408), v13);
  }
  if (*(unsigned char *)(a1 + 337)
    || *(unsigned char *)(a1 + 338)
    || (*(unsigned char *)v10 & 0x12) == 0
    || (*((_WORD *)a3 + 27) & 0xF) == a4)
  {
    CA::OGL::ContentsGeometry::fill_and_unbind(a1, (int32x2_t *)a2, (uint64_t)a3, a4);
  }
  else
  {
    double v79 = 0.0;
    double v80 = 0.0;
    if ((*(unsigned char *)(a1 + 248) & 0x10) != 0)
    {
      CA::Mat4Impl::mat4_get_scale((CA::Mat4Impl *)(a1 + 104), &v80, &v79, a4);
      double v14 = v79;
      double v15 = v80;
    }
    else
    {
      double v14 = *(double *)(a1 + 232);
      double v15 = v14;
    }
    if (v15 < 0.0) {
      double v15 = -v15;
    }
    if (v15 > 1.0) {
      double v15 = 1.0;
    }
    if (v14 < 0.0) {
      double v14 = -v14;
    }
    if (v14 > 1.0) {
      double v14 = 1.0;
    }
    double v79 = v14;
    double v80 = v15;
    if (v15 <= v14) {
      double v16 = v15;
    }
    else {
      double v16 = v14;
    }
    if (v15 > v14) {
      double v14 = v15;
    }
    BOOL v18 = v16 < 0.75 || v6 == 10;
    if (v14 >= 0.999 || !v18) {
      goto LABEL_78;
    }
    long long v78 = 0uLL;
    CA::Shape::get_bounds(*(void *)(*(void *)(a2 + 248) + 8), (int *)&v78);
    double v22 = *(int32x2_t **)(a2 + 264);
    if (v22) {
      float v23 = v22 + 4;
    }
    else {
      float v23 = (int32x2_t *)(a2 + 200);
    }
    uint32x2_t v24 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)((char *)&v78 + 8));
    if ((vpmax_u32(v24, v24).u32[0] & 0x80000000) != 0) {
      goto LABEL_79;
    }
    int32x2_t v25 = v23[1];
    uint32x2_t v26 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v25);
    if ((vpmax_u32(v26, v26).u32[0] & 0x80000000) != 0) {
      goto LABEL_79;
    }
    *(int32x2_t *)&long long v27 = vmax_s32(*(int32x2_t *)&v78, *v23);
    *(int32x2_t *)v20.i8 = vsub_s32(vmin_s32(vadd_s32(*(int32x2_t *)&v78, *(int32x2_t *)((char *)&v78 + 8)), vadd_s32(*v23, v25)), *(int32x2_t *)&v27);
    uint32x2_t v28 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)v20.i8);
    *(uint32x2_t *)v21.i8 = vpmax_u32(v28, v28);
    if (v21.i32[0] < 0) {
      goto LABEL_79;
    }
    *((void *)&v27 + 1) = v20.i64[0];
    long long v78 = v27;
    int v29 = v20.i32[0];
    if (v20.i32[0] <= v20.i32[1]) {
      int v30 = v20.i32[1];
    }
    else {
      int v30 = v20.i32[0];
    }
    v20.i32[0] = v30;
    v21.i32[0] = 1073741822;
    v31.i64[0] = (int)v27;
    v31.i64[1] = SDWORD1(v27);
    float64x2_t v32 = (float64x2_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v20, v21), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v31));
    double v33 = (double)v20.i32[1];
    if (v30 <= 1073741822) {
      double v34 = (double)v29;
    }
    else {
      double v34 = 1.79769313e308;
    }
    if (v30 > 1073741822) {
      double v33 = 1.79769313e308;
    }
    float64x2_t v76 = v32;
    v77.f64[0] = v34;
    v77.f64[1] = v33;
    if (fmax(v34, v33) < 1.79769313e308)
    {
      double v35 = v34 >= v33 ? v33 : v34;
      if (v35 > 0.0)
      {
        __asm { FMOV            V3.2D, #-2.0 }
        float64x2_t v76 = vaddq_f64(v32, _Q3);
        double v40 = v33 + 4.0;
        v77.f64[0] = v34 + 4.0;
        v77.f64[1] = v40;
        if (v34 + 4.0 <= 0.0 || v40 <= 0.0) {
          float64x2_t v77 = 0uLL;
        }
      }
    }
    CA::Rect::unapply_transform((CA::Rect *)&v76, (const CA::Transform *)(a1 + 104), v19);
    if ((CA::BoundsImpl::intersect((uint64_t)&v76, *(float64x2_t *)(a1 + 8), *(float64x2_t *)(a1 + 24)) & 1) == 0)
    {
LABEL_79:
      (*(void (**)(uint64_t, uint32x2_t **, void))(*(void *)a2 + 520))(a2, a3, 0);
      return;
    }
    int32x4_t v75 = 0uLL;
    float64x2_t v65 = v77;
    float64x2_t v66 = v76;
    CA::Bounds::set_exterior(&v75, v41, v76, v77);
    __int32 v42 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 184))(a2, 7);
    if (v75.i32[2] > v42 || v75.i32[3] > v42)
    {
LABEL_78:
      CA::OGL::ContentsGeometry::fill_and_unbind(a1, (int32x2_t *)a2, (uint64_t)a3, a4);
      return;
    }
    int32x4_t v74 = 0uLL;
    if (v80 != 1.0 && v65.f64[0] < 1.79769313e308)
    {
      v76.f64[0] = v66.f64[0] * v80;
      v77.f64[0] = v65.f64[0] * v80;
    }
    if (v79 != 1.0 && v65.f64[1] < 1.79769313e308)
    {
      v76.f64[1] = v66.f64[1] * v79;
      v77.f64[1] = v65.f64[1] * v79;
    }
    CA::Bounds::set_exterior(&v74, v43, v76, v77);
    memset(__dst, 0, 488);
    int v44 = *(const void **)(a2 + 16);
    memcpy(__dst, v44, 0x1E8uLL);
    *(void *)&__dst[0] = v44;
    *(void *)(a2 + 16) = __dst;
    if (*(unsigned char *)(a1 + 492)) {
      uint64_t v45 = 4111;
    }
    else {
      uint64_t v45 = 15;
    }
    uint64_t v46 = (*(uint64_t (**)(uint64_t, uint64_t, int32x4_t *, uint64_t))(*(void *)a2 + 656))(a2, 1, &v75, v45);
    if (v46)
    {
      uint64_t v67 = v46;
      if (*(_DWORD *)(a1 + 312) && (*(unsigned char *)v10 & 9) != 0
        || (uint64_t v48 = *(void *)(a2 + 16), *(void *)(v48 + 8) != 0x3C003C003C003C00))
      {
        uint64_t v49 = (*(uint64_t (**)(uint64_t, uint64_t, int32x4_t *, uint64_t))(*(void *)a2 + 656))(a2, 1, &v74, v45);
        uint64_t v48 = *(void *)(a2 + 16);
      }
      else
      {
        uint64_t v49 = 0;
      }
      uint64_t v50 = *(void *)&__dst[0];
      memcpy(__dst, *(const void **)&__dst[0], 0x1E8uLL);
      *(void *)&__dst[0] = v50;
      *(void *)(v48 + 8) = 0x3C003C003C003C00;
      *(unsigned char *)(*(void *)(a2 + 16) + 481) &= ~1u;
      uint64_t v104 = 0x3C003C003C003C00;
      uint64_t v106 = 0;
      uint64_t v105 = 0;
      uint64_t v107 = 0;
      uint64_t v100 = 0;
      int64x2_t v101 = 0;
      uint64_t v108 = 1065353216;
      uint64_t v102 = 0;
      unint64_t v103 = (double *)&CA::identity_transform;
      memset(v99, 0, sizeof(v99));
      CA::Shape::operator=((uint64_t)v99, &v75);
      int64x2_t v101 = v99;
      WORD2(v108) = 1;
      uint64_t v100 = CA::OGL::Context::set_gstate(a2, (uint64_t)&v100);
      CA::OGL::Context::push_surface(a2, v67, 1u, 1024, 0);
      unsigned int v51 = *(unsigned __int8 *)(a1 + 336);
      if ((*(unsigned int (**)(uint64_t))(*(void *)a2 + 1032))(a2) < v51)
      {
        *(unsigned char *)(*(void *)(a2 + 16) + 481) |= 2u;
        *(_DWORD *)(*(void *)(a2 + 16) + 352) = 1065353216;
      }
      v68[0] = (double *)(a1 + 8);
      v68[1] = v103;
      int v69 = 256;
      uint64_t v70 = 0;
      uint64_t v72 = 0;
      uint64_t v71 = 0;
      int v73 = 0;
      int v52 = (double *)(a1 + 276);
      if (v49) {
        CA::OGL::fill_rect_tex((CA::OGL::Context *)a2, (uint64_t)v68, a1 + 276, v52);
      }
      else {
        CA::OGL::ContentsGeometry::fill_geometry(a1, (CA::OGL::Context *)a2, v68, (float32x2_t *)v52);
      }
      *(unsigned char *)(*(void *)(a2 + 16) + 481) &= ~2u;
      CA::OGL::Context::pop_surface((CA::OGL::Context *)a2);
      CA::OGL::Context::set_gstate(a2, **(void **)(a2 + 248));
      *(void *)(a2 + 16) = *(void *)&__dst[0];
      *(void *)&__dst[0] = 0;
      (*(void (**)(uint64_t, uint32x2_t **, void))(*(void *)a2 + 520))(a2, a3, 0);
      memset(v98, 0, sizeof(v98));
      uint64_t v96 = 0;
      long long v94 = 0u;
      long long v95 = 0u;
      long long v92 = 0u;
      long long v93 = 0u;
      long long v90 = 0u;
      long long v91 = 0u;
      long long v88 = 0u;
      long long v89 = 0u;
      unsigned int v53 = (long long *)(a1 + 104);
      long long v87 = 0u;
      if (v49)
      {
        uint64_t v54 = *(const void **)(a2 + 16);
        memcpy(__dst, v54, 0x1E8uLL);
        *(void *)&__dst[0] = v54;
        *(void *)(a2 + 16) = __dst;
        *((void *)&__dst[0] + 1) = 0x3C003C003C003C00;
        BYTE1(__dst[30]) &= ~1u;
        CA::Shape::operator=((uint64_t)v98, &v74);
        int64x2_t v101 = v98;
        long long v88 = 0u;
        long long v89 = xmmword_184997D60;
        long long v90 = 0u;
        long long v91 = 0u;
        long long v92 = xmmword_184997D50;
        long long v93 = 0u;
        long long v94 = xmmword_184997D60;
        long long v87 = *(unint64_t *)&v80;
        if (v80 == v79)
        {
          *((double *)&v89 + 1) = v80;
          *(void *)&long long v92 = 0x3FF0000000000000;
          *(double *)&long long v95 = v80;
          *((double *)&v95 + 1) = 1.0 / v80;
          char v55 = 8 * (v80 != 1.0);
        }
        else
        {
          *((double *)&v89 + 1) = v79;
          *(void *)&long long v92 = 0x3FF0000000000000;
          __asm { FMOV            V0.2D, #1.0 }
          long long v95 = _Q0;
          char v55 = 16;
        }
        LOBYTE(v96) = v55;
        uint64_t v100 = CA::OGL::Context::set_gstate(a2, (uint64_t)&v100);
        CA::OGL::Context::push_surface(a2, v49, 1u, 1024, 0);
        unsigned int v53 = &v87;
      }
      uint64_t v57 = 0;
      if (v6 != 2 && v6 != 7)
      {
        if (v6 == 11)
        {
          uint64_t v57 = 1;
        }
        else if (v6 == 10)
        {
          uint64_t v57 = 2;
        }
        else
        {
          uint64_t v57 = 1;
        }
      }
      char v81 = *(double **)&v80;
      double v82 = v79;
      (*(void (**)(uint64_t, uint64_t, double **, long long *, uint64_t, float))(*(void *)a2 + 864))(a2, v67, &v81, v53, v57, a5);
      if (v49)
      {
        CA::OGL::Context::pop_surface((CA::OGL::Context *)a2);
        CA::OGL::Context::set_gstate(a2, **(void **)(a2 + 248));
        *(void *)(a2 + 16) = *(void *)&__dst[0];
        v60.f64[0] = v80;
        v60.f64[1] = v79;
        v61.i64[0] = v74.i32[0];
        v61.i64[1] = v74.i32[1];
        float32x2_t v62 = vcvt_f32_f64(vmlaq_f64(vnegq_f64(vcvtq_f64_s64(v61)), *(float64x2_t *)(a1 + 8), v60));
        float64x2_t v63 = vmlaq_f64(vcvtq_f64_f32(v62), v60, *(float64x2_t *)(a1 + 24));
        *(void *)&__dst[0] = 0;
        v97[0] = v62;
        v97[1] = vcvt_f32_f64(v63);
        char v81 = (double *)(a1 + 8);
        *(void *)&double v82 = a1 + 104;
        double v83 = *v10;
        uint64_t v84 = 0;
        uint64_t v85 = 0;
        uint64_t v86 = a1 + 40;
        CA::OGL::Context::bind_surface(a2, v49, 0, 1u, 1, 0.0);
        CA::OGL::ContentsGeometry::fill_geometry(a1, (CA::OGL::Context *)a2, &v81, v97);
        CA::OGL::Context::unbind_surface((void *)a2, v49, 0);
      }
      if (byte_1EB2ACBE1)
      {
        char v81 = (double *)(a1 + 8);
        *(void *)&double v82 = a1 + 104;
        double v83 = *v10;
        uint64_t v84 = 0;
        uint64_t v85 = 0;
        uint64_t v86 = a1 + 40;
        CA::OGL::fill_color_rect(a2, (uint64_t)&v81, (double *)0x80008080, v58, v83, v59);
      }
      CA::OGL::Context::release_surface(a2, v67);
      if (v49) {
        CA::OGL::Context::release_surface(a2, v49);
      }
      if (*(void *)&__dst[0]) {
        __assert_rtn("~ContextState", "ogl-context.h", 551, "!next && \"Imbalanced ContextState push/pop\"");
      }
    }
    else
    {
      CA::OGL::ContentsGeometry::fill_and_unbind(a1, (int32x2_t *)a2, (uint64_t)a3, v47);
      *(void *)(a2 + 16) = *(void *)&__dst[0];
    }
  }
}

uint64_t CACGColorSpaceIsRec601NTSC(uint64_t a1)
{
  if (CAGetColorSpace(0x16u) == a1) {
    return 1;
  }

  return CGColorSpaceEqualToColorSpaceIgnoringRange();
}

uint64_t CACGColorSpaceIsRec601PAL(uint64_t a1)
{
  if (CAGetColorSpace(0x17u) == a1) {
    return 1;
  }

  return CGColorSpaceEqualToColorSpaceIgnoringRange();
}

uint64_t CA::Render::Image::num_color_components(CA::Render::Image *this)
{
  unsigned int v1 = *((unsigned __int8 *)this + 152) - 8;
  if (v1 > 0x16) {
    return 3;
  }
  else {
    return dword_184999590[v1];
  }
}

CA::OGL::Context **CA::OGL::render_background(CA::OGL::Context **result, uint64_t a2, double a3, float32x4_t a4, int8x16_t a5)
{
  int v6 = result;
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void *)(a2 + 32);
  if ((v7 & 0x1000) != 0 && (*(unsigned char *)(*(void *)(a2 + 24) + 44) & 2) == 0)
  {
    uint64_t result = (CA::OGL::Context **)CA::OGL::render_shadow_path(*result, a2, a3, a4);
    if (byte_1EB2ACC6E) {
      return result;
    }
    uint64_t v7 = *(void *)(a2 + 32);
  }
  if ((v7 & 0x200000000) != 0)
  {
    double v8 = *v6;
    uint64_t v9 = *((void *)*v6 + 2);
    unsigned int v10 = *(unsigned __int8 *)(v9 + 480);
    if (v10 > 3 || v10 == 2) {
      *(unsigned char *)(v9 + 481) |= 1u;
    }
    uint64_t v12 = *(void *)(a2 + 24);
    float32x2_t v13 = *(float32x4_t **)(v12 + 128);
    if (v13)
    {
      double v14 = v13[18].f32[3];
      float16x4_t v15 = vcvt_f16_f32(v13[19]);
      float v16 = v13[20].f32[0];
      uint64_t v17 = *(void *)(v12 + 40);
      BOOL v18 = (double *)(v17 & 3);
      float v19 = v13[14].f32[1];
    }
    else
    {
      uint64_t v17 = *(void *)(v12 + 40);
      float16x4_t v15 = (float16x4_t)0x3C00000000000000;
      BOOL v18 = (double *)(v17 & 3);
      double v14 = 0.0;
      float v16 = 0.0;
      float v19 = 0.0;
    }
    *(double *)a5.i64 = v19;
    int v20 = *(_WORD *)(v12 + 38) & 0xF;
    float v21 = 0.0;
    if ((v17 & 0x4000000000) != 0) {
      float v21 = 1.0;
    }
    long long v22 = *(_OWORD *)(v12 + 80);
    float64x2_t v40 = *(float64x2_t *)(v12 + 64);
    long long v41 = v22;
    float16x4_t v39 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(v15), v16));
    uint64_t result = (CA::OGL::Context **)CA::OGL::emit_rim_rounded_rect(v8, &v40, &v39, v18, v20, *(CA::Mat4Impl **)(*((void *)v8 + 31) + 24), v14, v21, a5, *(double *)a5.i64);
  }
  __int16 v23 = *(_WORD *)(a2 + 40);
  if ((v23 & 8) != 0)
  {
    uint64_t v24 = **(void **)(*(void *)(a2 + 24) + 128);
    *(void *)&v40.f64[0] = &unk_1ED030FE0;
    *(void *)&v40.f64[1] = v6;
    *(void *)&long long v41 = a2;
    uint64_t result = (CA::OGL::Context **)(*(uint64_t (**)(uint64_t, float64x2_t *))(*(void *)v24 + 232))(v24, &v40);
  }
  uint64_t v25 = *(void *)(a2 + 32);
  if ((v25 & 0x20) != 0)
  {
    int8x8_t v26 = (int8x8_t)vcvt_f16_f32(*(float32x4_t *)(*(void *)(a2 + 24) + 16));
    if ((*(_WORD *)(a2 + 40) & 8) != 0)
    {
      uint64_t v27 = *(void *)(*(void *)(a2 + 16) + 256);
      if (v27)
      {
        os_unfair_lock_lock((os_unfair_lock_t)(v27 + 36));
        uint64_t v28 = *(void *)(v27 + 40);
        if (v28)
        {
          int v29 = (os_unfair_lock_s *)(v28 + 40);
          os_unfair_lock_lock((os_unfair_lock_t)(v28 + 40));
          uint64_t v30 = *(void *)(v28 + 64);
          uint64_t v31 = *(void *)(v28 + 72);
          if (v30 == v31)
          {
LABEL_27:
            int v32 = 0;
          }
          else
          {
            while (*(void *)v30 != *(void *)(v27 + 24))
            {
              v30 += 168;
              if (v30 == v31) {
                goto LABEL_27;
              }
            }
            uint64_t v33 = *(void *)(v28 + 48);
            if (v33 && *(CA::OGL::Context **)(v33 + 8) == *v6) {
              int v32 = (*(unsigned __int8 *)(v33 + 216) >> 1) & 1;
            }
            else {
              int v32 = *(unsigned __int8 *)(v30 + 160) != 0;
            }
          }
          os_unfair_lock_unlock(v29);
          os_unfair_lock_unlock((os_unfair_lock_t)(v27 + 36));
          if (v32) {
            unsigned int v34 = -1;
          }
          else {
            unsigned int v34 = 0;
          }
          int8x8_t v26 = vbic_s8(v26, (int8x8_t)vdup_n_s16(v34));
        }
        else
        {
          os_unfair_lock_unlock((os_unfair_lock_t)(v27 + 36));
        }
      }
    }
    int8x8_t v38 = v26;
    uint64_t v35 = *(void *)(*(void *)(a2 + 24) + 128);
    if (v35) {
      uint64_t v36 = *(void *)(v35 + 80);
    }
    else {
      uint64_t v36 = 0;
    }
    uint64_t result = (CA::OGL::Context **)CA::OGL::render_solid_background(*v6, a2, (uint64_t)&v38, v36);
    uint64_t v25 = *(void *)(a2 + 32);
  }
  if ((v23 & 8) == 0 && (v25 & 0x4000) != 0)
  {
    uint64_t v37 = **(void **)(*(void *)(a2 + 24) + 128);
    *(void *)&v40.f64[0] = &unk_1ED030FE0;
    *(void *)&v40.f64[1] = v6;
    *(void *)&long long v41 = a2;
    return (CA::OGL::Context **)(*(uint64_t (**)(uint64_t, float64x2_t *))(*(void *)v37 + 232))(v37, &v40);
  }
  return result;
}

BOOL CA::OGL::MetalContext::should_tile_image(CA::OGL::MetalContext *this, CA::Render::Texture *a2)
{
  unint64_t v2 = *((void *)this + 338);
  BOOL result = 1;
  if (v2 >= *((unsigned int *)a2 + 4) && v2 >= *((unsigned int *)a2 + 5))
  {
    if (*((unsigned char *)a2 + 12) != 23) {
      return 0;
    }
    unint64_t v4 = *((void *)this + 339);
    if (!v4 || *((void *)a2 + 20) <= v4) {
      return 0;
    }
  }
  return result;
}

uint64_t CA::Render::Texture::tiled_texture_cast(CA::Render::Texture *this)
{
  return 0;
}

void CA::OGL::MetalContext::update_texture(uint64_t a1, unint64_t a2, uint64_t a3, int a4, uint64_t a5, __n128 a6)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  int v10 = *(unsigned __int8 *)(a3 + 12);
  if (v10 == 51)
  {
    CA::OGL::MetalContext::update_surface(a1, a2, (unsigned int *)a3, a4, a5);
    return;
  }
  uint64_t v11 = *(void *)(a2 + 8);
  if (v10 != 23 || v11 == 0)
  {
    if (v10 != 34 || v11 == 0)
    {
      if (v10 != 9 || v11 == 0) {
        return;
      }
      int v15 = 204;
      int v16 = 1;
      unsigned int v17 = 166;
      switch(*(_DWORD *)(a3 + 156))
      {
        case 1:
          unsigned int v17 = 160;
          goto LABEL_48;
        case 2:
          unsigned int v17 = 164;
          goto LABEL_48;
        case 3:
          unsigned int v17 = 162;
          goto LABEL_48;
        case 4:
          goto LABEL_48;
        case 5:
          goto LABEL_47;
        case 6:
          int v15 = 205;
          goto LABEL_47;
        case 7:
          int v15 = 206;
          goto LABEL_47;
        case 8:
          int v15 = 207;
          goto LABEL_47;
        case 9:
          int v15 = 208;
          goto LABEL_47;
        case 0xA:
        case 0xB:
          int v15 = 210;
          goto LABEL_47;
        case 0xC:
          int v15 = 212;
          goto LABEL_47;
        case 0xD:
          int v15 = 213;
          goto LABEL_47;
        case 0xE:
          int v15 = 214;
          goto LABEL_47;
        case 0xF:
          int v15 = 215;
          goto LABEL_47;
        case 0x10:
          int v15 = 216;
          goto LABEL_47;
        case 0x11:
          int v15 = 217;
          goto LABEL_47;
        case 0x12:
          int v15 = 218;
LABEL_47:
          int v16 = 2;
          unsigned int v17 = v15;
LABEL_48:
          if ((*(_DWORD *)(a1 + 2724) & v16) == 0) {
            return;
          }
          int v23 = *(_DWORD *)(a3 + 168);
          if (v23 == 2)
          {
            int v24 = 0;
            *(_WORD *)(a2 + 58) |= 0x20u;
          }
          else
          {
            int v24 = (v23 == 0) << 24;
          }
          unsigned int v25 = *(_DWORD *)(a2 + 52) & 0xC0FFFFFF | v24;
          *(_DWORD *)(a2 + 52) = v25;
          a6.n128_u64[0] = *(void *)(a3 + 16);
          if (*(int *)(a3 + 152) >= 2)
          {
            *(_WORD *)(a2 + 123) |= 1u;
            *(_DWORD *)(a2 + 52) = v25 & 0xC1F0FFFF | 0x20000;
          }
          __n128 v36 = a6;
          CA::OGL::MetalContext::update_texture_plane((void *)a1, a2, a4, 0, v17, a6.n128_u32[0], a6.n128_u32[1]);
          [*(id *)(a2 + 88) setMipmapLevelCount:*(int *)(a3 + 152)];
          [*(id *)(a2 + 88) setUsage:1];
          if (*(unsigned char *)(a3 + 176))
          {
            int v29 = (void *)[*(id *)(a1 + 2952) newTextureWithDescriptor:*(void *)(a2 + 88)];
            *(void *)(a2 + 64) = v29;
            if (v29)
            {
              [v29 setLabel:@"com.apple.coreanimation.compressed-image-linear"];
              __n128 v30 = v36;
              if (*(int *)(a3 + 152) >= 1)
              {
                uint64_t v31 = 0;
                do
                {
                  uint64_t v32 = *(void *)(a3 + 96) + *(void *)(*(void *)(a3 + 128) + 8 * v31);
                  *(void *)&long long v33 = v30.n128_u32[0];
                  *((void *)&v33 + 1) = v30.n128_u32[1];
                  unsigned int v34 = *(void **)(a2 + 64);
                  memset(v38, 0, sizeof(v38));
                  long long v39 = v33;
                  uint64_t v40 = 1;
                  objc_msgSend(v34, "replaceRegion:mipmapLevel:slice:withBytes:bytesPerRow:bytesPerImage:", v38, v31, 0, v32, *(void *)(*(void *)(a3 + 144) + 8 * v31), 0, *(_OWORD *)&v30);
                  int8x8_t v35 = (int8x8_t)vcgt_u32(v37, (uint32x2_t)0x100000001);
                  v30.n128_u64[0] = (unint64_t)vsub_s32((int32x2_t)vand_s8((int8x8_t)vshr_n_u32(v37, 1uLL), v35), (int32x2_t)vmvn_s8(v35));
                  ++v31;
                }
                while (v31 < *(int *)(a3 + 152));
              }
            }
          }
          else
          {
            uint64_t v26 = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 168))(a3);
            uint64_t v27 = *MEMORY[0x1E4F14B00];
            if (*MEMORY[0x1E4F14B00] >= *MEMORY[0x1E4F14AE8]) {
              uint64_t v27 = *MEMORY[0x1E4F14AE8];
            }
            uint64_t v28 = objc_msgSend(*(id *)(a1 + 2952), "newTextureWithBytesNoCopy:length:descriptor:deallocator:", *(void *)(a3 + 96), (v26 + v27 - 1) & -v27, *(void *)(a2 + 88), 0, *(_OWORD *)&v36);
            *(void *)(a2 + 64) = v28;
            if (v28) {
              [v28 setLabel:@"com.apple.coreanimation.compressed-image"];
            }
          }
          CA::OGL::MetalContext::update_texture_ownership(a1, *(void **)(a2 + 64));
          *(void *)(a1 + 728) += (*(uint64_t (**)(uint64_t))(*(void *)a3 + 168))(a3);
          break;
        default:
          return;
      }
    }
    else
    {
      BOOL v18 = *(void **)(a3 + 96);
      if (!v18) {
        return;
      }
      if ([*(id *)(a3 + 96) device] != *(void *)(a1 + 2952)) {
        __assert_rtn("update_metal_texture", "ogl-metal.mm", 11593, "texture.device == _device");
      }
      if ([v18 pixelFormat] == 1
        && (*(unsigned int (**)(uint64_t))(*(void *)a3 + 104))(a3) != 8)
      {
        unsigned int v19 = *(_DWORD *)(a2 + 52) & 0xC0FFFFFF | 0x15000000;
      }
      else
      {
        unsigned int v19 = *(_DWORD *)(a2 + 52) & 0xC0FFFFFF;
      }
      *(_DWORD *)(a2 + 52) = v19;
      int v20 = [v18 mipmapLevelCount];
      unsigned int v21 = *(_DWORD *)(a3 + 16);
      unsigned int v22 = *(_DWORD *)(a3 + 20);
      if ((v20 & 0xFFFFFFFE) != 0)
      {
        *(_WORD *)(a2 + 123) |= 1u;
        *(_DWORD *)(a2 + 52) = *(_DWORD *)(a2 + 52) & 0xFFF0FFFF | 0x20000;
      }
      CA::OGL::MetalContext::update_texture_plane((void *)a1, a2, a4, 0, [v18 pixelFormat], v21, v22);
      *(void *)(a2 + 64) = v18;
    }
    *(_DWORD *)(a2 + 16) = *(_DWORD *)(a3 + 36);
    return;
  }

  CA::OGL::MetalContext::update_image(a1, a2, a3, a4, a5);
}

uint64_t CA::OGL::Context::destination_has_alpha_p(CA::OGL::Context *this)
{
  if (!(*(unsigned int (**)(CA::OGL::Context *))(*(void *)this + 800))(this)) {
    return 1;
  }
  uint64_t v2 = *((void *)this + 27);
  if (v2 && *(void *)(v2 + 504)) {
    return 1;
  }
  else {
    return (*((unsigned __int16 *)this + 416) >> 2) & 1;
  }
}

uint64_t CA::OGL::MetalContext::attached_to_framebuffer_p(CA::OGL::MetalContext *this)
{
  uint64_t v1 = *((void *)this + 33);
  if (v1) {
    return (*(unsigned __int16 *)(v1 + 232) >> 7) & 1;
  }
  else {
    return 1;
  }
}

uint64_t CA::Render::Texture::num_color_components(CA::Render::Texture *this)
{
  return 3;
}

unint64_t CA::OGL::render_shadow_path(CA::OGL::Context *a1, uint64_t a2, double a3, float32x4_t _Q1)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *((void *)a1 + 2);
  if (*(unsigned __int8 *)(v5 + 480) >= 2u) {
    *(unsigned char *)(v5 + 481) |= 1u;
  }
  uint64_t v6 = *(void *)(a2 + 24);
  uint64_t v7 = *(void *)(v6 + 128);
  if (v7)
  {
    _S0 = *(_DWORD *)(v7 + 200);
    _Q1.i32[0] = *(_DWORD *)(v7 + 204);
    __asm
    {
      FCVT            H0, S0
      FCVT            H1, S1
    }
    uint64_t v13 = _S0;
    uint64_t v14 = _Q1.u32[0];
    _Q1.i64[0] = *(void *)(v7 + 208);
    unint64_t v15 = *(void *)(v7 + 216);
    unint64_t v16 = vmovl_u16((uint16x4_t)vcvt_f16_f32(_Q1)).u64[0];
    v17.i64[0] = v16;
    v17.i64[1] = HIDWORD(v16);
    v18.i64[0] = 0xFFFFLL;
    v18.i64[1] = 0xFFFFLL;
    int64x2_t v19 = (int64x2_t)vshlq_u64((uint64x2_t)vandq_s8(v17, v18), (uint64x2_t)xmmword_184997FE0);
    unint64_t v20 = vorrq_s8((int8x16_t)vdupq_laneq_s64(v19, 1), (int8x16_t)v19).u64[0] | (v14 << 16) | v13;
    double v21 = *(float *)(v7 + 224);
  }
  else
  {
    unint64_t v15 = 0xC040000000000000;
    unint64_t v20 = 0x3C00000000000000;
    double v21 = 3.0;
  }
  unint64_t v35 = v15;
  int v22 = *(unsigned __int8 *)(v6 + 33);
  unint64_t v23 = *(void *)(v6 + 40);
  int v24 = (v23 >> 35) & ((v23 & 0x200000000) == 0);
  if (v7)
  {
    if ((v23 & 0x400000000) == 0) {
      goto LABEL_10;
    }
    long long v26 = *(_OWORD *)(v6 + 80);
    float64x2_t v33 = *(float64x2_t *)(v6 + 64);
    long long v34 = v26;
    uint64_t v27 = *(void *)(v7 + 72);
    if (v27)
    {
      unint64_t v32 = *(void *)(v7 + 216);
      unint64_t v31 = v20;
      unint64_t result = (unint64_t)CA::OGL::emit_shadow_uneven_round_rect(a1, &v33, (float32x2_t *)&v32, (double *)(v27 + 24), (float16x4_t *)&v31, v22, (v23 >> 33) & 1, v24, v21, v23 & 3, *(void *)(*((void *)a1 + 31) + 24));
      goto LABEL_15;
    }
    unint64_t v32 = *(void *)(v7 + 216);
    float v28 = *(float *)(v7 + 228);
LABEL_14:
    unint64_t v30 = v20;
    unint64_t result = (unint64_t)CA::OGL::emit_shadow_round_rect(a1, &v33, (float32x2_t *)&v32, (float16x4_t *)&v30, v22, (v23 >> 33) & 1, v24, v23 & 3, v28, v21, *(_WORD *)(v6 + 38) & 0xF, *(void *)(*((void *)a1 + 31) + 24));
    goto LABEL_15;
  }
  if ((v23 & 0x400000000) != 0)
  {
    long long v29 = *(_OWORD *)(v6 + 80);
    float64x2_t v33 = *(float64x2_t *)(v6 + 64);
    long long v34 = v29;
    unint64_t v32 = 0xC040000000000000;
    float v28 = 0.0;
    goto LABEL_14;
  }
LABEL_10:
  unint64_t result = CA::OGL::emit_shadow_path((uint64_t)a1);
LABEL_15:
  *(unsigned char *)(*((void *)a1 + 2) + 481) &= ~1u;
  return result;
}

uint64_t CA::OGL::render_subclass(CA::OGL::Renderer &,CA::OGL::Layer const*)::visitor::visit_subclass(uint64_t result, uint64_t a2, uint64_t a3, double *a4)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  if (!BYTE9(xmmword_1EB2ACC50) && *(unsigned char *)(a2 + 16) == 3)
  {
    uint64_t v4 = *(void *)(result + 16);
    uint64_t v5 = **(void ***)(result + 8);
    uint64_t v6 = v5[31];
    uint64_t v7 = *(void *)(v6 + 24);
    if ((*(unsigned char *)(v7 + 144) & 0x10) != 0) {
      double scale = CA::Mat4Impl::mat4_get_scale((CA::Mat4Impl *)v7, 0, 0, a4);
    }
    else {
      double scale = *(double *)(v7 + 128);
    }
    uint64_t v9 = v5[24];
    double v10 = 1.0 / scale;
    if (v9)
    {
      uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 16))(v9);
      if (v11)
      {
        if ((*(_DWORD *)(v11 + 624) & 4) != 0) {
          double v10 = 0.0;
        }
      }
    }
    uint64_t v12 = *(void *)(v4 + 24);
    uint64_t v13 = *(void *)(v12 + 128);
    float v14 = 0.0;
    if (v13) {
      float v14 = *(float *)(v13 + 228);
    }
    float64x2_t v15 = *(float64x2_t *)(v12 + 80);
    float64x2_t v37 = *(float64x2_t *)(v12 + 64);
    float64x2_t v38 = v15;
    CA::BoundsImpl::inset(v37.f64, v10, v10);
    float64x2_t v27 = v38;
    float64x2_t v28 = v37;
    float64x2_t v35 = v37;
    float64x2_t v36 = v38;
    CA::Rect::apply_transform((int8x16_t *)&v35, *(const CA::Transform **)(v6 + 24), v16);
    int64x2_t v17 = vceqzq_f64(v36);
    if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v17, 1), (int8x16_t)v17).u64[0] & 0x8000000000000000) != 0
      || (int8x16_t v18 = vorrq_s8((int8x16_t)vcltzq_f64(v36), (int8x16_t)vcgezq_f64(v36)),
          (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v18), 1), v18).u64[0] & 0x8000000000000000) != 0))
    {
      int32x4_t v29 = 0uLL;
    }
    else
    {
      int32x4_t v19 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v35, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
      int32x4_t v29 = vuzp1q_s32(v19, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v35, v36), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v19));
    }
    unint64_t result = CA::Shape::intersects(*(void *)(v6 + 8), (int32x2_t *)&v29);
    if (result)
    {
      float64_t v21 = fmax(v14 - v10, 0.0);
      *(void *)(v5[2] + 8) = 0x3C00000000000000;
      *(unsigned char *)(v5[2] + 481) |= 1u;
      int v22 = *(float64x2_t **)(v6 + 24);
      uint64_t v23 = CA::OGL::transform_filter_bits(v22, v20, 1.0, 1.0);
      v24.i64[0] = 1.0;
      int v26 = CA::OGL::rect_filter_bits(v22, v23, v25, v28, v27, v24, 1.0);
      v29.i64[0] = (uint64_t)&v37;
      v29.i64[1] = (uint64_t)v22;
      int v30 = v26;
      int v31 = 15;
      uint64_t v33 = 0;
      uint64_t v34 = 0;
      uint64_t v32 = 0;
      unint64_t result = CA::OGL::fill_round_rect((uint64_t)v5, (float64x2_t **)&v29, (double *)0xF, (double *)(*(_DWORD *)(*(void *)(v4 + 24) + 40) & 3), v21, v21);
      *(unsigned char *)(v5[2] + 481) &= ~1u;
    }
  }
  return result;
}

int8x16_t *CA::OGL::emit_shadow_uneven_round_rect(CA::OGL::Context *this, float64x2_t *a2, float32x2_t *a3, double *a4, float16x4_t *a5, int a6, int a7, int a8, double a9, unsigned int a10, uint64_t a11)
{
  v23[1] = *(float16x4_t *)MEMORY[0x1E4F143B8];
  double v15 = *a4;
  double v16 = a4[2];
  if (*a4 == v16
    && (double v17 = a4[1], v18 = a4[3], v17 == v18)
    && (double v19 = a4[4], v16 == v19)
    && (double v20 = a4[5], v18 == v20)
    && v19 == a4[6]
    && (v20 == a4[7] ? (BOOL v21 = v15 == v17) : (BOOL v21 = 0), v21))
  {
    v23[0] = *a5;
    return CA::OGL::emit_shadow_round_rect(this, a2, a3, v23, a6, a7, a8, a10, v15, a9, 15, a11);
  }
  else
  {
    unint64_t result = (int8x16_t *)CA::OGL::Context::shadow_cache(this);
    if (result)
    {
      unint64_t result = CA::Render::ShadowCache::lookup_rounded_rect_path((uint64_t)result, a2->f64, a4, a10 != 0);
      if (result) {
        return (int8x16_t *)CA::OGL::emit_shadow_path((uint64_t)this);
      }
    }
  }
  return result;
}

uint64_t CA::Render::ImageQueue::tag_detached_samples(uint64_t this, unsigned int a2)
{
  if (this && a2)
  {
    uint64_t v2 = a2;
    double v3 = (atomic_uint *)(this + 536);
    do
    {
      if (*(v3 - 1)) {
        atomic_fetch_or(v3, 0x1000000u);
      }
      v3 += 40;
      --v2;
    }
    while (v2);
  }
  return this;
}

uint64_t CA::OGL::set_swizzle(void *a1, unsigned int a2, int a3)
{
  if (a3 != 1) {
    __assert_rtn("set_swizzle", "ogl-layer.cpp", 2184, "swizzle == Render::kLayerContentsSwizzleAAAA");
  }
  uint64_t result = (*(uint64_t (**)(void *, uint64_t))(*a1 + 184))(a1, 28);
  uint64_t v6 = a1[2];
  if (result)
  {
    uint64_t v7 = a2;
    char v8 = CA::OGL::swizzle_to_image_function(CA::Render::LayerContentsSwizzle,CA::OGL::ImageFunction)::AAAA_functions[*(unsigned __int8 *)(v6 + a2 + 17)];
    if (!v8) {
      char v8 = 33;
    }
  }
  else
  {
    uint64_t v7 = a2;
    char v8 = 21;
  }
  *(unsigned char *)(v6 + v7 + 17) = v8;
  return result;
}

CA::Render::Image *CA::OGL::Context::tile_cache_load(double *a1, uint64_t a2, CA::Render::Image *a3, unsigned char *a4)
{
  uint64_t v4 = a3;
  v35[1] = *(double *)MEMORY[0x1E4F143B8];
  if (*a4 == 11 && a3 && (*(_DWORD *)(a2 + 308) & 0x12) != 0 && *((unsigned char *)a3 + 12) == 23)
  {
    if (*((unsigned __int8 *)a3 + 153) < 2u)
    {
      uint64_t v8 = CA::OGL::Context::tile_cache((CA::OGL::Context *)a1);
      if (v8)
      {
        double v10 = (CA::Render::TileCache *)v8;
        double v11 = *(double *)(a2 + 264);
        double v34 = 0.0;
        v35[0] = 0.0;
        double v12 = 1.0 / v11;
        if ((*(unsigned char *)(a2 + 248) & 0x10) != 0)
        {
          CA::Mat4Impl::mat4_get_scale((CA::Mat4Impl *)(a2 + 104), v35, &v34, v9);
          double v13 = v34;
          double v14 = v35[0];
        }
        else
        {
          double v13 = *(double *)(a2 + 232);
          double v14 = v13;
        }
        double v15 = v14 * v12;
        double v16 = *(double *)(a2 + 208);
        double v17 = *(double *)(a2 + 200) - floor(*(double *)(a2 + 200));
        *(double *)&unint64_t v18 = floor(v16);
        double v19 = v16 - *(double *)&v18;
        LODWORD(v18) = *((_DWORD *)v4 + 4);
        LODWORD(v16) = *((_DWORD *)v4 + 5);
        double v20 = v15 * (double)v18;
        double v34 = v13 * v12;
        v35[0] = v15;
        double v21 = v13 * v12 * (double)*(unint64_t *)&v16;
        image = CA::Render::TileCache::get_image(v10, v4, v17, v19, v20, v21, a1[30]);
        if (image)
        {
          int8x16_t v24 = image;
          *(double *)(a2 + 24) = v20 * v12;
          *(double *)(a2 + 32) = v21 * v12;
          v23.f64[0] = 1.0 / v35[0];
          CA::Transform::scale((float64x2_t *)(a2 + 104), v23, 1.0 / v34, 1.0);
          v25.f64[0] = -v17;
          float64x2_t v27 = CA::Transform::translate_right((float64x2_t *)(a2 + 104), v25, -v19, v26);
          LODWORD(v27.f64[0]) = *((_DWORD *)v24 + 4);
          LODWORD(v28) = *((_DWORD *)v24 + 5);
          float v29 = v20 / (double)*(unint64_t *)&v27.f64[0];
          float v30 = v21 / (double)v28;
          int v31 = *(_DWORD *)(a2 + 308);
          float v32 = 1.0 - v30;
          if ((v31 & 0x800) == 0) {
            float v32 = 0.0;
          }
          if ((v31 & 0x400) != 0)
          {
            *(float *)(a2 + 276) = *(float *)(a2 + 276) * v29;
            *(float *)(a2 + 280) = v32 + (float)(*(float *)(a2 + 280) * v30);
            *(float *)(a2 + 284) = *(float *)(a2 + 284) * v29;
            *(float *)(a2 + 288) = v32 + (float)(*(float *)(a2 + 288) * v30);
          }
          else
          {
            if ((v31 & 0x800) != 0) {
              float v30 = 1.0;
            }
            *(_DWORD *)(a2 + 276) = 0;
            *(float *)(a2 + 280) = v32;
            *(float *)(a2 + 284) = v29;
            *(float *)(a2 + 288) = v30;
            *(_DWORD *)(a2 + 308) = v31 | 0x400;
          }
          *a4 = 1;
          return v24;
        }
      }
    }
    else
    {
      *a4 = 7;
    }
  }
  return v4;
}

uint64_t ___ZN2CA19IOMobileFramebuffer9swap_waitEjj_block_invoke(uint64_t a1)
{
  uint64_t result = IOMobileFramebufferSwapWait();
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

void CA::Transaction::observer_callback(CA::Transaction *this, __CFRunLoopObserver *a2, unint64_t a3, void *a4)
{
  uint64_t v5 = *(CA::Transaction ***)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 576);
  if (v5)
  {
    if (v5[8] == this) {
      CA::Transaction::flush_as_runloop_observer((CA::Transaction *)v5, 1);
    }
  }
}

uint64_t CA::Render::Filter::compositing_dod(CA::Render::Filter *this)
{
  if ((int)this > 417)
  {
    if ((int)this <= 547)
    {
      switch((int)this)
      {
        case 515:
        case 524:
          return 4;
        case 516:
        case 517:
        case 519:
        case 521:
        case 522:
          return 0;
        case 518:
          return 3;
        case 520:
          return 5;
        case 523:
          return 2;
        default:
          JUMPOUT(0);
      }
    }
    uint64_t v2 = (this - 548);
    if (v2 > 0x3D) {
      return 0;
    }
    if (((1 << (this - 36)) & 0x200DA00000000001) == 0)
    {
      if (v2 == 1) {
        return 2;
      }
      if (v2 == 2) {
        return 3;
      }
      return 0;
    }
    return 4;
  }
  if ((int)this > 217)
  {
    char v1 = (_BYTE)this - 94;
    if ((this - 350) <= 0x35)
    {
      if (((1 << v1) & 0x20200400201C03) != 0) {
        return 4;
      }
      if (((1 << v1) & 0x120000000000) != 0) {
        return 5;
      }
    }
    if ((this - 218) > 0x2E || ((1 << (this + 38)) & 0x401000000001) == 0) {
      return 0;
    }
    return 4;
  }
  switch((int)this)
  {
    case 162:
    case 163:
    case 172:
    case 173:
    case 185:
      return 4;
    case 164:
    case 165:
    case 166:
    case 174:
    case 175:
    case 176:
    case 177:
    case 178:
    case 179:
    case 180:
    case 181:
    case 182:
    case 183:
    case 184:
      return 0;
    case 167:
    case 170:
    case 171:
      return 3;
    case 168:
      return 2;
    case 169:
      return 5;
    default:
      int v3 = this - 90;
      uint64_t result = 1;
      switch(v3)
      {
        case 0:
          return result;
        case 4:
        case 6:
        case 8:
          return 4;
        default:
          return 0;
      }
  }
  return result;
}

uint64_t CA::WindowServer::IOMFBDisplay::needs_alpha_unpremultiply(CA::WindowServer::IOMFBDisplay *this)
{
  return *((unsigned __int8 *)this + 28197);
}

uint64_t CA::Render::Updater::TransformOp::copy(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = x_heap_malloc_small_(a2, 0xB8uLL);
  uint64_t v4 = v3;
  if (v3)
  {
    BOOL is_2d_affine = 1;
    *(_WORD *)(v3 + 16) = 1;
    *(unsigned char *)(v3 + 18) = 0;
    *(void *)uint64_t v3 = &unk_1ED02FC88;
    CA::Transform::operator=(v3 + 24, a1 + 24);
    if ((*(unsigned char *)(a1 + 168) & 0x10) != 0) {
      BOOL is_2d_affine = CA::Mat4Impl::mat4_is_2d_affine((CA::Mat4Impl *)(a1 + 24), v6);
    }
    *(unsigned char *)(v4 + 176) = is_2d_affine;
  }
  return v4;
}

BOOL CA::Mat4Impl::mat4_is_2d_affine(CA::Mat4Impl *this, const double *a2)
{
  return fabs(*((double *)this + 3)) < 0.000001
      && fabs(*((double *)this + 7)) < 0.000001
      && fabs(*((double *)this + 8)) < 0.000001
      && fabs(*((double *)this + 9)) < 0.000001
      && fabs(*((double *)this + 11)) < 0.000001
      && fabs(*((double *)this + 15) + -1.0) < 0.000001;
}

uint64_t compare_pointer(void *a1, void *a2)
{
  return (*a1 > *a2) - (*a1 < *a2);
}

void CA::OGL::anonymous namespace'::filter_backdrop(CA::Render::Update **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, CA::Shape **a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v131 = *MEMORY[0x1E4F143B8];
  double v10 = *a1;
  *(_DWORD *)(a4 + 28) = *(_DWORD *)(a4 + 24);
  if (!a3) {
    goto LABEL_40;
  }
  unint64_t v12 = *(unsigned int *)(a3 + 16);
  if (!v12) {
    goto LABEL_40;
  }
  uint64_t v15 = a3 + 24;
  if ((*(unsigned char *)(*(void *)(a3 + 24) + 13) & 1) == 0)
  {
    unint64_t v16 = 0;
    do
    {
      if (v12 - 1 == v16) {
        goto LABEL_40;
      }
      uint64_t v17 = *(void *)(a3 + 32 + 8 * v16++);
    }
    while ((*(unsigned char *)(v17 + 13) & 1) == 0);
    if (v16 >= v12) {
      goto LABEL_40;
    }
  }
  unint64_t v18 = *(int32x4_t **)(a4 + 32);
  if (v18)
  {
    __int32 v20 = v18[2].i32[0];
    __int32 v19 = v18[2].i32[1];
    int v21 = v18[2].i32[2];
    int v22 = v18[2].i32[3];
    v117[0] = (CA::Shape *)__PAIR64__(v19, v20);
    v117[1] = (CA::Shape *)__PAIR64__(v22, v21);
    long long v116 = 0;
    if (a9)
    {
      if (v21 <= v22) {
        int v23 = v22;
      }
      else {
        int v23 = v21;
      }
      if (v21 >= v22) {
        int v24 = v22;
      }
      else {
        int v24 = v21;
      }
      if (v23 <= 1073741822 && v24 >= 1)
      {
        LODWORD(v117[0]) = v20 + 1;
        HIDWORD(v117[0]) = v19 + 1;
        LODWORD(v117[1]) = v21 - 2;
        HIDWORD(v117[1]) = v22 - 2;
        if (v21 - 2 < 1 || v22 - 2 <= 0) {
          v117[1] = 0;
        }
      }
      int32x4_t v27 = v18[2];
      int8x16_t v121 = (int8x16_t)v27;
      if (*(unsigned char *)(a4 + 216))
      {
        int v28 = v27.i32[2];
        if (v27.i32[2] <= v27.i32[3]) {
          int v29 = v27.i32[3];
        }
        else {
          int v29 = v27.i32[2];
        }
        if (v27.i32[2] >= v27.i32[3]) {
          int v28 = v27.i32[3];
        }
        if (v29 <= 1073741822 && v28 >= 1)
        {
          int8x16_t v121 = (int8x16_t)vaddq_s32(v27, (int32x4_t)xmmword_1849985E0);
          int32x2_t v31 = vcgt_s32((int32x2_t)0x100000001, vrev64_s32((int32x2_t)*(_OWORD *)&vextq_s8(v121, v121, 8uLL)));
          if ((v31.i32[1] | v31.i32[0])) {
            v121.i64[1] = 0;
          }
        }
      }
      long long v116 = (CA::Shape *)CA::Shape::new_shape((unsigned int *)&v121);
      if (a6) {
        CA::shape_subtract(&v116, a6, v32, v33);
      }
      else {
        CA::shape_subtract(&v116, v117, v32);
      }
    }
    uint64_t v36 = *(void *)(a4 + 40);
    uint64_t v103 = a8;
    if (v36 && v36 == *(void *)(a4 + 32))
    {
      CA::OGL::Context::release_surface((uint64_t)v10, v36);
      a6 = 0;
      a5 = 0;
      *(void *)(a4 + 40) = 0;
    }
    uint64_t v105 = a4;
    uint64_t v124 = 0x3C003C003C003C00;
    uint64_t v125 = 0;
    uint64_t v126 = 0;
    uint64_t v127 = 0;
    __int16 v130 = 0;
    int8x16_t v121 = 0uLL;
    uint64_t v122 = 0;
    int v128 = 1065353216;
    __int16 v129 = 1025;
    memset(v120, 0, sizeof(v120));
    CA::Shape::operator=((uint64_t)v120, v117);
    float64x2_t v37 = (_OWORD *)a5;
    if (!a5) {
      float64x2_t v37 = v120;
    }
    v121.i64[1] = (uint64_t)v37;
    uint64_t v38 = *(unsigned int *)(a3 + 16);
    int v111 = v22;
    if (v38)
    {
      uint64_t v39 = 8 * v38;
      uint64_t v40 = v39;
      uint64_t v41 = a3 + 24;
      while (*(_DWORD *)(*(void *)v41 + 24) != 50)
      {
        v41 += 8;
        v40 -= 8;
        if (!v40)
        {
          int v42 = 15;
          if (a6) {
            goto LABEL_65;
          }
          goto LABEL_57;
        }
      }
      if (*(_DWORD *)(*(void *)v15 + 24) == 50) {
        int v42 = 15;
      }
      else {
        int v42 = 262223;
      }
      v121.i64[1] = (uint64_t)&CA::Shape::_infinite_shape;
      if (!a6)
      {
LABEL_57:
        int v43 = v21;
        __int32 v44 = v20;
        int v108 = 1;
        a6 = (CA::Shape **)v120;
        goto LABEL_71;
      }
LABEL_65:
      while (1)
      {
        int v45 = *(_DWORD *)(*(void *)v15 + 24);
        if ((v45 == 588 || v45 == 247) && (*(_DWORD *)(*(void *)v15 + 12) & 0x40100) == 0x100) {
          break;
        }
        v15 += 8;
        v39 -= 8;
        if (!v39)
        {
          int v43 = v21;
          __int32 v44 = v20;
          int v108 = 1;
          goto LABEL_71;
        }
      }
      int v43 = v21;
      __int32 v44 = v20;
      int v108 = 0;
      v121.i64[1] = (uint64_t)a6;
    }
    else
    {
      int v43 = v21;
      __int32 v44 = v20;
      if (!a6) {
        a6 = (CA::Shape **)v120;
      }
      int v108 = 1;
      int v42 = 15;
    }
LABEL_71:
    uint64_t v123 = v105 + 64;
    int v115 = 0;
    uint64_t v46 = CA::OGL::prepare_filters(a1, a2, (unsigned int *)a3, 1, &v115, 1);
    if (v46)
    {
      unint64_t v47 = v46;
      unint64_t v48 = 0;
      uint64_t v49 = v46;
      do
      {
        v48 += !CA::OGL::can_filter_in_place(v49);
        uint64_t v49 = (void *)*v49;
      }
      while (v49);
      unsigned int v51 = *(_DWORD **)(v105 + 32);
      uint64_t v50 = *(_DWORD **)(v105 + 40);
      unsigned int v101 = v51[17] & 0x30 | v42;
      if (v48)
      {
        if (v50)
        {
          v50[8] = v44;
          v50[9] = v19;
          unsigned int v51 = v50;
          int v52 = v111;
          v50[10] = v43;
          v50[11] = v111;
          uint64_t v53 = v105;
        }
        else
        {
          unsigned int v51 = (_DWORD *)(*(uint64_t (**)(CA::Render::Update *, uint64_t, uint64_t, void))(*(void *)v10 + 656))(v10, 1, v103, v51[17] & 0x30 | v42 | 0x400u);
          uint64_t v53 = v105;
          int v52 = v111;
          if (!v51)
          {
            unint64_t v56 = 0;
            *(void *)(v105 + 40) = 0;
            goto LABEL_152;
          }
        }
      }
      else
      {
        ++*v51;
        if (v50)
        {
          uint64_t v57 = v51;
          CA::OGL::Context::release_surface((uint64_t)v10, (uint64_t)v50);
          unsigned int v51 = v57;
        }
        uint64_t v53 = v105;
        int v52 = v111;
      }
      double v109 = v51;
      (*(void (**)(CA::Render::Update *, _DWORD *, uint64_t, uint64_t))(*(void *)v10 + 704))(v10, v51, 16, 16);
      float v58 = v109;
      v109[8] = v44;
      v109[9] = v19;
      int v98 = v43;
      v109[10] = v43;
      v109[11] = v52;
      uint64_t v107 = v10;
      if (v48 < 2)
      {
        int64x2_t v61 = 0;
      }
      else
      {
        int v59 = v52;
        uint64_t v60 = (*(uint64_t (**)(CA::Render::Update *, uint64_t, uint64_t, void))(*(void *)v10 + 656))(v10, 1, v103, v101);
        if (!v60)
        {
          unint64_t v56 = 0;
          *(void *)(v53 + 40) = 0;
          uint64_t v91 = (uint64_t)v109;
          goto LABEL_151;
        }
        int64x2_t v61 = (int *)v60;
        (*(void (**)(CA::Render::Update *, uint64_t, uint64_t, uint64_t))(*(void *)v10 + 704))(v10, v60, 16, 16);
        v61[8] = v44;
        v61[9] = v19;
        v61[10] = v98;
        v61[11] = v59;
        float v58 = v109;
      }
      long long v95 = v47;
      if (v48) {
        float32x2_t v62 = v61;
      }
      else {
        float32x2_t v62 = v58;
      }
      if ((v48 & 1) == 0) {
        float v58 = v61;
      }
      uint64_t v110 = (uint64_t)v58;
      if (byte_1EB2ACBEA)
      {
        if (x_log_hook_p())
        {
          x_log_();
          uint64_t v53 = v105;
        }
        else
        {
          long long v93 = x_log_category_ogl;
          uint64_t v53 = v105;
          if (os_log_type_enabled((os_log_t)x_log_category_ogl, OS_LOG_TYPE_DEFAULT))
          {
            int v94 = *(_DWORD *)(a3 + 16);
            *(_DWORD *)buf = 67109376;
            *(_DWORD *)&uint8_t buf[4] = v94;
            v119[0].i16[0] = 2048;
            *(int32x2_t *)((char *)v119 + 2) = (int32x2_t)v47;
            _os_log_impl(&dword_184668000, v93, OS_LOG_TYPE_DEFAULT, "  applying %d merged group filters (lst %p)\n", buf, 0x12u);
          }
        }
      }
      uint64_t v63 = 0;
      int v64 = 0;
      uint64_t v102 = 0;
      unint64_t v56 = 0;
      int v112 = 1;
      float64x2_t v65 = v95;
      while (1)
      {
        char v66 = *(unsigned char *)(v53 + 216);
        BOOL can_filter_in_place = CA::OGL::can_filter_in_place(v65);
        BOOL v68 = can_filter_in_place;
        uint64_t v69 = v65[2];
        if (v69
          && ((int v70 = *(_DWORD *)(v69 + 24), v70 != 247) ? (v71 = v70 == 588) : (v71 = 1),
              !v71 ? (int v72 = 0) : (int v72 = 1),
              v108 |= v72,
              a5))
        {
          uint64_t v73 = v110;
          if (v72)
          {
            v121.i64[1] = a5;
            int v108 = 1;
          }
        }
        else
        {
          uint64_t v73 = v110;
        }
        int32x4_t v74 = v62;
        if (!v63) {
          int32x4_t v74 = *(int **)(v105 + 32);
        }
        if (can_filter_in_place) {
          uint64_t v75 = (uint64_t)v62;
        }
        else {
          uint64_t v75 = v73;
        }
        v112 &= can_filter_in_place;
        uint64_t v104 = v75;
        if (v112)
        {
          uint64_t v75 = *(void *)(v105 + 32);
          uint64_t v102 = v121.i64[1];
          v121.i64[1] = a7;
          int32x4_t v74 = (int *)v75;
        }
        else if ((((a9 & v108) ^ 1 | can_filter_in_place) & 1) == 0)
        {
          *(_OWORD *)(v75 + 32) = *(_OWORD *)v117;
        }
        v121.i64[0] = CA::OGL::Context::set_gstate((uint64_t)v107, (uint64_t)&v121);
        CA::OGL::Context::push_surface((uint64_t)v107, v75, (*(_WORD *)(v75 + 75) & 0x80) == 0, 64, 0);
        int v76 = v112;
        if (!v116) {
          int v76 = 1;
        }
        if (((v76 | v108) & 1) == 0)
        {
          uint64_t v114 = 0;
          (*(void (**)(CA::OGL::Context *))(*(void *)v107 + 912))(v107);
        }
        uint64_t v77 = v66 & 1;
        float v113 = 1.0;
        uint64_t v53 = v105;
        if (v56) {
          long long v78 = 0;
        }
        else {
          long long v78 = &v113;
        }
        CA::OGL::emit_filter(a1, (uint64_t)v65, a2, v74, v77, (uint64_t)a6, (uint64_t)v78, *(float *)(v105 + 28), *(float *)(v105 + 28));
        if (v112) {
          double v80 = (CA::Shape *)v102;
        }
        else {
          double v80 = (CA::Shape *)v121.i64[1];
        }
        v79.f32[0] = v113;
        if (v113 == 1.0 || v56) {
          goto LABEL_135;
        }
        double v80 = (CA::Shape *)CA::Shape::scale_and_dilate(v80, v79, v113, 1u, 1u);
        *(float *)(v105 + 28) = *(float *)(v105 + 28) * v113;
        *(_OWORD *)uint64_t v117 = *(_OWORD *)(v110 + 32);
        long long v97 = *(_OWORD *)v117;
        *(void *)buf = 0;
        v119[0] = 0;
        CA::Shape::get_bounds((uint64_t)v80, (int *)buf);
        char v81 = (CA::Shape *)v119[0];
        uint32x2_t v82 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)((char *)&v97 + 8));
        unsigned __int32 v83 = vpmax_u32(v82, v82).u32[0];
        uint32x2_t v84 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v119[0]);
        unsigned __int32 v85 = vpmax_u32(v84, v84).u32[0];
        if ((v83 & 0x80000000) != 0)
        {
          if ((v85 & 0x80000000) == 0)
          {
            uint64_t v86 = *(CA::Shape **)buf;
            goto LABEL_133;
          }
        }
        else if ((v85 & 0x80000000) == 0)
        {
          uint64_t v86 = (CA::Shape *)vmin_s32(*(int32x2_t *)&v97, *(int32x2_t *)buf);
          char v81 = (CA::Shape *)vsub_s32(vmax_s32(vadd_s32(*(int32x2_t *)&v97, *(int32x2_t *)((char *)&v97 + 8)), vadd_s32(*(int32x2_t *)buf, v119[0])), (int32x2_t)v86);
LABEL_133:
          v117[0] = v86;
          v117[1] = v81;
        }
        unint64_t v56 = v80;
LABEL_135:
        if (byte_1EB2ACBE1 && !*v65)
        {
          *(unsigned char *)(*((void *)v107 + 2) + 481) |= 1u;
          uint64_t v90 = *((void *)v107 + 2);
          *(unsigned char *)(v90 + 480) = 3;
          *(void *)(v90 + 8) = 0x3804000038043804;
          *(void *)buf = 0;
          v119[0] = 0;
          CA::OGL::emit_combine((uint64_t)v107, 0, 0, 0, v80, (unsigned int *)buf);
          *(unsigned char *)(*((void *)v107 + 2) + 481) &= ~1u;
        }
        CA::OGL::Context::pop_surface(v107);
        CA::OGL::Context::set_gstate((uint64_t)v107, **((void **)v107 + 31));
        v121.i64[1] = (uint64_t)v80;
        uint64_t v87 = v110;
        if (!v68) {
          uint64_t v87 = (uint64_t)v62;
        }
        uint64_t v110 = v87;
        char v88 = CA::OGL::filter_flags((uint64_t)v65, a2);
        if ((v88 & 0x10) != 0) {
          __int16 v89 = ~(*((_WORD *)v107 + 416) << 10) & 0x800;
        }
        else {
          __int16 v89 = 0;
        }
        v63 += !v68;
        v64 |= (v88 & 8) >> 3;
        *(_WORD *)(v75 + 75) = *(_WORD *)(v75 + 75) & 0xF7FF | v89;
        float64x2_t v65 = (void *)*v65;
        float32x2_t v62 = (int *)v104;
        if (!v65)
        {
          if (v64) {
            *(_WORD *)(v104 + 75) |= 0x200u;
          }
          *(void *)(v105 + 40) = v104;
          double v10 = v107;
          unint64_t v47 = v95;
          uint64_t v91 = v110;
          if (!v110)
          {
            do
            {
LABEL_152:
              long long v92 = (void *)*v47;
              CA::OGL::finalize_filter(v47);
              unint64_t v47 = v92;
            }
            while (v92);
            goto LABEL_153;
          }
LABEL_151:
          CA::OGL::Context::release_surface((uint64_t)v10, v91);
          goto LABEL_152;
        }
      }
    }
    uint64_t v54 = *(void *)(v105 + 40);
    if (v54)
    {
      CA::OGL::Context::release_surface((uint64_t)v10, v54);
      *(void *)(v105 + 40) = 0;
    }
    char v55 = *(_DWORD **)(v105 + 32);
    unint64_t v56 = 0;
    if (v55)
    {
      ++*v55;
      *(void *)(v105 + 40) = v55;
    }
LABEL_153:
    if (v116) {
      CA::Shape::unref(v116);
    }
    if (v56) {
      CA::Shape::unref(v56);
    }
  }
  else
  {
LABEL_40:
    float64x2_t v35 = *(_DWORD **)(a4 + 32);
    uint64_t v34 = *(void *)(a4 + 40);
    if ((_DWORD *)v34 != v35)
    {
      if (v34)
      {
        CA::OGL::Context::release_surface((uint64_t)v10, v34);
        float64x2_t v35 = *(_DWORD **)(a4 + 32);
      }
      if (v35)
      {
        ++*v35;
        *(void *)(a4 + 40) = v35;
      }
      else
      {
        *(void *)(a4 + 40) = 0;
      }
    }
  }
}

void *CA::OGL::prepare_filters(CA::Render::Update **a1, uint64_t a2, unsigned int *a3, char a4, int *a5, char a6)
{
  unint64_t v10 = 0;
  uint64_t v173 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = *(void *)(*(void *)(a2 + 16) + 256);
  if (v11 && (a6 & 1) == 0)
  {
    uint64_t v12 = *(void *)(v11 + 40);
    if (v12 && (uint64_t v13 = *(void *)(v12 + 560)) != 0) {
      unint64_t v10 = *(unsigned int *)(v13 + 16);
    }
    else {
      unint64_t v10 = 0;
    }
  }
  unint64_t v14 = a3[4];
  if (v10 >= v14) {
    return 0;
  }
  uint64_t v15 = 0;
  uint64_t v16 = 1065353216;
  __asm { FMOV            V0.4S, #1.0 }
  int8x16_t v154 = _Q0;
  _Q0.i32[0] = 1046066128;
  float v21 = 0.7873;
  *(float *)&int v22 = -0.2126;
  float v23 = 0.0722;
  *(float *)&int v24 = 0.9278;
  float32x2_t v25 = (float32x2_t)0x3E91D14E3E59B3D0;
  float32x2_t v26 = (float32x2_t)vdup_n_s32(0x3F371759u);
  uint64_t v27 = 0x3E0F5C293E126E98;
  float32x2_t v153 = (float32x2_t)vdup_n_s32(0x3D93DD98u);
  float32x2_t v155 = *(float32x2_t *)_Q0.i8;
  __int32 v152 = vdup_lane_s32(*(int32x2_t *)&_Q0, 0).i32[1];
  do
  {
    uint64_t v28 = *(void *)&a3[2 * v10 + 6];
    int v29 = *(_DWORD *)(v28 + 12);
    if ((v29 & 0x40100) == 0x100
      && ((v29 & 0x20000) == 0 || *(void *)(*(void *)(a2 + 16) + 88) || (*((_DWORD *)a1[1] + 271) & 0x4000) == 0))
    {
      if ((v29 & 0x200) != 0 && !*(_DWORD *)(v28 + 16)) {
        *(void *)(v28 + 16) = atomic_fetch_add(CA::Render::next_cache_id(void)::cache_id, 1u) + 1;
      }
      memset(v157, 0, sizeof(v157));
      uint64_t v30 = *(void *)(v28 + 48);
      if (v30)
      {
        if (!(*(unsigned int (**)(void))(*(void *)v30 + 72))(*(void *)(v28 + 48)))
        {
LABEL_24:
          unint64_t v14 = a3[4];
          goto LABEL_25;
        }
        int v31 = *a5;
        int v32 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v30 + 128))(v30, v28);
        if (v31 <= v32) {
          int v33 = v32;
        }
        else {
          int v33 = v31;
        }
        *a5 = v33;
        goto LABEL_22;
      }
      int v35 = *(_DWORD *)(v28 + 24);
      if (v35 <= 194)
      {
        if (v35 > 92)
        {
          switch(v35)
          {
            case ']':
            case 'm':
              float32x4_t v158 = 0uLL;
              if (CA::Render::KeyValueArray::get_float_color_key(*(CA::Render::KeyValueArray **)(v28 + 40), 286, &v158))
              {
                float v36 = v158.f32[1];
                float v37 = v158.f32[0];
                float v38 = v158.f32[2];
                if (v158.f32[0] == 0.0 && v158.f32[1] == 0.0 && v158.f32[2] == 0.0) {
                  goto LABEL_24;
                }
              }
              else
              {
                float32x4_t v158 = (float32x4_t)v154;
                float v38 = 1.0;
                float v36 = 1.0;
                float v37 = 1.0;
              }
              v157[3].i32[0] = 1065353216;
              v157[0].i32[0] = 1065353216;
              v157[4].i64[1] = v16;
              *(uint64_t *)((char *)v157[1].i64 + 4) = 0x3F80000000000000;
              *(float32x4_t *)((char *)v157 + 4) = 0uLL;
              memset((char *)&v157[1].u64[1] + 4, 0, 20);
              memset(&v157[3].i32[1], 0, 20);
              if (*(_DWORD *)(v28 + 24) == 109) {
                int v74 = -1;
              }
              else {
                int v74 = 1;
              }
              v157[1].f32[0] = v37 * (float)v74;
              v157[2].f32[1] = v36 * (float)v74;
              v157[3].f32[2] = v38 * (float)v74;
              goto LABEL_123;
            case '^':
            case 'b':
            case 'f':
            case 'i':
            case 'j':
            case 'l':
            case 'n':
            case 'o':
            case 'p':
            case 'q':
              goto LABEL_24;
            case '_':
              *(float *)&__int32 v43 = CA::Render::KeyValueArray::get_float_key(*(CA::Render::KeyValueArray **)(v28 + 40), 276, 1.0);
              if (*(float *)&v43 == 0.0) {
                goto LABEL_24;
              }
              v157[3].i64[0] = 1065353216;
              v157[0].i32[0] = 1065353216;
              v157[4].i64[1] = v16;
              *(uint64_t *)((char *)v157[1].i64 + 4) = 0x3F80000000000000;
              *(uint64_t *)((char *)v157[0].i64 + 4) = 0;
              v157[0].i32[3] = 0;
              *(uint64_t *)((char *)&v157[1].i64[1] + 4) = 0;
              v157[2].i64[1] = 0;
              *(uint64_t *)((char *)&v157[3].i64[1] + 4) = 0;
              v157[4].i32[1] = 0;
              v157[3].i32[2] = v43;
              v157[2].i32[1] = v43;
              v157[1].i32[0] = v43;
              goto LABEL_123;
            case 'a':
              *(float *)&unsigned __int32 v44 = CA::Render::KeyValueArray::get_float_key(*(CA::Render::KeyValueArray **)(v28 + 40), 276, 1.0);
              if (*(float *)&v44 == 1.0) {
                goto LABEL_24;
              }
              v157[4].i64[1] = v16;
              v157[1].i32[1] = 0;
              *(uint64_t *)((char *)v157[0].i64 + 4) = 0;
              v157[0].i32[3] = 0;
              *(uint64_t *)((char *)&v157[1].i64[1] + 4) = 0;
              v157[2].i64[1] = 0;
              *(uint64_t *)((char *)&v157[3].i64[1] + 4) = 0;
              v157[4].i32[1] = 0;
              v157[3].i64[0] = v44;
              v157[3].f32[2] = 0.5 - (float)(*(float *)&v44 * 0.5);
              v157[1].i32[2] = v44;
              v157[2].f32[1] = v157[3].f32[2];
              v157[0].i32[0] = v44;
              v157[1].f32[0] = v157[3].f32[2];
              goto LABEL_123;
            case 'c':
              float32x2_t v149 = (float32x2_t)v27;
              float32x2_t v45 = v26;
              float32x2_t v46 = v25;
              float v47 = *(float *)&v24;
              float v48 = v23;
              float v49 = *(float *)&v22;
              float v50 = v21;
              unsigned int v51 = *(CA::Render::KeyValueArray **)(v28 + 40);
              float float_key = CA::Render::KeyValueArray::get_float_key(v51, 277, 0.0);
              if (float_key == 0.0) {
                goto LABEL_79;
              }
              if (!CA::Render::KeyValueArray::get_int_key(v51, 301, 0))
              {
                v157[4].i64[1] = v16;
                *(uint64_t *)((char *)&v157[0].i64[1] + 4) = 0;
                v157[2].i64[0] = 0;
                memset(&v157[3].i32[1], 0, 20);
                __float2 v128 = __sincosf_stret(float_key);
                float v21 = v50;
                float v129 = v155.f32[0] + (float)(v128.__cosval * v50);
                *(float *)&int v22 = v49;
                *(float *)&unsigned int v130 = v129 + (float)(v128.__sinval * v49);
                float v23 = v48;
                float v131 = v48 - (float)(v128.__cosval * v48);
                *(float *)&int v24 = v47;
                v157[0].f32[2] = v131 + (float)(v128.__sinval * v47);
                float32x2_t v25 = v46;
                float32x2_t v132 = vmul_n_f32(v46, v128.__cosval);
                v133.f32[0] = vsub_f32(v155, v132).f32[0];
                float32x2_t v26 = v45;
                float32_t v134 = v133.f32[0] - (float)(v128.__sinval * v21);
                v133.i32[1] = vadd_f32(v132, v45).i32[1];
                uint64_t v27 = (uint64_t)v149;
                *(float32x2_t *)&v157[1].i32[1] = vmla_n_f32(v133, v149, v128.__sinval);
                float32x2_t v135 = vmul_n_f32((float32x2_t)0x3F6D844D3F371759, v128.__cosval);
                float32x2_t v136 = vsub_f32((float32x2_t)0x3F6D844D3F371759, v135);
                float32x2_t v137 = vmul_n_f32((float32x2_t)0x3D93DD983F371759, v128.__sinval);
                v133.i32[0] = vsub_f32(v136, v137).u32[0];
                v136.i32[1] = vadd_f32(v135, v153).i32[1];
                v157[1].f32[3] = v131 + (float)(v128.__sinval * -0.283);
                v157[2].f32[2] = v134;
                v157[0].i64[0] = __PAIR64__(v133.u32[0], v130);
                *(float32x2_t *)((char *)&v157[2].u64[1] + 4) = vadd_f32(v136, v137);
                goto LABEL_123;
              }
              uint64_t v15 = CA::OGL::add_primitive_filter((uint64_t)v15, v28);
LABEL_79:
              float v21 = v50;
              *(float *)&int v22 = v49;
              float v23 = v48;
              *(float *)&int v24 = v47;
              float32x2_t v25 = v46;
              float32x2_t v26 = v45;
LABEL_132:
              uint64_t v27 = (uint64_t)v149;
              goto LABEL_24;
            case 'd':
              goto LABEL_122;
            case 'e':
              uint64_t v53 = *((void *)*a1 + 24);
              if (v53
                && (uint64_t v54 = (*(uint64_t (**)(uint64_t))(*(void *)v53 + 16))(v53)) != 0
                && (*(unsigned int (**)(uint64_t))(*(void *)v54 + 864))(v54))
              {
                if ((*((_WORD *)*a1 + 416) & 2) != 0)
                {
                  if (*((int *)a1[1] + 271) >= 0) {
                    int v55 = ((*((unsigned int *)a1[1] + 271) | ((unint64_t)*((unsigned __int16 *)a1[1] + 544) << 32)) >> 33) & 1;
                  }
                  else {
                    int v55 = 1;
                  }
                }
                else
                {
                  int v55 = 1;
                }
              }
              else
              {
                int v55 = 0;
              }
              if (CA::Render::KeyValueArray::get_int_key(*(CA::Render::KeyValueArray **)(v28 + 40), 313, 0) != v55)goto LABEL_24; {
LABEL_122:
              }
              v157[4].i64[1] = v16;
              *(uint64_t *)((char *)v157[0].i64 + 4) = 0;
              v157[0].i32[3] = 0;
              *(uint64_t *)((char *)&v157[1].i64[1] + 4) = 0;
              v157[2].i64[1] = 0;
              *(uint64_t *)((char *)&v157[3].i64[1] + 4) = 0;
              v157[4].i32[1] = 0;
              v157[3].i64[0] = 3212836864;
              v157[3].i32[2] = 1065353216;
              v157[1].i32[2] = -1082130432;
              v157[2].i32[1] = 1065353216;
              v157[0].i32[0] = -1082130432;
              v157[1].i64[0] = 1065353216;
              goto LABEL_123;
            case 'g':
              CA::OGL::get_filter_color_matrix(*(CA::OGL **)(v28 + 40), (const CA::Render::Filter *)v157, (CA::ColorMatrix *)a3);
              int int_key = CA::Render::KeyValueArray::get_int_key(*(CA::Render::KeyValueArray **)(v28 + 40), 308, 0);
              int v57 = int_key;
              if (v15 || int_key || (a4 & 1) != 0 || !CA::ColorMatrix::is_diagonal((CA::ColorMatrix *)v157))
              {
                BOOL v42 = v57 == 0;
                goto LABEL_125;
              }
              _S1 = v157[4].i32[2];
              _S2 = v157[3].f32[0] * v157[4].f32[2];
              *(float32x2_t *)v58.f32 = vmul_n_f32((float32x2_t)__PAIR64__(v157[1].u32[2], v157[0].u32[0]), v157[4].f32[2]);
              v61.i32[0] = vcvt_f16_f32(v58).u32[0];
              __asm { FCVT            H2, S2 }
              v61.i16[2] = LOWORD(_S2);
              __asm { FCVT            H1, S1 }
              v61.i16[3] = _S1;
              *(float16x4_t *)(*(void *)(a2 + 104) + 88) = vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16(v61), vcvtq_f32_f16(*(float16x4_t *)(*(void *)(a2 + 104)+ 88))));
              if (*(short float *)&_S1 != COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))) {
                goto LABEL_119;
              }
              break;
            case 'h':
              float32x2_t v62 = *(CA::Render::KeyValueArray **)(v28 + 40);
              if (CA::Render::KeyValueArray::get_float_key(v62, 276, 1.0) == 0.0) {
                goto LABEL_24;
              }
              float32x2_t v149 = (float32x2_t)v27;
              float32x2_t v144 = v26;
              float32x2_t v145 = v25;
              int v146 = v22;
              float v63 = v21;
              float32x4_t v172 = 0uLL;
              if (CA::Render::KeyValueArray::get_float_color_key(v62, 286, &v172))
              {
                float v64 = v172.f32[3];
                float v65 = v172.f32[2];
                _D13 = *(float32x2_t *)v172.f32;
                if (v172.f32[3] > 0.0)
                {
                  _D13 = vmul_n_f32(*(float32x2_t *)v172.f32, 1.0 / v172.f32[3]);
                  *(float32x2_t *)v172.f32 = _D13;
                  float v65 = v172.f32[2] * (float)(1.0 / v172.f32[3]);
                  v172.f32[2] = v65;
                }
              }
              else
              {
                float32x4_t v172 = (float32x4_t)v154;
                float v64 = 1.0;
                __asm { FMOV            V13.2S, #1.0 }
                float v65 = 1.0;
              }
              uint64_t v120 = *(CA::Render::KeyValueArray **)(v28 + 40);
              float v121 = CA::Render::KeyValueArray::get_float_key(v120, 282, 0.0);
              float v143 = v121;
              float v122 = CA::Render::KeyValueArray::get_float_key(v120, 276, 1.0);
              _D2 = vmul_n_f32(_D13, v122);
              v158.i32[0] = vmlas_n_f32(1.0 - v122, v155.f32[0], _D2.f32[0]);
              *(float32x2_t *)&v158.i32[1] = vmul_n_f32((float32x2_t)0x3D93DD983F371759, _D2.f32[0]);
              v158.i32[3] = 0;
              float32x2_t v159 = vmul_f32(_D2, (float32x2_t)__PAIR64__(v152, LODWORD(v143)));
              _S1 = 1060575065;
              __asm { FMLA            S3, S1, V2.S[1] }
              int v160 = _S3;
              float v161 = vmuls_lane_f32(v23, _D2, 1);
              int v162 = 0;
              float v163 = vmuls_lane_f32(v143, _D2, 1);
              float32x2_t v164 = vmul_n_f32((float32x2_t)0x3F3717593E59B3D0, v65 * v122);
              float v165 = (float)(1.0 - v122) + (float)((float)(v65 * v122) * v23);
              int v166 = 0;
              float v167 = (float)(v65 * v122) * v143;
              uint64_t v168 = 0;
              int v169 = 0;
              float v170 = (float)(1.0 - v122) + (float)(v64 * v122);
              int v171 = 0;
              uint64_t v15 = CA::OGL::add_color_matrix((uint64_t)v15, v28, (int)*a1, &v158, a5, 1);
              float v21 = v63;
              int v22 = v146;
              float32x2_t v26 = v144;
              float32x2_t v25 = v145;
              goto LABEL_132;
            case 'k':
              float v67 = CA::Render::KeyValueArray::get_float_key(*(CA::Render::KeyValueArray **)(v28 + 40), 276, 1.0);
              if (v67 == 1.0) {
                goto LABEL_24;
              }
              float v68 = fmaxf(v67, 0.0);
              v157[4].i64[1] = v16;
              *(uint64_t *)((char *)&v157[0].i64[1] + 4) = 0;
              v157[2].i64[0] = 0;
              memset(&v157[3].i32[1], 0, 20);
              *(float *)&unsigned int v69 = v155.f32[0] + (float)(v68 * v21);
              v157[0].f32[2] = v23 - (float)(v68 * v23);
              float32x2_t v70 = vmul_n_f32(v25, v68);
              LODWORD(v71) = vsub_f32(v155, v70).u32[0];
              v157[2].i32[2] = v71;
              HIDWORD(v71) = vadd_f32(v70, v26).i32[1];
              *(uint64_t *)((char *)v157[1].i64 + 4) = v71;
              v157[1].f32[3] = v157[0].f32[2];
              float32x2_t v72 = vmul_n_f32((float32x2_t)0x3F6D844D3F371759, v68);
              LODWORD(v73) = vsub_f32((float32x2_t)0x3F6D844D3F371759, v72).u32[0];
              v157[0].i64[0] = __PAIR64__(v73, v69);
              HIDWORD(v73) = vadd_f32(v72, v153).i32[1];
              *(uint64_t *)((char *)&v157[2].i64[1] + 4) = v73;
              goto LABEL_123;
            case 'r':
              goto LABEL_22;
            default:
              if (v35 == 160 || v35 == 184) {
                goto LABEL_22;
              }
              goto LABEL_24;
          }
LABEL_90:
          uint64_t v15 = 0;
          goto LABEL_24;
        }
        BOOL v41 = v35 == 23 || v35 == 25;
        if (!v41
          && (v35 != 59
           || fabs(CA::Render::KeyValueArray::get_float_key(*(CA::Render::KeyValueArray **)(v28 + 40), 276, 1.0) + -0.5) <= 0.001))
        {
          goto LABEL_24;
        }
        goto LABEL_22;
      }
      if (v35 > 395)
      {
        if (v35 > 532)
        {
          _ZF = (v35 - 592) > 5 || ((1 << (v35 - 80)) & 0x25) == 0;
          if (_ZF && v35 != 533) {
            goto LABEL_24;
          }
          goto LABEL_22;
        }
        if (v35 != 396)
        {
          if (v35 != 410 && v35 != 492) {
            goto LABEL_24;
          }
          goto LABEL_22;
        }
        float32x4_t v158 = 0uLL;
        int float_color_key = CA::Render::KeyValueArray::get_float_color_key(*(CA::Render::KeyValueArray **)(v28 + 40), 286, &v158);
        int8x8_t v112 = (int8x8_t)vcvt_f16_f32(v158);
        if (float_color_key) {
          unsigned int v113 = -1;
        }
        else {
          unsigned int v113 = 0;
        }
        float16x4_t v114 = (float16x4_t)vbsl_s8((int8x8_t)vdup_n_s16(v113), v112, (int8x8_t)0x3C003C003C003C00);
        if (*(void *)&v114 == 0x3C003C003C003C00) {
          goto LABEL_24;
        }
        if ((a4 & 1) == 0 && !v15)
        {
          *(float16x4_t *)(*(void *)(a2 + 104) + 88) = vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16(v114), vcvtq_f32_f16(*(float16x4_t *)(*(void *)(a2 + 104)+ 88))));
          if (*(short float *)&v114.i16[3] != COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
          {
LABEL_119:
            uint64_t v15 = 0;
            *(void *)(a2 + 32) |= 4uLL;
            *(_WORD *)(a2 + 40) |= 1u;
            goto LABEL_24;
          }
          goto LABEL_90;
        }
        float32x4_t v158 = 0uLL;
        if (!CA::Render::KeyValueArray::get_float_color_key(*(CA::Render::KeyValueArray **)(v28 + 40), 286, &v158))goto LABEL_24; {
        if (v158.f32[3] <= 0.0)
        }
        {
          float32x2_t v126 = *(float32x2_t *)v158.f32;
          float v127 = v158.f32[2];
        }
        else
        {
          float32x2_t v126 = vmul_n_f32(*(float32x2_t *)v158.f32, 1.0 / v158.f32[3]);
          *(float32x2_t *)v158.f32 = v126;
          float v127 = v158.f32[2] * (float)(1.0 / v158.f32[3]);
          v158.f32[2] = v127;
        }
        memset(&v157[0].i32[1], 0, 20);
        memset((char *)&v157[1].u64[1] + 4, 0, 20);
        memset(&v157[3].i32[1], 0, 20);
        v157[1].i32[2] = v126.i32[1];
        v157[0].i32[0] = v126.i32[0];
        v157[3].f32[0] = v127;
        v157[4].i64[1] = __PAIR64__(HIDWORD(v16), v158.u32[3]);
LABEL_123:
        int v115 = *a1;
        uint64_t v116 = (uint64_t)v15;
        uint64_t v117 = v28;
        BOOL v118 = a5;
        int v119 = 1;
      }
      else
      {
        if (v35 <= 367)
        {
          switch(v35)
          {
            case 195:
              if (a4) {
                goto LABEL_22;
              }
              if (v15) {
                goto LABEL_22;
              }
              if ((*(void *)(a2 + 32) & 0x300007FE0) != 0x20) {
                goto LABEL_22;
              }
              if (*(void *)(*(void *)(a2 + 104) + 88) != 0x3C003C003C003C00) {
                goto LABEL_22;
              }
              float32x4_t v97 = *(float32x4_t *)(*(void *)(a2 + 24) + 16);
              int32x4_t v98 = (int32x4_t)vextq_s8(v154, (int8x16_t)v97, 0xCuLL);
              if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqq_f32(v97, (float32x4_t)vextq_s8((int8x16_t)v98, (int8x16_t)vrev64q_s32(v98), 8uLL))))) & 1) != 0|| v97.f32[0] <= 0.001)
              {
                goto LABEL_22;
              }
              long long v148 = *(_OWORD *)(*(void *)(a2 + 24) + 16);
              CA::Render::Update::render_edr_factor(a1[1], (const CA::Render::LayerNode *)a2);
              uint64_t v151 = v27;
              float32x2_t v99 = v26;
              float32x2_t v100 = v25;
              int v101 = v24;
              uint64_t v102 = v16;
              float v103 = v23;
              int v104 = v22;
              float v105 = v21;
              float v106 = *((float *)*a1 + 38);
              float v147 = CA::OGL::edr_gain_filter_gain(*(CA::OGL **)(v28 + 40), v107, v108, v106);
              float v109 = powf(*(float *)&v148, v106);
              float v110 = 1.0 / v106;
              float v21 = v105;
              int v22 = v104;
              float v23 = v103;
              uint64_t v16 = v102;
              int v24 = v101;
              float32x2_t v25 = v100;
              float32x2_t v26 = v99;
              uint64_t v27 = v151;
              uint64_t v15 = 0;
              float v88 = powf((float)(v109 * v147) + 1.0, v110) / *(float *)&v148;
              break;
            case 196:
              if (CA::Render::KeyValueArray::get_int_key(*(CA::Render::KeyValueArray **)(v28 + 40), 274, 1))
              {
LABEL_22:
                uint64_t v34 = CA::OGL::add_primitive_filter((uint64_t)v15, v28);
LABEL_23:
                uint64_t v15 = v34;
                goto LABEL_24;
              }
              CA::Render::Update::render_edr_factor(a1[1], v75);
              uint64_t v150 = v27;
              float32x2_t v76 = v26;
              float32x2_t v77 = v25;
              int v78 = v24;
              uint64_t v79 = v16;
              float v80 = v23;
              int v81 = v22;
              float v82 = v21;
              float v83 = *((float *)*a1 + 38);
              float v86 = CA::OGL::edr_gain_filter_gain(*(CA::OGL **)(v28 + 40), v84, v85, v83);
              float v87 = 1.0 / v83;
              float v21 = v82;
              int v22 = v81;
              float v23 = v80;
              uint64_t v16 = v79;
              int v24 = v78;
              float32x2_t v25 = v77;
              float32x2_t v26 = v76;
              uint64_t v27 = v150;
              float v88 = powf(v86 + 1.0, v87);
              break;
            case 262:
              goto LABEL_22;
            default:
              goto LABEL_24;
          }
          __int16 v89 = *(_WORD **)(a2 + 104);
          _H1 = v89[44];
          __asm { FCVT            S1, H1 }
          _S1 = v88 * _S1;
          __asm { FCVT            H1, S1 }
          v89[44] = LOWORD(_S1);
          LOWORD(_S1) = v89[45];
          __asm { FCVT            S1, H1 }
          _S1 = v88 * _S1;
          __asm { FCVT            H1, S1 }
          v89[45] = LOWORD(_S1);
          LOWORD(_S1) = v89[46];
          __asm { FCVT            S1, H1 }
          _S0 = v88 * _S1;
          __asm { FCVT            H0, S0 }
          v89[46] = LOWORD(_S0);
          goto LABEL_24;
        }
        if (v35 > 371)
        {
          if (v35 != 372 && v35 != 387) {
            goto LABEL_24;
          }
          goto LABEL_22;
        }
        if ((v35 - 368) < 2)
        {
          float v39 = CA::Render::KeyValueArray::get_float_key(*(CA::Render::KeyValueArray **)(v28 + 40), 276, 1.0);
          if (v39 == 0.0) {
            goto LABEL_24;
          }
          goto LABEL_22;
        }
        if (v35 != 370) {
          goto LABEL_24;
        }
        memset(v157, 0, 60);
        *(float32x4_t *)((char *)&v157[3] + 12) = (float32x4_t)xmmword_184997D70;
        BOOL v42 = CA::Render::KeyValueArray::get_int_key(*(CA::Render::KeyValueArray **)(v28 + 40), 308, 0) == 0;
LABEL_125:
        int v119 = v42;
        int v115 = *a1;
        uint64_t v116 = (uint64_t)v15;
        uint64_t v117 = v28;
        BOOL v118 = a5;
      }
      uint64_t v34 = CA::OGL::add_color_matrix(v116, v117, (int)v115, v157, v118, v119);
      goto LABEL_23;
    }
LABEL_25:
    ++v10;
  }
  while (v10 < v14);
  if (!v15) {
    return 0;
  }
  uint64_t v138 = v15[1];
  if (v138)
  {
    uint64_t v139 = 0;
    do
    {
      uint64_t v140 = v138;
      uint64_t v138 = *(void *)(v138 + 8);
      *(void *)(v140 + 8) = v139;
      uint64_t v139 = v140;
    }
    while (v138);
    v15[1] = v140;
  }
  long long v141 = 0;
  do
  {
    uint64_t result = v15;
    uint64_t v15 = (void *)*v15;
    *uint64_t result = v141;
    long long v141 = result;
  }
  while (v15);
  return result;
}

uint64_t CA::OGL::Context::push_surface(uint64_t this, uint64_t a2, unsigned __int8 a3, int a4, char a5)
{
  if (!a2) {
    __assert_rtn("push_surface", "ogl-context.cpp", 1117, "surf != nullptr");
  }
  uint64_t v6 = this;
  if (*(void *)(this + 264) == a2) {
    __assert_rtn("push_surface", "ogl-context.cpp", 1118, "_current_surface != surf");
  }
  if ((*(_WORD *)(this + 832) & 0x200) != 0) {
    this = CA::OGL::Context::flatten_detached_layers_(this);
  }
  __int16 v10 = *(_WORD *)(a2 + 75);
  if ((((v10 & 0x40) == 0) & a3) != 0) {
    __int16 v11 = 32;
  }
  else {
    __int16 v11 = 0;
  }
  *(_WORD *)(a2 + 75) = v11 | v10 & 0xFFDF;
  uint64_t v12 = *(void *)(v6 + 824);
  if (v12)
  {
    *(_DWORD *)(v12 + 300) |= a4 & 0x1FFFF;
    *(void *)(a2 + 16) = v12;
  }
  *(void *)(a2 + 8) = *(void *)(v6 + 264);
  *(void *)(v6 + 264) = a2;
  *(unsigned char *)(a2 + 72) = *(unsigned char *)(a2 + 72) & 0xC1 | (2 * (a5 & 0x1F));
  return this;
}

uint64_t CA::Render::KeyValueArray::get_float_color_key(CA::Render::KeyValueArray *this, int a2, float32x4_t *a3)
{
  unsigned int named_object = CA::Render::KeyValueArray::find_named_object_((uint64_t)this, a2);
  if ((named_object & 0x80000000) != 0) {
    return 0;
  }
  uint64_t v6 = *(void *)(*((void *)this + named_object + 3) + 24);
  if (!v6 || *(unsigned char *)(v6 + 12) != 56 || *(_DWORD *)(v6 + 16) < 4u) {
    return 0;
  }
  *a3 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)(v6 + 24)), *(float64x2_t *)(v6 + 40));
  return 1;
}

void CA::OGL::Context::pop_surface(CA::OGL::Context *this)
{
  uint64_t v1 = *((void *)this + 33);
  if (!v1) {
    __assert_rtn("pop_surface", "ogl-context.cpp", 1325, "_current_surface != 0");
  }
  if ((*(_WORD *)(v1 + 75) & 0x20) != 0
    && (*((void *)this + 34) != v1 || *((_DWORD *)this + 65) != ((*(unsigned __int8 *)(v1 + 72) >> 1) & 0x1F)))
  {
    CA::OGL::Context::prepare_destination_(this);
    uint64_t v1 = *((void *)this + 33);
  }
  if (*((_DWORD *)this + 115)) {
    BOOL v3 = BYTE1(xmmword_1EB2ACBF0) == 0;
  }
  else {
    BOOL v3 = 0;
  }
  if (v3 && (*(unsigned char *)(v1 + 69) & 8) == 0)
  {
    CA::OGL::export_surface((uint64_t)this, v1, "pop");
    uint64_t v1 = *((void *)this + 33);
  }
  *(void *)(v1 + 16) = 0;
  *(unsigned char *)(v1 + 72) &= 0xC1u;
  *((void *)this + 33) = *(void *)(*((void *)this + 33) + 8);
}

uint64_t CA::OGL::BlurFilter::DOD(CA::OGL::BlurFilter *this, CA::Render::KeyValueArray **a2, const CA::Render::Layer *a3, float64x2_t *a4)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  double float_key = CA::Render::KeyValueArray::get_float_key(a2[5], 310, 0.0);
  float v9 = (*(float (**)(CA::OGL::BlurFilter *))(*(void *)this + 152))(this);
  CA::BoundsImpl::inset(a4->f64, -(float_key * v9), -(float_key * v9));
  float64x2_t v18 = 0u;
  float64x2_t v19 = 0u;
  uint64_t result = (*(uint64_t (**)(CA::OGL::BlurFilter *, CA::Render::KeyValueArray **, const CA::Render::Layer *, float64x2_t *))(*(void *)this + 144))(this, a2, a3, &v18);
  if (result)
  {
    float64x2_t v11 = a4[1];
    int64x2_t v12 = vclezq_f64(v11);
    if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v12, 1), (int8x16_t)v12).u64[0] & 0x8000000000000000) == 0)
    {
      int64x2_t v13 = vclezq_f64(v19);
      if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v13, 1), (int8x16_t)v13).u64[0] & 0x8000000000000000) != 0
        || (float64x2_t v14 = vaddq_f64(*a4, v11),
            float64x2_t v15 = vmaxnmq_f64(*a4, v18),
            float64x2_t v16 = vsubq_f64(vminnmq_f64(v14, vaddq_f64(v18, v19)), v15),
            int64x2_t v17 = vclezq_f64(v16),
            (vorrq_s8((int8x16_t)vdupq_laneq_s64(v17, 1), (int8x16_t)v17).u64[0] & 0x8000000000000000) != 0))
      {
        a4[1].f64[0] = 0.0;
        a4[1].f64[1] = 0.0;
      }
      else
      {
        *a4 = v15;
        a4[1] = v16;
      }
    }
  }
  return result;
}

BOOL CA::Render::BackdropLayer::get_bounds(CA::Render::BackdropLayer *this, const CA::Render::Layer *a2, CA::Rect *a3, CA::Rect *a4)
{
  int v4 = *((_DWORD *)this + 3) & 0x500;
  if (v4)
  {
    CA::Render::BackdropLayer::get_backdrop_bounds((uint64_t)this, (uint64_t)a2, (uint64_t)a3);
    if (!a4) {
      return v4 != 0;
    }
  }
  else
  {
    a4 = a3;
  }
  *(_OWORD *)a4 = 0u;
  *((_OWORD *)a4 + 1) = 0u;
  return v4 != 0;
}

void CA::Render::Updater::RasterizationOp::map_bounds(CA::Render::Updater::RasterizationOp *this, CA::Render::Updater::LayerShapes *a2)
{
  BOOL v3 = (CA::Shape **)((char *)this + 20);
  CA::BoundsImpl::inset((double *)a2, (double)-*((_DWORD *)this + 5), (double)-*((_DWORD *)this + 5));
  if (*((void *)a2 + 8)) {
    CA::shape_map((CA::Shape **)a2 + 8, v3, (void (*)(CA::Rect *, void *))CA::Render::Updater::RasterizationOp::map_bounds(CA::Render::Updater::LayerShapes &,BOOL)::$_0::__invoke, v4, v5);
  }
  uint64_t v6 = (CA::Shape *)*((void *)a2 + 7);
  if (v6)
  {
    if (v6)
    {
      if (v6 == (CA::Shape *)1) {
        return;
      }
    }
    else if (*((_DWORD *)v6 + 1) == 6)
    {
      return;
    }
    CA::Shape::unref(v6);
    *((void *)a2 + 7) = 1;
  }
}

double *CA::BoundsImpl::inset(double *result, double a2, double a3)
{
  double v4 = result[2];
  double v3 = result[3];
  if (v4 <= v3) {
    double v5 = result[3];
  }
  else {
    double v5 = result[2];
  }
  if (v5 < 1.79769313e308)
  {
    if (v4 >= v3) {
      double v6 = result[3];
    }
    else {
      double v6 = result[2];
    }
    if (v6 > 0.0)
    {
      double v7 = result[1] + a3;
      *uint64_t result = *result + a2;
      result[1] = v7;
      double v8 = v4 - (a2 + a2);
      double v9 = v3 - (a3 + a3);
      result[2] = v8;
      result[3] = v9;
      if (v8 <= 0.0 || v9 <= 0.0)
      {
        result[2] = 0.0;
        result[3] = 0.0;
      }
    }
  }
  return result;
}

double *CA::Render::BackdropLayer::get_backdrop_bounds(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double v3 = *(double *)(a1 + 64);
  double v4 = *(double *)(a1 + 72);
  if (v3 >= v4) {
    double v5 = *(double *)(a1 + 72);
  }
  else {
    double v5 = *(double *)(a1 + 64);
  }
  if (v5 > 0.0)
  {
    double v6 = (void *)(a1 + 48);
    double v7 = (uint64_t *)(a1 + 56);
  }
  else
  {
    double v6 = (void *)(a2 + 64);
    double v7 = (uint64_t *)(a2 + 72);
    double v3 = *(double *)(a2 + 80);
    double v4 = *(double *)(a2 + 88);
  }
  uint64_t v8 = *v7;
  *(void *)a3 = *v6;
  *(void *)(a3 + 8) = v8;
  *(double *)(a3 + 16) = v3;
  *(double *)(a3 + 24) = v4;
  return CA::BoundsImpl::inset((double *)a3, (float)-*(float *)(a1 + 36), (float)-*(float *)(a1 + 36));
}

uint64_t CA::OGL::GaussianBlurFilter::get_bounds(CA::OGL::GaussianBlurFilter *this, const CA::Render::Filter *a2, const CA::Render::Layer *a3, Rect *a4)
{
  if (CA::Render::KeyValueArray::get_rect_key(*((void *)a2 + 5), a4)) {
    return 1;
  }
  double v7 = (CA::Render::KeyValueArray *)*((void *)a2 + 5);
  if (CA::Render::KeyValueArray::get_int_key(v7, 305, 0)
    || (uint64_t result = CA::Render::KeyValueArray::get_int_key(v7, 300, 0), result))
  {
    *(_OWORD *)&a4->top = *((_OWORD *)a3 + 4);
    *(_OWORD *)&a4[2].top = *((_OWORD *)a3 + 5);
    return 1;
  }
  return result;
}

uint64_t CA::Render::KeyValueArray::get_int_key(CA::Render::KeyValueArray *this, int a2, uint64_t a3)
{
  unsigned int named_object = CA::Render::KeyValueArray::find_named_object_((uint64_t)this, a2);
  if ((named_object & 0x80000000) == 0)
  {
    uint64_t v6 = *(void *)(*((void *)this + named_object + 3) + 24);
    if (v6)
    {
      if (*(unsigned char *)(v6 + 12) == 56 && *(_DWORD *)(v6 + 16)) {
        return (int)*(double *)(v6 + 24);
      }
    }
  }
  return a3;
}

double CA::Render::KeyValueArray::get_float_key(CA::Render::KeyValueArray *this, int a2, double a3)
{
  unsigned int named_object = CA::Render::KeyValueArray::find_named_object_((uint64_t)this, a2);
  if ((named_object & 0x80000000) == 0)
  {
    uint64_t v6 = *(void *)(*((void *)this + named_object + 3) + 24);
    if (v6)
    {
      if (*(unsigned char *)(v6 + 12) == 56 && *(_DWORD *)(v6 + 16)) {
        return *(double *)(v6 + 24);
      }
    }
  }
  return a3;
}

uint64_t CA::Render::KeyValueArray::find_named_object_(uint64_t a1, int a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  if (!v3) {
    return 0xFFFFFFFFLL;
  }
  if ((a2 & 0x40000000) != 0)
  {
    if ((a2 & 0xBFFFFFFF) >= v3) {
      return 0xFFFFFFFFLL;
    }
    else {
      return a2 & 0xBFFFFFFF;
    }
  }
  else
  {
    uint64_t result = 0;
    uint64_t v5 = a1 + 24;
    while (*(_DWORD *)(*(void *)(v5 + 8 * result) + 16) != a2)
    {
      if (v3 == ++result) {
        return 0xFFFFFFFFLL;
      }
    }
  }
  return result;
}

uint64_t CA::Render::KeyValueArray::get_rect_key(uint64_t this, Rect *a2)
{
  if (this)
  {
    uint64_t v2 = *(unsigned int *)(this + 16);
    if (!v2) {
      return 0;
    }
    uint64_t v3 = 0;
    while (1)
    {
      uint64_t v4 = *(void *)(this + 24 + 8 * v3);
      if (*(_DWORD *)(v4 + 16) == 285) {
        break;
      }
      if (v2 == ++v3) {
        return 0;
      }
    }
    if ((v3 & 0x80000000) == 0
      && (uint64_t v5 = *(void *)(v4 + 24)) != 0
      && *(unsigned char *)(v5 + 12) == 56
      && *(_DWORD *)(v5 + 16) >= 4u)
    {
      float64x2_t v6 = *(float64x2_t *)(v5 + 24);
      float64x2_t v7 = vsubq_f64(*(float64x2_t *)(v5 + 40), v6);
      *(float64x2_t *)&a2->top = v6;
      *(float64x2_t *)&a2[2].top = v7;
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return this;
}

float CA::OGL::BlurFilter::dirty_scale_factor(CA::OGL::BlurFilter *this)
{
  return 2.8;
}

BOOL CA::OGL::can_filter_in_place(void *a1)
{
  if (a1[1]) {
    return 0;
  }
  uint64_t v2 = a1[6];
  uint64_t v3 = a1[2];
  if (v2) {
    BOOL v4 = v3 == 0;
  }
  else {
    BOOL v4 = 0;
  }
  BOOL result = v4;
  if (v2) {
    BOOL v5 = 1;
  }
  else {
    BOOL v5 = v3 == 0;
  }
  if (!v5) {
    return (*(_DWORD *)(v3 + 12) & 0x40100) != 0x100
  }
        || CAAtomIndexInArray(25, (uint64_t)CA::Render::Filter::is_one_to_one(void)const::atoms, *(_DWORD *)(v3 + 24)) != -1;
  return result;
}

uint64_t CAAtomIndexInArray(uint64_t a1, uint64_t a2, int a3)
{
  unint64_t v3 = a1 - 1;
  if ((unint64_t)(a1 - 1) < 9)
  {
    unint64_t v4 = 0;
  }
  else
  {
    unint64_t v4 = 0;
    unint64_t v5 = a1 - 1;
    do
    {
      uint64_t result = v4 + (v5 >> 1);
      if (a3 - *(unsigned __int16 *)(a2 + 2 * result) <= 0)
      {
        unint64_t v3 = v4 + (v5 >> 1);
        if (((a3 - *(unsigned __int16 *)(a2 + 2 * result)) & 0x80000000) == 0) {
          return result;
        }
      }
      else
      {
        v4 += v5 >> 1;
      }
      unint64_t v5 = v3 - v4;
    }
    while (v3 - v4 > 8);
    if (v3 < v4) {
      return -1;
    }
  }
  uint64_t result = v4;
  while (*(unsigned __int16 *)(a2 + 2 * result) != a3)
  {
    if (++result > v3) {
      return -1;
    }
  }
  return result;
}

uint64_t CA::OGL::filter_flags(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  if (!v3)
  {
    float64x2_t v11 = *(CA::ColorMatrix **)(a1 + 48);
    if (!v11) {
      return 0;
    }
    if (CA::ColorMatrix::is_opaque_identity(v11)) {
      return 70;
    }
    return 6;
  }
  uint64_t v4 = *(void *)(v3 + 48);
  if (v4 && (*(unsigned int (**)(void))(*(void *)v4 + 72))(*(void *)(v3 + 48)))
  {
    uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4 + 112))(v4, v3, a2);
    goto LABEL_25;
  }
  int v7 = *(_DWORD *)(v3 + 24);
  if (v7 > 183)
  {
    if ((v7 - 368) >= 2 && v7 != 262)
    {
      uint64_t v6 = v7 == 184;
      goto LABEL_25;
    }
  }
  else if (((v7 - 99) > 0x3D || ((1 << (v7 - 99)) & 0x2000000000008001) == 0) {
         && v7 != 23
  }
         && v7 != 25)
  {
    uint64_t v6 = 0;
    goto LABEL_25;
  }
  uint64_t v6 = 6;
LABEL_25:
  int64x2_t v12 = *(CA::ColorMatrix **)(a1 + 48);
  if (v12)
  {
    if (CA::ColorMatrix::is_opaque_identity(v12)) {
      return v6 | 0x40;
    }
    else {
      return v6 & 0xFFFFFFEF;
    }
  }
  return v6;
}

void CA::OGL::emit_filter(CA::Render::Update **a1, uint64_t a2, uint64_t a3, int *a4, uint64_t a5, uint64_t a6, uint64_t a7, float a8, float a9)
{
  if (a4)
  {
    int64x2_t v13 = *a1;
    uint64_t v14 = *((void *)*a1 + 31);
    uint64_t v15 = *(void *)(a2 + 16);
    float v16 = a8 / a9;
    if (v15)
    {
      *(void *)(*((void *)v13 + 2) + 8) = *(void *)(v14 + 32);
      uint64_t v17 = *(void *)(v15 + 48);
      if (v17)
      {
        if ((*(unsigned int (**)(void))(*(void *)v17 + 72))(*(void *)(v15 + 48))) {
          (*(void (**)(uint64_t, uint64_t, uint64_t, CA::Render::Update *, int *, uint64_t, void, uint64_t, float, float, uint64_t))(*(void *)v17 + 104))(v17, v15, a3, v13, a4, a5, *(void *)(a2 + 48), a6, a8, a9, a7);
        }
      }
      else
      {
        int v25 = *(_DWORD *)(v15 + 24);
        if (v25 > 367)
        {
          if (v25 > 491)
          {
            if (v25 <= 591)
            {
              if (v25 == 492)
              {
                float v57 = a8 / a9;
                CA::OGL::emit_sdr_normalize_filter(v13, a4, v57);
              }
              else if (v25 == 533)
              {
                float v37 = *(CA::Render::KeyValueArray **)(v15 + 40);
                float v38 = a8 / a9;
                CA::OGL::render_srl_filter((uint64_t)v13, v37, a4, v38);
              }
            }
            else if (v25 == 592)
            {
              float v49 = *(CA::OGL **)(v15 + 40);
              float v50 = a8 / a9;
              CA::OGL::render_vibrant_color_matrix(v13, v49, (CA::ColorMatrix *)a4, v50);
            }
            else if (v25 == 594 || v25 == 597)
            {
              float v31 = a8 / a9;
              CA::OGL::render_vibrant_filter(v13, v15, a4, v31);
            }
          }
          else if (v25 <= 371)
          {
            if (v25 == 368)
            {
              uint64_t v53 = *(unsigned int **)(v15 + 40);
              float v54 = a8 / a9;
              CA::OGL::render_luminance_curve_map(v13, v53, a4, v54);
            }
            else if (v25 == 369)
            {
              float v34 = a8 / a9;
              CA::OGL::render_luminance_map((uint64_t)v13, v15, a4, v34);
            }
          }
          else
          {
            switch(v25)
            {
              case 372:
                float v42 = a8 / a9;
                CA::OGL::render_3d_lut_filter(v13, v15, a4, v42);
                break;
              case 387:
                CA::Render::Update::render_edr_factor(a1[1], (const CA::Render::LayerNode *)a2);
                unsigned __int32 v44 = *(CA::Render::KeyValueArray **)(v15 + 40);
                CA::OGL::render_meteor_filter((uint64_t)v13, v44, a4, v43, v16);
                break;
              case 410:
                uint64_t v28 = *(CA::Render::KeyValueArray **)(v15 + 40);
                float v29 = a8 / a9;
                CA::OGL::render_opacity_pair_filter(v13, v28, a4, v29);
                break;
            }
          }
        }
        else if (v25 > 159)
        {
          if (v25 <= 194)
          {
            if (v25 == 160)
            {
              int v55 = *(unsigned int **)(v15 + 40);
              float v56 = a8 / a9;
              CA::OGL::render_curves(v13, v55, a4, v56);
            }
            else if (v25 == 184)
            {
              int v35 = *(unsigned int **)(v15 + 40);
              float v36 = a8 / a9;
              CA::OGL::render_distance_field_filter(v13, v35, a4, v36);
            }
          }
          else
          {
            switch(v25)
            {
              case 195:
                CA::Render::Update::render_edr_factor(a1[1], (const CA::Render::LayerNode *)a2);
                float32x2_t v46 = *(CA::OGL **)(v15 + 40);
                CA::OGL::render_edr_gain_filter((uint64_t)v13, v46, a4, v45, v16);
                break;
              case 196:
                CA::Render::Update::render_edr_factor(a1[1], (const CA::Render::LayerNode *)a2);
                float v48 = *(CA::OGL **)(v15 + 40);
                CA::OGL::render_edr_gain_multiply_filter((uint64_t)v13, v48, a4, v47, v16);
                break;
              case 262:
                float v30 = a8 / a9;
                CA::OGL::render_home_affordance_base(v13, v15, a4, v30);
                break;
            }
          }
        }
        else if (v25 <= 58)
        {
          if (v25 == 23)
          {
            unsigned int v51 = *(CA::Render::KeyValueArray **)(v15 + 40);
            float v52 = a8 / a9;
            CA::OGL::render_alpha_smooth_threshold_filter(v13, v51, a4, v52);
          }
          else if (v25 == 25)
          {
            int v32 = *(CA::Render::KeyValueArray **)(v15 + 40);
            float v33 = a8 / a9;
            CA::OGL::render_alpha_threshold_filter(v13, v32, a4, v33);
          }
        }
        else
        {
          switch(v25)
          {
            case ';':
              float float_key = CA::Render::KeyValueArray::get_float_key(*(CA::Render::KeyValueArray **)(v15 + 40), 276, 1.0);
              CA::OGL::emit_bias(v13, a4, float_key, v16);
              break;
            case 'c':
              uint64_t v40 = *(CA::Render::KeyValueArray **)(v15 + 40);
              float v41 = a8 / a9;
              CA::OGL::render_hue_rotate(v13, v40, a4, v41);
              break;
            case 'r':
              CA::Render::Update::render_edr_factor(a1[1], (const CA::Render::LayerNode *)a2);
              uint64_t v27 = *(CA::Render::KeyValueArray **)(v15 + 40);
              CA::OGL::render_compress_luminance_filter((uint64_t)v13, v27, a4, v26, v16);
              break;
          }
        }
      }
    }
    else if (*(void *)(a2 + 48))
    {
      *(void *)(*((void *)v13 + 2) + 8) = *(void *)(v14 + 32);
      int v22 = *(float32x4_t **)(a2 + 48);
      int v23 = *(unsigned __int8 *)(a2 + 56);
      float v24 = a8 / a9;
      CA::OGL::emit_color_matrix(v13, v22, (uint64_t)a4, v23, v24);
    }
  }
}

void CA::OGL::finalize_filter(void *a1)
{
  uint64_t v2 = (void *)a1[1];
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)v2[1];
      free(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = (void *)a1[6];
  if (v4)
  {
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(malloc_zone, v4);
  }
  uint64_t v6 = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(v6, a1);
}

BOOL CA::OGL::PingPongState::attach_dest(float32x2_t *this, int a2, uint64_t a3)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  BOOL v6 = (this[4].i16[0] & 1) == 0;
  float32x2_t v7 = this[6];
  float32x2_t v8 = vsub_f32(this[7], v7);
  int32x2_t v9 = vceqz_f32(v8);
  v10.i64[0] = v9.i32[0];
  v10.i64[1] = v9.i32[1];
  if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v10, 1), (int8x16_t)v10).u64[0] & 0x8000000000000000) != 0
    || (int8x8_t v11 = vmvn_s8(vorr_s8((int8x8_t)vcltz_f32(v8), (int8x8_t)vcgez_f32(v8))),
        v12.i64[0] = v11.i32[0],
        v12.i64[1] = v11.i32[1],
        (vorrq_s8((int8x16_t)vdupq_laneq_s64(v12, 1), (int8x16_t)v12).u64[0] & 0x8000000000000000) != 0))
  {
    int32x4_t v29 = 0uLL;
    int32x2_t v19 = 0;
    int32x2_t v18 = (int32x2_t)-1;
  }
  else
  {
    float64x2_t v13 = vcvtq_f64_f32(v7);
    float64x2_t v14 = vmaxnmq_f64(v13, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000));
    float64x2_t v15 = vminnmq_f64(vaddq_f64(v13, vcvtq_f64_f32(v8)), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL));
    int32x4_t v16 = (int32x4_t)vcvtmq_s64_f64(v14);
    int32x4_t v17 = (int32x4_t)vsubq_s64(vcvtpq_s64_f64(v15), (int64x2_t)v16);
    int32x4_t v29 = vuzp1q_s32(v16, v17);
    int32x2_t v18 = vadd_s32(vmovn_s64((int64x2_t)v16), (int32x2_t)-1);
    int32x2_t v19 = vmovn_s64((int64x2_t)v17);
  }
  if (this[4].i8[2])
  {
    int v20 = v19.i32[0];
    if (v19.i32[0] <= v19.i32[1]) {
      int v21 = v19.i32[1];
    }
    else {
      int v21 = v19.i32[0];
    }
    if (v19.i32[0] >= v19.i32[1]) {
      int v20 = v19.i32[1];
    }
    if (v21 <= 1073741822 && v20 >= 1)
    {
      int8x8_t v23 = (int8x8_t)vadd_s32(v19, (int32x2_t)0x200000002);
      if (v23.i32[1] < 1 || v23.i32[0] < 1) {
        unsigned int v25 = -1;
      }
      else {
        unsigned int v25 = 0;
      }
      *(int32x2_t *)v29.i8 = v18;
      v29.u64[1] = (unint64_t)vbic_s8(v23, (int8x8_t)vdup_n_s32(v25));
    }
  }
  BOOL surface = CA::OGL::PingPongState::create_surface((CA::OGL::PingPongState *)this, v6, (const CA::Bounds *)&v29);
  if (surface)
  {
    uint64_t v27 = (uint64_t)this[v6 + 11];
    (*(void (**)(float32x2_t, uint64_t, uint64_t, uint64_t))(**(void **)this + 704))(*this, v27, a3, a3);
    CA::OGL::Context::push_surface((uint64_t)*this, v27, 0, 64, 0);
    if (a2)
    {
      if ((*(_WORD *)(v27 + 75) & 0x40) == 0)
      {
        memset(v30, 0, sizeof(v30));
        CA::Shape::operator=((uint64_t)v30, &v29);
        (*(void (**)(void))(**(void **)this + 912))();
      }
    }
  }
  return surface;
}

uint64_t CA::OGL::MetalContext::extend_surface(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  uint64_t v4 = *(int32x2_t **)(a2 + 200);
  if (!v4) {
    uint64_t v4 = (int32x2_t *)a2;
  }
  int32x2_t v5 = vmin_s32(vsub_s32(v4[5], (int32x2_t)vmvn_s8((int8x8_t)__PAIR64__(a4, a3))), *(int32x2_t *)(a2 + 24));
  *(int32x2_t *)(a2 + 184) = v5;
  uint64_t result = v5.u32[0];
  __int32 v7 = v5.i32[1];
  if ((*(unsigned char *)(a2 + 233) & 4) != 0)
  {
    *(int32x2_t *)(a2 + 184) = vrev64_s32(v5);
    __int32 v8 = v5.i32[0];
  }
  else
  {
    __int32 v8 = v5.i32[1];
    __int32 v7 = v5.i32[0];
  }
  __int16 v9 = *(_WORD *)(a2 + 75);
  if ((v9 & 0x40) == 0 || v7 > *(_DWORD *)(a2 + 192) || v8 > *(_DWORD *)(a2 + 196)) {
    *(_WORD *)(a2 + 75) = v9 & 0xFFBF;
  }
  return result;
}

uint64_t CA::OGL::MetalContext::clear_region(uint64_t result, uint64_t a2, uint64_t *a3)
{
  v5[1] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(result + 264);
  if (!v3) {
    __assert_rtn("clear_region", "ogl-metal.mm", 4155, "surf != nullptr");
  }
  if (*a3 || v3 == *(void *)(result + 272) || (__int16 v4 = *(_WORD *)(v3 + 75), (v4 & 0x80) != 0))
  {
    v5[0] = *a3;
    return CA::OGL::Context::paint_region(result, a2, v5, 0);
  }
  else
  {
    *(_WORD *)(v3 + 75) = v4 | 0x20;
  }
  return result;
}

BOOL CA::OGL::PingPongState::create_surface(CA::OGL::PingPongState *this, unsigned int a2, const CA::Bounds *a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  int32x2_t v5 = (char *)this + 8 * a2;
  uint64_t v8 = *((void *)v5 + 11);
  __int32 v7 = (uint64_t *)(v5 + 88);
  uint64_t v6 = v8;
  if (v8)
  {
    int v9 = *((_DWORD *)a3 + 2);
    if (v9 <= *(_DWORD *)(v6 + 24))
    {
      int v10 = *((_DWORD *)a3 + 3);
      BOOL v11 = v10 < 1 || v9 < 1;
      if (!v11 && v10 <= *(_DWORD *)(v6 + 28))
      {
        uint64_t v15 = *(void *)this;
        uint64_t v16 = *(void *)a3;
        int v17 = v9;
        int v18 = v10;
        (*(void (**)(uint64_t))(*(void *)v15 + 696))(v15);
        uint64_t v13 = *v7;
        return v13 != 0;
      }
    }
    CA::OGL::Context::release_surface(*(void *)this, v6);
    uint64_t *v7 = 0;
  }
  uint64_t v13 = (*(uint64_t (**)(void, uint64_t, const CA::Bounds *, void))(**(void **)this + 656))(*(void *)this, 1, a3, *((unsigned int *)this + 9));
  uint64_t *v7 = v13;
  return v13 != 0;
}

char *CA::OGL::MetalContext::create_surface(CA::OGL::MetalContext *this, MTLPixelFormat a2, int32x2_t *a3, int a4)
{
  uint64_t v104 = *MEMORY[0x1E4F143B8];
  unint64_t v4 = a3[1].u32[0];
  if ((int)v4 < 1) {
    return 0;
  }
  unint64_t v6 = a3[1].u32[1];
  if ((int)v6 < 1) {
    return 0;
  }
  int v7 = a2;
  uint64_t v8 = this;
  if (*((_DWORD *)this + 680) < (int)a2) {
    return 0;
  }
  unint64_t v11 = *((void *)this + 337);
  if (v11 < v4 || v11 < v6)
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      int v18 = x_log_category_ogl_metal;
      if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_DEFAULT))
      {
        __int32 v19 = a3[1].i32[0];
        __int32 v20 = a3[1].i32[1];
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)uint64_t v102 = v19;
        *(_WORD *)&v102[4] = 1024;
        *(_DWORD *)&v102[6] = v20;
        _os_log_impl(&dword_184668000, v18, OS_LOG_TYPE_DEFAULT, "Surface %d x %d is too large\n", buf, 0xEu);
      }
    }
    return 0;
  }
  if ((*((_WORD *)this + 1664) & 0x10) != 0) {
    int v14 = 4194015;
  }
  else {
    int v14 = 4185823;
  }
  uint64_t v15 = *((void *)this + 354);
  if ((a4 & 0x10) != 0) {
    uint64_t v15 = 115;
  }
  if ((a4 & 0x100000) != 0) {
    uint64_t v15 = 80;
  }
  if ((a4 & 0x200000) != 0) {
    uint64_t v15 = 63;
  }
  if ((a4 & 8) == 0) {
    goto LABEL_22;
  }
  if (v15 > 89)
  {
    uint64_t v16 = 110;
    if (v15 != 90 && v15 != 94)
    {
      if (v15 != 554) {
        goto LABEL_22;
      }
      if (CADeviceIsVirtualized::once != -1) {
        dispatch_once(&CADeviceIsVirtualized::once, &__block_literal_global_280);
      }
      if (CADeviceIsVirtualized::is_virtualized) {
        uint64_t v16 = 115;
      }
      else {
        uint64_t v16 = 550;
      }
    }
  }
  else
  {
    switch(v15)
    {
      case 10:
        uint64_t v16 = 30;
        break;
      case 43:
        uint64_t v16 = 80;
        break;
      case 63:
        uint64_t v16 = 113;
        break;
      default:
LABEL_22:
        uint64_t v16 = v15;
        break;
    }
  }
  if ((a4 & 0x10000) != 0)
  {
    if ((*((unsigned char *)v8 + 2725) & 4) != 0) {
      uint64_t v16 = 43;
    }
    else {
      uint64_t v16 = 80;
    }
  }
  if (CADeviceUseCompression::once[0] != -1) {
    dispatch_once(CADeviceUseCompression::once, &__block_literal_global_21);
  }
  int v17 = v14 & (a4 | 7);
  if (CADeviceUseCompression::enable_compression
    && ([*((id *)v8 + 369) supportsExtendedXR10Formats] & (v16 == 550)) != 0)
  {
    uint64_t v16 = 552;
  }
  if ((unint64_t)(v16 - 550) <= 5)
  {
    if ((a4 & 0x240) != 0)
    {
      v17 |= 0x10u;
      uint64_t v16 = 115;
    }
    else
    {
      v17 |= 0x100u;
    }
  }
  float v21 = 1.0;
  if ((v17 & 0x1000) != 0)
  {
    if (*((float *)v8 + 734) == 1.0) {
      v17 &= ~0x1000u;
    }
    else {
      float v21 = *((float *)v8 + 734);
    }
  }
  if ((v17 & 0x21930) == 0x20000) {
    uint64_t v22 = 80;
  }
  else {
    uint64_t v22 = v16;
  }
  if ((v17 & 0x80) != 0)
  {
    uint64_t v23 = CA::OGL::srgb_pixel_format(v22, a2);
    if (v22 == v23)
    {
      v17 &= ~0x80u;
      if (x_log_hook_p())
      {
        uint64_t Name = MTLPixelFormatGetName();
        x_log_();
      }
      else
      {
        float32x2_t v46 = x_log_category_ogl_metal;
        if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          *(void *)uint64_t v102 = MTLPixelFormatGetName();
          _os_log_impl(&dword_184668000, v46, OS_LOG_TYPE_DEFAULT, "Cannot create sRGB variant of %s", buf, 0xCu);
        }
      }
    }
    else
    {
      uint64_t v22 = v23;
    }
  }
  if ((unint64_t)(v22 - 550) >= 6) {
    int v24 = v17;
  }
  else {
    int v24 = v17 | 0x100;
  }
  if (v22 == 125)
  {
    v24 |= 0x20u;
  }
  else if (v22 == 115)
  {
    v24 |= 0x10u;
  }
  unsigned int v25 = v24 & 0xFFFFF7FF;
  if ((*((_WORD *)v8 + 1664) & 8) != 0) {
    unsigned int v26 = v24;
  }
  else {
    unsigned int v26 = v24 & 0xFFFFF7FF;
  }
  if ((v26 & 0x800) == 0) {
    goto LABEL_84;
  }
  uint64_t v27 = *((void *)v8 + 34);
  if (v27 != *((void *)v8 + 33)) {
    goto LABEL_75;
  }
  if (v27) {
    LODWORD(v27) = (*(unsigned __int8 *)(v27 + 72) >> 1) & 0x1F;
  }
  if (*((_DWORD *)v8 + 65) != v27) {
LABEL_75:
  }
    CA::OGL::Context::prepare_destination_(v8);
  if (v7 != 1) {
    goto LABEL_84;
  }
  uint64_t v28 = *((void *)v8 + 499);
  if (!v28) {
    goto LABEL_84;
  }
  if ((v26 & 0x40) != 0) {
    goto LABEL_84;
  }
  __int16 v29 = *(_WORD *)(v28 + 216);
  if (!v29 || ((*(_DWORD *)(v28 + 68) ^ v26) & 0xFFFCE3C0) != 0) {
    goto LABEL_84;
  }
  if ((v29 & 2) != 0)
  {
    __int16 v90 = -3;
    unsigned int v91 = 1;
    goto LABEL_191;
  }
  unsigned int v25 = v26;
  if ((v29 & 4) != 0)
  {
    __int16 v90 = -5;
    unsigned int v91 = 2;
LABEL_191:
    int v9 = (char *)x_mem_alloc0(0xF0uLL);
    *(_DWORD *)int v9 = 1;
    __int16 v92 = *(_WORD *)(v9 + 75) | 0x10;
    *(_WORD *)(v9 + 75) = v92;
    long long v93 = *(_OWORD *)a3->i8;
    *((int32x2_t *)v9 + 5) = a3[1];
    uint64_t v94 = *((void *)v8 + 499);
    *(void *)&long long v95 = *(void *)(v94 + 24);
    *((void *)&v95 + 1) = v93;
    *(_OWORD *)(v9 + 24) = v95;
    *((void *)v9 + 23) = *(void *)(v94 + 184);
    *((_DWORD *)v9 + 17) = *(_DWORD *)(v94 + 68) | 0x800;
    LOWORD(v94) = *(_WORD *)(v94 + 232) & 0x400;
    __int16 v96 = *((_WORD *)v9 + 116) & 0xFAC0;
    v9[72] |= 1u;
    v92 &= ~0x80u;
    *(_WORD *)(v9 + 75) = v92;
    LOWORD(v94) = v96 | 0x31 | v94;
    *((_WORD *)v9 + 116) = v94;
    *((_WORD *)v9 + 116) = *(_WORD *)(*((void *)v8 + 499) + 232) & 0x200 | v94 & 0xFDFF;
    *((void *)v9 + 25) = *((void *)v8 + 499);
    *((_WORD *)v9 + 106) = v91;
    *(_WORD *)(v9 + 75) = v92 | 0x100;
    *((void *)v9 + 12) = *(id *)(*((void *)v8 + 499) + 8 * v91 + 96);
    *((void *)v9 + 15) = [*(id *)(*((void *)v8 + 499) + 8 * v91 + 96) pixelFormat];
    *((float *)v9 + 16) = v21;
    *(_WORD *)(*((void *)v8 + 499) + 216) &= v90;
    return v9;
  }
LABEL_84:
  int v30 = v25 & 0x48000;
  int v31 = a3[1].i32[0];
  int v32 = a3[1].i32[1];
  if ((v25 & 0x40000) != 0)
  {
    unint64_t v33 = v31 - 1;
    if ((v31 & v33) != 0)
    {
      unint64_t v34 = v33 | (v33 >> 1) | ((v33 | (v33 >> 1)) >> 2);
      unint64_t v35 = v34 | (v34 >> 4) | ((v34 | (v34 >> 4)) >> 8);
      int v31 = (((v35 | (v35 >> 16)) >> 32) | v35 | (v35 >> 16)) + 1;
    }
    if ((v32 & (unint64_t)(v32 - 1)) != 0)
    {
      unint64_t v36 = (v32 - 1) | ((unint64_t)(v32 - 1) >> 1) | (((v32 - 1) | ((unint64_t)(v32 - 1) >> 1)) >> 2);
      unint64_t v37 = v36 | (v36 >> 4) | ((v36 | (v36 >> 4)) >> 8);
      int v32 = (((v37 | (v37 >> 16)) >> 32) | v37 | (v37 >> 16)) + 1;
    }
  }
  BOOL v39 = v31 < 64 || v32 < 64;
  if (!v30 && v39)
  {
    int v40 = CA::OGL::metal_pixel_format_Bpp((CA::OGL *)v22, a2);
    if (v31 > 63 || v32 >= 64)
    {
      unint64_t v41 = *MEMORY[0x1E4F14B00] / (unint64_t)(v40 << 6);
      if ((v31 - 17) > 0x2E || v32 > 511)
      {
        if ((v32 - 17) <= 0x2E && v31 <= 511)
        {
          uint64_t v47 = (int)v41 - 1;
          unint64_t v48 = v47 + v31;
          unint64_t v49 = v48 / (int)v41 * (int)v41;
          uint64_t v50 = v48 & -(uint64_t)(int)v41;
          if (((int)v41 & (unint64_t)v47) != 0) {
            int v31 = v49;
          }
          else {
            int v31 = v50;
          }
          int v32 = 64;
        }
      }
      else
      {
        uint64_t v42 = (int)v41 - 1;
        unint64_t v43 = v42 + v32;
        unint64_t v44 = v43 / (int)v41 * (int)v41;
        uint64_t v45 = v43 & -(uint64_t)(int)v41;
        if (((int)v41 & (unint64_t)v42) != 0) {
          int v32 = v44;
        }
        else {
          int v32 = v45;
        }
        int v31 = 64;
      }
    }
    else
    {
      int v32 = 64;
      int v31 = 64;
    }
  }
  unsigned int v51 = v25 & 0xFFFFFBFF;
  uint64_t v53 = (char **)((char *)v8 + 80);
  uint64_t v52 = *((void *)v8 + 10);
  if (!v52) {
    goto LABEL_153;
  }
  unint64_t v54 = 0;
  int v55 = 0;
  unint64_t v56 = v31 * v32;
  do
  {
    int v57 = *(_DWORD *)(v52 + 24);
    if (v30)
    {
      if (v31 != v57) {
        goto LABEL_141;
      }
      int v58 = v32;
      int v57 = v31;
      if (v32 != *(_DWORD *)(v52 + 28)) {
        goto LABEL_141;
      }
    }
    else
    {
      if (v31 > v57) {
        goto LABEL_141;
      }
      int v58 = *(_DWORD *)(v52 + 28);
      if (v32 > v58) {
        goto LABEL_141;
      }
    }
    if (*(_DWORD *)(v52 + 68) == v51
      && (*(unsigned char *)(v52 + 72) & 1) == v7
      && *(void *)(v52 + 48) == *((void *)v8 + 386)
      && ((v25 & 0x4000) == 0 || *(_DWORD *)(v52 + 208) != *((_DWORD *)v8 + 736)))
    {
      int v59 = 0;
      while (v59 < v7)
      {
        int v59 = 1;
        if (*(void *)(v52 + 120) != v22) {
          goto LABEL_141;
        }
      }
      unint64_t v60 = v58 * v57 - v56;
      if (((v25 & 0x400) == 0 || v60 <= v56 >> 2) && (!v55 || v60 < v54))
      {
        int v55 = v53;
        unint64_t v54 = v60;
      }
    }
LABEL_141:
    uint64_t v53 = (char **)(v52 + 8);
    uint64_t v52 = *(void *)(v52 + 8);
  }
  while (v52);
  if (v55)
  {
    int v9 = *v55;
    *int v55 = (char *)*((void *)*v55 + 1);
    long long v63 = *(_OWORD *)a3->i8;
    *(_DWORD *)int v9 = 1;
    *((_OWORD *)v9 + 2) = v63;
    __int16 v64 = *(_WORD *)(v9 + 75);
    if ((v64 & 0x40) != 0) {
      __int16 v65 = -6672;
    }
    else {
      __int16 v65 = -6800;
    }
    __int16 v66 = v65 & v64;
    *(_WORD *)(v9 + 75) = v66;
    v9[73] &= 0xC0u;
    int32x2_t v67 = vmin_s32(vadd_s32(a3[1], (int32x2_t)0x100000001), *(int32x2_t *)(v9 + 24));
    *((int32x2_t *)v9 + 23) = v67;
    if ((v64 & 0x40) == 0 || v67.i32[0] > *((_DWORD *)v9 + 48) || v67.i32[1] > *((_DWORD *)v9 + 49))
    {
      v66 &= 0xE5B0u;
      *(_WORD *)(v9 + 75) = v66;
    }
    *((float *)v9 + 16) = v21;
    *((_WORD *)v9 + 116) |= 0x40u;
    if (BYTE3(xmmword_1EB2ACC70))
    {
      uint64_t v68 = mach_continuous_time();
      __int16 v66 = *(_WORD *)(v9 + 75);
    }
    else
    {
      uint64_t v68 = 0;
    }
    *((void *)v9 + 7) = v68;
    *(_WORD *)(v9 + 75) = v66 | 0x2000;
    return v9;
  }
LABEL_153:
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  float32x2_t v70 = (char *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0xF0uLL, 0x743898A5uLL);
  int v9 = v70;
  *(_DWORD *)float32x2_t v70 = 1;
  __int16 v72 = *(_WORD *)(v70 + 75) | 0x10;
  *(_WORD *)(v70 + 75) = v72;
  *((_OWORD *)v70 + 2) = *(_OWORD *)a3->i8;
  *((_DWORD *)v70 + 6) = v31;
  *((_DWORD *)v70 + 7) = v32;
  __int32 v73 = a3[1].i32[0];
  if (v73 + 1 < v31) {
    int v74 = v73 + 1;
  }
  else {
    int v74 = v31;
  }
  *((_DWORD *)v70 + 46) = v74;
  __int32 v75 = a3[1].i32[1];
  if (v75 + 1 < v32) {
    int v76 = v75 + 1;
  }
  else {
    int v76 = v32;
  }
  *((_DWORD *)v70 + 47) = v76;
  *((_DWORD *)v70 + 17) = v51;
  v70[72] = v70[72] & 0xFE | v7 & 1;
  __int16 v77 = v7 & 0xF | (((v25 >> 6) & 1) << 8) | *((_WORD *)v70 + 116) & 0xFCC0;
  *(_WORD *)(v70 + 75) = v72 & 0xFF7F;
  *((_WORD *)v70 + 116) = v77;
  *((float *)v70 + 16) = v21;
  v70[74] = v70[74] & 0xE0 | CA::OGL::metal_pixel_format_Bpp((CA::OGL *)v22, v71);
  *((void *)v9 + 6) = *((void *)v8 + 386);
  if (v7 >= 1)
  {
    if (v31 <= v32) {
      int v78 = v32;
    }
    else {
      int v78 = v31;
    }
    uint64_t v79 = 0;
    unint64_t v99 = (unint64_t)(floor(log2((double)v78)) + 1.0);
    uint64_t v100 = 8 * v7;
    while (1)
    {
      float v80 = objc_msgSend(MEMORY[0x1E4F35330], "texture2DDescriptorWithPixelFormat:width:height:mipmapped:", v22, v31, v32, HIBYTE(*((unsigned __int16 *)v9 + 116)) & 1, Name, v98);
      [v80 setUsage:5];
      if ((v25 & 0x4000) != 0) {
        objc_msgSend(v80, "setUsage:", objc_msgSend(v80, "usage") | 2);
      }
      [v80 setProtectionOptions:*((void *)v9 + 6)];
      [v80 setStorageMode:2];
      if ((v25 & 0x80000) != 0) {
        [v80 setStorageMode:0];
      }
      if (v25 & 0x200 | *((_WORD *)v9 + 116) & 0x100) {
        [v80 setMipmapLevelCount:v99];
      }
      uint64_t v81 = (uint64_t)v8;
      float v82 = (void *)[*((id *)v8 + 369) newTextureWithDescriptor:v80];
      *(void *)&v9[v79 + 96] = v82;
      [v82 setLabel:@"com.apple.coreanimation.surface"];
      *(void *)&v9[v79 + 120] = v22;
      float v83 = *(void **)&v9[v79 + 96];
      if (!v83) {
        break;
      }
      uint64_t v84 = [*(id *)&v9[v79 + 96] protectionOptions];
      if (v84 != [v80 protectionOptions])
      {
        if (x_log_hook_p())
        {
          uint64_t Name = [v80 protectionOptions];
          uint64_t v98 = [v83 protectionOptions];
          x_log_();
        }
        else
        {
          float v85 = x_log_category_ogl_metal;
          if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR))
          {
            uint64_t v86 = [v80 protectionOptions];
            uint64_t v87 = [v83 protectionOptions];
            *(_DWORD *)buf = 134218240;
            *(void *)uint64_t v102 = v86;
            *(_WORD *)&v102[8] = 2048;
            uint64_t v103 = v87;
            _os_log_impl(&dword_184668000, v85, OS_LOG_TYPE_ERROR, "Descriptor (0x%llx) and texture (0x%llx) protection mismatch!", buf, 0x16u);
          }
        }
      }
      v79 += 8;
      uint64_t v8 = (CA::OGL::MetalContext *)v81;
      if (v100 == v79) {
        goto LABEL_177;
      }
    }
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      __int16 v89 = x_log_category_ogl_metal;
      if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)uint64_t v102 = v31;
        *(_WORD *)&v102[4] = 1024;
        *(_DWORD *)&v102[6] = v32;
        _os_log_impl(&dword_184668000, v89, OS_LOG_TYPE_ERROR, "Failed to allocate %dx%d surface texture.\n", buf, 0xEu);
      }
    }
    CA::OGL::MetalContext::finalize_surface(v81, (uint64_t)v9);
    return 0;
  }
LABEL_177:
  CA::OGL::MetalContext::add_memoryless_textures((uint64_t)v8, (uint64_t)v9);
  CA::OGL::MetalContext::add_path_buffer_texture((uint64_t)v8, (uint64_t)v9);
  uint64_t v88 = mach_continuous_time();
  *((void *)v9 + 28) = v88;
  if (!BYTE3(xmmword_1EB2ACC70)) {
    uint64_t v88 = 0;
  }
  *((void *)v9 + 7) = v88;
  return v9;
}

uint64_t CA::OGL::MetalContext::start_command_buffer(CA::OGL::MetalContext *this, uint64_t a2, const char *a3)
{
  v13[5] = *MEMORY[0x1E4F143B8];
  unint64_t v4 = (void *)*((void *)this + 372);
  if (v4)
  {
    if (objc_msgSend(*((id *)this + 372), "protectionOptions", a3) != a2) {
      [v4 setProtectionOptions:a2];
    }
    return 1;
  }
  else
  {
    id v7 = (id)objc_msgSend(*((id *)this + 370), "commandBuffer", a3);
    *((void *)this + 372) = v7;
    [v7 setLabel:@"com.apple.coreanimation.command-buffer"];
    uint64_t v8 = (void *)*((void *)this + 372);
    if (v8)
    {
      ++*((_DWORD *)this + 1022);
      [v8 setProtectionOptions:a2];
      if (*((void *)this + 27)) {
        objc_msgSend(v8, "setResponsibleTaskIDs:count:");
      }
      if ((*((unsigned char *)this + 2726) & 1) != 0 && *((void *)this + 10) && byte_1EB2ACC2A) {
        CA::OGL::MetalContext::mark_cache_drop_hints(this);
      }
      [*((id *)this + 372) enqueue];
      uint64_t v9 = *((void *)this + 505);
      uint64_t v5 = 1;
      *(void *)(v9 + 16) = atomic_fetch_add((atomic_ullong *volatile)this + 503, 1uLL) + 1;
      *(_DWORD *)(v9 + 40) = 0;
      int v10 = (void *)*((void *)this + 372);
      v13[0] = MEMORY[0x1E4F143A8];
      v13[1] = 3221225472;
      v13[2] = ___ZN2CA3OGL12MetalContext26prepare_new_command_bufferEv_block_invoke;
      _OWORD v13[3] = &__block_descriptor_40_e28_v16__0___MTLCommandBuffer__8l;
      uint64_t v13[4] = this;
      [v10 addCompletedHandler:v13];
    }
    else
    {
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        unint64_t v11 = x_log_category_ogl_metal;
        if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v13[0]) = 0;
          _os_log_impl(&dword_184668000, v11, OS_LOG_TYPE_ERROR, "Command buffer allocation failed!\n", (uint8_t *)v13, 2u);
        }
      }
      return 0;
    }
  }
  return v5;
}

uint64_t CA::OGL::metal_pixel_format_Bpp(CA::OGL *this, MTLPixelFormat a2)
{
  if ((uint64_t)this > 114)
  {
    if ((unint64_t)this - 550 < 2) {
      return 5;
    }
    if ((unint64_t)this - 552 >= 2 && this != (CA::OGL *)115) {
      return 4;
    }
    return 8;
  }
  if ((unint64_t)this <= 0x2B)
  {
    if (((1 << (char)this) & 0xA00C0000000) != 0) {
      return 2;
    }
    if (((1 << (char)this) & 0xC02) != 0) {
      return 1;
    }
  }
  if (this != (CA::OGL *)105)
  {
    if (this != (CA::OGL *)110) {
      return 4;
    }
    return 8;
  }
  return 16;
}

void *CA::OGL::add_primitive_filter(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v4 = *(void *)(a1 + 8);
    if (v4)
    {
      uint64_t v5 = 0;
      do
      {
        uint64_t v6 = v4;
        uint64_t v4 = *(void *)(v4 + 8);
        *(void *)(v6 + 8) = v5;
        uint64_t v5 = v6;
      }
      while (v4);
      *(void *)(a1 + 8) = v6;
    }
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  uint64_t result = malloc_type_zone_calloc(malloc_zone, 1uLL, 0x40uLL, 0x743898A5uLL);
  result[2] = a2;
  result[5] = *(void *)(a2 + 16);
  *uint64_t result = a1;
  return result;
}

uint64_t CA::OGL::anonymous namespace'::desired_src_edge_replication(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v11 = a1[70];
  if (v11)
  {
    unint64_t v12 = *(unsigned int *)(v11 + 16);
    if (v12)
    {
      if (*(unsigned char *)(*(void *)(v11 + 24) + 13)) {
        goto LABEL_17;
      }
      unint64_t v13 = 0;
      while (v12 - 1 != v13)
      {
        uint64_t v14 = *(void *)(v11 + 8 * v13++ + 32);
        if (*(unsigned char *)(v14 + 13))
        {
          if (v13 < v12) {
            goto LABEL_17;
          }
          break;
        }
      }
    }
  }
  if (a1[9] - a1[8] != 168) {
    return 0;
  }
  uint64_t v15 = *(void *)(a2 + 128);
  if (!v15) {
    return 0;
  }
  uint64_t v11 = *(void *)(v15 + 96);
  if (!v11) {
    return 0;
  }
  unint64_t v12 = *(unsigned int *)(v11 + 16);
  if (!v12) {
    return 0;
  }
  if ((*(unsigned char *)(*(void *)(v11 + 24) + 13) & 1) == 0)
  {
    unint64_t v16 = 0;
    while (v12 - 1 != v16)
    {
      uint64_t v17 = *(void *)(v11 + 8 * v16++ + 32);
      if (*(unsigned char *)(v17 + 13))
      {
        if (v16 >= v12) {
          return 0;
        }
        goto LABEL_17;
      }
    }
    return 0;
  }
LABEL_17:
  if (v12 <= 1) {
    unint64_t v12 = 1;
  }
  else {
    unint64_t v12 = v12;
  }
  for (__n128 i = (uint64_t *)(v11 + 24); ; ++i)
  {
    uint64_t v19 = *i;
    int v20 = *(_DWORD *)(*i + 24);
    if (v20 == 588 || v20 == 247) {
      break;
    }
    if (!--v12) {
      return 0;
    }
  }
  uint64_t v21 = *(void *)(v19 + 48);
  if (!v21 || !(*(unsigned int (**)(void))(*(void *)v21 + 72))(*(void *)(v19 + 48))) {
    return 0;
  }
  uint64_t v22 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v21 + 136);

  return v22(v21, v19, a2, a3, a4, a5, a6);
}

uint64_t CA::OGL::FilterSubclass::is_ogl_filter(CA::OGL::FilterSubclass *this)
{
  return 1;
}

uint64_t CA::OGL::GaussianBlurFilter::source_requirement(CA::OGL::GaussianBlurFilter *this, const CA::Render::Filter *a2)
{
  return 4;
}

void *CA::OGL::add_color_matrix(uint64_t a1, uint64_t a2, int a3, float32x4_t *a4, int *a5, int a6)
{
  uint64_t v9 = a1;
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  if ((vmaxvq_u8((uint8x16_t)vmvnq_s8(vuzp1q_s8((int8x16_t)vuzp1q_s16((int16x8_t)vceqq_f32(*a4, (float32x4_t)xmmword_184997DC0), (int16x8_t)vceqq_f32(a4[1], (float32x4_t)xmmword_184997DE0)), (int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_f32(a4[2]), (int16x8_t)vceqq_f32(a4[3], (float32x4_t)xmmword_184997DC0))))) & 1) == 0&& (vaddvq_s32((int32x4_t)vbicq_s8((int8x16_t)xmmword_184998120, (int8x16_t)vceqq_f32(a4[4], (float32x4_t)xmmword_184997DE0))) & 0xF) == 0)
  {
    return (void *)v9;
  }
  if (!a6 && (a4[1].f32[0] != 0.0 || a4[2].f32[1] != 0.0 || a4[3].f32[2] != 0.0) || a4[4].f32[3] != 0.0)
  {
    int v10 = *a5;
    if (*a5 <= 4) {
      int v10 = 4;
    }
    *a5 = v10;
  }
  if (!a1)
  {
LABEL_28:
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    uint64_t v22 = malloc_type_zone_calloc(malloc_zone, 1uLL, 0x40uLL, 0x743898A5uLL);
    uint64_t v23 = (malloc_zone_t *)get_malloc_zone();
    int v24 = malloc_type_zone_malloc(v23, 0x50uLL, 0x8BB15036uLL);
    v22[6] = v24;
    *int v24 = *a4;
    float32x4_t v25 = a4[4];
    float32x4_t v27 = a4[1];
    float32x4_t v26 = a4[2];
    v24[3] = a4[3];
    v24[4] = v25;
    v24[1] = v27;
    v24[2] = v26;
    v22[5] = *(void *)(a2 + 16);
    *((unsigned char *)v22 + 56) = a6;
    *uint64_t v22 = v9;
    return v22;
  }
  uint64_t v11 = *(const CA::ColorMatrix **)(a1 + 48);
  if (!v11)
  {
    uint64_t v15 = *(void *)(a1 + 16);
    if (!v15) {
      goto LABEL_24;
    }
    uint64_t v16 = *(void *)(v15 + 48);
    if (!v16) {
      goto LABEL_24;
    }
    if ((*(unsigned int (**)(uint64_t))(*(void *)v16 + 80))(v16)) {
      BOOL v17 = a6 == 0;
    }
    else {
      BOOL v17 = 1;
    }
    if (!v17)
    {
      __int16 v29 = (malloc_zone_t *)get_malloc_zone();
      int v30 = malloc_type_zone_malloc(v29, 0x50uLL, 0x8BB15036uLL);
      *(void *)(v9 + 48) = v30;
      *int v30 = *a4;
      float32x4_t v31 = a4[4];
      float32x4_t v33 = a4[1];
      float32x4_t v32 = a4[2];
      _OWORD v30[3] = a4[3];
      v30[4] = v31;
      v30[1] = v33;
      v30[2] = v32;
      *(unsigned char *)(v9 + 56) = a6;
      return (void *)v9;
    }
    uint64_t v11 = *(const CA::ColorMatrix **)(v9 + 48);
    if (!v11) {
      goto LABEL_24;
    }
  }
  if (*(unsigned __int8 *)(v9 + 56) != a6)
  {
LABEL_24:
    uint64_t v18 = *(void *)(v9 + 8);
    if (v18)
    {
      uint64_t v19 = 0;
      do
      {
        uint64_t v20 = v18;
        uint64_t v18 = *(void *)(v18 + 8);
        *(void *)(v20 + 8) = v19;
        uint64_t v19 = v20;
      }
      while (v18);
      *(void *)(v9 + 8) = v20;
    }
    goto LABEL_28;
  }
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v34 = 0u;
  CA::concat((CA *)&v34, (CA::ColorMatrix *)a4, v11, (const CA::ColorMatrix *)a4);
  long long v12 = v38;
  long long v13 = v36;
  *((_OWORD *)v11 + 3) = v37;
  *((_OWORD *)v11 + 4) = v12;
  long long v14 = v35;
  *(_OWORD *)uint64_t v11 = v34;
  *((_OWORD *)v11 + 1) = v14;
  *((_OWORD *)v11 + 2) = v13;
  if (!*(_DWORD *)(v9 + 40)) {
    *(void *)(v9 + 40) = *(void *)(a2 + 16);
  }
  return (void *)v9;
}

float CA::OGL::VariableBlurFilter::dirty_scale_factor(CA::OGL::VariableBlurFilter *this)
{
  return 5.6;
}

uint64_t CA::OGL::VariableBlurFilter::get_bounds(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  *a4 = *(_OWORD *)(a3 + 64);
  a4[1] = *(_OWORD *)(a3 + 80);
  return 1;
}

BOOL CA::ColorMatrix::is_opaque_identity(CA::ColorMatrix *this)
{
  return *((float *)this + 3) == 0.0
      && *((float *)this + 8) == 0.0
      && *((float *)this + 13) == 0.0
      && *((float *)this + 15) == 0.0
      && *((float *)this + 16) == 0.0
      && *((float *)this + 17) == 0.0
      && (float)(*((float *)this + 19) + *((float *)this + 18)) == 1.0;
}

float CA::concat(CA *this, CA::ColorMatrix *a2, const CA::ColorMatrix *a3, const CA::ColorMatrix *a4)
{
  float v5 = *((float *)a2 + 2);
  float v4 = *((float *)a2 + 3);
  float v7 = *((float *)a3 + 14);
  float v6 = *((float *)a3 + 15);
  float v8 = *((float *)a3 + 10);
  float v9 = *((float *)a3 + 11);
  float v10 = *((float *)a2 + 1);
  float v12 = *((float *)a3 + 4);
  float v11 = *((float *)a3 + 5);
  float v13 = *((float *)a3 + 1);
  *(float *)this = (float)((float)((float)(v6 * v4) + (float)(v8 * v5)) + (float)(v11 * v10))
                 + (float)(*(float *)a3 * *(float *)a2);
  float v15 = *((float *)a2 + 7);
  float v14 = *((float *)a2 + 8);
  float v17 = *((float *)a2 + 5);
  float v16 = *((float *)a2 + 6);
  float v18 = *((float *)a3 + 16);
  float v19 = *((float *)a3 + 17);
  float v20 = *((float *)a3 + 6);
  float v21 = *((float *)a3 + 7);
  float v22 = *(float *)a2;
  *((float *)this + 1) = (float)((float)((float)(v18 * v4) + (float)(v9 * v5)) + (float)(v20 * v10))
                       + (float)(v13 * *(float *)a2);
  float v23 = *(float *)a3;
  float v24 = *((float *)a3 + 1);
  float v25 = (float)((float)((float)(v14 * v6) + (float)(v15 * v8)) + (float)(v16 * v11)) + (float)(*(float *)a3 * v17);
  float v27 = *((float *)a2 + 12);
  float v26 = *((float *)a2 + 13);
  float v28 = *((float *)a3 + 12);
  float v29 = *((float *)a3 + 13);
  float v30 = *((float *)a2 + 1);
  float v31 = *((float *)a3 + 3);
  *((float *)this + 2) = (float)((float)((float)(v19 * v4) + (float)(v28 * v5)) + (float)(v21 * v30))
                       + (float)(*((float *)a3 + 2) * v22);
  float v32 = *((float *)a3 + 18);
  float v33 = *((float *)a3 + 19);
  float v34 = *((float *)a2 + 2);
  float v35 = *((float *)a3 + 8);
  float v36 = *((float *)a3 + 9);
  *((float *)this + 3) = (float)((float)((float)(v32 * v4) + (float)(v29 * v34)) + (float)(v35 * v30))
                       + (float)(v31 * v22);
  float v37 = (float)((float)((float)(*((float *)a2 + 4) + (float)(v33 * *((float *)a2 + 3))) + (float)(v7 * v34))
              + (float)(v36 * v30))
      + (float)(v12 * v22);
  float v39 = *((float *)a2 + 10);
  float v38 = *((float *)a2 + 11);
  *((float *)this + 4) = v37;
  *((float *)this + 5) = v25;
  float v41 = *((float *)a3 + 4);
  float v40 = *((float *)a3 + 5);
  float v42 = (float)((float)((float)(v26 * v6) + (float)(v27 * v8)) + (float)(v40 * v38)) + (float)(v39 * v23);
  float v43 = *((float *)a2 + 5);
  *((float *)this + 6) = (float)((float)((float)(v18 * v14) + (float)(v9 * v15)) + (float)(v20 * v16))
                       + (float)(v24 * v43);
  float v44 = *((float *)a2 + 6);
  float v45 = (float)((float)(v19 * v14) + (float)(v28 * v15)) + (float)(v44 * v21);
  float v46 = *((float *)a3 + 2);
  float v47 = *((float *)a3 + 3);
  *((float *)this + 7) = v45 + (float)(v46 * v43);
  float v48 = *((float *)a2 + 7);
  *((float *)this + 8) = (float)((float)((float)(v32 * v14) + (float)(v35 * v44)) + (float)(v48 * v29))
                       + (float)(v47 * v43);
  float v49 = (float)((float)((float)(*((float *)a2 + 9) + (float)(v7 * v48)) + (float)(v36 * v44))
              + (float)(*((float *)a2 + 8) * v33))
      + (float)(v41 * v43);
  *((float *)this + 10) = v42;
  float v51 = *((float *)a2 + 17);
  float v50 = *((float *)a2 + 18);
  float v52 = *((float *)a3 + 6);
  float v53 = *((float *)a3 + 7);
  float v54 = (float)((float)(v18 * v26) + (float)(v9 * v27)) + (float)(v52 * v38);
  float v55 = *((float *)a2 + 10);
  *((float *)this + 11) = v54 + (float)(v55 * v24);
  float v56 = *((float *)a3 + 11);
  float v57 = *((float *)a2 + 16);
  float v58 = (float)((float)((float)(v50 * v6) + (float)(*((float *)a3 + 10) * v51)) + (float)(v57 * v40))
      + (float)(*((float *)a2 + 15) * v23);
  float v59 = *((float *)a2 + 11);
  *((float *)this + 12) = (float)((float)((float)(v19 * v26) + (float)(v28 * v27)) + (float)(v46 * v55))
                        + (float)(v53 * v59);
  float v60 = v32 * v26;
  float v61 = *((float *)a2 + 12);
  *((float *)this + 9) = v49;
  float v62 = *((float *)a3 + 8);
  float v63 = *((float *)a3 + 9);
  *((float *)this + 13) = (float)((float)(v60 + (float)(v47 * v55)) + (float)(v61 * v29)) + (float)(v62 * v59);
  float v64 = (float)((float)((float)(*((float *)a2 + 14) + (float)(v7 * v61)) + (float)(v41 * v55))
              + (float)(*((float *)a2 + 13) * v33))
      + (float)(v63 * v59);
  *((float *)this + 15) = v58;
  float v65 = *((float *)a2 + 15);
  *((float *)this + 16) = (float)((float)((float)(v18 * v50) + (float)(v52 * v57)) + (float)(v56 * v51))
                        + (float)(v65 * v24);
  float v66 = *((float *)a2 + 16);
  float v67 = *((float *)a3 + 13);
  *((float *)this + 17) = (float)((float)((float)(v19 * v50) + (float)(v46 * v65)) + (float)(*((float *)a3 + 12) * v51))
                        + (float)(v66 * v53);
  float v68 = v32 * v50;
  float v69 = *((float *)a2 + 17);
  *((float *)this + 18) = (float)((float)(v68 + (float)(v47 * v65)) + (float)(v62 * v66)) + (float)(v67 * v69);
  *((float *)this + 14) = v64;
  float result = (float)((float)((float)(*((float *)a2 + 19) + (float)(v41 * v65)) + (float)(v63 * v66))
                 + (float)(*((float *)a2 + 18) * v33))
         + (float)(*((float *)a3 + 14) * v69);
  *((float *)this + 19) = result;
  return result;
}

BOOL CA::OGL::GaussianBlurFilter::can_append_color_matrix(CA::OGL::GaussianBlurFilter *this, CA::Render::KeyValueArray **a2, CA::OGL::Context *a3)
{
  return CA::Render::KeyValueArray::get_int_key(a2[5], 303, 0) == 0;
}

__n128 CA::OGL::Context::reuse_surface(uint64_t a1, uint64_t a2, __n128 *a3)
{
  __n128 result = *a3;
  *(__n128 *)(a2 + 32) = *a3;
  *(_WORD *)(a2 + 75) &= 0xFFF0u;
  return result;
}

uint64_t CA::WindowServer::IOMFBDisplay::actual_inverse_color(CA::WindowServer::IOMFBDisplay *this)
{
  return *((unsigned __int8 *)this + 28145);
}

uint64_t CA::OGL::VariableBlurFilter::source_requirement(CA::OGL::VariableBlurFilter *this, const CA::Render::Filter *a2)
{
  return 5;
}

uint64_t CA::OGL::Context::paint_region(uint64_t result, uint64_t a2, uint64_t *a3, int a4)
{
  uint64_t v7 = result;
  v30[122] = *MEMORY[0x1E4F143B8];
  if (*a3 || (*(_WORD *)(*(void *)(result + 264) + 75) & 0x60) == 0)
  {
    bzero(v30, 0x3D0uLL);
    uint64_t v25 = 0x3C003C003C003C00;
    uint64_t v26 = 0;
    uint64_t v27 = 0;
    uint64_t v28 = 0;
    uint64_t v29 = 0x4013F800000;
    v23[0] = 0;
    long long v24 = 0u;
    v23[1] = &CA::Shape::_infinite_shape;
    uint64_t v9 = *(void *)(v7 + 248);
    if (v9)
    {
      float v10 = *(const void **)(v7 + 16);
      memcpy(v30, v10, 0x1E8uLL);
      v30[0] = v10;
      *(void *)(v7 + 16) = v30;
      v23[0] = CA::OGL::Context::set_gstate(v7, (uint64_t)v23);
    }
    else
    {
      MEMORY[0x1F4188790](v8);
      bzero(v18, 0xF00uLL);
      *(void *)(v7 + 120) = v18;
      *(void *)(v7 + 136) = 80;
      CA::OGL::Context::prepare_context(v7, (uint64_t)v30);
      (*(void (**)(uint64_t, void *))(*(void *)v7 + 1008))(v7, v23);
    }
    uint64_t v12 = v7 + 16;
    uint64_t v11 = *(void *)(v7 + 16);
    if (a4)
    {
      *(unsigned char *)(v11 + 481) |= 1u;
      uint64_t v11 = *(void *)v12;
      *(unsigned char *)(*(void *)v12 + 480) = 3;
    }
    *(unsigned char *)(v11 + 16) = 0;
    *(void *)(v7 + 128) = 0;
    *(void *)(v7 + 96) = v7 + 834;
    long long v19 = xmmword_184997E70;
    *(_OWORD *)(v7 + 104) = xmmword_184997E70;
    v22[1] = 0;
    v22[2] = 0;
    uint64_t v21 = 0;
    v22[0] = a2;
    uint64_t v20 = 0;
    while (CA::ShapeIterator::iterate(v22, (int *)&v20))
    {
      if (*(_DWORD *)(v7 + 92)) {
        uint64_t v13 = 6;
      }
      else {
        uint64_t v13 = 4;
      }
      if ((unint64_t)(*(void *)(v7 + 128) + 4) > *(void *)(v7 + 136)
        || (unint64_t v14 = *(void *)(v7 + 112)) != 0 && *(void *)(v7 + 104) + v13 > v14)
      {
        *(_WORD *)(v7 + 832) |= 0x20u;
        CA::OGL::Context::array_flush(v7);
        *(void *)(v7 + 128) = 0;
        *(void *)(v7 + 96) = v7 + 834;
        *(_OWORD *)(v7 + 104) = v19;
      }
      CA::OGL::Context::array_rect((void *)v7, (float)(int)v20, (float)SHIDWORD(v20), (float)(v21 + v20), (float)(HIDWORD(v21) + HIDWORD(v20)));
      uint64_t v15 = *a3;
      uint64_t v16 = *(void *)(v7 + 120) + 48 * *(void *)(v7 + 128);
      *(void *)(v16 - 160) = *a3;
      *(void *)(v16 - 112) = v15;
      *(void *)(v16 - 64) = v15;
      *(void *)(v16 - 16) = v15;
    }
    CA::OGL::Context::array_flush(v7);
    if (v9)
    {
      __n128 result = CA::OGL::Context::set_gstate(v7, **(void **)(v7 + 248));
      *(void *)(v7 + 16) = v30[0];
      v30[0] = 0;
    }
    else
    {
      __n128 result = (*(uint64_t (**)(uint64_t, void *))(*(void *)v7 + 1016))(v7, v23);
      *(void *)uint64_t v12 = 0;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 120) = 0;
      *(void *)(v7 + 136) = 0;
    }
    for (uint64_t i = 61; i != -61; i -= 61)
    {
      if (v30[i]) {
        __assert_rtn("~ContextState", "ogl-context.h", 551, "!next && \"Imbalanced ContextState push/pop\"");
      }
    }
  }
  return result;
}

CATransform3D *__cdecl CATransform3DMakeAffineTransform(CATransform3D *__return_ptr retstr, CATransform3D *m)
{
  retstr->m13 = 0.0;
  retstr->m14 = 0.0;
  *(_OWORD *)&retstr->m31 = 0u;
  *(_OWORD *)&retstr->m33 = xmmword_184997D50;
  long long v2 = *(_OWORD *)&m->m13;
  *(_OWORD *)&retstr->m11 = *(_OWORD *)&m->m11;
  *(_OWORD *)&retstr->m21 = v2;
  *(_OWORD *)&retstr->m23 = 0u;
  *(_OWORD *)&retstr->m41 = *(_OWORD *)&m->m21;
  *(_OWORD *)&retstr->m43 = xmmword_184997D60;
  return m;
}

void ___ZN2CA3OGL12MetalContext24start_idle_collect_timerEv_block_invoke(uint64_t a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = mach_absolute_time();
  if (CATimeWithHostTime(v2) <= *(double *)(v1 + 4008) + 0.5) {
    return;
  }
  uint64_t v3 = *(CA::OGL::MetalBufferPool **)(v1 + 4040);
  unint64_t v4 = atomic_load((unint64_t *)(v1 + 4032));
  CA::OGL::MetalBufferPool::pool_flush(v3, v4, 0);
  uint64_t v5 = *(void *)(v1 + 4040);
  os_unfair_lock_lock((os_unfair_lock_t)(v5 + 56));
  float v6 = *(void ***)(v5 + 248);
  uint64_t v7 = *(void ***)(v5 + 256);
  if (v7 == v6)
  {
    uint64_t v11 = (void *)(v5 + 280);
    uint64_t v7 = *(void ***)(v5 + 248);
  }
  else
  {
    unint64_t v8 = *(void *)(v5 + 272);
    uint64_t v9 = &v6[v8 >> 9];
    float v10 = (void **)((char *)*v9 + 8 * (v8 & 0x1FF));
    uint64_t v11 = (void *)(v5 + 280);
    uint64_t v12 = *(uint64_t *)((char *)v6 + (((*(void *)(v5 + 280) + v8) >> 6) & 0x3FFFFFFFFFFFFF8))
        + 8 * ((*(void *)(v5 + 280) + v8) & 0x1FF);
    if (v10 != (void **)v12)
    {
      do
      {
        uint64_t v13 = *v10;
        float v18 = *v10;
        if (*(void *)(v5 + 328) > 0x3FuLL)
        {
        }
        else
        {
          objc_msgSend(v13, "setPurgeableState:", 3, v18, v19);
          std::deque<objc_object  {objcproto9MTLBuffer}*>::push_back((void *)(v5 + 288), &v18);
        }
        if ((char *)++v10 - (unsigned char *)*v9 == 4096)
        {
          unint64_t v14 = (void **)v9[1];
          ++v9;
          float v10 = v14;
        }
      }
      while (v10 != (void **)v12);
      float v6 = *(void ***)(v5 + 248);
      uint64_t v7 = *(void ***)(v5 + 256);
    }
  }
  *uint64_t v11 = 0;
  unint64_t v15 = (char *)v7 - (char *)v6;
  if (v15 >= 0x11)
  {
    do
    {
      operator delete(*v6);
      uint64_t v16 = *(void *)(v5 + 256);
      float v6 = (void **)(*(void *)(v5 + 248) + 8);
      *(void *)(v5 + 248) = v6;
      unint64_t v15 = v16 - (void)v6;
    }
    while (v15 > 0x10);
  }
  if (v15 >> 3 == 1)
  {
    uint64_t v17 = 256;
    goto LABEL_19;
  }
  if (v15 >> 3 == 2)
  {
    uint64_t v17 = 512;
LABEL_19:
    *(void *)(v5 + 272) = v17;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(v5 + 56));

  CA::OGL::MetalContext::stop_idle_collect_timer((CA::OGL::MetalContext *)v1);
}

void sub_184699EF0(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void *CA::OGL::MetalBufferPool::alloc_fragment_arg(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unsigned int v13 = 0;
  float v6 = CA::OGL::MetalBufferPool::alloc_bytes((CA::OGL::MetalBufferPool *)a1, a3, a4, 0, &v13);
  if (v6)
  {
    uint64_t v7 = *(void *)(a1 + 8);
    uint64_t v8 = a1 + 8 * a2;
    uint64_t v10 = *(void *)(v8 + 112);
    uint64_t v9 = (void *)(v8 + 112);
    uint64_t v11 = *(void *)(a1 + 192);
    if (v10 == v7)
    {
      (*(void (**)(uint64_t, char *, void, uint64_t))(a1 + 224))(v11, sel_setFragmentBufferOffset_atIndex_, v13, a2);
    }
    else
    {
      (*(void (**)(uint64_t, char *, void, void, uint64_t))(a1 + 208))(v11, sel_setFragmentBuffer_offset_atIndex_, *(void *)(a1 + 8), v13, a2);
      *uint64_t v9 = v7;
    }
  }
  return v6;
}

void *CA::OGL::MetalBufferPool::alloc_vertex_arg(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unsigned int v13 = 0;
  float v6 = CA::OGL::MetalBufferPool::alloc_bytes((CA::OGL::MetalBufferPool *)a1, a3, a4, 0, &v13);
  if (v6)
  {
    uint64_t v7 = *(void *)(a1 + 8);
    uint64_t v8 = a1 + 8 * a2;
    uint64_t v10 = *(void *)(v8 + 64);
    uint64_t v9 = (void *)(v8 + 64);
    uint64_t v11 = *(void *)(a1 + 192);
    if (v10 == v7)
    {
      (*(void (**)(uint64_t, char *, void, uint64_t))(a1 + 216))(v11, sel_setVertexBufferOffset_atIndex_, v13, a2);
    }
    else
    {
      (*(void (**)(uint64_t, char *, void, void, uint64_t))(a1 + 200))(v11, sel_setVertexBuffer_offset_atIndex_, *(void *)(a1 + 8), v13, a2);
      *uint64_t v9 = v7;
    }
  }
  return v6;
}

void *CA::OGL::MetalBufferPool::alloc_bytes(CA::OGL::MetalBufferPool *this, unsigned int a2, unsigned int a3, void *a4, unsigned int *a5)
{
  if ((a3 & (a3 - 1)) != 0) {
    __assert_rtn("get_buffer", "ogl-metal.mm", 3197, "x_power_of_two (alignment)");
  }
  uint64_t v9 = (void *)((char *)this + 24);
  uint64_t v10 = *((void *)this + 1);
  if (v10)
  {
    unsigned int v11 = *((_DWORD *)this + 11);
    if (v11 <= a3) {
      unsigned int v11 = a3;
    }
    int v12 = *((_DWORD *)this + 6);
    unsigned int v13 = *((_DWORD *)this + 7);
    unsigned int v14 = (v11 + v12 - 1) & -v11;
    if (v13 != v14 && v13 >= v14 + a2 || v12 == 0) {
      goto LABEL_15;
    }
    CA::OGL::MetalBufferPool::retire_metal_buffer((uint64_t)this, v10);
    *((void *)this + 1) = 0;
    *uint64_t v9 = 0;
    v9[1] = 0;
  }
  __n128 result = CA::OGL::MetalBufferPool::allocate_buffer((os_unfair_lock_s *)this, a2);
  *((void *)this + 1) = result;
  if (!result) {
    return result;
  }
  ++*((_DWORD *)this + 10);
  *((void *)this + 4) = [result contents];
  int v18 = [*((id *)this + 1) length];
  unsigned int v14 = 0;
  *((_DWORD *)this + 7) = v18;
LABEL_15:
  *(_DWORD *)uint64_t v9 = v14 + a2;
  if (a4) {
    *a4 = *((void *)this + 1);
  }
  if (a5) {
    *a5 = v14;
  }
  return (void *)(*((void *)this + 4) + v14);
}

uint64_t CA::OGL::MetalContext::encode_noise_scale(CA::OGL::MetalContext *this, const CA::OGL::MetalContext::FragmentShader::Spec *a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  int v3 = *(_DWORD *)(*((void *)this + 33) + 120);
  if (v3 > 93)
  {
    if ((v3 - 550) < 6)
    {
      float v4 = 0.0039216;
      goto LABEL_14;
    }
    if (v3 != 94)
    {
      if (v3 == 115)
      {
        float v4 = 0.00012207;
        goto LABEL_14;
      }
      goto LABEL_13;
    }
LABEL_12:
    float v4 = 0.001955;
    goto LABEL_14;
  }
  if (v3 == 41 || v3 == 43)
  {
    float v4 = 0.064516;
    goto LABEL_14;
  }
  if (v3 == 90) {
    goto LABEL_12;
  }
LABEL_13:
  float v4 = 0.0078431;
LABEL_14:
  _S8 = *(float *)(*((void *)this + 2) + 352) * v4;
  if (*((float *)this + 853) == _S8) {
    return 1;
  }
  __asm { FCVT            H0, S8 }
  __int16 __src = _H0;
  uint64_t result = CA::OGL::MetalBufferPool::encode_fragment_arg(*((CA::OGL::MetalBufferPool **)this + 505), 5, &__src, 2u, 2u);
  if (result) {
    *((float *)this + 853) = _S8;
  }
  return result;
}

uint64_t CA::OGL::MetalContext::encode_edr_resolve(CA::OGL::MetalContext *this, const CA::OGL::MetalContext::FragmentShader::Spec *a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *((void *)this + 2);
  float v4 = 1.0;
  if (*(unsigned char *)(v3 + 305)) {
    float v4 = *(float *)(v3 + 312);
  }
  _S8 = powf(*(float *)(*((void *)this + 33) + 64) * v4, 1.0 / *((float *)this + 38));
  if (*((float *)this + 854) == _S8) {
    return 1;
  }
  __asm { FCVT            H0, S8 }
  __int16 __src = _H0;
  uint64_t result = CA::OGL::MetalBufferPool::encode_fragment_arg(*((CA::OGL::MetalBufferPool **)this + 505), 6, &__src, 2u, 2u);
  if (result) {
    *((float *)this + 854) = _S8;
  }
  return result;
}

uint64_t CA::OGL::MetalBufferPool::encode_fragment_arg(CA::OGL::MetalBufferPool *this, uint64_t a2, const void *__src, unsigned int a4, unsigned int a5)
{
  if ((a5 & (a5 - 1)) != 0) {
    __assert_rtn("get_buffer", "ogl-metal.mm", 3197, "x_power_of_two (alignment)");
  }
  uint64_t v9 = *((void *)this + 1);
  if (v9)
  {
    unsigned int v10 = *((_DWORD *)this + 11);
    if (v10 <= a5) {
      unsigned int v10 = a5;
    }
    int v11 = *((_DWORD *)this + 6);
    unsigned int v12 = *((_DWORD *)this + 7);
    unsigned int v13 = (v10 + v11 - 1) & -v10;
    if (v12 != v13 && v12 >= v13 + a4 || v11 == 0) {
      goto LABEL_15;
    }
    uint64_t v16 = (void *)((char *)this + 24);
    CA::OGL::MetalBufferPool::retire_metal_buffer((uint64_t)this, v9);
    *((void *)this + 1) = 0;
    *uint64_t v16 = 0;
    *((void *)this + 4) = 0;
  }
  uint64_t result = (uint64_t)CA::OGL::MetalBufferPool::allocate_buffer((os_unfair_lock_s *)this, a4);
  *((void *)this + 1) = result;
  if (!result) {
    return result;
  }
  ++*((_DWORD *)this + 10);
  *((void *)this + 4) = [(id)result contents];
  unsigned int v13 = 0;
  *((_DWORD *)this + 7) = [*((id *)this + 1) length];
LABEL_15:
  if (__src) {
    memcpy((void *)(*((void *)this + 4) + v13), __src, a4);
  }
  *((_DWORD *)this + 6) = v13 + a4;
  uint64_t v18 = *((void *)this + 1);
  uint64_t v19 = (char *)this + 8 * a2;
  uint64_t v21 = *((void *)v19 + 14);
  uint64_t v20 = v19 + 112;
  uint64_t v22 = *((void *)this + 24);
  if (v21 == v18)
  {
    (*((void (**)(uint64_t, char *, void, uint64_t))this + 28))(v22, sel_setFragmentBufferOffset_atIndex_, v13, a2);
  }
  else
  {
    (*((void (**)(uint64_t, char *, void, void, uint64_t))this + 26))(v22, sel_setFragmentBuffer_offset_atIndex_, *((void *)this + 1), v13, a2);
    void *v20 = v18;
  }
  return 1;
}

void *CA::OGL::MetalBufferPool::allocate_buffer(os_unfair_lock_s *this, unsigned int a2)
{
  LODWORD(v2) = a2;
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (a2 <= 0x40000)
  {
    os_unfair_lock_lock(this + 14);
    uint64_t v4 = *(void *)&this[70]._os_unfair_lock_opaque;
    if (v4)
    {
      uint64_t v5 = v4 - 1;
      float v6 = *(void **)(*(void *)(*(void *)&this[62]._os_unfair_lock_opaque
                                + (((unint64_t)(*(void *)&this[68]._os_unfair_lock_opaque + v5) >> 6) & 0x3FFFFFFFFFFFFF8))
                    + 8 * ((*(void *)&this[68]._os_unfair_lock_opaque + v5) & 0x1FF));
      *(void *)&this[70]._os_unfair_lock_opaque = v5;
      std::deque<objc_object  {objcproto9MTLBuffer}*>::__maybe_remove_back_spare[abi:nn180100](&this[60]._os_unfair_lock_opaque);
      os_unfair_lock_unlock(this + 14);
      if (v6) {
        return v6;
      }
    }
    else
    {
      uint64_t v7 = *(void *)&this[82]._os_unfair_lock_opaque;
      if (v7)
      {
        uint64_t v8 = v7 - 1;
        float v6 = *(void **)(*(void *)(*(void *)&this[74]._os_unfair_lock_opaque
                                  + (((unint64_t)(*(void *)&this[80]._os_unfair_lock_opaque + v8) >> 6) & 0x3FFFFFFFFFFFFF8))
                      + 8 * ((*(void *)&this[80]._os_unfair_lock_opaque + v8) & 0x1FF));
        *(void *)&this[82]._os_unfair_lock_opaque = v8;
        std::deque<objc_object  {objcproto9MTLBuffer}*>::__maybe_remove_back_spare[abi:nn180100](&this[72]._os_unfair_lock_opaque);
        os_unfair_lock_unlock(this + 14);
        if (v6)
        {
          [v6 setPurgeableState:2];
          return v6;
        }
      }
      else
      {
        os_unfair_lock_unlock(this + 14);
      }
    }
  }
  if (v2 <= 0x40000) {
    uint64_t v2 = 0x40000;
  }
  else {
    uint64_t v2 = v2;
  }
  uint64_t v9 = (void *)[*(id *)&this->_os_unfair_lock_opaque newBufferWithLength:v2 options:0];
  if (v9)
  {
    float v6 = v9;
    [v9 setLabel:@"com.apple.coreanimation.buffer"];
  }
  else
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      unsigned int v10 = x_log_category_ogl_metal;
      if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        int v13 = v2;
        _os_log_impl(&dword_184668000, v10, OS_LOG_TYPE_ERROR, "Failed to allocate %u-byte Metal buffer\n", buf, 8u);
      }
    }
    return 0;
  }
  return v6;
}

void std::deque<objc_object  {objcproto9MTLBuffer}*>::__maybe_remove_back_spare[abi:nn180100](void *a1)
{
  uint64_t v2 = a1[1];
  uint64_t v1 = a1[2];
  if (v1 == v2) {
    uint64_t v3 = 0;
  }
  else {
    uint64_t v3 = ((v1 - v2) << 6) - 1;
  }
  if ((unint64_t)(v3 - (a1[5] + a1[4])) >= 0x400)
  {
    operator delete(*(void **)(v1 - 8));
    a1[2] -= 8;
  }
}

uint64_t CA::OGL::render_subclass(CA::OGL::Renderer &,CA::OGL::Layer const*)::visitor::visit_subclass(uint64_t a1, uint64_t a2, double *a3)
{
  uint64_t v86 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v5 = **(void ***)(a1 + 8);
  uint64_t v6 = v5[31];
  uint64_t v7 = *(void *)(v4 + 24);
  uint64_t v8 = *(void *)(v7 + 72);
  v82.f64[0] = *(float64_t *)(v7 + 64);
  *(void *)&v82.f64[1] = v8;
  float64_t v9 = *(double *)(v7 + 88);
  v83.f64[0] = *(float64_t *)(v7 + 80);
  v83.f64[1] = v9;
  v80.f64[0] = v82.f64[0];
  *(void *)&v80.f64[1] = v8;
  v81.f64[0] = v83.f64[0];
  v81.f64[1] = v9;
  CA::Rect::apply_transform((int8x16_t *)&v80, *(const CA::Transform **)(v6 + 24), a3);
  int64x2_t v10 = vceqzq_f64(v81);
  if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v10, 1), (int8x16_t)v10).u64[0] & 0x8000000000000000) != 0
    || (int8x16_t v11 = vorrq_s8((int8x16_t)vcltzq_f64(v81), (int8x16_t)vcgezq_f64(v81)),
        (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v11), 1), v11).u64[0] & 0x8000000000000000) != 0))
  {
    int32x4_t v71 = 0uLL;
  }
  else
  {
    int32x4_t v12 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v80, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
    int32x4_t v71 = vuzp1q_s32(v12, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v80, v81), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v12));
  }
  uint64_t result = CA::Shape::intersects(*(void *)(v6 + 8), (int32x2_t *)&v71);
  if (result)
  {
    unint64_t v15 = *(float64x2_t **)(v6 + 24);
    uint64_t v16 = CA::OGL::transform_filter_bits(v15, v14, 1.0, 1.0);
    v17.i64[0] = 1.0;
    float64x2_t v68 = v83;
    int v19 = CA::OGL::rect_filter_bits(v15, v16, v18, v82, v83, v17, 1.0);
    BOOL v20 = (*((unsigned char *)v5 + 433) & 0x40) == 0
       && (*(unsigned int (**)(void *, uint64_t))(*v5 + 184))(v5, 23) != 0;
    uint64_t v79 = 0;
    uint64_t result = (uint64_t)CA::Render::GradientLayer::color_map((char *)&v79, a2, v20);
    uint64_t v21 = v79;
    if (v79)
    {
      uint64_t result = (*(uint64_t (**)(atomic_uint *))(*(void *)v79 + 80))(v79);
      if (!result) {
        goto LABEL_64;
      }
      uint64_t v22 = result;
      int v23 = *(_DWORD *)(a2 + 104);
      BOOL v24 = v23 == 453;
      if (v23 == 117) {
        BOOL v24 = 1;
      }
      uint64_t v25 = (double *)(v24 ? 528647 : 4359);
      float32x4_t v85 = 0uLL;
      uint64_t result = (uint64_t)CA::OGL::Context::bind_image((uint64_t)v5, 0, (uint32x2_t *)result, v25, 1u, 1, v23 == 117, 0, 0.0, &v85, 0);
      if (!result) {
        goto LABEL_64;
      }
      uint64_t v26 = result;
      short float v27 = *(short float *)(v6 + 38);
      if (v27 == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
      {
        int v28 = *(_DWORD *)(a2 + 12);
        if ((v28 & 0x800) != 0)
        {
          if ((v28 & 0x1000) != 0)
          {
LABEL_20:
            unsigned int v29 = *(unsigned __int8 *)(v5[2] + 480);
            if (v29 > 3 || v29 == 2) {
              int v30 = 0;
            }
            else {
              int v30 = 0x8000;
            }
            int v31 = 1;
LABEL_27:
            unint64_t v32 = *(unsigned int *)(v6 + 32) | ((unint64_t)*(unsigned __int16 *)(v6 + 36) << 32);
            if ((v19 & 9) != 0 && (*(_WORD *)(v4 + 40) & 0x3C0) != 0 || (*(unsigned char *)(v4 + 32) & 0x10) != 0) {
              int v31 = 0;
            }
            v85.f32[3] = (float)(v85.f32[3] + v85.f32[1]) * 0.5;
            v85.i32[1] = v85.i32[3];
            uint64_t v33 = v5[2];
            unsigned int v34 = *(unsigned __int8 *)(v33 + 480);
            if (v34 >= 2 && (v34 != 3 || (v31 & 1) == 0))
            {
              *(unsigned char *)(v33 + 481) |= 1u;
              uint64_t v33 = v5[2];
            }
            *(_DWORD *)(v33 + 8) = v32;
            *(_WORD *)(v33 + 12) = WORD2(v32);
            *(short float *)(v33 + 14) = v27;
            float32x4_t v84 = 0uLL;
            int v67 = v31;
            if (v23 == 453)
            {
              float64x2_t v40 = *(float64x2_t *)(a2 + 72);
              float64x2_t v41 = vcvtq_f64_f32(vcvt_f32_f64(vmulq_f64(vsubq_f64(*(float64x2_t *)(a2 + 88), v40), v68)));
              __asm { FMOV            V2.2D, #-1.0 }
              float32x4_t v84 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(vmulq_f64(v68, v40), v41)), vdivq_f64(vmulq_f64(vaddq_f64(v40, _Q2), v68), v41));
              uint64_t v43 = v5[2];
              char v44 = 1;
            }
            else
            {
              if (v23 != 117)
              {
                if (v23 == 51)
                {
                  __asm { FMOV            V0.2S, #1.0 }
                  v84.i64[1] = _D0;
                }
LABEL_42:
                unsigned int v45 = (*(uint64_t (**)(uint64_t))(*(void *)v22 + 104))(v22);
                unsigned int v46 = (v45 < 0x1D) & (0x17826000u >> v45);
                if (v46 == 1)
                {
                  int v47 = *(_DWORD *)(a2 + 108);
                  *(unsigned char *)(v5[2] + 481) |= 2u;
                  *(_DWORD *)(v5[2] + 352) = v47;
                }
                int v48 = (*(unsigned __int16 *)(v4 + 40) >> 6);
                uint64_t v49 = *(void *)(v6 + 24);
                v71.i64[0] = (uint64_t)&v82;
                v71.i64[1] = v49;
                int v72 = v30 | v19;
                int v73 = v48;
                uint64_t v75 = 0;
                uint64_t v76 = 0;
                uint64_t v77 = a2;
                int v78 = &v85;
                uint64_t v50 = *(void *)(v4 + 24);
                uint64_t v51 = *(void *)(v50 + 128);
                float v52 = 0.0;
                if (v51)
                {
                  uint64_t v53 = *(void *)(v51 + 72);
                  if (v53)
                  {
                    CA::OGL::fill_uneven_round_rect_tex((CA::OGL::Context *)v5, (uint64_t)&v71, (float64_t *)(v53 + 24), (uint64_t)&v84, *(_DWORD *)(v50 + 40) & 3);
                    if (!v46) {
                      goto LABEL_60;
                    }
                    goto LABEL_59;
                  }
                  uint64_t v54 = *(void *)(v51 + 56);
                  if (v54)
                  {
                    float v55 = (uint32x2_t *)(*(uint64_t (**)(uint64_t, double))(*(void *)v54 + 80))(v54, 0.0);
                    uint64_t v56 = *(void *)(v4 + 24);
                    uint64_t v57 = *(void *)(v56 + 128);
                    if (v57)
                    {
                      uint64_t v58 = *(void *)(v57 + 64);
                      if (v58)
                      {
                        if (*(_DWORD *)(v58 + 16) > 3u)
                        {
                          float64x2_t v62 = vsubq_f64(*(float64x2_t *)(v58 + 40), *(float64x2_t *)(v58 + 24));
                          long long v69 = *(_OWORD *)(v58 + 24);
                          float64x2_t v70 = v62;
                        }
                        else
                        {
                          long long v69 = 0u;
                          float64x2_t v70 = 0u;
                        }
                      }
                      else
                      {
                        __asm { FMOV            V0.2D, #0.5 }
                        long long v69 = _Q0;
                        float64x2_t v70 = 0uLL;
                      }
                      float v60 = *(float *)(v57 + 228);
                    }
                    else
                    {
                      __asm { FMOV            V0.2D, #0.5 }
                      long long v69 = _Q0;
                      float64x2_t v70 = 0uLL;
                      float v60 = 0.0;
                    }
                    CA::OGL::fill_corner_rect_tex((CA::OGL::Context *)v5, (double **)&v71, v55, (double *)&v69, *(_DWORD *)(*(void *)(v4 + 16) + 24) & 1, (*(void *)(v56 + 40) >> 41) & 1, (uint64_t)&v84, *(_WORD *)(v56 + 38) & 0xF, v60, v60, 0);
                    if (!v46) {
                      goto LABEL_60;
                    }
LABEL_59:
                    *(unsigned char *)(v5[2] + 481) &= ~2u;
LABEL_60:
                    *(unsigned char *)(v5[2] + 19) = 0;
                    *(unsigned char *)(v5[2] + 481) &= ~1u;
                    (*(void (**)(void *, uint64_t, void))(*v5 + 520))(v5, v26, 0);
                    uint64_t v65 = *(void *)(*(void *)(v4 + 24) + 144);
                    if (v65) {
                      uint64_t v66 = (*(void *)(v65 + 96) >> 53) & 7;
                    }
                    else {
                      LODWORD(v66) = 0;
                    }
                    uint64_t result = CA::OGL::fill_color_rect((uint64_t)v5, (uint64_t)&v82, v19, 0, v67 ^ 1u, v66, v63, v64);
LABEL_64:
                    if (atomic_fetch_add(v21 + 2, 0xFFFFFFFF) == 1) {
                      return (*(uint64_t (**)(atomic_uint *))(*(void *)v21 + 16))(v21);
                    }
                    return result;
                  }
                  float v52 = *(float *)(v51 + 228);
                }
                CA::OGL::fill_round_rect_tex((CA::OGL::Context *)v5, (float64x2_t **)&v71, (uint64_t)&v84, (double *)(*(_WORD *)(v50 + 38) & 0xF), *(_DWORD *)(v50 + 40) & 3, 0, v52, v52);
                if (!v46) {
                  goto LABEL_60;
                }
                goto LABEL_59;
              }
              float32x4_t v84 = (float32x4_t)xmmword_184997FF0;
              uint64_t v43 = v5[2];
              char v44 = 2;
            }
            *(unsigned char *)(v43 + 19) = v44;
            goto LABEL_42;
          }
        }
        else if ((*(_DWORD *)(a2 + 28) & 0x800) != 0)
        {
          goto LABEL_20;
        }
      }
      int v31 = 0;
      int v30 = 0;
      goto LABEL_27;
    }
  }
  return result;
}

uint64_t CA::OGL::maybe_concatenate(CA::OGL *this, CA::Transform *a2, const CA::Transform *a3, const double *a4)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  if ((*((unsigned char *)this + 144) & 0x10) != 0
    && (*((unsigned char *)a2 + 144) & 0x10) != 0
    && !CA::Mat4Impl::mat4_is_affine(this, (const double *)a2)
    && !CA::Mat4Impl::mat4_is_affine(a2, v6))
  {
    if (CA::Mat4Impl::mat4_is_affine_with_z_translate(a2, v7))
    {
      long long v11 = *((_OWORD *)a2 + 1);
      long long v12 = *((_OWORD *)a2 + 2);
      long long v13 = *((_OWORD *)a2 + 3);
      long long v37 = *(_OWORD *)a2;
      long long v38 = v11;
      long long v39 = v12;
      long long v40 = v13;
      long long v14 = *((_OWORD *)a2 + 5);
      long long v15 = *((_OWORD *)a2 + 6);
      long long v16 = *((_OWORD *)a2 + 7);
      long long v41 = *((_OWORD *)a2 + 4);
      long long v42 = v14;
      long long v43 = v15;
      uint64_t v45 = *((void *)&v16 + 1);
      uint64_t v44 = 0;
LABEL_13:
      uint64_t v8 = 1;
      CA::Transform::set((uint64_t)&v46, (CA::Mat4Impl *)&v37, 1);
      int v31 = (float64x2_t *)&v46;
      unint64_t v32 = this;
LABEL_17:
      CA::Transform::concat(v32, v31, v29, v30);
      return v8;
    }
    if (CA::Mat4Impl::mat4_is_affine_with_z_translate(this, v10))
    {
      long long v18 = *((_OWORD *)this + 1);
      long long v19 = *((_OWORD *)this + 2);
      long long v20 = *((_OWORD *)this + 3);
      long long v46 = *(_OWORD *)this;
      long long v47 = v18;
      long long v48 = v19;
      long long v49 = v20;
      long long v21 = *((_OWORD *)this + 5);
      long long v22 = *((_OWORD *)this + 6);
      long long v23 = *((_OWORD *)this + 7);
      long long v50 = *((_OWORD *)this + 4);
      long long v51 = v21;
      long long v52 = v22;
      uint64_t v54 = *((void *)&v23 + 1);
      uint64_t v53 = 0;
    }
    else
    {
      if (CA::Mat4Impl::mat4_is_fixed_z_with_z_translate(a2, v17))
      {
        long long v25 = *((_OWORD *)a2 + 1);
        long long v26 = *((_OWORD *)a2 + 2);
        long long v27 = *((_OWORD *)a2 + 3);
        long long v37 = *(_OWORD *)a2;
        long long v38 = v25;
        long long v39 = v26;
        long long v40 = v27;
        long long v28 = *((_OWORD *)a2 + 7);
        long long v43 = *((_OWORD *)a2 + 6);
        uint64_t v45 = *((void *)&v28 + 1);
        uint64_t v44 = 0;
        long long v41 = 0uLL;
        long long v42 = xmmword_184997D50;
        goto LABEL_13;
      }
      if (!CA::Mat4Impl::mat4_is_fixed_z_with_z_translate(this, v24)) {
        return 0;
      }
      long long v33 = *((_OWORD *)this + 1);
      long long v34 = *((_OWORD *)this + 2);
      long long v35 = *((_OWORD *)this + 3);
      long long v46 = *(_OWORD *)this;
      long long v47 = v33;
      long long v48 = v34;
      long long v49 = v35;
      long long v36 = *((_OWORD *)this + 7);
      long long v52 = *((_OWORD *)this + 6);
      uint64_t v54 = *((void *)&v36 + 1);
      uint64_t v53 = 0;
      long long v50 = 0uLL;
      long long v51 = xmmword_184997D50;
    }
    uint64_t v8 = 1;
    CA::Transform::set((uint64_t)this, (CA::Mat4Impl *)&v46, 1);
    unint64_t v32 = this;
    int v31 = (float64x2_t *)a2;
    goto LABEL_17;
  }
  CA::Transform::concat(this, (float64x2_t *)a2, (uint64_t)a3, a4);
  return 1;
}

float64x2_t CA::Transform::concat(uint64_t a1, uint64_t a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if ((*(unsigned char *)(a2 + 32) & 0xF) != 0)
  {
    CA::Transform::set((CA::Transform *)v14, a2);
    result.f64[0] = CA::Transform::concat((CA::Transform *)a1, v14, v3, v4);
  }
  else
  {
    result.f64[0] = *(float64_t *)a2;
    if ((*(unsigned char *)(a1 + 144) & 0x10) != 0)
    {
      result.f64[1] = *(float64_t *)(a2 + 8);
      float64x2_t v7 = *(float64x2_t *)(a1 + 16);
      float64x2_t v8 = *(float64x2_t *)(a1 + 48);
      float64x2_t v9 = *(float64x2_t *)(a1 + 80);
      float64x2_t v10 = *(float64x2_t *)(a1 + 112);
      float64x2_t v11 = vmlaq_laneq_f64(*(float64x2_t *)(a1 + 32), result, v8, 1);
      float64x2_t v12 = vmlaq_laneq_f64(*(float64x2_t *)(a1 + 64), result, v9, 1);
      float64x2_t v13 = vmlaq_laneq_f64(*(float64x2_t *)(a1 + 96), result, v10, 1);
      *(float64x2_t *)a1 = vmlaq_laneq_f64(*(float64x2_t *)a1, result, v7, 1);
      *(float64x2_t *)(a1 + 16) = vmlaq_laneq_f64(v7, (float64x2_t)0, v7, 1);
      *(float64x2_t *)(a1 + 32) = v11;
      *(float64x2_t *)(a1 + 48) = vmlaq_laneq_f64(v8, (float64x2_t)0, v8, 1);
      *(float64x2_t *)(a1 + 64) = v12;
      *(float64x2_t *)(a1 + 80) = vmlaq_laneq_f64(v9, (float64x2_t)0, v9, 1);
      *(float64x2_t *)(a1 + 96) = v13;
      *(float64x2_t *)(a1 + 112) = vmlaq_laneq_f64(v10, (float64x2_t)0, v10, 1);
    }
    else
    {
      double v6 = *(double *)(a1 + 104);
      *(double *)(a1 + 96) = *(double *)(a1 + 96) + result.f64[0];
      result.f64[0] = v6 + *(double *)(a2 + 8);
      *(float64_t *)(a1 + 104) = result.f64[0];
    }
  }
  return result;
}

float64_t CA::Transform::concat(CA::Transform *this, float64x2_t *a2, uint64_t a3, const double *a4)
{
  char v4 = *((unsigned char *)this + 144);
  if ((v4 & 0x10) != 0) {
    goto LABEL_6;
  }
  if ((LOBYTE(a2[9].f64[0]) & 0x10) != 0)
  {
    __asm { FMOV            V0.2D, #1.0 }
    *((_OWORD *)this + 8) = _Q0;
    *((unsigned char *)this + 144) = v4 & 0xE0 | 0x10;
LABEL_6:
    *(void *)&v11.f64[0] = *(_OWORD *)&CA::Mat4Impl::mat4_concat((float64x2_t *)this, (double *)this, a2->f64, a4);
    return v11.f64[0];
  }
  if ((LOBYTE(a2[9].f64[0]) & 0xF) != 0) {
    float64x2_t v5 = vmlaq_n_f64(vmulq_n_f64(*a2, *((double *)this + 12)), a2[2], *((double *)this + 13));
  }
  else {
    float64x2_t v5 = *((float64x2_t *)this + 6);
  }
  float64x2_t v11 = vaddq_f64(v5, a2[6]);
  *((float64x2_t *)this + 6) = v11;
  char v12 = LOBYTE(a2[9].f64[0]);
  char v13 = v12;
  if ((v12 & 8) != 0)
  {
    float64x2_t v11 = vmulq_f64(*((float64x2_t *)this + 8), a2[8]);
    *((float64x2_t *)this + 8) = v11;
    char v4 = v4 & 0xF7 | (8 * (v11.f64[0] != 1.0));
    *((unsigned char *)this + 144) = v4;
    char v13 = LOBYTE(a2[9].f64[0]);
  }
  int v14 = concat_table[v4 & 7 | (8 * (v13 & 7))];
  if ((v4 & 7) == v14)
  {
    if ((v12 & 8) == 0) {
      return v11.f64[0];
    }
  }
  else
  {
    *((unsigned char *)this + 144) = v4 & 0xF8 | v14 & 7;
  }
  v11.f64[0] = CA::Transform::set_2x2(this);
  return v11.f64[0];
}

double CA::Transform::set(CA::Transform *this, uint64_t a2)
{
  *(_OWORD *)this = xmmword_184997D50;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = xmmword_184997D60;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = xmmword_184997D50;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = xmmword_184997D60;
  *((_OWORD *)this + 6) = *(_OWORD *)a2;
  *((_OWORD *)this + 8) = *(_OWORD *)(a2 + 16);
  char v2 = *((unsigned char *)this + 144) & 0xF8 | *(unsigned char *)(a2 + 32) & 7;
  *((unsigned char *)this + 144) = v2;
  *((unsigned char *)this + 144) = v2 & 0xE7 | *(unsigned char *)(a2 + 32) & 8;
  return CA::Transform::set_2x2(this);
}

uint64_t CA::OGL::render_solid_background(CA::OGL::Context *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v164 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *((void *)this + 31);
  float16x4_t v9 = *(float16x4_t *)(v8 + 32);
  if (*(void *)&v9 == 0x3C003C003C003C00)
  {
    if (*(void *)a3) {
      goto LABEL_6;
    }
  }
  else
  {
    float16x4_t v10 = vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16(v9), vcvtq_f32_f16(*(float16x4_t *)a3)));
    *(float16x4_t *)a3 = v10;
    if (v10) {
      goto LABEL_6;
    }
  }
  uint64_t result = CA::OGL::Context::need_transparent_source(this);
  if (!result) {
    return result;
  }
LABEL_6:
  char v12 = *(float64x2_t **)(a2 + 24);
  uint64_t v13 = (uint64_t)&v12[4];
  float64x2_t v14 = v12[5];
  float64x2_t v160 = v12[4];
  float64x2_t v161 = v14;
  CA::Rect::apply_transform((int8x16_t *)&v160, *(const CA::Transform **)(v8 + 24), (double *)a3);
  int64x2_t v15 = vceqzq_f64(v161);
  unint64_t v16 = vorrq_s8((int8x16_t)vdupq_laneq_s64(v15, 1), (int8x16_t)v15).u64[0];
  float64x2_t v143 = v160;
  float64x2_t v144 = v161;
  if ((v16 & 0x8000000000000000) != 0
    || (int8x16_t v17 = vorrq_s8((int8x16_t)vcltzq_f64(v161), (int8x16_t)vcgezq_f64(v161)),
        (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v17), 1), v17).u64[0] & 0x8000000000000000) != 0))
  {
    int32x4_t v154 = 0uLL;
  }
  else
  {
    int32x4_t v18 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v160, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
    int32x4_t v154 = vuzp1q_s32(v18, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v160, v161), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v18));
  }
  uint64_t result = CA::Shape::intersects(*(void *)(v8 + 8), (int32x2_t *)&v154);
  if (result)
  {
    long long v20 = *(float64x2_t **)(v8 + 24);
    uint64_t v21 = CA::OGL::transform_filter_bits(v20, v19, 1.0, 1.0);
    v22.i64[0] = 1.0;
    int v24 = CA::OGL::rect_filter_bits(v20, v21, v23, v12[4], v12[5], v22, 1.0);
    int v30 = v24;
    if (a4)
    {
      uint64_t v31 = *(void *)(a2 + 24);
      int v32 = *(_DWORD *)(v31 + 36);
      if ((v32 & 0xFu) > 0xA) {
        unsigned int v33 = 1;
      }
      else {
        unsigned int v33 = CA::OGL::texture_filter(CA::Render::ImageFilter)::filters[v32 & 0xF];
      }
      unsigned int v142 = v33;
      uint64_t v38 = v32 >> 4;
      if (v38 > 0xA) {
        int v39 = 1;
      }
      else {
        int v39 = CA::OGL::texture_filter(CA::Render::ImageFilter)::filters[v38];
      }
      int v141 = v39;
      uint64_t v40 = *(void *)(v31 + 128);
      if (v40) {
        float v41 = *(float *)(v40 + 292);
      }
      else {
        float v41 = 0.0;
      }
      uint64_t v140 = *(void *)(*(void *)(a2 + 16) + 24);
      if ((*(_DWORD *)(a4 + 12) & 0x300) == 0x100
        && (*(unsigned int (**)(CA::OGL::Context *, void, uint64_t))(*(void *)this + 608))(this, *(void *)(a4 + 128), 1))
      {
        if ((*((_DWORD *)this + 108) & 2) != 0) {
          unsigned int v55 = v30 ^ 0x800;
        }
        else {
          unsigned int v55 = v30;
        }
        if (v140) {
          uint64_t v56 = (double *)(v55 ^ 0x800);
        }
        else {
          uint64_t v56 = (double *)v55;
        }
        int32x4_t v163 = 0uLL;
        float64x2_t v162 = 0uLL;
        uint64_t v57 = CA::OGL::Context::bind_image((uint64_t)this, 0, *(uint32x2_t **)(a4 + 128), v56, v142, v141, 1, 0, v41, (float32x4_t *)&v163, 0);
        if (!v57)
        {
          int v68 = 0;
LABEL_139:
          uint64_t v117 = 0;
          goto LABEL_140;
        }
        BOOL v59 = 0;
        if (*(short float *)(a3 + 6) == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
        {
          uint64_t v58 = *(void *)(a4 + 128);
          if (v58)
          {
            if ((*(unsigned char *)(v58 + 13) & 0x10) != 0
              && *(double *)(a4 + 96) <= *(double *)(a4 + 80)
              && *(double *)(a4 + 104) <= *(double *)(a4 + 88))
            {
              BOOL v59 = 1;
            }
          }
        }
        if ((v56 & 9) != 0 && (*(_WORD *)(a2 + 40) & 0x3C0) != 0 || (*(unsigned char *)(a2 + 32) & 0x10) != 0) {
          BOOL v59 = 0;
        }
        uint64_t v60 = *((void *)this + 2);
        unsigned int v61 = *(unsigned __int8 *)(v60 + 480);
        int v139 = v30;
        if (v61 >= 2 && (v61 != 3 || !v59))
        {
          *(unsigned char *)(v60 + 481) |= 1u;
          uint64_t v60 = *((void *)this + 2);
        }
        *(void *)(v60 + 8) = *(void *)a3;
        uint64_t v62 = *(void *)(a2 + 24);
        uint64_t v63 = *(void *)(v62 + 128);
        *(void *)&v144.f64[0] = v57;
        LODWORD(v143.f64[0]) = v59;
        if (v63) {
          float64x2_t v64 = *(float64x2_t *)(v63 + 152);
        }
        else {
          float64x2_t v64 = 0uLL;
        }
        CA::OGL::pattern_texcoords((float64x2_t *)a4, (float *)v163.i32, (uint64_t)&v162, v12[4], v12[5], v64);
        int v102 = (*(unsigned __int16 *)(a2 + 40) >> 6);
        float64_t v103 = *(double *)(v8 + 24);
        v154.i64[0] = (uint64_t)&v12[4];
        *(float64_t *)&v154.i64[1] = v103;
        int v155 = (int)v56;
        int v156 = v102;
        uint64_t v158 = 0;
        uint64_t v159 = 0;
        uint64_t v157 = 0;
        float v104 = 0.0;
        if (v63)
        {
          uint64_t v105 = *(void *)(v63 + 72);
          if (v105)
          {
            CA::OGL::fill_uneven_round_rect_tex(this, (uint64_t)&v154, (float64_t *)(v105 + 24), (uint64_t)&v162, *(_DWORD *)(v62 + 40) & 3);
            int v30 = v139;
            goto LABEL_138;
          }
          uint64_t v106 = *(void *)(v63 + 56);
          if (v106)
          {
            uint64_t v107 = (uint32x2_t *)(*(uint64_t (**)(uint64_t, double))(*(void *)v106 + 80))(v106, 0.0);
            uint64_t v108 = *(void *)(a2 + 24);
            uint64_t v109 = *(void *)(v108 + 128);
            int v30 = v139;
            if (v109)
            {
              uint64_t v110 = *(void *)(v109 + 64);
              if (v110)
              {
                if (*(_DWORD *)(v110 + 16) > 3u)
                {
                  float64x2_t v128 = vsubq_f64(*(float64x2_t *)(v110 + 40), *(float64x2_t *)(v110 + 24));
                  long long v152 = *(_OWORD *)(v110 + 24);
                  float64x2_t v153 = v128;
                }
                else
                {
                  long long v152 = 0u;
                  float64x2_t v153 = 0u;
                }
              }
              else
              {
                __asm { FMOV            V0.2D, #0.5 }
                long long v152 = _Q0;
                float64x2_t v153 = 0uLL;
              }
              float v124 = *(float *)(v109 + 228);
            }
            else
            {
              __asm { FMOV            V0.2D, #0.5 }
              long long v152 = _Q0;
              float64x2_t v153 = 0uLL;
              float v124 = 0.0;
            }
            CA::OGL::fill_corner_rect_tex(this, (double **)&v154, v107, (double *)&v152, *(_DWORD *)(*(void *)(a2 + 16) + 24) & 1, (*(void *)(v108 + 40) >> 41) & 1, (uint64_t)&v162, *(_WORD *)(v108 + 38) & 0xF, v124, v124, 0);
            goto LABEL_138;
          }
          float v104 = *(float *)(v63 + 228);
        }
        int v30 = v139;
        CA::OGL::fill_round_rect_tex(this, (float64x2_t **)&v154, (uint64_t)&v162, (double *)(*(_WORD *)(v62 + 38) & 0xF), *(_DWORD *)(v62 + 40) & 3, 0, v104, v104);
LABEL_138:
        *(unsigned char *)(*((void *)this + 2) + 481) &= ~1u;
        (*(void (**)(CA::OGL::Context *, void, void))(*(void *)this + 520))(this, *(void *)&v144.f64[0], 0);
        int v68 = LODWORD(v143.f64[0]) ^ 1;
        goto LABEL_139;
      }
      if ((*(unsigned char *)(a2 + 32) & 0x10) == 0 && ((*(_WORD *)(a2 + 40) & 0x3C0) == 0 || (v30 & 9) == 0))
      {
        long long v65 = *(_OWORD *)(a4 + 32);
        long long v149 = *(_OWORD *)(a4 + 16);
        long long v150 = v65;
        long long v151 = *(_OWORD *)(a4 + 48);
        if (CGAffineTransformIsRectilinear())
        {
          *(void *)(*((void *)this + 2) + 8) = *(void *)a3;
          if (*(short float *)(a3 + 6) == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
          {
            uint64_t v66 = *(void *)(a4 + 128);
            char v67 = v140;
            int v68 = !v66
               || (*(unsigned char *)(v66 + 13) & 0x10) == 0
               || *(double *)(a4 + 96) > *(double *)(a4 + 80)
               || *(double *)(a4 + 104) > *(double *)(a4 + 88);
          }
          else
          {
            int v68 = 1;
            char v67 = v140;
          }
          uint64_t v113 = *((void *)this + 2);
          unsigned int v114 = *(unsigned __int8 *)(v113 + 480);
          if (v114 >= 2 && (v114 != 3 || v68)) {
            *(unsigned char *)(v113 + 481) |= 1u;
          }
          uint64_t v115 = *(void *)(*(void *)(a2 + 24) + 128);
          if (v115) {
            int32x4_t v116 = *(int32x4_t *)(v115 + 152);
          }
          else {
            int32x4_t v116 = 0uLL;
          }
          int32x4_t v154 = v116;
          CA::OGL::fill_pattern_rect((uint64_t)this, a4, v13, (float64x2_t *)&v154, *(void *)(*((void *)this + 31) + 24), &v160, v142, v141, v41, v67 & 1, 0);
          uint64_t v117 = 0;
          *(unsigned char *)(*((void *)this + 2) + 481) &= ~1u;
          goto LABEL_140;
        }
      }
      if ((v16 & 0x8000000000000000) != 0
        || (int8x16_t v69 = vorrq_s8((int8x16_t)vcltzq_f64(v144), (int8x16_t)vcgezq_f64(v144)),
            (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v69), 1), v69).u64[0] & 0x8000000000000000) != 0))
      {
        int32x4_t v163 = 0uLL;
      }
      else
      {
        int32x4_t v70 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v143, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
        int32x4_t v163 = vuzp1q_s32(v70, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v143, v144), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v70));
      }
      uint64_t v71 = CA::Shape::intersect(*(CA::Shape **)(v8 + 8), (const CA::Bounds *)&v163);
      CA::Shape::get_bounds(v71, v163.i32);
      uint64_t v72 = (*(uint64_t (**)(CA::OGL::Context *, uint64_t, int32x4_t *, uint64_t))(*(void *)this + 656))(this, 1, &v163, 15);
      if (!v72)
      {
LABEL_129:
        CA::Shape::unref((CA::Shape *)v71);
        int v68 = 1;
        uint64_t v117 = 1;
LABEL_140:
        int v126 = v68 != 0;
        goto LABEL_141;
      }
      int v73 = (_DWORD *)v72;
      MEMORY[0x1F4188790](v72);
      uint64_t v134 = 0x3C003C003C003C00;
      uint64_t v137 = 0;
      uint64_t v138 = 0;
      uint64_t v135 = 0;
      uint64_t v136 = 0;
      long long v132 = *(_OWORD *)(v8 + 8);
      uint64_t v133 = *(void *)(v8 + 24);
      LODWORD(v138) = *(_DWORD *)(v8 + 64);
      WORD2(v138) = *(_WORD *)(v8 + 68) & 0x500 | 4;
      *(void *)&v144.f64[0] = v71;
      uint64_t v131 = 0;
      *(void *)&long long v132 = v71;
      uint64_t v131 = CA::OGL::Context::set_gstate((uint64_t)this, (uint64_t)&v131);
      CA::OGL::Context::push_surface((uint64_t)this, (uint64_t)v73, 1u, 2, 0);
      *(void *)(*((void *)this + 2) + 8) = 0x3C003C003C003C00;
      int v79 = (*(unsigned __int16 *)(a2 + 40) >> 6);
      float64_t v80 = *(double *)(v8 + 24);
      v154.i64[0] = v13;
      *(float64_t *)&v154.i64[1] = v80;
      int v155 = v30;
      int v156 = v79;
      uint64_t v158 = 0;
      uint64_t v159 = 0;
      uint64_t v157 = 0;
      uint64_t v81 = *(void *)(a2 + 24);
      uint64_t v82 = *(void *)(v81 + 128);
      float v83 = 0.0;
      if (v82)
      {
        uint64_t v84 = *(void *)(v82 + 72);
        int v85 = v141;
        if (v84)
        {
          CA::OGL::fill_uneven_round_rect(this, (uint64_t)&v154, (double *)(v84 + 24), (double *)(*(_DWORD *)(v81 + 40) & 3), 0.0, v74, v75, v76, v77, v78);
          goto LABEL_123;
        }
        uint64_t v86 = *(void *)(v82 + 56);
        if (v86)
        {
          uint64_t v87 = (double *)(*(uint64_t (**)(uint64_t, double))(*(void *)v86 + 80))(v86, 0.0);
          uint64_t v88 = *(void *)(a2 + 24);
          uint64_t v89 = *(void *)(v88 + 128);
          if (v89)
          {
            uint64_t v90 = *(void *)(v89 + 64);
            if (v90)
            {
              if (*(_DWORD *)(v90 + 16) > 3u)
              {
                float64x2_t v118 = vsubq_f64(*(float64x2_t *)(v90 + 40), *(float64x2_t *)(v90 + 24));
                long long v147 = *(_OWORD *)(v90 + 24);
                float64x2_t v148 = v118;
              }
              else
              {
                long long v147 = 0u;
                float64x2_t v148 = 0u;
              }
            }
            else
            {
              __asm { FMOV            V0.2D, #0.5 }
              long long v147 = _Q0;
              float64x2_t v148 = 0uLL;
            }
            float v101 = *(float *)(v89 + 228);
          }
          else
          {
            __asm { FMOV            V0.2D, #0.5 }
            long long v147 = _Q0;
            float64x2_t v148 = 0uLL;
            float v101 = 0.0;
          }
          CA::OGL::fill_corner_rect((uint64_t)this, (double **)&v154, v87, (double *)&v147, *(_DWORD *)(*(void *)(a2 + 16) + 24) & 1, (*(void *)(v88 + 40) >> 41) & 1, *(_WORD *)(v88 + 38) & 0xF, v101, v101);
          goto LABEL_123;
        }
        float v83 = *(float *)(v82 + 228);
      }
      else
      {
        int v85 = v141;
      }
      CA::OGL::fill_round_rect((uint64_t)this, (float64x2_t **)&v154, (double *)(*(_WORD *)(v81 + 38) & 0xF), (double *)(*(_DWORD *)(v81 + 40) & 3), v83, v83);
LABEL_123:
      *(unsigned char *)(*((void *)this + 2) + 481) |= 1u;
      *(void *)(*((void *)this + 2) + 8) = *(void *)a3;
      uint64_t v119 = *(void *)(*(void *)(a2 + 24) + 128);
      if (v119) {
        float64x2_t v120 = *(float64x2_t *)(v119 + 152);
      }
      else {
        float64x2_t v120 = 0uLL;
      }
      float64x2_t v162 = v120;
      CA::OGL::fill_pattern_rect((uint64_t)this, a4, v13, &v162, *(void *)(*((void *)this + 31) + 24), &v160, v142, v85, v41, v140 & 1, 0);
      *(unsigned char *)(*((void *)this + 2) + 481) &= ~1u;
      CA::OGL::Context::pop_surface(this);
      CA::OGL::Context::set_gstate((uint64_t)this, **((void **)this + 31));
      uint64_t v121 = *((void *)this + 2);
      if (*(unsigned __int8 *)(v121 + 480) >= 2u) {
        *(unsigned char *)(v121 + 481) |= 1u;
      }
      float v122 = *(CA::Shape **)(v8 + 8);
      float64x2_t v162 = 0uLL;
      CA::OGL::emit_combine((uint64_t)this, 1u, v73, 0, v122, (unsigned int *)&v162);
      *(unsigned char *)(*((void *)this + 2) + 481) &= ~1u;
      CA::OGL::Context::release_surface((uint64_t)this, (uint64_t)v73);
      uint64_t v71 = *(void *)&v144.f64[0];
      goto LABEL_129;
    }
    short float v34 = *(short float *)(a3 + 6);
    *(short float *)&double v25 = COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0));
    BOOL v35 = v34 == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0));
    if (v34 == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))
      && (unint64_t v36 = *(char *)(*((void *)this + 2) + 480), v36 <= 3))
    {
      int v37 = dword_184998860[v36];
    }
    else
    {
      int v37 = 0;
    }
    if ((v24 & 9) != 0 && (*(_WORD *)(a2 + 40) & 0x3C0) != 0 || (*(unsigned char *)(a2 + 32) & 0x10) != 0) {
      BOOL v35 = 0;
    }
    uint64_t v42 = *(void *)(*(void *)(a2 + 24) + 128);
    double v43 = 0.0;
    if (v42)
    {
      LODWORD(v25) = *(_DWORD *)(v42 + 228);
      LODWORD(v43) = LODWORD(v25);
    }
    double v44 = *(float *)&v43;
    uint64_t v45 = *(void *)(a2 + 104);
    if (v45)
    {
      double v43 = 0.0;
      if ((*(unsigned char *)(v45 + 222) & 0x20) != 0) {
        double v44 = 0.0;
      }
    }
    uint64_t v46 = *((void *)this + 2);
    unsigned int v47 = *(unsigned __int8 *)(v46 + 480);
    if (v47 >= 2 && (v47 != 3 || !v35))
    {
      *(unsigned char *)(v46 + 481) |= 1u;
      uint64_t v46 = *((void *)this + 2);
    }
    *(void *)(v46 + 8) = *(void *)a3;
    int v48 = (*(unsigned __int16 *)(a2 + 40) >> 6);
    float64_t v49 = *(double *)(v8 + 24);
    v154.i64[0] = v13;
    *(float64_t *)&v154.i64[1] = v49;
    int v155 = v37 | v24;
    int v156 = v48;
    uint64_t v158 = 0;
    uint64_t v159 = 0;
    uint64_t v157 = 0;
    uint64_t v50 = *(void *)(a2 + 24);
    uint64_t v51 = *(void *)(v50 + 128);
    if (v51)
    {
      uint64_t v52 = *(void *)(v51 + 72);
      if (v52)
      {
        CA::OGL::fill_uneven_round_rect(this, (uint64_t)&v154, (double *)(v52 + 24), (double *)(*(_DWORD *)(v50 + 40) & 3), v43, v25, v26, v27, v28, v29);
LABEL_133:
        uint64_t v117 = 0;
        *(unsigned char *)(*((void *)this + 2) + 481) &= ~1u;
        int v126 = !v35;
LABEL_141:
        uint64_t v129 = *(void *)(*(void *)(a2 + 24) + 144);
        if (v129) {
          uint64_t v130 = (*(void *)(v129 + 96) >> 53) & 7;
        }
        else {
          LODWORD(v130) = 0;
        }
        return CA::OGL::fill_color_rect((uint64_t)this, v13, v30, (double *)v117, v126, v130, v53, v54);
      }
      uint64_t v91 = *(void *)(v51 + 56);
      if (v91)
      {
        __int16 v92 = (double *)(*(uint64_t (**)(uint64_t))(*(void *)v91 + 80))(v91);
        uint64_t v93 = *(void *)(a2 + 24);
        uint64_t v94 = *(void *)(v93 + 128);
        if (v94 && (uint64_t v95 = *(void *)(v94 + 64)) != 0)
        {
          if (*(_DWORD *)(v95 + 16) > 3u)
          {
            float64x2_t v125 = vsubq_f64(*(float64x2_t *)(v95 + 40), *(float64x2_t *)(v95 + 24));
            long long v145 = *(_OWORD *)(v95 + 24);
            float64x2_t v146 = v125;
          }
          else
          {
            long long v145 = 0u;
            float64x2_t v146 = 0u;
          }
        }
        else
        {
          __asm { FMOV            V0.2D, #0.5 }
          long long v145 = _Q0;
          float64x2_t v146 = 0uLL;
        }
        CA::OGL::fill_corner_rect((uint64_t)this, (double **)&v154, v92, (double *)&v145, *(_DWORD *)(*(void *)(a2 + 16) + 24) & 1, (*(void *)(v93 + 40) >> 41) & 1, *(_WORD *)(v93 + 38) & 0xF, v44, v44);
        goto LABEL_133;
      }
    }
    CA::OGL::fill_round_rect((uint64_t)this, (float64x2_t **)&v154, (double *)(*(_WORD *)(v50 + 38) & 0xF), (double *)(*(_DWORD *)(v50 + 40) & 3), v44, v44);
    goto LABEL_133;
  }
  return result;
}

uint64_t CA::OGL::ContentsGeometry::ContentsGeometry(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v172 = *MEMORY[0x1E4F143B8];
  int v12 = *(_DWORD *)(a4 + 16);
  *(_DWORD *)a1 = v12;
  int v13 = *(_DWORD *)(a4 + 20);
  *(void *)(a1 + 8) = 0;
  uint64_t v14 = a1 + 8;
  *(_DWORD *)(a1 + 4) = v13;
  *(void *)(a1 + 16) = 0;
  *(double *)(a1 + 24) = (double)v12;
  *(double *)(a1 + 32) = (double)v13;
  int64x2_t v15 = (CA::Transform *)(a1 + 104);
  __n128 v16 = CA::Transform::operator=(a1 + 104, *(void *)(a3 + 24));
  *(void *)(a1 + 256) = 0x3FF0000000000000;
  uint64_t v17 = *(void *)(a2 + 24);
  uint64_t v18 = *(void *)(v17 + 128);
  if (v18)
  {
    v16.n128_u32[0] = *(_DWORD *)(v18 + 284);
  }
  else
  {
    v16.n128_u8[0] = *(unsigned char *)(v17 + 34);
    v16.n128_f32[0] = (float)v16.n128_u32[0];
  }
  *(double *)(a1 + 264) = v16.n128_f32[0];
  *(unsigned char *)(a1 + 272) = 1;
  *(_DWORD *)(a1 + 308) = 0;
  *(_DWORD *)(a1 + 312) = (*(unsigned __int16 *)(a2 + 40) >> 6);
  *(_DWORD *)(a1 + 316) = -1082130432;
  *(unsigned char *)(a1 + 336) = (*(uint64_t (**)(uint64_t))(*(void *)a4 + 112))(a4);
  *(unsigned char *)(a1 + 337) = 0;
  uint64_t v21 = *(void *)(a2 + 24);
  *(unsigned char *)(a1 + 338) = (*(_DWORD *)(v21 + 40) & 0x8000) != 0;
  *(unsigned char *)(a1 + 339) = (*(void *)(v21 + 40) & 0x4000) == 0;
  *(unsigned char *)(a1 + 340) = 0;
  uint64_t v22 = *(void *)(v21 + 128);
  float v23 = 0.0;
  if (v22) {
    float v23 = *(float *)(v22 + 228);
  }
  double v24 = v23;
  *(double *)(a1 + 424) = v24;
  *(double *)(a1 + 432) = v24;
  *(unsigned char *)(a1 + 491) = 0;
  *(unsigned char *)(a1 + 492) = (*(_DWORD *)(*(void *)(a2 + 16) + 24) & 0x400) != 0;
  *(_WORD *)(a1 + 493) = 0;
  *(unsigned char *)(a1 + 495) = 0;
  *(unsigned char *)(a1 + 496) = *(void *)(a4 + 48) == 0;
  __asm { FMOV            V16.2D, #1.0 }
  if (*(unsigned char *)(a5 + 12) == 50)
  {
    *(unsigned char *)(a1 + 494) = 1;
    int32x2_t v30 = *(int32x2_t *)(a5 + 24);
    v31.i64[0] = v30.i32[0];
    v31.i64[1] = v30.i32[1];
    __asm { FMOV            V3.2D, #1.0 }
    float64x2_t v33 = vdivq_f64(_Q3, *(float64x2_t *)(a1 + 24));
    float64x2_t v34 = vmulq_f64(vcvtq_f64_s64(v31), v33);
    *(float32x2_t *)(a1 + 416) = vcvt_f32_f64(v34);
    _Q3.f64[0] = *(float64_t *)(a5 + 32);
    v31.i64[0] = SLODWORD(_Q3.f64[0]);
    v31.i64[1] = SHIDWORD(_Q3.f64[0]);
    float64x2_t v35 = vcvtq_f64_s64(v31);
    *(float32x2_t *)(a1 + 408) = vcvt_f32_f64(vmulq_f64(v35, v33));
    float64x2_t v36 = vcvtq_f64_f32(vdiv_f32((float32x2_t)0x3F0000003F000000, vcvt_f32_u32(*(uint32x2_t *)(a4 + 16))));
    int32x2_t v37 = vadd_s32(*(int32x2_t *)&_Q3.f64[0], v30);
    v31.i64[0] = v37.i32[0];
    v31.i64[1] = v37.i32[1];
    *(float32x2_t *)(a1 + 392) = vcvt_f32_f64(vaddq_f64(v34, v36));
    *(float32x2_t *)(a1 + 400) = vcvt_f32_f64(vmlaq_f64(vnegq_f64(v36), v33, vcvtq_f64_s64(v31)));
    *(unsigned char *)(a1 + 491) = 1;
    *(float64_t *)a1 = _Q3.f64[0];
    *(void *)uint64_t v14 = 0;
    *(void *)(v14 + 8) = 0;
    *(float64x2_t *)(a1 + 24) = v35;
    uint64_t v21 = *(void *)(a2 + 24);
  }
  uint64_t v171 = 0;
  v163[0] = (int8x16_t)xmmword_184997D50;
  v163[1] = 0u;
  long long v164 = xmmword_184997D60;
  long long v165 = 0u;
  long long v166 = 0u;
  long long v167 = xmmword_184997D50;
  long long v168 = 0u;
  long long v169 = xmmword_184997D60;
  int8x16_t v170 = _Q16;
  if ((*(unsigned char *)(v21 + 42) & 2) != 0) {
    *(_DWORD *)(a1 + 308) |= 0x200u;
  }
  unsigned int v38 = *(_DWORD *)(a4 + 12);
  if ((v38 & 0x400) != 0) {
    *(int8x16_t *)(a1 + 24) = vextq_s8(*(int8x16_t *)(a1 + 24), *(int8x16_t *)(a1 + 24), 8uLL);
  }
  if ((v38 & 0x4000) != 0)
  {
    int v39 = *(__int16 *)(a4 + 24);
    __int16 v40 = *(_WORD *)(a4 + 26);
    if (*(_DWORD *)(a4 + 24))
    {
LABEL_17:
      unsigned int v41 = *(_DWORD *)(a4 + 16);
      unsigned int v42 = *(_DWORD *)(a4 + 20);
      float v43 = 1.0 / (float)v41;
      float v44 = 1.0 / (float)v42;
      int v45 = v41 - (v39 + *(__int16 *)(a4 + 28));
      int v46 = v42 - (*(__int16 *)(a4 + 30) + v40);
      float v47 = v43 * (float)v39;
      *(float *)(a1 + 276) = v47;
      float v48 = v44 * (float)v40;
      *(float *)(a1 + 280) = v48;
      float v49 = v43 * (float)(v45 + v39);
      *(float *)(a1 + 284) = v49;
      float v50 = v44 * (float)(v46 + v40);
      *(float *)(a1 + 288) = v50;
      *(_DWORD *)(a1 + 308) |= 0x400u;
      *(double *)(a1 + 24) = (double)v45;
      *(double *)(a1 + 32) = (double)v46;
      float v51 = v43 * 0.5;
      *(float *)(a1 + 392) = v47 + v51;
      float v52 = v44 * 0.5;
      *(float *)(a1 + 396) = v48 + v52;
      *(float *)(a1 + 400) = v49 - v51;
      *(float *)(a1 + 404) = v50 - v52;
      *(unsigned char *)(a1 + 491) = 1;
      goto LABEL_18;
    }
    if (*(_WORD *)(a4 + 28) || *(_WORD *)(a4 + 30))
    {
      __int16 v40 = 0;
      goto LABEL_17;
    }
  }
LABEL_18:
  double v53 = 1.0;
  if ((v38 & 0x2000) != 0)
  {
    double v54 = *(float *)(a4 + 32);
    *(double *)(a1 + 256) = v54;
    *(double *)(a1 + 24) = *(double *)(a1 + 24) * v54;
    double v53 = 1.0 / v54;
    *(double *)_Q16.i64 = v53;
  }
  double v55 = *(double *)(a1 + 264);
  if (v55 != 1.0)
  {
    *(float64x2_t *)(a1 + 24) = vmulq_n_f64(*(float64x2_t *)(a1 + 24), 1.0 / v55);
    *(double *)_Q16.i64 = v53 * v55;
    *(double *)&_Q16.i64[1] = v55;
  }
  uint64_t v56 = (float32x2_t *)(a1 + 276);
  uint64_t v57 = *(void *)(v21 + 128);
  if (v57)
  {
    uint64_t v58 = *(void *)(v57 + 40);
    if (v58)
    {
      int v59 = *(_DWORD *)(a1 + 308);
      if ((v59 & 0x400) != 0)
      {
        float64x2_t v62 = vcvtq_f64_f32(*v56);
        float64x2_t v63 = vcvtq_f64_f32(vsub_f32(*(float32x2_t *)(a1 + 284), *(float32x2_t *)(a1 + 276)));
        float64x2_t v61 = *(float64x2_t *)(v58 + 24);
        float64x2_t v60 = *(float64x2_t *)(v58 + 40);
        *(float32x4_t *)v56->f32 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmlaq_f64(v62, v63, v61)), vmlaq_f64(v62, v63, v60));
      }
      else
      {
        float64x2_t v60 = *(float64x2_t *)(v58 + 40);
        float64x2_t v61 = *(float64x2_t *)(v58 + 24);
        *(float32x4_t *)v56->f32 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v61), v60);
        *(_DWORD *)(a1 + 308) = v59 | 0x400;
      }
      double v64 = *(double *)(a1 + 32);
      *(double *)(a1 + 24) = *(double *)(a1 + 24) * (v60.f64[0] - v61.f64[0]);
      *(double *)(a1 + 32) = v64 * (*(double *)(v58 + 48) - *(double *)(v58 + 32));
    }
  }
  int8x16_t v145 = _Q16;
  long long v148 = 0uLL;
  double v66 = *(double *)(a1 + 24);
  double v65 = *(double *)(a1 + 32);
  v147.f64[0] = v66;
  v147.f64[1] = v65;
  if ((*(_DWORD *)(v21 + 36) & 0xF000) == 0x9000
    && *(double *)(v21 + 64) == 0.0
    && *(double *)(v21 + 72) == 0.0
    && (!v57 || !*(void *)(v57 + 32))
    && *(double *)(v21 + 80) == v66
    && *(double *)(v21 + 88) == v65)
  {
    __asm { FMOV            V0.2D, #1.0 }
    long long v148 = _Q0;
    double v67 = 1.0;
    double v68 = 1.0;
  }
  else
  {
    CA::Render::Layer::append_contents_transform(v21, (CA::Transform *)v163, &v147, &v148);
    double v67 = *((double *)&v148 + 1);
    double v68 = *(double *)&v148;
  }
  *(double *)(a1 + 320) = v68;
  *(double *)(a1 + 328) = v67;
  if (v68 != 1.0 || v67 != 1.0)
  {
    uint64_t v69 = *(void *)(a2 + 24);
    uint64_t v70 = *(void *)(v69 + 128);
    if (v70)
    {
      uint64_t v71 = *(double **)(v70 + 48);
      if (v71)
      {
        *(unsigned char *)(a1 + 337) = 1;
        double v73 = v71[3];
        double v72 = v71[4];
        double v75 = v71[5];
        double v74 = v71[6];
        if ((*(unsigned char *)(v69 + 45) & 1) == 0)
        {
          if (v75 <= v73)
          {
            double v76 = 0.5 / (double)*(int *)a1;
            double v73 = v73 - v76;
            double v75 = v76 + v75;
          }
          if (v74 <= v72)
          {
            double v77 = 0.5 / (double)*(int *)(a1 + 4);
            double v72 = v72 - v77;
            double v74 = v77 + v74;
          }
        }
        float v78 = v73;
        *(float *)(a1 + 376) = v78;
        float v79 = v72;
        *(float *)(a1 + 380) = v79;
        float v80 = v75;
        *(float *)(a1 + 384) = v80;
        float v81 = v74;
        *(float *)(a1 + 388) = v81;
        double v82 = *(double *)(a1 + 24);
        double v83 = *(double *)(a1 + 32);
        double v84 = v82 / v68;
        double v85 = v83 / v67;
        *(double *)(a1 + 344) = v84 * v73;
        *(double *)(a1 + 352) = v85 * v72;
        *(double *)(a1 + 360) = v82 + v84 * (v75 - 1.0);
        *(double *)(a1 + 368) = v83 + v85 * (v74 - 1.0);
      }
    }
  }
  if ((v38 & 0x700) != 0)
  {
    uint64_t v162 = 0;
    float64x2_t v153 = (float64x2_t)xmmword_184997D50;
    long long v154 = 0u;
    long long v155 = xmmword_184997D60;
    long long v156 = 0u;
    long long v157 = 0u;
    long long v158 = xmmword_184997D50;
    long long v159 = 0u;
    long long v160 = xmmword_184997D60;
    __asm { FMOV            V0.2D, #1.0 }
    long long v161 = _Q0;
    if ((~v38 & 0x200400) == 0 && ((v38 & 0x300) == 0 || (v38 & 0x300) == 0x300)) {
      goto LABEL_49;
    }
    if ((v38 & 0x100) != 0)
    {
      float64x2_t v87 = CA::Transform::translate((CA::Transform *)&v153, 0.0, *(double *)(a1 + 32), 0.0);
      v87.f64[0] = 1.0;
      CA::Transform::scale(&v153, v87, -1.0, 1.0);
    }
    if ((v38 & 0x200) != 0)
    {
LABEL_49:
      float64x2_t v88 = CA::Transform::translate((CA::Transform *)&v153, *(double *)(a1 + 24), 0.0, 0.0);
      v88.f64[0] = -1.0;
      CA::Transform::scale(&v153, v88, 1.0, 1.0);
    }
    if ((v38 & 0x400) != 0)
    {
      CA::Transform::translate((CA::Transform *)&v153, *(double *)(a1 + 24), 0.0, 0.0);
      CA::Transform::rotate90((CA::Transform *)&v153, v89, v90, v91);
    }
    CA::Transform::concat_left((CA::Transform *)v163, &v153, (uint64_t)v19, v20);
    if ((*(unsigned char *)(a1 + 309) & 4) != 0) {
      CA::OGL::unrotate_texcoords((CA::OGL *)(v38 >> 8), (int8x16_t *)(a1 + 276), v19);
    }
    if (*(unsigned char *)(a1 + 337)) {
      CA::OGL::unrotate_texcoords((CA::OGL *)(v38 >> 8), (int8x16_t *)(a1 + 376), v19);
    }
    if ((v38 & 0x400) != 0) {
      *(int8x16_t *)(a1 + 24) = vextq_s8(*(int8x16_t *)(a1 + 24), *(int8x16_t *)(a1 + 24), 8uLL);
    }
  }
  __int16 v92 = (double *)(a1 + 40);
  if ((~v38 & 0x104000) == 0 && !*(unsigned char *)(a1 + 337) && !*(unsigned char *)(a1 + 338))
  {
    uint64_t v138 = *(void *)(*(void *)(a2 + 24) + 128);
    if ((!v138 || !*(void *)(v138 + 40)) && *(double *)&v148 == 1.0 && *((double *)&v148 + 1) == 1.0)
    {
      float v139 = *(float *)(a1 + 284);
      if (v139 > 1.0)
      {
        *(double *)(a1 + 24) = *(double *)(a1 + 24)
                             * (float)((float)(1.0 - *(float *)(a1 + 276)) / (float)(v139 - *(float *)(a1 + 276)));
        *(_DWORD *)(a1 + 284) = 1065353216;
      }
      float v140 = *(float *)(a1 + 288);
      float v141 = *(float *)(a1 + 280);
      if (v140 > 1.0)
      {
        *(double *)(a1 + 32) = *(double *)(a1 + 32) * (float)((float)(1.0 - v141) / (float)(v140 - v141));
        *(_DWORD *)(a1 + 288) = 1065353216;
        float v140 = 1.0;
      }
      if (v141 < 0.0)
      {
        double v142 = *(double *)(a1 + 32);
        double v143 = v142 * v141 / (float)(v140 - v141);
        *(double *)(a1 + 16) = *(double *)(a1 + 16) - v143;
        *(double *)(a1 + 32) = v143 + v142;
        *(_DWORD *)(a1 + 280) = 0;
      }
    }
  }
  CA::Transform::concat_left(v15, (float64x2_t *)v163, (uint64_t)v19, v20);
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a1 + 24);
  CA::Rect::apply_transform((int8x16_t *)(a1 + 40), v15, v93);
  if ((*(unsigned char *)(*(void *)(a2 + 24) + 42) & 1) != 0
    && ((*(unsigned char *)(a1 + 248) & 0x10) == 0 || CA::Mat4Impl::mat4_is_rectilinear(v15, v94)))
  {
    v96.f64[0] = *v92;
    if (*v92 == trunc(*v92))
    {
      double v98 = *(double *)(a1 + 48);
      double v99 = *(double *)(a1 + 56);
      double v97 = trunc(v98);
      if (v98 == v97 && v99 == trunc(v99))
      {
        double v100 = *(double *)(a1 + 64);
        double v97 = trunc(v100);
        if (v100 == v97) {
          goto LABEL_75;
        }
      }
    }
    else
    {
      double v99 = *(double *)(a1 + 56);
    }
    double v101 = *(double *)(a1 + 64);
    if (v99 >= v101) {
      double v102 = *(double *)(a1 + 64);
    }
    else {
      double v102 = v99;
    }
    if (v102 > 0.0)
    {
      double v103 = *(double *)(a1 + 48);
      double v104 = round(v96.f64[0]);
      double v105 = round(v103);
      v96.f64[0] = v104 - v96.f64[0];
      CA::Transform::translate_right((float64x2_t *)v15, v96, v105 - v103, v97);
      *(double *)(a1 + 40) = v104;
      *(double *)(a1 + 48) = v105;
      *(double *)(a1 + 56) = v99;
      *(double *)(a1 + 64) = v101;
    }
  }
LABEL_75:
  if (a6)
  {
    float64x2_t v106 = *(float64x2_t *)(a1 + 56);
    int64x2_t v107 = vceqzq_f64(v106);
    if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v107, 1), (int8x16_t)v107).u64[0] & 0x8000000000000000) != 0
      || (int8x16_t v108 = vorrq_s8((int8x16_t)vcltzq_f64(v106), (int8x16_t)vcgezq_f64(v106)),
          (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v108), 1), v108).u64[0] & 0x8000000000000000) != 0))
    {
      float64x2_t v153 = 0uLL;
    }
    else
    {
      float64x2_t v109 = *(float64x2_t *)(a1 + 40);
      int32x4_t v110 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v109, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
      float64x2_t v153 = (float64x2_t)vuzp1q_s32(v110, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v109, v106), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v110));
    }
    BOOL v111 = CA::Shape::intersects(*(void *)(a3 + 8), (int32x2_t *)&v153);
    *(unsigned char *)(a1 + 272) = v111;
    if (v111)
    {
      uint64_t v112 = CA::OGL::transform_filter_bits((float64x2_t *)v15, v94, *(double *)v145.i64, *(double *)&v145.i64[1]);
      int v114 = *(_DWORD *)(a1 + 308) | CA::OGL::rect_filter_bits((float64x2_t *)v15, v112, v113, *(float64x2_t *)(a1 + 8), *(float64x2_t *)(a1 + 24), v145, *(double *)&v145.i64[1]);
      *(_DWORD *)(a1 + 308) = v114;
      if ((*(unsigned char *)(a6 + 432) & 2) != 0)
      {
        v114 ^= 0x800u;
        *(_DWORD *)(a1 + 308) = v114;
      }
      if (*(unsigned char *)(*(void *)(a2 + 16) + 24)) {
        *(_DWORD *)(a1 + 308) = v114 ^ 0x800;
      }
    }
  }
  if (*(unsigned char *)(a1 + 491)
    && !*(unsigned char *)(a1 + 494)
    && (*(_DWORD *)(a1 + 308) & 0x800) == ((*(_DWORD *)(a4 + 12) >> 11) & 1))
  {
    float v115 = 1.0 - *(float *)(a1 + 396);
    *(float *)(a1 + 396) = 1.0 - *(float *)(a1 + 404);
    *(float *)(a1 + 404) = v115;
  }
  if (*(double *)(a1 + 424) == 0.0
    || (*(void *)(a2 + 32) & 0x300007FE0) != 0x100
    || *(unsigned char *)(a1 + 337)
    || *(unsigned char *)(a1 + 338)
    || (uint64_t v116 = *(void *)(a2 + 24), (*(unsigned char *)(v116 + 40) & 0x40) == 0)
    || (v171 & 0x10) != 0 && !CA::Mat4Impl::mat4_is_rectilinear((CA::Mat4Impl *)v163, v94))
  {
LABEL_118:
    char v117 = 0;
    goto LABEL_119;
  }
  if ((~*(_DWORD *)(v116 + 36) & 0xF0000) == 0
    || (char v117 = 0, *(double *)v163[0].i64 > 0.0) && *((double *)&v164 + 1) > 0.0)
  {
    float64x2_t v118 = *(void **)(v116 + 128);
    if (!v118 || !v118[9])
    {
      long long v119 = *(_OWORD *)(v116 + 80);
      float64x2_t v153 = *(float64x2_t *)(v116 + 64);
      long long v154 = v119;
      CA::Transform::invert(v163, (uint64_t)v94, v95);
      CA::Mat4Impl::mat4_apply_to_rect((float64x2_t *)v163, (int8x16_t *)&v153, v120);
      float64x2_t v151 = v153;
      long long v152 = v154;
      double v122 = *((double *)&v154 + 1);
      if (*(double *)&v154 <= *((double *)&v154 + 1)) {
        double v123 = *((double *)&v154 + 1);
      }
      else {
        double v123 = *(double *)&v154;
      }
      if (v123 < 1.79769313e308)
      {
        double v124 = *(double *)&v154 >= *((double *)&v154 + 1) ? *((double *)&v154 + 1) : *(double *)&v154;
        if (v124 > 0.0)
        {
          float64x2_t v151 = vaddq_f64(v153, (float64x2_t)vdupq_n_s64(0x3F50624DD2F1A9FCuLL));
          *(double *)&long long v152 = *(double *)&v154 + -0.002;
          *((double *)&v152 + 1) = *((double *)&v154 + 1) + -0.002;
          if (*(double *)&v154 + -0.002 <= 0.0 || *((double *)&v154 + 1) + -0.002 <= 0.0) {
            long long v152 = 0uLL;
          }
        }
      }
      double v144 = *(double *)&v154;
      float64x2_t v146 = v153;
      if ((*(unsigned char *)(a1 + 312) & 0xF) == 0 || CA::BoundsImpl::contains((double *)v14, v151.f64))
      {
        float64_t v149 = 0.0;
        float64_t v150 = 0.0;
        CA::Transform::get_scale((CA::Mat4Impl *)v163, &v150, &v149, v121);
        v125.f64[0] = v150;
        v125.f64[1] = v149;
        *(float64x2_t *)(a1 + 424) = vmulq_f64(*(float64x2_t *)(a1 + 424), v125);
        v125.f64[0] = *(float64_t *)(a1 + 8);
        double v126 = *(double *)(a1 + 16);
        double v127 = *(double *)(a1 + 24);
        double v128 = *(double *)(a1 + 32);
        float v129 = (v146.f64[0] - v125.f64[0]) / v127;
        *(float *)(a1 + 292) = v129;
        float v130 = (v146.f64[1] - v126) / v128;
        *(float *)(a1 + 296) = v130;
        float v131 = (v146.f64[0] - v125.f64[0] + v144) / v127;
        *(float *)(a1 + 300) = v131;
        float v132 = (v146.f64[1] - v126 + v122) / v128;
        *(float *)(a1 + 304) = v132;
        *(float64_t *)(a1 + 72) = v125.f64[0];
        *(double *)(a1 + 80) = v126;
        *(double *)(a1 + 88) = v127;
        *(double *)(a1 + 96) = v128;
        *(float64x2_t *)(a1 + 8) = v146;
        *(double *)(a1 + 24) = v144;
        *(double *)(a1 + 32) = v122;
        *(_DWORD *)(a1 + 440) = *(_WORD *)(v116 + 38) & 0xF;
        *(_DWORD *)(a1 + 444) = *(_DWORD *)(v116 + 40) & 3;
        if (v118)
        {
          *(void *)(a1 + 448) = v118[7];
          uint64_t v133 = v118[8];
          if (v133)
          {
            float64x2_t v134 = 0uLL;
            _Q1 = 0uLL;
            if (*(_DWORD *)(v133 + 16) >= 4u)
            {
              _Q1 = *(float64x2_t *)(v133 + 24);
              float64x2_t v134 = vsubq_f64(*(float64x2_t *)(v133 + 40), _Q1);
            }
            goto LABEL_137;
          }
        }
        else
        {
          *(void *)(a1 + 448) = 0;
        }
        __asm { FMOV            V1.2D, #0.5 }
        float64x2_t v134 = 0uLL;
LABEL_137:
        *(float64x2_t *)(a1 + 456) = _Q1;
        *(float64x2_t *)(a1 + 472) = v134;
        *(unsigned char *)(a1 + 489) = (*(void *)(v116 + 40) & 0x20000000000) != 0;
        *(unsigned char *)(a1 + 488) = *(unsigned char *)(*(void *)(a2 + 16) + 24) & 1;
        char v117 = 1;
        goto LABEL_119;
      }
    }
    goto LABEL_118;
  }
LABEL_119:
  *(unsigned char *)(a1 + 490) = v117;
  return a1;
}

double CA::Rect::apply_transform(int8x16_t *this, const CA::Transform *a2, double *a3)
{
  char v3 = *((unsigned char *)a2 + 144);
  if ((v3 & 0x10) != 0)
  {
    CA::Mat4Impl::mat4_apply_to_rect((float64x2_t *)a2, this, a3);
    return result;
  }
  double v5 = *(double *)this[1].i64;
  double result = *(double *)&this[1].i64[1];
  if (v5 <= result) {
    double v6 = *(double *)&this[1].i64[1];
  }
  else {
    double v6 = *(double *)this[1].i64;
  }
  if (v6 < 1.79769313e308)
  {
    if ((*((unsigned char *)a2 + 144) & 8) != 0)
    {
      double v7 = *(double *)&this->i64[1];
      *(double *)this->i64 = *(double *)this->i64 * *((double *)a2 + 16);
      *(double *)&this->i64[1] = v7 * *((double *)a2 + 16);
      double v5 = *((double *)a2 + 16) * v5;
      *(double *)this[1].i64 = v5;
      double result = *((double *)a2 + 16) * result;
      *(double *)&this[1].i64[1] = result;
      char v3 = *((unsigned char *)a2 + 144);
    }
    if ((v3 & 4) != 0)
    {
      uint64_t v9 = this->i64[0];
      *(double *)this->i64 = -(result + *(double *)&this->i64[1]);
      this->i64[1] = v9;
      *(double *)this[1].i64 = result;
      *(double *)&this[1].i64[1] = v5;
      char v3 = *((unsigned char *)a2 + 144);
      double v8 = v5;
      if ((v3 & 2) == 0)
      {
LABEL_14:
        double v10 = *(double *)&this->i64[1];
        if (v3)
        {
          double v10 = -(v8 + v10);
          *(double *)&this->i64[1] = v10;
        }
        *(double *)this->i64 = *(double *)this->i64 + *((double *)a2 + 12);
        double result = v10 + *((double *)a2 + 13);
        *(double *)&this->i64[1] = result;
        return result;
      }
    }
    else
    {
      double v8 = result;
      double result = v5;
      if ((v3 & 2) == 0) {
        goto LABEL_14;
      }
    }
    *(double *)this->i64 = -(result + *(double *)this->i64);
    char v3 = *((unsigned char *)a2 + 144);
    goto LABEL_14;
  }
  return result;
}

uint64_t CA::OGL::rect_filter_bits(float64x2_t *this, uint64_t a2, double *a3, float64x2_t a4, float64x2_t a5, int8x16_t a6, double a7)
{
  uint64_t v7 = a2;
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if ((~a2 & 9) == 0) {
    return v7;
  }
  int8x16_t v9 = (int8x16_t)vaddq_f64(a5, a4);
  int8x16_t v20 = v9;
  float64x2_t v21 = a4;
  if (!a2 && *(double *)a6.i64 == 1.0 && a7 == 1.0) {
    goto LABEL_9;
  }
  CA::Transform::apply_to_point2(this, v21.f64, a3);
  CA::Transform::apply_to_point2(this, (double *)v20.i64, v11);
  if ((v7 & 1) == 0)
  {
    a4.f64[0] = v21.f64[0];
    v9.i64[0] = v20.i64[0];
LABEL_9:
    a6.i64[0] = 0.5;
    v13.f64[0] = NAN;
    v13.f64[1] = NAN;
    int8x16_t v14 = (int8x16_t)vnegq_f64(v13);
    int8x16_t v12 = vbslq_s8(v14, a6, (int8x16_t)a4);
    double v15 = vabdd_f64(trunc(*(double *)v12.i64 + a4.f64[0]), a4.f64[0]);
    double v16 = vabdd_f64(trunc(*(double *)vbslq_s8(v14, a6, v9).i64 + *(double *)v9.i64), *(double *)v9.i64);
    if (v15 <= v16) {
      double v15 = v16;
    }
    uint64_t v7 = (v15 >= 0.001) | v7;
  }
  if ((v7 & 8) == 0)
  {
    a4.f64[0] = v21.f64[1];
    v9.i64[0] = 0.5;
    v17.f64[0] = NAN;
    v17.f64[1] = NAN;
    int8x16_t v18 = (int8x16_t)vnegq_f64(v17);
    v12.i64[0] = v20.i64[1];
    a4.f64[0] = vabdd_f64(trunc(*(double *)vbslq_s8(v18, v9, (int8x16_t)a4).i64 + v21.f64[1]), v21.f64[1]);
    *(double *)v9.i64 = vabdd_f64(trunc(*(double *)vbslq_s8(v18, v9, v12).i64 + *(double *)&v20.i64[1]), *(double *)&v20.i64[1]);
    if (a4.f64[0] <= *(double *)v9.i64) {
      a4.f64[0] = *(double *)v9.i64;
    }
    if (a4.f64[0] >= 0.001) {
      return v7 | 8;
    }
    else {
      return v7;
    }
  }
  return v7;
}

uint64_t CA::OGL::transform_filter_bits(float64x2_t *this, const double *a2, double a3, double a4)
{
  unsigned int v7 = LOBYTE(this[9].f64[0]);
  if ((v7 & 0x10) != 0)
  {
    double v18 = this[7].f64[1];
    double v19 = 1.0;
    double v20 = 1.0;
    if (fabs(v18 + -1.0) >= 0.001)
    {
      double v20 = 1.0 / (v18 * v18);
      double v19 = 1.0 / v18;
    }
    double v33 = v19;
    if (CA::Mat4Impl::mat4_is_rectilinear((CA::Mat4Impl *)this, a2))
    {
      int8x16_t v21 = (int8x16_t)vmulq_n_f64(this[6], v33);
      v22.f64[0] = NAN;
      v22.f64[1] = NAN;
      __asm { FMOV            V2.2D, #0.5 }
      float64x2_t v24 = vabdq_f64(vrndq_f64(vaddq_f64((float64x2_t)vbslq_s8((int8x16_t)vnegq_f64(v22), _Q2, v21), (float64x2_t)v21)), (float64x2_t)v21);
      unsigned int v25 = v24.f64[0] >= 0.001;
      if (v24.f64[1] >= 0.001) {
        v25 |= 8u;
      }
    }
    else
    {
      unsigned int v25 = 9;
    }
    double v28 = this->f64[0];
    double v27 = this->f64[1];
    double v29 = (v28 * v28 + v27 * v27) * v20;
    double v30 = this[2].f64[0];
    double v31 = this[2].f64[1];
    double v32 = (v30 * v30 + v31 * v31) * v20;
    if (v29 >= a3 + -0.001)
    {
      if (v29 > a3 + 0.001) {
        uint64_t result = v25 | 4;
      }
      else {
        uint64_t result = v25;
      }
    }
    else
    {
      uint64_t result = v25 | 2;
    }
    if (v32 >= a4 + -0.001)
    {
      if (v32 > a4 + 0.001) {
        uint64_t result = result | 0x20;
      }
    }
    else
    {
      uint64_t result = result | 0x10;
    }
    if (((result ^ (result >> 3)) & 7) != 0
      && fabs(v28) < 0.001
      && vabdd_f64(v28, v31) < 0.001
      && fabs(v30 + v27) < 0.001)
    {
      return result | 0x40;
    }
  }
  else
  {
    v8.f64[0] = NAN;
    v8.f64[1] = NAN;
    __asm { FMOV            V2.2D, #0.5 }
    float64x2_t v14 = vabdq_f64(vrndq_f64(vaddq_f64((float64x2_t)vbslq_s8((int8x16_t)vnegq_f64(v8), _Q2, (int8x16_t)this[6]), this[6])), this[6]);
    int v15 = v14.f64[0] >= 0.001;
    if (v14.f64[1] >= 0.001) {
      v15 |= 8u;
    }
    unsigned int v16 = v15 | (16 * v7) & 0x40 | (((v7 >> 1) & 1) << 7);
    double v17 = this[8].f64[0];
    if (v17 >= a3 + -0.001)
    {
      if (v17 > a3 + 0.001) {
        v16 |= 4u;
      }
    }
    else
    {
      v16 |= 2u;
    }
    if (v17 >= a4 + -0.001)
    {
      if (v17 > a4 + 0.001) {
        return v16 | 0x20;
      }
      else {
        return v16;
      }
    }
    else
    {
      return v16 | 0x10;
    }
  }
  return result;
}

double CA::Transform::set_2x2(CA::Transform *this)
{
  char v1 = *((unsigned char *)this + 144);
  double result = *((double *)this + 16);
  if ((v1 & 4) != 0) {
    double v3 = 0.0;
  }
  else {
    double v3 = *((double *)this + 16);
  }
  if ((*((unsigned char *)this + 144) & 4) != 0) {
    double v4 = -result;
  }
  else {
    double v4 = 0.0;
  }
  if ((*((unsigned char *)this + 144) & 4) == 0) {
    double result = 0.0;
  }
  *((double *)this + 4) = v4;
  *((double *)this + 5) = v3;
  *(double *)this = v3;
  *((double *)this + 1) = result;
  double v5 = -v3;
  if ((v1 & 2) == 0)
  {
    if ((v1 & 1) == 0) {
      return result;
    }
LABEL_13:
    double result = -result;
    *((double *)this + 1) = result;
    *((double *)this + 5) = v5;
    return result;
  }
  *(double *)this = v5;
  *((double *)this + 4) = -v4;
  if (v1) {
    goto LABEL_13;
  }
  return result;
}

float64_t CA::Transform::concat_left(CA::Transform *this, float64x2_t *a2, uint64_t a3, const double *a4)
{
  char v4 = *((unsigned char *)this + 144);
  if ((v4 & 0x10) != 0) {
    goto LABEL_6;
  }
  if ((LOBYTE(a2[9].f64[0]) & 0x10) != 0)
  {
    __asm { FMOV            V0.2D, #1.0 }
    *((_OWORD *)this + 8) = _Q0;
    *((unsigned char *)this + 144) = v4 & 0xE0 | 0x10;
LABEL_6:
    *(void *)&v5.f64[0] = *(_OWORD *)&CA::Mat4Impl::mat4_concat((float64x2_t *)this, a2->f64, (const double *)this, a4);
    return v5.f64[0];
  }
  v5.f64[0] = a2[6].f64[0];
  if ((*((unsigned char *)this + 144) & 0xF) != 0)
  {
    *((float64x2_t *)this + 6) = vmlaq_n_f64(vmlaq_n_f64(*((float64x2_t *)this + 6), *(float64x2_t *)this, v5.f64[0]), *((float64x2_t *)this + 2), a2[6].f64[1]);
  }
  else
  {
    v5.f64[0] = *((double *)this + 12) + v5.f64[0];
    double v11 = *((double *)this + 13) + a2[6].f64[1];
    *((void *)this + 12) = *(void *)&v5.f64[0];
    *((double *)this + 13) = v11;
  }
  char v12 = LOBYTE(a2[9].f64[0]);
  char v13 = v12;
  if ((v12 & 8) != 0)
  {
    float64x2_t v5 = vmulq_f64(*((float64x2_t *)this + 8), a2[8]);
    *((float64x2_t *)this + 8) = v5;
    char v4 = v4 & 0xF7 | (8 * (v5.f64[0] != 1.0));
    *((unsigned char *)this + 144) = v4;
    char v13 = LOBYTE(a2[9].f64[0]);
  }
  int v14 = concat_table[v13 & 7 | (8 * (v4 & 7))];
  if ((v4 & 7) == v14)
  {
    if ((v12 & 8) == 0) {
      return v5.f64[0];
    }
  }
  else
  {
    *((unsigned char *)this + 144) = v4 & 0xF8 | v14 & 7;
  }
  v5.f64[0] = CA::Transform::set_2x2(this);
  return v5.f64[0];
}

uint64_t CA::Render::Texture::bit_depth(CA::Render::Texture *this)
{
  unsigned int v1 = (*(uint64_t (**)(CA::Render::Texture *))(*(void *)this + 104))(this);
  if (v1 - 33 < 3) {
    return 9;
  }
  if (v1 > 0x23) {
    return 0;
  }
  return dword_184999500[v1];
}

double CA::Transform::apply_to_point2(float64x2_t *this, double *a2, double *a3)
{
  char v3 = LOBYTE(this[9].f64[0]);
  if ((v3 & 0x10) != 0)
  {
    *(void *)&double result = *(_OWORD *)&CA::Mat4Impl::mat4_apply_to_point2(this, a2, a3);
    return result;
  }
  if ((LOBYTE(this[9].f64[0]) & 8) == 0)
  {
    if ((LOBYTE(this[9].f64[0]) & 4) == 0) {
      goto LABEL_4;
    }
LABEL_11:
    uint64_t v7 = *(void *)a2;
    *a2 = -a2[1];
    *((void *)a2 + 1) = v7;
    char v3 = LOBYTE(this[9].f64[0]);
    if ((v3 & 2) == 0) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  double v6 = a2[1];
  *a2 = *a2 * this[8].f64[0];
  a2[1] = v6 * this[8].f64[0];
  char v3 = LOBYTE(this[9].f64[0]);
  if ((v3 & 4) != 0) {
    goto LABEL_11;
  }
LABEL_4:
  if ((v3 & 2) != 0)
  {
LABEL_5:
    *a2 = -*a2;
    char v3 = LOBYTE(this[9].f64[0]);
  }
LABEL_6:
  double v4 = a2[1];
  if (v3)
  {
    double v4 = -v4;
    a2[1] = v4;
  }
  *a2 = *a2 + this[6].f64[0];
  double result = v4 + this[6].f64[1];
  a2[1] = result;
  return result;
}

uint64_t CA::OGL::fill_color_rect(uint64_t result, uint64_t a2, int a3, double *a4, int a5, unsigned int a6, double a7, int8x16_t a8)
{
  uint64_t v11 = result;
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  unsigned int v12 = a3 & 0xFFFF7FFF;
  if (a4 && byte_1EB2ACBE1)
  {
    uint64_t v17 = *(void *)(*(void *)(result + 248) + 24);
    uint64_t v19 = a2;
    uint64_t v20 = v17;
    unsigned int v21 = a3 & 0xFFFF7FFF;
    int v25 = 0;
    uint64_t v23 = 0;
    uint64_t v24 = 0;
    uint64_t v22 = 0;
    double result = CA::OGL::fill_color_rect(result, (uint64_t)&v19, (double *)0x80800080, a4, a7, a8);
  }
  if (BYTE2(ca_debug_options))
  {
    uint64_t v14 = *(void *)(*(void *)(v11 + 248) + 24);
    uint64_t v19 = a2;
    uint64_t v20 = v14;
    unsigned int v21 = v12;
    if (a5) {
      uint64_t v15 = 2147483776;
    }
    else {
      uint64_t v15 = 8388736;
    }
    int v25 = 0;
    uint64_t v23 = 0;
    uint64_t v24 = 0;
    uint64_t v22 = 0;
    double result = CA::OGL::fill_color_rect(v11, (uint64_t)&v19, (double *)v15, a4, a7, a8);
  }
  if (byte_1EB2ACC4D) {
    BOOL v13 = a6 == 0;
  }
  else {
    BOOL v13 = 1;
  }
  if (!v13)
  {
    if (a6 > 4) {
      uint64_t v16 = 2147516544;
    }
    else {
      uint64_t v16 = CA::OGL::fill_color_rect(CA::OGL::Context &,CA::Rect const&,unsigned int,BOOL,BOOL,CA::Render::VelocityBucket)::velocity_colors[a6 - 1];
    }
    uint64_t v18 = *(void *)(*(void *)(v11 + 248) + 24);
    uint64_t v19 = a2;
    uint64_t v20 = v18;
    unsigned int v21 = v12;
    int v25 = 0;
    uint64_t v23 = 0;
    uint64_t v24 = 0;
    uint64_t v22 = 0;
    return CA::OGL::fill_color_rect(v11, (uint64_t)&v19, (double *)v16, a4, a7, a8);
  }
  return result;
}

uint64_t CA::OGL::fill_round_rect(uint64_t result, float64x2_t **a2, double *a3, double *a4, float64_t a5, float64_t a6)
{
  v50[4] = *(double *)MEMORY[0x1E4F143B8];
  double v6 = (*a2)[1].f64[1];
  if ((*a2)[1].f64[0] < v6) {
    double v6 = (*a2)[1].f64[0];
  }
  if (v6 > 0.0)
  {
    int v8 = (int)a3;
    double v10 = (CA::OGL::Context *)result;
    double v39 = 0.0;
    double v40 = 0.0;
    uint64_t v44 = 0;
    uint64_t v11 = a2[1];
    if ((LOBYTE(v11[9].f64[0]) & 0x10) != 0)
    {
      double v37 = a5;
      double v38 = a6;
      CA::Mat4Impl::mat4_get_scale((CA::Mat4Impl *)v11, &v40, &v39, a4);
      a5 = v37;
      a6 = v38;
      double v12 = v39;
      double v13 = v40;
    }
    else
    {
      double v12 = v11[8].f64[0];
      double v39 = v12;
      double v40 = v12;
      double v13 = v12;
    }
    v14.f64[0] = a5;
    v14.f64[1] = a6;
    float64x2_t v15 = vmulq_f64(v14, (float64x2_t)vdupq_n_s64(0x3FF875696E58A32FuLL));
    if (a4) {
      double v16 = v15.f64[0];
    }
    else {
      double v16 = a5;
    }
    if (a4) {
      double v17 = v15.f64[1];
    }
    else {
      double v17 = a6;
    }
    double v18 = v13 * v16;
    double v19 = v12 * v17;
    if (v18 >= v12 * v17) {
      double v19 = v18;
    }
    if (!v8 || v19 < 1.0) {
      return CA::OGL::fill_rect((uint64_t)v10, (uint64_t)a2, a3, a4);
    }
    unsigned int v20 = *((_DWORD *)a2 + 4);
    uint64_t v21 = *((void *)v10 + 2);
    unint64_t v22 = *(void *)(v21 + 16) & 0xFFFFFF00FF00FF00;
    if (*(void *)(v21 + 8) == 0x3C003C003C003C00) {
      int v23 = 1;
    }
    else {
      int v23 = 3;
    }
    *(_DWORD *)(v21 + 16) = v23 | v22;
    *(_DWORD *)(v21 + 20) = HIDWORD(v22);
    uint64_t v24 = (v20 >> 21) & 1;
    if (a4)
    {
      int8x16_t v25 = (int8x16_t)vaddq_f64(vdivq_f64(vmulq_f64((*a2)[1], (float64x2_t)vdupq_n_s64(0xBFF721E8A7A4B61BLL)), v15), (float64x2_t)vdupq_n_s64(0x400721E8A7A4B61BuLL));
      __asm { FMOV            V2.2D, #1.0 }
      int8x16_t v31 = vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v25, (float64x2_t)_Q2), _Q2, v25);
      *(float32x2_t *)&v50[0] = vcvt_f32_f64((float64x2_t)vbicq_s8(v31, (int8x16_t)vcltzq_f64((float64x2_t)v31)));
      LODWORD(a3) = vcvtpd_s64_f64(v19);
      (*(void (**)(CA::OGL::Context *, void, double *, void, uint64_t, uint64_t *, double *, double *))(*(void *)v10 + 464))(v10, 0, a3, 0, v24, &v44, a4, v50);
    }
    else
    {
      LODWORD(a3) = vcvtpd_s64_f64(v19);
      (*(void (**)(CA::OGL::Context *, void, double *, void, uint64_t, uint64_t *))(*(void *)v10 + 456))(v10, 0, a3, 0, v24, &v44);
    }
    double v33 = *a2;
    v50[0] = (*a2)->f64[0];
    v50[1] = v50[0] + v16;
    double v34 = v33[1].f64[0];
    v50[2] = v34 + v50[0] - v16;
    v50[3] = v34 + v50[0];
    v49[0] = v33->f64[1];
    v49[1] = v49[0] + v17;
    double v35 = v33[1].f64[1];
    v49[2] = v35 + v49[0] - v17;
    v49[3] = v35 + v49[0];
    LODWORD(v46) = v44;
    *((float *)&v46 + 1) = *(float *)&v44 + (float)((float)(*((float *)&v44 + 1) - *(float *)&v44) * 0.5);
    float v47 = *((float *)&v46 + 1);
    int v48 = HIDWORD(v44);
    LODWORD(v45[0]) = v44;
    v45[1] = *((float *)&v46 + 1);
    v45[2] = *((float *)&v46 + 1);
    v45[3] = *((float *)&v44 + 1);
    if (v34 == v35 && v16 == v17 && fabs(v34 + v16 * -2.0) < 1.0)
    {
      if ((*((unsigned char *)a2 + 20) & 0xF) != 0)
      {
        if (v8 == 15 && (a2[2] & 9) == 0) {
          goto LABEL_30;
        }
      }
      else if (v8 == 15)
      {
LABEL_30:
        int v41 = v44;
        uint64_t v42 = v44;
        int v43 = HIDWORD(v44);
        CA::OGL::emit_one_part_rect(v10, (uint64_t)a2, (const CA::Transform *)&v41, 0, 0);
LABEL_36:
        double result = (*(uint64_t (**)(CA::OGL::Context *, void, void))(*(void *)v10 + 520))(v10, 0, 0);
        *(unsigned char *)(*((void *)v10 + 2) + 16) = 0;
        return result;
      }
    }
    if (a4) {
      unsigned int v36 = ~(v8 << 22) & 0x3C00000 | 0x20000;
    }
    else {
      unsigned int v36 = ~(v8 << 22) & 0x3C00000;
    }
    CA::OGL::emit_nine_part_rect((uint64_t)v10, (uint64_t)a2, (uint64_t)v50, (uint64_t)v49, (uint64_t)&v46, (uint64_t)v45, 0, 0, v36);
    goto LABEL_36;
  }
  return result;
}

BOOL CA::Mat4Impl::mat4_is_rectilinear(CA::Mat4Impl *this, const double *a2)
{
  if (fabs(*((double *)this + 3)) >= 0.000001
    || fabs(*((double *)this + 7)) >= 0.000001
    || fabs(*((double *)this + 15) + -1.0) >= 0.000001)
  {
    return 0;
  }
  if (fabs(*((double *)this + 1)) < 0.000001 && fabs(*((double *)this + 4)) < 0.000001) {
    return 1;
  }
  return fabs(*(double *)this) < 0.000001 && fabs(*((double *)this + 5)) < 0.000001;
}

uint64_t CA::OGL::fill_rect(uint64_t result, uint64_t a2, double *a3, double *a4)
{
  uint64_t v5 = result;
  uint64_t v202 = *MEMORY[0x1E4F143B8];
  int v6 = *(_DWORD *)(a2 + 16);
  BOOL v7 = (v6 & 9) == 0 || (*(unsigned char *)(a2 + 20) & 0xF) == 0;
  if (v7 && (v6 & 0x100000) == 0) {
    goto LABEL_16;
  }
  int8x16_t v9 = *(float64x2_t **)a2;
  double v10 = *(double *)(*(void *)a2 + 16);
  if (v10 >= *(double *)(*(void *)a2 + 24)) {
    double v10 = *(double *)(*(void *)a2 + 24);
  }
  if (v10 > 0.0)
  {
    uint64_t v11 = *(const CA::Transform **)(a2 + 8);
    if (((*((unsigned char *)v11 + 144) & 0x10) == 0
       || CA::Mat4Impl::mat4_is_rectilinear(*(CA::Mat4Impl **)(a2 + 8), (const double *)a2))
      && !*(void *)(a2 + 24)
      && !*(void *)(a2 + 32))
    {
      float64x2_t v21 = v9[1];
      float64x2_t v200 = *v9;
      float64x2_t v201 = v21;
      CA::Rect::apply_transform((int8x16_t *)&v200, v11, a3);
      unint64_t v22 = *(float16x4_t **)(v5 + 16);
      float16x4_t v23 = v22[1];
      int64x2_t v24 = vceqzq_f64(v201);
      double v25 = v201.f64[1];
      float64x2_t v172 = v200;
      float64x2_t v169 = v201;
      if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v24, 1), (int8x16_t)v24).u64[0] & 0x8000000000000000) != 0
        || (int8x16_t v26 = vorrq_s8((int8x16_t)vcltzq_f64(v201), (int8x16_t)vcgezq_f64(v201)),
            (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v26), 1), v26).u64[0] & 0x8000000000000000) != 0))
      {
        int32x4_t v199 = 0uLL;
      }
      else
      {
        int32x4_t v27 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v200, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
        int32x4_t v199 = vuzp1q_s32(v27, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v200, v201), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v27));
      }
      double result = CA::OGL::Context::need_transparent_source((CA::OGL::Context *)v5);
      int v28 = result | ((v6 & 0x40000u) >> 18);
      v22[2].i8[0] = 0;
      int v29 = *(_DWORD *)(a2 + 20);
      *(void *)&double v30 = *(_OWORD *)&vaddq_f64(v169, v172);
      double v31 = v172.f64[1];
      double v32 = v25 + v172.f64[1];
      if ((v29 & 0xF) != 0)
      {
        double v33 = floor(v172.f64[0]);
        double v34 = ceil(v172.f64[0]);
        double v35 = round(v172.f64[0]);
        if (v29) {
          double v36 = v33;
        }
        else {
          double v36 = v35;
        }
        if (v29) {
          double v37 = v34;
        }
        else {
          double v37 = v35;
        }
        double v38 = floor(v30);
        double v39 = ceil(v30);
        double v40 = round(v30);
        if ((v29 & 2) != 0)
        {
          double v41 = v39;
        }
        else
        {
          double v38 = v40;
          double v41 = v40;
        }
        double v42 = floor(v172.f64[1]);
        double v43 = ceil(v172.f64[1]);
        double v44 = round(v172.f64[1]);
        if ((v29 & 4) != 0) {
          double v45 = v42;
        }
        else {
          double v45 = v44;
        }
        if ((v29 & 4) != 0) {
          double v46 = v43;
        }
        else {
          double v46 = v44;
        }
        double v47 = floor(v32);
        double v48 = ceil(v32);
        double v49 = round(v32);
        if ((v29 & 8) != 0)
        {
          double v50 = v48;
        }
        else
        {
          double v47 = v49;
          double v50 = v49;
        }
        BOOL v51 = (~v29 & 3) == 0;
        BOOL v52 = v41 == v36 + 1.0;
        BOOL v53 = (~v29 & 0xC) == 0;
        BOOL v54 = v50 == v45 + 1.0;
        BOOL v55 = v51 && v52;
        double v182 = v41;
        double v183 = v36;
        if (v51 && v52) {
          double v56 = v36;
        }
        else {
          double v56 = v37;
        }
        if (v51 && v52) {
          double v57 = v41;
        }
        else {
          double v57 = v38;
        }
        BOOL v58 = v53 && v54;
        double v180 = v50;
        double v181 = v45;
        if (v53 && v54) {
          double v59 = v45;
        }
        else {
          double v59 = v46;
        }
        double v185 = v59;
        if (v53 && v54) {
          double v60 = v50;
        }
        else {
          double v60 = v47;
        }
        uint64_t v61 = *(void *)(v5 + 16);
        double v161 = v25 + v172.f64[1];
        double v167 = v30;
        if ((*(unsigned char *)(v61 + 481) & 1) != 0 && (*(unsigned char *)(a2 + 17) & 0x80) != 0 && !v55 && !v58)
        {
          *(unsigned char *)(v61 + 481) &= ~1u;
          if (v60 > v59 && v57 > v56)
          {
            double v165 = v25;
            *(_OWORD *)uint64_t v192 = 0u;
            float64_t v81 = *(double *)(*(void *)(v5 + 248) + 8);
            *(void *)&v190.f64[0] = v5;
            v190.f64[1] = v81;
            memset(v191, 0, sizeof(v191));
            *(_WORD *)&v191[16] = 257;
            CA::OGL::Context::ClippedArray::start((CA::OGL::Context::ClippedArray *)&v190);
            *(_OWORD *)long long v188 = 0uLL;
            float v82 = v56;
            float v83 = v57;
            float v176 = v83;
            float v178 = v82;
            float v84 = v185;
            float v174 = v84;
            float v85 = v60;
            while (CA::OGL::Context::ClippedArray::next_rect((CA::OGL::Context::ClippedArray *)&v190, (int32x2_t *)v188))
            {
              __int16 v86 = *(_WORD *)(v5 + 832);
              float v87 = v60;
              float v88 = v174;
              float v89 = v176;
              float v90 = v178;
              if ((v86 & 0x40) != 0)
              {
                float v91 = (float)(*(_DWORD *)&v188[8] + *(_DWORD *)v188);
                float v92 = (float)*(int *)&v188[4];
                float v93 = (float)(*(_DWORD *)&v188[12] + *(_DWORD *)&v188[4]);
                float v90 = v178 <= (float)*(int *)v188 ? (float)*(int *)v188 : v178;
                float v89 = v176 >= v91 ? (float)(*(_DWORD *)&v188[8] + *(_DWORD *)v188) : v176;
                float v88 = v174 <= v92 ? (float)*(int *)&v188[4] : v174;
                float v87 = v85 >= v93 ? (float)(*(_DWORD *)&v188[12] + *(_DWORD *)&v188[4]) : v60;
                BOOL v94 = v176 > (float)*(int *)v188 && v178 < v91;
                BOOL v95 = v94 && v85 > v92;
                if (!v95 || v174 >= v93) {
                  continue;
                }
              }
              if (*(_DWORD *)(v5 + 92)) {
                uint64_t v97 = 6;
              }
              else {
                uint64_t v97 = 4;
              }
              if ((unint64_t)(*(void *)(v5 + 128) + 4) > *(void *)(v5 + 136)
                || (unint64_t v98 = *(void *)(v5 + 112)) != 0 && *(void *)(v5 + 104) + v97 > v98)
              {
                *(_WORD *)(v5 + 832) = v86 | 0x20;
                CA::OGL::Context::array_flush(v5);
                *(void *)(v5 + 128) = 0;
                *(void *)(v5 + 96) = v5 + 834;
                *(_OWORD *)(v5 + 104) = xmmword_184997E70;
              }
              CA::OGL::Context::array_rect((void *)v5, v90, v88, v89, v87);
              uint64_t v99 = *(void *)(v5 + 120) + 48 * *(void *)(v5 + 128);
              *(float16x4_t *)(v99 - 160) = v23;
              *(float16x4_t *)(v99 - 112) = v23;
              *(float16x4_t *)(v99 - 64) = v23;
              *(float16x4_t *)(v99 - 16) = v23;
            }
            double v25 = v165;
            double v31 = v172.f64[1];
          }
          int v62 = 0;
          *(unsigned char *)(*(void *)(v5 + 16) + 481) |= 1u;
        }
        else
        {
          int v62 = 1;
        }
        long long v189 = 0u;
        uint64_t v101 = *(void *)(*(void *)(v5 + 248) + 8);
        *(void *)long long v188 = v5;
        *(void *)&v188[8] = v101;
        memset(&v188[16], 0, 24);
        *(_WORD *)&v188[32] = 256;
        *(void *)&long long v189 = &v199;
        CA::OGL::Context::ClippedArray::start((CA::OGL::Context::ClippedArray *)v188);
        v186[0] = 0;
        v186[1] = 0;
        uint64_t v102 = v5 + 834;
        float v103 = v183;
        float v104 = v181;
        float v177 = v104;
        float v179 = v103;
        float v105 = v185;
        float v106 = v56 - v172.f64[0];
        float v107 = v185 - v31;
        float v171 = v107 * v106;
        float v108 = v169.f64[0];
        float v109 = 1.0;
        if (!v55) {
          float v108 = 1.0;
        }
        if (v58)
        {
          float v110 = v25;
          float v109 = v110;
        }
        float v170 = v108 * v107;
        float v111 = v182;
        float v175 = v111;
        float v112 = v167 - v57;
        float v168 = v107 * v112;
        float v166 = v109 * v106;
        if (v57 > v56) {
          int v113 = v62;
        }
        else {
          int v113 = 0;
        }
        float v164 = v109 * v108;
        float v163 = v109 * v112;
        float v114 = v161 - v60;
        float v162 = v114 * v106;
        float v160 = v108 * v114;
        float v159 = v114 * v112;
        float v115 = v180;
        float v173 = v115;
        while (1)
        {
          double result = CA::OGL::Context::ClippedArray::next_rect((CA::OGL::Context::ClippedArray *)v188, v186);
          if (!result) {
            break;
          }
          if (v185 > v181)
          {
            if (*(_DWORD *)(v5 + 92)) {
              uint64_t v116 = 18;
            }
            else {
              uint64_t v116 = 12;
            }
            if ((unint64_t)(*(void *)(v5 + 128) + 12) > *(void *)(v5 + 136)
              || (unint64_t v117 = *(void *)(v5 + 112)) != 0 && *(void *)(v5 + 104) + v116 > v117)
            {
              *(_WORD *)(v5 + 832) |= 0x20u;
              CA::OGL::Context::array_flush(v5);
              *(void *)(v5 + 128) = 0;
              *(void *)(v5 + 96) = v102;
              *(_OWORD *)(v5 + 104) = xmmword_184997E70;
            }
            if (v56 > v183)
            {
              float v118 = v56;
              CA::OGL::Context::array_rect((void *)v5, v179, v177, v118, v105);
              float16x4_t v119 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(v23), v171));
              uint64_t v120 = *(void *)(v5 + 120) + 48 * *(void *)(v5 + 128);
              *(float16x4_t *)(v120 - 160) = v119;
              *(float16x4_t *)(v120 - 112) = v119;
              *(float16x4_t *)(v120 - 64) = v119;
              *(float16x4_t *)(v120 - 16) = v119;
            }
            if (v57 > v56)
            {
              float v121 = v56;
              float v122 = v57;
              CA::OGL::Context::array_rect((void *)v5, v121, v177, v122, v105);
              float16x4_t v123 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(v23), v170));
              uint64_t v124 = *(void *)(v5 + 120) + 48 * *(void *)(v5 + 128);
              *(float16x4_t *)(v124 - 160) = v123;
              *(float16x4_t *)(v124 - 112) = v123;
              *(float16x4_t *)(v124 - 64) = v123;
              *(float16x4_t *)(v124 - 16) = v123;
            }
            if (v182 > v57)
            {
              float v125 = v57;
              CA::OGL::Context::array_rect((void *)v5, v125, v177, v175, v105);
              float16x4_t v126 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(v23), v168));
              uint64_t v127 = *(void *)(v5 + 120) + 48 * *(void *)(v5 + 128);
              *(float16x4_t *)(v127 - 160) = v126;
              *(float16x4_t *)(v127 - 112) = v126;
              *(float16x4_t *)(v127 - 64) = v126;
              *(float16x4_t *)(v127 - 16) = v126;
            }
          }
          if (v60 > v185)
          {
            if (*(_DWORD *)(v5 + 92)) {
              uint64_t v128 = 18;
            }
            else {
              uint64_t v128 = 12;
            }
            if ((unint64_t)(*(void *)(v5 + 128) + 12) > *(void *)(v5 + 136)
              || (unint64_t v129 = *(void *)(v5 + 112)) != 0 && *(void *)(v5 + 104) + v128 > v129)
            {
              *(_WORD *)(v5 + 832) |= 0x20u;
              CA::OGL::Context::array_flush(v5);
              *(void *)(v5 + 128) = 0;
              *(void *)(v5 + 96) = v102;
              *(_OWORD *)(v5 + 104) = xmmword_184997E70;
            }
            if (v56 > v183)
            {
              float v130 = v56;
              float v131 = v60;
              CA::OGL::Context::array_rect((void *)v5, v179, v105, v130, v131);
              float16x4_t v132 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(v23), v166));
              uint64_t v133 = *(void *)(v5 + 120) + 48 * *(void *)(v5 + 128);
              *(float16x4_t *)(v133 - 160) = v132;
              *(float16x4_t *)(v133 - 112) = v132;
              *(float16x4_t *)(v133 - 64) = v132;
              *(float16x4_t *)(v133 - 16) = v132;
            }
            if (v113)
            {
              float v134 = v56;
              float v135 = v57;
              float v136 = v60;
              CA::OGL::Context::array_rect((void *)v5, v134, v105, v135, v136);
              float16x4_t v137 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(v23), v164));
              uint64_t v138 = *(void *)(v5 + 120) + 48 * *(void *)(v5 + 128);
              *(float16x4_t *)(v138 - 160) = v137;
              *(float16x4_t *)(v138 - 112) = v137;
              *(float16x4_t *)(v138 - 64) = v137;
              *(float16x4_t *)(v138 - 16) = v137;
            }
            if (v182 > v57)
            {
              float v139 = v57;
              float v140 = v60;
              CA::OGL::Context::array_rect((void *)v5, v139, v105, v175, v140);
              float16x4_t v141 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(v23), v163));
              uint64_t v142 = *(void *)(v5 + 120) + 48 * *(void *)(v5 + 128);
              *(float16x4_t *)(v142 - 160) = v141;
              *(float16x4_t *)(v142 - 112) = v141;
              *(float16x4_t *)(v142 - 64) = v141;
              *(float16x4_t *)(v142 - 16) = v141;
            }
          }
          if (v180 > v60)
          {
            if (*(_DWORD *)(v5 + 92)) {
              uint64_t v143 = 18;
            }
            else {
              uint64_t v143 = 12;
            }
            if ((unint64_t)(*(void *)(v5 + 128) + 12) > *(void *)(v5 + 136)
              || (unint64_t v144 = *(void *)(v5 + 112)) != 0 && *(void *)(v5 + 104) + v143 > v144)
            {
              *(_WORD *)(v5 + 832) |= 0x20u;
              CA::OGL::Context::array_flush(v5);
              *(void *)(v5 + 128) = 0;
              *(void *)(v5 + 96) = v102;
              *(_OWORD *)(v5 + 104) = xmmword_184997E70;
            }
            if (v56 > v183)
            {
              float v145 = v60;
              float v146 = v56;
              CA::OGL::Context::array_rect((void *)v5, v179, v145, v146, v173);
              float16x4_t v147 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(v23), v162));
              uint64_t v148 = *(void *)(v5 + 120) + 48 * *(void *)(v5 + 128);
              *(float16x4_t *)(v148 - 160) = v147;
              *(float16x4_t *)(v148 - 112) = v147;
              *(float16x4_t *)(v148 - 64) = v147;
              *(float16x4_t *)(v148 - 16) = v147;
            }
            if (v57 > v56)
            {
              float v149 = v56;
              float v150 = v60;
              float v151 = v57;
              CA::OGL::Context::array_rect((void *)v5, v149, v150, v151, v173);
              float16x4_t v152 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(v23), v160));
              uint64_t v153 = *(void *)(v5 + 120) + 48 * *(void *)(v5 + 128);
              *(float16x4_t *)(v153 - 160) = v152;
              *(float16x4_t *)(v153 - 112) = v152;
              *(float16x4_t *)(v153 - 64) = v152;
              *(float16x4_t *)(v153 - 16) = v152;
            }
            if (v182 > v57)
            {
              float v154 = v57;
              float v155 = v60;
              CA::OGL::Context::array_rect((void *)v5, v154, v155, v175, v173);
              float16x4_t v156 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(v23), v159));
              uint64_t v157 = *(void *)(v5 + 120) + 48 * *(void *)(v5 + 128);
              *(float16x4_t *)(v157 - 160) = v156;
              *(float16x4_t *)(v157 - 112) = v156;
              *(float16x4_t *)(v157 - 64) = v156;
              *(float16x4_t *)(v157 - 16) = v156;
            }
          }
        }
        if (!v28) {
          goto LABEL_17;
        }
        v190.f64[0] = v183;
        v190.f64[1] = v181;
        *(_OWORD *)long long v191 = xmmword_184997D60;
        *(double *)&v191[16] = v182;
        *(double *)uint64_t v192 = v181;
        *(_OWORD *)&v192[8] = xmmword_184997D60;
        double v193 = v182;
        double v194 = v180;
        long long v195 = xmmword_184997D60;
        double v196 = v183;
        double v197 = v180;
        long long v198 = xmmword_184997D60;
        if ((*(unsigned char *)(a2 + 18) & 4) != 0) {
          uint64_t v158 = *(void *)(*(void *)(v5 + 16) + 8);
        }
        else {
          uint64_t v158 = 0;
        }
        uint64_t v187 = v158;
        double v100 = &v187;
      }
      else
      {
        if ((*(_DWORD *)(a2 + 16) & 0x100000) != 0)
        {
          double v63 = ceil(v30 + -0.001);
          float64x2_t v64 = vrndmq_f64(vaddq_f64(v172, (float64x2_t)vdupq_n_s64(0x3F50624DD2F1A9FCuLL)));
          double v65 = ceil(v32 + -0.001);
        }
        else
        {
          double v63 = round(v30);
          float64x2_t v64 = vrndaq_f64(v172);
          double v65 = round(v32);
        }
        double v66 = v64.f64[1];
        if (v65 > v64.f64[1] && v63 > v64.f64[0])
        {
          float64x2_t v184 = v64;
          uint64_t v68 = *(void *)(v5 + 16);
          char v69 = *(unsigned char *)(v68 + 481);
          unsigned int v70 = *(_DWORD *)&v69 & ((*(_DWORD *)(a2 + 16) & 0x8000u) >> 15);
          if (v70 == 1) {
            *(unsigned char *)(v68 + 481) = v69 & 0xFE;
          }
          *(_OWORD *)uint64_t v192 = 0u;
          float64_t v71 = *(double *)(*(void *)(v5 + 248) + 8);
          *(void *)&v190.f64[0] = v5;
          v190.f64[1] = v71;
          memset(v191, 0, sizeof(v191));
          *(_WORD *)&v191[16] = 256;
          *(void *)uint64_t v192 = &v199;
          CA::OGL::Context::ClippedArray::start((CA::OGL::Context::ClippedArray *)&v190);
          *(_OWORD *)long long v188 = 0uLL;
          while (1)
          {
            double result = CA::OGL::Context::ClippedArray::next_rect((CA::OGL::Context::ClippedArray *)&v190, (int32x2_t *)v188);
            if (!result) {
              break;
            }
            if (*(_DWORD *)(v5 + 92)) {
              uint64_t v76 = 6;
            }
            else {
              uint64_t v76 = 4;
            }
            if ((unint64_t)(*(void *)(v5 + 128) + 4) > *(void *)(v5 + 136)
              || (unint64_t v77 = *(void *)(v5 + 112)) != 0 && *(void *)(v5 + 104) + v76 > v77)
            {
              *(_WORD *)(v5 + 832) |= 0x20u;
              CA::OGL::Context::array_flush(v5);
              *(void *)(v5 + 128) = 0;
              *(void *)(v5 + 96) = v5 + 834;
              *(_OWORD *)(v5 + 104) = xmmword_184997E70;
            }
            float v73 = v66;
            float v74 = v63;
            float v75 = v65;
            float v72 = v184.f64[0];
            CA::OGL::Context::array_rect((void *)v5, v72, v73, v74, v75);
            uint64_t v78 = *(void *)(v5 + 120) + 48 * *(void *)(v5 + 128);
            *(float16x4_t *)(v78 - 160) = v23;
            *(float16x4_t *)(v78 - 112) = v23;
            *(float16x4_t *)(v78 - 64) = v23;
            *(float16x4_t *)(v78 - 16) = v23;
          }
          if (v70) {
            *(unsigned char *)(*(void *)(v5 + 16) + 481) |= 1u;
          }
          float64x2_t v64 = v184;
        }
        if (!v28) {
          goto LABEL_17;
        }
        float64x2_t v190 = v64;
        *(_OWORD *)long long v191 = xmmword_184997D60;
        *(double *)&v191[16] = v63;
        *(double *)uint64_t v192 = v66;
        *(_OWORD *)&v192[8] = xmmword_184997D60;
        double v193 = v63;
        double v194 = v65;
        long long v195 = xmmword_184997D60;
        double v196 = v64.f64[0];
        double v197 = v65;
        long long v198 = xmmword_184997D60;
        if ((*(unsigned char *)(a2 + 18) & 4) != 0) {
          uint64_t v79 = *(void *)(*(void *)(v5 + 16) + 8);
        }
        else {
          uint64_t v79 = 0;
        }
        *(void *)long long v188 = v79;
        double v100 = (uint64_t *)v188;
      }
      double result = CA::OGL::emit_quad_surround(v5, v190.f64, v100);
LABEL_17:
      *(unsigned char *)(*(void *)(v5 + 16) + 16) = 0;
      return result;
    }
    if (!v7)
    {
      float64x2_t v190 = 0u;
      *(_OWORD *)long long v191 = 0u;
      memset(v188, 0, 32);
      v186[0] = 0;
      uint64_t v187 = 0;
      uint64_t v12 = *(void *)(v5 + 16);
      unint64_t v13 = *(void *)(v12 + 16) & 0xFFFFFF00FF00FF00;
      if (*(void *)(v12 + 8) == 0x3C003C003C003C00) {
        int v14 = 1;
      }
      else {
        int v14 = 3;
      }
      *(_DWORD *)(v12 + 16) = v14 | v13;
      *(_DWORD *)(v12 + 20) = HIDWORD(v13);
      BOOL v15 = !CA::Transform::is_isotropic(*(CA::Transform **)(a2 + 8), 0.0, a2, (uint64_t)a3, a4);
      (*(void (**)(uint64_t, void, BOOL, void, uint64_t *))(*(void *)v5 + 448))(v5, 0, v15, 0, &v187);
      float v16 = *(float *)&v187;
      int v17 = *(_DWORD *)(a2 + 20);
      if (v17) {
        float v18 = *(float *)&v187;
      }
      else {
        float v18 = *(float *)&v187 + (float)((float)(*((float *)&v187 + 1) - *(float *)&v187) * 0.5);
      }
      *(float *)v200.f64 = v18;
      *((float *)v200.f64 + 1) = *(float *)&v187 + (float)((float)(*((float *)&v187 + 1) - *(float *)&v187) * 0.5);
      if ((v17 & 2) != 0) {
        float v19 = *((float *)&v187 + 1);
      }
      else {
        float v19 = *(float *)&v187 + (float)((float)(*((float *)&v187 + 1) - *(float *)&v187) * 0.5);
      }
      *(float *)&v200.f64[1] = *(float *)&v187 + (float)((float)(*((float *)&v187 + 1) - *(float *)&v187) * 0.5);
      *((float *)&v200.f64[1] + 1) = v19;
      if ((v17 & 4) == 0) {
        float v16 = *(float *)&v187 + (float)((float)(*((float *)&v187 + 1) - *(float *)&v187) * 0.5);
      }
      *(float *)v199.i32 = v16;
      *(float *)&v199.i32[1] = *(float *)&v187 + (float)((float)(*((float *)&v187 + 1) - *(float *)&v187) * 0.5);
      if ((v17 & 8) != 0) {
        float v20 = *((float *)&v187 + 1);
      }
      else {
        float v20 = *(float *)&v187 + (float)((float)(*((float *)&v187 + 1) - *(float *)&v187) * 0.5);
      }
      *(float *)&v199.i32[2] = *(float *)&v187 + (float)((float)(*((float *)&v187 + 1) - *(float *)&v187) * 0.5);
      *(float *)&v199.i32[3] = v20;
      CA::OGL::emit_nine_part_rect(v5, a2, (uint64_t)&v190, (uint64_t)v188, (uint64_t)&v200, (uint64_t)&v199, 0, 0, (*(double *)v186 >= *(double *)(v5 + 72)) << 17);
      double result = (*(uint64_t (**)(uint64_t, void, void))(*(void *)v5 + 520))(v5, 0, 0);
      goto LABEL_17;
    }
LABEL_16:
    *(unsigned char *)(*(void *)(v5 + 16) + 16) = 0;
    double result = (uint64_t)CA::OGL::emit_one_part_rect((CA::OGL::Context *)v5, a2, 0, 0, 0);
    goto LABEL_17;
  }
  return result;
}

double CA::OGL::Context::bind_supercircle(CA::OGL::Context *this, unsigned int a2, int a3, BOOL a4, BOOL a5, float *a6, int a7, float *a8)
{
  uint64_t v8 = *((void *)this + 2);
  *(_OWORD *)(v8 + 16 * a2 + 96) = xmmword_184997ED0;
  *(unsigned char *)(v8 + a2 + 17) = byte_184998ABC[a7];
  if (a8) {
    *(void *)&long long v9 = *(void *)a8;
  }
  else {
    *(void *)&long long v9 = 0;
  }
  *((void *)&v9 + 1) = v9;
  *(_OWORD *)(*((void *)this + 2) + 48 * a2 + 416) = v9;
  double result = 0.00781250557;
  *(void *)a6 = 0x3F800000BF800000;
  return result;
}

uint64_t CA::Render::Texture::image_format(CA::Render::Texture *this)
{
  return 0xFFFFFFFFLL;
}

uint64_t CA::Render::Surface::bit_depth(CA::Render::Surface *this)
{
  uint64_t v1 = *((unsigned int *)this + 27);
  if (v1 == -1)
  {
    uint64_t result = *((unsigned int *)this + 32);
    if (result) {
      return CA::Render::ycbcr_fourcc_depth((CA::Render *)result);
    }
  }
  else if ((v1 - 33) >= 3)
  {
    if (v1 > 0x23) {
      return 0;
    }
    else {
      return dword_184999500[v1];
    }
  }
  else
  {
    return 9;
  }
  return result;
}

char *CA::Render::GradientLayer::color_map(char *this, uint64_t a2, int a3)
{
  char v3 = this;
  v68[1] = *(void (**)(const void *, void *))MEMORY[0x1E4F143B8];
  if ((*(unsigned char *)(a2 + 13) & 8) != 0)
  {
    uint64_t v6 = *(void *)(a2 + 112);
    if (v6)
    {
      BOOL v7 = (atomic_uint *)(v6 + 8);
      if (!atomic_fetch_add((atomic_uint *volatile)(v6 + 8), 1u))
      {
        uint64_t v6 = 0;
        atomic_fetch_add(v7, 0xFFFFFFFF);
      }
    }
    *(void *)this = v6;
  }
  else
  {
    if (a3) {
      uint64_t v4 = 120;
    }
    else {
      uint64_t v4 = 112;
    }
    this = *(char **)(a2 + v4);
    if (this) {
      goto LABEL_6;
    }
    v68[0] = 0;
    if (*(void *)(a2 + 32) >= 2uLL)
    {
      uint64_t v8 = (CA::Render *)(a3 ? 13 : 1);
      uint64_t v9 = a3 ? 256 : 512;
      char v64 = a3;
      double v67 = (CA::Render *)CA::Render::format_rowbytes(v8, v9);
      this = (char *)CA::Render::aligned_malloc(v67, (unint64_t *)v68, 0);
      char v12 = v64;
      uint64_t v13 = a2;
      if (this)
      {
        float v14 = 1.0 / (float)v9;
        unint64_t v15 = *(void *)(a2 + 32);
        float v16 = *(float **)(a2 + 56);
        uint64_t v17 = v9;
        int v62 = (CA::Render::Image *)v4;
        unsigned int v61 = v8;
        if (v16) {
          float v18 = *v16;
        }
        else {
          float v18 = 0.0;
        }
        LODWORD(v19) = 0;
        int v20 = 0;
        float64x2_t v21 = *(CA::Render::TimingFunction **)(a2 + 64);
        uint64_t v22 = *(void *)(a2 + 48);
        float v23 = v14 * 0.5;
        __asm { FMOV            V14.2S, #1.0 }
        int v29 = v21;
        double v30 = v21;
        uint64_t v31 = v22;
        float v32 = v18;
        double v60 = (CGColorSpace *)this;
        double v33 = this;
        float v34 = 1.0 / (float)(v18 - v18);
        unsigned int v63 = v17;
        do
        {
          if (v23 >= v18)
          {
            double v35 = v29;
            float v36 = v18;
            do
            {
              uint64_t v31 = v22;
              unint64_t v19 = (v19 + 1);
              float v18 = 2.0;
              if (v15 <= v19)
              {
                float v36 = 2.0;
                int v29 = v35;
              }
              else
              {
                if (v16) {
                  float v18 = v16[v19];
                }
                else {
                  float v18 = v36 + (float)(1.0 / (float)(v15 - 1));
                }
                v22 += 16;
                int v29 = (CA::Render::TimingFunction *)((char *)v35 + 32 * (v21 != 0));
                if (!v21) {
                  double v35 = v30;
                }
                float v34 = 1.0 / (float)(v18 - v36);
              }
              double v30 = v35;
              float v32 = v36;
              double v35 = v29;
              float v36 = v18;
            }
            while (v23 >= v18);
          }
          if (v18 > v32)
          {
            float v41 = v34 * (float)(v23 - v32);
            if (v21)
            {
              double v66 = v33;
              *(double *)v10.i64 = CA::Render::TimingFunction::evaluate(v30, (const double *)v17, v41, 0.00001);
              uint64_t v13 = a2;
              double v33 = v66;
              uint64_t v17 = v63;
              char v12 = v64;
              float v41 = *(double *)v10.i64;
            }
            float v42 = *(float *)v31;
            if ((*(unsigned char *)(v13 + 29) & 0x10) != 0)
            {
              float v43 = *(float *)(v31 + 12);
              float v44 = *(float *)(v22 + 12);
              float v37 = (float)(v43 * v42)
                  + (float)((float)-(float)((float)(v43 * v42) - (float)(v44 * *(float *)v22)) * v41);
              float32x2_t v45 = vmul_n_f32(*(float32x2_t *)(v31 + 4), v43);
              float32x2_t v38 = vmla_n_f32(v45, vmla_n_f32(vneg_f32(v45), *(float32x2_t *)(v22 + 4), v44), v41);
              float v39 = v43 + (float)((float)(v44 - v43) * v41);
              int v40 = 1;
            }
            else
            {
              int v40 = 0;
              float v37 = v42 + (float)((float)(*(float *)v22 - v42) * v41);
              float32x2_t v38 = vmla_n_f32(*(float32x2_t *)(v31 + 4), vsub_f32(*(float32x2_t *)(v22 + 4), *(float32x2_t *)(v31 + 4)), v41);
              float v39 = *(float *)(v31 + 12) + (float)((float)(*(float *)(v22 + 12) - *(float *)(v31 + 12)) * v41);
            }
          }
          else
          {
            float v37 = *(float *)v31;
            float32x2_t v38 = *(float32x2_t *)(v31 + 4);
            float v39 = *(float *)(v31 + 12);
            int v40 = *(_DWORD *)(v13 + 28) & 0x1000;
          }
          if (v40) {
            BOOL v46 = v18 <= v32;
          }
          else {
            BOOL v46 = 1;
          }
          if (v46) {
            float v47 = v39;
          }
          else {
            float v47 = 1.0;
          }
          *(float *)v10.i32 = v47 * v37;
          *(float32x2_t *)v11.i8 = vmul_n_f32(v38, v47);
          if (v12)
          {
            int8x16_t v11 = vextq_s8(v10, v11, 0xCuLL);
            v11.i32[0] = v10.i32[0];
            *(float *)&v11.i32[3] = v39;
            *(float16x4_t *)v10.i8 = vcvt_f16_f32((float32x4_t)v11);
            *double v33 = v10.i64[0];
            uint64_t v48 = 8;
          }
          else
          {
            if (*(float *)v10.i32 > 1.0) {
              *(float *)v10.i32 = 1.0;
            }
            _D2 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*(float32x2_t *)v11.i8, _D14), (int8x8_t)_D14, *(int8x8_t *)v11.i8);
            int32x2_t v50 = vcltz_f32(_D2);
            _S4 = 1132396544;
            if (*(float *)v10.i32 >= 0.0) {
              float v52 = (float)(*(float *)v10.i32 * 255.0) + 0.5;
            }
            else {
              float v52 = 0.5;
            }
            unsigned int v53 = v52;
            unsigned int v54 = vmlas_n_f32(0.5, 255.0, _D2.f32[0]) << 8;
            if (v50.i8[0]) {
              unsigned int v55 = 0;
            }
            else {
              unsigned int v55 = v54;
            }
            __asm { FMLA            S0, S4, V2.S[1] }
            if (v50.i8[4]) {
              unsigned int v57 = 0;
            }
            else {
              unsigned int v57 = _S0;
            }
            *(_DWORD *)double v33 = v57 | ((float)((float)(v39 * 255.0) + 0.5) << 24) | (v53 << 16) | v55;
            uint64_t v48 = 4;
          }
          double v33 = (void *)((char *)v33 + v48);
          ++v20;
          float v23 = v23 + v14;
        }
        while (v20 != v17);
        this = (char *)CA::Render::Image::new_image((CA::Render::Image *)v61, v17, 1u, 1u, *(CGColorSpace **)(v13 + 128), v60, (unint64_t *)&v67, (const unint64_t *)CA::Render::release_image_data, v68[0], v60);
        uint64_t v58 = a2;
        double v59 = *(atomic_uint **)((char *)v62 + a2);
        *(void *)((char *)v62 + a2) = this;
        if (v59)
        {
          if (atomic_fetch_add(v59 + 2, 0xFFFFFFFF) == 1)
          {
            (*(void (**)(atomic_uint *))(*(void *)v59 + 16))(v59);
            uint64_t v58 = a2;
          }
          this = *(char **)((char *)v62 + v58);
          if (!this) {
            goto LABEL_8;
          }
        }
        else if (!this)
        {
LABEL_8:
          *char v3 = this;
          return this;
        }
LABEL_6:
        uint64_t v5 = (atomic_uint *)(this + 8);
        if (!atomic_fetch_add((atomic_uint *volatile)this + 2, 1u))
        {
          this = 0;
          atomic_fetch_add(v5, 0xFFFFFFFF);
        }
        goto LABEL_8;
      }
    }
    *char v3 = 0;
  }
  return this;
}

double CA::Transform::get_scale(CA::Mat4Impl *this, double *a2, double *a3, double *a4)
{
  if ((*((unsigned char *)this + 144) & 0x10) != 0) {
    return CA::Mat4Impl::mat4_get_scale(this, a2, a3, a4);
  }
  if (a2) {
    *a2 = *((double *)this + 16);
  }
  if (a3) {
    *a3 = *((double *)this + 16);
  }
  return *((double *)this + 16);
}

uint64_t CA::OGL::fill_color_rect(uint64_t a1, uint64_t a2, double *a3, double *a4, double a5, int8x16_t a6)
{
  unsigned int v7 = bswap32(a3);
  a6.i32[0] = v7;
  a6.i32[1] = v7 >> 8;
  a6.i32[2] = HIWORD(v7);
  v8.i64[0] = 0xFF000000FFLL;
  v8.i64[1] = 0xFF000000FFLL;
  int32x4_t v9 = (int32x4_t)vandq_s8(a6, v8);
  v9.i32[3] = vshrq_n_u32((uint32x4_t)vdupq_n_s32(v7), 0x18uLL).i32[3];
  *(float16x4_t *)(*(void *)(a1 + 16) + 8) = vcvt_f16_f32(vmulq_f32(vcvtq_f32_s32(v9), (float32x4_t)vdupq_n_s32(0x3B808081u)));
  if ((_BYTE)a3 == 0xFF)
  {
    int v10 = *(_DWORD *)(a2 + 16);
    uint64_t v11 = *(void *)(a1 + 16);
    char v12 = *(unsigned char *)(v11 + 480);
    *(unsigned char *)(v11 + 480) = 3;
    if (!v10) {
      goto LABEL_6;
    }
  }
  else
  {
    uint64_t v11 = *(void *)(a1 + 16);
    char v12 = *(unsigned char *)(v11 + 480);
    *(unsigned char *)(v11 + 480) = 3;
  }
  *(unsigned char *)(v11 + 481) |= 1u;
LABEL_6:
  uint64_t result = CA::OGL::fill_rect(a1, a2, a3, a4);
  *(unsigned char *)(*(void *)(a1 + 16) + 481) &= ~1u;
  *(unsigned char *)(*(void *)(a1 + 16) + 480) = v12;
  return result;
}

BOOL CA::OGL::MetalContext::edge_mode_supported(uint64_t a1, uint64_t a2, int a3)
{
  return !a3 || a2 && *(unsigned char *)(a2 + 12) == 23;
}

float CA::OGL::pattern_texcoords(float64x2_t *a1, float *a2, uint64_t a3, float64x2_t a4, float64x2_t a5, float64x2_t a6)
{
  v6.f64[0] = a1[1].f64[0];
  v6.f64[1] = a1[2].f64[1];
  __asm { FMOV            V4.2D, #1.0 }
  _Q3 = vdivq_f64(_Q4, vmulq_f64(a1[6], v6));
  _Q0 = vsubq_f64(a4, vaddq_f64(a1[3], a6));
  _D2 = vcvt_f32_f64(vmulq_f64(_Q0, _Q3));
  *(float32x2_t *)&_Q0.f64[0] = vcvt_f32_f64(vmulq_f64(vaddq_f64(_Q0, a5), _Q3));
  *(float32x2_t *)a3 = _D2;
  *(float64_t *)(a3 + 8) = _Q0.f64[0];
  float v15 = vmlas_n_f32(*a2, a2[2] - *a2, _D2.f32[0]);
  *(float *)a3 = v15;
  *(float *)_Q4.f64 = a2[3] - a2[1];
  __asm { FMLA            S3, S4, V2.S[1] }
  *(_DWORD *)(a3 + 4) = LODWORD(_Q3.f64[0]);
  _D2.f32[0] = vmlas_n_f32(*a2, a2[2] - *a2, *(float *)_Q0.f64);
  *(_DWORD *)(a3 + 8) = _D2.i32[0];
  _S5 = a2[3] - a2[1];
  __asm { FMLA            S4, S5, V0.S[1] }
  *(float *)_Q0.f64 = floorf(v15);
  float v17 = floorf(*(float *)_Q3.f64);
  *(float *)a3 = v15 - *(float *)_Q0.f64;
  *(float *)(a3 + 4) = *(float *)_Q3.f64 - v17;
  float result = _D2.f32[0] - *(float *)_Q0.f64;
  *(float *)(a3 + 8) = result;
  *(float *)(a3 + 12) = *(float *)_Q4.f64 - v17;
  return result;
}

BOOL CA::Mat4Impl::mat4_is_affine_with_z_translate(CA::Mat4Impl *this, const double *a2)
{
  return *((double *)this + 2) == 0.0
      && *((double *)this + 3) == 0.0
      && *((double *)this + 6) == 0.0
      && *((double *)this + 7) == 0.0
      && *((double *)this + 8) == 0.0
      && *((double *)this + 9) == 0.0
      && *((double *)this + 10) == 1.0
      && *((double *)this + 11) == 0.0
      && *((double *)this + 15) == 1.0;
}

uint64_t CA::OGL::emit_quad_surround(uint64_t a1, const double *a2, uint64_t *a3)
{
  uint64_t v5 = 0;
  uint64_t v119 = *MEMORY[0x1E4F143B8];
  float64x2_t v117 = 0u;
  long long v118 = 0u;
  float64x2_t v115 = 0u;
  float64x2_t v116 = 0u;
  long long v113 = 0u;
  long long v114 = 0u;
  float64x2_t v6 = &v115;
  float64x2_t v7 = (float64x2_t)vdupq_n_s64(0x3F50624DD2F1A9FCuLL);
  __asm
  {
    FMOV            V1.2D, #-1.0
    FMOV            V2.2D, #1.0
  }
  int8x16_t v13 = (int8x16_t)vdupq_n_s64(0x7FF0000000000000uLL);
  do
  {
    float64x2x4_t v121 = vld4q_f64(a2);
    a2 += 8;
    int8x16_t v14 = (int8x16_t)vcgtq_f64(v7, vabsq_f64(vaddq_f64(v121.val[3], _Q1)));
    int8x16_t v15 = (int8x16_t)vcgtzq_f64(v121.val[3]);
    float64x2_t v16 = (float64x2_t)vbslq_s8(vbicq_s8(vmvnq_s8(v14), v15), v13, vbslq_s8(vbicq_s8(v15, v14), (int8x16_t)vdivq_f64((float64x2_t)_Q2, v121.val[3]), _Q2));
    v120.val[0] = vmulq_f64(v121.val[0], v16);
    v120.val[1] = vmulq_f64(v121.val[1], v16);
    *(void *)&float64_t v17 = v6[1].f64;
    *(void *)&v121.val[0].f64[0] = v6;
    vst2q_f64(v6->f64, v120);
    v6 += 2;
    v121.val[0].f64[1] = v17;
    *(long long *)((char *)&v113 + v5) = (__int128)v121.val[0];
    v5 += 16;
  }
  while (v5 != 32);
  int8x16_t v18 = (int8x16_t)vsubq_f64(v117, v116);
  float64x2_t v19 = vmulq_f64((float64x2_t)vextq_s8(v18, v18, 8uLL), vsubq_f64(v116, v115));
  uint64_t v20 = v113;
  if (vsubq_f64(v19, (float64x2_t)vdupq_laneq_s64((int64x2_t)v19, 1)).f64[0] >= 0.0)
  {
    uint64_t v21 = *((void *)&v113 + 1);
  }
  else
  {
    uint64_t v21 = v114;
    uint64_t v22 = *((void *)&v113 + 1);
    *(void *)&long long v113 = *((void *)&v114 + 1);
    *((void *)&v113 + 1) = v114;
    *(void *)&long long v114 = v22;
    *((void *)&v114 + 1) = v20;
    uint64_t v20 = v113;
  }
  char v23 = 0;
  double v24 = *(double *)(v20 + 8);
  double v25 = *(double *)(v21 + 8);
  BOOL v26 = v24 >= v25;
  BOOL v27 = v24 < v25;
  uint64_t v28 = 2;
  do
  {
    BOOL v29 = v26;
    char v30 = v23;
    double v31 = *(double *)(*((void *)&v113 + v28) + 8);
    if (v31 >= *(double *)(*((void *)&v113 + v26) + 8))
    {
      if (v31 < *(double *)(*((void *)&v113 + v27) + 8)) {
        BOOL v27 = v28;
      }
    }
    else
    {
      BOOL v26 = v28;
      BOOL v27 = v29;
    }
    char v23 = 1;
    uint64_t v28 = 3;
  }
  while ((v30 & 1) == 0);
  double v32 = **((double **)&v113 + v26);
  double v33 = **((double **)&v113 + v27);
  double v34 = vabdd_f64(v32, v33);
  if (v32 < v33 || v34 < 0.001) {
    BOOL v27 = v26;
  }
  float v36 = (float64x2_t *)*((void *)&v113 + v27);
  float v37 = (float64x2_t *)*((void *)&v113 + ((v27 + 1) & 3));
  float32x2_t v38 = (float64x2_t *)*((void *)&v113 + ((v27 + 2) & 3));
  float v39 = (float64x2_t *)*((void *)&v113 + (v27 ? 0 : 3));
  long long v108 = 0uLL;
  uint64_t result = CA::Shape::get_bounds(*(void *)(*(void *)(a1 + 248) + 8), (int *)&v108);
  float v41 = *(int32x2_t **)(a1 + 264);
  if (v41) {
    float v42 = v41 + 4;
  }
  else {
    float v42 = (int32x2_t *)(a1 + 200);
  }
  uint32x2_t v43 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)((char *)&v108 + 8));
  if ((vpmax_u32(v43, v43).u32[0] & 0x80000000) == 0)
  {
    int32x2_t v44 = v42[1];
    uint32x2_t v45 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v44);
    if ((vpmax_u32(v45, v45).u32[0] & 0x80000000) == 0)
    {
      int32x2_t v46 = vmax_s32(*(int32x2_t *)&v108, *v42);
      int32x2_t v47 = vmin_s32(vadd_s32(*(int32x2_t *)&v108, *(int32x2_t *)((char *)&v108 + 8)), vadd_s32(*v42, v44));
      int32x2_t v48 = vsub_s32(v47, v46);
      uint32x2_t v49 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v48);
      if ((vpmax_u32(v49, v49).u32[0] & 0x80000000) == 0)
      {
        *(int32x2_t *)&long long v50 = v46;
        *((int32x2_t *)&v50 + 1) = v48;
        long long v108 = v50;
        v51.i64[0] = v47.i32[0];
        v51.i64[1] = v46.i32[1];
        float64x2_t v52 = vcvtq_f64_s64(v51);
        v51.i64[0] = v46.i32[0];
        v51.i64[1] = v47.i32[1];
        float64x2_t v105 = v52;
        float64x2_t v106 = vcvtq_f64_s64(v51);
        unsigned int v53 = *(const void **)(a1 + 16);
        memcpy(__dst, v53, sizeof(__dst));
        __dst[0] = v53;
        *(void *)(a1 + 16) = __dst;
        LOBYTE(__dst[2]) = 0;
        long long v111 = 0u;
        uint64_t v54 = *(void *)(*(void *)(a1 + 248) + 8);
        v109[0] = a1;
        v109[1] = v54;
        long long v110 = 0u;
        v109[2] = 0;
        WORD4(v110) = 256;
        CA::OGL::Context::ClippedArray::start((CA::OGL::Context::ClippedArray *)v109);
        v107[0] = 0;
        v107[1] = 0;
        v55.f64[0] = v105.f64[0];
        v55.f64[1] = v106.f64[1];
        float64x2_t v104 = v55;
        v55.f64[0] = v106.f64[0];
        v55.f64[1] = v105.f64[1];
        float64x2_t v103 = v55;
        while (1)
        {
          uint64_t result = CA::OGL::Context::ClippedArray::next_rect((CA::OGL::Context::ClippedArray *)v109, v107);
          if (!result) {
            break;
          }
          if (*(_DWORD *)(a1 + 92)) {
            uint64_t v56 = 48;
          }
          else {
            uint64_t v56 = 32;
          }
          if ((unint64_t)(*(void *)(a1 + 128) + 32) > *(void *)(a1 + 136)
            || (unint64_t v57 = *(void *)(a1 + 112)) != 0 && *(void *)(a1 + 104) + v56 > v57)
          {
            *(_WORD *)(a1 + 832) |= 0x20u;
            CA::OGL::Context::array_flush(a1);
            *(void *)(a1 + 128) = 0;
            *(void *)(a1 + 96) = a1 + 834;
            *(_OWORD *)(a1 + 104) = xmmword_184997E70;
          }
          double v58 = v36->f64[1];
          v59.f64[0] = v106.f64[0];
          if (v36->f64[0] > v106.f64[0] && v58 > v105.f64[1])
          {
            v61.f64[1] = v105.f64[1];
            v61.f64[0] = v36->f64[0];
            v59.f64[1] = v36->f64[1];
            CA::OGL::Context::array_quad((void *)a1, v103, v61, *v36, v59);
            uint64_t v62 = *a3;
            uint64_t v63 = *(void *)(a1 + 120) + 48 * *(void *)(a1 + 128);
            *(void *)(v63 - 160) = *a3;
            *(void *)(v63 - 112) = v62;
            *(void *)(v63 - 64) = v62;
            *(void *)(v63 - 16) = v62;
            double v58 = v36->f64[1];
          }
          double v64 = v37->f64[1];
          if (v58 > v105.f64[1] || v64 > v105.f64[1])
          {
            if (v58 >= v105.f64[1]) {
              double v58 = v105.f64[1];
            }
            if (v64 >= v58) {
              double v66 = v58;
            }
            else {
              double v66 = v37->f64[1];
            }
            v67.f64[0] = v36->f64[0];
            v67.f64[1] = v66;
            v68.f64[0] = v37->f64[0];
            v68.f64[1] = v66;
            CA::OGL::Context::array_quad((void *)a1, v67, v68, *v37, *v36);
            uint64_t v69 = *a3;
            uint64_t v70 = *(void *)(a1 + 120) + 48 * *(void *)(a1 + 128);
            *(void *)(v70 - 160) = *a3;
            *(void *)(v70 - 112) = v69;
            *(void *)(v70 - 64) = v69;
            *(void *)(v70 - 16) = v69;
          }
          double v71 = v37->f64[0];
          v72.f64[0] = v105.f64[0];
          if (v37->f64[0] < v105.f64[0] && v37->f64[1] > v105.f64[1])
          {
            v73.f64[1] = v105.f64[1];
            v73.f64[0] = v37->f64[0];
            v74.f64[0] = v105.f64[0];
            v74.f64[1] = v37->f64[1];
            CA::OGL::Context::array_quad((void *)a1, v73, v105, v74, *v37);
            v72.f64[0] = v105.f64[0];
            uint64_t v75 = *a3;
            uint64_t v76 = *(void *)(a1 + 120) + 48 * *(void *)(a1 + 128);
            *(void *)(v76 - 160) = *a3;
            *(void *)(v76 - 112) = v75;
            *(void *)(v76 - 64) = v75;
            *(void *)(v76 - 16) = v75;
            double v71 = v37->f64[0];
          }
          double v77 = v38->f64[0];
          if (v71 < v72.f64[0] || v77 < v72.f64[0])
          {
            if (v71 > v72.f64[0]) {
              v72.f64[0] = v71;
            }
            if (v77 <= v72.f64[0]) {
              v78.f64[0] = v72.f64[0];
            }
            else {
              v78.f64[0] = v38->f64[0];
            }
            v79.f64[0] = v78.f64[0];
            v79.f64[1] = v37->f64[1];
            v78.f64[1] = v38->f64[1];
            CA::OGL::Context::array_quad((void *)a1, *v37, v79, v78, *v38);
            v72.f64[0] = v105.f64[0];
            uint64_t v80 = *a3;
            uint64_t v81 = *(void *)(a1 + 120) + 48 * *(void *)(a1 + 128);
            *(void *)(v81 - 160) = *a3;
            *(void *)(v81 - 112) = v80;
            *(void *)(v81 - 64) = v80;
            *(void *)(v81 - 16) = v80;
            double v77 = v38->f64[0];
          }
          v82.f64[1] = v106.f64[1];
          double v83 = v38->f64[1];
          if (v77 < v72.f64[0] && v83 < v106.f64[1])
          {
            v72.f64[1] = v38->f64[1];
            v82.f64[0] = v77;
            CA::OGL::Context::array_quad((void *)a1, *v38, v72, v104, v82);
            uint64_t v84 = *a3;
            uint64_t v85 = *(void *)(a1 + 120) + 48 * *(void *)(a1 + 128);
            *(void *)(v85 - 160) = *a3;
            *(void *)(v85 - 112) = v84;
            *(void *)(v85 - 64) = v84;
            *(void *)(v85 - 16) = v84;
            double v83 = v38->f64[1];
          }
          double v86 = v39->f64[1];
          if (v83 < v106.f64[1] || v86 < v106.f64[1])
          {
            if (v83 <= v106.f64[1]) {
              double v87 = v106.f64[1];
            }
            else {
              double v87 = v83;
            }
            if (v86 <= v87) {
              double v86 = v87;
            }
            v88.f64[0] = v38->f64[0];
            v88.f64[1] = v86;
            v89.f64[0] = v39->f64[0];
            v89.f64[1] = v86;
            CA::OGL::Context::array_quad((void *)a1, *v39, *v38, v88, v89);
            uint64_t v90 = *a3;
            uint64_t v91 = *(void *)(a1 + 120) + 48 * *(void *)(a1 + 128);
            *(void *)(v91 - 160) = *a3;
            *(void *)(v91 - 112) = v90;
            *(void *)(v91 - 64) = v90;
            *(void *)(v91 - 16) = v90;
          }
          double v92 = v39->f64[0];
          double v93 = v106.f64[0];
          if (v39->f64[0] > v106.f64[0] && v39->f64[1] < v106.f64[1])
          {
            v94.f64[0] = v106.f64[0];
            v94.f64[1] = v39->f64[1];
            v95.f64[1] = v106.f64[1];
            v95.f64[0] = v39->f64[0];
            CA::OGL::Context::array_quad((void *)a1, v94, *v39, v95, v106);
            double v93 = v106.f64[0];
            uint64_t v96 = *a3;
            uint64_t v97 = *(void *)(a1 + 120) + 48 * *(void *)(a1 + 128);
            *(void *)(v97 - 160) = *a3;
            *(void *)(v97 - 112) = v96;
            *(void *)(v97 - 64) = v96;
            *(void *)(v97 - 16) = v96;
            double v92 = v39->f64[0];
          }
          double v98 = v36->f64[0];
          if (v36->f64[0] > v93 || v92 > v93)
          {
            if (v98 >= v93) {
              double v98 = v93;
            }
            if (v92 >= v98) {
              v99.f64[0] = v98;
            }
            else {
              v99.f64[0] = v92;
            }
            v100.f64[0] = v99.f64[0];
            v100.f64[1] = v36->f64[1];
            v99.f64[1] = v39->f64[1];
            CA::OGL::Context::array_quad((void *)a1, v100, *v36, *v39, v99);
            uint64_t v101 = *a3;
            uint64_t v102 = *(void *)(a1 + 120) + 48 * *(void *)(a1 + 128);
            *(void *)(v102 - 160) = *a3;
            *(void *)(v102 - 112) = v101;
            *(void *)(v102 - 64) = v101;
            *(void *)(v102 - 16) = v101;
          }
        }
        *(void *)(a1 + 16) = __dst[0];
      }
    }
  }
  return result;
}

BOOL CATransform3DIsIdentity(CATransform3D *t)
{
  if (t->m11 != 1.0) {
    return 0;
  }
  uint64_t v2 = 1;
  unint64_t v3 = 15;
  while (v2 != 16)
  {
    double v4 = *(&t->m11 + v2);
    double v5 = *(&CATransform3DIdentity.m11 + v2++);
    if (v4 != v5)
    {
      unint64_t v3 = v2 - 2;
      return v3 > 0xE;
    }
  }
  return v3 > 0xE;
}

void CA::Render::Updater::prepare_layer0(void *a1, CA::Render::LayerNode *a2, CA::Render::FlattenManager *a3, uint64_t a4, uint64_t a5)
{
  float64x2_t v6 = a2;
  float64x2_t v7 = a1;
  uint64_t v871 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *a1;
  LOWORD(v9) = *(_DWORD *)(*a1 + 1084);
  if ((*(_DWORD *)(*a1 + 1084) & 0x80) == 0
    || (*(_WORD *)(a4 + 136) & 0x100) != 0
    || (*((void *)a3 + 5) & 0x10CLL) != 4)
  {
    ++*(_DWORD *)(v8 + 756);
    uint64_t v19 = *((void *)a2 + 11);
    if (v19)
    {
      *((void *)a2 + 3) |= *(void *)(v19 + 24) & 0xC000000;
      int v9 = *(_DWORD *)(v8 + 1084);
    }
    v830 = (unsigned int *)(v8 + 1084);
    uint64_t v831 = a4;
    if ((v9 & 4) != 0)
    {
      uint64_t v20 = 0;
    }
    else
    {
      uint64_t v20 = *((void *)a3 + 18);
      if (v20)
      {
        uint64_t v21 = *(void *)(v20 + 96);
LABEL_16:
        *(void *)&double v22 = v21 | a5;
        uint64_t v23 = (uint64_t)CA::Render::FlattenManager::layer_is_flattened(a3, a2);
        uint64_t v26 = (uint64_t)a3;
        BOOL v27 = 0;
        uint64_t v834 = v26;
        uint64_t v28 = *(void *)(v26 + 40);
        int v824 = v23;
        if ((v28 & 0x80000) != 0 && (v23 & 1) == 0) {
          BOOL v27 = (*(_DWORD *)(*v7 + 1084) & 4) == 0;
        }
        uint64_t v29 = *((void *)v6 + 3);
        if ((v29 & 0x4000000) != 0) {
          char v30 = 0;
        }
        else {
          char v30 = (int32x2_t *)v20;
        }
        if (*((void *)v6 + 4) == v834) {
          double v31 = v22;
        }
        else {
          *(void *)&double v31 = *(void *)&v22 | 4;
        }
        _ZF = (*(_DWORD *)(v834 + 12) & 0x900) == 0;
        int v827 = *(_DWORD *)(v834 + 12) & 0x900;
        uint64_t v32 = v831;
        if (_ZF
          && (LODWORD(v31) & 0x8007FBC) == 0
          && ((*(void *)&v31 & 0x60000000000) == 0 || (*(_WORD *)(v831 + 136) & 0x800) == 0)
          && (!v30 || *(void *)&v30[2] == v834))
        {
          goto LABEL_1156;
        }
        uint64_t v846 = 0;
        double v844 = INFINITY;
        uint64_t v845 = 0;
        double v33 = *(CA::Render::LayerNode **)(v831 + 8);
        if (!v827) {
          double v33 = v6;
        }
        v841[0] = v6;
        v841[1] = v33;
        unsigned int v848 = *(_DWORD *)(v831 + 60) + 1;
        int8x16_t v849 = (int8x16_t)*(unint64_t *)&v31;
        float64x2_t v853 = *(float64x2_t *)(v831 + 104);
        float32x2_t v34 = *(float32x2_t *)(v831 + 120);
        unint64_t v851 = 0;
        float32x2_t v854 = v34;
        float v855 = *(float *)(v831 + 128);
        unsigned int v35 = *(unsigned __int16 *)(v831 + 136);
        if ((v28 & 0xC) == 8) {
          int v36 = 1;
        }
        else {
          int v36 = (v35 >> 8) & 1;
        }
        if (v36) {
          __int16 v37 = 256;
        }
        else {
          __int16 v37 = 0;
        }
        if (((*(void *)&v31 & 0x1000000000000000) != 0) | ((unsigned __int16)(v35 & 0x800) >> 11)) {
          __int16 v38 = 2048;
        }
        else {
          __int16 v38 = 0;
        }
        __int16 v857 = v37 & 0xFFC0 | *(_WORD *)(v831 + 136) & 0x200 | v38 & 0xFFC0 | *(_WORD *)(v831 + 136) & 0x3F;
        if (v30) {
          *(void *)&v30[12] &= ~0x1000000000000000uLL;
        }
        *((void *)v6 + 3) = v29 & 0xFFFFFFFFFD7FFFFFLL;
        if ((v29 & 0x40) == 0) {
          v849.i64[0] = *(void *)&v31 & 0xFFFFFFFFFFF87FFFLL;
        }
        uint64_t v39 = *(void *)(v834 + 128);
        if (v39) {
          uint64_t v40 = *(void *)(v39 + 8);
        }
        else {
          uint64_t v40 = 0;
        }
        uint64_t v819 = *(void *)(v834 + 40);
        if ((v819 & 0x100000000000) != 0)
        {
          uint64_t v816 = 0;
          long long v815 = 0u;
          int v814 = 0;
          if (v40)
          {
LABEL_52:
            *(_DWORD *)v869 = 0;
            LODWORD(v858.f64[0]) = 0;
            double v842 = *(double *)(v32 + 16);
            if (v842 < 0.0
              || (uint64_t v23 = CA::Render::Timing::map_time((CA::Render::Timing *)v40, &v842, (unsigned int *)v869),
                  (v23 & 1) == 0))
            {
              double v842 = -1.0;
            }
            double v843 = *(double *)(v32 + 24);
            if (v843 < 0.0
              || (uint64_t v23 = CA::Render::Timing::map_time((CA::Render::Timing *)v40, &v843, (unsigned int *)&v858),
                  (v23 & 1) == 0))
            {
              double v843 = -1.0;
            }
            float v41 = *(float *)(v40 + 16) * *(float *)(v32 + 56);
            float v847 = v41;
            if (v869[0] & 1) != 0 && (*(unsigned char *)(v40 + 13)) {
              float v847 = -v41;
            }
            MEMORY[0x1F4188790](v23);
            uint64_t v43 = *(void *)(v32 + 80);
            v803[0] = v40;
            v803[1] = v43;
            v850 = v803;
            double v44 = v842;
            if (v42 && v42 != LODWORD(v858.f64[0]) && v842 >= 0.0)
            {
              __n128 v25 = (__n128)vorrq_s8(v849, (int8x16_t)xmmword_184998140);
              int8x16_t v849 = (int8x16_t)v25;
            }
            double v45 = v843;
LABEL_68:
            uint64_t v825 = v40;
            if (v44 >= 0.0 || v45 < 0.0)
            {
              uint64_t v46 = v849.i64[0];
              if (v44 < 0.0 || v45 >= 0.0)
              {
LABEL_75:
                if ((v46 & 0x200000000000) != 0
                  && (!CA::Render::Updater::layer_may_be_hidden_culled(v834)
                   || (v46 & 0x100000000000) != 0
                   || byte_1EB2ACC20))
                {
                  v849.i64[1] |= 0x3CuLL;
                  v849.i64[0] = v46 | 0xA;
                }
                v829 = v30;
                if (v27) {
                  v849.i64[1] |= 0x100000000000uLL;
                }
                uint64_t v47 = v834;
                uint64_t v48 = *(void *)(v834 + 96);
                uint64_t v832 = v8;
                v833 = v6;
                v828 = v7;
                double v826 = v31;
                if (!v48) {
                  goto LABEL_96;
                }
                if (*(unsigned char *)(v48 + 12) == 25) {
                  v849.i64[1] |= 0x100000000080uLL;
                }
                if ((*(unsigned char *)(v8 + 274) & 1) != 0
                  && (uint64_t v49 = (*(uint64_t (**)(uint64_t))(*(void *)v48 + 80))(v48)) != 0
                  && ((*(uint64_t (**)(uint64_t))(*(void *)v49 + 232))(v49) & 1) != 0
                  || (long long v50 = *(unsigned char **)(v47 + 96), v50[12] == 25)
                  && CA::Render::ImageQueue::is_protected(*(CA::Render::ImageQueue **)(v47 + 96))
                  && *(unsigned char *)(v8 + 405)
                  && !*(void *)(v8 + 280)
                  || ((uint64_t v51 = (*(uint64_t (**)(unsigned char *))(*(void *)v50 + 80))(v50)) == 0
                    ? (uint64_t v54 = 0)
                    : (uint64_t v52 = v51,
                       uint64_t v53 = (*(unsigned int (**)(uint64_t))(*(void *)v51 + 232))(v51),
                       uint64_t v54 = (*(uint64_t (**)(uint64_t))(*(void *)v52 + 240))(v52) | v53,
                       uint64_t v47 = v834),
                      (v54 & ~*(void *)(v8 + 280)) != 0 || *(_DWORD *)(v8 + 316) && (*(unsigned char *)(v47 + 13) & 4) != 0))
                {
                  uint64_t v55 = (*(uint64_t (**)(void))(**(void **)(v47 + 96) + 80))(*(void *)(v47 + 96));
                  if (v55)
                  {
                    uint64_t v56 = v55;
                    uint64_t v57 = (*(unsigned int (**)(uint64_t))(*(void *)v55 + 232))(v55);
                    uint64_t v58 = (*(uint64_t (**)(uint64_t))(*(void *)v56 + 240))(v56) | v57;
                    uint64_t v47 = v834;
                  }
                  else
                  {
                    uint64_t v58 = 0;
                  }
                  *(void *)(v8 + 296) |= v58;
                  *((void *)v6 + 3) |= 0x2000000uLL;
                  goto LABEL_96;
                }
                int v153 = *(unsigned __int8 *)(v48 + 12);
                if (v153 == 24)
                {
                  double v239 = *(double *)(v8 + 72);
                  if (v239 >= *(double *)(v48 + 184))
                  {
                    if ((LOBYTE(v31) & 0x80) != 0) {
                      v849.i64[0] |= 3uLL;
                    }
                  }
                  else
                  {
                    __n128 v25 = (__n128)vorrq_s8(v849, (int8x16_t)xmmword_184998150);
                    int8x16_t v849 = (int8x16_t)v25;
                    *(void *)(v8 + 96) |= 0x40000000uLL;
                    v25.n128_u64[0] = *(void *)(v8 + 80);
                    if (v25.n128_f64[0] >= v239)
                    {
                      if (v239 == 0.0 || v25.n128_f64[0] <= v239) {
                        uint64_t v240 = *(void *)(v8 + 88) | 0x40000000;
                      }
                      else {
                        uint64_t v240 = 0x40000000;
                      }
                      *(void *)(v8 + 88) = v240;
                      *(double *)(v8 + 80) = v239;
                    }
                  }
                  goto LABEL_96;
                }
                if (v153 != 25) {
                  goto LABEL_96;
                }
                uint64_t v154 = v7[3];
                if ((*(unsigned char *)(v47 + 13) & 4) != 0
                  && (float v155 = (CA::Render::Context *)*(unsigned int *)(v48 + 200), v155)
                  && (v156 = CA::Render::Context::context_by_id(v155), (uint64_t v154 = v156) != 0))
                {
                  pthread_mutex_lock((pthread_mutex_t *)(v156 + 72));
                  LODWORD(v821.f64[0]) = 0;
                  *(void *)&v822.f64[0] = v154;
                }
                else
                {
                  v822.f64[0] = 0.0;
                  LODWORD(v821.f64[0]) = 1;
                }
                v837.f64[0] = 0.0;
                uint64_t v241 = *(void *)(v47 + 128);
                if (v241) {
                  float v242 = *(float *)(v241 + 256);
                }
                else {
                  float v242 = 1.0;
                }
                *(float *)(v48 + 152) = v242;
                v818.f64[0] = (float64_t)v7[2];
                double v256 = v842;
                float v257 = v847;
                long long v258 = v850;
                memset(v869, 0, 136);
                BOOL v840 = 0;
                LODWORD(v836[0]) = 0;
                unint64_t v820 = v48 + 56;
                os_unfair_lock_lock((os_unfair_lock_t)(v48 + 56));
                uint64_t v259 = *(void *)(*(void *)(v48 + 16) + 24);
                int v260 = *(_DWORD *)(v48 + 192);
                int v261 = *(_DWORD *)(v8 + 248);
                double v262 = 0.0;
                uint64_t v823 = v259;
                if (v260 != v261)
                {
                  if ((*v830 & 4) != 0)
                  {
                    double v263 = 0.0;
                    if (*(void *)(v48 + 24))
                    {
LABEL_1327:
                      v696 = (void *)(v48 + 224);
                      v697 = *(void **)(v48 + 224);
                      if (v697)
                      {
                        double v698 = *(double *)(v8 + 72);
                        do
                        {
                          while (1)
                          {
                            v699 = (atomic_uint *)*v697;
                            if (v698 > *(float *)(*v697 + 320)) {
                              break;
                            }
                            v696 = v697 + 1;
                            v697 = (void *)v697[1];
                            if (!v697) {
                              goto LABEL_1335;
                            }
                          }
                          if (atomic_fetch_add(v699 + 2, 0xFFFFFFFF) == 1) {
                            (*(void (**)(atomic_uint *))(*(void *)v699 + 16))(v699);
                          }
                          v700 = (void *)v697[1];
                          malloc_zone = (malloc_zone_t *)get_malloc_zone();
                          malloc_zone_free(malloc_zone, v697);
                          void *v696 = v700;
                          v697 = v700;
                          double v31 = v826;
                        }
                        while (v697);
                      }
LABEL_1335:
                      unint64_t v702 = atomic_load((unint64_t *)(v823 + 8));
                      uint64_t v703 = v702 & 0x4000000000008000;
                      if (LODWORD(v836[0])) {
                        BOOL v704 = 1;
                      }
                      else {
                        BOOL v704 = v703 == 0x4000000000008000;
                      }
                      if (v704) {
                        CAShmemImageQueueCollectable(v823, *(unsigned int *)(v48 + 196), v836[0], 0);
                      }
                      os_unfair_lock_unlock((os_unfair_lock_t)v820);
                      v705 = *(atomic_uint **)&v822.f64[0];
                      if ((LOBYTE(v821.f64[0]) & 1) == 0)
                      {
                        pthread_mutex_unlock((pthread_mutex_t *)(*(void *)&v822.f64[0] + 72));
                        if (atomic_fetch_add(v705 + 2, 0xFFFFFFFF) == 1) {
                          (*(void (**)(atomic_uint *))(*(void *)v705 + 16))(v705);
                        }
                      }
                      uint64_t v32 = v831;
                      if (v829)
                      {
                        if (v849.i8[1] < 0)
                        {
                          uint64_t v707 = *(void *)(*(void *)(v48 + 16) + 24);
                          int v706 = *(_DWORD *)(v707 + 96);
                          int v708 = v829[15].i32[1] * v829[15].i32[0];
                          if (v706 != v708)
                          {
                            v849.i64[1] |= 0x40000uLL;
                            int v706 = v708;
                          }
                        }
                        else
                        {
                          int v706 = v829[15].i32[1] * v829[15].i32[0];
                          uint64_t v707 = *(void *)(*(void *)(v48 + 16) + 24);
                        }
                        *(_DWORD *)(v707 + 96) = v706;
                        int v709 = *(_DWORD *)(v8 + 272);
                        unint64_t v710 = atomic_load((unint64_t *)(v707 + 8));
                        if ((v709 & 0x8000) == 0 || (v710 & 0x8000000000000000) != 0)
                        {
                          if ((v709 & 0x8000) == 0 && (v710 & 0x8000000000000000) != 0) {
                            atomic_fetch_and((atomic_ullong *volatile)(v707 + 8), 0x7FFFFFFFFFFFFFFFuLL);
                          }
                        }
                        else
                        {
                          atomic_fetch_or((atomic_ullong *volatile)(v707 + 8), 0x8000000000000000);
                        }
                        int32x2_t v711 = v829[12];
                        uint64_t v712 = *(void *)(*(void *)(v48 + 16) + 24);
                        unint64_t v713 = atomic_load((unint64_t *)(v712 + 8));
                        uint64_t v714 = v713 & 0x100000000000000;
                        if ((*(void *)&v711 & 0x80000000000) == 0 || v714)
                        {
                          if ((*(void *)&v711 & 0x80000000000) == 0 && v714) {
                            atomic_fetch_and((atomic_ullong *volatile)(v712 + 8), 0xFEFFFFFFFFFFFFFFLL);
                          }
                        }
                        else
                        {
                          atomic_fetch_or((atomic_ullong *volatile)(v712 + 8), 0x100000000000000uLL);
                        }
                        int v715 = *v830;
                        uint64_t v716 = *(void *)(*(void *)(v48 + 16) + 24);
                        unint64_t v717 = atomic_load((unint64_t *)(v716 + 8));
                        uint64_t v718 = v717 & 0x8000000000000;
                        uint64_t v719 = v715 & 0x80080000;
                        if (!v719 || v718)
                        {
                          if (!v719 && v718) {
                            atomic_fetch_and((atomic_ullong *volatile)(v716 + 8), 0xFFF7FFFFFFFFFFFFLL);
                          }
                        }
                        else
                        {
                          atomic_fetch_or((atomic_ullong *volatile)(v716 + 8), 0x8000000000000uLL);
                        }
                        unsigned int v720 = *(_DWORD *)(v8 + 268);
                        unint64_t v721 = atomic_load((unint64_t *)(*(void *)(*(void *)(v48 + 16) + 24) + 8));
                        unsigned int v722 = v720 >> 30;
                        if ((v721 & 0x400000000000000) != 0 && *(_DWORD *)(v48 + 272) && !v722)
                        {
                          v849.i64[1] |= 0x40000uLL;
                        }
                        else if (v722)
                        {
                          unsigned int v722 = *(_DWORD *)(*v7 + 248);
                        }
                        *(_DWORD *)(v48 + 272) = v722;
                      }
                      int v723 = *(_DWORD *)(v48 + 12);
                      if ((v723 & 0x40400) != 0)
                      {
                        uint64_t v724 = v849.i64[0] | 3;
                        v849.i64[1] = (8 * v849.i32[0]) & 0x40000 | v849.i64[1] & 0xFFFFFFFFFFFD7BFBLL | 0x404;
LABEL_1376:
                        v849.i64[0] = v724;
                        goto LABEL_1392;
                      }
                      if ((v723 & 0x200) == 0) {
                        goto LABEL_1392;
                      }
                      uint64_t v725 = (*(uint64_t (**)(uint64_t))(*(void *)v48 + 80))(v48);
                      if (!v725) {
                        goto LABEL_1385;
                      }
                      v726 = *(_DWORD **)(v725 + 40);
                      if (!v726) {
                        goto LABEL_1385;
                      }
                      if ((v726 & 1) != 0 || v726[1] != 12) {
                        goto LABEL_1535;
                      }
                      unsigned int v727 = v726[8] - v726[7];
                      unsigned int v728 = v726[9] - v726[5];
                      if (v727 > v728) {
                        unsigned int v728 = v727;
                      }
                      if (v728 <= 0x3FFFFFFE)
                      {
LABEL_1535:
                        if (*(void *)(v834 + 104)) {
                          uint64_t v729 = v849.i64[1] | 0x400;
                        }
                        else {
                          uint64_t v729 = v849.i64[1] | 0x8000000;
                        }
                        v849.i64[1] = v729;
                        if ((v849.i8[1] & 0x80) == 0)
                        {
LABEL_1392:
                          if ((v723 & 0x2100) == 0 || (*((unsigned char *)v6 + 27) & 4) != 0)
                          {
                            if (v847 == 0.0)
                            {
                              double v733 = *(double *)(*(void *)(*(void *)(v48 + 16) + 24) + 128);
                              BOOL v734 = ((*(void *)&v733 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 > 0x3FE
                                  && (*(void *)&v733 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000001;
                              BOOL v735 = !v734 || *(void *)&v733 == 0xFFF0000000000000;
                              BOOL v736 = !v735 && (*(void *)&v733 & 0x7FFFFFFFFFFFFFFFuLL) - 1 > 0xFFFFFFFFFFFFELL;
                              if (!v736 && v733 > *(double *)(v8 + 72) && v733 < *(double *)(v8 + 80))
                              {
                                if (byte_1EB2ACC84)
                                {
                                  if (x_log_hook_p())
                                  {
                                    v803[0] = "edr_deadline";
                                    x_log_();
                                    uint64_t v8 = v832;
                                    float64x2_t v6 = v833;
                                    float64x2_t v7 = v828;
                                    uint64_t v32 = v831;
                                    double v31 = v826;
                                  }
                                  else
                                  {
                                    v768 = x_log_category_CADebug;
                                    BOOL v769 = os_log_type_enabled((os_log_t)x_log_category_CADebug, OS_LOG_TYPE_INFO);
                                    uint64_t v8 = v832;
                                    float64x2_t v6 = v833;
                                    float64x2_t v7 = v828;
                                    uint64_t v32 = v831;
                                    double v31 = v826;
                                    if (v769)
                                    {
                                      *(_DWORD *)v869 = 136315138;
                                      *(void *)&v869[4] = "edr_deadline";
                                      _os_log_impl(&dword_184668000, v768, OS_LOG_TYPE_INFO, "kUpdateReasonDisplayBrightness %s", v869, 0xCu);
                                    }
                                  }
                                }
                                double v737 = *(double *)(*(void *)(*(void *)(v48 + 16) + 24) + 128);
                                *(void *)(v8 + 96) |= 8uLL;
                                double v738 = *(double *)(v8 + 80);
                                if (v738 >= v737)
                                {
                                  if (v737 == 0.0 || v738 <= v737) {
                                    uint64_t v765 = *(void *)(v8 + 88) | 8;
                                  }
                                  else {
                                    uint64_t v765 = 8;
                                  }
                                  goto LABEL_1449;
                                }
                              }
                            }
                          }
                          else
                          {
                            if ((v723 & 0x4000) == 0 || byte_1EB2ACC25)
                            {
                              *(void *)(v8 + 96) |= 0x80000000uLL;
                              double v737 = *(double *)(v8 + 72);
                              double v740 = *(double *)(v8 + 80);
                              if (v740 < v737) {
                                goto LABEL_1450;
                              }
                              if (v737 != 0.0 && v740 > v737) {
                                goto LABEL_1424;
                              }
                              goto LABEL_1448;
                            }
                            v730 = v850;
                            if (v850)
                            {
                              float v731 = 1.0;
                              do
                              {
                                uint64_t v732 = *v730;
                                CA::Render::Timing::inverse_map_time(*v730, v837.f64, INFINITY);
                                float v731 = *(float *)(v732 + 16) * v731;
                                v730 = (uint64_t *)v730[1];
                              }
                              while (v730);
                            }
                            else
                            {
                              float v731 = 1.0;
                            }
                            double v741 = v837.f64[0];
                            if ((v723 & 0x8000) != 0)
                            {
                              v742 = *(long long **)(v8 + 168);
                              if (v742)
                              {
                                if ((*(void *)&v837.f64[0] & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
                                  && v262 > 0.0
                                  && v262 < 0.1
                                  && fabsf(v731 + -1.0) < 0.01)
                                {
                                  unint64_t v743 = CAHostTimeWithTime(v837.f64[0]);
                                  unint64_t v744 = CAHostTimeWithTime(v262);
                                  long long v838 = *v742;
                                  uint64_t v839 = *((void *)v742 + 2);
                                  *(void *)v869 = v744;
                                  unint64_t phase = get_phase((unint64_t *)&v838, v743, (unint64_t *)v869);
                                  unint64_t v746 = *(void *)v869 - phase;
                                  if (!phase) {
                                    unint64_t v746 = 0;
                                  }
                                  unint64_t v747 = v746 / *((void *)v742 + 2);
                                  if (*(void *)(v8 + 176) < v747) {
                                    unint64_t v747 = *(void *)(v8 + 176);
                                  }
                                  *(void *)(v8 + 176) = v747;
                                }
                              }
                            }
                            double v737 = *(double *)(v8 + 72);
                            double v748 = *(double *)(v8 + 80);
                            uint64_t v32 = v831;
                            double v31 = v826;
                            if (v748 >= v741)
                            {
                              if (v737 <= v741) {
                                double v737 = v741;
                              }
                            }
                            else if (v737 <= v748)
                            {
                              double v737 = *(double *)(v8 + 80);
                            }
                            v837.f64[0] = v737;
                            *(void *)(v8 + 96) |= 0x80000000uLL;
                            if (v748 >= v737)
                            {
                              if (v737 != 0.0 && v748 > v737)
                              {
LABEL_1424:
                                uint64_t v765 = 0x80000000;
LABEL_1449:
                                *(void *)(v8 + 88) = v765;
                                *(double *)(v8 + 80) = v737;
                                goto LABEL_1450;
                              }
LABEL_1448:
                              uint64_t v765 = *(void *)(v8 + 88) | 0x80000000;
                              goto LABEL_1449;
                            }
                          }
LABEL_1450:
                          v750 = *(void **)(v8 + 184);
                          if (!v750) {
                            goto LABEL_1466;
                          }
                          if (CADeviceSupportsOddQuantaFrameRates())
                          {
                            BOOL v751 = CADevicePrefers60HzAPT();
                            *(float *)&double v752 = v847;
                            if (!v751 && fabsf(v847) > 0.01)
                            {
                              if (*(_DWORD *)(*(void *)(*(void *)(v48 + 16) + 24) + 32))
                              {
                                double v753 = *(double *)(v8 + 72) - v263;
                                HIDWORD(v754) = 1072701986;
                                if (v753 < 1.00833333) {
                                  goto LABEL_1465;
                                }
                              }
                            }
                          }
                          else
                          {
                            *(float *)&double v752 = v847;
                          }
                          HIDWORD(v752) = 1065646817;
                          if (fabs(*(float *)&v752 + -1.0) < 0.01 && v262 != 0.0)
                          {
                            double v753 = 0.0125 - v262;
                            HIDWORD(v754) = 1059086925;
                            if (0.0125 - v262 >= 0.000125)
                            {
LABEL_1465:
                              LODWORD(v752) = 1123024896;
                              LODWORD(v753) = 1123024896;
                              LODWORD(v754) = 1123024896;
                              objc_msgSend(v750, "addFrameRateRange:", v752, v753, v754, v804.i64[0]);
                              goto LABEL_1466;
                            }
                            uint64_t v755 = 0;
                            double v756 = 1.0;
                            while (1)
                            {
                              v757 = (int *)((char *)&CA::Render::Updater::prepare_layer0(CA::Render::Updater::GlobalState &,CA::Render::LayerNode *,CA::Render::Layer const*,CA::Render::Updater::LocalState0 &,unsigned long long)::common_rates
                                           + v755);
                              double v758 = 1.0
                                   / (double)*(int *)((char *)&CA::Render::Updater::prepare_layer0(CA::Render::Updater::GlobalState &,CA::Render::LayerNode *,CA::Render::Layer const*,CA::Render::Updater::LocalState0 &,unsigned long long)::common_rates
                                                    + v755);
                              double v759 = vabdd_f64(v262, v758);
                              double v760 = v758 * 0.01;
                              if (v759 < v760) {
                                break;
                              }
                              v755 += 12;
                              if (v755 == 72) {
                                goto LABEL_1466;
                              }
                            }
                            char v764 = *((unsigned char *)v757 + 8);
                            *(float *)&double v752 = (float)v757[1];
                            *(float *)&double v756 = *(float *)&v752;
                            *(float *)&double v760 = *(float *)&v752;
                            objc_msgSend(v750, "addFrameRateRange:", v752, v756, v760);
                            if (v764) {
                              [v750 addCompatQuantaIntent];
                            }
                          }
LABEL_1466:
                          if (CA::Render::ImageQueue::is_protected((CA::Render::ImageQueue *)v48))
                          {
                            uint64_t v761 = *(void *)(v48 + 64);
                            uint64_t v47 = v834;
                            if (v761 || (uint64_t v761 = *(void *)(v48 + 80)) != 0)
                            {
LABEL_1469:
                              uint64_t v762 = (*(uint64_t (**)(uint64_t))(*(void *)v761 + 240))(v761);
                              goto LABEL_1471;
                            }
                            if (*(void *)(v48 + 24))
                            {
                              uint64_t v761 = *(void *)(v48 + 80);
                              if (!v761) {
                                uint64_t v761 = *(void *)(v48 + 24);
                              }
                              goto LABEL_1469;
                            }
                            uint64_t v762 = 0;
                          }
                          else
                          {
                            uint64_t v762 = 0;
                            uint64_t v47 = v834;
                          }
LABEL_1471:
                          if (BYTE3(qword_1EB2ACC90)
                            && CA::Render::ImageQueue::is_protected((CA::Render::ImageQueue *)v48))
                          {
                            *(void *)(v8 + 296) |= 1uLL;
                          }
                          if ((*(unsigned char *)(v8 + 274) & 1) != 0
                            && CA::Render::ImageQueue::is_protected((CA::Render::ImageQueue *)v48))
                          {
                            *((void *)v6 + 3) |= 0x2000000uLL;
                            v849.i64[1] |= (8 * v849.i32[0]) & 0x40000 | 0x400;
                            v849.i64[0] |= 1uLL;
                            v763 = (int8x16_t *)(v8 + 296);
LABEL_1477:
                            v763->i64[0] |= v762;
                            goto LABEL_96;
                          }
                          if ((v29 & 0x2000000) != 0)
                          {
                            v763 = &v849;
                            v849.i64[1] |= 0x400uLL;
                            uint64_t v762 = 1;
                            goto LABEL_1477;
                          }
LABEL_96:
                          float64x2_t v59 = (const CA::Render::Object *)*((void *)v6 + 15);
                          if (v59)
                          {
                            CA::Render::Update::release_object((uint64_t *)v8, v59);
                            *((void *)v6 + 15) = 0;
                          }
                          uint64_t v60 = *(void *)(v47 + 128);
                          if (v60)
                          {
                            uint64_t v61 = *(void *)(v60 + 136);
                            if (v61)
                            {
                              if ((*v830 & 4) == 0)
                              {
                                uint64_t v62 = *(unsigned int *)(v61 + 16);
                                if (v62)
                                {
                                  uint64_t v63 = (uint64_t *)(v61 + 24);
                                  uint64_t v64 = v61 + 24 + 8 * v62;
                                  v809.i64[0] = v64;
                                  do
                                  {
                                    uint64_t v65 = *v63;
                                    uint64_t v66 = *(void *)(*v63 + 16);
                                    float64_t v67 = *(double *)(v66 + 24);
                                    if ((**(_DWORD **)&v67 & 0x40000000) == 0)
                                    {
                                      double v68 = *(double *)(v32 + 16);
                                      uint64_t v69 = *(void *)(v32 + 48) | 0x20;
                                      _ZF = *(double *)(v32 + 32) == v68 || v68 == 0.0;
                                      uint64_t v71 = *(void *)(v32 + 40) | 0x20;
                                      if (!_ZF) {
                                        uint64_t v71 = 32;
                                      }
                                      *(void *)(v32 + 40) = v71;
                                      *(void *)(v32 + 48) = v69;
                                      *(double *)(v32 + 32) = v68;
                                    }
                                    v849.i64[1] |= 0x800uLL;
                                    unint64_t v72 = *(void *)(v66 + 16);
                                    unint64_t v73 = v72 - 40;
                                    if (v72 >= 0x28)
                                    {
                                      int v74 = *(_DWORD *)(*(void *)&v67 + 8);
                                      LODWORD(v823) = *((_DWORD *)v7 + 2);
                                      if (v74 != v823)
                                      {
                                        uint64_t v75 = (os_unfair_lock_s *)*(unsigned int *)(*(void *)&v67 + 12);
                                        if (!WORD1(v75))
                                        {
                                          v811.i64[0] = v72;
                                          v810.i64[0] = v65;
                                          unint64_t v820 = (unint64_t)v75;
                                          os_unfair_lock_lock(&CA::Render::PresentationModifierShmem::_fetch_lock);
                                          os_unfair_lock_t v76 = (os_unfair_lock_t)v820;
                                          atomic_fetch_or(*(atomic_uint *volatile *)&v67, 0x80000000);
                                          uint64_t v77 = **(_DWORD **)&v67 & 1;
                                          if (v76)
                                          {
                                            os_unfair_lock_t v78 = 0;
                                            unint64_t v79 = v73 >> 3;
                                            uint64_t v80 = *(void *)&v67 + v811.i64[0];
                                            unint64_t v81 = *(void *)&v67 + 40;
                                            *(void *)&v822.f64[0] = *(void *)&v67 + 64;
                                            *(void *)&v821.f64[0] = *(void *)&v67 + 48;
                                            uint64_t v77 = v77;
                                            unint64_t v817 = v73 >> 3;
                                            v818.f64[0] = v67;
                                            unint64_t v812 = *(void *)&v67 + 40;
                                            v813 = (void **)v73;
                                            while (1)
                                            {
                                              if (v78 == (os_unfair_lock_t)v79)
                                              {
LABEL_129:
                                                uint64_t v32 = v831;
                                                goto LABEL_131;
                                              }
                                              uint64_t v82 = v80 - 8 * (void)v78;
                                              uint64_t v83 = *(unsigned int *)(v82 - 8);
                                              if (!v83) {
                                                break;
                                              }
                                              uint64_t v84 = (16 * v83) | 8;
                                              unint64_t v85 = *(unsigned int *)(v82 - 4);
                                              if (v73 < v85 || 3 * v84 + v85 > v73) {
                                                break;
                                              }
                                              uint64_t v87 = v84 * v77;
                                              float64x2_t v88 = (unsigned __int16 *)(v81 + v85 + v84 * v77);
                                              float64x2_t v89 = (unsigned __int16 *)(v81 + v85 + 2 * v84);
                                              int v90 = *v88;
                                              if (*v89 != v90) {
                                                goto LABEL_123;
                                              }
                                              uint64_t v91 = v77;
                                              uint64_t v92 = v80;
                                              int v93 = memcmp(v89 + 4, v88 + 4, 8 * v83);
                                              uint64_t v80 = v92;
                                              unint64_t v79 = v817;
                                              float64_t v67 = v818.f64[0];
                                              os_unfair_lock_t v76 = (os_unfair_lock_t)v820;
                                              uint64_t v77 = v91;
                                              unint64_t v81 = v812;
                                              unint64_t v73 = (unint64_t)v813;
                                              if (v93)
                                              {
LABEL_123:
                                                unsigned __int16 *v89 = v90;
                                                uint64_t v94 = 2 * v83;
                                                if ((unint64_t)(2 * v83) <= 1) {
                                                  uint64_t v94 = 1;
                                                }
                                                float64x2_t v95 = (void *)(*(void *)&v822.f64[0] + v85 + 32 * v83);
                                                uint64_t v96 = (uint64_t *)(*(void *)&v821.f64[0] + v87 + v85);
                                                do
                                                {
                                                  uint64_t v97 = *v96++;
                                                  *v95++ = v97;
                                                  --v94;
                                                }
                                                while (v94);
                                                v89[1] = 0;
                                              }
                                              os_unfair_lock_t v78 = (os_unfair_lock_t)((char *)v78 + 1);
                                              float64x2_t v6 = v833;
                                              float64x2_t v7 = v828;
                                              double v31 = v826;
                                              if (v78 == v76) {
                                                goto LABEL_129;
                                              }
                                            }
                                            uint64_t v32 = v831;
                                            double v31 = v826;
                                          }
LABEL_131:
                                          *(void *)(*(void *)&v67 + 32) = *(void *)(*(void *)&v67
                                                                                          + 8 * v77
                                                                                          + 16);
                                          **(_DWORD **)&v67 &= ~0x80000000;
                                          *(_DWORD *)(*(void *)&v67 + 8) = v823;
                                          os_unfair_lock_unlock(&CA::Render::PresentationModifierShmem::_fetch_lock);
                                          uint64_t v64 = v809.i64[0];
                                          uint64_t v65 = v810.i64[0];
                                          unint64_t v72 = v811.i64[0];
                                        }
                                      }
                                      unint64_t v98 = *(unsigned int *)(v65 + 24);
                                      if (v98 < v73 >> 3)
                                      {
                                        uint64_t v99 = *(void *)&v67 + v72 - 8 * v98;
                                        uint64_t v100 = *(unsigned int *)(v99 - 8);
                                        if (v100)
                                        {
                                          uint64_t v101 = (16 * v100) | 8;
                                          unint64_t v102 = *(unsigned int *)(v99 - 4);
                                          BOOL v103 = v73 < v102 || 3 * v101 + v102 > v73;
                                          if (!v103 && !*(_WORD *)(*(void *)&v67 + v102 + 2 * v101 + 42)) {
                                            v849.i64[1] |= 0x700uLL;
                                          }
                                        }
                                      }
                                    }
                                    if ((*(unsigned char *)(v65 + 13) & 4) != 0) {
                                      v849.i64[1] |= 0x100000000000uLL;
                                    }
                                    ++v63;
                                  }
                                  while (v63 != (uint64_t *)v64);
                                }
                              }
                            }
                          }
                          __asm { FMOV            V0.2D, #1.0 }
                          float64x2_t v837 = _Q0;
                          uint64_t v107 = *((unsigned __int16 *)v830 + 2);
                          unint64_t v108 = *v830 | (unint64_t)(v107 << 32);
                          unsigned int v109 = (v107 >> 4) & 1;
                          if (byte_1EB2ACC4D) {
                            uint64_t v110 = 1;
                          }
                          else {
                            uint64_t v110 = v109;
                          }
                          unint64_t v820 = v108;
                          int v111 = v110 | (v108 >> 21) & 1;
                          uint64_t v112 = v834;
                          uint64_t v113 = *(void *)(v834 + 136);
                          LODWORD(v823) = v111;
                          if (v113)
                          {
                            double v114 = v842;
                            uint64_t v8 = v832;
                            if (v842 < 0.0)
                            {
LABEL_202:
                              float16x4_t v147 = (const CA::Render::Object *)*((void *)v6 + 4);
                              if (v147 != (const CA::Render::Object *)v834)
                              {
                                CA::Render::Update::release_object((uint64_t *)*v7, v147);
                                *((void *)v6 + 4) = v112;
                                if (!atomic_fetch_add((atomic_uint *volatile)(v112 + 8), 1u)) {
                                  atomic_fetch_add((atomic_uint *volatile)(v112 + 8), 0xFFFFFFFF);
                                }
                              }
                              if (v111) {
                                uint64_t v148 = &v837;
                              }
                              else {
                                uint64_t v148 = 0;
                              }
                              CA::Render::LayerNode::update_frame_transform((uint64_t)v6, v148->f64);
                              LODWORD(v821.f64[0]) = 0;
                              uint64_t v152 = v112;
                              goto LABEL_467;
                            }
                          }
                          else
                          {
                            uint64_t v115 = *(void *)(v834 + 128);
                            uint64_t v8 = v832;
                            if (!v115) {
                              goto LABEL_202;
                            }
                            if (!*(void *)(v115 + 136)) {
                              goto LABEL_202;
                            }
                            double v114 = v842;
                            if (v842 < 0.0) {
                              goto LABEL_202;
                            }
                          }
                          float64x2_t v821 = _Q0;
                          if (!v829) {
                            goto LABEL_219;
                          }
                          float64x2_t v117 = v829 + 6;
                          float64x2_t v116 = (void *)v829[6];
                          if (!v116) {
                            goto LABEL_219;
                          }
                          char v118 = 0;
                          float v119 = v847;
                          *(void *)&_Q0.f64[0] = 136315650;
                          float64x2_t v822 = _Q0;
                          *(void *)&_Q0.f64[0] = 134220034;
                          float64x2_t v818 = _Q0;
LABEL_155:
                          uint64_t v120 = v110;
                          float64x2x4_t v121 = v116;
                          do
                          {
                            float v122 = (CA::Render *)*v121;
                            float16x4_t v123 = *(double **)(*v121 + 40);
                            if (v123)
                            {
                              double v124 = v123[5];
                              double v125 = CA::Render::Timing::end_time((CA::Render::Timing *)v123);
                            }
                            else
                            {
                              double v124 = 0.0;
                              double v125 = INFINITY;
                            }
                            if (v119 >= 0.0) {
                              v25.n128_f64[0] = v125;
                            }
                            else {
                              v25.n128_f64[0] = v124;
                            }
                            if ((*(unsigned int (**)(CA::Render *, double, __n128, float))(*(void *)v122 + 96))(v122, v114, v25, v119))
                            {
                              if (!byte_1EB2ACBE7) {
                                goto LABEL_166;
                              }
                              x_log_begin();
                              if (x_log_hook_p())
                              {
                                uint64_t v128 = mach_absolute_time();
                                CATimeWithHostTime(v128);
                                v803[0] = *((unsigned int *)v122 + 21);
                                x_log_();
                              }
                              else
                              {
                                float v130 = x_log_category_render;
                                if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
                                {
                                  uint64_t v131 = mach_absolute_time();
                                  double v132 = CATimeWithHostTime(v131);
                                  int32x2_t v133 = v829[3];
                                  if (v133) {
                                    v133.i32[0] = *(_DWORD *)(*(void *)&v133 + 16);
                                  }
                                  int32x2_t v134 = v829[2];
                                  if (v134)
                                  {
                                    uint64_t v135 = *(void *)(*(void *)&v134 + 120);
                                    if (v135) {
                                      int32x2_t v134 = (int32x2_t)(v135 + 28);
                                    }
                                    else {
                                      int32x2_t v134 = 0;
                                    }
                                  }
                                  int v136 = *((_DWORD *)v122 + 20);
                                  int v137 = *((_DWORD *)v122 + 21);
                                  *(_DWORD *)v869 = LODWORD(v818.f64[0]);
                                  *(double *)&v869[4] = v132;
                                  *(_WORD *)&v869[12] = 1024;
                                  *(_DWORD *)&v869[14] = v133.i32[0];
                                  *(_WORD *)&v869[18] = 2080;
                                  *(int32x2_t *)&v869[20] = v134;
                                  *(_WORD *)&v869[28] = 2048;
                                  *(void *)&v869[30] = v829;
                                  *(_WORD *)&v869[38] = 2048;
                                  *(void *)&v869[40] = v122;
                                  *(_WORD *)&v869[48] = 2048;
                                  *(double *)&v869[50] = v114;
                                  *(_WORD *)&v869[58] = 2048;
                                  *(double *)&v869[60] = v119;
                                  *(_WORD *)&v869[68] = 1024;
                                  *(_DWORD *)&v869[70] = v136;
                                  *(_WORD *)&v869[74] = 1024;
                                  *(_DWORD *)&v869[76] = v137;
                                  _os_log_impl(&dword_184668000, v130, OS_LOG_TYPE_DEFAULT, "%f %x \"%s\" (%p): collecting %p (t %f; speed %g; eval %u; frames %u):\n",
                                    v869,
                                    0x50u);
                                }
                              }
                              CA::Render::show_object(v122, v129);
                              v813 = (void **)x_stream_pop_(0);
                              unint64_t v817 = (unint64_t)x_stream_get(v813);
                              int v138 = 0;
LABEL_181:
                              uint64_t v139 = 0;
                              float v140 = (char *)(v817 + v138);
                              int v141 = -1;
                              while (1)
                              {
                                if (v140[v139] == 10)
                                {
                                  int v141 = v139;
                                }
                                else if (!v140[v139])
                                {
                                  unsigned int v142 = v139;
LABEL_187:
                                  if (v141 <= -1 || v140[v142] == 0) {
                                    int v144 = v142;
                                  }
                                  else {
                                    int v144 = v141 + 1;
                                  }
                                  if (v144 > 0)
                                  {
                                    if (x_log_hook_p())
                                    {
                                      v803[0] = v140;
                                      x_log_();
                                    }
                                    else
                                    {
                                      float v145 = x_log_category_render;
                                      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
                                      {
                                        *(_DWORD *)v869 = LODWORD(v822.f64[0]);
                                        float v146 = "continued...\n";
                                        if (!v138) {
                                          float v146 = "";
                                        }
                                        *(void *)&v869[4] = v146;
                                        *(_WORD *)&v869[12] = 1040;
                                        *(_DWORD *)&v869[14] = v144;
                                        *(_WORD *)&v869[18] = 2080;
                                        *(void *)&v869[20] = v140;
                                        _os_log_impl(&dword_184668000, v145, OS_LOG_TYPE_DEFAULT, "%s%.*s", v869, 0x1Cu);
                                      }
                                    }
                                    v138 += v144;
                                    goto LABEL_181;
                                  }
                                  x_log_end_free_(v813);
                                  float64x2_t v6 = v833;
                                  double v31 = v826;
LABEL_166:
                                  if (BYTE9(xmmword_1EB2ACC10))
                                  {
                                    kdebug_trace();
                                    float64x2_t v6 = v833;
                                    double v31 = v826;
                                  }
                                  CA::Render::invalidate_animation((CA::Render *)v829, (Handle *)v122, v126);
                                  float64x2_t v116 = (void *)v121[1];
                                  uint64_t v127 = (malloc_zone_t *)get_malloc_zone();
                                  malloc_zone_free(v127, v121);
                                  *float64x2_t v117 = (int32x2_t)v116;
                                  char v118 = 1;
                                  uint64_t v8 = v832;
                                  uint64_t v110 = v120;
                                  if (!v116)
                                  {
LABEL_218:
                                    *(void *)&v829[12] |= 0x80000uLL;
                                    int8x16_t v849 = vorrq_s8(v849, (int8x16_t)xmmword_184998160);
                                    goto LABEL_219;
                                  }
                                  goto LABEL_155;
                                }
                                ++v139;
                                unsigned int v142 = 32512;
                                if (v139 == 32512) {
                                  goto LABEL_187;
                                }
                              }
                            }
                            float64x2_t v117 = (int32x2_t *)(v121 + 1);
                            float64x2x4_t v121 = (void *)v121[1];
                          }
                          while (v121);
                          uint64_t v8 = v832;
                          LODWORD(v110) = v120;
                          if (v118) {
                            goto LABEL_218;
                          }
LABEL_219:
                          long long v870 = 0u;
                          *(_OWORD *)&v869[168] = 0u;
                          *(double *)v869 = v842;
                          *(void *)&v869[8] = LODWORD(v847);
                          *(void *)&v869[16] = v834;
                          *(void *)&v869[24] = v8;
                          *(void *)&v869[32] = v6;
                          *(_DWORD *)&v869[172] = 256;
                          memset(&v869[136], 0, 36);
                          memset(&v869[40], 0, 80);
                          *(float64x2_t *)&v869[120] = v821;
                          v869[176] = (v857 >> 3) & 7;
                          LODWORD(v822.f64[0]) = v110;
                          BYTE8(v870) = v110;
                          uint64_t v157 = *(void *)(v834 + 128);
                          if (v157)
                          {
                            uint64_t v158 = *(void *)(v157 + 136);
                            if (v158)
                            {
                              if (*(_DWORD *)(v158 + 16))
                              {
                                float v159 = (malloc_zone_t *)get_malloc_zone();
                                float v160 = malloc_type_zone_calloc(v159, 1uLL, 0x98uLL, 0x743898A5uLL);
                                float v164 = v160;
                                if (v160) {
                                  CA::Render::Layer::Layer((uint64_t)v160, *(uint64_t *)&v869[16]);
                                }
                                double v165 = *(atomic_uint **)&v869[40];
                                *(void *)&v869[40] = v164;
                                if (v165 && atomic_fetch_add(v165 + 2, 0xFFFFFFFF) == 1) {
                                  (*(void (**)(atomic_uint *))(*(void *)v165 + 16))(v165);
                                }
                                uint64_t v166 = *(unsigned int *)(v158 + 16);
                                if (v166)
                                {
                                  double v167 = (uint64_t *)(v158 + 24);
                                  *(void *)&v818.f64[0] = &v869[48];
                                  uint64_t v168 = v158 + 24 + 8 * v166;
                                  while (1)
                                  {
                                    uint64_t v169 = *v167;
                                    uint64_t v170 = *(void *)(*v167 + 16);
                                    uint64_t v171 = *(void *)(v170 + 24);
                                    v163.n128_u64[0] = *(void *)(v171 + 32);
                                    if (*(double *)&v870 >= v163.n128_f64[0]) {
                                      v163.n128_u64[0] = v870;
                                    }
                                    *(void *)&long long v870 = v163.n128_u64[0];
                                    float64x2_t v172 = *(CA::Render::Layer **)&v869[40];
                                    if ((BYTE8(v870) & 1) != 0 && (*(unsigned char *)(v169 + 13) & 2) != 0)
                                    {
                                      unint64_t v173 = *(void *)(v169 + 32);
                                      if (v173)
                                      {
                                        if (v173)
                                        {
                                          unint64_t v174 = v173 >> 1;
                                        }
                                        else
                                        {
                                          LODWORD(v174) = *(_DWORD *)v173;
                                          if (*(_DWORD *)v173) {
                                            LODWORD(v174) = *(_DWORD *)(v173 + 4);
                                          }
                                        }
                                      }
                                      else
                                      {
                                        LODWORD(v174) = 0;
                                      }
                                      int v175 = *(_DWORD *)(v169 + 40);
                                      if (v175 < 60 && v175 != 0) {
                                        goto LABEL_258;
                                      }
                                      unint64_t v177 = *(void *)(v170 + 16);
                                      unint64_t v178 = v177 - 40;
                                      if (v177 < 0x28) {
                                        goto LABEL_258;
                                      }
                                      unint64_t v179 = *(unsigned int *)(v169 + 24);
                                      if (v179 >= v178 >> 3) {
                                        goto LABEL_258;
                                      }
                                      uint64_t v180 = v171 + v177 - 8 * v179;
                                      unint64_t v181 = *(unsigned int *)(v180 - 8);
                                      if (!v181) {
                                        goto LABEL_258;
                                      }
                                      uint64_t v182 = (16 * v181) | 8;
                                      unint64_t v183 = *(unsigned int *)(v180 - 4);
                                      BOOL v184 = v178 < v183 || 3 * v182 + v183 > v178;
                                      if (!v184
                                        && (uint64_t v185 = v171 + v183 + 2 * v182,
                                            int v187 = *(unsigned __int16 *)(v185 + 40),
                                            uint64_t v186 = v185 + 40,
                                            v187))
                                      {
                                        if (v174 == 568)
                                        {
                                          CA::Render::VelocityState::init_scale(*(uint64_t *)&v818.f64[0], *(uint64_t *)&v869[40], (uint64_t)v161, v162);
                                          unint64_t v173 = *(void *)(v169 + 32);
                                        }
                                        CA::Render::VelocityState::set_keypath_velocity(*(uint64_t *)&v818.f64[0], (void *const *)v173, 0, 0, v181, (CA::Mat4Impl *)(v186 + 8 + 8 * v181), (double *)(v186 + 8), 0, v163);
                                        int v188 = *(_DWORD *)(v169 + 40);
                                        if (!v188) {
                                          int v188 = 60;
                                        }
                                        if (v188 >= 49)
                                        {
                                          if (v188 < 0x51) {
                                            char v223 = 3;
                                          }
                                          else {
                                            char v223 = 4;
                                          }
                                          if (v188 >= 0x3D) {
                                            unsigned __int8 v189 = v223;
                                          }
                                          else {
                                            unsigned __int8 v189 = 2;
                                          }
                                        }
                                        else
                                        {
                                          unsigned __int8 v189 = 1;
                                        }
                                        unsigned __int8 v224 = v869[176];
                                        if (v869[176] <= v189) {
                                          unsigned __int8 v224 = v189;
                                        }
                                        v869[176] = v224;
                                        if (v189 > v869[177]) {
                                          v869[177] = v189;
                                        }
                                        BYTE8(v870) |= 0x10u;
                                        float64x2_t v172 = *(CA::Render::Layer **)&v869[40];
                                      }
                                      else
                                      {
LABEL_258:
                                        if (v174 == 568) {
                                          *(_DWORD *)&v869[168] |= 0x200u;
                                        }
                                      }
                                    }
                                    if (*(void *)&v869[32]) {
                                      BOOL v190 = (*(unsigned char *)(*(void *)&v869[32] + 27) & 4) == 0;
                                    }
                                    else {
                                      BOOL v190 = 1;
                                    }
                                    uint64_t v191 = *(void *)(v169 + 16);
                                    unint64_t v192 = *(void *)(v191 + 16);
                                    unint64_t v193 = v192 - 40;
                                    if (v192 < 0x28) {
                                      goto LABEL_297;
                                    }
                                    unint64_t v194 = *(unsigned int *)(v169 + 24);
                                    if (v194 >= v193 >> 3) {
                                      goto LABEL_297;
                                    }
                                    uint64_t v195 = *(void *)(v191 + 24);
                                    uint64_t v196 = v195 + v192 - 8 * v194;
                                    float v162 = (double *)*(unsigned int *)(v196 - 8);
                                    if (!v162) {
                                      goto LABEL_297;
                                    }
                                    uint64_t v197 = (16 * (void)v162) | 8;
                                    unint64_t v198 = *(unsigned int *)(v196 - 4);
                                    if (v193 < v198 || 3 * v197 + v198 > v193) {
                                      goto LABEL_297;
                                    }
                                    uint64_t v200 = v195 + v198 + 2 * v197;
                                    uint64_t v201 = v200 + 40;
                                    if (v190) {
                                      *(_WORD *)(v200 + 42) = 1;
                                    }
                                    if (!*(_WORD *)v201) {
                                      goto LABEL_297;
                                    }
                                    __n128 v203 = (const CA::Render::Layer **)(v169 + 32);
                                    unint64_t v202 = *(void *)(v169 + 32);
                                    if (!v202) {
                                      goto LABEL_297;
                                    }
                                    if (v202) {
                                      break;
                                    }
                                    uint64_t v204 = *(unsigned int *)v202;
                                    if (v204)
                                    {
                                      if (v204 - 1 < (unint64_t)*(unsigned int *)v202)
                                      {
                                        LODWORD(v202) = *(_DWORD *)(v202 + 4 * v204);
LABEL_279:
                                        if (v202 == 386)
                                        {
                                          if (v162 >= 5)
                                          {
                                            unint64_t v205 = (unint64_t)*(double *)(v201 + 8);
                                            if (is_mul_ok(v205, 5uLL))
                                            {
                                              double v206 = *(double *)(v201 + 16);
                                              if (!((unint64_t)v206 >> 62))
                                              {
                                                uint64_t v207 = 5 * v205;
                                                if (5 * v205 < 0xFFFFFFFFFFFFFFFBLL
                                                  && !__CFADD__(5 * v205 + 5, 4 * (unint64_t)v206))
                                                {
                                                  unint64_t v812 = (unint64_t)*(double *)(v201 + 8);
                                                  v813 = (void **)v206;
                                                  uint32x2_t v208 = (malloc_zone_t *)get_malloc_zone();
                                                  int32x2_t v209 = (void **)malloc_type_zone_calloc(v208, 1uLL, 0xD0uLL, 0x743898A5uLL);
                                                  double v161 = v813;
                                                  if (v209)
                                                  {
                                                    unint64_t v817 = (unint64_t)v209;
                                                    CA::Render::MeshTransform::MeshTransform((CA::Render::MeshTransform *)v209, v812, (unint64_t)v813, -1);
                                                    unint64_t v210 = v812;
                                                    unint64_t v211 = v817;
                                                    if (v812)
                                                    {
                                                      uint64_t v212 = (float *)(*(void *)(v817 + 24) + 28);
                                                      uint64_t v213 = (float64x2_t *)(v201 + 48);
                                                      do
                                                      {
                                                        *(float32x2_t *)(v212 - 7) = vcvt_f32_f64(*v213);
                                                        *(float32x2_t *)(v212 - 3) = vcvt_f32_f64(v213[1]);
                                                        float v214 = v213[2].f64[0];
                                                        *(v212 - 1) = v214;
                                                        *uint64_t v212 = 1.0;
                                                        v212 += 8;
                                                        uint64_t v213 = (float64x2_t *)((char *)v213 + 40);
                                                        --v210;
                                                      }
                                                      while (v210);
                                                    }
                                                    unint64_t v215 = v813;
                                                    if (v813)
                                                    {
                                                      uint64_t v216 = 0;
                                                      __int16 v217 = (double *)(v201 + 48 + 8 * v207);
                                                      uint64_t v218 = *(void *)(v211 + 48);
                                                      uint64_t v219 = *(void *)(v211 + 72) + 4;
                                                      do
                                                      {
                                                        for (uint64_t i = 0; i != 16; i += 4)
                                                        {
                                                          double v221 = *v217++;
                                                          *(_DWORD *)(v218 + i) = v221;
                                                          *(_DWORD *)(v219 + 4 * i) = 0;
                                                        }
                                                        uint64_t v216 = (void **)((char *)v216 + 1);
                                                        v219 += 64;
                                                        v218 += 16;
                                                      }
                                                      while (v216 != v215);
                                                    }
                                                    *(_DWORD *)(v211 + 96) = *(double *)(v201 + 24);
                                                    *(_DWORD *)(v211 + 100) = (int)*(double *)(v201 + 32);
                                                    *(unsigned char *)(v211 + 108) = *(double *)(v201 + 40) != 0.0;
                                                    *(_DWORD *)(v211 + 12) &= 0xFFFFD4FF;
                                                    CA::Render::Layer::set_keypath_object(v172, v203, (void *const *)v817);
                                                    unint64_t v222 = v817;
                                                    if (atomic_fetch_add((atomic_uint *volatile)(v817 + 8), 0xFFFFFFFF) == 1) {
                                                      (*(void (**)(unint64_t))(*(void *)v222 + 16))(v222);
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                          goto LABEL_297;
                                        }
                                      }
                                      CA::Render::Layer::set_keypath_value(v172, (unint64_t *)(v169 + 32), (const unsigned int *)((*(_DWORD *)(v169 + 12) >> 8) & 1), (CA::Render::Vector *)v162, (double *)(v201 + 8));
                                    }
LABEL_297:
                                    ++v167;
                                    uint64_t v8 = v832;
                                    if (v167 == (uint64_t *)v168) {
                                      goto LABEL_310;
                                    }
                                  }
                                  v202 >>= 1;
                                  goto LABEL_279;
                                }
                              }
                            }
                          }
LABEL_310:
                          CA::Render::AnimationEvaluator::first_pass((CA::Render::AnimationEvaluator *)v869, (*((unsigned __int16 *)v830 + 2) >> 3) & 1);
                          v150.i64[0] = v870;
                          float64x2_t v7 = v828;
                          if (*(double *)&v870 != 0.0)
                          {
                            uint64_t v226 = v828[2];
                            v151.i64[0] = *(void *)(v226 + 624);
                            if (*(double *)v151.i64 >= *(double *)&v870) {
                              v225.i64[0] = v870;
                            }
                            else {
                              v225.i64[0] = *(void *)(v226 + 624);
                            }
                            if (*(double *)v151.i64 != 0.0) {
                              v150.i64[0] = v225.i64[0];
                            }
                            *(void *)(v226 + 624) = v150.i64[0];
                          }
                          uint64_t v112 = v834;
                          unsigned int add = atomic_fetch_add((atomic_uint *volatile)(v834 + 8), 1u);
                          int v228 = LODWORD(v822.f64[0]);
                          if (!add) {
                            atomic_fetch_add((atomic_uint *volatile)(v112 + 8), 0xFFFFFFFF);
                          }
                          char v229 = BYTE8(v870);
                          if ((BYTE8(v870) & 2) != 0)
                          {
                            if (*(void *)&v869[40]) {
                              uint64_t v230 = *(atomic_uint **)&v869[40];
                            }
                            else {
                              uint64_t v230 = *(atomic_uint **)&v869[16];
                            }
                            uint64_t v231 = (const CA::Render::Object *)*((void *)v6 + 4);
                            if (v231 != (const CA::Render::Object *)v230)
                            {
                              CA::Render::Update::release_object((uint64_t *)*v7, v231);
                              *((void *)v6 + 4) = v230;
                              if (!atomic_fetch_add(v230 + 2, 1u)) {
                                atomic_fetch_add(v230 + 2, 0xFFFFFFFF);
                              }
                            }
                            if (v823) {
                              long long v232 = &v837;
                            }
                            else {
                              long long v232 = 0;
                            }
                            CA::Render::LayerNode::update_frame_transform((uint64_t)v6, v232->f64);
                            CA::Render::AnimationEvaluator::second_pass((uint64_t)v869);
                            uint64_t v112 = v834;
                            if ((BYTE8(v870) & 4) == 0) {
                              goto LABEL_435;
                            }
                          }
                          else if ((BYTE8(v870) & 4) == 0)
                          {
                            goto LABEL_425;
                          }
                          if (*(unsigned char *)(*(void *)&v869[16] + 13))
                          {
                            uint64_t v238 = 0;
                            goto LABEL_423;
                          }
                          uint64_t v233 = *(void *)(*(void *)&v869[16] + 136);
                          unint64_t v234 = *(unsigned int *)(v233 + 16);
                          if (!v234)
                          {
                            uint64_t v238 = 0;
                            uint64_t v112 = v834;
                            goto LABEL_423;
                          }
                          uint64_t v235 = 0;
                          while (1)
                          {
                            uint64_t v236 = *(void *)(v233 + 24 + 8 * v235);
                            if ((*(_DWORD *)(v236 + 12) & 0x201FF) == 0x137) {
                              break;
                            }
LABEL_338:
                            if (++v235 >= v234)
                            {
                              uint64_t v238 = 0;
                              uint64_t v8 = v832;
                              uint64_t v112 = v834;
                              double v31 = v826;
LABEL_422:
                              int v228 = LODWORD(v822.f64[0]);
                              goto LABEL_423;
                            }
                          }
                          v858.f64[0] = *(float64_t *)v869;
                          if ((CA::Render::Animation::map_time((CA::Render::Animation *)v236, v858.f64, 0, 0, 0) & 1) == 0)
                          {
                            unint64_t v234 = *(unsigned int *)(v233 + 16);
                            goto LABEL_338;
                          }
                          uint64_t v243 = *(void *)&v869[40];
                          uint64_t v8 = v832;
                          uint64_t v112 = v834;
                          double v31 = v826;
                          if (!*(void *)&v869[40])
                          {
                            BOOL v244 = (malloc_zone_t *)get_malloc_zone();
                            uint64_t v243 = (uint64_t)malloc_type_zone_calloc(v244, 1uLL, 0x98uLL, 0x743898A5uLL);
                            if (v243) {
                              uint64_t v243 = CA::Render::Layer::Layer(v243, *(uint64_t *)&v869[16]);
                            }
                            int v245 = *(atomic_uint **)&v869[40];
                            *(void *)&v869[40] = v243;
                            if (v245)
                            {
                              if (atomic_fetch_add(v245 + 2, 0xFFFFFFFF) == 1) {
                                (*(void (**)(atomic_uint *))(*(void *)v245 + 16))(v245);
                              }
                              uint64_t v243 = *(void *)&v869[40];
                            }
                          }
                          *(_DWORD *)(v243 + 12) |= 0x1000u;
                          ++*(_DWORD *)(v236 + 84);
                          float64x2_t v246 = *(CA::Render::Layer **)&v869[40];
                          v150.i32[1] = HIDWORD(v858.f64[0]);
                          uint64_t v247 = *(void *)(v236 + 128);
                          if (v247 && *(unsigned char *)(v247 + 12) != 29) {
                            goto LABEL_421;
                          }
                          float v248 = *(float *)(v236 + 100);
                          double v249 = v248;
                          double v250 = (float)(*(float *)(v236 + 104) - v248);
                          int v251 = (CA::Render::Transition *)*(unsigned int *)(v236 + 92);
                          if (v251 == 225)
                          {
                            uint64_t v252 = *(void *)(v236 + 112);
                            if (v252) {
                              int v251 = (CA::Render::Transition *)*(unsigned int *)(v252 + 24);
                            }
                            else {
                              int v251 = 0;
                            }
                          }
                          double v278 = v249 + v858.f64[0] * v250;
                          long long v279 = CA::Render::Transition::lookup_transition(v251, v149, v237);
                          if (v279)
                          {
                            float v280 = v278;
                            uint64_t v281 = (**v279)((CA::Render::BuiltinTransition *)v279, (const CA::Render::TransitionAnimation *)v236, v246, v251, v280);
                            if (v281)
                            {
                              uint64_t v282 = v281;
                              BYTE8(v870) |= 8u;
                              long long v283 = *(atomic_uint **)&v869[40];
                              *(void *)&v869[40] = v282;
                              uint64_t v8 = v832;
                              if (v283 && atomic_fetch_add(v283 + 2, 0xFFFFFFFF) == 1) {
                                (*(void (**)(atomic_uint *))(*(void *)v283 + 16))(v283);
                              }
                              goto LABEL_421;
                            }
                          }
                          uint64_t v284 = (malloc_zone_t *)get_malloc_zone();
                          uint64_t v238 = malloc_type_zone_malloc(v284, 0x50uLL, 0x8BB15036uLL);
                          uint64_t v8 = v832;
                          if (!v238)
                          {
LABEL_421:
                            uint64_t v238 = 0;
                            goto LABEL_422;
                          }
                          int v285 = *(_DWORD *)(v236 + 12);
                          v238[2] = 1;
                          v238[3] = 54;
                          ++dword_1EB2ADEA0;
                          *(void *)uint64_t v238 = &unk_1ED02CED0;
                          v150.i64[0] = *(void *)(v236 + 92);
                          *((void *)v238 + 2) = v150.i64[0];
                          uint64_t v286 = *(void *)(v236 + 120);
                          if (v286)
                          {
                            long long v287 = (atomic_uint *)(v286 + 8);
                            if (!atomic_fetch_add((atomic_uint *volatile)(v286 + 8), 1u))
                            {
                              uint64_t v286 = 0;
                              atomic_fetch_add(v287, 0xFFFFFFFF);
                            }
                          }
                          *((void *)v238 + 3) = v286;
                          uint64_t v288 = *(void *)(v236 + 112);
                          if (v288)
                          {
                            long long v289 = (atomic_uint *)(v288 + 8);
                            unsigned int v290 = atomic_fetch_add((atomic_uint *volatile)(v288 + 8), 1u);
                            int v228 = LODWORD(v822.f64[0]);
                            if (!v290)
                            {
                              uint64_t v288 = 0;
                              atomic_fetch_add(v289, 0xFFFFFFFF);
                            }
                          }
                          else
                          {
                            int v228 = LODWORD(v822.f64[0]);
                          }
                          int v440 = v285 & 0x3000000;
                          *((void *)v238 + 4) = v288;
                          uint64_t v441 = *(void *)(v236 + 128);
                          if (v441)
                          {
                            uint64_t v442 = (atomic_uint *)(v441 + 8);
                            if (!atomic_fetch_add((atomic_uint *volatile)(v441 + 8), 1u))
                            {
                              uint64_t v441 = 0;
                              atomic_fetch_add(v442, 0xFFFFFFFF);
                            }
                          }
                          *((void *)v238 + 5) = v441;
                          float v443 = v278;
                          *((float *)v238 + 12) = v443;
                          *((void *)v238 + 7) = 0;
                          v238[16] = *(_DWORD *)(v236 + 136);
                          v238[17] = 0;
                          v238[18] = *(_DWORD *)(v236 + 140);
                          v238[19] = 0;
                          v238[3] |= v440;
LABEL_423:
                          *((void *)v6 + 15) = v238;
                          if ((v229 & 2) == 0 || (BYTE8(v870) & 8) != 0)
                          {
LABEL_425:
                            if (*(void *)&v869[40]) {
                              long long v291 = *(atomic_uint **)&v869[40];
                            }
                            else {
                              long long v291 = *(atomic_uint **)&v869[16];
                            }
                            long long v292 = (const CA::Render::Object *)*((void *)v6 + 4);
                            if (v292 != (const CA::Render::Object *)v291)
                            {
                              CA::Render::Update::release_object((uint64_t *)*v7, v292);
                              *((void *)v6 + 4) = v291;
                              if (!atomic_fetch_add(v291 + 2, 1u)) {
                                atomic_fetch_add(v291 + 2, 0xFFFFFFFF);
                              }
                            }
                            if (v823) {
                              long long v293 = &v837;
                            }
                            else {
                              long long v293 = 0;
                            }
                            CA::Render::LayerNode::update_frame_transform((uint64_t)v6, v293->f64);
                            uint64_t v112 = v834;
                          }
LABEL_435:
                          uint64_t v32 = v831;
                          if (!v228 || (BYTE8(v870) & 0x10) == 0) {
                            goto LABEL_457;
                          }
                          int v294 = *(_DWORD *)&v869[168];
                          if ((*(_WORD *)&v869[168] & 0x800) == 0)
                          {
                            float64x2_t v295 = v853;
                            float64x2_t v296 = v837;
                            if ((*(_WORD *)&v869[168] & 0x200) != 0 && (v869[168] & 0x30) != 0)
                            {
                              char v297 = 9;
                              goto LABEL_443;
                            }
                            if ((v857 & 0x200) != 0)
                            {
                              uint64_t v412 = *(void *)(*(void *)&v869[32] + 56);
                              if (!v412
                                || (v150.i64[0] = *(void *)(v412 + 24), *(double *)v150.i64 == 0.0)
                                && (v150.i64[0] = *(void *)(v412 + 56), *(double *)v150.i64 == 0.0))
                              {
                                uint64_t v413 = *(void *)&v869[40];
                                if (*(void *)&v869[40]) {
                                  uint64_t v414 = *(void *)&v869[40];
                                }
                                else {
                                  uint64_t v414 = *(void *)&v869[16];
                                }
                                uint64_t v415 = *(void *)(*(void *)&v869[32] + 88);
                                if (v415)
                                {
                                  uint64_t v416 = *(void *)(v415 + 32);
                                  if (v416 && (uint64_t v417 = *(void *)(v416 + 128)) != 0)
                                  {
                                    uint64_t v418 = *(void *)(v417 + 24);
                                    if (v418)
                                    {
                                      float64x2_t v818 = v837;
                                      float64x2_t v822 = v853;
                                      if (*(_DWORD *)(v418 + 16) <= 0xFu) {
                                        v419 = (CA::Mat4Impl *)&CA::Mat4Impl::mat4_identity_double;
                                      }
                                      else {
                                        v419 = (CA::Mat4Impl *)(v418 + 24);
                                      }
                                      if (CA::Mat4Impl::mat4_is_projective(v419, v149))
                                      {
                                        float64x2_t v295 = v822;
                                        float64x2_t v296 = v818;
                                        if ((v294 & 0x400) != 0)
                                        {
                                          v869[172] = 10;
                                          *(_DWORD *)&v869[168] = 2048;
                                          unsigned int v298 = 5;
                                          uint64_t v32 = v831;
                                          double v31 = v826;
                                          goto LABEL_445;
                                        }
LABEL_728:
                                        uint64_t v420 = *(void *)(v414 + 128);
                                        if (v420)
                                        {
                                          int8x16_t v421 = *(int8x16_t *)(v420 + 168);
                                        }
                                        else
                                        {
                                          double v422 = 0.0;
                                          if ((*(unsigned char *)(v414 + 45) & 0x40) == 0) {
                                            double v422 = 0.5;
                                          }
                                          int8x16_t v421 = (int8x16_t)vdupq_lane_s64(*(uint64_t *)&v422, 0);
                                        }
                                        int8x16_t v225 = (int8x16_t)vcvtq_f64_f32(v854);
                                        *(double *)v150.i64 = v855;
                                        int8x16_t v151 = *(int8x16_t *)(v414 + 80);
                                        if ((v294 & 0x80) == 0)
                                        {
                                          if ((v294 & 0xFFFFF7FF) != 0)
                                          {
                                            __asm { FMOV            V6.2D, #-0.5 }
                                            *(float64x2_t *)&v869[56] = vmulq_f64(*(float64x2_t *)&v869[56], v295);
                                            *(float64x2_t *)&v869[88] = vmulq_f64(*(float64x2_t *)&v869[88], v295);
                                            *(float64x2_t *)&v869[104] = vmulq_f64(*(float64x2_t *)&v869[104], v295);
                                            *(float64x2_t *)&v869[72] = vmulq_f64(*(float64x2_t *)&v869[72], v295);
                                            *(float64x2_t *)&v869[136] = vmulq_f64(*(float64x2_t *)&v869[136], v295);
                                            float64x2_t v424 = vaddq_f64(vaddq_f64(*(float64x2_t *)&v869[56], (float64x2_t)v225), *(float64x2_t *)&v869[136]);
                                            float64x2_t v425 = vmulq_f64(*(float64x2_t *)&v869[88], v296);
                                            float64x2_t v426 = vmulq_f64(*(float64x2_t *)&v869[104], (float64x2_t)v151);
                                            int8x16_t v427 = (int8x16_t)vsubq_f64(v821, (float64x2_t)v421);
                                            float64x2_t v428 = vaddq_f64(v426, v425);
                                            float64x2_t v429 = vmlsq_f64(v424, (float64x2_t)v421, v428);
                                            float64x2_t v430 = vnegq_f64(v424);
                                            float64x2_t v431 = vmlaq_f64(v424, (float64x2_t)v427, v428);
                                            float32x2_t v432 = vcvt_f32_f64(vnegq_f64(vmlaq_f64(vcvtq_f64_f32(vcvt_f32_f64(vmlaq_f64(vcvtq_f64_f32(vcvt_f32_f64(vmlaq_f64(v430, (float64x2_t)v421, v425))), vaddq_f64((float64x2_t)v421, _Q6), v426))), v296, *(float64x2_t *)&v869[72])));
                                            float32x2_t v854 = v432;
                                            v425.f64[0] = 0.5 * v426.f64[0];
                                            v426.f64[0] = vmuld_lane_f64(0.5, v426, 1);
                                            double v433 = sqrt(v425.f64[0] * v425.f64[0] + v426.f64[0] * v426.f64[0]);
                                            double v434 = 0.0;
                                            uint64_t v32 = v831;
                                            double v31 = v826;
                                            if ((v294 & 0x100) != 0)
                                            {
                                              float64x2_t v435 = vmulq_f64(vmulq_f64(vmulq_f64(v296, v295), (float64x2_t)v151), (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v421, (float64x2_t)v427), v421, v427));
                                              int8x16_t v151 = (int8x16_t)vmulq_f64(v435, v435);
                                              double v434 = fabs(*(double *)&v869[160]) * sqrt(vaddvq_f64((float64x2_t)v151));
                                            }
                                            double v436 = v434 + v433;
                                            *(double *)v151.i64 = v434 + v433 + sqrtf(vaddv_f32(vmul_f32(v432, v432)));
                                            float64x2_t v437 = (float64x2_t)vbslq_s8((int8x16_t)vcagtq_f64(v429, v431), (int8x16_t)vabsq_f64(v429), (int8x16_t)vabsq_f64(v431));
                                            double v438 = v434 + sqrt(vaddvq_f64(vmulq_f64(v437, v437)));
                                            if (*(double *)v151.i64 > v438) {
                                              double v438 = *(double *)v151.i64;
                                            }
                                            if ((*(unsigned char *)(v413 + 13) & 9) == 0) {
                                              *(double *)v151.i64 = v438;
                                            }
                                            *(double *)v225.i64 = v436 + *(double *)v150.i64;
                                            *(float *)v225.i32 = v436 + *(double *)v150.i64;
                                            float v855 = *(float *)v225.i32;
                                          }
                                          else
                                          {
                                            v151.i64[0] = 0;
                                            uint64_t v32 = v831;
                                            double v31 = v826;
                                          }
                                          goto LABEL_899;
                                        }
                                        if (*(_DWORD *)(v418 + 16) <= 0xFu) {
                                          unint64_t v439 = (double *)&CA::Mat4Impl::mat4_identity_double;
                                        }
                                        else {
                                          unint64_t v439 = (double *)(v418 + 24);
                                        }
                                        if ((v294 & 0xFFFFFF7F) != 0)
                                        {
                                          double v31 = v826;
                                          if ((v294 & 0x800) == 0) {
                                            goto LABEL_758;
                                          }
LABEL_759:
                                          *(_DWORD *)&v869[168] = 2048;
                                          unsigned int v298 = 5;
                                          uint64_t v32 = v831;
                                          goto LABEL_445;
                                        }
                                        double v31 = v826;
                                        if (v439[3] != 0.0 || v439[7] != 0.0)
                                        {
LABEL_758:
                                          v869[172] = 5;
                                          goto LABEL_759;
                                        }
                                        if (v420) {
                                          double v444 = *(double *)(v420 + 192) - *(double *)(v420 + 184);
                                        }
                                        else {
                                          double v444 = 0.0;
                                        }
                                        double v513 = v439[11];
                                        double v514 = -(v513 * *(double *)&v869[152]);
                                        double v515 = (v439[15] + v513 * v444) * (v439[15] + v513 * v444);
                                        if (v420)
                                        {
                                          float64x2_t v516 = *(float64x2_t *)(v420 + 168);
                                        }
                                        else
                                        {
                                          double v517 = 0.0;
                                          if ((*(unsigned char *)(v414 + 45) & 0x40) == 0) {
                                            double v517 = 0.5;
                                          }
                                          float64x2_t v516 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v517, 0);
                                        }
                                        float64x2_t v518 = *(float64x2_t *)(v414 + 48);
                                        float64x2_t v519 = *(float64x2_t *)(v416 + 64);
                                        float64x2_t v520 = *(float64x2_t *)(v416 + 80);
                                        uint64_t v521 = *(void *)(v416 + 128);
                                        double v522 = v514 / v515;
                                        if (v521)
                                        {
                                          float64x2_t v523 = *(float64x2_t *)(v521 + 168);
                                        }
                                        else
                                        {
                                          double v524 = 0.0;
                                          if ((*(unsigned char *)(v416 + 45) & 0x40) == 0) {
                                            double v524 = 0.5;
                                          }
                                          float64x2_t v523 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v524, 0);
                                        }
                                        uint64_t v32 = v831;
                                        float64x2_t v525 = vmulq_n_f64(v295, v522);
                                        float64x2_t v526 = vmulq_f64((float64x2_t)v151, v295);
                                        double v527 = v522 * v526.f64[0];
                                        double v528 = vmuld_lane_f64(v522, v526, 1);
                                        *(float *)&double v528 = *(double *)v150.i64 + sqrt(v527 * v527 + v528 * v528) * 0.5;
                                        float v855 = *(float *)&v528;
                                        float64x2_t v529 = vsubq_f64(v518, vmlaq_f64(vmlaq_f64(v519, (float64x2_t)v151, v516), v520, v523));
                                        float64x2_t v530 = vmlaq_f64((float64x2_t)v225, v529, v525);
                                        float64x2_t v531 = vmlaq_f64((float64x2_t)v225, vaddq_f64(v529, (float64x2_t)v151), v525);
                                        __asm { FMOV            V3.2D, #0.5 }
                                        float32x2_t v854 = vcvt_f32_f64(vmulq_f64(vaddq_f64(v531, v530), _Q3));
                                        int8x16_t v533 = (int8x16_t)vabsq_f64(v531);
                                        int8x16_t v225 = (int8x16_t)vcagtq_f64(v530, v531);
                                        float64x2_t v534 = (float64x2_t)vbslq_s8(v225, (int8x16_t)vabsq_f64(v530), v533);
                                        int8x16_t v151 = (int8x16_t)vmulq_f64(v534, v534);
                                        *(double *)v151.i64 = sqrt(vaddvq_f64((float64x2_t)v151));
LABEL_899:
                                        double v535 = *(double *)v151.i64 + *(double *)v150.i64;
                                        if (CA::Render::AnimationEvaluator::velocity_pass(CA::Vec2<double>,CA::Vec2<double>,BOOL,CA::Vec2<float> &,float &)::once[0] != -1) {
                                          dispatch_once(CA::Render::AnimationEvaluator::velocity_pass(CA::Vec2<double>,CA::Vec2<double>,BOOL,CA::Vec2<float> &,float &)::once, &__block_literal_global_19748);
                                        }
                                        if (CA::Render::AnimationEvaluator::velocity_pass(CA::Vec2<double>,CA::Vec2<double>,BOOL,CA::Vec2<float> &,float &)::has_thresholds)
                                        {
                                          *(double *)v150.i64 = *(float *)&CA::Render::AnimationEvaluator::velocity_pass(CA::Vec2<double>,CA::Vec2<double>,BOOL,CA::Vec2<float> &,float &)::thresholds;
                                          if (v535 >= *(float *)&CA::Render::AnimationEvaluator::velocity_pass(CA::Vec2<double>,CA::Vec2<double>,BOOL,CA::Vec2<float> &,float &)::thresholds)
                                          {
                                            unsigned int v298 = 4;
                                          }
                                          else
                                          {
                                            *(double *)v150.i64 = *((float *)&CA::Render::AnimationEvaluator::velocity_pass(CA::Vec2<double>,CA::Vec2<double>,BOOL,CA::Vec2<float> &,float &)::thresholds
                                                                  + 1);
                                            if (v535 >= *((float *)&CA::Render::AnimationEvaluator::velocity_pass(CA::Vec2<double>,CA::Vec2<double>,BOOL,CA::Vec2<float> &,float &)::thresholds
                                                         + 1))
                                            {
                                              unsigned int v298 = 3;
                                            }
                                            else
                                            {
                                              *(double *)v150.i64 = *((float *)&CA::Render::AnimationEvaluator::velocity_pass(CA::Vec2<double>,CA::Vec2<double>,BOOL,CA::Vec2<float> &,float &)::thresholds
                                                                    + 2);
                                              if (v535 >= *((float *)&CA::Render::AnimationEvaluator::velocity_pass(CA::Vec2<double>,CA::Vec2<double>,BOOL,CA::Vec2<float> &,float &)::thresholds
                                                           + 2))
                                                unsigned int v298 = 2;
                                              else {
                                                unsigned int v298 = 1;
                                              }
                                            }
                                          }
                                        }
                                        else
                                        {
                                          unsigned int v298 = 5;
                                        }
                                        if (!byte_1EB2ACC4E && v869[176] < v298) {
                                          unsigned int v298 = v869[176];
                                        }
LABEL_445:
                                        long long v299 = *(void **)(v8 + 184);
                                        if (v299 && v298 == 5)
                                        {
                                          if (v869[177] == 3)
                                          {
                                            v150.i32[0] = 1117782016;
                                            v151.i32[0] = 1123024896;
                                            v225.i32[0] = 1117782016;
LABEL_451:
                                            objc_msgSend(v299, "addFrameRateRange:", *(double *)v150.i64, *(double *)v151.i64, *(double *)v225.i64, v804.i64[0]);
                                          }
                                          else if (v869[177] == 4)
                                          {
                                            v151.i32[0] = 1123024896;
                                            v150.i32[0] = 1117782016;
                                            v225.i32[0] = 1123024896;
                                            goto LABEL_451;
                                          }
                                        }
                                        __int16 v300 = v857 & 0xFFC7 | (8 * (v869[176] & 7));
                                        if ((v857 & 7) != 5) {
                                          __int16 v300 = v857 & 0xFFC0 | (8 * (v869[176] & 7)) | v298;
                                        }
                                        __int16 v857 = v300;
                                        _ZF = v298 == 5;
                                        uint64_t v112 = v834;
                                        if (_ZF) {
                                          [*(id *)(v8 + 184) addReason:v869[172] | 0x20000u];
                                        }
LABEL_457:
                                        uint64_t v301 = *((void *)v6 + 4);
                                        uint64_t v152 = v112;
                                        if (v301 != v112)
                                        {
                                          int v302 = *(_DWORD *)(v301 + 12);
                                          if ((v302 & 0x1000) != 0
                                            || !CA::Render::Layer::is_containerable(*((CA::Render::Layer **)v6 + 4), v149))
                                          {
                                            unsigned int v303 = v302 & 0xFFFFF7FF;
                                          }
                                          else
                                          {
                                            unsigned int v303 = v302 | 0x800;
                                          }
                                          *(_DWORD *)(v301 + 12) = v303;
                                          uint64_t v152 = *((void *)v6 + 4);
                                          uint64_t v112 = v834;
                                        }
                                        uint64_t v304 = *(void *)&v869[40];
                                        if (*(void *)&v869[40]
                                          && atomic_fetch_add((atomic_uint *volatile)(*(void *)&v869[40] + 8), 0xFFFFFFFF) == 1)
                                        {
                                          (*(void (**)(uint64_t))(*(void *)v304 + 16))(v304);
                                        }
                                        LODWORD(v821.f64[0]) = 1;
LABEL_467:
                                        long long v305 = (CA::Render *)v829;
                                        long long v306 = *(CA::Render::Context **)(v32 + 88);
                                        if (v306
                                          && ((uint64_t v307 = CA::Render::Context::root_layer_handle(v306)) == 0
                                            ? (uint64_t v308 = 0)
                                            : (uint64_t v308 = *(void *)(v307 + 16)),
                                              v308 == v112
                                           && (uint64_t v504 = *(void *)(*(void *)v32 + 32),
                                               (uint64_t v505 = *(uint64_t **)(v504 + 128)) != 0)
                                           && (uint64_t v506 = *v505) != 0
                                           && (int v507 = *(_DWORD *)(v506 + 12), v507 == 30)))
                                        {
                                          if ((v507 & 0x1000) == 0
                                            || *(double *)(v504 + 64) == *(double *)(v152 + 64)
                                            && *(double *)(v504 + 72) == *(double *)(v152 + 72)
                                            && *(double *)(v504 + 80) == *(double *)(v152 + 80)
                                            && *(double *)(v504 + 88) == *(double *)(v152 + 88))
                                          {
                                            if ((v507 & 0x4000) == 0)
                                            {
                                              uint64_t v309 = v152;
                                              goto LABEL_871;
                                            }
                                            v868[0] = xmmword_184997D50;
                                            v868[1] = 0u;
                                            v868[2] = xmmword_184997D60;
                                            memset(&v868[3], 0, 32);
                                            v868[5] = xmmword_184997D50;
                                            v868[6] = 0u;
                                            v868[7] = xmmword_184997D60;
                                            v836[0] = &unk_1ED0301F0;
                                            v836[1] = v868;
                                            v778 = (CA::Render::LayerNode *)*((void *)v833 + 11);
                                            if (v778) {
                                              CA::Render::LayerNode::MapGeometry::map((uint64_t)v836, 0, v778);
                                            }
                                            memset(v869, 0, 152);
                                            CA::Transform::set((uint64_t)v869, (CA::Mat4Impl *)v868, 1);
                                            uint64_t v781 = *v828;
                                            v782 = *(float64x2_t **)(*v828 + 1064);
                                            if (v782) {
                                              CA::Transform::concat_left((CA::Transform *)v869, v782, v779, v780);
                                            }
                                            v783 = (CA::Mat4Impl *)*((void *)v833 + 7);
                                            if (v783)
                                            {
                                              uint64_t v867 = 0;
                                              long long v865 = 0u;
                                              long long v866 = 0u;
                                              long long v863 = 0u;
                                              long long v864 = 0u;
                                              float64x2_t v861 = 0u;
                                              long long v862 = 0u;
                                              float64x2_t v859 = 0u;
                                              float64x2_t v860 = 0u;
                                              float64x2_t v858 = 0u;
                                              CA::Transform::set((uint64_t)&v858, v783, 1);
                                              CA::Transform::concat_left((CA::Transform *)v869, &v858, v784, v785);
                                            }
                                            else
                                            {
                                              CA::Transform::translate((CA::Transform *)v869, *((double *)v833 + 8), *((double *)v833 + 9), *((double *)v833 + 10));
                                            }
                                            if ((*(_DWORD *)(v781 + 1084) & 0x8000000) != 0)
                                            {
                                              uint64_t v867 = 0;
                                              long long v865 = 0u;
                                              long long v866 = 0u;
                                              long long v863 = 0u;
                                              long long v864 = 0u;
                                              float64x2_t v861 = 0u;
                                              long long v862 = 0u;
                                              float64x2_t v859 = 0u;
                                              float64x2_t v860 = 0u;
                                              float64x2_t v858 = 0u;
                                              long long v786 = *(_OWORD *)(v781 + 624);
                                              long long v787 = *(_OWORD *)(v781 + 640);
                                              long long v788 = *(_OWORD *)(v781 + 656);
                                              v835[0] = *(_OWORD *)(v781 + 608);
                                              v835[1] = v786;
                                              v835[2] = v787;
                                              v835[3] = v788;
                                              long long v789 = *(_OWORD *)(v781 + 688);
                                              long long v790 = *(_OWORD *)(v781 + 704);
                                              long long v791 = *(_OWORD *)(v781 + 720);
                                              v835[4] = *(_OWORD *)(v781 + 672);
                                              v835[5] = v789;
                                              v835[6] = v790;
                                              v835[7] = v791;
                                              CA::Transform::set((uint64_t)&v858, (CA::Mat4Impl *)v835, 1);
                                              CA::Transform::concat_left((CA::Transform *)v869, &v858, v792, v793);
                                            }
                                            float64x2_t v6 = v833;
                                            CA::Render::LayerNode::set_frame_transform(v833, (const CA::Transform *)v869);
                                            uint64_t v309 = v152;
                                          }
                                          else
                                          {
                                            v770 = x_mem_alloc0(0x98uLL);
                                            uint64_t v309 = (uint64_t)v770;
                                            if (v770) {
                                              CA::Render::Layer::Layer((uint64_t)v770, v152);
                                            }
                                            v771 = *(float64_t **)(*(void *)v831 + 32);
                                            double v772 = v771[9];
                                            double v773 = v771[10];
                                            double v774 = v771[11];
                                            v858.f64[0] = v771[8];
                                            v858.f64[1] = v772;
                                            v859.f64[0] = v773 + v858.f64[0];
                                            v859.f64[1] = v772;
                                            v860.f64[0] = v773 + v858.f64[0];
                                            v860.f64[1] = v774 + v772;
                                            v861.f64[0] = v858.f64[0];
                                            v861.f64[1] = v774 + v772;
                                            uint64_t v775 = *(void *)(v152 + 128);
                                            if (v775)
                                            {
                                              double v777 = *(double *)(v775 + 168);
                                              double v776 = *(double *)(v775 + 176);
                                            }
                                            else
                                            {
                                              double v776 = 0.0;
                                              if ((*(unsigned char *)(v152 + 45) & 0x40) == 0) {
                                                double v776 = 0.5;
                                              }
                                              double v777 = v776;
                                            }
                                            uint64_t v794 = 0;
                                            *(double *)v868 = v777;
                                            *((double *)v868 + 1) = v776;
                                            float64x2_t v795 = vmlaq_n_f64(v858, vsubq_f64(v859, v858), v777);
                                            int64x2_t v796 = (int64x2_t)vmlaq_n_f64(v795, vmlaq_n_f64(vsubq_f64(v861, v795), vsubq_f64(v860, v861), v777), v776);
                                            float64x2_t v797 = (float64x2_t)vdupq_lane_s64(v796.i64[0], 0);
                                            float64x2_t v822 = (float64x2_t)v796;
                                            float64x2_t v798 = (float64x2_t)vdupq_laneq_s64(v796, 1);
                                            do
                                            {
                                              v799 = &v858.f64[v794];
                                              float64x2x2_t v872 = vld2q_f64(v799);
                                              v873.val[0] = vsubq_f64(v872.val[0], v797);
                                              v873.val[1] = vsubq_f64(v872.val[1], v798);
                                              vst2q_f64(v799, v873);
                                              v794 += 4;
                                            }
                                            while (v794 != 8);
                                            v835[0] = *(_OWORD *)(v152 + 80);
                                            CA::Mat4Impl::mat4_set_corner_matrix((uint64_t)v869, v858.f64, (double *)v835, (double *)v868);
                                            LODWORD(v836[0]) = 568;
                                            CA::Render::Layer::set_property_value((CA::Render::Layer *)v309, (const unsigned int *)v836, (double *)1, 0, (CA::Render::Vector *)0x10, (double *)v869, v800);
                                            *(void *)(v309 + 40) &= ~0x200uLL;
                                            *(float64x2_t *)(v309 + 48) = v822;
                                            v801 = (const CA::Render::Object *)*((void *)v833 + 4);
                                            if (v801 != (const CA::Render::Object *)v309)
                                            {
                                              CA::Render::Update::release_object((uint64_t *)*v828, v801);
                                              *((void *)v833 + 4) = v309;
                                              if (!atomic_fetch_add((atomic_uint *volatile)(v309 + 8), 1u)) {
                                                atomic_fetch_add((atomic_uint *volatile)(v309 + 8), 0xFFFFFFFF);
                                              }
                                            }
                                            if (v823) {
                                              v802 = &v837;
                                            }
                                            else {
                                              v802 = 0;
                                            }
                                            CA::Render::LayerNode::update_frame_transform((uint64_t)v833, v802->f64);
                                            if (atomic_fetch_add((atomic_uint *volatile)(v309 + 8), 0xFFFFFFFF) == 1) {
                                              (*(void (**)(uint64_t))(*(void *)v309 + 16))(v309);
                                            }
LABEL_871:
                                            float64x2_t v6 = v833;
                                          }
                                          float64x2_t v7 = v828;
                                          long long v305 = (CA::Render *)v829;
                                          uint64_t v32 = v831;
                                          uint64_t v8 = v832;
                                          uint64_t v112 = v834;
                                          double v31 = v826;
                                        }
                                        else
                                        {
                                          uint64_t v309 = v152;
                                        }
                                        if ((*(unsigned char *)(v309 + 13) & 8) != 0)
                                        {
                                          if ((LODWORD(v31) & 0x2000000) == 0)
                                          {
                                            if ((*v830 & 4) == 0) {
                                              goto LABEL_474;
                                            }
                                            uint64_t v312 = *(void *)(v8 + 344);
                                            if (v312)
                                            {
                                              if (!(*(unsigned int (**)(uint64_t, void, CA::Render::LayerNode *, uint64_t))(*(void *)v312 + 24))(v312, v7[3], v6, v309))goto LABEL_474; {
                                            }
                                              }
                                            else if (((*(void *)&v31 >> 25) & 1) == 0)
                                            {
                                              goto LABEL_474;
                                            }
                                          }
                                          v346 = (malloc_zone_t *)get_malloc_zone();
                                          uint64_t v347 = malloc_type_zone_calloc(v346, 1uLL, 0x98uLL, 0x743898A5uLL);
                                          uint64_t v310 = (uint64_t)v347;
                                          if (v347) {
                                            CA::Render::Layer::Layer((uint64_t)v347, v309);
                                          }
                                          *(_DWORD *)(v310 + 12) = *(_DWORD *)(v310 + 12) & 0xFFFFE7FF | 0x1000;
                                          float v149 = (const double *)*((void *)v6 + 4);
                                          if (v149 != (const double *)v310)
                                          {
                                            CA::Render::Update::release_object((uint64_t *)*v7, (const CA::Render::Object *)v149);
                                            *((void *)v6 + 4) = v310;
                                            if (!atomic_fetch_add((atomic_uint *volatile)(v310 + 8), 1u)) {
                                              atomic_fetch_add((atomic_uint *volatile)(v310 + 8), 0xFFFFFFFF);
                                            }
                                          }
                                          if (atomic_fetch_add((atomic_uint *volatile)(v310 + 8), 0xFFFFFFFF) == 1) {
                                            (*(void (**)(uint64_t))(*(void *)v310 + 16))(v310);
                                          }
                                        }
                                        else
                                        {
LABEL_474:
                                          uint64_t v310 = v309;
                                        }
                                        unint64_t v311 = *v830 | ((unint64_t)*((unsigned __int16 *)v830 + 2) << 32);
                                        if ((v311 & 0x1000000000) != 0)
                                        {
                                          int v313 = v857 & 7;
                                          if (v313 == 5 || v313 == 0) {
                                            int v315 = 2;
                                          }
                                          else {
                                            int v315 = 1;
                                          }
                                          LODWORD(v813) = v315;
                                        }
                                        else
                                        {
                                          LODWORD(v813) = 0;
                                        }
                                        *(void *)&v822.f64[0] = v310;
                                        if (!v825 && !*(void *)(v112 + 136))
                                        {
                                          uint64_t v336 = v849.i64[1];
                                          goto LABEL_624;
                                        }
                                        BOOL v316 = (os_unfair_lock_s *)&v853;
                                        double v317 = *(double *)(v32 + 16);
                                        float v318 = *(float *)(v32 + 56);
                                        double v319 = v842;
                                        double v320 = v843;
                                        float v321 = v847;
                                        v809.i32[0] = *((_DWORD *)v7 + 2);
                                        v818.f64[0] = *(float64_t *)(v8 + 184);
                                        LODWORD(v817) = *(_DWORD *)(v8 + 276);
                                        if ((v820 & 0x200000) == 0) {
                                          BOOL v316 = 0;
                                        }
                                        unint64_t v820 = (unint64_t)v316;
                                        v150.i64[0] = 0x7FF0000000000000;
                                        *(double *)v151.i64 = v318;
                                        v322.f64[0] = NAN;
                                        v322.f64[1] = NAN;
                                        int8x16_t v323 = vbslq_s8((int8x16_t)vnegq_f64(v322), v150, v151);
                                        uint64_t v324 = *(void *)(v112 + 128);
                                        if (v324)
                                        {
                                          unint64_t v325 = 0;
                                          uint64_t v326 = *(void *)(v324 + 8);
                                          LODWORD(v324) = v326 != 0;
                                          float v327 = v318;
                                          v807 = (atomic_uint *)v326;
                                          if (v318 != 0.0 && v326)
                                          {
                                            int8x16_t v810 = v323;
                                            double v328 = *(double *)(v326 + 40);
                                            float v329 = v318;
                                            *(double *)v150.i64 = CA::Render::Timing::end_time((CA::Render::Timing *)v326);
                                            float v327 = v329;
                                            unsigned int v330 = *(_DWORD *)(v326 + 12);
                                            int v331 = (v330 >> 10) & 1;
                                            int v332 = (v330 >> 9) & 1;
                                            if (v329 < 0.0) {
                                              double v333 = *(double *)v150.i64;
                                            }
                                            else {
                                              double v333 = v328;
                                            }
                                            if (v329 >= 0.0)
                                            {
                                              int v334 = v331;
                                            }
                                            else
                                            {
                                              *(double *)v150.i64 = v328;
                                              int v334 = v332;
                                            }
                                            if (v329 < 0.0) {
                                              int v332 = v331;
                                            }
                                            BOOL v335 = v333 > v317;
                                            if (v329 <= 0.0) {
                                              BOOL v335 = v333 < v317;
                                            }
                                            if (v335)
                                            {
                                              int8x16_t v150 = v810;
                                              if (!v334) {
                                                *(double *)v150.i64 = v333;
                                              }
                                              int8x16_t v323 = v150;
                                              unint64_t v325 = (unint64_t)(v334 == 0) << 11;
LABEL_539:
                                              LODWORD(v324) = 1;
                                            }
                                            else
                                            {
                                              BOOL v337 = *(double *)v150.i64 > v317;
                                              if (v329 <= 0.0) {
                                                BOOL v337 = *(double *)v150.i64 < v317;
                                              }
                                              if (v337)
                                              {
                                                double v338 = *(double *)(v326 + 32);
                                                if ((*(void *)&v338 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
                                                  || (float v327 = v329, *(double *)(v326 + 24) == 0.0))
                                                {
                                                  int8x16_t v323 = v810;
                                                  if ((v150.i64[0] & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000
                                                    && v332 == 0)
                                                  {
                                                    v323.i64[0] = v150.i64[0];
                                                    unint64_t v325 = 2048;
                                                  }
                                                  else
                                                  {
                                                    unint64_t v325 = 0;
                                                  }
                                                  goto LABEL_539;
                                                }
                                                float v339 = *(float *)(v326 + 16);
                                                *(double *)v150.i64 = v317;
                                                if ((float)(v339 * v329) != 0.0)
                                                {
                                                  v150.i64[0] = *(void *)(v326 + 40);
                                                  if (*(double *)v150.i64 <= v317)
                                                  {
                                                    double v340 = v339;
                                                    double v341 = *(double *)(v326 + 48);
                                                    double v342 = floor((v341 + (v317 - *(double *)v150.i64) * v340) / v338);
                                                    double v343 = -0.000001;
                                                    if (v329 > 0.0) {
                                                      double v343 = v338 + -0.000001;
                                                    }
                                                    double v344 = (v343 + v342 * v338 - v341) / v340 + *(double *)v150.i64;
                                                    if ((*(void *)&v344 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000) {
                                                      double v345 = v317;
                                                    }
                                                    else {
                                                      double v345 = v344;
                                                    }
                                                    *(double *)v150.i64 = CA::Render::Timing::end_time((CA::Render::Timing *)v326)
                                                                        + -0.000001;
                                                    if (v345 <= *(double *)v150.i64) {
                                                      *(double *)v150.i64 = v345;
                                                    }
                                                  }
                                                }
                                                *(double *)v323.i64 = *(double *)v150.i64 + -0.000001;
                                                LODWORD(v324) = 1;
                                                unint64_t v325 = 2048;
                                                uint64_t v112 = v834;
                                                float v327 = v329;
                                              }
                                              else
                                              {
                                                unint64_t v325 = 0;
                                                LODWORD(v324) = 1;
                                                int8x16_t v323 = v810;
                                              }
                                            }
                                          }
                                        }
                                        else
                                        {
                                          v807 = 0;
                                          unint64_t v325 = 0;
                                          float v327 = v318;
                                        }
                                        LODWORD(v868[0]) = 0;
                                        LODWORD(v835[0]) = 0;
                                        uint64_t v348 = *(void *)(v112 + 136);
                                        if (!v348 || (int v805 = v324, !*(_DWORD *)(v348 + 16)))
                                        {
                                          uint64_t v32 = v831;
                                          goto LABEL_612;
                                        }
                                        int8x16_t v810 = v323;
                                        *(float *)&v806 = v327;
                                        LODWORD(v812) = 0;
                                        uint64_t v349 = 0;
                                        *(double *)v150.i64 = v321;
                                        v323.i64[0] = 0x7FF0000000000000;
                                        v350.f64[0] = NAN;
                                        v350.f64[1] = NAN;
                                        int8x16_t v351 = vbslq_s8((int8x16_t)vnegq_f64(v350), v323, v150);
                                        uint64_t v808 = (v311 >> 35) & 1;
                                        int8x16_t v811 = v351;
                                        double v826 = *(double *)v351.i64;
                                        while (2)
                                        {
                                          uint64_t v352 = *(void *)(v348 + 24 + 8 * v349);
                                          int v353 = *(_DWORD *)(v352 + 12);
                                          if ((v353 & 0x20100) != 0x100) {
                                            goto LABEL_597;
                                          }
                                          uint64_t v354 = *(void *)(v352 + 40);
                                          if (v354)
                                          {
                                            double v355 = *(double *)(v354 + 40);
                                            double v356 = CA::Render::Timing::end_time(*(CA::Render::Timing **)(v352 + 40));
                                            if ((*(_DWORD *)(v352 + 12) & 0x8000) == 0) {
                                              goto LABEL_550;
                                            }
                                          }
                                          else
                                          {
                                            double v355 = 0.0;
                                            double v356 = INFINITY;
                                            if ((v353 & 0x8000) == 0) {
                                              goto LABEL_550;
                                            }
                                          }
                                          float v357 = *(float *)(v352 + 32);
                                          if (v357 != 0.0)
                                          {
                                            double v358 = 1.0 / v357;
                                            double v355 = v355 - v358;
                                            double v356 = v358 + v356;
                                          }
LABEL_550:
                                          v325 |= (*(void *)&v353 & 0x10000) << 28;
                                          if (v321 != 0.0)
                                          {
                                            if (v321 >= 0.0) {
                                              double v359 = v355;
                                            }
                                            else {
                                              double v359 = v356;
                                            }
                                            BOOL v360 = v359 > v319;
                                            if (v321 >= 0.0) {
                                              double v361 = v356;
                                            }
                                            else {
                                              double v361 = v355;
                                            }
                                            if (v321 <= 0.0) {
                                              BOOL v360 = v359 < v319;
                                            }
                                            if (v360)
                                            {
                                              BOOL v362 = v359 <= v320;
                                              if (v321 <= 0.0) {
                                                BOOL v362 = v359 >= v320;
                                              }
                                              goto LABEL_577;
                                            }
                                            BOOL v363 = v361 > v319;
                                            if (v321 <= 0.0) {
                                              BOOL v363 = v361 < v319;
                                            }
                                            if (v363)
                                            {
                                              *(double *)v869 = v361;
                                              int v364 = (*(uint64_t (**)(uint64_t))(*(void *)v352 + 104))(v352);
                                              v858.f64[0] = INFINITY;
                                              if (v364)
                                              {
                                                uint64_t v365 = v813;
                                                (*(void (**)(uint64_t, void, void, void, uint64_t, unsigned char *, uint64_t, unint64_t, double, float, _OWORD *))(*(void *)v352 + 112))(v352, *(void *)&v818.f64[0], v813, v817, v808, v869, v834, v820, v319, v321, v868);
                                                if (v320 != v319)
                                                {
                                                  (*(void (**)(uint64_t, void, uint64_t, void, uint64_t, float64x2_t *, uint64_t, unint64_t, double, float, _OWORD *))(*(void *)v352 + 112))(v352, *(void *)&v818.f64[0], v365, v817, v808, &v858, v834, v820, v320, v321, v835);
                                                  if (*(double *)v869 != v858.f64[0]) {
                                                    goto LABEL_575;
                                                  }
                                                }
                                              }
                                              BOOL v366 = v359 > v320;
                                              if (v321 <= 0.0) {
                                                BOOL v366 = v359 < v320;
                                              }
                                              if (v366) {
                                                goto LABEL_575;
                                              }
                                              BOOL v367 = v361 > v320;
                                              if (v321 <= 0.0) {
                                                BOOL v367 = v361 < v320;
                                              }
                                              if (v367 && *(_DWORD *)(v352 + 76) != v809.i32[0]) {
                                                BOOL v362 = 0;
                                              }
                                              else {
LABEL_575:
                                              }
                                                BOOL v362 = 1;
                                              double v359 = *(double *)v869;
                                              long long v305 = (CA::Render *)v829;
                                              if (v359 >= INFINITY) {
                                                goto LABEL_583;
                                              }
LABEL_577:
                                              v325 |= 0x800uLL;
                                              BOOL v368 = v359 < v826;
                                              if (v321 <= 0.0) {
                                                BOOL v368 = v359 > v826;
                                              }
                                              if (v368)
                                              {
                                                LODWORD(v812) = 1;
                                                *(double *)v351.i64 = v359;
                                                int8x16_t v811 = v351;
                                                double v826 = v359;
                                                if (!v362) {
                                                  break;
                                                }
                                              }
                                              else
                                              {
LABEL_583:
                                                if (!v362) {
                                                  break;
                                                }
                                              }
LABEL_584:
                                              unint64_t v369 = *(unsigned int *)(v352 + 12);
                                              uint64_t v370 = 256;
                                              if ((v369 & 0x1000) == 0) {
                                                uint64_t v370 = 512;
                                              }
                                              v325 |= v370 | (v369 >> 3) & 0x400;
LABEL_597:
                                              if (++v349 < (unint64_t)*(unsigned int *)(v348 + 16)) {
                                                continue;
                                              }
                                              v323.i64[0] = v810.i64[0];
                                              *(void *)v869 = v811.i64[0];
                                              float64x2_t v6 = v833;
                                              float v327 = *(float *)&v806;
                                              if (v812)
                                              {
                                                uint64_t v32 = v831;
                                                uint64_t v8 = v832;
                                                uint64_t v310 = *(void *)&v822.f64[0];
                                                if (v805)
                                                {
                                                  CA::Render::Timing::inverse_map_time((uint64_t)v807, (double *)v869, v317);
                                                  v323.i64[0] = v810.i64[0];
                                                  float v327 = *(float *)&v806;
                                                  double v826 = *(double *)v869;
                                                }
                                                BOOL v372 = v327 < 0.0;
                                                if (v826 <= *(double *)v323.i64) {
                                                  BOOL v372 = 0;
                                                }
                                                if (v327 > 0.0) {
                                                  BOOL v372 = v826 < *(double *)v323.i64;
                                                }
                                                if (v372) {
                                                  *(double *)v323.i64 = v826;
                                                }
                                              }
                                              else
                                              {
                                                uint64_t v32 = v831;
                                                uint64_t v8 = v832;
                                                uint64_t v310 = *(void *)&v822.f64[0];
                                              }
LABEL_612:
                                              double v373 = *(double *)(v32 + 32);
                                              BOOL v374 = v327 < 0.0;
                                              if (*(double *)v323.i64 <= v373) {
                                                BOOL v374 = 0;
                                              }
                                              if (v327 > 0.0) {
                                                BOOL v374 = *(double *)v323.i64 < v373;
                                              }
                                              if (v374)
                                              {
                                                uint64_t v375 = *(void *)(v32 + 48) | 2;
                                                BOOL v376 = v373 == *(double *)v323.i64 || *(double *)v323.i64 == 0.0;
                                                uint64_t v377 = *(void *)(v32 + 40) | 2;
                                                if (!v376) {
                                                  uint64_t v377 = 2;
                                                }
                                                *(void *)(v32 + 40) = v377;
                                                *(void *)(v32 + 48) = v375;
                                                *(void *)(v32 + 32) = v323.i64[0];
                                              }
                                              uint64_t v336 = v849.i64[1] | v325;
                                              float64x2_t v7 = v828;
LABEL_624:
                                              __int16 v378 = v857;
                                              v849.i64[1] = v336 | ((unint64_t)(v857 & 7) << 53);
                                              if (v823)
                                              {
                                                float64x2_t v853 = vmulq_f64(v853, v837);
                                                uint64_t v379 = *((void *)v6 + 7);
                                                if (v379)
                                                {
                                                  if ((*(unsigned char *)(v310 + 13) & 9) != 0
                                                    && !CA::Mat4Impl::mat4_is_2d_affine(*((CA::Mat4Impl **)v6 + 7), v149)|| *(double *)(v379 + 24) != 0.0|| *(double *)(v379 + 56) != 0.0)
                                                  {
                                                    __int16 v857 = v378 & 0xFDFF;
                                                  }
                                                }
                                              }
                                              unsigned int v380 = (CA::Render::LayerNodeAllocator *)v834;
                                              if (LODWORD(v821.f64[0])
                                                && atomic_fetch_add((atomic_uint *volatile)(v834 + 8), 0xFFFFFFFF) == 1)
                                              {
                                                unsigned int v380 = (CA::Render::LayerNodeAllocator *)(*(uint64_t (**)(CA::Render::LayerNodeAllocator *))(*(void *)v380 + 16))(v380);
                                              }
                                              uint64_t v381 = *((void *)v6 + 4);
                                              if (*(unsigned char *)(v381 + 41))
                                              {
                                                *((_DWORD *)v6 + 29) = 0;
                                              }
                                              else
                                              {
                                                uint64_t v382 = *(unsigned __int8 *)(v381 + 32);
                                                unsigned int v383 = v382 | (v382 << 8) | ((v382 | (v382 << 8)) << 16);
                                                *((_DWORD *)v6 + 29) = v383;
                                                uint64_t v384 = *(void *)(v32 + 96);
                                                if (v384)
                                                {
                                                  unint64_t v385 = (*(unsigned int *)(v384 + 196) | ((unint64_t)*(unsigned int *)(v384 + 196) << 24)) & 0xFF00FF00FF00FFLL;
                                                  unsigned int v383 = ((((v385 + v385 * v382) >> 8) & 0xFF00FF00FF00FFLL) >> 24) | ((v385 + v385 * v382) >> 8) & 0xFF00FF;
                                                  *((_DWORD *)v6 + 29) = v383;
                                                }
                                                uint64_t v386 = *((void *)v6 + 11);
                                                if (v386 && (*(unsigned char *)(*(void *)(v386 + 32) + 13) & 9) != 0)
                                                {
                                                  unsigned int v387 = *(_DWORD *)(v386 + 116);
                                                  if (v383 == -1)
                                                  {
                                                    unsigned int v383 = v387;
                                                  }
                                                  else if (v387 != -1)
                                                  {
                                                    int8x8_t v388 = vand_s8((int8x8_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)vdup_n_s32(v383 >> 8), (int8x8_t)0xFF0000FF00), vadd_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v387), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL), (int32x2_t)0x100000001)), (int8x8_t)0x1FF0001FF0000);
                                                    unsigned int v383 = (((v383 >> 8) & 0xFF0000)
                                                          + ((v383 >> 8) & 0xFF0000) * HIBYTE(v387)) & 0xFF000000 | ((v383 * v387 + v383) >> 8) | v388.i32[0] | v388.i32[1];
                                                  }
                                                  *((_DWORD *)v6 + 29) = v383;
                                                }
                                              }
                                              uint64_t v389 = (CA::Render::LayerNode *)*((void *)v6 + 15);
                                              if (v389 && *((void *)v389 + 5))
                                              {
                                                uint64_t v390 = (void *)*((void *)v6 + 17);
                                                if (!v390)
                                                {
                                                  uint64_t v390 = CA::Render::LayerNodeAllocator::alloc_node(v380);
                                                  *((void *)v6 + 17) = v390;
                                                }
                                                v390[11] = *((void *)v6 + 11);
                                                ++*(_DWORD *)(v32 + 132);
                                                memset(v869, 0, 32);
                                                *(_DWORD *)&v869[32] = 1065353216;
                                                std::vector<std::unordered_map<void *,CA::Render::LayerNode *>>::push_back[abi:nn180100]((uint64_t *)(v8 + 800), (uint64_t *)v869);
                                                std::__hash_table<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CA::Render::PerModeInfo>>>::~__hash_table((uint64_t)v869);
                                                CA::Render::Updater::prepare_layer0(v7, v390, *(void *)(*((void *)v6 + 15) + 40), v32, v849.i8[0] & 8);
                                                CA::Render::Update::pop_dependence_group((CA::Render::Update *)v8, v391);
                                                --*(_DWORD *)(v32 + 132);
                                                v390[11] = *((void *)v6 + 11);
                                              }
                                              else
                                              {
                                                uint64_t v392 = *((void *)v6 + 17);
                                                if (v392)
                                                {
                                                  *(void *)(v392 + 88) = 0;
                                                  if (atomic_fetch_add((atomic_uint *volatile)(v392 + 16), 0xFFFFFFFF) == 1) {
                                                    CA::Render::LayerNode::delete_node((CA::Render::LayerNode *)v392, v389);
                                                  }
                                                  *((void *)v6 + 17) = 0;
                                                  uint64_t v389 = (CA::Render::LayerNode *)*((void *)v6 + 15);
                                                }
                                                if (v389)
                                                {
                                                  CA::Render::Update::release_object((uint64_t *)v8, v389);
                                                  *((void *)v6 + 15) = 0;
                                                }
                                              }
                                              v393 = *(unsigned char ***)(v310 + 128);
                                              if (v393)
                                              {
                                                int v394 = *v393;
                                                if (*v393)
                                                {
                                                  memset(v869, 0, 24);
                                                  (*(void (**)(unsigned char *__return_ptr, unsigned char *, uint64_t, CA::Render::LayerNode *, double, double))(*(void *)v394 + 152))(v869, v394, v8, v6, v842, v847);
                                                  if ((*(void *)v869 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
                                                    || v847 == 0.0)
                                                  {
                                                    goto LABEL_682;
                                                  }
                                                  v849.i64[1] |= 0x704uLL;
                                                  double v395 = *(double *)(v8 + 72);
                                                  if (vabdd_f64(*(double *)v869, v395) <= 0.0001)
                                                  {
                                                    BOOL v401 = *(double *)v869 == v395 || v395 == 0.0;
                                                    uint64_t v402 = *(void *)&v869[8];
                                                    if (!v401) {
                                                      uint64_t v402 = 0;
                                                    }
                                                    uint64_t v398 = v402 | *(void *)&v869[16];
                                                    *(void *)&v869[8] = v398;
                                                    *(void *)(v8 + 96) |= *(void *)&v869[16];
                                                    double v403 = *(double *)(v8 + 80);
                                                    if (v403 >= v395)
                                                    {
                                                      if (v395 != 0.0 && v403 > v395) {
                                                        goto LABEL_681;
                                                      }
                                                      goto LABEL_680;
                                                    }
                                                  }
                                                  else
                                                  {
                                                    double v395 = (*(double *)v869 - v842) / v847 + v395;
                                                    BOOL v396 = *(double *)v869 == v395 || v395 == 0.0;
                                                    uint64_t v397 = *(void *)&v869[8];
                                                    if (!v396) {
                                                      uint64_t v397 = 0;
                                                    }
                                                    uint64_t v398 = v397 | *(void *)&v869[16];
                                                    *(void *)&v869[8] = v398;
                                                    *(void *)(v8 + 96) |= *(void *)&v869[16];
                                                    double v399 = *(double *)(v8 + 80);
                                                    if (v399 >= v395)
                                                    {
                                                      if (v395 != 0.0 && v399 > v395)
                                                      {
LABEL_681:
                                                        *(void *)(v8 + 88) = v398;
                                                        *(double *)(v8 + 80) = v395;
                                                        goto LABEL_682;
                                                      }
LABEL_680:
                                                      v398 |= *(void *)(v8 + 88);
                                                      goto LABEL_681;
                                                    }
                                                  }
LABEL_682:
                                                  if (v394[12] == 8) {
                                                    *((_WORD *)v830 + 2) = (*v830 | ((unint64_t)*((unsigned __int16 *)v830 + 2) << 32) | 0x10000000000) >> 32;
                                                  }
                                                }
                                              }
                                              uint64_t v404 = v849.i64[1];
                                              if ((v849.i16[4] & 0x300) != 0) {
                                                v849.i64[0] |= 7uLL;
                                              }
                                              if ((v849.i16[4] & 0x100) != 0) {
                                                v849.i64[0] |= 8uLL;
                                              }
                                              if ((v849.i32[2] & 0x8000400) != 0) {
                                                v849.i64[0] |= 0x10uLL;
                                              }
                                              if ((v849.i64[1] & 0x100000000000) != 0) {
                                                v849.i64[0] |= 0x100000000000uLL;
                                              }
                                              if ((v849.i16[4] & 0x700) != 0) {
                                                v849.i64[0] |= 0x10000000uLL;
                                              }
                                              int v405 = *(_DWORD *)(v32 + 132);
                                              int v856 = v405;
                                              uint64_t v852 = 0;
                                              uint64_t v406 = *(uint64_t **)(v310 + 128);
                                              if (v406)
                                              {
                                                uint64_t v407 = *v406;
                                                if (*v406)
                                                {
                                                  if (*(unsigned char *)(v407 + 12) == 30)
                                                  {
                                                    v849.i64[1] |= 0x4000000uLL;
                                                    int v408 = *(_DWORD *)(v407 + 12);
                                                    if ((v408 & 0x8000) != 0)
                                                    {
                                                      int v856 = v405 + 1;
                                                      v849.i64[1] = v404 | 0x4000100;
                                                      *(void *)(v841[0] + 24) |= 0x20000000uLL;
                                                      uint64_t v410 = CA::Render::Context::context_by_id((CA::Render::Context *)*(unsigned int *)(v407 + 16));
                                                      if (!v410) {
                                                        goto LABEL_914;
                                                      }
LABEL_703:
                                                      CA::Render::Update::add_included_context((CA::Render::Update *)v8, (os_unfair_lock_s *)v410, 1);
                                                      *(double *)(v410 + 560) = v842;
                                                      if (CA::Render::Update::allowed_in_secure_update((CA::Render::Update *)v8, (CA::Render::Context *)v410, (const CA::Render::LayerHost *)v407)&& ((CA::Render::Update::allowed_to_include_context(v8, v410) & 1) != 0|| CA_CFDictionaryGetBool(*(const __CFDictionary **)(v410 + 32), @"allowsRecursiveScreenCapture")))
                                                      {
                                                        int v411 = (atomic_uint *)v851;
                                                        unint64_t v851 = v410;
                                                        if (*(float *)(v410 + 308) > 1.0) {
                                                          v849.i64[1] |= 0x800uLL;
                                                        }
                                                      }
                                                      else
                                                      {
                                                        int v411 = (atomic_uint *)v410;
                                                      }
                                                    }
                                                    else
                                                    {
                                                      if ((v408 & 0x400) == 0
                                                        || (uint64_t v409 = *(void *)(v407 + 32)) != 0
                                                        && !*(unsigned char *)(v409 + 20)
                                                        || (*v830 & 4) != 0)
                                                      {
                                                        CA::Render::LayerHost::retain_hosted_context((CA::Render::LayerHost *)v869, (CA::Render::Context *)v407, v7[3], (*((void *)v6 + 3) >> 26) & 1);
                                                        uint64_t v410 = *(void *)v869;
                                                        if (*(void *)v869) {
                                                          goto LABEL_703;
                                                        }
                                                      }
LABEL_914:
                                                      int v411 = 0;
                                                    }
                                                    if (*(unsigned char *)(v407 + 13)) {
                                                      *((void *)v6 + 3) |= 0x800000uLL;
                                                    }
                                                    if (v411 && atomic_fetch_add(v411 + 2, 0xFFFFFFFF) == 1) {
                                                      (*(void (**)(atomic_uint *))(*(void *)v411 + 16))(v411);
                                                    }
                                                  }
                                                }
                                              }
                                              double v844 = INFINITY;
                                              uint64_t v845 = 0;
                                              uint64_t v846 = 0;
                                              if (v842 < 0.0) {
                                                *((void *)v6 + 11) = 0;
                                              }
                                              BOOL v536 = CA::Render::Update::allowed_in_update((CA::Render::Update *)v8, (CA::Render::Context *)v7[3], (const CA::Render::Layer *)v310);
                                              uint64_t v540 = v825;
                                              if (!v536) {
                                                *((void *)v6 + 11) = 0;
                                              }
                                              if (!byte_1EB2ACC20
                                                && (*v830 & 4) == 0
                                                && CA::Render::Updater::layer_may_be_hidden_culled(v310))
                                              {
                                                uint64_t v629 = v849.i64[0];
                                                if ((v849.i64[0] & 0x160000000000) == 0)
                                                {
                                                  *((void *)v6 + 11) = 0;
                                                  v849.i64[0] = v629 & 0xFFFFF9FFFFFFFFD9;
                                                  v849.i64[1] = 0x200000000000;
                                                }
                                              }
                                              uint64_t v541 = *(void *)(v8 + 344);
                                              if (v541
                                                && ((*(uint64_t (**)(uint64_t, void, CA::Render::LayerNode *, uint64_t))(*(void *)v541 + 16))(v541, v7[3], v6, v310) & 1) == 0&& (*v830 & 4) != 0)
                                              {
                                                *((void *)v6 + 11) = 0;
                                              }
                                              unint64_t v542 = v849.i64[0];
                                              if (v824)
                                              {
                                                unint64_t v542 = v849.i64[0] & 0xFFFFFFFFFFFFFFEFLL;
                                                *(_OWORD *)&v849 &= __PAIR128__(-17, -17);
                                              }
                                              if (*((void *)v6 + 11) != *(void *)v32) {
                                                goto LABEL_1090;
                                              }
                                              uint64_t v834 = v542;
                                              uint64_t v543 = *((void *)v6 + 12);
                                              v544 = (void *)*((void *)v6 + 13);
                                              v545 = (void *)((char *)v6 + 96);
                                              *(void *)&v869[8] = v544;
                                              *(void *)v869 = v543;
                                              void *v544 = v869;
                                              *(void *)(*v545 + 8) = v869;
                                              void *v545 = v545;
                                              v545[1] = v545;
                                              v546 = *(atomic_uint **)&v869[8];
                                              while (v546 != (atomic_uint *)v869)
                                              {
                                                v547 = v546;
                                                v546 = (atomic_uint *)*((void *)v546 + 1);
                                                if (v547[4] < 2)
                                                {
                                                  uint64_t v548 = *(void *)v547;
                                                  *(void *)(v548 + 8) = v546;
                                                  *(void *)v546 = v548;
                                                  *(void *)v547 = v547;
                                                  *((void *)v547 + 1) = v547;
                                                  *((void *)v547 + 11) = 0;
                                                  if (atomic_fetch_add(v547 + 4, 0xFFFFFFFF) == 1) {
                                                    CA::Render::LayerNode::delete_node((CA::Render::LayerNode *)v547, v537);
                                                  }
                                                }
                                                else
                                                {
                                                  *((void *)v547 + 3) |= 0x800uLL;
                                                }
                                              }
                                              unint64_t v549 = v851;
                                              if (v851)
                                              {
                                                if (BYTE9(xmmword_1EB2ACC10))
                                                {
                                                  if (!atomic_load((unsigned int *)(v851 + 228)))
                                                  {
                                                    if (*(_DWORD *)(v851 + 252)) {
                                                      pid_t v631 = 0;
                                                    }
                                                    else {
                                                      pid_t v631 = getpid();
                                                    }
                                                    int v766 = 0;
                                                    atomic_compare_exchange_strong((atomic_uint *volatile)(v549 + 228), (unsigned int *)&v766, v631);
                                                    uint64_t v8 = v832;
                                                    long long v305 = (CA::Render *)v829;
                                                    uint64_t v310 = *(void *)&v822.f64[0];
                                                  }
                                                  kdebug_trace();
                                                  unint64_t v549 = v851;
                                                }
                                                pthread_mutex_lock((pthread_mutex_t *)(v549 + 72));
                                                v550 = *(CA::Shape **)(v851 + 568);
                                                if (v550)
                                                {
                                                  CA::Shape::unref(v550);
                                                  *(void *)(v851 + 568) = 0;
                                                }
                                              }
                                              if (v305 && (*((void *)v305 + 7) || *((void *)v305 + 8))) {
                                                v849.i64[1] |= 0x20000000000uLL;
                                              }
                                              uint64_t v551 = *(void *)(v310 + 144);
                                              if (v551)
                                              {
                                                unint64_t v552 = *(void *)(v551 + 56);
                                                if (v552)
                                                {
                                                  while (1)
                                                  {
                                                    uint64_t v553 = *(void *)(v8 + 808);
                                                    v554 = (void *)(v553 - 40);
                                                    if (!std::__hash_table<std::__hash_value_type<CA::Render::Object *,x_link_struct>,std::__unordered_map_hasher<CA::Render::Object *,std::__hash_value_type<CA::Render::Object *,x_link_struct>,std::hash<CA::Render::Object *>,std::equal_to<CA::Render::Object *>,true>,std::__unordered_map_equal<CA::Render::Object *,std::__hash_value_type<CA::Render::Object *,x_link_struct>,std::equal_to<CA::Render::Object *>,std::hash<CA::Render::Object *>,true>,std::allocator<std::__hash_value_type<CA::Render::Object *,x_link_struct>>>::find<CA::Render::Object *>((void *)(v553 - 40), v552))break; {
LABEL_1027:
                                                    }
                                                    unint64_t v552 = *(void *)(v552 + 32);
                                                    if (!v552) {
                                                      goto LABEL_1038;
                                                    }
                                                  }
                                                  if (v833) {
                                                    atomic_fetch_add((atomic_uint *volatile)v833 + 4, 1u);
                                                  }
                                                  unint64_t v555 = 0x9DDFEA08EB382D69
                                                       * (((8 * v552) + 8) ^ HIDWORD(v552));
                                                  unint64_t v556 = 0x9DDFEA08EB382D69 * (HIDWORD(v552) ^ (v555 >> 47) ^ v555);
                                                  unint64_t v557 = 0x9DDFEA08EB382D69 * (v556 ^ (v556 >> 47));
                                                  unint64_t v558 = *(void *)(v553 - 32);
                                                  if (v558)
                                                  {
                                                    uint8x8_t v559 = (uint8x8_t)vcnt_s8((int8x8_t)v558);
                                                    v559.i16[0] = vaddlv_u8(v559);
                                                    if (v559.u32[0] > 1uLL)
                                                    {
                                                      unint64_t v560 = 0x9DDFEA08EB382D69 * (v556 ^ (v556 >> 47));
                                                      if (v557 >= v558) {
                                                        unint64_t v560 = v557 % v558;
                                                      }
                                                    }
                                                    else
                                                    {
                                                      unint64_t v560 = v557 & (v558 - 1);
                                                    }
                                                    v561 = *(void **)(*v554 + 8 * v560);
                                                    if (v561)
                                                    {
                                                      v562 = (void *)*v561;
                                                      if (v562)
                                                      {
                                                        uint64_t v8 = v832;
                                                        do
                                                        {
                                                          unint64_t v563 = v562[1];
                                                          if (v563 == v557)
                                                          {
                                                            if (v562[2] == v552) {
                                                              goto LABEL_1027;
                                                            }
                                                          }
                                                          else
                                                          {
                                                            if (v559.u32[0] > 1uLL)
                                                            {
                                                              if (v563 >= v558) {
                                                                v563 %= v558;
                                                              }
                                                            }
                                                            else
                                                            {
                                                              v563 &= v558 - 1;
                                                            }
                                                            if (v563 != v560) {
                                                              break;
                                                            }
                                                          }
                                                          v562 = (void *)*v562;
                                                        }
                                                        while (v562);
                                                      }
                                                    }
                                                  }
                                                  else
                                                  {
                                                    unint64_t v560 = 0;
                                                  }
                                                  v564 = operator new(0x20uLL);
                                                  void *v564 = 0;
                                                  v564[1] = v557;
                                                  v565 = v833;
                                                  v564[2] = v552;
                                                  v564[3] = v565;
                                                  v539.n128_f32[0] = (float)(unint64_t)(*(void *)(v553 - 16)
                                                                                             + 1);
                                                  float v566 = *(float *)(v553 - 8);
                                                  if (v558 && (float)(v566 * (float)v558) >= v539.n128_f32[0])
                                                  {
LABEL_1017:
                                                    v582 = (void *)*v554;
                                                    v583 = *(void **)(*v554 + 8 * v560);
                                                    if (v583)
                                                    {
                                                      void *v564 = *v583;
                                                    }
                                                    else
                                                    {
                                                      void *v564 = *(void *)(v553 - 24);
                                                      *(void *)(v553 - 24) = v564;
                                                      v582[v560] = v553 - 24;
                                                      if (!*v564)
                                                      {
LABEL_1026:
                                                        ++*(void *)(v553 - 16);
                                                        uint64_t v8 = v832;
                                                        goto LABEL_1027;
                                                      }
                                                      unint64_t v584 = *(void *)(*v564 + 8);
                                                      if ((v558 & (v558 - 1)) != 0)
                                                      {
                                                        if (v584 >= v558) {
                                                          v584 %= v558;
                                                        }
                                                      }
                                                      else
                                                      {
                                                        v584 &= v558 - 1;
                                                      }
                                                      v583 = (void *)(*v554 + 8 * v584);
                                                    }
                                                    void *v583 = v564;
                                                    goto LABEL_1026;
                                                  }
                                                  BOOL v567 = (v558 & (v558 - 1)) != 0;
                                                  if (v558 < 3) {
                                                    BOOL v567 = 1;
                                                  }
                                                  unint64_t v568 = v567 | (2 * v558);
                                                  unint64_t v569 = vcvtps_u32_f32(v539.n128_f32[0] / v566);
                                                  if (v568 <= v569) {
                                                    int8x8_t prime = (int8x8_t)v569;
                                                  }
                                                  else {
                                                    int8x8_t prime = (int8x8_t)v568;
                                                  }
                                                  if (*(void *)&prime == 1)
                                                  {
                                                    int8x8_t prime = (int8x8_t)2;
                                                  }
                                                  else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
                                                  {
                                                    int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
                                                  }
                                                  unint64_t v558 = *(void *)(v553 - 32);
                                                  if (*(void *)&prime > v558) {
                                                    goto LABEL_983;
                                                  }
                                                  if (*(void *)&prime < v558)
                                                  {
                                                    unint64_t v577 = vcvtps_u32_f32((float)*(unint64_t *)(v553 - 16)/ *(float *)(v553 - 8));
                                                    if (v558 < 3
                                                      || (uint8x8_t v578 = (uint8x8_t)vcnt_s8((int8x8_t)v558),
                                                          v578.i16[0] = vaddlv_u8(v578),
                                                          v578.u32[0] > 1uLL))
                                                    {
                                                      unint64_t v577 = std::__next_prime(v577);
                                                    }
                                                    else
                                                    {
                                                      uint64_t v579 = 1 << -(char)__clz(v577 - 1);
                                                      if (v577 >= 2) {
                                                        unint64_t v577 = v579;
                                                      }
                                                    }
                                                    if (*(void *)&prime <= v577) {
                                                      int8x8_t prime = (int8x8_t)v577;
                                                    }
                                                    if (*(void *)&prime >= v558)
                                                    {
                                                      unint64_t v558 = *(void *)(v553 - 32);
                                                    }
                                                    else
                                                    {
                                                      if (prime)
                                                      {
LABEL_983:
                                                        if (*(void *)&prime >> 61) {
                                                          std::__throw_bad_array_new_length[abi:nn180100]();
                                                        }
                                                        v571 = operator new(8 * *(void *)&prime);
                                                        v572 = (void *)*v554;
                                                        void *v554 = v571;
                                                        if (v572) {
                                                          operator delete(v572);
                                                        }
                                                        uint64_t v573 = 0;
                                                        *(int8x8_t *)(v553 - 32) = prime;
                                                        do
                                                          *(void *)(*v554 + 8 * v573++) = 0;
                                                        while (*(void *)&prime != v573);
                                                        v574 = *(void **)(v553 - 24);
                                                        if (v574)
                                                        {
                                                          unint64_t v575 = v574[1];
                                                          uint8x8_t v576 = (uint8x8_t)vcnt_s8(prime);
                                                          v576.i16[0] = vaddlv_u8(v576);
                                                          if (v576.u32[0] > 1uLL)
                                                          {
                                                            if (v575 >= *(void *)&prime) {
                                                              v575 %= *(void *)&prime;
                                                            }
                                                          }
                                                          else
                                                          {
                                                            v575 &= *(void *)&prime - 1;
                                                          }
                                                          *(void *)(*v554 + 8 * v575) = v553 - 24;
                                                          v580 = (void *)*v574;
                                                          if (*v574)
                                                          {
                                                            do
                                                            {
                                                              unint64_t v581 = v580[1];
                                                              if (v576.u32[0] > 1uLL)
                                                              {
                                                                if (v581 >= *(void *)&prime) {
                                                                  v581 %= *(void *)&prime;
                                                                }
                                                              }
                                                              else
                                                              {
                                                                v581 &= *(void *)&prime - 1;
                                                              }
                                                              if (v581 != v575)
                                                              {
                                                                if (!*(void *)(*v554 + 8 * v581))
                                                                {
                                                                  *(void *)(*v554 + 8 * v581) = v574;
                                                                  goto LABEL_1008;
                                                                }
                                                                void *v574 = *v580;
                                                                void *v580 = **(void **)(*v554 + 8 * v581);
                                                                **(void **)(*v554 + 8 * v581) = v580;
                                                                v580 = v574;
                                                              }
                                                              unint64_t v581 = v575;
LABEL_1008:
                                                              v574 = v580;
                                                              v580 = (void *)*v580;
                                                              unint64_t v575 = v581;
                                                            }
                                                            while (v580);
                                                          }
                                                        }
                                                        unint64_t v558 = (unint64_t)prime;
                                                        goto LABEL_1012;
                                                      }
                                                      v585 = (void *)*v554;
                                                      void *v554 = 0;
                                                      if (v585) {
                                                        operator delete(v585);
                                                      }
                                                      unint64_t v558 = 0;
                                                      *(void *)(v553 - 32) = 0;
                                                    }
                                                  }
LABEL_1012:
                                                  if ((v558 & (v558 - 1)) != 0)
                                                  {
                                                    if (v557 >= v558) {
                                                      unint64_t v560 = v557 % v558;
                                                    }
                                                    else {
                                                      unint64_t v560 = v557;
                                                    }
                                                  }
                                                  else
                                                  {
                                                    unint64_t v560 = (v558 - 1) & v557;
                                                  }
                                                  goto LABEL_1017;
                                                }
                                              }
LABEL_1038:
                                              v586 = *(uint64_t **)(v310 + 128);
                                              float64x2_t v6 = v833;
                                              float64x2_t v7 = v828;
                                              if (v586)
                                              {
                                                uint64_t v538 = *v586;
                                                if (*v586)
                                                {
                                                  if (*(unsigned char *)(v538 + 12) == 40) {
                                                    CA::Render::Updater::prepare_portal(v828, (uint64_t)v841, (uint64_t)v833, v538);
                                                  }
                                                }
                                              }
                                              long long v305 = (CA::Render *)v829;
                                              if ((v824 & 1) == 0)
                                              {
                                                if (!(*(void *)(v310 + 104) | v851))
                                                {
LABEL_1072:
                                                  v599 = *(unsigned char **)&v869[8];
                                                  if (*(unsigned char **)&v869[8] != v869)
                                                  {
                                                    do
                                                    {
                                                      v600 = (unsigned char *)*((void *)v599 + 1);
                                                      *(void *)v599 = v599;
                                                      *((void *)v599 + 1) = v599;
                                                      *((void *)v599 + 3) &= ~0x800uLL;
                                                      *((void *)v599 + 11) = 0;
                                                      if (atomic_fetch_add((atomic_uint *volatile)v599 + 4, 0xFFFFFFFF) == 1) {
                                                        CA::Render::LayerNode::delete_node((CA::Render::LayerNode *)v599, v537);
                                                      }
                                                      v599 = v600;
                                                    }
                                                    while (v600 != v869);
                                                  }
                                                  uint64_t v32 = v831;
                                                  if (*((void *)v6 + 16) || *(void *)(v310 + 112))
                                                  {
                                                    uint64_t v601 = v841[0];
                                                    uint64_t v602 = *(void *)(v841[0] + 128);
                                                    if (v602)
                                                    {
                                                      *(void *)(v602 + 24) |= 0x800uLL;
                                                      *(void *)(v601 + 128) = 0;
                                                    }
                                                    uint64_t v603 = *(void *)(*(void *)(v601 + 32) + 112);
                                                    if (v603)
                                                    {
                                                      LOBYTE(v858.f64[0]) = 0;
                                                      v604 = (atomic_uint *)CA::Render::Updater::layer_node(v603, (CA::Render::LayerNode *)v7, (uint64_t)v841, (char *)&v858);
                                                      *((void *)v604 + 11) = v601;
                                                      CA::Render::Updater::prepare_layer0(v7, v604, v603, v841, v849.i8[0] & 8);
                                                      *((void *)v604 + 11) = v601;
                                                      *(void *)(v601 + 128) = v604;
                                                      if (!LOBYTE(v858.f64[0])) {
                                                        atomic_fetch_add(v604 + 4, 1u);
                                                      }
                                                    }
                                                    long long v305 = (CA::Render *)v829;
                                                    if (v602)
                                                    {
                                                      if ((*(unsigned char *)(v602 + 25) & 8) != 0)
                                                      {
                                                        *(void *)(v602 + 88) = 0;
                                                        if (atomic_fetch_add((atomic_uint *volatile)(v602 + 16), 0xFFFFFFFF) == 1)CA::Render::LayerNode::delete_node((CA::Render::LayerNode *)v602, v537); {
                                                      }
                                                        }
                                                    }
                                                  }
                                                  if (v305) {
                                                    v849.i64[1] |= *((void *)v305 + 12) & 0x1000000000000000;
                                                  }
                                                  uint64_t v540 = v825;
                                                  LOBYTE(v542) = v834;
LABEL_1090:
                                                  v539.n128_f64[0] = v844;
                                                  if (v844 < INFINITY)
                                                  {
                                                    if ((v857 & 0x80) != 0)
                                                    {
                                                      *(_WORD *)(v32 + 136) |= 0x80u;
                                                    }
                                                    else if (v540)
                                                    {
                                                      CA::Render::Timing::inverse_map_time(v540, &v844, *(double *)(v32 + 16));
                                                      v539.n128_f64[0] = v844;
                                                    }
                                                    uint64_t v605 = v845;
                                                    *(void *)(v32 + 48) |= v846;
                                                    double v606 = *(double *)(v32 + 32);
                                                    if (v606 >= v539.n128_f64[0])
                                                    {
                                                      BOOL v607 = v606 <= v539.n128_f64[0] || v539.n128_f64[0] == 0.0;
                                                      uint64_t v608 = *(void *)(v32 + 40);
                                                      if (!v607) {
                                                        uint64_t v608 = 0;
                                                      }
                                                      *(void *)(v32 + 40) = v608 | v605;
                                                      *(void *)(v32 + 32) = v539.n128_u64[0];
                                                    }
                                                  }
                                                  if ((v857 & 0x40) != 0) {
                                                    *((void *)v6 + 3) |= 0x20uLL;
                                                  }
                                                  if (!v827 && (*((unsigned char *)v6 + 24) & 0x20) != 0) {
                                                    CA::Render::LayerNode::depth_sort_sublayers(v6);
                                                  }
                                                  uint64_t v609 = v849.i64[0];
                                                  if ((v849.i8[0] & 8) != 0)
                                                  {
                                                    if (*((void *)v6 + 7))
                                                    {
                                                      unint64_t v611 = *((void *)v6 + 3) | 4;
                                                    }
                                                    else
                                                    {
                                                      v539.n128_u64[0] = *((void *)v6 + 10);
                                                      *((void *)v6 + 30) = v539.n128_u64[0];
                                                      *((void *)v6 + 31) = v539.n128_u64[0];
                                                      unint64_t v611 = *((void *)v6 + 3) & 0xFFFFFFFFFFFFFFF3;
                                                    }
                                                    *((void *)v6 + 3) = v611;
                                                    uint64_t v610 = v849.i64[1];
                                                    if ((v609 & 0x28000) != 0)
                                                    {
                                                      uint64_t v610 = v849.i64[1] & 0xFFFFFFFFFFF97FFFLL | 0x40000;
                                                      v849.i64[1] = v610;
                                                      if ((v609 & 0x8000) != 0)
                                                      {
                                                        v609 |= 3uLL;
                                                        v849.i64[0] = v609;
                                                      }
                                                    }
                                                  }
                                                  else
                                                  {
                                                    uint64_t v610 = v849.i64[1];
                                                    if ((v849.i64[0] & 0x28000) != 0)
                                                    {
                                                      uint64_t v610 = v849.i64[1] | v849.i16[0] & 0x8000;
                                                      v849.i64[1] = v610;
                                                      if (v849.i16[0] < 0 && (v542 & 0x10) != 0)
                                                      {
                                                        v610 |= 0x10000uLL;
                                                        v849.i64[1] = v610;
                                                      }
                                                    }
                                                  }
                                                  if ((v609 & 0x8000) != 0)
                                                  {
                                                    if (v305)
                                                    {
                                                      if ((v610 & 0x8000) != 0)
                                                      {
                                                        uint64_t v615 = *((void *)v305 + 3);
                                                        if (v615)
                                                        {
                                                          uint64_t v616 = v841[0];
                                                          v617 = *(atomic_uint **)(v615 + 384);
                                                          if (v617 != (atomic_uint *)v841[0])
                                                          {
                                                            if (v617 && atomic_fetch_add(v617 + 4, 0xFFFFFFFF) == 1) {
                                                              CA::Render::LayerNode::delete_node((CA::Render::LayerNode *)v617, v537);
                                                            }
                                                            if (v616) {
                                                              atomic_fetch_add((atomic_uint *volatile)(v616 + 16), 1u);
                                                            }
                                                            *(void *)(v615 + 384) = v616;
                                                            uint64_t v610 = v849.i64[1];
                                                            uint64_t v609 = v849.i64[0];
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                  if ((v610 & 0x40000) != 0)
                                                  {
                                                    *(void *)(v831 + 72) |= 0x40000uLL;
                                                    v610 &= 0xFFFFFFFFFFF87FFFLL;
                                                    v609 |= 4uLL;
                                                    v849.i64[1] = v610;
                                                    v849.i64[0] = v609;
                                                  }
                                                  if (v305 && (v609 & 0x10) != 0) {
                                                    *((_DWORD *)v305 + 19) = *((_DWORD *)v7 + 2);
                                                  }
                                                  if ((*((unsigned char *)v6 + 24) & 0x40) != 0) {
                                                    unint64_t v612 = 0xEF1FC9FFF1F8007FLL;
                                                  }
                                                  else {
                                                    unint64_t v612 = 0xEF1FC9FFF1FF807FLL;
                                                  }
                                                  uint64_t v613 = *(void *)(*(void *)&v822.f64[0] + 96);
                                                  if (v613)
                                                  {
                                                    if (*(unsigned char *)(v613 + 12) == 25)
                                                    {
                                                      uint64_t v614 = (*(uint64_t (**)(void, __n128))(*(void *)v613 + 80))(*(void *)(*(void *)&v822.f64[0] + 96), v539);
                                                      if (!v614) {
                                                        uint64_t v614 = *(void *)(v613 + 32);
                                                      }
                                                    }
                                                    else
                                                    {
                                                      uint64_t v614 = *(void *)(*(void *)&v822.f64[0] + 96);
                                                    }
                                                  }
                                                  else
                                                  {
                                                    uint64_t v614 = 0;
                                                  }
                                                  v618 = (atomic_uint *)*((void *)v6 + 6);
                                                  char v30 = v829;
                                                  if (v618 != (atomic_uint *)v614)
                                                  {
                                                    if (v618 && atomic_fetch_add(v618 + 2, 0xFFFFFFFF) == 1) {
                                                      (*(void (**)(atomic_uint *))(*(void *)v618 + 16))(v618);
                                                    }
                                                    if (v614)
                                                    {
                                                      v619 = (atomic_uint *)(v614 + 8);
                                                      if (!atomic_fetch_add((atomic_uint *volatile)(v614 + 8), 1u))
                                                      {
                                                        uint64_t v614 = 0;
                                                        atomic_fetch_add(v619, 0xFFFFFFFF);
                                                      }
                                                    }
                                                    *((void *)v6 + 6) = v614;
                                                  }
                                                  if ((v819 & 0x100000000000) == 0)
                                                  {
                                                    uint64_t v620 = v831;
                                                    *(_OWORD *)(v831 + 16) = v815;
                                                    *(_DWORD *)(v620 + 56) = v814;
                                                    *(void *)(v620 + 80) = v816;
                                                  }
                                                  *(void *)&double v31 = v612 & v609 | v610;
                                                  uint64_t v32 = v831;
                                                  *(_WORD *)(v831 + 136) |= v857 & 0x400;
                                                  unint64_t v621 = v851;
                                                  if (v851
                                                    && atomic_fetch_add((atomic_uint *volatile)(v851 + 8), 0xFFFFFFFF) == 1)
                                                  {
                                                    (*(void (**)(unint64_t))(*(void *)v621 + 16))(v621);
                                                  }
LABEL_1156:
                                                  if (LOBYTE(v31))
                                                  {
                                                    *(void *)&v31 &= ~1uLL;
                                                    *(_WORD *)(v32 + 136) |= 0x400u;
                                                    if (v30)
                                                    {
                                                      if ((*(unsigned char *)(v32 + 64) & 1) == 0) {
                                                        CA::Render::Context::invalidate((CA::Render::Context *)v7[2], v30 + 14, (const CA::Bounds *)v24);
                                                      }
                                                    }
                                                  }
                                                  if ((LODWORD(v31) & 0x10000) != 0) {
                                                    *(_DWORD *)(v8 + 268) |= 0x100u;
                                                  }
                                                  if (v30) {
                                                    *(double *)&v30[12] = v31;
                                                  }
                                                  if (!v827 && (LOBYTE(v31) & 4) == 0) {
                                                    *(void *)&v31 |= (*((void *)v6 + 3) >> 3) & 4;
                                                  }
                                                  uint64_t v622 = *(void *)&v31 | 0x2000;
                                                  if ((LODWORD(v31) & 0x8007F80) == 0) {
                                                    uint64_t v622 = *(void *)&v31;
                                                  }
                                                  if ((v622 & 0x300) != 0) {
                                                    v622 |= 0x4000uLL;
                                                  }
                                                  if ((v622 & 6) != 0) {
                                                    v622 |= 0x20uLL;
                                                  }
                                                  if ((v622 & 0x28000) != 0) {
                                                    uint64_t v623 = (2 * v622) & 0x40000000000 | v622 | 0x20000;
                                                  }
                                                  else {
                                                    uint64_t v623 = (2 * v622) & 0x40000000000 | v622;
                                                  }
                                                  *(void *)(v32 + 72) |= v623 & 0x140004066020;
                                                  if ((v623 & 0x12) != 0) {
                                                    *(void *)(v32 + 64) |= 0x10uLL;
                                                  }
                                                  if (v30)
                                                  {
                                                    if ((v623 & 0x3C) != 0 && !*(_DWORD *)(v32 + 132))
                                                    {
                                                      int32x2_t v624 = v30[7];
                                                      if (v624)
                                                      {
                                                        double v625 = *(double *)(v32 + 16);
                                                        uint64_t v626 = (*(unsigned __int16 *)(v32 + 136) >> 10) & 1;
                                                        do
                                                        {
                                                          (***(void (****)(int32x2_t, uint64_t, int32x2_t *, uint64_t, double))&v624)(v624, v8, v30, v626, v625);
                                                          int32x2_t v624 = *(int32x2_t *)(*(void *)&v624 + 32);
                                                        }
                                                        while (v624);
                                                      }
                                                    }
                                                  }
                                                  return;
                                                }
                                                if (v848 <= 0xC0)
                                                {
                                                  uint64_t v588 = *(void *)(v841[0] + 32);
                                                  if (!v852
                                                    && (v627 = *(uint64_t **)(v588 + 128)) != 0
                                                    && (uint64_t v628 = *v627) != 0
                                                    && *(unsigned char *)(v628 + 12) == 44)
                                                  {
                                                    CA::Render::Updater::prepare_replicator((uint64_t)v7, (uint64_t)v841, v628, (const double *)v538);
                                                  }
                                                  else
                                                  {
                                                    double v24 = *(unsigned int **)(v588 + 104);
                                                    if ((*(unsigned char *)(v588 + 13) & 0x20) != 0)
                                                    {
                                                      if (v24) {
                                                        CA::Render::Updater::prepare_sublayer0(v7, (uint64_t)v841, (uint64_t)v24);
                                                      }
                                                    }
                                                    else if (v24)
                                                    {
                                                      uint64_t v589 = v24[4];
                                                      if (v589)
                                                      {
                                                        v590 = (unsigned int **)(v24 + 6);
                                                        do
                                                        {
                                                          double v24 = *v590;
                                                          if (*v590) {
                                                            CA::Render::Updater::prepare_sublayer0(v7, (uint64_t)v841, (uint64_t)v24);
                                                          }
                                                          ++v590;
                                                          --v589;
                                                        }
                                                        while (v589);
                                                      }
                                                    }
                                                    if (!v851) {
                                                      goto LABEL_1072;
                                                    }
                                                    uint64_t v591 = CA::Render::Context::root_layer_handle((CA::Render::Context *)v851);
                                                    if (v591)
                                                    {
                                                      double v24 = *(unsigned int **)(v591 + 16);
                                                      if (v24)
                                                      {
                                                        uint64_t v592 = *(void *)(v841[0] + 24) & 0x4000000;
                                                        uint64_t v593 = *(void *)(v841[0] + 88);
                                                        if (v593 && (*(unsigned char *)(v593 + 27) & 0x20) != 0) {
                                                          *(void *)(v841[0] + 24) |= 0x4000000uLL;
                                                        }
                                                        uint64_t v594 = v7[3];
                                                        int32x2_t v7[3] = v851;
                                                        CA::Render::Updater::prepare_sublayer0(v7, (uint64_t)v841, (uint64_t)v24);
                                                        *(void *)(v841[0] + 24) = *(void *)(v841[0] + 24) & 0xFFFFFFFFFBFFFFFFLL | v592;
                                                        int32x2_t v7[3] = v594;
                                                      }
                                                    }
                                                    if ((*(_DWORD *)(*v7 + 1084) & 4) == 0)
                                                    {
                                                      v595 = (CA::Shape **)CA::Render::Context::copy_dirty_shape((CA::Render::Context *)v851);
                                                      if (v595)
                                                      {
                                                        v596 = (CA::Shape *)v595;
                                                        CA::Render::Context::invalidate((CA::Render::Context *)v7[2], v595, (const CA::Shape *)v24);
                                                        CA::Shape::unref(v596);
                                                        unint64_t v597 = v851;
                                                        v598 = *(CA::Shape **)(v851 + 576);
                                                        if (v598) {
                                                          CA::Shape::unref(v598);
                                                        }
                                                        *(void *)(v597 + 576) = 1;
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                              if (v851)
                                              {
                                                pthread_mutex_unlock((pthread_mutex_t *)(v851 + 72));
                                                if (BYTE9(xmmword_1EB2ACC10))
                                                {
                                                  unint64_t v641 = v851;
                                                  if (!atomic_load((unsigned int *)(v851 + 228)))
                                                  {
                                                    if (*(_DWORD *)(v851 + 252)) {
                                                      pid_t v643 = 0;
                                                    }
                                                    else {
                                                      pid_t v643 = getpid();
                                                    }
                                                    int v767 = 0;
                                                    atomic_compare_exchange_strong((atomic_uint *volatile)(v641 + 228), (unsigned int *)&v767, v643);
                                                  }
                                                  kdebug_trace();
                                                  uint64_t v8 = v832;
                                                  float64x2_t v6 = v833;
                                                  float64x2_t v7 = v828;
                                                  long long v305 = (CA::Render *)v829;
                                                  uint64_t v310 = *(void *)&v822.f64[0];
                                                }
                                                uint64_t v587 = *(void *)(v8 + 344);
                                                if (v587) {
                                                  (*(void (**)(uint64_t, unint64_t))(*(void *)v587 + 40))(v587, v851);
                                                }
                                              }
                                              goto LABEL_1072;
                                            }
                                            BOOL v371 = v361 > v320;
                                            if (v321 <= 0.0) {
                                              BOOL v371 = v361 < v320;
                                            }
                                            if (v371) {
                                              goto LABEL_584;
                                            }
                                          }
                                          break;
                                        }
                                        if (v355 <= v319)
                                        {
                                          if (v356 <= v319
                                            || ((*(uint64_t (**)(uint64_t))(*(void *)v352 + 104))(v352) & 1) == 0)
                                          {
                                            goto LABEL_597;
                                          }
                                        }
                                        else if (!v354 || (*(_DWORD *)(v354 + 12) & 0x400) == 0)
                                        {
                                          goto LABEL_597;
                                        }
                                        v325 |= 0x1000uLL;
                                        goto LABEL_597;
                                      }
                                      float64x2_t v295 = v822;
                                      float64x2_t v296 = v818;
                                    }
                                  }
                                  else
                                  {
                                    uint64_t v418 = 0;
                                  }
                                }
                                else
                                {
                                  uint64_t v418 = 0;
                                  uint64_t v416 = 0;
                                }
                                v294 &= ~0x80u;
                                *(_DWORD *)&v869[168] = v294;
                                goto LABEL_728;
                              }
                            }
                            char v297 = 8;
LABEL_443:
                            v869[172] = v297;
                            *(_DWORD *)&v869[168] = 2048;
                          }
                          unsigned int v298 = 5;
                          goto LABEL_445;
                        }
                      }
                      else
                      {
LABEL_1385:
                        uint64_t v729 = v849.i64[1] | 0x400;
                        v849.i64[1] |= 0x400uLL;
                        if ((v849.i16[0] & 0x8000) == 0)
                        {
                          uint64_t v724 = v849.i64[0] | 1;
                          goto LABEL_1376;
                        }
                      }
                      v849.i64[1] = v729 | 0x10000;
                      goto LABEL_1392;
                    }
                  }
                  *(void *)(v259 + 320) = *(void *)(v8 + 136);
                  float64x2_t v264 = (void *const *)atomic_load((unint64_t *)(v259 + 8));
                  unint64_t v817 = (unint64_t)v264;
                  if ((v264 & 0x40000) != 0) {
                    double v256 = *(double *)(v8 + 72);
                  }
                  atomic_fetch_or((atomic_uint *volatile)(v259 + 256), 0x80000000);
                  __dmb(0xBu);
                  int v265 = *(_DWORD *)(v259 + 256) & 1;
                  uint64_t v266 = (double *)(v259 + 48 * (*(_DWORD *)(v259 + 256) & 1));
                  double v267 = v266[20];
                  double v268 = v266[21];
                  double v269 = v266[22];
                  double v270 = v269 + (v256 - v267) * v268;
                  if (v266[23] >= v270) {
                    double v271 = v269 + (v256 - v267) * v268;
                  }
                  else {
                    double v271 = v266[23];
                  }
                  uint64_t v272 = *((void *)v266 + 23);
                  double v273 = v266[24];
                  double v274 = v266[25];
                  __dmb(0xBu);
                  *(_DWORD *)(v259 + 256) = v265;
                  if (v271 < 0.0) {
                    double v271 = 0.0;
                  }
                  if ((v272 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000) {
                    double v270 = v271;
                  }
                  if (v274 < v270) {
                    double v270 = v274;
                  }
                  if (v273 <= v270) {
                    double v275 = v270;
                  }
                  else {
                    double v275 = v273;
                  }
                  float v276 = v268 * v257;
                  *(_DWORD *)(v48 + 192) = *(_DWORD *)(v8 + 248);
                  *(double *)(v48 + 128) = v275;
                  *(float *)(v48 + 136) = v276;
                  *(_DWORD *)(v48 + 12) &= 0xFFFA08FF;
                  if (v154 && v275 >= 0.0)
                  {
                    v811.i64[0] = (uint64_t)v258;
                    BOOL v840 = 0;
                    LODWORD(v812) = CAShmemImageQueueCopyImageInfo((uint64_t *)v48, *(unsigned int *)(v48 + 180), v259, v8, (uint64_t)v869, 1, &v840, v836, v275, v276);
                    int v277 = 0;
                    if ((v817 & 0x800) == 0) {
                      int v277 = *(double *)&v869[56] == *(double *)(v48 + 40)
                    }
                          && *(void *)&v869[48] == *(void *)(v48 + 48);
                    v809.i64[0] = v154;
                    int v445 = 16 * v869[116];
                    uint64_t v446 = CA::Render::ImageQueue::resolved_display_attributes((CA::Render::ImageQueue *)v48, (const CA::Render::Update *)v8);
                    uint64_t v448 = *(void *)(v48 + 80);
                    v810.i64[0] = v446;
                    if (v448)
                    {
                      uint64_t v449 = v446;
                      v450 = (CA::CAHDRProcessor *)CA::Render::ImageQueue::hdr_processor((CA::Render::ImageQueue *)v48, v447);
                      v277 &= ~CA::CAHDRProcessor::should_invalidate_tonemapping(v450, *(float *)(v48 + 88), *(float *)(v449 + 20), *(float *)(v48 + 92), *(float *)(v449 + 12));
                    }
                    BOOL v451 = *(unsigned char **)(v48 + 24);
                    v813 = (void **)(v48 + 24);
                    int v452 = v445;
                    if (!v451) {
                      goto LABEL_778;
                    }
                    if (v451[12] == 51)
                    {
                      if ((*(unsigned int (**)(unsigned char *))(*(void *)v451 + 280))(v451))
                      {
                        BOOL v453 = (CA::CAHDRProcessor *)CA::Render::ImageQueue::hdr_processor((CA::Render::ImageQueue *)v48, v447);
                        float v454 = *(float *)(v810.i64[0] + 20);
                        float v455 = *(float *)(v810.i64[0] + 12);
                        if (CA::CAHDRProcessor::should_invalidate_tonemapping(v453, *(float *)(v48 + 100), v454, *(float *)(v48 + 104), v455))
                        {
                          LOBYTE(v277) = 0;
                          int v452 = v445 | 0x400;
                          *(float *)(v48 + 100) = v454;
                          *(float *)(v48 + 104) = v455;
                        }
                      }
                    }
                    uint64_t v456 = (atomic_uint *)*v813;
                    if (*v813)
                    {
                      if (*(void *)(v48 + 80) && ((*(_DWORD *)&v869[20] ^ (v456[3] >> 8)) & 7) != 0) {
                        LOBYTE(v277) = 0;
                      }
                      if (v812)
                      {
                        int v457 = *(_DWORD *)&v869[4];
                        if (*(_DWORD *)&v869[4] == *(_DWORD *)(v48 + 188)) {
                          char v458 = v277;
                        }
                        else {
                          char v458 = 0;
                        }
                        if (v458)
                        {
                          CA::Render::update_texture_flags((uint64_t)v456, v259, *(unsigned int *)&v869[8], *(unsigned int *)&v869[20]);
                          v459 = (void *)v811.i64[0];
LABEL_785:
                          float64_t v467 = v818.f64[0];
                          goto LABEL_1290;
                        }
                        int v805 = 1;
                        goto LABEL_792;
                      }
                      v459 = (void *)v811.i64[0];
                      float64_t v467 = v818.f64[0];
                    }
                    else
                    {
LABEL_778:
                      if (v812)
                      {
                        int v457 = *(_DWORD *)&v869[4];
                        if (*(_DWORD *)&v869[4] == *(_DWORD *)(v48 + 188)) {
                          char v460 = v277;
                        }
                        else {
                          char v460 = 0;
                        }
                        if (v460)
                        {
                          v459 = (void *)v811.i64[0];
                          uint64_t v461 = *(void *)(v48 + 32);
                          if (v461)
                          {
                            uint64_t v462 = (*(uint64_t (**)(void))(**(void **)(v461 + 24) + 80))(*(void *)(v461 + 24));
                            unsigned int v463 = *(_DWORD *)&v869[8];
                            unsigned int v464 = *(_DWORD *)&v869[20];
                            CA::Render::update_texture_flags(v462, v259, *(unsigned int *)&v869[8], *(unsigned int *)&v869[20]);
                            uint64_t v465 = (*(uint64_t (**)(void))(**(void **)(*(void *)(v48 + 32) + 32) + 80))(*(void *)(*(void *)(v48 + 32) + 32));
                            unsigned int v466 = v464;
                            uint64_t v8 = v832;
                            CA::Render::update_texture_flags(v465, v259, v463, v466);
                          }
                          goto LABEL_785;
                        }
                        int v805 = 0;
                        uint64_t v456 = 0;
LABEL_792:
                        unsigned int v468 = *(_DWORD *)(v48 + 12);
                        unsigned int v469 = v468 >> 8;
                        int v470 = v869[8] & 1;
                        if (((v468 >> 8) & 8) != 0 && (v869[8] & 1) == 0) {
                          *(_DWORD *)(v48 + 12) = v468 & 0xFFFFF7FF;
                        }
                        if (v470) {
                          int v471 = 10;
                        }
                        else {
                          int v471 = 2;
                        }
                        LODWORD(v808) = v471 | v452;
                        v807 = v456;
                        if (!v456
                          || (v469 & 8) >> 3 != v470
                          || *((void *)v456 + 2) != *(void *)&v869[12]
                          || ((*(_DWORD *)&v869[20] ^ (v456[3] >> 8)) & 7) != 0)
                        {
                          LODWORD(v808) = v808 | 4;
                        }
                        *(void *)(v48 + 24) = 0;
                        *(void *)(v48 + 40) = *(void *)&v869[56];
                        *(void *)(v48 + 48) = *(void *)&v869[48];
                        *(_DWORD *)(v48 + 188) = v457;
                        unsigned int v472 = *(atomic_uint **)(v48 + 64);
                        v806 = v472;
                        if (v472)
                        {
                          if (atomic_fetch_add(v472 + 2, 0xFFFFFFFF) == 1) {
                            (*(void (**)(atomic_uint *))(*(void *)v472 + 16))(v806);
                          }
                          *(void *)(v48 + 64) = 0;
                        }
                        int v473 = *(atomic_uint **)(v48 + 80);
                        if (v473)
                        {
                          if (atomic_fetch_add(v473 + 2, 0xFFFFFFFF) == 1) {
                            (*(void (**)(atomic_uint *))(*(void *)v473 + 16))(v473);
                          }
                          *(void *)(v48 + 80) = 0;
                        }
                        *(unsigned char *)(v48 + 140) = 0;
                        if (*(_DWORD *)v869 == 4)
                        {
LABEL_814:
                          v804.i32[0] = *(_DWORD *)&v869[8];
                          unsigned int v474 = IOSurfaceLookup(*(IOSurfaceID *)&v869[48]);
                          size_t v475 = v474;
                          if (v474)
                          {
                            int v476 = CA::Render::iosurface_ycbcr_matrix(v474, v447);
                            *(_WORD *)&v869[118] = v476 | ((unsigned __int16)CA::Render::iosurface_chroma_location(v475, v476) << 8);
                          }
                          v809.i64[0] = (uint64_t)v475;
                          uint64_t v477 = *(void *)(v48 + 224);
                          if (!v477)
                          {
LABEL_830:
                            uint64_t v8 = v832;
                            float64x2_t v6 = v833;
                            double v31 = v826;
                            int32x2_t v486 = (__IOSurface *)v809.i64[0];
                            if (v809.i64[0])
                            {
                              v487 = (CA::Render::Surface *)x_mem_alloc0(0x158uLL);
                              if (v487)
                              {
                                uint64_t v479 = v487;
                                CA::Render::Surface::Surface((uint64_t)v487, v486, -1, 62, 0, v869[118], v869[119]);
                                *(void *)(v48 + 224) = x_list_prepend(*(void *)(v48 + 224), (uint64_t)v479);
                                goto LABEL_833;
                              }
                            }
                            goto LABEL_1229;
                          }
                          v478 = (void *)(v48 + 224);
                          while (1)
                          {
                            uint64_t v479 = *(CA::Render::Surface **)v477;
                            if (*(void *)&v869[48] == *(_DWORD *)(*(void *)v477 + 104))
                            {
                              if (*((void *)v479 + 2) == *(void *)&v869[12])
                              {
                                int v480 = CA::Render::Surface::ycbcr_matrix(*(CA::Render::Surface **)v477, v447);
                                unsigned int v482 = *(unsigned __int16 *)&v869[118];
                                if (v480 == v869[118]
                                  && CA::Render::Surface::chroma_location((__IOSurface **)v479, v481) == v482 >> 8)
                                {
                                  unsigned int v483 = *((_DWORD *)v479 + 3);
                                  if ((v470 == 0) != (unsigned __int16)(v483 & 0x1000) >> 12
                                    && ((v804.i8[0] & 8) == 0) != (unsigned __int16)(v483 & 0x800) >> 11
                                    && ((*(_DWORD *)&v869[20] ^ (v483 >> 8)) & 7) == 0)
                                  {
                                    atomic_fetch_add((atomic_uint *volatile)v479 + 9, 1u);
                                    if (v809.i64[0]) {
                                      CFRelease((CFTypeRef)v809.i64[0]);
                                    }
                                    uint64_t v8 = v832;
                                    float64x2_t v6 = v833;
                                    double v31 = v826;
LABEL_833:
                                    float v488 = *(double *)(v8 + 72) + 0.5;
                                    *((float *)v479 + 80) = v488;
                                    unsigned int v489 = (atomic_uint **)v813;
                                    v490 = (atomic_uint *)v479;
LABEL_834:
                                    X::Ref<CA::Render::Texture>::operator=(v489, v490);
                                    goto LABEL_1229;
                                  }
                                }
                              }
                              if (atomic_fetch_add((atomic_uint *volatile)v479 + 2, 0xFFFFFFFF) == 1) {
                                (*(void (**)(CA::Render::Surface *))(*(void *)v479 + 16))(v479);
                              }
                              uint64_t v484 = *(void *)(v477 + 8);
                              uint64_t v485 = (malloc_zone_t *)get_malloc_zone();
                              malloc_zone_free(v485, (void *)v477);
                              void *v478 = v484;
                              uint64_t v477 = v484;
                            }
                            else
                            {
                              v478 = (void *)(v477 + 8);
                              uint64_t v477 = *(void *)(v477 + 8);
                            }
                            if (!v477) {
                              goto LABEL_830;
                            }
                          }
                        }
                        if (*(_DWORD *)v869 != 3)
                        {
                          if (*(_DWORD *)v869 != 2)
                          {
                            v500 = (atomic_uint *)*v813;
                            if (*v813)
                            {
                              if (atomic_fetch_add(v500 + 2, 0xFFFFFFFF) == 1) {
                                (*(void (**)(atomic_uint *))(*(void *)v500 + 16))(v500);
                              }
                              *v813 = 0;
                            }
                            long long v501 = *(atomic_uint **)(v48 + 32);
                            if (v501)
                            {
                              if (atomic_fetch_add(v501 + 2, 0xFFFFFFFF) == 1) {
                                (*(void (**)(atomic_uint *))(*(void *)v501 + 16))(v501);
                              }
                              *(void *)(v48 + 32) = 0;
                            }
                            long long v502 = *(atomic_uint **)(v48 + 64);
                            if (v502)
                            {
                              if (atomic_fetch_add(v502 + 2, 0xFFFFFFFF) == 1) {
                                (*(void (**)(atomic_uint *))(*(void *)v502 + 16))(v502);
                              }
                              *(void *)(v48 + 64) = 0;
                            }
                            long long v503 = *(atomic_uint **)(v48 + 80);
                            if (v503)
                            {
                              if (atomic_fetch_add(v503 + 2, 0xFFFFFFFF) == 1) {
                                (*(void (**)(atomic_uint *))(*(void *)v503 + 16))(v503);
                              }
                              *(void *)(v48 + 80) = 0;
                            }
                            goto LABEL_1229;
                          }
                          goto LABEL_814;
                        }
                        uint64_t v491 = *(void *)&v869[32];
                        uint64_t v492 = *(void *)&v869[48];
                        if (*(void *)&v869[32]
                          && *(void *)&v869[48]
                          && ((v493 = *(double *)&v869[40], double v494 = *(double *)&v869[56], v275 > *(double *)&v869[40])
                            ? (_NF = v275 < *(double *)&v869[56])
                            : (_NF = 0),
                              _NF))
                        {
                          id v496 = CA::Render::ImageQueue::retain_image_queue((CA::Render::ImageQueue *)v48);
                          if (v496)
                          {
                            long long v497 = v496;
                            long long v498 = (atomic_uint *)CAImageQueueCopyTexture((uint64_t)v496, v491);
                            uint64_t v499 = (atomic_uint *)CAImageQueueCopyTexture((uint64_t)v497, v492);
                            CFRelease(v497);
                          }
                          else
                          {
                            uint64_t v632 = CA::Render::Context::lookup_object(*(void *)(v809.i64[0] + 136), *(_DWORD *)(v809.i64[0] + 148), v491, 0, 0, 0);
                            long long v498 = (atomic_uint *)v632;
                            if (v632 && !atomic_fetch_add((atomic_uint *volatile)(v632 + 8), 1u))
                            {
                              long long v498 = 0;
                              atomic_fetch_add((atomic_uint *volatile)(v632 + 8), 0xFFFFFFFF);
                            }
                            uint64_t v633 = CA::Render::Context::lookup_object(*(void *)(v809.i64[0] + 136), *(_DWORD *)(v809.i64[0] + 148), *(uint64_t *)&v869[48], 0, 0, 0);
                            uint64_t v499 = (atomic_uint *)v633;
                            if (v633 && !atomic_fetch_add((atomic_uint *volatile)(v633 + 8), 1u))
                            {
                              uint64_t v499 = 0;
                              atomic_fetch_add((atomic_uint *volatile)(v633 + 8), 0xFFFFFFFF);
                            }
                            float64x2_t v6 = v833;
                            double v31 = v826;
                          }
                          uint64_t v8 = v832;
                          if (v498)
                          {
                            if ((*(uint64_t (**)(atomic_uint *))(*(void *)v498 + 80))(v498)
                              && v499
                              && (*(uint64_t (**)(atomic_uint *))(*(void *)v499 + 80))(v499))
                            {
                              int8x16_t v809 = *(int8x16_t *)(v823 + 424);
                              v868[0] = v809;
                              int8x16_t v804 = *(int8x16_t *)(v823 + 440);
                              v868[1] = v804;
                              if (initialized != -1) {
                                dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
                              }
                              unsigned int v635 = *(float *)&dword_1EB2ACAD0;
                              if (*(float *)&dword_1EB2ACAD0)
                              {
                                *(double *)v634.i64 = (double)HIBYTE(v635) * 0.00392156863;
                                int8x8_t v636 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v635), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
                                v637.i64[0] = v636.u32[0];
                                v637.i64[1] = v636.u32[1];
                                int8x16_t v638 = (int8x16_t)vmulq_f64(vcvtq_f64_u64(v637), (float64x2_t)vdupq_n_s64(0x3F70101010101010uLL));
                                *(int8x16_t *)((char *)v868 + 8) = v638;
                                double v639 = (double)*(float *)&dword_1EB2ACAD0 * 0.00392156863;
                                int8x16_t v809 = v634;
                                *(double *)v868 = *(double *)v634.i64;
                                *((double *)&v868[1] + 1) = v639;
                              }
                              else
                              {
                                double v639 = *(double *)&v804.i64[1];
                                int8x16_t v638 = vextq_s8(v809, v804, 8uLL);
                              }
                              double v644 = (v275 - v493) / (v494 - v493);
                              if (*(double *)v809.i64 != 0.0
                                || *(double *)v638.i64 != 0.0
                                || *(double *)&v638.i64[1] != 1.0
                                || v639 != 1.0)
                              {
                                double v644 = CA::Render::TimingFunction::evaluate((CA::Render::TimingFunction *)v868, (const double *)v447, v644, 0.00001);
                              }
                              *(void *)&long long v865 = 0;
                              long long v863 = 0u;
                              long long v864 = 0u;
                              float64x2_t v861 = 0u;
                              long long v862 = 0u;
                              float64x2_t v859 = 0u;
                              float64x2_t v860 = 0u;
                              float64x2_t v858 = (float64x2_t)*(unint64_t *)&v644;
                              *(void *)&v835[0] = 0;
                              (*(void (**)(_OWORD *__return_ptr, atomic_uint *, atomic_uint *, float64x2_t *))(*(void *)v498 + 56))(v835, v498, v499, &v858);
                              X::Ref<CA::Render::Texture>::operator=((atomic_uint **)(v48 + 32), *(atomic_uint **)&v835[0]);
                              uint64_t v645 = *(void *)&v835[0];
                              if (*(void *)&v835[0]
                                && atomic_fetch_add((atomic_uint *volatile)(*(void *)&v835[0] + 8), 0xFFFFFFFF) == 1)
                              {
                                (*(void (**)(uint64_t))(*(void *)v645 + 16))(v645);
                              }
                              uint64_t v8 = v832;
                              float64x2_t v6 = v833;
                              double v31 = v826;
                            }
                            if (atomic_fetch_add(v498 + 2, 0xFFFFFFFF) == 1) {
                              (*(void (**)(atomic_uint *))(*(void *)v498 + 16))(v498);
                            }
                          }
                          if (v499 && atomic_fetch_add(v499 + 2, 0xFFFFFFFF) == 1) {
                            (*(void (**)(atomic_uint *))(*(void *)v499 + 16))(v499);
                          }
                        }
                        else
                        {
                          v508 = *(atomic_uint **)(v48 + 32);
                          if (v508)
                          {
                            if (atomic_fetch_add(v508 + 2, 0xFFFFFFFF) == 1) {
                              (*(void (**)(atomic_uint *))(*(void *)v508 + 16))(v508);
                            }
                            *(void *)(v48 + 32) = 0;
                            uint64_t v492 = *(void *)&v869[48];
                            uint64_t v491 = *(void *)&v869[32];
                          }
                          if ((v817 & 0x800) != 0
                            && v491
                            && v492
                            && vabdd_f64(v275, *(double *)&v869[40]) < vabdd_f64(v275, *(double *)&v869[56]))
                          {
                            uint64_t v492 = v491;
                          }
                          id v509 = CA::Render::ImageQueue::retain_image_queue((CA::Render::ImageQueue *)v48);
                          if (v509)
                          {
                            v510 = v509;
                            uint64_t v511 = CAImageQueueCopyTexture((uint64_t)v509, v492);
                            v512 = (atomic_uint *)*v813;
                            *v813 = (void *)v511;
                            if (v512 && atomic_fetch_add(v512 + 2, 0xFFFFFFFF) == 1) {
                              (*(void (**)(atomic_uint *))(*(void *)v512 + 16))(v512);
                            }
                            CFRelease(v510);
                            uint64_t v8 = v832;
                            float64x2_t v6 = v833;
                            double v31 = v826;
                          }
                          else
                          {
                            uint64_t v640 = CA::Render::Context::lookup_object(*(void *)(v809.i64[0] + 136), *(_DWORD *)(v809.i64[0] + 148), v492, 0, 0, 0);
                            uint64_t v8 = v832;
                            float64x2_t v6 = v833;
                            double v31 = v826;
                            if (v640)
                            {
                              v490 = (atomic_uint *)(*(uint64_t (**)(uint64_t))(*(void *)v640 + 80))(v640);
                              unsigned int v489 = (atomic_uint **)v813;
                              goto LABEL_834;
                            }
                          }
                        }
LABEL_1229:
                        v646 = *v813;
                        if (*v813)
                        {
                          uint64_t v259 = v823;
                          if (*((unsigned char *)v646 + 12) == 51)
                          {
                            CA::Render::Surface::reload_iosurface_needs_film_grain((CA::Render::Surface *)*v813);
                            *((_WORD *)v646 + 168) &= ~0x200u;
                            v647 = (atomic_uint *)*((void *)v646 + 20);
                            *((void *)v646 + 20) = 0;
                            if (v647 && atomic_fetch_add(v647 + 2, 0xFFFFFFFF) == 1) {
                              (*(void (**)(atomic_uint *))(*(void *)v647 + 16))(v647);
                            }
                            *((_WORD *)v646 + 168) &= ~4u;
                            *((_DWORD *)v646 + 33) = 1065353216;
                            v646 = *v813;
                          }
                          CA::Render::update_texture_flags((uint64_t)v646, v259, *(unsigned int *)&v869[8], *(unsigned int *)&v869[20]);
                          int v648 = *(_DWORD *)&v869[128];
                          if (*(int *)&v869[128] <= *(int *)&v869[132]) {
                            int v648 = *(_DWORD *)&v869[132];
                          }
                          if (v648 <= 1073741822)
                          {
                            v649 = (CA::Shape *)CA::Shape::new_shape((unsigned int *)&v869[120]);
                            CA::Render::Texture::set_dirty_shape((CA::Render::Texture *)*v813, v649);
                            CA::Shape::unref(v649);
                          }
                          atomic_fetch_add((atomic_uint *volatile)*v813 + 9, 1u);
                          if (initialized != -1) {
                            dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
                          }
                          if (*(float *)&dword_1EB2ACABC)
                          {
                            if (*((unsigned char *)*v813 + 12) == 51)
                            {
                              v650 = (__IOSurface *)*((void *)*v813 + 14);
                              if (v650)
                              {
                                v651 = CAIOSurfaceWriteToFileWithSuffix(v650, "image-queue");
                                free(v651);
                                if (*(float *)&dword_1EB2ACABC > 0.0) {
                                  *(float *)&dword_1EB2ACABC = *(float *)&dword_1EB2ACABC + -1.0;
                                }
                              }
                            }
                          }
                        }
                        else
                        {
                          uint64_t v652 = *(void *)(v48 + 32);
                          uint64_t v259 = v823;
                          if (v652)
                          {
                            v809.i64[0] = (*(uint64_t (**)(void))(**(void **)(v652 + 24) + 80))(*(void *)(v652 + 24));
                            uint64_t v653 = (*(uint64_t (**)(void))(**(void **)(v652 + 32) + 80))(*(void *)(v652 + 32));
                            unsigned int v654 = *(_DWORD *)&v869[8];
                            unsigned int v655 = *(_DWORD *)&v869[20];
                            uint64_t v656 = v809.i64[0];
                            CA::Render::update_texture_flags(v809.i64[0], v259, *(unsigned int *)&v869[8], *(unsigned int *)&v869[20]);
                            unsigned int v657 = v655;
                            uint64_t v8 = v832;
                            CA::Render::update_texture_flags(v653, v259, v654, v657);
                            atomic_fetch_add((atomic_uint *volatile)(v656 + 36), 1u);
                            atomic_fetch_add((atomic_uint *volatile)(v653 + 36), 1u);
                          }
                        }
                        v658 = *v813;
                        int v659 = v805;
                        char v660 = v805 ^ 1;
                        if (!*v813) {
                          char v660 = 1;
                        }
                        if (v660) {
                          goto LABEL_1265;
                        }
                        if (v658[4] != v807[4]) {
                          goto LABEL_1266;
                        }
                        if (v658[5] != v807[5]) {
                          goto LABEL_1266;
                        }
                        int v661 = *((unsigned __int16 *)v658 + 12);
                        int v662 = *((unsigned __int16 *)v807 + 12);
                        if (v661 != v662) {
                          goto LABEL_1266;
                        }
                        int v663 = *((unsigned __int16 *)v658 + 13);
                        int v664 = *((unsigned __int16 *)v807 + 13);
                        if (v663 != v664) {
                          goto LABEL_1266;
                        }
                        if (*((__int16 *)v807 + 14) + (__int16)v662 != *((__int16 *)v658 + 14) + (__int16)v661) {
                          goto LABEL_1266;
                        }
                        if (*((__int16 *)v807 + 15) + (__int16)v664 != *((__int16 *)v658 + 15) + (__int16)v663) {
                          goto LABEL_1266;
                        }
                        int v665 = *((unsigned __int8 *)v658 + 12);
                        if (v665 != *((unsigned __int8 *)v807 + 12)) {
                          goto LABEL_1266;
                        }
                        if (v665 != 51) {
                          goto LABEL_1265;
                        }
                        int CacheMode = v658[83];
                        if (CacheMode == -1)
                        {
                          int CacheMode = IOSurfaceGetCacheMode();
                          v658[83] = CacheMode;
                        }
                        atomic_uint v667 = v807[83];
                        if (v667 == -1)
                        {
                          uint64_t v668 = (uint64_t)v807;
                          atomic_uint v667 = IOSurfaceGetCacheMode();
                          *(_DWORD *)(v668 + 332) = v667;
                        }
                        uint64_t v8 = v832;
                        float64x2_t v6 = v833;
                        double v31 = v826;
                        int v659 = v805;
                        if (CacheMode == v667 && v658[32] == v807[32])
                        {
LABEL_1265:
                          __int32 v669 = v808;
                          __int32 v670 = v808 | 4;
                        }
                        else
                        {
LABEL_1266:
                          __int32 v670 = v808 | 4;
                          __int32 v669 = v808 | 4;
                        }
                        v671 = v807;
                        if ((v806 != 0) == ((*((unsigned __int16 *)v830 + 2) >> 11) & 1)) {
                          __int32 v670 = v669;
                        }
                        v809.i32[0] = v670;
                        v459 = (void *)v811.i64[0];
                        if (v659)
                        {
                          v672 = *v813;
                          if (!*v813) {
                            goto LABEL_1283;
                          }
                          if (*((unsigned char *)v807 + 12) == 51 && v672[12] == 51)
                          {
                            if (((*((unsigned __int16 *)v672 + 168) >> 5) & 1) != (v807[84] & 0x20) >> 5) {
                              *(_DWORD *)(v48 + 12) |= 0x400u;
                            }
                            uint64_t v673 = CA::Render::ImageQueue::hdr_processor((CA::Render::ImageQueue *)v48, v447);
                            if (v673)
                            {
                              uint64_t v674 = v673;
                              uint64_t v675 = v832;
                              int v676 = (*(uint64_t (**)(uint64_t, unsigned char *, uint64_t))(*(void *)v673 + 48))(v673, v672, v832);
                              if (v676 != (*(unsigned int (**)(uint64_t, atomic_uint *, uint64_t))(*(void *)v674 + 48))(v674, v671, v675))*(_DWORD *)(v48 + 12) |= 0x400u; {
                            }
                              }
                            uint64_t v8 = v832;
                            float64x2_t v6 = v833;
                            double v31 = v826;
                            v459 = (void *)v811.i64[0];
                            if (*(unsigned char *)(v810.i64[0] + 56))
                            {
                              if ((*(unsigned int (**)(unsigned char *))(*(void *)v672 + 264))(v672))
                              {
                                int v677 = (*(uint64_t (**)(unsigned char *))(*(void *)v672 + 256))(v672);
                                if (v677 != (*(unsigned int (**)(atomic_uint *))(*(void *)v671 + 256))(v671)) {
                                  *(_DWORD *)(v48 + 12) |= 0x400u;
                                }
                              }
                            }
                          }
                        }
                        if (*v813)
                        {
LABEL_1285:
                          if (v671)
                          {
                            unsigned int v678 = atomic_fetch_add(v671 + 2, 0xFFFFFFFF);
                            float64_t v467 = v818.f64[0];
                            if (v678 == 1) {
                              (*(void (**)(atomic_uint *))(*(void *)v671 + 16))(v671);
                            }
                          }
                          else
                          {
                            float64_t v467 = v818.f64[0];
                          }
                          int v452 = v809.i32[0];
LABEL_1290:
                          int v679 = v452 | v840;
                          int v680 = v812;
                          if (*(double *)&v869[96] == 0.0) {
                            int v680 = 0;
                          }
                          *(unsigned char *)(v48 + 249) = v680;
                          if (v680 == 1)
                          {
                            *(_OWORD *)(v48 + 256) = *(_OWORD *)&v869[96];
                            *v830 |= 0x400000u;
                            float64x2_t v7 = v828;
                          }
                          else
                          {
                            v681 = (unint64_t *)(*(void *)(*(void *)(v48 + 16) + 24) + 8);
                            unint64_t v682 = atomic_load(v681);
                            float64x2_t v7 = v828;
                            if ((v682 & 0x10000000000000) != 0) {
                              atomic_fetch_and((atomic_ullong *volatile)v681, 0xFFEFFFFFFFFFFFFFLL);
                            }
                          }
                          unint64_t v683 = atomic_load((unint64_t *)(v259 + 8));
                          if ((v683 & 0x200000000000001) == 1)
                          {
                            v679 |= 0x20u;
                            char v684 = atomic_load((unint64_t *)(v259 + 8));
                            if ((v684 & 0x40) == 0) {
                              *(_DWORD *)(v8 + 268) |= 0x2000000u;
                            }
                          }
                          if ((~v817 & 0xC00000000000000) == 0) {
                            *(_DWORD *)(v8 + 268) |= 0x4000000u;
                          }
                          unsigned int v685 = v679 | (v817 >> 47) & 0x100;
                          unsigned int v686 = *(_DWORD *)(v48 + 12);
                          unsigned __int16 v687 = (v686 & 0x20000) == 0;
                          if ((v817 & 0x40000000000000) == 0) {
                            v686 &= ~0x20000u;
                          }
                          if (((v817 >> 54) & v687) != 0) {
                            unsigned int v688 = v685 | 0x600;
                          }
                          else {
                            unsigned int v688 = v685;
                          }
                          unsigned int v689 = v686 & 0xFFF7FFFF;
                          *(_DWORD *)(v48 + 12) = v686 & 0xFFF7FFFF;
                          int v690 = ((unsigned __int16)(v686 >> 9) ^ (unsigned __int16)(v688 >> 1)) & 0x400 | v688;
                          if (v869[117])
                          {
                            if (v268 == 0.0) {
                              double v691 = INFINITY;
                            }
                            else {
                              double v691 = (*(double *)&v869[64] - v269) / v268 + v267;
                            }
                            v837.f64[0] = v691;
                            double v262 = 0.0;
                            if ((*(_DWORD *)&v869[8] & 0x40000800) == 0)
                            {
                              double v692 = *(double *)&v869[72];
                              if ((*(void *)&v869[72] & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
                                && *(double *)&v869[72] > 0.0
                                && *(double *)&v869[72] < 0.1)
                              {
                                if (vabdd_f64(*(double *)&v869[72], *(double *)(v48 + 240)) >= 0.005)
                                {
                                  *(unsigned char *)(v48 + 248) = 4;
                                }
                                else
                                {
                                  double v262 = *(double *)&v869[72];
                                  if (*(unsigned char *)(v48 + 248))
                                  {
                                    char v693 = *(unsigned char *)(v48 + 248) - 1;
                                    *(unsigned char *)(v48 + 248) = v693;
                                    double v262 = 0.0;
                                    if (!v693) {
                                      double v262 = v692;
                                    }
                                  }
                                }
                                *(double *)(v48 + 240) = v692;
                              }
                            }
                            unint64_t v694 = atomic_load((unint64_t *)(v259 + 8));
                            if ((v694 & 0x80000) != 0) {
                              int v695 = 192;
                            }
                            else {
                              int v695 = 64;
                            }
                            v690 |= v695;
                            unsigned int v689 = *(_DWORD *)(v48 + 12);
                          }
                          else
                          {
                            double v262 = 0.0;
                            if (!v690) {
                              goto LABEL_1326;
                            }
                          }
                          *(_DWORD *)(v48 + 12) = v689 | (v690 << 8);
LABEL_1326:
                          double v263 = *(double *)&v869[80];
                          CAShmemImageQueueUpdate(v259, *(_DWORD *)(*(void *)&v467 + 608), *(_DWORD *)(*(void *)&v467 + 612), *(void *)(*(void *)&v467 + 600), v459, *(void *)(v8 + 160), v690, *(unsigned int *)(v48 + 196), v276, *(double *)(v8 + 104));
                          goto LABEL_1327;
                        }
LABEL_1283:
                        if (!*(void *)(v48 + 32)) {
                          CA::Render::ImageQueue::flush_cache((CA::Render::ImageQueue *)v48);
                        }
                        goto LABEL_1285;
                      }
                      v459 = (void *)v811.i64[0];
                      float64_t v467 = v818.f64[0];
                      if (!*(void *)(v48 + 32)) {
                        goto LABEL_1290;
                      }
                    }
                    CA::Render::ImageQueue::flush_cache((CA::Render::ImageQueue *)v48);
                    goto LABEL_1290;
                  }
                  CA::Render::ImageQueue::flush_cache((CA::Render::ImageQueue *)v48);
                }
                double v263 = 0.0;
                goto LABEL_1327;
              }
              v849.i64[1] |= 0x3CuLL;
              uint64_t v46 = v849.i64[0] | 0xA;
            }
            else
            {
              v849.i64[1] |= 0x3CuLL;
              uint64_t v46 = v849.i64[0] | 9;
            }
            v849.i64[0] = v46;
            goto LABEL_75;
          }
        }
        else
        {
          long long v815 = *(_OWORD *)(v32 + 16);
          int v814 = *(_DWORD *)(v32 + 56);
          uint64_t v816 = *(void *)(v32 + 80);
          *(void *)(v32 + 16) = *(void *)(v8 + 72);
          *(void *)(v32 + 24) = *(void *)(v7[2] + 560);
          *(_DWORD *)(v32 + 56) = 1065353216;
          *(void *)(v32 + 80) = 0;
          *(_WORD *)(v32 + 136) |= 0x80u;
          if (v40) {
            goto LABEL_52;
          }
        }
        double v44 = *(double *)(v32 + 16);
        double v45 = *(double *)(v32 + 24);
        double v842 = v44;
        double v843 = v45;
        float v847 = *(float *)(v32 + 56);
        v850 = *(uint64_t **)(v32 + 80);
        goto LABEL_68;
      }
    }
    uint64_t v21 = 60;
    goto LABEL_16;
  }
  if ((*(_DWORD *)(*a1 + 1084) & 4) == 0)
  {
    *(_DWORD *)(a1[3] + 12) |= 0x40000u;
    unint64_t v10 = *((void *)a3 + 15);
    if (v10)
    {
      uint64_t v11 = (int8x8_t *)a1[3];
      char v12 = v11 + 39;
      int8x8_t v13 = v11[40];
      if (v13)
      {
        unint64_t v14 = 0x9DDFEA08EB382D69 * (((8 * v10) + 8) ^ HIDWORD(v10));
        unint64_t v15 = 0x9DDFEA08EB382D69 * (HIDWORD(v10) ^ (v14 >> 47) ^ v14);
        unint64_t v16 = 0x9DDFEA08EB382D69 * (v15 ^ (v15 >> 47));
        uint8x8_t v17 = (uint8x8_t)vcnt_s8(v13);
        v17.i16[0] = vaddlv_u8(v17);
        if (v17.u32[0] > 1uLL)
        {
          unint64_t v18 = v16;
          if (v16 >= *(void *)&v13) {
            unint64_t v18 = v16 % *(void *)&v13;
          }
        }
        else
        {
          unint64_t v18 = v16 & (*(void *)&v13 - 1);
        }
        uint64_t v253 = *(void **)(*(void *)v12 + 8 * v18);
        if (v253)
        {
          for (j = (void *)*v253; j; j = (void *)*j)
          {
            unint64_t v255 = j[1];
            if (v255 == v16)
            {
              if (j[2] == v10) {
                goto LABEL_379;
              }
            }
            else
            {
              if (v17.u32[0] > 1uLL)
              {
                if (v255 >= *(void *)&v13) {
                  v255 %= *(void *)&v13;
                }
              }
              else
              {
                v255 &= *(void *)&v13 - 1;
              }
              if (v255 != v18) {
                break;
              }
            }
          }
        }
      }
      std::__hash_table<CA::Render::String *,std::hash<CA::Render::String *>,std::equal_to<CA::Render::String *>,std::allocator<CA::Render::String *>>::__emplace_unique_key_args<CA::Render::String *,CA::Render::String * const&>((uint64_t)v12, *((void *)a3 + 15), *((void *)a3 + 15));
      if (!atomic_fetch_add((atomic_uint *volatile)(v10 + 8), 1u)) {
        atomic_fetch_add((atomic_uint *volatile)(v10 + 8), 0xFFFFFFFF);
      }
    }
LABEL_379:
    *(_DWORD *)(*v7 + 268) |= 0x200u;
  }
  *((void *)v6 + 11) = 0;
}

BOOL CA::Render::Updater::layer_may_be_hidden_culled(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 41)) {
    return 1;
  }
  if (*(unsigned char *)(a1 + 32)) {
    return 0;
  }
  uint64_t v2 = *(void *)(a1 + 128);
  return !v2
      || (uint64_t v3 = *(void *)(v2 + 88)) == 0
      || CA::Render::Filter::compositing_dod((CA::Render::Filter *)*(unsigned int *)(v3 + 24)) - 3 < 2;
}

uint64_t *CA::Render::Update::release_object(uint64_t *this, const CA::Render::Object *a2)
{
  if (a2)
  {
    uint64_t v3 = this;
    this = (uint64_t *)*this;
    unint64_t v4 = this[2];
    unint64_t v5 = v4 - 16;
    if (v4 >= 0x10)
    {
      float64x2_t v6 = (uint64_t *)this[1];
      this[1] = (uint64_t)(v6 + 2);
      this[2] = v5;
    }
    else
    {
      this = (uint64_t *)x_heap_malloc_small_(this, 0x10uLL);
      float64x2_t v6 = this;
    }
    uint64_t v7 = v3[40];
    uint64_t *v6 = (uint64_t)a2;
    v6[1] = v7;
    v3[40] = (uint64_t)v6;
  }
  return this;
}

int64x2_t CA::Render::BackdropLayer::update@<Q0>(CA::Render::BackdropLayer *this@<X0>, CA::Render::Update *a2@<X1>, CA::Render::LayerNode *a3@<X2>, __n128 a4@<Q0>, __n128 a5@<Q1>, uint64_t a6@<X8>)
{
  v31[1] = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *((void *)this + 11);
  if (v10)
  {
    uint64_t v11 = *((void *)a3 + 3);
    BOOL v12 = (v11 & 0x4000000) != 0 && *((void *)a2 + 132) != 0;
    int v14 = (v11 & 0x8000000) == 0 && v12;
    int v15 = *((_DWORD *)a2 + 271);
    if ((v15 & 4) == 0 && *((unsigned char *)this + 80) == 1)
    {
      unint64_t v16 = *(void **)(v10 + 40);
      uint64_t v17 = v16[2];
      if (*(void *)(v17 + 544)) {
        uint64_t v17 = *(void *)(v17 + 544);
      }
      if (v16[3] != v17)
      {
        unint64_t v18 = (int *)((char *)a2 + 1084);
        CA::Render::BackdropGroup::retain_group(v31, *(void *)(v10 + 16), v16[4], *(unsigned __int8 *)(v10 + 84), *(float *)(v10 + 32));
        uint64_t v19 = v31[0];
        uint64_t v20 = *(atomic_uint **)(v10 + 40);
        *(void *)(v10 + 40) = v31[0];
        if (v20)
        {
          if (atomic_fetch_add(v20 + 2, 0xFFFFFFFF) == 1) {
            (*(void (**)(atomic_uint *))(*(void *)v20 + 16))(v20);
          }
          uint64_t v19 = *(void *)(v10 + 40);
        }
        *(_DWORD *)(v19 + 12) |= 0x400u;
        int v15 = *v18;
      }
    }
    if (v11 & 0x4000000 | v15 & 0x8000004)
    {
      BOOL v21 = (v15 & 4) == 0 && v12;
      uint64_t v22 = *((void *)this + 11);
      if (v21)
      {
        uint64_t v23 = *((void *)a2 + 132);
        os_unfair_lock_lock((os_unfair_lock_t)(v22 + 36));
        double v24 = *(uint64_t **)(v22 + 88);
        if (v24)
        {
          while (v24[2] != *(void *)(v23 + 16) || v24[1] != *(void *)(v23 + 24))
          {
            double v24 = (uint64_t *)*v24;
            if (!v24) {
              goto LABEL_28;
            }
          }
          *((_DWORD *)v24 + 6) = *((_DWORD *)a2 + 62);
          char v30 = (atomic_uint *)(v24[4] + 8);
          if (!atomic_fetch_add(v30, 1u)) {
            atomic_fetch_add(v30, 0xFFFFFFFF);
          }
          int8x8_t v13 = (char *)v24[4];
          os_unfair_lock_unlock((os_unfair_lock_t)(v22 + 36));
        }
        else
        {
LABEL_28:
          __n128 v25 = CA::Render::BackdropState::copy_isolated((CA::Render::BackdropState *)v22, a2, v14);
          v31[0] = v25;
          uint64_t v26 = malloc_type_malloc(0x28uLL, 0x10200400F943929uLL);
          *uint64_t v26 = *(void *)(v22 + 88);
          v26[2] = *(void *)(v23 + 16);
          v26[1] = *(void *)(v23 + 24);
          *((_DWORD *)v26 + 6) = *((_DWORD *)a2 + 62);
          v26[4] = v25;
          *(void *)(v22 + 88) = v26;
          *((_DWORD *)v25 + 3) |= 0x300u;
          if (!atomic_fetch_add((atomic_uint *volatile)v25 + 2, 1u)) {
            atomic_fetch_add((atomic_uint *volatile)v25 + 2, 0xFFFFFFFF);
          }
          os_unfair_lock_unlock((os_unfair_lock_t)(v22 + 36));
          os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::BackdropState::_list_lock);
          X::small_vector_base<CA::Render::BackdropState *>::push_back(v31);
          os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::BackdropState::_list_lock);
          int8x8_t v13 = (char *)v31[0];
        }
      }
      else
      {
        int8x8_t v13 = CA::Render::BackdropState::copy_isolated(*((CA::Render::BackdropState **)this + 11), a2, 0);
      }
    }
    else
    {
      int8x8_t v13 = (char *)*((void *)this + 11);
      if (v13)
      {
        BOOL v27 = (atomic_uint *)(v13 + 8);
        if (!atomic_fetch_add((atomic_uint *volatile)v13 + 2, 1u))
        {
          int8x8_t v13 = 0;
          atomic_fetch_add(v27, 0xFFFFFFFF);
        }
      }
    }
  }
  else
  {
    int8x8_t v13 = 0;
  }
  uint64_t v28 = (atomic_uint *)*((void *)a3 + 32);
  if (v28 == (atomic_uint *)v13)
  {
    if (!v13) {
      goto LABEL_48;
    }
    if (atomic_fetch_add((atomic_uint *volatile)v13 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(char *, __n128, __n128))(*(void *)v13 + 16))(v13, a4, a5);
    }
    goto LABEL_44;
  }
  if (v28 && atomic_fetch_add(v28 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *, __n128, __n128))(*(void *)v28 + 16))(v28, a4, a5);
  }
  *((void *)a3 + 32) = v13;
  if (v13)
  {
LABEL_44:
    if ((*((unsigned char *)this + 13) & 4) != 0 && v13[96] && *((double *)a2 + 9) >= *((double *)v13 + 8)) {
      *((_DWORD *)a2 + 67) |= 0x40000u;
    }
  }
LABEL_48:
  *(void *)a6 = 0x7FF0000000000000;
  int64x2_t result = vdupq_n_s64(0x400000000uLL);
  *(int64x2_t *)(a6 + 8) = result;
  return result;
}

BOOL CA::Render::Animation::check_should_remove(CA::Render::Animation *this, double a2, double a3, float a4)
{
  if ((*((unsigned char *)this + 13) & 8) == 0) {
    return 0;
  }
  BOOL v5 = a2 < a3;
  BOOL v6 = a2 > a3;
  if (a4 >= 0.0) {
    BOOL v6 = 1;
  }
  if (a4 <= 0.0) {
    BOOL v5 = v6;
  }
  return !v5;
}

uint64_t CA::Render::MatchAnimation::is_time_dependent(CA::Render::MatchAnimation *this)
{
  return 0;
}

uint64_t CA::Render::LayerHost::update@<X0>(uint64_t this@<X0>, CA::Render::Update *a2@<X1>, CA::Render::LayerNode *a3@<X2>, double a4@<D0>, double a5@<D1>, void *a6@<X8>)
{
  if ((*((_DWORD *)a2 + 271) & 4) == 0)
  {
    uint64_t v8 = *(void *)(this + 32);
    this = *((void *)a3 + 33);
    if (this != v8)
    {
      if (this && atomic_fetch_add((atomic_uint *volatile)(this + 8), 0xFFFFFFFF) == 1) {
        this = (*(uint64_t (**)(uint64_t, double, double))(*(void *)this + 16))(this, a4, a5);
      }
      if (v8)
      {
        int v9 = (atomic_uint *)(v8 + 8);
        if (!atomic_fetch_add((atomic_uint *volatile)(v8 + 8), 1u))
        {
          uint64_t v8 = 0;
          atomic_fetch_add(v9, 0xFFFFFFFF);
        }
      }
      *((void *)a3 + 33) = v8;
    }
  }
  a6[1] = 0;
  a6[2] = 0;
  *a6 = 0x7FF0000000000000;
  return this;
}

unint64_t CA::Render::Context::copy_dirty_shape(CA::Render::Context *this)
{
  unint64_t v2 = *((void *)this + 72);
  if (v2) {
    return CA::Shape::ref(v2);
  }
  else {
    return CA::Shape::new_shape((unsigned int *)this + 146);
  }
}

void CA::Render::Context::invalidate(CA::Render::Context *this, CA::Shape **a2, const CA::Shape *a3)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    if (a2 == (CA::Shape **)1) {
      return;
    }
  }
  else if (*((_DWORD *)a2 + 1) == 6)
  {
    return;
  }
  if (*((void *)this + 72))
  {
    unint64_t v4 = (uint64_t *)((char *)this + 576);
    CA::shape_union((CA::Shape **)this + 72, a2, a3);
    uint64_t v5 = *v4;
    if ((*v4 & 1) == 0 && *(int *)(v5 + 4) >= 65)
    {
      CA::Shape::get_bounds(v5, (int *)this + 146);
      CA::Shape::unref(*((CA::Shape **)this + 72));
      *((void *)this + 72) = 0;
    }
  }
  else
  {
    int32x2_t v6 = 0;
    int32x2_t v7 = 0;
    CA::Shape::get_bounds((uint64_t)a2, (int *)&v6);
    CA::BoundsImpl::Union((int32x2_t *)this + 73, v6, v7);
  }
}

void CA::Render::LayerSubclass::update(void *a1@<X8>)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = 0x7FF0000000000000;
}

uint64_t CA::Render::Animation::is_time_dependent(CA::Render::Animation *this)
{
  return 1;
}

uint64_t CA::Render::MatchMoveDependence::run(uint64_t this, CA::Render::Update *a2, double a3, Handle *a4)
{
  if (((_BYTE)a4[12] & 8) != 0) {
    *(_DWORD *)(*(void *)(this + 48) + 76) = *((_DWORD *)a2 + 62);
  }
  return this;
}

void CA::Render::PortalState::Dependence::run(CA::Render::PortalState::Dependence *this, CA::Render::Update *a2, double a3, CA::Render::Handle *a4, int a5)
{
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  int v5 = *((_DWORD *)a2 + 62);
  if (*((_DWORD *)this + 14) != v5)
  {
    *((_DWORD *)this + 14) = v5;
    uint64_t v6 = *((void *)this + 6);
    if (a5) {
      *(unsigned char *)(v6 + 212) = 1;
    }
    *(double *)(v6 + 56) = a3;
    int32x2_t v7 = (CA::Render::LayerNode *)*((void *)a4 + 5);
    if (v7 && (*(_DWORD *)(v6 + 12) & 0x200) != 0)
    {
      uint64_t v9 = *((void *)v7 + 4);
      if (v9)
      {
        *(void *)&long long v58 = 0;
        long long v57 = 0u;
        long long v56 = 0u;
        long long v55 = 0u;
        long long v54 = 0u;
        long long v53 = 0u;
        long long v52 = 0u;
        long long v51 = 0u;
        long long v50 = 0u;
        uint64_t v10 = (atomic_uint *)(v9 + 8);
        *(void *)&long long v49 = v6;
        if (!atomic_fetch_add((atomic_uint *volatile)(v9 + 8), 1u))
        {
          uint64_t v9 = 0;
          atomic_fetch_add(v10, 0xFFFFFFFF);
        }
        *((void *)&v49 + 1) = v9;
        *((void *)&v58 + 1) = *((void *)v7 + 3);
        long long v50 = xmmword_184997D50;
        long long v51 = 0uLL;
        long long v52 = xmmword_184997D60;
        long long v53 = 0uLL;
        long long v54 = 0uLL;
        long long v55 = xmmword_184997D50;
        long long v56 = 0uLL;
        long long v57 = xmmword_184997D60;
        v48[0] = &unk_1ED0301F0;
        v48[1] = &v50;
        CA::Render::LayerNode::MapGeometry::map((uint64_t)v48, v7, 0);
        float v12 = 1.0;
        do
        {
          int8x8_t v13 = v7;
          LOBYTE(v11) = *(unsigned char *)(*((void *)v7 + 4) + 32);
          float v11 = (float)LODWORD(v11);
          float v12 = v11 * (float)(0.0039216 * v12);
          int32x2_t v7 = (CA::Render::LayerNode *)*((void *)v7 + 11);
        }
        while (v7);
        uint64_t v14 = *((void *)v13 + 5);
        if (v14) {
          *(void *)(v14 + 96) |= 0x1000000000000000uLL;
        }
        *(float *)&long long v58 = v12;
        os_unfair_lock_lock(&CA::Render::_cross_display_sources_lock);
        unint64_t v16 = CA::Render::_cross_display_sources;
        int v15 = (char *)qword_1E8F84BC8;
        uint64_t v17 = (char *)CA::Render::_cross_display_sources;
        if (CA::Render::_cross_display_sources != (_UNKNOWN *)qword_1E8F84BC8)
        {
          while (*(void *)v17 != v6)
          {
            v17 += 160;
            if (v17 == (char *)qword_1E8F84BC8) {
              goto LABEL_23;
            }
          }
        }
        if (v17 == (char *)qword_1E8F84BC8)
        {
LABEL_23:
          unint64_t v25 = 0xCCCCCCCCCCCCCCCDLL * ((qword_1E8F84BC8 - (uint64_t)CA::Render::_cross_display_sources) >> 5);
          if (qword_1E8F84BD8 < v25 + 1)
          {
            uint64_t v26 = off_1E8F84BD0;
            unint64_t v27 = (qword_1E8F84BD8 + 1) | ((unint64_t)(qword_1E8F84BD8 + 1) >> 1) | (((qword_1E8F84BD8 + 1) | ((unint64_t)(qword_1E8F84BD8 + 1) >> 1)) >> 2);
            unint64_t v28 = v27 | (v27 >> 4) | ((v27 | (v27 >> 4)) >> 8);
            unint64_t v29 = v28 | (v28 >> 16) | ((v28 | (v28 >> 16)) >> 32);
            if (v29 + 1 > v25 + 1) {
              uint64_t v30 = v29 + 1;
            }
            else {
              uint64_t v30 = v25 + 1;
            }
            double v31 = (char *)malloc_type_malloc(160 * v30, 0x1060040ACFB3375uLL);
            uint64_t v32 = v31;
            double v33 = CA::Render::_cross_display_sources;
            uint64_t v34 = qword_1E8F84BC8;
            if (CA::Render::_cross_display_sources != (_UNKNOWN *)qword_1E8F84BC8)
            {
              unsigned int v35 = v31;
              do
              {
                *(_OWORD *)unsigned int v35 = *v33;
                long long v36 = v33[2];
                long long v37 = v33[3];
                long long v38 = v33[4];
                *((_OWORD *)v35 + 1) = v33[1];
                *((_OWORD *)v35 + 2) = v36;
                *((_OWORD *)v35 + 3) = v37;
                *((_OWORD *)v35 + 4) = v38;
                long long v39 = v33[6];
                long long v40 = v33[7];
                long long v41 = v33[8];
                *((_OWORD *)v35 + 5) = v33[5];
                *((_OWORD *)v35 + 6) = v39;
                *((_OWORD *)v35 + 7) = v40;
                *((_OWORD *)v35 + 8) = v41;
                *((_OWORD *)v35 + 9) = v33[9];
                v33 += 10;
                v35 += 160;
              }
              while (v33 != (_OWORD *)v34);
            }
            if (v16 != v26) {
              free(CA::Render::_cross_display_sources);
            }
            int v15 = &v32[160 * v25];
            CA::Render::_cross_display_sources = v32;
            qword_1E8F84BC8 = (uint64_t)v15;
            qword_1E8F84BD8 = v30;
          }
          *(_OWORD *)int v15 = v49;
          long long v42 = v51;
          long long v43 = v52;
          long long v44 = v53;
          *((_OWORD *)v15 + 1) = v50;
          *((_OWORD *)v15 + 2) = v42;
          *((_OWORD *)v15 + 3) = v43;
          *((_OWORD *)v15 + 4) = v44;
          long long v45 = v55;
          long long v46 = v56;
          long long v47 = v57;
          *((_OWORD *)v15 + 5) = v54;
          *((_OWORD *)v15 + 6) = v45;
          *((_OWORD *)v15 + 7) = v46;
          *((_OWORD *)v15 + 8) = v47;
          *((_OWORD *)v15 + 9) = v58;
          qword_1E8F84BC8 += 160;
          os_unfair_lock_unlock(&CA::Render::_cross_display_sources_lock);
        }
        else
        {
          unint64_t v18 = (atomic_uint *)*((void *)v17 + 1);
          *(_OWORD *)uint64_t v17 = v49;
          long long v19 = v51;
          long long v20 = v52;
          long long v21 = v53;
          *((_OWORD *)v17 + 1) = v50;
          *((_OWORD *)v17 + 2) = v19;
          *((_OWORD *)v17 + 3) = v20;
          *((_OWORD *)v17 + 4) = v21;
          long long v22 = v55;
          long long v23 = v56;
          long long v24 = v57;
          *((_OWORD *)v17 + 5) = v54;
          *((_OWORD *)v17 + 6) = v22;
          *((_OWORD *)v17 + 7) = v23;
          *((_OWORD *)v17 + 8) = v24;
          *((_OWORD *)v17 + 9) = v58;
          os_unfair_lock_unlock(&CA::Render::_cross_display_sources_lock);
          if (v18 && atomic_fetch_add(v18 + 2, 0xFFFFFFFF) == 1) {
            (*(void (**)(atomic_uint *))(*(void *)v18 + 16))(v18);
          }
        }
      }
    }
  }
}

BOOL CAShmemImageQueueCopyImageInfo(uint64_t *a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, BOOL *a7, _DWORD *a8, double a9, float a10)
{
  uint64_t v11 = a5;
  uint64_t v179 = a4;
  uint64_t v166 = a1;
  uint64_t v205 = *MEMORY[0x1E4F143B8];
  unint64_t v16 = atomic_load((unint64_t *)(a3 + 8));
  os_signpost_id_t v164 = *(unsigned int *)(a3 + 88);
  if ((v16 & 0x800) != 0) {
    unint64_t v17 = v16 & 0xFFFFFFFFFFFFBFFFLL;
  }
  else {
    unint64_t v17 = v16;
  }
  unint64_t v18 = v17 & 0x180;
  uint64_t v170 = a8;
  uint64_t v169 = a7;
  if (v18 == 384)
  {
    BOOL v181 = (v17 & 0x800) == 0;
    goto LABEL_9;
  }
  if (v18 == 256)
  {
    BOOL v181 = (v17 & 0x800) == 0;
    *(void *)(a5 + 128) = 0;
    *(_OWORD *)(a5 + 96) = 0u;
    *(_OWORD *)(a5 + 112) = 0u;
    *(_OWORD *)(a5 + 64) = 0u;
    *(_OWORD *)(a5 + 80) = 0u;
    *(_OWORD *)(a5 + 32) = 0u;
    *(_OWORD *)(a5 + 48) = 0u;
    *(_OWORD *)a5 = 0u;
    *(_OWORD *)(a5 + 16) = 0u;
    long long v24 = (_DWORD *)(a3 + 16);
    unsigned int v23 = *(_DWORD *)(a3 + 16);
    if (*(_DWORD *)(a3 + 292) != v23)
    {
      int v20 = 0;
      BOOL v19 = 1;
      double v22 = INFINITY;
      double v21 = -INFINITY;
      goto LABEL_24;
    }
    double v25 = *(double *)(a3 + 296);
    BOOL v19 = 1;
    double v22 = INFINITY;
    double v21 = -INFINITY;
    goto LABEL_19;
  }
  if (v18 != 128)
  {
    BOOL v181 = (v17 & 0x800) == 0;
    BOOL v19 = a10 < 0.0;
    if (a10 > 0.0) {
      goto LABEL_13;
    }
    if (a10 < 0.0)
    {
      int v20 = 0;
      BOOL v19 = 1;
      double v22 = INFINITY;
      *(double *)&unint64_t v26 = -INFINITY;
      goto LABEL_14;
    }
LABEL_9:
    BOOL v19 = 0;
    int v20 = 0;
    double v21 = INFINITY;
    double v22 = INFINITY;
    goto LABEL_15;
  }
  BOOL v19 = 0;
  BOOL v181 = (v17 & 0x800) == 0;
LABEL_13:
  int v20 = 1;
  double v22 = -INFINITY;
  *(double *)&unint64_t v26 = INFINITY;
LABEL_14:
  double v21 = *(double *)&v26;
LABEL_15:
  *(void *)(a5 + 128) = 0;
  *(_OWORD *)(a5 + 96) = 0u;
  *(_OWORD *)(a5 + 112) = 0u;
  *(_OWORD *)(a5 + 64) = 0u;
  *(_OWORD *)(a5 + 80) = 0u;
  *(_OWORD *)(a5 + 32) = 0u;
  *(_OWORD *)(a5 + 48) = 0u;
  *(_OWORD *)a5 = 0u;
  *(_OWORD *)(a5 + 16) = 0u;
  long long v24 = (_DWORD *)(a3 + 16);
  unsigned int v23 = *(_DWORD *)(a3 + 16);
  if (*(_DWORD *)(a3 + 292) != v23) {
    goto LABEL_24;
  }
  double v25 = *(double *)(a3 + 296);
  if (!v20)
  {
LABEL_19:
    int v20 = 0;
    if (!v19 || v25 <= a9) {
      goto LABEL_24;
    }
    BOOL v19 = 1;
    goto LABEL_22;
  }
  int v20 = 1;
  if (v25 < a9) {
LABEL_22:
  }
    *(unsigned char *)(a5 + 116) = 1;
LABEL_24:
  unint64_t v27 = atomic_load((unint64_t *)(a3 + 8));
  if ((v27 & 0x1000000000000000) != 0)
  {
    if (!a2) {
      goto LABEL_45;
    }
    unsigned int v28 = 0;
    unint64_t v29 = (unsigned int *)(a3 + 564);
    double v30 = 0.0;
    unint64_t v31 = a2;
    do
    {
      if (*(v29 - 8) && (*(v29 - 10) == 286331153 || *(v29 - 10) == 572662306) && *v29 > v28)
      {
        double v32 = *(double *)(v29 - 21);
        if (v32 < *(double *)(v29 - 25)) {
          double v32 = *(double *)(v29 - 25);
        }
        if (v30 < v32) {
          double v30 = v32;
        }
        unsigned int v28 = *v29;
      }
      v29 += 40;
      --v31;
    }
    while (v31);
    uint64_t v33 = 0;
    uint64_t v34 = 0;
    unsigned int v35 = (_DWORD *)(a3 + 532);
    unsigned int v36 = -1;
    unsigned int v37 = -1;
    do
    {
      if (*v35)
      {
        v34 += (unint64_t)v35[1] >> 31;
        if (v35[8] > v28 && v35[8] < v36)
        {
          unsigned int v37 = v33;
          unsigned int v36 = v35[8];
        }
      }
      ++v33;
      v35 += 40;
    }
    while (a2 != v33);
    if (v37 != -1)
    {
      uint64_t v38 = a3 + 160 * v37;
      if ((*(_DWORD *)(v38 + 536) & 0x80000000) != 0)
      {
        uint64_t v128 = (double *)(v38 + 464);
        unint64_t v129 = (atomic_uint *)(v38 + 536);
        if ((*v129 & 0x4000000) == 0) {
          *uint64_t v128 = *v128 + v30;
        }
        atomic_fetch_and(v129, 0xFBFFFFFF);
        atomic_fetch_and(v129, 0x7FFFFFFFu);
        if (v34 != 1) {
          goto LABEL_46;
        }
        goto LABEL_45;
      }
    }
    if (!v34) {
LABEL_45:
    }
      atomic_fetch_and((atomic_ullong *volatile)(a3 + 8), 0xEFFFFFFFFFFFFFFFLL);
  }
LABEL_46:
  double v39 = 0.0;
  int v175 = v23;
  unint64_t v178 = v17;
  int v177 = v20;
  BOOL v174 = v19;
  if (a2 >= 2)
  {
    unint64_t v40 = 8 * a2;
    if (8 * a2 > 0x1000)
    {
      long long v41 = (double **)malloc_type_malloc(8 * a2, 0x6B28E50uLL);
    }
    else
    {
      MEMORY[0x1F4188790](v17);
      long long v41 = (double **)((char *)&v162 - ((v40 + 15) & 0xFFFFFFFFFFFFFFF0));
      bzero(v41, 8 * a2);
    }
    unint64_t v42 = 0;
    uint64_t v43 = a3 + 464;
    unint64_t v44 = a2;
    do
    {
      if (*(_DWORD *)(v43 + 68) && *(_DWORD *)(v43 + 64) == *v24) {
        v41[v42++] = (double *)v43;
      }
      v43 += 160;
      --v44;
    }
    while (v44);
    double v39 = 0.0;
    if (v42 >= 2)
    {
      std::__introsort<std::_ClassicAlgPolicy,CAShmemImageQueueCopyImageInfo::$_0 &,_CAShmemImageQueueImage **,false>(v41, &v41[v42], 126 - 2 * __clz(v42), 1);
      long long v45 = v41 + 1;
      double v46 = **v41;
      unint64_t v47 = v42 - 1;
      double v39 = INFINITY;
      do
      {
        uint64_t v48 = *v45++;
        double v49 = *v48;
        double v50 = *v48 - v46;
        if (v50 < v39) {
          double v39 = v50;
        }
        double v46 = v49;
        --v47;
      }
      while (v47);
    }
    if (v40 > 0x1000) {
      free(v41);
    }
    unsigned int v23 = v175;
    unint64_t v17 = v178;
    int v20 = v177;
    BOOL v19 = v174;
  }
  int v173 = a6;
  uint64_t v180 = a3;
  uint64_t v202 = 0;
  uint64_t v203 = 0;
  long long v51 = &CA::callback_timer;
  uint64_t v204 = 0;
  unint64_t v52 = 0;
  if (!a2)
  {
    unint64_t v54 = 0;
    LODWORD(v56) = 0;
    uint64_t v55 = 0;
    uint64_t v94 = -1;
    double v62 = v21;
    uint64_t v91 = -1;
    uint64_t v92 = v170;
    int v93 = v169;
    goto LABEL_148;
  }
  uint64_t v53 = 0;
  unint64_t v54 = 0;
  uint64_t v55 = 0;
  uint64_t v56 = 0;
  uint64_t v57 = v179 + 252;
  uint64_t v58 = v179 + 256;
  uint64_t v59 = v20 | v19;
  int8x16_t v60 = (int8x16_t)xmmword_184998040;
  uint64_t v165 = -1;
  int v163 = 835321960;
  uint64_t v61 = v180;
  uint64_t v176 = -1;
  double v62 = v21;
  uint64_t v162 = v23;
  uint64_t v168 = v179 + 252;
  uint64_t v167 = v179 + 256;
  do
  {
    if (!*(_DWORD *)(v61 + 532)) {
      goto LABEL_91;
    }
    int v63 = *(_DWORD *)(v61 + 528);
    if (v52 <= 2)
    {
      uint64_t v64 = &v202 + v52;
      *(_DWORD *)uint64_t v64 = *(_DWORD *)(v61 + 520);
      *((_DWORD *)v64 + 1) = *(_DWORD *)(v61 + 524);
      ++v52;
    }
    if (*((unsigned char *)v51 + 3097))
    {
      uint64_t v87 = v55;
      unint64_t v88 = a2;
      uint64_t v89 = v11;
      uint64_t v90 = v59;
      int8x16_t v172 = v60;
      kdebug_trace();
      int8x16_t v60 = v172;
      uint64_t v59 = v90;
      uint64_t v11 = v89;
      a2 = v88;
      uint64_t v58 = v167;
      uint64_t v57 = v168;
      uint64_t v55 = v87;
      long long v51 = &CA::callback_timer;
      BOOL v19 = v174;
      int v20 = v177;
      unint64_t v17 = v178;
      unsigned int v23 = v175;
    }
    int v65 = v63 - v23;
    int v66 = *(_DWORD *)(v61 + 524);
    if (v66 > 572662305)
    {
      if (v66 == 572662306 || v66 == 858993459)
      {
        unsigned int v77 = *(_DWORD *)(v61 + 560);
        if (v56 <= v77) {
          uint64_t v56 = v77;
        }
        else {
          uint64_t v56 = v56;
        }
        goto LABEL_91;
      }
      goto LABEL_94;
    }
    if (v66)
    {
      if (v66 != 286331153) {
        goto LABEL_94;
      }
      BOOL v67 = (*(_DWORD *)(v61 + 536) & 0x1000000) == 0 && (v17 & 0x20000000000000) == 0;
      double v68 = (_DWORD *)(v67 ? v58 : v57);
      if (*v68 - *(_DWORD *)(v61 + 552) < 0) {
        goto LABEL_94;
      }
      int v69 = 286331153;
      atomic_compare_exchange_strong((atomic_uint *volatile)(v61 + 524), (unsigned int *)&v69, 0);
      if (v69 != 286331153) {
        goto LABEL_92;
      }
    }
    int v70 = v60.i32[2];
    if (v60.i32[2] <= v60.i32[3]) {
      int v70 = v60.i32[3];
    }
    if (v65 < 0)
    {
      if (v70 >= 0x3FFFFFFF)
      {
        uint64_t v79 = *(void *)(v61 + 576);
        int v80 = v79;
        if ((int)v79 <= SHIDWORD(v79)) {
          int v80 = HIDWORD(v79);
        }
        if (v80 <= 1073741822) {
          int8x16_t v60 = *(int8x16_t *)(v61 + 568);
        }
      }
      int v81 = 0;
      atomic_compare_exchange_strong((atomic_uint *volatile)(v61 + 524), (unsigned int *)&v81, 0x33333333u);
      if (!v81)
      {
        uint64_t v56 = *(unsigned int *)(v179 + 248);
        *(_DWORD *)(v61 + 560) = v56;
LABEL_91:
        ++v54;
        goto LABEL_92;
      }
      goto LABEL_92;
    }
    if (v70 <= 1073741822)
    {
      uint64_t v71 = v55;
      unint64_t v171 = v54;
      unint64_t v72 = v52;
      uint64_t v73 = v56;
      unint64_t v74 = a2;
      uint64_t v75 = v11;
      uint64_t v76 = v59;
      int8x16_t v172 = v60;
      CA::BoundsImpl::Union((int32x2_t *)(v61 + 568), *(int32x2_t *)v60.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v60, v60, 8uLL));
      int8x16_t v60 = v172;
      uint64_t v59 = v76;
      uint64_t v11 = v75;
      a2 = v74;
      uint64_t v56 = v73;
      unint64_t v52 = v72;
      unint64_t v54 = v171;
      uint64_t v58 = v167;
      uint64_t v57 = v168;
      uint64_t v55 = v71;
      long long v51 = &CA::callback_timer;
      BOOL v19 = v174;
      int v20 = v177;
      unint64_t v17 = v178;
      unsigned int v23 = v175;
    }
LABEL_94:
    if ((*(_DWORD *)(v61 + 536) & 0x80000000) != 0) {
      goto LABEL_92;
    }
    if ((v65 & 0x80000000) == 0)
    {
      double v78 = *(double *)(v61 + 464);
      if (v20)
      {
        if (v78 > a9)
        {
          if (v63 != v23) {
            goto LABEL_117;
          }
          if (v78 < v62) {
            goto LABEL_116;
          }
          if (v78 <= v62 || v78 >= v21) {
            goto LABEL_117;
          }
          goto LABEL_118;
        }
        if (v78 > v22)
        {
LABEL_120:
          if (v63 == v23)
          {
            char v83 = v59 ^ 1;
            if (v176 == -1) {
              char v83 = 1;
            }
            if ((v83 & 1) == 0)
            {
              uint64_t v84 = v180 + 160 * v176;
              if (!*(_DWORD *)(v84 + 524))
              {
                if (v173)
                {
                  *(_DWORD *)(v84 + 524) = 572662306;
                  uint64_t v56 = *(unsigned int *)(v179 + 248);
                  *(_DWORD *)(v61 + 560) = v56;
                }
              }
            }
            uint64_t v176 = v53;
            double v22 = v78;
          }
          goto LABEL_92;
        }
      }
      else
      {
        if (v78 < a9 && v19)
        {
          if (v63 != v23) {
            goto LABEL_117;
          }
          if (v78 > v62)
          {
LABEL_116:
            double v62 = *(double *)(v61 + 464);
            uint64_t v165 = v53;
            goto LABEL_117;
          }
          if (v78 >= v62 || v78 <= v21) {
LABEL_117:
          }
            double v78 = v21;
LABEL_118:
          ++v55;
          double v21 = v78;
          goto LABEL_92;
        }
        if (v19)
        {
          if (v78 < v22) {
            goto LABEL_120;
          }
        }
        else if (vabdd_f64(v78, a9) < vabdd_f64(v22, a9))
        {
          goto LABEL_120;
        }
      }
    }
    char v85 = v59 ^ 1;
    if (v63 != v23) {
      char v85 = 1;
    }
    if ((v85 & 1) == 0 && !*(_DWORD *)(v61 + 524))
    {
      if (v173)
      {
        int v86 = 0;
        atomic_compare_exchange_strong((atomic_uint *volatile)(v61 + 524), (unsigned int *)&v86, 0x22222222u);
        if (!v86)
        {
          uint64_t v56 = *(unsigned int *)(v179 + 248);
          *(_DWORD *)(v61 + 560) = v56;
        }
      }
    }
LABEL_92:
    ++v53;
    v61 += 160;
  }
  while (a2 != v53);
  uint64_t v91 = v176;
  uint64_t v92 = v170;
  int v93 = v169;
  if (v176 == -1)
  {
    uint64_t v94 = v165;
    if ((v17 & 2) != 0 && v55)
    {
      --v55;
      *(unsigned char *)(v11 + 116) = 1;
      uint64_t v91 = v94;
      double v22 = v62;
    }
  }
  else
  {
    uint64_t v94 = v165;
  }
LABEL_148:
  if ((v17 & 0x4000) != 0 && v91 != -1 && v94 != -1 && a10 != 0.0 && v91 != v94)
  {
    double v95 = *(double *)(v179 + 112) * 0.6;
    double v96 = vabdd_f64(v62, a9);
    if (*(_DWORD *)(v180 + 160 * v91 + 548) && v96 < v95)
    {
      double v21 = v21 - v95;
      --v55;
      uint64_t v91 = v94;
      double v22 = v62;
    }
  }
  if (v93)
  {
    if (v54 > *(unsigned __int8 *)(v180 + 95)) {
      uint64_t v98 = 0;
    }
    else {
      uint64_t v98 = -1;
    }
    BOOL v100 = a10 != 0.0 && v55 != v98;
    *int v93 = v100;
  }
  if (v92) {
    _DWORD *v92 = v56;
  }
  uint64_t v101 = v180;
  int v102 = v173;
  if (v91 == -1) {
    return v91 != -1;
  }
  uint64_t v176 = v91;
  if (v181 || !v19 || v94 == -1)
  {
    double v103 = v62;
    double v62 = v22;
  }
  else
  {
    double v103 = v22;
    uint64_t v104 = v91;
    uint64_t v91 = v94;
    uint64_t v94 = v104;
  }
  uint64_t v105 = v180 + 464 + 160 * v91;
  int v106 = *(_DWORD *)(v105 + 60);
  if (v173)
  {
    update_image_sample(v166, v180, v180 + 464 + 160 * v91, v179, a9);
    int v20 = v177;
    LODWORD(v17) = v178;
  }
  char v107 = v181;
  if (v94 == -1) {
    char v107 = 1;
  }
  if ((v107 & 1) == 0)
  {
    *(void *)(v11 + 32) = *(void *)(v101 + 464 + 160 * v91 + 8);
    *(double *)(v11 + 40) = v62;
    uint64_t v105 = v101 + 464 + 160 * v94;
    update_image_sample(v166, v101, v105, v179, a9);
    int v20 = v177;
    LODWORD(v17) = v178;
  }
  *(void *)(v11 + 80) = *(void *)(v101 + 144);
  if (v106) {
    BOOL v108 = 0;
  }
  else {
    BOOL v108 = *(_DWORD *)(v105 + 60) == 286331153;
  }
  if (BYTE14(xmmword_1EB2ACC50))
  {
    double v161 = *(double *)(v105 + 128);
    if (v161 == 0.0) {
      BOOL v108 = 0;
    }
    if (v108)
    {
      if (*(double *)(v179 + 768) < v161) {
        double v161 = *(double *)(v179 + 768);
      }
      *(double *)(v179 + 768) = v161;
    }
  }
  if (v20)
  {
    if (v103 <= v62) {
      goto LABEL_192;
    }
LABEL_191:
    double v21 = v103;
  }
  else if (v62 > v103)
  {
    goto LABEL_191;
  }
LABEL_192:
  int v109 = 0;
  double v110 = *(double *)(v101 + 304);
  double v111 = *(double *)(v101 + 312);
  if (!byte_1EB2ACC2C)
  {
    unsigned int v112 = v102 & WORD1(v17);
    if (v112)
    {
      if ((v112 & v181) != 0)
      {
        if ((*(void *)&v21 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
          goto LABEL_208;
        }
        if (v111 >= a9) {
          double v113 = a9;
        }
        else {
          double v113 = *(double *)(v101 + 312);
        }
        if (v110 > v113) {
          double v113 = *(double *)(v101 + 304);
        }
        if (v113 != a9) {
          goto LABEL_208;
        }
        if (v111 >= v21) {
          double v114 = v21;
        }
        else {
          double v114 = *(double *)(v101 + 312);
        }
        if (v110 > v114) {
          double v114 = *(double *)(v101 + 304);
        }
        if (v114 == v21) {
          int v109 = 1;
        }
        else {
LABEL_208:
        }
          int v109 = 0;
      }
    }
  }
  *(_DWORD *)uint64_t v11 = *(_DWORD *)(v105 + 68);
  *(_DWORD *)(v11 + 8) = *(_DWORD *)(v105 + 72);
  *(void *)(v11 + 12) = *(void *)(v105 + 76);
  *(_DWORD *)(v11 + 20) = *(unsigned __int8 *)(v105 + 120);
  *(_DWORD *)(v11 + 24) = *(_DWORD *)(v105 + 84);
  *(void *)(v11 + 48) = *(void *)(v105 + 8);
  *(_DWORD *)(v11 + 4) = *(_DWORD *)(v105 + 64);
  if (v181) {
    double v115 = v62;
  }
  else {
    double v115 = v103;
  }
  *(double *)(v11 + 56) = v115;
  *(_OWORD *)(v11 + 120) = *(_OWORD *)(v105 + 104);
  *(double *)(v11 + 64) = v21;
  *(double *)(v11 + 72) = v39;
  *(_OWORD *)(v11 + 96) = *(_OWORD *)(v105 + 136);
  *(_DWORD *)(v11 + 112) = -858993459 * ((unint64_t)(v105 - (v101 + 464)) >> 5);
  *(unsigned char *)(v11 + 117) = v109;
  *(void *)(v11 + 88) = 0;
  if (*(_DWORD *)(v101 + 456) == 1) {
    atomic_fetch_add((atomic_uint *volatile)(v105 + 152), 1u);
  }
  IOSurfaceID v116 = *(_DWORD *)(v105 + 56);
  if (v116)
  {
    IOSurfaceRef v117 = IOSurfaceLookup(v116);
    *(void *)(v11 + 88) = IOSurfaceGetIndexedTimestamp();
    if (v117) {
      CFRelease(v117);
    }
  }
  char v118 = &CA::callback_timer;
  if (BYTE9(xmmword_1EB2ACC10)) {
    int v119 = v109;
  }
  else {
    int v119 = 0;
  }
  if (v119 == 1)
  {
    kdebug_trace();
    char v118 = &CA::callback_timer;
  }
  uint64_t v91 = v176;
  if (v181 || !*(void *)(v11 + 32) || !*(void *)(v11 + 48))
  {
    if (v62 != 0.0)
    {
      int v120 = *(_DWORD *)(v11 + 8);
      if ((v120 & 0x20) == 0)
      {
LABEL_231:
        if (a10 != 0.0 && (v120 & 0x80) == 0)
        {
          *(_DWORD *)(v179 + 268) |= 0x800u;
          if (!v102) {
            return v91 != -1;
          }
          goto LABEL_236;
        }
      }
    }
    if (!v102) {
      return v91 != -1;
    }
    goto LABEL_236;
  }
  if (*(double *)(v11 + 40) != 0.0 && *(double *)(v11 + 56) != 0.0)
  {
    int v120 = *(_DWORD *)(v11 + 8);
    if ((v120 & 0x20) == 0) {
      goto LABEL_231;
    }
  }
  if (v102)
  {
LABEL_236:
    if (*((unsigned char *)v118 + 3097))
    {
      kdebug_trace();
      kdebug_trace();
    }
    if (CADeviceSupportsAPT::once[0] != -1) {
      dispatch_once(CADeviceSupportsAPT::once, &__block_literal_global_52);
    }
    if (CAImageQueueLog(void)::onceToken != -1) {
      dispatch_once(&CAImageQueueLog(void)::onceToken, &__block_literal_global_89);
    }
    uint64_t v121 = CAImageQueueLog(void)::log;
    switch(v52)
    {
      case 0uLL:
        if (v164 && os_signpost_enabled((os_log_t)CAImageQueueLog(void)::log))
        {
          int v122 = *(_DWORD *)(v105 + 56);
          int v123 = *(_DWORD *)(v179 + 248);
          *(_DWORD *)buf = 67240960;
          int v183 = v122;
          __int16 v184 = 2050;
          double v185 = a9;
          __int16 v186 = 1026;
          int v187 = v123;
          __int16 v188 = 1026;
          int v189 = v175;
          double v124 = "ID is queue ID. surfaceID=%{public, name=surfaceID}#x serverSamplingTime=%{public, name=serverSamplingT"
                 "ime}f updateSeed=%{public, name=updateSeed}#x queueGeneration=%{public, name=queueGeneration}u samples=none";
          double v125 = v121;
          os_signpost_id_t v126 = v164;
          uint32_t v127 = 30;
          goto LABEL_363;
        }
        return v91 != -1;
      case 1uLL:
        if (!v164 || !os_signpost_enabled((os_log_t)CAImageQueueLog(void)::log)) {
          return v91 != -1;
        }
        int v130 = *(_DWORD *)(v105 + 56);
        int v131 = *(_DWORD *)(v179 + 248);
        if (SHIDWORD(v202) > 572662305)
        {
          if (HIDWORD(v202) != 572662306)
          {
            int v132 = v175;
            if (HIDWORD(v202) == 858993459)
            {
              int32x2_t v133 = "flushed";
              goto LABEL_297;
            }
LABEL_296:
            int32x2_t v133 = "<unknown>";
            goto LABEL_297;
          }
          int32x2_t v133 = "consumed";
        }
        else
        {
          if (HIDWORD(v202))
          {
            int v132 = v175;
            if (HIDWORD(v202) == 286331153)
            {
              int32x2_t v133 = "displayed";
LABEL_297:
              int v140 = *v133;
              *(_DWORD *)buf = 67241472;
              int v183 = v130;
              __int16 v184 = 2050;
              double v185 = a9;
              __int16 v186 = 1026;
              int v187 = v131;
              __int16 v188 = 1026;
              int v189 = v132;
              __int16 v190 = 1026;
              int v191 = v202;
              __int16 v192 = 1026;
              int v193 = v140;
              double v124 = "ID is queue ID. surfaceID=%{public, name=surfaceID}#x serverSamplingTime=%{public, name=serverSampl"
                     "ingTime}f updateSeed=%{public, name=updateSeed}#x queueGeneration=%{public, name=queueGeneration}u "
                     "samples=[(%{public, name=sample0Surface}#x, %{public, name=sample0State}c)]";
              double v125 = v121;
              os_signpost_id_t v126 = v164;
              uint32_t v127 = 42;
              goto LABEL_363;
            }
            goto LABEL_296;
          }
          int32x2_t v133 = "unconsumed";
        }
        int v132 = v175;
        goto LABEL_297;
      case 2uLL:
        if (!v164 || !os_signpost_enabled((os_log_t)CAImageQueueLog(void)::log)) {
          return v91 != -1;
        }
        if (SHIDWORD(v202) > 572662305)
        {
          if (HIDWORD(v202) != 572662306)
          {
            int v134 = v175;
            if (HIDWORD(v202) == 858993459)
            {
              uint64_t v135 = "flushed";
              goto LABEL_301;
            }
            goto LABEL_300;
          }
          uint64_t v135 = "consumed";
        }
        else
        {
          if (HIDWORD(v202))
          {
            int v134 = v175;
            if (HIDWORD(v202) == 286331153)
            {
              uint64_t v135 = "displayed";
              goto LABEL_301;
            }
LABEL_300:
            uint64_t v135 = "<unknown>";
LABEL_301:
            int v141 = *(_DWORD *)(v105 + 56);
            int v142 = *(_DWORD *)(v179 + 248);
            int v143 = *v135;
            if (SHIDWORD(v203) > 572662305)
            {
              if (HIDWORD(v203) == 572662306)
              {
                int v144 = "consumed";
                goto LABEL_311;
              }
              if (HIDWORD(v203) == 858993459)
              {
                int v144 = "flushed";
                goto LABEL_311;
              }
            }
            else
            {
              if (!HIDWORD(v203))
              {
                int v144 = "unconsumed";
                goto LABEL_311;
              }
              if (HIDWORD(v203) == 286331153)
              {
                int v144 = "displayed";
                goto LABEL_311;
              }
            }
            int v144 = "<unknown>";
LABEL_311:
            int v145 = *v144;
            *(_DWORD *)buf = 67241984;
            int v183 = v141;
            __int16 v184 = 2050;
            double v185 = a9;
            __int16 v186 = 1026;
            int v187 = v142;
            __int16 v188 = 1026;
            int v189 = v134;
            __int16 v190 = 1026;
            int v191 = v202;
            __int16 v192 = 1026;
            int v193 = v143;
            __int16 v194 = 1026;
            int v195 = v203;
            __int16 v196 = 1026;
            int v197 = v145;
            double v124 = "ID is queue ID. surfaceID=%{public, name=surfaceID}#x serverSamplingTime=%{public, name=serverSamplin"
                   "gTime}f updateSeed=%{public, name=updateSeed}#x queueGeneration=%{public, name=queueGeneration}u samp"
                   "les=[(%{public, name=sample0Surface}#x, %{public, name=sample0State}c), (%{public, name=sample1Surfac"
                   "e}#x, %{public, name=sample1State}c)]";
            double v125 = v121;
            os_signpost_id_t v126 = v164;
            uint32_t v127 = 54;
LABEL_363:
            _os_signpost_emit_with_name_impl(&dword_184668000, v125, OS_SIGNPOST_EVENT, v126, "ImageQueueSample", v124, buf, v127);
            return v91 != -1;
          }
          uint64_t v135 = "unconsumed";
        }
        int v134 = v175;
        goto LABEL_301;
      case 3uLL:
        if (a2 >= 4)
        {
          if (!v164 || !os_signpost_enabled((os_log_t)CAImageQueueLog(void)::log)) {
            return v91 != -1;
          }
          if (SHIDWORD(v202) > 572662305)
          {
            if (HIDWORD(v202) != 572662306)
            {
              int v136 = v175;
              if (HIDWORD(v202) == 858993459)
              {
                int v137 = "flushed";
                goto LABEL_317;
              }
              goto LABEL_316;
            }
            int v137 = "consumed";
          }
          else
          {
            if (HIDWORD(v202))
            {
              int v136 = v175;
              if (HIDWORD(v202) == 286331153)
              {
                int v137 = "displayed";
                goto LABEL_317;
              }
LABEL_316:
              int v137 = "<unknown>";
LABEL_317:
              if (SHIDWORD(v203) > 572662305)
              {
                if (HIDWORD(v203) == 572662306)
                {
                  float v146 = "consumed";
                  goto LABEL_337;
                }
                if (HIDWORD(v203) == 858993459)
                {
                  float v146 = "flushed";
                  goto LABEL_337;
                }
              }
              else
              {
                if (!HIDWORD(v203))
                {
                  float v146 = "unconsumed";
                  goto LABEL_337;
                }
                if (HIDWORD(v203) == 286331153)
                {
                  float v146 = "displayed";
                  goto LABEL_337;
                }
              }
              float v146 = "<unknown>";
LABEL_337:
              int v148 = *(_DWORD *)(v105 + 56);
              int v149 = *(_DWORD *)(v179 + 248);
              int v150 = *v137;
              int v151 = *v146;
              if (SHIDWORD(v204) > 572662305)
              {
                if (HIDWORD(v204) == 572662306)
                {
                  uint64_t v152 = "consumed";
                  goto LABEL_357;
                }
                if (HIDWORD(v204) == 858993459)
                {
                  uint64_t v152 = "flushed";
                  goto LABEL_357;
                }
              }
              else
              {
                if (!HIDWORD(v204))
                {
                  uint64_t v152 = "unconsumed";
                  goto LABEL_357;
                }
                if (HIDWORD(v204) == 286331153)
                {
                  uint64_t v152 = "displayed";
LABEL_357:
                  int v158 = *v152;
                  *(_DWORD *)buf = 67242496;
                  int v183 = v148;
                  __int16 v184 = 2050;
                  double v185 = a9;
                  __int16 v186 = 1026;
                  int v187 = v149;
                  __int16 v188 = 1026;
                  int v189 = v136;
                  __int16 v190 = 1026;
                  int v191 = v202;
                  __int16 v192 = 1026;
                  int v193 = v150;
                  __int16 v194 = 1026;
                  int v195 = v203;
                  __int16 v196 = 1026;
                  int v197 = v151;
                  __int16 v198 = 1026;
                  int v199 = v204;
                  __int16 v200 = 1026;
                  int v201 = v158;
                  double v124 = "ID is queue ID. surfaceID=%{public, name=surfaceID}#x serverSamplingTime=%{public, name=serverS"
                         "amplingTime}f updateSeed=%{public, name=updateSeed}#x queueGeneration=%{public, name=queueGener"
                         "ation}u samples=[(%{public, name=sample0Surface}#x, %{public, name=sample0State}c), (%{public, "
                         "name=sample1Surface}#x, %{public, name=sample1State}c), (%{public, name=sample2Surface}#x, %{pu"
                         "blic, name=sample2State}c), ...]";
LABEL_362:
                  double v125 = v121;
                  os_signpost_id_t v126 = v164;
                  uint32_t v127 = 66;
                  goto LABEL_363;
                }
              }
              uint64_t v152 = "<unknown>";
              goto LABEL_357;
            }
            int v137 = "unconsumed";
          }
          int v136 = v175;
          goto LABEL_317;
        }
        if (!v164 || !os_signpost_enabled((os_log_t)CAImageQueueLog(void)::log)) {
          return v91 != -1;
        }
        if (SHIDWORD(v202) > 572662305)
        {
          if (HIDWORD(v202) != 572662306)
          {
            int v138 = v175;
            if (HIDWORD(v202) == 858993459)
            {
              uint64_t v139 = "flushed";
              goto LABEL_327;
            }
            goto LABEL_326;
          }
          uint64_t v139 = "consumed";
        }
        else
        {
          if (HIDWORD(v202))
          {
            int v138 = v175;
            if (HIDWORD(v202) == 286331153)
            {
              uint64_t v139 = "displayed";
              goto LABEL_327;
            }
LABEL_326:
            uint64_t v139 = "<unknown>";
LABEL_327:
            if (SHIDWORD(v203) > 572662305)
            {
              if (HIDWORD(v203) == 572662306)
              {
                float16x4_t v147 = "consumed";
                goto LABEL_347;
              }
              if (HIDWORD(v203) == 858993459)
              {
                float16x4_t v147 = "flushed";
                goto LABEL_347;
              }
            }
            else
            {
              if (!HIDWORD(v203))
              {
                float16x4_t v147 = "unconsumed";
                goto LABEL_347;
              }
              if (HIDWORD(v203) == 286331153)
              {
                float16x4_t v147 = "displayed";
                goto LABEL_347;
              }
            }
            float16x4_t v147 = "<unknown>";
LABEL_347:
            int v153 = *(_DWORD *)(v105 + 56);
            int v154 = *(_DWORD *)(v179 + 248);
            int v155 = *v139;
            int v156 = *v147;
            if (SHIDWORD(v204) > 572662305)
            {
              if (HIDWORD(v204) == 572662306)
              {
                uint64_t v157 = "consumed";
                goto LABEL_361;
              }
              if (HIDWORD(v204) == 858993459)
              {
                uint64_t v157 = "flushed";
                goto LABEL_361;
              }
            }
            else
            {
              if (!HIDWORD(v204))
              {
                uint64_t v157 = "unconsumed";
                goto LABEL_361;
              }
              if (HIDWORD(v204) == 286331153)
              {
                uint64_t v157 = "displayed";
LABEL_361:
                int v159 = *v157;
                *(_DWORD *)buf = 67242496;
                int v183 = v153;
                __int16 v184 = 2050;
                double v185 = a9;
                __int16 v186 = 1026;
                int v187 = v154;
                __int16 v188 = 1026;
                int v189 = v138;
                __int16 v190 = 1026;
                int v191 = v202;
                __int16 v192 = 1026;
                int v193 = v155;
                __int16 v194 = 1026;
                int v195 = v203;
                __int16 v196 = 1026;
                int v197 = v156;
                __int16 v198 = 1026;
                int v199 = v204;
                __int16 v200 = 1026;
                int v201 = v159;
                double v124 = "ID is queue ID. surfaceID=%{public, name=surfaceID}#x serverSamplingTime=%{public, name=serverSam"
                       "plingTime}f updateSeed=%{public, name=updateSeed}#x queueGeneration=%{public, name=queueGeneratio"
                       "n}u samples=[(%{public, name=sample0Surface}#x, %{public, name=sample0State}c), (%{public, name=s"
                       "ample1Surface}#x, %{public, name=sample1State}c), (%{public, name=sample2Surface}#x, %{public, na"
                       "me=sample2State}c)]";
                goto LABEL_362;
              }
            }
            uint64_t v157 = "<unknown>";
            goto LABEL_361;
          }
          uint64_t v139 = "unconsumed";
        }
        int v138 = v175;
        goto LABEL_327;
      default:
        return v91 != -1;
    }
  }
  return v91 != -1;
}

void CAShmemImageQueueUpdate(uint64_t a1, int a2, int a3, unint64_t a4, void *a5, uint64_t a6, int a7, uint64_t a8, float a9, double a10)
{
  int v46 = a2;
  int v47 = a7;
  v48[1] = *(double *)MEMORY[0x1E4F143B8];
  if (!a6)
  {
    unint64_t v19 = CAHostTimeWithTime(a10);
    goto LABEL_7;
  }
  uint64_t v18 = *(void *)(a6 + 64);
  if ((v18 & 2) == 0)
  {
    unint64_t v19 = CAHostTimeWithTime(a10);
    if ((v18 & 8) != 0) {
      goto LABEL_8;
    }
LABEL_7:
    double v20 = 0.0166666667;
    goto LABEL_9;
  }
  unint64_t v19 = *(void *)(a6 + 16);
  if ((v18 & 8) == 0) {
    goto LABEL_7;
  }
LABEL_8:
  double v20 = (double)*(uint64_t *)(a6 + 32) / (double)*(int *)(a6 + 4);
LABEL_9:
  unint64_t v21 = CAHostTimeWithTime(v20);
  unint64_t v22 = v21;
  if (a5)
  {
    unint64_t v45 = v19;
    uint64_t v23 = a8;
    unint64_t v24 = a4;
    uint64_t v25 = -1;
    unint64_t v26 = a5;
    do
    {
      uint64_t v27 = v25;
      unint64_t v26 = (void *)v26[1];
      ++v25;
    }
    while (v26);
    unint64_t v28 = v27 + 2;
    if (v27 == -2)
    {
      double v30 = 0;
    }
    else
    {
      if (8 * v28 > 0x1000)
      {
        double v30 = (char *)malloc_type_malloc(8 * v28, 0x2004093837F09uLL);
        if (!v30) {
          return;
        }
      }
      else
      {
        MEMORY[0x1F4188790](v21);
        double v30 = (char *)&v45 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0);
        bzero(v30, v29);
      }
      do
      {
        *(void *)&v30[8 * v25] = *a5;
        a5 = (void *)a5[1];
        --v25;
      }
      while (v25 != -1);
    }
    a4 = v24;
    a8 = v23;
    unint64_t v19 = v45;
  }
  else
  {
    unint64_t v28 = 0;
    double v30 = 0;
  }
  v48[0] = 0.0;
  atomic_fetch_add((atomic_uint *volatile)a1, 1u);
  __dmb(0xBu);
  *(_DWORD *)(a1 + 20) = v46;
  if (*(_DWORD *)(a1 + 24) != a3)
  {
    *(_DWORD *)(a1 + 24) = a3;
    unint64_t v31 = atomic_load((unint64_t *)(a1 + 8));
    if ((v31 & 0x20000000000000) != 0)
    {
      if (a8)
      {
        uint64_t v32 = *(unsigned int *)(a1 + 56);
        if (v32) {
          CA::MachPortUtil::call_with_timeout<int (*)(unsigned int,unsigned int,unsigned int),unsigned int>(a8, 0, (uint64_t)"IQDidChangeDisplay", (uint64_t (*)(uint64_t, void, uint64_t))_CACImageQueueDidChangeDisplay, v32);
        }
      }
    }
  }
  atomic_store(a4, (unint64_t *)(a1 + 104));
  uint64_t v33 = 0;
  *(void *)(a1 + 112) = mach_absolute_time();
  double v34 = -0.0;
  if ((v47 & 0x10) == 0) {
    double v34 = v20;
  }
  double v35 = v34 + a10;
  if ((v47 & 0x10) != 0) {
    unint64_t v36 = 0;
  }
  else {
    unint64_t v36 = v22;
  }
  unint64_t v37 = v36 + v19;
  do
  {
    if (v28 != 1
      || (uint64_t v38 = *(void *)v30,
          double v39 = *(double *)(*(void *)v30 + 48)
              + (v35 - *(double *)(*(void *)v30 + 40)) * *(float *)(*(void *)v30 + 16),
          v48[0] = v39,
          v39 < 0.0)
      || v39 >= *(double *)(v38 + 32))
    {
      v48[0] = v35;
      BOOL v40 = v35 < 0.0 || v28 == 0;
      double v39 = v35;
      if (!v40)
      {
        unint64_t v41 = 0;
        while ((CA::Render::Timing::map_time(*(CA::Render::Timing **)&v30[8 * v41], v48, 0) & 1) != 0)
        {
          double v39 = v48[0];
          ++v41;
          if (v48[0] < 0.0 || v41 >= v28) {
            goto LABEL_47;
          }
        }
        v48[0] = -1.0;
        double v39 = -1.0;
      }
    }
LABEL_47:
    uint64_t v43 = a1 + 24 * v33;
    *(double *)(v43 + 336) = v39;
    *(void *)(v43 + 328) = v37;
    *(float *)(v43 + 344) = a9;
    ++v33;
    double v35 = v35 + v20;
    v37 += v22;
  }
  while (v33 != 4);
  *(_DWORD *)(a1 + 60) = 4;
  if (a6)
  {
    *(_DWORD *)(a1 + 288) = *(_DWORD *)(a6 + 4);
    uint64_t v44 = *(void *)(a6 + 64);
    if (v44)
    {
      *(void *)(a1 + 272) = *(void *)(a6 + 8);
      if ((v44 & 8) == 0)
      {
LABEL_51:
        if ((v44 & 0x10) == 0) {
          goto LABEL_53;
        }
        goto LABEL_52;
      }
    }
    else if ((v44 & 8) == 0)
    {
      goto LABEL_51;
    }
    *(void *)(a1 + 280) = *(void *)(a6 + 32);
    if ((v44 & 0x10) != 0) {
LABEL_52:
    }
      *(void *)(a1 + 264) = *(void *)(a6 + 24);
  }
LABEL_53:
  __dmb(0xBu);
  atomic_fetch_add((atomic_uint *volatile)(a1 + 4), 1u);
  if (8 * v28 > 0x1000)
  {
    if (v30) {
      free(v30);
    }
  }
}

void CA::Render::update_texture_flags(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  unint64_t v8 = atomic_load((unint64_t *)(a2 + 8));
  if ((a3 & 1) != 0 || (*(unsigned int (**)(uint64_t))(*(void *)a1 + 120))(a1)) {
    int v9 = 16;
  }
  else {
    int v9 = 0;
  }
  unsigned int v10 = a3 & 8 | (((v8 >> 3) & 1) << 6) & 0xFFFFFEFF | (32 * ((v8 >> 4) & 1)) & 0xFFFFFEFF | (((v8 >> 6) & 1) << 8) | (v8 >> 1) & 0x200 | v9;
  if ((v8 & 0x2000) != 0)
  {
    int v11 = v10 | 0x800;
  }
  else
  {
    if (CADeviceSupportsASTC::once != -1) {
      dispatch_once(&CADeviceSupportsASTC::once, &__block_literal_global_169_12170);
    }
    if (CADeviceSupportsASTC::supports_astc) {
      int v11 = v10;
    }
    else {
      int v11 = v10 | 0x800;
    }
  }
  int v12 = a4 & 7 | (((a4 >> 3) & 1) << 13) | v11;
  unsigned int v13 = *(_DWORD *)(a1 + 12);
  if (((v13 >> 8) & 0x97F) != v12)
  {
    unsigned int v13 = v13 & 0xFFF680FF | (v12 << 8);
    *(_DWORD *)(a1 + 12) = v13;
  }
  if ((a3 & 0x40000000) != 0 && v13 == 51)
  {
    if ((v8 & 0x40000000000000) != 0)
    {
      int v14 = 327680;
    }
    else
    {
      v13 &= ~0x4000000u;
      int v14 = 0x10000;
    }
    v13 |= (v14 | (a3 >> 10) & 0x20000) << 8;
    *(_DWORD *)(a1 + 12) = v13;
  }
  if ((a3 & 0x2000000) != 0
    || (unint64_t v15 = atomic_load((unint64_t *)(a2 + 8)), v13 = *(_DWORD *)(a1 + 12), (v15 & 0x20000000000000) != 0))
  {
    v13 |= 0x8000000u;
    *(_DWORD *)(a1 + 12) = v13;
  }
  if (v13 == 51)
  {
    if (initialized != -1) {
      dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
    }
    unsigned int v16 = *(float *)&dword_1EB2ACB24;
    if (!*(float *)&dword_1EB2ACB24) {
      LOBYTE(v16) = *(unsigned char *)(a2 + 94);
    }
    *(unsigned char *)(a1 + 328) = v16;
  }
}

uint64_t *update_image_sample(uint64_t *result, uint64_t a2, uint64_t a3, uint64_t a4, double a5)
{
  unint64_t v7 = (unint64_t)result;
  *(_DWORD *)(a3 + 60) = 286331153;
  int v8 = *(_DWORD *)(a4 + 248);
  int v9 = *(_DWORD *)(a3 + 84);
  *(_DWORD *)(a3 + 84) = v9 + 1;
  *(_DWORD *)(a3 + 88) = v8;
  if (!v9)
  {
    IOSurfaceID v18 = *(_DWORD *)(a3 + 56);
    if (v18)
    {
      IOSurfaceRef v19 = IOSurfaceLookup(v18);
      if (v19)
      {
        IOSurfaceRef v20 = v19;
        IOSurfaceInitDetachModeCode();
        IOSurfaceSetDetachModeCode();
        CFRelease(v20);
      }
      *(unsigned char *)(a3 + 123) = 0;
      int v8 = *(_DWORD *)(a4 + 248);
    }
    *(double *)(a3 + 16) = a5;
    *(_DWORD *)(a3 + 92) = v8;
    *(_DWORD *)(a2 + 40) = *(_DWORD *)(a3 + 100);
    double v21 = *(double *)(a4 + 72);
    *(void *)(a2 + 136) = *(void *)a3;
    *(double *)(a2 + 144) = v21;
    uint64_t v22 = *(void *)(a4 + 160);
    if (v22) {
      int64x2_t result = *(uint64_t **)(v22 + 16);
    }
    else {
      int64x2_t result = (uint64_t *)CAHostTimeWithTime(v21);
    }
    *(void *)(a3 + 24) = result;
    *(void *)(a3 + 32) = *(void *)(a4 + 112);
    __int16 v23 = atomic_load((unint64_t *)(a2 + 8));
    if (v23 < 0 && v7)
    {
      unint64_t v24 = *(void **)(a4 + 864);
      if (!v24) {
        goto LABEL_41;
      }
      uint64_t v25 = (void *)(a4 + 864);
      do
      {
        unint64_t v26 = v24[4];
        BOOL v27 = v26 >= v7;
        if (v26 >= v7) {
          unint64_t v28 = v24;
        }
        else {
          unint64_t v28 = v24 + 1;
        }
        if (v27) {
          uint64_t v25 = v24;
        }
        unint64_t v24 = (void *)*v28;
      }
      while (*v28);
      if (v25 == (void *)(a4 + 864) || v25[4] > v7)
      {
LABEL_41:
        int64x2_t result = std::__tree<CA::Render::Object *>::__emplace_unique_key_args<CA::Render::Object *,CA::Render::Object * const&>((uint64_t *)(a4 + 856), v7, v7);
        if (!atomic_fetch_add((atomic_uint *volatile)(v7 + 8), 1u)) {
          atomic_fetch_add((atomic_uint *volatile)(v7 + 8), 0xFFFFFFFF);
        }
      }
    }
  }
  unint64_t v10 = atomic_load((unint64_t *)(a2 + 8));
  if ((v10 & 0x2000000000000000) != 0 && v7)
  {
    int64x2_t result = *(uint64_t **)(a4 + 824);
    if (!result) {
      operator new();
    }
    int v11 = (void *)result[1];
    if (!v11) {
      goto LABEL_24;
    }
    int v12 = result + 1;
    do
    {
      unint64_t v13 = v11[4];
      BOOL v14 = v13 >= v7;
      if (v13 >= v7) {
        unint64_t v15 = v11;
      }
      else {
        unint64_t v15 = v11 + 1;
      }
      if (v14) {
        int v12 = v11;
      }
      int v11 = (void *)*v15;
    }
    while (*v15);
    if (v12 == result + 1 || v12[4] > v7)
    {
LABEL_24:
      int64x2_t result = std::__tree<CA::Render::Object *>::__emplace_unique_key_args<CA::Render::Object *,CA::Render::Object * const&>(result, v7, v7);
      if (!atomic_fetch_add((atomic_uint *volatile)(v7 + 8), 1u)) {
        atomic_fetch_add((atomic_uint *volatile)(v7 + 8), 0xFFFFFFFF);
      }
    }
  }
  return result;
}

uint64_t *std::__tree<std::tuple<unsigned short,unsigned short>>::__insert_node_at(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  int v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  int64x2_t result = std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t *std::__tree<CA::Render::Object *>::__emplace_unique_key_args<CA::Render::Object *,CA::Render::Object * const&>(uint64_t *result, unint64_t a2, uint64_t a3)
{
  unint64_t v4 = (uint64_t **)result;
  uint64_t v6 = (uint64_t **)(result + 1);
  int v5 = (uint64_t *)result[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v7 = (uint64_t **)v5;
        unint64_t v8 = v5[4];
        if (v8 <= a2) {
          break;
        }
        int v5 = *v7;
        uint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      int v5 = v7[1];
      if (!v5)
      {
        uint64_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    unint64_t v7 = (uint64_t **)(result + 1);
LABEL_9:
    int v9 = (uint64_t *)operator new(0x28uLL);
    v9[4] = a3;
    return std::__tree<std::tuple<unsigned short,unsigned short>>::__insert_node_at(v4, (uint64_t)v7, v6, v9);
  }
  return result;
}

uint64_t CA::Render::MatchPropertyDependence::run(uint64_t this, CA::Render::Update *a2, double a3, Handle *a4)
{
  if (((_BYTE)a4[12] & 0x18) != 0) {
    *(_DWORD *)(*(void *)(this + 48) + 76) = *((_DWORD *)a2 + 62);
  }
  return this;
}

double **std::__introsort<std::_ClassicAlgPolicy,CAShmemImageQueueCopyImageInfo::$_0 &,_CAShmemImageQueueImage **,false>(double **result, double **a2, uint64_t a3, char a4)
{
  int v9 = result;
  while (2)
  {
    unint64_t v10 = a2 - 1;
    int v11 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          int v9 = v11;
          uint64_t v12 = (char *)a2 - (char *)v11;
          unint64_t v13 = a2 - v11;
          if (v5 || !v4)
          {
            switch(v13)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                unint64_t v41 = *v11;
                if (**v10 < **v11)
                {
                  *int v11 = *v10;
                  *unint64_t v10 = v41;
                }
                break;
              case 3uLL:
                int64x2_t result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CAShmemImageQueueCopyImageInfo::$_0 &,_CAShmemImageQueueImage **>(v11, v11 + 1, a2 - 1);
                break;
              case 4uLL:
                int64x2_t result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,CAShmemImageQueueCopyImageInfo::$_0 &,_CAShmemImageQueueImage **>(v11, v11 + 1, v11 + 2, a2 - 1);
                break;
              case 5uLL:
                unint64_t v42 = v11 + 1;
                uint64_t v43 = v11 + 2;
                uint64_t v44 = v11 + 3;
                int64x2_t result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,CAShmemImageQueueCopyImageInfo::$_0 &,_CAShmemImageQueueImage **>(v11, v11 + 1, v11 + 2, v11 + 3);
                unint64_t v45 = v11[3];
                if (**v10 < *v45)
                {
                  *uint64_t v44 = *v10;
                  *unint64_t v10 = v45;
                  int v46 = *v44;
                  double v47 = **v44;
                  uint64_t v48 = *v43;
                  if (v47 < **v43)
                  {
                    *uint64_t v43 = v46;
                    *uint64_t v44 = v48;
                    double v49 = *v42;
                    if (v47 < **v42)
                    {
                      v11[1] = v46;
                      v11[2] = v49;
                      double v50 = *v11;
                      if (v47 < **v11)
                      {
                        *int v11 = v46;
                        v11[1] = v50;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v12 <= 191)
          {
            long long v51 = v11 + 1;
            BOOL v53 = v11 == a2 || v51 == a2;
            if (a4)
            {
              if (!v53)
              {
                uint64_t v54 = 8;
                uint64_t v55 = v11;
                do
                {
                  uint64_t v57 = *v55;
                  uint64_t v56 = v55[1];
                  uint64_t v55 = v51;
                  double v58 = *v56;
                  if (*v56 < *v57)
                  {
                    uint64_t v59 = v54;
                    do
                    {
                      *(double **)((char *)v11 + v59) = v57;
                      uint64_t v60 = v59 - 8;
                      if (v59 == 8)
                      {
                        uint64_t v61 = v11;
                        goto LABEL_81;
                      }
                      uint64_t v57 = *(double **)((char *)v11 + v59 - 16);
                      v59 -= 8;
                    }
                    while (v58 < *v57);
                    uint64_t v61 = (double **)((char *)v11 + v60);
LABEL_81:
                    *uint64_t v61 = v56;
                  }
                  long long v51 = v55 + 1;
                  v54 += 8;
                }
                while (v55 + 1 != a2);
              }
            }
            else if (!v53)
            {
              do
              {
                uint64_t v90 = *v9;
                uint64_t v89 = v9[1];
                int v9 = v51;
                double v91 = *v89;
                if (*v89 < *v90)
                {
                  do
                  {
                    *long long v51 = v90;
                    uint64_t v90 = *(v51 - 2);
                    --v51;
                  }
                  while (v91 < *v90);
                  *long long v51 = v89;
                }
                long long v51 = v9 + 1;
              }
              while (v9 + 1 != a2);
            }
            return result;
          }
          if (!a3)
          {
            if (v11 != a2)
            {
              int64_t v62 = (v13 - 2) >> 1;
              int64_t v63 = v62;
              do
              {
                int64_t v64 = v63;
                if (v62 >= v63)
                {
                  uint64_t v65 = (2 * v63) | 1;
                  int v66 = &v11[v65];
                  if (2 * v64 + 2 < (uint64_t)v13 && **v66 < *v66[1])
                  {
                    ++v66;
                    uint64_t v65 = 2 * v64 + 2;
                  }
                  BOOL v67 = &v11[v64];
                  double v68 = *v66;
                  int v69 = *v67;
                  double v70 = **v67;
                  if (**v66 >= v70)
                  {
                    do
                    {
                      uint64_t v71 = v66;
                      *BOOL v67 = v68;
                      if (v62 < v65) {
                        break;
                      }
                      uint64_t v72 = 2 * v65;
                      uint64_t v65 = (2 * v65) | 1;
                      int v66 = &v11[v65];
                      uint64_t v73 = v72 + 2;
                      if (v73 < (uint64_t)v13)
                      {
                        int64x2_t result = (double **)v66[1];
                        if (**v66 < *(double *)result)
                        {
                          ++v66;
                          uint64_t v65 = v73;
                        }
                      }
                      double v68 = *v66;
                      BOOL v67 = v71;
                    }
                    while (**v66 >= v70);
                    double *v71 = v69;
                  }
                }
                int64_t v63 = v64 - 1;
              }
              while (v64);
              uint64_t v74 = (unint64_t)v12 >> 3;
              do
              {
                uint64_t v75 = 0;
                uint64_t v76 = *v11;
                unsigned int v77 = v11;
                do
                {
                  double v78 = v77;
                  v77 += v75 + 1;
                  uint64_t v79 = 2 * v75;
                  uint64_t v75 = (2 * v75) | 1;
                  uint64_t v80 = v79 + 2;
                  if (v80 < v74 && **v77 < *v77[1])
                  {
                    ++v77;
                    uint64_t v75 = v80;
                  }
                  *double v78 = *v77;
                }
                while (v75 <= (uint64_t)((unint64_t)(v74 - 2) >> 1));
                if (v77 == --a2)
                {
                  *unsigned int v77 = v76;
                }
                else
                {
                  *unsigned int v77 = *a2;
                  *a2 = v76;
                  uint64_t v81 = (char *)v77 - (char *)v11 + 8;
                  if (v81 >= 9)
                  {
                    unint64_t v82 = (((unint64_t)v81 >> 3) - 2) >> 1;
                    char v83 = &v11[v82];
                    uint64_t v84 = *v83;
                    char v85 = *v77;
                    double v86 = **v77;
                    if (**v83 < v86)
                    {
                      do
                      {
                        uint64_t v87 = v83;
                        *unsigned int v77 = v84;
                        if (!v82) {
                          break;
                        }
                        unint64_t v82 = (v82 - 1) >> 1;
                        char v83 = &v11[v82];
                        uint64_t v84 = *v83;
                        unsigned int v77 = v87;
                      }
                      while (**v83 < v86);
                      *uint64_t v87 = v85;
                    }
                  }
                }
              }
              while (v74-- > 2);
            }
            return result;
          }
          unint64_t v14 = v13 >> 1;
          unint64_t v15 = &v11[v13 >> 1];
          if ((unint64_t)v12 >= 0x401)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CAShmemImageQueueCopyImageInfo::$_0 &,_CAShmemImageQueueImage **>(v9, &v9[v13 >> 1], a2 - 1);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CAShmemImageQueueCopyImageInfo::$_0 &,_CAShmemImageQueueImage **>(v9 + 1, v15 - 1, a2 - 2);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CAShmemImageQueueCopyImageInfo::$_0 &,_CAShmemImageQueueImage **>(v9 + 2, &v9[v14 + 1], a2 - 3);
            int64x2_t result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CAShmemImageQueueCopyImageInfo::$_0 &,_CAShmemImageQueueImage **>(v15 - 1, v15, &v9[v14 + 1]);
            unsigned int v16 = *v9;
            *int v9 = *v15;
            *unint64_t v15 = v16;
          }
          else
          {
            int64x2_t result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CAShmemImageQueueCopyImageInfo::$_0 &,_CAShmemImageQueueImage **>(&v9[v13 >> 1], v9, a2 - 1);
          }
          --a3;
          unint64_t v17 = *v9;
          double v18 = **v9;
          IOSurfaceRef v19 = v9;
          if (a4) {
            break;
          }
          IOSurfaceRef v19 = v9;
          if (**(v9 - 1) < v18) {
            break;
          }
          if (v18 >= **v10)
          {
            uint64_t v33 = v9 + 1;
            do
            {
              int v11 = v33;
              if (v33 >= a2) {
                break;
              }
              ++v33;
            }
            while (v18 >= **v11);
          }
          else
          {
            int v11 = v9;
            do
            {
              uint64_t v32 = v11[1];
              ++v11;
            }
            while (v18 >= *v32);
          }
          double v34 = a2;
          if (v11 < a2)
          {
            double v34 = a2;
            do
              double v35 = *--v34;
            while (v18 < *v35);
          }
          if (v11 < v34)
          {
            unint64_t v36 = *v11;
            unint64_t v37 = *v34;
            do
            {
              *int v11 = v37;
              *double v34 = v36;
              do
              {
                uint64_t v38 = v11[1];
                ++v11;
                unint64_t v36 = v38;
              }
              while (v18 >= *v38);
              do
              {
                double v39 = *--v34;
                unint64_t v37 = v39;
              }
              while (v18 < *v39);
            }
            while (v11 < v34);
          }
          BOOL v40 = v11 - 1;
          BOOL v4 = v11 - 1 >= v9;
          BOOL v5 = v11 - 1 == v9;
          if (v11 - 1 != v9) {
            *int v9 = *v40;
          }
          a4 = 0;
          *BOOL v40 = v17;
        }
        do
        {
          IOSurfaceRef v20 = v19;
          uint64_t v22 = v19[1];
          ++v19;
          double v21 = v22;
        }
        while (*v22 < v18);
        __int16 v23 = a2;
        if (v20 == v9)
        {
          __int16 v23 = a2;
          do
          {
            if (v19 >= v23) {
              break;
            }
            uint64_t v25 = *--v23;
          }
          while (*v25 >= v18);
        }
        else
        {
          do
            unint64_t v24 = *--v23;
          while (*v24 >= v18);
        }
        if (v19 < v23)
        {
          unint64_t v26 = *v23;
          BOOL v27 = v23;
          unint64_t v28 = v19;
          do
          {
            void *v28 = v26;
            atomic_uint *v27 = v21;
            do
            {
              IOSurfaceRef v20 = v28;
              size_t v29 = v28[1];
              ++v28;
              double v21 = v29;
            }
            while (*v29 < v18);
            do
            {
              double v30 = *--v27;
              unint64_t v26 = v30;
            }
            while (*v30 >= v18);
          }
          while (v28 < v27);
        }
        if (v20 != v9) {
          *int v9 = *v20;
        }
        atomic_uint *v20 = v17;
        if (v19 >= v23) {
          break;
        }
LABEL_30:
        int64x2_t result = (double **)std::__introsort<std::_ClassicAlgPolicy,CAShmemImageQueueCopyImageInfo::$_0 &,_CAShmemImageQueueImage **,false>(v9, v20, a3, a4 & 1);
        a4 = 0;
        int v11 = v20 + 1;
      }
      BOOL v31 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,CAShmemImageQueueCopyImageInfo::$_0 &,_CAShmemImageQueueImage **>(v9, v20);
      int v11 = v20 + 1;
      int64x2_t result = (double **)std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,CAShmemImageQueueCopyImageInfo::$_0 &,_CAShmemImageQueueImage **>(v20 + 1, a2);
      if (result) {
        break;
      }
      if (!v31) {
        goto LABEL_30;
      }
    }
    a2 = v20;
    if (!v31) {
      continue;
    }
    return result;
  }
}

id CA::Render::ImageQueue::retain_image_queue(CA::Render::ImageQueue *this)
{
  unint64_t v2 = (id *)((char *)this + 208);
  if (*((unsigned char *)this + 216)) {
    return objc_loadWeakRetained(v2);
  }
  else {
    return *v2;
  }
}

BOOL CATransform3DEqualToTransform(CATransform3D *a, CATransform3D *b)
{
  if (a->m11 != b->m11) {
    return 0;
  }
  uint64_t v3 = 1;
  unint64_t v4 = 15;
  while (v3 != 16)
  {
    double v5 = *(&a->m11 + v3);
    double v6 = *(&b->m11 + v3++);
    if (v5 != v6)
    {
      unint64_t v4 = v3 - 2;
      return v4 > 0xE;
    }
  }
  return v4 > 0xE;
}

CFTimeInterval CACurrentMediaTime(void)
{
  uint64_t v0 = mach_absolute_time();

  return CATimeWithHostTime(v0);
}

uint64_t CA::Render::Updater::prepare_layer(int32x2_t **a1, const CA::Render::Layer *a2, uint64_t a3, uint64_t a4, void *a5)
{
  uint64_t v1045 = *MEMORY[0x1E4F143B8];
  if (!a3) {
    return 0;
  }
  uint64_t v6 = a3;
  uint64_t v7 = (uint64_t)a2;
  unint64_t v8 = a1;
  uint64_t v998 = a4;
  float64_t v9 = *(double *)(a3 + 32);
  unint64_t v10 = (*a1)[135].u32[1] | ((unint64_t)(*a1)[136].u16[0] << 32);
  v1002.f64[0] = v9;
  if ((v10 & 4) != 0)
  {
    uint64_t v14 = 0;
    int v11 = 0;
LABEL_19:
    uint64_t v16 = 268435516;
    goto LABEL_20;
  }
  int v11 = *(int32x2_t **)(*(void *)&v9 + 144);
  if (!v11)
  {
    uint64_t v14 = 0;
    goto LABEL_19;
  }
  uint64_t v12 = 12;
  if (v11[10].i32[0] == *((_DWORD *)a1 + 2)) {
    uint64_t v12 = 13;
  }
  int32x2_t v13 = v11[v12];
  uint64_t v14 = (*(void *)&v11[12] >> 53) & 7;
  _ZF = (*(void *)&v13 & 0x1800000000) == 0 || (v10 & 0x40000000000) == 0;
  if (_ZF) {
    uint64_t v16 = *((void *)a2 + 8) & 8 | *(void *)&v13 | *((void *)a2 + 8) & ((unsigned __int32)v13.i32[0] >> 1) & 0x20;
  }
  else {
    uint64_t v16 = *((void *)a2 + 8) & 8 | *(void *)&v13 | *((void *)a2 + 8) & ((unsigned __int32)v13.i32[0] >> 1) & 0x20 | 4;
  }
  if ((v10 & 0x400000) != 0 && !*(void *)(a3 + 224) && (*(unsigned char *)(a3 + 24) & 0x40) != 0) {
    v16 |= 0xCuLL;
  }
LABEL_20:
  unsigned int v17 = CA::Render::FlattenManager::layer_is_flattened(*(CA::Render::FlattenManager **)&v1002.f64[0], a2);
  char v20 = *(unsigned char *)(*(void *)&v1002.f64[0] + 42);
  *(void *)&v1003.f64[0] = v8;
  uint64_t v1001 = v6;
  LODWORD(v999) = v17;
  if ((v20 & 8) == 0 || v17)
  {
    v23.i32[1] = 0;
    v23.i64[1] = 0;
    long long v997 = 0u;
    if (v17 && (uint64_t v24 = *(unsigned int *)(*(void *)(*(void *)&v1002.f64[0] + 144) + 72), v24))
    {
      os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::flattened_lock);
      long long v997 = 0u;
      if (CA::Render::flattened_cache && *(void *)(CA::Render::flattened_cache + 24))
      {
        uint64_t v25 = v14;
        unint64_t v26 = (uint64_t *)x_hash_table_lookup(CA::Render::flattened_cache, v24, 0);
        if (v26)
        {
          BOOL v27 = v26;
          unint64_t v995 = v26[5];
          uint64_t v28 = v26[7];
          uint64_t ProtectionOptions = *v26;
          if (ProtectionOptions) {
            uint64_t ProtectionOptions = IOSurfaceGetProtectionOptions();
          }
          double v21 = a5;
          long long v997 = *(_OWORD *)(v27 + 1);
          if ((_BYTE)xmmword_1EB2ACC70)
          {
            uint64_t v22 = ProtectionOptions;
            v994 = v21;
            uint64_t v986 = v7;
            uint64_t v924 = *((unsigned int *)v27 + 12);
            float64x2_t v1024 = 0uLL;
            if (v995) {
              CA::Shape::get_bounds(v995, (int *)&v1024);
            }
            if (v28) {
              v925 = (const char *)(v28 + 28);
            }
            else {
              v925 = "";
            }
            if (x_log_hook_p())
            {
              *(void *)&v977[72] = DWORD2(v997);
              *(void *)&v977[80] = HIDWORD(v997);
              *(void *)&v977[56] = v997;
              *(void *)&v977[64] = DWORD1(v997);
              *(void *)&v977[40] = v22;
              *(void *)&v977[48] = v924;
              *(void *)&v977[24] = LODWORD(v1024.f64[1]);
              *(void *)&v977[32] = HIDWORD(v1024.f64[1]);
              *(void *)&v977[8] = LODWORD(v1024.f64[0]);
              *(void *)&v977[16] = HIDWORD(v1024.f64[0]);
              *(void *)&v976.f64[1] = v24;
              *(void *)v977 = v925;
              x_log_();
            }
            else
            {
              v938 = x_log_category_flatten;
              if (os_log_type_enabled((os_log_t)x_log_category_flatten, OS_LOG_TYPE_DEFAULT))
              {
                LODWORD(v1042[0].f64[0]) = 67111938;
                HIDWORD(v1042[0].f64[0]) = v24;
                LOWORD(v1042[0].f64[1]) = 2080;
                *(void *)((char *)&v1042[0].f64[1] + 2) = v925;
                WORD1(v1042[1].f64[0]) = 1024;
                HIDWORD(v1042[1].f64[0]) = LODWORD(v1024.f64[0]);
                LOWORD(v1042[1].f64[1]) = 1024;
                *(_DWORD *)((char *)&v1042[1].f64[1] + 2) = HIDWORD(v1024.f64[0]);
                HIWORD(v1042[1].f64[1]) = 1024;
                LODWORD(v1042[2].f64[0]) = LODWORD(v1024.f64[1]);
                WORD2(v1042[2].f64[0]) = 1024;
                *(_DWORD *)((char *)v1042[2].f64 + 6) = HIDWORD(v1024.f64[1]);
                WORD1(v1042[2].f64[1]) = 2048;
                *(void *)((char *)&v1042[2].f64[1] + 4) = v22;
                WORD2(v1042[3].f64[0]) = 1024;
                *(_DWORD *)((char *)v1042[3].f64 + 6) = v924;
                WORD1(v1042[3].f64[1]) = 1024;
                HIDWORD(v1042[3].f64[1]) = v997;
                LOWORD(v1042[4].f64[0]) = 1024;
                *(_DWORD *)((char *)v1042[4].f64 + 2) = DWORD1(v997);
                HIWORD(v1042[4].f64[0]) = 1024;
                LODWORD(v1042[4].f64[1]) = DWORD2(v997);
                WORD2(v1042[4].f64[1]) = 1024;
                *(_DWORD *)((char *)&v1042[4].f64[1] + 6) = HIDWORD(v997);
                _os_log_impl(&dword_184668000, v938, OS_LOG_TYPE_DEFAULT, "[%d] fetched flatten info [%s] [%d %d %d %d] [%llu] [%x] [%d %d %d %d]", (uint8_t *)v1042, 0x52u);
              }
            }
            uint64_t v7 = v986;
            double v21 = v994;
          }
          else
          {
            uint64_t v22 = ProtectionOptions;
          }
          unint64_t v8 = *(int32x2_t ***)&v1003.f64[0];
        }
        else
        {
          double v21 = a5;
          unint64_t v995 = 0;
          uint64_t v22 = 0;
        }
        uint64_t v14 = v25;
        uint64_t v6 = v1001;
      }
      else
      {
        double v21 = a5;
        unint64_t v995 = 0;
        uint64_t v22 = 0;
      }
      os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::flattened_lock);
    }
    else
    {
      double v21 = a5;
      uint64_t v22 = 0;
      unint64_t v995 = 0;
    }
    v1000.n128_u32[0] = 0;
  }
  else
  {
    double v21 = a5;
    uint64_t v22 = 0;
    unint64_t v995 = 0;
    v1000.n128_u32[0] = ((*v8)[135].i32[1] & 4) == 0;
    v23.i32[1] = 0;
    v23.i64[1] = 0;
    long long v997 = 0u;
  }
  if ((*(void *)(v6 + 24) & 0x4000000) != 0)
  {
    v16 |= 0x3CuLL;
    double v30 = 0;
  }
  else
  {
    double v30 = v11;
  }
  uint64_t v31 = v998;
  if (byte_1EB2ACC67) {
    goto LABEL_1624;
  }
  if (initialized != -1) {
    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
  }
  if (*(float *)&dword_1EB2ACB8C) {
LABEL_1624:
  }
    v16 |= 0x1000003CuLL;
  *(void *)(v7 + 80) = v16;
  uint64_t v32 = (uint64_t **)*v8;
  ++(*v8)[94].i32[0];
  if (v1000.n128_u32[0]) {
    *((_DWORD *)v32 + 67) |= 0x10000000u;
  }
  if ((v16 & 0x3C) == 0)
  {
    uint64_t v44 = *(const CA::Shape **)&v1002.f64[0];
    if (*(void *)(*(void *)&v1002.f64[0] + 128)) {
      CA::Render::Updater::add_background_filters_((uint64_t ***)v8, v7, *(uint64_t *)&v1002.f64[0], v6, 0, 0);
    }
    uint64_t v45 = *(void *)(v6 + 24);
    int v46 = v21;
    if ((v45 & 0x20) != 0)
    {
      CA::Render::LayerNode::depth_sort_sublayers((CA::Render::LayerNode *)v6);
      uint64_t v45 = *(void *)(v6 + 24);
    }
    if ((v45 & 0x10) != 0) {
      goto LABEL_1277;
    }
    if (v30)
    {
      int v47 = v30[15].i32[0];
      int v48 = v30[15].i32[1];
      if (v47 <= v48) {
        int v49 = v30[15].i32[1];
      }
      else {
        int v49 = v30[15].i32[0];
      }
      v23.i32[0] = 1073741822;
      v19.i32[0] = v49;
      int8x16_t v50 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v19, v23), 0);
      int32x2_t v51 = v30[14];
      v52.i64[0] = v51.i32[0];
      v52.i64[1] = v51.i32[1];
      int8x16_t v53 = vbslq_s8(v50, (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v52));
      double v54 = (double)v47;
      if (v49 > 1073741822) {
        double v54 = 1.79769313e308;
      }
      v1042[0] = (float64x2_t)v53;
      if (v49 <= 1073741822) {
        double v55 = (double)v48;
      }
      else {
        double v55 = 1.79769313e308;
      }
      v1042[1].f64[0] = v54;
      v1042[1].f64[1] = v55;
      CA::Render::Updater::LayerShapes::union_bounds((__n128 *)v31, v1042, 0);
    }
    uint64_t v56 = *(CA::Shape ***)(v6 + 208);
    if (v56)
    {
      if (*(void *)(v31 + 56))
      {
        CA::shape_union((CA::Shape **)(v31 + 56), v56, v44);
        uint64_t v56 = *(CA::Shape ***)(v6 + 208);
      }
      CA::Render::Update::fullfill_backdrops((uint64_t)*v8, (const CA::Shape *)v56);
      CA::Render::Update::add_opaque_shape((CA::Shape **)*v8, *(CA::Shape ***)(v6 + 208), v57);
    }
    double v58 = (CA::Shape **)(v31 + 64);
    if (!*(void *)(v31 + 64) || (v60 = (CA::Shape ***)(v1001 + 224), (uint64_t v59 = *(CA::Shape ***)(v1001 + 224)) == 0))
    {
LABEL_1261:
      uint64_t v6 = v1001;
      if (*(void *)(v31 + 72))
      {
        int v708 = *(CA::Shape ***)(v1001 + 232);
        if (v708) {
          CA::shape_union((CA::Shape **)(v31 + 72), v708, v44);
        }
      }
      int v709 = *(int32x2_t **)(v31 + 80);
      if (v709)
      {
        int v710 = *(_DWORD *)(v1001 + 168);
        int v711 = *(_DWORD *)(v1001 + 172);
        if (v710 <= v711) {
          int v712 = *(_DWORD *)(v1001 + 172);
        }
        else {
          int v712 = *(_DWORD *)(v1001 + 168);
        }
        v23.i32[0] = 1073741822;
        v19.i32[0] = v712;
        int8x16_t v713 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v19, v23), 0);
        uint64_t v714 = *(void *)(v1001 + 160);
        v715.i64[0] = (int)v714;
        v715.i64[1] = SHIDWORD(v714);
        float64x2_t v716 = (float64x2_t)vbslq_s8(v713, (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v715));
        double v717 = (double)v710;
        double v718 = (double)v711;
        if (v712 > 1073741822)
        {
          double v717 = 1.79769313e308;
          double v718 = 1.79769313e308;
        }
        v1042[0] = v716;
        v1042[1].f64[0] = v717;
        v1042[1].f64[1] = v718;
        uint64_t v719 = *(float64x2_t **)(v1001 + 56);
        if (v719)
        {
          CA::Mat4Impl::mat4_apply_to_rect(v719, (int8x16_t *)v1042, (double *)v44);
          float64x2_t v720 = v1042[0];
        }
        else
        {
          float64x2_t v720 = vaddq_f64(v716, *(float64x2_t *)(v1001 + 64));
        }
        int64x2_t v721 = vceqzq_f64(v1042[1]);
        unint64_t v722 = vorrq_s8((int8x16_t)vdupq_laneq_s64(v721, 1), (int8x16_t)v721).u64[0];
        int8x16_t v723 = 0uLL;
        if ((v722 & 0x8000000000000000) == 0)
        {
          int8x16_t v724 = vorrq_s8((int8x16_t)vcltzq_f64(v1042[1]), (int8x16_t)vcgezq_f64(v1042[1]));
          if ((vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v724), 1), v724).u64[0] & 0x8000000000000000) == 0)
          {
            int32x4_t v725 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v720, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
            int8x16_t v723 = (int8x16_t)vuzp1q_s32(v725, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v720, v1042[1]), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v725));
          }
        }
        CA::BoundsImpl::Union(v709, *(int32x2_t *)v723.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v723, v723, 8uLL));
      }
LABEL_1277:
      if ((v16 & 2) != 0)
      {
        if (v30)
        {
          if (*(void *)&v30[2] == *(void *)&v1002.f64[0])
          {
            *(void *)&v30[12] &= ~2uLL;
            if ((*(unsigned char *)(v7 + 64) & 2) == 0)
            {
              v726 = (uint64_t **)*v8;
              CA::Render::Context::invalidate((CA::Render::Context *)v8[2], v30 + 14, v44);
              CA::Render::Update::invalidate_backdrops((CA::Render::Update *)v726, (const CA::Bounds *)&v30[14], 0, 0xFFFFFFFF);
            }
          }
        }
      }
      uint64_t v727 = v16 | 0x20;
      if ((v16 & 0x3F) == 0) {
        uint64_t v727 = v16;
      }
      *v46 |= (2 * v727) & 0x15480000000 | v727 & 0x407C15581C06020;
      uint64_t v728 = *(void *)(v7 + 48);
      if (v728) {
        *(void *)(v728 + 24) |= *(void *)(v6 + 24) & 0x10481400;
      }
      if (v30)
      {
        int32x2_t v729 = v30[12];
        if (v729.i16[0] < 0) {
          (*v8)[39].i32[0] = (float)((*v8)[25].i32[1] * (*v8)[25].i32[0]);
        }
        if ((*(void *)&v729 & 0x100000000) != 0) {
          CA::shape_union((CA::Shape **)&(*v8)[6], (CA::Shape **)&v30[14], v44);
        }
      }
      return 0;
    }
    uint64_t v61 = v46;
    int64_t v63 = (CA::Shape **)(v31 + 72);
    int64_t v62 = *(const CA::Shape **)(v31 + 72);
    if (!v62)
    {
      CA::Render::Updater::LayerShapes::union_visible_shape(v31, *(CA::Shape ***)(v1001 + 224), v44);
LABEL_1260:
      CA::Render::Update::add_visible_shape(**(CA::Shape ****)&v1003.f64[0], *v60, v167);
      int v46 = v61;
      unint64_t v8 = *(int32x2_t ***)&v1003.f64[0];
      goto LABEL_1261;
    }
    if (!v30 || !*(void *)(v1001 + 232) || (v30[12].i32[0] & 0x78000) == 0)
    {
LABEL_1255:
      int v706 = (CA::Shape **)CA::Shape::subtract((CA::Shape *)v59, v62, (uint64_t)v44, v18);
      if (*v58)
      {
        CA::shape_union(v58, v706, v705);
        uint64_t v707 = *v58;
        if ((*v58 & 1) == 0 && *((int *)v707 + 1) >= 257)
        {
          v1042[0] = 0uLL;
          CA::Shape::get_bounds((uint64_t)v707, (int *)v1042);
          CA::Shape::unref(*v58);
          *double v58 = (CA::Shape *)CA::Shape::new_shape((unsigned int *)v1042);
        }
      }
      CA::Shape::unref((CA::Shape *)v706);
      goto LABEL_1260;
    }
    uint64_t v64 = CA::Shape::intersect(*(void *)(v31 + 72), *(void *)(v1001 + 232));
    uint64_t v65 = (CA::Shape *)v64;
    if (v64)
    {
      if (v64 == 1)
      {
LABEL_1254:
        CA::Shape::unref(v65);
        uint64_t v59 = *v60;
        int64_t v62 = *v63;
        uint64_t v31 = v998;
        goto LABEL_1255;
      }
    }
    else if (*(_DWORD *)(v64 + 4) == 6)
    {
      goto LABEL_1254;
    }
    v700 = (CA::Shape **)CA::Shape::dilate(v64, 1u, 1u);
    CA::Render::Updater::LayerShapes::union_visible_shape(v998, v700, v701);
    CA::shape_union((CA::Shape **)v60, v700, v702);
    CA::shape_subtract(v63, v700, v703, v704);
    CA::Shape::unref((CA::Shape *)v700);
    *(void *)&v30[12] |= 0x40uLL;
    goto LABEL_1254;
  }
  uint64_t v1034 = v6;
  v1035 = *(const CA::Render::Layer **)&v1002.f64[0];
  int8x16_t v1036 = (int8x16_t)(unint64_t)v16;
  unsigned __int8 v1039 = *(unsigned char *)(v7 + 89) & 4;
  uint64_t v33 = *(void *)(v6 + 24);
  v993.n128_u64[0] = v22;
  if ((v33 & 0x40) == 0)
  {
    v16 &= 0xFFFFFFFFFFF87FFFLL;
    v1036.i64[0] = v16;
  }
  *(void *)(v6 + 24) = v33 & 0xFFFFFFFFEFA20BEFLL;
  double v34 = (CA::Render::Context *)*((unsigned int *)v8 + 2);
  double v35 = (CA::Render::Handle *)v8[2];
  *((_DWORD *)v35 + 154) = v34;
  LODWORD(v992.f64[0]) = *(_DWORD *)(v6 + 112);
  unint64_t v36 = (void *)v6;
  unint64_t v37 = v21;
  if (v30)
  {
    if ((v16 & 0x10000000) != 0)
    {
      CA::Render::Update::invalidate_backdrops((CA::Render::Update *)v32, (const CA::Bounds *)&v30[14], *(CA::Render::BackdropState **)(v6 + 256), LODWORD(v992.f64[0]));
      uint64_t v32 = (uint64_t **)*v8;
      double v35 = (CA::Render::Handle *)v8[2];
      double v34 = (CA::Render::Context *)*((unsigned int *)v8 + 2);
    }
    CA::Render::Updater::update_handle((CA::Render::Updater *)v32, v30, v35, v34);
    unint64_t v36 = (void *)v1034;
  }
  uint64_t v38 = (CA::Shape *)v36[27];
  if (v38)
  {
    CA::Shape::unref(v38);
    unint64_t v36 = (void *)v1034;
    *(void *)(v1034 + 216) = 0;
  }
  double v39 = (CA::Shape *)v36[28];
  if (v39)
  {
    CA::Shape::unref(v39);
    unint64_t v36 = (void *)v1034;
    *(void *)(v1034 + 224) = 0;
  }
  BOOL v40 = (CA::Shape *)v36[29];
  if (v40)
  {
    CA::Shape::unref(v40);
    unint64_t v36 = (void *)v1034;
    *(void *)(v1034 + 232) = 0;
  }
  if ((*((_WORD *)v1035 + 19) & 0x110) != 0) {
    v1036.i64[1] |= 0x8000000000uLL;
  }
  uint64_t v991 = v14;
  BOOL is_2d_affine = (CA::Shape *)v36[26];
  if (is_2d_affine)
  {
    CA::Shape::unref(is_2d_affine);
    *(void *)(v1034 + 208) = 0;
  }
  unint64_t v42 = *(void ***)v7;
  v1030 = *(void ***)v7;
  uint64_t v43 = *(CA::Mat4Impl **)(v6 + 56);
  if (v43)
  {
    CA::Transform::set((uint64_t)v1042, v43, 1);
    if ((v1044 & 0x10) == 0)
    {
LABEL_102:
      CA::Transform::concat((uint64_t)v1042, v7 + 8);
      if ((v1044 & 0x10) != 0)
      {
        MEMORY[0x1F4188790](is_2d_affine);
        uint64_t v971 = 0;
        *(_OWORD *)&v977[56] = 0u;
        v969 = &unk_1ED02FC88;
        float64x2_t v972 = v1042[0];
        float64x2_t v973 = v1042[1];
        float64x2_t v974 = v1042[2];
        float64x2_t v975 = v1042[3];
        float64x2_t v976 = v1042[4];
        *(float64x2_t *)v977 = v1042[5];
        *(_OWORD *)&v977[16] = v1043[0];
        *(_OWORD *)&v977[32] = v1043[1];
        *(_OWORD *)&v977[48] = v1043[2];
        v977[64] = v74 & 0x1F;
        BOOL is_2d_affine = (CA::Shape *)CA::Mat4Impl::mat4_is_2d_affine((CA::Mat4Impl *)v1042, v75);
        int32x4_t v72 = 0uLL;
        *(void *)&v977[72] = is_2d_affine;
        v970 = v42;
        v1030 = &v969;
        float64x2_t v1031 = 0uLL;
        __asm { FMOV            V0.2D, #1.0 }
        int32x4_t v1032 = _Q0;
        unsigned __int8 v73 = v1033 & 0xF0;
        v1033 &= 0xF0u;
        unint64_t v42 = &v969;
        unint64_t v8 = *(int32x2_t ***)&v1003.f64[0];
      }
      else
      {
        int32x4_t v72 = (int32x4_t)v1043[0];
        float64x2_t v1031 = (float64x2_t)v1043[0];
        int32x4_t v1032 = (int32x4_t)v1043[2];
        unsigned __int8 v73 = v1033 & 0xF0 | v1044 & 0xF;
        unsigned __int8 v1033 = v73;
      }
      goto LABEL_108;
    }
LABEL_98:
    if (!CA::Mat4Impl::mat4_is_affine((CA::Mat4Impl *)v1042, (const double *)v43)
      && (*((unsigned char *)v1035 + 41) & 4) == 0
      && !CA::Mat4Impl::mat4_is_front_facing((CA::Mat4Impl *)v1042, v71))
    {
      *(void *)(v6 + 24) |= 0x10uLL;
    }
    goto LABEL_102;
  }
  double v66 = *(double *)(v6 + 80);
  if (v66 != 0.0)
  {
    v1042[0] = (float64x2_t)xmmword_184997D50;
    v1042[1] = 0uLL;
    v1042[2] = (float64x2_t)xmmword_184997D60;
    memset(&v1042[3], 0, 32);
    v1042[5] = (float64x2_t)xmmword_184997D50;
    long long v67 = *(_OWORD *)(v6 + 64);
    *((void *)&v1043[1] + 1) = 0x3FF0000000000000;
    v1043[0] = v67;
    *(double *)&v1043[1] = v66;
    __asm { FMOV            V0.2D, #1.0 }
    v1043[2] = _Q0;
    LOBYTE(v1044) = 16;
    goto LABEL_98;
  }
  int32x4_t v1032 = *(int32x4_t *)(v7 + 24);
  float64x2_t v1031 = *(float64x2_t *)(v7 + 8);
  unsigned __int8 v1033 = *(unsigned char *)(v7 + 40);
  unsigned __int8 v73 = v1033;
  double v77 = *(double *)v1032.i64;
  if ((v1033 & 8) == 0) {
    double v77 = 1.0;
  }
  int8x16_t v78 = (int8x16_t)vmulq_n_f64(*(float64x2_t *)(v6 + 64), v77);
  int32x2_t v79 = vdup_n_s32((v1033 & 4) == 0);
  v80.i64[0] = v79.u32[0];
  v80.i64[1] = v79.u32[1];
  int8x16_t v81 = (int8x16_t)vdupq_lane_s64(v78.i64[0], 0);
  *(double *)v81.i64 = -*(double *)&v78.i64[1];
  int8x16_t v82 = vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v80, 0x3FuLL)), v78, v81);
  int32x2_t v83 = vceqz_s32((int32x2_t)vand_s8((int8x8_t)vdup_n_s32(v1033), (int8x8_t)0x100000002));
  v80.i64[0] = v83.i32[0];
  v80.i64[1] = v83.i32[1];
  int32x4_t v72 = (int32x4_t)vaddq_f64((float64x2_t)vbslq_s8((int8x16_t)v80, v82, (int8x16_t)vnegq_f64((float64x2_t)v82)), v1031);
  float64x2_t v1031 = (float64x2_t)v72;
LABEL_108:
  if (v1000.n128_u32[0])
  {
    if ((v73 & 0xF) != 0
      || (int32x2_t v84 = vmovn_s64(vceqzq_f64((float64x2_t)v72)), (v84.i8[0] & 1) == 0)
      || (v84.i8[4] & 1) == 0)
    {
      uint64_t v1044 = 0;
      memset(v1043, 0, sizeof(v1043));
      memset(v1042, 0, sizeof(v1042));
      CA::Transform::set((CA::Transform *)v1042, (uint64_t)&v1031);
      MEMORY[0x1F4188790](v85);
      uint64_t v971 = 0;
      memset(&v977[56], 0, 24);
      v969 = &unk_1ED02FC88;
      float64x2_t v972 = v1042[0];
      float64x2_t v973 = v1042[1];
      float64x2_t v974 = v1042[2];
      float64x2_t v975 = v1042[3];
      int32x4_t v72 = (int32x4_t)v1042[5];
      float64x2_t v976 = v1042[4];
      *(float64x2_t *)v977 = v1042[5];
      *(_OWORD *)&v977[16] = v1043[0];
      *(_OWORD *)&v977[32] = v1043[1];
      *(_OWORD *)&v977[48] = v1043[2];
      v977[64] = v1044 & 0x1F;
      BOOL is_2d_affine = (CA::Shape *)((v1044 & 0x10) == 0 || CA::Mat4Impl::mat4_is_2d_affine((CA::Mat4Impl *)v1042, v86));
      v977[72] = (_BYTE)is_2d_affine;
      v970 = v42;
      v1030 = &v969;
      float64x2_t v1031 = 0uLL;
      __asm { FMOV            V0.2D, #1.0 }
      int32x4_t v1032 = _Q0;
      unsigned __int8 v1033 = v73 & 0xF0;
      unint64_t v8 = *(int32x2_t ***)&v1003.f64[0];
    }
  }
  unint64_t v88 = v1035;
  uint64_t v89 = *((void *)v1035 + 16);
  if (v89)
  {
    uint64_t v90 = *(os_unfair_lock_s **)(v89 + 112);
    if (v90)
    {
      MEMORY[0x1F4188790](is_2d_affine);
      memset(&v977[8], 0, 72);
      os_unfair_lock_lock(v90 + 4);
      CA::Render::MeshTransform::update_locked((CA::Render::MeshTransform *)v90, 1);
      os_unfair_lock_unlock(v90 + 4);
      unint64_t v88 = v1035;
      *(_WORD *)&v977[24] = 0;
      v977[26] = 0;
      int32x4_t v72 = *((int32x4_t *)v1035 + 5);
      *(_OWORD *)&v977[48] = *((_OWORD *)v1035 + 4);
      *(void *)&v977[32] = &v1031;
      *(void *)&v977[40] = v90;
      *(int32x4_t *)&v977[64] = v72;
      *(void *)&v977[8] = &unk_1ED02FDD8;
      *(void *)&v977[16] = v1030;
      v1030 = (void **)&v977[8];
      unint64_t v8 = *(int32x2_t ***)&v1003.f64[0];
    }
  }
  unsigned int v91 = *(unsigned __int8 *)(v7 + 88);
  uint64_t v92 = v1001;
  if (*(unsigned __int8 *)(v1001 + 116) < v91) {
    unsigned int v91 = *(unsigned __int8 *)(v1001 + 116);
  }
  char v1038 = v91;
  v93.i32[1] = 0;
  v93.i64[1] = 0;
  float64x2_t v1008 = 0u;
  long long v1009 = 0u;
  float64x2_t v1007 = 0u;
  v1010 = 0;
  v1014 = (_OWORD *)(v1001 + 160);
  if (v91 - 1 <= 0xFD)
  {
    if ((*((unsigned char *)v88 + 43) & 0x20) == 0) {
      goto LABEL_133;
    }
    if ((*(unsigned char *)(v1001 + 24) & 0x80) != 0) {
      goto LABEL_133;
    }
    uint64_t v94 = (uint64_t **)*v8;
    if (((*v8)[34].i8[0] & 4) != 0) {
      goto LABEL_133;
    }
    double v95 = v94[41];
    if (!v95)
    {
      double v95 = (uint64_t *)x_heap_malloc_small_(*v94, 0x10uLL);
      double v96 = (uint64_t **)*v8;
      if (v95)
      {
        uint64_t v97 = *v96;
        *double v95 = 0;
        v95[1] = (uint64_t)v97;
      }
      v96[41] = v95;
    }
    uint64_t v98 = ((uint64_t (*)(uint64_t *))MEMORY[0x1F4188790])(v95);
    *(void *)&v977[64] = 0;
    *(void *)&v977[72] = 0;
    *(void *)&v977[56] = v98;
    v1010 = (uint64_t *)&v977[56];
  }
  if ((v1036.i8[2] & 0x10) != 0 || v91 != 255 || *(void *)(v92 + 152))
  {
LABEL_133:
    uint64_t v99 = 0;
    goto LABEL_134;
  }
  uint64_t v99 = 1;
LABEL_134:
  BOOL v100 = (CA::Shape **)(((unint64_t)(*v8)[135].u32[1] >> 22) & 1);
  uint64_t v1011 = v99;
  int64_t v1012 = (int64_t)v100;
  uint64_t v1013 = (uint64_t)v100;
  if (v999)
  {
    int v101 = DWORD2(v997);
    if (SDWORD2(v997) <= SHIDWORD(v997)) {
      int v101 = HIDWORD(v997);
    }
    v93.i32[0] = 1073741822;
    v72.i32[0] = v101;
    v102.i64[0] = (int)v997;
    v102.i64[1] = SDWORD1(v997);
    int8x16_t v103 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v72, v93), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v102));
    v102.i64[0] = SDWORD2(v997);
    v102.i64[1] = SHIDWORD(v997);
    int32x2_t v104 = vdup_n_s32(v101 > 1073741822);
    int8x16_t v105 = (int8x16_t)vcvtq_f64_s64(v102);
    v102.i64[0] = v104.u32[0];
    v102.i64[1] = v104.u32[1];
    v1042[0] = (float64x2_t)v103;
    v1042[1] = (float64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v102, 0x3FuLL)), (int8x16_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL), v105);
    CA::Rect::apply_transform(v1042[0].f64, (uint64_t)&v1031);
    CA::Render::Updater::LayerShapes::union_bounds((__n128 *)&v1007, v1042, (const CA::Bounds *)1);
  }
  if (v30 && (int v106 = (CA::Render::Context *)v30[3]) != 0 && (*((_WORD *)v106 + 276) & 0x10) != 0)
  {
    uint64_t v125 = CA::Render::Context::root_layer_handle(v106);
    if (v125) {
      uint64_t v126 = *(void *)(v125 + 16);
    }
    else {
      uint64_t v126 = 0;
    }
    CA::Render::Updater::prepare_layer_mask((uint64_t)v8, (uint64_t)&v1030, v31, (uint64_t)&v1007);
    if (v126 == *(void *)&v1002.f64[0])
    {
      __n128 v987 = v1016;
      float64x2_t v988 = v1015;
      float64x2_t v1015 = (float64x2_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
      __n128 v1016 = (__n128)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      v996.i32[0] = 1;
      goto LABEL_143;
    }
  }
  else
  {
    CA::Render::Updater::prepare_layer_mask((uint64_t)v8, (uint64_t)&v1030, v31, (uint64_t)&v1007);
  }
  v996.i32[0] = 0;
  __n128 v987 = 0u;
  float64x2_t v988 = 0u;
LABEL_143:
  float64x2_t v1005 = 0u;
  float64x2_t v1006 = 0u;
  if ((*(unsigned char *)(v92 + 27) & 2) == 0
    && (uint64_t v110 = *((void *)v1035 + 12)) != 0
    && (CA::Render::Updater::prepare_layer_contents(v8, (uint64_t)&v1030, *((void *)v1035 + 12), (uint64_t)&v1007),
        *(unsigned char *)(v110 + 12) == 25))
  {
    float64x2_t v1005 = v1007;
    float64x2_t v1006 = v1008;
    uint64_t v107 = (uint64_t)CA::Render::Updater::apply_shapes_ops(v1030, (CA::Render::Updater::LayerShapesOp *)&v1005, v108);
    LODWORD(v990.f64[0]) = 0;
  }
  else
  {
    LODWORD(v990.f64[0]) = 1;
  }
  *(void *)&v989.f64[0] = &v1013;
  uint64_t v111 = (uint64_t)v1035;
  uint64_t v112 = *((void *)v1035 + 16);
  if (v112) {
    uint64_t v113 = *(void *)(v112 + 80);
  }
  else {
    uint64_t v113 = 0;
  }
  float v114 = *((float *)v1035 + 7);
  BOOL v115 = *((float *)v1035 + 4) == 0.0;
  if (*((float *)v1035 + 5) != 0.0) {
    BOOL v115 = 0;
  }
  if (*((float *)v1035 + 6) != 0.0) {
    BOOL v115 = 0;
  }
  if (v115)
  {
    BOOL v116 = v113 == 0;
    if (v114 == 0.0 && !v113)
    {
      if (!v112)
      {
LABEL_265:
        int v133 = (int)v999;
        goto LABEL_266;
      }
      unsigned int v117 = 0;
      int v118 = 0;
      int v119 = 1;
      goto LABEL_173;
    }
  }
  else
  {
    BOOL v116 = v113 == 0;
  }
  int v118 = v114 == 1.0;
  if (v114 == 1.0 && !v116)
  {
    uint64_t v120 = *(void *)(v113 + 128);
    int v118 = v120
        && (*(unsigned char *)(v120 + 13) & 0x10) != 0
        && *(double *)(v113 + 96) <= *(double *)(v113 + 80)
        && *(double *)(v113 + 104) <= *(double *)(v113 + 88);
  }
  int v119 = v114 == 1.0 && v115;
  if (!v112)
  {
    float64x2_t v124 = *((float64x2_t *)v1035 + 5);
    v1042[0] = *((float64x2_t *)v1035 + 4);
    v1042[1] = v124;
    unsigned int v117 = 1;
    goto LABEL_218;
  }
  unsigned int v117 = 1;
LABEL_173:
  if (*(float *)(v112 + 236) <= 0.0)
  {
LABEL_179:
    int v123 = 0;
    goto LABEL_186;
  }
  BOOL v121 = 0;
  if (*(float *)(v112 + 240) == 0.0 && *(float *)(v112 + 244) == 0.0 && *(float *)(v112 + 248) == 0.0)
  {
    float v122 = *(float *)(v112 + 252);
    if (v122 == 0.0 && !*(void *)(v112 + 128)) {
      goto LABEL_179;
    }
    BOOL v121 = v122 == 1.0;
  }
  ++v117;
  v119 &= v121;
  int v123 = 1;
LABEL_186:
  uint32_t v127 = *(unsigned __int8 **)v112;
  if (!*(void *)v112) {
    goto LABEL_212;
  }
  LOBYTE(v1042[0].f64[0]) = 0;
  uint64_t v107 = (*(uint64_t (**)(unsigned __int8 *))(*(void *)v127 + 160))(v127);
  v119 &= ~v107;
  if (LOBYTE(v1042[0].f64[0])) {
    int v128 = v107;
  }
  else {
    int v128 = 0;
  }
  v118 |= v128;
  v117 += v107;
  unsigned int v129 = v127[12];
  if (v129 <= 7)
  {
    if (v129 == 3)
    {
      int v132 = (uint64_t *)*((void *)v1035 + 16);
      if (v132)
      {
        int v132 = (uint64_t *)*v132;
        if (v132)
        {
          if (*((unsigned char *)v132 + 12) != 3) {
            int v132 = 0;
          }
        }
      }
      if ((*((unsigned char *)v132 + 13) & 5) == 0) {
        goto LABEL_211;
      }
      v1039 |= 8u;
      unsigned __int8 v130 = *((unsigned char *)v132 + 13) & 0x10 | v1039 & 0xEF;
      goto LABEL_210;
    }
    if (v129 == 6)
    {
      unsigned __int8 v130 = v1039 | 0x20;
LABEL_210:
      unsigned __int8 v1039 = v130;
    }
  }
  else if (v129 == 8)
  {
    (*v8)[136].i16[0] |= 0x200u;
    v1039 |= 2u;
    v1036.i64[1] |= 4uLL;
    *(void *)(v1034 + 24) |= 0x1000uLL;
  }
  else
  {
    if (v129 != 19)
    {
      if (v129 == 45)
      {
        v1039 |= 0x42u;
        *(void *)(v1034 + 24) |= 0x1000uLL;
      }
      goto LABEL_211;
    }
    unsigned __int8 v131 = v1039 & 0x7F | ((*(unsigned char *)(**((void **)v1035 + 16) + 16) != 0) << 7);
    unsigned __int8 v1039 = v131;
    if ((*v8)[50].i8[7])
    {
      unsigned __int8 v130 = v131 | 2;
      goto LABEL_210;
    }
  }
LABEL_211:
  uint64_t v111 = (uint64_t)v1035;
LABEL_212:
  int v133 = (int)v999;
  if (v117)
  {
    float64x2_t v134 = *(float64x2_t *)(v111 + 80);
    v1042[0] = *(float64x2_t *)(v111 + 64);
    v1042[1] = v134;
    if (v123)
    {
      uint64_t v135 = *(void *)(v111 + 128);
      if (v135)
      {
        float v136 = *(float *)(v135 + 232);
        if (v136 > 0.0)
        {
          CA::BoundsImpl::inset(v1042[0].f64, -v136, -v136);
          int v118 = 0;
        }
      }
      CA::Rect::apply_transform(v1042[0].f64, (uint64_t)&v1031);
      goto LABEL_228;
    }
LABEL_218:
    CA::Rect::apply_transform(v1042[0].f64, (uint64_t)&v1031);
    if (v1011)
    {
      if (v1011)
      {
        if (v1011 == 1) {
          goto LABEL_228;
        }
      }
      else if (*(_DWORD *)(v1011 + 4) == 6)
      {
        goto LABEL_228;
      }
      int64x2_t v137 = vceqzq_f64(v1042[1]);
      if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v137, 1), (int8x16_t)v137).u64[0] & 0x8000000000000000) != 0
        || (int8x16_t v138 = vorrq_s8((int8x16_t)vcltzq_f64(v1042[1]), (int8x16_t)vcgezq_f64(v1042[1])),
            (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v138), 1), v138).u64[0] & 0x8000000000000000) != 0))
      {
        float64x2_t v1024 = 0uLL;
      }
      else
      {
        int32x4_t v139 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v1042[0], (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
        float64x2_t v1024 = (float64x2_t)vuzp1q_s32(v139, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v1042[0], v1042[1]), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v139));
      }
      uint64_t v107 = CA::Shape::contains(v1011, (const CA::Bounds *)&v1024);
      if (v107)
      {
LABEL_264:
        uint64_t v111 = (uint64_t)v1035;
        goto LABEL_265;
      }
    }
LABEL_228:
    uint64_t v140 = 549453824;
    if (v119) {
      uint64_t v140 = 0x800000;
    }
    v1036.i64[1] |= v140;
    if (v117 >= 2)
    {
      int v141 = v1010;
      if (v1010)
      {
        *((unsigned char *)v1010 + 16) = 1;
        int v142 = (void *)v141[1];
        if (v142)
        {
          CA::GenericRectTree<CA::Rect>::Pool::delete_node(*v141, v142);
          v141[1] = 0;
        }
      }
    }
    if (v1012)
    {
      if (v1012) {
        BOOL v143 = v1012 == 1;
      }
      else {
        BOOL v143 = *(_DWORD *)(v1012 + 4) == 6;
      }
      char v145 = v143;
      char v144 = v145 ^ 1;
    }
    else
    {
      char v144 = 0;
    }
    uint64_t v107 = CA::Render::Updater::LayerShapes::union_bounds((__n128 *)&v1007, v1042, (const CA::Bounds *)(v1038 != 0));
    if (v1011) {
      int v146 = v118;
    }
    else {
      int v146 = 0;
    }
    if (v146 == 1)
    {
      uint64_t v147 = *((void *)v1035 + 16);
      if (v147 && (*(float *)(v147 + 228) > 0.0 || *(void *)(v147 + 72)))
      {
        CA::Render::Updater::corner_clipped_layer_bounds(v1024.f64, v1035);
        v1042[0] = v1024;
        v1042[1] = v1025;
        CA::Rect::apply_transform(v1042[0].f64, (uint64_t)&v1031);
      }
      CA::Render::Updater::union_opaque_rect((uint64_t)v8, (uint64_t)&v1007, v108, v1042[0], v1042[1]);
      if (v1013) {
        int v149 = v119;
      }
      else {
        int v149 = 0;
      }
      if (v149 == 1)
      {
        v148.n128_f64[0] = v1042[1].f64[1] * v1042[1].f64[0];
        char v150 = v1042[1].f64[1] * v1042[1].f64[0] <= 4096.0 ? 1 : v144;
        if ((v150 & 1) == 0)
        {
          uint64_t v151 = *((void *)v1035 + 16);
          if (!v151 || !*(void *)(v151 + 96))
          {
            for (uint64_t i = v1030; i; uint64_t i = (void **)i[1])
              (*((void (**)(void **, float64x2_t *, __n128))*i + 5))(i, v1042, v148);
            CA::BoundsImpl::intersect((uint64_t)v1042, v1015, (float64x2_t)v1016);
            float64x2_t v1024 = 0uLL;
            CA::Bounds::set_interior((int32x4_t *)&v1024, v153, v1042[0], v1042[1]);
            CA::shape_union(*(CA::Shape ***)&v989.f64[0], (CA::Shape **)&v1024, v154);
          }
        }
      }
    }
    goto LABEL_264;
  }
LABEL_266:
  int v155 = *(uint64_t **)(v111 + 128);
  if (!v155 || (uint64_t v156 = *v155) == 0)
  {
    char v160 = 0;
    goto LABEL_302;
  }
  if (v1010)
  {
    if (!*((unsigned char *)v1010 + 16))
    {
      if ((*(unsigned int (**)(uint64_t))(*(void *)v156 + 208))(v156))
      {
        uint64_t v157 = v1010;
        *((unsigned char *)v1010 + 16) = 1;
        int v158 = (void *)v157[1];
        if (v158)
        {
          CA::GenericRectTree<CA::Rect>::Pool::delete_node(*v157, v158);
          v157[1] = 0;
        }
      }
    }
  }
  memset(v1042, 0, 48);
  int v159 = (*(uint64_t (**)(uint64_t))(*(void *)v156 + 176))(v156);
  char v160 = v159;
  if (!v159)
  {
    float64x2_t v1024 = 0u;
    float64x2_t v1025 = 0u;
    memset(v1040, 0, sizeof(v1040));
    if (!(*(unsigned int (**)(uint64_t, const CA::Render::Layer *, float64x2_t *, int8x16_t *))(*(void *)v156 + 184))(v156, v1035, &v1024, v1040))goto LABEL_299; {
    uint64_t v165 = (const CA::Bounds *)(*(uint64_t (**)(uint64_t))(*(void *)v156 + 200))(v156);
    }
    CA::Rect::apply_transform(v1024.f64, (uint64_t)&v1031);
    CA::Render::Updater::LayerShapes::union_bounds((__n128 *)&v1007, &v1024, v165);
    if (*(double *)v1040[1].i64 != 0.0 && v1011)
    {
      CA::Rect::apply_transform((double *)v1040[0].i64, (uint64_t)&v1031);
      CA::Render::Updater::union_opaque_rect((uint64_t)v8, (uint64_t)&v1007, v166, (float64x2_t)v1040[0], (float64x2_t)v1040[1]);
    }
    if (!v165) {
      goto LABEL_299;
    }
    goto LABEL_298;
  }
  if ((*(unsigned int (**)(uint64_t, const CA::Render::Layer *, float64x2_t *))(*(void *)v156 + 192))(v156, v1035, v1042))
  {
    float64x2_t v1024 = v1042[0];
    float64x2_t v1025 = vsubq_f64(*(float64x2_t *)((char *)&v1042[1] + 8), v1042[0]);
    CA::Rect::apply_transform(v1024.f64, (uint64_t)&v1031);
    float64x2_t v162 = v1024;
    int64x2_t v161 = (int64x2_t)v1025;
    v1042[0] = v1024;
    *(float64x2_t *)((char *)&v1042[1] + 8) = vaddq_f64(v1025, v1024);
    float64x2_t v1024 = 0u;
    float64x2_t v1025 = 0u;
    double v163 = *(double *)&v161.i64[1];
    if (*(double *)v161.i64 >= *(double *)&v161.i64[1]) {
      double v164 = *(double *)&v161.i64[1];
    }
    else {
      double v164 = *(double *)v161.i64;
    }
    if (v164 > 0.0)
    {
      if (*(double *)v161.i64 > *(double *)&v161.i64[1]) {
        double v163 = *(double *)v161.i64;
      }
      if (v163 >= 1.79769313e308)
      {
        float64x2_t v1024 = (float64x2_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
        int64x2_t v161 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
      }
      else
      {
        float64x2_t v1024 = v162;
      }
      float64x2_t v1025 = (float64x2_t)v161;
    }
    CA::Render::Updater::LayerShapes::union_bounds((__n128 *)&v1007, &v1024, (const CA::Bounds *)1);
    if (*(double *)&v1009 > v1042[1].f64[0]) {
      *(float64_t *)&long long v1009 = v1042[1].f64[0];
    }
    if (*((double *)&v1009 + 1) < v1042[2].f64[1]) {
      *((void *)&v1009 + 1) = *(void *)&v1042[2].f64[1];
    }
LABEL_298:
    v1036.i64[1] |= 0x20C00000uLL;
  }
LABEL_299:
  uint64_t v107 = (*(uint64_t (**)(uint64_t, const CA::Render::Layer *))(*(void *)v156 + 168))(v156, v1035);
  if (v107) {
    v1036.i64[1] |= 0x800000000uLL;
  }
  int v133 = (int)v999;
LABEL_302:
  if (v993.n128_u64[0]) {
    int v168 = v133;
  }
  else {
    int v168 = 0;
  }
  if (v168 == 1) {
    *(void *)(v7 + 72) |= (unint64_t)(v993.n128_u8[0] & 7) << 47;
  }
  uint64_t v169 = v1035;
  if (*((unsigned char *)v1035 + 33))
  {
    uint64_t v170 = *((void *)v1035 + 16);
    if (v170) {
      float32x4_t v171 = *(float32x4_t *)(v170 + 200);
    }
    else {
      float32x4_t v171 = (float32x4_t)xmmword_184997DF0;
    }
    if (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqzq_f32(v171)))))
    {
      uint64_t v172 = *((void *)v1035 + 5);
      if ((v172 & 0x200000000) != 0)
      {
        BOOL v174 = (float64x2_t *)&CA::RectTraits<double>::infinity;
        goto LABEL_329;
      }
      if ((v172 & 0x400000000) != 0)
      {
        int v173 = (float64x2_t *)((char *)v1035 + 64);
        goto LABEL_319;
      }
      if (v170)
      {
        uint64_t v107 = *(void *)(v170 + 120);
        if (v107)
        {
          int v173 = (float64x2_t *)CA::Render::Path::bounding_rect((CA::Render::Path *)v107);
          uint64_t v169 = v1035;
          uint64_t v170 = *((void *)v1035 + 16);
LABEL_319:
          float64x2_t v175 = v173[1];
          v1042[0] = *v173;
          v1042[1] = v175;
          if (v170) {
            float v176 = *(float *)(v170 + 224);
          }
          else {
            float v176 = 3.0;
          }
          CA::BoundsImpl::inset(v1042[0].f64, (float)(v176 * -2.8), (float)(v176 * -2.8));
          int v177 = (float32x2_t *)*((void *)v169 + 16);
          if (v177) {
            float32x2_t v178 = v177[27];
          }
          else {
            float32x2_t v178 = (float32x2_t)0xC040000000000000;
          }
          v1042[0] = vaddq_f64(v1042[0], vcvtq_f64_f32(v178));
          CA::Rect::apply_transform(v1042[0].f64, (uint64_t)&v1031);
          uint64_t v180 = *((void *)v169 + 16);
          if (v180)
          {
            uint64_t v181 = *(void *)(v180 + 96);
            if (v181)
            {
              if (*(_DWORD *)(v181 + 16))
              {
                MEMORY[0x1F4188790](v179);
                *(float64x2_t *)&v977[48] = v1042[0];
                *(float64x2_t *)&v977[64] = v1042[1];
                *(void *)&v977[24] = &unk_1ED02FCF8;
                *(void *)&v977[32] = v1030;
                *(void *)&v977[40] = 0;
                v1030 = (void **)&v977[24];
                goto LABEL_330;
              }
            }
          }
          BOOL v174 = v1042;
LABEL_329:
          uint64_t v107 = CA::Render::Updater::LayerShapes::union_bounds((__n128 *)&v1007, v174, (const CA::Bounds *)1);
LABEL_330:
          v1036.i64[1] |= 0x20C00000uLL;
        }
      }
    }
  }
  uint64_t v182 = v1035;
  int v183 = (float32x4_t *)*((void *)v1035 + 16);
  if (v183
    && v183[20].f32[0] != 0.0
    && (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqzq_f32(v183[19])))) & 1) != 0
    && (*((unsigned char *)v1035 + 44) & 0x10) != 0)
  {
    float64x2_t v184 = *((float64x2_t *)v1035 + 5);
    v1042[0] = *((float64x2_t *)v1035 + 4);
    v1042[1] = v184;
    CA::BoundsImpl::inset(v1042[0].f64, (float)-v183[18].f32[3], (float)-v183[18].f32[3]);
    CA::Rect::apply_transform(v1042[0].f64, (uint64_t)&v1031);
    uint64_t v186 = v183[6].i64[0];
    if (v186 && *(_DWORD *)(v186 + 16))
    {
      MEMORY[0x1F4188790](v185);
      *(float64x2_t *)&v977[48] = v1042[0];
      *(float64x2_t *)&v977[64] = v1042[1];
      *(void *)&v977[24] = &unk_1ED02FCF8;
      *(void *)&v977[32] = v1030;
      *(void *)&v977[40] = 0;
      v1030 = (void **)&v977[24];
    }
    else
    {
      uint64_t v107 = CA::Render::Updater::LayerShapes::union_bounds((__n128 *)&v1007, v1042, (const CA::Bounds *)1);
      uint64_t v182 = v1035;
    }
    v1036.i64[1] |= 0x20C00000uLL;
  }
  int v187 = v1030;
  *(void *)&long long v997 = v30;
  v994 = v37;
  if ((v160 & 1) == 0)
  {
    unint64_t v199 = *((void *)v182 + 5);
    if ((v199 & 0xC0000) != 0)
    {
      unsigned int v200 = v1032.i32[0];
      *(void *)&v1042[0].f64[0] = v1032.i64[0];
      *(void *)&v1042[0].f64[1] = v1032.i64[0];
      if (v1030)
      {
        int v201 = v1030;
        do
        {
          uint64_t v107 = (*((uint64_t (**)(void **, float64x2_t *))*v201 + 6))(v201, v1042);
          int v201 = (void **)v201[1];
        }
        while (v201);
        uint64_t v182 = v1035;
      }
      uint64_t v202 = *((void *)v182 + 16);
      if (v202)
      {
        float v203 = *(float *)(v202 + 288);
      }
      else
      {
        LOBYTE(v200) = *((unsigned char *)v182 + 35);
        float v203 = (float)v200;
      }
      double v242 = v1042[0].f64[0];
      if (v1042[0].f64[0] <= v1042[0].f64[1]) {
        double v242 = v1042[0].f64[1];
      }
      float v243 = v242 / v203;
      if (fabsf(v243 + -1.0) > 0.001)
      {
        uint64_t v107 = ((uint64_t (*)(uint64_t))MEMORY[0x1F4188790])(v107);
        *(_DWORD *)&v977[72] = 0;
        *(_DWORD *)&v977[76] = (int)(float)(v244 + 1.0);
        *(void *)&v977[56] = &unk_1ED02FD68;
        *(void *)&v977[64] = v1030;
        v1030 = (void **)&v977[56];
      }
      v1039 |= 4u;
      unint64_t v199 = *((void *)v182 + 5);
    }
    if ((v199 & 0x800000) != 0)
    {
      uint64_t v188 = v998;
      if (!((v199 >> 18) & 1 | v1000.n128_u8[0] & 1)) {
        goto LABEL_437;
      }
    }
    else
    {
      uint64_t v188 = v998;
      if (!v1000.n128_u32[0])
      {
LABEL_437:
        uint64_t v245 = *((void *)v182 + 16);
        if (*((unsigned char *)v182 + 33))
        {
          if (!v245)
          {
            if ((*((unsigned char *)v182 + 44) & 4) != 0) {
              goto LABEL_341;
            }
            goto LABEL_451;
          }
          if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqzq_f32(*(float32x4_t *)(v245 + 200))))) & 1) != 0
            && !*(void *)(v245 + 120))
          {
            BOOL v246 = (*((unsigned char *)v182 + 44) & 4) == 0;
LABEL_444:
            BOOL v247 = *(float *)(v245 + 320) != 0.0
                && (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqzq_f32(*(float32x4_t *)(v245 + 304))))) & 1) != 0
                && (*((unsigned char *)v182 + 44) & 0x10) == 0;
            if (!v246 && !v247)
            {
LABEL_452:
              uint64_t v252 = *(void *)(v245 + 96);
              if (!v252) {
                goto LABEL_341;
              }
              uint64_t v253 = *(unsigned int *)(v252 + 16);
              if (!v253) {
                goto LABEL_341;
              }
              while (1)
              {
                uint64_t v254 = *(void *)(v252 + 8 * (v253 - 1) + 24);
                int v255 = *(_DWORD *)(v254 + 12);
                if ((v255 & 0x40100) == 0x100
                  && ((v255 & 0x20000) == 0 || *(void *)(v1034 + 88) || ((*v8)[135].i32[1] & 0x4000) == 0))
                {
                  break;
                }
LABEL_464:
                if (!--v253)
                {
                  uint64_t v182 = v1035;
                  goto LABEL_340;
                }
              }
              MEMORY[0x1F4188790](v107);
              *(_OWORD *)&v977[64] = 0u;
              *(_OWORD *)&v977[32] = 0u;
              *(void *)&v977[24] = &unk_1ED02FE40;
              BOOL v108 = v1035;
              *(void *)&v977[48] = &v1031;
              *(void *)&v977[56] = v1035;
              *(void *)&v977[64] = v254;
              uint64_t v107 = *(void *)(v254 + 48);
              if (v107
                && (uint64_t v107 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v107 + 8))(v107, v254),
                    !v107))
              {
                if (*(void *)&v977[64])
                {
LABEL_462:
                  *(void *)&v977[32] = v1030;
                  v1030 = (void **)&v977[24];
                  unint64_t v8 = *(int32x2_t ***)&v1003.f64[0];
                  if ((*(unsigned char *)(v7 + 64) & 8) != 0) {
                    *(_DWORD *)(v254 + 20) = *(_DWORD *)(*(void *)&v1003.f64[0] + 8);
                  }
                  goto LABEL_464;
                }
              }
              else
              {
                *(void *)&v977[64] = 0;
              }
              v977[42] = 1;
              goto LABEL_462;
            }
LABEL_451:
            double v248 = MEMORY[0x1F4188790](v107);
            *(void *)&v977[56] = 0;
            *(void *)&v977[64] = &v1031;
            *(float *)&v977[72] = v249 * 2.8;
            *(double *)&v977[76] = v248;
            *(_DWORD *)&v977[84] = v250;
            *(void *)&v977[40] = &unk_1ED02FEB0;
            *(void *)&v977[48] = v1030;
            v1030 = (void **)&v977[40];
            v1036.i64[1] |= 0x20C00000uLL;
            if (v251) {
              goto LABEL_341;
            }
            goto LABEL_452;
          }
        }
        else if (!v245)
        {
          goto LABEL_341;
        }
        BOOL v246 = 0;
        goto LABEL_444;
      }
    }
    *(void *)(v1034 + 24) |= 0x1000uLL;
    goto LABEL_437;
  }
LABEL_340:
  uint64_t v188 = v998;
LABEL_341:
  uint64_t v189 = v1034;
  uint64_t v190 = *(void *)(v1034 + 24);
  if ((*((unsigned char *)v182 + 44) & 0x80) != 0)
  {
    v190 |= 0x400000uLL;
    *(void *)(v1034 + 24) = v190;
  }
  if ((v190 & 0x10) == 0 && !*(void *)(v1001 + 120) && !v1038)
  {
    uint64_t v191 = *((void *)v182 + 16);
    if (!v191) {
      goto LABEL_358;
    }
    uint64_t v192 = *(void *)(v191 + 104);
    if (v192)
    {
      unint64_t v193 = *(unsigned int *)(v192 + 16);
      if (v193)
      {
        if (*(unsigned char *)(*(void *)(v192 + 24) + 13)) {
          goto LABEL_359;
        }
        unint64_t v194 = 0;
        uint64_t v195 = v192 + 32;
        while (v193 - 1 != v194)
        {
          uint64_t v196 = *(void *)(v195 + 8 * v194++);
          if (*(unsigned char *)(v196 + 13))
          {
            if (v194 < v193) {
              goto LABEL_359;
            }
            break;
          }
        }
      }
    }
    uint64_t v197 = *(void *)(v191 + 88);
    if (!v197
      || (*(unsigned char *)(v197 + 13) & 1) == 0
      || (*((unsigned char *)v182 + 41) & 1) != 0
      || (uint64_t v107 = CA::Render::Filter::compositing_dod((CA::Render::Filter *)*(unsigned int *)(v197 + 24)),
          (v107 - 5) >= 0xFFFFFFFE))
    {
LABEL_358:
      v190 |= 0x10uLL;
      *(void *)(v189 + 24) = v190;
    }
  }
LABEL_359:
  if ((v190 & 0x10) != 0)
  {
    int32x4_t v1017 = 0u;
    __n128 v1016 = 0u;
    float64x2_t v1015 = 0u;
  }
  else if (((*v8)[135].i32[1] & 4) != 0)
  {
    double v198 = v1016.n128_f64[0];
    if (v1016.n128_f64[0] >= v1016.n128_f64[1]) {
      double v198 = v1016.n128_f64[1];
    }
    if (v198 <= 0.0 && (v1039 & 4) == 0) {
      *(void *)(v189 + 24) = v190 | 0x10;
    }
  }
  for (j = v1030; j != v187; j = (void **)j[1])
    uint64_t v107 = (*((uint64_t (**)(void **, float64x2_t *, void))*j + 3))(j, &v1007, (v1039 >> 2) & 1);
  if (v1008.f64[0] == 0.0)
  {
    uint64_t v229 = v1034;
    *(void *)(v1034 + 160) = 0;
    *(void *)(v229 + 168) = 0;
    if (!v187) {
      goto LABEL_383;
    }
    goto LABEL_382;
  }
  v1042[0] = v1007;
  v1042[1] = v1008;
  CA::Rect::unapply_transform(v1042[0].f64, (uint64_t)&v1031);
  int64x2_t v205 = vceqzq_f64(v1042[1]);
  unint64_t v206 = vorrq_s8((int8x16_t)vdupq_laneq_s64(v205, 1), (int8x16_t)v205).u64[0];
  int32x4_t v207 = 0uLL;
  if ((v206 & 0x8000000000000000) == 0)
  {
    int8x16_t v208 = vorrq_s8((int8x16_t)vcltzq_f64(v1042[1]), (int8x16_t)vcgezq_f64(v1042[1]));
    if ((vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v208), 1), v208).u64[0] & 0x8000000000000000) == 0)
    {
      int32x4_t v209 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v1042[0], (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
      int32x4_t v207 = vuzp1q_s32(v209, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v1042[0], v1042[1]), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v209));
    }
  }
  for (*(int32x4_t *)(v1034 + 160) = v207; v187; int v187 = (void **)v187[1])
LABEL_382:
    uint64_t v107 = (*((uint64_t (**)(void **, float64x2_t *, void))*v187 + 3))(v187, &v1007, (v1039 >> 2) & 1);
LABEL_383:
  unint64_t v210 = &v1030;
  unint64_t v211 = v1030;
  if (!v1030 || !*((unsigned char *)v1030 + 17))
  {
    MEMORY[0x1F4188790](v107);
    *(void *)&v977[64] = v211;
    *(void *)&v977[72] = 65792;
    *(void *)&v977[56] = &unk_1ED02FC20;
    v1030 = (void **)&v977[56];
    unint64_t v211 = (void **)&v977[56];
  }
  char v212 = (char)v999;
  uint64_t v213 = v210 + 9;
  v999 = (CA::Shape **)&v1012;
  float64x2_t v214 = v1007;
  float64x2_t v215 = v1008;
  int64x2_t v216 = vceqzq_f64(v1008);
  int32x4_t v217 = (int32x4_t)vdupq_laneq_s64(v216, 1);
  unint64_t v218 = vorrq_s8((int8x16_t)v217, (int8x16_t)v216).u64[0];
  __n128 v219 = 0uLL;
  if ((v218 & 0x8000000000000000) == 0)
  {
    int8x16_t v220 = vorrq_s8((int8x16_t)vcltzq_f64(v1008), (int8x16_t)vcgezq_f64(v1008));
    int32x4_t v217 = (int32x4_t)vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v220), 1), v220);
    if ((v217.i64[0] & 0x8000000000000000) == 0)
    {
      int32x4_t v221 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v1007, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
      int32x4_t v217 = (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v1007, v1008), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v221);
      __n128 v219 = (__n128)vuzp1q_s32(v221, v217);
    }
  }
  *(__n128 *)(v1001 + 192) = v219;
  uint64_t v222 = v1034 + 96;
  uint64_t v223 = *(void *)(v1034 + 104);
  if (v223 == v1034 + 96) {
    char v212 = 1;
  }
  if (v212)
  {
    unsigned __int8 v224 = (int32x2_t *)v997;
    uint64_t v225 = v1001;
    float64_t v226 = v1002.f64[0];
    if (v1012)
    {
      uint64_t v111 = v1013;
      if (v1013) {
        CA::shape_subtract(v999, (CA::Shape **)v1013, v108, v109);
      }
    }
    goto LABEL_491;
  }
  int v227 = (CA::Shape **)v1013;
  v1040[0].i64[0] = v1012;
  __int32 v228 = (*v8)[135].i32[1];
  if ((v228 & 0x400000) != 0)
  {
    int64_t v1012 = 1;
    uint64_t v1013 = 1;
  }
  if ((v228 & 4) != 0 && (*(unsigned char *)(v1034 + 24) & 0x18) != 0)
  {
    unsigned __int8 v224 = (int32x2_t *)v997;
    uint64_t v225 = v1001;
    float64_t v226 = v1002.f64[0];
    if ((*(void *)&v228 & 0x400000) == 0) {
      goto LABEL_491;
    }
    goto LABEL_486;
  }
  v1024.f64[0] = 0.0;
  uint64_t v986 = v7;
  *(void *)&long long v985 = v227;
  int32x4_t v982 = (int32x4_t)v215;
  int32x4_t v983 = (int32x4_t)v214;
  if (!v1011 || (v1036.i8[2] & 0x10) != 0)
  {
    uint64_t v984 = 0;
  }
  else
  {
    uint64_t v984 = v1011;
    *(void *)&v1024.f64[0] = v1011;
    uint64_t v1011 = 1;
  }
  char v230 = 0;
  __int32 v231 = v1036.i32[2];
  v1036.i64[1] &= 0xFFFFFFFFFE3FFFFFLL;
  __n128 v993 = (__n128)vdupq_n_s64(0x100000uLL);
  char v232 = 1;
  float64_t v233 = v1003.f64[0];
  do
  {
    uint64_t v234 = v223;
    uint64_t v223 = *(void *)(v223 + 8);
    CA::Render::Updater::prepare_layer(*(void *)&v233, &v1030, v234, &v1007, v213);
    if (*(unsigned char *)(*(void *)&v233 + 12) && (v1036.i32[0] & 0x20000) != 0) {
      v1036.i64[0] |= 8uLL;
    }
    v230 |= (*(void *)&v1037 & 0x28000) != 0;
    if ((v230 & 1) == 0) {
      v232 &= (v1037 & 0x800000) == 0;
    }
    if (v1011 && !(v1036.i64[0] & 0x100000 | v1011 & 1) && *(int *)(v1011 + 4) >= 65)
    {
      CA::Shape::unref((CA::Shape *)v1011);
      uint64_t v1011 = 1;
      int32x4_t v217 = (int32x4_t)v993;
      __n128 v219 = (__n128)vorrq_s8(v1036, (int8x16_t)v993);
      int8x16_t v1036 = (int8x16_t)v219;
    }
  }
  while (v223 != v222);
  uint64_t v235 = v231 & 0x1C00000;
  uint64_t v236 = v1030;
  if (v1030 != v211)
  {
    do
    {
      int32x2_t v237 = (void **)v236[1];
      (*(void (**)(void **))*v236)(v236);
      uint64_t v236 = v237;
    }
    while (v237 != v211);
  }
  v1030 = v211;
  uint64_t v238 = v1036.i64[1];
  uint64_t v7 = v986;
  unint64_t v8 = *(int32x2_t ***)&v1003.f64[0];
  float64_t v226 = v1002.f64[0];
  if ((v235 & ~v1036.i64[1]) == 0)
  {
    uint64_t v241 = v984;
    goto LABEL_479;
  }
  float64x2_t v239 = (float64x2_t)v982;
  float64x2_t v240 = (float64x2_t)v983;
  uint64_t v241 = v984;
  if (!v1011) {
    goto LABEL_478;
  }
  if (v1011)
  {
    if (v1011 == 1)
    {
LABEL_478:
      v238 |= v235;
      v1036.i64[1] = v238;
      goto LABEL_479;
    }
  }
  else if (*(_DWORD *)(v1011 + 4) == 6)
  {
    goto LABEL_478;
  }
  int64x2_t v256 = vclezq_f64((float64x2_t)v982);
  if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v256, 1), (int8x16_t)v256).u64[0] & 0x8000000000000000) == 0)
  {
    int64x2_t v257 = vclezq_f64((float64x2_t)v1016);
    if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v257, 1), (int8x16_t)v257).u64[0] & 0x8000000000000000) != 0)
    {
      float64x2_t v239 = 0uLL;
    }
    else
    {
      int8x16_t v258 = (int8x16_t)vmaxnmq_f64((float64x2_t)v983, v1015);
      int8x16_t v259 = (int8x16_t)vsubq_f64(vminnmq_f64(vaddq_f64((float64x2_t)v983, (float64x2_t)v982), vaddq_f64(v1015, (float64x2_t)v1016)), (float64x2_t)v258);
      int64x2_t v260 = vclezq_f64((float64x2_t)v259);
      int64x2_t v261 = vdupq_laneq_s64(v260, 1);
      int64x2_t v262 = (int64x2_t)vorrq_s8((int8x16_t)v261, (int8x16_t)v260);
      v261.i64[0] = -1;
      int8x16_t v263 = (int8x16_t)vdupq_lane_s64(vcgtq_s64(v262, v261).i64[0], 0);
      float64x2_t v240 = (float64x2_t)vbslq_s8(v263, v258, (int8x16_t)v983);
      float64x2_t v239 = (float64x2_t)vandq_s8(v259, v263);
    }
  }
  int64x2_t v264 = vceqzq_f64(v239);
  if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v264, 1), (int8x16_t)v264).u64[0] & 0x8000000000000000) != 0
    || (int8x16_t v265 = vorrq_s8((int8x16_t)vcltzq_f64(v239), (int8x16_t)vcgezq_f64(v239)),
        (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v265), 1), v265).u64[0] & 0x8000000000000000) != 0))
  {
    v1042[0] = 0uLL;
  }
  else
  {
    int32x4_t v266 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v240, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
    v1042[0] = (float64x2_t)vuzp1q_s32(v266, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v240, v239), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v266));
  }
  if (!CA::Shape::contains(v1011, (const CA::Bounds *)v1042)) {
    goto LABEL_478;
  }
LABEL_479:
  unsigned __int8 v224 = (int32x2_t *)v997;
  if (!(v232 & 1 | ((v230 & 1) == 0))) {
    v1036.i64[1] = v238 | 0x20C00000;
  }
  double v267 = (CA::Render::LayerNode *)v1034;
  uint64_t v188 = v998;
  int v227 = (CA::Shape **)v985;
  if (v241)
  {
    double v268 = (CA::Shape **)v1011;
    *(void *)(v1034 + 216) = v1011;
    CA::shape_union((CA::Shape **)&v1024, v268, v108);
    uint64_t v1011 = *(void *)&v1024.f64[0];
    double v267 = (CA::Render::LayerNode *)v1034;
  }
  uint64_t v225 = v1001;
  if ((*((unsigned char *)v267 + 24) & 0x20) != 0) {
    CA::Render::LayerNode::depth_sort_sublayers(v267);
  }
  if (((*v8)[135].i32[1] & 0x400000) != 0)
  {
LABEL_486:
    CA::shape_union(*(CA::Shape ***)&v989.f64[0], v227, v108);
    CA::shape_subtract((CA::Shape **)v1040, (CA::Shape **)v1013, v269, v270);
    uint64_t v272 = (CA::Shape *)v1040[0].i64[0];
    if (v1012)
    {
      CA::shape_union(v999, (CA::Shape **)v1040[0].i64[0], v271);
      if ((v1012 & 1) == 0 && *(int *)(v1012 + 4) >= 257)
      {
        v1042[0] = 0uLL;
        CA::Shape::get_bounds(v1012, (int *)v1042);
        CA::Shape::unref((CA::Shape *)v1012);
        int64_t v1012 = CA::Shape::new_shape((unsigned int *)v1042);
      }
    }
    CA::Shape::unref(v272);
    CA::Shape::unref((CA::Shape *)v227);
  }
LABEL_491:
  if (v996.i32[0])
  {
    float64x2_t v1015 = v988;
    __n128 v219 = v987;
    __n128 v1016 = v987;
  }
  if (v1012 && v1013)
  {
    double v274 = (CA::Shape **)CA::Shape::subtract((CA::Shape *)v1013, (const CA::Bounds *)&v1017);
    if (v1012)
    {
      CA::shape_union(v999, v274, v273);
      if ((v1012 & 1) == 0 && *(int *)(v1012 + 4) >= 257)
      {
        v1042[0] = 0uLL;
        CA::Shape::get_bounds(v1012, (int *)v1042);
        CA::Shape::unref((CA::Shape *)v1012);
        int64_t v1012 = CA::Shape::new_shape((unsigned int *)v1042);
      }
    }
    CA::Shape::unref((CA::Shape *)v274);
    uint64_t v276 = *(void *)(*(void *)&v226 + 128);
    if (v276
      && *(float *)(v276 + 236) > 0.0
      && (*(float *)(v276 + 240) != 0.0
       || *(float *)(v276 + 244) != 0.0
       || *(float *)(v276 + 248) != 0.0
       || *(float *)(v276 + 252) != 0.0
       || *(void *)(v276 + 128)))
    {
      CA::Render::Updater::LayerShapes::union_visible_shape((uint64_t)&v1007, (CA::Shape **)v1013, v275);
    }
  }
  if ((*(unsigned char *)(v225 + 27) & 2) == 0 && !BYTE10(xmmword_1EB2ACC70))
  {
    v914 = (__n128 *)*((void *)v1035 + 12);
    if (v914)
    {
      if (v914->n128_u8[12] == 25 && v914[15].n128_u8[9])
      {
        v915 = (uint64_t **)*v8;
        __n128 v993 = *(__n128 *)(*v8)[24].i8;
        float64x2_t v1024 = 0uLL;
        __n128 v987 = (__n128)v1008;
        float64x2_t v988 = v1007;
        CA::Bounds::set_exterior((int32x4_t *)&v1024, (const Rect *)v111, v1007, v1008);
        if (CA::BoundsImpl::intersect((int32x2_t *)&v1024, (int32x2_t)v993.n128_u64[0], (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v993, (int8x16_t)v993, 8uLL)))LODWORD(v989.f64[0]) = (double)vmulq_laneq_s32(*(int32x4_t *)&v993, *(int32x4_t *)&v993, 3).i32[2] * 0.95 < (double)(HIDWORD(v1024.f64[1]) * LODWORD(v1024.f64[1])); {
        else
        }
          LODWORD(v989.f64[0]) = 0;
        v926 = (CA::Shape *)v915[66];
        v1040[0] = 0uLL;
        CA::Bounds::set_exterior((int32x4_t *)v1040, v916, v988, (float64x2_t)v987);
        v927 = (CA::Shape *)CA::Shape::intersect(v926, (const CA::Bounds *)v1040);
        double v928 = (double)CA::Shape::area(v927);
        *(void *)&float64_t v929 = v1040[0].u32[2];
        *(void *)&float64_t v930 = v1040[0].u32[3];
        __int32 v931 = v1040[0].i32[3] * v1040[0].i32[2];
        double v932 = (double)(v1040[0].i32[3] * v1040[0].i32[2]) * 0.2;
        if (BYTE11(xmmword_1EB2ACC70))
        {
          if (x_log_hook_p())
          {
            v982.i64[0] = v932 > v928;
            float64_t v959 = v914[16].n128_f64[0];
            *(void *)&v988.f64[0] = v993.n128_u32[0];
            v987.n128_u64[0] = v993.n128_u32[1];
            uint64_t v984 = v993.n128_u32[2];
            v983.i64[0] = v993.n128_u32[3];
            uint64_t v981 = v993.n128_u32[3] * v993.n128_u32[2];
            uint64_t v960 = (HIDWORD(v1024.f64[1]) * LODWORD(v1024.f64[1]));
            double v961 = (float)((float)(int)v960 / (float)(int)v981);
            v993.n128_u64[0] = v1040[0].u32[0];
            *(void *)&long long v985 = v1040[0].u32[1];
            uint64_t v962 = CA::Shape::area(v926);
            *(void *)&v977[72] = CA::Shape::area(v927);
            *(void *)&v977[80] = v982.i64[0];
            *(void *)&v977[56] = v962;
            *(void *)&v977[40] = v960;
            *(void *)&v977[48] = LODWORD(v989.f64[0]);
            *(double *)&v977[32] = v961;
            *(void *)&v977[24] = v981;
            *(void *)&v977[16] = v983.i64[0];
            *(void *)&v977[8] = v984;
            *(void *)v977 = v987.n128_u64[0];
            *(void *)&v976.f64[0] = (LODWORD(v930) * LODWORD(v929));
            v976.f64[1] = v988.f64[0];
            v975.f64[0] = v929;
            v975.f64[1] = v930;
            *(void *)&v974.f64[1] = v985;
            *(void *)&v974.f64[0] = v993.n128_u64[0];
            v973.f64[1] = v959;
            *(double *)&v977[64] = (float)((float)*(uint64_t *)&v977[72] / (float)v931);
            x_log_();
          }
          else
          {
            *(void *)&v988.f64[0] = x_log_category_render;
            if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
            {
              v987.n128_u32[0] = v932 > v928;
              v982.i64[0] = v914[16].n128_i64[0];
              LODWORD(v984) = v1040[0].i32[1];
              v983.i32[0] = v1040[0].i32[0];
              __int32 v965 = v993.n128_u32[3] * v993.n128_u32[2];
              LODWORD(v985) = HIDWORD(v1024.f64[1]) * LODWORD(v1024.f64[1]);
              double v966 = (float)((float)(HIDWORD(v1024.f64[1]) * LODWORD(v1024.f64[1]))
                           / (float)(v993.n128_u32[3] * v993.n128_u32[2]));
              uint64_t v967 = CA::Shape::area(v926);
              uint64_t v968 = CA::Shape::area(v927);
              LODWORD(v1042[0].f64[0]) = 134222336;
              *(void *)((char *)v1042[0].f64 + 4) = v982.i64[0];
              WORD2(v1042[0].f64[1]) = 1024;
              *(_DWORD *)((char *)&v1042[0].f64[1] + 6) = v983.i32[0];
              WORD1(v1042[1].f64[0]) = 1024;
              HIDWORD(v1042[1].f64[0]) = v984;
              LOWORD(v1042[1].f64[1]) = 1024;
              *(_DWORD *)((char *)&v1042[1].f64[1] + 2) = LODWORD(v929);
              HIWORD(v1042[1].f64[1]) = 1024;
              LODWORD(v1042[2].f64[0]) = LODWORD(v930);
              WORD2(v1042[2].f64[0]) = 1024;
              *(_DWORD *)((char *)v1042[2].f64 + 6) = v931;
              WORD1(v1042[2].f64[1]) = 1024;
              HIDWORD(v1042[2].f64[1]) = v993.n128_u32[0];
              LOWORD(v1042[3].f64[0]) = 1024;
              *(_DWORD *)((char *)v1042[3].f64 + 2) = v993.n128_u32[1];
              HIWORD(v1042[3].f64[0]) = 1024;
              *(_DWORD *)((char *)&v1042[3].f64[1] + 6) = v993.n128_u32[3];
              LODWORD(v1042[3].f64[1]) = v993.n128_u32[2];
              WORD2(v1042[3].f64[1]) = 1024;
              WORD1(v1042[4].f64[0]) = 1024;
              HIDWORD(v1042[4].f64[0]) = v965;
              LOWORD(v1042[4].f64[1]) = 2048;
              *(double *)((char *)&v1042[4].f64[1] + 2) = v966;
              WORD1(v1042[5].f64[0]) = 1024;
              HIDWORD(v1042[5].f64[0]) = v985;
              LOWORD(v1042[5].f64[1]) = 1024;
              *(_DWORD *)((char *)&v1042[5].f64[1] + 2) = LODWORD(v989.f64[0]);
              HIWORD(v1042[5].f64[1]) = 2048;
              *(void *)&v1043[0] = v967;
              WORD4(v1043[0]) = 2048;
              *(double *)((char *)v1043 + 10) = (float)((float)v968 / (float)v931);
              WORD1(v1043[1]) = 2048;
              *(void *)((char *)&v1043[1] + 4) = v968;
              WORD6(v1043[1]) = 1024;
              *(_DWORD *)((char *)&v1043[1] + 14) = v987.n128_u32[0];
              _os_log_impl(&dword_184668000, *(os_log_t *)&v988.f64[0], OS_LOG_TYPE_DEFAULT, "IQ Preferred Latency %f: \n  self_bounds %i %i %i %i (area=%i)\n  update_bounds %i %i %i %i (area=%i)\n  intersection %.2f%% (area=%i)\n  is_full_screen %i\n\n  visible_shape_above area %ld\n  intersection %.2f%% (area=%ld)\n  unoccluded %i", (uint8_t *)v1042, 0x82u);
            }
          }
        }
        CA::Shape::unref(v927);
        int v933 = LODWORD(v989.f64[0]);
        if (v932 <= v928) {
          int v933 = 0;
        }
        if (v933 == 1 && (v219.n128_u64[0] = *(void *)(**(void **)&v1003.f64[0] + 144), v219.n128_f64[0] == 0.0))
        {
          __n128 v219 = v914[16];
          *(__n128 *)(**(void **)&v1003.f64[0] + 144) = v219;
          v934 = (unint64_t *)(*(void *)(v914[1].n128_u64[0] + 24) + 8);
          unint64_t v935 = atomic_load(v934);
          if ((v935 & 0x10000000000000) == 0) {
            atomic_fetch_or((atomic_ullong *volatile)v934, 0x10000000000000uLL);
          }
        }
        else
        {
          v936 = (unint64_t *)(*(void *)(v914[1].n128_u64[0] + 24) + 8);
          unint64_t v937 = atomic_load(v936);
          if ((v937 & 0x10000000000000) != 0) {
            atomic_fetch_and((atomic_ullong *volatile)v936, 0xFFEFFFFFFFFFFFFFLL);
          }
        }
        v1036.i64[1] |= 4uLL;
        unint64_t v8 = *(int32x2_t ***)&v1003.f64[0];
        unsigned __int8 v224 = (int32x2_t *)v997;
        uint64_t v188 = v998;
        uint64_t v225 = v1001;
      }
    }
  }
  int v277 = *(CA::Render::Transition **)(v225 + 120);
  if (v277)
  {
    float64x2_t v278 = v1015;
    float64x2_t v279 = (float64x2_t)v1016;
    float64x2_t v1015 = *(float64x2_t *)(v188 + 88);
    __n128 v1016 = *(__n128 *)(v188 + 104);
    __n128 v993 = (__n128)v1017;
    int32x4_t v1017 = *(int32x4_t *)(v188 + 120);
    v1036.i64[1] |= 0x20C00000uLL;
    v1029[0] = 0;
    long long v1027 = 0u;
    long long v1028 = 0u;
    float64x2_t v1025 = 0u;
    long long v1026 = 0u;
    float64x2_t v1024 = 0u;
    *(float64x2_t *)&v1029[1] = v1015;
    *(__n128 *)&v1029[3] = v1016;
    *(int32x4_t *)&v1029[5] = v1017;
    uint64_t v280 = *(void *)(v7 + 80);
    CA::Render::Updater::prepare_layer(v8, v7, *(void *)(v1034 + 136), &v1024, v213);
    uint64_t v281 = *(void *)(v7 + 80);
    *(void *)(v7 + 80) = v280;
    uint64_t v284 = CA::Render::Transition::subclass(v277, v282, v283);
    if (v284)
    {
      uint64_t v286 = v284;
      float64x2_t v287 = *((float64x2_t *)v1035 + 4);
      int8x16_t v288 = *((int8x16_t *)v1035 + 5);
      v1040[0] = (int8x16_t)v287;
      v1040[1] = v288;
      long long v289 = *(float64x2_t **)(v1034 + 56);
      if (v289) {
        CA::Mat4Impl::mat4_apply_to_rect(v289, v1040, v285);
      }
      else {
        v1040[0] = (int8x16_t)vaddq_f64(*(float64x2_t *)(v1034 + 64), v287);
      }
      float64x2_t v1022 = v1024;
      float64x2_t v1023 = v1025;
      v1020[0] = v1007;
      v1020[1] = v1008;
      long long v291 = *(void ***)v7;
      if (*(void *)v7)
      {
        long long v292 = 0;
        do
        {
          long long v293 = v292;
          long long v292 = v291;
          long long v291 = (void **)v291[1];
          v292[1] = v293;
        }
        while (v291);
        int v294 = 0;
        do
        {
          (*((void (**)(void **, float64x2_t *))*v292 + 9))(v292, &v1022);
          (*((void (**)(void **, float64x2_t *))*v292 + 9))(v292, v1020);
          float64x2_t v295 = (void **)v292[1];
          v292[1] = v294;
          int v294 = v292;
          long long v292 = v295;
        }
        while (v295);
      }
      CA::Rect::unapply_transform(v1022.f64, v7 + 8);
      CA::Rect::unapply_transform(v1020[0].f64, v7 + 8);
      uint64_t v1044 = 0;
      memset(v1043, 0, sizeof(v1043));
      memset(v1042, 0, sizeof(v1042));
      double v296 = CA::Transform::set((CA::Transform *)v1042, v7 + 8);
      ((void (*)(float64x2_t *__return_ptr, uint64_t (***)(CA::Render::BuiltinTransition *__hidden, const CA::Render::TransitionAnimation *, CA::Render::Layer *, unsigned int, float), CA::Render::Transition *, int8x16_t *, float64x2_t *, float64x2_t *, float64x2_t *, double))(*v286)[2])(&v1018, v286, v277, v1040, v1042, &v1022, v1020, v296);
      int32x4_t v217 = (int32x4_t)v1019;
      float64x2_t v1007 = v1018;
      float64x2_t v1008 = v1019;
      if (v1011)
      {
        CA::Shape::unref((CA::Shape *)v1011);
        uint64_t v1011 = 1;
      }
      char v297 = *(void ***)v7;
      unint64_t v8 = *(int32x2_t ***)&v1003.f64[0];
      if (*(void *)v7)
      {
        do
        {
          (*((void (**)(void **, float64x2_t *, void))*v297 + 3))(v297, &v1007, (v1039 >> 2) & 1);
          char v297 = (void **)v297[1];
        }
        while (v297);
      }
    }
    else
    {
      CA::Render::Updater::LayerShapes::union_bounds((__n128 *)&v1007, &v1024, (const CA::Bounds *)1);
    }
    if (v1012)
    {
      int64x2_t v298 = vceqzq_f64(v1008);
      if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v298, 1), (int8x16_t)v298).u64[0] & 0x8000000000000000) != 0
        || (int8x16_t v299 = vorrq_s8((int8x16_t)vcltzq_f64(v1008), (int8x16_t)vcgezq_f64(v1008)),
            (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v299), 1), v299).u64[0] & 0x8000000000000000) != 0))
      {
        v1042[0] = 0uLL;
      }
      else
      {
        int32x4_t v300 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v1007, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
        v1042[0] = (float64x2_t)vuzp1q_s32(v300, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v1007, v1008), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v300));
      }
      CA::shape_union(v999, (CA::Shape **)v1042, v290);
    }
    if (v1014) {
      _OWORD *v1014 = xmmword_184998040;
    }
    if (!v1011) {
      goto LABEL_532;
    }
    if (v1011)
    {
      if (v1011 == 1)
      {
LABEL_532:
        if ((v1036.i8[0] & 0x18) != 0) {
          *((_DWORD *)v277 + 19) = *((_DWORD *)v8 + 2);
        }
        if ((v281 & 0x18) != 0) {
          *((_DWORD *)v277 + 17) = *((_DWORD *)v8 + 2);
        }
        float64x2_t v1015 = v278;
        __n128 v1016 = (__n128)v279;
        __n128 v219 = v993;
        int32x4_t v1017 = (int32x4_t)v993;
        uint64_t v225 = v1001;
        goto LABEL_537;
      }
    }
    else if (*(_DWORD *)(v1011 + 4) == 6)
    {
      goto LABEL_532;
    }
    CA::Shape::unref((CA::Shape *)v1011);
    uint64_t v1011 = 1;
    goto LABEL_532;
  }
LABEL_537:
  uint64_t v301 = *((void *)v1035 + 16);
  float64_t v302 = v1002.f64[0];
  if (v301)
  {
    uint64_t v303 = *(void *)(v301 + 96);
    if (v303)
    {
      if ((v1039 & 0x10) == 0)
      {
        uint64_t v907 = *(unsigned int *)(v303 + 16);
        if (v907)
        {
          if ((v1036.i32[2] & 0x800000) == 0)
          {
            uint64_t v908 = v303 + 24;
            uint64_t v909 = 8 * v907;
            while ((*(_DWORD *)(*(void *)v908 + 12) & 0x40100) != 0x100
                 || *(_DWORD *)(*(void *)v908 + 24) == 101)
            {
              v908 += 8;
              v909 -= 8;
              if (!v909) {
                goto LABEL_539;
              }
            }
          }
          v1036.i64[1] |= 0x20C00000uLL;
        }
      }
    }
  }
LABEL_539:
  if ((((unint64_t)(*v8)[136].u16[0] << 32) & 0x30000000000) == 0x10000000000) {
    v1039 |= 2u;
  }
  uint64_t v304 = v1034;
  if (v301)
  {
    CA::Render::Updater::add_background_filters_((uint64_t ***)v8, v7, (uint64_t)v1035, v1034, (uint64_t)&v1030, (CA::Render::Updater::LayerShapes *)&v1007);
    uint64_t v304 = v1034;
  }
  uint64_t v305 = *(void *)(v304 + 24);
  if ((v305 & 0x10) == 0 && (v1039 & 4) == 0)
  {
    v219.n128_u64[0] = *(void *)&v1008.f64[0];
    v217.i32[1] = HIDWORD(v1008.f64[1]);
    if (v1008.f64[0] >= v1008.f64[1]) {
      v219.n128_u64[0] = *(void *)&v1008.f64[1];
    }
    if (v219.n128_f64[0] <= 0.0) {
      goto LABEL_551;
    }
    __n128 v219 = v1016;
    int64x2_t v306 = vclezq_f64((float64x2_t)v1016);
    int32x4_t v217 = (int32x4_t)vorrq_s8((int8x16_t)vdupq_laneq_s64(v306, 1), (int8x16_t)v306);
    if (v217.i64[0] < 0
      || (int32x4_t v217 = (int32x4_t)v1008,
          int64x2_t v307 = vclezq_f64(v1008),
          (vorrq_s8((int8x16_t)vdupq_laneq_s64(v307, 1), (int8x16_t)v307).u64[0] & 0x8000000000000000) != 0)
      || (v308 = vclezq_f64(vsubq_f64(vminnmq_f64(vaddq_f64(v1015, (float64x2_t)v1016), vaddq_f64(v1007, v1008)), vmaxnmq_f64(v1015, v1007))), int32x4_t v217 = (int32x4_t)vdupq_laneq_s64(v308, 1), v219 = (__n128)vorrq_s8((int8x16_t)v217, (int8x16_t)v308), (v219.n128_u64[0] & 0x8000000000000000) != 0))
    {
LABEL_551:
      v305 |= 0x10uLL;
      *(void *)(v304 + 24) = v305;
    }
  }
  uint64_t v309 = *(void *)(*(void *)&v302 + 128);
  if (v309)
  {
    uint64_t v310 = *(void *)(v309 + 96);
    if (v310)
    {
      uint64_t v311 = *(unsigned int *)(v310 + 16);
      if (v311)
      {
        uint64_t v312 = v310 + 24;
        uint64_t v313 = 8 * v311;
        while (1)
        {
          int v314 = *(_DWORD *)(*(void *)v312 + 24);
          if (((v314 - 195) < 2 || v314 == 387)
            && (*(_DWORD *)(*(void *)v312 + 12) & 0x40100) == 0x100)
          {
            break;
          }
          v312 += 8;
          v313 -= 8;
          if (!v313) {
            goto LABEL_564;
          }
        }
        uint64_t v315 = v1036.i64[1];
        v1036.i64[1] |= 0x800000000uLL;
        if ((((*v8)[135].u32[1] | ((unint64_t)(*v8)[136].u16[0] << 32)) & 0x40000000000) != 0)
        {
          v1036.i64[1] = v315 | 0x810000000;
          if (v224) {
            v224[9].i32[1] = *((_DWORD *)v8 + 2);
          }
        }
      }
    }
  }
LABEL_564:
  uint64_t v316 = *(void *)(*(void *)&v302 + 96);
  if (v316 && *(unsigned char *)(v316 + 12) == 25)
  {
    if (((*v8)[135].i32[1] & 4) == 0) {
      CA::Render::ImageQueue::set_visible(*(CA::Render::ImageQueue **)(*(void *)&v302 + 96), (v305 & 0x10) == 0);
    }
    if ((v305 & 0x10) != 0) {
      CA::Render::ImageQueue::did_composite((CA::Render::ImageQueue *)v316);
    }
    if (((*v8)[135].i32[1] & 4) == 0)
    {
      int64x2_t v317 = vceqzq_f64(v1008);
      unint64_t v318 = vorrq_s8((int8x16_t)vdupq_laneq_s64(v317, 1), (int8x16_t)v317).u64[0];
      int32x4_t v217 = 0uLL;
      if ((v318 & 0x8000000000000000) == 0)
      {
        int8x16_t v319 = vorrq_s8((int8x16_t)vcltzq_f64(v1008), (int8x16_t)vcgezq_f64(v1008));
        if ((vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v319), 1), v319).u64[0] & 0x8000000000000000) == 0)
        {
          int32x4_t v320 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v1007, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
          int32x4_t v217 = vuzp1q_s32(v320, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v1007, v1008), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v320));
        }
      }
      __n128 v219 = (__n128)vmulq_laneq_s32(v217, v217, 3);
      *(_DWORD *)(*(void *)(*(void *)(v316 + 16) + 24) + 64) = v219.n128_u32[2];
    }
  }
  uint64_t v321 = v1034;
  uint64_t v322 = *(void *)(v1034 + 24);
  if ((v322 & 0x10) != 0)
  {
    *(void *)(v225 + 176) = 0;
    *(void *)(v225 + 184) = 0;
    if ((v322 & 0x40) != 0 && *(void *)(v321 + 256))
    {
      uint64_t v331 = *(void *)(v225 + 256);
      *(void *)(v331 + 48) = 0;
      *(void *)(v331 + 56) = 0;
      *(unsigned char *)(v331 + 97) = 1;
    }
    goto LABEL_1062;
  }
  int8x16_t v323 = (int8x16_t)vdupq_n_s64(0xC1BFFFFFFF000000);
  float64x2_t v324 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v323, v1007), v323, (int8x16_t)v1007);
  int8x16_t v325 = (int8x16_t)vsubq_f64((float64x2_t)vdupq_n_s64(0x41C0000000000000uLL), v324);
  float64x2_t v326 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v1008, (float64x2_t)v325), v325, (int8x16_t)v1008);
  float64x2_t v1007 = v324;
  float64x2_t v1008 = v326;
  int64x2_t v327 = vceqzq_f64(v326);
  if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v327, 1), (int8x16_t)v327).u64[0] & 0x8000000000000000) != 0
    || (int8x16_t v328 = vorrq_s8((int8x16_t)vcltzq_f64(v326), (int8x16_t)vcgezq_f64(v326)),
        (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v328), 1), v328).u64[0] & 0x8000000000000000) != 0))
  {
    int8x16_t v1004 = 0uLL;
    int32x4_t v330 = 0uLL;
  }
  else
  {
    int32x4_t v329 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v324, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
    int32x4_t v330 = vuzp1q_s32(v329, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v324, v326), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v329));
    int8x16_t v1004 = (int8x16_t)v330;
  }
  if ((*((unsigned char *)v1035 + 43) & 4) != 0 && (*((unsigned char *)v1035 + 37) & 0xF) != 0)
  {
    v332.i64[0] = v330.i32[0];
    v332.i64[1] = v330.i32[1];
    float64x2_t v333 = vcvtq_f64_s64(v332);
    v332.i64[0] = v330.i32[2];
    v332.i64[1] = v330.i32[3];
    if ((vmaxv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqq_f64(v324, v333), (int32x4_t)vceqq_f64(v326, vcvtq_f64_s64(v332))))), 0xFuLL))) & 1) != 0&& (v322 & 0x100) == 0&& ((*v8)[34].i8[0] & 8) == 0)
    {
      int v334 = v330.i32[2];
      if (v330.i32[2] <= v330.i32[3]) {
        int v335 = v330.i32[3];
      }
      else {
        int v335 = v330.i32[2];
      }
      if (v330.i32[2] >= v330.i32[3]) {
        int v334 = v330.i32[3];
      }
      if (v335 <= 1073741822 && v334 >= 1)
      {
        int8x16_t v1004 = (int8x16_t)vaddq_s32(v330, (int32x4_t)xmmword_184997F10);
        int32x2_t v336 = vcgt_s32((int32x2_t)0x100000001, vrev64_s32((int32x2_t)*(_OWORD *)&vextq_s8(v1004, v1004, 8uLL)));
        if ((v336.i32[1] | v336.i32[0])) {
          v1004.i64[1] = 0;
        }
      }
    }
  }
  int v338 = CA::BoundsImpl::contains(v1015.f64, v1007.f64);
  if ((v1039 & 8) == 0) {
    goto LABEL_948;
  }
  uint64_t v339 = *(void *)(v321 + 256);
  if (!v339)
  {
    v1039 &= 0xE7u;
    goto LABEL_948;
  }
  os_unfair_lock_lock((os_unfair_lock_t)(v339 + 36));
  uint64_t v340 = *(void *)(v339 + 40);
  v987.n128_u64[0] = v340 + 40;
  os_unfair_lock_lock((os_unfair_lock_t)(v340 + 40));
  uint64_t v342 = **((void **)v1035 + 16);
  if (*(unsigned char *)(v342 + 12) != 3) {
    uint64_t v342 = 0;
  }
  if ((*(unsigned char *)(v342 + 13) & 4) != 0) {
    char v343 = v338;
  }
  else {
    char v343 = 1;
  }
  if ((v343 & 1) == 0)
  {
    int64x2_t v344 = vceqzq_f64((float64x2_t)v1016);
    unint64_t v345 = vorrq_s8((int8x16_t)vdupq_laneq_s64(v344, 1), (int8x16_t)v344).u64[0];
    int8x16_t v346 = 0uLL;
    if ((v345 & 0x8000000000000000) == 0)
    {
      int8x16_t v347 = vorrq_s8((int8x16_t)vcltzq_f64((float64x2_t)v1016), (int8x16_t)vcgezq_f64((float64x2_t)v1016));
      if ((vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v347), 1), v347).u64[0] & 0x8000000000000000) == 0)
      {
        int32x4_t v348 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v1015, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
        int8x16_t v346 = (int8x16_t)vuzp1q_s32(v348, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v1015, (float64x2_t)v1016), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v348));
      }
    }
    uint32x2_t v349 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, (int32x2_t)v1004.u64[1]);
    if ((vpmax_u32(v349, v349).u32[0] & 0x80000000) == 0)
    {
      int32x2_t v350 = (int32x2_t)vextq_s8(v346, v346, 8uLL).u64[0];
      uint32x2_t v351 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v350);
      if ((vpmax_u32(v351, v351).u32[0] & 0x80000000) != 0
        || (int32x2_t v352 = vadd_s32(*(int32x2_t *)v346.i8, v350),
            *(int32x2_t *)v346.i8 = vmax_s32(*(int32x2_t *)v1004.i8, *(int32x2_t *)v346.i8),
            int32x2_t v353 = vsub_s32(vmin_s32(vadd_s32(*(int32x2_t *)v1004.i8, (int32x2_t)v1004.u64[1]), v352), *(int32x2_t *)v346.i8), v354 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v353), (vpmax_u32(v354, v354).u32[0] & 0x80000000) != 0))
      {
        v1004.i64[1] = 0;
      }
      else
      {
        v346.u64[1] = (unint64_t)v353;
        int8x16_t v1004 = v346;
      }
    }
  }
  int8x16_t v355 = v1004;
  int32x2_t v356 = (int32x2_t)vextq_s8(v355, v355, 8uLL).u64[0];
  uint32x2_t v357 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v356);
  if ((vpmax_u32(v357, v357).u32[0] & 0x80000000) == 0)
  {
    int32x2_t v358 = (*v8)[25];
    uint32x2_t v359 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v358);
    if ((vpmax_u32(v359, v359).u32[0] & 0x80000000) != 0
      || (int32x2_t v360 = (*v8)[24],
          int32x2_t v361 = vadd_s32(*(int32x2_t *)v1004.i8, v356),
          *(int32x2_t *)v362.i8 = vmax_s32(*(int32x2_t *)v1004.i8, v360),
          int32x2_t v363 = vsub_s32(vmin_s32(v361, vadd_s32(v360, v358)), *(int32x2_t *)v362.i8),
          uint32x2_t v364 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v363),
          (vpmax_u32(v364, v364).u32[0] & 0x80000000) != 0))
    {
      v355.i64[1] = 0;
    }
    else
    {
      v362.u64[1] = (unint64_t)v363;
      int8x16_t v355 = v362;
    }
  }
  int v365 = *((_DWORD *)v8 + 2);
  *(void *)&v989.f64[0] = v1034;
  BOOL v366 = *(void **)(*(void *)(v1034 + 32) + 128);
  if (v366 && *v366)
  {
    if (*(unsigned char *)(*v366 + 12) == 3) {
      uint64_t v367 = *v366;
    }
    else {
      uint64_t v367 = 0;
    }
  }
  else
  {
    uint64_t v367 = 0;
  }
  int8x16_t v1021 = v355;
  if ((*(_DWORD *)(v367 + 12) & 0x1400) == 0x1000) {
    int8x16_t v1021 = 0uLL;
  }
  int v368 = *(_DWORD *)(v340 + 56);
  __n128 v993 = (__n128)v355;
  *(void *)&v988.f64[0] = v339 + 36;
  if (v368)
  {
    if (v368 != v365) {
      goto LABEL_933;
    }
    LODWORD(v984) = v365;
    *(void *)&long long v985 = v367;
    CA::shape_union((CA::Shape **)(v340 + 480), (CA::Shape **)&v1021, v341);
    float64_t v370 = v989.f64[0];
  }
  else
  {
    LODWORD(v984) = v365;
    *(void *)&long long v985 = v367;
    if (v366 && !(_BYTE)xmmword_1EB2ACBF0 && (BOOL v371 = (atomic_uint *)v366[12]) != 0)
    {
      BOOL v372 = *(atomic_uint **)(v340 + 560);
      float64_t v370 = v989.f64[0];
      if (v372 != v371)
      {
        if (v372 && atomic_fetch_add(v372 + 2, 0xFFFFFFFF) == 1) {
          (*(void (**)(atomic_uint *))(*(void *)v372 + 16))(v372);
        }
        double v373 = v371 + 2;
        if (!atomic_fetch_add(v371 + 2, 1u))
        {
          BOOL v371 = 0;
          atomic_fetch_add(v373, 0xFFFFFFFF);
        }
        *(void *)(v340 + 560) = v371;
      }
    }
    else
    {
      BOOL v374 = *(atomic_uint **)(v340 + 560);
      float64_t v370 = v989.f64[0];
      if (v374)
      {
        if (atomic_fetch_add(v374 + 2, 0xFFFFFFFF) == 1) {
          (*(void (**)(atomic_uint *))(*(void *)v374 + 16))(v374);
        }
        *(void *)(v340 + 560) = 0;
      }
    }
    uint64_t v375 = *(CA::Shape **)(v340 + 480);
    if (v375) {
      CA::Shape::unref(v375);
    }
    *(_DWORD *)(v340 + 56) = v984;
    *(_DWORD *)(v340 + 60) = *(_DWORD *)(v985 + 32);
    *(void *)(v340 + 480) = CA::Shape::new_shape((unsigned int *)&v1021);
  }
  uint64_t v376 = *(void *)(*(void *)(*(void *)&v370 + 32) + 128);
  LODWORD(v981) = v338;
  if (!v376)
  {
    uint64_t v379 = *(atomic_uint **)(v340 + 560);
    int32x4_t v380 = (int32x4_t)v993;
    if (!v379) {
      goto LABEL_893;
    }
    __int16 v378 = (atomic_uint **)(v340 + 560);
LABEL_890:
    if (atomic_fetch_add(v379 + 2, 0xFFFFFFFF) == 1)
    {
      (*(void (**)(atomic_uint *))(*(void *)v379 + 16))(v379);
      int32x4_t v380 = (int32x4_t)v993;
    }
    *__int16 v378 = 0;
    goto LABEL_893;
  }
  uint64_t v377 = *(void *)(v376 + 96);
  __int16 v378 = (atomic_uint **)(v340 + 560);
  uint64_t v379 = *(atomic_uint **)(v340 + 560);
  int32x4_t v380 = (int32x4_t)v993;
  if (!v377)
  {
    if (!v379) {
      goto LABEL_893;
    }
    goto LABEL_890;
  }
  if (!v379)
  {
LABEL_893:
    int32x4_t v982 = 0u;
    int32x4_t v983 = 0u;
    goto LABEL_894;
  }
  unsigned __int32 v381 = *(_DWORD *)(v377 + 16);
  unsigned __int32 v382 = v379[4];
  if (v381 >= v382) {
    unsigned int v383 = (CA::Render::Array *)v382;
  }
  else {
    unsigned int v383 = (CA::Render::Array *)v381;
  }
  if (!v383)
  {
    int32x4_t v982 = 0u;
    int32x4_t v983 = 0u;
LABEL_1648:
    if (atomic_fetch_add(v379 + 2, 0xFFFFFFFF) == 1)
    {
      (*(void (**)(atomic_uint *))(*(void *)v379 + 16))(v379);
      int32x4_t v380 = (int32x4_t)v993;
    }
    *__int16 v378 = 0;
    goto LABEL_894;
  }
  uint64_t v384 = 0;
  int32x4_t v982 = 0u;
  int32x4_t v983 = 0u;
  v979 = (atomic_uint **)(v340 + 560);
  while (1)
  {
    uint64_t v385 = *(void *)(v377 + 8 * (void)v384 + 24);
    uint64_t v386 = *(void *)&(*v378)[2 * (void)v384 + 6];
    int v387 = *(_DWORD *)(v385 + 24);
    if (v387 != *(_DWORD *)(v386 + 24)
      || ((*(unsigned __int8 *)(v385 + 13) ^ *(unsigned __int8 *)(v386 + 13)) & 1) != 0)
    {
      goto LABEL_1638;
    }
    uint64_t v388 = *(void *)(v385 + 40);
    uint64_t v389 = *(void *)(v386 + 40);
    if (!(v388 | v389)) {
      goto LABEL_833;
    }
    if ((v388 != 0) != (v389 != 0)) {
      goto LABEL_1638;
    }
    if (v387 <= 194) {
      break;
    }
    if (v387 > 369)
    {
      if (v387 > 491)
      {
        if (v387 != 492)
        {
          if (v387 != 533)
          {
            if (v387 != 588 || v385 != v386) {
              goto LABEL_1638;
            }
            goto LABEL_833;
          }
          uint64_t v390 = v383;
          double float_key = CA::Render::KeyValueArray::get_float_key(*(CA::Render::KeyValueArray **)(v385 + 40), 276, 0.5);
          double v396 = 0.5;
LABEL_738:
          uint64_t v402 = (CA::Render::KeyValueArray *)v389;
          int v403 = 276;
LABEL_739:
          if (float_key != CA::Render::KeyValueArray::get_float_key(v402, v403, v396)) {
            goto LABEL_1625;
          }
LABEL_740:
          int32x4_t v380 = (int32x4_t)v993;
          unsigned int v383 = v390;
          __int16 v378 = v979;
        }
      }
      else if (v387 != 370)
      {
        if (v387 != 387)
        {
          if (v387 != 410) {
            goto LABEL_1638;
          }
          uint64_t v390 = v383;
          double float_key = CA::Render::KeyValueArray::get_float_key(*(CA::Render::KeyValueArray **)(v385 + 40), 276, 0.0);
          double v396 = 0.0;
          goto LABEL_738;
        }
        goto LABEL_689;
      }
    }
    else
    {
      if (v387 <= 261)
      {
        if ((v387 - 195) >= 2)
        {
          if (v387 != 247) {
            goto LABEL_1638;
          }
          uint64_t v390 = v383;
          double v391 = CA::Render::KeyValueArray::get_float_key((CA::Render::KeyValueArray *)v388, 310, 0.0);
          if (v391 != CA::Render::KeyValueArray::get_float_key((CA::Render::KeyValueArray *)v389, 310, 0.0)) {
            goto LABEL_1625;
          }
          CA::Render::KeyValueArray::get_rect_key(v1042, v388, (const Rect *)0x11D, (float64x2_t)0, (float64x2_t)0);
          int32x4_t v982 = (int32x4_t)v1042[1];
          int32x4_t v983 = (int32x4_t)v1042[0];
          goto LABEL_740;
        }
LABEL_689:
        uint64_t v390 = v383;
        double v401 = CA::Render::KeyValueArray::get_float_key((CA::Render::KeyValueArray *)v388, 276, 0.0);
        if (v401 != CA::Render::KeyValueArray::get_float_key((CA::Render::KeyValueArray *)v389, 276, 0.0)) {
          goto LABEL_1625;
        }
        double float_key = CA::Render::KeyValueArray::get_float_key((CA::Render::KeyValueArray *)v388, 314, 1.0);
        double v396 = 1.0;
        uint64_t v402 = (CA::Render::KeyValueArray *)v389;
        int v403 = 314;
        goto LABEL_739;
      }
      if (v387 == 262)
      {
        if (!v388) {
          goto LABEL_769;
        }
        uint64_t v429 = *(unsigned int *)(v388 + 16);
        if (!v429) {
          goto LABEL_769;
        }
        uint64_t v430 = 0;
        while (1)
        {
          uint64_t v431 = *(void *)(v388 + 24 + 8 * v430);
          if (*(_DWORD *)(v431 + 16) == 289) {
            break;
          }
          if (v429 == ++v430) {
            goto LABEL_769;
          }
        }
        if ((v430 & 0x80000000) == 0) {
          uint64_t v446 = *(void *)(v431 + 24);
        }
        else {
LABEL_769:
        }
          uint64_t v446 = 0;
        if (!v389) {
          goto LABEL_778;
        }
        uint64_t v447 = *(unsigned int *)(v389 + 16);
        if (!v447) {
          goto LABEL_778;
        }
        uint64_t v448 = 0;
        while (1)
        {
          uint64_t v449 = *(void *)(v389 + 24 + 8 * v448);
          if (*(_DWORD *)(v449 + 16) == 289) {
            break;
          }
          if (v447 == ++v448) {
            goto LABEL_778;
          }
        }
        if ((v448 & 0x80000000) == 0) {
          uint64_t v450 = *(void *)(v449 + 24);
        }
        else {
LABEL_778:
        }
          uint64_t v450 = 0;
        *(void *)&long long v978 = v383;
        if (v446 != v450) {
          goto LABEL_1626;
        }
        double v451 = CA::Render::KeyValueArray::get_float_key((CA::Render::KeyValueArray *)v388, 276, 0.0);
        if (v451 != CA::Render::KeyValueArray::get_float_key((CA::Render::KeyValueArray *)v389, 276, 0.0)) {
          goto LABEL_1626;
        }
        double v452 = CA::Render::KeyValueArray::get_float_key((CA::Render::KeyValueArray *)v388, 307, 0.0);
        if (v452 != CA::Render::KeyValueArray::get_float_key((CA::Render::KeyValueArray *)v389, 307, 0.0)) {
          goto LABEL_1626;
        }
        LODWORD(v980) = CA::Render::KeyValueArray::get_color_key((CA::Render::KeyValueArray *)v388, 272, 0);
        int color_key = CA::Render::KeyValueArray::get_color_key((CA::Render::KeyValueArray *)v389, 272, 0);
        if (v980 != color_key) {
          goto LABEL_1626;
        }
        int v454 = CA::Render::KeyValueArray::get_color_key((CA::Render::KeyValueArray *)v388, 273, 0);
        if (v454 != CA::Render::KeyValueArray::get_color_key((CA::Render::KeyValueArray *)v389, 273, 0)) {
          goto LABEL_1626;
        }
        goto LABEL_831;
      }
      if (v387 == 368)
      {
        *(void *)&long long v978 = v383;
        double v432 = CA::Render::KeyValueArray::get_float_key((CA::Render::KeyValueArray *)v388, 276, 0.0);
        if (v432 != CA::Render::KeyValueArray::get_float_key((CA::Render::KeyValueArray *)v389, 276, 0.0)) {
          goto LABEL_1626;
        }
        if (!v388) {
          goto LABEL_815;
        }
        uint64_t v434 = *(unsigned int *)(v388 + 16);
        if (!v434) {
          goto LABEL_815;
        }
        uint64_t v435 = 0;
        while (1)
        {
          uint64_t v436 = *(void *)(v388 + 24 + 8 * v435);
          if (*(_DWORD *)(v436 + 16) == 321) {
            break;
          }
          if (v434 == ++v435) {
            goto LABEL_815;
          }
        }
        if ((v435 & 0x80000000) == 0) {
          unint64_t v466 = *(void *)(v436 + 24);
        }
        else {
LABEL_815:
        }
          unint64_t v466 = 0;
        if (!v389) {
          goto LABEL_829;
        }
        uint64_t v467 = *(unsigned int *)(v389 + 16);
        if (!v467) {
          goto LABEL_829;
        }
        uint64_t v468 = 0;
        while (1)
        {
          uint64_t v469 = *(void *)(v389 + 24 + 8 * v468);
          if (*(_DWORD *)(v469 + 16) == 321) {
            break;
          }
          if (v467 == ++v468) {
            goto LABEL_829;
          }
        }
        if ((v468 & 0x80000000) == 0) {
          unint64_t v471 = *(void *)(v469 + 24);
        }
        else {
LABEL_829:
        }
          unint64_t v471 = 0;
        if (!CA::Render::curves_equal(v466, v471, v433)) {
          goto LABEL_1626;
        }
        goto LABEL_831;
      }
      if (v387 != 369) {
        goto LABEL_1638;
      }
      uint64_t v390 = v383;
      double v397 = CA::Render::KeyValueArray::get_float_key(*(CA::Render::KeyValueArray **)(v385 + 40), 276, 0.0);
      if (v397 != CA::Render::KeyValueArray::get_float_key((CA::Render::KeyValueArray *)v389, 276, 0.0))
      {
LABEL_1625:
        int32x4_t v380 = (int32x4_t)v993;
        LODWORD(v383) = v390;
        __int16 v378 = v979;
        goto LABEL_1638;
      }
      int32x4_t v380 = (int32x4_t)v993;
      unsigned int v383 = v390;
      if (v388)
      {
        uint64_t v398 = *(unsigned int *)(v388 + 16);
        __int16 v378 = v979;
        if (!v398) {
          goto LABEL_806;
        }
        uint64_t v399 = 0;
        while (1)
        {
          uint64_t v400 = *(void *)(v388 + 24 + 8 * v399);
          if (*(_DWORD *)(v400 + 16) == 289) {
            break;
          }
          if (v398 == ++v399) {
            goto LABEL_806;
          }
        }
        if ((v399 & 0x80000000) != 0) {
LABEL_806:
        }
          uint64_t v439 = 0;
        else {
          uint64_t v439 = *(void *)(v400 + 24);
        }
      }
      else
      {
        uint64_t v439 = 0;
        __int16 v378 = v979;
      }
      if (!v389) {
        goto LABEL_824;
      }
      uint64_t v463 = *(unsigned int *)(v389 + 16);
      if (!v463) {
        goto LABEL_824;
      }
      uint64_t v464 = 0;
      while (1)
      {
        uint64_t v465 = *(void *)(v389 + 24 + 8 * v464);
        if (*(_DWORD *)(v465 + 16) == 289) {
          break;
        }
        if (v463 == ++v464) {
          goto LABEL_824;
        }
      }
      if ((v464 & 0x80000000) == 0) {
        uint64_t v470 = *(void *)(v465 + 24);
      }
      else {
LABEL_824:
      }
        uint64_t v470 = 0;
      if (v439 != v470) {
        goto LABEL_1638;
      }
    }
LABEL_833:
    uint64_t v384 = (CA::Render::Array *)((char *)v384 + 1);
    if (v384 == v383)
    {
      uint64_t v384 = v383;
      goto LABEL_1638;
    }
  }
  if (v387 <= 94)
  {
    if (v387 != 50)
    {
      if (v387 != 88) {
        goto LABEL_1638;
      }
      *(void *)&long long v978 = v383;
      v1042[0] = 0uLL;
      double vec2_key = CA::Render::KeyValueArray::get_vec2_key(v388, 311, (uint64_t)v1042);
      double v406 = v405;
      float64x2_t v1024 = 0uLL;
      if (vec2_key != CA::Render::KeyValueArray::get_vec2_key(v389, 311, (uint64_t)&v1024) || v406 != v407) {
        goto LABEL_1626;
      }
      v1040[0] = 0uLL;
      double v408 = CA::Render::KeyValueArray::get_vec2_key(v388, 298, (uint64_t)v1040);
      double v410 = v409;
      float64x2_t v1022 = 0uLL;
      BOOL v412 = v408 == CA::Render::KeyValueArray::get_vec2_key(v389, 298, (uint64_t)&v1022) && v410 == v411;
      if (!v412
        || (v1020[0] = 0uLL,
            double v413 = CA::Render::KeyValueArray::get_vec2_key(v388, 283, (uint64_t)v1020),
            double v415 = v414,
            float64x2_t v1018 = 0uLL,
            v413 != CA::Render::KeyValueArray::get_vec2_key(v389, 283, (uint64_t)&v1018))
        || v415 != v416)
      {
LABEL_1626:
        int32x4_t v380 = (int32x4_t)v993;
        goto LABEL_1637;
      }
LABEL_831:
      int32x4_t v380 = (int32x4_t)v993;
LABEL_832:
      unsigned int v383 = (CA::Render::Array *)v978;
      goto LABEL_833;
    }
    goto LABEL_833;
  }
  v980 = *(CA::Render::KeyValueArray **)(v386 + 40);
  switch(v387)
  {
    case '_':
    case 'a':
    case 'k':
      uint64_t v392 = v383;
      double v393 = CA::Render::KeyValueArray::get_float_key((CA::Render::KeyValueArray *)v388, 276, 1.0);
      double v394 = 1.0;
      goto LABEL_722;
    case 'b':
    case 'f':
    case 'h':
    case 'i':
    case 'j':
    case 'l':
    case 'm':
    case 'n':
    case 'o':
    case 'p':
    case 'q':
      goto LABEL_1638;
    case 'c':
      uint64_t v390 = v383;
      double v421 = CA::Render::KeyValueArray::get_float_key((CA::Render::KeyValueArray *)v388, 277, 0.0);
      double v422 = v980;
      if (v421 != CA::Render::KeyValueArray::get_float_key(v980, 277, 0.0)) {
        goto LABEL_1625;
      }
      int int_key = CA::Render::KeyValueArray::get_int_key((CA::Render::KeyValueArray *)v388, 301, 0);
      if (int_key != CA::Render::KeyValueArray::get_int_key(v422, 301, 0)) {
        goto LABEL_1625;
      }
      goto LABEL_740;
    case 'd':
      goto LABEL_833;
    case 'e':
      uint64_t v392 = v383;
      int v424 = CA::Render::KeyValueArray::get_int_key((CA::Render::KeyValueArray *)v388, 313, 0);
      if (v424 != CA::Render::KeyValueArray::get_int_key(v980, 313, 0)) {
        goto LABEL_886;
      }
      goto LABEL_723;
    case 'g':
      *(void *)&long long v978 = v383;
      if (!v388)
      {
        uint64_t v437 = 0;
        float64x2_t v426 = v980;
        goto LABEL_747;
      }
      uint64_t v425 = *(unsigned int *)(v388 + 16);
      float64x2_t v426 = v980;
      if (!v425) {
        goto LABEL_746;
      }
      uint64_t v427 = 0;
      while (1)
      {
        uint64_t v428 = *(void *)(v388 + 24 + 8 * v427);
        if (*(_DWORD *)(v428 + 16) == 290) {
          break;
        }
        if (v425 == ++v427) {
          goto LABEL_746;
        }
      }
      if ((v427 & 0x80000000) == 0)
      {
        uint64_t v437 = *(void *)(v428 + 24);
        goto LABEL_747;
      }
LABEL_746:
      uint64_t v437 = 0;
      if (!v426) {
        goto LABEL_755;
      }
      uint64_t v440 = *((unsigned int *)v426 + 4);
      if (!v440) {
        goto LABEL_755;
      }
LABEL_747:
      uint64_t v441 = 0;
      while (1)
      {
        uint64_t v442 = *((void *)v426 + v441 + 3);
        if (*(_DWORD *)(v442 + 16) == 290) {
          break;
        }
        if (v440 == ++v441) {
          goto LABEL_755;
        }
      }
      if ((v441 & 0x80000000) == 0) {
        uint64_t v443 = *(void *)(v442 + 24);
      }
      else {
LABEL_755:
      }
        uint64_t v443 = 0;
      BOOL v444 = CA::Render::KeyValueArray::get_int_key((CA::Render::KeyValueArray *)v388, 308, 0) == 0;
      BOOL v445 = v444 == (CA::Render::KeyValueArray::get_int_key(v980, 308, 0) != 0) || v437 == 0;
      if (!v445
        && *(unsigned char *)(v437 + 12) == 56
        && v443
        && *(unsigned char *)(v443 + 12) == 56
        && *(_DWORD *)(v437 + 16) == 20
        && *(_DWORD *)(v443 + 16) == 20
        && !memcmp((const void *)(v437 + 24), (const void *)(v443 + 24), 0xA0uLL))
      {
        int32x4_t v380 = (int32x4_t)v993;
        float64_t v370 = v989.f64[0];
        goto LABEL_832;
      }
      int32x4_t v380 = (int32x4_t)v993;
      float64_t v370 = v989.f64[0];
LABEL_1637:
      LODWORD(v383) = v978;
LABEL_1638:
      if (BYTE9(xmmword_1EB2ACC30)) {
        _CF = v384 >= v383;
      }
      else {
        _CF = 1;
      }
      if (_CF) {
        goto LABEL_1643;
      }
      uint64_t v939 = *(void *)(v377 + 8 * v384 + 24);
      uint64_t v940 = *(void *)&(*v378)[2 * v384 + 6];
      x_log_begin();
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        v944 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v1042[0].f64[0]) = 0;
          _os_log_impl(&dword_184668000, v944, OS_LOG_TYPE_DEFAULT, "Filter merging failed.\nFilter A:", (uint8_t *)v1042, 2u);
        }
      }
      CA::Render::show_newline((CA::Render *)1);
      (*(void (**)(uint64_t, uint64_t, void))(*(void *)v939 + 40))(v939, 1, 0);
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        v945 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v1042[0].f64[0]) = 0;
          _os_log_impl(&dword_184668000, v945, OS_LOG_TYPE_DEFAULT, "\nFilter B:", (uint8_t *)v1042, 2u);
        }
      }
      CA::Render::show_newline((CA::Render *)1);
      (*(void (**)(uint64_t, uint64_t, void))(*(void *)v940 + 40))(v940, 1, 0);
      v946 = (void **)x_stream_pop_(0);
      v980 = (CA::Render::KeyValueArray *)x_stream_get(v946);
      int v947 = 0;
      *(void *)&long long v948 = 136315650;
      long long v978 = v948;
      while (2)
      {
        uint64_t v949 = 0;
        v950 = (char *)v980 + v947;
        int v951 = -1;
        while (2)
        {
          if (v950[v949] == 10)
          {
            int v951 = v949;
LABEL_1729:
            ++v949;
            unsigned int v952 = 32512;
            if (v949 == 32512) {
              goto LABEL_1730;
            }
            continue;
          }
          break;
        }
        if (v950[v949]) {
          goto LABEL_1729;
        }
        unsigned int v952 = v949;
LABEL_1730:
        if (v951 <= -1 || v950[v952] == 0) {
          uint64_t v954 = v952;
        }
        else {
          uint64_t v954 = (v951 + 1);
        }
        if ((int)v954 > 0)
        {
          if (x_log_hook_p())
          {
            v955 = "continued...\n";
            if (!v947) {
              v955 = "";
            }
            *(void *)&v977[64] = v954;
            *(void *)&v977[72] = v950;
            *(void *)&v977[56] = v955;
            x_log_();
          }
          else
          {
            v956 = x_log_category_render;
            if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(v1042[0].f64[0]) = v978;
              v957 = "continued...\n";
              if (!v947) {
                v957 = "";
              }
              *(void *)((char *)v1042[0].f64 + 4) = v957;
              WORD2(v1042[0].f64[1]) = 1040;
              *(_DWORD *)((char *)&v1042[0].f64[1] + 6) = v954;
              WORD1(v1042[1].f64[0]) = 2080;
              *(void *)((char *)v1042[1].f64 + 4) = v950;
              _os_log_impl(&dword_184668000, v956, OS_LOG_TYPE_DEFAULT, "%s%.*s", (uint8_t *)v1042, 0x1Cu);
            }
          }
          v947 += v954;
          continue;
        }
        break;
      }
      x_log_end_free_(v946);
      int32x4_t v380 = (int32x4_t)v993;
      float64_t v370 = v989.f64[0];
      __int16 v378 = v979;
LABEL_1643:
      uint64_t v379 = *v378;
      if (!v384)
      {
        if (!v379) {
          goto LABEL_894;
        }
        goto LABEL_1648;
      }
      unsigned int v911 = v379[4];
      if (v384 != v911)
      {
        if (v911 >= v384)
        {
          v912 = CA::Render::Array::new_array(v384, v379 + 6, (CA::Render::Object *const *)1, v379[3] >> 8);
          int32x4_t v380 = (int32x4_t)v993;
          v913 = v912;
          uint64_t v379 = *v378;
          *__int16 v378 = v913;
          if (v379) {
            goto LABEL_1652;
          }
        }
        else
        {
          *__int16 v378 = 0;
LABEL_1652:
          if (atomic_fetch_add(v379 + 2, 0xFFFFFFFF) == 1)
          {
            (*(void (**)(atomic_uint *))(*(void *)v379 + 16))(v379);
            int32x4_t v380 = (int32x4_t)v993;
          }
        }
      }
LABEL_894:
      uint64_t v495 = *(void *)(v340 + 64);
      uint64_t v496 = *(void *)(v340 + 72) - v495;
      unint64_t v497 = v496 / 168;
      if (v496)
      {
        if (v497 <= 1) {
          uint64_t v498 = 1;
        }
        else {
          uint64_t v498 = v496 / 168;
        }
        while (*(void *)v495 != *(void *)(v339 + 24))
        {
          v495 += 168;
          if (!--v498) {
            goto LABEL_900;
          }
        }
        uint64_t v500 = v7;
      }
      else
      {
LABEL_900:
        X::small_vector_base<CA::Render::BackdropGroup::Item>::resize((char **)(v340 + 64), v497 + 1);
        uint64_t v499 = *(void *)(v340 + 64);
        if (0xCF3CF3CF3CF3CF3DLL * ((*(void *)(v340 + 72) - v499) >> 3) <= v497) {
          __assert_rtn("operator[]", "x-small-vector.h", 91, "pos < size () && \"Out of bounds access\"");
        }
        uint64_t v500 = v7;
        uint64_t v495 = v499 + 168 * v497;
        *(void *)uint64_t v495 = *(void *)(v339 + 24);
        *(_DWORD *)(v340 + 12) |= 0x400u;
        int32x4_t v380 = (int32x4_t)v993;
      }
      long long v501 = (_DWORD *)v985;
      uint64_t v502 = *(void *)(*(void *)(*(void *)&v370 + 32) + 128);
      if (v502)
      {
        if ((*(unsigned char *)(v985 + 13) & 2) != 0)
        {
          uint64_t v503 = *(void *)(v502 + 96);
          if (v503 && (uint64_t v504 = *(unsigned int *)(v503 + 16), v504))
          {
            uint64_t v505 = v503 + 24;
            uint64_t v506 = 8 * v504 - 8;
            do
            {
              if ((*(_DWORD *)(*(void *)v505 + 12) & 0x40100) == 0x100)
              {
                int v507 = v501;
                uint64_t v508 = CAAtomIndexInArray(25, (uint64_t)CA::Render::Filter::is_one_to_one(void)const::atoms, *(_DWORD *)(*(void *)v505 + 24));
                int32x4_t v380 = (int32x4_t)v993;
                _ZF = v508 == -1;
                long long v501 = v507;
                int v338 = !_ZF;
              }
              else
              {
                int v338 = 1;
              }
              if (!v338) {
                break;
              }
              v505 += 8;
              uint64_t v509 = v506;
              v506 -= 8;
            }
            while (v509);
          }
          else
          {
            LOBYTE(v338) = 1;
          }
        }
        else
        {
          LOBYTE(v338) = 0;
        }
      }
      else
      {
        int v338 = (*(unsigned __int8 *)(v985 + 13) >> 1) & 1;
      }
      float64_t v510 = v989.f64[0];
      *(float64_t *)(v495 + 8) = v989.f64[0];
      *(_DWORD *)(v495 + 164) = v984;
      int32x4_t v511 = v983;
      int32x4_t v512 = v982;
      *(int32x4_t *)(v495 + 48) = v983;
      *(int32x4_t *)(v495 + 64) = v512;
      int v513 = v380.i32[2];
      if (v380.i32[2] <= v380.i32[3]) {
        int v513 = v380.i32[3];
      }
      v512.i32[0] = 1073741822;
      v511.i32[0] = v513;
      v514.i64[0] = v380.i32[0];
      v514.i64[1] = v380.i32[1];
      int8x16_t v515 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v511, v512), 0), (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v514));
      v514.i64[0] = v380.i32[2];
      v514.i64[1] = v380.i32[3];
      int8x16_t v516 = (int8x16_t)vcvtq_f64_s64(v514);
      int32x2_t v517 = vdup_n_s32(v513 > 1073741822);
      v514.i64[0] = v517.u32[0];
      v514.i64[1] = v517.u32[1];
      *(int8x16_t *)(v495 + 80) = v515;
      *(int8x16_t *)(v495 + 96) = vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v514, 0x3FuLL)), (int8x16_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL), v516);
      float64x2_t v518 = (_OWORD *)(v495 + 16);
      if ((v501[3] & 0x1400) == 0x1000)
      {
        *float64x2_t v518 = 0u;
        *(_OWORD *)(v495 + 32) = 0u;
        uint64_t v7 = v500;
        unint64_t v8 = *(int32x2_t ***)&v1003.f64[0];
        uint64_t v188 = v998;
        double v519 = *(double *)v983.i64;
      }
      else
      {
        (*(void (**)(_DWORD *, void, _OWORD *, void))(*(void *)v501 + 184))(v501, *(void *)(*(void *)&v510 + 32), v518, 0);
        double v519 = *(double *)(v495 + 48);
        uint64_t v7 = v500;
        unint64_t v8 = *(int32x2_t ***)&v1003.f64[0];
        uint64_t v188 = v998;
      }
      uint64_t v520 = *(void *)(*(void *)&v510 + 32);
      *(_OWORD *)(v495 + 144) = *(_OWORD *)(v520 + 16);
      *(unsigned char *)(v495 + 160) = v338;
      float64_t v302 = v1002.f64[0];
      LOBYTE(v338) = v981;
      if (*(double *)(v520 + 64) == v519
        && *(double *)(v520 + 72) == *(double *)(v495 + 56)
        && *(double *)(v520 + 80) == *(double *)(v495 + 64)
        && *(double *)(v520 + 88) == *(double *)(v495 + 72))
      {
        if (byte_1EB2ACBEA)
        {
          if (x_log_hook_p())
          {
            x_log_();
            unint64_t v8 = *(int32x2_t ***)&v1003.f64[0];
            uint64_t v188 = v998;
            float64_t v302 = v1002.f64[0];
            LOBYTE(v338) = v981;
          }
          else
          {
            v942 = x_log_category_render;
            BOOL v943 = os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT);
            unint64_t v8 = *(int32x2_t ***)&v1003.f64[0];
            uint64_t v188 = v998;
            float64_t v302 = v1002.f64[0];
            LOBYTE(v338) = v981;
            if (v943)
            {
              LOWORD(v1042[0].f64[0]) = 0;
              _os_log_impl(&dword_184668000, v942, OS_LOG_TYPE_DEFAULT, "Filter merging aborted: layer.bounds == blur.inputBounds\n", (uint8_t *)v1042, 2u);
            }
          }
        }
        uint64_t v521 = *(atomic_uint **)(v340 + 560);
        if (v521)
        {
          if (atomic_fetch_add(v521 + 2, 0xFFFFFFFF) == 1) {
            (*(void (**)(atomic_uint *))(*(void *)v521 + 16))(v521);
          }
          *(void *)(v340 + 560) = 0;
        }
      }
LABEL_933:
      if (((*v8)[135].i32[1] & 0x2000) != 0)
      {
        uint64_t v522 = *(void *)(v340 + 48);
        if (v522) {
          v1036.i64[1] |= *(void *)(v522 + 16) << 47;
        }
      }
      __int32 v523 = v1004.i32[1];
      float64_t v524 = v988.f64[0];
      if (*(_DWORD *)(v339 + 48) != v1004.i32[0])
      {
        __int32 v525 = v1004.i32[2];
LABEL_943:
        *(_DWORD *)(v339 + 48) = v1004.i32[0];
        *(_DWORD *)(v339 + 52) = v523;
        __int32 v527 = v1004.i32[3];
        *(_DWORD *)(v339 + 56) = v525;
        *(_DWORD *)(v339 + 60) = v527;
        *(_DWORD *)(v340 + 12) |= 0x400u;
        *((unsigned char *)v8 + 12) = 1;
        goto LABEL_944;
      }
      __int32 v525 = v1004.i32[2];
      if (*(void *)(v339 + 52) != *(uint64_t *)((char *)v1004.i64 + 4) || *(_DWORD *)(v339 + 60) != v1004.i32[3]) {
        goto LABEL_943;
      }
      if (v338)
      {
LABEL_944:
        float64_t v526 = v987.n128_f64[0];
        goto LABEL_945;
      }
      float64_t v526 = v987.n128_f64[0];
      if ((v1036.i8[3] & 0x10) != 0) {
        *(_DWORD *)(v340 + 12) |= 0x400u;
      }
LABEL_945:
      if (v525 >= v1004.i32[3]) {
        __int32 v525 = v1004.i32[3];
      }
      *(unsigned char *)(v339 + 97) = v525 < 1;
      os_unfair_lock_unlock(*(os_unfair_lock_t *)&v526);
      os_unfair_lock_unlock(*(os_unfair_lock_t *)&v524);
LABEL_948:
      if ((v338 & 1) == 0)
      {
        int64x2_t v528 = vceqzq_f64((float64x2_t)v1016);
        __n128 v219 = 0uLL;
        if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v528, 1), (int8x16_t)v528).u64[0] & 0x8000000000000000) == 0)
        {
          int8x16_t v529 = vorrq_s8((int8x16_t)vcltzq_f64((float64x2_t)v1016), (int8x16_t)vcgezq_f64((float64x2_t)v1016));
          if ((vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v529), 1), v529).u64[0] & 0x8000000000000000) == 0)
          {
            int32x4_t v530 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v1015, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
            __n128 v219 = (__n128)vuzp1q_s32(v530, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v1015, (float64x2_t)v1016), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v530));
          }
        }
        int32x4_t v217 = (int32x4_t)vextq_s8((int8x16_t)v219, (int8x16_t)v219, 8uLL);
        if ((*(unsigned char *)(*(void *)&v302 + 13) & 4) != 0)
        {
          *(void *)&float64_t v919 = v1004.u32[0];
          *(void *)&float64_t v920 = v1004.u32[1];
          uint64_t v921 = v1004.u32[2];
          uint64_t v922 = v1004.u32[3];
          __n128 v993 = v219;
          CA::BoundsImpl::intersect((int32x2_t *)&v1004, (int32x2_t)v219.n128_u64[0], *(int32x2_t *)v217.i8);
          *(double *)v217.i64 = (double)((int)v922 * (int)v921) * 0.9;
          if (*(double *)v217.i64 >= (double)(v1004.i32[3] * v1004.i32[2]))
          {
            if (byte_1EB2ACC2F)
            {
              if (x_log_hook_p())
              {
                float64_t v958 = *(double *)&v997;
                if ((void)v997) {
                  *(void *)&float64_t v958 = *(unsigned int *)(v997 + 84);
                }
                *(void *)&v977[64] = v993.n128_u32[2];
                *(void *)&v977[72] = v993.n128_u32[3];
                *(void *)&v977[48] = v993.n128_u32[0];
                *(void *)&v977[56] = v993.n128_u32[1];
                *(void *)&v977[32] = v1004.u32[2];
                *(void *)&v977[40] = v1004.u32[3];
                *(void *)&v977[16] = v1004.u32[0];
                *(void *)&v977[24] = v1004.u32[1];
                *(void *)v977 = v921;
                *(void *)&v977[8] = v922;
                v976.f64[0] = v919;
                v976.f64[1] = v920;
                v975.f64[1] = v958;
                x_log_();
              }
              else
              {
                v963 = x_log_category_render;
                if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_INFO))
                {
                  int v964 = v997;
                  if ((void)v997) {
                    int v964 = *(_DWORD *)(v997 + 84);
                  }
                  LODWORD(v1042[0].f64[0]) = 67112192;
                  HIDWORD(v1042[0].f64[0]) = v964;
                  LOWORD(v1042[0].f64[1]) = 1024;
                  *(_DWORD *)((char *)&v1042[0].f64[1] + 2) = LODWORD(v919);
                  HIWORD(v1042[0].f64[1]) = 1024;
                  LODWORD(v1042[1].f64[0]) = LODWORD(v920);
                  WORD2(v1042[1].f64[0]) = 1024;
                  *(_DWORD *)((char *)v1042[1].f64 + 6) = v921;
                  WORD1(v1042[1].f64[1]) = 1024;
                  HIDWORD(v1042[1].f64[1]) = v922;
                  LOWORD(v1042[2].f64[0]) = 1024;
                  *(_DWORD *)((char *)v1042[2].f64 + 2) = v1004.i32[0];
                  HIWORD(v1042[2].f64[0]) = 1024;
                  LODWORD(v1042[2].f64[1]) = v1004.i32[1];
                  WORD2(v1042[2].f64[1]) = 1024;
                  *(_DWORD *)((char *)&v1042[2].f64[1] + 6) = v1004.i32[2];
                  WORD1(v1042[3].f64[0]) = 1024;
                  HIDWORD(v1042[3].f64[0]) = v1004.i32[3];
                  LOWORD(v1042[3].f64[1]) = 1024;
                  *(_DWORD *)((char *)&v1042[3].f64[1] + 2) = v993.n128_u32[0];
                  HIWORD(v1042[3].f64[1]) = 1024;
                  LODWORD(v1042[4].f64[0]) = v993.n128_u32[1];
                  WORD2(v1042[4].f64[0]) = 1024;
                  *(_DWORD *)((char *)v1042[4].f64 + 6) = v993.n128_u32[2];
                  WORD1(v1042[4].f64[1]) = 1024;
                  HIDWORD(v1042[4].f64[1]) = v993.n128_u32[3];
                  _os_log_impl(&dword_184668000, v963, OS_LOG_TYPE_INFO, "Slot <%d> [%d %d %d %d] clipped to[%d %d %d %d] by [%d %d %d %d]", (uint8_t *)v1042, 0x50u);
                }
              }
            }
            float64_t v302 = v1002.f64[0];
            *(void *)(v1001 + 24) |= 0x40000uLL;
            unint64_t v8 = *(int32x2_t ***)&v1003.f64[0];
            uint64_t v188 = v998;
          }
        }
        else
        {
          uint32x2_t v531 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, (int32x2_t)v1004.u64[1]);
          if ((vpmax_u32(v531, v531).u32[0] & 0x80000000) == 0)
          {
            uint32x2_t v532 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)v217.i8);
            if ((vpmax_u32(v532, v532).u32[0] & 0x80000000) != 0
              || (int32x2_t v533 = vadd_s32((int32x2_t)v219.n128_u64[0], *(int32x2_t *)v217.i8),
                  v219.n128_u64[0] = (unint64_t)vmax_s32(*(int32x2_t *)v1004.i8, (int32x2_t)v219.n128_u64[0]),
                  *(int32x2_t *)v217.i8 = vsub_s32(vmin_s32(vadd_s32(*(int32x2_t *)v1004.i8, (int32x2_t)v1004.u64[1]), v533), (int32x2_t)v219.n128_u64[0]), uint32x2_t v534 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)v217.i8), (vpmax_u32(v534, v534).u32[0] & 0x80000000) != 0))
            {
              v1004.i64[1] = 0;
            }
            else
            {
              v219.n128_u64[1] = v217.i64[0];
              int8x16_t v1004 = (int8x16_t)v219;
            }
          }
        }
      }
      unsigned __int8 v224 = (int32x2_t *)v997;
      uint64_t v225 = v1001;
      if (v996.i32[0])
      {
        v1042[0] = (float64x2_t)v1004;
        CA::BoundsImpl::intersect((int32x2_t *)v1042, (*v8)[24], (*v8)[25]);
        *(double *)v217.i64 = v1008.f64[1] * v1008.f64[0];
        *(float *)v217.i32 = (float)(HIDWORD(v1042[0].f64[1]) * LODWORD(v1042[0].f64[1]))
                           / (v1008.f64[1]
                            * v1008.f64[0]);
        v219.n128_u32[0] = 1.0;
        if (*(float *)v217.i32 < 1.0)
        {
          *(void *)(v225 + 24) |= 0x40000uLL;
          float v917 = 1.0 - *(float *)v217.i32;
          if (v917 <= 1.0) {
            v219.n128_f32[0] = v917;
          }
          v217.i32[1] = 0;
          if (v219.n128_f32[0] < 0.0) {
            v219.n128_f32[0] = 0.0;
          }
          *(_DWORD *)(v225 + 272) = v219.n128_u32[0];
        }
      }
      uint64_t v535 = *(void *)(v7 + 48);
      if ((!v535 || (*(unsigned char *)(v535 + 24) & 0x20) == 0)
        && (v1039 & 8) == 0
        && (v1036.i8[13] & 0x40) == 0
        && (*(unsigned char *)(v7 + 77) & 0x40) == 0
        && (v1039 & 0x80) == 0
        && (*(_DWORD *)(*(void *)&v302 + 12) & 0x400) == 0
        && (((*v8)[135].u32[1] | ((unint64_t)(*v8)[136].u16[0] << 32)) & 0x10000000000) == 0)
      {
        uint64_t v536 = *(void *)(v188 + 56);
        if (v536)
        {
          if (CA::Shape::intersects(v536, (int32x2_t *)&v1004))
          {
            CA::Bounds::subtract_exterior(&v1004, *(const CA::Shape **)(v188 + 56));
            v1036.i64[1] |= 0x40uLL;
          }
        }
      }
      v219.n128_u64[0] = v1004.i64[0];
      if (v224)
      {
        CA::BoundsImpl::Union(v224 + 14, *(int32x2_t *)v1004.i8, (int32x2_t)v1004.u64[1]);
        v219.n128_u64[0] = v1004.i64[0];
      }
      *(void *)(v225 + 176) = v219.n128_u64[0];
      int v537 = v1004.i32[2];
      __int32 v538 = v1004.i32[3];
      *(_DWORD *)(v225 + 184) = v1004.i32[2];
      *(_DWORD *)(v225 + 188) = v538;
      if ((v1036.i8[3] & 0x10) != 0)
      {
        CA::Render::Update::invalidate_backdrops((CA::Render::Update *)*v8, (const CA::Bounds *)&v1004, *(CA::Render::BackdropState **)(v1034 + 256), LODWORD(v992.f64[0]));
        int v537 = v1004.i32[2];
        __int32 v538 = v1004.i32[3];
      }
      char v539 = LOBYTE(v990.f64[0]);
      if (v537 >= v538) {
        int v537 = v538;
      }
      if (v537 >= 1)
      {
        uint64_t v540 = (uint64_t **)*v8;
        goto LABEL_980;
      }
      uint64_t v540 = (uint64_t **)*v8;
      if ((v1039 & 4) != 0)
      {
LABEL_980:
        if ((*((_DWORD *)v540 + 271) & 4) == 0 && (*(unsigned char *)(*(void *)&v302 + 38) & 0x10) != 0)
        {
          *(void *)(v1034 + 24) |= 8uLL;
          v1039 |= 2u;
        }
      }
      else
      {
        *(void *)(v1034 + 24) |= 0x10uLL;
      }
      if (v224) {
        char v541 = v539;
      }
      else {
        char v541 = 1;
      }
      if ((v541 & 1) == 0)
      {
        v219.n128_u32[0] = *((_DWORD *)v540 + 78);
        v219.n128_f64[0] = (double)v219.n128_u64[0];
        *(double *)v217.i64 = v1006.f64[1] * v1006.f64[0];
        if (v1006.f64[1] * v1006.f64[0] >= v219.n128_f64[0]) {
          v219.n128_f64[0] = v1006.f64[1] * v1006.f64[0];
        }
        *((_DWORD *)v540 + 78) = (float)v219.n128_f64[0];
      }
      __int32 v542 = *((_DWORD *)v540 + 271);
      if ((v542 & 0x1000000) == 0) {
        goto LABEL_1059;
      }
      uint64_t v543 = *(void *)(*(void *)&v302 + 128);
      if (!v543) {
        goto LABEL_1003;
      }
      uint64_t v544 = *(void *)(v543 + 88);
      if (v544)
      {
        int v545 = *(_DWORD *)(v544 + 24);
        if ((v545 - 433) < 3 || v545 == 361 || v545 == 600) {
          goto LABEL_1058;
        }
      }
      uint64_t v546 = *(void *)(v543 + 96);
      if (!v546 || (uint64_t v547 = *(unsigned int *)(v546 + 16), !v547))
      {
LABEL_1003:
        if ((*(unsigned char *)(*(void *)&v302 + 45) & 4) != 0)
        {
          float v559 = *(float *)(*(void *)&v302 + 16);
          if (v559 < 0.0 || v559 > 1.0) {
            goto LABEL_1058;
          }
          float v561 = *(float *)(*(void *)&v302 + 20);
          if (v561 < 0.0 || v561 > 1.0) {
            goto LABEL_1058;
          }
          float v563 = *(float *)(*(void *)&v302 + 24);
          if (v563 < 0.0 || v563 > 1.0) {
            goto LABEL_1058;
          }
          float v565 = *(float *)(*(void *)&v302 + 28);
          if (v565 < 0.0 || v565 > 1.0) {
            goto LABEL_1058;
          }
        }
        if (v543)
        {
          if (*(float *)(v543 + 236) > 0.0)
          {
            float v551 = *(float *)(v543 + 240);
            BOOL v552 = v551 >= 0.0 && v551 <= 1.0;
            if (!v552) {
              goto LABEL_1058;
            }
            float v553 = *(float *)(v543 + 244);
            if (v553 < 0.0) {
              goto LABEL_1058;
            }
            if (v553 > 1.0) {
              goto LABEL_1058;
            }
            float v554 = *(float *)(v543 + 248);
            if (v554 < 0.0) {
              goto LABEL_1058;
            }
            if (v554 > 1.0) {
              goto LABEL_1058;
            }
            float v555 = *(float *)(v543 + 252);
            if (v555 < 0.0 || v555 > 1.0) {
              goto LABEL_1058;
            }
          }
          if (!*(unsigned char *)(*(void *)&v302 + 33)) {
            goto LABEL_1048;
          }
          float v557 = *(float *)(v543 + 200);
          float v556 = *(float *)(v543 + 204);
          v217.i32[0] = *(_DWORD *)(v543 + 208);
          float v558 = *(float *)(v543 + 212);
        }
        else
        {
          if (!*(unsigned char *)(*(void *)&v302 + 33)) {
            goto LABEL_1059;
          }
          v217.i64[0] = 0;
          float v558 = 1.0;
          float v556 = 0.0;
          float v557 = 0.0;
        }
        if (v557 < 0.0
          || v557 > 1.0
          || v556 < 0.0
          || v556 > 1.0
          || *(float *)v217.i32 < 0.0
          || *(float *)v217.i32 > 1.0
          || v558 < 0.0
          || v558 > 1.0)
        {
          goto LABEL_1058;
        }
        if (!v543) {
          goto LABEL_1059;
        }
LABEL_1048:
        if (*(float *)(v543 + 300) != 0.0 && *(float *)(v543 + 320) > 0.0)
        {
          float v566 = *(float *)(v543 + 304);
          if (v566 < 0.0) {
            goto LABEL_1058;
          }
          if (v566 > 1.0) {
            goto LABEL_1058;
          }
          float v567 = *(float *)(v543 + 308);
          if (v567 < 0.0) {
            goto LABEL_1058;
          }
          if (v567 > 1.0) {
            goto LABEL_1058;
          }
          float v568 = *(float *)(v543 + 312);
          if (v568 < 0.0) {
            goto LABEL_1058;
          }
          if (v568 > 1.0) {
            goto LABEL_1058;
          }
          float v569 = *(float *)(v543 + 316);
          if (v569 < 0.0 || v569 > 1.0) {
            goto LABEL_1058;
          }
        }
        goto LABEL_1059;
      }
      uint64_t v548 = v546 + 24;
      uint64_t v549 = v548 + 8 * v547;
LABEL_999:
      uint64_t v550 = 0;
      while (*(_DWORD *)(*(void *)v548 + 24) != (unsigned __int16)CA::Render::Updater::layer_may_leave_P3(CA::Render::Layer const*)::atoms[v550])
      {
        if (++v550 == 9)
        {
          v548 += 8;
          if (v548 != v549) {
            goto LABEL_999;
          }
          goto LABEL_1003;
        }
      }
LABEL_1058:
      v1036.i64[1] |= 0x100000000uLL;
      CA::shape_union((CA::Shape **)v540 + 6, (CA::Shape **)&v1004, v337);
      uint64_t v540 = (uint64_t **)*v8;
      __int32 v542 = (*v8)[135].i32[1];
LABEL_1059:
      if ((v542 & 0x2000000) != 0 && (*(unsigned char *)(*(void *)&v302 + 45) & 0x20) != 0)
      {
        v1036.i64[1] |= 4uLL;
        CA::shape_union((CA::Shape **)v540 + 7, (CA::Shape **)&v1004, v337);
      }
LABEL_1062:
      unsigned __int8 v570 = v1039;
      if ((v1039 & 4) != 0) {
        *(void *)(v225 + 24) |= 0x80000uLL;
      }
      v571 = (uint64_t **)*v8;
      uint64_t v572 = v1034;
      *(_DWORD *)(v1034 + 112) = (*v8)[64].i32[0];
      if (*(void *)(v572 + 256) && (*(unsigned char *)(v572 + 24) & 0x10) == 0)
      {
        uint64_t v573 = v1030;
        v574 = (uint64_t *)(v571 + 63);
        unint64_t v575 = v571 + 63;
        while (1)
        {
          unint64_t v575 = (void *)*v575;
          if (!v575) {
            break;
          }
          if (v575[1] == v572) {
            goto LABEL_1102;
          }
        }
        uint8x8_t v576 = *(uint64_t **)(*(void *)(v572 + 32) + 128);
        if (v576 && (uint64_t v577 = *v576) != 0)
        {
          if (*(unsigned char *)(v577 + 12) == 3) {
            uint64_t v578 = v577;
          }
          else {
            uint64_t v578 = 0;
          }
        }
        else
        {
          uint64_t v578 = 0;
        }
        uint64_t v579 = x_heap_malloc_small_(*v571, 0x68uLL);
        uint64_t v580 = v579;
        if (v579)
        {
          *(void *)uint64_t v579 = 0;
          atomic_fetch_add((atomic_uint *volatile)(v572 + 16), 1u);
          *(void *)(v579 + 8) = v572;
          *(void *)(v579 + 88) = 0;
          *(void *)(v579 + 32) = 0;
          *(void *)(v579 + 40) = 0;
          *(void *)(v579 + 24) = 0;
          *(_DWORD *)(v579 + 96) |= 0x20000000u;
        }
        int v581 = *((_DWORD *)v571 + 128) + 1;
        *((_DWORD *)v571 + 128) = v581;
        unsigned int v582 = *(_DWORD *)(v579 + 96) & 0xF0000000 | v581 & 0xFFFFFFF;
        *(_DWORD *)(v579 + 96) = v582;
        *(_DWORD *)(v579 + 100) = *(_DWORD *)(v578 + 40);
        unsigned int v583 = v582 & 0xEFFFFFFF | (((*(_DWORD *)(v578 + 12) >> 12) & 1) << 28);
        *(_DWORD *)(v579 + 96) = v583;
        *(_DWORD *)(v579 + 96) = v583 & 0x9FFFFFFF | (((*(_DWORD *)(v578 + 12) >> 8) & 1) << 29);
        *(void *)(v579 + 40) = CA::Shape::ref((unint64_t)v571[65]);
        __n128 v219 = (__n128)v1031;
        int32x4_t v217 = v1032;
        *(float64x2_t *)(v580 + 48) = v1031;
        *(int32x4_t *)(v580 + 64) = v217;
        *(unsigned char *)(v580 + 80) = v1033;
        if (v573)
        {
          unint64_t v584 = *v571;
          v1042[0].f64[0] = 0.0;
          v585 = v1042;
          do
          {
            if (!*((unsigned char *)v573 + 18))
            {
              uint64_t v586 = (*((uint64_t (**)(void **, uint64_t *))*v573 + 2))(v573, v584);
              if (v586)
              {
                *(void *)&v585->f64[0] = v586;
                *(void *)(v586 + 8) = 0;
                v585 = (float64x2_t *)(v586 + 8);
              }
            }
            uint64_t v573 = (void **)v573[1];
          }
          while (v573);
          *(float64_t *)(v580 + 88) = v1042[0].f64[0];
          uint64_t v188 = v998;
        }
        ++*(_DWORD *)(v572 + 112);
        uint64_t v587 = *(void *)(*(void *)(v572 + 256) + 40);
        uint64_t v588 = (uint64_t)(v571 + 68);
        unint64_t v8 = *(int32x2_t ***)&v1003.f64[0];
        do
        {
          uint64_t v588 = *(void *)v588;
          if (!v588)
          {
            uint64_t v588 = x_heap_malloc_small_(*v571, 0x30uLL);
            *(void *)(v588 + 8) = v587;
            *(void *)(v588 + 16) = 0;
            *(void *)(v588 + 32) = 0;
            *(_DWORD *)(v588 + 40) = 0;
            *(void *)uint64_t v588 = v571[68];
            v571[68] = (uint64_t *)v588;
            goto LABEL_1096;
          }
        }
        while (*(void *)(v588 + 8) != v587);
        uint64_t v589 = *(CA::Shape **)(v588 + 16);
        if (v589)
        {
          CA::Shape::unref(v589);
          *(void *)(v588 + 16) = 0;
        }
        v590 = (void *)*v574;
        if (*v574)
        {
          do
          {
            if (v590[2] == v588)
            {
              v590[3] = 0;
              v590[4] = 0;
            }
            v590 = (void *)*v590;
          }
          while (v590);
        }
LABEL_1096:
        *(void *)(v580 + 16) = v588;
        *(void *)uint64_t v580 = *v574;
        uint64_t *v574 = v580;
        ++*(_DWORD *)(v588 + 40);
        uint64_t v591 = (CA::Render::LayerNode *)v572;
        if (*(void *)(v588 + 32)) {
          uint64_t v591 = CA::Render::LayerNode::shared_ancestor(*(CA::Render::LayerNode **)(v588 + 32), (CA::Render::LayerNode *)v572);
        }
        *(void *)(v588 + 32) = v591;
        char v592 = *(unsigned char *)(v580 + 99);
        uint64_t v225 = v1001;
        if ((v592 & 0x20) != 0)
        {
          if (*(void *)(v587 + 520))
          {
            uint64_t v593 = v571[74];
            atomic_fetch_add((atomic_uint *volatile)(v572 + 16), 1u);
            malloc_zone = (malloc_zone_t *)get_malloc_zone();
            v595 = (uint64_t *)malloc_type_zone_malloc(malloc_zone, 0x10uLL, 0x8BB15036uLL);
            uint64_t *v595 = v572;
            v595[1] = (uint64_t)v593;
            unint64_t v8 = *(int32x2_t ***)&v1003.f64[0];
            v571[74] = v595;
            v596 = *(CA::Shape **)(v587 + 520);
            if (v596)
            {
              CA::Shape::unref(v596);
              *(void *)(v587 + 520) = 0;
            }
          }
        }
LABEL_1102:
        uint64_t v572 = v1034;
        v1036.i64[1] |= 0x400000000004uLL;
        unsigned __int8 v570 = v1039;
        unsigned __int8 v224 = (int32x2_t *)v997;
        float64_t v302 = v1002.f64[0];
      }
      if ((*(unsigned char *)(v572 + 24) & 0x10) == 0)
      {
        if ((v570 & 0x20) != 0 && ((*v8)[135].i32[1] & 0x800) != 0)
        {
          uint64_t v1044 = 0;
          v1042[0] = (float64x2_t)xmmword_184997D50;
          v1042[1] = 0u;
          v1042[2] = (float64x2_t)xmmword_184997D60;
          memset(&v1042[3], 0, 32);
          v1042[5] = (float64x2_t)xmmword_184997D50;
          v1043[0] = 0u;
          v1043[1] = xmmword_184997D60;
          __asm { FMOV            V0.2D, #1.0 }
          v1043[2] = _Q0;
          float64x2_t v598 = CA::Transform::concat((uint64_t)v1042, (uint64_t)&v1031);
          v599 = v1030;
          if (!v1030) {
            goto LABEL_1109;
          }
          do
          {
            (*((void (**)(void **, float64x2_t *, float64x2_t))*v599 + 7))(v599, v1042, v598);
            v599 = (void **)v599[1];
          }
          while (v599);
          uint64_t v572 = v1034;
          if (!v1034)
          {
            unsigned int v600 = 255;
          }
          else
          {
LABEL_1109:
            unsigned int v600 = 255;
            do
            {
              unsigned int v600 = (v600 + v600 * *(unsigned __int8 *)(v572 + 116)) >> 8;
              uint64_t v572 = *(void *)(v572 + 88);
            }
            while (v572);
          }
          uint64_t v601 = **(void **)(*(void *)&v302 + 128);
          if (*(unsigned char *)(v601 + 12) != 6) {
            uint64_t v601 = 0;
          }
          uint64_t v602 = (uint64_t **)*v8;
          uint64_t v603 = *(const void **)(v601 + 16);
          int8x16_t v996 = (int8x16_t)v1042[0];
          float64x2_t v992 = v1042[2];
          __n128 v993 = (__n128)v1042[1];
          float64x2_t v989 = v1042[4];
          float64x2_t v990 = v1042[3];
          __n128 v987 = (__n128)v1043[0];
          float64x2_t v988 = v1042[5];
          long long v985 = v1043[1];
          float v604 = (float)v600;
          uint64_t v605 = x_heap_malloc_small_(*v602, 0xC8uLL);
          *(void *)uint64_t v605 = v602[127];
          if (v603) {
            CFTypeRef v606 = CFRetain(v603);
          }
          else {
            CFTypeRef v606 = 0;
          }
          float v607 = v604 * 0.0039216;
          *(void *)(v605 + 8) = v606;
          *(_OWORD *)(v605 + 16) = *(_OWORD *)(*(void *)&v302 + 64);
          int8x16_t v608 = v996;
          *(_OWORD *)(v605 + 32) = *(_OWORD *)(*(void *)&v302 + 80);
          *(int8x16_t *)(v605 + 48) = v608;
          float64x2_t v609 = v992;
          *(__n128 *)(v605 + 64) = v993;
          *(float64x2_t *)(v605 + 80) = v609;
          float64x2_t v610 = v989;
          *(float64x2_t *)(v605 + 96) = v990;
          *(float64x2_t *)(v605 + 112) = v610;
          int32x4_t v217 = (int32x4_t)v987;
          *(float64x2_t *)(v605 + 128) = v988;
          *(int32x4_t *)(v605 + 144) = v217;
          v217.i64[1] = *((void *)&v985 + 1);
          *(_OWORD *)(v605 + 160) = v985;
          uint64_t v611 = *(void *)(*(void *)&v302 + 128);
          v217.i32[0] = 0;
          if (v611) {
            v217.i32[0] = *(_DWORD *)(v611 + 228);
          }
          *(double *)v217.i64 = *(float *)v217.i32;
          *(void *)(v605 + 176) = v217.i64[0];
          *(float *)(v605 + 184) = v607;
          LOBYTE(v607) = *(unsigned char *)(*(void *)&v302 + 32);
          *(float *)(v605 + 188) = (float)LODWORD(v607) * 0.0039216;
          *(unsigned char *)(v605 + 192) = (*(void *)(*(void *)&v302 + 40) & 3) != 0;
          v602[127] = (uint64_t *)v605;
          v1036.i64[1] |= 4uLL;
          unsigned __int8 v570 = v1039;
          unsigned __int8 v224 = (int32x2_t *)v997;
        }
        if ((v570 & 0x40) != 0 && ((*v8)[135].i32[1] & 0x1000) != 0)
        {
          uint64_t v1044 = 0;
          v1042[0] = (float64x2_t)xmmword_184997D50;
          v1042[1] = 0u;
          v1042[2] = (float64x2_t)xmmword_184997D60;
          memset(&v1042[3], 0, 32);
          v1042[5] = (float64x2_t)xmmword_184997D50;
          v1043[0] = 0u;
          v1043[1] = xmmword_184997D60;
          __asm { FMOV            V0.2D, #1.0 }
          v1043[2] = _Q0;
          float64x2_t v614 = CA::Transform::concat((uint64_t)v1042, (uint64_t)&v1031);
          for (k = v1030; k; k = (void **)k[1])
            (*((void (**)(void **, float64x2_t *, float64x2_t))*k + 7))(k, v1042, v614);
          uint64_t v616 = v1034;
          if (v1034)
          {
            unsigned int v617 = 255;
            do
            {
              unsigned int v617 = (v617 + v617 * *(unsigned __int8 *)(v616 + 116)) >> 8;
              uint64_t v616 = *(void *)(v616 + 88);
            }
            while (v616);
          }
          else
          {
            unsigned int v617 = 255;
          }
          float64x2_t v618 = *(float64x2_t *)(*(void *)&v302 + 80);
          float64x2_t v1022 = *(float64x2_t *)(*(void *)&v302 + 64);
          float64x2_t v1023 = v618;
          CA::Rect::apply_transform((int8x16_t *)&v1022, (const CA::Transform *)v1042, v613);
          int8x16_t v996 = (int8x16_t)vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v1022), v1023);
          memset(v1029, 0, sizeof(v1029));
          long long v1027 = 0u;
          long long v1028 = 0u;
          float64x2_t v1025 = 0u;
          long long v1026 = 0u;
          float64x2_t v1024 = 0u;
          CA::Mat4Impl::mat4_get_unmatrix(v1042[0].f64, (uint64_t)&v1024, 0);
          uint64_t v619 = *(void *)(*(void *)(*(void *)&v302 + 128) + 96);
          float v620 = 0.0;
          if (v619 && *(_DWORD *)(v619 + 16))
          {
            uint64_t v621 = *(void *)(v619 + 24);
            if (*(_DWORD *)(v621 + 24) == 247)
            {
              float v620 = CA::Render::KeyValueArray::get_float_key(*(CA::Render::KeyValueArray **)(v621 + 40), 310, 0.0);
            }
            else if (x_log_hook_p())
            {
              *(void *)&v977[72] = [(__CFString *)CAAtomGetString(*(_DWORD *)(v621 + 24)) cStringUsingEncoding:4];
              x_log_();
            }
            else
            {
              uint64_t v622 = x_log_category_render;
              if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
              {
                uint64_t v623 = [(__CFString *)CAAtomGetString(*(_DWORD *)(v621 + 24)) cStringUsingEncoding:4];
                v1040[0].i32[0] = 136315138;
                *(uint64_t *)((char *)v1040[0].i64 + 4) = v623;
                _os_log_impl(&dword_184668000, v622, OS_LOG_TYPE_ERROR, "Unsupported filter %s for SIL", (uint8_t *)v1040, 0xCu);
              }
            }
            unint64_t v8 = *(int32x2_t ***)&v1003.f64[0];
          }
          uint64_t v624 = **(void **)(*(void *)&v302 + 128);
          if (*(unsigned char *)(v624 + 12) != 45) {
            uint64_t v624 = 0;
          }
          v1040[0].i64[0] = v1034;
          *(int8x16_t *)((char *)v1040 + 8) = v996;
          *(float *)&__int32 v625 = *(double *)&v1029[5];
          v1040[1].i32[2] = v625;
          *(float *)&v1040[1].i32[3] = (float)v617 * 0.0039216;
          int8x16_t v1041 = (int8x16_t)LODWORD(v620);
          unsigned int v626 = *(_DWORD *)(v624 + 16);
          v1041.i32[1] = v626;
          v1041.i16[4] = *(_WORD *)(v624 + 20);
          v627 = (uint64_t **)*v8;
          uint64_t v628 = (uint64_t *)(*v8)[128];
          uint64_t v629 = (uint64_t *)(*v8)[129];
          if (v628 != v629) {
            goto LABEL_1142;
          }
          uint64_t v629 = (uint64_t *)(*v8)[128];
          uint64_t v632 = (__n128 *)v629;
          if (0xAAAAAAAAAAAAAAABLL * (((char *)v627[130] - (char *)v628) >> 4) <= 3)
          {
            uint64_t v629 = (uint64_t *)operator new(0xC0uLL);
            int8x16_t v634 = v627[129];
            unsigned int v635 = v627[128];
            uint64_t v628 = v629;
            if (v634 != v635)
            {
              do
              {
                long long v636 = *((_OWORD *)v634 - 3);
                long long v637 = *((_OWORD *)v634 - 2);
                *(_OWORD *)((char *)v628 - 21) = *(_OWORD *)((char *)v634 - 21);
                *((_OWORD *)v628 - 3) = v636;
                *((_OWORD *)v628 - 2) = v637;
                v628 -= 6;
                v634 -= 6;
              }
              while (v634 != v635);
              int8x16_t v634 = v627[128];
            }
            v627[128] = v628;
            v627[129] = v629;
            v627[130] = v629 + 24;
            if (v634)
            {
              operator delete(v634);
              unsigned int v626 = v1041.u32[1];
              uint64_t v628 = v627[128];
              uint64_t v629 = v627[129];
            }
LABEL_1142:
            if (v626 >= 3) {
              unsigned int v630 = 3;
            }
            else {
              unsigned int v630 = v626;
            }
            if (v628 == v629)
            {
LABEL_1151:
              uint64_t v632 = (__n128 *)v629;
            }
            else
            {
              unsigned int v631 = CA::WindowServer::SILMgr::indicator_priority::priorities[v630];
              uint64_t v632 = (__n128 *)v628;
              while (1)
              {
                unsigned int v633 = v632[2].n128_u32[1];
                if (v633 >= 3) {
                  unsigned int v633 = 3;
                }
                if (v631 > CA::WindowServer::SILMgr::indicator_priority::priorities[v633]) {
                  break;
                }
                v632 += 3;
                if (v632 == (__n128 *)v629) {
                  goto LABEL_1151;
                }
              }
            }
          }
          int8x16_t v638 = v627[130];
          uint64_t v986 = v7;
          if (v629 >= v638)
          {
            unint64_t v645 = 0xAAAAAAAAAAAAAAABLL * (((char *)v629 - (char *)v628) >> 4) + 1;
            if (v645 > 0x555555555555555) {
              abort();
            }
            int64_t v646 = 0xAAAAAAAAAAAAAAABLL * (((char *)v632 - (char *)v628) >> 4);
            unint64_t v647 = 0xAAAAAAAAAAAAAAABLL * (((char *)v638 - (char *)v628) >> 4);
            if (2 * v647 > v645) {
              unint64_t v645 = 2 * v647;
            }
            if (v647 >= 0x2AAAAAAAAAAAAAALL) {
              unint64_t v648 = 0x555555555555555;
            }
            else {
              unint64_t v648 = v645;
            }
            if (v648)
            {
              v649 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Render::Update::SecureIndicator>>(v648);
            }
            else
            {
              v649 = 0;
              uint64_t v111 = 0;
            }
            v651 = (int8x16_t *)&v649[16 * (((char *)v632 - (char *)v628) >> 4)];
            uint64_t v652 = (uint64_t *)&v649[48 * v111];
            if (v646 == v111)
            {
              if ((char *)v632 - (char *)v628 < 1)
              {
                if (v628 == (uint64_t *)v632) {
                  unint64_t v654 = 1;
                }
                else {
                  unint64_t v654 = 0x5555555555555556 * (((char *)v632 - (char *)v628) >> 4);
                }
                unint64_t v655 = v654 >> 2;
                uint64_t v656 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CA::Render::Update::SecureIndicator>>(v654);
                v651 = (int8x16_t *)&v656[48 * v655];
                uint64_t v652 = (uint64_t *)&v656[48 * v111];
                if (v649) {
                  operator delete(v649);
                }
              }
              else
              {
                uint64_t v653 = v646 + 2;
                if (v646 >= -1) {
                  uint64_t v653 = v646 + 1;
                }
                v651 -= 3 * (v653 >> 1);
              }
            }
            __n128 v219 = (__n128)v1040[0];
            int32x4_t v217 = (int32x4_t)v1040[1];
            int8x16_t v657 = v1041;
            v651[1] = v1040[1];
            v651[2] = v657;
            int8x16_t *v651 = (int8x16_t)v219;
            v658 = v627[128];
            i64 = (uint64_t *)v651;
            if (v658 != (uint64_t *)v632)
            {
              char v660 = v632;
              int v661 = v651;
              do
              {
                __n128 v219 = v660[-3];
                int32x4_t v217 = (int32x4_t)v660[-2];
                i64 = v661[-3].i64;
                *(int8x16_t *)((char *)v661 - 21) = *(int8x16_t *)((char *)&v660[-2] + 11);
                v661[-3] = (int8x16_t)v219;
                v661[-2] = (int8x16_t)v217;
                v660 -= 3;
                v661 -= 3;
              }
              while (v660 != (__n128 *)v658);
            }
            int v662 = v651 + 3;
            int v663 = v627[129];
            int64_t v664 = (char *)v663 - (char *)v632;
            if (v663 != (uint64_t *)v632) {
              memmove(v662, v632, v664 - 5);
            }
            int v665 = v627[128];
            v627[128] = i64;
            v627[129] = (uint64_t *)((char *)v662->i64 + v664);
            v627[130] = v652;
            if (v665) {
              operator delete(v665);
            }
          }
          else if (v632 == (__n128 *)v629)
          {
            __n128 v219 = (__n128)v1040[0];
            int32x4_t v217 = (int32x4_t)v1040[1];
            int8x16_t v650 = v1041;
            *((int8x16_t *)v629 + 1) = v1040[1];
            *((int8x16_t *)v629 + 2) = v650;
            *(__n128 *)uint64_t v629 = v219;
            v627[129] = v629 + 6;
          }
          else
          {
            double v639 = v632 + 3;
            uint64_t v640 = v629 - 6;
            unint64_t v641 = v629;
            if ((unint64_t)v629 >= 0x30)
            {
              unint64_t v641 = v629;
              do
              {
                long long v642 = *(_OWORD *)v640;
                long long v643 = *((_OWORD *)v640 + 2);
                *((_OWORD *)v641 + 1) = *((_OWORD *)v640 + 1);
                *((_OWORD *)v641 + 2) = v643;
                *(_OWORD *)unint64_t v641 = v642;
                v641 += 6;
                v640 += 6;
              }
              while (v640 < v629);
            }
            v627[129] = v641;
            if (v629 != (uint64_t *)v639) {
              memmove(v639, v632, (char *)v629 - (char *)v639 - 5);
            }
            double v644 = v1040;
            if (v632 <= (__n128 *)v1040) {
              double v644 = &v1040[3 * (v627[129] > (uint64_t *)v1040)];
            }
            __n128 v219 = *(__n128 *)v644;
            int32x4_t v217 = (int32x4_t)v644[1];
            *(__n128 *)((char *)v632 + 27) = *(__n128 *)((char *)&v644[1] + 11);
            *uint64_t v632 = v219;
            v632[1] = (__n128)v217;
          }
          v666 = v627[128];
          if (v627[129] != v666)
          {
            uint64_t v667 = 0;
            unsigned int v668 = 0;
            uint64_t v669 = MEMORY[0x1E4F97AD8];
            unsigned int v670 = 1;
            do
            {
              if (v669) {
                int v671 = SILManagerIndicatorExtent();
              }
              else {
                int v671 = 20;
              }
              v668 += v671;
              if (v670 - 1 > 3 || v668 >= 0x101)
              {
                v672 = &v666[6 * v667];
                *((unsigned char *)v672 + 42) = 1;
                uint64_t v673 = *v672;
                *(void *)(v673 + 24) |= 0x100000000uLL;
                uint64_t v674 = *(CA::Render::Object **)(v673 + 40);
                if (v674) {
                  CA::Render::Handle::set_update_flags(v674, 3);
                }
              }
              uint64_t v667 = v670;
              v666 = v627[128];
              BOOL v552 = 0xAAAAAAAAAAAAAAABLL * (((char *)v627[129] - (char *)v666) >> 4) > v670++;
            }
            while (v552);
          }
          v1036.i64[1] |= 4uLL;
          unsigned __int8 v570 = v1039;
          uint64_t v7 = v986;
          unint64_t v8 = *(int32x2_t ***)&v1003.f64[0];
          unsigned __int8 v224 = (int32x2_t *)v997;
          uint64_t v188 = v998;
          uint64_t v225 = v1001;
          float64_t v302 = v1002.f64[0];
        }
      }
      if ((v570 & 0x80) != 0)
      {
        uint64_t v1044 = 0;
        v1042[0] = (float64x2_t)xmmword_184997D50;
        v1042[1] = 0u;
        v1042[2] = (float64x2_t)xmmword_184997D60;
        memset(&v1042[3], 0, 32);
        v1042[5] = (float64x2_t)xmmword_184997D50;
        v1043[0] = 0u;
        v1043[1] = xmmword_184997D60;
        __asm { FMOV            V0.2D, #1.0 }
        v1043[2] = _Q0;
        __n128 v219 = (__n128)CA::Transform::concat((uint64_t)v1042, (uint64_t)&v1031);
        for (m = v1030; m; m = (void **)m[1])
          (*((void (**)(void **, float64x2_t *, __n128))*m + 7))(m, v1042, v219);
        if (!BYTE9(xmmword_1EB2ACC50))
        {
          int v677 = *(uint64_t **)(*(void *)&v302 + 128);
          if (v677)
          {
            uint64_t v678 = *v677;
            if (v678)
            {
              if (*(unsigned char *)(v678 + 12) == 19 && *(unsigned char *)(v678 + 16))
              {
                int v679 = (uint64_t **)*v8;
                int v680 = (void *)x_heap_malloc_small_(*(uint64_t **)*v8, 0xB0uLL);
                v681 = v680;
                *int v680 = v679[131];
                float64_t v682 = v302;
                if (!atomic_fetch_add((atomic_uint *volatile)(*(void *)&v302 + 8), 1u))
                {
                  float64_t v682 = 0.0;
                  atomic_fetch_add((atomic_uint *volatile)(*(void *)&v302 + 8), 0xFFFFFFFF);
                }
                *((float64_t *)v680 + 1) = v682;
                __n128 v219 = CA::Transform::operator=((uint64_t)(v680 + 2), (uint64_t)v1042);
                *((unsigned char *)v681 + 168) = 0;
                unint64_t v683 = *(uint64_t **)(*(void *)&v302 + 128);
                if (v683)
                {
                  uint64_t v684 = *v683;
                  if (v684)
                  {
                    if (*(unsigned char *)(v684 + 12) == 19) {
                      *((unsigned char *)v681 + 168) = *(unsigned char *)(v684 + 16) == 2;
                    }
                  }
                }
                v679[131] = v681;
              }
            }
          }
        }
        v1036.i64[1] |= 4uLL;
      }
      if ((v1036.i8[0] & 2) == 0) {
        goto LABEL_1236;
      }
      unsigned int v685 = (uint64_t **)*v8;
      if (((*v8)[135].i32[1] & 4) != 0) {
        goto LABEL_1236;
      }
      uint64_t v686 = v1034;
      if (v224)
      {
        *(void *)&v224[12] &= ~2uLL;
        uint64_t v687 = *(void *)(v686 + 24);
        if ((v687 & 0x40) != 0)
        {
          if ((v687 & 0x10) == 0 && (*(unsigned char *)(v7 + 64) & 2) == 0)
          {
            unsigned int v688 = (CA::Render::Context *)v8[2];
            unsigned int v689 = v224 + 14;
            goto LABEL_1235;
          }
          goto LABEL_1236;
        }
      }
      else
      {
        uint64_t v687 = *(void *)(v1034 + 24);
      }
      if ((v687 & 0x10) == 0)
      {
        __n128 v219 = (__n128)v1008;
        int64x2_t v690 = vclezq_f64(v1008);
        int32x4_t v217 = (int32x4_t)vorrq_s8((int8x16_t)vdupq_laneq_s64(v690, 1), (int8x16_t)v690);
        if ((v217.i64[0] & 0x8000000000000000) == 0)
        {
          int32x4_t v217 = (int32x4_t)v1016;
          int64x2_t v691 = vclezq_f64((float64x2_t)v1016);
          if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v691, 1), (int8x16_t)v691).u64[0] & 0x8000000000000000) == 0)
          {
            __n128 v219 = (__n128)vmaxnmq_f64(v1007, v1015);
            int32x4_t v217 = (int32x4_t)vsubq_f64(vminnmq_f64(vaddq_f64(v1007, v1008), vaddq_f64(v1015, (float64x2_t)v1016)), (float64x2_t)v219);
            int64x2_t v692 = vclezq_f64((float64x2_t)v217);
            if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v692, 1), (int8x16_t)v692).u64[0] & 0x8000000000000000) == 0)
            {
              v1042[0] = 0uLL;
              CA::Bounds::set_exterior((int32x4_t *)v1042, (const Rect *)v111, (float64x2_t)v219, (float64x2_t)v217);
              unsigned int v688 = (CA::Render::Context *)v8[2];
              unsigned int v689 = (int32x2_t *)v1042;
LABEL_1235:
              CA::Render::Update::invalidate_context((CA::Render::Update *)v685, v688, v689);
            }
          }
        }
      }
LABEL_1236:
      if (CADeviceSupportsHDRProcessing::once[0] != -1) {
        dispatch_once(CADeviceSupportsHDRProcessing::once, &__block_literal_global_175);
      }
      if (!CADeviceSupportsHDRProcessing::supports_hdr) {
        goto LABEL_1366;
      }
      if ((*(unsigned char *)(v225 + 27) & 2) != 0) {
        goto LABEL_1366;
      }
      if ((*(unsigned char *)(v1034 + 24) & 0x10) != 0) {
        goto LABEL_1366;
      }
      char v693 = (void *)*((void *)v1035 + 12);
      if (!v693 || *((unsigned char *)v693 + 12) != 25) {
        goto LABEL_1366;
      }
      unint64_t v694 = (CA::Render::Context *)v8[3];
      if ((*(unsigned char *)(*(void *)&v302 + 13) & 4) != 0)
      {
        v699 = (CA::Render::Context *)*((unsigned int *)v693 + 50);
        if (v699)
        {
          uint64_t v696 = CA::Render::Context::context_by_id(v699);
          if (v696) {
            goto LABEL_1250;
          }
          unint64_t v694 = 0;
          goto LABEL_1294;
        }
LABEL_1251:
        uint64_t v696 = 0;
LABEL_1294:
        int v697 = 1;
        goto LABEL_1295;
      }
      uint64_t v695 = *(void *)(*(void *)&v302 + 144);
      if (!v695) {
        goto LABEL_1251;
      }
      uint64_t v696 = *(void *)(v695 + 24);
      int v697 = 1;
      if (v696)
      {
        double v698 = (atomic_uint *)(v696 + 8);
        if (!atomic_fetch_add((atomic_uint *volatile)(v696 + 8), 1u))
        {
          unint64_t v694 = 0;
          uint64_t v696 = 0;
          atomic_fetch_add(v698, 0xFFFFFFFF);
          goto LABEL_1294;
        }
LABEL_1250:
        pthread_mutex_lock((pthread_mutex_t *)(v696 + 72));
        int v697 = 0;
        unint64_t v694 = (CA::Render::Context *)v696;
      }
LABEL_1295:
      v996.i32[0] = v697;
      if (v224) {
        int v731 = v224[12].u8[1] >> 7;
      }
      else {
        int v731 = 0;
      }
      uint64_t v732 = (CA::Render::Texture *)(*(uint64_t (**)(void *))(*v693 + 80))(v693);
      if (v732)
      {
        uint64_t v1044 = 0;
        v1042[0] = (float64x2_t)xmmword_184997D50;
        v1042[1] = 0u;
        v1042[2] = (float64x2_t)xmmword_184997D60;
        memset(&v1042[3], 0, 32);
        v1042[5] = (float64x2_t)xmmword_184997D50;
        v1043[0] = 0u;
        v1043[1] = xmmword_184997D60;
        __asm { FMOV            V0.2D, #1.0 }
        v1043[2] = _Q0;
        float v735 = 1.0;
        if (!BYTE10(xmmword_1EB2ACC30)
          && ((*v8)[135].i32[1] & 0x100000) != 0
          && CA::Render::Layer::append_texture_transform(*(CA::Render::Layer **)&v1002.f64[0], (CA::Transform *)v1042, v732, (CA::Render::Object *)v693))
        {
          float64x2_t v737 = CA::Transform::concat((uint64_t)v1042, (uint64_t)&v1031);
          for (n = v1030; n; n = (void **)n[1])
            (*((void (**)(void **, float64x2_t *, float64x2_t))*n + 7))(n, v1042, v737);
          int rotation_flags = CA::Render::Updater::get_rotation_flags((CA::Render::Updater *)v1042, v736);
          if ((v1044 & 0x10) == 0
            && ((unsigned __int16)*(_DWORD *)(*(void *)&v1002.f64[0] + 36) >> 12) - 9 <= 2)
          {
            float v735 = *(double *)&v1043[2];
          }
        }
        else
        {
          int rotation_flags = -1;
        }
      }
      else
      {
        int rotation_flags = -1;
        float v735 = 1.0;
      }
      if (byte_1EB2ACC41) {
        int v740 = 1;
      }
      else {
        int v740 = (*(unsigned __int8 *)(*(void *)&v1002.f64[0] + 43) >> 4) & 1;
      }
      LOBYTE(v1042[0].f64[0]) = 0;
      int v741 = CA::Render::ImageQueue::forward_dm((os_unfair_lock_s *)v693, v694, (CA::Render::Update *)*v8, v735, rotation_flags, v740, v1042, v733);
      if (LOBYTE(v1042[0].f64[0])) {
        *(void *)(v7 + 64) |= 2uLL;
      }
      uint64_t v742 = *(void *)(*(void *)(v693[2] + 24) + 128);
      BOOL v745 = ((v742 & 0x7FFFFFFFFFFFFFFFuLL) - 0x10000000000000) >> 53 > 0x3FE
          && (v742 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000001
          && v742 != 0xFFF0000000000000
          && (v742 & 0x7FFFFFFFFFFFFFFFuLL) - 1 > 0xFFFFFFFFFFFFELL;
      uint64_t v188 = v998;
      if (v745) {
        goto LABEL_1327;
      }
      if (*(double *)(*(void *)(v693[2] + 24) + 128) >= *(double *)&(*v8)[9])
      {
        v1036.i64[1] |= 4uLL;
LABEL_1327:
        if ((v741 & 1) == 0) {
          goto LABEL_1335;
        }
        if ((v740 & 1) == 0)
        {
          if (v731) {
            uint64_t v746 = v1036.i64[1] | 0x2000000000;
          }
          else {
            uint64_t v746 = v1036.i64[1] | 0x800000000;
          }
          goto LABEL_1334;
        }
        if (v731) {
          goto LABEL_1335;
        }
LABEL_1330:
        uint64_t v746 = v1036.i64[1] | 0x4000000000000;
LABEL_1334:
        v1036.i64[1] = v746;
        goto LABEL_1335;
      }
      if (((v741 ^ 1 | v731) & 1) == 0) {
        goto LABEL_1330;
      }
LABEL_1335:
      CA::Render::ImageQueue::pse_mitigate((CA::Render::ImageQueue *)v693, (CA::Render::Update *)*v8);
      int is_protected = CA::Render::ImageQueue::is_protected((CA::Render::ImageQueue *)v693);
      uint64_t v748 = v1001;
      if (is_protected)
      {
        uint64_t v749 = v693[8];
        if (v749) {
          goto LABEL_1338;
        }
        uint64_t v749 = v693[10];
        if (v749) {
          goto LABEL_1338;
        }
        if (v693[3])
        {
          uint64_t v749 = v693[10];
          if (!v749) {
            uint64_t v749 = v693[3];
          }
LABEL_1338:
          uint64_t v750 = (*(uint64_t (**)(uint64_t))(*(void *)v749 + 240))(v749);
          v1036.i64[1] |= (v750 << 47) & 0x3000000000000 | 0x800000000000;
        }
      }
      if ((v996.i8[0] & 1) == 0)
      {
        pthread_mutex_unlock((pthread_mutex_t *)(v696 + 72));
        if (atomic_fetch_add((atomic_uint *volatile)(v696 + 8), 0xFFFFFFFF) == 1) {
          (*(void (**)(uint64_t))(*(void *)v696 + 16))(v696);
        }
      }
      BOOL v751 = *(atomic_uint **)(v748 + 48);
      float64_t v302 = v1002.f64[0];
      if (v751)
      {
        if (atomic_fetch_add(v751 + 2, 0xFFFFFFFF) == 1) {
          (*(void (**)(atomic_uint *))(*(void *)v751 + 16))(v751);
        }
        *(void *)(v748 + 48) = 0;
      }
      uint64_t v752 = (*(uint64_t (**)(void *))(*v693 + 80))(v693);
      if (v752)
      {
        uint64_t v753 = v752;
        uint64_t v754 = v752;
        if (!atomic_fetch_add((atomic_uint *volatile)(v752 + 8), 1u))
        {
          uint64_t v754 = 0;
          atomic_fetch_add((atomic_uint *volatile)(v752 + 8), 0xFFFFFFFF);
        }
        *(void *)(v1001 + 48) = v754;
        uint64_t v755 = (uint64_t **)*v8;
        __int8 v756 = (*v8)[50].i8[5];
        int v757 = BYTE9(xmmword_1EB2ACC10);
        int v758 = (*v8)[50].u8[7];
        int v759 = (v758 | v756);
        if (v759 | BYTE9(xmmword_1EB2ACC10) && *(unsigned char *)(v752 + 12) == 51 && v693[2])
        {
          if (v759)
          {
            double v760 = *(const void **)(v752 + 144);
            if (v760)
            {
              X::CFRef<__CFData const*>::operator=((const void **)v755 + 112, v760);
              v1036.i64[1] |= 4uLL;
              uint64_t v755 = **(uint64_t ****)&v1003.f64[0];
            }
            if ((*((_DWORD *)v755 + 103) - 3) <= 1)
            {
              *((_DWORD *)v755 + 271) |= *(unsigned char *)(v753 + 336) & 3;
              v1036.i64[1] |= 4uLL;
              if (v758)
              {
                uint64_t v761 = *(const void **)(v753 + 152);
                if (v761) {
                  X::CFRef<__CFData const*>::operator=((const void **)(**(void **)&v1003.f64[0] + 904), v761);
                }
              }
            }
          }
          if (v757) {
            kdebug_trace();
          }
        }
      }
      else
      {
        uint64_t v762 = v693[4];
        if (v762)
        {
          v763 = (atomic_uint *)(v762 + 8);
          if (!atomic_fetch_add((atomic_uint *volatile)(v762 + 8), 1u))
          {
            uint64_t v762 = 0;
            atomic_fetch_add(v763, 0xFFFFFFFF);
          }
          *(void *)(v1001 + 48) = v762;
        }
      }
      unint64_t v8 = *(int32x2_t ***)&v1003.f64[0];
      uint64_t v225 = v1001;
LABEL_1366:
      uint64_t v764 = v1036.i64[1];
      if (v224)
      {
        if ((v1036.i64[1] & 0x2000000000) != 0)
        {
          int32x2_t v765 = (*v8)[63];
          if (v765)
          {
            v219.n128_u32[1] = 1;
            while (1)
            {
              if ((*(unsigned char *)(*(void *)&v765 + 99) & 0x10) == 0)
              {
                *(int32x2_t *)v217.i8 = v224[15];
                uint32x2_t v766 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)v217.i8);
                if ((vpmax_u32(v766, v766).u32[0] & 0x80000000) == 0)
                {
                  int v767 = *(int32x2_t **)(*(void *)(*(void *)&v765 + 8) + 256);
                  int32x2_t v768 = v767[7];
                  uint32x2_t v769 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v768);
                  if ((vpmax_u32(v769, v769).u32[0] & 0x80000000) == 0)
                  {
                    uint32x2_t v770 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, vsub_s32(vmin_s32(vadd_s32(v224[14], *(int32x2_t *)v217.i8), vadd_s32(v767[6], v768)), vmax_s32(v224[14], v767[6])));
                    *(uint32x2_t *)v217.i8 = vpmax_u32(v770, v770);
                    if ((v217.i32[0] & 0x80000000) == 0) {
                      break;
                    }
                  }
                }
              }
              int32x2_t v765 = **(int32x2_t **)&v765;
              if (!*(void *)&v765) {
                goto LABEL_1375;
              }
            }
            uint64_t v764 = v1036.i64[1] | 0x800000000;
            v1036.i64[1] |= 0x800000000uLL;
          }
        }
      }
LABEL_1375:
      uint64_t v771 = *(void *)(*(void *)&v302 + 128);
      if ((*(unsigned char *)(*(void *)&v302 + 43) & 8) != 0)
      {
        uint64_t v772 = v764 | 0x800000000;
        v1036.i64[1] = v764 | 0x800000000;
        if (!v771) {
          goto LABEL_1384;
        }
        float v773 = *(float *)(v771 + 264);
        if (v773 != 0.0)
        {
          if (*(float *)(*v8)[135].i32 > v773) {
            float v773 = *(float *)(*v8)[135].i32;
          }
          *(float *)(*v8)[135].i32 = v773;
          uint64_t v772 = v764 | 0x800000004;
          v1036.i64[1] = v764 | 0x800000004;
        }
LABEL_1383:
        if (*(float *)(v771 + 296) > 1.0)
        {
          uint64_t v764 = v772 | 0x800000000;
          v1036.i64[1] = v772 | 0x800000000;
          goto LABEL_1385;
        }
LABEL_1384:
        uint64_t v764 = v772;
        goto LABEL_1385;
      }
      uint64_t v772 = v764;
      if (v771) {
        goto LABEL_1383;
      }
LABEL_1385:
      if ((v1036.i16[0] & 0x300) != 0) {
        v764 |= 4uLL;
      }
      unint64_t v774 = ((unint64_t)v1036.i64[0] >> 5) & 8;
      unint64_t v775 = v774 | v764;
      if ((v1036.i16[0] & 0x300) != 0) {
        v1036.i64[1] = v774 | v764;
      }
      uint64_t v776 = v1034;
      uint64_t v777 = *(void *)(v1034 + 24);
      if ((v777 & 0x10) != 0) {
        v1036.i64[1] = v775 & 0xFFFFFFFFFFFFFDFFLL;
      }
      if (v1039)
      {
        v777 |= 0x10000uLL;
        *(void *)(v1034 + 24) = v777;
        if ((*(unsigned char *)(v7 + 66) & 2) != 0) {
          (*v8)[33].i32[1] |= 4u;
        }
      }
      uint64_t v778 = *(void *)(v776 + 264);
      if (v778)
      {
        uint64_t v779 = *(void *)(v778 + 24);
        if (v779)
        {
          if ((v777 & 0x40) == 0) {
            goto LABEL_1399;
          }
          if ((*(unsigned int (**)(uint64_t))(*(void *)v779 + 16))(v779))
          {
            v780 = (uint64_t **)*v8;
            int32x2_t v781 = (*v8)[75];
            atomic_fetch_add((atomic_uint *volatile)(v779 + 8), 1u);
            v782 = (malloc_zone_t *)get_malloc_zone();
            v783 = (uint64_t *)malloc_type_zone_malloc(v782, 0x10uLL, 0x8BB15036uLL);
            uint64_t *v783 = v779;
            v783[1] = (uint64_t)v781;
            unint64_t v8 = *(int32x2_t ***)&v1003.f64[0];
            v780[75] = v783;
LABEL_1399:
            uint64_t v784 = (uint64_t **)*v8;
            float v785 = *(float *)&(*v8)[134].i32[1];
            if (v785 <= *(float *)(v779 + 176)) {
              float v785 = *(float *)(v779 + 176);
            }
            *((float *)v784 + 269) = v785;
            if (*(unsigned char *)(v779 + 152)) {
              v1036.i64[1] |= 0x800000000uLL;
            }
            if (*(unsigned char *)(v779 + 153)) {
              v1036.i64[1] |= 0x8000000000uLL;
            }
            uint64_t v786 = *(void *)(v779 + 160);
            if (v786)
            {
              if (*((unsigned char *)v784 + 274)) {
                *(void *)(v1034 + 24) |= 0x10uLL;
              }
              v1036.i64[1] |= (unint64_t)(v786 & 7) << 47;
            }
          }
        }
        v1036.i64[1] |= 4uLL;
      }
      if (v1000.n128_u32[0])
      {
        uint64_t v787 = v8[3][2].u32[0];
        long long v788 = *(uint64_t **)(*(void *)&v1002.f64[0] + 128);
        if (v788)
        {
          uint64_t v789 = *v788;
          if (v789)
          {
            if (*(unsigned char *)(v789 + 12) == 30)
            {
              uint64_t v790 = *(void *)(v789 + 72);
              if (v790) {
                uint64_t v787 = *(unsigned int *)(v790 + 16);
              }
              else {
                uint64_t v787 = 0;
              }
            }
          }
        }
        uint64_t v791 = *(void *)(*(void *)&v1002.f64[0] + 144);
        if (v791)
        {
          uint64_t v792 = *(void *)(*(void *)&v1002.f64[0] + 120);
          __n128 v219 = *(__n128 *)(v1034 + 160);
          *(void *)&float64_t v793 = *(unsigned int *)(v791 + 72);
          if (LODWORD(v793)
            || (unsigned int add = atomic_fetch_add(CA::Render::next_cache_id(void)::cache_id, 1u),
                *(void *)&float64_t v793 = add + 1,
                *(void *)(v791 + 72) = LODWORD(v793),
                add != -1))
          {
            __n128 v1000 = v219;
            os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::flattened_lock);
            float64x2_t v795 = (void *)CA::Render::flattened_cache;
            if (!CA::Render::flattened_cache)
            {
              float64x2_t v795 = x_hash_table_new_(0, 0, 0, 0, 0, 0);
              CA::Render::flattened_cache = (uint64_t)v795;
            }
            uint64_t v796 = x_hash_table_lookup((uint64_t)v795, LODWORD(v793), 0);
            if (!v796)
            {
              float64x2_t v797 = (malloc_zone_t *)get_malloc_zone();
              float64x2_t v798 = malloc_type_zone_malloc(v797, 0x40uLL, 0x8BB15036uLL);
              uint64_t v796 = (uint64_t)v798;
              if (v798)
              {
                v798[7] = 0;
                *(_OWORD *)float64x2_t v798 = 0u;
                *((_OWORD *)v798 + 1) = 0u;
                *((_OWORD *)v798 + 2) = 0u;
                *((_DWORD *)v798 + 12) = 0;
                v799 = (int *)CA::Render::flattened_cache;
                uint64_t v800 = LODWORD(v793);
                uint64_t v801 = v796;
              }
              else
              {
                v799 = (int *)CA::Render::flattened_cache;
                uint64_t v800 = LODWORD(v793);
                uint64_t v801 = 0;
              }
              hash_table_modify(v799, v800, v801, 0);
            }
            unint64_t v8 = *(int32x2_t ***)&v1003.f64[0];
            uint64_t v225 = v1001;
            if (v995)
            {
              v802 = *(CA::Shape **)(v796 + 40);
              if (v802) {
                CA::Shape::unref(v802);
              }
              *(void *)(v796 + 40) = CA::Shape::ref(v995);
            }
            __n128 v803 = v1000;
            if (v792)
            {
              int8x16_t v804 = *(atomic_uint **)(v796 + 56);
              if (v804 && atomic_fetch_add(v804 + 2, 0xFFFFFFFF) == 1)
              {
                (*(void (**)(atomic_uint *, __n128))(*(void *)v804 + 16))(v804, v803);
                __n128 v803 = v1000;
              }
              uint64_t v805 = v792;
              if (!atomic_fetch_add((atomic_uint *volatile)(v792 + 8), 1u))
              {
                uint64_t v805 = 0;
                atomic_fetch_add((atomic_uint *volatile)(v792 + 8), 0xFFFFFFFF);
              }
              *(void *)(v796 + 56) = v805;
            }
            *(_DWORD *)(v796 + 48) = v787;
            *(__n128 *)(v796 + 8) = v803;
            if ((_BYTE)xmmword_1EB2ACC70)
            {
              float64x2_t v1024 = 0uLL;
              if (v995) {
                CA::Shape::get_bounds(v995, (int *)&v1024);
              }
              if (v792) {
                v918 = (const char *)(v792 + 28);
              }
              else {
                v918 = "";
              }
              if (x_log_hook_p())
              {
                *(void *)&v977[64] = v1000.n128_u32[2];
                *(void *)&v977[72] = v1000.n128_u32[3];
                *(void *)&v977[48] = v1000.n128_u32[0];
                *(void *)&v977[56] = v1000.n128_u32[1];
                *(void *)&v977[32] = HIDWORD(v1024.f64[1]);
                *(void *)&v977[40] = v787;
                *(void *)&v977[16] = HIDWORD(v1024.f64[0]);
                *(void *)&v977[24] = LODWORD(v1024.f64[1]);
                *(void *)v977 = v918;
                *(void *)&v977[8] = LODWORD(v1024.f64[0]);
                v976.f64[1] = v793;
                x_log_();
              }
              else
              {
                v923 = x_log_category_flatten;
                if (os_log_type_enabled((os_log_t)x_log_category_flatten, OS_LOG_TYPE_DEFAULT))
                {
                  LODWORD(v1042[0].f64[0]) = 67111682;
                  HIDWORD(v1042[0].f64[0]) = LODWORD(v793);
                  LOWORD(v1042[0].f64[1]) = 2080;
                  *(void *)((char *)&v1042[0].f64[1] + 2) = v918;
                  WORD1(v1042[1].f64[0]) = 1024;
                  HIDWORD(v1042[1].f64[0]) = LODWORD(v1024.f64[0]);
                  LOWORD(v1042[1].f64[1]) = 1024;
                  *(_DWORD *)((char *)&v1042[1].f64[1] + 2) = HIDWORD(v1024.f64[0]);
                  HIWORD(v1042[1].f64[1]) = 1024;
                  LODWORD(v1042[2].f64[0]) = LODWORD(v1024.f64[1]);
                  WORD2(v1042[2].f64[0]) = 1024;
                  *(_DWORD *)((char *)v1042[2].f64 + 6) = HIDWORD(v1024.f64[1]);
                  WORD1(v1042[2].f64[1]) = 1024;
                  HIDWORD(v1042[2].f64[1]) = v787;
                  LOWORD(v1042[3].f64[0]) = 1024;
                  *(_DWORD *)((char *)v1042[3].f64 + 2) = v1000.n128_u32[0];
                  HIWORD(v1042[3].f64[0]) = 1024;
                  LODWORD(v1042[3].f64[1]) = v1000.n128_u32[1];
                  WORD2(v1042[3].f64[1]) = 1024;
                  *(_DWORD *)((char *)&v1042[3].f64[1] + 6) = v1000.n128_u32[2];
                  WORD1(v1042[4].f64[0]) = 1024;
                  HIDWORD(v1042[4].f64[0]) = v1000.n128_u32[3];
                  _os_log_impl(&dword_184668000, v923, OS_LOG_TYPE_DEFAULT, "[%d] cached flatten info [%s] [%d %d %d %d] [%x] [%d %d %d %d]", (uint8_t *)v1042, 0x48u);
                }
              }
              unint64_t v8 = *(int32x2_t ***)&v1003.f64[0];
              unsigned __int8 v224 = (int32x2_t *)v997;
              uint64_t v188 = v998;
              uint64_t v225 = v1001;
            }
            os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::flattened_lock);
          }
        }
      }
      uint64_t v806 = v1034;
      if ((*(unsigned char *)(v1034 + 24) & 0x10) != 0)
      {
        uint64_t v825 = v1036.i64[0];
        unint64_t v820 = v994;
        if ((v1036.i64[0] & 0x78000) != 0)
        {
          (*v8)[33].i32[1] |= 4u;
          v1036.i64[0] = v825 & 0xFFFFFFFFFFF87FFFLL;
        }
        v1036.i64[1] &= 0xFFF87E011E3FFFFFLL;
        if (v1012) {
          *(void *)(v806 + 224) = 1;
        }
        goto LABEL_1596;
      }
      int v807 = *(_DWORD *)(v225 + 184);
      int v808 = *(_DWORD *)(v225 + 188);
      if (v807 <= v808) {
        int v809 = *(_DWORD *)(v225 + 188);
      }
      else {
        int v809 = *(_DWORD *)(v225 + 184);
      }
      v219.n128_u32[0] = 1073741822;
      v217.i32[0] = v809;
      int8x16_t v810 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v217, (int32x4_t)v219), 0);
      uint64_t v811 = *(void *)(v225 + 176);
      v812.i64[0] = (int)v811;
      v812.i64[1] = SHIDWORD(v811);
      int8x16_t v813 = vbslq_s8(v810, (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v812));
      double v814 = (double)v807;
      if (v809 > 1073741822) {
        double v814 = 1.79769313e308;
      }
      v1042[0] = (float64x2_t)v813;
      if (v809 <= 1073741822) {
        double v815 = (double)v808;
      }
      else {
        double v815 = 1.79769313e308;
      }
      v1042[1].f64[0] = v814;
      v1042[1].f64[1] = v815;
      CA::Render::Updater::LayerShapes::union_bounds((__n128 *)v188, v1042, 0);
      uint64_t v819 = *(uint64_t **)(*(void *)&v1002.f64[0] + 128);
      unint64_t v820 = v994;
      if (v819)
      {
        uint64_t v821 = *v819;
        if (v821)
        {
          if (*(unsigned char *)(v821 + 12) == 30)
          {
            int v822 = *(_DWORD *)(v225 + 184);
            if (v822 >= *(_DWORD *)(v225 + 188)) {
              int v822 = *(_DWORD *)(v225 + 188);
            }
            if (v822 >= 1)
            {
              uint64_t v823 = *(void *)(v821 + 72);
              int v824 = v823 ? (CA::Render::Context *)*(unsigned int *)(v823 + 16) : 0;
              uint64_t v826 = CA::Render::Context::context_by_id(v824);
              if (v826)
              {
                int v827 = (atomic_uint *)v826;
                v828 = (uint64_t **)*v8;
                v829 = (__int32 *)(*v8)[115];
                int32x2_t v830 = (*v8)[116];
                uint64_t v831 = wmemchr(v829, v827[66], (uint64_t)(*(void *)&v830 - (void)v829) >> 2);
                if (v831) {
                  uint64_t v832 = v831;
                }
                else {
                  uint64_t v832 = (__int32 *)v830;
                }
                if (v832 == (__int32 *)v828[116])
                {
                  LODWORD(v1042[0].f64[0]) = v827[66];
                  X::small_vector_base<unsigned int>::push_back((uint64_t)(v828 + 115), v1042);
                }
                unsigned int v833 = atomic_fetch_add(v827 + 2, 0xFFFFFFFF);
                unint64_t v8 = *(int32x2_t ***)&v1003.f64[0];
                if (v833 == 1) {
                  (*(void (**)(atomic_uint *))(*(void *)v827 + 16))(v827);
                }
              }
            }
          }
        }
      }
      if (v1010 && !*((unsigned char *)v1010 + 16)) {
        *(void *)(v1034 + 24) |= 0x100000uLL;
      }
      uint64_t v834 = (CA::Shape **)v1011;
      if (v1011 && (v1039 & 2) == 0)
      {
        if (v1011)
        {
          if (v1011 != 1) {
            goto LABEL_1480;
          }
        }
        else
        {
          if (*(_DWORD *)(v1011 + 4) == 6) {
            goto LABEL_1485;
          }
LABEL_1480:
          if (!CA::Bounds::contains((CA::Bounds *)&v1017, v1011))
          {
            CA::shape_intersect((CA::Shape **)&v1011, (CA::Shape **)&v1017, v835);
            uint64_t v834 = (CA::Shape **)v1011;
          }
          if (*(void *)(v188 + 56))
          {
            CA::shape_union((CA::Shape **)(v188 + 56), v834, v835);
            uint64_t v834 = (CA::Shape **)v1011;
          }
          CA::Render::Update::fullfill_backdrops((uint64_t)*v8, (const CA::Shape *)v834);
          CA::Render::Update::add_opaque_shape((CA::Shape **)*v8, (CA::Shape **)v1011, v836);
        }
LABEL_1485:
        if ((v1036.i8[2] & 0x10) == 0)
        {
          *(void *)(v1034 + 208) = v1011;
          uint64_t v1011 = 0;
        }
      }
      if (!v1012) {
        goto LABEL_1518;
      }
      int64x2_t v837 = vceqzq_f64((float64x2_t)v1016);
      if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v837, 1), (int8x16_t)v837).u64[0] & 0x8000000000000000) != 0
        || (int8x16_t v838 = vorrq_s8((int8x16_t)vcltzq_f64((float64x2_t)v1016), (int8x16_t)vcgezq_f64((float64x2_t)v1016)),
            (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v838), 1), v838).u64[0] & 0x8000000000000000) != 0))
      {
        v1042[0] = 0uLL;
      }
      else
      {
        int32x4_t v839 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v1015, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
        v1042[0] = (float64x2_t)vuzp1q_s32(v839, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v1015, (float64x2_t)v1016), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v839));
      }
      CA::shape_intersect(v999, (CA::Shape **)v1042, v816);
      v841 = (CA::Shape **)(v188 + 64);
      if (!*(void *)(v188 + 64)) {
        goto LABEL_1517;
      }
      double v842 = *(const CA::Shape **)(v188 + 72);
      if (!v842) {
        goto LABEL_1507;
      }
      if (!v224 || !v1013)
      {
        if (v224) {
          goto LABEL_1505;
        }
        goto LABEL_1511;
      }
      if ((v224[12].i32[0] & 0x78000) == 0) {
        goto LABEL_1505;
      }
      uint64_t v843 = v7;
      uint64_t v844 = CA::Shape::intersect(*(void *)(v188 + 72), v1013);
      uint64_t v845 = (CA::Shape *)v844;
      if (v844)
      {
        if (v844 == 1) {
          goto LABEL_1504;
        }
        goto LABEL_1503;
      }
      if (*(_DWORD *)(v844 + 4) != 6)
      {
LABEL_1503:
        uint64_t v846 = (CA::Shape **)CA::Shape::dilate(v844, 1u, 1u);
        CA::Render::Updater::LayerShapes::union_visible_shape(v188, v846, v847);
        CA::Render::Updater::LayerShapes::union_visible_shape((uint64_t)&v1007, v846, v848);
        CA::shape_subtract((CA::Shape **)(v188 + 72), v846, v849, v850);
        v1036.i64[1] |= 0x40uLL;
        CA::Shape::unref((CA::Shape *)v846);
      }
LABEL_1504:
      CA::Shape::unref(v845);
      uint64_t v7 = v843;
      unint64_t v8 = *(int32x2_t ***)&v1003.f64[0];
LABEL_1505:
      if ((v224[12].i32[0] & 0x78000) == 0)
      {
        double v842 = *(const CA::Shape **)(v188 + 72);
LABEL_1511:
        float64x2_t v853 = (CA::Shape **)CA::Shape::subtract((CA::Shape *)v1012, v842, (uint64_t)v816, v840);
        if (*v841)
        {
          CA::shape_union((CA::Shape **)(v188 + 64), v853, v852);
          float32x2_t v854 = *v841;
          if ((*v841 & 1) == 0 && *((int *)v854 + 1) >= 257)
          {
            v1042[0] = 0uLL;
            CA::Shape::get_bounds((uint64_t)v854, (int *)v1042);
            CA::Shape::unref(*v841);
            *v841 = (CA::Shape *)CA::Shape::new_shape((unsigned int *)v1042);
          }
        }
        CA::Shape::unref((CA::Shape *)v853);
        goto LABEL_1516;
      }
      if (*v841)
      {
LABEL_1507:
        CA::shape_union((CA::Shape **)(v188 + 64), (CA::Shape **)v1012, v816);
        unint64_t v851 = *v841;
        if ((*v841 & 1) == 0 && *((int *)v851 + 1) >= 257)
        {
          v1042[0] = 0uLL;
          CA::Shape::get_bounds((uint64_t)v851, (int *)v1042);
          CA::Shape::unref(*v841);
          *v841 = (CA::Shape *)CA::Shape::new_shape((unsigned int *)v1042);
        }
      }
LABEL_1516:
      CA::Render::Update::add_visible_shape((CA::Shape **)*v8, (CA::Shape **)v1012, v816);
LABEL_1517:
      *(void *)(v1034 + 224) = v1012;
      int64_t v1012 = 0;
LABEL_1518:
      uint64_t v855 = v1013;
      if (v1013)
      {
        if (*(void *)(v188 + 72))
        {
          CA::shape_union((CA::Shape **)(v188 + 72), (CA::Shape **)v1013, v816);
          uint64_t v855 = v1013;
        }
        uint64_t v856 = v1034;
        *(void *)(v1034 + 232) = v855;
        uint64_t v1013 = 0;
      }
      else
      {
        uint64_t v856 = v1034;
      }
      int v857 = *(_DWORD *)(v856 + 168);
      if (v857)
      {
        uint64_t v858 = *((void *)v1035 + 5);
        if ((v858 & 0x40) != 0 && !*(void *)(v856 + 128))
        {
          uint64_t v859 = *((void *)v1035 + 16);
          float v860 = 0.0;
          if (!v859) {
            goto LABEL_1529;
          }
          if (!*(void *)(v859 + 112))
          {
            float v860 = *(float *)(v859 + 228);
LABEL_1529:
            float64x2_t v862 = *((float64x2_t *)v1035 + 4);
            float64x2_t v861 = *((float64x2_t *)v1035 + 5);
            v1042[0] = v862;
            v1042[1] = v861;
            if ((*((unsigned char *)v1035 + 38) & 0xF) == 0) {
              float v860 = 0.0;
            }
            double v863 = v861.f64[1];
            if (v859 && *(void *)(v859 + 72))
            {
              float64x2_t v1002 = v862;
              float64x2_t v1003 = v861;
              CA::Render::Layer::max_corner_radii(v859);
              float64x2_t v862 = v1002;
              v861.f64[0] = v1003.f64[0];
              float v860 = *(double *)v817.i64;
            }
            if (v861.f64[0] <= v863) {
              *(double *)v817.i64 = v863;
            }
            else {
              *(double *)v817.i64 = v861.f64[0];
            }
            v818.i32[1] = 2146435071;
            if (*(double *)v817.i64 < 1.79769313e308)
            {
              *(double *)v817.i64 = v861.f64[0] >= v863 ? v863 : v861.f64[0];
              if (*(double *)v817.i64 > 0.0)
              {
                int32x4_t v817 = (int32x4_t)vaddq_f64(v862, (float64x2_t)vdupq_n_s64(0xBEE4F8B588E368F1));
                v1042[0] = (float64x2_t)v817;
                *(double *)v818.i64 = v861.f64[0] + 0.00002;
                *(double *)v817.i64 = v863 + 0.00002;
                v1042[1].f64[0] = v861.f64[0] + 0.00002;
                v1042[1].f64[1] = v863 + 0.00002;
                if (v861.f64[0] + 0.00002 <= 0.0 || *(double *)v817.i64 <= 0.0) {
                  v1042[1] = 0uLL;
                }
              }
            }
            int v864 = *(_DWORD *)(v856 + 172);
            if (v857 <= v864) {
              int v865 = *(_DWORD *)(v856 + 172);
            }
            else {
              int v865 = v857;
            }
            v817.i32[0] = 1073741822;
            v818.i32[0] = v865;
            int8x16_t v866 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v818, v817), 0);
            uint64_t v867 = *(void *)(v856 + 160);
            v868.i64[0] = (int)v867;
            v868.i64[1] = SHIDWORD(v867);
            int8x16_t v869 = vbslq_s8(v866, (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v868));
            double v870 = (double)v857;
            double v871 = (double)v864;
            if (v865 > 1073741822)
            {
              double v870 = 1.79769313e308;
              double v871 = 1.79769313e308;
            }
            float64x2_t v1024 = (float64x2_t)v869;
            v1025.f64[0] = v870;
            v1025.f64[1] = v871;
            if (v860 == 0.0)
            {
LABEL_1551:
              if (!CA::BoundsImpl::contains(v1042[0].f64, v1024.f64)) {
                goto LABEL_1582;
              }
              goto LABEL_1581;
            }
            if (v859 && *(void *)(v859 + 56))
            {
              double v872 = v860;
              if ((v858 & 0x20000000000) != 0)
              {
                CA::BoundsImpl::inset(v1042[0].f64, v860, v860);
                goto LABEL_1551;
              }
              int8x16_t v874 = (int8x16_t)v1042[0];
              int8x16_t v873 = (int8x16_t)v1042[1];
            }
            else
            {
              double v872 = v860;
              float64x2_t v1002 = v1042[0];
              float64x2_t v1003 = v1042[1];
              v1040[0] = (int8x16_t)v1042[0];
              v1040[1] = (int8x16_t)v1042[1];
              CA::BoundsImpl::inset((double *)v1040[0].i64, v860 * 0.322182541, v860 * 0.322182541);
              BOOL v875 = CA::BoundsImpl::contains((double *)v1040[0].i64, v1024.f64);
              int8x16_t v874 = (int8x16_t)v1002;
              int8x16_t v873 = (int8x16_t)v1003;
              if (v875) {
                goto LABEL_1581;
              }
            }
            float v876 = v872 * 1.52866;
            if ((v858 & 3) == 0) {
              float v876 = v860;
            }
            v1040[0] = v874;
            v1040[1] = v873;
            double v877 = v876;
            double v878 = *(double *)&v873.i64[1];
            if (*(double *)v873.i64 <= *(double *)&v873.i64[1]) {
              double v879 = *(double *)&v873.i64[1];
            }
            else {
              double v879 = *(double *)v873.i64;
            }
            if (v879 < 1.79769313e308)
            {
              double v880 = *(double *)v873.i64 >= *(double *)&v873.i64[1] ? *(double *)&v873.i64[1] : *(double *)v873.i64;
              if (v880 > 0.0)
              {
                *(double *)v1040[0].i64 = *(double *)v874.i64 + v877;
                *(double *)v1040[1].i64 = *(double *)v873.i64 - (v877 + v877);
                v1040[1].i64[1] = v873.i64[1];
                if (*(double *)v1040[1].i64 <= 0.0 || *(double *)&v873.i64[1] <= 0.0) {
                  v1040[1] = 0uLL;
                }
              }
            }
            float64x2_t v1002 = (float64x2_t)v874;
            float64x2_t v1003 = (float64x2_t)v873;
            if (CA::BoundsImpl::contains((double *)v1040[0].i64, v1024.f64)) {
              goto LABEL_1581;
            }
            float64x2_t v1022 = v1002;
            float64x2_t v1023 = v1003;
            if (v879 < 1.79769313e308)
            {
              double v881 = v1003.f64[0] >= v878 ? v878 : v1003.f64[0];
              if (v881 > 0.0)
              {
                v1022.f64[1] = v1002.f64[1] + v877;
                v1023.f64[0] = v1003.f64[0];
                v1023.f64[1] = v878 - (v877 + v877);
                if (v1003.f64[0] <= 0.0 || v878 - (v877 + v877) <= 0.0) {
                  float64x2_t v1023 = 0uLL;
                }
              }
            }
            if (CA::BoundsImpl::contains(v1022.f64, v1024.f64)) {
LABEL_1581:
            }
              *(void *)(v856 + 24) |= 0x2000uLL;
          }
        }
LABEL_1582:
        v882 = *(int32x2_t **)(v188 + 80);
        if (v882)
        {
          int v883 = *(_DWORD *)(v856 + 168);
          int v884 = *(_DWORD *)(v856 + 172);
          if (v883 <= v884) {
            int v885 = *(_DWORD *)(v856 + 172);
          }
          else {
            int v885 = *(_DWORD *)(v856 + 168);
          }
          v817.i32[0] = 1073741822;
          v818.i32[0] = v885;
          int8x16_t v886 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v818, v817), 0);
          uint64_t v887 = *(void *)(v856 + 160);
          v888.i64[0] = (int)v887;
          v888.i64[1] = SHIDWORD(v887);
          float64x2_t v889 = (float64x2_t)vbslq_s8(v886, (int8x16_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL), (int8x16_t)vcvtq_f64_s64(v888));
          double v890 = (double)v883;
          double v891 = (double)v884;
          if (v885 > 1073741822)
          {
            double v890 = 1.79769313e308;
            double v891 = 1.79769313e308;
          }
          v1042[0] = v889;
          v1042[1].f64[0] = v890;
          v1042[1].f64[1] = v891;
          v892 = *(float64x2_t **)(v856 + 56);
          if (v892)
          {
            CA::Mat4Impl::mat4_apply_to_rect(v892, (int8x16_t *)v1042, (double *)v816);
            float64x2_t v893 = v1042[0];
          }
          else
          {
            float64x2_t v893 = vaddq_f64(v889, *(float64x2_t *)(v856 + 64));
          }
          int64x2_t v894 = vceqzq_f64(v1042[1]);
          unint64_t v895 = vorrq_s8((int8x16_t)vdupq_laneq_s64(v894, 1), (int8x16_t)v894).u64[0];
          int8x16_t v896 = 0uLL;
          if ((v895 & 0x8000000000000000) == 0)
          {
            int8x16_t v897 = vorrq_s8((int8x16_t)vcltzq_f64(v1042[1]), (int8x16_t)vcgezq_f64(v1042[1]));
            if ((vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v897), 1), v897).u64[0] & 0x8000000000000000) == 0)
            {
              int32x4_t v898 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v893, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
              int8x16_t v896 = (int8x16_t)vuzp1q_s32(v898, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v893, v1042[1]), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v898));
            }
          }
          CA::BoundsImpl::Union(v882, *(int32x2_t *)v896.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v896, v896, 8uLL));
        }
      }
      unsigned __int8 v224 = (int32x2_t *)v997;
      if (v1036.i8[10] < 0)
      {
        unint64_t v903 = (*v8)[135].u32[1] | ((unint64_t)(*v8)[136].u16[0] << 32);
        if ((v903 & 0x1000000000) != 0 && v991 != 5 && v991 > ((v903 >> 37) & 7))
        {
          uint64_t v904 = (uint64_t)&(*v8)[135] + 4;
          unint64_t v905 = v903 & 0xFFFFFF1FFFFFFFFFLL;
          unint64_t v906 = v905 | (v991 << 37);
          *(_DWORD *)uint64_t v904 = v905;
          *(_WORD *)(v904 + 4) = WORD2(v906);
        }
      }
LABEL_1596:
      if (v1011) {
        CA::Shape::unref((CA::Shape *)v1011);
      }
      if (v1012) {
        CA::Shape::unref((CA::Shape *)v1012);
      }
      if (v1013) {
        CA::Shape::unref((CA::Shape *)v1013);
      }
      if (v1010)
      {
        v899 = (void *)v1010[1];
        if (v899) {
          CA::GenericRectTree<CA::Rect>::Pool::delete_node(*v1010, v899);
        }
      }
      uint64_t v900 = v1036.i64[1];
      if ((v1036.i64[1] & 0x1800000000) != 0)
      {
        *(void *)(v1034 + 24) |= 0x400uLL;
        goto LABEL_1608;
      }
      if (v1036.i64[1])
      {
LABEL_1608:
        if (v224) {
          *(void *)&v224[12] |= v900;
        }
        if ((v900 & 0x3F) != 0) {
          uint64_t v901 = v900 | 0x20;
        }
        else {
          uint64_t v901 = v1036.i64[1];
        }
        v1036.i64[1] = (2 * v901) & 0x15480000000 | v901;
        *v820 |= (2 * v901) & 0x15480000000 | v901 & 0x407C15581C06020;
      }
      uint64_t v902 = *(void *)(v7 + 48);
      if (v902) {
        *(void *)(v902 + 24) |= *(void *)(v1034 + 24) & 0x10481400;
      }
      return 1;
    case 'r':
      uint64_t v392 = v383;
      double v393 = CA::Render::KeyValueArray::get_float_key((CA::Render::KeyValueArray *)v388, 276, 0.5);
      double v394 = 0.5;
LABEL_722:
      if (v393 == CA::Render::KeyValueArray::get_float_key(v980, 276, v394)) {
        goto LABEL_723;
      }
      goto LABEL_886;
    default:
      if (v387 != 160) {
        goto LABEL_1638;
      }
      if (!v388)
      {
        unint64_t v438 = 0;
        uint64_t v418 = v980;
        goto LABEL_788;
      }
      uint64_t v417 = *(unsigned int *)(v388 + 16);
      uint64_t v418 = v980;
      if (!v417) {
        goto LABEL_787;
      }
      uint64_t v419 = 0;
      while (1)
      {
        uint64_t v420 = *(void *)(v388 + 24 + 8 * v419);
        if (*(_DWORD *)(v420 + 16) == 312) {
          break;
        }
        if (v417 == ++v419) {
          goto LABEL_787;
        }
      }
      if ((v419 & 0x80000000) == 0)
      {
        unint64_t v438 = *(void *)(v420 + 24);
        goto LABEL_788;
      }
LABEL_787:
      unint64_t v438 = 0;
      if (!v418) {
        goto LABEL_796;
      }
      uint64_t v455 = *((unsigned int *)v418 + 4);
      if (!v455) {
        goto LABEL_796;
      }
LABEL_788:
      uint64_t v456 = 0;
      while (1)
      {
        uint64_t v457 = *((void *)v418 + v456 + 3);
        if (*(_DWORD *)(v457 + 16) == 312) {
          break;
        }
        if (v455 == ++v456) {
          goto LABEL_796;
        }
      }
      if ((v456 & 0x80000000) == 0)
      {
        uint64_t v392 = v383;
        unint64_t v458 = *(void *)(v457 + 24);
      }
      else
      {
LABEL_796:
        uint64_t v392 = v383;
        unint64_t v458 = 0;
      }
      if (!CA::Render::curves_equal(v438, v458, v369)) {
        goto LABEL_886;
      }
      if (!v388) {
        goto LABEL_837;
      }
      uint64_t v460 = *(unsigned int *)(v388 + 16);
      if (!v460) {
        goto LABEL_837;
      }
      uint64_t v461 = 0;
      while (1)
      {
        uint64_t v462 = *(void *)(v388 + 24 + 8 * v461);
        if (*(_DWORD *)(v462 + 16) == 299) {
          break;
        }
        if (v460 == ++v461) {
          goto LABEL_837;
        }
      }
      if ((v461 & 0x80000000) == 0) {
        unint64_t v472 = *(void *)(v462 + 24);
      }
      else {
LABEL_837:
      }
        unint64_t v472 = 0;
      if (!v980) {
        goto LABEL_846;
      }
      uint64_t v473 = *((unsigned int *)v980 + 4);
      if (!v473) {
        goto LABEL_846;
      }
      uint64_t v474 = 0;
      while (1)
      {
        uint64_t v475 = *((void *)v980 + v474 + 3);
        if (*(_DWORD *)(v475 + 16) == 299) {
          break;
        }
        if (v473 == ++v474) {
          goto LABEL_846;
        }
      }
      if ((v474 & 0x80000000) == 0) {
        unint64_t v476 = *(void *)(v475 + 24);
      }
      else {
LABEL_846:
      }
        unint64_t v476 = 0;
      if (!CA::Render::curves_equal(v472, v476, v459)) {
        goto LABEL_886;
      }
      if (!v388) {
        goto LABEL_856;
      }
      uint64_t v478 = *(unsigned int *)(v388 + 16);
      if (!v478) {
        goto LABEL_856;
      }
      uint64_t v479 = 0;
      while (1)
      {
        uint64_t v480 = *(void *)(v388 + 24 + 8 * v479);
        if (*(_DWORD *)(v480 + 16) == 284) {
          break;
        }
        if (v478 == ++v479) {
          goto LABEL_856;
        }
      }
      if ((v479 & 0x80000000) == 0) {
        unint64_t v481 = *(void *)(v480 + 24);
      }
      else {
LABEL_856:
      }
        unint64_t v481 = 0;
      if (!v980) {
        goto LABEL_865;
      }
      uint64_t v482 = *((unsigned int *)v980 + 4);
      if (!v482) {
        goto LABEL_865;
      }
      uint64_t v483 = 0;
      while (1)
      {
        uint64_t v484 = *((void *)v980 + v483 + 3);
        if (*(_DWORD *)(v484 + 16) == 284) {
          break;
        }
        if (v482 == ++v483) {
          goto LABEL_865;
        }
      }
      if ((v483 & 0x80000000) == 0) {
        unint64_t v485 = *(void *)(v484 + 24);
      }
      else {
LABEL_865:
      }
        unint64_t v485 = 0;
      if (!CA::Render::curves_equal(v481, v485, v477)) {
        goto LABEL_886;
      }
      if (!v388) {
        goto LABEL_875;
      }
      uint64_t v487 = *(unsigned int *)(v388 + 16);
      if (!v487) {
        goto LABEL_875;
      }
      uint64_t v488 = 0;
      while (1)
      {
        uint64_t v489 = *(void *)(v388 + 24 + 8 * v488);
        if (*(_DWORD *)(v489 + 16) == 275) {
          break;
        }
        if (v487 == ++v488) {
          goto LABEL_875;
        }
      }
      if ((v488 & 0x80000000) == 0) {
        unint64_t v490 = *(void *)(v489 + 24);
      }
      else {
LABEL_875:
      }
        unint64_t v490 = 0;
      if (!v980) {
        goto LABEL_884;
      }
      uint64_t v491 = *((unsigned int *)v980 + 4);
      if (!v491) {
        goto LABEL_884;
      }
      uint64_t v492 = 0;
      while (1)
      {
        uint64_t v493 = *((void *)v980 + v492 + 3);
        if (*(_DWORD *)(v493 + 16) == 275) {
          break;
        }
        if (v491 == ++v492) {
          goto LABEL_884;
        }
      }
      if ((v492 & 0x80000000) == 0) {
        unint64_t v494 = *(void *)(v493 + 24);
      }
      else {
LABEL_884:
      }
        unint64_t v494 = 0;
      if (!CA::Render::curves_equal(v490, v494, v486))
      {
LABEL_886:
        int32x4_t v380 = (int32x4_t)v993;
        LODWORD(v383) = v392;
        goto LABEL_1638;
      }
LABEL_723:
      int32x4_t v380 = (int32x4_t)v993;
      unsigned int v383 = v392;
      goto LABEL_833;
  }
}

void CA::Render::Updater::prepare_layer_mask(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *(void *)(a2 + 56);
  uint64_t v9 = *(void *)(v8 + 40);
  if ((v9 & 0x40) == 0)
  {
    *(_OWORD *)(a4 + 88) = *(_OWORD *)(a3 + 88);
    *(_OWORD *)(a4 + 104) = *(_OWORD *)(a3 + 104);
    *(_OWORD *)(a4 + 120) = *(_OWORD *)(a3 + 120);
    goto LABEL_21;
  }
  float64x2_t v44 = 0u;
  float64x2_t v45 = 0u;
  float64x2_t v10 = *(float64x2_t *)(v8 + 80);
  float64x2_t v54 = *(float64x2_t *)(v8 + 64);
  float64x2_t v55 = v10;
  CA::Rect::apply_transform(v54.f64, a2 + 8);
  uint64_t v11 = *(void *)(v8 + 128);
  float v12 = 0.0;
  if (v11) {
    float v12 = *(float *)(v11 + 228);
  }
  if ((*(unsigned char *)(v8 + 38) & 0xF) != 0)
  {
    if (v11) {
      goto LABEL_7;
    }
  }
  else
  {
    float v12 = 0.0;
    if (v11)
    {
LABEL_7:
      if (*(void *)(v11 + 72))
      {
        CA::Render::Layer::max_corner_radii(v11);
        float v12 = v43;
      }
    }
  }
  if ((v9 & 3) != 0)
  {
    float v13 = v12 * 1.52866;
    float v12 = v13;
  }
  if (v12 <= 0.0)
  {
    __n128 v14 = (__n128)v54;
    float64x2_t v44 = v54;
    float64x2_t v45 = v55;
  }
  else
  {
    CA::Render::Updater::corner_clipped_layer_bounds((double *)v53, (const CA::Render::Layer *)v8);
    float64x2_t v44 = (float64x2_t)v53[0];
    float64x2_t v45 = (float64x2_t)v53[1];
    v14.n128_f64[0] = CA::Rect::apply_transform(v44.f64, a2 + 8);
    *(void *)(a2 + 72) |= 0x20C00000uLL;
  }
  unint64_t v15 = *(void **)a2;
  if (*(void *)a2)
  {
    do
    {
      (*(void (**)(void *, float64x2_t *, float64x2_t *, __n128))(*v15 + 32))(v15, &v44, &v54, v14);
      unint64_t v15 = (void *)v15[1];
    }
    while (v15);
  }
  float64x2_t v16 = v55;
  *(float64x2_t *)(a4 + 88) = v54;
  *(float64x2_t *)(a4 + 104) = v16;
  unsigned int v17 = (int32x4_t *)(a4 + 120);
  int64x2_t v18 = vceqzq_f64(v45);
  if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v18, 1), (int8x16_t)v18).u64[0] & 0x8000000000000000) != 0
    || (int8x16_t v19 = vorrq_s8((int8x16_t)vcltzq_f64(v45), (int8x16_t)vcgezq_f64(v45)),
        (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v19), 1), v19).u64[0] & 0x8000000000000000) != 0))
  {
    v17->i64[0] = 0;
    *(void *)(a4 + 128) = 0;
  }
  else
  {
    int32x4_t v20 = (int32x4_t)vcvtpq_s64_f64(vmaxnmq_f64(v44, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
    *unsigned int v17 = vuzp1q_s32(v20, (int32x4_t)vsubq_s64(vcvtmq_s64_f64(vminnmq_f64(vaddq_f64(v44, v45), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v20));
  }
  CA::BoundsImpl::intersect(a4 + 88, *(float64x2_t *)(a3 + 88), *(float64x2_t *)(a3 + 104));
  CA::BoundsImpl::intersect((int32x2_t *)(a4 + 120), *(int32x2_t *)(a3 + 120), *(int32x2_t *)(a3 + 128));
LABEL_21:
  uint64_t v21 = *(void *)(*(void *)(a2 + 48) + 128);
  if (!v21) {
    return;
  }
  uint64_t v49 = 0;
  long long v47 = 0u;
  long long v48 = 0u;
  float64x2_t v45 = 0u;
  long long v46 = 0u;
  float64x2_t v44 = 0u;
  uint64_t v22 = (float64x2_t *)(a4 + 104);
  long long v23 = *(_OWORD *)(a4 + 104);
  long long v50 = *(_OWORD *)(a4 + 88);
  long long v51 = v23;
  uint64_t v24 = (int32x2_t *)(a4 + 120);
  long long v52 = *(_OWORD *)(a4 + 120);
  if (CA::Render::Updater::prepare_layer(a1, a2, v21, &v44, a2 + 72)) {
    *(void *)(a2 + 64) |= 8uLL;
  }
  if ((*(unsigned char *)(*(void *)(a2 + 56) + 40) & 0x80) != 0) {
    goto LABEL_34;
  }
  int64x2_t v25 = vclezq_f64(*v22);
  if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v25, 1), (int8x16_t)v25).u64[0] & 0x8000000000000000) == 0)
  {
    int64x2_t v26 = vclezq_f64(v45);
    if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v26, 1), (int8x16_t)v26).u64[0] & 0x8000000000000000) != 0
      || (float64x2_t v27 = *(float64x2_t *)(a4 + 88),
          float64x2_t v28 = vmaxnmq_f64(v27, v44),
          float64x2_t v29 = vsubq_f64(vminnmq_f64(vaddq_f64(v27, *v22), vaddq_f64(v44, v45)), v28),
          int64x2_t v30 = vclezq_f64(v29),
          (vorrq_s8((int8x16_t)vdupq_laneq_s64(v30, 1), (int8x16_t)v30).u64[0] & 0x8000000000000000) != 0))
    {
      v22->f64[0] = 0.0;
      *(void *)(a4 + 112) = 0;
    }
    else
    {
      *(float64x2_t *)(a4 + 88) = v28;
      *(float64x2_t *)(a4 + 104) = v29;
    }
  }
  uint64_t v31 = *(void *)(v21 + 208);
  if (!v31)
  {
LABEL_34:
    *uint64_t v24 = 0;
    *(void *)(a4 + 128) = 0;
    return;
  }
  if ((v31 & 1) == 0)
  {
    if (*(_DWORD *)(v31 + 4) == 12)
    {
      v32.i32[0] = *(_DWORD *)(v31 + 28);
      v32.i32[1] = *(_DWORD *)(v31 + 20);
      v33.i32[0] = *(_DWORD *)(v31 + 32) - v32.i32[0];
      unsigned int v34 = *(_DWORD *)(v31 + 36) - v32.i32[1];
      goto LABEL_38;
    }
LABEL_42:
    unint64_t v42 = (CA::Shape *)CA::Shape::intersect((CA::Shape *)v31, (const CA::Bounds *)(a4 + 120));
    CA::Shape::get_interior_bounds((uint64_t)v42, v24);
    CA::Shape::unref(v42);
    return;
  }
  if (v31 == 1) {
    goto LABEL_42;
  }
  v32.i32[0] = v31 >> 48;
  v32.i32[1] = (int)((unint64_t)v31 >> 16) >> 16;
  v33.i32[0] = v31 >> 17;
  unsigned int v34 = (v31 >> 2) & 0x7FFF;
LABEL_38:
  int32x2_t v35 = *(int32x2_t *)(a4 + 128);
  uint32x2_t v36 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v35);
  if ((vpmax_u32(v36, v36).u32[0] & 0x80000000) == 0)
  {
    v33.i32[1] = v34;
    uint32x2_t v37 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v33);
    if ((vpmax_u32(v37, v37).u32[0] & 0x80000000) != 0
      || (int32x2_t v38 = vadd_s32(v32, v33),
          *(int32x2_t *)&long long v39 = vmax_s32(*v24, v32),
          int32x2_t v40 = vsub_s32(vmin_s32(vadd_s32(*v24, v35), v38), *(int32x2_t *)&v39),
          uint32x2_t v41 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v40),
          (vpmax_u32(v41, v41).u32[0] & 0x80000000) != 0))
    {
      *(void *)(a4 + 128) = 0;
    }
    else
    {
      *((int32x2_t *)&v39 + 1) = v40;
      *(_OWORD *)v24->i8 = v39;
    }
  }
}

void CA::Render::Updater::add_background_filters_(uint64_t ***a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, CA::Render::Updater::LayerShapes *this)
{
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(a3 + 128);
  if (!v6) {
    return;
  }
  uint64_t v12 = *(void *)(v6 + 88);
  if (v12 && (*(unsigned char *)(v12 + 13) & 1) != 0)
  {
    BOOL v13 = 0;
    int32x2_t v38 = (CA::Render::Filter *)*(unsigned int *)(v12 + 24);
    if (v38 == 403 || v38 == 524) {
      goto LABEL_5;
    }
    int32x2_t v40 = (void *)(a2 + 72);
    *(void *)(a2 + 72) |= 0x20C00000uLL;
    unsigned int v41 = CA::Render::Filter::compositing_dod(v38) - 5;
    BOOL v13 = v41 < 0xFFFFFFFE;
    if ((int)v38 > 417)
    {
      if ((v38 - 548) <= 0x3D
        && ((1 << (v38 - 36)) & 0x200DA00000000007) != 0)
      {
        goto LABEL_76;
      }
      if ((v38 - 485) <= 0x26 && ((1 << (v38 + 27)) & 0x4A40000021) != 0) {
        goto LABEL_76;
      }
      if ((v38 - 418) <= 0xF && ((1 << ((_BYTE)v38 + 94)) & 0xA041) != 0) {
        goto LABEL_76;
      }
    }
    else if ((int)v38 > 253)
    {
      BOOL v47 = (v38 - 350) > 0x2D || ((1 << (v38 - 94)) & 0x320400201C03) == 0;
      if (!v47 || v38 == 254 || v38 == 264) {
        goto LABEL_76;
      }
    }
    else
    {
      BOOL v42 = (v38 - 162) > 0x38
         || ((1 << (v38 + 94)) & 0x100000000800FE3) == 0;
      if (!v42
        || ((v38 - 90) <= 0x34
          ? (BOOL v43 = ((1 << (v38 - 90)) & 0x10000000000151) == 0)
          : (BOOL v43 = 1),
            !v43))
      {
LABEL_76:
        if (!*(_DWORD *)(a4 + 116) && v41 > 0xFFFFFFFD) {
          goto LABEL_108;
        }
        uint64_t v48 = *(void *)(a2 + 48);
        if (v48) {
          *(void *)(v48 + 24) |= 0x4000uLL;
        }
        if ((int)v38 > 393)
        {
          BOOL v50 = (v38 - 520) > 0x1E || ((1 << ((_BYTE)v38 - 8)) & 0x60000009) == 0;
          if (v50 && v38 != 609 && v38 != 394)
          {
LABEL_108:
            *(unsigned char *)(a2 + 89) |= 2u;
            if (this)
            {
              int v55 = *(_DWORD *)(v12 + 24);
              if (v55 != 142 && v55 != 524)
              {
                uint64_t v56 = (CA::Shape *)*((void *)this + 7);
                if (v56)
                {
                  CA::Shape::unref(v56);
                  *((void *)this + 7) = 0;
                }
              }
            }
            goto LABEL_5;
          }
        }
        else
        {
          BOOL v49 = (v38 - 142) > 0x1D || ((1 << ((_BYTE)v38 + 114)) & 0x3C000001) == 0;
          if (v49 && v38 != 90 && v38 != 391) {
            goto LABEL_108;
          }
        }
        uint64_t v51 = *(void *)(a3 + 40);
        if ((v51 & 0x1000000) != 0 || (*(unsigned char *)(a2 + 89) & 4) != 0) {
          goto LABEL_108;
        }
        uint64_t v52 = *(void *)(a2 + 56);
        if (v52)
        {
          if (*(void *)(v52 + 40) & 0x40000000 | *(void *)(a3 + 40) & 0x100) {
            goto LABEL_108;
          }
        }
        else if ((v51 & 0x100) != 0)
        {
          goto LABEL_108;
        }
        uint64_t v54 = 0x200000000;
LABEL_107:
        *v40 |= v54;
        goto LABEL_108;
      }
    }
    uint64_t v53 = *(void *)(a2 + 48);
    if (!v53) {
      goto LABEL_108;
    }
    int32x2_t v40 = (void *)(v53 + 24);
    uint64_t v54 = 0x8000;
    goto LABEL_107;
  }
  BOOL v13 = 0;
LABEL_5:
  __n128 v14 = *(void **)(a3 + 128);
  if (v14)
  {
    uint64_t v15 = v14[13];
    if (v15)
    {
      uint64_t v57 = a5;
      if (!*v14 || ((*(uint64_t (**)(void))(*(void *)*v14 + 176))(*v14) & 1) == 0)
      {
        uint64_t v16 = *(unsigned int *)(v15 + 16);
        if (v16)
        {
          do
          {
            uint64_t v17 = *(void *)(v15 + 8 * (v16 - 1) + 24);
            if ((*(_DWORD *)(v17 + 12) & 0x40100) == 0x100)
            {
              uint64_t v18 = x_heap_malloc_small_(**a1, 0x38uLL);
              if (v18)
              {
                int8x16_t v19 = **a1;
                *(_WORD *)(v18 + 16) = 1;
                *(unsigned char *)(v18 + 18) = 0;
                *(void *)uint64_t v18 = &unk_1ED02FE40;
                *(void *)(v18 + 24) = a2 + 8;
                *(void *)(v18 + 32) = *(void *)(a2 + 56);
                *(void *)(v18 + 40) = v17;
                *(unsigned char *)(v18 + 48) = 1;
                uint64_t v20 = x_heap_malloc_small_(v19, 0x28uLL);
                if (v20)
                {
                  uint64_t v21 = *(long long **)(v18 + 24);
                  long long v22 = *v21;
                  long long v23 = v21[1];
                  *(void *)(v20 + 32) = *((void *)v21 + 4);
                  *(_OWORD *)uint64_t v20 = v22;
                  *(_OWORD *)(v20 + 16) = v23;
                }
                *(void *)(v18 + 24) = v20;
                uint64_t v24 = *(void *)(v18 + 32);
                if (v24)
                {
                  int64x2_t v25 = (atomic_uint *)(v24 + 8);
                  if (!atomic_fetch_add(v25, 1u)) {
                    atomic_fetch_add(v25, 0xFFFFFFFF);
                  }
                }
                uint64_t v26 = *(void *)(v18 + 40);
                if (v26)
                {
                  float64x2_t v27 = (atomic_uint *)(v26 + 8);
                  if (!atomic_fetch_add(v27, 1u)) {
                    atomic_fetch_add(v27, 0xFFFFFFFF);
                  }
                }
              }
              *(void *)(v18 + 8) = *(void *)a2;
              *(void *)a2 = v18;
              if ((*(unsigned char *)(a2 + 64) & 8) != 0) {
                *(_DWORD *)(v17 + 20) = *((_DWORD *)a1 + 2);
              }
              *(unsigned char *)(a2 + 89) |= 3u;
              *(void *)(a2 + 72) |= 0x20C00000uLL;
              LOBYTE(v13) = 1;
            }
            --v16;
          }
          while (v16);
        }
      }
      a5 = v57;
    }
  }
  if (this && v13)
  {
    CA::Render::Updater::LayerShapes::union_bounds((__n128 *)this, (float64x2_t *)((char *)this + 88), (const CA::Bounds *)1);
    float64x2_t v29 = (CA::Shape *)*((void *)this + 7);
    if (v29)
    {
      CA::Shape::unref(v29);
      *((void *)this + 7) = 1;
    }
    if (a5)
    {
      double v30 = *((double *)this + 13);
      if (v30 >= *((double *)this + 14)) {
        double v30 = *((double *)this + 14);
      }
      if (v30 > 0.0)
      {
        uint64_t v31 = *(void *)(a2 + 56);
        if (v31)
        {
          if ((*(unsigned char *)(v31 + 43) & 0x40) == 0)
          {
            int32x2_t v32 = *a1;
            float64x2_t v33 = *(float64x2_t *)((char *)this + 104);
            int64x2_t v34 = vceqzq_f64(v33);
            if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v34, 1), (int8x16_t)v34).u64[0] & 0x8000000000000000) != 0
              || (int8x16_t v35 = vorrq_s8((int8x16_t)vcltzq_f64(v33), (int8x16_t)vcgezq_f64(v33)),
                  (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v35), 1), v35).u64[0] & 0x8000000000000000) != 0))
            {
              v58[0] = 0;
              v58[1] = 0;
            }
            else
            {
              float64x2_t v36 = *(float64x2_t *)((char *)this + 88);
              int32x4_t v37 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(v36, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
              *(int32x4_t *)double v58 = vuzp1q_s32(v37, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(vminnmq_f64(vaddq_f64(v36, v33), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL))), (int64x2_t)v37));
            }
            CA::shape_union((CA::Shape **)v32 + 8, v58, v28);
            *(void *)(a5 + 72) |= 4uLL;
          }
        }
      }
    }
  }
}

uint64_t CA::Render::LayerSubclass::has_edr_content()
{
  return 0;
}

void CA::Render::Update::add_opaque_shape(CA::Shape **this, CA::Shape **a2, const CA::Shape *a3)
{
  unint64_t v4 = this + 65;
  CA::shape_union(this + 65, a2, a3);
  double v5 = this[65];
  if ((v5 & 1) == 0 && *((int *)v5 + 1) >= 257)
  {
    CA::Shape::unref(v5);
    *unint64_t v4 = 1;
  }
}

uint64_t CA::Render::LayerSubclass::get_bounds()
{
  return 0;
}

BOOL CA::Render::BackdropLayer::bounds_are_visible(CA::Render::BackdropLayer *this)
{
  return (*((_DWORD *)this + 3) & 0x1000) == 0 && (*((_DWORD *)this + 3) & 0x500) != 0;
}

BOOL CA::Render::BackdropLayer::has_background(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  int v3 = *(_DWORD *)(a1 + 12) & 0x1100;
  if (v3 == 256) {
    *a3 = 0;
  }
  return v3 == 256;
}

uint64_t CA::Render::LayerHost::has_background(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  *a3 = 0;
  return (*(unsigned __int8 *)(a1 + 13) >> 2) & 1;
}

double *CA::Render::Updater::corner_clipped_layer_bounds(double *this, const CA::Render::Layer *a2)
{
  *(_OWORD *)this = *((_OWORD *)a2 + 4);
  double v2 = *((double *)a2 + 10);
  double v3 = *((double *)a2 + 11);
  this[2] = v2;
  this[3] = v3;
  uint64_t v4 = *((void *)a2 + 16);
  if (v4)
  {
    uint64_t v6 = this;
    float v7 = *(float *)(v4 + 228);
    int v8 = *((_DWORD *)a2 + 9);
    if ((v8 & 0xF0000) == 0) {
      float v7 = 0.0;
    }
    if (*(void *)(v4 + 72))
    {
      this = (double *)CA::Render::Layer::max_corner_radii(*((void *)a2 + 16));
      float v7 = v15;
    }
    if (v7 > 0.0)
    {
      if (*(void *)(v4 + 56) && (*((unsigned char *)a2 + 45) & 2) != 0)
      {
        double v9 = v7;
        float64x2_t v10 = v6;
        double v11 = v9;
LABEL_19:
        return CA::BoundsImpl::inset(v10, v9, v11);
      }
      if ((*((unsigned char *)a2 + 40) & 3) != 0)
      {
        float v12 = v7 * 1.52866;
        float v7 = v12;
      }
      float v13 = ceilf(v7);
      double v14 = v13;
      if ((v8 & 0xF0000) == 0xF0000)
      {
        double v11 = 0.0;
        if (v2 <= v3) {
          double v9 = 0.0;
        }
        else {
          double v9 = v13;
        }
        if (v2 <= v3) {
          double v11 = v14;
        }
        float64x2_t v10 = v6;
        goto LABEL_19;
      }
      if (v2 <= v3)
      {
        double v17 = 0.0;
        if ((v8 & 0x30000) != 0) {
          double v16 = v14;
        }
        else {
          double v16 = 0.0;
        }
        if ((v8 & 0xC0000) != 0) {
          double v18 = v14;
        }
        else {
          double v18 = 0.0;
        }
        double v14 = 0.0;
      }
      else
      {
        double v16 = 0.0;
        if ((v8 & 0x50000) != 0) {
          double v17 = v13;
        }
        else {
          double v17 = 0.0;
        }
        if ((v8 & 0xA0000) == 0) {
          double v14 = 0.0;
        }
        double v18 = 0.0;
      }
      return CA::BoundsImpl::inset(v6, v17, v16, v14, v18);
    }
  }
  return this;
}

void CA::Render::Update::add_visible_shape(CA::Shape **this, CA::Shape **a2, const CA::Shape *a3)
{
  v7[2] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = this + 66;
  CA::shape_union(this + 66, a2, a3);
  uint64_t v5 = (uint64_t)this[66];
  if ((v5 & 1) == 0 && *(int *)(v5 + 4) >= 257)
  {
    v7[0] = 0;
    v7[1] = 0;
    CA::Shape::get_bounds(v5, (int *)v7);
    unint64_t v6 = CA::Shape::new_shape((unsigned int *)v7);
    CA::Shape::unref(*v4);
    *uint64_t v4 = (CA::Shape *)v6;
  }
}

uint64_t CA::Render::LayerSubclass::has_background()
{
  return 0;
}

uint64_t CA::Render::KeyValueArray::get_color_key(CA::Render::KeyValueArray *this, int a2, uint64_t a3)
{
  unsigned int named_object = CA::Render::KeyValueArray::find_named_object_((uint64_t)this, a2);
  if ((named_object & 0x80000000) == 0)
  {
    uint64_t v6 = *(void *)(*((void *)this + named_object + 3) + 24);
    if (v6)
    {
      if (*(unsigned char *)(v6 + 12) == 56 && *(_DWORD *)(v6 + 16) >= 4u)
      {
        int v7 = (int)(*(double *)(v6 + 24) * 255.0 + 0.5);
        int v8 = v7 & ~(v7 >> 31);
        int v9 = (int)(*(double *)(v6 + 48) * 255.0 + 0.5) & ~((int)(*(double *)(v6 + 48) * 255.0 + 0.5) >> 31);
        if (v8 >= 255) {
          int v8 = 255;
        }
        if (v9 >= 255) {
          int v9 = 255;
        }
        __asm { FMOV            V2.2D, #0.5 }
        uint32x2_t v15 = vshl_u32((uint32x2_t)vmin_s32(vmax_s32(vmovn_s64(vcvtq_s64_f64(vmlaq_f64(_Q2, (float64x2_t)vdupq_n_s64(0x406FE00000000000uLL), *(float64x2_t *)(v6 + 32)))), 0), (int32x2_t)0xFF000000FFLL), (uint32x2_t)0x800000010);
        return v15.i32[0] | (v8 << 24) | v9 | v15.i32[1];
      }
    }
  }
  return a3;
}

BOOL CA::Render::curves_equal(unint64_t this, unint64_t a2, CA::Render::Object *a3)
{
  if ((this == 0) == (a2 != 0)) {
    return 0;
  }
  if (!(this | a2)) {
    return 1;
  }
  if (*(unsigned char *)(this + 12) == 56 && *(unsigned char *)(a2 + 12) == 56)
  {
    uint64_t v3 = *(unsigned int *)(a2 + 16);
    if (v3 == *(_DWORD *)(this + 16)) {
      return memcmp((const void *)(this + 24), (const void *)(a2 + 24), 8 * v3) == 0;
    }
  }
  return 0;
}

double *CA::Render::Updater::RasterizationOp::map_crop(CA::Render::Updater::RasterizationOp *this, Rect *a2, Rect *a3)
{
  CA::BoundsImpl::inset((double *)a3, (double)-*((_DWORD *)this + 5), (double)-*((_DWORD *)this + 5));
  double v5 = (double)*((int *)this + 5);

  return CA::BoundsImpl::inset((double *)a2, v5, v5);
}

void CA::Render::ImageQueue::pse_mitigate(CA::Render::ImageQueue *this, CA::Render::Update *a2)
{
  if (((*((unsigned int *)a2 + 271) | ((unint64_t)*((unsigned __int16 *)a2 + 544) << 32)) & 0x80000000000) != 0)
  {
    uint64_t v4 = (os_unfair_lock_s *)((char *)this + 56);
    os_unfair_lock_lock((os_unfair_lock_t)this + 14);
    uint64_t v5 = *((void *)this + 3);
    if (v5 && *(unsigned char *)(v5 + 12) == 51 && *((double *)this + 5) != 0.0)
    {
      uint64_t v6 = *((void *)this + 10) ? *((void *)this + 10) : *((void *)this + 3);
      if ((*(_WORD *)(v6 + 336) & 0x40) != 0 && !*((void *)this + 8))
      {
        if (!*((void *)this + 9))
        {
          int v7 = x_mem_alloc0(0x20uLL);
          if (v7) {
            void *v7 = objc_opt_new();
          }
          *((void *)this + 9) = v7;
        }
        uint64_t v8 = CA::Render::ImageQueue::resolved_display_attributes(this, a2);
        int v9 = CA::CAPSEProcessor::process_surface(*((CA::CAPSEProcessor **)this + 9), (atomic_uint *)v6, *((double *)this + 5), *(float *)(v8 + 12), *(float *)(v8 + 20));
        float64x2_t v10 = (atomic_uint *)*((void *)this + 8);
        *((void *)this + 8) = v9;
        if (v10)
        {
          if (atomic_fetch_add(v10 + 2, 0xFFFFFFFF) == 1) {
            (*(void (**)(atomic_uint *))(*(void *)v10 + 16))(v10);
          }
          int v9 = (atomic_uint *)*((void *)this + 8);
        }
        if (v9) {
          atomic_fetch_add(v9 + 9, 1u);
        }
      }
    }
    os_unfair_lock_unlock(v4);
  }
}

uint64_t CA::Render::LayerSubclass::bounds_are_visible(CA::Render::LayerSubclass *this)
{
  return 1;
}

BOOL CA::Render::ShapeLayer::self_intersects(uint64_t a1)
{
  if (!*(void *)(a1 + 16)
    || (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqzq_f32(*(float32x4_t *)(a1 + 24))))) & 1) == 0
    && !*(void *)(a1 + 40)
    || *(double *)(a1 + 88) == 0.0
    || *(double *)(a1 + 80) <= *(double *)(a1 + 72))
  {
    return 0;
  }
  if (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqzq_f32(*(float32x4_t *)(a1 + 48)))))) {
    return 1;
  }
  return *(void *)(a1 + 64) != 0;
}

int32x4_t *CA::Bounds::set_interior(int32x4_t *this, const Rect *a2, float64x2_t a3, float64x2_t a4)
{
  int64x2_t v4 = vceqzq_f64(a4);
  if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v4, 1), (int8x16_t)v4).u64[0] & 0x8000000000000000) != 0
    || (int8x16_t v5 = vorrq_s8((int8x16_t)vcltzq_f64(a4), (int8x16_t)vcgezq_f64(a4)),
        (vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v5), 1), v5).u64[0] & 0x8000000000000000) != 0))
  {
    this->i64[0] = 0;
    this->i64[1] = 0;
  }
  else
  {
    float64x2_t v6 = vmaxnmq_f64(a3, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000));
    float64x2_t v7 = vminnmq_f64(vaddq_f64(a3, a4), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL));
    int32x4_t v8 = (int32x4_t)vcvtpq_s64_f64(v6);
    *this = vuzp1q_s32(v8, (int32x4_t)vsubq_s64(vcvtmq_s64_f64(v7), (int64x2_t)v8));
  }
  return this;
}

double *CA::BoundsImpl::inset(double *result, double a2, double a3, double a4, double a5)
{
  double v6 = result[2];
  double v5 = result[3];
  if (v6 <= v5) {
    double v7 = result[3];
  }
  else {
    double v7 = result[2];
  }
  if (v7 < 1.79769313e308)
  {
    if (v6 >= v5) {
      double v8 = result[3];
    }
    else {
      double v8 = result[2];
    }
    if (v8 > 0.0)
    {
      double v9 = result[1] + a3;
      *int64x2_t result = *result + a2;
      result[1] = v9;
      double v10 = v6 - (a2 + a4);
      double v11 = v5 - (a3 + a5);
      result[2] = v10;
      result[3] = v11;
      if (v10 <= 0.0 || v11 <= 0.0)
      {
        result[2] = 0.0;
        result[3] = 0.0;
      }
    }
  }
  return result;
}

uint64_t CA::Render::LayerSubclass::self_intersects()
{
  return 0;
}

uint64_t CA::Render::SecureIndicatorLayer::has_background(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  *a3 = 0;
  return 1;
}

BOOL CA::OGL::AsynchronousItem::latch(os_unfair_lock_s *this)
{
  double v2 = this + 52;
  os_unfair_lock_lock(this + 52);
  uint64_t v3 = 0;
  int64x2_t v4 = 0;
  do
  {
    double v5 = &this[v3];
    if ((this[v3 + 59]._os_unfair_lock_opaque & 0xFFFFFFFE) == 2)
    {
      if (!v4 || this[v3 + 58]._os_unfair_lock_opaque > *((_DWORD *)v4 + 4)) {
        int64x2_t v4 = (char *)&v5[54];
      }
      v5[59]._os_unfair_lock_opaque = 0;
    }
    v3 += 14;
  }
  while (v3 != 28);
  os_unfair_lock_unlock(v2);
  if (v4)
  {
    dispatch_semaphore_wait(*((dispatch_semaphore_t *)v4 + 4), 0xFFFFFFFFFFFFFFFFLL);
    os_unfair_lock_lock(v2);
    *((_DWORD *)v4 + 5) = 3;
    *(void *)&this[82]._os_unfair_lock_opaque = v4;
    LOWORD(this[38]._os_unfair_lock_opaque) = *((_WORD *)v4 + 26);
    *(void *)&this[40]._os_unfair_lock_opaque = *((void *)v4 + 5);
    this[44]._os_unfair_lock_opaque = *(_DWORD *)(v4 + 48);
    os_unfair_lock_unlock(v2);
  }
  return v4 != 0;
}

uint64_t CA::Render::Updater::LayerShapes::union_visible_shape(uint64_t this, CA::Shape **a2, const CA::Shape *a3)
{
  v4[2] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (CA::Shape **)(this + 64);
  if (*(void *)(this + 64))
  {
    CA::shape_union((CA::Shape **)(this + 64), a2, a3);
    this = (uint64_t)*v3;
    if ((*v3 & 1) == 0 && *(int *)(this + 4) >= 257)
    {
      v4[0] = 0;
      v4[1] = 0;
      CA::Shape::get_bounds(this, (int *)v4);
      CA::Shape::unref(*v3);
      this = CA::Shape::new_shape((unsigned int *)v4);
      *uint64_t v3 = (CA::Shape *)this;
    }
  }
  return this;
}

BOOL CA::Render::GainMapLayer::has_background(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  *a3 = 0;
  if (*(unsigned char *)(a1 + 16) == 3 || BYTE10(xmmword_1EB2ACC50) != 0) {
    return 1;
  }
  if (CADeviceSupportsHWGainMap::once[0] != -1) {
    dispatch_once(CADeviceSupportsHWGainMap::once, &__block_literal_global_80);
  }
  return CADeviceSupportsHWGainMap::supports_gain_map == 0;
}

double CA::Render::Updater::LayerShapesOp::map_detached_rect(CA::Render::Updater::LayerShapesOp *this, Rect *a2)
{
  double result = 0.0;
  *(_OWORD *)&a2->top = 0u;
  *(_OWORD *)&a2[2].top = 0u;
  return result;
}

double CA::Render::Updater::TransformOp::map_crop(CA::Render::Updater::TransformOp *this, CA::Rect *a2, int8x16_t *a3)
{
  int64x2_t v4 = (CA::Render::Updater::TransformOp *)((char *)this + 24);
  CA::Rect::apply_transform(a3, (CA::Render::Updater::TransformOp *)((char *)this + 24), (double *)a3->i64);
  double result = *((double *)a2 + 2);
  if (result != 0.0)
  {
    return CA::Rect::apply_transform_interior((int8x16_t *)a2, v4);
  }
  return result;
}

double CA::Render::Updater::FilterOp::map_crop(CA::Render::Updater::FilterOp *this, CA::Rect *a2, __n128 *a3)
{
  if (!*((void *)this + 5)
    || (CA::Render::Updater::FilterOp::apply_filter(this, a3, 0), (uint64_t v5 = *((void *)this + 5)) == 0)
    || (uint64_t v6 = *(void *)(v5 + 48)) == 0
    || ((*(uint64_t (**)(uint64_t))(*(void *)v6 + 32))(v6) & 1) == 0)
  {
    double result = 0.0;
    *(_OWORD *)a2 = 0u;
    *((_OWORD *)a2 + 1) = 0u;
  }
  return result;
}

float64x2_t CA::Render::Updater::TransformOp::map_scale(uint64_t a1, float64x2_t *a2, uint64_t a3, double *a4)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  float64x2_t v6 = 0uLL;
  if ((*(unsigned char *)(a1 + 168) & 0x10) != 0)
  {
    CA::Mat4Impl::mat4_get_scale((CA::Mat4Impl *)(a1 + 24), v6.f64, &v6.f64[1], a4);
  }
  else
  {
    v6.f64[0] = *(float64_t *)(a1 + 152);
    v6.f64[1] = v6.f64[0];
  }
  float64x2_t result = vmulq_f64(*a2, v6);
  *a2 = result;
  return result;
}

float64_t CA::Render::Updater::ShadowOp::map_crop(CA::Render::Updater::ShadowOp *this, CA::Rect *a2, float64x2_t *a3)
{
  return CA::Render::Updater::ShadowOp::apply_shadow(this, a3);
}

uint64_t CA::OGL::ImagingNode::prepare_roi(CA::OGL::ImagingNode *this)
{
  uint64_t v2 = 0;
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  char v3 = 1;
  do
  {
    char v4 = v3;
    uint64_t v5 = (char *)this + 8 * v2;
    uint64_t v8 = *((void *)v5 + 3);
    uint64_t v7 = (uint64_t *)(v5 + 24);
    uint64_t result = v8;
    if (v8)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 96))(result);
      uint64_t v9 = *v7;
      int v10 = *(_DWORD *)(v9 + 220);
      int v11 = v10 & 0xC00000;
      int v12 = v10 & 0x3200000;
      if (!v11 && v12 != 50331648 && (*(unsigned char *)(v9 + 217) & 8) == 0)
      {
        double v14 = *(void **)(v9 + 8);
        if (!(v14[11] >> 25) && !*(void *)(v9 + 48) && (*(_WORD *)(v9 + 212) & 0x3C00) == 0)
        {
          uint64_t v15 = *((_DWORD *)this + 55) & 0x1FFFF;
          uint64_t v16 = *v14;
          uint64_t v17 = *(void *)(*v14 + 824);
          *(void *)(v16 + 824) = *(void *)(v9 + 16);
          *(_WORD *)(v16 + 832) &= ~0x800u;
          int v18 = 1065353216;
          uint64_t result = (*(uint64_t (**)(uint64_t, int *, uint64_t))(*(void *)v9 + 80))(v9, &v18, v15);
          *(void *)(v9 + 48) = result;
          if (result) {
            *(void *)(*(void *)(v9 + 8) + 88) += *(int *)(result + 28)
          }
                                                     * (uint64_t)*(int *)(result + 24)
                                                     * (*(unsigned char *)(result + 74) & 0x1F);
          *(void *)(v16 + 824) = v17;
          *(_WORD *)(v16 + 832) &= ~0x800u;
        }
      }
    }
    char v3 = 0;
    uint64_t v2 = 1;
  }
  while ((v4 & 1) != 0);
  return result;
}

uint64_t CA::OGL::CacheNode::retain_surface(CA::OGL::CacheNode *this, float *a2, uint64_t a3)
{
  v17[2] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = **((void **)this + 1);
  v17[0] = 0;
  v17[1] = 0;
  CA::Shape::get_bounds(*((void *)this + 8), (int *)v17);
  uint64_t v7 = CA::OGL::Context::cache_fetch(v6, (_DWORD *)this + 57);
  if (v7)
  {
    uint64_t v8 = v7;
    uint64_t v9 = *(void *)(v7 + 48);
    if (!v9) {
      goto LABEL_9;
    }
    if (!CA::BoundsImpl::contains((_DWORD *)(v9 + 32), v17)
      || ((*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v6 + 808))(v6, v9, 0) & 1) == 0)
    {
      CA::OGL::Context::cache_set_surface(v6, v8, 0);
    }
    uint64_t v10 = *(void *)(v8 + 48);
    if (v10)
    {
      int v16 = 1065353216;
      uint64_t v11 = *(void *)(v10 + 48);
      if (v11 == (*(uint64_t (**)(uint64_t))(*(void *)v6 + 96))(v6))
      {
        ++*(_DWORD *)v10;
        goto LABEL_13;
      }
    }
    else
    {
LABEL_9:
      ++*(_DWORD *)(v6 + 716);
      if (byte_1EB2ACBE3) {
        *(double *)(v8 + 56) = *(double *)(v6 + 240) + 0.1;
      }
      int v16 = 1065353216;
    }
    uint64_t v10 = (*(uint64_t (**)(void, int *, uint64_t))(**((void **)this + 3) + 80))(*((void *)this + 3), &v16, a3);
    CA::OGL::Context::cache_set_surface(v6, v8, v10);
LABEL_13:
    if (byte_1EB2ACBE3)
    {
      uint64_t v14 = *(void *)(*((void *)this + 2) + 104);
      if (v14)
      {
        if (*(double *)(v6 + 240) >= *(double *)(v8 + 56)) {
          int v15 = 0x40000;
        }
        else {
          int v15 = 393216;
        }
        *(_DWORD *)(v14 + 220) = *(_DWORD *)(v14 + 220) & 0xFFF1FFFF | v15;
      }
    }
    *(_DWORD *)a2 = v16;
    return v10;
  }
  float v13 = *(uint64_t (**)(void))(**((void **)this + 3) + 80);

  return v13();
}

uint64_t CA::OGL::Context::cache_fetch(uint64_t a1, _DWORD *a2)
{
  if (!*a2) {
    return 0;
  }
  uint64_t v4 = a1 + 368;
  for (uint64_t i = *(void *)(a1 + 376); i != v4; uint64_t i = *(void *)(i + 8))
  {
    if (*(_DWORD *)(i + 16) == *a2)
    {
      if (a2[1] != *(_DWORD *)(i + 20))
      {
        CA::OGL::Context::cache_set_surface(a1, i, 0);
        *(_OWORD *)(i + 28) = xmmword_184998040;
        *(_DWORD *)(i + 20) = a2[1];
      }
      uint64_t v9 = *(void *)i;
      uint64_t v8 = *(void **)(i + 8);
      *(void *)(v9 + 8) = v8;
      *uint64_t v8 = v9;
      *(void *)uint64_t i = i;
      *(void *)(i + 8) = i;
      goto LABEL_13;
    }
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  uint64_t v7 = malloc_type_zone_malloc(malloc_zone, 0x40uLL, 0x8BB15036uLL);
  uint64_t i = (uint64_t)v7;
  if (v7)
  {
    v7[2] = 0u;
    void v7[3] = 0u;
    _OWORD *v7 = 0u;
    v7[1] = 0u;
  }
  *((void *)v7 + 2) = *(void *)a2;
  *((void *)v7 + 6) = 0;
  *(_OWORD *)((char *)v7 + 28) = xmmword_184998040;
LABEL_13:
  *(_DWORD *)(i + 24) = *(_DWORD *)(a1 + 228);
  uint64_t v10 = *(uint64_t **)(a1 + 376);
  *(void *)(a1 + 376) = i;
  *(void *)uint64_t i = v4;
  *uint64_t v10 = i;
  *(void *)(i + 8) = v10;
  return i;
}

uint64_t CA::OGL::CacheNode::grow_roi(uint64_t this, int8x16_t *a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = **(void **)(this + 8);
  if ((*(unsigned char *)(v2 + 433) & 0x10) != 0) {
    return this;
  }
  uint64_t v4 = this;
  if (*(unsigned char *)(this + 224))
  {
    int8x16_t v5 = *a2;
    uint64_t v6 = (int32x2_t *)(this + 128);
    if ((*(_DWORD *)(this + 136) & 0x80000000) != 0)
    {
      int8x16_t v23 = *a2;
      (*(void (**)(uint64_t, uint64_t))(*(void *)this + 40))(this, this + 128);
      int8x16_t v5 = v23;
    }
    int32x2_t v7 = (int32x2_t)vextq_s8(v5, v5, 8uLL).u64[0];
    int32x2_t v8 = *(int32x2_t *)(v4 + 136);
    uint32x2_t v9 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v7);
    uint32x2_t v10 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v8);
    unsigned __int32 v11 = vpmax_u32(v10, v10).u32[0];
    if ((vpmax_u32(v9, v9).u32[0] & 0x80000000) != 0)
    {
      if ((v11 & 0x80000000) != 0) {
        goto LABEL_11;
      }
      *(int32x2_t *)v5.i8 = *v6;
    }
    else
    {
      if ((v11 & 0x80000000) != 0) {
        goto LABEL_11;
      }
      int32x2_t v12 = vadd_s32(*(int32x2_t *)v5.i8, v7);
      *(int32x2_t *)v5.i8 = vmin_s32(*(int32x2_t *)v5.i8, *v6);
      int32x2_t v8 = vsub_s32(vmax_s32(v12, vadd_s32(*v6, v8)), *(int32x2_t *)v5.i8);
    }
    v5.u64[1] = (unint64_t)v8;
LABEL_11:
    int8x16_t v24 = v5;
    this = (*(uint64_t (**)(void, uint64_t))(***(void ***)(v4 + 8) + 184))(**(void **)(v4 + 8), 7);
    if (v24.i32[2] <= (int)this && v24.i32[3] <= (int)this)
    {
      *a2 = v24;
      return this;
    }
  }
  this = CA::OGL::Context::cache_fetch(v2, (_DWORD *)(v4 + 228));
  if (this)
  {
    uint64_t v14 = *(void *)(this + 48);
    int v15 = 64;
    if (v14)
    {
      long long v25 = *(_OWORD *)(v14 + 32);
      this = CA::BoundsImpl::contains(&v25, a2);
      if (this) {
        int v15 = 64;
      }
      else {
        int v15 = 1024;
      }
    }
  }
  else
  {
    int v15 = 64;
  }
  int v16 = *(_DWORD *)(v4 + 136);
  if (v16 < 0)
  {
    this = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v4 + 40))(v4, v4 + 128);
    int v16 = *(_DWORD *)(v4 + 136);
  }
  __int32 v17 = a2->i32[2];
  if (v16 - v17 <= v15)
  {
    int v18 = *(_DWORD *)(v4 + 128);
  }
  else
  {
    int v18 = a2->i32[0] & -v15;
    int v16 = ((v15 + v17 + a2->i32[0] - 1) & -v15) - v18;
  }
  a2->i32[0] = v18;
  a2->i32[2] = v16;
  int v19 = *(_DWORD *)(v4 + 140);
  __int32 v20 = a2->i32[3];
  if (v19 - v20 <= v15)
  {
    a2->i32[1] = *(_DWORD *)(v4 + 132);
  }
  else
  {
    __int32 v21 = a2->i32[1];
    int v22 = v21 & -v15;
    a2->i32[1] = v22;
    int v19 = ((v15 + v20 + v21 - 1) & -v15) - v22;
  }
  a2->i32[3] = v19;
  return this;
}

void CA::Render::Update::added_all_contexts(uint64_t **this, CA::Render::LayerNode *a2, const CA::Shape *a3)
{
  char v3 = (CA::Render::Update *)this;
  uint64_t v200 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = this[74];
  if (v4)
  {
    do
    {
      uint64_t v5 = *v4;
      if (*v4)
      {
        uint64_t v6 = *v4;
        while ((*(unsigned char *)(v6 + 24) & 0x18) == 0)
        {
          uint64_t v7 = *(void *)(*(void *)(v6 + 32) + 40);
          if ((v7 & 0x80000) != 0 || (v7 & 0x840000) == 0x840000) {
            break;
          }
          uint64_t v6 = *(void *)(v6 + 88);
          if (!v6) {
            goto LABEL_8;
          }
        }
      }
      else
      {
LABEL_8:
        uint64_t v8 = *(void *)(*(void *)(v5 + 256) + 40);
        CA::Render::Update::invalidate_backdrops((uint64_t)v3, *(CA::Shape **)(v8 + 480), 0, 0);
        CA::shape_union((CA::Shape **)v3 + 2, *(CA::Shape ***)(v8 + 480), v9);
      }
      if (atomic_fetch_add((atomic_uint *volatile)(v5 + 16), 0xFFFFFFFF) == 1) {
        CA::Render::LayerNode::delete_node((CA::Render::LayerNode *)v5, a2);
      }
      uint64_t v4 = (uint64_t *)v4[1];
    }
    while (v4);
    uint32x2_t v10 = (void *)*((void *)v3 + 74);
    if (v10)
    {
      do
      {
        unsigned __int32 v11 = (void *)v10[1];
        free(v10);
        uint32x2_t v10 = v11;
      }
      while (v11);
    }
    *((void *)v3 + 74) = 0;
  }
  int32x2_t v12 = (int32x2_t *)*((void *)v3 + 63);
  if (v12)
  {
    float v13 = (CA::Shape **)((char *)v3 + 16);
    uint64_t v181 = v3;
    int64x2_t v14 = vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
    int8x16_t v187 = (int8x16_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    int8x16_t v188 = (int8x16_t)v14;
    v14.i64[0] = 0x7FF0000000000000;
    int64x2_t v186 = v14;
    v14.i32[0] = 1073741822;
    int32x4_t v184 = (int32x4_t)v14;
    int32x4_t v185 = (int32x4_t)v14;
    int32x4_t v182 = (int32x4_t)v14;
    int v183 = (CA::Shape **)((char *)v3 + 16);
    while (1)
    {
      uint64_t v15 = *(void *)(*(void *)&v12[1] + 256);
      os_unfair_lock_lock((os_unfair_lock_t)(v15 + 36));
      uint64_t v16 = *(void *)(v15 + 40);
      os_unfair_lock_lock((os_unfair_lock_t)(v16 + 40));
      float v18 = *(float *)(*(void *)(v15 + 40) + 60);
      float v19 = 0.0;
      if (v18 != 1.0) {
        float v19 = ceilf(0.5 / v18);
      }
      int v20 = *((_DWORD *)v3 + 62);
      if (*(_DWORD *)(v16 + 56) != v20 || *(_DWORD *)(v16 + 432) == v20)
      {
        char v21 = 0;
        goto LABEL_22;
      }
      unsigned int v57 = *((_DWORD *)v3 + 67);
      uint64_t v58 = *((void *)v3 + 73);
      unsigned int v59 = *(_DWORD *)(v16 + 12);
      *(_DWORD *)(v16 + 12) = v59 & 0xFFFFFBFF;
      *(_DWORD *)(v16 + 432) = v20;
      uint64_t v60 = *(void *)(v16 + 560);
      if (v60) {
        LODWORD(v60) = *(_DWORD *)(v60 + 16);
      }
      int v61 = (v59 >> 10) & 1;
      if (*(_DWORD *)(v16 + 556) != v60) {
        LOBYTE(v61) = 1;
      }
      *(_DWORD *)(v16 + 556) = v60;
      int v62 = (v57 >> 15) & 1;
      if ((v59 & 0x800) != 0) {
        char v63 = v61;
      }
      else {
        char v63 = 1;
      }
      if (*(unsigned __int8 *)(v16 + 569) == v62) {
        char v21 = v61;
      }
      else {
        char v21 = v63;
      }
      if (v58)
      {
        uint64_t v64 = *(void *)(v16 + 48);
        if (!v64 || *(void *)(v64 + 8) != v58) {
          char v21 = 1;
        }
      }
      unint64_t v117 = *(void *)(v16 + 64);
      int v118 = *(long long **)(v16 + 72);
      if (v118 == (long long *)v117)
      {
        unint64_t v117 = *(void *)(v16 + 72);
      }
      else
      {
        unint64_t v119 = 0xCF3CF3CF3CF3CF3DLL * ((uint64_t)((uint64_t)v118 - v117) >> 3);
        do
        {
          unint64_t v120 = v119 - 1;
          if (0xCF3CF3CF3CF3CF3DLL * ((uint64_t)((uint64_t)v118 - v117) >> 3) <= v119 - 1) {
LABEL_208:
          }
            __assert_rtn("operator[]", "x-small-vector.h", 91, "pos < size () && \"Out of bounds access\"");
          if (*(_DWORD *)(v117 + 168 * v120 + 164) != v20 || !*(void *)(v117 + 168 * v120 + 8))
          {
            BOOL v121 = (long long *)(v117 + 168 * v119);
            if (v121 != v118)
            {
              float v122 = (char *)v121 - 168;
              do
              {
                long long v123 = *(_OWORD *)(v122 + 184);
                *(_OWORD *)float v122 = *(_OWORD *)(v122 + 168);
                *((_OWORD *)v122 + 1) = v123;
                long long v124 = *(_OWORD *)(v122 + 216);
                *((_OWORD *)v122 + 2) = *(_OWORD *)(v122 + 200);
                *((_OWORD *)v122 + 3) = v124;
                long long v125 = *(_OWORD *)(v122 + 248);
                *((_OWORD *)v122 + 4) = *(_OWORD *)(v122 + 232);
                *((_OWORD *)v122 + 5) = v125;
                long long v126 = *(_OWORD *)(v122 + 264);
                long long v127 = *(_OWORD *)(v122 + 280);
                long long v128 = *(_OWORD *)(v122 + 296);
                long long v129 = *(_OWORD *)(v122 + 312);
                *((void *)v122 + 20) = *((void *)v122 + 41);
                *((_OWORD *)v122 + 8) = v128;
                *((_OWORD *)v122 + 9) = v129;
                unsigned __int8 v130 = (long long *)(v122 + 336);
                *((_OWORD *)v122 + 6) = v126;
                *((_OWORD *)v122 + 7) = v127;
                v122 += 168;
              }
              while (v130 != v118);
              unint64_t v117 = *(void *)(v16 + 64);
              int v118 = *(long long **)(v16 + 72);
            }
            if ((unint64_t)v118 <= v117) {
              __assert_rtn("pop_back", "x-small-vector.h", 410, "_end > _begin && \"pop_back on empty container\"");
            }
            int v118 = (long long *)((char *)v118 - 168);
            *(void *)(v16 + 72) = v118;
            char v21 = 1;
          }
          unint64_t v119 = v120;
        }
        while (v120);
      }
      unint64_t v131 = 126 - 2 * __clz(0xCF3CF3CF3CF3CF3DLL * ((uint64_t)((uint64_t)v118 - v117) >> 3));
      uint64_t v132 = v118 == (long long *)v117 ? 0 : v131;
      std::__introsort<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *,false>(v117, v118, v132, 1);
      uint64_t v133 = *(void *)(v16 + 64);
      uint64_t v134 = *(void *)(v16 + 72) - v133;
      if (v134)
      {
        unint64_t v135 = 0xCF3CF3CF3CF3CF3DLL * (v134 >> 3) - 1;
        float v136 = (float64x2_t *)(v133 + 168 * v135);
        float64x2_t v138 = v136[1];
        float64x2_t v137 = v136[2];
        float64x2_t v194 = v136[5];
        float64x2_t v195 = v136[6];
        if (0xCF3CF3CF3CF3CF3DLL * (v134 >> 3) != 1)
        {
          float64x2_t v189 = v137;
          uint64_t v139 = 0;
          unint64_t v140 = 0;
          while (1)
          {
            float64x2_t v198 = 0u;
            float64x2_t v199 = 0u;
            *(_OWORD *)uint64_t v196 = 0u;
            float64x2_t v197 = 0u;
            uint64_t v141 = *(void *)(v16 + 64);
            unint64_t v142 = 0xCF3CF3CF3CF3CF3DLL * ((*(void *)(v16 + 72) - v141) >> 3);
            if (v142 <= v140) {
              goto LABEL_208;
            }
            double v143 = *(double *)(v141 + v139 + 24);
            double v144 = *(double *)(v141 + v139 + 32);
            double v145 = *(double *)(v141 + v139 + 40);
            v196[0] = *(CA::Shape **)(v141 + v139 + 16);
            v196[1] = *(CA::Shape **)&v143;
            v197.f64[0] = v144 + *(double *)v196;
            v197.f64[1] = v143;
            v198.f64[0] = v144 + *(double *)v196;
            v198.f64[1] = v145 + v143;
            *(CA::Shape **)&v199.f64[0] = v196[0];
            v199.f64[1] = v145 + v143;
            *(void *)&long long v192 = &unk_1ED030230;
            *((void *)&v192 + 1) = 4;
            unint64_t v193 = v196;
            if (v142 <= v135) {
              goto LABEL_208;
            }
            float64x2_t v190 = v138;
            CA::Render::LayerNode::MapGeometry::map((uint64_t)&v192, *(CA::Render::LayerNode **)(v141 + v139 + 8), *(CA::Render::LayerNode **)(v141 + 168 * v135 + 8));
            int8x16_t v146 = vbslq_s8((int8x16_t)vcgtq_f64(v197, *(float64x2_t *)v196), *(int8x16_t *)v196, (int8x16_t)v197);
            int8x16_t v147 = vbslq_s8((int8x16_t)vcgtq_f64(*(float64x2_t *)v196, v197), *(int8x16_t *)v196, (int8x16_t)v197);
            int8x16_t v148 = vbslq_s8((int8x16_t)vcgtq_f64(v199, v198), (int8x16_t)v198, (int8x16_t)v199);
            float64x2_t v149 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v198, v199), (int8x16_t)v198, (int8x16_t)v199);
            int8x16_t v150 = vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v148, (float64x2_t)v146), v146, v148);
            int8x16_t v151 = (int8x16_t)vsubq_f64((float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)v147, v149), v147, (int8x16_t)v149), (float64x2_t)v150);
            *(void *)&v149.f64[0] = COERCE_UNSIGNED_INT64(vaddvq_f64((float64x2_t)v151)) & 0x7FFFFFFFFFFFFFFFLL;
            float64x2_t v152 = (float64x2_t)vbslq_s8((int8x16_t)vdupq_lane_s64(vcgtq_s64(v186, (int64x2_t)v149).i64[0], 0), v151, v187);
            *(int32x2_t *)&v149.f64[0] = vdup_n_s32(*(void *)&v149.f64[0] < 0x7FF0000000000000);
            v153.i64[0] = LODWORD(v149.f64[0]);
            v153.i64[1] = HIDWORD(v149.f64[0]);
            float64x2_t v154 = v189;
            float64x2_t v155 = (float64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v153, 0x3FuLL)), v150, v188);
            int64x2_t v156 = vclezq_f64(v189);
            int64x2_t v157 = vclezq_f64(v152);
            int32x2_t v158 = vmovn_s64(vcltzq_s64((int64x2_t)vorrq_s8((int8x16_t)vzip1q_s64(v157, v156), (int8x16_t)vzip2q_s64(v157, v156))));
            if (v158.i8[4]) {
              break;
            }
            if ((v158.i8[0] & 1) == 0)
            {
              float64x2_t v159 = vaddq_f64(v155, v152);
              float64x2_t v155 = vminnmq_f64(v190, v155);
              float64x2_t v152 = vsubq_f64(vmaxnmq_f64(vaddq_f64(v190, v189), v159), v155);
LABEL_145:
              float64x2_t v190 = v155;
              float64x2_t v154 = v152;
            }
LABEL_146:
            float64x2_t v189 = v154;
            *(unsigned char *)(v141 + v139 + 161) = CA::BoundsImpl::contains(v194.f64, (double *)(v141 + v139 + 80));
            ++v140;
            v139 += 168;
            float64x2_t v138 = v190;
            if (v135 == v140)
            {
              double v160 = v190.f64[0];
              char v3 = v181;
              float64x2_t v137 = v189;
              goto LABEL_150;
            }
          }
          if (v158.i8[0]) {
            goto LABEL_146;
          }
          goto LABEL_145;
        }
        double v160 = v138.f64[0];
LABEL_150:
        float v13 = v183;
      }
      else
      {
        double v160 = 0.0;
        v138.f64[1] = 0.0;
        float64x2_t v137 = 0uLL;
      }
      if (*(double *)(v16 + 488) != v160) {
        break;
      }
      float64_t v161 = v138.f64[1];
      if (*(double *)(v16 + 496) != v138.f64[1]
        || *(double *)(v16 + 504) != v137.f64[0]
        || *(double *)(v16 + 512) != v137.f64[1])
      {
        goto LABEL_157;
      }
LABEL_158:
      *(double *)(v16 + 488) = v160;
      *(float64_t *)(v16 + 496) = v161;
      *(float64x2_t *)(v16 + 504) = v137;
      if (*(void *)(v16 + 48))
      {
        BOOL v162 = 0;
        if ((v21 & 1) == 0) {
          goto LABEL_162;
        }
      }
      else
      {
        BOOL v162 = (*(unsigned char *)(v16 + 13) & 8) == 0;
        if ((v21 & 1) == 0)
        {
LABEL_162:
          if (!v162) {
            goto LABEL_22;
          }
        }
      }
      unint64_t v163 = *(void *)(v16 + 480);
      if (v163)
      {
        if (*(void *)(v16 + 520))
        {
          CA::Shape::unref(*(CA::Shape **)(v16 + 520));
          unint64_t v163 = *(void *)(v16 + 480);
        }
        *(void *)(v16 + 520) = CA::Shape::ref(v163);
      }
LABEL_22:
      int v22 = *(CA::Shape **)(v16 + 536);
      if (v22) {
        CA::Shape::unref(v22);
      }
      unint64_t v23 = *(void *)(v16 + 528);
      if (v23) {
        unint64_t v23 = CA::Shape::ref(v23);
      }
      *(void *)(v16 + 536) = v23;
      if (v21 & 1 | (BYTE7(xmmword_1EB2ACC10) != 0)) {
        CA::shape_union(v13, *(CA::Shape ***)(v16 + 480), v17);
      }
      os_unfair_lock_unlock((os_unfair_lock_t)(v16 + 40));
      int v24 = v12[4].i32[0];
      int v25 = v12[4].i32[1];
      if (v24 >= v25) {
        int v26 = v12[4].i32[1];
      }
      else {
        int v26 = v12[4].i32[0];
      }
      if (v26 < 1) {
        goto LABEL_116;
      }
      float64x2_t v27 = v12 + 3;
      long long v192 = 0uLL;
      float64x2_t v28 = (int32x2_t *)(v15 + 48);
      long long v191 = 0uLL;
      if (!CA::BoundsImpl::contains(&v12[3], (_DWORD *)(v15 + 48)))
      {
        if (v24 <= v25) {
          int v33 = v25;
        }
        else {
          int v33 = v24;
        }
        v29.i32[0] = v33;
        float64x2_t v197 = 0u;
        int32x2_t v34 = v12[3];
        v35.i64[0] = v34.i32[0];
        v35.i64[1] = v34.i32[1];
        int32x4_t v36 = (int32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v29, v185), 0), v188, (int8x16_t)vcvtq_f64_s64(v35));
        double v37 = (double)v25;
        if (v33 <= 1073741822) {
          double v38 = (double)v24;
        }
        else {
          double v38 = 1.79769313e308;
        }
        if (v33 > 1073741822) {
          double v37 = 1.79769313e308;
        }
        *(int32x4_t *)uint64_t v196 = v36;
        v197.f64[0] = v38;
        v197.f64[1] = v37;
        float v39 = *(float *)&v12[12].i32[1];
        if (v39 != 0.0)
        {
          int v40 = *(_DWORD *)(v15 + 60);
          double v41 = (double)(*(_DWORD *)(v15 + 48) + *(_DWORD *)(v15 + 56) / 2);
          if (v40 >= 0) {
            int v42 = *(_DWORD *)(v15 + 60);
          }
          else {
            int v42 = v40 + 1;
          }
          double v43 = *(double *)v36.i64 - v41;
          float v44 = 1.0 / (float)((float)(v39 * 2.0) + 1.0);
          double v45 = v44;
          if (v44 != 1.0 && v38 < 1.79769313e308)
          {
            double v43 = v43 * v45;
            v197.f64[0] = v38 * v45;
          }
          int v47 = *(_DWORD *)(v15 + 52) + (v42 >> 1);
          double v48 = *(double *)&v36.i64[1] - (double)v47;
          v36.i32[1] = 2146435071;
          if (v44 != 1.0 && v37 < 1.79769313e308)
          {
            double v48 = v48 * v45;
            *(double *)v36.i64 = v37 * v45;
            v197.f64[1] = v37 * v45;
          }
          v36.i32[0] = v33;
          v50.i64[0] = v27->i32[0];
          v50.i64[1] = (int)HIDWORD(*(unint64_t *)v27);
          float64x2_t v51 = (float64x2_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v36, v184), 0), v188, (int8x16_t)vcvtq_f64_s64(v50));
          double v52 = v43 + v41;
          v53.f64[0] = v38;
          v53.f64[1] = v37;
          v196[0] = *(CA::Shape **)&v52;
          *(double *)&v196[1] = v48 + (double)v47;
          int64x2_t v54 = vclezq_f64(v197);
          int64x2_t v55 = vclezq_f64(v53);
          int32x2_t v56 = vmovn_s64(vcltzq_s64((int64x2_t)vorrq_s8((int8x16_t)vzip1q_s64(v55, v54), (int8x16_t)vzip2q_s64(v55, v54))));
          if (v56.i8[4])
          {
            if ((v56.i8[0] & 1) == 0)
            {
              *(float64x2_t *)uint64_t v196 = v51;
              v197.f64[0] = v38;
              goto LABEL_77;
            }
          }
          else if ((v56.i8[0] & 1) == 0)
          {
            float64x2_t v65 = vminnmq_f64(*(float64x2_t *)v196, v51);
            float64x2_t v66 = vsubq_f64(vmaxnmq_f64(vaddq_f64(*(float64x2_t *)v196, v197), vaddq_f64(v51, v53)), v65);
            *(float64x2_t *)uint64_t v196 = v65;
            double v37 = v66.f64[1];
            v197.f64[0] = v66.f64[0];
LABEL_77:
            v197.f64[1] = v37;
          }
        }
        *(void *)&v194.f64[0] = &unk_1ED030210;
        *(void *)&v194.f64[1] = 1;
        *(void *)&v195.f64[0] = v196;
        CA::Render::LayerNode::MapGeometry::map((uint64_t)&v194, 0, *(CA::Render::LayerNode **)&v12[1]);
        CA::Rect::apply_transform((double *)v196, (uint64_t)&v12[6]);
        CA::Render::Updater::apply_shapes_ops(*(void **)&v12[11], (CA::Render::Updater::LayerShapesOp *)v196, v67);
        uint64_t v68 = *((void *)v3 + 25);
        int v69 = v68;
        if ((int)v68 <= SHIDWORD(v68)) {
          int v69 = HIDWORD(v68);
        }
        float64x2_t v70 = v197;
        int64x2_t v71 = vclezq_f64(v197);
        if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v71, 1), (int8x16_t)v71).u64[0] & 0x8000000000000000) == 0)
        {
          v72.i64[0] = (int)v68;
          v72.i64[1] = SHIDWORD(v68);
          int8x16_t v73 = (int8x16_t)vcvtq_f64_s64(v72);
          int32x2_t v74 = vdup_n_s32(v69 > 1073741822);
          v72.i64[0] = v74.u32[0];
          v72.i64[1] = v74.u32[1];
          float64x2_t v75 = (float64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v72, 0x3FuLL)), v187, v73);
          int64x2_t v76 = vclezq_f64(v75);
          int32x4_t v77 = (int32x4_t)vdupq_laneq_s64(v76, 1);
          if ((vorrq_s8((int8x16_t)v77, (int8x16_t)v76).u64[0] & 0x8000000000000000) != 0) {
            goto LABEL_84;
          }
          uint64_t v78 = *((void *)v3 + 24);
          v79.i64[0] = (int)v78;
          v79.i64[1] = SHIDWORD(v78);
          v77.i32[0] = v69;
          float64x2_t v80 = (float64x2_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v77, v182), 0), v188, (int8x16_t)vcvtq_f64_s64(v79));
          float64x2_t v81 = vaddq_f64(v80, v75);
          float64x2_t v82 = vmaxnmq_f64(*(float64x2_t *)v196, v80);
          float64x2_t v70 = vsubq_f64(vminnmq_f64(vaddq_f64(*(float64x2_t *)v196, v197), v81), v82);
          int64x2_t v83 = vclezq_f64(v70);
          if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v83, 1), (int8x16_t)v83).u64[0] & 0x8000000000000000) != 0)
          {
LABEL_84:
            float64x2_t v197 = 0uLL;
            float64x2_t v70 = 0uLL;
          }
          else
          {
            *(float64x2_t *)uint64_t v196 = v82;
            float64x2_t v197 = v70;
          }
        }
        int64x2_t v84 = vceqzq_f64(v70);
        unint64_t v85 = vorrq_s8((int8x16_t)vdupq_laneq_s64(v84, 1), (int8x16_t)v84).u64[0];
        int8x16_t v86 = 0uLL;
        if ((v85 & 0x8000000000000000) == 0)
        {
          int8x16_t v87 = vorrq_s8((int8x16_t)vcltzq_f64(v70), (int8x16_t)vcgezq_f64(v70));
          if ((vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v87), 1), v87).u64[0] & 0x8000000000000000) == 0)
          {
            float64x2_t v88 = vminnmq_f64(vaddq_f64(*(float64x2_t *)v196, v70), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL));
            int32x4_t v89 = (int32x4_t)vcvtmq_s64_f64(vmaxnmq_f64(*(float64x2_t *)v196, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000)));
            int8x16_t v86 = (int8x16_t)vuzp1q_s32(v89, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(v88), (int64x2_t)v89));
          }
        }
        int32x2_t v90 = (int32x2_t)vextq_s8(v86, v86, 8uLL).u64[0];
        int32x2_t v91 = v12[4];
        uint32x2_t v92 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v90);
        unsigned __int32 v93 = vpmax_u32(v92, v92).u32[0];
        uint32x2_t v94 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v91);
        unsigned __int32 v95 = vpmax_u32(v94, v94).u32[0];
        if ((v93 & 0x80000000) != 0)
        {
          if ((v95 & 0x80000000) == 0)
          {
            *(int32x2_t *)v86.i8 = *v27;
LABEL_93:
            v86.u64[1] = (unint64_t)v91;
            int32x2_t v90 = (int32x2_t)vextq_s8(v86, v86, 8uLL).u64[0];
          }
        }
        else if ((v95 & 0x80000000) == 0)
        {
          int32x2_t v96 = vadd_s32(*(int32x2_t *)v86.i8, v90);
          *(int32x2_t *)v86.i8 = vmin_s32(*(int32x2_t *)v86.i8, *v27);
          int32x2_t v91 = vsub_s32(vmax_s32(v96, vadd_s32(*v27, v91)), *(int32x2_t *)v86.i8);
          goto LABEL_93;
        }
        uint32x2_t v97 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v90);
        if ((vpmax_u32(v97, v97).u32[0] & 0x80000000) != 0) {
          goto LABEL_111;
        }
        int32x2_t v98 = *(int32x2_t *)(v15 + 56);
        uint32x2_t v99 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v98);
        if ((vpmax_u32(v99, v99).u32[0] & 0x80000000) != 0
          || (int32x2_t v100 = *v28,
              int32x2_t v101 = vadd_s32(*(int32x2_t *)v86.i8, v90),
              int32x2_t v102 = vadd_s32(*v28, v98),
              int32x2_t v103 = vmax_s32(*(int32x2_t *)v86.i8, *v28),
              int32x2_t v104 = vsub_s32(vmin_s32(v101, v102), v103),
              uint32x2_t v105 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v104),
              (vpmax_u32(v105, v105).u32[0] & 0x80000000) != 0))
        {
LABEL_111:
          int v32 = 0;
          int v31 = 0;
        }
        else
        {
          int v31 = v104.i32[0];
          int v32 = v104.i32[1];
          *(int32x2_t *)&long long v106 = v103;
          *((int32x2_t *)&v106 + 1) = v104;
          long long v191 = v106;
          long long v192 = v106;
          if (v104.i32[0] <= v104.i32[1]) {
            int v107 = v104.i32[1];
          }
          else {
            int v107 = v104.i32[0];
          }
          if (v104.i32[0] >= v104.i32[1]) {
            int v108 = v104.i32[1];
          }
          else {
            int v108 = v104.i32[0];
          }
          if (v107 <= 1073741822 && v108 >= 1)
          {
            unsigned int v109 = (int)(float)-v19;
            *(int32x2_t *)&long long v191 = vadd_s32(v103, vdup_n_s32(v109));
            int v110 = v104.i32[0] - 2 * v109;
            int v111 = v104.i32[1] - 2 * v109;
            *((void *)&v191 + 1) = __PAIR64__(v111, v110);
            if (v110 < 1 || v111 <= 0) {
              *((void *)&v191 + 1) = 0;
            }
          }
          uint32x2_t v112 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)((char *)&v191 + 8));
          if ((vpmax_u32(v112, v112).u32[0] & 0x80000000) == 0)
          {
            *(int32x2_t *)&long long v113 = vmax_s32(*(int32x2_t *)&v191, v100);
            int32x2_t v114 = vsub_s32(vmin_s32(vadd_s32(*(int32x2_t *)&v191, *(int32x2_t *)((char *)&v191 + 8)), v102), *(int32x2_t *)&v113);
            uint32x2_t v115 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v114);
            if ((vpmax_u32(v115, v115).u32[0] & 0x80000000) != 0)
            {
              *((void *)&v191 + 1) = 0;
            }
            else
            {
              *((int32x2_t *)&v113 + 1) = v114;
              long long v191 = v113;
            }
          }
        }
        goto LABEL_112;
      }
      unsigned int v30 = *(_DWORD *)(v15 + 52);
      LODWORD(v192) = *(_DWORD *)(v15 + 48);
      DWORD1(v192) = v30;
      int v31 = *(_DWORD *)(v15 + 56);
      int v32 = *(_DWORD *)(v15 + 60);
      *((void *)&v192 + 1) = __PAIR64__(v32, v31);
      *(void *)&long long v191 = __PAIR64__(v30, v192);
      *((void *)&v191 + 1) = __PAIR64__(v32, v31);
LABEL_112:
      if (v31 >= v32) {
        int v31 = v32;
      }
      if (v31 >= 1)
      {
        float64x2_t v197 = 0u;
        float64x2_t v198 = 0u;
        *(_OWORD *)uint64_t v196 = 0u;
        CA::Shape::operator=((uint64_t)v196, &v191);
        CA::shape_union(v13, v196, v116);
        float64x2_t v197 = 0u;
        float64x2_t v198 = 0u;
        *(_OWORD *)uint64_t v196 = 0u;
        CA::Shape::operator=((uint64_t)v196, &v192);
        CA::Render::Update::invalidate_backdrops((uint64_t)v3, (CA::Shape *)v196, (int32x2_t **)v12, 1);
      }
LABEL_116:
      os_unfair_lock_unlock((os_unfair_lock_t)(v15 + 36));
      int32x2_t v12 = (int32x2_t *)*v12;
      if (!v12) {
        goto LABEL_168;
      }
    }
    float64_t v161 = v138.f64[1];
LABEL_157:
    char v21 = 1;
    goto LABEL_158;
  }
LABEL_168:
  for (uint64_t i = (void *)*((void *)v3 + 68); i; uint64_t i = (void *)*i)
  {
    uint64_t v165 = (CA::Shape **)i[2];
    if (v165)
    {
      uint64_t v166 = (unint64_t *)(i[1] + 520);
      if (*v166) {
        CA::shape_union((CA::Shape **)(i[1] + 520), v165, a3);
      }
      else {
        *uint64_t v166 = CA::Shape::ref(i[2]);
      }
    }
  }
  uint64_t v167 = *((unsigned int *)v3 + 128);
  if (v167)
  {
    if (*((void *)v3 + 67))
    {
      unint64_t v168 = 0;
      do
      {
        uint64_t v169 = *(CA::Shape **)(*((void *)v3 + 67) + 8 * v168);
        if (v169)
        {
          CA::Shape::unref(v169);
          LODWORD(v167) = *((_DWORD *)v3 + 128);
        }
        ++v168;
      }
      while (v168 < v167);
    }
    else
    {
      *((void *)v3 + 67) = malloc_type_malloc(8 * v167, 0x8639EFE1uLL);
      LODWORD(v167) = *((_DWORD *)v3 + 128);
    }
    uint64_t v170 = (void *)*((void *)v3 + 63);
    if (v170)
    {
      unsigned int v171 = v167 - 1;
      do
      {
        uint64_t v172 = *(void *)(v170[2] + 8);
        os_unfair_lock_lock((os_unfair_lock_t)(v172 + 40));
        uint64_t v173 = *(void *)(v172 + 520);
        if (v173) {
          uint64_t v174 = CA::Shape::intersect(v173, v170[5]);
        }
        else {
          uint64_t v174 = 1;
        }
        *(void *)(*((void *)v3 + 67) + 8 * v171) = v174;
        os_unfair_lock_unlock((os_unfair_lock_t)(v172 + 40));
        uint64_t v170 = (void *)*v170;
        --v171;
      }
      while (v170);
      LODWORD(v167) = *((_DWORD *)v3 + 128);
    }
    if (v167 >= 2)
    {
      uint64_t v175 = 0;
      unint64_t v176 = 1;
      do
      {
        CA::shape_union((CA::Shape **)(*((void *)v3 + 67) + v175 + 8), *(CA::Shape ***)(*((void *)v3 + 67) + v175), a3);
        ++v176;
        v175 += 8;
      }
      while (v176 < *((unsigned int *)v3 + 128));
    }
  }
  CA::shape_intersect((CA::Shape **)v3 + 2, (CA::Shape **)v3 + 24, a3);
  int v177 = (CA::Shape *)*((void *)v3 + 3);
  if (v177)
  {
    CA::Shape::unref(v177);
    *((void *)v3 + 3) = 0;
  }
  *((void *)v3 + 3) = CA::Shape::ref(*((void *)v3 + 2));
  if ((*((unsigned char *)v3 + 269) & 2) != 0) {
    notify_post("com.apple.CoreAnimation.CAWindowServer.SecureModeViolation");
  }
  unint64_t v178 = *((unsigned int *)v3 + 271) | ((unint64_t)*((unsigned __int16 *)v3 + 544) << 32) | 0x100000000;
  *((_WORD *)v3 + 544) = WORD2(v178);
  uint64_t v179 = *((void *)v3 + 4);
  if ((v179 & 1) == 0)
  {
    if (*(_DWORD *)(v179 + 4) == 6) {
      goto LABEL_201;
    }
    goto LABEL_200;
  }
  if (v179 != 1)
  {
LABEL_200:
    uint64_t v180 = CA::Shape::dilate(v179, 1u, 1u);
    CA::Shape::unref(*((CA::Shape **)v3 + 4));
    *((void *)v3 + 4) = v180;
    LODWORD(v178) = *((_DWORD *)v3 + 271);
  }
LABEL_201:
  if ((v178 & 4) == 0 && BYTE9(xmmword_1EB2ACC10)) {
    kdebug_trace();
  }
  if (initialized != -1) {
    dispatch_once_f(&initialized, 0, (dispatch_function_t)init_debug);
  }
  if (*(float *)&dword_1EB2ACB8C)
  {
    if (*(float *)&dword_1EB2ACB8C > 0.0) {
      *(float *)&dword_1EB2ACB8C = *(float *)&dword_1EB2ACB8C + -1.0;
    }
  }
}

BOOL CA::BoundsImpl::contains(double *a1, double *a2)
{
  double v2 = a1[2];
  if (v2 > 0.0
    && (double v3 = a1[3], v3 > 0.0)
    && (double v4 = a2[2], v4 >= 0.0)
    && (double v5 = a2[3], v5 >= 0.0)
    && *a1 <= *a2
    && (double v6 = a1[1], v7 = a2[1], v6 <= v7)
    && *a1 + v2 >= *a2 + v4)
  {
    return v6 + v3 >= v7 + v5;
  }
  else
  {
    return 0;
  }
}

BOOL CA::Bounds::contains(CA::Bounds *this, uint64_t a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    if (a2 != 1)
    {
      int v16 = a2 >> 48;
      int v17 = (int)((unint64_t)a2 >> 16) >> 16;
      unsigned int v18 = a2 >> 17;
      unsigned int v5 = (a2 >> 2) & 0x7FFF;
      goto LABEL_7;
    }
    return 0;
  }
  int v2 = *(_DWORD *)(a2 + 4);
  if (v2 == 6) {
    return 0;
  }
  if (v2 == 12)
  {
    int v3 = *(_DWORD *)(a2 + 20);
    int v4 = *(_DWORD *)(a2 + 32);
    int v16 = *(_DWORD *)(a2 + 28);
    int v17 = v3;
    unsigned int v18 = v4 - v16;
    unsigned int v5 = *(_DWORD *)(a2 + 36) - v3;
LABEL_7:
    unsigned int v19 = v5;
    return CA::BoundsImpl::contains(this, &v16);
  }
  int v9 = *(_DWORD *)(a2 + 12);
  double v7 = (char *)(a2 + 12);
  int v8 = v9;
  if (v9 != 0x7FFFFFFF)
  {
    int v10 = *(_DWORD *)this;
    int v11 = *((_DWORD *)this + 1);
    int v12 = *((_DWORD *)this + 2) + *(_DWORD *)this;
    int v13 = *((_DWORD *)this + 3) + v11;
    BOOL result = 1;
    while (1)
    {
      uint64_t v14 = *((int *)v7 + 1);
      uint64_t v15 = &v7[4 * v14];
      if (v14 == 2)
      {
        int v8 = *(_DWORD *)v15;
      }
      else
      {
        if (v8 < v11) {
          return 0;
        }
        int v8 = *(_DWORD *)v15;
        if (*(_DWORD *)v15 > v13 || *((_DWORD *)v7 + 2) < v10 || *((_DWORD *)v15 - 1) > v12) {
          return 0;
        }
      }
      v7 += 4 * v14;
      if (v8 == 0x7FFFFFFF) {
        return result;
      }
    }
  }
  return 1;
}

uint64_t CA::Render::Update::fullfill_backdrops(uint64_t this, const CA::Shape *a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    uint64_t v3 = this;
    if (a2)
    {
      if (a2 == (const CA::Shape *)1) {
        return this;
      }
    }
    else if (*((_DWORD *)a2 + 1) == 6)
    {
      return this;
    }
    for (uint64_t i = *(uint64_t **)(this + 504); i; uint64_t i = (uint64_t *)*i)
    {
      int v5 = *((_DWORD *)i + 24);
      if ((v5 & 0x40000000) == 0)
      {
        long long v6 = *(_OWORD *)(*(void *)(i[1] + 256) + 48);
        long long v14 = v6;
        uint32x2_t v7 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)((char *)&v6 + 8));
        if ((vpmax_u32(v7, v7).u32[0] & 0x80000000) == 0)
        {
          int32x2_t v8 = *(int32x2_t *)(v3 + 200);
          uint32x2_t v9 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v8);
          if ((vpmax_u32(v9, v9).u32[0] & 0x80000000) != 0
            || (int32x2_t v10 = *(int32x2_t *)(v3 + 192),
                int32x2_t v11 = vadd_s32(*(int32x2_t *)&v6, *(int32x2_t *)((char *)&v6 + 8)),
                *(int32x2_t *)&long long v6 = vmax_s32(*(int32x2_t *)&v6, v10),
                int32x2_t v12 = vsub_s32(vmin_s32(v11, vadd_s32(v10, v8)), *(int32x2_t *)&v6),
                uint32x2_t v13 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v12),
                (vpmax_u32(v13, v13).u32[0] & 0x80000000) != 0))
          {
            *((void *)&v14 + 1) = 0;
          }
          else
          {
            *((int32x2_t *)&v6 + 1) = v12;
            long long v14 = v6;
          }
        }
        this = CA::Shape::contains((uint64_t)a2, (const CA::Bounds *)&v14);
        if (this) {
          *((_DWORD *)i + 24) = v5 | 0x40000000;
        }
      }
    }
  }
  return this;
}

BOOL CA::Shape::contains(uint64_t this, const CA::Bounds *a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (this)
  {
    if (this != 1)
    {
      int v19 = this >> 48;
      int v20 = (int)((unint64_t)this >> 16) >> 16;
      unsigned int v21 = this >> 17;
      unsigned int v4 = (this >> 2) & 0x7FFF;
      goto LABEL_6;
    }
  }
  else if (*(_DWORD *)(this + 4) == 12)
  {
    int v2 = *(_DWORD *)(this + 20);
    int v3 = *(_DWORD *)(this + 32);
    int v19 = *(_DWORD *)(this + 28);
    int v20 = v2;
    unsigned int v21 = v3 - v19;
    unsigned int v4 = *(_DWORD *)(this + 36) - v2;
LABEL_6:
    unsigned int v22 = v4;
    return CA::BoundsImpl::contains(&v19, a2);
  }
  int v6 = *((_DWORD *)a2 + 2);
  if (!v6) {
    return 0;
  }
  int v7 = *((_DWORD *)a2 + 3);
  if (!v7) {
    return 0;
  }
  if (this)
  {
    if (this != 1) {
      goto LABEL_13;
    }
    return 0;
  }
  if (*(_DWORD *)(this + 4) == 6) {
    return 0;
  }
LABEL_13:
  uint64_t v5 = 0;
  int v10 = *(_DWORD *)(this + 12);
  int32x2_t v8 = (char *)(this + 12);
  int v9 = v10;
  if (v10 != 0x7FFFFFFF)
  {
    int v11 = *((_DWORD *)a2 + 1);
    int v12 = v11 + v7;
    if (v9 < v12)
    {
      int v13 = *(_DWORD *)a2 + v6;
      while (v11 >= v9)
      {
        uint64_t v14 = *((int *)v8 + 1);
        uint64_t v15 = &v8[4 * v14];
        int v9 = *(_DWORD *)v15;
        if (v11 < *(_DWORD *)v15 && (int)v14 >= 3)
        {
          int v17 = v8 + 8;
          while (*(_DWORD *)a2 < *(_DWORD *)v17 || v13 > *((_DWORD *)v17 + 1))
          {
            v17 += 8;
            if (v17 >= v15) {
              goto LABEL_27;
            }
          }
          int v11 = *(_DWORD *)v15;
          if (v12 <= v9) {
            return 1;
          }
        }
LABEL_27:
        uint64_t v5 = 0;
        if (v9 != 0x7FFFFFFF)
        {
          int32x2_t v8 = v15;
          if (v9 < v12) {
            continue;
          }
        }
        return v5;
      }
      return 0;
    }
  }
  return v5;
}

BOOL CA::BoundsImpl::contains(_DWORD *a1, _DWORD *a2)
{
  int v2 = a1[2];
  if (v2 < 1) {
    return 0;
  }
  int v3 = a1[3];
  if (v3 < 1) {
    return 0;
  }
  int v4 = a2[2];
  if (v4 < 0) {
    return 0;
  }
  int v5 = a2[3];
  if (v5 < 0) {
    return 0;
  }
  if (*a1 > *a2) {
    return 0;
  }
  int v6 = a1[1];
  int v7 = a2[1];
  if (v6 > v7) {
    return 0;
  }
  BOOL v9 = v6 + v3 >= v7 + v5;
  return *a1 + v2 >= *a2 + v4 && v9;
}

void CA::Render::Update::invalidate_backdrops(uint64_t a1, CA::Shape *this, int32x2_t **a3, int a4)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (this)
  {
    if (this == (CA::Shape *)1) {
      return;
    }
  }
  else if (*((_DWORD *)this + 1) == 6)
  {
    return;
  }
  int v7 = (int32x2_t **)(a1 + 504);
  if (a3) {
    int v7 = a3;
  }
  int32x2_t v8 = *v7;
  if (*v7)
  {
    while (1)
    {
      __int32 v9 = v8[12].i32[0];
      if ((v9 & 0x40000000) != 0) {
        int v10 = a4;
      }
      else {
        int v10 = 1;
      }
      if ((v9 & 0x10000000) != 0 || !v10) {
        goto LABEL_27;
      }
      uint64_t v11 = *(void *)(*(void *)&v8[1] + 256);
      uint64_t v12 = CA::Shape::intersect(this, (const CA::Bounds *)(v11 + 48));
      uint64_t v14 = (CA::Shape *)v12;
      if ((v12 & 1) == 0) {
        break;
      }
      if (v12 != 1) {
        goto LABEL_17;
      }
LABEL_26:
      CA::Shape::unref(v14);
LABEL_27:
      int32x2_t v8 = (int32x2_t *)*v8;
      if (!v8) {
        return;
      }
    }
    if (*(_DWORD *)(v12 + 4) == 6) {
      goto LABEL_26;
    }
LABEL_17:
    if ((v8[12].i8[3] & 0x20) != 0)
    {
      int32x2_t v20 = 0;
      int32x2_t v21 = 0;
      CA::Shape::get_bounds(v12, (int *)&v20);
      CA::BoundsImpl::Union(v8 + 3, v20, v21);
    }
    int32x2_t v15 = v8[2];
    uint64_t v17 = *(void *)(*(void *)&v15 + 16);
    int v16 = (CA::Shape **)(*(void *)&v15 + 16);
    if (v17)
    {
      CA::shape_union(v16, (CA::Shape **)v14, v13);
      unsigned int v18 = *v16;
      if ((*v16 & 1) != 0 || *((int *)v18 + 1) < 65) {
        goto LABEL_25;
      }
      int32x2_t v20 = 0;
      int32x2_t v21 = 0;
      CA::Shape::get_bounds((uint64_t)v18, (int *)&v20);
      CA::Shape::unref(*v16);
      unint64_t v19 = CA::Shape::new_shape((unsigned int *)&v20);
    }
    else
    {
      unint64_t v19 = CA::Shape::ref((unint64_t)v14);
    }
    *int v16 = (CA::Shape *)v19;
LABEL_25:
    goto LABEL_26;
  }
}

void CA::shape_intersect(CA::Shape **this, CA::Shape **a2, const CA::Bounds *a3)
{
  int v4 = *this;
  if (*this)
  {
    if (v4 == (CA::Shape *)1) {
      return;
    }
    goto LABEL_5;
  }
  if (*((_DWORD *)v4 + 1) != 6)
  {
LABEL_5:
    uint64_t v5 = CA::Shape::intersect(*this, (const CA::Bounds *)a2);
    CA::Shape::unref(v4);
    *this = (CA::Shape *)v5;
  }
}

uint64_t CA::Shape::intersect(CA::Shape *this, const CA::Bounds *a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  if (this) {
    BOOL v3 = this == (CA::Shape *)1;
  }
  else {
    BOOL v3 = *((_DWORD *)this + 1) == 6;
  }
  char v4 = v3;
  uint64_t result = 1;
  if ((v4 & 1) == 0 && *((_DWORD *)a2 + 2))
  {
    if (*((_DWORD *)a2 + 3))
    {
      memset(v6, 0, sizeof(v6));
      CA::Shape::operator=((uint64_t)v6, a2);
      return CA::Shape::intersect((uint64_t)this, (uint64_t)v6);
    }
  }
  return result;
}

void std::__introsort<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *,false>(unint64_t a1, long long *a2, uint64_t a3, char a4)
{
  while (2)
  {
    int v177 = (long long *)((char *)a2 - 168);
    unint64_t v9 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v9;
          uint64_t v10 = (uint64_t)a2 - v9;
          unint64_t v11 = 0xCF3CF3CF3CF3CF3DLL * ((uint64_t)((uint64_t)a2 - v9) >> 3);
          if (v5 || !v4)
          {
            switch(v11)
            {
              case 0uLL:
              case 1uLL:
                return;
              case 2uLL:
                if (*(_DWORD *)(*((void *)a2 - 20) + 112) < *(_DWORD *)(*(void *)(v9 + 8) + 112))
                {
                  std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<CA::Render::BackdropGroup::Item *&,CA::Render::BackdropGroup::Item *&>((long long *)v9, v177);
                }
                break;
              case 3uLL:
                std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *>(v9, v9 + 168, (uint64_t)v177);
                break;
              case 4uLL:
                std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *>(v9, v9 + 168, v9 + 336, (uint64_t)v177);
                break;
              case 5uLL:
                std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *,0>(v9, v9 + 168, v9 + 336, v9 + 504, (uint64_t)v177);
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v10 <= 4031)
          {
            char v63 = (long long *)(v9 + 168);
            BOOL v65 = (long long *)v9 == a2 || v63 == a2;
            if (a4)
            {
              if (!v65)
              {
                uint64_t v66 = 0;
                long long v67 = (void *)v9;
                do
                {
                  uint64_t v68 = v63;
                  uint64_t v69 = v67[22];
                  if (*(_DWORD *)(v69 + 112) < *(_DWORD *)(v67[1] + 112))
                  {
                    uint64_t v70 = *(void *)v68;
                    long long v71 = *(_OWORD *)(v67 + 23);
                    long long v72 = *(_OWORD *)(v67 + 25);
                    long long v73 = *(_OWORD *)(v67 + 27);
                    long long v74 = *(_OWORD *)(v67 + 29);
                    long long v75 = *(_OWORD *)(v67 + 33);
                    long long v200 = *(_OWORD *)(v67 + 35);
                    long long v207 = *(_OWORD *)(v67 + 37);
                    long long v76 = *(_OWORD *)(v67 + 31);
                    uint64_t v221 = v67[41];
                    uint64_t v77 = v66;
                    long long v214 = *(_OWORD *)(v67 + 39);
                    while (1)
                    {
                      uint64_t v78 = v77;
                      uint64_t v79 = v9 + v77;
                      long long v80 = *(_OWORD *)(v79 + 16);
                      *(_OWORD *)(v79 + 168) = *(_OWORD *)v79;
                      *(_OWORD *)(v79 + 184) = v80;
                      long long v81 = *(_OWORD *)(v79 + 48);
                      *(_OWORD *)(v79 + 200) = *(_OWORD *)(v79 + 32);
                      *(_OWORD *)(v79 + 216) = v81;
                      long long v82 = *(_OWORD *)(v79 + 80);
                      *(_OWORD *)(v79 + 232) = *(_OWORD *)(v79 + 64);
                      *(_OWORD *)(v79 + 248) = v82;
                      long long v83 = *(_OWORD *)(v79 + 112);
                      *(_OWORD *)(v79 + 264) = *(_OWORD *)(v79 + 96);
                      long long v84 = *(_OWORD *)(v79 + 128);
                      long long v85 = *(_OWORD *)(v79 + 144);
                      *(void *)(v79 + 328) = *(void *)(v79 + 160);
                      *(_OWORD *)(v79 + 296) = v84;
                      *(_OWORD *)(v79 + 312) = v85;
                      *(_OWORD *)(v79 + 280) = v83;
                      if (!v78) {
                        break;
                      }
                      unsigned int v86 = *(_DWORD *)(*(void *)(v79 - 160) + 112);
                      uint64_t v77 = v78 - 168;
                      if (*(_DWORD *)(v69 + 112) >= v86)
                      {
                        uint64_t v87 = v9 + v78 + 112;
                        uint64_t v88 = v9 + v77 + 168;
                        goto LABEL_83;
                      }
                    }
                    uint64_t v87 = v79 + 112;
                    uint64_t v88 = v9;
LABEL_83:
                    *(void *)uint64_t v88 = v70;
                    *(void *)(v88 + 8) = v69;
                    *(_OWORD *)(v88 + 16) = v71;
                    *(_OWORD *)(v88 + 32) = v72;
                    *(_OWORD *)(v88 + 48) = v73;
                    *(_OWORD *)(v88 + 64) = v74;
                    *(_OWORD *)(v88 + 80) = v76;
                    *(_OWORD *)(v88 + 96) = v75;
                    *(void *)(v87 + 48) = v221;
                    *(_OWORD *)(v87 + 16) = v207;
                    *(_OWORD *)(v87 + 32) = v214;
                    *(_OWORD *)uint64_t v87 = v200;
                  }
                  char v63 = (long long *)((char *)v68 + 168);
                  v66 += 168;
                  long long v67 = v68;
                }
                while ((long long *)((char *)v68 + 168) != a2);
              }
            }
            else if (!v65)
            {
              unint64_t v157 = v9 + 64;
              do
              {
                int32x2_t v158 = v63;
                uint64_t v159 = *(void *)(a1 + 176);
                if (*(_DWORD *)(v159 + 112) < *(_DWORD *)(*(void *)(a1 + 8) + 112))
                {
                  uint64_t v160 = *(void *)v158;
                  long long v161 = *(_OWORD *)(a1 + 184);
                  long long v162 = *(_OWORD *)(a1 + 200);
                  long long v163 = *(_OWORD *)(a1 + 216);
                  long long v164 = *(_OWORD *)(a1 + 232);
                  long long v165 = *(_OWORD *)(a1 + 264);
                  long long v203 = *(_OWORD *)(a1 + 280);
                  long long v210 = *(_OWORD *)(a1 + 296);
                  long long v166 = *(_OWORD *)(a1 + 248);
                  uint64_t v224 = *(void *)(a1 + 328);
                  unint64_t v167 = v157;
                  long long v217 = *(_OWORD *)(a1 + 312);
                  do
                  {
                    unint64_t v168 = v167;
                    long long v169 = *(_OWORD *)(v167 - 48);
                    *(_OWORD *)(v167 + 104) = *(_OWORD *)(v167 - 64);
                    *(_OWORD *)(v167 + 120) = v169;
                    long long v170 = *(_OWORD *)(v167 - 16);
                    *(_OWORD *)(v167 + 136) = *(_OWORD *)(v167 - 32);
                    *(_OWORD *)(v167 + 152) = v170;
                    long long v171 = *(_OWORD *)(v167 + 16);
                    *(_OWORD *)(v167 + 168) = *(_OWORD *)v167;
                    *(_OWORD *)(v167 + 184) = v171;
                    long long v172 = *(_OWORD *)(v167 + 48);
                    *(_OWORD *)(v167 + 200) = *(_OWORD *)(v167 + 32);
                    long long v173 = *(_OWORD *)(v167 + 64);
                    long long v174 = *(_OWORD *)(v167 + 80);
                    *(void *)(v167 + 264) = *(void *)(v167 + 96);
                    *(_OWORD *)(v167 + 248) = v174;
                    *(_OWORD *)(v167 + 232) = v173;
                    *(_OWORD *)(v167 + 216) = v172;
                    uint64_t v175 = *(void *)(v167 - 224);
                    v167 -= 168;
                  }
                  while (*(_DWORD *)(v159 + 112) < *(_DWORD *)(v175 + 112));
                  unint64_t v176 = v168 + 48;
                  *(void *)(v167 + 104) = v160;
                  *(void *)(v167 + 112) = v159;
                  *(_OWORD *)(v167 + 120) = v161;
                  *(_OWORD *)(v167 + 136) = v162;
                  *(_OWORD *)(v167 + 152) = v163;
                  *(_OWORD *)(v167 + 168) = v164;
                  *(_OWORD *)(v167 + 184) = v166;
                  *(_OWORD *)(v167 + 200) = v165;
                  *(void *)(v176 + 48) = v224;
                  *(_OWORD *)(v176 + 16) = v210;
                  *(_OWORD *)(v176 + 32) = v217;
                  *(_OWORD *)unint64_t v176 = v203;
                }
                char v63 = (long long *)((char *)v158 + 168);
                v157 += 168;
                a1 = (unint64_t)v158;
              }
              while ((long long *)((char *)v158 + 168) != a2);
            }
            return;
          }
          if (!a3)
          {
            if ((long long *)v9 != a2)
            {
              int64_t v89 = (v11 - 2) >> 1;
              int64_t v90 = v89;
              do
              {
                int64_t v91 = v90;
                if (v89 >= v90)
                {
                  uint64_t v92 = (2 * v90) | 1;
                  unint64_t v93 = v9 + 168 * v92;
                  if (2 * v90 + 2 < (uint64_t)v11)
                  {
                    unsigned int v94 = *(_DWORD *)(*(void *)(v9 + 168 * v92 + 8) + 112);
                    unsigned int v95 = *(_DWORD *)(*(void *)(v93 + 176) + 112);
                    v93 += 168 * (v94 < v95);
                    if (v94 < v95) {
                      uint64_t v92 = 2 * v90 + 2;
                    }
                  }
                  uint64_t v96 = *(void *)(v9 + 168 * v90 + 8);
                  if (*(_DWORD *)(*(void *)(v93 + 8) + 112) >= *(_DWORD *)(v96 + 112))
                  {
                    unint64_t v97 = v9 + 168 * v91;
                    uint64_t v98 = *(void *)v97;
                    long long v99 = *(_OWORD *)(v97 + 16);
                    long long v100 = *(_OWORD *)(v97 + 32);
                    long long v101 = *(_OWORD *)(v97 + 48);
                    long long v102 = *(_OWORD *)(v97 + 64);
                    long long v103 = *(_OWORD *)(v97 + 80);
                    long long v104 = *(_OWORD *)(v97 + 96);
                    uint64_t v222 = *(void *)(v97 + 160);
                    long long v208 = *(_OWORD *)(v97 + 128);
                    long long v215 = *(_OWORD *)(v97 + 144);
                    long long v201 = *(_OWORD *)(v97 + 112);
                    do
                    {
                      unint64_t v105 = v93;
                      *(_OWORD *)unint64_t v97 = *(_OWORD *)v93;
                      *(_OWORD *)(v97 + 16) = *(_OWORD *)(v93 + 16);
                      *(_OWORD *)(v97 + 32) = *(_OWORD *)(v93 + 32);
                      *(_OWORD *)(v97 + 48) = *(_OWORD *)(v93 + 48);
                      *(_OWORD *)(v97 + 64) = *(_OWORD *)(v93 + 64);
                      *(_OWORD *)(v97 + 80) = *(_OWORD *)(v93 + 80);
                      *(_OWORD *)(v97 + 96) = *(_OWORD *)(v93 + 96);
                      long long v106 = *(_OWORD *)(v93 + 112);
                      long long v107 = *(_OWORD *)(v93 + 128);
                      long long v108 = *(_OWORD *)(v93 + 144);
                      *(void *)(v97 + 160) = *(void *)(v93 + 160);
                      *(_OWORD *)(v97 + 128) = v107;
                      *(_OWORD *)(v97 + 144) = v108;
                      *(_OWORD *)(v97 + 112) = v106;
                      if (v89 < v92) {
                        break;
                      }
                      uint64_t v109 = (2 * v92) | 1;
                      unint64_t v93 = v9 + 168 * v109;
                      uint64_t v110 = 2 * v92 + 2;
                      if (v110 < (uint64_t)v11)
                      {
                        unsigned int v111 = *(_DWORD *)(*(void *)(v9 + 168 * v109 + 8) + 112);
                        unsigned int v112 = *(_DWORD *)(*(void *)(v93 + 176) + 112);
                        v93 += 168 * (v111 < v112);
                        if (v111 < v112) {
                          uint64_t v109 = v110;
                        }
                      }
                      unint64_t v97 = v105;
                      uint64_t v92 = v109;
                    }
                    while (*(_DWORD *)(*(void *)(v93 + 8) + 112) >= *(_DWORD *)(v96 + 112));
                    *(void *)unint64_t v105 = v98;
                    *(void *)(v105 + 8) = v96;
                    *(_OWORD *)(v105 + 16) = v99;
                    *(_OWORD *)(v105 + 32) = v100;
                    *(_OWORD *)(v105 + 48) = v101;
                    *(_OWORD *)(v105 + 64) = v102;
                    *(_OWORD *)(v105 + 80) = v103;
                    *(_OWORD *)(v105 + 96) = v104;
                    *(_OWORD *)(v105 + 112) = v201;
                    *(_OWORD *)(v105 + 128) = v208;
                    *(_OWORD *)(v105 + 144) = v215;
                    *(void *)(v105 + 160) = v222;
                  }
                }
                int64_t v90 = v91 - 1;
              }
              while (v91);
              int64_t v113 = ((unint64_t)a2 - v9) / 0xA8;
              do
              {
                uint64_t v114 = 0;
                uint32x2_t v115 = a2;
                long long v191 = *(_OWORD *)v9;
                uint64_t v117 = *(void *)(v9 + 16);
                uint64_t v116 = *(void *)(v9 + 24);
                uint64_t v119 = *(void *)(v9 + 32);
                uint64_t v118 = *(void *)(v9 + 40);
                uint64_t v121 = *(void *)(v9 + 48);
                uint64_t v120 = *(void *)(v9 + 56);
                uint64_t v123 = *(void *)(v9 + 64);
                uint64_t v122 = *(void *)(v9 + 72);
                uint64_t v125 = *(void *)(v9 + 80);
                uint64_t v124 = *(void *)(v9 + 88);
                uint64_t v127 = *(void *)(v9 + 96);
                uint64_t v126 = *(void *)(v9 + 104);
                uint64_t v196 = *(void *)(v9 + 160);
                unint64_t v128 = v9;
                long long v194 = *(_OWORD *)(v9 + 128);
                long long v195 = *(_OWORD *)(v9 + 144);
                long long v193 = *(_OWORD *)(v9 + 112);
                do
                {
                  uint64_t v129 = v114 + 1;
                  unint64_t v130 = v128 + 168 * (v114 + 1);
                  uint64_t v131 = (2 * v114) | 1;
                  uint64_t v132 = 2 * v114 + 2;
                  if (v132 < v113)
                  {
                    unsigned int v133 = *(_DWORD *)(*(void *)(v128 + 168 * v129 + 8) + 112);
                    unsigned int v134 = *(_DWORD *)(*(void *)(v130 + 176) + 112);
                    v130 += 168 * (v133 < v134);
                    if (v133 < v134) {
                      uint64_t v131 = v132;
                    }
                  }
                  *(_OWORD *)unint64_t v128 = *(_OWORD *)v130;
                  *(_OWORD *)(v128 + 16) = *(_OWORD *)(v130 + 16);
                  *(_OWORD *)(v128 + 32) = *(_OWORD *)(v130 + 32);
                  *(_OWORD *)(v128 + 48) = *(_OWORD *)(v130 + 48);
                  *(_OWORD *)(v128 + 64) = *(_OWORD *)(v130 + 64);
                  *(_OWORD *)(v128 + 80) = *(_OWORD *)(v130 + 80);
                  *(_OWORD *)(v128 + 96) = *(_OWORD *)(v130 + 96);
                  long long v135 = *(_OWORD *)(v130 + 112);
                  long long v136 = *(_OWORD *)(v130 + 128);
                  long long v137 = *(_OWORD *)(v130 + 144);
                  *(void *)(v128 + 160) = *(void *)(v130 + 160);
                  *(_OWORD *)(v128 + 128) = v136;
                  *(_OWORD *)(v128 + 144) = v137;
                  *(_OWORD *)(v128 + 112) = v135;
                  unint64_t v128 = v130;
                  uint64_t v114 = v131;
                }
                while (v131 <= (uint64_t)((unint64_t)(v113 - 2) >> 1));
                float64x2_t v138 = (long long *)(v130 + 112);
                a2 = (long long *)((char *)a2 - 168);
                if ((long long *)v130 == (long long *)((char *)v115 - 168))
                {
                  *(_OWORD *)unint64_t v130 = v191;
                  *(void *)(v130 + 16) = v117;
                  *(void *)(v130 + 24) = v116;
                  *(void *)(v130 + 32) = v119;
                  *(void *)(v130 + 40) = v118;
                  *(void *)(v130 + 48) = v121;
                  *(void *)(v130 + 56) = v120;
                  *(void *)(v130 + 64) = v123;
                  *(void *)(v130 + 72) = v122;
                  *(void *)(v130 + 80) = v125;
                  *(void *)(v130 + 88) = v124;
                  *(void *)(v130 + 96) = v127;
                  *(void *)(v130 + 104) = v126;
                  *(void *)(v130 + 160) = v196;
                  *(_OWORD *)(v130 + 128) = v194;
                  *(_OWORD *)(v130 + 144) = v195;
                  *float64x2_t v138 = v193;
                }
                else
                {
                  *(_OWORD *)unint64_t v130 = *a2;
                  *(_OWORD *)(v130 + 16) = *(long long *)((char *)v115 - 152);
                  *(_OWORD *)(v130 + 32) = *(long long *)((char *)v115 - 136);
                  *(_OWORD *)(v130 + 48) = *(long long *)((char *)v115 - 120);
                  *(_OWORD *)(v130 + 64) = *(long long *)((char *)v115 - 104);
                  *(_OWORD *)(v130 + 80) = *(long long *)((char *)v115 - 88);
                  *(_OWORD *)(v130 + 96) = *(long long *)((char *)v115 - 72);
                  long long v139 = *(long long *)((char *)v115 - 40);
                  long long v140 = *(long long *)((char *)v115 - 24);
                  long long v141 = *(long long *)((char *)v115 - 56);
                  *(void *)(v130 + 160) = *((void *)v115 - 1);
                  *(_OWORD *)(v130 + 128) = v139;
                  *(_OWORD *)(v130 + 144) = v140;
                  *float64x2_t v138 = v141;
                  *a2 = v191;
                  *((void *)v115 - 19) = v117;
                  *((void *)v115 - 18) = v116;
                  *((void *)v115 - 17) = v119;
                  *((void *)v115 - 16) = v118;
                  *((void *)v115 - 15) = v121;
                  *((void *)v115 - 14) = v120;
                  *((void *)v115 - 13) = v123;
                  *((void *)v115 - 12) = v122;
                  *((void *)v115 - 11) = v125;
                  *((void *)v115 - 10) = v124;
                  *((void *)v115 - 9) = v127;
                  *((void *)v115 - 8) = v126;
                  *((void *)v115 - 1) = v196;
                  *(long long *)((char *)v115 - 24) = v195;
                  *(long long *)((char *)v115 - 40) = v194;
                  *(long long *)((char *)v115 - 56) = v193;
                  uint64_t v142 = v130 - v9 + 168;
                  if (v142 >= 169)
                  {
                    unint64_t v143 = (v142 / 0xA8uLL - 2) >> 1;
                    uint64_t v144 = *(void *)(v130 + 8);
                    if (*(_DWORD *)(*(void *)(v9 + 168 * v143 + 8) + 112) < *(_DWORD *)(v144 + 112))
                    {
                      uint64_t v145 = *(void *)v130;
                      long long v146 = *(_OWORD *)(v130 + 16);
                      long long v147 = *(_OWORD *)(v130 + 32);
                      long long v148 = *(_OWORD *)(v130 + 48);
                      long long v149 = *(_OWORD *)(v130 + 64);
                      long long v150 = *(_OWORD *)(v130 + 80);
                      long long v151 = *(_OWORD *)(v130 + 96);
                      uint64_t v223 = *(void *)(v130 + 160);
                      long long v209 = *(_OWORD *)(v130 + 128);
                      long long v216 = *(_OWORD *)(v130 + 144);
                      long long v202 = *v138;
                      do
                      {
                        unint64_t v152 = v130;
                        unint64_t v130 = v9 + 168 * v143;
                        *(_OWORD *)unint64_t v152 = *(_OWORD *)v130;
                        *(_OWORD *)(v152 + 16) = *(_OWORD *)(v130 + 16);
                        *(_OWORD *)(v152 + 32) = *(_OWORD *)(v130 + 32);
                        *(_OWORD *)(v152 + 48) = *(_OWORD *)(v130 + 48);
                        *(_OWORD *)(v152 + 64) = *(_OWORD *)(v130 + 64);
                        *(_OWORD *)(v152 + 80) = *(_OWORD *)(v130 + 80);
                        *(_OWORD *)(v152 + 96) = *(_OWORD *)(v130 + 96);
                        long long v153 = *(_OWORD *)(v130 + 112);
                        long long v154 = *(_OWORD *)(v130 + 128);
                        long long v155 = *(_OWORD *)(v130 + 144);
                        *(void *)(v152 + 160) = *(void *)(v130 + 160);
                        *(_OWORD *)(v152 + 128) = v154;
                        *(_OWORD *)(v152 + 144) = v155;
                        *(_OWORD *)(v152 + 112) = v153;
                        if (!v143) {
                          break;
                        }
                        unint64_t v143 = (v143 - 1) >> 1;
                      }
                      while (*(_DWORD *)(*(void *)(v9 + 168 * v143 + 8) + 112) < *(_DWORD *)(v144 + 112));
                      *(void *)unint64_t v130 = v145;
                      *(void *)(v130 + 8) = v144;
                      *(_OWORD *)(v130 + 16) = v146;
                      *(_OWORD *)(v130 + 32) = v147;
                      *(_OWORD *)(v130 + 48) = v148;
                      *(_OWORD *)(v130 + 64) = v149;
                      *(_OWORD *)(v130 + 80) = v150;
                      *(_OWORD *)(v130 + 96) = v151;
                      *(void *)(v130 + 160) = v223;
                      *(_OWORD *)(v130 + 128) = v209;
                      *(_OWORD *)(v130 + 144) = v216;
                      *(_OWORD *)(v130 + 112) = v202;
                    }
                  }
                }
              }
              while (v113-- > 2);
            }
            return;
          }
          unint64_t v12 = v11 >> 1;
          int v13 = (_OWORD *)(v9 + 168 * (v11 >> 1));
          if ((unint64_t)v10 >= 0x5401)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *>(a1, a1 + 168 * (v11 >> 1), (uint64_t)v177);
            uint64_t v14 = 168 * v12;
            unint64_t v15 = a1 + 168 * v12;
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *>(a1 + 168, v15 - 168, (uint64_t)(a2 - 21));
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *>(a1 + 336, a1 + 168 + v14, (uint64_t)a2 - 504);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *>(v15 - 168, (uint64_t)v13, a1 + 168 + v14);
            long long v192 = *(_OWORD *)a1;
            uint64_t v218 = *(void *)(a1 + 160);
            long long v204 = *(_OWORD *)(a1 + 128);
            long long v211 = *(_OWORD *)(a1 + 144);
            long long v197 = *(_OWORD *)(a1 + 112);
            long long v16 = *(_OWORD *)(a1 + 16);
            long long v17 = *(_OWORD *)(a1 + 32);
            long long v18 = *(_OWORD *)(a1 + 48);
            long long v19 = *(_OWORD *)(a1 + 64);
            long long v20 = *(_OWORD *)(a1 + 80);
            long long v21 = *(_OWORD *)(a1 + 96);
            long long v22 = *(_OWORD *)(v15 + 16);
            long long v23 = *(_OWORD *)(v15 + 32);
            *(_OWORD *)a1 = *v13;
            *(_OWORD *)(a1 + 16) = v22;
            long long v24 = *(_OWORD *)(v15 + 48);
            long long v25 = *(_OWORD *)(v15 + 64);
            *(_OWORD *)(a1 + 32) = v23;
            *(_OWORD *)(a1 + 48) = v24;
            long long v26 = *(_OWORD *)(v15 + 80);
            long long v27 = *(_OWORD *)(v15 + 96);
            *(_OWORD *)(a1 + 64) = v25;
            *(_OWORD *)(a1 + 80) = v26;
            long long v28 = *(_OWORD *)(v15 + 112);
            long long v29 = *(_OWORD *)(v15 + 128);
            long long v30 = *(_OWORD *)(v15 + 144);
            *(void *)(a1 + 160) = *(void *)(v15 + 160);
            *(_OWORD *)(a1 + 128) = v29;
            *(_OWORD *)(a1 + 144) = v30;
            *(_OWORD *)(a1 + 96) = v27;
            *(_OWORD *)(a1 + 112) = v28;
            _OWORD *v13 = v192;
            *(_OWORD *)(v15 + 16) = v16;
            *(_OWORD *)(v15 + 32) = v17;
            *(_OWORD *)(v15 + 48) = v18;
            *(_OWORD *)(v15 + 64) = v19;
            *(_OWORD *)(v15 + 80) = v20;
            *(_OWORD *)(v15 + 96) = v21;
            *(void *)(v15 + 160) = v218;
            *(_OWORD *)(v15 + 128) = v204;
            *(_OWORD *)(v15 + 144) = v211;
            *(_OWORD *)(v15 + 112) = v197;
          }
          else
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *>(a1 + 168 * (v11 >> 1), a1, (uint64_t)v177);
          }
          --a3;
          if (a4) {
            break;
          }
          uint64_t v31 = *(void *)(a1 + 8);
          unsigned int v32 = *(_DWORD *)(v31 + 112);
          if (*(_DWORD *)(*(void *)(a1 - 160) + 112) < v32) {
            goto LABEL_12;
          }
          uint64_t v49 = *(void *)a1;
          long long v188 = *(_OWORD *)(a1 + 32);
          long long v190 = *(_OWORD *)(a1 + 16);
          long long v184 = *(_OWORD *)(a1 + 64);
          long long v186 = *(_OWORD *)(a1 + 48);
          long long v180 = *(_OWORD *)(a1 + 96);
          long long v182 = *(_OWORD *)(a1 + 80);
          long long v199 = *(_OWORD *)(a1 + 112);
          long long v206 = *(_OWORD *)(a1 + 128);
          long long v213 = *(_OWORD *)(a1 + 144);
          uint64_t v220 = *(void *)(a1 + 160);
          if (v32 >= *(_DWORD *)(*((void *)a2 - 20) + 112))
          {
            unint64_t v52 = a1 + 168;
            do
            {
              unint64_t v9 = v52;
              if (v52 >= (unint64_t)a2) {
                break;
              }
              unsigned int v53 = *(_DWORD *)(*(void *)(v52 + 8) + 112);
              v52 += 168;
            }
            while (v32 >= v53);
          }
          else
          {
            unint64_t v50 = a1;
            do
            {
              unint64_t v9 = v50 + 168;
              unsigned int v51 = *(_DWORD *)(*(void *)(v50 + 176) + 112);
              v50 += 168;
            }
            while (v32 >= v51);
          }
          int64x2_t v54 = a2;
          if (v9 < (unint64_t)a2)
          {
            int64x2_t v55 = a2;
            do
            {
              int64x2_t v54 = (long long *)((char *)v55 - 168);
              unsigned int v56 = *(_DWORD *)(*((void *)v55 - 20) + 112);
              int64x2_t v55 = (long long *)((char *)v55 - 168);
            }
            while (v32 < v56);
          }
          while (v9 < (unint64_t)v54)
          {
            std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<CA::Render::BackdropGroup::Item *&,CA::Render::BackdropGroup::Item *&>((long long *)v9, v54);
            unsigned int v57 = *(_DWORD *)(v31 + 112);
            do
            {
              uint64_t v58 = *(void *)(v9 + 176);
              v9 += 168;
            }
            while (v57 >= *(_DWORD *)(v58 + 112));
            do
            {
              uint64_t v59 = *((void *)v54 - 20);
              int64x2_t v54 = (long long *)((char *)v54 - 168);
            }
            while (v57 < *(_DWORD *)(v59 + 112));
          }
          BOOL v4 = v9 - 168 >= a1;
          BOOL v5 = v9 - 168 == a1;
          if (v9 - 168 != a1)
          {
            *(_OWORD *)a1 = *(_OWORD *)(v9 - 168);
            *(_OWORD *)(a1 + 16) = *(_OWORD *)(v9 - 152);
            *(_OWORD *)(a1 + 32) = *(_OWORD *)(v9 - 136);
            *(_OWORD *)(a1 + 48) = *(_OWORD *)(v9 - 120);
            *(_OWORD *)(a1 + 64) = *(_OWORD *)(v9 - 104);
            *(_OWORD *)(a1 + 80) = *(_OWORD *)(v9 - 88);
            *(_OWORD *)(a1 + 96) = *(_OWORD *)(v9 - 72);
            long long v60 = *(_OWORD *)(v9 - 56);
            long long v61 = *(_OWORD *)(v9 - 40);
            long long v62 = *(_OWORD *)(v9 - 24);
            *(void *)(a1 + 160) = *(void *)(v9 - 8);
            *(_OWORD *)(a1 + 128) = v61;
            *(_OWORD *)(a1 + 144) = v62;
            *(_OWORD *)(a1 + 112) = v60;
          }
          a4 = 0;
          *(void *)(v9 - 168) = v49;
          *(void *)(v9 - 160) = v31;
          *(_OWORD *)(v9 - 152) = v190;
          *(_OWORD *)(v9 - 136) = v188;
          *(_OWORD *)(v9 - 120) = v186;
          *(_OWORD *)(v9 - 104) = v184;
          *(_OWORD *)(v9 - 88) = v182;
          *(_OWORD *)(v9 - 72) = v180;
          *(void *)(v9 - 8) = v220;
          *(_OWORD *)(v9 - 24) = v213;
          *(_OWORD *)(v9 - 40) = v206;
          *(_OWORD *)(v9 - 56) = v199;
        }
        uint64_t v31 = *(void *)(a1 + 8);
        unsigned int v32 = *(_DWORD *)(v31 + 112);
LABEL_12:
        uint64_t v33 = *(void *)a1;
        long long v187 = *(_OWORD *)(a1 + 32);
        long long v189 = *(_OWORD *)(a1 + 16);
        long long v183 = *(_OWORD *)(a1 + 64);
        long long v185 = *(_OWORD *)(a1 + 48);
        long long v179 = *(_OWORD *)(a1 + 96);
        long long v181 = *(_OWORD *)(a1 + 80);
        long long v198 = *(_OWORD *)(a1 + 112);
        long long v205 = *(_OWORD *)(a1 + 128);
        uint64_t v219 = *(void *)(a1 + 160);
        unint64_t v34 = a1;
        long long v212 = *(_OWORD *)(a1 + 144);
        do
        {
          unint64_t v35 = v34;
          v34 += 168;
        }
        while (*(_DWORD *)(*(void *)(v35 + 176) + 112) < v32);
        int32x4_t v36 = a2;
        if (v35 == a1)
        {
          float v39 = a2;
          while (v34 < (unint64_t)v39)
          {
            double v37 = (long long *)((char *)v39 - 168);
            unsigned int v40 = *(_DWORD *)(*((void *)v39 - 20) + 112);
            float v39 = (long long *)((char *)v39 - 168);
            if (v40 < v32) {
              goto LABEL_22;
            }
          }
          double v37 = v39;
        }
        else
        {
          do
          {
            double v37 = (long long *)((char *)v36 - 168);
            unsigned int v38 = *(_DWORD *)(*((void *)v36 - 20) + 112);
            int32x4_t v36 = (long long *)((char *)v36 - 168);
          }
          while (v38 >= v32);
        }
LABEL_22:
        unint64_t v9 = v34;
        if (v34 < (unint64_t)v37)
        {
          double v41 = v37;
          do
          {
            std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<CA::Render::BackdropGroup::Item *&,CA::Render::BackdropGroup::Item *&>((long long *)v9, v41);
            unsigned int v42 = *(_DWORD *)(v31 + 112);
            do
            {
              uint64_t v43 = *(void *)(v9 + 176);
              v9 += 168;
            }
            while (*(_DWORD *)(v43 + 112) < v42);
            do
            {
              uint64_t v44 = *((void *)v41 - 20);
              double v41 = (long long *)((char *)v41 - 168);
            }
            while (*(_DWORD *)(v44 + 112) >= v42);
          }
          while (v9 < (unint64_t)v41);
        }
        if (v9 - 168 != a1)
        {
          *(_OWORD *)a1 = *(_OWORD *)(v9 - 168);
          *(_OWORD *)(a1 + 16) = *(_OWORD *)(v9 - 152);
          *(_OWORD *)(a1 + 32) = *(_OWORD *)(v9 - 136);
          *(_OWORD *)(a1 + 48) = *(_OWORD *)(v9 - 120);
          *(_OWORD *)(a1 + 64) = *(_OWORD *)(v9 - 104);
          *(_OWORD *)(a1 + 80) = *(_OWORD *)(v9 - 88);
          *(_OWORD *)(a1 + 96) = *(_OWORD *)(v9 - 72);
          long long v45 = *(_OWORD *)(v9 - 56);
          long long v46 = *(_OWORD *)(v9 - 40);
          long long v47 = *(_OWORD *)(v9 - 24);
          *(void *)(a1 + 160) = *(void *)(v9 - 8);
          *(_OWORD *)(a1 + 128) = v46;
          *(_OWORD *)(a1 + 144) = v47;
          *(_OWORD *)(a1 + 112) = v45;
        }
        *(void *)(v9 - 168) = v33;
        *(void *)(v9 - 160) = v31;
        *(_OWORD *)(v9 - 152) = v189;
        *(_OWORD *)(v9 - 136) = v187;
        *(_OWORD *)(v9 - 120) = v185;
        *(_OWORD *)(v9 - 104) = v183;
        *(_OWORD *)(v9 - 88) = v181;
        *(_OWORD *)(v9 - 72) = v179;
        *(void *)(v9 - 8) = v219;
        *(_OWORD *)(v9 - 24) = v212;
        *(_OWORD *)(v9 - 40) = v205;
        *(_OWORD *)(v9 - 56) = v198;
        if (v34 >= (unint64_t)v37) {
          break;
        }
LABEL_33:
        std::__introsort<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *,false>(a1, v9 - 168, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v48 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *>(a1, v9 - 168);
      if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,CA::Render::BackdropGroup::finalize_update(unsigned int,BOOL,void *)::$_0 &,CA::Render::BackdropGroup::Item *>(v9, (uint64_t)a2))
      {
        break;
      }
      if (!v48) {
        goto LABEL_33;
      }
    }
    a2 = (long long *)(v9 - 168);
    if (!v48) {
      continue;
    }
    break;
  }
}

_DWORD *CA::OGL::ImagingNode::retain_surface(CA::OGL::ImagingNode *this, float *a2, unsigned int a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = **((void **)this + 1);
  float v9 = 0.0;
  ++*(_DWORD *)(v4 + 740);
  if (*((unsigned char *)this + 213))
  {
    int v6 = (_DWORD *)(*(uint64_t (**)(void, float *))(**((void **)this + 3) + 80))(*((void *)this + 3), &v9);
    float v7 = v9;
  }
  else
  {
    int v5 = *((_DWORD *)this + 54) & 0x3FFFFF;
    v10[0] = &unk_1ED02B600;
    v10[1] = this;
    int v11 = 1;
    int v12 = v5;
    int v13 = 0;
    uint64_t v14 = 0;
    CA::OGL::ImagingNode::render((uint64_t)this, (uint64_t)v10, a3);
    int v6 = v13;
    if (v13)
    {
      float v7 = *(float *)&v14;
    }
    else
    {
      int v6 = *(_DWORD **)(v4 + 280);
      if (v6
        || (int v6 = (_DWORD *)(*(uint64_t (**)(uint64_t))(*(void *)v4 + 728))(v4),
            (*(void *)(v4 + 280) = v6) != 0))
      {
        ++*v6;
      }
      float v7 = 1.0;
    }
    CA::OGL::RenderSurface::~RenderSurface((CA::OGL::RenderSurface *)v10);
  }
  --*(_DWORD *)(v4 + 740);
  *a2 = v7;
  return v6;
}

void CA::OGL::RenderSurface::~RenderSurface(CA::OGL::RenderSurface *this)
{
  *(void *)this = &unk_1ED02B600;
  uint64_t v1 = *((void *)this + 3);
  if (v1)
  {
    *(_WORD *)(v1 + 75) &= ~0x400u;
    CA::OGL::Context::pop_surface(**(CA::OGL::Context ***)(*((void *)this + 1) + 8));
  }
}

{
  uint64_t vars8;

  CA::OGL::RenderSurface::~RenderSurface(this);

  JUMPOUT(0x185323DC0);
}

void CA::OGL::Context::collect(CA::OGL::Context *this, char a2)
{
  uint64_t v99 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *((void *)this + 50);
  if (v4)
  {
    double v5 = *((double *)this + 30);
    uint64_t v97 = 0;
    double v98 = 0.0;
    if (v5 != 0.0)
    {
      double v98 = v5 + -5.0;
      if (v5 + -5.0 > *(double *)(v4 + 32))
      {
        uint64_t v97 = v4;
        *(void *)(v4 + 32) = 0x7FF0000000000000;
        os_unfair_lock_lock((os_unfair_lock_t)(v4 + 40));
        x_hash_table_remove_if (*(void *)(v4 + 16), (unsigned int (*)(void, void, uint64_t))CA::Render::TileCache::collect_entry, (uint64_t)&v97);
        os_unfair_lock_unlock((os_unfair_lock_t)(v4 + 40));
      }
    }
    if (*(void *)(v4 + 24))
    {
      os_unfair_lock_lock((os_unfair_lock_t)(v4 + 40));
      int v6 = *(uint64_t **)(v4 + 24);
      *(void *)(v4 + 24) = 0;
      os_unfair_lock_unlock((os_unfair_lock_t)(v4 + 40));
      if (v6)
      {
        float v7 = v6;
        do
        {
          int32x2_t v8 = (void *)*v7;
          CA::Render::tile_cache_entry_release_images((void *)v4, *v7);
          malloc_zone = (malloc_zone_t *)get_malloc_zone();
          malloc_zone_free(malloc_zone, v8);
          float v7 = (uint64_t *)v7[1];
        }
        while (v7);
        do
        {
          uint64_t v10 = (uint64_t *)v6[1];
          free(v6);
          int v6 = v10;
        }
        while (v10);
      }
    }
  }
  uint64_t v11 = *((void *)this + 51);
  if (v11)
  {
    if (*(void *)(v11 + 8))
    {
      double v12 = *((double *)this + 30);
      os_unfair_lock_lock((os_unfair_lock_t)(v11 + 24));
      int v13 = *(uint64_t **)(v11 + 8);
      *(void *)(v11 + 8) = 0;
      os_unfair_lock_unlock((os_unfair_lock_t)(v11 + 24));
      if (v13)
      {
        unint64_t v16 = 15;
        long long v17 = v13;
        do
        {
          long long v17 = (uint64_t *)v17[1];
          if (v16 < 2) {
            break;
          }
          --v16;
        }
        while (v17);
        if (v17)
        {
          uint64_t v18 = v17[1];
          if (v18)
          {
            do
            {
              CA::Render::ShadowCache::free_bounds_entry(*(CA::Render::ShadowCache **)v18, v14, v15);
              uint64_t v18 = *(void *)(v18 + 8);
            }
            while (v18);
            long long v19 = (void *)v17[1];
            if (v19)
            {
              do
              {
                long long v20 = (void *)v19[1];
                free(v19);
                long long v19 = v20;
              }
              while (v20);
            }
            v17[1] = 0;
          }
        }
        long long v21 = v13;
        do
        {
          uint64_t v22 = *v21;
          long long v21 = (uint64_t *)v21[1];
          if (*(double *)(v22 + 96) + 60.0 < v12)
          {
            int v13 = x_list_remove(v13, v22);
            long long v23 = *(atomic_uint **)(v22 + 104);
            if (v23)
            {
              if (atomic_fetch_add(v23 + 2, 0xFFFFFFFF) == 1) {
                (*(void (**)(atomic_uint *))(*(void *)v23 + 16))(v23);
              }
              *(void *)(v22 + 104) = 0;
            }
            long long v24 = (malloc_zone_t *)get_malloc_zone();
            malloc_zone_free(v24, (void *)v22);
          }
        }
        while (v21);
        os_unfair_lock_lock((os_unfair_lock_t)(v11 + 24));
        if (v13)
        {
          uint64_t v25 = *(void *)(v11 + 8);
          uint64_t v97 = v25;
          if (v25)
          {
            do
            {
              uint64_t v26 = v25;
              uint64_t v25 = *(void *)(v25 + 8);
            }
            while (v25);
            long long v27 = (uint64_t **)(v26 + 8);
          }
          else
          {
            long long v27 = (uint64_t **)&v97;
          }
          int32x2_t *v27 = v13;
          *(void *)(v11 + 8) = v97;
        }
      }
      else
      {
        os_unfair_lock_lock((os_unfair_lock_t)(v11 + 24));
      }
      os_unfair_lock_unlock((os_unfair_lock_t)(v11 + 24));
    }
    if (*(void *)(v11 + 16))
    {
      os_unfair_lock_lock((os_unfair_lock_t)(v11 + 24));
      long long v28 = *(void **)(v11 + 16);
      *(void *)(v11 + 16) = 0;
      os_unfair_lock_unlock((os_unfair_lock_t)(v11 + 24));
      while (v28)
      {
        long long v29 = v28;
        long long v28 = (void *)*v28;
        long long v30 = (void *)v29[14];
        if (v30)
        {
          v29[15] = v30;
          operator delete(v30);
        }
        uint64_t v31 = (void *)v29[11];
        if (v31)
        {
          v29[12] = v31;
          operator delete(v31);
        }
        unsigned int v32 = (atomic_uint *)v29[4];
        if (v32 && atomic_fetch_add(v32 + 2, 0xFFFFFFFF) == 1) {
          (*(void (**)(atomic_uint *))(*(void *)v32 + 16))(v32);
        }
        uint64_t v33 = (atomic_uint *)v29[3];
        if (v33 && atomic_fetch_add(v33 + 2, 0xFFFFFFFF) == 1) {
          (*(void (**)(atomic_uint *))(*(void *)v33 + 16))(v33);
        }
        unint64_t v34 = (malloc_zone_t *)get_malloc_zone();
        malloc_zone_free(v34, v29);
      }
    }
  }
  os_unfair_lock_lock((os_unfair_lock_t)this + 76);
  unint64_t v35 = (void *)*((void *)this + 41);
  unsigned int v95 = (uint64_t *)*((void *)this + 40);
  uint64_t v96 = v35;
  *((void *)this + 40) = 0;
  *((void *)this + 41) = 0;
  int32x4_t v36 = (uint64_t *)*((void *)this + 43);
  unsigned int v94 = v36;
  *((void *)this + 43) = 0;
  if (v35)
  {
    double v37 = v35;
    do
    {
      *(unsigned char *)(*v37 + 60) = 0;
      double v37 = (void *)v37[1];
    }
    while (v37);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)this + 76);
  if (a2)
  {
    unsigned int v38 = -1;
    if (!v36) {
      goto LABEL_65;
    }
  }
  else
  {
    unsigned int v38 = *((_DWORD *)this + 58);
    if (!v36) {
      goto LABEL_65;
    }
  }
  float v39 = &v94;
  do
  {
    uint64_t v40 = *v36;
    if ((*(_WORD *)(*v36 + 75) & 0x100) != 0 && *(_DWORD *)(v40 + 4) > v38)
    {
      float v39 = (uint64_t **)(v36 + 1);
    }
    else
    {
      double v41 = (uint64_t *)v36[1];
      unsigned int v42 = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(v42, v36);
      long long *v39 = v41;
      CA::OGL::Context::release_surface((uint64_t)this, v40);
    }
    int32x4_t v36 = *v39;
  }
  while (*v39);
  unint64_t v35 = v96;
LABEL_65:
  if (v35)
  {
    uint64_t v43 = &v96;
    do
    {
      uint64_t v44 = *v35;
      unsigned int v45 = *(_DWORD *)(*v35 + 20);
      if (v45 > v38)
      {
        if (v45 == *((_DWORD *)this + 57)) {
          goto LABEL_74;
        }
      }
      else if (v38 != -1)
      {
        goto LABEL_72;
      }
      if (!(*(unsigned int (**)(CA::OGL::Context *, void, BOOL))(*(void *)this + 640))(this, *v35, v45 <= v38))
      {
LABEL_74:
        uint64_t v43 = v35 + 1;
        goto LABEL_75;
      }
LABEL_72:
      long long v46 = (void *)v35[1];
      long long v47 = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(v47, v35);
      *uint64_t v43 = v46;
      *(_DWORD *)(v44 + 20) = 0;
      uint64_t v48 = *(void *)(v44 + 8);
      if (!v48)
      {
        unint64_t v35 = v46;
        continue;
      }
      (*(void (**)(uint64_t))(*(void *)v48 + 184))(v48);
      *(void *)(v44 + 8) = 0;
LABEL_75:
      unint64_t v35 = (void *)*v43;
    }
    while (v35);
  }
  uint64_t v49 = v95;
  if (v95)
  {
    unint64_t v50 = &v95;
    do
    {
      uint64_t v51 = *v49;
      if ((v38 == -1 || *(_DWORD *)(v51 + 20) > v38)
        && !(*(unsigned int (**)(CA::OGL::Context *, uint64_t, BOOL))(*(void *)this + 640))(this, *v49, v38 == -1))
      {
        unint64_t v50 = (uint64_t **)(v49 + 1);
      }
      else
      {
        unint64_t v52 = (uint64_t *)v49[1];
        unsigned int v53 = (malloc_zone_t *)get_malloc_zone();
        malloc_zone_free(v53, v49);
        *unint64_t v50 = v52;
        (*(void (**)(CA::OGL::Context *, uint64_t))(*(void *)this + 648))(this, v51);
        int64x2_t v54 = *(CA::WindowServer::Surface **)(v51 + 32);
        if (v54) {
          CA::WindowServer::Surface::unref(v54);
        }
        int64x2_t v55 = *(CA::WindowServer::Surface **)(v51 + 40);
        if (v55) {
          CA::WindowServer::Surface::unref(v55);
        }
        uint64_t v56 = *(void *)(v51 + 8);
        if (v56)
        {
          (*(void (**)(uint64_t))(*(void *)v56 + 184))(v56);
          *(void *)(v51 + 8) = 0;
        }
        if ((*(_WORD *)(v51 + 58) & 0x200) != 0) {
          *((void *)this + 42) = x_list_remove(*((void **)this + 42), v51);
        }
        unsigned int v57 = (malloc_zone_t *)get_malloc_zone();
        malloc_zone_free(v57, (void *)v51);
      }
      uint64_t v49 = *v50;
    }
    while (*v50);
    uint64_t v49 = v95;
  }
  uint64_t v58 = v94;
  uint64_t v59 = v96;
  if (v94 || v96 || v49)
  {
    os_unfair_lock_lock((os_unfair_lock_t)this + 76);
    uint64_t v60 = *((void *)this + 43);
    uint64_t v97 = v60;
    if (v60)
    {
      do
      {
        uint64_t v61 = v60;
        uint64_t v60 = *(void *)(v60 + 8);
      }
      while (v60);
      long long v62 = (uint64_t **)(v61 + 8);
    }
    else
    {
      long long v62 = (uint64_t **)&v97;
    }
    *long long v62 = v58;
    *((void *)this + 43) = v97;
    if (v59)
    {
      do
      {
        char v63 = (void *)v59[1];
        if (*(unsigned char *)(*v59 + 61))
        {
          uint64_t v64 = (malloc_zone_t *)get_malloc_zone();
          malloc_zone_free(v64, v59);
        }
        else
        {
          *(unsigned char *)(*v59 + 60) = 1;
          v59[1] = *((void *)this + 41);
          *((void *)this + 41) = v59;
        }
        uint64_t v59 = v63;
      }
      while (v63);
    }
    uint64_t v65 = *((void *)this + 40);
    uint64_t v96 = 0;
    uint64_t v97 = v65;
    if (v65)
    {
      do
      {
        uint64_t v66 = v65;
        uint64_t v65 = *(void *)(v65 + 8);
      }
      while (v65);
      long long v67 = (uint64_t **)(v66 + 8);
    }
    else
    {
      long long v67 = (uint64_t **)&v97;
    }
    *long long v67 = v49;
    *((void *)this + 40) = v97;
    os_unfair_lock_unlock((os_unfair_lock_t)this + 76);
  }
  uint64_t v68 = (void *)*((void *)this + 42);
  if (v68)
  {
    uint64_t v69 = (void *)((char *)this + 336);
    do
    {
      uint64_t v70 = *v68;
      if (*(_DWORD *)(*v68 + 20) > v38
        || v38 == -1
        && !(*(unsigned int (**)(CA::OGL::Context *, void, uint64_t))(*(void *)this + 640))(this, *v68, 1))
      {
        uint64_t v69 = v68 + 1;
      }
      else
      {
        uint64_t v71 = v68[1];
        long long v72 = (malloc_zone_t *)get_malloc_zone();
        malloc_zone_free(v72, v68);
        *uint64_t v69 = v71;
        *(_WORD *)(v70 + 58) &= ~0x200u;
        (*(void (**)(CA::OGL::Context *, uint64_t))(*(void *)this + 648))(this, v70);
      }
      uint64_t v68 = (void *)*v69;
    }
    while (*v69);
  }
  long long v73 = (uint64_t *)*((void *)this + 45);
  if (v73)
  {
    uint64_t v75 = *v73;
    uint64_t v74 = v73[1];
    while (v75 != v74)
    {
      int v76 = *(unsigned __int16 *)(v75 + 26) - 1;
      *(_WORD *)(v75 + 26) = v76;
      if (!v76)
      {
        if (v75 != v74)
        {
          uint64_t v77 = v75 + 32;
          if (v75 + 32 != v74)
          {
            do
            {
              int v78 = *(unsigned __int16 *)(v77 + 26) - 1;
              *(_WORD *)(v77 + 26) = v78;
              if (v78)
              {
                *(void *)uint64_t v75 = *(void *)v77;
                uint64_t v79 = *(void *)(v77 + 8);
                *(void *)(v77 + 8) = 0;
                long long v80 = *(atomic_uint **)(v75 + 8);
                *(void *)(v75 + 8) = v79;
                if (v80 && atomic_fetch_add(v80 + 2, 0xFFFFFFFF) == 1) {
                  (*(void (**)(atomic_uint *))(*(void *)v80 + 16))(v80);
                }
                uint64_t v81 = *(void *)(v77 + 16);
                *(void *)(v77 + 16) = 0;
                long long v82 = *(atomic_uint **)(v75 + 16);
                *(void *)(v75 + 16) = v81;
                if (v82 && atomic_fetch_add(v82 + 2, 0xFFFFFFFF) == 1) {
                  (*(void (**)(atomic_uint *))(*(void *)v82 + 16))(v82);
                }
                *(_DWORD *)(v75 + 24) = *(_DWORD *)(v77 + 24);
                v75 += 32;
              }
              v77 += 32;
            }
            while (v77 != v74);
            long long v73 = (uint64_t *)*((void *)this + 45);
            uint64_t v74 = v73[1];
          }
        }
        if (v75 != v74)
        {
          while (v74 != v75)
          {
            v74 -= 32;
            std::__destroy_at[abi:nn180100]<CA::OGL::TransientRenderTexture,0>(v74);
          }
          v73[1] = v75;
        }
        break;
      }
      v75 += 32;
    }
  }
  long long v83 = (char *)this + 368;
  if (*((CA::OGL::Context **)this + 47) != (CA::OGL::Context *)((char *)this + 368))
  {
    long long v84 = (char *)*((void *)this + 46);
    if (v84 != v83)
    {
      while ((a2 & 1) != 0
           || (*((_DWORD *)this + 57) - *((_DWORD *)v84 + 6)) > 0x1D
           || *((void *)this + 48) > *((void *)this + 49))
      {
        unsigned int v86 = *(char **)v84;
        long long v85 = (char **)*((void *)v84 + 1);
        *((void *)v86 + 1) = v85;
        *long long v85 = v86;
        *(void *)long long v84 = v84;
        *((void *)v84 + 1) = v84;
        uint64_t v87 = *((void *)v84 + 6);
        if (v87)
        {
          *((void *)this + 48) -= *(int *)(v87 + 44) * (uint64_t)*(int *)(v87 + 40) * (*(unsigned char *)(v87 + 74) & 0x1F);
          CA::OGL::Context::release_surface((uint64_t)this, v87);
        }
        uint64_t v88 = (malloc_zone_t *)get_malloc_zone();
        malloc_zone_free(v88, v84);
        long long v84 = v86;
        if (v86 == v83) {
          goto LABEL_157;
        }
      }
      while (v84 != v83)
      {
        if (*((void *)v84 + 6) && *((_DWORD *)v84 + 6) < *((_DWORD *)this + 57)) {
          (*(void (**)(CA::OGL::Context *))(*(void *)this + 808))(this);
        }
        long long v84 = (char *)*((void *)v84 + 1);
      }
    }
  }
LABEL_157:
  int64_t v90 = (uint64_t *)((char *)this + 80);
  uint64_t v89 = *((void *)this + 10);
  if (v89)
  {
    do
    {
      if ((a2 & 1) != 0 || (v92 = *(_DWORD *)v89 - 1, BOOL v91 = *(_DWORD *)v89 == 1, *(_DWORD *)v89 = v92, v91))
      {
        *int64_t v90 = *(void *)(v89 + 8);
        (*(void (**)(CA::OGL::Context *, uint64_t))(*(void *)this + 736))(this, v89);
      }
      else
      {
        if (v92 <= 2) {
          (*(void (**)(CA::OGL::Context *, uint64_t, uint64_t))(*(void *)this + 808))(this, v89, 2);
        }
        int64_t v90 = (uint64_t *)(v89 + 8);
      }
      uint64_t v89 = *v90;
    }
    while (*v90);
  }
  if (a2)
  {
    unint64_t v93 = (_DWORD *)*((void *)this + 35);
    if (v93)
    {
      if (*v93 == 1)
      {
        (*(void (**)(CA::OGL::Context *))(*(void *)this + 736))(this);
        *((void *)this + 35) = 0;
      }
    }
  }
}

uint64_t CA::OGL::MetalContext::set_surface_volatile()
{
  return 1;
}

void CA::OGL::MetalContext::finalize_surface(uint64_t a1, uint64_t a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (*(void *)(a2 + 224)) {
    BOOL v4 = BYTE3(xmmword_1EB2ACC70) == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4)
  {
    int v6 = CA::OGL::MetalContext::_metal_trace_log;
    if (os_signpost_enabled((os_log_t)CA::OGL::MetalContext::_metal_trace_log))
    {
      int v9 = *(_DWORD *)(a2 + 24);
      int v10 = *(_DWORD *)(a2 + 28);
      int v11 = *(_DWORD *)(a2 + 68);
      double v12 = CA::OGL::MetalContext::metal_pixel_format_name(*(CA::OGL::MetalContext **)(a2 + 120), v8);
      uint64_t v13 = *(void *)(a2 + 224);
      uint64_t v14 = *(int *)(a2 + 28) * (uint64_t)*(int *)(a2 + 24) * (*(unsigned char *)(a2 + 74) & 0x1F);
      v15[0] = 67241474;
      v15[1] = v9;
      __int16 v16 = 1026;
      int v17 = v10;
      __int16 v18 = 1026;
      int v19 = v11;
      __int16 v20 = 2082;
      long long v21 = v12;
      __int16 v22 = 2050;
      uint64_t v23 = v14;
      __int16 v24 = 2050;
      uint64_t v25 = v13;
      _os_signpost_emit_with_name_impl(&dword_184668000, v6, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SurfaceLifetime", " width=%{public,name=width}d height=%{public,name=height}d features=%{public,name=features}#x format=%{public,name=format}s alloc_size=%{public,name=alloc_size}zu begin=%{public,signpost.description:begin_time}llu", (uint8_t *)v15, 0x32u);
    }
  }
  if (*(void *)(a1 + 3320) == a2) {
    *(void *)(a1 + 3320) = 0;
  }
  CA::OGL::MetalContext::finalize_surface_textures(a1, a2);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  malloc_zone_free(malloc_zone, (void *)a2);
}

void CA::OGL::MetalContext::finalize_surface_textures(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 200);
  if (v4) {
    *(_WORD *)(v4 + 216) |= 1 << *(_WORD *)(a2 + 212);
  }

  *(void *)(a2 + 144) = 0;
  *(void *)(a2 + 152) = 0;
  LOWORD(v5) = *(_WORD *)(a2 + 232);
  if ((__int16)((_WORD)v5 << 12) >= 1)
  {
    uint64_t v6 = 0;
    do
    {
      uint64_t v7 = a2 + 8 * v6;

      *(void *)(v7 + 96) = 0;
      uint64_t v8 = *(void *)(v7 + 160);
      if (v8)
      {
        CA::OGL::MetalContext::delete_image(a1, v8);
        int v9 = *(void **)(v7 + 160);
        if (v9)
        {
          malloc_zone = (malloc_zone_t *)get_malloc_zone();
          malloc_zone_free(malloc_zone, v9);
        }
        *(void *)(v7 + 160) = 0;
      }
      ++v6;
      int v5 = *(unsigned __int16 *)(a2 + 232);
    }
    while (v6 < v5 << 28 >> 28);
  }
  *(_WORD *)(a2 + 232) = v5 & 0xFFF0;
}

void CA::OGL::MetalContext::delete_image(uint64_t a1, uint64_t a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 16);
  if (v4)
  {
    uint64_t v5 = 0;
    uint64_t v6 = v4 + 176;
    do
    {
      if ((*(void *)(v6 + v5) & 0xFFFFFFFFFFFFFFFCLL) == a2) {
        __assert_rtn("delete_image", "ogl-metal.mm", 12655, "state_image_binding (_state, tex_unit) != tex");
      }
      v5 += 8;
    }
    while (v5 != 104);
  }
  uint64_t v7 = *(unsigned __int8 *)(a2 + 122);
  size_t v8 = 8 * v7;
  if (v7 <= 2) {
    size_t v9 = 24 - 8 * v7;
  }
  else {
    size_t v9 = 0;
  }
  bzero((char *)&__dst + 8 * v7, v9);
  memcpy(&__dst, (const void *)(a2 + 64), v8);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZN2CA3OGL12MetalContext12delete_imageEPNS0_5ImageE_block_invoke;
  block[3] = &__block_descriptor_56_e5_v8__0ls32l24;
  long long v20 = __dst;
  uint64_t v21 = v23;
  if (*(char *)(a2 + 125) < 0)
  {
    int v11 = *(void **)(a1 + 2976);
    if (v11)
    {
      v18[0] = MEMORY[0x1E4F143A8];
      v18[1] = 3221225472;
      double v18[2] = ___ZN2CA3OGL12MetalContext12delete_imageEPNS0_5ImageE_block_invoke_2;
      v18[3] = &unk_1E527BE40;
      uint64_t v18[4] = block;
      v18[5] = a1;
      [v11 addScheduledHandler:v18];
    }
    else
    {
      dispatch_async(*(dispatch_queue_t *)(a1 + 4000), block);
    }
  }
  else
  {
    for (uint64_t i = 0; i != 24; i += 8)
  }
  if (*(unsigned char *)(a2 + 122))
  {
    unint64_t v12 = 0;
    do
    {
      uint64_t v13 = a2 + 8 * v12;
      *(void *)(v13 + 64) = 0;

      *(void *)(v13 + 88) = 0;
      ++v12;
    }
    while (v12 < *(unsigned __int8 *)(a2 + 122));
  }
  uint64_t v14 = *(CA::WindowServer::Surface **)(a2 + 32);
  if (v14)
  {
    CA::WindowServer::Surface::unref(v14);
    *(void *)(a2 + 32) = 0;
  }
  uint64_t v15 = *(CA::WindowServer::Surface **)(a2 + 40);
  if (v15)
  {
    CA::WindowServer::Surface::unref(v15);
    *(void *)(a2 + 40) = 0;
  }
  __int16 v16 = *(_WORD *)(a2 + 123);
  *(unsigned char *)(a2 + 122) = 0;
  int v17 = *(unsigned __int8 *)(a2 + 55) << 24;
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 48) = 0;
  *(_DWORD *)(a2 + 52) = v17;
  *(_WORD *)(a2 + 123) = v16 & 0xFFD8;
}

void CA::Render::Image::release_data(atomic_uint *this)
{
  if (atomic_fetch_add(this + 37, 0xFFFFFFFF) == 1)
  {
    CA::Render::Image::~Image((CA::Render::Image *)this);
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(malloc_zone, this);
  }
}

void CA::Render::Texture::~Texture(CGColorSpaceRef *this)
{
  *this = (CGColorSpaceRef)&unk_1ED02FB10;
  CGColorSpaceRelease(this[6]);
  BOOL v3 = this[5];
  if (v3) {
    CA::Shape::unref(v3);
  }
  *this = (CGColorSpaceRef)&unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate((CA::Render::Encoder::ObjectCache *)this, v2);
  }
}

{
  malloc_zone_t *malloc_zone;
  uint64_t vars8;

  CA::Render::Texture::~Texture(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

void CA::Render::Encoder::ObjectCache::invalidate(CA::Render::Encoder::ObjectCache *this, const CA::Render::Object *a2)
{
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::Encoder::ObjectCache::_lock);
  BOOL v3 = (void *)CA::Render::Encoder::ObjectCache::_cache_list;
  if (CA::Render::Encoder::ObjectCache::_cache_list)
  {
    do
    {
      uint64_t v4 = *v3;
      unsigned int v5 = x_hash_table_remove(*(void *)(*v3 + 8), (uint64_t)this);
      if (v5 || (v7 = *(void *)(v4 + 24)) != 0 && (unsigned int v5 = x_hash_table_remove(v7, (uint64_t)this)) != 0)
      {
        uint64_t v6 = *(int **)(v4 + 16);
        if (!v6)
        {
          uint64_t v6 = (int *)x_hash_table_new_(0, 0, 0, 0, 0, 0);
          *(void *)(v4 + 16) = v6;
        }
        hash_table_modify(v6, (uint64_t)this, v5, 0);
      }
      BOOL v3 = (void *)v3[1];
    }
    while (v3);
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Encoder::ObjectCache::_lock);
}

void CA::OGL::Context::cache_set_surface(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a2 + 48);
  if (v4 != a3)
  {
    if (v4)
    {
      *(void *)(a1 + 384) -= *(int *)(v4 + 44) * (uint64_t)*(int *)(v4 + 40) * (*(unsigned char *)(v4 + 74) & 0x1F);
      CA::OGL::Context::release_surface(a1, v4);
      *(void *)(a2 + 48) = 0;
    }
    if (a3 && (*(unsigned char *)(a1 + 433) & 0x10) == 0)
    {
      uint64_t v7 = *(int *)(a3 + 44) * (uint64_t)*(int *)(a3 + 40) * (*(unsigned char *)(a3 + 74) & 0x1F);
      unint64_t v8 = *(void *)(a1 + 392);
      unint64_t v9 = *(void *)(a1 + 384) + v7;
      if (v9 > v8)
      {
        int v10 = *(uint64_t **)(a1 + 368);
        if (v10 != (uint64_t *)a2)
        {
          while (1)
          {
            uint64_t v11 = *(void *)(a1 + 384);
            if (*((_DWORD *)v10 + 6) == *(_DWORD *)(a2 + 24) || (unint64_t)(v11 + v7) <= *(void *)(a1 + 392)) {
              break;
            }
            unint64_t v12 = (uint64_t *)*v10;
            uint64_t v13 = v10[6];
            if (v13)
            {
              *(void *)(a1 + 384) = v11
                                    - *(int *)(v13 + 44) * (uint64_t)*(int *)(v13 + 40) * (*(unsigned char *)(v13 + 74) & 0x1F);
              CA::OGL::Context::release_surface(a1, v13);
              uint64_t v15 = *v10;
              uint64_t v14 = (void *)v10[1];
              *(void *)(v15 + 8) = v14;
              void *v14 = v15;
              *int v10 = (uint64_t)v10;
              v10[1] = (uint64_t)v10;
              malloc_zone = (malloc_zone_t *)get_malloc_zone();
              malloc_zone_free(malloc_zone, v10);
            }
            int v10 = v12;
            if (v12 == (uint64_t *)a2)
            {
              uint64_t v11 = *(void *)(a1 + 384);
              break;
            }
          }
          unint64_t v8 = *(void *)(a1 + 392);
          unint64_t v9 = v11 + v7;
        }
      }
      if (v9 <= v8)
      {
        ++*(_DWORD *)a3;
        *(void *)(a2 + 48) = a3;
        *(void *)(a1 + 384) = v9;
      }
    }
  }
}

void CA::Render::Image::~Image(CA::Render::Image *this)
{
  int v2 = (void (*)(void, void))*((void *)this + 13);
  if (v2) {
    v2(*((void *)this + 12), *((void *)this + 14));
  }
  BOOL v3 = (atomic_uint *)*((void *)this + 15);
  if (v3 && atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v3 + 16))(v3);
  }
  --dword_1EB2ADE24;

  CA::Render::Texture::~Texture((CGColorSpaceRef *)this);
}

{
  malloc_zone_t *malloc_zone;
  uint64_t vars8;

  CA::Render::Image::~Image(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

BOOL CA::OGL::MetalContext::finish_image(CA::OGL::MetalContext *this, uint64_t a2, int a3)
{
  if (!*(unsigned char *)(a2 + 122)) {
    return 1;
  }
  if (a3)
  {
    unint64_t v5 = *(void *)(a2 + 112);
    unint64_t v6 = atomic_load((unint64_t *)this + 504);
    if (v5 > v6)
    {
      int v7 = *((_DWORD *)this + 681);
      CA::OGL::MetalContext::flush(this, 1);
      if ((v7 & 0x4000) != 0)
      {
        if (*(unsigned char *)(a2 + 122))
        {
          unint64_t v9 = 0;
          do
            [*(id *)(a2 + 64 + 8 * v9++) waitUntilComplete];
          while (v9 < *(unsigned __int8 *)(a2 + 122));
        }
      }
      else
      {
        [*((id *)this + 371) waitUntilCompleted];

        *((void *)this + 371) = 0;
      }
      goto LABEL_10;
    }
    return 1;
  }
LABEL_10:
  unint64_t v10 = *(void *)(a2 + 112);
  unint64_t v11 = atomic_load((unint64_t *)this + 504);
  return v10 <= v11;
}

uint64_t CA::Render::release_shmem_bitmap(CA::Render *this, const void *a2, void *a3)
{
  atomic_fetch_add(*((atomic_uint *volatile *)a2 + 3), 0xFFFFFFFF);
  if (atomic_fetch_add((atomic_uint *volatile)a2 + 2, 0xFFFFFFFF) == 1) {
    return (*(uint64_t (**)(const void *))(*(void *)a2 + 16))(a2);
  }
  return result;
}

void CA::Render::anonymous namespace'::provider_free(CA::Render::_anonymous_namespace_ *this, CGDataProvider *a2, void *a3)
{
  CGDataProviderReleaseBytePtr();

  CGDataProviderRelease(a2);
}

atomic_uint *CA::Render::CompressedImage::unref_image_data(atomic_uint *this)
{
  unsigned int add = atomic_fetch_add(this + 41, 0xFFFFFFFF);
  if (this)
  {
    if (add == 1) {
      return (atomic_uint *)(*(uint64_t (**)(void))(*(void *)this + 8))();
    }
  }
  return this;
}

int *CA::OGL::FilterNode::retain_surface(CA::OGL::FilterNode *this, float *a2, uint64_t a3)
{
  unsigned int v3 = a3;
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if ((*((unsigned char *)this + 224) & 1) == 0) {
    return CA::OGL::ImagingNode::retain_surface(this, a2, v3);
  }
  uint64_t v6 = *((void *)this + 2);
  if ((*(_WORD *)(v6 + 40) & 8) != 0 || (*(unsigned char *)(v6 + 32) & 8) != 0) {
    return CA::OGL::ImagingNode::retain_surface(this, a2, v3);
  }
  int v7 = (CA::Render::Update **)*((void *)this + 1);
  unint64_t v8 = *v7;
  float v12 = 1.0;
  uint64_t v9 = (*(uint64_t (**)(void, float *, uint64_t))(**((void **)this + 3) + 80))(*((void *)this + 3), &v12, a3);
  unint64_t v10 = (int *)v9;
  if (*((void *)v8 + 35) == v9)
  {
    CA::OGL::Context::release_surface((uint64_t)v8, v9);
    return CA::OGL::ImagingNode::retain_surface(this, a2, v3);
  }
  CA::OGL::Context::push_surface((uint64_t)v8, v9, (*(_WORD *)(v9 + 75) & 0x80) == 0, 64, 0);
  CA::OGL::emit_filter(v7, *((void *)this + 29), *((void *)this + 2), v10, 0, 0, 0, *a2, v12);
  CA::OGL::Context::pop_surface(v8);
  *a2 = v12;
  return v10;
}

__n128 std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<CA::Render::BackdropGroup::Item *&,CA::Render::BackdropGroup::Item *&>(long long *a1, long long *a2)
{
  long long v2 = a1[1];
  long long v3 = a1[6];
  long long v12 = *a1;
  long long v13 = a1[7];
  long long v14 = a1[8];
  __n128 v15 = (__n128)a1[9];
  uint64_t v16 = *((void *)a1 + 20);
  long long v4 = a1[2];
  long long v5 = a1[3];
  long long v6 = a1[4];
  long long v7 = a1[5];
  *a1 = *a2;
  a1[1] = a2[1];
  a1[2] = a2[2];
  a1[3] = a2[3];
  a1[4] = a2[4];
  a1[5] = a2[5];
  a1[6] = a2[6];
  long long v8 = a2[7];
  long long v9 = a2[8];
  long long v10 = a2[9];
  *((void *)a1 + 20) = *((void *)a2 + 20);
  a1[8] = v9;
  a1[9] = v10;
  a1[7] = v8;
  *a2 = v12;
  a2[1] = v2;
  a2[2] = v4;
  a2[3] = v5;
  a2[4] = v6;
  a2[5] = v7;
  *((void *)a2 + 20) = v16;
  __n128 result = v15;
  a2[8] = v14;
  a2[9] = (__int128)v15;
  a2[6] = v3;
  a2[7] = v13;
  return result;
}

atomic_uint *CA::Render::Array::decode(CA::Render::Decoder *a1, uint64_t a2, int *a3, int a4)
{
  int v8 = CA::Render::Decoder::decode_int32(a1);
  unsigned int v9 = CA::Render::Decoder::decode_int32(a1);
  unsigned int v10 = v9;
  if (v9 > 0x100000)
  {
    CA::Render::Decoder::set_fatal_error(a1, "%s - suspiciously large array: %u");
    return 0;
  }
  size_t v11 = 8 * v9 + 24;
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  long long v13 = (char *)malloc_type_zone_malloc(malloc_zone, v11, 0x8BB15036uLL);
  long long v14 = (atomic_uint *)v13;
  if (v13)
  {
    if (((((v8 & 1) == 0) ^ a4) & 1) == 0)
    {
      CA::Render::Decoder::set_fatal_error(a1, "%s - array is %sretained, but %sretained is expected");
      return 0;
    }
    uint64_t v15 = v10;
    *((_DWORD *)v13 + 2) = 1;
    ++dword_1EB2ADDCC;
    *(void *)long long v13 = &unk_1ED02F158;
    *((_DWORD *)v13 + 3) = (v8 << 8) | 1;
    *((_DWORD *)v13 + 4) = v10;
    if ((v8 & 1) == 0)
    {
      if (!v10) {
        goto LABEL_18;
      }
      char v16 = 0;
      int v17 = (uint64_t *)(v13 + 24);
      do
      {
        uint64_t v18 = CA::Render::Decoder::decode_object(a1, 0);
        *v17++ = v18;
        v16 |= v18 == 0;
        --v15;
      }
      while (v15);
      if (v16)
      {
        int v19 = 1;
      }
      else
      {
LABEL_18:
        if (CA::Render::Array::check_types((uint64_t)v14, a2, a3)) {
          return v14;
        }
        int v19 = 0;
      }
      if (a3) {
        int v22 = *a3;
      }
      else {
        int v22 = -1;
      }
      CA::Render::Decoder::set_fatal_error(a1, "%s - null_pointer? %d, n_types %zu, types[0] = %d", "decode", v19, a2, v22);
      if (atomic_fetch_add(v14 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v14 + 16))(v14);
      }
      return 0;
    }
    if (v10)
    {
      uint64_t v21 = 0;
      do
      {
        *(void *)&v14[v21 + 6] = CA::Render::Decoder::decode_size_t(a1);
        v21 += 2;
      }
      while (2 * v10 != v21);
    }
  }
  return v14;
}

void CA::Render::Server::CmdStreamMsg::run(CA::Render::Server::CmdStreamMsg *this, BOOL *a2, BOOL *a3, double *a4)
{
  uint64_t v119 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *((void *)this + 521);
  if (!v4) {
    __assert_rtn("run", "render-server.cpp", 1596, "is_valid ()");
  }
  long long v5 = this;
  if (*((unsigned char *)this + 4176)) {
    __assert_rtn("run", "render-server.cpp", 1597, "!_did_run");
  }
  *((unsigned char *)this + 4176) = 1;
  uint64_t v8 = *((void *)this + 520);
  uint64_t v9 = 0;
  if ((int)v8 - 1 >= 0)
  {
    uint64_t v10 = *((void *)this + 519);
    uint64_t v11 = 8 * (v8 - 1);
    do
    {
      **(void **)(v10 + v11) = v9;
      uint64_t v9 = *(void *)(v10 + v11);
      v11 -= 8;
    }
    while (v11 != -8);
  }
  *(void *)(v4 + 48) = v9;
  *(void *)(v4 + 56) = v8;
  unint64_t v12 = *(void *)(v4 + 72);
  kdebug_trace();
  int64_t v113 = (const void **)(v12 + 528);
  double v13 = NAN;
  uint32x2_t v115 = a2;
  uint64_t v116 = (CA::Render::ImageProvider *)v12;
  while (2)
  {
    int v14 = CA::Render::Decoder::decode_int8((CA::Render::Decoder *)v4);
    switch(v14)
    {
      case 0:
        goto LABEL_131;
      case 1:
        uint64_t v17 = CA::Render::Decoder::decode_size_t((CA::Render::Decoder *)v4);
        int v18 = CA::Render::Decoder::decode_int32((CA::Render::Decoder *)v4);
        int v19 = (CA::Render::Context *)v12;
        long long v20 = (CA::Render::Object *)v17;
        goto LABEL_38;
      case 2:
        *a2 = 1;
        unint64_t v21 = CA::Render::Decoder::decode_size_t((CA::Render::Decoder *)v4);
        unsigned int v22 = CA::Render::Decoder::decode_int32((CA::Render::Decoder *)v4);
        uint64_t v23 = CA::Render::Decoder::decode_object(v4, 0);
        CA::Render::Decoder::decode_int32((CA::Render::Decoder *)v4);
        if (*(unsigned char *)(v4 + 18))
        {
          if (x_log_hook_p()) {
            goto LABEL_111;
          }
          unsigned int v86 = x_log_category_render;
          if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
          {
            int v87 = *(_DWORD *)(v12 + 16);
            *(_DWORD *)buf = 67109120;
            int v118 = v87;
            goto LABEL_127;
          }
          goto LABEL_128;
        }
        CA::Render::Context::set_object((CA::Render::Context *)v12, v21, v22, (CA::Render::Object *)v23);
        goto LABEL_83;
      case 3:
        *a2 = 1;
        uint64_t v24 = (CA::Render::Object *)CA::Render::Decoder::decode_size_t((CA::Render::Decoder *)v4);
        CA::Render::Context::update_layer((CA::Render::Context *)v12, v24);
        goto LABEL_83;
      case 4:
        *a2 = 1;
        uint64_t v25 = (CA::Render::Object *)CA::Render::Decoder::decode_size_t((CA::Render::Decoder *)v4);
        uint64_t v23 = CA::Render::Decoder::decode_object((CA::Render::Decoder *)v4, 7, (uint64_t)&CA::Render::Decoder::decode_animation(void)::types);
        if (*(unsigned char *)(v4 + 18))
        {
          if (x_log_hook_p()) {
            goto LABEL_111;
          }
          unsigned int v86 = x_log_category_render;
          if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
          {
            int v88 = *(_DWORD *)(v12 + 16);
            *(_DWORD *)buf = 67109120;
            int v118 = v88;
            goto LABEL_127;
          }
          goto LABEL_128;
        }
        CA::Render::Context::add_animation((CA::Render::Context *)v12, v25, (CA::Render::Animation *)v23);
        if (!v23) {
          goto LABEL_83;
        }
        goto LABEL_76;
      case 5:
        *a2 = 1;
        uint64_t v26 = (CA::Render::Object *)CA::Render::Decoder::decode_size_t((CA::Render::Decoder *)v4);
        CA::Render::Context::remove_all_animations((CA::Render::Context *)v12, v26);
        goto LABEL_83;
      case 6:
        *a2 = 1;
        long long v27 = (CA::Render::Object *)CA::Render::Decoder::decode_size_t((CA::Render::Decoder *)v4);
        CFStringGetTypeID();
        long long v28 = CA::Render::Decoder::decode_cfobject((CA::Render::Decoder *)v4);
        CA::Render::Context::remove_animation((CA::Render::Context *)v12, v27, (const __CFString *)v28);
        if (v28) {
          CFRelease(v28);
        }
        goto LABEL_83;
      case 7:
        *a2 = 1;
        uint64_t v29 = CA::Render::Decoder::decode_size_t((CA::Render::Decoder *)v4);
        CA::Render::Context::set_layer_id(v12, v29);
        goto LABEL_83;
      case 8:
        CFDictionaryGetTypeID();
        long long v30 = CA::Render::Decoder::decode_cfobject((CA::Render::Decoder *)v4);
        X::CFRef<__CFDictionary const*>::operator=(v113, v30);
        ++*(_DWORD *)(v12 + 48);
        if (v30) {
          CFRelease(v30);
        }
        unsigned int v31 = 7;
        goto LABEL_29;
      case 9:
        *a2 = 1;
        unsigned int v32 = CA::Render::Decoder::decode_colorspace((CA::Render::Decoder *)v4);
        if (*(unsigned char *)(v4 + 18))
        {
          if (x_log_hook_p())
          {
            x_log_();
          }
          else
          {
            BOOL v91 = x_log_category_render;
            if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
            {
              int v92 = *(_DWORD *)(v12 + 16);
              *(_DWORD *)buf = 67109120;
              int v118 = v92;
              _os_log_impl(&dword_184668000, v91, OS_LOG_TYPE_ERROR, "CoreAnimation: serialization error from context %x\n", buf, 8u);
            }
          }
          if (!v32) {
            goto LABEL_131;
          }
          unint64_t v93 = v32;
LABEL_120:
          CFRelease(v93);
          goto LABEL_131;
        }
        CA::Render::Context::set_colorspace((CA::Render::Context *)v12, v32);
        CGColorSpaceRelease(v32);
        goto LABEL_83;
      case 10:
        CFStringGetTypeID();
        uint64_t v33 = CA::Render::Decoder::decode_cfobject((CA::Render::Decoder *)v4);
        if ((*(unsigned char *)(v4 + 18) & 1) == 0)
        {
          CA::Render::Context::set_client_annotation((CA::Render::Context *)v12, v33);
          goto LABEL_83;
        }
        if (x_log_hook_p())
        {
          x_log_();
        }
        else
        {
          unsigned int v94 = x_log_category_render;
          if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
          {
            int v95 = *(_DWORD *)(v12 + 16);
            *(_DWORD *)buf = 67109120;
            int v118 = v95;
            _os_log_impl(&dword_184668000, v94, OS_LOG_TYPE_ERROR, "CoreAnimation: serialization error from context %x\n", buf, 8u);
          }
        }
        if (!v33) {
          goto LABEL_131;
        }
        unint64_t v93 = v33;
        goto LABEL_120;
      case 11:
      case 12:
        int v15 = v14;
        *a2 = 1;
        int v16 = CA::Render::Decoder::decode_size_t((CA::Render::Decoder *)v4);
        CA::Render::Context::order_relative((CA::Render::Context *)v12, v15 == 11, v16);
        goto LABEL_83;
      case 13:
        *a2 = 1;
        float v34 = COERCE_FLOAT(CA::Render::Decoder::decode_int32((CA::Render::Decoder *)v4));
        if (*(float *)(v12 + 192) == v34) {
          goto LABEL_83;
        }
        *(float *)(v12 + 192) = v34;
        unsigned int v31 = 8;
LABEL_29:
        CA::Render::post_notification(v31, v12, 0, 0);
        goto LABEL_83;
      case 14:
        *a2 = 1;
        unsigned int v35 = CA::Render::Decoder::decode_int32((CA::Render::Decoder *)v4);
        uint64_t v23 = CA::Render::Decoder::decode_object(v4, 0);
        if (*(unsigned char *)(v4 + 18))
        {
          if (x_log_hook_p()) {
            goto LABEL_111;
          }
          unsigned int v86 = x_log_category_render;
          if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
          {
            int v89 = *(_DWORD *)(v12 + 16);
            *(_DWORD *)buf = 67109120;
            int v118 = v89;
            goto LABEL_127;
          }
          goto LABEL_128;
        }
        CA::Render::Context::set_slot((CA::Render::Context *)v12, v35, v23);
        if (!v23) {
          goto LABEL_83;
        }
        goto LABEL_76;
      case 15:
        unsigned int v36 = CA::Render::Decoder::decode_int32((CA::Render::Decoder *)v4);
        CA::Render::Context::delete_slot((CA::Render::Context *)v12, v36);
        goto LABEL_83;
      case 16:
        int v37 = CA::Render::Decoder::decode_int32((CA::Render::Decoder *)v4);
        unsigned int v38 = (CA::Render::Context *)CA::Render::Decoder::decode_int32((CA::Render::Decoder *)v4);
        CA::Render::Context::transfer_slot((CA::Render::Context *)v12, v37, v38);
        goto LABEL_83;
      case 17:
        uint64_t v39 = CA::Render::Decoder::decode_size_t((CA::Render::Decoder *)v4);
        int v40 = CA::Render::Decoder::decode_int32((CA::Render::Decoder *)v4);
        unint64_t v41 = CA::Render::Context::lookup_object(*(void *)(v12 + 136), *(_DWORD *)(v12 + 148), v39, v40, 0, 0);
        if (v41) {
          CA::Render::post_notification(0xBu, v41, 0, 0);
        }
        int v19 = (CA::Render::Context *)v12;
        long long v20 = (CA::Render::Object *)v39;
        int v18 = v40;
LABEL_38:
        CA::Render::Context::delete_object(v19, v20, v18);
        goto LABEL_83;
      case 18:
        *a2 = 1;
        int v42 = CA::Render::Decoder::decode_int32((CA::Render::Decoder *)v4);
        unsigned int v43 = CA::Render::Decoder::decode_int32((CA::Render::Decoder *)v4);
        CA::Render::Context::flush_image_queue((CA::Render::Context *)v12, v42, v43);
        goto LABEL_83;
      case 19:
        unsigned int v111 = a4;
        unsigned int v112 = v5;
        *a2 = 1;
        uint64_t v110 = (CA::Render::Context *)CA::Render::Decoder::decode_size_t((CA::Render::Decoder *)v4);
        unsigned int v109 = CA::Render::Decoder::decode_int32((CA::Render::Decoder *)v4);
        unsigned int v108 = CA::Render::Decoder::decode_int32((CA::Render::Decoder *)v4);
        unsigned int v107 = CA::Render::Decoder::decode_int32((CA::Render::Decoder *)v4);
        int v44 = CA::Render::Decoder::decode_int32((CA::Render::Decoder *)v4);
        int v45 = CA::Render::Decoder::decode_int32((CA::Render::Decoder *)v4);
        int v46 = CA::Render::Decoder::decode_int32((CA::Render::Decoder *)v4);
        int v47 = CA::Render::Decoder::decode_int32((CA::Render::Decoder *)v4);
        int v48 = CA::Render::Decoder::decode_int8((CA::Render::Decoder *)v4);
        LODWORD(v49) = CA::Render::Decoder::decode_int32((CA::Render::Decoder *)v4);
        int v50 = CA::Render::Decoder::decode_int32((CA::Render::Decoder *)v4);
        unsigned int v51 = CA::Render::Decoder::decode_int32((CA::Render::Decoder *)v4);
        unint64_t v52 = (CA::Render::Pattern *)CA::Render::Decoder::decode_object(v4, 37);
        uint64_t v23 = (atomic_uint *)v52;
        if (*(unsigned char *)(v4 + 18))
        {
          if (!x_log_hook_p())
          {
            unsigned int v86 = x_log_category_render;
            a4 = v111;
            long long v5 = v112;
            a2 = v115;
            unint64_t v12 = (unint64_t)v116;
            if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
            {
              int v96 = *((_DWORD *)v116 + 4);
              *(_DWORD *)buf = 67109120;
              int v118 = v96;
              goto LABEL_127;
            }
            goto LABEL_128;
          }
          unint64_t v12 = (unint64_t)v116;
          x_log_();
          a4 = v111;
          long long v5 = v112;
LABEL_109:
          a2 = v115;
          goto LABEL_128;
        }
        int v105 = v47;
        unint64_t v12 = (unint64_t)v116;
        CA::Render::ImageProvider::create(v116, v110, v109, v108, v107, v44, v45, v46, v49, v105, v48 != 0, v106, v50, v51, v52);
        if (v23)
        {
          a4 = v111;
          long long v5 = v112;
          a2 = v115;
          if (atomic_fetch_add(v23 + 2, 0xFFFFFFFF) == 1) {
            goto LABEL_77;
          }
        }
        else
        {
          a4 = v111;
          long long v5 = v112;
          a2 = v115;
        }
        goto LABEL_83;
      case 20:
        *a2 = 1;
        uint64_t v53 = CA::Render::Decoder::decode_size_t((CA::Render::Decoder *)v4);
        unsigned int v54 = CA::Render::Decoder::decode_int32((CA::Render::Decoder *)v4);
        unsigned int v55 = CA::Render::Decoder::decode_int32((CA::Render::Decoder *)v4);
        CA::Render::ImageProvider::set_image_size(*(CA::Render::ImageProvider **)(v12 + 136), (CA::Render::Context *)*(unsigned int *)(v12 + 148), v53, v54, v55);
        goto LABEL_83;
      case 21:
        *a2 = 1;
        uint64_t v56 = CA::Render::Decoder::decode_size_t((CA::Render::Decoder *)v4);
        int v57 = CA::Render::Decoder::decode_int32((CA::Render::Decoder *)v4);
        uint64_t v23 = CA::Render::Decoder::decode_object(v4, 37);
        if (*(unsigned char *)(v4 + 18))
        {
          if (x_log_hook_p()) {
            goto LABEL_111;
          }
          unsigned int v86 = x_log_category_render;
          if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
          {
            int v90 = *(_DWORD *)(v12 + 16);
            *(_DWORD *)buf = 67109120;
            int v118 = v90;
            goto LABEL_127;
          }
          goto LABEL_128;
        }
        CA::Render::ImageProvider::set_fill_color(*(CA::Render::ImageProvider **)(v12 + 136), (CA::Render::Context *)*(unsigned int *)(v12 + 148), v56, v57, (Pattern *)v23);
        if (!v23) {
          goto LABEL_83;
        }
        goto LABEL_76;
      case 22:
        *a2 = 1;
        uint64_t v58 = CA::Render::Decoder::decode_size_t((CA::Render::Decoder *)v4);
        int v59 = CA::Render::Decoder::decode_int32((CA::Render::Decoder *)v4);
        uint64_t v60 = CA::Render::Context::lookup_object(*(void *)(v12 + 136), *(_DWORD *)(v12 + 148), v58, 0, 24, 0);
        if (v60) {
          *(_DWORD *)(v60 + 136) = v59;
        }
        goto LABEL_83;
      case 23:
        *a2 = 1;
        uint64_t v61 = CA::Render::Decoder::decode_size_t((CA::Render::Decoder *)v4);
        int v62 = CA::Render::Decoder::decode_int32((CA::Render::Decoder *)v4);
        int v63 = CA::Render::Decoder::decode_int32((CA::Render::Decoder *)v4);
        int v64 = CA::Render::Decoder::decode_int32((CA::Render::Decoder *)v4);
        uint64_t v23 = CA::Render::Decoder::decode_object((CA::Render::Decoder *)v4, 6, (uint64_t)&CA::Render::texture_types);
        int v65 = CA::Render::Decoder::decode_int32((CA::Render::Decoder *)v4);
        unsigned int v66 = CA::Render::Decoder::decode_int32((CA::Render::Decoder *)v4);
        if ((*(unsigned char *)(v4 + 18) & 1) == 0)
        {
          CA::Render::ImageProvider::set_subimage(*((CA::Render::ImageProvider **)v116 + 17), (CA::Render::Context *)*((unsigned int *)v116 + 37), v61, v62, v63, v64, (CA::Render::Texture *)v23, v65, v66);
          if (v23)
          {
            a2 = v115;
            if (atomic_fetch_add(v23 + 2, 0xFFFFFFFF) == 1) {
              (*(void (**)(atomic_uint *))(*(void *)v23 + 16))(v23);
            }
          }
          else
          {
            a2 = v115;
          }
          unint64_t v12 = (unint64_t)v116;
          goto LABEL_83;
        }
        if (!x_log_hook_p())
        {
          unsigned int v86 = x_log_category_render;
          a2 = v115;
          unint64_t v12 = (unint64_t)v116;
          if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
          {
            int v97 = *((_DWORD *)v116 + 4);
            *(_DWORD *)buf = 67109120;
            int v118 = v97;
            goto LABEL_127;
          }
          goto LABEL_128;
        }
        unint64_t v12 = (unint64_t)v116;
        x_log_();
        goto LABEL_109;
      case 24:
        *a2 = 1;
        uint64_t v67 = CA::Render::Decoder::decode_size_t((CA::Render::Decoder *)v4);
        int v68 = CA::Render::Decoder::decode_int32((CA::Render::Decoder *)v4);
        int v69 = CA::Render::Decoder::decode_int32((CA::Render::Decoder *)v4);
        int v70 = CA::Render::Decoder::decode_int32((CA::Render::Decoder *)v4);
        int v71 = CA::Render::Decoder::decode_int32((CA::Render::Decoder *)v4);
        int v72 = CA::Render::Decoder::decode_int32((CA::Render::Decoder *)v4);
        unsigned int v73 = CA::Render::Decoder::decode_int32((CA::Render::Decoder *)v4);
        int v74 = v69;
        int v75 = v70;
        a2 = v115;
        unint64_t v12 = (unint64_t)v116;
        CA::Render::ImageProvider::invalidate(*((CA::Render::ImageProvider **)v116 + 17), (CA::Render::Context *)*((unsigned int *)v116 + 37), v67, v68, v74, v75, v71, v72, v73);
        goto LABEL_83;
      case 26:
        double v76 = COERCE_DOUBLE(CA::Render::Decoder::decode_int64((CA::Render::Decoder *)v4));
        if (v76 > 0.0) {
          CA::Render::Context::add_input_time((CA::Render::Context *)v12, v76);
        }
        goto LABEL_83;
      case 27:
        if (CA::Render::Decoder::decode_int8((CA::Render::Decoder *)v4)) {
          CA::Render::Context::set_frame_stall_skip_request((CA::Render::Context *)v12, 1);
        }
        goto LABEL_83;
      case 28:
        unint64_t v77 = CA::Render::Decoder::decode_int64((CA::Render::Decoder *)v4);
        if (v77) {
          CA::Render::Context::add_remote_input_mach_time((CA::Render::Context *)v12, v77);
        }
        goto LABEL_83;
      case 29:
        double v78 = COERCE_DOUBLE(CA::Render::Decoder::decode_int64((CA::Render::Decoder *)v4));
        if (v78 != 1.79769313e308) {
          double v13 = v78;
        }
        goto LABEL_83;
      case 30:
        CA::Render::Decoder::decode_int64((CA::Render::Decoder *)v4);
        goto LABEL_83;
      case 31:
        int v79 = CA::Render::Decoder::decode_int8((CA::Render::Decoder *)v4);
        *a3 = 1;
        if (v79) {
          *a2 = 1;
        }
        goto LABEL_83;
      case 32:
        int v80 = CA::Render::Decoder::decode_int32((CA::Render::Decoder *)v4);
        if (CA::Render::Decoder::decode_int8((CA::Render::Decoder *)v4))
        {
          *a2 = 1;
          *(_DWORD *)(v12 + 288) = v80;
          if (!*(_DWORD *)(v12 + 292)) {
            *(_DWORD *)(v12 + 292) = v80;
          }
          *(_DWORD *)(v12 + 296) = v80;
        }
        else
        {
          *(_DWORD *)(v12 + 288) = v80;
        }
        goto LABEL_83;
      case 33:
        buf[0] = 0;
        mach_port_name_t v81 = CA::Render::Decoder::decode_port((CA::Render::Decoder *)v4, 18, (BOOL *)buf);
        if (buf[0]) {
          mach_port_deallocate(*MEMORY[0x1E4F14960], v81);
        }
        goto LABEL_83;
      case 34:
        *(void *)a4 = CA::Render::Decoder::decode_int64((CA::Render::Decoder *)v4);
        goto LABEL_83;
      case 35:
        *a2 = 1;
        long long v82 = CA::Render::Decoder::decode_object(v4, 47);
        uint64_t v23 = v82;
        if ((*(unsigned char *)(v4 + 18) & 1) == 0)
        {
          CA::Render::Context::flush_presentation_modifier_shmem((uint64_t)v82);
          if (v23)
          {
LABEL_76:
            if (atomic_fetch_add(v23 + 2, 0xFFFFFFFF) == 1) {
LABEL_77:
            }
              (*(void (**)(atomic_uint *))(*(void *)v23 + 16))(v23);
          }
LABEL_83:
          if (*(unsigned char *)(v4 + 18))
          {
            if (x_log_hook_p())
            {
              x_log_();
            }
            else
            {
              long long v84 = x_log_category_render;
              if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
              {
                int v85 = *(_DWORD *)(v12 + 16);
                *(_DWORD *)buf = 67109120;
                int v118 = v85;
                _os_log_impl(&dword_184668000, v84, OS_LOG_TYPE_ERROR, "CoreAnimation: serialization error from context %x\n", buf, 8u);
              }
            }
            goto LABEL_131;
          }
          continue;
        }
        if (x_log_hook_p())
        {
LABEL_111:
          x_log_();
          goto LABEL_128;
        }
        unsigned int v86 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
        {
          int v98 = *(_DWORD *)(v12 + 16);
          *(_DWORD *)buf = 67109120;
          int v118 = v98;
LABEL_127:
          _os_log_impl(&dword_184668000, v86, OS_LOG_TYPE_ERROR, "CoreAnimation: serialization error from context %x\n", buf, 8u);
        }
LABEL_128:
        if (v23 && atomic_fetch_add(v23 + 2, 0xFFFFFFFF) == 1) {
          (*(void (**)(atomic_uint *))(*(void *)v23 + 16))(v23);
        }
LABEL_131:
        if (*(_DWORD *)(v12 + 288))
        {
          if (!atomic_load((unsigned int *)(v12 + 228)))
          {
            if (*(_DWORD *)(v12 + 252)) {
              pid_t v100 = 0;
            }
            else {
              pid_t v100 = getpid();
            }
            int v101 = 0;
            atomic_compare_exchange_strong((atomic_uint *volatile)(v12 + 228), (unsigned int *)&v101, v100);
          }
          kdebug_trace();
        }
        if (!atomic_load((unsigned int *)(v12 + 228)))
        {
          if (*(_DWORD *)(v12 + 252)) {
            pid_t v103 = 0;
          }
          else {
            pid_t v103 = getpid();
          }
          int v104 = 0;
          atomic_compare_exchange_strong((atomic_uint *volatile)(v12 + 228), (unsigned int *)&v104, v103);
        }
        if (*a2)
        {
          CA::Render::Context::add_begin_time((os_unfair_lock_s *)v12, v13);
          CA::Render::Context::add_update_deadline((CA::Render::Context *)v12, *a4);
        }
        if ((*(unsigned char *)(v4 + 64) & 4) == 0) {
          CA::Render::Context::increment_commit_seed((os_unfair_lock_s *)v12);
        }
        kdebug_trace();
        CA::Render::Server::CmdStreamMsg::_send_reply(v5);
        return;
      case 36:
        *a2 = 1;
        double v83 = COERCE_DOUBLE(CA::Render::Decoder::decode_int64((CA::Render::Decoder *)v4));
        CA::Render::Context::set_glitch_request((CA::Render::Context *)v12, v83);
        goto LABEL_83;
      default:
        CA::Render::Decoder::set_fatal_error((CA::Render::Decoder *)v4, "invalid command: 0x%x, buffer size %zu, offset %zu", v14, *(void *)(v4 + 40) - *(void *)(v4 + 24), *(void *)(v4 + 32) - *(void *)(v4 + 24));
        goto LABEL_131;
    }
  }
}

uint64_t CA::Render::Decoder::decode_int8(CA::Render::Decoder *this)
{
  uint64_t v1 = (unsigned __int8 *)*((void *)this + 4);
  long long v2 = (unsigned __int8 *)*((void *)this + 5);
  if (v1 + 1 <= v2)
  {
    *((void *)this + 4) = v1 + 1;
    return *v1;
  }
  else
  {
    CA::Render::Decoder::set_fatal_error(this, "%s - _buffer_point = %p, _buffer_end = %p", "decode_int8", *((const void **)this + 4), v2);
    return 0;
  }
}

uint64_t CA::Render::Decoder::decode_int32(CA::Render::Decoder *this)
{
  uint64_t v1 = (unsigned int *)*((void *)this + 4);
  long long v2 = (unsigned int *)*((void *)this + 5);
  long long v3 = v1 + 1;
  if (v1 + 1 <= v2)
  {
    uint64_t v4 = *v1;
    *((void *)this + 4) = v3;
  }
  else
  {
    CA::Render::Decoder::set_fatal_error(this, "%s - _buffer_point = %p, _buffer_end = %p", "decode_int32", *((const void **)this + 4), v2);
    return 0;
  }
  return v4;
}

uint64_t CA::Render::Decoder::decode_int64(CA::Render::Decoder *this)
{
  uint64_t v1 = (uint64_t *)*((void *)this + 4);
  long long v2 = (uint64_t *)*((void *)this + 5);
  long long v3 = v1 + 1;
  if (v1 + 1 <= v2)
  {
    uint64_t v4 = *v1;
    *((void *)this + 4) = v3;
  }
  else
  {
    CA::Render::Decoder::set_fatal_error(this, "%s - _buffer_point = %p, _buffer_end = %p", "decode_int64", *((const void **)this + 4), v2);
    return 0;
  }
  return v4;
}

uint64_t CA::Render::Decoder::decode_size_t(CA::Render::Decoder *this)
{
  if ((*((unsigned char *)this + 64) & 1) == 0) {
    return CA::Render::Decoder::decode_int32(this);
  }

  return CA::Render::Decoder::decode_int64(this);
}

void CA::Render::Context::set_object(CA::Render::Context *this, unint64_t a2, unsigned int a3, CA::Render::Object *a4)
{
  uint64_t v4 = (CA::Render::Context *)MEMORY[0x1F4188790](this);
  v154[509] = *MEMORY[0x1E4F143B8];
  if (!v5) {
    return;
  }
  uint64_t v9 = (uint64_t)v7;
  if (!v7) {
    return;
  }
  int v10 = v6;
  uint64_t v11 = v5;
  unint64_t v12 = v4;
  if (*((unsigned char *)v7 + 12) == 29)
  {
    uint64_t v13 = v8;
    unsigned int v148 = 0;
    uint64_t v14 = (uint64_t)CA::Render::Context::lookup_handle(v4, v5, v6, 1, &v148);
    if (v14)
    {
      uint64_t v16 = v14;
      if (*(void *)(v14 + 16) != v9)
      {
        int v17 = *(_DWORD *)(v9 + 12);
        uint64_t v147 = v14;
        if ((v17 & 0x200) != 0)
        {
          uint64_t v18 = *(void *)(v9 + 112);
          if (v18)
          {
            CA::Render::Layer::set_mask((CA::Render::Layer *)v9, 0);
            *(_DWORD *)(v9 + 12) &= ~0x200u;
            int v19 = (atomic_uint *)CA::Render::Context::lookup_object(*((void *)v12 + 17), *((_DWORD *)v12 + 37), v18, 0, 29, 0);
            if (v19)
            {
              uint64_t v20 = v13;
              uint64_t v14 = CA::Render::Layer::set_mask((CA::Render::Layer *)v9, v19);
            }
            else
            {
              uint64_t v20 = v13;
              if (x_log_hook_p())
              {
                x_log_();
              }
              else
              {
                unsigned int v22 = x_log_category_render;
                uint64_t v14 = os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR);
                if (v14)
                {
                  LODWORD(v151) = 134217984;
                  *(void *)((char *)&v151 + 4) = v18;
                  _os_log_impl(&dword_184668000, v22, OS_LOG_TYPE_ERROR, "CoreAnimation: missing mask layer 0x%lx\n", (uint8_t *)&v151, 0xCu);
                }
              }
            }
          }
          else
          {
            uint64_t v20 = v13;
            *(_DWORD *)(v9 + 12) = v17 & 0xFFFFFDFF;
          }
          uint64_t v13 = v20;
          if ((*(unsigned char *)(v9 + 13) & 0x20) == 0)
          {
            uint64_t v23 = *(void *)(v9 + 104);
            if (v23)
            {
              unint64_t v24 = *(unsigned int *)(v23 + 16);
              if (!v24)
              {
                CA::Render::Layer::set_sublayers(v9, 0);
                goto LABEL_49;
              }
              unsigned int v142 = v13;
              long long v146 = v12;
              if (v24 > 0x200)
              {
                uint64_t v26 = malloc_type_malloc(8 * v24, 0x2004093837F09uLL);
                if (!v26)
                {
                  CA::Render::Layer::set_sublayers(v9, 0);
                  unint64_t v12 = v146;
                  uint64_t v13 = v142;
                  goto LABEL_49;
                }
              }
              else
              {
                MEMORY[0x1F4188790](v14);
                uint64_t v26 = (uint64_t *)((char *)&v129 - ((v25 + 15) & 0xFFFFFFFF0));
                bzero(v26, v25);
              }
              unint64_t v28 = 0;
              int64_t v144 = v24;
              if (v24 <= 1) {
                unint64_t v24 = 1;
              }
              uint64_t v29 = (uint64_t *)(v23 + 24);
              *(void *)&long long v27 = 134217984;
              long long v145 = v27;
              do
              {
                uint64_t v30 = *v29;
                uint64_t v31 = CA::Render::Context::lookup_object(*((void *)v146 + 17), *((_DWORD *)v146 + 37), *v29, 0, 29, 0);
                if (v31)
                {
                  v26[v28++] = v31;
                }
                else if (x_log_hook_p())
                {
                  x_log_();
                }
                else
                {
                  unsigned int v32 = v26;
                  uint64_t v33 = x_log_category_render;
                  if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
                  {
                    LODWORD(v151) = v145;
                    *(void *)((char *)&v151 + 4) = v30;
                    _os_log_impl(&dword_184668000, v33, OS_LOG_TYPE_ERROR, "CoreAnimation: missing sublayer %p\n", (uint8_t *)&v151, 0xCu);
                  }
                  uint64_t v26 = v32;
                }
                ++v29;
                --v24;
              }
              while (v24);
              if (v28 <= 1)
              {
                uint64_t v16 = v147;
                if (v28 == 1) {
                  unsigned int v36 = (atomic_uint *)*v26;
                }
                else {
                  unsigned int v36 = 0;
                }
                unint64_t v12 = v146;
                unsigned int v35 = v144;
                CA::Render::Layer::set_single_sublayer(v9, v36);
              }
              else
              {
                float v34 = CA::Render::Array::new_array((CA::Render::Array *)v28, v26, (CA::Render::Object *const *)1, 0);
                CA::Render::Layer::set_sublayers(v9, v34);
                unint64_t v12 = v146;
                uint64_t v16 = v147;
                unsigned int v35 = v144;
                if (v34 && atomic_fetch_add(v34 + 2, 0xFFFFFFFF) == 1) {
                  (*(void (**)(atomic_uint *))(*(void *)v34 + 16))(v34);
                }
              }
              uint64_t v13 = v142;
              if (v35 >= 0x201) {
                free(v26);
              }
            }
          }
        }
LABEL_49:
        if (v13) {
          *(_DWORD *)(v16 + 84) = 0;
        }
        uint64_t v37 = *(void *)(v9 + 96);
        if (!v37) {
          goto LABEL_69;
        }
        unsigned int v38 = *(_DWORD *)(v37 + 12);
        if (v38 != 43) {
          goto LABEL_69;
        }
        if (v38 >> 8 == 1)
        {
          if (v12)
          {
            uint64_t v40 = CA::Render::Context::lookup_object(*((void *)v12 + 17), *((_DWORD *)v12 + 37), *(void *)(v37 + 16), 0, 0, 0);
            uint64_t v39 = v40;
            if (v40 && !atomic_fetch_add((atomic_uint *volatile)(v40 + 8), 1u))
            {
              uint64_t v39 = 0;
              atomic_fetch_add((atomic_uint *volatile)(v40 + 8), 0xFFFFFFFF);
            }
            goto LABEL_60;
          }
        }
        else if (!(v38 >> 8))
        {
          uint64_t v39 = CA::Render::Context::copy_slot((CA::Render::Context *)*(unsigned int *)(v37 + 16));
LABEL_60:
          unsigned int v38 = *(_DWORD *)(v37 + 12);
LABEL_62:
          uint64_t v41 = *(void *)(v37 + 16);
          CA::Render::Layer::set_contents((CA::Render::Layer *)v9, (CA::Render::Object *)v39);
          if (v38 > 0xFF)
          {
            if (!v39) {
              goto LABEL_69;
            }
          }
          else
          {
            *(_DWORD *)(v9 + 12) |= 0x400u;
            *(_DWORD *)(v16 + 84) = v41;
            if (!v39) {
              goto LABEL_69;
            }
            if (*(unsigned char *)(v39 + 12) == 25) {
              *(_DWORD *)(*(void *)(*(void *)(v39 + 16) + 24) + 72) = *((_DWORD *)v12 + 4);
            }
          }
          if (atomic_fetch_add((atomic_uint *volatile)(v39 + 8), 0xFFFFFFFF) == 1) {
            (*(void (**)(uint64_t))(*(void *)v39 + 16))(v39);
          }
LABEL_69:
          int v42 = *(CA::Render::LayerNode **)(v16 + 16);
          if (v42 && v148 == v10)
          {
            CA::Render::Layer::copy_properties((CA::Render::Layer *)v9, (size_t)v42, v13, v15);
            if ((*(unsigned char *)(v16 + 98) & 8) == 0) {
              CA::Render::Layer::set_animations(v9, *(atomic_uint **)(*(void *)(v16 + 16) + 136));
            }
            int v42 = *(CA::Render::LayerNode **)(v16 + 16);
          }
          if (!v42 || (*(unsigned char *)(v16 + 98) & 8) != 0)
          {
            uint64_t v43 = *(void *)(v16 + 48);
            if (!v43) {
              goto LABEL_93;
            }
            int v44 = *((_DWORD *)v12 + 3);
            uint64_t v45 = -1;
            do
            {
              uint64_t v46 = v45;
              uint64_t v43 = *(void *)(v43 + 8);
              ++v45;
            }
            while (v43);
            if (v46 != -2 && (int v47 = CA::Render::Array::new_array((CA::Render::Array *)(v46 + 2), 0, 0, 0)) != 0)
            {
              int v48 = v47;
              if ((v44 & 0x800) != 0) {
                uint64_t v49 = -1;
              }
              else {
                uint64_t v49 = 1;
              }
              int v50 = *(uint64_t **)(v16 + 48);
              if (v50)
              {
                if ((v44 & 0x800) != 0) {
                  uint64_t v51 = v45;
                }
                else {
                  uint64_t v51 = 0;
                }
                do
                {
                  uint64_t v52 = *v50;
                  if (*v50)
                  {
                    uint64_t v53 = (atomic_uint *)(v52 + 8);
                    if (!atomic_fetch_add((atomic_uint *volatile)(v52 + 8), 1u))
                    {
                      uint64_t v52 = 0;
                      atomic_fetch_add(v53, 0xFFFFFFFF);
                    }
                  }
                  *(void *)&v47[2 * v51 + 6] = v52;
                  v51 += v49;
                  int v50 = (uint64_t *)v50[1];
                }
                while (v50);
              }
              CA::Render::Layer::set_animations(v9, v47);
              if (atomic_fetch_add(v48 + 2, 0xFFFFFFFF) == 1) {
                (*(void (**)(atomic_uint *))(*(void *)v48 + 16))(v48);
              }
            }
            else
            {
LABEL_93:
              CA::Render::Layer::set_animations(v9, 0);
            }
            *(void *)(v16 + 96) &= ~0x80000uLL;
          }
          if ((v13 & 2) != 0)
          {
            uint64_t v73 = *(void *)(v16 + 16);
            if (v73)
            {
              uint64_t v74 = *(void *)(v73 + 104);
              if ((*(unsigned char *)(v73 + 13) & 0x20) != 0)
              {
                if (v74)
                {
                  uint64_t v78 = *(void *)(v74 + 144);
                  if (v78)
                  {
                    if (*(CA::Render::Object **)(v78 + 32) == v11) {
                      *(void *)(v78 + 32) = 0;
                    }
                  }
                }
              }
              else if (v74)
              {
                uint64_t v75 = *(unsigned int *)(v74 + 16);
                if (v75)
                {
                  uint64_t v76 = v74 + 24;
                  do
                  {
                    uint64_t v77 = *(void *)(*(void *)v76 + 144);
                    if (v77 && *(CA::Render::Object **)(v77 + 32) == v11) {
                      *(void *)(v77 + 32) = 0;
                    }
                    v76 += 8;
                    --v75;
                  }
                  while (v75);
                }
              }
            }
            uint64_t v79 = *(void *)(v9 + 104);
            if ((*(unsigned char *)(v9 + 13) & 0x20) != 0)
            {
              if (v79)
              {
                uint64_t v83 = *(void *)(v79 + 144);
                if (v83) {
                  *(void *)(v83 + 32) = v11;
                }
              }
            }
            else if (v79)
            {
              uint64_t v80 = *(unsigned int *)(v79 + 16);
              if (v80)
              {
                uint64_t v81 = v79 + 24;
                do
                {
                  uint64_t v82 = *(void *)(*(void *)v81 + 144);
                  if (v82) {
                    *(void *)(v82 + 32) = v11;
                  }
                  v81 += 8;
                  --v80;
                }
                while (v80);
              }
            }
          }
          if ((v13 & 4) != 0)
          {
            uint64_t v54 = *(void *)(v16 + 16);
            if (v54)
            {
              uint64_t v55 = *(void *)(v54 + 112);
              if (v55)
              {
                uint64_t v56 = *(void *)(v55 + 144);
                if (*(CA::Render::Object **)(v56 + 32) == v11) {
                  *(void *)(v56 + 32) = 0;
                }
              }
            }
            uint64_t v57 = *(void *)(v9 + 112);
            if (v57) {
              *(void *)(*(void *)(v57 + 144) + 32) = v11;
            }
          }
          uint64_t v58 = *(void *)(v16 + 40);
          if (v58)
          {
            *(void *)(v58 + 40) = 0;
            if (atomic_fetch_add((atomic_uint *volatile)(v58 + 16), 0xFFFFFFFF) == 1) {
              CA::Render::LayerNode::delete_node((CA::Render::LayerNode *)v58, v42);
            }
            *(void *)(v16 + 40) = 0;
          }
          int v59 = *(void **)(v9 + 128);
          if (v59 && *v59) {
            CA::Render::Layer::ensure_ext((CA::Render::Layer *)v9);
          }
          int v60 = v13 & 0x1FFFF9;
          if ((v13 & 0x1FFFF9) != 0) {
            uint64_t v61 = 0x100000000007;
          }
          else {
            uint64_t v61 = 0x100000000004;
          }
          if (v60)
          {
            int v62 = v13;
            if ((v13 & 1) == 0) {
              goto LABEL_157;
            }
            uint64_t v63 = *(void *)(v9 + 96);
            if (v63)
            {
              uint64_t v64 = (*(uint64_t (**)(uint64_t))(*(void *)v63 + 80))(v63);
              if (v64)
              {
                int v65 = (CA::Render::Texture *)v64;
                unsigned int v66 = *(CA::Shape **)(v64 + 40);
                if (v60 == 1 && v66)
                {
                  uint64_t v67 = v13;
                  uint64_t v68 = *(void *)(v147 + 16);
                  if (v68)
                  {
                    uint64_t v69 = *(void *)(v68 + 96);
                    if (v69)
                    {
                      uint64_t v70 = (*(uint64_t (**)(uint64_t))(*(void *)v69 + 80))(v69);
                      if (v70)
                      {
                        int v71 = *(CA::Shape **)(v70 + 40);
                        if (v71)
                        {
                          int v72 = (CA::Shape *)CA::Shape::Union(*(void *)(v70 + 40), (uint64_t)v66);
                          CA::Render::Texture::set_dirty_shape(v65, v72);
                          if (!CA::Shape::is_valid(v72))
                          {
                            if (x_log_hook_p())
                            {
                              CA::Shape::is_valid(v66);
                              CA::Shape::is_valid(v71);
                              x_log_();
                            }
                            else
                            {
                              uint64_t v126 = x_log_category_render;
                              if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_FAULT))
                              {
                                BOOL is_valid = CA::Shape::is_valid(v66);
                                BOOL v128 = CA::Shape::is_valid(v71);
                                LODWORD(v151) = 67109376;
                                DWORD1(v151) = is_valid;
                                WORD4(v151) = 1024;
                                *(_DWORD *)((char *)&v151 + 10) = v128;
                                _os_log_impl(&dword_184668000, v126, OS_LOG_TYPE_FAULT, "Shape union is bogus, new shape: %d, old shape: %d!", (uint8_t *)&v151, 0xEu);
                              }
                            }
                            CA::Render::Texture::set_dirty_shape(v65, (CA::Shape *)&CA::Shape::_infinite_shape);
                          }
                          if (v72) {
                            CA::Shape::unref(v72);
                          }
                        }
                      }
                    }
                  }
                  uint64_t v13 = v67;
                  int v62 = v67 & 0xFFFFFFFE;
                  uint64_t v61 = 0x100000000014;
LABEL_157:
                  if ((v62 & 0x5FE78) != 0) {
                    v61 |= 8uLL;
                  }
                  if ((v13 & 4) != 0) {
                    v61 |= 0xBuLL;
                  }
                  if ((v62 & 0xBF3D3) != 0) {
                    v61 |= 0x10uLL;
                  }
                  if ((v62 & 0xFFFFB) != 0) {
                    uint64_t v84 = v61 | 0x10000000;
                  }
                  else {
                    uint64_t v84 = v61;
                  }
                  if ((v13 & 2) != 0)
                  {
                    uint64_t v85 = v84 | 0x2000008;
                    uint64_t v86 = v147;
                    if ((~(*(_DWORD *)(v147 + 96) | v84) & 3) == 0)
                    {
                      v84 |= 0x2000008uLL;
LABEL_253:
                      *(void *)(v86 + 96) |= v84;
                      uint64_t v123 = *(atomic_uint **)(v9 + 144);
                      if (v123 != (atomic_uint *)v86)
                      {
                        if (v123 && atomic_fetch_add(v123 + 2, 0xFFFFFFFF) == 1) {
                          (*(void (**)(atomic_uint *))(*(void *)v123 + 16))(v123);
                        }
                        uint64_t v124 = v86;
                        if (!atomic_fetch_add((atomic_uint *volatile)(v86 + 8), 1u))
                        {
                          uint64_t v124 = 0;
                          atomic_fetch_add((atomic_uint *volatile)(v86 + 8), 0xFFFFFFFF);
                        }
                        *(void *)(v9 + 144) = v124;
                      }
                      uint64_t v125 = *(void **)(v9 + 128);
                      if (v125)
                      {
                        if (*v125) {
                          (*(void (**)(void, CA::Render::Context *, uint64_t, uint64_t, uint64_t))(*(void *)*v125 + 104))(*v125, v12, v9, v86, v13);
                        }
                      }
                      CA::Render::Handle::set_current_layer(v86, (CA::Render::Layer *)v9);
                      return;
                    }
                    uint64_t v87 = *(void *)(v147 + 16);
                    uint64_t v149 = 0;
                    uint64_t v150 = 0;
                    if (v87)
                    {
                      uint64_t v88 = *(void *)(v87 + 104);
                      if ((*(unsigned char *)(v87 + 13) & 0x20) != 0 || !v88)
                      {
                        uint64_t v150 = *(void *)(v87 + 104);
                        int64_t v89 = v88 != 0;
                        if (v88) {
                          int v90 = &v150;
                        }
                        else {
                          int v90 = 0;
                        }
                      }
                      else
                      {
                        int64_t v89 = *(unsigned int *)(v88 + 16);
                        int v90 = (uint64_t *)(v88 + 24);
                      }
                    }
                    else
                    {
                      int64_t v89 = 0;
                      int v90 = 0;
                    }
                    uint64_t v91 = *(void *)(v9 + 104);
                    char v92 = *(unsigned char *)(v9 + 13);
                    unsigned int v142 = v13;
                    if ((v92 & 0x20) != 0 || !v91)
                    {
                      uint64_t v149 = v91;
                      int64_t v93 = v91 != 0;
                      if (v91) {
                        unsigned int v94 = &v149;
                      }
                      else {
                        unsigned int v94 = 0;
                      }
                    }
                    else
                    {
                      int64_t v93 = *(unsigned int *)(v91 + 16);
                      unsigned int v94 = (uint64_t *)(v91 + 24);
                    }
                    if (v93 + v89 >= 128) {
                      uint64_t v95 = 128;
                    }
                    else {
                      uint64_t v95 = v93 + v89;
                    }
                    if (v89 >= v93) {
                      int64_t v96 = v93;
                    }
                    else {
                      int64_t v96 = v89;
                    }
                    float64x2_t v138 = v94;
                    int64_t v97 = 0;
                    if (v96)
                    {
                      while (*(void *)(v90[v97] + 144) == *(void *)(v94[v97] + 144))
                      {
                        if (v96 == ++v97)
                        {
                          int64_t v97 = v96;
                          break;
                        }
                      }
                    }
                    if (v97 == v93) {
                      int64_t v98 = v89 - 1;
                    }
                    else {
                      int64_t v98 = v89 + 1;
                    }
                    if (v97 == v89) {
                      int64_t v99 = v89 + 1;
                    }
                    else {
                      int64_t v99 = v89 - 1;
                    }
                    if (v97 != v89 || v97 != v93)
                    {
                      if (v89 <= v93) {
                        unint64_t v100 = v93;
                      }
                      else {
                        unint64_t v100 = v89;
                      }
                      if (v100 >= 0x401)
                      {
                        uint64_t v85 = v84 | 0x200000B;
                        goto LABEL_251;
                      }
                      uint64_t v136 = v95;
                      uint64_t v130 = v84 | 0x2000008;
                      uint64_t v134 = v84;
                      *((void *)&v151 + 1) = 0;
                      unint64_t v152 = v154;
                      long long v153 = xmmword_184998060;
                      *(void *)&long long v151 = (char *)&v151 + 8;
                      int64_t v144 = (16 * v100) | 8;
                      *(void *)&long long v145 = x_heap_malloc((uint64_t *)&v151 + 1, v144);
                      uint64_t v101 = x_heap_malloc((uint64_t *)v151, v144);
                      *(void *)(v145 + 8 * v89) = v97;
                      uint64_t v143 = v101;
                      *(void *)(v101 + 8 * v89) = 0;
                      if (!(v93 + v89))
                      {
                        x_heap_free((void ***)v151);
                        uint64_t v122 = v134;
                        goto LABEL_250;
                      }
                      uint64_t v102 = v136;
                      if (v136 <= 1) {
                        uint64_t v102 = 1;
                      }
                      uint64_t v135 = v102;
                      int64_t v133 = -v89;
                      uint64_t v132 = &v138[-v89];
                      BOOL v103 = 1;
                      uint64_t v104 = 1;
                      long long v146 = v12;
                      while (1)
                      {
                        unint64_t v137 = v104;
                        if (v99 <= v98) {
                          break;
                        }
                        int64_t v105 = v99;
LABEL_236:
                        int64_t v99 = v105 - 1;
                        ++v98;
                        uint64_t v104 = v137 + 1;
                        BOOL v103 = v137 < v136;
                        unint64_t v12 = v146;
                        if (v137 == v135)
                        {
LABEL_247:
                          x_heap_free((void ***)v151);
                          uint64_t v122 = v134;
                          uint64_t v85 = v130;
                          if (v103) {
                            goto LABEL_251;
                          }
LABEL_250:
                          uint64_t v85 = v122 | 0x200000B;
                          goto LABEL_251;
                        }
                      }
                      BOOL v131 = v103;
                      uint64_t v141 = v104 + v89;
                      int64_t v144 = v89 - v104;
                      uint64_t v139 = v104 + v89 - 1;
                      uint64_t v140 = v89 - v104 + 1;
                      int64_t v106 = v133 + v99;
                      unsigned int v107 = &v132[v99];
                      int64_t v105 = v99;
                      while (1)
                      {
                        uint64_t v108 = x_heap_malloc_small_((uint64_t *)v151, 0x20uLL);
                        if (v99 == v144) {
                          break;
                        }
                        if (v99 == v141)
                        {
                          int v113 = 0;
                          uint64_t v110 = v139;
                          int64_t v112 = *(void *)(v145 + 8 * v139);
                        }
                        else
                        {
                          uint64_t v110 = v99 + 1;
                          int64_t v111 = *(void *)(v145 + 8 * (v99 + 1));
                          int64_t v112 = *(void *)(v145 + 8 * (v99 - 1));
                          if (v111 >= v112) {
                            goto LABEL_215;
                          }
                          int v113 = 0;
                          uint64_t v110 = v99 - 1;
                        }
LABEL_220:
                        uint64_t v114 = v143;
                        *(void *)uint64_t v108 = *(void *)(v143 + 8 * v110);
                        *(_DWORD *)(v108 + 8) = v113;
                        int64_t v115 = v112 + v99 - v89;
                        *(void *)(v108 + 16) = v112 - 1;
                        *(void *)(v108 + 24) = v115 - 1;
                        *(void *)(v114 + 8 * v99) = v108;
                        if (v112 < v89 && v115 < v93)
                        {
                          do
                          {
                            if (*(void *)(v90[v112] + 144) != *(void *)(v107[v112] + 144)) {
                              break;
                            }
                            if (++v112 >= v89) {
                              break;
                            }
                          }
                          while (v112 + v106 < v93);
                          int64_t v115 = v106 + v112;
                        }
                        *(void *)(v145 + 8 * v99) = v112;
                        if (v112 == v89 && v115 == v93)
                        {
                          uint64_t v118 = 0;
                          do
                          {
                            uint64_t v119 = v108;
                            uint64_t v108 = *(void *)v108;
                            *(void *)uint64_t v119 = v118;
                            uint64_t v118 = v119;
                          }
                          while (v108);
                          unint64_t v12 = v146;
                          uint64_t v120 = v138;
                          do
                          {
                            if (*(_DWORD *)(v119 + 8) == 1)
                            {
                              CA::Render::Context::invalidate(*(CA::Render::Context **)(v147 + 24), (int32x2_t *)(*(void *)(v90[*(void *)(v119 + 16)] + 144) + 112), v109);
                            }
                            else
                            {
                              uint64_t v121 = *(void *)(v120[*(void *)(v119 + 24)] + 144);
                              if (v121) {
                                *(void *)(v121 + 96) |= 2uLL;
                              }
                            }
                            uint64_t v119 = *(void *)v119;
                          }
                          while (v119);
                          LOBYTE(v103) = v131;
                          goto LABEL_247;
                        }
                        int64_t v117 = v99 + 2;
                        if (v112 == v89) {
                          int64_t v105 = v99 + 2;
                        }
                        if (v115 == v93) {
                          int64_t v98 = v99 - 2;
                        }
                        v106 += 2;
                        v107 += 2;
                        v99 += 2;
                        if (v117 > v98) {
                          goto LABEL_236;
                        }
                      }
                      uint64_t v110 = v140;
                      int64_t v111 = *(void *)(v145 + 8 * v140);
LABEL_215:
                      int64_t v112 = v111 + 1;
                      int v113 = 1;
                      goto LABEL_220;
                    }
LABEL_251:
                    uint64_t v84 = v85;
                    uint64_t v13 = v142;
                  }
                  uint64_t v86 = v147;
                  goto LABEL_253;
                }
                if (v66)
                {
                  CA::Shape::unref(*(CA::Shape **)(v64 + 40));
                  *((void *)v65 + 5) = 0;
                }
              }
            }
            uint64_t v61 = 0x100000000007;
          }
          int v62 = v13;
          goto LABEL_157;
        }
        uint64_t v39 = 0;
        goto LABEL_62;
      }
    }
    if (atomic_fetch_add((atomic_uint *volatile)(v9 + 8), 0xFFFFFFFF) == 1) {
      (*(void (**)(uint64_t))(*(void *)v9 + 16))(v9);
    }
  }
  else
  {
    unint64_t v21 = (CA::Render::Context *)((char *)v4 + 136);
    CA::Render::Context::ResourceTable::insert(v21, v5, v6, v7);
  }
}

void CA::Render::LayerNode::delete_node(CA::Render::LayerNode *this, CA::Render::LayerNode *a2)
{
  long long v2 = this;
  long long v3 = 0;
  uint64_t v4 = 0;
  *((void *)this + 11) = 0;
  do
  {
    long long v5 = v2;
    int v6 = (atomic_uint *)*((void *)v2 + 11);
    long long v7 = (atomic_uint *)*((void *)v2 + 13);
    if (v7 != (atomic_uint *)((char *)v2 + 96))
    {
      do
      {
        uint64_t v8 = (atomic_uint *)*((void *)v7 + 1);
        if (v8 == v7) {
          break;
        }
        *((void *)v7 + 11) = 0;
        uint64_t v9 = *(void *)v7;
        *(void *)(v9 + 8) = v8;
        *(void *)uint64_t v8 = v9;
        *(void *)long long v7 = v7;
        *((void *)v7 + 1) = v7;
        if (atomic_fetch_add(v7 + 4, 0xFFFFFFFF) == 1)
        {
          *((void *)v7 + 11) = v6;
          int v6 = v7;
        }
        long long v7 = v8;
      }
      while (v8 != (atomic_uint *)((char *)v2 + 96));
    }
    int v10 = (atomic_uint *)*((void *)v2 + 16);
    if (v10 && (*((void *)v10 + 11) = 0, atomic_fetch_add(v10 + 4, 0xFFFFFFFF) == 1)) {
      *((void *)v10 + 11) = v6;
    }
    else {
      int v10 = v6;
    }
    long long v2 = (CA::Render::LayerNode *)*((void *)v2 + 17);
    if (v2 && (*((void *)v2 + 11) = 0, atomic_fetch_add((atomic_uint *volatile)v2 + 4, 0xFFFFFFFF) == 1)) {
      *((void *)v2 + 11) = v10;
    }
    else {
      long long v2 = (CA::Render::LayerNode *)v10;
    }
    uint64_t v11 = (atomic_uint *)*((void *)v5 + 6);
    if (v11 && atomic_fetch_add(v11 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *, CA::Render::LayerNode *))(*(void *)v11 + 16))(v11, a2);
    }
    unint64_t v12 = (CA::Shape *)*((void *)v5 + 26);
    if (v12) {
      CA::Shape::unref(v12);
    }
    uint64_t v13 = (CA::Shape *)*((void *)v5 + 27);
    if (v13) {
      CA::Shape::unref(v13);
    }
    uint64_t v14 = (CA::Shape *)*((void *)v5 + 28);
    if (v14) {
      CA::Shape::unref(v14);
    }
    __n128 v15 = (CA::Shape *)*((void *)v5 + 29);
    if (v15) {
      CA::Shape::unref(v15);
    }
    uint64_t v16 = (void *)*((void *)v5 + 7);
    if (v16)
    {
      *uint64_t v16 = v3;
      long long v3 = (void *)*((void *)v5 + 7);
    }
    int v17 = (void *)*((void *)v5 + 18);
    if (v17)
    {
      *int v17 = v3;
      long long v3 = (void *)*((void *)v5 + 18);
    }
    uint64_t v18 = (atomic_uint *)*((void *)v5 + 4);
    if (v18 && atomic_fetch_add(v18 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *, CA::Render::LayerNode *))(*(void *)v18 + 16))(v18, a2);
    }
    int v19 = (atomic_uint *)*((void *)v5 + 15);
    if (v19 && atomic_fetch_add(v19 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *, CA::Render::LayerNode *))(*(void *)v19 + 16))(v19, a2);
    }
    uint64_t v20 = *((void *)v5 + 5);
    if (v20) {
      *(void *)(v20 + 40) = 0;
    }
    unint64_t v21 = (atomic_uint *)*((void *)v5 + 32);
    if (v21 && atomic_fetch_add(v21 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *, CA::Render::LayerNode *))(*(void *)v21 + 16))(v21, a2);
    }
    unsigned int v22 = (atomic_uint *)*((void *)v5 + 33);
    if (v22 && atomic_fetch_add(v22 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *, CA::Render::LayerNode *))(*(void *)v22 + 16))(v22, a2);
    }
    uint64_t v23 = (void *)*((void *)v5 + 19);
    if (v23)
    {
      do
      {
        unint64_t v24 = (void *)*v23;
        free(v23);
        uint64_t v23 = v24;
      }
      while (v24);
    }
    *((void *)v5 + 11) = v4;
    uint64_t v4 = v5;
  }
  while (v2);
  do
  {
    while (1)
    {
      size_t v25 = v5;
      long long v5 = (CA::Render::LayerNode *)*((void *)v5 + 11);
      *(void *)&long long v26 = 0x2222222222222222;
      *((void *)&v26 + 1) = 0x2222222222222222;
      *(_OWORD *)size_t v25 = v26;
      *((_OWORD *)v25 + 1) = v26;
      *((_OWORD *)v25 + 2) = v26;
      *((_OWORD *)v25 + 3) = v26;
      *((_OWORD *)v25 + 6) = v26;
      *((_OWORD *)v25 + 7) = v26;
      *((_OWORD *)v25 + 8) = v26;
      *((_OWORD *)v25 + 9) = v26;
      *((_OWORD *)v25 + 10) = v26;
      *((_OWORD *)v25 + 11) = v26;
      *((_OWORD *)v25 + 12) = v26;
      *((_OWORD *)v25 + 13) = v26;
      *((_OWORD *)v25 + 14) = v26;
      *((_OWORD *)v25 + 15) = v26;
      *((_OWORD *)v25 + 16) = v26;
      *((void *)v25 + 34) = 0x2222222222222222;
      *((_OWORD *)v25 + 4) = v26;
      *((_OWORD *)v25 + 5) = v26;
      if (CA::Render::LayerNodeAllocator::_data <= (unint64_t)v25)
      {
        unint64_t v27 = 0xAF8AF8AF8AF8AF8BLL * (((uint64_t)v25 - CA::Render::LayerNodeAllocator::_data) >> 3);
        if (v27 < 0x1000) {
          break;
        }
      }
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(malloc_zone, v25);
      if (!v5) {
        goto LABEL_52;
      }
    }
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::LayerNodeAllocator::_lock);
    uint64_t v29 = CA::Render::LayerNodeAllocator::_free_offsets_count++;
    *(_WORD *)(CA::Render::LayerNodeAllocator::_free_offsets + 2 * v29) = v27;
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::LayerNodeAllocator::_lock);
  }
  while (v5);
LABEL_52:
  if (v3)
  {
    do
    {
      uint64_t v30 = (void *)*v3;
      free(v3);
      long long v3 = v30;
    }
    while (v30);
  }
}

CA::Render::Object *CA::Render::Context::lookup_handle(CA::Render::Context *this, CA::Render::Object *a2, int a3, int a4, unsigned int *a5)
{
  uint64_t v8 = (CA::Render::Context *)((char *)this + 136);
  unint64_t v9 = (((unint64_t)a2 ^ 0x8000000000000000) + ~((void)a2 << 32)) ^ ((((unint64_t)a2 ^ 0x8000000000000000)
                                                                               + ~((void)a2 << 32)) >> 22);
  unint64_t v10 = 9 * ((v9 + ~(v9 << 13)) ^ ((v9 + ~(v9 << 13)) >> 8));
  unint64_t v11 = (v10 ^ (v10 >> 15)) + ~((v10 ^ (v10 >> 15)) << 27);
  uint64_t v12 = *((void *)this + 17) + 8 * (*((_DWORD *)this + 37) & ((v11 >> 31) ^ v11));
  do
  {
    uint64_t v12 = *(void *)v12;
    if (!v12)
    {
      if (a5) {
        *a5 = 0;
      }
LABEL_17:
      if (!a4) {
        return 0;
      }
      goto LABEL_18;
    }
  }
  while (*(void *)(v12 + 8) != ((unint64_t)a2 ^ 0x8000000000000000));
  if (a5) {
    *a5 = *(_DWORD *)(v12 + 24);
  }
  if (a3) {
    *(_DWORD *)(v12 + 24) = a3;
  }
  uint64_t v13 = *(unsigned __int8 **)(v12 + 16);
  if (!v13) {
    goto LABEL_17;
  }
  int v14 = v13[12];
  if (v14 == 22) {
    __n128 v15 = (CA::Render::Object *)v13;
  }
  else {
    __n128 v15 = 0;
  }
  if (v14 != 22 && (a4 & 1) != 0)
  {
LABEL_18:
    if ((*((unsigned char *)this + 13) & 4) == 0)
    {
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      int v17 = (CA::Render::Object *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x80uLL, 0x743898A5uLL);
      __n128 v15 = v17;
      if (v17)
      {
        *((_DWORD *)v17 + 2) = 1;
        *((_DWORD *)v17 + 3) = 22;
        ++dword_1EB2ADE20;
        *(void *)int v17 = &unk_1ED02F600;
        *((void *)v17 + 9) = 0;
        *((void *)v17 + 14) = 0;
        *((void *)v17 + 15) = 0;
        *((void *)v17 + 2) = 0;
        *((void *)v17 + 3) = this;
        uint64_t v18 = v8;
        int v19 = a2;
        int v20 = a3;
        unint64_t v21 = v15;
      }
      else
      {
        MEMORY[0x18] = this;
        uint64_t v18 = v8;
        int v19 = a2;
        int v20 = a3;
        unint64_t v21 = 0;
      }
      CA::Render::Context::ResourceTable::insert(v18, v19, v20, v21);
      return v15;
    }
    return 0;
  }
  return v15;
}

uint64_t CA::Render::ImageQueue::texture_cast(CA::Render::ImageQueue *this)
{
  uint64_t result = *((void *)this + 8);
  if (!result)
  {
    uint64_t result = *((void *)this + 10);
    if (!result) {
      return *((void *)this + 3);
    }
  }
  return result;
}

uint64_t CA::Render::Handle::set_current_layer(uint64_t this, CA::Render::Layer *a2)
{
  long long v2 = *(CA::Render::Layer **)(this + 16);
  if (v2 != a2)
  {
    *(void *)(this + 16) = a2;
    this = CA::Render::Handle::update_container_state(this, (const double *)a2);
    a2 = v2;
  }
  if (a2 && atomic_fetch_add((atomic_uint *volatile)a2 + 2, 0xFFFFFFFF) == 1)
  {
    long long v3 = *(uint64_t (**)(CA::Render::Layer *))(*(void *)a2 + 16);
    return v3(a2);
  }
  return this;
}

uint64_t CA::Render::Handle::update_container_state(uint64_t this, const double *a2)
{
  uint64_t v2 = *(void *)(this + 16);
  if (v2)
  {
    if ((*(unsigned char *)(this + 13) & 1) != 0 || *(void *)(this + 56) || *(void *)(this + 64)) {
      unsigned int v3 = *(_DWORD *)(v2 + 12) | 0x1000;
    }
    else {
      unsigned int v3 = *(_DWORD *)(v2 + 12) & 0xFFFFEFFF;
    }
    *(_DWORD *)(v2 + 12) = v3;
    uint64_t v4 = *(void *)(this + 16);
    int v5 = *(_DWORD *)(v4 + 12);
    if ((v5 & 0x1000) != 0
      || (this = CA::Render::Layer::is_containerable(*(CA::Render::Layer **)(this + 16), a2), !this))
    {
      unsigned int v6 = v5 & 0xFFFFF7FF;
    }
    else
    {
      unsigned int v6 = v5 | 0x800;
    }
    *(_DWORD *)(v4 + 12) = v6;
  }
  return this;
}

BOOL CA::Render::Layer::is_containerable(CA::Render::Layer *this, const double *a2)
{
  if (*((void *)this + 12)) {
    return 0;
  }
  uint64_t v3 = *((void *)this + 5);
  if ((v3 & 0x40000000000) != 0) {
    return 0;
  }
  if (*((unsigned char *)this + 33)) {
    return 0;
  }
  uint64_t v5 = *((void *)this + 16);
  if (v5)
  {
    if (*(float *)(v5 + 320) != 0.0) {
      return 0;
    }
  }
  BOOL result = 0;
  if ((v3 & 0x10C0000) != 0 || *((void *)this + 14)) {
    return result;
  }
  if (*((unsigned __int8 *)this + 32) != 255 && *((unsigned char *)this + 32) || (v3 & 0x208088000000) != 0x80000000) {
    return 0;
  }
  BOOL result = 0;
  if ((~(_WORD)v3 & 0xC00) != 0 || (*((_DWORD *)this + 9) & 0x7FF00000) != 0) {
    return result;
  }
  if (!v5) {
    goto LABEL_38;
  }
  if (*(float *)(v5 + 236) > 0.0) {
    return 0;
  }
  if (*(void *)v5) {
    return 0;
  }
  if (*(void *)(v5 + 96)) {
    return 0;
  }
  if (*(void *)(v5 + 88)) {
    return 0;
  }
  if (*(void *)(v5 + 104)) {
    return 0;
  }
  uint64_t v6 = *((void *)this + 16);
  if (*(void *)(v5 + 112) || *(void *)(v5 + 80)) {
    return 0;
  }
  uint64_t v7 = *(void *)(v5 + 16);
  if (v7)
  {
    unsigned int v8 = *(_DWORD *)(v7 + 16);
    unint64_t v9 = (long long *)(v7 + 24);
    unint64_t v10 = (CA::Mat4Impl *)(v8 >= 0x10 ? v9 : &CA::Mat4Impl::mat4_identity_double);
    BOOL result = CA::Mat4Impl::mat4_is_affine(v10, a2);
    if (!result) {
      return result;
    }
  }
  uint64_t v11 = *(void *)(v6 + 24);
  if (v11)
  {
    uint64_t v12 = *(_DWORD *)(v11 + 16) >= 0x10u
        ? (CA::Mat4Impl *)(v11 + 24)
        : (CA::Mat4Impl *)&CA::Mat4Impl::mat4_identity_double;
    BOOL result = CA::Mat4Impl::mat4_is_affine(v12, a2);
    if (!result) {
      return result;
    }
  }
  if (*(double *)(v6 + 192) != 0.0 || *(double *)(v6 + 184) != 0.0) {
    return 0;
  }
  if ((v3 & 0x40) != 0)
  {
    BOOL result = 0;
    if (*(float *)(v6 + 228) != 0.0 || v11) {
      return result;
    }
  }
LABEL_38:
  uint64_t v13 = *((void *)this + 17);
  if (v13)
  {
    uint64_t v14 = *(unsigned int *)(v13 + 16);
    if (v14)
    {
      uint64_t v15 = v13 + 24;
      uint64_t v16 = 8 * v14;
      while (*(unsigned char *)(*(void *)v15 + 12) != 55)
      {
        v15 += 8;
        v16 -= 8;
        if (!v16) {
          goto LABEL_43;
        }
      }
      return 0;
    }
  }
LABEL_43:
  int v17 = (unsigned int *)*((void *)this + 13);
  if ((*((unsigned char *)this + 13) & 0x20) == 0)
  {
    if (v17)
    {
      uint64_t v18 = v17[4];
      if (v18)
      {
        int v19 = (CA::Render::Layer **)(v17 + 6);
        uint64_t v20 = 8 * v18;
        while (CA::Render::Layer::sublayer_allows_containerization(this, *v19))
        {
          ++v19;
          v20 -= 8;
          if (!v20) {
            return 1;
          }
        }
        return 0;
      }
    }
    return 1;
  }
  if (!v17) {
    return 1;
  }
  BOOL result = CA::Render::Layer::sublayer_allows_containerization(this, (CA::Render::Layer *)v17);
  if (result) {
    return 1;
  }
  return result;
}

BOOL CA::Render::Layer::sublayer_allows_containerization(CA::Render::Layer *this, CA::Render::Layer *a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if ((*((unsigned char *)a2 + 13) & 9) != 0) {
    return 0;
  }
  uint64_t v4 = *((void *)this + 5);
  if ((v4 & 0x40) != 0)
  {
    uint64_t v15 = *((void *)a2 + 5);
    if ((v15 & 0x40) == 0) {
      return 0;
    }
    uint64_t v5 = *((void *)a2 + 16);
    if (v5)
    {
      if (*(void *)(v5 + 16)) {
        return 0;
      }
      double v17 = *((double *)a2 + 6);
      double v16 = *((double *)a2 + 7);
      double v18 = *((double *)a2 + 11);
      double v23 = *((double *)a2 + 10);
      double v24 = v18;
      double v19 = *(double *)(v5 + 176);
      double v20 = *(double *)(v5 + 168) * v23;
    }
    else
    {
      double v17 = *((double *)a2 + 6);
      double v16 = *((double *)a2 + 7);
      double v21 = *((double *)a2 + 10);
      double v18 = *((double *)a2 + 11);
      double v23 = v21;
      double v24 = v18;
      double v19 = 0.0;
      if ((v15 & 0x400000000000) == 0) {
        double v19 = 0.5;
      }
      double v20 = v21 * v19;
    }
    v22[0] = v17 - v20;
    v22[1] = v16 - v19 * v18;
    BOOL result = CA::BoundsImpl::contains((double *)this + 8, v22);
    if (!result) {
      return result;
    }
  }
  else
  {
    uint64_t v5 = *((void *)a2 + 16);
  }
  if (!v5)
  {
LABEL_16:
    uint64_t v10 = *((void *)a2 + 17);
    if (!v10) {
      return 1;
    }
    uint64_t v11 = *(unsigned int *)(v10 + 16);
    if (!v11) {
      return 1;
    }
    uint64_t v12 = v10 + 24;
    uint64_t v13 = 8 * v11;
    BOOL result = 1;
    while (1)
    {
      int v14 = *(_DWORD *)(*(void *)v12 + 12);
      if ((v14 & 0x40000) != 0 || (v14 & 0x1000) != 0 && (v4 & 0x40) != 0) {
        break;
      }
      v12 += 8;
      v13 -= 8;
      if (!v13) {
        return result;
      }
    }
    return 0;
  }
  if (*(void *)(v5 + 88) || *(void *)(v5 + 104)) {
    return 0;
  }
  uint64_t v6 = *(void *)(v5 + 16);
  if (!v6
    || ((v7 = *(_DWORD *)(v6 + 16), unsigned int v8 = (CA::Mat4Impl *)(v6 + 24), v7 >= 0x10)
      ? (unint64_t v9 = v8)
      : (unint64_t v9 = (CA::Mat4Impl *)&CA::Mat4Impl::mat4_identity_double),
        BOOL result = CA::Mat4Impl::mat4_is_affine(v9, (const double *)a2)))
  {
    if (*(double *)(v5 + 192) == 0.0 && *(double *)(v5 + 184) == 0.0) {
      goto LABEL_16;
    }
    return 0;
  }
  return result;
}

atomic_uint *CA::Render::Layer::set_animations(uint64_t a1, atomic_uint *a2)
{
  BOOL result = *(atomic_uint **)(a1 + 136);
  if (result != a2)
  {
    uint64_t v4 = a2;
    if (result && atomic_fetch_add(result + 2, 0xFFFFFFFF) == 1) {
      BOOL result = (atomic_uint *)(*(uint64_t (**)(atomic_uint *))(*(void *)result + 16))(result);
    }
    if (v4)
    {
      uint64_t v5 = v4 + 2;
      if (!atomic_fetch_add(v4 + 2, 1u))
      {
        uint64_t v4 = 0;
        atomic_fetch_add(v5, 0xFFFFFFFF);
      }
    }
    *(void *)(a1 + 136) = v4;
  }
  return result;
}

CA::Render::Layer *CA::Render::Layer::Layer(CA::Render::Layer *this, CA::Render::Decoder *a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  *(void *)this = &unk_1ED02F670;
  *((_DWORD *)this + 2) = 1;
  *((_DWORD *)this + 3) = (CA::Render::Decoder::decode_int32(a2) << 8) | 0x1D;
  ++dword_1EB2ADE3C;
  *(void *)this = &unk_1ED02F440;
  CA::Render::Decoder::decode_bytes(a2, (char *)this + 16, 0x50uLL);
  *((void *)this + 12) = CA::Render::Decoder::decode_object(a2, 11, (uint64_t)CA::Render::contents_types);
  __dst[0] = 29;
  *((void *)this + 13) = CA::Render::Decoder::decode_array_object(a2, 1, __dst, 1);
  *((void *)this + 14) = CA::Render::Decoder::decode_size_t(a2);
  *((void *)this + 15) = CA::Render::Decoder::decode_object(a2, 49);
  if (CA::Render::Decoder::decode_int8(a2))
  {
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    uint64_t v5 = (char *)malloc_type_zone_malloc(malloc_zone, 0x150uLL, 0x8BB15036uLL);
    if (v5)
    {
      *(void *)uint64_t v5 = CA::Render::Decoder::decode_object(a2, 14, (uint64_t)&CA::Render::subclass_types);
      *((void *)v5 + 1) = CA::Render::Decoder::decode_object(a2, 52);
      *((void *)v5 + 2) = CA::Render::Decoder::decode_object(a2, 56);
      *((void *)v5 + 3) = CA::Render::Decoder::decode_object(a2, 56);
      *((void *)v5 + 4) = CA::Render::Decoder::decode_object(a2, 56);
      *((void *)v5 + 5) = CA::Render::Decoder::decode_object(a2, 56);
      *((void *)v5 + 6) = CA::Render::Decoder::decode_object(a2, 56);
      *((void *)v5 + 7) = CA::Render::Decoder::decode_object(a2, 11, (uint64_t)CA::Render::contents_types);
      *((void *)v5 + 8) = CA::Render::Decoder::decode_object(a2, 56);
      *((void *)v5 + 9) = CA::Render::Decoder::decode_object(a2, 56);
      *((void *)v5 + 10) = CA::Render::Decoder::decode_object(a2, 37);
      *((void *)v5 + 11) = CA::Render::Decoder::decode_object(a2, 17);
      __dst[0] = 17;
      *((void *)v5 + 12) = CA::Render::Decoder::decode_array_object(a2, 1, __dst, 0);
      __dst[0] = 17;
      *((void *)v5 + 13) = CA::Render::Decoder::decode_array_object(a2, 1, __dst, 0);
      *((void *)v5 + 14) = CA::Render::Decoder::decode_object(a2, 33);
      *((void *)v5 + 15) = CA::Render::Decoder::decode_object(a2, 36);
      *((void *)v5 + 16) = CA::Render::Decoder::decode_object(a2, 37);
      __dst[0] = 42;
      *((void *)v5 + 17) = CA::Render::Decoder::decode_array_object(a2, 1, __dst, 0);
      *((void *)v5 + 18) = 0;
      *(_OWORD *)long long __dst = 0uLL;
      CA::Render::Decoder::decode_bytes(a2, __dst, 0x10uLL);
      *(_OWORD *)(v5 + 152) = *(_OWORD *)__dst;
      *(_OWORD *)long long __dst = 0uLL;
      CA::Render::Decoder::decode_bytes(a2, __dst, 0x10uLL);
      *(_OWORD *)(v5 + 168) = *(_OWORD *)__dst;
      *((void *)v5 + 23) = CA::Render::Decoder::decode_int64(a2);
      *((void *)v5 + 24) = CA::Render::Decoder::decode_int64(a2);
      *(_OWORD *)long long __dst = 0uLL;
      CA::Render::Decoder::decode_bytes(a2, __dst, 0x10uLL);
      *(_OWORD *)(v5 + 200) = *(_OWORD *)__dst;
      *(void *)long long __dst = 0;
      CA::Render::Decoder::decode_bytes(a2, __dst, 8uLL);
      *((void *)v5 + 27) = *(void *)__dst;
      *((_DWORD *)v5 + 56) = CA::Render::Decoder::decode_int32(a2);
      *((_DWORD *)v5 + 57) = CA::Render::Decoder::decode_int32(a2);
      *((_DWORD *)v5 + 58) = CA::Render::Decoder::decode_int32(a2);
      *((_DWORD *)v5 + 59) = CA::Render::Decoder::decode_int32(a2);
      *(_OWORD *)long long __dst = 0uLL;
      CA::Render::Decoder::decode_bytes(a2, __dst, 0x10uLL);
      *((_OWORD *)v5 + 15) = *(_OWORD *)__dst;
      *((_DWORD *)v5 + 64) = CA::Render::Decoder::decode_int32(a2);
      *((_DWORD *)v5 + 65) = CA::Render::Decoder::decode_int32(a2);
      *((_DWORD *)v5 + 66) = CA::Render::Decoder::decode_int32(a2);
      *(_OWORD *)long long __dst = 0uLL;
      CA::Render::Decoder::decode_bytes(a2, __dst, 0x10uLL);
      *(_OWORD *)(v5 + 268) = *(_OWORD *)__dst;
      *((_DWORD *)v5 + 71) = CA::Render::Decoder::decode_int32(a2);
      *((_DWORD *)v5 + 72) = CA::Render::Decoder::decode_int32(a2);
      *((_DWORD *)v5 + 73) = CA::Render::Decoder::decode_int32(a2);
      *((_DWORD *)v5 + 74) = CA::Render::Decoder::decode_int32(a2);
      *((_DWORD *)v5 + 75) = CA::Render::Decoder::decode_int32(a2);
      *(_OWORD *)long long __dst = 0uLL;
      CA::Render::Decoder::decode_bytes(a2, __dst, 0x10uLL);
      *((_OWORD *)v5 + 19) = *(_OWORD *)__dst;
      *((_DWORD *)v5 + 80) = CA::Render::Decoder::decode_int32(a2);
      unsigned int v6 = CA::Render::Decoder::decode_int8(a2);
      if (v6 >= 2)
      {
        CA::Render::Decoder::set_fatal_error(a2, "%s - enum %u out of range of %u", "decode_int8_enum", v6, 2);
        LOBYTE(v6) = 0;
      }
      v5[324] = v5[324] & 0xFE | v6;
      *((_DWORD *)v5 + 82) = 1;
      uint64_t v7 = *((void *)v5 + 2);
      if (v7)
      {
        unsigned int v8 = *(_DWORD *)(v7 + 16);
        if (v8 <= 0xF)
        {
          CA::Render::Decoder::set_fatal_error(a2, "%s - transform size %u", "Ext", v8);
          unint64_t v9 = (atomic_uint *)*((void *)v5 + 2);
          if (v9)
          {
            if (atomic_fetch_add(v9 + 2, 0xFFFFFFFF) == 1) {
              (*(void (**)(atomic_uint *))(*(void *)v9 + 16))(v9);
            }
            *((void *)v5 + 2) = 0;
          }
        }
      }
      uint64_t v10 = *((void *)v5 + 3);
      if (v10)
      {
        unsigned int v11 = *(_DWORD *)(v10 + 16);
        if (v11 <= 0xF)
        {
          CA::Render::Decoder::set_fatal_error(a2, "%s - sublayerTransform size %u", "Ext", v11);
          uint64_t v12 = (atomic_uint *)*((void *)v5 + 3);
          if (v12)
          {
            if (atomic_fetch_add(v12 + 2, 0xFFFFFFFF) == 1) {
              (*(void (**)(atomic_uint *))(*(void *)v12 + 16))(v12);
            }
            *((void *)v5 + 3) = 0;
          }
        }
      }
      uint64_t v13 = *((void *)v5 + 4);
      if (v13)
      {
        unsigned int v14 = *(_DWORD *)(v13 + 16);
        if (v14 <= 5)
        {
          CA::Render::Decoder::set_fatal_error(a2, "%s - contentsTransform size %u", "Ext", v14);
          uint64_t v15 = (atomic_uint *)*((void *)v5 + 4);
          if (v15)
          {
            if (atomic_fetch_add(v15 + 2, 0xFFFFFFFF) == 1) {
              (*(void (**)(atomic_uint *))(*(void *)v15 + 16))(v15);
            }
            *((void *)v5 + 4) = 0;
          }
        }
      }
      uint64_t v16 = *((void *)v5 + 5);
      if (v16)
      {
        unsigned int v17 = *(_DWORD *)(v16 + 16);
        if (v17 <= 3)
        {
          CA::Render::Decoder::set_fatal_error(a2, "%s - contentsRect size %u", "Ext", v17);
          double v18 = (atomic_uint *)*((void *)v5 + 5);
          if (v18)
          {
            if (atomic_fetch_add(v18 + 2, 0xFFFFFFFF) == 1) {
              (*(void (**)(atomic_uint *))(*(void *)v18 + 16))(v18);
            }
            *((void *)v5 + 5) = 0;
          }
        }
      }
      uint64_t v19 = *((void *)v5 + 6);
      if (v19)
      {
        unsigned int v20 = *(_DWORD *)(v19 + 16);
        if (v20 <= 3)
        {
          CA::Render::Decoder::set_fatal_error(a2, "%s - contentsCenter size %u", "Ext", v20);
          double v21 = (atomic_uint *)*((void *)v5 + 6);
          if (v21)
          {
            if (atomic_fetch_add(v21 + 2, 0xFFFFFFFF) == 1) {
              (*(void (**)(atomic_uint *))(*(void *)v21 + 16))(v21);
            }
            *((void *)v5 + 6) = 0;
          }
        }
      }
      uint64_t v22 = *((void *)v5 + 8);
      if (v22)
      {
        unsigned int v23 = *(_DWORD *)(v22 + 16);
        if (v23 <= 3)
        {
          CA::Render::Decoder::set_fatal_error(a2, "%s - cornerContentsCenter size %u", "Ext", v23);
          double v24 = (atomic_uint *)*((void *)v5 + 8);
          if (v24)
          {
            if (atomic_fetch_add(v24 + 2, 0xFFFFFFFF) == 1) {
              (*(void (**)(atomic_uint *))(*(void *)v24 + 16))(v24);
            }
            *((void *)v5 + 8) = 0;
          }
        }
      }
      uint64_t v25 = (os_unfair_lock_s *)*((void *)v5 + 14);
      if (v25 && (CA::Render::MeshTransform::validate(v25) & 1) == 0)
      {
        long long v26 = (atomic_uint *)*((void *)v5 + 14);
        if (v26)
        {
          if (atomic_fetch_add(v26 + 2, 0xFFFFFFFF) == 1) {
            (*(void (**)(atomic_uint *))(*(void *)v26 + 16))(v26);
          }
          *((void *)v5 + 14) = 0;
        }
        CA::Render::Decoder::set_fatal_error(a2, "%s - meshTransform = %p", "Ext", 0);
      }
    }
  }
  else
  {
    uint64_t v5 = 0;
  }
  *((void *)this + 17) = 0;
  *((void *)this + 18) = 0;
  *((void *)this + 16) = v5;
  if ((*((unsigned char *)this + 13) & 2) == 0)
  {
    CA::Render::Decoder::set_fatal_error(a2, "%s - expected sublayer ids", "Layer");
    *((_DWORD *)this + 3) |= 0x200u;
  }
  return this;
}

atomic_uint *CA::Render::Decoder::decode_object(uint64_t a1, uint64_t a2)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 18)) {
    return 0;
  }
  unsigned int v4 = CA::Render::Decoder::decode_int8((CA::Render::Decoder *)a1);
  if (!v4) {
    return 0;
  }
  unsigned int v6 = v4;
  if (v4 < 0xFE)
  {
    if (!a2 || v4 == a2)
    {
      unsigned int v11 = *(CA::Render::Context **)(a1 + 72);
      if ((*((_WORD *)v11 + 276) & 0x100) == 0 || v6 <= 0x38 && ((1 << v6) & 0x1BFC8707EB6022ALL) != 0)
      {
        switch(v6)
        {
          case 1u:
            *(_DWORD *)buf = 0;
            uint64_t v12 = CA::Render::Array::decode((CA::Render::Decoder *)a1, 1, (int *)buf, 0);
            goto LABEL_95;
          case 3u:
            uint64_t v13 = (CA::Render::BackdropLayer *)x_mem_alloc0(0x60uLL);
            if (!v13) {
              goto LABEL_101;
            }
            uint64_t v10 = (atomic_uint *)v13;
            CA::Render::BackdropLayer::BackdropLayer(v13, (CA::Render::Decoder *)a1);
            goto LABEL_96;
          case 5u:
            unsigned int v14 = (CA::Render::BasicAnimation *)x_mem_alloc0(0x98uLL);
            if (!v14) {
              goto LABEL_101;
            }
            uint64_t v10 = (atomic_uint *)v14;
            CA::Render::BasicAnimation::BasicAnimation(v14, (CA::Render::Decoder *)a1);
            goto LABEL_96;
          case 6u:
            if ((*((_WORD *)v11 + 276) & 0x200) == 0) {
              goto LABEL_80;
            }
            uint64_t v15 = (CA::Render::CarPlayRegionLayer *)x_mem_alloc0(0x18uLL);
            if (!v15) {
              goto LABEL_101;
            }
            uint64_t v10 = (atomic_uint *)v15;
            CA::Render::CarPlayRegionLayer::CarPlayRegionLayer(v15, (CA::Render::Decoder *)a1);
            goto LABEL_96;
          case 8u:
            if ((*((_WORD *)v11 + 276) & 0x200) == 0) {
              goto LABEL_80;
            }
            uint64_t v16 = (CA::Render::CloningTerminatorLayer *)x_mem_alloc0(0x10uLL);
            if (!v16) {
              goto LABEL_101;
            }
            uint64_t v10 = (atomic_uint *)v16;
            CA::Render::CloningTerminatorLayer::CloningTerminatorLayer(v16, (CA::Render::Decoder *)a1);
            goto LABEL_96;
          case 9u:
            uint64_t v12 = (atomic_uint *)CA::Render::CompressedImage::decode((CA::Render::CompressedImage *)a1, v5);
            goto LABEL_95;
          case 0xCu:
            unsigned int v17 = (CA::Render::DistanceFieldLayer *)x_mem_alloc0(0x28uLL);
            if (!v17) {
              goto LABEL_101;
            }
            uint64_t v10 = (atomic_uint *)v17;
            CA::Render::DistanceFieldLayer::DistanceFieldLayer(v17, (CA::Render::Decoder *)a1);
            goto LABEL_96;
          case 0xDu:
            double v18 = (CA::Render::EmitterBehavior *)x_mem_alloc0(0x30uLL);
            if (!v18) {
              goto LABEL_101;
            }
            uint64_t v10 = (atomic_uint *)v18;
            CA::Render::EmitterBehavior::EmitterBehavior(v18, (CA::Render::Decoder *)a1);
            goto LABEL_96;
          case 0xEu:
            uint64_t v19 = (CA::Render::EmitterCell *)x_mem_alloc0(0xE8uLL);
            if (!v19) {
              goto LABEL_101;
            }
            uint64_t v10 = (atomic_uint *)v19;
            CA::Render::EmitterCell::EmitterCell(v19, (CA::Render::Decoder *)a1);
            goto LABEL_96;
          case 0xFu:
            unsigned int v20 = (CA::Render::EmitterLayer *)x_mem_alloc0(0xA8uLL);
            if (!v20) {
              goto LABEL_101;
            }
            uint64_t v10 = (atomic_uint *)v20;
            CA::Render::EmitterLayer::EmitterLayer(v20, (CA::Render::Decoder *)a1);
            goto LABEL_96;
          case 0x11u:
            uint64_t v12 = (atomic_uint *)CA::Render::Filter::decode((CA::Render::Filter *)a1, v5);
            goto LABEL_95;
          case 0x12u:
            uint64_t v12 = (atomic_uint *)CA::Render::Function::decode((CA::Render::Function *)a1, v5);
            goto LABEL_95;
          case 0x13u:
            if ((*((_WORD *)v11 + 276) & 0x200) == 0) {
              goto LABEL_80;
            }
            double v21 = (CA::Render::GainMapLayer *)x_mem_alloc0(0x18uLL);
            if (!v21) {
              goto LABEL_101;
            }
            uint64_t v10 = (atomic_uint *)v21;
            CA::Render::GainMapLayer::GainMapLayer(v21, (CA::Render::Decoder *)a1);
            goto LABEL_96;
          case 0x14u:
            uint64_t v22 = (CA::Render::GradientLayer *)x_mem_alloc0(0x90uLL);
            if (!v22) {
              goto LABEL_101;
            }
            uint64_t v10 = (atomic_uint *)v22;
            CA::Render::GradientLayer::GradientLayer(v22, (CA::Render::Decoder *)a1);
            goto LABEL_96;
          case 0x15u:
            unsigned int v23 = (CA::Render::GroupAnimation *)x_mem_alloc0(0x68uLL);
            if (!v23) {
              goto LABEL_101;
            }
            uint64_t v10 = (atomic_uint *)v23;
            CA::Render::GroupAnimation::GroupAnimation(v23, (CA::Render::Decoder *)a1);
            goto LABEL_96;
          case 0x17u:
            uint64_t v12 = CA::Render::Image::decode((CA::Render::Image *)a1, v5);
            goto LABEL_95;
          case 0x19u:
            uint64_t v12 = (atomic_uint *)CA::Render::ImageQueue::decode((CA::Render::Context **)a1, v5);
            goto LABEL_95;
          case 0x1Bu:
            double v24 = (CA::Render::KeyframeAnimation *)x_mem_alloc0(0xB0uLL);
            if (!v24) {
              goto LABEL_101;
            }
            uint64_t v10 = (atomic_uint *)v24;
            CA::Render::KeyframeAnimation::KeyframeAnimation(v24, (CA::Render::Decoder *)a1);
            goto LABEL_96;
          case 0x1Cu:
            uint64_t v25 = (CA::Render::KeyValue *)x_mem_alloc0(0x20uLL);
            if (!v25) {
              goto LABEL_101;
            }
            uint64_t v10 = (atomic_uint *)v25;
            CA::Render::KeyValue::KeyValue(v25, (CA::Render::Decoder *)a1);
            goto LABEL_96;
          case 0x1Du:
            long long v26 = (CA::Render::Layer *)x_mem_alloc0(0x98uLL);
            if (!v26) {
              goto LABEL_101;
            }
            uint64_t v10 = (atomic_uint *)v26;
            CA::Render::Layer::Layer(v26, (CA::Render::Decoder *)a1);
            goto LABEL_96;
          case 0x1Eu:
            unint64_t v27 = (CA::Render::LayerHost *)x_mem_alloc0(0x58uLL);
            if (!v27) {
              goto LABEL_101;
            }
            uint64_t v10 = (atomic_uint *)v27;
            CA::Render::LayerHost::LayerHost(v27, (CA::Render::Decoder *)a1);
            goto LABEL_96;
          case 0x1Fu:
            unint64_t v28 = (CA::Render::MatchMoveAnimation *)x_mem_alloc0(0x90uLL);
            if (!v28) {
              goto LABEL_101;
            }
            uint64_t v10 = (atomic_uint *)v28;
            CA::Render::MatchMoveAnimation::MatchMoveAnimation(v28, (CA::Render::Decoder *)a1);
            goto LABEL_96;
          case 0x20u:
            uint64_t v29 = (CA::Render::MatchPropertyAnimation *)x_mem_alloc0(0x88uLL);
            if (!v29) {
              goto LABEL_101;
            }
            uint64_t v10 = (atomic_uint *)v29;
            CA::Render::MatchPropertyAnimation::MatchPropertyAnimation(v29, (CA::Render::Decoder *)a1);
            goto LABEL_96;
          case 0x21u:
            uint64_t v12 = (atomic_uint *)CA::Render::MeshTransform::decode((CA::Render::MeshTransform *)a1, v5);
            goto LABEL_95;
          case 0x22u:
            uint64_t v12 = (atomic_uint *)CA::Render::MetalTexture::decode();
            goto LABEL_95;
          case 0x24u:
            uint64_t v12 = (atomic_uint *)CA::Render::Path::decode((CA::Render::Path *)a1, v5);
            goto LABEL_95;
          case 0x25u:
            uint64_t v30 = (CA::Render::Pattern *)x_mem_alloc0(0x88uLL);
            if (!v30) {
              goto LABEL_101;
            }
            uint64_t v10 = (atomic_uint *)v30;
            CA::Render::Pattern::Pattern(v30, (CA::Render::Decoder *)a1);
            goto LABEL_96;
          case 0x26u:
            uint64_t v12 = (atomic_uint *)CA::Render::PixelBuffer::decode((CA::Render::PixelBuffer *)a1, v5);
            goto LABEL_95;
          case 0x28u:
            uint64_t v31 = (CA::Render::PortalLayer *)x_mem_alloc0(0x40uLL);
            if (!v31) {
              goto LABEL_101;
            }
            uint64_t v10 = (atomic_uint *)v31;
            CA::Render::PortalLayer::PortalLayer(v31, (CA::Render::Decoder *)a1);
            goto LABEL_96;
          case 0x2Au:
            unsigned int v32 = (CA::Render::PresentationModifier *)x_mem_alloc0(0x30uLL);
            if (!v32) {
              goto LABEL_101;
            }
            uint64_t v10 = (atomic_uint *)v32;
            CA::Render::PresentationModifier::PresentationModifier(v32, (CA::Render::Decoder *)a1);
            goto LABEL_96;
          case 0x2Bu:
            uint64_t v33 = (CA::Render::Proxy *)x_mem_alloc0(0x18uLL);
            if (!v33) {
              goto LABEL_101;
            }
            uint64_t v10 = (atomic_uint *)v33;
            CA::Render::Proxy::Proxy(v33, (CA::Render::Decoder *)a1);
            goto LABEL_96;
          case 0x2Cu:
            float v34 = (CA::Render::ReplicatorLayer *)x_mem_alloc0(0x48uLL);
            if (!v34) {
              goto LABEL_101;
            }
            uint64_t v10 = (atomic_uint *)v34;
            CA::Render::ReplicatorLayer::ReplicatorLayer(v34, (CA::Render::Decoder *)a1);
            goto LABEL_96;
          case 0x2Du:
            if ((*((_WORD *)v11 + 276) & 0x200) != 0)
            {
              uint64_t v43 = (CA::Render::SecureIndicatorLayer *)x_mem_alloc0(0x18uLL);
              if (v43)
              {
                uint64_t v10 = (atomic_uint *)v43;
                CA::Render::SecureIndicatorLayer::SecureIndicatorLayer(v43, (CA::Render::Decoder *)a1);
LABEL_96:
                if ((*(unsigned char *)(a1 + 18) & 1) != 0 && v10)
                {
LABEL_98:
                  if (atomic_fetch_add(v10 + 2, 0xFFFFFFFF) == 1) {
                    (*(void (**)(atomic_uint *))(*(void *)v10 + 16))(v10);
                  }
                  return 0;
                }
                if (v10) {
                  return v10;
                }
              }
            }
            else
            {
LABEL_80:
              CA::Render::Decoder::set_fatal_error((CA::Render::Decoder *)a1, "Missing entitlement for system layer!");
            }
LABEL_101:
            CA::Render::Decoder::set_fatal_error((CA::Render::Decoder *)a1, "%s - ptr == NULL, type = %u");
            return 0;
          case 0x2Eu:
            unsigned int v35 = (CA::Render::ShapeLayer *)x_mem_alloc0(0x98uLL);
            if (!v35) {
              goto LABEL_101;
            }
            uint64_t v10 = (atomic_uint *)v35;
            CA::Render::ShapeLayer::ShapeLayer(v35, (CA::Render::Decoder *)a1);
            goto LABEL_96;
          case 0x2Fu:
            uint64_t v12 = CA::Render::Shmem::decode((CA::Render::Shmem *)a1, v5);
            goto LABEL_95;
          case 0x30u:
            unsigned int v36 = (CA::Render::SpringAnimation *)x_mem_alloc0(0xF0uLL);
            if (!v36) {
              goto LABEL_101;
            }
            uint64_t v10 = (atomic_uint *)v36;
            CA::Render::SpringAnimation::SpringAnimation(v36, (CA::Render::Decoder *)a1);
            goto LABEL_96;
          case 0x31u:
            uint64_t v12 = CA::Render::String::decode((CA::Render::String *)a1, v5);
            goto LABEL_95;
          case 0x32u:
            malloc_zone = (malloc_zone_t *)get_malloc_zone();
            unsigned int v38 = (CA::Render::Subtexture *)malloc_type_zone_malloc(malloc_zone, 0x28uLL, 0x8BB15036uLL);
            if (!v38) {
              goto LABEL_101;
            }
            uint64_t v10 = (atomic_uint *)v38;
            CA::Render::Subtexture::Subtexture(v38, (CA::Render::Decoder *)a1);
            goto LABEL_96;
          case 0x33u:
            uint64_t v12 = (atomic_uint *)CA::Render::Surface::decode((CA::Render::Surface *)a1, v5);
            goto LABEL_95;
          case 0x34u:
            uint64_t v39 = (CA::Render::Timing *)x_mem_alloc0(0x40uLL);
            if (!v39) {
              goto LABEL_101;
            }
            uint64_t v10 = (atomic_uint *)v39;
            CA::Render::Timing::Timing(v39, (CA::Render::Decoder *)a1);
            goto LABEL_96;
          case 0x37u:
            uint64_t v40 = (CA::Render::TransitionAnimation *)x_mem_alloc0(0x90uLL);
            if (!v40) {
              goto LABEL_101;
            }
            uint64_t v10 = (atomic_uint *)v40;
            CA::Render::TransitionAnimation::TransitionAnimation(v40, (CA::Render::Decoder *)a1);
            goto LABEL_96;
          case 0x38u:
            uint64_t v12 = CA::Render::Vector::decode((CA::Render::Vector *)a1, v5);
LABEL_95:
            uint64_t v10 = v12;
            goto LABEL_96;
          default:
            if (x_log_hook_p())
            {
              x_log_();
            }
            else
            {
              int v42 = x_log_category_render;
              if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 67109120;
                unsigned int v45 = v6;
                _os_log_impl(&dword_184668000, v42, OS_LOG_TYPE_ERROR, "unable to decode object of type %d\n", buf, 8u);
              }
            }
            goto LABEL_101;
        }
      }
      CA::Render::Context::process_path(v11);
      CA::Render::Decoder::set_fatal_error((CA::Render::Decoder *)a1, "Deserialization of disallowed type: %s, process: %s");
    }
    else
    {
      CA::Render::Decoder::set_fatal_error((CA::Render::Decoder *)a1, "%s - required_type = %u, type = %u");
    }
    return 0;
  }
  *(_DWORD *)buf = 0;
  uint64_t v7 = CA::Render::Decoder::decode_size_t((CA::Render::Decoder *)a1);
  unsigned int v8 = CA::Render::Decoder::decode_int32((CA::Render::Decoder *)a1);
  if (v6 != 255)
  {
    unint64_t v9 = (CA::Render::Object *)CA::Render::Decoder::decode_object(a1, a2);
    if (v9)
    {
      uint64_t v10 = (atomic_uint *)v9;
      if ((*(unsigned char *)(a1 + 18) & 1) == 0)
      {
        CA::Render::Context::set_object(*(CA::Render::Context **)(a1 + 72), v7, v8, v9);
        goto LABEL_17;
      }
      goto LABEL_98;
    }
LABEL_19:
    if (a2) {
      CA::Render::Decoder::set_fatal_error((CA::Render::Decoder *)a1, "%s - ptr = NULL, required_type = %u, type = %u, id = %llu, error = %u");
    }
    return 0;
  }
  uint64_t v10 = (atomic_uint *)CA::Render::Context::lookup_object(*(void *)(*(void *)(a1 + 72) + 136), *(_DWORD *)(*(void *)(a1 + 72) + 148), v7, v8, a2, (int *)buf);
  if (!v10) {
    goto LABEL_19;
  }
LABEL_17:
  if (!atomic_fetch_add(v10 + 2, 1u)) {
    atomic_fetch_add(v10 + 2, 0xFFFFFFFF);
  }
  return v10;
}

void CA::Render::Decoder::decode_bytes(CA::Render::Decoder *this, void *__dst, size_t __n)
{
  unsigned int v6 = (const void *)*((void *)this + 4);
  BOOL v7 = __CFADD__(v6, __n);
  if ((unint64_t)v6 + __n > *((void *)this + 5) || v7)
  {
    bzero(__dst, __n);
    CA::Render::Decoder::set_fatal_error(this, "%s - _buffer_point = %p, len = %zu, _buffer_end = %p", "decode_bytes", *((const void **)this + 4), __n, *((const void **)this + 5));
  }
  else
  {
    memcpy(__dst, v6, __n);
    *((void *)this + 4) += __n;
  }
}

atomic_uint *CA::Render::Decoder::decode_array_object(CA::Render::Decoder *a1, uint64_t a2, int *a3, int a4)
{
  if ((*((unsigned char *)a1 + 18) & 1) == 0)
  {
    int v8 = CA::Render::Decoder::decode_int8(a1);
    if (v8)
    {
      if (v8 == 1)
      {
        BOOL result = CA::Render::Array::decode(a1, a2, a3, a4);
        if (result) {
          return result;
        }
        CA::Render::Decoder::set_fatal_error(a1, "%s - ptr = NULL");
      }
      else
      {
        CA::Render::Decoder::set_fatal_error(a1, "%s - type = %u");
      }
    }
  }
  return 0;
}

void *x_mem_alloc0(size_t a1)
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  return malloc_type_zone_calloc(malloc_zone, 1uLL, a1, 0x743898A5uLL);
}

atomic_uint *CA::Render::Decoder::decode_object(CA::Render::Decoder *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = CA::Render::Decoder::decode_object(a1, 0);
  BOOL v7 = (atomic_uint *)v6;
  if (v6)
  {
    uint64_t v8 = 0;
    int v9 = *(unsigned __int8 *)(v6 + 12);
    while (v9 != *(_DWORD *)(a3 + 4 * v8))
    {
      if (a2 == ++v8) {
        goto LABEL_7;
      }
    }
    if (v8 != a2) {
      return v7;
    }
LABEL_7:
    CA::Render::Decoder::set_fatal_error(a1, "%s - decoded object of unexpected type: %d", "decode_object", v9);
    if (atomic_fetch_add(v7 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v7 + 16))(v7);
    }
    return 0;
  }
  return v7;
}

void CA::Render::Context::delete_object(CA::Render::Context *this, CA::Render::Object *a2, int a3)
{
  unint64_t v4 = (((unint64_t)a2 ^ 0x8000000000000000) + ~((void)a2 << 32)) ^ ((((unint64_t)a2 ^ 0x8000000000000000)
                                                                               + ~((void)a2 << 32)) >> 22);
  unint64_t v5 = 9 * ((v4 + ~(v4 << 13)) ^ ((v4 + ~(v4 << 13)) >> 8));
  unint64_t v6 = (v5 ^ (v5 >> 15)) + ~((v5 ^ (v5 >> 15)) << 27);
  BOOL v7 = (void *)(*((void *)this + 17) + 8
                                         * (*((_DWORD *)this + 37) & ((v6 >> 31) ^ v6)));
  while (1)
  {
    uint64_t v8 = v7;
    BOOL v7 = (void *)*v7;
    if (!v7) {
      break;
    }
    if (v7[1] == ((unint64_t)a2 ^ 0x8000000000000000))
    {
      int v9 = *((_DWORD *)v7 + 6);
      if (v9) {
        BOOL v10 = v9 == a3;
      }
      else {
        BOOL v10 = 1;
      }
      if (v10)
      {
        *uint64_t v8 = *v7;
        CA::Render::Context::ResourceTable::release_value((CA::Render::Context::ResourceTable *)v7[2], a2);
        malloc_zone = (malloc_zone_t *)get_malloc_zone();
        malloc_zone_free(malloc_zone, v7);
        --*((void *)this + 20);
      }
      return;
    }
  }
}

void CA::Render::Update::invalidate_context(CA::Render::Update *this, CA::Render::Context *a2, int32x2_t *a3)
{
  CA::Render::Context::invalidate(a2, a3, (const CA::Bounds *)a3);

  CA::Render::Update::invalidate_backdrops(this, (const CA::Bounds *)a3, 0, 0xFFFFFFFF);
}

void CA::Render::Context::invalidate(CA::Render::Context *this, int32x2_t *a2, const CA::Bounds *a3)
{
  int v3 = a2[1].i32[0];
  if (v3 >= a2[1].i32[1]) {
    int v3 = a2[1].i32[1];
  }
  if (v3 >= 1)
  {
    if (*((void *)this + 72))
    {
      unint64_t v5 = (uint64_t *)((char *)this + 576);
      CA::shape_union((CA::Shape **)this + 72, (CA::Shape **)a2, a3);
      uint64_t v6 = *v5;
      if ((*v5 & 1) == 0 && *(int *)(v6 + 4) >= 65)
      {
        CA::Shape::get_bounds(v6, (int *)this + 146);
        CA::Shape::unref(*((CA::Shape **)this + 72));
        *((void *)this + 72) = 0;
      }
    }
    else
    {
      BOOL v7 = (int32x2_t *)((char *)this + 584);
      int32x2_t v8 = *a2;
      int32x2_t v9 = a2[1];
      CA::BoundsImpl::Union(v7, v8, v9);
    }
  }
}

void CA::Render::Context::ResourceTable::insert(CA::Render::Context::ResourceTable *this, CA::Render::Object *a2, int a3, CA::Render::Object *a4)
{
  unint64_t v7 = (unint64_t)a2 ^ 0x8000000000000000;
  unint64_t v8 = (((unint64_t)a2 ^ 0x8000000000000000) + ~((void)a2 << 32)) ^ ((((unint64_t)a2 ^ 0x8000000000000000)
                                                                               + ~((void)a2 << 32)) >> 22);
  unint64_t v9 = 9 * ((v8 + ~(v8 << 13)) ^ ((v8 + ~(v8 << 13)) >> 8));
  unint64_t v10 = (v9 ^ (v9 >> 15)) + ~((v9 ^ (v9 >> 15)) << 27);
  unint64_t v11 = v10 ^ (v10 >> 31);
  uint64_t v12 = *(void *)this + 8 * (v11 & *((_DWORD *)this + 3));
  while (1)
  {
    uint64_t v12 = *(void *)v12;
    if (!v12) {
      break;
    }
    if (*(void *)(v12 + 8) == v7)
    {
      CA::Render::Context::ResourceTable::release_value(*(CA::Render::Context::ResourceTable **)(v12 + 16), a2);
      *(void *)(v12 + 16) = a4;
      *(_DWORD *)(v12 + 24) = a3;
      return;
    }
  }
  unint64_t v13 = *((void *)this + 3) + 1;
  *((void *)this + 3) = v13;
  int v14 = *((_DWORD *)this + 2);
  if (v13 >= (4 * v14))
  {
    int v15 = 2 * v14;
    size_t v16 = 8 * (2 * v14);
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    double v18 = malloc_type_zone_calloc(malloc_zone, 1uLL, v16, 0x743898A5uLL);
    if (v18)
    {
      uint64_t v19 = v18;
      int v20 = *((_DWORD *)this + 4) + 1;
      int v21 = ~(-1 << v20);
      *((_DWORD *)this + 3) = v21;
      *((_DWORD *)this + 4) = v20;
      unint64_t v22 = *((unsigned int *)this + 2);
      if (v22)
      {
        for (unint64_t i = 0; i < v22; ++i)
        {
          double v24 = *(void **)(*(void *)this + 8 * i);
          if (v24)
          {
            do
            {
              uint64_t v25 = (void *)*v24;
              unint64_t v26 = v24[1] + ~(v24[1] << 32);
              unint64_t v27 = (v26 ^ (v26 >> 22)) + ~((v26 ^ (v26 >> 22)) << 13);
              unint64_t v28 = (9 * (v27 ^ (v27 >> 8))) ^ ((9 * (v27 ^ (v27 >> 8))) >> 15);
              LODWORD(v28) = v21 & (((v28 + ~(v28 << 27)) >> 31) ^ (v28 + ~(v28 << 27)));
              *double v24 = v18[v28];
              v18[v28] = v24;
              double v24 = v25;
            }
            while (v25);
          }
        }
      }
      uint64_t v29 = *(void **)this;
      uint64_t v30 = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(v30, v29);
      *(void *)this = v19;
      *((_DWORD *)this + 2) = v15;
    }
  }
  uint64_t v31 = (malloc_zone_t *)get_malloc_zone();
  unsigned int v32 = malloc_type_zone_malloc(v31, 0x20uLL, 0x8BB15036uLL);
  v32[2] = a4;
  *((_DWORD *)v32 + 6) = a3;
  uint64_t v33 = *(void *)this;
  uint64_t v34 = v11 & *((_DWORD *)this + 3);
  void *v32 = *(void *)(*(void *)this + 8 * v34);
  v32[1] = v7;
  *(void *)(v33 + 8 * v34) = v32;
}

_DWORD *CA::Render::Vector::decode(CA::Render::Vector *this, CA::Render::Decoder *a2)
{
  unsigned int v3 = CA::Render::Decoder::decode_int32(this);
  size_t v4 = 8 * v3;
  if (v3 < 0x7FFFE)
  {
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    unint64_t v7 = malloc_type_zone_malloc(malloc_zone, v4 + 24, 0x8BB15036uLL);
    unint64_t v5 = v7;
    if (v7)
    {
      v7[2] = 1;
      void v7[3] = 56;
      ++dword_1EB2ADEA8;
      *(void *)unint64_t v7 = &unk_1ED02F810;
      v7[4] = v3;
      CA::Render::Decoder::decode_bytes(this, v7 + 6, v4);
    }
  }
  else
  {
    CA::Render::Decoder::set_fatal_error(this, "%s - suspiciously large vector size: %zu", "decode", v4 + 24);
    return 0;
  }
  return v5;
}

BOOL CA::Render::Array::check_types(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if ((a2 != 1 || *a3) && (unint64_t v3 = *(unsigned int *)(a1 + 16), v3))
  {
    BOOL v4 = 0;
    for (i = 0; i != v3; BOOL v4 = i >= v3)
    {
      uint64_t v6 = 0;
      while (a3[v6] != *(unsigned __int8 *)(*(void *)(a1 + 8 * i + 24) + 12))
      {
        if (a2 == ++v6) {
          return v4;
        }
      }
      if (v6 == a2) {
        break;
      }
      ++i;
    }
  }
  else
  {
    return 1;
  }
  return v4;
}

CA::Render::KeyValue *CA::Render::KeyValue::KeyValue(CA::Render::KeyValue *this, CA::Render::Decoder *a2)
{
  *((_DWORD *)this + 2) = 1;
  *((_DWORD *)this + 3) = 28;
  ++dword_1EB2ADE38;
  *(void *)this = &unk_1ED02FFB8;
  *((_DWORD *)this + 4) = CA::Render::Decoder::decode_atom(a2);
  *((void *)this + 3) = CA::Render::Decoder::decode_object(a2, 0);
  return this;
}

void CA::Render::Context::ResourceTable::release_value(CA::Render::Context::ResourceTable *this, CA::Render::Object *a2)
{
  if (this)
  {
    int v3 = *((unsigned __int8 *)this + 12);
    if (v3 == 24)
    {
      os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::ImageProvider::_provider_lock);
      *((void *)this + 21) = 0;
      os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::ImageProvider::_provider_lock);
    }
    else if (v3 == 22)
    {
      if (*((void *)this + 3))
      {
        os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::Handle::_handle_lock);
        *((void *)this + 3) = 0;
        os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Handle::_handle_lock);
      }
      for (unint64_t i = (void *)*((void *)this + 6); i; unint64_t i = (void *)i[1])
      {
        uint64_t v5 = *i;
        if (*(unsigned char *)(*i + 12) == 55)
        {
          uint64_t v6 = *(atomic_uint **)(v5 + 128);
          if (v6)
          {
            if (atomic_fetch_add(v6 + 2, 0xFFFFFFFF) == 1) {
              (*(void (**)(atomic_uint *, CA::Render::Object *))(*(void *)v6 + 16))(v6, a2);
            }
            *(void *)(v5 + 128) = 0;
          }
        }
      }
      uint64_t v7 = *((void *)this + 5);
      if (v7)
      {
        *(void *)(v7 + 40) = 0;
        if (atomic_fetch_add((atomic_uint *volatile)(v7 + 16), 0xFFFFFFFF) == 1) {
          CA::Render::LayerNode::delete_node((CA::Render::LayerNode *)v7, a2);
        }
        *((void *)this + 5) = 0;
      }
      uint64_t v8 = *((void *)this + 2);
      if (v8)
      {
        unint64_t v9 = *(uint64_t **)(v8 + 128);
        if (v9)
        {
          uint64_t v10 = *v9;
          if (*v9)
          {
            if (*(unsigned char *)(v10 + 12) == 30 && *(CA::Render::Context::ResourceTable **)(v10 + 24) == this) {
              CA::Render::LayerHost::invalidate((CA::Render::LayerHost *)v10);
            }
          }
        }
      }
      if ((*((unsigned char *)this + 13) & 0x20) != 0)
      {
        CA::Render::FlattenManager::flattened_cache_remove_surface((CA::Render::FlattenManager *)*((unsigned int *)this
                                                                                                 + 18));
        *((_DWORD *)this + 3) &= ~0x2000u;
      }
      CA::Render::Handle::set_current_layer((uint64_t)this, 0);
      *((void *)this + 7) = 0;
      *((void *)this + 8) = 0;
    }
    if (atomic_fetch_add((atomic_uint *volatile)this + 2, 0xFFFFFFFF) == 1)
    {
      unint64_t v11 = *(void (**)(CA::Render::Context::ResourceTable *))(*(void *)this + 16);
      v11(this);
    }
  }
}

CA::Render::Filter *CA::Render::Filter::decode(CA::Render::Filter *this, CA::Render::Decoder *a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  int v3 = CA::Render::Decoder::decode_int32(this);
  if ((v3 & 0x100) != 0)
  {
    uint64_t v10 = CA::Render::Decoder::decode_atom(this);
    unint64_t v11 = CA::Render::Filter::shared_filter((CA::Render::Filter *)v10);
    uint64_t v12 = v11;
    if (v11 && !atomic_fetch_add((atomic_uint *volatile)v11 + 2, 1u))
    {
      uint64_t v12 = 0;
      atomic_fetch_add((atomic_uint *volatile)v11 + 2, 0xFFFFFFFF);
    }
  }
  else
  {
    int v4 = v3;
    if (CA::Render::Decoder::decode_int8(this) == 1)
    {
      int v5 = CA::Render::Decoder::decode_atom(this);
      uint64_t v6 = (atomic_uint *)CA::Render::Decoder::decode_object(this, 49);
      int v16 = 28;
      uint64_t v7 = CA::Render::Decoder::decode_array_object(this, 1, &v16, 0);
      if (v7)
      {
        uint64_t v8 = v7 + 2;
        unint64_t v9 = v7;
        if (!atomic_fetch_add(v7 + 2, 1u))
        {
          unint64_t v9 = 0;
          atomic_fetch_add(v8, 0xFFFFFFFF);
        }
        if (atomic_fetch_add(v8, 0xFFFFFFFF) == 1) {
          (*(void (**)(atomic_uint *))(*(void *)v7 + 16))(v7);
        }
      }
      else
      {
        unint64_t v9 = 0;
      }
      malloc_zone = (malloc_zone_t *)get_malloc_zone();
      int v14 = (CA::Render::Filter *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x38uLL, 0x743898A5uLL);
      uint64_t v12 = v14;
      if (v14) {
        CA::Render::Filter::Filter(v14, v5, v6, v9);
      }
      *((_DWORD *)v12 + 3) |= v4 << 8;
      if (v9 && atomic_fetch_add(v9 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v9 + 16))(v9);
      }
      if (v6 && atomic_fetch_add(v6 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v6 + 16))(v6);
      }
    }
    else
    {
      return 0;
    }
  }
  return v12;
}

CA::Render::Timing *CA::Render::Timing::Timing(CA::Render::Timing *this, CA::Render::Decoder *a2)
{
  *(void *)this = &unk_1ED02F670;
  *((_DWORD *)this + 2) = 1;
  *((_DWORD *)this + 3) = (CA::Render::Decoder::decode_int32(a2) << 8) | 0x34;
  ++dword_1EB2ADE98;
  *(void *)this = &unk_1ED02F798;
  *((_DWORD *)this + 4) = CA::Render::Decoder::decode_int32(a2);
  *((void *)this + 3) = CA::Render::Decoder::decode_int64(a2);
  *((void *)this + 4) = CA::Render::Decoder::decode_int64(a2);
  *((void *)this + 5) = CA::Render::Decoder::decode_int64(a2);
  *((void *)this + 6) = CA::Render::Decoder::decode_int64(a2);
  *((void *)this + 7) = CA::Render::Decoder::decode_int64(a2);
  return this;
}

void CA::Render::Context::add_animation(CA::Render::Context *this, CA::Render::Object *a2, CA::Render::Animation *a3)
{
  uint64_t v101 = *MEMORY[0x1E4F143B8];
  int v4 = CA::Render::Context::lookup_handle(this, a2, 0, 1, 0);
  if (!v4 || !a3) {
    return;
  }
  int v5 = v4;
  int v6 = (*(uint64_t (**)(CA::Render::Animation *, void))(*(void *)a3 + 136))(a3, *((void *)v4 + 2));
  uint64_t v8 = (void **)((char *)v5 + 48);
  uint64_t v7 = (void *)*((void *)v5 + 6);
  if (!v7) {
    goto LABEL_49;
  }
  unint64_t v9 = (void *)((char *)v5 + 48);
  do
  {
    uint64_t v10 = (CA::Render::Animation *)*v7;
    if ((CA::Render::Animation *)*v7 == a3
      || (unint64_t v11 = (const void *)*((void *)a3 + 7)) == 0
      || (uint64_t v12 = (const void *)*((void *)v10 + 7)) == 0
      || *((void *)a3 + 8) != *((void *)v10 + 8)
      || !CFEqual(v11, v12))
    {
      int v14 = (void *)v7[1];
      unint64_t v9 = v7 + 1;
      goto LABEL_15;
    }
    if (!byte_1EB2ACBE7) {
      goto LABEL_11;
    }
    x_log_begin();
    if (x_log_hook_p())
    {
      uint64_t v16 = mach_absolute_time();
      CATimeWithHostTime(v16);
      x_log_();
    }
    else
    {
      double v18 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v19 = mach_absolute_time();
        double v20 = CATimeWithHostTime(v19);
        uint64_t v21 = *((void *)v5 + 3);
        if (v21) {
          LODWORD(v21) = *(_DWORD *)(v21 + 16);
        }
        uint64_t v22 = *((void *)v5 + 2);
        if (v22)
        {
          uint64_t v23 = *(void *)(v22 + 120);
          if (v23) {
            uint64_t v22 = v23 + 28;
          }
          else {
            uint64_t v22 = 0;
          }
        }
        int v24 = *((_DWORD *)v10 + 20);
        int v25 = *((_DWORD *)v10 + 21);
        *(_DWORD *)buf = 134219522;
        double v88 = v20;
        __int16 v89 = 1024;
        int v90 = v21;
        __int16 v91 = 2080;
        char v92 = (char *)v22;
        __int16 v93 = 2048;
        unsigned int v94 = v5;
        __int16 v95 = 2048;
        int64_t v96 = v10;
        __int16 v97 = 1024;
        int v98 = v24;
        __int16 v99 = 1024;
        int v100 = v25;
        _os_log_impl(&dword_184668000, v18, OS_LOG_TYPE_DEFAULT, "%f %x \"%s\" (%p): replacing %p (eval %u; frames %u):\n",
          buf,
          0x3Cu);
      }
    }
    CA::Render::show_object(v10, v17);
    uint64_t v81 = (void **)x_stream_pop_(0);
    uint64_t v83 = x_stream_get(v81);
    int v26 = 0;
    while (2)
    {
      uint64_t v27 = 0;
      unint64_t v28 = &v83[v26];
      int v29 = -1;
      while (1)
      {
        if (v28[v27] == 10)
        {
          int v29 = v27;
          goto LABEL_33;
        }
        if (!v28[v27]) {
          break;
        }
LABEL_33:
        ++v27;
        unsigned int v30 = 32512;
        if (v27 == 32512) {
          goto LABEL_34;
        }
      }
      unsigned int v30 = v27;
LABEL_34:
      if (v29 <= -1 || v28[v30] == 0) {
        int v32 = v30;
      }
      else {
        int v32 = v29 + 1;
      }
      if (v32 > 0)
      {
        int v84 = v32;
        int v85 = v26;
        if (x_log_hook_p())
        {
          x_log_();
          int v33 = v84;
          int v34 = v85;
        }
        else
        {
          log = x_log_category_render;
          BOOL v35 = os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT);
          int v34 = v85;
          int v33 = v84;
          if (v35)
          {
            *(_DWORD *)buf = 136315650;
            unsigned int v36 = "continued...\n";
            if (!v85) {
              unsigned int v36 = "";
            }
            double v88 = *(double *)&v36;
            __int16 v89 = 1040;
            int v90 = v84;
            __int16 v91 = 2080;
            char v92 = v28;
            _os_log_impl(&dword_184668000, log, OS_LOG_TYPE_DEFAULT, "%s%.*s", buf, 0x1Cu);
            int v33 = v84;
            int v34 = v85;
          }
        }
        int v26 = v33 + v34;
        continue;
      }
      break;
    }
    x_log_end_free_(v81);
LABEL_11:
    if (BYTE9(xmmword_1EB2ACC10)) {
      kdebug_trace();
    }
    CA::Render::invalidate_animation(v5, (Handle *)v10, v13);
    int v14 = (void *)v7[1];
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(malloc_zone, v7);
    *unint64_t v9 = v14;
    *((void *)v5 + 12) |= 0x10080003uLL;
LABEL_15:
    uint64_t v7 = v14;
  }
  while (v14);
LABEL_49:
  if (!v6)
  {
    if (!byte_1EB2ACBE7) {
      return;
    }
    x_log_begin();
    if (x_log_hook_p())
    {
      uint64_t v47 = mach_absolute_time();
      CATimeWithHostTime(v47);
      x_log_();
    }
    else
    {
      int v65 = x_log_category_render;
      if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v66 = mach_absolute_time();
        double v67 = CATimeWithHostTime(v66);
        uint64_t v68 = *((void *)v5 + 3);
        if (v68) {
          LODWORD(v68) = *(_DWORD *)(v68 + 16);
        }
        uint64_t v69 = *((void *)v5 + 2);
        if (v69)
        {
          uint64_t v70 = *(void *)(v69 + 120);
          if (v70) {
            uint64_t v69 = v70 + 28;
          }
          else {
            uint64_t v69 = 0;
          }
        }
        *(_DWORD *)buf = 134219010;
        double v88 = v67;
        __int16 v89 = 1024;
        int v90 = v68;
        __int16 v91 = 2080;
        char v92 = (char *)v69;
        __int16 v93 = 2048;
        unsigned int v94 = v5;
        __int16 v95 = 2048;
        int64_t v96 = a3;
        _os_log_impl(&dword_184668000, v65, OS_LOG_TYPE_DEFAULT, "%f %x \"%s\" (%p): not adding %p:\n", buf, 0x30u);
      }
    }
    CA::Render::show_object(a3, v48);
    uint64_t v86 = (void **)x_stream_pop_(0);
    int v71 = x_stream_get(v86);
    for (int i = 0; ; i += v78)
    {
      uint64_t v73 = 0;
      uint64_t v74 = &v71[i];
      int v75 = -1;
      while (1)
      {
        if (v74[v73] == 10)
        {
          int v75 = v73;
          goto LABEL_115;
        }
        if (!v74[v73]) {
          break;
        }
LABEL_115:
        ++v73;
        unsigned int v76 = 32512;
        if (v73 == 32512) {
          goto LABEL_116;
        }
      }
      unsigned int v76 = v73;
LABEL_116:
      if (v75 <= -1 || v74[v76] == 0) {
        int v78 = v76;
      }
      else {
        int v78 = v75 + 1;
      }
      if (v78 < 1) {
        goto LABEL_131;
      }
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        uint64_t v79 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315650;
          if (i) {
            uint64_t v80 = "continued...\n";
          }
          else {
            uint64_t v80 = "";
          }
          double v88 = *(double *)&v80;
          __int16 v89 = 1040;
          int v90 = v78;
          __int16 v91 = 2080;
          char v92 = &v71[i];
          _os_log_impl(&dword_184668000, v79, OS_LOG_TYPE_DEFAULT, "%s%.*s", buf, 0x1Cu);
        }
      }
    }
  }
  uint64_t v37 = *v8;
  if (*v8)
  {
    uint64_t v38 = *((void *)a3 + 5);
    do
    {
      double v39 = 0.0;
      double v40 = 0.0;
      if (v38) {
        double v40 = *(double *)(v38 + 40);
      }
      uint64_t v41 = *(void *)(*v37 + 40);
      if (v41) {
        double v39 = *(double *)(v41 + 40);
      }
      if (v40 < v39 || v40 <= v39 && *((_DWORD *)a3 + 18) < *(_DWORD *)(*v37 + 72)) {
        break;
      }
      uint64_t v8 = (void **)(v37 + 1);
      uint64_t v37 = (void *)v37[1];
    }
    while (v37);
  }
  int v42 = a3;
  if (!atomic_fetch_add((atomic_uint *volatile)a3 + 2, 1u))
  {
    int v42 = 0;
    atomic_fetch_add((atomic_uint *volatile)a3 + 2, 0xFFFFFFFF);
  }
  uint64_t v43 = (malloc_zone_t *)get_malloc_zone();
  int v44 = malloc_type_zone_malloc(v43, 0x10uLL, 0x8BB15036uLL);
  *int v44 = v42;
  v44[1] = v37;
  *uint64_t v8 = v44;
  *((void *)v5 + 12) |= 0x80003uLL;
  (*(void (**)(CA::Render::Animation *, CA::Render::Object *))(*(void *)a3 + 144))(a3, v5);
  if (BYTE9(xmmword_1EB2ACC10)) {
    kdebug_trace();
  }
  if (!byte_1EB2ACBE7) {
    return;
  }
  x_log_begin();
  if (x_log_hook_p())
  {
    uint64_t v45 = mach_absolute_time();
    CATimeWithHostTime(v45);
    x_log_();
  }
  else
  {
    uint64_t v49 = x_log_category_render;
    if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v50 = mach_absolute_time();
      double v51 = CATimeWithHostTime(v50);
      uint64_t v52 = *((void *)v5 + 3);
      if (v52) {
        LODWORD(v52) = *(_DWORD *)(v52 + 16);
      }
      uint64_t v53 = *((void *)v5 + 2);
      if (v53)
      {
        uint64_t v54 = *(void *)(v53 + 120);
        if (v54) {
          uint64_t v53 = v54 + 28;
        }
        else {
          uint64_t v53 = 0;
        }
      }
      *(_DWORD *)buf = 134219010;
      double v88 = v51;
      __int16 v89 = 1024;
      int v90 = v52;
      __int16 v91 = 2080;
      char v92 = (char *)v53;
      __int16 v93 = 2048;
      unsigned int v94 = v5;
      __int16 v95 = 2048;
      int64_t v96 = a3;
      _os_log_impl(&dword_184668000, v49, OS_LOG_TYPE_DEFAULT, "%f %x \"%s\" (%p): adding %p:\n", buf, 0x30u);
    }
  }
  CA::Render::show_object(a3, v46);
  uint64_t v86 = (void **)x_stream_pop_(0);
  uint64_t v55 = x_stream_get(v86);
  int v56 = 0;
  while (2)
  {
    uint64_t v57 = 0;
    uint64_t v58 = &v55[v56];
    int v59 = -1;
    while (2)
    {
      if (v58[v57] == 10)
      {
        int v59 = v57;
LABEL_85:
        ++v57;
        unsigned int v60 = 32512;
        if (v57 == 32512) {
          goto LABEL_86;
        }
        continue;
      }
      break;
    }
    if (v58[v57]) {
      goto LABEL_85;
    }
    unsigned int v60 = v57;
LABEL_86:
    if (v59 <= -1 || v58[v60] == 0) {
      int v62 = v60;
    }
    else {
      int v62 = v59 + 1;
    }
    if (v62 >= 1)
    {
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        uint64_t v63 = x_log_category_render;
        if (os_log_type_enabled((os_log_t)x_log_category_render, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315650;
          if (v56) {
            uint64_t v64 = "continued...\n";
          }
          else {
            uint64_t v64 = "";
          }
          double v88 = *(double *)&v64;
          __int16 v89 = 1040;
          int v90 = v62;
          __int16 v91 = 2080;
          char v92 = &v55[v56];
          _os_log_impl(&dword_184668000, v63, OS_LOG_TYPE_DEFAULT, "%s%.*s", buf, 0x1Cu);
        }
      }
      v56 += v62;
      continue;
    }
    break;
  }
LABEL_131:
  x_log_end_free_(v86);
}

uint64_t CA::Render::Animation::was_added(uint64_t this, Handle *a2)
{
  int v2 = *(_DWORD *)(this + 12);
  if ((v2 & 0x1000) == 0)
  {
    if ((v2 & 0x2000) == 0) {
      return this;
    }
LABEL_5:
    a2[12] = (Handle)((unint64_t)a2[12] | 0x10);
    return this;
  }
  a2[12] = (Handle)((unint64_t)a2[12] | 8);
  if ((*(_DWORD *)(this + 12) & 0x2000) != 0) {
    goto LABEL_5;
  }
  return this;
}

uint64_t CA::Render::BackdropLayer::commit_layer(uint64_t this, CA::Render::Context *a2, CA::Render::Layer *a3, CA::Render::Handle *a4, int a5)
{
  uint64_t v7 = this;
  v23[1] = *MEMORY[0x1E4F143B8];
  if (!*(void *)(this + 88))
  {
    uint64_t v10 = *(void *)(this + 16);
    uint64_t v9 = *(void *)(this + 24);
    int v11 = *(unsigned __int8 *)(this + 80);
    float v12 = *(float *)(this + 32);
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::BackdropState::_list_lock);
    int v14 = (char *)CA::Render::BackdropState::_list;
    uint64_t v13 = qword_1E8F83DD0;
    if (CA::Render::BackdropState::_list != (_UNKNOWN *)qword_1E8F83DD0)
    {
      int v15 = (const void *)(v9 + 28);
      do
      {
        uint64_t v16 = *(_DWORD **)v14;
        if (*(void *)(*(void *)v14 + 24) == v10
          && *((CA::Render::Context **)v16 + 2) == a2
          && *((unsigned __int8 *)v16 + 84) == v11
          && *((float *)v16 + 8) == v12
          && (*((unsigned char *)v16 + 13) & 2) == 0)
        {
          if (v9)
          {
            uint64_t v17 = *(void *)(*((void *)v16 + 5) + 32);
            if (v17)
            {
              size_t v18 = *(unsigned int *)(v9 + 24);
              if (v18 == *(_DWORD *)(v17 + 24))
              {
                uint64_t v22 = v15;
                int v19 = memcmp(v15, (const void *)(v17 + 28), v18);
                int v15 = v22;
                if (!v19)
                {
                  if (atomic_fetch_add(v16 + 2, 1u)) {
                    goto LABEL_25;
                  }
                  atomic_fetch_add(v16 + 2, 0xFFFFFFFF);
                }
              }
            }
          }
        }
        v14 += 8;
      }
      while (v14 != (char *)v13);
    }
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    uint64_t v21 = malloc_type_zone_malloc(malloc_zone, 0x68uLL, 0x8BB15036uLL);
    uint64_t v16 = v21;
    if (v21)
    {
      v21[2] = 1;
      v21[3] = 4;
      ++dword_1EB2ADDD8;
      *(void *)uint64_t v21 = &unk_1ED02D930;
      *((void *)v21 + 2) = a2;
      *((void *)v21 + 3) = v10;
      *((float *)v21 + 8) = v12;
      v21[9] = 0;
      CA::Render::BackdropGroup::retain_group((void *)v21 + 5, (uint64_t)a2, v9, v11, v12);
      v16[20] = 0;
      *((_OWORD *)v16 + 3) = 0u;
      *((_OWORD *)v16 + 4) = 0u;
      *((unsigned char *)v16 + 84) = v11;
      *((void *)v16 + 11) = 0;
      *((_WORD *)v16 + 48) = 0;
    }
    v23[0] = v16;
    v16[3] |= 0x100u;
    X::small_vector_base<CA::Render::BackdropState *>::push_back(v23);
LABEL_25:
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::BackdropState::_list_lock);
    this = *(void *)(v7 + 88);
    *(void *)(v7 + 88) = v16;
    if (this && atomic_fetch_add((atomic_uint *volatile)(this + 8), 0xFFFFFFFF) == 1) {
      this = (*(uint64_t (**)(uint64_t))(*(void *)this + 16))(this);
    }
  }
  if ((a5 & 0x5FE78) != 0) {
    *((void *)a4 + 12) |= 0x10uLL;
  }
  if ((a5 & 0x200000) == 0) {
    *(unsigned char *)(*(void *)(v7 + 88) + 97) = 1;
  }
  return this;
}

CA::Render::BackdropLayer *CA::Render::BackdropLayer::BackdropLayer(CA::Render::BackdropLayer *this, CA::Render::Decoder *a2)
{
  *(void *)this = &unk_1ED02F670;
  *((_DWORD *)this + 2) = 1;
  *((_DWORD *)this + 3) = (CA::Render::Decoder::decode_int32(a2) << 8) | 3;
  ++dword_1EB2ADDD4;
  *(void *)this = &unk_1ED02D828;
  *((void *)this + 2) = CA::Render::Decoder::decode_size_t(a2);
  *((void *)this + 3) = CA::Render::Decoder::decode_object(a2, 49);
  *((_DWORD *)this + 8) = CA::Render::Decoder::decode_int32(a2);
  *((_DWORD *)this + 9) = CA::Render::Decoder::decode_int32(a2);
  int v4 = CA::Render::Decoder::decode_int32(a2);
  *((_OWORD *)this + 3) = 0u;
  *((_DWORD *)this + 10) = v4;
  *((_OWORD *)this + 4) = 0u;
  CA::Render::Decoder::decode_bytes(a2, (char *)this + 48, 0x20uLL);
  unsigned int v5 = CA::Render::Decoder::decode_int8(a2);
  if (v5 >= 3)
  {
    CA::Render::Decoder::set_fatal_error(a2, "%s - enum %u out of range of %u", "decode_int8_enum", v5, 3);
    LOBYTE(v5) = 0;
  }
  *((unsigned char *)this + 80) = v5;
  *((void *)this + 11) = 0;
  return this;
}

void X::small_vector_base<CA::Render::BackdropState *>::push_back(void *a1)
{
  int v3 = CA::Render::BackdropState::_list;
  int v2 = (char *)qword_1E8F83DD0;
  uint64_t v4 = (qword_1E8F83DD0 - (uint64_t)CA::Render::BackdropState::_list) >> 3;
  if (qword_1E8F83DE0 < (unint64_t)(v4 + 1))
  {
    unsigned int v5 = off_1E8F83DD8;
    unint64_t v6 = (qword_1E8F83DE0 + 1) | ((unint64_t)(qword_1E8F83DE0 + 1) >> 1) | (((qword_1E8F83DE0 + 1) | ((unint64_t)(qword_1E8F83DE0 + 1) >> 1)) >> 2);
    unint64_t v7 = v6 | (v6 >> 4) | ((v6 | (v6 >> 4)) >> 8);
    unint64_t v8 = v7 | (v7 >> 16) | ((v7 | (v7 >> 16)) >> 32);
    if (v8 + 1 > v4 + 1) {
      uint64_t v9 = v8 + 1;
    }
    else {
      uint64_t v9 = v4 + 1;
    }
    uint64_t v10 = (char *)malloc_type_malloc(8 * v9, 0x2004093837F09uLL);
    int v11 = v10;
    float v12 = (uint64_t *)CA::Render::BackdropState::_list;
    uint64_t v13 = qword_1E8F83DD0;
    if (CA::Render::BackdropState::_list != (_UNKNOWN *)qword_1E8F83DD0)
    {
      int v14 = v10;
      do
      {
        uint64_t v15 = *v12++;
        *(void *)int v14 = v15;
        v14 += 8;
      }
      while (v12 != (uint64_t *)v13);
    }
    if (v3 != v5) {
      free(CA::Render::BackdropState::_list);
    }
    int v2 = &v11[8 * v4];
    CA::Render::BackdropState::_list = v11;
    qword_1E8F83DD0 = (uint64_t)v2;
    qword_1E8F83DE0 = v9;
  }
  *(void *)int v2 = *a1;
  qword_1E8F83DD0 += 8;
}

BOOL CA::Render::SpringAnimation::validate(CA::Render::SpringAnimation *this, CA::Render::Layer *a2)
{
  BOOL v3 = CA::Render::BasicAnimation0::validate(this, a2);
  if (v3) {
    CA::Render::SpringAnimation::State::update((uint64_t)this + 192, *((double *)this + 19), *((double *)this + 20), *((double *)this + 21), *((double *)this + 22), *((unsigned __int8 *)this + 184));
  }
  return v3;
}

BOOL CA::Render::PropertyAnimation::validate(uint64_t a1)
{
  uint64_t v1 = *(_DWORD **)(a1 + 96);
  if (!v1) {
    return 0;
  }
  if (v1) {
    return 1;
  }
  return *v1 != 0;
}

const void **CA::Render::GradientLayer::commit_layer(const void **this, CFTypeRef *a2, CA::Render::Layer *a3, CA::Render::Handle *a4)
{
  return X::CFRef<__CFDictionary const*>::operator=(this + 17, a2[56]);
}

CGColorSpace *CA::Render::Context::set_colorspace(CA::Render::Context *this, CGColorSpace *a2)
{
  BOOL result = (CGColorSpace *)*((void *)this + 56);
  if (result != a2)
  {
    CGColorSpaceRelease(result);
    BOOL result = CGColorSpaceRetain(a2);
    *((void *)this + 56) = result;
  }
  return result;
}

void CA::Render::Context::flush_image_queue(CA::Render::Context *this, int a2, unsigned int a3)
{
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::Context::_image_queues_lock);
  uint64_t v6 = *((void *)this + 45);
  uint64_t v7 = *((void *)this + 46);
  while (v6 != v7)
  {
    if (*(_DWORD *)(*(void *)v6 + 184) == a2)
    {
      uint64_t v8 = *(void *)(*(void *)(*(void *)v6 + 16) + 24);
      do
      {
        unsigned int v9 = *(_DWORD *)(v8 + 16);
        if (v9 >= a3) {
          break;
        }
        int v10 = *(_DWORD *)(v8 + 16);
        atomic_compare_exchange_strong((atomic_uint *volatile)(v8 + 16), (unsigned int *)&v10, a3);
      }
      while (v10 != v9);
      uint64_t v7 = *((void *)this + 46);
    }
    v6 += 8;
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Context::_image_queues_lock);
}

uint64_t CA::Render::Context::flush_presentation_modifier_shmem(uint64_t result)
{
  if (result && *(void *)(result + 16) >= 0x28uLL)
  {
    uint64_t v1 = *(atomic_uint **)(result + 24);
    v1[1] = v1[1] == 0;
    do
    {
      int v2 = *v1 & 0x7FFFFFFF;
      int v3 = v2;
      atomic_compare_exchange_strong(v1, (unsigned int *)&v3, *v1 & 0x7FFFFFFE | v1[1]);
    }
    while (v3 != v2);
  }
  return result;
}

void CA::Render::FlattenManager::flattened_cache_remove_surface(CA::Render::FlattenManager *this)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (this)
  {
    unsigned int v1 = this;
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::flattened_lock);
    if (CA::Render::flattened_cache)
    {
      if (*(void *)(CA::Render::flattened_cache + 24))
      {
        uint64_t v2 = x_hash_table_remove(CA::Render::flattened_cache, v1);
        if (v2)
        {
          uint64_t v3 = v2;
          if ((_BYTE)xmmword_1EB2ACC70)
          {
            if (x_log_hook_p())
            {
              IOSurfaceGetID(*(IOSurfaceRef *)v3);
              x_log_();
            }
            else
            {
              uint64_t v7 = x_log_category_flatten;
              if (os_log_type_enabled((os_log_t)x_log_category_flatten, OS_LOG_TYPE_DEFAULT))
              {
                IOSurfaceID ID = IOSurfaceGetID(*(IOSurfaceRef *)v3);
                uint64_t v9 = *(void *)(CA::Render::flattened_cache + 24);
                *(_DWORD *)buf = 67109632;
                unsigned int v11 = v1;
                __int16 v12 = 1024;
                IOSurfaceID v13 = ID;
                __int16 v14 = 2048;
                uint64_t v15 = v9;
                _os_log_impl(&dword_184668000, v7, OS_LOG_TYPE_DEFAULT, "[%d] removed surface <%d> from cache <size: %zu>", buf, 0x18u);
              }
            }
          }
          CFRelease(*(CFTypeRef *)v3);
          uint64_t v4 = *(CA::Shape **)(v3 + 40);
          if (v4) {
            CA::Shape::unref(v4);
          }
          unsigned int v5 = *(atomic_uint **)(v3 + 56);
          if (v5)
          {
            if (atomic_fetch_add(v5 + 2, 0xFFFFFFFF) == 1) {
              (*(void (**)(atomic_uint *))(*(void *)v5 + 16))(v5);
            }
          }
          malloc_zone = (malloc_zone_t *)get_malloc_zone();
          malloc_zone_free(malloc_zone, (void *)v3);
        }
      }
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::flattened_lock);
  }
}

uint64_t CA::Render::Context::copy_slot(CA::Render::Context *this)
{
  unsigned int v1 = this;
  os_unfair_lock_lock(&CA::Render::Context::_context_lock);
  if (CA::Render::Context::_slot_table)
  {
    uint64_t v2 = x_hash_table_lookup(CA::Render::Context::_slot_table, v1, 0);
    uint64_t v3 = v2;
    if (v2 && !atomic_fetch_add((atomic_uint *volatile)(v2 + 8), 1u))
    {
      uint64_t v3 = 0;
      atomic_fetch_add((atomic_uint *volatile)(v2 + 8), 0xFFFFFFFF);
    }
  }
  else
  {
    uint64_t v3 = 0;
  }
  os_unfair_lock_unlock(&CA::Render::Context::_context_lock);
  return v3;
}

CA::Render::Proxy *CA::Render::Proxy::Proxy(CA::Render::Proxy *this, CA::Render::Decoder *a2)
{
  *(void *)this = &unk_1ED02F670;
  *((_DWORD *)this + 2) = 1;
  *((_DWORD *)this + 3) = (CA::Render::Decoder::decode_int32(a2) << 8) | 0x2B;
  ++dword_1EB2ADE74;
  *(void *)this = &unk_1ED02F4B0;
  *((void *)this + 2) = CA::Render::Decoder::decode_int64(a2);
  return this;
}

atomic_uint *CA::Render::PortalLayer::commit_layer(CA::Render::PortalLayer *this, CA::Render::Context *a2, CA::Render::Layer *a3, CA::Render::Handle *a4, int a5)
{
  uint64_t v6 = a2;
  v44[1] = *(CA::Render::Handle **)MEMORY[0x1E4F143B8];
  if ((a5 & 0x200000) == 0)
  {
    uint64_t v8 = *((void *)this + 7);
    if (v8 && (a2 = *(CA::Render::Context **)(v8 + 48)) != 0)
    {
      v44[0] = 0;
      CA::Render::Handle::Dependence::retain_source_handle((CA::Render::Handle::Dependence *)v44, (uint64_t)a2);
      uint64_t v9 = v44[0];
      if (v44[0])
      {
        CA::Render::Handle::set_update_flags(v44[0], 24);
        *((void *)v9 + 12) |= 3uLL;
        if (atomic_fetch_add((atomic_uint *volatile)v9 + 2, 0xFFFFFFFF) == 1) {
          (*(void (**)(CA::Render::Handle *))(*(void *)v9 + 16))(v9);
        }
      }
    }
    else
    {
      uint64_t v10 = *((void *)a4 + 2);
      if (v10)
      {
        unsigned int v11 = *(uint64_t **)(v10 + 128);
        if (v11)
        {
          uint64_t v12 = *v11;
          if (v12)
          {
            if (*(unsigned char *)(v12 + 12) == 40)
            {
              uint64_t v13 = *(void *)(v12 + 56);
              if (v13)
              {
                a2 = *(CA::Render::Context **)(v13 + 48);
                if (a2)
                {
                  v44[0] = 0;
                  CA::Render::Handle::Dependence::retain_source_handle((CA::Render::Handle::Dependence *)v44, (uint64_t)a2);
                  __int16 v14 = (atomic_uint *)v44[0];
                  if (v44[0])
                  {
                    *((void *)v44[0] + 12) |= 0x18uLL;
                    if (atomic_fetch_add(v14 + 2, 0xFFFFFFFF) == 1) {
                      (*(void (**)(atomic_uint *))(*(void *)v14 + 16))(v14);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  BOOL result = (atomic_uint *)*((void *)this + 7);
  if ((a5 & 0x10000) != 0 && result)
  {
    *((void *)this + 7) = 0;
    if (atomic_fetch_add(result + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *, CA::Render::Context *, CA::Render::Layer *, CA::Render::Handle *))(*(void *)result + 16))(result, a2, a3, a4);
    }
    BOOL result = (atomic_uint *)*((void *)this + 7);
  }
  if (result) {
    goto LABEL_23;
  }
  uint64_t v23 = (CA::Render::Context *)*((unsigned int *)v6 + 4);
  int v24 = (CA::Render::Context *)*((unsigned int *)this + 10);
  uint64_t v25 = *((void *)this + 3);
  uint64_t v26 = *((void *)this + 4);
  int v27 = *((_DWORD *)this + 3);
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::PortalState::_list_lock);
  for (uint64_t i = CA::Render::PortalState::_list; i; uint64_t i = *(void *)(i + 16))
  {
    if (*(_DWORD *)(i + 24) == v23
      && *(void *)(i + 32) == v25
      && *(_DWORD *)(i + 28) == v24
      && *(void *)(i + 40) == v26)
    {
      if (atomic_fetch_add((atomic_uint *volatile)(i + 8), 1u)) {
        goto LABEL_76;
      }
      atomic_fetch_add((atomic_uint *volatile)(i + 8), 0xFFFFFFFF);
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::PortalState::_list_lock);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  unsigned int v30 = malloc_type_zone_calloc(malloc_zone, 1uLL, 0xD8uLL, 0x743898A5uLL);
  uint64_t i = (uint64_t)v30;
  if (v30)
  {
    v30[26] = 0;
    *((_OWORD *)v30 + 11) = 0u;
    *((_OWORD *)v30 + 12) = 0u;
    *((_OWORD *)v30 + 9) = 0u;
    *((_OWORD *)v30 + 10) = 0u;
    *((_OWORD *)v30 + 7) = 0u;
    *((_OWORD *)v30 + 8) = 0u;
    *((_OWORD *)v30 + 5) = 0u;
    *((_OWORD *)v30 + 6) = 0u;
    *((_OWORD *)v30 + 3) = 0u;
    *((_OWORD *)v30 + 4) = 0u;
    *((_OWORD *)v30 + 1) = 0u;
    *((_OWORD *)v30 + 2) = 0u;
    *((_DWORD *)v30 + 2) = 1;
    *((_DWORD *)v30 + 3) = 41;
    ++dword_1EB2ADE6C;
    *unsigned int v30 = &unk_1ED02D200;
  }
  *((_DWORD *)v30 + 6) = v23;
  *((_DWORD *)v30 + 7) = v24;
  v30[4] = v25;
  void v30[5] = v26;
  if ((v27 & 0x2000) != 0) {
    *((_DWORD *)v30 + 3) |= 0x200u;
  }
  uint64_t v31 = CA::Render::Context::context_by_id(v24);
  if (v31)
  {
    __int16 v32 = *(_WORD *)(v31 + 552);
    if ((v32 & 8) != 0)
    {
      *(_DWORD *)(i + 12) |= 0x400u;
      __int16 v32 = *(_WORD *)(v31 + 552);
    }
    if ((v32 & 0x10) != 0) {
      *(_DWORD *)(i + 12) |= 0x800u;
    }
    if (atomic_fetch_add((atomic_uint *volatile)(v31 + 8), 0xFFFFFFFF) == 1) {
      (*(void (**)(uint64_t))(*(void *)v31 + 16))(v31);
    }
  }
  uint64_t v33 = CA::Render::Context::context_by_id(v23);
  if (v33)
  {
    if ((*(_WORD *)(v33 + 552) & 0x20) != 0) {
      *(_DWORD *)(i + 12) |= 0x1000u;
    }
    if (atomic_fetch_add((atomic_uint *volatile)(v33 + 8), 0xFFFFFFFF) == 1) {
      (*(void (**)(uint64_t))(*(void *)v33 + 16))(v33);
    }
  }
  if (v24 == v23)
  {
    if (!v26 || !v23 || v26 == v25) {
      goto LABEL_75;
    }
  }
  else if (!v24 || !v26)
  {
    goto LABEL_75;
  }
  int v34 = (malloc_zone_t *)get_malloc_zone();
  BOOL v35 = malloc_type_zone_malloc(v34, 0x40uLL, 0x8BB15036uLL);
  if (v35)
  {
    double v35[2] = v24;
    v35[3] = v23;
    *((void *)v35 + 2) = v26;
    *((void *)v35 + 3) = v25;
    *((void *)v35 + 4) = 0;
    *((void *)v35 + 5) = 0;
    *(void *)BOOL v35 = &unk_1ED02D1D8;
    *((void *)v35 + 6) = i;
    v35[14] = 0;
    *(void *)(i + 48) = v35;
  }
  else
  {
    *(void *)(i + 48) = 0;
  }
  CA::Render::Handle::add_dependence((uint64_t)v35);
LABEL_75:
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::PortalState::_list_lock);
  *(void *)(i + 16) = CA::Render::PortalState::_list;
  CA::Render::PortalState::_list = i;
LABEL_76:
  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::PortalState::_list_lock);
  BOOL result = (atomic_uint *)*((void *)this + 7);
  *((void *)this + 7) = i;
  if (result && atomic_fetch_add(result + 2, 0xFFFFFFFF) == 1) {
    BOOL result = (atomic_uint *)(*(uint64_t (**)(atomic_uint *))(*(void *)result + 16))(result);
  }
LABEL_23:
  if ((a5 & 0x10000) != 0)
  {
    uint64_t v16 = *((void *)this + 7);
    if (v16)
    {
      uint64_t v17 = *(void *)(v16 + 48);
      if (v17)
      {
        v44[0] = 0;
        BOOL result = (atomic_uint *)CA::Render::Handle::Dependence::retain_source_handle((CA::Render::Handle::Dependence *)v44, v17);
        size_t v18 = v44[0];
        if (v44[0])
        {
          *((void *)v44[0] + 12) |= 0x1BuLL;
          int v19 = (atomic_uint *)((char *)v18 + 8);
          if (!atomic_fetch_add((atomic_uint *volatile)v18 + 2, 1u))
          {
            size_t v18 = 0;
            atomic_fetch_add(v19, 0xFFFFFFFF);
          }
          uint64_t v21 = (CA::Render::Handle **)*((void *)v6 + 50);
          unint64_t v20 = *((void *)v6 + 51);
          if ((unint64_t)v21 >= v20)
          {
            unsigned int v36 = (void *)*((void *)v6 + 49);
            uint64_t v37 = v21 - (CA::Render::Handle **)v36;
            unint64_t v38 = v37 + 1;
            if ((unint64_t)(v37 + 1) >> 61) {
              abort();
            }
            uint64_t v39 = v20 - (void)v36;
            if (v39 >> 2 > v38) {
              unint64_t v38 = v39 >> 2;
            }
            if ((unint64_t)v39 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v40 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v40 = v38;
            }
            if (v40)
            {
              if (v40 >> 61) {
                std::__throw_bad_array_new_length[abi:nn180100]();
              }
              uint64_t v41 = (char *)operator new(8 * v40);
            }
            else
            {
              uint64_t v41 = 0;
            }
            int v42 = (CA::Render::Handle **)&v41[8 * v37];
            *int v42 = v18;
            uint64_t v22 = v42 + 1;
            if (v21 != v36)
            {
              do
              {
                uint64_t v43 = *--v21;
                *--int v42 = v43;
              }
              while (v21 != v36);
              uint64_t v21 = (CA::Render::Handle **)*((void *)v6 + 49);
            }
            *((void *)v6 + 49) = v42;
            *((void *)v6 + 50) = v22;
            *((void *)v6 + 51) = &v41[8 * v40];
            if (v21) {
              operator delete(v21);
            }
          }
          else
          {
            *uint64_t v21 = v18;
            uint64_t v22 = v21 + 1;
          }
          *((void *)v6 + 50) = v22;
          BOOL result = (atomic_uint *)v44[0];
          if (v44[0] && atomic_fetch_add((atomic_uint *volatile)v44[0] + 2, 0xFFFFFFFF) == 1) {
            BOOL result = (atomic_uint *)(*(uint64_t (**)(atomic_uint *))(*(void *)result + 16))(result);
          }
        }
      }
    }
  }
  *((void *)this + 2) = v6;
  return result;
}

CA::Render::ReplicatorLayer *CA::Render::ReplicatorLayer::ReplicatorLayer(CA::Render::ReplicatorLayer *this, CA::Render::Decoder *a2)
{
  *(void *)this = &unk_1ED02F670;
  *((_DWORD *)this + 2) = 1;
  *((_DWORD *)this + 3) = (CA::Render::Decoder::decode_int32(a2) << 8) | 0x2C;
  ++dword_1EB2ADE78;
  *(void *)this = &unk_1ED02E208;
  *((_DWORD *)this + 4) = CA::Render::Decoder::decode_int32(a2);
  *((void *)this + 3) = CA::Render::Decoder::decode_object(a2, 56);
  CA::Render::Decoder::decode_bytes(a2, (char *)this + 32, 0x24uLL);
  uint64_t v4 = *((void *)this + 3);
  if (v4)
  {
    unsigned int v5 = *(_DWORD *)(v4 + 16);
    if (v5 <= 3)
    {
      CA::Render::Decoder::set_fatal_error(a2, "%s - _instance_transform size %u", "ReplicatorLayer", v5);
      uint64_t v6 = (atomic_uint *)*((void *)this + 3);
      if (v6)
      {
        if (atomic_fetch_add(v6 + 2, 0xFFFFFFFF) == 1) {
          (*(void (**)(atomic_uint *))(*(void *)v6 + 16))(v6);
        }
        *((void *)this + 3) = 0;
      }
    }
  }
  return this;
}

CA::Render::GainMapLayer *CA::Render::GainMapLayer::GainMapLayer(CA::Render::GainMapLayer *this, CA::Render::Decoder *a2)
{
  *(void *)this = &unk_1ED02F670;
  *((_DWORD *)this + 2) = 1;
  *((_DWORD *)this + 3) = (CA::Render::Decoder::decode_int32(a2) << 8) | 0x13;
  ++dword_1EB2ADE14;
  *(void *)this = &unk_1ED02D3E8;
  unsigned int v4 = CA::Render::Decoder::decode_int8(a2);
  if (v4 >= 4)
  {
    CA::Render::Decoder::set_fatal_error(a2, "%s - enum %u out of range of %u", "decode_int8_enum", v4, 4);
    LOBYTE(v4) = 0;
  }
  *((unsigned char *)this + 16) = v4;
  return this;
}

CA::Render::PortalLayer *CA::Render::PortalLayer::PortalLayer(CA::Render::PortalLayer *this, CA::Render::Decoder *a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  *(void *)this = &unk_1ED02F670;
  *((_DWORD *)this + 2) = 1;
  *((_DWORD *)this + 3) = (CA::Render::Decoder::decode_int32(a2) << 8) | 0x28;
  ++dword_1EB2ADE68;
  *(void *)this = &unk_1ED02D0D0;
  *((void *)this + 3) = CA::Render::Decoder::decode_size_t(a2);
  *((void *)this + 4) = CA::Render::Decoder::decode_size_t(a2);
  *((_DWORD *)this + 10) = CA::Render::Decoder::decode_int32(a2);
  int v8 = 28;
  unsigned int v4 = CA::Render::Decoder::decode_array_object(a2, 1, &v8, 0);
  if (v4)
  {
    unsigned int v5 = v4 + 2;
    uint64_t v6 = v4;
    if (!atomic_fetch_add(v4 + 2, 1u))
    {
      uint64_t v6 = 0;
      atomic_fetch_add(v5, 0xFFFFFFFF);
    }
    *((void *)this + 6) = v6;
    if (atomic_fetch_add(v5, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v4 + 16))(v4);
    }
  }
  else
  {
    *((void *)this + 6) = 0;
  }
  *((void *)this + 7) = 0;
  return this;
}

void CA::Render::Context::set_slot(CA::Render::Context *this, unsigned int a2, atomic_uint *a3)
{
  if (a2 && CA::Render::Context::_slot_table)
  {
    uint64_t v5 = *((void *)this + 21);
    uint64_t v6 = *((void *)this + 22);
    if (v5 != v6)
    {
      while (*(_DWORD *)v5 != a2)
      {
        v5 += 8;
        if (v5 == v6) {
          return;
        }
      }
    }
    if (v5 != v6 && !*(unsigned char *)(v5 + 4))
    {
      os_unfair_lock_lock(&CA::Render::Context::_context_lock);
      uint64_t v7 = a2;
      int v8 = (atomic_uint *)x_hash_table_lookup(CA::Render::Context::_slot_table, a2, 0);
      uint64_t v9 = (int *)CA::Render::Context::_slot_table;
      if (a3)
      {
        uint64_t v10 = a3 + 2;
        if (!atomic_fetch_add(a3 + 2, 1u))
        {
          a3 = 0;
          atomic_fetch_add(v10, 0xFFFFFFFF);
        }
      }
      hash_table_modify(v9, v7, (uint64_t)a3, 0);
      os_unfair_lock_unlock(&CA::Render::Context::_context_lock);
      if (v8 && atomic_fetch_add(v8 + 2, 0xFFFFFFFF) == 1)
      {
        unsigned int v11 = *(void (**)(atomic_uint *))(*(void *)v8 + 16);
        v11(v8);
      }
    }
  }
}

CA::Render::MatchMoveAnimation *CA::Render::MatchMoveAnimation::MatchMoveAnimation(CA::Render::MatchMoveAnimation *this, CA::Render::Decoder *a2)
{
  matched = CA::Render::MatchAnimation::MatchAnimation(this, a2);
  *((unsigned char *)matched + 12) = 31;
  ++dword_1EB2ADE44;
  *(void *)matched = &unk_1ED02EB00;
  *((void *)this + 17) = CA::Render::Decoder::decode_object(a2, 56);
  return this;
}

uint64_t CA::Render::MatchMoveAnimation::validate(uint64_t a1)
{
  if (!*(void *)(a1 + 104)) {
    return 0;
  }
  if (!*(_DWORD *)(a1 + 112)) {
    return 0;
  }
  unint64_t v1 = *(void *)(a1 + 120);
  if (!v1 || (v1 & 1) == 0 && !*(_DWORD *)v1) {
    return 0;
  }
  uint64_t v2 = *(void *)(a1 + 136);
  if (!v2 || !*(_DWORD *)(v2 + 16)) {
    return 0;
  }
  if (v1)
  {
    v1 >>= 1;
  }
  else
  {
    if (!*(_DWORD *)v1)
    {
LABEL_14:
      *(_DWORD *)(a1 + 12) |= 0x4000u;
      return 1;
    }
    LODWORD(v1) = *(_DWORD *)(v1 + 4);
  }
  if (v1 != 438) {
    goto LABEL_14;
  }
  return 1;
}

uint64_t CA::Render::GroupAnimation::validate(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 96);
  if (!v2 || !*(_DWORD *)(v2 + 16)) {
    return 1;
  }
  unint64_t v4 = 0;
  do
  {
    uint64_t result = (*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 24 + 8 * v4) + 136))(*(void *)(v2 + 24 + 8 * v4), a2);
    if ((result & 1) == 0) {
      break;
    }
    ++v4;
  }
  while (v4 < *(unsigned int *)(v2 + 16));
  return result;
}

uint64_t CA::Layer::commit_if_needed(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v6 = a2[24];
  if ((v6 & 0x80000000) != 0 || (v7 = a1 + 4 * v6, (int v8 = *(_DWORD *)(v7 + 272)) == 0))
  {
    uint64_t v9 = CA::Layer::thread_flags_((CA::Layer *)a1, (CA::Transaction *)a2);
    int v8 = *v9;
  }
  else
  {
    uint64_t v9 = (int *)(v7 + 272);
  }
  if ((*(_DWORD *)(a1 + 4) & 0x2000000) != 0)
  {
    v8 |= 0x200018u;
    *uint64_t v9 = v8;
  }
  if ((*(_DWORD *)(a1 + 4) & 0x2200418) != 0)
  {
    atomic_fetch_and((atomic_uint *volatile)(a1 + 4), ~(v8 & 0x2200418));
    int v8 = *v9;
  }
  if ((v8 & 0x18) == 0 && *(_DWORD *)(a1 + 264)) {
    return 0;
  }
  uint64_t v10 = *(void **)(a1 + 24);
  if (v10)
  {
    unsigned int v11 = v10 + 1;
    uint64_t v12 = v10[2];
    if (v12 == 1)
    {
      if (!v10[3])
      {
LABEL_18:
        char v14 = 0;
        do
        {
          uint64_t v15 = *v11++;
          if (CA::Layer::commit_if_needed(*(void *)(v15 + 16), a2, a3)) {
            char v14 = 1;
          }
          --v12;
        }
        while (v12);
        uint64_t v13 = v14 & 1;
        goto LABEL_24;
      }
LABEL_17:
      unsigned int v11 = (uint64_t *)*v11;
      goto LABEL_18;
    }
    if (v12) {
      goto LABEL_17;
    }
  }
  uint64_t v13 = 0;
LABEL_24:
  uint64_t v16 = *(void *)(a1 + 32);
  if (v16) {
    uint64_t v13 = CA::Layer::commit_if_needed(*(void *)(v16 + 16), a2, a3) | v13;
  }
  if (!*(_DWORD *)(a1 + 264))
  {
    do
      unsigned int add = atomic_fetch_add(CA::Render::next_sequence(void)::sequence, 1u);
    while (add == -1);
    *(_DWORD *)(a1 + 264) = add + 1;
  }
  (*(void (**)(uint64_t, uint64_t, void))(a3 + 16))(a3, a1, *v9);
  int v18 = *v9;
  if ((*(unsigned char *)(a1 + 41) & 0x10) != 0)
  {
    v18 |= 0x80000u;
    *uint64_t v9 = v18;
    uint64_t v13 = 1;
  }
  if ((v18 & 8) != 0)
  {
    *(_DWORD *)(a1 + 40) = 0;
    int v18 = *v9;
  }
  unsigned int v19 = v18 & 0xFDDFBBE7;
  if (v13) {
    int v20 = 18432;
  }
  else {
    int v20 = 0x4000;
  }
  *uint64_t v9 = v19 | v20;
  return v13;
}

uint64_t ___ZN2CA7Context18commit_transactionEPNS_11TransactionEdPd_block_invoke(uint64_t a1, id *a2, int a3, const __CFString *a4, CALayer *a5, CA::Render::TimingList *(*a6)(CA::Layer *, void *), void *a7)
{
  unsigned int v7 = a4;
  unsigned int v11 = *(CA::Transaction ***)(a1 + 40);
  uint64_t v12 = *v11;
  char v13 = *(unsigned char *)(*((void *)*v11 + 13) + 204);
  if ((v13 & 0x20) == 0)
  {
    kdebug_trace();
    uint64_t v12 = *v11;
  }
  if ((a3 & 0x200000) != 0)
  {
    v11[6] = (CA::Transaction *)0xBFF0000000000000;
    CA::Layer::commit_animations((CA::Layer *)a2, v12, (__CFString *)v11, a4, a5, a6, a7);
  }
  char v14 = (atomic_uint *)objc_msgSend(a2[2], "_copyRenderLayer:layerFlags:commitFlags:");
  if (v14)
  {
    uint64_t v15 = v11[4];
    if (v15)
    {
      if (CA::Render::Encoder::initialize_render_id_slide(void)::once[0] != -1) {
        dispatch_once(CA::Render::Encoder::initialize_render_id_slide(void)::once, &__block_literal_global_13615);
      }
      if (a2) {
        uint64_t v16 = (CA::Render::Encoder *)((char *)a2 + CA::Render::_render_id_slide);
      }
      else {
        uint64_t v16 = 0;
      }
      CA::Render::encode_set_object(v15, v16, v7, (CA::Render::Object *)v14, 0);
    }
    uint64_t v17 = v11[5];
    if (v17)
    {
      if (CA::Render::Encoder::initialize_render_id_slide(void)::once[0] != -1) {
        dispatch_once(CA::Render::Encoder::initialize_render_id_slide(void)::once, &__block_literal_global_13615);
      }
      if (a2) {
        unint64_t v18 = (unint64_t)a2 + CA::Render::_render_id_slide;
      }
      else {
        unint64_t v18 = 0;
      }
      CA::Render::Context::set_object(v17, v18, v7, (CA::Render::Object *)v14);
    }
    else if (atomic_fetch_add(v14 + 2, 0xFFFFFFFF) == 1)
    {
      (*(void (**)(atomic_uint *))(*(void *)v14 + 16))(v14);
    }
  }
  uint64_t result = [a2[2] _didCommitLayer:*v11];
  *((unsigned char *)v11 + 56) = 1;
  if ((v13 & 0x20) == 0) {
    uint64_t result = kdebug_trace();
  }
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void sub_1846BC184(_Unwind_Exception *exception_object)
{
  if ((v1 & 0x20) == 0) {
    kdebug_trace();
  }
  _Unwind_Resume(exception_object);
}

CA::Layer *CA::Layer::sublayers(CA::Layer *this)
{
  while (1)
  {
    char v1 = this;
    v12[1] = *MEMORY[0x1E4F143B8];
    if ((*((_DWORD *)this + 1) & 0x60000) == 0) {
      return (CA::Layer *)*((void *)v1 + 3);
    }
    if ((*((_DWORD *)this + 1) & 0x60000) == 0x20000) {
      break;
    }
    unsigned int v7 = CA::Transaction::ensure_compat(this);
    this = CA::Layer::model_layer(v1, v7);
    if (!this) {
      return this;
    }
  }
  this = (CA::Layer *)*((void *)this + 3);
  if (!this)
  {
    uint64_t v2 = CA::Transaction::ensure_compat(0);
    this = CA::Layer::model_layer(v1, v2);
    if (this)
    {
      uint64_t v3 = (void *)*((void *)this + 3);
      if (!v3) {
        return 0;
      }
      uint64_t v4 = v3[2];
      unint64_t v5 = 8 * v4;
      if ((unint64_t)(8 * v4) > 0x1000)
      {
        uint64_t v6 = (char *)malloc_type_malloc(8 * v4, 0x80040B8603338uLL);
        if (!v6) {
          return (CA::Layer *)*((void *)v1 + 3);
        }
      }
      else
      {
        MEMORY[0x1F4188790](this);
        uint64_t v6 = (char *)v12 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
        bzero(v6, 8 * v4);
      }
      uint64_t v8 = 0;
      if (v4)
      {
        for (uint64_t i = 0; i != v4; ++i)
        {
          uint64_t v10 = v3 + 1;
          if (v3[2] != 1 || v3[3]) {
            uint64_t v10 = (void *)*v10;
          }
          unsigned int v11 = CA::Layer::presentation_layer(*(CA::Layer **)(v10[i] + 16), (CA::Transaction::Shared **)v2);
          if (v11) {
            *(void *)&v6[8 * v8++] = v11;
          }
        }
      }
      *((void *)v1 + 3) = [[CALayerArray alloc] initWithLayers:v6 count:v8 retain:1];
      if (v5 > 0x1000) {
        free(v6);
      }
      return (CA::Layer *)*((void *)v1 + 3);
    }
  }
  return this;
}

void *CA::Render::encode_set_object(CA::Render *this, CA::Render::Encoder *a2, int a3, CA::Render::Object *a4, CA::Render::Object *a5)
{
  int v5 = (int)a5;
  uint64_t v10 = (unsigned char *)*((void *)this + 4);
  if ((unint64_t)(v10 + 1) > *((void *)this + 5))
  {
    CA::Render::Encoder::grow(this, 1);
    uint64_t v10 = (unsigned char *)*((void *)this + 4);
  }
  *((void *)this + 4) = v10 + 1;
  *uint64_t v10 = 2;
  unsigned int v11 = (void *)*((void *)this + 4);
  if ((unint64_t)(v11 + 1) > *((void *)this + 5))
  {
    CA::Render::Encoder::grow(this, 8);
    unsigned int v11 = (void *)*((void *)this + 4);
  }
  *unsigned int v11 = a2;
  uint64_t v12 = *((void *)this + 4);
  unint64_t v13 = *((void *)this + 5);
  char v14 = (_DWORD *)(v12 + 8);
  *((void *)this + 4) = v12 + 8;
  if (v12 + 12 > v13)
  {
    CA::Render::Encoder::grow(this, 4);
    char v14 = (_DWORD *)*((void *)this + 4);
  }
  _DWORD *v14 = a3;
  *((void *)this + 4) += 4;
  uint64_t result = CA::Render::Encoder::encode_object_uncached(this, a4);
  uint64_t v16 = (_DWORD *)*((void *)this + 4);
  if ((unint64_t)(v16 + 1) > *((void *)this + 5))
  {
    uint64_t result = CA::Render::Encoder::grow(this, 4);
    uint64_t v16 = (_DWORD *)*((void *)this + 4);
  }
  *uint64_t v16 = v5;
  *((void *)this + 4) += 4;
  return result;
}

void CA::Render::Layer::encode(CA::Render::Layer *this, CA::Render::Encoder *a2)
{
  CA::Render::Object::encode(this, a2);
  uint64_t v4 = (_OWORD *)*((void *)a2 + 4);
  if ((unint64_t)(v4 + 5) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 80);
    uint64_t v4 = (_OWORD *)*((void *)a2 + 4);
  }
  *uint64_t v4 = *((_OWORD *)this + 1);
  long long v5 = *((_OWORD *)this + 2);
  long long v6 = *((_OWORD *)this + 3);
  long long v7 = *((_OWORD *)this + 5);
  void v4[3] = *((_OWORD *)this + 4);
  v4[4] = v7;
  v4[1] = v5;
  v4[2] = v6;
  *((void *)a2 + 4) += 80;
  CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)this + 12));
  CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)this + 13));
  uint64_t v8 = *((void *)this + 14);
  uint64_t v9 = (void *)*((void *)a2 + 4);
  if ((unint64_t)(v9 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 8);
    uint64_t v9 = (void *)*((void *)a2 + 4);
  }
  *uint64_t v9 = v8;
  *((void *)a2 + 4) += 8;
  CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)this + 15));
  BOOL v10 = *((void *)this + 16) != 0;
  unsigned int v11 = (BOOL *)*((void *)a2 + 4);
  if ((unint64_t)(v11 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 1);
    unsigned int v11 = (BOOL *)*((void *)a2 + 4);
  }
  *((void *)a2 + 4) = v11 + 1;
  *unsigned int v11 = v10;
  uint64_t v12 = *((void *)this + 16);
  if (v12)
  {
    CA::Render::Encoder::encode_object(a2, *(const CA::Render::Object **)v12);
    CA::Render::Encoder::encode_object(a2, *(const CA::Render::Object **)(v12 + 8));
    CA::Render::Encoder::encode_object(a2, *(const CA::Render::Object **)(v12 + 16));
    CA::Render::Encoder::encode_object(a2, *(const CA::Render::Object **)(v12 + 24));
    CA::Render::Encoder::encode_object(a2, *(const CA::Render::Object **)(v12 + 32));
    CA::Render::Encoder::encode_object(a2, *(const CA::Render::Object **)(v12 + 40));
    CA::Render::Encoder::encode_object(a2, *(const CA::Render::Object **)(v12 + 48));
    CA::Render::Encoder::encode_object(a2, *(const CA::Render::Object **)(v12 + 56));
    CA::Render::Encoder::encode_object(a2, *(const CA::Render::Object **)(v12 + 64));
    CA::Render::Encoder::encode_object(a2, *(const CA::Render::Object **)(v12 + 72));
    CA::Render::Encoder::encode_object(a2, *(const CA::Render::Object **)(v12 + 80));
    CA::Render::Encoder::encode_object(a2, *(const CA::Render::Object **)(v12 + 88));
    CA::Render::Encoder::encode_object(a2, *(const CA::Render::Object **)(v12 + 96));
    CA::Render::Encoder::encode_object(a2, *(const CA::Render::Object **)(v12 + 104));
    CA::Render::Encoder::encode_object(a2, *(const CA::Render::Object **)(v12 + 112));
    CA::Render::Encoder::encode_object(a2, *(const CA::Render::Object **)(v12 + 120));
    CA::Render::Encoder::encode_object(a2, *(const CA::Render::Object **)(v12 + 128));
    CA::Render::Encoder::encode_object(a2, *(const CA::Render::Object **)(v12 + 136));
    unint64_t v13 = (_OWORD *)*((void *)a2 + 4);
    if ((unint64_t)(v13 + 1) > *((void *)a2 + 5))
    {
      CA::Render::Encoder::grow(a2, 16);
      unint64_t v13 = (_OWORD *)*((void *)a2 + 4);
    }
    _OWORD *v13 = *(_OWORD *)(v12 + 152);
    uint64_t v14 = *((void *)a2 + 4);
    unint64_t v15 = *((void *)a2 + 5);
    uint64_t v16 = (_OWORD *)(v14 + 16);
    *((void *)a2 + 4) = v14 + 16;
    if (v14 + 32 > v15)
    {
      CA::Render::Encoder::grow(a2, 16);
      uint64_t v16 = (_OWORD *)*((void *)a2 + 4);
    }
    *uint64_t v16 = *(_OWORD *)(v12 + 168);
    uint64_t v17 = *((void *)a2 + 4);
    unint64_t v18 = *((void *)a2 + 5);
    unsigned int v19 = (void *)(v17 + 16);
    *((void *)a2 + 4) = v17 + 16;
    uint64_t v20 = *(void *)(v12 + 184);
    if (v17 + 24 > v18)
    {
      CA::Render::Encoder::grow(a2, 8);
      unsigned int v19 = (void *)*((void *)a2 + 4);
    }
    void *v19 = v20;
    uint64_t v21 = *((void *)a2 + 4);
    unint64_t v22 = *((void *)a2 + 5);
    uint64_t v23 = (void *)(v21 + 8);
    *((void *)a2 + 4) = v21 + 8;
    uint64_t v24 = *(void *)(v12 + 192);
    if (v21 + 16 > v22)
    {
      CA::Render::Encoder::grow(a2, 8);
      uint64_t v23 = (void *)*((void *)a2 + 4);
    }
    *uint64_t v23 = v24;
    uint64_t v25 = *((void *)a2 + 4);
    unint64_t v26 = *((void *)a2 + 5);
    int v27 = (_OWORD *)(v25 + 8);
    *((void *)a2 + 4) = v25 + 8;
    if (v25 + 24 > v26)
    {
      CA::Render::Encoder::grow(a2, 16);
      int v27 = (_OWORD *)*((void *)a2 + 4);
    }
    _OWORD *v27 = *(_OWORD *)(v12 + 200);
    uint64_t v28 = *((void *)a2 + 4);
    unint64_t v29 = *((void *)a2 + 5);
    unsigned int v30 = (void *)(v28 + 16);
    *((void *)a2 + 4) = v28 + 16;
    if (v28 + 24 > v29)
    {
      CA::Render::Encoder::grow(a2, 8);
      unsigned int v30 = (void *)*((void *)a2 + 4);
    }
    *unsigned int v30 = *(void *)(v12 + 216);
    uint64_t v31 = *((void *)a2 + 4);
    unint64_t v32 = *((void *)a2 + 5);
    uint64_t v33 = (_DWORD *)(v31 + 8);
    *((void *)a2 + 4) = v31 + 8;
    int v34 = *(_DWORD *)(v12 + 224);
    if (v31 + 12 > v32)
    {
      CA::Render::Encoder::grow(a2, 4);
      uint64_t v33 = (_DWORD *)*((void *)a2 + 4);
    }
    *uint64_t v33 = v34;
    uint64_t v35 = *((void *)a2 + 4);
    unint64_t v36 = *((void *)a2 + 5);
    uint64_t v37 = (_DWORD *)(v35 + 4);
    *((void *)a2 + 4) = v35 + 4;
    int v38 = *(_DWORD *)(v12 + 228);
    if (v35 + 8 > v36)
    {
      CA::Render::Encoder::grow(a2, 4);
      uint64_t v37 = (_DWORD *)*((void *)a2 + 4);
    }
    _DWORD *v37 = v38;
    uint64_t v39 = *((void *)a2 + 4);
    unint64_t v40 = *((void *)a2 + 5);
    uint64_t v41 = (_DWORD *)(v39 + 4);
    *((void *)a2 + 4) = v39 + 4;
    int v42 = *(_DWORD *)(v12 + 232);
    if (v39 + 8 > v40)
    {
      CA::Render::Encoder::grow(a2, 4);
      uint64_t v41 = (_DWORD *)*((void *)a2 + 4);
    }
    *uint64_t v41 = v42;
    uint64_t v43 = *((void *)a2 + 4);
    unint64_t v44 = *((void *)a2 + 5);
    uint64_t v45 = (_DWORD *)(v43 + 4);
    *((void *)a2 + 4) = v43 + 4;
    int v46 = *(_DWORD *)(v12 + 236);
    if (v43 + 8 > v44)
    {
      CA::Render::Encoder::grow(a2, 4);
      uint64_t v45 = (_DWORD *)*((void *)a2 + 4);
    }
    *uint64_t v45 = v46;
    uint64_t v47 = *((void *)a2 + 4);
    unint64_t v48 = *((void *)a2 + 5);
    uint64_t v49 = (_OWORD *)(v47 + 4);
    *((void *)a2 + 4) = v47 + 4;
    if (v47 + 20 > v48)
    {
      CA::Render::Encoder::grow(a2, 16);
      uint64_t v49 = (_OWORD *)*((void *)a2 + 4);
    }
    _OWORD *v49 = *(_OWORD *)(v12 + 240);
    uint64_t v50 = *((void *)a2 + 4);
    unint64_t v51 = *((void *)a2 + 5);
    uint64_t v52 = (_DWORD *)(v50 + 16);
    *((void *)a2 + 4) = v50 + 16;
    int v53 = *(_DWORD *)(v12 + 256);
    if (v50 + 20 > v51)
    {
      CA::Render::Encoder::grow(a2, 4);
      uint64_t v52 = (_DWORD *)*((void *)a2 + 4);
    }
    *uint64_t v52 = v53;
    uint64_t v54 = *((void *)a2 + 4);
    unint64_t v55 = *((void *)a2 + 5);
    int v56 = (_DWORD *)(v54 + 4);
    *((void *)a2 + 4) = v54 + 4;
    int v57 = *(_DWORD *)(v12 + 260);
    if (v54 + 8 > v55)
    {
      CA::Render::Encoder::grow(a2, 4);
      int v56 = (_DWORD *)*((void *)a2 + 4);
    }
    *int v56 = v57;
    uint64_t v58 = *((void *)a2 + 4);
    unint64_t v59 = *((void *)a2 + 5);
    unsigned int v60 = (_DWORD *)(v58 + 4);
    *((void *)a2 + 4) = v58 + 4;
    int v61 = *(_DWORD *)(v12 + 264);
    if (v58 + 8 > v59)
    {
      CA::Render::Encoder::grow(a2, 4);
      unsigned int v60 = (_DWORD *)*((void *)a2 + 4);
    }
    *unsigned int v60 = v61;
    uint64_t v62 = *((void *)a2 + 4);
    unint64_t v63 = *((void *)a2 + 5);
    uint64_t v64 = (_OWORD *)(v62 + 4);
    *((void *)a2 + 4) = v62 + 4;
    if (v62 + 20 > v63)
    {
      CA::Render::Encoder::grow(a2, 16);
      uint64_t v64 = (_OWORD *)*((void *)a2 + 4);
    }
    *uint64_t v64 = *(_OWORD *)(v12 + 268);
    uint64_t v65 = *((void *)a2 + 4);
    unint64_t v66 = *((void *)a2 + 5);
    double v67 = (_DWORD *)(v65 + 16);
    *((void *)a2 + 4) = v65 + 16;
    int v68 = *(_DWORD *)(v12 + 284);
    if (v65 + 20 > v66)
    {
      CA::Render::Encoder::grow(a2, 4);
      double v67 = (_DWORD *)*((void *)a2 + 4);
    }
    *double v67 = v68;
    uint64_t v69 = *((void *)a2 + 4);
    unint64_t v70 = *((void *)a2 + 5);
    int v71 = (_DWORD *)(v69 + 4);
    *((void *)a2 + 4) = v69 + 4;
    int v72 = *(_DWORD *)(v12 + 288);
    if (v69 + 8 > v70)
    {
      CA::Render::Encoder::grow(a2, 4);
      int v71 = (_DWORD *)*((void *)a2 + 4);
    }
    _DWORD *v71 = v72;
    uint64_t v73 = *((void *)a2 + 4);
    unint64_t v74 = *((void *)a2 + 5);
    int v75 = (_DWORD *)(v73 + 4);
    *((void *)a2 + 4) = v73 + 4;
    int v76 = *(_DWORD *)(v12 + 292);
    if (v73 + 8 > v74)
    {
      CA::Render::Encoder::grow(a2, 4);
      int v75 = (_DWORD *)*((void *)a2 + 4);
    }
    _DWORD *v75 = v76;
    uint64_t v77 = *((void *)a2 + 4);
    unint64_t v78 = *((void *)a2 + 5);
    uint64_t v79 = (_DWORD *)(v77 + 4);
    *((void *)a2 + 4) = v77 + 4;
    int v80 = *(_DWORD *)(v12 + 296);
    if (v77 + 8 > v78)
    {
      CA::Render::Encoder::grow(a2, 4);
      uint64_t v79 = (_DWORD *)*((void *)a2 + 4);
    }
    _DWORD *v79 = v80;
    uint64_t v81 = *((void *)a2 + 4);
    unint64_t v82 = *((void *)a2 + 5);
    uint64_t v83 = (_DWORD *)(v81 + 4);
    *((void *)a2 + 4) = v81 + 4;
    int v84 = *(_DWORD *)(v12 + 300);
    if (v81 + 8 > v82)
    {
      CA::Render::Encoder::grow(a2, 4);
      uint64_t v83 = (_DWORD *)*((void *)a2 + 4);
    }
    *uint64_t v83 = v84;
    uint64_t v85 = *((void *)a2 + 4);
    unint64_t v86 = *((void *)a2 + 5);
    uint64_t v87 = (_OWORD *)(v85 + 4);
    *((void *)a2 + 4) = v85 + 4;
    if (v85 + 20 > v86)
    {
      CA::Render::Encoder::grow(a2, 16);
      uint64_t v87 = (_OWORD *)*((void *)a2 + 4);
    }
    *uint64_t v87 = *(_OWORD *)(v12 + 304);
    uint64_t v88 = *((void *)a2 + 4);
    unint64_t v89 = *((void *)a2 + 5);
    int v90 = (_DWORD *)(v88 + 16);
    *((void *)a2 + 4) = v88 + 16;
    int v91 = *(_DWORD *)(v12 + 320);
    if (v88 + 20 > v89)
    {
      CA::Render::Encoder::grow(a2, 4);
      int v90 = (_DWORD *)*((void *)a2 + 4);
    }
    *int v90 = v91;
    uint64_t v92 = *((void *)a2 + 4);
    unint64_t v93 = *((void *)a2 + 5);
    unsigned int v94 = (unsigned char *)(v92 + 4);
    *((void *)a2 + 4) = v92 + 4;
    char v95 = *(unsigned char *)(v12 + 324) & 1;
    if (v92 + 5 > v93)
    {
      CA::Render::Encoder::grow(a2, 1);
      unsigned int v94 = (unsigned char *)*((void *)a2 + 4);
    }
    *((void *)a2 + 4) = v94 + 1;
    *unsigned int v94 = v95;
  }
}

void *CA::Render::Encoder::encode_object_uncached(void *this, const CA::Render::Object *a2)
{
  uint64_t v3 = this;
  if (a2) {
    int v4 = *((unsigned __int8 *)a2 + 12);
  }
  else {
    int v4 = 0;
  }
  long long v5 = (unsigned char *)this[4];
  if ((unint64_t)(v5 + 1) > this[5])
  {
    this = CA::Render::Encoder::grow((CA::Render::Encoder *)this, 1);
    long long v5 = (unsigned char *)v3[4];
  }
  v3[4] = v5 + 1;
  *long long v5 = v4;
  if (v4)
  {
    long long v6 = *(uint64_t (**)(const CA::Render::Object *, void *))(*(void *)a2 + 32);
    return (void *)v6(a2, v3);
  }
  return this;
}

void CA::Render::Encoder::encode_object(CA::Render::Encoder *this, const CA::Render::Object *a2)
{
  if (a2
    && *((void *)this + 9)
    && (*(unsigned int (**)(const CA::Render::Object *))(*(void *)a2 + 24))(a2))
  {
    uint64_t v4 = *((void *)this + 9);
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::Encoder::ObjectCache::_lock);
    int v5 = x_hash_table_lookup(*(void *)(v4 + 8), (uint64_t)a2, 0);
    if (v5)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Encoder::ObjectCache::_lock);
      long long v6 = (unsigned char *)*((void *)this + 4);
      if ((unint64_t)(v6 + 1) > *((void *)this + 5))
      {
        CA::Render::Encoder::grow(this, 1);
        long long v6 = (unsigned char *)*((void *)this + 4);
      }
      *((void *)this + 4) = v6 + 1;
      unsigned char *v6 = -1;
      if (CA::Render::Encoder::initialize_render_id_slide(void)::once[0] != -1) {
        dispatch_once(CA::Render::Encoder::initialize_render_id_slide(void)::once, &__block_literal_global_13615);
      }
      long long v7 = (char *)a2 + CA::Render::_render_id_slide;
      uint64_t v8 = (void *)*((void *)this + 4);
      if ((unint64_t)(v8 + 1) > *((void *)this + 5))
      {
        CA::Render::Encoder::grow(this, 8);
        uint64_t v8 = (void *)*((void *)this + 4);
      }
      *uint64_t v8 = v7;
      uint64_t v9 = *((void *)this + 4);
      unint64_t v10 = *((void *)this + 5);
      unsigned int v11 = (_DWORD *)(v9 + 8);
      *((void *)this + 4) = v9 + 8;
      if (v9 + 12 > v10)
      {
        CA::Render::Encoder::grow(this, 4);
        unsigned int v11 = (_DWORD *)*((void *)this + 4);
      }
      *unsigned int v11 = v5;
      *((void *)this + 4) += 4;
      return;
    }
    do
    {
      unsigned int add = atomic_fetch_add(CA::Render::next_sequence(void)::sequence, 1u);
      unsigned int v13 = add + 1;
    }
    while (add == -1);
    hash_table_modify(*(int **)(v4 + 8), (uint64_t)a2, add + 1, 0);
    *((_DWORD *)a2 + 3) |= 0x80000000;
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::Encoder::ObjectCache::_lock);
    uint64_t v14 = (unsigned char *)*((void *)this + 4);
    if ((unint64_t)(v14 + 1) > *((void *)this + 5))
    {
      CA::Render::Encoder::grow(this, 1);
      uint64_t v14 = (unsigned char *)*((void *)this + 4);
    }
    *((void *)this + 4) = v14 + 1;
    unsigned char *v14 = -2;
    if (CA::Render::Encoder::initialize_render_id_slide(void)::once[0] != -1) {
      dispatch_once(CA::Render::Encoder::initialize_render_id_slide(void)::once, &__block_literal_global_13615);
    }
    unint64_t v15 = (char *)a2 + CA::Render::_render_id_slide;
    uint64_t v16 = (void *)*((void *)this + 4);
    if ((unint64_t)(v16 + 1) > *((void *)this + 5))
    {
      CA::Render::Encoder::grow(this, 8);
      uint64_t v16 = (void *)*((void *)this + 4);
    }
    *uint64_t v16 = v15;
    uint64_t v17 = *((void *)this + 4);
    unint64_t v18 = *((void *)this + 5);
    unsigned int v19 = (unsigned int *)(v17 + 8);
    *((void *)this + 4) = v17 + 8;
    if (v17 + 12 > v18)
    {
      CA::Render::Encoder::grow(this, 4);
      unsigned int v19 = (unsigned int *)*((void *)this + 4);
    }
    unsigned int *v19 = v13;
    *((void *)this + 4) += 4;
  }

  CA::Render::Encoder::encode_object_uncached(this, a2);
}

_DWORD *CA::Render::Object::encode(_DWORD *this, CA::Render::Encoder *a2)
{
  unsigned int v3 = this[3];
  uint64_t v4 = (unsigned int *)*((void *)a2 + 4);
  if ((unint64_t)(v4 + 1) > *((void *)a2 + 5))
  {
    this = CA::Render::Encoder::grow(a2, 4);
    uint64_t v4 = (unsigned int *)*((void *)a2 + 4);
  }
  *uint64_t v4 = v3 >> 8;
  *((void *)a2 + 4) += 4;
  return this;
}

uint64_t CA::Render::Object::caches_encoding(CA::Render::Object *this)
{
  return 0;
}

uint64_t CA::Render::Layer::image_filter_from_string(const __CFString *this, const __CFString *a2)
{
  if (this == @"linear") {
    return 1;
  }
  int v2 = (int)a2;
  int v3 = CAInternAtom(this, 0);
  int v4 = v3;
  if (v3 <= 152)
  {
    if (v3 <= 74)
    {
      if (v3 == 40)
      {
        BOOL v5 = v2 == 0;
        unsigned int v6 = 9;
      }
      else
      {
        if (v3 != 41) {
          return 1;
        }
        BOOL v5 = v2 == 0;
        unsigned int v6 = 10;
      }
    }
    else
    {
      switch(v3)
      {
        case 'K':
          BOOL v5 = v2 == 0;
          unsigned int v6 = 5;
          break;
        case 'L':
          BOOL v5 = v2 == 0;
          unsigned int v6 = 6;
          break;
        case 'M':
          BOOL v5 = v2 == 0;
          unsigned int v6 = 7;
          break;
        default:
          return 1;
      }
    }
LABEL_26:
    if (v5) {
      return 1;
    }
    else {
      return v6;
    }
  }
  if (v3 <= 362)
  {
    if (v3 == 153) {
      return 3;
    }
    if (v3 != 341) {
      return 1;
    }
    BOOL v5 = v2 == 0;
    unsigned int v6 = 4;
    goto LABEL_26;
  }
  if (v3 == 363) {
    return 8;
  }
  uint64_t result = 0;
  if (v4 != 398)
  {
    if (v4 != 574) {
      return 1;
    }
    if (v2) {
      return 2;
    }
    else {
      return 1;
    }
  }
  return result;
}

uint64_t CA::Context::current_colorspace(CA::Context *this, CA::Transaction *a2)
{
  if ((this || (this = *(CA::Context **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 576)) != 0)
    && (uint64_t v2 = *((void *)this + 5)) != 0)
  {
    return *(void *)(v2 + 112);
  }
  else
  {
    return CAGetColorSpace(0x1Du);
  }
}

CA::Render::Filter *CA::Render::Filter::Filter(CA::Render::Filter *this, int a2, atomic_uint *a3, atomic_uint *a4)
{
  *((_DWORD *)this + 2) = 1;
  *((_DWORD *)this + 3) = 17;
  ++dword_1EB2ADE0C;
  *(void *)this = &unk_1ED02F590;
  *((void *)this + 2) = 0;
  *((_DWORD *)this + 6) = a2;
  if (a3)
  {
    BOOL v5 = a3 + 2;
    if (!atomic_fetch_add(a3 + 2, 1u))
    {
      a3 = 0;
      atomic_fetch_add(v5, 0xFFFFFFFF);
    }
  }
  *((void *)this + 4) = a3;
  if (a4)
  {
    unsigned int v6 = a4 + 2;
    if (!atomic_fetch_add(a4 + 2, 1u))
    {
      a4 = 0;
      atomic_fetch_add(v6, 0xFFFFFFFF);
    }
  }
  *((void *)this + 5) = a4;
  uint64_t v7 = *((unsigned int *)this + 6);
  if (CA::Render::filter_table
    || (CA::Render::add_filter((CA::Render *)0x1A5, (uint64_t)&CA::OGL::page_curl_filter_init(void)::page_curl, (const CA::Render::FilterSubclass *)a3), CA::Render::add_filter((CA::Render *)0xF7, (uint64_t)CA::OGL::initialize_filters(void)::gaussian_blur_filter, v8), CA::Render::add_filter((CA::Render *)0x24C, (uint64_t)CA::OGL::initialize_filters(void)::variable_blur_filter, v9), CA::Render::add_filter((CA::Render *)0x156, (uint64_t)CA::OGL::initialize_filters(void)::lanczos_resize_filter, v10), CA::Render::add_filter((CA::Render *)0x32, (uint64_t)CA::OGL::initialize_filters(void)::average_color_filter, v11), CA::Render::add_filter((CA::Render *)0x160, (uint64_t)CA::OGL::initialize_filters(void)::limit_apl_filter, v12), CA::Render::add_filter((CA::Render *)0x58,
          (uint64_t)CA::OGL::initialize_filters(void)::chromatic_aberration_filter,
          v13),
        CA::Render::filter_table))
  {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::filter_lock);
    uint64_t v14 = x_hash_table_lookup(CA::Render::filter_table, v7, 0);
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::filter_lock);
  }
  else
  {
    uint64_t v14 = 0;
  }
  *((void *)this + 6) = v14;
  if (CA::Render::Filter::evaluate_identity(this)) {
    *((_DWORD *)this + 3) |= 0x40000u;
  }
  return this;
}

_DWORD *CA::Render::set_list_property<CA::Render::Filter>(uint64_t a1, unint64_t a2, uint64_t a3, int a4, CA::Render::Vector *a5, double *a6)
{
  unsigned int v6 = (_DWORD *)a1;
  if (a1)
  {
    if (a2 >= 2)
    {
      int named_object = CA::Render::TypedArray<CA::Render::Filter>::find_named_object(a1, *(_DWORD *)a3);
      if ((named_object & 0x80000000) == 0)
      {
        int v13 = named_object;
        uint64_t v14 = *(void *)&v6[2 * named_object + 6];
        unint64_t v15 = CA::Render::set_object_property<CA::Render::Filter>(v14, a2 - 1, (const double *)(a3 + 4), a4, a5, a6);
        if (v15 && v15 != (CA::Render::Filter *)v14)
        {
          uint64_t v17 = v15;
          unint64_t v18 = CA::Render::Array::new_array((CA::Render::Array *)v6[4], v6 + 6, (CA::Render::Object *const *)1, 0);
          unsigned int v6 = v18;
          if (v18)
          {
            unsigned int v19 = &v18[2 * v13];
            unint64_t v22 = (atomic_uint *)*((void *)v19 + 3);
            uint64_t v21 = (CA::Render::Filter **)(v19 + 6);
            uint64_t v20 = v22;
            if (v22 && atomic_fetch_add(v20 + 2, 0xFFFFFFFF) == 1) {
              (*(void (**)(atomic_uint *))(*(void *)v20 + 16))(v20);
            }
            *uint64_t v21 = v17;
          }
        }
      }
    }
  }
  return v6;
}

_DWORD *CA::Render::Array::new_array(CA::Render::Array *this, const void *a2, CA::Render::Object *const *a3, int a4)
{
  int v5 = (int)a3;
  unsigned int v7 = this;
  size_t v8 = 8 * this;
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  unint64_t v10 = malloc_type_zone_malloc(malloc_zone, v8 + 24, 0x8BB15036uLL);
  unsigned int v11 = v10;
  if (v10)
  {
    void v10[2] = 1;
    ++dword_1EB2ADDCC;
    *(void *)unint64_t v10 = &unk_1ED02F158;
    v10[3] = (a4 << 8) | 1;
    unsigned int v10[4] = v7;
    uint64_t v12 = v10 + 6;
    if (a2)
    {
      memcpy(v12, a2, v8);
      if (v7 && v5)
      {
        int v13 = v11 + 6;
        uint64_t v14 = v7;
        do
        {
          unint64_t v15 = (atomic_uint *)(*v13 + 8);
          if (!atomic_fetch_add(v15, 1u)) {
            atomic_fetch_add(v15, 0xFFFFFFFF);
          }
          ++v13;
          --v14;
        }
        while (v14);
      }
    }
    else
    {
      bzero(v12, v8);
    }
  }
  return v11;
}

unint64_t CA::Render::TypedArray<CA::Render::Filter>::find_named_object(uint64_t a1, unsigned int a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 16);
  if (!v2) {
    return 0xFFFFFFFFLL;
  }
  if ((a2 & 0x40000000) == 0)
  {
    unint64_t v5 = 0;
    uint64_t v6 = a1 + 24;
    do
    {
      unsigned int v7 = *(CA::Render::String **)(*(void *)(v6 + 8 * v5) + 32);
      if (v7)
      {
        if (CA::Render::String::equal(v7, a2)) {
          return v5;
        }
        unsigned int v2 = *(_DWORD *)(a1 + 16);
      }
      ++v5;
    }
    while (v5 < v2);
    return 0xFFFFFFFFLL;
  }
  if ((a2 & 0xBFFFFFFF) >= v2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return a2 & 0xBFFFFFFF;
  }
}

BOOL CA::Render::String::equal(CA::Render::String *this, unsigned int a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  String = CAAtomGetString(a2);
  CString = CA_CFStringGetCString(String, v6, 1024);
  return strcmp((const char *)this + 28, CString) == 0;
}

const char *CA_CFStringGetCString(const __CFString *a1, char *a2, CFIndex a3)
{
  uint64_t result = CFStringGetCStringPtr(a1, 0x8000100u);
  if (!result)
  {
    if (CFStringGetCString(a1, a2, a3, 0x8000100u)) {
      return a2;
    }
    else {
      return 0;
    }
  }
  return result;
}

CA::Render::Filter *CA::Render::set_object_property<CA::Render::Filter>(uint64_t a1, uint64_t a2, const double *a3, int a4, CA::Render::Vector *this, double *a6)
{
  if (!a1) {
    return 0;
  }
  int v12 = *(_DWORD *)(a1 + 12);
  if ((v12 & 0x8000) != 0)
  {
    uint64_t v16 = (CA::Render::Filter *)a1;
  }
  else
  {
    if (*(_DWORD *)(a1 + 16)) {
      BOOL v13 = 1;
    }
    else {
      BOOL v13 = (*(_DWORD *)(a1 + 12) & 0x200) == 0;
    }
    if (!v13) {
      *(void *)(a1 + 16) = atomic_fetch_add(CA::Render::next_cache_id(void)::cache_id, 1u) + 1;
    }
    uint64_t v14 = *(_DWORD **)(a1 + 40);
    if (v14) {
      unint64_t v15 = CA::Render::Array::new_array((CA::Render::Array *)v14[4], v14 + 6, (CA::Render::Object *const *)1, v14[3] >> 8);
    }
    else {
      unint64_t v15 = 0;
    }
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    unint64_t v18 = (CA::Render::Filter *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x38uLL, 0x743898A5uLL);
    uint64_t v16 = v18;
    if (v18) {
      CA::Render::Filter::Filter(v18, *(_DWORD *)(a1 + 24), *(atomic_uint **)(a1 + 32), v15);
    }
    *((_DWORD *)v16 + 3) |= *(_DWORD *)(a1 + 12) & 0xFFFFFF00;
    *((void *)v16 + 2) = *(void *)(a1 + 16);
    if (v15 && atomic_fetch_add(v15 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v15 + 16))(v15);
    }
    int v12 = *((_DWORD *)v16 + 3) | 0x8000;
    *((_DWORD *)v16 + 3) = v12;
  }
  if (a2 == 1)
  {
    if (this == (CA::Render::Vector *)1 && *(_DWORD *)a3 == 212)
    {
      if (*a6 <= 0.5) {
        unsigned int v19 = v12 & 0xFFFFFEFF;
      }
      else {
        unsigned int v19 = v12 | 0x100;
      }
      *((_DWORD *)v16 + 3) = v19;
    }
    else if (*((void *)v16 + 5))
    {
      uint64_t v20 = CA::Render::Vector::new_vector(this, a6, a3);
      uint64_t v21 = v20;
      unint64_t v22 = (CA::Render::KeyValueArray *)*((void *)v16 + 5);
      int v23 = *(_DWORD *)a3;
      if (a4)
      {
        if (v20)
        {
          unsigned int named_object = CA::Render::KeyValueArray::find_named_object_(*((void *)v16 + 5), v23);
          if ((named_object & 0x80000000) == 0)
          {
            uint64_t v26 = *(void *)(*((void *)v22 + named_object + 3) + 24);
            if (v26)
            {
              if (*(unsigned char *)(v26 + 12) == 56)
              {
                LODWORD(v25) = *(_DWORD *)(v26 + 16);
                unint64_t v27 = (unint64_t)fmin((double)(unint64_t)this, (double)v25);
                if (v27)
                {
                  uint64_t v28 = (double *)(v26 + 24);
                  unint64_t v29 = (double *)(v21 + 6);
                  do
                  {
                    double v30 = *v28++;
                    *unint64_t v29 = *v29 + v30;
                    ++v29;
                    --v27;
                  }
                  while (v27);
                }
              }
            }
          }
        }
      }
      CA::Render::KeyValueArray::set_key(v22, v23, v21);
      if (CA::Render::Filter::evaluate_identity(v16)) {
        int v31 = 0x40000;
      }
      else {
        int v31 = 0;
      }
      *((_DWORD *)v16 + 3) = *((_DWORD *)v16 + 3) & 0xFFFBFFFF | v31;
      if (v21 && atomic_fetch_add(v21 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v21 + 16))(v21);
      }
    }
  }
  return v16;
}

uint64_t CA::Render::Filter::evaluate_identity(CA::Render::Filter *this)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  unsigned int v2 = (uint64_t (***)(void))*((void *)this + 6);
  if (!v2)
  {
    float32x4_t v32 = 0uLL;
    int v5 = *((_DWORD *)this + 6);
    if (v5 <= 266)
    {
      if (v5 <= 106)
      {
        if (v5 != 93)
        {
          if (v5 == 99)
          {
            size_t v8 = (CA::Render::KeyValueArray *)*((void *)this + 5);
            double v7 = 0.0;
            int v14 = 277;
            return CA::Render::KeyValueArray::get_float_key(v8, v14, v7) == 0.0;
          }
          if (v5 != 104) {
            return 0;
          }
          goto LABEL_35;
        }
        return CA::Render::KeyValueArray::get_color_key(*((CA::Render::KeyValueArray **)this + 5), 286, 0) == 0;
      }
      if (v5 != 107)
      {
        if (v5 == 109) {
          return CA::Render::KeyValueArray::get_color_key(*((CA::Render::KeyValueArray **)this + 5), 286, 0) == 0;
        }
        if (v5 == 160)
        {
          uint64_t v9 = *((void *)this + 5);
          if (!v9) {
            return 1;
          }
          uint64_t v10 = *(unsigned int *)(v9 + 16);
          if (!v10) {
            return 1;
          }
          uint64_t v11 = 0;
          while (1)
          {
            uint64_t v12 = *(void *)(v9 + 24 + 8 * v11);
            if (*(_DWORD *)(v12 + 16) == 312) {
              break;
            }
            if (v10 == ++v11) {
              goto LABEL_54;
            }
          }
          if ((v11 & 0x80000000) == 0)
          {
            uint64_t v23 = *(void *)(v12 + 24);
            uint64_t result = v23 == 0;
            if (v23) {
              return result;
            }
          }
LABEL_54:
          uint64_t v24 = 0;
          while (1)
          {
            uint64_t v25 = *(void *)(v9 + 24 + 8 * v24);
            if (*(_DWORD *)(v25 + 16) == 299) {
              break;
            }
            if (v10 == ++v24) {
              goto LABEL_62;
            }
          }
          if ((v24 & 0x80000000) == 0)
          {
            uint64_t v26 = *(void *)(v25 + 24);
            uint64_t result = v26 == 0;
            if (v26) {
              return result;
            }
          }
LABEL_62:
          uint64_t v27 = 0;
          while (1)
          {
            uint64_t v28 = *(void *)(v9 + 24 + 8 * v27);
            if (*(_DWORD *)(v28 + 16) == 284) {
              break;
            }
            if (v10 == ++v27) {
              goto LABEL_68;
            }
          }
          if ((v27 & 0x80000000) == 0)
          {
            uint64_t v29 = *(void *)(v28 + 24);
            uint64_t result = v29 == 0;
            if (v29) {
              return result;
            }
          }
LABEL_68:
          uint64_t v30 = 0;
          uint64_t v31 = v9 + 24;
          uint64_t result = 1;
          while (1)
          {
            uint64_t v19 = *(void *)(v31 + 8 * v30);
            if (*(_DWORD *)(v19 + 16) == 275) {
              break;
            }
            if (v10 == ++v30) {
              return result;
            }
          }
          if ((v30 & 0x80000000) != 0) {
            return 1;
          }
          return *(void *)(v19 + 24) == 0;
        }
        return 0;
      }
      uint64_t v20 = (CA::Render::KeyValueArray *)*((void *)this + 5);
      double v21 = 1.0;
      double v22 = 1.0;
      return CA::Render::KeyValueArray::get_float_key(v20, 276, v22) == v21;
    }
    if (v5 > 395)
    {
      if (v5 == 533)
      {
        uint64_t v20 = (CA::Render::KeyValueArray *)*((void *)this + 5);
        double v21 = 0.5;
        double v22 = 0.5;
        return CA::Render::KeyValueArray::get_float_key(v20, 276, v22) == v21;
      }
      if (v5 == 410)
      {
LABEL_35:
        size_t v8 = (CA::Render::KeyValueArray *)*((void *)this + 5);
        double v7 = 0.0;
        goto LABEL_36;
      }
      if (v5 != 396) {
        return 0;
      }
      if (CA::Render::KeyValueArray::get_float_color_key(*((CA::Render::KeyValueArray **)this + 5), 286, &v32))
      {
        uint64_t result = 0;
        if (v32.f32[0] != 1.0 || v32.f32[1] != 1.0 || v32.f32[2] != 1.0) {
          return result;
        }
        return v32.f32[3] == 1.0;
      }
    }
    else if (v5 != 267)
    {
      if (v5 == 368)
      {
        uint64_t v15 = *((void *)this + 5);
        if (!v15) {
          return 1;
        }
        uint64_t v16 = *(unsigned int *)(v15 + 16);
        if (!v16) {
          return 1;
        }
        uint64_t v17 = 0;
        uint64_t v18 = v15 + 24;
        uint64_t result = 1;
        while (1)
        {
          uint64_t v19 = *(void *)(v18 + 8 * v17);
          if (*(_DWORD *)(v19 + 16) == 321) {
            break;
          }
          if (v16 == ++v17) {
            return result;
          }
        }
        if ((v17 & 0x80000000) != 0) {
          return 1;
        }
        return *(void *)(v19 + 24) == 0;
      }
      if (v5 != 387) {
        return 0;
      }
      uint64_t v6 = (CA::Render::KeyValueArray *)*((void *)this + 5);
      if (CA::Render::KeyValueArray::get_float_key(v6, 314, 1.0) != 0.0)
      {
        double v7 = 1.0;
        size_t v8 = v6;
LABEL_36:
        int v14 = 276;
        return CA::Render::KeyValueArray::get_float_key(v8, v14, v7) == 0.0;
      }
    }
    return 1;
  }
  int v3 = **v2;

  return v3();
}

uint64_t CA::Render::KeyValueArray::set_key(CA::Render::KeyValueArray *this, int a2, atomic_uint *a3)
{
  uint64_t result = CA::Render::KeyValueArray::find_named_object_((uint64_t)this, a2);
  if ((result & 0x80000000) == 0)
  {
    double v7 = (char *)this + 8 * result;
    uint64_t v10 = (atomic_uint *)*((void *)v7 + 3);
    uint64_t v9 = v7 + 24;
    size_t v8 = v10;
    if (v10 && atomic_fetch_add(v8 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v8 + 16))(v8);
    }
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    uint64_t result = (uint64_t)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x20uLL, 0x743898A5uLL);
    if (result)
    {
      *(_DWORD *)(result + 8) = 1;
      *(_DWORD *)(result + 12) = 28;
      ++dword_1EB2ADE38;
      *(void *)uint64_t result = &unk_1ED02FFB8;
      *(_DWORD *)(result + 16) = a2;
      if (a3)
      {
        uint64_t v12 = a3 + 2;
        if (!atomic_fetch_add(a3 + 2, 1u))
        {
          a3 = 0;
          atomic_fetch_add(v12, 0xFFFFFFFF);
        }
      }
      *(void *)(result + 24) = a3;
    }
    *uint64_t v9 = result;
  }
  return result;
}

void CA::Layer::commit_animations(CA::Layer *this, CA::Transaction *a2, __CFString *a3, const __CFString *a4, CALayer *a5, CA::Render::TimingList *(*a6)(CA::Layer *, void *), void *a7)
{
  v48[1] = *MEMORY[0x1E4F143B8];
  Class isa = a3[1].isa;
  if (isa) {
    int v11 = (*(uint64_t (**)(void *))(*(void *)isa + 24))(isa);
  }
  else {
    int v11 = 0;
  }
  uint64_t v12 = (uint64_t *)*((void *)this + 35);
  uint64_t v47 = (uint64_t)v12;
  if (!v12) {
    return;
  }
  int v13 = *(_DWORD *)(*((void *)a2 + 5) + 8);
  int v14 = v12;
  do
  {
    __int16 v15 = *((_WORD *)v14 + 28);
    if ((v15 & 0x20) == 0)
    {
      if ((v15 & 2) == 0)
      {
        *((_DWORD *)v14 + 11) = v13;
        uint64_t v16 = (unsigned char *)v14[1];
        double v17 = 0.0;
        if ((v16[16] & 4) != 0) {
          goto LABEL_26;
        }
        uint64_t v18 = (__CFString *)[(id)v14[1] beginTimeMode];
        uint64_t v19 = v18;
        if (v18 == @"non-zero")
        {
          [v16 beginTime];
          if (v21 == 0.0) {
            goto LABEL_26;
          }
        }
        else
        {
          if (v18 == @"relative") {
            goto LABEL_31;
          }
          if (v18 == @"absolute") {
            goto LABEL_33;
          }
        }
        if ([(__CFString *)v19 isEqualToString:@"non-zero"])
        {
          [v16 beginTime];
          if (v22 == 0.0)
          {
LABEL_26:
            if (v11)
            {
LABEL_27:
              uint64_t v23 = v14[1];
              uint64_t v24 = CA::Context::copy_timings(*((CA::Transaction ***)this + 2), (CA::Layer *)a3->isa, a3);
              (*(void (**)(void *, uint64_t, uint64_t *, atomic_uint *, double))(*(void *)a3[1].isa + 48))(a3[1].isa, v23, v14, v24, v17);
              double v25 = CA::Render::TimingList::map_time((CA::Render::TimingList *)v24, *(double *)&a3->data + v17);
              uint64_t v26 = (_DWORD *)v14[1];
              v26[4] &= 0xFFFFFFFA;
              [v26 setBeginTime:v25];
              [(id)v14[1] setBeginTimeMode:@"absolute"];
              *(_DWORD *)(v14[1] + 16) |= 1u;
              *((_WORD *)v14 + 28) = v14[7] & 0xFFF7 | (8 * (byte_1EB2ACC81 == 0));
              if (v24 && atomic_fetch_add(v24 + 2, 0xFFFFFFFF) == 1) {
                (*(void (**)(atomic_uint *))(*(void *)v24 + 16))(v24);
              }
LABEL_33:
              __int16 v30 = *((_WORD *)v14 + 28) | 2;
              *((_WORD *)v14 + 28) = v30;
              if ((v30 & 0x100) == 0)
              {
LABEL_50:
                if (!v14[4]) {
                  v14[4] = CAMediaTimingCopyRenderTiming(v14[1]);
                }
                goto LABEL_52;
              }
LABEL_34:
              uint64_t v31 = [(id)v14[1] _copyRenderAnimationForLayer:*((void *)this + 2)];
              if (v31)
              {
                uint64_t v32 = v31;
                CFStringRef v33 = (const __CFString *)v14[2];
                if (v33)
                {
                  CFStringRef Copy = CFStringCreateCopy(0, v33);
                  CFHashCode v35 = CFHash(Copy);
                }
                else
                {
                  CFHashCode v35 = 0;
                  CFStringRef Copy = 0;
                }
                *(void *)(v32 + 64) = v35;
                unint64_t v36 = *(const void **)(v32 + 56);
                if (v36) {
                  CFRelease(v36);
                }
                *(void *)(v32 + 56) = Copy;
                *(_DWORD *)(v32 + 72) = *((_DWORD *)v14 + 10);
                if (objc_opt_isKindOfClass())
                {
                  v48[0] = 0;
                  uint64_t v39 = *(_DWORD **)(v32 + 96);
                  if (!v39 || (v39 & 1) == 0 && !*v39)
                  {
                    CA::Render::key_path_set((CA::Render *)v48, (CFStringRef)v14[2], v37);
                    CA::Render::key_path_free(*(CA::Render **)(v32 + 96), v40);
                    *(void *)(v32 + 96) = v48[0];
                  }
                }
                CA::Context::commit_animation(this, (CA::Layer *)v32, (CA::Render::Animation *)a3, v38);
                uint64_t v41 = *(void *)(v32 + 40);
                if (v41)
                {
                  int v42 = (atomic_uint *)(v41 + 8);
                  if (!atomic_fetch_add((atomic_uint *volatile)(v41 + 8), 1u))
                  {
                    uint64_t v41 = 0;
                    atomic_fetch_add(v42, 0xFFFFFFFF);
                  }
                }
                v14[4] = v41;
                if (atomic_fetch_add((atomic_uint *volatile)(v32 + 8), 0xFFFFFFFF) == 1) {
                  (*(void (**)(uint64_t))(*(void *)v32 + 16))(v32);
                }
              }
              goto LABEL_50;
            }
LABEL_32:
            double v28 = CA::Context::commit_layer_time((CALayer **)this, (CA::Layer *)a3, v17, a3, (uint64_t)a4, a5);
            uint64_t v29 = (_DWORD *)v14[1];
            v29[4] &= 0xFFFFFFFA;
            [v29 setBeginTime:v28];
            [(id)v14[1] setBeginTimeMode:@"absolute"];
            *(_DWORD *)(v14[1] + 16) |= 1u;
            goto LABEL_33;
          }
        }
        if (![(__CFString *)v19 isEqualToString:@"relative"]) {
          goto LABEL_33;
        }
LABEL_31:
        [v16 beginTime];
        double v17 = v27;
        if (v11) {
          goto LABEL_27;
        }
        goto LABEL_32;
      }
      if (*((_DWORD *)v14 + 11) != v13)
      {
        *((_DWORD *)v14 + 11) = v13;
        uint64_t v20 = (atomic_uint *)v14[4];
        if (v20)
        {
          if (atomic_fetch_add(v20 + 2, 0xFFFFFFFF) == 1) {
            (*(void (**)(atomic_uint *))(*(void *)v20 + 16))(v20);
          }
          __int16 v15 = *((_WORD *)v14 + 28);
        }
        v14[4] = 0;
        if ((v15 & 0x100) == 0) {
          goto LABEL_50;
        }
        goto LABEL_34;
      }
    }
    if ((v15 & 1) != 0 && (*((_DWORD *)this + 13) & 0x100000) == 0) {
      *((_WORD *)v14 + 28) = v15 | 4;
    }
LABEL_52:
    int v14 = (uint64_t *)*v14;
  }
  while (v14);
  uint64_t v43 = &v47;
  do
  {
    unint64_t v44 = (uint64_t **)v43;
    uint64_t v43 = v12;
    while (1)
    {
      __int16 v45 = *((_WORD *)v43 + 28);
      if ((v45 & 0x24) == 0) {
        break;
      }
      *unint64_t v44 = (uint64_t *)*v43;
      if ((v43[7] & 0x124) == 0x104) {
        CA::Context::remove_animation(this, (const __CFString *)v43[2], a3, a4);
      }
      schedule_stop_callback((uint64_t)v43, (uint64_t *)&animation_state);
      *uint64_t v43 = qword_1EB2A8C20;
      qword_1EB2A8C20 = (uint64_t)v43;
      uint64_t v43 = *v44;
      if (!*v44) {
        goto LABEL_63;
      }
    }
    if ((v45 & 0x40) != 0) {
      *((_WORD *)v43 + 28) = v45 & 0xFFBF;
    }
    uint64_t v12 = (uint64_t *)*v43;
  }
  while (*v43);
LABEL_63:
  uint64_t v46 = v47;

  CA::Layer::set_animations(this, v46);
}

void sub_1846C0834(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    if (atomic_fetch_add(v1 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v1 + 16))(v1);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t CA::Render::Encoder::is_deferred(CA::Render::Encoder *this)
{
  return 0;
}

BOOL CA::OGL::BlurFilter::identity(CA::OGL::BlurFilter *this, CA::Render::KeyValueArray **a2)
{
  return CA::Render::KeyValueArray::get_float_key(a2[5], 310, 0.0) <= 0.0;
}

BOOL CA::Render::Shmem::caches_encoding(CA::Render::Shmem *this)
{
  return (*((unsigned char *)this + 13) & 0x40) == 0;
}

uint64_t CA::Render::Image::caches_encoding(CA::Render::Image *this)
{
  if (!*((void *)this + 15))
  {
    unsigned int v2 = (char *)CA::Render::Image::data_size(this);
    if ((unint64_t)v2 >= *MEMORY[0x1E4F14B00])
    {
      atomic_fetch_add((atomic_uint *volatile)this + 37, 1u);
      int v4 = CA::Render::Shmem::new_shmem(*((void *)this + 12), v2, 64, (uint64_t (*)(CA::Render *, void *, void *))CA::Render::release_image_data, (void (*)(const void *, void *))this, v3);
      int v5 = (atomic_uint *)*((void *)this + 15);
      *((void *)this + 15) = v4;
      if (v5)
      {
        if (atomic_fetch_add(v5 + 2, 0xFFFFFFFF) == 1) {
          (*(void (**)(atomic_uint *))(*(void *)v5 + 16))(v5);
        }
      }
    }
  }
  return 1;
}

void *CA::Render::Layer::set_contents_scale(void *this, float a2)
{
  int v3 = this;
  int v4 = (int)a2;
  if (truncf(a2) != a2 || this[16])
  {
    this = CA::Render::Layer::ensure_ext((CA::Render::Layer *)this);
    *((float *)this + 71) = a2;
  }
  *((unsigned char *)v3 + 34) = v4;
  return this;
}

void *CA::Render::Layer::set_rasterization_scale(void *this, float a2)
{
  int v3 = this;
  int v4 = (int)a2;
  if (truncf(a2) != a2 || this[16])
  {
    this = CA::Render::Layer::ensure_ext((CA::Render::Layer *)this);
    *((float *)this + 72) = a2;
  }
  *((unsigned char *)v3 + 35) = v4;
  return this;
}

void CA::Context::commit_animation(CA::Context *this, CA::Layer *a2, CA::Render::Animation *a3, void *a4)
{
  double v7 = (CA::Render::Context *)*((void *)a3 + 5);
  if (v7)
  {
    if (CA::Render::Encoder::initialize_render_id_slide(void)::once[0] != -1) {
      dispatch_once(CA::Render::Encoder::initialize_render_id_slide(void)::once, &__block_literal_global_13615);
    }
    if (this) {
      size_t v8 = (CA::Context *)((char *)this + CA::Render::_render_id_slide);
    }
    else {
      size_t v8 = 0;
    }
    CA::Render::Context::add_animation(v7, v8, a2);
  }
  uint64_t v9 = (CA::Render::Encoder *)*((void *)a3 + 4);
  if (v9)
  {
    if (CA::Render::Encoder::initialize_render_id_slide(void)::once[0] != -1) {
      dispatch_once(CA::Render::Encoder::initialize_render_id_slide(void)::once, &__block_literal_global_13615);
    }
    if (this) {
      uint64_t v10 = (char *)this + CA::Render::_render_id_slide;
    }
    else {
      uint64_t v10 = 0;
    }
    int v11 = (unsigned char *)*((void *)v9 + 4);
    if ((unint64_t)(v11 + 1) > *((void *)v9 + 5))
    {
      CA::Render::Encoder::grow(v9, 1);
      int v11 = (unsigned char *)*((void *)v9 + 4);
    }
    *((void *)v9 + 4) = v11 + 1;
    *int v11 = 4;
    uint64_t v12 = (void *)*((void *)v9 + 4);
    if ((unint64_t)(v12 + 1) > *((void *)v9 + 5))
    {
      CA::Render::Encoder::grow(v9, 8);
      uint64_t v12 = (void *)*((void *)v9 + 4);
    }
    *uint64_t v12 = v10;
    *((void *)v9 + 4) += 8;
    CA::Render::Encoder::encode_object(v9, a2);
  }
  *((unsigned char *)a3 + 56) = 1;
}

double CA::Context::commit_layer_time(CALayer **this, CA::Layer *a2, double a3, void *a4, uint64_t a5, CALayer *a6)
{
  v9[1] = *(double *)MEMORY[0x1E4F143B8];
  if (a3 == 0.0)
  {
    double v7 = (CA::Layer *)((char *)a2 + 48);
    double result = *((double *)a2 + 6);
    if (result < 0.0)
    {
      *((void *)a2 + 6) = *((void *)a2 + 2);
      CA::Layer::convert_time(*(CA::Layer **)a2, v7, 0, this[2], a6);
      return *((double *)a2 + 6);
    }
  }
  else
  {
    v9[0] = *((double *)a2 + 2) + a3;
    CA::Layer::convert_time(*(CA::Layer **)a2, (CA::Transaction *)v9, 0, this[2], a6);
    return v9[0];
  }
  return result;
}

id CA::Layer::identifiers(CA::Layer *this)
{
  v6[1] = *(id *)MEMORY[0x1E4F143B8];
  unsigned int v2 = CA::Transaction::ensure_compat(this);
  int v3 = *((_DWORD *)v2 + 25);
  *((_DWORD *)v2 + 25) = v3 + 1;
  if (!v3) {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
  }
  v6[0] = 0;
  CA::Layer::getter(this, 0x10Au, (const CGAffineTransform *)2, v6);
  id v4 = v6[0];
  CA::Transaction::unlock(v2);
  return v4;
}

void sub_1846C10F8(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t CA::Render::DeferredEncoder::is_deferred(CA::Render::DeferredEncoder *this)
{
  return 1;
}

void CA::Render::BackdropLayer::encode(CA::Render::BackdropLayer *this, CA::Render::Encoder *a2)
{
  CA::Render::Object::encode(this, a2);
  uint64_t v4 = *((void *)this + 2);
  int v5 = (void *)*((void *)a2 + 4);
  if ((unint64_t)(v5 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 8);
    int v5 = (void *)*((void *)a2 + 4);
  }
  *int v5 = v4;
  *((void *)a2 + 4) += 8;
  CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)this + 3));
  int v6 = *((_DWORD *)this + 8);
  double v7 = (_DWORD *)*((void *)a2 + 4);
  if ((unint64_t)(v7 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 4);
    double v7 = (_DWORD *)*((void *)a2 + 4);
  }
  _DWORD *v7 = v6;
  uint64_t v8 = *((void *)a2 + 4);
  unint64_t v9 = *((void *)a2 + 5);
  uint64_t v10 = (_DWORD *)(v8 + 4);
  *((void *)a2 + 4) = v8 + 4;
  int v11 = *((_DWORD *)this + 9);
  if (v8 + 8 > v9)
  {
    CA::Render::Encoder::grow(a2, 4);
    uint64_t v10 = (_DWORD *)*((void *)a2 + 4);
  }
  *uint64_t v10 = v11;
  uint64_t v12 = *((void *)a2 + 4);
  unint64_t v13 = *((void *)a2 + 5);
  int v14 = (_DWORD *)(v12 + 4);
  *((void *)a2 + 4) = v12 + 4;
  int v15 = *((_DWORD *)this + 10);
  if (v12 + 8 > v13)
  {
    CA::Render::Encoder::grow(a2, 4);
    int v14 = (_DWORD *)*((void *)a2 + 4);
  }
  _DWORD *v14 = v15;
  uint64_t v16 = *((void *)a2 + 4);
  unint64_t v17 = *((void *)a2 + 5);
  uint64_t v18 = (_OWORD *)(v16 + 4);
  *((void *)a2 + 4) = v16 + 4;
  if (v16 + 36 > v17)
  {
    CA::Render::Encoder::grow(a2, 32);
    uint64_t v18 = (_OWORD *)*((void *)a2 + 4);
  }
  long long v19 = *((_OWORD *)this + 4);
  *uint64_t v18 = *((_OWORD *)this + 3);
  v18[1] = v19;
  uint64_t v20 = *((void *)a2 + 4);
  unint64_t v21 = *((void *)a2 + 5);
  double v22 = (unsigned char *)(v20 + 32);
  *((void *)a2 + 4) = v20 + 32;
  char v23 = *((unsigned char *)this + 80);
  if (v20 + 33 > v21)
  {
    CA::Render::Encoder::grow(a2, 1);
    double v22 = (unsigned char *)*((void *)a2 + 4);
  }
  *((void *)a2 + 4) = v22 + 1;
  *double v22 = v23;
}

CA::Render::Layer *CA::Render::Layer::set_border_color(CA::Render::Layer *result, float a2, float a3, float a4, float a5)
{
  if (*((void *)result + 16) || a2 != 0.0 || a3 != 0.0 || a4 != 0.0 || a5 != 1.0)
  {
    double result = (CA::Render::Layer *)CA::Render::Layer::ensure_ext(result);
    *((float *)result + 60) = a2;
    *((float *)result + 61) = a3;
    *((float *)result + 62) = a4;
    *((float *)result + 63) = a5;
  }
  return result;
}

void CA::Render::add_filter(CA::Render *this, uint64_t a2, const CA::Render::FilterSubclass *a3)
{
  unsigned int v4 = this;
  os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::filter_lock);
  int v5 = (int *)CA::Render::filter_table;
  if (!CA::Render::filter_table)
  {
    int v5 = (int *)x_hash_table_new_(0, 0, 0, 0, 0, 0);
    CA::Render::filter_table = (uint64_t)v5;
  }
  hash_table_modify(v5, v4, a2, 0);

  os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::filter_lock);
}

void CA::Context::remove_animation(CA::Context *this, const __CFString *a2, const __CFString *a3, const __CFString *a4)
{
  info = (CA::Render::Context *)a3[1].info;
  if (info)
  {
    if (CA::Render::Encoder::initialize_render_id_slide(void)::once[0] != -1) {
      dispatch_once(CA::Render::Encoder::initialize_render_id_slide(void)::once, &__block_literal_global_13615);
    }
    if (this) {
      uint64_t v8 = (CA::Context *)((char *)this + CA::Render::_render_id_slide);
    }
    else {
      uint64_t v8 = 0;
    }
    CA::Render::Context::remove_animation(info, v8, a2);
  }
  Class isa = (CA::Render *)a3[1].isa;
  if (isa)
  {
    if (CA::Render::Encoder::initialize_render_id_slide(void)::once[0] != -1) {
      dispatch_once(CA::Render::Encoder::initialize_render_id_slide(void)::once, &__block_literal_global_13615);
    }
    if (this) {
      uint64_t v10 = (CA::Context *)((char *)this + CA::Render::_render_id_slide);
    }
    else {
      uint64_t v10 = 0;
    }
    CA::Render::encode_remove_animation(isa, v10, a2, a4);
  }
  LOBYTE(a3[1].length) = 1;
}

void CA::Render::encode_remove_animation(CA::Render *this, CA::Render::Encoder *a2, const void *a3, const __CFString *a4)
{
  double v7 = (unsigned char *)*((void *)this + 4);
  if ((unint64_t)(v7 + 1) > *((void *)this + 5))
  {
    CA::Render::Encoder::grow(this, 1);
    double v7 = (unsigned char *)*((void *)this + 4);
  }
  *((void *)this + 4) = v7 + 1;
  unsigned char *v7 = 6;
  uint64_t v8 = (void *)*((void *)this + 4);
  if ((unint64_t)(v8 + 1) > *((void *)this + 5))
  {
    CA::Render::Encoder::grow(this, 8);
    uint64_t v8 = (void *)*((void *)this + 4);
  }
  *uint64_t v8 = a2;
  *((void *)this + 4) += 8;

  CA::Render::Encoder::encode_cfobject(this, a3);
}

void *CA::Render::LayerHost::encode(CA::Render::LayerHost *this, CA::Render::Encoder *a2)
{
  CA::Render::Object::encode(this, a2);
  int v4 = *((_DWORD *)this + 4);
  int v5 = (_DWORD *)*((void *)a2 + 4);
  if ((unint64_t)(v5 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 4);
    int v5 = (_DWORD *)*((void *)a2 + 4);
  }
  *int v5 = v4;
  uint64_t v6 = *((void *)a2 + 4);
  unint64_t v7 = *((void *)a2 + 5);
  uint64_t v8 = (void *)(v6 + 4);
  *((void *)a2 + 4) = v6 + 4;
  uint64_t v9 = *((void *)this + 8);
  if (v6 + 12 > v7)
  {
    CA::Render::Encoder::grow(a2, 8);
    uint64_t v8 = (void *)*((void *)a2 + 4);
  }
  *uint64_t v8 = v9;
  uint64_t v10 = *((void *)a2 + 4);
  unint64_t v11 = *((void *)a2 + 5);
  uint64_t v12 = (_DWORD *)(v10 + 8);
  *((void *)a2 + 4) = v10 + 8;
  uint64_t v13 = (*((void *)this + 6) - *((void *)this + 5)) >> 3;
  if (v10 + 12 > v11)
  {
    CA::Render::Encoder::grow(a2, 4);
    uint64_t v12 = (_DWORD *)*((void *)a2 + 4);
  }
  *uint64_t v12 = v13;
  unint64_t v14 = *((void *)a2 + 5);
  int v15 = (void *)(*((void *)a2 + 4) + 4);
  *((void *)a2 + 4) = v15;
  uint64_t v16 = (const void *)*((void *)this + 5);
  size_t v17 = *((void *)this + 6) - (void)v16;
  if ((unint64_t)v15 + v17 > v14)
  {
    CA::Render::Encoder::grow(a2, v17);
    int v15 = (void *)*((void *)a2 + 4);
  }
  double result = memcpy(v15, v16, v17);
  *((void *)a2 + 4) += v17;
  return result;
}

void CA::Render::SpringAnimation::encode(CA::Render::SpringAnimation *this, CA::Render::Encoder *a2)
{
  CA::Render::BasicAnimation0::encode(this, a2);
  uint64_t v4 = *((void *)this + 19);
  int v5 = (void *)*((void *)a2 + 4);
  if ((unint64_t)(v5 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 8);
    int v5 = (void *)*((void *)a2 + 4);
  }
  *int v5 = v4;
  uint64_t v6 = *((void *)a2 + 4);
  unint64_t v7 = *((void *)a2 + 5);
  uint64_t v8 = (void *)(v6 + 8);
  *((void *)a2 + 4) = v6 + 8;
  uint64_t v9 = *((void *)this + 20);
  if (v6 + 16 > v7)
  {
    CA::Render::Encoder::grow(a2, 8);
    uint64_t v8 = (void *)*((void *)a2 + 4);
  }
  *uint64_t v8 = v9;
  uint64_t v10 = *((void *)a2 + 4);
  unint64_t v11 = *((void *)a2 + 5);
  uint64_t v12 = (void *)(v10 + 8);
  *((void *)a2 + 4) = v10 + 8;
  uint64_t v13 = *((void *)this + 21);
  if (v10 + 16 > v11)
  {
    CA::Render::Encoder::grow(a2, 8);
    uint64_t v12 = (void *)*((void *)a2 + 4);
  }
  *uint64_t v12 = v13;
  uint64_t v14 = *((void *)a2 + 4);
  unint64_t v15 = *((void *)a2 + 5);
  uint64_t v16 = (void *)(v14 + 8);
  *((void *)a2 + 4) = v14 + 8;
  uint64_t v17 = *((void *)this + 22);
  if (v14 + 16 > v15)
  {
    CA::Render::Encoder::grow(a2, 8);
    uint64_t v16 = (void *)*((void *)a2 + 4);
  }
  *uint64_t v16 = v17;
  *((void *)a2 + 4) += 8;
}

double CA::Render::CompressedImage::encode(CA::Render::CompressedImage *this, CA::Render::Encoder *a2)
{
  v46[1] = *MEMORY[0x1E4F143B8];
  int v4 = *((_DWORD *)this + 3) >> 8;
  int v5 = (_DWORD *)*((void *)a2 + 4);
  if ((unint64_t)(v5 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 4);
    int v5 = (_DWORD *)*((void *)a2 + 4);
  }
  *int v5 = v4;
  uint64_t v6 = *((void *)a2 + 4);
  unint64_t v7 = *((void *)a2 + 5);
  uint64_t v8 = (_DWORD *)(v6 + 4);
  *((void *)a2 + 4) = v6 + 4;
  int v9 = *((_DWORD *)this + 4);
  if (v6 + 8 > v7)
  {
    CA::Render::Encoder::grow(a2, 4);
    uint64_t v8 = (_DWORD *)*((void *)a2 + 4);
  }
  *uint64_t v8 = v9;
  uint64_t v10 = *((void *)a2 + 4);
  unint64_t v11 = *((void *)a2 + 5);
  uint64_t v12 = (_DWORD *)(v10 + 4);
  *((void *)a2 + 4) = v10 + 4;
  int v13 = *((_DWORD *)this + 5);
  if (v10 + 8 > v11)
  {
    CA::Render::Encoder::grow(a2, 4);
    uint64_t v12 = (_DWORD *)*((void *)a2 + 4);
  }
  *uint64_t v12 = v13;
  uint64_t v14 = *((void *)a2 + 4);
  unint64_t v15 = *((void *)a2 + 5);
  uint64_t v16 = (_DWORD *)(v14 + 4);
  *((void *)a2 + 4) = v14 + 4;
  int v17 = *((_DWORD *)this + 38);
  if (v14 + 8 > v15)
  {
    CA::Render::Encoder::grow(a2, 4);
    uint64_t v16 = (_DWORD *)*((void *)a2 + 4);
  }
  *uint64_t v16 = v17;
  uint64_t v18 = (void *)(*((void *)a2 + 4) + 4);
  *((void *)a2 + 4) = v18;
  if (*((int *)this + 38) >= 1)
  {
    uint64_t v19 = 0;
    do
    {
      uint64_t v20 = *(void *)(*((void *)this + 16) + 8 * v19);
      if ((unint64_t)(v18 + 1) > *((void *)a2 + 5))
      {
        CA::Render::Encoder::grow(a2, 8);
        uint64_t v18 = (void *)*((void *)a2 + 4);
      }
      *uint64_t v18 = v20;
      uint64_t v21 = *((void *)a2 + 4);
      unint64_t v22 = *((void *)a2 + 5);
      char v23 = (void *)(v21 + 8);
      *((void *)a2 + 4) = v21 + 8;
      uint64_t v24 = *(void *)(*((void *)this + 17) + 8 * v19);
      if (v21 + 16 > v22)
      {
        CA::Render::Encoder::grow(a2, 8);
        char v23 = (void *)*((void *)a2 + 4);
      }
      *char v23 = v24;
      uint64_t v25 = *((void *)a2 + 4);
      unint64_t v26 = *((void *)a2 + 5);
      double v27 = (void *)(v25 + 8);
      *((void *)a2 + 4) = v25 + 8;
      uint64_t v28 = *(void *)(*((void *)this + 18) + 8 * v19);
      if (v25 + 16 > v26)
      {
        CA::Render::Encoder::grow(a2, 8);
        double v27 = (void *)*((void *)a2 + 4);
      }
      void *v27 = v28;
      uint64_t v18 = (void *)(*((void *)a2 + 4) + 8);
      *((void *)a2 + 4) = v18;
      ++v19;
    }
    while (v19 < *((int *)this + 38));
  }
  int v29 = *((_DWORD *)this + 40);
  if ((unint64_t)v18 + 4 > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 4);
    uint64_t v18 = (void *)*((void *)a2 + 4);
  }
  *(_DWORD *)uint64_t v18 = v29;
  uint64_t v30 = *((void *)a2 + 4);
  unint64_t v31 = *((void *)a2 + 5);
  uint64_t v32 = (_DWORD *)(v30 + 4);
  *((void *)a2 + 4) = v30 + 4;
  int v33 = *((_DWORD *)this + 42);
  if (v30 + 8 > v31)
  {
    CA::Render::Encoder::grow(a2, 4);
    uint64_t v32 = (_DWORD *)*((void *)a2 + 4);
  }
  _DWORD *v32 = v33;
  uint64_t v34 = *((void *)a2 + 4);
  unint64_t v35 = *((void *)a2 + 5);
  unint64_t v36 = (unsigned char *)(v34 + 4);
  *((void *)a2 + 4) = v34 + 4;
  char v37 = *((unsigned char *)this + 176) & 1;
  if (v34 + 5 > v35)
  {
    CA::Render::Encoder::grow(a2, 1);
    unint64_t v36 = (unsigned char *)*((void *)a2 + 4);
  }
  *((void *)a2 + 4) = v36 + 1;
  *unint64_t v36 = v37;
  uint64_t v38 = *((void *)this + 13);
  uint64_t v39 = (void *)*((void *)a2 + 4);
  if ((unint64_t)(v39 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 8);
    uint64_t v39 = (void *)*((void *)a2 + 4);
  }
  void *v39 = v38;
  *((void *)a2 + 4) += 8;
  mach_port_name_t v40 = *((_DWORD *)this + 43);
  if (!v40)
  {
    memory_object_offset_t v41 = *((void *)this + 12);
    v46[0] = *((void *)this + 13);
    mach_make_memory_entry_64(*MEMORY[0x1E4F14960], v46, v41, 3145729, (mach_port_t *)this + 43, 0);
    mach_port_name_t v40 = *((_DWORD *)this + 43);
  }
  CA::Render::Encoder::encode_port_send_right(a2, v40, 0);
  int v42 = (void *)x_heap_malloc_small_(*((uint64_t **)a2 + 1), 0x10uLL);
  uint64_t v43 = this;
  if (!atomic_fetch_add((atomic_uint *volatile)this + 2, 1u))
  {
    uint64_t v43 = 0;
    atomic_fetch_add((atomic_uint *volatile)this + 2, 0xFFFFFFFF);
  }
  uint64_t v44 = *((void *)a2 + 14);
  *int v42 = v43;
  v42[1] = v44;
  *((void *)a2 + 14) = v42;

  *(void *)&double result = CA::Render::Texture::encode((CGColorSpaceRef *)this, a2).n128_u64[0];
  return result;
}

uint64_t CA::Render::CompressedImage::caches_encoding(CA::Render::CompressedImage *this)
{
  return 0;
}

uint64_t CA::Render::Surface::caches_encoding(CA::Render::Surface *this)
{
  return 1;
}

CA::Render::Layer *CA::Render::Layer::set_shadow_color(CA::Render::Layer *result, float a2, float a3, float a4, float a5)
{
  if (*((void *)result + 16) || a2 != 0.0 || a3 != 0.0 || a4 != 0.0 || a5 != 1.0)
  {
    double result = (CA::Render::Layer *)CA::Render::Layer::ensure_ext(result);
    *((float *)result + 50) = a2;
    *((float *)result + 51) = a3;
    *((float *)result + 52) = a4;
    *((float *)result + 53) = a5;
  }
  return result;
}

uint64_t CA::Render::Layer::set_shadow_path(uint64_t this, CA::Render::Path *a2)
{
  unsigned int v2 = a2;
  if (a2 || *(void *)(this + 128))
  {
    int v3 = CA::Render::Layer::ensure_ext((CA::Render::Layer *)this);
    this = v3[15];
    if ((CA::Render::Path *)this != v2)
    {
      if (this && atomic_fetch_add((atomic_uint *volatile)(this + 8), 0xFFFFFFFF) == 1) {
        this = (*(uint64_t (**)(uint64_t))(*(void *)this + 16))(this);
      }
      if (v2)
      {
        int v4 = (atomic_uint *)((char *)v2 + 8);
        if (!atomic_fetch_add((atomic_uint *volatile)v2 + 2, 1u))
        {
          unsigned int v2 = 0;
          atomic_fetch_add(v4, 0xFFFFFFFF);
        }
      }
      v3[15] = v2;
    }
  }
  return this;
}

void CA::Render::DeferredEncoder::add_timing_list(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, double a5)
{
  if (!atomic_fetch_add((atomic_uint *volatile)(a4 + 8), 1u)) {
    atomic_fetch_add((atomic_uint *volatile)(a4 + 8), 0xFFFFFFFF);
  }
  unint64_t v11 = (void *)a1[16];
  unint64_t v10 = a1[17];
  if ((unint64_t)v11 >= v10)
  {
    int v13 = (void *)a1[15];
    unint64_t v14 = 0xCCCCCCCCCCCCCCCDLL * (v11 - v13) + 1;
    if (v14 > 0x666666666666666) {
      abort();
    }
    unint64_t v15 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v10 - (void)v13) >> 3);
    if (2 * v15 > v14) {
      unint64_t v14 = 2 * v15;
    }
    if (v15 >= 0x333333333333333) {
      unint64_t v16 = 0x666666666666666;
    }
    else {
      unint64_t v16 = v14;
    }
    if (v16)
    {
      if (v16 > 0x666666666666666) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      int v17 = (char *)operator new(40 * v16);
    }
    else
    {
      int v17 = 0;
    }
    uint64_t v18 = &v17[8 * (v11 - v13)];
    *(void *)uint64_t v18 = a2;
    *((void *)v18 + 1) = a3;
    *((void *)v18 + 2) = a4;
    *((double *)v18 + 3) = a5;
    *((void *)v18 + 4) = 0;
    uint64_t v12 = v18 + 40;
    if (v11 != v13)
    {
      do
      {
        long long v19 = *(_OWORD *)(v11 - 5);
        long long v20 = *(_OWORD *)(v11 - 3);
        *((void *)v18 - 1) = *(v11 - 1);
        *(_OWORD *)(v18 - 24) = v20;
        *(_OWORD *)(v18 - 40) = v19;
        v18 -= 40;
        v11 -= 5;
      }
      while (v11 != v13);
      unint64_t v11 = (void *)a1[15];
    }
    a1[15] = v18;
    a1[16] = v12;
    a1[17] = &v17[40 * v16];
    if (v11) {
      operator delete(v11);
    }
  }
  else
  {
    *unint64_t v11 = a2;
    v11[1] = a3;
    v11[2] = a4;
    *((double *)v11 + 3) = a5;
    uint64_t v12 = v11 + 5;
    v11[4] = 0;
  }
  a1[16] = v12;
}

void *CA::Render::Proxy::encode(CA::Render::Proxy *this, CA::Render::Encoder *a2)
{
  double result = CA::Render::Object::encode(this, a2);
  uint64_t v5 = *((void *)this + 2);
  uint64_t v6 = (void *)*((void *)a2 + 4);
  if ((unint64_t)(v6 + 1) > *((void *)a2 + 5))
  {
    double result = CA::Render::Encoder::grow(a2, 8);
    uint64_t v6 = (void *)*((void *)a2 + 4);
  }
  void *v6 = v5;
  *((void *)a2 + 4) += 8;
  return result;
}

__n128 CA::Render::ReplicatorLayer::encode(CA::Render::ReplicatorLayer *this, CA::Render::Encoder *a2)
{
  CA::Render::Object::encode(this, a2);
  int v4 = *((_DWORD *)this + 4);
  uint64_t v5 = (_DWORD *)*((void *)a2 + 4);
  if ((unint64_t)(v5 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 4);
    uint64_t v5 = (_DWORD *)*((void *)a2 + 4);
  }
  *uint64_t v5 = v4;
  *((void *)a2 + 4) += 4;
  CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)this + 3));
  uint64_t v6 = *((void *)a2 + 4);
  if ((unint64_t)(v6 + 36) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 36);
    uint64_t v6 = *((void *)a2 + 4);
  }
  __n128 result = *((__n128 *)this + 2);
  long long v8 = *((_OWORD *)this + 3);
  *(_DWORD *)(v6 + 32) = *((_DWORD *)this + 16);
  *(__n128 *)uint64_t v6 = result;
  *(_OWORD *)(v6 + 16) = v8;
  *((void *)a2 + 4) += 36;
  return result;
}

void CA::Render::TransitionAnimation::encode(CA::Render::TransitionAnimation *this, CA::Render::Encoder *a2)
{
  CA::Render::Animation::encode(this, a2);
  CA::Render::Encoder::encode_atom(a2, *((_DWORD *)this + 23));
  CA::Render::Encoder::encode_atom(a2, *((_DWORD *)this + 24));
  int v4 = *((_DWORD *)this + 25);
  uint64_t v5 = (_DWORD *)*((void *)a2 + 4);
  if ((unint64_t)(v5 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 4);
    uint64_t v5 = (_DWORD *)*((void *)a2 + 4);
  }
  *uint64_t v5 = v4;
  uint64_t v6 = *((void *)a2 + 4);
  unint64_t v7 = *((void *)a2 + 5);
  long long v8 = (_DWORD *)(v6 + 4);
  *((void *)a2 + 4) = v6 + 4;
  int v9 = *((_DWORD *)this + 26);
  if (v6 + 8 > v7)
  {
    CA::Render::Encoder::grow(a2, 4);
    long long v8 = (_DWORD *)*((void *)a2 + 4);
  }
  *long long v8 = v9;
  *((void *)a2 + 4) += 4;
  CA::Render::Encoder::encode_object(a2, *((const CA::Render::Object **)this + 14));
  unint64_t v10 = (const CA::Render::Object *)*((void *)this + 15);

  CA::Render::Encoder::encode_object(a2, v10);
}

uint64_t CA::Render::Layer::set_corner_radii(uint64_t this, CA::Render::Vector *a2)
{
  unsigned int v2 = a2;
  if (a2 || *(void *)(this + 128))
  {
    int v3 = CA::Render::Layer::ensure_ext((CA::Render::Layer *)this);
    this = v3[9];
    if ((CA::Render::Vector *)this != v2)
    {
      if (this && atomic_fetch_add((atomic_uint *volatile)(this + 8), 0xFFFFFFFF) == 1) {
        this = (*(uint64_t (**)(uint64_t))(*(void *)this + 16))(this);
      }
      if (v2)
      {
        int v4 = (atomic_uint *)((char *)v2 + 8);
        if (!atomic_fetch_add((atomic_uint *volatile)v2 + 2, 1u))
        {
          unsigned int v2 = 0;
          atomic_fetch_add(v4, 0xFFFFFFFF);
        }
      }
      v3[9] = v2;
    }
  }
  return this;
}

void sub_1846C23A0(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    if (atomic_fetch_add(v1 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v1 + 16))(v1);
    }
  }
  _Unwind_Resume(exception_object);
}

void *CA::Render::GainMapLayer::encode(CA::Render::GainMapLayer *this, CA::Render::Encoder *a2)
{
  __n128 result = CA::Render::Object::encode(this, a2);
  char v5 = *((unsigned char *)this + 16);
  uint64_t v6 = (unsigned char *)*((void *)a2 + 4);
  if ((unint64_t)(v6 + 1) > *((void *)a2 + 5))
  {
    __n128 result = CA::Render::Encoder::grow(a2, 1);
    uint64_t v6 = (unsigned char *)*((void *)a2 + 4);
  }
  *((void *)a2 + 4) = v6 + 1;
  unsigned char *v6 = v5;
  return result;
}

void CA::Render::PortalLayer::encode(CA::Render::PortalLayer *this, CA::Render::Encoder *a2)
{
  CA::Render::Object::encode(this, a2);
  uint64_t v4 = *((void *)this + 3);
  char v5 = (void *)*((void *)a2 + 4);
  if ((unint64_t)(v5 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 8);
    char v5 = (void *)*((void *)a2 + 4);
  }
  *char v5 = v4;
  uint64_t v6 = *((void *)a2 + 4);
  unint64_t v7 = *((void *)a2 + 5);
  long long v8 = (void *)(v6 + 8);
  *((void *)a2 + 4) = v6 + 8;
  uint64_t v9 = *((void *)this + 4);
  if (v6 + 16 > v7)
  {
    CA::Render::Encoder::grow(a2, 8);
    long long v8 = (void *)*((void *)a2 + 4);
  }
  *long long v8 = v9;
  uint64_t v10 = *((void *)a2 + 4);
  unint64_t v11 = *((void *)a2 + 5);
  uint64_t v12 = (_DWORD *)(v10 + 8);
  *((void *)a2 + 4) = v10 + 8;
  int v13 = *((_DWORD *)this + 10);
  if (v10 + 12 > v11)
  {
    CA::Render::Encoder::grow(a2, 4);
    uint64_t v12 = (_DWORD *)*((void *)a2 + 4);
  }
  *uint64_t v12 = v13;
  *((void *)a2 + 4) += 4;
  unint64_t v14 = (const CA::Render::Object *)*((void *)this + 6);

  CA::Render::Encoder::encode_object(a2, v14);
}

void CA::Render::MatchMoveAnimation::encode(void **this, CA::Render::Encoder *a2)
{
  CA::Render::MatchAnimation::encode(this, a2);
  uint64_t v4 = (const CA::Render::Object *)this[17];

  CA::Render::Encoder::encode_object(a2, v4);
}

CA::Render::Encoder *CA::Render::MatchAnimation::encode(void **this, CA::Render::Encoder *a2)
{
  CA::Render::Animation::encode((CA::Render::Animation *)this, a2);
  uint64_t v4 = this[12];
  char v5 = (void *)*((void *)a2 + 4);
  if ((unint64_t)(v5 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 8);
    char v5 = (void *)*((void *)a2 + 4);
  }
  *char v5 = v4;
  uint64_t v6 = *((void *)a2 + 4);
  unint64_t v7 = *((void *)a2 + 5);
  long long v8 = (void *)(v6 + 8);
  *((void *)a2 + 4) = v6 + 8;
  uint64_t v9 = this[13];
  if (v6 + 16 > v7)
  {
    CA::Render::Encoder::grow(a2, 8);
    long long v8 = (void *)*((void *)a2 + 4);
  }
  *long long v8 = v9;
  uint64_t v10 = *((void *)a2 + 4);
  unint64_t v11 = *((void *)a2 + 5);
  uint64_t v12 = (_DWORD *)(v10 + 8);
  *((void *)a2 + 4) = v10 + 8;
  int v13 = *((_DWORD *)this + 28);
  if (v10 + 12 > v11)
  {
    CA::Render::Encoder::grow(a2, 4);
    uint64_t v12 = (_DWORD *)*((void *)a2 + 4);
  }
  *uint64_t v12 = v13;
  *((void *)a2 + 4) += 4;

  return CA::Render::Encoder::encode_keypath(a2, this + 15);
}

void CA::Render::Pattern::encode(CA::Render::Pattern *this, CA::Render::Encoder *a2)
{
  CA::Render::Object::encode(this, a2);
  uint64_t v4 = (_OWORD *)*((void *)a2 + 4);
  if ((unint64_t)(v4 + 3) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 48);
    uint64_t v4 = (_OWORD *)*((void *)a2 + 4);
  }
  long long v5 = *((_OWORD *)this + 1);
  long long v6 = *((_OWORD *)this + 3);
  v4[1] = *((_OWORD *)this + 2);
  v4[2] = v6;
  *uint64_t v4 = v5;
  uint64_t v7 = *((void *)a2 + 4);
  unint64_t v8 = *((void *)a2 + 5);
  uint64_t v9 = (_OWORD *)(v7 + 48);
  *((void *)a2 + 4) = v7 + 48;
  if (v7 + 80 > v8)
  {
    CA::Render::Encoder::grow(a2, 32);
    uint64_t v9 = (_OWORD *)*((void *)a2 + 4);
  }
  long long v10 = *((_OWORD *)this + 5);
  *uint64_t v9 = *((_OWORD *)this + 4);
  v9[1] = v10;
  uint64_t v11 = *((void *)a2 + 4);
  unint64_t v12 = *((void *)a2 + 5);
  int v13 = (_OWORD *)(v11 + 32);
  *((void *)a2 + 4) = v11 + 32;
  if (v11 + 48 > v12)
  {
    CA::Render::Encoder::grow(a2, 16);
    int v13 = (_OWORD *)*((void *)a2 + 4);
  }
  _OWORD *v13 = *((_OWORD *)this + 6);
  uint64_t v14 = *((void *)a2 + 4);
  unint64_t v15 = *((void *)a2 + 5);
  unint64_t v16 = (_OWORD *)(v14 + 16);
  *((void *)a2 + 4) = v14 + 16;
  if (v14 + 32 > v15)
  {
    CA::Render::Encoder::grow(a2, 16);
    unint64_t v16 = (_OWORD *)*((void *)a2 + 4);
  }
  *unint64_t v16 = *((_OWORD *)this + 7);
  *((void *)a2 + 4) += 16;
  int v17 = (const CA::Render::Object *)*((void *)this + 16);

  CA::Render::Encoder::encode_object(a2, v17);
}

CA::Shape *CA::Render::Texture::set_dirty_shape(CA::Render::Texture *this, CA::Shape *a2)
{
  __n128 result = (CA::Shape *)*((void *)this + 5);
  if (result != a2)
  {
    if (result) {
      CA::Shape::unref(result);
    }
    if (a2) {
      __n128 result = (CA::Shape *)CA::Shape::ref((unint64_t)a2);
    }
    else {
      __n128 result = 0;
    }
    *((void *)this + 5) = result;
  }
  return result;
}

CA::Render::Surface *CAIOSurfaceRetainFrontTexture(CA::Render::Surface *result)
{
  if (result)
  {
    char v1 = result;
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    __n128 result = (CA::Render::Surface *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x158uLL, 0x743898A5uLL);
    if (result) {
      return CA::Render::Surface::Surface(result, *((CA::Render::Surface **)v1 + 2), 1081344);
    }
  }
  return result;
}

void sub_1846C2A9C(_Unwind_Exception *exception_object)
{
  if (atomic_fetch_add(v1 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v1 + 16))(v1);
  }
  _Unwind_Resume(exception_object);
}

void *CA::Render::SecureIndicatorLayer::encode(CA::Render::SecureIndicatorLayer *this, CA::Render::Encoder *a2)
{
  __n128 result = CA::Render::Object::encode(this, a2);
  int v5 = *((_DWORD *)this + 4);
  long long v6 = (_DWORD *)*((void *)a2 + 4);
  if ((unint64_t)(v6 + 1) > *((void *)a2 + 5))
  {
    __n128 result = CA::Render::Encoder::grow(a2, 4);
    long long v6 = (_DWORD *)*((void *)a2 + 4);
  }
  _DWORD *v6 = v5;
  uint64_t v7 = *((void *)a2 + 4);
  unint64_t v8 = *((void *)a2 + 5);
  uint64_t v9 = (_WORD *)(v7 + 4);
  *((void *)a2 + 4) = v7 + 4;
  __int16 v10 = *((_WORD *)this + 10);
  if (v7 + 6 > v8)
  {
    __n128 result = CA::Render::Encoder::grow(a2, 2);
    uint64_t v9 = (_WORD *)*((void *)a2 + 4);
  }
  *uint64_t v9 = v10;
  *((void *)a2 + 4) += 2;
  return result;
}

void CA::Render::GroupAnimation::encode(const CA::Render::Object **this, CA::Render::Encoder *a2)
{
  CA::Render::Animation::encode((CA::Render::Animation *)this, a2);
  uint64_t v4 = this[12];

  CA::Render::Encoder::encode_object(a2, v4);
}

__n128 CA::Render::MeshTransform::encode(CA::Render::MeshTransform *this, CA::Render::Encoder *a2)
{
  uint64_t v4 = (os_unfair_lock_s *)((char *)this + 16);
  os_unfair_lock_lock((os_unfair_lock_t)this + 4);
  CA::Render::MeshTransform::update_locked(this, 3);
  os_unfair_lock_unlock(v4);
  int v5 = *((_DWORD *)this + 3) >> 8;
  long long v6 = (_DWORD *)*((void *)a2 + 4);
  if ((unint64_t)(v6 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 4);
    long long v6 = (_DWORD *)*((void *)a2 + 4);
  }
  _DWORD *v6 = v5;
  uint64_t v7 = *((void *)a2 + 4);
  unint64_t v8 = *((void *)a2 + 5);
  uint64_t v9 = (uint64_t *)(v7 + 4);
  *((void *)a2 + 4) = v7 + 4;
  uint64_t v10 = (uint64_t)(*((void *)this + 4) - *((void *)this + 3)) >> 5;
  if (v7 + 12 > v8)
  {
    CA::Render::Encoder::grow(a2, 8);
    uint64_t v9 = (uint64_t *)*((void *)a2 + 4);
  }
  *uint64_t v9 = v10;
  uint64_t v11 = *((void *)a2 + 4);
  unint64_t v12 = *((void *)a2 + 5);
  int v13 = (uint64_t *)(v11 + 8);
  *((void *)a2 + 4) = v11 + 8;
  uint64_t v14 = (uint64_t)(*((void *)this + 7) - *((void *)this + 6)) >> 4;
  if (v11 + 16 > v12)
  {
    CA::Render::Encoder::grow(a2, 8);
    int v13 = (uint64_t *)*((void *)a2 + 4);
  }
  uint64_t *v13 = v14;
  uint64_t v15 = *((void *)a2 + 4);
  unint64_t v16 = *((void *)a2 + 5);
  int v17 = (unsigned char *)(v15 + 8);
  *((void *)a2 + 4) = v15 + 8;
  int v18 = *((_DWORD *)this + 24);
  if (v15 + 9 > v16)
  {
    CA::Render::Encoder::grow(a2, 1);
    int v17 = (unsigned char *)*((void *)a2 + 4);
  }
  *((void *)a2 + 4) = v17 + 1;
  *int v17 = v18;
  int v19 = *((_DWORD *)this + 25);
  long long v20 = (_DWORD *)*((void *)a2 + 4);
  if ((unint64_t)(v20 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 4);
    long long v20 = (_DWORD *)*((void *)a2 + 4);
  }
  _DWORD *v20 = v19;
  uint64_t v21 = *((void *)a2 + 4);
  unint64_t v22 = *((void *)a2 + 5);
  char v23 = (_DWORD *)(v21 + 4);
  *((void *)a2 + 4) = v21 + 4;
  int v24 = *((_DWORD *)this + 26);
  if (v21 + 8 > v22)
  {
    CA::Render::Encoder::grow(a2, 4);
    char v23 = (_DWORD *)*((void *)a2 + 4);
  }
  *char v23 = v24;
  uint64_t v25 = *((void *)a2 + 4);
  unint64_t v26 = *((void *)a2 + 5);
  double v27 = (unsigned char *)(v25 + 4);
  *((void *)a2 + 4) = v25 + 4;
  char v28 = *((unsigned char *)this + 108);
  if (v25 + 5 > v26)
  {
    CA::Render::Encoder::grow(a2, 1);
    double v27 = (unsigned char *)*((void *)a2 + 4);
  }
  *((void *)a2 + 4) = v27 + 1;
  unsigned char *v27 = v28;
  int v29 = *((_DWORD *)this + 28);
  uint64_t v30 = (_DWORD *)*((void *)a2 + 4);
  if ((unint64_t)(v30 + 1) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 4);
    uint64_t v30 = (_DWORD *)*((void *)a2 + 4);
  }
  *uint64_t v30 = v29;
  uint64_t v31 = *((void *)a2 + 4) + 4;
  *((void *)a2 + 4) = v31;
  uint64_t v32 = *((void *)this + 3);
  if (*((void *)this + 4) != v32)
  {
    uint64_t v33 = 0;
    unint64_t v34 = 0;
    do
    {
      if ((unint64_t)(v31 + 8) > *((void *)a2 + 5))
      {
        CA::Render::Encoder::grow(a2, 8);
        uint64_t v31 = *((void *)a2 + 4);
      }
      *(void *)uint64_t v31 = *(void *)(v32 + v33);
      uint64_t v35 = *((void *)a2 + 4);
      unint64_t v36 = *((void *)a2 + 5);
      uint64_t v37 = v35 + 8;
      *((void *)a2 + 4) = v35 + 8;
      uint64_t v38 = *((void *)this + 3);
      if (v35 + 20 > v36)
      {
        CA::Render::Encoder::grow(a2, 12);
        uint64_t v37 = *((void *)a2 + 4);
      }
      uint64_t v39 = *(void *)(v38 + v33 + 16);
      *(_DWORD *)(v37 + 8) = *(_DWORD *)(v38 + v33 + 24);
      *(void *)uint64_t v37 = v39;
      uint64_t v31 = *((void *)a2 + 4) + 12;
      *((void *)a2 + 4) = v31;
      ++v34;
      uint64_t v32 = *((void *)this + 3);
      v33 += 32;
    }
    while (v34 < (*((void *)this + 4) - v32) >> 5);
  }
  if (*((void *)this + 7) != *((void *)this + 6))
  {
    uint64_t v40 = 0;
    unint64_t v41 = 0;
    do
    {
      for (uint64_t i = 0; i != 16; i += 4)
      {
        int v43 = *(_DWORD *)(*((void *)this + 6) + v40 + i);
        if ((unint64_t)(v31 + 4) > *((void *)a2 + 5))
        {
          CA::Render::Encoder::grow(a2, 4);
          uint64_t v31 = *((void *)a2 + 4);
        }
        *(_DWORD *)uint64_t v31 = v43;
        uint64_t v31 = *((void *)a2 + 4) + 4;
        *((void *)a2 + 4) = v31;
      }
      ++v41;
      v40 += 16;
    }
    while (v41 < (uint64_t)(*((void *)this + 7) - *((void *)this + 6)) >> 4);
  }
  uint64_t v44 = *((void *)this + 9);
  if (*((void *)this + 10) != v44)
  {
    uint64_t v45 = 0;
    unint64_t v46 = 0;
    do
    {
      int v47 = *(_DWORD *)(v44 + v45 + 8);
      if ((unint64_t)(v31 + 4) > *((void *)a2 + 5))
      {
        CA::Render::Encoder::grow(a2, 4);
        uint64_t v31 = *((void *)a2 + 4);
      }
      *(_DWORD *)uint64_t v31 = v47;
      uint64_t v48 = *((void *)a2 + 4);
      unint64_t v49 = *((void *)a2 + 5);
      uint64_t v50 = (_DWORD *)(v48 + 4);
      *((void *)a2 + 4) = v48 + 4;
      int v51 = *(_DWORD *)(*((void *)this + 9) + v45 + 4);
      if (v48 + 8 > v49)
      {
        CA::Render::Encoder::grow(a2, 4);
        uint64_t v50 = (_DWORD *)*((void *)a2 + 4);
      }
      *uint64_t v50 = v51;
      uint64_t v31 = *((void *)a2 + 4) + 4;
      *((void *)a2 + 4) = v31;
      ++v46;
      uint64_t v44 = *((void *)this + 9);
      v45 += 16;
    }
    while (v46 < (*((void *)this + 10) - v44) >> 4);
  }
  if ((unint64_t)(v31 + 32) > *((void *)a2 + 5))
  {
    CA::Render::Encoder::grow(a2, 32);
    uint64_t v31 = *((void *)a2 + 4);
  }
  long long v52 = *(_OWORD *)((char *)this + 136);
  *(_OWORD *)uint64_t v31 = *(_OWORD *)((char *)this + 120);
  *(_OWORD *)(v31 + 16) = v52;
  uint64_t v53 = *((void *)a2 + 4);
  unint64_t v54 = *((void *)a2 + 5);
  uint64_t v55 = v53 + 32;
  *((void *)a2 + 4) = v53 + 32;
  if (v53 + 80 > v54)
  {
    CA::Render::Encoder::grow(a2, 48);
    uint64_t v55 = *((void *)a2 + 4);
  }
  __n128 result = *(__n128 *)((char *)this + 152);
  long long v57 = *(_OWORD *)((char *)this + 184);
  *(_OWORD *)(v55 + 16) = *(_OWORD *)((char *)this + 168);
  *(_OWORD *)(v55 + 32) = v57;
  *(__n128 *)uint64_t v55 = result;
  *((void *)a2 + 4) += 48;
  return result;
}

void ___ZN2CA3OGL12MetalContext12delete_imageEPNS0_5ImageE_block_invoke(uint64_t a1)
{
  uint64_t v1 = 0;
  uint64_t v2 = a1 + 32;
  do
  {

    v1 += 8;
  }
  while (v1 != 24);
}

uint64_t CA::Render::ShapeLayer::visit_subclass(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, a1);
}

void CAML::ObjCContext::~ObjCContext(CAML::ObjCContext *this)
{
  CAML::ObjCContext::~ObjCContext(this);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t **i;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  void *v10;
  CFDictionaryRef v11;
  const void *v12;

  uint64_t v2 = 0;
  *(void *)this = &unk_1ED030738;
  int v3 = *((void *)this + 13);
  uint64_t v4 = 1 << *(_DWORD *)v3;
  do
  {
    for (uint64_t i = *(uint64_t ***)(*(void *)(v3 + 16) + 8 * v2); i; uint64_t i = (uint64_t **)*i)
    ++v2;
  }
  while (v2 != v4);
  x_hash_table_free(*((void **)this + 13));
  *(void *)this = &unk_1ED030B10;
  if (*((void *)this + 1)) {
    CAML::Context::result(this);
  }
  long long v6 = (const void *)*((void *)this + 2);
  if (v6) {
    CFRelease(v6);
  }
  uint64_t v7 = (const void *)*((void *)this + 3);
  if (v7) {
    CFRelease(v7);
  }
  unint64_t v8 = (const void *)*((void *)this + 4);
  if (v8) {
    CFRelease(v8);
  }
  uint64_t v9 = (const void *)*((void *)this + 5);
  if (v9) {
    CFRelease(v9);
  }
  uint64_t v10 = (void *)*((void *)this + 7);
  if (v10) {
    x_hash_table_free(v10);
  }
  uint64_t v11 = (const __CFDictionary *)*((void *)this + 8);
  if (v11)
  {
    CFDictionaryApplyFunction(v11, (CFDictionaryApplierFunction)CAML::Context::free_object, 0);
    CFRelease(*((CFTypeRef *)this + 8));
  }
  unint64_t v12 = (const void *)*((void *)this + 9);
  if (v12) {
    CFRelease(v12);
  }
}

uint64_t CAML::anonymous namespace'::free_types(void *a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 56))(a2);
  if ((result & 1) == 0)
  {
    free(a1);
    int v5 = *(uint64_t (**)(uint64_t))(*(void *)a2 + 8);
    return v5(a2);
  }
  return result;
}

uint64_t CAML::ObjCType::builtin_type(CAML::ObjCType *this)
{
  return 1;
}

uint64_t CAML::ObjCNSObject::builtin_type(CAML::ObjCNSObject *this)
{
  return 0;
}

void CAML::ObjCNSObject::~ObjCNSObject(CAML::ObjCNSObject *this)
{
  *(void *)this = &unk_1ED030AC8;
  uint64_t v2 = (const void *)*((void *)this + 2);
  if (v2) {
    CFRelease(v2);
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  const void *v1;

  *(void *)this = &unk_1ED030AC8;
  uint64_t v1 = (const void *)*((void *)this + 2);
  if (v1) {
    CFRelease(v1);
  }
}

void CAML::Context::free_object(CAML::Context *this, __CFString *a2, Object *a3, void *a4)
{
  if (a2)
  {
    CFRelease((CFTypeRef)a2->info);
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(malloc_zone, a2);
  }
}

uint64_t CA::Context::set_layer(CA::Context *this, char *a2)
{
  uint64_t v4 = *(CA::Transaction **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 576);
  if (!v4) {
    uint64_t v4 = (CA::Transaction *)CA::Transaction::create(this);
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 16));
  long long v6 = (char *)*((void *)this + 12);
  if (v6 != a2)
  {
    if (v6)
    {
      uint64_t v7 = (CA::Layer *)*((void *)v6 + 2);
      if (v7) {
        CA::Layer::set_visible(v7, 0);
      }
    }
    *((void *)this + 12) = a2;
    if (a2)
    {
      CFRetain(a2);
      uint64_t v8 = *((void *)this + 12);
      a2 = *(char **)(v8 + 16);
      if (a2)
      {
        uint64_t v9 = CA::Layer::retain_parent(*(CA::Layer **)(v8 + 16), v4);
        if (v9)
        {
          uint64_t v10 = v9;
          CA::Layer::remove_from_superlayer((CALayer **)a2);
          while (1)
          {
            atomic_uint v11 = *v10;
            if (!*v10) {
              break;
            }
            atomic_uint v12 = *v10;
            atomic_compare_exchange_strong(v10, (unsigned int *)&v12, v11 - 1);
            if (v12 == v11)
            {
              if (v11 == 1)
              {
                CA::Layer::destroy((CA::Layer *)v10);
                CA::Layer::~Layer((CA::AttrList **)v10);
                malloc_zone = (malloc_zone_t *)get_malloc_zone();
                malloc_zone_free(malloc_zone, v10);
              }
              break;
            }
          }
        }
        else if ((a2[54] & 0x10) != 0)
        {
          uint64_t v14 = CA::Layer::retain_context((CA::Layer *)a2);
          uint64_t v15 = (CA::Context *)v14;
          if (v14)
          {
            CA::Context::set_layer((CA::Context *)v14, 0);
            CA::Context::unref(v15, 0);
          }
        }
        CA::Layer::set_visible((CA::Layer *)a2, *((_DWORD *)this + 2));
        if (CA::Render::Encoder::initialize_render_id_slide(void)::once[0] != -1) {
          dispatch_once(CA::Render::Encoder::initialize_render_id_slide(void)::once, &__block_literal_global_13615);
        }
        a2 += CA::Render::_render_id_slide;
      }
    }
    if (v6) {
      CA::Transaction::release_object(v4, v6);
    }
    CA::Transaction::add_command((CA::Transaction *)6, *((_DWORD *)this + 2), (uint64_t)a2, 0, v5);
  }

  return pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 16));
}

void sub_1846C3890(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t CA::Transaction::add_command(CA::Transaction *this, int a2, uint64_t a3, const void *a4, const void *a5)
{
  unsigned int v8 = this;
  uint64_t v9 = *(CA::Transaction **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 576);
  if (!v9) {
    uint64_t v9 = (CA::Transaction *)CA::Transaction::create(this);
  }
  uint64_t v10 = *((void *)v9 + 13);
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  atomic_uint v12 = malloc_type_zone_malloc(malloc_zone, 0x28uLL, 0x8BB15036uLL);
  v12[8] = a2;
  *((void *)v12 + 1) = v8;
  *((void *)v12 + 2) = a3;
  if (a4) {
    uint64_t result = (uint64_t)CFRetain(a4);
  }
  else {
    uint64_t result = 0;
  }
  *((void *)v12 + 3) = result;
  if (!**((_DWORD **)v9 + 13)) {
    uint64_t result = CA::Transaction::ensure_implicit(v9, 1);
  }
  do
  {
    uint64_t v14 = *(void *)(v10 + 16);
    *(void *)atomic_uint v12 = v14;
    uint64_t v15 = v14;
    atomic_compare_exchange_strong((atomic_ullong *volatile)(v10 + 16), (unint64_t *)&v15, (unint64_t)v12);
  }
  while (v15 != v14);
  return result;
}

void CA::Layer::set_visible(CA::Layer *this, int a2)
{
  uint64_t v4 = (CA::Transaction *)CA::Transaction::ensure_compat(this);
  int v5 = *((_DWORD *)v4 + 25);
  *((_DWORD *)v4 + 25) = v5 + 1;
  if (!v5) {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
  }
  uint64_t v6 = *((void *)this + 1);
  CA::Transaction::unlock(v4);
  if (v6) {
    objc_msgSend(MEMORY[0x1E4F1CA00], "raise:format:", @"CALayerInvalid", @"layer %@ has a superlayer; so cannot be added to a context",
  }
      *((void *)this + 2));
  int v7 = *((_DWORD *)this + 13);
  if (!a2)
  {
    if ((v7 & 0x100000) == 0) {
      return;
    }
    int v11 = *((_DWORD *)v4 + 25);
    *((_DWORD *)v4 + 25) = v11 + 1;
    if (!v11) {
      os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
    }
    goto LABEL_16;
  }
  int v8 = *((_DWORD *)this + 67);
  if ((v7 & 0x100000) == 0)
  {
    int v9 = *((_DWORD *)v4 + 25);
    *((_DWORD *)v4 + 25) = v9 + 1;
    if (!v9) {
      os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
    }
    if (v8 != a2)
    {
      int v10 = *((_DWORD *)v4 + 25);
      *((_DWORD *)v4 + 25) = v10 + 1;
      if (!v10) {
        os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
      }
      *((void *)this + 1) = 0;
      *((_DWORD *)this + 67) = a2;
      CA::Transaction::unlock(v4);
      CA::Transaction::remove_root(v4, (atomic_uint *)this);
      CA::Layer::mark_context_changed((atomic_uint *)this, (CA::Transaction **)v4);
    }
LABEL_16:
    CA::Layer::mark_visible(this, v4, a2 != 0);
    CA::Transaction::unlock(v4);
    return;
  }
  if (v8 != a2)
  {
    atomic_uint v12 = (void *)MEMORY[0x1E4F1CA00];
    [v12 raise:@"CALayerInvalid" format:@"cannot add layer to one context while visible in another"];
  }
}

void sub_1846C3B28(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

void CA::Layer::mark_context_changed(atomic_uint *this, CA::Transaction **a2)
{
  atomic_fetch_or(this + 1, 0x2000000u);
  this[10] |= 0x1FFFFFu;
  if (this[66])
  {
    if (CA::Render::Encoder::initialize_render_id_slide(void)::once[0] != -1) {
      dispatch_once(CA::Render::Encoder::initialize_render_id_slide(void)::once, &__block_literal_global_13615);
    }
    if (this) {
      uint64_t v4 = (char *)this + CA::Render::_render_id_slide;
    }
    else {
      uint64_t v4 = 0;
    }
    CA::Transaction::add_deleted_id(a2[13], (uint64_t)v4, this[66], 0);
    this[66] = 0;
  }
  int v5 = (void *)*((void *)this + 3);
  if (v5)
  {
    uint64_t v6 = v5 + 1;
    uint64_t v7 = v5[2];
    if (v7 == 1)
    {
      if (!v5[3])
      {
        do
        {
LABEL_14:
          uint64_t v8 = *v6++;
          CA::Layer::mark_context_changed(*(CA::Layer **)(v8 + 16), (CA::Transaction *)a2);
          --v7;
        }
        while (v7);
        goto LABEL_15;
      }
    }
    else if (!v7)
    {
      goto LABEL_15;
    }
    uint64_t v6 = (uint64_t *)*v6;
    goto LABEL_14;
  }
LABEL_15:
  uint64_t v9 = *((void *)this + 4);
  if (v9) {
    CA::Layer::mark_context_changed(*(CA::Layer **)(v9 + 16), (CA::Transaction *)a2);
  }
  for (uint64_t i = (uint64_t *)*((void *)this + 35); i; uint64_t i = (uint64_t *)*i)
    *((_DWORD *)i + 11) = 0;
}

uint64_t CA::Transaction::add_commit_handler(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 0;
  }
  int v3 = a3;
  uint64_t v6 = *(unsigned int *)(*(void *)(a1 + 104) + 56);
  unsigned int v7 = a3 + 1;
  if ((a3 + 1) > 6) {
    int v8 = -1;
  }
  else {
    int v8 = dword_1849AC7A0[v7];
  }
  if ((v6 + 1) >= 7) {
    goto LABEL_32;
  }
  if (v6 == 2)
  {
    if (v7 < 7)
    {
      if (a3 != 2)
      {
        if (a3 != 5) {
          goto LABEL_16;
        }
        goto LABEL_15;
      }
      goto LABEL_17;
    }
LABEL_32:
    __assert_rtn("order_of_phase", "CATransactionInternal.mm", 1611, "phase_is_valid (phase)");
  }
  if (dword_18499B480[(v6 + 1)] <= v8)
  {
LABEL_16:
    uint64_t v9 = 1;
    goto LABEL_28;
  }
  if (a3 == -1 || a3 == 5)
  {
LABEL_15:
    objc_msgSend(MEMORY[0x1E4F1CA00], "raise:format:", @"CATransaction", @"cannot add handler to %i from %i", a3, v6);
    uint64_t v9 = 0;
LABEL_28:
    int v13 = *(_DWORD *)(a1 + 100);
    *(_DWORD *)(a1 + 100) = v13 + 1;
    if (!v13) {
      os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
    }
    uint64_t v14 = (uint64_t *)CA::Transaction::commit_handlers_for_phase(*(void *)(a1 + 104), v3);
    uint64_t v15 = *v14;
    unint64_t v16 = _Block_copy(a2);
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    int v18 = malloc_type_zone_malloc(malloc_zone, 0x10uLL, 0x8BB15036uLL);
    *int v18 = v16;
    v18[1] = v15;
    uint64_t *v14 = (uint64_t)v18;
    CA::Transaction::unlock((CA::Transaction *)a1);
    return v9;
  }
LABEL_17:
  if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    int v10 = x_log_category_api;
    if (os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109376;
      int v21 = v3;
      __int16 v22 = 1024;
      int v23 = v6;
      _os_log_impl(&dword_184668000, v10, OS_LOG_TYPE_ERROR, "cannot add handler to %i from %i - dropping", buf, 0xEu);
    }
  }
  buf[0] = 0;
  int AppBooleanValue = CFPreferencesGetAppBooleanValue(@"CADebugTxHandlers", @"com.apple.coreanimation", buf);
  if (buf[0] && AppBooleanValue)
  {
    if (x_log_hook_p())
    {
      x_log_();
    }
    else
    {
      atomic_uint v12 = x_log_category_api;
      if (os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 67109376;
        int v21 = v3;
        __int16 v22 = 1024;
        int v23 = v6;
        _os_log_impl(&dword_184668000, v12, OS_LOG_TYPE_FAULT, "CoreAnimation: cannot add handler to %i from %i", buf, 0xEu);
      }
    }
  }
  uint64_t v9 = 0;
  if (v6 != v3) {
    goto LABEL_28;
  }
  return v9;
}

void CA::Transaction::flush_as_runloop_observer(CA::Transaction *this, int a2)
{
  uint64_t v3 = *((void *)this + 13);
  if (v3)
  {
    if (*(_DWORD *)v3)
    {
      char v4 = *(unsigned char *)(v3 + 204);
      if ((v4 & 1) != 0 && a2 != (v4 & 8) >> 3)
      {
        int v5 = (void *)MEMORY[0x185324A30]();
        if (dyld_program_sdk_at_least())
        {
          CA::Transaction::flush(this);
        }
        else
        {
          CA::Transaction::commit(this);
          CA::Transaction::reset_animators(this);
        }
      }
    }
  }
  if (*((unsigned char *)this + 116))
  {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::callback_lock);
    uint64_t v6 = (void *)CA::active_timers;
    if (CA::callback_timer) {
      BOOL v7 = CA::active_timers == 0;
    }
    else {
      BOOL v7 = 1;
    }
    if (!v7)
    {
      while (*v6 != CA::callback_timer)
      {
        uint64_t v6 = (void *)v6[1];
        if (!v6) {
          goto LABEL_18;
        }
      }
      CFRunLoopTimerInvalidate((CFRunLoopTimerRef)CA::callback_timer);
      CFRelease((CFTypeRef)CA::callback_timer);
      CA::callback_timer = 0;
      CA::update_timer(v8);
    }
LABEL_18:
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::callback_lock);
  }
}

void sub_1846C4020(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void CA::Transaction::flush(CA::Transaction *this)
{
  uint64_t v1 = *((void *)this + 13);
  if ((*(unsigned char *)(v1 + 204) & 1) != 0 && !*((_DWORD *)this + 28))
  {
    if (*(_DWORD *)v1 < 2u) {
      CA::Transaction::commit(this);
    }
    else {
      *(unsigned char *)(v1 + 204) |= 2u;
    }
  }
}

void x_hash_table_remove_if (uint64_t a1, unsigned int (*a2)(void, void, uint64_t), uint64_t a3)
{
  if (*(void *)(a1 + 24))
  {
    uint64_t v6 = 0;
    uint64_t v7 = 1 << *(_DWORD *)a1;
    do
    {
      int v8 = (void **)(*(void *)(a1 + 16) + 8 * v6);
      while (1)
      {
        uint64_t v9 = *v8;
        if (!*v8) {
          break;
        }
        if (a2(v9[2], v9[3], a3))
        {
          *int v8 = (void *)*v9;
          uint64_t v10 = v9[3];
          int v11 = *(void (**)(void))(a1 + 48);
          if (v11) {
            v11(v9[2]);
          }
          atomic_uint v12 = *(void (**)(uint64_t))(a1 + 56);
          if (v12) {
            v12(v10);
          }
          uint64_t v13 = *(void *)(a1 + 72);
          if (v13)
          {
            *uint64_t v9 = *(void *)(v13 + 8);
            *(void *)(v13 + 8) = v9;
          }
          else
          {
            malloc_zone = (malloc_zone_t *)get_malloc_zone();
            malloc_zone_free(malloc_zone, v9);
          }
          --*(void *)(a1 + 24);
        }
        else
        {
          int v8 = (void **)*v8;
        }
      }
      ++v6;
    }
    while (v6 != v7);
  }
}

uint64_t CA::release_root_if_unused(CA *this, CA::Layer *a2, CA::Layer *a3, void *a4)
{
  if (*((void *)this + 2)) {
    return 0;
  }
  while (1)
  {
    int v6 = *(_DWORD *)this;
    if (!*(_DWORD *)this) {
      break;
    }
    int v7 = *(_DWORD *)this;
    atomic_compare_exchange_strong((atomic_uint *volatile)this, (unsigned int *)&v7, v6 - 1);
    if (v7 == v6)
    {
      if (v6 == 1)
      {
        CA::Layer::destroy(this);
        CA::Layer::~Layer((CA::AttrList **)this);
        malloc_zone = (malloc_zone_t *)get_malloc_zone();
        malloc_zone_free(malloc_zone, this);
      }
      return 1;
    }
  }
  return 1;
}

void CA::Transaction::commit(CA::Transaction *this)
{
  uint64_t v81 = *MEMORY[0x1E4F143B8];
  if (*((CA::Transaction **)this + 13) != (CA::Transaction *)((char *)this + 120)) {
    return;
  }
  int v2 = 0;
  atomic_compare_exchange_strong((atomic_uint *volatile)this + 28, (unsigned int *)&v2, 1u);
  if (v2) {
    return;
  }
  uint64_t v3 = *((void *)this + 13);
  uint64_t v4 = mach_absolute_time();
  double v5 = CATimeWithHostTime(v4);
  if (*(double *)(v3 + 176) == 0.0)
  {
    double v6 = *(double *)(v3 + 184);
    if (v6 == 0.0)
    {
      double v6 = *(double *)(v3 + 152);
      if (v6 == 0.0) {
        double v6 = v5;
      }
    }
    CA::Transaction::set_frame_begin_time(*((void *)this + 13), v6);
  }
  char v76 = *(unsigned char *)(*((void *)this + 13) + 204);
  if ((v76 & 0x20) == 0)
  {
    CAHostTimeWithTime(*(double *)(v3 + 184));
    CAHostTimeWithTime(*(double *)(v3 + 176));
    CAHostTimeWithTime(*(double *)(v3 + 192));
    kdebug_trace();
  }
  int v7 = &unk_1E8F87000;
  char v77 = 1;
  while (2)
  {
    *((unsigned char *)this + 116) &= ~2u;
    CA::Transaction::run_commit_handlers((uint64_t)this, 4);
    int v11 = 0;
    atomic_uint v12 = (CA::Layer *)*((void *)this + 6);
    while (1)
    {
      if (v12)
      {
        if (v11)
        {
          uint64_t v13 = 0;
          uint64_t v14 = 1 << *(_DWORD *)v12;
          do
          {
            for (uint64_t i = *(uint64_t ***)(*((void *)v12 + 2) + 8 * v13); i; uint64_t i = (uint64_t **)*i)
              CA::move_root((CA *)i[2], (CA::Layer *)i[3], v11, v9);
            ++v13;
          }
          while (v13 != v14);
          x_hash_table_remove_all(*((void **)this + 6));
          int v7 = (void *)&unk_1E8F87000;
        }
        else
        {
          *((void *)this + 6) = 0;
          int v11 = v12;
        }
      }
      else if (!v11)
      {
        break;
      }
      x_hash_table_remove_if ((uint64_t)v11, (unsigned int (*)(void, void, uint64_t))CA::release_root_if_unused, (uint64_t)this);
      atomic_uint v12 = (CA::Layer *)*((void *)this + 6);
      if (!v12) {
        break;
      }
      if (!*((void *)v12 + 3))
      {
        *((void *)this + 6) = v11;
        x_hash_table_free(v12);
        goto LABEL_26;
      }
    }
    *((void *)this + 6) = v11;
LABEL_26:
    if (*(void *)(v3 + 24))
    {
      *((void *)this + 3) = *(void *)(v3 + 24);
      *(void *)(v3 + 24) = 0;
    }
    while (1)
    {
      int v21 = (void *)v7[159];
      if (!v21) {
        break;
      }
      unint64_t v16 = (void *)v7[159];
      atomic_compare_exchange_strong(CA::Transaction::global_deleted, (unint64_t *)&v16, 0);
      int v17 = v21;
      if (v16 == v21)
      {
        do
        {
          *(void *)buf = 0;
          int v18 = (void *)*v17;
          *(void *)buf = v18;
          if (v18)
          {
            do
            {
              int v19 = v18;
              int v18 = (void *)*v18;
            }
            while (v18);
          }
          else
          {
            int v19 = buf;
          }
          void *v19 = *((void *)this + 3);
          *((void *)this + 3) = *(void *)buf;
          int v17 = (void *)v17[1];
        }
        while (v17);
        do
        {
          long long v20 = (void *)v21[1];
          free(v21);
          int v21 = v20;
        }
        while (v20);
      }
    }
    double v79 = 0.0;
    CA::Context::commit_transaction(this, (CA::Transaction *)&v79, v5, v8, (uint64_t)v9, v10);
    CAHostTimeWithTime(v79);
    CAHostTimeWithTime(*(double *)(v3 + 152));
    CAHostTimeWithTime(*(double *)(v3 + 168));
    int v23 = (void *)*((void *)this + 3);
    if (v23)
    {
      do
      {
        uint64_t v24 = (void *)*v23;
        free(v23);
        int v23 = v24;
      }
      while (v24);
      *((void *)this + 3) = 0;
    }
    uint64_t v25 = (void *)*((void *)this + 6);
    if (v25)
    {
      uint64_t v26 = 0;
      *((void *)this + 6) = 0;
      uint64_t v27 = 1 << *(_DWORD *)v25;
      do
      {
        for (j = *(uint64_t ***)(v25[2] + 8 * v26); j; j = (uint64_t **)*j)
          CA::release_root((atomic_uint *)j[2], (CA::Layer *)j[3], this, v22);
        ++v26;
      }
      while (v26 != v27);
      x_hash_table_free(v25);
    }
    int v29 = (void *)*((void *)this + 2);
    if (v29)
    {
      CA::Transaction::free_command_list(v29);
      *((void *)this + 2) = 0;
    }
    while (1)
    {
      unint64_t v36 = *(id **)(v3 + 32);
      if (!v36) {
        break;
      }
      *(void *)(v3 + 32) = *v36;
      [v36[1] invalidate];

      while (1)
      {
        uint64_t v30 = (id *)v36[2];
        if (!v30) {
          break;
        }
        v36[2] = *v30;
        uint64_t v31 = (const void **)v30[2];
        if (v31)
        {
          do
          {
            _Block_release(*v31);
            uint64_t v31 = (const void **)v31[1];
          }
          while (v31);
          uint64_t v32 = v30[2];
          if (v32)
          {
            do
            {
              uint64_t v33 = (void *)v32[1];
              free(v32);
              uint64_t v32 = v33;
            }
            while (v33);
          }
        }
        malloc_zone = (malloc_zone_t *)get_malloc_zone();
        malloc_zone_free(malloc_zone, v30);
      }
      uint64_t v35 = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(v35, v36);
    }
    *(_DWORD *)(v3 + 40) = 0;
    uint64_t v37 = *(const void **)(v3 + 120);
    if (v37)
    {
      CFRelease(v37);
      *(void *)(v3 + 120) = 0;
    }
LABEL_94:
    int v56 = (void *)*((void *)this + 13);
    v56[28] = 0;
    uint64_t v57 = v56[27];
    if (v57)
    {
      uint64_t v58 = 0;
      uint64_t v59 = 1 << *(_DWORD *)v57;
      do
      {
        for (k = *(uint64_t ***)(*(void *)(v57 + 16) + 8 * v58); k; k = (uint64_t **)*k)
          release_presentation_layer((int)k[2], k[3]);
        ++v58;
      }
      while (v58 != v59);
      v56[27] = 0;
    }
    uint64_t v55 = (uint64_t *)v56[26];
    if (v55)
    {
      v56[26] = 0;
      int v38 = *((_DWORD *)this + 25);
      *((_DWORD *)this + 25) = v38 + 1;
      uint64_t v39 = v55;
      if (!v38)
      {
        os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
        uint64_t v39 = v55;
      }
      while (1)
      {
        uint64_t v43 = *v39;
        uint64_t v44 = *((unsigned int *)this + 24);
        if ((v44 & 0x80000000) != 0) {
          break;
        }
        uint64_t v45 = v43 + 4 * v44;
        int v40 = *(_DWORD *)(v45 + 272);
        *(_DWORD *)(v45 + 272) = 0;
        if ((v40 & 0x400) != 0) {
          goto LABEL_75;
        }
LABEL_76:
        unint64_t v46 = *(const void **)(v43 + 256);
        if (v46)
        {
          CA::Transaction::release_object(this, v46);
          *(void *)(v43 + 256) = 0;
        }
        int v47 = *(CA::AttrList **)(v43 + 184);
        if (v47) {
          CA::AttrList::free(v47, v46);
        }
        *(void *)(v43 + 184) = 0;
        atomic_fetch_and((atomic_uint *volatile)(v43 + 4), 0xFFEFFFFF);
        unsigned int v48 = v40 & 0x4204B7E;
        if ((v40 & 0x60000) == 0 && v48 != 0)
        {
          atomic_fetch_or((atomic_uint *volatile)(v43 + 4), v48);
          if ((v40 & 0x18) != 0) {
            unsigned int v41 = (4 * ((v40 & 6) != 0)) | 0x10;
          }
          else {
            unsigned int v41 = 4 * ((v40 & 6) != 0);
          }
          if ((v40 & 0x60) != 0) {
            v41 |= 0x40u;
          }
          if ((v40 & 0x300) != 0) {
            v41 |= 0x200u;
          }
          for (uint64_t m = *(void *)(v43 + 8); m; uint64_t m = *(void *)(m + 8))
          {
            if ((v41 & ~*(_DWORD *)(m + 4)) == 0) {
              break;
            }
            atomic_fetch_or((atomic_uint *volatile)(m + 4), v41);
          }
        }
        uint64_t v39 = (uint64_t *)v39[1];
        if (!v39)
        {
          CA::Transaction::unlock(this);
          do
          {
            uint64_t v50 = (atomic_uint *)*v55;
            uint64_t v51 = *(void *)(*v55 + 16);
            if (v51)
            {
              CALayerRelease(v51);
              uint64_t v50 = (atomic_uint *)*v55;
            }
            while (1)
            {
              atomic_uint v52 = *v50;
              if (!*v50) {
                break;
              }
              atomic_uint v53 = *v50;
              atomic_compare_exchange_strong(v50, (unsigned int *)&v53, v52 - 1);
              if (v53 == v52)
              {
                if (v52 == 1)
                {
                  CA::Layer::destroy((CA::Layer *)v50);
                  CA::Layer::~Layer((CA::AttrList **)v50);
                  unint64_t v54 = (malloc_zone_t *)get_malloc_zone();
                  malloc_zone_free(v54, v50);
                }
                break;
              }
            }
            uint64_t v55 = (uint64_t *)v55[1];
          }
          while (v55);
          goto LABEL_94;
        }
      }
      int v40 = *(_DWORD *)x_hash_table_lookup(*(void *)this, *v39, 0);
      if ((v40 & 0x400) == 0) {
        goto LABEL_76;
      }
LABEL_75:
      *(_DWORD *)(v43 + 40) |= 1u;
      goto LABEL_76;
    }
    if ((v77 & 1) != 0 && (*(void *)(v3 + 24) || *(void *)(v3 + 16)))
    {
      char v77 = 0;
      int v7 = (void *)&unk_1E8F87000;
      continue;
    }
    break;
  }
  if (*(void *)this)
  {
    x_hash_table_free(*(void **)(v3 + 8));
    *(void *)(v3 + 8) = 0;
    *(void *)this = 0;
  }
  else
  {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::slot_lock);
    CA::Transaction::slot_mask &= ~(1 << *((_DWORD *)this + 24));
    *(_DWORD *)(v3 + 4) = -1;
    *((_DWORD *)this + 24) = -1;
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Transaction::slot_lock);
  }
  char v61 = *(unsigned char *)(v3 + 204);
  *(_DWORD *)uint64_t v3 = 0;
  *(void *)(v3 + 144) = 0;
  *(void *)(v3 + 152) = 0;
  if (!*(_DWORD *)(v3 + 160))
  {
    *(_OWORD *)(v3 + 168) = 0u;
    *(_OWORD *)(v3 + 184) = 0u;
  }
  x_heap_free(*(void ****)(v3 + 128));
  *(_WORD *)(v3 + 206) = 0;
  *(void *)(v3 + 128) = 0;
  *(void *)(v3 + 136) = 0;
  unint64_t v63 = *(void **)(v3 + 240);
  if (v63)
  {
    free(v63);
    *(void *)(v3 + 240) = 0;
  }
  *(unsigned char *)(v3 + 204) = (*(unsigned char *)(v3 + 204) >> 1) & 8 | *(unsigned char *)(v3 + 204) & 0x93;
  unsigned int add = atomic_fetch_add(&CA::Transaction::next_transaction_seed, 1u);
  *(_DWORD *)(v3 + 200) = add + 1;
  if (add == -1) {
    *(_DWORD *)(v3 + 200) = atomic_fetch_add(&CA::Transaction::next_transaction_seed, 1u) + 1;
  }
  *((_DWORD *)this + 28) = 0;
  *((unsigned char *)this + 116) &= 0xF9u;
  uint64_t v65 = (CA::Transaction::Level *)*((void *)this + 11);
  if (v65)
  {
    *((void *)this + 11) = 0;
    do
    {
      unint64_t v66 = *(CA::Transaction::Level **)v65;
      CA::Transaction::Level::~Level(v65, v62);
      double v67 = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(v67, v65);
      uint64_t v65 = v66;
    }
    while (v66);
  }
  uint64_t v68 = mach_absolute_time();
  double v69 = CATimeWithHostTime(v68);
  if (CADeviceSupportsAPT::once[0] != -1)
  {
    double v78 = v69;
    dispatch_once(CADeviceSupportsAPT::once, &__block_literal_global_52);
    double v69 = v78;
  }
  double v70 = dbl_184998250[CADeviceSupportsAPT::supports_apt == 0];
  double v71 = v69 - v5;
  *(void *)buf = 0;
  *(void *)&uint8_t buf[8] = 0;
  mach_get_times();
  uint64_t v72 = *(void *)&buf[8] - *(void *)buf;
  uint64_t v73 = CAHostTimeWithTime(v5) + v72;
  int v74 = *(_DWORD *)(*((void *)this + 13) + 200);
  if (v71 >= v70)
  {
    if (CA::Transaction::bad_perf_signpost_handle(void)::once_token[0] != -1) {
      dispatch_once(CA::Transaction::bad_perf_signpost_handle(void)::once_token, &__block_literal_global_37_6636);
    }
    int v75 = CA::Transaction::bad_perf_signpost_handle(void)::handle;
    if (os_signpost_enabled((os_log_t)CA::Transaction::bad_perf_signpost_handle(void)::handle))
    {
      *(_DWORD *)buf = 134349312;
      *(void *)&uint8_t buf[4] = v73;
      *(_WORD *)&unsigned char buf[12] = 1026;
      *(_DWORD *)&buf[14] = v74;
      _os_signpost_emit_with_name_impl(&dword_184668000, v75, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Commit", "%{public, signpost.description:begin_time}llu seed=%{public, name=transaction_seed}#x", buf, 0x12u);
    }
  }
  else if ((v61 & 0x20) == 0)
  {
    if (CA::Transaction::in_memory_signpost_handle(void)::once_token != -1) {
      dispatch_once(&CA::Transaction::in_memory_signpost_handle(void)::once_token, &__block_literal_global_6639);
    }
    if (os_signpost_enabled((os_log_t)CA::Transaction::in_memory_signpost_handle(void)::handle))
    {
      *(_DWORD *)buf = 134349312;
      *(void *)&uint8_t buf[4] = v73;
      *(_WORD *)&unsigned char buf[12] = 1026;
      *(_DWORD *)&buf[14] = v74;
      _os_signpost_emit_unreliably_with_name_impl();
    }
  }
  if ((v76 & 0x20) == 0) {
    kdebug_trace();
  }
}

void sub_1846C4BD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  if ((a11 & 0x20) == 0) {
    kdebug_trace();
  }
  _Unwind_Resume(exception_object);
}

uint64_t CALayerRelease(uint64_t result)
{
  uint64_t v1 = (void *)result;
  do
  {
    int v2 = *(_DWORD *)(result + 8);
    if (!v2)
    {
      if (*(_DWORD *)(result + 12)) {
        return result;
      }
      uint64_t result = dyld_program_sdk_at_least();
      if (!result) {
        return result;
      }
      goto LABEL_11;
    }
    int v3 = *(_DWORD *)(result + 8);
    atomic_compare_exchange_strong((atomic_uint *volatile)(result + 8), (unsigned int *)&v3, v2 - 1);
  }
  while (v3 != v2);
  if (*MEMORY[0x1E4F1CBC0]) {
    uint64_t result = NSRecordAllocationEvent();
  }
  if (v2 == 1)
  {
    uint64_t v4 = v1[2];
    if (v4)
    {
      *(void *)(v4 + 16) = 0;
      atomic_fetch_and((atomic_uint *volatile)(v4 + 4), 0xFFFF7FFF);
    }
LABEL_11:
    return [v1 _dealloc];
  }
  return result;
}

void CA::AttrList::free(CA::AttrList *this, const void *a2)
{
  uint64_t v3 = *((void *)this + 1);
  if ((*((_DWORD *)this + 2) & 7) != 0)
  {
    *((void *)this + 1) = v3 & 0xFFFFFFFFFFFFFFF8 | ((v3 & 7) - 1);
  }
  else
  {
    unint64_t v4 = v3 & 0xFFFFFFFFFFFFFFF8;
    if (v4) {
      *(void *)(v4 + 8) &= 7uLL;
    }
    double v5 = *(_DWORD **)this;
    if (*(void *)this)
    {
      double v6 = v5 + 2;
      if ((v5[2] & 0x80000000) != 0)
      {
        int v7 = this;
LABEL_11:
        *(void *)int v7 = 0;
        *v6 &= ~0x80000000;
      }
      else
      {
        while (1)
        {
          int v7 = (CA::AttrList *)v5;
          CA::AttrList::Node::free_memory((CA::AttrList::Node *)v5, a2);
          double v5 = *(_DWORD **)v7;
          if (!*(void *)v7) {
            break;
          }
          if ((v5[2] & 0x80000000) != 0)
          {
            double v6 = v5 + 2;
            goto LABEL_11;
          }
        }
      }
      int v8 = *(void **)this;
      if (*(void *)this)
      {
        do
        {
          uint64_t v9 = (void *)*v8;
          free(v8);
          int v8 = v9;
        }
        while (v9);
      }
    }
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(malloc_zone, this);
  }
}

void *CA::Transaction::run_commit_handlers(uint64_t a1, int a2)
{
  uint64_t result = (void *)CA::Transaction::commit_handlers_for_phase(*(void *)(a1 + 104), a2);
  if (*result)
  {
    double v5 = result;
    kdebug_trace();
    *(_DWORD *)(*(void *)(a1 + 104) + 56) = a2;
    double v6 = (void *)*v5;
    if (*v5)
    {
      int v7 = 0;
      do
      {
        (*(void (**)(void))(*v6 + 16))();
        _Block_release((const void *)*v6);
        double v6 = (void *)v6[1];
        ++v7;
      }
      while (v6);
      int v8 = (void *)*v5;
      if (*v5)
      {
        do
        {
          uint64_t v9 = (void *)v8[1];
          free(v8);
          int v8 = v9;
        }
        while (v9);
      }
    }
    *double v5 = 0;
    *(_DWORD *)(*(void *)(a1 + 104) + 56) = -1;
    return (void *)kdebug_trace();
  }
  return result;
}

void sub_1846C4EA8(_Unwind_Exception *a1)
{
}

uint64_t CA::Transaction::commit_handlers_for_phase(uint64_t a1, int a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  switch(a2)
  {
    case 0:
      uint64_t result = a1 + 72;
      break;
    case 1:
      goto LABEL_11;
    case 2:
      uint64_t result = a1 + 88;
      break;
    case 3:
      uint64_t result = a1 + 96;
      break;
    case 4:
      uint64_t result = a1 + 64;
      break;
    case 5:
      uint64_t result = a1 + 104;
      break;
    default:
      if (x_log_hook_p())
      {
        x_log_();
      }
      else
      {
        unint64_t v4 = x_log_category_api;
        if (os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)double v5 = 0;
          _os_log_impl(&dword_184668000, v4, OS_LOG_TYPE_DEFAULT, "CoreAnimation: invalid commit handler phase! Defaulting to pre-commit.\n", v5, 2u);
        }
      }
LABEL_11:
      uint64_t result = a1 + 80;
      break;
  }
  return result;
}

void release_presentation_layer(int a1, CFTypeRef cf)
{
}

void CA::Layer::~Layer(CA::AttrList **this)
{
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  uint64_t v3 = *(CA::Transaction **)(StatusReg + 576);
  if (!v3) {
    uint64_t v3 = (CA::Transaction *)CA::Transaction::create((CA::Transaction *)this);
  }
  unint64_t v4 = this[32];
  if (v4) {
    CA::Transaction::release_object(v3, v4);
  }
  double v5 = this[23];
  if (v5)
  {
    int v6 = *((_DWORD *)v3 + 25);
    *((_DWORD *)v3 + 25) = v6 + 1;
    if (v6 || (os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock), (double v5 = this[23]) != 0)) {
      CA::AttrList::free(v5, v4);
    }
    CA::Transaction::unlock(v3);
  }
  int v7 = (id *)(this + 30);
  if (this[30])
  {
    if (*((unsigned char *)this + 248)) {
      int v7 = (id *)objc_storeWeakOrNil(v7, 0);
    }
    else {
      id *v7 = 0;
    }
  }
  int v8 = *(CA::Transaction **)(StatusReg + 576);
  if (!v8) {
    int v8 = (CA::Transaction *)CA::Transaction::create((CA::Transaction *)v7);
  }
  uint64_t v9 = this[18];
  if (v9) {
    CA::Transaction::release_object(v8, v9);
  }
  CFArrayRef v10 = this[9];
  if (v10)
  {
    int v11 = *((_DWORD *)v8 + 25);
    *((_DWORD *)v8 + 25) = v11 + 1;
    if (v11 || (os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock), (CFArrayRef v10 = this[9]) != 0)) {
      CA::AttrList::free(v10, v9);
    }
    CA::Transaction::unlock(v8);
  }
  atomic_uint v12 = (id *)(this + 16);
  if (this[16])
  {
    if (*((unsigned char *)this + 136)) {
      objc_storeWeakOrNil(v12, 0);
    }
    else {
      *atomic_uint v12 = 0;
    }
  }
}

void sub_1846C51D4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = (id *)(v1 + 128);
  if (*(void *)(v1 + 128))
  {
    if (*(unsigned char *)(v1 + 136)) {
      objc_storeWeakOrNil(v3, 0);
    }
    else {
      *uint64_t v3 = 0;
    }
  }
  _Unwind_Resume(exception_object);
}

void CA::Layer::destroy(CA::Layer *this)
{
  uint64_t v2 = CA::Transaction::ensure_compat(this);
  int v3 = *(_DWORD *)(v2 + 100);
  *(_DWORD *)(v2 + 100) = v3 + 1;
  if (!v3) {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
  }
  if ((*((_DWORD *)this + 1) & 0x60000) != 0)
  {
    uint64_t v4 = *(void *)(*(void *)(v2 + 104) + 224);
    if (v4) {
      x_hash_table_remove(v4, (uint64_t)this);
    }
  }
  else
  {
    double v5 = (CALayerArray *)*((void *)this + 3);
    if (v5) {
      CA::Layer::update_sublayers(this, (CA::Transaction *)v2, v5, 0);
    }
    uint64_t v6 = *((void *)this + 4);
    if (v6)
    {
      int v7 = *(CA::Layer **)(v6 + 16);
      int v8 = CA::Layer::ancestor_context_id(this, (CA::Transaction *)v2);
      CA::Layer::update_removed_sublayer(v7, (CA::Transaction *)v2, v8);
    }
    uint64_t v9 = (void *)*((void *)this + 35);
    if (v9)
    {
      if ((*((unsigned char *)this + 54) & 0x10) == 0 && non_visible_animating_layers) {
        CFSetRemoveValue((CFMutableSetRef)non_visible_animating_layers, this);
      }
      do
      {
        CFArrayRef v10 = (void *)*v9;
        schedule_stop_callback((uint64_t)v9, (uint64_t *)&animation_state);
        free_non_deferred_animation(v9, 1);
        uint64_t v9 = v10;
      }
      while (v10);
      CA::Layer::set_animations(this, 0);
    }
    if (*((_DWORD *)this + 66))
    {
      if (CA::Render::Encoder::initialize_render_id_slide(void)::once[0] != -1) {
        dispatch_once(CA::Render::Encoder::initialize_render_id_slide(void)::once, &__block_literal_global_13615);
      }
      if (this) {
        int v11 = (char *)this + CA::Render::_render_id_slide;
      }
      else {
        int v11 = 0;
      }
      CA::Transaction::add_deleted_id(*(CA::Transaction **)(v2 + 104), (uint64_t)v11, *((_DWORD *)this + 66), 0);
    }
  }
  atomic_uint v12 = (const void *)*((void *)this + 3);
  if (v12)
  {
    CA::Transaction::release_object((CA::Transaction *)v2, v12);
    *((void *)this + 3) = 0;
  }
  uint64_t v13 = (const void *)*((void *)this + 4);
  if (v13)
  {
    CA::Transaction::release_object((CA::Transaction *)v2, v13);
    *((void *)this + 4) = 0;
  }
  uint64_t v14 = (const void *)*((void *)this + 36);
  if (v14)
  {
    CA::Transaction::release_object((CA::Transaction *)v2, v14);
    *((void *)this + 36) = 0;
  }

  CA::Transaction::unlock((CA::Transaction *)v2);
}

void sub_1846C53C8(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

void CA::release_root(atomic_uint *this, CA::Layer *a2, CA::Layer *a3, void *a4)
{
  while (1)
  {
    atomic_uint v5 = *this;
    if (!*this) {
      break;
    }
    atomic_uint v6 = *this;
    atomic_compare_exchange_strong(this, (unsigned int *)&v6, v5 - 1);
    if (v6 == v5)
    {
      if (v5 == 1)
      {
        CA::Layer::destroy((CA::Layer *)this);
        CA::Layer::~Layer((CA::AttrList **)this);
        malloc_zone = (malloc_zone_t *)get_malloc_zone();
        malloc_zone_free(malloc_zone, this);
      }
      return;
    }
  }
}

void CA::release_objects(void *a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = (CFTypeRef *)a1;
  do
  {
    CFRelease(*v2);
    uint64_t v2 = (CFTypeRef *)v2[1];
  }
  while (v2);
  if (v1)
  {
    do
    {
      int v3 = (void *)v1[1];
      free(v1);
      uint64_t v1 = v3;
    }
    while (v3);
  }
}

void CA::Layer::remove_from_superlayer(CALayer **this)
{
  uint64_t v2 = CA::Transaction::ensure_compat((CA::Transaction *)this);
  if ((*((_DWORD *)this + 1) & 0x60000) != 0) {
    [MEMORY[0x1E4F1CA00] raise:@"CALayerInvalidTree", @"expecting model layer not copy: %@", this[2] format];
  }
  int v3 = this[2];
  int v4 = *((_DWORD *)v2 + 25);
  *((_DWORD *)v2 + 25) = v4 + 1;
  if (!v4) {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
  }
  atomic_uint v5 = (CA::Layer *)CA::Layer::retain_parent((CA::Layer *)this, v2);
  int v8 = (atomic_uint *)v5;
  if (v5) {
    CA::Layer::remove_sublayer(v5, v2, v3, v6, v7);
  }
  CA::Transaction::unlock(v2);
  if (v8)
  {
    CA::Transaction::release_object(v2, v3);
    while (1)
    {
      atomic_uint v9 = *v8;
      if (!*v8) {
        break;
      }
      atomic_uint v10 = *v8;
      atomic_compare_exchange_strong(v8, (unsigned int *)&v10, v9 - 1);
      if (v10 == v9)
      {
        if (v9 == 1)
        {
          CA::Layer::destroy((CA::Layer *)v8);
          CA::Layer::~Layer((CA::AttrList **)v8);
          malloc_zone = (malloc_zone_t *)get_malloc_zone();
          malloc_zone_free(malloc_zone, v8);
        }
        return;
      }
    }
  }
}

void sub_1846C56DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  X::Ref<CA::Layer>::~Ref((atomic_uint **)va);
  _Unwind_Resume(a1);
}

void CA::Layer::remove_sublayer(CA::Layer *this, CA::Transaction *a2, CALayer *a3, uint64_t a4, objc_object **a5)
{
  v20[1] = *(objc_object **)MEMORY[0x1E4F143B8];
  if (*((CALayer **)this + 4) == a3)
  {
    v20[0] = 0;
    CA::Layer::begin_change(this, a2, @"mask", (objc_object *)v20, a5);
    layer = (CA::Layer *)a3->_attr.layer;
    int v13 = CA::Layer::ancestor_context_id(this, a2);
    CA::Layer::update_removed_sublayer(layer, a2, v13);
    *((void *)this + 4) = 0;
    uint64_t v14 = v20[0];
    uint64_t v15 = (id *)this;
    unint64_t v16 = a2;
    int v17 = 376;
    int v18 = @"mask";
  }
  else
  {
    int v8 = (void *)*((void *)this + 3);
    if (!v8) {
      return;
    }
    v20[0] = 0;
    CA::Layer::begin_change(this, a2, @"sublayers", (objc_object *)v20, a5);
    atomic_uint v9 = (CA::Layer *)a3->_attr.layer;
    int v10 = CA::Layer::ancestor_context_id(this, a2);
    CA::Layer::update_removed_sublayer(v9, a2, v10);
    uint64_t v11 = v8[2];
    if (v11 == 1)
    {
      CA::Transaction::release_object(a2, v8);
      *((void *)this + 3) = 0;
    }
    else
    {
      if (v11)
      {
        uint64_t v19 = 0;
        while (*(CALayer **)(v8[1] + 8 * v19) != a3)
        {
          if (v11 == ++v19) {
            goto LABEL_10;
          }
        }
      }
      else
      {
LABEL_10:
        LODWORD(v19) = -1;
      }
      CALayerArrayRemoveValue((char *)v8, v19);
    }
    uint64_t v14 = v20[0];
    int v18 = @"sublayers";
    uint64_t v15 = (id *)this;
    unint64_t v16 = a2;
    int v17 = 547;
  }
  CA::Layer::end_change(v15, v16, v17, (objc_object *)v18, v14);
}

_DWORD *CA::Layer::update_removed_sublayer(CA::Layer *this, CA::Transaction *a2, int a3)
{
  int v6 = *((_DWORD *)a2 + 25);
  *((_DWORD *)a2 + 25) = v6 + 1;
  if (!v6) {
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
  }
  *((void *)this + 1) = 0;
  *((_DWORD *)this + 67) = a3;
  CA::Transaction::unlock(a2);
  CA::Layer::mark_visible(this, a2, 0);
  uint64_t result = CA::Transaction::add_root(a2, (atomic_uint *)this);
  if (((*((_DWORD *)this + 1) ^ (*((_DWORD *)this + 12) << 11)) & 0x400000) != 0)
  {
    return (_DWORD *)CA::Layer::toggle_flipped(this, a2);
  }
  return result;
}

_DWORD *CA::Transaction::add_root(CA::Transaction *this, atomic_uint *a2)
{
  int v4 = (int *)*((void *)this + 6);
  if (!v4)
  {
    int v4 = (int *)x_hash_table_new_(0, 0, 0, 0, 0, 0);
    *((void *)this + 6) = v4;
  }
  uint64_t result = (_DWORD *)hash_table_modify(v4, (uint64_t)a2, (uint64_t)a2, 0);
  if (result)
  {
    do
    {
      atomic_uint v6 = *a2;
      if (!*a2) {
        break;
      }
      atomic_uint v7 = *a2;
      atomic_compare_exchange_strong(a2, (unsigned int *)&v7, v6 + 1);
    }
    while (v7 != v6);
    if ((*((unsigned char *)this + 116) & 0x20) != 0)
    {
      uint64_t v8 = *((unsigned int *)this + 24);
      if ((v8 & 0x80000000) != 0 || !a2[v8 + 68])
      {
        return CA::Layer::thread_flags_((CA::Layer *)a2, this);
      }
    }
  }
  return result;
}

char *CALayerArrayRemoveValue(char *result, uint64_t a2)
{
  uint64_t v2 = result + 8;
  if (result[40]) {
    abort();
  }
  uint64_t v3 = *((void *)result + 2);
  if (v3 + ~a2)
  {
    uint64_t result = (char *)memmove((void *)(*v2 + 8 * a2), (const void *)(*v2 + 8 * a2 + 8), 8 * (v3 + ~a2));
    uint64_t v3 = v2[1];
  }
  v2[1] = v3 - 1;
  ++v2[3];
  return result;
}

void CA::Transaction::Level::~Level(CA::Transaction::Level *this, const void *a2)
{
  uint64_t v3 = (dispatch_block_t *)*((void *)this + 1);
  if (v3) {
    CA::Transaction::Continuation::unref(v3);
  }
  int v4 = (CA::AttrList *)*((void *)this + 2);
  if (v4) {
    CA::AttrList::free(v4, a2);
  }
}

void *x_hash_table_new_(unint64_t (*a1)(uint64_t a1), BOOL (*a2)(uint64_t a1, uint64_t a2), uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6)
{
  if (a6 && *(void *)(a6 + 16) != 32) {
    return 0;
  }
  if (a1 == x_int_hash || a1 == 0) {
    uint64_t v11 = x_pointer_hash;
  }
  else {
    uint64_t v11 = a1;
  }
  if (a2 == x_int_compare || a2 == 0) {
    int v13 = x_pointer_compare;
  }
  else {
    int v13 = a2;
  }
  if (!a5)
  {
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    int v18 = malloc_type_zone_malloc(malloc_zone, 0x58uLL, 0x8BB15036uLL);
    uint64_t v15 = v18;
    if (!v18) {
      return v15;
    }
    *(_DWORD *)int v18 = 4;
    v18[1] = 15;
    uint64_t v19 = (malloc_zone_t *)get_malloc_zone();
    long long v20 = malloc_type_zone_calloc(v19, 1uLL, 0x80uLL, 0x743898A5uLL);
    _DWORD v15[2] = v20;
    if (v20) {
      goto LABEL_21;
    }
    __int16 v22 = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(v22, v15);
    return 0;
  }
  uint64_t v14 = x_heap_malloc_small_(a5, 0x58uLL);
  uint64_t v15 = (void *)v14;
  if (!v14) {
    return v15;
  }
  *(_DWORD *)uint64_t v14 = 4;
  *(void *)(v14 + 8) = 15;
  unint64_t v16 = (_OWORD *)x_heap_malloc_small_(a5, 0x80uLL);
  if (!v16)
  {
    _DWORD v15[2] = 0;
    return 0;
  }
  v16[6] = 0u;
  v16[7] = 0u;
  void v16[4] = 0u;
  v16[5] = 0u;
  v16[2] = 0u;
  v16[3] = 0u;
  *unint64_t v16 = 0u;
  v16[1] = 0u;
  _DWORD v15[2] = v16;
LABEL_21:
  v15[3] = 0;
  void v15[4] = v11;
  v15[5] = v13;
  v15[6] = a3;
  v15[7] = a4;
  v15[8] = a5;
  char v21 = v15[10] & 0xFC | (2 * (v13 == x_pointer_compare));
  v15[9] = a6;
  *((unsigned char *)v15 + 80) = v21;
  if (a5 && !a6)
  {
    v15[9] = x_pool_new_(a5);
    *((unsigned char *)v15 + 80) |= 1u;
  }
  return v15;
}

void CA::Transaction::add_deleted_id(CA::Transaction *this, uint64_t a2, int a3, int a4)
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  atomic_uint v9 = malloc_type_zone_malloc(malloc_zone, 0x18uLL, 0x8BB15036uLL);
  v9[1] = a2;
  *((_DWORD *)v9 + 4) = a3;
  *((_DWORD *)v9 + 5) = a4;
  do
  {
    uint64_t v10 = *((void *)this + 3);
    *atomic_uint v9 = v10;
    uint64_t v11 = v10;
    atomic_compare_exchange_strong((atomic_ullong *volatile)this + 3, (unint64_t *)&v11, (unint64_t)v9);
  }
  while (v11 != v10);
}

void x_hash_table_free(void *a1)
{
  uint64_t v2 = 0;
  uint64_t v3 = 1 << *(_DWORD *)a1;
  do
  {
    int v4 = *(void **)(a1[2] + 8 * v2);
    if (!v4)
    {
      if (a1[9]) {
        goto LABEL_16;
      }
LABEL_14:
      uint64_t v10 = *(void **)(a1[2] + 8 * v2);
      if (v10)
      {
        do
        {
          uint64_t v11 = (void *)*v10;
          free(v10);
          uint64_t v10 = v11;
        }
        while (v11);
      }
      goto LABEL_16;
    }
    do
    {
      atomic_uint v5 = v4;
      int v4 = (void *)*v4;
      uint64_t v6 = v5[3];
      atomic_uint v7 = (void (*)(void))a1[6];
      if (v7) {
        v7(v5[2]);
      }
      uint64_t v8 = (void (*)(uint64_t))a1[7];
      if (v8) {
        v8(v6);
      }
      uint64_t v9 = a1[9];
      if (v9 && (a1[10] & 1) == 0)
      {
        *atomic_uint v5 = *(void *)(v9 + 8);
        *(void *)(v9 + 8) = v5;
      }
    }
    while (v4);
    if (!v9) {
      goto LABEL_14;
    }
LABEL_16:
    ++v2;
  }
  while (v2 != v3);
  if (!a1[8])
  {
    if (a1[10])
    {
      atomic_uint v12 = (void **)a1[9];
      if (v12)
      {
        if (!v12[4])
        {
          int v13 = *v12;
          if (*v12)
          {
            do
            {
              uint64_t v14 = (void *)*v13;
              malloc_zone = (malloc_zone_t *)get_malloc_zone();
              malloc_zone_free(malloc_zone, v13);
              int v13 = v14;
            }
            while (v14);
          }
          unint64_t v16 = (malloc_zone_t *)get_malloc_zone();
          malloc_zone_free(v16, v12);
        }
      }
    }
    int v17 = (void *)a1[2];
    int v18 = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(v18, v17);
    uint64_t v19 = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(v19, a1);
  }
}

void CA::Layer::set_sublayers(CALayerArray **this, CALayerArray *a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  atomic_uint v5 = CA::Transaction::ensure_compat((CA::Transaction *)this);
  if ((*((_DWORD *)this + 1) & 0x60000) != 0) {
    [MEMORY[0x1E4F1CA00] raise:@"CALayerInvalidTree", @"expecting model layer not copy: %@", this[2] format];
  }
  if (this[3] != a2)
  {
    int v6 = *((_DWORD *)v5 + 25);
    *((_DWORD *)v5 + 25) = v6 + 1;
    if (v6)
    {
      if (a2)
      {
LABEL_6:
        CFIndex Count = CFArrayGetCount((CFArrayRef)a2);
        CFIndex v8 = Count;
        if (Count)
        {
          unint64_t v9 = 8 * Count;
          if ((unint64_t)(8 * Count) <= 0x1000)
          {
            MEMORY[0x1F4188790](Count);
            uint64_t v10 = (char *)&v24 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
            bzero(v10, 8 * v8);
            goto LABEL_12;
          }
          uint64_t v10 = (char *)malloc_type_malloc(8 * Count, 0xC0040B8AA526DuLL);
          if (v10)
          {
LABEL_12:
            v26.location = 0;
            v26.length = v8;
            CFArrayGetValues((CFArrayRef)a2, v26, (const void **)v10);
            uint64_t v12 = 0;
            uint64_t v11 = 0;
            do
            {
              uint64_t v13 = *(void *)&v10[8 * v12];
              uint64_t v14 = (CA::Layer *)CA::Layer::retain_parent(*(CA::Layer **)(v13 + 16), v5);
              if (v14)
              {
                int v17 = (atomic_uint *)v14;
                if (v14 != (CA::Layer *)this || this[4] == (CALayerArray *)v13)
                {
                  CA::Layer::remove_sublayer(v14, v5, (CALayer *)v13, v15, v16);
                  MEMORY[0x1F4188790](v18);
                  v23[0] = v13;
                  v23[1] = v11;
                  uint64_t v11 = (CFTypeRef *)v23;
                }
                while (1)
                {
                  atomic_uint v19 = *v17;
                  if (!*v17) {
                    break;
                  }
                  atomic_uint v20 = *v17;
                  atomic_compare_exchange_strong(v17, (unsigned int *)&v20, v19 - 1);
                  if (v20 == v19)
                  {
                    if (v19 == 1)
                    {
                      CA::Layer::destroy((CA::Layer *)v17);
                      CA::Layer::~Layer((CA::AttrList **)v17);
                      malloc_zone = (malloc_zone_t *)get_malloc_zone();
                      malloc_zone_free(malloc_zone, v17);
                    }
                    break;
                  }
                }
              }
              else
              {
                CA::Layer::remove_from_context(*(CA::Layer **)(v13 + 16));
              }
              ++v12;
            }
            while (v12 != v8);
            a2 = objc_alloc_init(CALayerArray);
            CALayerArrayInsertValues((uint64_t)a2, 0, (void **)v10, v8);
            if (v9 > 0x1000) {
              free(v10);
            }
            goto LABEL_26;
          }
        }
        uint64_t v11 = 0;
        a2 = 0;
LABEL_26:
        v24.Class isa = 0;
        CA::Layer::begin_change((CA::Layer *)this, v5, @"sublayers", &v24, v4);
        __int16 v22 = this[3];
        CA::Layer::update_sublayers((CA::Layer *)this, v5, v22, a2);
        this[3] = a2;
        CA::Layer::end_change((id *)this, v5, 547, (objc_object *)@"sublayers", (objc_object *)v24.isa);
        CA::Transaction::unlock(v5);
        if (v22) {
          CA::Transaction::release_object(v5, v22);
        }
        while (v11)
        {
          CA::Transaction::release_object(v5, *v11);
          uint64_t v11 = (CFTypeRef *)v11[1];
        }
        return;
      }
    }
    else
    {
      os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
      if (a2) {
        goto LABEL_6;
      }
    }
    uint64_t v11 = 0;
    goto LABEL_26;
  }
}

void sub_1846C61E8(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

void CA::Layer::update_sublayers(CA::Layer *this, CA::Transaction *a2, CALayerArray *a3, CALayerArray *a4)
{
  v38[1] = *MEMORY[0x1E4F143B8];
  if (a3 == a4) {
    return;
  }
  v38[0] = 0;
  if (!a3)
  {
    int64_t var0 = 0;
    if (a4) {
      goto LABEL_4;
    }
LABEL_6:
    int64_t v9 = 0;
    goto LABEL_7;
  }
  int64_t var0 = a3->_ivars.var0;
  if (!a4) {
    goto LABEL_6;
  }
LABEL_4:
  int64_t v9 = a4->_ivars.var0;
LABEL_7:
  uint64_t v10 = 8 * var0;
  if (var0 < 1)
  {
    uint64_t v12 = (CA::Layer ***)v38;
  }
  else
  {
    if ((unint64_t)(v10 + 8) > 0x1000)
    {
      uint64_t v12 = (CA::Layer ***)malloc_type_malloc(v10 + 8, 0x80040B8603338uLL);
    }
    else
    {
      MEMORY[0x1F4188790](this);
      uint64_t v12 = (CA::Layer ***)((char *)&v36 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0));
      bzero(v12, v11);
    }
    p_ivars = &a3->_ivars;
    if (a3->_ivars.var0 != 1 || a3->_ivars.capacity) {
      p_ivars = (_CALayerArrayIvars *)p_ivars->layers;
    }
    memcpy(v12, p_ivars, 8 * var0);
    qsort(v12, var0, 8uLL, (int (__cdecl *)(const void *, const void *))compare_pointer);
    v12[var0] = 0;
  }
  uint64_t v14 = 8 * v9;
  uint64_t v37 = v10;
  if (v9 < 1)
  {
    unint64_t v16 = (CA::Layer ***)v38;
  }
  else
  {
    if ((unint64_t)(v14 + 8) > 0x1000)
    {
      unint64_t v16 = (CA::Layer ***)malloc_type_malloc(v14 + 8, 0x80040B8603338uLL);
    }
    else
    {
      MEMORY[0x1F4188790](this);
      unint64_t v16 = (CA::Layer ***)((char *)&v36 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0));
      bzero(v16, v15);
    }
    int v17 = &a4->_ivars;
    if (a4->_ivars.var0 != 1 || a4->_ivars.capacity) {
      int v17 = (_CALayerArrayIvars *)v17->layers;
    }
    memcpy(v16, v17, 8 * v9);
    qsort(v16, v9, 8uLL, (int (__cdecl *)(const void *, const void *))compare_pointer);
    v16[v9] = 0;
  }
  int v18 = CA::Layer::ancestor_context_id(this, a2);
  int v19 = 0;
  unint64_t v36 = v12;
  atomic_uint v20 = v12 + 1;
  char v21 = *v12;
  __int16 v22 = v16 + 1;
  int v23 = *v16;
  if (v21 && v23)
  {
    int v19 = 0;
    while (v21 != v23)
    {
      if (v21 >= v23)
      {
        CFRetain(v23);
        CA::Layer::update_added_sublayer(v23[2], a2, this, v18);
        CFRange v26 = v23[2];
        uint64_t v27 = *((unsigned int *)a2 + 24);
        if ((v27 & 0x80000000) != 0 || (int v28 = *((_DWORD *)v26 + v27 + 68)) == 0) {
          int v28 = *CA::Layer::thread_flags_(v26, a2);
        }
        v19 |= v28;
        goto LABEL_36;
      }
      CA::Layer::update_removed_sublayer(v21[2], a2, v18);
      CA::Transaction::release_object(a2, v21);
      objc_object v24 = *v20++;
      char v21 = v24;
LABEL_37:
      if (v21) {
        BOOL v30 = v23 == 0;
      }
      else {
        BOOL v30 = 1;
      }
      if (v30) {
        goto LABEL_42;
      }
    }
    uint64_t v25 = *v20++;
    char v21 = v25;
LABEL_36:
    int v29 = *v22++;
    int v23 = v29;
    goto LABEL_37;
  }
LABEL_42:
  if (v21)
  {
    do
    {
      CA::Layer::update_removed_sublayer(v21[2], a2, v18);
      CA::Transaction::release_object(a2, v21);
      uint64_t v31 = *v20++;
      char v21 = v31;
    }
    while (v31);
  }
  if (v23)
  {
    do
    {
      CFRetain(v23);
      CA::Layer::update_added_sublayer(v23[2], a2, this, v18);
      uint64_t v32 = v23[2];
      uint64_t v33 = *((unsigned int *)a2 + 24);
      if ((v33 & 0x80000000) != 0 || (int v34 = *((_DWORD *)v32 + v33 + 68)) == 0) {
        int v34 = *CA::Layer::thread_flags_(v32, a2);
      }
      v19 |= v34;
      uint64_t v35 = *v22++;
      int v23 = v35;
    }
    while (v35);
  }
  CA::Layer::update_for_changed_sublayers((atomic_uint *)this, a2, v19);
  if ((unint64_t)(v37 - 4089) <= 0xFFFFFFFFFFFFEFFELL) {
    free(v36);
  }
  if ((unint64_t)(v14 - 4089) <= 0xFFFFFFFFFFFFEFFELL) {
    free(v16);
  }
}

uint64_t CA::OGL::Context::remove_images(uint64_t a1, uint64_t a2, void *a3)
{
  return 1;
}

void *CA::OGL::Context::prepend_deleted_image(void *result, uint64_t a2)
{
  if (!*(unsigned char *)(a2 + 61))
  {
    uint64_t v3 = result;
    uint64_t v4 = result[40];
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    uint64_t result = malloc_type_zone_malloc(malloc_zone, 0x10uLL, 0x8BB15036uLL);
    *uint64_t result = a2;
    result[1] = v4;
    v3[40] = result;
    uint64_t v6 = *(void *)a2;
    if (*(void *)a2)
    {
      if (*(void **)(v6 + 88) == v3) {
        *(void *)(v6 + 88) = 0;
      }
      *(void *)a2 = 0;
    }
    if (*(unsigned char *)(a2 + 60))
    {
      uint64_t result = x_list_remove((void *)v3[41], a2);
      v3[41] = result;
      *(unsigned char *)(a2 + 60) = 0;
    }
    *(unsigned char *)(a2 + 61) = 1;
  }
  return result;
}

uint64_t CA::move_root(CA *this, CA::Layer *a2, CA::Layer *a3, void *a4)
{
  return hash_table_modify((int *)a3, (uint64_t)this, (uint64_t)a2, 0);
}

uint64_t CA::Layer::toggle_flipped(CA::Layer *this, CA::Transaction *a2)
{
  while (1)
  {
    uint64_t v4 = (void *)*((void *)this + 2);
    [v4 willChangeValueForKey:@"contentsAreFlipped"];
    atomic_fetch_xor((atomic_uint *volatile)this + 1, 0x400000u);
    if ((CA::Layer::layout_is_active(this, a2, 1) & 1) == 0
      && [v4 needsLayoutOnGeometryChange])
    {
      [v4 setNeedsLayout];
    }
    atomic_uint v5 = (_WORD *)[v4 contents];
    if (v5)
    {
      uint64_t v6 = v5;
      CFTypeID v7 = CFGetTypeID(v5);
      if (CABackingStoreGetTypeID::once[0] != -1) {
        dispatch_once(CABackingStoreGetTypeID::once, &__block_literal_global_907);
      }
      if (v7 == CABackingStoreGetTypeID::type && (v6[246] & 0x4000) != 0) {
        [v4 setNeedsDisplay];
      }
    }
    uint64_t result = [v4 didChangeValueForKey:@"contentsAreFlipped"];
    int64_t v9 = (void *)*((void *)this + 3);
    if (v9)
    {
      uint64_t v10 = v9 + 1;
      uint64_t v11 = v9[2];
      if (v11 == 1)
      {
        if (!v9[3])
        {
          do
          {
LABEL_16:
            uint64_t v12 = *v10++;
            uint64_t result = CA::Layer::toggle_flipped(*(CA::Layer **)(v12 + 16), a2);
            --v11;
          }
          while (v11);
          goto LABEL_17;
        }
      }
      else if (!v11)
      {
        goto LABEL_17;
      }
      uint64_t v10 = (uint64_t *)*v10;
      goto LABEL_16;
    }
LABEL_17:
    uint64_t v13 = *((void *)this + 4);
    if (!v13) {
      return result;
    }
    this = *(CA::Layer **)(v13 + 16);
  }
}

uint64_t CA::Transaction::set_frame_begin_time(uint64_t this, double a2)
{
  double v2 = *(double *)(this + 176);
  if (v2 == 0.0 || v2 > a2)
  {
    *(double *)(this + 176) = a2;
    if ((*(unsigned char *)(this + 204) & 0x20) == 0)
    {
      CAHostTimeWithTime(a2);
      return kdebug_trace();
    }
  }
  return this;
}

void CA::Transaction::free_command_list(void *a1)
{
  if (a1)
  {
    uint64_t v1 = a1;
    double v2 = a1;
    do
    {
      uint64_t v3 = (const void *)v2[3];
      if (v3) {
        CFRelease(v3);
      }
      double v2 = (void *)*v2;
    }
    while (v2);
    do
    {
      uint64_t v4 = (void *)*v1;
      free(v1);
      uint64_t v1 = v4;
    }
    while (v4);
  }
}

void sub_1846C6B70(_Unwind_Exception *exception_object)
{
}

uint64_t CAImageQueueSetEnhancementMode(uint64_t result, char a2)
{
  uint64_t v2 = *(void *)(result + 48);
  if (v2)
  {
    *(unsigned char *)(*(void *)(v2 + 24) + 94) = a2;
    __dmb(0xBu);
  }
  return result;
}

void CA::Render::MeshTransform::~MeshTransform(CA::Render::MeshTransform *this, const CA::Render::Object *a2)
{
  *(void *)this = &unk_1ED02DBE8;
  uint64_t v3 = (atomic_uint *)*((void *)this + 25);
  if (v3 && atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v3 + 16))(v3);
  }
  uint64_t v4 = (void *)*((void *)this + 9);
  if (v4)
  {
    *((void *)this + 10) = v4;
    operator delete(v4);
  }
  atomic_uint v5 = (void *)*((void *)this + 6);
  if (v5)
  {
    *((void *)this + 7) = v5;
    operator delete(v5);
  }
  uint64_t v6 = (void *)*((void *)this + 3);
  if (v6)
  {
    *((void *)this + 4) = v6;
    operator delete(v6);
  }
  --dword_1EB2ADE4C;
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  atomic_uint *v3;
  void *v4;
  void *v5;
  void *v6;

  *(void *)this = &unk_1ED02DBE8;
  uint64_t v3 = (atomic_uint *)*((void *)this + 25);
  if (v3 && atomic_fetch_add(v3 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v3 + 16))(v3);
  }
  uint64_t v4 = (void *)*((void *)this + 9);
  if (v4)
  {
    *((void *)this + 10) = v4;
    operator delete(v4);
  }
  atomic_uint v5 = (void *)*((void *)this + 6);
  if (v5)
  {
    *((void *)this + 7) = v5;
    operator delete(v5);
  }
  uint64_t v6 = (void *)*((void *)this + 3);
  if (v6)
  {
    *((void *)this + 4) = v6;
    operator delete(v6);
  }
  --dword_1EB2ADE4C;
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  }
}

void CA::Render::Proxy::~Proxy(CA::Render::Proxy *this, const CA::Render::Object *a2)
{
  --dword_1EB2ADE74;
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  }
  malloc_zone = (malloc_zone_t *)get_malloc_zone();

  malloc_zone_free(malloc_zone, this);
}

{
  --dword_1EB2ADE74;
  *(void *)this = &unk_1ED02F670;
  if ((*((_DWORD *)this + 3) & 0x80000000) != 0) {
    CA::Render::Encoder::ObjectCache::invalidate(this, a2);
  }
}

void CA::Transaction::Continuation::unref(dispatch_block_t *this)
{
  if (atomic_fetch_add((atomic_uint *volatile)this, 0xFFFFFFFF) == 1)
  {
    dispatch_async(MEMORY[0x1E4F14428], this[2]);
    _Block_release(this[2]);
    uint64_t v2 = (CA::Transaction::Continuation *)this[1];
    if (v2) {
      CA::Transaction::Continuation::unref(v2);
    }
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    malloc_zone_free(malloc_zone, this);
  }
}

BOOL CA::Render::BasicAnimation0::validate(CA::Render::BasicAnimation0 *this, CA::Render::Layer *a2)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (const CA::Render::Layer **)((char *)this + 96);
  uint64_t v2 = (_DWORD *)*((void *)this + 12);
  if (!v2 || (v2 & 1) == 0 && !*v2) {
    return 0;
  }
  if (*((void *)this + 14) || *((void *)this + 15)) {
    return 1;
  }
  if (a2 && !*((void *)this + 16))
  {
    uint64_t v6 = *((void *)this + 5);
    uint64_t v7 = v6 ? *(void *)(v6 + 40) : 0;
    v22[1] = 0;
    *(_OWORD *)&v32[16] = 0u;
    long long v33 = 0u;
    v22[0] = v7;
    int v23 = a2;
    memset(v32, 0, 21);
    *(_WORD *)&v32[22] = 0;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    long long v31 = 0u;
    __asm { FMOV            V0.2D, #1.0 }
    long long v30 = _Q0;
    v32[21] = 1;
    v32[24] = 1;
    CA::Render::AnimationEvaluator::first_pass((CA::Render::AnimationEvaluator *)v22, 0);
    CA::Render::AnimationEvaluator::second_pass((uint64_t)v22);
    uint64_t v14 = (void)v25 ? (CA::Render::Layer *)v25 : v23;
    if (CA::Render::Layer::keypath_is_object(v14, v3, v13))
    {
      keypath_object = (CA::Render::Vector *)CA::Render::Layer::get_keypath_object(v14, v3, v15);
      CA::Render::ShapeLayer::set_dash_pattern(this, keypath_object);
    }
    else
    {
      memset(v34, 0, sizeof(v34));
      char v21 = 0;
      keypath_value = (CA::Render::Vector *)CA::Render::Layer::get_keypath_value(v14, (unint64_t *)v3, 0x18uLL, v34, (float64x2_t **)&v21);
      if (keypath_value)
      {
        int v19 = CA::Render::Vector::new_vector(keypath_value, v21, v18);
        CA::Render::ShapeLayer::set_dash_pattern(this, (CA::Render::Vector *)v19);
        if (v19 && atomic_fetch_add(v19 + 2, 0xFFFFFFFF) == 1) {
          (*(void (**)(atomic_uint *))(*(void *)v19 + 16))(v19);
        }
        if (v21 != v34) {
          free(v21);
        }
      }
    }
    uint64_t v20 = v25;
    if ((void)v25 && atomic_fetch_add((atomic_uint *volatile)(v25 + 8), 0xFFFFFFFF) == 1) {
      (*(void (**)(uint64_t))(*(void *)v20 + 16))(v20);
    }
    if (*((void *)this + 14) || *((void *)this + 15)) {
      return 1;
    }
  }
  return *((void *)this + 16) != 0;
}

void CA::Render::AnimationEvaluator::first_pass(CA::Render::AnimationEvaluator *this, int a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(*((void *)this + 2) + 136);
  if (v2)
  {
    uint64_t v4 = *(unsigned int *)(v2 + 16);
    if (v4)
    {
      uint64_t v6 = (uint64_t *)(v2 + 24);
      uint64_t v7 = 8 * v4;
      CFIndex v8 = &qword_1EB2AB000;
      int64_t v9 = &qword_1EB2AB000;
      do
      {
        uint64_t v10 = *v6;
        int v11 = *(_DWORD *)(*v6 + 12);
        if ((v11 & 0x20000) != 0) {
          goto LABEL_11;
        }
        ++*(_DWORD *)(v10 + 80);
        if ((v11 & 0x100) == 0) {
          goto LABEL_11;
        }
        if ((v11 & 0x4000) != 0)
        {
          char v12 = *((unsigned char *)this + 192) | 2;
        }
        else
        {
          if (v11 != 55)
          {
            int v27 = 0;
            BOOL v26 = 0;
            double v25 = *(double *)this;
            if (!CA::Render::Animation::map_time((CA::Render::Animation *)v10, &v25, &v27, 0, &v26)) {
              goto LABEL_11;
            }
            if (!*((void *)this + 5))
            {
              uint64_t v14 = v9;
              size_t v15 = v8;
              malloc_zone = (malloc_zone_t *)get_malloc_zone();
              int v17 = malloc_type_zone_calloc(malloc_zone, 1uLL, 0x98uLL, 0x743898A5uLL);
              int v18 = v17;
              if (v17) {
                CA::Render::Layer::Layer((uint64_t)v17, *((void *)this + 2));
              }
              int v19 = (atomic_uint *)*((void *)this + 5);
              *((void *)this + 5) = v18;
              CFIndex v8 = v15;
              int64_t v9 = v14;
              if (v19 && atomic_fetch_add(v19 + 2, 0xFFFFFFFF) == 1) {
                (*(void (**)(atomic_uint *))(*(void *)v19 + 16))(v19);
              }
            }
            ++*(_DWORD *)(v10 + 84);
            (*(void (**)(uint64_t, CA::Render::AnimationEvaluator *, void, BOOL, double))(*(void *)v10 + 120))(v10, this, v27, v26, v25);
            if ((*((unsigned char *)this + 192) & 1) == 0
              || v26
              || !CA::Render::Animation::affects_velocity((CA::Render::Animation *)v10))
            {
              goto LABEL_11;
            }
            int v13 = (int)*(float *)(v10 + 28);
            if (v13)
            {
              if (!a2)
              {
LABEL_36:
                if (v13 >= 49)
                {
                  if (v13 >= 0x3D)
                  {
                    if (v13 < 0x51) {
                      unsigned __int8 v20 = 3;
                    }
                    else {
                      unsigned __int8 v20 = 4;
                    }
                  }
                  else
                  {
                    unsigned __int8 v20 = 2;
                  }
                }
                else
                {
                  unsigned __int8 v20 = 1;
                }
                if (*((unsigned __int8 *)this + 176) > v20) {
                  unsigned __int8 v20 = *((unsigned char *)this + 176);
                }
                *((unsigned char *)this + 176) = v20;
                char v12 = *((unsigned char *)this + 192) | 0x10;
                goto LABEL_10;
              }
            }
            else
            {
              if (v8[340] != -1) {
                dispatch_once(CAPrefers60HzAPT(void)::once, &__block_literal_global_3);
              }
              if (*((unsigned char *)v9 + 2712)) {
                int v13 = 60;
              }
              else {
                int v13 = 120;
              }
              if (!a2) {
                goto LABEL_36;
              }
            }
            if (!*(_DWORD *)(v10 + 88) && (*(unsigned char *)(v10 + 14) & 0x80) != 0 && v13 >= 60) {
              int v13 = 60;
            }
            goto LABEL_36;
          }
          char v12 = *((unsigned char *)this + 192) | 4;
        }
LABEL_10:
        *((unsigned char *)this + 192) = v12;
LABEL_11:
        ++v6;
        v7 -= 8;
      }
      while (v7);
    }
    if ((*((unsigned char *)this + 192) & 2) != 0 && !*((void *)this + 5))
    {
      char v21 = (malloc_zone_t *)get_malloc_zone();
      __int16 v22 = malloc_type_zone_calloc(v21, 1uLL, 0x98uLL, 0x743898A5uLL);
      int v23 = v22;
      if (v22) {
        CA::Render::Layer::Layer((uint64_t)v22, *((void *)this + 2));
      }
      long long v24 = (atomic_uint *)*((void *)this + 5);
      *((void *)this + 5) = v23;
      if (v24)
      {
        if (atomic_fetch_add(v24 + 2, 0xFFFFFFFF) == 1) {
          (*(void (**)(atomic_uint *))(*(void *)v24 + 16))(v24);
        }
      }
    }
  }
}

uint64_t CA::Render::Layer::Layer(uint64_t result, uint64_t a2)
{
  *(void *)uint64_t result = &unk_1ED02F670;
  *(_DWORD *)(result + 8) = 1;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a2 + 12) & 0xFFFFFF00 | 0x1D;
  ++dword_1EB2ADE3C;
  *(void *)uint64_t result = &unk_1ED02F440;
  long long v2 = *(_OWORD *)(a2 + 16);
  long long v3 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(result + 32) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(result + 48) = v3;
  *(_OWORD *)(result + 16) = v2;
  *(_OWORD *)(result + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(result + 80) = *(_OWORD *)(a2 + 80);
  uint64_t v4 = *(void *)(a2 + 96);
  if (v4)
  {
    atomic_uint v5 = (atomic_uint *)(v4 + 8);
    if (!atomic_fetch_add((atomic_uint *volatile)(v4 + 8), 1u))
    {
      uint64_t v4 = 0;
      atomic_fetch_add(v5, 0xFFFFFFFF);
    }
  }
  *(void *)(result + 96) = v4;
  uint64_t v6 = *(void *)(a2 + 104);
  if (v6)
  {
    uint64_t v7 = (atomic_uint *)(v6 + 8);
    if (!atomic_fetch_add((atomic_uint *volatile)(v6 + 8), 1u))
    {
      uint64_t v6 = 0;
      atomic_fetch_add(v7, 0xFFFFFFFF);
    }
  }
  *(void *)(result + 104) = v6;
  uint64_t v8 = *(void *)(a2 + 112);
  if (v8)
  {
    int64_t v9 = (atomic_uint *)(v8 + 8);
    if (!atomic_fetch_add((atomic_uint *volatile)(v8 + 8), 1u))
    {
      uint64_t v8 = 0;
      atomic_fetch_add(v9, 0xFFFFFFFF);
    }
  }
  *(void *)(result + 112) = v8;
  uint64_t v10 = *(void *)(a2 + 120);
  if (v10)
  {
    int v11 = (atomic_uint *)(v10 + 8);
    if (!atomic_fetch_add((atomic_uint *volatile)(v10 + 8), 1u))
    {
      uint64_t v10 = 0;
      atomic_fetch_add(v11, 0xFFFFFFFF);
    }
  }
  *(void *)(result + 120) = v10;
  uint64_t v12 = *(void *)(a2 + 128);
  if (v12) {
    atomic_fetch_add((atomic_uint *volatile)(v12 + 328), 1u);
  }
  *(void *)(result + 128) = v12;
  *(void *)(result + 136) = 0;
  uint64_t v13 = *(void *)(a2 + 144);
  if (v13)
  {
    uint64_t v14 = (atomic_uint *)(v13 + 8);
    if (!atomic_fetch_add((atomic_uint *volatile)(v13 + 8), 1u))
    {
      uint64_t v13 = 0;
      atomic_fetch_add(v14, 0xFFFFFFFF);
    }
  }
  *(void *)(result + 144) = v13;
  return result;
}

BOOL CA::Render::Animation::affects_velocity(CA::Render::Animation *this)
{
  if ((*((_DWORD *)this + 3) & 0x88000) != 0x80000 || *((_DWORD *)this + 3) == 31) {
    return 0;
  }
  uint64_t v2 = *((void *)this + 5);
  if (v2)
  {
    if (*(double *)(v2 + 32) < 0.00208333333) {
      return 0;
    }
  }
  int v4 = (int)*((float *)this + 7);
  if (v4) {
    BOOL v5 = v4 <= 59;
  }
  else {
    BOOL v5 = 0;
  }
  return !v5;
}

uint64_t CA::Render::Animation::map_time(CA::Render::Animation *this, double *a2, int *a3, BOOL *a4, BOOL *a5)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = (double *)*((void *)this + 5);
  if (!v7)
  {
    if (a3) {
      *a3 = 0;
    }
    return 1;
  }
  float v10 = *((float *)this + 8);
  if (v10 != 0.0 && (*((unsigned char *)this + 13) & 0x80) != 0) {
    *a2 = floor((*a2 - v7[5]) * v10) / v10 + v7[5];
  }
  uint64_t result = CA::Render::Timing::map_parent_to_active((CA::Render::Timing *)v7, a2, a5);
  if (result)
  {
    uint64_t v12 = *((void *)this + 5);
    if (a3)
    {
      double v13 = *(double *)(v12 + 32);
      if (*(unsigned char *)(v12 + 13)) {
        double v13 = v13 + v13;
      }
      if ((*(void *)&v13 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
        int v14 = 0;
      }
      else {
        int v14 = vcvtmd_s64_f64(*a2 / v13);
      }
      *a3 = v14;
    }
    unsigned int v20 = 0;
    CA::Render::Timing::map_active_to_local(v12, a2, &v20);
    uint64_t v16 = *((void *)this + 5);
    if (a4 && (*(unsigned char *)(v16 + 13) & 1) != 0) {
      *a4 = v20 & 1;
    }
    double v17 = *(double *)(v16 + 32);
    double v18 = *a2 / v17;
    *a2 = v18;
    uint64_t v19 = *((void *)this + 6);
    if (v19)
    {
      if (*(_DWORD *)(v19 + 16) == 4) {
        *a2 = CA::Render::TimingFunction::evaluate((CA::Render::TimingFunction *)(v19 + 24), v15, v18, 0.001 / v17);
      }
    }
    return 1;
  }
  return result;
}

uint64_t CA::Render::Timing::map_active_to_local(uint64_t this, double *a2, unsigned int *a3)
{
  double v3 = *a2;
  double v4 = *(double *)(this + 32);
  double v5 = 0.0;
  if ((*(void *)&v4 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || (v3 >= 0.0 ? (BOOL v6 = v3 < v4) : (BOOL v6 = 0), v6))
  {
    double v7 = 0.0;
  }
  else
  {
    double v7 = floor(v3 / v4);
    double v3 = v3 - v7 * v4;
    if (*(unsigned char *)(this + 13) & 1) != 0 && ((int)v7)
    {
      double v3 = v4 - v3;
      double v8 = v4 + -0.000001;
      if (v3 >= v8) {
        double v3 = v8;
      }
    }
  }
  if ((*(void *)&v3 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    *a2 = v3;
    double v5 = v7;
  }
  if (a3) {
    *a3 = (int)v5;
  }
  return this;
}

uint64_t CA::Render::Timing::map_parent_to_active(CA::Render::Timing *this, double *a2, BOOL *a3)
{
  int v6 = *((_DWORD *)this + 3);
  double v7 = *a2;
  double v8 = *((double *)this + 5);
  double v9 = CA::Render::Timing::end_time(this);
  if ((v6 & 0x400) == 0 && v7 < v8 || (v6 & 0x200) == 0 && v7 > v9) {
    return 0;
  }
  if (v7 >= v8) {
    double v10 = v7;
  }
  else {
    double v10 = v8;
  }
  double v11 = v9 + -0.000001;
  if (v10 <= v11) {
    double v11 = v10;
  }
  BOOL v12 = v11 != v7;
  double v13 = *((double *)this + 6) + (v11 - v8) * *((float *)this + 4);
  if ((*(void *)&v13 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
    return 0;
  }
  *a2 = v13;
  if (a3) {
    *a3 = v12;
  }
  return 1;
}

double CA::Render::Timing::end_time(CA::Render::Timing *this)
{
  int v1 = *((_DWORD *)this + 3);
  if ((v1 & 0x1000) != 0) {
    return *((double *)this + 7);
  }
  float v2 = *((float *)this + 4);
  if (v2 != 0.0)
  {
    double v5 = 1.0;
    if (v2 == 1.0)
    {
      if ((v1 & 0x800) == 0)
      {
LABEL_7:
        double v7 = *((double *)this + 3);
        double v6 = *((double *)this + 4);
        if ((v1 & 0x100) != 0) {
          double v6 = v6 + v6;
        }
        if (v7 > 0.0) {
          double v6 = v6 * v7;
        }
        goto LABEL_13;
      }
    }
    else
    {
      double v5 = fabsf(1.0 / v2);
      if ((v1 & 0x800) == 0) {
        goto LABEL_7;
      }
    }
    double v6 = *((double *)this + 3);
LABEL_13:
    double v3 = v6 * v5;
    goto LABEL_14;
  }
  double v3 = INFINITY;
LABEL_14:
  double result = v3 + *((double *)this + 5);
  *((double *)this + 7) = result;
  *((_DWORD *)this + 3) = v1 | 0x1000;
  return result;
}

void CA::Render::BasicAnimation0::apply(CA::Render::BasicAnimation0 *this, CA::Render::AnimationEvaluator *a2, double a3, int a4, char a5)
{
  uint64_t v114 = *MEMORY[0x1E4F143B8];
  keypath_object = (atomic_uint *)*((void *)this + 14);
  double v11 = (atomic_uint *)*((void *)this + 15);
  BOOL v12 = (CA::Render::PropertyAnimation *)*((void *)this + 16);
  uint64_t v13 = CA::Render::PropertyAnimation::apply_velocity_state(this, (uint64_t)a2);
  int v14 = (CA::Render::VelocityState *)v13;
  if ((a5 & 1) != 0 || !v13) {
    double v15 = 0.0;
  }
  else {
    double v15 = (*(double (**)(CA::Render::BasicAnimation0 *, double))(*(void *)this + 128))(this, a3)
  }
        * *((float *)a2 + 2);
  uint64_t v16 = (unint64_t *)((char *)this + 96);
  double v17 = (*(double (**)(CA::Render::BasicAnimation0 *, double))(*(void *)this + 168))(this, a3);
  if (CA::Render::Layer::keypath_is_object(*((CA::Render::Layer **)a2 + 5), (const CA::Render::Layer **)this + 12, v18))
  {
    if (keypath_object)
    {
      if (v11) {
        goto LABEL_8;
      }
    }
    else
    {
      keypath_object = (atomic_uint *)CA::Render::Layer::get_keypath_object(*((CA::Render::Layer **)a2 + 5), (const CA::Render::Layer **)this + 12, v19);
      if (v11) {
        goto LABEL_8;
      }
    }
    double v11 = (atomic_uint *)CA::Render::Layer::get_keypath_object(*((CA::Render::Layer **)a2 + 2), (const CA::Render::Layer **)this + 12, v19);
LABEL_8:
    memset(&v109[16], 0, 104);
    *(double *)unsigned int v109 = v17;
    *(double *)&v109[8] = v15;
    v97[0] = 0;
    CA::Render::mix_objects((uint64_t)v97, keypath_object, v11, (const ValueInterpolator *)v109);
    CA::Render::Layer::set_keypath_object(*((CA::Render::Layer **)a2 + 5), (const CA::Render::Layer **)this + 12, (void *const *)v97[0]);
    __int16 v22 = v97[0];
    if (v97[0])
    {
      if (atomic_fetch_add((atomic_uint *volatile)v97[0] + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(CA::Render::Object *))(*(void *)v22 + 16))(v22);
      }
    }
    return;
  }
  if (!v12) {
    goto LABEL_22;
  }
  unint64_t v23 = *v16;
  if (!*v16) {
    goto LABEL_22;
  }
  if (v23)
  {
    v23 >>= 1;
  }
  else
  {
    if (!*(_DWORD *)v23)
    {
LABEL_22:
      char v24 = 0;
      goto LABEL_23;
    }
    LODWORD(v23) = *(_DWORD *)(v23 + 4);
  }
  char v24 = 1;
  if (v23 != 139 && v23 != 546 && v23 != 568) {
    goto LABEL_22;
  }
LABEL_23:
  long long v112 = 0u;
  long long v113 = 0u;
  long long v110 = 0u;
  long long v111 = 0u;
  memset(v109, 0, sizeof(v109));
  long long v107 = 0u;
  long long v108 = 0u;
  long long v105 = 0u;
  long long v106 = 0u;
  long long v103 = 0u;
  long long v104 = 0u;
  long long v101 = 0u;
  long long v102 = 0u;
  long long v99 = 0u;
  long long v100 = 0u;
  *(_OWORD *)__int16 v97 = 0u;
  long long v98 = 0u;
  int v80 = (double *)v109;
  double v79 = (double *)v97;
  if (keypath_object && v11)
  {
    uint64_t v25 = CA::Render::PropertyAnimation::animation_value((CA::Render::PropertyAnimation *)keypath_object, (const CA::Render::Object *)v109, (const CA::Render::Object **)&v80, v20, v21);
LABEL_26:
    unint64_t v28 = v25;
    uint64_t keypath_value = CA::Render::PropertyAnimation::animation_value((CA::Render::PropertyAnimation *)v11, (const CA::Render::Object *)v97, (const CA::Render::Object **)&v79, v26, v27);
LABEL_27:
    long long v30 = (CA::Render::Vector *)keypath_value;
    goto LABEL_28;
  }
  if (keypath_object && v12)
  {
    unint64_t v28 = CA::Render::PropertyAnimation::animation_value((CA::Render::PropertyAnimation *)keypath_object, (const CA::Render::Object *)v109, (const CA::Render::Object **)&v80, v20, v21);
    unint64_t v35 = CA::Render::PropertyAnimation::animation_value(v12, (const CA::Render::Object *)v97, (const CA::Render::Object **)&v79, v33, v34);
    long long v30 = (CA::Render::Vector *)v35;
    if (v24)
    {
      uint64_t v37 = v79;
      if (v28 >= v35) {
        unint64_t v38 = v35;
      }
      else {
        unint64_t v38 = v28;
      }
      if (v38 == 6)
      {
        float64x2_t v62 = *(float64x2_t *)(v80 + 2);
        float64x2_t v63 = vmlaq_laneq_f64(vmlaq_n_f64(*(float64x2_t *)(v80 + 4), *(float64x2_t *)v80, v79[4]), v62, *(float64x2_t *)(v79 + 4), 1);
        float64x2_t v64 = vmlaq_laneq_f64(vmulq_n_f64(*(float64x2_t *)v80, v79[2]), v62, *(float64x2_t *)(v79 + 2), 1);
        *(float64x2_t *)double v79 = vmlaq_laneq_f64(vmulq_n_f64(*(float64x2_t *)v80, *v79), v62, *(float64x2_t *)v79, 1);
        *((float64x2_t *)v37 + 1) = v64;
        *((float64x2_t *)v37 + 2) = v63;
        goto LABEL_28;
      }
      if (v38 == 16)
      {
        long long v93 = *((_OWORD *)v79 + 4);
        long long v94 = *((_OWORD *)v79 + 5);
        long long v95 = *((_OWORD *)v79 + 6);
        long long v96 = *((_OWORD *)v79 + 7);
        float64x2_t v89 = *(float64x2_t *)v79;
        float64x2_t v90 = *(float64x2_t *)(v79 + 2);
        float64x2_t v91 = *(float64x2_t *)(v79 + 4);
        long long v92 = *((_OWORD *)v79 + 3);
        float64x2_t v39 = *(float64x2_t *)v80;
        long long v40 = *((_OWORD *)v80 + 1);
        long long v41 = *((_OWORD *)v80 + 3);
        long long v83 = *((_OWORD *)v80 + 2);
        long long v84 = v41;
        float64x2_t v81 = v39;
        long long v82 = v40;
        long long v42 = *((_OWORD *)v80 + 4);
        long long v43 = *((_OWORD *)v80 + 5);
        long long v44 = *((_OWORD *)v80 + 7);
        long long v87 = *((_OWORD *)v80 + 6);
        long long v88 = v44;
        long long v85 = v42;
        long long v86 = v43;
LABEL_56:
        CA::Mat4Impl::mat4_concat(&v89, v89.f64, v81.f64, v36);
        *((_OWORD *)v37 + 4) = v93;
        *((_OWORD *)v37 + 5) = v94;
        *((_OWORD *)v37 + 6) = v95;
        *((_OWORD *)v37 + 7) = v96;
        *(float64x2_t *)uint64_t v37 = v89;
        *((float64x2_t *)v37 + 1) = v90;
        *((float64x2_t *)v37 + 2) = v91;
        *((_OWORD *)v37 + 3) = v92;
        goto LABEL_28;
      }
    }
    else if (v28 >= v35)
    {
      unint64_t v38 = v35;
    }
    else
    {
      unint64_t v38 = v28;
    }
    if (v38)
    {
      uint64_t v57 = v79;
      int v56 = v80;
      do
      {
        double v58 = *v56++;
        *uint64_t v57 = *v57 + v58;
        ++v57;
        --v38;
      }
      while (v38);
    }
    goto LABEL_28;
  }
  if (v11 && v12)
  {
    unint64_t v28 = CA::Render::PropertyAnimation::animation_value(v12, (const CA::Render::Object *)v109, (const CA::Render::Object **)&v80, v20, v21);
    unint64_t v47 = CA::Render::PropertyAnimation::animation_value((CA::Render::PropertyAnimation *)v11, (const CA::Render::Object *)v97, (const CA::Render::Object **)&v79, v45, v46);
    long long v30 = (CA::Render::Vector *)v47;
    if (v24)
    {
      uint64_t v37 = v80;
      if (v28 >= v47) {
        unint64_t v49 = v47;
      }
      else {
        unint64_t v49 = v28;
      }
      if (v49 == 6)
      {
        float64x2_t v76 = *(float64x2_t *)v79;
        float64x2_t v77 = *(float64x2_t *)(v79 + 2);
        float64x2_t v78 = *(float64x2_t *)(v79 + 4);
        float64x2_t v65 = *(float64x2_t *)(v80 + 2);
        float64x2_t v89 = *(float64x2_t *)v80;
        float64x2_t v90 = v65;
        float64x2_t v91 = *(float64x2_t *)(v80 + 4);
        CA::Mat2Impl::mat2_invert((CA::Mat2Impl *)&v89, v89.f64, v48);
        float64x2_t v66 = vmlaq_laneq_f64(vmulq_n_f64(v89, v77.f64[0]), v90, v77, 1);
        float64x2_t v67 = vmlaq_laneq_f64(vmlaq_n_f64(v91, v89, v78.f64[0]), v90, v78, 1);
        *(float64x2_t *)uint64_t v37 = vmlaq_laneq_f64(vmulq_n_f64(v89, v76.f64[0]), v90, v76, 1);
        *((float64x2_t *)v37 + 1) = v66;
        *((float64x2_t *)v37 + 2) = v67;
        goto LABEL_28;
      }
      if (v49 == 16)
      {
        long long v93 = *((_OWORD *)v79 + 4);
        long long v94 = *((_OWORD *)v79 + 5);
        long long v95 = *((_OWORD *)v79 + 6);
        long long v96 = *((_OWORD *)v79 + 7);
        float64x2_t v89 = *(float64x2_t *)v79;
        float64x2_t v90 = *(float64x2_t *)(v79 + 2);
        float64x2_t v91 = *(float64x2_t *)(v79 + 4);
        long long v92 = *((_OWORD *)v79 + 3);
        float64x2_t v50 = *(float64x2_t *)v80;
        long long v51 = *((_OWORD *)v80 + 1);
        long long v52 = *((_OWORD *)v80 + 3);
        long long v83 = *((_OWORD *)v80 + 2);
        long long v84 = v52;
        float64x2_t v81 = v50;
        long long v82 = v51;
        long long v53 = *((_OWORD *)v80 + 4);
        long long v54 = *((_OWORD *)v80 + 5);
        long long v55 = *((_OWORD *)v80 + 7);
        long long v87 = *((_OWORD *)v80 + 6);
        long long v88 = v55;
        long long v85 = v53;
        long long v86 = v54;
        CA::Mat4Impl::mat4_invert((CA::Mat4Impl *)&v81, (CA::Mat4Impl *)&v81, v48);
        goto LABEL_56;
      }
    }
    else if (v28 >= v47)
    {
      unint64_t v49 = v47;
    }
    else
    {
      unint64_t v49 = v28;
    }
    if (v49)
    {
      uint64_t v59 = v79;
      unsigned int v60 = v80;
      do
      {
        double v61 = *v59++;
        *unsigned int v60 = v61 - *v60;
        ++v60;
        --v49;
      }
      while (v49);
    }
    goto LABEL_28;
  }
  if (keypath_object)
  {
    unint64_t v28 = CA::Render::PropertyAnimation::animation_value((CA::Render::PropertyAnimation *)keypath_object, (const CA::Render::Object *)v109, (const CA::Render::Object **)&v80, v20, v21);
    uint64_t keypath_value = CA::Render::Layer::get_keypath_value(*((CA::Render::Layer **)a2 + 2), (unint64_t *)this + 12, 0x18uLL, (float64x2_t *)v97, (float64x2_t **)&v79);
    goto LABEL_27;
  }
  if (v11)
  {
    uint64_t v25 = CA::Render::Layer::get_keypath_value(*((CA::Render::Layer **)a2 + 5), (unint64_t *)this + 12, 0x18uLL, (float64x2_t *)v109, (float64x2_t **)&v80);
    goto LABEL_26;
  }
  if (v12)
  {
    unint64_t v28 = CA::Render::Layer::get_keypath_value(*((CA::Render::Layer **)a2 + 5), (unint64_t *)this + 12, 0x18uLL, (float64x2_t *)v109, (float64x2_t **)&v80);
    unint64_t v70 = CA::Render::PropertyAnimation::animation_value(v12, (const CA::Render::Object *)v97, (const CA::Render::Object **)&v79, v68, v69);
    long long v30 = (CA::Render::Vector *)v70;
    if (v24)
    {
      if (v28 >= v70) {
        double v71 = (const double *)v70;
      }
      else {
        double v71 = (const double *)v28;
      }
        goto LABEL_28;
    }
    else if (v28 >= v70)
    {
      double v71 = (const double *)v70;
    }
    else
    {
      double v71 = (const double *)v28;
    }
    if (v71)
    {
      uint64_t v73 = v79;
      uint64_t v72 = v80;
      do
      {
        double v74 = *v72++;
        double *v73 = *v73 + v74;
        ++v73;
        double v71 = (const double *)((char *)v71 - 1);
      }
      while (v71);
    }
    goto LABEL_28;
  }
  unint64_t v28 = 0;
  long long v30 = 0;
LABEL_28:
  if ((unint64_t)v30 >= v28) {
    long long v31 = (CA::Render::Vector *)v28;
  }
  else {
    long long v31 = v30;
  }
  uint64_t v32 = v80;
  if (v31)
  {
    *(void *)&long long v96 = 0;
    long long v94 = 0u;
    long long v95 = 0u;
    long long v92 = 0u;
    long long v93 = 0u;
    float64x2_t v90 = 0u;
    float64x2_t v91 = 0u;
    v89.f64[0] = v17;
    v89.f64[1] = v15;
    LODWORD(v75) = a4;
    CA::Render::PropertyAnimation::set(this, *((CA::Render::Layer **)a2 + 5), v14, v31, 0, v80, v79, 0, v80, v79, (const CA::Render::ValueInterpolator *)&v89, v75);
    uint64_t v32 = v80;
  }
  if (v32 != (double *)v109) {
    free(v32);
  }
  if (v79 != (double *)v97) {
    free(v79);
  }
}

uint64_t CA::Render::PropertyAnimation::animation_value(CA::Render::PropertyAnimation *this, const CA::Render::Object *a2, const CA::Render::Object **a3, double *a4, double **a5)
{
  if (*((unsigned char *)this + 12) != 56) {
    return 0;
  }
  double v6 = a2;
  uint64_t v8 = *((unsigned int *)this + 4);
  double v9 = a2;
  if (v8 < 0x19)
  {
LABEL_5:
    if (v9)
    {
      double v6 = v9;
      uint64_t result = v8;
    }
    else
    {
      uint64_t result = 24;
    }
    if (!result) {
      goto LABEL_14;
    }
    goto LABEL_12;
  }
  if (a3)
  {
    double v9 = (const CA::Render::Object *)malloc_type_malloc(8 * v8, 0x100004000313F17uLL);
    goto LABEL_5;
  }
  uint64_t result = 24;
LABEL_12:
  for (uint64_t i = 0; i != result; ++i)
    *((void *)v6 + i) = *((void *)this + i + 3);
LABEL_14:
  if (a3) {
    *a3 = v6;
  }
  return result;
}

uint64_t CA::Render::Layer::keypath_is_object(CA::Render::Layer *this, const CA::Render::Layer **a2, void *const *a3)
{
  v14[1] = *MEMORY[0x1E4F143B8];
  v14[0] = this;
  unsigned int v5 = CA::Render::skip_sublayers((CA::Render *)v14, a2, a3);
  if ((v5 & 0x80000000) != 0) {
    return 0;
  }
  unint64_t v6 = (unint64_t)*a2;
  if (!*a2)
  {
    if (v5 != -1) {
      return 0;
    }
    goto LABEL_19;
  }
  if (v6) {
    int v7 = 1;
  }
  else {
    int v7 = *(_DWORD *)v6;
  }
  int v8 = v7 - v5;
  if (v8 != 1)
  {
    if (v8 > 3 || !v6) {
      return 0;
    }
    if (v6)
    {
      if (v5) {
        return 0;
      }
      unint64_t v9 = v6 >> 1;
    }
    else
    {
      if (*(_DWORD *)v6 <= v5) {
        return 0;
      }
      LODWORD(v9) = *(_DWORD *)(v6 + 4 * v5 + 4);
    }
    if (v9 != 226)
    {
      if (v9 == 113)
      {
        unsigned int v13 = v5 + 1;
        return (v6 & 1) == 0 && *(_DWORD *)v6 > v13 && *(_DWORD *)(v6 + 4 * v13 + 4) == 289;
      }
      if (v9 != 56) {
        return 0;
      }
    }
    unsigned int v13 = v5 + 2;
    return (v6 & 1) == 0 && *(_DWORD *)v6 > v13 && *(_DWORD *)(v6 + 4 * v13 + 4) == 289;
  }
  if (!v6) {
    goto LABEL_19;
  }
  if (v6)
  {
    if (v5) {
      goto LABEL_19;
    }
    v6 >>= 1;
  }
  else
  {
    if (*(_DWORD *)v6 <= v5) {
      goto LABEL_19;
    }
    LODWORD(v6) = *(_DWORD *)(v6 + 4 * v5 + 4);
  }
  uint64_t result = 1;
  if ((int)v6 > 225)
  {
    if ((int)v6 > 503)
    {
      if (v6 == 504 || v6 == 547) {
        return result;
      }
    }
    else if (v6 == 226 || v6 == 386)
    {
      return result;
    }
  }
  else if ((v6 - 113) <= 0x1E && ((1 << (v6 - 113)) & 0x40000041) != 0 || v6 == 56)
  {
    return result;
  }
LABEL_19:
  double v10 = (uint64_t *)*((void *)this + 16);
  if (!v10) {
    return 0;
  }
  uint64_t result = *v10;
  if (*v10)
  {
    BOOL v12 = *(uint64_t (**)(void))(*(void *)result + 112);
    return v12();
  }
  return result;
}

unint64_t CA::Render::skip_sublayers(CA::Render *this, const CA::Render::Layer **a2, void *const *a3)
{
  double v3 = (int *)*a2;
  if (!*a2) {
    return 0;
  }
  if (v3)
  {
    int v6 = 1;
  }
  else
  {
    int v6 = *v3;
    if (*v3 < 1) {
      return 0;
    }
  }
  for (unint64_t i = 0; v6 > (int)i; i += 2)
  {
    unint64_t v8 = (unint64_t)*a2;
    if (!*a2) {
      break;
    }
    if (v8)
    {
      if (i) {
        return i;
      }
      v8 >>= 1;
    }
    else
    {
      if (i >= *(unsigned int *)v8) {
        return i;
      }
      LODWORD(v8) = *(_DWORD *)(v8 + 4 * i + 4);
    }
    if (v8 != 547) {
      break;
    }
    uint64_t v9 = *(void *)(*(void *)this + 104);
    if ((*(unsigned char *)(*(void *)this + 13) & 0x20) != 0)
    {
      if (!v9) {
        return 0xFFFFFFFFLL;
      }
      double v11 = *(CA::Render::String **)(v9 + 120);
      if (!v11 || !CA::Render::String::equal(v11, 0x223u)) {
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      if (!v9) {
        return 0xFFFFFFFFLL;
      }
      unsigned int named_object = CA::Render::TypedArray<CA::Render::Layer>::find_named_object(*(void *)(*(void *)this + 104), 0x223u);
      if ((named_object & 0x80000000) != 0) {
        return 0xFFFFFFFFLL;
      }
      uint64_t v9 = *(void *)(v9 + 8 * named_object + 24);
    }
    *(void *)this = v9;
  }
  return i;
}

void CA::Render::PropertyAnimation::set(CA::Render::PropertyAnimation *this, CA::Render::Layer *a2, CA::Render::VelocityState *a3, CA::Render::Vector *a4, unint64_t a5, const double *a6, const double *a7, unint64_t a8, const double *a9, const double *a10, const CA::Render::ValueInterpolator *a11, double *a12)
{
  uint64_t v204 = *MEMORY[0x1E4F143B8];
  if (!((unint64_t)a4 >> 61))
  {
    double v15 = a4;
    double v18 = this;
    long long v154 = a7;
    size_t v155 = 8 * (void)a4;
    if ((unint64_t)(8 * (void)a4) > 0x1000)
    {
      int v34 = (float64x2_t *)malloc_type_malloc(v155, 0x2B6CFB91uLL);
      unint64_t v35 = v154;
      if (!v34) {
        return;
      }
      __int16 v22 = v34;
      __asm { FMOV            V0.2D, #1.0 }
      float64x2_t v178 = (float64x2_t)_Q0;
      if (!a3)
      {
        long long v151 = 0;
        unint64_t v152 = 0;
        int v32 = 0;
        long long v33 = 0;
        goto LABEL_12;
      }
      unint64_t v152 = (float64x2_t *)malloc_type_malloc(v155, 0x923DBC3EuLL);
      if (!v152) {
        return;
      }
      long long v151 = a3;
      int v32 = 1;
      long long v33 = v22;
    }
    else
    {
      uint64_t v150 = a4;
      size_t v20 = v155;
      MEMORY[0x1F4188790](this);
      size_t v21 = (v155 + 15) & 0xFFFFFFFFFFFFFFF0;
      __int16 v22 = (float64x2_t *)((char *)&v142 - v21);
      bzero((char *)&v142 - v21, v155);
      __asm { FMOV            V0.2D, #1.0 }
      float64x2_t v178 = (float64x2_t)_Q0;
      long long v151 = a3;
      if (a3)
      {
        MEMORY[0x1F4188790](v23);
        unint64_t v152 = (float64x2_t *)((char *)&v142 - v21);
        bzero((char *)&v142 - v21, v20);
        int v32 = 1;
        long long v33 = (float64x2_t *)((char *)&v142 - v21);
      }
      else
      {
        int v32 = 0;
        unint64_t v152 = 0;
        long long v33 = 0;
      }
      double v18 = this;
      double v15 = v150;
    }
    unint64_t v35 = v154;
LABEL_12:
    char v36 = *((unsigned char *)v18 + 13);
    long long v153 = a2;
    if ((v36 & 4) != 0 && (uint64_t v37 = *((void *)v18 + 5)) != 0)
    {
      if (*(unsigned char *)(v37 + 13)) {
        a10 = a9;
      }
    }
    else
    {
      a10 = 0;
    }
    unint64_t v39 = *((void *)v18 + 12);
    uint64_t v150 = (CA::Render::PropertyAnimation *)((char *)v18 + 96);
    if (v39)
    {
      if (v39)
      {
        v39 >>= 1;
      }
      else
      {
        if (!*(_DWORD *)v39) {
          goto LABEL_33;
        }
        LODWORD(v39) = *(_DWORD *)(v39 + 4);
      }
      if (v39 == 139 || v39 == 568 || v39 == 546)
      {
        if (v15 == (CA::Render::Vector *)6)
        {
          float64x2_t v193 = 0u;
          __n128 v194 = 0u;
          float64x2_t v192 = 0u;
          if (v35)
          {
            long long v90 = *((_OWORD *)a6 + 1);
            float64x2_t v189 = *(float64x2_t *)a6;
            long long v190 = v90;
            long long v191 = *((_OWORD *)a6 + 2);
            float64x2_t v91 = *(float64x2_t *)(v35 + 2);
            float64x2_t v170 = *(float64x2_t *)v35;
            float64x2_t v171 = v91;
            float64x2_t v172 = *(float64x2_t *)(v35 + 4);
            int v92 = v32;
            if (v32)
            {
              v183.f64[0] = 0.0;
              float64x2_t v181 = 0u;
              float64x2_t v182 = 0u;
              float64x2_t v179 = 0u;
              float64x2_t v180 = 0u;
              CA::Mat2Impl::mat2_mix_with_deriv(&v192, (uint64_t)&v189, (uint64_t)&v170, &v179, &v178, *(double *)a11, *((double *)a11 + 1));
              long long v33 = &v178;
              long long v93 = v152;
              *unint64_t v152 = v179;
              v93[1] = v180;
              v93[2].f64[0] = v181.f64[0];
            }
            else
            {
              long long v100 = v33;
              CA::Mat2Impl::mat2_mix((CA::Mat2Impl *)&v192, v189.f64, v170.f64, v26, *(double *)a11);
              long long v33 = v100;
            }
            int v88 = v92;
            LOBYTE(v32) = v92;
          }
          else
          {
            int v88 = 0;
            float64x2_t v98 = *(float64x2_t *)(a6 + 2);
            float64x2_t v192 = *(float64x2_t *)a6;
            float64x2_t v193 = v98;
            __n128 v194 = *(__n128 *)(a6 + 4);
          }
          if (a10)
          {
            float64x2_t v101 = *(float64x2_t *)(a10 + 2);
            float64x2_t v179 = *(float64x2_t *)a10;
            float64x2_t v180 = v101;
            float64x2_t v181 = *(float64x2_t *)(a10 + 4);
            char v102 = v32;
            long long v103 = v33;
            CA::Mat2Impl::mat2_pow((CA::Mat2Impl *)&v179, (double *)a12, v25, v26);
            long long v33 = v103;
            LOBYTE(v32) = v102;
            float64x2_t v104 = v192;
            *(void *)&v105.f64[0] = *(_OWORD *)&vmulq_laneq_f64(v193, v179, 1);
            float64x2_t v106 = vmulq_f64((float64x2_t)vzip2q_s64((int64x2_t)v192, (int64x2_t)v193), v179);
            v105.f64[1] = v106.f64[1];
            float64x2_t v107 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v106.f64[0], 0);
            *(void *)&v107.f64[0] = *(_OWORD *)&vmulq_f64(v192, v179);
            float64x2_t v192 = vaddq_f64(v105, v107);
            float64x2_t v108 = vmlaq_n_f64(vmulq_n_f64(v104, v180.f64[0]), v193, v180.f64[1]);
            _Q0 = (__n128)vmlaq_n_f64(vmlaq_n_f64((float64x2_t)v194, v104, v181.f64[0]), v193, v181.f64[1]);
            float64_t v109 = v192.f64[1];
          }
          else
          {
            float64_t v109 = v192.f64[1];
            float64x2_t v108 = v193;
            _Q0 = v194;
          }
          float64x2_t v89 = v153;
          unint64_t v35 = v154;
          v22->f64[0] = v192.f64[0];
          v22->f64[1] = v109;
          v22[1] = v108;
          void v22[2] = (float64x2_t)_Q0;
LABEL_92:
          char v136 = v32 ^ 1;
          if (!v35) {
            char v136 = 1;
          }
          if ((v136 & 1) == 0) {
            CA::Render::VelocityState::set_keypath_velocity((uint64_t)v151, *((void *const **)v18 + 12), *((CA::Render::Function **)v18 + 13), (*((_DWORD *)v18 + 3) >> 9) & 1, (unint64_t)v15, (CA::Mat4Impl *)v152, v33->f64, v88, _Q0);
          }
          uint64_t v137 = *((void *)v18 + 13);
          if (v137)
          {
            if ((*(unsigned int (**)(uint64_t))(*(void *)v137 + 104))(v137) <= (unint64_t)v15)
            {
              uint64_t v138 = (*(uint64_t (**)(void))(**((void **)v18 + 13) + 112))(*((void *)v18 + 13));
              unsigned int v139 = v138;
              if (v138 <= 0x200)
              {
                MEMORY[0x1F4188790](v138);
                uint64_t v141 = (char *)&v142 - ((v140 + 15) & 0xFFFFFFFF0);
                bzero(v141, v140);
LABEL_102:
                *(void *)&v179.f64[0] = v18;
                *(void *)&v179.f64[1] = v89;
                if ((*(unsigned int (**)(void, uint64_t, float64x2_t *, void, char *, void, float64_t (*)(CA::Render *, const unsigned int *, const unsigned int *, uint64_t, void *), float64x2_t *))(**((void **)v18 + 13) + 128))(*((void *)v18 + 13), 1, v22, 0, v141, 0, CA::Render::animation_get_function_param, &v179))
                {
                  CA::Render::Layer::set_keypath_value(v89, (unint64_t *)v150, (const unsigned int *)((*((_DWORD *)v18 + 3) >> 9) & 1), (CA::Render::Vector *)v139, (double *)v141);
                }
                if (v139 >= 0x201) {
                  free(v141);
                }
                goto LABEL_106;
              }
              uint64_t v141 = (char *)malloc_type_malloc(8 * v138, 0xBF37FB71uLL);
              if (v141) {
                goto LABEL_102;
              }
            }
          }
          else
          {
            CA::Render::Layer::set_keypath_value(v89, (unint64_t *)v150, (const unsigned int *)((*((_DWORD *)v18 + 3) >> 9) & 1), v15, v22->f64);
          }
LABEL_106:
          if (v155 > 0x1000) {
            free(v22);
          }
          return;
        }
        if (v15 == (CA::Render::Vector *)16)
        {
          float64x2_t v176 = 0u;
          long long v177 = 0u;
          float64x2_t v174 = 0u;
          long long v175 = 0u;
          float64x2_t v172 = 0u;
          float64x2_t v173 = 0u;
          float64x2_t v170 = 0u;
          float64x2_t v171 = 0u;
          if (v35)
          {
            long long v40 = *((_OWORD *)a6 + 5);
            long long v166 = *((_OWORD *)a6 + 4);
            long long v167 = v40;
            long long v41 = *((_OWORD *)a6 + 7);
            float64x2_t v168 = *(float64x2_t *)(a6 + 12);
            long long v169 = v41;
            float64x2_t v42 = *(float64x2_t *)(a6 + 2);
            v163[0] = *(float64x2_t *)a6;
            v163[1] = v42;
            long long v43 = *((_OWORD *)a6 + 3);
            float64x2_t v164 = *(float64x2_t *)(a6 + 4);
            long long v165 = v43;
            float64x2_t v44 = *(float64x2_t *)v35;
            long long v45 = *((_OWORD *)v35 + 1);
            long long v46 = *((_OWORD *)v35 + 3);
            long long v157 = *((_OWORD *)v35 + 2);
            long long v158 = v46;
            v156[0] = v44;
            v156[1] = v45;
            long long v47 = *((_OWORD *)v35 + 4);
            long long v48 = *((_OWORD *)v35 + 5);
            long long v49 = *((_OWORD *)v35 + 7);
            long long v161 = *((_OWORD *)v35 + 6);
            long long v162 = v49;
            long long v159 = v47;
            long long v160 = v48;
            int v50 = v32;
            if (v32)
            {
              double v51 = *(double *)a11;
              *(void *)&long long v47 = *((void *)a11 + 1);
              long long v148 = v47;
              if (CA::Mat4Impl::mat4_is_affine((CA::Mat4Impl *)v163, v24)
                && CA::Mat4Impl::mat4_is_affine((CA::Mat4Impl *)v156, v52))
              {
                float64x2_t v192 = v163[0];
                float64x2_t v193 = v164;
                __n128 v194 = (__n128)v168;
                float64x2_t v189 = (float64x2_t)v156[0];
                long long v190 = v157;
                long long v191 = v161;
                CA::Mat2Impl::mat2_mix_with_deriv(v203, (uint64_t)&v192, (uint64_t)&v189, &v179, &v178, v51, *(double *)&v148);
                double v53 = 0.0;
                long long v54 = v151;
                unint64_t v35 = v154;
                int v32 = v50;
                float64x2_t v55 = v179;
                float64x2_t v56 = v180;
                memset(v188, 0, 40);
                float64x2_t v174 = 0u;
                long long v175 = xmmword_184997D50;
                float64x2_t v170 = v203[0];
                float64x2_t v171 = 0u;
                float64x2_t v142 = 0u;
                float64x2_t v172 = v203[1];
                float64x2_t v173 = 0u;
                double v57 = 1.0;
                char v58 = 1;
                double v59 = 0.0;
                float64x2_t v176 = v203[2];
                long long v177 = xmmword_184997D60;
                double v60 = 0.0;
                double v61 = 0.0;
                double v62 = v181.f64[0];
              }
              else
              {
                CA::Mat4Impl::mat4_get_unmatrix(v163[0].f64, (uint64_t)&v179, (const double *)1);
                CA::Mat4Impl::mat4_get_unmatrix((double *)v156, (uint64_t)&v192, (const double *)1);
                CA::mix((uint64_t)&v189, &v179, &v192, v51);
                double v110 = *((double *)&v185 + 1);
                v188[0] = vmulq_n_f64(vsubq_f64(v196, v183), *(double *)&v148);
                v188[1] = vmulq_n_f64(vsubq_f64(v197, v184), *(double *)&v148);
                *(double *)&v188[2] = (v198 - *(double *)&v185) * *(double *)&v148;
                double v111 = *((double *)&v186 + 1);
                double v112 = *(double *)&v186;
                double v113 = v187;
                double v114 = v200 * *(double *)&v186 + v201 * *((double *)&v186 + 1);
                double v115 = v114 + v199 * *((double *)&v185 + 1) + v202 * v187;
                long long v54 = v151;
                long long v147 = v188[0];
                if (v115 < 0.0)
                {
                  double v115 = -(v114 + v202 * v187 + v199 * *((double *)&v185 + 1));
                  double v110 = -*((double *)&v185 + 1);
                  double v112 = -*(double *)&v186;
                  double v111 = -*((double *)&v186 + 1);
                  double v113 = -v187;
                }
                float64x2_t v146 = vsubq_f64(v192, v179);
                float64x2_t v144 = vsubq_f64((float64x2_t)v194, v181);
                float64x2_t v145 = vsubq_f64(v193, v180);
                float64x2_t v143 = vsubq_f64(v195, v182);
                double v116 = v112 * v201 + v113 * v199 - (v110 * v202 + v111 * v200);
                double v117 = v111 * v199 + v113 * v200 - (v110 * v201 + v112 * v202);
                double v118 = v110 * v200 + v113 * v201 - (v112 * v199 + v111 * v202);
                double v119 = sqrt(v116 * v116 + v117 * v117 + v118 * v118);
                long double v122 = atan2(v119, v115);
                double v123 = v122 + v122;
                if (v119 == 0.0)
                {
                  double v57 = 1.0;
                  double v60 = 0.0;
                  double v61 = 0.0;
                }
                else
                {
                  double v60 = v116 * (1.0 / v119);
                  double v61 = v117 * (1.0 / v119);
                  double v57 = v118 * (1.0 / v119);
                  if (v57 < 0.0)
                  {
                    double v60 = -v60;
                    double v61 = -v61;
                    double v57 = -v57;
                    double v123 = -v123;
                  }
                }
                float64x2_t v145 = vmulq_n_f64(v145, *(double *)&v148);
                float64x2_t v146 = vmulq_n_f64(v146, *(double *)&v148);
                float64x2_t v142 = vmulq_n_f64(v144, *(double *)&v148);
                float64x2_t v144 = vmulq_n_f64(v143, *(double *)&v148);
                double v62 = -(*(double *)&v148 * v123);
                float64x2_t v178 = v189;
                CA::Mat4Impl::mat4_set_unmatrix((CA::Mat4Impl *)&v170, (uint64_t)&v189, v120, v121);
                float64x2_t v56 = v144;
                double v53 = v145.f64[0];
                float64x2_t v55 = v146;
                double v59 = *(double *)&v147;
                char v58 = vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqzq_f64(*(float64x2_t *)((char *)v188 + 8)), (int32x4_t)vceqzq_f64(*(float64x2_t *)((char *)&v188[1] + 8)))))) ^ 1;
                unint64_t v35 = v154;
                int v32 = v50;
              }
              if ((v58 & 1) == 0
                || fabs(v60) >= 0.000001
                || fabs(v61) >= 0.000001
                || fabs(v57 + -1.0) >= 0.000001
                || v142.f64[0] != 0.0
                || v142.f64[1] != 0.0)
              {
                if ((*((unsigned char *)v54 + 121) & 8) == 0) {
                  *((unsigned char *)v54 + 124) = 3;
                }
                *((_DWORD *)v54 + 30) = 2048;
              }
              if (fabs(v53 + -1.0) >= 0.000001 || fabs(v59) >= 0.000001) {
                *((_DWORD *)v54 + 30) |= 0x400u;
              }
              long long v151 = v54;
              uint64_t v124 = (CA::Mat4Impl *)v152;
              *unint64_t v152 = v55;
              *((float64x2_t *)v124 + 1) = v56;
              long long v33 = &v178;
              int v88 = v32;
              *((double *)v124 + 4) = v62;
            }
            else
            {
              long long v99 = v33;
              CA::Mat4Impl::mat4_mix((CA::Mat4Impl *)&v170, v163, (double *)v156, v26, *(double *)a11);
              long long v33 = v99;
              int v88 = 0;
              unint64_t v35 = v154;
              LOBYTE(v32) = 0;
            }
          }
          else
          {
            int v88 = 0;
            long long v94 = *((_OWORD *)a6 + 5);
            float64x2_t v174 = *(float64x2_t *)(a6 + 8);
            long long v175 = v94;
            long long v95 = *((_OWORD *)a6 + 7);
            float64x2_t v176 = *(float64x2_t *)(a6 + 12);
            long long v177 = v95;
            float64x2_t v96 = *(float64x2_t *)(a6 + 2);
            float64x2_t v170 = *(float64x2_t *)a6;
            float64x2_t v171 = v96;
            float64x2_t v97 = *(float64x2_t *)(a6 + 6);
            float64x2_t v172 = *(float64x2_t *)(a6 + 4);
            float64x2_t v173 = v97;
          }
          if (a10)
          {
            float64x2_t v125 = *(float64x2_t *)(a10 + 10);
            float64x2_t v183 = *(float64x2_t *)(a10 + 8);
            float64x2_t v184 = v125;
            long long v126 = *((_OWORD *)a10 + 7);
            long long v185 = *((_OWORD *)a10 + 6);
            long long v186 = v126;
            float64x2_t v127 = *(float64x2_t *)(a10 + 2);
            float64x2_t v179 = *(float64x2_t *)a10;
            float64x2_t v180 = v127;
            float64x2_t v128 = *(float64x2_t *)(a10 + 6);
            float64x2_t v181 = *(float64x2_t *)(a10 + 4);
            float64x2_t v182 = v128;
            char v129 = v32;
            uint64_t v130 = v33;
            CA::Mat4Impl::mat4_pow((CA::Mat4Impl *)&v179, (double *)a12, v25, v26);
            CA::Mat4Impl::mat4_concat(&v170, v179.f64, v170.f64, v131);
            long long v33 = v130;
            LOBYTE(v32) = v129;
            unint64_t v35 = v154;
          }
          long long v132 = v175;
          v22[4] = v174;
          v22[5] = (float64x2_t)v132;
          long long v133 = v177;
          v22[6] = v176;
          v22[7] = (float64x2_t)v133;
          float64x2_t v134 = v171;
          *__int16 v22 = v170;
          v22[1] = v134;
          _Q0 = (__n128)v172;
          float64x2_t v135 = v173;
          void v22[2] = v172;
          uint64_t v22[3] = v135;
LABEL_91:
          float64x2_t v89 = v153;
          goto LABEL_92;
        }
      }
    }
LABEL_33:
    LODWORD(v148) = a12;
    uint64_t v149 = (double *)v22;
    if (v35)
    {
      float64x2_t v63 = v22;
      float64x2_t v64 = v33;
      int v65 = v32;
      (*(void (**)(CA::Render::PropertyAnimation *, CA::Render::Vector *, float64x2_t *, unint64_t, const double *, const double *, unint64_t, const CA::Render::ValueInterpolator *))(*(void *)v18 + 160))(v18, v15, v63, a5, a6, v35, a8, a11);
      long long v33 = v64;
      LOBYTE(v32) = v65;
      unint64_t v35 = v154;
      if (v65)
      {
        if (*((unsigned char *)a11 + 112) && a5 | a8)
        {
          _Q0.n128_u64[0] = -2.0;
          float64x2_t v66 = v15;
          float64x2_t v67 = v154;
          uint64_t v68 = (double *)v152;
          while (1)
          {
            double v69 = *a6++;
            double v70 = v69;
            double v71 = *v67++;
            double v72 = v71;
            if (a5)
            {
              double v73 = *(double *)a5;
              a5 += 8;
              double v74 = v73;
              if (!a8) {
                goto LABEL_42;
              }
            }
            else
            {
              double v74 = -(v72 + v70 * -2.0);
              if (!a8)
              {
LABEL_42:
                double v76 = -(v70 + v72 * -2.0);
                goto LABEL_43;
              }
            }
            double v75 = *(double *)a8;
            a8 += 8;
            double v76 = v75;
LABEL_43:
            *v68++ = (*((double *)a11 + 6) * v70
                    + *((double *)a11 + 7) * (*((double *)a11 + 10) * (v70 - v74) + *((double *)a11 + 11) * (v72 - v70))
                    + *((double *)a11 + 8) * v72
                    + *((double *)a11 + 9) * (*((double *)a11 + 12) * (v72 - v70) + *((double *)a11 + 13) * (v76 - v72)))
                   * *((double *)a11 + 1);
            float64x2_t v66 = (CA::Render::Vector *)((char *)v66 - 1);
            if (!v66) {
              goto LABEL_50;
            }
          }
        }
        double v79 = v15;
        int v80 = (double *)v154;
        float64x2_t v81 = (CA::Mat4Impl *)v152;
        do
        {
          double v82 = *a6++;
          double v83 = v82;
          double v84 = *v80++;
          _Q0.n128_f64[0] = *((double *)a11 + 1) * (v84 - v83);
          *(void *)float64x2_t v81 = _Q0.n128_u64[0];
          float64x2_t v81 = (CA::Mat4Impl *)((char *)v81 + 8);
          double v79 = (CA::Render::Vector *)((char *)v79 - 1);
        }
        while (v79);
      }
    }
    else
    {
      float64x2_t v77 = v15;
      do
      {
        unint64_t v78 = *(void *)a6++;
        _Q0.n128_u64[0] = v78;
        *(void *)&v22->f64[0] = v78;
        __int16 v22 = (float64x2_t *)((char *)v22 + 8);
        float64x2_t v77 = (CA::Render::Vector *)((char *)v77 - 1);
      }
      while (v77);
    }
LABEL_50:
    if (!a10)
    {
      int v88 = 0;
      float64x2_t v89 = v153;
      __int16 v22 = (float64x2_t *)v149;
      goto LABEL_92;
    }
    _Q0.n128_f64[0] = (double)(int)v148;
    __int16 v22 = (float64x2_t *)v149;
    long long v85 = v149;
    long long v86 = v15;
    do
    {
      double v87 = *a10++;
      *long long v85 = *v85 + v87 * _Q0.n128_f64[0];
      ++v85;
      long long v86 = (CA::Render::Vector *)((char *)v86 - 1);
    }
    while (v86);
    int v88 = 0;
    goto LABEL_91;
  }
}

uint64_t CA::Render::VelocityState::set_keypath_velocity(uint64_t this, void *const *a2, CA::Render::Function *a3, int a4, unint64_t a5, CA::Mat4Impl *a6, double *a7, int a8, __n128 a9)
{
  char v9 = a8;
  uint64_t v15 = this;
  unsigned int v110[2] = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    LODWORD(v18) = 0;
    BOOL v19 = 0;
    uint64_t v16 = 0;
    LODWORD(v110[1]) = 0;
    v110[0] = 0;
    goto LABEL_8;
  }
  if ((a2 & 1) == 0)
  {
    uint64_t v16 = *(unsigned int *)a2;
    if (v16 >= 4)
    {
      if ((*(unsigned char *)(this + 121) & 8) == 0) {
        *(unsigned char *)(this + 124) = 1;
      }
      int v17 = 2048;
      goto LABEL_186;
    }
    LODWORD(v110[1]) = 0;
    v110[0] = 0;
    uint64_t v23 = *(unsigned int *)a2;
    if (v23)
    {
      uint64_t v24 = 0;
      uint64_t v25 = 4 * v23;
      do
      {
        *(_DWORD *)((char *)v110 + v24) = *(_DWORD *)((char *)a2 + v24 + 4);
        v24 += 4;
      }
      while (v25 != v24);
      LODWORD(v18) = v110[0];
      goto LABEL_22;
    }
    LODWORD(v18) = 0;
    BOOL v19 = 0;
LABEL_8:
    BOOL v20 = a5 == 16;
    goto LABEL_9;
  }
  unint64_t v18 = (unint64_t)a2 >> 1;
  LODWORD(v110[1]) = 0;
  v110[0] = ((unint64_t)a2 >> 1);
  uint64_t v16 = 1;
LABEL_22:
  BOOL v19 = v16 == 1 && v18 == 568;
  BOOL v20 = a5 == 16;
  if (a5 == 16 && v19)
  {
    if (!a3)
    {
      if (!a8)
      {
        long long v40 = (double *)(this + 88);
        goto LABEL_50;
      }
LABEL_35:
      double v28 = *(double *)a6;
      double v29 = *(double *)(v15 + 72);
      double v30 = *(double *)(v15 + 80);
      double v31 = *(double *)(v15 + 64);
      double v32 = v29 * *(double *)a6 + *(double *)(v15 + 56) * *a7;
      if (!a4) {
        double v29 = 1.0;
      }
      *(double *)(v15 + 72) = v29 * *a7;
      if (a4) {
        double v33 = v32;
      }
      else {
        double v33 = v28;
      }
      *(double *)(v15 + 56) = v33;
      double v34 = a7[1];
      double v35 = *((double *)a6 + 1);
      if (a4) {
        double v36 = v30;
      }
      else {
        double v36 = 1.0;
      }
      *(double *)(v15 + 80) = v36 * v34;
      double v37 = v30 * v35 + v31 * v34;
      if (!a4) {
        double v37 = v35;
      }
      *(double *)(v15 + 64) = v37;
      if (a4)
      {
        double v38 = *(double *)(v15 + 96);
        *(double *)(v15 + 88) = *((double *)a6 + 2) + *(double *)(v15 + 88);
        *(double *)(v15 + 96) = *((double *)a6 + 3) + v38;
        double v39 = *((double *)a6 + 4) + *(double *)(v15 + 112);
      }
      else
      {
        *(void *)(v15 + 88) = *((void *)a6 + 2);
        *(void *)(v15 + 96) = *((void *)a6 + 3);
        double v39 = *((double *)a6 + 4);
      }
      *(double *)(v15 + 112) = v39;
      int v50 = 368;
      goto LABEL_185;
    }
    BOOL v20 = 1;
    LODWORD(v18) = 568;
    goto LABEL_32;
  }
LABEL_9:
  if (!a5) {
    return this;
  }
  unint64_t v21 = a5;
  for (unint64_t i = (unint64_t *)a6; ; ++i)
  {
    a9.n128_u64[0] = *i;
    if (*(double *)i != 0.0) {
      break;
    }
    if (!--v21) {
      return this;
    }
  }
  if (a3)
  {
    if (!v19)
    {
      LODWORD(v110[0]) = 0;
      goto LABEL_180;
    }
LABEL_32:
    switch((*(unsigned int (**)(CA::Render::Function *, __n128))(*(void *)a3 + 120))(a3, a9))
    {
      case 0xFFFFFFFF:
        LODWORD(v18) = 0;
        LODWORD(v110[0]) = 0;
        goto LABEL_162;
      case 0u:
      case 1u:
      case 2u:
        int v27 = 481;
        goto LABEL_70;
      case 3u:
      case 4u:
      case 5u:
      case 6u:
      case 7u:
      case 8u:
        int v27 = 486;
        goto LABEL_70;
      case 9u:
      case 0xAu:
      case 0xBu:
      case 0xCu:
        int v27 = 572;
LABEL_70:
        HIDWORD(v110[0]) = v27;
        uint64_t v16 = 2;
        break;
      default:
LABEL_162:
        uint64_t v16 = 1;
        break;
    }
    this = (*(uint64_t (**)(CA::Render::Function *))(*(void *)a3 + 120))(a3);
    if (this < 0xD) {
      *((_DWORD *)v110 + v16++) = dword_1849AC7BC[(int)this];
    }
  }
  if ((int)v18 > 567)
  {
    if (v18 != 568)
    {
      if (v18 == 615)
      {
        if (a4) {
          double v56 = *(double *)a6 + *(double *)(v15 + 104);
        }
        else {
          double v56 = *(double *)a6;
        }
        *(double *)(v15 + 104) = v56;
        int v50 = 128;
        goto LABEL_185;
      }
LABEL_180:
      if ((*(unsigned char *)(v15 + 121) & 8) == 0)
      {
        char v73 = 1;
        goto LABEL_182;
      }
      goto LABEL_183;
    }
    long long v40 = (double *)(v15 + 88);
    switch(v16)
    {
      case 3:
        if (HIDWORD(v110[0]) == 572)
        {
          if (LODWORD(v110[1]) == 611)
          {
            if ((a4 & 1) == 0)
            {
              double v103 = *(double *)a6;
              goto LABEL_238;
            }
            double v101 = *(double *)(v15 + 96);
            double v102 = *(double *)a6;
            goto LABEL_220;
          }
          if (LODWORD(v110[1]) != 607) {
            goto LABEL_180;
          }
          if (a4) {
            double v98 = *(double *)a6 + *v40;
          }
          else {
            double v98 = *(double *)a6;
          }
          *long long v40 = v98;
LABEL_239:
          int v50 = 64;
          goto LABEL_185;
        }
        if (HIDWORD(v110[0]) == 486)
        {
          if (LODWORD(v110[1]) == 611)
          {
            double v104 = *a7;
            double v105 = *(double *)a6;
            double v106 = *(double *)(v15 + 80);
            double v107 = *(double *)(v15 + 64);
            double v108 = 1.0;
            if (a4) {
              double v108 = *(double *)(v15 + 80);
            }
            *(double *)(v15 + 80) = v108 * v104;
            double v109 = v106 * v105 + v107 * v104;
            if (!a4) {
              double v109 = v105;
            }
            *(double *)(v15 + 64) = v109;
            int v50 = 32;
            goto LABEL_185;
          }
          if (LODWORD(v110[1]) != 610)
          {
            if (LODWORD(v110[1]) == 607)
            {
              double v78 = *a7;
              double v79 = *(double *)a6;
              double v80 = *(double *)(v15 + 72);
              double v81 = *(double *)(v15 + 56);
              double v82 = 1.0;
              if (a4) {
                double v82 = *(double *)(v15 + 72);
              }
              *(double *)(v15 + 72) = v82 * v78;
              double v83 = v80 * v79 + v81 * v78;
              if (!a4) {
                double v83 = v79;
              }
              *(double *)(v15 + 56) = v83;
              int v50 = 16;
              goto LABEL_185;
            }
            goto LABEL_180;
          }
LABEL_149:
          double v84 = *(double *)a6;
          double v85 = *(double *)(v15 + 72);
          double v86 = *(double *)(v15 + 80);
          double v87 = *(double *)(v15 + 64);
          double v88 = v85 * *(double *)a6 + *(double *)(v15 + 56) * *a7;
          if (!a4) {
            double v85 = 1.0;
          }
          *(double *)(v15 + 72) = v85 * *a7;
          if (a4) {
            double v89 = v88;
          }
          else {
            double v89 = v84;
          }
          *(double *)(v15 + 56) = v89;
          double v90 = *a7;
          double v91 = *(double *)a6;
          if (a4) {
            double v92 = v86;
          }
          else {
            double v92 = 1.0;
          }
          *(double *)(v15 + 80) = v92 * v90;
          double v93 = v86 * v91 + v87 * v90;
          if (!a4) {
            double v93 = v91;
          }
          *(double *)(v15 + 64) = v93;
          int v50 = 48;
          goto LABEL_185;
        }
        int v50 = 0;
        if (*(void *)((char *)v110 + 4) != 0x265000001E1) {
          goto LABEL_185;
        }
        break;
      case 2:
        if (HIDWORD(v110[0]) != 481)
        {
          if (HIDWORD(v110[0]) != 572)
          {
            if (HIDWORD(v110[0]) != 486) {
              goto LABEL_160;
            }
            goto LABEL_149;
          }
          if (a4)
          {
            *long long v40 = *(double *)a6 + *v40;
            if (a5 > 1)
            {
              double v101 = *(double *)(v15 + 96);
              double v102 = *((double *)a6 + 1);
LABEL_220:
              double v103 = v102 + v101;
              goto LABEL_238;
            }
          }
          else
          {
            *long long v40 = *(double *)a6;
            if (a5 >= 2)
            {
              double v103 = *((double *)a6 + 1);
LABEL_238:
              *(double *)(v15 + 96) = v103;
              goto LABEL_239;
            }
          }
          goto LABEL_239;
        }
        break;
      case 1:
        if ((v9 & 1) == 0)
        {
          if (!v20)
          {
            if (a5 != 6) {
              goto LABEL_160;
            }
            if (*((double *)a6 + 1) == 0.0 && *((double *)a6 + 2) == 0.0)
            {
              double v61 = *(double *)a6;
              if (*(double *)a6 == 0.0 && *((double *)a6 + 3) == 0.0)
              {
                int v50 = 0;
              }
              else
              {
                double v62 = *(double *)(v15 + 72);
                double v63 = *(double *)(v15 + 80);
                double v64 = *(double *)(v15 + 64);
                double v65 = v62 * v61 + *(double *)(v15 + 56) * *a7;
                if (!a4) {
                  double v62 = 1.0;
                }
                *(double *)(v15 + 72) = v62 * *a7;
                if (a4) {
                  double v61 = v65;
                }
                *(double *)(v15 + 56) = v61;
                double v66 = a7[3];
                double v67 = *((double *)a6 + 3);
                if (a4) {
                  double v68 = v63;
                }
                else {
                  double v68 = 1.0;
                }
                *(double *)(v15 + 80) = v68 * v66;
                double v69 = v63 * v67 + v64 * v66;
                if (!a4) {
                  double v69 = v67;
                }
                *(double *)(v15 + 64) = v69;
                int v50 = 48;
              }
              double v70 = *((double *)a6 + 4);
              if (v70 != 0.0 || *((double *)a6 + 5) != 0.0)
              {
                if (a4)
                {
                  double v71 = *(double *)(v15 + 96);
                  *(double *)(v15 + 88) = *(double *)(v15 + 88) + v70;
                  double v72 = *((double *)a6 + 5) + v71;
                }
                else
                {
                  *long long v40 = v70;
                  double v72 = *((double *)a6 + 5);
                }
                *(double *)(v15 + 96) = v72;
                v50 |= 0x40u;
              }
              goto LABEL_185;
            }
            goto LABEL_116;
          }
LABEL_50:
          this = CA::Mat4Impl::mat4_is_velocity_affine_with_z_transform(a6, (const double *)a2);
          if (this && *((double *)a6 + 1) == 0.0 && *((double *)a6 + 4) == 0.0)
          {
            double v41 = *(double *)a6;
            if (*(double *)a6 == 0.0 && *((double *)a6 + 5) == 0.0)
            {
              int v50 = 0;
            }
            else
            {
              double v42 = *(double *)(v15 + 72);
              double v43 = *(double *)(v15 + 80);
              double v44 = *(double *)(v15 + 64);
              double v45 = v42 * v41 + *(double *)(v15 + 56) * *a7;
              if (!a4) {
                double v42 = 1.0;
              }
              *(double *)(v15 + 72) = v42 * *a7;
              if (a4) {
                double v41 = v45;
              }
              *(double *)(v15 + 56) = v41;
              double v46 = a7[5];
              double v47 = *((double *)a6 + 5);
              if (a4) {
                double v48 = v43;
              }
              else {
                double v48 = 1.0;
              }
              *(double *)(v15 + 80) = v48 * v46;
              double v49 = v43 * v47 + v44 * v46;
              if (!a4) {
                double v49 = v47;
              }
              *(double *)(v15 + 64) = v49;
              int v50 = 48;
            }
            double v51 = *((double *)a6 + 12);
            if (v51 != 0.0 || *((double *)a6 + 13) != 0.0)
            {
              if (a4)
              {
                double v52 = *(double *)(v15 + 96);
                *(double *)(v15 + 88) = *(double *)(v15 + 88) + v51;
                double v53 = *((double *)a6 + 13) + v52;
              }
              else
              {
                *long long v40 = v51;
                double v53 = *((double *)a6 + 13);
              }
              *(double *)(v15 + 96) = v53;
              v50 |= 0x40u;
            }
            if (*((double *)a6 + 10) == 0.0 && *((double *)a6 + 14) == 0.0) {
              goto LABEL_185;
            }
            int v99 = *(_DWORD *)(v15 + 120) | 0x400;
            goto LABEL_184;
          }
LABEL_116:
          if ((*(unsigned char *)(v15 + 121) & 8) == 0)
          {
            char v73 = 3;
LABEL_182:
            *(unsigned char *)(v15 + 124) = v73;
          }
LABEL_183:
          int v50 = 0;
          int v99 = 2048;
LABEL_184:
          *(_DWORD *)(v15 + 120) = v99;
          goto LABEL_185;
        }
        goto LABEL_35;
      default:
        goto LABEL_160;
    }
    if (a4) {
      double v100 = *(double *)a6 + *(double *)(v15 + 112);
    }
    else {
      double v100 = *(double *)a6;
    }
    *(double *)(v15 + 112) = v100;
    int v50 = 256;
    goto LABEL_185;
  }
  if (v18 == 74)
  {
    if (v16 == 3)
    {
      if (HIDWORD(v110[0]) != 513)
      {
        if (HIDWORD(v110[0]) != 416) {
          goto LABEL_160;
        }
        if (LODWORD(v110[1]) != 611)
        {
          if (LODWORD(v110[1]) == 607)
          {
            if (a4) {
              double v75 = *(double *)a6 + *(double *)(v15 + 24);
            }
            else {
              double v75 = *(double *)a6;
            }
            *(double *)(v15 + 24) = v75;
          }
          goto LABEL_201;
        }
        if (a4) {
          double v77 = *(double *)a6 + *(double *)(v15 + 32);
        }
        else {
          double v77 = *(double *)a6;
        }
LABEL_200:
        *(double *)(v15 + 32) = v77;
LABEL_201:
        int v50 = 4;
        goto LABEL_185;
      }
      if (LODWORD(v110[1]) != 256)
      {
        if (LODWORD(v110[1]) == 604)
        {
          if (a4) {
            double v97 = *(double *)a6 + *(double *)(v15 + 40);
          }
          else {
            double v97 = *(double *)a6;
          }
          *(double *)(v15 + 40) = v97;
        }
        goto LABEL_236;
      }
      if (a4) {
        double v95 = *(double *)a6 + *(double *)(v15 + 48);
      }
      else {
        double v95 = *(double *)a6;
      }
    }
    else
    {
      if (v16 != 2)
      {
        if (v16 == 1 && a5 >= 4)
        {
          if (a4)
          {
            double v57 = *(double *)(v15 + 32);
            *(double *)(v15 + 24) = *(double *)a6 + *(double *)(v15 + 24);
            *(double *)(v15 + 32) = *((double *)a6 + 1) + v57;
            double v58 = *(double *)(v15 + 48);
            *(double *)(v15 + 40) = *((double *)a6 + 2) + *(double *)(v15 + 40) - *(double *)a6;
            double v59 = *((double *)a6 + 1);
            double v60 = *((double *)a6 + 3) + v58;
          }
          else
          {
            *(void *)(v15 + 24) = *(void *)a6;
            *(void *)(v15 + 32) = *((void *)a6 + 1);
            *(double *)(v15 + 40) = *((double *)a6 + 2) - *(double *)a6;
            double v60 = *((double *)a6 + 3);
            double v59 = *((double *)a6 + 1);
          }
          *(double *)(v15 + 48) = v60 - v59;
          int v50 = 12;
          goto LABEL_185;
        }
        goto LABEL_160;
      }
      if (a5 >= 2 && HIDWORD(v110[0]) == 416)
      {
        if (a4)
        {
          double v76 = *(double *)(v15 + 32);
          *(double *)(v15 + 24) = *(double *)a6 + *(double *)(v15 + 24);
          double v77 = *((double *)a6 + 1) + v76;
        }
        else
        {
          *(void *)(v15 + 24) = *(void *)a6;
          double v77 = *((double *)a6 + 1);
        }
        goto LABEL_200;
      }
      int v50 = 0;
      if (a5 < 2 || HIDWORD(v110[0]) != 513) {
        goto LABEL_185;
      }
      if (a4)
      {
        double v94 = *(double *)(v15 + 48);
        *(double *)(v15 + 40) = *(double *)a6 + *(double *)(v15 + 40);
        double v95 = *((double *)a6 + 1) + v94;
      }
      else
      {
        *(void *)(v15 + 40) = *(void *)a6;
        double v95 = *((double *)a6 + 1);
      }
    }
    *(double *)(v15 + 48) = v95;
LABEL_236:
    int v50 = 8;
    goto LABEL_185;
  }
  if (v18 != 438) {
    goto LABEL_180;
  }
  if (v16 == 2)
  {
    if (HIDWORD(v110[0]) == 611)
    {
      if (a4) {
        double v96 = *(double *)a6 + *(double *)(v15 + 16);
      }
      else {
        double v96 = *(double *)a6;
      }
      *(double *)(v15 + 16) = v96;
      int v50 = 2;
      goto LABEL_185;
    }
    if (HIDWORD(v110[0]) == 607)
    {
      if (a4) {
        double v74 = *(double *)a6 + *(double *)(v15 + 8);
      }
      else {
        double v74 = *(double *)a6;
      }
      *(double *)(v15 + 8) = v74;
      int v50 = 1;
      goto LABEL_185;
    }
  }
  else if (v16 == 1 && a5 >= 2)
  {
    if (a4)
    {
      double v54 = *(double *)(v15 + 16);
      *(double *)(v15 + 8) = *(double *)a6 + *(double *)(v15 + 8);
      *(double *)(v15 + 16) = *((double *)a6 + 1) + v54;
      if (a5 > 2)
      {
        double v55 = *((double *)a6 + 2) + *(double *)(v15 + 104);
LABEL_171:
        *(double *)(v15 + 104) = v55;
        int v50 = 131;
        goto LABEL_185;
      }
    }
    else
    {
      *(void *)(v15 + 8) = *(void *)a6;
      *(void *)(v15 + 16) = *((void *)a6 + 1);
      if (a5 >= 3)
      {
        double v55 = *((double *)a6 + 2);
        goto LABEL_171;
      }
    }
    int v50 = 3;
    goto LABEL_185;
  }
LABEL_160:
  int v50 = 0;
LABEL_185:
  int v17 = *(_DWORD *)(v15 + 120) | v50;
LABEL_186:
  *(_DWORD *)(v15 + 120) = v17;
  return this;
}

double CA::Render::BasicAnimation0::interpolate_vector(CA::Render::BasicAnimation0 *this, uint64_t a2, float64x2_t *a3, double *a4, double *a5, double *a6, double *a7, const CA::Render::ValueInterpolator *a8)
{
  unint64_t v8 = a5;
  char v9 = a3;
  uint64_t v10 = a2;
  if (a2 != 2)
  {
LABEL_5:
    CA::Render::PropertyAnimation::interpolate_vector(this, a2, a3->f64, a4, a5, a6, a7, a8);
    if ((*((unsigned char *)this + 15) & 1) != 0 && v10)
    {
      do
      {
        double v15 = *v8++;
        double result = round(v9->f64[0] - v15) + v15;
        v9->f64[0] = result;
        char v9 = (float64x2_t *)((char *)v9 + 8);
        --v10;
      }
      while (v10);
    }
    return result;
  }
  double v12 = *((double *)this + 17);
  double v13 = *((double *)this + 18);
  if (v12 == 0.0 && v13 == 0.0)
  {
    a2 = 2;
    goto LABEL_5;
  }
  double v16 = *(double *)a8;
  float64x2_t v17 = *(float64x2_t *)a5;
  float64x2_t v18 = *(float64x2_t *)a6;

  *(void *)&double result = *(_OWORD *)&CA::Render::point_interpolate(a3, (double *)2, a3->f64, a4, v17, v18, v16, v12, v13);
  return result;
}

double *CA::Render::PropertyAnimation::interpolate_vector(CA::Render::PropertyAnimation *this, uint64_t a2, double *a3, double *a4, double *a5, double *a6, double *a7, const CA::Render::ValueInterpolator *a8)
{
  if (*((unsigned char *)a8 + 112)) {
    BOOL v8 = ((unint64_t)a4 | (unint64_t)a7) == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (!v8) {
    return CA::Render::ValueInterpolator::mix_n<double>((double *)a8, a2, a3, a4, a5, a6, a7);
  }
  for (; a2; --a2)
  {
    double v9 = *a5++;
    double v10 = v9;
    double v11 = *a6++;
    *a3++ = v10 + *(double *)a8 * (v11 - v10);
  }
  return result;
}

uint64_t CA::Render::PropertyAnimation::apply_velocity_state(CA::Render::Animation *a1, uint64_t a2)
{
  char v4 = *(unsigned char *)(a2 + 192);
  BOOL v5 = CA::Render::Animation::affects_velocity(a1);
  BOOL v8 = v5;
  if ((v4 & 1) == 0)
  {
    uint64_t v9 = 0;
    goto LABEL_12;
  }
  uint64_t v9 = a2 + 48;
  unint64_t v10 = *((void *)a1 + 12);
  if (v10)
  {
    if (v10)
    {
      v10 >>= 1;
    }
    else
    {
      if (!*(_DWORD *)v10) {
        goto LABEL_12;
      }
      LODWORD(v10) = *(_DWORD *)(v10 + 4);
    }
    if (v10 == 568)
    {
      if (v5) {
        CA::Render::VelocityState::init_scale(a2 + 48, *(void *)(a2 + 40), v6, v7);
      }
      else {
        *(_DWORD *)(a2 + 168) |= 0x200u;
      }
    }
  }
LABEL_12:
  if (v8) {
    return v9;
  }
  else {
    return 0;
  }
}

double CA::Render::TimingFunction::evaluate(CA::Render::TimingFunction *this, const double *a2, double a3, double a4)
{
  double v4 = *(double *)this * 3.0;
  double v5 = (*((double *)this + 2) - *(double *)this) * 3.0;
  double v6 = v5 - v4;
  double v7 = 1.0 - v5;
  int v8 = 8;
  double v9 = a3;
  while (1)
  {
    double v10 = -(a3 - (v4 + (v6 + v9 * v7) * v9) * v9);
    if (fabs(v10) < a4) {
      break;
    }
    double v11 = v4 + (v6 + v6 + v7 * 3.0 * v9) * v9;
    if (fabs(v11) >= 0.000001)
    {
      double v9 = v9 - v10 / v11;
      if (--v8) {
        continue;
      }
    }
    double v9 = 0.0;
    if (a3 >= 0.0)
    {
      double v9 = 1.0;
      if (a3 <= 1.0)
      {
        double v12 = 0.0;
        double v13 = 1.0;
        int v14 = -1025;
        double v9 = a3;
        do
        {
          if (__CFADD__(v14++, 1)) {
            break;
          }
          double v16 = -(a3 - (v4 + (v6 + v9 * v7) * v9) * v9);
          if (fabs(v16) < a4) {
            break;
          }
          if (v16 >= 0.0) {
            double v13 = v9;
          }
          else {
            double v12 = v9;
          }
          double v9 = v12 + (v13 - v12) * 0.5;
        }
        while (v12 < v13);
      }
    }
    return (*((double *)this + 1) * 3.0
          + ((*((double *)this + 3) - *((double *)this + 1)) * 3.0
           - *((double *)this + 1) * 3.0
           + v9 * (1.0 - (*((double *)this + 3) - *((double *)this + 1)) * 3.0))
          * v9)
         * v9;
  }
  return (*((double *)this + 1) * 3.0
        + ((*((double *)this + 3) - *((double *)this + 1)) * 3.0
         - *((double *)this + 1) * 3.0
         + v9 * (1.0 - (*((double *)this + 3) - *((double *)this + 1)) * 3.0))
        * v9)
       * v9;
}

uint64_t CA::Render::Layer::get_keypath_value(CA::Render::Layer *this, unint64_t *size, unint64_t a3, float64x2_t *a4, float64x2_t **a5)
{
  v21[1] = *MEMORY[0x1E4F143B8];
  unint64_t v5 = *size;
  if (!*size) {
    return 0;
  }
  if (v5)
  {
    unint64_t v10 = 1;
LABEL_6:
    MEMORY[0x1F4188790](this);
    double v13 = (_DWORD *)((char *)v21 - ((v12 + 15) & 0x7FFFFFFF0));
    bzero(v13, v12);
LABEL_7:
    if (v5)
    {
      _DWORD *v13 = v5 >> 1;
    }
    else
    {
      uint64_t v15 = *(unsigned int *)v5;
      if (v15)
      {
        unint64_t v16 = 0;
        uint64_t v17 = 4 * v15;
        do
        {
          v13[v16 / 4] = *(_DWORD *)(v5 + 4 + v16);
          v16 += 4;
        }
        while (v17 != v16);
      }
    }
    goto LABEL_13;
  }
  unint64_t v10 = *(unsigned int *)v5;
  if (v10 - 0x10000 < 0xFFFFFFFFFFFF0001) {
    return 0;
  }
  if (v10 <= 0x400) {
    goto LABEL_6;
  }
  BOOL v20 = malloc_type_malloc(4 * v10, 0x100004052888210uLL);
  if (!v20) {
    return 0;
  }
  double v13 = v20;
  unint64_t v5 = *size;
  if (*size) {
    goto LABEL_7;
  }
LABEL_13:
  uint64_t property_value = CA::Render::Layer::get_property_value(this, v13, v10, a3, a4, a5, v14);
  if (v10 >= 0x401) {
    free(v13);
  }
  return property_value;
}

uint64_t CA::Render::Layer::get_property_value(CA::Render::Layer *this, const unsigned int *a2, uint64_t a3, unint64_t a4, float64x2_t *a5, float64x2_t **a6, float a7)
{
  uint64_t v131 = *MEMORY[0x1E4F143B8];
  double v11 = (unsigned int *)(a2 + 1);
  if (a6) {
    goto LABEL_14;
  }
  while (1)
  {
    unint64_t v16 = (int *)(v11 - 1);
    if (!a3) {
      goto LABEL_166;
    }
    unint64_t v17 = a3 - 1;
    if (a3 == 1)
    {
      int v31 = *v16;
      if (*v16 <= 334)
      {
        if (v31 <= 120)
        {
          if (v31 > 53)
          {
            switch(v31)
            {
              case 'B':
                double v64 = (float32x2_t *)*((void *)this + 16);
                if (!v64) {
                  goto LABEL_244;
                }
                float32x2_t v55 = v64[30];
                float32x2_t v56 = v64[31];
                goto LABEL_146;
              case 'C':
                uint64_t v120 = *((void *)this + 16);
                if (!v120) {
                  goto LABEL_263;
                }
                float v76 = *(float *)(v120 + 232);
                goto LABEL_279;
              case 'D':
              case 'F':
              case 'G':
              case 'H':
              case 'I':
                goto LABEL_166;
              case 'E':
                uint64_t v121 = *((void *)this + 16);
                if (!v121) {
                  goto LABEL_263;
                }
                float v76 = *(float *)(v121 + 236);
                goto LABEL_279;
              case 'J':
                _Q0 = *((float64x2_t *)this + 4);
                _Q1 = *((float64x2_t *)this + 5);
LABEL_265:
                float64x2_t v84 = vaddq_f64(_Q0, _Q1);
LABEL_266:
                *a5 = _Q0;
                a5[1] = v84;
                return 4;
              default:
                if (v31 == 54)
                {
                  *a5 = vcvtq_f64_f32(*(float32x2_t *)((char *)this + 16));
                  float64x2_t v66 = vcvtq_f64_f32(*(float32x2_t *)((char *)this + 24));
                  goto LABEL_268;
                }
                if (v31 != 55) {
                  goto LABEL_166;
                }
                uint64_t v74 = *((void *)this + 16);
                if (v74) {
                  float64x2_t v69 = *(float64x2_t *)(v74 + 152);
                }
                else {
                  float64x2_t v69 = 0uLL;
                }
                break;
            }
            goto LABEL_284;
          }
          if (v31 == 13)
          {
            double v70 = 0.0;
            if ((*((void *)this + 5) & 0x4000000) != 0) {
              double v70 = 1.0;
            }
            a5->f64[0] = v70;
            goto LABEL_166;
          }
          if (v31 == 27)
          {
            uint64_t v73 = *((void *)this + 16);
            if (v73)
            {
              float64x2_t v69 = *(float64x2_t *)(v73 + 168);
            }
            else
            {
              double v122 = 0.0;
              if ((*((unsigned char *)this + 45) & 0x40) == 0) {
                double v122 = 0.5;
              }
              float64x2_t v69 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v122, 0);
            }
            goto LABEL_284;
          }
          if (v31 != 28) {
            goto LABEL_166;
          }
          uint64_t v59 = *((void *)this + 16);
          if (v59)
          {
            double v41 = *(double *)(v59 + 184);
            goto LABEL_280;
          }
        }
        else
        {
          if (v31 <= 182)
          {
            switch(v31)
            {
              case 121:
                uint64_t v32 = *((void *)this + 16);
                __asm { FMOV            V1.2D, #1.0 }
                _Q0 = 0uLL;
                if (!v32) {
                  goto LABEL_265;
                }
                uint64_t v38 = *(void *)(v32 + 48);
                if (!v38) {
                  goto LABEL_265;
                }
                goto LABEL_202;
              case 125:
                uint64_t v79 = *((void *)this + 16);
                if (!v79) {
                  goto LABEL_254;
                }
                float v76 = *(float *)(v79 + 256);
                goto LABEL_279;
              case 131:
                unsigned int v80 = (unsigned __int16)*((_DWORD *)this + 9) >> 12;
                goto LABEL_207;
              case 132:
                uint64_t v81 = *((void *)this + 16);
                if (!v81) {
                  goto LABEL_263;
                }
                float v76 = *(float *)(v81 + 260);
                goto LABEL_279;
              case 133:
                uint64_t v82 = *((void *)this + 16);
                if (v82)
                {
                  double v83 = (float32x2_t *)(v82 + 268);
                  _Q0 = vcvtq_f64_f32(*v83);
                  float64x2_t v84 = vcvtq_f64_f32(v83[1]);
                }
                else
                {
                  __asm { FMOV            V0.2D, #1.0 }
                  float64x2_t v84 = _Q0;
                }
                goto LABEL_266;
              case 135:
                uint64_t v85 = *((void *)this + 16);
                __asm { FMOV            V1.2D, #1.0 }
                _Q0 = 0uLL;
                if (!v85) {
                  goto LABEL_265;
                }
                uint64_t v38 = *(void *)(v85 + 40);
                if (!v38) {
                  goto LABEL_265;
                }
LABEL_202:
                unsigned int v86 = *(_DWORD *)(v38 + 16);
                _Q1 = 0uLL;
                goto LABEL_220;
              case 136:
                uint64_t v87 = *((void *)this + 16);
                if (v87)
                {
                  float v76 = *(float *)(v87 + 284);
                }
                else
                {
                  LOBYTE(a7) = *((unsigned char *)this + 34);
                  float v76 = (float)LODWORD(a7);
                }
                goto LABEL_279;
              case 138:
                uint64_t v88 = *((void *)this + 16);
                if (!v88) {
                  goto LABEL_263;
                }
                unsigned int v80 = *(unsigned char *)(v88 + 324) & 1;
LABEL_207:
                double v41 = (double)v80;
                goto LABEL_280;
              case 139:
                if (a4 < 6) {
                  return 0;
                }
                uint64_t v89 = *((void *)this + 16);
                double v90 = (float64x2_t *)MEMORY[0x1E4F1DAB8];
                double v91 = (float64x2_t *)(MEMORY[0x1E4F1DAB8] + 16);
                double v92 = (float64x2_t *)(MEMORY[0x1E4F1DAB8] + 32);
                if (v89)
                {
                  uint64_t v93 = *(void *)(v89 + 32);
                  if (v93)
                  {
                    double v91 = (float64x2_t *)(MEMORY[0x1E4F1DAB8] + 16);
                    double v92 = (float64x2_t *)(v93 + 56);
                    if (*(_DWORD *)(v93 + 16) >= 6u) {
                      double v91 = (float64x2_t *)(v93 + 40);
                    }
                    else {
                      double v92 = (float64x2_t *)(MEMORY[0x1E4F1DAB8] + 32);
                    }
                    if (*(_DWORD *)(v93 + 16) >= 6u) {
                      double v90 = (float64x2_t *)(v93 + 24);
                    }
                  }
                }
                float64x2_t v94 = *v91;
                float64x2_t v95 = *v92;
                *a5 = *v90;
                a5[1] = v94;
                a5[2] = v95;
                return 6;
              case 144:
                uint64_t v96 = *((void *)this + 16);
                _Q1 = 0uLL;
                __asm { FMOV            V0.2D, #0.5 }
                if (!v96) {
                  goto LABEL_265;
                }
                uint64_t v38 = *(void *)(v96 + 64);
                if (!v38) {
                  goto LABEL_265;
                }
                unsigned int v86 = *(_DWORD *)(v38 + 16);
                _Q0 = 0uLL;
LABEL_220:
                if (v86 >= 4)
                {
                  _Q0 = *(float64x2_t *)(v38 + 24);
                  _Q1 = vsubq_f64(*(float64x2_t *)(v38 + 40), _Q0);
                }
                goto LABEL_265;
              case 147:
                uint64_t v97 = *((void *)this + 16);
                if (!v97) {
                  return 0;
                }
                uint64_t result = 0;
                if (a4 < 8) {
                  return result;
                }
                uint64_t v98 = *(void *)(v97 + 72);
                if (!v98) {
                  return result;
                }
                if (*(_DWORD *)(v98 + 16) != 8) {
                  return 0;
                }
                float64x2_t v99 = *(float64x2_t *)(v98 + 24);
                float64x2_t v100 = *(float64x2_t *)(v98 + 40);
                float64x2_t v101 = *(float64x2_t *)(v98 + 72);
                a5[2] = *(float64x2_t *)(v98 + 56);
                a5[3] = v101;
                *a5 = v99;
                a5[1] = v100;
                uint64_t result = 8;
                break;
              case 148:
                uint64_t v102 = *((void *)this + 16);
                float v76 = 0.0;
                if (v102) {
                  float v76 = *(float *)(v102 + 228);
                }
                goto LABEL_279;
              default:
                goto LABEL_166;
            }
            return result;
          }
          if (v31 > 245)
          {
            if (v31 != 246)
            {
              if (v31 == 257)
              {
                _ZF = (*((void *)this + 5) & 0x100) == 0;
              }
              else
              {
                if (v31 != 334) {
                  goto LABEL_166;
                }
                _ZF = (*((void *)this + 5) & 0x80) == 0;
              }
LABEL_249:
              double v41 = 0.0;
              if (!_ZF) {
                double v41 = 1.0;
              }
              goto LABEL_280;
            }
            uint64_t v103 = *((void *)this + 16);
            if (!v103)
            {
LABEL_254:
              double v41 = 1.0;
              goto LABEL_280;
            }
            float v76 = *(float *)(v103 + 296);
LABEL_279:
            double v41 = v76;
            goto LABEL_280;
          }
          if (v31 != 183)
          {
            if (v31 != 186) {
              goto LABEL_166;
            }
            _ZF = (*((void *)this + 5) & 0x400) == 0;
            goto LABEL_249;
          }
          uint64_t v111 = *((void *)this + 16);
          if (v111)
          {
            float v76 = *(float *)(v111 + 264);
            goto LABEL_279;
          }
        }
        goto LABEL_263;
      }
      if (v31 <= 500)
      {
        if (v31 > 443)
        {
          switch(v31)
          {
            case 477:
              double v54 = (float32x2_t *)*((void *)this + 16);
              if (!v54) {
                goto LABEL_244;
              }
              float32x2_t v55 = v54[38];
              float32x2_t v56 = v54[39];
              goto LABEL_146;
            case 478:
              uint64_t v112 = *((void *)this + 16);
              if (!v112) {
                goto LABEL_263;
              }
              float v76 = *(float *)(v112 + 320);
              goto LABEL_279;
            case 479:
              _ZF = (*((void *)this + 5) & 0x1000000000) == 0;
              goto LABEL_249;
            case 480:
              uint64_t v113 = *((void *)this + 16);
              if (!v113) {
                goto LABEL_263;
              }
              float v76 = *(float *)(v113 + 300);
              goto LABEL_279;
            default:
              if (v31 != 444) {
                goto LABEL_166;
              }
              _ZF = (*((void *)this + 5) & 0x800000) == 0;
              goto LABEL_249;
          }
        }
        if (v31 <= 389)
        {
          if (v31 == 335)
          {
            _ZF = (*((void *)this + 5) & 0x200000000) == 0;
          }
          else
          {
            if (v31 != 378) {
              goto LABEL_166;
            }
            _ZF = (*((void *)this + 5) & 0x40) == 0;
          }
          goto LABEL_249;
        }
        if (v31 != 390)
        {
          if (v31 != 409)
          {
            if (v31 == 438)
            {
              a5->f64[0] = *((float64_t *)this + 6);
              a5->f64[1] = *((float64_t *)this + 7);
              uint64_t v61 = *((void *)this + 16);
              if (v61) {
                float64_t v62 = *(double *)(v61 + 192);
              }
              else {
                float64_t v62 = 0.0;
              }
              a5[1].f64[0] = v62;
              return 3;
            }
            goto LABEL_166;
          }
          LOBYTE(a7) = *((unsigned char *)this + 32);
LABEL_186:
          float v76 = (float)LODWORD(a7) * 0.0039216;
          goto LABEL_279;
        }
        uint64_t v75 = *((void *)this + 16);
        if (v75)
        {
          float v76 = *(float *)(v75 + 292);
          goto LABEL_279;
        }
LABEL_263:
        double v41 = 0.0;
        goto LABEL_280;
      }
      if (v31 <= 545)
      {
        switch(v31)
        {
          case 501:
            double v58 = (float32x2_t *)*((void *)this + 16);
            if (v58)
            {
              float32x2_t v55 = v58[25];
              float32x2_t v56 = v58[26];
LABEL_146:
              float64x2_t v65 = vcvtq_f64_f32(v55);
              float64x2_t v66 = vcvtq_f64_f32(v56);
            }
            else
            {
LABEL_244:
              float64x2_t v66 = (float64x2_t)xmmword_184997D60;
              float64x2_t v65 = 0uLL;
            }
            *a5 = v65;
LABEL_268:
            a5[1] = v66;
            return 4;
          case 502:
            double v77 = (float32x2_t *)*((void *)this + 16);
            if (v77) {
              float64x2_t v69 = vcvtq_f64_f32(v77[27]);
            }
            else {
              float64x2_t v69 = (float64x2_t)xmmword_184997EE0;
            }
            goto LABEL_284;
          case 503:
            LOBYTE(a7) = *((unsigned char *)this + 33);
            goto LABEL_186;
          case 505:
            _ZF = (*((void *)this + 5) & 0x400000000) == 0;
            goto LABEL_249;
          case 506:
            uint64_t v78 = *((void *)this + 16);
            if (v78)
            {
              float v76 = *(float *)(v78 + 224);
              goto LABEL_279;
            }
            double v41 = 3.0;
            break;
          case 508:
            _ZF = (*((void *)this + 5) & 0x40000) == 0;
            goto LABEL_249;
          case 509:
            _ZF = (*((void *)this + 5) & 0x80000) == 0;
            goto LABEL_249;
          case 510:
            _ZF = (*((void *)this + 5) & 0x100000) == 0;
            goto LABEL_249;
          default:
            goto LABEL_166;
        }
        goto LABEL_280;
      }
      switch(v31)
      {
        case 546:
          uint64_t v104 = *((void *)this + 16);
          if (v104)
          {
            double v105 = (uint64_t *)(v104 + 24);
LABEL_236:
            uint64_t v107 = *v105;
            double v108 = &CA::Mat4Impl::mat4_identity_double;
            if (v107)
            {
              unsigned int v109 = *(_DWORD *)(v107 + 16);
              double v110 = (long long *)(v107 + 24);
              if (v109 > 0xF) {
                double v108 = v110;
              }
            }
LABEL_256:
            if (a4 >= 0x10)
            {
              long long v114 = v108[1];
              long long v115 = v108[2];
              long long v116 = v108[3];
              *a5 = (float64x2_t)*v108;
              a5[1] = (float64x2_t)v114;
              a5[2] = (float64x2_t)v115;
              a5[3] = (float64x2_t)v116;
              long long v117 = v108[5];
              long long v118 = v108[6];
              long long v119 = v108[7];
              a5[4] = (float64x2_t)v108[4];
              a5[5] = (float64x2_t)v117;
              a5[6] = (float64x2_t)v118;
              a5[7] = (float64x2_t)v119;
              return 16;
            }
            return 0;
          }
          break;
        case 568:
          uint64_t v106 = *((void *)this + 16);
          if (v106)
          {
            double v105 = (uint64_t *)(v106 + 16);
            goto LABEL_236;
          }
          break;
        case 615:
          uint64_t v68 = *((void *)this + 16);
          if (v68)
          {
            double v41 = *(double *)(v68 + 192);
            goto LABEL_280;
          }
          goto LABEL_263;
        default:
          goto LABEL_166;
      }
      double v108 = &CA::Mat4Impl::mat4_identity_double;
      goto LABEL_256;
    }
    int v18 = *v16;
    if (*v16 != 547) {
      break;
    }
    size_t v12 = (CA::Render::Layer *)*((void *)this + 13);
    if ((*((unsigned char *)this + 13) & 0x20) != 0)
    {
      if (!v12) {
        return 0;
      }
      unsigned int v14 = *v11;
      if ((*v11 & 0x40000000) != 0)
      {
        if ((v14 & 0xBFFFFFFF) != 0) {
          return 0;
        }
      }
      else
      {
        uint64_t result = *((void *)v12 + 15);
        if (!result) {
          return result;
        }
        if (!CA::Render::String::equal((CA::Render::String *)result, v14)) {
          return 0;
        }
      }
    }
    else
    {
      if (!v12) {
        return 0;
      }
      unsigned int named_object = CA::Render::TypedArray<CA::Render::Layer>::find_named_object(*((void *)this + 13), *v11);
      if ((named_object & 0x80000000) != 0) {
        return 0;
      }
      size_t v12 = (CA::Render::Layer *)*((void *)v12 + named_object + 3);
    }
    a3 -= 2;
    v11 += 2;
    this = v12;
    if (a6) {
LABEL_14:
    }
      *a6 = a5;
  }
  if (v18 > 138)
  {
    if (v18 > 437)
    {
      if (v18 <= 545)
      {
        if (v18 != 438)
        {
          if (v18 != 502) {
            goto LABEL_166;
          }
          uint64_t v20 = *((void *)this + 16);
          if (v20)
          {
            double v21 = *(float *)(v20 + 216);
            double v22 = *(float *)(v20 + 220);
          }
          else
          {
            double v22 = -3.0;
            double v21 = 0.0;
          }
          if (a3 != 2) {
            return 0;
          }
          if (*v11 != 604)
          {
            if (*v11 != 256) {
              return 0;
            }
            double v21 = v22;
          }
          a5->f64[0] = v21;
          return 1;
        }
LABEL_52:
        if (a3 != 2) {
          return 0;
        }
        if (*v11 == 607)
        {
          double v30 = (double *)((char *)this + 48);
        }
        else
        {
          if (*v11 != 611) {
            return 0;
          }
          double v30 = (double *)((char *)this + 56);
        }
        double v41 = *v30;
        goto LABEL_280;
      }
      if (v18 == 546)
      {
        uint64_t v53 = *((void *)this + 16);
        if (v53)
        {
          double v29 = *(CA::Render **)(v53 + 24);
          goto LABEL_95;
        }
      }
      else
      {
        if (v18 != 568) {
          goto LABEL_166;
        }
        uint64_t v28 = *((void *)this + 16);
        if (v28)
        {
          double v29 = *(CA::Render **)(v28 + 16);
LABEL_95:
          return CA::Render::get_transform_property(v29, (CA::Render::Vector *)(a3 - 1), (int *)v11, (unsigned int *)a5, a5->f64);
        }
      }
      double v29 = 0;
      goto LABEL_95;
    }
    if (v18 != 139)
    {
      if (v18 == 144)
      {
        uint64_t v48 = *((void *)this + 16);
        if (v48)
        {
          uint64_t v27 = *(void *)(v48 + 64);
          long long v123 = 0u;
          float64x2_t v124 = 0u;
          if (v27)
          {
LABEL_84:
            if (*(_DWORD *)(v27 + 16) >= 4u)
            {
              float64x2_t v51 = vsubq_f64(*(float64x2_t *)(v27 + 40), *(float64x2_t *)(v27 + 24));
              long long v123 = *(_OWORD *)(v27 + 24);
              float64x2_t v124 = v51;
            }
            return CA::Render::get_rect_property((CA::Render *)&v123, (const CA::Rect *)(a3 - 1), (int *)v11, (unsigned int *)a5, a5->f64);
          }
        }
        __asm { FMOV            V0.2D, #0.5 }
        long long v123 = _Q0;
        float64x2_t v124 = 0uLL;
        return CA::Render::get_rect_property((CA::Render *)&v123, (const CA::Rect *)(a3 - 1), (int *)v11, (unsigned int *)a5, a5->f64);
      }
      if (v18 != 226) {
        goto LABEL_166;
      }
      uint64_t v25 = *((void *)this + 16);
      if (v25)
      {
        uint64_t v24 = *(void *)(v25 + 96);
        goto LABEL_91;
      }
LABEL_90:
      uint64_t v24 = 0;
      goto LABEL_91;
    }
    uint64_t v43 = *((void *)this + 16);
    if (v43 && (uint64_t v44 = *(void *)(v43 + 32)) != 0 && *(_DWORD *)(v44 + 16) > 5u)
    {
      long long v60 = *(_OWORD *)(v44 + 40);
      long long v128 = *(_OWORD *)(v44 + 24);
      long long v129 = v60;
      long long v46 = *(_OWORD *)(v44 + 56);
    }
    else
    {
      long long v45 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
      long long v128 = *MEMORY[0x1E4F1DAB8];
      long long v129 = v45;
      long long v46 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 32);
    }
    long long v130 = v46;
    uint64_t v127 = 0;
    long long v125 = 0u;
    long long v126 = 0u;
    long long v123 = 0u;
    float64x2_t v124 = 0u;
    CA::Mat2Impl::mat2_get_unmatrix((uint64_t)&v128, (uint64_t)&v123);
    if (a3 != 3)
    {
      uint64_t result = 0;
      if (a3 != 2) {
        return result;
      }
      unsigned int v47 = *v11;
      if (*v11 != 572)
      {
        if (v47 == 486)
        {
          double v41 = (*((double *)&v123 + 1) + *(double *)&v123) * 0.5;
        }
        else
        {
          if (v47 != 481) {
            return 0;
          }
          double v41 = *(double *)&v125;
        }
        goto LABEL_280;
      }
      float64x2_t v69 = v124;
LABEL_284:
      *a5 = v69;
      return 2;
    }
    if (*v11 == 572)
    {
      unsigned int v67 = v11[1];
      if (v67 == 611)
      {
        double v41 = v124.f64[1];
      }
      else
      {
        if (v67 != 607) {
          return 0;
        }
        double v41 = v124.f64[0];
      }
    }
    else
    {
      if (*v11 != 486) {
        return 0;
      }
      unsigned int v57 = v11[1];
      if (v57 == 611)
      {
        double v41 = *((double *)&v123 + 1);
      }
      else
      {
        if (v57 != 607) {
          return 0;
        }
        double v41 = *(double *)&v123;
      }
    }
LABEL_280:
    a5->f64[0] = v41;
    return 1;
  }
  if (v18 <= 73)
  {
    if (v18 != 27)
    {
      if (v18 != 55)
      {
        if (v18 != 56) {
          goto LABEL_166;
        }
        uint64_t v23 = *((void *)this + 16);
        if (v23)
        {
          uint64_t v24 = *(void *)(v23 + 104);
LABEL_91:
          return CA::Render::get_list_property<CA::Render::Filter>(v24, v17, (uint64_t)v11, a4, a5->f64);
        }
        goto LABEL_90;
      }
      uint64_t v40 = *((void *)this + 16);
      if (v40)
      {
        double v41 = *(double *)(v40 + 152);
        double v42 = *(double *)(v40 + 160);
      }
      else
      {
        double v41 = 0.0;
        double v42 = 0.0;
      }
      if (a3 != 2) {
        return 0;
      }
      if (*v11 != 607)
      {
        if (*v11 != 611) {
          return 0;
        }
        double v41 = v42;
      }
      goto LABEL_280;
    }
    goto LABEL_52;
  }
  if (v18 > 120)
  {
    if (v18 == 121)
    {
      uint64_t v50 = *((void *)this + 16);
      if (v50)
      {
        uint64_t v27 = *(void *)(v50 + 48);
LABEL_83:
        long long v123 = 0u;
        float64x2_t v124 = 0u;
        if (v27) {
          goto LABEL_84;
        }
      }
    }
    else
    {
      if (v18 != 135) {
        goto LABEL_166;
      }
      uint64_t v26 = *((void *)this + 16);
      if (v26)
      {
        uint64_t v27 = *(void *)(v26 + 40);
        goto LABEL_83;
      }
    }
    long long v123 = 0uLL;
    __asm { FMOV            V0.2D, #1.0 }
    float64x2_t v124 = _Q0;
    return CA::Render::get_rect_property((CA::Render *)&v123, (const CA::Rect *)(a3 - 1), (int *)v11, (unsigned int *)a5, a5->f64);
  }
  if (v18 == 74)
  {
    double v39 = (CA::Render::Layer *)((char *)this + 64);
    return CA::Render::get_rect_property(v39, (const CA::Rect *)(a3 - 1), (int *)v11, (unsigned int *)a5, a5->f64);
  }
  else
  {
    if (v18 == 113)
    {
      uint64_t v19 = *((void *)this + 16);
      if (v19)
      {
        uint64_t result = *(void *)(v19 + 88);
        if (result)
        {
          return CA::Render::Filter::get_property((CA::Render::Filter *)result, v17, v11, a4, a5->f64);
        }
        return result;
      }
      return 0;
    }
LABEL_166:
    double v71 = (uint64_t *)*((void *)this + 16);
    if (!v71) {
      return 0;
    }
    uint64_t result = *v71;
    if (*v71)
    {
      double v72 = *(uint64_t (**)(void))(*(void *)result + 136);
      return v72();
    }
  }
  return result;
}

void CA::Render::VelocityState::init_scale(uint64_t a1, uint64_t a2, uint64_t a3, double *a4)
{
  if (*(unsigned char *)(a1 + 125))
  {
    *(unsigned char *)(a1 + 125) = 0;
    uint64_t v5 = *(void *)(a2 + 128);
    if (v5)
    {
      uint64_t v6 = *(void *)(v5 + 16);
      if (v6)
      {
        unsigned int v7 = *(_DWORD *)(v6 + 16);
        int v8 = (double *)(v6 + 24);
        if (v7 >= 0x10) {
          double v9 = v8;
        }
        else {
          double v9 = (double *)&CA::Mat4Impl::mat4_identity_double;
        }
        if (v9[2] != 0.0
          || v9[3] != 0.0
          || v9[6] != 0.0
          || v9[7] != 0.0
          || v9[8] != 0.0
          || v9[9] != 0.0
          || v9[11] != 0.0
          || v9[15] != 1.0)
        {
          if ((*(unsigned char *)(a1 + 121) & 8) == 0) {
            *(unsigned char *)(a1 + 124) = 2;
          }
          int v10 = 2048;
          goto LABEL_23;
        }
        CA::Mat4Impl::mat4_get_scale((CA::Mat4Impl *)v9, (double *)(a1 + 72), (double *)(a1 + 80), a4);
        if (fabs(v9[2]) >= 0.000001
          || fabs(v9[6]) >= 0.000001
          || fabs(v9[10] + -1.0) >= 0.000001
          || fabs(v9[14]) >= 0.000001)
        {
          int v10 = *(_DWORD *)(a1 + 120) | 0x400;
LABEL_23:
          *(_DWORD *)(a1 + 120) = v10;
        }
      }
    }
  }
}

double CA::Render::SpringAnimation::time_function(CA::Render::SpringAnimation *this, double a2)
{
  uint64_t v2 = *((void *)this + 5);
  if (v2) {
    double v3 = *(double *)(v2 + 32);
  }
  else {
    double v3 = INFINITY;
  }
  return CA::Render::SpringAnimation::State::eval((CA::Render::SpringAnimation *)((char *)this + 192), v3 * a2);
}

void CA::Render::MatchPropertyAnimation::apply(CA::Render::MatchPropertyAnimation *this, CA::Render::AnimationEvaluator *a2, double a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  unint64_t v3 = *((void *)this + 16);
  if (v3)
  {
    uint64_t v5 = (CA::Render::LayerNode *)*((void *)a2 + 4);
    if (v5)
    {
      uint64_t v7 = *((void *)a2 + 3);
      int v8 = *(void **)(v7 + 808);
      double v9 = *(void **)(v7 + 800);
      while (v8 != v9)
      {
        v8 -= 5;
        int v10 = std::__hash_table<std::__hash_value_type<CA::Render::Object *,x_link_struct>,std::__unordered_map_hasher<CA::Render::Object *,std::__hash_value_type<CA::Render::Object *,x_link_struct>,std::hash<CA::Render::Object *>,std::equal_to<CA::Render::Object *>,true>,std::__unordered_map_equal<CA::Render::Object *,std::__hash_value_type<CA::Render::Object *,x_link_struct>,std::equal_to<CA::Render::Object *>,std::hash<CA::Render::Object *>,true>,std::allocator<std::__hash_value_type<CA::Render::Object *,x_link_struct>>>::find<CA::Render::Object *>(v8, v3);
        if (v10)
        {
          double v11 = (CA::Render::LayerNode *)v10[3];
          goto LABEL_8;
        }
      }
      double v11 = 0;
LABEL_8:
      CA::Render::Update::mark_root_dependence((CA::Render::LayerNode *)(*(unsigned int *)(v7 + 1084) | ((unint64_t)*(unsigned __int16 *)(v7 + 1088) << 32)), v11, v5);
      if (v11)
      {
        double v13 = (CA::Render::Layer *)*((void *)v11 + 4);
        unsigned int v14 = (CA::Render::Layer *)*((void *)a2 + 5);
        if (CA::Render::Layer::keypath_is_object(v14, (const CA::Render::Layer **)this + 15, v12))
        {
          keypath_object = (void *const *)CA::Render::Layer::get_keypath_object(v13, (const CA::Render::Layer **)this + 15, v15);
          CA::Render::Layer::set_keypath_object(v14, (const CA::Render::Layer **)this + 15, keypath_object);
        }
        else
        {
          memset(v19, 0, sizeof(v19));
          int v18 = 0;
          uint64_t keypath_value = (CA::Render::Vector *)CA::Render::Layer::get_keypath_value(v13, (unint64_t *)this + 15, 0x18uLL, v19, (float64x2_t **)&v18);
          if (keypath_value)
          {
            CA::Render::Layer::set_keypath_value(v14, (unint64_t *)this + 15, (const unsigned int *)((*((_DWORD *)this + 3) >> 9) & 1), keypath_value, v18);
            if (v18 != (double *)v19) {
              free(v18);
            }
          }
        }
      }
    }
  }
}

uint64_t CA::Render::LayerSubclass::keypath_is_object(CA::Render::LayerSubclass *this, void *const *a2)
{
  return 0;
}

uint64_t CA::Render::get_list_property<CA::Render::Filter>(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, double *a5)
{
  if (!a1) {
    return 0;
  }
  if (a2 < 2) {
    return 0;
  }
  unsigned int named_object = CA::Render::TypedArray<CA::Render::Filter>::find_named_object(a1, *(_DWORD *)a3);
  if ((named_object & 0x80000000) != 0) {
    return 0;
  }
  double v11 = *(CA::Render::Filter **)(a1 + 8 * named_object + 24);
  if (!v11) {
    return 0;
  }

  return CA::Render::Filter::get_property(v11, a2 - 1, (const unsigned int *)(a3 + 4), a4, a5);
}

uint64_t CA::Render::Filter::get_property(CA::Render::Filter *this, uint64_t a2, const unsigned int *a3, unint64_t a4, double *a5)
{
  if (a2 != 1) {
    return 0;
  }
  if (*a3 == 212)
  {
    double v6 = 1.0;
    if ((*((_DWORD *)this + 3) & 0x100) == 0) {
      double v6 = 0.0;
    }
    *a5 = v6;
    return 1;
  }
  else
  {
    uint64_t v8 = *((void *)this + 5);
    if (v8
      && (unsigned int named_object = CA::Render::KeyValueArray::find_named_object_(*((void *)this + 5), *a3),
          (named_object & 0x80000000) == 0)
      && (uint64_t v11 = *(void *)(*(void *)(v8 + 8 * named_object + 24) + 24)) != 0
      && *(unsigned char *)(v11 + 12) == 56
      && (unint64_t v12 = *(unsigned int *)(v11 + 16), v12 <= a4))
    {
      memcpy(a5, (const void *)(v11 + 24), 8 * v12);
      return *(unsigned int *)(v11 + 16);
    }
    else
    {
      return 0;
    }
  }
}

BOOL CA::Render::ShapeLayer::keypath_is_object(CA::Render::ShapeLayer *this, void *const *a2)
{
  unint64_t v2 = (unint64_t)*a2;
  if (!*a2) {
    return 0;
  }
  if (v2)
  {
    v2 >>= 1;
    return v2 == 423 || v2 == 355;
  }
  if (*(_DWORD *)v2 != 1) {
    return 0;
  }
  LODWORD(v2) = *(_DWORD *)(v2 + 4);
  return v2 == 423 || v2 == 355;
}

uint64_t CA::Render::ShapeLayer::get_property(float32x2_t *this, unint64_t a2, const unsigned int *a3, unint64_t a4, float64x2_t *a5, float64x2_t **a6)
{
  if (a4 < 4) {
    return 0;
  }
  if (a6) {
    *a6 = a5;
  }
  uint64_t result = 0;
  int v8 = *a3;
  if (*(int *)a3 <= 391)
  {
    switch(v8)
    {
      case 222:
        float32x2_t v9 = this[3];
        float32x2_t v10 = this[4];
        goto LABEL_20;
      case 356:
        float64_t v11 = *(double *)&this[13];
        break;
      case 358:
        float64_t v11 = *(double *)&this[11];
        break;
      default:
        return result;
    }
    goto LABEL_23;
  }
  if (v8 > 542)
  {
    if (v8 == 543)
    {
      float64_t v11 = *(double *)&this[10];
    }
    else
    {
      if (v8 != 544) {
        return result;
      }
      float64_t v11 = *(double *)&this[9];
    }
LABEL_23:
    a5->f64[0] = v11;
    return 1;
  }
  if (v8 == 392)
  {
    float64_t v11 = *(double *)&this[12];
    goto LABEL_23;
  }
  if (v8 == 542)
  {
    float32x2_t v9 = this[6];
    float32x2_t v10 = this[7];
LABEL_20:
    *a5 = vcvtq_f64_f32(v9);
    a5[1] = vcvtq_f64_f32(v10);
    return 4;
  }
  return result;
}

uint64_t CA::Render::ReplicatorLayer::get_property(CA::Render::ReplicatorLayer *this, uint64_t a2, const unsigned int *a3, unint64_t a4, float64x2_t *a5, float64x2_t **a6)
{
  if (a4 >= 4)
  {
    if (a6) {
      *a6 = a5;
    }
    if (!a2) {
      return a2;
    }
    if (a2 == 1)
    {
      a2 = 0;
      switch(*a3)
      {
        case 0x143u:
          a2 = 8;
          goto LABEL_16;
        case 0x144u:
          a2 = 7;
          goto LABEL_16;
        case 0x145u:
          float64x2_t v7 = vcvtq_f64_f32(*(float32x2_t *)((char *)this + 44));
          *a5 = vcvtq_f64_f32(*(float32x2_t *)((char *)this + 36));
          a5[1] = v7;
          return 4;
        case 0x146u:
          double v8 = (double)*((int *)this + 4);
          goto LABEL_17;
        case 0x147u:
          goto LABEL_16;
        case 0x148u:
          a2 = 6;
          goto LABEL_16;
        case 0x149u:
          a2 = 5;
LABEL_16:
          double v8 = *((float *)this + a2 + 8);
LABEL_17:
          a5->f64[0] = v8;
          a2 = 1;
          break;
        case 0x14Au:
          if (a4 < 0x10) {
            return 0;
          }
          uint64_t v9 = *((void *)this + 3);
          float64x2_t v10 = *(float64x2_t *)(v9 + 40);
          float64x2_t v11 = *(float64x2_t *)(v9 + 56);
          float64x2_t v12 = *(float64x2_t *)(v9 + 72);
          *a5 = *(float64x2_t *)(v9 + 24);
          a5[1] = v10;
          a5[2] = v11;
          a5[3] = v12;
          float64x2_t v13 = *(float64x2_t *)(v9 + 104);
          float64x2_t v14 = *(float64x2_t *)(v9 + 120);
          float64x2_t v15 = *(float64x2_t *)(v9 + 136);
          a5[4] = *(float64x2_t *)(v9 + 88);
          a5[5] = v13;
          a5[6] = v14;
          a5[7] = v15;
          a2 = 16;
          break;
        default:
          return a2;
      }
      return a2;
    }
    if (*a3 == 330) {
      return CA::Render::get_transform_property(*((CA::Render **)this + 3), (CA::Render::Vector *)(a2 - 1), (int *)a3 + 1, (unsigned int *)a5, a5->f64);
    }
  }
  return 0;
}

uint64_t CA::Render::GradientLayer::get_property(CA::Render::GradientLayer *this, uint64_t a2, const unsigned int *a3, unint64_t a4, float64x2_t *a5, double **a6)
{
  if (a4 < 4) {
    return 0;
  }
  uint64_t v9 = (double *)a5;
  if (a6) {
    *a6 = (double *)a5;
  }
  unint64_t v6 = 0;
  int v12 = *a3;
  if (*(int *)a3 > 364)
  {
    if (v12 != 365)
    {
      if (v12 != 402)
      {
        if (v12 != 536) {
          return v6;
        }
LABEL_14:
        float64x2_t v13 = (double *)((char *)this + 72);
        _ZF = v12 == 536;
        uint64_t v15 = 88;
        if (_ZF) {
          uint64_t v15 = 72;
        }
        else {
          float64x2_t v13 = (double *)((char *)this + 88);
        }
        if (a2 != 2)
        {
          if (a2 == 1)
          {
            a5->f64[0] = *(float64_t *)((char *)this + v15);
            a5->f64[1] = v13[1];
            return 2;
          }
          return 0;
        }
        unsigned int v19 = a3[1];
        if (v19 == 611)
        {
          double v18 = v13[1];
        }
        else
        {
          if (v19 != 607) {
            return 0;
          }
          double v18 = *(double *)((char *)this + v15);
        }
LABEL_27:
        a5->f64[0] = v18;
        return 1;
      }
      float v17 = *((float *)this + 27);
LABEL_26:
      double v18 = v17;
      goto LABEL_27;
    }
  }
  else if (v12 != 110)
  {
    if (v12 != 215)
    {
      if (v12 != 331) {
        return v6;
      }
      unint64_t v23 = *((void *)this + 4);
      if (v23 < 2) {
        return 0;
      }
      if (a2 != 2)
      {
        if (a2 == 1)
        {
          unint64_t v24 = v23 - 1;
          if (!(v24 >> 62))
          {
            unint64_t v6 = 4 * v24;
            if (!((4 * v24) >> 61))
            {
              uint64_t v25 = (const void *)*((void *)this + 8);
              size_t v26 = 32 * v24;
              uint64_t v27 = v25;
              uint64_t v28 = (double *)a5;
              if (v6 > a4)
              {
                uint64_t v28 = (double *)malloc_type_malloc(v26, 0xADD7C2B9uLL);
                uint64_t v27 = (const void *)*((void *)this + 8);
              }
              if (v28) {
                uint64_t v9 = v28;
              }
              else {
                unint64_t v6 = a4;
              }
              if (v27)
              {
                memcpy(v9, v25, v26);
              }
              else if (v6)
              {
                unint64_t v45 = 0;
                long long v46 = v9 + 2;
                __asm { FMOV            V0.2D, #1.0 }
                do
                {
                  *((void *)v46 - 2) = 0;
                  *((void *)v46 - 1) = 0;
                  _OWORD *v46 = _Q0;
                  v46 += 2;
                  v45 += 4;
                }
                while (v45 < v6);
              }
              *a6 = v9;
              return v6;
            }
          }
        }
        return 0;
      }
      uint64_t v35 = a3[1];
      if ((v35 & 0x40000000) == 0 || v23 - 1 <= (v35 & 0xFFFFFFFFBFFFFFFFLL)) {
        return 0;
      }
      uint64_t v36 = *((void *)this + 8);
      if (v36)
      {
        double v37 = (double *)(v36 + 8 * (4 * v35));
        a5->f64[0] = *v37;
        a5->f64[1] = v37[1];
        a5[1].f64[0] = v37[2];
        a5[1].f64[1] = v37[3];
      }
      else
      {
        a5->f64[0] = 0.0;
        a5->f64[1] = 0.0;
        __asm { FMOV            V0.2D, #1.0 }
        a5[1] = _Q0;
      }
      return 4;
    }
    goto LABEL_14;
  }
  if (a2 == 2)
  {
    uint64_t v20 = a3[1];
    if ((v20 & 0x40000000) == 0 || *((void *)this + 4) <= (v20 & 0xFFFFFFFFBFFFFFFFLL)) {
      return 0;
    }
    if (v12 != 365)
    {
      double v21 = (float32x2_t *)(*((void *)this + 6) + 4 * (4 * v20));
      float64x2_t v22 = vcvtq_f64_f32(v21[1]);
      *a5 = vcvtq_f64_f32(*v21);
      a5[1] = v22;
      return 4;
    }
    uint64_t v44 = *((void *)this + 7);
    if (!v44) {
      return 0;
    }
    float v17 = *(float *)(v44 + 4 * (v20 & 0xFFFFFFFFBFFFFFFFLL));
    goto LABEL_26;
  }
  if (a2 != 1) {
    return 0;
  }
  unint64_t v6 = *((void *)this + 4);
  if (v12 == 110)
  {
    if (v6 >> 62) {
      return 0;
    }
    unint64_t v16 = (float **)((char *)this + 48);
    v6 *= 4;
  }
  else
  {
    unint64_t v16 = (float **)((char *)this + 56);
  }
  if (v6 >> 61) {
    return 0;
  }
  double v29 = *v16;
  double v30 = (double *)a5;
  if (v6 > a4) {
    double v30 = (double *)malloc_type_malloc(8 * v6, 0x531A6179uLL);
  }
  if (v30)
  {
    int v31 = v30;
  }
  else
  {
    unint64_t v6 = a4;
    int v31 = v9;
  }
  if (v29)
  {
    if (v6)
    {
      uint64_t v32 = v31;
      unint64_t v33 = v6;
      do
      {
        float v34 = *v29++;
        *v32++ = v34;
        --v33;
      }
      while (v33);
    }
  }
  else if (v6)
  {
    unint64_t v38 = 0;
    uint64x2_t v39 = (uint64x2_t)vdupq_n_s64(v6 - 1);
    double v40 = 1.0 / (double)v6;
    int64x2_t v41 = (int64x2_t)xmmword_184997FD0;
    int64x2_t v42 = vdupq_n_s64(2uLL);
    do
    {
      int32x2_t v43 = vmovn_s64((int64x2_t)vcgeq_u64(v39, (uint64x2_t)v41));
      if (v43.i8[0]) {
        v31[v38] = v40 * (double)v38;
      }
      if (v43.i8[4]) {
        v31[v38 + 1] = v40 * (double)(v38 + 1);
      }
      v38 += 2;
      int64x2_t v41 = vaddq_s64(v41, v42);
    }
    while (((v6 + 1) & 0xFFFFFFFFFFFFFFFELL) != v38);
  }
  *a6 = v31;
  return v6;
}

uint64_t CA::Render::Layer::get_keypath_object(CA::Render::Layer *this, const CA::Render::Layer **a2, void *const *a3)
{
  v23[1] = *MEMORY[0x1E4F143B8];
  v23[0] = this;
  unsigned int v5 = CA::Render::skip_sublayers((CA::Render *)v23, a2, a3);
  if ((v5 & 0x80000000) != 0) {
    return 0;
  }
  unint64_t v6 = (unint64_t)*a2;
  if (!*a2) {
    return 0;
  }
  uint64_t v7 = (v6 & 1) != 0 ? 1 : *(unsigned int *)v6;
  if (v7 - v5 != 1) {
    return 0;
  }
  if (!v6) {
    goto LABEL_12;
  }
  if (v6)
  {
    if (v5) {
      goto LABEL_12;
    }
    v6 >>= 1;
  }
  else
  {
    if (*(_DWORD *)v6 <= v5) {
      goto LABEL_12;
    }
    LODWORD(v6) = *(_DWORD *)(v6 + 4 * v5 + 4);
  }
  if ((int)v6 > 225)
  {
    if ((int)v6 > 545)
    {
      switch(v6)
      {
        case 0x222:
          uint64_t v18 = *(void *)(v23[0] + 128);
          if (v18) {
            return *(void *)(v18 + 24);
          }
          return 0;
        case 0x223:
          return 0;
        case 0x238:
          uint64_t v14 = *(void *)(v23[0] + 128);
          if (v14) {
            return *(void *)(v14 + 16);
          }
          return 0;
      }
    }
    else
    {
      switch(v6)
      {
        case 0xE2:
          uint64_t v11 = *(void *)(v23[0] + 128);
          if (v11) {
            return *(void *)(v11 + 96);
          }
          return 0;
        case 0x182:
          uint64_t v17 = *(void *)(v23[0] + 128);
          if (v17) {
            return *(void *)(v17 + 112);
          }
          return 0;
        case 0x1F8:
          uint64_t v12 = *(void *)(v23[0] + 128);
          if (v12) {
            return *(void *)(v12 + 120);
          }
          return 0;
      }
    }
LABEL_12:
    double v8 = (uint64_t *)*((void *)this + 16);
    if (v8)
    {
      uint64_t result = *v8;
      if (*v8)
      {
        float64x2_t v10 = *(uint64_t (**)(void))(*(void *)result + 120);
        return v10();
      }
      return result;
    }
    return 0;
  }
  if ((int)v6 <= 120)
  {
    switch(v6)
    {
      case '8':
        uint64_t v15 = *(void *)(v23[0] + 128);
        if (v15) {
          return *(void *)(v15 + 104);
        }
        return 0;
      case 'q':
        uint64_t v16 = *(void *)(v23[0] + 128);
        if (v16) {
          return *(void *)(v16 + 88);
        }
        return 0;
      case 'w':
        uint64_t v11 = v23[0];
        return *(void *)(v11 + 96);
    }
    goto LABEL_12;
  }
  switch((int)v6)
  {
    case 135:
      uint64_t v13 = *(void *)(v23[0] + 128);
      if (!v13) {
        return 0;
      }
      return *(void *)(v13 + 40);
    case 136:
    case 137:
    case 138:
    case 140:
    case 141:
    case 142:
      goto LABEL_12;
    case 139:
      uint64_t v20 = *(void *)(v23[0] + 128);
      if (!v20) {
        return 0;
      }
      return *(void *)(v20 + 32);
    case 143:
      uint64_t v21 = *(void *)(v23[0] + 128);
      if (!v21) {
        return 0;
      }
      return *(void *)(v21 + 56);
    case 144:
      uint64_t v22 = *(void *)(v23[0] + 128);
      if (!v22) {
        return 0;
      }
      return *(void *)(v22 + 64);
    default:
      if (v6 != 121) {
        goto LABEL_12;
      }
      uint64_t v19 = *(void *)(v23[0] + 128);
      if (!v19) {
        return 0;
      }
      uint64_t result = *(void *)(v19 + 48);
      break;
  }
  return result;
}

uint64_t CA::Render::Texture::mix@<X0>(atomic_uint *this@<X0>, atomic_uint *a2@<X1>, const CA::Render::ValueInterpolator *a3@<X2>, void *a4@<X8>)
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  uint64_t result = (uint64_t)malloc_type_zone_malloc(malloc_zone, 0xA8uLL, 0x8BB15036uLL);
  if (result) {
    uint64_t result = CA::Render::Interpolator::Interpolator(result, this, a2, *(double *)a3);
  }
  *a4 = result;
  return result;
}

uint64_t CA::Render::Interpolator::Interpolator(uint64_t this, atomic_uint *a2, atomic_uint *a3, double a4)
{
  *(_DWORD *)(this + 8) = 1;
  *(_DWORD *)(this + 12) = 26;
  ++dword_1EB2ADE30;
  *(void *)this = &unk_1ED02D4F8;
  *(void *)(this + 16) = 0;
  if (a2)
  {
    double v4 = a2 + 2;
    if (!atomic_fetch_add(a2 + 2, 1u))
    {
      a2 = 0;
      atomic_fetch_add(v4, 0xFFFFFFFF);
    }
  }
  *(void *)(this + 24) = a2;
  if (a3)
  {
    unsigned int v5 = a3 + 2;
    if (!atomic_fetch_add(a3 + 2, 1u))
    {
      a3 = 0;
      atomic_fetch_add(v5, 0xFFFFFFFF);
    }
  }
  *(void *)(this + 32) = a3;
  *(void *)(this + 40) = 0;
  *(double *)(this + 48) = a4;
  *(void *)(this + 56) = 0;
  *(unsigned char *)(this + 160) = 0;
  return this;
}

uint64_t CA::Render::ShapeLayer::get_keypath_object(CA::Render::ShapeLayer *this, void *const *a2)
{
  unint64_t v2 = (unint64_t)*a2;
  if (!*a2) {
    return 0;
  }
  if (v2)
  {
    v2 >>= 1;
  }
  else
  {
    if (*(_DWORD *)v2 != 1) {
      return 0;
    }
    LODWORD(v2) = *(_DWORD *)(v2 + 4);
  }
  if (v2 == 355)
  {
    unint64_t v3 = (char *)this + 112;
    return *(void *)v3;
  }
  if (v2 != 423) {
    return 0;
  }
  unint64_t v3 = (char *)this + 16;
  return *(void *)v3;
}

CA::Render **CA::Render::Path::mix@<X0>(CA::Render **this@<X0>, CA::Render **a2@<X1>, const CA::Render::ValueInterpolator *a3@<X2>, CA::Render ***a4@<X8>)
{
  float v5 = *(double *)a3;
  uint64_t result = CA::Render::morph_paths(this, a2, a3, v5);
  *a4 = result;
  return result;
}

uint64_t CA::Render::AnimationEvaluator::second_pass(uint64_t this)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if ((*(unsigned char *)(this + 192) & 2) != 0)
  {
    int v1 = (double *)this;
    uint64_t v2 = *(void *)(*(void *)(this + 16) + 136);
    unint64_t v3 = *(unsigned int *)(v2 + 16);
    if (v3)
    {
      for (unint64_t i = 0; i < v3; ++i)
      {
        float v5 = *(CA::Render::Animation **)(v2 + 24 + 8 * i);
        if ((*((_DWORD *)v5 + 3) & 0x24100) == 0x4100)
        {
          int v7 = 0;
          double v6 = *v1;
          this = CA::Render::Animation::map_time(v5, &v6, &v7, 0, 0);
          if (this)
          {
            ++*((_DWORD *)v5 + 21);
            this = (*(uint64_t (**)(CA::Render::Animation *, double *, void, void, double))(*(void *)v5 + 120))(v5, v1, v7, 0, v6);
          }
          unint64_t v3 = *(unsigned int *)(v2 + 16);
        }
      }
    }
  }
  return this;
}

uint64_t CA::Render::Layer::set_filters(uint64_t result, uint64_t a2)
{
  uint64_t v2 = a2;
  if (a2 || *(void *)(result + 128))
  {
    unint64_t v3 = CA::Render::Layer::ensure_ext((CA::Render::Layer *)result);
    uint64_t result = v3[12];
    if (result != v2)
    {
      if (result && atomic_fetch_add((atomic_uint *volatile)(result + 8), 0xFFFFFFFF) == 1) {
        uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 16))(result);
      }
      if (v2)
      {
        double v4 = (atomic_uint *)(v2 + 8);
        if (!atomic_fetch_add((atomic_uint *volatile)(v2 + 8), 1u))
        {
          uint64_t v2 = 0;
          atomic_fetch_add(v4, 0xFFFFFFFF);
        }
      }
      v3[12] = v2;
    }
  }
  return result;
}

uint64_t CA::Render::Layer::set_contents_rect(uint64_t this, CA::Render::Vector *a2)
{
  uint64_t v2 = a2;
  if (a2 || *(void *)(this + 128))
  {
    unint64_t v3 = CA::Render::Layer::ensure_ext((CA::Render::Layer *)this);
    this = v3[5];
    if ((CA::Render::Vector *)this != v2)
    {
      if (this && atomic_fetch_add((atomic_uint *volatile)(this + 8), 0xFFFFFFFF) == 1) {
        this = (*(uint64_t (**)(uint64_t))(*(void *)this + 16))(this);
      }
      if (v2)
      {
        double v4 = (atomic_uint *)((char *)v2 + 8);
        if (!atomic_fetch_add((atomic_uint *volatile)v2 + 2, 1u))
        {
          uint64_t v2 = 0;
          atomic_fetch_add(v4, 0xFFFFFFFF);
        }
      }
      v3[5] = v2;
    }
  }
  return this;
}

void CA::Render::MatchMoveAnimation::apply(CA::Render::MatchMoveAnimation *this, CA::Render::AnimationEvaluator *a2, double a3)
{
  uint64_t v78 = *MEMORY[0x1E4F143B8];
  unint64_t v3 = *((void *)this + 16);
  if (!v3) {
    return;
  }
  float v5 = (CA::Render::LayerNode *)*((void *)a2 + 4);
  if (!v5) {
    return;
  }
  uint64_t v7 = *((void *)a2 + 3);
  uint64_t v8 = *(void **)(v7 + 808);
  uint64_t v9 = *(void **)(v7 + 800);
  while (v8 != v9)
  {
    v8 -= 5;
    float64x2_t v10 = std::__hash_table<std::__hash_value_type<CA::Render::Object *,x_link_struct>,std::__unordered_map_hasher<CA::Render::Object *,std::__hash_value_type<CA::Render::Object *,x_link_struct>,std::hash<CA::Render::Object *>,std::equal_to<CA::Render::Object *>,true>,std::__unordered_map_equal<CA::Render::Object *,std::__hash_value_type<CA::Render::Object *,x_link_struct>,std::equal_to<CA::Render::Object *>,std::hash<CA::Render::Object *>,true>,std::allocator<std::__hash_value_type<CA::Render::Object *,x_link_struct>>>::find<CA::Render::Object *>(v8, v3);
    if (v10)
    {
      uint64_t v11 = (CA::Render::LayerNode *)v10[3];
      goto LABEL_8;
    }
  }
  uint64_t v11 = 0;
LABEL_8:
  CA::Render::Update::mark_root_dependence((CA::Render::LayerNode *)(*(unsigned int *)(v7 + 1084) | ((unint64_t)*(unsigned __int16 *)(v7 + 1088) << 32)), v11, v5);
  if (!v11) {
    return;
  }
  unint64_t v12 = *((void *)this + 15);
  if (!v12) {
    goto LABEL_13;
  }
  if ((v12 & 1) == 0)
  {
    if (*(_DWORD *)v12)
    {
      LODWORD(v12) = *(_DWORD *)(v12 + 4);
      goto LABEL_15;
    }
LABEL_13:
    uint64_t v13 = (CA::Render::LayerNode *)*((void *)a2 + 4);
    goto LABEL_17;
  }
  v12 >>= 1;
LABEL_15:
  uint64_t v13 = (CA::Render::LayerNode *)*((void *)a2 + 4);
  if (v12 != 438)
  {
LABEL_17:
    int v14 = 0;
    int v15 = 0;
    if ((*((unsigned char *)this + 15) & 0x10) == 0) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }
  int v14 = 1;
LABEL_18:
  uint64_t v13 = (CA::Render::LayerNode *)*((void *)v13 + 11);
  int v15 = v14;
  if (!v13) {
    return;
  }
LABEL_19:
  uint64_t v16 = *((void *)this + 17);
  unsigned int v17 = *(_DWORD *)(v16 + 16);
  if (v17 >> 1 >= 4) {
    uint64_t v18 = 4;
  }
  else {
    uint64_t v18 = v17 >> 1;
  }
  if (!v18) {
    return;
  }
  uint64_t v19 = 0;
  float64x2_t v76 = 0u;
  float64x2_t v77 = 0u;
  float64x2_t v74 = 0u;
  float64x2_t v75 = 0u;
  do
  {
    uint64_t v20 = (void *)&v74.f64[v19];
    void *v20 = *(void *)(v16 + v19 * 8 + 24);
    v20[1] = *(void *)(v16 + v19 * 8 + 32);
    v19 += 2;
  }
  while (2 * v18 != v19);
  if ((*((unsigned char *)this + 15) & 0x20) != 0)
  {
    float64x2_t v21 = *(float64x2_t *)(*((void *)v11 + 4) + 80);
    uint64_t v22 = &v74;
    uint64_t v23 = v18;
    do
    {
      *uint64_t v22 = vmulq_f64(*v22, v21);
      ++v22;
      --v23;
    }
    while (v23);
  }
  *(void *)&v60.f64[0] = &unk_1ED030230;
  *(void *)&v60.f64[1] = v18;
  *(void *)&v61.f64[0] = &v74;
  CA::Render::LayerNode::MapGeometry::map((uint64_t)&v60, v11, v13);
  uint64_t v25 = *((void *)a2 + 5);
  if (v18 == 2)
  {
    double v26 = 0.5;
    if (v15)
    {
      uint64_t v27 = *(void *)(v25 + 128);
      if (v27)
      {
        double v26 = *(double *)(v27 + 168);
      }
      else
      {
        double v26 = 0.0;
        if ((*(unsigned char *)(v25 + 45) & 0x40) == 0) {
          double v26 = 0.5;
        }
      }
    }
    float64x2_t v36 = vsubq_f64(v75, v74);
    float64x2_t v68 = vmlaq_n_f64(v74, v36, v26);
    if (!v15) {
      goto LABEL_62;
    }
    unsigned int v37 = *((_DWORD *)this + 3);
    if ((v37 & 0xC000000) == 0) {
      goto LABEL_62;
    }
    long long v66 = 0u;
    long long v67 = 0u;
    long long v64 = 0u;
    long long v65 = 0u;
    float64x2_t v62 = 0u;
    float64x2_t v63 = 0u;
    float64x2_t v60 = 0u;
    float64x2_t v61 = 0u;
    if ((v37 & 0x8000000) != 0)
    {
      float64x2_t v56 = v36;
      double v38 = atan2(v36.f64[1], v36.f64[0]);
      float64x2_t v63 = 0u;
      long long v64 = 0u;
      long long v65 = xmmword_184997D50;
      long long v67 = xmmword_184997D60;
      __double2 v41 = __sincos_stret(v38);
      *(double *)v40.i64 = v41.__cosval;
      *(double *)v39.i64 = v41.__sinval;
      if (fabs(v41.__sinval) >= 0.0000001)
      {
        if (fabs(v41.__cosval) < 0.0000001)
        {
          v40.i64[0] = 1.0;
          v52.f64[0] = NAN;
          v52.f64[1] = NAN;
          v39.i64[0] = vbslq_s8((int8x16_t)vnegq_f64(v52), v40, v39).u64[0];
          v40.i64[0] = 0;
        }
      }
      else
      {
        v39.i64[0] = 1.0;
        v42.f64[0] = NAN;
        v42.f64[1] = NAN;
        v40.i64[0] = vbslq_s8((int8x16_t)vnegq_f64(v42), v39, v40).u64[0];
        v39.i64[0] = 0;
      }
      float64x2_t v36 = v56;
      *(void *)&v60.f64[0] = v40.i64[0];
      *(void *)&v60.f64[1] = v39.i64[0];
      v62.f64[0] = -*(double *)v39.i64;
      *(void *)&v62.f64[1] = v40.i64[0];
    }
    else
    {
      float64x2_t v60 = (float64x2_t)xmmword_184997D50;
      float64x2_t v62 = (float64x2_t)xmmword_184997D60;
      float64x2_t v63 = 0uLL;
      long long v64 = 0uLL;
      long long v65 = xmmword_184997D50;
      long long v67 = xmmword_184997D60;
    }
    if ((v37 & 0x4000000) != 0)
    {
      double v53 = sqrt(vaddvq_f64(vmulq_f64(v36, v36))) / *(double *)(v25 + 80);
      float64x2_t v60 = vmulq_n_f64(v60, v53);
      float64x2_t v61 = vmulq_n_f64((float64x2_t)0, v53);
      float64x2_t v62 = vmulq_n_f64(v62, v53);
      float64x2_t v63 = v61;
      long long v64 = 0u;
      long long v65 = xmmword_184997D50;
    }
    LODWORD(v70[0]) = 568;
    uint64_t v50 = (const unsigned int *)((v37 >> 9) & 1);
    float64x2_t v51 = (unsigned int *)v70;
    goto LABEL_61;
  }
  if (v18 != 1)
  {
    if (v17 < 8) {
      return;
    }
    if (v15)
    {
      uint64_t v28 = *(void *)(v25 + 128);
      if (v28)
      {
        double v30 = *(double *)(v28 + 168);
        double v29 = *(double *)(v28 + 176);
      }
      else
      {
        double v29 = 0.0;
        if ((*(unsigned char *)(v25 + 45) & 0x40) == 0) {
          double v29 = 0.5;
        }
        double v30 = v29;
      }
      *(double *)&long long v59 = v30;
      *((double *)&v59 + 1) = v29;
    }
    else
    {
      __asm { FMOV            V0.2D, #0.5 }
      long long v59 = _Q0;
      double v29 = 0.5;
      double v30 = 0.5;
    }
    float64x2_t v43 = vmlaq_n_f64(v74, vsubq_f64(v75, v74), v30);
    int64x2_t v44 = (int64x2_t)vmlaq_n_f64(v43, vmlaq_n_f64(vsubq_f64(v77, v43), vsubq_f64(v76, v77), v30), v29);
    float64x2_t v68 = (float64x2_t)v44;
    if (!v15) {
      goto LABEL_62;
    }
    uint64_t v45 = 0;
    long long v72 = 0u;
    long long v73 = 0u;
    *(_OWORD *)double v70 = 0u;
    long long v71 = 0u;
    float64x2_t v46 = (float64x2_t)vdupq_lane_s64(v44.i64[0], 0);
    float64x2_t v47 = (float64x2_t)vdupq_laneq_s64(v44, 1);
    do
    {
      uint64_t v48 = &v74.f64[v45];
      float64x2x2_t v79 = vld2q_f64(v48);
      v80.val[0] = vsubq_f64(v79.val[0], v46);
      v80.val[1] = vsubq_f64(v79.val[1], v47);
      double v49 = &v70[v45];
      vst2q_f64(v49, v80);
      v45 += 4;
    }
    while (v45 != 8);
    long long v66 = 0u;
    long long v67 = 0u;
    long long v64 = 0u;
    long long v65 = 0u;
    float64x2_t v62 = 0u;
    float64x2_t v63 = 0u;
    float64x2_t v60 = 0u;
    float64x2_t v61 = 0u;
    long long v58 = *(_OWORD *)(v25 + 80);
    CA::Mat4Impl::mat4_set_corner_matrix((uint64_t)&v60, v70, (double *)&v58, (double *)&v59);
    int v57 = 568;
    uint64_t v50 = (const unsigned int *)((*((_DWORD *)this + 3) >> 9) & 1);
    float64x2_t v51 = (unsigned int *)&v57;
LABEL_61:
    CA::Render::Layer::set_property_value((CA::Render::Layer *)v25, v51, (double *)1, v50, (CA::Render::Vector *)0x10, v60.f64, v24);
    goto LABEL_62;
  }
  float64x2_t v68 = v74;
LABEL_62:
  unsigned int v54 = *((_DWORD *)this + 3);
  int v55 = (v54 >> 8) & 0x30000;
  if (!v55) {
    return;
  }
  if (v55 == 0x20000 || v55 == 0x10000)
  {
    memset(&v69, 0, 32);
    if ((unint64_t)CA::Render::Layer::get_keypath_value((CA::Render::Layer *)v25, (unint64_t *)this + 15, 4uLL, &v69, 0) < 2)return; {
    unsigned int v54 = *((_DWORD *)this + 3);
    }
    if ((v54 & 0x1000000) == 0) {
      v68.f64[0] = v69.f64[0];
    }
    if ((v54 & 0x2000000) == 0) {
      v68.f64[1] = v69.f64[1];
    }
  }
  CA::Render::Layer::set_keypath_value((CA::Render::Layer *)v25, (unint64_t *)this + 15, (const unsigned int *)((v54 >> 9) & 1), (CA::Render::Vector *)2, v68.f64);
}

void CA::Render::Layer::set_keypath_value(CA::Render::Layer *this, unint64_t *size, const unsigned int *a3, CA::Render::Vector *a4, double *a5)
{
  v19[1] = *MEMORY[0x1E4F143B8];
  unint64_t v5 = *size;
  if (*size)
  {
    if (v5)
    {
      unint64_t v10 = 1;
    }
    else
    {
      unint64_t v10 = *(unsigned int *)v5;
      if (v10 - 0x10000 < 0xFFFFFFFFFFFF0001) {
        return;
      }
      if (v10 > 0x400)
      {
        unint64_t v12 = malloc_type_malloc(4 * v10, 0x100004052888210uLL);
        if (!v12) {
          return;
        }
        int v14 = v12;
        unint64_t v5 = *size;
        if (!*size) {
          goto LABEL_15;
        }
        if ((v5 & 1) == 0) {
          goto LABEL_8;
        }
        goto LABEL_14;
      }
    }
    MEMORY[0x1F4188790](this);
    int v14 = (_DWORD *)((char *)v19 - ((v18 + 15) & 0x7FFFFFFF0));
    bzero(v14, v18);
    if ((v5 & 1) == 0)
    {
LABEL_8:
      uint64_t v15 = *(unsigned int *)v5;
      if (v15)
      {
        unint64_t v16 = 0;
        uint64_t v17 = 4 * v15;
        do
        {
          v14[v16 / 4] = *(_DWORD *)(v5 + 4 + v16);
          v16 += 4;
        }
        while (v17 != v16);
      }
      goto LABEL_15;
    }
LABEL_14:
    _DWORD *v14 = v5 >> 1;
LABEL_15:
    CA::Render::Layer::set_property_value(this, v14, (double *)v10, a3, a4, a5, v13);
    if (v10 >= 0x401) {
      free(v14);
    }
  }
}

void CA::Render::Layer::set_property_value(CA::Render::Layer *this, const unsigned int *a2, double *a3, const unsigned int *a4, CA::Render::Vector *a5, double *a6, const double *a7)
{
  uint64_t v177 = *MEMORY[0x1E4F143B8];
  if (!a3) {
    return;
  }
  uint64_t v7 = (float64x2_t *)a6;
  BOOL v9 = (int)a4;
  int v13 = a3 - 1;
  if (a3 == (double *)1)
  {
    int8x16_t v173 = 0u;
    float64x2_t v174 = 0u;
    v172.CGFloat a = 0.0;
    if (!a4)
    {
LABEL_28:
      uint64_t v15 = 0;
      int v14 = *a2;
      goto LABEL_29;
    }
    int v14 = *a2;
    uint64_t v15 = 1;
    if (*(int *)a2 > 545)
    {
      if (v14 != 546 && v14 != 568)
      {
LABEL_23:
        if (CA::Render::Layer::get_property_value(this, a2, 1, 4uLL, (float64x2_t *)&v173, (float64x2_t **)&v172, 0.0) >= (unint64_t)a5)
        {
          CGFloat a = v172.a;
          if (a5)
          {
            uint64_t v23 = 0;
            do
            {
              *(double *)(*(void *)&a + 8 * (void)v23) = *(double *)(*(void *)&a + 8 * (void)v23)
                                                             + v7->f64[(void)v23];
              uint64_t v23 = (CA::Render::Vector *)((char *)v23 + 1);
            }
            while (a5 != v23);
          }
          uint64_t v7 = *(float64x2_t **)&a;
        }
        goto LABEL_28;
      }
    }
    else if (v14 != 139 && v14 != 330)
    {
      goto LABEL_23;
    }
LABEL_29:
    if (v14 <= 377)
    {
      if (v14 <= 124)
      {
        if (v14 > 54)
        {
          switch(v14)
          {
            case 'B':
              if ((unint64_t)a5 >= 4)
              {
                float v33 = v7->f64[0];
                float v34 = v7->f64[1];
                float v35 = v7[1].f64[0];
                float v36 = v7[1].f64[1];
                CA::Render::Layer::set_border_color(this, v33, v34, v35, v36);
              }
              goto LABEL_327;
            case 'C':
              if (a5)
              {
                float v146 = v7->f64[0];
                if (v146 != 0.0 || *((void *)this + 16)) {
                  *((float *)CA::Render::Layer::ensure_ext(this) + 58) = v146;
                }
              }
              goto LABEL_327;
            case 'D':
              if (!a5) {
                goto LABEL_327;
              }
              unint64_t v47 = *((void *)this + 5) & 0xFFFFFFDFFFFFFFFFLL | ((unint64_t)(v7->f64[0] > 0.5) << 37);
              goto LABEL_326;
            case 'E':
              if (a5)
              {
                float v147 = v7->f64[0];
                if (v147 > 0.0 || *((void *)this + 16)) {
                  *((float *)CA::Render::Layer::ensure_ext(this) + 59) = v147;
                }
              }
              goto LABEL_327;
            case 'F':
            case 'G':
            case 'H':
            case 'I':
              goto LABEL_306;
            case 'J':
              if ((unint64_t)a5 >= 4)
              {
                float64x2_t v148 = vsubq_f64(v7[1], *v7);
                *((float64x2_t *)this + 4) = *v7;
                *((float64x2_t *)this + 5) = v148;
              }
              goto LABEL_327;
            default:
              if (v14 == 55)
              {
                if ((unint64_t)a5 >= 2)
                {
                  float64_t v154 = v7->f64[0];
                  float64_t v155 = v7->f64[1];
                  int64x2_t v156 = (float64_t *)CA::Render::Layer::ensure_ext(this);
                  v156[19] = v154;
                  v156[20] = v155;
                }
              }
              else
              {
                if (v14 != 121) {
                  goto LABEL_306;
                }
                if ((unint64_t)a5 >= 4)
                {
                  uint64_t v93 = CA::Render::Vector::new_vector((CA::Render::Vector *)4, v7, a3);
                  CA::Render::Layer::set_contents_center((uint64_t)this, (CA::Render::Vector *)v93);
                  if (v93)
                  {
LABEL_285:
                    if (atomic_fetch_add(v93 + 2, 0xFFFFFFFF) == 1) {
                      (*(void (**)(atomic_uint *))(*(void *)v93 + 16))(v93);
                    }
                  }
                }
              }
              break;
          }
          goto LABEL_327;
        }
        if (v14 > 27)
        {
          if (v14 == 28)
          {
            if (a5 && (v7->f64[0] != 0.0 || *((void *)this + 16)))
            {
              float64_t v120 = v7->f64[0];
              *((float64_t *)CA::Render::Layer::ensure_ext(this) + 23) = v120;
            }
            goto LABEL_327;
          }
          if (v14 == 54)
          {
            if ((unint64_t)a5 >= 4)
            {
              float v85 = v7->f64[0];
              float v86 = v7->f64[1];
              float v87 = v7[1].f64[0];
              float v88 = v7[1].f64[1];
              CA::Render::Layer::set_background_color((uint64_t)this, v85, v86, v87, v88);
            }
            goto LABEL_327;
          }
        }
        else
        {
          if (v14 == 13)
          {
            if (!a5) {
              goto LABEL_327;
            }
            unint64_t v47 = *((void *)this + 5) & 0xFFFFFFFFFBFFFFFFLL | ((unint64_t)(v7->f64[0] > 0.5) << 26);
            goto LABEL_326;
          }
          if (v14 == 27)
          {
            if ((unint64_t)a5 >= 2)
            {
              *(float64x2_t *)&v176.CGFloat a = *v7;
              CA::Render::Layer::set_anchor_point(this, (uint64_t)&v176);
            }
            goto LABEL_327;
          }
        }
        goto LABEL_306;
      }
      if (v14 <= 182)
      {
        switch(v14)
        {
          case 125:
            if (a5)
            {
              float v24 = v7->f64[0];
              if (v24 != 1.0 || *((void *)this + 16)) {
                *((float *)CA::Render::Layer::ensure_ext(this) + 64) = v24;
              }
            }
            break;
          case 131:
            if (a5) {
              *((_DWORD *)this + 9) = *((_DWORD *)this + 9) & 0xFFFF0FFF | (((int)v7->f64[0] & 0xF) << 12);
            }
            break;
          case 132:
            if (a5)
            {
              float v131 = v7->f64[0];
              if (v131 != 0.0 || *((void *)this + 16)) {
                *((float *)CA::Render::Layer::ensure_ext(this) + 65) = v131;
              }
            }
            break;
          case 133:
            if ((unint64_t)a5 >= 4)
            {
              float v132 = v7->f64[0];
              float v133 = v7->f64[1];
              float v134 = v7[1].f64[0];
              float v135 = v7[1].f64[1];
              CA::Render::Layer::set_contents_multiply_color(this, v132, v133, v134, v135);
            }
            break;
          case 135:
            if ((unint64_t)a5 >= 4)
            {
              uint64_t v93 = CA::Render::Vector::new_vector((CA::Render::Vector *)4, v7, a3);
              CA::Render::Layer::set_contents_rect((uint64_t)this, (CA::Render::Vector *)v93);
              if (v93) {
                goto LABEL_285;
              }
            }
            break;
          case 136:
            if (a5)
            {
              float v136 = v7->f64[0];
              CA::Render::Layer::set_contents_scale(this, v136);
            }
            break;
          case 138:
            if (a5) {
              CA::Render::Layer::set_contents_swizzle(this, (int)v7->f64[0]);
            }
            break;
          case 139:
            CA::Render::Layer::set_affine_matrix((atomic_uint *)this, v15, (unint64_t)a5, v7);
            break;
          case 147:
            if ((unint64_t)a5 >= 8)
            {
              uint64_t v93 = CA::Render::Vector::new_vector((CA::Render::Vector *)8, v7, a3);
              CA::Render::Layer::set_corner_radii((uint64_t)this, (CA::Render::Vector *)v93);
              if (v93) {
                goto LABEL_285;
              }
            }
            break;
          case 148:
            if (a5)
            {
              float v137 = v7->f64[0];
              float v138 = v137 >= 0.0 ? v7->f64[0] : 0.0;
              if (v138 != 0.0 || *((void *)this + 16)) {
                *((float *)CA::Render::Layer::ensure_ext(this) + 57) = v138;
              }
            }
            break;
          default:
            goto LABEL_306;
        }
        goto LABEL_327;
      }
      if (v14 <= 256)
      {
        if (v14 == 183)
        {
          if (a5)
          {
            float v139 = v7->f64[0];
            if (v139 != 0.0 || *((void *)this + 16)) {
              *((float *)CA::Render::Layer::ensure_ext(this) + 66) = v139;
            }
          }
          goto LABEL_327;
        }
        if (v14 == 186)
        {
          if (!a5) {
            goto LABEL_327;
          }
          unint64_t v47 = *((void *)this + 5) & 0xFFFFFFFFFFFFFBFFLL | ((unint64_t)(v7->f64[0] > 0.5) << 10);
          goto LABEL_326;
        }
LABEL_306:
        float64x2_t v142 = (void *)*((void *)this + 16);
        if (v142)
        {
          if (*v142)
          {
            uint64_t v143 = *CA::Render::Layer::ensure_ext(this);
            if (v143) {
              (*(void (**)(uint64_t, uint64_t, const unsigned int *, uint64_t, CA::Render::Vector *, float64x2_t *))(*(void *)v143 + 144))(v143, 1, a2, v15, a5, v7);
            }
          }
        }
        goto LABEL_327;
      }
      if (v14 != 257)
      {
        if (v14 == 335)
        {
          if (!a5) {
            goto LABEL_327;
          }
          unint64_t v47 = *((void *)this + 5) & 0xFFFFFFFDFFFFFFFFLL | ((unint64_t)(v7->f64[0] > 0.5) << 33);
          goto LABEL_326;
        }
        goto LABEL_306;
      }
      if (!a5) {
        goto LABEL_327;
      }
      unint64_t v47 = *((void *)this + 5) & 0xFFFFFFFFFFFFFEFFLL | ((unint64_t)(v7->f64[0] > 0.5) << 8);
LABEL_326:
      *((void *)this + 5) = v47;
LABEL_327:
      if (*(int8x16_t **)&v172.a != &v173) {
        free(*(void **)&v172.a);
      }
      return;
    }
    if (v14 <= 500)
    {
      if (v14 > 443)
      {
        switch(v14)
        {
          case 477:
            if ((unint64_t)a5 >= 4)
            {
              float v25 = v7->f64[0];
              float v26 = v7->f64[1];
              float v27 = v7[1].f64[0];
              float v28 = v7[1].f64[1];
              CA::Render::Layer::set_rim_color(this, v25, v26, v27, v28);
            }
            break;
          case 478:
            if (a5)
            {
              float v144 = v7->f64[0];
              if (v144 > 0.0 || *((void *)this + 16)) {
                *((float *)CA::Render::Layer::ensure_ext(this) + 80) = v144;
              }
            }
            break;
          case 479:
            if (a5)
            {
              unint64_t v47 = *((void *)this + 5) & 0xFFFFFFEFFFFFFFFFLL | ((unint64_t)(v7->f64[0] > 0.5) << 36);
              goto LABEL_326;
            }
            break;
          case 480:
            if (a5)
            {
              float v145 = v7->f64[0];
              if (v145 > 0.0 || *((void *)this + 16)) {
                *((float *)CA::Render::Layer::ensure_ext(this) + 75) = v145;
              }
            }
            break;
          default:
            if (v14 != 444) {
              goto LABEL_306;
            }
            if (a5)
            {
              unint64_t v47 = *((void *)this + 5) & 0xFFFFFFFFFF7FFFFFLL | ((unint64_t)(v7->f64[0] > 0.5) << 23);
              goto LABEL_326;
            }
            break;
        }
        goto LABEL_327;
      }
      if (v14 <= 408)
      {
        if (v14 == 378)
        {
          if (!a5) {
            goto LABEL_327;
          }
          unint64_t v47 = *((void *)this + 5) & 0xFFFFFFFFFFFFFFBFLL | ((unint64_t)(v7->f64[0] > 0.5) << 6);
          goto LABEL_326;
        }
        if (v14 == 390)
        {
          if (a5)
          {
            float v46 = v7->f64[0];
            if (v46 != 0.0 || *((void *)this + 16)) {
              *((float *)CA::Render::Layer::ensure_ext(this) + 73) = v46;
            }
          }
          goto LABEL_327;
        }
        goto LABEL_306;
      }
      if (v14 == 409)
      {
        if (a5)
        {
          BOOL v117 = v7->f64[0] > 1.0 || v7->f64[0] < 0.0;
          float v118 = 1.0;
          if (v7->f64[0] < 0.0 && v7->f64[0] <= 1.0) {
            float v118 = 0.0;
          }
          float v119 = v7->f64[0];
          if (v117) {
            float v119 = v118;
          }
          *((unsigned char *)this + 32) = (int)(float)((float)(v119 * 255.0) + 0.5);
        }
        goto LABEL_327;
      }
      if (v14 != 438) {
        goto LABEL_306;
      }
      if ((unint64_t)a5 < 2) {
        goto LABEL_327;
      }
      *((float64x2_t *)this + 3) = *v7;
      if (a5 == (CA::Render::Vector *)2) {
        goto LABEL_327;
      }
      double v84 = v7[1].f64[0];
LABEL_131:
      if (v84 != 0.0 || *((void *)this + 16)) {
        *((double *)CA::Render::Layer::ensure_ext(this) + 24) = v84;
      }
      goto LABEL_327;
    }
    if (v14 <= 545)
    {
      switch(v14)
      {
        case 501:
          if ((unint64_t)a5 >= 4)
          {
            float v29 = v7->f64[0];
            float v30 = v7->f64[1];
            float v31 = v7[1].f64[0];
            float v32 = v7[1].f64[1];
            CA::Render::Layer::set_shadow_color(this, v29, v30, v31, v32);
          }
          goto LABEL_327;
        case 502:
          if ((unint64_t)a5 >= 2)
          {
            float v123 = v7->f64[0];
            float v124 = v7->f64[1];
            BOOL v125 = v123 == 0.0 && v124 == -3.0;
            if (!v125 || *((void *)this + 16))
            {
              long long v126 = (float *)CA::Render::Layer::ensure_ext(this);
              v126[54] = v123;
              v126[55] = v124;
            }
          }
          goto LABEL_327;
        case 503:
          if (a5)
          {
            BOOL v127 = v7->f64[0] > 1.0 || v7->f64[0] < 0.0;
            float v128 = 1.0;
            if (v7->f64[0] < 0.0 && v7->f64[0] <= 1.0) {
              float v128 = 0.0;
            }
            float v129 = v7->f64[0];
            if (v127) {
              float v129 = v128;
            }
            *((unsigned char *)this + 33) = (int)(float)((float)(v129 * 255.0) + 0.5);
          }
          goto LABEL_327;
        case 505:
          if (!a5) {
            goto LABEL_327;
          }
          unint64_t v47 = *((void *)this + 5) & 0xFFFFFFFBFFFFFFFFLL | ((unint64_t)(v7->f64[0] > 0.5) << 34);
          break;
        case 506:
          if (a5)
          {
            float v130 = v7->f64[0];
            if (v130 != 3.0 || *((void *)this + 16)) {
              *((float *)CA::Render::Layer::ensure_ext(this) + 56) = v130;
            }
          }
          goto LABEL_327;
        case 508:
          if (!a5) {
            goto LABEL_327;
          }
          unint64_t v47 = *((void *)this + 5) & 0xFFFFFFFFFFFBFFFFLL | ((unint64_t)(v7->f64[0] > 0.5) << 18);
          break;
        case 509:
          if (!a5) {
            goto LABEL_327;
          }
          unint64_t v47 = *((void *)this + 5) & 0xFFFFFFFFFFF7FFFFLL | ((unint64_t)(v7->f64[0] > 0.5) << 19);
          break;
        case 510:
          if (!a5) {
            goto LABEL_327;
          }
          unint64_t v47 = *((void *)this + 5) & 0xFFFFFFFFFFEFFFFFLL | ((unint64_t)(v7->f64[0] > 0.5) << 20);
          break;
        case 516:
          if (!a5) {
            goto LABEL_327;
          }
          unint64_t v47 = *((void *)this + 5) & 0xFFFFFFBFFFFFFFFFLL | ((unint64_t)(v7->f64[0] > 0.5) << 38);
          break;
        default:
          goto LABEL_306;
      }
      goto LABEL_326;
    }
    switch(v14)
    {
      case 546:
        size_t v140 = (atomic_uint *)this;
        uint64_t v141 = 24;
        break;
      case 568:
        size_t v140 = (atomic_uint *)this;
        uint64_t v141 = 16;
        break;
      case 615:
        if (!a5) {
          goto LABEL_327;
        }
        double v84 = v7->f64[0];
        goto LABEL_131;
      default:
        goto LABEL_306;
    }
    CA::Render::Layer::set_transform_matrix(v140, v141, v15, (unint64_t)a5, v7);
    goto LABEL_327;
  }
  uint64_t v17 = a2 + 1;
  int v16 = *a2;
  if (*(int *)a2 > 138)
  {
    if (v16 <= 501)
    {
      if (v16 != 139)
      {
        if (v16 != 226)
        {
          if (v16 != 438) {
            goto LABEL_115;
          }
          double v40 = *((double *)this + 6);
          double v39 = *((double *)this + 7);
          if (a3 == 2)
          {
            unsigned int v41 = *v17;
            if (a5 && v41 == 607)
            {
              if (!a4) {
                double v40 = -0.0;
              }
              double v40 = *a6 + v40;
            }
            else if (a5 && v41 == 611)
            {
              if (!a4) {
                double v39 = -0.0;
              }
              double v39 = *a6 + v39;
            }
          }
          *((double *)this + 6) = v40;
          *((double *)this + 7) = v39;
          return;
        }
        uint64_t v69 = *((void *)this + 16);
        if (v69) {
          uint64_t v70 = *(void *)(v69 + 96);
        }
        else {
          uint64_t v70 = 0;
        }
        uint64_t v113 = CA::Render::set_list_property<CA::Render::Filter>(v70, (unint64_t)a3 - 1, (uint64_t)(a2 + 1), (int)a4, a5, a6);
        long long v114 = v113;
        uint64_t v115 = *((void *)this + 16);
        if (v115) {
          uint64_t v115 = *(void *)(v115 + 96);
        }
        if (v113 == (_DWORD *)v115) {
          return;
        }
        long long v116 = CA::Render::Layer::ensure_ext(this);
        float64x2_t v99 = (atomic_uint *)v116[12];
        v116[12] = v114;
        if (!v99) {
          return;
        }
LABEL_208:
        if (atomic_fetch_add(v99 + 2, 0xFFFFFFFF) != 1) {
          return;
        }
        uint64_t v98 = *(void (**)(atomic_uint *))(*(void *)v99 + 16);
        goto LABEL_419;
      }
      uint64_t v59 = *((void *)this + 16);
      if (v59 && (uint64_t v60 = *(void *)(v59 + 32)) != 0)
      {
        unsigned int v61 = *(_DWORD *)(v60 + 16);
        float64x2_t v62 = (_OWORD *)(v60 + 24);
        float64x2_t v63 = (long long *)(v60 + 40);
        long long v64 = (long long *)(v60 + 56);
        BOOL v65 = v61 >= 6;
        if (v61 < 6) {
          long long v64 = (long long *)(MEMORY[0x1E4F1DAB8] + 32);
        }
        long long v66 = (long long *)(MEMORY[0x1E4F1DAB8] + 16);
        if (v65) {
          long long v66 = v63;
        }
        if (!v65) {
          float64x2_t v62 = (_OWORD *)MEMORY[0x1E4F1DAB8];
        }
        long long v67 = *v66;
        long long v68 = *v64;
        *(_OWORD *)&v172.CGFloat a = *v62;
        *(_OWORD *)&v172.c = v67;
        *(_OWORD *)&v172.tx = v68;
      }
      else
      {
        long long v89 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
        *(_OWORD *)&v172.CGFloat a = *MEMORY[0x1E4F1DAB8];
        *(_OWORD *)&v172.c = v89;
        *(_OWORD *)&v172.tx = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 32);
      }
      memset(v175, 0, 40);
      int8x16_t v173 = 0u;
      float64x2_t v174 = 0u;
      CA::Mat2Impl::mat2_get_unmatrix((uint64_t)&v172, (uint64_t)&v173);
      if (v13 == 2)
      {
        if (*v17 == 572)
        {
          unsigned int v160 = a2[2];
          if (a5 && v160 == 607)
          {
            if (v9) {
              double v161 = v7->f64[0] + v174.f64[0];
            }
            else {
              double v161 = v7->f64[0];
            }
            v174.f64[0] = v161;
          }
          else if (a5 && v160 == 611)
          {
            if (v9) {
              double v169 = v7->f64[0] + v174.f64[1];
            }
            else {
              double v169 = v7->f64[0];
            }
            v174.f64[1] = v169;
          }
        }
        else if (*v17 == 486)
        {
          unsigned int v121 = a2[2];
          if (a5 && v121 == 607)
          {
            if (v9) {
              double v122 = v7->f64[0] + *(double *)v173.i64;
            }
            else {
              double v122 = v7->f64[0];
            }
            *(double *)v173.i64 = v122;
          }
          else if (a5 && v121 == 611)
          {
            if (v9) {
              double v168 = v7->f64[0] + *(double *)&v173.i64[1];
            }
            else {
              double v168 = v7->f64[0];
            }
            *(double *)&v173.i64[1] = v168;
          }
        }
      }
      else if (v13 == 1)
      {
        unsigned int v91 = *v17;
        if (a5 && v91 == 481)
        {
          if (v9) {
            double v92 = v7->f64[0] + *(double *)v175;
          }
          else {
            double v92 = v7->f64[0];
          }
          *(double *)long long v175 = v92;
        }
        else if (a5 && v91 == 486)
        {
          float64x2_t v157 = vld1q_dup_f64(v7->f64);
          int8x16_t v158 = (int8x16_t)vdupq_n_s64(0x8000000000000000);
          if (v9) {
            unint64_t v159 = -1;
          }
          else {
            unint64_t v159 = 0;
          }
          int8x16_t v173 = (int8x16_t)vaddq_f64(v157, (float64x2_t)vbslq_s8((int8x16_t)vdupq_n_s64(v159), v173, v158));
        }
        else if ((unint64_t)a5 >= 2 && v91 == 572)
        {
          if (v9) {
            float64x2_t v162 = vaddq_f64(*v7, v174);
          }
          else {
            float64x2_t v162 = *v7;
          }
          float64x2_t v174 = v162;
        }
      }
      *(_OWORD *)&v172.CGFloat a = *(_OWORD *)((char *)v175 + 8);
      *(_OWORD *)&v172.c = *(_OWORD *)((char *)&v175[1] + 8);
      *(float64x2_t *)&v172.tx = v174;
      if (*(double *)v175 != 0.0) {
        CA::Mat2Impl::mat2_rotate((float64x2_t *)&v172, v90, *(double *)v175);
      }
      if (*(double *)v173.i64 != 1.0 || *(double *)&v173.i64[1] != 1.0)
      {
        *(float64x2_t *)&v172.CGFloat a = vmulq_n_f64(*(float64x2_t *)&v172.a, *(double *)v173.i64);
        *(float64x2_t *)&v172.c = vmulq_n_f64(*(float64x2_t *)&v172.c, *(double *)&v173.i64[1]);
      }
      CGAffineTransform v171 = v172;
      if (CGAffineTransformIsIdentity(&v171))
      {
        CA::Render::Layer::set_contents_transform((uint64_t)this, 0);
        return;
      }
      CGAffineTransform v176 = v172;
      uint64_t v104 = CA::Render::Vector::new_vector((CA::Render::Vector *)6, &v176, v170);
      CA::Render::Layer::set_contents_transform((uint64_t)this, (CA::Render::Vector *)v104);
      if (!v104) {
        return;
      }
    }
    else
    {
      if (v16 <= 546)
      {
        if (v16 != 502)
        {
          if (v16 == 546)
          {
            uint64_t v20 = *((void *)this + 16);
            if (v20) {
              float64x2_t v21 = *(CA::Render **)(v20 + 24);
            }
            else {
              float64x2_t v21 = 0;
            }
            uint64_t v104 = CA::Render::set_transform_property(v21, (CA::Render::Vector *)((char *)a3 - 1), (int *)a2 + 1, a4, (unint64_t)a5, (uint64_t)a6, a7);
            CA::Render::Layer::set_sublayer_transform((uint64_t)this, (CA::Render::Vector *)v104);
            if (!v104) {
              return;
            }
            goto LABEL_417;
          }
          goto LABEL_115;
        }
        uint64_t v50 = *((void *)this + 16);
        if (v50)
        {
          double v51 = *(float *)(v50 + 216);
          double v52 = *(float *)(v50 + 220);
        }
        else
        {
          double v52 = -3.0;
          double v51 = 0.0;
        }
        if (a3 == 2)
        {
          unsigned int v109 = *v17;
          if (a5 && v109 == 604)
          {
            if (!a4) {
              double v51 = -0.0;
            }
            double v51 = *a6 + v51;
          }
          else if (a5 && v109 == 256)
          {
            if (!a4) {
              double v52 = -0.0;
            }
            double v52 = *a6 + v52;
          }
        }
        float v149 = v51;
        float v150 = v52;
        if (v50 || v149 != 0.0 || v150 != -3.0)
        {
          long long v151 = (float *)CA::Render::Layer::ensure_ext(this);
          v151[54] = v149;
          v151[55] = v150;
        }
        return;
      }
      if (v16 != 547)
      {
        if (v16 == 568)
        {
          uint64_t v44 = *((void *)this + 16);
          if (v44) {
            uint64_t v45 = *(CA::Render **)(v44 + 16);
          }
          else {
            uint64_t v45 = 0;
          }
          uint64_t v104 = CA::Render::set_transform_property(v45, (CA::Render::Vector *)((char *)a3 - 1), (int *)a2 + 1, a4, (unint64_t)a5, (uint64_t)a6, a7);
          CA::Render::Layer::set_transform((uint64_t)this, (CA::Render::Vector *)v104);
          if (!v104) {
            return;
          }
          goto LABEL_417;
        }
        goto LABEL_115;
      }
      uint64_t v73 = *((void *)this + 13);
      if ((*((unsigned char *)this + 13) & 0x20) != 0)
      {
        if (!v73
          || !CA::Render::atom_is_single_sublayer((CA::Render *)*v17, *((void *)this + 13), (CA::Render::Layer *)a3))
        {
          return;
        }
        float64x2_t v94 = (atomic_uint *)x_mem_alloc0(0x98uLL);
        if (v94)
        {
          float64x2_t v95 = v94;
          uint64_t v96 = (CA::Render::Layer *)CA::Render::Layer::Layer((uint64_t)v94, v73);
          CA::Render::Layer::set_property_value(v96, a2 + 2, (unint64_t)a3 - 2, v9, (unint64_t)a5, v7->f64);
          CA::Render::Layer::evaluate_container((uint64_t)v95, v97);
          CA::Render::Layer::set_single_sublayer((uint64_t)this, v95);
          if (atomic_fetch_add(v95 + 2, 0xFFFFFFFF) != 1) {
            return;
          }
          uint64_t v98 = *(void (**)(atomic_uint *))(*(void *)v95 + 16);
          float64x2_t v99 = v95;
LABEL_419:
          v98(v99);
          return;
        }
        CA::Render::Layer::set_property_value(0, a2 + 2, (unint64_t)a3 - 2, v9, (unint64_t)a5, v7->f64);
        CA::Render::Layer::evaluate_container(0, v167);
        CA::Render::Layer::set_single_sublayer((uint64_t)this, 0);
        return;
      }
      if (!v73) {
        return;
      }
      unsigned int named_object = CA::Render::TypedArray<CA::Render::Layer>::find_named_object(*((void *)this + 13), *v17);
      if ((named_object & 0x80000000) != 0) {
        return;
      }
      unsigned int v75 = named_object;
      float64x2_t v76 = x_mem_alloc0(0x98uLL);
      uint64_t v77 = (uint64_t)v76;
      if (v76)
      {
        uint64_t v78 = (CA::Render::Layer *)CA::Render::Layer::Layer((uint64_t)v76, *(void *)(v73 + 8 * v75 + 24));
        CA::Render::Layer::set_property_value(v78, a2 + 2, (unint64_t)a3 - 2, v9, (unint64_t)a5, v7->f64);
        uint64_t v80 = v77;
      }
      else
      {
        CA::Render::Layer::set_property_value(0, a2 + 2, (unint64_t)a3 - 2, v9, (unint64_t)a5, v7->f64);
        uint64_t v80 = 0;
      }
      CA::Render::Layer::evaluate_container(v80, v79);
      uint64_t v104 = CA::Render::Array::new_array((CA::Render::Array *)*(unsigned int *)(v73 + 16), (const void *)(v73 + 24), (CA::Render::Object *const *)1, 0);
      long long v163 = &v104[2 * v75];
      long long v166 = (atomic_uint *)*((void *)v163 + 3);
      long long v165 = (uint64_t *)(v163 + 6);
      float64x2_t v164 = v166;
      if (v166 && atomic_fetch_add(v164 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v164 + 16))(v164);
      }
      *long long v165 = v77;
      CA::Render::Layer::set_sublayers((uint64_t)this, v104);
    }
LABEL_417:
    if (atomic_fetch_add(v104 + 2, 0xFFFFFFFF) != 1) {
      return;
    }
    uint64_t v98 = *(void (**)(atomic_uint *))(*(void *)v104 + 16);
    float64x2_t v99 = v104;
    goto LABEL_419;
  }
  if (v16 > 73)
  {
    if (v16 <= 120)
    {
      if (v16 == 74)
      {
        float64x2_t v48 = *((float64x2_t *)this + 5);
        int8x16_t v173 = *((int8x16_t *)this + 4);
        float64x2_t v174 = v48;
        CA::Render::set_rect_property((double *)v173.i64, (Rect *)((char *)a3 - 1), (int *)a2 + 1, a4, (unint64_t)a5, a6, a7);
        float64x2_t v49 = v174;
        *((int8x16_t *)this + 4) = v173;
        *((float64x2_t *)this + 5) = v49;
        return;
      }
      if (v16 == 113)
      {
        uint64_t v18 = *((void *)this + 16);
        if (v18) {
          uint64_t v19 = *(void *)(v18 + 88);
        }
        else {
          uint64_t v19 = 0;
        }
        float64x2_t v100 = CA::Render::set_object_property<CA::Render::Filter>(v19, (uint64_t)a3 - 1, (const double *)(a2 + 1), (int)a4, a5, a6);
        float64x2_t v101 = v100;
        uint64_t v102 = (CA::Render::Filter *)*((void *)this + 16);
        if (v102) {
          uint64_t v102 = (CA::Render::Filter *)*((void *)v102 + 11);
        }
        if (v100 == v102) {
          return;
        }
        uint64_t v103 = CA::Render::Layer::ensure_ext(this);
        float64x2_t v99 = (atomic_uint *)v103[11];
        v103[11] = v101;
        if (!v99) {
          return;
        }
        goto LABEL_208;
      }
      goto LABEL_115;
    }
    if (v16 == 121)
    {
      uint64_t v71 = *((void *)this + 16);
      if (v71) {
        long long v72 = *(CA::Render **)(v71 + 48);
      }
      else {
        long long v72 = 0;
      }
      uint64_t v104 = CA::Render::set_rect_vector_property(v72, (Rect *)((char *)a3 - 1), (int *)a2 + 1, a4, (unint64_t)a5, a6, a7);
      CA::Render::Layer::set_contents_center((uint64_t)this, (CA::Render::Vector *)v104);
      if (!v104) {
        return;
      }
      goto LABEL_417;
    }
    if (v16 == 135)
    {
      uint64_t v42 = *((void *)this + 16);
      if (v42) {
        float64x2_t v43 = *(CA::Render **)(v42 + 40);
      }
      else {
        float64x2_t v43 = 0;
      }
      uint64_t v104 = CA::Render::set_rect_vector_property(v43, (Rect *)((char *)a3 - 1), (int *)a2 + 1, a4, (unint64_t)a5, a6, a7);
      CA::Render::Layer::set_contents_rect((uint64_t)this, (CA::Render::Vector *)v104);
      if (!v104) {
        return;
      }
      goto LABEL_417;
    }
LABEL_115:
    uint64_t v81 = (void *)*((void *)this + 16);
    if (v81)
    {
      if (*v81)
      {
        uint64_t v82 = *CA::Render::Layer::ensure_ext(this);
        if (v82)
        {
          double v83 = *(void (**)(void))(*(void *)v82 + 144);
          v83();
        }
      }
    }
    return;
  }
  if (v16 == 27)
  {
    uint64_t v53 = *((void *)this + 16);
    if (v53)
    {
      double v55 = *(double *)(v53 + 168);
      double v54 = *(double *)(v53 + 176);
    }
    else
    {
      double v54 = 0.0;
      if ((*((unsigned char *)this + 45) & 0x40) == 0) {
        double v54 = 0.5;
      }
      double v55 = v54;
    }
    *(double *)v173.i64 = v55;
    *(double *)&v173.i64[1] = v54;
    if (a3 == 2)
    {
      unsigned int v110 = *v17;
      if (a5 && v110 == 607)
      {
        if (!a4) {
          double v55 = 0.0;
        }
        *(double *)v173.i64 = *a6 + v55;
      }
      else if (a5 && v110 == 611)
      {
        if (!a4) {
          double v54 = 0.0;
        }
        *(double *)&v173.i64[1] = *a6 + v54;
      }
    }
    CA::Render::Layer::set_anchor_point(this, (uint64_t)&v173);
    return;
  }
  if (v16 == 55)
  {
    uint64_t v56 = *((void *)this + 16);
    if (v56)
    {
      double v57 = *(double *)(v56 + 152);
      double v58 = *(double *)(v56 + 160);
    }
    else
    {
      double v57 = 0.0;
      double v58 = 0.0;
    }
    if (a3 == 2)
    {
      unsigned int v111 = *v17;
      if (a5 && v111 == 607)
      {
        double v112 = -0.0;
        if (a4) {
          double v112 = v57;
        }
        double v57 = *a6 + v112;
      }
      else if (a5 && v111 == 611)
      {
        double v152 = -0.0;
        if (a4) {
          double v152 = v58;
        }
        double v58 = *a6 + v152;
      }
    }
    long long v153 = (double *)CA::Render::Layer::ensure_ext(this);
    v153[19] = v57;
    v153[20] = v58;
    return;
  }
  if (v16 != 56) {
    goto LABEL_115;
  }
  uint64_t v37 = *((void *)this + 16);
  if (v37) {
    uint64_t v38 = *(void *)(v37 + 104);
  }
  else {
    uint64_t v38 = 0;
  }
  double v105 = CA::Render::set_list_property<CA::Render::Filter>(v38, (unint64_t)a3 - 1, (uint64_t)(a2 + 1), (int)a4, a5, a6);
  uint64_t v106 = v105;
  uint64_t v107 = *((void *)this + 16);
  if (v107) {
    uint64_t v107 = *(void *)(v107 + 104);
  }
  if (v105 != (_DWORD *)v107)
  {
    double v108 = CA::Render::Layer::ensure_ext(this);
    float64x2_t v99 = (atomic_uint *)v108[13];
    v108[13] = v106;
    if (v99) {
      goto LABEL_208;
    }
  }
}

void *std::__hash_table<std::__hash_value_type<CA::Render::Object *,x_link_struct>,std::__unordered_map_hasher<CA::Render::Object *,std::__hash_value_type<CA::Render::Object *,x_link_struct>,std::hash<CA::Render::Object *>,std::equal_to<CA::Render::Object *>,true>,std::__unordered_map_equal<CA::Render::Object *,std::__hash_value_type<CA::Render::Object *,x_link_struct>,std::equal_to<CA::Render::Object *>,std::hash<CA::Render::Object *>,true>,std::allocator<std::__hash_value_type<CA::Render::Object *,x_link_struct>>>::find<CA::Render::Object *>(void *a1, unint64_t a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  unint64_t v4 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v3 >> 47) ^ v3);
  unint64_t v5 = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = v5;
    if (v5 >= *(void *)&v2) {
      unint64_t v7 = v5 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v7 = v5 & (*(void *)&v2 - 1);
  }
  uint64_t v8 = *(void **)(*a1 + 8 * v7);
  if (!v8) {
    return 0;
  }
  uint64_t result = (void *)*v8;
  if (*v8)
  {
    do
    {
      unint64_t v10 = result[1];
      if (v10 == v5)
      {
        if (result[2] == a2) {
          return result;
        }
      }
      else
      {
        if (v6.u32[0] > 1uLL)
        {
          if (v10 >= *(void *)&v2) {
            v10 %= *(void *)&v2;
          }
        }
        else
        {
          v10 &= *(void *)&v2 - 1;
        }
        if (v10 != v7) {
          return 0;
        }
      }
      uint64_t result = (void *)*result;
    }
    while (result);
  }
  return result;
}

atomic_uint *CA::Render::Layer::set_transform_matrix(atomic_uint *result, uint64_t a2, int a3, unint64_t a4, float64x2_t *a5)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (a4 >= 0x10)
  {
    uint64_t result = (atomic_uint *)CA::Render::Layer::ensure_ext((CA::Render::Layer *)result);
    unint64_t v10 = result;
    v11.n128_u64[0] = *(void *)&a5->f64[0];
    if (a5->f64[0] == 1.0)
    {
      uint64_t v17 = 1;
      while (v17 != 16)
      {
        uint64_t v18 = v17;
        v11.n128_u64[0] = *(void *)&a5->f64[v17];
        double v19 = *((double *)&CA::Mat4Impl::mat4_identity_double + v17++);
        if (v11.n128_f64[0] != v19)
        {
          if ((unint64_t)(v18 - 1) < 0xF) {
            goto LABEL_3;
          }
          break;
        }
      }
      if ((a3 & 1) == 0)
      {
        uint64_t result = *(atomic_uint **)((char *)result + a2);
        *(void *)((char *)v10 + a2) = 0;
        if (result)
        {
          if (atomic_fetch_add(result + 2, 0xFFFFFFFF) == 1)
          {
            uint64_t v20 = *(uint64_t (**)(__n128))(*(void *)result + 16);
            return (atomic_uint *)v20(v11);
          }
        }
      }
    }
    else
    {
LABEL_3:
      memset(v21, 0, sizeof(v21));
      if (a3)
      {
        uint64_t v12 = *(void *)((char *)result + a2);
        if (v12)
        {
          unsigned int v13 = *(_DWORD *)(v12 + 16);
          int v14 = (double *)(v12 + 24);
          if (v13 <= 0xF) {
            uint64_t v15 = (double *)&CA::Mat4Impl::mat4_identity_double;
          }
          else {
            uint64_t v15 = v14;
          }
          CA::Mat4Impl::mat4_concat(v21, v15, a5->f64, v9);
          a5 = v21;
        }
      }
      int v16 = CA::Render::Vector::new_vector((CA::Render::Vector *)0x10, a5, v8);
      uint64_t result = *(atomic_uint **)((char *)v10 + a2);
      *(void *)((char *)v10 + a2) = v16;
      if (result)
      {
        if (atomic_fetch_add(result + 2, 0xFFFFFFFF) == 1) {
          return (atomic_uint *)(*(uint64_t (**)(atomic_uint *))(*(void *)result + 16))(result);
        }
      }
    }
  }
  return result;
}

_DWORD *CA::Render::Vector::new_vector(CA::Render::Vector *this, const void *a2, const double *a3)
{
  int v4 = (int)this;
  size_t v5 = 8 * this;
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  unint64_t v7 = malloc_type_zone_malloc(malloc_zone, v5 + 24, 0x8BB15036uLL);
  uint64_t v8 = v7;
  if (v7)
  {
    v7[2] = 1;
    void v7[3] = 56;
    ++dword_1EB2ADEA8;
    *(void *)unint64_t v7 = &unk_1ED02F810;
    v7[4] = v4;
    BOOL v9 = v7 + 6;
    if (a2) {
      memcpy(v9, a2, v5);
    }
    else {
      bzero(v9, v5);
    }
  }
  return v8;
}

CA::Render::LayerNode *CA::Render::Update::mark_root_dependence(CA::Render::LayerNode *this, CA::Render::LayerNode *a2, CA::Render::LayerNode *a3)
{
  if ((this & 4) == 0)
  {
    unint64_t v3 = a3;
    int v4 = a2;
    if (a2)
    {
      this = CA::Render::LayerNode::shared_ancestor(a2, a3);
      if (this)
      {
        uint64_t v5 = *((void *)this + 5);
        if (!v5) {
          return this;
        }
LABEL_13:
        *(void *)(v5 + 96) |= 0x1000000000000000uLL;
        return this;
      }
      do
      {
        unint64_t v7 = v3;
        unint64_t v3 = (CA::Render::LayerNode *)*((void *)v3 + 11);
      }
      while (v3);
      uint64_t v8 = *((void *)v7 + 5);
      if (v8) {
        *(void *)(v8 + 96) |= 0x1000000000000000uLL;
      }
      do
      {
        uint8x8_t v6 = v4;
        int v4 = (CA::Render::LayerNode *)*((void *)v4 + 11);
      }
      while (v4);
    }
    else
    {
      do
      {
        uint8x8_t v6 = v3;
        unint64_t v3 = (CA::Render::LayerNode *)*((void *)v3 + 11);
      }
      while (v3);
    }
    uint64_t v5 = *((void *)v6 + 5);
    if (!v5) {
      return this;
    }
    goto LABEL_13;
  }
  return this;
}

void CA::Render::LayerNode::MapGeometry::map(uint64_t this, CA::Render::LayerNode *a2, CA::Render::LayerNode *a3)
{
  uint64_t v5 = (CA::Render::LayerNode::MapGeometry *)this;
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    this = (uint64_t)CA::Render::LayerNode::shared_ancestor(a2, a3);
    uint8x8_t v6 = (CA::Render::LayerNode::MapGeometry *)this;
    if (this)
    {
      do
      {
        if ((*(unsigned char *)(*((void *)v6 + 4) + 13) & 9) == 0) {
          break;
        }
        uint8x8_t v6 = (CA::Render::LayerNode::MapGeometry *)*((void *)v6 + 11);
      }
      while (v6);
    }
  }
  else
  {
    uint8x8_t v6 = 0;
  }
  long long v37 = xmmword_184997D50;
  float64x2_t v38 = 0u;
  v7.f64[1] = 1.0;
  float64x2_t v39 = (float64x2_t)xmmword_184997D60;
  float64x2_t v40 = 0u;
  float64x2_t v41 = 0u;
  float64x2_t v42 = (float64x2_t)xmmword_184997D50;
  long long v35 = xmmword_184997D60;
  long long v36 = xmmword_184997D50;
  float64x2_t v43 = 0u;
  float64x2_t v44 = (float64x2_t)xmmword_184997D60;
  if (v6 == a2) {
    goto LABEL_23;
  }
  char v8 = 0;
  BOOL v9 = a2;
  do
  {
    while (1)
    {
      if (v9 != a2 && (*(_DWORD *)(*((void *)v9 + 4) + 12) & 0x900) != 0) {
        goto LABEL_20;
      }
      unint64_t v10 = (float64x2_t *)*((void *)v9 + 7);
      if (!v10)
      {
        float64x2_t v12 = *((float64x2_t *)v9 + 4);
        v7.f64[0] = *((float64_t *)v9 + 10);
        long long v37 = (__int128)vmlaq_laneq_f64((float64x2_t)v37, v12, v38, 1);
        float64x2_t v38 = vmlaq_laneq_f64(v38, v7, v38, 1);
        float64x2_t v39 = vmlaq_laneq_f64(v39, v12, v40, 1);
        float64x2_t v40 = vmlaq_laneq_f64(v40, v7, v40, 1);
        float64x2_t v41 = vmlaq_laneq_f64(v41, v12, v42, 1);
        float64x2_t v42 = vmlaq_laneq_f64(v42, v7, v42, 1);
        float64x2_t v43 = vmlaq_laneq_f64(v43, v12, v44, 1);
        float64x2_t v44 = vmlaq_laneq_f64(v44, v7, v44, 1);
        goto LABEL_16;
      }
      this = CA::Mat4Impl::mat4_is_affine(*((CA::Mat4Impl **)v9 + 7), (const double *)a2);
      if (this) {
        break;
      }
      (**(void (***)(CA::Render::LayerNode::MapGeometry *, float64x2_t *))v5)(v5, (float64x2_t *)&v37);
      this = (**(uint64_t (***)(CA::Render::LayerNode::MapGeometry *, void))v5)(v5, *((void *)v9 + 7));
      char v8 = 0;
      char v13 = 0;
      v7.f64[1] = *((float64_t *)&v35 + 1);
      long long v37 = v36;
      float64x2_t v38 = 0u;
      float64x2_t v40 = 0u;
      float64x2_t v41 = 0u;
      float64x2_t v39 = (float64x2_t)v35;
      float64x2_t v42 = (float64x2_t)v36;
      float64x2_t v43 = 0u;
      float64x2_t v44 = (float64x2_t)v35;
      BOOL v9 = (CA::Render::LayerNode *)*((void *)v9 + 11);
      if (v9 == v6) {
        goto LABEL_24;
      }
    }
    if (v8)
    {
      CA::Mat4Impl::mat4_concat((float64x2_t *)&v37, (double *)&v37, v10->f64, v11);
LABEL_16:
      char v8 = 1;
      goto LABEL_20;
    }
    float64x2_t v14 = v10[1];
    float64x2_t v15 = v10[2];
    float64x2_t v16 = v10[3];
    long long v37 = (__int128)*v10;
    float64x2_t v38 = v14;
    float64x2_t v39 = v15;
    float64x2_t v40 = v16;
    float64x2_t v7 = v10[5];
    float64x2_t v17 = v10[6];
    float64x2_t v18 = v10[7];
    float64x2_t v41 = v10[4];
    float64x2_t v42 = v7;
    char v8 = 1;
    float64x2_t v43 = v17;
    float64x2_t v44 = v18;
LABEL_20:
    BOOL v9 = (CA::Render::LayerNode *)*((void *)v9 + 11);
  }
  while (v9 != v6);
  if ((v8 & 1) == 0)
  {
LABEL_23:
    char v13 = 0;
    goto LABEL_24;
  }
  this = (**(uint64_t (***)(CA::Render::LayerNode::MapGeometry *, float64x2_t *))v5)(v5, (float64x2_t *)&v37);
  char v13 = 1;
LABEL_24:
  if (v6 != a3)
  {
    double v19 = 0;
    int v20 = 2304;
    float64x2_t v21 = a3;
    do
    {
      if (v21 == a3 || (*(_DWORD *)(*((void *)v21 + 4) + 12) & v20) == 0)
      {
        this = MEMORY[0x1F4188790](this);
        *((void *)&v35 - 2) = v21;
        *((void *)&v35 - 1) = v19;
        double v19 = &v35 - 1;
      }
      float64x2_t v21 = (CA::Render::LayerNode *)*((void *)v21 + 11);
    }
    while (v21 != v6);
    if (v13)
    {
      long long v37 = v36;
      float64x2_t v38 = 0u;
      float64x2_t v40 = 0u;
      float64x2_t v41 = 0u;
      float64x2_t v39 = (float64x2_t)v35;
      float64x2_t v42 = (float64x2_t)v36;
      float64x2_t v43 = 0u;
      float64x2_t v44 = (float64x2_t)v35;
    }
    if (v19)
    {
      char v22 = 0;
      do
      {
        while (1)
        {
          uint64_t v23 = *(void *)v19;
          float v24 = *(float64x2_t **)(*(void *)v19 + 56);
          if (v24) {
            break;
          }
          double v26 = *(double *)(v23 + 64);
          double v27 = *(double *)(v23 + 72);
          double v28 = *(double *)(v23 + 80);
          float64x2_t v43 = vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(v43, (float64x2_t)v37, v26), v39, v27), v41, v28);
          float64x2_t v44 = vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(v44, v38, v26), v40, v27), v42, v28);
LABEL_47:
          double v19 = (long long *)*((void *)v19 + 1);
          char v22 = 1;
          if (!v19)
          {
            if (CA::Mat4Impl::mat4_invert((CA::Mat4Impl *)&v37, (CA::Mat4Impl *)&v37, (const double *)a3)) {
              (*(void (**)(CA::Render::LayerNode::MapGeometry *, long long *))(*(void *)v5 + 8))(v5, &v37);
            }
            return;
          }
        }
        if (CA::Mat4Impl::mat4_is_affine(*(CA::Mat4Impl **)(*(void *)v19 + 56), (const double *)a2))
        {
          if (v22)
          {
            CA::Mat4Impl::mat4_concat((float64x2_t *)&v37, v24->f64, (const double *)&v37, v25);
          }
          else
          {
            float64x2_t v29 = v24[1];
            float64x2_t v30 = v24[2];
            float64x2_t v31 = v24[3];
            long long v37 = (__int128)*v24;
            float64x2_t v38 = v29;
            float64x2_t v39 = v30;
            float64x2_t v40 = v31;
            float64x2_t v32 = v24[5];
            float64x2_t v33 = v24[6];
            float64x2_t v34 = v24[7];
            float64x2_t v41 = v24[4];
            float64x2_t v42 = v32;
            float64x2_t v43 = v33;
            float64x2_t v44 = v34;
          }
          goto LABEL_47;
        }
        if ((v22 & 1) != 0
          && CA::Mat4Impl::mat4_invert((CA::Mat4Impl *)&v37, (CA::Mat4Impl *)&v37, (const double *)a3))
        {
          (*(void (**)(CA::Render::LayerNode::MapGeometry *, long long *))(*(void *)v5 + 8))(v5, &v37);
        }
        if (CA::Mat4Impl::mat4_invert((CA::Mat4Impl *)&v37, *(CA::Mat4Impl **)(v23 + 56), (const double *)a3))(*(void (**)(CA::Render::LayerNode::MapGeometry *, long long *))(*(void *)v5 + 8))(v5, &v37); {
        char v22 = 0;
        }
        long long v37 = v36;
        float64x2_t v38 = 0u;
        float64x2_t v40 = 0u;
        float64x2_t v41 = 0u;
        float64x2_t v39 = (float64x2_t)v35;
        float64x2_t v42 = (float64x2_t)v36;
        float64x2_t v43 = 0u;
        float64x2_t v44 = (float64x2_t)v35;
        double v19 = (long long *)*((void *)v19 + 1);
      }
      while (v19);
    }
  }
}

CA::Render::LayerNode *CA::Render::LayerNode::shared_ancestor(CA::Render::LayerNode *this, CA::Render::LayerNode *a2)
{
  if (a2 == this || !a2 || *((CA::Render::LayerNode **)this + 11) == a2) {
    return a2;
  }
  if (*((CA::Render::LayerNode **)a2 + 11) == this) {
    return this;
  }
  BOOL v2 = 1;
  BOOL v3 = 1;
  unint64_t v4 = (unint64_t)a2;
  unint64_t v5 = (unint64_t)this;
  while (!v3)
  {
    unint64_t v5 = 0;
    if (v2) {
      goto LABEL_11;
    }
LABEL_9:
    unint64_t v4 = 0;
LABEL_13:
    BOOL v3 = v5 != 0;
    BOOL v2 = v4 != 0;
    if (!(v5 | v4))
    {
      unint64_t v5 = 0;
      goto LABEL_17;
    }
  }
  uint64_t v6 = *(void *)(v5 + 24);
  if ((v6 & 0x200000) != 0) {
    goto LABEL_17;
  }
  *(void *)(v5 + 24) = v6 | 0x200000;
  unint64_t v5 = *(void *)(v5 + 88);
  if (!v2) {
    goto LABEL_9;
  }
LABEL_11:
  uint64_t v7 = *(void *)(v4 + 24);
  if ((v7 & 0x200000) == 0)
  {
    *(void *)(v4 + 24) = v7 | 0x200000;
    unint64_t v4 = *(void *)(v4 + 88);
    goto LABEL_13;
  }
  unint64_t v5 = v4;
  do
  {
LABEL_17:
    uint64_t v8 = *((void *)this + 3);
    if ((v8 & 0x200000) == 0) {
      break;
    }
    *((void *)this + 3) = v8 & 0xFFFFFFFFFFDFFFFFLL;
    this = (CA::Render::LayerNode *)*((void *)this + 11);
  }
  while (this);
  do
  {
    uint64_t v9 = *((void *)a2 + 3);
    if ((v9 & 0x200000) == 0) {
      break;
    }
    *((void *)a2 + 3) = v9 & 0xFFFFFFFFFFDFFFFFLL;
    a2 = (CA::Render::LayerNode *)*((void *)a2 + 11);
  }
  while (a2);
  return (CA::Render::LayerNode *)v5;
}

uint64_t CA::Mat4Impl::mat4_invert(CA::Mat4Impl *this, CA::Mat4Impl *a2, const double *a3)
{
  BOOL is_affine = CA::Mat4Impl::mat4_is_affine(a2, (const double *)a2);
  double v7 = *(double *)a2;
  double v6 = *((double *)a2 + 1);
  if (!is_affine)
  {
    double v23 = *((double *)a2 + 2);
    double v24 = *((double *)a2 + 3);
    double v25 = *((double *)a2 + 4);
    double v26 = *((double *)a2 + 5);
    double v27 = *((double *)a2 + 6);
    double v28 = *((double *)a2 + 7);
    double v29 = *((double *)a2 + 8);
    double v30 = *((double *)a2 + 9);
    double v31 = *((double *)a2 + 10);
    double v32 = *((double *)a2 + 11);
    double v34 = *((double *)a2 + 12);
    double v33 = *((double *)a2 + 13);
    double v36 = *((double *)a2 + 14);
    double v35 = *((double *)a2 + 15);
    double v37 = -(v36 * v32 - v35 * v31);
    double v38 = -(v36 * v28 - v35 * v27);
    double v39 = -(v31 * v28 - v32 * v27);
    double v40 = v33 * v39 - (v38 * v30 - v37 * v26);
    double v41 = v39 * v34 - (v38 * v29 - v37 * v25);
    double v42 = -(v33 * v32 - v35 * v30);
    double v43 = -(v33 * v28 - v35 * v26);
    double v44 = -(v30 * v28 - v32 * v26);
    double v45 = v44 * v34 - (v43 * v29 - v42 * v25);
    double v46 = -(v33 * v31 - v36 * v30);
    double v47 = -(v33 * v27 - v36 * v26);
    double v48 = -(v30 * v27 - v31 * v26);
    double v49 = v34 * v48 - (v47 * v29 - v46 * v25);
    double v50 = v45 * v23 + v40 * v7 - (v49 * v24 + v41 * v6);
    if (v50 != 0.0)
    {
      double v52 = -(v26 * v23 - v27 * v6);
      double v65 = v29 * v52 + v48 * v7;
      double v53 = -(v26 * v24 - v28 * v6);
      double v64 = v53 * v29 + v44 * v7;
      double v54 = -(v30 * v23 - v31 * v6);
      double v55 = -(v30 * v24 - v32 * v6);
      double v56 = -(v31 * v24 - v32 * v23);
      double v57 = -(v27 * v24 - v28 * v23);
      double v58 = v57 * v29 + v39 * v7;
      double v59 = v30 * v57 + v39 * v6;
      double v60 = v34 * v52 + v47 * v7;
      double v61 = -(v33 * v23 - v36 * v6);
      double v62 = -(v36 * v24 - v35 * v23);
      double v63 = -(v33 * v24 - v35 * v6);
      *(double *)this = 1.0 / v50 * v40;
      *((double *)this + 1) = -(v33 * v56 + v37 * v6 - v62 * v30) * (1.0 / v50);
      *((double *)this + 2) = 1.0 / v50 * (v33 * v57 + v38 * v6 - v62 * v26);
      *((double *)this + 3) = -(v59 - v56 * v26) * (1.0 / v50);
      *((double *)this + 4) = -(1.0 / v50 * v41);
      *((double *)this + 5) = 1.0 / v50 * (v56 * v34 + v37 * v7 - v62 * v29);
      *((double *)this + 6) = -(v34 * v57 + v38 * v7 - v62 * v25) * (1.0 / v50);
      *((double *)this + 7) = 1.0 / v50 * (v58 - v56 * v25);
      *((double *)this + 8) = 1.0 / v50 * v45;
      *((double *)this + 9) = -(v55 * v34 + v42 * v7 - v63 * v29) * (1.0 / v50);
      *((double *)this + 10) = 1.0 / v50 * (v34 * v53 + v43 * v7 - v63 * v25);
      *((double *)this + 11) = -(v64 - v55 * v25) * (1.0 / v50);
      *((double *)this + 12) = -(1.0 / v50 * v49);
      *((double *)this + 13) = 1.0 / v50 * (v34 * v54 + v46 * v7 - v61 * v29);
      *((double *)this + 14) = -(v60 - v61 * v25) * (1.0 / v50);
      double v21 = 1.0 / v50 * (v65 - v54 * v25);
      uint64_t v22 = 15;
      goto LABEL_7;
    }
    return 0;
  }
  double v8 = *((double *)a2 + 4);
  double v9 = *((double *)a2 + 5);
  double v10 = -(v8 * v6 - v9 * v7);
  if (v10 == 0.0) {
    return 0;
  }
  double v11 = 1.0 / v10;
  double v13 = *((double *)a2 + 12);
  double v12 = *((double *)a2 + 13);
  long long v14 = *((_OWORD *)a2 + 1);
  long long v15 = *((_OWORD *)a2 + 2);
  long long v16 = *((_OWORD *)a2 + 3);
  *(_OWORD *)this = *(_OWORD *)a2;
  *((_OWORD *)this + 1) = v14;
  *((_OWORD *)this + 2) = v15;
  *((_OWORD *)this + 3) = v16;
  long long v17 = *((_OWORD *)a2 + 5);
  long long v18 = *((_OWORD *)a2 + 7);
  *((_OWORD *)this + 4) = *((_OWORD *)a2 + 4);
  *((_OWORD *)this + 5) = v17;
  *((_OWORD *)this + 7) = v18;
  double v19 = v11 * v9;
  *(double *)this = v19;
  *((double *)this + 1) = -(v11 * v6);
  double v20 = v11 * v7;
  *((double *)this + 4) = -(v11 * v8);
  *((double *)this + 5) = v20;
  *((double *)this + 12) = -(v13 * v19 - v11 * v8 * v12);
  double v21 = -(v12 * v20 - v11 * v6 * v13);
  uint64_t v22 = 13;
LABEL_7:
  *((double *)this + v22) = v21;
  return 1;
}

void CA::Render::LayerNode::MapPoints::unapply(uint64_t a1, float64x2_t *this, double *a3)
{
  if (*(void *)(a1 + 8))
  {
    uint64_t v5 = 0;
    unint64_t v6 = 0;
    do
    {
      CA::Mat4Impl::mat4_unapply_inverse_to_point2(this, (double *)(*(void *)(a1 + 16) + v5), a3);
      ++v6;
      v5 += 16;
    }
    while (v6 < *(void *)(a1 + 8));
  }
}

float64x2_t CA::Mat4Impl::mat4_unapply_inverse_to_point2(float64x2_t *this, double *a2, double *a3)
{
  double v3 = a2[1];
  double v4 = -(this[7].f64[0] + this[1].f64[0] * *a2 + this[3].f64[0] * v3) / this[5].f64[0];
  double v5 = this[7].f64[1] + this[1].f64[1] * *a2 + this[3].f64[1] * v3 + this[5].f64[1] * v4;
  if (fabs(v5 + -1.0) >= 0.000001)
  {
    if (v5 <= 0.0) {
      double v5 = INFINITY;
    }
    else {
      double v5 = 1.0 / v5;
    }
  }
  float64x2_t result = vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(this[6], *this, *a2), this[2], v3), this[4], v4), v5);
  *(float64x2_t *)a2 = result;
  return result;
}

float CA::Render::Layer::copy_properties(CA::Render::Layer *this, size_t size, int a3, __n128 a4)
{
  unint64_t v6 = this;
  v106[1] = *MEMORY[0x1E4F143B8];
  if ((a3 & 1) == 0)
  {
    this = (CA::Render::Layer *)CA::Render::Layer::set_contents(this, *(CA::Render::Object **)(size + 96));
    if ((*(unsigned char *)(size + 13) & 4) != 0) {
      *((_DWORD *)v6 + 3) |= 0x400u;
    }
  }
  if ((a3 & 4) == 0)
  {
    uint64_t v7 = *(void *)(size + 112);
    if (v7)
    {
      uint64_t v8 = *(void *)(v7 + 144);
      if (v8) {
        this = (CA::Render::Layer *)CA::Render::Layer::set_mask(v6, *(atomic_uint **)(v8 + 16));
      }
    }
    *((void *)v6 + 5) = *((void *)v6 + 5) & 0xFFFFFFFFFFFFFF7FLL | (((*(void *)(size + 40) >> 7) & 1) << 7);
  }
  if ((a3 & 2) == 0)
  {
    uint64_t v9 = *(void *)(size + 104);
    if ((*(unsigned char *)(size + 13) & 0x20) != 0)
    {
      if (v9)
      {
        uint64_t v14 = *(void *)(v9 + 144);
        if (v14)
        {
          uint64_t v15 = *(void *)(v14 + 16);
          if (v15)
          {
            long long v16 = (atomic_uint *)(v15 + 8);
            if (!atomic_fetch_add((atomic_uint *volatile)(v15 + 8), 1u))
            {
              uint64_t v15 = 0;
              atomic_fetch_add(v16, 0xFFFFFFFF);
            }
          }
        }
        else
        {
          uint64_t v15 = 0;
        }
        long long v17 = (atomic_uint *)*((void *)v6 + 13);
        if (v17 && atomic_fetch_add(v17 + 2, 0xFFFFFFFF) == 1) {
          (*(void (**)(atomic_uint *))(*(void *)v17 + 16))(v17);
        }
        *((void *)v6 + 13) = v15;
        *((_DWORD *)v6 + 3) |= 0x2000u;
      }
    }
    else if (v9)
    {
      uint64_t v10 = *(unsigned int *)(v9 + 16);
      if (!v10) {
        goto LABEL_30;
      }
      uint64_t v11 = 0;
      while (1)
      {
        uint64_t v12 = *(void *)(v9 + 24 + 8 * v11);
        if (v12)
        {
          uint64_t v13 = *(void *)(v12 + 144);
          if (!v13 || *(void *)(v13 + 16) != v12) {
            break;
          }
        }
        if (v10 == ++v11) {
          goto LABEL_30;
        }
      }
      if (v11 != v10)
      {
        if (v10 >= 0x201)
        {
          uint64_t v93 = (uint64_t *)malloc_type_malloc(8 * v10, 0x616586A5uLL);
          if (!v93) {
            goto LABEL_31;
          }
        }
        else
        {
          MEMORY[0x1F4188790](this);
          uint64_t v93 = (void *)((char *)v106 - ((v92 + 15) & 0xFFFFFFFF0));
          bzero(v93, v92);
        }
        unint64_t v94 = 0;
        uint64_t v95 = v9 + 24;
        uint64_t v96 = v10;
        do
        {
          if (*(void *)v95)
          {
            uint64_t v97 = *(void *)(*(void *)v95 + 144);
            if (v97)
            {
              uint64_t v98 = *(void *)(v97 + 16);
              if (v98) {
                v93[v94++] = v98;
              }
            }
          }
          v95 += 8;
          --v96;
        }
        while (v96);
        if (v94 < 2)
        {
          if (v94 == 1)
          {
            uint64_t v102 = *v93;
            if (*v93)
            {
              uint64_t v103 = (atomic_uint *)(v102 + 8);
              if (!atomic_fetch_add((atomic_uint *volatile)(v102 + 8), 1u))
              {
                uint64_t v102 = 0;
                atomic_fetch_add(v103, 0xFFFFFFFF);
              }
            }
          }
          else
          {
            uint64_t v102 = 0;
          }
          uint64_t v104 = (atomic_uint *)*((void *)v6 + 13);
          if (v104 && atomic_fetch_add(v104 + 2, 0xFFFFFFFF) == 1) {
            (*(void (**)(atomic_uint *))(*(void *)v104 + 16))(v104);
          }
          *((void *)v6 + 13) = v102;
          unsigned int v101 = *((_DWORD *)v6 + 3) | 0x2000;
        }
        else
        {
          float64x2_t v99 = CA::Render::Array::new_array((CA::Render::Array *)v94, v93, (CA::Render::Object *const *)1, 0);
          float64x2_t v100 = (atomic_uint *)*((void *)v6 + 13);
          if (v100 && atomic_fetch_add(v100 + 2, 0xFFFFFFFF) == 1) {
            (*(void (**)(atomic_uint *))(*(void *)v100 + 16))(v100);
          }
          *((void *)v6 + 13) = v99;
          unsigned int v101 = *((_DWORD *)v6 + 3) & 0xFFFFDFFF;
        }
        *((_DWORD *)v6 + 3) = v101;
        if (v10 >= 0x201) {
          free(v93);
        }
      }
      else
      {
LABEL_30:
        CA::Render::Layer::set_sublayers((uint64_t)v6, *(atomic_uint **)(size + 104));
      }
    }
  }
LABEL_31:
  if ((a3 & 8) == 0)
  {
    *((unsigned char *)v6 + 32) = *(unsigned char *)(size + 32);
    *((void *)v6 + 5) = *((void *)v6 + 5) & 0xFFFFFFFFFFFFFEFFLL | (((*(void *)(size + 40) >> 8) & 1) << 8);
    a4 = *(__n128 *)(size + 48);
    *((__n128 *)v6 + 3) = a4;
    uint64_t v18 = *(void *)(size + 128);
    if (v18)
    {
      double v19 = CA::Render::Layer::ensure_ext(v6);
      if (v19)
      {
        a4.n128_u64[0] = *(void *)(v18 + 192);
        v19[24] = a4.n128_u64[0];
      }
    }
  }
  if ((a3 & 0x10) == 0)
  {
    unsigned int v20 = *(unsigned __int8 *)(size + 34);
    *((unsigned char *)v6 + 34) = v20;
    unint64_t v21 = *((void *)v6 + 5) & 0xFFFFFFFFFFFFFFBFLL | (((*(void *)(size + 40) >> 6) & 1) << 6);
    *((void *)v6 + 5) = v21;
    unint64_t v22 = v21 & 0xFFFFFFFFFFFFFDFFLL | (((*(void *)(size + 40) >> 9) & 1) << 9);
    *((void *)v6 + 5) = v22;
    unint64_t v23 = v22 & 0xFFFFFFFFFFFFF7FFLL | (((*(void *)(size + 40) >> 11) & 1) << 11);
    *((void *)v6 + 5) = v23;
    unint64_t v24 = v23 & 0xFFFFFFFFFFFFEFFFLL | (((*(void *)(size + 40) >> 12) & 1) << 12);
    *((void *)v6 + 5) = v24;
    unint64_t v25 = v24 & 0xFFFFFFFFFFFFDFFFLL | (((*(void *)(size + 40) >> 13) & 1) << 13);
    *((void *)v6 + 5) = v25;
    unint64_t v26 = v25 & 0xFFFFFFFFFFFDFFFFLL | (((*(void *)(size + 40) >> 17) & 1) << 17);
    *((void *)v6 + 5) = v26;
    uint64_t v27 = *(void *)(size + 40) & 0x400000000000;
    *((void *)v6 + 5) = v26 & 0xFFFFBFFFFFFFFFFFLL | v27;
    *((_OWORD *)v6 + 4) = *(_OWORD *)(size + 64);
    a4 = *(__n128 *)(size + 80);
    *((__n128 *)v6 + 5) = a4;
    uint64_t v28 = *(void *)(size + 128);
    if (v28)
    {
      double v29 = CA::Render::Layer::ensure_ext(v6);
      if (!v29) {
        goto LABEL_44;
      }
      *(_OWORD *)(v29 + 21) = *(_OWORD *)(v28 + 168);
      v29[23] = *(void *)(v28 + 184);
      a4.n128_u32[0] = *(_DWORD *)(v28 + 284);
    }
    else
    {
      double v29 = (void *)*((void *)v6 + 16);
      if (!v29) {
        goto LABEL_44;
      }
      a4.n128_u64[0] = 0;
      if (!v27) {
        a4.n128_f64[0] = 0.5;
      }
      v29[21] = a4.n128_u64[0];
      v29[22] = a4.n128_u64[0];
      a4.n128_f32[0] = (float)v20;
    }
    *((_DWORD *)v29 + 71) = a4.n128_u32[0];
  }
LABEL_44:
  uint64_t v30 = *(void *)(size + 128);
  if (!v30) {
    goto LABEL_60;
  }
  if ((a3 & 0x20) != 0)
  {
    if ((a3 & 0x40) != 0) {
      goto LABEL_47;
    }
  }
  else
  {
    CA::Render::Layer::set_transform((uint64_t)v6, *(CA::Render::Vector **)(v30 + 16));
    if ((a3 & 0x40) != 0)
    {
LABEL_47:
      if ((a3 & 0x80) != 0) {
        goto LABEL_48;
      }
      goto LABEL_102;
    }
  }
  CA::Render::Layer::set_sublayer_transform((uint64_t)v6, *(CA::Render::Vector **)(v30 + 24));
  if ((a3 & 0x80) != 0)
  {
LABEL_48:
    if ((a3 & 0x100) != 0) {
      goto LABEL_49;
    }
    goto LABEL_103;
  }
LABEL_102:
  CA::Render::Layer::set_contents_transform((uint64_t)v6, *(CA::Render::Vector **)(v30 + 32));
  if ((a3 & 0x100) != 0)
  {
LABEL_49:
    if ((a3 & 0x20000) != 0) {
      goto LABEL_50;
    }
    goto LABEL_104;
  }
LABEL_103:
  CA::Render::Layer::set_contents_rect((uint64_t)v6, *(CA::Render::Vector **)(v30 + 40));
  if ((a3 & 0x20000) != 0)
  {
LABEL_50:
    if ((a3 & 0x80000) != 0) {
      goto LABEL_51;
    }
    goto LABEL_105;
  }
LABEL_104:
  CA::Render::Layer::set_contents_center((uint64_t)v6, *(CA::Render::Vector **)(v30 + 48));
  if ((a3 & 0x80000) != 0)
  {
LABEL_51:
    if ((a3 & 0x1000) != 0) {
      goto LABEL_52;
    }
    goto LABEL_106;
  }
LABEL_105:
  CA::Render::Layer::set_corner_contents((uint64_t)v6, *(CA::Render::Object **)(v30 + 56));
  CA::Render::Layer::set_corner_contents_center((uint64_t)v6, *(CA::Render::Vector **)(v30 + 64));
  if ((a3 & 0x1000) != 0)
  {
LABEL_52:
    if ((a3 & 0x200) != 0) {
      goto LABEL_53;
    }
    goto LABEL_107;
  }
LABEL_106:
  CA::Render::Layer::set_timing((uint64_t)v6, *(CA::Render::Timing **)(v30 + 8));
  if ((a3 & 0x200) != 0)
  {
LABEL_53:
    if ((a3 & 0x400) != 0) {
      goto LABEL_54;
    }
    goto LABEL_108;
  }
LABEL_107:
  CA::Render::Layer::set_filters((uint64_t)v6, *(void *)(v30 + 96));
  if ((a3 & 0x400) != 0)
  {
LABEL_54:
    if ((a3 & 0x800) != 0) {
      goto LABEL_55;
    }
    goto LABEL_109;
  }
LABEL_108:
  CA::Render::Layer::set_background_filters((uint64_t)v6, *(void *)(v30 + 104));
  if ((a3 & 0x800) != 0)
  {
LABEL_55:
    if ((a3 & 0x40000) != 0) {
      goto LABEL_56;
    }
    goto LABEL_110;
  }
LABEL_109:
  CA::Render::Layer::set_compositing_filter((uint64_t)v6, *(CA::Render::Filter **)(v30 + 88));
  if ((a3 & 0x40000) != 0)
  {
LABEL_56:
    if ((a3 & 0x10000) != 0) {
      goto LABEL_57;
    }
    goto LABEL_111;
  }
LABEL_110:
  CA::Render::Layer::set_mesh_transform((uint64_t)v6, *(os_unfair_lock_s **)(v30 + 112));
  if ((a3 & 0x10000) != 0)
  {
LABEL_57:
    if ((a3 & 0x4000) != 0) {
      goto LABEL_58;
    }
    goto LABEL_112;
  }
LABEL_111:
  CA::Render::Layer::set_subclass((uint64_t)v6, *(CA::Render::LayerSubclass **)v30);
  if ((a3 & 0x4000) != 0)
  {
LABEL_58:
    if ((a3 & 0x100000) != 0) {
      goto LABEL_60;
    }
    goto LABEL_59;
  }
LABEL_112:
  CA::Render::Layer::set_modifiers((uint64_t)v6, *(void *)(v30 + 136));
  if ((a3 & 0x100000) == 0) {
LABEL_59:
  }
    CA::Render::Layer::set_identifiers((uint64_t)v6, *(void *)(v30 + 144));
LABEL_60:
  if ((a3 & 0x8000) == 0)
  {
    double v31 = (atomic_uint *)*((void *)v6 + 15);
    double v32 = *(atomic_uint **)(size + 120);
    if (v31 != v32)
    {
      if (v31)
      {
        if (atomic_fetch_add(v31 + 2, 0xFFFFFFFF) == 1) {
          (*(void (**)(atomic_uint *))(*(void *)v31 + 16))(v31);
        }
        double v32 = *(atomic_uint **)(size + 120);
      }
      if (v32)
      {
        double v33 = v32 + 2;
        if (!atomic_fetch_add(v32 + 2, 1u))
        {
          double v32 = 0;
          atomic_fetch_add(v33, 0xFFFFFFFF);
        }
      }
      *((void *)v6 + 15) = v32;
    }
    a4 = *(__n128 *)(size + 16);
    *((__n128 *)v6 + 1) = a4;
    unsigned int v34 = *(unsigned __int8 *)(size + 35);
    *((unsigned char *)v6 + 35) = v34;
    unsigned int v35 = *((_DWORD *)v6 + 9) & 0xFFFFFFF0 | *(_DWORD *)(size + 36) & 0xF;
    *((_DWORD *)v6 + 9) = v35;
    unsigned int v36 = v35 & 0xFFFFFF0F | (16 * ((*(_DWORD *)(size + 36) >> 4) & 0xF));
    *((_DWORD *)v6 + 9) = v36;
    unsigned int v37 = v36 & 0xFFFFF0FF | (((*(_DWORD *)(size + 36) >> 8) & 0xF) << 8);
    *((_DWORD *)v6 + 9) = v37;
    unint64_t v38 = *((void *)v6 + 5) & 0xFFFFFFFFFFFFBFFFLL | (((*(void *)(size + 40) >> 14) & 1) << 14);
    *((void *)v6 + 5) = v38;
    unint64_t v39 = v38 & 0xFFFFFFFFFFFEFFFFLL | (((*(void *)(size + 40) >> 16) & 1) << 16);
    *((void *)v6 + 5) = v39;
    unsigned int v40 = v37 & 0xFFFF0FFF | (HIBYTE(*(_WORD *)(size + 36)) >> 4 << 12);
    *((_DWORD *)v6 + 9) = v40;
    unsigned int v41 = v40 & 0xFFF0FFFF | ((HIWORD(*(_DWORD *)(size + 36)) & 0xF) << 16);
    *((_DWORD *)v6 + 9) = v41;
    *((_DWORD *)v6 + 9) = v41 & 0x800FFFFF | (((*(_DWORD *)(size + 36) >> 20) & 0x7FF) << 20);
    unint64_t v42 = v39 & 0xFFFFFFFFFFFFFFFCLL | *(void *)(size + 40) & 3;
    *((void *)v6 + 5) = v42;
    unint64_t v43 = v42 & 0xFFFFFFFFFFFFFFF3 | (4 * ((*(void *)(size + 40) >> 2) & 3));
    *((void *)v6 + 5) = v43;
    unint64_t v44 = v43 & 0xFFFFFFFFFFFFFBFFLL | (((*(void *)(size + 40) >> 10) & 1) << 10);
    *((void *)v6 + 5) = v44;
    unint64_t v45 = v44 & 0xFFFFFFFFFFFF7FFFLL | (((*(void *)(size + 40) >> 15) & 1) << 15);
    *((void *)v6 + 5) = v45;
    unint64_t v46 = v45 & 0xFFFFFFFFFFFBFFFFLL | (((*(void *)(size + 40) >> 18) & 1) << 18);
    *((void *)v6 + 5) = v46;
    unint64_t v47 = v46 & 0xFFFFFFFFFFF7FFFFLL | (((*(void *)(size + 40) >> 19) & 1) << 19);
    *((void *)v6 + 5) = v47;
    unint64_t v48 = v47 & 0xFFFFFFFFFFEFFFFFLL | (((*(void *)(size + 40) >> 20) & 1) << 20);
    *((void *)v6 + 5) = v48;
    unint64_t v49 = v48 & 0xFFFFFFFFFFDFFFFFLL | (((*(void *)(size + 40) >> 21) & 1) << 21);
    *((void *)v6 + 5) = v49;
    unint64_t v50 = v49 & 0xFFFFFFFFFFBFFFFFLL | (((*(void *)(size + 40) >> 22) & 1) << 22);
    *((void *)v6 + 5) = v50;
    unint64_t v51 = v50 & 0xFFFFFFFFFF7FFFFFLL | (((*(void *)(size + 40) >> 23) & 1) << 23);
    *((void *)v6 + 5) = v51;
    unint64_t v52 = v51 & 0xFFFFFFFFFEFFFFFFLL | (((*(void *)(size + 40) >> 24) & 1) << 24);
    *((void *)v6 + 5) = v52;
    unint64_t v53 = v52 & 0xFFFFFFFFFDFFFFFFLL | (((*(void *)(size + 40) >> 25) & 1) << 25);
    *((void *)v6 + 5) = v53;
    unint64_t v54 = v53 & 0xFFFFFFFFFBFFFFFFLL | (((*(void *)(size + 40) >> 26) & 1) << 26);
    *((void *)v6 + 5) = v54;
    unint64_t v55 = v54 & 0xFFFFFFFFF7FFFFFFLL | (((*(void *)(size + 40) >> 27) & 1) << 27);
    *((void *)v6 + 5) = v55;
    unint64_t v56 = v55 & 0xFFFFFFFFEFFFFFFFLL | (((*(void *)(size + 40) >> 28) & 1) << 28);
    *((void *)v6 + 5) = v56;
    unint64_t v57 = v56 & 0xFFFFFFFFDFFFFFFFLL | (((*(void *)(size + 40) >> 29) & 1) << 29);
    *((void *)v6 + 5) = v57;
    unint64_t v58 = v57 & 0xFFFFFFFFBFFFFFFFLL | (((*(void *)(size + 40) >> 30) & 1) << 30);
    *((void *)v6 + 5) = v58;
    unint64_t v59 = v58 & 0xFFFFFFFF7FFFFFFFLL | (((*(void *)(size + 40) >> 31) & 1) << 31);
    *((void *)v6 + 5) = v59;
    unint64_t v60 = v59 & 0xFFFFFFFEFFFFFFFFLL | ((HIDWORD(*(void *)(size + 40)) & 1) << 32);
    *((void *)v6 + 5) = v60;
    unint64_t v61 = v60 & 0xFFFFFF7FFFFFFFFFLL | (((*(void *)(size + 40) >> 39) & 1) << 39);
    *((void *)v6 + 5) = v61;
    unint64_t v62 = v61 & 0xFFFFFEFFFFFFFFFFLL | (((*(void *)(size + 40) >> 40) & 1) << 40);
    *((void *)v6 + 5) = v62;
    unint64_t v63 = v62 & 0xFFFFFDFFFFFFFFFFLL | (((*(void *)(size + 40) >> 41) & 1) << 41);
    *((void *)v6 + 5) = v63;
    unint64_t v64 = v63 & 0xFFFFFBFFFFFFFFFFLL | (((*(void *)(size + 40) >> 42) & 1) << 42);
    *((void *)v6 + 5) = v64;
    unint64_t v65 = v64 & 0xFFFFF7FFFFFFFFFFLL | (((*(void *)(size + 40) >> 43) & 1) << 43);
    *((void *)v6 + 5) = v65;
    unint64_t v66 = v65 & 0xFFFFEFFFFFFFFFFFLL | (((*(void *)(size + 40) >> 44) & 1) << 44);
    *((void *)v6 + 5) = v66;
    unint64_t v67 = v66 & 0xFFFFDFFFFFFFFFFFLL | (((*(void *)(size + 40) >> 45) & 1) << 45);
    *((void *)v6 + 5) = v67;
    *((void *)v6 + 5) = v67 & 0xFFFFFFFFFFFFFFCFLL | (16 * ((*(void *)(size + 40) >> 4) & 3));
    uint64_t v68 = *(void *)(size + 128);
    if (v68)
    {
      uint64_t v69 = CA::Render::Layer::ensure_ext(v6);
      if (v69)
      {
        uint64_t v70 = v69;
        *(_OWORD *)(v69 + 19) = *(_OWORD *)(v68 + 152);
        uint64_t v71 = (atomic_uint *)v69[10];
        long long v72 = *(atomic_uint **)(v68 + 80);
        if (v71 != v72)
        {
          if (v71)
          {
            if (atomic_fetch_add(v71 + 2, 0xFFFFFFFF) == 1) {
              (*(void (**)(atomic_uint *))(*(void *)v71 + 16))(v71);
            }
            long long v72 = *(atomic_uint **)(v68 + 80);
          }
          if (v72)
          {
            uint64_t v73 = v72 + 2;
            if (!atomic_fetch_add(v72 + 2, 1u))
            {
              long long v72 = 0;
              atomic_fetch_add(v73, 0xFFFFFFFF);
            }
          }
          v70[10] = v72;
        }
        *((_DWORD *)v70 + 74) = *(_DWORD *)(v68 + 296);
        v70[36] = *(void *)(v68 + 288);
        *((_OWORD *)v70 + 15) = *(_OWORD *)(v68 + 240);
        float64x2_t v74 = (atomic_uint *)v70[16];
        unsigned int v75 = *(atomic_uint **)(v68 + 128);
        if (v74 != v75)
        {
          if (v74)
          {
            if (atomic_fetch_add(v74 + 2, 0xFFFFFFFF) == 1) {
              (*(void (**)(atomic_uint *))(*(void *)v74 + 16))(v74);
            }
            unsigned int v75 = *(atomic_uint **)(v68 + 128);
          }
          if (v75)
          {
            float64x2_t v76 = v75 + 2;
            if (!atomic_fetch_add(v75 + 2, 1u))
            {
              unsigned int v75 = 0;
              atomic_fetch_add(v76, 0xFFFFFFFF);
            }
          }
          v70[16] = v75;
        }
        v70[29] = *(void *)(v68 + 232);
        uint64_t v77 = (atomic_uint *)v70[9];
        uint64_t v78 = *(atomic_uint **)(v68 + 72);
        if (v77 != v78)
        {
          if (v77)
          {
            if (atomic_fetch_add(v77 + 2, 0xFFFFFFFF) == 1) {
              (*(void (**)(atomic_uint *))(*(void *)v77 + 16))(v77);
            }
            uint64_t v78 = *(atomic_uint **)(v68 + 72);
          }
          if (v78)
          {
            float64x2x2_t v79 = v78 + 2;
            if (!atomic_fetch_add(v78 + 2, 1u))
            {
              uint64_t v78 = 0;
              atomic_fetch_add(v79, 0xFFFFFFFF);
            }
          }
          v70[9] = v78;
        }
        *((_DWORD *)v70 + 57) = *(_DWORD *)(v68 + 228);
        v70[32] = *(void *)(v68 + 256);
        *((_DWORD *)v70 + 66) = *(_DWORD *)(v68 + 264);
        a4 = *(__n128 *)(v68 + 268);
        *(__n128 *)((char *)v70 + 268) = a4;
        *((unsigned char *)v70 + 324) = *((unsigned char *)v70 + 324) & 0xFE | *(unsigned char *)(v68 + 324) & 1;
      }
    }
    else
    {
      uint64_t v80 = *((void *)v6 + 16);
      if (v80)
      {
        a4.n128_f32[0] = (float)v34;
        *(float *)(v80 + 288) = (float)v34;
      }
    }
  }
  if ((a3 & 0x2000) == 0)
  {
    *((unsigned char *)v6 + 33) = *(unsigned char *)(size + 33);
    unint64_t v81 = *((void *)v6 + 5) & 0xFFFFFFFDFFFFFFFFLL | (((*(void *)(size + 40) >> 33) & 1) << 33);
    *((void *)v6 + 5) = v81;
    unint64_t v82 = v81 & 0xFFFFFFFBFFFFFFFFLL | (((*(void *)(size + 40) >> 34) & 1) << 34);
    *((void *)v6 + 5) = v82;
    unint64_t v83 = v82 & 0xFFFFFFF7FFFFFFFFLL | (((*(void *)(size + 40) >> 35) & 1) << 35);
    *((void *)v6 + 5) = v83;
    unint64_t v84 = v83 & 0xFFFFFFEFFFFFFFFFLL | (((*(void *)(size + 40) >> 36) & 1) << 36);
    *((void *)v6 + 5) = v84;
    unint64_t v85 = v84 & 0xFFFFFFDFFFFFFFFFLL | (((*(void *)(size + 40) >> 37) & 1) << 37);
    *((void *)v6 + 5) = v85;
    *((void *)v6 + 5) = v85 & 0xFFFFFFBFFFFFFFFFLL | (((*(void *)(size + 40) >> 38) & 1) << 38);
    uint64_t v86 = *(void *)(size + 128);
    if (v86)
    {
      float v87 = CA::Render::Layer::ensure_ext(v6);
      if (v87)
      {
        float v88 = v87;
        *(_OWORD *)(v87 + 25) = *(_OWORD *)(v86 + 200);
        v87[27] = *(void *)(v86 + 216);
        *((_DWORD *)v87 + 56) = *(_DWORD *)(v86 + 224);
        long long v89 = (atomic_uint *)v87[15];
        double v90 = *(atomic_uint **)(v86 + 120);
        if (v89 != v90)
        {
          if (v89)
          {
            if (atomic_fetch_add(v89 + 2, 0xFFFFFFFF) == 1) {
              (*(void (**)(atomic_uint *))(*(void *)v89 + 16))(v89);
            }
            double v90 = *(atomic_uint **)(v86 + 120);
          }
          if (v90)
          {
            unsigned int v91 = v90 + 2;
            if (!atomic_fetch_add(v90 + 2, 1u))
            {
              double v90 = 0;
              atomic_fetch_add(v91, 0xFFFFFFFF);
            }
          }
          v88[15] = v90;
        }
        *((_OWORD *)v88 + 19) = *(_OWORD *)(v86 + 304);
        *((_DWORD *)v88 + 75) = *(_DWORD *)(v86 + 300);
        a4.n128_u32[0] = *(_DWORD *)(v86 + 320);
        *((_DWORD *)v88 + 80) = a4.n128_u32[0];
      }
    }
  }
  return a4.n128_f32[0];
}

void *CA::Render::Layer::ensure_ext(CA::Render::Layer *this)
{
  BOOL v2 = (void *)*((void *)this + 16);
  if (!v2)
  {
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    uint64_t v7 = (char *)malloc_type_zone_malloc(malloc_zone, 0x150uLL, 0x8BB15036uLL);
    if (v7)
    {
      double v5 = v7;
      *((void *)v7 + 20) = 0;
      *((_OWORD *)v7 + 8) = 0u;
      *((_OWORD *)v7 + 9) = 0u;
      *((_OWORD *)v7 + 6) = 0u;
      *((_OWORD *)v7 + 7) = 0u;
      *((_OWORD *)v7 + 4) = 0u;
      *((_OWORD *)v7 + 5) = 0u;
      *((_OWORD *)v7 + 2) = 0u;
      *((_OWORD *)v7 + 3) = 0u;
      *(_OWORD *)uint64_t v7 = 0u;
      *((_OWORD *)v7 + 1) = 0u;
      double v8 = 0.0;
      if ((*((void *)this + 5) & 0x400000000000) == 0) {
        double v8 = 0.5;
      }
      *((double *)v7 + 21) = v8;
      *((double *)v7 + 22) = v8;
      *((void *)v7 + 24) = 0;
      *((void *)v7 + 25) = 0;
      *((void *)v7 + 23) = 0;
      *((_DWORD *)v7 + 52) = 0;
      *(_OWORD *)(v7 + 212) = xmmword_184997EC0;
      *(void *)(v7 + 228) = 0;
      *(void *)(v7 + 244) = 0;
      *(void *)(v7 + 236) = 0;
      *(_OWORD *)(v7 + 252) = xmmword_184997ED0;
      __asm { FMOV            V0.4S, #1.0 }
      *(_OWORD *)(v7 + 268) = _Q0;
      LOBYTE(_Q0) = *((unsigned char *)this + 34);
      *(float *)&_Q0 = (float)_Q0;
      *((_DWORD *)v7 + 71) = _Q0;
      LOBYTE(_Q0) = *((unsigned char *)this + 35);
      *((float *)v7 + 72) = (float)_Q0;
      *(void *)(v7 + 292) = 0x3F80000000000000;
      *(void *)(v7 + 308) = 0;
      *(void *)(v7 + 300) = 0;
      *(void *)(v7 + 316) = 1065353216;
      v7[324] &= ~1u;
      goto LABEL_64;
    }
LABEL_10:
    BOOL v2 = 0;
    goto LABEL_65;
  }
  if (*((_DWORD *)v2 + 82) == 1) {
    return v2;
  }
  double v3 = (malloc_zone_t *)get_malloc_zone();
  double v4 = (char *)malloc_type_zone_malloc(v3, 0x150uLL, 0x8BB15036uLL);
  if (!v4) {
    goto LABEL_10;
  }
  double v5 = v4;
  if (*v2) {
    (*(void (**)(void))(*(void *)*v2 + 96))(*v2);
  }
  else {
    *(void *)double v4 = 0;
  }
  uint64_t v14 = v2[1];
  if (v14)
  {
    uint64_t v15 = (atomic_uint *)(v14 + 8);
    if (!atomic_fetch_add((atomic_uint *volatile)(v14 + 8), 1u))
    {
      uint64_t v14 = 0;
      atomic_fetch_add(v15, 0xFFFFFFFF);
    }
  }
  *((void *)v5 + 1) = v14;
  uint64_t v16 = v2[2];
  if (v16)
  {
    long long v17 = (atomic_uint *)(v16 + 8);
    if (!atomic_fetch_add((atomic_uint *volatile)(v16 + 8), 1u))
    {
      uint64_t v16 = 0;
      atomic_fetch_add(v17, 0xFFFFFFFF);
    }
  }
  *((void *)v5 + 2) = v16;
  uint64_t v18 = v2[3];
  if (v18)
  {
    double v19 = (atomic_uint *)(v18 + 8);
    if (!atomic_fetch_add((atomic_uint *volatile)(v18 + 8), 1u))
    {
      uint64_t v18 = 0;
      atomic_fetch_add(v19, 0xFFFFFFFF);
    }
  }
  *((void *)v5 + 3) = v18;
  uint64_t v20 = v2[4];
  if (v20)
  {
    unint64_t v21 = (atomic_uint *)(v20 + 8);
    if (!atomic_fetch_add((atomic_uint *volatile)(v20 + 8), 1u))
    {
      uint64_t v20 = 0;
      atomic_fetch_add(v21, 0xFFFFFFFF);
    }
  }
  *((void *)v5 + 4) = v20;
  uint64_t v22 = v2[5];
  if (v22)
  {
    unint64_t v23 = (atomic_uint *)(v22 + 8);
    if (!atomic_fetch_add((atomic_uint *volatile)(v22 + 8), 1u))
    {
      uint64_t v22 = 0;
      atomic_fetch_add(v23, 0xFFFFFFFF);
    }
  }
  *((void *)v5 + 5) = v22;
  uint64_t v24 = v2[6];
  if (v24)
  {
    unint64_t v25 = (atomic_uint *)(v24 + 8);
    if (!atomic_fetch_add((atomic_uint *volatile)(v24 + 8), 1u))
    {
      uint64_t v24 = 0;
      atomic_fetch_add(v25, 0xFFFFFFFF);
    }
  }
  *((void *)v5 + 6) = v24;
  uint64_t v26 = v2[7];
  if (v26)
  {
    uint64_t v27 = (atomic_uint *)(v26 + 8);
    if (!atomic_fetch_add((atomic_uint *volatile)(v26 + 8), 1u))
    {
      uint64_t v26 = 0;
      atomic_fetch_add(v27, 0xFFFFFFFF);
    }
  }
  *((void *)v5 + 7) = v26;
  uint64_t v28 = v2[8];
  if (v28)
  {
    double v29 = (atomic_uint *)(v28 + 8);
    if (!atomic_fetch_add((atomic_uint *volatile)(v28 + 8), 1u))
    {
      uint64_t v28 = 0;
      atomic_fetch_add(v29, 0xFFFFFFFF);
    }
  }
  *((void *)v5 + 8) = v28;
  uint64_t v30 = v2[9];
  if (v30)
  {
    double v31 = (atomic_uint *)(v30 + 8);
    if (!atomic_fetch_add((atomic_uint *volatile)(v30 + 8), 1u))
    {
      uint64_t v30 = 0;
      atomic_fetch_add(v31, 0xFFFFFFFF);
    }
  }
  *((void *)v5 + 9) = v30;
  uint64_t v32 = v2[10];
  if (v32)
  {
    double v33 = (atomic_uint *)(v32 + 8);
    if (!atomic_fetch_add((atomic_uint *volatile)(v32 + 8), 1u))
    {
      uint64_t v32 = 0;
      atomic_fetch_add(v33, 0xFFFFFFFF);
    }
  }
  *((void *)v5 + 10) = v32;
  uint64_t v34 = v2[11];
  if (v34)
  {
    unsigned int v35 = (atomic_uint *)(v34 + 8);
    if (!atomic_fetch_add((atomic_uint *volatile)(v34 + 8), 1u))
    {
      uint64_t v34 = 0;
      atomic_fetch_add(v35, 0xFFFFFFFF);
    }
  }
  *((void *)v5 + 11) = v34;
  uint64_t v36 = v2[12];
  if (v36)
  {
    unsigned int v37 = (atomic_uint *)(v36 + 8);
    if (!atomic_fetch_add((atomic_uint *volatile)(v36 + 8), 1u))
    {
      uint64_t v36 = 0;
      atomic_fetch_add(v37, 0xFFFFFFFF);
    }
  }
  *((void *)v5 + 12) = v36;
  uint64_t v38 = v2[13];
  if (v38)
  {
    unint64_t v39 = (atomic_uint *)(v38 + 8);
    if (!atomic_fetch_add((atomic_uint *volatile)(v38 + 8), 1u))
    {
      uint64_t v38 = 0;
      atomic_fetch_add(v39, 0xFFFFFFFF);
    }
  }
  *((void *)v5 + 13) = v38;
  uint64_t v40 = v2[14];
  if (v40)
  {
    unsigned int v41 = (atomic_uint *)(v40 + 8);
    if (!atomic_fetch_add((atomic_uint *volatile)(v40 + 8), 1u))
    {
      uint64_t v40 = 0;
      atomic_fetch_add(v41, 0xFFFFFFFF);
    }
  }
  *((void *)v5 + 14) = v40;
  uint64_t v42 = v2[15];
  if (v42)
  {
    unint64_t v43 = (atomic_uint *)(v42 + 8);
    if (!atomic_fetch_add((atomic_uint *volatile)(v42 + 8), 1u))
    {
      uint64_t v42 = 0;
      atomic_fetch_add(v43, 0xFFFFFFFF);
    }
  }
  *((void *)v5 + 15) = v42;
  uint64_t v44 = v2[16];
  if (v44)
  {
    unint64_t v45 = (atomic_uint *)(v44 + 8);
    if (!atomic_fetch_add((atomic_uint *volatile)(v44 + 8), 1u))
    {
      uint64_t v44 = 0;
      atomic_fetch_add(v45, 0xFFFFFFFF);
    }
  }
  *((void *)v5 + 16) = v44;
  uint64_t v46 = v2[17];
  if (v46)
  {
    unint64_t v47 = (atomic_uint *)(v46 + 8);
    if (!atomic_fetch_add((atomic_uint *volatile)(v46 + 8), 1u))
    {
      uint64_t v46 = 0;
      atomic_fetch_add(v47, 0xFFFFFFFF);
    }
  }
  *((void *)v5 + 17) = v46;
  *((void *)v5 + 18) = 0;
  *(_OWORD *)(v5 + 152) = *(_OWORD *)(v2 + 19);
  *(_OWORD *)(v5 + 168) = *(_OWORD *)(v2 + 21);
  *(_OWORD *)(v5 + 184) = *(_OWORD *)(v2 + 23);
  *(_OWORD *)(v5 + 200) = *(_OWORD *)(v2 + 25);
  *((void *)v5 + 27) = v2[27];
  *((_OWORD *)v5 + 14) = *((_OWORD *)v2 + 14);
  *((_OWORD *)v5 + 15) = *((_OWORD *)v2 + 15);
  *((void *)v5 + 32) = v2[32];
  *((_DWORD *)v5 + 66) = *((_DWORD *)v2 + 66);
  *(_OWORD *)(v5 + 268) = *(_OWORD *)((char *)v2 + 268);
  *(_OWORD *)(v5 + 284) = *(_OWORD *)((char *)v2 + 284);
  *((_DWORD *)v5 + 75) = *((_DWORD *)v2 + 75);
  *((_OWORD *)v5 + 19) = *((_OWORD *)v2 + 19);
  *((_DWORD *)v5 + 80) = *((_DWORD *)v2 + 80);
  v5[324] = v5[324] & 0xFE | *((unsigned char *)v2 + 324) & 1;
LABEL_64:
  *((_DWORD *)v5 + 82) = 1;
  BOOL v2 = v5;
LABEL_65:
  unint64_t v48 = (CA::Render::Layer::Ext *)*((void *)this + 16);
  *((void *)this + 16) = v2;
  if (v48) {
    CA::Render::Layer::Ext::unref(v48);
  }
  return v2;
}

atomic_uint *CA::Render::Layer::set_contents(CA::Render::Layer *this, CA::Render::Object *a2)
{
  if (a2)
  {
    uint64_t v3 = 0;
    int v4 = *((unsigned __int8 *)a2 + 12);
    do
    {
      int v5 = CA::Render::contents_types[v3];
      if (v5 == v4) {
        break;
      }
    }
    while (v3++ != 10);
    if (v5 == v4) {
      uint64_t v7 = a2;
    }
    else {
      uint64_t v7 = 0;
    }
  }
  else
  {
    uint64_t v7 = 0;
  }
  float64x2_t result = (atomic_uint *)*((void *)this + 12);
  if (result != (atomic_uint *)v7)
  {
    if (result && atomic_fetch_add(result + 2, 0xFFFFFFFF) == 1) {
      float64x2_t result = (atomic_uint *)(*(uint64_t (**)(atomic_uint *))(*(void *)result + 16))(result);
    }
    if (v7)
    {
      uint64_t v9 = (atomic_uint *)((char *)v7 + 8);
      if (!atomic_fetch_add((atomic_uint *volatile)v7 + 2, 1u))
      {
        uint64_t v7 = 0;
        atomic_fetch_add(v9, 0xFFFFFFFF);
      }
    }
    *((void *)this + 12) = v7;
  }
  return result;
}

double CA::Mat4Impl::mat4_set_corner_matrix(uint64_t a1, double *a2, double *a3, double *a4)
{
  double v4 = a2[2];
  double v5 = a2[3];
  double v7 = a2[4];
  double v6 = a2[5];
  double v8 = a2[6];
  double v9 = a2[7];
  double v11 = *a2;
  double v10 = a2[1];
  double v12 = v7 - (v4 + v8) + *a2;
  double v13 = v6 - (v5 + v9) + v10;
  if (fabs(v12) >= 0.000001 || fabs(v13) >= 0.000001)
  {
    double v20 = v8 - v7;
    double v21 = v5 - v6;
    double v22 = v4 - v7;
    double v23 = -(v20 * (v5 - v6) - (v9 - v6) * v22);
    double v18 = -(v13 * v20 - v12 * (v9 - v6)) / v23;
    double v19 = -(v12 * v21 - v13 * v22) / v23;
    double v14 = v4 - v11 + v18 * v4;
    double v16 = v5 - v10 + v18 * v5;
    double v15 = v8 - v11 + v19 * v8;
    double v17 = v9 - v10 + v19 * v9;
  }
  else
  {
    double v14 = v4 - v11;
    double v15 = v7 - v4;
    double v16 = v5 - v10;
    double v17 = v6 - v5;
    double v18 = 0.0;
    double v19 = 0.0;
  }
  *(double *)a1 = v14 / *a3;
  *(double *)(a1 + 8) = v16 / *a3;
  *(void *)(a1 + 16) = 0;
  *(double *)(a1 + 24) = v18 / *a3;
  *(double *)(a1 + 32) = v15 / a3[1];
  *(double *)(a1 + 40) = v17 / a3[1];
  *(void *)(a1 + 48) = 0;
  *(double *)(a1 + 56) = v19 / a3[1];
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(_OWORD *)(a1 + 80) = xmmword_184997D50;
  *(double *)(a1 + 96) = v11;
  *(double *)(a1 + 104) = v10;
  *(_OWORD *)(a1 + 112) = xmmword_184997D60;
  *(double *)(a1 + 96) = v11 + *a4 * v14 + a4[1] * v15;
  *(double *)(a1 + 104) = v10 + *a4 * v16 + a4[1] * v17;
  double result = *a4 * v18 + 1.0 + a4[1] * v19;
  *(double *)(a1 + 120) = result;
  return result;
}

uint64_t CA::Render::Layer::set_modifiers(uint64_t result, uint64_t a2)
{
  uint64_t v2 = a2;
  if (a2 || *(void *)(result + 128))
  {
    uint64_t v3 = CA::Render::Layer::ensure_ext((CA::Render::Layer *)result);
    double result = v3[17];
    if (result != v2)
    {
      if (result && atomic_fetch_add((atomic_uint *volatile)(result + 8), 0xFFFFFFFF) == 1) {
        double result = (*(uint64_t (**)(uint64_t))(*(void *)result + 16))(result);
      }
      if (v2)
      {
        double v4 = (atomic_uint *)(v2 + 8);
        if (!atomic_fetch_add((atomic_uint *volatile)(v2 + 8), 1u))
        {
          uint64_t v2 = 0;
          atomic_fetch_add(v4, 0xFFFFFFFF);
        }
      }
      v3[17] = v2;
    }
  }
  return result;
}

uint64_t CA::Render::Layer::set_transform(uint64_t this, CA::Render::Vector *a2)
{
  uint64_t v2 = a2;
  if (a2 || *(void *)(this + 128))
  {
    uint64_t v3 = CA::Render::Layer::ensure_ext((CA::Render::Layer *)this);
    this = v3[2];
    if ((CA::Render::Vector *)this != v2)
    {
      if (this && atomic_fetch_add((atomic_uint *volatile)(this + 8), 0xFFFFFFFF) == 1) {
        this = (*(uint64_t (**)(uint64_t))(*(void *)this + 16))(this);
      }
      if (v2)
      {
        double v4 = (atomic_uint *)((char *)v2 + 8);
        if (!atomic_fetch_add((atomic_uint *volatile)v2 + 2, 1u))
        {
          uint64_t v2 = 0;
          atomic_fetch_add(v4, 0xFFFFFFFF);
        }
      }
      v3[2] = v2;
    }
  }
  return this;
}

_DWORD *CA::Render::BackdropLayer::copy@<X0>(CA::Render::BackdropLayer *this@<X0>, void *a2@<X8>)
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  double result = malloc_type_zone_calloc(malloc_zone, 1uLL, 0x60uLL, 0x743898A5uLL);
  if (result)
  {
    result[2] = 1;
    result[3] = 3;
    ++dword_1EB2ADDD4;
    *(void *)double result = &unk_1ED02D828;
    uint64_t v6 = *((void *)this + 3);
    *((void *)result + 2) = *((void *)this + 2);
    if (v6)
    {
      double v7 = (atomic_uint *)(v6 + 8);
      if (!atomic_fetch_add((atomic_uint *volatile)(v6 + 8), 1u))
      {
        uint64_t v6 = 0;
        atomic_fetch_add(v7, 0xFFFFFFFF);
      }
    }
    *((void *)result + 3) = v6;
    *((void *)result + 4) = *((void *)this + 4);
    result[10] = *((_DWORD *)this + 10);
    *((_OWORD *)result + 3) = *((_OWORD *)this + 3);
    *((_OWORD *)result + 4) = *((_OWORD *)this + 4);
    *((unsigned char *)result + 80) = *((unsigned char *)this + 80);
    uint64_t v8 = *((void *)this + 11);
    if (v8)
    {
      double v9 = (atomic_uint *)(v8 + 8);
      if (!atomic_fetch_add((atomic_uint *volatile)(v8 + 8), 1u))
      {
        uint64_t v8 = 0;
        atomic_fetch_add(v9, 0xFFFFFFFF);
      }
    }
    *((void *)result + 11) = v8;
    result[3] |= *((_DWORD *)this + 3) & 0xFFFFFF00;
  }
  *a2 = result;
  return result;
}

uint64_t CA::Render::Layer::set_identifiers(uint64_t result, uint64_t a2)
{
  uint64_t v2 = a2;
  if (a2 || *(void *)(result + 128))
  {
    uint64_t v3 = CA::Render::Layer::ensure_ext((CA::Render::Layer *)result);
    double result = v3[18];
    if (result != v2)
    {
      if (result && atomic_fetch_add((atomic_uint *volatile)(result + 8), 0xFFFFFFFF) == 1) {
        double result = (*(uint64_t (**)(uint64_t))(*(void *)result + 16))(result);
      }
      if (v2)
      {
        double v4 = (atomic_uint *)(v2 + 8);
        if (!atomic_fetch_add((atomic_uint *volatile)(v2 + 8), 1u))
        {
          uint64_t v2 = 0;
          atomic_fetch_add(v4, 0xFFFFFFFF);
        }
      }
      v3[18] = v2;
    }
  }
  return result;
}

uint64_t CA::Render::Layer::set_background_filters(uint64_t result, uint64_t a2)
{
  uint64_t v2 = a2;
  if (a2 || *(void *)(result + 128))
  {
    uint64_t v3 = CA::Render::Layer::ensure_ext((CA::Render::Layer *)result);
    double result = v3[13];
    if (result != v2)
    {
      if (result && atomic_fetch_add((atomic_uint *volatile)(result + 8), 0xFFFFFFFF) == 1) {
        double result = (*(uint64_t (**)(uint64_t))(*(void *)result + 16))(result);
      }
      if (v2)
      {
        double v4 = (atomic_uint *)(v2 + 8);
        if (!atomic_fetch_add((atomic_uint *volatile)(v2 + 8), 1u))
        {
          uint64_t v2 = 0;
          atomic_fetch_add(v4, 0xFFFFFFFF);
        }
      }
      v3[13] = v2;
    }
  }
  return result;
}

uint64_t CA::Render::Layer::set_corner_contents_center(uint64_t this, CA::Render::Vector *a2)
{
  uint64_t v2 = a2;
  if (a2 || *(void *)(this + 128))
  {
    uint64_t v3 = CA::Render::Layer::ensure_ext((CA::Render::Layer *)this);
    this = v3[8];
    if ((CA::Render::Vector *)this != v2)
    {
      if (this && atomic_fetch_add((atomic_uint *volatile)(this + 8), 0xFFFFFFFF) == 1) {
        this = (*(uint64_t (**)(uint64_t))(*(void *)this + 16))(this);
      }
      if (v2)
      {
        double v4 = (atomic_uint *)((char *)v2 + 8);
        if (!atomic_fetch_add((atomic_uint *volatile)v2 + 2, 1u))
        {
          uint64_t v2 = 0;
          atomic_fetch_add(v4, 0xFFFFFFFF);
        }
      }
      v3[8] = v2;
    }
  }
  return this;
}

double *CA::Render::set_rect_property(double *this, Rect *a2, int *a3, const unsigned int *a4, unint64_t a5, double *a6, const double *a7)
{
  int v7 = *a3;
  if (a2 == 1)
  {
    if (a5 >= 2 && v7 == 416)
    {
      double v8 = *a6;
      if (a4)
      {
        double v9 = this[1];
        *this = *this + v8;
        double v10 = v9 + a6[1];
      }
      else
      {
        *this = v8;
        double v10 = a6[1];
      }
      this[1] = v10;
    }
    else if (a5 >= 2 && v7 == 513)
    {
      double v14 = *a6;
      if (a4)
      {
        double v15 = this[3];
        this[2] = this[2] + v14;
        double v16 = v15 + a6[1];
      }
      else
      {
        this[2] = v14;
        double v16 = a6[1];
      }
      this[3] = v16;
    }
  }
  else if (v7 == 513)
  {
    double v17 = this[2];
    double v18 = this[3];
    if (a2 == 2)
    {
      int v19 = a3[1];
      if (a5 && v19 == 604)
      {
        if (!a4) {
          double v17 = -0.0;
        }
        double v17 = *a6 + v17;
      }
      else if (a5 && v19 == 256)
      {
        if (!a4) {
          double v18 = -0.0;
        }
        double v18 = *a6 + v18;
      }
    }
    this[2] = v17;
    this[3] = v18;
  }
  else if (v7 == 416)
  {
    double v11 = *this;
    double v12 = this[1];
    if (a2 == 2)
    {
      int v13 = a3[1];
      if (a5 && v13 == 607)
      {
        if (!a4) {
          double v11 = -0.0;
        }
        double v11 = *a6 + v11;
      }
      else if (a5 && v13 == 611)
      {
        if (!a4) {
          double v12 = -0.0;
        }
        double v12 = *a6 + v12;
      }
    }
    *this = v11;
    this[1] = v12;
  }
  return this;
}

double CA::Render::LayerNode::MapTransform::unapply(uint64_t a1, const double *a2, uint64_t a3, const double *a4)
{
  *(void *)&double result = *(_OWORD *)&CA::Mat4Impl::mat4_concat((float64x2_t *)*(void *)(a1 + 8), (double *)*(void *)(a1 + 8), a2, a4);
  return result;
}

_DWORD *CA::Render::SecureIndicatorLayer::copy@<X0>(CA::Render::SecureIndicatorLayer *this@<X0>, void *a2@<X8>)
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  double result = malloc_type_zone_calloc(malloc_zone, 1uLL, 0x18uLL, 0x743898A5uLL);
  if (result)
  {
    result[2] = 1;
    result[3] = 45;
    ++dword_1EB2ADE7C;
    *(void *)double result = &unk_1ED02EDA0;
    result[4] = *((_DWORD *)this + 4);
    *((_WORD *)result + 10) = *((_WORD *)this + 10);
  }
  *a2 = result;
  return result;
}

char *CA::Render::ShapeLayer::copy@<X0>(CA::Render::ShapeLayer *this@<X0>, void *a2@<X8>)
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  double result = (char *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x98uLL, 0x743898A5uLL);
  if (result)
  {
    *((_DWORD *)result + 2) = 1;
    *((_DWORD *)result + 3) = 46;
    ++dword_1EB2ADE80;
    *(void *)double result = &unk_1ED02CCD8;
    uint64_t v6 = *((void *)this + 2);
    if (v6)
    {
      int v7 = (atomic_uint *)(v6 + 8);
      if (!atomic_fetch_add((atomic_uint *volatile)(v6 + 8), 1u))
      {
        uint64_t v6 = 0;
        atomic_fetch_add(v7, 0xFFFFFFFF);
      }
    }
    *((void *)result + 2) = v6;
    *(_OWORD *)(result + 24) = *(_OWORD *)((char *)this + 24);
    uint64_t v8 = *((void *)this + 5);
    if (v8)
    {
      double v9 = (atomic_uint *)(v8 + 8);
      if (!atomic_fetch_add((atomic_uint *volatile)(v8 + 8), 1u))
      {
        uint64_t v8 = 0;
        atomic_fetch_add(v9, 0xFFFFFFFF);
      }
    }
    *((void *)result + 5) = v8;
    *((_OWORD *)result + 3) = *((_OWORD *)this + 3);
    uint64_t v10 = *((void *)this + 8);
    if (v10)
    {
      double v11 = (atomic_uint *)(v10 + 8);
      if (!atomic_fetch_add((atomic_uint *volatile)(v10 + 8), 1u))
      {
        uint64_t v10 = 0;
        atomic_fetch_add(v11, 0xFFFFFFFF);
      }
    }
    *((void *)result + 8) = v10;
    *(_OWORD *)(result + 72) = *(_OWORD *)((char *)this + 72);
    *(_OWORD *)(result + 88) = *(_OWORD *)((char *)this + 88);
    *((void *)result + 13) = *((void *)this + 13);
    uint64_t v12 = *((void *)this + 14);
    if (v12)
    {
      int v13 = (atomic_uint *)(v12 + 8);
      if (!atomic_fetch_add((atomic_uint *volatile)(v12 + 8), 1u))
      {
        uint64_t v12 = 0;
        atomic_fetch_add(v13, 0xFFFFFFFF);
      }
    }
    *((void *)result + 14) = v12;
    unsigned int v14 = *((_DWORD *)result + 30) & 0xFFFFFF00 | *((unsigned __int8 *)this + 120);
    *((_DWORD *)result + 30) = v14;
    unsigned int v15 = v14 & 0xFFFF00FF | (*((unsigned __int8 *)this + 121) << 8);
    *((_DWORD *)result + 30) = v15;
    *((_DWORD *)result + 30) = v15 & 0xFF00FFFF | (*((unsigned __int8 *)this + 122) << 16);
    double v16 = this;
    if (!atomic_fetch_add((atomic_uint *volatile)this + 2, 1u))
    {
      double v16 = 0;
      atomic_fetch_add((atomic_uint *volatile)this + 2, 0xFFFFFFFF);
    }
    *((void *)result + 16) = v16;
    uint64_t v17 = *((void *)this + 17);
    if (v17)
    {
      double v18 = (atomic_uint *)(v17 + 8);
      if (!atomic_fetch_add((atomic_uint *volatile)(v17 + 8), 1u))
      {
        uint64_t v17 = 0;
        atomic_fetch_add(v18, 0xFFFFFFFF);
      }
    }
    *((void *)result + 17) = v17;
    *((void *)result + 18) = *((void *)this + 18);
  }
  *a2 = result;
  return result;
}

float64x2_t CA::Render::ShapeLayer::set_property(CA::Render::ShapeLayer *this, unint64_t a2, const unsigned int *a3, BOOL a4, unint64_t a5, const double *a6)
{
  int v6 = *a3;
  if (*(int *)a3 <= 391)
  {
    if (v6 == 222)
    {
      if (a5 >= 4)
      {
        float64x2_t result = *(float64x2_t *)(a6 + 2);
        *(float32x4_t *)((char *)this + 24) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)a6), result);
      }
    }
    else
    {
      if (v6 == 356)
      {
        if (!a5) {
          return result;
        }
        *((double *)this + 13) = *a6;
        goto LABEL_17;
      }
      if (v6 == 358 && a5 != 0)
      {
        *((double *)this + 11) = *a6;
        goto LABEL_17;
      }
    }
  }
  else
  {
    if (v6 <= 542)
    {
      if (v6 != 392)
      {
        if (v6 == 542 && a5 >= 4)
        {
          float64x2_t result = *(float64x2_t *)(a6 + 2);
          *((float32x4_t *)this + 3) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)a6), result);
        }
        return result;
      }
      if (!a5) {
        return result;
      }
      *((double *)this + 12) = *a6;
LABEL_17:
      CA::Render::ShapeLayer::invalidate_stroke_path(this);
      return result;
    }
    if (v6 == 543)
    {
      if (!a5) {
        return result;
      }
      *((double *)this + 10) = *a6;
      goto LABEL_17;
    }
    if (v6 == 544 && a5 != 0)
    {
      *((double *)this + 9) = *a6;
      goto LABEL_17;
    }
  }
  return result;
}

atomic_uint *CA::Render::ReplicatorLayer::set_property(atomic_uint *this, uint64_t a2, const unsigned int *a3, const double *a4, unint64_t a5, const double *a6, const double *a7)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    int v7 = this;
    if (a2 == 1)
    {
      uint64_t v8 = 0;
      switch(*a3)
      {
        case 0x143u:
          uint64_t v8 = 8;
          goto LABEL_18;
        case 0x144u:
          uint64_t v8 = 7;
          goto LABEL_18;
        case 0x145u:
          if (a5 >= 4) {
            *(float32x4_t *)(this + 9) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)a6), *(float64x2_t *)(a6 + 2));
          }
          return this;
        case 0x146u:
          if (a5) {
            this[4] = (int)(floor(*a6) + 0.5);
          }
          return this;
        case 0x147u:
          goto LABEL_18;
        case 0x148u:
          uint64_t v8 = 6;
          goto LABEL_18;
        case 0x149u:
          uint64_t v8 = 5;
LABEL_18:
          if (a5)
          {
            *(float *)&atomic_uint v11 = *a6;
            this[v8 + 8] = v11;
          }
          break;
        case 0x14Au:
          if (a5 >= 0x10)
          {
            memset(v14, 0, sizeof(v14));
            if (a4)
            {
              uint64_t v12 = *((void *)this + 3);
              if (v12)
              {
                CA::Mat4Impl::mat4_concat(v14, (double *)(v12 + 24), a6, a4);
                a6 = (const double *)v14;
              }
            }
            int v13 = CA::Render::Vector::new_vector((CA::Render::Vector *)0x10, a6, (const double *)a3);
            this = (atomic_uint *)*((void *)v7 + 3);
            *((void *)v7 + 3) = v13;
            if (this && atomic_fetch_add(this + 2, 0xFFFFFFFF) == 1) {
              this = (atomic_uint *)(*(uint64_t (**)(atomic_uint *))(*(void *)this + 16))(this);
            }
          }
          break;
        default:
          return this;
      }
    }
    else if (*a3 == 330)
    {
      double v9 = CA::Render::set_transform_property(*((CA::Render **)this + 3), (CA::Render::Vector *)(a2 - 1), (int *)a3 + 1, (const unsigned int *)a4, a5, (uint64_t)a6, a7);
      this = (atomic_uint *)*((void *)v7 + 3);
      *((void *)v7 + 3) = v9;
      if (this)
      {
        if (atomic_fetch_add(this + 2, 0xFFFFFFFF) == 1)
        {
          uint64_t v10 = *(uint64_t (**)(void))(*(void *)this + 16);
          return (atomic_uint *)v10();
        }
      }
    }
  }
  return this;
}

_DWORD *CA::Render::ReplicatorLayer::copy@<X0>(CA::Render::ReplicatorLayer *this@<X0>, void *a2@<X8>)
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  float64x2_t result = malloc_type_zone_calloc(malloc_zone, 1uLL, 0x48uLL, 0x743898A5uLL);
  if (result)
  {
    result[2] = 1;
    result[3] = 44;
    ++dword_1EB2ADE78;
    *(void *)float64x2_t result = &unk_1ED02E208;
    result[4] = *((_DWORD *)this + 4);
    uint64_t v6 = *((void *)this + 3);
    if (v6)
    {
      int v7 = (atomic_uint *)(v6 + 8);
      if (!atomic_fetch_add((atomic_uint *volatile)(v6 + 8), 1u))
      {
        uint64_t v6 = 0;
        atomic_fetch_add(v7, 0xFFFFFFFF);
      }
    }
    uint64_t v8 = 0;
    *((void *)result + 3) = v6;
    result[3] |= *((_DWORD *)this + 3) & 0xFFFFFF00;
    do
    {
      result[v8 + 8] = *(_DWORD *)((char *)this + v8 * 4 + 32);
      ++v8;
    }
    while (v8 != 9);
  }
  *a2 = result;
  return result;
}

char *CA::Render::PortalLayer::copy@<X0>(CA::Render::PortalLayer *this@<X0>, void *a2@<X8>)
{
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  float64x2_t result = (char *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x40uLL, 0x743898A5uLL);
  if (result)
  {
    *((_DWORD *)result + 2) = 1;
    *((_DWORD *)result + 3) = 40;
    ++dword_1EB2ADE68;
    *(void *)float64x2_t result = &unk_1ED02D0D0;
    *(_OWORD *)(result + 24) = *(_OWORD *)((char *)this + 24);
    *((_DWORD *)result + 10) = *((_DWORD *)this + 10);
    uint64_t v6 = *((void *)this + 6);
    if (v6)
    {
      int v7 = (atomic_uint *)(v6 + 8);
      if (!atomic_fetch_add((atomic_uint *volatile)(v6 + 8), 1u))
      {
        uint64_t v6 = 0;
        atomic_fetch_add(v7, 0xFFFFFFFF);
      }
    }
    *((void *)result + 6) = v6;
    uint64_t v8 = *((void *)this + 7);
    if (v8)
    {
      double v9 = (atomic_uint *)(v8 + 8);
      if (!atomic_fetch_add((atomic_uint *volatile)(v8 + 8), 1u))
      {
        uint64_t v8 = 0;
        atomic_fetch_add(v9, 0xFFFFFFFF);
      }
    }
    *((void *)result + 7) = v8;
    *((_DWORD *)result + 3) |= *((_DWORD *)this + 3) & 0xFFFFFF00;
  }
  *a2 = result;
  return result;
}

unint64_t *CA::Render::Layer::set_background_color(uint64_t a1, float a2, float a3, float a4, float a5)
{
  *(float *)(a1 + 16) = a2;
  *(float *)(a1 + 20) = a3;
  *(float *)(a1 + 24) = a4;
  *(float *)(a1 + 28) = a5;
  if (a4 != 0.0 || a2 != 0.0 || a3 != 0.0)
  {
    uint64_t v9 = *(void *)(a1 + 40);
    float64x2_t result = (unint64_t *)(a1 + 40);
    uint64_t v6 = v9;
    goto LABEL_7;
  }
  uint64_t v7 = *(void *)(a1 + 40);
  float64x2_t result = (unint64_t *)(a1 + 40);
  uint64_t v6 = v7;
  if (a5 != 0.0)
  {
LABEL_7:
    uint64_t v8 = 0x40000000000;
    goto LABEL_8;
  }
  uint64_t v8 = 0;
LABEL_8:
  *float64x2_t result = v8 | v6 & 0xFFFFFBFFFFFFFFFFLL;
  return result;
}

void CA::Render::GradientLayer::set_property(CA::Render::GradientLayer *this, uint64_t a2, const unsigned int *a3, BOOL a4, unint64_t a5, const double *a6)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  int v11 = *a3;
  if (*(int *)a3 > 364)
  {
    if (v11 != 365)
    {
      if (v11 != 536) {
        goto LABEL_65;
      }
      goto LABEL_7;
    }
LABEL_14:
    if (a2 == 2)
    {
      uint64_t v23 = a3[1];
      if ((v23 & 0x40000000) == 0) {
        goto LABEL_55;
      }
      unint64_t v24 = v23 & 0xFFFFFFFFBFFFFFFFLL;
      if (*((void *)this + 4) <= (v23 & 0xFFFFFFFFBFFFFFFFLL)) {
        goto LABEL_55;
      }
      if (a5 < 4 || v11 != 110)
      {
        if (v11 == 365 && a5 && *((void *)this + 7))
        {
          float v27 = *a6;
          CA::Render::InterpolatedFunction::set_location((uint64_t)this + 16, v24, v27);
        }
        goto LABEL_55;
      }
      if ((CARequiresColorMatching(*((CGColorSpace **)this + 17), *((CGColorSpace **)this + 16), 0) & 1) == 0)
      {
        CA::Render::Gradient::set_color((uint64_t)this + 16, v24, a6);
        goto LABEL_55;
      }
      if (CARetainColorTransform(*((CGColorSpace **)this + 16)))
      {
        float64x2_t v51 = 0u;
        float64x2_t v52 = 0u;
        CA::Render::convert_color((uint64_t)a6, (uint64_t)&v51);
        uint64_t v25 = *((void *)this + 6);
        if (v25)
        {
          if (*((void *)this + 4) > v24)
          {
            uint64_t v26 = (float32x4_t *)(v25 + 16 * v24);
            *uint64_t v26 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v51), v52);
            if (v26->f32[3] < 1.0) {
              *((_DWORD *)this + 7) &= ~0x800u;
            }
          }
        }
        goto LABEL_42;
      }
    }
    else if (a2 == 1)
    {
      if (v11 == 365)
      {
        if (*((void *)this + 7) && *((void *)this + 4) <= a5) {
          CA::Render::InterpolatedFunction::set_locations((uint64_t)this + 16, a6);
        }
        goto LABEL_55;
      }
      if (a5 >= 4 * *((void *)this + 4))
      {
        if ((CARequiresColorMatching(*((CGColorSpace **)this + 17), *((CGColorSpace **)this + 16), 0) & 1) == 0)
        {
          CA::Render::Gradient::set_colors((uint64_t)this + 16, a6);
          goto LABEL_55;
        }
        if (CARetainColorTransform(*((CGColorSpace **)this + 16)))
        {
          if (*((void *)this + 4))
          {
            unint64_t v15 = 0;
            double v16 = (float64_t *)(a6 + 3);
            uint64_t v17 = 12;
            do
            {
              float64x2_t v18 = *(float64x2_t *)(v16 - 1);
              float64x2_t v51 = *(float64x2_t *)(v16 - 3);
              float64x2_t v52 = v18;
              CGColorTransformConvertColorComponents();
              uint64_t v19 = *((void *)this + 6);
              unint64_t v20 = *((void *)this + 4);
              if (v19)
              {
                if (v20 > v15)
                {
                  v21.f64[0] = 0.0;
                  v21.f64[1] = *v16;
                  *(float32x4_t *)(v19 + 16 * v15) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64((float64x2_t)0), v21);
                  if (*(float *)(v19 + v17) < 1.0) {
                    *((_DWORD *)this + 7) &= ~0x800u;
                  }
                }
              }
              ++v15;
              v17 += 16;
              v16 += 4;
            }
            while (v15 < v20);
          }
LABEL_42:
          CGColorTransformRelease();
        }
      }
    }
LABEL_55:
    if ((*((unsigned char *)this + 13) & 8) == 0)
    {
      uint64_t v28 = (atomic_uint *)*((void *)this + 14);
      if (v28)
      {
        if (atomic_fetch_add(v28 + 2, 0xFFFFFFFF) == 1) {
          (*(void (**)(atomic_uint *))(*(void *)v28 + 16))(v28);
        }
        *((void *)this + 14) = 0;
      }
      double v29 = (atomic_uint *)*((void *)this + 15);
      if (v29)
      {
        if (atomic_fetch_add(v29 + 2, 0xFFFFFFFF) == 1) {
          (*(void (**)(atomic_uint *))(*(void *)v29 + 16))(v29);
        }
        *((void *)this + 15) = 0;
      }
    }
    int v11 = *a3;
    goto LABEL_65;
  }
  if (v11 == 110) {
    goto LABEL_14;
  }
  if (v11 != 215)
  {
LABEL_65:
    if (v11 == 331)
    {
      if (a2 == 2)
      {
        if (a5 >= 4)
        {
          uint64_t v42 = a3[1];
          if ((v42 & 0x40000000) != 0)
          {
            uint64_t v43 = *((void *)this + 4);
            _CF = v43 != 0;
            unint64_t v44 = v43 - 1;
            if (_CF)
            {
              unint64_t v45 = v42 & 0xFFFFFFFFBFFFFFFFLL;
              if (v44 > (v42 & 0xFFFFFFFFBFFFFFFFLL))
              {
                *((_DWORD *)this + 7) |= 0x400u;
                CA::Render::InterpolatedFunction::allocate_storage((CA::Render::GradientLayer *)((char *)this + 16));
                uint64_t v46 = *((void *)this + 8);
                if (v46)
                {
                  long long v47 = *((_OWORD *)a6 + 1);
                  unint64_t v48 = (_OWORD *)(v46 + 32 * v45);
                  _OWORD *v48 = *(_OWORD *)a6;
                  v48[1] = v47;
                }
              }
            }
          }
        }
      }
      else if (a2 == 1)
      {
        *((_DWORD *)this + 7) |= 0x400u;
        uint64_t v30 = *((void *)this + 4);
        CA::Render::InterpolatedFunction::allocate_storage((CA::Render::GradientLayer *)((char *)this + 16));
        double v31 = (void *)*((void *)this + 8);
        if (v31)
        {
          unint64_t v32 = v30 - 1 >= a5 >> 2 ? a5 >> 2 : v30 - 1;
          memcpy(v31, a6, 32 * v32);
          uint64_t v33 = *((void *)this + 4);
          if (v32 < v33 - 1)
          {
            uint64_t v34 = ~v32 + v33;
            unsigned int v35 = (_OWORD *)(*((void *)this + 8) + 32 * v32 + 16);
            __asm { FMOV            V0.2D, #1.0 }
            do
            {
              *((void *)v35 - 2) = 0;
              *((void *)v35 - 1) = 0;
              *unsigned int v35 = _Q0;
              v35 += 2;
              --v34;
            }
            while (v34);
          }
        }
      }
      if ((*((unsigned char *)this + 13) & 8) == 0)
      {
        unint64_t v49 = (atomic_uint *)*((void *)this + 14);
        if (v49)
        {
          if (atomic_fetch_add(v49 + 2, 0xFFFFFFFF) == 1) {
            (*(void (**)(atomic_uint *))(*(void *)v49 + 16))(v49);
          }
          *((void *)this + 14) = 0;
        }
        unint64_t v50 = (atomic_uint *)*((void *)this + 15);
        if (v50)
        {
          if (atomic_fetch_add(v50 + 2, 0xFFFFFFFF) == 1) {
            (*(void (**)(atomic_uint *))(*(void *)v50 + 16))(v50);
          }
          *((void *)this + 15) = 0;
        }
      }
    }
    else if (a5 && v11 == 402)
    {
      float v41 = *a6;
      *((float *)this + 27) = v41;
    }
    return;
  }
LABEL_7:
  uint64_t v12 = 72;
  if (v11 == 536)
  {
    int v13 = (char *)this + 72;
  }
  else
  {
    uint64_t v12 = 88;
    int v13 = (char *)this + 88;
  }
  if (a2 == 1 && a5 >= 2)
  {
    *(double *)((char *)this + v12) = *a6;
    uint64_t v14 = *((void *)a6 + 1);
LABEL_13:
    *((void *)v13 + 1) = v14;
    return;
  }
  if (a2 != 2) {
    return;
  }
  unsigned int v22 = a3[1];
  if (a5 && v22 == 607)
  {
    *(double *)((char *)this + v12) = *a6;
    return;
  }
  if (a5 && v22 == 611)
  {
    uint64_t v14 = *(void *)a6;
    goto LABEL_13;
  }
}

atomic_uint *CA::Render::Layer::set_affine_matrix(atomic_uint *result, int a2, unint64_t a3, float64x2_t *a4)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (a3 >= 6)
  {
    uint64_t v6 = CA::Render::Layer::ensure_ext((CA::Render::Layer *)result);
    uint64_t v8 = v6;
    float64x2_t v10 = *a4;
    float64x2_t v9 = a4[1];
    float64x2_t v11 = a4[2];
    if (a2)
    {
      uint64_t v12 = v6[4];
      if (v12)
      {
        unsigned int v13 = *(_DWORD *)(v12 + 16);
        uint64_t v14 = (float64x2_t *)(v12 + 24);
        unint64_t v15 = (float64x2_t *)(v12 + 40);
        double v16 = (float64x2_t *)(v12 + 56);
        BOOL v17 = v13 >= 6;
        if (v13 < 6) {
          double v16 = (float64x2_t *)(MEMORY[0x1E4F1DAB8] + 32);
        }
        float64x2_t v18 = (float64x2_t *)(MEMORY[0x1E4F1DAB8] + 16);
        if (v17) {
          float64x2_t v18 = v15;
        }
        if (!v17) {
          uint64_t v14 = (float64x2_t *)MEMORY[0x1E4F1DAB8];
        }
        float64x2_t v11 = vmlaq_laneq_f64(vmlaq_n_f64(*v16, *v14, v11.f64[0]), *v18, v11, 1);
        float64x2_t v9 = vmlaq_laneq_f64(vmulq_n_f64(*v14, v9.f64[0]), *v18, v9, 1);
        float64x2_t v10 = vmlaq_laneq_f64(vmulq_n_f64(*v14, v10.f64[0]), *v18, v10, 1);
      }
    }
    v20[0] = v10;
    v20[1] = v9;
    v20[2] = v11;
    uint64_t v19 = CA::Render::Vector::new_vector((CA::Render::Vector *)6, v20, v7);
    float64x2_t result = (atomic_uint *)v8[4];
    v8[4] = v19;
    if (result)
    {
      if (atomic_fetch_add(result + 2, 0xFFFFFFFF) == 1) {
        return (atomic_uint *)(*(uint64_t (**)(atomic_uint *))(*(void *)result + 16))(result);
      }
    }
  }
  return result;
}

uint64_t CA::Render::Layer::set_timing(uint64_t this, CA::Render::Timing *a2)
{
  uint64_t v2 = a2;
  if (a2 || *(void *)(this + 128))
  {
    uint64_t v3 = CA::Render::Layer::ensure_ext((CA::Render::Layer *)this);
    this = v3[1];
    if ((CA::Render::Timing *)this != v2)
    {
      if (this && atomic_fetch_add((atomic_uint *volatile)(this + 8), 0xFFFFFFFF) == 1) {
        this = (*(uint64_t (**)(uint64_t))(*(void *)this + 16))(this);
      }
      if (v2)
      {
        double v4 = (atomic_uint *)((char *)v2 + 8);
        if (!atomic_fetch_add((atomic_uint *volatile)v2 + 2, 1u))
        {
          uint64_t v2 = 0;
          atomic_fetch_add(v4, 0xFFFFFFFF);
        }
      }
      v3[1] = v2;
    }
  }
  return this;
}

uint64_t CA::Render::Layer::set_compositing_filter(uint64_t this, CA::Render::Filter *a2)
{
  uint64_t v2 = a2;
  if (a2 || *(void *)(this + 128))
  {
    uint64_t v3 = CA::Render::Layer::ensure_ext((CA::Render::Layer *)this);
    this = v3[11];
    if ((CA::Render::Filter *)this != v2)
    {
      if (this && atomic_fetch_add((atomic_uint *volatile)(this + 8), 0xFFFFFFFF) == 1) {
        this = (*(uint64_t (**)(uint64_t))(*(void *)this + 16))(this);
      }
      if (v2)
      {
        double v4 = (atomic_uint *)((char *)v2 + 8);
        if (!atomic_fetch_add((atomic_uint *volatile)v2 + 2, 1u))
        {
          uint64_t v2 = 0;
          atomic_fetch_add(v4, 0xFFFFFFFF);
        }
      }
      v3[11] = v2;
    }
  }
  return this;
}

uint64_t CA::Render::Layer::set_contents_transform(uint64_t this, CA::Render::Vector *a2)
{
  uint64_t v2 = a2;
  if (a2 || *(void *)(this + 128))
  {
    uint64_t v3 = CA::Render::Layer::ensure_ext((CA::Render::Layer *)this);
    this = v3[4];
    if ((CA::Render::Vector *)this != v2)
    {
      if (this && atomic_fetch_add((atomic_uint *volatile)(this + 8), 0xFFFFFFFF) == 1) {
        this = (*(uint64_t (**)(uint64_t))(*(void *)this + 16))(this);
      }
      if (v2)
      {
        double v4 = (atomic_uint *)((char *)v2 + 8);
        if (!atomic_fetch_add((atomic_uint *volatile)v2 + 2, 1u))
        {
          uint64_t v2 = 0;
          atomic_fetch_add(v4, 0xFFFFFFFF);
        }
      }
      v3[4] = v2;
    }
  }
  return this;
}

uint64_t CA::Render::Layer::set_corner_contents(uint64_t this, CA::Render::Object *a2)
{
  uint64_t v2 = a2;
  if (a2 || *(void *)(this + 128))
  {
    uint64_t v3 = CA::Render::Layer::ensure_ext((CA::Render::Layer *)this);
    this = v3[7];
    if ((CA::Render::Object *)this != v2)
    {
      if (this && atomic_fetch_add((atomic_uint *volatile)(this + 8), 0xFFFFFFFF) == 1) {
        this = (*(uint64_t (**)(uint64_t))(*(void *)this + 16))(this);
      }
      if (v2)
      {
        double v4 = (atomic_uint *)((char *)v2 + 8);
        if (!atomic_fetch_add((atomic_uint *volatile)v2 + 2, 1u))
        {
          uint64_t v2 = 0;
          atomic_fetch_add(v4, 0xFFFFFFFF);
        }
      }
      v3[7] = v2;
    }
  }
  return this;
}

uint64_t CA::Render::Layer::set_sublayer_transform(uint64_t this, CA::Render::Vector *a2)
{
  uint64_t v2 = a2;
  if (a2 || *(void *)(this + 128))
  {
    uint64_t v3 = CA::Render::Layer::ensure_ext((CA::Render::Layer *)this);
    this = v3[3];
    if ((CA::Render::Vector *)this != v2)
    {
      if (this && atomic_fetch_add((atomic_uint *volatile)(this + 8), 0xFFFFFFFF) == 1) {
        this = (*(uint64_t (**)(uint64_t))(*(void *)this + 16))(this);
      }
      if (v2)
      {
        double v4 = (atomic_uint *)((char *)v2 + 8);
        if (!atomic_fetch_add((atomic_uint *volatile)v2 + 2, 1u))
        {
          uint64_t v2 = 0;
          atomic_fetch_add(v4, 0xFFFFFFFF);
        }
      }
      _OWORD v3[3] = v2;
    }
  }
  return this;
}

uint64_t CA::Render::Layer::set_contents_center(uint64_t this, CA::Render::Vector *a2)
{
  uint64_t v2 = a2;
  if (a2 || *(void *)(this + 128))
  {
    uint64_t v3 = CA::Render::Layer::ensure_ext((CA::Render::Layer *)this);
    this = v3[6];
    if ((CA::Render::Vector *)this != v2)
    {
      if (this && atomic_fetch_add((atomic_uint *volatile)(this + 8), 0xFFFFFFFF) == 1) {
        this = (*(uint64_t (**)(uint64_t))(*(void *)this + 16))(this);
      }
      if (v2)
      {
        double v4 = (atomic_uint *)((char *)v2 + 8);
        if (!atomic_fetch_add((atomic_uint *volatile)v2 + 2, 1u))
        {
          uint64_t v2 = 0;
          atomic_fetch_add(v4, 0xFFFFFFFF);
        }
      }
      v3[6] = v2;
    }
  }
  return this;
}

uint64_t ___ZN4CAML12_GLOBAL__N_112set_propertyEPNS_7ContextEPNS_5StateE_block_invoke()
{
  uint64_t result = CAInternAtomWithCString("delegate");
  return result;
}

void sub_1846D14D0(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t CA::Layer::style_value(CA::Layer *this, unsigned int a2, objc_object **a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if ((*((unsigned char *)this + 57) & 1) == 0) {
    return 0;
  }
  id v11 = 0;
  uint64_t v5 = *((void *)this + 9);
  if (!v5 || (CA::AttrList::get(v5, 545, (const CGAffineTransform *)1, (CA::Mat4Impl *)&v11) & 1) == 0)
  {
    uint64_t v6 = (objc_class *)objc_opt_class();
    CAObject_defaultValueForAtom(v6, 545, (const CGAffineTransform *)1, (uint64_t)&v11);
  }
  if (!v11) {
    return 0;
  }
  String = CAAtomGetString(a2);
  uint64_t result = (uint64_t)v11;
  if (v11)
  {
    while (1)
    {
      uint64_t v9 = objc_msgSend((id)result, "objectForKey:", String, v11, v12);
      if (v9) {
        break;
      }
      uint64_t result = [v11 objectForKey:@"style"];
      id v11 = (id)result;
      if (!result) {
        return result;
      }
    }
    if (v9 == *MEMORY[0x1E4F1D260]) {
      float64x2_t v10 = 0;
    }
    else {
      float64x2_t v10 = (objc_object *)v9;
    }
    *a3 = v10;
    return 1;
  }
  return result;
}

void sub_1846D1754(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

void CA::Layer::set_commit_needed(CA::Layer *this, CA::Transaction *a2, int a3)
{
  if ((*((_DWORD *)this + 1) & 0x60000) == 0)
  {
    int v6 = *((_DWORD *)a2 + 25);
    *((_DWORD *)a2 + 25) = v6 + 1;
    if (!v6) {
      os_unfair_lock_lock((os_unfair_lock_t)&CA::Transaction::transaction_lock);
    }
    if (a3) {
      int v7 = 1032;
    }
    else {
      int v7 = 8;
    }
    *((_DWORD *)this + 10) |= a3 & 0xFFFFFFFE;
    CA::Layer::mark(this, a2, v7, 16);
    CA::Transaction::unlock(a2);
  }
}

void sub_1846D1B70(_Unwind_Exception *a1)
{
  CA::Transaction::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t classDescription_locked(objc_class *a1)
{
  uint64_t v148 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  v141[0] = 0;
  uint64_t v2 = x_hash_table_lookup(class_table, (uint64_t)a1, v141);
  if (v141[0]) {
    return v2;
  }
  Class v138 = a1;
  double v4 = (objc_class *)[(objc_class *)a1 superclass];
  uint64_t v5 = a1;
  if (v4 == a1) {
    return 0;
  }
  if (log_class_descriptions)
  {
    if (x_log_hook_p())
    {
      float v130 = [NSStringFromClass(a1) UTF8String];
      x_log_();
    }
    else
    {
      int v7 = x_log_category_api;
      if (os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v8 = [NSStringFromClass(v5) UTF8String];
        LODWORD(v141[0]) = 136315138;
        *(void *)((char *)v141 + 4) = v8;
        _os_log_impl(&dword_184668000, v7, OS_LOG_TYPE_DEFAULT, "creating class description for %s\n", (uint8_t *)v141, 0xCu);
      }
    }
  }
  float v139 = malloc_type_malloc(0x90uLL, 0x10F0040449965B5uLL);
  v139[1] = v138;
  uint64_t v9 = classDescription_locked(v4);
  float64x2_t v10 = v139;
  *float v139 = v9;
  *((_OWORD *)v10 + 1) = 0u;
  float v134 = (void **)(v10 + 2);
  *((_OWORD *)v10 + 2) = 0u;
  *((_OWORD *)v10 + 3) = 0u;
  *((_OWORD *)v10 + 4) = 0u;
  *((_OWORD *)v10 + 5) = 0u;
  *((_OWORD *)v10 + 6) = 0u;
  *((_OWORD *)v10 + 7) = 0u;
  v10[16] = 0;
  char v11 = [(objc_class *)v138 CA_automaticallyNotifiesObservers:v138];
  uint64_t v12 = v139;
  *((unsigned char *)v139 + 136) = v11;
  *(_WORD *)((char *)v12 + 137) = 0;
  *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 584) = v12;
  if ((Class)objc_opt_class() == v138)
  {
    classDescription_locked(objc_class *)::CALayer_needsLayoutForKey = [(objc_class *)v138 methodForSelector:sel_needsLayoutForKey_];
    if (!classDescription_locked(objc_class *)::CALayer_needsLayoutForKey) {
      goto LABEL_17;
    }
  }
  else if (!classDescription_locked(objc_class *)::CALayer_needsLayoutForKey)
  {
    goto LABEL_17;
  }
  if ([(objc_class *)v138 isSubclassOfClass:objc_opt_class()])
  {
    uint64_t v13 = [(objc_class *)v138 methodForSelector:sel_needsLayoutForKey_];
    BOOL v14 = v13 != classDescription_locked(objc_class *)::CALayer_needsLayoutForKey;
    goto LABEL_18;
  }
LABEL_17:
  BOOL v14 = 0;
LABEL_18:
  *((unsigned char *)v139 + 137) = v14;
  unint64_t v15 = (objc_class *)objc_opt_class();
  double v16 = v138;
  if (v15 == v138)
  {
    classDescription_locked(objc_class *)::CALayer_needsDisplayForKey = [(objc_class *)v138 methodForSelector:sel_needsDisplayForKey_];
    double v16 = v138;
    if (classDescription_locked(objc_class *)::CALayer_needsDisplayForKey) {
      goto LABEL_20;
    }
LABEL_23:
    BOOL v18 = 0;
    goto LABEL_26;
  }
  if (!classDescription_locked(objc_class *)::CALayer_needsDisplayForKey) {
    goto LABEL_23;
  }
LABEL_20:
  if ([(objc_class *)v138 isSubclassOfClass:objc_opt_class()])
  {
    uint64_t v17 = [(objc_class *)v138 methodForSelector:sel_needsDisplayForKey_];
    BOOL v18 = v17 != classDescription_locked(objc_class *)::CALayer_needsDisplayForKey;
  }
  else
  {
    BOOL v18 = 0;
  }
  double v16 = v138;
LABEL_26:
  *((unsigned char *)v139 + 138) = v18;
  unsigned int v140 = 0;
  float v135 = class_copyPropertyList(v16, &v140);
  if (v140)
  {
    uint64_t v19 = (unsigned int *)malloc_type_malloc(40 * v140, 0x10F004002E6B5C6uLL);
    *float v134 = v19;
    if (v140)
    {
      uint64_t v21 = 0;
      *(void *)&long long v20 = 67109634;
      long long v132 = v20;
      *(void *)&long long v20 = 136315394;
      long long v133 = v20;
      while (1)
      {
        unsigned int v22 = v135[v21];
        uint64_t Name = property_getName(v22);
        Attributes = property_getAttributes(v22);
        if (v6[3032])
        {
          if (x_log_hook_p())
          {
            float v131 = (x_list_struct *)Attributes;
            float v130 = Name;
            x_log_();
          }
          else
          {
            unint64_t v24 = x_log_category_api;
            if (os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(v141[0]) = v133;
              *(void *)((char *)v141 + 4) = Name;
              WORD2(v141[1]) = 2080;
              *(void *)((char *)&v141[1] + 6) = Attributes;
              _os_log_impl(&dword_184668000, v24, OS_LOG_TYPE_DEFAULT, "  %s: %s\n", (uint8_t *)v141, 0x16u);
            }
          }
        }
        unsigned int v25 = CAInternAtomWithCString(Name);
        *((void *)v19 + 1) = 0;
        float v137 = (x_list_struct *)(v19 + 2);
        *((void *)v19 + 2) = 0;
        LOWORD(v26) = 0;
        unsigned int *v19 = v25;
        v19[1] = 0x20000;
        *((void *)v19 + 3) = 0;
        float v27 = (char **)(v19 + 6);
        *((void *)v19 + 4) = 0;
        char v28 = *Attributes;
        if (*Attributes) {
          break;
        }
LABEL_118:
        if (-[objc_class CA_encodesPropertyConditionally:type:](v138, "CA_encodesPropertyConditionally:type:", *v19, (unsigned __int16)v26, (void)v132, *((void *)&v132 + 1)))v19[1] |= 0x20000000u; {
        if (v6[3032])
        }
        {
          if (x_log_hook_p())
          {
            float v130 = (const char *)HIWORD(v19[1]);
            x_log_();
          }
          else
          {
            unint64_t v50 = x_log_category_api;
            if (os_log_type_enabled((os_log_t)x_log_category_api, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v51 = *((void *)v19 + 3);
              unsigned int v52 = HIWORD(v19[1]);
              v141[0] = __PAIR64__((unsigned __int16)v19[1], v132);
              LOWORD(v141[1]) = 2080;
              *(void *)((char *)&v141[1] + 2) = v51;
              WORD1(v141[2]) = 1024;
              HIDWORD(v141[2]) = v52;
              _os_log_impl(&dword_184668000, v50, OS_LOG_TYPE_DEFAULT, "    type %d: %s flags 0x%x\n", (uint8_t *)v141, 0x18u);
            }
          }
        }
        if (*((_WORD *)v19 + 2))
        {
          uint64_t v53 = *v19;
          if (v53)
          {
            if (!*((void *)v19 + 2))
            {
              if (v53 > 0x268) {
                goto LABEL_132;
              }
              if (init_selectors(void)::once[0] != -1) {
                dispatch_once(init_selectors(void)::once, &__block_literal_global_11052);
              }
              SEL v54 = (SEL)t[2 * v53];
              if (!v54) {
LABEL_132:
              }
                SEL v54 = sel_registerName(Name);
              *((void *)v19 + 2) = v54;
            }
            if (!*(void *)v137 && (*((unsigned char *)v19 + 6) & 1) == 0)
            {
              uint64_t v55 = *v19;
              if (v55 > 0x268) {
                goto LABEL_140;
              }
              if (init_selectors(void)::once[0] != -1) {
                dispatch_once(init_selectors(void)::once, &__block_literal_global_11052);
              }
              SEL v56 = (SEL)t[2 * v55 + 1];
              if (!v56) {
LABEL_140:
              }
                SEL v56 = defaultSetter(Name);
              *(void *)float v137 = v56;
            }
            v19 += 10;
            ++*((_DWORD *)v139 + 6);
          }
        }
        if (++v21 >= (unint64_t)v140) {
          goto LABEL_144;
        }
      }
      while (1)
      {
        double v29 = Attributes + 1;
        for (unint64_t i = Attributes + 1; *i && *i != 44; ++i)
          ;
        if (v28 > 70)
        {
          switch(v28)
          {
            case 'R':
              unsigned int v31 = v19[1] | 0x10000;
              goto LABEL_96;
            case 'S':
              int64_t v34 = i - Attributes;
              if (i - Attributes > 255) {
                goto LABEL_97;
              }
              uint64_t v35 = *v19;
              if (v35 >= 0x269)
              {
                *(void *)float v137 = 0;
LABEL_63:
                memcpy(v141, v29, v34 + 1);
                *((unsigned char *)v141 + v34 - 1) = 0;
                *(void *)float v137 = sel_registerName((const char *)v141);
                goto LABEL_97;
              }
              if (init_selectors(void)::once[0] != -1) {
                dispatch_once(init_selectors(void)::once, &__block_literal_global_11052);
              }
              uint64_t v40 = t[2 * v35 + 1];
              *(void *)float v137 = v40;
              if (!v40) {
                goto LABEL_63;
              }
              goto LABEL_97;
            case 'T':
              int64_t v36 = i - Attributes;
              if (i - Attributes > 255) {
                goto LABEL_97;
              }
              unsigned int v37 = v6;
              int64_t v38 = v36 - 1;
              unint64_t v39 = (char *)v141;
              memcpy(v141, v29, v36 - 1);
              *((unsigned char *)v141 + v38) = 0;
              int v6 = v37;
              atomic_uint *v27 = 0;
              while (2)
              {
                switch(*v39)
                {
                  case '@':
                    int v46 = v39[1];
                    unint64_t v45 = v39 + 1;
                    if (v46 == 34) {
                      atomic_uint *v27 = intern_quoted(v45);
                    }
                    goto LABEL_84;
                  case 'A':
                  case 'D':
                  case 'E':
                  case 'F':
                  case 'G':
                  case 'H':
                  case 'J':
                  case 'K':
                  case 'M':
                  case 'P':
                  case 'T':
                  case 'U':
                  case 'W':
                  case 'X':
                  case 'Y':
                  case 'Z':
                  case '[':
                  case '\\':
                  case ']':
                  case '_':
                  case 'a':
                  case 'b':
                  case 'e':
                  case 'g':
                  case 'h':
                  case 'j':
                  case 'k':
                  case 'm':
                  case 'p':
                    goto LABEL_71;
                  case 'B':
                    int v42 = 6;
                    goto LABEL_95;
                  case 'C':
                    int v42 = 8;
                    goto LABEL_95;
                  case 'I':
                    int v42 = 12;
                    goto LABEL_95;
                  case 'L':
                  case 'Q':
                    int v42 = 14;
                    goto LABEL_95;
                  case 'N':
                  case 'O':
                  case 'R':
                  case 'V':
                  case 'n':
                  case 'o':
                  case 'r':
                    ++v39;
                    continue;
                  case 'S':
                    int v42 = 10;
                    goto LABEL_95;
                  case '^':
                    int v44 = v39[1];
                    uint64_t v43 = v39 + 1;
                    if (v44 == 123) {
                      atomic_uint *v27 = intern_struct_name(v43);
                    }
                    int v42 = 2;
                    goto LABEL_95;
                  case 'c':
                    int v42 = 7;
                    goto LABEL_95;
                  case 'd':
                    int v42 = 18;
                    goto LABEL_95;
                  case 'f':
                    int v42 = 17;
                    goto LABEL_95;
                  case 'i':
                    int v42 = 11;
                    goto LABEL_95;
                  case 'l':
                  case 'q':
                    int v42 = 13;
                    goto LABEL_95;
                  case 's':
                    int v42 = 9;
                    goto LABEL_95;
                  default:
                    if (*v39 == 58)
                    {
LABEL_84:
                      *((_WORD *)v19 + 2) = 1;
                      goto LABEL_97;
                    }
LABEL_71:
                    if (compare_types(v39, "{CGPoint=dd}"))
                    {
                      int v42 = 19;
                    }
                    else if (compare_types(v39, "{CGSize=dd}"))
                    {
                      int v42 = 20;
                    }
                    else if (compare_types(v39, "{CGRect={CGPoint=dd}{CGSize=dd}}"))
                    {
                      int v42 = 21;
                    }
                    else if (compare_types(v39, "{CGAffineTransform=dddddd}") || compare_types(v39, "{?=dddddd}"))
                    {
                      int v42 = 23;
                    }
                    else if (compare_types(v39, "{CATransform3D=dddddddddddddddd}"))
                    {
                      int v42 = 22;
                    }
                    else if (compare_types(v39, "{CAPoint3D=ddd}"))
                    {
                      int v42 = 24;
                    }
                    else if (compare_types(v39, "{CACornerRadii={CGSize=dd}{CGSize=dd}{CGSize=dd}{CGSize=dd}}"))
                    {
                      int v42 = 25;
                    }
                    else
                    {
                      int v42 = 0;
                    }
LABEL_95:
                    unsigned int v31 = v19[1] & 0xFFFD0000 | v42;
                    break;
                }
                goto LABEL_96;
              }
            case 'U':
            case 'V':
              goto LABEL_97;
            case 'W':
              unsigned int v31 = v19[1] | 0x80000;
              goto LABEL_96;
            default:
              if (v28 != 71) {
                goto LABEL_97;
              }
              int64_t v32 = i - Attributes;
              if (i - Attributes > 255) {
                goto LABEL_97;
              }
              uint64_t v33 = *v19;
              if (v33 >= 0x269)
              {
                *((void *)v19 + 2) = 0;
LABEL_67:
                memcpy(v141, v29, v32 + 1);
                *((unsigned char *)v141 + v32 - 1) = 0;
                *((void *)v19 + 2) = sel_registerName((const char *)v141);
                goto LABEL_97;
              }
              if (init_selectors(void)::once[0] != -1) {
                dispatch_once(init_selectors(void)::once, &__block_literal_global_11052);
              }
              uint64_t v41 = t[2 * v33];
              *((void *)v19 + 2) = v41;
              if (!v41) {
                goto LABEL_67;
              }
              break;
          }
          goto LABEL_97;
        }
        if (v28 == 38) {
          break;
        }
        if (v28 == 67)
        {
          unsigned int v31 = v19[1] & 0xFFF9FFFF | 0x40000;
          goto LABEL_96;
        }
        if (v28 == 68)
        {
          unsigned int v31 = v19[1] | 0x200000;
LABEL_96:
          v19[1] = v31;
        }
LABEL_97:
        if (*i == 44) {
          Attributes = i + 1;
        }
        else {
          Attributes = i;
        }
        char v28 = *Attributes;
        if (!*Attributes)
        {
          unsigned int v26 = v19[1];
          if ((unsigned __int16)v26 - 1 <= 3)
          {
            unsigned int v47 = v26 & 0xFFFF0000;
            unsigned int v48 = v26 & 0xFFFF0000 | 2;
            if ((v26 & 0x20000) != 0) {
              unsigned int v48 = v26 & 0xFFFF0000 | 1;
            }
            if ((v26 & 0x80000) != 0) {
              unsigned int v48 = v47 | 4;
            }
            int v49 = v47 | 3;
            if ((v26 & 0x40000) != 0) {
              unsigned int v26 = v49;
            }
            else {
              unsigned int v26 = v48;
            }
            v19[1] = v26;
          }
          goto LABEL_118;
        }
      }
      unsigned int v31 = v19[1] & 0xFFFDFFFF;
      goto LABEL_96;
    }
LABEL_144:
    if (!*((_DWORD *)v139 + 6))
    {
      free(*v134);
      *float v134 = 0;
    }
  }
  free(v135);
  unint64_t v57 = v139;
  size_t v58 = *((unsigned int *)v139 + 6);
  if (!v58)
  {
    v139[14] = 0;
    goto LABEL_182;
  }
  unint64_t v59 = *v134;
  if (!*v134) {
    __assert_rtn("classDescription_locked", "CAObject.mm", 444, "info != NULL");
  }
  qsort(*v134, v58, 0x28uLL, (int (__cdecl *)(const void *, const void *))compareInfo);
  unint64_t v60 = v139;
  MEMORY[0x1F4188790](v61);
  unint64_t v63 = (char *)&v132 - 8 * v62;
  bzero(v63, v64);
  MEMORY[0x1F4188790](v65);
  unint64_t v67 = (char *)&v132 - 8 * v66;
  bzero(v67, v68);
  uint64_t v69 = *((unsigned int *)v60 + 6);
  if (v69)
  {
    CFIndex v70 = 0;
    do
    {
      *(void *)&v63[8 * v70] = v59[2];
      CFIndex v71 = v70 + 1;
      *(void *)&v67[8 * v70] = v59;
      uint64_t v72 = v59[1];
      if (v72)
      {
        *(void *)&v63[8 * v71] = v72;
        *(void *)&v67[8 * v71] = v59;
        CFIndex v71 = v70 + 2;
      }
      v59 += 5;
      CFIndex v70 = v71;
      --v69;
    }
    while (v69);
  }
  else
  {
    CFIndex v71 = 0;
  }
  CFDictionaryRef v73 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF98], (const void **)v63, (const void **)v67, v71, 0, 0);
  unint64_t v57 = v139;
  int v74 = *((_DWORD *)v139 + 6);
  v139[14] = v73;
  if (v74)
  {
    LODWORD(v141[0]) = 0;
    unsigned int v75 = (char *)*v134;
    float64x2_t v76 = class_copyMethodList(v138, (unsigned int *)v141);
    uint64_t v77 = v76;
    if (!LODWORD(v141[0]))
    {
      float64x2x2_t v79 = 0;
LABEL_165:
      unint64_t v57 = v139;
      unint64_t v82 = *((unsigned int *)v139 + 6);
      if (!v82) {
        goto LABEL_178;
      }
      uint64_t v83 = 0;
      while (1)
      {
        unint64_t v84 = &v75[40 * v83];
        if ((v84[6] & 0x20) == 0) {
          goto LABEL_175;
        }
        uint64_t v85 = 0;
        uint64_t v86 = (int *)(v84 + 4);
        char v87 = 1;
        while (1)
        {
          char v88 = v87;
          uint64_t v89 = (uint64_t)&v75[40 * v83 + 8 * v85];
          uint64_t v91 = *(void *)(v89 + 8);
          double v90 = (const void *)(v89 + 8);
          if (!v91
            || bsearch(v90, v79, LODWORD(v141[0]), 8uLL, (int (__cdecl *)(const void *, const void *))compare_sel))
          {
            goto LABEL_173;
          }
          int v92 = *v86;
          if ((v88 & 1) == 0) {
            break;
          }
          *uint64_t v86 = v92 | 0x40000000;
LABEL_173:
          char v87 = 0;
          uint64_t v85 = 1;
          if ((v88 & 1) == 0) {
            goto LABEL_174;
          }
        }
        *uint64_t v86 = v92 | 0x80000000;
LABEL_174:
        unint64_t v57 = v139;
        unint64_t v82 = *((unsigned int *)v139 + 6);
LABEL_175:
        if (++v83 >= v82)
        {
LABEL_178:
          if (LODWORD(v141[0]))
          {
            if (LODWORD(v141[0]) >= 0x201) {
              free(v79);
            }
            free(v77);
          }
          goto LABEL_182;
        }
      }
    }
    if (LODWORD(v141[0]) > 0x200)
    {
      float64x2x2_t v79 = (char *)malloc_type_malloc(8 * LODWORD(v141[0]), 0x80040B8603338uLL);
      unsigned int v80 = v141[0];
      if (!LODWORD(v141[0]))
      {
LABEL_164:
        qsort(v79, v80, 8uLL, (int (__cdecl *)(const void *, const void *))compare_sel);
        goto LABEL_165;
      }
    }
    else
    {
      MEMORY[0x1F4188790](v76);
      float64x2x2_t v79 = (char *)&v132 - ((v78 + 15) & 0xFFFFFFFF0);
      bzero(v79, v78);
    }
    unint64_t v81 = 0;
    do
    {
      *(void *)&v79[8 * v81] = method_getName(v77[v81]);
      ++v81;
      unsigned int v80 = v141[0];
    }
    while (v81 < LODWORD(v141[0]));
    goto LABEL_164;
  }
LABEL_182:
  uint64_t v93 = 0;
  float v137 = 0;
  uint64_t v94 = 0;
  uint64_t v95 = 0;
  uint64_t v96 = v57;
  do
  {
    if (*((_DWORD *)v96 + 6))
    {
      uint64_t v97 = 0;
      unint64_t v98 = 0;
      do
      {
        long long v146 = 0u;
        long long v147 = 0u;
        long long v144 = 0u;
        long long v145 = 0u;
        long long v142 = 0u;
        long long v143 = 0u;
        memset(v141, 0, sizeof(v141));
        uint64_t v99 = v96[2];
        float64x2_t v100 = (const char *)*(unsigned int *)(v99 + v97);
        String = CAAtomGetString(*(_DWORD *)(v99 + v97));
        if (*((unsigned char *)v139 + 137))
        {
          uint64_t v102 = [(objc_class *)v138 needsLayoutForKey:String];
          if (v102)
          {
            MEMORY[0x1F4188790](v102);
            float v130 = v100;
            float v131 = v95;
            ++v94;
            uint64_t v95 = (x_list_struct *)&v130;
          }
        }
        if (*((unsigned char *)v139 + 138))
        {
          uint64_t v103 = [(objc_class *)v138 needsDisplayForKey:String];
          if (v103)
          {
            MEMORY[0x1F4188790](v103);
            float v130 = v100;
            float v131 = v137;
            ++v93;
            float v137 = (x_list_struct *)&v130;
          }
        }
        uint64_t v104 = (void *)[(objc_class *)v138 defaultValueForKey:String];
        if (v104)
        {
          if (v96 == v139
            || !*v139
            || (double v105 = (void *)[*(id *)(*v139 + 8) defaultValueForKey:String], v105 != v104)
            && ([v105 isEqual:v104] & 1) == 0)
          {
            CAValueObjCUnbox(v104, *(unsigned __int16 *)(v96[2] + v97 + 4), (uint64_t)v141);
            uint64_t v106 = (char *)&v139[v100 & 7];
            unsigned int v109 = (CA::AttrList *)*((void *)v106 + 6);
            double v108 = (CA::AttrList **)(v106 + 48);
            uint64_t v107 = v109;
            unsigned int v110 = (unsigned int *)(v96[2] + v97);
            unsigned int v111 = (const void *)*v110;
            int v112 = *((unsigned __int16 *)v110 + 2);
            if (!v109)
            {
              malloc_zone = (malloc_zone_t *)get_malloc_zone();
              uint64_t v107 = (CA::AttrList *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x10uLL, 0x743898A5uLL);
            }
            *double v108 = CA::AttrList::set(v107, v111, v112, (unsigned __int8 *)v141);
          }
        }
        ++v98;
        v97 += 40;
      }
      while (v98 < *((unsigned int *)v96 + 6));
    }
    uint64_t v96 = (void *)*v96;
  }
  while (v96);
  Class v114 = v138;
  uint64_t v3 = (uint64_t)v139;
  if (v94)
  {
    if (v94 < 0)
    {
      v139[4] = 0;
    }
    else
    {
      uint64_t v115 = (malloc_zone_t *)get_malloc_zone();
      long long v116 = malloc_type_zone_malloc(v115, 2 * v94, 0x8BB15036uLL);
      *(void *)(v3 + 32) = v116;
      if (v116)
      {
        if (v95)
        {
          unint64_t v118 = 0;
          float v119 = v95;
          do
          {
            ++v118;
            float v119 = (x_list_struct *)*((void *)v119 + 1);
          }
          while (v119);
          float64_t v120 = list_sort_1(v95, v118, v117);
          if (v120)
          {
            unsigned int v121 = *(_WORD **)(v3 + 32);
            do
            {
              *v121++ = *(void *)v120;
              float64_t v120 = (x_list_struct *)*((void *)v120 + 1);
            }
            while (v120);
          }
        }
        *(_WORD *)(v3 + 28) = v94;
      }
    }
  }
  if (v93)
  {
    if (v93 < 0)
    {
      *(void *)(v3 + 40) = 0;
    }
    else
    {
      double v122 = (malloc_zone_t *)get_malloc_zone();
      float v123 = malloc_type_zone_malloc(v122, 2 * v93, 0x8BB15036uLL);
      *(void *)(v3 + 40) = v123;
      if (v123)
      {
        if (v137)
        {
          unint64_t v125 = 0;
          long long v126 = v137;
          do
          {
            ++v125;
            long long v126 = (x_list_struct *)*((void *)v126 + 1);
          }
          while (v126);
          BOOL v127 = list_sort_1(v137, v125, v124);
          if (v127)
          {
            float v128 = *(_WORD **)(v3 + 40);
            do
            {
              *v128++ = *(void *)v127;
              BOOL v127 = (x_list_struct *)*((void *)v127 + 1);
            }
            while (v127);
          }
        }
        *(_WORD *)(v3 + 30) = v93;
      }
    }
  }
  hash_table_modify((int *)class_table, (uint64_t)v114, v3, 0);
  return v3;
}

__CFString *CAAtomGetString(unsigned int a1)
{
  if (!a1) {
    return @"<nil>";
  }
  os_unfair_lock_lock((os_unfair_lock_t)&atomLock);
  if (!atomArray) {
    initAtoms();
  }
  if (a1 >= 0x26A)
  {
    unint64_t v2 = a1;
  }
  else
  {
    unint64_t v2 = a1;
    uint64_t v3 = *(void *)(atomArray + 8 * a1);
    if (!v3)
    {
      double v4 = &word_1849A8ABA;
      while (1)
      {
        int v5 = (unsigned __int16)*v4;
        v4 += 2;
        if (v5 == a1) {
          break;
        }
        if (++v3 == 1619) {
          goto LABEL_12;
        }
      }
      *(void *)(atomArray + 8 * a1) = CFStringCreateWithCStringNoCopy(0, &stringpool_contents[*((__int16 *)&wordlist + 2 * v3)], 0x8000100u, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
    }
  }
LABEL_12:
  if (atomArraySize <= v2) {
    int v6 = @"<unknown>";
  }
  else {
    int v6 = *(__CFString **)(atomArray + 8 * v2);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&atomLock);
  return v6;
}

uint64_t CAInternAtom(const __CFString *a1, int a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  memset(v9, 0, sizeof(v9));
  CStringPtr = CFStringGetCStringPtr(a1, 0x8000100u);
  if (!CStringPtr && (CStringPtr = (const char *)v9, !CFStringGetCString(a1, (char *)v9, 64, 0x8000100u))
    || (uint64_t v5 = (uint64_t)_CAInternAtomWithCString(CStringPtr), !v5))
  {
    os_unfair_lock_lock((os_unfair_lock_t)&atomLock);
    uint64_t v6 = atomDict;
    if (!atomDict)
    {
      initAtoms();
      uint64_t v6 = atomDict;
    }
    uint64_t v5 = x_hash_table_lookup(v6, (uint64_t)a1, 0);
    if (!v5 && a2)
    {
      uint64_t v5 = nextAtom++;
      CFStringRef Copy = CFStringCreateCopy(0, a1);
      insertAtom(v5, Copy);
      CFRelease(Copy);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&atomLock);
  }
  return v5;
}

uint64_t CA::OGL::MetalBufferPool::set_encoder(uint64_t this, objc_object *a2)
{
  if (a2)
  {
    uint64_t v3 = (void *)this;
    *(_OWORD *)(this + 160) = 0u;
    *(_OWORD *)(this + 176) = 0u;
    *(_OWORD *)(this + 128) = 0u;
    *(_OWORD *)(this + 144) = 0u;
    *(_OWORD *)(this + 96) = 0u;
    *(_OWORD *)(this + 112) = 0u;
    *(_OWORD *)(this + 64) = 0u;
    *(_OWORD *)(this + 80) = 0u;
    *(void *)(this + 192) = a2;
    *(void *)(this + 200) = [(objc_object *)a2 methodForSelector:sel_setVertexBuffer_offset_atIndex_];
    v3[26] = [(objc_object *)a2 methodForSelector:sel_setFragmentBuffer_offset_atIndex_];
    v3[27] = [(objc_object *)a2 methodForSelector:sel_setVertexBufferOffset_atIndex_];
    v3[28] = [(objc_object *)a2 methodForSelector:sel_setFragmentBufferOffset_atIndex_];
    this = [(objc_object *)a2 methodForSelector:sel_drawIndexedPrimitives_indexCount_indexType_indexBuffer_indexBufferOffset_];
    v3[29] = this;
  }
  return this;
}

uint64_t CAInternAtomWithCString(const char *a1)
{
  uint64_t v2 = (uint64_t)_CAInternAtomWithCString(a1);
  if (!v2)
  {
    CFStringRef v3 = CFStringCreateWithCString(0, a1, 0x8000100u);
    if (v3)
    {
      CFStringRef v4 = v3;
      os_unfair_lock_lock((os_unfair_lock_t)&atomLock);
      uint64_t v5 = atomDict;
      if (!atomDict)
      {
        initAtoms();
        uint64_t v5 = atomDict;
      }
      uint64_t v2 = x_hash_table_lookup(v5, (uint64_t)v4, 0);
      if (!v2)
      {
        uint64_t v2 = nextAtom++;
        insertAtom(v2, v4);
      }
      os_unfair_lock_unlock((os_unfair_lock_t)&atomLock);
      CFRelease(v4);
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

double CAValueObjCUnbox(void *a1, int a2, uint64_t a3)
{
  switch(a2)
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      goto LABEL_2;
    case 6:
      char v5 = [a1 BOOLValue];
      goto LABEL_7;
    case 7:
      char v5 = [a1 charValue];
      goto LABEL_7;
    case 8:
      char v5 = [a1 unsignedCharValue];
LABEL_7:
      *(unsigned char *)a3 = v5;
      return result;
    case 9:
      __int16 v7 = [a1 shortValue];
      goto LABEL_10;
    case 10:
      __int16 v7 = [a1 unsignedShortValue];
LABEL_10:
      *(_WORD *)a3 = v7;
      return result;
    case 11:
      int v8 = [a1 intValue];
      goto LABEL_13;
    case 12:
      int v8 = [a1 unsignedIntValue];
LABEL_13:
      *(_DWORD *)a3 = v8;
      return result;
    case 13:
      a1 = (void *)[a1 longValue];
      goto LABEL_2;
    case 14:
      a1 = (void *)[a1 unsignedLongValue];
      goto LABEL_2;
    case 15:
      a1 = (void *)[a1 longLongValue];
      goto LABEL_2;
    case 16:
      a1 = (void *)[a1 unsignedLongLongValue];
LABEL_2:
      *(void *)a3 = a1;
      return result;
    case 17:
      [a1 floatValue];
      *(_DWORD *)a3 = LODWORD(result);
      return result;
    case 18:
      [a1 doubleValue];
      *(double *)a3 = result;
      return result;
    case 19:
    case 20:
      uint64_t v4 = 16;
      goto LABEL_26;
    case 21:
      uint64_t v4 = 32;
      goto LABEL_26;
    case 22:
      uint64_t v4 = 128;
      goto LABEL_26;
    case 23:
      if (a1)
      {
        objc_msgSend(a1, "CA_CGAffineTransformValue");
      }
      else
      {
        long long v10 = 0u;
        long long v11 = 0u;
        long long v9 = 0u;
      }
      *(_OWORD *)a3 = v9;
      *(_OWORD *)(a3 + 16) = v10;
      double result = *(double *)&v11;
      *(_OWORD *)(a3 + 32) = v11;
      return result;
    case 24:
      uint64_t v4 = 24;
      goto LABEL_26;
    case 25:
      uint64_t v4 = 64;
LABEL_26:
      [a1 getValue:a3 size:v4];
      break;
    default:
      return result;
  }
  return result;
}

BOOL compare_types(char *a1, const char *a2)
{
  while (1)
  {
    int v3 = *a1;
    int v4 = *(unsigned __int8 *)a2;
    if (!*a1 || v4 == 0) {
      break;
    }
    if (v3 == 34)
    {
      uint64_t v6 = strchr(a1 + 1, 34);
      int v7 = v6[1];
      a1 = v6 + 1;
      int v3 = v7;
    }
    ++a1;
    ++a2;
    if (v3 != v4) {
      return 0;
    }
  }
  return v3 == v4;
}

char *intern_quoted(char *a1)
{
  v10[1] = *MEMORY[0x1E4F143B8];
  int v1 = a1 + 1;
  double result = strchr(a1 + 1, 34);
  if (result)
  {
    int v3 = result;
    int v4 = strchr(v1, 60);
    if (v4) {
      char v5 = v4;
    }
    else {
      char v5 = v3;
    }
    size_t v6 = v5 - v1;
    if (v5 == v1)
    {
      return 0;
    }
    else
    {
      MEMORY[0x1F4188790](v4);
      int v8 = (char *)v10 - v7;
      bzero((char *)v10 + v6 - v7, v6 != -1);
      memcpy(v8, v1, v6);
      v8[v6] = 0;
      long long v9 = sel_registerName(v8);
      return (char *)sel_getName(v9);
    }
  }
  return result;
}

CFTypeRef insertAtom(unsigned int a1, CFTypeRef cf)
{
  int v4 = (int *)atomDict;
  CFTypeRef v5 = CFRetain(cf);
  uint64_t v6 = a1;
  hash_table_modify(v4, (uint64_t)v5, a1, 0);
  uint64_t v7 = atomArraySize;
  if (atomArraySize <= (unint64_t)a1)
  {
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    long long v10 = malloc_type_zone_calloc(malloc_zone, 1uLL, 16 * v7, 0xB6D46EB3uLL);
    if (v10)
    {
      uint64_t v11 = (uint64_t)v10;
      size_t v12 = 8 * v7;
      uint64_t v13 = (void *)atomArray;
      memcpy(v10, (const void *)atomArray, v12);
      BOOL v14 = (malloc_zone_t *)get_malloc_zone();
      malloc_zone_free(v14, v13);
      atomArray = v11;
      atomArraySize *= 2;
    }
  }
  CFTypeRef result = CFRetain(cf);
  *(void *)(atomArray + 8 * v6) = result;
  return result;
}

SEL defaultSetter(const char *a1)
{
  v6[1] = *MEMORY[0x1E4F143B8];
  size_t v2 = strlen(a1);
  int v3 = (char *)v6 - ((MEMORY[0x1F4188790](v2) + 20) & 0xFFFFFFFFFFFFFFF0);
  bzero(v3, v4);
  *(_WORD *)int v3 = 25971;
  v3[2] = 116;
  memcpy(v3 + 3, a1, v2);
  _OWORD v3[3] = __toupper(v3[3]);
  *(_WORD *)&v3[v2 + 3] = 58;
  return sel_registerName(v3);
}

char *intern_struct_name(char *a1)
{
  v7[1] = *MEMORY[0x1E4F143B8];
  int v1 = a1 + 1;
  CFTypeRef result = strchr(a1 + 1, 61);
  if (result)
  {
    size_t v3 = result - v1;
    MEMORY[0x1F4188790](result);
    CFTypeRef v5 = (char *)v7 - v4;
    bzero((char *)v7 + v3 - v4, v3 != -1);
    memcpy(v5, v1, v3);
    v5[v3] = 0;
    uint64_t v6 = sel_registerName(v5);
    return (char *)sel_getName(v6);
  }
  return result;
}

x_list_struct *list_sort_1(x_list_struct *a1, unint64_t a2, BOOL (*a3)(const void *, const void *))
{
  size_t v3 = a1;
  if (a2 >= 2)
  {
    unint64_t v5 = a2 >> 1;
    uint64_t v6 = a1;
    uint64_t v7 = (a2 >> 1) - 1;
    if (a2 >> 1 != 1)
    {
      uint64_t v6 = a1;
      do
      {
        uint64_t v6 = (x_list_struct *)*((void *)v6 + 1);
        --v7;
      }
      while (v7);
    }
    int v8 = (x_list_struct *)*((void *)v6 + 1);
    *((void *)v6 + 1) = 0;
    long long v9 = (x_list_struct *)list_sort_1(a1, a2 >> 1, a3);
    size_t v3 = (x_list_struct *)list_sort_1(v8, a2 - v5, v10);
    if (atom_less(*(void *)v3, *(void *)v9))
    {
      uint64_t v11 = (x_list_struct *)*((void *)v3 + 1);
      size_t v12 = v9;
    }
    else
    {
      size_t v12 = (x_list_struct *)*((void *)v9 + 1);
      uint64_t v11 = v3;
      size_t v3 = v9;
    }
    BOOL v13 = v12 != 0;
    if (v12 && v11)
    {
      BOOL v14 = v3;
      do
      {
        if (atom_less(*(void *)v11, *(void *)v12))
        {
          *((void *)v14 + 1) = v11;
          unint64_t v15 = (x_list_struct *)*((void *)v11 + 1);
          double v16 = v12;
          BOOL v14 = v11;
          uint64_t v11 = v15;
        }
        else
        {
          *((void *)v14 + 1) = v12;
          double v16 = (x_list_struct *)*((void *)v12 + 1);
          unint64_t v15 = v11;
          BOOL v14 = v12;
          size_t v12 = v16;
        }
        BOOL v13 = v16 != 0;
        if (v16) {
          BOOL v17 = v15 == 0;
        }
        else {
          BOOL v17 = 1;
        }
      }
      while (!v17);
    }
    else
    {
      double v16 = v12;
      unint64_t v15 = v11;
      BOOL v14 = v3;
    }
    if (!v13) {
      double v16 = v15;
    }
    *((void *)v14 + 1) = v16;
  }
  return v3;
}

BOOL atom_less(unsigned int a1, unsigned int a2)
{
  return a1 < a2;
}

uint64_t CA::OGL::MetalContext::decode_segment(unsigned char **a1, uint64_t a2, unsigned __int8 *a3, unsigned int a4)
{
  uint64_t v4 = a3;
  uint64_t v5 = 0;
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = a4;
  uint64_t v7 = a3 + 24;
  do
  {
    unsigned int v9 = (char)v4[72 * v5];
    if ((v9 & 0x80000000) != 0)
    {
      uint64_t result = __maskrune(v9, 0x8000uLL);
      if (!result) {
        goto LABEL_10;
      }
    }
    else
    {
      uint64_t result = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v9 + 60) & 0x8000;
      if (!result) {
        goto LABEL_10;
      }
    }
    if (!v4[72 * v5 + 1])
    {
      uint64_t v11 = &v4[72 * v5];
      int v13 = *((_DWORD *)v11 + 2);
      size_t v12 = (int *)(v11 + 8);
      if (v13 >= 1)
      {
        uint64_t v14 = 0;
        do
          uint64_t result = (*(uint64_t (**)(uint64_t, void))&v7[8 * v14++])(a2, *(unsigned int *)&v4[72 * v5 + 12]);
        while (v14 < *v12);
      }
    }
LABEL_10:
    ++v5;
    v7 += 72;
  }
  while (v5 != v6);
  unint64_t v15 = *a1;
  int v42 = v4 + 24;
  uint64_t v43 = v4;
  uint64_t v16 = a2;
LABEL_12:
  while (1)
  {
    int v17 = *v15;
    if (!*v15 || v17 == 95) {
      break;
    }
    uint64_t v18 = 0;
    ++v15;
    uint64_t v19 = v42;
    int v44 = v17;
    do
    {
      if (v17 == v4[72 * v18])
      {
        uint64_t v20 = MEMORY[0x1E4F14390];
        if (v4[72 * v18 + 1])
        {
          while (1)
          {
LABEL_17:
            unsigned int v21 = (char)*v15;
            if ((v21 & 0x80000000) != 0)
            {
              if (__maskrune(v21, 0x8000uLL)) {
                break;
              }
            }
            else if ((*(_DWORD *)(v20 + 4 * v21 + 60) & 0x8000) != 0)
            {
              break;
            }
            int v22 = *v15;
            if (!*v15 || v22 == 95) {
              break;
            }
            uint64_t v23 = 0;
            ++v15;
            unint64_t v24 = v4;
            while (1)
            {
              int v25 = *v24;
              v24 += 72;
              if (v22 == v25) {
                break;
              }
              if (v6 == ++v23) {
                goto LABEL_17;
              }
            }
            (*(void (**)(uint64_t, uint64_t))&v4[72 * v23 + 24])(v16, 1);
          }
        }
        else
        {
          unsigned int v26 = &v4[72 * v18];
          int v28 = *((_DWORD *)v26 + 2);
          float v27 = (int *)(v26 + 8);
          if (v28 >= 1)
          {
            uint64_t v29 = 0;
            uint64_t v30 = &v4[72 * v18];
            unsigned int v31 = (int *)(v30 + 4);
            int v46 = (uint64_t (**)(void))(v30 + 16);
            unsigned int v47 = (unsigned int *)(v30 + 12);
            do
            {
              unsigned int v32 = *v47;
              uint64_t v33 = (void *)[[NSString alloc] initWithBytesNoCopy:v15 length:*v31 encoding:4 freeWhenDone:0];
              if (*v46) {
                int64_t v34 = (void *)(*v46)();
              }
              else {
                int64_t v34 = 0;
              }
              uint64_t v35 = (void *)[v34 valueForKey:v33];

              if (v35)
              {
                uint64_t v36 = [v35 unsignedIntValue];
              }
              else
              {
                __int16 v50 = 0;
                uint64_t __dst = 0;
                unsigned int v48 = 0;
                size_t v37 = *v31;
                memcpy(&__dst, v15, v37);
                *((unsigned char *)&__dst + v37) = 0;
                if (sscanf((const char *)&__dst, "%d", &v48) == 1) {
                  uint64_t v36 = v48;
                }
                else {
                  uint64_t v36 = v32;
                }
              }
              uint64_t v16 = a2;
              (*(void (**)(uint64_t, uint64_t))&v19[8 * v29])(a2, v36);
              v15 += *v31;
              ++v29;
            }
            while (v29 < *v27);
          }
        }
      }
      ++v18;
      v19 += 72;
      uint64_t v4 = v43;
      int v17 = v44;
    }
    while (v18 != v6);
    uint64_t v38 = MEMORY[0x1E4F14390];
    while (1)
    {
      unsigned int v39 = (char)*v15;
      if ((v39 & 0x80000000) != 0)
      {
        uint64_t result = __maskrune(v39, 0x8000uLL);
        if (result) {
          goto LABEL_12;
        }
      }
      else
      {
        uint64_t result = *(_DWORD *)(v38 + 4 * v39 + 60) & 0x8000;
        if (result) {
          goto LABEL_12;
        }
      }
      if (!*v15 || *v15 == 95) {
        break;
      }
      ++v15;
    }
  }
  if (v17 == 95) {
    uint64_t v40 = v15 + 1;
  }
  else {
    uint64_t v40 = v15;
  }
  *a1 = v40;
  return result;
}

void initAtoms()
{
  if (!atomDict)
  {
    nextAtouint64_t m = 618;
    atomDict = (uint64_t)x_hash_table_new_((unint64_t (*)(uint64_t))hash_cf, (BOOL (*)(uint64_t, uint64_t))compare_cf, 0, 0, 0, 0);
    if ((2 * nextAtom) <= 0x80) {
      size_t v0 = 128;
    }
    else {
      size_t v0 = (2 * nextAtom);
    }
    atomArraySize = v0;
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    atomArray = (uint64_t)malloc_type_zone_calloc(malloc_zone, v0, 8uLL, 0xB6D46EB3uLL);
  }
}

_WORD *CA::OGL::MetalContext::Pipeline::Spec::decode_segment(char const**)::$_0::__invoke(uint64_t a1, __int16 a2)
{
  __int16 v3 = *(_WORD *)(a1 + 24);
  uint64_t result = (_WORD *)(a1 + 24);
  *uint64_t result = v3 & 0xFC00 | a2 & 0x3FF;
  return result;
}

uint64_t CA::OGL::MetalContext::FragmentShader::Spec::decode_segment(char const**)::$_3::__invoke(uint64_t result, char a2)
{
  *(unsigned char *)(result + 16) = *(unsigned char *)(result + 16) & 0x9F | (32 * (a2 & 3));
  return result;
}

uint64_t CA::OGL::MetalContext::FragmentShader::Spec::Image::decode_segment(char const**)::$_0::__invoke(uint64_t a1, char a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a1 & 0xFFFFFFC0 | a2 & 0x3F;
  __int16 v3 = *(_WORD *)(a1 + 4);
  uint64_t result = a1 + 4;
  *(unsigned char *)(result + 2) = *(unsigned char *)(result + 2);
  *(_WORD *)uint64_t result = v3;
  return result;
}

uint64_t CA::OGL::MetalContext::FragmentShader::Spec::decode_segment(char const**)::$_0::__invoke(uint64_t result, char a2)
{
  *(unsigned char *)(result + 14) = *(unsigned char *)(result + 14) & 0x80 | a2 & 0x7F;
  return result;
}

uint64_t CA::OGL::MetalContext::Pipeline::Spec::decode_segment(char const**)::$_1::__invoke(uint64_t a1, __int16 a2)
{
  int v3 = *(unsigned __int16 *)(a1 + 24);
  uint64_t result = a1 + 24;
  unsigned int v4 = v3 & 0xFFFF03FF | (*(unsigned __int8 *)(result + 2) << 16);
  *(_WORD *)uint64_t result = v3 & 0x3FF | (a2 << 10);
  *(unsigned char *)(result + 2) = BYTE2(v4);
  return result;
}

uint64_t CA::OGL::MetalContext::get_Opcode_decoder(CA::OGL::MetalContext *this)
{
  if (CA::OGL::MetalContext::get_Opcode_decoder(void)::once != -1) {
    dispatch_once(&CA::OGL::MetalContext::get_Opcode_decoder(void)::once, &__block_literal_global_2592);
  }
  return CA::OGL::MetalContext::get_Opcode_decoder(void)::decoder;
}

uint64_t CA::OGL::MetalContext::FragmentShader::Spec::decode_segment(char const**)::$_4::__invoke(uint64_t result, char a2)
{
  *(_WORD *)(result + 17) = *(_WORD *)(result + 17) & 0xFFFC | a2 & 3;
  return result;
}

unsigned int *CA::OGL::MetalContext::FragmentShader::Spec::Image::decode_segment(char const**)::$_10::__invoke(unsigned int *result, char a2)
{
  unint64_t v2 = (*result | ((unint64_t)(*((unsigned __int16 *)result + 2) | (*((unsigned __int8 *)result + 6) << 16)) << 32)) & 0xFFFE0FFFFFFFFFFFLL | ((unint64_t)(a2 & 0x1F) << 44);
  *uint64_t result = *result;
  *((_WORD *)result + 2) = WORD2(v2);
  *((unsigned char *)result + 6) = BYTE6(v2);
  return result;
}

unsigned int *CA::OGL::MetalContext::FragmentShader::Spec::Image::decode_segment(char const**)::$_9::__invoke(unsigned int *result, char a2)
{
  int v2 = *((unsigned __int8 *)result + 6);
  unint64_t v3 = (*result | ((unint64_t)(*((unsigned __int16 *)result + 2) | (v2 << 16)) << 32)) & 0xFFFFF07FFFFFFFFFLL;
  *((unsigned char *)result + 6) = v2;
  *uint64_t result = v3;
  *((_WORD *)result + 2) = (v3 | ((unint64_t)(a2 & 0x1F) << 39)) >> 32;
  return result;
}

unsigned int *CA::OGL::MetalContext::FragmentShader::Spec::Image::decode_segment(char const**)::$_8::__invoke(unsigned int *result, char a2)
{
  int v2 = *((unsigned __int8 *)result + 6);
  unint64_t v3 = (*result | ((unint64_t)(*((unsigned __int16 *)result + 2) | (v2 << 16)) << 32)) & 0xFFFFFF83FFFFFFFFLL;
  *((unsigned char *)result + 6) = v2;
  *uint64_t result = v3;
  *((_WORD *)result + 2) = (v3 | ((unint64_t)(a2 & 0x1F) << 34)) >> 32;
  return result;
}

unsigned int *CA::OGL::MetalContext::FragmentShader::Spec::Image::decode_segment(char const**)::$_7::__invoke(unsigned int *result, char a2)
{
  int v2 = *((unsigned __int8 *)result + 6);
  unint64_t v3 = (*result | ((unint64_t)(*((unsigned __int16 *)result + 2) | (v2 << 16)) << 32)) & 0xFFFFFFFC1FFFFFFFLL | ((unint64_t)(a2 & 0x1F) << 29);
  *((unsigned char *)result + 6) = v2;
  *uint64_t result = v3;
  *((_WORD *)result + 2) = WORD2(v3);
  return result;
}

uint64_t CA::OGL::MetalContext::FragmentShader::Spec::Image::decode_segment(char const**)::$_6::__invoke(uint64_t result, char a2)
{
  __int16 v2 = *(_WORD *)(result + 4);
  unsigned int v3 = *(_DWORD *)result & 0xE0FFFFFF;
  *(unsigned char *)(result + 6) = *(unsigned char *)(result + 6);
  *(_WORD *)(result + 4) = v2;
  *(_DWORD *)uint64_t result = v3 | ((a2 & 0x1F) << 24);
  return result;
}

uint64_t CA::OGL::MetalContext::FragmentShader::Spec::Image::decode_segment(char const**)::$_5::__invoke(uint64_t result, char a2)
{
  __int16 v2 = *(_WORD *)(result + 4);
  unsigned int v3 = *(_DWORD *)result & 0xFF07FFFF;
  *(unsigned char *)(result + 6) = *(unsigned char *)(result + 6);
  *(_WORD *)(result + 4) = v2;
  *(_DWORD *)uint64_t result = v3 | ((a2 & 0x1F) << 19);
  return result;
}

uint64_t CA::OGL::MetalContext::FragmentShader::Spec::Image::decode_segment(char const**)::$_4::__invoke(uint64_t result, char a2)
{
  __int16 v2 = *(_WORD *)(result + 4);
  unsigned int v3 = *(_DWORD *)result & 0xFFF8FFFF;
  *(unsigned char *)(result + 6) = *(unsigned char *)(result + 6);
  *(_WORD *)(result + 4) = v2;
  *(_DWORD *)uint64_t result = v3 | ((a2 & 7) << 16);
  return result;
}

uint64_t CA::OGL::MetalContext::FragmentShader::Spec::Image::decode_segment(char const**)::$_3::__invoke(uint64_t result, char a2)
{
  __int16 v2 = *(_WORD *)(result + 4);
  unsigned int v3 = *(_DWORD *)result & 0xFFFF1FFF;
  *(unsigned char *)(result + 6) = *(unsigned char *)(result + 6);
  *(_WORD *)(result + 4) = v2;
  *(_DWORD *)uint64_t result = v3 | ((a2 & 7) << 13);
  return result;
}

uint64_t CA::OGL::MetalContext::FragmentShader::Spec::decode_segment(char const**)::$_1::__invoke(uint64_t result, char a2)
{
  *(unsigned char *)(result + 15) = *(unsigned char *)(result + 15) & 0xC0 | a2 & 0x3F;
  return result;
}

uint64_t CA::OGL::MetalContext::FragmentShader::Spec::Image::decode_segment(char const**)::$_1::__invoke(uint64_t result, char a2)
{
  __int16 v2 = *(_WORD *)(result + 4);
  unsigned int v3 = *(_DWORD *)result & 0xFFFFFE3F;
  *(unsigned char *)(result + 6) = *(unsigned char *)(result + 6);
  *(_WORD *)(result + 4) = v2;
  *(_DWORD *)uint64_t result = v3 | ((a2 & 7) << 6);
  return result;
}

uint64_t CA::OGL::MetalContext::Pipeline::Spec::decode_segment(char const**)::$_3::__invoke(uint64_t a1, int a2)
{
  int v3 = *(unsigned __int16 *)(a1 + 24);
  uint64_t result = a1 + 24;
  unsigned int v4 = (v3 | (*(unsigned __int8 *)(result + 2) << 16)) & 0xFFFEFFFF;
  *(_WORD *)uint64_t result = v3;
  *(unsigned char *)(result + 2) = (v4 | ((a2 != 0) << 16)) >> 16;
  return result;
}

uint64_t CA::OGL::MetalContext::FragmentShader::Spec::Image::decode_segment(char const**)::$_2::__invoke(uint64_t result, char a2)
{
  __int16 v2 = *(_WORD *)(result + 4);
  unsigned int v3 = *(_DWORD *)result & 0xFFFFE1FF;
  *(unsigned char *)(result + 6) = *(unsigned char *)(result + 6);
  *(_WORD *)(result + 4) = v2;
  *(_DWORD *)uint64_t result = v3 | ((a2 & 0xF) << 9);
  return result;
}

uint64_t CA::OGL::MetalContext::FragmentShader::Spec::decode_segment(char const**)::$_9::__invoke(uint64_t result, int a2)
{
  *(_WORD *)(result + 17) = *(_WORD *)(result + 17) & 0xF7FF | ((a2 != 0) << 11);
  return result;
}

uint64_t CA::OGL::MetalContext::FragmentShader::Spec::decode_segment(char const**)::$_8::__invoke(uint64_t result, int a2)
{
  *(_WORD *)(result + 17) = *(_WORD *)(result + 17) & 0xFFDF | (32 * (a2 != 0));
  return result;
}

uint64_t CA::OGL::MetalContext::FragmentShader::Spec::decode_segment(char const**)::$_7::__invoke(uint64_t result, int a2)
{
  *(_WORD *)(result + 17) = *(_WORD *)(result + 17) & 0xFFEF | (16 * (a2 != 0));
  return result;
}

uint64_t CA::OGL::MetalContext::FragmentShader::Spec::decode_segment(char const**)::$_5::__invoke(uint64_t result, char a2)
{
  *(unsigned char *)(result + 16) = *(unsigned char *)(result + 16) & 0xE7 | (8 * (a2 & 3));
  return result;
}

uint64_t CA::OGL::MetalContext::FragmentShader::Spec::decode_segment(char const**)::$_2::__invoke(uint64_t result, char a2)
{
  *(unsigned char *)(result + 16) = *(unsigned char *)(result + 16) & 0xF8 | a2 & 7;
  return result;
}

uint64_t CA::OGL::MetalContext::get_MTLPixelFormat_decoder(CA::OGL::MetalContext *this)
{
  if (CA::OGL::MetalContext::get_MTLPixelFormat_decoder(void)::once != -1) {
    dispatch_once(&CA::OGL::MetalContext::get_MTLPixelFormat_decoder(void)::once, &__block_literal_global_2751);
  }
  return CA::OGL::MetalContext::get_MTLPixelFormat_decoder(void)::decoder;
}

uint64_t CA::OGL::MetalContext::get_ImageFunction_decoder(CA::OGL::MetalContext *this)
{
  if (CA::OGL::MetalContext::get_ImageFunction_decoder(void)::once[0] != -1) {
    dispatch_once(CA::OGL::MetalContext::get_ImageFunction_decoder(void)::once, &__block_literal_global_2409);
  }
  return CA::OGL::MetalContext::get_ImageFunction_decoder(void)::decoder;
}

uint64_t CA::OGL::MetalContext::FragmentShader::Spec::decode_segment(char const**)::$_10::__invoke(uint64_t result, int a2)
{
  *(_WORD *)(result + 17) = *(_WORD *)(result + 17) & 0xFFBF | ((a2 != 0) << 6);
  return result;
}

uint64_t CA::OGL::MetalContext::get_BlendFunction_decoder(CA::OGL::MetalContext *this)
{
  if (CA::OGL::MetalContext::get_BlendFunction_decoder(void)::once != -1) {
    dispatch_once(&CA::OGL::MetalContext::get_BlendFunction_decoder(void)::once, &__block_literal_global_2130);
  }
  return CA::OGL::MetalContext::get_BlendFunction_decoder(void)::decoder;
}

uint64_t CA::OGL::MetalContext::Pipeline::Spec::decode_segment(char const**)::$_4::__invoke(uint64_t a1, int a2)
{
  int v3 = *(unsigned __int16 *)(a1 + 24);
  uint64_t result = a1 + 24;
  unsigned int v4 = (v3 | (*(unsigned __int8 *)(result + 2) << 16)) & 0xFFFDFFFF;
  *(_WORD *)uint64_t result = v3;
  *(unsigned char *)(result + 2) = (v4 | ((a2 != 0) << 17)) >> 16;
  return result;
}

uint64_t CA::OGL::MetalContext::get_TextureFunction_decoder(CA::OGL::MetalContext *this)
{
  if (CA::OGL::MetalContext::get_TextureFunction_decoder(void)::once[0] != -1) {
    dispatch_once(CA::OGL::MetalContext::get_TextureFunction_decoder(void)::once, &__block_literal_global_1613);
  }
  return CA::OGL::MetalContext::get_TextureFunction_decoder(void)::decoder;
}

unsigned int *CA::OGL::MetalContext::FragmentShader::Spec::Image::decode_segment(char const**)::$_11::__invoke(unsigned int *result, int a2)
{
  unint64_t v2 = (*result | ((unint64_t)(*((unsigned __int16 *)result + 2) | (*((unsigned __int8 *)result + 6) << 16)) << 32)) & 0xFFFDFFFFFFFFFFFFLL;
  *((_WORD *)result + 2) = *((_WORD *)result + 2);
  *uint64_t result = v2;
  *((unsigned char *)result + 6) = (v2 | ((unint64_t)(a2 != 0) << 49)) >> 48;
  return result;
}

uint64_t CA::OGL::MetalContext::get_CoordFunction_decoder(CA::OGL::MetalContext *this)
{
  if (CA::OGL::MetalContext::get_CoordFunction_decoder(void)::once != -1) {
    dispatch_once(&CA::OGL::MetalContext::get_CoordFunction_decoder(void)::once, &__block_literal_global_2535);
  }
  return CA::OGL::MetalContext::get_CoordFunction_decoder(void)::decoder;
}

void *allocate_drawable_texture(void *a1, __IOSurface *a2, unsigned int a3, unsigned int a4, uint64_t a5, uint64_t a6, unsigned int a7, int a8, uint64_t a9, uint64_t a10)
{
  unint64_t v15 = (void *)[MEMORY[0x1E4F35330] texture2DDescriptorWithPixelFormat:a5 width:a3 height:a4 mipmapped:0];
  PixelFormat = (CA::Render *)IOSurfaceGetPixelFormat(a2);
  int v17 = (int)PixelFormat;
  int v18 = CA::Render::fourcc_compressed_of_type(PixelFormat, 0, 0);
  if (CADeviceSupportsUniversalCompression::once != -1) {
    dispatch_once(&CADeviceSupportsUniversalCompression::once, &__block_literal_global_37_12054);
  }
  if (v18 == v17 || !CADeviceSupportsUniversalCompression::universal)
  {
    if (a7 >= 4) {
      abort();
    }
    uint64_t v19 = a7;
  }
  else if ((a7 & 0xFFFFFFFD) == 1)
  {
    uint64_t v19 = 4;
  }
  else
  {
    uint64_t v19 = 0;
  }
  [v15 setRotation:v19];
  [v15 setIsDrawable:1];
  if (a8)
  {
    [v15 setFramebufferOnly:1];
    uint64_t v20 = 4;
  }
  else
  {
    uint64_t v20 = a10;
  }
  [v15 setUsage:v20];
  if (a6)
  {
    [v15 setForceResourceIndex:1];
    [v15 setResourceIndex:a6];
  }
  unsigned int v21 = (void *)[a1 newTextureWithDescriptor:v15 iosurface:a2 plane:0];
  [v21 setLabel:a9];
  return v21;
}

uint64_t CA::OGL::Context::set_destination_texture(CA::OGL::Context *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v5[1] = *MEMORY[0x1E4F143B8];
  v5[0] = a3;
  return (*(uint64_t (**)(CA::OGL::Context *, uint64_t, void *, BOOL, uint64_t, void))(*(void *)this + 24))(this, a2, v5, a3 != 0, a4, 0);
}

BOOL CA::OGL::MetalContext::set_destination_iosurface(os_unfair_lock_s *this, __IOSurface *a2, int a3, int a4)
{
  void v22[2] = *MEMORY[0x1E4F143B8];
  v22[0] = 0;
  v22[1] = 0;
  if (a2)
  {
    os_unfair_lock_lock(this + 702);
    uint64_t v8 = *(void *)&this[704]._os_unfair_lock_opaque;
    if (v8) {
      uint64_t v9 = x_hash_table_lookup(v8, (uint64_t)a2, 0);
    }
    else {
      uint64_t v9 = 0;
    }
    unint64_t v10 = 0;
    uint64_t v11 = 0;
    char v12 = 1;
    do
    {
      char v13 = v12;
      uint64_t v14 = v11;
      while (!v9)
      {
        char v15 = v12;
        char v12 = 0;
        v22[v14] = 0;
        uint64_t v14 = 1;
        if ((v15 & 1) == 0)
        {
          os_unfair_lock_unlock(this + 702);
          v22[0] = (unint64_t)CA::OGL::MetalContext::alloc_destination_texture((CA::OGL::MetalContext *)this, a2);
          operator new[]();
        }
      }
      id v16 = *(id *)(v9 + 8 * v11);
      char v12 = 0;
      v22[v11] = (unint64_t)v16;
      if (v16) {
        ++v10;
      }
      uint64_t v11 = 1;
    }
    while ((v13 & 1) != 0);
    os_unfair_lock_unlock(this + 702);
  }
  else
  {
    unint64_t v10 = 0;
  }
  *(void *)&this[772]._os_unfair_lock_opaque = 0;
  CA::OGL::MetalContext::set_destination_textures((CA::OGL::MetalContext *)this, 0, (id *)v22, v10, a3, a4);
  if (v10)
  {
    int v17 = v22;
    unint64_t v18 = v10;
    do
    {
      uint64_t v19 = (void *)*v17++;

      --v18;
    }
    while (v18);
  }
  if (a2) {
    BOOL v20 = v10 == 0;
  }
  else {
    BOOL v20 = 0;
  }
  return !v20;
}

void sub_1846D580C(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void CA::OGL::MetalContext::set_destination_textures(CA::OGL::MetalContext *this, uint64_t a2, id *a3, unint64_t a4, int a5, int a6)
{
  uint64_t v12 = *((void *)this + 33);
  if (v12)
  {
    *((_WORD *)this + 1664) |= 0x100u;
    CA::OGL::Context::pop_surface(this);
    CA::OGL::Context::release_surface((uint64_t)this, v12);
    *((_WORD *)this + 1664) &= ~0x100u;
    if (*((void *)this + 33)) {
      __assert_rtn("set_destination_textures", "ogl-metal.mm", 10079, "current_surface () == nullptr");
    }
  }
  *(_OWORD *)((char *)this + 2824) = 0u;
  if (!a4)
  {
    *((void *)this + 386) = 0;
    return;
  }
  id v13 = *a3;
  uint64_t v14 = (CA::OGL *)[*a3 pixelFormat];
  BOOL has_alpha_plane = CA::OGL::metal_pixel_format_has_alpha_plane(v14, v15);
  *((void *)this + 386) = [v13 protectionOptions];
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  unint64_t v18 = (char *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0xF0uLL, 0x743898A5uLL);
  uint64_t v19 = (int32x2_t *)v18;
  *(_DWORD *)unint64_t v18 = 1;
  if (has_alpha_plane) {
    int v20 = 15;
  }
  else {
    int v20 = 7;
  }
  *((_DWORD *)v18 + 17) = v20;
  v18[72] &= ~1u;
  __int16 v21 = *((_WORD *)v18 + 116) & 0xFD40 | a4 & 0xF;
  *(_WORD *)(v18 + 75) = *(_WORD *)(v18 + 75) & 0xFE0F | 0x190;
  *((void *)v18 + 11) = this;
  if (a5) {
    __int16 v22 = 640;
  }
  else {
    __int16 v22 = 128;
  }
  *((_WORD *)v18 + 116) = v22 | v21;
  *((_DWORD *)v18 + 6) = [v13 width];
  v19[3].i32[1] = [v13 height];
  v19[6] = (int32x2_t)[v13 protectionOptions];
  __int32 v23 = v19[3].i32[0];
  __int32 v24 = v19[3].i32[1];
  v19[23].i32[0] = v23;
  v19[23].i32[1] = v24;
  v19[4] = vneg_s32(*(int32x2_t *)((char *)this + 2840));
  v19[5].i32[0] = v23;
  v19[5].i32[1] = v24;
  v19[8].i32[0] = *((_DWORD *)this + 734);
  if (a4 > 3) {
    __assert_rtn("set_destination_textures", "ogl-metal.mm", 10123, "count <= MAX_COLOR_ATTACHMENTS");
  }
  int v33 = a6;
  uint64_t v25 = 0;
  do
  {
    id v26 = a3[v25];
    float v27 = &v19[v25];
    v27[12] = (int32x2_t)v26;
    v27[15] = (int32x2_t)[v26 pixelFormat];
    if ([v26 storageMode] == 3) {
      v19[26].i16[3] |= 1 << v25;
    }
    else {
      v19[9].i8[0] ^= 1u;
    }
    ++v25;
  }
  while (a4 != v25);
  if (!a2 || a4 == 1)
  {
    CA::OGL::MetalContext::add_memoryless_textures((uint64_t)this, (uint64_t)v19);
    int v28 = v33;
  }
  else
  {
    int v28 = v33;
    if ((*((_WORD *)this + 1664) & 8) != 0)
    {
      __int16 v29 = v19[26].i16[3] != 0;
      v19[27].i16[0] = v19[26].i16[3];
      *((_WORD *)this + 1664) = *((_WORD *)this + 1664) & 0xFFFD | (2 * v29);
    }
  }
  if (v28 && (*((_WORD *)this + 1664) & 0x10) != 0)
  {
    v19[8].i32[1] |= 0x2000u;
    CA::OGL::MetalContext::add_path_buffer_texture((uint64_t)this, (uint64_t)v19);
  }
  uint64_t v30 = [v13 pixelFormat];
  uint64_t v31 = v30;
  if ((unint64_t)(v30 - 550) <= 5) {
    v19[8].i32[1] |= 0x100u;
  }
  if (v30 == 115)
  {
    int v32 = 16;
    goto LABEL_31;
  }
  if (v30 == 125)
  {
    int v32 = 32;
LABEL_31:
    v19[8].i32[1] |= v32;
  }
  CA::OGL::Context::push_surface((uint64_t)this, (uint64_t)v19, 0, 0, 0);
  *((void *)this + 353) = v19;
  *((void *)this + 354) = v31;
}

uint64_t CA::OGL::MetalContext::add_path_buffer_texture(uint64_t result, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 68);
  if ((v2 & 0x2000) != 0)
  {
    if (*(void *)(a2 + 120) == 125)
    {
      *(_DWORD *)(a2 + 68) = v2 & 0xFFFFDFFF;
    }
    else
    {
      uint64_t v4 = result;
      uint64_t v5 = (void *)[MEMORY[0x1E4F35330] texture2DDescriptorWithPixelFormat:55 width:*(int *)(a2 + 24) height:*(int *)(a2 + 28) mipmapped:0];
      [v5 setStorageMode:3];
      [v5 setUsage:5];
      [v5 setProtectionOptions:*(void *)(v4 + 3088)];
      uint64_t v6 = (void *)[*(id *)(v4 + 2952) newTextureWithDescriptor:v5];
      *(void *)(a2 + 8 * (*(unsigned __int16 *)(a2 + 232) << 28 >> 28) + 96) = v6;
      uint64_t result = [v6 setLabel:@"com.apple.coreanimation.path-buffer"];
      int v7 = *(unsigned __int16 *)(a2 + 232);
      *(void *)(a2 + 8 * (v7 << 28 >> 28) + 120) = 55;
      *(_WORD *)(a2 + 232) = v7 & 0xFFF0 | (v7 + 1) & 0xF;
    }
  }
  return result;
}

void *CA::OGL::MetalContext::alloc_destination_texture(CA::OGL::MetalContext *this, IOSurfaceRef buffer)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  if (buffer)
  {
    PixelFormat = (CA::Render *)IOSurfaceGetPixelFormat(buffer);
    uint64_t ProtectionOptions = IOSurfaceGetProtectionOptions();
  }
  else
  {
    PixelFormat = 0;
    uint64_t ProtectionOptions = 0;
  }
  *((void *)this + 386) = ProtectionOptions;
  size_t Width = IOSurfaceGetWidth(buffer);
  size_t Height = IOSurfaceGetHeight(buffer);
  size_t v8 = Height;
  size_t v9 = *((void *)this + 337);
  if (Width > v9 || Height > v9)
  {
    if (x_log_hook_p())
    {
LABEL_36:
      x_log_();
      return 0;
    }
    uint64_t v16 = x_log_category_ogl_metal;
    if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134218240;
      *(void *)int64_t v34 = Width;
      *(_WORD *)&_OWORD v34[8] = 2048;
      size_t v35 = v8;
      int v17 = "%zu by %zu iosurface is too large for GPU\n";
      unint64_t v18 = v16;
      uint32_t v19 = 22;
LABEL_59:
      _os_log_impl(&dword_184668000, v18, OS_LOG_TYPE_ERROR, v17, buf, v19);
    }
    return 0;
  }
  uint64_t v11 = CA::OGL::four_cc_to_mtl_format(PixelFormat, *((_DWORD *)this + 681));
  if (v11 == 1) {
    uint64_t v12 = 10;
  }
  else {
    uint64_t v12 = v11;
  }
  if (!v12)
  {
    if (x_log_hook_p())
    {
      if ((PixelFormat & 0x80000000) != 0) {
        __maskrune(PixelFormat >> 24, 0x40000uLL);
      }
      if (BYTE2(PixelFormat) > 0x7Fu) {
        __maskrune(BYTE2(PixelFormat), 0x40000uLL);
      }
      if (BYTE1(PixelFormat) > 0x7Fu) {
        __maskrune(BYTE1(PixelFormat), 0x40000uLL);
      }
      if (PixelFormat > 0x7Fu) {
        __maskrune(PixelFormat, 0x40000uLL);
      }
      goto LABEL_36;
    }
    uint64_t v20 = x_log_category_ogl_metal;
    if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR))
    {
      unsigned int v21 = PixelFormat >> 24;
      uint64_t v22 = MEMORY[0x1E4F14390];
      if ((PixelFormat & 0x80000000) != 0) {
        int v23 = __maskrune(v21, 0x40000uLL);
      }
      else {
        int v23 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v21 + 60) & 0x40000;
      }
      if (v23) {
        int v25 = (int)PixelFormat >> 24;
      }
      else {
        int v25 = 32;
      }
      if (BYTE2(PixelFormat) <= 0x7Fu) {
        int v26 = *(_DWORD *)(v22 + 4 * BYTE2(PixelFormat) + 60) & 0x40000;
      }
      else {
        int v26 = __maskrune(BYTE2(PixelFormat), 0x40000uLL);
      }
      if (v26) {
        int v27 = SBYTE2(PixelFormat);
      }
      else {
        int v27 = 32;
      }
      if (BYTE1(PixelFormat) <= 0x7Fu) {
        int v28 = *(_DWORD *)(v22 + 4 * BYTE1(PixelFormat) + 60) & 0x40000;
      }
      else {
        int v28 = __maskrune(BYTE1(PixelFormat), 0x40000uLL);
      }
      if (v28) {
        int v29 = SBYTE1(PixelFormat);
      }
      else {
        int v29 = 32;
      }
      if (PixelFormat <= 0x7Fu) {
        int v30 = *(_DWORD *)(v22 + 4 * PixelFormat + 60) & 0x40000;
      }
      else {
        int v30 = __maskrune(PixelFormat, 0x40000uLL);
      }
      *(_DWORD *)buf = 67109888;
      int v31 = (char)PixelFormat;
      *(_DWORD *)int64_t v34 = v25;
      *(_WORD *)&v34[4] = 1024;
      if (!v30) {
        int v31 = 32;
      }
      *(_DWORD *)&v34[6] = v27;
      LOWORD(v35) = 1024;
      *(_DWORD *)((char *)&v35 + 2) = v29;
      HIWORD(v35) = 1024;
      int v36 = v31;
      int v17 = "Unsupported IOSurface pixel format: %c%c%c%c";
      unint64_t v18 = v20;
      uint32_t v19 = 26;
      goto LABEL_59;
    }
    return 0;
  }
  id v13 = (void *)[MEMORY[0x1E4F35330] texture2DDescriptorWithPixelFormat:v12 width:Width height:v8 mipmapped:0];
  [v13 setUsage:5];
  [v13 setProtectionOptions:*((void *)this + 386)];
  uint64_t v14 = (void *)[*((id *)this + 369) newTextureWithDescriptor:v13 iosurface:buffer plane:0];
  MTLPixelFormat v15 = v14;
  if (v14)
  {
    [v14 setLabel:@"com.apple.coreanimation.iosurface-destination"];
  }
  else if (x_log_hook_p())
  {
    x_log_();
  }
  else
  {
    __int32 v24 = x_log_category_ogl_metal;
    if (os_log_type_enabled((os_log_t)x_log_category_ogl_metal, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_184668000, v24, OS_LOG_TYPE_ERROR, "Unable to create MTLTexture for destination IOSurface\n", buf, 2u);
    }
  }
  return v15;
}

uint64_t CA::OGL::AsynchronousNode::retain_surface(CA::OGL::AsynchronousNode *this, float *a2, CA::Render::LayerNode *a3, float a4, double a5, double a6, double a7, float64x2_t a8)
{
  uint64_t v93 = *MEMORY[0x1E4F143B8];
  size_t v8 = (CA::OGL::Context **)*((void *)this + 1);
  size_t v9 = *v8;
  uint64_t v10 = *((void *)this + 28);
  if (v10)
  {
    uint64_t v11 = a2;
    uint64_t v13 = *((void *)this + 2);
    uint64_t v14 = *(char **)(v10 + 24);
    uint64_t v15 = *((void *)v9 + 33);
    if (v15) {
      BOOL v16 = (*(unsigned char *)(v15 + 68) & 0x30) != 0;
    }
    else {
      BOOL v16 = 0;
    }
    int v18 = *(unsigned __int8 *)(v10 + 21);
    uint64_t v76 = *((void *)this + 2);
    if (v14)
    {
      uint64_t buffer = 0;
      goto LABEL_47;
    }
    uint32_t v19 = *(int8x16_t **)(v13 + 24);
    uint64_t v20 = v19[8].i64[0];
    if (v20)
    {
      float v21 = *(float *)(v20 + 288);
    }
    else
    {
      LOBYTE(a4) = v19[2].i8[3];
      float v21 = (float)LODWORD(a4);
    }
    int8x16_t v22 = v19[4];
    int8x16_t v23 = v19[5];
    if (v21 != 1.0)
    {
      double v24 = v21;
      a8.f64[0] = 1.79769313e308;
      int8x16_t v25 = (int8x16_t)vdupq_lane_s64(vcgtq_f64(a8, (float64x2_t)v23).i64[0], 0);
      v26.i64[1] = v19[4].i64[1];
      *(double *)v26.i64 = v21 * *(double *)v22.i64;
      int8x16_t v22 = vbslq_s8(v25, v26, v22);
      v26.i64[1] = v19[5].i64[1];
      *(double *)v26.i64 = v21 * *(double *)v23.i64;
      int8x16_t v23 = vbslq_s8(v25, v26, v23);
      if (*(double *)&v23.i64[1] < 1.79769313e308)
      {
        v22.i64[1] = vmuld_lane_f64(v24, (float64x2_t)v22, 1);
        *(double *)&v23.i64[1] = *(double *)&v23.i64[1] * v24;
      }
    }
    int64x2_t v27 = vceqzq_f64((float64x2_t)v23);
    int32x4_t v28 = 0uLL;
    if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v27, 1), (int8x16_t)v27).u64[0] & 0x8000000000000000) == 0)
    {
      int8x16_t v29 = vorrq_s8((int8x16_t)vcltzq_f64((float64x2_t)v23), (int8x16_t)vcgezq_f64((float64x2_t)v23));
      if ((vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v29), 1), v29).u64[0] & 0x8000000000000000) == 0)
      {
        float64x2_t v30 = vmaxnmq_f64((float64x2_t)v22, (float64x2_t)vdupq_n_s64(0xC1BFFFFFFF000000));
        float64x2_t v31 = vminnmq_f64(vaddq_f64((float64x2_t)v22, (float64x2_t)v23), (float64x2_t)vdupq_n_s64(0x41C0000000000000uLL));
        int32x4_t v32 = (int32x4_t)vcvtmq_s64_f64(v30);
        int32x4_t v28 = vuzp1q_s32(v32, (int32x4_t)vsubq_s64(vcvtpq_s64_f64(v31), (int64x2_t)v32));
      }
    }
    int v33 = *(CA::Render::Handle **)(v10 + 32);
    uint64_t v34 = *(void *)(v13 + 16);
    size_t v35 = *(const CA::Render::LayerNode **)(v34 + 104);
    int32x4_t v75 = v28;
    if (v35 == (const CA::Render::LayerNode *)(v34 + 96)) {
      int v36 = 0;
    }
    else {
      int v36 = CA::Render::Update::build_hit_test_tree(v8[1], v35, a3, 1.0);
    }
    malloc_zone = (malloc_zone_t *)get_malloc_zone();
    uint64_t v38 = (char *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x220uLL, 0x743898A5uLL);
    uint64_t v14 = v38;
    if (v38)
    {
      CFDictionaryRef v73 = v33;
      int v74 = v11;
      int v39 = v18;
      uint64_t v40 = 0;
      uint64_t v41 = v38 + 392;
      *((_DWORD *)v38 + 3) = *(_DWORD *)(*((void *)this + 28) + 16);
      *(_OWORD *)(v38 + 24) = xmmword_184998350;
      *(_OWORD *)(v38 + 40) = xmmword_184998280;
      *(_OWORD *)(v38 + 56) = xmmword_184997E30;
      *((void *)v38 + 9) = 0;
      *((_WORD *)v38 + 40) = 0;
      *(void *)(v38 + 84) = 0x100000001;
      *(_OWORD *)(v38 + 92) = 0u;
      *(_OWORD *)(v38 + 108) = 0u;
      v38[124] = 0;
      *((_DWORD *)v38 + 37) = -1;
      *((_DWORD *)v38 + 32) = 1065353216;
      *(void *)(v38 + 140) = 0;
      *(void *)(v38 + 132) = 0;
      *((_WORD *)v38 + 76) = 0;
      *((void *)v38 + 20) = 0;
      *((void *)v38 + 21) = 0;
      *((void *)v38 + 22) = 1065353216;
      *((void *)v38 + 23) = v36;
      *((_DWORD *)v38 + 2) = 1;
      *(void *)uint64_t v38 = &unk_1ED02B6E8;
      *((_DWORD *)v38 + 52) = 0;
      do
      {
        int v42 = &v14[v40];
        *(void *)&v14[v40 + 224] = 0;
        *((void *)v42 + 30) = dispatch_semaphore_create(1);
        *((void *)v42 + 31) = dispatch_semaphore_create(1);
        v40 += 56;
      }
      while (v40 != 112);
      *((int32x4_t *)v14 + 21) = v75;
      *((float *)v14 + 88) = v21;
      *((_DWORD *)v14 + 94) = 0;
      v14[528] = v16;
      int v18 = v39;
      v14[529] = v39;
      *uint64_t v41 = xmmword_184997D50;
      *(_OWORD *)(v14 + 408) = 0u;
      *(_OWORD *)(v14 + 424) = xmmword_184997D60;
      *(_OWORD *)(v14 + 440) = 0u;
      *(_OWORD *)(v14 + 456) = 0u;
      *(_OWORD *)(v14 + 472) = xmmword_184997D50;
      *(_OWORD *)(v14 + 488) = 0u;
      *(_OWORD *)(v14 + 504) = xmmword_184997D60;
      int v33 = v73;
      uint64_t buffer = CA::OGL::AsynchronousItem::first_buffer((CA::OGL::AsynchronousItem *)v14, v9, v73);
      uint64_t v11 = v74;
      if (!buffer) {
        goto LABEL_32;
      }
    }
    else
    {
      uint64_t buffer = CA::OGL::AsynchronousItem::first_buffer(0, v9, v33);
      if (!buffer)
      {
LABEL_32:
        *((void *)v14 + 2) = v33;
        CA::Render::AsynchronousState::set_item(*((void *)this + 28), (atomic_uint *)v14);
        *(unsigned char *)(*((void *)this + 28) + 20) = 1;
        if (CA::OGL::AsynchronousDispatcher::dispatcher(void)::once != -1) {
          dispatch_once(&CA::OGL::AsynchronousDispatcher::dispatcher(void)::once, &__block_literal_global_1810);
        }
        uint64_t v45 = CA::OGL::AsynchronousDispatcher::dispatcher(void)::dispatcher;
        uint64_t v46 = *((void *)v9 + 24);
        if (v46)
        {
          uint64_t v47 = (*(uint64_t (**)(uint64_t))(*(void *)v46 + 16))(v46);
          if (v47)
          {
            double v48 = (*(double (**)(uint64_t))(*(void *)v47 + 744))(v47);
            double v49 = 0.0166666667;
            if (v48 > 0.0 && v48 * 0.95 <= 0.0166666667) {
              double v49 = round(0.0166666667 / v48) * v48;
            }
            if (v49 > v48) {
              double v48 = v49;
            }
            *(void *)(v45 + 48) = CAHostTimeWithTime(v48);
          }
        }
        os_unfair_lock_lock((os_unfair_lock_t)(v45 + 4));
        atomic_fetch_add((atomic_uint *volatile)v14 + 2, 1u);
        *((void *)v14 + 25) = v45;
        *((void *)v14 + 24) = *(void *)(v45 + 8);
        *(void *)(v45 + 8) = v14;
        ++*(_DWORD *)(v45 + 16);
        if (*(_DWORD *)v45)
        {
          __int16 v50 = *(__CFRunLoop **)(v45 + 32);
          uint64_t v51 = (const void *)*MEMORY[0x1E4F1D418];
          *(void *)&long long block = MEMORY[0x1E4F143A8];
          *((void *)&block + 1) = 0x40000000;
          *(void *)&long long v79 = ___ZN2CA3OGL22AsynchronousDispatcher13schedule_itemEPNS0_16AsynchronousItemE_block_invoke;
          *((void *)&v79 + 1) = &__block_descriptor_tmp_1;
          *(void *)&long long v80 = v45;
          CFRunLoopPerformBlock(v50, v51, &block);
          CFRunLoopWakeUp(*(CFRunLoopRef *)(v45 + 32));
        }
        os_unfair_lock_unlock((os_unfair_lock_t)(v45 + 4));
        unsigned int add = atomic_fetch_add((atomic_uint *volatile)v14 + 2, 0xFFFFFFFF);
        if (v14 && add == 1) {
          (*(void (**)(char *))(*(void *)v14 + 8))(v14);
        }
LABEL_47:
        os_unfair_lock_lock((os_unfair_lock_t)v14 + 94);
        v14[528] = v16;
        os_unfair_lock_unlock((os_unfair_lock_t)v14 + 94);
        os_unfair_lock_lock((os_unfair_lock_t)v14 + 94);
        v14[529] = v18;
        os_unfair_lock_unlock((os_unfair_lock_t)v14 + 94);
        uint64_t v53 = *((void *)this + 28);
        uint64_t v54 = v53 + 40;
        double v55 = *(double *)(v53 + 64);
        os_unfair_lock_lock((os_unfair_lock_t)v14 + 94);
        *((void *)v14 + 48) = v54;
        *((void *)v14 + 65) = CAHostTimeWithTime(v55);
        os_unfair_lock_unlock((os_unfair_lock_t)v14 + 94);
        long long block = xmmword_184997D50;
        long long v79 = 0u;
        long long v80 = xmmword_184997D60;
        long long v81 = 0u;
        long long v82 = 0u;
        v83[0] = xmmword_184997D50;
        v83[1] = 0u;
        long long v84 = xmmword_184997D60;
        v77[0] = &unk_1ED0301F0;
        v77[1] = &block;
        CA::Render::LayerNode::MapGeometry::map((uint64_t)v77, 0, *(CA::Render::LayerNode **)(*((void *)this + 2) + 16));
        os_unfair_lock_lock((os_unfair_lock_t)v14 + 94);
        long long v56 = v79;
        long long v57 = v80;
        long long v58 = v81;
        *(_OWORD *)(v14 + 392) = block;
        *(_OWORD *)(v14 + 408) = v56;
        *(_OWORD *)(v14 + 424) = v57;
        *(_OWORD *)(v14 + 440) = v58;
        long long v59 = v83[0];
        long long v60 = v83[1];
        long long v61 = v84;
        *(_OWORD *)(v14 + 456) = v82;
        *(_OWORD *)(v14 + 472) = v59;
        *(_OWORD *)(v14 + 488) = v60;
        *(_OWORD *)(v14 + 504) = v61;
        os_unfair_lock_unlock((os_unfair_lock_t)v14 + 94);
        uint64_t v62 = *((void *)v9 + 24);
        if (v62)
        {
          uint64_t v63 = (*(uint64_t (**)(uint64_t))(*(void *)v62 + 16))(v62);
          if (v63)
          {
            uint64_t v64 = v63;
            long long v91 = 0u;
            long long v92 = 0u;
            long long v89 = 0u;
            long long v90 = 0u;
            long long v87 = 0u;
            long long v88 = 0u;
            long long v85 = 0u;
            long long v86 = 0u;
            CA::WindowServer::Display::reconciled_display_attributes((CA::WindowServer::Display *)&v85, v63);
            long long v65 = v85;
            *(_OWORD *)(v14 + 88) = v89;
            *(_OWORD *)(v14 + 104) = v90;
            *(_OWORD *)(v14 + 120) = v91;
            *(_OWORD *)(v14 + 136) = v92;
            *(_OWORD *)(v14 + 24) = v65;
            *(_OWORD *)(v14 + 40) = v86;
            *(_OWORD *)(v14 + 56) = v87;
            *(_OWORD *)(v14 + 72) = v88;
            *((void *)v14 + 21) = (*(uint64_t (**)(uint64_t))(*(void *)v64 + 1400))(v64);
          }
        }
        *uint64_t v11 = 1.0;
        if (buffer) {
          goto LABEL_51;
        }
        uint64_t v66 = *(void *)(*(void *)(v76 + 16) + 24);
        unint64_t v67 = (os_unfair_lock_s *)(v14 + 208);
        os_unfair_lock_lock((os_unfair_lock_t)v14 + 52);
        uint64_t v68 = *((void *)v14 + 41);
        if (v68
          && *(void *)v68
          && ((unint64_t v69 = v66 & 0x4000000) != 0 || !dispatch_semaphore_wait(*(dispatch_semaphore_t *)(v68 + 24), 0)))
        {
          *(void *)&long long v85 = MEMORY[0x1E4F143A8];
          *((void *)&v85 + 1) = 0x40000000;
          *(void *)&long long v86 = ___ZN2CA3OGL16AsynchronousItem20retain_latest_bufferERNS0_7ContextEb_block_invoke;
          *((void *)&v86 + 1) = &__block_descriptor_tmp_8;
          LOBYTE(v88) = v69 >> 26;
          *(void *)&long long v87 = v14;
          *((void *)&v87 + 1) = v68;
          atomic_fetch_add((atomic_uint *volatile)v14 + 2, 1u);
          if (((*(uint64_t (**)(CA::OGL::Context *, long long *))(*(void *)v9 + 144))(v9, &v85) & 1) == 0) {
            ((void (*)(long long *))v86)(&v85);
          }
          CFTypeRef v71 = CFRetain(*(CFTypeRef *)v68);
          os_unfair_lock_unlock(v67);
          if (v71)
          {
            uint64_t buffer = (*(uint64_t (**)(CA::OGL::Context *, uint64_t, void, void, CFTypeRef))(*(void *)v9 + 672))(v9, 1, 0, 0, v71);
            CFRelease(v71);
            if (buffer)
            {
LABEL_51:
              *(_WORD *)(buffer + 75) = *(_WORD *)(buffer + 75) & 0xF7FF | ((v18 != 0) << 11);
LABEL_60:
              if (byte_1EB2ACC0C)
              {
                uint64_t v72 = *(void *)(*((void *)this + 2) + 104);
                if (v72) {
                  *(_DWORD *)(v72 + 220) = *(_DWORD *)(v72 + 220) & 0xFFF1FFFF | 0x20000;
                }
              }
              return buffer;
            }
          }
        }
        else
        {
          os_unfair_lock_unlock((os_unfair_lock_t)v14 + 52);
        }
        uint64_t buffer = *((void *)v9 + 35);
        if (buffer
          || (uint64_t buffer = (*(uint64_t (**)(CA::OGL::Context *))(*(void *)v9 + 728))(v9),
              (*((void *)v9 + 35) = buffer) != 0))
        {
          ++*(_DWORD *)buffer;
        }
        goto LABEL_60;
      }
    }
    float v44 = 1.0;
    if (!v16) {
      CA::Render::Update::render_edr_factor(v8[1], v43);
    }
    memset(v83, 0, sizeof(v83));
    LODWORD(v84) = 0;
    long long v81 = 0u;
    long long v82 = 0u;
    long long v79 = 0u;
    long long v80 = 0u;
    long long block = 0u;
    *(int8x8_t *)((char *)v83 + 12) = vand_s8((int8x8_t)(vcvts_n_s32_f32(v44, 0x14uLL) | 0x10000000000000), (int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(v44 != 0.0), 0x1FuLL)));
    IOSurfaceSetBulkAttachments2();
    uint64_t buffer = (*(uint64_t (**)(CA::OGL::Context *, uint64_t, void, void, uint64_t))(*(void *)v9 + 672))(v9, 1, 0, 0, buffer);
    if (buffer)
    {
      CA::OGL::Context::push_surface((uint64_t)v9, buffer, 1u, 0, 0);
      CA::OGL::ImagingNode::render(*((void *)this + 3), 0, 0);
      CA::OGL::Context::pop_surface(v9);
    }
    goto LABEL_32;
  }
  uint64_t buffer = *((void *)v9 + 35);
  if (buffer
    || (uint64_t buffer = (*(uint64_t (**)(CA::OGL::Context *, float *))(*(void *)v9 + 728))(*v8, a2),
        (*((void *)v9 + 35) = buffer) != 0))
  {
    ++*(_DWORD *)buffer;
  }
  return buffer;
}

uint64_t CA::WindowServer::IOMFBDisplay::protection_options(CA::WindowServer::IOMFBDisplay *this)
{
  int v1 = (*((unsigned __int16 *)this + 328) >> 10) & 7;
  if (!v1) {
    return 7;
  }
  if (v1 == 2)
  {
    if (byte_1EB2ACC8D) {
      IOMobileFramebufferGetProtectionOptions();
    }
    return 0;
  }
  else
  {
    for (int i = 5; ; --i)
    {
      int ProtectionOptions = IOMobileFramebufferGetProtectionOptions();
      if (!ProtectionOptions || i == 0) {
        break;
      }
      usleep(0x186A0u);
    }
    if (ProtectionOptions)
    {
      if (CADeviceSupportsUniversalCompression::once != -1) {
        dispatch_once(&CADeviceSupportsUniversalCompression::once, &__block_literal_global_37_12054);
      }
      if (CADeviceSupportsUniversalCompression::universal) {
        return 7;
      }
      else {
        return 0;
      }
    }
    else
    {
      return (*((_WORD *)this + 328) & 0x1C00) == 1024;
    }
  }
}

char *CA::Render::Update::build_hit_test_tree(CA::Render::Update *this, const CA::Render::LayerNode *a2, CA::Render::LayerNode *a3, double a4)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  kdebug_trace();
  malloc_zone = (malloc_zone_t *)get_malloc_zone();
  size_t v8 = (char *)malloc_type_zone_calloc(malloc_zone, 1uLL, 0x40uLL, 0x743898A5uLL);
  size_t v9 = v8;
  if (v8)
  {
    *(_DWORD *)size_t v8 = 0;
    *(_OWORD *)(v8 + 24) = 0u;
    *(_OWORD *)(v8 + 40) = 0u;
    *((_DWORD *)v8 + 14) = 1065353216;
    os_unfair_lock_lock((os_unfair_lock_t)&CA::Render::HitTestTree::storage_cache_lock);
    uint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = (_OWORD *)CA::Render::HitTestTree::storage_cache[v10];
      if (v11) {
        break;
      }
      if (++v10 == 2)
      {
        os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::HitTestTree::storage_cache_lock);
        uint64_t v11 = malloc_type_malloc(4 * *MEMORY[0x1E4F14B00], 0x1801C8F5uLL);
        goto LABEL_8;
      }
    }
    CA::Render::HitTestTree::storage_cache[v10] = 0;
    os_unfair_lock_unlock((os_unfair_lock_t)&CA::Render::HitTestTree::storage_cache_lock);
LABEL_8:
    uint64_t v12 = (_DWORD *)MEMORY[0x1E4F14B00];
    *(_DWORD *)size_t v9 = 1;
    int v13 = 4 * *v12;
    *((_DWORD *)v9 + 1) = 0;
    *((_DWORD *)v9 + 2) = v13;
    *((void *)v9 + 2) = v11;
  }
  else
  {
    uint64_t v11 = (_OWORD *)MEMORY[0x10];
  }
  int v14 = 0;
  v11[11] = 0u;
  v11[12] = 0u;
  v11[9] = 0u;
  v11[10] = 0u;
  v11[7] = 0u;
  v11[8] = 0u;
  v11[5] = 0u;
  v11[6] = 0u;
  v11[3] = 0u;
  v11[4] = 0u;
  v11[1] = 0u;
  v11[2] = 0u;
  *uint64_t v11 = 0u;
  *((_DWORD *)v9 + 1) += 208;
  unsigned int v23 = 0;
  if (byte_1EB2ACC2F)
  {
    int v14 = 2;
    if (a2)
    {
LABEL_11:
      uint64_t v15 = *((void *)a2 + 5);
      if (v15 && (uint64_t v16 = *(void *)(v15 + 24)) != 0) {
        unsigned int v17 = *(_DWORD *)(v16 + 16);
      }
      else {
        unsigned int v17 = 0;
      }
      CA::Render::HitTestTree::append_root_node((CA::Render::HitTestTree *)v9, a2, v17, v14, &v23);
      goto LABEL_20;
    }
  }
  else if (a2)
  {
    goto LABEL_11;
  }
  int v18 = (CA::Render::Update *)((char *)this + 216);
  uint32_t v19 = (const CA::Render::LayerNode *)*((void *)this + 28);
  if (v19 != (CA::Render::Update *)((char *)this + 216))
  {
    uint64_t v20 = (char *)this + 208;
    do
    {
      uint64_t v20 = *(char **)v20;
      CA::Render::HitTestTree::append_root_node((CA::Render::HitTestTree *)v9, v19, *((_DWORD *)v20 + 2), v14, &v23);
      uint32_t v19 = (const CA::Render::LayerNode *)*((void *)v19 + 1);
    }
    while (v19 != v18);
  }
LABEL_20:
  uint64_t v21 = *((void *)v9 + 2);
  *(void *)(v21 + 8) = *(void *)(v21 + 8) & 0xFFFFFF0000000000 | v23 | 0x800D0FF000000;
  *(_OWORD *)(v21 + 80) = xmmword_184997D50;
  *(_OWORD *)(v21 + 96) = 0u;
  *(_OWORD *)(v21 + 112) = xmmword_184997D60;
  *(_OWORD *)(v21 + 128) = 0u;
  *(_OWORD *)(v21 + 144) = 0u;
  *(_OWORD *)(v21 + 160) = xmmword_184997D50;
  *(_OWORD *)(v21 + 176) = 0u;
  *(_OWORD *)(v21 + 192) = xmmword_184997D60;
  *(double *)(v21 + 80) = a4;
  *(double *)(v21 + 120) = a4;
  *(void *)(v21 + 160) = 0x3FF0000000000000;
  kdebug_trace();
  return v9;
}

uint64_t CA::Render::HitTestTree::append_root_node(CA::Render::HitTestTree *this, const CA::Render::LayerNode *a2, unsigned int a3, int a4, unsigned int *a5)
{
  int v6 = a4;
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *((void *)a2 + 5);
  if (v10)
  {
    uint64_t v11 = *(void *)(v10 + 24);
    if (v11)
    {
      unsigned int v12 = *(unsigned __int16 *)(v11 + 552);
      int v6 = (v12 >> 1) & 4 | a4;
      if ((v12 & 0x10) != 0) {
        std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>((uint64_t)this + 24, a3, a3);
      }
    }
  }
  unsigned __int16 v14 = 0;
  uint64_t result = CA::Render::HitTestTree::append_layer_node(this, a2, 0, a3, v6, &v14);
  if (result) {
    ++*a5;
  }
  return result;
}

uint64_t CA::Render::HitTestTree::append_layer_node(CA::Render::HitTestTree *this, const CA::Render::LayerNode *a2, int a3, unsigned int a4, int a5, unsigned __int16 *a6)
{
  uint64_t v94 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *((void *)a2 + 3);
  uint64_t v11 = *((void *)a2 + 4);
  unsigned int v12 = ((v10 & 0x18) != 0) | a5;
  uint64_t v13 = ((v10 & 0x18) != 0) | a5 & 1u;
  if (*((_DWORD *)a2 + 29)) {
    BOOL v14 = (v10 & 0x200) == 0;
  }
  else {
    BOOL v14 = 0;
  }
  if (v14)
  {
    uint64_t v16 = *(void *)(v11 + 40);
    BOOL v17 = (v10 & 0x400000) == 0;
    if (!v13) {
      BOOL v17 = (int)v16 >= 0;
    }
    int v15 = (int)v16 >= 0 || v17;
  }
  else
  {
    int v15 = 1;
  }
  uint64_t v18 = *(void *)(v11 + 144);
  if (!a4)
  {
    if (v18)
    {
      if ((*(unsigned char *)(v18 + 99) & 4) != 0) {
        char v44 = 0;
      }
      else {
        char v44 = v15;
      }
      if ((v44 & 1) == 0) {
        goto LABEL_12;
      }
    }
    else if ((v15 & 1) == 0)
    {
      goto LABEL_12;
    }
    return 0;
  }
LABEL_12:
  uint64_t v20 = *((unsigned int *)this + 1);
  unint64_t v19 = *((unsigned int *)this + 2);
  if (v20 + 240 <= v19)
  {
    unsigned int v23 = (char *)*((void *)this + 2);
  }
  else
  {
    size_t v21 = (2 * v19);
    *((_DWORD *)this + 2) = v21;
    unsigned int v22 = v12;
    unsigned int v23 = (char *)malloc_type_realloc(*((void **)this + 2), v21, 0x83A9C038uLL);
    unsigned int v12 = v22;
    *((void *)this + 2) = v23;
  }
  int v92 = *(_DWORD *)(v11 + 12);
  uint64_t v24 = &v23[v20];
  *((_OWORD *)v24 + 3) = 0u;
  *((_OWORD *)v24 + 4) = 0u;
  *((_OWORD *)v24 + 1) = 0u;
  *((_OWORD *)v24 + 2) = 0u;
  *(_OWORD *)uint64_t v24 = 0u;
  *(_DWORD *)uint64_t v24 = v20 - a3;
  uint64_t v25 = 0x10000000000;
  if (!v15) {
    uint64_t v25 = 0;
  }
  uint64_t v26 = v25 | (*((_DWORD *)a2 + 29) << 24);
  *((void *)v24 + 1) = v26;
  unint64_t v27 = v26 & 0xFFFFFDFFFFFFFFFFLL | (((*(void *)(v11 + 40) >> 6) & 1) << 41);
  *((void *)v24 + 1) = v27;
  unint64_t v28 = v27 & 0xFFFFF7FFFFFFFFFFLL | (((*(void *)(v11 + 40) >> 39) & 1) << 43);
  *((void *)v24 + 1) = v28;
  uint64_t v29 = (v13 << 45) | ((*((void *)a2 + 3) & 1) << 44) | v28;
  *((void *)v24 + 1) = v29;
  unint64_t v30 = v29 | ((unint64_t)(*((void *)a2 + 16) != 0) << 47);
  *((void *)v24 + 1) = v30;
  if ((*(unsigned char *)(v11 + 45) & 4) != 0 || (uint64_t v31 = *(void *)(v11 + 128)) != 0 && (uint64_t v31 = *(void *)(v31 + 80)) != 0) {
    uint64_t v31 = 0x1000000000000;
  }
  unint64_t v32 = v31 | v30;
  *((void *)v24 + 1) = v32;
  uint64_t v33 = *(void *)(v11 + 96);
  unint64_t v34 = v32 | ((unint64_t)(v33 != 0) << 49);
  *((void *)v24 + 1) = v34;
  if (v33)
  {
    if ((*(_DWORD *)(v11 + 36) & 0xF000) != 0x9000
      || (*(unsigned char *)(v11 + 44) & 1) != 0
      || (uint64_t v35 = *(void *)(v11 + 128)) != 0 && *(void *)(v35 + 32))
    {
      uint64_t v33 = 0;
    }
    else
    {
      uint64_t v33 = 0x4000000000000;
    }
  }
  unint64_t v36 = v33 | v34;
  *((void *)v24 + 1) = v36;
  unint64_t v37 = *(void *)(v11 + 128);
  if (v37)
  {
    unint64_t v37 = *(void *)(v37 + 96);
    if (v37)
    {
      uint64_t v38 = *(unsigned int *)(v37 + 16);
      if (v38)
      {
        int v39 = (uint64_t *)(v37 + 24);
        uint64_t v40 = 8 * v38 - 8;
        do
        {
          uint64_t v41 = *v39++;
          int v42 = *(_DWORD *)(v41 + 24);
          BOOL v43 = v42 != 100 || v40 == 0;
          v40 -= 8;
        }
        while (!v43);
        unint64_t v37 = (unint64_t)(v42 != 100) << 46;
      }
      else
      {
        unint64_t v37 = 0;
      }
    }
  }
  unint64_t v46 = v36 & 0xFFFFBFFFFFFFFFFFLL | v37;
  *((void *)v24 + 1) = v46;
  uint64_t v47 = (*((void *)a2 + 3) << 33) & 0x800000000000000 | v46;
  *((void *)v24 + 1) = v47;
  *((_DWORD *)v24 + 6) = a4;
  if ((v92 & 0x400) != 0 && v18) {
    *((_DWORD *)v24 + 7) = *(_DWORD *)(v18 + 84);
  }
  *((_OWORD *)v24 + 2) = *((_OWORD *)a2 + 11);
  long long v48 = *(_OWORD *)(v11 + 80);
  *((_OWORD *)v24 + 3) = *((_OWORD *)a2 + 12);
  *((_OWORD *)v24 + 4) = v48;
  if (*((void *)a2 + 7))
  {
    v47 |= 0x8000000000000uLL;
    *((void *)v24 + 1) = v47;
    double v49 = (long long *)*((void *)a2 + 7);
    long long v50 = *v49;
    long long v51 = v49[1];
    long long v52 = v49[3];
    *((_OWORD *)v24 + 7) = v49[2];
    *((_OWORD *)v24 + 8) = v52;
    *((_OWORD *)v24 + 5) = v50;
    *((_OWORD *)v24 + 6) = v51;
    long long v53 = v49[4];
    long long v54 = v49[5];
    long long v55 = v49[7];
    *((_OWORD *)v24 + 11) = v49[6];
    *((_OWORD *)v24 + 12) = v55;
    *((_OWORD *)v24 + 9) = v53;
    *((_OWORD *)v24 + 10) = v54;
    unsigned int v56 = 16;
  }
  else if (*((double *)a2 + 8) == 0.0 && *((double *)a2 + 9) == 0.0)
  {
    unsigned int v56 = 0;
  }
  else
  {
    v47 |= 0x10000000000000uLL;
    *((void *)v24 + 1) = v47;
    *((_OWORD *)v24 + 5) = *((_OWORD *)a2 + 4);
    unsigned int v56 = 2;
  }
  long long v57 = *(float32x4_t **)(v11 + 128);
  if (!v57) {
    goto LABEL_74;
  }
  if (v57[14].f32[3] > 0.0
    && ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqzq_f32(v57[15])))) & 1) != 0 || v57[8].i64[0]))
  {
    *((void *)v24 + 1) = v47 | 0x20000000000000;
    long long v57 = *(float32x4_t **)(v11 + 128);
    if (!v57)
    {
      unsigned int v60 = 0;
      long long v61 = (unsigned int *)&v24[8 * v56];
      v56 |= 1u;
      *((void *)v61 + 10) = 0;
      goto LABEL_75;
    }
    float v58 = v57[14].f32[2];
    unsigned int v59 = v56 | 1;
    *(double *)&v24[8 * v56 + 80] = v57[14].f32[3];
    if (v58 == 0.0)
    {
      v56 |= 1u;
      v47 |= 0x20000000000000uLL;
    }
    else
    {
      v47 |= 0x60000000000000uLL;
      *((void *)v24 + 1) = v47;
      v56 += 2;
      long long v57 = *(float32x4_t **)(v11 + 128);
      *(double *)&v24[8 * v59 + 80] = v58;
      if (!v57) {
        goto LABEL_74;
      }
    }
  }
  float v62 = v57[14].f32[1];
  if (v62 > 0.0)
  {
    *((void *)v24 + 1) = v47 | 0x80000000000000;
    *(double *)&v24[8 * v56 + 80] = v62;
    long long v57 = *(float32x4_t **)(v11 + 128);
    if (!v57)
    {
      unsigned int v60 = 0;
      ++v56;
      goto LABEL_75;
    }
    ++v56;
  }
  uint64_t v63 = v57->i64[0];
  if (!v57->i64[0]) {
    goto LABEL_74;
  }
  int v64 = *(unsigned __int8 *)(v63 + 12);
  if (v64 == 40)
  {
    unsigned int v60 = *(_DWORD *)(v63 + 40);
    uint64_t v84 = *(void *)(v63 + 56);
    if (v84)
    {
      unsigned int v85 = *(_DWORD *)(v84 + 12);
      unsigned int v12 = (v85 >> 8) & 4 | v12 & 0xFFFFFFFB;
      if ((v85 & 0x800) != 0) {
        goto LABEL_125;
      }
    }
  }
  else
  {
    if (v64 != 30)
    {
LABEL_74:
      unsigned int v60 = 0;
      goto LABEL_75;
    }
    unsigned int v60 = *(_DWORD *)(v63 + 16);
    uint64_t v65 = *(void *)(v63 + 72);
    if (!v65)
    {
      LOWORD(v12) = v12 & 0xFFFB;
      goto LABEL_75;
    }
    unsigned int v66 = *(unsigned __int16 *)(v65 + 552);
    unsigned int v12 = (v66 >> 1) & 4 | v12 & 0xFFFFFFFB;
    if ((v66 & 0x10) != 0)
    {
LABEL_125:
      __int16 v86 = v12;
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>((uint64_t)this + 24, v60, v60);
      LOWORD(v12) = v86;
    }
  }
LABEL_75:
  if ((v12 & 4) != 0)
  {
    if ((*(unsigned char *)(v11 + 39) & 2) != 0 || (uint64_t v67 = *(unsigned int *)v24, v67) && (v24[-v67 + 15] & 2) != 0) {
      *((void *)v24 + 1) |= 0x200000000000000uLL;
    }
  }
  if (*(double *)(v11 + 64) == 0.0)
  {
    uint64_t v68 = *((void *)v24 + 1);
    if (*(double *)(v11 + 72) == 0.0) {
      goto LABEL_84;
    }
  }
  else
  {
    uint64_t v68 = *((void *)v24 + 1);
  }
  v68 |= 0x100000000000000uLL;
  *((void *)v24 + 1) = v68;
  unsigned int v69 = v56 + 1;
  *(void *)&v24[8 * v56 + 80] = *(void *)(v11 + 64);
  v56 += 2;
  *(void *)&v24[8 * v69 + 80] = *(void *)(v11 + 72);
LABEL_84:
  unsigned __int16 v70 = v12;
  if ((*((unsigned char *)a2 + 26) & 4) != 0)
  {
    v68 |= 0x40000000000uLL;
    *((void *)v24 + 1) = v68;
    CFTypeRef v71 = (unsigned int *)&v24[8 * v56];
    LOBYTE(v56) = v56 + 1;
    *((double *)v71 + 10) = *((float *)a2 + 68);
  }
  unsigned __int16 v93 = 0;
  int v72 = (8 * (_BYTE)v56 + 80) & 0xF8;
  *((void *)v24 + 1) = v68 & 0xFFFFFF00FFFFFFFFLL | ((unint64_t)(v72 >> 3) << 35);
  *((_DWORD *)this + 1) += v72;
  if (v24[13] < 0
    && (CA::Render::HitTestTree::append_layer_node(this, *((const CA::Render::LayerNode **)a2 + 16), v20, v60, v12, &v93) & 1) == 0)
  {
    if ((*(unsigned char *)(v11 + 40) & 0x80) == 0)
    {
      uint64_t result = 0;
      *((_DWORD *)this + 1) -= *(unsigned __int8 *)(*((void *)this + 2) + v20 + 12);
      return result;
    }
    *((void *)v24 + 1) &= ~0x800000000000uLL;
  }
  uint64_t v73 = *((void *)a2 + 13);
  if ((const CA::Render::LayerNode *)v73 == (const CA::Render::LayerNode *)((char *)a2 + 96))
  {
    int v74 = 0;
    int32x4_t v75 = a6;
  }
  else
  {
    int v74 = 0;
    int32x4_t v75 = a6;
    do
    {
      if (*(void *)(*(void *)(v73 + 32) + 144) || (*(unsigned char *)(v73 + 27) & 4) != 0) {
        v74 += CA::Render::HitTestTree::append_layer_node(this, (const CA::Render::LayerNode *)v73, v20, v60, v70, &v93);
      }
      uint64_t v73 = *(void *)(v73 + 8);
    }
    while ((const CA::Render::LayerNode *)v73 != (const CA::Render::LayerNode *)((char *)a2 + 96));
  }
  uint64_t v76 = *((void *)this + 2) + v20;
  *(_DWORD *)(v76 + 4) = *((_DWORD *)this + 1) - v20;
  uint64_t v77 = *(void *)(v76 + 8);
  *(void *)(v76 + 8) = v77 & 0xFFFFFFFFFF000000 | *(void *)&v74 & 0xFFFFFFLL;
  size_t v78 = *(void **)(v11 + 128);
  if (v78 && *v78
    || (v70 & 2) != 0
    || ((v77 & 0x6000000000000) != 0x2000000000000 ? (BOOL v79 = (v92 & 0x400) == 0) : (BOOL v79 = 0),
        !v79 || (*(unsigned char *)(v11 + 40) & 0x80) != 0 || (char v80 = v93, (v93 & 0x20) != 0) || (v77 & 0x20000000000000) != 0))
  {
    long long v81 = (atomic_uint *)(v11 + 8);
    if (!atomic_fetch_add((atomic_uint *volatile)(v11 + 8), 1u))
    {
      uint64_t v11 = 0;
      atomic_fetch_add(v81, 0xFFFFFFFF);
    }
    *(void *)(v76 + 16) = v11;
    char v80 = v93;
    if ((v93 & 0x20) == 0) {
      goto LABEL_111;
    }
LABEL_117:
    *v75 |= 0x20u;
    uint64_t v82 = *(void *)(v76 + 8);
    if ((v82 & 0x800000000000) != 0)
    {
      uint64_t v87 = v76 + BYTE4(v82);
      if (!*(void *)(v87 + 16))
      {
        uint64_t v88 = *((void *)a2 + 16);
        if (v88)
        {
          uint64_t v89 = *(void *)(v88 + 32);
          if (v89)
          {
            long long v90 = (atomic_uint *)(v89 + 8);
            if (!atomic_fetch_add((atomic_uint *volatile)(v89 + 8), 1u))
            {
              uint64_t v89 = 0;
              atomic_fetch_add(v90, 0xFFFFFFFF);
            }
            *(void *)(v87 + 16) = v89;
          }
        }
      }
    }
    goto LABEL_118;
  }
  if ((v93 & 0x20) != 0) {
    goto LABEL_117;
  }
LABEL_111:
  if (*((void *)this + 6)
    && std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>((void *)this + 3, *(_DWORD *)(v76 + 24)))
  {
    *v75 |= 0x20u;
  }
LABEL_118:
  uint64_t v83 = *(void *)(v76 + 8);
  if ((v80 & 0x10) != 0 || (v83 & 0x200000000000000) != 0)
  {
    *(void *)(v76 + 8) = v83 | 0x400000000000000;
    *v75 |= 0x10u;
  }
  return 1;
}