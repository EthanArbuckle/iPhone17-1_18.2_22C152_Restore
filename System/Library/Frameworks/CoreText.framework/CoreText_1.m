void setOpticalSizeComponent(const __CFString *a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, const void *a6, atomic_ullong *a7, uint64_t a8, double a9, double a10, double a11, double a12, const void *a13)
{
  CFAllocatorRef *v23;
  double v24;
  CFNumberRef v25;
  CFNumberRef v26;
  CFNumberRef v27;
  uint64_t v28;
  const void *v29;
  double valuePtr;

  setNameWithGrade(a1, a5, a7);
  if (a9 >= 0.0) {
    CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit(a7, memory_order_acquire), @"opticalSize", (const void *)[NSNumber numberWithDouble:a9]);
  }
  if (a13) {
    CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit(a7, memory_order_acquire), @"familyName", a13);
  }
  v23 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
  if (a10 > 0.0)
  {
    v24 = *(double *)(a2 + 8) * a10 / a9 - (double)(*(_DWORD *)(a2 + 24) - *(_DWORD *)(a2 + 28));
    if (a4 == 1 || (a3 - 61) <= 3)
    {
      DetermineLanguageSpecificParameters();
      if (byte_1EB2CDB29) {
        v24 = v24 + 1.0;
      }
    }
    valuePtr = v24;
    v25 = CFNumberCreate(*v23, kCFNumberDoubleType, &valuePtr);
    CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit(a7, memory_order_acquire), @"leadingOverride", v25);
  }
  if (a11 != 0.0)
  {
    valuePtr = a11;
    v26 = CFNumberCreate(*v23, kCFNumberDoubleType, &valuePtr);
    CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit(a7, memory_order_acquire), @"lineSpacingOverrideRatio", v26);
  }
  if (*(_DWORD *)(a2 + 32)) {
    CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit(a7, memory_order_acquire), @"capHeight", (const void *)objc_msgSend(NSNumber, "numberWithInt:"));
  }
  if (a12 != 0.0)
  {
    valuePtr = a12;
    v27 = CFNumberCreate(*v23, kCFNumberDoubleType, &valuePtr);
    CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit(a7, memory_order_acquire), @"trackingAmount", v27);
  }
  if (a3 <= 0x144)
  {
    if (qword_1EB2CDB80 != -1) {
      dispatch_once(&qword_1EB2CDB80, &__block_literal_global_1698);
    }
    v28 = objc_msgSend((id)qword_1EB2CDB78, "objectForKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedInt:", a3));
    if (v28)
    {
      v29 = (const void *)v28;
      if (a8) {
        v29 = (const void *)[NSString stringWithFormat:@"%@-%@", v28, a8];
      }
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit(a7, memory_order_acquire), @"NSCTFontUIUsageAttribute", v29);
    }
  }
  if (a6) {
    CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit(a7, memory_order_acquire), @"UnicodeCharSetTrim", a6);
  }
}

void setNameWithGrade(const __CFString *value, uint64_t a2, atomic_ullong *a3)
{
  if (a2)
  {
    v5 = (__CFString *)CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@G%u", value, a2);
    CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit(a3, memory_order_acquire), @"name", v5);
  }
  else
  {
    explicit = (__CFDictionary *)atomic_load_explicit(a3, memory_order_acquire);
    CFDictionaryAddValue(explicit, @"name", value);
  }
}

void CreateSplicedFontFromStash(atomic_ullong *a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, void *a4@<X8>)
{
  uint64_t v7 = TSplicedFont::Create(a2, (uint64_t)&kAdopted, (void *)atomic_exchange(a1, 0));
  if (v7)
  {
    if (a3) {
      int v8 = 4;
    }
    else {
      int v8 = 1028;
    }
    if (a2) {
      int v8 = 0;
    }
    int v11 = v8;
    uint64_t v9 = v7;
    TCFBase_NEW<CTFontDescriptor,TBaseFont const*&,unsigned int &>(&v9, &v11, &v10);
    *a4 = atomic_exchange((atomic_ullong *volatile)&v10, 0);
  }
  else
  {
    *a4 = 0;
  }
}

uint64_t TSplicedFont::Create(uint64_t a1, uint64_t a2, void *a3)
{
  id v6 = (id)0xAAAAAAAAAAAAAAAALL;
  id v7 = a3;
  TSplicedFont::CreateCascadeList((atomic_ullong *)&v7, (const TSplicedFontDict *)((a1 != 0) << 17), &v6);
  if (atomic_load_explicit((atomic_ullong *volatile)&v6, memory_order_acquire))
  {
    CFArrayRef explicit = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v6, memory_order_acquire);
    if (explicit && CFArrayGetValueAtIndex(explicit, 0)) {
      operator new();
    }
    atomic_load_explicit((atomic_ullong *volatile)&v6, memory_order_acquire);
  }
  else
  {
    CFDictionaryRef v4 = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v7, memory_order_acquire);
    if (v4) {
      CFDictionaryGetValue(v4, @"Components");
    }
  }

  return 0;
}

uint64_t TBaseFont::TBaseFont(uint64_t a1, id a2, void *a3)
{
  *(_DWORD *)(a1 + 8) = 0;
  *(void *)a1 = &unk_1ED05F4D8;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(void *)(a1 + 80) = a2;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = a3;
  *(void *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 112) = 0;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_DWORD *)(a1 + 184) = 805306368;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(void *)(a1 + 232) = 0;
  *(void *)(a1 + 240) = 0;
  v5 = (_OWORD *)MEMORY[0x1E4F1DAD8];
  id v6 = (_OWORD *)MEMORY[0x1E4F1DB28];
  *(_DWORD *)(a1 + 248) = 0;
  long long v7 = v6[1];
  *(_OWORD *)(a1 + 304) = *v6;
  *(_OWORD *)(a1 + 320) = v7;
  *(_OWORD *)(a1 + 288) = *v5;
  *(unsigned char *)(a1 + 336) = 0;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_OWORD *)(a1 + 360) = 0u;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_DWORD *)(a1 + 392) = 1065353216;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 416) = 0u;
  *(_DWORD *)(a1 + 432) = 1065353216;
  *(_WORD *)(a1 + 440) = -1;
  *(void *)(a1 + 460) = 0;
  *(_DWORD *)(a1 + 468) = 0;
  *(void *)(a1 + 444) = 0;
  *(void *)(a1 + 452) = 0;
  *(void *)(a1 + 480) = a1 + 472;
  *(void *)(a1 + 488) = 0;
  *(void *)(a1 + 496) = 0;
  *(void *)(a1 + 504) = 0;
  *(void *)(a1 + 544) = a1 + 512;
  *(_OWORD *)(a1 + 568) = 0u;
  *(_OWORD *)(a1 + 584) = 0u;
  *(_OWORD *)(a1 + 552) = 0u;
  TBaseFont::Init((atomic_ullong *)a1, 0);
  return a1;
}

CFURLRef TSplicedFont::SynthesiseURL@<X0>(TSplicedFont *this@<X0>, CFURLRef *a2@<X8>)
{
  CFStringRef v4 = (const __CFString *)[@"file://system-synthetic-spliced-font#postscript-name=" stringByAppendingString:this];
  CFURLRef result = CFURLCreateWithString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v4, 0);
  *a2 = result;
  return result;
}

__CFString *GetLocalizedTrimSetKey(__CFString *a1, unsigned int *a2)
{
  id v5 = (id)0xAAAAAAAAAAAAAAAALL;
  LanguageNormalizedForPresetFallbacks(a1, (atomic_ullong *)&v5);
  LocalizedTrimSetKeyForNormalizedLanguage = GetLocalizedTrimSetKeyForNormalizedLanguage((__CFString *)atomic_load_explicit((atomic_ullong *volatile)&v5, memory_order_acquire), a2);

  return LocalizedTrimSetKeyForNormalizedLanguage;
}

__CFString *GetLocalizedTrimSetKeyForNormalizedLanguage(__CFString *cf1, unsigned int *a2)
{
  if (cf1 == @"zh-Hans" || cf1 && CFEqual(cf1, @"zh-Hans"))
  {
    unsigned int v4 = 1;
LABEL_25:
    *a2 = v4;
    return @"system-ui";
  }
  if (cf1 == @"zh-Hant" || cf1 && CFEqual(cf1, @"zh-Hant"))
  {
    unsigned int v4 = 2;
    goto LABEL_25;
  }
  if (cf1 == @"zh-HK" || cf1 && CFEqual(cf1, @"zh-HK"))
  {
    unsigned int v4 = 4;
    goto LABEL_25;
  }
  if (cf1 == @"zh-MO" || cf1 && CFEqual(cf1, @"zh-MO"))
  {
    unsigned int v4 = 8;
    goto LABEL_25;
  }
  if (cf1 == @"ja" || cf1 && CFEqual(cf1, @"ja"))
  {
    unsigned int v4 = 16;
    goto LABEL_25;
  }
  if (cf1 == @"ar" || cf1 && CFEqual(cf1, @"ar"))
  {
    unsigned int v4 = 32;
    goto LABEL_25;
  }
  if (cf1 == @"hi" || cf1 && CFEqual(cf1, @"hi"))
  {
    id v9 = (id)0xAAAAAAAAAAAAAAAALL;
    CopyPreferredNumberingSystem((uint64_t *)&v9);
    id v6 = (__CFString *)(id)atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire);
    if (v6 == @"deva")
    {
    }
    else
    {
      long long v7 = v6;
      if (!v6)
      {

LABEL_37:
        return 0;
      }
      int v8 = CFEqual(v6, @"deva");

      if (!v8) {
        goto LABEL_37;
      }
    }
    *a2 = 64;

    return @"system-ui";
  }
  return 0;
}

void LanguageNormalizedForPresetFallbacks(__CFString *a1@<X0>, atomic_ullong *a2@<X8>)
{
  *a2 = 0xAAAAAAAAAAAAAAAALL;
  if (a1) {
    LanguageIdentifierByNormalizing(a1, 0, a2);
  }
  else {
    CreateNormalizedPreferredLanguage(0, a2);
  }
}

void CreateNormalizedPreferredLanguage(unsigned int a1@<W0>, atomic_ullong *a2@<X8>)
{
  id v4 = (id)0xAAAAAAAAAAAAAAAALL;
  CopyPreferredLanguage((atomic_ullong *)&v4);
  LanguageIdentifierByNormalizing((__CFString *)atomic_load_explicit((atomic_ullong *volatile)&v4, memory_order_acquire), a1, a2);
}

void LanguageIdentifierByNormalizing(__CFString *a1@<X0>, unsigned int a2@<W1>, atomic_ullong *a3@<X8>)
{
  if (!a1)
  {
    *a3 = 0;
    return;
  }
  os_unfair_lock_lock_with_options();
  uint64_t v6 = a2;
  long long v7 = *(const void **)&_MergedGlobals_17[8 * a2 + 104];
  if (v7)
  {
    if (*(_DWORD *)&_MergedGlobals_17[4 * a2 + 88] == TGenerationSeed::sGeneration) {
      goto LABEL_6;
    }
    CFRelease(v7);
  }
  v59.data = (char *)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  v59.info = atomic_exchange((atomic_ullong *volatile)&v59.data, 0);

  int v8 = &_MergedGlobals_17[8 * a2];
  *((void *)v8 + 13) = atomic_exchange(&v59.info, 0);

  *(_DWORD *)&_MergedGlobals_17[4 * a2 + 88] = TGenerationSeed::sGeneration;
  long long v7 = (const void *)*((void *)v8 + 13);
LABEL_6:
  *a3 = 0xAAAAAAAAAAAAAAAALL;
  v59.data = (char *)(id)CFDictionaryGetValue((CFDictionaryRef)v7, a1);
  *a3 = atomic_exchange((atomic_ullong *volatile)&v59.data, 0);

  if (!atomic_load_explicit(a3, memory_order_acquire))
  {
    if (a1 == @"zh" || CFStringHasPrefix(a1, @"zh"))
    {
      v59.data = (char *)a1;
      CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      v59.info = (uint64_t)CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&v59.data, 1, MEMORY[0x1E4F1D510]);
      if (!a2)
      {
        if (a1 == @"zh-Hant"
          || (int v10 = CFEqual(a1, @"zh-Hant"), a1 == @"zh")
          || v10
          || CFEqual(a1, @"zh"))
        {
          CFArrayRef v11 = (const __CFArray *)[&unk_1ED07E500 objectForKeyedSubscript:a1];
          CFArrayRef v12 = CFLocaleCopyPreferredLanguages();
          CFArrayRef v13 = CFBundleCopyLocalizationsForPreferences(v11, v12);
          CFArrayRef v14 = v13;
          if (v14)
          {
            CFArrayRef v15 = v14;
            CFIndex Count = CFArrayGetCount(v14);

            if (Count) {
              TCFRef<__CTFont const*>::Retain(&v59.info, v13);
            }
          }
          else
          {
          }
        }
      }
      if (a2 == 2) {
        CFArrayRef v26 = (const __CFArray *)&unk_1ED084FF8;
      }
      else {
        CFArrayRef v26 = (const __CFArray *)&unk_1ED085010;
      }
      CFArrayRef v27 = CFBundleCopyLocalizationsForPreferences(v26, (CFArrayRef)atomic_load_explicit(&v59.info, memory_order_acquire));
      CFArrayRef v28 = v27;
      if (!v28)
      {

        goto LABEL_39;
      }
      CFArrayRef v29 = v28;
      CFIndex v30 = CFArrayGetCount(v28);

      if (!v30)
      {
LABEL_39:
        v34 = a1;
LABEL_42:
        v59.isa = v34;
LABEL_43:

        info = (void *)v59.info;
LABEL_122:

        CFDictionarySetValue(*(CFMutableDictionaryRef *)&_MergedGlobals_17[8 * v6 + 104], a1, (const void *)atomic_load_explicit(a3, memory_order_acquire));
        goto LABEL_123;
      }
      CFArrayRef v31 = v27;
      if (v31)
      {
        CFArrayRef v32 = v31;
        ValueAtIndex = (__CFString *)CFArrayGetValueAtIndex(v31, 0);

        if (a2)
        {
LABEL_34:
          if (ValueAtIndex != @"zxx" && (!ValueAtIndex || !CFEqual(ValueAtIndex, @"zxx"))) {
            goto LABEL_41;
          }
          goto LABEL_39;
        }
        if (ValueAtIndex == @"zh-Hant")
        {
LABEL_47:
          CFDictionaryRef ComponentsFromLocaleIdentifier = CFLocaleCreateComponentsFromLocaleIdentifier(v9, a1);
          Value = (__CFString *)CFDictionaryGetValue(ComponentsFromLocaleIdentifier, (const void *)*MEMORY[0x1E4F1D1F0]);
          if (Value != @"HK")
          {
            v38 = Value;
            if (Value)
            {
              if (CFEqual(Value, @"HK")) {
                goto LABEL_50;
              }
              if (v38 == @"MO" || CFEqual(v38, @"MO"))
              {
                v39 = @"zh-MO";
                goto LABEL_51;
              }
            }

            goto LABEL_34;
          }
LABEL_50:
          v39 = @"zh-HK";
LABEL_51:
          v59.isa = v39;

          goto LABEL_43;
        }
        if (ValueAtIndex)
        {
          if (!CFEqual(ValueAtIndex, @"zh-Hant")) {
            goto LABEL_34;
          }
          goto LABEL_47;
        }
      }
      else
      {

        ValueAtIndex = 0;
      }
LABEL_41:
      v34 = ValueAtIndex;
      goto LABEL_42;
    }
    CFAllocatorRef v17 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    v18 = (char *)CFLocaleCreateComponentsFromLocaleIdentifier((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1);
    v59.info = 0xAAAAAAAAAAAAAAAALL;
    v59.data = v18;
    CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v59.data, memory_order_acquire);
    v20 = (const void *)*MEMORY[0x1E4F1D218];
    if (explicit) {
      CFDictionaryRef explicit = (const __CFDictionary *)CFDictionaryGetValue(explicit, (const void *)*MEMORY[0x1E4F1D218]);
    }
    v59.isa = explicit;
    v59.info = atomic_exchange((atomic_ullong *volatile)&v59, 0);

    if (!atomic_load_explicit(&v59.info, memory_order_acquire))
    {
LABEL_119:
      v50 = a1;
      goto LABEL_120;
    }
    CFDictionaryRef v21 = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v59.data, memory_order_acquire);
    key = (void *)*MEMORY[0x1E4F1D220];
    v22 = (__CFString *)CFDictionaryGetValue(v21, (const void *)*MEMORY[0x1E4F1D220]);
    v23 = (__CFString *)(id)atomic_load_explicit(&v59.info, memory_order_acquire);
    if (v23 == @"yue")
    {
    }
    else
    {
      v24 = v23;
      if (!v23)
      {

        goto LABEL_69;
      }
      int v25 = CFEqual(v23, @"yue");

      if (!v25)
      {
LABEL_69:
        v42 = (__CFString *)(id)atomic_load_explicit(&v59.info, memory_order_acquire);
        if (v42 == @"wuu")
        {
        }
        else
        {
          v43 = v42;
          if (!v42)
          {

            goto LABEL_83;
          }
          int v44 = CFEqual(v42, @"wuu");

          if (!v44)
          {
LABEL_83:
            v51 = (__CFString *)(id)atomic_load_explicit(&v59.info, memory_order_acquire);
            if (v51 == @"und")
            {
            }
            else
            {
              v52 = v51;
              if (!v51)
              {
                isa = 0;
LABEL_108:

LABEL_109:
                if (a2)
                {
                  if (v22)
                  {
                    Mutable = CFDictionaryCreateMutable(v17, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                    CFDictionarySetValue(Mutable, v20, (const void *)atomic_load_explicit(&v59.info, memory_order_acquire));
                    CFDictionarySetValue(Mutable, key, v22);
                    v59.isa = (void *)CFLocaleCreateLocaleIdentifierFromComponents(v17, Mutable);

                    v59.isa = (void *)CFLocaleCreateCanonicalLanguageIdentifierFromString(v17, (CFStringRef)atomic_load_explicit(&v59.info, memory_order_acquire));
                    v59.isa = (void *)atomic_exchange(&v59.info, 0);

LABEL_121:
                    info = v59.data;
                    goto LABEL_122;
                  }
                  if (objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F1CA20], "systemLanguages"), "containsObject:", a1))goto LABEL_119; {
LABEL_130:
                  }
                  v59.isa = (void *)atomic_exchange(&v59.info, 0);
                  goto LABEL_121;
                }
                if (!v22)
                {
                  v59.isa = (void *)0xAAAAAAAAAAAAAAAALL;
                  MaximizedLocaleIdentifier(&v59, a1);

                  v22 = (__CFString *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v59.data, memory_order_acquire), key);
                }
                if (v22 != @"Arab")
                {
                  if (!v22) {
                    goto LABEL_130;
                  }
                  if (!CFEqual(v22, @"Arab"))
                  {
                    if (v22 == @"Aran" || CFEqual(v22, @"Aran"))
                    {
                      v50 = @"ur";
                      goto LABEL_120;
                    }
                    if (v22 == @"Qaag" || CFEqual(v22, @"Qaag"))
                    {
                      v50 = @"my-Qaag";
                      goto LABEL_120;
                    }
                    goto LABEL_130;
                  }
                }
                v50 = @"ar";
LABEL_120:
                v59.isa = v50;
                goto LABEL_121;
              }
              int v53 = CFEqual(v51, @"und");

              if (!v53) {
                goto LABEL_109;
              }
            }
            v59.isa = (void *)0xAAAAAAAAAAAAAAAALL;
            MaximizedLocaleIdentifier(&v59, a1);

            CFDictionaryRef v54 = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v59.data, memory_order_acquire);
            if (v54) {
              CFDictionaryRef v54 = (const __CFDictionary *)CFDictionaryGetValue(v54, v20);
            }
            id v58 = v54;

            if (v22) {
              v22 = (__CFString *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v59.data, memory_order_acquire), key);
            }
            isa = v59.isa;
            goto LABEL_108;
          }
        }
        if (v22 == @"Hant" || v22 && CFEqual(v22, @"Hant"))
        {
          CFDictionaryRef v45 = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v59.data, memory_order_acquire);
          v46 = (__CFString *)CFDictionaryGetValue(v45, (const void *)*MEMORY[0x1E4F1D1F0]);
          v47 = v46;
          if (v46 == @"HK")
          {
            BOOL v48 = 1;
          }
          else
          {
            if (!v46)
            {
              BOOL v48 = 0;
              BOOL v49 = 0;
LABEL_100:
              if (a2 == 3 || !a2)
              {
                if (v49)
                {
LABEL_103:
                  v50 = @"zh-MO";
                  goto LABEL_120;
                }
                if (v48)
                {
LABEL_105:
                  v50 = @"zh-HK";
                  goto LABEL_120;
                }
              }
              goto LABEL_106;
            }
            BOOL v48 = CFEqual(v46, @"HK") != 0;
            if (v47 == @"MO")
            {
              BOOL v49 = 1;
              goto LABEL_100;
            }
          }
          BOOL v49 = CFEqual(v47, @"MO") != 0;
          goto LABEL_100;
        }
LABEL_81:
        v50 = @"zh-Hans";
        goto LABEL_120;
      }
    }
    if (v22 != @"Hans" && (!v22 || !CFEqual(v22, @"Hans")))
    {
      if ((CFDictionaryRef v40 = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v59.data, memory_order_acquire),
            v41 = (__CFString *)CFDictionaryGetValue(v40, (const void *)*MEMORY[0x1E4F1D1F0]),
            v22 == @"Hant")
        || v22 && CFEqual(v22, @"Hant")
        || v41 != @"CN" && (!v41 || !CFEqual(v41, @"CN")))
      {
        if (a2 == 3 || !a2)
        {
          if (v41 == @"MO" || v41 && CFEqual(v41, @"MO")) {
            goto LABEL_103;
          }
          goto LABEL_105;
        }
LABEL_106:
        v50 = @"zh-Hant";
        goto LABEL_120;
      }
    }
    goto LABEL_81;
  }
LABEL_123:
  os_unfair_lock_unlock(&stru_1EB2CE25C);
}

void CopyPreferredLanguage(atomic_ullong *a1@<X8>)
{
  os_unfair_lock_lock_with_options();
  *a1 = (atomic_ullong)(id)qword_1EB2CE280;
  if (qword_1EB2CE288 != -1) {
    dispatch_once_f(&qword_1EB2CE288, 0, (dispatch_function_t)GetLocaleChangedCount(void)::$_0::__invoke);
  }
  if (dword_1EB2CE264 != gLocaleChangedCount)
  {
    dword_1EB2CE264 = gLocaleChangedCount;
    CFArrayRef v2 = CFLocaleCopyPreferredLanguages();
    CFArrayRef v3 = v2;
    if (v3)
    {
      CFArrayRef v4 = v3;
      CFIndex Count = CFArrayGetCount(v3);

      if (Count >= 1)
      {
        ValueAtIndex = (void *)CFArrayGetValueAtIndex(v2, 0);
        TCFRef<__CTFont const*>::Retain(a1, ValueAtIndex);
      }
    }
    else
    {
    }
    CFDictionaryRef explicit = (void *)atomic_load_explicit(a1, memory_order_acquire);
    int v8 = (void *)qword_1EB2CE280;
    if ((void *)qword_1EB2CE280 != explicit)
    {
      qword_1EB2CE280 = explicit;
    }
  }

  os_unfair_lock_unlock(&stru_1EB2CE260);
}

__CFString *SFFontNameForWidth(unsigned int a1, CFNumberRef number, void *a3)
{
  CFArrayRef v3 = kFont2X[5 * a1];
  if (number)
  {
    double valuePtr = NAN;
    CFNumberGetValue(number, kCFNumberDoubleType, &valuePtr);
    unsigned int v6 = ClassOfWidth(valuePtr);
    if (v6 != 5)
    {
      if (v6 >= 8) {
        int v7 = 8;
      }
      else {
        int v7 = v6;
      }
      if (a3) {
        *a3 = off_1E528E270[v7];
      }
      return off_1E528E4F8[v7][a1 % 9];
    }
  }
  return v3;
}

void addComponentsWithNameAndTrimCharacterSet(const __CFString *a1, const __CFString *a2, atomic_ullong *a3)
{
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  int v8 = CFDictionaryCreateMutable(v6, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionaryAddValue(v8, @"name", a1);
  if (a2) {
    CFDictionaryAddValue(v8, @"UnicodeCharSetTrim", a2);
  }
  CFArrayAppendValue(Mutable, v8);
  CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit(a3, memory_order_acquire), @"Components", Mutable);
}

void addComponentsWithTrimCharacterSet(const void **a1, const void *a2, atomic_ullong *a3, uint64_t a4)
{
  CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  id Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  CFAllocatorRef v9 = CFDictionaryCreateMutable(v8, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionaryAddValue(v9, @"name", *a1);
  if (a2) {
    CFDictionaryAddValue(v9, @"UnicodeCharSetTrim", a2);
  }
  CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), v9);
  if (a4) {
    (*(void (**)(uint64_t, id *))(a4 + 16))(a4, &Mutable);
  }
  CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit(a3, memory_order_acquire), @"Components", (const void *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire));
}

void *LanguageAwareLineSpacingOverrideRatio(anonymous namespace'::THIUsageSpec const*,__CFString const*)::$_0::__invoke()
{
  CFURLRef result = objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F1CB18], "standardUserDefaults"), "objectForKey:", @"NSLanguageAwareLineSpacingAdjustmentsON");
  if (result)
  {
    CFURLRef result = (void *)[result integerValue];
    dword_1EB2CDB2C = result == 0;
  }
  return result;
}

CFStringRef ExuberatedGroupForTallPseudolanguageIfEnabled(void)::$_0::__invoke()
{
  CFStringRef result = (const __CFString *)objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F1CB18], "standardUserDefaults"), "stringForKey:", @"NSTallLocalizedStrings");
  if (result)
  {
    CFStringRef result = (const __CFString *)GetExuberatedGroupForLanguage(result, 0);
    dword_1EB2CE268 = (int)result;
  }
  return result;
}

CTParagraphStyleRef CTParagraphStyleCreate(const CTParagraphStyleSetting *settings, size_t settingCount)
{
  id v28 = (id)0xAAAAAAAAAAAAAAAALL;
  CFArrayRef v4 = (TNativeParagraphStyle *)TCFBase<TNativeParagraphStyle>::Allocate();
  if (v4)
  {
    id v5 = v4;
    *((void *)v4 + 2) = 0;
    *((void *)v4 + 3) = TNativeParagraphStyle::Hash;
    *((void *)v4 + 6) = 0;
    *((void *)v4 + 4) = 0;
    *((void *)v4 + 5) = (char *)v4 + 48;
    *((void *)v4 + 7) = 0;
    *((void *)v4 + 8) = 0;
    *((void *)v4 + 9) = TNativeParagraphStyle::CopyDefaultTabStops(v4);
    *((_WORD *)v5 + 40) = 1024;
    *((unsigned char *)v5 + 82) = -1;
    *((void *)v5 + 11) = 0;
    *((unsigned char *)v5 + 96) = 0;
    id explicit = v5;
    id v27 = (id)atomic_exchange((atomic_ullong *volatile)&explicit, 0);
  }
  else
  {
    id v27 = 0;
  }
  id v28 = (id)atomic_exchange((atomic_ullong *volatile)&v27, 0);

  if (atomic_load_explicit((atomic_ullong *volatile)&v28, memory_order_acquire))
  {
    id explicit = 0;
    unint64_t v26 = 0xAAAAAAAAAAAAAA00;
    id explicit = (id)atomic_load_explicit((atomic_ullong *volatile)&v28, memory_order_acquire);
    LOBYTE(v26) = 1;
    if (settings && settingCount)
    {
      size_t v6 = 24 * settingCount;
      p_value = &settings->value;
      do
      {
        CFAllocatorRef v8 = (id *)*p_value;
        if (*p_value)
        {
          uint64_t v9 = (uint64_t)*(p_value - 1);
          switch(*((_DWORD *)p_value - 4))
          {
            case 0:
              if (v9 == 1) {
                TParagraphStyle::SetAlignment((TParagraphStyle *)&explicit, *(unsigned __int8 *)v8);
              }
              break;
            case 1:
              if (v9 == 8)
              {
                double v11 = *(double *)v8;
                goto LABEL_59;
              }
              if (v9 == 4)
              {
                double v11 = *(float *)v8;
LABEL_59:
                TParagraphStyle::SetFirstLineHeadIndent((TNativeParagraphStyle ***)&explicit, v11);
                break;
              }
              break;
            case 2:
              if (v9 == 8)
              {
                double v12 = *(double *)v8;
                goto LABEL_61;
              }
              if (v9 == 4)
              {
                double v12 = *(float *)v8;
LABEL_61:
                TParagraphStyle::SetHeadIndent((TNativeParagraphStyle ***)&explicit, v12);
                break;
              }
              break;
            case 3:
              if (v9 == 8)
              {
                double v13 = *(double *)v8;
                goto LABEL_63;
              }
              if (v9 == 4)
              {
                double v13 = *(float *)v8;
LABEL_63:
                TParagraphStyle::SetTailIndent((TNativeParagraphStyle ***)&explicit, v13);
                break;
              }
              break;
            case 4:
              if (v9 == 8) {
                TParagraphStyle::SetTabStops((TParagraphStyle *)&explicit, *v8);
              }
              break;
            case 5:
              if (v9 == 8)
              {
                double v14 = *(double *)v8;
                goto LABEL_65;
              }
              if (v9 == 4)
              {
                double v14 = *(float *)v8;
LABEL_65:
                TParagraphStyle::SetDefaultTabInterval((TParagraphStyle *)&explicit, v14);
                break;
              }
              break;
            case 6:
              if (v9 == 1) {
                TParagraphStyle::SetLineBreakMode((TParagraphStyle *)&explicit, *(unsigned __int8 *)v8);
              }
              break;
            case 7:
              if (v9 == 8)
              {
                double v15 = *(double *)v8;
                goto LABEL_67;
              }
              if (v9 == 4)
              {
                double v15 = *(float *)v8;
LABEL_67:
                TParagraphStyle::SetLineHeightMultiple((TNativeParagraphStyle ***)&explicit, v15);
                break;
              }
              break;
            case 8:
              if (v9 == 8)
              {
                double v16 = *(double *)v8;
                goto LABEL_69;
              }
              if (v9 == 4)
              {
                double v16 = *(float *)v8;
LABEL_69:
                TParagraphStyle::SetMaximumLineHeight((TNativeParagraphStyle ***)&explicit, v16);
                break;
              }
              break;
            case 9:
              if (v9 == 8)
              {
                double v17 = *(double *)v8;
                goto LABEL_71;
              }
              if (v9 == 4)
              {
                double v17 = *(float *)v8;
LABEL_71:
                TParagraphStyle::SetMinimumLineHeight((TNativeParagraphStyle ***)&explicit, v17);
                break;
              }
              break;
            case 0xA:
            case 0xF:
              if (v9 == 8)
              {
                double v10 = *(double *)v8;
                goto LABEL_57;
              }
              if (v9 == 4)
              {
                double v10 = *(float *)v8;
LABEL_57:
                TParagraphStyle::SetMinimumLineSpacing((TParagraphStyle *)&explicit, v10);
                break;
              }
              break;
            case 0xB:
              if (v9 == 8)
              {
                double v18 = *(double *)v8;
                goto LABEL_73;
              }
              if (v9 == 4)
              {
                double v18 = *(float *)v8;
LABEL_73:
                TParagraphStyle::SetParagraphSpacing((TNativeParagraphStyle ***)&explicit, v18);
                break;
              }
              break;
            case 0xC:
              if (v9 == 8)
              {
                double v19 = *(double *)v8;
                goto LABEL_75;
              }
              if (v9 == 4)
              {
                double v19 = *(float *)v8;
LABEL_75:
                TParagraphStyle::SetParagraphSpacingBefore((TNativeParagraphStyle ***)&explicit, v19);
                break;
              }
              break;
            case 0xD:
              if (v9 == 1) {
                TParagraphStyle::SetBaseWritingDirection((TParagraphStyle *)&explicit, *(char *)v8);
              }
              break;
            case 0xE:
              if (v9 == 8)
              {
                double v20 = *(double *)v8;
LABEL_77:
                if ((_BYTE)v26)
                {
                  uint64_t v22 = *(void *)(*((void *)explicit + 5) + 8);
                  if (!v22) {
                    TNativeParagraphStyle::CreateSpacePack(*((TNativeParagraphStyle **)explicit + 5));
                  }
                  *(double *)(v22 + 32) = v20;
                }
                break;
              }
              if (v9 == 4)
              {
                double v20 = *(float *)v8;
                goto LABEL_77;
              }
              break;
            case 0x10:
              if (v9 == 8)
              {
                double v21 = *(double *)v8;
                goto LABEL_82;
              }
              if (v9 == 4)
              {
                double v21 = *(float *)v8;
LABEL_82:
                TParagraphStyle::SetLineSpacingAdjustment((TNativeParagraphStyle ***)&explicit, v21);
                break;
              }
              break;
            case 0x11:
              if (v9 == 8) {
                TParagraphStyle::SetLineBoundsOptions((TParagraphStyle *)&explicit, (uint64_t)*v8);
              }
              break;
            default:
              break;
          }
        }
        p_value += 3;
        v6 -= 24;
      }
      while (v6);
    }
    v23 = (const __CTParagraphStyle *)atomic_exchange((atomic_ullong *volatile)&v28, 0);
  }
  else
  {
    v23 = 0;
  }

  return v23;
}

uint64_t TCFBase<TNativeParagraphStyle>::Allocate()
{
  if (qword_1EB2CE3B0 != -1) {
    dispatch_once_f(&qword_1EB2CE3B0, 0, (dispatch_function_t)TCFBase<TNativeParagraphStyle>::GetTypeID(void)::{lambda(void *)#1}::__invoke);
  }

  return _CFRuntimeCreateInstance();
}

CFArrayRef TNativeParagraphStyle::CopyDefaultTabStops(TNativeParagraphStyle *this)
{
  uint64_t v1 = 0;
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  double v7 = 0.0;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  *(_OWORD *)values = 0u;
  long long v9 = 0u;
  while (1)
  {
    double v7 = v7 + 28.0;
    char v5 = 0;
    TCFBase_NEW<CTTextTab,double &,CTTextAlignment,decltype(nullptr)>((uint64_t *)&v7, &v5, &v6);

    if (!atomic_load_explicit((atomic_ullong *volatile)&values[v1], memory_order_acquire)) {
      break;
    }
    if (++v1 == 12)
    {
      CFArrayRef v2 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)values, 12, MEMORY[0x1E4F1D510]);
      goto LABEL_6;
    }
  }
  CFArrayRef v2 = 0;
LABEL_6:
  for (uint64_t i = 11; i != -1; --i)

  return v2;
}

void TCFBase_NEW<CTTextTab,double &,CTTextAlignment,decltype(nullptr)>(uint64_t *a1@<X0>, char *a2@<X1>, void *a3@<X8>)
{
  uint64_t v6 = TCFBase<TNativeTextTab>::Allocate();
  if (v6)
  {
    uint64_t v7 = *a1;
    char v8 = *a2;
    *(void *)(v6 + 16) = 0;
    *(void *)(v6 + 24) = 0;
    *(void *)(v6 + 48) = v7;
    *(void *)(v6 + 32) = 0;
    *(void *)(v6 + 40) = v6 + 48;
    *(unsigned char *)(v6 + 56) = v8;
    *(void *)(v6 + 64) = 0;
    id v9 = (id)v6;
    *a3 = atomic_exchange((atomic_ullong *volatile)&v9, 0);
  }
  else
  {
    *a3 = 0;
  }
}

uint64_t TCFBase<TNativeTextTab>::Allocate()
{
  if (TCFBase<TNativeTextTab>::GetTypeID(void)::once != -1) {
    dispatch_once_f(&TCFBase<TNativeTextTab>::GetTypeID(void)::once, 0, (dispatch_function_t)TCFBase<TNativeTextTab>::GetTypeID(void)::{lambda(void *)#1}::__invoke);
  }

  return _CFRuntimeCreateInstance();
}

void *TParagraphStyle::SetAlignment(TParagraphStyle *this, uint64_t a2)
{
  int v2 = *((unsigned __int8 *)this + 8);
  CFStringRef result = *(void **)this;
  if (!v2) {
    return objc_msgSend(result, sel_setAlignment_, a2);
  }
  *(unsigned char *)(result[5] + 33) = a2;
  return result;
}

void TNativeParagraphStyle::CreateSpacePack(TNativeParagraphStyle *this)
{
}

id TParagraphStyle::SetMinimumLineSpacing(TParagraphStyle *this, double a2)
{
  id result = (id)_CFExecutableLinkedOnOrAfter();
  if (result)
  {
    if (!*((unsigned char *)this + 8))
    {
      char v5 = *(void **)this;
      return objc_msgSend(v5, sel_setLineSpacing_, a2);
    }
  }
  else if (!*((unsigned char *)this + 8))
  {
    return result;
  }
  uint64_t v6 = *(TNativeParagraphStyle **)(*(void *)this + 40);
  uint64_t v7 = *((void *)v6 + 1);
  if (!v7) {
    TNativeParagraphStyle::CreateSpacePack(v6);
  }
  *(double *)(v7 + 40) = a2;
  return result;
}

void *TParagraphStyle::SetBaseWritingDirection(TParagraphStyle *this, uint64_t a2)
{
  int v2 = *((unsigned __int8 *)this + 8);
  id result = *(void **)this;
  if (!v2) {
    return objc_msgSend(result, sel_setBaseWritingDirection_, a2);
  }
  *(unsigned char *)(result[5] + 34) = a2;
  return result;
}

void *TParagraphStyle::SetDefaultTabInterval(TParagraphStyle *this, double a2)
{
  int v2 = *((unsigned __int8 *)this + 8);
  id result = *(void **)this;
  if (!v2) {
    return objc_msgSend(result, sel_setDefaultTabInterval_, a2);
  }
  *(double *)(result[5] + 16) = a2;
  return result;
}

uint64_t TParagraphStyle::SetLineBoundsOptions(TParagraphStyle *this, uint64_t a2)
{
  int v4 = *((unsigned __int8 *)this + 8);
  uint64_t result = *(void *)this;
  if (v4)
  {
    *(void *)(*(void *)(result + 40) + 40) = a2;
  }
  else
  {
    uint64_t result = objc_opt_respondsToSelector();
    if (result)
    {
      uint64_t v6 = *(void **)this;
      return (uint64_t)objc_msgSend(v6, sel__setLineBoundsOptions_, a2);
    }
  }
  return result;
}

void TParagraphStyle::SetTabStops(TParagraphStyle *this, id a2)
{
  int v2 = *((unsigned __int8 *)this + 8);
  CFArrayRef v3 = *(void **)this;
  if (v2) {
    TCFRef<__CTFont const*>::Retain((atomic_ullong *)(v3[5] + 24), a2);
  }
  else {
    objc_msgSend(v3, sel_setTabStops_, a2);
  }
}

uint64_t TBaseFont::GetScriptAnalysisValue(atomic_ullong *this)
{
  TBaseFont::CopyAttributeInternal(this, @"CTFontIgnoreScriptAnalysisAttribute", &valuePtr);
  int v2 = (void *)atomic_exchange((atomic_ullong *volatile)&valuePtr, 0);

  if (v2)
  {
    CFNumberRef v3 = v2;
    LODWORD(valuePtr) = -1431655766;
    CFNumberGetValue(v3, kCFNumberIntType, &valuePtr);
    if (valuePtr) {
      uint64_t v4 = 2;
    }
    else {
      uint64_t v4 = 1;
    }
  }
  else
  {
    CFDataRef CommonTable = (const __CFData *)TBaseFont::GetCommonTable((TBaseFont *)this, 1196643650, 0);
    if (IgnoreScriptAnalysisForGCommonTable(CommonTable))
    {
      CFDataRef v6 = (const __CFData *)TBaseFont::GetCommonTable((TBaseFont *)this, 1196445523, 0);
      if (v6) {
        int v7 = IgnoreScriptAnalysisForGCommonTable(v6);
      }
      else {
        int v7 = 1;
      }
    }
    else
    {
      int v7 = 0;
    }
    TCFNumber::TCFNumber<int>(&v9, v7);
    TBaseFont::SetAttributeInternal<TCFRef<__CFSet const*>>(this, (atomic_ullong *)&v9, @"CTFontIgnoreScriptAnalysisAttribute");

    if (v7) {
      uint64_t v4 = 2;
    }
    else {
      uint64_t v4 = 0;
    }
  }

  return v4;
}

uint64_t IgnoreScriptAnalysisForGCommonTable(const __CFData *a1)
{
  if (!a1) {
    return 1;
  }
  BytePtr = CFDataGetBytePtr(a1);
  if (!BytePtr) {
    return 1;
  }
  unint64_t v3 = (unint64_t)BytePtr;
  uint64_t v4 = CFDataGetBytePtr(a1);
  if (v4) {
    unint64_t v5 = (unint64_t)&v4[CFDataGetLength(a1)];
  }
  else {
    unint64_t v5 = 0;
  }

  return OTL::GCommon::IgnoreScriptAnalysis(v3, v5);
}

uint64_t OTL::GCommon::IgnoreScriptAnalysis(unint64_t a1, unint64_t a2)
{
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  if (!*(_WORD *)(a1 + 4)) {
    return 1;
  }
  uint64_t v4 = __rev16(*(unsigned __int16 *)(a1 + 4));
  unint64_t v5 = (unsigned __int16 *)(a1 + v4);
  unint64_t v6 = a1 + v4 + 2;
  if (v6 > a2) {
    return 1;
  }
  unsigned int v8 = *v5;
  uint64_t v9 = __rev16(v8);
  unint64_t v10 = v6 + 6 * v9;
  if (v10 < v6 || v10 > a2)
  {
    unint64_t v12 = (a2 - v6) / 6;
    if ((unint64_t)(v5 + 4) > a2) {
      unint64_t v12 = 0;
    }
    if (v12 != v9 || v8 == 0) {
      return 1;
    }
  }
  else if (!*v5)
  {
    return 1;
  }
  uint64_t v14 = (unsigned __int16 *)((char *)v5 + (bswap32(v5[3]) >> 16));
  if ((unint64_t)(v14 + 1) >= a1 && (unint64_t)(v14 + 2) <= a2)
  {
    qmemcpy(v66, "lryckerginahanakntalnmrarehcroegrnurmago", sizeof(v66));
    if (v9 <= 1) {
      uint64_t v16 = 1;
    }
    else {
      uint64_t v16 = v9;
    }
    uint64_t v17 = v4 + 2;
    while (1)
    {
      unsigned int v18 = *(_DWORD *)(a1 + v17);
      if (v18 != 1414284868)
      {
        double v19 = wmemchr((__int32 *)v66, bswap32(v18), 0xAuLL);
        double v20 = v19 ? (char *)v19 : (char *)&v67;
        if (v20 - v66 == 40) {
          break;
        }
      }
      v17 += 6;
      if (!--v16)
      {
        if (*(_WORD *)(a1 + 6))
        {
          double v21 = (unsigned __int16 *)(a1 + __rev16(*(unsigned __int16 *)(a1 + 6)));
          uint64_t v22 = v21 + 1;
          if ((unint64_t)(v21 + 1) <= a2)
          {
            uint64_t v23 = bswap32(*v21) >> 16;
            unint64_t v24 = (unint64_t)&v22[3 * v23];
            if (v24 >= (unint64_t)v22 && v24 <= a2) {
              goto LABEL_43;
            }
            unint64_t v26 = (a2 - (unint64_t)v22) / 6;
            if ((unint64_t)(v21 + 4) > a2) {
              unint64_t v26 = 0;
            }
            if (v26 == v23)
            {
LABEL_43:
              uint64_t result = (uint64_t)OTL::FirstLangSysTable(v14, a1, a2);
              if (!result) {
                return result;
              }
              if (v9 < 2)
              {
                LODWORD(v31) = 1;
              }
              else
              {
                uint64_t v27 = result;
                unsigned int v28 = *(unsigned __int16 *)(result + 4);
                unsigned int v29 = __rev16(v28);
                uint64_t v30 = v29 <= 1 ? 1 : v29;
                uint64_t v31 = 1;
                while (1)
                {
                  CFArrayRef v32 = (unsigned __int16 *)((char *)v5 + (bswap32(v5[3 * v31 + 3]) >> 16));
                  if ((unint64_t)(v32 + 2) > a2) {
                    break;
                  }
                  LangSysTable = OTL::FirstLangSysTable(v32, a1, a2);
                  if (!LangSysTable || *((unsigned __int16 *)LangSysTable + 2) != v28) {
                    break;
                  }
                  if (v28)
                  {
                    uint64_t v34 = 0;
                    do
                    {
                      unsigned int v35 = bswap32(*(unsigned __int16 *)(v27 + 2 * v34 + 6)) >> 16;
                      v36 = &v21[3 * v35];
                      v37 = v36 + 1;
                      unint64_t v38 = (unint64_t)(v36 + 4);
                      if ((unint64_t)v37 < a1 || v38 > a2) {
                        return 0;
                      }
                      unsigned int v40 = bswap32(*(unsigned __int16 *)&LangSysTable[2 * v34 + 6]) >> 16;
                      v41 = &v21[3 * v40];
                      v42 = v41 + 1;
                      unint64_t v43 = (unint64_t)(v41 + 4);
                      if ((unint64_t)v42 < a1 || v43 > a2) {
                        return 0;
                      }
                      if (*v37 != *v42) {
                        goto LABEL_103;
                      }
                      unsigned int v45 = v21[3 * v35 + 3];
                      v46 = (char *)v21 + __rev16(v45);
                      v47 = (unsigned __int16 *)(v46 + 4);
                      if ((unint64_t)(v46 + 2) < a1 || (unint64_t)v47 > a2) {
                        return 0;
                      }
                      unsigned int v49 = *((unsigned __int16 *)v46 + 1);
                      uint64_t v50 = __rev16(v49);
                      v51 = &v47[v50];
                      unint64_t v52 = (unint64_t)(v46 + 6) <= a2 ? (a2 - (unint64_t)v47) >> 1 : 0;
                      BOOL v53 = (unint64_t)v51 <= a2 && v51 >= v47;
                      if (!v53 && v52 != v50) {
                        return 0;
                      }
                      unsigned int v55 = v21[3 * v40 + 3];
                      v56 = (char *)v21 + __rev16(v55);
                      v57 = (unsigned __int16 *)(v56 + 4);
                      if (v56 + 2 < (char *)v21 || (unint64_t)v57 > a2) {
                        return 0;
                      }
                      unsigned int v59 = *((unsigned __int16 *)v56 + 1);
                      uint64_t v60 = __rev16(v59);
                      v61 = &v57[v60];
                      unint64_t v62 = (unint64_t)(v56 + 6) <= a2 ? (a2 - (unint64_t)v57) >> 1 : 0;
                      BOOL v63 = (unint64_t)v61 <= a2 && v61 >= v57;
                      if (!v63 && v62 != v60) {
                        return 0;
                      }
                      if (v45 != v55)
                      {
                        if (v49 != v59) {
                          goto LABEL_103;
                        }
                        if (v49)
                        {
                          uint64_t v65 = 2 * v50;
                          while (*v47 == *v57)
                          {
                            ++v47;
                            ++v57;
                            v65 -= 2;
                            if (!v65) {
                              goto LABEL_99;
                            }
                          }
                          goto LABEL_103;
                        }
                      }
LABEL_99:
                      ;
                    }
                    while (++v34 != v30);
                  }
                  ++v31;
                  uint64_t result = 1;
                  if (v31 == v9) {
                    return result;
                  }
                }
              }
LABEL_103:
              if (v31 == v9) {
                return 1;
              }
            }
          }
        }
        return 0;
      }
    }
  }
  return 0;
}

char *OTL::FirstLangSysTable(unsigned __int16 *a1, unint64_t a2, unint64_t a3)
{
  if (*a1)
  {
    uint64_t v4 = __rev16(*a1);
  }
  else
  {
    if (!a1[1]) {
      return 0;
    }
    uint64_t result = 0;
    if ((unint64_t)(a1 + 4) < a2 || (unint64_t)(a1 + 5) > a3) {
      return result;
    }
    uint64_t v4 = bswap32(a1[4]) >> 16;
  }
  unint64_t v6 = (char *)a1 + v4;
  unint64_t v7 = (unint64_t)(v6 + 6);
  if ((unint64_t)(v6 + 4) < a2 || v7 > a3) {
    return 0;
  }
  uint64_t v9 = bswap32(*((unsigned __int16 *)v6 + 2)) >> 16;
  unint64_t v10 = v7 + 2 * v9;
  if ((unint64_t)(v6 + 8) <= a3) {
    unint64_t v11 = (a3 - v7) >> 1;
  }
  else {
    unint64_t v11 = 0;
  }
  if (v10 >= v7 && v10 <= a3 || v11 == v9) {
    return v6;
  }
  else {
    return 0;
  }
}

void TFontFeatures::TFontFeatures(TFontFeatures *this, const TBaseFont *a2, int a3)
{
  uint64_t v4 = a2;
  uint64_t v223 = *MEMORY[0x1E4F143B8];
  *(void *)this = 0;
  memset(v208, 170, sizeof(v208));
  TFontFeatureTable::TFontFeatureTable((TFontFeatureTable *)v208, a2);
  unint64_t v5 = (unsigned __int16 *)v208[2];
  v185 = v4;
  if (v208[2])
  {
    int v6 = *(_DWORD *)v208[2];
    if ((*(_DWORD *)v208[2] & 0xFEFFFFFF) == 0x100)
    {
      int v179 = a3;
      int v180 = *(_DWORD *)v208[2];
      *(_OWORD *)__p = 0u;
      *(_OWORD *)v214 = 0u;
      *(void *)&v214[16] = 0xAAAAAAAA3F800000;
      v182 = (unsigned __int16 *)v208[2];
      if (v6 == 16777472) {
        goto LABEL_174;
      }
      *(_OWORD *)v204 = 0uLL;
      long long v205 = 0uLL;
      float v206 = 1.0;
      int v207 = -1431655766;
      CFDataRef CommonTable = (const __CFData *)TBaseFont::GetCommonTable(v4, 1836020344, 0);
      if (!CommonTable
        || ((CFDataRef v8 = CommonTable, v194 = CFDataGetBytePtr(CommonTable), (v9 = CFDataGetBytePtr(v8)) == 0)
          ? (unint64_t v10 = 0)
          : (unint64_t v10 = (unint64_t)&v9[CFDataGetLength(v8)]),
            !v194 || (unint64_t v12 = v194 + 8, (unint64_t)(v194 + 8) > v10)))
      {
LABEL_108:
        id v212 = (id)0xAAAAAAAAAAAAAAAALL;
        (*(void (**)(id *__return_ptr))(*(void *)v185 + 480))(&v212);
        CFDataRef v56 = (const __CFData *)(id)atomic_load_explicit((atomic_ullong *volatile)&v212, memory_order_acquire);
        CFDataRef v57 = v56;
        if (v56) {
          BytePtr = CFDataGetBytePtr(v56);
        }
        else {
          BytePtr = 0;
        }
        unint64_t v5 = v182;

        id v59 = (id)atomic_load_explicit((atomic_ullong *volatile)&v212, memory_order_acquire);
        CFDataRef v60 = (const __CFData *)v59;
        if (v60)
        {
          CFDataRef v61 = v60;
          unint64_t v62 = CFDataGetBytePtr(v60);

          if (v62) {
            v62 += CFDataGetLength((CFDataRef)v59);
          }
        }
        else
        {

          unint64_t v62 = 0;
        }

        if (BytePtr && BytePtr + 6 <= v62)
        {
          BOOL v63 = BytePtr + 12;
          unsigned int v64 = bswap32(*((unsigned __int16 *)BytePtr + 2)) >> 16;
          unint64_t v65 = (unint64_t)&BytePtr[12 * v64 + 12];
          if (v65 >= (unint64_t)(BytePtr + 12) && v65 <= (unint64_t)v62)
          {
            LOWORD(v66) = v64;
            goto LABEL_122;
          }
          if (BytePtr + 24 <= v62)
          {
            unint64_t v66 = (v62 - v63) / 0xCuLL;
            unsigned int v64 = (unsigned __int16)v66;
LABEL_122:
            if ((_WORD)v66)
            {
              uint64_t v67 = (unsigned __int16 *)&v63[12 * v64];
              while ((*((_WORD *)v63 + 4) & 0x80) == 0)
              {
LABEL_164:
                v63 += 12;
                if (v63 == (const UInt8 *)v67) {
                  goto LABEL_165;
                }
              }
              unint64_t v68 = bswap32(*(unsigned __int16 *)v63) >> 16;
              unint64_t v69 = (unint64_t)v204[1];
              if (v204[1])
              {
                uint8x8_t v70 = (uint8x8_t)vcnt_s8((int8x8_t)v204[1]);
                v70.i16[0] = vaddlv_u8(v70);
                if (v70.u32[0] > 1uLL)
                {
                  unint64_t v71 = v68;
                  if (v204[1] <= (id)v68) {
                    unint64_t v71 = v68 % (unint64_t)v204[1];
                  }
                }
                else
                {
                  unint64_t v71 = (LODWORD(v204[1]) - 1) & v68;
                }
                v72 = (uint64_t ***)*((void *)v204[0] + v71);
                if (v72)
                {
                  for (uint64_t i = *v72; i; uint64_t i = (uint64_t **)*i)
                  {
                    unint64_t v74 = (unint64_t)i[1];
                    if (v74 == v68)
                    {
                      if (*((unsigned __int16 *)i + 8) == v68) {
                        goto LABEL_164;
                      }
                    }
                    else
                    {
                      if (v70.u32[0] > 1uLL)
                      {
                        if ((id)v74 >= v204[1]) {
                          v74 %= (unint64_t)v204[1];
                        }
                      }
                      else
                      {
                        v74 &= (unint64_t)v204[1] - 1;
                      }
                      if (v74 != v71) {
                        break;
                      }
                    }
                  }
                }
              }
              else
              {
                unint64_t v71 = 0xAAAAAAAAAAAAAAAALL;
              }
              v75 = operator new(0x18uLL);
              void *v75 = 0;
              v75[1] = v68;
              *((_WORD *)v75 + 8) = v68;
              *((_WORD *)v75 + 9) = 0;
              float v76 = (float)(unint64_t)(*((void *)&v205 + 1) + 1);
              if (!v69 || (float)(v206 * (float)v69) < v76)
              {
                BOOL v77 = (v69 & (v69 - 1)) != 0;
                if (v69 < 3) {
                  BOOL v77 = 1;
                }
                unint64_t v78 = v77 | (2 * v69);
                unint64_t v79 = vcvtps_u32_f32(v76 / v206);
                if (v78 <= v79) {
                  size_t v80 = v79;
                }
                else {
                  size_t v80 = v78;
                }
                std::__hash_table<std::__hash_value_type<unsigned int,OTL::Lookup>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,OTL::Lookup>>>::__rehash<true>((uint64_t)v204, v80);
                unint64_t v69 = (unint64_t)v204[1];
                if (((unint64_t)v204[1] & ((unint64_t)v204[1] - 1)) != 0)
                {
                  if (v204[1] <= (id)v68) {
                    unint64_t v71 = v68 % (unint64_t)v204[1];
                  }
                  else {
                    unint64_t v71 = v68;
                  }
                }
                else
                {
                  unint64_t v71 = (LODWORD(v204[1]) - 1) & v68;
                }
              }
              v81 = v204[0];
              v82 = (void *)*((void *)v204[0] + v71);
              if (v82)
              {
                void *v75 = *v82;
              }
              else
              {
                void *v75 = v205;
                *(void *)&long long v205 = v75;
                v81[v71] = &v205;
                if (!*v75)
                {
LABEL_163:
                  ++*((void *)&v205 + 1);
                  goto LABEL_164;
                }
                unint64_t v83 = *(void *)(*v75 + 8);
                if ((v69 & (v69 - 1)) != 0)
                {
                  if (v83 >= v69) {
                    v83 %= v69;
                  }
                }
                else
                {
                  v83 &= v69 - 1;
                }
                v82 = (char *)v204[0] + 8 * v83;
              }
              void *v82 = v75;
              goto LABEL_163;
            }
          }
        }
LABEL_165:

        std::__hash_table<std::__hash_value_type<unsigned short,unsigned short>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,unsigned short>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,unsigned short>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,unsigned short>>>::clear(__p);
        id v84 = v204[0];
        v204[0] = 0;
        v85 = __p[0];
        __p[0] = v84;
        if (v85) {
          operator delete(v85);
        }
        unint64_t v86 = (unint64_t)v204[1];
        v204[1] = 0;
        *(_OWORD *)v214 = v205;
        *(float *)&v214[16] = v206;
        __p[1] = (void *)v86;
        if (*((void *)&v205 + 1))
        {
          unint64_t v87 = *(void *)(v205 + 8);
          if ((v86 & (v86 - 1)) != 0)
          {
            if (v87 >= v86) {
              v87 %= v86;
            }
          }
          else
          {
            v87 &= v86 - 1;
          }
          *((void *)__p[0] + v87) = v214;
          long long v205 = 0uLL;
        }
        std::__hash_table<EncoderAttempt,std::hash<EncoderAttempt>,std::equal_to<EncoderAttempt>,std::allocator<EncoderAttempt>>::~__hash_table((uint64_t)v204);
        uint64_t v4 = v185;
LABEL_174:
        CFIndex v88 = bswap32(v5[2]) >> 16;
        CFAllocatorRef allocatora = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        id Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v88, MEMORY[0x1E4F1D510]);
        if (!atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire))
        {
LABEL_254:

          std::__hash_table<EncoderAttempt,std::hash<EncoderAttempt>,std::equal_to<EncoderAttempt>,std::allocator<EncoderAttempt>>::~__hash_table((uint64_t)__p);
          a3 = v179;
          goto LABEL_255;
        }
        id v89 = (id)atomic_load_explicit((atomic_ullong *volatile)&v208[1], memory_order_acquire);
        CFDataRef v90 = (const __CFData *)v89;
        if (v90)
        {
          CFDataRef v91 = v90;
          v92 = CFDataGetBytePtr(v90);

          if (v92)
          {
            unint64_t v93 = (unint64_t)&v92[CFDataGetLength((CFDataRef)v89)];
            goto LABEL_180;
          }
        }
        else
        {
        }
        unint64_t v93 = 0;
LABEL_180:

        v94 = v5;
        v95 = v5 + 6;
        unint64_t v96 = (unint64_t)&v5[6 * v88 + 6];
        if (v96 < (unint64_t)(v5 + 6) || v96 > v93)
        {
          if ((unint64_t)(v5 + 12) > v93)
          {
LABEL_253:

            uint64_t v4 = v185;
            goto LABEL_254;
          }
          CFIndex v88 = (v93 - (unint64_t)v95) / 0xC;
        }
        unint64_t v184 = v93;
        if (v88)
        {
          v98 = &v95[6 * v88];
          value = (void *)*MEMORY[0x1E4F1CFD0];
          v181 = v98;
          do
          {
            unsigned int v99 = *v95;
            unsigned int v100 = v95[1];
            unsigned int v101 = *((_DWORD *)v95 + 1);
            v102 = v94;
            unsigned int v103 = v95[4];
            unsigned int v104 = v95[5];
            id v202 = (id)0xAAAAAAAAAAAAAAAALL;
            TCFNumber::TCFNumber<short>(&v202, bswap32(v104) >> 16);
            int v105 = bswap32(v103);
            v94 = v102;
            BOOL v106 = v180 != 16777472;
            if ((v105 & 0x40000000) == 0) {
              BOOL v106 = 1;
            }
            int v189 = v105 >> 16;
            if (v105 >> 16 >= 0) {
              BOOL v106 = 1;
            }
            signed int v107 = bswap32(v101);
            v108 = (unsigned __int16 *)((char *)v102 + v107);
            if (v107 < 0
              || ((unsigned int v109 = bswap32(v100) >> 16, v110 = &v108[2 * v109], v110 >= v108)
                ? (BOOL v111 = (unint64_t)v110 > v184)
                : (BOOL v111 = 1),
                  v111))
            {
              BOOL v112 = (unint64_t)(v108 + 2) > v184 || v107 <= -1;
              unsigned int v109 = (v184 - v108) >> 2;
              if (v112) {
                LOWORD(v109) = 0;
              }
            }
            if ((unsigned __int16)v109 > ((unsigned __int16)(HIWORD(v105) & 0x8000) >> 15))
            {
              v183 = v95;
              int v113 = __rev16(v99);
              uint64_t v114 = BYTE2(v105);
              uint64_t v115 = (unsigned __int16)v109;
              if (v106) {
                uint64_t v116 = 0;
              }
              else {
                uint64_t v116 = v114;
              }
              id v211 = CFArrayCreateMutable(allocatora, (unsigned __int16)v109, MEMORY[0x1E4F1D510]);
              if (atomic_load_explicit((atomic_ullong *volatile)&v211, memory_order_acquire))
              {
                if (v189 >= 0) {
                  __int16 v117 = -2;
                }
                else {
                  __int16 v117 = -1;
                }
                __int16 v195 = v117;
                BOOL v119 = v180 == 16777472 && v99 != 0;
                BOOL v192 = v119;
                do
                {
                  unsigned int v120 = bswap32(*v108);
                  if (*(void *)&v214[8])
                  {
                    LOWORD(v204[0]) = v113;
                    v121 = std::__hash_table<std::__hash_value_type<unsigned short,OTL::FeatureTable const*>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,OTL::FeatureTable const*>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,OTL::FeatureTable const*>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,OTL::FeatureTable const*>>>::find<unsigned short>(__p, (unsigned __int16 *)v204);
                    BOOL v122 = v121 && *((unsigned __int16 *)v121 + 9) == HIWORD(v120);
                  }
                  else
                  {
                    if (v189 < 0) {
                      BOOL v123 = v116 == 0;
                    }
                    else {
                      BOOL v123 = (v120 & 0x10000) == 0;
                    }
                    BOOL v122 = v123;
                  }
                  int v124 = *(_DWORD *)&v195 & HIWORD(v120);
                  id v210 = (id)0xAAAAAAAAAAAAAAAALL;
                  TCFNumber::TCFNumber<short>(&v210, bswap32(v108[1]) >> 16);
                  id v209 = (id)0xAAAAAAAAAAAAAAAALL;
                  id explicit = (const void *)atomic_load_explicit((atomic_ullong *volatile)&v210, memory_order_acquire);
                  id v209 = 0;
                  v204[0] = CFDictionaryCreateMutable(allocatora, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                  TCFNumber::TCFNumber<int>(&v212, v124);
                  CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)v204, memory_order_acquire), @"CTFeatureSelectorIdentifier", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v212, memory_order_acquire));

                  if (explicit) {
                    CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)v204, memory_order_acquire), @"CTFeatureSelectorNameID", explicit);
                  }
                  if (v122) {
                    CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)v204, memory_order_acquire), @"CTFeatureSelectorDefault", value);
                  }

                  if (v192)
                  {
                    v204[0] = (id)0xAAAAAAAAAAAAAAAALL;
                    CopyOTFeatureSettingForTypeAndSelector(v113, v124, v204);
                    if (atomic_load_explicit((atomic_ullong *volatile)v204, memory_order_acquire))
                    {
                      unint64_t v126 = atomic_load_explicit((atomic_ullong *volatile)v204, memory_order_acquire);
                      v127 = v126
                           ? (const void *)[*(id *)(v126 + 8) objectForKey:@"CTFeatureOpenTypeTag"]: 0;
                      unint64_t v128 = atomic_load_explicit((atomic_ullong *volatile)v204, memory_order_acquire);
                      if (v128)
                      {
                        uint64_t v129 = [*(id *)(v128 + 8) objectForKey:@"CTFeatureOpenTypeValue"];
                        if (v127)
                        {
                          v130 = (const void *)v129;
                          if (v129)
                          {
                            CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v209, memory_order_acquire), @"CTFeatureOpenTypeTag", v127);
                            CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v209, memory_order_acquire), @"CTFeatureOpenTypeValue", v130);
                          }
                        }
                      }
                    }
                  }
                  id v131 = (id)atomic_load_explicit((atomic_ullong *volatile)&v209, memory_order_acquire);
                  CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v211, memory_order_acquire), v131);

                  --v116;
                  v108 += 2;
                  --v115;
                }
                while (v115);
              }
              v132 = (void *)atomic_exchange((atomic_ullong *volatile)&v211, 0);

              id v211 = (id)0xAAAAAAAAAAAAAAAALL;
              v133 = (const void *)atomic_load_explicit((atomic_ullong *volatile)&v202, memory_order_acquire);
              id v211 = 0;
              v204[0] = CFDictionaryCreateMutable(allocatora, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
              TCFNumber::TCFNumber<int>(&v212, v113);
              CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)v204, memory_order_acquire), @"CTFeatureTypeIdentifier", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v212, memory_order_acquire));

              CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)v204, memory_order_acquire), @"CTFeatureTypeSelectors", v132);
              if (v133) {
                CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)v204, memory_order_acquire), @"CTFeatureTypeNameID", v133);
              }
              v98 = v181;
              v94 = v182;
              if (v189 < 0) {
                CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)v204, memory_order_acquire), @"CTFeatureTypeExclusive", value);
              }

              id v134 = (id)atomic_load_explicit((atomic_ullong *volatile)&v211, memory_order_acquire);
              CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), v134);

              v95 = v183;
            }

            v95 += 6;
          }
          while (v95 != v98);
        }
        goto LABEL_253;
      }
      long long v13 = operator new(0x18uLL);
      uint64_t v14 = v13;
      *long long v13 = 0;
      v13[1] = 0;
      *((_DWORD *)v13 + 4) = 0;
      int8x8_t v15 = (int8x8_t)v204[1];
      if (v204[1])
      {
        if (*(void *)v204[0])
        {
          uint64_t v16 = **(uint64_t ***)v204[0];
          if (v16)
          {
            uint8x8_t v17 = (uint8x8_t)vcnt_s8((int8x8_t)v204[1]);
            v17.i16[0] = vaddlv_u8(v17);
            do
            {
              unint64_t v18 = v16[1];
              if (v18)
              {
                if (v17.u32[0] > 1uLL)
                {
                  if ((id)v18 < v204[1]) {
                    break;
                  }
                  unint64_t v19 = v18 % (unint64_t)v204[1];
                }
                else
                {
                  unint64_t v19 = v18 & ((unint64_t)v204[1] - 1);
                }
                if (v19) {
                  break;
                }
              }
              else if (!*((_WORD *)v16 + 8))
              {
                operator delete(v13);
                goto LABEL_49;
              }
              uint64_t v16 = (uint64_t *)*v16;
            }
            while (v16);
          }
        }
      }
      float v20 = (float)(unint64_t)(*((void *)&v205 + 1) + 1);
      if (v204[1] && (float)(v206 * (float)(unint64_t)v204[1]) >= v20)
      {
        unint64_t v21 = 0;
      }
      else
      {
        BOOL v22 = v204[1] < (id)3 || ((unint64_t)v204[1] & ((unint64_t)v204[1] - 1)) != 0;
        unint64_t v23 = v22 | (2 * (uint64_t)v204[1]);
        unint64_t v24 = vcvtps_u32_f32(v20 / v206);
        if (v23 <= v24) {
          size_t v25 = v24;
        }
        else {
          size_t v25 = v23;
        }
        std::__hash_table<std::__hash_value_type<unsigned int,OTL::Lookup>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,OTL::Lookup>>>::__rehash<true>((uint64_t)v204, v25);
        int8x8_t v15 = (int8x8_t)v204[1];
        unint64_t v21 = v14[1];
      }
      uint8x8_t v26 = (uint8x8_t)vcnt_s8(v15);
      v26.i16[0] = vaddlv_u8(v26);
      if (v26.u32[0] > 1uLL)
      {
        if (v21 >= *(void *)&v15) {
          v21 %= *(void *)&v15;
        }
      }
      else
      {
        v21 &= *(void *)&v15 - 1;
      }
      uint64_t v27 = v204[0];
      unsigned int v28 = (void *)*((void *)v204[0] + v21);
      if (v28)
      {
        *uint64_t v14 = *v28;
      }
      else
      {
        *uint64_t v14 = v205;
        *(void *)&long long v205 = v14;
        v27[v21] = &v205;
        if (!*v14)
        {
LABEL_48:
          ++*((void *)&v205 + 1);
LABEL_49:
          unsigned int v30 = *((_DWORD *)v194 + 1);
          if (v30)
          {
            int v31 = 0;
            unsigned int v32 = bswap32(v30);
            if (v32 <= 1) {
              unsigned int v32 = 1;
            }
            unsigned int v191 = v32;
            CFAllocatorRef allocator = (CFAllocatorRef)v10;
            while (1)
            {
              if (v194 > v12 + 8 || (unint64_t)(v12 + 12) > v10) {
                goto LABEL_108;
              }
              CFAllocatorRef v34 = (const __CFAllocator *)(v12 + 16);
              LODWORD(v35) = bswap32(*((_DWORD *)v12 + 2));
              unint64_t v36 = (unint64_t)&v12[12 * v35 + 16];
              if (v36 < (unint64_t)(v12 + 16) || v36 > v10)
              {
                if ((unint64_t)(v12 + 28) > v10) {
                  goto LABEL_107;
                }
                unint64_t v35 = (allocator - v34) / 0xCuLL;
              }
              if ((_WORD)v35)
              {
                unint64_t v38 = (unsigned __int16 *)((char *)v34 + 12 * (unsigned __int16)v35);
                while ((*(_DWORD *)v12 & *((_DWORD *)v34 + 1)) == 0)
                {
LABEL_106:
                  CFAllocatorRef v34 = (const __CFAllocator *)((char *)v34 + 12);
                  if (v34 == (const __CFAllocator *)v38) {
                    goto LABEL_107;
                  }
                }
                unint64_t v39 = bswap32(*(unsigned __int16 *)v34) >> 16;
                unint64_t v40 = (unint64_t)v204[1];
                if (v204[1])
                {
                  uint8x8_t v41 = (uint8x8_t)vcnt_s8((int8x8_t)v204[1]);
                  v41.i16[0] = vaddlv_u8(v41);
                  if (v41.u32[0] > 1uLL)
                  {
                    unint64_t v42 = v39;
                    if (v204[1] <= (id)v39) {
                      unint64_t v42 = v39 % (unint64_t)v204[1];
                    }
                  }
                  else
                  {
                    unint64_t v42 = (LODWORD(v204[1]) - 1) & v39;
                  }
                  unint64_t v43 = (uint64_t ***)*((void *)v204[0] + v42);
                  if (v43)
                  {
                    for (j = *v43; j; j = (uint64_t **)*j)
                    {
                      unint64_t v45 = (unint64_t)j[1];
                      if (v45 == v39)
                      {
                        if (*((unsigned __int16 *)j + 8) == v39) {
                          goto LABEL_106;
                        }
                      }
                      else
                      {
                        if (v41.u32[0] > 1uLL)
                        {
                          if ((id)v45 >= v204[1]) {
                            v45 %= (unint64_t)v204[1];
                          }
                        }
                        else
                        {
                          v45 &= (unint64_t)v204[1] - 1;
                        }
                        if (v45 != v42) {
                          break;
                        }
                      }
                    }
                  }
                }
                else
                {
                  unint64_t v42 = 0xAAAAAAAAAAAAAAAALL;
                }
                unsigned int v46 = bswap32(*((unsigned __int16 *)v34 + 1)) >> 16;
                v47 = operator new(0x18uLL);
                void *v47 = 0;
                v47[1] = v39;
                *((_WORD *)v47 + 8) = v39;
                *((_WORD *)v47 + 9) = v46;
                float v48 = (float)(unint64_t)(*((void *)&v205 + 1) + 1);
                if (!v40 || (float)(v206 * (float)v40) < v48)
                {
                  BOOL v49 = (v40 & (v40 - 1)) != 0;
                  if (v40 < 3) {
                    BOOL v49 = 1;
                  }
                  unint64_t v50 = v49 | (2 * v40);
                  unint64_t v51 = vcvtps_u32_f32(v48 / v206);
                  if (v50 <= v51) {
                    size_t v52 = v51;
                  }
                  else {
                    size_t v52 = v50;
                  }
                  std::__hash_table<std::__hash_value_type<unsigned int,OTL::Lookup>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,OTL::Lookup>>>::__rehash<true>((uint64_t)v204, v52);
                  unint64_t v40 = (unint64_t)v204[1];
                  if (((unint64_t)v204[1] & ((unint64_t)v204[1] - 1)) != 0)
                  {
                    if (v204[1] <= (id)v39) {
                      unint64_t v42 = v39 % (unint64_t)v204[1];
                    }
                    else {
                      unint64_t v42 = v39;
                    }
                  }
                  else
                  {
                    unint64_t v42 = (LODWORD(v204[1]) - 1) & v39;
                  }
                }
                BOOL v53 = v204[0];
                CFDictionaryRef v54 = (void *)*((void *)v204[0] + v42);
                if (v54)
                {
                  void *v47 = *v54;
                  goto LABEL_104;
                }
                void *v47 = v205;
                *(void *)&long long v205 = v47;
                v53[v42] = &v205;
                if (*v47)
                {
                  unint64_t v55 = *(void *)(*v47 + 8);
                  if ((v40 & (v40 - 1)) != 0)
                  {
                    if (v55 >= v40) {
                      v55 %= v40;
                    }
                  }
                  else
                  {
                    v55 &= v40 - 1;
                  }
                  CFDictionaryRef v54 = (char *)v204[0] + 8 * v55;
LABEL_104:
                  *CFDictionaryRef v54 = v47;
                }
                ++*((void *)&v205 + 1);
                goto LABEL_106;
              }
LABEL_107:
              v12 += bswap32(*((_DWORD *)v12 + 1));
              ++v31;
              unint64_t v10 = (unint64_t)allocator;
              if (v31 == v191) {
                goto LABEL_108;
              }
            }
          }
          goto LABEL_108;
        }
        unint64_t v29 = *(void *)(*v14 + 8);
        if (v26.u32[0] > 1uLL)
        {
          if (v29 >= *(void *)&v15) {
            v29 %= *(void *)&v15;
          }
        }
        else
        {
          v29 &= *(void *)&v15 - 1;
        }
        unsigned int v28 = (char *)v204[0] + 8 * v29;
      }
      *unsigned int v28 = v14;
      goto LABEL_48;
    }
  }
  else if ((*(unsigned int (**)(TBaseFont *, uint64_t))(*(void *)v4 + 472))(v4, 1717920116))
  {
    unint64_t v11 = (void *)atomic_exchange((atomic_ullong *volatile)this, (unint64_t)CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, MEMORY[0x1E4F1D510]));
LABEL_316:

    goto LABEL_317;
  }
LABEL_255:
  if (a3 && atomic_load_explicit((atomic_ullong *volatile)this, memory_order_acquire))
  {
    if (LOBYTE(v208[0]))
    {
      CustomOTFeatures(v4, 1, v204);
      v135 = (unsigned int *)v204[0];
      v193 = (unsigned int *)v204[1];
      if (v204[0] != v204[1])
      {
        CFAllocatorRef v136 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        valuea = (void *)*MEMORY[0x1E4F1CFD0];
        CFAllocatorRef v190 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        while (1)
        {
          unsigned int v137 = *v135;
          LODWORD(__p[0]) = bswap32(*v135);
          BYTE4(__p[0]) = 0;
          v138 = (__CFString *)CFStringCreateWithCString(v136, (const char *)__p, 0);
          int v139 = NumberOfGlyphVariants(v4, v137);
          if (v139) {
            break;
          }
LABEL_303:

          if (++v135 == v193)
          {
            v135 = (unsigned int *)v204[0];
            goto LABEL_305;
          }
        }
        LODWORD(v140) = v139;
        v141 = CFArrayCreateMutable(v136, (v139 + 1), MEMORY[0x1E4F1D510]);
        CFArrayAppendValue(v141, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v201, memory_order_acquire));

        int v142 = 0;
        do
        {
          CFArrayAppendValue(v141, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v200, memory_order_acquire));
        }
        while (v140 != v142);
        ValueAtIndex = (__CFDictionary *)CFArrayGetValueAtIndex(v141, 0);
        __p[0] = (void *)0xAAAAAAAAAAAAAAAALL;
        CTCopyLocalizedString(@"Off", @"OpenType", __p);
        CFDictionarySetValue(ValueAtIndex, @"CTFeatureSelectorName", (const void *)atomic_load_explicit((atomic_ullong *volatile)__p, memory_order_acquire));
        if (v140 == 1)
        {
          v144 = (__CFDictionary *)CFArrayGetValueAtIndex(v141, 1);
          id v212 = (id)0xAAAAAAAAAAAAAAAALL;
          CTCopyLocalizedString(@"On", @"OpenType", &v212);
          CFDictionarySetValue(v144, @"CTFeatureSelectorName", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v212, memory_order_acquire));
        }
        else
        {
          CFIndex v145 = 1;
          do
          {
            v146 = (__CFDictionary *)CFArrayGetValueAtIndex(v141, v145);
            id v212 = (id)0xAAAAAAAAAAAAAAAALL;
            CreateLocalizedStringWithFormat(@"%d", &v212, v145);
            CFDictionarySetValue(v146, @"CTFeatureSelectorName", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v212, memory_order_acquire));

            ++v145;
          }
          while (v145 - v140 != 1);
        }

        id v211 = 0;
        CFAllocatorRef v136 = v190;
        __p[0] = CFDictionaryCreateMutable(v190, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        if ((dyld_program_sdk_at_least() & 1) == 0)
        {
          TCFNumber::TCFNumber<int>(&v212, 0);
          CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)__p, memory_order_acquire), @"CTFeatureTypeIdentifier", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v212, memory_order_acquire));
        }
        CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)__p, memory_order_acquire), @"CTFeatureOpenTypeTag", v138);
        CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)__p, memory_order_acquire), @"CTFeatureTypeSelectors", v141);
        CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)__p, memory_order_acquire), @"CTFeatureTypeExclusive", valuea);

        if ((v137 & 0xFFFF0000) == 0x73730000)
        {
          unsigned __int16 CharacterVariantOrStylisticSet = GetCharacterVariantOrStylisticSet(v137);
          if (CharacterVariantOrStylisticSet >= 0x100u)
          {
            unsigned __int8 v167 = CharacterVariantOrStylisticSet;
            __p[0] = (void *)0xAAAAAAAAAAAAAAAALL;
            CTCopyLocalizedString(@"Stylistic Set %d", @"OpenType", &v212);
            CreateLocalizedStringWithFormat((const __CFString *)atomic_load_explicit((atomic_ullong *volatile)&v212, memory_order_acquire), __p, v167);

            CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v211, memory_order_acquire), @"CTFeatureTypeName", (const void *)atomic_load_explicit((atomic_ullong *volatile)__p, memory_order_acquire));
            CFDataRef v168 = NameIDForStylisticSet(v185, v167);
            if ((v168 & 0xFF0000) != 0)
            {
              id v212 = (id)0xAAAAAAAAAAAAAAAALL;
              TCFNumber::TCFNumber<int>(&v212, (unsigned __int16)v168);
              CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v211, memory_order_acquire), @"CTFeatureTypeNameID", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v212, memory_order_acquire));
            }
            goto LABEL_300;
          }
        }
        else if ((v137 & 0xFFFF0000) == 0x63760000)
        {
          unsigned __int16 v147 = GetCharacterVariantOrStylisticSet(v137);
          if (v147 >= 0x100u)
          {
            unsigned __int8 v148 = v147;
            id v210 = (id)0xAAAAAAAAAAAAAAAALL;
            CTCopyLocalizedString(@"Character Variant %d", @"OpenType", __p);
            CreateLocalizedStringWithFormat((const __CFString *)atomic_load_explicit((atomic_ullong *volatile)__p, memory_order_acquire), &v210, v148);

            CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v211, memory_order_acquire), @"CTFeatureTypeName", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v210, memory_order_acquire));
            LODWORD(v209) = -1442797056;
            LODWORD(Mutable) = -1442797056;
            unint64_t v221 = 0xAAAAAAAAAAAAAAAALL;
            *(void *)&long long v149 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v149 + 1) = 0xAAAAAAAAAAAAAAAALL;
            long long v219 = v149;
            long long v220 = v149;
            long long v217 = v149;
            long long v218 = v149;
            long long v215 = v149;
            long long v216 = v149;
            *(_OWORD *)&v214[8] = v149;
            __p[0] = 0;
            __p[1] = 0;
            *(void *)v214 = 0;
            v222 = &v214[8];
            uint64_t v150 = NameIDForCharacterVariant(v185, v148, (uint64_t)&v209, (uint64_t)&Mutable, __p);
            if ((v150 & 0xFF0000) != 0)
            {
              unsigned __int16 v151 = v150;
              if (BYTE2(v209))
              {
                v152 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v211, memory_order_acquire);
                TCFNumber::TCFNumber<int>(&v212, (unsigned __int16)v209);
                CFDictionarySetValue(v152, @"CTFontFeatureSampleTextNameID", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v212, memory_order_acquire));
              }
              if (BYTE2(Mutable))
              {
                v153 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v211, memory_order_acquire);
                TCFNumber::TCFNumber<int>(&v212, (unsigned __int16)Mutable);
                CFDictionarySetValue(v153, @"CTFontFeatureTooltipTextNameID", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v212, memory_order_acquire));
              }
              id v212 = (id)0xAAAAAAAAAAAAAAAALL;
              TCFNumber::TCFNumber<int>(&v212, v151);
              CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v211, memory_order_acquire), @"CTFeatureTypeNameID", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v212, memory_order_acquire));
            }
            unint64_t v154 = (unint64_t)((char *)__p[1] - (char *)__p[0]) >> 2;
            if (v140 >= v154) {
              uint64_t v140 = v154;
            }
            else {
              uint64_t v140 = v140;
            }
            if (v140)
            {
              for (uint64_t k = 0; k != v140; ++k)
              {
                v156 = (__CFDictionary *)CFArrayGetValueAtIndex(v141, k + 1);
                id v212 = (id)0xAAAAAAAAAAAAAAAALL;
                TCFNumber::TCFNumber<int>(&v212, *((_DWORD *)__p[0] + k));
                CFDictionarySetValue(v156, @"CTFeatureSelectorNameID", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v212, memory_order_acquire));
              }
            }
            id v212 = __p;
            std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v212);

            CFAllocatorRef v136 = v190;
            goto LABEL_300;
          }
        }
        __p[0] = (void *)0xAAAAAAAAAAAAAAAALL;
        CopyLocalizedOTFeatureName(v138, __p);
        if (atomic_load_explicit((atomic_ullong *volatile)__p, memory_order_acquire))
        {
          CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v211, memory_order_acquire), @"CTFeatureTypeName", (const void *)atomic_load_explicit((atomic_ullong *volatile)__p, memory_order_acquire));
        }
        else
        {
          id v212 = (id)0xAAAAAAAAAAAAAAAALL;
          CopyFeatureSettingForTag(v138, 0, 0, 0, 1, &v212);
          if (!atomic_load_explicit((atomic_ullong *volatile)&v212, memory_order_acquire)) {
            goto LABEL_295;
          }
          unint64_t v158 = atomic_load_explicit((atomic_ullong *volatile)&v212, memory_order_acquire);
          if (!v158) {
            goto LABEL_295;
          }
          uint64_t v159 = [*(id *)(v158 + 8) objectForKey:@"CTFeatureTypeIdentifier"];
          if (!v159) {
            goto LABEL_295;
          }
          v160 = (void *)v159;
          v161 = (void *)[*(id *)(v158 + 8) objectForKey:@"CTFeatureSelectorIdentifier"];
          if (v161
            && (FeatureSelector = (__CFDictionary *)TFontFeatures::GetFeatureSelector((atomic_ullong *)this, [v160 unsignedShortValue], objc_msgSend(v161, "unsignedShortValue"))) != 0&& (v163 = FeatureSelector, CFDictionaryAddValue(FeatureSelector, @"CTFeatureOpenTypeTag", v138), CFDictionaryAddValue(v163, @"CTFeatureOpenTypeValue", &unk_1ED080898), (v164 = CFDictionaryGetValue(v163, @"CTFeatureSelectorNameID")) != 0))
          {
            CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v211, memory_order_acquire), @"CTFeatureTypeNameID", v164);

            v165 = (__CFString *)__p[0];
          }
          else
          {
LABEL_295:

            CFStringRef v166 = CFStringCreateWithFormat(v190, 0, @"'%@'", v138);
            CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v211, memory_order_acquire), @"CTFeatureTypeName", v166);
            v165 = (__CFString *)v166;
          }
        }
LABEL_300:
        v169 = (__CFArray *)atomic_load_explicit((atomic_ullong *volatile)this, memory_order_acquire);
        if (v169) {
          CFArrayAppendValue(v169, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v211, memory_order_acquire));
        }

        uint64_t v4 = v185;
        goto LABEL_303;
      }
LABEL_305:
      if (v135)
      {
        v204[1] = v135;
        operator delete(v135);
      }
    }
    __p[0] = (void *)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(void **__return_ptr, TBaseFont *))(*(void *)v4 + 496))(__p, v4);
    atomic_load_explicit((atomic_ullong *volatile)__p, memory_order_acquire);
    uint64_t v170 = CGFontNameTableCreate();
    CFArrayRef allocatorb = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)this, memory_order_acquire);
    if (allocatorb)
    {
      CFIndex Count = CFArrayGetCount(allocatorb);
      if (Count)
      {
        for (CFIndex m = 0; m != Count; ++m)
        {
          v172 = (id)CFArrayGetValueAtIndex(allocatorb, m);
          ReplaceNameIDKeyWithLocalizedName((const __CFDictionary *)v172, @"CTFeatureTypeNameID", @"CTFeatureTypeName", v170, @"FeatureTypeNames");
          ReplaceNameIDKeyWithLocalizedName((const __CFDictionary *)v172, @"CTFontFeatureSampleTextNameID", @"CTFeatureSampleText", v170, 0);
          ReplaceNameIDKeyWithLocalizedName((const __CFDictionary *)v172, @"CTFontFeatureTooltipTextNameID", @"CTFeatureTooltipText", v170, 0);
          CFArrayRef v173 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)v172, @"CTFeatureTypeSelectors");
          if (v173)
          {
            CFArrayRef v174 = v173;
            CFIndex v175 = CFArrayGetCount(v173);
            if (v175)
            {
              CFIndex v176 = v175;
              for (CFIndex n = 0; n != v176; ++n)
              {
                v178 = (id)CFArrayGetValueAtIndex(v174, n);
                ReplaceNameIDKeyWithLocalizedName((const __CFDictionary *)v178, @"CTFeatureSelectorNameID", @"CTFeatureSelectorName", v170, @"FeatureSelectorNames");
              }
            }
          }
        }
      }
    }
    CGFontNameTableRelease();
    unint64_t v11 = __p[0];
    goto LABEL_316;
  }
LABEL_317:
}

uint64_t IsFontSpecificFeatureSetting(CTFeatureSetting *a1)
{
  uint64_t v1 = a1;
  id v13 = 0;
  uint64_t v2 = -[CTFeatureSetting type]((uint64_t)a1);
  if (v2)
  {
    CFNumberRef v3 = (const __CFNumber *)v2;
    CFNumberRef v4 = (const __CFNumber *)-[CTFeatureSetting selector]((uint64_t)v1);
    LOWORD(v12) = -21846;
    CFNumberGetValue(v3, kCFNumberShortType, &v12);
    int v5 = (unsigned __int16)v12;
    LOWORD(v12) = -21846;
    CFNumberGetValue(v4, kCFNumberShortType, &v12);
    CopyOTFeatureSettingForTypeAndSelector(v5, (unsigned __int16)v12, &v12);

    unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&v13, memory_order_acquire);
    if (!explicit)
    {
      uint64_t v7 = 0;
      while (*(unsigned __int16 *)((char *)&kMasterFeatureMap + v7 + 4) != v5
           || (*(_WORD *)((unsigned char *)&kMasterFeatureMap + v7 + 8) & 0x8040) == 0)
      {
        v7 += 12;
        if (v7 == 1980) {
          goto LABEL_8;
        }
      }
      goto LABEL_10;
    }
    uint64_t v1 = (CTFeatureSetting *)atomic_load_explicit((atomic_ullong *volatile)&v13, memory_order_acquire);
  }
LABEL_8:
  CFStringRef v8 = (const __CFString *)-[CTFeatureSetting tag]((uint64_t)v1);
  if (!v8 || (unsigned int v9 = FourCharCodeFromString(v8), (IsOTFeatureFontSpecific(v9) & 1) == 0))
  {
    uint64_t v10 = 0;
    goto LABEL_12;
  }
LABEL_10:
  uint64_t v10 = 1;
LABEL_12:

  return v10;
}

void CopyOTFeatureSettingForTypeAndSelector(int a1@<W0>, int a2@<W1>, void *a3@<X8>)
{
  if (qword_1EB2CE4E8 != -1) {
    dispatch_once_f(&qword_1EB2CE4E8, 0, (dispatch_function_t)CopyOTFeatureSettingForTypeAndSelector(unsigned short,unsigned short)::$_0::__invoke);
  }
  if (!v6) {
    goto LABEL_7;
  }
  uint64_t v7 = (unsigned int *)v6[3];
  unsigned int v8 = v7[2];
  if (v8)
  {
    if ((v8 & 0xA) == 0)
    {
      *(_DWORD *)cStr = bswap32(*v7);
      char v15 = 0;
      CFStringRef v11 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], cStr, 0);
      *a3 = -[CTFeatureSetting initWithType:selector:tag:value:]([CTFeatureSetting alloc], 0, 0, (uint64_t)v11, (NSNumber *)[NSNumber numberWithUnsignedInt:1]);
      uint64_t v10 = (__CFString *)v11;
      goto LABEL_9;
    }
LABEL_7:
    *a3 = 0;
    return;
  }
  unsigned int v12 = bswap32(*v7);
  char v13 = 0;
  CFStringRef v9 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const char *)&v12, 0);
  *a3 = -[CTFeatureSetting initWithType:selector:tag:value:]([CTFeatureSetting alloc], 0, 0, (uint64_t)v9, (NSNumber *)[NSNumber numberWithUnsignedInt:(a2 & 1) == 0]);
  uint64_t v10 = (__CFString *)v9;
LABEL_9:
}

void *TCFNumber::TCFNumber<int>(void *a1, int a2)
{
  int valuePtr = a2;
  id v4 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
  *a1 = atomic_exchange((atomic_ullong *volatile)&v4, 0);

  return a1;
}

void TAttributes::CopyOfFontWithLigatureSetting(CTFontRef *a1, const __CTFont *a2, int a3)
{
  id v7 = (id)0xAAAAAAAAAAAAAAAALL;
  CreateFeatureSettingsForLigatureSetting(&v7, *(void *)(*((void *)a2 + 5) + 400), a3);
  if (atomic_load_explicit((atomic_ullong *volatile)&v7, memory_order_acquire))
  {
    values = (void *)atomic_load_explicit((atomic_ullong *volatile)&v7, memory_order_acquire);
    keys = @"NSCTFontFeatureSettingsAttribute";
    CFDictionaryRef v5 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    int v6 = CTFontDescriptorCreateWithAttributes(v5);
    *a1 = CTFontCreateCopyWithAttributes(a2, 0.0, 0, v6);
  }
  else
  {

    *a1 = a2;
  }
}

CTFontDescriptorRef CTFontDescriptorCreateWithAttributes(CFDictionaryRef attributes)
{
  CFDictionaryRef v5 = attributes;
  if (!attributes) {
    return 0;
  }
  id v4 = (id)0xAAAAAAAAAAAAAAAALL;
  TCFBase_NEW<CTFontDescriptor,__CFDictionary const*&>((void **)&v5, &v3);
  id v4 = (id)atomic_exchange((atomic_ullong *volatile)&v3, 0);

  uint64_t v1 = (const __CTFontDescriptor *)atomic_exchange((atomic_ullong *volatile)&v4, 0);
  return v1;
}

void TCFBase_NEW<CTFontDescriptor,__CFDictionary const*&>(void **a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = TCFBase<TDescriptor>::Allocate();
  if (v4)
  {
    CFDictionaryRef v5 = (void *)v4;
    int v6 = *a1;
    *(void *)(v4 + 16) = 0;
    *(void *)(v4 + 24) = TDescriptor::Hash;
    *(void *)(v4 + 32) = 0;
    *(void *)(v4 + 40) = v4 + 48;
    *(void *)(v4 + 48) = &unk_1ED05D778;
    *(void *)(v4 + 56) = 0;
    *(_DWORD *)(v4 + 64) = 0;
    *(void *)(v4 + 80) = 0;
    *(void *)(v4 + 88) = 0;
    *(void *)(v4 + 72) = 0;
    TCFRef<__CTFont const*>::Retain((atomic_ullong *)(v4 + 56), v6);
    id v7 = v5;
    *a2 = atomic_exchange((atomic_ullong *volatile)&v7, 0);
  }
  else
  {
    *a2 = 0;
  }
}

void CreateFeatureSettingsForLigatureSetting(void *a1, uint64_t a2, int a3)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v56[3] = v4;
  v56[2] = v4;
  v56[1] = v4;
  v56[0] = v4;
  CFDictionaryRef v54 = 0;
  unint64_t v55 = 0;
  BOOL v53 = 0;
  CFDataRef v57 = v56;
  id v50 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr, uint64_t, void))(*(void *)a2 + 136))(&v50, a2, 0);
  CFArrayRef explicit = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v50, memory_order_acquire);
  if (explicit)
  {
    CFIndex Count = CFArrayGetCount(explicit);
    if (Count)
    {
      CFIndex v6 = 0;
      CFArrayRef v48 = explicit;
      while (1)
      {
        CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(explicit, v6);
        CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, @"CTFeatureTypeIdentifier");
        if (Value)
        {
          LOWORD(valuePtr[0]) = -21846;
          CFNumberGetValue(Value, kCFNumberShortType, valuePtr);
          if (LOWORD(valuePtr[0]) == 1)
          {
            CFArrayRef v9 = (const __CFArray *)CFDictionaryGetValue(ValueAtIndex, @"CTFeatureTypeSelectors");
            if (v9)
            {
              CFArrayRef v10 = v9;
              CFIndex v11 = CFArrayGetCount(v9);
              if (v11) {
                break;
              }
            }
          }
        }
LABEL_66:
        if (++v6 == Count) {
          goto LABEL_67;
        }
      }
      CFIndex v12 = v11;
      CFIndex v13 = 0;
      while (1)
      {
        CFDictionaryRef v14 = (const __CFDictionary *)CFArrayGetValueAtIndex(v10, v13);
        CFNumberRef v15 = (const __CFNumber *)CFDictionaryGetValue(v14, @"CTFeatureSelectorIdentifier");
        if (v15)
        {
          LOWORD(valuePtr[0]) = -21846;
          CFNumberGetValue(v15, kCFNumberShortType, valuePtr);
          __int16 v16 = (__int16)valuePtr[0];
          if (!LOWORD(valuePtr[0]))
          {
            uint8x8_t v17 = v54;
            if (v54 < v55)
            {
              *(_WORD *)CFDictionaryRef v54 = 0;
              unint64_t v24 = (void **)((char *)v17 + 2);
              goto LABEL_27;
            }
            unint64_t v18 = v53;
            uint64_t v26 = (char *)v54 - (char *)v53;
            if ((char *)v54 - (char *)v53 <= -3) {
              goto LABEL_73;
            }
            uint64_t v27 = v26 >> 1;
            if ((char *)v55 - (char *)v53 <= (unint64_t)((v26 >> 1) + 1)) {
              uint64_t v28 = v27 + 1;
            }
            else {
              uint64_t v28 = (char *)v55 - (char *)v53;
            }
            if ((unint64_t)((char *)v55 - (char *)v53) >= 0x7FFFFFFFFFFFFFFELL) {
              uint64_t v22 = 0x7FFFFFFFFFFFFFFFLL;
            }
            else {
              uint64_t v22 = v28;
            }
            size_t v52 = v56;
            if (v22)
            {
              unint64_t v23 = (char *)TInlineBufferAllocator<unsigned short,30ul>::allocate((uint64_t)v56, v22);
              unint64_t v18 = v53;
              uint8x8_t v17 = v54;
            }
            else
            {
              unint64_t v23 = 0;
            }
            unsigned int v32 = &v23[2 * v27];
            *(_WORD *)unsigned int v32 = 0;
            if (v17 == v18)
            {
              CFAllocatorRef v34 = &v23[2 * v27];
            }
            else
            {
              v33 = v17;
              CFAllocatorRef v34 = &v23[2 * v27];
              do
              {
                __int16 v35 = *((_WORD *)v33 - 1);
                v33 = (void **)((char *)v33 - 2);
                *((_WORD *)v34 - 1) = v35;
                v34 -= 2;
              }
              while (v33 != v18);
            }
            goto LABEL_63;
          }
          if (!a3)
          {
            __int16 v16 = LOWORD(valuePtr[0]) + 1;
            uint8x8_t v17 = v54;
            if (v54 < v55) {
              goto LABEL_26;
            }
            unint64_t v18 = v53;
            uint64_t v29 = (char *)v54 - (char *)v53;
            if ((char *)v54 - (char *)v53 <= -3) {
LABEL_73:
            }
              abort();
            uint64_t v30 = v29 >> 1;
            if ((char *)v55 - (char *)v53 <= (unint64_t)((v29 >> 1) + 1)) {
              uint64_t v31 = v30 + 1;
            }
            else {
              uint64_t v31 = (char *)v55 - (char *)v53;
            }
            if ((unint64_t)((char *)v55 - (char *)v53) >= 0x7FFFFFFFFFFFFFFELL) {
              uint64_t v22 = 0x7FFFFFFFFFFFFFFFLL;
            }
            else {
              uint64_t v22 = v31;
            }
            size_t v52 = v56;
            if (v22)
            {
              unint64_t v23 = (char *)TInlineBufferAllocator<unsigned short,30ul>::allocate((uint64_t)v56, v22);
              unint64_t v18 = v53;
              uint8x8_t v17 = v54;
            }
            else
            {
              unint64_t v23 = 0;
            }
            unsigned int v32 = &v23[2 * v30];
            *(_WORD *)unsigned int v32 = v16;
            if (v17 == v18) {
              goto LABEL_62;
            }
            unint64_t v38 = v17;
            CFAllocatorRef v34 = &v23[2 * v30];
            CFArrayRef explicit = v48;
            do
            {
              __int16 v39 = *((_WORD *)v38 - 1);
              unint64_t v38 = (void **)((char *)v38 - 2);
              *((_WORD *)v34 - 1) = v39;
              v34 -= 2;
            }
            while (v38 != v18);
LABEL_63:
            size_t v25 = (void **)(v32 + 2);
            BOOL v53 = (void **)v34;
            CFDictionaryRef v54 = (void **)(v32 + 2);
            unint64_t v40 = v55;
            unint64_t v55 = (void **)&v23[2 * v22];
            valuePtr[2] = v17;
            valuePtr[3] = v40;
            valuePtr[0] = v18;
            valuePtr[1] = v18;
            std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,30ul> &>::~__split_buffer((uint64_t)valuePtr);
            goto LABEL_64;
          }
          if (a3 == 2)
          {
            uint8x8_t v17 = v54;
            if (v54 >= v55)
            {
              unint64_t v18 = v53;
              uint64_t v19 = (char *)v54 - (char *)v53;
              if ((char *)v54 - (char *)v53 <= -3) {
                goto LABEL_73;
              }
              uint64_t v20 = v19 >> 1;
              if ((char *)v55 - (char *)v53 <= (unint64_t)((v19 >> 1) + 1)) {
                uint64_t v21 = v20 + 1;
              }
              else {
                uint64_t v21 = (char *)v55 - (char *)v53;
              }
              if ((unint64_t)((char *)v55 - (char *)v53) >= 0x7FFFFFFFFFFFFFFELL) {
                uint64_t v22 = 0x7FFFFFFFFFFFFFFFLL;
              }
              else {
                uint64_t v22 = v21;
              }
              size_t v52 = v56;
              if (v22)
              {
                unint64_t v23 = (char *)TInlineBufferAllocator<unsigned short,30ul>::allocate((uint64_t)v56, v22);
                unint64_t v18 = v53;
                uint8x8_t v17 = v54;
              }
              else
              {
                unint64_t v23 = 0;
              }
              unsigned int v32 = &v23[2 * v20];
              *(_WORD *)unsigned int v32 = v16;
              if (v17 != v18)
              {
                unint64_t v36 = v17;
                CFAllocatorRef v34 = &v23[2 * v20];
                CFArrayRef explicit = v48;
                do
                {
                  __int16 v37 = *((_WORD *)v36 - 1);
                  unint64_t v36 = (void **)((char *)v36 - 2);
                  *((_WORD *)v34 - 1) = v37;
                  v34 -= 2;
                }
                while (v36 != v18);
                goto LABEL_63;
              }
LABEL_62:
              CFAllocatorRef v34 = v32;
              CFArrayRef explicit = v48;
              goto LABEL_63;
            }
LABEL_26:
            *(_WORD *)uint8x8_t v17 = v16;
            unint64_t v24 = (void **)((char *)v17 + 2);
LABEL_27:
            size_t v25 = v24;
LABEL_64:
            CFDictionaryRef v54 = v25;
          }
        }
        if (++v13 == v12) {
          goto LABEL_66;
        }
      }
    }
  }
LABEL_67:
  if (v53 == v54)
  {
    *a1 = 0;
  }
  else
  {
    valuePtr[0] = (void **)CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], ((char *)v54 - (char *)v53) >> 1, MEMORY[0x1E4F1D510]);
    uint8x8_t v41 = (unsigned __int16 *)v53;
    unint64_t v42 = (unsigned __int16 *)v54;
    if (v53 != v54)
    {
      do
      {
        unsigned int v43 = *v41++;
        uint64_t v44 = [NSNumber numberWithUnsignedShort:1];
        unint64_t v45 = -[CTFeatureSetting initWithType:selector:tag:value:]([CTFeatureSetting alloc], v44, [NSNumber numberWithUnsignedShort:v43], 0, 0);
        unsigned int v46 = v45;
        CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)valuePtr, memory_order_acquire), v46);
      }
      while (v41 != v42);
    }
    *a1 = atomic_exchange((atomic_ullong *volatile)valuePtr, 0);
  }
  valuePtr[0] = (void **)&v53;
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100](valuePtr);
}

void TFontFeatures::SettingsByNormalizing(atomic_ullong *a1@<X0>, const TBaseFont *a2@<X1>, uint64_t a3@<X2>, atomic_ullong *a4@<X3>, CFArrayRef *a5@<X8>)
{
  id v48 = [[CTFeatureSetting alloc] initWithDictionary:a3];
  if (!atomic_load_explicit((atomic_ullong *volatile)&v48, memory_order_acquire)) {
    goto LABEL_39;
  }
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&v48, memory_order_acquire);
  if (explicit)
  {
    CFStringRef v10 = (const __CFString *)[*(id *)(explicit + 8) objectForKey:@"CTFeatureOpenTypeTag"];
    BOOL v47 = 0;
    unsigned int v46 = 0;
    if (v10)
    {
      unint64_t v11 = atomic_load_explicit((atomic_ullong *volatile)&v48, memory_order_acquire);
      if (v11
        && (CFIndex v12 = (const void *)[*(id *)(v11 + 8) objectForKey:@"CTFeatureOpenTypeValue"]) != 0)
      {
        uint64_t v13 = (uint64_t)v12;
        CFTypeID v14 = CFGetTypeID(v12);
        LODWORD(v45) = 0;
        if (v14 == CFNullGetTypeID())
        {
          uint64_t v15 = 0;
          char v16 = 1;
        }
        else
        {
          GetValue<__CFNumber const*>(v13, &v45);
          char v16 = 0;
          uint64_t v15 = v45;
        }
      }
      else
      {
        uint64_t v15 = 0;
        char v16 = 0;
        LODWORD(v45) = 0;
      }
      CopyFeatureSettingForTag(v10, a2, &v47, &v46, v15, &values);

      char v17 = 1;
    }
    else
    {
      char v17 = 0;
      char v16 = 0;
    }
  }
  else
  {
    char v17 = 0;
    CFStringRef v10 = 0;
    char v16 = 0;
    BOOL v47 = 0;
    unsigned int v46 = 0;
  }
  unint64_t v18 = atomic_load_explicit((atomic_ullong *volatile)&v48, memory_order_acquire);
  if (v18)
  {
    uint64_t v19 = (const void *)[*(id *)(v18 + 8) objectForKey:@"CTFeatureSelectorIdentifier"];
    if ((v16 & 1) == 0)
    {
      if (!v19) {
        goto LABEL_36;
      }
      CFTypeID v20 = CFGetTypeID(v19);
      if (v20 != CFNullGetTypeID()) {
        goto LABEL_36;
      }
    }
  }
  else if ((v16 & 1) == 0)
  {
    goto LABEL_36;
  }
  unint64_t v21 = atomic_load_explicit((atomic_ullong *volatile)&v48, memory_order_acquire);
  uint8x8_t v41 = a2;
  if (v21) {
    CFNumberRef v22 = (const __CFNumber *)[*(id *)(v21 + 8) objectForKey:@"CTFeatureTypeIdentifier"];
  }
  else {
    CFNumberRef v22 = 0;
  }
  unint64_t v23 = TFontFeatures::GetFeatureType(a1, v22);
  unint64_t v24 = v23;
  size_t v25 = a1;
  if (!v23)
  {
LABEL_25:
    CFArrayRef v27 = 0;
    goto LABEL_28;
  }
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)v23, @"CTFeatureTypeSelectors");
  CFArrayRef v27 = Value;
  if (Value)
  {
    CFIndex Count = CFArrayGetCount(Value);
    if (Count)
    {
      CFIndex v29 = Count;
      unint64_t v40 = a5;
      CFIndex v30 = 0;
      while (1)
      {
        id values = (id)CFArrayGetValueAtIndex(v27, v30);
          break;

        if (v29 == ++v30)
        {
          CFArrayRef v27 = 0;
          goto LABEL_27;
        }
      }
      CFArrayRef v27 = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&values, memory_order_acquire);

LABEL_27:
      a5 = v40;
      goto LABEL_28;
    }
    goto LABEL_25;
  }
LABEL_28:
  CFDictionaryRef v31 = v27;
  CFDictionaryRef v32 = v31;
  if (v31) {
    v33 = CFDictionaryGetValue(v31, @"CTFeatureSelectorIdentifier");
  }
  else {
    v33 = 0;
  }
  id values = -[CTFeatureSetting initWithType:selector:tag:value:]([CTFeatureSetting alloc], (uint64_t)v22, (uint64_t)v33, 0, 0);

  char v34 = v17 ^ 1;
  if (!a4) {
    char v34 = 1;
  }
  if ((v34 & 1) == 0)
  {
    id values = -[CTFeatureSetting initWithType:selector:tag:value:]([CTFeatureSetting alloc], 0, 0, (uint64_t)v10, (NSNumber *)[NSNumber numberWithUnsignedInt:v46]);
  }
  a1 = v25;
  a2 = v41;
LABEL_36:
  if (v47)
  {
    if (atomic_load_explicit((atomic_ullong *volatile)&v48, memory_order_acquire))
    {
      id values = (id)atomic_load_explicit((atomic_ullong *volatile)&v48, memory_order_acquire);
      *a5 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&values, 1, MEMORY[0x1E4F1D510]);
      goto LABEL_48;
    }
LABEL_39:
    *a5 = 0;
    goto LABEL_48;
  }
  BOOL HasOTFontFeatureTable = TBaseFont::HasOTFontFeatureTable((atomic_ullong *)a2);
  id v45 = (id)0xAAAAAAAAAAAAAAAALL;
  id v45 = (id)atomic_load_explicit((atomic_ullong *volatile)&v48, memory_order_acquire);
  CFAllocatorRef v36 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  __int16 v37 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
  id Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  id v43 = CFArrayCreateMutable(v36, 0, v37);
  if (TFontFeatures::HandleAlias(a1, (atomic_ullong *)&v45, HasOTFontFeatureTable, (atomic_ullong *)&Mutable, (atomic_ullong *)&v43))
  {
    id values = (id)0xAAAAAAAAAAAAAAAALL;
    TCFMutableArray::TCFMutableArray((TCFMutableArray *)&values, (CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v43, memory_order_acquire));
    CFArrayRemoveValueAtIndex((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&values, memory_order_acquire), 0);
    *a5 = (CFArrayRef)atomic_exchange((atomic_ullong *volatile)&values, 0);
    id v38 = values;
  }
  else
  {
    BOOL v42 = -86;
    __int16 v39 = TFontFeatures::GetFeatureSelector(a1, (atomic_ullong *)&v45, &v42);
    if (v39 && atomic_load_explicit((atomic_ullong *volatile)&v48, memory_order_acquire))
    {
      id values = (id)atomic_load_explicit((atomic_ullong *volatile)&v48, memory_order_acquire);
      *a5 = CFArrayCreate(v36, (const void **)&values, 1, MEMORY[0x1E4F1D510]);
    }
    else
    {
      *a5 = 0;
    }
    id v38 = v39;
  }

LABEL_48:
}

NSNumber *ValidatedValue(NSNumber *a1)
{
  if (!a1) {
    return (NSNumber *)*MEMORY[0x1E4F1CFD0];
  }
  uint64_t v1 = a1;
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 != CFNumberGetTypeID() && v2 != CFBooleanGetTypeID())
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0) {
      return 0;
    }
  }
  return v1;
}

void TFont::UpdateFeatureSettings(uint64_t a1, __CFDictionary *a2, id a3, int a4)
{
  CFDictionaryRef v5 = (atomic_ullong *)(a1 + 168);
  if (a4) {
    CFIndex v6 = (const TBaseFont *)a3;
  }
  else {
    CFIndex v6 = TFontFeatures::CopyNonDefaultSettings(*(TFontFeatures **)(a1 + 400), (const TBaseFont *)a3, (const __CFArray *)a3);
  }
  id v7 = v6;
  TFontFeatureSettingList::Emplace((uint64_t)v5, (atomic_ullong *)&v7);

  if (atomic_load_explicit(v5, memory_order_acquire)) {
    CFDictionarySetValue(a2, @"NSCTFontFeatureSettingsAttribute", (const void *)atomic_load_explicit(v5, memory_order_acquire));
  }
}

const TBaseFont *TFontFeatures::CopyNonDefaultSettings(TFontFeatures *this, const TBaseFont *a2, const __CFArray *a3)
{
  id v3 = a2;
  if (a2)
  {
    id v7 = (id)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(id *__return_ptr))(*(void *)this + 136))(&v6);
    id v7 = (id)atomic_exchange((atomic_ullong *volatile)&v6, 0);

    id v3 = (const TBaseFont *)TFontFeatures::CopyNonDefault((atomic_ullong *)&v7, this, v3);
  }
  return v3;
}

void TBaseFont::CopyFeatures(TBaseFont *this@<X0>, int a2@<W1>, const __CFArray **a3@<X8>)
{
}

void *TCFNumber::TCFNumber<short>(void *a1, __int16 a2)
{
  __int16 valuePtr = a2;
  id v4 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberShortType, &valuePtr);
  *a1 = atomic_exchange((atomic_ullong *volatile)&v4, 0);

  return a1;
}

void **TCompactArray<unsigned short,8ul,3ul,30ul>::assign<unsigned int *>(uint64_t a1, int *a2, int *a3)
{
  *(unsigned char *)a1 = 0;
  id v6 = a2 + 8;
  id v7 = (char **)(a1 + 32);
  uint64_t result = std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__insert_with_size[abi:nn180100]<unsigned int *,unsigned int *>((void **)(a1 + 32), *(char **)(a1 + 40), a2, a2 + 8, 8);
  if (v6 != a3)
  {
    CFArrayRef v9 = a2 + 9;
    unsigned int v10 = 1;
    do
    {
      unint64_t v11 = v6;
      v6 += 8;
      uint64_t v13 = *(void *)(a1 + 32);
      CFIndex v12 = *(char **)(a1 + 40);
      unsigned int v14 = v12 - v13;
      if ((uint64_t)&v12[-v13] < 15)
      {
        char v16 = *(unsigned __int16 **)(a1 + 32);
LABEL_17:
        CFNumberRef v22 = v11 + 7;
        if (v16 != (unsigned __int16 *)v12)
        {
          uint64_t v23 = 24;
          do
          {
            unint64_t v24 = v16;
            if (v22 != v11)
            {
              uint64_t v25 = v22 - v11;
              uint64_t v26 = (v12 - (char *)v16) >> 1;
              unint64_t v24 = *(unsigned __int16 **)(a1 + 40);
              if (v26 >= v25)
              {
                uint64_t v27 = (uint64_t)&v16[v26 + 1 - v25];
                unint64_t v24 = *(unsigned __int16 **)(a1 + 40);
                if ((unsigned __int16 *)v27 != v16)
                {
                  unint64_t v24 = v16;
                  while (*v11 != *v24)
                  {
LABEL_27:
                    if (++v24 == (unsigned __int16 *)v27)
                    {
                      unint64_t v24 = *(unsigned __int16 **)(a1 + 40);
                      goto LABEL_29;
                    }
                  }
                  unint64_t v28 = 0;
                  uint64_t v29 = 1;
                  while (v23 != v28)
                  {
                    int v30 = v24[v29];
                    int v31 = v9[v28 / 4];
                    ++v29;
                    v28 += 4;
                    if (v31 != v30) {
                      goto LABEL_27;
                    }
                  }
                }
              }
            }
LABEL_29:
            if (v16 == v24) {
              break;
            }
            --v22;
            ++v16;
            v23 -= 4;
          }
          while (v16 != (unsigned __int16 *)v12);
        }
        unint64_t v32 = (unint64_t)((char *)v6 - (char *)v22) >> 2;
        *(unsigned char *)(a1 + v10) = v32 + (v14 >> 1) - 8;
        uint64_t v33 = *(void *)(a1 + 32);
        unint64_t v34 = ((*(void *)(a1 + 40) - v33) >> 1) + v32;
        unint64_t v35 = (*(void *)(a1 + 48) - v33) >> 1;
        if (v35 <= 0x1E) {
          unint64_t v35 = 30;
        }
        if (v34 > v35)
        {
          uint64_t v36 = 0;
          while (1)
          {
            unint64_t v37 = TCompactArray<unsigned short,8ul,3ul,30ul>::assign<unsigned int *>(unsigned int *,unsigned int *)::kBuckets[v36];
            if (v34 <= v37) {
              break;
            }
            if (++v36 == 3)
            {
              unint64_t v37 = 256;
              break;
            }
          }
          std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::reserve(v7, v37);
          CFIndex v12 = *(char **)(a1 + 40);
        }
        uint64_t result = std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__insert_with_size[abi:nn180100]<unsigned int *,unsigned int *>((void **)v7, v12, v22, v6, v6 - v22);
      }
      else
      {
        uint64_t v15 = &v12[-v13];
        char v16 = *(unsigned __int16 **)(a1 + 32);
        while (1)
        {
          uint64_t v17 = (uint64_t)&v15[(void)v16 - 14];
          unint64_t v18 = *(unsigned __int16 **)(a1 + 40);
          if ((unsigned __int16 *)v17 != v16)
          {
            unint64_t v18 = v16;
            while (*v11 != *v18)
            {
LABEL_11:
              if (++v18 == (unsigned __int16 *)v17)
              {
                unint64_t v18 = *(unsigned __int16 **)(a1 + 40);
                goto LABEL_13;
              }
            }
            uint64_t v19 = 0;
            while (v19 != 7)
            {
              int v20 = v18[v19 + 1];
              int v21 = v9[v19++];
              if (v21 != v20) {
                goto LABEL_11;
              }
            }
          }
LABEL_13:
          if (v18 == v16) {
            break;
          }
          uint64_t v15 = (char *)(v12 - (char *)++v16);
          if (v12 - (char *)v16 <= 14) {
            goto LABEL_17;
          }
        }
        *(unsigned char *)(a1 + v10) = (v16 - v13) >> 1;
      }
      ++v10;
      v9 += 8;
    }
    while (v6 != a3);
  }
  return result;
}

void **std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__insert_with_size[abi:nn180100]<unsigned int *,unsigned int *>(void **result, char *__src, int *a3, int *a4, uint64_t a5)
{
  if (a5 < 1) {
    return result;
  }
  id v6 = a3;
  id v7 = __src;
  unsigned int v8 = result;
  unint64_t v9 = (unint64_t)result[1];
  unsigned int v10 = result[2];
  if (a5 > (uint64_t)&v10[-v9] >> 1)
  {
    unint64_t v11 = *result;
    uint64_t v12 = a5 + ((uint64_t)(v9 - (void)*result) >> 1);
    if (v12 < 0) {
      abort();
    }
    uint64_t v13 = (__src - v11) >> 1;
    uint64_t v14 = (uint64_t)(result + 3);
    unint64_t v15 = v10 - v11;
    if (v15 > v12) {
      uint64_t v12 = v15;
    }
    if (v15 >= 0x7FFFFFFFFFFFFFFELL) {
      uint64_t v16 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v16 = v12;
    }
    v33[4] = v8 + 3;
    if (v16) {
      uint64_t v17 = (char *)TInlineBufferAllocator<unsigned short,30ul>::allocate(v14, v16);
    }
    else {
      uint64_t v17 = 0;
    }
    uint64_t v29 = &v17[2 * v13];
    v33[0] = v17;
    v33[1] = v29;
    v33[3] = &v17[2 * v16];
    uint64_t v30 = 2 * a5;
    int v31 = &v29[2 * a5];
    do
    {
      int v32 = *v6++;
      *(_WORD *)uint64_t v29 = v32;
      v29 += 2;
      v30 -= 2;
    }
    while (v30);
    v33[2] = v31;
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__swap_out_circular_buffer(v8, (uint64_t)v33, v7);
    return (void **)std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,30ul> &>::~__split_buffer((uint64_t)v33);
  }
  uint64_t v18 = (uint64_t)(v9 - (void)__src) >> 1;
  if (v18 >= a5)
  {
    uint64_t v19 = &a3[a5];
    int v20 = (char *)result[1];
LABEL_18:
    unint64_t v24 = &__src[2 * a5];
    uint64_t v25 = &v20[-2 * a5];
    uint64_t v26 = v20;
    if ((unint64_t)v25 < v9)
    {
      uint64_t v26 = v20;
      do
      {
        __int16 v27 = *(_WORD *)v25;
        v25 += 2;
        *(_WORD *)uint64_t v26 = v27;
        v26 += 2;
      }
      while ((unint64_t)v25 < v9);
    }
    result[1] = v26;
    if (v20 != v24) {
      uint64_t result = (void **)memmove(&v20[-2 * ((v20 - v24) >> 1)], __src, v20 - v24);
    }
    for (; v6 != v19; v7 += 2)
    {
      int v28 = *v6++;
      *(_WORD *)id v7 = v28;
    }
    return result;
  }
  uint64_t v19 = &a3[v18];
  int v20 = (char *)result[1];
  if (v19 != a4)
  {
    int v21 = v19;
    CFNumberRef v22 = result[1];
    do
    {
      int v23 = *v21++;
      *v22++ = v23;
      v20 += 2;
    }
    while (v21 != a4);
  }
  result[1] = v20;
  if ((uint64_t)(v9 - (void)__src) >= 1) {
    goto LABEL_18;
  }
  return result;
}

uint64_t std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,30ul> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3) {
    *(void *)(a1 + 16) = v2 + ((v3 - v2 + 1) & 0xFFFFFFFFFFFFFFFELL);
  }
  id v4 = *(void **)a1;
  if (*(void *)a1)
  {
    unint64_t v5 = *(void *)(a1 + 32);
    if (v5 <= (unint64_t)v4 && v5 + 60 > (unint64_t)v4)
    {
      if (*(void *)(a1 + 24) == *(void *)(v5 + 64)) {
        *(void *)(v5 + 64) = v4;
      }
    }
    else
    {
      operator delete(v4);
    }
  }
  return a1;
}

void *TInlineBufferAllocator<unsigned short,30ul>::allocate(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void **)(a1 + 64);
  unint64_t v4 = (unint64_t)result + 2 * a2;
  if (v4 <= a1 + 60)
  {
    *(void *)(a1 + 64) = v4;
  }
  else
  {
    if (a2 < 0) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    return operator new(2 * a2);
  }
  return result;
}

char *std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__swap_out_circular_buffer(void **a1, uint64_t a2, char *__src)
{
  unint64_t v5 = *(char **)(a2 + 8);
  id v6 = (char *)*a1;
  id v7 = v5;
  if (*a1 != __src)
  {
    unsigned int v8 = __src;
    id v7 = *(char **)(a2 + 8);
    do
    {
      __int16 v9 = *((_WORD *)v8 - 1);
      v8 -= 2;
      *((_WORD *)v7 - 1) = v9;
      v7 -= 2;
    }
    while (v8 != v6);
  }
  *(void *)(a2 + 8) = v7;
  unsigned int v10 = a1[1];
  uint64_t v11 = *(void *)(a2 + 16);
  int64_t v12 = v10 - __src;
  if (v10 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v10 - __src);
    id v7 = *(char **)(a2 + 8);
  }
  *(void *)(a2 + 16) = v11 + v12;
  uint64_t v13 = (char *)*a1;
  *a1 = v7;
  *(void *)(a2 + 8) = v13;
  uint64_t v14 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(void *)(a2 + 16) = v14;
  unint64_t v15 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(void *)(a2 + 24) = v15;
  *(void *)a2 = *(void *)(a2 + 8);
  return v5;
}

char **std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::reserve(char **result, unint64_t a2)
{
  if (a2 > (result[2] - *result) >> 1)
  {
    if ((a2 & 0x8000000000000000) != 0) {
      abort();
    }
    uint64_t v3 = result;
    uint64_t v4 = result[1] - *result;
    v12[4] = result + 3;
    unint64_t v5 = (char *)TInlineBufferAllocator<unsigned short,30ul>::allocate((uint64_t)(result + 3), a2);
    id v7 = *v3;
    id v6 = v3[1];
    unsigned int v8 = &v5[v4 & 0xFFFFFFFFFFFFFFFELL];
    if (v6 != *v3)
    {
      __int16 v9 = v3[1];
      unsigned int v8 = &v5[v4 & 0xFFFFFFFFFFFFFFFELL];
      do
      {
        __int16 v10 = *((_WORD *)v9 - 1);
        v9 -= 2;
        *((_WORD *)v8 - 1) = v10;
        v8 -= 2;
      }
      while (v9 != v7);
    }
    *uint64_t v3 = v8;
    v3[1] = &v5[v4 & 0xFFFFFFFFFFFFFFFELL];
    uint64_t v11 = v3[2];
    v3[2] = &v5[2 * a2];
    v12[2] = v6;
    v12[3] = v11;
    v12[0] = v7;
    v12[1] = v7;
    return (char **)std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,30ul> &>::~__split_buffer((uint64_t)v12);
  }
  return result;
}

uint64_t IsOTFeatureFontSpecific(unsigned int a1)
{
  unint64_t v3 = 0xAAAAAAAAAAAAAAAALL;
  int v1 = ConvertOTFeatureToAATFeature(a1, (uint64_t)&v3);
  uint64_t result = 1;
  if (v1 && (unsigned __int16)v3 != 35)
  {
    if ((v3 & 0x800000000000) != 0) {
      return 1;
    }
    else {
      return (HIDWORD(v3) >> 6) & 1;
    }
  }
  return result;
}

uint64_t ConvertOTFeatureToAATFeature(unsigned int a1, uint64_t a2)
{
  unsigned int v11 = a1;
  if (v4 != v5)
  {
    int v6 = *((_DWORD *)v4 + 2);
    if ((~v6 & 0xE) == 0)
    {
      if (a1 != 1667460464) {
        return 2 * (v6 == 14);
      }
      uint64_t v7 = 27;
      goto LABEL_20;
    }
    if (v4 != (uint64_t *)&unk_184BA84A4)
    {
      while (*(_DWORD *)v4 <= a1)
      {
        if (*(_DWORD *)v4 == a1 && (v4[1] & 0x44) != 4) {
          goto LABEL_14;
        }
        uint64_t v4 = (uint64_t *)((char *)v4 + 12);
        if (v4 == (uint64_t *)&unk_184BA84A4) {
          break;
        }
      }
    }
    uint64_t v4 = (uint64_t *)&unk_184BA84A4;
LABEL_14:
    if ((v4[1] & 8) == 0)
    {
      uint64_t v9 = *(uint64_t *)((char *)v4 + 4);
      *(void *)a2 = v9;
      if ((v4[1] & 0x40) != 0) {
        *(_WORD *)(a2 + 2) = WORD1(v9) + 1;
      }
      return 1;
    }
    if ((v4[1] & 0x180) == 0x80)
    {
      uint64_t v7 = 1;
LABEL_20:
      *(void *)a2 = v7 & 0xFFFF0000FFFFFFFFLL | 0x200000000;
      return 1;
    }
  }
  return 0;
}

uint64_t *std::equal_range[abi:nn180100]<anonymous namespace'::FeatureMapEntry const*,unsigned int>(unsigned int *a1)
{
  uint64_t result = &kMasterFeatureMap;
  unint64_t v3 = (unsigned int *)&unk_184BA84A4;
  unsigned int v4 = *a1;
  unint64_t v5 = 165;
  while (1)
  {
    unint64_t v6 = v5 >> 1;
    uint64_t v7 = (unsigned int *)result + 3 * (v5 >> 1);
    if (*v7 >= v4) {
      break;
    }
    uint64_t result = (uint64_t *)(v7 + 3);
    unint64_t v6 = v5 + ~v6;
LABEL_6:
    unint64_t v5 = v6;
    if (!v6) {
      return result;
    }
  }
  if (*v7 > v4)
  {
    unint64_t v3 = (unsigned int *)result + 3 * (v5 >> 1);
    goto LABEL_6;
  }
  unsigned int v8 = (uint64_t *)((char *)result + 12 * (v5 >> 1));
  if (v5 >= 2)
  {
    unsigned int v8 = result;
    do
    {
      unint64_t v9 = v6 >> 1;
      __int16 v10 = (_DWORD *)v8 + 3 * (v6 >> 1);
      unsigned int v12 = *v10;
      unsigned int v11 = (uint64_t *)(v10 + 3);
      v6 += ~(v6 >> 1);
      if (v12 >= v4) {
        unint64_t v6 = v9;
      }
      else {
        unsigned int v8 = v11;
      }
    }
    while (v6);
  }
  uint64_t v13 = v7 + 3;
  if (v3 == v7 + 3) {
    return v8;
  }
  unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * (v3 - (v7 + 3));
  do
  {
    unint64_t v15 = v14 >> 1;
    uint64_t v16 = &v13[3 * (v14 >> 1)];
    unsigned int v18 = *v16;
    uint64_t v17 = v16 + 3;
    v14 += ~(v14 >> 1);
    if (v18 > v4) {
      unint64_t v14 = v15;
    }
    else {
      uint64_t v13 = v17;
    }
  }
  while (v14);
  return v8;
}

void TBaseFont::CopyOTFontFeatureTable(TBaseFont *this@<X0>, unint64_t *a2@<X8>)
{
  id v13 = (id)0xAAAAAAAAAAAAAAAALL;
  TBaseFont::CopyAttributeInternal((atomic_ullong *)this, @"CTFontOTFeatures", &v13);
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&v13, memory_order_acquire);
  unint64_t v5 = (const void **)MEMORY[0x1E4F1D260];
  if (!explicit)
  {
    memset(v12, 170, sizeof(v12));
    TFontFeatureTable::TFontFeatureTable((TFontFeatureTable *)v12, this);
    id v11 = (id)0xAAAAAAAAAAAAAAAALL;
    if (LOBYTE(v12[0])) {
      id v6 = (id)atomic_load_explicit((atomic_ullong *volatile)&v12[1], memory_order_acquire);
    }
    else {
      id v6 = 0;
    }
    id v11 = v6;
    if (atomic_load_explicit((atomic_ullong *volatile)&v11, memory_order_acquire))
    {
      id v7 = (id)atomic_load_explicit((atomic_ullong *volatile)&v11, memory_order_acquire);
      os_unfair_lock_lock_with_options();
      unsigned int v8 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)this + 15, memory_order_acquire);
      if (v7)
      {
        if (!v8) {
          TBaseFont::InitAttributesDict((atomic_ullong *)this);
        }
        unint64_t v9 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)this + 15, memory_order_acquire);
        if (v9) {
          CFDictionarySetValue(v9, @"CTFontOTFeatures", v7);
        }
      }
      else if (v8)
      {
        CFDictionaryRemoveValue(v8, @"CTFontOTFeatures");
      }
      os_unfair_lock_unlock((os_unfair_lock_t)this + 28);
    }
    else
    {
      TBaseFont::SetAttributeInternal<__CFDictionary const*>((atomic_ullong *)this, *v5, @"CTFontOTFeatures");
    }
  }
  if (*v5 == (const void *)atomic_load_explicit((atomic_ullong *volatile)&v13, memory_order_acquire)) {
    unint64_t v10 = 0;
  }
  else {
    unint64_t v10 = atomic_exchange((atomic_ullong *volatile)&v13, 0);
  }
  *a2 = v10;
}

void TFontFeatureTable::TFontFeatureTable(TFontFeatureTable *this, const TBaseFont *a2)
{
  *(unsigned char *)this = 0;
  *((void *)this + 1) = 0;
  unint64_t v3 = (atomic_ullong *)((char *)this + 8);
  *((void *)this + 2) = 0;
  if (TFontFeatureTable::LoadTableData((atomic_ullong *)this, a2)
    && CFDataGetLength((CFDataRef)atomic_load_explicit(v3, memory_order_acquire)) >= 8)
  {
    BytePtr = (const UInt8 *)(id)atomic_load_explicit(v3, memory_order_acquire);
    unint64_t v5 = (UInt8 *)BytePtr;
    if (BytePtr) {
      BytePtr = CFDataGetBytePtr((CFDataRef)BytePtr);
    }
    *((void *)this + 2) = BytePtr;
  }
}

BOOL TFontFeatureTable::LoadTableData(atomic_ullong *this, const TBaseFont *a2)
{
  if ((*(unsigned int (**)(const TBaseFont *, uint64_t))(*(void *)a2 + 472))(a2, 1836020344))
  {
    (*(void (**)(id *__return_ptr, const TBaseFont *, uint64_t))(*(void *)a2 + 480))(&v6, a2, 1717920116);
    unsigned int v4 = (void *)atomic_exchange(this + 1, atomic_exchange((atomic_ullong *volatile)&v6, 0));
LABEL_6:

    return atomic_load_explicit(this + 1, memory_order_acquire) != 0;
  }
  if (((*(uint64_t (**)(const TBaseFont *, uint64_t))(*(void *)a2 + 472))(a2, 1196643650) & 1) != 0
    || (*(unsigned int (**)(const TBaseFont *, uint64_t))(*(void *)a2 + 472))(a2, 1196445523))
  {
    *(unsigned char *)this = 1;
    CreateOTFeatureTable(a2, &v6);
    unsigned int v4 = (void *)atomic_exchange(this + 1, atomic_exchange((atomic_ullong *volatile)&v6, 0));
    goto LABEL_6;
  }
  return atomic_load_explicit(this + 1, memory_order_acquire) != 0;
}

void TSplicedFont::CopyFeatures(TSplicedFont *this@<X0>, int a2@<W1>, const __CFArray **a3@<X8>)
{
  uint64_t v6 = *(void *)(*((void *)this + 76) + 40);
  if ((*(_DWORD *)(v6 + 16) & 0x80000000) == 0) {
    TDescriptor::InitBaseFont(*(TDescriptor **)(*((void *)this + 76) + 40), 0, 0.0);
  }
  unint64_t explicit = (atomic_ullong *)atomic_load_explicit((atomic_ullong *volatile)(v6 + 32), memory_order_acquire);

  TBaseFont::CopyFeaturesInternal(this, explicit, a2, a3);
}

uint64_t GetValue<__CFNumber const*>(uint64_t result, void *a2)
{
  if (result)
  {
    CFNumberRef v3 = (const __CFNumber *)result;
    CFTypeID v4 = CFGetTypeID((CFTypeRef)result);
    if (v4 == CFNumberGetTypeID() || v4 == CFBooleanGetTypeID())
    {
      if (a2) {
        CFNumberGetValue(v3, kCFNumberIntType, a2);
      }
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

double TFont::GetFeatureTableSubstitutions(OTL::GCommon::Table)const::$_0::__invoke()
{
  double result = 0.0;
  xmmword_1EB2CE080 = 0u;
  *(_OWORD *)algn_1EB2CE090 = 0u;
  dword_1EB2CE0A0 = 1065353216;
  return result;
}

void CopyOTFeatureSettingForTypeAndSelector(unsigned short,unsigned short)::$_0::__invoke()
{
  uint64_t v0 = 0;
  unint64_t v1 = 0;
  xmmword_1EB2CE5A0 = 0u;
  *(_OWORD *)&qword_1EB2CE5B0 = 0u;
  uint64_t v2 = &kMasterFeatureMap;
  dword_1EB2CE5C0 = 1065353216;
  do
  {
    if (*(_DWORD *)v2 && (v2[1] & 0x40) == 0)
    {
      unint64_t v3 = *((unsigned __int16 *)v2 + 3) | (*((unsigned __int16 *)v2 + 2) << 16);
      if (v1)
      {
        uint8x8_t v4 = (uint8x8_t)vcnt_s8((int8x8_t)v1);
        v4.i16[0] = vaddlv_u8(v4);
        if (v4.u32[0] > 1uLL)
        {
          unint64_t v5 = *((unsigned __int16 *)v2 + 3) | (*((unsigned __int16 *)v2 + 2) << 16);
          if (v1 <= v3) {
            unint64_t v5 = v3 % v1;
          }
        }
        else
        {
          unint64_t v5 = (v1 - 1) & v3;
        }
        uint64_t v6 = *(uint64_t ***)(xmmword_1EB2CE5A0 + 8 * v5);
        if (v6)
        {
          for (uint64_t i = *v6; i; uint64_t i = (uint64_t *)*i)
          {
            unint64_t v8 = i[1];
            if (v8 == v3)
            {
              if (*((_DWORD *)i + 4) == v3) {
                goto LABEL_43;
              }
            }
            else
            {
              if (v4.u32[0] > 1uLL)
              {
                if (v8 >= v1) {
                  v8 %= v1;
                }
              }
              else
              {
                v8 &= v1 - 1;
              }
              if (v8 != v5) {
                break;
              }
            }
          }
        }
      }
      else
      {
        unint64_t v5 = 0xAAAAAAAAAAAAAAAALL;
      }
      unint64_t v9 = operator new(0x20uLL);
      *unint64_t v9 = 0;
      v9[1] = v3;
      *((_DWORD *)v9 + 4) = v3;
      v9[3] = v2;
      float v10 = (float)(unint64_t)(v0 + 1);
      if (!v1 || (float)(*(float *)&dword_1EB2CE5C0 * (float)v1) < v10)
      {
        BOOL v11 = (v1 & (v1 - 1)) != 0;
        if (v1 < 3) {
          BOOL v11 = 1;
        }
        unint64_t v12 = v11 | (2 * v1);
        unint64_t v13 = vcvtps_u32_f32(v10 / *(float *)&dword_1EB2CE5C0);
        if (v12 <= v13) {
          size_t v14 = v13;
        }
        else {
          size_t v14 = v12;
        }
        std::__hash_table<std::__hash_value_type<TRun const*,long>,std::__unordered_map_hasher<TRun const*,std::__hash_value_type<TRun const*,long>,std::hash<TRun const*>,std::equal_to<TRun const*>,true>,std::__unordered_map_equal<TRun const*,std::__hash_value_type<TRun const*,long>,std::equal_to<TRun const*>,std::hash<TRun const*>,true>,std::allocator<std::__hash_value_type<TRun const*,long>>>::__rehash<true>((uint64_t)&xmmword_1EB2CE5A0, v14);
        unint64_t v1 = *((void *)&xmmword_1EB2CE5A0 + 1);
        if ((v1 & (v1 - 1)) != 0)
        {
          if (*((void *)&xmmword_1EB2CE5A0 + 1) <= v3) {
            unint64_t v5 = v3 % *((void *)&xmmword_1EB2CE5A0 + 1);
          }
          else {
            unint64_t v5 = v3;
          }
        }
        else
        {
          unint64_t v5 = (DWORD2(xmmword_1EB2CE5A0) - 1) & v3;
        }
      }
      uint64_t v15 = xmmword_1EB2CE5A0;
      uint64_t v16 = *(void **)(xmmword_1EB2CE5A0 + 8 * v5);
      if (v16)
      {
        *unint64_t v9 = *v16;
      }
      else
      {
        *unint64_t v9 = qword_1EB2CE5B0;
        qword_1EB2CE5B0 = (uint64_t)v9;
        *(void *)(v15 + 8 * v5) = &qword_1EB2CE5B0;
        if (!*v9)
        {
LABEL_42:
          uint64_t v0 = ++qword_1EB2CE5B8;
          goto LABEL_43;
        }
        unint64_t v17 = *(void *)(*v9 + 8);
        if ((v1 & (v1 - 1)) != 0)
        {
          if (v17 >= v1) {
            v17 %= v1;
          }
        }
        else
        {
          v17 &= v1 - 1;
        }
        uint64_t v16 = (void *)(xmmword_1EB2CE5A0 + 8 * v17);
      }
      *uint64_t v16 = v9;
      goto LABEL_42;
    }
LABEL_43:
    uint64_t v2 = (uint64_t *)((char *)v2 + 12);
  }
  while (v2 != (uint64_t *)&unk_184BA84A4);
}

void FindMasterFeatureMapEntry(unsigned int)::$_0::__invoke()
{
  uint64_t v0 = 0;
  unint64_t v1 = 0;
  xmmword_1EB2CE5C8 = 0u;
  *(_OWORD *)&qword_1EB2CE5D8 = 0u;
  uint64_t v2 = &kMasterFeatureMap;
  dword_1EB2CE5E8 = 1065353216;
  do
  {
    if ((v2[1] & 0x44) == 4) {
      goto LABEL_42;
    }
    unint64_t v3 = *(unsigned int *)v2;
    if (v1)
    {
      uint8x8_t v4 = (uint8x8_t)vcnt_s8((int8x8_t)v1);
      v4.i16[0] = vaddlv_u8(v4);
      if (v4.u32[0] > 1uLL)
      {
        unint64_t v5 = *(unsigned int *)v2;
        if (v1 <= v3) {
          unint64_t v5 = v3 % v1;
        }
      }
      else
      {
        unint64_t v5 = (v1 - 1) & v3;
      }
      uint64_t v6 = *(uint64_t ***)(xmmword_1EB2CE5C8 + 8 * v5);
      if (v6)
      {
        for (uint64_t i = *v6; i; uint64_t i = (uint64_t *)*i)
        {
          unint64_t v8 = i[1];
          if (v8 == v3)
          {
            if (*((_DWORD *)i + 4) == v3) {
              goto LABEL_42;
            }
          }
          else
          {
            if (v4.u32[0] > 1uLL)
            {
              if (v8 >= v1) {
                v8 %= v1;
              }
            }
            else
            {
              v8 &= v1 - 1;
            }
            if (v8 != v5) {
              break;
            }
          }
        }
      }
    }
    else
    {
      unint64_t v5 = 0xAAAAAAAAAAAAAAAALL;
    }
    unint64_t v9 = operator new(0x20uLL);
    *unint64_t v9 = 0;
    v9[1] = v3;
    *((_DWORD *)v9 + 4) = v3;
    v9[3] = v2;
    float v10 = (float)(unint64_t)(v0 + 1);
    if (!v1 || (float)(*(float *)&dword_1EB2CE5E8 * (float)v1) < v10)
    {
      BOOL v11 = (v1 & (v1 - 1)) != 0;
      if (v1 < 3) {
        BOOL v11 = 1;
      }
      unint64_t v12 = v11 | (2 * v1);
      unint64_t v13 = vcvtps_u32_f32(v10 / *(float *)&dword_1EB2CE5E8);
      if (v12 <= v13) {
        size_t v14 = v13;
      }
      else {
        size_t v14 = v12;
      }
      std::__hash_table<std::__hash_value_type<TRun const*,long>,std::__unordered_map_hasher<TRun const*,std::__hash_value_type<TRun const*,long>,std::hash<TRun const*>,std::equal_to<TRun const*>,true>,std::__unordered_map_equal<TRun const*,std::__hash_value_type<TRun const*,long>,std::equal_to<TRun const*>,std::hash<TRun const*>,true>,std::allocator<std::__hash_value_type<TRun const*,long>>>::__rehash<true>((uint64_t)&xmmword_1EB2CE5C8, v14);
      unint64_t v1 = *((void *)&xmmword_1EB2CE5C8 + 1);
      if ((v1 & (v1 - 1)) != 0)
      {
        if (*((void *)&xmmword_1EB2CE5C8 + 1) <= v3) {
          unint64_t v5 = v3 % *((void *)&xmmword_1EB2CE5C8 + 1);
        }
        else {
          unint64_t v5 = v3;
        }
      }
      else
      {
        unint64_t v5 = (DWORD2(xmmword_1EB2CE5C8) - 1) & v3;
      }
    }
    uint64_t v15 = xmmword_1EB2CE5C8;
    uint64_t v16 = *(void **)(xmmword_1EB2CE5C8 + 8 * v5);
    if (v16)
    {
      *unint64_t v9 = *v16;
LABEL_40:
      *uint64_t v16 = v9;
      goto LABEL_41;
    }
    *unint64_t v9 = qword_1EB2CE5D8;
    qword_1EB2CE5D8 = (uint64_t)v9;
    *(void *)(v15 + 8 * v5) = &qword_1EB2CE5D8;
    if (*v9)
    {
      unint64_t v17 = *(void *)(*v9 + 8);
      if ((v1 & (v1 - 1)) != 0)
      {
        if (v17 >= v1) {
          v17 %= v1;
        }
      }
      else
      {
        v17 &= v1 - 1;
      }
      uint64_t v16 = (void *)(xmmword_1EB2CE5C8 + 8 * v17);
      goto LABEL_40;
    }
LABEL_41:
    uint64_t v0 = ++qword_1EB2CE5E0;
LABEL_42:
    uint64_t v2 = (uint64_t *)((char *)v2 + 12);
  }
  while (v2 != (uint64_t *)&unk_184BA84A4);
}

void std::__hash_table<std::__hash_value_type<TRun const*,long>,std::__unordered_map_hasher<TRun const*,std::__hash_value_type<TRun const*,long>,std::hash<TRun const*>,std::equal_to<TRun const*>,true>,std::__unordered_map_equal<TRun const*,std::__hash_value_type<TRun const*,long>,std::equal_to<TRun const*>,std::hash<TRun const*>,true>,std::allocator<std::__hash_value_type<TRun const*,long>>>::__rehash<true>(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2;
  }
  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }
  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime <= *(void *)&v4)
  {
    if (prime >= *(void *)&v4) {
      return;
    }
    unint64_t v11 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v12 = (uint8x8_t)vcnt_s8(v4), v12.i16[0] = vaddlv_u8(v12), v12.u32[0] > 1uLL))
    {
      unint64_t v11 = std::__next_prime(v11);
    }
    else
    {
      uint64_t v13 = 1 << -(char)__clz(v11 - 1);
      if (v11 >= 2) {
        unint64_t v11 = v13;
      }
    }
    if (prime <= v11) {
      size_t prime = v11;
    }
    if (prime >= *(void *)&v4) {
      return;
    }
    if (!prime)
    {
      uint64_t v16 = *(void **)a1;
      *(void *)a1 = 0;
      if (v16) {
        operator delete(v16);
      }
      *(void *)(a1 + 8) = 0;
      return;
    }
  }
  if (prime >> 61) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  unint64_t v5 = operator new(8 * prime);
  uint64_t v6 = *(void **)a1;
  *(void *)a1 = v5;
  if (v6) {
    operator delete(v6);
  }
  uint64_t v7 = 0;
  *(void *)(a1 + 8) = prime;
  do
    *(void *)(*(void *)a1 + 8 * v7++) = 0;
  while (prime != v7);
  unint64_t v8 = *(void **)(a1 + 16);
  if (v8)
  {
    size_t v9 = v8[1];
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)prime);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      if (v9 >= prime) {
        v9 %= prime;
      }
    }
    else
    {
      v9 &= prime - 1;
    }
    *(void *)(*(void *)a1 + 8 * v9) = a1 + 16;
    size_t v14 = (void *)*v8;
    if (*v8)
    {
      do
      {
        size_t v15 = v14[1];
        if (v10.u32[0] > 1uLL)
        {
          if (v15 >= prime) {
            v15 %= prime;
          }
        }
        else
        {
          v15 &= prime - 1;
        }
        if (v15 != v9)
        {
          if (!*(void *)(*(void *)a1 + 8 * v15))
          {
            *(void *)(*(void *)a1 + 8 * v15) = v8;
            goto LABEL_31;
          }
          *unint64_t v8 = *v14;
          *size_t v14 = **(void **)(*(void *)a1 + 8 * v15);
          **(void **)(*(void *)a1 + 8 * v15) = v14;
          size_t v14 = v8;
        }
        size_t v15 = v9;
LABEL_31:
        unint64_t v8 = v14;
        size_t v14 = (void *)*v14;
        size_t v9 = v15;
      }
      while (v14);
    }
  }
}

CGFloat CTFontGetXHeight(CTFontRef font)
{
  if (!font) {
    return 0.0;
  }
  unint64_t v1 = (TFont *)*((void *)font + 5);
  uint64_t v2 = *((void *)v1 + 50);
  TFont::GetScaledMatrix(v1, &v4);
  (*(void (**)(uint64_t, CGAffineTransform *))(*(void *)v2 + 608))(v2, &v4);
  return result;
}

CGFloat TBaseFont::GetXHeight(TBaseFont *this, const CGAffineTransform *a2)
{
  InitializedGraphicsFont = (CGFont *)TBaseFont::GetInitializedGraphicsFont(this);
  return a2->ty + a2->d * (double)CGFontGetXHeight(InitializedGraphicsFont) + a2->b * 0.0;
}

void TFramesetterAttrString::~TFramesetterAttrString(id *this)
{
  *this = &unk_1ED05F088;

  uint64_t v2 = (std::__shared_weak_count *)this[32];
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  TLine::~TLine((TLine *)(this + 1));
}

{
  uint64_t vars8;

  TFramesetterAttrString::~TFramesetterAttrString(this);

  JUMPOUT(0x1853275C0);
}

double TFont::GetOpticalBoundsForGlyphs(TFont *this, const unsigned __int16 *a2, CGRect *a3, uint64_t a4)
{
  uint64_t v80 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *((void *)this + 50);
  if (v8 && (*(unsigned int (**)(uint64_t))(*(void *)v8 + 400))(v8))
  {
    *(void *)&long long v9 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v66[3] = v9;
    v66[4] = v9;
    v66[2] = v9;
    v66[0] = v9;
    v66[1] = v9;
    CFDataRef CommonTable = (const __CFData *)TBaseFont::GetCommonTable(*((TBaseFont **)this + 50), 1195656518, 0);
    OTL::GDEF::GDEF((OTL::GDEF *)v66, CommonTable);
    unint64_t v65 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v11 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v64[3] = v11;
    v64[4] = v11;
    v64[1] = v11;
    v64[2] = v11;
    v64[0] = v11;
    CFDataRef v12 = (const __CFData *)TBaseFont::GetCommonTable(*((TBaseFont **)this + 50), 1196445523, 0);
    OTL::GCommon::GCommon((uint64_t)v64, 1, this, v12, (uint64_t)v66, 1145457748, 0);
    *(void *)&v64[0] = &unk_1ED05FAF8;
    uint64_t v13 = (int *)((char *)this + 48);
    inited = (int *)((char *)this + 48);
    if (!*((_DWORD *)this + 12)) {
      inited = TFont::InitStrikeMetrics(this);
    }
    unint64_t v62 = a3;
    double v15 = *((double *)inited + 1);
    uint64_t v16 = (int *)((char *)this + 48);
    if (!*v13) {
      uint64_t v16 = TFont::InitStrikeMetrics(this);
    }
    uint64_t v17 = MEMORY[0x1E4F1DB28];
    if (a4)
    {
      double v18 = *((double *)v16 + 2);
      double v19 = -v18;
      double v20 = v15 + v18;
      uint64_t v21 = 2 * a4;
      CFNumberRef v22 = a2;
      int v23 = a3;
      do
      {
        __int16 v24 = *v22++;
        LOWORD(v70) = v24;
        long long v25 = *(_OWORD *)(v17 + 16);
        long long v68 = *(_OWORD *)v17;
        v69[0] = v25;
        TFont::GetAdvancesForGlyphs((uint64_t)this, (uint64_t)&v70, (double *)v69, 2, 1, 0, 0, 0);
        CGFloat v26 = *(double *)v69;
        *(void *)&v23->origin.double x = v68;
        v23->origin.CGFloat y = v19;
        v23->size.CGFloat width = v26;
        v23->size.CGFloat height = v20;
        ++v23;
        v21 -= 2;
      }
      while (v21);
    }
    if (!*v13) {
      uint64_t v13 = TFont::InitStrikeMetrics(this);
    }
    double v27 = *((double *)v13 + 5);
    *(void *)&long long v28 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v28 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v78 = v28;
    long long v79 = v28;
    long long v76 = v28;
    long long v77 = v28;
    long long v74 = v28;
    long long v75 = v28;
    long long v72 = v28;
    long long v73 = v28;
    int v63 = 1818649188;
    long long v70 = v28;
    long long v71 = v28;
    OTL::FeatureBuffer::FeatureBuffer<unsigned int const*>((char **)&v68, &v63, v64);
    OTL::GCommon::GetLookups((uint64_t)v64, (uint64_t)&v68, (uint64_t)&v70);
    double v67 = COERCE_DOUBLE(&v68);
    std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v67);
    if (BYTE8(v79))
    {
      if (a4 < 1) {
        goto LABEL_19;
      }
      p_size = &a3->size;
      uint64_t v30 = a2;
      uint64_t v31 = a4;
      do
      {
        double v67 = NAN;
        *(void *)&long long v68 = -1;
        unsigned int v32 = *v30++;
        if (OTL::GPOS::GetSinglePosAdjustments((OTL::GPOS *)v64, (unsigned __int16 **)&v70, v32, (double *)&v68, &v67))
        {
          double v33 = v27 * *(double *)&v68;
          p_size[-1].CGFloat width = p_size[-1].width - v27 * *(double *)&v68;
          p_size->CGFloat width = v33 + p_size->width;
        }
        p_size += 2;
        --v31;
      }
      while (v31);
      a3 = v62;
      if (BYTE8(v79))
      {
LABEL_19:
        *(void *)&long long v68 = &v70;
        std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v68);
      }
    }
    *(void *)&long long v34 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v34 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v78 = v34;
    long long v79 = v34;
    long long v76 = v34;
    long long v77 = v34;
    long long v74 = v34;
    long long v75 = v34;
    long long v72 = v34;
    long long v73 = v34;
    long long v70 = v34;
    long long v71 = v34;
    int v63 = 1920229988;
    OTL::FeatureBuffer::FeatureBuffer<unsigned int const*>((char **)&v68, &v63, v64);
    OTL::GCommon::GetLookups((uint64_t)v64, (uint64_t)&v68, (uint64_t)&v70);
    double v67 = COERCE_DOUBLE(&v68);
    std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v67);
    if (BYTE8(v79))
    {
      if (a4 < 1) {
        goto LABEL_27;
      }
      unint64_t v35 = &a3->size;
      uint64_t v36 = a4;
      do
      {
        double v67 = NAN;
        *(void *)&long long v68 = -1;
        unsigned int v37 = *a2++;
        if (OTL::GPOS::GetSinglePosAdjustments((OTL::GPOS *)v64, (unsigned __int16 **)&v70, v37, (double *)&v68, &v67))v35->CGFloat width = v27 * v67 + v35->width; {
        v35 += 2;
        }
        --v36;
      }
      while (v36);
      if (BYTE8(v79))
      {
LABEL_27:
        *(void *)&long long v68 = &v70;
        std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v68);
      }
    }
    double x = *(double *)v17;
    CGFloat y = *(double *)(v17 + 8);
    CGFloat v40 = *(double *)(v17 + 16);
    CGFloat v41 = *(double *)(v17 + 24);
    if (a4 >= 1)
    {
      BOOL v42 = &a3->size;
      do
      {
        CGFloat width = v42[-1].width;
        CGFloat height = v42[-1].height;
        CGFloat v46 = v42->width;
        CGFloat v45 = v42->height;
        v81.origin.double x = x;
        v81.origin.CGFloat y = y;
        v81.size.CGFloat width = v40;
        v81.size.CGFloat height = v41;
        if (CGRectIsEmpty(v81))
        {
          double x = width;
          CGFloat y = height;
          CGFloat v40 = v46;
          CGFloat v41 = v45;
        }
        else
        {
          v82.origin.double x = width;
          v82.origin.CGFloat y = height;
          v82.size.CGFloat width = v46;
          v82.size.CGFloat height = v45;
          if (!CGRectIsEmpty(v82))
          {
            v83.origin.double x = x;
            v83.origin.CGFloat y = y;
            v83.size.CGFloat width = v40;
            v83.size.CGFloat height = v41;
            v89.origin.double x = width;
            v89.origin.CGFloat y = height;
            v89.size.CGFloat width = v46;
            v89.size.CGFloat height = v45;
            CGRect v84 = CGRectUnion(v83, v89);
            double x = v84.origin.x;
            CGFloat y = v84.origin.y;
            CGFloat v40 = v84.size.width;
            CGFloat v41 = v84.size.height;
          }
        }
        v42 += 2;
        --a4;
      }
      while (a4);
    }
  }
  else
  {
    long long v68 = xmmword_184B8A278;
    v69[0] = unk_184B8A288;
    memset(&v69[1], 170, 40);
    TAATOpbdTable::TAATOpbdTable((TAATOpbdTable *)&v68, this);
    double x = *MEMORY[0x1E4F1DB28];
    CGFloat v47 = *(double *)(MEMORY[0x1E4F1DB28] + 8);
    CGFloat v48 = *(double *)(MEMORY[0x1E4F1DB28] + 16);
    CGFloat v49 = *(double *)(MEMORY[0x1E4F1DB28] + 24);
    if (a4 >= 1)
    {
      id v50 = &a3->size;
      do
      {
        unint64_t v51 = *(double (**)(void *, void))&v69[2];
        size_t v52 = (void *)((char *)&v69[-1] + (*((uint64_t *)&v69[2] + 1) >> 1));
        if (BYTE8(v69[2])) {
          unint64_t v51 = *(double (**)(void *, void))(*v52 + LODWORD(v69[2]));
        }
        unsigned int v53 = *a2++;
        CGFloat v54 = v51(v52, v53);
        CGFloat v56 = v55;
        CGFloat v58 = v57;
        CGFloat v60 = v59;
        v50[-1].CGFloat width = v54;
        v50[-1].CGFloat height = v55;
        v50->CGFloat width = v57;
        v50->CGFloat height = v59;
        v85.origin.double x = x;
        v85.origin.CGFloat y = v47;
        v85.size.CGFloat width = v48;
        v85.size.CGFloat height = v49;
        if (CGRectIsEmpty(v85))
        {
          double x = v54;
          CGFloat v47 = v56;
          CGFloat v48 = v58;
          CGFloat v49 = v60;
        }
        else
        {
          v86.origin.double x = v54;
          v86.origin.CGFloat y = v56;
          v86.size.CGFloat width = v58;
          v86.size.CGFloat height = v60;
          if (!CGRectIsEmpty(v86))
          {
            v87.origin.double x = x;
            v87.origin.CGFloat y = v47;
            v87.size.CGFloat width = v48;
            v87.size.CGFloat height = v49;
            v90.origin.double x = v54;
            v90.origin.CGFloat y = v56;
            v90.size.CGFloat width = v58;
            v90.size.CGFloat height = v60;
            CGRect v88 = CGRectUnion(v87, v90);
            double x = v88.origin.x;
            CGFloat v47 = v88.origin.y;
            CGFloat v48 = v88.size.width;
            CGFloat v49 = v88.size.height;
          }
        }
        v50 += 2;
        --a4;
      }
      while (a4);
    }
    TAATOpbdTable::~TAATOpbdTable((TAATOpbdTable *)&v68);
  }
  return x;
}

BOOL TBaseFont::HasOpticalBoundsInGPOS(TBaseFont *this)
{
  if ((*((_DWORD *)this + 46) & 0x4000000) != 0) {
    return (*((_DWORD *)this + 45) >> 26) & 1;
  }
  memset(v8, 170, sizeof(v8));
  CustomOTFeatures(this, 0, v8);
  uint64_t v2 = (void *)v8[0];
  if (v8[0] == v8[1])
  {
    uint64_t v6 = (_DWORD *)v8[0];
  }
  else
  {
    unint64_t v3 = (_DWORD *)v8[0];
    while (*v3 != 1818649188)
    {
      if (++v3 == (_DWORD *)v8[1])
      {
        unint64_t v3 = (_DWORD *)v8[1];
        break;
      }
    }
    if (v3 != (_DWORD *)v8[1])
    {
      BOOL v4 = 1;
      unsigned int v5 = 0x4000000;
      goto LABEL_16;
    }
    uint64_t v6 = (_DWORD *)v8[0];
    while (*v6 != 1920229988)
    {
      if (++v6 == (_DWORD *)v8[1])
      {
        uint64_t v6 = (_DWORD *)v8[1];
        break;
      }
    }
  }
  BOOL v4 = v6 != (_DWORD *)v8[1];
  unsigned int v5 = v4 << 26;
LABEL_16:
  atomic_fetch_or_explicit((atomic_uint *volatile)this + 45, v5, memory_order_relaxed);
  atomic_fetch_or_explicit((atomic_uint *volatile)this + 46, 0x4000000u, memory_order_relaxed);
  if (v2)
  {
    v8[1] = v2;
    operator delete(v2);
  }
  return v4;
}

double TAATOpbdTable::GetDefaultBounds(TAATOpbdTable *this, __int16 a2)
{
  __int16 v6 = a2;
  long long v3 = *(_OWORD *)(MEMORY[0x1E4F1DB28] + 16);
  long long v7 = *MEMORY[0x1E4F1DB28];
  long long v8 = v3;
  TFont::GetAdvancesForGlyphs(*(void *)this, (uint64_t)&v6, (double *)&v8, 2, 1, 0, 0, 0);
  BOOL v4 = *(TFont **)this;
  if (!*(_DWORD *)(*(void *)this + 48))
  {
    TFont::InitStrikeMetrics(v4);
    BOOL v4 = *(TFont **)this;
  }
  if (!*((_DWORD *)v4 + 12)) {
    TFont::InitStrikeMetrics(v4);
  }
  return *(double *)&v7;
}

void TAATOpbdTable::~TAATOpbdTable(TAATOpbdTable *this)
{
  BOOL v4 = (void **)*((void *)this + 8);
  uint64_t v2 = (void *)((char *)this + 64);
  long long v3 = v4;
  *uint64_t v2 = 0;
  if (v4) {
    std::default_delete<TAATControlPointAccess>::operator()[abi:nn180100]((uint64_t)v2, v3);
  }
}

void TAATOpbdTable::TAATOpbdTable(TAATOpbdTable *this, const TFont *a2)
{
  *(void *)this = a2;
  TFont::GetScaledMatrix(a2, &v25);
  *(float64x2_t *)((char *)this + 8) = vaddq_f64(vaddq_f64(*(float64x2_t *)&v25.a, *(float64x2_t *)&v25.c), *(float64x2_t *)&v25.tx);
  (*(void (**)(void))(**((void **)a2 + 50) + 480))();
  CFDataRef v4 = (const __CFData *)(id)atomic_load_explicit((atomic_ullong *volatile)this + 3, memory_order_acquire);
  CFDataRef v5 = v4;
  if (v4) {
    BytePtr = CFDataGetBytePtr(v4);
  }
  else {
    BytePtr = 0;
  }

  *((void *)this + 4) = BytePtr;
  id v7 = (id)atomic_load_explicit((atomic_ullong *volatile)this + 3, memory_order_acquire);
  CFDataRef v8 = (const __CFData *)v7;
  if (v8)
  {
    CFDataRef v9 = v8;
    uint8x8_t v10 = CFDataGetBytePtr(v8);

    if (v10) {
      v10 += CFDataGetLength((CFDataRef)v7);
    }
  }
  else
  {

    uint8x8_t v10 = 0;
  }

  *((void *)this + 8) = 0;
  *((void *)this + 5) = v10;
  *((void *)this + 6) = TAATOpbdTable::GetDefaultBounds;
  *((void *)this + 7) = 0;
  long long v11 = (_WORD *)*((void *)this + 4);
  if (v11)
  {
    if (v11 + 4 <= (_WORD *)v10)
    {
      switch(bswap32((unsigned __int16)v11[3]) >> 16)
      {
        case 0u:
          goto LABEL_35;
        case 2u:
        case 4u:
        case 6u:
          if (v11 + 6 > (_WORD *)v10) {
            goto LABEL_10;
          }
          uint64_t v13 = v11 + 9;
          unsigned int v14 = bswap32((unsigned __int16)v11[4]) >> 16;
          unsigned int v15 = (unsigned __int16)v11[5];
          goto LABEL_31;
        case 8u:
          uint64_t v16 = (const UInt8 *)(v11 + 6);
          if (v11 + 6 > (_WORD *)v10) {
            goto LABEL_10;
          }
          uint64_t v17 = bswap32((unsigned __int16)v11[5]) >> 16;
          unint64_t v18 = (unint64_t)&v16[2 * v17];
          unint64_t v19 = v11 + 7 <= (_WORD *)v10 ? (unint64_t)(v10 - v16) >> 1 : 0;
          BOOL v20 = v18 <= (unint64_t)v10 && v18 >= (unint64_t)v16;
          if (!v20 && v19 != v17) {
            goto LABEL_10;
          }
          goto LABEL_35;
        case 0xAu:
          uint64_t v13 = v11 + 7;
          if (v11 + 7 > (_WORD *)v10) {
            goto LABEL_10;
          }
          unsigned int v14 = bswap32((unsigned __int16)v11[4]) >> 16;
          unsigned int v15 = (unsigned __int16)v11[6];
LABEL_31:
          unint64_t v22 = (unint64_t)v13 + (bswap32(v15) >> 16) * (unint64_t)v14;
          if (v22 < (unint64_t)v13 || v22 > (unint64_t)v10) {
            goto LABEL_10;
          }
LABEL_35:
          if (*v11 != 256) {
            goto LABEL_10;
          }
          unsigned int v24 = bswap32((unsigned __int16)v11[2]) >> 16;
          if (v24 == 1)
          {
            *((void *)this + 6) = TAATOpbdTable::LookupByControlPoint;
            *((void *)this + 7) = 0;
            operator new();
          }
          if (v24) {
            goto LABEL_10;
          }
          CFDataRef v12 = TAATOpbdTable::LookupByDistance;
          break;
        default:
          goto LABEL_10;
      }
    }
    else
    {
LABEL_10:
      (*(void (**)(void, uint64_t))(**((void **)a2 + 50) + 488))(*((void *)a2 + 50), 1869636196);
      CFDataRef v12 = TAATOpbdTable::InvalidLookup;
    }
    *((void *)this + 6) = v12;
    *((void *)this + 7) = 0;
  }
}

void CopyFeatureSettingForTag(const __CFString *a1@<X0>, const TBaseFont *a2@<X2>, BOOL *a3@<X3>, unsigned int *a4@<X4>, uint64_t a5@<X1>, void *a6@<X8>)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  unsigned int v12 = FourCharCodeFromString(a1);
  unsigned int v51 = v12;
  if (!v12)
  {
    *a6 = 0;
    return;
  }
  unsigned int v13 = v12;
  MasterFeatureMapEntrCGFloat y = FindMasterFeatureMapEntry(v12);
  if (a2) {
    BOOL v15 = a3 == 0;
  }
  else {
    BOOL v15 = 1;
  }
  int v16 = !v15;
  if (!MasterFeatureMapEntry)
  {
    if (v16)
    {
      memset(valuePtr, 170, sizeof(valuePtr));
      CustomOTFeatures(a2, 0, valuePtr);
      CGFloat v26 = (void *)valuePtr[0];
      if (valuePtr[1] == valuePtr[0]) {
        goto LABEL_53;
      }
      unint64_t v27 = ((char *)valuePtr[1] - (char *)valuePtr[0]) >> 2;
      long long v28 = (unsigned int *)valuePtr[0];
      do
      {
        unint64_t v29 = v27 >> 1;
        uint64_t v30 = &v28[v27 >> 1];
        unsigned int v32 = *v30;
        uint64_t v31 = v30 + 1;
        v27 += ~(v27 >> 1);
        if (v32 < v13) {
          long long v28 = v31;
        }
        else {
          unint64_t v27 = v29;
        }
      }
      while (v27);
      if (v28 == valuePtr[1]) {
LABEL_53:
      }
        BOOL v33 = 0;
      else {
        BOOL v33 = v13 >= *v28;
      }
      *a3 = v33;
      if (v26)
      {
        valuePtr[1] = v26;
        operator delete(v26);
      }
    }
    if (a4) {
      *a4 = 0;
    }
    uint64_t v50 = [NSNumber numberWithUnsignedInt:a5];
    id v43 = [CTFeatureSetting alloc];
    uint64_t v44 = 0;
    uint64_t v45 = 0;
    CFStringRef v46 = a1;
    CGFloat v47 = (NSNumber *)v50;
LABEL_59:
    *a6 = -[CTFeatureSetting initWithType:selector:tag:value:](v43, v44, v45, (uint64_t)v46, v47);
    return;
  }
  uint64_t v17 = MasterFeatureMapEntry;
  if (!v16)
  {
LABEL_37:
    unsigned __int16 v34 = *((_WORD *)v17 + 3);
    unsigned int v35 = *((_DWORD *)v17 + 2);
    if (v35)
    {
      if (v17[1] & 2 | a5)
      {
        if ((v35 & 0x40) != 0) {
          unsigned __int16 v34 = a5;
        }
      }
      else
      {
              i != v49;
              uint64_t i = (uint64_t *)((char *)i + 12))
        {
          if ((i[1] & 2) != 0)
          {
            unsigned __int16 v34 = *((_WORD *)i + 3);
            break;
          }
        }
      }
    }
    else if (a5)
    {
      v34 &= ~1u;
    }
    else
    {
      v34 |= 1u;
    }
    if (a4)
    {
      *a4 = (v35 >> 1) & 1;
      unsigned int v35 = *((_DWORD *)v17 + 2);
    }
    if ((v35 & 8) == 0)
    {
      valuePtr[0] = (const void *)a5;
      CFAllocatorRef v36 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFNumberRef v37 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberLongType, valuePtr);
      LODWORD(valuePtr[0]) = *((unsigned __int16 *)v17 + 2);
      CFNumberRef v38 = CFNumberCreate(v36, kCFNumberIntType, valuePtr);
      LODWORD(valuePtr[0]) = v34;
      CFNumberRef v39 = CFNumberCreate(v36, kCFNumberIntType, valuePtr);
      valuePtr[0] = @"CTFeatureOpenTypeTag";
      valuePtr[1] = @"CTFeatureOpenTypeValue";
      valuePtr[2] = @"CTFeatureTypeIdentifier";
      *(void *)&v54[0] = @"CTFeatureSelectorIdentifier";
      values[0] = (void *)a1;
      values[1] = v37;
      values[2] = v38;
      values[3] = v39;
      CFDictionaryRef v40 = CFDictionaryCreate(v36, valuePtr, (const void **)values, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      *a6 = [[CTFeatureSetting alloc] initWithDictionary:v40];

      return;
    }
    uint64_t v41 = [NSNumber numberWithUnsignedShort:*((unsigned __int16 *)v17 + 2)];
    uint64_t v42 = [NSNumber numberWithUnsignedShort:v34];
    id v43 = [CTFeatureSetting alloc];
    uint64_t v44 = v41;
    uint64_t v45 = v42;
    CFStringRef v46 = 0;
    CGFloat v47 = 0;
    goto LABEL_59;
  }
  *(void *)&long long v18 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v54[6] = v18;
  v54[5] = v18;
  v54[4] = v18;
  v54[3] = v18;
  v54[2] = v18;
  v54[1] = v18;
  v54[0] = v18;
  memset(valuePtr, 0, sizeof(valuePtr));
  unint64_t v55 = 0xAAAAAAAAAAAAAAAALL;
  CGFloat v56 = v54;
  MergeOTFeaturesFromTable<TInlineVector<unsigned int,30ul>>(valuePtr, a2, 1196643650);
  MergeOTFeaturesFromTable<TInlineVector<unsigned int,30ul>>(valuePtr, a2, 1196445523);
  unint64_t v19 = (unsigned int *)valuePtr[0];
  if (valuePtr[1] == valuePtr[0]) {
    goto LABEL_35;
  }
  unint64_t v20 = ((char *)valuePtr[1] - (char *)valuePtr[0]) >> 2;
  do
  {
    unint64_t v21 = v20 >> 1;
    unint64_t v22 = &v19[v20 >> 1];
    unsigned int v24 = *v22;
    int v23 = v22 + 1;
    v20 += ~(v20 >> 1);
    if (v24 < v13) {
      unint64_t v19 = v23;
    }
    else {
      unint64_t v20 = v21;
    }
  }
  while (v20);
  if (v19 == valuePtr[1])
  {
LABEL_35:
    *a3 = 0;
LABEL_36:
    values[0] = valuePtr;
    std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)values);
    goto LABEL_37;
  }
  BOOL v25 = v13 >= *v19;
  *a3 = v25;
  if (!v25
    || a5 < 2
    || (v17[1] & 0x8000) == 0
    || NumberOfGlyphVariants(a2, v13) < a5)
  {
    goto LABEL_36;
  }
  if (a4) {
    *a4 = 0;
  }
  *a6 = -[CTFeatureSetting initWithType:selector:tag:value:]([CTFeatureSetting alloc], 0, 0, (uint64_t)a1, (NSNumber *)[NSNumber numberWithUnsignedInt:a5]);
  values[0] = valuePtr;
  std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)values);
}

void CustomOTFeatures(const TBaseFont *a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  CFDataRef v4 = a1;
  uint64_t v74 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v71[6] = v6;
  v71[5] = v6;
  v71[3] = v6;
  v71[4] = v6;
  v71[1] = v6;
  v71[2] = v6;
  v71[0] = v6;
  unint64_t v69 = 0;
  uint64_t v70 = 0;
  long long v68 = 0;
  unint64_t v72 = 0xAAAAAAAAAAAAAAAALL;
  long long v73 = v71;
  MergeOTFeaturesFromTable<TInlineVector<unsigned int,30ul>>(&v68, a1, 1196643650);
  MergeOTFeaturesFromTable<TInlineVector<unsigned int,30ul>>(&v68, v4, 1196445523);
  id v7 = (unsigned int *)v68;
  CFDataRef v8 = v69;
  if (v68 != v69)
  {
    CFDataRef v9 = v68 + 1;
    while (v9 != v69)
    {
      int v10 = *(v9 - 1);
      int v11 = *v9++;
      if (v10 == v11)
      {
        unsigned int v12 = v9 - 2;
        while (v9 != v8)
        {
          int v13 = v10;
          int v10 = *v9;
          if (v13 != *v9)
          {
            v12[1] = v10;
            ++v12;
          }
          ++v9;
        }
        unsigned int v14 = v12 + 1;
        goto LABEL_12;
      }
    }
  }
  unsigned int v14 = v69;
LABEL_12:
  if (v8 != v14)
  {
    CFDataRef v8 = v14;
    unint64_t v69 = v14;
  }
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  double v67 = a3;
  if (v7 != (unsigned int *)v8)
  {
    BOOL v15 = &kMasterFeatureMap;
    while (v15 != (uint64_t *)&unk_184BA84A4)
    {
      unsigned int v16 = *(_DWORD *)v15;
      if (*(_DWORD *)v15 <= *v7)
      {
        BOOL v15 = (uint64_t *)((char *)v15 + 12);
        if (v16 >= *v7) {
          ++v7;
        }
      }
      else
      {
        std::back_insert_iterator<std::vector<unsigned int>>::operator=[abi:nn180100]((uint64_t *)&v67, v7++);
      }
      if (v7 == (unsigned int *)v8) {
        goto LABEL_22;
      }
    }
    *(void *)unint64_t v65 = v67;
    while (v7 != (unsigned int *)v8)
      std::back_insert_iterator<std::vector<unsigned int>>::operator=[abi:nn180100]((uint64_t *)v65, v7++);
  }
LABEL_22:
  if (a2)
  {
    uint64_t v17 = a3 + 2;
    long long v18 = &kMasterFeatureMap;
    do
    {
      int v66 = *((_DWORD *)v18 + 2);
      *(void *)unint64_t v65 = *v18;
      if ((v66 & 0x8000) != 0)
      {
        unint64_t v19 = v68;
        if (v69 != v68)
        {
          unint64_t v20 = v69 - v68;
          do
          {
            unint64_t v21 = v20 >> 1;
            unint64_t v22 = (unsigned int *)&v19[v20 >> 1];
            unsigned int v24 = *v22;
            int v23 = (int *)(v22 + 1);
            v20 += ~(v20 >> 1);
            if (v24 < v65[0]) {
              unint64_t v19 = v23;
            }
            else {
              unint64_t v20 = v21;
            }
          }
          while (v20);
          if (v19 != v69 && v65[0] >= *v19 && NumberOfGlyphVariants(v4, v65[0]) >= 2)
          {
            CGFloat v26 = (char *)*a3;
            BOOL v25 = (char *)a3[1];
            uint64_t v27 = (uint64_t)&v25[-*a3];
            if (v25 == (char *)*a3)
            {
              unint64_t v29 = (char *)a3[1];
            }
            else
            {
              unint64_t v28 = v27 >> 2;
              unint64_t v29 = (char *)*a3;
              do
              {
                unint64_t v30 = v28 >> 1;
                uint64_t v31 = (unsigned int *)&v29[4 * (v28 >> 1)];
                unsigned int v33 = *v31;
                unsigned int v32 = (char *)(v31 + 1);
                v28 += ~(v28 >> 1);
                if (v33 < v65[0]) {
                  unint64_t v29 = v32;
                }
                else {
                  unint64_t v28 = v30;
                }
              }
              while (v28);
            }
            uint64_t v34 = v29 - v26;
            unsigned int v35 = &v26[(v29 - v26) & 0xFFFFFFFFFFFFFFFCLL];
            uint64_t v36 = *v17;
            if ((unint64_t)v25 >= *v17)
            {
              unint64_t v40 = (v27 >> 2) + 1;
              if (v40 >> 62) {
                abort();
              }
              int v63 = v4;
              uint64_t v64 = (uint64_t)v17;
              unint64_t v41 = v36 - (void)v26;
              unint64_t v42 = (v36 - (uint64_t)v26) >> 1;
              if (v42 > v40) {
                unint64_t v40 = v42;
              }
              if (v41 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v43 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v43 = v40;
              }
              if (v43) {
                uint64_t v44 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>((uint64_t)v17, v43);
              }
              else {
                uint64_t v44 = 0;
              }
              uint64_t v47 = v34 >> 2;
              CGFloat v48 = &v44[4 * (v34 >> 2)];
              CGFloat v49 = &v44[4 * v43];
              if (v34 >> 2 == v43)
              {
                if (v34 < 1)
                {
                  if (v29 == v26) {
                    unint64_t v51 = 1;
                  }
                  else {
                    unint64_t v51 = v34 >> 1;
                  }
                  size_t v52 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v64, v51);
                  CGFloat v48 = &v52[v51 & 0xFFFFFFFFFFFFFFFCLL];
                  CGFloat v49 = &v52[4 * v53];
                  if (v44)
                  {
                    CGFloat v54 = &v52[4 * v53];
                    operator delete(v44);
                    CGFloat v49 = v54;
                  }
                }
                else
                {
                  if (v47 >= -1) {
                    unint64_t v50 = v47 + 1;
                  }
                  else {
                    unint64_t v50 = v47 + 2;
                  }
                  v48 -= 4 * (v50 >> 1);
                }
              }
              *(_DWORD *)CGFloat v48 = v65[0];
              unint64_t v55 = v48 + 4;
              CGFloat v56 = (char *)*a3;
              if ((char *)*a3 != v35)
              {
                uint64_t v57 = v35;
                do
                {
                  int v58 = *((_DWORD *)v57 - 1);
                  v57 -= 4;
                  *((_DWORD *)v48 - 1) = v58;
                  v48 -= 4;
                }
                while (v57 != v56);
              }
              double v59 = (char *)a3[1];
              int64_t v60 = v59 - v35;
              if (v59 != v35)
              {
                CFDataRef v61 = v49;
                memmove(v55, v35, v59 - v35);
                CGFloat v49 = v61;
              }
              unint64_t v62 = (void *)*a3;
              *a3 = v48;
              a3[1] = &v55[v60];
              a3[2] = v49;
              CFDataRef v4 = v63;
              uint64_t v17 = (uint64_t *)v64;
              if (v62) {
                operator delete(v62);
              }
            }
            else if (v35 == v25)
            {
              *(_DWORD *)BOOL v25 = v65[0];
              a3[1] = v25 + 4;
            }
            else
            {
              CFNumberRef v37 = v25 - 4;
              CFNumberRef v38 = (unsigned int *)a3[1];
              while (v37 < v25)
              {
                unsigned int v39 = *(_DWORD *)v37;
                v37 += 4;
                *v38++ = v39;
              }
              a3[1] = v38;
              if (v25 != v35 + 4)
              {
                memmove(&v25[-4 * ((v25 - (v35 + 4)) >> 2)], &v26[(v29 - v26) & 0xFFFFFFFFFFFFFFFCLL], v25 - (v35 + 4));
                CFNumberRef v38 = (unsigned int *)a3[1];
              }
              BOOL v46 = v35 <= (char *)v65 && v38 > v65;
              *(_DWORD *)unsigned int v35 = *(_DWORD *)((unint64_t)v65 | (4 * v46));
            }
          }
        }
      }
      long long v18 = (uint64_t *)((char *)v18 + 12);
    }
    while (v18 != (uint64_t *)&unk_184BA84A4);
  }
  *(void *)unint64_t v65 = &v68;
  std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v65);
}

uint64_t *std::back_insert_iterator<std::vector<unsigned int>>::operator=[abi:nn180100](uint64_t *a1, _DWORD *a2)
{
  uint64_t v4 = *a1;
  CFDataRef v5 = *(_DWORD **)(*a1 + 8);
  long long v6 = (void *)(*a1 + 16);
  if ((unint64_t)v5 >= *v6)
  {
    CFDataRef v8 = *(_DWORD **)v4;
    uint64_t v9 = ((uint64_t)v5 - *(void *)v4) >> 2;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 62) {
      abort();
    }
    uint64_t v11 = *v6 - (void)v8;
    if (v11 >> 1 > v10) {
      unint64_t v10 = v11 >> 1;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      int v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>((uint64_t)v6, v12);
      CFDataRef v8 = *(_DWORD **)v4;
      CFDataRef v5 = *(_DWORD **)(v4 + 8);
    }
    else
    {
      int v13 = 0;
    }
    unsigned int v14 = &v13[4 * v9];
    BOOL v15 = &v13[4 * v12];
    *(_DWORD *)unsigned int v14 = *a2;
    id v7 = v14 + 4;
    while (v5 != v8)
    {
      int v16 = *--v5;
      *((_DWORD *)v14 - 1) = v16;
      v14 -= 4;
    }
    *(void *)uint64_t v4 = v14;
    *(void *)(v4 + 8) = v7;
    *(void *)(v4 + 16) = v15;
    if (v8) {
      operator delete(v8);
    }
  }
  else
  {
    _DWORD *v5 = *a2;
    id v7 = v5 + 1;
  }
  *(void *)(v4 + 8) = v7;
  return a1;
}

void MergeOTFeaturesFromTable<TInlineVector<unsigned int,30ul>>(void *a1, TBaseFont *this, uint64_t a3)
{
  CFDataRef CommonTable = (const __CFData *)TBaseFont::GetCommonTable(this, a3, 0);
  if (CommonTable)
  {
    CFDataRef v5 = CommonTable;
    BytePtr = CFDataGetBytePtr(CommonTable);
    if (BytePtr)
    {
      id v7 = BytePtr;
      CFDataRef v8 = CFDataGetBytePtr(v5);
      if (v8)
      {
        unint64_t v9 = (unint64_t)&v8[CFDataGetLength(v5)];
        if ((unint64_t)(v7 + 10) <= v9
          && bswap32(*(unsigned __int16 *)v7) >> 16 <= 1
          && (!*((_WORD *)v7 + 1) || (unint64_t)(v7 + 14) <= v9))
        {
          if (*((_WORD *)v7 + 3))
          {
            unint64_t v10 = &v7[__rev16(*((unsigned __int16 *)v7 + 3))];
            uint64_t v11 = (unsigned int *)(v10 + 2);
            if ((unint64_t)(v10 + 2) <= v9)
            {
              unsigned int v12 = *(unsigned __int16 *)v10;
              uint64_t v13 = __rev16(v12);
              unsigned int v14 = (char *)v11 + 6 * v13;
              BOOL v15 = v14 < (char *)v11 || (unint64_t)v14 > v9;
              if (!v15
                || ((unint64_t)(v10 + 8) <= v9 ? (unint64_t v16 = (v9 - (unint64_t)v11) / 6) : (unint64_t v16 = 0),
                    v16 == v13))
              {
                uint64_t v17 = (char *)a1[1];
                uint64_t v18 = (uint64_t)&v17[-*a1] >> 2;
                unint64_t v19 = v13 + v18;
                if (v13 + v18 > (unint64_t)((uint64_t)(a1[2] - *a1) >> 2))
                {
                  if (v19 >> 62) {
LABEL_47:
                  }
                    abort();
                  CGFloat v48 = a1 + 3;
                  unint64_t v20 = (char *)TInlineBufferAllocator<unsigned int,30ul>::allocate((uint64_t)(a1 + 3), v13 + v18);
                  unint64_t v22 = (char *)*a1;
                  unint64_t v21 = (char *)a1[1];
                  int v23 = &v20[4 * v18];
                  if (v21 != (char *)*a1)
                  {
                    unsigned int v24 = (char *)a1[1];
                    int v23 = &v20[4 * v18];
                    do
                    {
                      int v25 = *((_DWORD *)v24 - 1);
                      v24 -= 4;
                      *((_DWORD *)v23 - 1) = v25;
                      v23 -= 4;
                    }
                    while (v24 != v22);
                  }
                  *a1 = v23;
                  a1[1] = &v20[4 * v18];
                  uint64_t v26 = a1[2];
                  a1[2] = &v20[4 * v19];
                  BOOL v46 = v21;
                  uint64_t v47 = v26;
                  uint64_t v44 = v22;
                  uint64_t v45 = v22;
                  std::__split_buffer<unsigned int,TInlineBufferAllocator<unsigned int,30ul> &>::~__split_buffer((uint64_t)&v44);
                  uint64_t v17 = (char *)a1[1];
                }
                uint64_t v43 = v18;
                if (v12)
                {
                  uint64_t v27 = (unsigned int *)((char *)v11 + 6 * v13);
                  do
                  {
                    unsigned int v28 = bswap32(*v11);
                    unint64_t v29 = a1[2];
                    if ((unint64_t)v17 >= v29)
                    {
                      unint64_t v30 = (char *)*a1;
                      uint64_t v31 = (uint64_t)&v17[-*a1] >> 2;
                      unint64_t v32 = v31 + 1;
                      if ((unint64_t)(v31 + 1) >> 62) {
                        goto LABEL_47;
                      }
                      uint64_t v33 = v29 - (void)v30;
                      if (v33 >> 1 > v32) {
                        unint64_t v32 = v33 >> 1;
                      }
                      if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFFCLL) {
                        unint64_t v34 = 0x3FFFFFFFFFFFFFFFLL;
                      }
                      else {
                        unint64_t v34 = v32;
                      }
                      CGFloat v48 = a1 + 3;
                      if (v34)
                      {
                        unsigned int v35 = (char *)TInlineBufferAllocator<unsigned int,30ul>::allocate((uint64_t)(a1 + 3), v34);
                        unint64_t v30 = (char *)*a1;
                        uint64_t v17 = (char *)a1[1];
                      }
                      else
                      {
                        unsigned int v35 = 0;
                      }
                      uint64_t v36 = (unsigned int *)&v35[4 * v31];
                      unsigned int *v36 = v28;
                      if (v17 == v30)
                      {
                        CFNumberRef v38 = &v35[4 * v31];
                      }
                      else
                      {
                        CFNumberRef v37 = v17;
                        CFNumberRef v38 = &v35[4 * v31];
                        do
                        {
                          int v39 = *((_DWORD *)v37 - 1);
                          v37 -= 4;
                          *((_DWORD *)v38 - 1) = v39;
                          v38 -= 4;
                        }
                        while (v37 != v30);
                      }
                      unint64_t v40 = (char *)(v36 + 1);
                      *a1 = v38;
                      a1[1] = v36 + 1;
                      uint64_t v41 = a1[2];
                      a1[2] = &v35[4 * v34];
                      BOOL v46 = v17;
                      uint64_t v47 = v41;
                      uint64_t v44 = v30;
                      uint64_t v45 = v30;
                      std::__split_buffer<unsigned int,TInlineBufferAllocator<unsigned int,30ul> &>::~__split_buffer((uint64_t)&v44);
                      uint64_t v17 = v40;
                    }
                    else
                    {
                      *(_DWORD *)uint64_t v17 = v28;
                      v17 += 4;
                    }
                    a1[1] = v17;
                    uint64_t v11 = (unsigned int *)((char *)v11 + 6);
                  }
                  while (v11 != v27);
                }
                unint64_t v42 = (char *)*a1;
                LOBYTE(v44) = -86;
                std::__sort<std::__less<unsigned int,unsigned int> &,unsigned int *>();
                std::__inplace_merge[abi:nn180100]<std::_ClassicAlgPolicy,std::__wrap_iter<unsigned int *>,std::__less<void,void> &>(v42, &v42[4 * v43], v17);
              }
            }
          }
        }
      }
    }
  }
}

void CreateOTFeatureTable(const TBaseFont *a1@<X0>, void *a2@<X8>)
{
  memset(&v103, 0, sizeof(v103));
  MergeOTFeaturesFromTable<std::vector<unsigned int>>(&v103, a1, 1196643650);
  MergeOTFeaturesFromTable<std::vector<unsigned int>>(&v103, a1, 1196445523);
  begiCFIndex n = v103.__begin_;
  std::vector<unsigned int>::pointer end = v103.__end_;
  if (v103.__begin_ != v103.__end_)
  {
    std::vector<unsigned int>::pointer v6 = v103.__begin_ + 1;
    while (v6 != v103.__end_)
    {
      unsigned int v7 = *(v6 - 1);
      unsigned int v8 = *v6++;
      if (v7 == v8)
      {
        std::vector<unsigned int>::pointer v9 = v6 - 2;
        while (v6 != end)
        {
          unsigned int v10 = v7;
          unsigned int v7 = *v6;
          if (v10 != *v6)
          {
            v9[1] = v7;
            ++v9;
          }
          ++v6;
        }
        uint64_t v11 = v9 + 1;
        goto LABEL_12;
      }
    }
  }
  uint64_t v11 = v103.__end_;
LABEL_12:
  if (end != v11)
  {
    std::vector<unsigned int>::pointer end = v11;
    v103.__end_ = v11;
  }
  unsigned int v12 = (CFAllocatorRef *)MEMORY[0x1E4F1CF90];
  if (begin == end)
  {
    CFIndex v45 = 0;
    BOOL v46 = 0;
  }
  else
  {
    v92 = a2;
    uint64_t v13 = (unsigned __int16 *)operator new(8uLL);
    *(void *)uint64_t v13 = 0x10000;
    unsigned int v14 = v13 + 4;
    *(_OWORD *)unsigned int v100 = 0u;
    long long v101 = 0u;
    unint64_t v102 = 0xAAAAAAAA3F800000;
    long long v97 = 0u;
    long long v98 = 0u;
    BOOL v15 = &dword_184BA7CF4;
    unint64_t v99 = 0xAAAAAAAA3F800000;
    unint64_t v16 = (char *)(v13 + 4);
    unint64_t v93 = end;
    do
    {
      if (*begin == *v15)
      {
        uint64_t v17 = v15 + 3;
        do
        {
          uint64_t v18 = v17;
          if (v17 >= &dword_184BA84A4) {
            break;
          }
          v17 += 3;
        }
        while (*begin == *v18);
        std::vector<unsigned int>::pointer v95 = begin;
        if (v15 < v18)
        {
          while (1)
          {
            if ((v15[2] & 8) != 0)
            {
              unint64_t v20 = v14;
            }
            else
            {
              unint64_t v19 = v15 + 1;
              if (v14 >= (unsigned __int16 *)v16)
              {
                uint64_t v21 = ((char *)v14 - (char *)v13) >> 3;
                unint64_t v22 = v21 + 1;
                if ((unint64_t)(v21 + 1) >> 61) {
                  abort();
                }
                if ((v16 - (char *)v13) >> 2 > v22) {
                  unint64_t v22 = (v16 - (char *)v13) >> 2;
                }
                if ((unint64_t)(v16 - (char *)v13) >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v23 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v23 = v22;
                }
                if (v23)
                {
                  if (v23 >> 61) {
                    std::__throw_bad_array_new_length[abi:nn180100]();
                  }
                  unsigned int v24 = (char *)operator new(8 * v23);
                }
                else
                {
                  unsigned int v24 = 0;
                }
                int v25 = (unsigned __int16 *)&v24[8 * v21];
                *(void *)int v25 = *v19;
                unint64_t v20 = v25 + 4;
                while (v14 != v13)
                {
                  uint64_t v26 = *((void *)v14 - 1);
                  v14 -= 4;
                  *((void *)v25 - 1) = v26;
                  v25 -= 4;
                }
                unint64_t v16 = &v24[8 * v23];
                if (v13) {
                  operator delete(v13);
                }
                uint64_t v13 = v25;
              }
              else
              {
                *(void *)unsigned int v14 = *v19;
                unint64_t v20 = v14 + 4;
              }
              if ((v15[2] & 0x40) != 0)
              {
                LOWORD(v28) = NumberOfGlyphVariants(a1, *v15);
                unsigned __int16 v29 = *((_WORD *)v15 + 2);
                uint64_t v31 = (id *)&v97;
                unint64_t v30 = v15 + 1;
              }
              else
              {
                if (*(_WORD *)v19 != 35) {
                  goto LABEL_47;
                }
                CFDataRef v27 = FeatureParamsForTag<OTL::StylisticSetFeatureParams>(a1, *v15);
                if (!v27) {
                  goto LABEL_47;
                }
                unsigned int v28 = bswap32(*((unsigned __int16 *)v27 + 1)) >> 16;
                unint64_t v30 = (_WORD *)v15 + 3;
                unsigned __int16 v29 = *((_WORD *)v15 + 3);
                uint64_t v31 = v100;
              }
              *((_WORD *)std::__hash_table<std::__hash_value_type<unsigned short,unsigned short>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,unsigned short>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,unsigned short>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,unsigned short>>>::__emplace_unique_key_args<unsigned short,std::piecewise_construct_t const&,std::tuple<unsigned short const&>,std::tuple<>>((uint64_t)v31, v29, v30)+ 9) = v28;
            }
LABEL_47:
            unsigned int v14 = v20;
            BOOL v32 = v15 >= v18 - 3;
            v15 += 3;
            if (v32) {
              goto LABEL_54;
            }
          }
        }
        unint64_t v20 = v14;
LABEL_54:
        begiCFIndex n = v95 + 1;
        unsigned int v14 = v20;
        std::vector<unsigned int>::pointer end = v93;
      }
      else if (*begin >= *v15)
      {
        uint64_t v18 = v15 + 3;
      }
      else
      {
        ++begin;
        uint64_t v18 = v15;
      }
      if (begin == end) {
        break;
      }
      BOOL v15 = v18;
    }
    while (v18 != &dword_184BA84A4);
    if (v13 == v14)
    {
      CFIndex v45 = 0;
      BOOL v46 = 0;
      a2 = v92;
      unsigned int v12 = (CFAllocatorRef *)MEMORY[0x1E4F1CF90];
    }
    else
    {
      unsigned int v12 = (CFAllocatorRef *)MEMORY[0x1E4F1CF90];
      if (*((void *)&v101 + 1))
      {
        id v96 = (id)0xAAAAAAAAAAAAAAAALL;
        (*(void (**)(id *__return_ptr))(*(void *)a1 + 496))(&v96);
        atomic_load_explicit((atomic_ullong *volatile)&v96, memory_order_acquire);
        if (CGFontNameTableCreate())
        {
          uint64_t v33 = (long long *)v101;
          if ((void)v101)
          {
            while (1)
            {
              unint64_t v34 = (void *)CGFontNameTableCopyRootName();

              unsigned int v35 = *(long long **)v33;
              if (!v34) {
                break;
              }
LABEL_90:
              uint64_t v33 = v35;
              if (!v35) {
                goto LABEL_91;
              }
            }
            unint64_t v36 = (unint64_t)v100[1];
            unint64_t v37 = *((void *)v33 + 1);
            uint8x8_t v38 = (uint8x8_t)vcnt_s8((int8x8_t)v100[1]);
            v38.i16[0] = vaddlv_u8(v38);
            if (v38.u32[0] > 1uLL)
            {
              if ((id)v37 >= v100[1]) {
                v37 %= (unint64_t)v100[1];
              }
            }
            else
            {
              v37 &= (unint64_t)v100[1] - 1;
            }
            int v39 = (long long *)*((void *)v100[0] + v37);
            do
            {
              unint64_t v40 = v39;
              int v39 = *(long long **)v39;
            }
            while (v39 != v33);
            if (v40 == &v101) {
              goto LABEL_180;
            }
            unint64_t v41 = *((void *)v40 + 1);
            if (v38.u32[0] > 1uLL)
            {
              if ((id)v41 >= v100[1]) {
                v41 %= (unint64_t)v100[1];
              }
            }
            else
            {
              v41 &= (unint64_t)v100[1] - 1;
            }
            unint64_t v42 = *(long long **)v33;
            if (v41 != v37)
            {
LABEL_180:
              if (v35)
              {
                unint64_t v43 = *((void *)v35 + 1);
                if (v38.u32[0] > 1uLL)
                {
                  unint64_t v44 = *((void *)v35 + 1);
                  if ((id)v43 >= v100[1]) {
                    unint64_t v44 = v43 % (unint64_t)v100[1];
                  }
                }
                else
                {
                  unint64_t v44 = v43 & ((unint64_t)v100[1] - 1);
                }
                unint64_t v42 = *(long long **)v33;
                if (v44 == v37) {
                  goto LABEL_83;
                }
              }
              *((void *)v100[0] + v37) = 0;
              unint64_t v42 = *(long long **)v33;
            }
            if (!v42)
            {
LABEL_89:
              *(void *)unint64_t v40 = v42;
              *(void *)uint64_t v33 = 0;
              --*((void *)&v101 + 1);
              operator delete(v33);
              goto LABEL_90;
            }
            unint64_t v43 = *((void *)v42 + 1);
LABEL_83:
            if (v38.u32[0] > 1uLL)
            {
              if (v43 >= v36) {
                v43 %= v36;
              }
            }
            else
            {
              v43 &= v36 - 1;
            }
            if (v43 != v37)
            {
              *((void *)v100[0] + v43) = v40;
              unint64_t v42 = *(long long **)v33;
            }
            goto LABEL_89;
          }
LABEL_91:
          CGFontNameTableRelease();
        }
        else
        {
          std::__hash_table<std::__hash_value_type<unsigned short,unsigned short>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,unsigned short>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,unsigned short>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,unsigned short>>>::clear(v100);
        }
      }
      unint64_t v47 = ((char *)v14 - (char *)v13) >> 3;
      std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,PseudoFeature *,false>((unint64_t)v13, v14, 126 - 2 * __clz(v47), 1);
      CGFloat v48 = v13 - 4;
      a2 = v92;
      do
      {
        if (v48 + 8 == v14)
        {
          CGFloat v54 = v14;
          goto LABEL_113;
        }
        int v50 = v48[4];
        v48 += 4;
        LODWORD(v49) = v50;
      }
      while (v50 != v48[4] || v48[1] != v48[5]);
      for (uint64_t i = v48 + 8; i != v14; i += 4)
      {
        if (v49 != *i || v48[1] != i[1])
        {
          uint64_t v49 = *(void *)i;
          *((void *)v48 + 1) = *(void *)i;
          v48 += 4;
          LODWORD(v49) = (unsigned __int16)v49;
        }
      }
      CGFloat v54 = v48 + 4;
      unint64_t v47 = ((char *)v54 - (char *)v13) >> 3;
LABEL_113:
      unint64_t v55 = (char *)((char *)v14 - (char *)v54);
      if (v55)
      {
        CGFloat v56 = &v13[4 * v47];
        size_t v57 = (char *)v14 - &v55[(void)v56];
        if (v57) {
          memmove(&v13[4 * v47], &v55[(void)v56], v57);
        }
        unsigned int v14 = (unsigned __int16 *)((char *)v56 + v57);
      }
      if (v13 == v14)
      {
        unsigned int v58 = 0;
      }
      else
      {
        unsigned int v58 = 0;
        int v59 = -1;
        int64_t v60 = v13;
        do
        {
          int v62 = *v60;
          v60 += 4;
          int v61 = v62;
          if (v59 != v62) {
            ++v58;
          }
          int v59 = v61;
        }
        while (v60 != v14);
      }
      uint64_t v63 = v98;
      if ((void)v98)
      {
        int v64 = 0;
        do
        {
          v64 += *(unsigned __int16 *)(v63 + 18);
          uint64_t v63 = *(void *)v63;
        }
        while (v63);
        uint64_t v63 = v64;
      }
      CFIndex v45 = 4 * (v63 + (((char *)v14 - (char *)v13) >> 3)) + 12 * v58 + 12;
      unint64_t v65 = (UInt8 *)CFAllocatorAllocate(*v12, v45, 0);
      BOOL v46 = v65;
      *(_DWORD *)unint64_t v65 = 16777472;
      *((_DWORD *)v65 + 1) = bswap32(v58) >> 16;
      *((_DWORD *)v65 + 2) = 0;
      if (v13 != v14)
      {
        CFIndex v94 = v45;
        int v66 = 0;
        double v67 = &v65[12 * v58 + 12];
        CFDataRef v91 = v65;
        long long v68 = v65 + 12;
        unint64_t v69 = v13;
        int v70 = 12 * v58 + 12;
        do
        {
          if ((v69[2] & 0x40) != 0)
          {
            CGRect v86 = std::__hash_table<std::__hash_value_type<unsigned short,unsigned short>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,unsigned short>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,unsigned short>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,unsigned short>>>::__emplace_unique_key_args<unsigned short,std::piecewise_construct_t const&,std::tuple<unsigned short const&>,std::tuple<>>((uint64_t)&v97, *v69, v69);
            int v70 = 12 * v58 + 12;
            int v87 = *((unsigned __int16 *)v86 + 9);
            unsigned int v88 = *v69;
            *(_WORD *)long long v68 = __rev16(v88);
            *((_WORD *)v68 + 1) = bswap32(v87 + 1) >> 16;
            v68[1] = bswap32(v70 + 4 * (v66 + ((unint64_t)((char *)v69 - (char *)v13) >> 3)));
            *((_WORD *)v68 + 4) = 192;
            int v89 = -200 * v88;
            *((_WORD *)v68 + 5) = bswap32(v89 - 200) >> 16;
            *(_WORD *)double v67 = 0;
            *((_WORD *)v67 + 1) = bswap32(v89 - 201) >> 16;
            v67 += 4;
            if (v87)
            {
              int v90 = 0;
              do
              {
                *(_WORD *)double v67 = bswap32(++v90) >> 16;
                *((_WORD *)v67 + 1) = bswap32(v89 - 202) >> 16;
                v67 += 4;
                --v89;
              }
              while (v87 != v90);
            }
            v66 += v87;
            v68 += 3;
            v69 += 4;
          }
          else
          {
            uint64_t v71 = 0;
            unsigned int v72 = *v69;
            while (v72 == v69[v71])
            {
              v71 += 4;
              if (&v69[v71] == v14)
              {
                long long v73 = v14;
                goto LABEL_136;
              }
            }
            long long v73 = &v69[v71];
LABEL_136:
            *(_WORD *)long long v68 = __rev16(v72);
            *((_WORD *)v68 + 1) = bswap32((v73 - v69) >> 3) >> 16;
            v68[1] = bswap32(v70 + 4 * (v66 + ((unint64_t)((char *)v69 - (char *)v13) >> 3)));
            *((_WORD *)v68 + 5) = bswap32(-200 - 200 * v72) >> 16;
            if (v69 == v73)
            {
              unsigned int v75 = 0;
            }
            else
            {
              int v74 = 0;
              unsigned int v75 = 0;
              do
              {
                LOWORD(v96) = v69[1];
                *(_WORD *)double v67 = bswap32((unsigned __int16)v96) >> 16;
                int v76 = *v69;
                int v77 = (unsigned __int16)v96;
                unsigned int v78 = bswap32(~(unsigned __int16)v96 - 200 * v76 - 200) >> 16;
                *((_WORD *)v67 + 1) = v78;
                int v79 = *((_DWORD *)v69 + 1);
                if (v79)
                {
                  v75 |= v74 & (v79 << 30 >> 31) | 0xFFFFC000;
                }
                else
                {
                  if ((v79 & 2) == 0) {
                    *(_WORD *)double v67 = __rev16(v77 ^ 1);
                  }
                  if (v76 == 35 && v100[1])
                  {
                    uint8x8_t v80 = (uint8x8_t)vcnt_s8((int8x8_t)v100[1]);
                    v80.i16[0] = vaddlv_u8(v80);
                    if (v80.u32[0] > 1uLL)
                    {
                      unint64_t v81 = (unsigned __int16)v96;
                      if (v100[1] <= (id)(unsigned __int16)v96) {
                        unint64_t v81 = (unsigned __int16)v96 % (unint64_t)v100[1];
                      }
                    }
                    else
                    {
                      unint64_t v81 = (LODWORD(v100[1]) - 1) & (unsigned __int16)v96;
                    }
                    CGRect v82 = (uint64_t ***)*((void *)v100[0] + v81);
                    if (v82)
                    {
                      for (j = *v82; j; j = (uint64_t **)*j)
                      {
                        unint64_t v84 = (unint64_t)j[1];
                        if (v84 == (unsigned __int16)v96)
                        {
                          if (*((unsigned __int16 *)j + 8) == (unsigned __int16)v96)
                          {
                            CGRect v85 = std::__hash_table<std::__hash_value_type<unsigned short,unsigned short>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,unsigned short>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,unsigned short>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,unsigned short>>>::__emplace_unique_key_args<unsigned short,std::piecewise_construct_t const&,std::tuple<unsigned short const&>,std::tuple<>>((uint64_t)v100, (unsigned __int16)v96, &v96);
                            int v70 = 12 * v58 + 12;
                            unsigned int v78 = bswap32(*((unsigned __int16 *)v85 + 9)) >> 16;
                            goto LABEL_160;
                          }
                        }
                        else
                        {
                          if (v80.u32[0] > 1uLL)
                          {
                            if ((id)v84 >= v100[1]) {
                              v84 %= (unint64_t)v100[1];
                            }
                          }
                          else
                          {
                            v84 &= (unint64_t)v100[1] - 1;
                          }
                          if (v84 != v81) {
                            break;
                          }
                        }
                      }
                    }
                  }
                  LOWORD(v78) = v78 | 0x100;
LABEL_160:
                  *((_WORD *)v67 + 1) = v78;
                }
                v67 += 4;
                ++v74;
                v69 += 4;
              }
              while (v69 != v73);
              unint64_t v69 = v73;
            }
            *((_WORD *)v68 + 4) = bswap32(v75) >> 16;
            v68 += 3;
          }
        }
        while (v69 != v14);
        a2 = v92;
        CFIndex v45 = v94;
        unsigned int v12 = (CFAllocatorRef *)MEMORY[0x1E4F1CF90];
        BOOL v46 = v91;
      }
    }
    std::__hash_table<EncoderAttempt,std::hash<EncoderAttempt>,std::equal_to<EncoderAttempt>,std::allocator<EncoderAttempt>>::~__hash_table((uint64_t)&v97);
    std::__hash_table<EncoderAttempt,std::hash<EncoderAttempt>,std::equal_to<EncoderAttempt>,std::allocator<EncoderAttempt>>::~__hash_table((uint64_t)v100);
    if (v13) {
      operator delete(v13);
    }
  }
  v100[0] = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v46, v45, *v12);
  *a2 = atomic_exchange((atomic_ullong *volatile)v100, 0);

  if (v103.__begin_)
  {
    v103.__end_ = v103.__begin_;
    operator delete(v103.__begin_);
  }
}

void *std::__hash_table<std::__hash_value_type<unsigned short,unsigned short>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,unsigned short>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,unsigned short>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,unsigned short>>>::__emplace_unique_key_args<unsigned short,std::piecewise_construct_t const&,std::tuple<unsigned short const&>,std::tuple<>>(uint64_t a1, unsigned __int16 a2, _WORD *a3)
{
  unint64_t v5 = a2;
  unint64_t v6 = *(void *)(a1 + 8);
  if (v6)
  {
    uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      unint64_t v8 = a2;
      if (v6 <= a2) {
        unint64_t v8 = a2 % v6;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & a2;
    }
    std::vector<unsigned int>::pointer v9 = *(void ***)(*(void *)a1 + 8 * v8);
    if (v9)
    {
      unsigned int v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((unsigned __int16 *)v10 + 8) == a2) {
              return v10;
            }
          }
          else
          {
            if (v7.u32[0] > 1uLL)
            {
              if (v11 >= v6) {
                v11 %= v6;
              }
            }
            else
            {
              v11 &= v6 - 1;
            }
            if (v11 != v8) {
              break;
            }
          }
          unsigned int v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  else
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAAALL;
  }
  unsigned int v10 = operator new(0x18uLL);
  *unsigned int v10 = 0;
  v10[1] = v5;
  *((_WORD *)v10 + 8) = *a3;
  *((_WORD *)v10 + 9) = 0;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v13 = *(float *)(a1 + 32);
  if (!v6 || (float)(v13 * (float)v6) < v12)
  {
    BOOL v14 = 1;
    if (v6 >= 3) {
      BOOL v14 = (v6 & (v6 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v6);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<std::__hash_value_type<unsigned int,OTL::Lookup>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,OTL::Lookup>>>::__rehash<true>(a1, v17);
    unint64_t v6 = *(void *)(a1 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v6 <= v5) {
        unint64_t v8 = v5 % v6;
      }
      else {
        unint64_t v8 = v5;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & v5;
    }
  }
  uint64_t v18 = *(void *)a1;
  unint64_t v19 = *(void **)(*(void *)a1 + 8 * v8);
  if (v19)
  {
    *unsigned int v10 = *v19;
LABEL_38:
    *unint64_t v19 = v10;
    goto LABEL_39;
  }
  *unsigned int v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v8) = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v20 >= v6) {
        v20 %= v6;
      }
    }
    else
    {
      v20 &= v6 - 1;
    }
    unint64_t v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v10;
}

const __CFData *FeatureParamsForTag<OTL::StylisticSetFeatureParams>(TBaseFont *a1, int a2)
{
  CFDataRef CommonTable = (const __CFData *)TBaseFont::GetCommonTable(a1, 1196643650, 0);
  if (!CommonTable || (CFDataRef result = FeatureParamsForTag<OTL::StylisticSetFeatureParams>(CommonTable, a2)) == 0)
  {
    CFDataRef v6 = (const __CFData *)TBaseFont::GetCommonTable(a1, 1196445523, 0);
    if (!v6) {
      return 0;
    }
    CFDataRef result = FeatureParamsForTag<OTL::StylisticSetFeatureParams>(v6, a2);
    if (!result) {
      return 0;
    }
  }
  return result;
}

const __CFData *FeatureParamsForTag<OTL::StylisticSetFeatureParams>(CFDataRef theData, int a2)
{
  CFDataRef v2 = theData;
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  if (theData)
  {
    BytePtr = CFDataGetBytePtr(theData);
    if (!BytePtr) {
      return 0;
    }
    unint64_t v5 = (unint64_t)BytePtr;
    CFDataRef v6 = CFDataGetBytePtr(v2);
    unint64_t v7 = v6 ? (unint64_t)&v6[CFDataGetLength(v2)] : 0;
    if (!*(_WORD *)(v5 + 6)) {
      return 0;
    }
    uint64_t v8 = __rev16(*(unsigned __int16 *)(v5 + 6));
    std::vector<unsigned int>::pointer v9 = (unsigned __int16 *)(v5 + v8);
    unint64_t v10 = v5 + v8 + 2;
    if (v10 > v7) {
      return 0;
    }
    unsigned int v11 = *v9;
    uint64_t v12 = __rev16(v11);
    unint64_t v13 = v10 + 6 * v12;
    if (v13 < v10 || v13 > v7)
    {
      unint64_t v15 = (v7 - v10) / 6;
      if ((unint64_t)(v9 + 4) > v7) {
        unint64_t v15 = 0;
      }
      if (v15 != v12) {
        return 0;
      }
    }
    if (*(_WORD *)(v5 + 8)
      && (unint64_t v16 = (unsigned __int16 *)(v5 + __rev16(*(unsigned __int16 *)(v5 + 8))),
          size_t v17 = v16 + 1,
          (unint64_t)(v16 + 1) <= v7))
    {
      CFDataRef v2 = 0;
      uint64_t v19 = bswap32(*v16) >> 16;
      unint64_t v20 = (unint64_t)&v17[v19];
      if ((unint64_t)(v16 + 2) <= v7) {
        unint64_t v21 = (v7 - (unint64_t)v17) >> 1;
      }
      else {
        unint64_t v21 = 0;
      }
      if (v20 <= v7 && v20 >= (unint64_t)v17 || v21 == v19)
      {
        *(void *)&long long v24 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v24 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v40[2] = v24;
        v40[3] = v24;
        v40[0] = v24;
        v40[1] = v24;
        memset(v39, 0, sizeof(v39));
        unint64_t v41 = v40;
        if (!v11) {
          goto LABEL_35;
        }
        int v25 = (unsigned __int16 *)(v8 + v5 + 6);
        uint64_t v26 = 6 * v12;
        while (bswap32(*((_DWORD *)v25 - 1)) != a2)
        {
          v25 += 3;
          v26 -= 6;
          if (!v26) {
            goto LABEL_35;
          }
        }
        CFDataRef v27 = (unsigned __int16 *)((char *)v9 + (bswap32(*v25) >> 16));
        unsigned int v28 = v27 + 2;
        BOOL v29 = (unint64_t)(v27 + 1) < v5 || (unint64_t)v28 > v7;
        if (!v29
          && ((uint64_t v30 = bswap32(v27[1]) >> 16,
               unint64_t v31 = (unint64_t)&v28[v30],
               (unint64_t)(v27 + 3) <= v7)
            ? (unint64_t v32 = (v7 - (unint64_t)v28) >> 1)
            : (unint64_t v32 = 0),
              v31 <= v7 ? (BOOL v33 = v31 >= (unint64_t)v28) : (BOOL v33 = 0),
              !v33 ? (BOOL v34 = v32 == v30) : (BOOL v34 = 1),
              v34))
        {
          unsigned int v35 = *v27;
          CFDataRef v36 = (const __CFData *)((char *)v27 + __rev16(v35));
          if ((unint64_t)v36 + 4 > v7 || v35 == 0) {
            CFDataRef v2 = 0;
          }
          else {
            CFDataRef v2 = v36;
          }
        }
        else
        {
LABEL_35:
          CFDataRef v2 = 0;
        }
        uint8x8_t v38 = (void **)v39;
        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100](&v38);
      }
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

unint64_t std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,PseudoFeature *,false>(unint64_t result, unsigned __int16 *a2, uint64_t a3, char a4)
{
  std::vector<unsigned int>::pointer v9 = (unsigned __int16 *)result;
  while (2)
  {
    unint64_t v10 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          std::vector<unsigned int>::pointer v9 = v10;
          uint64_t v11 = (char *)a2 - (char *)v10;
          unint64_t v12 = ((char *)a2 - (char *)v10) >> 3;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                unsigned int v66 = *(a2 - 4);
                unsigned int v67 = *v10;
                unsigned int v68 = v10[1];
                BOOL v5 = v66 == v67;
                BOOL v69 = v66 < v67;
                if (v5) {
                  BOOL v69 = *(a2 - 3) < v68;
                }
                if (v69)
                {
                  int v70 = *((_DWORD *)v10 + 1);
                  *(void *)unint64_t v10 = *((void *)a2 - 1);
                  *(a2 - 4) = v67;
                  *(a2 - 3) = v68;
                  *((_DWORD *)a2 - 1) = v70;
                }
                break;
              case 3uLL:
                CFDataRef result = (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,PseudoFeature *>(v10, v10 + 4, a2 - 4);
                break;
              case 4uLL:
                CFDataRef result = (unint64_t)std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,PseudoFeature *>(v10, v10 + 4, v10 + 8, a2 - 4);
                break;
              case 5uLL:
                CFDataRef result = (unint64_t)std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,PseudoFeature *>(v10, v10 + 4, v10 + 8, v10 + 12, a2 - 4);
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v11 <= 191)
          {
            uint64_t v71 = v10 + 4;
            BOOL v73 = v10 == a2 || v71 == a2;
            if (a4)
            {
              if (!v73)
              {
                uint64_t v74 = 0;
                unsigned int v75 = v10;
                do
                {
                  unsigned int v76 = v75[4];
                  unsigned int v77 = v75[5];
                  unsigned int v78 = *v75;
                  unsigned int v79 = v75[1];
                  unsigned int v75 = v71;
                  BOOL v80 = v77 < v79;
                  BOOL v5 = v76 == v78;
                  BOOL v81 = v76 < v78;
                  if (!v5) {
                    BOOL v80 = v81;
                  }
                  if (v80)
                  {
                    uint64_t v82 = *(void *)v75;
                    unsigned int v83 = (unsigned __int16)*(void *)v75;
                    uint64_t v84 = v74;
                    while (1)
                    {
                      CGRect v85 = (char *)v10 + v84;
                      *(void *)((char *)v10 + v84 + 8) = *(void *)((char *)v10 + v84);
                      if (!v84) {
                        break;
                      }
                      unsigned int v86 = *((unsigned __int16 *)v85 - 4);
                      BOOL v87 = *((unsigned __int16 *)v85 - 3) > WORD1(v82);
                      BOOL v5 = v86 == v83;
                      BOOL v88 = v86 > v83;
                      if (!v5) {
                        BOOL v87 = v88;
                      }
                      v84 -= 8;
                      if (!v87)
                      {
                        int v89 = (unsigned __int16 *)((char *)v10 + v84 + 8);
                        goto LABEL_112;
                      }
                    }
                    int v89 = v10;
LABEL_112:
                    *(void *)int v89 = v82;
                  }
                  uint64_t v71 = v75 + 4;
                  v74 += 8;
                }
                while (v75 + 4 != a2);
              }
            }
            else if (!v73)
            {
              do
              {
                unsigned int v134 = v9[4];
                unsigned int v135 = v9[5];
                unsigned int v136 = *v9;
                unsigned int v137 = v9[1];
                std::vector<unsigned int>::pointer v9 = v71;
                BOOL v138 = v135 < v137;
                BOOL v5 = v134 == v136;
                BOOL v139 = v134 < v136;
                if (v5) {
                  BOOL v139 = v138;
                }
                if (v139)
                {
                  uint64_t v140 = *(void *)v71;
                  unsigned int v141 = (unsigned __int16)*(void *)v71;
                  int v142 = v9;
                  do
                  {
                    v143 = v142;
                    uint64_t v144 = *((void *)v142 - 1);
                    v142 -= 4;
                    void *v143 = v144;
                    unsigned int v145 = *((unsigned __int16 *)v143 - 8);
                    BOOL v146 = *((unsigned __int16 *)v143 - 7) > WORD1(v140);
                    BOOL v5 = v145 == v141;
                    BOOL v147 = v145 > v141;
                    if (!v5) {
                      BOOL v146 = v147;
                    }
                  }
                  while (v146);
                  *(void *)int v142 = v140;
                }
                uint64_t v71 = v9 + 4;
              }
              while (v9 + 4 != a2);
            }
            return result;
          }
          if (!a3)
          {
            if (v10 != a2)
            {
              int64_t v90 = (v12 - 2) >> 1;
              int64_t v91 = v90;
              do
              {
                int64_t v92 = v91;
                if (v90 >= v91)
                {
                  uint64_t v93 = (2 * v91) | 1;
                  CFIndex v94 = &v10[4 * v93];
                  if (2 * v92 + 2 < (uint64_t)v12)
                  {
                    unsigned int v97 = *v94;
                    unsigned int v95 = v94[4];
                    BOOL v96 = v94[1] < v94[5];
                    if (v97 != v95) {
                      BOOL v96 = v97 < v95;
                    }
                    if (v96)
                    {
                      unsigned int v97 = v94[4];
                      v94 += 4;
                      uint64_t v93 = 2 * v92 + 2;
                    }
                  }
                  else
                  {
                    unsigned int v97 = *v94;
                  }
                  long long v98 = &v10[4 * v92];
                  unsigned int v99 = *v98;
                  BOOL v5 = v97 == v99;
                  BOOL v100 = v97 < v99;
                  if (v5) {
                    BOOL v100 = v94[1] < v10[4 * v92 + 1];
                  }
                  if (!v100)
                  {
                    uint64_t v101 = *(void *)v98;
                    do
                    {
                      unint64_t v102 = v94;
                      *(void *)long long v98 = *(void *)v94;
                      if (v90 < v93) {
                        break;
                      }
                      uint64_t v103 = (2 * v93) | 1;
                      CFIndex v94 = &v10[4 * v103];
                      uint64_t v93 = 2 * v93 + 2;
                      if (v93 < (uint64_t)v12)
                      {
                        unsigned int v106 = *v94;
                        unsigned int v104 = v94[4];
                        BOOL v105 = v94[1] < v94[5];
                        if (v106 != v104) {
                          BOOL v105 = v106 < v104;
                        }
                        if (v105)
                        {
                          unsigned int v106 = v94[4];
                          v94 += 4;
                        }
                        else
                        {
                          uint64_t v93 = v103;
                        }
                      }
                      else
                      {
                        unsigned int v106 = *v94;
                        uint64_t v93 = v103;
                      }
                      BOOL v5 = v106 == (unsigned __int16)v101;
                      BOOL v107 = v106 < (unsigned __int16)v101;
                      if (v5) {
                        BOOL v107 = v94[1] < WORD1(v101);
                      }
                      long long v98 = v102;
                    }
                    while (!v107);
                    *(void *)unint64_t v102 = v101;
                  }
                }
                int64_t v91 = v92 - 1;
              }
              while (v92);
              uint64_t v108 = (unint64_t)v11 >> 3;
              do
              {
                uint64_t v109 = 0;
                unsigned __int16 v110 = *v10;
                unsigned __int16 v111 = v10[1];
                int v112 = *((_DWORD *)v10 + 1);
                uint64_t v113 = v108 - 2;
                if (v108 < 2) {
                  uint64_t v113 = v108 - 1;
                }
                uint64_t v114 = v113 >> 1;
                uint64_t v115 = v10;
                do
                {
                  uint64_t v116 = &v115[4 * v109 + 4];
                  CFDataRef result = 2 * v109;
                  uint64_t v117 = (2 * v109) | 1;
                  uint64_t v118 = 2 * v109 + 2;
                  if (v118 < v108)
                  {
                    unsigned int v119 = *v116;
                    unsigned int v120 = v116[4];
                    BOOL v5 = v119 == v120;
                    LODWORD(result) = v119 < v120;
                    CFDataRef result = v5 ? v116[1] < v116[5] : result;
                    if (result)
                    {
                      v116 += 4;
                      uint64_t v117 = v118;
                    }
                  }
                  *(void *)uint64_t v115 = *(void *)v116;
                  uint64_t v115 = v116;
                  uint64_t v109 = v117;
                }
                while (v117 <= v114);
                if (v116 == a2 - 4)
                {
                  *uint64_t v116 = v110;
                  v116[1] = v111;
                  *((_DWORD *)v116 + 1) = v112;
                }
                else
                {
                  *(void *)uint64_t v116 = *((void *)a2 - 1);
                  *(a2 - 4) = v110;
                  *(a2 - 3) = v111;
                  *((_DWORD *)a2 - 1) = v112;
                  uint64_t v121 = (char *)v116 - (char *)v10 + 8;
                  if (v121 >= 9)
                  {
                    unint64_t v122 = (((unint64_t)v121 >> 3) - 2) >> 1;
                    BOOL v123 = &v10[4 * v122];
                    unsigned int v124 = *v123;
                    unsigned int v125 = *v116;
                    BOOL v5 = v124 == v125;
                    BOOL v126 = v124 < v125;
                    if (v5) {
                      BOOL v126 = v123[1] < v116[1];
                    }
                    if (v126)
                    {
                      uint64_t v127 = *(void *)v116;
                      unsigned int v128 = (unsigned __int16)*(void *)v116;
                      do
                      {
                        uint64_t v129 = v123;
                        *(void *)uint64_t v116 = *(void *)v123;
                        if (!v122) {
                          break;
                        }
                        unint64_t v122 = (v122 - 1) >> 1;
                        BOOL v123 = &v10[4 * v122];
                        unsigned int v130 = *v123;
                        BOOL v131 = v123[1] < WORD1(v127);
                        BOOL v5 = v130 == v128;
                        BOOL v132 = v130 < v128;
                        if (!v5) {
                          BOOL v131 = v132;
                        }
                        uint64_t v116 = v129;
                      }
                      while (v131);
                      *(void *)uint64_t v129 = v127;
                    }
                  }
                }
                a2 -= 4;
              }
              while (v108-- > 2);
            }
            return result;
          }
          unint64_t v13 = v12 >> 1;
          BOOL v14 = &v10[4 * (v12 >> 1)];
          if ((unint64_t)v11 >= 0x401)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,PseudoFeature *>(v9, &v9[4 * (v12 >> 1)], a2 - 4);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,PseudoFeature *>(v9 + 4, v14 - 4, a2 - 8);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,PseudoFeature *>(v9 + 8, &v9[4 * v13 + 4], a2 - 12);
            CFDataRef result = (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,PseudoFeature *>(v14 - 4, v14, &v9[4 * v13 + 4]);
            int v15 = *(_DWORD *)v9;
            int v16 = *((_DWORD *)v9 + 1);
            *(void *)std::vector<unsigned int>::pointer v9 = *(void *)v14;
            *(_DWORD *)BOOL v14 = v15;
            *((_DWORD *)v14 + 1) = v16;
          }
          else
          {
            CFDataRef result = (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,PseudoFeature *>(&v9[4 * (v12 >> 1)], v9, a2 - 4);
          }
          --a3;
          if (a4) {
            break;
          }
          unsigned int v17 = *(v9 - 4);
          unsigned int v18 = *v9;
          BOOL v5 = v17 == v18;
          BOOL v19 = v17 < v18;
          if (v5) {
            BOOL v19 = *(v9 - 3) < v9[1];
          }
          if (v19) {
            break;
          }
          uint64_t v43 = *(void *)v9;
          unsigned int v44 = (unsigned __int16)*(void *)v9;
          unsigned int v45 = WORD1(*(void *)v9);
          unsigned int v46 = *(a2 - 4);
          BOOL v5 = v46 == v44;
          BOOL v47 = v46 > v44;
          if (v5) {
            BOOL v47 = *(a2 - 3) > WORD1(*(void *)v9);
          }
          if (v47)
          {
            unint64_t v10 = v9;
            do
            {
              unsigned int v48 = v10[4];
              v10 += 4;
              BOOL v49 = v48 > v44;
              if (v48 == v44) {
                BOOL v49 = v10[1] > v45;
              }
            }
            while (!v49);
          }
          else
          {
            int v50 = v9 + 4;
            do
            {
              unint64_t v10 = v50;
              if (v50 >= a2) {
                break;
              }
              unsigned int v51 = *v50;
              BOOL v52 = v10[1] > v45;
              BOOL v5 = v51 == v44;
              BOOL v53 = v51 > v44;
              if (!v5) {
                BOOL v52 = v53;
              }
              int v50 = v10 + 4;
            }
            while (!v52);
          }
          CGFloat v54 = a2;
          if (v10 < a2)
          {
            CGFloat v54 = a2;
            do
            {
              unsigned int v55 = *(v54 - 4);
              v54 -= 4;
              BOOL v56 = v55 > v44;
              if (v55 == v44) {
                BOOL v56 = v54[1] > v45;
              }
            }
            while (v56);
          }
          if (v10 < v54)
          {
            unsigned __int16 v57 = *v10;
            do
            {
              unsigned __int16 v58 = v10[1];
              int v59 = *((_DWORD *)v10 + 1);
              *(void *)unint64_t v10 = *(void *)v54;
              *CGFloat v54 = v57;
              v54[1] = v58;
              *((_DWORD *)v54 + 1) = v59;
              do
              {
                unsigned int v60 = v10[4];
                v10 += 4;
                unsigned __int16 v57 = v60;
                BOOL v61 = v10[1] > v45;
                BOOL v62 = v60 > v44;
                if (v60 != v44) {
                  BOOL v61 = v62;
                }
              }
              while (!v61);
              do
              {
                unsigned int v63 = *(v54 - 4);
                v54 -= 4;
                BOOL v64 = v63 > v44;
                if (v63 == v44) {
                  BOOL v64 = v54[1] > v45;
                }
              }
              while (v64);
            }
            while (v10 < v54);
          }
          unint64_t v65 = v10 - 4;
          BOOL v4 = v10 - 4 >= v9;
          BOOL v5 = v10 - 4 == v9;
          if (v10 - 4 != v9) {
            *(void *)std::vector<unsigned int>::pointer v9 = *(void *)v65;
          }
          a4 = 0;
          *(void *)unint64_t v65 = v43;
        }
        uint64_t v20 = 0;
        uint64_t v21 = *(void *)v9;
        unsigned int v22 = (unsigned __int16)*(void *)v9;
        unsigned int v23 = WORD1(*(void *)v9);
        do
        {
          unsigned int v24 = v9[v20 + 4];
          BOOL v25 = v9[v20 + 5] < v23;
          if (v24 != v22) {
            BOOL v25 = v24 < v22;
          }
          v20 += 4;
        }
        while (v25);
        uint64_t v26 = &v9[v20];
        CFDataRef v27 = a2;
        if (v20 == 4)
        {
          CFDataRef v27 = a2;
          do
          {
            if (v26 >= v27) {
              break;
            }
            unsigned int v30 = *(v27 - 4);
            v27 -= 4;
            BOOL v31 = v30 < v22;
            if (v30 == v22) {
              BOOL v31 = v27[1] < v23;
            }
          }
          while (!v31);
        }
        else
        {
          do
          {
            unsigned int v28 = *(v27 - 4);
            v27 -= 4;
            BOOL v29 = v28 < v22;
            if (v28 == v22) {
              BOOL v29 = v27[1] < v23;
            }
          }
          while (!v29);
        }
        if (v26 >= v27)
        {
          unint64_t v41 = v26 - 4;
        }
        else
        {
          unint64_t v32 = v27;
          BOOL v33 = v26;
          do
          {
            unsigned __int16 v34 = v33[1];
            int v35 = *((_DWORD *)v33 + 1);
            *(void *)BOOL v33 = *(void *)v32;
            *unint64_t v32 = v24;
            v32[1] = v34;
            *((_DWORD *)v32 + 1) = v35;
            do
            {
              unsigned int v36 = v33[4];
              v33 += 4;
              LOWORD(v24) = v36;
              BOOL v37 = v33[1] < v23;
              BOOL v38 = v36 < v22;
              if (v36 != v22) {
                BOOL v37 = v38;
              }
            }
            while (v37);
            do
            {
              unsigned int v39 = *(v32 - 4);
              v32 -= 4;
              BOOL v40 = v39 < v22;
              if (v39 == v22) {
                BOOL v40 = v32[1] < v23;
              }
            }
            while (!v40);
          }
          while (v33 < v32);
          unint64_t v41 = v33 - 4;
        }
        if (v41 != v9) {
          *(void *)std::vector<unsigned int>::pointer v9 = *(void *)v41;
        }
        *(void *)unint64_t v41 = v21;
        if (v26 >= v27) {
          break;
        }
LABEL_45:
        CFDataRef result = std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,PseudoFeature *,false>(v9, v41, a3, a4 & 1);
        a4 = 0;
        unint64_t v10 = v41 + 4;
      }
      BOOL v42 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,PseudoFeature *>(v9, v41);
      unint64_t v10 = v41 + 4;
      CFDataRef result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,PseudoFeature *>(v41 + 4, a2);
      if (result) {
        break;
      }
      if (!v42) {
        goto LABEL_45;
      }
    }
    a2 = v41;
    if (!v42) {
      continue;
    }
    return result;
  }
}

unsigned __int16 *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,PseudoFeature *>(unsigned __int16 *result, unsigned __int16 *a2, unsigned __int16 *a3)
{
  unsigned int v3 = *a2;
  unsigned int v4 = a2[1];
  unsigned int v5 = *result;
  unsigned int v6 = result[1];
  BOOL v7 = v3 < v5;
  if (v3 == v5) {
    BOOL v7 = v4 < v6;
  }
  unsigned int v8 = *a3;
  BOOL v9 = v8 == v3;
  BOOL v10 = v8 < v3;
  if (v9) {
    BOOL v10 = a3[1] < v4;
  }
  if (v7)
  {
    int v11 = *((_DWORD *)result + 1);
    if (v10)
    {
      *(void *)CFDataRef result = *(void *)a3;
LABEL_17:
      *a3 = v5;
      a3[1] = v6;
      *((_DWORD *)a3 + 1) = v11;
      return result;
    }
    *(void *)CFDataRef result = *(void *)a2;
    *a2 = v5;
    a2[1] = v6;
    *((_DWORD *)a2 + 1) = v11;
    unsigned int v18 = *a3;
    BOOL v9 = v18 == v5;
    BOOL v19 = v18 < v5;
    if (v9) {
      BOOL v19 = a3[1] < v6;
    }
    if (v19)
    {
      *(void *)a2 = *(void *)a3;
      goto LABEL_17;
    }
  }
  else if (v10)
  {
    int v12 = *((_DWORD *)a2 + 1);
    *(void *)a2 = *(void *)a3;
    *a3 = v3;
    a3[1] = v4;
    *((_DWORD *)a3 + 1) = v12;
    unsigned int v13 = *a2;
    unsigned int v14 = *result;
    unsigned int v15 = result[1];
    BOOL v9 = v13 == v14;
    BOOL v16 = v13 < v14;
    if (v9) {
      BOOL v16 = a2[1] < v15;
    }
    if (v16)
    {
      int v17 = *((_DWORD *)result + 1);
      *(void *)CFDataRef result = *(void *)a2;
      *a2 = v14;
      a2[1] = v15;
      *((_DWORD *)a2 + 1) = v17;
    }
  }
  return result;
}

void MergeOTFeaturesFromTable<std::vector<unsigned int>>(std::vector<unsigned int> *a1, TBaseFont *this, uint64_t a3)
{
  CFDataRef CommonTable = (const __CFData *)TBaseFont::GetCommonTable(this, a3, 0);
  if (CommonTable)
  {
    CFDataRef v5 = CommonTable;
    BytePtr = CFDataGetBytePtr(CommonTable);
    if (BytePtr)
    {
      BOOL v7 = BytePtr;
      unsigned int v8 = CFDataGetBytePtr(v5);
      if (v8)
      {
        unint64_t v9 = (unint64_t)&v8[CFDataGetLength(v5)];
        if ((unint64_t)(v7 + 10) <= v9
          && bswap32(*(unsigned __int16 *)v7) >> 16 <= 1
          && (!*((_WORD *)v7 + 1) || (unint64_t)(v7 + 14) <= v9))
        {
          if (*((_WORD *)v7 + 3))
          {
            BOOL v10 = &v7[__rev16(*((unsigned __int16 *)v7 + 3))];
            int v11 = (unsigned int *)(v10 + 2);
            if ((unint64_t)(v10 + 2) <= v9)
            {
              unsigned int v12 = *(unsigned __int16 *)v10;
              uint64_t v13 = __rev16(v12);
              unsigned int v14 = (char *)v11 + 6 * v13;
              BOOL v15 = v14 < (char *)v11 || (unint64_t)v14 > v9;
              if (!v15
                || ((unint64_t)(v10 + 8) <= v9 ? (unint64_t v16 = (v9 - (unint64_t)v11) / 6) : (unint64_t v16 = 0),
                    v16 == v13))
              {
                uint64_t v17 = (char *)a1->__end_ - (char *)a1->__begin_;
                std::vector<unsigned int>::reserve(a1, v13 + (v17 >> 2));
                std::vector<unsigned int>::pointer end = a1->__end_;
                if (v12)
                {
                  BOOL v19 = (unsigned int *)((char *)v11 + 6 * v13);
                  p_end_cap = &a1->__end_cap_;
                  do
                  {
                    unsigned int v21 = bswap32(*v11);
                    if (end >= p_end_cap->__value_)
                    {
                      begiCFIndex n = a1->__begin_;
                      uint64_t v24 = end - a1->__begin_;
                      unint64_t v25 = v24 + 1;
                      if ((unint64_t)(v24 + 1) >> 62) {
                        abort();
                      }
                      uint64_t v26 = (char *)p_end_cap->__value_ - (char *)begin;
                      if (v26 >> 1 > v25) {
                        unint64_t v25 = v26 >> 1;
                      }
                      if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFFCLL) {
                        unint64_t v27 = 0x3FFFFFFFFFFFFFFFLL;
                      }
                      else {
                        unint64_t v27 = v25;
                      }
                      if (v27)
                      {
                        unsigned int v28 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>((uint64_t)&a1->__end_cap_, v27);
                        begiCFIndex n = a1->__begin_;
                        std::vector<unsigned int>::pointer end = a1->__end_;
                      }
                      else
                      {
                        unsigned int v28 = 0;
                      }
                      BOOL v29 = (unsigned int *)&v28[4 * v24];
                      *BOOL v29 = v21;
                      unsigned int v22 = (char *)(v29 + 1);
                      while (end != begin)
                      {
                        unsigned int v30 = *--end;
                        *--BOOL v29 = v30;
                      }
                      a1->__begin_ = v29;
                      a1->__end_ = (std::vector<unsigned int>::pointer)v22;
                      a1->__end_cap_.__value_ = (unsigned int *)&v28[4 * v27];
                      if (begin) {
                        operator delete(begin);
                      }
                    }
                    else
                    {
                      *std::vector<unsigned int>::pointer end = v21;
                      unsigned int v22 = (char *)(end + 1);
                    }
                    a1->__end_ = (std::vector<unsigned int>::pointer)v22;
                    int v11 = (unsigned int *)((char *)v11 + 6);
                    std::vector<unsigned int>::pointer end = (std::vector<unsigned int>::pointer)v22;
                  }
                  while (v11 != v19);
                }
                else
                {
                  unsigned int v22 = (char *)a1->__end_;
                }
                BOOL v31 = (char *)a1->__begin_;
                std::__sort<std::__less<unsigned int,unsigned int> &,unsigned int *>();
                std::__inplace_merge[abi:nn180100]<std::_ClassicAlgPolicy,std::__wrap_iter<unsigned int *>,std::__less<void,void> &>(v31, &v31[4 * (v17 >> 2)], v22);
              }
            }
          }
        }
      }
    }
  }
}

void std::__inplace_merge[abi:nn180100]<std::_ClassicAlgPolicy,std::__wrap_iter<unsigned int *>,std::__less<void,void> &>(char *a1, char *a2, char *a3)
{
  uint64_t v6 = (a2 - a1) >> 2;
  uint64_t v7 = (a3 - a2) >> 2;
  if (v7 >= v6) {
    uint64_t v8 = (a2 - a1) >> 2;
  }
  else {
    uint64_t v8 = (a3 - a2) >> 2;
  }
  if (v8 < 1)
  {
LABEL_8:
    std::__inplace_merge<std::_ClassicAlgPolicy,std::__less<void,void> &,std::__wrap_iter<unsigned int *>>(a1, a2, a3, v6, v7, 0, 0);
  }
  else
  {
    unint64_t v9 = (const std::nothrow_t *)MEMORY[0x1E4FBA2D0];
    while (1)
    {
      BOOL v10 = operator new(4 * v8, v9);
      if (v10) {
        break;
      }
      BOOL v11 = (unint64_t)v8 > 1;
      uint64_t v8 = (unint64_t)v8 >> 1;
      if (!v11) {
        goto LABEL_8;
      }
    }
    unsigned int v12 = v10;
    std::__inplace_merge<std::_ClassicAlgPolicy,std::__less<void,void> &,std::__wrap_iter<unsigned int *>>(a1, a2, a3, v6, v7, v10, v8);
    operator delete(v12);
  }
}

char *std::__inplace_merge<std::_ClassicAlgPolicy,std::__less<void,void> &,std::__wrap_iter<unsigned int *>>(char *result, char *a2, char *a3, uint64_t a4, uint64_t a5, _DWORD *a6, uint64_t a7)
{
  if (a5)
  {
    uint64_t v7 = a5;
    BOOL v11 = result;
    while (a4 > a7 && v7 > a7)
    {
      if (!a4) {
        return result;
      }
      uint64_t v12 = 0;
      unsigned int v13 = *(_DWORD *)a2;
      uint64_t v14 = -a4;
      while (1)
      {
        unsigned int v15 = *(_DWORD *)&v11[v12];
        if (v13 < v15) {
          break;
        }
        v12 += 4;
        BOOL v73 = __CFADD__(v14++, 1);
        if (v73) {
          return result;
        }
      }
      unint64_t v16 = &v11[v12];
      if (-v14 >= v7)
      {
        if (v14 == -1)
        {
          *(_DWORD *)&v11[v12] = v13;
          *(_DWORD *)a2 = v15;
          return result;
        }
        if (v14 <= 0) {
          uint64_t v27 = -v14;
        }
        else {
          uint64_t v27 = 1 - v14;
        }
        uint64_t v26 = v27 >> 1;
        uint64_t v20 = &v11[4 * (v27 >> 1) + v12];
        BOOL v19 = a2;
        if (a2 != a3)
        {
          unint64_t v28 = (a3 - a2) >> 2;
          BOOL v19 = a2;
          do
          {
            unint64_t v29 = v28 >> 1;
            unsigned int v30 = &v19[4 * (v28 >> 1)];
            unsigned int v32 = *(_DWORD *)v30;
            BOOL v31 = v30 + 4;
            v28 += ~(v28 >> 1);
            if (v32 < *(_DWORD *)v20) {
              BOOL v19 = v31;
            }
            else {
              unint64_t v28 = v29;
            }
          }
          while (v28);
        }
        uint64_t v18 = (v19 - a2) >> 2;
      }
      else
      {
        if (v7 >= 0) {
          uint64_t v17 = v7;
        }
        else {
          uint64_t v17 = v7 + 1;
        }
        uint64_t v18 = v17 >> 1;
        BOOL v19 = &a2[4 * (v17 >> 1)];
        uint64_t v20 = a2;
        if (a2 - v11 != v12)
        {
          unint64_t v21 = (a2 - v11 - v12) >> 2;
          uint64_t v20 = &v11[v12];
          do
          {
            unint64_t v22 = v21 >> 1;
            unsigned int v23 = &v20[4 * (v21 >> 1)];
            unsigned int v25 = *(_DWORD *)v23;
            uint64_t v24 = v23 + 4;
            v21 += ~(v21 >> 1);
            if (*(_DWORD *)v19 < v25) {
              unint64_t v21 = v22;
            }
            else {
              uint64_t v20 = v24;
            }
          }
          while (v21);
        }
        uint64_t v26 = (v20 - v11 - v12) >> 2;
      }
      if (v20 == a2)
      {
        a2 = v19;
      }
      else
      {
        uint64_t v33 = v19 - a2;
        if (v19 == a2)
        {
          a2 = v20;
        }
        else
        {
          unsigned __int16 v34 = v20 + 4;
          if (v20 + 4 == a2)
          {
            int v79 = *(_DWORD *)v20;
            CGRect v85 = a6;
            uint64_t v87 = a7;
            unsigned int v39 = a3;
            uint64_t v81 = v18;
            uint64_t v83 = v26;
            memmove(v20, a2, v19 - a2);
            uint64_t v18 = v81;
            uint64_t v26 = v83;
            unint64_t v16 = &v11[v12];
            a6 = v85;
            a7 = v87;
            a3 = v39;
            a2 = &v20[v33];
            *(_DWORD *)&v20[v33] = v79;
          }
          else
          {
            int v35 = a2 + 4;
            if (a2 + 4 == v19)
            {
              int v40 = *((_DWORD *)v19 - 1);
              a2 = v20 + 4;
              if (v19 - 4 != v20)
              {
                unsigned int v86 = a6;
                uint64_t v88 = a7;
                unint64_t v41 = a3;
                uint64_t v82 = v18;
                uint64_t v84 = v26;
                int v80 = *((_DWORD *)v19 - 1);
                memmove(v20 + 4, v20, v19 - 4 - v20);
                int v40 = v80;
                uint64_t v18 = v82;
                uint64_t v26 = v84;
                unint64_t v16 = &v11[v12];
                a6 = v86;
                a7 = v88;
                a3 = v41;
              }
              *(_DWORD *)uint64_t v20 = v40;
            }
            else
            {
              uint64_t v36 = (a2 - v20) >> 2;
              if (v36 == v33 >> 2)
              {
                do
                {
                  int v37 = *((_DWORD *)v34 - 1);
                  *((_DWORD *)v34 - 1) = *((_DWORD *)v35 - 1);
                  *((_DWORD *)v35 - 1) = v37;
                  if (v34 == a2) {
                    break;
                  }
                  v34 += 4;
                  BOOL v38 = v35 == v19;
                  v35 += 4;
                }
                while (!v38);
              }
              else
              {
                uint64_t v42 = v33 >> 2;
                uint64_t v43 = (a2 - v20) >> 2;
                do
                {
                  uint64_t v44 = v43;
                  uint64_t v43 = v42;
                  uint64_t v42 = v44 % v42;
                }
                while (v42);
                if (v43)
                {
                  unsigned int v45 = &v20[4 * v43];
                  do
                  {
                    int v47 = *((_DWORD *)v45 - 1);
                    v45 -= 4;
                    int v46 = v47;
                    unsigned int v48 = &v45[4 * v36];
                    BOOL v49 = v45;
                    do
                    {
                      int v50 = v48;
                      *(_DWORD *)BOOL v49 = *(_DWORD *)v48;
                      unsigned int v51 = &v48[4 * v36];
                      BOOL v52 = __OFSUB__(v36, (v19 - v48) >> 2);
                      uint64_t v54 = v36 - ((v19 - v48) >> 2);
                      char v53 = (v54 < 0) ^ v52;
                      unsigned int v48 = &v20[4 * v54];
                      if (v53) {
                        unsigned int v48 = v51;
                      }
                      BOOL v49 = v50;
                    }
                    while (v48 != v45);
                    *(_DWORD *)int v50 = v46;
                  }
                  while (v45 != v20);
                }
                a2 = &v20[4 * (v33 >> 2)];
              }
            }
          }
        }
      }
      a4 = -(v26 + v14);
      uint64_t v55 = v7 - v18;
      if (v26 + v18 >= v7 - (v26 + v18) - v14)
      {
        BOOL v61 = a2;
        BOOL v62 = v19;
        uint64_t v63 = v26;
        uint64_t v64 = -(v26 + v14);
        uint64_t v65 = v18;
        uint64_t v66 = v7 - v18;
        unsigned __int16 v57 = a6;
        uint64_t v58 = a7;
        unsigned int v67 = v16;
        CFDataRef result = (char *)std::__inplace_merge<std::_ClassicAlgPolicy,std::__less<void,void> &,std::__wrap_iter<unsigned int *>>(a2, v62, a3, v64, v66);
        unsigned int v60 = v67;
        a2 = v20;
        uint64_t v55 = v65;
        a4 = v63;
        a3 = v61;
      }
      else
      {
        BOOL v56 = &v11[v12];
        unsigned __int16 v57 = a6;
        uint64_t v58 = a7;
        int v59 = a3;
        CFDataRef result = (char *)std::__inplace_merge<std::_ClassicAlgPolicy,std::__less<void,void> &,std::__wrap_iter<unsigned int *>>(v56, v20, a2, v26, v18);
        a3 = v59;
        unsigned int v60 = a2;
        a2 = v19;
      }
      uint64_t v7 = v55;
      BOOL v11 = v60;
      a6 = v57;
      a7 = v58;
      if (!v55) {
        return result;
      }
    }
    if (a4 <= v7)
    {
      if (v11 != a2)
      {
        unint64_t v74 = 0;
        do
        {
          a6[v74 / 4] = *(_DWORD *)&v11[v74];
          v74 += 4;
        }
        while (&v11[v74] != a2);
        if (v74)
        {
          unsigned int v75 = a6;
          while (a2 != a3)
          {
            unsigned int v76 = *(_DWORD *)a2;
            BOOL v77 = *(_DWORD *)a2 >= *v75;
            if (*(_DWORD *)a2 >= *v75) {
              unsigned int v76 = *v75;
            }
            a2 += 4 * (*(_DWORD *)a2 < *v75);
            v75 += v77;
            *(_DWORD *)BOOL v11 = v76;
            v11 += 4;
            if (&a6[v74 / 4] == v75) {
              return result;
            }
          }
          return (char *)memmove(v11, v75, (char *)a6 - (char *)v75 + v74);
        }
      }
    }
    else if (a3 != a2)
    {
      uint64_t v68 = 0;
      do
      {
        a6[v68] = *(_DWORD *)&a2[v68 * 4];
        ++v68;
      }
      while (&a2[v68 * 4] != a3);
      if (v68 * 4)
      {
        BOOL v69 = &a6[v68];
        int v70 = a3 - 4;
        while (a2 != v11)
        {
          unsigned int v71 = *(v69 - 1);
          unsigned int v72 = *((_DWORD *)a2 - 1);
          BOOL v73 = v71 >= v72;
          if (v71 <= v72) {
            unsigned int v71 = *((_DWORD *)a2 - 1);
          }
          if (v73) {
            --v69;
          }
          else {
            a2 -= 4;
          }
          *(_DWORD *)int v70 = v71;
          v70 -= 4;
          if (v69 == a6) {
            return result;
          }
        }
        uint64_t v78 = 0;
        do
        {
          *(_DWORD *)&v70[v78 * 4] = v69[v78 - 1];
          --v78;
        }
        while (&v69[v78] != a6);
      }
    }
  }
  return result;
}

void std::vector<unsigned int>::reserve(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __n)
{
  value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  if (__n > value - this->__begin_)
  {
    if (__n >> 62) {
      abort();
    }
    int64_t v5 = (char *)this->__end_ - (char *)this->__begin_;
    uint64_t v6 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>((uint64_t)p_end_cap, __n);
    uint64_t v7 = (unsigned int *)&v6[v5 & 0xFFFFFFFFFFFFFFFCLL];
    unint64_t v9 = (unsigned int *)&v6[4 * v8];
    begiCFIndex n = this->__begin_;
    std::vector<unsigned int>::pointer end = this->__end_;
    uint64_t v12 = v7;
    if (end != this->__begin_)
    {
      uint64_t v12 = v7;
      do
      {
        unsigned int v13 = *--end;
        *--uint64_t v12 = v13;
      }
      while (end != begin);
    }
    this->__begin_ = v12;
    this->__end_ = v7;
    this->__end_cap_.__value_ = v9;
    if (begin)
    {
      operator delete(begin);
    }
  }
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(4 * a2);
}

unsigned __int16 *std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,PseudoFeature *>(unsigned __int16 *a1, unsigned __int16 *a2, unsigned __int16 *a3, unsigned __int16 *a4)
{
  CFDataRef result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,PseudoFeature *>(a1, a2, a3);
  unsigned int v9 = *a4;
  unsigned int v10 = *a3;
  unsigned int v11 = a3[1];
  BOOL v12 = v9 == v10;
  BOOL v13 = v9 < v10;
  if (v12) {
    BOOL v13 = a4[1] < v11;
  }
  if (v13)
  {
    int v14 = *((_DWORD *)a3 + 1);
    *(void *)a3 = *(void *)a4;
    *a4 = v10;
    a4[1] = v11;
    *((_DWORD *)a4 + 1) = v14;
    unsigned int v15 = *a3;
    unsigned int v16 = *a2;
    unsigned int v17 = a2[1];
    BOOL v12 = v15 == v16;
    BOOL v18 = v15 < v16;
    if (v12) {
      BOOL v18 = a3[1] < v17;
    }
    if (v18)
    {
      int v19 = *((_DWORD *)a2 + 1);
      *(void *)a2 = *(void *)a3;
      *a3 = v16;
      a3[1] = v17;
      *((_DWORD *)a3 + 1) = v19;
      unsigned int v20 = *a2;
      unsigned int v21 = *a1;
      unsigned int v22 = a1[1];
      BOOL v12 = v20 == v21;
      BOOL v23 = v20 < v21;
      if (v12) {
        BOOL v23 = a2[1] < v22;
      }
      if (v23)
      {
        int v24 = *((_DWORD *)a1 + 1);
        *(void *)a1 = *(void *)a2;
        *a2 = v21;
        a2[1] = v22;
        *((_DWORD *)a2 + 1) = v24;
      }
    }
  }
  return result;
}

void *IsOTFeatureTurnedOnByShapingEngine(unsigned int)::$_0::__invoke()
{
  for (uint64_t i = 0; i != 1980; i += 12)
  {
    if (*(_DWORD *)((char *)&kMasterFeatureMap + i + 8) == 14) {
      CFDataRef result = std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>((uint64_t)&xmmword_1EB2CE578, (unsigned int *)((char *)&kMasterFeatureMap + i), (uint64_t *)((char *)&kMasterFeatureMap + i));
    }
  }
  return result;
}

void *std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>(uint64_t a1, unsigned int *a2, _DWORD *a3)
{
  unint64_t v5 = *a2;
  unint64_t v6 = *(void *)(a1 + 8);
  if (v6)
  {
    uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      unint64_t v8 = *a2;
      if (v6 <= v5) {
        unint64_t v8 = v5 % v6;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & v5;
    }
    unsigned int v9 = *(void ***)(*(void *)a1 + 8 * v8);
    if (v9)
    {
      unsigned int v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == v5)
          {
            if (*((_DWORD *)v10 + 4) == v5) {
              return v10;
            }
          }
          else
          {
            if (v7.u32[0] > 1uLL)
            {
              if (v11 >= v6) {
                v11 %= v6;
              }
            }
            else
            {
              v11 &= v6 - 1;
            }
            if (v11 != v8) {
              break;
            }
          }
          unsigned int v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  else
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAAALL;
  }
  unsigned int v10 = operator new(0x18uLL);
  *unsigned int v10 = 0;
  v10[1] = v5;
  *((_DWORD *)v10 + 4) = *a3;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v13 = *(float *)(a1 + 32);
  if (!v6 || (float)(v13 * (float)v6) < v12)
  {
    BOOL v14 = 1;
    if (v6 >= 3) {
      BOOL v14 = (v6 & (v6 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v6);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<std::__hash_value_type<unsigned int,OTL::Lookup>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,OTL::Lookup>>>::__rehash<true>(a1, v17);
    unint64_t v6 = *(void *)(a1 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v6 <= v5) {
        unint64_t v8 = v5 % v6;
      }
      else {
        unint64_t v8 = v5;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & v5;
    }
  }
  uint64_t v18 = *(void *)a1;
  int v19 = *(void **)(*(void *)a1 + 8 * v8);
  if (v19)
  {
    *unsigned int v10 = *v19;
LABEL_38:
    *int v19 = v10;
    goto LABEL_39;
  }
  *unsigned int v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v8) = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v20 >= v6) {
        v20 %= v6;
      }
    }
    else
    {
      v20 &= v6 - 1;
    }
    int v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v10;
}

void FallbackForLangSysTag(unsigned int)::$_0::__invoke()
{
  uint64_t v0 = kLanguageToLangSysMappings;
  unint64_t v1 = &kLanguageToLangSysMappings[8];
  int v2 = 1633776160;
  do
  {
    unsigned int v3 = (unsigned int *)v0;
    uint64_t v0 = v1;
    int v4 = v2;
    int v2 = v3[2];
    if (v2 != v4) {
      goto LABEL_42;
    }
    unint64_t v5 = v3[1];
    unsigned int v6 = v3[3];
    unint64_t v7 = *((void *)&xmmword_1EB2CE528 + 1);
    if (*((void *)&xmmword_1EB2CE528 + 1))
    {
      uint8x8_t v8 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&xmmword_1EB2CE528 + 8));
      v8.i16[0] = vaddlv_u8(v8);
      if (v8.u32[0] > 1uLL)
      {
        unint64_t v9 = v3[1];
        if (*((void *)&xmmword_1EB2CE528 + 1) <= v5) {
          unint64_t v9 = v5 % *((void *)&xmmword_1EB2CE528 + 1);
        }
      }
      else
      {
        unint64_t v9 = (DWORD2(xmmword_1EB2CE528) - 1) & v5;
      }
      unsigned int v10 = *(uint64_t ***)(xmmword_1EB2CE528 + 8 * v9);
      if (v10)
      {
        for (uint64_t i = *v10; i; uint64_t i = (uint64_t *)*i)
        {
          unint64_t v12 = i[1];
          if (v12 == v5)
          {
            if (*((_DWORD *)i + 4) == v5) {
              goto LABEL_42;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v12 >= *((void *)&xmmword_1EB2CE528 + 1)) {
                v12 %= *((void *)&xmmword_1EB2CE528 + 1);
              }
            }
            else
            {
              v12 &= *((void *)&xmmword_1EB2CE528 + 1) - 1;
            }
            if (v12 != v9) {
              break;
            }
          }
        }
      }
    }
    else
    {
      unint64_t v9 = 0xAAAAAAAAAAAAAAAALL;
    }
    float v13 = operator new(0x18uLL);
    *float v13 = 0;
    v13[1] = v5;
    *((_DWORD *)v13 + 4) = v5;
    *((_DWORD *)v13 + 5) = v6;
    float v14 = (float)(unint64_t)(qword_1EB2CE540 + 1);
    if (!v7 || (float)(*(float *)&dword_1EB2CE548 * (float)v7) < v14)
    {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
      if (v7 < 3) {
        BOOL v15 = 1;
      }
      unint64_t v16 = v15 | (2 * v7);
      unint64_t v17 = vcvtps_u32_f32(v14 / *(float *)&dword_1EB2CE548);
      if (v16 <= v17) {
        size_t v18 = v17;
      }
      else {
        size_t v18 = v16;
      }
      std::__hash_table<std::__hash_value_type<unsigned int,OTL::Lookup>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,OTL::Lookup>>>::__rehash<true>((uint64_t)&xmmword_1EB2CE528, v18);
      unint64_t v7 = *((void *)&xmmword_1EB2CE528 + 1);
      if ((v7 & (v7 - 1)) != 0)
      {
        if (*((void *)&xmmword_1EB2CE528 + 1) <= v5) {
          unint64_t v9 = v5 % *((void *)&xmmword_1EB2CE528 + 1);
        }
        else {
          unint64_t v9 = v5;
        }
      }
      else
      {
        unint64_t v9 = (DWORD2(xmmword_1EB2CE528) - 1) & v5;
      }
    }
    uint64_t v19 = xmmword_1EB2CE528;
    unint64_t v20 = *(void **)(xmmword_1EB2CE528 + 8 * v9);
    if (v20)
    {
      *float v13 = *v20;
LABEL_40:
      void *v20 = v13;
      goto LABEL_41;
    }
    *float v13 = qword_1EB2CE538;
    qword_1EB2CE538 = (uint64_t)v13;
    *(void *)(v19 + 8 * v9) = &qword_1EB2CE538;
    if (*v13)
    {
      unint64_t v21 = *(void *)(*v13 + 8);
      if ((v7 & (v7 - 1)) != 0)
      {
        if (v21 >= v7) {
          v21 %= v7;
        }
      }
      else
      {
        v21 &= v7 - 1;
      }
      unint64_t v20 = (void *)(xmmword_1EB2CE528 + 8 * v21);
      goto LABEL_40;
    }
LABEL_41:
    ++qword_1EB2CE540;
LABEL_42:
    unint64_t v1 = (char *)(v0 + 8);
  }
  while (v0 + 8 != (const char *)&kMasterFeatureMap);
}

void std::__hash_table<std::__hash_value_type<unsigned int,OTL::Lookup>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,OTL::Lookup>>>::__rehash<true>(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2;
  }
  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }
  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(void *)&v4) {
    goto LABEL_16;
  }
  if (prime < *(void *)&v4)
  {
    unint64_t v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      unint64_t v5 = std::__next_prime(v5);
    }
    else
    {
      uint64_t v7 = 1 << -(char)__clz(v5 - 1);
      if (v5 >= 2) {
        unint64_t v5 = v7;
      }
    }
    if (prime <= v5) {
      size_t prime = v5;
    }
    if (prime < *(void *)&v4)
    {
LABEL_16:
      std::__hash_table<std::__hash_value_type<unsigned int,OTL::Lookup>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,OTL::Lookup>>>::__do_rehash<true>(a1, prime);
    }
  }
}

void std::__hash_table<std::__hash_value_type<unsigned int,OTL::Lookup>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,OTL::Lookup>>>::__do_rehash<true>(uint64_t a1, unint64_t a2)
{
  if (a2)
  {
    if (a2 >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    int8x8_t v4 = operator new(8 * a2);
    unint64_t v5 = *(void **)a1;
    *(void *)a1 = v4;
    if (v5) {
      operator delete(v5);
    }
    uint64_t v6 = 0;
    *(void *)(a1 + 8) = a2;
    do
      *(void *)(*(void *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    uint64_t v7 = *(void **)(a1 + 16);
    if (v7)
    {
      unint64_t v8 = v7[1];
      uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2) {
          v8 %= a2;
        }
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v8) = a1 + 16;
      unint64_t v11 = (void *)*v7;
      if (*v7)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= a2) {
              v12 %= a2;
            }
          }
          else
          {
            v12 &= a2 - 1;
          }
          if (v12 != v8)
          {
            if (!*(void *)(*(void *)a1 + 8 * v12))
            {
              *(void *)(*(void *)a1 + 8 * v12) = v7;
              goto LABEL_24;
            }
            *uint64_t v7 = *v11;
            *unint64_t v11 = **(void **)(*(void *)a1 + 8 * v12);
            **(void **)(*(void *)a1 + 8 * v12) = v11;
            unint64_t v11 = v7;
          }
          unint64_t v12 = v8;
LABEL_24:
          uint64_t v7 = v11;
          unint64_t v11 = (void *)*v11;
          unint64_t v8 = v12;
        }
        while (v11);
      }
    }
  }
  else
  {
    unsigned int v10 = *(void **)a1;
    *(void *)a1 = 0;
    if (v10) {
      operator delete(v10);
    }
    *(void *)(a1 + 8) = 0;
  }
}

CFTypeID CTFontGetTypeID(void)
{
  if (TCFBase<TFont>::GetTypeID(void)::once != -1) {
    dispatch_once_f(&TCFBase<TFont>::GetTypeID(void)::once, 0, (dispatch_function_t)TCFBase<TFont>::GetTypeID(void)::{lambda(void *)#1}::__invoke);
  }
  return TCFBase<TFont>::fTypeID;
}

double CTLineGetWidthForStringRangeWithOffset(uint64_t a1, CFIndex a2, CFIndex a3, double a4)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  double v4 = 0.0;
  if (a1)
  {
    unint64_t v5 = *(const TLine ***)(a1 + 40);
    CFIndex v6 = (CFIndex)v5[9];
    CFIndex v7 = (CFIndex)v5[10] + v6;
    CFIndex v8 = v7 - a2;
    if (a3) {
      CFIndex v8 = a3;
    }
    if ((v8 & 0x8000000000000000) == 0 && a2 >= v6 && v8 + a2 <= v7)
    {
      *(_OWORD *)&v17[80] = unk_184B88CA0;
      *(_OWORD *)&v17[96] = xmmword_184B88CB0;
      long long v19 = unk_184B88D00;
      *(_OWORD *)size_t v18 = xmmword_184B88CD0;
      memset(&v18[16], 170, 32);
      if (v7 <= a2) {
        v10.length = 0;
      }
      else {
        v10.length = v8;
      }
      if (v7 <= a2) {
        v10.locatioCFIndex n = 0;
      }
      else {
        v10.locatioCFIndex n = a2;
      }
      *(_OWORD *)&v17[112] = unk_184B88CC0;
      memset(v17, 170, 80);
      unint64_t v12 = *v5;
      unint64_t v11 = v5[1];
      float v13 = *v5;
      if (v11)
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)v11 + 1, 1uLL, memory_order_relaxed);
        float v13 = *v5;
      }
      *(void *)unint64_t v17 = v12;
      *(void *)&v17[8] = v11;
      memset(&v17[16], 0, 24);
      *(void *)&v17[64] = &v17[40];
      BYTE8(v19) = 0;
      memset(&v17[72], 0, 56);
      memset(&v18[8], 0, 21);
      *(void *)&v18[32] = 0;
      *(void *)&v18[40] = 0;
      LOBYTE(v19) = 0;
      uint64_t v21 = 0;
      uint64_t v22 = 0;
      uint64_t v20 = 0;
      *(void *)size_t v18 = 0xFFEFFFFFFFFFFFFFLL;
      v15[0] = (const TLine *)v5;
      v15[1] = v13;
      v15[2] = 0;
      v15[3] = 0;
      v16[0] = 0;
      *(void *)((char *)v16 + 6) = 0;
      v16[2] = 0;
      TTypesetter::FillLine(v15, (TLine *)v17, v10, 1.79769313e308, a4);
      double v4 = *(double *)&v17[104];
      TLine::~TLine((TLine *)v17);
    }
  }
  return v4;
}

__CFString *TDescriptorSource::GetNameForSystemFontOfWeight(__CFString *this, const __CFString *a2, double a3, int a4, void *a5, const __CFString **a6)
{
  int v8 = (int)a2;
  unsigned int v11 = IndexesBracketing<double const*,double>(kCTFontDefaultWeights, (double *)&kCTFontWeightRegular, a3, 0.001);
  if (@"NSCTFontUIFontDesignDefault" == this
    || this && @"NSCTFontUIFontDesignDefault" && CFEqual(this, @"NSCTFontUIFontDesignDefault"))
  {
    unint64_t v12 = off_1E528B858;
    float v13 = off_1E528B8A0;
    goto LABEL_6;
  }
  if (@"NSCTFontUIFontDesignRounded" == this
    || this && @"NSCTFontUIFontDesignRounded" && CFEqual(this, @"NSCTFontUIFontDesignRounded"))
  {
    unint64_t v12 = kSystemUIFontRoundNames;
    goto LABEL_27;
  }
  if (@"NSCTFontUIFontDesignCompactRounded" == this
    || this && @"NSCTFontUIFontDesignCompactRounded" && CFEqual(this, @"NSCTFontUIFontDesignCompactRounded"))
  {
    unint64_t v12 = kSystemUIFontCompactRoundNames;
    goto LABEL_27;
  }
  if (@"NSCTFontUIFontDesignSerif" == this
    || this && @"NSCTFontUIFontDesignSerif" && CFEqual(this, @"NSCTFontUIFontDesignSerif"))
  {
    unsigned int v11 = IndexesBracketing<double const*,double>(&kCTFontDefaultWeights[3], (double *)&kCTFontWeightRegular, a3, 0.001);
    uint64_t v14 = 6;
    if (!a4) {
      uint64_t v14 = 0;
    }
    BOOL v15 = kSystemUIFontSerifNames;
LABEL_26:
    unint64_t v12 = &v15[v14];
    goto LABEL_27;
  }
  if (@"NSCTFontUIFontDesignCompact" == this
    || this && @"NSCTFontUIFontDesignCompact" && CFEqual(this, @"NSCTFontUIFontDesignCompact"))
  {
    unint64_t v12 = off_1E528B8E8;
    float v13 = off_1E528B930;
    goto LABEL_6;
  }
  if (@"NSCTFontUIFontDesignCore" == this
    || this && @"NSCTFontUIFontDesignCore" && CFEqual(this, @"NSCTFontUIFontDesignCore"))
  {
    unint64_t v12 = off_1E528B978;
    float v13 = off_1E528B9C0;
LABEL_6:
    if (a4) {
      unint64_t v12 = v13;
    }
    goto LABEL_27;
  }
  if (@"NSCTFontUIFontDesignMonospaced" == this
    || this && @"NSCTFontUIFontDesignMonospaced" && CFEqual(this, @"NSCTFontUIFontDesignMonospaced"))
  {
    unsigned int v11 = IndexesBracketing<double const*,double>(&kCTFontDefaultWeights[2], &kCTFontDefaultWeights[8], a3, 0.001);
    uint64_t v14 = 6;
    if (!a4) {
      uint64_t v14 = 0;
    }
    BOOL v15 = kSystemUIFontMonospacedNames;
    goto LABEL_26;
  }
  if (@"NSCTFontUIFontDesignSoft" == this
    || this && @"NSCTFontUIFontDesignSoft" && CFEqual(this, @"NSCTFontUIFontDesignSoft"))
  {
    unint64_t v12 = kSystemUIFontSoftNames;
  }
  else
  {
    if (@"NSCTFontUIFontDesignCompactSoft" != this)
    {
      CFDataRef result = 0;
      if (!this || !@"NSCTFontUIFontDesignCompactSoft") {
        return result;
      }
      if (!CFEqual(this, @"NSCTFontUIFontDesignCompactSoft")) {
        return 0;
      }
    }
    unint64_t v12 = kSystemUIFontCompactSoftNames;
  }
LABEL_27:
  unsigned int v16 = HIWORD(v11);
  if (v8)
  {
    CFDataRef result = v12[v16];
    if (a5 && (unsigned __int16)v11 != v16)
    {
      unsigned int v16 = (unsigned __int16)v11;
LABEL_33:
      *a5 = v12[v16];
    }
  }
  else
  {
    CFDataRef result = v12[(unsigned __int16)v11];
    if (a5 && (unsigned __int16)v11 != v16) {
      goto LABEL_33;
    }
  }
  return result;
}

uint64_t IndexesBracketing<double const*,double>(double *a1, double *a2, double a3, double a4)
{
  if ((char *)a2 - (char *)a1 >= 16 && *a1 <= a3)
  {
    if (*(a2 - 1) <= a3)
    {
      unsigned __int16 v4 = ((unint64_t)((char *)a2 - (char *)a1) >> 3) - 1;
    }
    else
    {
      CFIndex v7 = a1 + 1;
      if (a1 + 1 == a2)
      {
        unsigned __int16 v4 = 0;
        unsigned __int16 v5 = 1;
        return v4 | (v5 << 16);
      }
      unsigned __int16 v4 = 0;
      unsigned __int16 v5 = 1;
      while (1)
      {
        double v8 = *(v7 - 1);
        if (vabdd_f64(a3, v8) < a4) {
          break;
        }
        if (vabdd_f64(a3, *v7) < a4)
        {
          unsigned __int16 v4 = v5;
          return v4 | (v5 << 16);
        }
        if (v8 >= a3 || *v7 <= a3)
        {
          ++v4;
          ++v5;
          if (++v7 != a2) {
            continue;
          }
        }
        return v4 | (v5 << 16);
      }
    }
    unsigned __int16 v5 = v4;
  }
  else
  {
    unsigned __int16 v4 = 0;
    unsigned __int16 v5 = 0;
  }
  return v4 | (v5 << 16);
}

uint64_t TCFBase<TFramesetter>::ClassDestruct(uint64_t a1)
{
  int v2 = *(void (**)(uint64_t))(a1 + 16);
  if (v2) {
    v2(a1);
  }
  unsigned int v3 = ***(uint64_t (****)(void))(a1 + 40);

  return v3();
}

void TAttributes::HandleLanguageAttribute(const __CFString *a1, uint64_t a2)
{
  if (a1)
  {
    CFTypeID v4 = CFGetTypeID(a1);
    if (v4 == CFStringGetTypeID())
    {
      unsigned __int16 v5 = (void *)atomic_exchange((atomic_ullong *volatile)(*(void *)a2 + 24), (unint64_t)CFLocaleCreateCanonicalLanguageIdentifierFromString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1));
    }
  }
}

uint64_t ___Z29CTFontGetPlistFromGSFontCachePK10__CFStringb_block_invoke()
{
  uint64_t result = GSFontGetCacheDictionary();
  _MergedGlobals_34 = result != 0;
  return result;
}

uint64_t TDescriptorSource::GetTextStyleWithSymbolicTraits(TDescriptorSource *this, __CFString *a2)
{
  unsigned int v3 = (TDescriptorSource *)MapTextStyleValue((uint64_t)this);
  if (v3 > 0x144)
  {
    FontNameForNameAndTrait = 0;
  }
  else
  {
    FontNameForNameAndTrait = (TDescriptorSource *)TDescriptorSource::UIFontNameForUIType(v3);
    if (FontNameForNameAndTrait) {
      FontNameForNameAndTrait = (TDescriptorSource *)TDescriptorSource::FindFontNameForNameAndTrait(FontNameForNameAndTrait, 0, (uint64_t *)a2, (int)a2);
    }
  }

  return TDescriptorSource::TextStyleForUIFontName(FontNameForNameAndTrait, v4, v5);
}

id ___Z25VariableSizeTextStylesSetv_block_invoke()
{
  id result = (id)objc_msgSend(MEMORY[0x1E4F1CAD0], "setWithObjects:", @"UICTFontTextStylePreferredSizeRegular", @"UICTFontTextStylePreferredSizeBold", 0);
  qword_1EB2CDBB8 = (uint64_t)result;
  return result;
}

double CTFontGetCapHeightForSystemFontOfSize(double a1)
{
  return (double)*((int *)kFont2X + 8) * a1 / *((double *)kFont2X + 1);
}

uint64_t CTRunGetGlyphStorage(uint64_t result, _OWORD *a2)
{
  if (result)
  {
    uint64_t v2 = *(void *)(result + 40);
    if (a2) {
      *a2 = *(_OWORD *)(v2 + 200);
    }
    return *(void *)(v2 + 216);
  }
  return result;
}

void KeyFilterApplier(const void *value, const void *a2, atomic_ullong *a3)
{
  if (CFSetContainsValue((CFSetRef)atomic_load_explicit(a3, memory_order_acquire), value))
  {
    unint64_t explicit = (__CFDictionary *)atomic_load_explicit(a3 + 1, memory_order_acquire);
    CFDictionaryAddValue(explicit, value, a2);
  }
}

void TDecorationRun::CalculateGlyphIntersections(CGAffineTransform,TRun const&,double,double,std::function<void ()(double,double)> const&)const::$_0::__invoke(_anonymous_namespace_::PathObserver *this, uint64_t a2)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  CFStringRef v4 = *(_anonymous_namespace_::PathObserver **)(a2 + 8);
  unsigned int v5 = *(_DWORD *)a2;
  if ((*(_DWORD *)a2 - 1) >= 3)
  {
    if (v5 == 4)
    {
      int v6 = 1;
      unsigned int v5 = 1;
      CFStringRef v4 = this;
    }
    else
    {
      if (v5)
      {
        unsigned int v5 = 0;
        double v8 = (double *)((char *)this + 24);
        double v12 = *((double *)this + 3);
        char v14 = 1;
        int v6 = 1;
        double v9 = v12;
        goto LABEL_16;
      }
      *(_OWORD *)this = *(_OWORD *)*(void *)(a2 + 8);
      int v6 = 0;
      if (*(double *)(*(void *)(a2 + 8) + 8) < *((double *)this + 4) + 1.0e-10)
      {
        int v7 = *((_DWORD *)this + 12) + 1;
        *((_DWORD *)this + 12) = v7;
        *((_DWORD *)this + 13) = v7;
        *((_DWORD *)this + 14) = v7;
      }
      unsigned int v5 = 1;
    }
  }
  else
  {
    int v6 = 1;
  }
  double v8 = (double *)((char *)this + 24);
  double v9 = *((double *)this + 3);
  uint64_t v10 = v5;
  uint64_t v11 = 8;
  double v12 = v9;
  do
  {
    double v13 = *(double *)((char *)v4 + v11);
    if (v9 < v13) {
      double v9 = *(double *)((char *)v4 + v11);
    }
    if (v13 < v12) {
      double v12 = *(double *)((char *)v4 + v11);
    }
    v11 += 16;
    --v10;
  }
  while (v10);
  char v14 = 0;
LABEL_16:
  double v15 = *((double *)this + 4);
  double v16 = *((double *)this + 5);
  BOOL v17 = v12 <= v15;
  if (v15 > v9) {
    BOOL v17 = 0;
  }
  int v18 = v6 & v17;
  BOOL v19 = v12 <= v16;
  if (v16 > v9) {
    BOOL v19 = 0;
  }
  int v20 = v6 & v19;
  uint64_t v21 = (double *)((char *)v4 + 16 * v5 - 16);
  double v22 = *v21;
  double v23 = v21[1];
  if (v15 < v23 && v23 < v16) {
  unsigned int v25 = (CGPoint *)((char *)this + 16);
  }
  if ((v18 | v20) == 1)
  {
    *(void *)&long long v26 = -1;
    *((void *)&v26 + 1) = -1;
    v52[1] = v26;
    v52[2] = v26;
    CGPoint v51 = *v25;
    v52[0] = v26;
    if ((v14 & 1) == 0) {
      memmove(v52, v4, 16 * v5);
    }
    memset(v50, 255, sizeof(v50));
    memset(v49, 255, sizeof(v49));
    if (v18)
    {
      unsigned int InterceptsAtY = GetInterceptsAtY(v5, &v51, *((double *)this + 4) + 1.0e-10, v50, v49);
      if (InterceptsAtY)
      {
        uint64_t v28 = InterceptsAtY;
        unint64_t v29 = v49;
        unsigned int v30 = v50;
        do
        {
          int v31 = *((_DWORD *)this + 13);
          if (v31)
          {
            int v32 = 0;
          }
          else
          {
            int v32 = *((_DWORD *)this + 12) + 1;
            *((_DWORD *)this + 12) = v32;
            int v31 = v32;
          }
          double v33 = *v30++;
          double v34 = v33;
          *((_DWORD *)this + 13) = v32;
          double v35 = *v29++;
          --v28;
        }
        while (v28);
      }
    }
    if (v20)
    {
      unsigned int v36 = GetInterceptsAtY(v5, &v51, *((double *)this + 5) + 1.0e-10, v50, v49);
      if (v36)
      {
        uint64_t v37 = v36;
        BOOL v38 = v49;
        unsigned int v39 = v50;
        do
        {
          double v40 = *v39++;
          double v41 = v40;
          double v42 = *v38++;
          --v37;
        }
        while (v37);
      }
    }
  }
  if (*(_DWORD *)a2 == 4)
  {
    long long v43 = *MEMORY[0x1E4F1DAD8];
    *unsigned int v25 = *(CGPoint *)MEMORY[0x1E4F1DAD8];
    *(_OWORD *)this = v43;
    int v44 = *((_DWORD *)this + 14);
    if (v44)
    {
      int v45 = *((_DWORD *)this + 13);
      if (v44 != v45)
      {
        uint64_t v46 = *((void *)this + 9);
        while (v46 != *((void *)this + 8))
        {
          uint64_t v47 = v46;
          int v48 = *(_DWORD *)(v46 - 4);
          v46 -= 16;
          if (v48 == v45)
          {
            *(_DWORD *)(v47 - 4) = v44;
            break;
          }
        }
      }
      *((_DWORD *)this + 13) = 0;
      *((_DWORD *)this + 14) = 0;
    }
  }
  else
  {
    v25->double x = v22;
    *double v8 = v23;
  }
}

void anonymous namespace'::PathObserver::HandleIntersectionAt(void *a1, int a2, int a3, double a4)
{
  double v8 = (double *)a1[9];
  unint64_t v9 = a1[10];
  if ((unint64_t)v8 >= v9)
  {
    uint64_t v11 = (double *)a1[8];
    uint64_t v12 = ((char *)v8 - (char *)v11) >> 4;
    unint64_t v13 = v12 + 1;
    if ((unint64_t)(v12 + 1) >> 60) {
      abort();
    }
    if ((uint64_t)(v9 - (void)v11) >> 3 > v13) {
      unint64_t v13 = (uint64_t)(v9 - (void)v11) >> 3;
    }
    if (v9 - (unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v14 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v13;
    }
    double v16 = (double *)(a1 + 19);
    double v15 = (char *)a1[19];
    unint64_t v17 = (unint64_t)&v15[16 * v14];
    if (v17 <= (unint64_t)(a1 + 19))
    {
      *(void *)double v16 = v17;
    }
    else
    {
      if (v14 >> 60) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      double v15 = (char *)operator new(16 * v14);
    }
    int v18 = &v15[16 * v12];
    *(double *)int v18 = a4;
    *((_DWORD *)v18 + 2) = a2;
    *((_DWORD *)v18 + 3) = a3;
    uint64_t v10 = (double *)(v18 + 16);
    if (v8 != v11)
    {
      do
      {
        *((_OWORD *)v18 - 1) = *((_OWORD *)v8 - 1);
        v18 -= 16;
        v8 -= 2;
      }
      while (v8 != v11);
      double v8 = (double *)a1[8];
      unint64_t v9 = a1[10];
    }
    a1[8] = v18;
    a1[9] = v10;
    a1[10] = &v15[16 * v14];
    if (v8)
    {
      if (a1 + 11 <= (void *)v8 && v16 > v8)
      {
        if (v9 == *(void *)v16) {
          *(void *)double v16 = v8;
        }
      }
      else
      {
        operator delete(v8);
      }
    }
  }
  else
  {
    *double v8 = a4;
    uint64_t v10 = v8 + 2;
    *((_DWORD *)v8 + 2) = a2;
    *((_DWORD *)v8 + 3) = a3;
  }
  a1[9] = v10;
}

__n128 anonymous namespace'::PathObserver::CleanUpAfterUnclosedSubpath(_anonymous_namespace_::PathObserver *this)
{
  int v1 = *((_DWORD *)this + 14);
  if (*(void *)((char *)this + 52))
  {
    uint64_t v2 = *((void *)this + 8);
    uint64_t v3 = *((void *)this + 9);
    while (v2 != v3)
    {
      int v4 = *(_DWORD *)(v2 + 12);
      if (v4 && (v4 == v1 || v4 == *((_DWORD *)this + 13))) {
        *(_DWORD *)(v2 + 12) = 0;
      }
      v2 += 16;
    }
    *((_DWORD *)this + 13) = 0;
    *((_DWORD *)this + 14) = 0;
  }
  __n128 result = *(__n128 *)MEMORY[0x1E4F1DAD8];
  *(_OWORD *)this = *MEMORY[0x1E4F1DAD8];
  *((__n128 *)this + 1) = result;
  return result;
}

uint64_t GetInterceptsAtY(int a1, const CGPoint *a2, double a3, double *a4, double *a5)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  switch(a1)
  {
    case 3:
      double y = a2->y;
      double v14 = a2[1].y;
      double v15 = a2[2].y;
      double v16 = v15 * -3.0 - (y - v14 * 3.0) + a2[3].y;
      double v17 = v14 * -6.0 + y * 3.0 + v15 * 3.0;
      double v18 = v14 * 3.0 + y * -3.0;
      double v19 = y - a3;
      double v54 = NAN;
      double v55 = NAN;
      long double v53 = NAN;
      if (fabs(v16) >= 1.0e-10)
      {
        double v33 = v17 / v16;
        double v34 = (v18 / v16 * -3.0 + v33 * v33) / 9.0;
        double v35 = (v18 / v16 * (v17 / v16 * -9.0) + v33 * (v33 + v33) * v33 + v19 / v16 * 27.0) / 54.0;
        double v36 = v34 * -(v34 * v34) + v35 * v35;
        if (v36 >= 0.0)
        {
          double v41 = sqrt(v36);
          double v42 = cbrt(v41 - v35);
          long double v53 = v42 + cbrt(-v35 - v41) + v33 / -3.0;
          unsigned int v20 = 1;
        }
        else
        {
          long double v37 = pow(v34, 1.5);
          double v38 = acos(v35 / v37);
          double v39 = sqrt(v34) * -2.0;
          double v40 = v33 / -3.0;
          long double v53 = v40 + v39 * cos(v38 / 3.0);
          double v54 = v40 + v39 * cos((v38 + 6.28318531) / 3.0);
          double v55 = v40 + v39 * cos((v38 + -6.28318531) / 3.0);
          std::__sort<std::__less<double,double> &,double *>();
          unsigned int v20 = 3;
        }
      }
      else
      {
        unsigned int v20 = SolveQuadratic(v17, v18, v19, &v53);
        if (!v20) {
          return 0;
        }
      }
      uint64_t v12 = 0;
      long long v43 = &v53;
      uint64_t v44 = v20;
      do
      {
        double v45 = *v43;
        if (*v43 >= 0.0 && v45 <= 1.0)
        {
          EvalBezierCurve(v45, 3u, a2);
          a4[v12] = v47;
          if (a5)
          {
            double v48 = *v43;
            EvalBezierCurve(*v43, 2u, a2);
            double v50 = v49;
            EvalBezierCurve(v48, 2u, a2 + 1);
            a5[v12] = (v51 - v50) * 3.0;
          }
          uint64_t v12 = (v12 + 1);
        }
        ++v43;
        --v44;
      }
      while (v44);
      break;
    case 2:
      double v21 = a2->y;
      double v22 = a2[1].y;
      double v23 = v21 + v22 * -2.0 + a2[2].y;
      long double v53 = NAN;
      double v54 = NAN;
      unsigned int v24 = SolveQuadratic(v23, v22 + v22 + v21 * -2.0, v21 - a3, &v53);
      uint64_t v12 = 0;
      if (v24)
      {
        unsigned int v25 = &v53;
        uint64_t v26 = v24;
        do
        {
          double v27 = *v25;
          if (*v25 >= 0.0 && v27 <= 1.0)
          {
            EvalBezierCurve(*v25, 2u, a2);
            a4[v12] = v29;
            if (a5)
            {
              EvalBezierCurve(v27, 1u, a2);
              double v31 = v30;
              EvalBezierCurve(v27, 1u, a2 + 1);
              a5[v12] = v32 - v31 + v32 - v31;
            }
            uint64_t v12 = (v12 + 1);
          }
          ++v25;
          --v26;
        }
        while (v26);
      }
      break;
    case 1:
      double v8 = a2->y;
      double v9 = a2[1].y;
      if ((v8 >= a3 || v9 <= a3) && (v8 <= a3 || v9 >= a3)) {
        return 0;
      }
      *a4 = a2->x + (a3 - v8) * (a2[1].x - a2->x) / (v9 - v8);
      if (a5) {
        *a5 = v9 - v8;
      }
      return 1;
    default:
      return 0;
  }
  return v12;
}

void EvalBezierCurve(double a1, unsigned int a2, const CGPoint *a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v6 = -1;
  *((void *)&v6 + 1) = -1;
  v22[2] = v6;
  v22[3] = v6;
  v22[0] = v6;
  v22[1] = v6;
  unsigned int v7 = a2 + 1;
  size_t v8 = 16 * (a2 + 1);
  if (a2 <= 2) {
    size_t v9 = 64 - 16 * v7;
  }
  else {
    size_t v9 = 0;
  }
  uint64_t v10 = __dst;
  memset(&__dst[v7], 255, v9);
  memcpy(__dst, a3, v8);
  unint64_t v11 = a2;
  uint64_t v12 = v22;
  do
  {
    uint64_t v13 = 0;
    double v14 = v12;
    unint64_t v15 = v11 - 1;
    if (v11 <= 1) {
      uint64_t v16 = 1;
    }
    else {
      uint64_t v16 = v11;
    }
    do
    {
      double v17 = *((double *)&v10[v13] + 1);
      double v18 = *((double *)&v10[v13 + 1] + 1);
      double v19 = std::__lerp[abi:nn180100]<double>(*(double *)&v10[v13], *(double *)&v10[v13 + 1], a1);
      double v20 = std::__lerp[abi:nn180100]<double>(v17, v18, a1);
      double v21 = (double *)&v14[v13];
      *double v21 = v19;
      v21[1] = v20;
      ++v13;
      --v16;
    }
    while (v16);
    unint64_t v11 = v15;
    uint64_t v12 = v10;
    uint64_t v10 = v14;
  }
  while (v15);
}

uint64_t SolveQuadratic(double a1, double a2, double a3, double *a4)
{
  if (fabs(a1) < 1.0e-10)
  {
    if (fabs(a2) >= 1.0e-10)
    {
      *a4 = -a3 / a2;
      return 1;
    }
    return 0;
  }
  double v5 = a1 * -4.0 * a3 + a2 * a2;
  if (v5 < 0.0) {
    return 0;
  }
  double v6 = sqrt(v5);
  double v7 = a1 + a1;
  *a4 = (-a2 - v6) / v7;
  a4[1] = (v6 - a2) / v7;
  return 2;
}

CGSize CTFramesetterSuggestFrameSizeWithConstraints(CTFramesetterRef framesetter, CFRange stringRange, CFDictionaryRef frameAttributes, CGSize constraints, CFRange *fitRange)
{
  if (!framesetter)
  {
    double v47 = *MEMORY[0x1E4F1DB30];
    double v26 = *(double *)(MEMORY[0x1E4F1DB30] + 8);
    goto LABEL_66;
  }
  CFIndex length = stringRange.length;
  locatioCFIndex n = stringRange.location;
  double v10 = 10000000.0;
  if (constraints.width <= 10000000.0) {
    double width = constraints.width;
  }
  else {
    double width = 10000000.0;
  }
  if (constraints.width <= 0.0) {
    double width = 10000000.0;
  }
  if (constraints.height <= 10000000.0) {
    double height = constraints.height;
  }
  else {
    double height = 10000000.0;
  }
  if (constraints.height > 0.0) {
    double v10 = height;
  }
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  CGPathRef v15 = CGPathCreateWithRect(*(CGRect *)(&v10 - 3), 0);
  uint64_t v16 = (TFramesetter *)*((void *)framesetter + 5);
  CFIndex v17 = *(void *)(*(void *)((*(uint64_t (**)(TFramesetter *))(*(void *)v16 + 16))(v16) + 216) + 16);
  if (location + length > v17)
  {
    double v47 = *MEMORY[0x1E4F1DB30];
    double v26 = *(double *)(MEMORY[0x1E4F1DB30] + 8);
    goto LABEL_65;
  }
  uint64_t v18 = v17 - location;
  if (length) {
    uint64_t v19 = length;
  }
  else {
    uint64_t v19 = v18;
  }
  double v58 = NAN;
  long long v56 = 0u;
  long long v57 = 0u;
  long long v55 = 0u;
  id v54 = (id)0xAAAAAAAAAAAAAAAALL;
  TFramesetter::CreateFrame(v16, location, v19, v15, frameAttributes, &v58, (uint64_t)&v55, (unint64_t *)&v54);
  if (!atomic_load_explicit((atomic_ullong *volatile)&v54, memory_order_acquire)) {
    goto LABEL_55;
  }
  uint64_t v20 = *(void *)(atomic_load_explicit((atomic_ullong *volatile)&v54, memory_order_acquire) + 40);
  if (fitRange) {
    *fitRange = *(CFRange *)(v20 + 16);
  }
  double v21 = (TCharStream **)(*(uint64_t (**)(TFramesetter *))(*(void *)v16 + 16))(v16);
  CFIndex Count = CFArrayGetCount((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)(v20 + 104), memory_order_acquire));
  if (Count <= 0)
  {
LABEL_55:
    double v47 = *MEMORY[0x1E4F1DB30];
    double v26 = *(double *)(MEMORY[0x1E4F1DB30] + 8);
    goto LABEL_64;
  }
  CFIndex v23 = Count;
  CFIndex v24 = 0;
  int v25 = *(_DWORD *)(v20 + 144);
  double v27 = *MEMORY[0x1E4F1DB30];
  double v26 = *(double *)(MEMORY[0x1E4F1DB30] + 8);
  do
  {
    LineAtIndedouble x = TFrame::GetLineAtIndex((atomic_ullong *)v20, v24);
    uint64_t v30 = LineAtIndex[5];
    uint64_t v31 = *(void *)(v30 + 72);
    if (*(void *)(v30 + 24) == *(void *)(v30 + 16))
    {
      uint64_t v32 = 0;
      if (!v31)
      {
LABEL_27:
        long double v37 = *(TParagraphStyle ***)(v32 + 128);
        double v35 = (TParagraphStyle ***)(v32 + 128);
        double v34 = v37;
        if (!v37) {
          goto LABEL_38;
        }
        goto LABEL_28;
      }
    }
    else
    {
      uint64_t v32 = *(void *)(*(void *)(*(void *)(v30 + 16)
                                  + 8 * TLine::FindRunWithCharIndex((TLine *)LineAtIndex[5], *(void *)(v30 + 72), 1))
                      + 40)
          + 40;
      if (!v31) {
        goto LABEL_27;
      }
    }
    BOOL IsParagraphSeparator = TCharStream::IsParagraphSeparator(*v21, v31 - 1);
    double v36 = *(TParagraphStyle ***)(v32 + 128);
    double v35 = (TParagraphStyle ***)(v32 + 128);
    double v34 = v36;
    if (IsParagraphSeparator)
    {
      if (!v34) {
        goto LABEL_38;
      }
LABEL_28:
      double FirstLineHeadIndent = TParagraphStyle::GetFirstLineHeadIndent(v34, v29);
      goto LABEL_31;
    }
    if (!v34)
    {
LABEL_38:
      double v40 = 0.0;
LABEL_39:
      double v44 = 0.0;
LABEL_40:
      double v46 = v40 + *(double *)(v30 + 104) - v44;
LABEL_41:
      TLine::GetTrailingWhitespace(v30, v53);
      double v46 = v46 - v53[2];
      goto LABEL_42;
    }
    double FirstLineHeadIndent = TParagraphStyle::GetHeadIndent(v34, v29);
LABEL_31:
    double v40 = FirstLineHeadIndent;
    if (!*v35) {
      goto LABEL_39;
    }
    double TailIndent = TParagraphStyle::GetTailIndent(*v35, v38);
    long long v43 = *v35;
    if (TailIndent <= 0.0) {
      double v44 = TailIndent;
    }
    else {
      double v44 = 0.0;
    }
    if (!v43) {
      goto LABEL_40;
    }
    unsigned int LineBreakMode = TParagraphStyle::GetLineBreakMode(v43, v41);
    double v46 = v40 + *(double *)(v30 + 104) - v44;
    if (LineBreakMode != 1) {
      goto LABEL_41;
    }
LABEL_42:
    if (v46 >= v27) {
      double v47 = v46;
    }
    else {
      double v47 = v27;
    }
    if (!v25) {
      double v27 = v47;
    }
    if (v46 >= v26 && v25 != 0) {
      double v26 = v46;
    }
    ++v24;
  }
  while (v23 != v24);
  if (v25)
  {
    double v47 = v58 + *(double *)(v30 + 112);
  }
  else if (*(unsigned char *)(v20 + 160))
  {
    double v26 = v58;
  }
  else
  {
    double v26 = v58 + *((double *)&v57 + 1);
    if (!*(unsigned char *)(v20 + 161)) {
      double v26 = v26 + *(double *)&v56;
    }
  }
  if (*(unsigned char *)(v20 + 162))
  {
    double v49 = ceil(v47);
    double v50 = ceil(v26);
    if (*(_DWORD *)(v20 + 144)) {
      double v47 = v49;
    }
    else {
      double v26 = v50;
    }
  }
LABEL_64:

LABEL_65:
LABEL_66:
  double v51 = v47;
  double v52 = v26;
  result.double height = v52;
  result.double width = v51;
  return result;
}

void TFramesetter::FrameInRect(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, double *a5, uint64_t a6)
{
  uint64_t v118 = *MEMORY[0x1E4F143B8];
  int v103 = *(_DWORD *)(a2 + 144);
  uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  double v11 = *(double *)(a2 + 40);
  CGFloat x = *(double *)(a2 + 48);
  double v13 = v11 * 0.5;
  CGFloat y = *(double *)(a2 + 56);
  CGFloat width = *(double *)(a2 + 64);
  uint64_t v96 = a2;
  CGFloat height = *(double *)(a2 + 72);
  if (v11 != 0.0)
  {
    CGRect v122 = CGRectInset(*(CGRect *)(a2 + 48), v13, v13);
    CGFloat x = v122.origin.x;
    CGFloat y = v122.origin.y;
    CGFloat width = v122.size.width;
    CGFloat height = v122.size.height;
  }
  v123.origin.CGFloat x = x;
  v123.origin.CGFloat y = y;
  v123.size.CGFloat width = width;
  v123.size.CGFloat height = height;
  double v17 = CGRectGetHeight(v123);
  v124.origin.CGFloat x = x;
  v124.origin.CGFloat y = y;
  v124.size.CGFloat width = width;
  v124.size.CGFloat height = height;
  double v18 = CGRectGetWidth(v124);
  if (v103) {
    double v19 = v17;
  }
  else {
    double v19 = v18;
  }
  double v97 = v19;
  double v94 = v17;
  if (v103) {
    double v20 = v18;
  }
  else {
    double v20 = v17;
  }
  if (a3) {
    BOOL IsParagraphSeparator = TCharStream::IsParagraphSeparator(*(TCharStream **)v10, a3 - 1);
  }
  else {
    BOOL IsParagraphSeparator = 1;
  }
  uint64_t v21 = *(void *)(a2 + 152);
  int v99 = *(unsigned __int8 *)(a2 + 162);
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  uint64_t v112 = 0;
  id v113 = Mutable;
  __p = 0;
  unsigned __int16 v111 = 0;
  id v109 = 0;
  uint64_t v92 = a4;
  uint64_t v93 = a3;
  if (a4 >= 1)
  {
    CFIndex v23 = 0;
    double v24 = 0.0;
    if (v103 == 2) {
      double v25 = 0.0;
    }
    else {
      double v25 = v20;
    }
    char v100 = 1;
    uint64_t v105 = a3;
    uint64_t v26 = a4;
    while (1)
    {
      uint64_t v28 = *(void *)(v10 + 16);
      uint64_t v27 = *(void *)(v10 + 24);
      if (v27 == v28)
      {
        uint64_t v31 = 0;
        LODWORD(v32) = 0;
      }
      else
      {
        uint64_t v30 = *(void *)(*(void *)(*(void *)(v10 + 16) + 8 * TLine::FindRunWithCharIndex((TLine *)v10, v105, 1))
                        + 40);
        uint64_t v31 = (TFramesetter *)(v30 + 40);
        uint64_t v32 = *(TParagraphStyle ***)(v30 + 168);
        if (v32) {
          LODWORD(v32) = TParagraphStyle::GetLineBreakMode(v32, v29);
        }
      }
      if (v32 <= 2) {
        unsigned int v33 = v32;
      }
      else {
        unsigned int v33 = 0;
      }
      if (v32 >= 3) {
        int v34 = (int)v32;
      }
      else {
        int v34 = 4;
      }
      if (v21 - 1 == v23) {
        unsigned int v33 = v34;
      }
      if (v21 >= 1) {
        unsigned int v35 = v33;
      }
      else {
        unsigned int v35 = v32;
      }
      double HeadIndent = TFramesetter::GetHeadIndent(v31, (const TAttributes *)IsParagraphSeparator);
      double v38 = 0.0;
      if (v27 == v28
        || (double v39 = (TParagraphStyle **)*((void *)v31 + 16)) == 0
        || (TailIndent = TParagraphStyle::GetTailIndent(v39, v36), double v38 = TailIndent, TailIndent <= 0.0))
      {
        double v41 = v97 - HeadIndent + v38;
      }
      else
      {
        double v41 = TailIndent - HeadIndent;
      }
      unsigned int v102 = v35;
      if (v35 <= 1) {
        double v42 = v41;
      }
      else {
        double v42 = 1.79769313e308;
      }
      if (v35 == 1)
      {
        uint64_t v115 = 0;
        long long v43 = v114;
        uint64_t v44 = TTypesetter::SuggestClusterBreak(v10, v105, (uint64_t)v114, v42, HeadIndent);
      }
      else
      {
        uint64_t v117 = 0;
        long long v43 = v116;
        uint64_t v44 = TTypesetter::SuggestLineBreak(v10, v105, (uint64_t)v116, v42, HeadIndent);
      }
      uint64_t v46 = v44;
      char v98 = v45;
      std::__function::__value_func<unsigned char ()(long)>::~__value_func[abi:nn180100](v43);
      if (v46 < 0) {
        CFIndex v47 = v26;
      }
      else {
        CFIndex v47 = v46;
      }
      if (v47 >= v26) {
        CFIndex v48 = v26;
      }
      else {
        CFIndex v48 = v47;
      }
      id v108 = (id)0xAAAAAAAAAAAAAAAALL;
      TCFBase_NEW<CTLine,std::shared_ptr<TCharStream const> const&>((uint64_t *)v10, &v108);
      if (!atomic_load_explicit((atomic_ullong *volatile)&v108, memory_order_acquire))
      {
        char v69 = v98;

        goto LABEL_73;
      }
      uint64_t v101 = (uint64_t)v31;
      uint64_t v49 = v26;
      double v50 = a5;
      double v51 = *(TLine **)(atomic_load_explicit((atomic_ullong *volatile)&v108, memory_order_acquire) + 40);
      v120.locatioCFIndex n = v105;
      v120.CFIndex length = v48;
      TTypesetter::FillLine((TTypesetter *)v10, v51, v120, v42, HeadIndent);
      id v107 = (id)0xAAAAAAAAAAAAAAAALL;
      id v107 = (id)ExternalizeLine((atomic_ullong *)&v108);
      __int16 v52 = *((_WORD *)v51 + 76);
      BOOL v54 = TFramesetter::ParagraphEndsWith(v51, *(const TLine **)v10, v53);
      *(void *)&long long v55 = -1;
      *((void *)&v55 + 1) = -1;
      *(_OWORD *)&v106[16] = v55;
      *(_OWORD *)&v106[32] = v55;
      *(_OWORD *)unsigned int v106 = v55;
      TFramesetter::GetLineMetrics((uint64_t)v106, v51, (const void *)(v100 & 1), IsParagraphSeparator, v54, v99 != 0);
      uint64_t v56 = *(void *)&v106[24];
      if (v103 == 2)
      {
        a5 = v50;
        uint64_t v57 = *(void *)&v106[40];
        double v58 = *(double *)v106;
        if (*(double *)v106 + *(double *)&v106[40] + *(double *)&v106[24] + v24 + *v50 - v20 > 0.0002) {
          goto LABEL_54;
        }
        uint64_t v59 = *(void *)&v106[8];
        double v60 = v24 + *(double *)&v106[24] + *(double *)&v106[8];
        double v61 = *v50 + v60;
        double v25 = v25 + v60;
        uint64_t v62 = *(void *)v106;
        uint64_t v26 = v49;
      }
      else
      {
        uint64_t v62 = *(void *)v106;
        double v63 = v24 + *(double *)&v106[24] + *(double *)v106;
        a5 = v50;
        double v61 = *v50 + v63;
        if (v61 > v20)
        {
LABEL_54:
          int v64 = 0;
          uint64_t v26 = v49;
          goto LABEL_69;
        }
        uint64_t v57 = *(void *)&v106[40];
        uint64_t v26 = v49;
        if (!*(unsigned char *)(v96 + 160) && v61 + *(double *)&v106[40] - v20 > 0.0002
          || !*(unsigned char *)(v96 + 161) && v61 + *(double *)&v106[40] + *(double *)&v106[16] - v20 > 0.0002)
        {
          goto LABEL_68;
        }
        double v25 = v25 - v63;
        double v58 = *(double *)&v106[8];
        uint64_t v59 = *(void *)&v106[8];
      }
      if ((v52 & 8) != 0) {
        double v65 = v38;
      }
      else {
        double v65 = HeadIndent;
      }
      *a5 = v61;
      *(void *)a6 = v62;
      *(void *)(a6 + 8) = v59;
      double v66 = *(double *)&v106[16];
      double v67 = *(double *)&v106[32];
      *(void *)(a6 + 16) = *(void *)&v106[16];
      *(void *)(a6 + 24) = v56;
      *(double *)(a6 + 32) = v67;
      *(void *)(a6 + 40) = v57;
      double v68 = v94;
      if (!v103) {
        double v68 = v65;
      }
      if (TFramesetter::AppendLine(v101, v103 == 0, (v52 & 8) >> 3, v54, v102, v23, (atomic_ullong *)&v107, (atomic_ullong *)&v113, v41, v13 + v68, v13 + v25, (uint64_t)&__p, (atomic_ullong *)&v109))
      {
        v26 -= v48;
        v105 += v48;
        if (v58 + v66 + v67 + *a5 < v20)
        {
          char v100 = 0;
          int v64 = 1;
          BOOL IsParagraphSeparator = v54;
          double v24 = v58 + v66 + v67;
          goto LABEL_69;
        }
      }
LABEL_68:
      int v64 = 0;
LABEL_69:

      if (v64)
      {
        ++v23;
        if (v26 > 0) {
          continue;
        }
      }
      char v69 = v98;
      goto LABEL_73;
    }
  }
  char v69 = 0;
  uint64_t v26 = a4;
  uint64_t v105 = a3;
LABEL_73:
  CFIndex Count = CFArrayGetCount((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v113, memory_order_acquire));
  if (!v21 && v26 >= 1)
  {
    CFIndex v71 = Count - 1;
    if (Count >= 1)
    {
      uint64_t v72 = *((void *)CFArrayGetValueAtIndex((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v113, memory_order_acquire), v71)+ 5);
      id v108 = (id)0xAAAAAAAAAAAAAAAALL;
      TCFBase_NEW<CTLine,std::shared_ptr<TCharStream const> const&>((uint64_t *)v10, &v108);
      if (atomic_load_explicit((atomic_ullong *volatile)&v108, memory_order_acquire))
      {
        double v73 = *((double *)__p + 2 * v71);
        double v74 = v97 - v73;
        CFIndex v75 = *(void *)(v72 + 72);
        v121.CFIndex length = *(void *)(v72 + 80) + v26;
        v121.locatioCFIndex n = v75;
        TTypesetter::FillLine((TTypesetter *)v10, *(TLine **)(atomic_load_explicit((atomic_ullong *volatile)&v108, memory_order_acquire) + 40), v121, v97 - v73, v73);
        int v76 = 1;
        if (*(void *)(v10 + 24) != *(void *)(v10 + 16))
        {
          BOOL v77 = *(TParagraphStyle ***)(*(void *)(*(void *)(*(void *)(v10 + 16)
                                                             + 8 * TLine::FindRunWithCharIndex((TLine *)v10, v75, 1))
                                                 + 40)
                                     + 168);
          if (v77)
          {
            unsigned int LineBreakMode = TParagraphStyle::GetLineBreakMode(v77, v78);
            if (LineBreakMode <= 2) {
              int v76 = 1;
            }
            else {
              int v76 = LineBreakMode - 3;
            }
          }
        }
        if ((v69 & 2) != 0 && v76 == 1)
        {
          id v107 = (id)0xAAAAAAAAAAAAAAAALL;
          TCFBase_NEW<CTLine,std::shared_ptr<TCharStream const> const&>((uint64_t *)v10, &v107);
          if (atomic_load_explicit((atomic_ullong *volatile)&v107, memory_order_acquire))
          {
            TCharStream::GetRangeOfParagraphSeparatorAtIndex(*(TCharStream **)v10, *(void *)(v72 + 72) + *(void *)(v72 + 80) - 1, v80, v81, v82, v83, v84, v85);
            uint64_t v87 = v86;
            *(void *)unsigned int v106 = -1;
            *(void *)&long long v88 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v88 + 1) = 0xAAAAAAAAAAAAAAAALL;
            *(_OWORD *)&v106[8] = v88;
            *(_OWORD *)&v106[24] = v88;
            TTruncator::TTruncator((uint64_t)v106, atomic_load_explicit((atomic_ullong *volatile)&v108, memory_order_acquire), *(void *)(atomic_load_explicit((atomic_ullong *volatile)&v107, memory_order_acquire) + 40));
            v119.locatioCFIndex n = *(void *)(v72 + 72) - v87 + *(void *)(v72 + 80);
            v119.CFIndex length = v87 + v26;
            TTruncator::AppendToken((TLine **)v106, v119, v74);
            int v89 = (const void *)ExternalizeLine((atomic_ullong *)&v107);
            CFArraySetValueAtIndex((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v113, memory_order_acquire), v71, v89);
            CFRelease(v89);
          }
        }
        else
        {
          TruncatedLine = CreateTruncatedLine((uint64_t **)atomic_load_explicit((atomic_ullong *volatile)&v108, memory_order_acquire), v76, 0, 0, v74);
          if (TruncatedLine)
          {
            int64_t v91 = TruncatedLine;
            CFArraySetValueAtIndex((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v113, memory_order_acquire), v71, TruncatedLine);
            CFRelease(v91);
          }
        }
      }
    }
  }
  TFrame::SetLines(v96, (void *)atomic_load_explicit((atomic_ullong *volatile)&v113, memory_order_acquire), (uint64_t)&__p, (void *)atomic_load_explicit((atomic_ullong *volatile)&v109, memory_order_acquire), v93, v92, v93, v105 - v93);

  if (__p)
  {
    unsigned __int16 v111 = __p;
    operator delete(__p);
  }
}

uint64_t TFramesetterAttrString::Typesetter(TFramesetterAttrString *this)
{
  return (uint64_t)this + 8;
}

unint64_t TypesetterCreateLine(const __CTTypesetter *a1, CFRange a2, double a3)
{
  if (!a1) {
    return 0;
  }
  locatioCFIndex n = a2.location;
  double v5 = (uint64_t *)*((void *)a1 + 5);
  CFIndex v6 = *(void *)(v5[27] + 16);
  CFIndex length = v6 - a2.location;
  if (a2.length) {
    CFIndex length = a2.length;
  }
  uint64_t v8 = length + a2.location;
  if (length + a2.location >= v6) {
    CFIndex v9 = *(void *)(v5[27] + 16);
  }
  else {
    CFIndex v9 = length + a2.location;
  }
  if (a2.location < 0 || v6 <= a2.location)
  {
    BOOL v11 = v8 > 0 && a2.location < 1;
    locatioCFIndex n = 0;
    if (v11) {
      CFIndex v10 = v9;
    }
    else {
      CFIndex v10 = 0;
    }
  }
  else
  {
    CFIndex v10 = v9 - a2.location;
  }
  id v29 = (id)0xAAAAAAAAAAAAAAAALL;
  TCFBase_NEW<CTLine,std::shared_ptr<TCharStream const> const&>(v5, &v29);
  if (!atomic_load_explicit((atomic_ullong *volatile)&v29, memory_order_acquire))
  {
    unint64_t v27 = 0;
    goto LABEL_43;
  }
  v30.locatioCFIndex n = location;
  v30.CFIndex length = v10;
  TTypesetter::FillLine((TTypesetter *)v5, *(TLine **)(atomic_load_explicit((atomic_ullong *volatile)&v29, memory_order_acquire) + 40), v30, 1.79769313e308, a3);
  if (atomic_load_explicit((atomic_ullong *volatile)&v29, memory_order_acquire))
  {
    uint64_t v12 = *(void *)(atomic_load_explicit((atomic_ullong *volatile)&v29, memory_order_acquire) + 40);
    double v13 = *(uint64_t **)(v12 + 16);
    uint64_t v14 = *(void *)(v12 + 24) - (void)v13;
    if (v14 >= 1)
    {
      uint64_t v15 = (unint64_t)v14 >> 3;
      if ((unint64_t)v14 >> 3 <= 1) {
        uint64_t v15 = 1;
      }
      do
      {
        uint64_t v16 = *v13++;
        *(void *)(*(void *)(v16 + 48) + 272) = v12;
        --v15;
      }
      while (v15);
    }
    if ((*(_WORD *)(v12 + 154) & 8) == 0) {
      goto LABEL_40;
    }
    uint64_t v17 = v14 >> 3;
    uint64_t v18 = *(void *)(v12 + 72);
    uint64_t v19 = *(void *)(v12 + 88);
    if (v19) {
      goto LABEL_24;
    }
    RunWithCharIndeCGFloat x = TLine::FindRunWithCharIndex((TLine *)v12, *(void *)(v12 + 72), 1);
    if (RunWithCharIndex >= v17)
    {
      uint64_t v19 = 0;
    }
    else
    {
      uint64_t v19 = *(void *)(*(void *)(*(void *)(v12 + 16) + 8 * RunWithCharIndex) + 48);
      if (v19)
      {
LABEL_24:
        if (*(unsigned char *)(v19 + 224)) {
          uint64_t v20 = *(void *)(v19 + 208) - 1;
        }
        else {
          uint64_t v20 = 0;
        }
        uint64_t v22 = *(void *)(v19 + 216);
        uint64_t v23 = *(void *)(v19 + 200);
        if (*(__int16 *)(*(void *)(v22 + 16) + 2 * v23 + 2 * v20) == -1
          && *(void *)(*(void *)(v22 + 48) + 8 * v23 + 8 * v20) == v18)
        {
          *(void *)(v19 + 264) = v20;
        }
      }
    }
    if (v14 >= 1)
    {
      uint64_t v24 = v17 - 1;
      do
      {
        double v25 = *(TRun **)(*(void *)(*(void *)(v12 + 16) + 8 * v24) + 48);
        if (v25 != (TRun *)v19 && !TRun::GetNonDeletedGlyphCount(v25)) {
          TLine::DeleteRun((TLine *)v12, v24);
        }
        uint64_t v26 = v24-- + 1;
      }
      while (v26 > 1);
    }
LABEL_40:
    if ((*(_WORD *)(v12 + 154) & 0x20) != 0) {
      TLine::DoGlyphFixups((TLine *)v12);
    }
  }
  unint64_t v27 = atomic_exchange((atomic_ullong *volatile)&v29, 0);
LABEL_43:

  return v27;
}

void TTypesetter::FillLine(TTypesetter *this, TLine *a2, CFRange a3, double a4, double a5)
{
  double v5 = this;
  long long v6 = *(_OWORD *)((char *)this + 216);
  uint64_t v7 = *((void *)this + 29);
  uint64_t v8 = (char *)this + 240;
  int v9 = *((_DWORD *)this + 65);
  char v10 = *((unsigned char *)this + 264);
  char v11 = *((unsigned char *)this + 257);
  uint64_t v12 = 0;
  TTypesetter::FillLine(&v5, a2, a3, a4, a5);
}

double TParagraphStyle::GetFirstLineHeadIndent(TParagraphStyle **this, const void *a2)
{
  int v2 = *((unsigned __int8 *)this + 8);
  uint64_t v3 = *this;
  if (v2)
  {
    Native = TParagraphStyle::GetNative(v3, a2);
    if (*Native) {
      return *(double *)*Native;
    }
    else {
      return 0.0;
    }
  }
  else
  {
    [(TParagraphStyle *)v3 firstLineHeadIndent];
  }
  return result;
}

id TParagraphStyle::GetLineBreakMode(TParagraphStyle **this, const void *a2)
{
  int v2 = *((unsigned __int8 *)this + 8);
  uint64_t v3 = *this;
  if (v2) {
    return (id)*((unsigned __int8 *)TParagraphStyle::GetNative(v3, a2) + 32);
  }

  return [(TParagraphStyle *)v3 lineBreakMode];
}

double TParagraphStyle::GetTailIndent(TParagraphStyle **this, const void *a2)
{
  int v2 = *((unsigned __int8 *)this + 8);
  uint64_t v3 = *this;
  if (v2)
  {
    Native = TParagraphStyle::GetNative(v3, a2);
    if (*Native) {
      return *(double *)(*Native + 16);
    }
    else {
      return 0.0;
    }
  }
  else
  {
    [(TParagraphStyle *)v3 tailIndent];
  }
  return result;
}

BOOL TFramesetter::ParagraphEndsWith(TFramesetter *this, const TLine *a2, const TCharStream *a3)
{
  uint64_t v3 = *((void *)this + 10) + *((void *)this + 9);
  if (v3 == *((void *)a2 + 2)) {
    return 1;
  }
  uint64_t v7 = *((void *)this + 2);
  uint64_t v6 = *((void *)this + 3);
  uint64_t v8 = v6 - v7;
  if (v6 == v7) {
    return 0;
  }
  uint64_t v10 = v3 - 1;
  RunWithCharIndeCGFloat x = TLine::FindRunWithCharIndex(this, v3 - 1, 1);
  if (RunWithCharIndex >= v8 >> 3) {
    return 0;
  }
  uint64_t v12 = *(void *)(*(void *)(*((void *)this + 2) + 8 * RunWithCharIndex) + 40);
  if ((*(_DWORD *)(*(void *)(*(void *)(v12 + 216) + 40)
                  + 4 * *(void *)(v12 + 200)
                  + 4 * TRun::GetGlyphIndexForCharIndex<false>(v12, v10)) & 2) == 0)
    return 0;

  return TCharStream::IsParagraphSeparator(a2, v10);
}

double TFramesetter::GetHeadIndent(TFramesetter *this, const TAttributes *a2)
{
  if (this)
  {
    int v2 = (TParagraphStyle **)*((void *)this + 16);
    if (a2)
    {
      if (v2) {
        return TParagraphStyle::GetFirstLineHeadIndent(v2, a2);
      }
    }
    else if (v2)
    {
      return TParagraphStyle::GetHeadIndent(v2, a2);
    }
  }
  return 0.0;
}

uint64_t TFramesetter::AppendLine(uint64_t a1, int a2, char a3, int a4, unsigned int a5, CFIndex a6, atomic_ullong *a7, atomic_ullong *a8, double a9, double a10, double a11, uint64_t a12, atomic_ullong *a13)
{
  uint64_t v24 = (const void *)(a5 - 3);
  if (a5 >= 3)
  {
    TruncatedLine = CreateTruncatedLine((uint64_t **)atomic_load_explicit(a7, memory_order_acquire), (int)v24, 0, 0, a9);
    if (!TruncatedLine) {
      return 0;
    }
  }
  double v26 = 0.0;
  if (a1)
  {
    unint64_t v27 = *(TParagraphStyle ***)(a1 + 128);
    if (v27)
    {
      int Alignment = TParagraphStyle::GetAlignment(v27, v24);
      if (a4) {
        int v29 = 4;
      }
      else {
        int v29 = 3;
      }
      if (Alignment != 3) {
        int v29 = Alignment;
      }
      if (v29 == 5)
      {
        LOBYTE(v29) = a3 ^ 1;
LABEL_15:
        if (v29 - 1 >= 2)
        {
          if (v29 == 3)
          {
            CTLineRef JustifiedLine = CTLineCreateJustifiedLine((CTLineRef)atomic_load_explicit(a7, memory_order_acquire), 1.0, a9);
            if (JustifiedLine) {
              TCFRef<__CTFont const*>::Retain(a7, JustifiedLine);
            }
          }
        }
        else
        {
          unint64_t explicit = (const __CTLine *)atomic_load_explicit(a7, memory_order_acquire);
          double v31 = 0.5;
          if (v29 == 1) {
            double v31 = 1.0;
          }
          double PenOffsetForFlush = CTLineGetPenOffsetForFlush(explicit, v31, a9);
          double v26 = PenOffsetForFlush;
          uint64_t v33 = *(void *)(a1 + 120);
          if (v33)
          {
            double v34 = floor(PenOffsetForFlush);
            if ((*(_WORD *)(v33 + 66) & 0x10) != 0) {
              double v26 = v34;
            }
          }
        }
        goto LABEL_26;
      }
      if (v29 != 4) {
        goto LABEL_15;
      }
    }
    LOBYTE(v29) = a3;
    goto LABEL_15;
  }
LABEL_26:
  if (!atomic_load_explicit(a7, memory_order_acquire)) {
    return 0;
  }
  id v36 = (id)atomic_load_explicit(a7, memory_order_acquire);
  CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit(a8, memory_order_acquire), v36);

  double v37 = a10 + v26;
  if (a2) {
    double v38 = a11;
  }
  else {
    double v38 = a10 - v26;
  }
  if (a2) {
    a11 = v37;
  }
  unint64_t v39 = *(void *)(a12 + 16);
  double v40 = *(double **)(a12 + 8);
  if ((unint64_t)v40 >= v39)
  {
    long long v43 = *(double **)a12;
    uint64_t v44 = ((uint64_t)v40 - *(void *)a12) >> 4;
    unint64_t v45 = v44 + 1;
    if ((unint64_t)(v44 + 1) >> 60) {
      abort();
    }
    uint64_t v46 = v39 - (void)v43;
    if (v46 >> 3 > v45) {
      unint64_t v45 = v46 >> 3;
    }
    if ((unint64_t)v46 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v47 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v47 = v45;
    }
    if (v47)
    {
      CFIndex v48 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CGSize>>(a12 + 16, v47);
      long long v43 = *(double **)a12;
      double v40 = *(double **)(a12 + 8);
    }
    else
    {
      CFIndex v48 = 0;
    }
    uint64_t v49 = (double *)&v48[16 * v44];
    double v50 = &v48[16 * v47];
    *uint64_t v49 = a11;
    v49[1] = v38;
    double v41 = v49 + 2;
    if (v40 != v43)
    {
      do
      {
        *((_OWORD *)v49 - 1) = *((_OWORD *)v40 - 1);
        v49 -= 2;
        v40 -= 2;
      }
      while (v40 != v43);
      long long v43 = *(double **)a12;
    }
    *(void *)a12 = v49;
    *(void *)(a12 + 8) = v41;
    *(void *)(a12 + 16) = v50;
    if (v43) {
      operator delete(v43);
    }
  }
  else
  {
    *double v40 = a11;
    v40[1] = v38;
    double v41 = v40 + 2;
  }
  *(void *)(a12 + 8) = v41;
  if (a5 != 2) {
    return 1;
  }
  if (!atomic_load_explicit(a13, memory_order_acquire)) {

  }
  double v51 = (__CFBitVector *)atomic_load_explicit(a13, memory_order_acquire);
  CFIndex Count = CFArrayGetCount((CFArrayRef)atomic_load_explicit(a8, memory_order_acquire));
  CFBitVectorSetCount(v51, Count);
  uint64_t v42 = 1;
  CFBitVectorSetBitAtIndex((CFMutableBitVectorRef)atomic_load_explicit(a13, memory_order_acquire), a6, 1u);
  return v42;
}

uint64_t TParagraphStyle::GetAlignment(TParagraphStyle **this, const void *a2)
{
  int v2 = *((unsigned __int8 *)this + 8);
  uint64_t v3 = *this;
  if (v2)
  {
    LOBYTE(v4) = *((unsigned char *)TParagraphStyle::GetNative(v3, a2) + 33);
  }
  else
  {
    unsigned int v5 = [(TParagraphStyle *)v3 alignment];
    unint64_t v4 = 0x403010200uLL >> (8 * v5);
    if (v5 >= 5) {
      LOBYTE(v4) = v5;
    }
  }
  return v4;
}

void TFrame::SetLines(uint64_t a1, void *a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(void *)a1 = a5;
  *(void *)(a1 + 8) = a6;
  *(void *)(a1 + 16) = a7;
  *(void *)(a1 + 24) = a8;
  TCFRef<__CTFont const*>::Retain((atomic_ullong *)(a1 + 104), a2);
  if (a1 + 112 != a3) {
    std::vector<CGPoint>::__assign_with_size[abi:nn180100]<CGPoint*,CGPoint*>((char *)(a1 + 112), *(char **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 4);
  }

  TCFRef<__CTFont const*>::Retain((atomic_ullong *)(a1 + 136), a4);
}

char *std::vector<CGPoint>::__assign_with_size[abi:nn180100]<CGPoint*,CGPoint*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  int v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 4)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *uint64_t v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 60) {
      abort();
    }
    uint64_t v10 = v8 >> 3;
    if (v8 >> 3 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v11 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    double result = std::vector<CGSize>::__vallocate[abi:nn180100](v7, v11);
    double v13 = (char *)v7[1];
    uint64_t v12 = (void **)(v7 + 1);
    int v9 = v13;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      uint64_t v18 = v9;
      uint64_t v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  uint64_t v12 = (void **)(result + 8);
  uint64_t v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 4;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  uint64_t v16 = &__src[16 * v15];
  if (v14 != v9)
  {
    double result = (char *)memmove(*(void **)result, __src, v14 - v9);
    int v9 = (char *)*v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    uint64_t v18 = v9;
    uint64_t v19 = v16;
LABEL_18:
    double result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *uint64_t v12 = &v9[v17];
  return result;
}

char *std::vector<CGSize>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >> 60) {
    abort();
  }
  double result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CGSize>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v4];
  return result;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<CGSize>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(16 * a2);
}

CTFrameRef CTFramesetterCreateFrame(CTFramesetterRef framesetter, CFRange stringRange, CGPathRef path, CFDictionaryRef frameAttributes)
{
  uint64_t v4 = 0;
  if (framesetter && path)
  {
    CFIndex length = stringRange.length;
    locatioCFIndex n = stringRange.location;
    int v9 = (TFramesetter *)*((void *)framesetter + 5);
    CFIndex v10 = *(void *)(*(void *)((*(uint64_t (**)(TFramesetter *))(*(void *)v9 + 16))(v9) + 216) + 16);
    if (location + length > v10)
    {
      return 0;
    }
    else
    {
      uint64_t v11 = v10 - location;
      uint64_t v16 = -1;
      memset(&v15[1], 0, 32);
      if (length) {
        uint64_t v12 = length;
      }
      else {
        uint64_t v12 = v11;
      }
      v15[0] = 0uLL;
      TFramesetter::CreateFrame(v9, location, v12, path, frameAttributes, (double *)&v16, (uint64_t)v15, (unint64_t *)&v14);
      uint64_t v4 = (const __CTFrame *)atomic_exchange((atomic_ullong *volatile)&v14, 0);
    }
  }
  return v4;
}

void TFramesetter::CreateFrame(TFramesetter *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X3>, const __CFDictionary *a5@<X4>, double *a6@<X5>, uint64_t a7@<X6>, unint64_t *a8@<X8>)
{
  CFDictionaryRef v17 = a5;
  uint64_t v18 = a4;
  *a6 = 0.0;
  id v16 = (id)0xAAAAAAAAAAAAAAAALL;
  TCFBase_NEW<CTFrame,CGPath const*&,__CFDictionary const*&>(&v18, &v17, &v16);
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&v16, memory_order_acquire);
  if (explicit)
  {
    unint64_t v15 = *(TFrame **)(atomic_load_explicit((atomic_ullong *volatile)&v16, memory_order_acquire) + 40);
    if (*((unsigned char *)v15 + 32))
    {
      TFramesetter::FrameInRect((uint64_t)a1, (uint64_t)v15, a2, a3, a6, a7);
    }
    else
    {
      v19.locatioCFIndex n = a2;
      v19.CFIndex length = a3;
      TFramesetter::FrameInPath(a1, v15, v19);
    }
    unint64_t explicit = atomic_exchange((atomic_ullong *volatile)&v16, 0);
  }
  *a8 = explicit;
}

void TCFBase_NEW<CTFrame,CGPath const*&,__CFDictionary const*&>(void **a1@<X0>, const __CFDictionary **a2@<X1>, void *a3@<X8>)
{
  uint64_t v6 = TCFBase<TFrame>::Allocate();
  if (v6)
  {
    uint64_t v7 = (void *)v6;
    uint64_t v8 = *a1;
    CFDictionaryRef v9 = *a2;
    CFIndex v10 = (TFrame *)(v6 + 48);
    v7[2] = 0;
    v7[3] = 0;
    v7[4] = 0;
    v7[5] = v10;
    TFrame::TFrame(v10, v8, v9);
    id v11 = v7;
    *a3 = atomic_exchange((atomic_ullong *volatile)&v11, 0);
  }
  else
  {
    *a3 = 0;
  }
}

uint64_t TCFBase<TFrame>::Allocate()
{
  if (TCFBase<TFrame>::GetTypeID(void)::once != -1) {
    dispatch_once_f(&TCFBase<TFrame>::GetTypeID(void)::once, 0, (dispatch_function_t)TCFBase<TFrame>::GetTypeID(void)::{lambda(void *)#1}::__invoke);
  }

  return _CFRuntimeCreateInstance();
}

void TFrame::TFrame(TFrame *this, id a2, const __CFDictionary *a3)
{
  *((_DWORD *)this + 9) = 0;
  *((void *)this + 5) = 0;
  unsigned int v5 = (double *)((char *)this + 40);
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((void *)this + 10) = a2;
  CFDictionaryRef v6 = a3;
  *((void *)this + 19) = -1;
  *((void *)this + 11) = v6;
  *((_OWORD *)this + 6) = 0u;
  uint64_t v7 = (atomic_ullong *)((char *)this + 96);
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_DWORD *)this + 36) = 0;
  *((_WORD *)this + 80) = 256;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB2CDEF8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB2CDEF8))
  {
    _MergedGlobals_7 = 1;
    __cxa_guard_release(&qword_1EB2CDEF8);
  }
  *((unsigned char *)this + 162) = _MergedGlobals_7;
  *((unsigned char *)this + 163) = 0;
  if (atomic_load_explicit((atomic_ullong *volatile)this + 11, memory_order_acquire))
  {
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)this + 11, memory_order_acquire), @"CTFrameProgression");
    if (Value)
    {
      LODWORD(valuePtr) = -1431655766;
      CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
      *((_DWORD *)this + 36) = valuePtr;
    }
    CFNumberRef v9 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)this + 11, memory_order_acquire), @"CTFramePathFillRule");
    if (v9)
    {
      LODWORD(valuePtr) = -1431655766;
      CFNumberGetValue(v9, kCFNumberIntType, &valuePtr);
      *((_DWORD *)this + 9) = valuePtr;
    }
    CFNumberRef v10 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)this + 11, memory_order_acquire), @"CTFramePathWidth");
    if (v10)
    {
      CFNumberGetValue(v10, kCFNumberDoubleType, v5);
      if (*v5 < 0.0) {
        double *v5 = 0.0;
      }
    }
    id v11 = (void *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)this + 11, memory_order_acquire), @"CTFrameClippingPaths");
    TCFRef<__CTFont const*>::Retain((atomic_ullong *)this + 12, v11);
    if (!atomic_load_explicit((atomic_ullong *volatile)this + 12, memory_order_acquire))
    {
      unint64_t v15 = CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)this + 11, memory_order_acquire), @"CTFramePathClippingPath");
      if (v15)
      {
        id v16 = v15;
        CFTypeID v17 = CFGetTypeID(v15);
        if (v17 == CGPathGetTypeID())
        {
          int v29 = v16;
          __int16 valuePtr = @"CTFramePathClippingPath";
          CFAllocatorRef v18 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          CFDictionaryRef v19 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&valuePtr, &v29, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          __int16 valuePtr = (__CFString *)v19;
          CFArrayRef v20 = CFArrayCreate(v18, (const void **)&valuePtr, 1, MEMORY[0x1E4F1D510]);
          TCFRef<__CTFont const*>::Retain((atomic_ullong *)this + 12, v20);
        }
        else
        {
          CFLog();
        }
      }
    }
    CFArrayRef v12 = (const __CFArray *)(id)atomic_load_explicit(v7, memory_order_acquire);
    if (v12)
    {
      CFArrayRef v13 = v12;
      CFIndex Count = CFArrayGetCount(v12);

      if (Count >= 1) {
        *((unsigned char *)this + 32) = 0;
      }
    }
    else
    {
    }
    CFNumberRef v21 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)this + 11, memory_order_acquire), @"CTFrameMaximumNumberOfLines");
    if (v21) {
      CFNumberGetValue(v21, kCFNumberLongType, (char *)this + 152);
    }
    CFBooleanRef v22 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)this + 11, memory_order_acquire), @"CTFrameHangingDescenders");
    if (v22) {
      *((unsigned char *)this + 160) = CFBooleanGetValue(v22) != 0;
    }
    CFBooleanRef v23 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)this + 11, memory_order_acquire), @"CTFrameHangingLeading");
    if (v23) {
      *((unsigned char *)this + 161) = CFBooleanGetValue(v23) != 0;
    }
    CFBooleanRef v24 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)this + 11, memory_order_acquire), @"CTFrameIntegerLineMetrics");
    if (v24) {
      *((unsigned char *)this + 162) = CFBooleanGetValue(v24) != 0;
    }
    CFBooleanRef v25 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)this + 11, memory_order_acquire), @"CTFrameForceNonRectPath");
    if (v25) {
      *((unsigned char *)this + 163) = CFBooleanGetValue(v25) != 0;
    }
  }
  CFArrayRef v26 = (const __CFArray *)(id)atomic_load_explicit(v7, memory_order_acquire);
  CFArrayRef v27 = v26;
  BOOL v28 = (!v26 || !CFArrayGetCount(v26))
     && !*((unsigned char *)this + 163)
     && CGPathIsRect((CGPathRef)atomic_load_explicit((atomic_ullong *volatile)this + 10, memory_order_acquire), (CGRect *)((char *)this + 48));
  *((unsigned char *)this + 32) = v28;

  if (!*((unsigned char *)this + 32)) {
    *(CGRect *)((char *)this + 48) = CGPathGetBoundingBox((CGPathRef)atomic_load_explicit((atomic_ullong *volatile)this + 10, memory_order_acquire));
  }
}

const void *TFrame::GetLineAtIndex(atomic_ullong *this, CFIndex a2)
{
  CFArrayRef v3 = (const __CFArray *)(id)atomic_load_explicit(this + 13, memory_order_acquire);
  CFArrayRef v4 = v3;
  if (v3) {
    CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v3, a2);
  }
  else {
    CFDictionaryRef ValueAtIndex = 0;
  }

  return ValueAtIndex;
}

CGRect CTLineGetBoundsWithOptions(CTLineRef line, CTLineBoundsOptions options)
{
  if (line)
  {
    double Bounds = TLine::GetBounds(*((TLine **)line + 5), options);
  }
  else
  {
    double Bounds = *MEMORY[0x1E4F1DB20];
    double v3 = *(double *)(MEMORY[0x1E4F1DB20] + 8);
    double v4 = *(double *)(MEMORY[0x1E4F1DB20] + 16);
    double v5 = *(double *)(MEMORY[0x1E4F1DB20] + 24);
  }
  result.size.CGFloat height = v5;
  result.size.CGFloat width = v4;
  result.origin.CGFloat y = v3;
  result.origin.CGFloat x = Bounds;
  return result;
}

double TLine::GetBounds(TLine *this, unint64_t a2)
{
  unint64_t v2 = a2;
  v74[0] = a2;
  uint64_t v4 = *((void *)this + 2);
  uint64_t v5 = *((void *)this + 3) - v4;
  if ((a2 & 0x40) != 0 && v5 >= 1)
  {
    unint64_t v6 = a2 & 0xFFFFFFFFFFFFFFE3;
    uint64_t v7 = *(TParagraphStyle ***)(*(void *)(*(void *)v4 + 40) + 168);
    if (v7) {
      unint64_t v8 = (unint64_t)TParagraphStyle::GetLineBoundsOptions(v7, (const void *)a2) & 0x1C;
    }
    else {
      unint64_t v8 = 0;
    }
    unint64_t v2 = v8 | v6;
    v74[0] = v2;
  }
  if ((v2 & 0x18) == 8)
  {
    if ((v2 & 4) != 0)
    {
      v62[0] = 4;
      CFIndex LeftHangersGlyphCountAndWidth = TLine::GetLeftHangersGlyphCountAndWidth(this, v62);
      v10.CFIndex length = *((void *)this + 18)
                 - (TLine::GetRightHangersGlyphCountAndWidth(this, v62)
                  + LeftHangersGlyphCountAndWidth);
      CFNumberRef v9 = this;
      v10.locatioCFIndex n = LeftHangersGlyphCountAndWidth;
    }
    else
    {
      v10.CFIndex length = *((void *)this + 18);
      CFNumberRef v9 = this;
      v10.locatioCFIndex n = 0;
    }
    return TLine::GetImageBounds(v9, 0, v10);
  }
  if ((v2 & 0x20) != 0)
  {
    v2 |= 2uLL;
    v74[0] = v2;
  }
  double v11 = 0.0;
  if (v5 < 1 || (uint64_t v12 = *((void *)this + 2), v13 = *((void *)this + 3), v12 == v13))
  {
    int v14 = 0;
    double v23 = 0.0;
    CGFloat v56 = NAN;
    CGFloat v57 = NAN;
    CGFloat v52 = NAN;
    CGFloat r1a = NAN;
    double v55 = 0.0;
    double v59 = 0.0;
    double v61 = 0.0;
    double v20 = 0.0;
    double v19 = 0.0;
    double v18 = 0.0;
  }
  else
  {
    uint64_t v50 = v5;
    int v14 = 0;
    CGFloat x = NAN;
    CGFloat height = NAN;
    __int16 v17 = *((_WORD *)this + 76);
    double v18 = 0.0;
    double v19 = 0.0;
    double v20 = 0.0;
    double v21 = 0.0;
    double v22 = 0.0;
    double v55 = 0.0;
    CGFloat v56 = NAN;
    CGFloat v57 = NAN;
    double v23 = 0.0;
    do
    {
      CFBooleanRef v24 = *(atomic_ullong **)(*(void *)v12 + 40);
      CFBooleanRef v25 = *(TFont **)(atomic_load_explicit(v24 + 7, memory_order_acquire) + 40);
      v62[0] = -1;
      double v72 = NAN;
      double v73 = NAN;
      TFont::GetDefaultMetrics(v25, (double *)v62, &v73, &v72);
      if ((v74[0] & 2) != 0)
      {
        if ((v74[0] & 0x20) != 0)
        {
          id v71 = (id)0xAAAAAAAAAAAAAAAALL;
          TAttributes::OriginalFont(v24 + 5, (atomic_ullong *)&v71);
          double v69 = NAN;
          double v70 = NAN;
          double v67 = NAN;
          double v68 = NAN;
          if (CTFontGetLanguageAwareOutsetsForLanguage((void *)atomic_load_explicit((atomic_ullong *volatile)&v71, memory_order_acquire), &v70, &v69, &v68, &v67))
          {
            BOOL v28 = *(int **)(atomic_load_explicit((atomic_ullong *volatile)&v71, memory_order_acquire) + 40);
            int v29 = v28 + 12;
            inited = v28 + 12;
            if (!v28[12]) {
              inited = TFont::InitStrikeMetrics((TFont *)v28);
            }
            if (v21 < *((double *)inited + 1) + v69) {
              double v21 = *((double *)inited + 1) + v69;
            }
            if (!*v29) {
              int v29 = TFont::InitStrikeMetrics((TFont *)v28);
            }
            if (v22 < *((double *)v29 + 2) + v67) {
              double v22 = *((double *)v29 + 2) + v67;
            }
            double v31 = v55;
            if (v55 < v70) {
              double v31 = v70;
            }
            double v55 = v31;
            if (v23 < v68) {
              double v23 = v68;
            }
          }
          double v65 = NAN;
          double v66 = NAN;
          if (TFont::GetWinMetrics((TBaseFont **)v25, &v66, &v65))
          {
            if (v21 < v66) {
              double v21 = v66;
            }
            if (v22 < v65) {
              double v22 = v65;
            }
          }
          id v64 = (id)0xAAAAAAAAAAAAAAAALL;
          (*(void (**)(id *__return_ptr, atomic_ullong *))(*v24 + 128))(&v64, v24);
          double v58 = v21;
          double v60 = v22;
          if (atomic_load_explicit((atomic_ullong *volatile)&v64, memory_order_acquire))
          {
            double v51 = v23;
            CGFloat r1 = height;
            CGFloat v32 = x;
            BoundingBoCGFloat x = CGPathGetBoundingBox((CGPathRef)atomic_load_explicit((atomic_ullong *volatile)&v64, memory_order_acquire));
            CGFloat x = BoundingBox.origin.x;
            CGFloat y = BoundingBox.origin.y;
            CGFloat width = BoundingBox.size.width;
            CGFloat height = BoundingBox.size.height;
            if (v14)
            {
              v76.origin.CGFloat x = v32;
              v76.size.CGFloat width = v56;
              v76.origin.CGFloat y = v57;
              v76.size.CGFloat height = r1;
              v80.origin.CGFloat x = x;
              v80.origin.CGFloat y = y;
              v80.size.CGFloat width = width;
              v80.size.CGFloat height = height;
              CGRect v77 = CGRectUnion(v76, v80);
              CGFloat x = v77.origin.x;
              CGFloat y = v77.origin.y;
              CGFloat width = v77.size.width;
              CGFloat height = v77.size.height;
            }
            int v14 = 1;
            double v23 = v51;
          }
          else
          {
            CGFloat width = v56;
            CGFloat y = v57;
          }

          CGFloat v56 = width;
          CGFloat v57 = y;
          double v21 = v58;
          double v22 = v60;
        }
      }
      else
      {
        CrossStreamMinMaCGFloat x = TRun::GetCrossStreamMinMax((TRun *)v24);
        *(double *)uint64_t v62 = *(double *)v62 + v27;
        double v73 = v73 - CrossStreamMinMax;
      }
      if ((v17 & 0x20) != 0) {
        double v35 = (*(double (**)(atomic_ullong *))(*v24 + 56))(v24);
      }
      else {
        double v35 = *(double *)v62;
      }
      if (v18 < v35) {
        double v18 = v35;
      }
      if (v19 < v73) {
        double v19 = v73;
      }
      if (v20 < v72) {
        double v20 = v72;
      }
      v12 += 8;
    }
    while (v12 != v13);
    double v59 = v21;
    double v61 = v22;
    CGFloat v52 = x;
    CGFloat r1a = height;
    LOBYTE(v2) = v74[0];
    uint64_t v5 = v50;
    double v11 = 0.0;
  }
  if (v2) {
    double v36 = -v19;
  }
  else {
    double v36 = -(v20 + v19);
  }
  if (v2) {
    double v37 = v19 + v18;
  }
  else {
    double v37 = v20 + v19 + v18;
  }
  double v38 = *((double *)this + 13);
  TLine::GetLeftHangersGlyphCountAndWidth(this, 0);
  if (v39 != 0.0) {
    double v11 = 0.0 - v39;
  }
  if ((v2 & 0x14) != 0)
  {
    TLine::GetLeftHangersGlyphCountAndWidth(this, v74);
    double v11 = v11 + v40;
    double v41 = v38 - v40;
    TLine::GetRightHangersGlyphCountAndWidth(this, v74);
    double v38 = v41 - v42;
  }
  else if ((v2 & 0xA0) != 0)
  {
    TLine::GetTrailingWhitespace((uint64_t)this, (double *)v62);
    double v38 = v38 - v63;
    if ((*((_WORD *)this + 76) & 8) != 0)
    {
      double v11 = v11 + v63;
    }
    else if (v5 >= 1 && (v2 & 0x20) == 0)
    {
      uint64_t v46 = *(int **)(atomic_load_explicit((atomic_ullong *volatile)(*(void *)(*(void *)(*((void *)this + 3) - 8) + 40) + 56), memory_order_acquire)+ 40);
      double UnscaledTrackAmount = TFont::GetUnscaledTrackAmount((TFont *)v46);
      if (UnscaledTrackAmount != 0.0)
      {
        double v48 = UnscaledTrackAmount;
        if (v46[12]) {
          uint64_t v49 = v46 + 12;
        }
        else {
          uint64_t v49 = TFont::InitStrikeMetrics((TFont *)v46);
        }
        double v38 = v38 - v48 * *((double *)v49 + 5);
      }
    }
  }
  if ((v74[0] & 0x20) != 0)
  {
    v81.origin.CGFloat x = v11 - v55;
    v81.origin.CGFloat y = -v61;
    v81.size.CGFloat width = v23 + v55 + v38;
    v81.size.CGFloat height = v61 + v59;
    v78.origin.CGFloat x = v11;
    v78.origin.CGFloat y = v36;
    v78.size.CGFloat width = v38;
    v78.size.CGFloat height = v37;
    CGRect v79 = CGRectUnion(v78, v81);
    double v11 = v79.origin.x;
    if (v14)
    {
      v82.origin.CGFloat x = v52;
      v82.size.CGFloat height = r1a;
      v82.size.CGFloat width = v56;
      v82.origin.CGFloat y = v57;
      *(void *)&double v43 = (unint64_t)CGRectUnion(v79, v82);
      return v43;
    }
  }
  return v11;
}

double TRun::GetCrossStreamMinMax(TRun *this)
{
  uint64_t v1 = *((void *)this + 39);
  if (v1) {
    return *(double *)(v1 + 16);
  }
  else {
    return 0.0;
  }
}

uint64_t TFramesetter::GetLineMetrics(uint64_t this, TLine *a2, const void *a3, int a4, int a5, int a6)
{
  uint64_t v6 = *((void *)a2 + 15);
  if (*((double *)a2 + 16) == -1.79769313e308) {
    double v7 = 0.0;
  }
  else {
    double v7 = *((double *)a2 + 16);
  }
  *(void *)this = *((void *)a2 + 14);
  *(void *)(this + 8) = v6;
  *(double *)(this + 16) = v7;
  *(void *)(this + 24) = 0;
  *(void *)(this + 32) = 0;
  *(void *)(this + 40) = v6;
  uint64_t v8 = *((void *)a2 + 2);
  uint64_t v9 = *((void *)a2 + 3);
  uint64_t v10 = v9 - v8;
  if (v9 != v8)
  {
    uint64_t v13 = (float64x2_t *)this;
    uint64_t v14 = *(void *)(*(void *)v8 + 40);
    uint64_t rect_8 = v14 + 40;
    unint64_t v15 = *(TParagraphStyle ***)(v14 + 168);
    if (v15
      && (unint64_t LineBoundsOptions = (unint64_t)TParagraphStyle::GetLineBoundsOptions(v15, a2),
          unint64_t v17 = LineBoundsOptions,
          (LineBoundsOptions & 0x20) != 0))
    {
      double Bounds = TLine::GetBounds(a2, LineBoundsOptions | 1);
      CGFloat v31 = v30;
      CGFloat v33 = v32;
      CGFloat v35 = v34;
      double rect = TLine::GetBounds(a2, v17 & 0xFFFFFFFFFFFFFFFELL);
      CGFloat v37 = v36;
      CGFloat v39 = v38;
      CGFloat v41 = v40;
      v54.origin.CGFloat x = Bounds;
      v54.origin.CGFloat y = v31;
      v54.size.CGFloat width = v33;
      v54.size.CGFloat height = v35;
      v13->f64[0] = CGRectGetMaxY(v54);
      v55.origin.CGFloat x = Bounds;
      v55.origin.CGFloat y = v31;
      v55.size.CGFloat width = v33;
      v55.size.CGFloat height = v35;
      double v42 = fabs(CGRectGetMinX(v55));
      v13->f64[1] = v42;
      v13[2].f64[1] = v42;
      v56.origin.CGFloat x = rect;
      v56.origin.CGFloat y = v37;
      v56.size.CGFloat width = v39;
      v56.size.CGFloat height = v41;
      double v43 = fabs(CGRectGetMinX(v56)) - v42;
      if (v43 < 0.0) {
        double v43 = 0.0;
      }
      double v44 = -0.0;
      if (v7 < 0.0) {
        double v44 = v7;
      }
      v13[1].f64[0] = v44 + v43;
    }
    else if (v10 >= 1)
    {
      uint64_t v18 = 0;
      uint64_t v19 = v10 >> 3;
      if (v10 >> 3 <= 1) {
        uint64_t v19 = 1;
      }
      uint64_t v20 = 8 * v19;
      do
      {
        double v21 = *(atomic_ullong **)(*(void *)(*((void *)a2 + 2) + v18) + 40);
        atomic_ullong v22 = v21[20];
        if (v22) {
          double v23 = *(double *)(v22 + 48);
        }
        else {
          double v23 = 0.0;
        }
        CFBooleanRef v24 = *(atomic_ullong **)(atomic_load_explicit(v21 + 7, memory_order_acquire) + 40);
        double v52 = NAN;
        double v53 = NAN;
        double v51 = NAN;
        if (TFont::IsSystemUIFontAndForShaping(v24, (BOOL *)&v50))
        {
          id v50 = (id)0xAAAAAAAAAAAAAAAALL;
          TAttributes::OriginalFont(v21 + 5, (atomic_ullong *)&v50);
          if (atomic_load_explicit((atomic_ullong *volatile)&v50, memory_order_acquire))
          {
            TFont::GetDefaultMetrics(*(TFont **)(atomic_load_explicit((atomic_ullong *volatile)&v50, memory_order_acquire) + 40), &v53, &v52, &v51);
            v25.f64[0] = v23 + v53;
            v25.f64[1] = v52 - v23;
            *(int8x16_t *)uint64_t v13 = vbslq_s8((int8x16_t)vcgtq_f64(v25, *v13), (int8x16_t)v25, *(int8x16_t *)v13);
            double v26 = v13[1].f64[0];
            if (v26 < v51) {
              double v26 = v51;
            }
            v13[1].f64[0] = v26;
          }
        }
        TFont::GetDefaultMetrics((TFont *)v24, &v53, &v52, &v51);
        v27.f64[0] = v23 + v53;
        v27.f64[1] = v52 - v23;
        *(int8x16_t *)uint64_t v13 = vbslq_s8((int8x16_t)vcgtq_f64(v27, *v13), (int8x16_t)v27, *(int8x16_t *)v13);
        double v28 = v13[1].f64[0];
        if (v28 < v51) {
          double v28 = v51;
        }
        v13[1].f64[0] = v28;
        v18 += 8;
      }
      while (v20 != v18);
    }
    return ApplyParagraphStyleSettings(rect_8, a3, a4, a5, a6, v13, (uint64_t)a2);
  }
  return this;
}

double *TFont::GetDefaultMetrics(TFont *this, double *a2, double *a3, double *a4)
{
  if (*((_DWORD *)this + 12)) {
    CGRect result = (double *)((char *)this + 48);
  }
  else {
    CGRect result = (double *)TFont::InitStrikeMetrics(this);
  }
  double v10 = result[1];
  double v9 = result[2];
  uint64_t v11 = *((void *)result + 3);
  if (*((unsigned char *)result + 88) && (*(unsigned char *)this & 1) == 0)
  {
    CGRect result = (double *)GetTable();
    if (result) {
      double v12 = result[12];
    }
    else {
      double v12 = 0.0;
    }
    if (v12 == 0.0) {
      double v12 = 0.2;
    }
    double v10 = v10 + (v10 + v9) * v12;
  }
  *a2 = v10;
  *a3 = v9;
  *(void *)a4 = v11;
  return result;
}

uint64_t ApplyParagraphStyleSettings(uint64_t a1, const void *a2, int a3, int a4, int a5, float64x2_t *a6, uint64_t a7)
{
  char v12 = (char)a2;
  if (a5)
  {
    __asm { FMOV            V1.2D, #0.5 }
    *a6 = vrndmq_f64(vaddq_f64(*a6, _Q1));
    double v18 = a6[1].f64[0];
    double v19 = floor(v18 + 0.5);
    if (v18 > 0.0) {
      double v18 = v19;
    }
    a6[1].f64[0] = v18;
    if ((dyld_program_sdk_at_least() & 1) == 0) {
      a6[2].f64[1] = a6->f64[1];
    }
  }
  uint64_t v20 = *(TParagraphStyle ***)(a1 + 128);
  double v21 = 0.0;
  double v22 = 0.0;
  double v23 = 0.0;
  double v24 = 0.0;
  if (!v20) {
    goto LABEL_38;
  }
  double LineHeightMultiple = TParagraphStyle::GetLineHeightMultiple(v20, a2);
  float64x2_t v27 = *(TParagraphStyle ***)(a1 + 128);
  double v23 = LineHeightMultiple >= 0.0 ? LineHeightMultiple : 0.0;
  if (v27
    && ((double MaximumLineHeight = TParagraphStyle::GetMaximumLineHeight(v27, v25),
         double v30 = *(TParagraphStyle ***)(a1 + 128),
         MaximumLineHeight >= 0.0)
      ? (double v24 = MaximumLineHeight)
      : (double v24 = 0.0),
        v30
     && ((double MinimumLineHeight = TParagraphStyle::GetMinimumLineHeight(v30, v28),
          CGFloat v33 = *(TParagraphStyle ***)(a1 + 128),
          double ParagraphSpacingBefore = 0.0,
          MinimumLineHeight >= 0.0)
       ? (double v22 = MinimumLineHeight)
       : (double v22 = 0.0),
         v33)))
  {
    double LineSpacingAdjustment = TParagraphStyle::GetLineSpacingAdjustment(v33, v31);
    uint64_t v37 = *(void *)(a1 + 128);
    f64 = a6[1].f64;
    double v39 = LineSpacingAdjustment + a6[1].f64[0];
    a6[1].f64[0] = v39;
    double v40 = 10000000.0;
    if (v37)
    {
      double v41 = 0.0;
      if (*(unsigned char *)(v37 + 8))
      {
        uint64_t v42 = TParagraphStyle::GetNative(*(TParagraphStyle **)v37, v35)[1];
        double v41 = 0.0;
        if (v42) {
          double v41 = *(double *)(v42 + 40);
        }
      }
      if (v41 >= v39 && v41 != 0.0) {
        double v39 = v41;
      }
      uint64_t v44 = *(void *)(a1 + 128);
      if (v44)
      {
        double v40 = 10000000.0;
        if (*(unsigned char *)(v44 + 8))
        {
          uint64_t v45 = TParagraphStyle::GetNative(*(TParagraphStyle **)v44, v35)[1];
          if (v45) {
            double v40 = *(double *)(v45 + 32);
          }
        }
        uint64_t v46 = *(TParagraphStyle ***)(a1 + 128);
        if (v46)
        {
          double ParagraphSpacing = TParagraphStyle::GetParagraphSpacing(v46, v35);
          uint64_t v49 = *(TParagraphStyle ***)(a1 + 128);
          double v21 = ParagraphSpacing >= 0.0 ? ParagraphSpacing : 0.0;
          if (v49) {
            double ParagraphSpacingBefore = TParagraphStyle::GetParagraphSpacingBefore(v49, v47);
          }
        }
      }
    }
  }
  else
  {
LABEL_38:
    f64 = a6[1].f64;
    double v39 = a6[1].f64[0] + 0.0;
    a6[1].f64[0] = v39;
    double v40 = 10000000.0;
    double ParagraphSpacingBefore = 0.0;
  }
  if (ParagraphSpacingBefore < 0.0) {
    double ParagraphSpacingBefore = 0.0;
  }
  double v50 = a6->f64[0];
  double v51 = a6->f64[1];
  if (v23 > 0.0)
  {
    double v50 = v50 - (v50 + v51 - v23 * (v50 + v51));
    a6->f64[0] = v50;
  }
  double v52 = v51 + v50;
  BOOL v53 = v52 <= v24 || v24 <= 0.0;
  double v54 = v52 - v24;
  if (v53) {
    double v54 = 0.0;
  }
  if (v52 >= v22 || v22 <= 0.0) {
    double v56 = v54;
  }
  else {
    double v56 = v52 - v22;
  }
  uint64_t result = dyld_program_sdk_at_least();
  if ((result & 1) == 0)
  {
    a6->f64[0] = a6->f64[0] - v56;
    goto LABEL_65;
  }
  if (v56 == 0.0)
  {
    if (a7)
    {
      double v62 = a6[2].f64[1];
      if (v62 != a6->f64[1]) {
        goto LABEL_64;
      }
    }
  }
  else
  {
    double v58 = v56 * 0.5;
    double v59 = floor(v56 * 0.5 + 0.5);
    if (a5) {
      double v58 = v59;
    }
    double v60 = a6->f64[0] - v58;
    float64_t v61 = a6->f64[1] - (v56 - v58);
    a6->f64[0] = v60;
    a6->f64[1] = v61;
    a6[2].f64[1] = v61;
    if (a7)
    {
      *(double *)(a7 + 112) = v60;
      double v62 = a6->f64[1];
LABEL_64:
      *(double *)(a7 + 120) = v62;
    }
  }
LABEL_65:
  double v63 = *f64;
  if (*f64 < v39) {
    double v63 = v39;
  }
  if (v40 < v63) {
    double v63 = v40;
  }
  double *f64 = v63;
  if (a3 && (v12 & 1) == 0) {
    a6[1].f64[1] = ParagraphSpacingBefore;
  }
  if (a4) {
    a6[2].f64[0] = v21;
  }
  return result;
}

double TParagraphStyle::GetParagraphSpacingBefore(TParagraphStyle **this, const void *a2)
{
  int v2 = *((unsigned __int8 *)this + 8);
  double v3 = *this;
  if (v2)
  {
    uint64_t v4 = TParagraphStyle::GetNative(v3, a2)[1];
    if (v4) {
      return *(double *)(v4 + 56);
    }
    else {
      return 0.0;
    }
  }
  else
  {
    [(TParagraphStyle *)v3 paragraphSpacingBefore];
  }
  return result;
}

double TParagraphStyle::GetLineSpacingAdjustment(TParagraphStyle **this, const void *a2)
{
  int v2 = *((unsigned __int8 *)this + 8);
  double v3 = *this;
  if (v2)
  {
    uint64_t v4 = TParagraphStyle::GetNative(v3, a2)[1];
    if (v4) {
      return *(double *)(v4 + 24);
    }
    else {
      return 0.0;
    }
  }
  else
  {
    [(TParagraphStyle *)v3 lineSpacing];
  }
  return result;
}

double TParagraphStyle::GetLineHeightMultiple(TParagraphStyle **this, const void *a2)
{
  int v2 = *((unsigned __int8 *)this + 8);
  double v3 = *this;
  if (v2)
  {
    uint64_t v4 = TParagraphStyle::GetNative(v3, a2)[1];
    if (v4) {
      return *(double *)v4;
    }
    else {
      return 0.0;
    }
  }
  else
  {
    [(TParagraphStyle *)v3 lineHeightMultiple];
  }
  return result;
}

double TParagraphStyle::GetMinimumLineHeight(TParagraphStyle **this, const void *a2)
{
  int v2 = *((unsigned __int8 *)this + 8);
  double v3 = *this;
  if (v2)
  {
    uint64_t v4 = TParagraphStyle::GetNative(v3, a2)[1];
    if (v4) {
      return *(double *)(v4 + 16);
    }
    else {
      return 0.0;
    }
  }
  else
  {
    [(TParagraphStyle *)v3 minimumLineHeight];
  }
  return result;
}

double TParagraphStyle::GetMaximumLineHeight(TParagraphStyle **this, const void *a2)
{
  int v2 = *((unsigned __int8 *)this + 8);
  double v3 = *this;
  if (v2)
  {
    uint64_t v4 = TParagraphStyle::GetNative(v3, a2)[1];
    if (v4) {
      return *(double *)(v4 + 8);
    }
    else {
      return 0.0;
    }
  }
  else
  {
    [(TParagraphStyle *)v3 maximumLineHeight];
  }
  return result;
}

double TParagraphStyle::GetParagraphSpacing(TParagraphStyle **this, const void *a2)
{
  int v2 = *((unsigned __int8 *)this + 8);
  double v3 = *this;
  if (v2)
  {
    uint64_t v4 = TParagraphStyle::GetNative(v3, a2)[1];
    if (v4) {
      return *(double *)(v4 + 48);
    }
    else {
      return 0.0;
    }
  }
  else
  {
    [(TParagraphStyle *)v3 paragraphSpacing];
  }
  return result;
}

double TLine::GetImageBounds(TLine *this, CGContext *a2, CFRange a3)
{
  double v4 = *MEMORY[0x1E4F1DB28];
  CGFloat v3 = *(double *)(MEMORY[0x1E4F1DB28] + 8);
  CGFloat v6 = *(double *)(MEMORY[0x1E4F1DB28] + 16);
  CGFloat v5 = *(double *)(MEMORY[0x1E4F1DB28] + 24);
  uint64_t v7 = *((void *)this + 2);
  uint64_t v8 = *((void *)this + 3) - v7;
  if (v8 >= 1)
  {
    CFIndex length = a3.length;
    uint64_t v12 = (unint64_t)v8 >> 3;
    uint64_t v13 = *(void **)(*(void *)v7 + 40);
    uint64_t v14 = (double *)v13[39];
    unint64_t v15 = (double *)MEMORY[0x1E4F1DB30];
    if (!v14) {
      uint64_t v14 = (double *)MEMORY[0x1E4F1DB30];
    }
    double v16 = *v14;
    double v32 = v14[1];
    double v33 = v16;
    if (v12 <= 1) {
      uint64_t v17 = 1;
    }
    else {
      uint64_t v17 = v12;
    }
    uint64_t v18 = 1;
    while (1)
    {
      CFIndex v19 = v13[26];
      a3.CFIndex length = v19 >= length + a3.location ? length + a3.location : v13[26];
      if (a3.location > 0 || length + a3.location < 1)
      {
        CFIndex v20 = a3.length - a3.location;
        if (a3.location < v19) {
          locatioCFIndex n = a3.location;
        }
        else {
          locatioCFIndex n = 0;
        }
        if (a3.location >= v19) {
          CFIndex v20 = 0;
        }
        BOOL v22 = a3.location >= 0;
        a3.locatioCFIndex n = a3.location >= 0 ? location : 0;
        a3.CFIndex length = v22 ? v20 : 0;
      }
      else
      {
        a3.locatioCFIndex n = 0;
      }
      v34.origin.double x = (*(double (**)(void *, CGContext *, CFIndex, CFIndex, double *, double *))(*v13 + 104))(v13, a2, a3.location, a3.length, &v33, &v32);
      double x = v34.origin.x;
      CGFloat y = v34.origin.y;
      CGFloat width = v34.size.width;
      CGFloat height = v34.size.height;
      if (CGRectIsNull(v34)) {
        break;
      }
      v35.origin.double x = v4;
      v35.origin.CGFloat y = v3;
      v35.size.CGFloat width = v6;
      v35.size.CGFloat height = v5;
      if (!CGRectIsEmpty(v35))
      {
        v36.origin.double x = x;
        v36.origin.CGFloat y = y;
        v36.size.CGFloat width = width;
        v36.size.CGFloat height = height;
        if (CGRectIsEmpty(v36))
        {
          double x = v4;
          CGFloat y = v3;
          CGFloat width = v6;
          CGFloat height = v5;
        }
        else
        {
          v37.origin.double x = v4;
          v37.origin.CGFloat y = v3;
          v37.size.CGFloat width = v6;
          v37.size.CGFloat height = v5;
          v39.origin.double x = x;
          v39.origin.CGFloat y = y;
          v39.size.CGFloat width = width;
          v39.size.CGFloat height = height;
          CGRect v38 = CGRectUnion(v37, v39);
          double x = v38.origin.x;
          CGFloat y = v38.origin.y;
          CGFloat width = v38.size.width;
          CGFloat height = v38.size.height;
        }
      }
      if (v17 == v18) {
        break;
      }
      a3.locatioCFIndex n = 0;
      uint64_t v13 = *(void **)(*(void *)(*((void *)this + 2) + 8 * v18) + 40);
      float64x2_t v27 = (double *)v13[39];
      if (!v27) {
        float64x2_t v27 = v15;
      }
      double v28 = *v27 + v33;
      length -= v19;
      ++v18;
      double v32 = v27[1] + v32;
      double v33 = v28;
      CGFloat v5 = height;
      CGFloat v6 = width;
      CGFloat v3 = y;
      double v4 = x;
    }
    TLine::GetLeftHangersGlyphCountAndWidth(this, 0);
    double v30 = v29;
    if (v29 == 0.0) {
      double v30 = 0.0;
    }
    return x - v30;
  }
  return v4;
}

double TRun::GetImageBounds(TRun *this, CGContext *a2, CFRange a3, double *a4, double *a5)
{
  CFIndex length = a3.length;
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  if (a3.length <= 0)
  {
    if (a3.length < 0) {
      uint64_t v13 = (void *)MEMORY[0x1E4F1DB20];
    }
    else {
      uint64_t v13 = (void *)MEMORY[0x1E4F1DB28];
    }
    return *(double *)v13;
  }
  else
  {
    locatioCFIndex n = a3.location;
    uint64_t v11 = *((void *)this + 20);
    if (v11) {
      double v12 = *(double *)(v11 + 48);
    }
    else {
      double v12 = 0.0;
    }
    uint64_t v14 = *((void *)this + 27);
    uint64_t v15 = *(void *)(v14 + 32);
    if (v15 || (uint64_t v18 = *(void *)(v14 + 24)) == 0)
    {
      int v16 = 0;
      uint64_t v17 = v15 + 16 * *((void *)this + 25);
    }
    else
    {
      uint64_t v17 = v18 + 8 * *((void *)this + 25);
      int v16 = 1;
    }
    double v19 = *a4;
    double v20 = *a5;
    *(void *)&long long v21 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v21 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v58[28] = v21;
    v58[29] = v21;
    v58[26] = v21;
    v58[27] = v21;
    v58[24] = v21;
    v58[25] = v21;
    v58[22] = v21;
    v58[23] = v21;
    v58[20] = v21;
    v58[21] = v21;
    v58[18] = v21;
    v58[19] = v21;
    v58[16] = v21;
    v58[17] = v21;
    v58[15] = v21;
    v58[14] = v21;
    v58[13] = v21;
    v58[12] = v21;
    v58[11] = v21;
    v58[10] = v21;
    v58[9] = v21;
    v58[8] = v21;
    v58[7] = v21;
    v58[6] = v21;
    v58[5] = v21;
    v58[4] = v21;
    v58[3] = v21;
    v58[2] = v21;
    v58[1] = v21;
    v58[0] = v21;
    double v56 = 0;
    CGRect v55 = 0;
    uint64_t v57 = 0;
    double v59 = v58;
    CFIndex v22 = a3.location + a3.length;
    if (a3.location + a3.length
      && (std::vector<CGPoint,TInlineBufferAllocator<CGPoint,30ul>>::__vallocate[abi:nn180100](&v55, a3.location + a3.length), double v23 = (char *)v56, bzero(v56, 16 * v22), v56 = &v23[16 * v22], (v24 = v55) != 0))
    {
      uint64_t v46 = a4;
      unint64_t v47 = a5;
      double v48 = a2;
      double v25 = v20 + v12;
      if (v22 >= 1)
      {
        uint64_t v26 = 0;
        uint64_t v27 = 0;
        double v28 = (double *)MEMORY[0x1E4F1DAD8];
        do
        {
          if ((*((unsigned char *)this + 225) & 0x10) != 0)
          {
            [*((id *)this + 27) originAtIndex:v27 + *((void *)this + 25)];
            double v24 = v55;
          }
          else
          {
            double v29 = *v28;
            double v30 = v28[1];
          }
          CGFloat v31 = (double *)&v24[v26];
          *CGFloat v31 = v19 + v29;
          v31[1] = v25 + v30;
          if (v16)
          {
            double v32 = (double *)(v17 + 8 * v27);
            double v33 = 0.0;
          }
          else
          {
            double v32 = (double *)(v17 + v26);
            double v33 = *(double *)(v17 + v26 + 8);
          }
          double v19 = v19 + *v32;
          double v25 = v25 + v33;
          ++v27;
          v26 += 16;
        }
        while (v22 != v27);
      }
      *(void *)&long long v34 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v34 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v53[28] = v34;
      v53[29] = v34;
      v53[26] = v34;
      v53[27] = v34;
      v53[24] = v34;
      v53[25] = v34;
      v53[22] = v34;
      v53[23] = v34;
      v53[20] = v34;
      v53[21] = v34;
      v53[18] = v34;
      v53[19] = v34;
      v53[16] = v34;
      v53[17] = v34;
      v53[15] = v34;
      v53[14] = v34;
      v53[13] = v34;
      v53[12] = v34;
      v53[11] = v34;
      v53[10] = v34;
      v53[9] = v34;
      v53[8] = v34;
      v53[7] = v34;
      v53[6] = v34;
      v53[5] = v34;
      v53[4] = v34;
      double v53[3] = v34;
      v53[2] = v34;
      v53[1] = v34;
      v53[0] = v34;
      __dst = 0;
      double v51 = 0;
      uint64_t v52 = 0;
      double v54 = v53;
      std::vector<CGPoint,TInlineBufferAllocator<CGPoint,30ul>>::__vallocate[abi:nn180100]((char **)&__dst, length);
      CGRect v35 = (char *)v51;
      bzero(v51, 16 * length);
      double v51 = &v35[16 * length];
      CGRect v36 = __dst;
      if (__dst)
      {
        uint64_t v37 = *((void *)this + 39);
        if (!v37 || (uint64_t v38 = *(void *)(v37 + 56), v38 == *(void *)(v37 + 64)))
        {
          unint64_t v42 = length + 1;
          double v40 = v47;
          CGRect v39 = v48;
          double v41 = v46;
          do
          {
            *v36++ = kUnitSize;
            --v42;
          }
          while (v42 > 1);
        }
        else
        {
          memmove(__dst, (const void *)(v38 + 16 * location), 16 * length);
          double v40 = v47;
          CGRect v39 = v48;
          double v41 = v46;
        }
        double *v41 = v19;
        *double v40 = v25 - v12;
        double v43 = *(const TFont **)(atomic_load_explicit((atomic_ullong *volatile)this + 7, memory_order_acquire) + 40);
        v61.locatioCFIndex n = location;
        v61.CFIndex length = length;
        Imagedouble Bounds = TStorageRange::GetImageBounds((TRun *)((char *)this + 192), v43, v39, v61, (const CGPoint *)&v55[16 * location], (const CGSize *)__dst);
      }
      else
      {
        Imagedouble Bounds = *MEMORY[0x1E4F1DB20];
      }
      p_dst = &__dst;
      std::vector<CGPoint,TInlineBufferAllocator<CGPoint,30ul>>::__destroy_vector::operator()[abi:nn180100](&p_dst);
    }
    else
    {
      Imagedouble Bounds = *MEMORY[0x1E4F1DB20];
    }
    __dst = &v55;
    std::vector<CGPoint,TInlineBufferAllocator<CGPoint,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&__dst);
  }
  return ImageBounds;
}

char *std::vector<CGPoint,TInlineBufferAllocator<CGPoint,30ul>>::__vallocate[abi:nn180100](char **a1, unint64_t a2)
{
  if (a2 >> 60) {
    abort();
  }
  double result = TInlineBufferAllocator<CGPoint,30ul>::allocate((uint64_t)(a1 + 3), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * a2];
  return result;
}

char *TInlineBufferAllocator<CGPoint,30ul>::allocate(uint64_t a1, unint64_t a2)
{
  int v2 = (char *)(a1 + 480);
  double result = *(char **)(a1 + 480);
  double v4 = &result[16 * a2];
  if (v4 <= v2)
  {
    *(void *)int v2 = v4;
  }
  else
  {
    if (a2 >> 60) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    return (char *)operator new(16 * a2);
  }
  return result;
}

double TStorageRange::GetImageBounds(TStorageRange *this, const TFont *a2, CGContext *a3, CFRange a4, const CGPoint *a5, const CGSize *a6)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  if (!a5) {
    return *MEMORY[0x1E4F1DB20];
  }
  CGFloat v6 = a6;
  if (!a6) {
    return *MEMORY[0x1E4F1DB20];
  }
  uint64_t v7 = a5;
  CFIndex length = a4.length;
  locatioCFIndex n = a4.location;
  memset(v33, 170, sizeof(v33));
  double v30 = 0;
  CGFloat v31 = 0;
  uint64_t v32 = 0;
  long long v34 = v33;
  if (length
    && (std::vector<CGRect,TInlineBufferAllocator<CGRect,30ul>>::__vallocate[abi:nn180100]((char **)&v30, length),
        double v12 = (char *)v31,
        bzero(v31, 32 * length),
        CGFloat v31 = &v12[32 * length],
        v30))
  {
    uint64_t v13 = *((void *)this + 3);
    uint64_t v14 = *((void *)this + 1);
    uint64_t v15 = (const unsigned __int16 *)(*(void *)(v13 + 16) + 2 * v14 + 2 * location);
    if (length >= 1 && *(__int16 *)v15 == -1 && !*(void *)(*(void *)(v13 + 48) + 8 * v14 + 8 * location))
    {
      ++v15;
      ++v6;
      ++v7;
      --length;
    }
    TFont::GetBoundingBoxesForGlyphs(a2, v15, v30, length, kCTFontOrientationDefault);
    double v16 = *MEMORY[0x1E4F1DB28];
    CGFloat v17 = *(double *)(MEMORY[0x1E4F1DB28] + 8);
    CGFloat v18 = *(double *)(MEMORY[0x1E4F1DB28] + 16);
    CGFloat v19 = *(double *)(MEMORY[0x1E4F1DB28] + 24);
    if (length >= 1)
    {
      uint64_t v20 = 0;
      p_CGFloat y = &v7->y;
      p_CGFloat height = &v6->height;
      do
      {
        double v23 = *(p_height - 1);
        v36.origin.CGFloat x = v23 * v30[v20].origin.x;
        v36.origin.CGFloat y = *p_height * v30[v20].origin.y;
        v36.size.CGFloat width = v23 * v30[v20].size.width;
        v36.size.CGFloat height = *p_height * v30[v20].size.height;
        CGRect v37 = CGRectOffset(v36, *(p_y - 1), *p_y);
        CGFloat x = v37.origin.x;
        CGFloat y = v37.origin.y;
        CGFloat width = v37.size.width;
        CGFloat height = v37.size.height;
        v37.origin.CGFloat x = v16;
        v37.origin.CGFloat y = v17;
        v37.size.CGFloat width = v18;
        v37.size.CGFloat height = v19;
        if (CGRectIsEmpty(v37))
        {
          double v16 = x;
          CGFloat v17 = y;
          CGFloat v18 = width;
          CGFloat v19 = height;
        }
        else
        {
          v38.origin.CGFloat x = x;
          v38.origin.CGFloat y = y;
          v38.size.CGFloat width = width;
          v38.size.CGFloat height = height;
          if (!CGRectIsEmpty(v38))
          {
            v39.origin.CGFloat x = v16;
            v39.origin.CGFloat y = v17;
            v39.size.CGFloat width = v18;
            v39.size.CGFloat height = v19;
            v41.origin.CGFloat x = x;
            v41.origin.CGFloat y = y;
            v41.size.CGFloat width = width;
            v41.size.CGFloat height = height;
            CGRect v40 = CGRectUnion(v39, v41);
            double v16 = v40.origin.x;
            CGFloat v17 = v40.origin.y;
            CGFloat v18 = v40.size.width;
            CGFloat v19 = v40.size.height;
          }
        }
        p_y += 2;
        ++v20;
        p_height += 2;
        --length;
      }
      while (length);
    }
  }
  else
  {
    double v16 = *MEMORY[0x1E4F1DB20];
  }
  double v29 = &v30;
  std::vector<CGRect,TInlineBufferAllocator<CGRect,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v29);
  return v16;
}

void std::vector<CGRect,TInlineBufferAllocator<CGRect,30ul>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  int v2 = (void **)**a1;
  if (v2)
  {
    v1[1] = v2;
    CGFloat v3 = v1 + 123;
    if (v1 + 3 <= v2)
    {
      BOOL v4 = v3 >= v2;
      BOOL v5 = v3 == v2;
    }
    else
    {
      BOOL v4 = 0;
      BOOL v5 = 0;
    }
    if (!v5 && v4)
    {
      if (v1[2] == v1[123]) {
        *CGFloat v3 = v2;
      }
    }
    else
    {
      operator delete(v2);
    }
  }
}

double TFont::GetBoundingBoxesForGlyphs(TFont *this, const unsigned __int16 *a2, CGRect *a3, uint64_t a4, CTFontOrientation a5)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  id v37 = (id)0xAAAAAAAAAAAAAAAALL;
  bboxes = a3;
  (*(void (**)(id *__return_ptr))(**((void **)this + 50) + 496))(&v37);
  if (a4 < 1) {
    goto LABEL_19;
  }
  unint64_t explicit = (CGFont *)atomic_load_explicit((atomic_ullong *volatile)&v37, memory_order_acquire);
  double v10 = bboxes;
  if (!CGFontGetGlyphBBoxes(explicit, a2, a4, bboxes)) {
    goto LABEL_19;
  }
  *(void *)&long long v11 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v47[14] = v11;
  v47[13] = v11;
  v47[12] = v11;
  v47[11] = v11;
  v47[10] = v11;
  v47[9] = v11;
  v47[8] = v11;
  v47[7] = v11;
  v47[6] = v11;
  v47[5] = v11;
  v47[4] = v11;
  v47[3] = v11;
  v47[2] = v11;
  v47[1] = v11;
  v47[0] = v11;
  uint64_t v44 = 0;
  uint64_t v45 = 0;
  uint64_t v46 = 0;
  double v48 = v47;
  int BoundingBoxesForSVGGlyphs = TFont::GetBoundingBoxesForSVGGlyphs(this, 0, (uint64_t)a2, (uint64_t)v10, a4, 1, (double *)&v44, 0);
  *(void *)&long long v13 = -1;
  *((void *)&v13 + 1) = -1;
  *(_OWORD *)&v36.c = v13;
  *(_OWORD *)&v36.tCGFloat x = v13;
  int v14 = BoundingBoxesForSVGGlyphs ^ 1;
  *(_OWORD *)&v36.a = v13;
  TFont::GetScaledMatrix(this, &v36);
  if (a5 != kCTFontOrientationVertical && (a5 || (*(unsigned char *)this & 1) == 0))
  {
LABEL_11:
    double v23 = *MEMORY[0x1E4F1DB28];
    CGFloat v24 = *(double *)(MEMORY[0x1E4F1DB28] + 8);
    CGFloat v25 = *(double *)(MEMORY[0x1E4F1DB28] + 16);
    CGFloat v26 = *(double *)(MEMORY[0x1E4F1DB28] + 24);
    v42[0] = COERCE_CGSIZE_(TFont::GetColorBitmapFontTranslate(this));
    v42[1] = v27;
    double v28 = operator new(0x20uLL);
    *double v28 = &unk_1ED061E50;
    v28[1] = &bboxes;
    v28[2] = &v36;
    v28[3] = v42;
    v40[3] = v28;
    ForEachIndex(a4, v14, v44, v45, (uint64_t)v40);
    std::__function::__value_func<void ()(long)>::~__value_func[abi:nn180100](v40);
    uint64_t v29 = 0;
    do
    {
      CGFloat x = bboxes[v29].origin.x;
      CGFloat y = bboxes[v29].origin.y;
      CGFloat width = bboxes[v29].size.width;
      CGFloat height = bboxes[v29].size.height;
      v52.origin.CGFloat x = v23;
      v52.origin.CGFloat y = v24;
      v52.size.CGFloat width = v25;
      v52.size.CGFloat height = v26;
      if (CGRectIsEmpty(v52))
      {
        double v23 = x;
        CGFloat v24 = y;
        CGFloat v25 = width;
        CGFloat v26 = height;
      }
      else
      {
        v53.origin.CGFloat x = x;
        v53.origin.CGFloat y = y;
        v53.size.CGFloat width = width;
        v53.size.CGFloat height = height;
        if (!CGRectIsEmpty(v53))
        {
          v54.origin.CGFloat x = v23;
          v54.origin.CGFloat y = v24;
          v54.size.CGFloat width = v25;
          v54.size.CGFloat height = v26;
          v56.origin.CGFloat x = x;
          v56.origin.CGFloat y = y;
          v56.size.CGFloat width = width;
          v56.size.CGFloat height = height;
          CGRect v55 = CGRectUnion(v54, v56);
          double v23 = v55.origin.x;
          CGFloat v24 = v55.origin.y;
          CGFloat v25 = v55.size.width;
          CGFloat v26 = v55.size.height;
        }
      }
      ++v29;
      --a4;
    }
    while (a4);
    goto LABEL_17;
  }
  TFont::GetEffectiveMatrix(this, (uint64_t)v42);
  *(_OWORD *)&v36.a = *(_OWORD *)v42;
  *(_OWORD *)&v36.c = *(_OWORD *)v43;
  *(_OWORD *)&v36.tCGFloat x = *(_OWORD *)&v43[2];
  *(void *)&long long v15 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v43[57] = v15;
  *(_OWORD *)&v43[59] = v15;
  *(_OWORD *)&v43[53] = v15;
  *(_OWORD *)&v43[55] = v15;
  *(_OWORD *)&v43[49] = v15;
  *(_OWORD *)&v43[51] = v15;
  *(_OWORD *)&v43[45] = v15;
  *(_OWORD *)&v43[47] = v15;
  *(_OWORD *)&v43[41] = v15;
  *(_OWORD *)&v43[43] = v15;
  *(_OWORD *)&v43[37] = v15;
  *(_OWORD *)&v43[39] = v15;
  *(_OWORD *)&v43[33] = v15;
  *(_OWORD *)&v43[35] = v15;
  *(_OWORD *)&v43[31] = v15;
  *(_OWORD *)&v43[29] = v15;
  *(_OWORD *)&v43[27] = v15;
  *(_OWORD *)&v43[25] = v15;
  *(_OWORD *)&v43[23] = v15;
  *(_OWORD *)&v43[21] = v15;
  *(_OWORD *)&v43[19] = v15;
  *(_OWORD *)&v43[17] = v15;
  *(_OWORD *)&v43[15] = v15;
  *(_OWORD *)&v43[13] = v15;
  *(_OWORD *)&v43[11] = v15;
  *(_OWORD *)&v43[9] = v15;
  *(_OWORD *)&v43[7] = v15;
  *(_OWORD *)&v43[5] = v15;
  *(_OWORD *)&v43[3] = v15;
  *(_OWORD *)&v43[1] = v15;
  v42[0] = 0;
  v42[1] = 0;
  v43[0] = 0;
  v43[61] = &v43[1];
  std::vector<CGPoint,TInlineBufferAllocator<CGPoint,30ul>>::__vallocate[abi:nn180100]((char **)v42, a4);
  double v16 = v42[1];
  bzero(v42[1], 16 * a4);
  v42[1] = &v16[a4];
  CGFloat v17 = v42[0];
  if (v42[0])
  {
    if (TFont::GetUnscaledVerticalTranslationsForGlyphs(this, a2, v42[0], a4))
    {
      TFont::GetScaleFactor((double *)this);
      uint64_t v35 = v18;
      v41[0] = &unk_1ED061E08;
      v41[1] = &bboxes;
      v41[2] = &v35;
      v41[3] = v41;
      ForEachIndex(a4, v14, v44, v45, (uint64_t)v41);
      std::__function::__value_func<void ()(long)>::~__value_func[abi:nn180100](v41);
      p_size = &bboxes->size;
      uint64_t v20 = a4;
      do
      {
        CGRect v50 = *(CGRect *)&p_size[-1].width;
        CGAffineTransform v39 = *(CGAffineTransform *)kRotateLeftTransform;
        CGRect v51 = CGRectApplyAffineTransform(v50, &v39);
        *(CGRect *)&p_size[-1].CGFloat width = v51;
        float64x2_t v21 = *(float64x2_t *)v17++;
        v51.size.CGFloat height = v51.origin.y;
        CGFloat v22 = v51.origin.x;
        p_size[-1] = (CGSize)vextq_s8((int8x16_t)vsubq_f64(*(float64x2_t *)&v51.size.height, v21), (int8x16_t)vaddq_f64(*(float64x2_t *)&v51.origin.y, v21), 8uLL);
        p_size += 2;
        --v20;
      }
      while (v20);
      *(void *)&v39.a = v42;
      std::vector<CGPoint,TInlineBufferAllocator<CGPoint,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v39);
      goto LABEL_11;
    }
    *(void *)&v39.a = v42;
    std::vector<CGPoint,TInlineBufferAllocator<CGPoint,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v39);
    v42[0] = (CGSize *)&v44;
    std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v42);
LABEL_19:
    double v23 = *MEMORY[0x1E4F1DB20];
    goto LABEL_20;
  }
  double v23 = *MEMORY[0x1E4F1DB20];
  *(void *)&v39.a = v42;
  std::vector<CGPoint,TInlineBufferAllocator<CGPoint,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v39);
LABEL_17:
  v42[0] = (CGSize *)&v44;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v42);
LABEL_20:

  return v23;
}

uint64_t TFont::GetBoundingBoxesForSVGGlyphs(TFont *a1, _OWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, double *a7, CGFloat *a8)
{
  uint64_t result = TFont::ensureSVGTableObject(a1);
  if (result)
  {
    if (a6 == 2)
    {
      int v17 = 1;
    }
    else if (a6)
    {
      int v17 = 0;
    }
    else
    {
      int v17 = *(unsigned char *)a1 & 1;
    }
    TFont::GetPaletteColors((atomic_ullong *)a1);
    if (a5 < 1)
    {
      return 0;
    }
    else
    {
      int v57 = v17;
      CGRect v56 = a8;
      double v58 = a2;
      char v18 = 0;
      unint64_t v19 = 0;
      CGFloat v21 = *(double *)(MEMORY[0x1E4F1DB28] + 16);
      CGFloat v20 = *(double *)(MEMORY[0x1E4F1DB28] + 24);
      CGFloat v23 = *MEMORY[0x1E4F1DB28];
      CGFloat v22 = *(double *)(MEMORY[0x1E4F1DB28] + 8);
      uint64_t v59 = a4 + 16;
      do
      {
        uint64_t v24 = -2 * v19;
        unint64_t v25 = v19;
        CGFloat v26 = (double *)(v59 + 32 * v19);
        while (OTSVGTableGetDocumentIndexForGlyph() == -1)
        {
          if (v18)
          {
            CGRect v38 = (unint64_t *)*((void *)a7 + 1);
            unint64_t v39 = *((void *)a7 + 2);
            if ((unint64_t)v38 >= v39)
            {
              CGFloat v41 = *a7;
              uint64_t v42 = ((uint64_t)v38 - *(void *)a7) >> 3;
              unint64_t v43 = v42 + 1;
              if ((unint64_t)(v42 + 1) >> 61) {
                abort();
              }
              uint64_t v44 = v39 - *(void *)&v41;
              if (v44 >> 2 > v43) {
                unint64_t v43 = v44 >> 2;
              }
              if ((unint64_t)v44 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v45 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v45 = v43;
              }
              *(void *)&v61.tdouble x = a7 + 3;
              if (v45)
              {
                uint64_t v46 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)(a7 + 3), v45);
                CGFloat v41 = *a7;
                CGRect v38 = (unint64_t *)*((void *)a7 + 1);
              }
              else
              {
                uint64_t v46 = 0;
              }
              CGRect v51 = (unint64_t *)&v46[8 * v42];
              unint64_t *v51 = v25;
              if (v38 == *(unint64_t **)&v41)
              {
                CGRect v53 = &v46[8 * v42];
              }
              else
              {
                CGRect v52 = v38;
                CGRect v53 = &v46[8 * v42];
                do
                {
                  uint64_t v54 = *--v52;
                  *((void *)v53 - 1) = v54;
                  v53 -= 8;
                }
                while (v52 != *(unint64_t **)&v41);
              }
              CGRect v40 = v51 + 1;
              *(void *)a7 = v53;
              *((void *)a7 + 1) = v51 + 1;
              CGFloat v55 = a7[2];
              *((void *)a7 + 2) = &v46[8 * v45];
              *(void *)&v61.c = v38;
              v61.d = v55;
              v61.a = v41;
              v61.b = v41;
              std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v61);
            }
            else
            {
              unint64_t *v38 = v25;
              CGRect v40 = v38 + 1;
            }
            *((void *)a7 + 1) = v40;
            goto LABEL_49;
          }
          char v18 = 0;
          uint64_t result = 0;
          ++v25;
          v24 -= 2;
          v26 += 4;
          if (a5 == v25) {
            return result;
          }
        }
        if ((v18 & 1) == 0)
        {
          std::vector<long,TInlineBufferAllocator<long,30ul>>::resize((uint64_t)a7, v25);
          uint64_t v27 = *(void **)a7;
          double v28 = (void *)*((void *)a7 + 1);
          if (*(void **)a7 != v28)
          {
            uint64_t v29 = 0;
            do
              *v27++ = v29++;
            while (v27 != v28);
          }
        }
        if (OTSVGDocumentCreate())
        {
          if (OTSVGGlyphRecordingCreate())
          {
            OTSVGGlyphRecordingGetBoundingRect();
            *(v26 - 2) = v30;
            *(v26 - 1) = v31;
            *CGFloat v26 = v32;
            v26[1] = v33;
            if (v57)
            {
              v60.CGFloat width = NAN;
              v60.CGFloat height = NAN;
              TFont::GetUnscaledVerticalTranslationsForGlyphs(a1, (const unsigned __int16 *)(a3 - v24), &v60, 1);
              CGRect v62 = *(CGRect *)(v26 - 2);
              CGAffineTransform v61 = *(CGAffineTransform *)kRotateLeftTransform;
              CGRect v63 = CGRectApplyAffineTransform(v62, &v61);
              CGFloat width = v63.size.width;
              CGFloat height = v63.size.height;
              *CGFloat v26 = v63.size.width;
              v26[1] = v63.size.height;
              double x = v63.origin.x - v60.height;
              double y = v63.origin.y + v60.width;
              *(v26 - 2) = v63.origin.x - v60.height;
              *(v26 - 1) = y;
            }
            else
            {
              double x = v30;
              double y = v31;
              CGFloat width = v32;
              CGFloat height = v33;
            }
            if (v58)
            {
              long long v47 = v58[1];
              *(_OWORD *)&v61.a = *v58;
              *(_OWORD *)&v61.c = v47;
              *(_OWORD *)&v61.tdouble x = v58[2];
              double v48 = x;
              *(double *)&long long v47 = y;
              CGFloat v49 = width;
              CGFloat v50 = height;
              CGRect v64 = CGRectApplyAffineTransform(*(CGRect *)((char *)&v47 - 8), &v61);
              double x = v64.origin.x;
              double y = v64.origin.y;
              CGFloat width = v64.size.width;
              CGFloat height = v64.size.height;
              *(CGRect *)(v26 - 2) = v64;
            }
            v65.origin.double x = v23;
            v65.origin.double y = v22;
            v65.size.CGFloat width = v21;
            v65.size.CGFloat height = v20;
            if (!CGRectIsEmpty(v65))
            {
              v66.origin.double x = x;
              v66.origin.double y = y;
              v66.size.CGFloat width = width;
              v66.size.CGFloat height = height;
              if (CGRectIsEmpty(v66))
              {
                double x = v23;
                double y = v22;
                CGFloat width = v21;
                CGFloat height = v20;
              }
              else
              {
                v67.origin.double x = v23;
                v67.origin.double y = v22;
                v67.size.CGFloat width = v21;
                v67.size.CGFloat height = v20;
                v69.origin.double x = x;
                v69.origin.double y = y;
                v69.size.CGFloat width = width;
                v69.size.CGFloat height = height;
                CGRect v68 = CGRectUnion(v67, v69);
                double x = v68.origin.x;
                double y = v68.origin.y;
                CGFloat width = v68.size.width;
                CGFloat height = v68.size.height;
              }
            }
            OTSVGGlyphRecordingRelease();
            CGFloat v23 = x;
            CGFloat v22 = y;
            CGFloat v21 = width;
            CGFloat v20 = height;
          }
          OTSVGDocumentRelease();
        }
LABEL_49:
        unint64_t v19 = v25 + 1;
        char v18 = 1;
      }
      while (a5 - 1 != v25);
      if (v56)
      {
        CGFloat *v56 = v23;
        v56[1] = v22;
        uint64_t result = 1;
        v56[2] = v21;
        v56[3] = v20;
      }
      else
      {
        return 1;
      }
    }
  }
  return result;
}

double TFont::GetColorBitmapFontTranslate(TFont *this)
{
  if (TFont::GetEffectiveSize(this) == *((double *)this + 2)) {
    return *MEMORY[0x1E4F1DAD8];
  }
  double UnscaledTrackAmount = TFont::GetUnscaledTrackAmount(this);
  int v3 = *(_DWORD *)this;
  if ((*(_DWORD *)this & 2) != 0) {
    return 0.0;
  }
  double v4 = UnscaledTrackAmount;
  double v5 = 0.5;
  if (UnscaledTrackAmount != 0.0)
  {
    TFont::GetScaleFactor((double *)this);
    double v5 = v4 * v6 * 0.4 + 0.0;
    int v3 = *(_DWORD *)this;
  }
  if ((v3 & 1) == 0) {
    dyld_program_sdk_at_least();
  }
  return v5;
}

char *std::vector<CGRect,TInlineBufferAllocator<CGRect,30ul>>::__vallocate[abi:nn180100](char **a1, unint64_t a2)
{
  if (a2 >> 59) {
    abort();
  }
  uint64_t result = TInlineBufferAllocator<DecorationOverride,30ul>::allocate((uint64_t)(a1 + 3), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[32 * a2];
  return result;
}

char *TInlineBufferAllocator<DecorationOverride,30ul>::allocate(uint64_t a1, unint64_t a2)
{
  int v2 = (char *)(a1 + 960);
  uint64_t result = *(char **)(a1 + 960);
  double v4 = &result[32 * a2];
  if (v4 <= v2)
  {
    *(void *)int v2 = v4;
  }
  else
  {
    if (a2 >> 59) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    return (char *)operator new(32 * a2);
  }
  return result;
}

CFCharacterSetRef GetExcessiveLineHeightCharacterSet(void)::$_0::__invoke()
{
  CFCharacterSetRef result = TDescriptorSource::CopyPredefinedCharacterSet((TDescriptorSource *)@"CTFontUIFontExuberatedCharacterSet", 0);
  qword_1EB2CE020 = (uint64_t)result;
  return result;
}

CFCharacterSetRef TDescriptorSource::CopyPredefinedCharacterSet(TDescriptorSource *this, const __CFString *a2)
{
  if (a2)
  {
    CFDictionaryRef PlistFromGSFontCache = (const __CFDictionary *)CTFontGetPlistFromGSFontCache(@"CTCharacterSets.plist", 1);
    if (!PlistFromGSFontCache) {
      goto LABEL_8;
    }
LABEL_7:
    CFDictionaryRef PlistFromGSFontCache = (const __CFDictionary *)CFDictionaryGetValue(PlistFromGSFontCache, this);
    goto LABEL_8;
  }
  if (qword_1EB2CE240 != -1) {
    dispatch_once(&qword_1EB2CE240, &__block_literal_global_694);
  }
  CFDictionaryRef PlistFromGSFontCache = (const __CFDictionary *)qword_1EB2CE238;
  if (qword_1EB2CE238) {
    goto LABEL_7;
  }
LABEL_8:

  return CreateCharacterSetWithCompressedBitmapRepresentation(PlistFromGSFontCache);
}

CFCharacterSetRef CTFontCopyCharacterSet(CTFontRef font)
{
  if (!font) {
    return 0;
  }
  (*(void (**)(id *__return_ptr))(**(void **)(*((void *)font + 5) + 400) + 184))(&v3);
  CFCharacterSetRef v1 = (const __CFCharacterSet *)atomic_exchange((atomic_ullong *volatile)&v3, 0);

  return v1;
}

void TTenuousComponentFont::CopyCharacterSet(atomic_ullong *this@<X0>, void *a2@<X8>)
{
  if ((*(uint64_t (**)(atomic_ullong *))(*this + 896))(this))
  {
    TComponentFont::CopyCharacterSet(this, a2);
  }
  else
  {
    *a2 = 0;
  }
}

void TComponentFont::CopyCharacterSet(atomic_ullong *this@<X0>, void *a2@<X8>)
{
  if (atomic_load_explicit(this + 24, memory_order_acquire))
  {
    unint64_t explicit = (void *)atomic_load_explicit(this + 24, memory_order_acquire);
  }
  else
  {
    double v5 = @"UnicodeCharSet";
    id v22 = 0;
    if (*((unsigned char *)this + 713))
    {
      CFDataRef ComponentAttribute = (const __CFData *)TComponentFont::GetComponentAttribute(this, @"cmapOverride");
      if (ComponentAttribute)
      {
        CFDataRef v7 = ComponentAttribute;
        CFDataRef v8 = ComponentAttribute;
        BytePtr = CFDataGetBytePtr(v7);
        CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        CFMutableArrayRef Mutable = CFCharacterSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
        if (Mutable)
        {
          uint64_t v12 = *(void *)BytePtr;
          if (*(void *)BytePtr)
          {
            long long v13 = (unsigned int *)(BytePtr + 8);
            do
            {
              --v12;
              unsigned int v14 = *v13;
              v13 += 2;
              v23.locatioCFIndex n = v14;
              v23.CFIndex length = 1;
              CFCharacterSetAddCharactersInRange(Mutable, v23);
            }
            while (v12);
          }
        }
        Copdouble y = CFCharacterSetCreateCopy(v10, Mutable);
      }
    }
    if (!atomic_load_explicit((atomic_ullong *volatile)&v22, memory_order_acquire) && (*((unsigned char *)this + 713) & 2) != 0)
    {
      long long v15 = (void *)TComponentFont::GetComponentAttribute(this, @"UnicodeCharSet");
      TCFRef<__CTFont const*>::Retain((atomic_ullong *)&v22, v15);
      if (!atomic_load_explicit((atomic_ullong *volatile)&v22, memory_order_acquire))
      {
        double v5 = @"NSCTFontCharacterSetAttribute";
        TBaseFont::CopyAttributeInternal(this, @"NSCTFontCharacterSetAttribute", &Copy);
      }
    }
    if (!atomic_load_explicit((atomic_ullong *volatile)&v22, memory_order_acquire) && (*((unsigned char *)this + 713) & 4) != 0)
    {
      CFStringRef v16 = (const __CFString *)TComponentFont::GetComponentAttribute(this, @"UnicodeCharSetTrim");
      if (v16)
      {
        CFStringRef v17 = v16;
        CFTypeID v18 = CFGetTypeID(v16);
        if (v18 == CFStringGetTypeID())
        {
          Copdouble y = (id)0xAAAAAAAAAAAAAAAALL;
          TBaseFont::CopyPrebuiltCharacterSet(this, (atomic_ullong *)&Copy);
          if (atomic_load_explicit((atomic_ullong *volatile)&Copy, memory_order_acquire))
          {
            CreateTrimmedCharacterSetForKey((const __CFCharacterSet *)atomic_load_explicit((atomic_ullong *volatile)&Copy, memory_order_acquire), v17, (CFCharacterSetRef *)&v20);
          }
          double v5 = @"NSCTFontCharacterSetAttribute";
        }
      }
    }
    if (!atomic_load_explicit((atomic_ullong *volatile)&v22, memory_order_acquire))
    {
      TBaseFont::CopyCharacterSet(this, a2);

      return;
    }
    uint64_t v19 = 0;
    atomic_compare_exchange_strong(this + 24, (unint64_t *)&v19, atomic_load_explicit((atomic_ullong *volatile)&v22, memory_order_acquire));
    if (!v19) {
      TBaseFont::SetAttributeInternal<__CFDictionary const*>(this, (const void *)atomic_exchange((atomic_ullong *volatile)&v22, 0), v5);
    }

    unint64_t explicit = (void *)atomic_load_explicit(this + 24, memory_order_acquire);
  }
  *a2 = explicit;
}

void TBaseFont::CopyCharacterSet(atomic_ullong *this@<X0>, void *a2@<X8>)
{
  if (atomic_load_explicit(this + 24, memory_order_acquire))
  {
    *a2 = (id)atomic_load_explicit(this + 24, memory_order_acquire);
  }
  else
  {
    id v8 = (id)0xAAAAAAAAAAAAAAAALL;
    TBaseFont::CopyPrebuiltCharacterSet(this, (atomic_ullong *)&v8);
    if (atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire)) {
      goto LABEL_8;
    }
    if (!atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire))
    {
      TBaseFont::GetInitializedGraphicsFont((TBaseFont *)this);
      id v7 = (id)CGFontCopyCharacterSet();

      if (!atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire))
      {
        v9.locatioCFIndex n = 0;
        v9.CFIndex length = 0;
        id v7 = CFCharacterSetCreateWithCharactersInRange((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v9);
      }
    }
    CharacterSetByAddingSynthesizedCharacters((id)atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire), (unint64_t *)&v7);

    if (atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire))
    {
LABEL_8:
      uint64_t v4 = 0;
      unint64_t v5 = atomic_exchange((atomic_ullong *volatile)&v8, 0);
      atomic_compare_exchange_strong(this + 24, (unint64_t *)&v4, v5);
      if (v4) {
        double v6 = (void *)v5;
      }
      else {
        double v6 = 0;
      }
    }
    *a2 = (id)atomic_load_explicit(this + 24, memory_order_acquire);
  }
}

void TBaseFont::CopyPrebuiltCharacterSet(atomic_ullong *this@<X0>, atomic_ullong *a2@<X8>)
{
  *a2 = 0;
  if ((*(unsigned int (**)(atomic_ullong *))(*this + 704))(this))
  {
    uint64_t v4 = (void *)atomic_exchange(a2, (unint64_t)CreateCharacterSetForFont((const __CFString *)atomic_load_explicit(this + 12, memory_order_acquire)));
  }
}

CFCharacterSetRef CreateCharacterSetForFont(const __CFString *a1)
{
  if (!a1) {
    return 0;
  }
  CopyAttributeForSystemFont(a1, @"NSCTFontCharacterSetAttribute", (const __CFString **)&v4);
  CFDataRef v1 = (const __CFData *)atomic_exchange((atomic_ullong *volatile)&v4, 0);

  if (v1) {
    CharacterSetWithCompressedBitmapRepresentatioCFIndex n = CreateCharacterSetWithCompressedBitmapRepresentation(v1);
  }
  else {
    CharacterSetWithCompressedBitmapRepresentatioCFIndex n = 0;
  }

  return CharacterSetWithCompressedBitmapRepresentation;
}

CFCharacterSetRef CreateCharacterSetWithCompressedBitmapRepresentation(const __CFData *a1)
{
  if (a1)
  {
    BytePtr = CFDataGetBytePtr(a1);
    CFIndex Length = CFDataGetLength(a1);
    CFDataRef v4 = 0;
    if (BytePtr)
    {
      CFIndex v5 = Length;
      CFCharacterSetRef v6 = 0;
      if (Length)
      {
        CFIndex v7 = *((unsigned int *)BytePtr + 1);
        CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF90];
        CFRange v9 = (char *)CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E4F1CF90], v7, 0);
        CFAllocatorRef v10 = v9;
        if (*(_DWORD *)BytePtr == 1)
        {
          uint64_t v19 = (char *)BytePtr;
          uint64_t v20 = v5;
          int v21 = 255;
        }
        else
        {
          if (*(_DWORD *)BytePtr == 2)
          {
            int v11 = *((_DWORD *)BytePtr + 1);
            CFIndex v12 = v5 - (v11 & 1);
            long long v13 = BytePtr + 8;
            unsigned int v14 = &BytePtr[v12];
            if (BytePtr + 8 >= &BytePtr[v12])
            {
              long long v15 = v9;
            }
            else
            {
              long long v15 = v9;
              do
              {
                unsigned int v16 = *(unsigned __int16 *)v13;
                v13 += 2;
                unsigned int v17 = v16 >> 14;
                uint64_t v18 = v16 & 0x3FFF;
                if (v16 >> 14 == 2)
                {
                  memcpy(v15, v13, 2 * v18);
                  v13 += 2 * v18;
                }
                else if (v17 == 1)
                {
                  memset(v15, 255, 2 * v18);
                }
                else if (v17)
                {
                  CFLog();
                }
                else
                {
                  bzero(v15, 2 * v18);
                }
                v15 += 2 * v18;
              }
              while (v13 < v14);
            }
            if (v11) {
              *long long v15 = *v13;
            }
            goto LABEL_25;
          }
          uint64_t v19 = (char *)BytePtr;
          uint64_t v20 = v5;
          int v21 = 0;
        }
        GetUncompressedBitmapRepresentation(v19, v20, v21, v10);
LABEL_25:
        CFAllocatorRef v22 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        CFDataRef v4 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)v10, v7, v8);
        if (v4) {
          CFCharacterSetRef v6 = CFCharacterSetCreateWithBitmapRepresentation(v22, v4);
        }
        else {
          CFCharacterSetRef v6 = 0;
        }
      }
    }
    else
    {
      CFCharacterSetRef v6 = 0;
    }

    return v6;
  }
  return 0;
}

void CharacterSetByAddingSynthesizedCharacters(id a1@<X0>, unint64_t *a2@<X8>)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    goto LABEL_7;
  }
  *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v14[2] = v5;
  v14[3] = v5;
  v14[0] = v5;
  v14[1] = v5;
  CFIndex v12 = 0;
  uint64_t v13 = 0;
  int v11 = 0;
  long long v15 = v14;
  AddSynthesizableCharacters((uint64_t)a1, &v11);
  if (v11 == v12)
  {
    MutableCopdouble y = &v11;
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&MutableCopy);
LABEL_7:
    *a2 = (unint64_t)a1;
    return;
  }
  MutableCopdouble y = CFCharacterSetCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFCharacterSetRef)a1);
  CFCharacterSetRef v6 = v11;
  CFIndex v7 = v12;
  while (v6 != v7)
  {
    unsigned int v8 = *(unsigned __int16 *)v6;
    v6 += 2;
    v17.locatioCFIndex n = v8;
    v17.CFIndex length = 1;
    CFCharacterSetAddCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&MutableCopy, memory_order_acquire), v17);
  }
  unint64_t v9 = atomic_exchange((atomic_ullong *volatile)&MutableCopy, 0);
  _CFCharacterSetCompact();
  *a2 = v9;

  MutableCopdouble y = &v11;
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&MutableCopy);
}

uint64_t AddSynthesizableCharacters(uint64_t a1, char **a2)
{
  *(void *)&long long v3 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)theSet = v3;
  long long v46 = v3;
  uint64_t result = CFCharacterSetInitInlineBuffer();
  long long v5 = L"\t ";
  do
  {
    __int16 v44 = v5[2];
    int v6 = *(_DWORD *)v5;
    int v43 = v6;
    unsigned int v7 = (uint64_t)theSet[1] & 4;
    if (HIDWORD(theSet[1]) > (unsigned __int16)v6 || v46 <= (unsigned __int16)v6)
    {
      if (((uint64_t)theSet[1] & 4) != 0) {
        goto LABEL_87;
      }
      goto LABEL_33;
    }
    if (((uint64_t)theSet[1] & 2) != 0)
    {
      uint64_t result = CFCharacterSetIsLongCharacterMember(theSet[0], (unsigned __int16)v6);
      if (result) {
        goto LABEL_87;
      }
LABEL_33:
      uint64_t v17 = 2;
      while (1)
      {
        unint64_t v18 = *(unsigned __int16 *)((char *)&v43 + v17);
        if (*(_WORD *)((char *)&v43 + v17))
        {
          unsigned int v19 = (uint64_t)theSet[1] & 4;
          if (HIDWORD(theSet[1]) <= v18 && v46 > v18)
          {
            if (((uint64_t)theSet[1] & 2) != 0)
            {
              uint64_t result = CFCharacterSetIsLongCharacterMember(theSet[0], v18);
              if (result) {
                goto LABEL_68;
              }
            }
            else if (*((void *)&v46 + 1))
            {
              if ((uint64_t)theSet[1])
              {
                unsigned int v25 = v19 >> 2;
                uint64_t v26 = *(unsigned __int8 *)(*((void *)&v46 + 1) + (v18 >> 8));
                if (*(unsigned char *)(*((void *)&v46 + 1) + (v18 >> 8)))
                {
                  if (v26 == 255)
                  {
                    unsigned int v25 = v19 == 0;
                  }
                  else
                  {
                    BOOL v27 = v19 == 0;
                    if ((*(unsigned __int8 *)(*((void *)&v46 + 1) + 32 * v26 + (v18 >> 3) + 224) >> (v18 & 7))) {
                      unsigned int v25 = v27;
                    }
                  }
                }
                if (v25) {
                  goto LABEL_68;
                }
              }
              else
              {
                BOOL v9 = v19 == 0;
                BOOL v21 = v19 != 0;
                char v22 = v9;
                if ((*(unsigned __int8 *)(*((void *)&v46 + 1) + (v18 >> 3)) >> (v18 & 7))) {
                  BOOL v21 = v22;
                }
                if (v21) {
                  goto LABEL_68;
                }
              }
            }
            else
            {
              BOOL v9 = v19 == 0;
              BOOL v23 = v19 != 0;
              char v24 = v9;
              if (((uint64_t)theSet[1] & 1) == 0) {
                BOOL v23 = v24;
              }
              if (v23)
              {
LABEL_68:
                double v28 = a2[1];
                unint64_t v29 = (unint64_t)a2[2];
                if ((unint64_t)v28 >= v29)
                {
                  double v31 = *a2;
                  uint64_t v32 = v28 - *a2;
                  if (v32 <= -3) {
                    abort();
                  }
                  uint64_t v33 = v32 >> 1;
                  unint64_t v34 = v29 - (void)v31;
                  if (v34 <= (v32 >> 1) + 1) {
                    unint64_t v35 = v33 + 1;
                  }
                  else {
                    unint64_t v35 = v34;
                  }
                  if (v34 >= 0x7FFFFFFFFFFFFFFELL) {
                    uint64_t v36 = 0x7FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    uint64_t v36 = v35;
                  }
                  v47[4] = a2 + 3;
                  if (v36)
                  {
                    id v37 = (char *)TInlineBufferAllocator<unsigned short,30ul>::allocate((uint64_t)(a2 + 3), v36);
                    double v31 = *a2;
                    double v28 = a2[1];
                  }
                  else
                  {
                    id v37 = 0;
                  }
                  CGRect v38 = &v37[2 * v33];
                  *(_WORD *)CGRect v38 = v43;
                  if (v28 == v31)
                  {
                    CGRect v40 = &v37[2 * v33];
                  }
                  else
                  {
                    unint64_t v39 = v28;
                    CGRect v40 = &v37[2 * v33];
                    do
                    {
                      __int16 v41 = *((_WORD *)v39 - 1);
                      v39 -= 2;
                      *((_WORD *)v40 - 1) = v41;
                      v40 -= 2;
                    }
                    while (v39 != v31);
                  }
                  double v30 = v38 + 2;
                  *a2 = v40;
                  a2[1] = v38 + 2;
                  uint64_t v42 = a2[2];
                  a2[2] = &v37[2 * v36];
                  v47[2] = v28;
                  v47[3] = v42;
                  v47[0] = v31;
                  v47[1] = v31;
                  uint64_t result = std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,30ul> &>::~__split_buffer((uint64_t)v47);
                }
                else
                {
                  *(_WORD *)double v28 = v43;
                  double v30 = v28 + 2;
                }
                a2[1] = v30;
                goto LABEL_87;
              }
            }
          }
          else if (((uint64_t)theSet[1] & 4) != 0)
          {
            goto LABEL_68;
          }
        }
        v17 += 2;
        if (v17 == 6) {
          goto LABEL_87;
        }
      }
    }
    if (*((void *)&v46 + 1))
    {
      if ((uint64_t)theSet[1])
      {
        unsigned int v14 = v7 >> 2;
        uint64_t v15 = *(unsigned __int8 *)(*((void *)&v46 + 1) + ((unint64_t)(unsigned __int16)v6 >> 8));
        if (*(unsigned char *)(*((void *)&v46 + 1) + ((unint64_t)(unsigned __int16)v6 >> 8)))
        {
          if (v15 == 255)
          {
            unsigned int v14 = v7 == 0;
          }
          else
          {
            BOOL v16 = v7 == 0;
            if ((((unint64_t)*(unsigned __int8 *)(*((void *)&v46 + 1)
                                                        + 32 * v15
                                                        + (v6 >> 3)
                                                        + 224) >> (v6 & 7)) & 1) != 0)
              unsigned int v14 = v16;
          }
        }
        if (!v14) {
          goto LABEL_33;
        }
      }
      else
      {
        BOOL v9 = v7 == 0;
        BOOL v10 = v7 != 0;
        char v11 = v9;
        if ((((unint64_t)*(unsigned __int8 *)(*((void *)&v46 + 1)
                                                    + ((unint64_t)(unsigned __int16)v6 >> 3)) >> (v6 & 7)) & 1) != 0)
          BOOL v10 = v11;
        if (!v10) {
          goto LABEL_33;
        }
      }
    }
    else
    {
      BOOL v9 = v7 == 0;
      BOOL v12 = v7 != 0;
      char v13 = v9;
      if (((uint64_t)theSet[1] & 1) == 0) {
        BOOL v12 = v13;
      }
      if (!v12) {
        goto LABEL_33;
      }
    }
LABEL_87:
    v5 += 3;
  }
  while (v5 != (const __int16 *)&xmmword_184BA8A68);
  return result;
}

CFLocaleRef CopyLowercasedString(__CFString const*)::$_0::__invoke()
{
  CFLocaleRef result = CFLocaleCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], @"en_US");
  _MergedGlobals_28 = (uint64_t)result;
  return result;
}

void EnsureGSFontInitialized(void)
{
  if (EnsureGSFontInitialized(void)::onceToken != -1) {
    dispatch_once_f(&EnsureGSFontInitialized(void)::onceToken, 0, (dispatch_function_t)EnsureGSFontInitialized(void)::$_0::__invoke);
  }
}

char *ConvertToMorxSync(TBaseFont const*)::{lambda(void *)#1}::__invoke()
{
  CFLocaleRef result = getenv("CT_SKIP_MORX_CONVERSION");
  _MergedGlobals_160 = result != 0;
  return result;
}

__CFString *TAttributes::HandleTextScaleAttribute(__CFString *result, uint64_t a2)
{
  if (result == @"NSTextScaleSecondary"
    || result && (CFLocaleRef result = (__CFString *)CFEqual(result, @"NSTextScaleSecondary"), result))
  {
    *(_WORD *)(*(void *)a2 + 138) |= 0x2000u;
  }
  return result;
}

void CTFrameGetLineOrigins(CTFrameRef frame, CFRange range, CGPoint *origins)
{
  if (frame)
  {
    CFIndex length = range.length;
    locatioCFIndex n = range.location;
    uint64_t v6 = *((void *)frame + 5);
    CFIndex Count = CFArrayGetCount((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)(v6 + 104), memory_order_acquire));
    if (location + length <= Count)
    {
      CFIndex v8 = Count - location;
      if (length) {
        CFIndex v8 = length;
      }
      if (v8)
      {
        BOOL v9 = (const void *)(*(void *)(v6 + 112) + 16 * location);
        memmove(origins, v9, 16 * v8);
      }
    }
  }
}

uint64_t TCFBase<TNativeParagraphStyle>::ClassDestruct(uint64_t a1)
{
  int v2 = *(void (**)(uint64_t))(a1 + 16);
  if (v2) {
    v2(a1);
  }
  long long v3 = *(uint64_t **)(a1 + 40);

  uint64_t v4 = v3[1];
  v3[1] = 0;
  if (v4) {
    MEMORY[0x1853275C0](v4, 0x1000C40FA0F61DDLL);
  }
  uint64_t result = *v3;
  *long long v3 = 0;
  if (result)
  {
    JUMPOUT(0x1853275C0);
  }
  return result;
}

char *CheckForUnboundedLayout(BOOL)::$_0::__invoke()
{
  uint64_t result = getenv("CTDisallowUnboundedLayout");
  byte_1EB2CDEC1 = result != 0;
  return result;
}

CTFramesetterRef CTFramesetterCreateWithAttributedString(CFAttributedStringRef attrString)
{
  CFAttributedStringRef v1 = attrString;
  if (attrString)
  {
    id v6 = (id)0xAAAAAAAAAAAAAAAALL;
    int v2 = (void *)TCFBase<TFramesetter>::Allocate();
    if (v2)
    {
      long long v3 = v2;
      v2[2] = 0;
      v2[3] = 0;
      v2[4] = 0;
      v2[5] = v2 + 6;
      v2[6] = &unk_1ED05F088;
      TTypesetterAttrString::TTypesetterAttrString((TTypesetterAttrString *)(v2 + 7), v1, 0, 0);
      v3[41] = 0;
      id v7 = v3;
      id v5 = (id)atomic_exchange((atomic_ullong *volatile)&v7, 0);
    }
    else
    {
      id v5 = 0;
    }
    id v6 = (id)atomic_exchange((atomic_ullong *volatile)&v5, 0);

    CFAttributedStringRef v1 = (const __CFAttributedString *)atomic_exchange((atomic_ullong *volatile)&v6, 0);
  }
  return v1;
}

uint64_t TCFBase<TFramesetter>::Allocate()
{
  if (_MergedGlobals_8 != -1) {
    dispatch_once_f(&_MergedGlobals_8, 0, (dispatch_function_t)TCFBase<TFramesetter>::GetTypeID(void)::{lambda(void *)#1}::__invoke);
  }

  return _CFRuntimeCreateInstance();
}

uint64_t ___ZL28GetCTCharacterSetsDictionaryb_block_invoke()
{
  uint64_t result = CTFontGetPlistFromGSFontCache(@"CTCharacterSets.plist", 0);
  qword_1EB2CE238 = result;
  return result;
}

uint64_t ___ZL23DetermineTypeStylesSpecv_block_invoke()
{
  uint64_t result = objc_msgSend((id)objc_msgSend((id)CTFontGetPlistFromGSFontCache(@"CoreTextConfig.plist", 0), "objectForKey:", @"AppleSwitch"), "BOOLValue");
  if (result)
  {
    kFont2X = &kFont2XCompact;
    _MergedGlobals_82[0] = 1;
    _MergedGlobals_2 = &kTypeHierarchySpecWatch;
    qword_1EB2CD650 = (uint64_t)kFontSoftCompact;
    off_1EB2CD658[0] = &kFontJapaneseWatch;
    qword_1EB2CD660 = (uint64_t)&kFontKoreanWatch;
    off_1EB2CD668[0] = kFontCompactRounded;
    qword_1EB2CD670 = (uint64_t)kFallbacksCompact;
    gDisableLooseFontNameMatchingOverride = 1;
  }
  return result;
}

uint64_t ___ZL23GetCTFontInfoDictionaryv_block_invoke()
{
  uint64_t result = CTFontGetPlistFromGSFontCache(@"CTFontInfo.plist", 0);
  qword_1EB2CE8E0 = result;
  return result;
}

uint64_t CTFontGetPlistFromGSFontCache(const __CFString *a1, char a2)
{
  if ((a2 & 1) == 0)
  {
    if (qword_1EB2CE8A8 != -1) {
      dispatch_once(&qword_1EB2CE8A8, &__block_literal_global_6);
    }
    if (!_MergedGlobals_34) {
      return 0;
    }
  }

  return MEMORY[0x1F4119ED0](a1);
}

uint64_t TDescriptor::GetSystemUIFontOptions(void)::$_0::__invoke()
{
  _MergedGlobals_13 = 1024;
  uint64_t result = dyld_program_sdk_at_least();
  if ((result & 1) == 0) {
    _MergedGlobals_13 |= 2u;
  }
  return result;
}

id CTFontCopySystemUIFontExcessiveLineHeightCharacterSet()
{
  if (qword_1EB2CE028 != -1) {
    dispatch_once_f(&qword_1EB2CE028, 0, (dispatch_function_t)GetExcessiveLineHeightCharacterSet(void)::$_0::__invoke);
  }
  uint64_t v0 = (void *)qword_1EB2CE020;

  return v0;
}

uint64_t TStorageRange::DeleteGlyphs(uint64_t this, uint64_t a2, const uint64_t *a3)
{
  uint64_t v5 = this;
  uint64_t v6 = *(void *)(this + 8);
  uint64_t v7 = *(void *)(this + 24);
  uint64_t v8 = *(void *)(v7 + 32);
  if (v8 || (uint64_t v11 = *(void *)(v7 + 24)) == 0)
  {
    int v9 = 0;
    uint64_t v10 = v8 + 16 * v6;
  }
  else
  {
    uint64_t v10 = v11 + 8 * v6;
    int v9 = 1;
  }
  uint64_t v12 = *a3;
  if (a2 < 2)
  {
    uint64_t v21 = 0;
  }
  else
  {
    uint64_t v13 = 0;
    uint64_t v14 = v6 + v12;
    uint64_t v24 = a2 - 1;
    uint64_t v15 = 1 - a2;
    BOOL v16 = a3 + 1;
    do
    {
      uint64_t v17 = *(void *)(v5 + 8);
      if (v9) {
        char v18 = 3;
      }
      else {
        char v18 = 4;
      }
      uint64_t v19 = *v16++;
      *(double *)uint64_t v5 = *(double *)v5 - *(double *)(v10 + ((v14 - v17) << v18));
      uint64_t v20 = v19 + v17;
      this = objc_msgSend(*(id *)(v5 + 24), "moveGlyphsFromRange:toIndex:", v14 + 1, v19 + v17 - v14, v14 + v13--);
      uint64_t v14 = v20;
    }
    while (v15 != v13);
    uint64_t v21 = v24;
    uint64_t v12 = a3[v24];
    uint64_t v6 = *(void *)(v5 + 8);
  }
  char v22 = 3;
  if (!v9) {
    char v22 = 4;
  }
  *(double *)uint64_t v5 = *(double *)v5 - *(double *)(v10 + (v12 << v22));
  uint64_t v23 = *(void *)(v5 + 16);
  if (v23 - 1 > v12)
  {
    this = objc_msgSend(*(id *)(v5 + 24), "moveGlyphsFromRange:toIndex:", v12 + v6 + 1, v23 - 1 - v12, v12 + v6 - v21);
    uint64_t v23 = *(void *)(v5 + 16);
  }
  *(void *)(v5 + 16) = v23 - a2;
  return this;
}

double CTRunGetInitialBaseAdvance(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1E4F1DB30];
  if (a1 && *(void *)(*(void *)(a1 + 40) + 312)) {
    uint64_t v1 = *(void *)(*(void *)(a1 + 40) + 312);
  }
  return *(double *)v1;
}

uint64_t ___Z26GetDefaultWritingDirectionv_block_invoke()
{
  Class v0 = NSClassFromString(&cfstr_Nsparagraphsty.isa);
  if (v0) {
    uint64_t result = (uint64_t)[(objc_class *)v0 defaultWritingDirectionForLanguage:0];
  }
  else {
    uint64_t result = 255;
  }
  _MergedGlobals_10 = result;
  return result;
}

Class _CTFontDescriptorEnableBridging(uint64_t a1)
{
  Class result = objc_lookUpClass("UICTFontDescriptor");
  if (result)
  {
    return (Class)MEMORY[0x1F40D90C8](a1, "UICTFontDescriptor");
  }
  return result;
}

Class _CTFontEnableBridging(uint64_t a1)
{
  Class result = objc_lookUpClass("UICTFont");
  if (result)
  {
    return (Class)MEMORY[0x1F40D90C8](a1, "UICTFont");
  }
  return result;
}

const void *___Z26IsSystemFontPostScriptNamePK10__CFString_block_invoke()
{
  if (qword_1EB2CE8E8 != -1) {
    dispatch_once(&qword_1EB2CE8E8, &__block_literal_global_107);
  }
  Class result = (const void *)qword_1EB2CE8E0;
  if (qword_1EB2CE8E0) {
    Class result = CFDictionaryGetValue((CFDictionaryRef)qword_1EB2CE8E0, @"Attrs");
  }
  qword_1EB2CE8B0 = (uint64_t)result;
  return result;
}

CTFontRef CTFontCreateWithGraphicsFont(CGFontRef graphicsFont, CGFloat size, const CGAffineTransform *matrix, CTFontDescriptorRef attributes)
{
  id v14 = (id)0xAAAAAAAAAAAAAAAALL;
  uint64_t v8 = TCFBase<TFont>::Allocate();
  if (v8)
  {
    int v9 = (void *)v8;
    uint64_t v10 = (TFont *)(v8 + 48);
    v9[2] = 0;
    v9[3] = TFont::Hash;
    v9[4] = 0;
    v9[5] = v10;
    TFont::TFont(v10, graphicsFont, size, (CGAffineTransform *)matrix, attributes);
    id v15 = v9;
    id v13 = (id)atomic_exchange((atomic_ullong *volatile)&v15, 0);
  }
  else
  {
    id v13 = 0;
  }
  id v14 = (id)atomic_exchange((atomic_ullong *volatile)&v13, 0);

  uint64_t v11 = (const __CTFont *)atomic_exchange((atomic_ullong *volatile)&v14, 0);
  return v11;
}

void TFont::TFont(TFont *this, CGFont *a2, double a3, CGAffineTransform *a4, const __CTFontDescriptor *a5)
{
  *(_DWORD *)this = 0;
  int v9 = (atomic_ullong *)((char *)this + 8);
  TFont::InitDescriptor(a2, a5, (atomic_ullong *)this + 1);
  *((double *)this + 2) = TFont::InitSize(a5, a3, v10);
  *((void *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0x80000000;
  TFont::InitMatrix((TFont *)a4, (const CGAffineTransform *)a5, (void *)this + 5);
  *((_DWORD *)this + 12) = 0;
  *(_OWORD *)((char *)this + 88) = *MEMORY[0x1E4F1DAD8];
  long long v11 = *(_OWORD *)(MEMORY[0x1E4F1DB28] + 16);
  *(_OWORD *)((char *)this + 104) = *MEMORY[0x1E4F1DB28];
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 120) = v11;
  *((unsigned char *)this + 136) = 0;
  *((void *)this + 24) = 0;
  *((void *)this + 23) = 0;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((void *)this + 22) = (char *)this + 184;
  *((_DWORD *)this + 50) = 0;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *((_DWORD *)this + 60) = 1065353216;
  *(_OWORD *)((char *)this + 248) = 0u;
  *(_OWORD *)((char *)this + 264) = 0u;
  *((_DWORD *)this + 70) = 1065353216;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 19) = 0u;
  *((_OWORD *)this + 20) = 0u;
  *((_OWORD *)this + 21) = 0u;
  *((_OWORD *)this + 22) = 0u;
  *((_DWORD *)this + 92) = 0;
  *((void *)this + 47) = 0;
  *((void *)this + 48) = 0;
  *((unsigned char *)this + 392) = 0;
  *((void *)this + 50) = TFont::InitBaseFont(v12, v9);
  *((void *)this + 51) = 0;
  *((_DWORD *)this + 104) = 0;
  *(_OWORD *)((char *)this + 456) = 0u;
  *(_OWORD *)((char *)this + 472) = 0u;
  *((void *)this + 54) = 0;
  *((void *)this + 55) = 0;
  *((void *)this + 53) = 0;
  *((_DWORD *)this + 112) = 0;
  *((_DWORD *)this + 122) = 1065353216;
  *((void *)this + 62) = 0;
  *((_DWORD *)this + 126) = 0;
  *((void *)this + 64) = 0;
  *((unsigned char *)this + 520) = 0;
  *((void *)this + 66) = 0;
  *((void *)this + 68) = 0;
  *((void *)this + 67) = 0;
  TFont::SetExtras((atomic_ullong *)this, a5, 0);
  TFont::SetFlags((atomic_ullong *)this, 0, a5);
  TFont::SetOpticalSize(this, a5);
  TFont::AddFontSpecificFeatureSettings(this);
}

void TFont::InitDescriptor(TFont *this@<X0>, CTFontDescriptorRef descriptor@<X1>, atomic_ullong *a3@<X8>)
{
  *a3 = 0;
  id v8 = 0;
  if (descriptor) {

  }
  TDescriptorSource::TDescriptorSource((TDescriptorSource *)&v6);
  TDescriptorSource::CopyDescriptor(&v6, this, (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire), (atomic_ullong *)&v7);

  if (!atomic_load_explicit(a3, memory_order_acquire))
  {
    TDescriptorSource::TDescriptorSource((TDescriptorSource *)&v6);
    TDescriptorSource::CreateDefaultDescriptor(0, &v7);
  }
}

void TDescriptorSource::CopyDescriptor(atomic_ullong **this@<X0>, CGFont *a2@<X1>, const __CFDictionary *a3@<X2>, atomic_ullong *a4@<X8>)
{
  uint64_t v17 = a2;
  if (a2)
  {
    BOOL v16 = -86;
    id v15 = (id)0xAAAAAAAAAAAAAAAALL;
    CreateFontURLFromFont(a2, &v16, (atomic_ullong *)&v15);
    unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire);
    if (a3 && explicit && CFDictionaryGetCount(a3))
    {
      id v14 = (id)0xAAAAAAAAAAAAAAAALL;
      VariationsForGraphicsFontByAddingVariation(&v14);
      if (atomic_load_explicit((atomic_ullong *volatile)&v14, memory_order_acquire))
      {
        CFDictionaryRef v12 = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v14, memory_order_acquire);
        TCFBase_NEW<CTFontDescriptor,CGFont *&,__CFDictionary const*>(&v17, &v12, &v13);
        *a4 = atomic_exchange((atomic_ullong *volatile)&v13, 0);

        goto LABEL_13;
      }
    }
    if (!v16)
    {
      *a4 = 0xAAAAAAAAAAAAAAAALL;
      TDescriptorSource::CopyDescriptorUncached(this, (const __CFURL *)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), a4);
      id v8 = *this;
      unint64_t v9 = atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire);
      unint64_t v10 = atomic_load_explicit(a4, memory_order_acquire);
      long long v11 = (void *)atomic_load_explicit(v8, memory_order_acquire);
      if (v10) {
        [v11 setObject:v10 forKey:v9];
      }
      else {
        [v11 removeObjectForKey:v9];
      }
      goto LABEL_17;
    }
    TCFBase_NEW<CTFontDescriptor,CGFont *&,is_inmemory_t const&>(&v14);
    *a4 = atomic_exchange((atomic_ullong *volatile)&v14, 0);
LABEL_13:

LABEL_17:
    return;
  }

  TDescriptorSource::CreateDefaultDescriptor(0, a4);
}

void CreateFontURLFromFont(CGFont *a1@<X0>, BOOL *a2@<X1>, atomic_ullong *a3@<X8>)
{
  *a2 = 0;
  *a3 = CGFontCopyURL();
  if (!atomic_load_explicit(a3, memory_order_acquire))
  {
    id v9 = (id)0xAAAAAAAAAAAAAAAALL;
    id v8 = (id)CGFontCopyPostScriptName(a1);
    FindAndReplace((CFStringRef *)&v9, (atomic_ullong *)&v8, @";", @"/");

    if (atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire))
    {

      CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      id v7 = (__CFString *)CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"file://iNmEmOrYcGfOnT_%p#postscript-name=%@", a1, atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire));

      if (atomic_load_explicit(a3, memory_order_acquire)) {
        *a2 = 1;
      }
    }
  }
}

void CopyPostScriptNameFromFontURL(const __CFURL *a1@<X0>, CFStringRef *a2@<X8>)
{
  if (!a1)
  {
    long long v3 = 0;
    goto LABEL_11;
  }
  long long v3 = (__CFString *)CFURLCopyFragment(a1, &stru_1ED0677F8);
  if (!v3)
  {
LABEL_11:

    *a2 = 0;
    return;
  }
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v3, @";");
  CFArrayRef v6 = ArrayBySeparatingStrings;
  if (!ArrayBySeparatingStrings || (CFIndex Count = CFArrayGetCount(ArrayBySeparatingStrings)) == 0)
  {
LABEL_9:

    goto LABEL_11;
  }
  CFIndex v8 = Count;
  CFIndex v9 = 0;
  while (1)
  {
    CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v6, v9);
    memset(v13, 170, 32);
    if (SplitStringAtSeparator(ValueAtIndex, (const __CFString *)&v13[1], v13, v11))
    {
      if (CFStringHasPrefix(ValueAtIndex, @"postscript-name")) {
        break;
      }
    }
    if (v8 == ++v9) {
      goto LABEL_9;
    }
  }
  id v12 = (id)CFStringCreateWithSubstring(v4, ValueAtIndex, v13[0]);
  FindAndReplace(a2, (atomic_ullong *)&v12, @"/", @";");
}

void CreateFontInfoDictionaryFromFontURL(const __CFURL *a1@<X0>, unint64_t *a2@<X8>)
{
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  id Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (a1)
  {
    v26[1].locatioCFIndex n = 0;
    CFURLRef v5 = CFURLGetBaseURL(a1);
    CFURLRef explicit = a1;
    if (v5)
    {

      CFURLRef explicit = (const __CFURL *)atomic_load_explicit(&v26[1].location, memory_order_acquire);
    }
    id v7 = (__CFString *)CFURLCopyFileSystemPath(explicit, kCFURLPOSIXPathStyle);
  }
  else
  {
    id v7 = 0;
  }
  CFStringRef v8 = v7;
  if (v8)
  {
    CFIndex v9 = (__CFString *)v8;
    CFIndex Length = CFStringGetLength(v8);

    if (Length < 1) {
      goto LABEL_28;
    }
    CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"path", v7);
    if (a1)
    {
      a1 = (const __CFURL *)CFURLCopyFragment(a1, &stru_1ED0677F8);
      if (a1)
      {
        CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(v4, (CFStringRef)a1, @";");
        CFArrayRef v12 = ArrayBySeparatingStrings;
        id v27 = 0;
        if (ArrayBySeparatingStrings)
        {
          CFIndex Count = CFArrayGetCount(ArrayBySeparatingStrings);
          if (Count)
          {
            CFIndex v14 = Count;
            CFIndex v15 = 0;
            while (1)
            {
              CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v12, v15);
              memset(v26, 170, sizeof(v26));
              if (SplitStringAtSeparator(ValueAtIndex, (const __CFString *)&v26[1], v26, v17)) {
                break;
              }
LABEL_24:
              if (v14 == ++v15) {
                goto LABEL_25;
              }
            }
            char v18 = (__CFString *)CFStringCreateWithSubstring(v4, ValueAtIndex, v26[1]);
            id v25 = (id)0xAAAAAAAAAAAAAAAALL;
            id v29 = (id)CFStringCreateWithSubstring(v4, ValueAtIndex, v26[0]);
            FindAndReplace((CFStringRef *)&v25, (atomic_ullong *)&v29, @"/", @";");

            if (CFStringHasPrefix(v18, @"var:"))
            {
              if (!atomic_load_explicit((atomic_ullong *volatile)&v27, memory_order_acquire))
              {
                id v29 = CFDictionaryCreateMutable(v4, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                id v24 = (id)atomic_exchange((atomic_ullong *volatile)&v29, 0);

                CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"variation", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v27, memory_order_acquire));
              }
              v30.CFIndex length = CFStringGetLength(v18) - 4;
              v30.locatioCFIndex n = 4;
              CFStringRef v19 = CFStringCreateWithSubstring(v4, v18, v30);
              if (!v19) {
                goto LABEL_23;
              }
              CFStringRef v20 = v19;
              id v29 = (id)0xAAAAAAAAAAAAAAAALL;
              CreateNumberFromString((const __CFString *)atomic_load_explicit((atomic_ullong *volatile)&v25, memory_order_acquire), (CFNumberRef *)&v29);
              if (atomic_load_explicit((atomic_ullong *volatile)&v29, memory_order_acquire)) {
                CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v27, memory_order_acquire), v20, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v29, memory_order_acquire));
              }
              CFRelease(v20);
              id v21 = v29;
            }
            else
            {
              char v22 = v18;
              CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), v22, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v25, memory_order_acquire));
              id v21 = v22;
            }

LABEL_23:
            goto LABEL_24;
          }
        }
LABEL_25:
      }
    }
  }
  else
  {
    a1 = 0;
  }

LABEL_28:
  if (CFDictionaryGetCount((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire)) < 1)unint64_t v23 = 0; {
  else
  }
    unint64_t v23 = atomic_exchange((atomic_ullong *volatile)&Mutable, 0);
  *a2 = v23;
}

void FindAndReplace(CFStringRef *a1, atomic_ullong *a2, const __CFString *a3, const __CFString *a4)
{
  if (atomic_load_explicit(a2, memory_order_acquire)
    && (CFIndex Length = CFStringGetLength((CFStringRef)atomic_load_explicit(a2, memory_order_acquire)),
        v12.locatioCFIndex n = 0,
        v12.CFIndex length = Length,
        CFStringFindWithOptions((CFStringRef)atomic_load_explicit(a2, memory_order_acquire), a3, v12, 0, 0)))
  {
    CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    MutableCopdouble y = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, (CFStringRef)atomic_load_explicit(a2, memory_order_acquire));
    v13.locatioCFIndex n = 0;
    v13.CFIndex length = Length;
    CFStringFindAndReplace(MutableCopy, a3, a4, v13, 0);
    *a1 = CFStringCreateCopy(v9, MutableCopy);
  }
  else
  {
    *a1 = (CFStringRef)atomic_exchange(a2, 0);
  }
}

BOOL SplitStringAtSeparator(const __CFString *a1, const __CFString *a2, CFRange *a3, CFRange *a4)
{
  CFRange v7 = CFStringFind(a1, @"=", 0);
  CFIndex Length = CFStringGetLength(@"=");
  if (v7.length == Length)
  {
    a2->isa = 0;
    a2->info = v7.location;
    CFIndex v9 = CFStringGetLength(a1);
    a3->locatioCFIndex n = v7.location + v7.length;
    a3->CFIndex length = v9 - (v7.location + v7.length);
  }
  return v7.length == Length;
}

void CreateNumberFromString(const __CFString *a1@<X0>, CFNumberRef *a2@<X8>)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    *a2 = 0;
    return;
  }
  *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v18[0] = v4;
  v18[1] = v4;
  uint64_t v17 = 0;
  int64x2_t v16 = 0uLL;
  CFStringRef v19 = v18;
  CStringPtr = CFStringGetCStringPtr(a1, 0x8000100u);
  if (!CStringPtr)
  {
    CFIndex Length = CFStringGetLength(a1);
    CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
    CFIndex v8 = MaximumSizeForEncoding + 1;
    CFIndex v9 = (char *)v16.i64[0];
    if ((unint64_t)(MaximumSizeForEncoding + 1) <= v16.i64[1] - v16.i64[0])
    {
      if ((unint64_t)(MaximumSizeForEncoding + 1) < v16.i64[1] - v16.i64[0]) {
        v16.i64[1] = v16.i64[0] + v8;
      }
    }
    else
    {
      std::vector<char,TInlineBufferAllocator<char,30ul>>::__append(&v16, MaximumSizeForEncoding + 1 - (v16.i64[1] - v16.i64[0]));
      CFIndex v9 = (char *)v16.i64[0];
    }
    if (!CFStringGetCString(a1, v9, v8, 0x8000100u)) {
      goto LABEL_14;
    }
    CStringPtr = (const char *)v16.i64[0];
    if (!v16.i64[0]) {
      goto LABEL_14;
    }
  }
  CFIndex v14 = (char *)0xAAAAAAAAAAAAAAAALL;
  unint64_t v10 = (void **)strtol_l(CStringPtr, &v14, 10, 0);
  if (v14 != CStringPtr && !*v14)
  {
    __int16 valuePtr = (int64x2_t *)v10;
    CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFNumberType v13 = kCFNumberLongType;
LABEL_17:
    *a2 = CFNumberCreate(v12, v13, &valuePtr);
    goto LABEL_18;
  }
  double v11 = strtod_l(CStringPtr, &v14, 0);
  if (v14 != CStringPtr && !*v14)
  {
    __int16 valuePtr = *(int64x2_t **)&v11;
    CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFNumberType v13 = kCFNumberDoubleType;
    goto LABEL_17;
  }
LABEL_14:
  *a2 = 0;
LABEL_18:
  __int16 valuePtr = &v16;
  std::vector<char,TInlineBufferAllocator<char,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&valuePtr);
}

uint64_t _LargestExuberatedGroupForLanguages(CFArrayRef theArray, const __CFString **a2, int a3, BOOL *a4)
{
  long long v4 = a2;
  if (a4) {
    *a4 = 0;
  }
  if (!theArray)
  {
    id v24 = 0;
    uint64_t v25 = 0;
    if (!a2) {
      return v25;
    }
    goto LABEL_55;
  }
  CFIndex Count = CFArrayGetCount(theArray);
  if (Count)
  {
    uint64_t v6 = 0;
    int v31 = 0;
    CFRange v30 = 0;
    unsigned __int8 v7 = 0;
    CFStringRef v8 = 0;
    CFIndex v9 = 0;
    while (1)
    {
      CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, v9);
      CFStringRef v33 = 0;
      id v34 = 0;
      uint64_t ExuberatedGroupForLanguage = GetExuberatedGroupForLanguage(ValueAtIndex, &v33);

      CFAllocatorRef v12 = (__CFString *)(id)atomic_load_explicit((atomic_ullong *volatile)&v34, memory_order_acquire);
      CFNumberType v13 = v12;
      if (v12 == @"ar")
      {
        BOOL v14 = 1;
      }
      else if (v12)
      {
        BOOL v14 = CFEqual(v12, @"ar") != 0;
      }
      else
      {
        BOOL v14 = 0;
      }

      v7 |= v14;
      if ((int)ExuberatedGroupForLanguage <= (int)v6)
      {
        CFStringRef ValueAtIndex = v8;
        uint64_t ExuberatedGroupForLanguage = v6;
      }
      else
      {
        CFIndex v15 = (__CFString *)(id)atomic_load_explicit((atomic_ullong *volatile)&v34, memory_order_acquire);
        if (v15 == @"ur")
        {

LABEL_18:
          if (a4) {
            *a4 = (v7 & 1) == 0;
          }
          if (a3) {
            CFStringRef v18 = v8;
          }
          else {
            CFStringRef v18 = ValueAtIndex;
          }
          CFStringRef v19 = v30;
          if (a3) {
            CFStringRef v20 = ValueAtIndex;
          }
          else {
            CFStringRef v20 = v30;
          }
          int v21 = v31;
          if (a3) {
            int v22 = ExuberatedGroupForLanguage;
          }
          else {
            int v22 = v31;
          }
          if (a3) {
            unsigned int v23 = v6;
          }
          else {
            unsigned int v23 = ExuberatedGroupForLanguage;
          }
          if (v7 & a3) {
            CFStringRef ValueAtIndex = v8;
          }
          else {
            CFStringRef ValueAtIndex = v18;
          }
          if ((v7 & a3 & 1) == 0) {
            CFStringRef v19 = v20;
          }
          CFRange v30 = (__CFString *)v19;
          if ((v7 & a3 & 1) == 0) {
            int v21 = v22;
          }
          int v31 = v21;
          if (v7 & a3) {
            uint64_t ExuberatedGroupForLanguage = v6;
          }
          else {
            uint64_t ExuberatedGroupForLanguage = v23;
          }
          goto LABEL_43;
        }
        int64x2_t v16 = v15;
        if (v15)
        {
          int v17 = CFEqual(v15, @"ur");

          if (v17) {
            goto LABEL_18;
          }
        }
        else
        {
        }
      }
LABEL_43:

      ++v9;
      uint64_t v6 = ExuberatedGroupForLanguage;
      CFStringRef v8 = ValueAtIndex;
      if (Count == v9) {
        goto LABEL_48;
      }
    }
  }
  CFStringRef ValueAtIndex = 0;
  CFRange v30 = 0;
  int v31 = 0;
  LODWORD(ExuberatedGroupForLanguage) = 0;
LABEL_48:
  if (v31 <= (int)ExuberatedGroupForLanguage) {
    id v24 = (__CFString *)ValueAtIndex;
  }
  else {
    id v24 = v30;
  }
  if (v31 <= (int)ExuberatedGroupForLanguage) {
    uint64_t v25 = ExuberatedGroupForLanguage;
  }
  else {
    uint64_t v25 = v31;
  }
  long long v4 = a2;
  if (a2) {
LABEL_55:
  }
    *long long v4 = v24;
  return v25;
}

uint64_t GetExuberatedGroupForLanguage(const __CFString *a1, const __CFString **a2)
{
  v13.isa = (void *)0xAAAAAAAAAAAAAAAALL;
  MaximizedLocaleIdentifier(&v13, a1);
  CFDictionaryRef ComponentsFromLocaleIdentifier = CFLocaleCreateComponentsFromLocaleIdentifier((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFLocaleIdentifier)atomic_load_explicit((atomic_ullong *volatile)&v13, memory_order_acquire));
  CFDictionaryRef v4 = ComponentsFromLocaleIdentifier;
  if (ComponentsFromLocaleIdentifier)
  {
    CFNumberRef Value = (__CFString *)CFDictionaryGetValue(ComponentsFromLocaleIdentifier, (const void *)*MEMORY[0x1E4F1D218]);
    if (!a2) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  CFNumberRef Value = 0;
  if (a2) {
LABEL_3:
  }
    *a2 = Value;
LABEL_4:
  if (Value == @"vi")
  {
    uint64_t v6 = 2;
    goto LABEL_21;
  }
  if (!Value)
  {
    if (!v4) {
      goto LABEL_20;
    }
    goto LABEL_17;
  }
  uint64_t v6 = 2;
  if (!CFEqual(Value, @"vi") && Value != @"lut")
  {
    int v7 = CFEqual(Value, @"lut");
    if (v4) {
      BOOL v8 = v7 == 0;
    }
    else {
      BOOL v8 = 0;
    }
    if (!v8)
    {
      uint64_t v6 = 2 * (v7 != 0);
      goto LABEL_21;
    }
LABEL_17:
    CFIndex v9 = CFDictionaryGetValue(v4, (const void *)*MEMORY[0x1E4F1D220]);
    if (v9)
    {
      CFNumberRef v10 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)&unk_1ED07E528, v9);
      if (v10)
      {
        unsigned int valuePtr = -1431655766;
        CFNumberGetValue(v10, kCFNumberIntType, &valuePtr);
        uint64_t v6 = valuePtr;
        goto LABEL_21;
      }
    }
LABEL_20:
    uint64_t v6 = 0;
  }
LABEL_21:

  return v6;
}

void MaximizedLocaleIdentifier(const __CFString *a1, const __CFString *a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v22[0] = v4;
  v22[1] = v4;
  uint64_t v21 = 0;
  int64x2_t v20 = 0uLL;
  unsigned int v23 = v22;
  CStringPtr = CFStringGetCStringPtr(a2, 0x600u);
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  if (!CStringPtr)
  {
    CFIndex Length = CFStringGetLength(a2);
    unint64_t v8 = CFStringGetMaximumSizeForEncoding(Length, 0x600u) + 1;
    CFIndex v9 = (char *)v20.i64[0];
    if (v8 <= v20.i64[1] - v20.i64[0])
    {
      if (v8 < v20.i64[1] - v20.i64[0]) {
        v20.i64[1] = v20.i64[0] + v8;
      }
    }
    else
    {
      std::vector<char,TInlineBufferAllocator<char,30ul>>::__append(&v20, v8 - (v20.i64[1] - v20.i64[0]));
      CFIndex v9 = (char *)v20.i64[0];
    }
    CFStringGetCString(a2, v9, v8, 0x600u);
    *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  }
  *(_OWORD *)((char *)v19 + 13) = v6;
  v19[0] = v6;
  long long v17 = v6;
  long long v18 = v6;
  long long v15 = v6;
  long long v16 = v6;
  long long v13 = v6;
  long long v14 = v6;
  *(_OWORD *)bytes = v6;
  long long v12 = v6;
  int v10 = uloc_addLikelySubtags();
  a1->isa = (void *)CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], bytes, v10, 0x600u, 0);
  *(void *)bytes = &v20;
  std::vector<char,TInlineBufferAllocator<char,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)bytes);
}

char *std::vector<char,TInlineBufferAllocator<char,30ul>>::__append(int64x2_t *a1, size_t a2)
{
  long long v6 = &a1->i64[1];
  Class result = (char *)a1->i64[1];
  uint64_t v5 = v6[1];
  if (v5 - (uint64_t)result >= a2)
  {
    if (a2)
    {
      long long v12 = &result[a2];
      bzero(result, a2);
      Class result = v12;
    }
    a1->i64[1] = (uint64_t)result;
  }
  else
  {
    int v7 = &result[-a1->i64[0]];
    unint64_t v8 = (unint64_t)&v7[a2];
    if ((uint64_t)&v7[a2] < 0) {
      abort();
    }
    unint64_t v9 = v5 - a1->i64[0];
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v10 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v10 = v8;
    }
    uint64_t v24 = &a1[1].i64[1];
    if (v10)
    {
      uint64_t v11 = a1[3].i64[1];
      if (v11 + v10 <= (unint64_t)a1[3].u64 + 6) {
        a1[3].i64[1] = v11 + v10;
      }
      else {
        uint64_t v11 = (uint64_t)operator new(v10);
      }
    }
    else
    {
      uint64_t v11 = 0;
    }
    long long v13 = &v7[v11];
    long long v14 = (char *)(v11 + v10);
    unsigned int v23 = v14;
    long long v15 = &v13[a2];
    bzero(v13, a2);
    v22.i64[1] = (uint64_t)&v13[a2];
    uint64_t v17 = a1->i64[0];
    unint64_t v16 = a1->u64[1];
    if (v16 == a1->i64[0])
    {
      int64x2_t v19 = vdupq_n_s64(v16);
    }
    else
    {
      do
      {
        char v18 = *(unsigned char *)--v16;
        *--long long v13 = v18;
      }
      while (v16 != v17);
      int64x2_t v19 = *a1;
      long long v15 = (char *)v22.i64[1];
      long long v14 = v23;
    }
    a1->i64[0] = (uint64_t)v13;
    a1->i64[1] = (uint64_t)v15;
    int64x2_t v22 = v19;
    int64x2_t v20 = (char *)a1[1].i64[0];
    a1[1].i64[0] = (uint64_t)v14;
    unsigned int v23 = v20;
    uint64_t v21 = v19.i64[0];
    return (char *)std::__split_buffer<char,TInlineBufferAllocator<char,30ul> &>::~__split_buffer((uint64_t)&v21);
  }
  return result;
}

uint64_t std::__split_buffer<char,TInlineBufferAllocator<char,30ul> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (*(void *)(a1 + 16) != v2) {
    *(void *)(a1 + 16) = v2;
  }
  long long v3 = *(void **)a1;
  if (*(void *)a1)
  {
    unint64_t v4 = *(void *)(a1 + 32);
    if (v4 <= (unint64_t)v3 && v4 + 30 > (unint64_t)v3)
    {
      if (*(void *)(a1 + 24) == *(void *)(v4 + 32)) {
        *(void *)(v4 + 32) = v3;
      }
    }
    else
    {
      operator delete(v3);
    }
  }
  return a1;
}

void std::vector<char,TInlineBufferAllocator<char,30ul>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    v1[1] = v2;
    long long v3 = (void **)((char *)v1 + 54);
    if (v1 + 3 <= v2)
    {
      BOOL v4 = v3 >= v2;
      BOOL v5 = v3 == v2;
    }
    else
    {
      BOOL v4 = 0;
      BOOL v5 = 0;
    }
    if (!v5 && v4)
    {
      if (v1[2] == v1[7]) {
        v1[7] = v2;
      }
    }
    else
    {
      operator delete(v2);
    }
  }
}

void *TCFBase_NEW<CTFontDescriptor,CGFont *&,is_inmemory_t const&>@<X0>(void *a1@<X8>)
{
  Class result = (void *)TCFBase<TDescriptor>::Allocate(96);
  if (result) {
    CTFontDescriptor::CTFontDescriptor(result);
  }
  *a1 = 0;
  return result;
}

void CTFontDescriptor::CTFontDescriptor(void *a1)
{
  a1[2] = 0;
  a1[3] = TDescriptor::Hash;
  a1[4] = 0;
  a1[5] = a1 + 6;
  operator new();
}

void CreateTraitsWithVariation(CFDictionaryRef theDict@<X0>, const __CFDictionary *a2@<X1>, const __CFArray *a3@<X2>, const TBaseFont *a4@<X3>, atomic_ullong *a5@<X4>, atomic_ullong *a6@<X5>, void *a7@<X8>)
{
  if (!a3)
  {
    *a7 = theDict;
    return;
  }
  id v51 = (id)0xAAAAAAAAAAAAAAAALL;
  TCFMutableDictionary::TCFMutableDictionary((TCFMutableDictionary *)&v51, theDict);
  CFDictionaryRef theDicta = theDict;
  unsigned int SymbolicTraitsFromTraits = GetSymbolicTraitsFromTraits(theDict);
  CFIndex Count = CFArrayGetCount(a3);
  if (Count)
  {
    CFIndex v11 = Count;
    char v45 = 0;
    uint64_t v46 = 0;
    int v48 = 0;
    CFIndex v12 = 0;
    double v13 = NAN;
    double v14 = NAN;
    double v15 = NAN;
    int v47 = -1431655936;
    do
    {
      CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(a3, v12);
      CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, @"NSCTVariationAxisIdentifier");
      LODWORD(valuePtr[0]) = -1431655766;
      CFNumberGetValue(Value, kCFNumberIntType, valuePtr);
      if (SLODWORD(valuePtr[0]) > 2003072103)
      {
        if (LODWORD(valuePtr[0]) == 2003072104)
        {
          DetermineVariationValue(2003072104, a2, ValueAtIndex, 0, a6);
          double v14 = v23;
          LOBYTE(v46) = 1;
        }
        else if (LODWORD(valuePtr[0]) == 2003265652)
        {
          DetermineVariationValue(2003265652, a2, ValueAtIndex, a5, 0);
          double v13 = v19;
          char v45 = 1;
        }
      }
      else if (LODWORD(valuePtr[0]) == 1769234796)
      {
        valuePtr[0] = (id)-1;
        double v20 = 0.0;
        if (a2)
        {
          CFNumberRef v21 = (const __CFNumber *)CFDictionaryGetValue(a2, Value);
          if (v21)
          {
            CFNumberGetValue(v21, kCFNumberDoubleType, valuePtr);
            double v20 = *(double *)valuePtr;
          }
        }
        BOOL v22 = v20 <= 1.0 && v20 > 0.0;
        int v47 = v22;
        int v48 = 1;
      }
      else if (LODWORD(valuePtr[0]) == 1936486004)
      {
        DetermineVariationValue(1936486004, a2, ValueAtIndex, 0, 0);
        double v15 = v18;
        BYTE4(v46) = 1;
      }
      ++v12;
    }
    while (v11 != v12);
  }
  else
  {
    uint64_t v46 = 0;
    char v45 = 0;
    double v15 = NAN;
    double v14 = NAN;
    int v47 = -1431655936;
    int v48 = 0;
    double v13 = NAN;
  }
  if ((*(uint64_t (**)(const TBaseFont *))(*(void *)a4 + 704))(a4))
  {
    unsigned int v24 = SymbolicTraitsFromTraits;
    char v26 = v46;
    char v25 = BYTE4(v46);
    CFDictionaryRef v27 = theDicta;
    char v28 = v45;
  }
  else
  {
    id v29 = (CGFont *)(*(uint64_t (**)(const TBaseFont *))(*(void *)a4 + 568))(a4);
    unsigned int v24 = SymbolicTraitsFromTraits;
    char v26 = v46;
    char v25 = BYTE4(v46);
    CFDictionaryRef v27 = theDicta;
    char v28 = v45;
    if (IsNamedInstance(v29))
    {
      if (v45 && (_BYTE)v46 && BYTE4(v46))
      {
        char v26 = 1;
        char v25 = 1;
        goto LABEL_58;
      }
      valuePtr[0] = (id)-1;
      double v49 = NAN;
      double v50 = NAN;
      uint64_t TraitsFromSubfamilyName = GetTraitsFromSubfamilyName(a4, v45 != 0, v46 != 0, BYTE4(v46) != 0, (double *)valuePtr, &v50, &v49);
      if ((_BYTE)TraitsFromSubfamilyName) {
        BOOL v31 = v45 != 0;
      }
      else {
        BOOL v31 = 1;
      }
      if (!v31)
      {
        double v13 = *(double *)valuePtr;
        char v28 = 1;
      }
      if ((TraitsFromSubfamilyName & 0xFF00) != 0 && v46 == 0)
      {
        double v14 = v50;
        char v26 = 1;
      }
      if ((TraitsFromSubfamilyName & 0xFFFFFF) >= 0x10000 && BYTE4(v46) == 0)
      {
        double v15 = v49;
        char v25 = 1;
      }
    }
  }
  if (!v27) {
    goto LABEL_57;
  }
  if (v28) {
    goto LABEL_48;
  }
  CFNumberRef v34 = (const __CFNumber *)CFDictionaryGetValue(v27, @"NSCTFontWeightTrait");
  if (v34)
  {
    valuePtr[0] = (id)-1;
    CFNumberGetValue(v34, kCFNumberDoubleType, valuePtr);
    double v13 = *(double *)valuePtr;
LABEL_48:
    char v28 = 1;
    goto LABEL_49;
  }
  char v28 = 0;
  double v13 = 0.0;
LABEL_49:
  if (!v26)
  {
    CFNumberRef v35 = (const __CFNumber *)CFDictionaryGetValue(v27, @"NSCTFontProportionTrait");
    if (!v35)
    {
      char v26 = 0;
      double v14 = 0.0;
      goto LABEL_53;
    }
    valuePtr[0] = (id)-1;
    CFNumberGetValue(v35, kCFNumberDoubleType, valuePtr);
    double v14 = *(double *)valuePtr;
  }
  char v26 = 1;
LABEL_53:
  if (v25)
  {
LABEL_56:
    char v25 = 1;
    goto LABEL_57;
  }
  CFNumberRef v36 = (const __CFNumber *)CFDictionaryGetValue(v27, @"NSCTFontSlantTrait");
  if (v36)
  {
    valuePtr[0] = (id)-1;
    CFNumberGetValue(v36, kCFNumberDoubleType, valuePtr);
    double v15 = *(double *)valuePtr;
    goto LABEL_56;
  }
  char v25 = 0;
  double v15 = 0.0;
LABEL_57:
  if (!v28)
  {
    unsigned int v37 = v24;
    goto LABEL_62;
  }
LABEL_58:
  TCFNumber::TCFNumber<double>(valuePtr, v13);
  CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v51, memory_order_acquire), @"NSCTFontWeightTrait", (const void *)atomic_load_explicit((atomic_ullong *volatile)valuePtr, memory_order_acquire));

  if (v13 <= 0.239) {
    unsigned int v37 = v24 & 0xFFFFFFFD;
  }
  else {
    unsigned int v37 = v24 | 2;
  }
LABEL_62:
  if (v26)
  {
    TCFNumber::TCFNumber<double>(valuePtr, v14);
    CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v51, memory_order_acquire), @"NSCTFontProportionTrait", (const void *)atomic_load_explicit((atomic_ullong *volatile)valuePtr, memory_order_acquire));

    if (v14 <= 0.15)
    {
      if (v14 < -0.15) {
        unsigned int v37 = v37 & 0xFFFFFF9F | 0x40;
      }
    }
    else
    {
      unsigned int v37 = v37 & 0xFFFFFF9F | 0x20;
    }
  }
  if (v25)
  {
    TCFNumber::TCFNumber<double>(valuePtr, v15);
    CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v51, memory_order_acquire), @"NSCTFontSlantTrait", (const void *)atomic_load_explicit((atomic_ullong *volatile)valuePtr, memory_order_acquire));

    BOOL v38 = v47;
    if (!v48) {
      BOOL v38 = fabs(v15) > 0.000001;
    }
  }
  else
  {
    BOOL v38 = v47;
    if (!v48) {
      goto LABEL_74;
    }
  }
  if (v38) {
    v37 |= 1u;
  }
  else {
    v37 &= ~1u;
  }
LABEL_74:
  if (v37 != v24)
  {
    TCFNumber::TCFNumber<unsigned int>(valuePtr, v37);
    CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v51, memory_order_acquire), @"NSCTFontSymbolicTrait", (const void *)atomic_load_explicit((atomic_ullong *volatile)valuePtr, memory_order_acquire));
  }
  *a7 = atomic_exchange((atomic_ullong *volatile)&v51, 0);
}

void DetermineVariationValue(uint64_t a1, const __CFDictionary *a2, const __CFDictionary *a3, atomic_ullong *a4, atomic_ullong *a5)
{
  int v9 = a1;
  size_t v10 = (const void *)[NSNumber numberWithUnsignedInt:a1];
  if (!a2 || (CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a2, v10)) == 0)
  {
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a3, @"NSCTVariationAxisDefaultValue");
    if (!Value) {
      return;
    }
  }
  double valuePtr = 0.0;
  CFNumberGetValue(Value, kCFNumberDoubleType, &valuePtr);
  if (v9 == 1936486004) {
    return;
  }
  double v25 = NAN;
  if (a3) {
    CFNumberRef v12 = (const __CFNumber *)CFDictionaryGetValue(a3, @"NSCTVariationAxisMinimumValue");
  }
  else {
    CFNumberRef v12 = 0;
  }
  CFNumberGetValue(v12, kCFNumberDoubleType, &v25);
  if (v9 != 2003072104)
  {
    if (v9 == 2003265652 && round(v25) > 0.0)
    {
      unsigned int v13 = llround(valuePtr);
      if (a4)
      {
        LODWORD(v23) = v13;
        id v24 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &v23);
      }
      if (v13 >= 0x3E8) {
        unsigned int v14 = 1000;
      }
      else {
        unsigned int v14 = v13;
      }
      WeightOfClass(v14);
      return;
    }
LABEL_24:
    uint64_t v23 = -1;
    id v24 = (id)-1;
    if (a3)
    {
      CFNumberRef v21 = (const __CFNumber *)CFDictionaryGetValue(a3, @"NSCTVariationAxisMaximumValue");
      CFNumberGetValue(v21, kCFNumberDoubleType, &v24);
      CFNumberRef v22 = (const __CFNumber *)CFDictionaryGetValue(a3, @"NSCTVariationAxisDefaultValue");
    }
    else
    {
      CFNumberGetValue(0, kCFNumberDoubleType, &v24);
      CFNumberRef v22 = 0;
    }
    CFNumberGetValue(v22, kCFNumberDoubleType, &v23);
    return;
  }
  if (round(v25) <= 0.0) {
    goto LABEL_24;
  }
  double v15 = (double)llround(valuePtr);
  unsigned int v16 = IndexesBracketing<float const*,double>(kWidthPercentScale, &kWidthPercentScale[11], v15, 0.001);
  float v17 = kWidthPercentScale[(unsigned __int16)v16];
  float v18 = kWidthPercentScale[HIWORD(v16)];
  double v19 = 0.0;
  if (v17 != v18) {
    double v19 = (v15 - v17) / (v18 - v17);
  }
  unsigned int v20 = llround(std::__lerp[abi:nn180100]<double>((double)(unsigned __int16)v16, (double)HIWORD(v16), v19));
  if (a5)
  {
    LODWORD(v23) = v20;
    id v24 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &v23);
  }
}

unsigned int ClassOfWidth(double a1)
{
  unsigned int v2 = IndexesBracketing<float const*,double>(kWidthScale, kWidthPercentScale, a1, 0.001);
  float v3 = kWidthScale[(unsigned __int16)v2];
  float v4 = kWidthScale[HIWORD(v2)];
  double v5 = 0.0;
  if (v3 != v4)
  {
    float v6 = (a1 - v3) / (v4 - v3);
    double v5 = v6;
  }
  return llround(std::__lerp[abi:nn180100]<double>((double)(unsigned __int16)v2, (double)HIWORD(v2), v5));
}

uint64_t IndexesBracketing<float const*,double>(float *a1, float *a2, double a3, double a4)
{
  if ((char *)a2 - (char *)a1 >= 8 && *a1 <= a3)
  {
    if (*(a2 - 1) <= a3)
    {
      unsigned __int16 v4 = ((unint64_t)((char *)a2 - (char *)a1) >> 2) - 1;
    }
    else
    {
      int v7 = a1 + 1;
      if (a1 + 1 == a2)
      {
        unsigned __int16 v4 = 0;
        unsigned __int16 v5 = 1;
        return v4 | (v5 << 16);
      }
      unsigned __int16 v4 = 0;
      unsigned __int16 v5 = 1;
      while (1)
      {
        double v8 = *(v7 - 1);
        if (vabdd_f64(a3, v8) < a4) {
          break;
        }
        double v9 = *v7;
        if (vabdd_f64(a3, v9) < a4)
        {
          unsigned __int16 v4 = v5;
          return v4 | (v5 << 16);
        }
        if (v8 >= a3 || v9 <= a3)
        {
          ++v4;
          ++v5;
          if (++v7 != a2) {
            continue;
          }
        }
        return v4 | (v5 << 16);
      }
    }
    unsigned __int16 v5 = v4;
  }
  else
  {
    unsigned __int16 v4 = 0;
    unsigned __int16 v5 = 0;
  }
  return v4 | (v5 << 16);
}

double WeightOfClass(unsigned int a1)
{
  unsigned int v1 = (5243 * (a1 >> 2)) >> 17;
  if (v1 >= 9) {
    unsigned int v2 = 9;
  }
  else {
    unsigned int v2 = (5243 * (a1 >> 2)) >> 17;
  }
  double v3 = (double)(int)(100 * v1);
  unsigned int v4 = v2 + 1;
  double v5 = (double)(int)(100 * v4);
  float v6 = 0.0;
  if (v3 != v5) {
    float v6 = ((double)a1 - v3) / (v5 - v3);
  }
  return std::__lerp[abi:nn180100]<float>(kWeightScale[v1], kWeightScale[v4], v6);
}

float std::__lerp[abi:nn180100]<float>(float a1, float a2, float a3)
{
  if (a1 <= 0.0 && a2 >= 0.0 || a1 >= 0.0 && a2 <= 0.0) {
    return (float)((float)(1.0 - a3) * a1) + (float)(a3 * a2);
  }
  BOOL v4 = a3 <= 1.0;
  if (a3 != 1.0)
  {
    float v5 = a1 + (float)(a3 * (float)(a2 - a1));
    int v6 = v4;
    int v7 = (a2 > a1) ^ v6;
    if (v5 <= a2) {
      float v8 = a2;
    }
    else {
      float v8 = v5;
    }
    if (v5 < a2) {
      a2 = v5;
    }
    if (v7) {
      return v8;
    }
  }
  return a2;
}

void TDescriptor::MergeVariationWithBase(TDescriptor *this, const TBaseFont *a2, const __CFDictionary *a3, atomic_ullong *a4)
{
  if (a2)
  {
    id v31 = (id)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(id *__return_ptr, const TBaseFont *))(*(void *)a2 + 120))(&v31, a2);
    if (!atomic_load_explicit((atomic_ullong *volatile)&v31, memory_order_acquire))
    {
LABEL_51:

      return;
    }
    id v30 = (id)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(id *__return_ptr, const TBaseFont *))(*(void *)a2 + 112))(&v30, a2);
    int v8 = *((_DWORD *)this + 4);
    if (!(*(unsigned int (**)(const TBaseFont *))(*(void *)a2 + 456))(a2)) {
      goto LABEL_16;
    }
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a3, &unk_1ED080880);
    CFNumberRef v10 = Value;
    if (Value)
    {
      CFTypeID v11 = CFGetTypeID(Value);
      if (v11 != CFNumberGetTypeID()) {
        CFNumberRef v10 = 0;
      }
    }
    CFDictionaryRef v12 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)&v30, memory_order_acquire);
    if (!v12)
    {

      int v17 = 1;
      if (!v10 || (v8 & 0x8000) != 0) {
        goto LABEL_29;
      }
      goto LABEL_20;
    }
    CFDictionaryRef v13 = v12;
    CFNumberRef v14 = (const __CFNumber *)CFDictionaryGetValue(v12, &unk_1ED080880);

    if (!v10)
    {
      int v17 = 1;
      goto LABEL_29;
    }
    if (v14)
    {
      double valuePtr = NAN;
      CFNumberGetValue(v10, kCFNumberDoubleType, &valuePtr);
      double v15 = valuePtr;
      double valuePtr = NAN;
      CFNumberGetValue(v14, kCFNumberDoubleType, &valuePtr);
      if (vabdd_f64(v15, valuePtr) < 0.0001 || (v8 & 0x8000) != 0) {
        goto LABEL_17;
      }
    }
    else
    {
LABEL_16:
      if ((v8 & 0x8000) != 0)
      {
LABEL_17:
        int v17 = 1;
LABEL_29:
        if (!atomic_load_explicit((atomic_ullong *volatile)&v30, memory_order_acquire)) {
          goto LABEL_55;
        }
        CFArrayRef explicit = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v31, memory_order_acquire);
        CFDictionaryRef v20 = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v30, memory_order_acquire);
        if (a3)
        {
          if (v20)
          {
            if (!CFEqual(v20, a3))
            {
              CFTypeID v21 = CFGetTypeID(a3);
              if (v21 == CFDictionaryGetTypeID())
              {
                CFIndex Count = CFDictionaryGetCount(v20);
                CFIndex v23 = CFDictionaryGetCount(a3);
                double valuePtr = 0.0;
                if (v23 || !Count)
                {
                  if (Count || !v23)
                  {
                    id v33 = (id)0xAAAAAAAAAAAAAAAALL;
                    CreateMergedVariation(explicit, v20, a3, &v33);
                    CreateValidVariation(explicit, (void *)atomic_load_explicit((atomic_ullong *volatile)&v33, memory_order_acquire), (CFDictionaryRef *)&v32);

                    CFDictionaryRef v25 = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&valuePtr, memory_order_acquire);
                    if (v25 != v20 && (!v25 || !CFEqual(v20, v25)))
                    {
                      CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit(a4, memory_order_acquire), @"NSCTFontVariationAttribute", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v33, memory_order_acquire));

                      goto LABEL_54;
                    }
                  }
                  else
                  {
                    CreateValidVariation(explicit, a3, (CFDictionaryRef *)&v33);

                    CFDictionaryRef v24 = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&valuePtr, memory_order_acquire);
                    if (v24 != v20 && (!v24 || !CFEqual(v20, v24)))
                    {
                      CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit(a4, memory_order_acquire), @"NSCTFontVariationAttribute", a3);
LABEL_54:

LABEL_55:
                      CFDictionaryRef v27 = (void *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit(a4, memory_order_acquire), @"NSCTFontVariationAttribute");
                      if (v17)
                      {
                        double valuePtr = -3.72066208e-103;
                        CreateValidVariation((const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v31, memory_order_acquire), v27, (CFDictionaryRef *)&valuePtr);
                        atomic_load_explicit((atomic_ullong *volatile)&valuePtr, memory_order_acquire);
                        if ((*(unsigned int (**)(const TBaseFont *))(*(void *)a2 + 16))(a2) != 1414809156)
                        {
                          if ((*(unsigned int (**)(const TBaseFont *))(*(void *)a2 + 16))(a2) != 1414743620) {
                            goto LABEL_64;
                          }
                          uint64_t v28 = *(void *)(*((void *)a2 + 76) + 40);
                          if ((*(_DWORD *)(v28 + 16) & 0x80000000) == 0) {
                            TDescriptor::InitBaseFont(*(TDescriptor **)(*((void *)a2 + 76) + 40), 0, 0.0);
                          }
                          unint64_t v29 = atomic_load_explicit((atomic_ullong *volatile)(v28 + 32), memory_order_acquire);
                          if (!v29
                            || (*(unsigned int (**)(unint64_t))(*(void *)v29 + 16))(v29) != 1414809156)
                          {
LABEL_64:
                            operator new();
                          }
                        }
                        operator new();
                      }
                      double valuePtr = -3.72066208e-103;
                      (*(void (**)(double *__return_ptr, const TBaseFont *))(*(void *)a2 + 496))(&valuePtr, a2);
                      id v33 = (id)0xAAAAAAAAAAAAAAAALL;
                      AddDefaultsToVariation((const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v31, memory_order_acquire), (const __CFDictionary *)v27, &v33);
                      id v32 = (id)0xAAAAAAAAAAAAAAAALL;
                      atomic_load_explicit((atomic_ullong *volatile)&valuePtr, memory_order_acquire);
                      atomic_load_explicit((atomic_ullong *volatile)&v33, memory_order_acquire);
                      VariationsForGraphicsFontByAddingVariation(&v32);
                      operator new();
                    }
                  }
                }
              }
            }
          }
        }
        CFDictionaryRemoveValue((CFMutableDictionaryRef)atomic_load_explicit(a4, memory_order_acquire), @"NSCTFontVariationAttribute");
        atomic_fetch_add_explicit((atomic_uint *volatile)a2 + 2, 1u, memory_order_relaxed);
        __swp(v26, (unsigned int *)this + 8);
        atomic_fetch_or_explicit((atomic_uint *volatile)this + 4, 0x80000000, memory_order_relaxed);
        if (v26 && atomic_fetch_add_explicit(v26 + 2, 0xFFFFFFFF, memory_order_release) == 1)
        {
          __dmb(9u);
          (*(void (**)(atomic_uint *))(*(void *)v26 + 8))(v26);
        }

        goto LABEL_51;
      }
    }
LABEL_20:
    if (atomic_load_explicit((atomic_ullong *volatile)&v30, memory_order_acquire))
    {
      double valuePtr = -3.72066208e-103;
      CreateValidVariation((const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v31, memory_order_acquire), a3, (CFDictionaryRef *)&valuePtr);
      if (atomic_load_explicit((atomic_ullong *volatile)&valuePtr, memory_order_acquire)
        && !CFEqual((CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)&v30, memory_order_acquire), (CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)&valuePtr, memory_order_acquire)))
      {
        (*(void (**)(id *__return_ptr, const TBaseFont *, __CFString *))(*(void *)a2 + 56))(&v33, a2, @"NSCTFontFileURLAttribute");
        float v18 = (void *)atomic_exchange((atomic_ullong *volatile)&v33, 0);

        if (v18)
        {
          CFDictionaryRemoveValue((CFMutableDictionaryRef)atomic_load_explicit(a4, memory_order_acquire), @"NSFontNameAttribute");
          CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit(a4, memory_order_acquire), @"NSCTFontFileURLAttribute", v18);
        }
      }
    }
    int v17 = 0;
    goto LABEL_29;
  }
}

id TInstanceFont::CopyVariation@<X0>(atomic_ullong *this@<X0>, void *a2@<X8>)
{
  id result = (id)atomic_load_explicit(this + 75, memory_order_acquire);
  *a2 = result;
  return result;
}

void CreateValidVariation(const __CFArray *a1@<X0>, void *cf@<X1>, CFDictionaryRef *a3@<X8>)
{
  v66[1] = *MEMORY[0x1E4F143B8];
  CFTypeID v6 = CFGetTypeID(cf);
  if (v6 != CFDictionaryGetTypeID())
  {
    *a3 = 0;
    return;
  }
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v65[14] = v7;
  v65[13] = v7;
  v65[12] = v7;
  v65[11] = v7;
  v65[10] = v7;
  v65[9] = v7;
  v65[8] = v7;
  v65[7] = v7;
  v65[6] = v7;
  v65[5] = v7;
  v65[4] = v7;
  v65[3] = v7;
  unsigned int v65[2] = v7;
  v65[1] = v7;
  v65[0] = v7;
  __p = 0;
  CGRect v63 = 0;
  unint64_t v64 = 0;
  v66[0] = v65;
  v60[13] = v7;
  v60[14] = v7;
  v60[11] = v7;
  v60[12] = v7;
  v60[9] = v7;
  v60[10] = v7;
  v60[7] = v7;
  v60[8] = v7;
  v60[5] = v7;
  v60[6] = v7;
  v60[3] = v7;
  v60[4] = v7;
  v60[1] = v7;
  v60[2] = v7;
  v60[0] = v7;
  id values = 0;
  double v58 = 0;
  unint64_t v59 = 0;
  CGAffineTransform v61 = (void **)v60;
  if (!a1) {
    goto LABEL_70;
  }
  CFIndex Count = CFArrayGetCount(a1);
  if (!Count) {
    goto LABEL_70;
  }
  CFIndex v9 = Count;
  uint64_t v54 = a3;
  int v10 = 0;
  for (CFIndex i = 0; i != v9; ++i)
  {
    CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(a1, i);
    CFNumberRef Value = CFDictionaryGetValue(ValueAtIndex, @"NSCTVariationAxisIdentifier");
    if (!cf) {
      continue;
    }
    CFNumberRef v14 = Value;
    CFStringRef v15 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, Value);
    if (v15)
    {
      CFStringRef v16 = v15;
LABEL_8:
      double valuePtr = NAN;
      CFTypeID v17 = CFGetTypeID(v16);
      if (v17 == CFNumberGetTypeID() || v17 == CFBooleanGetTypeID())
      {
        CFNumberGetValue((CFNumberRef)v16, kCFNumberDoubleType, &valuePtr);
        DoubleCFNumberRef Value = valuePtr;
      }
      else
      {
        if (v17 != CFStringGetTypeID())
        {
LABEL_27:
          int v10 = 1;
          continue;
        }
        DoubleCFNumberRef Value = CFStringGetDoubleValue(v16);
        double valuePtr = DoubleValue;
      }
      ClampValueToRangeOfAxis(DoubleValue, ValueAtIndex);
      double v20 = v19;
      CFNumberRef v21 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, @"NSCTVariationAxisDefaultValue");
      if (CFNumberCompare((CFNumberRef)[NSNumber numberWithDouble:v20], v21, 0) == kCFCompareEqualTo) {
        goto LABEL_27;
      }
      CFNumberRef v22 = v63;
      if ((unint64_t)v63 >= v64)
      {
        uint64_t v25 = (v63 - (unsigned char *)__p) >> 3;
        if ((unint64_t)(v25 + 1) >> 61) {
          goto LABEL_82;
        }
        unint64_t v26 = (uint64_t)(v64 - (void)__p) >> 2;
        if (v26 <= v25 + 1) {
          unint64_t v26 = v25 + 1;
        }
        if (v64 - (unint64_t)__p >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v27 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v27 = v26;
        }
        if (v27) {
          uint64_t v28 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v65, v27);
        }
        else {
          uint64_t v28 = 0;
        }
        unint64_t v29 = &v28[8 * v25];
        *(void *)unint64_t v29 = v14;
        CFIndex v23 = v29 + 8;
        id v31 = __p;
        id v30 = v63;
        if (v63 != __p)
        {
          do
          {
            uint64_t v32 = *--v30;
            *((void *)v29 - 1) = v32;
            v29 -= 8;
          }
          while (v30 != v31);
          id v30 = __p;
        }
        id v33 = &v28[8 * v27];
        __p = v29;
        CGRect v63 = v23;
        unint64_t v34 = v64;
        unint64_t v64 = (unint64_t)v33;
        if (v30)
        {
          if (v65 <= (_OWORD *)v30 && v66 > v30)
          {
            if (v34 == v66[0]) {
              v66[0] = v30;
            }
          }
          else
          {
            operator delete(v30);
          }
        }
      }
      else
      {
        *(void *)CGRect v63 = v14;
        CFIndex v23 = v22 + 8;
      }
      CGRect v63 = v23;
      TCFNumber::TCFNumber<double>(&v55, v20);
      CFNumberRef v36 = v58;
      if ((unint64_t)v58 < v59)
      {
        _OWORD *v36 = (void *)atomic_exchange((atomic_ullong *volatile)&v55, 0);
        unsigned int v37 = v36 + 1;
LABEL_66:
        double v58 = v37;

        v10 |= v20 != valuePtr;
        continue;
      }
      uint64_t v38 = v58 - values;
      if ((unint64_t)(v38 + 1) >> 61) {
LABEL_82:
      }
        abort();
      unint64_t v39 = (uint64_t)(v59 - (void)values) >> 2;
      if (v39 <= v38 + 1) {
        unint64_t v39 = v38 + 1;
      }
      if (v59 - (unint64_t)values >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v40 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v40 = v39;
      }
      if (v40)
      {
        __int16 v41 = (char *)v61;
        if (&v61[v40] <= (void **)&v61)
        {
          v61 += v40;
        }
        else
        {
          if (v40 >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          __int16 v41 = (char *)operator new(8 * v40);
        }
      }
      else
      {
        __int16 v41 = 0;
      }
      uint64_t v42 = (void **)&v41[8 * v38];
      int v43 = &v41[8 * v40];
      char *v42 = (void *)atomic_exchange((atomic_ullong *volatile)&v55, 0);
      unsigned int v37 = v42 + 1;
      __int16 v44 = values;
      char v45 = v58;
      if (v58 == values)
      {
        id values = v42;
        double v58 = v42 + 1;
        int v47 = (void **)v59;
        unint64_t v59 = (unint64_t)v43;
        if (!v45) {
          goto LABEL_66;
        }
      }
      else
      {
        do
          *--uint64_t v42 = (void *)atomic_exchange((atomic_ullong *volatile)--v45, 0);
        while (v45 != v44);
        char v45 = values;
        uint64_t v46 = v58;
        id values = v42;
        double v58 = v37;
        int v47 = (void **)v59;
        unint64_t v59 = (unint64_t)v43;
        if (v46 != v45)
        {
          do
          {
            int v48 = v46 - 1;

            uint64_t v46 = v48;
          }
          while (v48 != v45);
        }
        if (!v45) {
          goto LABEL_66;
        }
      }
      if (v60 > (_OWORD *)v45 || &v61 <= (void ***)v45)
      {
        operator delete(v45);
      }
      else if (v47 == v61)
      {
        CGAffineTransform v61 = v45;
      }
      goto LABEL_66;
    }
    CFDictionaryRef v24 = CFDictionaryGetValue(ValueAtIndex, @"NSCTVariationAxisName");
    if (v24)
    {
      CFStringRef v16 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, v24);
      v10 |= v16 != 0;
      if (v16) {
        goto LABEL_8;
      }
    }
  }
  a3 = v54;
  if (v10)
  {
    *uint64_t v54 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)__p, (const void **)values, (v63 - (unsigned char *)__p) >> 3, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    goto LABEL_71;
  }
LABEL_70:
  double valuePtr = COERCE_DOUBLE(cf);
  *a3 = (CFDictionaryRef)atomic_exchange((atomic_ullong *volatile)&valuePtr, 0);

LABEL_71:
  double v49 = values;
  if (values)
  {
    double v50 = v58;
    id v51 = values;
    if (v58 != values)
    {
      do
      {
        CGRect v52 = v50 - 1;

        double v50 = v52;
      }
      while (v52 != v49);
      id v51 = values;
    }
    double v58 = v49;
    if (v60 > (_OWORD *)v51 || &v61 <= (void ***)v51) {
      operator delete(v51);
    }
  }
  id values = &__p;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](&values);
}

BOOL TTenuousComponentFont::HasDerivedOpticalSize(atomic_ullong *this)
{
  return atomic_load_explicit(this + 96, memory_order_acquire) != 0;
}

uint64_t TBaseFont::CopyAttribute(TBaseFont *this, const __CFString *key)
{
  FontAttributeID = GetFontAttributeID(key);
  BOOL v4 = *(uint64_t (**)(TBaseFont *, const void *))(*(void *)this + 40);

  return v4(this, FontAttributeID);
}

uint64_t TInstanceFont::TInstanceFont(uint64_t a1, CGFont *a2, __CFDictionary *a3)
{
  CreateCopyOfFontWithVariation(a2, a3, (CGFont **)&v6);
  TBaseFont::TBaseFont(a1, (id)atomic_load_explicit((atomic_ullong *volatile)&v6, memory_order_acquire));

  *(void *)a1 = &unk_1ED05DBE0;
  *(unsigned char *)(a1 + 624) = 0;
  *(_OWORD *)(a1 + 600) = 0u;
  *(unsigned char *)(a1 + 616) = 0;
  *(_OWORD *)(a1 + 632) = 0u;
  TInstanceFont::InitWithVariation((atomic_ullong *)a1, (CGFont *)atomic_load_explicit((atomic_ullong *volatile)(a1 + 104), memory_order_acquire), a3, 0);
  return a1;
}

CGFont *CreateCopyOfFontWithVariation@<X0>(CGFont *a1@<X0>, const __CFDictionary *a2@<X1>, CGFont **a3@<X8>)
{
  if (a1 && a2) {
    id result = CGFontCreateCopyWithVariations(a1, a2);
  }
  else {
    id result = a1;
  }
  *a3 = result;
  return result;
}

uint64_t TBaseFont::TBaseFont(uint64_t a1, id a2)
{
  *(_DWORD *)(a1 + 8) = 0;
  *(void *)a1 = &unk_1ED05F4D8;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = a2;
  *(_DWORD *)(a1 + 112) = 0;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_DWORD *)(a1 + 184) = 805306368;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(void *)(a1 + 232) = 0;
  *(void *)(a1 + 240) = 0;
  BOOL v4 = (_OWORD *)MEMORY[0x1E4F1DAD8];
  float v5 = (_OWORD *)MEMORY[0x1E4F1DB28];
  *(_DWORD *)(a1 + 248) = 0;
  long long v6 = v5[1];
  *(_OWORD *)(a1 + 304) = *v5;
  *(_OWORD *)(a1 + 320) = v6;
  *(_OWORD *)(a1 + 288) = *v4;
  *(unsigned char *)(a1 + 336) = 0;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_OWORD *)(a1 + 360) = 0u;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_DWORD *)(a1 + 392) = 1065353216;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 416) = 0u;
  *(_DWORD *)(a1 + 432) = 1065353216;
  *(_WORD *)(a1 + 440) = -1;
  *(void *)(a1 + 460) = 0;
  *(_DWORD *)(a1 + 468) = 0;
  *(void *)(a1 + 444) = 0;
  *(void *)(a1 + 452) = 0;
  *(void *)(a1 + 480) = a1 + 472;
  *(void *)(a1 + 488) = 0;
  *(void *)(a1 + 496) = 0;
  *(void *)(a1 + 504) = 0;
  *(void *)(a1 + 544) = a1 + 512;
  *(_OWORD *)(a1 + 568) = 0u;
  *(_OWORD *)(a1 + 584) = 0u;
  *(_OWORD *)(a1 + 552) = 0u;
  TBaseFont::Init((atomic_ullong *)a1, (CGFont *)a2);
  return a1;
}

void VariationsForGraphicsFontByAddingVariation(void *a1@<X8>)
{
  *a1 = 0;
}

void AddDefaultsToVariation(const __CFArray *a1@<X0>, const __CFDictionary *a2@<X1>, void *a3@<X8>)
{
  id v14 = (id)0xAAAAAAAAAAAAAAAALL;
  TCFMutableDictionary::TCFMutableDictionary((TCFMutableDictionary *)&v14, a2);
  if (a1)
  {
    CFIndex Count = CFArrayGetCount(a1);
    if (Count)
    {
      CFIndex v6 = Count;
      for (CFIndex i = 0; i != v6; ++i)
      {
        CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(a1, i);
        CFNumberRef Value = CFDictionaryGetValue(ValueAtIndex, @"NSCTVariationAxisIdentifier");
        if (a2)
        {
          int v10 = CFDictionaryGetValue(a2, Value);
          if (v10)
          {
            CFTypeID v11 = CFGetTypeID(v10);
            if (v11 == CFNumberGetTypeID()) {
              continue;
            }
          }
        }
        CFDictionaryRef v12 = CFDictionaryGetValue(ValueAtIndex, @"NSCTVariationAxisDefaultValue");
        CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v14, memory_order_acquire), Value, v12);
      }
    }
  }
  *a3 = atomic_exchange((atomic_ullong *volatile)&v14, 0);
}

void CreateMergedVariation(const __CFArray *a1@<X0>, const __CFDictionary *a2@<X1>, const __CFDictionary *a3@<X2>, void *a4@<X8>)
{
  id v20 = (id)0xAAAAAAAAAAAAAAAALL;
  TCFMutableDictionary::TCFMutableDictionary((TCFMutableDictionary *)&v20, a2);
  if (a1)
  {
    CFIndex Count = CFArrayGetCount(a1);
    if (Count)
    {
      CFIndex v7 = Count;
      for (CFIndex i = 0; v7 != i; ++i)
      {
        CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(a1, i);
        CFNumberRef Value = CFDictionaryGetValue(ValueAtIndex, @"NSCTVariationAxisIdentifier");
        if (!a3) {
          continue;
        }
        CFTypeID v11 = Value;
        CFStringRef v12 = (const __CFString *)CFDictionaryGetValue(a3, Value);
        if (!v12)
        {
          CFStringRef v16 = CFDictionaryGetValue(ValueAtIndex, @"NSCTVariationAxisName");
          if (!v16) {
            continue;
          }
          CFStringRef v12 = (const __CFString *)CFDictionaryGetValue(a3, v16);
          if (!v12) {
            continue;
          }
        }
        uint64_t valuePtr = -1;
        CFTypeID v13 = CFGetTypeID(v12);
        if (v13 == CFNumberGetTypeID() || v13 == CFBooleanGetTypeID())
        {
          CFNumberGetValue((CFNumberRef)v12, kCFNumberDoubleType, &valuePtr);
          DoubleCFNumberRef Value = *(double *)&valuePtr;
        }
        else
        {
          if (v13 != CFStringGetTypeID())
          {
            CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire), v11, v12);
            continue;
          }
          DoubleCFNumberRef Value = CFStringGetDoubleValue(v12);
          uint64_t valuePtr = *(void *)&DoubleValue;
        }
        ClampValueToRangeOfAxis(DoubleValue, ValueAtIndex);
        TCFNumber::TCFNumber<double>(&v18, v15);
        CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire), v11, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v18, memory_order_acquire));
      }
    }
  }
  *a4 = atomic_exchange((atomic_ullong *volatile)&v20, 0);
}

CTFontRef CTFontCreateUIFontForLanguage(CTFontUIFontType uiType, CGFloat size, CFStringRef language)
{
  double v3 = (const __CTFontDescriptor *)CTFontDescriptorCreateForUIType(*(TDescriptorSource **)&uiType, language, size);
  BOOL v4 = v3;
  if (v3) {
    float v5 = CTFontCreateWithFontDescriptor(v3, 0.0, 0);
  }
  else {
    float v5 = 0;
  }

  return v5;
}

unint64_t CTFontDescriptorCreateForUIType(TDescriptorSource *a1, const __CFString *a2, double a3)
{
  TDescriptorSource::TDescriptorSource((TDescriptorSource *)&v8);
  TDescriptorSource::CreateDescriptorForUIType(a1, a3, a2, &v9);
  unint64_t v6 = atomic_exchange((atomic_ullong *volatile)&v9, 0);

  return v6;
}

void TDescriptorSource::CreateDescriptorForUIType(TDescriptorSource *a1@<X1>, double a2@<D0>, const __CFString *a3@<X2>, void *a4@<X8>)
{
  unsigned int v7 = a1;
  v26[1] = *MEMORY[0x1E4F143B8];
  double v22 = a2;
  if ((a1 == -1 || a1 < 0x145 || (a1 - 1007) > 0xFFFFFFF8)
    && (CFStringRef v20 = 0,
        unint64_t v21 = 0xAAAAAAAAFFFFFFFFLL,
        id v18 = 0,
        double v19 = 0.0,
        (SetDescriptorInfoForUIType((uint64_t)&v18, a1) & 1) != 0))
  {
    CFStringRef v9 = v20;
    if (v20)
    {
      uint64_t v25 = @"NSCTFontTextStylePlatformAttribute";
      v26[0] = [NSNumber numberWithUnsignedInt:v21];
      int v10 = (TDescriptorSource *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v26 forKeys:&v25 count:1];
      TDescriptorSource::CreateDescriptorForTextStyle(v10, v9, @"UICTContentSizeCategoryL", a3, v10);
    }
    else
    {
      if (v7 <= 1) {
        int v11 = 20;
      }
      else {
        int v11 = 1028;
      }
      int v17 = v11;
      id v16 = (id)0xAAAAAAAAAAAAAAAALL;
      if (a2 == 0.0) {
        CFStringRef v12 = &v19;
      }
      else {
        CFStringRef v12 = &v22;
      }
      TCFBase_NEW<CTFontDescriptor,__CFString const*&,double &,unsigned int &>(&v18, v12, &v17, &v15);
      id v16 = (id)atomic_exchange((atomic_ullong *volatile)&v15, 0);

      if (a3)
      {
        if (v22 == 0.0) {
          double v22 = v19;
        }
        v24[0] = v18;
        v23[0] = @"NSFontNameAttribute";
        v23[1] = @"NSFontSizeAttribute";
        uint64_t v13 = objc_msgSend(NSNumber, "numberWithDouble:");
        v23[2] = @"CTFontDescriptorLanguageAttribute";
        v24[1] = v13;
        v24[2] = a3;
        id v15 = (id)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v24 forKeys:v23 count:3];
        TCFBase_NEW<CTFontDescriptor,__CFDictionary const*&,unsigned int &>(&v14, &v15, &v17);
        *a4 = atomic_exchange((atomic_ullong *volatile)&v14, 0);
      }
      else
      {
        *a4 = atomic_exchange((atomic_ullong *volatile)&v16, 0);
      }
    }
  }
  else
  {
    *a4 = 0;
  }
}

void TCFBase_NEW<CTFontDescriptor,__CFString const*&,double &,unsigned int &>(__CFString **a1@<X0>, double *a2@<X1>, int *a3@<X2>, void *a4@<X8>)
{
  uint64_t v8 = TCFBase<TDescriptor>::Allocate(96);
  if (v8)
  {
    CFStringRef v9 = (void *)v8;
    int v10 = *a1;
    double v11 = *a2;
    int v12 = *a3;
    uint64_t v13 = (TDescriptor *)(v8 + 48);
    v9[2] = 0;
    v9[3] = TDescriptor::Hash;
    v9[4] = 0;
    v9[5] = v13;
    TDescriptor::TDescriptor(v13, v10, v11, v12);
    id v14 = v9;
    *a4 = atomic_exchange((atomic_ullong *volatile)&v14, 0);
  }
  else
  {
    *a4 = 0;
  }
}

void TDescriptor::TDescriptor(TDescriptor *this, __CFString *a2, double a3, int a4)
{
  *(void *)this = &unk_1ED05D778;
  *((void *)this + 1) = 0;
  *((_DWORD *)this + 4) = a4 & 0x7FFFFFFF;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 3) = 0;
  id Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (a2)
  {
    CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"NSFontNameAttribute", a2);
    CFStringRef v9 = (const void *)TDescriptorSource::TextStyleForUIFontName((TDescriptorSource *)a2, v7, v8);
    if (v9) {
      CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"NSCTFontUIUsageAttribute", v9);
    }
  }
  if (a3 > 0.0)
  {
    TCFNumber::TCFNumber<double>(&v10, a3);
    CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"NSFontSizeAttribute", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire));
  }
}

void CopyVariationAxes(void *a1@<X8>)
{
  capacitdouble y = 0;
  CGFontGetVariationAxes();
  *a1 = 0;
}

void CreateTraitValues(double a1@<D0>, double a2@<D1>, double a3@<D2>, const __CFString *a4@<X4>, int a5@<W0>, int a6@<W1>, int a7@<W2>, int a8@<W3>, void *a9@<X8>)
{
  id Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (a5)
  {
    if (a1 > 0.239) {
      a8 |= 2u;
    }
    TCFNumber::TCFNumber<double>(&v22, a1);
    CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"NSCTFontWeightTrait", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v22, memory_order_acquire));

    if (!a6)
    {
LABEL_3:
      if (!a7) {
        goto LABEL_7;
      }
      goto LABEL_4;
    }
  }
  else if (!a6)
  {
    goto LABEL_3;
  }
  if (a2 <= 0.15)
  {
    if (a2 < -0.15) {
      a8 |= 0x40u;
    }
  }
  else
  {
    a8 |= 0x20u;
  }
  TCFNumber::TCFNumber<double>(&v22, a2);
  CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"NSCTFontProportionTrait", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v22, memory_order_acquire));

  if (a7)
  {
LABEL_4:
    double v18 = fabs(a3);
    BOOL v19 = v18 <= 0.000001;
    BOOL v20 = v18 > 0.000001;
    double v21 = 0.0;
    if (!v19) {
      double v21 = a3;
    }
    a8 |= v20;
    TCFNumber::TCFNumber<double>(&v22, v21);
    CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"NSCTFontSlantTrait", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v22, memory_order_acquire));
  }
LABEL_7:
  TCFNumber::TCFNumber<unsigned int>(&v22, a8 | 0x4000);
  CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"NSCTFontSymbolicTrait", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v22, memory_order_acquire));

  if (a4) {
    CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"NSCTFontUIFontDesignTrait", a4);
  }
  *a9 = atomic_exchange((atomic_ullong *volatile)&Mutable, 0);
}

void *TCFNumber::TCFNumber<double>(void *a1, double a2)
{
  double valuePtr = a2;
  id v4 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberDoubleType, &valuePtr);
  *a1 = atomic_exchange((atomic_ullong *volatile)&v4, 0);

  return a1;
}

void *TCFNumber::TCFNumber<unsigned int>(void *a1, unsigned int a2)
{
  uint64_t valuePtr = a2;
  id v4 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberLongType, &valuePtr);
  *a1 = atomic_exchange((atomic_ullong *volatile)&v4, 0);

  return a1;
}

uint64_t ___ZL18IsHVFCompatibleAppv_block_invoke()
{
  uint64_t result = dyld_program_sdk_at_least();
  if ((result & 1) == 0)
  {
    uint64_t v1 = 0;
    while (1)
    {
      uint64_t result = _CFAppVersionCheckLessThan();
      if (result) {
        break;
      }
      v1 += 8;
      if (v1 == 16) {
        return result;
      }
    }
    _MergedGlobals_16[0] = 1;
  }
  return result;
}

void GetShapingGlyphsQueue(void)::$_0::__invoke()
{
  Class v0 = dispatch_queue_create("com.apple.CoreText.InitShapingGlyphs", 0);
  qword_1EB2CDFA0 = (uint64_t)v0;
  global_queue = dispatch_get_global_queue(-2, 0);

  dispatch_set_target_queue(v0, global_queue);
}

BOOL CTFontDescriptorMatchFontDescriptorsWithProgressHandler(CFArrayRef descriptors, CFSetRef mandatoryAttributes, CTFontDescriptorProgressHandler progressBlock)
{
  return CTFontDescriptorMatchFontDescriptorsWithProgressHandlerCore(descriptors, mandatoryAttributes, 0, progressBlock);
}

Class TCFBase<TFont>::GetTypeID(void)::{lambda(void *)#1}::__invoke()
{
  TCFBase<TFont>::CreateTypeID();
  uint64_t v0 = TCFBase<TFont>::fTypeID;

  return _CTFontEnableBridging(v0);
}

uint64_t TCFBase<TFont>::CreateTypeID()
{
  {
    TCFBase<TFont>::CreateTypeID(void)::runtimeClass = 0;
    *(void *)algn_1EB2CDA48 = "CTFont";
    qword_1EB2CDA50 = 0;
    unk_1EB2CDA58 = 0;
    qword_1EB2CDA60 = (uint64_t)TCFBase<TFont>::ClassDestruct;
    qword_1EB2CDA68 = (uint64_t)TCFBase<TFont>::ClassEqual;
    qword_1EB2CDA70 = (uint64_t)TCFBase<TFont>::ClassHash;
    unk_1EB2CDA78 = 0;
    qword_1EB2CDA80 = (uint64_t)TCFBase<TFont>::ClassDebug;
    unk_1EB2CDA88 = 0;
    qword_1EB2CDA90 = 0;
    unk_1EB2CDA98 = 0;
  }
  uint64_t result = _CFRuntimeRegisterClass();
  TCFBase<TFont>::fTypeID = result;
  return result;
}

Class TCFBase<TDescriptor>::GetTypeID(void)::{lambda(void *)#1}::__invoke()
{
  TCFBase<TDescriptor>::CreateTypeID();
  uint64_t v0 = TCFBase<TDescriptor>::fTypeID;

  return _CTFontDescriptorEnableBridging(v0);
}

uint64_t TCFBase<TDescriptor>::CreateTypeID()
{
  {
    TCFBase<TDescriptor>::CreateTypeID(void)::runtimeClass = 0;
    *(void *)algn_1EB2CD9C8 = "CTFontDescriptor";
    qword_1EB2CD9D0 = 0;
    unk_1EB2CD9D8 = 0;
    qword_1EB2CD9E0 = (uint64_t)TCFBase<TDescriptor>::ClassDestruct;
    qword_1EB2CD9E8 = (uint64_t)TCFBase<TDescriptor>::ClassEqual;
    qword_1EB2CD9F0 = (uint64_t)TCFBase<TDescriptor>::ClassHash;
    unk_1EB2CD9F8 = 0;
    qword_1EB2CDA00 = (uint64_t)TCFBase<TDescriptor>::ClassDebug;
    unk_1EB2CDA08 = 0;
    qword_1EB2CDA10 = 0;
    unk_1EB2CDA18 = 0;
  }
  uint64_t result = _CFRuntimeRegisterClass();
  TCFBase<TDescriptor>::fTypeID = result;
  return result;
}

uint64_t CTGlyphStorageCreateMutableWithInterface(uint64_t a1, uint64_t a2)
{
  id v4 = [_CTMutableGlyphStorage alloc];

  return (uint64_t)[(_CTMutableGlyphStorage *)v4 initWithInterface:a2 options:a1];
}

uint64_t TAATMorphTable::ShapeGlyphs(uint64_t *a1, unsigned char *a2, CFIndex a3)
{
  v95.locatioCFIndex n = a3;
  uint64_t v110 = *MEMORY[0x1E4F143B8];
  a1[2] = TRunGlue::length((TRunGlue *)a1[1]) << 7;
  if (!*((unsigned char *)a1 + 56))
  {
    uint64_t v35 = *a1;
    uint64_t v34 = a1[1];
    CFIndex v36 = *(void *)(v34 + 16);
    v95.locatioCFIndex n = *(void *)(v34 + 8);
    HIDWORD(v95.length) = -1431655766;
    uint64_t v37 = (*(uint64_t (**)(uint64_t *, char *))(v35 + 16))(a1, (char *)&v95.length + 4);
    uint64_t v38 = 1;
    if (HIDWORD(v95.length))
    {
      unint64_t v39 = (unsigned int *)v37;
      unsigned int length_high = 0;
      while ((*(unsigned int (**)(unsigned int *))(*(void *)v39 + 16))(v39))
      {
        unsigned int v91 = length_high;
        int v92 = TAATMorphChain::FlagsForOptionalLigatures((TAATMorphChain *)v39);
        unint64_t v108 = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&long long v41 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v41 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v107[5] = v41;
        v107[6] = v41;
        v107[3] = v41;
        v107[4] = v41;
        v107[1] = v41;
        v107[2] = v41;
        v107[0] = v41;
        *(void *)cStr = 0;
        uint64_t v105 = 0;
        unsigned int v106 = 0;
        id v109 = v107;
        if (v36 >= 1)
        {
          for (uint64_t i = 0; i != v36; ++i)
          {
            uint64_t v43 = *(void *)(*(void *)(*(void *)(*(void *)a1[1] + 16) + 8 * (i + v95.location)) + 48);
            int v44 = TAATMorphChain::ResolveFlags((TAATMorphChain *)v39, v39[10], (atomic_ullong *)(*(void *)(atomic_load_explicit((atomic_ullong *volatile)(v43 + 56), memory_order_acquire)+ 40)+ 168), (atomic_ullong *)(v43 + 40), 0);
            int v45 = v44;
            uint64_t v46 = v105;
            if (v105 >= v106)
            {
              int v48 = *(char **)cStr;
              uint64_t v49 = (uint64_t)&v105[-*(void *)cStr] >> 2;
              unint64_t v50 = v49 + 1;
              if ((unint64_t)(v49 + 1) >> 62) {
                abort();
              }
              uint64_t v51 = (uint64_t)&v106[-*(void *)cStr];
              if ((uint64_t)&v106[-*(void *)cStr] >> 1 > v50) {
                unint64_t v50 = v51 >> 1;
              }
              if ((unint64_t)v51 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v52 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v52 = v50;
              }
              char v100 = v107;
              if (v52)
              {
                CGRect v53 = (char *)TInlineBufferAllocator<unsigned int,30ul>::allocate((uint64_t)v107, v52);
                int v48 = *(char **)cStr;
                uint64_t v46 = v105;
              }
              else
              {
                CGRect v53 = 0;
              }
              uint64_t v54 = &v53[4 * v49];
              *(_DWORD *)uint64_t v54 = v45;
              if (v46 == v48)
              {
                CGRect v56 = &v53[4 * v49];
              }
              else
              {
                id v55 = v46;
                CGRect v56 = &v53[4 * v49];
                do
                {
                  int v57 = *((_DWORD *)v55 - 1);
                  v55 -= 4;
                  *((_DWORD *)v56 - 1) = v57;
                  v56 -= 4;
                }
                while (v55 != v48);
              }
              int v47 = v54 + 4;
              *(void *)cStr = v56;
              uint64_t v105 = v54 + 4;
              double v58 = v106;
              unsigned int v106 = &v53[4 * v52];
              char v98 = v46;
              int v99 = v58;
              *(void *)uint64_t v96 = v48;
              double v97 = v48;
              std::__split_buffer<unsigned int,TInlineBufferAllocator<unsigned int,30ul> &>::~__split_buffer((uint64_t)v96);
            }
            else
            {
              *(_DWORD *)uint64_t v105 = v44;
              int v47 = v46 + 4;
            }
            uint64_t v105 = v47;
          }
        }
        LODWORD(v95.length) = -1431655766;
        uint64_t v59 = (*(uint64_t (**)(unsigned int *, CFIndex *))(*(void *)v39 + 40))(v39, &v95.length);
        if (LODWORD(v95.length))
        {
          CGSize v60 = (_DWORD *)v59;
          uint64_t v61 = 0;
          while (((*(uint64_t (**)(_DWORD *))(*(void *)v60 + 16))(v60) & 1) != 0)
          {
            if (v36 >= 1)
            {
              uint64_t v62 = 0;
              int v63 = v60[2];
              do
              {
                int v64 = *(_DWORD *)(*(void *)cStr + 4 * v62);
                if ((v64 & v63) != 0)
                {
                  CFIndex v65 = v62 + v95.location;
                  uint64_t v66 = 1;
                  do
                  {
                    CFIndex v67 = v66;
                    CFIndex v68 = v62 + v66;
                    if (v62 + v66 >= v36 || (v63 & v92) != 0) {
                      break;
                    }
                    int v70 = *(_DWORD *)(*(void *)cStr + 4 * v62 + 4 * v66++) ^ v64;
                  }
                  while ((v70 & v63) == 0);
                  id v71 = (const unsigned __int8 *)(*(uint64_t (**)(unsigned int *, uint64_t))(*(void *)v39 + 32))(v39, v61);
                  if (!v71
                    || (v113.locatioCFIndex n = v95.location,
                        v113.unsigned int length = v36,
                        TRunGlue::CoveredByBitmap((TRunGlue *)a1[1], v71, v113)))
                  {
                    v111.locatioCFIndex n = v65;
                    v111.unsigned int length = v67;
                    TRunGlue::SetRunRange((TRunGlue *)a1[1], v111);
                    double v72 = (TRunGlue *)a1[1];
                    v103[0] = &unk_1ED060E00;
                    v103[3] = v103;
                    uint64_t v73 = TRunGlue::GlyphRangeByTrimming(v72, (uint64_t)v103);
                    uint64_t v75 = v74;
                    std::__function::__value_func<BOOL ()(TRunGlue::TGlyph)>::~__value_func[abi:nn180100](v103);
                    if (v75)
                    {
                      int v76 = (*(uint64_t (**)(_DWORD *, uint64_t, uint64_t, uint64_t))(*(void *)v60 + 40))(v60, a1[1], v73, v75);
                      if (v76)
                      {
                        if (v76 == 5)
                        {
                          *(void *)uint64_t v96 = cStr;
                          std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v96);
                          return 0;
                        }
                        *a2 = 1;
                        if (v76 >= 2)
                        {
                          CGRect v77 = (TRunGlue *)a1[1];
                          *((unsigned char *)v77 + 592) = 1;
                          if (v76 == 3)
                          {
                            if (TRunGlue::length(v77) > a1[2]) {
                              break;
                            }
                          }
                          else if (v76 == 6)
                          {
                            break;
                          }
                        }
                      }
                    }
                  }
                }
                else
                {
                  CFIndex v68 = v62 + 1;
                }
                uint64_t v62 = v68;
              }
              while (v68 < v36);
            }
            uint64_t v61 = (v61 + 1);
            unsigned int length = v95.length;
            if (v61 >= LODWORD(v95.length)) {
              goto LABEL_94;
            }
          }
          unsigned int length = v95.length;
LABEL_94:
          if (v61 < length)
          {
            *(_DWORD *)uint64_t v96 = bswap32(*((_DWORD *)a1 + 7));
            v96[4] = 0;
            uint64_t v86 = (__CFString *)CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v96, 0);
            int64_t v90 = TFont::DebugDescription(*(TFont **)(a1[1] + 616));
            CFLog();

            uint64_t v82 = *(void *)(*(void *)(a1[1] + 616) + 400);
            (*(void (**)(uint64_t, void))(*(void *)v82 + 488))(v82, *((unsigned int *)a1 + 7));
            a1[4] = 0;
            unsigned int length_high = HIDWORD(v95.length);

            *(void *)uint64_t v96 = cStr;
            std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v96);
            uint64_t v38 = 0;
            goto LABEL_101;
          }
        }
        *(void *)uint64_t v96 = cStr;
        std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v96);
        unsigned int length_high = v91 + 1;
        if (v91 + 1 >= HIDWORD(v95.length)) {
          break;
        }
      }
      uint64_t v38 = 1;
    }
    else
    {
      unsigned int length_high = 0;
    }
LABEL_101:
    if (length_high < HIDWORD(v95.length))
    {
      *(_DWORD *)cStr = bswap32(*((_DWORD *)a1 + 7));
      char cStr[4] = 0;
      uint64_t v83 = (__CFString *)CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], cStr, 0);
      uint64_t v87 = TFont::DebugDescription(*(TFont **)(a1[1] + 616));
      CFLog();

      uint64_t v79 = *(void *)(*(void *)(a1[1] + 616) + 400);
      (*(void (**)(uint64_t, void))(*(void *)v79 + 488))(v79, *((unsigned int *)a1 + 7));
      a1[4] = 0;

      uint64_t v38 = 0;
    }
    v112.locatioCFIndex n = v95.location;
    v112.unsigned int length = v36;
    TRunGlue::SetRunRange((TRunGlue *)a1[1], v112);
    return v38;
  }
  id v4 = (TRunGlue *)a1[1];
  v102[0] = &unk_1ED060D70;
  v102[3] = v102;
  uint64_t v5 = TRunGlue::GlyphRangeByTrimming(v4, (uint64_t)v102);
  uint64_t v7 = v6;
  std::__function::__value_func<BOOL ()(TRunGlue::TGlyph)>::~__value_func[abi:nn180100](v102);
  if (v7 < 1) {
    return 1;
  }
  unsigned int v8 = *(_DWORD *)a1[5];
  *(_DWORD *)uint64_t v96 = -1431655766;
  uint64_t v9 = (*(uint64_t (**)(uint64_t *, char *))(*a1 + 16))(a1, v96);
  uint64_t result = 1;
  unsigned int v11 = 0;
  if (!*(_DWORD *)v96) {
    goto LABEL_106;
  }
  unsigned int v93 = bswap32(v8) >> 16;
  while (1)
  {
    if (!(*(unsigned int (**)(uint64_t, void))(*(void *)v9 + 16))(v9, v93))
    {
LABEL_104:
      uint64_t result = 1;
      goto LABEL_106;
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB2CDF80, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB2CDF80))
    {
      _MergedGlobals_9 = GetLocaleChangedCount();
      __cxa_guard_release(&qword_1EB2CDF80);
    }
    LocaleChangedCFIndex Count = GetLocaleChangedCount();
    int v13 = LocaleChangedCount;
    int v14 = _MergedGlobals_9;
    uint64_t v15 = a1[1];
    uint64_t v16 = *(void *)(v15 + 616);
    int v17 = (atomic_ullong *)(v16 + 168);
    uint64_t v18 = *(void *)(v15 + 152);
    if (!v18) {
      goto LABEL_115;
    }
    if (atomic_load_explicit((atomic_ullong *volatile)(v18 + 64), memory_order_acquire) && LocaleChangedCount == v14)
    {
      CFDictionaryRef v24 = (atomic_ullong *)(v18 + 40);
      uint64_t v22 = *(unsigned int *)(v9 + 40);
      CFIndex v23 = (TAATMorphChain *)v9;
      locatioCFIndex n = 0;
    }
    else
    {
LABEL_115:
      if (!v95.location && !v11)
      {
        int v20 = *(_DWORD *)(v16 + 4 * *(unsigned __int8 *)(v9 + 64) + 288);
        if (v20) {
          BOOL v21 = LocaleChangedCount == v14;
        }
        else {
          BOOL v21 = 0;
        }
        if (!v21)
        {
          int v20 = TAATMorphChain::ResolveFlags((TAATMorphChain *)v9, *(unsigned int *)(v9 + 40), v17, 0, 0);
          *(_DWORD *)(v16 + 4 * *(unsigned __int8 *)(v9 + 64) + 288) = v20;
          if (v13 != v14) {
            _MergedGlobals_9 = v13;
          }
        }
        goto LABEL_23;
      }
      uint64_t v22 = *(unsigned int *)(v9 + 40);
      CFIndex v23 = (TAATMorphChain *)v9;
      CFDictionaryRef v24 = 0;
      locatioCFIndex n = (__CFString *)v95.location;
    }
    int v20 = TAATMorphChain::ResolveFlags(v23, v22, v17, v24, location);
LABEL_23:
    LODWORD(v103[0]) = -1431655766;
    uint64_t v26 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v9 + 40))(v9, v103);
    if (LODWORD(v103[0]))
    {
      unint64_t v27 = (_DWORD *)v26;
      uint64_t v28 = 0;
      do
      {
        if (!(*(unsigned int (**)(_DWORD *))(*(void *)v27 + 16))(v27)) {
          break;
        }
        if ((v27[2] & v20) != 0)
        {
          unint64_t v29 = (const unsigned __int8 *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v9 + 32))(v9, v28);
          if (!v29 || TRunGlue::CoveredByBitmap((TRunGlue *)a1[1], v29, *(CFRange *)(a1[1] + 8)))
          {
            int v30 = (*(uint64_t (**)(_DWORD *, uint64_t, uint64_t, uint64_t))(*(void *)v27 + 40))(v27, a1[1], v5, v7);
            if (v30)
            {
              int v31 = v30;
              if (v30 == 5) {
                return 0;
              }
              *a2 = 1;
              uint64_t v32 = (TRunGlue *)a1[1];
              if (v31 >= 2)
              {
                *((unsigned char *)v32 + 592) = 1;
                if (v31 == 3)
                {
                  if (TRunGlue::length(v32) > a1[2]) {
                    break;
                  }
                  uint64_t v32 = (TRunGlue *)a1[1];
                }
                else if (v31 == 6)
                {
                  break;
                }
              }
              v101[0] = &unk_1ED060DB8;
              v101[3] = v101;
              uint64_t v5 = TRunGlue::GlyphRangeByTrimming(v32, (uint64_t)v101);
              uint64_t v7 = v33;
              std::__function::__value_func<BOOL ()(TRunGlue::TGlyph)>::~__value_func[abi:nn180100](v101);
            }
          }
        }
        uint64_t v28 = (v28 + 1);
      }
      while (v28 < LODWORD(v103[0]));
      if (v28 < LODWORD(v103[0])) {
        break;
      }
    }
    if (++v11 >= *(_DWORD *)v96) {
      goto LABEL_104;
    }
  }
  *(_DWORD *)cStr = bswap32(*((_DWORD *)a1 + 7));
  char cStr[4] = 0;
  uint64_t v84 = (__CFString *)CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], cStr, 0);
  long long v88 = TFont::DebugDescription(*(TFont **)(a1[1] + 616));
  CFLog();

  uint64_t v80 = *(void *)(*(void *)(a1[1] + 616) + 400);
  (*(void (**)(uint64_t, void))(*(void *)v80 + 488))(v80, *((unsigned int *)a1 + 7));
  a1[4] = 0;
  unsigned int v11 = *(_DWORD *)v96;

  uint64_t result = 0;
LABEL_106:
  if (v11 < *(_DWORD *)v96)
  {
    *(_DWORD *)cStr = bswap32(*((_DWORD *)a1 + 7));
    char cStr[4] = 0;
    uint64_t v85 = (__CFString *)CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], cStr, 0);
    int v89 = TFont::DebugDescription(*(TFont **)(a1[1] + 616));
    CFLog();

    uint64_t v81 = *(void *)(*(void *)(a1[1] + 616) + 400);
    (*(void (**)(uint64_t, void))(*(void *)v81 + 488))(v81, *((unsigned int *)a1 + 7));
    a1[4] = 0;

    return 0;
  }
  return result;
}

uint64_t TAATMorphSubtableMorx::NextSubtable(TAATMorphSubtableMorx *this)
{
  uint64_t v1 = (unsigned int *)*((void *)this + 14);
  *((void *)this + 13) = v1;
  unsigned int v2 = v1 + 2;
  unint64_t v3 = *((void *)this + 12);
  if (*((void *)this + 11) > (unint64_t)(v1 + 2) || (unint64_t)(v1 + 3) > v3) {
    return 0;
  }
  uint64_t v5 = (char *)v1 + bswap32(*v1);
  *((void *)this + 14) = v5;
  if ((unint64_t)v5 > v3) {
    return 0;
  }
  *((_DWORD *)this + 2) = bswap32(*v2);
  return 1;
}

uint64_t TAATMorphChainMorx::GetCoverage(TAATMorphChainMorx *this, unsigned int a2)
{
  uint64_t v2 = *((void *)this + 24);
  if (a2 >= (unint64_t)((*((void *)this + 25) - v2) >> 3)) {
    return 0;
  }
  else {
    return *(void *)(v2 + 8 * a2);
  }
}

uint64_t TAATMorphSubtableMorx::Process(TAATMorphSubtableMorx *this, TRunGlue *a2, CFRange a3)
{
  uint64_t v3 = MEMORY[0x1F4188790](this, a2);
  uint64_t v6 = v5;
  uint64_t v8 = v7;
  uint64_t v9 = (TRunGlue *)v4;
  uint64_t v10 = v3;
  uint64_t v490 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = *(void *)(v3 + 104);
  unsigned int v12 = bswap32(*(_DWORD *)(v11 + 4));
  if ((v12 & 0x20000000) == 0 && *(unsigned char *)(v3 + 80) != v12 >> 31) {
    return 0;
  }
  if ((v12 & 0x40000000) != 0) {
    int v13 = -1;
  }
  else {
    int v13 = 1;
  }
  *(_DWORD *)(v3 + 12) = v13;
  if ((v12 & 0x10000000) != 0) {
    *(_DWORD *)(v3 + 12) = *(_DWORD *)(v4 + 24) * v13;
  }
  uint64_t v14 = *(void *)(v4 + 16);
  if (v14 == 1)
  {
    memset(__b, 170, sizeof(__b));
    memset(v457, 170, sizeof(v457));
    unsigned int v455 = 0;
    unsigned int v456 = -1431655766;
    switch((char)v12)
    {
      case 0:
LABEL_124:
        if ((unint64_t)(v11 + 28) > *(void *)(v10 + 112)
          || !TAATMorphSubtableMorx::InitRearrangementState(v10, v9, __b))
        {
          return 6;
        }
        if (TAATMorphSubtableMorx::FetchInitialClass((TAATMorphSubtableMorx *)v10, v9, v8, v6, (TRunGlue **)&v457[1], v457, &v456))TAATMorphSubtableMorx::DoRearrangementSubtable(v10, v9, (uint64_t *)__b, (TRunGlue *)v457[1], v457[2], v457[0], v456, (int *)&v455); {
        return v455;
        }
      case 1:
        if ((unint64_t)(v11 + 32) > *(void *)(v10 + 112)
          || !TAATMorphSubtableMorx::InitContextualState(v10, v9, (uint64_t *)__b))
        {
          return 6;
        }
        if (!TAATMorphSubtableMorx::FetchInitialClass((TAATMorphSubtableMorx *)v10, v9, v8, v6, (TRunGlue **)&v457[1], v457, &v456))return v455; {
        v450 = v9;
        }
        uint64_t v56 = v457[2];
        uint64_t v57 = v457[0];
        unsigned int Class = (unsigned __int16)v456;
        uint64_t v59 = HIWORD(v456);
        v438 = (TRunGlue *)v457[1];
        uint64_t v427 = *(void *)(v457[1] + 176) + 2 * *(void *)(v457[1] + 160);
        int v60 = *(unsigned __int16 *)(v427 + 2 * v457[2]);
        memset((char *)&v489[1] + 8, 170, 24);
        memset(v489, 0, 24);
        *(void *)&v489[3] = (char *)&v489[1] + 8;
        while (2)
        {
          uint64_t v62 = *((void *)&__b[1] + 1);
          uint64_t v61 = *(void *)&__b[1];
          int v64 = (TRunGlue *)*((void *)&__b[0] + 1);
          uint64_t v63 = *(void *)&__b[0];
          v444 = (TRunGlue *)v56;
          v432 = (TRunGlue *)*((void *)&__b[0] + 1);
LABEL_72:
          if (v57)
          {
            if (v60 == 0xFFFF) {
              goto LABEL_92;
            }
            uint64_t v65 = v63;
            BOOL IsDeleted = TRunGlue::IsDeleted(v438, v56);
            uint64_t v63 = v65;
            if (IsDeleted) {
              goto LABEL_92;
            }
          }
          CFIndex v67 = (unsigned __int16 *)(v61 + 2 * ((void)v64 * (unsigned __int16)v59 + Class));
          unint64_t v68 = *(void *)(v10 + 104);
          unint64_t v69 = *(void *)(v10 + 112);
          if (v68 > (unint64_t)v67 || (unint64_t)(v67 + 1) > v69) {
            goto LABEL_511;
          }
          uint64_t v71 = bswap32(*v67) >> 16;
          double v72 = (unsigned __int16 *)(v62 + 8 * v71);
          if (v68 > (unint64_t)v72 || (unint64_t)(v72 + 4) > v69) {
            goto LABEL_511;
          }
          unsigned int v74 = *v72;
          uint64_t v75 = v62;
          int v76 = (unsigned __int16 *)(v62 + 8 * v71);
          unsigned int v77 = v76[1];
          unsigned int v78 = v76[2];
          unsigned int v79 = v76[3];
          if (v78 != 0xFFFF)
          {
            uint64_t v80 = v63;
            int v81 = TAATMorphSubtableMorx::DoContextualSubstitution(v10, (uint64_t)v450, __rev16(v78), v450, v63, &v455);
            uint64_t v63 = v80;
            if (!v81) {
              goto LABEL_511;
            }
          }
          uint64_t v56 = (uint64_t)v444;
          if (v79 != 0xFFFF)
          {
            unsigned int v82 = __rev16(v79);
            uint64_t v83 = v63;
            int v84 = TAATMorphSubtableMorx::DoContextualSubstitution(v10, (uint64_t)v450, v82, v438, (uint64_t)v444, &v455);
            uint64_t v63 = v83;
            if (!v84)
            {
LABEL_511:
              *(void *)&__b[0] = v63;
LABEL_512:
              v372 = (int64x2_t *)v489;
              goto LABEL_513;
            }
          }
          uint64_t v85 = bswap32(v74) >> 16;
          int v86 = (int)bswap32(v77) >> 16;
          if (v86 < 0) {
            uint64_t v63 = (uint64_t)v444;
          }
          if ((v86 & 0x4000) != 0)
          {
            long long v88 = (_WORD *)*((void *)&v489[0] + 1);
            uint64_t v62 = v75;
            int v89 = *(unsigned __int16 **)&v489[0];
            if (*(void *)&v489[0] != *((void *)&v489[0] + 1))
            {
              while (*v89 != v60 || v89[1] != (unsigned __int16)v59 || v89[2] != v85)
              {
                v89 += 3;
                if (v89 == *((unsigned __int16 **)&v489[0] + 1))
                {
                  int v89 = (unsigned __int16 *)*((void *)&v489[0] + 1);
                  break;
                }
              }
            }
            if (v89 == *((unsigned __int16 **)&v489[0] + 1))
            {
              *(void *)&__b[0] = v63;
              if (*((void *)&v489[0] + 1) >= *(void *)&v489[1])
              {
                unint64_t v91 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v489[0] + 1) - *(void *)&v489[0]) >> 1);
                unint64_t v92 = v91 + 1;
                if (v91 + 1 > 0x2AAAAAAAAAAAAAAALL) {
                  goto LABEL_532;
                }
                if (0x5555555555555556 * ((uint64_t)(*(void *)&v489[1] - *(void *)&v489[0]) >> 1) > v92) {
                  unint64_t v92 = 0x5555555555555556 * ((uint64_t)(*(void *)&v489[1] - *(void *)&v489[0]) >> 1);
                }
                if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&v489[1] - *(void *)&v489[0]) >> 1) >= 0x1555555555555555) {
                  unint64_t v93 = 0x2AAAAAAAAAAAAAAALL;
                }
                else {
                  unint64_t v93 = v92;
                }
                *((void *)&v473 + 1) = (char *)&v489[1] + 8;
                if (v93) {
                  double v94 = (char *)TInlineBufferAllocator<std::tuple<unsigned short,unsigned short,unsigned short>,4ul>::allocate((uint64_t)&v489[1] + 8, v93);
                }
                else {
                  double v94 = 0;
                }
                CFRange v95 = &v94[6 * v91];
                *(_WORD *)CFRange v95 = v60;
                *((_WORD *)v95 + 1) = v59;
                *((_WORD *)v95 + 2) = v85;
                uint64_t v96 = *((void *)&v489[0] + 1);
                uint64_t v97 = *(void *)&v489[0];
                if (*((void *)&v489[0] + 1) == *(void *)&v489[0])
                {
                  int64x2_t v101 = vdupq_n_s64(*((unint64_t *)&v489[0] + 1));
                  char v98 = &v94[6 * v91];
                }
                else
                {
                  char v98 = &v94[6 * v91];
                  do
                  {
                    int v99 = *(_DWORD *)(v96 - 6);
                    v96 -= 6;
                    __int16 v100 = *(_WORD *)(v96 + 4);
                    *(_DWORD *)(v98 - 6) = v99;
                    v98 -= 6;
                    *((_WORD *)v98 + 2) = v100;
                  }
                  while (v96 != v97);
                  int64x2_t v101 = (int64x2_t)v489[0];
                }
                int64_t v90 = v95 + 6;
                *(void *)&v489[0] = v98;
                *((void *)&v489[0] + 1) = v95 + 6;
                int64x2_t v472 = v101;
                uint64_t v102 = *(void *)&v489[1];
                *(void *)&v489[1] = &v94[6 * v93];
                *(void *)&long long v473 = v102;
                __src = (void *)v101.i64[0];
                std::__split_buffer<std::tuple<unsigned short,unsigned short,unsigned short>,TInlineBufferAllocator<std::tuple<unsigned short,unsigned short,unsigned short>,4ul> &>::~__split_buffer((uint64_t)&__src);
              }
              else
              {
                **((_WORD **)&v489[0] + 1) = v60;
                v88[1] = v59;
                int64_t v90 = v88 + 3;
                v88[2] = v85;
              }
              *((void *)&v489[0] + 1) = v90;
              uint64_t v56 = (uint64_t)v444;
LABEL_121:
              int v60 = *(unsigned __int16 *)(v427 + 2 * v56);
              unsigned int Class = TAATMorphSubtableMorx::FetchClass((TAATMorphSubtableMorx *)v10, v60);
              uint64_t v59 = v85;
              continue;
            }
            uint64_t v59 = v85;
          }
          else
          {
            uint64_t v59 = v85;
            uint64_t v62 = v75;
          }
          break;
        }
        int v64 = v432;
LABEL_92:
        *((void *)&v489[0] + 1) = *(void *)&v489[0];
        uint64_t v87 = v57 - 1;
        if (v57 <= 1)
        {
          unsigned int Class = 0;
          uint64_t v57 = 0;
          if (v87) {
            goto LABEL_511;
          }
          goto LABEL_72;
        }
        *(void *)&__b[0] = v63;
        v56 += *(int *)(v10 + 12);
        uint64_t v85 = v59;
        --v57;
        goto LABEL_121;
      case 2:
        if ((unint64_t)(v11 + 40) > *(void *)(v10 + 112)
          || !TAATMorphSubtableMorx::InitLigatureState(v10, __b))
        {
          return 6;
        }
        if (!TAATMorphSubtableMorx::FetchInitialClass((TAATMorphSubtableMorx *)v10, v9, v8, v6, (TRunGlue **)&v457[1], v457, &v456))return v455; {
        v452 = v9;
        }
        int v179 = 0;
        unsigned int v180 = 0;
        v181 = 0;
        uint64_t v182 = v457[1];
        uint64_t v183 = v457[0];
        unsigned int v184 = (unsigned __int16)v456;
        uint64_t v185 = HIWORD(v456);
        uint64_t v406 = *(void *)(v457[1] + 176) + 2 * *(void *)(v457[1] + 160);
        uint64_t v418 = v457[2];
        uint64_t v186 = *(unsigned __int16 *)(v406 + 2 * v457[2]);
        memset(v469, 170, sizeof(v469));
        v468 = 0;
        int64x2_t v467 = 0uLL;
        uint64_t v384 = v457[1];
        v470 = v469;
        unsigned __int16 v416 = -1;
LABEL_238:
        uint64_t v420 = *((void *)&__b[128] + 1);
        uint64_t v187 = *((void *)&__b[129] + 1);
        uint64_t v424 = *(void *)&__b[129];
        int v188 = __b[128];
        uint64_t v413 = *((void *)&__b[129] + 1);
        do
        {
          if (!v183) {
            goto LABEL_242;
          }
          if (v186 != 0xFFFF)
          {
            int v189 = (TRunGlue *)v182;
            uint64_t v190 = v182;
            uint64_t v191 = v186;
            uint64_t v192 = v183;
            BOOL v193 = TRunGlue::IsDeleted(v189, v418);
            uint64_t v187 = v413;
            uint64_t v186 = v191;
            uint64_t v182 = v190;
            uint64_t v183 = v192;
            if (!v193)
            {
LABEL_242:
              v194 = (unsigned int *)(v424 + 2 * (v420 * (unsigned __int16)v185 + v184));
              v196 = *(unsigned int **)(v10 + 104);
              unint64_t v195 = *(void *)(v10 + 112);
              if (v196 > v194 || (unint64_t)v194 + 2 > v195) {
                goto LABEL_505;
              }
              if (v181 == (unsigned __int16 *)v194)
              {
                v194 = (unsigned int *)v181;
              }
              else
              {
                unsigned int v198 = bswap32(*(unsigned __int16 *)v194) >> 16;
                int v179 = (unsigned int *)(v187 + 6 * v198);
                if (v196 > v179 || (unint64_t)v179 + 6 > v195) {
                  goto LABEL_505;
                }
                unsigned __int16 v416 = v185;
                unsigned int v180 = bswap32(*(unsigned __int16 *)(v187 + 6 * v198 + 2)) >> 16;
                uint64_t v185 = bswap32(*(unsigned __int16 *)v179) >> 16;
              }
              __int16 v200 = v180;
              if ((unsigned __int16)v180 >= 0x2000u)
              {
                if ((v180 & 0x8000) != 0)
                {
                  LODWORD(__b[128]) = v188 + 1;
                  if (v188 > 126)
                  {
                    int v188 = 0;
                    LODWORD(__b[128]) = 0;
                  }
                  else
                  {
                    int v201 = DWORD1(__b[128]);
                    if (v188 + 1 > SDWORD1(__b[128])) {
                      int v201 = v188 + 1;
                    }
                    DWORD1(__b[128]) = v201;
                    ++v188;
                  }
                  id v202 = (uint64_t *)&__b[v188];
                  *id v202 = v182;
                  v202[1] = v418;
                }
                if ((v180 & 0x2000) == 0) {
                  goto LABEL_303;
                }
                __int16 v401 = v180;
                unsigned int v404 = v180;
                if (v188 < 0) {
                  goto LABEL_505;
                }
                v386 = v194;
                unsigned int v389 = v186;
                uint64_t v392 = v183;
                uint64_t v395 = v185;
                v398 = v179;
                unsigned int v203 = bswap32(*((unsigned __int16 *)v179 + 2)) >> 16;
                memset(v489, 170, sizeof(v489));
                int v204 = 0;
                long long v205 = v196 + 3;
                uint64_t v206 = (uint64_t)v196 + bswap32(v196[7]) + 12;
                unsigned int v207 = v196[9];
                uint64_t v208 = (uint64_t)v196 + bswap32(v196[8]) + 12;
                uint64_t v209 = -1;
                uint64_t v466 = -1;
                v429 = (char *)v205 + bswap32(v207);
                __int16 v465 = -1;
                unint64_t v210 = v206 + 4 * v203;
                *(void *)&long long v211 = 0xAAAAAAAAAAAAAAAALL;
                *((void *)&v211 + 1) = 0xAAAAAAAAAAAAAAAALL;
                long long v486 = v211;
                long long v487 = v211;
                long long v484 = v211;
                long long v485 = v211;
                long long v482 = v211;
                long long v483 = v211;
                long long v480 = v211;
                long long v481 = v211;
                long long v478 = v211;
                long long v479 = v211;
                long long v476 = v211;
                long long v477 = v211;
                long long v474 = v211;
                long long v475 = v211;
                long long v473 = v211;
                __src = 0;
                int64x2_t v472 = 0uLL;
                v488 = &v473;
                v460 = (void **)v10;
                v461 = v452;
                p_src = &__src;
                v463 = &v466;
                v464 = &v465;
                id v212 = (TRunGlue *)((char *)v489 + 8);
                uint64_t v213 = 1;
                int v214 = DWORD1(__b[128]);
                do
                {
                  v440 = (TRunGlue *)v213;
                  v446 = (TRunGlue *)v209;
                  v434 = v212;
                  unint64_t v215 = *(void *)(v10 + 104);
                  unint64_t v216 = *(void *)(v10 + 112);
                  if (v215 > v210 || v210 + 4 > v216) {
                    goto LABEL_504;
                  }
                  v210 += 4;
                  while (1)
                  {
                    unsigned int v218 = bswap32(*(_DWORD *)(v210 - 4));
                    long long v219 = &__b[v188];
                    uint64_t v221 = *v219;
                    uint64_t v220 = v219[1];
                    v222 = (unsigned __int16 *)(v208
                                              + 2
                                              * (*(unsigned __int16 *)(*(void *)(*v219 + 176)
                                                                     + 2 * *(void *)(*v219 + 160)
                                                                     + 2 * v220)
                                               + ((int)(4 * v218) >> 2)));
                    if (v215 > (unint64_t)v222 || (unint64_t)(v222 + 1) > v216) {
                      goto LABEL_504;
                    }
                    v204 += bswap32(*v222) >> 16;
                    if (v218 >> 30) {
                      break;
                    }
                    uint64_t v459 = v220;
                    std::vector<long,TInlineBufferAllocator<long,30ul>>::insert((uint64_t)&__src, (char *)__src, &v459);
                    unsigned int v455 = 1;
                    if (v188 >= 1) {
                      --v188;
                    }
                    else {
                      int v188 = v214;
                    }
                    unint64_t v215 = *(void *)(v10 + 104);
                    if (v215 <= v210)
                    {
                      unint64_t v216 = *(void *)(v10 + 112);
                      v210 += 4;
                      if (v210 <= v216) {
                        continue;
                      }
                    }
                    goto LABEL_504;
                  }
                  v224 = &v429[2 * v204];
                  if (v215 > (unint64_t)v224 || (unint64_t)(v224 + 2) > v216) {
                    goto LABEL_504;
                  }
                  if (v466 != -1)
                  {
                    TAATMorphSubtableMorx::DoLigatureAction<TRunGlue::TGlyphInVector>(TRunGlue&,unsigned short,TAATMorphSubtableMorx::MorxLigatureState *,MorphActionResultCode &)::{lambda(void)#1}::operator()((uint64_t)&v460);
                    v472.i64[0] = (uint64_t)__src;
                  }
                  uint64_t v466 = v220;
                  __int16 v465 = bswap32(*(unsigned __int16 *)v224) >> 16;
                  if (v446 == (TRunGlue *)127)
                  {
LABEL_504:
                    v460 = &__src;
                    std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](&v460);
                    goto LABEL_505;
                  }
                  uint64_t v209 = (uint64_t)v446 + 1;
                  v226 = &v489[(void)((void)v446 + 1)];
                  void *v226 = v221;
                  v226[1] = v220;
                  unsigned int v455 = 1;
                  if (v188 >= 1) {
                    --v188;
                  }
                  else {
                    int v188 = v214;
                  }
                  v228 = v434;
                  uint64_t v227 = (uint64_t)v440;
                  uint64_t v213 = (uint64_t)v440 + 1;
                  id v212 = (TRunGlue *)((char *)v434 + 16);
                }
                while ((v218 & 0x80000000) == 0);
                LODWORD(__b[128]) = v188;
                TAATMorphSubtableMorx::DoLigatureAction<TRunGlue::TGlyphInVector>(TRunGlue&,unsigned short,TAATMorphSubtableMorx::MorxLigatureState *,MorphActionResultCode &)::{lambda(void)#1}::operator()((uint64_t)&v460);
                if ((int)v446 < -1)
                {
                  uint64_t v182 = v384;
                  v194 = v386;
                  uint64_t v185 = v395;
                  unsigned int v180 = v404;
                }
                else
                {
                  uint64_t v182 = v384;
                  v194 = v386;
                  uint64_t v185 = v395;
                  unsigned int v180 = v404;
                  do
                  {
                    if (v188 > 126)
                    {
                      int v188 = 0;
                    }
                    else
                    {
                      int v229 = DWORD1(__b[128]);
                      if (v188 + 1 > SDWORD1(__b[128])) {
                        int v229 = v188 + 1;
                      }
                      DWORD1(__b[128]) = v229;
                      ++v188;
                    }
                    uint64_t v230 = *(void *)v228;
                    v231 = &__b[v188];
                    void *v231 = *((void *)v228 - 1);
                    v231[1] = v230;
                    v228 = (TRunGlue *)((char *)v228 - 16);
                    BOOL v28 = v227-- <= 1;
                  }
                  while (!v28);
                  LODWORD(__b[128]) = v188;
                }
                v460 = &__src;
                std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](&v460);
                int v179 = v398;
                uint64_t v183 = v392;
                uint64_t v186 = v389;
                uint64_t v187 = v413;
                __int16 v200 = v401;
LABEL_303:
                if ((v200 & 0x4000) != 0)
                {
                  v233 = (_WORD *)v467.i64[1];
                  v234 = (unsigned __int16 *)v467.i64[0];
                  if (v467.i64[0] != v467.i64[1])
                  {
                    while (*v234 != v186 || v234[1] != v416 || v234[2] != (unsigned __int16)v185)
                    {
                      v234 += 3;
                      if (v234 == (unsigned __int16 *)v467.i64[1])
                      {
                        v234 = (unsigned __int16 *)v467.i64[1];
                        break;
                      }
                    }
                  }
                  if (v234 == (unsigned __int16 *)v467.i64[1])
                  {
                    uint64_t v235 = v185;
                    if (v467.i64[1] < (unint64_t)v468)
                    {
                      uint64_t v236 = v183;
                      *(_WORD *)v467.i64[1] = v186;
                      v233[1] = v416;
                      v237 = v233 + 3;
                      v233[2] = v235;
                      goto LABEL_333;
                    }
                    unint64_t v238 = 0xAAAAAAAAAAAAAAABLL * ((v467.i64[1] - v467.i64[0]) >> 1);
                    unint64_t v239 = v238 + 1;
                    if (v238 + 1 <= 0x2AAAAAAAAAAAAAAALL)
                    {
                      uint64_t v236 = v183;
                      if (0x5555555555555556 * ((uint64_t)&v468[-v467.i64[0]] >> 1) > v239) {
                        unint64_t v239 = 0x5555555555555556 * ((uint64_t)&v468[-v467.i64[0]] >> 1);
                      }
                      if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v468[-v467.i64[0]] >> 1) >= 0x1555555555555555) {
                        unint64_t v240 = 0x2AAAAAAAAAAAAAAALL;
                      }
                      else {
                        unint64_t v240 = v239;
                      }
                      *(void *)&v489[2] = v469;
                      if (v240)
                      {
                        __int16 v241 = v186;
                        v242 = (char *)TInlineBufferAllocator<std::tuple<unsigned short,unsigned short,unsigned short>,4ul>::allocate((uint64_t)v469, v240);
                        LOWORD(v186) = v241;
                      }
                      else
                      {
                        v242 = 0;
                      }
                      v243 = &v242[6 * v238];
                      *(_WORD *)v243 = v186;
                      *((_WORD *)v243 + 1) = v416;
                      *((_WORD *)v243 + 2) = v235;
                      uint64_t v244 = v467.i64[1];
                      uint64_t v245 = v467.i64[0];
                      if (v467.i64[1] == v467.i64[0])
                      {
                        int64x2_t v249 = vdupq_n_s64(v467.u64[1]);
                        v246 = &v242[6 * v238];
                      }
                      else
                      {
                        v246 = &v242[6 * v238];
                        do
                        {
                          int v247 = *(_DWORD *)(v244 - 6);
                          v244 -= 6;
                          __int16 v248 = *(_WORD *)(v244 + 4);
                          *(_DWORD *)(v246 - 6) = v247;
                          v246 -= 6;
                          *((_WORD *)v246 + 2) = v248;
                        }
                        while (v244 != v245);
                        int64x2_t v249 = v467;
                      }
                      v237 = v243 + 6;
                      v467.i64[0] = (uint64_t)v246;
                      v467.i64[1] = (uint64_t)(v243 + 6);
                      *(int64x2_t *)((char *)v489 + 8) = v249;
                      v250 = v468;
                      v468 = &v242[6 * v240];
                      *((void *)&v489[1] + 1) = v250;
                      *(void *)&v489[0] = v249.i64[0];
                      std::__split_buffer<std::tuple<unsigned short,unsigned short,unsigned short>,TInlineBufferAllocator<std::tuple<unsigned short,unsigned short,unsigned short>,4ul> &>::~__split_buffer((uint64_t)v489);
LABEL_333:
                      v467.i64[1] = (uint64_t)v237;
                      v181 = (unsigned __int16 *)v194;
                      uint64_t v185 = v235;
LABEL_334:
                      uint64_t v251 = *(unsigned __int16 *)(v406 + 2 * v418);
                      unsigned int v252 = TAATMorphSubtableMorx::FetchClass((TAATMorphSubtableMorx *)v10, *(unsigned __int16 *)(v406 + 2 * v418));
                      uint64_t v186 = v251;
                      unsigned int v184 = v252;
                      uint64_t v183 = v236;
                      goto LABEL_238;
                    }
LABEL_532:
                    abort();
                  }
                }
              }
              v181 = (unsigned __int16 *)v194;
            }
          }
          v467.i64[1] = v467.i64[0];
          uint64_t v232 = v183 - 1;
          if (v183 > 1)
          {
            v418 += *(int *)(v10 + 12);
            uint64_t v236 = v183 - 1;
            goto LABEL_334;
          }
          unsigned int v184 = 0;
          uint64_t v183 = 0;
        }
        while (!v232);
        goto LABEL_505;
      case 4:
        v177 = *(SFNTLookupTable **)(v10 + 112);
        if (v11 + 14 > (unint64_t)v177) {
          return 6;
        }
        v178 = (const SFNTLookupTable *)(v11 + 12);
        switch(bswap32(*(unsigned __int16 *)(v11 + 12)) >> 16)
        {
          case 0u:
            goto LABEL_520;
          case 2u:
          case 4u:
          case 6u:
LABEL_508:
            if (v11 + 18 > (unint64_t)v177) {
              return 6;
            }
            unint64_t v373 = v11 + 24;
            unsigned int v374 = bswap32(*(unsigned __int16 *)(v11 + 14)) >> 16;
            unsigned int v375 = *(unsigned __int16 *)(v11 + 16);
            goto LABEL_516;
          case 8u:
            unint64_t v253 = v11 + 18;
            if (v11 + 18 > (unint64_t)v177) {
              return 6;
            }
            uint64_t v254 = bswap32(*(unsigned __int16 *)(v11 + 16)) >> 16;
            unint64_t v255 = v253 + 2 * v254;
            unint64_t v256 = v11 + 20 <= (unint64_t)v177 ? ((unint64_t)v177 - v253) >> 1 : 0;
            BOOL v257 = v255 <= (unint64_t)v177 && v255 >= v253;
            if (!v257 && v256 != v254) {
              return 6;
            }
            goto LABEL_520;
          case 0xAu:
LABEL_514:
            unint64_t v373 = v11 + 20;
            if (v11 + 20 > (unint64_t)v177) {
              return 6;
            }
            unsigned int v374 = bswap32(*(unsigned __int16 *)(v11 + 14)) >> 16;
            unsigned int v375 = *(unsigned __int16 *)(v11 + 18);
LABEL_516:
            unint64_t v376 = v373 + (bswap32(v375) >> 16) * (unint64_t)v374;
            if (v376 < v373 || v376 > (unint64_t)v177) {
              return 6;
            }
LABEL_520:
            TAATLookupTable::SetTable(v10 + 24, v178, v177);
            TAATMorphSubtable::DoSwashSubtable((void *)v10, v9, v8, (uint64_t)v9, v8 + v6, *(void *)(v10 + 104), &v455);
            break;
          default:
            return 6;
        }
        return v455;
      case 5:
LABEL_128:
        if ((unint64_t)(v11 + 32) > *(void *)(v10 + 112)
          || !TAATMorphSubtableMorx::InitInsertionState(v10, v9, (uint64_t *)__b))
        {
          return 6;
        }
        if (TAATMorphSubtableMorx::FetchInitialClass((TAATMorphSubtableMorx *)v10, v9, v8, v6, (TRunGlue **)&v457[1], v457, &v456))TAATMorphSubtableMorx::DoInsertionSubtable(v10, v9, (uint64_t *)__b, (TRunGlue *)v457[1], v457[2], v457[0], v456, (int *)&v455); {
        return v455;
        }
      default:
        return 6;
    }
  }
  if (!v14)
  {
    memset(__b, 170, sizeof(__b));
    memset(v457, 170, sizeof(v457));
    unsigned int v455 = 0;
    unsigned int v456 = -1431655766;
    switch((char)v12)
    {
      case 0:
        goto LABEL_124;
      case 1:
        if ((unint64_t)(v11 + 32) > *(void *)(v10 + 112)
          || !TAATMorphSubtableMorx::InitContextualState(v10, v9, (uint64_t *)__b))
        {
          return 6;
        }
        if (!TAATMorphSubtableMorx::FetchInitialClass((TAATMorphSubtableMorx *)v10, v9, v8, v6, (TRunGlue **)&v457[1], v457, &v456))return v455; {
        v449 = v9;
        }
        uint64_t v15 = v457[2];
        uint64_t v16 = v457[0];
        unsigned int v17 = (unsigned __int16)v456;
        uint64_t v18 = HIWORD(v456);
        v431 = (TRunGlue *)v457[1];
        uint64_t v426 = *(void *)(v457[1] + 176) + 2 * *(void *)(v457[1] + 160);
        int v19 = *(unsigned __int16 *)(v426 + 2 * v457[2]);
        memset((char *)&v489[1] + 8, 170, 24);
        memset(v489, 0, 24);
        *(void *)&v489[3] = (char *)&v489[1] + 8;
        while (2)
        {
          uint64_t v21 = *((void *)&__b[1] + 1);
          int v20 = *(TRunGlue **)&__b[1];
          uint64_t v22 = (TRunGlue *)*((void *)&__b[0] + 1);
          v437 = (TRunGlue *)*((void *)&__b[0] + 1);
          uint64_t v23 = *(void *)&__b[0];
          v443 = *(TRunGlue **)&__b[1];
LABEL_16:
          if (v16 && v19 == 0xFFFF)
          {
            uint64_t v24 = *(void *)&v489[0];
            goto LABEL_35;
          }
          uint64_t v25 = (unsigned __int16 *)((char *)v20 + 2 * (void)v22 * (unsigned __int16)v18 + 2 * v17);
          unint64_t v26 = *(void *)(v10 + 104);
          unint64_t v27 = *(void *)(v10 + 112);
          BOOL v28 = v26 > (unint64_t)v25 || (unint64_t)(v25 + 1) > v27;
          if (!v28)
          {
            uint64_t v29 = bswap32(*v25) >> 16;
            int v30 = (unsigned __int16 *)(v21 + 8 * v29);
            if (v26 <= (unint64_t)v30 && (unint64_t)(v30 + 4) <= v27)
            {
              unsigned int v32 = *v30;
              uint64_t v33 = (unsigned __int16 *)(v21 + 8 * v29);
              unsigned int v34 = v33[1];
              unsigned int v35 = v33[2];
              unsigned int v36 = v33[3];
              if ((v35 == 0xFFFF
                 || TAATMorphSubtableMorx::DoContextualSubstitution(v10, (uint64_t)v449, __rev16(v35), v449, v23, &v455))&& (v36 == 0xFFFF|| TAATMorphSubtableMorx::DoContextualSubstitution(v10, (uint64_t)v449, __rev16(v36), v431, v15, &v455)))
              {
                uint64_t v37 = bswap32(v32) >> 16;
                int v38 = (int)bswap32(v34) >> 16;
                if (v38 < 0) {
                  uint64_t v23 = v15;
                }
                uint64_t v24 = *(void *)&v489[0];
                if ((v38 & 0x4000) != 0)
                {
                  unint64_t v40 = (_WORD *)*((void *)&v489[0] + 1);
                  long long v41 = *(unsigned __int16 **)&v489[0];
                  if (*(void *)&v489[0] != *((void *)&v489[0] + 1))
                  {
                    while (*v41 != v19 || v41[1] != (unsigned __int16)v18 || v41[2] != v37)
                    {
                      v41 += 3;
                      if (v41 == *((unsigned __int16 **)&v489[0] + 1))
                      {
                        long long v41 = (unsigned __int16 *)*((void *)&v489[0] + 1);
                        break;
                      }
                    }
                  }
                  if (v41 == *((unsigned __int16 **)&v489[0] + 1))
                  {
                    *(void *)&__b[0] = v23;
                    if (*((void *)&v489[0] + 1) >= *(void *)&v489[1])
                    {
                      unint64_t v43 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v489[0] + 1) - *(void *)&v489[0]) >> 1);
                      unint64_t v44 = v43 + 1;
                      if (v43 + 1 > 0x2AAAAAAAAAAAAAAALL) {
                        goto LABEL_532;
                      }
                      if (0x5555555555555556 * ((uint64_t)(*(void *)&v489[1] - *(void *)&v489[0]) >> 1) > v44) {
                        unint64_t v44 = 0x5555555555555556 * ((uint64_t)(*(void *)&v489[1] - *(void *)&v489[0]) >> 1);
                      }
                      if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&v489[1] - *(void *)&v489[0]) >> 1) >= 0x1555555555555555) {
                        unint64_t v45 = 0x2AAAAAAAAAAAAAAALL;
                      }
                      else {
                        unint64_t v45 = v44;
                      }
                      *((void *)&v473 + 1) = (char *)&v489[1] + 8;
                      if (v45) {
                        uint64_t v46 = (char *)TInlineBufferAllocator<std::tuple<unsigned short,unsigned short,unsigned short>,4ul>::allocate((uint64_t)&v489[1] + 8, v45);
                      }
                      else {
                        uint64_t v46 = 0;
                      }
                      int v47 = &v46[6 * v43];
                      *(_WORD *)int v47 = v19;
                      *((_WORD *)v47 + 1) = v18;
                      *((_WORD *)v47 + 2) = v37;
                      uint64_t v48 = *((void *)&v489[0] + 1);
                      uint64_t v49 = *(void *)&v489[0];
                      if (*((void *)&v489[0] + 1) == *(void *)&v489[0])
                      {
                        int64x2_t v53 = vdupq_n_s64(*((unint64_t *)&v489[0] + 1));
                        unint64_t v50 = &v46[6 * v43];
                      }
                      else
                      {
                        unint64_t v50 = &v46[6 * v43];
                        do
                        {
                          int v51 = *(_DWORD *)(v48 - 6);
                          v48 -= 6;
                          __int16 v52 = *(_WORD *)(v48 + 4);
                          *(_DWORD *)(v50 - 6) = v51;
                          v50 -= 6;
                          *((_WORD *)v50 + 2) = v52;
                        }
                        while (v48 != v49);
                        int64x2_t v53 = (int64x2_t)v489[0];
                      }
                      uint64_t v42 = v47 + 6;
                      *(void *)&v489[0] = v50;
                      *((void *)&v489[0] + 1) = v47 + 6;
                      int64x2_t v472 = v53;
                      uint64_t v54 = *(void *)&v489[1];
                      *(void *)&v489[1] = &v46[6 * v45];
                      *(void *)&long long v473 = v54;
                      __src = (void *)v53.i64[0];
                      std::__split_buffer<std::tuple<unsigned short,unsigned short,unsigned short>,TInlineBufferAllocator<std::tuple<unsigned short,unsigned short,unsigned short>,4ul> &>::~__split_buffer((uint64_t)&__src);
                    }
                    else
                    {
                      **((_WORD **)&v489[0] + 1) = v19;
                      v40[1] = v18;
                      uint64_t v42 = v40 + 3;
                      v40[2] = v37;
                    }
                    *((void *)&v489[0] + 1) = v42;
LABEL_63:
                    int v19 = *(unsigned __int16 *)(v426 + 2 * v15);
                    unsigned int v17 = TAATMorphSubtableMorx::FetchClass((TAATMorphSubtableMorx *)v10, v19);
                    uint64_t v18 = v37;
                    continue;
                  }
                }
                uint64_t v18 = v37;
                uint64_t v22 = v437;
                int v20 = v443;
LABEL_35:
                *((void *)&v489[0] + 1) = v24;
                uint64_t v39 = v16 - 1;
                if (v16 <= 1)
                {
                  unsigned int v17 = 0;
                  uint64_t v16 = 0;
                  if (v39) {
                    break;
                  }
                  goto LABEL_16;
                }
                *(void *)&__b[0] = v23;
                v15 += *(int *)(v10 + 12);
                uint64_t v37 = v18;
                --v16;
                goto LABEL_63;
              }
            }
          }
          break;
        }
LABEL_510:
        *(void *)&__b[0] = v23;
        goto LABEL_512;
      case 2:
        if ((unint64_t)(v11 + 40) > *(void *)(v10 + 112)
          || !TAATMorphSubtableMorx::InitLigatureState(v10, __b))
        {
          return 6;
        }
        if (!TAATMorphSubtableMorx::FetchInitialClass((TAATMorphSubtableMorx *)v10, v9, v8, v6, (TRunGlue **)&v457[1], v457, &v456))return v455; {
        v451 = v9;
        }
        int v103 = 0;
        unsigned int v104 = 0;
        uint64_t v105 = 0;
        uint64_t v106 = v457[2];
        uint64_t v107 = v457[0];
        unsigned int v108 = (unsigned __int16)v456;
        uint64_t v109 = HIWORD(v456);
        uint64_t v383 = v457[1];
        uint64_t v110 = *(void *)(v457[1] + 176) + 2 * *(void *)(v457[1] + 160);
        int v111 = *(unsigned __int16 *)(v110 + 2 * v457[2]);
        memset(v469, 170, sizeof(v469));
        v468 = 0;
        int64x2_t v467 = 0uLL;
        v470 = v469;
        uint64_t v112 = 0xFFFFLL;
        uint64_t v415 = v110;
LABEL_136:
        uint64_t v113 = *(void *)&__b[129];
        uint64_t v114 = *((void *)&__b[128] + 1);
        uint64_t v115 = *((void *)&__b[129] + 1);
        int v116 = __b[128];
        while (2)
        {
          if (v107 && v111 == 0xFFFF) {
            goto LABEL_202;
          }
          uint64_t v117 = (unsigned int *)(v113 + 2 * (v114 * (unsigned __int16)v109 + v108));
          CFRange v119 = *(unsigned int **)(v10 + 104);
          unint64_t v118 = *(void *)(v10 + 112);
          if (v119 > v117 || (unint64_t)v117 + 2 > v118) {
            goto LABEL_505;
          }
          if (v105 == (unsigned __int16 *)v117)
          {
            uint64_t v117 = (unsigned int *)v105;
            goto LABEL_150;
          }
          unsigned int v121 = bswap32(*(unsigned __int16 *)v117) >> 16;
          int v103 = (unsigned int *)(v115 + 6 * v121);
          if (v119 <= v103 && (unint64_t)v103 + 6 <= v118)
          {
            uint64_t v112 = v109;
            unsigned int v104 = bswap32(*(unsigned __int16 *)(v115 + 6 * v121 + 2)) >> 16;
            uint64_t v109 = bswap32(*(unsigned __int16 *)v103) >> 16;
LABEL_150:
            __int16 v123 = v104;
            if ((unsigned __int16)v104 < 0x2000u) {
              goto LABEL_201;
            }
            if ((v104 & 0x8000) != 0)
            {
              LODWORD(__b[128]) = v116 + 1;
              if (v116 > 126)
              {
                int v116 = 0;
                LODWORD(__b[128]) = 0;
              }
              else
              {
                int v124 = DWORD1(__b[128]);
                if (v116 + 1 > SDWORD1(__b[128])) {
                  int v124 = v116 + 1;
                }
                DWORD1(__b[128]) = v124;
                ++v116;
              }
              unsigned int v125 = (uint64_t *)&__b[v116];
              *unsigned int v125 = v383;
              v125[1] = v106;
            }
            if ((v104 & 0x2000) != 0)
            {
              __int16 v412 = v104;
              if (v116 < 0) {
                goto LABEL_505;
              }
              uint64_t v385 = v115;
              uint64_t v388 = v114;
              uint64_t v391 = v113;
              v394 = v117;
              int v397 = v111;
              unsigned int v400 = v112;
              uint64_t v403 = v107;
              uint64_t v405 = v109;
              unsigned int v422 = v104;
              v407 = v103;
              uint64_t v409 = v106;
              unsigned int v126 = bswap32(*((unsigned __int16 *)v103 + 2)) >> 16;
              memset(v489, 170, sizeof(v489));
              unsigned int v127 = 0;
              uint64_t v128 = (uint64_t)v119 + bswap32(v119[7]) + 12;
              unsigned int v129 = v119[9];
              uint64_t v130 = (uint64_t)v119 + bswap32(v119[8]) + 12;
              uint64_t v131 = -1;
              uint64_t v466 = -1;
              uint64_t v428 = (uint64_t)v119 + bswap32(v129) + 12;
              __int16 v465 = -1;
              unint64_t v132 = v128 + 4 * v126;
              *(void *)&long long v133 = 0xAAAAAAAAAAAAAAAALL;
              *((void *)&v133 + 1) = 0xAAAAAAAAAAAAAAAALL;
              long long v486 = v133;
              long long v487 = v133;
              long long v484 = v133;
              long long v485 = v133;
              long long v482 = v133;
              long long v483 = v133;
              long long v480 = v133;
              long long v481 = v133;
              long long v478 = v133;
              long long v479 = v133;
              long long v476 = v133;
              long long v477 = v133;
              long long v474 = v133;
              long long v475 = v133;
              long long v473 = v133;
              __src = 0;
              int64x2_t v472 = 0uLL;
              v488 = &v473;
              v460 = (void **)v10;
              v461 = v451;
              p_src = &__src;
              v463 = &v466;
              v464 = &v465;
              unsigned int v134 = (TRunGlue *)((char *)v489 + 8);
              uint64_t v135 = 1;
              int v136 = DWORD1(__b[128]);
              do
              {
                v439 = (TRunGlue *)v135;
                v445 = (TRunGlue *)v131;
                v433 = v134;
                unint64_t v137 = *(void *)(v10 + 104);
                unint64_t v138 = *(void *)(v10 + 112);
                if (v137 > v132 || v132 + 4 > v138) {
                  goto LABEL_504;
                }
                v132 += 4;
                while (1)
                {
                  unsigned int v140 = bswap32(*(_DWORD *)(v132 - 4));
                  unsigned int v141 = &__b[v116];
                  uint64_t v142 = *v141;
                  uint64_t v143 = v141[1];
                  uint64_t v144 = (unsigned __int16 *)(v130
                                            + 2
                                            * (*(unsigned __int16 *)(*(void *)(*v141 + 176)
                                                                   + 2 * *(void *)(*v141 + 160)
                                                                   + 2 * v143)
                                             + ((int)(4 * v140) >> 2)));
                  if (v137 > (unint64_t)v144 || (unint64_t)(v144 + 1) > v138) {
                    goto LABEL_504;
                  }
                  v127 += bswap32(*v144) >> 16;
                  if (v140 >> 30) {
                    break;
                  }
                  uint64_t v459 = v143;
                  std::vector<long,TInlineBufferAllocator<long,30ul>>::insert((uint64_t)&__src, (char *)__src, &v459);
                  unsigned int v455 = 1;
                  if (v116 >= 1) {
                    --v116;
                  }
                  else {
                    int v116 = v136;
                  }
                  unint64_t v137 = *(void *)(v10 + 104);
                  if (v137 <= v132)
                  {
                    unint64_t v138 = *(void *)(v10 + 112);
                    v132 += 4;
                    if (v132 <= v138) {
                      continue;
                    }
                  }
                  goto LABEL_504;
                }
                BOOL v146 = (unsigned __int16 *)(v428 + 2 * v127);
                if (v137 > (unint64_t)v146 || (unint64_t)(v146 + 1) > v138) {
                  goto LABEL_504;
                }
                if (v466 != -1)
                {
                  TAATMorphSubtableMorx::DoLigatureAction<TRunGlue::TGlyphInVector>(TRunGlue&,unsigned short,TAATMorphSubtableMorx::MorxLigatureState *,MorphActionResultCode &)::{lambda(void)#1}::operator()((uint64_t)&v460);
                  v472.i64[0] = (uint64_t)__src;
                }
                uint64_t v466 = v143;
                __int16 v465 = bswap32(*v146) >> 16;
                if (v445 == (TRunGlue *)127) {
                  goto LABEL_504;
                }
                uint64_t v131 = (uint64_t)v445 + 1;
                unsigned __int8 v148 = &v489[(void)((void)v445 + 1)];
                *unsigned __int8 v148 = v142;
                v148[1] = v143;
                unsigned int v455 = 1;
                if (v116 >= 1) {
                  --v116;
                }
                else {
                  int v116 = v136;
                }
                uint64_t v150 = v433;
                uint64_t v149 = (uint64_t)v439;
                uint64_t v135 = (uint64_t)v439 + 1;
                unsigned int v134 = (TRunGlue *)((char *)v433 + 16);
              }
              while ((v140 & 0x80000000) == 0);
              LODWORD(__b[128]) = v116;
              TAATMorphSubtableMorx::DoLigatureAction<TRunGlue::TGlyphInVector>(TRunGlue&,unsigned short,TAATMorphSubtableMorx::MorxLigatureState *,MorphActionResultCode &)::{lambda(void)#1}::operator()((uint64_t)&v460);
              if ((int)v445 < -1)
              {
                int v103 = v407;
                uint64_t v106 = v409;
                uint64_t v109 = v405;
                unsigned int v104 = v422;
              }
              else
              {
                int v103 = v407;
                uint64_t v106 = v409;
                uint64_t v109 = v405;
                unsigned int v104 = v422;
                do
                {
                  if (v116 > 126)
                  {
                    int v116 = 0;
                  }
                  else
                  {
                    int v151 = DWORD1(__b[128]);
                    if (v116 + 1 > SDWORD1(__b[128])) {
                      int v151 = v116 + 1;
                    }
                    DWORD1(__b[128]) = v151;
                    ++v116;
                  }
                  uint64_t v152 = *(void *)v150;
                  v153 = &__b[v116];
                  void *v153 = *((void *)v150 - 1);
                  v153[1] = v152;
                  uint64_t v150 = (TRunGlue *)((char *)v150 - 16);
                  BOOL v28 = v149-- <= 1;
                }
                while (!v28);
                LODWORD(__b[128]) = v116;
              }
              uint64_t v117 = v394;
              v460 = &__src;
              std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](&v460);
              uint64_t v110 = v415;
              uint64_t v107 = v403;
              uint64_t v112 = v400;
              int v111 = v397;
              uint64_t v114 = v388;
              uint64_t v113 = v391;
              uint64_t v115 = v385;
              __int16 v123 = v412;
            }
            if ((v123 & 0x4000) == 0) {
              goto LABEL_201;
            }
            v155 = (_WORD *)v467.i64[1];
            v156 = (unsigned __int16 *)v467.i64[0];
            if (v467.i64[0] != v467.i64[1])
            {
              while (*v156 != v111 || v156[1] != (unsigned __int16)v112 || v156[2] != (unsigned __int16)v109)
              {
                v156 += 3;
                if (v156 == (unsigned __int16 *)v467.i64[1])
                {
                  v156 = (unsigned __int16 *)v467.i64[1];
                  break;
                }
              }
            }
            if (v156 == (unsigned __int16 *)v467.i64[1])
            {
              unsigned int v423 = v104;
              if (v467.i64[1] >= (unint64_t)v468)
              {
                unint64_t v160 = 0xAAAAAAAAAAAAAAABLL * ((v467.i64[1] - v467.i64[0]) >> 1);
                unint64_t v161 = v160 + 1;
                if (v160 + 1 > 0x2AAAAAAAAAAAAAAALL) {
                  goto LABEL_532;
                }
                uint64_t v162 = v106;
                uint64_t v157 = v107;
                if (0x5555555555555556 * ((uint64_t)&v468[-v467.i64[0]] >> 1) > v161) {
                  unint64_t v161 = 0x5555555555555556 * ((uint64_t)&v468[-v467.i64[0]] >> 1);
                }
                if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v468[-v467.i64[0]] >> 1) >= 0x1555555555555555) {
                  unint64_t v163 = 0x2AAAAAAAAAAAAAAALL;
                }
                else {
                  unint64_t v163 = v161;
                }
                *(void *)&v489[2] = v469;
                if (v163)
                {
                  __int16 v164 = v111;
                  uint64_t v165 = v112;
                  CFStringRef v166 = (char *)TInlineBufferAllocator<std::tuple<unsigned short,unsigned short,unsigned short>,4ul>::allocate((uint64_t)v469, v163);
                  LOWORD(v111) = v164;
                  uint64_t v112 = v165;
                }
                else
                {
                  CFStringRef v166 = 0;
                }
                unsigned __int8 v167 = &v166[6 * v160];
                *(_WORD *)unsigned __int8 v167 = v111;
                *((_WORD *)v167 + 1) = v112;
                *((_WORD *)v167 + 2) = v109;
                uint64_t v168 = v467.i64[1];
                uint64_t v169 = v467.i64[0];
                if (v467.i64[1] == v467.i64[0])
                {
                  uint64_t v158 = v112;
                  int64x2_t v173 = vdupq_n_s64(v467.u64[1]);
                  uint64_t v170 = &v166[6 * v160];
                }
                else
                {
                  uint64_t v170 = &v166[6 * v160];
                  do
                  {
                    int v171 = *(_DWORD *)(v168 - 6);
                    v168 -= 6;
                    __int16 v172 = *(_WORD *)(v168 + 4);
                    *(_DWORD *)(v170 - 6) = v171;
                    v170 -= 6;
                    *((_WORD *)v170 + 2) = v172;
                  }
                  while (v168 != v169);
                  uint64_t v158 = v112;
                  int64x2_t v173 = v467;
                }
                uint64_t v159 = v167 + 6;
                v467.i64[0] = (uint64_t)v170;
                v467.i64[1] = (uint64_t)(v167 + 6);
                *(int64x2_t *)((char *)v489 + 8) = v173;
                CFArrayRef v174 = v468;
                v468 = &v166[6 * v163];
                *((void *)&v489[1] + 1) = v174;
                *(void *)&v489[0] = v173.i64[0];
                std::__split_buffer<std::tuple<unsigned short,unsigned short,unsigned short>,TInlineBufferAllocator<std::tuple<unsigned short,unsigned short,unsigned short>,4ul> &>::~__split_buffer((uint64_t)v489);
                uint64_t v110 = v415;
                uint64_t v106 = v162;
              }
              else
              {
                uint64_t v157 = v107;
                *(_WORD *)v467.i64[1] = v111;
                uint64_t v158 = v112;
                v155[1] = v112;
                uint64_t v159 = v155 + 3;
                v155[2] = v109;
              }
              v467.i64[1] = (uint64_t)v159;
              uint64_t v105 = (unsigned __int16 *)v117;
              unsigned int v104 = v423;
            }
            else
            {
LABEL_201:
              uint64_t v105 = (unsigned __int16 *)v117;
LABEL_202:
              v467.i64[1] = v467.i64[0];
              uint64_t v154 = v107 - 1;
              if (v107 <= 1)
              {
                unsigned int v108 = 0;
                uint64_t v107 = 0;
                if (v154) {
                  goto LABEL_505;
                }
                continue;
              }
              uint64_t v158 = v112;
              v106 += *(int *)(v10 + 12);
              uint64_t v157 = v107 - 1;
            }
            int v175 = *(unsigned __int16 *)(v110 + 2 * v106);
            uint64_t v176 = v110;
            unsigned int v108 = TAATMorphSubtableMorx::FetchClass((TAATMorphSubtableMorx *)v10, v175);
            uint64_t v110 = v176;
            int v111 = v175;
            uint64_t v107 = v157;
            uint64_t v112 = v158;
            goto LABEL_136;
          }
          break;
        }
        break;
      case 4:
        v177 = *(SFNTLookupTable **)(v10 + 112);
        if (v11 + 14 <= (unint64_t)v177)
        {
          v178 = (const SFNTLookupTable *)(v11 + 12);
          switch(bswap32(*(unsigned __int16 *)(v11 + 12)) >> 16)
          {
            case 0u:
              goto LABEL_520;
            case 2u:
            case 4u:
            case 6u:
              goto LABEL_508;
            case 8u:
              goto LABEL_521;
            case 0xAu:
              goto LABEL_514;
            default:
              return 6;
          }
        }
        return 6;
      case 5:
        goto LABEL_128;
      default:
        return 6;
    }
    goto LABEL_505;
  }
  memset(__b, 170, sizeof(__b));
  memset(v457, 170, sizeof(v457));
  unsigned int v455 = 0;
  unsigned int v456 = -1431655766;
  switch((char)v12)
  {
    case 0:
      goto LABEL_124;
    case 1:
      if ((unint64_t)(v11 + 32) > *(void *)(v10 + 112)
        || !TAATMorphSubtableMorx::InitContextualState(v10, v9, (uint64_t *)__b))
      {
        return 6;
      }
      if (!TAATMorphSubtableMorx::FetchInitialClass((TAATMorphSubtableMorx *)v10, v9, v8, v6, (TRunGlue **)&v457[1], v457, &v456))return v455; {
      v453 = v9;
      }
      uint64_t v259 = v457[2];
      uint64_t v260 = v457[0];
      unsigned int v261 = (unsigned __int16)v456;
      uint64_t v262 = HIWORD(v456);
      v447 = (TRunGlue *)v457[1];
      int GlyphID = TRunGlue::GetGlyphID((TRunGlue *)v457[1], v457[2]);
      memset((char *)&v489[1] + 8, 170, 24);
      memset(v489, 0, 24);
      *(void *)&v489[3] = (char *)&v489[1] + 8;
      while (2)
      {
        uint64_t v265 = *((void *)&__b[1] + 1);
        v264 = *(TRunGlue **)&__b[1];
        uint64_t v23 = *(void *)&__b[0];
        v435 = *(TRunGlue **)&__b[1];
        v441 = (TRunGlue *)*((void *)&__b[0] + 1);
        while (2)
        {
          if (v260 && (GlyphID == 0xFFFF || TRunGlue::IsDeleted(v447, v259))) {
            goto LABEL_373;
          }
          v266 = (unsigned __int16 *)((char *)v264 + 2 * (void)v441 * (unsigned __int16)v262 + 2 * v261);
          unint64_t v267 = *(void *)(v10 + 104);
          unint64_t v268 = *(void *)(v10 + 112);
          if (v267 > (unint64_t)v266 || (unint64_t)(v266 + 1) > v268) {
            goto LABEL_510;
          }
          uint64_t v270 = bswap32(*v266) >> 16;
          v271 = (unsigned __int16 *)(v265 + 8 * v270);
          if (v267 > (unint64_t)v271 || (unint64_t)(v271 + 4) > v268) {
            goto LABEL_510;
          }
          unsigned int v273 = *v271;
          v274 = (unsigned __int16 *)(v265 + 8 * v270);
          unsigned int v275 = v274[1];
          unsigned int v276 = v274[2];
          unsigned int v277 = v274[3];
          if (v276 != 0xFFFF
            && !TAATMorphSubtableMorx::DoContextualSubstitution(v10, (uint64_t)v453, __rev16(v276), v453, v23, &v455))
          {
            goto LABEL_510;
          }
          if (v277 != 0xFFFF
            && !TAATMorphSubtableMorx::DoContextualSubstitution(v10, (uint64_t)v453, __rev16(v277), v447, v259, &v455))
          {
            goto LABEL_510;
          }
          uint64_t v278 = bswap32(v273) >> 16;
          int v279 = (int)bswap32(v275) >> 16;
          if (v279 < 0) {
            uint64_t v23 = v259;
          }
          if ((v279 & 0x4000) == 0) {
            goto LABEL_372;
          }
          v281 = (_WORD *)*((void *)&v489[0] + 1);
          v282 = *(unsigned __int16 **)&v489[0];
          if (*(void *)&v489[0] != *((void *)&v489[0] + 1))
          {
            while (*v282 != GlyphID || v282[1] != (unsigned __int16)v262 || v282[2] != v278)
            {
              v282 += 3;
              if (v282 == *((unsigned __int16 **)&v489[0] + 1))
              {
                v282 = (unsigned __int16 *)*((void *)&v489[0] + 1);
                break;
              }
            }
          }
          if (v282 == *((unsigned __int16 **)&v489[0] + 1))
          {
            *(void *)&__b[0] = v23;
            if (*((void *)&v489[0] + 1) >= *(void *)&v489[1])
            {
              unint64_t v284 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v489[0] + 1) - *(void *)&v489[0]) >> 1);
              unint64_t v285 = v284 + 1;
              if (v284 + 1 > 0x2AAAAAAAAAAAAAAALL) {
                goto LABEL_532;
              }
              if (0x5555555555555556 * ((uint64_t)(*(void *)&v489[1] - *(void *)&v489[0]) >> 1) > v285) {
                unint64_t v285 = 0x5555555555555556 * ((uint64_t)(*(void *)&v489[1] - *(void *)&v489[0]) >> 1);
              }
              if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&v489[1] - *(void *)&v489[0]) >> 1) >= 0x1555555555555555) {
                unint64_t v286 = 0x2AAAAAAAAAAAAAAALL;
              }
              else {
                unint64_t v286 = v285;
              }
              *((void *)&v473 + 1) = (char *)&v489[1] + 8;
              if (v286) {
                v287 = (char *)TInlineBufferAllocator<std::tuple<unsigned short,unsigned short,unsigned short>,4ul>::allocate((uint64_t)&v489[1] + 8, v286);
              }
              else {
                v287 = 0;
              }
              v288 = &v287[6 * v284];
              *(_WORD *)v288 = GlyphID;
              *((_WORD *)v288 + 1) = v262;
              *((_WORD *)v288 + 2) = v278;
              uint64_t v289 = *((void *)&v489[0] + 1);
              uint64_t v290 = *(void *)&v489[0];
              if (*((void *)&v489[0] + 1) == *(void *)&v489[0])
              {
                int64x2_t v294 = vdupq_n_s64(*((unint64_t *)&v489[0] + 1));
                v291 = &v287[6 * v284];
              }
              else
              {
                v291 = &v287[6 * v284];
                do
                {
                  int v292 = *(_DWORD *)(v289 - 6);
                  v289 -= 6;
                  __int16 v293 = *(_WORD *)(v289 + 4);
                  *(_DWORD *)(v291 - 6) = v292;
                  v291 -= 6;
                  *((_WORD *)v291 + 2) = v293;
                }
                while (v289 != v290);
                int64x2_t v294 = (int64x2_t)v489[0];
              }
              v283 = v288 + 6;
              *(void *)&v489[0] = v291;
              *((void *)&v489[0] + 1) = v288 + 6;
              int64x2_t v472 = v294;
              uint64_t v295 = *(void *)&v489[1];
              *(void *)&v489[1] = &v287[6 * v286];
              *(void *)&long long v473 = v295;
              __src = (void *)v294.i64[0];
              std::__split_buffer<std::tuple<unsigned short,unsigned short,unsigned short>,TInlineBufferAllocator<std::tuple<unsigned short,unsigned short,unsigned short>,4ul> &>::~__split_buffer((uint64_t)&__src);
            }
            else
            {
              **((_WORD **)&v489[0] + 1) = GlyphID;
              v281[1] = v262;
              v283 = v281 + 3;
              v281[2] = v278;
            }
            *((void *)&v489[0] + 1) = v283;
          }
          else
          {
LABEL_372:
            uint64_t v262 = v278;
            v264 = v435;
LABEL_373:
            *((void *)&v489[0] + 1) = *(void *)&v489[0];
            uint64_t v280 = v260 - 1;
            if (v260 <= 1)
            {
              unsigned int v261 = 0;
              uint64_t v260 = 0;
              if (v280) {
                goto LABEL_510;
              }
              continue;
            }
            *(void *)&__b[0] = v23;
            v259 += *(int *)(v10 + 12);
            uint64_t v278 = v262;
            --v260;
          }
          break;
        }
        int GlyphID = TRunGlue::GetGlyphID(v447, v259);
        unsigned int v261 = TAATMorphSubtableMorx::FetchClass((TAATMorphSubtableMorx *)v10, GlyphID);
        uint64_t v262 = v278;
        continue;
      }
    case 2:
      if ((unint64_t)(v11 + 40) > *(void *)(v10 + 112)
        || !TAATMorphSubtableMorx::InitLigatureState(v10, __b))
      {
        return 6;
      }
      if (!TAATMorphSubtableMorx::FetchInitialClass((TAATMorphSubtableMorx *)v10, v9, v8, v6, (TRunGlue **)&v457[1], v457, &v456))return v455; {
      v296 = (TRunGlue *)v457[1];
      }
      uint64_t v410 = v457[0];
      uint64_t v414 = v457[2];
      unsigned int v297 = (unsigned __int16)v456;
      uint64_t v298 = HIWORD(v456);
      uint64_t v299 = TRunGlue::GetGlyphID((TRunGlue *)v457[1], v457[2]);
      v425 = 0;
      unsigned int v300 = 0;
      v301 = 0;
      memset(v469, 170, sizeof(v469));
      v468 = 0;
      int64x2_t v467 = 0uLL;
      v387 = v296;
      v470 = v469;
      int v421 = 0xFFFF;
      v454 = v9;
LABEL_407:
      uint64_t v417 = *((void *)&__b[128] + 1);
      uint64_t v302 = *((void *)&__b[129] + 1);
      uint64_t v419 = *(void *)&__b[129];
      int v303 = __b[128];
      uint64_t v304 = v410;
      uint64_t v408 = *((void *)&__b[129] + 1);
      while (2)
      {
        if (v304)
        {
          if (v299 == 0xFFFF) {
            goto LABEL_474;
          }
          v305 = v296;
          v306 = v296;
          uint64_t v307 = v299;
          uint64_t v308 = v304;
          BOOL v309 = TRunGlue::IsDeleted(v305, v414);
          uint64_t v302 = v408;
          uint64_t v299 = v307;
          v296 = v306;
          uint64_t v304 = v308;
          if (v309) {
            goto LABEL_474;
          }
        }
        v310 = (unsigned int *)(v419 + 2 * (v417 * (unsigned __int16)v298 + v297));
        v312 = *(unsigned int **)(v10 + 104);
        unint64_t v311 = *(void *)(v10 + 112);
        if (v312 > v310 || (unint64_t)v310 + 2 > v311) {
          break;
        }
        if (v301 == (unsigned __int16 *)v310)
        {
          v310 = (unsigned int *)v301;
          int v317 = v421;
          goto LABEL_422;
        }
        unsigned int v314 = bswap32(*(unsigned __int16 *)v310) >> 16;
        v315 = (unsigned int *)(v302 + 6 * v314);
        v425 = v315;
        if (v312 <= v315 && (unint64_t)v315 + 6 <= v311)
        {
          int v317 = v298;
          unsigned int v300 = bswap32(*(unsigned __int16 *)(v302 + 6 * v314 + 2)) >> 16;
          uint64_t v298 = bswap32(*(unsigned __int16 *)v315) >> 16;
LABEL_422:
          __int16 v318 = v300;
          int v421 = v317;
          if ((unsigned __int16)v300 < 0x2000u) {
            goto LABEL_473;
          }
          if ((v300 & 0x8000) != 0)
          {
            LODWORD(__b[128]) = v303 + 1;
            if (v303 > 126)
            {
              int v303 = 0;
              LODWORD(__b[128]) = 0;
            }
            else
            {
              int v319 = DWORD1(__b[128]);
              if (v303 + 1 > SDWORD1(__b[128])) {
                int v319 = v303 + 1;
              }
              DWORD1(__b[128]) = v319;
              ++v303;
            }
            v320 = (TRunGlue **)&__b[v303];
            *v320 = v296;
            v320[1] = (TRunGlue *)v414;
          }
          if ((v300 & 0x2000) != 0)
          {
            __int16 v399 = v300;
            unsigned int v402 = v300;
            if (v303 < 0) {
              break;
            }
            v390 = v310;
            unsigned int v393 = v299;
            uint64_t v411 = v304;
            uint64_t v396 = v298;
            unsigned int v321 = bswap32(*((unsigned __int16 *)v425 + 2)) >> 16;
            memset(v489, 170, sizeof(v489));
            unsigned int v322 = 0;
            uint64_t v323 = (uint64_t)v312 + bswap32(v312[7]) + 12;
            unsigned int v324 = v312[9];
            uint64_t v325 = (uint64_t)v312 + bswap32(v312[8]) + 12;
            uint64_t v326 = -1;
            uint64_t v466 = -1;
            uint64_t v430 = (uint64_t)v312 + bswap32(v324) + 12;
            __int16 v465 = -1;
            unint64_t v327 = v323 + 4 * v321;
            *(void *)&long long v328 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v328 + 1) = 0xAAAAAAAAAAAAAAAALL;
            long long v486 = v328;
            long long v487 = v328;
            long long v484 = v328;
            long long v485 = v328;
            long long v482 = v328;
            long long v483 = v328;
            long long v480 = v328;
            long long v481 = v328;
            long long v478 = v328;
            long long v479 = v328;
            long long v476 = v328;
            long long v477 = v328;
            long long v474 = v328;
            long long v475 = v328;
            long long v473 = v328;
            __src = 0;
            int64x2_t v472 = 0uLL;
            v488 = &v473;
            v460 = (void **)v10;
            v461 = v9;
            p_src = &__src;
            v463 = &v466;
            v464 = &v465;
            v329 = (TRunGlue *)((char *)v489 + 8);
            uint64_t v330 = 1;
            int v331 = DWORD1(__b[128]);
            do
            {
              v442 = (TRunGlue *)v330;
              v448 = (TRunGlue *)v326;
              v436 = v329;
              if (*(void *)(v10 + 104) > v327 || v327 + 4 > *(void *)(v10 + 112)) {
                goto LABEL_504;
              }
              v327 += 4;
              while (1)
              {
                unsigned int v333 = bswap32(*(_DWORD *)(v327 - 4));
                v334 = &__b[v303];
                v336 = *(TRunGlue **)v334;
                uint64_t v335 = *((void *)v334 + 1);
                v337 = (unsigned __int16 *)(v325
                                          + 2
                                          * (int)(TRunGlue::GetGlyphID(*(TRunGlue **)v334, v335) + ((int)(4 * v333) >> 2)));
                unint64_t v338 = *(void *)(v10 + 104);
                unint64_t v339 = *(void *)(v10 + 112);
                if (v338 > (unint64_t)v337 || (unint64_t)(v337 + 1) > v339) {
                  goto LABEL_504;
                }
                v322 += bswap32(*v337) >> 16;
                if (v333 >> 30) {
                  break;
                }
                uint64_t v459 = v335;
                std::vector<long,TInlineBufferAllocator<long,30ul>>::insert((uint64_t)&__src, (char *)__src, &v459);
                unsigned int v455 = 1;
                if (v303 >= 1) {
                  --v303;
                }
                else {
                  int v303 = v331;
                }
                if (*(void *)(v10 + 104) <= v327)
                {
                  v327 += 4;
                  if (v327 <= *(void *)(v10 + 112)) {
                    continue;
                  }
                }
                goto LABEL_504;
              }
              v341 = (unsigned __int16 *)(v430 + 2 * v322);
              if (v338 > (unint64_t)v341 || (unint64_t)(v341 + 1) > v339) {
                goto LABEL_504;
              }
              if (v466 != -1)
              {
                TAATMorphSubtableMorx::DoLigatureAction<TRunGlue::TGlyphInVector>(TRunGlue&,unsigned short,TAATMorphSubtableMorx::MorxLigatureState *,MorphActionResultCode &)::{lambda(void)#1}::operator()((uint64_t)&v460);
                v472.i64[0] = (uint64_t)__src;
              }
              uint64_t v466 = v335;
              __int16 v465 = bswap32(*v341) >> 16;
              if (v448 == (TRunGlue *)127) {
                goto LABEL_504;
              }
              uint64_t v326 = (uint64_t)v448 + 1;
              v343 = (TRunGlue **)&v489[(void)((void)v448 + 1)];
              *v343 = v336;
              v343[1] = (TRunGlue *)v335;
              unsigned int v455 = 1;
              if (v303 >= 1) {
                --v303;
              }
              else {
                int v303 = v331;
              }
              v345 = v436;
              uint64_t v344 = (uint64_t)v442;
              uint64_t v330 = (uint64_t)v442 + 1;
              v329 = (TRunGlue *)((char *)v436 + 16);
            }
            while ((v333 & 0x80000000) == 0);
            LODWORD(__b[128]) = v303;
            TAATMorphSubtableMorx::DoLigatureAction<TRunGlue::TGlyphInVector>(TRunGlue&,unsigned short,TAATMorphSubtableMorx::MorxLigatureState *,MorphActionResultCode &)::{lambda(void)#1}::operator()((uint64_t)&v460);
            if ((int)v448 < -1)
            {
              v296 = v387;
              uint64_t v298 = v396;
              unsigned int v300 = v402;
              LOWORD(v317) = v421;
            }
            else
            {
              v296 = v387;
              uint64_t v298 = v396;
              unsigned int v300 = v402;
              LOWORD(v317) = v421;
              do
              {
                if (v303 > 126)
                {
                  int v303 = 0;
                }
                else
                {
                  int v346 = DWORD1(__b[128]);
                  if (v303 + 1 > SDWORD1(__b[128])) {
                    int v346 = v303 + 1;
                  }
                  DWORD1(__b[128]) = v346;
                  ++v303;
                }
                uint64_t v347 = *(void *)v345;
                v348 = &__b[v303];
                void *v348 = *((void *)v345 - 1);
                v348[1] = v347;
                v345 = (TRunGlue *)((char *)v345 - 16);
                BOOL v28 = v344-- <= 1;
              }
              while (!v28);
              LODWORD(__b[128]) = v303;
            }
            v310 = v390;
            v460 = &__src;
            std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](&v460);
            uint64_t v9 = v454;
            uint64_t v302 = v408;
            uint64_t v304 = v411;
            uint64_t v299 = v393;
            __int16 v318 = v399;
          }
          if ((v318 & 0x4000) == 0) {
            goto LABEL_473;
          }
          v350 = (_WORD *)v467.i64[1];
          v351 = (unsigned __int16 *)v467.i64[0];
          if (v467.i64[0] != v467.i64[1])
          {
            while (*v351 != v299 || v351[1] != (unsigned __int16)v317 || v351[2] != (unsigned __int16)v298)
            {
              v351 += 3;
              if (v351 == (unsigned __int16 *)v467.i64[1])
              {
                v351 = (unsigned __int16 *)v467.i64[1];
                break;
              }
            }
          }
          if (v351 == (unsigned __int16 *)v467.i64[1])
          {
            uint64_t v352 = v298;
            uint64_t v410 = v304;
            if (v467.i64[1] >= (unint64_t)v468)
            {
              unint64_t v354 = 0xAAAAAAAAAAAAAAABLL * ((v467.i64[1] - v467.i64[0]) >> 1);
              unint64_t v355 = v354 + 1;
              if (v354 + 1 > 0x2AAAAAAAAAAAAAAALL) {
                goto LABEL_532;
              }
              if (0x5555555555555556 * ((uint64_t)&v468[-v467.i64[0]] >> 1) > v355) {
                unint64_t v355 = 0x5555555555555556 * ((uint64_t)&v468[-v467.i64[0]] >> 1);
              }
              if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v468[-v467.i64[0]] >> 1) >= 0x1555555555555555) {
                unint64_t v356 = 0x2AAAAAAAAAAAAAAALL;
              }
              else {
                unint64_t v356 = v355;
              }
              *(void *)&v489[2] = v469;
              if (v356)
              {
                v357 = v310;
                v358 = v296;
                __int16 v359 = v299;
                v360 = (char *)TInlineBufferAllocator<std::tuple<unsigned short,unsigned short,unsigned short>,4ul>::allocate((uint64_t)v469, v356);
                LOWORD(v299) = v359;
                v296 = v358;
                v310 = v357;
              }
              else
              {
                v360 = 0;
              }
              v362 = &v360[6 * v354];
              *(_WORD *)v362 = v299;
              *((_WORD *)v362 + 1) = v317;
              *((_WORD *)v362 + 2) = v352;
              uint64_t v363 = v467.i64[1];
              uint64_t v364 = v467.i64[0];
              if (v467.i64[1] == v467.i64[0])
              {
                int64x2_t v368 = vdupq_n_s64(v467.u64[1]);
                v365 = &v360[6 * v354];
              }
              else
              {
                v365 = &v360[6 * v354];
                do
                {
                  int v366 = *(_DWORD *)(v363 - 6);
                  v363 -= 6;
                  __int16 v367 = *(_WORD *)(v363 + 4);
                  *(_DWORD *)(v365 - 6) = v366;
                  v365 -= 6;
                  *((_WORD *)v365 + 2) = v367;
                }
                while (v363 != v364);
                int64x2_t v368 = v467;
              }
              v353 = v362 + 6;
              v467.i64[0] = (uint64_t)v365;
              v467.i64[1] = (uint64_t)(v362 + 6);
              *(int64x2_t *)((char *)v489 + 8) = v368;
              v369 = v468;
              v468 = &v360[6 * v356];
              *((void *)&v489[1] + 1) = v369;
              *(void *)&v489[0] = v368.i64[0];
              std::__split_buffer<std::tuple<unsigned short,unsigned short,unsigned short>,TInlineBufferAllocator<std::tuple<unsigned short,unsigned short,unsigned short>,4ul> &>::~__split_buffer((uint64_t)v489);
            }
            else
            {
              *(_WORD *)v467.i64[1] = v299;
              v350[1] = v317;
              v353 = v350 + 3;
              v350[2] = v352;
            }
            v467.i64[1] = (uint64_t)v353;
            v301 = (unsigned __int16 *)v310;
            uint64_t v298 = v352;
            uint64_t v361 = TRunGlue::GetGlyphID(v296, v414);
          }
          else
          {
LABEL_473:
            v301 = (unsigned __int16 *)v310;
LABEL_474:
            v467.i64[1] = v467.i64[0];
            uint64_t v349 = v304 - 1;
            if (v304 <= 1)
            {
              unsigned int v297 = 0;
              uint64_t v304 = 0;
              if (v349) {
                break;
              }
              continue;
            }
            uint64_t v410 = v304 - 1;
            v414 += *(int *)(v10 + 12);
            uint64_t v361 = TRunGlue::GetGlyphID(v296, v414);
          }
          uint64_t v370 = v361;
          unsigned int v371 = TAATMorphSubtableMorx::FetchClass((TAATMorphSubtableMorx *)v10, v361);
          uint64_t v299 = v370;
          unsigned int v297 = v371;
          goto LABEL_407;
        }
        break;
      }
LABEL_505:
      v372 = &v467;
LABEL_513:
      std::vector<std::tuple<unsigned short,unsigned short,unsigned short>,TInlineBufferAllocator<std::tuple<unsigned short,unsigned short,unsigned short>,4ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)v372);
      return v455;
    case 4:
      v177 = *(SFNTLookupTable **)(v10 + 112);
      if (v11 + 14 <= (unint64_t)v177)
      {
        v178 = (const SFNTLookupTable *)(v11 + 12);
        switch(bswap32(*(unsigned __int16 *)(v11 + 12)) >> 16)
        {
          case 0u:
            goto LABEL_520;
          case 2u:
          case 4u:
          case 6u:
            goto LABEL_508;
          case 8u:
LABEL_521:
            unint64_t v378 = v11 + 18;
            if (v11 + 18 > (unint64_t)v177) {
              return 6;
            }
            uint64_t v379 = bswap32(*(unsigned __int16 *)(v11 + 16)) >> 16;
            unint64_t v380 = v378 + 2 * v379;
            unint64_t v381 = v11 + 20 <= (unint64_t)v177 ? ((unint64_t)v177 - v378) >> 1 : 0;
            BOOL v382 = v380 <= (unint64_t)v177 && v380 >= v378;
            if (!v382 && v381 != v379) {
              return 6;
            }
            goto LABEL_520;
          case 0xAu:
            goto LABEL_514;
          default:
            return 6;
        }
      }
      return 6;
    case 5:
      goto LABEL_128;
    default:
      return 6;
  }
}

uint64_t TAATMorphSubtableMorx::FetchClass(TAATMorphSubtableMorx *this, int a2)
{
  if (a2 == 0xFFFF) {
    return 2;
  }
  uint64_t v10 = v2;
  uint64_t v11 = v3;
  unint64_t v9 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v4 = (uint64_t (*)(void *))*((void *)this + 3);
  uint64_t v5 = *((void *)this + 4);
  uint64_t v6 = (void *)((char *)this + (v5 >> 1) + 24);
  if (v5) {
    uint64_t v4 = *(uint64_t (**)(void *))(*v6 + v4);
  }
  uint64_t v8 = (unsigned __int16 *)v4(v6);
  if (v8) {
    return bswap32(*v8) >> 16;
  }
  else {
    return 1;
  }
}

unsigned __int16 *TAATLookupTable::LookupSingleTable(TAATLookupTable *this, unsigned int a2, unint64_t *a3)
{
  if (a2 == 0xFFFF) {
    return 0;
  }
  uint64_t v3 = (unsigned __int16 *)*((void *)this + 2);
  uint64_t v4 = v3 + 1;
  uint64_t v5 = bswap32(v3[1]) >> 16;
  if (v5 < 4) {
    return 0;
  }
  unsigned int v6 = v3[2];
  if (!v3[2]) {
    return 0;
  }
  uint64_t v7 = (char *)(v3 + 6);
  uint64_t v8 = &v7[__rev16(v6) * v5];
  unint64_t v9 = &v8[-v5];
  BOOL v10 = (unint64_t)v8 <= *((void *)this + 5) && v9 >= (char *)v4;
  if (!v10 || v8 < v9) {
    return 0;
  }
  while (1)
  {
    unsigned int v12 = bswap32(*(unsigned __int16 *)v7) >> 16;
    if (v12 >= a2) {
      break;
    }
    v7 += v5;
    if (v8 <= v7) {
      return 0;
    }
  }
  if (v12 != a2) {
    return 0;
  }
  *a3 = v5 - 2;
  return (unsigned __int16 *)(v7 + 2);
}

uint64_t TAATMorphSubtableMorx::InitLigatureState(uint64_t a1, void *a2)
{
  a2[256] = -1;
  uint64_t v4 = *(unsigned int **)(a1 + 104);
  uint64_t v3 = *(SFNTLookupTable **)(a1 + 112);
  uint64_t v5 = v4 + 3;
  a2[257] = bswap32(v4[3]);
  unsigned int v6 = (const SFNTLookupTable *)((char *)v4 + bswap32(v4[4]) + 12);
  if (&v6->fsHeader > (SFNTLookupFormatSpecificHeader *)v3) {
    return 0;
  }
  uint64_t v7 = 0;
  switch(bswap32(v6->format) >> 16)
  {
    case 0u:
      goto LABEL_23;
    case 2u:
    case 4u:
    case 6u:
      if (v6->fsHeader.trimmedArray.valueArray > (SFNTLookupValue *)v3) {
        return 0;
      }
      id values = (UInt8 *)&v6->fsHeader.vector + 10;
      unsigned int v9 = bswap32(v6->fsHeader.theArray.lookupValues[0]) >> 16;
      unsigned int nUnits = v6->fsHeader.segment.binSearch.nUnits;
      goto LABEL_19;
    case 8u:
      p_searchRange = &v6->fsHeader.segment.binSearch.searchRange;
      if (v6->fsHeader.trimmedArray.valueArray > (SFNTLookupValue *)v3) {
        return 0;
      }
      uint64_t v12 = bswap32(v6->fsHeader.segment.binSearch.nUnits) >> 16;
      unint64_t v13 = (unint64_t)&p_searchRange[v12];
      unint64_t v14 = v6->fsHeader.vector.values <= (UInt8 *)v3
          ? (unint64_t)((char *)v3 - (char *)p_searchRange) >> 1
          : 0;
      BOOL v15 = v13 <= (unint64_t)v3 && v13 >= (unint64_t)p_searchRange;
      if (!v15 && v14 != v12) {
        return 0;
      }
      goto LABEL_23;
    case 0xAu:
      id values = v6->fsHeader.vector.values;
      if (v6->fsHeader.vector.values > (UInt8 *)v3) {
        return 0;
      }
      unsigned int v9 = bswap32(v6->fsHeader.theArray.lookupValues[0]) >> 16;
      unsigned int nUnits = v6->fsHeader.segment.binSearch.searchRange;
LABEL_19:
      unint64_t v17 = (unint64_t)&values[(bswap32(nUnits) >> 16) * (unint64_t)v9];
      if (v17 < (unint64_t)values || v17 > (unint64_t)v3) {
        return 0;
      }
LABEL_23:
      TAATLookupTable::SetTable(a1 + 24, v6, v3);
      a2[258] = (char *)v5 + bswap32(v4[5]);
      a2[259] = (char *)v5 + bswap32(v4[6]);
      uint64_t v7 = 1;
      break;
    default:
      return v7;
  }
  return v7;
}

uint64_t TAATLookupTable::SetTable(uint64_t this, const SFNTLookupTable *a2, SFNTLookupTable *a3)
{
  p_fsHeader = &a2->fsHeader;
  if (&a2->fsHeader <= (SFNTLookupFormatSpecificHeader *)a3)
  {
    switch(bswap32(a2->format) >> 16)
    {
      case 0u:
        goto LABEL_23;
      case 2u:
      case 4u:
      case 6u:
        if (a2->fsHeader.trimmedArray.valueArray > (SFNTLookupValue *)a3) {
          goto LABEL_49;
        }
        id values = (UInt8 *)&a2->fsHeader.vector + 10;
        unsigned int v5 = bswap32(a2->fsHeader.theArray.lookupValues[0]) >> 16;
        unsigned int nUnits = a2->fsHeader.segment.binSearch.nUnits;
        break;
      case 8u:
        p_searchRange = &a2->fsHeader.segment.binSearch.searchRange;
        if (a2->fsHeader.trimmedArray.valueArray > (SFNTLookupValue *)a3) {
          goto LABEL_49;
        }
        uint64_t v8 = bswap32(a2->fsHeader.segment.binSearch.nUnits) >> 16;
        unint64_t v9 = (unint64_t)&p_searchRange[v8];
        unint64_t v10 = a2->fsHeader.vector.values <= (UInt8 *)a3
            ? (unint64_t)((char *)a3 - (char *)p_searchRange) >> 1
            : 0;
        BOOL v11 = v9 <= (unint64_t)a3 && v9 >= (unint64_t)p_searchRange;
        if (!v11 && v10 != v8) {
          goto LABEL_49;
        }
        goto LABEL_23;
      case 0xAu:
        id values = a2->fsHeader.vector.values;
        if (a2->fsHeader.vector.values > (UInt8 *)a3) {
          goto LABEL_49;
        }
        unsigned int v5 = bswap32(a2->fsHeader.theArray.lookupValues[0]) >> 16;
        unsigned int nUnits = a2->fsHeader.segment.binSearch.searchRange;
        break;
      default:
        goto LABEL_49;
    }
    unint64_t v13 = (unint64_t)&values[(bswap32(nUnits) >> 16) * (unint64_t)v5];
    if (v13 >= (unint64_t)values && v13 <= (unint64_t)a3)
    {
LABEL_23:
      *(void *)(this + 40) = a3;
      unsigned int v15 = bswap32(a2->format);
      *(_WORD *)(this + 48) = HIWORD(v15);
      switch(HIWORD(v15))
      {
        case 0u:
          if (&a2->fsHeader.segment.binSearch.nUnits <= (UInt16 *)a3) {
            unint64_t v16 = (unint64_t)((char *)a3 - (char *)p_fsHeader) >> 1;
          }
          else {
            unint64_t v16 = 0;
          }
          *(void *)(this + 16) = p_fsHeader;
          *(void *)(this + 24) = v16;
          unint64_t v17 = TAATLookupTable::LookupSimpleArray;
          goto LABEL_54;
        case 2u:
          *(void *)(this + 16) = a2;
          unint64_t v17 = TAATLookupTable::LookupSegmentSingle;
          goto LABEL_54;
        case 4u:
          *(void *)(this + 16) = a2;
          unint64_t v17 = TAATLookupTable::LookupSegmentArray;
          goto LABEL_54;
        case 6u:
          *(void *)(this + 16) = a2;
          unint64_t v17 = TAATLookupTable::LookupSingleTable;
          goto LABEL_54;
        case 8u:
          *(void *)(this + 16) = p_fsHeader;
          unsigned int v18 = bswap32(a2->fsHeader.theArray.lookupValues[0]) >> 16;
          *(_WORD *)(this + 24) = v18;
          if (!a2->fsHeader.segment.binSearch.nUnits)
          {
            *(_DWORD *)(this + 24) = 0xFFFF;
LABEL_51:
            unint64_t v17 = TAATLookupTable::LookupTrimmedArray;
            goto LABEL_54;
          }
          unint64_t v19 = __rev16(a2->fsHeader.segment.binSearch.nUnits);
          int v20 = &a2->fsHeader.segment.binSearch.searchRange;
          uint64_t v21 = &a2->fsHeader.segment.binSearch.searchRange + v19;
          if (v21 >= &a2->fsHeader.segment.binSearch.searchRange && v21 <= (SFNTLookupValue *)a3) {
            goto LABEL_40;
          }
          if (a2->fsHeader.vector.values <= (UInt8 *)a3 && (unint64_t)((char *)a3 - (char *)v20) >= 2)
          {
            unint64_t v19 = (unint64_t)((char *)a3 - (char *)v20) >> 1;
LABEL_40:
            unint64_t v23 = v19 + v18 - 1;
            *(_WORD *)(this + 26) = v23;
            if (v23 >> 16) {
              break;
            }
            goto LABEL_51;
          }
          break;
        case 0xAu:
          *(void *)(this + 16) = p_fsHeader;
          unsigned int v24 = p_fsHeader->theArray.lookupValues[0];
          unint64_t v25 = __rev16(v24);
          *(void *)(this + 24) = v25;
          if (!v24) {
            break;
          }
          unsigned int v26 = bswap32(a2->fsHeader.segment.binSearch.nUnits) >> 16;
          *(_WORD *)(this + 32) = v26;
          if (a2->fsHeader.segment.binSearch.searchRange)
          {
            unint64_t v27 = &a2->fsHeader.vector.values[v25
                                            * (unint64_t)__rev16(a2->fsHeader.segment.binSearch.searchRange)];
            if (a3 < (SFNTLookupTable *)v27) {
              unint64_t v27 = (UInt8 *)a3;
            }
            unint64_t v28 = v27 - a2->fsHeader.vector.values;
            if (v28 < v25) {
              break;
            }
            uint64_t v29 = v28 / v25 - 1;
            BOOL v11 = __CFADD__(v29, v26);
            unint64_t v30 = v29 + v26;
            *(_WORD *)(this + 34) = v30;
            if (v11 || v30 >> 16) {
              break;
            }
          }
          else
          {
            *(_DWORD *)(this + 32) = 0xFFFF;
          }
          unint64_t v17 = TAATLookupTable::LookupVector;
LABEL_54:
          *(void *)this = v17;
          *(void *)(this + 8) = 0;
          return this;
        default:
          break;
      }
    }
  }
LABEL_49:
  *(void *)(this + 8) = 0;
  *(void *)(this + 16) = a2;
  *(void *)this = TAATLookupTable::BadTable;
  *(_WORD *)(this + 48) = -1;
  return this;
}

uint64_t TAATMorphSubtableMorx::FetchInitialClass(TAATMorphSubtableMorx *a1, TRunGlue *a2, uint64_t a3, uint64_t a4, TRunGlue **a5, uint64_t *a6, _WORD *a7)
{
  uint64_t FirstGlyph = TAATMorphSubtable::FindFirstGlyph((uint64_t)a1, a2, a3, a4, a5, a6);
  if (FirstGlyph)
  {
    int GlyphID = TRunGlue::GetGlyphID(*a5, (uint64_t)a5[1]);
    *a7 = TAATMorphSubtableMorx::FetchClass(a1, GlyphID);
    a7[1] = 0;
  }
  return FirstGlyph;
}

uint64_t TAATMorphSubtable::FindFirstGlyph(uint64_t a1, TRunGlue *this, uint64_t a3, uint64_t a4, void *a5, uint64_t *a6)
{
  if (a4 < 1) {
    return 0;
  }
  int v11 = *(_DWORD *)(a1 + 12);
  uint64_t v12 = TRunGlue::length(this);
  if (v11 >= 1)
  {
    *a5 = this;
    a5[1] = a3;
    uint64_t v13 = v12 - a3;
    if (v12 == a3) {
      return 0;
    }
LABEL_8:
    *a6 = v13;
    return 1;
  }
  uint64_t v13 = a3 + a4 - v12 + TRunGlue::length(this);
  if (v13)
  {
    *a5 = this;
    a5[1] = v13 - 1;
    goto LABEL_8;
  }
  return 0;
}

uint64_t TAATMorphChainMorx::NextChain(TAATMorphChainMorx *this, unsigned int a2)
{
  uint64_t v2 = (unsigned int *)*((void *)this + 4);
  *((void *)this + 3) = v2;
  unint64_t v3 = *((void *)this + 1);
  unint64_t v4 = *((void *)this + 2);
  unsigned int v5 = v2 + 4;
  if (v3 > (unint64_t)(v2 + 3) || (unint64_t)v5 > v4) {
    return 0;
  }
  unint64_t v8 = (unint64_t)v2 + bswap32(v2[1]);
  *((void *)this + 4) = v8;
  if (v8 > v4) {
    return 0;
  }
  unint64_t v9 = &v2[3 * bswap32(v2[2]) + 4];
  *((void *)this + 22) = v9;
  *((void *)this + 23) = v9;
  *((void *)this + 20) = v3;
  *((void *)this + 21) = v4;
  *((void *)this + 25) = *((void *)this + 24);
  if (a2 < 3)
  {
    unint64_t v28 = v2;
  }
  else
  {
    unsigned int v10 = v2[3];
    unint64_t v11 = bswap32(v10);
    if (v10)
    {
      if (v11 <= 1) {
        int v12 = 1;
      }
      else {
        int v12 = v11;
      }
      do
      {
        *((void *)this + 22) = v9;
        uint64_t v13 = v9 + 2;
        if (v3 > (unint64_t)(v9 + 2) || (unint64_t)(v9 + 3) > v4) {
          break;
        }
        unint64_t v9 = (unsigned int *)((char *)v9 + bswap32(*v9));
        *((void *)this + 23) = v9;
        if ((unint64_t)v9 > v4) {
          break;
        }
        *((_DWORD *)this + 20) = bswap32(*v13);
        --v12;
      }
      while (v12);
    }
    if (v2 <= v9)
    {
      unsigned int v15 = &v9[v11];
      if (v15 >= v9 && (unint64_t)v15 <= v8) {
        goto LABEL_38;
      }
    }
    BOOL v16 = (unint64_t)(v9 + 1) > v8 || v2 > v9;
    unint64_t v17 = (v8 - (unint64_t)v9) >> 2;
    if (v16) {
      unint64_t v17 = 0;
    }
    if (v17 == v11)
    {
LABEL_38:
      GlyphCFIndex Count = TBaseFont::GetGlyphCount(*(TBaseFont **)(*((void *)this + 7) + 400));
      if (GlyphCount <= 0x10000) {
        unint64_t v19 = (GlyphCount + 7) >> 3;
      }
      else {
        unint64_t v19 = 0x2000;
      }
      uint64_t v20 = *((void *)this + 24);
      if (v11 > (*((void *)this + 26) - v20) >> 3)
      {
        uint64_t v21 = *((void *)this + 25) - v20;
        unsigned int v74 = (char *)this + 216;
        uint64_t v22 = TInlineBufferAllocator<unsigned char const*,48ul>::allocate((uint64_t)this + 216, v11);
        uint64_t v24 = *((void *)this + 24);
        unint64_t v23 = *((void *)this + 25);
        if (v23 == v24)
        {
          int64x2_t v27 = vdupq_n_s64(v23);
          unint64_t v25 = &v22[v21 & 0xFFFFFFFFFFFFFFF8];
        }
        else
        {
          unint64_t v25 = &v22[v21 & 0xFFFFFFFFFFFFFFF8];
          do
          {
            uint64_t v26 = *(void *)(v23 - 8);
            v23 -= 8;
            *((void *)v25 - 1) = v26;
            v25 -= 8;
          }
          while (v23 != v24);
          int64x2_t v27 = *((int64x2_t *)this + 12);
        }
        *((void *)this + 24) = v25;
        *((void *)this + 25) = &v22[v21 & 0xFFFFFFFFFFFFFFF8];
        int64x2_t v72 = v27;
        uint64_t v29 = (char *)*((void *)this + 26);
        *((void *)this + 26) = &v22[8 * v11];
        uint64_t v73 = v29;
        uint64_t v71 = v27.i64[0];
        std::__split_buffer<unsigned char const*,TInlineBufferAllocator<unsigned char const*,48ul> &>::~__split_buffer((uint64_t)&v71);
      }
      if (v10)
      {
        unint64_t v30 = v9;
        int v31 = &v9[v11];
        do
        {
          unsigned int v32 = bswap32(*v30);
          if (v32 + 1 > 1)
          {
            unsigned int v36 = (char *)v9 + v32;
            unint64_t v37 = *((void *)this + 4);
            BOOL v39 = &v36[v19] >= v36
               && (unint64_t)&v36[v19] <= v37
               && *((void *)this + 3) <= (unint64_t)v36;
            BOOL v40 = (unint64_t)(v36 + 1) <= v37;
            unint64_t v41 = v37 - (void)v36;
            if (*((void *)this + 3) <= (unint64_t)v36 && v40) {
              unint64_t v42 = v41;
            }
            else {
              unint64_t v42 = 0;
            }
            if (!v39 && v42 != v19)
            {
              *((void *)this + 25) = *((void *)this + 24);
              break;
            }
            unint64_t v44 = (char **)*((void *)this + 25);
            unint64_t v43 = *((void *)this + 26);
            if ((unint64_t)v44 >= v43)
            {
              uint64_t v51 = *((void *)this + 24);
              uint64_t v52 = ((uint64_t)v44 - v51) >> 3;
              if ((unint64_t)(v52 + 1) >> 61) {
LABEL_96:
              }
                abort();
              uint64_t v53 = v43 - v51;
              uint64_t v54 = v53 >> 2;
              if (v53 >> 2 <= (unint64_t)(v52 + 1)) {
                uint64_t v54 = v52 + 1;
              }
              if ((unint64_t)v53 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v55 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v55 = v54;
              }
              unsigned int v74 = (char *)this + 216;
              if (v55) {
                uint64_t v56 = TInlineBufferAllocator<unsigned char const*,48ul>::allocate((uint64_t)this + 216, v55);
              }
              else {
                uint64_t v56 = 0;
              }
              uint64_t v57 = &v56[8 * v52];
              double v58 = &v56[8 * v55];
              uint64_t v73 = v58;
              *(void *)uint64_t v57 = v36;
              unsigned int v35 = v57 + 8;
              v72.i64[1] = (uint64_t)(v57 + 8);
              uint64_t v62 = *((void *)this + 24);
              unint64_t v59 = *((void *)this + 25);
              if (v59 != v62)
              {
                do
                {
                  uint64_t v63 = *(void *)(v59 - 8);
                  v59 -= 8;
                  *((void *)v57 - 1) = v63;
                  v57 -= 8;
                }
                while (v59 != v62);
LABEL_79:
                int64x2_t v64 = *((int64x2_t *)this + 12);
                unsigned int v35 = (void *)v72.i64[1];
                double v58 = v73;
LABEL_81:
                *((void *)this + 24) = v57;
                *((void *)this + 25) = v35;
                int64x2_t v72 = v64;
                uint64_t v65 = (char *)*((void *)this + 26);
                *((void *)this + 26) = v58;
                uint64_t v73 = v65;
                uint64_t v71 = v64.i64[0];
                std::__split_buffer<unsigned char const*,TInlineBufferAllocator<unsigned char const*,48ul> &>::~__split_buffer((uint64_t)&v71);
                goto LABEL_82;
              }
LABEL_80:
              int64x2_t v64 = vdupq_n_s64(v59);
              goto LABEL_81;
            }
            *unint64_t v44 = v36;
            unsigned int v35 = v44 + 1;
          }
          else
          {
            unsigned int v34 = (void *)*((void *)this + 25);
            unint64_t v33 = *((void *)this + 26);
            if ((unint64_t)v34 >= v33)
            {
              uint64_t v45 = *((void *)this + 24);
              uint64_t v46 = ((uint64_t)v34 - v45) >> 3;
              if ((unint64_t)(v46 + 1) >> 61) {
                goto LABEL_96;
              }
              uint64_t v47 = v33 - v45;
              uint64_t v48 = v47 >> 2;
              if (v47 >> 2 <= (unint64_t)(v46 + 1)) {
                uint64_t v48 = v46 + 1;
              }
              if ((unint64_t)v47 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v49 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v49 = v48;
              }
              unsigned int v74 = (char *)this + 216;
              if (v49) {
                unint64_t v50 = TInlineBufferAllocator<unsigned char const*,48ul>::allocate((uint64_t)this + 216, v49);
              }
              else {
                unint64_t v50 = 0;
              }
              uint64_t v57 = &v50[8 * v46];
              double v58 = &v50[8 * v49];
              uint64_t v73 = v58;
              *(void *)uint64_t v57 = 0;
              unsigned int v35 = v57 + 8;
              v72.i64[1] = (uint64_t)(v57 + 8);
              uint64_t v60 = *((void *)this + 24);
              unint64_t v59 = *((void *)this + 25);
              if (v59 != v60)
              {
                do
                {
                  uint64_t v61 = *(void *)(v59 - 8);
                  v59 -= 8;
                  *((void *)v57 - 1) = v61;
                  v57 -= 8;
                }
                while (v59 != v60);
                goto LABEL_79;
              }
              goto LABEL_80;
            }
            void *v34 = 0;
            unsigned int v35 = v34 + 1;
          }
LABEL_82:
          *((void *)this + 25) = v35;
          ++v30;
        }
        while (v30 != v31);
      }
    }
    uint64_t v66 = (uint64_t)&v2[3 * bswap32(v2[2]) + 4];
    *((void *)this + 22) = v66;
    *((void *)this + 23) = v66;
    *((_OWORD *)this + 10) = *(_OWORD *)((char *)this + 8);
    unint64_t v28 = (unsigned int *)*((void *)this + 3);
    unint64_t v8 = *((void *)this + 4);
    unsigned int v5 = v2 + 4;
  }
  *((_DWORD *)this + 10) = bswap32(*v2);
  if (v28 > v5
    || ((LODWORD(v67) = bswap32(v2[2]), unint64_t v68 = (unint64_t)&v5[3 * v67], v68 >= (unint64_t)v5)
      ? (BOOL v69 = v68 > v8)
      : (BOOL v69 = 1),
        v69))
  {
    LODWORD(v67) = 0;
    if (v28 <= v5 && (unint64_t)(v2 + 7) <= v8) {
      unint64_t v67 = (v8 - (unint64_t)v5) / 0xC;
    }
  }
  *((_DWORD *)this + 11) = v67;
  *((void *)this + 6) = v5;
  return 1;
}

uint64_t TAATMorphTableMorx::GetChain(TAATMorphTableMorx *this, unsigned int *a2)
{
  *a2 = bswap32(*(_DWORD *)(*((void *)this + 5) + 4));
  return (uint64_t)this + 64;
}

uint64_t TAATMorphChainMorx::GetSubtable(TAATMorphChainMorx *this, unsigned int *a2)
{
  *a2 = bswap32(*(_DWORD *)(*((void *)this + 3) + 12));
  return (uint64_t)this + 72;
}

void GetLocaleChangedCount(void)::$_0::__invoke()
{
  LocalCenter = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterAddObserver(LocalCenter, 0, (CFNotificationCallback)HandleLocaleChanged, (CFStringRef)*MEMORY[0x1E4F1D200], 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();

  CFNotificationCenterAddObserver(DarwinNotifyCenter, 0, (CFNotificationCallback)HandleLocaleChanged, @"com.apple.language.changed", 0, CFNotificationSuspensionBehaviorDeliverImmediately);
}

void std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,OTL::GlyphLookups::SortLookups(void)::{lambda(std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&)#1} &,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>*>(__int16 *a1, __int16 *a2, __int16 *a3, __int16 *a4)
{
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,OTL::GlyphLookups::SortLookups(void)::{lambda(std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&)#1} &,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>*>(a1, a2, a3);
  unsigned int v8 = (unsigned __int16)*a4;
  unsigned int v9 = (unsigned __int16)*a3;
  BOOL v10 = v8 == v9;
  if (v8 >= v9) {
    char v11 = 1;
  }
  else {
    char v11 = -1;
  }
  if (v10)
  {
    unsigned int v12 = (unsigned __int16)a4[1];
    unsigned int v13 = (unsigned __int16)a3[1];
    BOOL v14 = v12 >= v13;
    BOOL v15 = v12 == v13;
    char v11 = -1;
    if (v14) {
      char v11 = 1;
    }
    if (v15) {
      char v11 = 0;
    }
  }
  if (v11 < 0)
  {
    std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>::swap[abi:nn180100](a3, a4);
    unsigned int v16 = (unsigned __int16)*a3;
    unsigned int v17 = (unsigned __int16)*a2;
    BOOL v18 = v16 == v17;
    if (v16 >= v17) {
      char v19 = 1;
    }
    else {
      char v19 = -1;
    }
    if (v18)
    {
      unsigned int v20 = (unsigned __int16)a3[1];
      unsigned int v21 = (unsigned __int16)a2[1];
      BOOL v14 = v20 >= v21;
      BOOL v22 = v20 == v21;
      char v19 = -1;
      if (v14) {
        char v19 = 1;
      }
      if (v22) {
        char v19 = 0;
      }
    }
    if (v19 < 0)
    {
      std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>::swap[abi:nn180100](a2, a3);
      unsigned int v23 = (unsigned __int16)*a2;
      unsigned int v24 = (unsigned __int16)*a1;
      BOOL v25 = v23 == v24;
      if (v23 >= v24) {
        char v26 = 1;
      }
      else {
        char v26 = -1;
      }
      if (v25)
      {
        unsigned int v27 = (unsigned __int16)a2[1];
        unsigned int v28 = (unsigned __int16)a1[1];
        BOOL v14 = v27 >= v28;
        BOOL v29 = v27 == v28;
        char v26 = -1;
        if (v14) {
          char v26 = 1;
        }
        if (v29) {
          char v26 = 0;
        }
      }
      if (v26 < 0)
      {
        std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>::swap[abi:nn180100](a1, a2);
      }
    }
  }
}

void std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,OTL::GlyphLookups::SortLookups(void)::{lambda(std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&)#1} &,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>*>(__int16 *a1, __int16 *a2, __int16 *a3)
{
  unsigned int v5 = a1;
  unsigned int v6 = (unsigned __int16)*a2;
  unsigned int v7 = (unsigned __int16)*a1;
  char v8 = -1;
  if (v6 >= v7) {
    char v8 = 1;
  }
  if (v6 == v7)
  {
    unsigned int v9 = (unsigned __int16)a2[1];
    unsigned int v10 = (unsigned __int16)a1[1];
    BOOL v11 = v9 >= v10;
    BOOL v12 = v9 == v10;
    char v13 = -1;
    if (v11) {
      char v13 = 1;
    }
    if (v12) {
      char v8 = 0;
    }
    else {
      char v8 = v13;
    }
  }
  unsigned int v14 = (unsigned __int16)*a3;
  char v15 = -1;
  if (v14 >= v6) {
    char v15 = 1;
  }
  if (v8 < 0)
  {
    if (v14 == v6)
    {
      unsigned int v28 = (unsigned __int16)a3[1];
      unsigned int v29 = (unsigned __int16)a2[1];
      BOOL v11 = v28 >= v29;
      BOOL v30 = v28 == v29;
      char v31 = -1;
      if (v11) {
        char v31 = 1;
      }
      if (v30) {
        char v15 = 0;
      }
      else {
        char v15 = v31;
      }
    }
    if ((v15 & 0x80) == 0)
    {
      std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>::swap[abi:nn180100](a1, a2);
      unsigned int v32 = (unsigned __int16)*a3;
      unsigned int v33 = (unsigned __int16)*a2;
      BOOL v34 = v32 == v33;
      if (v32 >= v33) {
        char v35 = 1;
      }
      else {
        char v35 = -1;
      }
      if (v34)
      {
        unsigned int v36 = (unsigned __int16)a3[1];
        unsigned int v37 = (unsigned __int16)a2[1];
        BOOL v11 = v36 >= v37;
        BOOL v38 = v36 == v37;
        char v35 = -1;
        if (v11) {
          char v35 = 1;
        }
        if (v38) {
          char v35 = 0;
        }
      }
      if ((v35 & 0x80) == 0) {
        return;
      }
      a1 = a2;
    }
    unsigned int v27 = a3;
    goto LABEL_55;
  }
  if (v14 == v6)
  {
    unsigned int v16 = (unsigned __int16)a3[1];
    unsigned int v17 = (unsigned __int16)a2[1];
    BOOL v11 = v16 >= v17;
    BOOL v18 = v16 == v17;
    char v19 = -1;
    if (v11) {
      char v19 = 1;
    }
    if (v18) {
      char v15 = 0;
    }
    else {
      char v15 = v19;
    }
  }
  if (v15 < 0)
  {
    std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>::swap[abi:nn180100](a2, a3);
    unsigned int v20 = (unsigned __int16)*a2;
    unsigned int v21 = (unsigned __int16)*v5;
    BOOL v22 = v20 == v21;
    if (v20 >= v21) {
      char v23 = 1;
    }
    else {
      char v23 = -1;
    }
    if (v22)
    {
      unsigned int v24 = (unsigned __int16)a2[1];
      unsigned int v25 = (unsigned __int16)v5[1];
      BOOL v11 = v24 >= v25;
      BOOL v26 = v24 == v25;
      char v23 = -1;
      if (v11) {
        char v23 = 1;
      }
      if (v26) {
        char v23 = 0;
      }
    }
    if (v23 < 0)
    {
      a1 = v5;
      unsigned int v27 = a2;
LABEL_55:
      std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>::swap[abi:nn180100](a1, v27);
    }
  }
}

void *CTFontGetLanguageAwareOutsets(void *result, double *a2, double *a3, double *a4, double *a5)
{
  return CTFontGetLanguageAwareOutsetsForLanguage(result, a2, a3, a4, a5);
}

unint64_t CTFontDescriptorCreateWithTextStyle(__CFString *a1, __CFString *a2, unint64_t a3)
{
  TDescriptorSource::TDescriptorSource((TDescriptorSource *)&v8);
  TDescriptorSource::CreateDescriptorForTextStyle(a1, a2, a3, 0, &v9);
  unint64_t v6 = atomic_exchange((atomic_ullong *volatile)&v9, 0);

  return v6;
}

uint64_t TSplicedFont::CopyTable(TSplicedFont *this)
{
  uint64_t v1 = *(void *)(*((void *)this + 76) + 40);
  if ((*(_DWORD *)(v1 + 16) & 0x80000000) == 0) {
    TDescriptor::InitBaseFont(*(TDescriptor **)(*((void *)this + 76) + 40), 0, 0.0);
  }
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)atomic_load_explicit((atomic_ullong *volatile)(v1 + 32), memory_order_acquire)
                           + 480);

  return v2();
}

void TAATMorphTableMorx::TAATMorphTableMorx(TAATMorphTableMorx *this, TRunGlue *a2)
{
  TAATMorphTable::TAATMorphTable(this, a2, 1634561906);
  *(void *)uint64_t v3 = &unk_1ED05E7B0;
  uint64_t v4 = *(void *)(v3 + 8);
  uint64_t v5 = *(void *)(v4 + 616);
  char v6 = *(unsigned char *)(v3 + 24);
  char v7 = *(unsigned char *)(v3 + 25);
  *(_OWORD *)(v3 + 88) = 0u;
  *(_OWORD *)(v3 + 72) = 0u;
  *(void *)(v3 + 120) = v5;
  *(unsigned char *)(v3 + 128) = v7;
  *(void *)(v3 + 64) = &unk_1ED05E770;
  *(void *)(v3 + 160) = TAATLookupTable::BadTable;
  *(void *)(v3 + 168) = 0;
  *(void *)(v3 + 200) = 0;
  *(_WORD *)(v3 + 208) = -1;
  *(unsigned char *)(v3 + 216) = v6;
  *(void *)(v3 + 136) = &unk_1ED05EB58;
  *(void *)(v3 + 264) = 0;
  *(void *)(v3 + 272) = 0;
  *(void *)(v3 + 256) = 0;
  *(void *)(v3 + 664) = v3 + 280;
  uint64_t v8 = *(void *)(v3 + 40);
  if (v8)
  {
    unint64_t v9 = *((void *)this + 6);
    uint64_t v10 = v8 + 8;
    if (v8 + 8 > v9)
    {
      BOOL v12 = TFont::DebugDescription(*(TFont **)(v4 + 616));
      CFLog();

      uint64_t v11 = *(void *)(*(void *)(*((void *)this + 1) + 616) + 400);
      (*(void (**)(uint64_t))(*(void *)v11 + 488))(v11);
      *((void *)this + 4) = 0;
      *((void *)this + 5) = 0;
    }
    else
    {
      *((void *)this + 9) = v8;
      *((void *)this + 10) = v9;
      *((void *)this + 11) = v10;
      *((void *)this + 12) = v10;
    }
  }
}

void TAATMorphTable::TAATMorphTable(TAATMorphTable *this, TRunGlue *a2, uint64_t a3)
{
  *(void *)this = &unk_1ED05DFD0;
  *((void *)this + 1) = a2;
  *((void *)this + 2) = 0;
  *((unsigned char *)this + 24) = *((unsigned char *)a2 + 634);
  *((unsigned char *)this + 25) = 0;
  *((_DWORD *)this + 7) = a3;
  CFDataRef CommonTable = (const __CFData *)TBaseFont::GetCommonTable(*(TBaseFont **)(*((void *)a2 + 77) + 400), a3, (unsigned int *)this + 7);
  *((void *)this + 4) = CommonTable;
  if (CommonTable)
  {
    BytePtr = CFDataGetBytePtr(CommonTable);
    *((void *)this + 5) = BytePtr;
    *((unsigned char *)this + 56) = 1;
    if (BytePtr)
    {
      char v6 = BytePtr;
      CFIndex Length = CFDataGetLength(*((CFDataRef *)this + 4));
      *((void *)this + 6) = &v6[Length];
      if (*((void *)this + 5) + 4 > (unint64_t)&v6[Length])
      {
        *(_DWORD *)cStr = bswap32(*((_DWORD *)this + 7));
        char v20 = 0;
        unsigned int v17 = (__CFString *)CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], cStr, 0);
        BOOL v18 = TFont::DebugDescription(*(TFont **)(*((void *)this + 1) + 616));
        CFLog();

        uint64_t v16 = *(void *)(*(void *)(*((void *)this + 1) + 616) + 400);
        (*(void (**)(uint64_t, void))(*(void *)v16 + 488))(v16, *((unsigned int *)this + 7));
        *((void *)this + 4) = 0;
        *((void *)this + 5) = 0;
      }
      else
      {
        uint64_t v8 = *((void *)this + 1);
        uint64_t v9 = *(void *)(v8 + 16);
        if (v9 < 1)
        {
          *((unsigned char *)this + 25) = *(unsigned char *)(v8 + 593);
        }
        else
        {
          CFIndex v10 = *(void *)(v8 + 8);
          uint64_t v11 = *(void *)(*(void *)(*(void *)(*(void *)v8 + 16) + 8 * v10) + 48);
          *((unsigned char *)this + 25) = *(unsigned char *)(v11 + 260) & 1;
          if (v9 != 1)
          {
            uint64_t v12 = v9 + v10;
            CFIndex v13 = 1;
            while (1)
            {
              unsigned int v14 = (TRunGlue *)*((void *)this + 1);
              uint64_t v15 = *(void *)(*(void *)(*(void *)(*(void *)v14 + 16) + 8 * v10 + 8 * v13) + 48);
              if (*(unsigned __int8 *)(v11 + 224) != *(unsigned __int8 *)(v15 + 224)) {
                break;
              }
              if (!TFont::Compare(*(TFont **)(atomic_load_explicit((atomic_ullong *volatile)(v11 + 56), memory_order_acquire)+ 40), *(const TFont **)(atomic_load_explicit((atomic_ullong *volatile)(v15 + 56), memory_order_acquire)+ 40), 1))
              {
                unsigned int v14 = (TRunGlue *)*((void *)this + 1);
                break;
              }
              *((unsigned char *)this + 25) |= *(unsigned char *)(v15 + 260) & 1;
              *((unsigned char *)this + 56) = 0;
              ++v13;
              if (v10 + v13 >= v12) {
                return;
              }
            }
            v21.locatioCFIndex n = v10;
            v21.unsigned int length = v13;
            TRunGlue::SetRunRange(v14, v21);
          }
        }
      }
    }
  }
  else
  {
    *((void *)this + 5) = 0;
    *((unsigned char *)this + 56) = 1;
  }
}

CFStringRef GetSystemLibraryFontsPath(void)::$_0::__invoke()
{
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (qword_1EB2CE458 != -1) {
    dispatch_once_f(&qword_1EB2CE458, 0, (dispatch_function_t)GetSystemRootPath(void)::$_0::__invoke);
  }
  CFStringRef result = CFStringCreateWithFormat(v0, 0, @"%@System/Library/Fonts/", GetSystemRootPath(void)::_sysPath);
  qword_1EB2CE478 = (uint64_t)result;
  return result;
}

const char *GetSystemRootPath(void)::$_0::__invoke()
{
  CFStringRef result = getenv("SIMULATOR_ROOT");
  if (result)
  {
    uint64_t v1 = result;
    if (*result)
    {
      if (result[strlen(result) - 1] == 47) {
        uint64_t v2 = "";
      }
      else {
        uint64_t v2 = "/";
      }
      CFStringRef result = (const char *)CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%s%s", v1, v2);
      GetSystemRootPath(void)::_sysPath = (uint64_t)result;
    }
  }
  return result;
}

void TSplicedFont::CopyVariationAxes(TSplicedFont *this@<X0>, void *a2@<X8>)
{
  uint64_t v4 = (atomic_ullong *)((char *)this + 600);
  if (TSplicedFontDict::ComponentHasVariations((atomic_ullong *)this + 75))
  {
    CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit(v4, memory_order_acquire);
    if (explicit && (CFNumberRef Value = (void *)CFDictionaryGetValue(explicit, @"variationAxes")) != 0)
    {
      id v9 = Value;
      *a2 = atomic_exchange((atomic_ullong *volatile)&v9, 0);
    }
    else
    {
      uint64_t v7 = *(void *)(*((void *)this + 76) + 40);
      if ((*(_DWORD *)(v7 + 16) & 0x80000000) == 0) {
        TDescriptor::InitBaseFont((TDescriptor *)v7, 0, 0.0);
      }
      uint64_t v8 = *(void (**)(void))(*(void *)atomic_load_explicit((atomic_ullong *volatile)(v7 + 32), memory_order_acquire)
                            + 120);
      v8();
    }
  }
  else
  {
    *a2 = 0;
  }
}

BOOL std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,anonymous namespace'::PathObserver::Intersection *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (v6)
  {
    uint64_t v8 = *(void *)a1;
    int v10 = *(_DWORD *)(a1 + 8);
    int v9 = *(_DWORD *)(a1 + 12);
    if (result)
    {
      *(_OWORD *)a1 = *(_OWORD *)a3;
    }
    else
    {
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(void *)a2 = v8;
      *(_DWORD *)(a2 + 8) = v10;
      *(_DWORD *)(a2 + 12) = v9;
      if (!result) {
        return result;
      }
      *(_OWORD *)a2 = *(_OWORD *)a3;
    }
    *(void *)a3 = v8;
    *(_DWORD *)(a3 + 8) = v10;
    *(_DWORD *)(a3 + 12) = v9;
  }
  else if (result)
  {
    uint64_t v11 = *(void *)a2;
    uint64_t v12 = *(void *)(a2 + 8);
    *(_OWORD *)a2 = *(_OWORD *)a3;
    *(void *)a3 = v11;
    *(void *)(a3 + 8) = v12;
    if (result)
    {
      uint64_t v13 = *(void *)a1;
      uint64_t v14 = *(void *)(a1 + 8);
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(void *)a2 = v13;
      *(void *)(a2 + 8) = v14;
    }
  }
  return result;
}

void std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,anonymous namespace'::PathObserver::Intersection *,false>(unint64_t a1, long long *a2, uint64_t a3, char a4)
{
  while (2)
  {
    int v10 = a2 - 1;
    uint64_t v84 = (uint64_t)(a2 - 2);
    uint64_t v85 = a2;
    uint64_t v11 = (uint64_t)(a2 - 3);
    uint64_t v12 = (long long *)a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = (unint64_t)v12;
          uint64_t v13 = (char *)a2 - (char *)v12;
          uint64_t v14 = a2 - v12;
          if (v5 || !v4)
          {
            switch(v14)
            {
              case 0:
              case 1:
                return;
              case 2:
                {
                  uint64_t v34 = *(void *)a1;
                  uint64_t v35 = *(void *)(a1 + 8);
                  *(_OWORD *)a1 = *v10;
                  *((void *)a2 - 2) = v34;
                  *((void *)a2 - 1) = v35;
                }
                break;
              case 3:
                break;
              case 4:
                break;
              case 5:
                unsigned int v36 = (long long *)(a1 + 16);
                unsigned int v37 = (long long *)(a1 + 32);
                BOOL v38 = (long long *)(a1 + 48);
                {
                  uint64_t v39 = *(void *)(a1 + 48);
                  uint64_t v40 = *(void *)(a1 + 56);
                  long long *v38 = *v10;
                  *((void *)a2 - 2) = v39;
                  *((void *)a2 - 1) = v40;
                  {
                    uint64_t v41 = *(void *)(a1 + 32);
                    uint64_t v42 = *(void *)(a1 + 40);
                    long long *v37 = *v38;
                    *(void *)(a1 + 48) = v41;
                    *(void *)(a1 + 56) = v42;
                    {
                      uint64_t v43 = *(void *)(a1 + 16);
                      uint64_t v44 = *(void *)(a1 + 24);
                      long long *v36 = *v37;
                      *(void *)(a1 + 32) = v43;
                      *(void *)(a1 + 40) = v44;
                      {
                        uint64_t v45 = *(void *)a1;
                        uint64_t v46 = *(void *)(a1 + 8);
                        *(_OWORD *)a1 = *v36;
                        *(void *)(a1 + 16) = v45;
                        *(void *)(a1 + 24) = v46;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v13 <= 383)
          {
            uint64_t v47 = a1 + 16;
            BOOL v49 = (long long *)a1 == a2 || v47 == (void)a2;
            if (a4)
            {
              if (!v49)
              {
                uint64_t v50 = 0;
                uint64_t v51 = (long long *)a1;
                do
                {
                  uint64_t v52 = (uint64_t)v51;
                  uint64_t v51 = (long long *)v47;
                  {
                    long long v87 = *v51;
                    uint64_t v53 = v50;
                    while (1)
                    {
                      *(_OWORD *)(a1 + v53 + 16) = *(_OWORD *)(a1 + v53);
                      if (!v53) {
                        break;
                      }
                      v53 -= 16;
                      {
                        uint64_t v54 = (_OWORD *)(a1 + v53 + 16);
                        goto LABEL_82;
                      }
                    }
                    uint64_t v54 = (_OWORD *)a1;
LABEL_82:
                    *uint64_t v54 = v87;
                    a2 = v85;
                  }
                  uint64_t v47 = (uint64_t)(v51 + 1);
                  v50 += 16;
                }
                while (v51 + 1 != a2);
              }
            }
            else if (!v49)
            {
              uint64_t v80 = a1 - 16;
              do
              {
                uint64_t v81 = a1;
                a1 = v47;
                {
                  long long v87 = *(_OWORD *)a1;
                  uint64_t v82 = v80;
                  do
                  {
                    *(_OWORD *)(v82 + 32) = *(_OWORD *)(v82 + 16);
                    v82 -= 16;
                  }
                  while (v83);
                  *(_OWORD *)(v82 + 32) = v87;
                }
                uint64_t v47 = a1 + 16;
                v80 += 16;
              }
              while ((long long *)(a1 + 16) != a2);
            }
            return;
          }
          if (!a3)
          {
            if ((long long *)a1 != a2)
            {
              int64_t v55 = (unint64_t)(v14 - 2) >> 1;
              int64_t v56 = v55;
              do
              {
                int64_t v57 = v56;
                if (v55 >= v56)
                {
                  uint64_t v58 = (2 * v56) | 1;
                  unint64_t v59 = (long long *)(a1 + 16 * v58);
                  if (2 * v56 + 2 < v14
                  {
                    ++v59;
                    uint64_t v58 = 2 * v57 + 2;
                  }
                  uint64_t v60 = (long long *)(a1 + 16 * v57);
                  {
                    long long v87 = *v60;
                    do
                    {
                      uint64_t v61 = v59;
                      *uint64_t v60 = *v59;
                      if (v55 < v58) {
                        break;
                      }
                      uint64_t v62 = (2 * v58) | 1;
                      unint64_t v59 = (long long *)(a1 + 16 * v62);
                      uint64_t v63 = 2 * v58 + 2;
                      if (v63 < v14
                      {
                        ++v59;
                        uint64_t v62 = v63;
                      }
                      uint64_t v60 = v61;
                      uint64_t v58 = v62;
                    }
                    long long *v61 = v87;
                  }
                }
                int64_t v56 = v57 - 1;
              }
              while (v57);
              uint64_t v64 = (unint64_t)v13 >> 4;
              uint64_t v65 = v85;
              do
              {
                uint64_t v66 = 0;
                unint64_t v67 = v65;
                uint64_t v68 = *(void *)a1;
                int v69 = *(_DWORD *)(a1 + 12);
                int v86 = *(_DWORD *)(a1 + 8);
                int v70 = (_OWORD *)a1;
                do
                {
                  uint64_t v71 = (uint64_t)&v70[v66 + 1];
                  uint64_t v72 = (2 * v66) | 1;
                  uint64_t v73 = 2 * v66 + 2;
                  if (v73 < v64
                  {
                    v71 += 16;
                    uint64_t v72 = v73;
                  }
                  *int v70 = *(_OWORD *)v71;
                  int v70 = (_OWORD *)v71;
                  uint64_t v66 = v72;
                }
                while (v72 <= (uint64_t)((unint64_t)(v64 - 2) >> 1));
                --v65;
                if ((long long *)v71 == v67 - 1)
                {
                  *(void *)uint64_t v71 = v68;
                  *(_DWORD *)(v71 + 8) = v86;
                  *(_DWORD *)(v71 + 12) = v69;
                }
                else
                {
                  *(_OWORD *)uint64_t v71 = *v65;
                  *((void *)v67 - 2) = v68;
                  *((_DWORD *)v67 - 2) = v86;
                  *((_DWORD *)v67 - 1) = v69;
                  uint64_t v74 = v71 - a1 + 16;
                  if (v74 >= 17)
                  {
                    unint64_t v75 = (((unint64_t)v74 >> 4) - 2) >> 1;
                    int v76 = (long long *)(a1 + 16 * v75);
                    {
                      unsigned int v77 = v65;
                      long long v87 = *(_OWORD *)v71;
                      do
                      {
                        unsigned int v78 = v76;
                        *(_OWORD *)uint64_t v71 = *v76;
                        if (!v75) {
                          break;
                        }
                        unint64_t v75 = (v75 - 1) >> 1;
                        int v76 = (long long *)(a1 + 16 * v75);
                        uint64_t v71 = (uint64_t)v78;
                      }
                      *unsigned int v78 = v87;
                      uint64_t v65 = v77;
                    }
                  }
                }
              }
              while (v64-- > 2);
            }
            return;
          }
          unint64_t v15 = (unint64_t)v14 >> 1;
          uint64_t v16 = a1 + 16 * ((unint64_t)v14 >> 1);
          if ((unint64_t)v13 < 0x801)
          {
          }
          else
          {
            uint64_t v17 = *(void *)a1;
            uint64_t v18 = *(void *)(a1 + 8);
            *(_OWORD *)a1 = *(_OWORD *)v16;
            *(void *)uint64_t v16 = v17;
            *(void *)(v16 + 8) = v18;
          }
          a2 = v85;
          --a3;
          if ((a4 & 1) != 0
          {
            break;
          }
          long long v87 = *(_OWORD *)a1;
          {
            uint64_t v12 = (long long *)a1;
            do
              ++v12;
          }
          else
          {
            unint64_t v28 = a1 + 16;
            do
            {
              uint64_t v12 = (long long *)v28;
              if (v28 >= (unint64_t)v85) {
                break;
              }
              unint64_t v28 = (unint64_t)(v12 + 1);
            }
            while (!v29);
          }
          unint64_t v30 = (unint64_t)v85;
          if (v12 < v85)
          {
            unint64_t v30 = (unint64_t)v85;
            do
              v30 -= 16;
          }
          while ((unint64_t)v12 < v30)
          {
            uint64_t v31 = *(void *)v12;
            uint64_t v32 = *((void *)v12 + 1);
            *uint64_t v12 = *(_OWORD *)v30;
            *(void *)unint64_t v30 = v31;
            *(void *)(v30 + 8) = v32;
            do
              ++v12;
            do
              v30 -= 16;
          }
          unsigned int v33 = v12 - 1;
          BOOL v4 = (unint64_t)(v12 - 1) >= a1;
          BOOL v5 = v12 - 1 == (long long *)a1;
          if (v12 - 1 != (long long *)a1) {
            *(_OWORD *)a1 = *v33;
          }
          a4 = 0;
          long long *v33 = v87;
        }
        uint64_t v19 = 0;
        long long v87 = *(_OWORD *)a1;
        do
          v19 += 16;
        char v20 = (uint64_t *)(a1 + v19);
        unint64_t v21 = (unint64_t)v85;
        BOOL v5 = v19 == 16;
        a2 = v85;
        if (v5)
        {
          unint64_t v21 = (unint64_t)v85;
          do
          {
            if ((unint64_t)v20 >= v21) {
              break;
            }
            v21 -= 16;
          }
        }
        else
        {
          do
            v21 -= 16;
        }
        if ((unint64_t)v20 >= v21)
        {
          BOOL v26 = (long long *)(v20 - 2);
        }
        else
        {
          unint64_t v22 = v21;
          char v23 = v20;
          do
          {
            uint64_t v24 = *v23;
            uint64_t v25 = v23[1];
            *(_OWORD *)char v23 = *(_OWORD *)v22;
            *(void *)unint64_t v22 = v24;
            *(void *)(v22 + 8) = v25;
            do
              v23 += 2;
            do
              v22 -= 16;
          }
          while ((unint64_t)v23 < v22);
          BOOL v26 = (long long *)(v23 - 2);
        }
        if (v26 != (long long *)a1) {
          *(_OWORD *)a1 = *v26;
        }
        *BOOL v26 = v87;
        if ((unint64_t)v20 >= v21) {
          break;
        }
LABEL_32:
        a4 = 0;
        uint64_t v12 = v26 + 1;
      }
      uint64_t v12 = v26 + 1;
      {
        break;
      }
      if (!v27) {
        goto LABEL_32;
      }
    }
    a2 = v26;
    if (!v27) {
      continue;
    }
    break;
  }
}

BOOL std::__less<void,void>::operator()[abi:nn180100]<anonymous namespace'::PathObserver::Intersection,anonymous namespace'::PathObserver::Intersection>(uint64_t a1, uint64_t a2)
{
  if (*(double *)a1 == *(double *)a2) {
    int v2 = 0;
  }
  else {
    int v2 = -127;
  }
  if (*(double *)a1 > *(double *)a2) {
    int v2 = 1;
  }
  if (*(double *)a1 < *(double *)a2) {
    int v2 = -1;
  }
  if (!v2)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 8);
    unsigned int v4 = *(_DWORD *)(a2 + 8);
    BOOL v5 = v3 == v4;
    LOBYTE(v2) = v3 < v4 ? -1 : 1;
    if (v5)
    {
      unsigned int v6 = *(_DWORD *)(a1 + 12);
      unsigned int v7 = *(_DWORD *)(a2 + 12);
      BOOL v8 = v6 == v7;
      LOBYTE(v2) = v6 < v7 ? -1 : 1;
      if (v8) {
        LOBYTE(v2) = 0;
      }
    }
  }
  return v2 != 129 && (v2 & 0x80u) != 0;
}

double std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,anonymous namespace'::PathObserver::Intersection *>(uint64_t a1, double *a2, double *a3, uint64_t a4)
{
  {
    double v9 = *a3;
    uint64_t v10 = *((void *)a3 + 1);
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(double *)a4 = v9;
    *(void *)(a4 + 8) = v10;
    {
      double v11 = *a2;
      uint64_t v12 = *((void *)a2 + 1);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *a3 = v11;
      *((void *)a3 + 1) = v12;
      {
        double result = *(double *)a1;
        uint64_t v13 = *(void *)(a1 + 8);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *a2 = result;
        *((void *)a2 + 1) = v13;
      }
    }
  }
  return result;
}

CFStringRef GetSystemLibraryPrivateFontsPath(void)::$_0::__invoke()
{
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (qword_1EB2CE458 != -1) {
    dispatch_once_f(&qword_1EB2CE458, 0, (dispatch_function_t)GetSystemRootPath(void)::$_0::__invoke);
  }
  CFStringRef result = CFStringCreateWithFormat(v0, 0, @"%@System/Library/PrivateFrameworks/FontServices.framework/CorePrivate/", GetSystemRootPath(void)::_sysPath);
  qword_1EB2CE488 = (uint64_t)result;
  return result;
}

void TBaseFont::GetUnscaledTrackAmount(__CFDictionary const*,double,BOOL,unsigned int)const::$_0::__invoke()
{
  CFAllocatorRef v0 = (void *)CFPreferencesCopyValue(@"AppleSystemUIFontDefaultTrack", (CFStringRef)*MEMORY[0x1E4F1D3B8], (CFStringRef)*MEMORY[0x1E4F1D3F0], (CFStringRef)*MEMORY[0x1E4F1D3C8]);
  uint64_t v1 = v0;
  if (v0)
  {
    CFNumberRef v2 = v0;
    uint64_t valuePtr = -1;
    CFNumberGetValue(v2, kCFNumberDoubleType, &valuePtr);
    qword_1EB2CDB08 = valuePtr;
  }
}

void *CTRunGetStretchFactors(void *result, uint64_t a2, uint64_t a3, _OWORD *__dst)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (result && __dst)
  {
    uint64_t v4 = result[5];
    if ((*(unsigned char *)(v4 + 225) & 8) != 0)
    {
      uint64_t v10 = *(void *)(v4 + 264);
      v20[0] = &unk_1ED05D650;
      v20[1] = v4;
      v20[2] = __dst;
      unint64_t v21 = v20;
      uint64_t v11 = *(void *)(v4 + 208);
      uint64_t v12 = *(void *)(*(void *)(v4 + 216) + 16) + 2 * *(void *)(v4 + 200);
      if (a3) {
        uint64_t v13 = a3;
      }
      else {
        uint64_t v13 = *(void *)(v4 + 208);
      }
      uint64_t v14 = 0;
      if (v11 >= 1 && a2 >= 1)
      {
        uint64_t v16 = 0;
        do
        {
          if (v10 == v14 || *(__int16 *)(v12 + 2 * v14) != -1) {
            ++v16;
          }
          ++v14;
        }
        while (v14 < v11 && v16 < a2);
      }
      if (v14 < v11 && v13 >= 1)
      {
        uint64_t v18 = 0;
        do
        {
          if (v10 == v14 || *(unsigned __int16 *)(v12 + 2 * v14) != 0xFFFF) {
            std::function<void ()(long,long)>::operator()((uint64_t)v21, v14, v18++);
          }
          ++v14;
        }
        while (v14 < v11 && v18 < v13);
      }
      return std::__function::__value_func<void ()(long,long)>::~__value_func[abi:nn180100](v20);
    }
    else if ((a2 & 0x8000000000000000) == 0)
    {
      uint64_t v5 = *(void *)(v4 + 208);
      if (a2 + a3 <= v5)
      {
        uint64_t v6 = v5 - a2;
        if (a3) {
          uint64_t v6 = a3;
        }
        uint64_t v7 = *(void *)(v4 + 312);
        if (!v7 || (uint64_t v8 = *(void *)(v7 + 56), v8 == *(void *)(v7 + 64)))
        {
          if (v6 >= 1)
          {
            unint64_t v19 = v6 + 1;
            do
            {
              *__dst++ = kUnitSize;
              --v19;
            }
            while (v19 > 1);
          }
        }
        else if (v6)
        {
          double v9 = (const void *)(v8 + 16 * a2);
          return memmove(__dst, v9, 16 * v6);
        }
      }
    }
  }
  return result;
}

uint64_t CTFontIsAppleColorEmoji(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(**(void **)(*(void *)(result + 40) + 400) + 712))();
  }
  return result;
}

uint64_t TCFBase<TLine>::CreateTypeID()
{
  {
    TCFBase<TLine>::CreateTypeID(void)::runtimeunsigned int Class = 0;
    *(void *)algn_1EB2CD968 = "CTLine";
    qword_1EB2CD970 = 0;
    unk_1EB2CD978 = 0;
    qword_1EB2CD980 = (uint64_t)TCFBase<TLine>::ClassDestruct;
    qword_1EB2CD988 = (uint64_t)TCFBase<TLine>::ClassEqual;
    qword_1EB2CD990 = (uint64_t)TCFBase<TLine>::ClassHash;
    unk_1EB2CD998 = 0;
    qword_1EB2CD9A0 = (uint64_t)TCFBase<TLine>::ClassDebug;
    unk_1EB2CD9A8 = 0;
    qword_1EB2CD9B0 = 0;
    unk_1EB2CD9B8 = 0;
  }
  uint64_t result = _CFRuntimeRegisterClass();
  TCFBase<TLine>::fTypeID = result;
  return result;
}

uint64_t TCFBase<TRun>::CreateTypeID()
{
  {
    TCFBase<TRun>::CreateTypeID(void)::runtimeunsigned int Class = 0;
    *(void *)algn_1EB2CD908 = "CTRun";
    qword_1EB2CD910 = 0;
    unk_1EB2CD918 = 0;
    qword_1EB2CD920 = (uint64_t)TCFBase<TRun>::ClassDestruct;
    qword_1EB2CD928 = (uint64_t)TCFBase<TRun>::ClassEqual;
    qword_1EB2CD930 = (uint64_t)TCFBase<TRun>::ClassHash;
    unk_1EB2CD938 = 0;
    qword_1EB2CD940 = (uint64_t)TCFBase<TRun>::ClassDebug;
    unk_1EB2CD948 = 0;
    qword_1EB2CD950 = 0;
    unk_1EB2CD958 = 0;
  }
  uint64_t result = _CFRuntimeRegisterClass();
  TCFBase<TRun>::fTypeID = result;
  return result;
}

const void *CTRunCreateMutableRunsWithStorageAndOptions(_CTGlyphStorage *a1, CFIndex a2, CFIndex a3, const __CFDictionary *a4, unsigned int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = 0;
  if (a1 && a6)
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      uint64_t result = 0;
      if (a4)
      {
        if ((a2 & 0x8000000000000000) == 0 && (a3 & 0x8000000000000000) == 0)
        {
          int64_t count = a1->_count;
          if (a2 + a3 <= count)
          {
            CFIndex v18 = count - a2;
            if (a3) {
              v19.unsigned int length = a3;
            }
            else {
              v19.unsigned int length = v18;
            }
            v20[0] = a6;
            v20[1] = a7;
            v20[2] = a8;
            v19.locatioCFIndex n = a2;
            return TRunEncoder::Encode((TRunEncoder *)v20, a1, v19, a5, a4);
          }
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

const void *TRunEncoder::Encode(TRunEncoder *this, _CTGlyphStorage *a2, CFRange a3, unsigned int a4, const __CFDictionary *a5)
{
  CFRange v14 = a3;
  id v12 = (id)0xAAAAAAAAAAAAAAAALL;
  uint64_t v13 = a2;
  v15.locatioCFIndex n = 0;
  v15.unsigned int length = 0;
  TAttributes::TAttributes((TAttributes *)v10, a5, 0, v15, 1);
  TCFBase_NEW<CTGlyphRun,_CTGlyphStorage *&,CFRange &,TAttributes>(&v13, &v14, (const TAttributes *)v10, &v11);
  id v12 = (id)atomic_exchange((atomic_ullong *volatile)&v11, 0);

  TAttributes::~TAttributes((TAttributes *)v10);
  if (!atomic_load_explicit((atomic_ullong *volatile)&v12, memory_order_acquire))
  {
    uint64_t v8 = 0;
    goto LABEL_15;
  }
  uint64_t v7 = *(void *)(atomic_load_explicit((atomic_ullong *volatile)&v12, memory_order_acquire) + 48);
  objc_msgSend(*(id *)(v7 + 216), "resetOrigins:", *(void *)(v7 + 200), *(void *)(v7 + 208));
  TStorageRange::SyncWithStorage((TStorageRange *)(v7 + 192));
  if ((a4 & 8) != 0) {
    TAttributes::SetRareAttributes((TAttributes *)(v7 + 40), 1);
  }
  TAttributes::SetRareAttributes((TAttributes *)(v7 + 40), 2);
  if ((a4 & 0x10) == 0)
  {
    if ((a4 & 2) == 0) {
      goto LABEL_6;
    }
LABEL_9:
    *(_DWORD *)(v7 + 260) |= 1u;
    TAttributes::SetRareAttributes((TAttributes *)(v7 + 40), 8);
    if ((a4 & 0x20) == 0) {
      goto LABEL_12;
    }
LABEL_10:
    if (*(int *)(v7 + 256) <= 1) {
      *(_DWORD *)(v7 + 256) = 1;
    }
    goto LABEL_12;
  }
  *(unsigned char *)(v7 + 225) |= 1u;
  if ((a4 & 2) != 0) {
    goto LABEL_9;
  }
LABEL_6:
  if ((a4 & 0x20) != 0) {
    goto LABEL_10;
  }
LABEL_12:
  if ((a4 & 5) != 0) {
    uint64_t v8 = TRunEncoder::EncodeWithLineOptions((uint64_t *)this, (atomic_ullong *)&v12, a4);
  }
  else {
    uint64_t v8 = (const void *)atomic_exchange((atomic_ullong *volatile)&v12, 0);
  }
LABEL_15:

  return v8;
}

uint64_t TAttributes::SetRareAttributes(TAttributes *this, __int16 a2)
{
  uint64_t result = *((void *)this + 15);
  if (!result) {
    operator new();
  }
  *(_WORD *)(result + 66) |= a2;
  return result;
}

double TStorageRange::SyncWithStorage(TStorageRange *this)
{
  [*((id *)this + 3) sync];
  double __C = NAN;
  uint64_t v2 = *((void *)this + 3);
  uint64_t v3 = *(void *)(v2 + 32);
  if (v3 || (uint64_t v6 = *(void *)(v2 + 24)) == 0)
  {
    uint64_t v4 = (const double *)(v3 + 16 * *((void *)this + 1));
    vDSP_Stride v5 = 2;
  }
  else
  {
    uint64_t v4 = (const double *)(v6 + 8 * *((void *)this + 1));
    vDSP_Stride v5 = 1;
  }
  vDSP_sveD(v4, v5, &__C, *((void *)this + 2));
  double result = __C;
  *(double *)this = __C;
  return result;
}

void TCFBase_NEW<CTGlyphRun,_CTGlyphStorage *&,CFRange &,TAttributes>(_CTGlyphStorage **a1@<X0>, CFRange *a2@<X1>, const TAttributes *a3@<X2>, void *a4@<X8>)
{
  uint64_t v8 = TCFBase<TRun>::Allocate();
  if (v8)
  {
    double v9 = (void *)v8;
    uint64_t v10 = *a1;
    CFRange v13 = *a2;
    id v11 = (TRun *)(v8 + 72);
    v9[2] = 0;
    v9[3] = 0;
    v9[4] = 0;
    v9[5] = v11;
    v9[6] = v11;
    v9[7] = CTGlyphRun::CloneEntire;
    v9[8] = CTGlyphRun::CloneRange;
    TRun::TRun(v11, v10, v13, a3);
    id v12 = v9;
    *a4 = atomic_exchange((atomic_ullong *volatile)&v12, 0);
  }
  else
  {
    *a4 = 0;
  }
}

void TRun::TRun(TRun *this, _CTGlyphStorage *a2, CFRange a3, const TAttributes *a4)
{
  uint64_t length = a3.length;
  locatioCFIndex n = a3.location;
  *(void *)this = &unk_1ED05F378;
  *(_WORD *)((char *)this + 89) = 0;
  *((unsigned char *)this + 91) = 0;
  *((unsigned char *)this + 96) = 0;
  *((unsigned char *)this + 144) = 0;
  *((void *)this + 23) = 0;
  *((void *)this + 20) = 0;
  *((void *)this + 21) = 0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  TAttributes::operator=((uint64_t)this + 40, (uint64_t)a4);
  v15.locatioCFIndex n = location;
  v15.uint64_t length = length;
  TStorageRange::TStorageRange((TRun *)((char *)this + 192), a2, v15);
  *((void *)this + 34) = 0;
  *((void *)this + 35) = 0;
  *((void *)this + 32) = 0;
  *((void *)this + 33) = -1;
  *((_OWORD *)this + 18) = *MEMORY[0x1E4F1DB30];
  *((_DWORD *)this + 76) = -1;
  *((void *)this + 39) = 0;
  uint64_t v8 = length - 1;
  if (length < 1)
  {
    uint64_t v12 = 0;
    uint64_t v14 = 0;
  }
  else
  {
    double v9 = (void *)*((void *)this + 27);
    uint64_t v10 = *((void *)this + 25);
    id v11 = (uint64_t *)(v9[6] + 8 * v10);
    uint64_t v12 = *v11;
    uint64_t v13 = v11[v8];
    uint64_t v14 = v13 - v12 + [v9 attachmentCountAtIndex:v10 + v8] + 1;
  }
  *((void *)this + 1) = v12;
  *((void *)this + 2) = v14;
}

CGFloat CTFontGetUnderlinePosition(CTFontRef font)
{
  if (font) {
    return TFont::GetUnderlinePositionAndThickness(*((TFont **)font + 5));
  }
  else {
    return 0.0;
  }
}

CGFloat CTFontGetUnderlineThickness(CTFontRef font)
{
  if (!font) {
    return 0.0;
  }
  TFont::GetUnderlinePositionAndThickness(*((TFont **)font + 5));
  return v1;
}

void TDecorator::DrawDecoration(uint64_t a1, uint64_t a2, TLine *a3, uint64_t a4)
{
  uint64_t v184 = *MEMORY[0x1E4F143B8];
  memset(v171, 170, sizeof(v171));
  int64x2_t v169 = 0uLL;
  double v170 = 0.0;
  __int16 v172 = v171;
  if (a4)
  {
    uint64_t v8 = *(void **)a4;
    uint64_t v7 = *(void **)(a4 + 8);
    if (*(void **)a4 != v7)
    {
      CGFloat v9 = 0.0;
      do
      {
        uint64_t v10 = v8;
        v146[0] = (id)0xAAAAAAAAAAAAAAAALL;
        id v11 = (id)*v8;
        v146[0] = *(id *)v8;
        while ((id)*v8 == v11)
        {
          v8 += 4;
          if (v8 == v7)
          {
            uint64_t v8 = v7;
            break;
          }
        }
        uint64_t v12 = *(void *)(*(void *)(*(void *)(*((void *)a3 + 2) + 8 * (void)v11) + 40) + 208);
        if (v12 >= 1)
        {
          CGFloat v13 = 0.0;
          while (v10 != v8)
          {
            uint64_t v14 = v10[1];
            BOOL v15 = v14 <= *(void *)&v13;
            *(void *)&CGFloat v16 = v14 - *(void *)&v13;
            if (v15)
            {
              CFDictionaryRef explicit = (void *)atomic_load_explicit(v10 + 3, memory_order_acquire);
              uint64_t v18 = v169.i64[1];
              if (v169.i64[1] >= *(void *)&v170)
              {
                uint64_t v20 = (v169.i64[1] - v169.i64[0]) >> 5;
                if ((unint64_t)(v20 + 1) >> 59) {
                  abort();
                }
                unint64_t v21 = (*(void *)&v170 - v169.i64[0]) >> 4;
                if (v21 <= v20 + 1) {
                  unint64_t v21 = v20 + 1;
                }
                if (*(void *)&v170 - v169.i64[0] >= 0x7FFFFFFFFFFFFFE0uLL) {
                  unint64_t v22 = 0x7FFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v22 = v21;
                }
                *(void *)&v178.tdouble x = v171;
                if (v22) {
                  char v23 = TInlineBufferAllocator<DecorationOverride,30ul>::allocate((uint64_t)v171, v22);
                }
                else {
                  char v23 = 0;
                }
                *(void *)&CGFloat v24 = &v23[32 * v20];
                *(void *)&v178.CGFloat a = v23;
                v178.CGFloat b = v24;
                *(void *)&CGFloat d = &v23[32 * v22];
                v178.CGFloat d = d;
                long long v26 = *(_OWORD *)(v10 + 1);
                **(void **)&CGFloat v24 = v146[0];
                *(_OWORD *)(*(void *)&v24 + 8) = v26;
                *(void *)(*(void *)&v24 + 24) = explicit;
                *(void *)&CGFloat v9 = *(void *)&v24 + 32;
                *(void *)&v178.c = *(void *)&v24 + 32;
                uint64_t v27 = v169.i64[1];
                uint64_t v28 = v169.i64[0];
                if (v169.i64[1] == v169.i64[0])
                {
                  int64x2_t v30 = vdupq_n_s64(v169.u64[1]);
                }
                else
                {
                  do
                  {
                    long long v29 = *(_OWORD *)(v27 - 32);
                    *(void *)(*(void *)&v24 - 16) = *(void *)(v27 - 16);
                    *(_OWORD *)(*(void *)&v24 - 32) = v29;
                    *(void *)(*(void *)&v24 - 8) = atomic_exchange((atomic_ullong *volatile)(v27 - 8), 0);
                    *(void *)&v24 -= 32;
                    v27 -= 32;
                  }
                  while (v27 != v28);
                  int64x2_t v30 = v169;
                  CGFloat v9 = v178.c;
                  CGFloat d = v178.d;
                }
                *(CGFloat *)v169.i64 = v24;
                *(CGFloat *)&v169.i64[1] = v9;
                *(int64x2_t *)&v178.CGFloat b = v30;
                CGFloat v31 = v170;
                double v170 = d;
                v178.CGFloat d = v31;
                *(void *)&v178.CGFloat a = v30.i64[0];
                std::__split_buffer<DecorationOverride,TInlineBufferAllocator<DecorationOverride,30ul> &>::~__split_buffer((uint64_t)&v178);
              }
              else
              {
                long long v19 = *(_OWORD *)(v10 + 1);
                *(void *)v169.i64[1] = v146[0];
                *(_OWORD *)(v18 + 8) = v19;
                *(void *)(v18 + 24) = explicit;
                *(void *)&CGFloat v9 = v18 + 32;
              }
              *(CGFloat *)&v169.i64[1] = v9;
              uint64_t v32 = v10[1];
              uint64_t v33 = v10[2];
              v10 += 4;
              *(void *)&CGFloat v13 = v33 + v32;
            }
            else
            {
              v178.CGFloat a = v13;
              v178.CGFloat b = v16;
              if (*(void *)&v9 >= *(void *)&v170)
              {
                CGFloat v9 = COERCE_DOUBLE(std::vector<DecorationOverride,TInlineBufferAllocator<DecorationOverride,30ul>>::__emplace_back_slow_path<long &,CFRange>((char **)&v169, v146, (long long *)&v178));
              }
              else
              {
                **(void **)&CGFloat v9 = v146[0];
                *(CGFloat *)(*(void *)&v9 + 8) = v13;
                *(CGFloat *)(*(void *)&v9 + 16) = v16;
                *(void *)(*(void *)&v9 + 24) = 0;
                *(void *)&v9 += 32;
              }
              *(CGFloat *)&v169.i64[1] = v9;
              CGFloat v13 = *((double *)v10 + 1);
            }
            if (*(uint64_t *)&v13 >= v12) {
              goto LABEL_39;
            }
          }
          v178.CGFloat a = v13;
          *(void *)&v178.CGFloat b = v12 - *(void *)&v13;
          if (*(void *)&v9 >= *(void *)&v170)
          {
            CGFloat v9 = COERCE_DOUBLE(std::vector<DecorationOverride,TInlineBufferAllocator<DecorationOverride,30ul>>::__emplace_back_slow_path<long &,CFRange>((char **)&v169, v146, (long long *)&v178));
          }
          else
          {
            **(void **)&CGFloat v9 = v146[0];
            *(CGFloat *)(*(void *)&v9 + 8) = v13;
            *(void *)(*(void *)&v9 + 16) = v12 - *(void *)&v13;
            *(void *)(*(void *)&v9 + 24) = 0;
            *(void *)&v9 += 32;
          }
          *(CGFloat *)&v169.i64[1] = v9;
        }
LABEL_39:
        ;
      }
      while (v8 != v7);
    }
  }
  TLine::GetLeftHangersGlyphCountAndWidth(a3, 0);
  if (v34 == 0.0) {
    double v35 = 0.0;
  }
  else {
    double v35 = 0.0 - v34;
  }
  uint64_t v36 = a2;
  if (*(_DWORD *)a2) {
    CGFloat y = *(double *)(a2 + 24);
  }
  else {
    CGFloat y = CGContextGetTextPosition((CGContextRef)*(void *)(a2 + 8)).y;
  }
  CGFloat b = 0.0;
  uint64_t v40 = *((void *)a3 + 2);
  uint64_t v39 = *((void *)a3 + 3);
  uint64_t v145 = (v39 - v40) >> 3;
  uint64_t v41 = *(double **)(a2 + 80);
  unint64_t v137 = (_OWORD *)(a2 + 32);
  float64x2_t v142 = (float64x2_t)vdupq_n_s64(0x3CB0000000000000uLL);
  int8x16_t v138 = (int8x16_t)vdupq_n_s64(0x7FFFFFFFFFFFFFFFuLL);
  BOOL v139 = v41;
  double v140 = y;
  uint64_t v136 = a1;
  while (1)
  {
    v146[0] = (id)0xAAAAAAAAAAAAAAAALL;
    uint64_t v147 = unk_184BA6280;
    v150[1] = -1431655766;
    width[1] = NAN;
    v146[1] = 0;
    LOBYTE(v147) = 0;
    v150[0] = 0;
    double v148 = 0.0;
    width[0] = 0.0;
    *(double *)&long long v151 = v35;
    *((CGFloat *)&v151 + 1) = y;
    CGFloat v152 = b;
    CGFloat v153 = 0.0;
    LODWORD(v146[0]) = *(_DWORD *)a1;
    uint64_t v42 = v169.i64[0] == v169.i64[1] ? 0 : &v169;
    unint64_t v160 = v41;
    v167[0] = 0.0;
    *(void *)&CGFloat v43 = (v39 - v40) >> 3;
    v168.CGFloat a = b;
    v168.CGFloat b = 0.0;
    if (*(uint64_t *)&b >= *(uint64_t *)&v43)
    {
      *(double *)&uint64_t v46 = 0.0;
    }
    else
    {
      while (1)
      {
        v175.CGFloat a = -3.72066208e-103;
        v175.CGFloat a = *(CGFloat *)(*(void *)(*((void *)a3 + 2) + 8 * *(void *)&b) + 40);
        CGFloat a = v175.a;
        LOBYTE(v173) = 0;
        uint64_t v45 = operator new(0x38uLL);
        *uint64_t v45 = &unk_1ED0607D0;
        v45[1] = *(void *)&a + 40;
        v45[2] = a1;
        v45[3] = &v173;
        v45[4] = v146;
        v45[5] = v167;
        v45[6] = &v175;
        *(void *)&v178.CGFloat d = v45;
        EnumerateOverrides(*(void *)(*(void *)&a + 208), *(uint64_t *)&b, v42, (uint64_t)&v178);
        std::__function::__value_func<void ()(CFRange,__CFDictionary const*,BOOL *,BOOL *)>::~__value_func[abi:nn180100](&v178);
        if ((_BYTE)v173) {
          break;
        }
        ++*(void *)&b;
        v168.CGFloat a = b;
        if (*(void *)&v43 == *(void *)&b)
        {
          *(double *)&uint64_t v46 = 0.0;
          goto LABEL_57;
        }
      }
      *(void *)&v168.CGFloat b = 1;
      uint64_t v46 = 1;
    }
    if (*(void *)&b == *(void *)&v43)
    {
LABEL_57:
      CGFloat v152 = v43;
      CGFloat v153 = *(double *)&v46;
      CGFloat b = *(double *)&v46;
      double v47 = v167[0];
    }
    else
    {
      long long v173 = v151;
      int v157 = -1;
      CGFloat v165 = 0.0;
      c[0] = 0;
      CGFloat v158 = b;
      *(void *)&long long v159 = 0;
      CGFloat v163 = 0.0;
      double v164 = 0.0;
      char v156 = 0;
      while (*(uint64_t *)&b < *(uint64_t *)&v43)
      {
        unint64_t v155 = 0xAAAAAAAAAAAAAAAALL;
        unint64_t v155 = *(void *)(*(void *)(*((void *)a3 + 2) + 8 * *(void *)&b) + 40);
        unint64_t v48 = v155;
        char v154 = 0;
        BOOL v49 = operator new(0x88uLL);
        *BOOL v49 = &unk_1ED060818;
        v49[1] = v48 + 40;
        v49[2] = &v160;
        double v49[3] = &v155;
        v49[4] = &v173;
        v49[5] = a1;
        v49[6] = &v156;
        v49[7] = &v154;
        v49[8] = v146;
        v49[9] = &v157;
        v49[10] = &v163;
        v49[11] = &v158;
        v49[12] = &v168;
        v49[13] = c;
        v49[14] = &v164;
        v49[15] = &v159;
        v49[16] = &v165;
        *(void *)&v175.CGFloat d = v49;
        BOOL v50 = EnumerateOverrides(*(void *)(v48 + 208), *(uint64_t *)&b, v42, (uint64_t)&v175);
        std::__function::__value_func<void ()(CFRange,__CFDictionary const*,BOOL *,BOOL *)>::~__value_func[abi:nn180100](&v175);
        if (v154 || !v50) {
          break;
        }
        *(void *)&CGFloat b = ++*(void *)&v158;
      }
      v150[0] = v157;
      *(double *)&long long v151 = v167[0] + *(double *)&v173;
      *((CGContextRef *)&v151 + 1) = c[0];
      *(void *)&width[0] = v159;
      width[1] = v165;
      double v148 = v164;
      CGFloat v43 = v168.a;
      CGFloat b = v168.b;
      CGFloat v152 = v168.a;
      CGFloat v153 = v168.b;
      double v47 = v167[0] + v164;
      uint64_t v36 = a2;
    }
    if (*(uint64_t *)&v43 >= v145) {
      break;
    }
    if (v43 == 0.0 && (v169.i64[0] == v169.i64[1] || *(uint64_t *)v169.i64[0] >= 1))
    {
      if (*(uint64_t *)&b < 1)
      {
        uint64_t v63 = 0;
        double v64 = 0.0;
      }
      else
      {
        uint64_t v63 = 0;
        double v64 = 0.0;
        while (1)
        {
          uint64_t v65 = *(atomic_ullong **)(*(void *)(*((void *)a3 + 2) + 8 * v63) + 40);
          uint64_t v66 = v65[26];
          uint64_t v67 = (*(uint64_t (**)(atomic_ullong *))(*v65 + 80))(v65);
          double v64 = v64 + *(double *)&v68;
          if (v67 < v66) {
            break;
          }
          uint64_t v69 = v67;
          int v70 = (TParagraphStyle **)v65[21];
          char v71 = v70 ? TParagraphStyle::GetLineBoundsOptions(v70, v68) : 0;
          CFIndex LeftHangersGlyphCountAndWidth = TRun::GetLeftHangersGlyphCountAndWidth(v65, v69, v71, *(const TCharStream **)a3, 1);
          double v64 = v64 + v73;
          if (LeftHangersGlyphCountAndWidth < v66) {
            break;
          }
          if (*(void *)&b == ++v63)
          {
            uint64_t v36 = a2;
            goto LABEL_133;
          }
        }
      }
      if (v63 == *(void *)&b)
      {
        uint64_t v36 = a2;
        goto LABEL_133;
      }
      *(double *)&long long v151 = v64 + *(double *)&v151;
      double v148 = v148 - v64;
      uint64_t v36 = a2;
    }
    if (*(void *)&b + *(void *)&v43 == v145 && v169.i64[0] == v169.i64[1])
    {
      CGFloat v51 = v152;
      uint64_t v52 = *(void *)&v153 + *(void *)&v152;
      double v53 = 0.0;
      do
      {
        if (v52 <= *(uint64_t *)&v51)
        {
          CGFloat b = *(double *)&v145;
          goto LABEL_133;
        }
        uint64_t v54 = *(TRun **)(*(void *)(*((void *)a3 + 2) + 8 * v52 - 8) + 40);
        CFIndex v55 = *((void *)v54 + 26);
        uint64_t RightWhitespaceGlyphCountAndWidth = TRun::GetRightWhitespaceGlyphCountAndWidth(v54);
        double v53 = v53 + *(double *)&v57;
        uint64_t v58 = v55 - RightWhitespaceGlyphCountAndWidth;
        if (v55 > RightWhitespaceGlyphCountAndWidth) {
          break;
        }
        unint64_t v59 = (TParagraphStyle **)*((void *)v54 + 21);
        char v60 = v59 ? TParagraphStyle::GetLineBoundsOptions(v59, v57) : 0;
        CFIndex RightHangersGlyphCountAndWidth = TRun::GetRightHangersGlyphCountAndWidth((atomic_ullong *)v54, v58, v60, *(const TCharStream **)a3, -1);
        double v53 = v53 + v62;
        --v52;
      }
      while (RightHangersGlyphCountAndWidth >= v55);
      double v148 = v148 - v53;
    }
    CGFloat v74 = v152;
    CGFloat v75 = v153;
    double v76 = *(double *)(a1 + 8);
    if (v76 == 0.0)
    {
      int v86 = *(CGContext **)(v36 + 8);
      TLine::GetLeftHangersGlyphCountAndWidth(a3, 0);
      if (v87 == 0.0) {
        double v88 = 0.0;
      }
      else {
        double v88 = 0.0 - v87;
      }
      uint64_t v89 = *((void *)a3 + 2);
      int64_t v90 = (double *)(v89 + 8 * *(void *)&v74);
      *(void *)&CGFloat b = *(void *)&v75 + *(void *)&v74;
      unint64_t v160 = v90;
      *(void *)&v167[0] = v89 + 8 * *(void *)&b;
      c[0] = v86;
      CGContextSaveGState(v86);
      TAttributes::SetStrokeColor(v86, (void *)atomic_load_explicit((atomic_ullong *volatile)&v146[1], memory_order_acquire), v91);
      char v92 = v150[0];
      *(void *)&long long v93 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v93 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long v180 = v93;
      long long v179 = v93;
      *(_OWORD *)&v178.tdouble x = v93;
      *(_OWORD *)&v178.c = v93;
      *(_OWORD *)&v178.CGFloat a = v93;
      TDecorator::dashes((TDecorator *)&v178, v150[0], width[0] / (double)(v150[0] & 7));
      double v94 = c[0];
      CGContextSetLineWidth(c[0], width[0]);
      *(void *)&long long v95 = -1;
      *((void *)&v95 + 1) = -1;
      *(_OWORD *)&v168.c = v95;
      *(_OWORD *)&v168.tdouble x = v95;
      *(_OWORD *)&v168.CGFloat a = v95;
      CGContextGetTextMatrix(&v168, v94);
      *(double *)&long long v173 = v168.tx - v88;
      *((void *)&v173 + 1) = *(void *)&v168.ty;
      *(_OWORD *)&v168.tdouble x = *MEMORY[0x1E4F1DAD8];
      int64x2_t v96 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f64(v142, vabsq_f64(*(float64x2_t *)&v168.tx)), (int8x16_t)vcgeq_f64(v142, vabsq_f64(vaddq_f64(*(float64x2_t *)&v168.a, (float64x2_t)xmmword_184B88D30)))), (int8x16_t)vcgeq_f64(v142, vabsq_f64(vaddq_f64(*(float64x2_t *)&v168.c, (float64x2_t)xmmword_184B88D40))));
      LOBYTE(v159) = vandq_s8((int8x16_t)vdupq_laneq_s64(v96, 1), (int8x16_t)v96).i64[0] < 0;
      *(void *)&v175.CGFloat a = &v159;
      *(void *)&v175.CGFloat b = &v168;
      *(void *)&v175.c = c;
      *(void *)&v175.CGFloat d = &v173;
      *(void *)&v175.tdouble x = &v160;
      *(void *)&v175.tCGFloat y = v167;
      *(void *)&long long v176 = &v178;
      *((void *)&v176 + 1) = v146;
      double v97 = ceil(v148);
      double v99 = *((double *)&v151 + 1);
      double v98 = *(double *)&v151;
      if ((v92 & 8) != 0)
      {
        double v98 = *(double *)&v151;
        double v99 = *((double *)&v151 + 1) + width[1];
      }
      std::vector<double,TInlineBufferAllocator<double,6ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v178);
      CGContextRestoreGState(v86);
      goto LABEL_130;
    }
    CGFloat v144 = v153;
    TLine::GetLeftHangersGlyphCountAndWidth(a3, 0);
    if (v77 == 0.0) {
      double v78 = 0.0;
    }
    else {
      double v78 = 0.0 - v77;
    }
    uint64_t v141 = *((void *)a3 + 2);
    CGFloat v158 = v76;
    int v79 = (int)v146[0];
    unint64_t v80 = atomic_load_explicit((atomic_ullong *volatile)&v146[1], memory_order_acquire);
    CGFloat v82 = v148;
    CGFloat v81 = width[0];
    CGFloat v83 = width[1];
    unsigned int v84 = v150[0];
    long long v85 = v151;
    if (**(_DWORD **)&v76 == 1)
    {
      memset(&v178, 170, 24);
      *(void *)&long long v100 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v100 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long v177 = v100;
      long long v176 = v100;
      *(_OWORD *)&v175.tdouble x = v100;
      *(_OWORD *)&v175.c = v100;
      *(_OWORD *)&v175.CGFloat a = v100;
      TDecorator::dashes((TDecorator *)&v175, v150[0], width[0] / (double)(v150[0] & 7));
      LODWORD(v178.a) = 0;
      LODWORD(v178.b) = v79;
      v178.CGFloat d = v82;
      v178.tdouble x = v81;
      *(int8x8_t *)((char *)&v178.b + 4) = vand_s8((int8x8_t)vdup_n_s32(v84), (int8x8_t)0x700000000FFLL);
      v178.tCGFloat y = v83;
      long long v179 = v85;
      *(CGFloat *)&long long v180 = v74;
      *((CGFloat *)&v180 + 1) = v144;
      CGFloat v181 = v175.a;
      uint64_t v182 = (uint64_t)(*(void *)&v175.b - *(void *)&v175.a) >> 3;
      unint64_t v183 = v80;
      (*(void (**)(void))(*(void *)(*(void *)&v76 + 8) + 16))();
      std::vector<double,TInlineBufferAllocator<double,6ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v175);
    }
    else if (!**(_DWORD **)&v76)
    {
      (*(void (**)(double, double, double, double, double))(*(void *)(*(void *)&v76 + 8) + 16))(v148, width[0], width[1], *(double *)&v151, *((double *)&v151 + 1));
    }
    *(void *)&long long v101 = -1;
    *((void *)&v101 + 1) = -1;
    *(_OWORD *)&v168.c = v101;
    *(_OWORD *)&v168.tdouble x = v101;
    *(_OWORD *)&v168.CGFloat a = v101;
    uint64_t v36 = a2;
    if (*(_DWORD *)a2)
    {
      long long v102 = *(_OWORD *)(a2 + 48);
      *(_OWORD *)&v168.CGFloat a = *v137;
      *(_OWORD *)&v168.c = v102;
      *(_OWORD *)&v168.tdouble x = *(_OWORD *)(a2 + 64);
    }
    else
    {
      CGContextGetTextMatrix(&v168, *(CGContextRef *)(a2 + 8));
    }
    CGFloat v103 = v144;
    tdouble x = v168.tx;
    tCGFloat y = v168.ty;
    _V1.D[1] = v168.b;
    double v107 = *MEMORY[0x1E4F1DAD8];
    double v108 = *(double *)(MEMORY[0x1E4F1DAD8] + 8);
    v168.tdouble x = *(CGFloat *)MEMORY[0x1E4F1DAD8];
    v168.tCGFloat y = v108;
    int64x2_t v109 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f64(v142, (float64x2_t)vandq_s8(*(int8x16_t *)&v168.tx, v138)), (int8x16_t)vcgeq_f64(v142, vabsq_f64(vaddq_f64(*(float64x2_t *)&v168.a, (float64x2_t)xmmword_184B88D30)))), (int8x16_t)vcgeq_f64(v142, vabsq_f64(vaddq_f64(*(float64x2_t *)&v168.c, (float64x2_t)xmmword_184B88D40))));
    double v111 = *((double *)&v151 + 1);
    _D10 = *(double *)&v151;
    _D11 = *(double *)&v151 + ceil(v148);
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v109, 1), (int8x16_t)v109).u64[0] & 0x8000000000000000) != 0)
    {
      double v118 = *((double *)&v151 + 1);
    }
    else
    {
      __asm { FMLA            D7, D10, V1.D[1] }
      _D10 = v107 + vmlad_n_f64(v168.c * *((double *)&v151 + 1), *(double *)&v151, v168.a);
      double v118 = v108 + _D7;
      __asm { FMLA            D4, D11, V1.D[1] }
      _D11 = v107 + vmlad_n_f64(v168.c * *((double *)&v151 + 1), _D11, v168.a);
      double v111 = v108 + _D4;
    }
    double v120 = tx - v78;
    *(void *)&v178.CGFloat a = MEMORY[0x1E4F143A8];
    *(void *)&v178.CGFloat b = 3321888768;
    *(void *)&v178.c = ___ZZN14TDecorationRun22EnumerateDecorationRunIN12_GLOBAL__N_111TRunAdapterEEEvRK16TLineDrawContextT_S6_7CFRangeP18TDecoratorObserverdENKUl7CGPointSA_E_cvU13block_pointerFvSA_SA_EEv_block_invoke;
    *(void *)&v178.CGFloat d = &__block_descriptor_40_8_32c151_ZTSKZN14TDecorationRun22EnumerateDecorationRunIN12_GLOBAL__N_111TRunAdapterEEEvRK16TLineDrawContextT_S6_7CFRangeP18TDecoratorObserverdEUl7CGPointSA_E__e33_v40__0_CGPoint_dd_8_CGPoint_dd_24l;
    *(void *)&v178.tdouble x = &v158;
    *(double *)&uint64_t v121 = COERCE_DOUBLE(objc_msgSend((id)objc_msgSend(&v178, "copy", v136), "autorelease"));
    v167[0] = v120;
    v167[1] = ty;
    c[0] = *(CGContextRef *)&_D10;
    c[1] = *(CGContextRef *)&v118;
    CGFloat v165 = *(double *)&v121;
    CGFloat v163 = width[0];
    double v164 = width[0] * 0.75;
    if ((_BYTE)v147)
    {
      double v111 = v111 - v118 * 2.0;
      double v118 = v118 - v118 * 2.0;
      c[1] = *(CGContextRef *)&v118;
    }
    unint64_t v160 = &v164;
    unint64_t v161 = v167;
    uint64_t v162 = (uint64_t *)&v165;
    if (LODWORD(v146[0]))
    {
      if (_D11 - _D10 > width[0] * 0.75)
      {
        v122.n128_f64[0] = v120 + _D10;
        v123.n128_f64[0] = ty + v118;
        v124.n128_f64[0] = v120 + _D11;
        v125.n128_f64[0] = ty + v111;
LABEL_128:
        (*(void (**)(__n128, __n128, __n128, __n128))(v121 + 16))(v122, v123, v124, v125);
        goto LABEL_129;
      }
      goto LABEL_129;
    }
    long long v159 = *(_OWORD *)c;
    *(void *)&long long v126 = -1;
    *((void *)&v126 + 1) = -1;
    *(_OWORD *)&v178.tdouble x = v126;
    *(_OWORD *)&v178.c = v126;
    *(_OWORD *)&v178.CGFloat a = v126;
    if (*(_DWORD *)a2)
    {
      __n128 v123 = *(__n128 *)(a2 + 48);
      *(_OWORD *)&v178.CGFloat a = *v137;
      *(__n128 *)&v178.c = v123;
      __n128 v122 = *(__n128 *)(a2 + 64);
      *(__n128 *)&v178.tdouble x = v122;
      if (v144 == 0.0) {
        goto LABEL_125;
      }
    }
    else
    {
      CGContextGetTextMatrix(&v178, *(CGContextRef *)(a2 + 8));
      if (v144 == 0.0)
      {
LABEL_125:
        unsigned int v134 = &v164;
        goto LABEL_126;
      }
    }
    uint64_t v127 = 8 * *(void *)&v144;
    uint64_t v128 = (uint64_t *)(v141 + 8 * *(void *)&v74);
    do
    {
      uint64_t v129 = *v128++;
      uint64_t v130 = *(__n128 **)(v129 + 40);
      CGAffineTransform v175 = v178;
      CGFloat v131 = *(double *)&c[1] - width[0] * 0.5;
      double v132 = *(double *)&c[1] + width[0] * 0.5;
      long long v133 = operator new(0x28uLL);
      void *v133 = &unk_1ED05D328;
      v133[1] = &v163;
      v133[2] = c;
      v133[3] = &v160;
      v133[4] = &v159;
      CFArrayRef v174 = v133;
      TDecorationRun::CalculateGlyphIntersections((uint64_t)v146, &v175.a, v130, (uint64_t)&v173, v131, v132);
      std::__function::__value_func<void ()(double,double)>::~__value_func[abi:nn180100](&v173);
      v127 -= 8;
    }
    while (v127);
    unsigned int v134 = v160;
    uint64_t v36 = a2;
    CGFloat v103 = v144;
    a1 = v136;
LABEL_126:
    if (_D11 - *(double *)&v159 > *v134)
    {
      double v135 = v161[1];
      v122.n128_f64[0] = *(double *)&v159 + *v161;
      v123.n128_f64[0] = *((double *)&v159 + 1) + v135;
      v124.n128_f64[0] = _D11 + *v161;
      v125.n128_f64[0] = v111 + v135;
      uint64_t v121 = *v162;
      goto LABEL_128;
    }
LABEL_129:
    *(void *)&CGFloat b = *(void *)&v103 + *(void *)&v74;
    uint64_t v41 = v139;
    CGFloat y = v140;
LABEL_130:
    if (v169.i64[0] != v169.i64[1] && *(void *)v169.i64[0] < *(uint64_t *)&b) {
      CGFloat b = *(double *)v169.i64[0];
    }
LABEL_133:
    double v35 = v35 + v47;

    uint64_t v40 = *((void *)a3 + 2);
    uint64_t v39 = *((void *)a3 + 3);
  }

  *(void *)&v178.CGFloat a = &v169;
  std::vector<DecorationOverride,TInlineBufferAllocator<DecorationOverride,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v178);
}

void *std::__function::__value_func<void ()(CFRange,__CFDictionary const*,BOOL *,BOOL *)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

BOOL EnumerateOverrides(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  if (a3)
  {
    uint64_t v8 = (void *)*a3;
    uint64_t v7 = (void *)a3[1];
    CGFloat v9 = (void *)*a3;
    if ((void *)*a3 != v7)
    {
      CGFloat v9 = (void *)*a3;
      while (*v9 == a2)
      {
        v9 += 4;
        if (v9 == v7)
        {
          CGFloat v9 = (void *)a3[1];
          break;
        }
      }
    }
    if (a1 < 1)
    {
      uint64_t v11 = 0;
    }
    else
    {
      uint64_t v10 = 0;
      uint64_t v11 = 0;
      do
      {
        if (v8 == v9)
        {
          __int16 v29 = 0;
          uint64_t v26 = a1 - v11;
          uint64_t v22 = *(void *)(a4 + 24);
          char v23 = (char *)&v29 + 1;
          CGFloat v24 = &v29;
          uint64_t v25 = v11;
          goto LABEL_24;
        }
        uint64_t v12 = v10;
        uint64_t v13 = v8[1];
        uint64_t v14 = v8[2];
        __int16 v28 = 0;
        std::function<void ()(CFRange,__CFDictionary const*,BOOL *,BOOL *)>::operator()(*(void *)(a4 + 24), v13, v14, atomic_load_explicit(v8 + 3, memory_order_acquire), (uint64_t)&v28 + 1, (uint64_t)&v28);
        uint64_t v10 = v12 + HIBYTE(v28);
        if ((_BYTE)v28) {
          break;
        }
        uint64_t v11 = v14 + v13;
        v8 += 4;
      }
      while (v14 + v13 < a1);
      if (v10)
      {
        BOOL v15 = (void *)*a3;
        CGFloat v16 = (void *)a3[1];
        uint64_t v17 = *a3 + 32 * v10;
        if ((void *)v17 != v16)
        {
          uint64_t v18 = 4 * (v12 + HIBYTE(v28));
          long long v19 = (void *)*a3;
          do
          {
            long long v20 = *(_OWORD *)&v19[v18];
            _OWORD v19[2] = v19[v18 + 2];
            *(_OWORD *)long long v19 = v20;

            v19 += 4;
            v15 += 4;
          }
          while (&v19[v18] != v16);
          uint64_t v17 = a3[1];
        }
        if ((void *)v17 != v15)
        {
          do
          {
            uint64_t v21 = v17 - 32;

            uint64_t v17 = v21;
          }
          while ((void *)v21 != v15);
        }
        a3[1] = v15;
      }
    }
    return v11 == a1;
  }
  else
  {
    __int16 v30 = 0;
    uint64_t v22 = *(void *)(a4 + 24);
    char v23 = (char *)&v30 + 1;
    CGFloat v24 = &v30;
    uint64_t v25 = 0;
    uint64_t v26 = a1;
LABEL_24:
    std::function<void ()(CFRange,__CFDictionary const*,BOOL *,BOOL *)>::operator()(v22, v25, v26, 0, (uint64_t)v23, (uint64_t)v24);
    return 1;
  }
}

uint64_t std::function<void ()(CFRange,__CFDictionary const*,BOOL *,BOOL *)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v11[0] = a2;
  v11[1] = a3;
  uint64_t v9 = a5;
  uint64_t v10 = a4;
  uint64_t v8 = a6;
  if (a1) {
    return (*(uint64_t (**)(uint64_t, void *, uint64_t *, uint64_t *, uint64_t *))(*(void *)a1 + 48))(a1, v11, &v10, &v9, &v8);
  }
  uint64_t v7 = std::__throw_bad_function_call[abi:nn180100]();
  return std::__split_buffer<DecorationOverride,TInlineBufferAllocator<DecorationOverride,30ul> &>::~__split_buffer(v7);
}

uint64_t std::__split_buffer<DecorationOverride,TInlineBufferAllocator<DecorationOverride,30ul> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 32;
  }
  uint64_t v4 = *(void **)a1;
  if (*(void *)a1)
  {
    unint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = (void *)(v5 + 960);
    if (v5 <= (unint64_t)v4 && v6 > v4)
    {
      if (*(void *)(a1 + 24) == *v6) {
        *uint64_t v6 = v4;
      }
    }
    else
    {
      operator delete(v4);
    }
  }
  return a1;
}

void std::__function::__func<TDecorator::NextDecorationRun(double,TLine const&,TInlineVector<DecorationOverride,30ul> *,TDecorationRun &)::$_0,std::allocator<TDecorator::NextDecorationRun(double,TLine const&,TInlineVector<DecorationOverride,30ul> *,TDecorationRun &)::$_0>,void ()(CFRange,__CFDictionary const*,BOOL *,BOOL *)>::operator()(uint64_t a1, CFIndex *a2, const __CFDictionary **a3, void *a4, unsigned char **a5)
{
  CFIndex v6 = *a2;
  CFIndex v7 = a2[1];
  CFDictionaryRef v8 = *a3;
  uint64_t v9 = (unsigned char *)*a4;
  uint64_t v10 = *a5;
  v20[6] = xmmword_184BA63E0;
  memset(&v20[7], 170, 40);
  void v20[3] = unk_184BA63B0;
  memset(&v20[4], 255, 32);
  memset(v20, 170, 48);
  uint64_t v11 = *(_DWORD **)(a1 + 16);
  TAttributes::TAttributes((TAttributes *)v20, *(const TAttributes **)(a1 + 8), v8);
  if (*v11 == 1)
  {
    if ((BYTE9(v20[8]) & 0x10) != 0)
    {
      **(unsigned char **)(a1 + 24) = 1;
      uint64_t v14 = *(void *)(a1 + 32);
      StrikethroughColor = (void *)TAttributes::GetStrikethroughColor((TAttributes *)v20, v12, v13);
      goto LABEL_12;
    }
  }
  else if (!*v11 && (BYTE9(v20[8]) & 4) != 0)
  {
    **(unsigned char **)(a1 + 24) = 1;
    uint64_t v14 = *(void *)(a1 + 32);
    StrikethroughColor = (void *)TAttributes::GetUnderlineColor((TAttributes *)v20, v12, v13);
LABEL_12:
    TCFRef<__CTFont const*>::Retain((atomic_ullong *)(v14 + 8), StrikethroughColor);
    goto LABEL_13;
  }
  uint64_t v16 = **(void **)(a1 + 48);
  v21.locatioCFIndex n = v6;
  v21.uint64_t length = v7;
  double Width = TStorageRange::GetWidth((TStorageRange *)(v16 + 192), v21);
  double v18 = 0.0;
  if (!v6)
  {
    long long v19 = *(double **)(v16 + 312);
    if (!v19) {
      long long v19 = (double *)MEMORY[0x1E4F1DB30];
    }
    double v18 = *v19;
  }
  **(double **)(a1 + 40) = Width + v18 + **(double **)(a1 + 40);
  uint64_t v10 = v9;
LABEL_13:
  *uint64_t v10 = 1;
  TAttributes::~TAttributes((TAttributes *)v20);
}

const void *TAttributes::GetUnderlineColor(TAttributes *this, uint64_t a2, const __CFString **a3)
{
  if (*((unsigned char *)this + 136)) {
    return (const void *)*MEMORY[0x1E4F1D260];
  }
  double result = TAttributes::GetUnderlineColor((TAttributes *)atomic_load_explicit((atomic_ullong *volatile)this, memory_order_acquire), 0, a3);
  if (!result)
  {
    if ((*((unsigned char *)this + 136) & 2) != 0) {
      return (const void *)atomic_load_explicit((atomic_ullong *volatile)this + 4, memory_order_acquire);
    }
    else {
      return 0;
    }
  }
  return result;
}

void std::__function::__func<TDecorator::NextDecorationRun(double,TLine const&,TInlineVector<DecorationOverride,30ul> *,TDecorationRun &)::$_1,std::allocator<TDecorator::NextDecorationRun(double,TLine const&,TInlineVector<DecorationOverride,30ul> *,TDecorationRun &)::$_1>,void ()(CFRange,__CFDictionary const*,BOOL *,BOOL *)>::operator()(uint64_t a1, uint64_t *a2, const __CFDictionary **a3, unsigned char **a4, unsigned char **a5)
{
  uint64_t v6 = *a2;
  CFIndex v7 = (const __CFString **)a2[1];
  CFDictionaryRef v8 = *a3;
  uint64_t v9 = *a4;
  uint64_t v10 = *a5;
  uint64_t v11 = *(int **)(a1 + 40);
  v35[6] = xmmword_184BA63E0;
  memset(&v35[7], 170, 40);
  v35[3] = unk_184BA63B0;
  memset(&v35[4], 255, 32);
  memset(v35, 170, 48);
  TAttributes::TAttributes((TAttributes *)v35, *(const TAttributes **)(a1 + 8), v8);
  int v34 = 0;
  double v32 = 0.0;
  CFTypeRef cf2 = 0;
  double v30 = 0.0;
  double v31 = 0.0;
  double v12 = **(double **)(a1 + 16);
  uint64_t v13 = **(atomic_ullong ***)(a1 + 24);
  double v14 = *(double *)(*(void *)(a1 + 32) + 8);
  int v15 = *v11;
  __int16 v28 = *(BOOL **)(a1 + 48);
  double v29 = 0.0;
  if ((GetDecorationAttributes(v13, v6, v7, (TAttributes *)v35, v15, &v34, &cf2, &v32, v12, v14, &v31, &v30, &v29, v28) & 1) == 0) {
    goto LABEL_13;
  }
  *(unsigned char *)(*(void *)(a1 + 64) + 16) = **(unsigned char **)(a1 + 48);
  uint64_t v16 = *(_DWORD **)(a1 + 72);
  if (*v16 == -1)
  {
    *uint64_t v16 = v34;
    **(void **)(a1 + 80) = cf2;
  }
  else
  {
    if (v34 != *v16) {
      goto LABEL_13;
    }
    uint64_t v17 = *(CFTypeRef **)(a1 + 80);
    CFTypeRef v18 = *v17;
    if (*v17 != cf2 && (!v18 || !cf2 || !CFEqual(v18, cf2))) {
      goto LABEL_13;
    }
  }
  int v19 = *v11;
  if (*v11 == 1 && **(void **)(a1 + 88) > **(void **)(a1 + 96) && **(double **)(a1 + 104) != v31)
  {
LABEL_13:
    **(unsigned char **)(a1 + 56) = 1;
    *uint64_t v10 = 1;
    goto LABEL_14;
  }
  **(double **)(a1 + 112) = v32 + **(double **)(a1 + 112);
  long long v20 = *(double **)(a1 + 120);
  double v21 = *v20;
  if (*v20 < v30) {
    double v21 = v30;
  }
  double *v20 = v21;
  if (v19)
  {
    double v22 = v31;
    char v23 = *(double **)(a1 + 104);
  }
  else
  {
    char v23 = *(double **)(a1 + 104);
    double v22 = v31;
    if (v31 >= *v23) {
      double v22 = *v23;
    }
  }
  double *v23 = v22;
  CGFloat v24 = *(double **)(a1 + 128);
  double v25 = *v24;
  if (*v24 < v29) {
    double v25 = v29;
  }
  double *v24 = v25;
  *uint64_t v9 = 1;
  uint64_t v26 = *(void **)(a1 + 96);
  uint64_t v27 = v26[1];
  if (**(void **)(a1 + 88) == v27 + *v26) {
    v26[1] = v27 + 1;
  }
LABEL_14:
  TAttributes::~TAttributes((TAttributes *)v35);
}

uint64_t GetDecorationAttributes(atomic_ullong *a1, uint64_t a2, const __CFString **a3, TAttributes *this, int a5, int *a6, void *a7, double *a8, double a9, double a10, double *a11, double *a12, double *a13, BOOL *a14)
{
  uint64_t v23 = *((void *)this + 15);
  if (a5 != 1)
  {
    if (v23)
    {
      CGFloat v24 = (int *)(v23 + 56);
      goto LABEL_6;
    }
LABEL_11:
    uint64_t result = 0;
    *a6 = 0;
    return result;
  }
  if (!v23) {
    goto LABEL_11;
  }
  CGFloat v24 = (int *)(v23 + 60);
LABEL_6:
  int v25 = *v24;
  *a6 = *v24;
  if (!v25) {
    return 0;
  }
  if (a5 != 1 && !*a14)
  {
    if ((**(unsigned char **)(atomic_load_explicit((atomic_ullong *volatile)this + 2, memory_order_acquire) + 40) & 1) == 0)
    {
      BOOL v26 = 0;
LABEL_28:
      *a14 = v26;
      goto LABEL_29;
    }
    *(double *)&id v87 = -3.72066208e-103;
    LanguageIdentifierByNormalizing((__CFString *)atomic_load_explicit((atomic_ullong *volatile)this + 3, memory_order_acquire), 1u, (atomic_ullong *)&v87);
    if (!atomic_load_explicit((atomic_ullong *volatile)&v87, memory_order_acquire)) {
      goto LABEL_27;
    }
    double v29 = (__CFString *)(id)atomic_load_explicit((atomic_ullong *volatile)&v87, memory_order_acquire);
    double v30 = v29;
    if (v29 != @"ja" && (!v29 || !CFEqual(v29, @"ja")))
    {
      double v31 = (__CFString *)(id)atomic_load_explicit((atomic_ullong *volatile)&v87, memory_order_acquire);
      if (v31 != @"ko")
      {
        if (v31)
        {
          CGFloat v81 = v31;
          int v82 = CFEqual(v31, @"ko");

          if (!v82) {
            goto LABEL_27;
          }
LABEL_25:

          BOOL v26 = 1;
          goto LABEL_28;
        }

LABEL_27:
        BOOL v26 = TAttributes::GetCompositionLanguage(this, v32) == 2;
        goto LABEL_28;
      }
    }
    goto LABEL_25;
  }
  if (a5 == 1)
  {
    StrikethroughColor = TAttributes::GetStrikethroughColor(this, a2, a3);
    goto LABEL_30;
  }
LABEL_29:
  StrikethroughColor = TAttributes::GetUnderlineColor(this, a2, a3);
LABEL_30:
  *a7 = StrikethroughColor;
  v88.locatioCFIndex n = a2;
  v88.uint64_t length = (CFIndex)a3;
  double Width = TStorageRange::GetWidth((TStorageRange *)(a1 + 24), v88);
  double v34 = 0.0;
  if (!a2)
  {
    double v35 = (double *)a1[39];
    if (!v35) {
      double v35 = (double *)MEMORY[0x1E4F1DB30];
    }
    double v34 = *v35;
  }
  *a8 = Width + v34;
  id v84 = 0;
  if (a5 == 1)
  {
    TAttributes::OriginalFont((atomic_ullong *)this, (atomic_ullong *)&v87);

    uint64_t v36 = *(int **)(atomic_load_explicit((atomic_ullong *volatile)&v84, memory_order_acquire) + 40);
    *a11 = TFont::GetStrikethroughPositionAndThickness((TFont *)v36);
    *(void *)a12 = v42;
    double v41 = 0.0;
    if ((*(unsigned char *)v36 & 1) == 0) {
      goto LABEL_43;
    }
  }
  else
  {
    uint64_t v36 = *(int **)(atomic_load_explicit(a1 + 7, memory_order_acquire) + 40);
    *a11 = TFont::GetUnderlinePositionAndThickness((TFont *)v36);
    *(void *)a12 = v37;
    if ((*(unsigned char *)v36 & 1) == 0) {
      goto LABEL_43;
    }
    BOOL v38 = v36 + 12;
    initeCGFloat d = v36 + 12;
    if (!v36[12]) {
      initeCGFloat d = TFont::InitStrikeMetrics((TFont *)v36);
    }
    double v40 = *((double *)inited + 1);
    if (!*v38) {
      BOOL v38 = TFont::InitStrikeMetrics((TFont *)v36);
    }
    double v41 = (v40 + *((double *)v38 + 2)) * -0.5;
  }
  *a11 = v41;
LABEL_43:
  uint64_t v43 = *((void *)this + 15);
  if (v43) {
    double v44 = *(double *)(v43 + 48);
  }
  else {
    double v44 = 0.0;
  }
  *a11 = v44 + *a11;
  if ((*(unsigned char *)v36 & 1) == 0)
  {
    double v86 = NAN;
    *(double *)&id v87 = NAN;
    double v85 = NAN;
    TFont::GetDefaultMetrics((TFont *)v36, (double *)&v87, &v86, &v85);
    int v45 = *a6;
    double v46 = (double)(*a6 & 7);
    if (a5)
    {
      *a11 = *a11 * a9;
      double v47 = v46 * a9 * *a12;
      *a12 = v47;
      double v48 = *a11;
      if (*a11 > 1.0 && v47 > 0.35)
      {
        *a12 = ceil(v47);
        char v49 = vcvtpd_s64_f64(v47);
        double v50 = a9 * a10 - floor(a9 * a10);
        double v51 = floor(*a11 + 0.5);
        double v52 = floor(*a11) + 0.5;
        if ((v49 & 1) == 0) {
          double v52 = v51;
        }
        double v48 = v52 - v50;
      }
      *a11 = v48 / a9;
      double v53 = *a12 / a9;
      *a12 = v53;
      BOOL v54 = (v45 & 8) == 0;
      goto LABEL_55;
    }
    double v56 = (v86 + *(double *)&v87) * 0.25;
    if (v86 >= 2.0) {
      double v56 = v86;
    }
    double v57 = v56 * 5.3636991;
    if (v56 * 5.3636991 > v86 + *(double *)&v87) {
      double v57 = v86 + *(double *)&v87;
    }
    double v58 = *a11;
    if (*a11 >= 0.0) {
      double v58 = v57 * -0.0880554625;
    }
    *a11 = -(a9 * v58);
    double v59 = *a12 * a9;
    double v60 = v56 * a9;
    double v61 = v59 * v46;
    *a12 = v59 * v46;
    if ((v45 & 8) != 0)
    {
      *a12 = v61 * 0.75;
      *a11 = v61 * 0.75 * 0.5 + *a11;
      if (v60 < 4.0 || *a12 <= 0.35)
      {
        *a12 = v60 * 0.25;
        double v69 = v60 * 0.25 * 2.5;
      }
      else
      {
        double v71 = *a12 + -0.5;
        *a12 = ceil(v71);
        char v72 = vcvtpd_s64_f64(v71);
        double v73 = a9 * a10 - floor(a9 * a10);
        double v74 = floor(*a11 + 0.5);
        double v75 = floor(*a11) + 0.5;
        if ((v72 & 1) == 0) {
          double v75 = v74;
        }
        double v69 = v73 + v75;
        *a11 = v69;
        if (v69 > 1.5)
        {
          double v55 = *a12;
          double v70 = 3.0;
          if (*a12 < 2.0 || v69 >= 3.0 && (v60 < 7.0 || v69 > 3.0)) {
            goto LABEL_98;
          }
        }
        double v69 = v69 + 1.0;
      }
      *a11 = v69;
      double v55 = *a12;
      double v70 = 3.0;
    }
    else if (v60 < 2.0 || v61 <= 0.35)
    {
      double v69 = *a11;
      double v55 = 0.0;
      double v70 = 1.0;
    }
    else
    {
      double v62 = ceil(v61);
      *a12 = v62;
      if (v62 >= v60
        || (v60 <= 4.0 ? (BOOL v63 = v62 < 3.0) : (BOOL v63 = 1), !v63 || (v60 <= 2.5 ? (v64 = v62 < 2.0) : (v64 = 1), !v64)))
      {
        double v62 = v62 + -1.0;
        *a12 = v62;
      }
      int v65 = (int)v62;
      double v66 = a9 * a10 - floor(a9 * a10);
      double v67 = floor(*a11 + 0.5);
      double v68 = floor(*a11) + 0.5;
      if ((v65 & 1) == 0) {
        double v68 = v67;
      }
      double v69 = v66 + v68;
      *a11 = v69;
      if (v69 < 1.5 || (double v55 = 0.0, v70 = 1.0, v60 > 4.0) && v69 <= 1.5)
      {
        double v70 = 1.0;
        double v69 = v69 + 1.0;
        *a11 = v69;
        double v55 = 0.0;
      }
    }
LABEL_98:
    double v76 = v44 * a9;
    double v77 = v70 * *a12;
    if (v60 > 0.0)
    {
      double v78 = floor(v60 - v76) + v77 * -0.5;
      if (v78 < v69) {
        double v69 = v78;
      }
    }
    double v79 = ceil(v59 - v76) + v77 * 0.5;
    if (v69 >= v79) {
      double v79 = v69;
    }
    *a11 = v79 / -a9;
    double v80 = v57 * v46 * 0.0440277313;
    if (*a12 / a9 > 0.0) {
      double v80 = *a12 / a9;
    }
    *a12 = v80;
    goto LABEL_58;
  }
  double v53 = *a12;
  BOOL v54 = (v25 & 8) == 0;
LABEL_55:
  if (v54) {
    double v55 = 0.0;
  }
  else {
    double v55 = v53;
  }
LABEL_58:
  *a13 = v55;

  return 1;
}

double TStorageRange::GetWidth(TStorageRange *this, CFRange a2)
{
  double __C = NAN;
  uint64_t v2 = *((void *)this + 3);
  uint64_t v3 = *(void *)(v2 + 32);
  if (v3 || (uint64_t v5 = *(void *)(v2 + 24)) == 0)
  {
    uint64_t v4 = (const double *)(v3 + 16 * *((void *)this + 1) + 16 * a2.location);
    a2.locatioCFIndex n = 2;
  }
  else
  {
    uint64_t v4 = (const double *)(v5 + 8 * *((void *)this + 1) + 8 * a2.location);
    a2.locatioCFIndex n = 1;
  }
  vDSP_sveD(v4, a2.location, &__C, a2.length);
  return __C;
}

double TFont::GetUnderlinePositionAndThickness(TFont *this)
{
  uint64_t v2 = *((void *)this + 50);
  *(void *)&long long v3 = -1;
  *((void *)&v3 + 1) = -1;
  *(_OWORD *)&v10.c = v3;
  *(_OWORD *)&v10.tdouble x = v3;
  *(_OWORD *)&v10.CGFloat a = v3;
  TFont::GetScaledMatrix(this, &v10);
  double v4 = (*(double (**)(uint64_t, CGAffineTransform *))(*(void *)v2 + 584))(v2, &v10);
  if ((*(double (**)(uint64_t, CGAffineTransform *))(*(void *)v2 + 592))(v2, &v10) <= 0.0)
  {
    uint64_t v5 = (int *)((char *)this + 48);
    initeCGFloat d = (int *)((char *)this + 48);
    if (!*((_DWORD *)this + 12)) {
      initeCGFloat d = TFont::InitStrikeMetrics(this);
    }
    double v7 = *((double *)inited + 2);
    if (!*v5) {
      uint64_t v5 = TFont::InitStrikeMetrics(this);
    }
    double v8 = ceil(v7 + *((double *)v5 + 3)) * 5.3636991;
    if (v4 >= 0.0) {
      return v8 * -0.0880554625;
    }
  }
  return v4;
}

void std::vector<double,TInlineBufferAllocator<double,6ul>>::__destroy_vector::operator()[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  if (v2)
  {
    *(void *)(a1 + 8) = v2;
    long long v3 = (void *)(a1 + 72);
    if (a1 + 24 <= (unint64_t)v2)
    {
      BOOL v4 = v3 >= v2;
      BOOL v5 = v3 == v2;
    }
    else
    {
      BOOL v4 = 0;
      BOOL v5 = 0;
    }
    if (!v5 && v4)
    {
      if (*(void *)(a1 + 16) == *(void *)(a1 + 72)) {
        *long long v3 = v2;
      }
    }
    else
    {
      operator delete(v2);
    }
  }
}

CGFloat TSplicedFontDict::GetUnderlineThickness(atomic_ullong *this, double a2, const CGAffineTransform *a3)
{
  CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit(this, memory_order_acquire);
  if (explicit)
  {
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(explicit, @"FontMetrics");
    if (Value)
    {
      CFDictionaryRef v7 = Value;
      if (CFDictionaryGetCount(Value) >= 1)
      {
        CFStringRef v8 = (const __CFString *)CFDictionaryGetValue(v7, @"underlineThickness");
        if (v8) {
          return a3->ty + CFStringGetDoubleValue(v8) * a3->d + a3->b * 0.0;
        }
      }
    }
  }
  return a2;
}

CGFloat TSplicedFontDict::GetUnderlinePosition(atomic_ullong *this, double a2, const CGAffineTransform *a3)
{
  CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit(this, memory_order_acquire);
  if (explicit)
  {
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(explicit, @"FontMetrics");
    if (Value)
    {
      CFDictionaryRef v7 = Value;
      if (CFDictionaryGetCount(Value) >= 1)
      {
        CFStringRef v8 = (const __CFString *)CFDictionaryGetValue(v7, @"underlinePosition");
        if (v8) {
          return a3->ty + CFStringGetDoubleValue(v8) * a3->d + a3->b * 0.0;
        }
      }
    }
  }
  return a2;
}

CGFloat TComponentFont::GetUnderlineThickness(TComponentFont *this, const CGAffineTransform *a2)
{
  long long v3 = (atomic_ullong *)((char *)this + 720);
  TBaseFont::GetInitializedGraphicsFont(this);
  CGFontGetUnderlineThickness();
  double v5 = a2->ty + v4 * a2->d + a2->b * 0.0;

  return TSplicedFontDict::GetUnderlineThickness(v3, v5, a2);
}

CGFloat TComponentFont::GetUnderlinePosition(TComponentFont *this, const CGAffineTransform *a2)
{
  long long v3 = (atomic_ullong *)((char *)this + 720);
  TBaseFont::GetInitializedGraphicsFont(this);
  CGFontGetUnderlinePosition();
  double v5 = a2->ty + v4 * a2->d + a2->b * 0.0;

  return TSplicedFontDict::GetUnderlinePosition(v3, v5, a2);
}

void TAttributes::SetStrokeColor(TAttributes *this, void *cf, const void *a3)
{
  if (!cf)
  {
    if (qword_1EB2CE328 != -1) {
      dispatch_once_f(&qword_1EB2CE328, 0, (dispatch_function_t)GetBlackColor(void)::$_0::__invoke);
    }
    uint64_t v6 = (CGColor *)qword_1EB2CE320;
    CFDictionaryRef v7 = this;
    goto LABEL_9;
  }
  CFTypeID v5 = CFGetTypeID(cf);
  if (v5 == CFNullGetTypeID()) {
    return;
  }
  if (v5 == CGColorGetTypeID())
  {
    CFDictionaryRef v7 = this;
    uint64_t v6 = (CGColor *)cf;
LABEL_9:
    CGContextSetStrokeColorWithColor(v7, v6);
    return;
  }

  SetStrokeNSColor(this, cf);
}

void TDecorator::dashes(TDecorator *this, unsigned int a2, double a3)
{
  v24[1] = *MEMORY[0x1E4F143B8];
  *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)((char *)this + 56) = v5;
  *(_OWORD *)((char *)this + 40) = v5;
  *(_OWORD *)((char *)this + 24) = v5;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = 0;
  *((void *)this + 9) = (char *)this + 24;
  switch((a2 >> 8) & 7)
  {
    case 1u:
      uint64_t v6 = (char *)&v22;
      v24[0] = &v22;
      long long v20 = &v22;
      __asm { FMOV            V0.2D, #3.0 }
      goto LABEL_4;
    case 2u:
      uint64_t v6 = (char *)&v22;
      v24[0] = &v22;
      long long v20 = &v22;
      _Q0 = xmmword_184BA6100;
LABEL_4:
      long long v21 = _Q0;
      CFTypeRef v18 = &v21;
      int v19 = &v22;
      unint64_t v12 = 2;
      goto LABEL_7;
    case 3u:
      uint64_t v6 = (char *)&v23;
      v24[0] = &v23;
      int v19 = &v23;
      long long v20 = &v23;
      long long v21 = xmmword_184BA62C8;
      long long v22 = unk_184BA62D8;
      CFTypeRef v18 = &v21;
      unint64_t v12 = 4;
      goto LABEL_7;
    case 4u:
      uint64_t v6 = (char *)v24;
      v24[0] = v24;
      int v19 = (long long *)v24;
      long long v20 = (long long *)v24;
      long long v21 = xmmword_184BA62E8;
      long long v22 = unk_184BA62F8;
      long long v23 = xmmword_184BA6308;
      CFTypeRef v18 = &v21;
      unint64_t v12 = 6;
LABEL_7:
      std::vector<double,TInlineBufferAllocator<double,6ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<double const*>,std::__wrap_iter<double const*>>((void **)this, (char *)&v21, v6, v12);
      std::vector<double,TInlineBufferAllocator<double,6ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v18);
      break;
    default:
      break;
  }
  uint64_t v13 = *(void *)this;
  uint64_t v14 = *((void *)this + 1);
  uint64_t v15 = v14 - *(void *)this;
  if (v14 != *(void *)this)
  {
    uint64_t v16 = 0;
    unint64_t v17 = v15 >> 3;
    do
    {
      *(double *)(v13 + 8 * v16) = *(double *)(v13 + 8 * v16) * a3;
      ++v16;
    }
    while (v17 > v16);
  }
}

void SetStrokeNSColor(CGContext *a1, id a2)
{
  long long v3 = (CGColor *)objc_msgSend(a2, sel_CGColor);

  CGContextSetStrokeColorWithColor(a1, v3);
}

uint64_t TRun::GetLeftWhitespaceGlyphCountAndWidth(TRun *this)
{
  double v1 = (double *)MEMORY[0x1E4F1DB30];
  if (*((void *)this + 39)) {
    double v1 = (double *)*((void *)this + 39);
  }
  uint64_t v2 = *((void *)this + 26);
  long long v3 = (void *)*((void *)this + 27);
  uint64_t v4 = v3[4];
  if (v4 || (uint64_t v8 = v3[3]) == 0)
  {
    int v5 = 0;
    uint64_t v6 = *((void *)this + 25);
    CFDictionaryRef v7 = (double *)(v4 + 16 * v6);
  }
  else
  {
    uint64_t v6 = *((void *)this + 25);
    CFDictionaryRef v7 = (double *)(v8 + 8 * v6);
    int v5 = 1;
  }
  double v9 = *v1;
  if (v2 < 1) {
    return 0;
  }
  uint64_t v10 = 0;
  uint64_t v11 = v3[5] + 4 * v6;
  for (uint64_t i = v7; ; i += 2)
  {
    int v13 = *(_DWORD *)(v11 + 4 * v10);
    if ((v13 & 0x20) == 0
      && (*(_DWORD *)(v11 + 4 * v10) & 5) != 1
      && ((v13 & 0x1040) == 0 || (*((unsigned char *)this + 224) & 1) == 0))
    {
      break;
    }
    if (v5) {
      uint64_t v15 = v7;
    }
    else {
      uint64_t v15 = i;
    }
    double v9 = v9 + *v15;
    ++v10;
    ++v7;
    if (v2 == v10) {
      return *((void *)this + 26);
    }
  }
  return v10;
}

CGFloat TBaseFont::GetUnderlineThickness(TBaseFont *this, const CGAffineTransform *a2)
{
  TBaseFont::GetInitializedGraphicsFont(this);
  CGFontGetUnderlineThickness();
  return a2->ty + v3 * a2->d + a2->b * 0.0;
}

CGFloat TBaseFont::GetUnderlinePosition(TBaseFont *this, const CGAffineTransform *a2)
{
  TBaseFont::GetInitializedGraphicsFont(this);
  CGFontGetUnderlinePosition();
  return a2->ty + v3 * a2->d + a2->b * 0.0;
}

uint64_t TFont::GetSystemUIFontOptions(void)::$_0::__invoke()
{
  qword_1EB2CE038 = 1024;
  uint64_t result = dyld_program_sdk_at_least();
  if ((result & 1) == 0) {
    qword_1EB2CE038 |= 2uLL;
  }
  return result;
}

CFTypeID CTFontDescriptorGetTypeID(void)
{
  if (TCFBase<TDescriptor>::GetTypeID(void)::once != -1) {
    dispatch_once_f(&TCFBase<TDescriptor>::GetTypeID(void)::once, 0, (dispatch_function_t)TCFBase<TDescriptor>::GetTypeID(void)::{lambda(void *)#1}::__invoke);
  }
  return TCFBase<TDescriptor>::fTypeID;
}

uint64_t TCFBase<TNativeParagraphStyle>::GetTypeID(void)::{lambda(void *)#1}::__invoke()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB2CE3C0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB2CE3C0))
  {
    qword_1EB2CE3C8 = 0;
    unk_1EB2CE3D0 = "CTParagraphStyle";
    qword_1EB2CE3D8 = 0;
    unk_1EB2CE3E0 = 0;
    qword_1EB2CE3E8 = (uint64_t)TCFBase<TNativeParagraphStyle>::ClassDestruct;
    qword_1EB2CE3F0 = (uint64_t)TCFBase<TNativeParagraphStyle>::ClassEqual;
    qword_1EB2CE3F8 = (uint64_t)TCFBase<TNativeParagraphStyle>::ClassHash;
    unk_1EB2CE400 = 0;
    qword_1EB2CE408 = (uint64_t)TCFBase<TNativeParagraphStyle>::ClassDebug;
    unk_1EB2CE410 = 0;
    qword_1EB2CE418 = 0;
    unk_1EB2CE420 = 0;
    __cxa_guard_release(&qword_1EB2CE3C0);
  }
  uint64_t result = _CFRuntimeRegisterClass();
  qword_1EB2CE3B8 = result;
  return result;
}

double CTRunGetInitialAdvance(uint64_t a1)
{
  if (!a1) {
    return *MEMORY[0x1E4F1DB30];
  }
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = (double *)MEMORY[0x1E4F1DB30];
  if (*(void *)(v1 + 312)) {
    uint64_t v2 = *(double **)(v1 + 312);
  }
  double v3 = *v2;
  if ((*(unsigned char *)(v1 + 225) & 0x10) != 0)
  {
    uint64_t v4 = *(void *)(v1 + 208);
    if (v4 >= 1)
    {
      uint64_t v5 = 0;
      uint64_t v6 = *(void **)(v1 + 216);
      uint64_t v7 = *(void *)(v1 + 200);
      while (*(__int16 *)(v6[2] + 2 * v7 + 2 * v5) == -1 && v5 != *(void *)(v1 + 264))
      {
        if (v4 == ++v5) {
          return v3;
        }
      }
      [v6 originAtIndex:v7 + v5];
      return v3 + v8;
    }
  }
  return v3;
}

void CreateCopyOfArrayByApplyingFunction(__CFArray const*,std::function<TCFRef<void const*> ()(void const*)>)::$_0::__invoke(void *a1, uint64_t a2)
{
  v8[0] = (id)0xAAAAAAAAAAAAAAAALL;
  uint64_t v3 = *(void *)(*(void *)(a2 + 8) + 24);
  v8[1] = a1;
  if (v3)
  {
    (*(void (**)(id *__return_ptr))(*(void *)v3 + 48))(v8);
    if (atomic_load_explicit((atomic_ullong *volatile)v8, memory_order_acquire))
    {
      uint64_t v5 = *(atomic_ullong **)a2;
      id v6 = (id)atomic_load_explicit((atomic_ullong *volatile)v8, memory_order_acquire);
      CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit(v5, memory_order_acquire), v6);
    }
  }
  else
  {
    uint64_t v7 = std::__throw_bad_function_call[abi:nn180100]();
    std::__function::__func<CreateNormalizedLanguages(__CFArray const*)::$_0,std::allocator<CreateNormalizedLanguages(__CFArray const*)::$_0>,TCFRef<void const*> ()(void const*)>::operator()(v7);
  }
}

void std::__function::__func<CreateNormalizedLanguages(__CFArray const*)::$_0,std::allocator<CreateNormalizedLanguages(__CFArray const*)::$_0>,TCFRef<void const*> ()(void const*)>::operator()(__CFString **a1@<X1>, void *a2@<X8>)
{
  LanguageIdentifierByNormalizing(*a1, 1u, (atomic_ullong *)&v3);
  *a2 = atomic_exchange((atomic_ullong *volatile)&v3, 0);
}

double CTFontGetTransformedAdvancesForGlyphsAndStyle(uint64_t a1, int a2, unsigned int a3, double *a4, _WORD *a5, uint64_t a6, unint64_t a7)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  double v7 = 0.0;
  if (a1 && a5)
  {
    double v10 = *(double *)&a6;
    if (a4 || a7 != 1)
    {
      *(void *)&long long v16 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v21[28] = v16;
      v21[29] = v16;
      v21[26] = v16;
      v21[27] = v16;
      v21[24] = v16;
      v21[25] = v16;
      v21[22] = v16;
      v21[23] = v16;
      v21[20] = v16;
      v21[21] = v16;
      v21[18] = v16;
      v21[19] = v16;
      v21[16] = v16;
      v21[17] = v16;
      v21[15] = v16;
      v21[14] = v16;
      v21[13] = v16;
      v21[12] = v16;
      v21[11] = v16;
      v21[10] = v16;
      v21[9] = v16;
      v21[8] = v16;
      v21[7] = v16;
      v21[6] = v16;
      v21[4] = v16;
      v21[5] = v16;
      v21[2] = v16;
      v21[3] = v16;
      v21[0] = v16;
      v21[1] = v16;
      memset(v20, 0, sizeof(v20));
      long long v22 = v21;
      if (*(double *)&a6 == 0.0)
      {
        std::vector<CGSize,TInlineBufferAllocator<CGSize,30ul>>::resize((uint64_t)v20, a7);
        double v10 = v20[0];
      }
      TFont::GetAdvancesForGlyphs(*(void *)(a1 + 40), (uint64_t)a5, *(double **)&v10, 2, a7, a2, a3 | 0x100000000, a4);
      double v7 = v17;
      int v19 = (void **)v20;
      std::vector<CGPoint,TInlineBufferAllocator<CGPoint,30ul>>::__destroy_vector::operator()[abi:nn180100](&v19);
    }
    else
    {
      uint64_t v15 = *(void *)(a1 + 40);
      LOWORD(v19) = *a5;
      v20[0] = NAN;
      TFont::GetUnsummedAdvancesForGlyphs(v15, (uint64_t)&v19, v20, 1, 1, a2, a3 | 0x100000000);
      double v7 = v20[0];
      if (v10 != 0.0)
      {
        **(void **)&double v10 = *(void *)&v20[0];
        *(void *)(*(void *)&v10 + 8) = 0;
      }
    }
  }
  return v7;
}

CFSetRef TDescriptor::TDescriptor(TDescriptor const&,__CFDictionary const*)::$_0::__invoke()
{
  v1[3] = *(const void **)MEMORY[0x1E4F143B8];
  v1[0] = @"NSCTFontFeatureSettingsAttribute";
  v1[1] = @"NSFontSizeAttribute";
  v1[2] = @"NSCTFontOpticalSizeAttribute";
  CFSetRef result = CFSetCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v1, 3, MEMORY[0x1E4F1D548]);
  qword_1EB2CE0B8 = (uint64_t)result;
  return result;
}

uint64_t TCombiningEngine::ResolveCombiningMarks(void ****a1, int a2, unsigned char *a3, char *a4)
{
  uint64_t v5 = a1;
  uint64_t v363 = *MEMORY[0x1E4F143B8];
  id v6 = *a1;
  uint64_t v7 = (uint64_t)(*a1)[5];
  if (v7 == -1)
  {
    TRunGlue::ComputeEndIndex(*a1);
    uint64_t v7 = (uint64_t)v6[5];
  }
  uint64_t v8 = (uint64_t)v6[6];
  if (v8 >= 1)
  {
    if (a2 == 1) {
      int v9 = -1;
    }
    else {
      int v9 = 1;
    }
    if (a2 == 1) {
      int v10 = 0;
    }
    else {
      int v10 = a2;
    }
    int v312 = v9;
    char v311 = -86;
    if (!v10)
    {
      if (a3) {
        *a3 = 1;
      }
      uint64_t v11 = a4;
      if (!a4) {
        uint64_t v11 = &v311;
      }
      a4 = v11;
    }
    int v300 = 0;
    uint64_t v12 = v8 + v7;
    v301 = (uint64_t *)v5;
    int v302 = v10;
    uint64_t v303 = v8 + v7;
    while (1)
    {
      BOOL v310 = -86;
      uint64_t NextUncombinedCharRange = TRunGlue::GetNextUncombinedCharRange((TLine **)*v5, v7, &v310, &v312);
      if (NextUncombinedCharRange >= v12) {
        goto LABEL_550;
      }
      uint64_t v15 = NextUncombinedCharRange;
      uint64_t v16 = v14;
      if (v14 <= 1 && (v310 || v14 != 1))
      {
        uint64_t v7 = v14 + NextUncombinedCharRange + 1;
        goto LABEL_144;
      }
      double v17 = (TLine **)*v5;
      CFTypeRef v18 = (*v5)[5];
      if (v18 == (void **)-1)
      {
        TRunGlue::ComputeEndIndex(*v5);
        CFTypeRef v18 = (void **)v17[5];
      }
      uint64_t v7 = v15 + v16;
      int v19 = (char *)v18 + (void)v17[6];
      if (v15 + v16 >= (uint64_t)v19) {
        long long v20 = (char *)v18 + (void)v17[6];
      }
      else {
        long long v20 = (char *)(v15 + v16);
      }
      long long v21 = (char *)(v20 - (char *)v18);
      BOOL v22 = v15 <= (uint64_t)v18 && (uint64_t)v18 < v7;
      if (v22) {
        uint64_t v23 = (uint64_t)v18;
      }
      else {
        uint64_t v23 = 0;
      }
      if (!v22) {
        long long v21 = 0;
      }
      CGFloat v24 = &v20[-v15];
      BOOL v25 = (uint64_t)v18 <= v15 && v15 < (uint64_t)v19;
      uint64_t v26 = v25 ? v15 : v23;
      uint64_t v27 = v25 ? v24 : v21;
      if (v26 != v15 || v27 != (char *)v16) {
        goto LABEL_550;
      }
      if (v10 == 2
        && v310
        && (TCharStream::GetClusterRangeForRange((uint64_t)v5[1], v15, v16, 2) != v15 || v28 != v16))
      {
        goto LABEL_144;
      }
      uint64_t v304 = v15 + v16;
      *(void *)&long long v29 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v29 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v336[2] = v29;
      v336[3] = v29;
      v336[0] = v29;
      v336[1] = v29;
      memset(v335, 0, sizeof(v335));
      v337 = v336;
      uint64_t v30 = TCharStream::LazyCopyChars(v5[1], v15, v16);
      if (!v30)
      {
        *(void *)unint64_t v338 = v335;
        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v338);
        goto LABEL_550;
      }
      uint64_t v31 = v30;
      *(void *)&long long v32 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v32 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v333[13] = v32;
      v333[14] = v32;
      v333[11] = v32;
      v333[12] = v32;
      v333[9] = v32;
      v333[10] = v32;
      v333[7] = v32;
      v333[8] = v32;
      v333[5] = v32;
      v333[6] = v32;
      v333[3] = v32;
      v333[4] = v32;
      v333[1] = v32;
      v333[2] = v32;
      v333[0] = v32;
      int v331 = 0;
      unint64_t v332 = 0;
      uint64_t v330 = 0;
      v334 = v333;
      TRunGlue::GetMappedCharsInRange((uint64_t)*v5, v15, v16, &v330);
      uint64_t v33 = v330;
      uint64_t v309 = v15;
      if (v10) {
        goto LABEL_103;
      }
      uint64_t v34 = 0;
      v305 = (TStorageRange *)v16;
      do
      {
        if (*(_WORD *)(v31 + 2 * v34) == 847)
        {
          double v35 = (void *)(v34 + v15);
          uint64_t v36 = v331;
          if (v33 != v331)
          {
            do
            {
              if (*(void **)v33 == v35) {
                goto LABEL_57;
              }
              v33 += 8;
            }
            while (v33 != v331);
            uint64_t v33 = v331;
          }
LABEL_57:
          if (v33 == v331)
          {
            uint64_t v37 = v330;
            uint64_t v38 = v331 - v330;
            if (v331 == v330)
            {
              double v40 = v331;
            }
            else
            {
              unint64_t v39 = v38 >> 3;
              double v40 = v330;
              do
              {
                unint64_t v41 = v39 >> 1;
                uint64_t v42 = &v40[8 * (v39 >> 1)];
                uint64_t v44 = *(void *)v42;
                uint64_t v43 = v42 + 8;
                v39 += ~(v39 >> 1);
                if (v44 < (uint64_t)v35) {
                  double v40 = v43;
                }
                else {
                  unint64_t v39 = v41;
                }
              }
              while (v39);
            }
            uint64_t v45 = v40 - v330;
            double v46 = &v330[(v40 - v330) & 0xFFFFFFFFFFFFFFF8];
            if ((unint64_t)v331 < v332)
            {
              uint64_t v15 = v309;
              if (v46 == v331)
              {
                *(void *)int v331 = v35;
                int v331 = v36 + 8;
                uint64_t v16 = (uint64_t)v305;
              }
              else
              {
                double v47 = v331 - 8;
                double v48 = v331;
                uint64_t v16 = (uint64_t)v305;
                if ((unint64_t)v331 >= 8)
                {
                  do
                  {
                    uint64_t v49 = *(void *)v47;
                    v47 += 8;
                    *(void *)double v48 = v49;
                    v48 += 8;
                  }
                  while (v47 < v36);
                }
                int v331 = v48;
                if (v36 != v46 + 8) {
                  memmove(&v36[-8 * ((v36 - (v46 + 8)) >> 3)], v46, v36 - (v46 + 8));
                }
                *(void *)double v46 = v35;
              }
LABEL_96:
              uint64_t v33 = v331;
              goto LABEL_97;
            }
            unint64_t v50 = (v38 >> 3) + 1;
            unint64_t v355 = 0xAAAAAAAAAAAAAAAALL;
            if (v50 >> 61) {
LABEL_552:
            }
              abort();
            if ((uint64_t)(v332 - (void)v330) >> 2 > v50) {
              unint64_t v50 = (uint64_t)(v332 - (void)v330) >> 2;
            }
            if (v332 - (unint64_t)v330 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v51 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v51 = v50;
            }
            *((void *)&v356[0] + 1) = v333;
            if (v51) {
              double v52 = (void **)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v333, v51);
            }
            else {
              double v52 = 0;
            }
            uint64_t v53 = v45 >> 3;
            v353 = v52;
            BOOL v54 = (char *)&v52[v45 >> 3];
            unint64_t v354 = (void **)v54;
            *(void *)&v356[0] = &v52[v51];
            if (v45 >> 3 == v51)
            {
              if (v45 >= 1)
              {
                if (v53 >= -1) {
                  unint64_t v55 = v53 + 1;
                }
                else {
                  unint64_t v55 = v53 + 2;
                }
                v54 -= 8 * (v55 >> 1);
                goto LABEL_89;
              }
              if (v40 == v37) {
                unint64_t v63 = 1;
              }
              else {
                unint64_t v63 = v45 >> 2;
              }
              *(void *)&v338[32] = v333;
              BOOL v64 = &v52[v51];
              v353 = (void **)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v333, v63);
              double v56 = &v353[v63 >> 2];
              *(void *)unint64_t v338 = v52;
              unint64_t v354 = v56;
              *(void *)&v338[8] = v54;
              *(void *)&v338[16] = v54;
              *(void *)&v356[0] = &v353[v63];
              *(void *)&v338[24] = v64;
              std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)v338);
              BOOL v54 = (char *)v354;
            }
            else
            {
LABEL_89:
              double v56 = (void **)v54;
            }
            char *v56 = v35;
            unint64_t v57 = (unint64_t)(v56 + 1);
            unint64_t v355 = v57;
            double v58 = (void **)v330;
            uint64_t v16 = (uint64_t)v305;
            uint64_t v15 = v309;
            if (v330 != v46)
            {
              double v59 = v46;
              do
              {
                uint64_t v60 = *((void *)v59 - 1);
                v59 -= 8;
                *((void *)v54 - 1) = v60;
                v54 -= 8;
              }
              while (v59 != (char *)v58);
            }
            unint64_t v354 = (void **)v54;
            double v61 = (char *)(v331 - v46);
            if (v331 != v46)
            {
              memmove((void *)v57, v46, v331 - v46);
              BOOL v54 = (char *)v354;
              double v46 = v331;
            }
            unint64_t v354 = v58;
            uint64_t v330 = v54;
            int v331 = &v61[v57];
            unint64_t v355 = (unint64_t)v46;
            unint64_t v62 = v332;
            unint64_t v332 = *(void *)&v356[0];
            *(void *)&v356[0] = v62;
            v353 = v58;
            std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v353);
            goto LABEL_96;
          }
        }
LABEL_97:
        ++v34;
      }
      while (v34 != v16);
      uint64_t v33 = v330;
      uint64_t v5 = (void ****)v301;
      int v10 = v302;
LABEL_103:
      int v65 = v331;
      if (v33 == v331) {
        goto LABEL_142;
      }
      do
      {
        uint64_t v66 = *(void *)v33;
        uint64_t v67 = *(void *)v33 - v15;
        if ((*(_WORD *)(v31 + 2 * v67) & 0xFC00) == 0xD800)
        {
          uint64_t v68 = v67 + 1;
          if (v68 == v16) {
            break;
          }
          if ((*(_WORD *)(v31 + 2 * v68) & 0xFC00) == 0xDC00)
          {
            v33 += 8;
            if (v33 == v65 || *(void *)v33 != v68)
            {
              *(void *)unint64_t v338 = v66 + 1;
              uint64_t v33 = std::vector<long,TInlineBufferAllocator<long,30ul>>::insert((uint64_t)&v330, v33, v338);
              int v65 = v331;
            }
          }
        }
        v33 += 8;
      }
      while (v33 != v65);
      double v69 = v330;
      if (v330 == v65)
      {
LABEL_142:
        uint64_t v12 = v303;
        uint64_t v7 = v304;
        goto LABEL_143;
      }
      if (v10)
      {
        if (v10 == 2)
        {
          *(void *)&long long v70 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v70 + 1) = 0xAAAAAAAAAAAAAAAALL;
          if (!v310)
          {
            uint64_t v71 = *(void *)v330;
            char v72 = **v5;
            uint64_t v73 = *(void *)(*((void *)v72[2] + TLine::FindRunWithCharIndex((TLine *)v72, *(void *)v330, 1)) + 48);
            double v74 = *(TFont **)(atomic_load_explicit((atomic_ullong *volatile)(v73 + 56), memory_order_acquire) + 40);
            LOWORD(v353) = *(_WORD *)(*(void *)(*(void *)(v73 + 216) + 16)
                                    + 2 * *(void *)(v73 + 200)
                                    + 2 * TRun::GetGlyphIndexForCharIndex<false>(v73, v71));
            *(void *)&long long v75 = -1;
            *((void *)&v75 + 1) = -1;
            *(_OWORD *)unint64_t v338 = v75;
            *(_OWORD *)&v338[16] = v75;
            v366.origin.double x = TFont::GetBoundingBoxesForGlyphs(v74, (const unsigned __int16 *)&v353, (CGRect *)v338, 1, kCTFontOrientationDefault);
            double MinX = CGRectGetMinX(v366);
            if (MinX < 0.0)
            {
              uint64_t GlyphIndexForChar = TRun::GetGlyphIndexForCharIndex<false>(v73, v71);
              uint64_t v78 = GlyphIndexForChar;
              uint64_t v79 = *(void *)(v73 + 216);
              uint64_t v80 = *(void *)(v79 + 32);
              if (v80 || (uint64_t v97 = *(void *)(v79 + 24)) == 0)
              {
                uint64_t v81 = v80 + 16 * *(void *)(v73 + 200) + 16 * GlyphIndexForChar;
                uint64_t v82 = *(void *)(v81 + 8);
              }
              else
              {
                uint64_t v81 = v97 + 8 * *(void *)(v73 + 200) + 8 * GlyphIndexForChar;
                uint64_t v82 = 0;
              }
              double v98 = *(double *)v81 - MinX;
              TStorageRange::SetAdvance((TStorageRange *)(v73 + 192), GlyphIndexForChar, *(CGSize *)(&v82 - 1));
              objc_msgSend(*(id *)(v73 + 216), "setOrigin:atIndex:", *(void *)(v73 + 200) + v78, -MinX, 0.0);
              if (*MEMORY[0x1E4F1DAD8] != -MinX || *(double *)(MEMORY[0x1E4F1DAD8] + 8) != 0.0) {
                *(unsigned char *)(v73 + 225) |= 0x10u;
              }
            }
            v300 |= MinX < 0.0;
            double v69 = v330;
            int v65 = v331;
            *(void *)&long long v70 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v70 + 1) = 0xAAAAAAAAAAAAAAAALL;
          }
          if ((unint64_t)(v65 - v69) >= 9)
          {
            long long v340 = v70;
            long long v341 = v70;
            *(_OWORD *)&v338[24] = v70;
            long long v339 = v70;
            memset(v338, 0, 24);
            *(void *)&long long v342 = &v338[24];
            CollectChars(v15, v16, v31, v69, v65, (char **)v338);
            v353 = (void **)0xAAAAAAAAAAAAAAAALL;
            v353 = **v5;
            v300 |= TGlyphComposer::ComposeGlyphs((TLine **)&v353, v15, (uint64_t)v338, &v330);
            v353 = (void **)v338;
            std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100](&v353);
          }
        }
        goto LABEL_142;
      }
      if (!v310 || v16 != (v65 - v330) >> 3)
      {
        LOBYTE(v95) = 0;
        int64x2_t v96 = a3;
        uint64_t v12 = v303;
        uint64_t v7 = v304;
        if (a3) {
          goto LABEL_544;
        }
        goto LABEL_143;
      }
      FontForCharIndedouble x = TRunGlue::GetFontForCharIndex((TLine **)*v5, v15);
      if (!FontForCharIndex)
      {
        LOBYTE(v95) = 0;
        uint64_t v12 = v303;
        uint64_t v7 = v304;
        goto LABEL_543;
      }
      uint64_t v84 = FontForCharIndex;
      *(void *)&long long v85 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v85 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v328[2] = v85;
      v328[3] = v85;
      v328[0] = v85;
      v328[1] = v85;
      uint64_t v326 = 0;
      uint64_t v327 = 0;
      uint64_t v325 = 0;
      v329 = v328;
      CollectChars(v15, v16, v31, v330, v331, &v325);
      *(void *)&long long v86 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v86 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v323[2] = v86;
      v323[3] = v86;
      v323[0] = v86;
      v323[1] = v86;
      unsigned int v321 = 0;
      uint64_t v322 = 0;
      unsigned int v324 = v323;
      v318[13] = v86;
      v318[14] = v86;
      v318[11] = v86;
      v318[12] = v86;
      v318[9] = v86;
      v318[10] = v86;
      v318[7] = v86;
      v318[8] = v86;
      v318[5] = v86;
      v318[6] = v86;
      v318[3] = v86;
      v318[4] = v86;
      v318[1] = v86;
      v318[2] = v86;
      v318[0] = v86;
      v316 = 0;
      uint64_t v317 = 0;
      v315 = 0;
      int v319 = v318;
      v320 = 0;
      uint64_t v87 = v326 - v325;
      if (v326 != v325)
      {
        std::vector<long,TInlineBufferAllocator<long,30ul>>::__vallocate[abi:nn180100](&v315, v87 >> 1);
        CFRange v88 = (char *)v316;
        bzero(v316, (4 * v87) & 0xFFFFFFFFFFFFFFF8);
        uint64_t v89 = &v88[4 * v87];
        v316 = v89;
        int64_t v90 = v315;
        if (v315 != v89)
        {
          uint64_t v91 = 0;
          do
          {
            *(void *)int64_t v90 = v91;
            v90 += 8;
            ++v91;
          }
          while (v90 != v89);
        }
      }
      unsigned int v92 = *(unsigned __int16 *)v325;
      uint64_t v12 = v303;
      uint64_t v7 = v304;
      if ((v92 & 0xFC00) == 0xD800)
      {
        if (v326 - v325 == 2) {
          goto LABEL_127;
        }
        int v99 = *((unsigned __int16 *)v325 + 1);
        BOOL v100 = (v99 & 0xFC00) == 56320;
        unsigned int v93 = v99 + (v92 << 10) - 56613888;
        if (!v100) {
          unsigned int v93 = *(unsigned __int16 *)v325;
        }
        uint64_t v94 = 2;
        if (!v100) {
          uint64_t v94 = 1;
        }
LABEL_150:
        if (v93 >= 0x900 && (v93 & 0xFFFFFFC0) != 69312) {
          goto LABEL_182;
        }
      }
      else
      {
        if (v92 < 0x600) {
          goto LABEL_182;
        }
        if (v92 >= 0x700)
        {
          if (v92 < 0x750) {
            goto LABEL_182;
          }
          if (v92 >= 0x780)
          {
            if (v92 >= 0x8A0)
            {
LABEL_127:
              unsigned int v93 = *(unsigned __int16 *)v325;
              uint64_t v94 = 1;
              goto LABEL_150;
            }
LABEL_182:
            unsigned int v110 = v312 >> 31;
            goto LABEL_183;
          }
        }
        uint64_t v94 = 1;
      }
      uint64_t v102 = (v326 - v325) >> 1;
      while (2)
      {
        if (v94 != v102)
        {
          uint64_t v103 = v94 + 1;
          unsigned int v104 = *(unsigned __int16 *)&v325[2 * v94];
          if ((v104 & 0xFC00) == 0xD800)
          {
            uint64_t v105 = (v326 - v325) >> 1;
            if (v103 != v102)
            {
              int v106 = *(unsigned __int16 *)&v325[2 * v103];
              BOOL v107 = (v106 & 0xFC00) == 56320;
              unsigned int v108 = (v104 << 10) - 56613888 + v106;
              uint64_t v105 = v107 ? v94 + 2 : v94 + 1;
              if (v107) {
                unsigned int v104 = v108;
              }
            }
LABEL_165:
            BOOL v109 = (v104 & 0xFFFFFFC0) == 69312;
            uint64_t v94 = v105;
LABEL_175:
            if (v104 != 847 && !v109) {
              goto LABEL_182;
            }
            continue;
          }
          if (v104 < 0x600)
          {
LABEL_171:
            BOOL v109 = 0;
          }
          else
          {
            if (v104 >= 0x700)
            {
              if (v104 < 0x750) {
                goto LABEL_171;
              }
              if (v104 >= 0x780)
              {
                if (v104 < 0x8A0) {
                  goto LABEL_171;
                }
                if (v104 >= 0x900)
                {
                  uint64_t v105 = v94 + 1;
                  goto LABEL_165;
                }
              }
            }
            BOOL v109 = 1;
          }
          ++v94;
          goto LABEL_175;
        }
        break;
      }
      if (v312 < 0)
      {
        long long v126 = &v325;
        if (DecomposeInitialChar(&v325, (uint64_t *)&v315, &v320))
        {
          int v127 = 1;
          *a4 = 1;
          long long v126 = &v320;
        }
        else
        {
          int v127 = 0;
        }
        if (ApplyModifiedCombiningClasses(v126, 1, &v315, (char *)&v320))
        {
          if (ComposeArabicDecompositions((uint64_t)&v320, &v315, (uint64_t)&v320)) {
            int v95 = 1;
          }
          else {
            int v95 = v127;
          }
          if (v316 != v315)
          {
            uint64_t v136 = 0;
            do
            {
              if (v136 != *(void *)&v315[8 * v136]) {
                goto LABEL_272;
              }
              ++v136;
            }
            while (((unsigned char *)v316 - v315) >> 3 != v136);
          }
        }
        else if (ComposeArabicDecompositions((uint64_t)v126, &v315, (uint64_t)&v320))
        {
          BOOL v137 = v321 - v320 == v326 - v325 && memcmp(v320, v325, v321 - v320) == 0;
          int v95 = !v137;
        }
        else
        {
          int v95 = 0;
        }
LABEL_204:
        if (v95)
        {
          unsigned int v297 = 0;
          goto LABEL_206;
        }
        goto LABEL_542;
      }
      unsigned int v110 = 0;
LABEL_183:
      if (v92 < 0x590 || v92 >= 0x600 && (unsigned __int16)(v92 + 1251) > 0x32u)
      {
LABEL_200:
        if (u_getIntPropertyValue(v92, UCHAR_HANGUL_SYLLABLE_TYPE))
        {
          LOBYTE(v95) = 0;
          goto LABEL_542;
        }
        int v95 = 0;
        if (TCharComposer::ComposeChars((uint64_t)v325, (v326 - v325) >> 1, (uint64_t)&v320, 0)) {
          int v95 = v321 - v320 < (unint64_t)(v326 - v325);
        }
        goto LABEL_204;
      }
      double v111 = v325 + 2;
      while (2)
      {
        if (v111 != v326)
        {
          unsigned int v112 = *(unsigned __int16 *)v111;
          if (v112 >= 0x590)
          {
            if (v112 >= 0x600)
            {
              BOOL v113 = (unsigned __int16)(v112 + 1251) < 0x33u;
              goto LABEL_192;
            }
          }
          else
          {
            BOOL v113 = 0;
LABEL_192:
            if (v112 != 847 && !v113) {
              goto LABEL_200;
            }
          }
          v111 += 2;
          continue;
        }
        break;
      }
      if (!v110) {
        goto LABEL_200;
      }
      uint64_t v115 = &v325;
      BOOL v116 = DecomposeInitialChar(&v325, (uint64_t *)&v315, &v320);
      if (v116)
      {
        int v295 = 1;
        *a4 = 1;
        uint64_t v115 = &v320;
      }
      else
      {
        int v295 = 0;
      }
      int v134 = ApplyModifiedCombiningClasses(v115, 0, &v315, (char *)&v320);
      char CanPositionHebrewMarks = FontCanPositionHebrewMarks((TBaseFont **)v84);
      if (!v134)
      {
        if (CanPositionHebrewMarks)
        {
          int v95 = v295;
        }
        else
        {
          if (v116) {
            CGFloat v144 = &v320;
          }
          else {
            CGFloat v144 = &v325;
          }
          int v95 = v295;
          if (TCombiningEngine::ComposeHebrewPresentationForms((uint64_t)v144, (uint64_t)&v320, *(void *)(v84 + 400)))
          {
            do
            {
              uint64_t v145 = v315 + 8;
              BOOL v146 = (char *)((unsigned char *)v316 - (v315 + 16));
              if (v316 != v315 + 16) {
                memmove(v315 + 8, v315 + 16, (unsigned char *)v316 - (v315 + 16));
              }
              v316 = &v146[(void)v145];
              if (v321 - v320 == v326 - v325)
              {
                int v147 = memcmp(v320, v325, v321 - v320);
                BOOL v148 = v147 == 0;
                if (v147) {
                  uint64_t v149 = &v320;
                }
                else {
                  uint64_t v149 = &v325;
                }
              }
              else
              {
                BOOL v148 = 0;
                uint64_t v149 = &v320;
              }
            }
            while ((TCombiningEngine::ComposeHebrewPresentationForms((uint64_t)v149, (uint64_t)&v320, *(void *)(v84 + 400)) & 1) != 0);
            int v95 = !v148;
          }
        }
        goto LABEL_204;
      }
      if (CanPositionHebrewMarks)
      {
        int v95 = v295;
      }
      else
      {
        int v95 = v295;
        if (TCombiningEngine::ComposeHebrewPresentationForms((uint64_t)&v320, (uint64_t)&v320, *(void *)(v84 + 400)))
        {
          do
          {
            AdjustIndexesForPairwiseComposition(&v315);
            BOOL v142 = v321 - v320 == v326 - v325 && memcmp(v320, v325, v321 - v320) == 0;
          }
          while ((TCombiningEngine::ComposeHebrewPresentationForms((uint64_t)&v320, (uint64_t)&v320, *(void *)(v84 + 400)) & 1) != 0);
          int v95 = !v142;
        }
      }
      if (v316 == v315) {
        goto LABEL_204;
      }
      uint64_t v143 = 0;
      while (v143 == *(void *)&v315[8 * v143])
      {
        if (((unsigned char *)v316 - v315) >> 3 == ++v143) {
          goto LABEL_204;
        }
      }
LABEL_272:
      unsigned int v297 = (uint64_t *)&v315;
LABEL_206:
      char v296 = v95;
      if ((*(uint64_t (**)(void))(**(void **)(v84 + 400) + 688))(*(void *)(v84 + 400)))
      {
        int v95 = 0;
        goto LABEL_541;
      }
      double v118 = v325;
      uint64_t v117 = v326;
      CFRange v119 = v321;
      *(void *)&long long v120 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v120 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v361[2] = v120;
      v361[3] = v120;
      v361[0] = v120;
      v361[1] = v120;
      v358 = 0;
      uint64_t v360 = 0;
      __int16 v359 = 0;
      v362 = v361;
      uint64_t v121 = v321 - v320;
      uint64_t v122 = (v321 - v320) >> 1;
      CFIndex v292 = v122;
      if (v321 == v320)
      {
        __n128 v125 = 0;
      }
      else
      {
        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__vallocate[abi:nn180100](&v358, (v321 - v320) >> 1);
        __n128 v123 = v359;
        bzero(v359, v121 & 0xFFFFFFFFFFFFFFFELL);
        __n128 v124 = &v123[2 * v292];
        uint64_t v122 = v292;
        __int16 v359 = v124;
        CFRange v119 = v320;
        __n128 v125 = v358;
      }
      uint64_t v128 = (*(uint64_t (**)(void, char *, _WORD *, uint64_t))(**(void **)(v84 + 400) + 664))(*(void *)(v84 + 400), v119, v125, v122);
      BOOL v290 = v297 != 0;
      BOOL v22 = v121 < 1;
      uint64_t v12 = v303;
      uint64_t v7 = v304;
      if (v22 || !v297 || v128 == v122)
      {
LABEL_226:
        if (v128 == v122) {
          goto LABEL_227;
        }
        *(void *)unint64_t v338 = &v358;
        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v338);
        int v95 = 0;
        int v10 = v302;
        goto LABEL_541;
      }
      uint64_t v129 = v358;
      uint64_t v130 = v320;
      if (v122 <= 1) {
        uint64_t v131 = 1;
      }
      else {
        uint64_t v131 = v122;
      }
      while (1)
      {
        if (!*v129 && *(_WORD *)v130 == 847)
        {
          *uint64_t v129 = -1;
          if (++v128 == v122) {
            break;
          }
        }
        v130 += 2;
        ++v129;
        if (!--v131) {
          goto LABEL_226;
        }
      }
LABEL_227:
      CFIndex v306 = v16;
      RunWithCharIndedouble x = -1;
      double v132 = **v5;
      if (v132)
      {
        RunWithCharIndedouble x = TLine::FindRunWithCharIndex((TLine *)**v5, v15, 1);
        uint64_t v133 = *(void *)(*((void *)v132[2] + RunWithCharIndex) + 48);
      }
      else
      {
        uint64_t v133 = 0;
      }
      *(void *)&long long v138 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v138 + 1) = 0xAAAAAAAAAAAAAAAALL;
      if (v297)
      {
        for (uint64_t i = (void *)*v297; i != (void *)v297[1]; ++i)
        {
          if (*i >= (unint64_t)v306)
          {
            *(void *)unint64_t v338 = &v358;
            std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v338);
            int v95 = 0;
            int v10 = v302;
            uint64_t v12 = v303;
            uint64_t v7 = v304;
            goto LABEL_541;
          }
        }
      }
      v291 = (TBaseFont **)v84;
      v356[13] = v138;
      v356[14] = v138;
      uint64_t v140 = (v117 - v118) >> 1;
      v356[11] = v138;
      v356[12] = v138;
      v356[9] = v138;
      v356[10] = v138;
      v356[7] = v138;
      v356[8] = v138;
      v356[5] = v138;
      v356[6] = v138;
      v356[3] = v138;
      v356[4] = v138;
      v356[1] = v138;
      v356[2] = v138;
      v356[0] = v138;
      v353 = 0;
      unint64_t v355 = 0;
      unint64_t v354 = 0;
      v357 = v356;
      if (!v297)
      {
        int v10 = v302;
        goto LABEL_359;
      }
      int v10 = v302;
      if (!v133) {
        goto LABEL_359;
      }
      uint64_t v141 = *(void *)(v133 + 8);
      if (v141 < v304 && *(void *)(v133 + 16) + v141 >= v304)
      {
        if ((*(unsigned char *)(v133 + 225) & 2) != 0)
        {
          v364.locatioCFIndex n = v15;
          v364.uint64_t length = v306;
          TLine::SetLevelRange(v132, v364, *(unsigned char *)(v133 + 224), 0);
          TRunGlue::TRunGlue((TRunGlue *)v338, (TLine *)v132);
          TRunGlue::operator=((uint64_t)*v5, (long long *)v338);
          std::__function::__value_func<BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::~__value_func[abi:nn180100](v352);
          unsigned int v314 = (void **)v351;
          std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100](&v314);
          unsigned int v314 = (void **)v349 + 1;
          std::vector<unsigned char,TInlineBufferAllocator<unsigned char,128ul>>::__destroy_vector::operator()[abi:nn180100](&v314);
          unsigned int v314 = (void **)&v340;
          std::vector<std::pair<UScriptCode,long>,TInlineBufferAllocator<std::pair<UScriptCode,long>,1ul>>::__destroy_vector::operator()[abi:nn180100](&v314);
          BOOL v290 = 1;
        }
        else
        {
          BOOL v290 = 0;
        }
        goto LABEL_358;
      }
      uint64_t v150 = v15;
      if (v306 >= 1)
      {
        do
        {
          uint64_t v151 = *(void *)(v133 + 8);
          if (v151 > v150 || *(void *)(v133 + 16) + v151 <= v150)
          {
            ++RunWithCharIndex;
            uint64_t v133 = *(void *)(*((void *)v132[2] + RunWithCharIndex) + 48);
          }
          CFIndex v153 = TRun::GetGlyphIndexForCharIndex<false>(v133, v150);
          TLine::SeparateCharWithGlyphIndex((TLine *)v132, &RunWithCharIndex, v153);
          ++v150;
        }
        while (v150 < v304);
      }
      char v154 = (char *)*v297;
      if (v140 >= v292)
      {
LABEL_350:
        uint64_t v188 = v297[1] - (void)v154;
        if (v188 >= 1)
        {
          uint64_t v189 = 0;
          uint64_t v190 = (unint64_t)v188 >> 3;
          if (v190 <= 1) {
            uint64_t v191 = 1;
          }
          else {
            uint64_t v191 = v190;
          }
          do
          {
            uint64_t v192 = *(void *)&v154[8 * v189];
            for (j = v189; v189 != v192; uint64_t v192 = *(void *)&v154[8 * j])
            {
              uint64_t v194 = j;
              uint64_t j = v192;
              uint64_t v195 = TLine::FindRunWithCharIndex((TLine *)v132, v194 + v309, 1);
              uint64_t v196 = TLine::FindRunWithCharIndex((TLine *)v132, j + v309, 1);
              v197 = v132[2];
              uint64_t v198 = v197[v195];
              v197[v195] = v197[v196];
              v197[v196] = v198;
              *((_WORD *)v132 + 77) |= 0x40u;
              char v154 = (char *)*v297;
              *(void *)(*v297 + 8 * v194) = v194;
            }
            *(void *)&v154[8 * j] = j;
            ++v189;
          }
          while (v189 != v191);
        }
        TRunGlue::TRunGlue((TRunGlue *)v338, (TLine *)v132);
        uint64_t v5 = (void ****)v301;
        TRunGlue::operator=(*v301, (long long *)v338);
        std::__function::__value_func<BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::~__value_func[abi:nn180100](v352);
        unsigned int v314 = (void **)v351;
        std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100](&v314);
        unsigned int v314 = (void **)v349 + 1;
        std::vector<unsigned char,TInlineBufferAllocator<unsigned char,128ul>>::__destroy_vector::operator()[abi:nn180100](&v314);
        unsigned int v314 = (void **)&v340;
        std::vector<std::pair<UScriptCode,long>,TInlineBufferAllocator<std::pair<UScriptCode,long>,1ul>>::__destroy_vector::operator()[abi:nn180100](&v314);
        BOOL v290 = 0;
        unsigned int v297 = 0;
        int v10 = v302;
        uint64_t v15 = v309;
        uint64_t v122 = v292;
LABEL_358:
        RunWithCharIndedouble x = TLine::FindRunWithCharIndex((TLine *)v132, v15, 1);
        uint64_t v133 = *(void *)(*((void *)v132[2] + RunWithCharIndex) + 48);
LABEL_359:
        if (v140 == v122)
        {
          if (!v297) {
            goto LABEL_364;
          }
LABEL_367:
          BOOL v201 = v297 != 0;
          if (v297)
          {
            BOOL v202 = __OFSUB__(v140, v122);
            int64_t v203 = v140 - v122;
            if (!((v203 < 0) ^ v202 | (v203 == 0)))
            {
              int v204 = (char *)(*v297 + 8);
              *(void *)unint64_t v338 = 0;
              long long v205 = std::vector<long,TInlineBufferAllocator<long,30ul>>::insert((uint64_t)v297, v204, v203, v338);
              uint64_t v206 = 0;
              unsigned int v207 = &v205[8 * v203];
              uint64_t v208 = 8 * v140 - 8 * v292;
              do
              {
                *(void *)&v205[8 * v206] = v206 + 1;
                ++v206;
                v208 -= 8;
              }
              while (v208);
              uint64_t v209 = (char *)v297[1];
              while (v207 != v209)
              {
                *(void *)v207 += v203;
                v207 += 8;
              }
              BOOL v201 = 1;
            }
          }
          if (v133)
          {
            CFIndex v210 = v292;
            goto LABEL_379;
          }
          uint64_t v227 = (TLine **)*v5;
          if (v201) {
            uint64_t v228 = *v297;
          }
          else {
            uint64_t v228 = 0;
          }
LABEL_425:
          uint64_t v12 = v303;
          uint64_t v7 = v304;
          int v95 = TRunGlue::ReplaceCharRangeWithGlyphs((TRunGlue *)v227, v15, v306, &v320, &v358, v228);
          goto LABEL_538;
        }
        int ShapingType = TBaseFont::GetShapingType(v291[50]);
        if (v297 || ShapingType != 2) {
          goto LABEL_367;
        }
LABEL_364:
        int v200 = (unsigned __int16)*v358;
        if (v200 == TRunGlue::GetGlyphIDForCharIndex((TRunGlue *)*v5, v15))
        {
          int v95 = 0;
          goto LABEL_366;
        }
        CFIndex v210 = v292;
        if (!v133)
        {
          uint64_t v228 = 0;
          uint64_t v227 = (TLine **)*v5;
          goto LABEL_425;
        }
        BOOL v201 = 0;
LABEL_379:
        if ((*(_WORD *)v320 & 0xF800) == 0xD800) {
          uint64_t v211 = v15 + 1;
        }
        else {
          uint64_t v211 = v15;
        }
        CFIndex v294 = v306 - v210;
        if (v306 - v210 >= 1)
        {
          id v212 = v5;
          LODWORD(v288) = v201;
          HIDWORD(v288) = v290 && v201;
          uint64_t v213 = v306 - v210;
          do
          {
            int v214 = (char *)v132[2];
            uint64_t v215 = (unsigned char *)v132[3] - v214;
            if (v215 >= 1)
            {
              uint64_t v216 = v211 + v213;
              uint64_t v217 = (unint64_t)v215 >> 3;
              if (v217 <= 1) {
                uint64_t v217 = 1;
              }
              while (1)
              {
                uint64_t v218 = *(void *)(*(void *)v214 + 48);
                uint64_t v219 = *(void *)(v218 + 8);
                if (v219 <= v216 && *(void *)(v218 + 16) + v219 > v216) {
                  break;
                }
                v214 += 8;
                if (!--v217) {
                  goto LABEL_404;
                }
              }
              uint64_t v221 = TRun::GetGlyphIndexForCharIndex<false>(*(void *)(*(void *)v214 + 48), v211 + v213);
              v222 = *(void **)(v218 + 216);
              uint64_t v223 = *(void *)(v218 + 200);
              if (*(void *)(v222[6] + 8 * v223 + 8 * v221) == v216)
              {
                [v222 setGlyph:0xFFFFLL atIndex:v223 + v221];
                if ((*(unsigned char *)(v218 + 225) & 2) != 0) {
                  *(unsigned char *)(v218 + 225) |= 8u;
                }
                objc_msgSend(*(id *)(v218 + 216), "setProps:atIndex:", *(_DWORD *)(*(void *)(*(void *)(v218 + 216) + 40) + 4 * *(void *)(v218 + 200) + 4 * v221) | 0x20u, *(void *)(v218 + 200) + v221, v288);
                TStorageRange::SetAdvance((TStorageRange *)(v218 + 192), v221, *MEMORY[0x1E4F1DB30]);
                if (HIDWORD(v288))
                {
                  uint64_t v224 = *(void *)(*v297 + 8 * (v216 - v15)) + v15;
                  if (v224 != v216)
                  {
                    uint64_t v225 = *(void *)(v218 + 8);
                    if (v225 <= v224 && *(void *)(v218 + 16) + v225 > v224)
                    {
                      objc_msgSend(*(id *)(v218 + 216), "setStringIndex:atIndex:");
                      *(_DWORD *)(v218 + 256) = 2;
                    }
                  }
                }
              }
            }
LABEL_404:
            BOOL v22 = v213-- <= 1;
          }
          while (!v22);
          if (v306 < v292)
          {
            int v95 = 0;
            uint64_t v5 = v212;
            int v10 = v302;
LABEL_537:
            uint64_t v12 = v303;
            uint64_t v7 = v304;
            goto LABEL_538;
          }
          uint64_t v235 = 0;
          uint64_t v5 = v212;
          int v10 = v302;
          BOOL v201 = v288;
LABEL_495:
          if (v15 < v304)
          {
            uint64_t v270 = *(void *)(v133 + 8);
            uint64_t v271 = *(void *)(v133 + 16);
            int v293 = v290 && v201;
            while (v270 <= v15 && v271 + v270 > v15)
            {
LABEL_504:
              uint64_t v273 = TRun::GetGlyphIndexForCharIndex<false>(v133, v15);
              do
              {
                uint64_t v274 = v235;
                unsigned int v275 = v353;
                if (v353 != v354)
                {
                  while (*v275 != (void *)v235)
                  {
                    if (++v275 == v354)
                    {
                      unsigned int v275 = v354;
                      break;
                    }
                  }
                }
                ++v235;
              }
              while (v275 != v354);
              UChar32 v276 = *(unsigned __int16 *)&v320[2 * v274];
              if ((v276 & 0xFC00) == 0xD800 && v235 != (v321 - v320) >> 1)
              {
                int v277 = *(unsigned __int16 *)&v320[2 * v235];
                BOOL v278 = (v277 & 0xFC00) == 56320;
                UChar32 v279 = (v276 << 10) - 56613888 + v277;
                uint64_t v235 = v278 ? v274 + 2 : v274 + 1;
                if (v278) {
                  UChar32 v276 = v279;
                }
              }
              uint64_t v308 = (TStorageRange *)(v133 + 192);
              [*(id *)(v133 + 216) setProps:*(_DWORD *)(*(void *)(*(void *)(v133 + 216) + 40) + 4 * *(void *)(v133 + 200) + 4 * v273) & 0xFFFFFFBF | ((u_isbase(v276) == 0) << 6) atIndex:*(void *)(v133 + 200) + v273];
              if (TFont::operator==(*(TFont **)(atomic_load_explicit((atomic_ullong *volatile)(v133 + 56), memory_order_acquire)+ 40), (TFont *)v291))
              {
                int v280 = (unsigned __int16)v358[v274];
                [*(id *)(v133 + 216) setGlyph:(unsigned __int16)v358[v274] atIndex:*(void *)(v133 + 200) + v273];
                if (v280 == 0xFFFF && (*(unsigned char *)(v133 + 225) & 2) != 0) {
                  *(unsigned char *)(v133 + 225) |= 8u;
                }
                uint64_t v281 = *(void *)(atomic_load_explicit((atomic_ullong *volatile)(v133 + 56), memory_order_acquire) + 40);
                uint64_t RenderingStyle = TAttributes::GetRenderingStyle((TAttributes *)(v133 + 40));
                TStorageRange::ResetAdvance((uint64_t)v308, v273, v281, RenderingStyle);
              }
              else
              {
                [*(id *)(v133 + 216) setGlyph:0xFFFFLL atIndex:*(void *)(v133 + 200) + v273];
                if ((*(unsigned char *)(v133 + 225) & 2) != 0) {
                  *(unsigned char *)(v133 + 225) |= 8u;
                }
                TStorageRange::SetAdvance(v308, v273, *MEMORY[0x1E4F1DB30]);
              }
              if (v293)
              {
                uint64_t v283 = *(void *)(*v297 + 8 * (v15 - v309)) + v309;
                if (v283 != v15 && v270 <= v283 && v270 + v271 > v283)
                {
                  objc_msgSend(*(id *)(v133 + 216), "setStringIndex:atIndex:");
                  *(_DWORD *)(v133 + 256) = 2;
                }
              }
              uint64_t v284 = v15 + v294;
              CFIndex v294 = 0;
              uint64_t v15 = v284 - v274 + v235;
              int v10 = v302;
              if (v15 >= v304)
              {
                int v95 = 1;
                goto LABEL_536;
              }
            }
            while (1)
            {
              uint64_t v133 = *(void *)(v133 + 24);
              if (!v133) {
                break;
              }
              uint64_t v270 = *(void *)(v133 + 8);
              uint64_t v271 = *(void *)(v133 + 16);
              if (v270 <= v15 && v271 + v270 > v15) {
                goto LABEL_504;
              }
            }
            int v95 = 0;
LABEL_536:
            uint64_t v5 = (void ****)v301;
            goto LABEL_537;
          }
LABEL_534:
          int v95 = 1;
          goto LABEL_537;
        }
        int v10 = v302;
        if (v306 >= v210)
        {
          uint64_t v235 = 0;
          goto LABEL_495;
        }
        LODWORD(v288) = v201;
        if (v321 == v320)
        {
          uint64_t v230 = 0;
        }
        else
        {
          uint64_t v229 = 0;
          uint64_t v230 = 0;
          uint64_t v231 = (v321 - v320) >> 1;
          do
          {
            uint64_t v232 = v229 + 1;
            if ((*(_WORD *)&v320[2 * v229] & 0xFC00) == 0xD800 && v232 != v231)
            {
              uint64_t v234 = v229 + 2;
              if ((*(_WORD *)&v320[2 * v232] & 0xFC00) == 0xDC00) {
                uint64_t v232 = v234;
              }
            }
            ++v230;
            uint64_t v229 = v232;
          }
          while (v232 != v231);
        }
        if (v326 == v325)
        {
          uint64_t v237 = 0;
        }
        else
        {
          uint64_t v236 = 0;
          uint64_t v237 = 0;
          uint64_t v238 = (v326 - v325) >> 1;
          do
          {
            uint64_t v239 = v236 + 1;
            if ((*(_WORD *)&v325[2 * v236] & 0xFC00) == 0xD800 && v239 != v238)
            {
              uint64_t v241 = v236 + 2;
              if ((*(_WORD *)&v325[2 * v239] & 0xFC00) == 0xDC00) {
                uint64_t v239 = v241;
              }
            }
            ++v237;
            uint64_t v236 = v239;
          }
          while (v239 != v238);
        }
        char v242 = *(unsigned char *)(v133 + 224);
        CFIndex v243 = v230 - v237;
        TStorageRange::DetachStorage((id *)(v133 + 192));
        uint64_t v244 = TRun::GetGlyphIndexForCharIndex<false>(v133, v309);
        int v245 = *(_DWORD *)(*(void *)(*(void *)(v133 + 216) + 40) + 4 * *(void *)(v133 + 200) + 4 * v244);
        v365.locatioCFIndex n = v244 + 1;
        uint64_t v307 = (TStorageRange *)(v133 + 192);
        v365.uint64_t length = v243;
        TStorageRange::InsertGlyphs((id *)(v133 + 192), v365);
        TRunGlue::InsertedGlyphsAtCharIndex((TRunGlue *)*v5, v243, v309);
        if (*(int *)(v133 + 256) <= 1) {
          *(_DWORD *)(v133 + 256) = 1;
        }
        int v246 = *(unsigned __int16 *)v320;
        if ((v246 & 0xFC00) == 0xD800
          && v321 - v320 != 2
          && (int v247 = *((unsigned __int16 *)v320 + 1), (v247 & 0xFC00) == 0xDC00))
        {
          unsigned int v289 = v247 + (v246 << 10) - 56613888;
          uint64_t v248 = 2;
        }
        else
        {
          unsigned int v289 = *(unsigned __int16 *)v320;
          uint64_t v248 = 1;
        }
        if (v242) {
          CFIndex v249 = v243;
        }
        else {
          CFIndex v249 = 0;
        }
        uint64_t v250 = v244 + v249;
        int v251 = (unsigned __int16)*v358;
        objc_msgSend(*(id *)(v133 + 216), "setGlyph:atIndex:", (unsigned __int16)*v358, *(void *)(v133 + 200) + v250, v288);
        if (v251 == 0xFFFF && (*(unsigned char *)(v133 + 225) & 2) != 0) {
          *(unsigned char *)(v133 + 225) |= 8u;
        }
        uint64_t v252 = TAttributes::GetRenderingStyle((TAttributes *)(v133 + 40));
        TStorageRange::ResetAdvance((uint64_t)v307, v250, (uint64_t)v291, v252);
        [*(id *)(v133 + 216) setProps:v245 | 0x80u atIndex:*(void *)(v133 + 200) + v250];
        [*(id *)(v133 + 216) setStringIndex:v309 atIndex:*(void *)(v133 + 200) + v250];
        [*(id *)(v133 + 216) setAttachmentCount:v248 - 1 atIndex:*(void *)(v133 + 200) + v250];
        unint64_t v253 = v353;
        uint64_t v254 = v354;
        if (v353 != v354) {
          uint64_t v248 = (uint64_t)*v353;
        }
        if (v242) {
          uint64_t v255 = -1;
        }
        else {
          uint64_t v255 = 1;
        }
        uint64_t v256 = v250 + v255;
        if (!v290)
        {
          if (v243 < 1)
          {
            int v10 = v302;
          }
          else
          {
            do
            {
              uint64_t v264 = v248 + 1;
              if ((*(_WORD *)&v320[2 * v248] & 0xFC00) == 0xD800
                && v264 != (v321 - v320) >> 1
                && (*(_WORD *)&v320[2 * v264] & 0xFC00) == 0xDC00)
              {
                uint64_t v264 = v248 + 2;
              }
              int v265 = (unsigned __int16)v358[v248];
              [*(id *)(v133 + 216) setGlyph:(unsigned __int16)v358[v248] atIndex:v256 + *(void *)(v133 + 200)];
              char v266 = *(unsigned char *)(v133 + 225);
              if (v265 == 0xFFFF && (v266 & 2) != 0) {
                *(unsigned char *)(v133 + 225) = v266 | 8;
              }
              uint64_t v268 = TAttributes::GetRenderingStyle((TAttributes *)(v133 + 40));
              TStorageRange::ResetAdvance((uint64_t)v307, v256, (uint64_t)v291, v268);
              [*(id *)(v133 + 216) setProps:v245 | 0x240u atIndex:v256 + *(void *)(v133 + 200)];
              [*(id *)(v133 + 216) setStringIndex:v309 atIndex:v256 + *(void *)(v133 + 200)];
              [*(id *)(v133 + 216) setAttachmentCount:0 atIndex:v256 + *(void *)(v133 + 200)];
              v256 += v255;
              uint64_t v248 = v264;
              --v243;
            }
            while (v243);
            unint64_t v253 = v353;
            uint64_t v254 = v354;
            uint64_t v248 = v264;
            int v10 = v302;
          }
          CFIndex v294 = 0;
          uint64_t v269 = 1;
          if (v289 >= 0x10000) {
            uint64_t v269 = 2;
          }
          uint64_t v15 = v269 + v309;
          if (v253 == v254) {
            uint64_t v235 = v248;
          }
          else {
            uint64_t v235 = v269;
          }
LABEL_494:
          uint64_t v5 = (void ****)v301;
          BOOL v201 = v288;
          if (!v290) {
            goto LABEL_495;
          }
          goto LABEL_534;
        }
        int v10 = v302;
        if (v248 < v292)
        {
          do
          {
            uint64_t v235 = v248 + 1;
            if ((*(_WORD *)&v320[2 * v248] & 0xFC00) == 0xD800)
            {
              uint64_t v257 = v309;
              if (v235 != (v321 - v320) >> 1 && (*(_WORD *)&v320[2 * v235] & 0xFC00) == 0xDC00) {
                uint64_t v235 = v248 + 2;
              }
            }
            else
            {
              uint64_t v257 = v309;
            }
            int v258 = (unsigned __int16)v358[v248];
            [*(id *)(v133 + 216) setGlyph:(unsigned __int16)v358[v248] atIndex:v256 + *(void *)(v133 + 200)];
            char v259 = *(unsigned char *)(v133 + 225);
            if (v258 == 0xFFFF && (v259 & 2) != 0) {
              *(unsigned char *)(v133 + 225) = v259 | 8;
            }
            uint64_t v261 = TAttributes::GetRenderingStyle((TAttributes *)(v133 + 40));
            TStorageRange::ResetAdvance((uint64_t)v307, v256, (uint64_t)v291, v261);
            uint64_t v262 = *(void *)(*v297 + 8 * v248);
            uint64_t v15 = v262 + v257;
            if (v262) {
              int v263 = 64;
            }
            else {
              int v263 = 576;
            }
            [*(id *)(v133 + 216) setProps:*(_DWORD *)(*(void *)(*(void *)(v133 + 216) + 40) + 4 * *(void *)(v133 + 200) + 4 * v256) | v263 atIndex:v256 + *(void *)(v133 + 200)];
            [*(id *)(v133 + 216) setStringIndex:v15 atIndex:v256 + *(void *)(v133 + 200)];
            [*(id *)(v133 + 216) setAttachmentCount:v235 + ~v248 atIndex:v256 + *(void *)(v133 + 200)];
            v256 += v255;
            uint64_t v248 = v235;
          }
          while (v235 < v292);
          goto LABEL_494;
        }
        int v95 = 1;
LABEL_487:
        uint64_t v5 = (void ****)v301;
        goto LABEL_366;
      }
      unint64_t v155 = v154 + 8;
      char v156 = (char *)v297[1];
      *(void *)&long long v157 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v157 + 1) = 0xAAAAAAAAAAAAAAAALL;
      if (v154 + 8 != v156)
      {
        while (*(void *)v155)
        {
          v155 += 8;
          if (v155 == v156)
          {
            unint64_t v155 = (char *)v297[1];
            break;
          }
        }
      }
      if (v155 == v156)
      {
        int v95 = 0;
        goto LABEL_487;
      }
      do
      {
        uint64_t v158 = (v155 - v154) >> 3;
        long long v159 = v354;
        unint64_t v160 = v353;
        uint64_t v161 = v354 - v353;
        uint64_t v162 = (void *)(v161 + v158);
        if ((unint64_t)v354 >= v355)
        {
          unint64_t v165 = v161 + 1;
          if ((unint64_t)(v161 + 1) >> 61) {
            goto LABEL_552;
          }
          uint64_t v166 = v355 - (void)v353;
          if ((uint64_t)(v355 - (void)v353) >> 2 > v165) {
            unint64_t v165 = v166 >> 2;
          }
          if ((unint64_t)v166 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v167 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v167 = v165;
          }
          *(void *)&v338[32] = v356;
          if (v167)
          {
            CGAffineTransform v168 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v356, v167);
            long long v159 = v354;
            unint64_t v160 = v353;
          }
          else
          {
            CGAffineTransform v168 = 0;
          }
          int64x2_t v169 = &v168[8 * v161];
          *(void *)int64x2_t v169 = v162;
          if (v159 == v160)
          {
            int v171 = (void **)&v168[8 * v161];
          }
          else
          {
            double v170 = v159;
            int v171 = (void **)&v168[8 * v161];
            do
            {
              __int16 v172 = *--v170;
              *--int v171 = v172;
            }
            while (v170 != v160);
          }
          double v164 = (void **)(v169 + 8);
          v353 = v171;
          *(void *)&v338[8] = v160;
          unint64_t v354 = (void **)(v169 + 8);
          *(void *)&v338[16] = v159;
          unint64_t v173 = v355;
          unint64_t v355 = (unint64_t)&v168[8 * v167];
          *(void *)&v338[24] = v173;
          *(void *)unint64_t v338 = v160;
          std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)v338);
          char v154 = (char *)*v297;
          char v156 = (char *)v297[1];
          uint64_t v163 = (uint64_t)&v155[-*v297] >> 3;
          *(void *)&long long v157 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v157 + 1) = 0xAAAAAAAAAAAAAAAALL;
        }
        else
        {
          *unint64_t v354 = v162;
          uint64_t v163 = (v155 - v154) >> 3;
          double v164 = v159 + 1;
        }
        unint64_t v354 = v164;
        CFArrayRef v174 = &v154[8 * v163];
        int64_t v175 = v156 - (v174 + 8);
        if (v156 != v174 + 8)
        {
          memmove(&v154[8 * v163], v174 + 8, v156 - (v174 + 8));
          *(void *)&long long v157 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v157 + 1) = 0xAAAAAAAAAAAAAAAALL;
          char v154 = (char *)*v297;
        }
        char v156 = &v174[v175];
        v297[1] = (uint64_t)&v174[v175];
        unint64_t v155 = v156;
        if (&v154[8 * v158] != v156)
        {
          unint64_t v155 = &v154[8 * v158];
          while (*(void *)v155)
          {
            v155 += 8;
            if (v155 == v156)
            {
              unint64_t v155 = v156;
              break;
            }
          }
        }
      }
      while (v155 != v156);
      v349[2] = v157;
      v349[3] = v157;
      v349[0] = v157;
      v349[1] = v157;
      long long v347 = v157;
      long long v348 = v157;
      long long v345 = v157;
      long long v346 = v157;
      long long v343 = v157;
      long long v344 = v157;
      long long v341 = v157;
      long long v342 = v157;
      long long v339 = v157;
      long long v340 = v157;
      *(_OWORD *)&v338[24] = v157;
      memset(v338, 0, 24);
      v350 = &v338[24];
      int64_t v176 = v156 - v154;
      if (v156 != v154)
      {
        std::vector<long,TInlineBufferAllocator<long,30ul>>::__vallocate[abi:nn180100](v338, v176 >> 3);
        uint64_t v177 = *(void *)&v338[8];
        memmove(*(void **)&v338[8], v154, v176);
        *(void *)&v338[8] = v177 + v176;
      }
      LOBYTE(v314) = -86;
      std::__sort<std::__less<long,long> &,long *>();
      long long v179 = *(uint64_t **)&v338[8];
      uint64_t v178 = *(void *)v338;
      if (*(void *)v338 != *(void *)&v338[8])
      {
        long long v180 = (uint64_t *)(*(void *)v338 + 8);
        while (v180 != *(uint64_t **)&v338[8])
        {
          uint64_t v181 = *(v180 - 1);
          uint64_t v182 = *v180++;
          if (v181 == v182)
          {
            unint64_t v183 = v180 - 2;
            while (v180 != v179)
            {
              uint64_t v184 = v181;
              uint64_t v181 = *v180;
              if (v184 != *v180)
              {
                v183[1] = v181;
                ++v183;
              }
              ++v180;
            }
            uint64_t v185 = v183 + 1;
            goto LABEL_346;
          }
        }
      }
      uint64_t v185 = *(uint64_t **)&v338[8];
LABEL_346:
      if (v179 != v185)
      {
        long long v179 = v185;
        *(void *)&v338[8] = v185;
      }
      uint64_t v186 = (char *)v179 - v178;
      uint64_t v187 = v297[1] - *v297;
      unsigned int v314 = (void **)v338;
      std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](&v314);
      if (v186 == (char *)v187)
      {
        char v154 = (char *)*v297;
        goto LABEL_350;
      }
      int v95 = 0;
      uint64_t v5 = (void ****)v301;
      int v10 = v302;
LABEL_366:
      uint64_t v12 = v303;
      uint64_t v7 = v304;
LABEL_538:
      *(void *)unint64_t v338 = &v353;
      std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v338);
      *(void *)unint64_t v338 = &v358;
      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v338);
      char v285 = v296;
      if (v95) {
        char v285 = 1;
      }
      char v296 = v285;
LABEL_541:
      v300 |= v95;
      LOBYTE(v95) = v296;
LABEL_542:
      *(void *)unint64_t v338 = &v315;
      std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v338);
      *(void *)unint64_t v338 = &v320;
      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v338);
      *(void *)unint64_t v338 = &v325;
      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v338);
LABEL_543:
      int64x2_t v96 = a3;
      if (a3)
      {
LABEL_544:
        if ((v95 & 1) == 0) {
          *int64x2_t v96 = 0;
        }
      }
LABEL_143:
      *(void *)unint64_t v338 = &v330;
      std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v338);
      *(void *)unint64_t v338 = v335;
      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v338);
LABEL_144:
      if (v7 >= v12)
      {
LABEL_550:
        char v286 = v300;
        return v286 & 1;
      }
    }
  }
  char v286 = 0;
  return v286 & 1;
}

uint64_t TRunGlue::GetNextUncombinedCharRange(TLine **this, uint64_t a2, BOOL *a3, int *a4)
{
  if (*this) {
    return TLine::GetNextUncombinedCharRange(*this, a2, a3, a4);
  }
  uint64_t v5 = (uint64_t)this[4];
  id v6 = (char *)this[5] + (void)this[6];
  if (v5 < 1)
  {
LABEL_7:
    uint64_t v11 = (uint64_t)v6;
  }
  else
  {
    uint64_t v7 = 0;
    uint64_t v8 = this[66];
    int v9 = this[20];
    int v10 = this[65];
    while (1)
    {
      uint64_t v11 = *((void *)v8 + (void)v9 + v7);
      if (v11 >= a2) {
        break;
      }
      if (v5 == ++v7) {
        goto LABEL_7;
      }
    }
    if (v11 < (uint64_t)v6)
    {
      char v12 = 0;
      while (1)
      {
        int v14 = *((_DWORD *)v10 + (void)v9 + v7);
        if ((v14 & 0x40) != 0) {
          break;
        }
        if ((v14 & 0x20) == 0)
        {
          if ((v14 & 0x380) != 0) {
            uint64_t v11 = a2;
          }
          v12 |= (*((_DWORD *)v10 + (void)v9 + v7) & 0x380) == 0;
          if ((v14 & 2) != 0) {
            char v12 = 0;
          }
          else {
            a2 = v11;
          }
        }
        if (v7 + 1 >= v5) {
          goto LABEL_7;
        }
        uint64_t v13 = (uint64_t)v8 + 8 * (void)v9 + 8;
        uint64_t v11 = *(void *)(v13 + 8 * v7);
        if ((v12 & 1) == 0) {
          a2 = *(void *)(v13 + 8 * v7);
        }
        ++v7;
        if (v11 >= (uint64_t)v6) {
          goto LABEL_8;
        }
      }
      if (v11 < (uint64_t)v6 && (v14 & 0x3C0) != 0)
      {
        uint64_t v15 = (uint64_t)v10 + 4 * (void)v9 + 4;
        uint64_t v16 = (uint64_t)v8 + 8 * (void)v9 + 8;
        do
        {
          if (v7 + 1 >= v5) {
            break;
          }
          if (*(void *)(v16 + 8 * v7) >= (uint64_t)v6) {
            break;
          }
          int v17 = *(_DWORD *)(v15 + 4 * v7++);
        }
        while ((v17 & 0x3C0) != 0);
      }
      *a3 = v12 & 1;
      return a2;
    }
  }
LABEL_8:
  *a3 = 0;
  return v11;
}

uint64_t TLine::GetNextUncombinedCharRange(TLine *this, uint64_t a2, BOOL *a3, int *a4)
{
  if (*((void *)this + 2) == *((void *)this + 3))
  {
    *a3 = 0;
    return *((void *)this + 10) + *((void *)this + 9);
  }
  else
  {
    uint64_t v8 = *(void *)(*(void *)(*((void *)this + 2) + 8 * TLine::FindRunWithCharIndex(this, a2, 1)) + 40);
    uint64_t v9 = a2;
    while (1)
    {
      uint64_t v11 = *(void *)(v8 + 8);
      uint64_t v10 = *(void *)(v8 + 16);
      uint64_t v12 = v9 <= v11 ? *(void *)(v8 + 8) : v9;
      uint64_t NextUncombinedCharRange = TRun::GetNextUncombinedCharRange((TRun *)v8, v12, a3);
      uint64_t v9 = NextUncombinedCharRange;
      uint64_t v15 = v14;
      int v16 = (*(unsigned char *)(v8 + 224) & 1) != 0 ? -1 : 1;
      *a4 = v16;
      uint64_t v17 = v10 + v11;
      if (NextUncombinedCharRange != v17) {
        break;
      }
      uint64_t v8 = *(void *)(v8 + 24);
      if (v8)
      {
        uint64_t v18 = *((void *)this + 9);
        if (v18 <= NextUncombinedCharRange && *((void *)this + 10) + v18 > NextUncombinedCharRange) {
          continue;
        }
      }
      return v9;
    }
    if (NextUncombinedCharRange == v11)
    {
      if (v11 > *((void *)this + 9)
        && TRun::GetLeadingUncombinedCharCount((TRun *)v8) >= 1
        && v11 > a2
        && (long long v20 = *(TRun **)(v8 + 32)) != 0)
      {
        while (1)
        {
          uint64_t v9 = v11 - 1;
          uint64_t TrailingBaseChar = TRun::GetTrailingBaseChar(v20);
          if (TrailingBaseChar == v11 - 1) {
            break;
          }
          uint64_t v9 = *((void *)v20 + 1);
          if (v11 > v9)
          {
            uint64_t v9 = TrailingBaseChar;
            break;
          }
          v15 += *((void *)v20 + 2);
          long long v20 = (TRun *)*((void *)v20 + 4);
          BOOL v22 = v9 <= a2 || v20 == 0;
          uint64_t v11 = v9;
          if (v22) {
            goto LABEL_30;
          }
        }
        uint64_t v15 = v15 + v11 - v9;
        *a3 = 1;
      }
      else
      {
        uint64_t v9 = v11;
      }
    }
LABEL_30:
    if (v9 + v15 == v17)
    {
      do
      {
        uint64_t v8 = *(void *)(v8 + 24);
        if (!v8) {
          break;
        }
        LeadingUncombinedCharCFIndex Count = TRun::GetLeadingUncombinedCharCount((TRun *)v8);
        v15 += LeadingUncombinedCharCount;
      }
      while (LeadingUncombinedCharCount == *(void *)(v8 + 16));
    }
  }
  return v9;
}

uint64_t TRun::GetNextUncombinedCharRange(TRun *this, uint64_t a2, BOOL *a3)
{
  uint64_t v4 = a2;
  uint64_t GlyphIndexForChar = TRun::GetGlyphIndexForCharIndex<false>((uint64_t)this, a2);
  uint64_t v23 = GlyphIndexForChar;
  uint64_t v7 = *((void *)this + 2) + *((void *)this + 1);
  if (v7 <= v4)
  {
    uint64_t NextChar = v4;
LABEL_40:
    *a3 = 0;
    return NextChar;
  }
  else
  {
    char v8 = 0;
    uint64_t v9 = (void *)*((void *)this + 27);
    uint64_t v10 = *((void *)this + 25);
    uint64_t v11 = v9[5] + 4 * v10;
    uint64_t NextChar = v4;
    while (1)
    {
      int v13 = *(_DWORD *)(v11 + 4 * GlyphIndexForChar);
      if ((v13 & 0x2040) == 0x40) {
        break;
      }
      if ((v13 & 0x20) == 0 && *(unsigned __int16 *)(v9[2] + 2 * v10 + 2 * GlyphIndexForChar) != 0xFFFF)
      {
        if ((v13 & 0x300) != 0) {
          uint64_t v14 = v4;
        }
        else {
          uint64_t v14 = NextChar;
        }
        if ((v13 & 2) != 0)
        {
          char v8 = 0;
        }
        else
        {
          uint64_t v4 = v14;
          v8 |= (v13 & 0x300) == 0;
        }
      }
      if (*((int *)this + 64) > 1)
      {
        if (*((unsigned char *)this + 224)) {
          uint64_t v16 = -1;
        }
        else {
          uint64_t v16 = 1;
        }
        if (*((unsigned char *)this + 224)) {
          uint64_t v17 = -1;
        }
        else {
          uint64_t v17 = *((void *)this + 26);
        }
        uint64_t v15 = v16 + GlyphIndexForChar;
        uint64_t v23 = v16 + GlyphIndexForChar;
        if (v16 + GlyphIndexForChar == v17)
        {
          uint64_t v15 = v17;
        }
        else
        {
          uint64_t v18 = v9[6] + 8 * v10;
          uint64_t v19 = *(void *)(v18 + 8 * v15);
          if (v19 < NextChar)
          {
            v15 += v16;
            uint64_t v23 = v15;
            if (v15 == v17)
            {
LABEL_31:
              uint64_t v15 = v17;
            }
            else
            {
              uint64_t v20 = GlyphIndexForChar + 3 * v16;
              while (1)
              {
                uint64_t v19 = *(void *)(v18 + 8 * v15);
                if (v19 >= NextChar) {
                  break;
                }
                v15 += v16;
                uint64_t v23 = v20;
                v20 += v16;
                if (v17 == v15) {
                  goto LABEL_31;
                }
              }
            }
          }
          uint64_t NextChar = v19;
        }
        if (v15 == v17) {
          uint64_t NextChar = v7;
        }
      }
      else
      {
        if (*((unsigned char *)this + 224))
        {
          uint64_t v15 = GlyphIndexForChar - 1;
          uint64_t v23 = GlyphIndexForChar - 1;
          if (GlyphIndexForChar < 1)
          {
LABEL_49:
            uint64_t NextChar = v7;
            goto LABEL_40;
          }
        }
        else
        {
          uint64_t v15 = GlyphIndexForChar + 1;
          uint64_t v23 = GlyphIndexForChar + 1;
          if (GlyphIndexForChar + 1 >= *((void *)this + 26)) {
            goto LABEL_49;
          }
        }
        uint64_t NextChar = *(void *)(v9[6] + 8 * v10 + 8 * v15);
      }
      if ((v8 & 1) == 0) {
        uint64_t v4 = NextChar;
      }
      uint64_t GlyphIndexForChar = v15;
      if (NextChar >= v7) {
        goto LABEL_40;
      }
    }
    for (; NextChar < v7; uint64_t NextChar = TRun::GetNextChar(this, NextChar, &v23))
    {
      if ((*(_DWORD *)(*(void *)(*((void *)this + 27) + 40) + 4 * *((void *)this + 25) + 4 * v23) & 0x2040) != 0x40
        && (*(_DWORD *)(*(void *)(*((void *)this + 27) + 40) + 4 * *((void *)this + 25) + 4 * v23) & 0x300) == 0)
      {
        break;
      }
    }
    *a3 = v8 & 1;
  }
  return v4;
}

CFDataRef CTFontCopyTable(CTFontRef font, CTFontTableTag table, CTFontTableOptions options)
{
  CFDataRef v3 = 0;
  if (font && table)
  {
    (*(void (**)(id *__return_ptr))(**(void **)(*((void *)font + 5) + 400) + 480))(&v5);
    CFDataRef v3 = (const __CFData *)atomic_exchange((atomic_ullong *volatile)&v5, 0);
  }
  return v3;
}

unsigned int CTFontGetUnitsPerEm(CTFontRef font)
{
  if (!font) {
    return 1000;
  }
  uint64_t v1 = (int *)*((void *)font + 5);
  if (v1[12]) {
    initeCGFloat d = v1 + 12;
  }
  else {
    initeCGFloat d = TFont::InitStrikeMetrics((TFont *)v1);
  }
  return *inited;
}

void TDescriptorSource::CopyMatchingDescriptorsForFamily(TDescriptorSource *this@<X0>, const __CFString *a2@<X1>, void *a3@<X8>)
{
  if (a2)
  {
    int v4 = (int)this;
    id v6 = a2;
    keys = @"NSFontFamilyAttribute";
    CFDictionaryRef v5 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&keys, &v6, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    TDescriptorSource::CopyDescriptorsForRequest(v4, v5);
  }
  else
  {
    *a3 = 0;
  }
}

void TDescriptorSource::CopyDescriptorForRequest(atomic_ullong **this@<X0>, const __CFDictionary *a2@<X1>, const __CFSet *a3@<X2>, const __CFDictionary *a4@<X3>, unint64_t a5@<X4>, void *a6@<X8>)
{
  CFSetRef v8 = a3;
  id v28 = 0;
  if (!a3)
  {
    if (qword_1EB2CE1E0 != -1) {
      dispatch_once_f(&qword_1EB2CE1E0, 0, (dispatch_function_t)TDescriptorSource::GetMatchableNameAttributes(void)::$_0::__invoke);
    }
    CFSetRef v8 = (const __CFSet *)qword_1EB2CE1D8;
  }
  id v27 = (id)0xAAAAAAAAAAAAAAAALL;
  TDescriptorSource::CopyDescriptorsForRequest(a2, this, v8, 0, a5, 0, (atomic_ullong *)&v27);
  CFArrayRef v12 = (const __CFArray *)(id)atomic_load_explicit((atomic_ullong *volatile)&v27, memory_order_acquire);
  if (!v12) {
    goto LABEL_32;
  }
  CFArrayRef v13 = v12;
  CFIndex Count = CFArrayGetCount(v12);

  if (Count < 1)
  {
LABEL_33:
    *a6 = atomic_exchange((atomic_ullong *volatile)&v28, 0);
    goto LABEL_34;
  }
  CFArrayRef context = (const __CFArray *)0xAAAAAAAAAAAAAAAALL;
  TCFMutableDictionary::TCFMutableDictionary((TCFMutableDictionary *)&context, a2);
  if (Count != 1)
  {
    CFSetApplyFunction(v8, (CFSetApplierFunction)TDescriptorSource::CopyDescriptorForRequest(__CFDictionary const*,__CFSet const*,__CFDictionary const*,unsigned long)const::$_0::__invoke, &context);
    CFDictionaryRemoveValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&context, memory_order_acquire), @"NSFontSizeAttribute");
  }
  CFIndex v15 = CFDictionaryGetCount((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&context, memory_order_acquire));
  if (Count == 1 || !v15)
  {
    if (Count != 1 && !v15)
    {
      TDescriptorSource::CreateVariantWithTraitsMatchingDescriptors((TDescriptorSource *)atomic_load_explicit((atomic_ullong *volatile)&v27, memory_order_acquire), a4, &v29);

      id v20 = v29;
LABEL_30:

      goto LABEL_31;
    }
    CFDictionaryRef explicit = (void *)atomic_load_explicit((atomic_ullong *volatile)&v27, memory_order_acquire);
LABEL_26:
    CFArrayRef v22 = explicit;
    CFArrayRef v23 = v22;
    if (v22) {
      CFDictionaryRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(v22, 0);
    }
    else {
      CFDictionaryRef ValueAtIndex = 0;
    }
    TCFRef<__CTFont const*>::Retain((atomic_ullong *)&v28, ValueAtIndex);
    id v20 = v23;
    goto LABEL_30;
  }
  if (!a4
    || CFDictionaryGetCount((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&context, memory_order_acquire)) < 1)
  {
LABEL_24:
    TDescriptorSource::CopyDescriptorsForRequestFromArray((TDescriptorSource *)&v29, (CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v27, memory_order_acquire), (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&context, memory_order_acquire), 0, a5 | 3, 1);
    id v25 = (id)atomic_exchange((atomic_ullong *volatile)&v29, 0);

    if (atomic_load_explicit((atomic_ullong *volatile)&v28, memory_order_acquire))
    {
LABEL_31:
      CFArrayRef v12 = context;
LABEL_32:

      goto LABEL_33;
    }
    CFDictionaryRef explicit = (void *)atomic_load_explicit((atomic_ullong *volatile)&v27, memory_order_acquire);
    goto LABEL_26;
  }
  id v29 = (id)0xAAAAAAAAAAAAAAAALL;
  CFDictionaryRef v16 = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&context, memory_order_acquire);
  if (qword_1EB2CE1D0 != -1) {
    dispatch_once_f(&qword_1EB2CE1D0, 0, (dispatch_function_t)TDescriptorSource::GetMatchableAttributes(void)::$_0::__invoke);
  }
  TDescriptorSource::CopyMandatoryMatchableRequest(v16, (CFSetRef)qword_1EB2CE1C8, &v29);
  CFDictionaryRef v17 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)&v29, memory_order_acquire);
  if (!v17)
  {

    goto LABEL_23;
  }
  CFDictionaryRef v18 = v17;
  CFIndex v19 = CFDictionaryGetCount(v17);

  if (v19 != 1)
  {
LABEL_23:

    goto LABEL_24;
  }
  TDescriptorSource::CreateVariantWithTraitsMatchingDescriptors((TDescriptorSource *)atomic_load_explicit((atomic_ullong *volatile)&v27, memory_order_acquire), a4, a6);

LABEL_34:
}

unint64_t CTFontDescriptorCreateMatchingFontDescriptorsWithOptions(uint64_t a1, const __CFSet *a2, uint64_t a3)
{
  if (!a1) {
    return 0;
  }
  TDescriptor::CreateMatchingDescriptors(*(TDescriptor **)(a1 + 40), a2, a3, (atomic_ullong *)&v5);
  unint64_t v3 = atomic_exchange((atomic_ullong *volatile)&v5, 0);

  return v3;
}

void TCFLazyMutableArray::Sort(TCFLazyMutableArray *this, CFComparisonResult (__cdecl *a2)(const void *, const void *, void *), void *a3)
{
  TCFLazyMutableArray::LazyCreate(this);
  CFDictionaryRef explicit = (__CFArray *)atomic_load_explicit((atomic_ullong *volatile)this, memory_order_acquire);
  CFArrayRef v6 = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)this, memory_order_acquire);
  if (v6) {
    v7.uint64_t length = CFArrayGetCount(v6);
  }
  else {
    v7.uint64_t length = 0;
  }
  v7.locatioCFIndex n = 0;

  CFArraySortValues(explicit, v7, a2, 0);
}

CFArrayRef CTFontDescriptorCreateMatchingFontDescriptors(CTFontDescriptorRef descriptor, CFSetRef mandatoryAttributes)
{
  if (!descriptor) {
    return 0;
  }
  TDescriptor::CreateMatchingDescriptors(*((TDescriptor **)descriptor + 5), mandatoryAttributes, 0, (atomic_ullong *)&v4);
  CFArrayRef v2 = (const __CFArray *)atomic_exchange((atomic_ullong *volatile)&v4, 0);

  return v2;
}

void TDescriptor::CreateMatchingDescriptors(TDescriptor *this@<X0>, const __CFSet *a2@<X1>, uint64_t a3@<X2>, atomic_ullong *a4@<X8>)
{
  int v4 = a3;
  *a4 = 0;
  uint64_t v8 = AsMatchingOptions(*((_DWORD *)this + 4)) | a3;
  unint64_t v41 = (atomic_ullong *)0xAAAAAAAAAAAAAAAALL;
  TDescriptorSource::TDescriptorSource((TDescriptorSource *)&v41);
  CFDictionaryRef Attributes = (const __CFDictionary *)TDescriptor::GetAttributes((atomic_ullong *)this, 1);
  if (!Attributes || !CFDictionaryGetCount(Attributes))
  {
    if ((v4 & 0x20000) != 0) {
      TDescriptorSource::CopyAllDescriptorsInternal(&v41, 0, v8, &keys);
    }
    else {
      TDescriptorSource::CopyAllDescriptorsSorted(&v41, v8, &keys);
    }
    unint64_t v12 = atomic_exchange((atomic_ullong *volatile)&keys, 0);
    goto LABEL_12;
  }
  if ((*((_DWORD *)this + 4) & 0x40000000) == 0)
  {
    if ((*(void *)&v4 & 0x20000) != 0) {
      uint64_t v11 = 0;
    }
    else {
      uint64_t v11 = (CFComparisonResult (__cdecl *)(const void *, const void *, void *))CompareDescriptorsByTraitsAndPrecedence;
    }
    TDescriptorSource::CopyDescriptorsForRequest((void *)atomic_load_explicit((atomic_ullong *volatile)this + 1, memory_order_acquire), &v41, a2, v11, v8, 0, (atomic_ullong *)&keys);
    unint64_t v12 = atomic_exchange((atomic_ullong *volatile)&keys, 0);
LABEL_12:

    id v13 = keys;
    goto LABEL_13;
  }
  CFStringRef PostScriptNameAndAttribute = (const __CFString *)TDescriptorSource::GetPostScriptNameAndAttribute((TDescriptorSource *)atomic_load_explicit((atomic_ullong *volatile)this + 1, memory_order_acquire), v10);
  if (!PostScriptNameAndAttribute) {
    goto LABEL_14;
  }
  id values = (void *)0xAAAAAAAAAAAAAAAALL;
  TDescriptorSource::CopyFontDescriptorPerPostScriptName(&v41, PostScriptNameAndAttribute, v8, 1, 0, &values);
  if (atomic_load_explicit((atomic_ullong *volatile)&values, memory_order_acquire))
  {
    id keys = (id)atomic_load_explicit((atomic_ullong *volatile)&values, memory_order_acquire);
    id Mutable = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&keys, 1, MEMORY[0x1E4F1D510]);
  }
  id v13 = values;
LABEL_13:

LABEL_14:
  int v14 = *((_DWORD *)this + 4) & 0x7FFFFFFF;
  CFDictionaryRef v15 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)this + 1, memory_order_acquire);
  CFDictionaryRef v16 = v15;
  if (v15 && (CFDictionaryRef Value = (void *)CFDictionaryGetValue(v15, @"NSCTFontCharacterSetAttribute")) != 0)
  {
    CFDictionaryRef v18 = Value;
    CFTypeID v19 = CFGetTypeID(Value);
    if (v19 == CFCharacterSetGetTypeID()) {
      id v20 = v18;
    }
    else {
      id v20 = 0;
    }
  }
  else
  {
    id v20 = 0;
  }

  if (v20 || v14)
  {
    CFArrayRef v21 = (const __CFArray *)(id)atomic_load_explicit(a4, memory_order_acquire);
    if (v21)
    {
      CFArrayRef v22 = v21;
      CFIndex Count = CFArrayGetCount(v21);

      if (Count < 1) {
        return;
      }
      CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      id Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
      CFArrayRef explicit = (const __CFArray *)atomic_load_explicit(a4, memory_order_acquire);
      if (explicit)
      {
        CFIndex v25 = CFArrayGetCount(explicit);
        if (v25)
        {
          CFIndex v26 = v25;
          CFIndex v27 = 0;
          while (1)
          {
            CFDictionaryRef ValueAtIndex = (atomic_ullong **)CFArrayGetValueAtIndex(explicit, v27);
            id v39 = 0;
            if (v20)
            {
              id values = v20;
              id keys = @"NSCTFontCharacterSetAttribute";
              CFDictionaryRef v29 = CFDictionaryCreate(allocator, (const void **)&keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
              uint64_t v30 = (CTFontDescriptor *)TCFBase<TDescriptor>::Allocate();
              if (v30)
              {
                CTFontDescriptor::CTFontDescriptor(v30, (const CTFontDescriptor *)ValueAtIndex, v29, v14);
                id keys = v31;
                id values = (void *)atomic_exchange((atomic_ullong *volatile)&keys, 0);
              }
              else
              {
                id values = 0;
              }

              double v35 = v29;
            }
            else
            {
              uint64_t v32 = TCFBase<TDescriptor>::Allocate();
              if (v32)
              {
                uint64_t v33 = (void *)v32;
                uint64_t v34 = (TDescriptor *)(v32 + 48);
                v33[2] = 0;
                v33[3] = TDescriptor::Hash;
                v33[4] = 0;
                void v33[5] = v34;
                TDescriptor::TDescriptor(v34, ValueAtIndex[5], v14);
                id keys = v33;
                id values = (void *)atomic_exchange((atomic_ullong *volatile)&keys, 0);
              }
              else
              {
                id values = 0;
              }

              double v35 = values;
            }

            if (!atomic_load_explicit((atomic_ullong *volatile)&v39, memory_order_acquire)) {
              break;
            }
            id v36 = (id)atomic_load_explicit((atomic_ullong *volatile)&v39, memory_order_acquire);
            CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), v36);

            if (v26 == ++v27) {
              goto LABEL_44;
            }
          }
        }
      }
LABEL_44:

      CFArrayRef v21 = (const __CFArray *)Mutable;
    }
  }
}

void TDescriptorSource::CopyDescriptorsForRequestFromArray(TDescriptorSource *this, CFArrayRef theArray, const __CFDictionary *a3, CFComparisonResult (__cdecl *a4)(const void *, const void *, void *), unint64_t a5, int a6)
{
  CFArrayRef v9 = theArray;
  CFIndex Count = CFArrayGetCount(theArray);
  if (!Count)
  {
    *(void *)this = 0;
    return;
  }
  uint64_t v12 = Count;
  if (a3) {
    CFIndex v13 = CFDictionaryGetCount(a3);
  }
  else {
    CFIndex v13 = 0;
  }
  v108[0] = 0;
  if (v12 >= 2)
  {
    int v14 = v13 ? a6 : 1;
    if (a4 && v14)
    {
      v107[0] = (id)0xAAAAAAAAAAAAAAAALL;
      TCFMutableArray::TCFMutableArray((TCFMutableArray *)v107, v9);
      CFArrayRef explicit = (__CFArray *)atomic_load_explicit((atomic_ullong *volatile)v107, memory_order_acquire);
      v109.uint64_t length = CFArrayGetCount((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)v107, memory_order_acquire));
      v109.locatioCFIndex n = 0;
      CFArraySortValues(explicit, v109, a4, 0);
      CFArrayRef v9 = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)v107, memory_order_acquire);
    }
  }
  if (!v13)
  {
    *(void *)this = v9;
    goto LABEL_170;
  }
  v107[0] = 0;
  v107[1] = 0;
  CFTypeID TypeID = CFStringGetTypeID();
  CFRange v88 = a4;
  if (a3)
  {
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a3, @"NSCTFontPostScriptNameAttribute");
    if (Value)
    {
      CFStringRef v18 = Value;
      if (CFGetTypeID(Value) == TypeID) {
        CFStringRef v19 = v18;
      }
      else {
        CFStringRef v19 = 0;
      }
    }
    else
    {
      CFStringRef v19 = 0;
    }
    CFArrayRef v21 = (__CFString *)CFDictionaryGetValue(a3, @"NSFontNameAttribute");
    if (v21)
    {
      CFArrayRef v22 = v21;
      if (CFGetTypeID(v21) == TypeID) {
        CFArrayRef v23 = v22;
      }
      else {
        CFArrayRef v23 = 0;
      }
      long long v101 = v23;
    }
    else
    {
      long long v101 = 0;
    }
    CFStringRef v24 = (const __CFString *)CFDictionaryGetValue(a3, @"NSFontVisibleNameAttribute");
    if (v24)
    {
      CFStringRef v25 = v24;
      if (CFGetTypeID(v24) == TypeID) {
        CFStringRef v26 = v25;
      }
      else {
        CFStringRef v26 = 0;
      }
      CFStringRef v100 = v26;
    }
    else
    {
      CFStringRef v100 = 0;
    }
    CFStringRef v27 = (const __CFString *)CFDictionaryGetValue(a3, @"NSFontFamilyAttribute");
    if (v27)
    {
      CFStringRef v28 = v27;
      if (CFGetTypeID(v27) == TypeID) {
        CFStringRef v29 = v28;
      }
      else {
        CFStringRef v29 = 0;
      }
      CFStringRef v99 = v29;
    }
    else
    {
      CFStringRef v99 = 0;
    }
    uint64_t v30 = (__CFString *)CFDictionaryGetValue(a3, @"NSFontFaceAttribute");
    if (v30)
    {
      uint64_t v31 = v30;
      if (CFGetTypeID(v30) == TypeID) {
        uint64_t v32 = v31;
      }
      else {
        uint64_t v32 = 0;
      }
      double v98 = v32;
    }
    else
    {
      double v98 = 0;
    }
    CFBooleanRef v33 = (const __CFBoolean *)CFDictionaryGetValue(a3, @"NSCTFontUserInstalledAttribute");
    if (v33)
    {
      CFBooleanRef v34 = v33;
      CFTypeID v35 = CFGetTypeID(v33);
      if (v35 == CFBooleanGetTypeID()) {
        CFBooleanRef v36 = v34;
      }
      else {
        CFBooleanRef v36 = 0;
      }
      BOOLeaCFIndex n = v36;
    }
    else
    {
      BOOLeaCFIndex n = 0;
    }
    uint64_t v37 = (__CFURL *)CFDictionaryGetValue(a3, @"NSCTFontFileURLAttribute");
    if (v37)
    {
      uint64_t v38 = v37;
      CFTypeID v39 = CFGetTypeID(v37);
      if (v39 == CFURLGetTypeID()) {
        double v40 = v38;
      }
      else {
        double v40 = 0;
      }
      uint64_t v94 = v40;
    }
    else
    {
      uint64_t v94 = 0;
    }
    unint64_t v41 = (__CFNumber *)CFDictionaryGetValue(a3, @"NSCTFontFormatAttribute");
    if (v41)
    {
      uint64_t v42 = v41;
      CFTypeID v43 = CFGetTypeID(v41);
      if (v43 == CFNumberGetTypeID()) {
        uint64_t v44 = v42;
      }
      else {
        uint64_t v44 = 0;
      }
      unsigned int v92 = v44;
    }
    else
    {
      unsigned int v92 = 0;
    }
    uint64_t v45 = (__CFNumber *)CFDictionaryGetValue(a3, @"NSCTFontRegistrationScopeAttribute");
    if (v45)
    {
      double v46 = v45;
      CFTypeID v47 = CFGetTypeID(v45);
      if (v47 == CFNumberGetTypeID()) {
        double v48 = v46;
      }
      else {
        double v48 = 0;
      }
      uint64_t v91 = v48;
    }
    else
    {
      uint64_t v91 = 0;
    }
    CFNumberRef v49 = (const __CFNumber *)CFDictionaryGetValue(a3, @"NSCTFontDomainAttribute");
    if (v49)
    {
      CFNumberRef v50 = v49;
      CFTypeID v51 = CFGetTypeID(v49);
      if (v51 == CFNumberGetTypeID()) {
        CFNumberRef v52 = v50;
      }
      else {
        CFNumberRef v52 = 0;
      }
      CFNumberRef number = v52;
    }
    else
    {
      CFNumberRef number = 0;
    }
    id v106 = (id)0xAAAAAAAAAAAAAAAALL;
    id v20 = (void *)CFDictionaryGetValue(a3, @"NSCTFontDesignLanguagesAttribute");
    if (v20)
    {
      uint64_t v53 = v20;
      CFTypeID v54 = CFGetTypeID(v20);
      if (v54 == CFArrayGetTypeID()) {
        id v20 = v53;
      }
      else {
        id v20 = 0;
      }
    }
  }
  else
  {
    CFStringRef v19 = 0;
    long long v101 = 0;
    CFStringRef v99 = 0;
    CFStringRef v100 = 0;
    double v98 = 0;
    BOOLeaCFIndex n = 0;
    CFNumberRef number = 0;
    uint64_t v94 = 0;
    uint64_t v91 = 0;
    unsigned int v92 = 0;
    id v20 = 0;
    id v106 = (id)0xAAAAAAAAAAAAAAAALL;
  }
  values[0] = v20;
  id v106 = (id)atomic_exchange((atomic_ullong *volatile)values, 0);

  if (a3)
  {
    unint64_t v55 = (void *)CFDictionaryGetValue(a3, @"NSCTFontDesignLanguagesAttribute");
    if (v55)
    {
      double v56 = v55;
      if (CFGetTypeID(v55) == TypeID)
      {
        values[0] = v56;
        CFArrayRef v105 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)values, 1, MEMORY[0x1E4F1D510]);
      }
    }
    CFArrayRef v105 = (CFArrayRef)0xAAAAAAAAAAAAAAAALL;
    unint64_t v57 = (void *)CFDictionaryGetValue(a3, @"NSCTFontLanguagesAttribute");
    if (v57)
    {
      double v58 = v57;
      CFTypeID v59 = CFGetTypeID(v57);
      if (v59 == CFArrayGetTypeID()) {
        unint64_t v57 = v58;
      }
      else {
        unint64_t v57 = 0;
      }
    }
  }
  else
  {
    unint64_t v57 = 0;
    CFArrayRef v105 = (CFArrayRef)0xAAAAAAAAAAAAAAAALL;
  }
  values[0] = v57;
  CFArrayRef v105 = (CFArrayRef)atomic_exchange((atomic_ullong *volatile)values, 0);

  if (a3)
  {
    uint64_t v60 = (void *)CFDictionaryGetValue(a3, @"NSCTFontLanguagesAttribute");
    if (v60)
    {
      double v61 = v60;
      if (CFGetTypeID(v60) == TypeID)
      {
        values[0] = v61;
        CFArrayRef valuePtr = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)values, 1, MEMORY[0x1E4F1D510]);
      }
    }
    unint64_t v62 = (__CFDictionary *)CFDictionaryGetValue(a3, @"NSCTFontTraitsAttribute");
    if (v62)
    {
      unint64_t v63 = v62;
      CFTypeID v64 = CFGetTypeID(v62);
      if (v64 == CFDictionaryGetTypeID()) {
        int v65 = v63;
      }
      else {
        int v65 = 0;
      }
      int64x2_t v96 = v65;
    }
    else
    {
      int64x2_t v96 = 0;
    }
    uint64_t v66 = (__CFCharacterSet *)CFDictionaryGetValue(a3, @"NSCTFontCharacterSetAttribute");
    if (v66)
    {
      uint64_t v67 = v66;
      CFTypeID v68 = CFGetTypeID(v66);
      if (v68 == CFCharacterSetGetTypeID()) {
        double v69 = v67;
      }
      else {
        double v69 = 0;
      }
      uint64_t v97 = v69;
      goto LABEL_106;
    }
  }
  else
  {
    int64x2_t v96 = 0;
  }
  uint64_t v97 = 0;
LABEL_106:
  int v95 = a6;
  if ((a5 & 8) != 0) {
    char v70 = a6;
  }
  else {
    char v70 = 1;
  }
  char v87 = v70;
  values[0] = 0;
  values[1] = 0;
  BOOL v93 = ShouldFilterInvisibles(a3, a5);
  if (!v9 || (CFIndex v71 = CFArrayGetCount(v9)) == 0)
  {
LABEL_155:
    if (v95)
    {
      if ((a5 >> 2) & 1 | v93)
      {
        CFArrayRef v80 = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)values, memory_order_acquire);
        if (v80)
        {
          if (CFArrayGetCount(v80) >= 1)
          {
            CFDictionaryRef ValueAtIndex = (void *)CFArrayGetValueAtIndex((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)values, memory_order_acquire), 0);
            goto LABEL_160;
          }
        }
      }
    }
    CFArrayRef v82 = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)v107, memory_order_acquire);
    if (!v82 || (CFIndex v83 = CFArrayGetCount(v82), v83 < 1))
    {
      *(void *)this = 0;
      goto LABEL_169;
    }
    if (v83 != 1)
    {
      if ((v87 & 1) == 0)
      {
        CreateDescriptorArrayFilteringDuplicates(&valuePtr, (CFComparisonResult (*)(const void *, const void *, void *))atomic_load_explicit((atomic_ullong *volatile)v107, memory_order_acquire), v88);
        *(void *)this = atomic_exchange((atomic_ullong *volatile)&valuePtr, 0);

        goto LABEL_169;
      }
      if (v88) {
        TCFLazyMutableArray::Sort((TCFLazyMutableArray *)v107, v88, v84);
      }
    }
    *(void *)this = atomic_exchange((atomic_ullong *volatile)v107, 0);
    goto LABEL_169;
  }
  CFIndex v72 = v71;
  CFIndex v73 = 0;
  double v74 = (TDescriptor **)*MEMORY[0x1E4F1D260];
  while (1)
  {
    long long v75 = (TDescriptor **)CFArrayGetValueAtIndex(v9, v73);
    if (v75 == v74) {
      goto LABEL_154;
    }
    double v76 = v75;
    double v77 = v75[5];
    if ((*((_DWORD *)v77 + 4) & 0x80000000) == 0) {
      TDescriptor::InitBaseFont(v75[5], a5, 0.0);
    }
    uint64_t v78 = (atomic_ullong *)atomic_load_explicit((atomic_ullong *volatile)v77 + 4, memory_order_acquire);
    if (!v78 || v19 && !ComparePostScriptName(v19, v78)) {
      goto LABEL_154;
    }
    if (v101 && !CompareName(v101, v78, (a5 & 0x40) != 0, (a5 & 0x200) != 0)) {
      goto LABEL_154;
    }
    if ((unint64_t)v100 | (unint64_t)v99 | (unint64_t)v98
      && !CompareOtherNamesInclusive(v100, v99, v98, (const TBaseFont *)v78, (a5 & 0x40) != 0))
    {
      goto LABEL_154;
    }
    if (atomic_load_explicit((atomic_ullong *volatile)&v106, memory_order_acquire)
      && !CompareDesignLanguages((const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v106, memory_order_acquire), (const TBaseFont *)v78))
    {
      goto LABEL_154;
    }
    if (atomic_load_explicit((atomic_ullong *volatile)&v105, memory_order_acquire)
      && !CompareSupportedLanguages((const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v105, memory_order_acquire), (const TBaseFont *)v78))
    {
      goto LABEL_154;
    }
    if (v97 && !CompareCharSet(v97, v78)) {
      goto LABEL_154;
    }
    if (v96 && !CompareTraits(v96, (const TBaseFont *)v78)) {
      goto LABEL_154;
    }
    if (v94 && !CompareFileURL(v94, (const TBaseFont *)v78)) {
      goto LABEL_154;
    }
    if (v92 && !CompareFormat(v92, (const TBaseFont *)v78)) {
      goto LABEL_154;
    }
    if (v91 && !CompareScope(v91, (const TBaseFont *)v78)) {
      goto LABEL_154;
    }
    if (number)
    {
      LODWORD(valuePtr) = -1431655766;
      CFNumberGetValue(number, kCFNumberIntType, &valuePtr);
      int v85 = (int)valuePtr;
      if (((*(unsigned int (**)(atomic_ullong *))(*v78 + 272))(v78) & v85) == 0) {
        goto LABEL_154;
      }
    }
    if (BOOLean)
    {
      IsUserInstalleCGFloat d = TBaseFont::IsUserInstalled((TBaseFont *)v78);
      if (CFBooleanGetValue(BOOLean) != IsUserInstalled) {
        goto LABEL_154;
      }
    }
    if ((a5 & 4) == 0 || ((*(uint64_t (**)(atomic_ullong *))(*v78 + 704))(v78))
      && (!v93
       || !(*(unsigned int (**)(atomic_ullong *))(*v78 + 696))(v78)
       || a3
       && (CFDictionaryGetValue(a3, @"NSFontNameAttribute")
        || CFDictionaryGetValue(a3, @"NSFontFamilyAttribute")))
      && ((a5 & 0x2000) == 0 || !(*(unsigned int (**)(atomic_ullong *))(*v78 + 688))(v78)))
    {
      break;
    }
    if (v95)
    {
      TCFLazyMutableArray::LazyCreate((TCFLazyMutableArray *)values);
      uint64_t v79 = values;
LABEL_153:
      CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)v79, memory_order_acquire), v76);
    }
LABEL_154:
    if (v72 == ++v73) {
      goto LABEL_155;
    }
  }
  if ((v95 & 1) == 0)
  {
    TCFLazyMutableArray::LazyCreate((TCFLazyMutableArray *)v107);
    uint64_t v79 = v107;
    goto LABEL_153;
  }
  CFDictionaryRef ValueAtIndex = v76;
LABEL_160:
  *(void *)this = ValueAtIndex;
LABEL_169:

LABEL_170:
}

BOOL TBaseFont::IsUserInstalled(TBaseFont *this)
{
  id v4 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr))(*(void *)this + 200))(&v4);
  CFURLRef explicit = (const __CFURL *)atomic_load_explicit((atomic_ullong *volatile)&v4, memory_order_acquire);
  if (explicit)
  {
    id v5 = 0;
    if (CFURLGetBaseURL(explicit))
    {

      CFURLRef explicit = (const __CFURL *)atomic_load_explicit((atomic_ullong *volatile)&v5, memory_order_acquire);
    }
    CFURLRef explicit = (const __CFURL *)CFURLCopyFileSystemPath(explicit, kCFURLPOSIXPathStyle);
  }
  BOOL v2 = !IsSystemFontPath((CFStringRef)explicit);

  return v2;
}

void TDescriptorSource::CopyDescriptorsForRequest(void *cf@<X1>, atomic_ullong **a2@<X0>, const __CFSet *a3@<X2>, CFComparisonResult (__cdecl *a4)(const void *, const void *, void *)@<X3>, unint64_t a5@<X4>, atomic_ullong *a6@<X5>, atomic_ullong *a7@<X8>)
{
  uint64_t v131 = *MEMORY[0x1E4F143B8];
  CFTypeID v14 = CFGetTypeID(cf);
  CFTypeID TypeID = CFDictionaryGetTypeID();
  *a7 = 0;
  if (v14 == TypeID)
  {
    id v121 = (id)0xAAAAAAAAAAAAAAAALL;
    TDescriptorSource::CopyMandatoryMatchableRequest((const __CFDictionary *)cf, a3, &v121);
    double v118 = a4;
    if ((a5 & 0x20) != 0)
    {
      int v16 = 0;
    }
    else if (dispatch_get_specific((const void *)TDescriptorSource::DoNotCacheKey))
    {
      int v16 = 0;
      a5 |= 0x20uLL;
    }
    else
    {
      if (TDescriptorSource::CopyCachedDescriptors(a2, (void *)atomic_load_explicit((atomic_ullong *volatile)&v121, memory_order_acquire), (void *)a5, a7, a4))goto LABEL_145; {
      int v16 = 1;
      }
    }
    CFDictionaryRef v17 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)&v121, memory_order_acquire);
    CFDictionaryRef v18 = v17;
    if (v17) {
      CFIndex Count = CFDictionaryGetCount(v17);
    }
    else {
      CFIndex Count = 0;
    }

    SInt32 valuePtr = 0;
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"NSCTFontDownloadableAttribute");
    if (Value)
    {
      CFNumberRef v21 = Value;
      CFTypeID v22 = CFGetTypeID(Value);
      if (v22 == CFNumberGetTypeID() || v22 == CFBooleanGetTypeID())
      {
        CFNumberGetValue(v21, kCFNumberIntType, &valuePtr);
      }
      else if (v22 == CFStringGetTypeID())
      {
        SInt32 valuePtr = CFStringGetIntValue((CFStringRef)v21);
      }
    }
    SInt32 v23 = valuePtr;
    if (Count <= 0 && !valuePtr)
    {
      *(double *)&id v125 = -3.72066208e-103;
      TDescriptorSource::CreateDefaultDescriptor(0, &v125);
      if (atomic_load_explicit((atomic_ullong *volatile)&v125, memory_order_acquire))
      {
        id values = (void *)atomic_load_explicit((atomic_ullong *volatile)&v125, memory_order_acquire);
        id v124 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&values, 1, MEMORY[0x1E4F1D510]);
      }
      goto LABEL_55;
    }
    if ((a5 & 0x10) != 0)
    {
LABEL_52:
      if ((a5 & 0x200) == 0 && v23)
      {
        TDescriptorSource::CopyDownloadableDescriptorsForRequest((TDescriptorSource *)atomic_load_explicit((atomic_ullong *volatile)&v121, memory_order_acquire), (const __CFDictionary *)a5, &values);

        int v16 = 0;
LABEL_55:
        unint64_t v41 = a5;
LABEL_56:
        CFArrayRef v42 = (const __CFArray *)(id)atomic_load_explicit(a7, memory_order_acquire);
        CFArrayRef v43 = v42;
        if (v42) {
          CFIndex v44 = CFArrayGetCount(v42);
        }
        else {
          CFIndex v44 = 0;
        }
        SInt32 v45 = valuePtr;

        if (v44 >= 2 && !v45)
        {
          BOOL v47 = ShouldFilterInvisibles((CFDictionaryRef)cf, v41);
          int v48 = (v41 >> 2) & 1 | v47;
          if ((v41 & 8) != 0 || v48)
          {
            id values = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
            if (v48)
            {
              int theDict = v16;
              CFNumberRef v49 = a7;
              CFArrayRef explicit = (const __CFArray *)atomic_load_explicit(a7, memory_order_acquire);
              if (explicit)
              {
                CFIndex v51 = CFArrayGetCount(explicit);
                if (v51)
                {
                  CFIndex v52 = v51;
                  for (CFIndex i = 0; i != v52; ++i)
                  {
                    CFDictionaryRef ValueAtIndex = (TDescriptor **)CFArrayGetValueAtIndex(explicit, i);
                    unint64_t v55 = ValueAtIndex;
                    double v56 = ValueAtIndex[5];
                    if ((*((_DWORD *)v56 + 4) & 0x80000000) == 0) {
                      TDescriptor::InitBaseFont(ValueAtIndex[5], 0, 0.0);
                    }
                    unint64_t v57 = atomic_load_explicit((atomic_ullong *volatile)v56 + 4, memory_order_acquire);
                    if (v57
                      && (!v47 || ((*(uint64_t (**)(unint64_t))(*(void *)v57 + 696))(v57) & 1) == 0)
                      && ((v41 & 4) == 0
                       || (*(unsigned int (**)(unint64_t))(*(void *)v57 + 704))(v57)))
                    {
                      CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&values, memory_order_acquire), v55);
                    }
                  }
                }
              }
              a7 = v49;

              int v16 = theDict;
            }
            if ((v41 & 8) != 0)
            {
              CreateDescriptorArrayFilteringDuplicates((CFArrayRef *)&v125, (CFComparisonResult (*)(const void *, const void *, void *))atomic_load_explicit(a7, memory_order_acquire), v118);
            }
          }
        }
        if (cf)
        {
          if ((v41 & 0x100) != 0)
          {
            CFIndex v58 = CFDictionaryGetCount((CFDictionaryRef)cf);
            if (v58 >= 1)
            {
              CFIndex v59 = v58;
              uint64_t v114 = (__CFString *)a7;
              *(void *)&long long v60 = 0xAAAAAAAAAAAAAAAALL;
              *((void *)&v60 + 1) = 0xAAAAAAAAAAAAAAAALL;
              v129[14] = v60;
              v129[13] = v60;
              v129[12] = v60;
              v129[11] = v60;
              v129[10] = v60;
              v129[9] = v60;
              v129[8] = v60;
              v129[7] = v60;
              v129[6] = v60;
              v129[5] = v60;
              v129[4] = v60;
              v129[3] = v60;
              v129[2] = v60;
              v129[1] = v60;
              v129[0] = v60;
              int v127 = 0;
              uint64_t v128 = 0;
              id values = 0;
              uint64_t v130 = v129;
              std::vector<long,TInlineBufferAllocator<long,30ul>>::__vallocate[abi:nn180100](&values, v58);
              double v61 = (char *)v127;
              bzero(v127, 8 * v59);
              int v127 = &v61[8 * v59];
              CFDictionaryGetKeysAndValues((CFDictionaryRef)cf, (const void **)values, 0);
              CFAllocatorRef allocatora = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
              id Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D548]);
              uint64_t v63 = 0;
              while (1)
              {
                CFTypeID v64 = (__CFString *)*((void *)values + v63);
                int v65 = @"NSFontSizeAttribute";
                if (v64 == @"NSFontSizeAttribute") {
                  goto LABEL_89;
                }
                if (@"NSFontSizeAttribute" && v64 && CFEqual(v64, @"NSFontSizeAttribute")) {
                  break;
                }
LABEL_92:
                CFSetAddValue(Mutable, *((const void **)values + v63));
LABEL_93:
                if (v59 == ++v63)
                {
                  if (qword_1EB2CE1D0 != -1) {
                    dispatch_once_f(&qword_1EB2CE1D0, 0, (dispatch_function_t)TDescriptorSource::GetMatchableAttributes(void)::$_0::__invoke);
                  }
                  if (qword_1EB2CE1C8) {
                    -[__CFSet minusSet:](Mutable, "minusSet:");
                  }
                  if (CFSetGetCount(Mutable))
                  {
                    *(double *)&id v125 = -3.72066208e-103;
                    CreateCopyOfDictionaryFilteredByKeys((const __CFDictionary *)cf, Mutable, &v125);
                    CFDictionaryRef v69 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)&v125, memory_order_acquire);
                    if (v69)
                    {
                      CFDictionaryRef v70 = v69;
                      CFIndex v71 = CFDictionaryGetCount(v69);

                      if (v71 >= 1)
                      {
                        id v124 = CFArrayCreateMutable(allocatora, 0, MEMORY[0x1E4F1D510]);
                        CFArrayRef v72 = (const __CFArray *)atomic_load_explicit(a7, memory_order_acquire);
                        if (v72)
                        {
                          CFIndex v73 = CFArrayGetCount(v72);
                          if (v73)
                          {
                            CFIndex v74 = v73;
                            for (CFIndex j = 0; j != v74; ++j)
                            {
                              id v122 = (id)CFArrayGetValueAtIndex(v72, j);
                              CFDictionaryRef v119 = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v125, memory_order_acquire);
                              TCFBase_NEW<CTFontDescriptor,CTFontDescriptor*,__CFDictionary const*&>((uint64_t *)&v122, &v119, &v123);
                              double v76 = (void *)atomic_exchange((atomic_ullong *volatile)&v123, 0);

                              id v77 = v76;
                              CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v124, memory_order_acquire), v77);
                            }
                          }
                        }
                        a7 = (atomic_ullong *)v114;
                      }
                    }
                    else
                    {
                    }
                  }

                  *(double *)&id v125 = COERCE_DOUBLE(&values);
                  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v125);
                  goto LABEL_131;
                }
              }
              int v65 = (__CFString *)*((void *)values + v63);
LABEL_89:
              CFNumberRef v66 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, v65);
              if (v66)
              {
                CFNumberRef v67 = v66;
                CFTypeID v68 = CFGetTypeID(v66);
                if (v68 != CFNumberGetTypeID()) {
                  goto LABEL_93;
                }
                *(double *)&id v125 = NAN;
                CFNumberGetValue(v67, kCFNumberDoubleType, &v125);
                if (*(double *)&v125 == 0.0) {
                  goto LABEL_93;
                }
              }
              goto LABEL_92;
            }
          }
        }
LABEL_131:
        if (v16)
        {
          BOOL v93 = (void *)atomic_load_explicit((atomic_ullong *volatile)&v121, memory_order_acquire);
          CFArrayRef v94 = (const __CFArray *)atomic_load_explicit(a7, memory_order_acquire);
          if (v94 && CFArrayGetCount(v94))
          {
            id values = 0;
            int v127 = 0;
            CFIndex v95 = CFArrayGetCount(v94);
            if (v95)
            {
              CFIndex v96 = v95;
              for (CFIndex k = 0; k != v96; ++k)
              {
                double v98 = CFArrayGetValueAtIndex(v94, k);
                uint64_t v99 = *((void *)v98 + 5);
                if ((*(_DWORD *)(v99 + 16) & 0x80000000) == 0) {
                  TDescriptor::InitBaseFont(*((TDescriptor **)v98 + 5), 0, 0.0);
                }
                unint64_t v100 = atomic_load_explicit((atomic_ullong *volatile)(v99 + 32), memory_order_acquire);
                if (v100)
                {
                  *(double *)&id v125 = -3.72066208e-103;
                  (*(void (**)(id *__return_ptr))(*(void *)v100 + 200))(&v125);
                  if (atomic_load_explicit((atomic_ullong *volatile)&v125, memory_order_acquire))
                  {
                    id v101 = (id)atomic_load_explicit((atomic_ullong *volatile)&v125, memory_order_acquire);
                    TCFLazyMutableArray::LazyCreate((TCFLazyMutableArray *)&values);
                    CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&values, memory_order_acquire), v101);
                  }
                }
              }
            }
            TPerThreadLRUCache<TRequestCacheNode,(ThreadSpecificKey)3,16ul>::TPerThreadLRUCache(&v125);
            TRequestCache::AddResultForRequest((TRequestCache *)&v125, (void *)atomic_load_explicit((atomic_ullong *volatile)&values, memory_order_acquire), v93, (void *)v41, (CFComparisonResult (*)(const void *, const void *, void *))v118);
          }
          else
          {
            TDescriptorSource::AddMissedRequest((TDescriptorSource *)v93, (const void *)v41, (uint64_t)v118, v46);
          }
        }
        goto LABEL_145;
      }
      CFArrayRef allocatorb = a6;
      uint64_t v115 = a2;
      CFDictionaryRef v78 = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v121, memory_order_acquire);
      id v123 = (id)0xAAAAAAAAAAAAAAAALL;
      uint64_t v79 = (__CFString *)CFDictionaryGetValue(v78, @"NSFontFamilyAttribute");
      if (v79)
      {
        uint64_t v81 = v79;
        CFTypeID v82 = CFGetTypeID(v79);
        if (v82 == CFStringGetTypeID())
        {
          id values = (void *)0xAAAAAAAAAAAAAAAALL;
          TDescriptorSource::CopyDescriptorsForRequestWithFamilyName((TDescriptorSource *)&values, (const __CFString *)a2, v81, a5);
          if (atomic_load_explicit((atomic_ullong *volatile)&values, memory_order_acquire))
          {
            *(double *)&id v125 = -3.72066208e-103;
            TCFMutableDictionary::TCFMutableDictionary((TCFMutableDictionary *)&v125, v78);
            CFDictionaryRemoveValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v125, memory_order_acquire), @"NSFontFamilyAttribute");
            if (ShouldFilterInvisibles(v78, a5)) {
              unint64_t v83 = a5;
            }
            else {
              unint64_t v83 = a5 | 2;
            }
            CFArrayRef v84 = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&values, memory_order_acquire);
            CFDictionaryRef v85 = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v125, memory_order_acquire);
            if ((char *)v118 == (char *)CompareDescriptorsByTraitsAndPrecedence) {
              long long v86 = (CFComparisonResult (__cdecl *)(const void *, const void *, void *))CompareDescriptorsByTraitsAndPrecedenceForSingleFamily;
            }
            else {
              long long v86 = v118;
            }
            TDescriptorSource::CopyDescriptorsForRequestFromArray((TDescriptorSource *)&v124, v84, v85, v86, v83, 0);
            id v123 = (id)atomic_exchange((atomic_ullong *volatile)&v124, 0);
          }
          else
          {

            id v123 = 0;
          }
          atomic_load_explicit((atomic_ullong *volatile)&v123, memory_order_acquire);
          unint64_t v41 = a5;
          goto LABEL_158;
        }
      }
      id v123 = 0;
      unint64_t v41 = a5;
      if (atomic_load_explicit((atomic_ullong *volatile)&v123, memory_order_acquire))
      {
LABEL_158:
        id values = (void *)atomic_exchange((atomic_ullong *volatile)&v123, 0);
LABEL_159:

        if (!atomic_load_explicit(a7, memory_order_acquire) && Count == 1 && (a5 & 0x200) == 0)
        {
          CFStringRef PostScriptNameAndAttribute = (const __CFString *)TDescriptorSource::GetPostScriptNameAndAttribute((TDescriptorSource *)atomic_load_explicit((atomic_ullong *volatile)&v121, memory_order_acquire), v104);
          if (PostScriptNameAndAttribute)
          {
            *(double *)&id v125 = -3.72066208e-103;
            TDescriptorSource::CopyFontDescriptorPerPostScriptName(v115, PostScriptNameAndAttribute, v41, 0, 0, &v125);
            if (atomic_load_explicit((atomic_ullong *volatile)&v125, memory_order_acquire))
            {
              id values = (void *)atomic_load_explicit((atomic_ullong *volatile)&v125, memory_order_acquire);
              id v124 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&values, 1, MEMORY[0x1E4F1D510]);
            }
          }
        }
        goto LABEL_56;
      }
      *(double *)&id v125 = 0.0;
      CFDictionaryRef theDicta = v78;
      CFRange v88 = (__CFString *)TDescriptorSource::GetPostScriptNameAndAttribute(v78, v80);
      if (v88)
      {
        uint64_t v89 = v87;
        id v124 = (id)0xAAAAAAAAAAAAAAAALL;
        TDescriptorSource::CopyFontDescriptorPerPostScriptName(a2, v88, a5, 1, 0, &v124);
        if (atomic_load_explicit((atomic_ullong *volatile)&v124, memory_order_acquire))
        {
          id values = (void *)atomic_load_explicit((atomic_ullong *volatile)&v124, memory_order_acquire);
          id v122 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&values, 1, MEMORY[0x1E4F1D510]);
        }
        char v87 = v89;
      }
      unint64_t v41 = a5;
      if (atomic_load_explicit((atomic_ullong *volatile)&v125, memory_order_acquire)
        || (unint64_t v41 = a5, (a5 & 0x200) != 0)
        || (unint64_t v41 = a5, @"NSFontNameAttribute" != v87))
      {
LABEL_122:
        if (atomic_load_explicit((atomic_ullong *volatile)&v125, memory_order_acquire))
        {
          if (v118 || (v41 & 0x1000) == 0)
          {
            TDescriptorSource::CopyDescriptorsForRequestFromArray((TDescriptorSource *)&values, (CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v125, memory_order_acquire), theDicta, v118, v41, 0);
          }
          else
          {
            int v90 = v16;
            uint64_t v91 = a7;
            TDescriptorSource::CopyDescriptorsForRequestFromArray((TDescriptorSource *)&values, (CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v125, memory_order_acquire), theDicta, 0, v41, 1);
            unsigned int v92 = (void *)atomic_exchange((atomic_ullong *volatile)&values, 0);

            if (v92)
            {
              id values = v92;
              id v124 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&values, 1, MEMORY[0x1E4F1D510]);
            }
            a7 = v91;
            int v16 = v90;
          }
        }

        goto LABEL_158;
      }
      BOOL v102 = IsLooseFontNameMatchingDisabled();
      if (v88 && v102 && CFDictionaryGetCount(v78) == 1)
      {
        unint64_t v41 = a5;
        if (TDescriptorSource::AddMissedRequest((TDescriptorSource *)v88, (const void *)a5, (uint64_t)v118, v103))
        {
          CFLog();
          unint64_t v41 = a5;
        }
        goto LABEL_122;
      }
      unint64_t v41 = a5 | 0x40;
      if ((a5 & 0x20) == 0
        && TDescriptorSource::CopyCachedDescriptors(a2, v78, (void *)(a5 | 0x40), (atomic_ullong *)&v123, v118))
      {
        id values = (void *)atomic_exchange((atomic_ullong *volatile)&v123, 0);
LABEL_169:

        goto LABEL_159;
      }
      CFStringRef v106 = (const __CFString *)CFDictionaryGetValue(v78, @"NSFontVisibleNameAttribute");
      if (v106)
      {
        CFStringRef v107 = v106;
        CFTypeID v108 = CFGetTypeID(v106);
        if (v108 == CFStringGetTypeID())
        {
          CFRange v109 = CGFontCreateWithFontName(v107);
          if (v109)
          {
            id v124 = (id)0xAAAAAAAAAAAAAAAALL;
            TDescriptorSource::CopyDescriptor(a2, v109, 0, (atomic_ullong *)&v124);
            if (atomic_load_explicit((atomic_ullong *volatile)&v124, memory_order_acquire))
            {
              id values = (void *)atomic_load_explicit((atomic_ullong *volatile)&v124, memory_order_acquire);
              id v122 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&values, 1, MEMORY[0x1E4F1D510]);

              if (CFDictionaryGetCount(theDicta) == 1)
              {
                id values = (void *)atomic_exchange((atomic_ullong *volatile)&v125, 0);

                goto LABEL_169;
              }
            }
          }
        }
      }
      unint64_t v110 = atomic_load_explicit((atomic_ullong *volatile)&v125, memory_order_acquire);
      if (allocatorb && !v110) {
        TCFRef<__CTFont const*>::Retain((atomic_ullong *)&v125, (id)atomic_load_explicit(allocatorb, memory_order_acquire));
      }
      if (!atomic_load_explicit((atomic_ullong *volatile)&v125, memory_order_acquire))
      {
        TDescriptorSource::CopyAllDescriptorsInternal(a2, 0, a5 | 0x40, &values);

        if (allocatorb) {
          TCFRef<__CTFont const*>::Retain(allocatorb, (id)atomic_load_explicit((atomic_ullong *volatile)&v125, memory_order_acquire));
        }
      }
      goto LABEL_122;
    }
    *(double *)&id v125 = -3.72066208e-103;
    TDescriptorSource::CopySplicedDescriptorsForRequest((CFArrayRef *)&v125, (TDescriptorSource *)a2, (CFDictionaryRef)cf, a5, 0, 0, 0, -1, *MEMORY[0x1E4F1CFC8]);
    CFArrayRef v24 = (const __CFArray *)(id)atomic_load_explicit((atomic_ullong *volatile)&v125, memory_order_acquire);
    if (v24)
    {
      CFArrayRef v25 = v24;
      uint64_t v26 = CFArrayGetCount(v24);

      if (v26 >= 1
        && (CFDictionaryContainsKey((CFDictionaryRef)cf, @"NSFontFamilyAttribute")
         || TDescriptorSource::GetPostScriptNameAndAttribute((TDescriptorSource *)cf, v27)))
      {
        goto LABEL_30;
      }
    }
    else
    {

      uint64_t v26 = 0;
    }
    if (!CFDictionaryContainsKey((CFDictionaryRef)cf, @"NSCTFontUIUsageAttribute"))
    {
      CFDictionaryRef v36 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)cf, @"NSCTFontTraitsAttribute");
      if (!v36
        || (v37 = v36, v38 = a6, v39 = CFGetTypeID(v36), BOOL v40 = v39 == CFDictionaryGetTypeID(), a6 = v38, !v40)
        || !CFDictionaryGetValue(v37, @"NSCTFontUIFontDesignTrait"))
      {
        id v124 = 0;
        goto LABEL_50;
      }
    }
LABEL_30:
    if (v118 && v26 >= 2)
    {
      CFAllocatorRef allocator = (CFAllocatorRef)a6;
      id values = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v26, MEMORY[0x1E4F1D510]);
      CFArrayRef v28 = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v125, memory_order_acquire);
      if (v28)
      {
        CFIndex v29 = CFArrayGetCount(v28);
        if (v29)
        {
          CFIndex v30 = v29;
          CFIndex v31 = 0;
          uint64_t v32 = (const void *)*MEMORY[0x1E4F1D260];
          do
          {
            CFBooleanRef v33 = CFArrayGetValueAtIndex(v28, v31);
            if (v33 != v32) {
              CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&values, memory_order_acquire), v33);
            }
            ++v31;
          }
          while (v30 != v31);
        }
      }
      if (CFArrayGetCount((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&values, memory_order_acquire)) > 1)
      {
        if ((char *)v118 == (char *)CompareDescriptorsByTraitsAndPrecedence) {
          CFBooleanRef v34 = (CFComparisonResult (__cdecl *)(const void *, const void *, void *))CompareDescriptorsByTraitsAndPrecedenceForSingleFamily;
        }
        else {
          CFBooleanRef v34 = v118;
        }
        CFTypeID v35 = (__CFArray *)atomic_load_explicit((atomic_ullong *volatile)&values, memory_order_acquire);
        v132.uint64_t length = CFArrayGetCount((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&values, memory_order_acquire));
        v132.locatioCFIndex n = 0;
        CFArraySortValues(v35, v132, v34, 0);
      }
      id v124 = (id)atomic_exchange((atomic_ullong *volatile)&values, 0);

      a6 = (atomic_ullong *)allocator;
    }
    else
    {
      id v124 = (id)atomic_load_explicit((atomic_ullong *volatile)&v125, memory_order_acquire);
    }
LABEL_50:

    if (!atomic_load_explicit(a7, memory_order_acquire))
    {
      SInt32 v23 = valuePtr;
      goto LABEL_52;
    }
LABEL_145:
  }
}

void TCFLazyMutableArray::LazyCreate(TCFLazyMutableArray *this)
{
  if (!atomic_load_explicit((atomic_ullong *volatile)this, memory_order_acquire))
  {
    CFArrayRef v2 = (const __CFArray *)*((void *)this + 1);
    CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    if (v2) {
      MutableCopCGFloat y = CFArrayCreateMutableCopy(v3, 0, v2);
    }
    else {
      MutableCopCGFloat y = CFArrayCreateMutable(v3, 0, MEMORY[0x1E4F1D510]);
    }
    id v5 = (void *)atomic_exchange((atomic_ullong *volatile)this, (unint64_t)MutableCopy);
  }
}

BOOL ShouldFilterInvisibles(CFDictionaryRef theDict, char a2)
{
  if ((a2 & 2) != 0) {
    return 0;
  }
  if (!theDict) {
    return 1;
  }
  if (CFDictionaryGetValue(theDict, @"NSFontNameAttribute")) {
    return 0;
  }
  return CFDictionaryGetValue(theDict, @"NSFontFamilyAttribute") == 0;
}

uint64_t TDescriptorSource::CopyCachedDescriptors(atomic_ullong **a1, void *a2, void *a3, atomic_ullong *a4, void *a5)
{
  if (!TDescriptorSource::HasMissedRequest((TDescriptorSource *)a2, a3, a5, v10))
  {
    id v24 = 0;
    TPerThreadLRUCache<TRequestCacheNode,(ThreadSpecificKey)3,16ul>::TPerThreadLRUCache(&Mutable);
    uint64_t v11 = TRequestCache::CopyResultForRequest((uint64_t *)&Mutable, a2, a3, (atomic_ullong *)&v24, a5);
    if (!v11 || !atomic_load_explicit((atomic_ullong *volatile)&v24, memory_order_acquire))
    {
LABEL_20:

      return v11;
    }
    id Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    CFTypeID v12 = CFGetTypeID((CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)&v24, memory_order_acquire));
    if (v12 == CFArrayGetTypeID())
    {
      CFArrayRef v13 = (const __CFArray *)(id)atomic_load_explicit((atomic_ullong *volatile)&v24, memory_order_acquire);
      if (v13)
      {
        CFArrayRef v14 = v13;
        CFIndex Count = CFArrayGetCount(v13);

        if (Count)
        {
          for (CFIndex i = 0; i != Count; ++i)
          {
            CFURLRef ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex(v14, i);
            id v22 = (id)0xAAAAAAAAAAAAAAAALL;
            TDescriptorSource::CopyDescriptor(a1, ValueAtIndex, 0, 0, &v22);
            id v21 = (id)0xAAAAAAAAAAAAAAAALL;
            TDescriptorSource::CopyFontDescriptorWithOptions((atomic_ullong *)&v22, (int)a3, 0, &v21);
            if (atomic_load_explicit((atomic_ullong *volatile)&v21, memory_order_acquire))
            {
              id v18 = (id)atomic_load_explicit((atomic_ullong *volatile)&v21, memory_order_acquire);
              CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), v18);
            }
          }
        }
        goto LABEL_17;
      }
    }
    else
    {
      id v22 = (id)0xAAAAAAAAAAAAAAAALL;
      TDescriptorSource::CopyDescriptor(a1, (const __CFURL *)atomic_load_explicit((atomic_ullong *volatile)&v24, memory_order_acquire), 0, 0, &v22);
      id v21 = (id)0xAAAAAAAAAAAAAAAALL;
      TDescriptorSource::CopyFontDescriptorWithOptions((atomic_ullong *)&v22, (int)a3, 0, &v21);
      if (atomic_load_explicit((atomic_ullong *volatile)&v21, memory_order_acquire))
      {
        id v19 = (id)atomic_load_explicit((atomic_ullong *volatile)&v21, memory_order_acquire);
        CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), v19);
      }
      CFArrayRef v13 = (const __CFArray *)v22;
    }

LABEL_17:
    if (CFArrayGetCount((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire))) {

    }
    goto LABEL_20;
  }
  return 1;
}

void TDescriptorSource::CopyMandatoryMatchableRequest(const __CFDictionary *this@<X0>, CFSetRef theSet@<X1>, void *a3@<X8>)
{
  if (qword_1EB2CE1D0 != -1) {
    dispatch_once_f(&qword_1EB2CE1D0, 0, (dispatch_function_t)TDescriptorSource::GetMatchableAttributes(void)::$_0::__invoke);
  }
  CFSetRef v7 = (const __CFSet *)qword_1EB2CE1C8;
  if (theSet && CFSetGetCount(theSet))
  {
    id v8 = (id)0xAAAAAAAAAAAAAAAALL;
    TCFMutableSet::TCFMutableSet((TCFMutableSet *)&v8, v7);
    objc_msgSend((id)atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire), "intersectSet:", theSet);
    CreateCopyOfDictionaryFilteredByKeys(this, (CFSetRef)atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire), a3);
  }
  else
  {
    CreateCopyOfDictionaryFilteredByKeys(this, v7, a3);
  }
}

void CreateCopyOfDictionaryFilteredByKeys(const __CFDictionary *a1@<X0>, CFSetRef theSet@<X1>, void *a3@<X8>)
{
  if (a1)
  {
    if (theSet && CFSetGetCount(theSet) >= 1)
    {
      CFSetRef context = theSet;
      id Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)KeyFilterApplier, &context);
      id v6 = (id)atomic_exchange((atomic_ullong *volatile)&Mutable, 0);
      *a3 = atomic_exchange((atomic_ullong *volatile)&v6, 0);
    }
    else
    {
      CFSetRef context = a1;
      *a3 = atomic_exchange((atomic_ullong *volatile)&context, 0);
    }
  }
  else
  {
    *a3 = 0;
  }
}

void TCFMutableSet::TCFMutableSet(TCFMutableSet *this, CFSetRef theSet)
{
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (theSet) {
    MutableCopCGFloat y = CFSetCreateMutableCopy(v3, 0, theSet);
  }
  else {
    MutableCopCGFloat y = CFSetCreateMutable(v3, 0, MEMORY[0x1E4F1D548]);
  }
  *(void *)this = MutableCopy;
}

void TDescriptorSource::CopySplicedDescriptorsForRequest(CFArrayRef *a1, TDescriptorSource *a2, CFDictionaryRef theDict, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int isa, uint64_t a9)
{
  uint64_t v10 = a6;
  int Value = a5;
  if (a5)
  {
    if (a6) {
      goto LABEL_3;
    }
LABEL_13:
    LODWORD(v10) = CFDictionaryGetValue(theDict, @"CTFontLanguageAwareLineHeightRatioAttribute");
    if (a7) {
      goto LABEL_4;
    }
LABEL_14:
    LODWORD(a7) = CFDictionaryGetValue(theDict, @"CTFontLineSpacingOverrideAttribute");
    goto LABEL_4;
  }
  int Value = CFDictionaryGetValue(theDict, @"CTFontDescriptorLanguageAttribute");
  if (!v10) {
    goto LABEL_13;
  }
LABEL_3:
  if (!a7) {
    goto LABEL_14;
  }
LABEL_4:
  int v49 = v10;
  int v13 = a9;
  CFNumberRef v14 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"CTFontLegibilityWeightAttribute");
  CFNumberRef v15 = v14;
  if (v14)
  {
    CFTypeID v16 = CFGetTypeID(v14);
    if (v16 != CFNumberGetTypeID()) {
      CFNumberRef v15 = 0;
    }
  }
  if (!a9)
  {
    CFDictionaryRef v17 = CFDictionaryGetValue(theDict, @"CTFontIgnoreLegibilityWeightAttribute");
    if (v17)
    {
      int v18 = (int)v17;
      CFTypeID v19 = CFGetTypeID(v17);
      if (v19 == CFBooleanGetTypeID()) {
        int v13 = v18;
      }
      else {
        int v13 = 0;
      }
    }
    else
    {
      int v13 = 0;
    }
  }
  int v46 = a7;
  if (v15)
  {
    LODWORD(valuePtr.isa) = -1431655766;
    CFNumberGetValue(v15, kCFNumberIntType, &valuePtr);
    isCGFloat a = (int)valuePtr.isa;
  }
  CFDictionaryRef v20 = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"NSCTFontTraitsAttribute");
  CFDictionaryRef v21 = v20;
  if (v20)
  {
    CFTypeID v22 = CFGetTypeID(v20);
    if (v22 != CFDictionaryGetTypeID())
    {
      uint64_t v45 = 0;
      CFDictionaryRef v21 = 0;
      goto LABEL_28;
    }
    CFIndex Count = CFDictionaryGetCount(v21);
    if (Count)
    {
      CFIndex v24 = Count;
      CFArrayRef v25 = CFDictionaryGetValue(v21, @"NSCTFontWeightTrait");
      CFDictionaryGetValue(v21, @"NSCTFontProportionTrait");
      uint64_t v26 = CFDictionaryGetValue(v21, @"NSCTFontUIFontDesignTrait");
      CFDictionaryRef v27 = CFDictionaryGetValue(v21, @"NSCTFontGradeTrait");
      if (v24 == 1)
      {
        if (v25 || v26 || v27)
        {
          CFTypeRef cf2 = v26;
          CFDictionaryRef v21 = 0;
        }
        else
        {
          CFTypeRef cf2 = 0;
        }
        uint64_t v45 = 1;
      }
      else
      {
        uint64_t v45 = v24;
        CFTypeRef cf2 = v26;
      }
      goto LABEL_29;
    }
  }
  uint64_t v45 = 0;
LABEL_28:
  CFTypeRef cf2 = 0;
LABEL_29:
  CFDictionaryGetValue(theDict, @"NSCTFontSizeCategoryAttribute");
  CFDictionaryGetValue(theDict, @"NSCTFontTextStylePlatformAttribute");
  CFStringRef PostScriptNameAndAttribute = TDescriptorSource::GetPostScriptNameAndAttribute(theDict, v28);
  CFIndex v30 = (TDescriptorSource *)CFDictionaryGetValue(theDict, @"NSCTFontUIUsageAttribute");
  if (v30)
  {
    if (!TDescriptorSource::FindFontNameForTextStyle(v30, (const __CFString *)v21, 0, 0, 0, v31))
    {
LABEL_36:
      *a1 = 0;
      return;
    }
LABEL_33:
    CFMutableArrayRef Mutable = (CFMutableArrayRef)0xAAAAAAAAAAAAAAAALL;
    TDescriptorSource::CopySplicedDescriptorForName(&Mutable);
    if (atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire))
    {
      valuePtr.isCGFloat a = (void *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      *a1 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&valuePtr.isa, 1, MEMORY[0x1E4F1D510]);

      return;
    }

    goto LABEL_36;
  }
  if (PostScriptNameAndAttribute) {
    goto LABEL_33;
  }
  uint64_t v32 = (TDescriptorSource *)os_unfair_lock_lock_with_options();
  TDescriptorSource::EnsureSplicedFontStash(v32);
  if (cf2) {
    UIFontFamilyNameForDesigCFIndex n = TDescriptorSource::GetUIFontFamilyNameForDesign(cf2, v33);
  }
  else {
    UIFontFamilyNameForDesigCFIndex n = (const __CFString *)CFDictionaryGetValue(theDict, @"NSFontFamilyAttribute");
  }
  CFStringRef v36 = UIFontFamilyNameForDesign;
  if (!UIFontFamilyNameForDesign) {
    goto LABEL_58;
  }
  valuePtr.isCGFloat a = (void *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v37 = TDescriptorSource::FontNamesForFamily(UIFontFamilyNameForDesign, &valuePtr, v35);
  if (v37)
  {
    uint64_t v38 = v37;
    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFIndex)valuePtr.isa, MEMORY[0x1E4F1D510]);
    if (valuePtr.isa)
    {
      CFTypeID v39 = 0;
      int v40 = v49;
      do
      {
        id v52 = (id)0xAAAAAAAAAAAAAAAALL;
        TDescriptorSource::CopySpliceFontForName((uint64_t *)&v52, *(id *)(v38 + 8 * (void)v39), Value, v40, v46, isa, v13, 0, 0, 0, 0, 0, 0, 0, 0);
        if (atomic_load_explicit((atomic_ullong *volatile)&v52, memory_order_acquire))
        {
          id v41 = (id)atomic_load_explicit((atomic_ullong *volatile)&v52, memory_order_acquire);
          CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), v41);
          CFArrayRef v42 = v41;
          int v40 = v49;
        }
        CFTypeID v39 = (char *)v39 + 1;
      }
      while (v39 < valuePtr.isa);
      if (valuePtr.isa > (void *)1)
      {
        id v52 = (id)0xAAAAAAAAAAAAAAAALL;
        TCFMutableDictionary::TCFMutableDictionary((TCFMutableDictionary *)&v52, theDict);
        CFDictionaryRemoveValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v52, memory_order_acquire), @"NSFontFamilyAttribute");
        if (v45 == 1)
        {
          if (cf2) {
            CFDictionaryRemoveValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v52, memory_order_acquire), @"NSCTFontTraitsAttribute");
          }
        }
        if (CFDictionaryGetCount((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v52, memory_order_acquire)))
        {
          TDescriptorSource::CopyDescriptorsForRequestFromArray((TDescriptorSource *)&v51, (CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v52, memory_order_acquire), 0, a4 | 0x43, 0);
          *a1 = (CFArrayRef)atomic_exchange((atomic_ullong *volatile)&v51, 0);

LABEL_61:
          goto LABEL_62;
        }
      }
    }
    *a1 = (CFArrayRef)atomic_exchange((atomic_ullong *volatile)&Mutable, 0);
    goto LABEL_61;
  }
  if (cf2) {
    TDescriptorSource::CopyMatchingDescriptorsForFamily(a2, v36, a1);
  }
  else {
LABEL_58:
  }
    *a1 = 0;
LABEL_62:
  os_unfair_lock_unlock((os_unfair_lock_t)&TDescriptorSource::sSplicedFontsLock);
}

const void *TDescriptorSource::GetPostScriptNameAndAttribute(TDescriptorSource *this, const __CFDictionary *a2)
{
  CFTypeID TypeID = CFStringGetTypeID();
  int Value = CFDictionaryGetValue(this, @"NSCTFontPostScriptNameAttribute");
  if (!Value || (id v5 = Value, CFGetTypeID(Value) != TypeID))
  {
    id v6 = CFDictionaryGetValue(this, @"NSFontNameAttribute");
    if (v6)
    {
      CFSetRef v7 = v6;
      if (CFGetTypeID(v6) == TypeID) {
        return v7;
      }
      else {
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  return v5;
}

uint64_t TDescriptorSource::FontNamesForFamily(CFTypeRef cf2, const __CFString *a2, unint64_t *a3)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB2CDB40, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB2CDB40))
  {
    qword_1EB2CDBF8 = @".AppleSimplifiedChineseFont";
    unk_1EB2CDC00 = 8;
    qword_1EB2CDC08 = (uint64_t)kChineseNames;
    unk_1EB2CDC10 = @".AppleTraditionalChineseFont";
    qword_1EB2CDC18 = 8;
    unk_1EB2CDC20 = off_1E528D540;
    qword_1EB2CDC28 = @".AppleHongKongChineseFont";
    unk_1EB2CDC30 = 8;
    qword_1EB2CDC38 = (uint64_t)off_1E528D580;
    unk_1EB2CDC40 = @".AppleMacaoChineseFont";
    qword_1EB2CDC48 = 8;
    unk_1EB2CDC50 = off_1E528D5C0;
    qword_1EB2CDC58 = @".AppleJapaneseFont";
    unk_1EB2CDC60 = 9;
    qword_1EB2CDC68 = (uint64_t)kJapaneseNames;
    unk_1EB2CDC70 = @".AppleKoreanFont";
    qword_1EB2CDC78 = 8;
    unk_1EB2CDC80 = kKoreanNames;
    qword_1EB2CDC88 = @".AppleArabicFont";
    unk_1EB2CDC90 = 9;
    qword_1EB2CDC98 = (uint64_t)kArabicNames;
    unk_1EB2CDCA0 = @".AppleThaiFont";
    qword_1EB2CDCA8 = 3;
    unk_1EB2CDCB0 = kThaiNames;
    qword_1EB2CDCB8 = @".AppleUrduFont";
    unk_1EB2CDCC0 = 2;
    qword_1EB2CDCC8 = (uint64_t)kUrduNames;
    unk_1EB2CDCD0 = @".AppleSystemUIFont";
    qword_1EB2CDCD8 = 29;
    unk_1EB2CDCE0 = kSystemUIFontNames;
    qword_1EB2CDCE8 = @".AppleSystemFallback";
    unk_1EB2CDCF0 = 9;
    qword_1EB2CDCF8 = (uint64_t)kSystemFallbackFontNames;
    unk_1EB2CDD00 = @".AppleSystemUIFontCompact";
    qword_1EB2CDD08 = 18;
    unk_1EB2CDD10 = kSystemUIFontCompactNames;
    qword_1EB2CDD18 = @".AppleSystemUIFontCore";
    unk_1EB2CDD20 = 27;
    qword_1EB2CDD28 = (uint64_t)kSystemUIFontCoreNames;
    unk_1EB2CDD30 = @".AppleSystemUIFontRounded";
    qword_1EB2CDD38 = 9;
    unk_1EB2CDD40 = kSystemUIFontRoundNames;
    qword_1EB2CDD48 = @".AppleSystemUIFontCompactRounded";
    qword_1EB2CDD50 = 9;
    qword_1EB2CDD58 = (uint64_t)kSystemUIFontCompactRoundNames;
    qword_1EB2CDD60 = @".AppleSystemUIFontCondensed";
    qword_1EB2CDD68 = 9;
    qword_1EB2CDD70 = (uint64_t)kSystemUIFontCondensedNames;
    qword_1EB2CDD78 = @".AppleSystemUIFontCoreCondensed";
    qword_1EB2CDD80 = 9;
    qword_1EB2CDD88 = (uint64_t)kSystemUIFontCoreCondensedNames;
    qword_1EB2CDD90 = @".AppleSystemUIFontSerif";
    qword_1EB2CDDA0 = (uint64_t)kSystemUIFontSerifNames;
    qword_1EB2CDD98 = 12;
    qword_1EB2CDDA8 = @".AppleSystemUIFontSoft";
    qword_1EB2CDDB0 = 9;
    qword_1EB2CDDB8 = (uint64_t)kSystemUIFontSoftNames;
    qword_1EB2CDDC0 = @".AppleSystemUIFontCompactSoft";
    qword_1EB2CDDC8 = 9;
    qword_1EB2CDDD0 = (uint64_t)kSystemUIFontCompactSoftNames;
    qword_1EB2CDDD8 = @".AppleSystemUIFontMonospaced";
    qword_1EB2CDDE0 = 12;
    qword_1EB2CDDE8 = (uint64_t)kSystemUIFontMonospacedNames;
    qword_1EB2CDDF0 = @".Apple Symbols Fallback";
    qword_1EB2CDDF8 = 1;
    qword_1EB2CDE00 = (uint64_t)kSymbolsFBNames;
    qword_1EB2CDE08 = @".Times Fallback";
    qword_1EB2CDE10 = 4;
    qword_1EB2CDE18 = (uint64_t)kTimesFBNames;
    __cxa_guard_release(&qword_1EB2CDB40);
  }
  uint64_t v5 = 0;
  while (1)
  {
    id v6 = &_MergedGlobals_82[v5];
    CFTypeRef v7 = *(CFTypeRef *)&_MergedGlobals_82[v5 + 208];
    if (v7 == cf2 || cf2 && v7 && CFEqual(v7, cf2)) {
      break;
    }
    v5 += 24;
    if (v5 == 552)
    {
      uint64_t result = 0;
      a2->isCGFloat a = 0;
      return result;
    }
  }
  uint64_t result = *((void *)v6 + 28);
  a2->isCGFloat a = (void *)*((void *)v6 + 27);
  return result;
}

void TDescriptorSource::CopyDescriptorsForRequestWithFamilyName(TDescriptorSource *this, const __CFString *a2, __CFString *a3, int a4)
{
  __int16 v4 = a4;
  v13.info = 0;
  v13.datCGFloat a = 0;
  if ((*(void *)&a4 & 0x10400) != 0 || !TDescriptorSource::ShouldSubstituteInvisibleFontName(a3, a2))
  {
    v13.isCGFloat a = (void *)0xAAAAAAAAAAAAAAAALL;
    CopyPostScriptNamesForFamily(a3, (v4 & 0x200) != 0, &v13);
    CFArrayRef explicit = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v13, memory_order_acquire);
    if (explicit)
    {
      CFIndex Count = CFArrayGetCount(explicit);
      if (Count)
      {
        CFIndex v9 = Count;
        for (CFIndex i = 0; i != v9; ++i)
        {
          CFArrayGetValueAtIndex(explicit, i);
          id v12 = (id)0xAAAAAAAAAAAAAAAALL;
          TDescriptorSource::CopyFontDescriptorPerPostScriptName(&v12);
          if (atomic_load_explicit((atomic_ullong *volatile)&v12, memory_order_acquire))
          {
            id v11 = (id)atomic_load_explicit((atomic_ullong *volatile)&v12, memory_order_acquire);
            TCFLazyMutableArray::LazyCreate((TCFLazyMutableArray *)&v13.info);
            CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit(&v13.info, memory_order_acquire), v11);
          }
        }
      }
    }
    *(void *)this = atomic_exchange(&v13.info, 0);
  }
  else
  {
    *(void *)this = 0;
  }
}

void CopyPostScriptNamesForFamily(const __CFString *a1@<X0>, char a2@<W1>, __CFString *a3@<X8>)
{
  id v19 = (id)0xAAAAAAAAAAAAAAAALL;
  CopyLowercasedString(a1, &v19);
  a3->isCGFloat a = (void *)0xAAAAAAAAAAAAAAAALL;
  CopyPostScriptNamesForFamilyLowercased(a3, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v19, memory_order_acquire));
  if (a1 != @"." && (!a1 || !CFStringHasPrefix(a1, @".")))
  {
    atomic_load_explicit((atomic_ullong *volatile)&v19, memory_order_acquire);
    CFArrayRef v6 = (const __CFArray *)FSFontCopyFontNamesForFamily();
    if (atomic_load_explicit((atomic_ullong *volatile)a3, memory_order_acquire))
    {
      v20.isCGFloat a = (void *)0xAAAAAAAAAAAAAAAALL;
      TCFMutableArray::TCFMutableArray((TCFMutableArray *)&v20, (CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)a3, memory_order_acquire));
      if (v6)
      {
        CFIndex Count = CFArrayGetCount(v6);
        if (Count)
        {
          CFIndex v8 = Count;
          for (CFIndex i = 0; i != v8; ++i)
          {
            CFURLRef ValueAtIndex = CFArrayGetValueAtIndex(v6, i);
            CFArrayRef explicit = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire);
            v21.uint64_t length = CFArrayGetCount((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire));
            v21.locatioCFIndex n = 0;
            if (!CFArrayContainsValue(explicit, v21, ValueAtIndex)) {
              CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire), ValueAtIndex);
            }
          }
        }
      }
    }
    else
    {
      TCFRef<__CTFont const*>::Retain((atomic_ullong *)a3, v6);
    }
  }
  CFArrayRef v12 = (const __CFArray *)(id)atomic_load_explicit((atomic_ullong *volatile)a3, memory_order_acquire);
  CFArrayRef v13 = v12;
  if (v12) {
    BOOL v14 = CFArrayGetCount(v12) != 0;
  }
  else {
    BOOL v14 = 0;
  }

  if (!v14 && (a2 & 1) == 0)
  {
    CFNumberRef v15 = (const void *)atomic_load_explicit((atomic_ullong *volatile)&v19, memory_order_acquire);
    if (qword_1EB2CE8E8 != -1) {
      dispatch_once(&qword_1EB2CE8E8, &__block_literal_global_107);
    }
    if (qword_1EB2CE8E0
      && (CFDictionaryRef v16 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)qword_1EB2CE8E0, @"Aliases")) != 0)
    {
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v16, @"Families");
      if (Value) {
        CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(Value, v15);
      }
    }
    else
    {
      CFDictionaryRef Value = 0;
    }
    v20.isCGFloat a = Value;
    int v18 = (void *)atomic_exchange((atomic_ullong *volatile)&v20, 0);

    if (v18)
    {
      CopyPostScriptNamesForFamilyLowercased(&v20, v18);
    }
  }
}

void CopyPostScriptNamesForFamilyLowercased(const __CFString *a1, const void *a2)
{
  if (!a2) {
    goto LABEL_9;
  }
  if (qword_1EB2CE8E8 != -1) {
    dispatch_once(&qword_1EB2CE8E8, &__block_literal_global_107);
  }
  if (qword_1EB2CE8E0
    && (CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)qword_1EB2CE8E0, @"Families")) != 0
    && (CFArrayRef v5 = (const __CFArray *)CFDictionaryGetValue(Value, a2)) != 0
    && (CFArrayRef v6 = v5, CFArrayGetCount(v5)))
  {
    id v7 = v6;
    a1->isCGFloat a = (void *)atomic_exchange((atomic_ullong *volatile)&v7, 0);
  }
  else
  {
LABEL_9:
    a1->isCGFloat a = 0;
  }
}

BOOL TDescriptorSource::AddMissedRequest(TDescriptorSource *this, const void *a2, uint64_t a3, CFComparisonResult (*a4)(const void *, const void *, void *))
{
  if (this)
  {
    os_unfair_lock_lock_with_options();
    MissedRequests = (float *)GetMissedRequests();
    id v44 = this;
    *(void *)&long long v45 = a2;
    *((void *)&v45 + 1) = a3;
    BOOL v9 = v8 == 0;
    if (v8)
    {
LABEL_77:

      os_unfair_lock_unlock((os_unfair_lock_t)&sMissedRequestCacheLock);
      return v9;
    }
    CFHashCode v10 = CFHash((CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)&v44, memory_order_acquire));
    unint64_t v11 = STL::hash_val<unsigned long,unsigned long,CFComparisonResult (*)(void const*,void const*,void *)>(v10, v45, *((unint64_t *)&v45 + 1));
    unint64_t v12 = v11;
    unint64_t v13 = *((void *)MissedRequests + 1);
    if (v13)
    {
      uint8x8_t v14 = (uint8x8_t)vcnt_s8((int8x8_t)v13);
      v14.i16[0] = vaddlv_u8(v14);
      unint64_t v15 = v14.u32[0];
      if (v14.u32[0] > 1uLL)
      {
        unint64_t v16 = v11;
        if (v11 >= v13) {
          unint64_t v16 = v11 % v13;
        }
      }
      else
      {
        unint64_t v16 = (v13 - 1) & v11;
      }
      CFDictionaryRef v17 = *(void **)(*(void *)MissedRequests + 8 * v16);
      if (v17)
      {
        int v18 = (void *)*v17;
        if (*v17)
        {
          do
          {
            unint64_t v19 = v18[1];
            if (v19 == v12)
            {
              {
                goto LABEL_77;
              }
            }
            else
            {
              if (v15 > 1)
              {
                if (v19 >= v13) {
                  v19 %= v13;
                }
              }
              else
              {
                v19 &= v13 - 1;
              }
              if (v19 != v16) {
                break;
              }
            }
            int v18 = (void *)*v18;
          }
          while (v18);
        }
      }
    }
    else
    {
      unint64_t v16 = 0xAAAAAAAAAAAAAAAALL;
    }
    __CFString v20 = (char *)operator new(0x28uLL);
    *(void *)__CFString v20 = 0;
    *((void *)v20 + 1) = v12;
    *((void *)v20 + 2) = (id)atomic_load_explicit((atomic_ullong *volatile)&v44, memory_order_acquire);
    *(_OWORD *)(v20 + 24) = v45;
    float v21 = (float)(unint64_t)(*((void *)MissedRequests + 3) + 1);
    float v22 = MissedRequests[8];
    if (v13 && (float)(v22 * (float)v13) >= v21)
    {
LABEL_67:
      uint64_t v38 = *(void **)MissedRequests;
      CFTypeID v39 = *(void **)(*(void *)MissedRequests + 8 * v16);
      if (v39)
      {
        *(void *)__CFString v20 = *v39;
      }
      else
      {
        uint64_t v40 = *((void *)MissedRequests + 2);
        *(void *)__CFString v20 = v40;
        *((void *)MissedRequests + 2) = v20;
        v38[v16] = MissedRequests + 4;
        if (!v40)
        {
LABEL_76:
          ++*((void *)MissedRequests + 3);
          goto LABEL_77;
        }
        unint64_t v41 = *(void *)(v40 + 8);
        if ((v13 & (v13 - 1)) != 0)
        {
          if (v41 >= v13) {
            v41 %= v13;
          }
        }
        else
        {
          v41 &= v13 - 1;
        }
        CFTypeID v39 = (void *)(*(void *)MissedRequests + 8 * v41);
      }
      void *v39 = v20;
      goto LABEL_76;
    }
    BOOL v23 = (v13 & (v13 - 1)) == 0;
    if (v13 < 3) {
      BOOL v23 = 0;
    }
    unint64_t v24 = (2 * v13) | !v23;
    unint64_t v25 = vcvtps_u32_f32(v21 / v22);
    if (v24 <= v25) {
      int8x8_t prime = (int8x8_t)v25;
    }
    else {
      int8x8_t prime = (int8x8_t)v24;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    }
    unint64_t v13 = *((void *)MissedRequests + 1);
    if (*(void *)&prime > v13) {
      goto LABEL_33;
    }
    if (*(void *)&prime < v13)
    {
      unint64_t v33 = vcvtps_u32_f32((float)*((unint64_t *)MissedRequests + 3) / MissedRequests[8]);
      if (v13 < 3 || (uint8x8_t v34 = (uint8x8_t)vcnt_s8((int8x8_t)v13), v34.i16[0] = vaddlv_u8(v34), v34.u32[0] > 1uLL))
      {
        unint64_t v33 = std::__next_prime(v33);
      }
      else
      {
        uint64_t v35 = 1 << -(char)__clz(v33 - 1);
        if (v33 >= 2) {
          unint64_t v33 = v35;
        }
      }
      if (*(void *)&prime <= v33) {
        int8x8_t prime = (int8x8_t)v33;
      }
      if (*(void *)&prime >= v13)
      {
        unint64_t v13 = *((void *)MissedRequests + 1);
      }
      else
      {
        if (prime)
        {
LABEL_33:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          CFDictionaryRef v27 = operator new(8 * *(void *)&prime);
          CFDictionaryRef v28 = *(void **)MissedRequests;
          *(void *)MissedRequests = v27;
          if (v28) {
            operator delete(v28);
          }
          uint64_t v29 = 0;
          *((int8x8_t *)MissedRequests + 1) = prime;
          do
            *(void *)(*(void *)MissedRequests + 8 * v29++) = 0;
          while (*(void *)&prime != v29);
          CFIndex v30 = (void *)*((void *)MissedRequests + 2);
          if (v30)
          {
            unint64_t v31 = v30[1];
            uint8x8_t v32 = (uint8x8_t)vcnt_s8(prime);
            v32.i16[0] = vaddlv_u8(v32);
            if (v32.u32[0] > 1uLL)
            {
              if (v31 >= *(void *)&prime) {
                v31 %= *(void *)&prime;
              }
            }
            else
            {
              v31 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)MissedRequests + 8 * v31) = MissedRequests + 4;
            CFStringRef v36 = (void *)*v30;
            if (*v30)
            {
              do
              {
                unint64_t v37 = v36[1];
                if (v32.u32[0] > 1uLL)
                {
                  if (v37 >= *(void *)&prime) {
                    v37 %= *(void *)&prime;
                  }
                }
                else
                {
                  v37 &= *(void *)&prime - 1;
                }
                if (v37 != v31)
                {
                  if (!*(void *)(*(void *)MissedRequests + 8 * v37))
                  {
                    *(void *)(*(void *)MissedRequests + 8 * v37) = v30;
                    goto LABEL_58;
                  }
                  *CFIndex v30 = *v36;
                  void *v36 = **(void **)(*(void *)MissedRequests + 8 * v37);
                  **(void **)(*(void *)MissedRequests + 8 * v37) = v36;
                  CFStringRef v36 = v30;
                }
                unint64_t v37 = v31;
LABEL_58:
                CFIndex v30 = v36;
                CFStringRef v36 = (void *)*v36;
                unint64_t v31 = v37;
              }
              while (v36);
            }
          }
          unint64_t v13 = (unint64_t)prime;
          goto LABEL_62;
        }
        CFArrayRef v43 = *(void **)MissedRequests;
        *(void *)MissedRequests = 0;
        if (v43) {
          operator delete(v43);
        }
        unint64_t v13 = 0;
        *((void *)MissedRequests + 1) = 0;
      }
    }
LABEL_62:
    if ((v13 & (v13 - 1)) != 0)
    {
      if (v12 >= v13) {
        unint64_t v16 = v12 % v13;
      }
      else {
        unint64_t v16 = v12;
      }
    }
    else
    {
      unint64_t v16 = (v13 - 1) & v12;
    }
    goto LABEL_67;
  }
  return 0;
}

BOOL CompareName(__CFString *a1, atomic_ullong *a2, char a3, char a4)
{
  CFIndex v8 = (__CFString *)(id)atomic_load_explicit(a2 + 12, memory_order_acquire);
  BOOL v9 = v8;
  CFHashCode v10 = v9;
  if (v10 == a1)
  {

LABEL_10:
    BOOL v12 = 1;
    goto LABEL_12;
  }
  unint64_t v11 = v10;
  if (!a1 || !v10)
  {

    if (a4) {
      goto LABEL_11;
    }
    goto LABEL_9;
  }
  BOOL v12 = 1;
  CFComparisonResult v13 = CFStringCompare(a1, v10, 1uLL);

  if (v13)
  {
    if (a4) {
      goto LABEL_11;
    }
LABEL_9:
    if (IsPostScriptNameAlias(a1, v8)) {
      goto LABEL_10;
    }
LABEL_11:
    BOOL v12 = CompareOtherNamesExclusive(a1, a1, a1, (const TBaseFont *)a2, a3);
  }
LABEL_12:

  return v12;
}

uint64_t TAATKernEngine::KernRuns(uint64_t a1, unsigned char *a2, int *a3)
{
  int v125 = *a3;
  *a3 = 2;
  if (!TRunGlue::length(*(TRunGlue **)a1)) {
    return 1;
  }
  uint64_t v4 = *(void *)(a1 + 96);
  if (*(unsigned char *)(a1 + 113))
  {
    uint64_t v5 = bswap32(*(unsigned __int16 *)(v4 + 2)) >> 16;
    uint64_t v6 = v4 + 4;
  }
  else
  {
    uint64_t v5 = (int)bswap32(*(_DWORD *)(v4 + 4));
    uint64_t v6 = v4 + 8;
  }
  id v7 = *(TRunGlue **)a1;
  uint64_t v8 = *(void *)(*(void *)a1 + 640);
  uint64_t v9 = *(void *)(*(void *)a1 + 648);
  *(void *)(a1 + 8) = v8;
  *(void *)(a1 + 16) = v9;
  if (*((unsigned char *)v7 + 634))
  {
    *(void *)(a1 + 8) = v9;
    *(void *)(a1 + 16) = v8;
  }
  *(void *)(a1 + 24) = 0x3FF0000000000000;
  if (v5 >= 1)
  {
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    uint64_t v124 = v5;
    do
    {
      uint64_t v142 = v10;
      v6 += v11;
      unint64_t v12 = v6 + 6;
      if (*(void *)(a1 + 96) > (unint64_t)(v6 + 4) || v12 > *(void *)(a1 + 104))
      {
LABEL_200:
        id v123 = TFont::DebugDescription(*(TFont **)(*(void *)a1 + 616));
        CFLog();

        uint64_t v122 = *(void *)(*(void *)(*(void *)a1 + 616) + 400);
        (*(void (**)(uint64_t))(*(void *)v122 + 488))(v122);
        uint64_t result = 0;
        *(void *)(a1 + 96) = 0;
        return result;
      }
      unsigned int v14 = bswap32(*(unsigned __int16 *)(v6 + 4)) >> 16;
      if (*(unsigned char *)(a1 + 113))
      {
        uint64_t v11 = bswap32(*(unsigned __int16 *)(v6 + 2)) >> 16;
        if (((v14 << 11) & 0x1000) != 0) {
          goto LABEL_173;
        }
        unsigned int v14 = ((v14 >> 8) & 0xFFFFA7FF | (v14 << 15) | (((v14 >> 2) & 1) << 14) | (((v14 >> 3) & 1) << 11) & 0xFFFFEFFF | (((v14 >> 1) & 1) << 12)) ^ 0xFFFF8000;
        unint64_t v15 = (unsigned __int16 *)(v6 + 6);
      }
      else
      {
        unint64_t v15 = (unsigned __int16 *)(v6 + 8);
        uint64_t v11 = (int)bswap32(*(_DWORD *)v6);
      }
      __int16 v16 = v14;
      if (*(unsigned char *)(a1 + 112) == (unsigned __int16)v14 >> 15)
      {
        if ((v14 & 0x4000) != 0)
        {
          if (*(unsigned char *)(a1 + 112)) {
            goto LABEL_173;
          }
        }
        else if (!v125)
        {
          goto LABEL_173;
        }
        if ((v14 & 0x2000) != 0)
        {
          CFDictionaryRef v17 = *(TBaseFont **)(*(void *)(*(void *)a1 + 616) + 400);
          if (v17)
          {
            if (TBaseFont::GetInitializedGraphicsFont(v17)
              && CGFontGetParserFont()
              && *(void *)(a1 + 96) <= v12
              && (unint64_t)(v6 + 8) <= *(void *)(a1 + 104))
            {
              FPFontGetVariationScalar();
              if (v18 == 0.0) {
                goto LABEL_173;
              }
              *(double *)(a1 + 24) = v18;
            }
          }
        }
        BOOL v146 = v15;
        uint64_t v131 = v11;
        uint64_t v132 = v6;
        switch((char)v14)
        {
          case 0:
            unint64_t v19 = *(void *)(a1 + 104);
            __CFString v20 = v15 + 4;
            if ((unint64_t)(v15 + 4) > v19) {
              goto LABEL_200;
            }
            *(void *)&long long v21 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v21 + 1) = 0xAAAAAAAAAAAAAAAALL;
            long long v149 = v21;
            long long v150 = v21;
            v148[0] = a1;
            v148[1] = v15;
            v148[2] = v19;
            LOWORD(v149) = v14;
            v151[0] = 0;
            LODWORD(v22) = bswap32(*v15) >> 16;
            unint64_t v23 = (unint64_t)&v20[3 * v22];
            if (v23 < (unint64_t)v20 || v23 > v19)
            {
              if ((unint64_t)(v15 + 7) > v19) {
                LOWORD(v22) = 0;
              }
              else {
                unint64_t v22 = (v19 - (unint64_t)v20) / 6;
              }
            }
            WORD4(v150) = v22;
            unint64_t v24 = *(TRunGlue **)a1;
            uint64_t v25 = *(void *)(*(void *)a1 + 16);
            uint64_t v26 = TAATKernEngine::KernOrderedList::ProcessGlyphsT<TRunGlue::TGlyphInVector>;
            if (v25)
            {
              if (v25 == 1) {
                uint64_t v26 = TAATKernEngine::KernOrderedList::ProcessGlyphsT<TRunGlue::TGlyphInSingleRun>;
              }
              else {
                uint64_t v26 = TAATKernEngine::KernOrderedList::ProcessGlyphsT<TRunGlue::TGlyph>;
              }
            }
            CFArrayRef v105 = (void (*)(void *, unsigned char *))v26;
            *((void *)&v149 + 1) = v26;
            *(void *)&long long v150 = 0;
            uint64_t v106 = *(void *)(*((void *)v24 + 77) + 400);
            if (TBaseFont::GetGlyphCount((TBaseFont *)v106))
            {
              os_unfair_lock_lock_with_options();
              uint64_t v107 = *(void *)(v106 + 488);
              if (2 * v142 >= (unint64_t)((*(void *)(v106 + 496) - v107) >> 3)
                || (CFTypeID v108 = *(_WORD **)(v107 + 16 * v142)) == 0)
              {
                operator new[]();
              }
              WORD5(v150) = *v108;
              v151[0] = v108 + 1;
              os_unfair_lock_unlock((os_unfair_lock_t)(v106 + 444));
            }
            v105(v148, a2);
            goto LABEL_170;
          case 1:
            unint64_t v27 = *(void *)(a1 + 104);
            if ((unint64_t)(v15 + 5) > v27) {
              goto LABEL_200;
            }
            CFDictionaryRef v28 = (unsigned __int16 *)((char *)v15 + (bswap32(v15[1]) >> 16));
            uint64_t v29 = v28 + 2;
            if ((unint64_t)(v28 + 2) > v27) {
              goto LABEL_200;
            }
            *(void *)&long long v30 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v30 + 1) = 0xAAAAAAAAAAAAAAAALL;
            long long v149 = v30;
            long long v150 = v30;
            BOOL v139 = (char *)v15 + (bswap32(v15[3]) >> 16);
            uint64_t v31 = bswap32(v28[1]) >> 16;
            unint64_t v32 = (unint64_t)v29 + v31;
            uint64_t v128 = v28;
            if ((unint64_t)v28 + 5 <= v27) {
              unsigned __int16 v33 = v27 - (_WORD)v29;
            }
            else {
              unsigned __int16 v33 = 0;
            }
            if (v32 <= v27 && v32 >= (unint64_t)v29) {
              unsigned __int16 v35 = v31;
            }
            else {
              unsigned __int16 v35 = v33;
            }
            unsigned __int16 v126 = v35;
            unsigned int v36 = v15[2];
            BYTE11(v150) = 0;
            memset(v151, 0, sizeof(v151));
            uint64_t v152 = -1;
            unsigned int v37 = bswap32(v36) >> 16;
            uint64_t v133 = *(TRunGlue **)a1;
            uint64_t v38 = TRunGlue::length(*(TRunGlue **)a1);
            uint64_t v143 = 0;
            int v39 = 0;
            uint64_t v136 = v15 + 1;
            while (2)
            {
              if (v38 < 1)
              {
                if (((v38 == 0) & (v39 ^ 1)) == 0) {
                  break;
                }
LABEL_57:
                int v39 = 1;
                CFArrayRef v42 = (unsigned __int8 *)&v150 + 11;
LABEL_58:
                uint64_t v43 = *v42;
                goto LABEL_59;
              }
              if (v39) {
                goto LABEL_57;
              }
              int GlyphID = TRunGlue::GetGlyphID(v133, v143);
              if (GlyphID == 0xFFFF)
              {
                int v39 = 0;
                uint64_t v43 = 2;
              }
              else
              {
                int v41 = GlyphID - (bswap32(*v128) >> 16);
                if ((unsigned __int16)v41 < v126)
                {
                  int v39 = 0;
                  CFArrayRef v42 = (unsigned __int8 *)v128 + (unsigned __int16)v41 + 4;
                  goto LABEL_58;
                }
                int v39 = 0;
                uint64_t v43 = 1;
              }
LABEL_59:
              id v44 = (unsigned __int8 *)v146 + v43 + (unsigned __int16)v37;
              if ((unint64_t)(v44 + 1) <= v27)
              {
                long long v45 = (unsigned __int16 *)&v139[4 * *v44];
                if (v45 >= v146 && (unint64_t)(v45 + 2) <= v27)
                {
                  unsigned int v47 = *v45;
                  int v48 = (int)bswap32(v45[1]) >> 16;
                  if (v48 < 0)
                  {
                    if (v152 <= 6) {
                      uint64_t v49 = v152 + 1;
                    }
                    else {
                      uint64_t v49 = 0;
                    }
                    uint64_t v152 = v49;
                    v151[v49] = v143;
                  }
                  if ((v48 & 0x3FFF) == 0 || (uint64_t v50 = v152, v152 < 0))
                  {
LABEL_81:
                    unsigned int v37 = bswap32(v47) >> 16;
                    LODWORD(v55) = v39 ^ 1;
                    if ((v48 & 0x4000) != 0) {
                      uint64_t v55 = 0;
                    }
                    else {
                      uint64_t v55 = v55;
                    }
                    v143 += v55;
                    v38 -= (v48 & 0x4000) == 0;
                    continue;
                  }
                  if ((unsigned __int16 *)((char *)v146 + (v48 & 0x3FFF)) >= v146)
                  {
                    unint64_t v51 = (unint64_t)v136 + (v48 & 0x3FFF);
                    while (v51 <= v27)
                    {
                      if (v50 >= 1) {
                        uint64_t v52 = v50 - 1;
                      }
                      else {
                        uint64_t v52 = 7;
                      }
                      unsigned int v53 = bswap32(*(unsigned __int16 *)(v51 - 2)) >> 16;
                      if ((v53 & 0xFFFE) != 0)
                      {
                        uint64_t v54 = v151[v50];
                        if ((v54 & 0x8000000000000000) == 0)
                        {
                          TAATKernEngine::HandleKern<TRunGlue::TGlyph>(a1, *(void *)a1, v54, (__int16)(v53 & 0xFFFE), v14);
                          *a2 = 1;
                        }
                      }
                      v51 += 2;
                      uint64_t v50 = v52;
                      if (v53) {
                        goto LABEL_81;
                      }
                    }
                  }
                }
              }
              break;
            }
            __int16 v16 = v14;
LABEL_170:
            uint64_t v5 = v124;
            uint64_t v11 = v131;
            uint64_t v6 = v132;
LABEL_171:
            if ((v16 & 0x2000) != 0) {
              *(void *)(a1 + 24) = 0x3FF0000000000000;
            }
            break;
          case 2:
            if ((unint64_t)(v15 + 4) > *(void *)(a1 + 104)) {
              goto LABEL_200;
            }
            unint64_t v56 = *(void *)(a1 + 104);
            unsigned __int16 v140 = 0;
            uint64_t v144 = v6 - (void)v15;
            uint64_t v57 = v6 - (void)v15 + (bswap32(v15[1]) >> 16);
            CFIndex v58 = (unsigned __int16 *)((char *)v15 + v57);
            if (v57 >= 0 && (unint64_t)(v58 + 3) <= v56)
            {
              unint64_t v59 = (unint64_t)(v58 + 2);
              unsigned int v60 = bswap32(v58[1]) >> 16;
              unint64_t v61 = (unint64_t)&v58[v60 + 2];
              if (v61 > v56 || v61 < v59) {
                unsigned int v60 = (v56 - (v58 + 4)) >> 1;
              }
              if (v59 >= (unint64_t)v15) {
                unsigned __int16 v63 = v60;
              }
              else {
                unsigned __int16 v63 = 0;
              }
              unsigned __int16 v140 = v63;
            }
            BOOL v137 = v58;
            uint64_t v64 = v144 + (bswap32(v15[2]) >> 16);
            if (v64 < 0) {
              goto LABEL_170;
            }
            int v65 = (unsigned __int16 *)((char *)v15 + v64);
            if ((unint64_t)v15 + v64 + 6 > v56) {
              goto LABEL_170;
            }
            CFNumberRef v66 = v65 + 2;
            unsigned int v67 = bswap32(v65[1]) >> 16;
            unint64_t v68 = (unint64_t)&v65[v67 + 2];
            if (v68 > v56 || v68 < (unint64_t)v66) {
              unsigned int v67 = (v56 - (v65 + 4)) >> 1;
            }
            if (v66 < v15) {
              LOWORD(v67) = 0;
            }
            unsigned __int16 v134 = v67;
            if (!v140 || !(_WORD)v67) {
              goto LABEL_170;
            }
            CFDictionaryRef v70 = *(TRunGlue **)a1;
            uint64_t v71 = TRunGlue::length(*(TRunGlue **)a1);
            if (*((void *)v70 + 19))
            {
              TRunGlue::FocusOnIndex(v70, 0);
              CFArrayRef v72 = (unsigned __int16 *)(*((void *)v70 + 22) - 2 * *((void *)v70 + 20));
            }
            else
            {
              CFArrayRef v72 = (unsigned __int16 *)(*((void *)v70 + 22) + 2 * *((void *)v70 + 20));
            }
            if (v71 < 2) {
              goto LABEL_170;
            }
            uint64_t v109 = *v72;
            uint64_t v130 = v15 + 3;
            uint64_t v110 = 1;
            while (2)
            {
              uint64_t v111 = TRunGlue::GetGlyphID(v70, v110);
              if (v111 == 0xFFFF || (uint64_t v112 = v111, TRunGlue::IsDeleted(v70, v110)))
              {
                uint64_t v112 = v109;
                goto LABEL_190;
              }
              unsigned int v113 = bswap32(*v137);
              unsigned int v114 = (unsigned __int16)(v109 - HIWORD(v113));
              int v115 = v112 - (bswap32(*v65) >> 16);
              BOOL v116 = &v137[(unsigned __int16)(v109 - HIWORD(v113)) + 2];
              if (v114 >= v140) {
                BOOL v116 = v130;
              }
              if ((unsigned __int16)v115 >= v134) {
                unsigned int v117 = 0;
              }
              else {
                unsigned int v117 = bswap32(v65[(unsigned __int16)v115 + 2]) >> 16;
              }
              uint64_t v118 = v144 + (bswap32(*v116) >> 16) + v117;
              if (v118 >= 0)
              {
                CFDictionaryRef v119 = (unsigned __int16 *)((char *)v146 + v118);
                if ((unint64_t)(v119 + 1) <= v56)
                {
                  unsigned int v120 = *v119;
                  if (v120)
                  {
                    TAATKernEngine::HandleKern<TRunGlue::TGlyph>(a1, (uint64_t)v70, v110, (int)bswap32(v120) >> 16, v14);
                    *a2 = 1;
                  }
LABEL_190:
                  ++v110;
                  uint64_t v109 = v112;
                  if (v71 == v110) {
                    goto LABEL_170;
                  }
                  continue;
                }
              }
              goto LABEL_170;
            }
          case 3:
            unint64_t v73 = *(void *)(a1 + 104);
            if ((unint64_t)(v15 + 3) > v73) {
              goto LABEL_200;
            }
            uint64_t v74 = bswap32(*v15) >> 16;
            int v127 = v15 + 3;
            unint64_t v75 = (unint64_t)&v15[*((unsigned __int8 *)v15 + 2) + 3];
            unint64_t v76 = v75 + v74;
            id v77 = (TRunGlue *)(v75 + v74 + v74);
            BOOL v78 = v75 >= (unint64_t)v15;
            BOOL v80 = v75 + v74 >= v75 && v76 <= v73;
            BOOL v81 = v75 + 1 <= v73;
            uint64_t v141 = (uint64_t)&v15[*((unsigned __int8 *)v15 + 2) + 3];
            unsigned __int16 v82 = v73 - v75;
            if (v78 && v81) {
              unsigned __int16 v83 = v82;
            }
            else {
              unsigned __int16 v83 = 0;
            }
            if (v78 && v80) {
              unsigned __int16 v84 = v74;
            }
            else {
              unsigned __int16 v84 = v83;
            }
            BOOL v85 = v76 >= (unint64_t)v15;
            double v135 = v77;
            unint64_t v138 = v76;
            BOOL v87 = (unint64_t)v77 >= v76 && (unint64_t)v77 <= v73;
            BOOL v88 = v76 + 1 <= v73;
            unint64_t v89 = *(void *)(a1 + 104);
            __int16 v90 = v73 - v76;
            if (v85 && v88) {
              __int16 v91 = v90;
            }
            else {
              __int16 v91 = 0;
            }
            if (!v85 || !v87) {
              LOWORD(v74) = v91;
            }
            LODWORD(v74) = (unsigned __int16)v74;
            if ((unsigned __int16)v74 >= v84) {
              LODWORD(v74) = v84;
            }
            unsigned int v145 = v74;
            if (!v74) {
              goto LABEL_170;
            }
            unsigned int v129 = *((unsigned __int8 *)v15 + 4);
            unsigned int v92 = *(TRunGlue **)a1;
            uint64_t v93 = TRunGlue::length(*(TRunGlue **)a1);
            if (*((void *)v92 + 19))
            {
              TRunGlue::FocusOnIndex(v92, 0);
              CFArrayRef v94 = (unsigned __int16 *)(*((void *)v92 + 22) - 2 * *((void *)v92 + 20));
            }
            else
            {
              CFArrayRef v94 = (unsigned __int16 *)(*((void *)v92 + 22) + 2 * *((void *)v92 + 20));
            }
            if (v93 < 2) {
              goto LABEL_170;
            }
            unsigned int v95 = *v94;
            if (v145 <= v95) {
              uint64_t v96 = 0;
            }
            else {
              uint64_t v96 = v95;
            }
            uint64_t v97 = 1;
            while (2)
            {
              unsigned int v98 = TRunGlue::GetGlyphID(v92, v97);
              if (v98 == 0xFFFF || (unsigned int v99 = v98, TRunGlue::IsDeleted(v92, v97)))
              {
                uint64_t v100 = v96;
                goto LABEL_161;
              }
              if (v145 <= v99) {
                uint64_t v100 = 0;
              }
              else {
                uint64_t v100 = v99;
              }
              id v101 = (unsigned __int8 *)v135
                   + *(unsigned __int8 *)(v138 + v100)
                   + *(unsigned __int8 *)(v141 + (unsigned __int16)v96) * (unint64_t)v129;
              if (v101 >= (unsigned __int8 *)v146 && (unint64_t)(v101 + 1) <= v89)
              {
                uint64_t v103 = &v127[*v101];
                if ((unint64_t)(v103 + 1) <= v89)
                {
                  unsigned int v104 = *v103;
                  if (v104)
                  {
                    TAATKernEngine::HandleKern<TRunGlue::TGlyph>(a1, (uint64_t)v92, v97, (int)bswap32(v104) >> 16, v14);
                    *a2 = 1;
                  }
LABEL_161:
                  ++v97;
                  uint64_t v96 = v100;
                  if (v93 == v97) {
                    goto LABEL_170;
                  }
                  continue;
                }
              }
              goto LABEL_170;
            }
          default:
            goto LABEL_171;
        }
      }
LABEL_173:
      uint64_t v10 = v142 + 1;
    }
    while (v142 + 1 != v5);
  }
  uint64_t result = TKerningEngineImplementation::MergeDeltas((TRunGlue **)a1, (void *)(a1 + 32), (void *)(a1 + 56), a2, (unsigned char *)(a1 + 80));
  if (result)
  {
    if (*(unsigned char *)(a1 + 80))
    {
      return TKerningEngineImplementation::TransferDeletedAdvances((TRunGlue **)a1);
    }
    return 1;
  }
  return result;
}

uint64_t TKerningEngineImplementation::MergeDeltas(TRunGlue **a1, void *a2, void *a3, unsigned char *a4, unsigned char *a5)
{
  uint64_t v6 = a3;
  uint64_t v8 = *a1;
  if (*((unsigned char *)*a1 + 634)) {
    double v9 = *((double *)*a1 + 81);
  }
  else {
    double v9 = *((double *)*a1 + 80);
  }
  if (*((unsigned char *)*a1 + 634)) {
    double v10 = *((double *)*a1 + 80);
  }
  else {
    double v10 = *((double *)*a1 + 81);
  }
  if (*a2 != a2[1])
  {
    uint64_t v57 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v12 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)uint64_t v55 = v12;
    long long v56 = v12;
    TAATPropTable::TAATPropTable((TAATPropTable *)v55, *((const __CTFont **)v8 + 76));
    CFComparisonResult v13 = (void *)*a2;
    unsigned int v14 = (void *)a2[1];
    while (v13 != v14)
    {
      int v15 = *((__int16 *)v13 + 4);
      if (!*((_WORD *)v13 + 4)) {
        goto LABEL_29;
      }
      uint64_t v16 = *v13;
      CFDictionaryRef v17 = *a1;
      uint64_t GlyphID = TRunGlue::GetGlyphID(*a1, *v13);
      if (GlyphID == 0xFFFF) {
        goto LABEL_29;
      }
      uint64_t v19 = GlyphID;
      if (TRunGlue::IsDeleted(v17, v16)) {
        goto LABEL_29;
      }
      __CFString v20 = (uint64_t (*)(void *, uint64_t))*((void *)&v56 + 1);
      long long v21 = (id *)((char *)v55 + (v57 >> 1));
      if (v57) {
        __CFString v20 = *(uint64_t (**)(void *, uint64_t))(*v21 + DWORD2(v56));
      }
      if ((v20(v21, v19) & 0x8000) != 0)
      {
LABEL_29:
        unint64_t v23 = v13;
      }
      else
      {
        __int16 v22 = v15;
        unint64_t v23 = v13 + 2;
        if (v13 + 2 == v14
          || *((__int16 *)v13 + 12) + v15
          || ((v24 = *v23, *v23 >= v16) ? (uint64_t v25 = v16) : (uint64_t v25 = *v23), (TRunGlue::GetGlyphProps(*a1, v25) & 0x1040) == 0))
        {
LABEL_27:
          uint64_t v29 = *a1;
          if (v16 <= 0)
          {
            v58.CGFloat width = v9 * (double)v22;
            v58.CGFloat height = 0.0;
            unint64_t v23 = v13;
            if ((TRunGlue::AdvanceInitialAdvance(*a1, v58) & 1) == 0)
            {

              return 0;
            }
          }
          else
          {
            uint64_t v30 = v16 - 1;
            double Advance = TRunGlue::GetAdvance(*a1, v30);
            TKerningEngineImplementation::SetAdvance<TRunGlue::TGlyph>(v29, v30, a5, Advance + v9 * (double)v22, v32);
            unint64_t v23 = v13;
          }
        }
        else
        {
          uint64_t v26 = v16;
          if (v24 >= v16) {
            uint64_t v26 = *v23;
          }
          uint64_t v27 = v25 + 1;
          while (v27 < v26)
          {
            if (!TRunGlue::IsDeleted(*a1, v27++)) {
              goto LABEL_27;
            }
          }
          if (v16 == v26) {
            __int16 v22 = *((_WORD *)v13 + 12);
          }
          unsigned __int16 v33 = *a1;
          v59.double x = TRunGlue::GetOrigin(*a1, v25) + v9 * (double)v22;
          TRunGlue::SetOrigin(v33, v25, v59);
        }
      }
      CFComparisonResult v13 = v23 + 2;
    }
    *a4 = 1;

    uint64_t v6 = a3;
  }
  if (!v6[2]) {
    return 1;
  }
  uint8x8_t v34 = (void *)*v6;
  if (*(void *)(*v6 + 32))
  {
    __int16 v35 = 0;
    goto LABEL_48;
  }
  __int16 v35 = *((_WORD *)v34 + 20);
  if (!v35) {
    goto LABEL_44;
  }
  v55[0] = *a1;
  v55[1] = 0;
  if (TRunGlue::TGlyph::IsDeleted((TRunGlue::TGlyph *)v55))
  {
    __int16 v35 = 0;
    goto LABEL_44;
  }
  v60.CGFloat height = v10 * (double)v35;
  v60.CGFloat width = 0.0;
  if (TRunGlue::AdvanceInitialAdvance(*a1, v60))
  {
LABEL_44:
    unsigned int v36 = (void *)v34[1];
    if (v36)
    {
      do
      {
        uint8x8_t v34 = v36;
        unsigned int v36 = (void *)*v36;
      }
      while (v36);
    }
    else
    {
      do
      {
        unsigned int v37 = v34;
        uint8x8_t v34 = (void *)v34[2];
      }
      while ((void *)*v34 != v37);
    }
LABEL_48:
    uint64_t v38 = v6 + 1;
    if (v34 != v6 + 1)
    {
      do
      {
        int64_t v39 = v34[4];
        v55[0] = *a1;
        v55[1] = (id)v39;
        BOOL IsDeleted = TRunGlue::TGlyph::IsDeleted((TRunGlue::TGlyph *)v55);
        if ((v39 & 0x8000000000000000) == 0 && !IsDeleted)
        {
          int v41 = *a1;
          uint64_t v42 = v39 - 1;
          double v43 = TRunGlue::GetAdvance(*a1, v42);
          double v45 = v43;
          double v46 = v44;
          if (*((unsigned char *)v34 + 42))
          {
            double v46 = v44 + -v10 * (double)v35;
            TKerningEngineImplementation::SetAdvance<TRunGlue::TGlyph>(v41, v42, a5, v43, v46);
            __int16 v35 = 0;
          }
          __int16 v47 = *((_WORD *)v34 + 20);
          if (v47)
          {
            TKerningEngineImplementation::SetAdvance<TRunGlue::TGlyph>(v41, v42, a5, v45, v46 + v10 * (double)v47);
            v35 += v47;
            int v48 = (TRun *)*((void *)*a1 + 19);
            if (v48) {
              TRun::NoteCrossStreamPosition(v48, v10 * (double)v35);
            }
          }
        }
        uint64_t v49 = (void *)v34[1];
        if (v49)
        {
          do
          {
            uint64_t v50 = v49;
            uint64_t v49 = (void *)*v49;
          }
          while (v49);
        }
        else
        {
          do
          {
            uint64_t v50 = (void *)v34[2];
            BOOL v51 = *v50 == (void)v34;
            uint8x8_t v34 = v50;
          }
          while (!v51);
        }
        uint8x8_t v34 = v50;
      }
      while (v50 != v38);
    }
    return 1;
  }
  return 0;
}

void TAATKernEngine::KernOrderedList::ProcessGlyphsT<TRunGlue::TGlyphInSingleRun>(uint64_t a1, unsigned char *a2)
{
  if (*(void *)(a1 + 56))
  {
    uint64_t v4 = *(void *)(a1 + 8);
    uint64_t v5 = **(TRunGlue ***)a1;
    uint64_t v6 = *((void *)v5 + 22);
    uint64_t v7 = *((void *)v5 + 20);
    uint64_t v8 = TRunGlue::length(v5);
    if (v8 >= 2)
    {
      uint64_t v9 = v8;
      uint64_t v48 = v4 + 8;
      double v10 = (unsigned __int16 *)(v6 + 2 * v7);
      uint64_t v11 = *v10;
      uint64_t v12 = v4 + 10;
      for (uint64_t i = 1; i != v9; ++i)
      {
        uint64_t v14 = v10[i];
        if (v14 == 0xFFFF || TRunGlue::IsDeleted(v5, i))
        {
          uint64_t v14 = v11;
          goto LABEL_7;
        }
        if (*(unsigned __int16 *)(a1 + 50) >= (unsigned __int16)v11)
        {
          if (*(_WORD *)(*(void *)(a1 + 56) + 2 * (unsigned __int16)v11))
          {
            unsigned int v15 = *(unsigned __int16 *)(a1 + 48);
            if (v15 > (unsigned __int16)(*(_WORD *)(*(void *)(a1 + 56) + 2 * (unsigned __int16)v11) - 1))
            {
              unsigned __int16 v16 = *(_WORD *)(*(void *)(a1 + 56) + 2 * (unsigned __int16)v11) - 1;
              CFDictionaryRef v17 = (unsigned __int16 *)(v12 + 6 * v16);
              do
              {
                unsigned int v18 = bswap32(*(v17 - 1)) >> 16;
                if (v18 == (unsigned __int16)v11)
                {
                  if (v14 <= bswap32(*v17) >> 16) {
                    goto LABEL_19;
                  }
                }
                else if (v18 >= (unsigned __int16)v11)
                {
LABEL_19:
                  unsigned int v19 = v16;
                  __CFString v20 = (unsigned __int16 *)(v48 + 6 * v16);
                  if ((unsigned __int16)v11 == bswap32(*v20) >> 16 && v14 == bswap32(v20[1]) >> 16)
                  {
                    unsigned int v21 = *(unsigned __int16 *)(v48 + 6 * v19 + 4);
                    if (v21)
                    {
                      __int16 v22 = *(TRunGlue ***)a1;
                      __int16 v23 = *(_WORD *)(a1 + 24);
                      int v24 = (int)(*(double *)(*(void *)a1 + 24) * (double)((int)bswap32(v21) >> 16));
                      int v46 = v24;
                      if ((v23 & 0x4000) != 0)
                      {
                        uint64_t v49 = i;
                        uint64_t v50 = &v49;
                        CFDictionaryRef v28 = std::__tree<std::__value_type<long,TAATDeltaYListEntry>,std::__map_value_compare<long,std::__value_type<long,TAATDeltaYListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TAATDeltaYListEntry>>>::__emplace_unique_key_args<long,std::piecewise_construct_t const&,std::tuple<long &&>,std::tuple<>>((uint64_t **)v22 + 7, &v49, (uint64_t)&std::piecewise_construct, &v50);
                        __int16 v29 = v46;
                        if (v46 == -32768)
                        {
                          __int16 v29 = 0;
                          *((unsigned char *)v28 + 42) = 1;
                        }
                        else if ((v23 & 0x800) == 0)
                        {
                          __int16 v29 = *((_WORD *)v28 + 20) + v46;
                        }
                        *((_WORD *)v28 + 20) = v29;
                      }
                      else
                      {
                        if ((*(_WORD *)(a1 + 24) & 0x800) != 0)
                        {
                          uint64_t v25 = (uint64_t)v22[4];
                          uint64_t v26 = (uint64_t)v22[5];
                          if (v25 == v26) {
                            goto LABEL_40;
                          }
                          while (*(void *)v25 != i)
                          {
                            v25 += 16;
                            if (v25 == v26)
                            {
                              uint64_t v27 = *(TRunGlue ***)a1;
                              uint64_t v25 = (uint64_t)v22[5];
                              goto LABEL_41;
                            }
                          }
                          if (v25 == v26 || (uint64_t v30 = v25 + 16, v25 + 16 == v26))
                          {
LABEL_40:
                            uint64_t v27 = *(TRunGlue ***)a1;
                          }
                          else
                          {
                            uint64_t v27 = *(TRunGlue ***)a1;
                            do
                            {
                              if (*(void *)v30 != i)
                              {
                                *(void *)uint64_t v25 = *(void *)v30;
                                *(_WORD *)(v25 + 8) = *(_WORD *)(v30 + 8);
                                v25 += 16;
                              }
                              v30 += 16;
                            }
                            while (v30 != v26);
                          }
LABEL_41:
                          std::vector<std::pair<long,TAATDeltaXListEntry>>::erase((uint64_t)(v22 + 4), v25, v26);
                          __int16 v22 = v27;
                          LOWORD(v24) = v46;
                        }
                        uint64_t v31 = (char *)v22[6];
                        double v32 = (uint64_t *)v22[5];
                        if (v32 >= (uint64_t *)v31)
                        {
                          uint8x8_t v34 = (char *)v22[4];
                          uint64_t v45 = ((char *)v32 - v34) >> 4;
                          unint64_t v35 = v45 + 1;
                          if ((unint64_t)(v45 + 1) >> 60) {
                            abort();
                          }
                          unsigned int v36 = v22;
                          uint64_t v37 = v31 - v34;
                          if (v37 >> 3 > v35) {
                            unint64_t v35 = v37 >> 3;
                          }
                          if ((unint64_t)v37 >= 0x7FFFFFFFFFFFFFF0) {
                            unint64_t v38 = 0xFFFFFFFFFFFFFFFLL;
                          }
                          else {
                            unint64_t v38 = v35;
                          }
                          uint64_t v40 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CGSize>>((uint64_t)(v22 + 6), v38);
                          int v41 = &v40[16 * v45];
                          *(void *)int v41 = i;
                          *((_WORD *)v41 + 4) = v46;
                          double v43 = v36[4];
                          uint64_t v42 = v36[5];
                          __int16 v22 = v36;
                          double v44 = v41;
                          if (v42 != v43)
                          {
                            do
                            {
                              *((_OWORD *)v44 - 1) = *((_OWORD *)v42 - 1);
                              v44 -= 16;
                              uint64_t v42 = (TRunGlue *)((char *)v42 - 16);
                            }
                            while (v42 != v43);
                            uint64_t v42 = v36[4];
                          }
                          unsigned __int16 v33 = (TRunGlue *)(v41 + 16);
                          _OWORD v22[4] = (TRunGlue *)v44;
                          v22[5] = (TRunGlue *)(v41 + 16);
                          v22[6] = (TRunGlue *)&v40[16 * v39];
                          if (v42)
                          {
                            __int16 v47 = v22;
                            operator delete(v42);
                            __int16 v22 = v47;
                          }
                        }
                        else
                        {
                          *double v32 = i;
                          *((_WORD *)v32 + 4) = v24;
                          unsigned __int16 v33 = (TRunGlue *)(v32 + 2);
                        }
                        v22[5] = v33;
                      }
                      *a2 = 1;
                    }
                  }
                  break;
                }
                ++v16;
                v17 += 3;
              }
              while (v15 != v16);
            }
          }
        }
LABEL_7:
        uint64_t v11 = v14;
      }
    }
  }
}

void TAATKernEngine::KernOrderedList::ProcessGlyphsT<TRunGlue::TGlyphInVector>(uint64_t a1, unsigned char *a2)
{
  if (*(void *)(a1 + 56))
  {
    uint64_t v4 = *(void *)(a1 + 8);
    uint64_t v5 = **(TRunGlue ***)a1;
    uint64_t v6 = *((void *)v5 + 22);
    uint64_t v7 = *((void *)v5 + 20);
    uint64_t v8 = TRunGlue::length(v5);
    if (v8 >= 2)
    {
      uint64_t v9 = v8;
      uint64_t v10 = v4 + 8;
      uint64_t v11 = (unsigned __int16 *)(v6 + 2 * v7);
      uint64_t v12 = *v11;
      uint64_t v13 = v4 + 10;
      for (uint64_t i = 1; i != v9; ++i)
      {
        uint64_t v15 = v11[i];
        if (v15 == 0xFFFF)
        {
          uint64_t v15 = v12;
          goto LABEL_16;
        }
        if (*(unsigned __int16 *)(a1 + 50) >= (unsigned __int16)v12)
        {
          if (*(_WORD *)(*(void *)(a1 + 56) + 2 * (unsigned __int16)v12))
          {
            unsigned int v16 = *(unsigned __int16 *)(a1 + 48);
            if (v16 > (unsigned __int16)(*(_WORD *)(*(void *)(a1 + 56) + 2 * (unsigned __int16)v12) - 1))
            {
              unsigned __int16 v17 = *(_WORD *)(*(void *)(a1 + 56) + 2 * (unsigned __int16)v12) - 1;
              unsigned int v18 = (unsigned __int16 *)(v13 + 6 * v17);
              do
              {
                unsigned int v19 = bswap32(*(v18 - 1)) >> 16;
                if (v19 == (unsigned __int16)v12)
                {
                  if (v15 <= bswap32(*v18) >> 16) {
                    goto LABEL_18;
                  }
                }
                else if (v19 >= (unsigned __int16)v12)
                {
LABEL_18:
                  unsigned int v20 = v17;
                  unsigned int v21 = (unsigned __int16 *)(v10 + 6 * v17);
                  if ((unsigned __int16)v12 == bswap32(*v21) >> 16
                    && v15 == bswap32(v21[1]) >> 16
                    && *(_WORD *)(v10 + 6 * v20 + 4))
                  {
                    __int16 v22 = *(TRunGlue ***)a1;
                    __int16 v23 = *(_WORD *)(a1 + 24);
                    double v24 = *(double *)(*(void *)a1 + 24)
                        * (double)((int)bswap32(*(unsigned __int16 *)(v10 + 6 * v20 + 4)) >> 16);
                    int v25 = (int)v24;
                    if ((v23 & 0x4000) != 0)
                    {
                      uint64_t v50 = v10;
                      uint64_t v52 = i;
                      unsigned int v53 = &v52;
                      int v29 = (int)v24;
                      uint64_t v30 = std::__tree<std::__value_type<long,TAATDeltaYListEntry>,std::__map_value_compare<long,std::__value_type<long,TAATDeltaYListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TAATDeltaYListEntry>>>::__emplace_unique_key_args<long,std::piecewise_construct_t const&,std::tuple<long &&>,std::tuple<>>((uint64_t **)v22 + 7, &v52, (uint64_t)&std::piecewise_construct, &v53);
                      if (v29 == -32768)
                      {
                        LOWORD(v29) = 0;
                        *((unsigned char *)v30 + 42) = 1;
                      }
                      else if ((v23 & 0x800) == 0)
                      {
                        LOWORD(v29) = *((_WORD *)v30 + 20) + v29;
                      }
                      *((_WORD *)v30 + 20) = v29;
                      uint64_t v10 = v50;
                    }
                    else
                    {
                      int v49 = (int)v24;
                      if ((*(_WORD *)(a1 + 24) & 0x800) != 0)
                      {
                        uint64_t v26 = (uint64_t)v22[4];
                        uint64_t v27 = (uint64_t)v22[5];
                        __int16 v47 = *(TRunGlue ***)a1;
                        if (v26 == v27) {
                          goto LABEL_39;
                        }
                        while (*(void *)v26 != i)
                        {
                          v26 += 16;
                          if (v26 == v27)
                          {
                            uint64_t v28 = v10;
                            uint64_t v26 = (uint64_t)v22[5];
                            goto LABEL_40;
                          }
                        }
                        if (v26 == v27 || (uint64_t v31 = v26 + 16, v26 + 16 == v27))
                        {
LABEL_39:
                          uint64_t v28 = v10;
                        }
                        else
                        {
                          uint64_t v28 = v10;
                          do
                          {
                            if (*(void *)v31 != i)
                            {
                              *(void *)uint64_t v26 = *(void *)v31;
                              *(_WORD *)(v26 + 8) = *(_WORD *)(v31 + 8);
                              v26 += 16;
                            }
                            v31 += 16;
                          }
                          while (v31 != v27);
                        }
LABEL_40:
                        std::vector<std::pair<long,TAATDeltaXListEntry>>::erase((uint64_t)(v22 + 4), v26, v27);
                        uint64_t v10 = v28;
                        __int16 v22 = v47;
                        LOWORD(v25) = v49;
                      }
                      double v32 = (char *)v22[6];
                      unsigned __int16 v33 = (uint64_t *)v22[5];
                      if (v33 >= (uint64_t *)v32)
                      {
                        uint64_t v51 = v10;
                        unint64_t v35 = (char *)v22[4];
                        uint64_t v46 = ((char *)v33 - v35) >> 4;
                        unint64_t v36 = v46 + 1;
                        if ((unint64_t)(v46 + 1) >> 60) {
                          abort();
                        }
                        uint64_t v37 = v22;
                        uint64_t v38 = v32 - v35;
                        if (v38 >> 3 > v36) {
                          unint64_t v36 = v38 >> 3;
                        }
                        if ((unint64_t)v38 >= 0x7FFFFFFFFFFFFFF0) {
                          unint64_t v39 = 0xFFFFFFFFFFFFFFFLL;
                        }
                        else {
                          unint64_t v39 = v36;
                        }
                        int v41 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CGSize>>((uint64_t)(v22 + 6), v39);
                        uint64_t v42 = &v41[16 * v46];
                        *(void *)uint64_t v42 = i;
                        *((_WORD *)v42 + 4) = v49;
                        double v44 = v37[4];
                        double v43 = v37[5];
                        __int16 v22 = v37;
                        uint64_t v45 = v42;
                        if (v43 != v44)
                        {
                          do
                          {
                            *((_OWORD *)v45 - 1) = *((_OWORD *)v43 - 1);
                            v45 -= 16;
                            double v43 = (TRunGlue *)((char *)v43 - 16);
                          }
                          while (v43 != v44);
                          double v43 = v37[4];
                        }
                        uint8x8_t v34 = (TRunGlue *)(v42 + 16);
                        _OWORD v22[4] = (TRunGlue *)v45;
                        v22[5] = (TRunGlue *)(v42 + 16);
                        v22[6] = (TRunGlue *)&v41[16 * v40];
                        if (v43)
                        {
                          uint64_t v48 = v22;
                          operator delete(v43);
                          __int16 v22 = v48;
                        }
                        uint64_t v10 = v51;
                      }
                      else
                      {
                        uint64_t *v33 = i;
                        *((_WORD *)v33 + 4) = v25;
                        uint8x8_t v34 = (TRunGlue *)(v33 + 2);
                      }
                      v22[5] = v34;
                    }
                    *a2 = 1;
                  }
                  break;
                }
                ++v17;
                v18 += 3;
              }
              while (v16 != v17);
            }
          }
        }
LABEL_16:
        uint64_t v12 = v15;
      }
    }
  }
}

void TBaseFont::AddKerningDataAtIndex(void *a1, uint64_t *a2, unint64_t a3)
{
  uint64_t v4 = a1[61];
  if (a3 >= (a1[62] - v4) >> 3)
  {
    uint64_t v8 = (int64x2_t *)(a1 + 61);
    std::vector<std::unique_ptr<unsigned short const[]>,TInlineBufferAllocator<std::unique_ptr<unsigned short const[]>,4ul>>::resize((uint64_t)(a1 + 61), a3);
    uint64_t v10 = (void *)a1[62];
    unint64_t v9 = a1[63];
    if ((unint64_t)v10 >= v9)
    {
      uint64_t v13 = a1[61];
      uint64_t v14 = ((uint64_t)v10 - v13) >> 3;
      if ((unint64_t)(v14 + 1) >> 61) {
        abort();
      }
      uint64_t v15 = v9 - v13;
      uint64_t v16 = v15 >> 2;
      if (v15 >> 2 <= (unint64_t)(v14 + 1)) {
        uint64_t v16 = v14 + 1;
      }
      if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v17 = v16;
      }
      uint64_t v30 = a1 + 64;
      if (v17) {
        unsigned int v18 = (char *)TInlineBufferAllocator<std::unique_ptr<unsigned short const[]>,4ul>::allocate((uint64_t)(a1 + 64), v17);
      }
      else {
        unsigned int v18 = 0;
      }
      unsigned int v19 = &v18[8 * v14];
      unsigned int v20 = &v18[8 * v17];
      int v29 = v20;
      uint64_t v21 = *a2;
      *a2 = 0;
      *(void *)unsigned int v19 = v21;
      uint64_t v12 = v19 + 8;
      v28.i64[1] = (uint64_t)(v19 + 8);
      __int16 v23 = (void *)a1[61];
      __int16 v22 = (void *)a1[62];
      if (v22 == v23)
      {
        int64x2_t v25 = vdupq_n_s64((unint64_t)v22);
      }
      else
      {
        do
        {
          uint64_t v24 = *--v22;
          void *v22 = 0;
          *((void *)v19 - 1) = v24;
          v19 -= 8;
        }
        while (v22 != v23);
        int64x2_t v25 = *v8;
        uint64_t v12 = (void *)v28.i64[1];
        unsigned int v20 = v29;
      }
      a1[61] = v19;
      a1[62] = v12;
      int64x2_t v28 = v25;
      uint64_t v26 = (char *)a1[63];
      a1[63] = v20;
      int v29 = v26;
      uint64_t v27 = v25.i64[0];
      std::__split_buffer<std::unique_ptr<unsigned short const[]>,TInlineBufferAllocator<std::unique_ptr<unsigned short const[]>,4ul> &>::~__split_buffer(&v27);
    }
    else
    {
      uint64_t v11 = *a2;
      *a2 = 0;
      *uint64_t v10 = v11;
      uint64_t v12 = v10 + 1;
    }
    a1[62] = v12;
  }
  else
  {
    uint64_t v5 = *a2;
    *a2 = 0;
    uint64_t v6 = *(void *)(v4 + 8 * a3);
    *(void *)(v4 + 8 * a3) = v5;
    if (v6)
    {
      JUMPOUT(0x1853275A0);
    }
  }
}

void std::vector<std::unique_ptr<unsigned short const[]>,TInlineBufferAllocator<std::unique_ptr<unsigned short const[]>,4ul>>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      std::vector<std::unique_ptr<unsigned short const[]>,TInlineBufferAllocator<std::unique_ptr<unsigned short const[]>,4ul>>::__base_destruct_at_end[abi:nn180100](a1, (void *)(*(void *)a1 + 8 * a2));
    }
  }
  else
  {
    std::vector<std::unique_ptr<unsigned short const[]>,TInlineBufferAllocator<std::unique_ptr<unsigned short const[]>,4ul>>::__append((long long *)a1, a2 - v2);
  }
}

void *std::__split_buffer<std::unique_ptr<unsigned short const[]>,TInlineBufferAllocator<std::unique_ptr<unsigned short const[]>,4ul> &>::~__split_buffer(void *a1)
{
  std::__split_buffer<std::unique_ptr<unsigned short const[]>,TInlineBufferAllocator<std::unique_ptr<unsigned short const[]>,4ul> &>::__destruct_at_end[abi:nn180100]((uint64_t)a1, a1[1]);
  unint64_t v2 = (void *)*a1;
  if (*a1)
  {
    unint64_t v3 = a1[4];
    uint64_t v4 = (void *)(v3 + 32);
    if (v3 <= (unint64_t)v2 && v4 > v2)
    {
      if (a1[3] == *v4) {
        *uint64_t v4 = v2;
      }
    }
    else
    {
      operator delete(v2);
    }
  }
  return a1;
}

uint64_t std::__split_buffer<std::unique_ptr<unsigned short const[]>,TInlineBufferAllocator<std::unique_ptr<unsigned short const[]>,4ul> &>::__destruct_at_end[abi:nn180100](uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 16);
  if (v2 != a2)
  {
    uint64_t v4 = result;
    do
    {
      *(void *)(v4 + 16) = v2 - 8;
      uint64_t result = *(void *)(v2 - 8);
      *(void *)(v2 - 8) = 0;
      if (result) {
        uint64_t result = MEMORY[0x1853275A0](result, 0x1000C80BDFB0063);
      }
      uint64_t v2 = *(void *)(v4 + 16);
    }
    while (v2 != a2);
  }
  return result;
}

void *TInlineBufferAllocator<std::unique_ptr<unsigned short const[]>,4ul>::allocate(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v2 = (unint64_t *)(a1 + 32);
  uint64_t v3 = v4;
  unint64_t v5 = v4 + 8 * a2;
  if (v5 <= (unint64_t)v2)
  {
    *uint64_t v2 = v5;
    return (void *)v3;
  }
  else
  {
    if (a2 >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    return operator new(8 * a2);
  }
}

uint64_t CTFontHasTable(uint64_t a1, int a2)
{
  if (a1 && a2) {
    return (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 40) + 400) + 472))();
  }
  else {
    return 0;
  }
}

BOOL TCFBase<TRunDelegate>::ClassEqual(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 40);
  uint64_t v3 = *(void **)(a2 + 40);
  return !memcmp(v2, v3, 0x28uLL) && v2[5] == v3[5];
}

uint64_t _CTFontCreateWithNameAndSymbolicTraits(__CFString *a1, unsigned int a2, CGFloat a3)
{
  if (!a1) {
    return 0;
  }
  unint64_t v5 = a1;
  if ((a2 & 2) != 0) {
    uint64_t v6 = 700;
  }
  else {
    uint64_t v6 = 400;
  }
  TDescriptorSource::TDescriptorSource((TDescriptorSource *)&v36);
  if ((a2 & 0x1000) != 0)
  {
    unsigned int v8 = a2 & 0xFFFFEFFF;
    unint64_t v9 = 1026;
  }
  else
  {
    unint64_t v5 = TDescriptorSource::SubstituteFontNameForInvisibleFontName(v5, v7);
    unint64_t v9 = 2;
    unsigned int v8 = a2;
  }
  int v10 = a2 & 1;
  if (v5 == @"Helvetica") {
    goto LABEL_11;
  }
  uint64_t v11 = 16;
  if (!v5) {
    goto LABEL_12;
  }
  if (CFEqual(v5, @"Helvetica")) {
LABEL_11:
  }
    uint64_t v11 = 18;
  else {
    uint64_t v11 = 16;
  }
LABEL_12:
  id v35 = (id)0xAAAAAAAAAAAAAAAALL;
  TDescriptorSource::CopyFontDescriptorPerPostScriptName(&v36, v5, v9, v11, 0, &v35);
  if (!atomic_load_explicit((atomic_ullong *volatile)&v35, memory_order_acquire))
  {
    id v34 = (id)0xAAAAAAAAAAAAAAAALL;
    TDescriptorSource::CopyMatchingDescriptorsForFamily((TDescriptorSource *)&v36, v5, &v34);
    CFArrayRef v21 = (const __CFArray *)(id)atomic_load_explicit((atomic_ullong *volatile)&v34, memory_order_acquire);
    if (v21)
    {
      CFArrayRef v22 = v21;
      CFIndex Count = CFArrayGetCount(v21);

      if (Count < 1) {
        goto LABEL_27;
      }
      if ((a2 & 0x1000) == 0)
      {
        goto LABEL_42;
      }
      TCFNumber::TCFNumber<unsigned int>(&v33, v8);
      id values = (id)atomic_load_explicit((atomic_ullong *volatile)&v33, memory_order_acquire);
      id keys = @"NSCTFontSymbolicTrait";
      CFArrayRef v25 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);

      TDescriptorSource::CreateVariantWithTraitsMatchingDescriptors((TDescriptorSource *)atomic_load_explicit((atomic_ullong *volatile)&v34, memory_order_acquire), v25, &keys);
      if (atomic_load_explicit((atomic_ullong *volatile)&v35, memory_order_acquire))
      {
        uint64_t v6 = (uint64_t)CTFontCreateWithFontDescriptor((CTFontDescriptorRef)atomic_load_explicit((atomic_ullong *volatile)&v35, memory_order_acquire), a3, 0);

LABEL_43:
        id v31 = v34;
LABEL_44:

        goto LABEL_45;
      }
    }
    else
    {
      CFArrayRef v25 = 0;
    }

LABEL_27:
    CFStringRef v26 = (const __CFString *)TDescriptorSource::UIFontNameForFullName((uint64_t)v5, v24);
    if (!v26
      || (TDescriptorSource::CopyFontDescriptorPerPostScriptName(&v36, v26, 0x402uLL, 1, 0, &keys),
          (id)atomic_exchange((atomic_ullong *volatile)&v35, atomic_exchange((atomic_ullong *volatile)&keys, 0)), keys, !atomic_load_explicit((atomic_ullong *volatile)&v35, memory_order_acquire)))
    {
      uint64_t v6 = 0;
      goto LABEL_43;
    }
    CTFontRef v27 = CTFontCreateWithFontDescriptor((CTFontDescriptorRef)atomic_load_explicit((atomic_ullong *volatile)&v35, memory_order_acquire), a3, 0);
LABEL_42:
    uint64_t v6 = (uint64_t)v27;
    goto LABEL_43;
  }
  if ((a2 & 0x1000) != 0 || (a2 & 3) == 0)
  {
LABEL_35:
    CFArrayRef explicit = (const __CTFontDescriptor *)atomic_load_explicit((atomic_ullong *volatile)&v35, memory_order_acquire);
    if (v8) {
      CopyWithSymbolicTraits = CTFontDescriptorCreateCopyWithSymbolicTraits(explicit, v8, v8);
    }
    else {
      CopyWithSymbolicTraits = explicit;
    }
    uint64_t v30 = CopyWithSymbolicTraits;
    if (!CopyWithSymbolicTraits) {
      CopyWithSymbolicTraits = (const __CTFontDescriptor *)atomic_load_explicit((atomic_ullong *volatile)&v35, memory_order_acquire);
    }
    uint64_t v6 = (uint64_t)CTFontCreateWithFontDescriptor(CopyWithSymbolicTraits, a3, 0);
    id v31 = v30;
    goto LABEL_44;
  }
  uint64_t v12 = (id)atomic_load_explicit((atomic_ullong *volatile)&v35, memory_order_acquire);
  uint64_t v13 = (atomic_ullong *)v12[5];

  TDescriptor::CopyAttribute(v13, @"NSFontFamilyAttribute", &keys);
  uint64_t v14 = (__CFString *)atomic_exchange((atomic_ullong *volatile)&keys, 0);

  id keys = (id)0xAAAAAAAAAAAAAAAALL;
  TDescriptorSource::CopyMatchingDescriptorsForFamily((TDescriptorSource *)&v36, v14, &keys);
  CFArrayRef v15 = (const __CFArray *)(id)atomic_load_explicit((atomic_ullong *volatile)&keys, memory_order_acquire);
  CFArrayRef v16 = v15;
  BOOL v17 = v15 == 0;
  if (!v15) {
    goto LABEL_32;
  }
  CFIndex v18 = CFArrayGetCount(v15);

  if (v18 >= 1)
  {
    id values = (id)CTFontDescriptorCopyAttribute((CTFontDescriptorRef)atomic_load_explicit((atomic_ullong *volatile)&v35, memory_order_acquire), @"NSCTFontTraitsAttribute");
    CFArrayRef v16 = (const __CFArray *)atomic_exchange((atomic_ullong *volatile)&values, 0);

    int v19 = GetSymbolicTraitsFromTraits(v16) & 0x61;
    if (v10 != v19)
    {
      v10 |= v19;
      id values = CTFontDescriptorCreateCopyWithSymbolicTraits((CTFontDescriptorRef)atomic_load_explicit((atomic_ullong *volatile)&v35, memory_order_acquire), v10, 0x61u);
    }
    id values = (id)CTFontDescriptorCopyAttribute((CTFontDescriptorRef)atomic_load_explicit((atomic_ullong *volatile)&v35, memory_order_acquire), @"NSCTFontPostScriptNameAttribute");
    unsigned int v20 = (void *)atomic_exchange((atomic_ullong *volatile)&values, 0);

LABEL_32:

    goto LABEL_34;
  }
  BOOL v17 = 1;
LABEL_34:

  if (v17) {
    goto LABEL_35;
  }
LABEL_45:

  return v6;
}

const __CFDictionary *TSplicedFont::AddDescriptorAttributes(atomic_ullong *a1, int64x2_t *a2, int64x2_t *a3)
{
  if (((*(uint64_t (**)(atomic_ullong *))(*a1 + 840))(a1) & 1) == 0)
  {
    CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit(a1 + 75, memory_order_acquire);
    if (explicit)
    {
      CFDictionaryRef Value = CFDictionaryGetValue(explicit, @"NSCTFontUIUsageAttribute");
      if (Value)
      {
        unsigned int v8 = Value;
        int v10 = (void *)a2->i64[1];
        unint64_t v9 = a2[1].u64[0];
        if ((unint64_t)v10 >= v9)
        {
          uint64_t v12 = ((uint64_t)v10 - a2->i64[0]) >> 3;
          if ((unint64_t)(v12 + 1) >> 61) {
            goto LABEL_142;
          }
          uint64_t v13 = v9 - a2->i64[0];
          uint64_t v14 = v13 >> 2;
          if (v13 >> 2 <= (unint64_t)(v12 + 1)) {
            uint64_t v14 = v12 + 1;
          }
          if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v15 = v14;
          }
          unint64_t v138 = &a2[1].i64[1];
          if (v15) {
            CFArrayRef v16 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&a2[1].i64[1], v15);
          }
          else {
            CFArrayRef v16 = 0;
          }
          BOOL v17 = &v16[8 * v12];
          CFIndex v18 = &v16[8 * v15];
          BOOL v137 = v18;
          *(void *)BOOL v17 = @"NSCTFontUIUsageAttribute";
          uint64_t v11 = v17 + 8;
          v136.i64[1] = (uint64_t)(v17 + 8);
          uint64_t v20 = a2->i64[0];
          unint64_t v19 = a2->u64[1];
          if (v19 == a2->i64[0])
          {
            int64x2_t v22 = vdupq_n_s64(v19);
          }
          else
          {
            do
            {
              uint64_t v21 = *(void *)(v19 - 8);
              v19 -= 8;
              *((void *)v17 - 1) = v21;
              v17 -= 8;
            }
            while (v19 != v20);
            int64x2_t v22 = *a2;
            uint64_t v11 = (void *)v136.i64[1];
            CFIndex v18 = v137;
          }
          a2->i64[0] = (uint64_t)v17;
          a2->i64[1] = (uint64_t)v11;
          int64x2_t v136 = v22;
          __int16 v23 = (char *)a2[1].i64[0];
          a2[1].i64[0] = (uint64_t)v18;
          BOOL v137 = v23;
          id v135 = (id)v22.i64[0];
          std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v135);
        }
        else
        {
          *int v10 = @"NSCTFontUIUsageAttribute";
          uint64_t v11 = v10 + 1;
        }
        a2->i64[1] = (uint64_t)v11;
        CFArrayRef v25 = (void *)a3->i64[1];
        unint64_t v24 = a3[1].u64[0];
        if ((unint64_t)v25 >= v24)
        {
          uint64_t v27 = ((uint64_t)v25 - a3->i64[0]) >> 3;
          if ((unint64_t)(v27 + 1) >> 61) {
            goto LABEL_142;
          }
          uint64_t v28 = v24 - a3->i64[0];
          uint64_t v29 = v28 >> 2;
          if (v28 >> 2 <= (unint64_t)(v27 + 1)) {
            uint64_t v29 = v27 + 1;
          }
          if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v30 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v30 = v29;
          }
          unint64_t v138 = &a3[1].i64[1];
          if (v30) {
            id v31 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&a3[1].i64[1], v30);
          }
          else {
            id v31 = 0;
          }
          double v32 = &v31[8 * v27];
          id v33 = &v31[8 * v30];
          BOOL v137 = v33;
          *(void *)double v32 = v8;
          CFStringRef v26 = v32 + 8;
          v136.i64[1] = (uint64_t)(v32 + 8);
          uint64_t v35 = a3->i64[0];
          unint64_t v34 = a3->u64[1];
          if (v34 == a3->i64[0])
          {
            int64x2_t v37 = vdupq_n_s64(v34);
          }
          else
          {
            do
            {
              uint64_t v36 = *(void *)(v34 - 8);
              v34 -= 8;
              *((void *)v32 - 1) = v36;
              v32 -= 8;
            }
            while (v34 != v35);
            int64x2_t v37 = *a3;
            CFStringRef v26 = (void *)v136.i64[1];
            id v33 = v137;
          }
          a3->i64[0] = (uint64_t)v32;
          a3->i64[1] = (uint64_t)v26;
          int64x2_t v136 = v37;
          uint64_t v38 = (char *)a3[1].i64[0];
          a3[1].i64[0] = (uint64_t)v33;
          BOOL v137 = v38;
          id v135 = (id)v37.i64[0];
          std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v135);
        }
        else
        {
          *CFArrayRef v25 = v8;
          CFStringRef v26 = v25 + 1;
        }
        a3->i64[1] = (uint64_t)v26;
        (*(void (**)(id *__return_ptr, atomic_ullong *, uint64_t))(*a1 + 40))(&v135, a1, 57);
        unint64_t v39 = (void *)atomic_exchange((atomic_ullong *volatile)&v135, 0);

        if (v39)
        {
          int v41 = (void *)a2->i64[1];
          unint64_t v40 = a2[1].u64[0];
          if ((unint64_t)v41 >= v40)
          {
            uint64_t v43 = ((uint64_t)v41 - a2->i64[0]) >> 3;
            if ((unint64_t)(v43 + 1) >> 61) {
              goto LABEL_142;
            }
            uint64_t v44 = v40 - a2->i64[0];
            uint64_t v45 = v44 >> 2;
            if (v44 >> 2 <= (unint64_t)(v43 + 1)) {
              uint64_t v45 = v43 + 1;
            }
            if ((unint64_t)v44 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v46 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v46 = v45;
            }
            unint64_t v138 = &a2[1].i64[1];
            if (v46) {
              __int16 v47 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&a2[1].i64[1], v46);
            }
            else {
              __int16 v47 = 0;
            }
            uint64_t v48 = &v47[8 * v43];
            int v49 = &v47[8 * v46];
            BOOL v137 = v49;
            *(void *)uint64_t v48 = @"NSCTFontTraitsAttribute";
            uint64_t v42 = v48 + 8;
            v136.i64[1] = (uint64_t)(v48 + 8);
            uint64_t v51 = a2->i64[0];
            unint64_t v50 = a2->u64[1];
            if (v50 == a2->i64[0])
            {
              int64x2_t v53 = vdupq_n_s64(v50);
            }
            else
            {
              do
              {
                uint64_t v52 = *(void *)(v50 - 8);
                v50 -= 8;
                *((void *)v48 - 1) = v52;
                v48 -= 8;
              }
              while (v50 != v51);
              int64x2_t v53 = *a2;
              uint64_t v42 = (void *)v136.i64[1];
              int v49 = v137;
            }
            a2->i64[0] = (uint64_t)v48;
            a2->i64[1] = (uint64_t)v42;
            int64x2_t v136 = v53;
            uint64_t v54 = (char *)a2[1].i64[0];
            a2[1].i64[0] = (uint64_t)v49;
            BOOL v137 = v54;
            id v135 = (id)v53.i64[0];
            std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v135);
          }
          else
          {
            void *v41 = @"NSCTFontTraitsAttribute";
            uint64_t v42 = v41 + 1;
          }
          a2->i64[1] = (uint64_t)v42;
          long long v56 = (void *)a3->i64[1];
          unint64_t v55 = a3[1].u64[0];
          if ((unint64_t)v56 >= v55)
          {
            uint64_t v58 = ((uint64_t)v56 - a3->i64[0]) >> 3;
            if ((unint64_t)(v58 + 1) >> 61) {
              goto LABEL_142;
            }
            uint64_t v59 = v55 - a3->i64[0];
            uint64_t v60 = v59 >> 2;
            if (v59 >> 2 <= (unint64_t)(v58 + 1)) {
              uint64_t v60 = v58 + 1;
            }
            if ((unint64_t)v59 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v61 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v61 = v60;
            }
            unint64_t v138 = &a3[1].i64[1];
            if (v61) {
              unint64_t v62 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&a3[1].i64[1], v61);
            }
            else {
              unint64_t v62 = 0;
            }
            unsigned __int16 v63 = &v62[8 * v58];
            uint64_t v64 = &v62[8 * v61];
            BOOL v137 = v64;
            *(void *)unsigned __int16 v63 = v39;
            uint64_t v57 = v63 + 8;
            v136.i64[1] = (uint64_t)(v63 + 8);
            uint64_t v66 = a3->i64[0];
            unint64_t v65 = a3->u64[1];
            if (v65 == a3->i64[0])
            {
              int64x2_t v68 = vdupq_n_s64(v65);
            }
            else
            {
              do
              {
                uint64_t v67 = *(void *)(v65 - 8);
                v65 -= 8;
                *((void *)v63 - 1) = v67;
                v63 -= 8;
              }
              while (v65 != v66);
              int64x2_t v68 = *a3;
              uint64_t v57 = (void *)v136.i64[1];
              uint64_t v64 = v137;
            }
            a3->i64[0] = (uint64_t)v63;
            a3->i64[1] = (uint64_t)v57;
            int64x2_t v136 = v68;
            CFDictionaryRef v69 = (char *)a3[1].i64[0];
            a3[1].i64[0] = (uint64_t)v64;
            BOOL v137 = v69;
            id v135 = (id)v68.i64[0];
            std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v135);
          }
          else
          {
            void *v56 = v39;
            uint64_t v57 = v56 + 1;
          }
          a3->i64[1] = (uint64_t)v57;
        }
      }
    }
    CFDictionaryRef v70 = (const __CFDictionary *)atomic_load_explicit(a1 + 75, memory_order_acquire);
    if (v70)
    {
      uint64_t v71 = CFDictionaryGetValue(v70, @"language");
      if (v71)
      {
        CFArrayRef v72 = v71;
        uint64_t v74 = (void *)a2->i64[1];
        unint64_t v73 = a2[1].u64[0];
        if ((unint64_t)v74 >= v73)
        {
          uint64_t v76 = ((uint64_t)v74 - a2->i64[0]) >> 3;
          if ((unint64_t)(v76 + 1) >> 61) {
            goto LABEL_142;
          }
          uint64_t v77 = v73 - a2->i64[0];
          uint64_t v78 = v77 >> 2;
          if (v77 >> 2 <= (unint64_t)(v76 + 1)) {
            uint64_t v78 = v76 + 1;
          }
          if ((unint64_t)v77 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v79 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v79 = v78;
          }
          unint64_t v138 = &a2[1].i64[1];
          if (v79) {
            BOOL v80 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&a2[1].i64[1], v79);
          }
          else {
            BOOL v80 = 0;
          }
          BOOL v81 = &v80[8 * v76];
          unsigned __int16 v82 = &v80[8 * v79];
          BOOL v137 = v82;
          *(void *)BOOL v81 = @"CTFontDescriptorLanguageAttribute";
          unint64_t v75 = v81 + 8;
          v136.i64[1] = (uint64_t)(v81 + 8);
          uint64_t v84 = a2->i64[0];
          unint64_t v83 = a2->u64[1];
          if (v83 == a2->i64[0])
          {
            int64x2_t v86 = vdupq_n_s64(v83);
          }
          else
          {
            do
            {
              uint64_t v85 = *(void *)(v83 - 8);
              v83 -= 8;
              *((void *)v81 - 1) = v85;
              v81 -= 8;
            }
            while (v83 != v84);
            int64x2_t v86 = *a2;
            unint64_t v75 = (void *)v136.i64[1];
            unsigned __int16 v82 = v137;
          }
          a2->i64[0] = (uint64_t)v81;
          a2->i64[1] = (uint64_t)v75;
          int64x2_t v136 = v86;
          BOOL v87 = (char *)a2[1].i64[0];
          a2[1].i64[0] = (uint64_t)v82;
          BOOL v137 = v87;
          id v135 = (id)v86.i64[0];
          std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v135);
        }
        else
        {
          *uint64_t v74 = @"CTFontDescriptorLanguageAttribute";
          unint64_t v75 = v74 + 1;
        }
        a2->i64[1] = (uint64_t)v75;
        unint64_t v89 = (void *)a3->i64[1];
        unint64_t v88 = a3[1].u64[0];
        if ((unint64_t)v89 >= v88)
        {
          uint64_t v91 = ((uint64_t)v89 - a3->i64[0]) >> 3;
          if ((unint64_t)(v91 + 1) >> 61) {
            goto LABEL_142;
          }
          uint64_t v92 = v88 - a3->i64[0];
          uint64_t v93 = v92 >> 2;
          if (v92 >> 2 <= (unint64_t)(v91 + 1)) {
            uint64_t v93 = v91 + 1;
          }
          if ((unint64_t)v92 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v94 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v94 = v93;
          }
          unint64_t v138 = &a3[1].i64[1];
          if (v94) {
            unsigned int v95 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&a3[1].i64[1], v94);
          }
          else {
            unsigned int v95 = 0;
          }
          uint64_t v96 = &v95[8 * v91];
          uint64_t v97 = &v95[8 * v94];
          BOOL v137 = v97;
          *(void *)uint64_t v96 = v72;
          __int16 v90 = v96 + 8;
          v136.i64[1] = (uint64_t)(v96 + 8);
          uint64_t v99 = a3->i64[0];
          unint64_t v98 = a3->u64[1];
          if (v98 == a3->i64[0])
          {
            int64x2_t v101 = vdupq_n_s64(v98);
          }
          else
          {
            do
            {
              uint64_t v100 = *(void *)(v98 - 8);
              v98 -= 8;
              *((void *)v96 - 1) = v100;
              v96 -= 8;
            }
            while (v98 != v99);
            int64x2_t v101 = *a3;
            __int16 v90 = (void *)v136.i64[1];
            uint64_t v97 = v137;
          }
          a3->i64[0] = (uint64_t)v96;
          a3->i64[1] = (uint64_t)v90;
          int64x2_t v136 = v101;
          BOOL v102 = (char *)a3[1].i64[0];
          a3[1].i64[0] = (uint64_t)v97;
          BOOL v137 = v102;
          id v135 = (id)v101.i64[0];
          std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v135);
        }
        else
        {
          *unint64_t v89 = v72;
          __int16 v90 = v89 + 1;
        }
        a3->i64[1] = (uint64_t)v90;
      }
    }
  }
  CFDictionaryRef result = (const __CFDictionary *)atomic_load_explicit(a1 + 75, memory_order_acquire);
  if (result)
  {
    CFDictionaryRef result = (const __CFDictionary *)CFDictionaryGetValue(result, @"ignoreLegibilityWeight");
    if (result)
    {
      CFArrayRef v105 = (void *)a2->i64[1];
      unint64_t v104 = a2[1].u64[0];
      if ((unint64_t)v105 >= v104)
      {
        uint64_t v107 = ((uint64_t)v105 - a2->i64[0]) >> 3;
        if ((unint64_t)(v107 + 1) >> 61) {
          goto LABEL_142;
        }
        uint64_t v108 = v104 - a2->i64[0];
        uint64_t v109 = v108 >> 2;
        if (v108 >> 2 <= (unint64_t)(v107 + 1)) {
          uint64_t v109 = v107 + 1;
        }
        if ((unint64_t)v108 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v110 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v110 = v109;
        }
        unint64_t v138 = &a2[1].i64[1];
        if (v110) {
          uint64_t v111 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&a2[1].i64[1], v110);
        }
        else {
          uint64_t v111 = 0;
        }
        uint64_t v112 = &v111[8 * v107];
        unsigned int v113 = &v111[8 * v110];
        BOOL v137 = v113;
        *(void *)uint64_t v112 = @"CTFontIgnoreLegibilityWeightAttribute";
        uint64_t v106 = v112 + 8;
        v136.i64[1] = (uint64_t)(v112 + 8);
        uint64_t v115 = a2->i64[0];
        unint64_t v114 = a2->u64[1];
        if (v114 == a2->i64[0])
        {
          int64x2_t v117 = vdupq_n_s64(v114);
        }
        else
        {
          do
          {
            uint64_t v116 = *(void *)(v114 - 8);
            v114 -= 8;
            *((void *)v112 - 1) = v116;
            v112 -= 8;
          }
          while (v114 != v115);
          int64x2_t v117 = *a2;
          uint64_t v106 = (void *)v136.i64[1];
          unsigned int v113 = v137;
        }
        a2->i64[0] = (uint64_t)v112;
        a2->i64[1] = (uint64_t)v106;
        int64x2_t v136 = v117;
        uint64_t v118 = (char *)a2[1].i64[0];
        a2[1].i64[0] = (uint64_t)v113;
        BOOL v137 = v118;
        id v135 = (id)v117.i64[0];
        CFDictionaryRef result = (const __CFDictionary *)std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v135);
      }
      else
      {
        *CFArrayRef v105 = @"CTFontIgnoreLegibilityWeightAttribute";
        uint64_t v106 = v105 + 1;
      }
      a2->i64[1] = (uint64_t)v106;
      uint64_t v119 = *MEMORY[0x1E4F1CFD0];
      id v121 = (void *)a3->i64[1];
      unint64_t v120 = a3[1].u64[0];
      if ((unint64_t)v121 < v120)
      {
        *id v121 = v119;
        uint64_t v122 = v121 + 1;
LABEL_140:
        a3->i64[1] = (uint64_t)v122;
        return result;
      }
      uint64_t v123 = ((uint64_t)v121 - a3->i64[0]) >> 3;
      if (!((unint64_t)(v123 + 1) >> 61))
      {
        uint64_t v124 = v120 - a3->i64[0];
        uint64_t v125 = v124 >> 2;
        if (v124 >> 2 <= (unint64_t)(v123 + 1)) {
          uint64_t v125 = v123 + 1;
        }
        if ((unint64_t)v124 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v126 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v126 = v125;
        }
        unint64_t v138 = &a3[1].i64[1];
        if (v126) {
          int v127 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&a3[1].i64[1], v126);
        }
        else {
          int v127 = 0;
        }
        uint64_t v128 = &v127[8 * v123];
        unsigned int v129 = &v127[8 * v126];
        BOOL v137 = v129;
        *(void *)uint64_t v128 = v119;
        uint64_t v122 = v128 + 8;
        v136.i64[1] = (uint64_t)(v128 + 8);
        uint64_t v131 = a3->i64[0];
        unint64_t v130 = a3->u64[1];
        if (v130 == a3->i64[0])
        {
          int64x2_t v133 = vdupq_n_s64(v130);
        }
        else
        {
          do
          {
            uint64_t v132 = *(void *)(v130 - 8);
            v130 -= 8;
            *((void *)v128 - 1) = v132;
            v128 -= 8;
          }
          while (v130 != v131);
          int64x2_t v133 = *a3;
          uint64_t v122 = (void *)v136.i64[1];
          unsigned int v129 = v137;
        }
        a3->i64[0] = (uint64_t)v128;
        a3->i64[1] = (uint64_t)v122;
        int64x2_t v136 = v133;
        unsigned __int16 v134 = (char *)a3[1].i64[0];
        a3[1].i64[0] = (uint64_t)v129;
        BOOL v137 = v134;
        id v135 = (id)v133.i64[0];
        CFDictionaryRef result = (const __CFDictionary *)std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v135);
        goto LABEL_140;
      }
LABEL_142:
      abort();
    }
  }
  return result;
}

void TSplicedFont::CopyAttribute(TSplicedFont *this@<X0>, uint64_t a2@<X1>, atomic_ullong *a3@<X8>)
{
  switch(a2)
  {
    case '0':
    case '9':
      uint64_t v4 = *(void *)(*((void *)this + 76) + 40);
      if ((*(_DWORD *)(v4 + 16) & 0x80000000) == 0) {
        TDescriptor::InitBaseFont(*(TDescriptor **)(*((void *)this + 76) + 40), 0, 0.0);
      }
      unint64_t v5 = *(void (**)(void))(*(void *)atomic_load_explicit((atomic_ullong *volatile)(v4 + 32), memory_order_acquire)
                            + 40);
      v5();
      return;
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
      goto LABEL_10;
    case ':':
      CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)this + 75, memory_order_acquire);
      if (!explicit) {
        goto LABEL_18;
      }
      unint64_t v9 = @"languageAwareLineHeightRatio";
      goto LABEL_17;
    case ';':
      CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)this + 75, memory_order_acquire);
      if (!explicit) {
        goto LABEL_18;
      }
      unint64_t v9 = @"lineSpacingOverride";
LABEL_17:
      CFDictionaryRef explicit = (const __CFDictionary *)CFDictionaryGetValue(explicit, v9);
LABEL_18:
      id v10 = explicit;
      *a3 = atomic_exchange((atomic_ullong *volatile)&v10, 0);

      return;
    case '<':
      CFDictionaryRef Value = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)this + 75, memory_order_acquire);
      if (!Value) {
        goto LABEL_24;
      }
      CFStringRef v7 = @"legibilityWeight";
      goto LABEL_23;
    case '=':
      CFDictionaryRef Value = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)this + 75, memory_order_acquire);
      if (!Value) {
        goto LABEL_24;
      }
      CFStringRef v7 = @"ignoreLegibilityWeight";
      goto LABEL_23;
    default:
      if (a2 == 43)
      {
        CFDictionaryRef Value = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)this + 75, memory_order_acquire);
        if (Value)
        {
          CFStringRef v7 = @"NSCTFontUIUsageAttribute";
LABEL_23:
          CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(Value, v7);
        }
LABEL_24:
        *a3 = (atomic_ullong)Value;
      }
      else
      {
LABEL_10:
        TBaseFont::CopyAttribute(this, a2, a3);
      }
      return;
  }
}

__CFString *TDescriptorSource::SubstituteFontNameForInvisibleFontName(const __CFString *this, const __CFString *a2)
{
  CFStringRef v2 = this;
  if (TDescriptorSource::ShouldSubstituteInvisibleFontName(this, a2))
  {
    CTFontLogSystemFontNameRequest();
    return @"TimesNewRomanPSMT";
  }
  return (__CFString *)v2;
}

CTFontRef CreateBestFontForCSS<anonymous namespace'::ValuesAreDescriptors>(id a1, CFArrayRef theArray, unsigned int a3, int a4, CGFloat a5)
{
  CFArrayRef v7 = theArray;
  v71[1] = *MEMORY[0x1E4F143B8];
  CFIndex Count = CFArrayGetCount(theArray);
  if (Count == 1)
  {
    CFURLRef ValueAtIndex = (const __CTFontDescriptor *)CFArrayGetValueAtIndex(v7, 0);
    return CTFontCreateWithFontDescriptor(ValueAtIndex, a5, 0);
  }
  CFIndex v12 = Count;
  *(void *)&long long v13 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v70[28] = v13;
  v70[29] = v13;
  v70[26] = v13;
  v70[27] = v13;
  v70[24] = v13;
  v70[25] = v13;
  v70[22] = v13;
  v70[23] = v13;
  v70[20] = v13;
  v70[21] = v13;
  v70[18] = v13;
  v70[19] = v13;
  v70[16] = v13;
  v70[17] = v13;
  v70[15] = v13;
  v70[14] = v13;
  v70[13] = v13;
  v70[12] = v13;
  v70[11] = v13;
  v70[10] = v13;
  v70[9] = v13;
  v70[8] = v13;
  v70[7] = v13;
  v70[6] = v13;
  v70[5] = v13;
  v70[4] = v13;
  v70[3] = v13;
  v70[2] = v13;
  v70[1] = v13;
  v70[0] = v13;
  __p = 0;
  int64x2_t v68 = 0;
  unint64_t v69 = 0;
  v71[0] = v70;
  if (Count < 1) {
    return 0;
  }
  CTFontDescriptorRef descriptor = 0;
  CFIndex v14 = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  unint64_t v61 = 0;
  unsigned int v62 = a3;
  double v15 = (double)a3;
  double v16 = -500.0;
  double v17 = 500.0;
  double v18 = INFINITY;
  CFArrayRef v63 = v7;
  do
  {
    unint64_t v19 = (const __CTFontDescriptor *)CFArrayGetValueAtIndex(v7, v14);
    double valuePtr = 0.0;
    CTFontRef v20 = CTFontCreateWithFontDescriptor(v19, a5, 0);
    id v66 = (id)CTFontCopyAttribute(v20, @"CTFontCSSWeightAttribute");
    CFNumberRef v21 = (const __CFNumber *)atomic_exchange((atomic_ullong *volatile)&v66, 0);

    if (v20)
    {
      char v22 = (*(uint64_t (**)(void))(**(void **)(*((void *)v20 + 5) + 400) + 160))(*(void *)(*((void *)v20 + 5) + 400));
      if (v21) {
        goto LABEL_9;
      }
    }
    else
    {
      char v22 = 0;
      if (v21)
      {
LABEL_9:
        CFNumberGetValue(v21, kCFNumberDoubleType, &valuePtr);
        goto LABEL_12;
      }
    }
    double valuePtr = 400.0;
LABEL_12:
    id v66 = (id)CTFontDescriptorCopyAttribute(v19, @"NSCTFontPostScriptNameAttribute");
    __int16 v23 = (void *)atomic_exchange((atomic_ullong *volatile)&v66, 0);

    id v24 = v23;
    if (v24 == a1)
    {

LABEL_18:
      if (v62 < 0x258 || (v22 & 2) != 0)
      {
        CTFontRef v55 = CTFontCreateWithFontDescriptor(v19, a5, 0);

        goto LABEL_101;
      }
      goto LABEL_22;
    }
    CFArrayRef v25 = v24;
    if (!a1 || !v24)
    {

      goto LABEL_22;
    }
    int v26 = CFEqual(v24, a1);

    if (v26) {
      goto LABEL_18;
    }
LABEL_22:
    double v27 = valuePtr;
    double v28 = valuePtr - v15;
    if ((v22 & 0x61) == a4)
    {
      if (fabs(v28) >= 0.001)
      {
        unint64_t v30 = v68;
        if ((unint64_t)v68 >= v69)
        {
          uint64_t v33 = (v68 - (unsigned char *)__p) >> 4;
          unint64_t v34 = v33 + 1;
          if ((unint64_t)(v33 + 1) >> 60) {
            abort();
          }
          uint64_t v35 = v69 - (void)__p;
          if ((uint64_t)(v69 - (void)__p) >> 3 > v34) {
            unint64_t v34 = v35 >> 3;
          }
          if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v36 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v36 = v34;
          }
          if (v36)
          {
            int64x2_t v37 = (char *)v71[0];
            if (v71[0] + 16 * v36 <= (unint64_t)v71)
            {
              v71[0] += 16 * v36;
            }
            else
            {
              if (v36 >> 60) {
                std::__throw_bad_array_new_length[abi:nn180100]();
              }
              int64x2_t v37 = (char *)operator new(16 * v36);
            }
          }
          else
          {
            int64x2_t v37 = 0;
          }
          uint64_t v38 = (const __CTFontDescriptor **)&v37[16 * v33];
          char *v38 = v19;
          *((double *)v38 + 1) = v27;
          unint64_t v40 = __p;
          unint64_t v39 = v68;
          int v41 = v38;
          if (v68 != __p)
          {
            do
            {
              *((_OWORD *)v41 - 1) = *(v39 - 1);
              v41 -= 2;
              --v39;
            }
            while (v39 != v40);
            unint64_t v39 = __p;
          }
          uint64_t v42 = &v37[16 * v36];
          id v31 = (char *)(v38 + 2);
          __p = v41;
          int64x2_t v68 = (char *)(v38 + 2);
          unint64_t v43 = v69;
          unint64_t v69 = (unint64_t)v42;
          if (v39)
          {
            if (v70 <= v39 && v71 > (void *)v39)
            {
              if (v43 == v71[0]) {
                v71[0] = v39;
              }
            }
            else
            {
              operator delete(v39);
            }
          }
          double v32 = v60;
        }
        else
        {
          *(void *)int64x2_t v68 = v19;
          *((double *)v30 + 1) = v27;
          id v31 = v30 + 16;
          double v32 = v60;
        }
        int64x2_t v68 = v31;
        BOOL v45 = v28 < 0.0;
        BOOL v46 = v28 > v16;
        BOOL v47 = !v45 || !v46;
        if (v45 && v46) {
          double v48 = v28;
        }
        else {
          double v48 = v16;
        }
        int v49 = v59;
        if (v47) {
          unint64_t v50 = v59;
        }
        else {
          unint64_t v50 = v19;
        }
        BOOL v51 = v28 > 0.0 && v28 < v17;
        if (v51) {
          double v17 = v28;
        }
        else {
          double v16 = v48;
        }
        if (v51) {
          double v32 = v19;
        }
        else {
          int v49 = v50;
        }
        uint64_t v59 = v49;
        uint64_t v60 = v32;
      }
      else
      {
        uint64_t v29 = v61;
        if (!v61) {
          uint64_t v29 = v19;
        }
        unint64_t v61 = v29;
      }
    }
    else if (__p == v68 && fabs(v28) < fabs(v18))
    {
      double v18 = valuePtr - v15;
      CTFontDescriptorRef descriptor = v19;
    }

    ++v14;
    CFArrayRef v7 = v63;
  }
  while (v14 != v12);
  uint64_t v52 = v61;
  if (!v61)
  {
    int64x2_t v53 = (char *)__p;
    if (__p == v68)
    {
      long long v56 = descriptor;
      if (!descriptor)
      {
        CTFontRef v55 = 0;
        goto LABEL_102;
      }
    }
    else
    {
      if (v62 != 400)
      {
        if (v62 == 500)
        {
          uint64_t v54 = (double *)__p;
          while (fabs(v54[1] + -400.0) >= 0.001)
          {
            v54 += 2;
            if (v54 == (double *)v68) {
              goto LABEL_92;
            }
          }
          goto LABEL_90;
        }
        goto LABEL_92;
      }
      uint64_t v54 = (double *)__p;
      while (fabs(v54[1] + -500.0) >= 0.001)
      {
        v54 += 2;
        if (v54 == (double *)v68) {
          goto LABEL_92;
        }
      }
LABEL_90:
      if (v54 != (double *)v68)
      {
        uint64_t v52 = *(const __CTFontDescriptor **)v54;
        goto LABEL_100;
      }
LABEL_92:
      if (v62 < 0x1F5)
      {
        uint64_t v57 = v59;
        long long v56 = v60;
        if (v59) {
          goto LABEL_97;
        }
        if (!v60)
        {
LABEL_107:
          uint64_t v52 = *(const __CTFontDescriptor **)__p;
          goto LABEL_100;
        }
      }
      else
      {
        uint64_t v57 = v59;
        long long v56 = v60;
        if (!v60)
        {
          if (!v59) {
            goto LABEL_107;
          }
LABEL_97:
          uint64_t v52 = v57;
          goto LABEL_100;
        }
      }
    }
    uint64_t v52 = v56;
  }
LABEL_100:
  CTFontRef v55 = CTFontCreateWithFontDescriptor(v52, a5, 0);
LABEL_101:
  int64x2_t v53 = (char *)__p;
LABEL_102:
  if (v53)
  {
    int64x2_t v68 = v53;
    if (v70 > (_OWORD *)v53 || v71 <= (void *)v53) {
      operator delete(v53);
    }
  }
  return v55;
}

CFTypeRef CTFontCopyAttribute(CTFontRef font, CFStringRef attribute)
{
  if (!font) {
    return 0;
  }
  uint64_t v3 = (TFont *)*((void *)font + 5);
  FontAttributeID = GetFontAttributeID(attribute);
  TFont::CopyAttribute(v3, attribute, (uint64_t)FontAttributeID, (atomic_ullong *)&v7);
  unint64_t v5 = (const void *)atomic_exchange((atomic_ullong *volatile)&v7, 0);

  return v5;
}

void TFont::CopyAttribute(TFont *this@<X0>, const __CFString *key@<X2>, uint64_t a3@<X1>, atomic_ullong *a4@<X8>)
{
  *a4 = 0;
  switch(a3)
  {
    case 8:
      double UnscaledTrackAmount = *((double *)this + 2);
      goto LABEL_22;
    case 9:
      CFDictionaryRef Value = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)this + 20, memory_order_acquire);
      CFDictionaryRef v15 = Value;
      if (Value) {
        CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(Value, @"NSCTFontOpticalSizeAttribute");
      }
      v23[0] = Value;

      if (atomic_load_explicit(a4, memory_order_acquire)) {
        return;
      }
      if (!atomic_load_explicit((atomic_ullong *volatile)this + 1, memory_order_acquire)
        || (*(_DWORD *)(*(void *)(atomic_load_explicit((atomic_ullong *volatile)this + 1, memory_order_acquire) + 40)
                      + 16) & 0x8000) == 0)
      {
        double UnscaledTrackAmount = *((double *)this + 3);
LABEL_22:
        v23[0] = *(id *)&UnscaledTrackAmount;
        CFAllocatorRef v16 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        CFNumberType v17 = kCFNumberDoubleType;
LABEL_38:
        CFNumberRef valuePtr = CFNumberCreate(v16, v17, v23);

        CFNumberRef v10 = valuePtr;
        goto LABEL_39;
      }
      CFNumberRef v21 = @"auto";
LABEL_35:
      v23[0] = v21;
      goto LABEL_36;
    case 10:
    case 14:
    case 17:
    case 20:
    case 21:
    case 49:
    case 50:
    case 52:
      goto LABEL_2;
    case 11:
      double UnscaledTrackAmount = TFont::GetUnscaledTrackAmount(this);
      goto LABEL_22;
    case 12:
    case 13:
      *(void *)&long long v11 = -1;
      *((void *)&v11 + 1) = -1;
      long long v24 = v11;
      long long v25 = v11;
      *(_OWORD *)__int16 v23 = v11;
      TFont::GetEffectiveMatrix(this, (uint64_t)v23);
      CFNumberRef v10 = (CFNumberRef)atomic_exchange(a4, (unint64_t)CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)v23, 48));
      goto LABEL_39;
    case 15:
    case 16:
    case 18:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 29:
    case 30:
    case 31:
    case 32:
    case 34:
    case 35:
    case 36:
    case 37:
    case 39:
    case 40:
    case 41:
    case 43:
    case 45:
    case 46:
    case 47:
    case 48:
    case 51:
    case 53:
    case 54:
      goto LABEL_12;
    case 19:
      (*(void (**)(id *__return_ptr))(**((void **)this + 50) + 136))(v23);
      goto LABEL_36;
    case 22:
      if (*(_DWORD *)this) {
        int v18 = 2;
      }
      else {
        int v18 = 1;
      }
      goto LABEL_34;
    case 28:
      uint64_t v19 = *((void *)this + 50);
      if ((*(_DWORD *)(v19 + 184) & 0x400) == 0) {
        TBaseFont::DetermineFontFlags(*((TBaseFont **)this + 50), 0x400u);
      }
      int v18 = (*(_DWORD *)(v19 + 180) >> 10) & 1;
      goto LABEL_34;
    case 33:
      uint64_t v20 = *((void *)this + 50);
      if (!v20) {
        return;
      }
      (*(void (**)(id *__return_ptr))(*(void *)v20 + 200))(v23);
      goto LABEL_36;
    case 38:
    case 42:
      if (!*((void *)this + 40)) {
        TFont::InitShapingGlyphs(this);
      }
      if (a3 == 42)
      {
        CFIndex v12 = (atomic_ullong *)((char *)this + 304);
      }
      else
      {
        if (a3 != 38) {
          return;
        }
        CFIndex v12 = (atomic_ullong *)((char *)this + 296);
      }
      id v22 = (id)atomic_load_explicit(v12, memory_order_acquire);
      TCFRef<__CTFont const*>::Retain(a4, v22);

      return;
    case 44:
      int v18 = ((*(_DWORD *)this >> 1) & 1) == 0;
LABEL_34:
      LODWORD(valuePtr) = v18;
      CFNumberRef v21 = (__CFString *)CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
      goto LABEL_35;
    case 55:
      v23[0] = (id)(((unint64_t)*(unsigned int *)this >> 6) & 7);
      CFAllocatorRef v16 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFNumberType v17 = kCFNumberLongType;
      goto LABEL_38;
    default:
      if (a3 == 65)
      {
LABEL_2:
        CFDictionaryRef v8 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)this + 20, memory_order_acquire);
        CFDictionaryRef v9 = v8;
        if (v8) {
          CFDictionaryRef v8 = (const __CFDictionary *)CFDictionaryGetValue(v8, key);
        }
        v23[0] = v8;

        CFNumberRef v10 = v9;
      }
      else
      {
LABEL_12:
        if (atomic_load_explicit((atomic_ullong *volatile)this + 1, memory_order_acquire)) {
          TDescriptor::CopyAttribute(*(atomic_ullong **)(atomic_load_explicit((atomic_ullong *volatile)this + 1, memory_order_acquire) + 40), key, v23);
        }
        else {
          v23[0] = 0;
        }
LABEL_36:

        CFNumberRef v10 = (CFNumberRef)v23[0];
      }
LABEL_39:

      return;
  }
}

double TextScaleRecipeForSize(CFDictionaryRef theDict, uint64_t a2, char a3, double a4)
{
  if (a3) {
    double v6 = *(double *)&a2 * 100.0;
  }
  else {
    double v6 = 0.0;
  }
  if (v6 == 0.0)
  {
    CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(theDict, @"auto");
    theArraCGFloat y = (CFArrayRef)0xAAAAAAAAAAAAAAAALL;
    CFArrayRef v26 = (CFArrayRef)0xAAAAAAAAAAAAAAAALL;
    double v27 = NAN;
    tuplesBracketingValue((const __CFArray *)&theArray, Value, a4, 0);
    CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(theArray, 1);
    double valuePtr = NAN;
    CFNumberGetValue(ValueAtIndex, kCFNumberDoubleType, &valuePtr);
    double v9 = valuePtr;
    CFNumberRef v10 = (const __CFNumber *)CFArrayGetValueAtIndex(v26, 1);
    double valuePtr = NAN;
    CFNumberGetValue(v10, kCFNumberDoubleType, &valuePtr);
    double v6 = std::__lerp[abi:nn180100]<double>(v9, valuePtr, v27);
  }
  CFArrayRef v11 = (const __CFArray *)CFDictionaryGetValue(theDict, @"recipes");
  theArraCGFloat y = (CFArrayRef)0xAAAAAAAAAAAAAAAALL;
  CFArrayRef v26 = (CFArrayRef)0xAAAAAAAAAAAAAAAALL;
  double v27 = NAN;
  tuplesBracketingValue((const __CFArray *)&theArray, v11, a4, 0);
  CFArrayRef v12 = theArray;
  double v13 = TextScaleRecipeForSize(__CFDictionary const*,double,std::optional<double>)::$_0::operator()(theArray, v6);
  double v15 = v14;
  double v17 = v16;
  if (v12 != v26)
  {
    double v18 = TextScaleRecipeForSize(__CFDictionary const*,double,std::optional<double>)::$_0::operator()(v26, v6);
    double v20 = v19;
    double v22 = v21;
    double v23 = v27;
    std::__lerp[abi:nn180100]<double>(v13, v18, v27);
    std::__lerp[abi:nn180100]<double>(v15, v20, v23);
    std::__lerp[abi:nn180100]<double>(v17, v22, v23);
  }
  return v6;
}

void tuplesBracketingValue(const __CFArray *a1, CFArrayRef theArray, double a3, CFIndex a4)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v40[14] = v7;
  v40[13] = v7;
  v40[12] = v7;
  v40[11] = v7;
  v40[10] = v7;
  v40[9] = v7;
  v40[8] = v7;
  v40[7] = v7;
  v40[6] = v7;
  v40[5] = v7;
  void v40[4] = v7;
  v40[3] = v7;
  v40[2] = v7;
  v40[1] = v7;
  v40[0] = v7;
  uint64_t v38 = 0;
  unint64_t v39 = 0;
  int64x2_t v37 = 0;
  int v41 = v40;
  CFIndex Count = CFArrayGetCount(theArray);
  if (Count <= a4)
  {
    double v15 = (double *)v38;
  }
  else
  {
    CFIndex v9 = Count;
    CFIndex v10 = a4;
    do
    {
      CFArrayRef ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(theArray, v10);
      CFNumberRef v12 = (const __CFNumber *)CFArrayGetValueAtIndex(ValueAtIndex, 0);
      valuePtr[0] = (void **)-1;
      CFNumberGetValue(v12, kCFNumberDoubleType, valuePtr);
      double v13 = valuePtr[0];
      double v14 = (void **)v38;
      if (v38 >= (void ***)v39)
      {
        double v16 = (void **)v37;
        uint64_t v17 = ((char *)v38 - (char *)v37) >> 3;
        unint64_t v18 = v17 + 1;
        if ((unint64_t)(v17 + 1) >> 61) {
          abort();
        }
        uint64_t v19 = (char *)v39 - (char *)v37;
        if (((char *)v39 - (char *)v37) >> 2 > v18) {
          unint64_t v18 = v19 >> 2;
        }
        if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v20 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v20 = v18;
        }
        valuePtr[4] = (void **)v40;
        if (v20)
        {
          double v21 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v40, v20);
          double v16 = (void **)v37;
          double v14 = (void **)v38;
        }
        else
        {
          double v21 = 0;
        }
        double v22 = (void ***)&v21[8 * v17];
        void *v22 = v13;
        if (v14 == v16)
        {
          long long v24 = (double *)&v21[8 * v17];
        }
        else
        {
          double v23 = v14;
          long long v24 = (double *)&v21[8 * v17];
          do
          {
            uint64_t v25 = (uint64_t)*--v23;
            *((void *)v24-- - 1) = v25;
          }
          while (v23 != v16);
        }
        double v15 = (double *)(v22 + 1);
        int64x2_t v37 = v24;
        uint64_t v38 = v22 + 1;
        CFArrayRef v26 = v39;
        unint64_t v39 = (void **)&v21[8 * v20];
        id valuePtr[2] = v14;
        valuePtr[3] = v26;
        valuePtr[0] = v16;
        valuePtr[1] = v16;
        std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)valuePtr);
      }
      else
      {
        char *v38 = valuePtr[0];
        double v15 = (double *)(v14 + 1);
      }
      uint64_t v38 = (void ***)v15;
      ++v10;
    }
    while (v10 != v9);
  }
  unsigned int v27 = IndexesBracketing<std::__wrap_iter<double *>,double>(v37, v15, a3);
  uint64_t v28 = HIWORD(v27);
  int v29 = (unsigned __int16)v27;
  unint64_t v30 = CFArrayGetValueAtIndex(theArray, (unsigned __int16)v27 + a4);
  id v31 = CFArrayGetValueAtIndex(theArray, v28 + a4);
  double v32 = v37[v29];
  double v33 = v37[v28];
  double v34 = 0.0;
  if (v32 != v33) {
    double v34 = (a3 - v32) / (v33 - v32);
  }
  *(void *)a1 = v30;
  *((void *)a1 + 1) = v31;
  *((double *)a1 + 2) = v34;
  valuePtr[0] = (void **)&v37;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](valuePtr);
}

uint64_t IndexesBracketing<std::__wrap_iter<double *>,double>(double *a1, double *a2, double a3)
{
  if ((char *)a2 - (char *)a1 >= 16 && *a1 <= a3)
  {
    if (*(a2 - 1) <= a3)
    {
      unsigned __int16 v3 = ((unint64_t)((char *)a2 - (char *)a1) >> 3) - 1;
    }
    else
    {
      double v6 = a1 + 1;
      if (a1 + 1 == a2)
      {
        unsigned __int16 v3 = 0;
        unsigned __int16 v4 = 1;
        return v3 | (v4 << 16);
      }
      unsigned __int16 v3 = 0;
      unsigned __int16 v4 = 1;
      while (1)
      {
        double v7 = *(v6 - 1);
        if (vabdd_f64(a3, v7) < 2.22044605e-16) {
          break;
        }
        if (vabdd_f64(a3, *v6) < 2.22044605e-16)
        {
          unsigned __int16 v3 = v4;
          return v3 | (v4 << 16);
        }
        if (v7 >= a3 || *v6 <= a3)
        {
          ++v3;
          ++v4;
          if (++v6 != a2) {
            continue;
          }
        }
        return v3 | (v4 << 16);
      }
    }
    unsigned __int16 v4 = v3;
  }
  else
  {
    unsigned __int16 v3 = 0;
    unsigned __int16 v4 = 0;
  }
  return v3 | (v4 << 16);
}

double TextScaleRecipeForSize(__CFDictionary const*,double,std::optional<double>)::$_0::operator()(CFArrayRef theArray, double a2)
{
  theArrayCGFloat a = (CFArrayRef)0xAAAAAAAAAAAAAAAALL;
  CFArrayRef v17 = (CFArrayRef)0xAAAAAAAAAAAAAAAALL;
  double v18 = NAN;
  tuplesBracketingValue((const __CFArray *)&theArraya, theArray, a2, 1);
  CFArrayRef v2 = theArraya;
  CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(theArraya, 1);
  double valuePtr = NAN;
  CFNumberGetValue(ValueAtIndex, kCFNumberDoubleType, &valuePtr);
  double v4 = valuePtr;
  CFArrayRef v5 = v17;
  CFNumberRef v6 = (const __CFNumber *)CFArrayGetValueAtIndex(v17, 1);
  double valuePtr = NAN;
  CFNumberGetValue(v6, kCFNumberDoubleType, &valuePtr);
  double v7 = v18;
  double v8 = std::__lerp[abi:nn180100]<double>(v4, valuePtr, v18);
  CFNumberRef v9 = (const __CFNumber *)CFArrayGetValueAtIndex(v2, 2);
  double valuePtr = NAN;
  CFNumberGetValue(v9, kCFNumberDoubleType, &valuePtr);
  double v10 = valuePtr;
  CFNumberRef v11 = (const __CFNumber *)CFArrayGetValueAtIndex(v5, 2);
  double valuePtr = NAN;
  CFNumberGetValue(v11, kCFNumberDoubleType, &valuePtr);
  std::__lerp[abi:nn180100]<double>(v10, valuePtr, v7);
  CFNumberRef v12 = (const __CFNumber *)CFArrayGetValueAtIndex(v2, 3);
  double valuePtr = NAN;
  CFNumberGetValue(v12, kCFNumberDoubleType, &valuePtr);
  double v13 = valuePtr;
  CFNumberRef v14 = (const __CFNumber *)CFArrayGetValueAtIndex(v5, 3);
  double valuePtr = NAN;
  CFNumberGetValue(v14, kCFNumberDoubleType, &valuePtr);
  std::__lerp[abi:nn180100]<double>(v13, valuePtr, v7);
  return v8;
}

CGRect CTFontGetBoundingRectsForGlyphs(CTFontRef font, CTFontOrientation orientation, const CGGlyph *glyphs, CGRect *boundingRects, CFIndex count)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (font && glyphs)
  {
    memset(v23, 170, sizeof(v23));
    memset(v22, 0, sizeof(v22));
    long long v24 = v23;
    if (!boundingRects)
    {
      std::vector<CGRect,TInlineBufferAllocator<CGRect,30ul>>::resize(v22, count);
      boundingRects = (CGRect *)v22[0];
    }
    double BoundingBoxesForGlyphs = TFont::GetBoundingBoxesForGlyphs(*((TFont **)font + 5), glyphs, boundingRects, count, orientation);
    double v12 = v11;
    double v14 = v13;
    double v16 = v15;
    double v21 = v22;
    std::vector<CGRect,TInlineBufferAllocator<CGRect,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v21);
  }
  else
  {
    double BoundingBoxesForGlyphs = *MEMORY[0x1E4F1DB20];
    double v12 = *(double *)(MEMORY[0x1E4F1DB20] + 8);
    double v14 = *(double *)(MEMORY[0x1E4F1DB20] + 16);
    double v16 = *(double *)(MEMORY[0x1E4F1DB20] + 24);
  }
  double v17 = BoundingBoxesForGlyphs;
  double v18 = v12;
  double v19 = v14;
  double v20 = v16;
  result.size.CGFloat height = v20;
  result.size.CGFloat width = v19;
  result.origin.CGFloat y = v18;
  result.origin.double x = v17;
  return result;
}

void std::vector<CGRect,TInlineBufferAllocator<CGRect,30ul>>::resize(char **a1, unint64_t a2)
{
  unsigned __int16 v3 = *a1;
  double v4 = a1[1];
  unint64_t v5 = (v4 - *a1) >> 5;
  if (a2 <= v5)
  {
    if (a2 >= v5) {
      return;
    }
    double v22 = &v3[32 * a2];
    goto LABEL_23;
  }
  unint64_t v6 = a2 - v5;
  double v7 = a1[2];
  if (a2 - v5 <= (v7 - v4) >> 5)
  {
    bzero(a1[1], 32 * v6);
    double v22 = &v4[32 * v6];
LABEL_23:
    a1[1] = v22;
    return;
  }
  if (a2 >> 59) {
    abort();
  }
  unint64_t v8 = (unint64_t)(a1 + 3);
  uint64_t v9 = v7 - v3;
  uint64_t v10 = v9 >> 4;
  if (v9 >> 4 <= a2) {
    uint64_t v10 = a2;
  }
  if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFE0) {
    unint64_t v11 = 0x7FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v11 = v10;
  }
  double v12 = TInlineBufferAllocator<DecorationOverride,30ul>::allocate((uint64_t)(a1 + 3), v11);
  double v13 = &v12[32 * v5];
  double v14 = &v12[32 * v11];
  bzero(v13, 32 * v6);
  double v15 = &v13[32 * v6];
  double v17 = *a1;
  double v16 = a1[1];
  if (v16 != *a1)
  {
    do
    {
      long long v18 = *((_OWORD *)v16 - 1);
      *((_OWORD *)v13 - 2) = *((_OWORD *)v16 - 2);
      *((_OWORD *)v13 - 1) = v18;
      v13 -= 32;
      v16 -= 32;
    }
    while (v16 != v17);
    double v16 = *a1;
  }
  *a1 = v13;
  a1[1] = v15;
  double v19 = a1[2];
  a1[2] = v14;
  if (v16)
  {
    double v20 = (char *)(a1 + 123);
    if (v8 <= (unint64_t)v16 && v20 > v16)
    {
      if (v19 == *(char **)v20) {
        *(void *)double v20 = v16;
      }
    }
    else
    {
      operator delete(v16);
    }
  }
}

uint64_t TCFBase<TRunDelegate>::GetTypeID(void)::{lambda(void *)#1}::__invoke()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB2CE790, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB2CE790))
  {
    qword_1EB2CE798 = 0;
    unk_1EB2CE7A0 = "CTRunDelegate";
    qword_1EB2CE7A8 = 0;
    unk_1EB2CE7B0 = 0;
    qword_1EB2CE7B8 = (uint64_t)TCFBase<TRunDelegate>::ClassDestruct;
    qword_1EB2CE7C0 = (uint64_t)TCFBase<TRunDelegate>::ClassEqual;
    qword_1EB2CE7C8 = (uint64_t)TCFBase<TRunDelegate>::ClassHash;
    unk_1EB2CE7D0 = 0;
    qword_1EB2CE7D8 = (uint64_t)TCFBase<TRunDelegate>::ClassDebug;
    unk_1EB2CE7E0 = 0;
    qword_1EB2CE7E8 = 0;
    unk_1EB2CE7F0 = 0;
    __cxa_guard_release(&qword_1EB2CE790);
  }
  uint64_t result = _CFRuntimeRegisterClass();
  qword_1EB2CE788 = result;
  return result;
}

unint64_t CTLineCreateJustifiedLineWithOptions(uint64_t a1, const TLine *a2, double a3, double a4)
{
  unint64_t v4 = 0;
  if (a1 && a4 >= 0.0)
  {
    double v5 = 1.0;
    if (a3 <= 1.0) {
      double v5 = a3;
    }
    BOOL v6 = a3 < 0.0;
    double v7 = 0.0;
    if (!v6) {
      double v7 = v5;
    }
    TJustEngine::CreateJustifiedLine(*(const TCharStream ***)(a1 + 40), a2, v7, a4, (unint64_t *)&v9);
    unint64_t v4 = ExternalizeLine((atomic_ullong *)&v9);
  }
  return v4;
}

void TJustEngine::CreateJustifiedLine(const TCharStream **this@<X0>, const TLine *a2@<X1>, double a3@<D0>, double a4@<D1>, unint64_t *a5@<X8>)
{
  char v62 = (char)a2;
  uint64_t v87 = *MEMORY[0x1E4F143B8];
  uint64_t v60 = *this;
  Hangingdouble Width = TLine::GetHangingWidth((TLine *)this);
  TLine::GetVisibleGlyphRangeAndWidth((TLine *)this, (uint64_t)&v79);
  id v10 = v79;
  unint64_t v11 = v80;
  double v12 = v81;
  if ((uint64_t)v80 < 1)
  {
    UnanchoredGlyphRange = 0;
    v63.locatioCFIndex n = 0;
  }
  else
  {
    v88.locatioCFIndex n = (CFIndex)v79;
    v88.uint64_t length = (CFIndex)v80;
    UnanchoredGlyphRange = (TJustEngine *)TLine::GetUnanchoredGlyphRange((TLine *)this, v88);
    v63.locatioCFIndex n = v13;
  }
  id v68 = (id)0xAAAAAAAAAAAAAAAALL;
  uint64_t v14 = TCFBase<TLine>::Allocate();
  if (v14)
  {
    uint64_t v15 = v14;
    *(void *)(v14 + 16) = 0;
    *(void *)(v14 + 24) = 0;
    *(_OWORD *)(v14 + 48) = 0u;
    uint64_t v16 = v14 + 48;
    *(void *)(v15 + 32) = 0;
    *(void *)(v15 + 40) = v16;
    *(_OWORD *)(v15 + 64) = 0u;
    *(void *)(v15 + 80) = 0;
    *(void *)(v15 + 112) = v15 + 88;
    *(void *)(v15 + 184) = 0;
    *(unsigned char *)(v15 + 232) = 0;
    *(_OWORD *)(v15 + 120) = 0u;
    *(_OWORD *)(v15 + 136) = 0u;
    *(void *)(v15 + 208) = 0;
    *(void *)(v15 + 216) = 0;
    *(unsigned char *)(v15 + 224) = 0;
    *(void *)(v15 + 240) = 0;
    *(void *)(v15 + 248) = 0;
    *(void *)(v15 + 256) = 0;
    TLine::operator=(v16, (uint64_t *)this);
    id v79 = (id)v15;
    id v68 = (id)atomic_exchange((atomic_ullong *volatile)&v79, 0);
  }
  else
  {
    id v68 = 0;
  }
  if (!atomic_load_explicit((atomic_ullong *volatile)&v68, memory_order_acquire))
  {
    *a5 = 0;
    goto LABEL_56;
  }
  double v17 = HangingWidth + a4;
  double v18 = (HangingWidth + a4 - v12) * a3;
  Table = GetTable();
  double v20 = 0.0002;
  if (Table)
  {
    double v21 = (double *)*((void *)Table + 8);
    if (v21) {
      double v20 = *v21;
    }
  }
  BOOL v22 = v18 >= 0.0 && v18 < v20;
  if (v22 || v63.location <= 0)
  {
    *a5 = atomic_exchange((atomic_ullong *volatile)&v68, 0);
    goto LABEL_56;
  }
  uint64_t v59 = (uint64_t)v10;
  CFIndex v23 = *(void *)(atomic_load_explicit((atomic_ullong *volatile)&v68, memory_order_acquire) + 40);
  TLine::DetachRuns((atomic_ullong *)v23);
  if ((*(_WORD *)(v23 + 154) & 2) != 0)
  {
    uint64_t v25 = *(void *)(v23 + 16);
    uint64_t v26 = *(void *)(v23 + 24) - v25;
    if (v26 >= 1)
    {
      uint64_t v27 = (unint64_t)v26 >> 3;
      if (v27 <= 1) {
        uint64_t v27 = 1;
      }
      do
      {
        uint64_t v28 = *(void *)(*(void *)(*(void *)v25 + 48) + 312);
        if (v28)
        {
          uint64_t v29 = *(void *)(v28 + 56);
          if (v29 != *(void *)(v28 + 64)) {
            *(void *)(v28 + 64) = v29;
          }
        }
        v25 += 8;
        --v27;
      }
      while (v27);
    }
  }
  CFIndex v58 = (CFIndex)v11;
  *(void *)&long long v30 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v30 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v85[14] = v30;
  v85[13] = v30;
  v85[12] = v30;
  v85[11] = v30;
  v85[10] = v30;
  v85[9] = v30;
  v85[8] = v30;
  v85[7] = v30;
  v85[6] = v30;
  v85[5] = v30;
  v85[4] = v30;
  v85[3] = v30;
  v85[2] = v30;
  v85[1] = v30;
  v85[0] = v30;
  memset(v84, 0, sizeof(v84));
  int64x2_t v86 = v85;
  double v66 = 0.0;
  uint64_t v67 = 0;
  id v31 = v60;
  do
  {
    uint64_t v32 = *(void *)(v23 + 16);
    uint64_t v33 = *(void *)(v23 + 24);
    v89.locatioCFIndex n = v63.location;
    v89.uint64_t length = v23;
    uint64_t v34 = TJustEngine::ReconciledRangeForLines((uint64_t)UnanchoredGlyphRange, v89, (const TLine *)this, v24);
    uint64_t v36 = v35;
    memset(v82, 170, sizeof(v82));
    id v79 = 0;
    BOOL v80 = 0;
    double v81 = 0.0;
    unint64_t v83 = v82;
    uint64_t v37 = v34 + v36;
    if (v34 + v36)
    {
      std::vector<JustLeftRightMaxima,TInlineBufferAllocator<JustLeftRightMaxima,30ul>>::__vallocate[abi:nn180100]((char **)&v79, v34 + v36);
      uint64_t v38 = (char *)v80;
      bzero(v80, 24 * ((24 * v37 - 24) / 0x18uLL) + 24);
      id v31 = v60;
      BOOL v80 = &v38[24 * v37];
    }
    memset(v77, 170, sizeof(v77));
    uint64_t v74 = 0;
    unint64_t v75 = 0;
    uint64_t v76 = 0;
    uint64_t v78 = v77;
    TJustEngine::GenerateMaximaList((TLine *)v23, v31, v34, v36, 0, v62, (uint64_t *)&v79, (uint64_t *)&v74, v18);
    std::vector<double,TInlineBufferAllocator<double,30ul>>::resize((uint64_t)v84, v34 + v36);
    TJustEngine::DistributeGap(v32, v33, v34, v36, 0, v62, (uint64_t)v79, v84[0], v18, &v66);
    if (v74 != v75)
    {
      uint64_t v65 = 0xAAAAAAAAAAAAAAAALL;
      *(void *)&long long v39 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v39 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v72[28] = v39;
      v72[29] = v39;
      v72[26] = v39;
      v72[27] = v39;
      v72[24] = v39;
      v72[25] = v39;
      v72[22] = v39;
      v72[23] = v39;
      v72[20] = v39;
      v72[21] = v39;
      v72[18] = v39;
      v72[19] = v39;
      v72[16] = v39;
      v72[17] = v39;
      v72[14] = v39;
      v72[15] = v39;
      v72[12] = v39;
      v72[13] = v39;
      v72[10] = v39;
      v72[11] = v39;
      v72[8] = v39;
      v72[9] = v39;
      v72[6] = v39;
      v72[7] = v39;
      v72[4] = v39;
      v72[5] = v39;
      v72[2] = v39;
      v72[3] = v39;
      v72[0] = v39;
      v72[1] = v39;
      unint64_t v69 = 0;
      CFDictionaryRef v70 = 0;
      uint64_t v71 = 0;
      unint64_t v73 = v72;
      char v40 = TPostcompEngine::DoActions(v32, v33, v34, v36, (uint64_t)&v74, v84[0], (unint64_t *)&v65, (char **)&v69);
      if (v65 >= 1) {
        *(void *)(v23 + 144) += v65;
      }
      if (v40)
      {
        TLine::ResetLine((TLine *)v23, v31);
        TLine::GetVisibleGlyphRangeAndWidth((TLine *)v23, (uint64_t)&v63.length);
        double v18 = (v17 - v64) * a3;
        double v66 = 0.0;
        uint64_t v67 = 0;
        v63.uint64_t length = (CFIndex)&v69;
        std::vector<CGPoint,TInlineBufferAllocator<CGPoint,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v63.length);
        char v41 = 1;
        goto LABEL_37;
      }
      if (v69 != v70)
      {
        CFIndex v42 = TAATPostcompEngine::ApplyKashidas(v32, v33, &v69, v84[0]);
        uint64_t v65 = v42;
        if (v42 >= 1)
        {
          *(void *)(v23 + 144) += v42;
          ApplyArabicLowConnections<std::__wrap_iter<CTRun **>>(v32, v33);
        }
      }
      v63.uint64_t length = (CFIndex)&v69;
      std::vector<CGPoint,TInlineBufferAllocator<CGPoint,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v63.length);
    }
    char v41 = 0;
LABEL_37:
    unint64_t v69 = (uint64_t *)&v74;
    std::vector<std::tuple<long,std::unique_ptr<std::vector<unsigned short>>,TCFRef<__CFData const*>>,TInlineBufferAllocator<std::tuple<long,std::unique_ptr<std::vector<unsigned short>>,TCFRef<__CFData const*>>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v69);
    uint64_t v74 = &v79;
    std::vector<JustLeftRightMaxima,TInlineBufferAllocator<JustLeftRightMaxima,30ul>>::__destroy_vector::operator()[abi:nn180100](&v74);
  }
  while ((v41 & 1) != 0);
  v90.locatioCFIndex n = v58;
  v90.uint64_t length = v23;
  CFIndex v44 = TJustEngine::ReconciledRangeForLines(v59, v90, (const TLine *)this, v24);
  uint64_t v46 = v45;
  if (v44 >= 1)
  {
    v43.locatioCFIndex n = v44;
    TJustEngine::ZeroRange(v23, 0, v43);
  }
  v43.locatioCFIndex n = *(void *)(v23 + 144) - (v44 + v46);
  if (v43.location >= 1) {
    TJustEngine::ZeroRange(v23, (TLine *)(v44 + v46), v43);
  }
  TLine::SyncWithRuns((TLine *)v23);
  if ((v62 & 2) != 0 || v18 >= 0.0)
  {
LABEL_54:
    unint64_t v55 = atomic_exchange((atomic_ullong *volatile)&v68, 0);
  }
  else
  {
    if (v17 >= v12 + v66 - v20)
    {
      if (*(double *)(v23 + 104) - v17 > 0.0)
      {
        BOOL v47 = *(void **)(*(void *)(*(void *)(v23 + 24) - 8) + 48);
        uint64_t v48 = v47[26];
        uint64_t v49 = v48 - 1;
        if (v48 >= 1)
        {
          unint64_t v50 = (TStorageRange *)(v47 + 24);
          uint64_t v51 = v47[27];
          uint64_t v52 = *(void *)(v51 + 32);
          if (v52 || (uint64_t v56 = *(void *)(v51 + 24)) == 0)
          {
            uint64_t v53 = v52 + 16 * v47[25] + 16 * v49;
            uint64_t v54 = *(void *)(v53 + 8);
          }
          else
          {
            uint64_t v53 = v56 + 8 * v47[25] + 8 * v49;
            uint64_t v54 = 0;
          }
          double v57 = *(double *)v53 - v20;
          TStorageRange::SetAdvance(v50, v49, *(CGSize *)(&v54 - 1));
          TLine::SyncWithRuns((TLine *)v23);
        }
      }
      goto LABEL_54;
    }
    unint64_t v55 = 0;
  }
  *a5 = v55;
  id v79 = v84;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v79);
LABEL_56:
}

uint64_t TJustEngine::ReconciledRangeForLines(uint64_t this, CFRange a2, const TLine *a3, const TLine *a4)
{
  uint64_t v4 = *((void *)a3 + 18);
  uint64_t v5 = this + a2.location;
  CFIndex v6 = *(void *)(a2.length + 144);
  CFIndex v7 = a2.location - v4 + v6;
  if (v5 < v4)
  {
    uint64_t v8 = *((void *)a3 + 2);
    uint64_t v9 = *((void *)a3 + 3);
    uint64_t v10 = *(void *)(a2.length + 16);
    uint64_t v11 = *(void *)(a2.length + 24);
    do
    {
      if (v8 == v9)
      {
        unint64_t v16 = 0xAAAAAAAAAAAAAAAALL;
        uint64_t v13 = v8;
      }
      else
      {
        uint64_t v12 = 0;
        uint64_t v13 = v8;
        uint64_t v14 = v8;
        while (1)
        {
          uint64_t v15 = *(void *)(*(void *)(*(void *)v14 + 40) + 208) + v12;
          if (v15 > v5) {
            break;
          }
          v14 += 8;
          v13 += 8;
          uint64_t v12 = v15;
          if (v14 == v9)
          {
            unint64_t v16 = 0xAAAAAAAAAAAAAAAALL;
            uint64_t v13 = v9;
            goto LABEL_10;
          }
        }
        unint64_t v16 = v5 - v12;
      }
LABEL_10:
      uint64_t v17 = (v13 - v8) >> 3;
      if (v17 >= (v9 - v8) >> 3) {
        break;
      }
      uint64_t v18 = *(void *)(*(void *)(v8 + 8 * v17) + 40);
      if ((*(_DWORD *)(*(void *)(*(void *)(v18 + 216) + 40) + 4 * *(void *)(v18 + 200) + 4 * v16) & 0x20) == 0
        || v7 + this >= v6)
      {
        break;
      }
      if (v10 == v11)
      {
        uint64_t v20 = v10;
      }
      else
      {
        uint64_t v19 = 0;
        uint64_t v20 = v10;
        uint64_t v21 = v10;
        while (1)
        {
          uint64_t v22 = *(void *)(*(void *)(*(void *)v21 + 40) + 208) + v19;
          if (v22 > v5) {
            break;
          }
          v21 += 8;
          v20 += 8;
          uint64_t v19 = v22;
          if (v21 == v11)
          {
            uint64_t v20 = v11;
            goto LABEL_20;
          }
        }
        unint64_t v16 = v5 - v19;
      }
LABEL_20:
      uint64_t v23 = (v20 - v10) >> 3;
      if (v23 >= (v11 - v10) >> 3) {
        break;
      }
      uint64_t v24 = *(void *)(*(void *)(v10 + 8 * v23) + 40);
      if ((*(_DWORD *)(*(void *)(*(void *)(v24 + 216) + 40) + 4 * *(void *)(v24 + 200) + 4 * v16) & 0x20) != 0) {
        break;
      }
      ++v7;
      ++v5;
    }
    while (v5 < v4);
  }
  return this;
}

void std::vector<double,TInlineBufferAllocator<double,30ul>>::__append(char **a1, unint64_t a2)
{
  uint64_t v5 = a1[1];
  uint64_t v4 = a1[2];
  if (a2 <= (v4 - v5) >> 3)
  {
    if (a2)
    {
      bzero(a1[1], 8 * a2);
      v5 += 8 * a2;
    }
    a1[1] = v5;
  }
  else
  {
    uint64_t v6 = (uint64_t)(a1 + 3);
    CFIndex v7 = *a1;
    uint64_t v8 = v5 - *a1;
    unint64_t v9 = a2 + (v8 >> 3);
    if (v9 >> 61) {
      abort();
    }
    uint64_t v10 = v8 >> 3;
    uint64_t v11 = v4 - v7;
    if (v11 >> 2 > v9) {
      unint64_t v9 = v11 >> 2;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v9;
    }
    v20[4] = a1 + 3;
    if (v12)
    {
      uint64_t v13 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate(v6, v12);
      CFIndex v7 = *a1;
      uint64_t v5 = a1[1];
    }
    else
    {
      uint64_t v13 = 0;
    }
    uint64_t v14 = &v13[8 * v10];
    uint64_t v15 = &v13[8 * v12];
    bzero(v14, 8 * a2);
    unint64_t v16 = &v14[8 * a2];
    if (v5 != v7)
    {
      uint64_t v17 = v5;
      do
      {
        uint64_t v18 = *((void *)v17 - 1);
        v17 -= 8;
        *((void *)v14 - 1) = v18;
        v14 -= 8;
      }
      while (v17 != v7);
    }
    *a1 = v14;
    a1[1] = v16;
    uint64_t v19 = a1[2];
    a1[2] = v15;
    v20[2] = v5;
    double v20[3] = v19;
    v20[0] = v7;
    v20[1] = v7;
    std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)v20);
  }
}

void std::vector<double,TInlineBufferAllocator<double,30ul>>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 8 * a2;
    }
  }
  else
  {
    std::vector<double,TInlineBufferAllocator<double,30ul>>::__append((char **)a1, a2 - v2);
  }
}

void std::vector<std::tuple<long,std::unique_ptr<std::vector<unsigned short>>,TCFRef<__CFData const*>>,TInlineBufferAllocator<std::tuple<long,std::unique_ptr<std::vector<unsigned short>>,TCFRef<__CFData const*>>,30ul>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = (void **)**a1;
    uint64_t v6 = v1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 24;
        std::__destroy_at[abi:nn180100]<std::tuple<long,std::unique_ptr<std::vector<unsigned short>>,TCFRef<__CFData const*>>,0>(v4);
      }
      while ((void *)v4 != v2);
      uint64_t v6 = *a1;
      uint64_t v5 = (void **)**a1;
    }
    v1[1] = v2;
    CFIndex v7 = v6 + 93;
    if (v6 + 3 <= v5 && v7 > v5)
    {
      if (v6[2] == v6[93]) {
        *CFIndex v7 = v5;
      }
    }
    else
    {
      operator delete(v5);
    }
  }
}

void std::vector<JustLeftRightMaxima,TInlineBufferAllocator<JustLeftRightMaxima,30ul>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = (void **)**a1;
  if (v2)
  {
    v1[1] = v2;
    unsigned __int16 v3 = v1 + 93;
    if (v1 + 3 <= v2)
    {
      BOOL v4 = v3 >= v2;
      BOOL v5 = v3 == v2;
    }
    else
    {
      BOOL v4 = 0;
      BOOL v5 = 0;
    }
    if (!v5 && v4)
    {
      if (v1[2] == v1[93]) {
        *unsigned __int16 v3 = v2;
      }
    }
    else
    {
      operator delete(v2);
    }
  }
}

double TLine::GetVisibleGlyphRangeAndWidth@<D0>(TLine *this@<X0>, uint64_t a2@<X8>)
{
  if ((*((_WORD *)this + 76) & 8) != 0)
  {
    LeftWhitespaceGlyphCountAnddouble Width = TLine::GetLeftWhitespaceGlyphCountAndWidth(this);
    uint64_t v6 = LeftWhitespaceGlyphCountAndWidth;
  }
  else
  {
    LeftWhitespaceGlyphCountAnddouble Width = TLine::GetRightWhitespaceGlyphCountAndWidth(this);
    uint64_t v6 = 0;
  }
  uint64_t v7 = *((void *)this + 18) - LeftWhitespaceGlyphCountAndWidth;
  double result = *((double *)this + 13) - v5;
  *(void *)a2 = v6;
  *(void *)(a2 + 8) = v7;
  *(double *)(a2 + 16) = result;
  return result;
}

CFIndex TLine::GetUnanchoredGlyphRange(TLine *this, CFRange a2)
{
  __int16 v2 = *((_WORD *)this + 76);
  if ((v2 & 2) != 0)
  {
    locatioCFIndex n = a2.length + a2.location - 1;
    uint64_t v4 = *((void *)this + 2);
    uint64_t v5 = *((void *)this + 3);
    if ((v2 & 8) != 0)
    {
      uint64_t v7 = (v5 - v4) >> 3;
      int v6 = -1;
      CFIndex v8 = a2.length + a2.location - 1;
      locatioCFIndex n = a2.location;
    }
    else
    {
      int v6 = 1;
      uint64_t v7 = -1;
      CFIndex v8 = a2.location;
    }
    CFIndex v34 = a2.location;
    CFIndex v32 = v8;
    if (v4 == v5)
    {
LABEL_9:
      uint64_t v12 = 0;
      uint64_t v10 = *((void *)this + 3);
    }
    else
    {
      CFIndex v9 = 0;
      uint64_t v10 = *((void *)this + 2);
      while (1)
      {
        CFIndex v11 = *(void *)(*(void *)(*(void *)v10 + 40) + 208) + v9;
        if (v11 > location) {
          break;
        }
        v10 += 8;
        CFIndex v9 = v11;
        if (v10 == v5) {
          goto LABEL_9;
        }
      }
      uint64_t v12 = location - v9;
    }
    uint64_t v13 = (v10 - v4) >> 3;
    uint64_t v14 = *(void *)(*(void *)v10 + 40);
    int v15 = -v6;
    uint64_t v16 = v6;
    uint64_t v17 = v4 - 8 * v6;
    uint64_t v33 = v7;
    uint64_t v18 = -(v7 + v6);
    while (1)
    {
      if (*(unsigned char *)(v14 + 225))
      {
        uint64_t TabGlyph = TStorageRange::FindTabGlyph((TStorageRange *)(v14 + 192), v12, v15, 0);
        if ((TabGlyph & 0x8000000000000000) == 0) {
          break;
        }
      }
      if (!(v18 + v13))
      {
        a2.locatioCFIndex n = v34;
        return a2.location;
      }
      uint64_t v12 = 0;
      uint64_t v20 = v13 - v16;
      uint64_t v14 = *(void *)(*(void *)(v17 + 8 * v13) + 40);
      v13 -= v16;
      if ((v2 & 8) == 0)
      {
        uint64_t v12 = *(void *)(v14 + 208) - 1;
        uint64_t v13 = v20;
      }
    }
    a2.locatioCFIndex n = v34;
    if (v13 != v33)
    {
      if (v4 == v5)
      {
LABEL_23:
        uint64_t v22 = v5;
      }
      else
      {
        CFIndex v21 = 0;
        uint64_t v22 = v4;
        while (1)
        {
          CFIndex v23 = *(void *)(*(void *)(*(void *)v22 + 40) + 208) + v21;
          if (v23 > v32) {
            break;
          }
          v22 += 8;
          CFIndex v21 = v23;
          if (v22 == v5) {
            goto LABEL_23;
          }
        }
        uint64_t v12 = v32 - v21;
      }
      uint64_t v24 = v22 - v4;
      if (v13 == v24 >> 3)
      {
        uint64_t v26 = 0;
      }
      else
      {
        uint64_t v25 = v24 >> 3;
        if ((v2 & 8) != 0) {
          uint64_t v26 = v12 + 1;
        }
        else {
          uint64_t v26 = *(void *)(*(void *)(*(void *)(v4 + 8 * v25) + 40) + 208) - v12;
        }
        for (uint64_t i = v25 + v16; v13 != i; i += v16)
        {
          if (i < 0) {
            break;
          }
          if ((v5 - v4) >> 3 <= i) {
            break;
          }
          v26 += *(void *)(*(void *)(*(void *)(v4 + 8 * i) + 40) + 208);
        }
      }
      if ((v2 & 8) != 0) {
        uint64_t v28 = *(void *)(v14 + 208) - TabGlyph;
      }
      else {
        uint64_t v28 = TabGlyph + 1;
      }
      uint64_t v29 = v28 + v26;
      if ((v2 & 8) != 0) {
        uint64_t v30 = 0;
      }
      else {
        uint64_t v30 = v29;
      }
      a2.locatioCFIndex n = v30 + v34;
    }
  }
  return a2.location;
}

double TLine::GetHangingWidth(TLine *this)
{
  TLine::GetLeftHangersGlyphCountAndWidth(this, 0);
  double v3 = v2;
  TLine::GetRightHangersGlyphCountAndWidth(this, 0);
  double v5 = v4;
  if ((*((_WORD *)this + 76) & 8) != 0) {
    TLine::GetLeftWhitespaceGlyphCountAndWidth(this);
  }
  else {
    TLine::GetRightWhitespaceGlyphCountAndWidth(this);
  }
  return v3 + v5 - v6;
}

uint64_t TLine::GetRightWhitespaceGlyphCountAndWidth(TLine *this)
{
  uint64_t v1 = 0;
  uint64_t v2 = *((void *)this + 2);
  uint64_t v3 = (*((void *)this + 3) - v2) >> 3;
  uint64_t v4 = v2 - 8;
  double v5 = 0.0;
  do
  {
    uint64_t v6 = v3 - 1;
    if (v3 < 1) {
      break;
    }
    uint64_t v7 = *(TRun **)(*(void *)(v4 + 8 * v3) + 40);
    uint64_t RightWhitespaceGlyphCountAndWidth = TRun::GetRightWhitespaceGlyphCountAndWidth(v7);
    v1 += RightWhitespaceGlyphCountAndWidth;
    double v5 = v5 + v9;
    uint64_t v3 = v6;
  }
  while (RightWhitespaceGlyphCountAndWidth >= *((void *)v7 + 26));
  return v1;
}

void TJustEngine::GenerateMaximaList(TLine *a1, void *a2, uint64_t a3, uint64_t a4, int a5, char a6, uint64_t *a7, uint64_t *a8, double a9)
{
  uint64_t v11 = (uint64_t)a1;
  uint64_t v12 = *((void *)a1 + 2);
  uint64_t v13 = *((void *)a1 + 3);
  if (v12 == v13)
  {
    uint64_t v14 = 0;
    uint64_t v15 = *((void *)a1 + 2);
  }
  else
  {
    uint64_t v14 = 0;
    uint64_t v15 = *((void *)a1 + 2);
    while (1)
    {
      uint64_t v16 = *(void *)(*(void *)(*(void *)v15 + 40) + 208);
      if (a3 < v16) {
        break;
      }
      v14 += v16;
      v15 += 8;
      a3 -= v16;
      if (v15 == v13) {
        return;
      }
    }
  }
  BOOL v96 = 0;
  if (v15 != v13)
  {
    uint64_t v75 = v12;
    char v80 = 0;
    BOOL v83 = 0;
    uint64_t v74 = (uint64_t)(a8 + 3);
    uint64_t v77 = v13;
    while (1)
    {
      uint64_t v17 = *(atomic_ullong **)(*(void *)v15 + 40);
      uint64_t v18 = a3 & ~(a3 >> 63);
      uint64_t v19 = a3 + a4;
      if (a3 + a4 >= v17[26]) {
        uint64_t v19 = v17[26];
      }
      BOOL v20 = v19 < v18;
      uint64_t v21 = v19 - v18;
      if (v20) {
        uint64_t v22 = 0;
      }
      else {
        uint64_t v22 = v21;
      }
      if (v20) {
        uint64_t v23 = 0;
      }
      else {
        uint64_t v23 = a3 & ~(a3 >> 63);
      }
      if (v22 < 1)
      {
LABEL_71:
        if (v80)
        {
          uint64_t v71 = *a7;
          uint64_t v72 = a7[1];
          if (*a7 != v72)
          {
            uint64_t v73 = *a7;
            while (!*(unsigned char *)(v73 + 18))
            {
              v73 += 24;
              if (v73 == v72) {
                goto LABEL_78;
              }
            }
            if (v73 != v72) {
              return;
            }
            do
            {
LABEL_78:
              if (!*(_WORD *)(v71 + 16)) {
                *(unsigned char *)(v71 + 18) = 1;
              }
              v71 += 24;
            }
            while (v71 != v72);
          }
        }
        return;
      }
      atomic_ullong v88 = v17[26];
      unint64_t v95 = 0xAAAAAAAAAAAAAAAALL;
      *(void *)&long long v24 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v24 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v93[2] = v24;
      long long v94 = v24;
      v93[0] = v24;
      v93[1] = v24;
      TAATJustEngine::TAATJustEngine((TAATJustEngine *)v93, v17);
      uint64_t v84 = v17;
      uint64_t v85 = v23;
      if (TAATJustEngine::GenerateMaximas(v93, v11, (uint64_t)a2, v23, v22, a7, v14, a9 > 0.0, a5))
      {
        if ((void)v94)
        {
          uint64_t v25 = a8;
          uint64_t v26 = (v15 - v75) >> 3;
          TAATJustEngine::PostcompTable((atomic_ullong *)v93, v97);
          uint64_t v27 = (uint64_t *)a8[1];
          unint64_t v28 = a8[2];
          if ((unint64_t)v27 >= v28)
          {
            unint64_t v42 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v27 - *a8) >> 3);
            unint64_t v43 = v42 + 1;
            if (v42 + 1 > 0xAAAAAAAAAAAAAAALL) {
              goto LABEL_82;
            }
            unint64_t v44 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v28 - *a8) >> 3);
            if (2 * v44 > v43) {
              unint64_t v43 = 2 * v44;
            }
            if (v44 >= 0x555555555555555) {
              unint64_t v45 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              unint64_t v45 = v43;
            }
            *(void *)&v90[2] = v74;
            atomic_ullong v32 = v88;
            if (v45) {
              uint64_t v46 = TInlineBufferAllocator<std::pair<double,CFRange>,30ul>::allocate(v74, v45);
            }
            else {
              uint64_t v46 = 0;
            }
            BOOL v47 = (uint64_t *)&v46[24 * v42];
            *(void *)&v90[0] = v46;
            *((void *)&v90[0] + 1) = v47;
            *(void *)&v90[1] = v47;
            *((void *)&v90[1] + 1) = &v46[24 * v45];
            uint64_t *v47 = v26;
            unint64_t v48 = v95;
            unint64_t v95 = 0;
            v47[1] = v48;
            v47[2] = atomic_exchange((atomic_ullong *volatile)v97, 0);
            *(void *)&v90[1] += 24;
            uint64_t v25 = a8;
            std::vector<std::tuple<long,std::unique_ptr<std::vector<unsigned short>>,TCFRef<__CFData const*>>,TInlineBufferAllocator<std::tuple<long,std::unique_ptr<std::vector<unsigned short>>,TCFRef<__CFData const*>>,30ul>>::__swap_out_circular_buffer(a8, v90);
            id v31 = (void *)a8[1];
            std::__split_buffer<std::tuple<long,std::unique_ptr<std::vector<unsigned short>>,TCFRef<__CFData const*>>,TInlineBufferAllocator<std::tuple<long,std::unique_ptr<std::vector<unsigned short>>,TCFRef<__CFData const*>>,30ul> &>::~__split_buffer((uint64_t)v90);
            uint64_t v11 = (uint64_t)a1;
          }
          else
          {
            *uint64_t v27 = v26;
            unint64_t v29 = v95;
            unint64_t v95 = 0;
            unint64_t v30 = atomic_exchange((atomic_ullong *volatile)v97, 0);
            v27[1] = v29;
            v27[2] = v30;
            id v31 = v27 + 3;
            uint64_t v11 = (uint64_t)a1;
            atomic_ullong v32 = v88;
          }
          v25[1] = (uint64_t)v31;

          BOOL v83 = 0;
          uint64_t v34 = v77;
        }
        else
        {
          BOOL v83 = 0;
          uint64_t v11 = (uint64_t)a1;
          uint64_t v34 = v77;
          atomic_ullong v32 = v88;
        }
        goto LABEL_59;
      }
      v92[0] = &unk_1ED05E840;
      v92[1] = v17;
      TGenericJustEngine::GenerateMaximas((uint64_t)v92, a1, a2, v23, v22, a7, v14, a9 > 0.0, a5, &v96);
      if ((void)v94)
      {
        BOOL Maximas = 0;
        uint64_t v11 = (uint64_t)a1;
        uint64_t v34 = v77;
        atomic_ullong v32 = v88;
      }
      else
      {
        unint64_t v91 = 0xAAAAAAAAFFFFFFFFLL;
        memset(v90, 170, sizeof(v90));
        TArabicJustEngine::TArabicJustEngine((TArabicJustEngine *)v90, v17);
        BOOL Maximas = TArabicJustEngine::GenerateMaximas((uint64_t)v90, (uint64_t)a1, (uint64_t)a2);
        atomic_ullong v32 = v88;
        if (Maximas)
        {
          uint64_t v35 = (v15 - v75) >> 3;
          TArabicJustEngine::PostcompTable((TArabicJustEngine *)v90, (unint64_t *)&v89);
          uint64_t v36 = a8;
          uint64_t v37 = (uint64_t *)a8[1];
          unint64_t v38 = a8[2];
          if ((unint64_t)v37 >= v38)
          {
            unint64_t v49 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v37 - *a8) >> 3);
            unint64_t v50 = v49 + 1;
            if (v49 + 1 > 0xAAAAAAAAAAAAAAALL) {
LABEL_82:
            }
              abort();
            unint64_t v51 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v38 - *a8) >> 3);
            if (2 * v51 > v50) {
              unint64_t v50 = 2 * v51;
            }
            if (v51 >= 0x555555555555555) {
              unint64_t v52 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              unint64_t v52 = v50;
            }
            uint64_t v100 = v74;
            if (v52) {
              uint64_t v53 = TInlineBufferAllocator<std::pair<double,CFRange>,30ul>::allocate(v74, v52);
            }
            else {
              uint64_t v53 = 0;
            }
            uint64_t v54 = (uint64_t *)&v53[24 * v49];
            v97[0] = v53;
            v97[1] = v54;
            unint64_t v98 = v54;
            uint64_t v99 = &v53[24 * v52];
            *uint64_t v54 = v35;
            uint64_t v55 = *((void *)&v90[1] + 1);
            *((void *)&v90[1] + 1) = 0;
            v54[1] = v55;
            v54[2] = atomic_exchange((atomic_ullong *volatile)&v89, 0);
            v98 += 3;
            uint64_t v36 = a8;
            std::vector<std::tuple<long,std::unique_ptr<std::vector<unsigned short>>,TCFRef<__CFData const*>>,TInlineBufferAllocator<std::tuple<long,std::unique_ptr<std::vector<unsigned short>>,TCFRef<__CFData const*>>,30ul>>::__swap_out_circular_buffer(a8, v97);
            char v41 = (void *)a8[1];
            std::__split_buffer<std::tuple<long,std::unique_ptr<std::vector<unsigned short>>,TCFRef<__CFData const*>>,TInlineBufferAllocator<std::tuple<long,std::unique_ptr<std::vector<unsigned short>>,TCFRef<__CFData const*>>,30ul> &>::~__split_buffer((uint64_t)v97);
          }
          else
          {
            uint64_t *v37 = v35;
            uint64_t v39 = *((void *)&v90[1] + 1);
            *((void *)&v90[1] + 1) = 0;
            unint64_t v40 = atomic_exchange((atomic_ullong *volatile)&v89, 0);
            v37[1] = v39;
            v37[2] = v40;
            char v41 = v37 + 3;
          }
          v36[1] = (uint64_t)v41;
        }
        TArabicJustEngine::~TArabicJustEngine((TArabicJustEngine *)v90);
        uint64_t v11 = (uint64_t)a1;
        uint64_t v34 = v77;
        if (Maximas) {
          goto LABEL_58;
        }
      }
      if (v83)
      {
        if (v85 + v22)
        {
          uint64_t v56 = 24 * (v85 + v22);
          double v57 = (_WORD *)(*a7 + 24 * v14 + 16);
          do
          {
            unsigned int v58 = (unsigned __int16)*v57;
            if (v58 <= 2) {
              _WORD *v57 = v58 + 1;
            }
            v57 += 12;
            v56 -= 24;
          }
          while (v56);
        }
        BOOL Maximas = 1;
      }
LABEL_58:
      v80 |= Maximas;
      BOOL v83 = Maximas;
LABEL_59:
      if (a6)
      {
        uint64_t v59 = *(TFont **)(atomic_load_explicit(v84 + 7, memory_order_acquire) + 40);
        uint64_t TrackingFloor = TFont::GetTrackingFloor(v59);
        char v62 = v61;
        double v63 = *(double *)&TrackingFloor;
        double v64 = TFont::GetEffectiveSize(v59) * -0.03;
        if (v62) {
          double v64 = v63;
        }
        uint64_t v65 = (double *)(*a7 + 24 * (v85 + v14) + 8);
        do
        {
          double v67 = *(v65 - 1);
          double v66 = *v65;
          double v68 = v67 + *v65;
          if (v68 != 0.0 && v68 < v64)
          {
            double v70 = v64 / v68;
            *(v65 - 1) = v67 * v70;
            *uint64_t v65 = v66 * v70;
          }
          v65 += 3;
          --v22;
        }
        while (v22);
      }
      a3 -= v32;
      v14 += v32;
      TAATJustEngine::~TAATJustEngine((TAATJustEngine *)v93);
      v15 += 8;
      if (v15 == v34) {
        goto LABEL_71;
      }
    }
  }
}

uint64_t TFont::GetTrackingFloor(TFont *this)
{
  id v7 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr))(**((void **)this + 50) + 480))(&v7);
  if (atomic_load_explicit((atomic_ullong *volatile)&v7, memory_order_acquire))
  {
    double UnscaledTrackAmount = TFont::GetUnscaledTrackAmount(this);
    double v3 = TAATTrakTable::UnscaledTrackAmountForSize((TAATTrakTable *)atomic_load_explicit((atomic_ullong *volatile)&v7, memory_order_acquire), (const __CFData *)(*(_DWORD *)this & 1), *((double *)this + 2), -1.79769313e308)- UnscaledTrackAmount;
    TFont::GetScaleFactor((double *)this);
    double v5 = v3 * v4;
  }
  else
  {
    double v5 = 0.0;
  }

  return *(void *)&v5;
}

uint64_t TGenericJustEngine::GenerateMaximas(uint64_t a1, TLine *a2, void *a3, unint64_t a4, uint64_t a5, uint64_t *a6, uint64_t a7, int a8, int a9, BOOL *a10)
{
  v108[1] = *MEMORY[0x1E4F143B8];
  double v15 = *(double *)(*(void *)(atomic_load_explicit((atomic_ullong *volatile)(*(void *)(a1 + 8) + 56), memory_order_acquire)+ 40)+ 16);
  uint64_t v16 = *(void *)(*(void *)(atomic_load_explicit((atomic_ullong *volatile)(*(void *)(a1 + 8) + 56), memory_order_acquire)+ 40)+ 400);
  if (v16) {
    int v87 = (*(uint64_t (**)(uint64_t))(*(void *)v16 + 376))(v16);
  }
  else {
    int v87 = 0;
  }
  uint64_t v17 = *(void *)(a1 + 8);
  if (a9)
  {
    uint64_t v78 = 0;
    uint64_t v79 = 0;
    if (a8) {
      double v18 = 1.0;
    }
    else {
      double v18 = -1.0;
    }
    double v19 = 0.0;
    double v20 = 0.0;
    double v21 = v18;
  }
  else
  {
    if (a8) {
      double v19 = 0.5;
    }
    else {
      double v19 = -0.04296875;
    }
    if (a8) {
      double v20 = 0.14453125;
    }
    else {
      double v20 = -0.04296875;
    }
    uint64_t v79 = 2;
    uint64_t v78 = 1;
    double v18 = v19;
    double v21 = v20;
  }
  __int16 v22 = *(_WORD *)(v17 + 178);
  uint64_t v23 = *a6;
  char v86 = *(unsigned char *)(v17 + 224);
  long long v24 = v107;
  *(void *)&long long v25 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v25 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v107[14] = v25;
  v107[13] = v25;
  v107[12] = v25;
  v107[11] = v25;
  v107[10] = v25;
  v107[9] = v25;
  v107[8] = v25;
  _OWORD v107[7] = v25;
  v107[6] = v25;
  v107[5] = v25;
  v107[4] = v25;
  v107[3] = v25;
  id v107[2] = v25;
  v107[1] = v25;
  v107[0] = v25;
  unint64_t v104 = 0;
  unint64_t v105 = 0;
  unint64_t v106 = 0;
  v108[0] = v107;
  unint64_t v81 = a4;
  unint64_t v26 = a4 + a5;
  if (a4 + a5)
  {
    if ((v26 & 0x8000000000000000) != 0) {
      abort();
    }
    unint64_t v27 = (v26 - 1) >> 6;
    if ((void *)((char *)v107 + 8 * v27 + 8) <= v108) {
      v108[0] = (char *)v107 + 8 * v27 + 8;
    }
    else {
      long long v24 = operator new(8 * (v27 + 1));
    }
    unint64_t v105 = v26;
    unint64_t v106 = v27 + 1;
    unint64_t v104 = v24;
    if (v26 >= 0x41) {
      unint64_t v28 = (v26 - 1) >> 6;
    }
    else {
      unint64_t v28 = 0;
    }
    *((void *)v24 + v28) = 0;
    unint64_t v29 = v26 >> 6;
    if (v26 >= 0x40) {
      bzero(v24, 8 * v29);
    }
    if ((v26 & 0x3F) != 0) {
      *((void *)v24 + v29) &= ~(0xFFFFFFFFFFFFFFFFLL >> -(v26 & 0x3F));
    }
  }
  else
  {
    long long v24 = 0;
  }
  unint64_t v30 = a10;
  uint64_t v89 = 0;
  CFRange v90 = a3;
  long long v101 = 0u;
  long long v91 = 0u;
  long long v92 = 0u;
  long long v93 = 0u;
  long long v94 = 0u;
  long long v95 = 0u;
  long long v96 = 0u;
  long long v97 = 0u;
  long long v98 = 0u;
  long long v99 = 0u;
  long long v100 = 0u;
  uint64_t v31 = a3[2];
  uint64_t v102 = 0;
  *(void *)&long long v101 = v31;
  BOOL v32 = *a10;
  uint64_t v88 = 0;
  BOOL v33 = v32;
  if (a5)
  {
    BOOL v85 = v32;
    double v34 = v15 * v20;
    double v35 = v15 * v21;
    double v36 = v15 * v19;
    uint64_t v37 = v23 + 24 * a7;
    uint64_t v84 = a7;
    unint64_t v38 = v81;
    uint64_t v39 = 24 * (v81 + a7) - 8;
    int v40 = v22 & 0x40;
    double v41 = v15 * v18;
    while (1)
    {
      unint64_t v42 = *(void **)(v17 + 216);
      uint64_t v43 = *(void *)(v17 + 200);
      if (*(__int16 *)(v42[2] + 2 * v43 + 2 * v38) != -1)
      {
        int v44 = *(_DWORD *)(v42[5] + 4 * v43 + 4 * v38);
        if (!(v44 & 0x20 | v40))
        {
          uint64_t v45 = v42[6] + 8 * v43;
          uint64_t v46 = *(void *)(v45 + 8 * v38);
          if (v44)
          {
            uint64_t v103 = *(void *)(v45 + 8 * v38);
            UChar32 FullChar = TCharStreamIterator::GetFullChar((TCharStreamIterator *)&v90, &v103, 0);
            IntPropertyCFArrayRef Value = u_getIntPropertyValue(FullChar, UCHAR_EAST_ASIAN_WIDTH);
            if (IntPropertyValue > 5 || ((1 << IntPropertyValue) & 0x2C) == 0)
            {
              uint64_t v54 = v37 + 24 * v38;
              *(double *)uint64_t v54 = v36;
              *(double *)(v54 + 8) = v41;
              *(void *)(v54 + 16) = v78;
              if (v85)
              {
                uint64_t v55 = *a6;
                uint64_t v56 = (unsigned __int16 *)(*a6 + v39);
                uint64_t v57 = v38 + v84;
                while (v57-- >= 1)
                {
                  int v59 = *v56;
                  v56 -= 12;
                  if (v59 != 4) {
                    goto LABEL_70;
                  }
                }
                if (((((v38 + v84) & ((uint64_t)(v38 + v84) >> 63)) - 1) & 0x8000000000000000) != 0) {
                  goto LABEL_71;
                }
                uint64_t v57 = 0x7FFFFFFFFFFFFFFFLL;
LABEL_70:
                BOOL v85 = 0;
                *(void *)(v55 + 24 * v57 + 8) = 0;
                *(void *)(v55 + 24 * (v38 + v84)) = 0;
              }
              else
              {
LABEL_71:
                BOOL v85 = 0;
              }
              goto LABEL_39;
            }
          }
          else
          {
            UChar32 FullChar = 0;
          }
          if (!v87)
          {
            if (a9) {
              goto LABEL_42;
            }
            if (a8)
            {
              if (!FullChar)
              {
                uint64_t v103 = v46;
                UChar32 FullChar = TCharStreamIterator::GetFullChar((TCharStreamIterator *)&v90, &v103, 0);
              }
              if (u_getIntPropertyValue(FullChar, UCHAR_SCRIPT) != 2) {
                goto LABEL_42;
              }
            }
            else
            {
              if (!FullChar)
              {
                uint64_t v103 = v46;
                UChar32 FullChar = TCharStreamIterator::GetFullChar((TCharStreamIterator *)&v90, &v103, 0);
              }
              unsigned int v60 = u_getIntPropertyValue(FullChar, UCHAR_SCRIPT);
              if (v60 > 0x11
                || ((1 << v60) & 0x20414) == 0
                && (v60
                 || (unsigned int v61 = u_getIntPropertyValue(FullChar, UCHAR_EAST_ASIAN_WIDTH), v61 > 5)
                 || ((1 << v61) & 0x2C) == 0))
              {
LABEL_42:
                uint64_t v49 = v38 + v84;
                uint64_t v50 = v88;
                if (v88 > (uint64_t)(v38 + v84) || (uint64_t v51 = v89, v89 + v88 <= v49))
                {
                  TLine::GetClusterRange(a2, a3, v46, 2, &v88, 0, 0);
                  uint64_t v50 = v88;
                  uint64_t v51 = v89;
                }
                uint64_t v52 = v51 - 1;
                if ((v86 & 1) == 0) {
                  uint64_t v52 = 0;
                }
                if (v49 == v52 + v50)
                {
                  uint64_t v53 = v37 + 24 * v38;
                  *(double *)uint64_t v53 = v34;
                  *(double *)(v53 + 8) = v35;
                  *(void *)(v53 + 16) = v79;
                  BOOL v85 = 1;
                }
                else
                {
                  *(void *)((char *)v104 + ((v38 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v38;
                }
                goto LABEL_39;
              }
            }
          }
        }
      }
      *(_WORD *)(v37 + 24 * v38 + 16) = 4;
LABEL_39:
      ++v38;
      v39 += 24;
      if (v38 == v26)
      {
        long long v24 = v104;
        a7 = v84;
        unint64_t v30 = a10;
        BOOL v33 = v85;
        break;
      }
    }
  }
  char v62 = (unint64_t *)v24;
  unint64_t v63 = v105;
  if (v105 < 0x40)
  {
LABEL_76:
    if (v63)
    {
      int v64 = __clz(__rbit64(*v62 & (0xFFFFFFFFFFFFFFFFLL >> -(char)v63)));
      if ((*v62 & (0xFFFFFFFFFFFFFFFFLL >> -(char)v63)) != 0) {
        LODWORD(v63) = v64;
      }
    }
  }
  else
  {
    char v62 = (unint64_t *)v24;
    unint64_t v63 = v105;
    while (!*v62)
    {
      ++v62;
      v63 -= 64;
      if (v63 <= 0x3F) {
        goto LABEL_76;
      }
    }
    LODWORD(v63) = __clz(__rbit64(*v62));
  }
  if (v62 != (unint64_t *)((char *)v24 + 8 * (v105 >> 6)) || (v105 & 0x3F) != v63)
  {
    unint64_t v66 = v81 - 1;
    unint64_t v67 = v26 - 1;
    if ((v86 & 1) == 0)
    {
      unint64_t v66 = v26;
      unint64_t v67 = v81;
    }
    if (v67 != v66)
    {
      uint64_t v68 = 1;
      if (v86) {
        uint64_t v68 = -1;
      }
      uint64_t v69 = 24 * (v67 + a7);
      uint64_t v70 = -1;
      do
      {
        uint64_t v71 = a7 + v67;
        uint64_t v72 = *a6;
        if (((*(void *)((char *)v104 + ((v67 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v67) & 1) == 0 || v70 == -1)
        {
          if (*(_WORD *)(v72 + v69 + 16) == 4) {
            uint64_t v71 = v70;
          }
        }
        else
        {
          uint64_t v73 = (long long *)(v72 + 24 * v70);
          uint64_t v74 = v72 + v69;
          long long v75 = *v73;
          *(void *)(v74 + 16) = *((void *)v73 + 2);
          *(_OWORD *)uint64_t v74 = v75;
          uint64_t v76 = *a6;
          if (v86)
          {
            *(void *)(v76 + v69 + 8) = 0;
            *(void *)(v76 + 24 * v70) = 0;
          }
          else
          {
            *(void *)(v76 + 24 * v70 + 8) = 0;
            *(void *)(v76 + v69) = 0;
          }
        }
        v67 += v68;
        v69 += 24 * v68;
        uint64_t v70 = v71;
      }
      while (v66 != v67);
      long long v24 = v104;
    }
  }
  *unint64_t v30 = v33;
  if (v24 && (v107 > v24 || v108 <= (void *)v24)) {
    operator delete(v24);
  }
  return 1;
}

uint64_t TBaseFont::HasCursiveAttachment(TBaseFont *this)
{
  if ((*((_DWORD *)this + 46) & 0x1000000) != 0) {
    return HIBYTE(*((_DWORD *)this + 45)) & 1;
  }
  BOOL v7 = 0;
  CopyFeatureSettingForTag(@"curs", this, &v7, 0, 1, &v6);
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&v6, memory_order_acquire);
  BOOL v3 = v7;

  if (explicit) {
    BOOL v4 = 0;
  }
  else {
    BOOL v4 = !v3;
  }
  if (v4)
  {
    uint64_t result = 0;
    atomic_fetch_or_explicit((atomic_uint *volatile)this + 45, 0, memory_order_relaxed);
    atomic_fetch_or_explicit((atomic_uint *volatile)this + 46, 0x1000000u, memory_order_relaxed);
  }
  else
  {
    atomic_fetch_or_explicit((atomic_uint *volatile)this + 45, 0x1000000u, memory_order_relaxed);
    atomic_fetch_or_explicit((atomic_uint *volatile)this + 46, 0x1000000u, memory_order_relaxed);
    return 1;
  }
  return result;
}

void TArabicJustEngine::~TArabicJustEngine(TArabicJustEngine *this)
{
  *(void *)this = &unk_1ED05E670;
  std::__hash_table<EncoderAttempt,std::hash<EncoderAttempt>,std::equal_to<EncoderAttempt>,std::allocator<EncoderAttempt>>::~__hash_table((uint64_t)this + 32);
  uint64_t v2 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v2) {
    std::default_delete<std::vector<unsigned short>>::operator()[abi:nn180100]((uint64_t)this + 24, v2);
  }
}

{
  uint64_t vars8;

  TArabicJustEngine::~TArabicJustEngine(this);

  JUMPOUT(0x1853275C0);
}

void TArabicJustEngine::TArabicJustEngine(TArabicJustEngine *this, atomic_ullong *a2)
{
  *(void *)this = &unk_1ED05E670;
  *((void *)this + 1) = a2;
  *((_WORD *)this + 8) = 0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *((void *)this + 7) = 0;
  *((_DWORD *)this + 16) = 1065353216;
  uint64_t v3 = *(void *)(*(void *)(atomic_load_explicit(a2 + 7, memory_order_acquire) + 40) + 400);
  if (v3)
  {
    __int16 v7 = 1600;
    __int16 v6 = -21846;
    if ((*(uint64_t (**)(uint64_t, __int16 *, __int16 *, uint64_t))(*(void *)v3 + 664))(v3, &v7, &v6, 1))
    {
      double v5 = NAN;
      if ((*(unsigned int (**)(uint64_t, __int16 *, double *, uint64_t, uint64_t))(*(void *)v3 + 512))(v3, &v6, &v5, 1, 1))
      {
        if (v5 > 0.0)
        {
          __int16 v4 = v6;
          if (((*(uint64_t (**)(uint64_t, double))(*(void *)v3 + 376))(v3, v5) & 1) == 0) {
            *((_WORD *)this + 8) = v4;
          }
        }
      }
    }
  }
}

BOOL TArabicJustEngine::GenerateMaximas(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (!*(_WORD *)(a1 + 16)) {
    return 0;
  }
  *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v28[14] = v4;
  v28[13] = v4;
  v28[12] = v4;
  v28[11] = v4;
  v28[10] = v4;
  v28[9] = v4;
  v28[8] = v4;
  v28[7] = v4;
  v28[6] = v4;
  v28[5] = v4;
  v28[4] = v4;
  v28[3] = v4;
  v28[2] = v4;
  v28[1] = v4;
  v28[0] = v4;
  long long v27 = v4;
  long long v26 = v4;
  long long v25 = v4;
  long long v24 = v4;
  long long v23 = v4;
  long long v22 = v4;
  long long v21 = v4;
  long long v20 = v4;
  long long v19 = v4;
  long long v18 = v4;
  long long v17 = v4;
  long long v16 = v4;
  long long v15 = v4;
  long long v14 = v4;
  *(_OWORD *)&v13[8] = v4;
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v6 = *(void *)(v5 + 8);
  v12[0] = *(void *)(v5 + 16) + v6;
  v12[1] = v6;
  v13[16] = 0;
  *(void *)uint64_t v13 = 0;
  v12[2] = 0;
  *(void *)&v13[5] = 0;
  *(void *)&long long v14 = a2;
  *((void *)&v14 + 1) = a3;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  uint64_t v7 = *(void *)(a3 + 16);
  long long v26 = 0uLL;
  *(void *)&long long v25 = v7;
  long long v27 = 0uLL;
  unint64_t v29 = v28;
  RuCFIndex n = TScriptRun::NextRun((uint64_t)v12, 0);
  BOOL v9 = *(_DWORD *)&v13[8] == 1634885986 && Run;
  if (v9)
  {
    atomic_load_explicit((atomic_ullong *volatile)(*(void *)(a1 + 8) + 56), memory_order_acquire);
    operator new();
  }
  __p = (char *)&v26 + 8;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&__p);
  return v9;
}

void TAATJustEngine::~TAATJustEngine(TAATJustEngine *this)
{
  *(void *)this = &unk_1ED05DFA0;
  uint64_t v4 = *((void *)this + 8);
  uint64_t v2 = (void *)((char *)this + 64);
  uint64_t v3 = v4;
  *uint64_t v2 = 0;
  if (v4) {
    std::default_delete<std::vector<unsigned short>>::operator()[abi:nn180100]((uint64_t)v2, v3);
  }
}

{
  uint64_t vars8;

  TAATJustEngine::~TAATJustEngine(this);

  JUMPOUT(0x1853275C0);
}

void TAATJustEngine::TAATJustEngine(TAATJustEngine *this, atomic_ullong *a2)
{
  *(void *)this = &unk_1ED05DFA0;
  *((void *)this + 1) = a2;
  uint64_t v3 = (atomic_ullong *)((char *)this + 16);
  (*(void (**)(void))(**(void **)(*(void *)(atomic_load_explicit(a2 + 7, memory_order_acquire) + 40) + 400) + 480))();
  CFDataRef v4 = (const __CFData *)(id)atomic_load_explicit(v3, memory_order_acquire);
  CFDataRef v5 = v4;
  if (v4) {
    BytePtr = CFDataGetBytePtr(v4);
  }
  else {
    BytePtr = 0;
  }

  *((void *)this + 3) = BytePtr;
  id v7 = (id)atomic_load_explicit(v3, memory_order_acquire);
  CFDataRef v8 = (const __CFData *)v7;
  if (v8)
  {
    CFDataRef v9 = v8;
    uint64_t v10 = CFDataGetBytePtr(v8);

    if (v10)
    {
      unint64_t v11 = (unint64_t)&v10[CFDataGetLength((CFDataRef)v7)];
      goto LABEL_9;
    }
  }
  else
  {
  }
  unint64_t v11 = 0;
LABEL_9:

  *(_OWORD *)((char *)this + 40) = 0u;
  *((void *)this + 4) = v11;
  *(_OWORD *)((char *)this + 56) = 0u;
  uint64_t v12 = (_DWORD *)*((void *)this + 3);
  if (v12)
  {
    if ((unint64_t)v12 + 10 > v11 || *v12 != 256)
    {
LABEL_24:
      unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(*((void *)this + 1) + 56), memory_order_acquire);
      CFLog();
      (*(void (**)(void))(**(void **)(*(void *)(explicit + 40) + 400) + 488))(*(void *)(*(void *)(explicit + 40) + 400));
      *((void *)this + 3) = 0;
      *((void *)this + 6) = 0;
      return;
    }
    uint64_t v13 = 8;
    if (!*(unsigned char *)(*((void *)this + 1) + 90)) {
      uint64_t v13 = 6;
    }
    unsigned int v14 = *(unsigned __int16 *)((char *)v12 + v13);
    if (v14)
    {
      long long v15 = (unsigned __int16 *)((char *)v12 + __rev16(v14));
      *((void *)this + 5) = v15;
      if ((unint64_t)(v15 + 12) <= v11)
      {
        long long v16 = (char *)v12 + (bswap32(v15[1]) >> 16);
        *((void *)this + 7) = v16;
        if ((unint64_t)(v16 + 1) <= v11)
        {
          if (!v15[2]
            || (long long v17 = (char *)v12 + __rev16(v15[2]), *((void *)this + 6) = v17, (unint64_t)(v17 + 18) <= v11))
          {
            if (!*v15) {
              operator new();
            }
            if ((unint64_t)v12 + __rev16(*v15) + 26 <= v11) {
              operator new();
            }
          }
        }
      }
      goto LABEL_24;
    }
  }
}

uint64_t TAATJustEngine::GenerateMaximas(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t a7, int a8, int a9)
{
  uint64_t v9 = a1[3];
  if (v9)
  {
    uint64_t v9 = a1[5];
    if (v9)
    {
      uint64_t v15 = *a6;
      double v55 = *(double *)(*(void *)(atomic_load_explicit((atomic_ullong *volatile)(a1[1] + 56), memory_order_acquire)
                                  + 40)
                      + 16);
      uint64_t v16 = a1[1];
      uint64_t v17 = *(void *)(*(void *)(v16 + 216) + 16);
      uint64_t v18 = *(void *)(v16 + 200);
      *(void *)&long long v19 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v19 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long v59 = v19;
      long long v60 = v19;
      long long v20 = (SFNTLookupTable *)a1[4];
      long long v21 = (const SFNTLookupTable *)(a1[5] + 6);
      uint64_t v57 = TAATLookupTable::BadTable;
      uint64_t v58 = 0;
      *((void *)&v60 + 1) = 0;
      unint64_t v61 = 0xAAAAAAAAAAAAFFFFLL;
      TAATLookupTable::SetTable((uint64_t)&v57, v21, v20);
      if (a5)
      {
        char v56 = 0;
        uint64_t v22 = v15 + 24 * a7;
        uint64_t v23 = v17 + 2 * v18;
        uint64_t v24 = a4 + a5;
        if (a8) {
          double v25 = 1.0;
        }
        else {
          double v25 = -1.0;
        }
        if (a8) {
          double v26 = 1.0;
        }
        else {
          double v26 = 0.0;
        }
        float32x2_t v27 = (float32x2_t)vdup_n_s32(0x37800000u);
        do
        {
          uint64_t v28 = *(void *)(v16 + 216);
          uint64_t v29 = *(void *)(v16 + 200);
          if (*(__int16 *)(*(void *)(v28 + 16) + 2 * v29 + 2 * a4) == -1
            || (*(_DWORD *)(*(void *)(v28 + 40) + 4 * v29 + 4 * a4) & 0x20) != 0)
          {
            *(_WORD *)(v22 + 24 * a4 + 16) = 4;
          }
          else
          {
            uint64_t v30 = *(unsigned __int16 *)(v23 + 2 * a4);
            unint64_t v62 = 0xAAAAAAAAAAAAAAAALL;
            uint64_t v31 = v57;
            BOOL v32 = (TAATLookupTable *)((char *)&v57 + (v58 >> 1));
            if (v58) {
              uint64_t v31 = *(uint64_t (**)(TAATLookupTable *, unsigned __int16, unint64_t *))(*(void *)v32 + v57);
            }
            BOOL v33 = (float64x2_t *)(v22 + 24 * a4);
            double v34 = (unsigned __int16 *)v31(v32, v30, &v62);
            if (!v34) {
              goto LABEL_35;
            }
            uint64_t v35 = bswap32(*v34) >> 16;
            uint64_t v36 = a1[7];
            uint64_t v37 = (unsigned int *)(v36 + v35);
            unint64_t v38 = a1[4];
            BOOL v39 = a1[3] > (unint64_t)(v36 + v35) || v36 + v35 + 28 > v38;
            if (!v39
              && ((int v40 = (void *)a1[8], *v40 == v40[1]) ? (v41 = 0) : (v41 = *(unsigned __int16 *)(*v40 + 2 * a4)),
                  (unint64_t v42 = v37 + 1,
                   unsigned int v43 = bswap32(*v37),
                   unint64_t v44 = (unint64_t)&v42[6 * v43],
                   v44 >= (unint64_t)v42)
                ? (BOOL v45 = v44 > v38)
                : (BOOL v45 = 1),
                  v45 ? (int v46 = (v38 - (unint64_t)v42) / 0x18) : (int v46 = v43),
                  v46))
            {
              BOOL v47 = (unsigned __int16 *)(v36 + v35 + 26);
              while (v41 != bswap32(*(_DWORD *)(v47 - 11)))
              {
                v47 += 12;
                if (!--v46) {
                  goto LABEL_35;
                }
              }
              if (a8)
              {
                unsigned int v49 = bswap32(*(v47 - 1)) >> 16;
                unsigned int v50 = bswap32(*(_DWORD *)(v47 - 9));
                uint64_t v51 = (unsigned int *)(v47 - 5);
              }
              else
              {
                unsigned int v49 = bswap32(*v47) >> 16;
                unsigned int v50 = bswap32(*(_DWORD *)(v47 - 7));
                uint64_t v51 = (unsigned int *)(v47 - 3);
              }
              float32x2_t v52 = vmul_f32(vcvt_f32_s32((int32x2_t)__PAIR64__(bswap32(*v51), v50)), v27);
              if (v52.f32[0] != 0.0 || v52.f32[1] != 0.0)
              {
                float64x2_t *v33 = vmulq_n_f64(vcvtq_f64_f32(v52), v55);
                char v56 = 1;
              }
              uint64_t v53 = v22 + 24 * a4;
              *(_WORD *)(v53 + 16) = v49 & 3;
              *(unsigned char *)(v53 + 18) = (v49 & 0x1000) != 0;
            }
            else
            {
LABEL_35:
              if ((*(_DWORD *)(*(void *)(*(void *)(a1[1] + 216) + 40)
                              + 4 * *(void *)(a1[1] + 200)
                              + 4 * a4) & 1) != 0)
              {
                v33->f64[0] = v25;
                uint64_t v48 = v22 + 24 * a4;
                *(double *)(v48 + 8) = v26;
                *(_WORD *)(v48 + 16) = 1;
              }
              *(unsigned char *)(v22 + 24 * a4 + 18) = 0;
            }
          }
          ++a4;
        }
        while (a4 != v24);
      }
      else
      {
        char v56 = 0;
      }
      LOBYTE(v9) = (a9 == 0) | v56;
    }
  }
  return v9 & 1;
}

uint64_t TJustEngine::DistributeGap(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, int a5, char a6, uint64_t a7, uint64_t a8, double a9, double *a10)
{
  uint64_t v10 = a7;
  uint64_t v11 = a3;
  uint64_t v12 = a2;
  uint64_t v13 = result;
  memset(v94, 0, sizeof(v94));
  uint64_t v14 = a3 + a4;
  memset(v95, 0, 64);
  if (a4 >= 1)
  {
    uint64_t v15 = (double *)(a7 + 24 * a3 + 16);
    double v16 = 0.0;
    uint64_t v17 = a3;
    do
    {
      uint64_t v18 = *(unsigned __int16 *)v15;
      if (v18 != 4)
      {
        double v19 = *(v15 - 2) + *(v15 - 1);
        *((double *)v95 + v18) = *((double *)v95 + v18) + v19;
        double v16 = v16 + v19;
        if (*((unsigned char *)v15 + 2)) {
          *((double *)&v95[2] + v18) = v19 + *((double *)&v95[2] + v18);
        }
      }
      ++v17;
      v15 += 3;
    }
    while (v17 < v14);
    if (a5)
    {
      long long v20 = (double *)(a7 + 24 * a3 + 8);
      uint64_t v21 = a3;
      do
      {
        double *v20 = *(v20 - 1) + *v20;
        *(v20 - 1) = 0.0;
        ++v21;
        v20 += 3;
      }
      while (v21 < v14);
      goto LABEL_20;
    }
LABEL_12:
    uint64_t v22 = v14 - 1;
    uint64_t v23 = a7 + 24 * (v14 - 1);
    double v25 = *(double *)(v23 + 8);
    uint64_t v24 = (void *)(v23 + 8);
    double v26 = v25;
    if (v25 != 0.0)
    {
      uint64_t v27 = a7 + 24 * v22;
      int v28 = *(unsigned __int8 *)(v27 + 18);
      uint64_t v29 = *(unsigned __int16 *)(v27 + 16);
      if (v28) {
        *((double *)&v95[2] + v29) = *((double *)&v95[2] + v29) - v26;
      }
      double v16 = v16 - v26;
      *((double *)v95 + v29) = *((double *)v95 + v29) - v26;
      void *v24 = 0;
    }
    uint64_t v30 = (double *)(a7 + 24 * a3);
    double v31 = *v30;
    if (*v30 != 0.0)
    {
      uint64_t v32 = a7 + 24 * a3;
      int v33 = *(unsigned __int8 *)(v32 + 18);
      uint64_t v34 = *(unsigned __int16 *)(v32 + 16);
      if (v33) {
        *((double *)&v95[2] + v34) = *((double *)&v95[2] + v34) - v31;
      }
      double v16 = v16 - v31;
      *((double *)v95 + v34) = *((double *)v95 + v34) - v31;
      *uint64_t v30 = 0.0;
    }
    goto LABEL_20;
  }
  double v16 = 0.0;
  if (!a5) {
    goto LABEL_12;
  }
LABEL_20:
  uint64_t v35 = 0;
  uint64_t v36 = 0;
  double v37 = a9;
  __int16 v38 = -1;
  do
  {
    double v39 = *(double *)((char *)v95 + v35);
    if (v39 != 0.0)
    {
      if (fabs(v37) <= fabs(v39))
      {
        *(double *)((char *)v94 + v35) = v37 / v39;
        goto LABEL_35;
      }
      if (v38 == -1) {
        __int16 v38 = v36;
      }
      *(void *)((char *)v94 + v35) = 0x3FF0000000000000;
      double v37 = v37 - v39;
      double v40 = *(double *)((char *)&v95[2] + v35);
      if (v40 != 0.0)
      {
        *(double *)((char *)&v94[2] + v35) = v37 / v40;
        goto LABEL_35;
      }
    }
    ++v36;
    v35 += 8;
  }
  while (v36 != 4);
  if (((a6 & 1) != 0 && v37 > 0.0 || (a6 & 1) == 0 && v37 != 0.0) && v38 != -1) {
    *((double *)v94 + v38) = (a9 - v16 + *((double *)v95 + v38)) / *((double *)v95 + v38);
  }
LABEL_35:
  if (result != a2)
  {
    while (1)
    {
      uint64_t v41 = *(void *)(*(void *)(*(void *)v13 + 40) + 208);
      if (v11 < v41) {
        break;
      }
      v10 += 24 * v41;
      a8 += 8 * v41;
      v13 += 8;
      v11 -= v41;
      if (v13 == a2) {
        return result;
      }
    }
  }
  if (v13 != a2)
  {
    unint64_t v42 = 0;
    do
    {
      uint64_t v43 = *(void *)(*(void *)v13 + 48);
      uint64_t v44 = *(void *)(v43 + 208);
      uint64_t v45 = v11 & ~(v11 >> 63);
      uint64_t v46 = v11 + a4;
      if (v11 + a4 >= v44) {
        uint64_t v46 = *(void *)(v43 + 208);
      }
      BOOL v47 = v46 < v45;
      uint64_t v48 = v46 - v45;
      if (v47)
      {
        uint64_t v48 = 0;
        uint64_t v49 = 0;
      }
      else
      {
        uint64_t v49 = v11 & ~(v11 >> 63);
      }
      if (v48 >= 1)
      {
        uint64_t v89 = v42;
        uint64_t v90 = v11;
        uint64_t v50 = *(void *)(v43 + 216);
        uint64_t v51 = *(void *)(v50 + 32);
        uint64_t v91 = v13;
        uint64_t v87 = *(void *)(v43 + 208);
        if (v51 || (uint64_t v54 = *(void *)(v50 + 24)) == 0)
        {
          char v52 = 0;
          uint64_t v53 = v51 + 16 * *(void *)(v43 + 200);
        }
        else
        {
          uint64_t v53 = v54 + 8 * *(void *)(v43 + 200);
          char v52 = 1;
        }
        uint64_t v88 = *(void *)(*(void *)v13 + 48);
        double v55 = (TStorageRange *)(v43 + 192);
        uint64_t v56 = v49 + v48;
        uint64_t v57 = v53 - 8 + 8 * (v49 + v48);
        uint64_t v58 = v49 + v48 - 1;
        long long v59 = (uint64_t *)(v53 - 8 + 16 * (v49 + v48));
        uint64_t v92 = v10;
        long long v60 = (double *)(v10 + 24 * (v49 + v48) - 8);
        double v61 = 0.0;
        do
        {
          uint64_t v62 = *(unsigned __int16 *)v60;
          double v63 = *((double *)v94 + v62);
          double v65 = *(v60 - 2);
          double v64 = *(v60 - 1);
          double v66 = v64 * v63;
          double v67 = v63 * v65;
          if (*((unsigned char *)v60 + 2))
          {
            double v68 = *((double *)&v94[2] + v62);
            double v66 = v66 + v64 * v68;
            double v67 = v67 + v65 * v68;
          }
          --v56;
          *(double *)(a8 + 8 * v58) = v66 + v67;
          uint64_t v69 = 0;
          uint64_t v70 = (double *)v57;
          if ((v52 & 1) == 0)
          {
            uint64_t v70 = (double *)(v53 + 16 * v56);
            uint64_t v69 = *v59;
          }
          double v71 = v61 + v66;
          if (v61 + v66 != 0.0)
          {
            double v72 = v71 + *v70;
            uint64_t result = TStorageRange::SetAdvance(v55, v58, *(CGSize *)(&v69 - 1));
            double v73 = v71 + *a10;
            double v74 = a10[1] + *a10 - (v73 - v71) + v71 - (v73 - (v73 - v71));
            *a10 = v73;
            a10[1] = v74;
          }
          v60 -= 3;
          v57 -= 8;
          v59 -= 2;
          double v61 = v67;
          BOOL v47 = v58-- <= v49;
        }
        while (!v47);
        unint64_t v42 = v89;
        uint64_t v11 = v90;
        BOOL v75 = v67 == 0.0 || v89 == 0;
        uint64_t v13 = v91;
        uint64_t v10 = v92;
        uint64_t v12 = a2;
        uint64_t v44 = v87;
        uint64_t v43 = v88;
        if (!v75)
        {
          uint64_t v76 = v89[27];
          uint64_t v77 = v89[26] - 1;
          uint64_t v78 = *(void *)(v76 + 32);
          if (v78 || (uint64_t v81 = *(void *)(v76 + 24)) == 0)
          {
            uint64_t v79 = v78 + 16 * v89[25] + 16 * v77;
            uint64_t v80 = *(void *)(v79 + 8);
          }
          else
          {
            uint64_t v79 = v81 + 8 * v89[25] + 8 * v77;
            uint64_t v80 = 0;
          }
          double v82 = v67 + *(double *)v79;
          uint64_t result = TStorageRange::SetAdvance((TStorageRange *)(v89 + 24), v77, *(CGSize *)(&v80 - 1));
          double v83 = v67 + *a10;
          double v84 = a10[1] + *a10 - (v83 - v67) + v67 - (v83 - (v83 - v67));
          *a10 = v83;
          a10[1] = v84;
        }
      }
      v10 += 24 * v44;
      a8 += 8 * v44;
      if ((*(_WORD *)(v43 + 178) & 0x40) == 0) {
        unint64_t v42 = (void *)v43;
      }
      v11 -= v44;
      v13 += 8;
    }
    while (v13 != v12);
  }
  return result;
}

void TAttributes::ApplyAttributeHandlers(void const*,void const*,void *)::$_0::__invoke()
{
  keys[38] = *(void **)MEMORY[0x1E4F143B8];
  keys[0] = @"NSFont";
  keys[1] = @"NSParagraphStyle";
  keys[2] = @"CTForegroundColor";
  keys[3] = @"CTBackgroundColor";
  keys[4] = @"NSColor";
  keys[5] = @"NSBackgroundColor";
  keys[6] = @"NSShadow";
  keys[7] = @"NSBaselineOffset";
  keys[8] = @"NSStrokeWidth";
  keys[9] = @"NSUnderline";
  keys[10] = @"NSStrikethrough";
  keys[11] = @"NSKern";
  keys[12] = @"CTTracking";
  keys[13] = @"NSLigature";
  keys[14] = @"CTBaselineOffset";
  keys[15] = @"CTSuperscript";
  keys[16] = @"NSCharacterShape";
  keys[17] = @"CTVerticalForms";
  keys[18] = @"CTHorizontalInVerticalForms";
  keys[19] = @"NSGlyphInfo";
  keys[20] = @"CTRunDelegate";
  keys[21] = @"CTForegroundColorFromContext";
  keys[22] = @"CTRenderingStyle";
  keys[23] = @"CTBaselineClass";
  keys[24] = @"CTBaselineInfo";
  keys[25] = @"CTBaselineReferenceInfo";
  keys[26] = @"NSWritingDirection";
  keys[27] = @"NSLanguage";
  keys[28] = @"CTRubyAnnotation";
  keys[29] = @"CTTextEncapsulation";
  keys[30] = @"NSTextEncapsulation";
  keys[31] = @"CTTrimWhitespaceBackground";
  keys[32] = @"CTImposedGlyph";
  keys[33] = @"CTPalette";
  keys[34] = @"NSTextScale";
  keys[35] = @"CTAdaptiveImageProvider";
  keys[36] = @"CTEmojiImageProvider";
  keys[37] = @"CTRunMetricsDelegate";
  memcpy(__dst, off_1ED062750, sizeof(__dst));
  id v0 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)keys, __dst, 38, MEMORY[0x1E4F1D530], 0);
  qword_1EB2CE2F0 = atomic_exchange((atomic_ullong *volatile)&v0, 0);
}

BOOL CTFontDescriptorMatchFontDescriptorsWithProgressHandlerCore(void *a1, void *a2, uint64_t a3, const void *a4)
{
  if (a1)
  {
    if (qword_1EB2CE948 != -1) {
      dispatch_once(&qword_1EB2CE948, &__block_literal_global_180);
    }
    CFDataRef v8 = qword_1EB2CE950;
    uint64_t v9 = [FontAssetDownloadManager alloc];
    if (v9)
    {
      v14.receiver = v9;
      v14.super_class = (Class)FontAssetDownloadManager;
      uint64_t v10 = (atomic_ullong *)objc_msgSendSuper2(&v14, sel_init);
      uint64_t v11 = v10;
      if (v10)
      {
        TCFRef<__CTFont const*>::Retain(v10 + 1, a1);
        if ((void *)atomic_load_explicit(v11 + 2, memory_order_acquire) != a2) {

        }
        v11[3] = (atomic_ullong)_Block_copy(a4);
        v11[4] = [objc_alloc(MEMORY[0x1E4F1CA60]) initWithCapacity:0];
        v11[5] = [objc_alloc(MEMORY[0x1E4F1CA60]) initWithCapacity:0];
        v11[6] = [objc_alloc(MEMORY[0x1E4F1CA60]) initWithCapacity:0];
      }
    }
    else
    {
      uint64_t v11 = 0;
    }
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = ___ZL59CTFontDescriptorMatchFontDescriptorsWithProgressHandlerCorePK9__CFArrayPK7__CFSetmU13block_pointerFb29CTFontDescriptorMatchingStatePK14__CFDictionaryE_block_invoke;
    CFRange v13[3] = &unk_1E52909A0;
    v13[4] = v11;
    v13[5] = a3;
    dispatch_async(v8, v13);
  }
  return a1 != 0;
}

void CGFontVariationFromDictCallback(const void *a1, const __CFString *a2, void *a3)
{
  unint64_t v3 = a3[2];
  if (v3 >= a3[3]) {
    return;
  }
  a3[2] = v3 + 1;
  uint64_t v5 = a3[4];
  if (!v5) {
    return;
  }
  CFDataRef v8 = (int *)(v5 + 16 * v3);
  CFTypeID v9 = CFGetTypeID(a1);
  if (v9 == CFNumberGetTypeID())
  {
    CFNumberGetValue((CFNumberRef)a1, kCFNumberIntType, (void *)(v5 + 16 * v3));
  }
  else if (v9 == CFStringGetTypeID())
  {
    uint64_t v10 = a3[1];
    if (v10)
    {
      uint64_t v11 = (_DWORD *)(*a3 + 8);
      uint64_t v12 = 40 * v10;
      while (1)
      {
        uint64_t v13 = (const void *)*((void *)v11 - 1);
        if (v13 == a1 || a1 && v13 && CFEqual(a1, v13)) {
          break;
        }
        v11 += 10;
        v12 -= 40;
        if (!v12)
        {
          LODWORD(v10) = 0;
          goto LABEL_15;
        }
      }
      LODWORD(v10) = *v11;
    }
LABEL_15:
    *CFDataRef v8 = v10;
  }
  objc_super v14 = (double *)(v5 + 16 * v3 + 8);
  if (a2)
  {
    CFTypeID v15 = CFGetTypeID(a2);
    if (v15 == CFNumberGetTypeID() || v15 == CFBooleanGetTypeID())
    {
      CFNumberGetValue((CFNumberRef)a2, kCFNumberDoubleType, v14);
      return;
    }
    if (v15 == CFStringGetTypeID())
    {
      *objc_super v14 = CFStringGetDoubleValue(a2);
      return;
    }
  }
  uint64_t v16 = a3[1];
  if (v16)
  {
    int v17 = *v8;
    uint64_t v18 = 40 * v16;
    double v19 = (void *)(*a3 + 32);
    do
    {
      if (*((_DWORD *)v19 - 6) == v17) {
        *objc_super v14 = *(double *)v19;
      }
      v19 += 5;
      v18 -= 40;
    }
    while (v18);
  }
}

CTFontRef TAttributes::GetDefaultFont(void)::{lambda(void *)#1}::__invoke(TDescriptorSource *a1)
{
  CTFontRef result = TDescriptorSource::CreateDefaultUserFont(a1);
  if (!result) {
    CTFontRef result = CTFontCreateWithName(0, 0.0, 0);
  }
  qword_1EB2CE2E8 = (uint64_t)result;
  return result;
}

CTFontRef CTFontCreateWithName(CFStringRef name, CGFloat size, const CGAffineTransform *matrix)
{
  CFTypeID v9 = (__CFString *)name;
  CGFloat v8 = size;
  id v6 = (id)0xAAAAAAAAAAAAAAAALL;
  id v7 = (CGAffineTransform *)matrix;
  TCFBase_NEW<CTFont,__CFString const*&,double &,CGAffineTransform const*&,char const(&)[21]>(&v9, &v8, &v7, "CTFontCreateWithName", &v5);
  id v6 = (id)atomic_exchange((atomic_ullong *volatile)&v5, 0);

  unint64_t v3 = (const __CTFont *)atomic_exchange((atomic_ullong *volatile)&v6, 0);
  return v3;
}

void TCFBase_NEW<CTFont,__CFString const*&,double &,CGAffineTransform const*&,char const(&)[21]>(__CFString **a1@<X0>, double *a2@<X1>, CGAffineTransform **a3@<X2>, const char *a4@<X3>, void *a5@<X8>)
{
  uint64_t v10 = TCFBase<TFont>::Allocate();
  if (v10)
  {
    uint64_t v11 = (void *)v10;
    uint64_t v12 = *a1;
    double v13 = *a2;
    objc_super v14 = *a3;
    CFTypeID v15 = (TFont *)(v10 + 48);
    void v11[2] = 0;
    v11[3] = TFont::Hash;
    v11[4] = 0;
    v11[5] = v15;
    TFont::TFont(v15, v12, v13, v14, a4, 0);
    id v16 = v11;
    *a5 = atomic_exchange((atomic_ullong *volatile)&v16, 0);
  }
  else
  {
    *a5 = 0;
  }
}

CTFontRef CTFontCreateWithNameAndOptions(CFStringRef name, CGFloat size, const CGAffineTransform *matrix, CTFontOptions options)
{
  int v17 = (__CFString *)name;
  sizeCGFloat a = size;
  CTFontOptions v14 = options;
  CFTypeID v15 = (CGAffineTransform *)matrix;
  if ((options & 0x20000000) != 0)
  {
    int v7 = options & 0x85;
    uint64_t SystemUIFontOptions = TFont::GetSystemUIFontOptions((TFont *)name);
    int v9 = v7 | 0x400;
    if ((SystemUIFontOptions & options) == 0) {
      int v9 = v7;
    }
    LODWORD(v12) = v9 | (options >> 1) & 0x10000;
    TCFBase_NEW<CTFontDescriptor,__CFString const*&,double &,unsigned int &>(&v17, &sizea, (int *)&v12, &v13);
    uint64_t v10 = (const __CTFontDescriptor *)atomic_exchange((atomic_ullong *volatile)&v13, 0);

    id v5 = CTFontCreateWithFontDescriptorAndOptions(v10, sizea, v15, v14);
    id v6 = v10;
  }
  else
  {
    id v13 = (id)0xAAAAAAAAAAAAAAAALL;
    TCFBase_NEW<CTFont,__CFString const*&,double &,CGAffineTransform const*&,char const(&)[31],unsigned long &>(&v17, &sizea, &v15, "CTFontCreateWithNameAndOptions", &v14, &v12);
    id v13 = (id)atomic_exchange((atomic_ullong *volatile)&v12, 0);

    id v5 = (const __CTFont *)atomic_exchange((atomic_ullong *volatile)&v13, 0);
    id v6 = v13;
  }

  return v5;
}

void TCFBase_NEW<CTFont,__CFString const*&,double &,CGAffineTransform const*&,char const(&)[31],unsigned long &>(__CFString **a1@<X0>, double *a2@<X1>, CGAffineTransform **a3@<X2>, const char *a4@<X3>, unint64_t *a5@<X4>, void *a6@<X8>)
{
  uint64_t v12 = TCFBase<TFont>::Allocate();
  if (v12)
  {
    id v13 = (void *)v12;
    CTFontOptions v14 = *a1;
    double v15 = *a2;
    id v16 = *a3;
    unint64_t v17 = *a5;
    uint64_t v18 = (TFont *)(v12 + 48);
    v13[2] = 0;
    CFRange v13[3] = TFont::Hash;
    v13[4] = 0;
    v13[5] = v18;
    TFont::TFont(v18, v14, v15, v16, a4, v17);
    id v19 = v13;
    *a6 = atomic_exchange((atomic_ullong *volatile)&v19, 0);
  }
  else
  {
    *a6 = 0;
  }
}

void TFont::TFont(TFont *this, __CFString *a2, double a3, CGAffineTransform *a4, const char *a5, unint64_t a6)
{
  *(_DWORD *)this = 0;
  int v9 = (atomic_ullong *)((char *)this + 8);
  TFont::InitDescriptor(a2, a3, a6, (void *)this + 1);
  *((double *)this + 2) = TFont::InitSize(0, a3, v10);
  *((void *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0x80000000;
  TFont::InitMatrix((TFont *)a4, 0, (void *)this + 5);
  *((_DWORD *)this + 12) = 0;
  *(_OWORD *)((char *)this + 88) = *MEMORY[0x1E4F1DAD8];
  long long v11 = *(_OWORD *)(MEMORY[0x1E4F1DB28] + 16);
  *(_OWORD *)((char *)this + 104) = *MEMORY[0x1E4F1DB28];
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 120) = v11;
  *((unsigned char *)this + 136) = 0;
  *((void *)this + 24) = 0;
  *((void *)this + 23) = 0;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((void *)this + 22) = (char *)this + 184;
  *((_DWORD *)this + 50) = 0;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *((_DWORD *)this + 60) = 1065353216;
  *(_OWORD *)((char *)this + 248) = 0u;
  *(_OWORD *)((char *)this + 264) = 0u;
  *((_DWORD *)this + 70) = 1065353216;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 19) = 0u;
  *((_OWORD *)this + 20) = 0u;
  *((_OWORD *)this + 21) = 0u;
  *((_OWORD *)this + 22) = 0u;
  *((_DWORD *)this + 92) = 0;
  *((void *)this + 47) = 0;
  *((void *)this + 48) = 0;
  *((unsigned char *)this + 392) = 0;
  *((void *)this + 50) = TFont::InitBaseFont(v12, v9);
  *((void *)this + 51) = 0;
  *((_DWORD *)this + 104) = 0;
  *(_OWORD *)((char *)this + 456) = 0u;
  *(_OWORD *)((char *)this + 472) = 0u;
  *((void *)this + 54) = 0;
  *((void *)this + 55) = 0;
  *((void *)this + 53) = 0;
  *((_DWORD *)this + 112) = 0;
  *((_DWORD *)this + 122) = 1065353216;
  *((void *)this + 62) = 0;
  *((_DWORD *)this + 126) = 0;
  *((void *)this + 64) = 0;
  *((unsigned char *)this + 520) = 0;
  *((void *)this + 66) = 0;
  *((void *)this + 68) = 0;
  *((void *)this + 67) = 0;
  *(_DWORD *)this = 192;
  TFont::SetOpticalSize(this, 0);
  TFont::AddFontSpecificFeatureSettings(this);
}

void TFont::InitDescriptor(__CFString *this@<X0>, double a2@<D0>, unint64_t a3@<X2>, void *a4@<X8>)
{
  if (this && CFStringGetLength(this) > 0)
  {
    if (qword_1EB2CE040 != -1) {
      dispatch_once_f(&qword_1EB2CE040, 0, (dispatch_function_t)TFont::GetSystemUIFontOptions(void)::$_0::__invoke);
    }
    uint64_t v9 = a3 & 0x85;
    if ((qword_1EB2CE038 & a3) != 0) {
      uint64_t v9 = a3 & 0x85 | 0x400;
    }
    unint64_t v10 = (a3 >> 1) & 0x10000 | (((a3 >> 1) & 1) << 9) | v9 | 2;
    id v33 = (id)0xAAAAAAAAAAAAAAAALL;
    TDescriptorSource::TDescriptorSource((TDescriptorSource *)keys);
    TDescriptorSource::CopyFontDescriptorPerPostScriptName((atomic_ullong **)keys, this, v10, 0, 0, &v33);
    unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&v33, memory_order_acquire);
    if (a2 <= 0.0 || !explicit) {
      goto LABEL_41;
    }
    uint64_t v12 = (TDescriptor **)(id)atomic_load_explicit((atomic_ullong *volatile)&v33, memory_order_acquire);
    id v13 = v12;
    CTFontOptions v14 = v12[5];
    if ((*((_DWORD *)v14 + 4) & 0x80000000) == 0) {
      TDescriptor::InitBaseFont(v12[5], 0, 0.0);
    }
    unint64_t v15 = atomic_load_explicit((atomic_ullong *volatile)v14 + 4, memory_order_acquire);

    if (v15
      && (*(unsigned int (**)(unint64_t))(*(void *)v15 + 16))(v15) == 1414743620
      && (*(unsigned int (**)(unint64_t))(*(void *)v15 + 840))(v15))
    {
      keys[0] = @"NSFontNameAttribute";
      id values = this;
      CFDictionaryRef v16 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      *(void *)&long long v17 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v17 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long v31 = v17;
      long long v32 = v17;
      *(_OWORD *)id keys = v17;
      TDescriptor::TDescriptor((TDescriptor *)keys, v16, v10);
      if ((v31 & 0x80000000) == 0) {
        TDescriptor::InitBaseFont((TDescriptor *)keys, v10, a2);
      }
      unint64_t v18 = atomic_load_explicit((atomic_ullong *volatile)&v32, memory_order_acquire);
      uint64_t v19 = TCFBase<TDescriptor>::Allocate();
      if (v19)
      {
        *(void *)(v19 + 16) = 0;
        *(void *)(v19 + 24) = TDescriptor::Hash;
        *(void *)(v19 + 32) = 0;
        *(void *)(v19 + 40) = v19 + 48;
        *(void *)(v19 + 48) = &unk_1ED05D778;
        *(void *)(v19 + 56) = 0;
        *(_DWORD *)(v19 + 64) = v10 | 0x80000400;
        *(void *)(v19 + 72) = 0;
        if (v18) {
          atomic_fetch_add_explicit((atomic_uint *volatile)(v18 + 8), 1u, memory_order_relaxed);
        }
        *(void *)(v19 + 80) = v18;
        *(void *)(v19 + 88) = 0;
        id values = (void *)v19;
        id v29 = (id)atomic_exchange((atomic_ullong *volatile)&values, 0);
      }
      else
      {
        id v29 = 0;
      }
      *a4 = atomic_exchange((atomic_ullong *volatile)&v29, 0);

      TDescriptor::~TDescriptor((TDescriptor *)keys);
    }
    else
    {
LABEL_41:
      if (atomic_load_explicit((atomic_ullong *volatile)&v33, memory_order_acquire))
      {
        long long v20 = (TDescriptor **)(id)atomic_load_explicit((atomic_ullong *volatile)&v33, memory_order_acquire);
        uint64_t v21 = v20;
        uint64_t v22 = v20[5];
        if ((*((_DWORD *)v22 + 4) & 0x80000000) == 0) {
          TDescriptor::InitBaseFont(v20[5], 0, 0.0);
        }
        unint64_t v23 = atomic_load_explicit((atomic_ullong *volatile)v22 + 4, memory_order_acquire);

        if (v23)
        {
          id v24 = (id)atomic_load_explicit((atomic_ullong *volatile)(v23 + 96), memory_order_acquire);
          double v25 = (TFont *)v24;
          uint64_t v27 = v25;
          if (v25 == (TFont *)this || v25 && CFEqual(v25, this))
          {
          }
          else
          {
            char ShouldSubstituteInvisibleFontName = TDescriptorSource::ShouldSubstituteInvisibleFontName(this, v26);

            if ((ShouldSubstituteInvisibleFontName & 1) == 0)
            {
              CFLog();
              if (qword_1EB2CE048 != -1) {
                dispatch_once_f(&qword_1EB2CE048, "CTFontLogSuboptimalRequest", (dispatch_function_t)CTFontLogSuboptimalRequest::$_0::__invoke);
              }
            }
          }
        }
      }
      if (!atomic_load_explicit((atomic_ullong *volatile)&v33, memory_order_acquire))
      {
        TDescriptorSource::TDescriptorSource((TDescriptorSource *)&values);
        TDescriptorSource::CreateDefaultDescriptor(0, keys);
      }
      *a4 = atomic_exchange((atomic_ullong *volatile)&v33, 0);
    }
  }
  else
  {
    TDescriptorSource::TDescriptorSource((TDescriptorSource *)keys);
    TDescriptorSource::CreateDefaultDescriptor(0, a4);
  }
}

CTFontRef TDescriptorSource::CreateDefaultUserFont(TDescriptorSource *this)
{
  return CTFontCreateWithName(@"Helvetica", 12.0, 0);
}

CTFontDescriptorRef CTFontDescriptorCreateCopyWithFeature(CTFontDescriptorRef original, CFNumberRef featureTypeIdentifier, CFNumberRef featureSelectorIdentifier)
{
  CFNumberRef v9 = featureTypeIdentifier;
  CFNumberRef v8 = featureSelectorIdentifier;
  if (!original) {
    return 0;
  }
  if (featureTypeIdentifier && featureSelectorIdentifier)
  {
    id v7 = (id)0xAAAAAAAAAAAAAAAALL;
    CTFontDescriptorRef v5 = original;
    TCFBase_NEW<CTFontDescriptor,CTFontDescriptor*,__CFNumber const*&,__CFNumber const*&>((uint64_t *)&v5, &v9, &v8, &v6);
    id v7 = (id)atomic_exchange((atomic_ullong *volatile)&v6, 0);

    unint64_t v3 = (const __CTFontDescriptor *)atomic_exchange((atomic_ullong *volatile)&v7, 0);
    return v3;
  }

  return original;
}

void TCFBase_NEW<CTFontDescriptor,CTFontDescriptor*,__CFNumber const*&,__CFNumber const*&>(uint64_t *a1@<X0>, const __CFNumber **a2@<X1>, const __CFNumber **a3@<X2>, void *a4@<X8>)
{
  uint64_t v8 = TCFBase<TDescriptor>::Allocate();
  if (v8)
  {
    CFNumberRef v9 = (void *)v8;
    uint64_t v10 = *a1;
    CFNumberRef v11 = *a2;
    CFNumberRef v12 = *a3;
    id v13 = (TDescriptor *)(v8 + 48);
    v9[2] = 0;
    v9[3] = TDescriptor::Hash;
    v9[4] = 0;
    v9[5] = v13;
    TDescriptor::TDescriptor(v13, *(const TDescriptor **)(v10 + 40), v11, v12);
    id v14 = v9;
    *a4 = atomic_exchange((atomic_ullong *volatile)&v14, 0);
  }
  else
  {
    *a4 = 0;
  }
}

void TDescriptor::TDescriptor(TDescriptor *this, const TDescriptor *a2, const __CFNumber *a3, const __CFNumber *a4)
{
  *(void *)this = &unk_1ED05D778;
  *((void *)this + 1) = 0;
  *((_DWORD *)this + 4) = *((_DWORD *)a2 + 4) & 0x7FFFFFFF;
  *((void *)this + 3) = 0;
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)a2 + 4, memory_order_acquire);
  if (explicit)
  {
    if ((*(_DWORD *)(explicit + 180) & 0x10000000) != 0)
    {
      unint64_t explicit = 0;
    }
    else
    {
      atomic_fetch_or_explicit((atomic_uint *volatile)this + 4, 0x80000000, memory_order_relaxed);
      atomic_fetch_add_explicit((atomic_uint *volatile)(explicit + 8), 1u, memory_order_relaxed);
    }
  }
  *((void *)this + 4) = explicit;
  *((void *)this + 5) = (id)atomic_load_explicit((atomic_ullong *volatile)a2 + 5, memory_order_acquire);
  id v14 = (id)0xAAAAAAAAAAAAAAAALL;
  TDescriptor::CopyAttributes((atomic_ullong *)a2, &v14);
  id v13 = (id)0xAAAAAAAAAAAAAAAALL;
  TCFMutableDictionary::TCFMutableDictionary((TCFMutableDictionary *)&v13, (CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v14, memory_order_acquire));
  CFNumberRef v9 = -[CTFeatureSetting initWithType:selector:tag:value:]([CTFeatureSetting alloc], (uint64_t)a3, (uint64_t)a4, 0, 0);
  if (v9)
  {
    id v12 = (id)0xAAAAAAAAAAAAAAAALL;
    CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v13, memory_order_acquire), @"NSCTFontFeatureSettingsAttribute");
    TCFMutableArray::TCFMutableArray((TCFMutableArray *)&v12, Value);
    CFNumberRef v11 = v9;
    CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v12, memory_order_acquire), v11);

    CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v13, memory_order_acquire), @"NSCTFontFeatureSettingsAttribute", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v12, memory_order_acquire));
  }
}

CFStringRef CTFontCopyFullName(CTFontRef font)
{
  if (!font) {
    return 0;
  }
  (*(void (**)(id *__return_ptr))(**(void **)(*((void *)font + 5) + 400) + 72))(&v3);
  CFStringRef v1 = (const __CFString *)atomic_exchange((atomic_ullong *volatile)&v3, 0);

  return v1;
}

uint64_t CTRunGetPropertiesPtr(uint64_t a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  uint64_t v1 = *(void *)(a1 + 40);
  if ((*(unsigned char *)(v1 + 225) & 8) == 0) {
    return *(void *)(*(void *)(v1 + 216) + 40) + 4 * *(void *)(v1 + 200);
  }
  NonDeletedGlyphCFIndex Count = TRun::GetNonDeletedGlyphCount(*(TRun **)(a1 + 40));
  CFMutableArrayRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  BytePtr = (const UInt8 *)Mutable;
  if (Mutable)
  {
    CFDataSetLength(Mutable, 4 * NonDeletedGlyphCount);
    CFAutorelease(BytePtr);
    BytePtr = CFDataGetBytePtr((CFDataRef)BytePtr);
    uint64_t v6 = *(void *)(v1 + 208);
    uint64_t v5 = *(void *)(v1 + 216);
    uint64_t v7 = *(void *)(v1 + 200);
    uint64_t v8 = *(void *)(v5 + 40) + 4 * v7;
    uint64_t v9 = *(void *)(v1 + 264);
    v16[0] = &unk_1ED05FD68;
    v16[1] = BytePtr;
    v16[2] = v8;
    long long v17 = v16;
    if (NonDeletedGlyphCount) {
      uint64_t v10 = NonDeletedGlyphCount;
    }
    else {
      uint64_t v10 = v6;
    }
    if (v6 >= 1 && v10 >= 1)
    {
      uint64_t v12 = 0;
      uint64_t v13 = 0;
      uint64_t v14 = *(void *)(v5 + 16) + 2 * v7;
      do
      {
        if (v9 == v13 || *(unsigned __int16 *)(v14 + 2 * v13) != 0xFFFF) {
          std::function<void ()(long,long)>::operator()((uint64_t)v17, v13, v12++);
        }
        ++v13;
      }
      while (v13 < v6 && v12 < v10);
    }
    std::__function::__value_func<void ()(long,long)>::~__value_func[abi:nn180100](v16);
  }
  return (uint64_t)BytePtr;
}

const __CFNumber *TAttributes::HandleNSBaselineOffsetAttribute(const __CFNumber *result, TAttributes **a2)
{
  if (result)
  {
    CFNumberRef v3 = result;
    double valuePtr = NAN;
    CFTypeID v4 = CFGetTypeID(result);
    if (v4 == CFNumberGetTypeID() || v4 == CFBooleanGetTypeID())
    {
      CFNumberGetValue(v3, kCFNumberDoubleType, &valuePtr);
    }
    else
    {
      CTFontRef result = (const __CFNumber *)CFStringGetTypeID();
      if ((const __CFNumber *)v4 != result) {
        return result;
      }
      double valuePtr = CFStringGetDoubleValue((CFStringRef)v3);
    }
    CTFontRef result = (const __CFNumber *)TAttributes::EnsureRareData(*a2);
    if (!*((void *)result + 5))
    {
      *((void *)result + 5) = @"NSBaselineOffset";
      *((double *)result + 6) = valuePtr;
    }
  }
  return result;
}

void GetFontAttributeID(__CFString const*)::$_0::__invoke()
{
  keys[67] = *(void **)MEMORY[0x1E4F143B8];
  keys[0] = @"NSFontNameAttribute";
  keys[1] = @"NSFontVisibleNameAttribute";
  keys[2] = @"NSFontFamilyAttribute";
  keys[3] = @"NSFontFaceAttribute";
  keys[4] = @"NSCTFontTraitsAttribute";
  keys[5] = @"NSCTFontVariationAxesAttribute";
  keys[6] = @"NSCTFontVariationAttribute";
  keys[7] = @"NSFontSizeAttribute";
  keys[8] = @"NSCTFontOpticalSizeAttribute";
  keys[9] = @"NSCTFontTrackAttribute";
  keys[10] = @"NSCTFontUnscaledTrackingAttribute";
  keys[11] = @"NSCTFontMatrixAttribute";
  keys[12] = @"NSFontMatrixAttribute";
  keys[13] = @"NSCTFontCascadeListAttribute";
  keys[14] = @"NSCTFontCharacterSetAttribute";
  keys[15] = @"NSCTFontLanguagesAttribute";
  keys[16] = @"NSCTFontBaselineAdjustAttribute";
  keys[17] = @"NSCTFontMacintoshEncodingsAttribute";
  keys[18] = @"NSCTFontFeaturesAttribute";
  keys[19] = @"NSCTFontFeatureSettingsAttribute";
  keys[20] = @"NSCTFontFixedAdvanceAttribute";
  keys[21] = @"NSCTFontOrientationAttribute";
  keys[22] = @"NSCTFontDesignLanguagesAttribute";
  keys[23] = @"NSCTFontComponentListAttribute";
  keys[24] = @"NSCTFontFileURLAttribute";
  keys[25] = @"NSCTFontFormatAttribute";
  keys[26] = @"NSCTFontStringEncodingAttribute";
  keys[27] = @"CTFontIgnoreScriptAnalysisAttribute";
  keys[28] = @"NSCTFontRegistrationScopeAttribute";
  keys[29] = @"NSCTFontPriorityAttribute";
  keys[30] = @"NSCTFontDomainAttribute";
  keys[31] = @"NSCTFontEnabledAttribute";
  keys[32] = @"NSCTFontReferenceURLAttribute";
  keys[33] = @"NSCTFontPostScriptNameAttribute";
  keys[34] = @"NSCTFontDownloadableAttribute";
  keys[35] = @"NSCTFontDownloadedAttribute";
  keys[36] = @"CTFontOriginalFeatureSettingsAttribute";
  keys[37] = @"CTFontShapingGlyphsAttribute";
  keys[38] = @"CTFontVerticalShapingGlyphsAttribute";
  keys[39] = @"CTFontShapingGlyphsFFSAttribute";
  keys[40] = @"CTFontVerticalShapingGlyphsFFSAttribute";
  keys[41] = @"CTFontLangSysListAttribute";
  keys[42] = @"NSCTFontUIUsageAttribute";
  keys[43] = @"CTFontCacheGlyphImagesAttribute";
  keys[44] = @"CTFontOpticalPointSizesAttribute";
  keys[45] = @"CTFontCSSWeightAttribute";
  keys[46] = @"CTFontCSSWidthAttribute";
  keys[47] = @"NSCTFontSizeCategoryAttribute";
  keys[48] = @"CTFontPaletteAttribute";
  keys[49] = @"CTFontPaletteColorsAttribute";
  keys[50] = @"CTFontMorxConversionResultAttribute";
  keys[51] = @"CTFontDescriptorLanguageAttribute";
  keys[52] = @"CTFontPostScriptNameAliases";
  keys[53] = @"NSCTFontUserInstalledAttribute";
  keys[54] = @"NSCTFontFallbackOptionAttribute";
  keys[55] = @"NSCTFontTextStylePlatformAttribute";
  keys[56] = @"NSCTFontTextStyleTraitsAttribute";
  keys[57] = @"CTFontLanguageAwareLineHeightRatioAttribute";
  keys[58] = @"CTFontLineSpacingOverrideAttribute";
  keys[59] = @"CTFontLegibilityWeightAttribute";
  keys[60] = @"CTFontIgnoreLegibilityWeightAttribute";
  keys[61] = @"NSCTFontCodableVariationAttribute";
  keys[62] = @"CTFontDownloadableStubAttribute";
  keys[63] = @"CTFontWeightAxisValueAttribute";
  keys[64] = @"CTFontEmojiMLUpscalingTimeoutAttribute";
  keys[65] = @"CTFontDisableColorBitmapSizeModAttribute";
  keys[66] = @"CTFontAllowCellularDownloadAttribute";
  memcpy(__dst, &unk_184BA9270, sizeof(__dst));
  id v1 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)keys, __dst, 67, MEMORY[0x1E4F1D530], 0);
  unint64_t v0 = atomic_exchange((atomic_ullong *volatile)&v1, 0);

  _MergedGlobals_33 = v0;
}

BOOL CTFontHasFeatureSettingWithTypeAndSelector(BOOL result, unsigned __int16 a2, int a3)
{
  if (result) {
    return TFontFeatureSettingList::IndexOfAATSetting((TFontFeatureSettingList *)(*(void *)(result + 40) + 168), a2, a3) != -1;
  }
  return result;
}

void LangSysTagsWithFallback(unsigned int)::$_0::__invoke()
{
  unint64_t v0 = kLanguageToLangSysMappings;
  id v1 = &kLanguageToLangSysMappings[8];
  int v2 = 1633776160;
  do
  {
    CFNumberRef v3 = v1;
    int v4 = *((_DWORD *)v0 + 2);
    if (v4 != v2) {
      goto LABEL_82;
    }
    unint64_t v5 = *((unsigned int *)v0 + 3);
    int v6 = *((_DWORD *)v0 + 1);
    uint64_t v7 = operator new(0x18uLL);
    v7[4] = v5;
    v7[5] = v6;
    *(void *)uint64_t v7 = 0;
    *((void *)v7 + 1) = v5;
    int8x8_t v8 = (int8x8_t)qword_1EB2CE558;
    float v9 = (float)(unint64_t)(qword_1EB2CE568 + 1);
    if (!qword_1EB2CE558 || (float)(*(float *)&dword_1EB2CE570 * (float)(unint64_t)qword_1EB2CE558) < v9)
    {
      BOOL v10 = (qword_1EB2CE558 & (qword_1EB2CE558 - 1)) != 0;
      if ((unint64_t)qword_1EB2CE558 < 3) {
        BOOL v10 = 1;
      }
      unint64_t v11 = v10 | (2 * qword_1EB2CE558);
      unint64_t v12 = vcvtps_u32_f32(v9 / *(float *)&dword_1EB2CE570);
      if (v11 <= v12) {
        int8x8_t prime = (int8x8_t)v12;
      }
      else {
        int8x8_t prime = (int8x8_t)v11;
      }
      if (*(void *)&prime == 1)
      {
        int8x8_t prime = (int8x8_t)2;
      }
      else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
      {
        int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
        int8x8_t v8 = (int8x8_t)qword_1EB2CE558;
      }
      if (*(void *)&prime > *(void *)&v8) {
        goto LABEL_96;
      }
      if (*(void *)&prime >= *(void *)&v8) {
        goto LABEL_45;
      }
      unint64_t v20 = vcvtps_u32_f32((float)(unint64_t)qword_1EB2CE568 / *(float *)&dword_1EB2CE570);
      if (*(void *)&v8 < 3uLL || (uint8x8_t v21 = (uint8x8_t)vcnt_s8(v8), v21.i16[0] = vaddlv_u8(v21), v21.u32[0] > 1uLL))
      {
        unint64_t v20 = std::__next_prime(v20);
      }
      else
      {
        uint64_t v22 = 1 << -(char)__clz(v20 - 1);
        if (v20 >= 2) {
          unint64_t v20 = v22;
        }
      }
      if (*(void *)&prime <= v20) {
        int8x8_t prime = (int8x8_t)v20;
      }
      if (*(void *)&prime >= *(void *)&v8)
      {
        int8x8_t v8 = (int8x8_t)qword_1EB2CE558;
        goto LABEL_45;
      }
      if (prime)
      {
LABEL_96:
        if (*(void *)&prime >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        uint64_t v14 = operator new(8 * *(void *)&prime);
        unint64_t v15 = (void *)qword_1EB2CE550;
        qword_1EB2CE550 = (uint64_t)v14;
        if (v15) {
          operator delete(v15);
        }
        uint64_t v16 = 0;
        qword_1EB2CE558 = (uint64_t)prime;
        do
          *(void *)(qword_1EB2CE550 + 8 * v16++) = 0;
        while (*(void *)&prime != v16);
        long long v17 = (uint64_t **)qword_1EB2CE560;
        if (qword_1EB2CE560)
        {
          unint64_t v18 = *(void *)(qword_1EB2CE560 + 8);
          uint8x8_t v19 = (uint8x8_t)vcnt_s8(prime);
          v19.i16[0] = vaddlv_u8(v19);
          if (v19.u32[0] > 1uLL)
          {
            if (v18 >= *(void *)&prime) {
              v18 %= *(void *)&prime;
            }
          }
          else
          {
            v18 &= *(void *)&prime - 1;
          }
          *(void *)(qword_1EB2CE550 + 8 * v18) = &qword_1EB2CE560;
          for (uint64_t i = *v17; *v17; uint64_t i = *v17)
          {
            unint64_t v24 = i[1];
            if (v19.u32[0] > 1uLL)
            {
              if (v24 >= *(void *)&prime) {
                v24 %= *(void *)&prime;
              }
            }
            else
            {
              v24 &= *(void *)&prime - 1;
            }
            if (v24 == v18)
            {
              long long v17 = (uint64_t **)i;
            }
            else
            {
              double v25 = i;
              if (*(void *)(qword_1EB2CE550 + 8 * v24))
              {
                do
                {
                  CFStringRef v26 = v25;
                  double v25 = (uint64_t *)*v25;
                }
                while (v25 && *((_DWORD *)i + 4) == *((_DWORD *)v25 + 4));
                *long long v17 = v25;
                *CFStringRef v26 = **(void **)(qword_1EB2CE550 + 8 * v24);
                **(void **)(qword_1EB2CE550 + 8 * v24) = i;
              }
              else
              {
                *(void *)(qword_1EB2CE550 + 8 * v24) = v17;
                long long v17 = (uint64_t **)i;
                unint64_t v18 = v24;
              }
            }
          }
        }
        int8x8_t v8 = prime;
      }
      else
      {
        double v39 = (void *)qword_1EB2CE550;
        qword_1EB2CE550 = 0;
        if (v39) {
          operator delete(v39);
        }
        int8x8_t v8 = 0;
        qword_1EB2CE558 = 0;
      }
    }
LABEL_45:
    uint8x8_t v27 = (uint8x8_t)vcnt_s8(v8);
    v27.i16[0] = vaddlv_u8(v27);
    if (v27.u32[0] > 1uLL)
    {
      unint64_t v28 = v5;
      if (*(void *)&v8 <= v5) {
        unint64_t v28 = v5 % *(void *)&v8;
      }
    }
    else
    {
      unint64_t v28 = (v8.i32[0] - 1) & v5;
    }
    uint64_t v29 = qword_1EB2CE550;
    uint64_t v30 = *(uint64_t **)(qword_1EB2CE550 + 8 * v28);
    if (v30)
    {
      int v31 = 0;
      do
      {
        long long v32 = v30;
        uint64_t v30 = (uint64_t *)*v30;
        if (!v30) {
          break;
        }
        unint64_t v33 = v30[1];
        if (v27.u32[0] > 1uLL)
        {
          unint64_t v34 = v30[1];
          if (v33 >= *(void *)&v8) {
            unint64_t v34 = v33 % *(void *)&v8;
          }
        }
        else
        {
          unint64_t v34 = v33 & (*(void *)&v8 - 1);
        }
        if (v34 != v28) {
          break;
        }
        BOOL v35 = v33 == v5 && *((_DWORD *)v30 + 4) == v7[4];
        int v36 = v31 & !v35;
        v31 |= v35;
      }
      while (v36 != 1);
    }
    else
    {
      long long v32 = 0;
    }
    if (v27.u32[0] > 1uLL)
    {
      if (*(void *)&v8 <= v5) {
        v5 %= *(void *)&v8;
      }
    }
    else
    {
      unint64_t v5 = (v8.i32[0] - 1) & v5;
    }
    if (v32)
    {
      *(void *)uint64_t v7 = *v32;
      *long long v32 = v7;
      if (!*(void *)v7) {
        goto LABEL_81;
      }
      unint64_t v37 = *(void *)(*(void *)v7 + 8);
      if (v27.u32[0] > 1uLL)
      {
        if (v37 >= *(void *)&v8) {
          v37 %= *(void *)&v8;
        }
      }
      else
      {
        v37 &= *(void *)&v8 - 1;
      }
      if (v37 == v5) {
        goto LABEL_81;
      }
      goto LABEL_80;
    }
    uint64_t v38 = qword_1EB2CE560;
    *(void *)uint64_t v7 = qword_1EB2CE560;
    qword_1EB2CE560 = (uint64_t)v7;
    *(void *)(v29 + 8 * v5) = &qword_1EB2CE560;
    if (v38)
    {
      unint64_t v37 = *(void *)(v38 + 8);
      if (v27.u32[0] > 1uLL)
      {
        if (v37 >= *(void *)&v8) {
          v37 %= *(void *)&v8;
        }
      }
      else
      {
        v37 &= *(void *)&v8 - 1;
      }
LABEL_80:
      *(void *)(qword_1EB2CE550 + 8 * v37) = v7;
    }
LABEL_81:
    ++qword_1EB2CE568;
LABEL_82:
    id v1 = v3 + 8;
    int v2 = v4;
    unint64_t v0 = v3;
  }
  while (v3 + 8 != (char *)&kMasterFeatureMap);
}

uint64_t TCFBase<TTypesetter>::CreateTypeID()
{
  {
    TCFBase<TTypesetter>::CreateTypeID(void)::runtimeunsigned int Class = 0;
    *(void *)algn_1EB2CD888 = "CTTypesetter";
    qword_1EB2CD890 = 0;
    unk_1EB2CD898 = 0;
    qword_1EB2CD8A0 = (uint64_t)TCFBase<TTypesetter>::ClassDestruct;
    qword_1EB2CD8A8 = (uint64_t)TCFBase<TTypesetter>::ClassEqual;
    qword_1EB2CD8B0 = (uint64_t)TCFBase<TTypesetter>::ClassHash;
    unk_1EB2CD8B8 = 0;
    qword_1EB2CD8C0 = (uint64_t)TCFBase<TTypesetter>::ClassDebug;
    unk_1EB2CD8C8 = 0;
    qword_1EB2CD8D0 = 0;
    unk_1EB2CD8D8 = 0;
  }
  uint64_t result = _CFRuntimeRegisterClass();
  TCFBase<TTypesetter>::fCFTypeID TypeID = result;
  return result;
}

CFArrayRef CTFontCopyVariationAxes(CTFontRef font)
{
  if (!font) {
    return 0;
  }
  TBaseFont::CopyVariationAxesExternal(*(TBaseFont **)(*((void *)font + 5) + 400), (atomic_ullong *)&v3);
  CFArrayRef v1 = (const __CFArray *)atomic_exchange((atomic_ullong *volatile)&v3, 0);

  return v1;
}

void TBaseFont::CopyVariationAxesExternal(TBaseFont *this@<X0>, atomic_ullong *a2@<X8>)
{
  *a2 = 0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(atomic_ullong *__return_ptr))(*(void *)this + 120))(a2);
  if (atomic_load_explicit(a2, memory_order_acquire))
  {
    TBaseFont::GetInitializedGraphicsFont(this);
    uint64_t ParserFont = CGFontGetParserFont();
    if (ParserFont)
    {
      uint64_t v5 = ParserFont;
      CFIndex Count = CFArrayGetCount((CFArrayRef)atomic_load_explicit(a2, memory_order_acquire));
      CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], Count, MEMORY[0x1E4F1D510]);
      id v31 = (id)0xAAAAAAAAAAAAAAAALL;
      CreateNormalizedPreferredLanguages(&v31);
      uint64_t v9 = CGFontNameTableCreate();
      if (v9)
      {
        uint64_t v10 = v9;
        CFStringRef v26 = a2;
        CFAllocatorRef allocator = v7;
        CFArrayRef explicit = (const __CFArray *)atomic_load_explicit(a2, memory_order_acquire);
        if (explicit)
        {
          CFIndex v12 = CFArrayGetCount(explicit);
          if (v12)
          {
            CFIndex v13 = v12;
            CFIndex v14 = 0;
            unint64_t v15 = @"NSCTVariationAxisIdentifier";
            do
            {
              CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(explicit, v14);
              int valuePtr = -1431655766;
              CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, v15);
              if (Value)
              {
                CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
                int VariationAxisNameID = FPFontGetVariationAxisNameID();
                id v29 = (id)0xAAAAAAAAAAAAAAAALL;
                CopyLocalizedFontNameInternal((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v31, memory_order_acquire), 0, v10, VariationAxisNameID, 0, @"AxisNames", (atomic_ullong *)&v29);
                if (atomic_load_explicit((atomic_ullong *volatile)&v29, memory_order_acquire))
                {
                  uint8x8_t v19 = v15;
                  unint64_t v20 = Mutable;
                  uint64_t v21 = v10;
                  uint64_t v22 = v5;
                  id v23 = (id)atomic_load_explicit((atomic_ullong *volatile)&v29, memory_order_acquire);
                  id v24 = (id)CFDictionaryGetValue(ValueAtIndex, @"NSCTVariationAxisName");
                  if (v23 == v24)
                  {

                    uint64_t v5 = v22;
                    uint64_t v10 = v21;
                    CFMutableArrayRef Mutable = v20;
                    unint64_t v15 = v19;
                  }
                  else
                  {
                    if (!v23 || !v24)
                    {

                      uint64_t v5 = v22;
                      uint64_t v10 = v21;
                      CFMutableArrayRef Mutable = v20;
                      unint64_t v15 = v19;
LABEL_21:
                      id v28 = (id)0xAAAAAAAAAAAAAAAALL;
                      TCFMutableDictionary::TCFMutableDictionary((TCFMutableDictionary *)&v28, ValueAtIndex);
                      CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v28, memory_order_acquire), @"NSCTVariationAxisName", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v29, memory_order_acquire));
                      CFArrayAppendValue(Mutable, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v28, memory_order_acquire));

                      goto LABEL_18;
                    }
                    int v25 = CFEqual(v23, v24);

                    uint64_t v5 = v22;
                    uint64_t v10 = v21;
                    CFMutableArrayRef Mutable = v20;
                    unint64_t v15 = v19;
                    if (!v25) {
                      goto LABEL_21;
                    }
                  }
                }
              }
              else
              {
                int valuePtr = 0;
              }
              CFArrayAppendValue(Mutable, ValueAtIndex);
LABEL_18:
              ++v14;
            }
            while (v13 != v14);
          }
        }

        CGFontNameTableRelease();
      }
    }
  }
}

void CopyLocalizedFontNameInternal(CFArrayRef theArray@<X3>, CGFont *a2@<X0>, uint64_t a3@<X1>, int a4@<W2>, void *a5@<X4>, const __CFString *a6@<X5>, atomic_ullong *a7@<X8>)
{
  v80[1] = *MEMORY[0x1E4F143B8];
  id v78 = 0;
  if (!theArray || (CFArrayRef explicit = theArray, !CFArrayGetCount(theArray)))
  {
    CreateNormalizedPreferredLanguages(&values);

    CFArrayRef explicit = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v78, memory_order_acquire);
  }
  if (a5) {
    *a5 = 0;
  }
  if ((unint64_t)a2 | a3 && a4 != -1)
  {
    v77.datCGFloat a = 0;
    v77.uint64_t length = 0;
    if ((a4 & 0x80000000) == 0)
    {
      if (a3)
      {
        uint64_t v14 = 0;
      }
      else
      {
        a3 = CGFontNameTableCreate();
        uint64_t v14 = a3;
        if (!a3) {
          goto LABEL_44;
        }
      }
      uint64_t v68 = v14;
      uint64_t v69 = a2;
      double v72 = a5;
      CFStringRef v74 = a6;
      uint64_t v70 = a7;
      CFArrayRef v15 = (const __CFArray *)CGFontNameTableCopyLocales();
      CFAllocatorRef v16 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      theSet = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D548]);
      if (v15)
      {
        CFIndex Count = CFArrayGetCount(v15);
        if (Count)
        {
          CFIndex v18 = Count;
          for (CFIndex i = 0; i != v18; ++i)
          {
            CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v15, i);
            CFStringRef v21 = (const __CFString *)MEMORY[0x185325F30](ValueAtIndex);
            CanonicalLanguageIdentifierFromString = (__CFString *)CFLocaleCreateCanonicalLanguageIdentifierFromString(v16, v21);
            CFStringRef v23 = CanonicalLanguageIdentifierFromString;
            if (v23)
            {
              id v24 = (__CFString *)v23;
              CFIndex Length = CFStringGetLength(v23);

              if (Length >= 1) {
                CFSetAddValue(theSet, CanonicalLanguageIdentifierFromString);
              }
            }
            else
            {
            }
          }
        }
      }
      int v71 = a4;
      id values = (id)0xAAAAAAAAAAAAAAAALL;
      TCFMutableArray::TCFMutableArray((TCFMutableArray *)&values, explicit);
      if (explicit)
      {
        CFIndex v26 = CFArrayGetCount(explicit);
        if (v26)
        {
          CFIndex v27 = v26;
          CFIndex v28 = 0;
          id v29 = (const void *)*MEMORY[0x1E4F1D218];
          do
          {
            CFStringRef v30 = (const __CFString *)CFArrayGetValueAtIndex(explicit, v28);
            CFDictionaryRef ComponentsFromLocaleIdentifier = CFLocaleCreateComponentsFromLocaleIdentifier(v16, v30);
            CFDictionaryRef v32 = ComponentsFromLocaleIdentifier;
            if (ComponentsFromLocaleIdentifier)
            {
              CFNumberRef Value = CFDictionaryGetValue(ComponentsFromLocaleIdentifier, v29);
              if (Value)
              {
                unint64_t v34 = Value;
                CFArrayRef v35 = v15;
                CFArrayRef v36 = explicit;
                uint64_t v37 = a3;
                unint64_t v38 = atomic_load_explicit((atomic_ullong *volatile)&values, memory_order_acquire);
                v81.uint64_t length = CFArrayGetCount((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&values, memory_order_acquire));
                CFArrayRef v39 = (const __CFArray *)v38;
                a3 = v37;
                CFArrayRef explicit = v36;
                CFArrayRef v15 = v35;
                v81.locatioCFIndex n = 0;
                if (!CFArrayContainsValue(v39, v81, v34)) {
                  CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&values, memory_order_acquire), v34);
                }
              }
            }

            ++v28;
          }
          while (v27 != v28);
        }
      }
      double v40 = theSet;
      a4 = v71;
      if (CFSetGetCount(theSet) > 0)
      {
        v77.info = 0xAAAAAAAAAAAAAAAALL;
        CreateSortedArrayWithSet(theSet, 0, 0, (CFArrayRef *)&v77.info);
        CFArrayRef v41 = CFBundleCopyLocalizationsForPreferences((CFArrayRef)atomic_load_explicit(&v77.info, memory_order_acquire), (CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&values, memory_order_acquire));
        CFArrayRef v42 = v41;
        if (v41)
        {
          CFIndex v43 = CFArrayGetCount(v41);
          if (v43)
          {
            CFIndex v44 = 0;
            CFIndex v45 = v43 - 1;
            do
            {
              uint64_t v46 = (void *)CFArrayGetValueAtIndex(v42, v44);
              TCFRef<__CTFont const*>::Retain((atomic_ullong *)&v77.data, v46);
              if (v71 == 1 || v71 == 2) {

              }
              if (!atomic_load_explicit(&v77.length, memory_order_acquire)) {
              if (atomic_load_explicit(&v77.length, memory_order_acquire))
              }
                break;
              BOOL v53 = v45 == v44++;
            }
            while (!v53);
          }
        }

        double v40 = theSet;
      }

      a2 = v69;
      a7 = v70;
      a5 = v72;
      a6 = v74;
      if (v68)
      {
        CGFontNameTableRelease();
        a3 = 0;
      }
    }
LABEL_44:
    if (a4 != 2 && !a6)
    {
LABEL_98:
      if (atomic_load_explicit(&v77.length, memory_order_acquire))
      {
        if (a5) {
          *a5 = atomic_exchange((atomic_ullong *volatile)&v77.data, 0);
        }
        *a7 = atomic_exchange(&v77.length, 0);
      }
      else
      {
        CopyFontNameInternal(a2, a3, a4, a7);
      }
      goto LABEL_103;
    }
    unint64_t v47 = atomic_load_explicit(&v77.length, memory_order_acquire);
    BOOL v48 = v47 == 0;
    if (atomic_load_explicit(&v77.length, memory_order_acquire)
      && atomic_load_explicit((atomic_ullong *volatile)&v77.data, memory_order_acquire)
      && CFArrayGetCount(explicit))
    {
      CFStringRef v75 = a6;
      id values = (id)0xAAAAAAAAAAAAAAAALL;
      if (explicit) {
        uint64_t v49 = (__CFString *)CFArrayGetValueAtIndex(explicit, 0);
      }
      else {
        uint64_t v49 = 0;
      }
      LanguageIdentifierByNormalizing(v49, 1u, (atomic_ullong *)&values);
      v77.info = 0xAAAAAAAAAAAAAAAALL;
      LanguageIdentifierByNormalizing((__CFString *)atomic_load_explicit((atomic_ullong *volatile)&v77.data, memory_order_acquire), 1u, &v77.info);
      id v50 = (id)atomic_load_explicit((atomic_ullong *volatile)&values, memory_order_acquire);
      id v51 = (id)atomic_load_explicit(&v77.info, memory_order_acquire);
      char v52 = v51;
      if (v50 != v51)
      {
        if (!v50 || !v51)
        {

          a6 = v75;
          if (v75) {
            goto LABEL_72;
          }
          goto LABEL_53;
        }
        if (CFEqual(v50, v51)) {
          BOOL v53 = v47 == 0;
        }
        else {
          BOOL v53 = 1;
        }
        BOOL v48 = v53;
      }

      a6 = v75;
      if (!v48) {
        goto LABEL_98;
      }
    }
    else if (v47)
    {
      goto LABEL_98;
    }
    if (a6) {
      goto LABEL_72;
    }
LABEL_53:
    if (a4 == 4)
    {
LABEL_56:
      a6 = @"FontNames";
      goto LABEL_72;
    }
    if (a4 != 2)
    {
      if (a4 != 1) {
        goto LABEL_98;
      }
      goto LABEL_56;
    }
    a6 = @"StyleNames";
LABEL_72:
    *a7 = 0xAAAAAAAAAAAAAAAALL;
    CopyFontNameInternal(a2, a3, a4, a7);
    if (atomic_load_explicit(a7, memory_order_acquire))
    {
      if (a4 < 0)
      {
LABEL_103:

        goto LABEL_104;
      }
      MutableCopCGFloat y = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, (CFStringRef)atomic_load_explicit(a7, memory_order_acquire));
      if (MutableCopy)
      {
        double v55 = MutableCopy;
        CFStringTrimWhitespace(MutableCopy);
        id values = v55;
      }
    }
    v77.isCGFloat a = (void *)0xAAAAAAAAAAAAAAAALL;
    v77.info = 0;
    CFStringRef v56 = (const __CFString *)atomic_load_explicit(a7, memory_order_acquire);
    if (atomic_load_explicit((atomic_ullong *volatile)&v78, memory_order_acquire)) {
      uint64_t v57 = 0;
    }
    else {
      uint64_t v57 = (const __CFString **)explicit;
    }
    unint64_t v58 = atomic_load_explicit((atomic_ullong *volatile)&v78, memory_order_acquire);
    if (a5 || !v58)
    {
      id values = &v77.info;
      v80[0] = 0;
      CopyDefaultLocalizedName(&v77, v56, a6, v57, (unint64_t)v80);
    }
    else
    {
      CopyDefaultLocalizedName(&v77, v56, a6, v57, 0);
    }
    if (!atomic_load_explicit((atomic_ullong *volatile)&v77, memory_order_acquire)) {
      goto LABEL_97;
    }
    if (atomic_load_explicit(&v77.info, memory_order_acquire)
      && atomic_load_explicit((atomic_ullong *volatile)&v77.data, memory_order_acquire))
    {
      double v73 = a5;
      id values = (id)0xAAAAAAAAAAAAAAAALL;
      v80[0] = 0xAAAAAAAAAAAAAAAALL;
      long long v59 = (void *)atomic_load_explicit(&v77.info, memory_order_acquire);
      unint64_t v60 = atomic_load_explicit((atomic_ullong *volatile)&v77.data, memory_order_acquire);
      id values = v59;
      v80[0] = v60;
      CFArrayRef v61 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&values, 2, MEMORY[0x1E4F1D510]);
      CFArrayRef v62 = CFBundleCopyLocalizationsForPreferences(v61, explicit);
      CFArrayRef v63 = v62;
      CFArrayRef v64 = v63;
      if (v63 && CFArrayGetCount(v63)) {
        double v65 = CFArrayGetValueAtIndex(v62, 0);
      }
      else {
        double v65 = 0;
      }

      double v66 = (const void *)atomic_load_explicit(&v77.info, memory_order_acquire);
      if (v65 == v66)
      {

        a5 = v73;
      }
      else
      {
        if (!v65 || !v66)
        {

          a5 = v73;
          goto LABEL_97;
        }
        int v67 = CFEqual(v65, v66);

        a5 = v73;
        if (!v67) {
          goto LABEL_97;
        }
      }
    }
    TCFRef<__CTFont const*>::Retain((atomic_ullong *)&v77.data, (id)atomic_load_explicit(&v77.info, memory_order_acquire));
    TCFRef<__CTFont const*>::Retain(&v77.length, (id)atomic_load_explicit((atomic_ullong *volatile)&v77, memory_order_acquire));
LABEL_97:

    goto LABEL_98;
  }
  *a7 = 0;
LABEL_104:
}

void CreateSortedArrayWithSet(CFSetRef theSet@<X0>, CFComparisonResult (__cdecl *a2)(const void *, const void *, void *)@<X1>, void *a3@<X2>, CFArrayRef *a4@<X8>)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  if (theSet)
  {
    CFIndex Count = CFSetGetCount(theSet);
    *(void *)&long long v9 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v33 = v9;
    long long v32 = v9;
    long long v31 = v9;
    long long v30 = v9;
    long long v29 = v9;
    long long v28 = v9;
    long long v27 = v9;
    long long v26 = v9;
    long long v25 = v9;
    long long v23 = v9;
    long long v24 = v9;
    long long v21 = v9;
    long long v22 = v9;
    long long v19 = v9;
    long long v20 = v9;
    long long v17 = 0;
    uint64_t v18 = 0;
    id values = 0;
    unint64_t v34 = &v19;
    if (Count)
    {
      std::vector<long,TInlineBufferAllocator<long,30ul>>::__vallocate[abi:nn180100](&values, Count);
      uint64_t v10 = (char *)v17;
      bzero(v17, 8 * Count);
      long long v17 = &v10[8 * Count];
      unint64_t v11 = values;
    }
    else
    {
      unint64_t v11 = 0;
    }
  }
  else
  {
    unint64_t v11 = 0;
    CFIndex Count = 0;
    *(void *)&long long v12 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v33 = v12;
    long long v32 = v12;
    long long v31 = v12;
    long long v30 = v12;
    long long v29 = v12;
    long long v28 = v12;
    long long v27 = v12;
    long long v26 = v12;
    long long v25 = v12;
    unint64_t v34 = &v19;
    long long v23 = v12;
    long long v24 = v12;
    long long v21 = v12;
    long long v22 = v12;
    long long v19 = v12;
    long long v20 = v12;
    long long v17 = 0;
    uint64_t v18 = 0;
    id values = 0;
  }
  CFSetGetValues(theSet, (const void **)v11);
  if (a2 && Count >= 2)
  {
    CFIndex v13 = values;
    id Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    v36.locatioCFIndex n = 0;
    v36.uint64_t length = 0;
    CFArrayReplaceValues((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), v36, (const void **)v13, Count);
    CFArrayRef explicit = (__CFArray *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
    v37.uint64_t length = CFArrayGetCount((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire));
    v37.locatioCFIndex n = 0;
    CFArraySortValues(explicit, v37, a2, a3);
    *a4 = (CFArrayRef)atomic_exchange((atomic_ullong *volatile)&Mutable, 0);
  }
  else
  {
    *a4 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)values, Count, MEMORY[0x1E4F1D510]);
  }
  id Mutable = &values;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&Mutable);
}

void CreateNormalizedPreferredLanguages(void *a1@<X8>)
{
  v3[4] = *MEMORY[0x1E4F143B8];
  CFArrayRef v2 = CFLocaleCopyPreferredLanguages();
  v3[0] = &unk_1ED05FFA8;
  v3[3] = v3;
  CreateCopyOfArrayByApplyingFunction(v2, (uint64_t)v3, a1);
  std::__function::__value_func<TCFRef<void const*> ()(void const*)>::~__value_func[abi:nn180100](v3);
}

void *std::__function::__value_func<TCFRef<void const*> ()(void const*)>::~__value_func[abi:nn180100](void *a1)
{
  CFArrayRef v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void CreateCopyOfArrayByApplyingFunction(const __CFArray *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  if (a1)
  {
    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    context[1] = a2;
    id v8 = Mutable;
    context[0] = &v8;
    v9.uint64_t length = CFArrayGetCount(a1);
    v9.locatioCFIndex n = 0;
    CFArrayApplyFunction(a1, v9, (CFArrayApplierFunction)CreateCopyOfArrayByApplyingFunction(__CFArray const*,std::function<TCFRef<void const*> ()(void const*)>)::$_0::__invoke, context);
    *a3 = atomic_exchange((atomic_ullong *volatile)&v8, 0);
  }
  else
  {
    *a3 = 0;
  }
}

CFArrayRef CTFontCopyAvailableTables(CTFontRef font, CTFontTableOptions options)
{
  if (!font) {
    return 0;
  }
  (*(void (**)(id *__return_ptr))(**(void **)(*((void *)font + 5) + 400) + 464))(&v4);
  CFArrayRef v2 = (const __CFArray *)atomic_exchange((atomic_ullong *volatile)&v4, 0);

  return v2;
}

void TBaseFont::CopyAvailableTables(TBaseFont *this@<X0>, void *a2@<X8>)
{
  InitializedGraphicsFont = (CGFont *)TBaseFont::GetInitializedGraphicsFont(this);
  id v14 = CGFontCopyTableTags(InitializedGraphicsFont);
  CFArrayRef v5 = (const __CFArray *)(id)atomic_load_explicit((atomic_ullong *volatile)&v14, memory_order_acquire);
  if (!v5)
  {

    goto LABEL_13;
  }
  CFArrayRef v6 = v5;
  uint64_t Count = CFArrayGetCount(v5);

  if (!Count)
  {
LABEL_13:
    *a2 = 0;
    goto LABEL_14;
  }
  id v13 = 0;
  int v8 = *((_DWORD *)this + 44);
  if (Count >= 1)
  {
    CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    unint64_t v10 = Count + 1;
    do
    {
      int ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v14, memory_order_acquire), v10 - 2);
      if ((TableFlagForIdentifier(ValueAtIndex) & v8) != 0)
      {
        if (!atomic_load_explicit((atomic_ullong *volatile)&v13, memory_order_acquire))
        {

          if (!atomic_load_explicit((atomic_ullong *volatile)&v13, memory_order_acquire)) {
            break;
          }
          id v12 = (id)atomic_load_explicit((atomic_ullong *volatile)&v13, memory_order_acquire);
          TCFRef<__CTFont const*>::Retain((atomic_ullong *)&v14, v12);
        }
        CFArrayRemoveValueAtIndex((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v13, memory_order_acquire), v10 - 2);
      }
      --v10;
    }
    while (v10 > 1);
  }
  *a2 = atomic_exchange((atomic_ullong *volatile)&v14, 0);

LABEL_14:
}

uint64_t IsGB18030ComplianceRequired(void)::$_0::__invoke()
{
  uint64_t result = MGGetBoolAnswer();
  _MergedGlobals_25 = result;
  return result;
}

dispatch_queue_t ___ZL32CTFontDescriptorGetMatchingQueuev_block_invoke()
{
  dispatch_queue_t result = dispatch_queue_create("com.apple.CoreText.fontdescriptorMatching", 0);
  qword_1EB2CE950 = (uint64_t)result;
  return result;
}

void CTRunGetBaseAdvancesAndOrigins(CTRunRef runRef, CFRange range, CGSize *advancesBuffer, CGPoint *originsBuffer)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  if (runRef)
  {
    locatioCFIndex n = range.location;
    uint64_t v7 = *((void *)runRef + 5);
    int v8 = *(void **)(v7 + 216);
    uint64_t v9 = v8[4];
    if (v9 || (uint64_t v13 = v8[3]) == 0)
    {
      uint64_t v10 = *(void *)(v7 + 200);
      uint64_t v11 = v9 + 16 * v10;
      uint64_t v12 = 2;
      if (!advancesBuffer) {
        goto LABEL_33;
      }
    }
    else
    {
      uint64_t v10 = *(void *)(v7 + 200);
      uint64_t v11 = v13 + 8 * v10;
      uint64_t v12 = 1;
      if (!advancesBuffer) {
        goto LABEL_33;
      }
    }
    if (originsBuffer)
    {
      uint64_t v46 = v12;
      CFIndex length = range.length;
      uint64_t v14 = *(void *)(v7 + 264);
      if ((*(unsigned char *)(v7 + 225) & 0x10) != 0)
      {
        CFRange v37 = operator new(0x30uLL);
        void *v37 = &unk_1ED05FFF0;
        v37[1] = advancesBuffer;
        v37[2] = v46;
        v37[3] = v11;
        v37[4] = originsBuffer;
        v37[5] = v7 + 192;
        uint64_t v54 = v37;
        uint64_t v38 = *(void *)(v7 + 208);
        uint64_t v39 = v8[2] + 2 * v10;
        if (length) {
          uint64_t v40 = length;
        }
        else {
          uint64_t v40 = *(void *)(v7 + 208);
        }
        uint64_t v41 = 0;
        if (v38 >= 1 && location >= 1)
        {
          CFIndex v43 = 0;
          do
          {
            if (v14 == v41 || *(__int16 *)(v39 + 2 * v41) != -1) {
              ++v43;
            }
            ++v41;
          }
          while (v41 < v38 && v43 < location);
        }
        long long v23 = v53;
        if (v41 < v38 && v40 >= 1)
        {
          uint64_t v45 = 0;
          do
          {
            if (v14 == v41 || *(unsigned __int16 *)(v39 + 2 * v41) != 0xFFFF) {
              std::function<void ()(long,long)>::operator()((uint64_t)v37, v41, v45++);
            }
            ++v41;
            long long v23 = v53;
          }
          while (v41 < v38 && v45 < v40);
        }
      }
      else
      {
        CFArrayRef v15 = operator new(0x28uLL);
        *CFArrayRef v15 = &unk_1ED060038;
        v15[1] = advancesBuffer;
        v15[2] = v46;
        _OWORD v15[3] = v11;
        v15[4] = originsBuffer;
        char v52 = v15;
        uint64_t v16 = *(void *)(v7 + 208);
        uint64_t v17 = v8[2] + 2 * v10;
        if (length) {
          uint64_t v18 = length;
        }
        else {
          uint64_t v18 = *(void *)(v7 + 208);
        }
        uint64_t v19 = 0;
        if (v16 >= 1 && location >= 1)
        {
          CFIndex v21 = 0;
          do
          {
            if (v14 == v19 || *(__int16 *)(v17 + 2 * v19) != -1) {
              ++v21;
            }
            ++v19;
          }
          while (v19 < v16 && v21 < location);
        }
        long long v23 = v51;
        if (v19 < v16 && v18 >= 1)
        {
          uint64_t v24 = 0;
          do
          {
            if (v14 == v19 || *(unsigned __int16 *)(v17 + 2 * v19) != 0xFFFF) {
              std::function<void ()(long,long)>::operator()((uint64_t)v15, v19, v24++);
            }
            ++v19;
            long long v23 = v51;
          }
          while (v19 < v16 && v24 < v18);
        }
      }
LABEL_80:
      std::__function::__value_func<void ()(long,long)>::~__value_func[abi:nn180100](v23);
      return;
    }
LABEL_33:
    uint64_t v25 = *(void *)(v7 + 264);
    uint64_t v47 = *(void *)(v7 + 216);
    CFIndex v26 = range.length;
    uint64_t v27 = v12;
    long long v28 = operator new(0x30uLL);
    *long long v28 = &unk_1ED060080;
    v28[1] = advancesBuffer;
    v28[2] = v27;
    v28[3] = v11;
    v28[4] = originsBuffer;
    v28[5] = v7 + 192;
    id v50 = v28;
    uint64_t v29 = *(void *)(v7 + 208);
    uint64_t v30 = *(void *)(v47 + 16) + 2 * v10;
    if (v26) {
      uint64_t v31 = v26;
    }
    else {
      uint64_t v31 = *(void *)(v7 + 208);
    }
    uint64_t v32 = 0;
    if (v29 >= 1 && location >= 1)
    {
      CFIndex v34 = 0;
      do
      {
        if (v25 == v32 || *(__int16 *)(v30 + 2 * v32) != -1) {
          ++v34;
        }
        ++v32;
      }
      while (v32 < v29 && v34 < location);
    }
    long long v23 = v49;
    if (v32 < v29 && v31 >= 1)
    {
      uint64_t v36 = 0;
      do
      {
        if (v25 == v32 || *(unsigned __int16 *)(v30 + 2 * v32) != 0xFFFF) {
          std::function<void ()(long,long)>::operator()((uint64_t)v28, v32, v36++);
        }
        ++v32;
        long long v23 = v49;
      }
      while (v32 < v29 && v36 < v31);
    }
    goto LABEL_80;
  }
}

void TBaseFont::SupportsConnectedLanguage(void)const::$_0::__invoke()
{
  __dst[38] = *(const void **)MEMORY[0x1E4F143B8];
  memcpy(__dst, off_1E528FD30, 0x130uLL);
  id v0 = CFSetCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], __dst, 38, MEMORY[0x1E4F1D548]);
  qword_1EB2CDAB8 = atomic_exchange((atomic_ullong *volatile)&v0, 0);
}

CGColorSpaceRef ___ZL14CopyEmojiImagejPKvmddPK8__CFDataP6CGSize_block_invoke()
{
  atomic_store((unint64_t)malloc_type_malloc(qword_1EB2CDFC8, 0x1BA38830uLL), (unint64_t *)&qword_1EB2CDFB8);
  CGColorSpaceRef result = CGColorSpaceCreateDeviceRGB();
  qword_1EB2CDFC0 = (uint64_t)result;
  return result;
}

void GetLanguageAwareOutsetIndexForFontName(__CFString const*,double &,double &,double &,double &,__CFString const*)::$_0::__invoke(uint64_t a1, uint64_t a2)
{
  MEMORY[0x1F4188790](a1, a2);
  memset(__b, 170, sizeof(__b));
  int64x2_t v2 = (int64x2_t)xmmword_184B7E240;
  uint64_t v3 = 0x1FFFFFFFFFFFFDAALL;
  int64x2_t v4 = vdupq_n_s64(2uLL);
  do
  {
    *(int64x2_t *)&__b[v3 + 598] = v2;
    int64x2_t v2 = vaddq_s64(v2, v4);
    v3 += 2;
  }
  while (v3 * 8);
  id v5 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)kPSFontNames, __b, 598, MEMORY[0x1E4F1D530], 0);
  _MergedGlobals_3 = atomic_exchange((atomic_ullong *volatile)&v5, 0);
}

uint64_t TCFBase<TFramesetter>::GetTypeID(void)::{lambda(void *)#1}::__invoke()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB2CDF10, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB2CDF10))
  {
    qword_1EB2CDF18 = 0;
    unk_1EB2CDF20 = "CTFramesetter";
    qword_1EB2CDF28 = 0;
    unk_1EB2CDF30 = 0;
    qword_1EB2CDF38 = (uint64_t)TCFBase<TFramesetter>::ClassDestruct;
    qword_1EB2CDF40 = (uint64_t)TCFBase<TFramesetter>::ClassEqual;
    qword_1EB2CDF48 = (uint64_t)TCFBase<TFramesetter>::ClassHash;
    unk_1EB2CDF50 = 0;
    qword_1EB2CDF58 = (uint64_t)TCFBase<TFramesetter>::ClassDebug;
    unk_1EB2CDF60 = 0;
    qword_1EB2CDF68 = 0;
    unk_1EB2CDF70 = 0;
    __cxa_guard_release(&qword_1EB2CDF10);
  }
  uint64_t result = _CFRuntimeRegisterClass();
  qword_1EB2CDF08 = result;
  return result;
}

uint64_t TCFBase<TFrame>::CreateTypeID()
{
  {
    TCFBase<TFrame>::CreateTypeID(void)::runtimeunsigned int Class = 0;
    *(void *)algn_1EB2CD7A8 = "CTFrame";
    qword_1EB2CD7B0 = 0;
    unk_1EB2CD7B8 = 0;
    qword_1EB2CD7C0 = (uint64_t)TCFBase<TFrame>::ClassDestruct;
    qword_1EB2CD7C8 = (uint64_t)TCFBase<TFrame>::ClassEqual;
    qword_1EB2CD7D0 = (uint64_t)TCFBase<TFrame>::ClassHash;
    unk_1EB2CD7D8 = 0;
    qword_1EB2CD7E0 = (uint64_t)TCFBase<TFrame>::ClassDebug;
    unk_1EB2CD7E8 = 0;
    qword_1EB2CD7F0 = 0;
    unk_1EB2CD7F8 = 0;
  }
  uint64_t result = _CFRuntimeRegisterClass();
  TCFBase<TFrame>::fCFTypeID TypeID = result;
  return result;
}

uint64_t TCFBase<TNativeTextTab>::CreateTypeID()
{
  {
    TCFBase<TNativeTextTab>::CreateTypeID(void)::runtimeunsigned int Class = 0;
    *(void *)algn_1EB2CD818 = "CTTextTab";
    qword_1EB2CD820 = 0;
    unk_1EB2CD828 = 0;
    qword_1EB2CD830 = (uint64_t)TCFBase<TNativeTextTab>::ClassDestruct;
    qword_1EB2CD838 = (uint64_t)TCFBase<TNativeTextTab>::ClassEqual;
    qword_1EB2CD840 = (uint64_t)TCFBase<TNativeTextTab>::ClassHash;
    unk_1EB2CD848 = 0;
    qword_1EB2CD850 = (uint64_t)TCFBase<TNativeTextTab>::ClassDebug;
    unk_1EB2CD858 = 0;
    qword_1EB2CD860 = 0;
    unk_1EB2CD868 = 0;
  }
  uint64_t result = _CFRuntimeRegisterClass();
  TCFBase<TNativeTextTab>::fCFTypeID TypeID = result;
  return result;
}

void *CTFontGetLanguageAwareOutsetsForLanguage(void *result, double *a2, double *a3, double *a4, double *a5)
{
  if (result)
  {
    uint64_t v5 = result[5];
    if (*(unsigned char *)v5)
    {
      return 0;
    }
    else
    {
      uint64_t result = *(void **)(v5 + 400);
      if (result)
      {
        double v13 = NAN;
        double v14 = NAN;
        double v11 = NAN;
        double v12 = NAN;
        double v10 = *(double *)(v5 + 16);
        uint64_t result = (void *)(*(uint64_t (**)(void *, double *, double *, double *, double *, double))(*result + 888))(result, &v14, &v13, &v12, &v11, v10);
        if (result)
        {
          if (a2) {
            *a2 = v10 * v14;
          }
          if (a3) {
            *a3 = v10 * v13;
          }
          if (a4) {
            *a4 = v10 * v12;
          }
          if (a5) {
            *a5 = v10 * v11;
          }
        }
      }
    }
  }
  return result;
}

uint64_t TComponentFont::GetLanguageAwareOutsets(atomic_ullong *this, double a2, double *a3, double *a4, double *a5, double *a6, __CFString *a7)
{
  uint64_t LanguageAwareOutsets = TBaseFont::GetLanguageAwareOutsets(this, a2, a3, a4, a5, a6, a7);
  if (LanguageAwareOutsets && (*(unsigned int (**)(atomic_ullong *))(*this + 784))(this))
  {
    double LanguageAwareAdjustRatio = GetLanguageAwareAdjustRatio();
    CFNumberRef ComponentAttribute = (const __CFNumber *)TComponentFont::GetComponentAttribute(this, @"languageAwareLineHeightRatio");
    if (ComponentAttribute)
    {
      uint64_t valuePtr = -1;
      CFNumberGetValue(ComponentAttribute, kCFNumberDoubleType, &valuePtr);
      double LanguageAwareAdjustRatio = *(double *)&valuePtr;
    }
    *a4 = *a4 - LanguageAwareAdjustRatio * *a4;
    *a6 = *a6 - LanguageAwareAdjustRatio * *a6;
  }
  return LanguageAwareOutsets;
}

uint64_t TBaseFont::GetLanguageAwareOutsets(atomic_ullong *this, double a2, double *a3, double *a4, double *a5, double *a6, __CFString *a7)
{
  CFStringRef explicit = (const __CFString *)atomic_load_explicit(this + 12, memory_order_acquire);
  if (explicit && (GetLanguageAwareOutsetIndexForFontName(explicit, a3, a4, a5, a6, a7) & 1) != 0) {
    return 1;
  }
  uint64_t result = atomic_load_explicit(this + 30, memory_order_acquire);
  if (result || (uint64_t result = TBaseFont::CreateTraitsValues((TBaseFont *)this)) != 0)
  {
    unsigned int v14 = __const__Z19LocalTraitForWeightdd_kWeightTraits[(unsigned __int16)IndexesBracketing<double const*,double>(kCTFontDefaultWeights, (double *)&kCTFontWeightRegular, *(double *)(result + 8), 0.001)];
    if (v14 >= 0x11) {
      unsigned int v14 = 17;
    }
    CFStringRef v15 = kFont2X[5 * v14];
    return GetLanguageAwareOutsetIndexForFontName(v15, a3, a4, a5, a6, 0);
  }
  return result;
}

uint64_t GetLanguageAwareOutsetIndexForFontName(const __CFString *a1, double *a2, double *a3, double *a4, double *a5, __CFString *a6)
{
  if (qword_1EB2CDE78 != -1) {
    dispatch_once_f(&qword_1EB2CDE78, 0, (dispatch_function_t)GetLanguageAwareOutsetIndexForFontName(__CFString const*,double &,double &,double &,double &,__CFString const*)::$_0::__invoke);
  }
  int v12 = _ExuberatedGroupForPreferredLanguages(0, 0);
  CFNumberRef Value = CFDictionaryGetValue((CFDictionaryRef)_MergedGlobals_3, a1);
  if (Value) {
    BOOL v14 = (unint64_t)Value >= 0x257;
  }
  else {
    BOOL v14 = 1;
  }
  uint64_t v15 = !v14;
  if (v15 == 1)
  {
    uint64_t v16 = Value;
    if (v12 == 4) {
      uint64_t v17 = (char *)&kLanguageAwareOutsetsTableUrdu;
    }
    else {
      uint64_t v17 = (char *)&kLanguageAwareOutsetsTable;
    }
    if (!a6) {
      goto LABEL_23;
    }
    id v23 = (id)0xAAAAAAAAAAAAAAAALL;
    LanguageIdentifierByNormalizing(a6, 0, (atomic_ullong *)&v23);
    uint64_t v18 = (__CFString *)(id)atomic_load_explicit((atomic_ullong *volatile)&v23, memory_order_acquire);
    uint64_t v19 = v18;
    if (v18 == @"ur")
    {
    }
    else
    {
      if (!v18)
      {

LABEL_21:
        uint64_t v17 = (char *)&kLanguageAwareOutsetsTable;
        goto LABEL_22;
      }
      int v20 = CFEqual(v18, @"ur");

      if (!v20) {
        goto LABEL_21;
      }
    }
    uint64_t v17 = (char *)&kLanguageAwareOutsetsTableUrdu;
LABEL_22:

LABEL_23:
    CFIndex v21 = (double *)&v17[32 * (void)v16];
    *a2 = *(v21 - 4);
    *a3 = *(v21 - 2);
    *a4 = *(v21 - 3);
    *a5 = *(v21 - 1);
  }
  return v15;
}

void ___Z20MakeSpliceDescriptorPK10__CFStringmS1_S1_PK10__CFNumberS4_j23CTFontTextStylePlatformjS4_S4_22CTFontLegibilityWeightPK11__CFBooleanPKvS1__block_invoke()
{
  keys[4] = *(void **)MEMORY[0x1E4F143B8];
  keys[0] = @"NSCTFontUIFontDesignSerif";
  keys[1] = @"NSCTFontUIFontDesignMonospaced";
  keys[2] = @"NSCTFontUIFontDesignCompact";
  keys[3] = @"NSCTFontUIFontDesignCore";
  *(_OWORD *)id values = xmmword_1E528D210;
  long long v2 = *(_OWORD *)off_1E528D220;
  id v0 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)keys, (const void **)values, 4, MEMORY[0x1E4F1D530], 0);
  qword_1EB2CDB50 = atomic_exchange((atomic_ullong *volatile)&v0, 0);
}

CFSetRef TDescriptorSource::GetMatchableAttributes(void)::$_0::__invoke()
{
  values[18] = *(void **)MEMORY[0x1E4F143B8];
  values[0] = @"NSCTFontPostScriptNameAttribute";
  values[1] = @"NSFontNameAttribute";
  values[2] = @"NSFontVisibleNameAttribute";
  values[3] = @"NSFontFamilyAttribute";
  values[4] = @"NSFontFaceAttribute";
  values[5] = @"NSCTFontUIUsageAttribute";
  values[6] = @"NSCTFontFileURLAttribute";
  values[7] = @"NSCTFontTraitsAttribute";
  values[8] = @"NSCTFontCharacterSetAttribute";
  values[9] = @"NSCTFontLanguagesAttribute";
  values[10] = @"NSCTFontDesignLanguagesAttribute";
  values[11] = @"NSCTFontFormatAttribute";
  values[12] = @"NSCTFontRegistrationScopeAttribute";
  values[13] = @"NSCTFontPriorityAttribute";
  values[14] = @"NSCTFontDomainAttribute";
  values[15] = @"NSCTFontDownloadedAttribute";
  values[16] = @"NSCTFontUserInstalledAttribute";
  values[17] = @"CTFontDownloadableStubAttribute";
  CFSetRef result = CFSetCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)values, 18, MEMORY[0x1E4F1D548]);
  qword_1EB2CE1C8 = (uint64_t)result;
  return result;
}

CFTypeID TAttributes::HandleForegroundColorFromContextAttribute(CFTypeID result, uint64_t a2)
{
  if (result)
  {
    CFNumberRef v3 = (const __CFNumber *)result;
    CFTypeID v4 = CFGetTypeID((CFTypeRef)result);
    if (v4 == CFNumberGetTypeID() || v4 == CFBooleanGetTypeID())
    {
      unsigned int valuePtr = -1431655766;
      CFNumberGetValue(v3, kCFNumberIntType, &valuePtr);
      CFSetRef result = valuePtr;
      if (!valuePtr) {
        return result;
      }
      goto LABEL_5;
    }
    CFSetRef result = CFStringGetTypeID();
    if (v4 == result)
    {
      CFSetRef result = CFStringGetIntValue((CFStringRef)v3);
      if (result) {
LABEL_5:
      }
        *(unsigned char *)(*(void *)a2 + 136) |= 1u;
    }
  }
  return result;
}

id ___Z29UIFontNameForUITypeDictionaryv_block_invoke()
{
  v2[274] = *MEMORY[0x1E4F143B8];
  v1[0] = &unk_1ED080A90;
  v1[1] = &unk_1ED080AA8;
  v2[0] = @".AppleSystemUIFont";
  v2[1] = @".AppleSystemUIFontEmphasized";
  v1[2] = &unk_1ED080B80;
  v1[3] = &unk_1ED080B98;
  v2[2] = @".AppleSystemUIFontItalic";
  v2[3] = @".AppleSystemUIFontEmphasizedItalic";
  v1[4] = &unk_1ED081B10;
  v1[5] = &unk_1ED081B28;
  v2[4] = @".AppleSystemUIFaceCaption3";
  v2[5] = @".AppleSystemUIFaceEmphasizedCaption3";
  v1[6] = &unk_1ED080AC0;
  v1[7] = &unk_1ED080AD8;
  v2[6] = @".AppleSystemUIFaceHeadline";
  v2[7] = @".AppleSystemUIFaceShortHeadline";
  v1[8] = &unk_1ED080BB0;
  v1[9] = &unk_1ED080BC8;
  v2[8] = @".AppleSystemUIFaceHeadline2";
  v2[9] = @".AppleSystemUIFaceItalicHeadline2";
  v1[10] = &unk_1ED080BE0;
  v1[11] = &unk_1ED080BF8;
  v2[10] = @".AppleSystemUIFaceShortHeadline2";
  v2[11] = @".AppleSystemUIFaceShortItalicHeadline2";
  v1[12] = &unk_1ED080C10;
  v1[13] = &unk_1ED080C28;
  v2[12] = @".AppleSystemUIFaceEmphasizedBody";
  v2[13] = @".AppleSystemUIFaceBody";
  v1[14] = &unk_1ED080C40;
  v1[15] = &unk_1ED080C58;
  v2[14] = @".AppleSystemUIFaceEmphasizedItalicBody";
  v2[15] = @".AppleSystemUIFaceItalicBody";
  v1[16] = &unk_1ED080C70;
  v1[17] = &unk_1ED080C88;
  v2[16] = @".AppleSystemUIFaceShortEmphasizedBody";
  v2[17] = @".AppleSystemUIFaceShortBody";
  v1[18] = &unk_1ED080CA0;
  v1[19] = &unk_1ED080CB8;
  v2[18] = @".AppleSystemUIFaceShortEmphasizedItalicBody";
  v2[19] = @".AppleSystemUIFaceShortItalicBody";
  v1[20] = &unk_1ED080AF0;
  v1[21] = &unk_1ED080B08;
  v2[20] = @".AppleSystemUIFaceEmphasizedSubhead";
  v2[21] = @".AppleSystemUIFaceSubhead";
  v1[22] = &unk_1ED080B20;
  v1[23] = &unk_1ED080B38;
  v2[22] = @".AppleSystemUIFaceItalicSubhead";
  v2[23] = @".AppleSystemUIFaceShortEmphasizedSubhead";
  v1[24] = &unk_1ED080B50;
  v1[25] = &unk_1ED080B68;
  v2[24] = @".AppleSystemUIFaceShortSubhead";
  v2[25] = @".AppleSystemUIFaceShortItalicSubhead";
  v1[26] = &unk_1ED080CD0;
  v1[27] = &unk_1ED080CE8;
  v2[26] = @".AppleSystemUIFaceEmphasizedSubhead2";
  v2[27] = @".AppleSystemUIFaceSubhead2";
  v1[28] = &unk_1ED080D00;
  v1[29] = &unk_1ED080D18;
  v2[28] = @".AppleSystemUIFaceItalicSubhead2";
  v2[29] = @".AppleSystemUIFaceShortEmphasizedSubhead2";
  v1[30] = &unk_1ED080D30;
  v1[31] = &unk_1ED080D48;
  v2[30] = @".AppleSystemUIFaceShortSubhead2";
  v2[31] = @".AppleSystemUIFaceShortItalicSubhead2";
  v1[32] = &unk_1ED080D60;
  v1[33] = &unk_1ED080D78;
  v2[32] = @".AppleSystemUIFaceEmphasizedFootnote";
  v2[33] = @".AppleSystemUIFaceFootnote";
  v1[34] = &unk_1ED080D90;
  v1[35] = &unk_1ED080DA8;
  v2[34] = @".AppleSystemUIFaceItalicFootnote";
  v2[35] = @".AppleSystemUIFaceShortEmphasizedFootnote";
  v1[36] = &unk_1ED080DC0;
  v1[37] = &unk_1ED080DD8;
  v2[36] = @".AppleSystemUIFaceShortFootnote";
  v2[37] = @".AppleSystemUIFaceShortItalicFootnote";
  v1[38] = &unk_1ED080DF0;
  v1[39] = &unk_1ED080E08;
  v2[38] = @".AppleSystemUIFaceEmphasizedCaption1";
  v2[39] = @".AppleSystemUIFaceCaption1";
  v1[40] = &unk_1ED080E20;
  v1[41] = &unk_1ED080E38;
  v2[40] = @".AppleSystemUIFaceItalicCaption1";
  v2[41] = @".AppleSystemUIFaceShortEmphasizedCaption1";
  v1[42] = &unk_1ED080E50;
  v1[43] = &unk_1ED080E68;
  v2[42] = @".AppleSystemUIFaceShortCaption1";
  v2[43] = @".AppleSystemUIFaceShortItalicCaption1";
  v1[44] = &unk_1ED080E80;
  v1[45] = &unk_1ED080E98;
  v2[44] = @".AppleSystemUIFaceEmphasizedCaption2";
  v2[45] = @".AppleSystemUIFaceCaption2";
  v1[46] = &unk_1ED080EB0;
  v1[47] = &unk_1ED080EC8;
  v2[46] = @".AppleSystemUIFaceItalicCaption2";
  v2[47] = @".AppleSystemUIFaceTallEmphasizedBody";
  v1[48] = &unk_1ED080EE0;
  v1[49] = &unk_1ED080EF8;
  v2[48] = @".AppleSystemUIFaceTallBody";
  v2[49] = @".AppleSystemUIFaceTallEmphasizedItalicBody";
  v1[50] = &unk_1ED080F10;
  v1[51] = &unk_1ED080F28;
  v2[50] = @".AppleSystemUIFaceTallItalicBody";
  v2[51] = @".AppleSystemUIFaceItalicHeadline";
  v1[52] = &unk_1ED080F40;
  v1[53] = &unk_1ED080F58;
  v2[52] = @".AppleSystemUIFaceShortItalicHeadline";
  v2[53] = @".AppleSystemUIFontThin";
  v1[54] = &unk_1ED080F70;
  v1[55] = &unk_1ED080F88;
  v2[54] = @".AppleSystemUIFontLight";
  v2[55] = @".AppleSystemUIFontUltraLight";
  v1[56] = &unk_1ED080FA0;
  v1[57] = &unk_1ED080FB8;
  v2[56] = @".AppleSystemUIFontMedium";
  v2[57] = @".AppleSystemUIFontDemi";
  v1[58] = &unk_1ED080FD0;
  v1[59] = &unk_1ED080FE8;
  v2[58] = @".AppleSystemUIFontBold";
  v2[59] = @".AppleSystemUIFontHeavy";
  v1[60] = &unk_1ED081000;
  v1[61] = &unk_1ED081018;
  v2[60] = @".AppleSystemUIFontBlack";
  v2[61] = @".AppleSystemUIFaceCallout";
  v1[62] = &unk_1ED081030;
  v1[63] = &unk_1ED081048;
  v2[62] = @".AppleSystemUIFaceItalicCallout";
  v2[63] = @".AppleSystemUIFaceEmphasizedCallout";
  v1[64] = &unk_1ED081060;
  v2[64] = @".AppleSystemUIFaceEmphasizedItalicCallout";
  v1[65] = &unk_1ED081078;
  v2[65] = @".AppleSystemUIFaceShortCallout";
  v1[66] = &unk_1ED081090;
  v2[66] = @".AppleSystemUIFaceShortItalicCallout";
  v1[67] = &unk_1ED0810A8;
  v2[67] = @".AppleSystemUIFaceShortEmphasizedCallout";
  v1[68] = &unk_1ED0810C0;
  v2[68] = @".AppleSystemUIFaceShortEmphasizedItalicCallout";
  v1[69] = &unk_1ED0810D8;
  v2[69] = @".AppleSystemUIFaceTallCallout";
  v1[70] = &unk_1ED0810F0;
  v2[70] = @".AppleSystemUIFaceTallItalicCallout";
  v1[71] = &unk_1ED081108;
  v2[71] = @".AppleSystemUIFaceTallEmphasizedCallout";
  v1[72] = &unk_1ED081120;
  v2[72] = @".AppleSystemUIFaceTallEmphasizedItalicCallout";
  v1[73] = &unk_1ED081138;
  v2[73] = @".AppleSystemUIFaceEmphasizedFootnote2";
  v1[74] = &unk_1ED081150;
  v2[74] = @".AppleSystemUIFaceFootnote2";
  v1[75] = &unk_1ED081168;
  v2[75] = @".AppleSystemUIFaceItalicFootnote2";
  v1[76] = &unk_1ED081180;
  v2[76] = @".AppleSystemUIFaceShortEmphasizedFootnote2";
  v1[77] = &unk_1ED081198;
  v2[77] = @".AppleSystemUIFaceShortFootnote2";
  v1[78] = &unk_1ED0811B0;
  v2[78] = @".AppleSystemUIFaceShortItalicFootnote2";
  v1[79] = &unk_1ED0811C8;
  v2[79] = @".AppleSystemUIFaceShortEmphasizedCaption2";
  v1[80] = &unk_1ED0811E0;
  v2[80] = @".AppleSystemUIFaceShortCaption2";
  v1[81] = &unk_1ED0811F8;
  v2[81] = @".AppleSystemUIFaceShortItalicCaption2";
  v1[82] = &unk_1ED081210;
  v2[82] = @".AppleSystemUIFontThinItalic";
  v1[83] = &unk_1ED081228;
  v2[83] = @".AppleSystemUIFontLightItalic";
  v1[84] = &unk_1ED081240;
  v2[84] = @".AppleSystemUIFontUltraLightItalic";
  v1[85] = &unk_1ED081258;
  v2[85] = @".AppleSystemUIFontMediumItalic";
  v1[86] = &unk_1ED081270;
  v2[86] = @".AppleSystemUIFontDemiItalic";
  v1[87] = &unk_1ED081288;
  v2[87] = @".AppleSystemUIFontBoldItalic";
  v1[88] = &unk_1ED0812A0;
  v2[88] = @".AppleSystemUIFontHeavyItalic";
  v1[89] = &unk_1ED0812B8;
  v2[89] = @".AppleSystemUIFontBlackItalic";
  v1[90] = &unk_1ED0812D0;
  v2[90] = @".AppleSystemUIFontUltraLightAlways";
  v1[91] = &unk_1ED0812E8;
  v2[91] = @".AppleSystemUIFontThinAlways";
  v1[92] = &unk_1ED081300;
  v2[92] = @".AppleSystemUIFontCompact-Regular";
  v1[93] = &unk_1ED081318;
  v2[93] = @".AppleSystemUIFontCompact-Bold";
  v1[94] = &unk_1ED081330;
  v2[94] = @".AppleSystemUIFontCompact-Thin";
  v1[95] = &unk_1ED081348;
  v2[95] = @".AppleSystemUIFontCompact-Light";
  v1[96] = &unk_1ED081360;
  v2[96] = @".AppleSystemUIFontCompact-UltraLight";
  v1[97] = &unk_1ED081378;
  v2[97] = @".AppleSystemUIFontCompact-Medium";
  v1[98] = &unk_1ED081390;
  v2[98] = @".AppleSystemUIFontCompact-Semibold";
  v1[99] = &unk_1ED0813A8;
  v2[99] = @".AppleSystemUIFontCompact-Heavy";
  v1[100] = &unk_1ED0813C0;
  v2[100] = @".AppleSystemUIFontCompact-Black";
  v1[101] = &unk_1ED0813D8;
  v2[101] = @".AppleSystemUIFontCompact-Italic";
  v1[102] = &unk_1ED0813F0;
  v2[102] = @".AppleSystemUIFontCompact-BoldItalic";
  v1[103] = &unk_1ED081408;
  v2[103] = @".AppleSystemUIFontCompact-ThinItalic";
  v1[104] = &unk_1ED081420;
  v2[104] = @".AppleSystemUIFontCompact-LightItalic";
  v1[105] = &unk_1ED081438;
  v2[105] = @".AppleSystemUIFontCompact-UltraLightItalic";
  v1[106] = &unk_1ED081450;
  v2[106] = @".AppleSystemUIFontCompact-MediumItalic";
  v1[107] = &unk_1ED081468;
  v2[107] = @".AppleSystemUIFontCompact-SemiboldItalic";
  v1[108] = &unk_1ED081480;
  v2[108] = @".AppleSystemUIFontCompact-HeavyItalic";
  v1[109] = &unk_1ED081498;
  v2[109] = @".AppleSystemUIFontCompact-BlackItalic";
  v1[110] = &unk_1ED0814B0;
  v2[110] = @".AppleSystemUIFontRounded-Ultralight";
  v1[111] = &unk_1ED0814C8;
  v2[111] = @".AppleSystemUIFontRounded-Thin";
  v1[112] = &unk_1ED0814E0;
  v2[112] = @".AppleSystemUIFontRounded-Light";
  v1[113] = &unk_1ED0814F8;
  v2[113] = @".AppleSystemUIFontRounded-Regular";
  v1[114] = &unk_1ED081510;
  v2[114] = @".AppleSystemUIFontRounded-Medium";
  v1[115] = &unk_1ED081528;
  v2[115] = @".AppleSystemUIFontRounded-Semibold";
  v1[116] = &unk_1ED081540;
  v2[116] = @".AppleSystemUIFontRounded-Bold";
  v1[117] = &unk_1ED081558;
  v2[117] = @".AppleSystemUIFontRounded-Heavy";
  v1[118] = &unk_1ED081570;
  v2[118] = @".AppleSystemUIFontRounded-Black";
  v1[119] = &unk_1ED081588;
  v2[119] = @".AppleSystemUIFaceTitle1";
  v1[120] = &unk_1ED0815A0;
  v2[120] = @".AppleSystemUIFaceItalicTitle1";
  v1[121] = &unk_1ED0815B8;
  v2[121] = @".AppleSystemUIFaceEmphasizedTitle1";
  v1[122] = &unk_1ED0815D0;
  v2[122] = @".AppleSystemUIFaceEmphasizedItalicTitle1";
  v1[123] = &unk_1ED0815E8;
  v2[123] = @".AppleSystemUIFaceShortTitle1";
  v1[124] = &unk_1ED081600;
  v2[124] = @".AppleSystemUIFaceShortItalicTitle1";
  v1[125] = &unk_1ED081618;
  v2[125] = @".AppleSystemUIFaceShortEmphasizedTitle1";
  v1[126] = &unk_1ED081630;
  v1[145] = &unk_1ED0817F8;
  v1[144] = &unk_1ED0817E0;
  v2[144] = @".AppleSystemUIFaceItalicTitle3";
  v1[143] = &unk_1ED0817C8;
  v2[143] = @".AppleSystemUIFaceTitle3";
  v1[142] = &unk_1ED0817B0;
  v2[142] = @".AppleSystemUIFaceTallEmphasizedItalicTitle2";
  v1[141] = &unk_1ED081798;
  v2[141] = @".AppleSystemUIFaceTallEmphasizedTitle2";
  v1[140] = &unk_1ED081780;
  v2[140] = @".AppleSystemUIFaceTallItalicTitle2";
  v1[139] = &unk_1ED081768;
  v2[139] = @".AppleSystemUIFaceTallTitle2";
  v1[138] = &unk_1ED081750;
  v2[138] = @".AppleSystemUIFaceShortEmphasizedItalicTitle2";
  v1[137] = &unk_1ED081738;
  v2[137] = @".AppleSystemUIFaceShortEmphasizedTitle2";
  v1[136] = &unk_1ED081720;
  v2[136] = @".AppleSystemUIFaceShortItalicTitle2";
  v1[135] = &unk_1ED081708;
  v2[135] = @".AppleSystemUIFaceShortTitle2";
  v1[134] = &unk_1ED0816F0;
  v2[134] = @".AppleSystemUIFaceEmphasizedItalicTitle2";
  v1[133] = &unk_1ED0816D8;
  v2[133] = @".AppleSystemUIFaceEmphasizedTitle2";
  v1[132] = &unk_1ED0816C0;
  v2[132] = @".AppleSystemUIFaceItalicTitle2";
  v1[131] = &unk_1ED0816A8;
  v2[131] = @".AppleSystemUIFaceTitle2";
  v1[130] = &unk_1ED081690;
  v2[130] = @".AppleSystemUIFaceTallEmphasizedItalicTitle1";
  v1[129] = &unk_1ED081678;
  v2[129] = @".AppleSystemUIFaceTallEmphasizedTitle1";
  v1[128] = &unk_1ED081660;
  v2[128] = @".AppleSystemUIFaceTallItalicTitle1";
  v1[127] = &unk_1ED081648;
  v2[127] = @".AppleSystemUIFaceTallTitle1";
  v2[126] = @".AppleSystemUIFaceShortEmphasizedItalicTitle1";
  v2[145] = @".AppleSystemUIFaceEmphasizedTitle3";
  v1[146] = &unk_1ED081810;
  v2[146] = @".AppleSystemUIFaceEmphasizedItalicTitle3";
  v1[147] = &unk_1ED081828;
  v2[147] = @".AppleSystemUIFaceShortTitle3";
  v1[148] = &unk_1ED081840;
  v2[148] = @".AppleSystemUIFaceShortItalicTitle3";
  v1[149] = &unk_1ED081858;
  v2[149] = @".AppleSystemUIFaceShortEmphasizedTitle3";
  v1[150] = &unk_1ED081870;
  v2[150] = @".AppleSystemUIFaceShortEmphasizedItalicTitle3";
  v1[151] = &unk_1ED081888;
  v2[151] = @".AppleSystemUIFaceTallTitle3";
  v1[152] = &unk_1ED0818A0;
  v2[152] = @".AppleSystemUIFaceTallItalicTitle3";
  v1[153] = &unk_1ED0818B8;
  v2[153] = @".AppleSystemUIFaceTallEmphasizedTitle3";
  v1[154] = &unk_1ED0818D0;
  v2[154] = @".AppleSystemUIFaceTallEmphasizedItalicTitle3";
  v1[155] = &unk_1ED0818E8;
  v2[155] = @".AppleSystemUIFaceSubtitle3";
  v1[156] = &unk_1ED081900;
  v2[156] = @".AppleSystemUIFaceSubtitle2";
  v1[157] = &unk_1ED081918;
  v2[157] = @".AppleSystemUIFaceSubtitle1";
  v1[158] = &unk_1ED081930;
  v2[158] = @".AppleSystemUIFaceSection1";
  v1[159] = &unk_1ED081948;
  v2[159] = @".AppleSystemUIFaceSection2";
  v1[160] = &unk_1ED081960;
  v2[160] = @".AppleSystemUIFaceSection3";
  v1[161] = &unk_1ED081978;
  v2[161] = @".AppleSystemUIFaceTitle4";
  v1[162] = &unk_1ED081990;
  v2[162] = @".AppleSystemUIFaceHeadline3";
  v1[163] = &unk_1ED0819A8;
  v2[163] = @".AppleSystemUIFaceItalicSubtitle1";
  v1[164] = &unk_1ED0819C0;
  v2[164] = @".AppleSystemUIFaceEmphasizedSubtitle1";
  v1[165] = &unk_1ED0819D8;
  v2[165] = @".AppleSystemUIFaceEmphasizedItalicSubtitle1";
  v1[166] = &unk_1ED0819F0;
  v2[166] = @".AppleSystemUIFaceTitle0";
  v1[167] = &unk_1ED081A08;
  v2[167] = @".AppleSystemUIFaceEmphasizedTitle0";
  v1[168] = &unk_1ED081A20;
  v2[168] = @".AppleSystemUIFaceShortTitle0";
  v1[169] = &unk_1ED081A38;
  v2[169] = @".AppleSystemUIFaceShortEmphasizedTitle0";
  v1[170] = &unk_1ED081A50;
  v2[170] = @".AppleSystemUIFaceTallTitle0";
  v1[171] = &unk_1ED081A68;
  v2[171] = @".AppleSystemUIFaceTallEmphasizedTitle0";
  v1[172] = &unk_1ED081A80;
  v2[172] = @".AppleSystemUIFaceEmphasizedHeadline";
  v1[173] = &unk_1ED081A98;
  v2[173] = @".AppleSystemUIFaceEmphasizedItalicHeadline";
  v1[174] = &unk_1ED081AB0;
  v2[174] = @".AppleSystemUIFaceShortEmphasizedHeadline";
  v1[175] = &unk_1ED081AC8;
  v2[175] = @".AppleSystemUIFaceShortEmphasizedItalicHeadline";
  v1[176] = &unk_1ED081AE0;
  v2[176] = @".AppleSystemUIFaceTallHeadline";
  v1[177] = &unk_1ED081AF8;
  v2[177] = @".AppleSystemUIFaceTallEmphasizedHeadline";
  v1[178] = &unk_1ED081C18;
  v2[178] = @".AppleSystemUIFontSerif-Regular";
  v1[179] = &unk_1ED081C30;
  v2[179] = @".AppleSystemUIFontSerif-Medium";
  v1[180] = &unk_1ED081C48;
  v2[180] = @".AppleSystemUIFontSerif-Semibold";
  v1[181] = &unk_1ED081C60;
  v2[181] = @".AppleSystemUIFontSerif-Bold";
  v1[182] = &unk_1ED081C78;
  v2[182] = @".AppleSystemUIFontSerif-Heavy";
  v1[183] = &unk_1ED081C90;
  v2[183] = @".AppleSystemUIFontSerif-Black";
  v1[184] = &unk_1ED081CA8;
  v2[184] = @".AppleSystemUIFontSerif-Italic";
  v1[185] = &unk_1ED081CC0;
  v2[185] = @".AppleSystemUIFontSerif-MediumItalic";
  v1[186] = &unk_1ED081CD8;
  v2[186] = @".AppleSystemUIFontSerif-SemiboldItalic";
  v1[187] = &unk_1ED081CF0;
  v2[187] = @".AppleSystemUIFontSerif-BoldItalic";
  v1[188] = &unk_1ED081D08;
  v2[188] = @".AppleSystemUIFontSerif-HeavyItalic";
  v1[189] = &unk_1ED081D20;
  v2[189] = @".AppleSystemUIFontSerif-BlackItalc";
  v1[190] = &unk_1ED081D38;
  v2[190] = @".AppleSystemUIFontMonospaced-Light";
  v1[191] = &unk_1ED081D50;
  v2[191] = @".AppleSystemUIFontMonospaced-Regular";
  v1[192] = &unk_1ED081D68;
  v2[192] = @".AppleSystemUIFontMonospaced-Medium";
  v1[193] = &unk_1ED081D80;
  v2[193] = @".AppleSystemUIFontMonospaced-Semibold";
  v1[194] = &unk_1ED081D98;
  v2[194] = @".AppleSystemUIFontMonospaced-Bold";
  v1[195] = &unk_1ED081DB0;
  v2[195] = @".AppleSystemUIFontMonospaced-Heavy";
  v1[196] = &unk_1ED081DC8;
  v2[196] = @".AppleSystemUIFontMonospaced-LightItalic";
  v1[197] = &unk_1ED081DE0;
  v2[197] = @".AppleSystemUIFontMonospaced-RegularItalic";
  v1[198] = &unk_1ED081DF8;
  v2[198] = @".AppleSystemUIFontMonospaced-MediumItalic";
  v1[199] = &unk_1ED081E10;
  v2[199] = @".AppleSystemUIFontMonospaced-SemiboldItalic";
  v1[200] = &unk_1ED081E28;
  v2[200] = @".AppleSystemUIFontMonospaced-BoldItalic";
  v1[201] = &unk_1ED081E40;
  v2[201] = @".AppleSystemUIFontMonospaced-HeavyItalic";
  v1[202] = &unk_1ED081B40;
  v2[202] = @".AppleSystemUIFontCondensed-Regular";
  v1[203] = &unk_1ED081B58;
  v2[203] = @".AppleSystemUIFontCondensed-Bold";
  v1[204] = &unk_1ED081B70;
  v2[204] = @".AppleSystemUIFontCondensed-Thin";
  v1[205] = &unk_1ED081B88;
  v2[205] = @".AppleSystemUIFontCondensed-Light";
  v1[206] = &unk_1ED081BA0;
  v2[206] = @".AppleSystemUIFontCondensed-UltraLight";
  v1[207] = &unk_1ED081BB8;
  v2[207] = @".AppleSystemUIFontCondensed-Medium";
  v1[208] = &unk_1ED081BD0;
  v2[208] = @".AppleSystemUIFontCondensed-Semibold";
  v1[209] = &unk_1ED081BE8;
  v2[209] = @".AppleSystemUIFontCondensed-Heavy";
  v1[210] = &unk_1ED081C00;
  v2[210] = @".AppleSystemUIFontCondensed-Black";
  v1[211] = &unk_1ED081E58;
  v2[211] = @".AppleSystemUIFaceExtraLargeTitle";
  v1[212] = &unk_1ED081E70;
  v2[212] = @".AppleSystemUIFaceEmphasizedExtraLargeTitle";
  v1[213] = &unk_1ED081E88;
  v2[213] = @".AppleSystemUIFaceExtraLargeTitle2";
  v1[214] = &unk_1ED081EA0;
  v2[214] = @".AppleSystemUIFaceEmphasizedExtraLargeTitle2";
  v1[215] = &unk_1ED081EB8;
  v2[215] = @".AppleSystemUIFontCompactRounded-Ultralight";
  v1[216] = &unk_1ED081ED0;
  v2[216] = @".AppleSystemUIFontCompactRounded-Thin";
  v1[217] = &unk_1ED081EE8;
  v2[217] = @".AppleSystemUIFontCompactRounded-Light";
  v1[218] = &unk_1ED081F00;
  v2[218] = @".AppleSystemUIFontCompactRounded-Regular";
  v1[219] = &unk_1ED081F18;
  v2[219] = @".AppleSystemUIFontCompactRounded-Medium";
  v1[220] = &unk_1ED081F30;
  v2[220] = @".AppleSystemUIFontCompactRounded-Semibold";
  v1[221] = &unk_1ED081F48;
  v2[221] = @".AppleSystemUIFontCompactRounded-Bold";
  v1[222] = &unk_1ED081F60;
  v2[222] = @".AppleSystemUIFontCompactRounded-Heavy";
  v1[223] = &unk_1ED081F78;
  v2[223] = @".AppleSystemUIFontCompactRounded-Black";
  v1[224] = &unk_1ED081F90;
  v2[224] = @".AppleSystemUIFontCore-Regular";
  v1[225] = &unk_1ED081FA8;
  v2[225] = @".AppleSystemUIFontCore-Bold";
  v1[226] = &unk_1ED081FC0;
  v2[226] = @".AppleSystemUIFontCore-Thin";
  v1[227] = &unk_1ED081FD8;
  v2[227] = @".AppleSystemUIFontCore-Light";
  v1[228] = &unk_1ED081FF0;
  v2[228] = @".AppleSystemUIFontCore-UltraLight";
  v1[229] = &unk_1ED082008;
  v2[229] = @".AppleSystemUIFontCore-Medium";
  v1[230] = &unk_1ED082020;
  v2[230] = @".AppleSystemUIFontCore-Semibold";
  v1[231] = &unk_1ED082038;
  v2[231] = @".AppleSystemUIFontCore-Heavy";
  v1[232] = &unk_1ED082050;
  v2[232] = @".AppleSystemUIFontCore-Black";
  v1[233] = &unk_1ED082068;
  v2[233] = @".AppleSystemUIFontCore-Italic";
  v1[234] = &unk_1ED082080;
  v2[234] = @".AppleSystemUIFontCore-BoldItalic";
  v1[235] = &unk_1ED082098;
  v2[235] = @".AppleSystemUIFontCore-ThinItalic";
  v1[236] = &unk_1ED0820B0;
  v2[236] = @".AppleSystemUIFontCore-LightItalic";
  v1[237] = &unk_1ED0820C8;
  v2[237] = @".AppleSystemUIFontCore-UltraLightItalic";
  v1[238] = &unk_1ED0820E0;
  v2[238] = @".AppleSystemUIFontCore-MediumItalic";
  v1[239] = &unk_1ED0820F8;
  v2[239] = @".AppleSystemUIFontCore-SemiboldItalic";
  v1[240] = &unk_1ED082110;
  v2[240] = @".AppleSystemUIFontCore-HeavyItalic";
  v1[241] = &unk_1ED082128;
  v2[241] = @".AppleSystemUIFontCore-BlackItalic";
  v1[242] = &unk_1ED082140;
  v2[242] = @".AppleSystemUIFontCoreCondensed-Regular";
  v1[243] = &unk_1ED082158;
  v2[243] = @".AppleSystemUIFontCoreCondensed-Bold";
  v1[244] = &unk_1ED082170;
  v2[244] = @".AppleSystemUIFontCoreCondensed-Thin";
  v1[245] = &unk_1ED082188;
  v2[245] = @".AppleSystemUIFontCoreCondensed-Light";
  v1[246] = &unk_1ED0821A0;
  v2[246] = @".AppleSystemUIFontCoreCondensed-UltraLight";
  v1[247] = &unk_1ED0821B8;
  v2[247] = @".AppleSystemUIFontCoreCondensed-Medium";
  v1[248] = &unk_1ED0821D0;
  v2[248] = @".AppleSystemUIFontCoreCondensed-Semibold";
  v1[249] = &unk_1ED0821E8;
  v2[249] = @".AppleSystemUIFontCoreCondensed-Heavy";
  v1[250] = &unk_1ED082200;
  v2[250] = @".AppleSystemUIFontCoreCondensed-Black";
  v1[251] = &unk_1ED082218;
  v2[251] = @".AppleSystemUIFaceEmphasizedItalicCaption1";
  v1[252] = &unk_1ED082230;
  v2[252] = @".AppleSystemUIFaceShortEmphasizedItalicCaption1";
  v1[253] = &unk_1ED082248;
  v2[253] = @".AppleSystemUIFaceTallCaption1";
  v1[254] = &unk_1ED082260;
  v2[254] = @".AppleSystemUIFaceTallItalicCaption1";
  v1[255] = &unk_1ED082278;
  v2[255] = @".AppleSystemUIFaceTallEmphasizedCaption1";
  v1[256] = &unk_1ED082290;
  v2[256] = @".AppleSystemUIFaceTallEmphasizedItalicCaption1";
  v1[257] = &unk_1ED0822A8;
  v2[257] = @".AppleSystemUIFaceEmphasizedItalicCaption2";
  v1[258] = &unk_1ED0822C0;
  v2[258] = @".AppleSystemUIFaceShortEmphasizedItalicCaption2";
  v1[259] = &unk_1ED0822D8;
  v2[259] = @".AppleSystemUIFaceTallCaption2";
  v1[260] = &unk_1ED0822F0;
  v2[260] = @".AppleSystemUIFaceTallItalicCaption2";
  v1[261] = &unk_1ED082308;
  v2[261] = @".AppleSystemUIFaceTallEmphasizedCaption2";
  v1[262] = &unk_1ED082320;
  v2[262] = @".AppleSystemUIFaceTallEmphasizedItalicCaption2";
  v1[263] = &unk_1ED082338;
  v2[263] = @".AppleSystemUIFaceItalicExtraLargeTitle";
  v1[264] = &unk_1ED082350;
  v2[264] = @".AppleSystemUIFaceEmphasizedItalicExtraLargeTitle";
  v1[265] = &unk_1ED082368;
  v2[265] = @".AppleSystemUIFaceItalicExtraLargeTitle2";
  v1[266] = &unk_1ED082380;
  v2[266] = @".AppleSystemUIFaceEmphasizedItalicExtraLargeTitle2";
  v1[267] = &unk_1ED082398;
  v2[267] = @".AppleSystemUIFaceCondensedHeadline";
  v1[268] = &unk_1ED0823B0;
  v2[268] = @".AppleSystemUIFaceCondensedTitle1";
  v1[269] = &unk_1ED0823C8;
  v2[269] = @".AppleSystemUIFaceCondensedTitle2";
  v1[270] = &unk_1ED0823E0;
  v2[270] = @".AppleSystemUIFaceCondensedTitle3";
  v1[271] = &unk_1ED0823F8;
  v2[271] = @".AppleSystemUIFaceCondensedBody";
  v1[272] = &unk_1ED082410;
  v2[272] = @".AppleSystemUIFacePreferredSize-Regular";
  v1[273] = &unk_1ED082428;
  v2[273] = @".AppleSystemUIFacePreferredSize-Bold";
  id result = (id)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v2 forKeys:v1 count:274];
  qword_1EB2CDB88 = (uint64_t)result;
  return result;
}

id ___Z31FontNameForStashIndexDictionaryv_block_invoke()
{
  v2[267] = *MEMORY[0x1E4F143B8];
  v1[0] = &unk_1ED0827E8;
  v1[1] = &unk_1ED082800;
  v2[0] = @"UICTFontTextStyleHeadline";
  v2[1] = @"UICTFontTextStyleItalicHeadline";
  v1[2] = &unk_1ED080A90;
  v1[3] = &unk_1ED080AA8;
  v2[2] = @"UICTFontTextStyleShortHeadline";
  v2[3] = @"UICTFontTextStyleShortItalicHeadline";
  v1[4] = &unk_1ED082818;
  v1[5] = &unk_1ED082830;
  v2[4] = @"UICTFontTextStyleHeadline2";
  v2[5] = @"UICTFontTextStyleItalicHeadline2";
  v1[6] = &unk_1ED082848;
  v1[7] = &unk_1ED082860;
  v2[6] = @"UICTFontTextStyleShortHeadline2";
  v2[7] = @"UICTFontTextStyleShortItalicHeadline2";
  v1[8] = &unk_1ED082878;
  v1[9] = &unk_1ED082890;
  v2[8] = @"UICTFontTextStyleEmphasizedBody";
  v2[9] = @"UICTFontTextStyleBody";
  v1[10] = &unk_1ED0828A8;
  v1[11] = &unk_1ED0828C0;
  v2[10] = @"UICTFontTextStyleEmphasizedItalicBody";
  v2[11] = @"UICTFontTextStyleItalicBody";
  v1[12] = &unk_1ED0828D8;
  v1[13] = &unk_1ED0828F0;
  v2[12] = @"UICTFontTextStyleShortEmphasizedBody";
  v2[13] = @"UICTFontTextStyleShortBody";
  v1[14] = &unk_1ED082908;
  v1[15] = &unk_1ED082920;
  v2[14] = @"UICTFontTextStyleShortEmphasizedItalicBody";
  v2[15] = @"UICTFontTextStyleShortItalicBody";
  v1[16] = &unk_1ED082938;
  v1[17] = &unk_1ED082950;
  v2[16] = @"UICTFontTextStyleTallEmphasizedBody";
  v2[17] = @"UICTFontTextStyleTallBody";
  v1[18] = &unk_1ED082968;
  v1[19] = &unk_1ED082980;
  v2[18] = @"UICTFontTextStyleTallEmphasizedItalicBody";
  v2[19] = @"UICTFontTextStyleTallItalicBody";
  v1[20] = &unk_1ED082998;
  v1[21] = &unk_1ED0829B0;
  v2[20] = @"UICTFontTextStyleEmphasizedSubhead";
  v2[21] = @"UICTFontTextStyleSubhead";
  v1[22] = &unk_1ED0829C8;
  v1[23] = &unk_1ED0829E0;
  v2[22] = @"UICTFontTextStyleItalicSubhead";
  v2[23] = @"UICTFontTextStyleShortEmphasizedSubhead";
  v1[24] = &unk_1ED0829F8;
  v1[25] = &unk_1ED082A10;
  v2[24] = @"UICTFontTextStyleShortSubhead";
  v2[25] = @"UICTFontTextStyleShortItalicSubhead";
  v1[26] = &unk_1ED082A28;
  v1[27] = &unk_1ED080B80;
  v2[26] = @"UICTFontTextStyleEmphasizedSubhead2";
  v2[27] = @"UICTFontTextStyleSubhead2";
  v1[28] = &unk_1ED082A40;
  v1[29] = &unk_1ED082A58;
  v2[28] = @"UICTFontTextStyleItalicSubhead2";
  v2[29] = @"UICTFontTextStyleShortEmphasizedSubhead2";
  v1[30] = &unk_1ED082A70;
  v1[31] = &unk_1ED082A88;
  v2[30] = @"UICTFontTextStyleShortSubhead2";
  v2[31] = @"UICTFontTextStyleShortItalicSubhead2";
  v1[32] = &unk_1ED082AA0;
  v1[33] = &unk_1ED082AB8;
  v2[32] = @"UICTFontTextStyleEmphasizedFootnote";
  v2[33] = @"UICTFontTextStyleFootnote";
  v1[34] = &unk_1ED082AD0;
  v1[35] = &unk_1ED082AE8;
  v2[34] = @"UICTFontTextStyleItalicFootnote";
  v2[35] = @"UICTFontTextStyleShortEmphasizedFootnote";
  v1[36] = &unk_1ED082B00;
  v1[37] = &unk_1ED082B18;
  v2[36] = @"UICTFontTextStyleShortFootnote";
  v2[37] = @"UICTFontTextStyleShortItalicFootnote";
  v1[38] = &unk_1ED082B30;
  v1[39] = &unk_1ED082B48;
  v2[38] = @"UICTFontTextStyleEmphasizedCaption1";
  v2[39] = @"UICTFontTextStyleCaption1";
  v1[40] = &unk_1ED082B60;
  v1[41] = &unk_1ED082B78;
  v2[40] = @"UICTFontTextStyleItalicCaption1";
  v2[41] = @"UICTFontTextStyleShortEmphasizedCaption1";
  v1[42] = &unk_1ED082B90;
  v1[43] = &unk_1ED082BA8;
  v2[42] = @"UICTFontTextStyleShortCaption1";
  v2[43] = @"UICTFontTextStyleShortItalicCaption1";
  v1[44] = &unk_1ED082BC0;
  v1[45] = &unk_1ED082BD8;
  v2[44] = @"UICTFontTextStyleEmphasizedCaption2";
  v2[45] = @"UICTFontTextStyleCaption2";
  v1[46] = &unk_1ED082BF0;
  v1[47] = &unk_1ED082C08;
  v2[46] = @"UICTFontTextStyleItalicCaption2";
  v2[47] = @"UICTFontTextStyleCallout";
  v1[48] = &unk_1ED082C20;
  v1[49] = &unk_1ED082C38;
  v2[48] = @"UICTFontTextStyleItalicCallout";
  v2[49] = @"UICTFontTextStyleEmphasizedCallout";
  v1[50] = &unk_1ED082C50;
  v1[51] = &unk_1ED082C68;
  v2[50] = @"UICTFontTextStyleEmphasizedItalicCallout";
  v2[51] = @"UICTFontTextStyleShortCallout";
  v1[52] = &unk_1ED080B98;
  v1[53] = &unk_1ED082C80;
  v2[52] = @"UICTFontTextStyleShortItalicCallout";
  v2[53] = @"UICTFontTextStyleShortEmphasizedCallout";
  v1[54] = &unk_1ED082C98;
  v1[55] = &unk_1ED080AC0;
  v2[54] = @"UICTFontTextStyleShortEmphasizedItalicCallout";
  v2[55] = @"UICTFontTextStyleTallCallout";
  v1[56] = &unk_1ED080AD8;
  v1[57] = &unk_1ED080BB0;
  v2[56] = @"UICTFontTextStyleTallItalicCallout";
  v2[57] = @"UICTFontTextStyleTallEmphasizedCallout";
  v1[58] = &unk_1ED080BC8;
  v1[59] = &unk_1ED080BE0;
  v2[58] = @"UICTFontTextStyleTallEmphasizedItalicCallout";
  v2[59] = @"UICTFontTextStyleEmphasizedFootnote2";
  v1[60] = &unk_1ED080BF8;
  v1[61] = &unk_1ED080C10;
  v2[60] = @"UICTFontTextStyleFootnote2";
  v2[61] = @"UICTFontTextStyleItalicFootnote2";
  v1[62] = &unk_1ED080C28;
  v1[63] = &unk_1ED080C40;
  v2[62] = @"UICTFontTextStyleShortEmphasizedFootnote2";
  v2[63] = @"UICTFontTextStyleShortFootnote2";
  v1[64] = &unk_1ED080C58;
  v2[64] = @"UICTFontTextStyleShortItalicFootnote2";
  v1[65] = &unk_1ED080C70;
  v2[65] = @"UICTFontTextStyleShortEmphasizedCaption2";
  v1[66] = &unk_1ED080C88;
  v2[66] = @"UICTFontTextStyleShortCaption2";
  v1[67] = &unk_1ED080CA0;
  v2[67] = @"UICTFontTextStyleShortItalicCaption2";
  v1[68] = &unk_1ED081468;
  v2[68] = @"CTFontEmphasizedUsage";
  v1[69] = &unk_1ED081480;
  v2[69] = @"CTFontRegularUsage";
  v1[70] = &unk_1ED081498;
  v2[70] = @"CTFontObliqueUsage";
  v1[71] = &unk_1ED0814B0;
  v2[71] = @"CTFontEmphasizedObliqueUsage";
  v1[72] = &unk_1ED0814C8;
  v2[72] = @"CTFontThinUsage";
  v1[73] = &unk_1ED0814E0;
  v2[73] = @"CTFontLightUsage";
  v1[74] = &unk_1ED0814F8;
  v2[74] = @"CTFontUltraLightUsage";
  v1[75] = &unk_1ED081510;
  v2[75] = @"CTFontMediumUsage";
  v1[76] = &unk_1ED081528;
  v2[76] = @"CTFontDemiUsage";
  v1[77] = &unk_1ED081540;
  v2[77] = @"CTFontBoldUsage";
  v1[78] = &unk_1ED081558;
  v2[78] = @"CTFontHeavyUsage";
  v1[79] = &unk_1ED081570;
  v2[79] = @"CTFontBlackUsage";
  v1[80] = &unk_1ED081720;
  v2[80] = @"CTFontSystemUICoreRegular";
  v1[81] = &unk_1ED081708;
  v2[81] = @"CTFontSystemUICoreBold";
  v1[82] = &unk_1ED0817E0;
  v2[82] = @"CTFontSystemUICoreBold";
  v1[83] = &unk_1ED081768;
  v2[83] = @"CTFontSystemUICoreThin";
  v1[84] = &unk_1ED081780;
  v2[84] = @"CTFontSystemUICoreLight";
  v1[85] = &unk_1ED081798;
  v2[85] = @"CTFontSystemUICoreUltraLight";
  v1[86] = &unk_1ED0817B0;
  v2[86] = @"CTFontSystemUICoreMedium";
  v1[87] = &unk_1ED0817C8;
  v2[87] = @"CTFontSystemUICoreSemiBold";
  v1[88] = &unk_1ED0817F8;
  v2[88] = @"CTFontSystemUICoreHeavy";
  v1[89] = &unk_1ED081810;
  v2[89] = @"CTFontSystemUICoreBlack";
  v1[90] = &unk_1ED081738;
  v2[90] = @"CTFontSystemUICoreItalic";
  v1[91] = &unk_1ED081750;
  v2[91] = @"CTFontSystemUICoreBoldItalic";
  v1[92] = &unk_1ED081828;
  v2[92] = @"CTFontSystemUICoreThinItalic";
  v1[93] = &unk_1ED081840;
  v2[93] = @"CTFontSystemUICoreLightItalic";
  v1[94] = &unk_1ED081858;
  v2[94] = @"CTFontSystemUICoreUltraLightItalic";
  v1[95] = &unk_1ED081870;
  v2[95] = @"CTFontSystemUICoreMediumItalic";
  v1[96] = &unk_1ED081888;
  v2[96] = @"CTFontSystemUICoreSemiBoldItalic";
  v1[97] = &unk_1ED0818B8;
  v2[97] = @"CTFontSystemUICoreHeavyItalic";
  v1[98] = &unk_1ED0818D0;
  v2[98] = @"CTFontSystemUICoreBlackItalic";
  v1[99] = &unk_1ED0823C8;
  v2[99] = @"CTFontSystemUIAlternateRegular";
  v1[100] = &unk_1ED0823B0;
  v2[100] = @"CTFontSystemUIAlternateBold";
  v1[101] = &unk_1ED081588;
  v2[101] = @"CTFontSystemUIAlternateThin";
  v1[102] = &unk_1ED0815A0;
  v2[102] = @"CTFontSystemUIAlternateLight";
  v1[103] = &unk_1ED0815B8;
  v2[103] = @"CTFontSystemUIAlternateUltraLight";
  v1[104] = &unk_1ED0815D0;
  v2[104] = @"CTFontSystemUIAlternateMedium";
  v1[105] = &unk_1ED0815E8;
  v2[105] = @"CTFontSystemUIAlternateSemiBold";
  v1[106] = &unk_1ED081618;
  v2[106] = @"CTFontSystemUIAlternateHeavy";
  v1[107] = &unk_1ED081630;
  v2[107] = @"CTFontSystemUIAlternateBlack";
  v1[108] = &unk_1ED0823E0;
  v2[108] = @"CTFontSystemUIAlternateItalic";
  v1[109] = &unk_1ED0823F8;
  v2[109] = @"CTFontSystemUIAlternateBoldItalic";
  v1[110] = &unk_1ED081648;
  v2[110] = @"CTFontSystemUIAlternateThinItalic";
  v1[111] = &unk_1ED081660;
  v2[111] = @"CTFontSystemUIAlternateLightItalic";
  v1[112] = &unk_1ED081678;
  v2[112] = @"CTFontSystemUIAlternateUltraLightItalic";
  v1[113] = &unk_1ED081690;
  v2[113] = @"CTFontSystemUIAlternateMediumItalic";
  v1[114] = &unk_1ED0816A8;
  v2[114] = @"CTFontSystemUIAlternateSemiBoldItalic";
  v1[115] = &unk_1ED0816D8;
  v2[115] = @"CTFontSystemUIAlternateHeavyItalic";
  v1[116] = &unk_1ED0816F0;
  v2[116] = @"CTFontSystemUIAlternateBlackItalic";
  v1[117] = &unk_1ED0811B0;
  v2[117] = @"UICTFontTextStyleCaption3";
  v1[118] = &unk_1ED0811C8;
  v2[118] = @"UICTFontTextStyleEmphasizedCaption3";
  v1[119] = &unk_1ED081B40;
  v2[119] = @"CTFontThinItalicUsage";
  v1[120] = &unk_1ED081B58;
  v2[120] = @"CTFontLightItalicUsage";
  v1[121] = &unk_1ED081B70;
  v2[121] = @"CTFontUltraLightItalicUsage";
  v1[122] = &unk_1ED081B88;
  v2[122] = @"CTFontMediumItalicUsage";
  v1[123] = &unk_1ED081BA0;
  v2[123] = @"CTFontDemiItalicUsage";
  v1[124] = &unk_1ED081BB8;
  v2[124] = @"CTFontBoldItalicUsage";
  v1[125] = &unk_1ED081BD0;
  v2[125] = @"CTFontHeavyItalicUsage";
  v1[138] = &unk_1ED0819C0;
  v1[137] = &unk_1ED0819A8;
  v2[137] = @"CTFontSystemUIRoundedBlack";
  v1[136] = &unk_1ED081990;
  v2[136] = @"CTFontSystemUIRoundedHeavy";
  v1[135] = &unk_1ED081978;
  v2[135] = @"CTFontSystemUIRoundedBold";
  v1[134] = &unk_1ED081960;
  v2[134] = @"CTFontSystemUIRoundedSemibold";
  v1[133] = &unk_1ED081948;
  v2[133] = @"CTFontSystemUIRoundedMedium";
  v1[132] = &unk_1ED081930;
  v2[132] = @"CTFontSystemUIRoundedRegular";
  v1[131] = &unk_1ED081918;
  v2[131] = @"CTFontSystemUIRoundedLight";
  v1[130] = &unk_1ED081900;
  v2[130] = @"CTFontSystemUIRoundedThin";
  v1[129] = &unk_1ED0818E8;
  v2[129] = @"CTFontSystemUIRoundedUltralight";
  v2[128] = @"CTFontTextStyleThin";
  v2[127] = @"CTFontTextStyleUltraLight";
  v1[128] = &unk_1ED082398;
  v2[126] = @"CTFontBlackItalicUsage";
  v1[127] = &unk_1ED081C00;
  v1[126] = &unk_1ED081BE8;
  v2[138] = @"CTFontSystemUICompactRoundedUltralight";
  v1[139] = &unk_1ED0819D8;
  v2[139] = @"CTFontSystemUICompactRoundedThin";
  v1[140] = &unk_1ED0819F0;
  v2[140] = @"CTFontSystemUICompactRoundedLight";
  v1[141] = &unk_1ED081A08;
  v2[141] = @"CTFontSystemUICompactRoundedRegular";
  v1[142] = &unk_1ED081A20;
  v2[142] = @"CTFontSystemUICompactRoundedMedium";
  v1[143] = &unk_1ED081A38;
  v2[143] = @"CTFontSystemUICompactRoundedSemibold";
  v1[144] = &unk_1ED081A50;
  v2[144] = @"CTFontSystemUICompactRoundedBold";
  v1[145] = &unk_1ED081A68;
  v2[145] = @"CTFontSystemUICompactRoundedHeavy";
  v1[146] = &unk_1ED081A80;
  v2[146] = @"CTFontSystemUICompactRoundedBlack";
  v1[147] = &unk_1ED080CB8;
  v2[147] = @"UICTFontTextStyleTitle1";
  v1[148] = &unk_1ED080AF0;
  v2[148] = @"UICTFontTextStyleItalicTitle1";
  v1[149] = &unk_1ED080B08;
  v2[149] = @"UICTFontTextStyleEmphasizedTitle1";
  v1[150] = &unk_1ED080B20;
  v2[150] = @"UICTFontTextStyleEmphasizedItalicTitle1";
  v1[151] = &unk_1ED080B38;
  v2[151] = @"UICTFontTextStyleShortTitle1";
  v1[152] = &unk_1ED080B50;
  v2[152] = @"UICTFontTextStyleShortItalicTitle1";
  v1[153] = &unk_1ED080B68;
  v2[153] = @"UICTFontTextStyleShortEmphasizedTitle1";
  v1[154] = &unk_1ED080CD0;
  v2[154] = @"UICTFontTextStyleShortEmphasizedItalicTitle1";
  v1[155] = &unk_1ED080CE8;
  v2[155] = @"UICTFontTextStyleTallTitle1";
  v1[156] = &unk_1ED080D00;
  v2[156] = @"UICTFontTextStyleTallItalicTitle1";
  v1[157] = &unk_1ED080D18;
  v2[157] = @"UICTFontTextStyleTallEmphasizedTitle1";
  v1[158] = &unk_1ED080D30;
  v2[158] = @"UICTFontTextStyleTallEmphasizedItalicTitle1";
  v1[159] = &unk_1ED080D48;
  v2[159] = @"UICTFontTextStyleTitle2";
  v1[160] = &unk_1ED080D60;
  v2[160] = @"UICTFontTextStyleItalicTitle2";
  v1[161] = &unk_1ED080D78;
  v2[161] = @"UICTFontTextStyleEmphasizedTitle2";
  v1[162] = &unk_1ED080D90;
  v2[162] = @"UICTFontTextStyleEmphasizedItalicTitle2";
  v1[163] = &unk_1ED080DA8;
  v2[163] = @"UICTFontTextStyleShortTitle2";
  v1[164] = &unk_1ED080DC0;
  v2[164] = @"UICTFontTextStyleShortItalicTitle2";
  v1[165] = &unk_1ED080DD8;
  v2[165] = @"UICTFontTextStyleShortEmphasizedTitle2";
  v1[166] = &unk_1ED080DF0;
  v2[166] = @"UICTFontTextStyleShortEmphasizedItalicTitle2";
  v1[167] = &unk_1ED080E08;
  v2[167] = @"UICTFontTextStyleTallTitle2";
  v1[168] = &unk_1ED080E20;
  v2[168] = @"UICTFontTextStyleTallItalicTitle2";
  v1[169] = &unk_1ED080E38;
  v2[169] = @"UICTFontTextStyleTallEmphasizedTitle2";
  v1[170] = &unk_1ED080E50;
  v2[170] = @"UICTFontTextStyleTallEmphasizedItalicTitle2";
  v1[171] = &unk_1ED080E68;
  v2[171] = @"UICTFontTextStyleTitle3";
  v1[172] = &unk_1ED080E80;
  v2[172] = @"UICTFontTextStyleItalicTitle3";
  v1[173] = &unk_1ED080E98;
  v2[173] = @"UICTFontTextStyleEmphasizedTitle3";
  v1[174] = &unk_1ED080EB0;
  v2[174] = @"UICTFontTextStyleEmphasizedItalicTitle3";
  v1[175] = &unk_1ED080EC8;
  v2[175] = @"UICTFontTextStyleShortTitle3";
  v1[176] = &unk_1ED080EE0;
  v2[176] = @"UICTFontTextStyleShortItalicTitle3";
  v1[177] = &unk_1ED080EF8;
  v2[177] = @"UICTFontTextStyleShortEmphasizedTitle3";
  v1[178] = &unk_1ED080F10;
  v2[178] = @"UICTFontTextStyleShortEmphasizedItalicTitle3";
  v1[179] = &unk_1ED080F28;
  v2[179] = @"UICTFontTextStyleTallTitle3";
  v1[180] = &unk_1ED080F40;
  v2[180] = @"UICTFontTextStyleTallItalicTitle3";
  v1[181] = &unk_1ED080F58;
  v2[181] = @"UICTFontTextStyleTallEmphasizedTitle3";
  v1[182] = &unk_1ED080F70;
  v2[182] = @"UICTFontTextStyleTallEmphasizedItalicTitle3";
  v1[183] = &unk_1ED080F88;
  v2[183] = @"UICTFontTextStyleSubtitle3";
  v1[184] = &unk_1ED080FA0;
  v2[184] = @"UICTFontTextStyleSubtitle2";
  v1[185] = &unk_1ED080FB8;
  v2[185] = @"UICTFontTextStyleSubtitle1";
  v1[186] = &unk_1ED080FD0;
  v2[186] = @"UICTFontTextStyleSection1";
  v1[187] = &unk_1ED080FE8;
  v2[187] = @"UICTFontTextStyleSection2";
  v1[188] = &unk_1ED081000;
  v2[188] = @"UICTFontTextStyleSection3";
  v1[189] = &unk_1ED081018;
  v2[189] = @"UICTFontTextStyleTitle4";
  v1[190] = &unk_1ED081030;
  v2[190] = @"UICTFontTextStyleHeadline3";
  v1[191] = &unk_1ED081048;
  v2[191] = @"UICTFontTextStyleItalicSubtitle1";
  v1[192] = &unk_1ED081060;
  v2[192] = @"UICTFontTextStyleEmphasizedSubtitle1";
  v1[193] = &unk_1ED081078;
  v2[193] = @"UICTFontTextStyleEmphasizedItalicSubtitle1";
  v1[194] = &unk_1ED081090;
  v2[194] = @"UICTFontTextStyleTitle0";
  v1[195] = &unk_1ED0810A8;
  v2[195] = @"UICTFontTextStyleEmphasizedTitle0";
  v1[196] = &unk_1ED0810C0;
  v2[196] = @"UICTFontTextStyleShortTitle0";
  v1[197] = &unk_1ED0810D8;
  v2[197] = @"UICTFontTextStyleShortEmphasizedTitle0";
  v1[198] = &unk_1ED0810F0;
  v2[198] = @"UICTFontTextStyleTallTitle0";
  v1[199] = &unk_1ED081108;
  v2[199] = @"UICTFontTextStyleTallEmphasizedTitle0";
  v1[200] = &unk_1ED081120;
  v2[200] = @"UICTFontTextStyleEmphasizedHeadline";
  v1[201] = &unk_1ED081138;
  v2[201] = @"UICTFontTextStyleEmphasizedItalicHeadline";
  v1[202] = &unk_1ED081150;
  v2[202] = @"UICTFontTextStyleShortEmphasizedHeadline";
  v1[203] = &unk_1ED081168;
  v2[203] = @"UICTFontTextStyleShortEmphasizedItalicHeadline";
  v1[204] = &unk_1ED081180;
  v2[204] = @"UICTFontTextStyleTallHeadline";
  v1[205] = &unk_1ED081198;
  v2[205] = @"UICTFontTextStyleTallEmphasizedHeadline";
  v1[206] = &unk_1ED081D50;
  v2[206] = @"CTFontSystemUISerifRegular";
  v1[207] = &unk_1ED081D68;
  v2[207] = @"CTFontSystemUISerifMedium";
  v1[208] = &unk_1ED081D80;
  v2[208] = @"CTFontSystemUISerifSemibold";
  v1[209] = &unk_1ED081D98;
  v2[209] = @"CTFontSystemUISerifBold";
  v1[210] = &unk_1ED081DB0;
  v2[210] = @"CTFontSystemUISerifHeavy";
  v1[211] = &unk_1ED081DC8;
  v2[211] = @"CTFontSystemUISerifBlack";
  v1[212] = &unk_1ED081DE0;
  v2[212] = @"CTFontSystemUISerifItalic";
  v1[213] = &unk_1ED081DF8;
  v2[213] = @"CTFontSystemUISerifMediumItalic";
  v1[214] = &unk_1ED081E10;
  v2[214] = @"CTFontSystemUISerifSemiboldItalic";
  v1[215] = &unk_1ED081E28;
  v2[215] = @"CTFontSystemUISerifBoldItalic";
  v1[216] = &unk_1ED081E40;
  v2[216] = @"CTFontSystemUISerifHeavyItalic";
  v1[217] = &unk_1ED081B10;
  v2[217] = @"CTFontSystemUISerifBlackItalic";
  v1[218] = &unk_1ED081B28;
  v2[218] = @"CTFontSystemUIMonospacedLight";
  v1[219] = &unk_1ED081E58;
  v2[219] = @"CTFontSystemUIMonospacedRegular";
  v1[220] = &unk_1ED081E70;
  v2[220] = @"CTFontSystemUIMonospacedMedium";
  v1[221] = &unk_1ED081E88;
  v2[221] = @"CTFontSystemUIMonospacedSemibold";
  v1[222] = &unk_1ED081EA0;
  v2[222] = @"CTFontSystemUIMonospacedBold";
  v1[223] = &unk_1ED081EB8;
  v2[223] = @"CTFontSystemUIMonospacedHeavy";
  v1[224] = &unk_1ED081ED0;
  v2[224] = @"CTFontSystemUIMonospacedLightItalic";
  v1[225] = &unk_1ED081EE8;
  v2[225] = @"CTFontSystemUIMonospacedRegularItalic";
  v1[226] = &unk_1ED081F00;
  v2[226] = @"CTFontSystemUIMonospacedMediumItalic";
  v1[227] = &unk_1ED081F18;
  v2[227] = @"CTFontSystemUIMonospacedSemiboldItalic";
  v1[228] = &unk_1ED081F30;
  v2[228] = @"CTFontSystemUIMonospacedBoldItalic";
  v1[229] = &unk_1ED081F48;
  v2[229] = @"CTFontSystemUIMonospacedHeavyItalic";
  v1[230] = &unk_1ED081A98;
  v2[230] = @"CTFontSystemUICondensedRegular";
  v1[231] = &unk_1ED081AB0;
  v2[231] = @"CTFontSystemUICondensedBold";
  v1[232] = &unk_1ED081AC8;
  v2[232] = @"CTFontSystemUICondensedThin";
  v1[233] = &unk_1ED081AE0;
  v2[233] = @"CTFontSystemUICondensedLight";
  v1[234] = &unk_1ED081AF8;
  v2[234] = @"CTFontSystemUICondensedUltraLight";
  v1[235] = &unk_1ED081C18;
  v2[235] = @"CTFontSystemUICondensedMedium";
  v1[236] = &unk_1ED081C30;
  v2[236] = @"CTFontSystemUICondensedSemiBold";
  v1[237] = &unk_1ED081C48;
  v2[237] = @"CTFontSystemUICondensedHeavy";
  v1[238] = &unk_1ED081C60;
  v2[238] = @"CTFontSystemUICondensedBlack";
  v1[239] = &unk_1ED081C78;
  v2[239] = @"CTFontSystemUICoreCondensedRegular";
  v1[240] = &unk_1ED081C90;
  v2[240] = @"CTFontSystemUICoreCondensedBold";
  v1[241] = &unk_1ED081CA8;
  v2[241] = @"CTFontSystemUICoreCondensedThin";
  v1[242] = &unk_1ED081CC0;
  v2[242] = @"CTFontSystemUICoreCondensedLight";
  v1[243] = &unk_1ED081CD8;
  v2[243] = @"CTFontSystemUICoreCondensedUltraLight";
  v1[244] = &unk_1ED081CF0;
  v2[244] = @"CTFontSystemUICoreCondensedMedium";
  v1[245] = &unk_1ED081D08;
  v2[245] = @"CTFontSystemUICoreCondensedSemiBold";
  v1[246] = &unk_1ED081D20;
  v2[246] = @"CTFontSystemUICoreCondensedHeavy";
  v1[247] = &unk_1ED081D38;
  v2[247] = @"CTFontSystemUICoreCondensedBlack";
  v1[248] = &unk_1ED081240;
  v2[248] = @"UICTFontTextStyleEmphasizedItalicCaption1";
  v1[249] = &unk_1ED081258;
  v2[249] = @"UICTFontTextStyleShortEmphasizedItalicCaption1";
  v1[250] = &unk_1ED081270;
  v2[250] = @"UICTFontTextStyleTallCaption1";
  v1[251] = &unk_1ED081288;
  v2[251] = @"UICTFontTextStyleTallItalicCaption1";
  v1[252] = &unk_1ED0812A0;
  v2[252] = @"UICTFontTextStyleTallEmphasizedCaption1";
  v1[253] = &unk_1ED0812B8;
  v2[253] = @"UICTFontTextStyleTallEmphasizedItalicCaption1";
  v1[254] = &unk_1ED0812D0;
  v2[254] = @"UICTFontTextStyleEmphasizedItalicCaption2";
  v1[255] = &unk_1ED0812E8;
  v2[255] = @"UICTFontTextStyleShortEmphasizedItalicCaption2";
  v1[256] = &unk_1ED081300;
  v2[256] = @"UICTFontTextStyleTallCaption2";
  v1[257] = &unk_1ED081318;
  v2[257] = @"UICTFontTextStyleTallItalicCaption2";
  v1[258] = &unk_1ED081330;
  v2[258] = @"UICTFontTextStyleTallEmphasizedCaption2";
  v1[259] = &unk_1ED081348;
  v2[259] = @"UICTFontTextStyleTallEmphasizedItalicCaption2";
  v1[260] = &unk_1ED0813F0;
  v2[260] = @"UICTFontTextStyleCondensedHeadline";
  v1[261] = &unk_1ED081408;
  v2[261] = @"UICTFontTextStyleCondensedTitle1";
  v1[262] = &unk_1ED081420;
  v2[262] = @"UICTFontTextStyleCondensedTitle2";
  v1[263] = &unk_1ED081438;
  v2[263] = @"UICTFontTextStyleCondensedTitle3";
  v1[264] = &unk_1ED081450;
  v2[264] = @"UICTFontTextStyleCondensedBody";
  v1[265] = &unk_1ED0813C0;
  v2[265] = @"UICTFontTextStylePreferredSizeRegular";
  v1[266] = &unk_1ED0813D8;
  v2[266] = @"UICTFontTextStylePreferredSizeBold";
  id result = (id)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v2 forKeys:v1 count:267];
  qword_1EB2CDBA8 = (uint64_t)result;
  return result;
}

void TAttributes::GetDefaultAttributes(void)::{lambda(void *)#1}::__invoke()
{
  if (qword_1EB2CE318 != -1) {
    dispatch_once_f(&qword_1EB2CE318, 0, (dispatch_function_t)TAttributes::GetDefaultFont(void)::{lambda(void *)#1}::__invoke);
  }
  id values = (void *)qword_1EB2CE2E8;
  id keys = @"NSFont";
  id v1 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&keys, (const void **)&values, 1, MEMORY[0x1E4F1D048], MEMORY[0x1E4F1D540]);
  unint64_t v0 = atomic_exchange((atomic_ullong *volatile)&v1, 0);

  _MergedGlobals_18 = v0;
}

id ___Z28TextStyleForUITypeDictionaryv_block_invoke()
{
  v2[274] = *MEMORY[0x1E4F143B8];
  v1[0] = &unk_1ED080A90;
  v1[1] = &unk_1ED080AA8;
  v2[0] = @"CTFontRegularUsage";
  v2[1] = @"CTFontEmphasizedUsage";
  v1[2] = &unk_1ED080B80;
  v1[3] = &unk_1ED080B98;
  v2[2] = @"CTFontObliqueUsage";
  v2[3] = @"CTFontEmphasizedObliqueUsage";
  v1[4] = &unk_1ED081B10;
  v1[5] = &unk_1ED081B28;
  v2[4] = @"UICTFontTextStyleCaption3";
  v2[5] = @"UICTFontTextStyleEmphasizedCaption3";
  v1[6] = &unk_1ED080AC0;
  v1[7] = &unk_1ED080AD8;
  v2[6] = @"UICTFontTextStyleHeadline";
  v2[7] = @"UICTFontTextStyleShortHeadline";
  v1[8] = &unk_1ED080BB0;
  v1[9] = &unk_1ED080BC8;
  v2[8] = @"UICTFontTextStyleHeadline2";
  v2[9] = @"UICTFontTextStyleItalicHeadline2";
  v1[10] = &unk_1ED080BE0;
  v1[11] = &unk_1ED080BF8;
  v2[10] = @"UICTFontTextStyleShortHeadline2";
  v2[11] = @"UICTFontTextStyleShortItalicHeadline2";
  v1[12] = &unk_1ED080C10;
  v1[13] = &unk_1ED080C28;
  v2[12] = @"UICTFontTextStyleEmphasizedBody";
  v2[13] = @"UICTFontTextStyleBody";
  v1[14] = &unk_1ED080C40;
  v1[15] = &unk_1ED080C58;
  v2[14] = @"UICTFontTextStyleEmphasizedItalicBody";
  v2[15] = @"UICTFontTextStyleItalicBody";
  v1[16] = &unk_1ED080C70;
  v1[17] = &unk_1ED080C88;
  v2[16] = @"UICTFontTextStyleShortEmphasizedBody";
  v2[17] = @"UICTFontTextStyleShortBody";
  v1[18] = &unk_1ED080CA0;
  v1[19] = &unk_1ED080CB8;
  v2[18] = @"UICTFontTextStyleShortEmphasizedItalicBody";
  v2[19] = @"UICTFontTextStyleShortItalicBody";
  v1[20] = &unk_1ED080AF0;
  v1[21] = &unk_1ED080B08;
  v2[20] = @"UICTFontTextStyleEmphasizedSubhead";
  v2[21] = @"UICTFontTextStyleSubhead";
  v1[22] = &unk_1ED080B20;
  v1[23] = &unk_1ED080B38;
  v2[22] = @"UICTFontTextStyleItalicSubhead";
  v2[23] = @"UICTFontTextStyleShortEmphasizedSubhead";
  v1[24] = &unk_1ED080B50;
  v1[25] = &unk_1ED080B68;
  v2[24] = @"UICTFontTextStyleShortSubhead";
  v2[25] = @"UICTFontTextStyleShortItalicSubhead";
  v1[26] = &unk_1ED080CD0;
  v1[27] = &unk_1ED080CE8;
  v2[26] = @"UICTFontTextStyleEmphasizedSubhead2";
  v2[27] = @"UICTFontTextStyleSubhead2";
  v1[28] = &unk_1ED080D00;
  v1[29] = &unk_1ED080D18;
  v2[28] = @"UICTFontTextStyleItalicSubhead2";
  v2[29] = @"UICTFontTextStyleShortEmphasizedSubhead2";
  v1[30] = &unk_1ED080D30;
  v1[31] = &unk_1ED080D48;
  v2[30] = @"UICTFontTextStyleShortSubhead2";
  v2[31] = @"UICTFontTextStyleShortItalicSubhead2";
  v1[32] = &unk_1ED080D60;
  v1[33] = &unk_1ED080D78;
  v2[32] = @"UICTFontTextStyleEmphasizedFootnote";
  v2[33] = @"UICTFontTextStyleFootnote";
  v1[34] = &unk_1ED080D90;
  v1[35] = &unk_1ED080DA8;
  v2[34] = @"UICTFontTextStyleItalicFootnote";
  v2[35] = @"UICTFontTextStyleShortEmphasizedFootnote";
  v1[36] = &unk_1ED080DC0;
  v1[37] = &unk_1ED080DD8;
  v2[36] = @"UICTFontTextStyleShortFootnote";
  v2[37] = @"UICTFontTextStyleShortItalicFootnote";
  v1[38] = &unk_1ED080DF0;
  v1[39] = &unk_1ED080E08;
  v2[38] = @"UICTFontTextStyleEmphasizedCaption1";
  v2[39] = @"UICTFontTextStyleCaption1";
  v1[40] = &unk_1ED080E20;
  v1[41] = &unk_1ED080E38;
  v2[40] = @"UICTFontTextStyleItalicCaption1";
  v2[41] = @"UICTFontTextStyleShortEmphasizedCaption1";
  v1[42] = &unk_1ED080E50;
  v1[43] = &unk_1ED080E68;
  v2[42] = @"UICTFontTextStyleShortCaption1";
  v2[43] = @"UICTFontTextStyleShortItalicCaption1";
  v1[44] = &unk_1ED080E80;
  v1[45] = &unk_1ED080E98;
  v2[44] = @"UICTFontTextStyleEmphasizedCaption2";
  v2[45] = @"UICTFontTextStyleCaption2";
  v1[46] = &unk_1ED080EB0;
  v1[47] = &unk_1ED080EC8;
  v2[46] = @"UICTFontTextStyleItalicCaption2";
  v2[47] = @"UICTFontTextStyleTallEmphasizedBody";
  v1[48] = &unk_1ED080EE0;
  v1[49] = &unk_1ED080EF8;
  v2[48] = @"UICTFontTextStyleTallBody";
  v2[49] = @"UICTFontTextStyleTallEmphasizedItalicBody";
  v1[50] = &unk_1ED080F10;
  v1[51] = &unk_1ED080F28;
  v2[50] = @"UICTFontTextStyleTallItalicBody";
  v2[51] = @"UICTFontTextStyleItalicHeadline";
  v1[52] = &unk_1ED080F40;
  v1[53] = &unk_1ED080F58;
  v2[52] = @"UICTFontTextStyleShortItalicHeadline";
  v2[53] = @"CTFontThinUsage";
  v1[54] = &unk_1ED080F70;
  v1[55] = &unk_1ED080F88;
  v2[54] = @"CTFontLightUsage";
  v2[55] = @"CTFontUltraLightUsage";
  v1[56] = &unk_1ED080FA0;
  v1[57] = &unk_1ED080FB8;
  v2[56] = @"CTFontMediumUsage";
  v2[57] = @"CTFontDemiUsage";
  v1[58] = &unk_1ED080FD0;
  v1[59] = &unk_1ED080FE8;
  v2[58] = @"CTFontBoldUsage";
  v2[59] = @"CTFontHeavyUsage";
  v1[60] = &unk_1ED081000;
  v1[61] = &unk_1ED081018;
  v2[60] = @"CTFontBlackUsage";
  v2[61] = @"UICTFontTextStyleCallout";
  v1[62] = &unk_1ED081030;
  v1[63] = &unk_1ED081048;
  v2[62] = @"UICTFontTextStyleItalicCallout";
  v2[63] = @"UICTFontTextStyleEmphasizedCallout";
  v1[64] = &unk_1ED081060;
  v2[64] = @"UICTFontTextStyleEmphasizedItalicCallout";
  v1[65] = &unk_1ED081078;
  v2[65] = @"UICTFontTextStyleShortCallout";
  v1[66] = &unk_1ED081090;
  v2[66] = @"UICTFontTextStyleShortItalicCallout";
  v1[67] = &unk_1ED0810A8;
  v2[67] = @"UICTFontTextStyleShortEmphasizedCallout";
  v1[68] = &unk_1ED0810C0;
  v2[68] = @"UICTFontTextStyleShortEmphasizedItalicCallout";
  v1[69] = &unk_1ED0810D8;
  v2[69] = @"UICTFontTextStyleTallCallout";
  v1[70] = &unk_1ED0810F0;
  v2[70] = @"UICTFontTextStyleTallItalicCallout";
  v1[71] = &unk_1ED081108;
  v2[71] = @"UICTFontTextStyleTallEmphasizedCallout";
  v1[72] = &unk_1ED081120;
  v2[72] = @"UICTFontTextStyleTallEmphasizedItalicCallout";
  v1[73] = &unk_1ED081138;
  v2[73] = @"UICTFontTextStyleEmphasizedFootnote2";
  v1[74] = &unk_1ED081150;
  v2[74] = @"UICTFontTextStyleFootnote2";
  v1[75] = &unk_1ED081168;
  v2[75] = @"UICTFontTextStyleItalicFootnote2";
  v1[76] = &unk_1ED081180;
  v2[76] = @"UICTFontTextStyleShortEmphasizedFootnote2";
  v1[77] = &unk_1ED081198;
  v2[77] = @"UICTFontTextStyleShortFootnote2";
  v1[78] = &unk_1ED0811B0;
  v2[78] = @"UICTFontTextStyleShortItalicFootnote2";
  v1[79] = &unk_1ED0811C8;
  v2[79] = @"UICTFontTextStyleShortEmphasizedCaption2";
  v1[80] = &unk_1ED0811E0;
  v2[80] = @"UICTFontTextStyleShortCaption2";
  v1[81] = &unk_1ED0811F8;
  v2[81] = @"UICTFontTextStyleShortItalicCaption2";
  v1[82] = &unk_1ED081210;
  v2[82] = @"CTFontThinItalicUsage";
  v1[83] = &unk_1ED081228;
  v2[83] = @"CTFontLightItalicUsage";
  v1[84] = &unk_1ED081240;
  v2[84] = @"CTFontUltraLightItalicUsage";
  v1[85] = &unk_1ED081258;
  v2[85] = @"CTFontMediumItalicUsage";
  v1[86] = &unk_1ED081270;
  v2[86] = @"CTFontDemiItalicUsage";
  v1[87] = &unk_1ED081288;
  v2[87] = @"CTFontBoldItalicUsage";
  v1[88] = &unk_1ED0812A0;
  v2[88] = @"CTFontHeavyItalicUsage";
  v1[89] = &unk_1ED0812B8;
  v2[89] = @"CTFontBlackItalicUsage";
  v1[90] = &unk_1ED0812D0;
  v2[90] = @"CTFontTextStyleUltraLight";
  v1[91] = &unk_1ED0812E8;
  v2[91] = @"CTFontTextStyleThin";
  v1[92] = &unk_1ED081300;
  v2[92] = @"CTFontSystemUIAlternateRegular";
  v1[93] = &unk_1ED081318;
  v2[93] = @"CTFontSystemUIAlternateBold";
  v1[94] = &unk_1ED081330;
  v2[94] = @"CTFontSystemUIAlternateThin";
  v1[95] = &unk_1ED081348;
  v2[95] = @"CTFontSystemUIAlternateLight";
  v1[96] = &unk_1ED081360;
  v2[96] = @"CTFontSystemUIAlternateUltraLight";
  v1[97] = &unk_1ED081378;
  v2[97] = @"CTFontSystemUIAlternateMedium";
  v1[98] = &unk_1ED081390;
  v2[98] = @"CTFontSystemUIAlternateSemiBold";
  v1[99] = &unk_1ED0813A8;
  v2[99] = @"CTFontSystemUIAlternateHeavy";
  v1[100] = &unk_1ED0813C0;
  v2[100] = @"CTFontSystemUIAlternateBlack";
  v1[101] = &unk_1ED0813D8;
  v2[101] = @"CTFontSystemUIAlternateItalic";
  v1[102] = &unk_1ED0813F0;
  v2[102] = @"CTFontSystemUIAlternateBoldItalic";
  v1[103] = &unk_1ED081408;
  v2[103] = @"CTFontSystemUIAlternateThinItalic";
  v1[104] = &unk_1ED081420;
  v2[104] = @"CTFontSystemUIAlternateLightItalic";
  v1[105] = &unk_1ED081438;
  v2[105] = @"CTFontSystemUIAlternateUltraLightItalic";
  v1[106] = &unk_1ED081450;
  v2[106] = @"CTFontSystemUIAlternateMediumItalic";
  v1[107] = &unk_1ED081468;
  v2[107] = @"CTFontSystemUIAlternateSemiBoldItalic";
  v1[108] = &unk_1ED081480;
  v2[108] = @"CTFontSystemUIAlternateHeavyItalic";
  v1[109] = &unk_1ED081498;
  v2[109] = @"CTFontSystemUIAlternateBlackItalic";
  v1[110] = &unk_1ED0814B0;
  v2[110] = @"CTFontSystemUIRoundedUltralight";
  v1[111] = &unk_1ED0814C8;
  v2[111] = @"CTFontSystemUIRoundedThin";
  v1[112] = &unk_1ED0814E0;
  v2[112] = @"CTFontSystemUIRoundedLight";
  v1[113] = &unk_1ED0814F8;
  v2[113] = @"CTFontSystemUIRoundedRegular";
  v1[114] = &unk_1ED081510;
  v2[114] = @"CTFontSystemUIRoundedMedium";
  v1[115] = &unk_1ED081528;
  v2[115] = @"CTFontSystemUIRoundedSemibold";
  v1[116] = &unk_1ED081540;
  v2[116] = @"CTFontSystemUIRoundedBold";
  v1[117] = &unk_1ED081558;
  v2[117] = @"CTFontSystemUIRoundedHeavy";
  v1[118] = &unk_1ED081570;
  v2[118] = @"CTFontSystemUIRoundedBlack";
  v1[119] = &unk_1ED081588;
  v2[119] = @"UICTFontTextStyleTitle1";
  v1[120] = &unk_1ED0815A0;
  v2[120] = @"UICTFontTextStyleItalicTitle1";
  v1[121] = &unk_1ED0815B8;
  v2[121] = @"UICTFontTextStyleEmphasizedTitle1";
  v1[122] = &unk_1ED0815D0;
  v2[122] = @"UICTFontTextStyleEmphasizedItalicTitle1";
  v1[123] = &unk_1ED0815E8;
  v2[123] = @"UICTFontTextStyleShortTitle1";
  v1[124] = &unk_1ED081600;
  v2[124] = @"UICTFontTextStyleShortItalicTitle1";
  v1[125] = &unk_1ED081618;
  v1[143] = &unk_1ED0817C8;
  v1[145] = &unk_1ED0817F8;
  v1[144] = &unk_1ED0817E0;
  v2[144] = @"UICTFontTextStyleItalicTitle3";
  v2[143] = @"UICTFontTextStyleTitle3";
  v1[142] = &unk_1ED0817B0;
  v2[142] = @"UICTFontTextStyleTallEmphasizedItalicTitle2";
  v1[141] = &unk_1ED081798;
  v2[141] = @"UICTFontTextStyleTallEmphasizedTitle2";
  v1[140] = &unk_1ED081780;
  v2[140] = @"UICTFontTextStyleTallItalicTitle2";
  v1[139] = &unk_1ED081768;
  v2[139] = @"UICTFontTextStyleTallTitle2";
  v1[138] = &unk_1ED081750;
  v2[138] = @"UICTFontTextStyleShortEmphasizedItalicTitle2";
  v1[137] = &unk_1ED081738;
  v2[137] = @"UICTFontTextStyleShortEmphasizedTitle2";
  v1[136] = &unk_1ED081720;
  v2[136] = @"UICTFontTextStyleShortItalicTitle2";
  v1[135] = &unk_1ED081708;
  v2[135] = @"UICTFontTextStyleShortTitle2";
  v1[134] = &unk_1ED0816F0;
  v2[134] = @"UICTFontTextStyleEmphasizedItalicTitle2";
  v1[133] = &unk_1ED0816D8;
  v2[133] = @"UICTFontTextStyleEmphasizedTitle2";
  v2[125] = @"UICTFontTextStyleShortEmphasizedTitle1";
  v2[132] = @"UICTFontTextStyleItalicTitle2";
  v1[126] = &unk_1ED081630;
  v2[131] = @"UICTFontTextStyleTitle2";
  v1[132] = &unk_1ED0816C0;
  v2[130] = @"UICTFontTextStyleTallEmphasizedItalicTitle1";
  v1[131] = &unk_1ED0816A8;
  v2[129] = @"UICTFontTextStyleTallEmphasizedTitle1";
  v1[130] = &unk_1ED081690;
  v2[128] = @"UICTFontTextStyleTallItalicTitle1";
  v1[129] = &unk_1ED081678;
  v2[127] = @"UICTFontTextStyleTallTitle1";
  v1[128] = &unk_1ED081660;
  v2[126] = @"UICTFontTextStyleShortEmphasizedItalicTitle1";
  v1[127] = &unk_1ED081648;
  v2[145] = @"UICTFontTextStyleEmphasizedTitle3";
  v1[146] = &unk_1ED081810;
  v2[146] = @"UICTFontTextStyleEmphasizedItalicTitle3";
  v1[147] = &unk_1ED081828;
  v2[147] = @"UICTFontTextStyleShortTitle3";
  v1[148] = &unk_1ED081840;
  v2[148] = @"UICTFontTextStyleShortItalicTitle3";
  v1[149] = &unk_1ED081858;
  v2[149] = @"UICTFontTextStyleShortEmphasizedTitle3";
  v1[150] = &unk_1ED081870;
  v2[150] = @"UICTFontTextStyleShortEmphasizedItalicTitle3";
  v1[151] = &unk_1ED081888;
  v2[151] = @"UICTFontTextStyleTallTitle3";
  v1[152] = &unk_1ED0818A0;
  v2[152] = @"UICTFontTextStyleTallItalicTitle3";
  v1[153] = &unk_1ED0818B8;
  v2[153] = @"UICTFontTextStyleTallEmphasizedTitle3";
  v1[154] = &unk_1ED0818D0;
  v2[154] = @"UICTFontTextStyleTallEmphasizedItalicTitle3";
  v1[155] = &unk_1ED0818E8;
  v2[155] = @"UICTFontTextStyleSubtitle3";
  v1[156] = &unk_1ED081900;
  v2[156] = @"UICTFontTextStyleSubtitle2";
  v1[157] = &unk_1ED081918;
  v2[157] = @"UICTFontTextStyleSubtitle1";
  v1[158] = &unk_1ED081930;
  v2[158] = @"UICTFontTextStyleSection1";
  v1[159] = &unk_1ED081948;
  v2[159] = @"UICTFontTextStyleSection2";
  v1[160] = &unk_1ED081960;
  v2[160] = @"UICTFontTextStyleSection3";
  v1[161] = &unk_1ED081978;
  v2[161] = @"UICTFontTextStyleTitle4";
  v1[162] = &unk_1ED081990;
  v2[162] = @"UICTFontTextStyleHeadline3";
  v1[163] = &unk_1ED0819A8;
  v2[163] = @"UICTFontTextStyleItalicSubtitle1";
  v1[164] = &unk_1ED0819C0;
  v2[164] = @"UICTFontTextStyleEmphasizedSubtitle1";
  v1[165] = &unk_1ED0819D8;
  v2[165] = @"UICTFontTextStyleEmphasizedItalicSubtitle1";
  v1[166] = &unk_1ED0819F0;
  v2[166] = @"UICTFontTextStyleTitle0";
  v1[167] = &unk_1ED081A08;
  v2[167] = @"UICTFontTextStyleEmphasizedTitle0";
  v1[168] = &unk_1ED081A20;
  v2[168] = @"UICTFontTextStyleShortTitle0";
  v1[169] = &unk_1ED081A38;
  v2[169] = @"UICTFontTextStyleShortEmphasizedTitle0";
  v1[170] = &unk_1ED081A50;
  v2[170] = @"UICTFontTextStyleTallTitle0";
  v1[171] = &unk_1ED081A68;
  v2[171] = @"UICTFontTextStyleTallEmphasizedTitle0";
  v1[172] = &unk_1ED081A80;
  v2[172] = @"UICTFontTextStyleEmphasizedHeadline";
  v1[173] = &unk_1ED081A98;
  v2[173] = @"UICTFontTextStyleEmphasizedItalicHeadline";
  v1[174] = &unk_1ED081AB0;
  v2[174] = @"UICTFontTextStyleShortEmphasizedHeadline";
  v1[175] = &unk_1ED081AC8;
  v2[175] = @"UICTFontTextStyleShortEmphasizedItalicHeadline";
  v1[176] = &unk_1ED081AE0;
  v2[176] = @"UICTFontTextStyleTallHeadline";
  v1[177] = &unk_1ED081AF8;
  v2[177] = @"UICTFontTextStyleTallEmphasizedHeadline";
  v1[178] = &unk_1ED081C18;
  v2[178] = @"CTFontSystemUISerifRegular";
  v1[179] = &unk_1ED081C30;
  v2[179] = @"CTFontSystemUISerifMedium";
  v1[180] = &unk_1ED081C48;
  v2[180] = @"CTFontSystemUISerifSemibold";
  v1[181] = &unk_1ED081C60;
  v2[181] = @"CTFontSystemUISerifBold";
  v1[182] = &unk_1ED081C78;
  v2[182] = @"CTFontSystemUISerifHeavy";
  v1[183] = &unk_1ED081C90;
  v2[183] = @"CTFontSystemUISerifBlack";
  v1[184] = &unk_1ED081CA8;
  v2[184] = @"CTFontSystemUISerifItalic";
  v1[185] = &unk_1ED081CC0;
  v2[185] = @"CTFontSystemUISerifMediumItalic";
  v1[186] = &unk_1ED081CD8;
  v2[186] = @"CTFontSystemUISerifSemiboldItalic";
  v1[187] = &unk_1ED081CF0;
  v2[187] = @"CTFontSystemUISerifBoldItalic";
  v1[188] = &unk_1ED081D08;
  v2[188] = @"CTFontSystemUISerifHeavyItalic";
  v1[189] = &unk_1ED081D20;
  v2[189] = @"CTFontSystemUISerifBlackItalic";
  v1[190] = &unk_1ED081D38;
  v2[190] = @"CTFontSystemUIMonospacedLight";
  v1[191] = &unk_1ED081D50;
  v2[191] = @"CTFontSystemUIMonospacedRegular";
  v1[192] = &unk_1ED081D68;
  v2[192] = @"CTFontSystemUIMonospacedMedium";
  v1[193] = &unk_1ED081D80;
  v2[193] = @"CTFontSystemUIMonospacedSemibold";
  v1[194] = &unk_1ED081D98;
  v2[194] = @"CTFontSystemUIMonospacedBold";
  v1[195] = &unk_1ED081DB0;
  v2[195] = @"CTFontSystemUIMonospacedHeavy";
  v1[196] = &unk_1ED081DC8;
  v2[196] = @"CTFontSystemUIMonospacedLightItalic";
  v1[197] = &unk_1ED081DE0;
  v2[197] = @"CTFontSystemUIMonospacedRegularItalic";
  v1[198] = &unk_1ED081DF8;
  v2[198] = @"CTFontSystemUIMonospacedMediumItalic";
  v1[199] = &unk_1ED081E10;
  v2[199] = @"CTFontSystemUIMonospacedSemiboldItalic";
  v1[200] = &unk_1ED081E28;
  v2[200] = @"CTFontSystemUIMonospacedBoldItalic";
  v1[201] = &unk_1ED081E40;
  v2[201] = @"CTFontSystemUIMonospacedHeavyItalic";
  v1[202] = &unk_1ED081B40;
  v2[202] = @"CTFontSystemUICondensedRegular";
  v1[203] = &unk_1ED081B58;
  v2[203] = @"CTFontSystemUICondensedBold";
  v1[204] = &unk_1ED081B70;
  v2[204] = @"CTFontSystemUICondensedThin";
  v1[205] = &unk_1ED081B88;
  v2[205] = @"CTFontSystemUICondensedLight";
  v1[206] = &unk_1ED081BA0;
  v2[206] = @"CTFontSystemUICondensedUltraLight";
  v1[207] = &unk_1ED081BB8;
  v2[207] = @"CTFontSystemUICondensedMedium";
  v1[208] = &unk_1ED081BD0;
  v2[208] = @"CTFontSystemUICondensedSemiBold";
  v1[209] = &unk_1ED081BE8;
  v2[209] = @"CTFontSystemUICondensedHeavy";
  v1[210] = &unk_1ED081C00;
  v2[210] = @"CTFontSystemUICondensedBlack";
  v1[211] = &unk_1ED081E58;
  v2[211] = @"UICTFontTextStyleExtraLargeTitle";
  v1[212] = &unk_1ED081E70;
  v2[212] = @"UICTFontTextStyleEmphasizedExtraLargeTitle";
  v1[213] = &unk_1ED081E88;
  v2[213] = @"UICTFontTextStyleExtraLargeTitle2";
  v1[214] = &unk_1ED081EA0;
  v2[214] = @"UICTFontTextStyleEmphasizedExtraLargeTitle2";
  v1[215] = &unk_1ED081EB8;
  v2[215] = @"CTFontSystemUICompactRoundedUltralight";
  v1[216] = &unk_1ED081ED0;
  v2[216] = @"CTFontSystemUICompactRoundedThin";
  v1[217] = &unk_1ED081EE8;
  v2[217] = @"CTFontSystemUICompactRoundedLight";
  v1[218] = &unk_1ED081F00;
  v2[218] = @"CTFontSystemUICompactRoundedRegular";
  v1[219] = &unk_1ED081F18;
  v2[219] = @"CTFontSystemUICompactRoundedMedium";
  v1[220] = &unk_1ED081F30;
  v2[220] = @"CTFontSystemUICompactRoundedSemibold";
  v1[221] = &unk_1ED081F48;
  v2[221] = @"CTFontSystemUICompactRoundedBold";
  v1[222] = &unk_1ED081F60;
  v2[222] = @"CTFontSystemUICompactRoundedHeavy";
  v1[223] = &unk_1ED081F78;
  v2[223] = @"CTFontSystemUICompactRoundedBlack";
  v1[224] = &unk_1ED081F90;
  v2[224] = @"CTFontSystemUICoreRegular";
  v1[225] = &unk_1ED081FA8;
  v2[225] = @"CTFontSystemUICoreBold";
  v1[226] = &unk_1ED081FC0;
  v2[226] = @"CTFontSystemUICoreThin";
  v1[227] = &unk_1ED081FD8;
  v2[227] = @"CTFontSystemUICoreLight";
  v1[228] = &unk_1ED081FF0;
  v2[228] = @"CTFontSystemUICoreUltraLight";
  v1[229] = &unk_1ED082008;
  v2[229] = @"CTFontSystemUICoreMedium";
  v1[230] = &unk_1ED082020;
  v2[230] = @"CTFontSystemUICoreSemiBold";
  v1[231] = &unk_1ED082038;
  v2[231] = @"CTFontSystemUICoreHeavy";
  v1[232] = &unk_1ED082050;
  v2[232] = @"CTFontSystemUICoreBlack";
  v1[233] = &unk_1ED082068;
  v2[233] = @"CTFontSystemUICoreItalic";
  v1[234] = &unk_1ED082080;
  v2[234] = @"CTFontSystemUICoreBoldItalic";
  v1[235] = &unk_1ED082098;
  v2[235] = @"CTFontSystemUICoreThinItalic";
  v1[236] = &unk_1ED0820B0;
  v2[236] = @"CTFontSystemUICoreLightItalic";
  v1[237] = &unk_1ED0820C8;
  v2[237] = @"CTFontSystemUICoreUltraLightItalic";
  v1[238] = &unk_1ED0820E0;
  v2[238] = @"CTFontSystemUICoreMediumItalic";
  v1[239] = &unk_1ED0820F8;
  v2[239] = @"CTFontSystemUICoreSemiBoldItalic";
  v1[240] = &unk_1ED082110;
  v2[240] = @"CTFontSystemUICoreHeavyItalic";
  v1[241] = &unk_1ED082128;
  v2[241] = @"CTFontSystemUICoreBlackItalic";
  v1[242] = &unk_1ED082140;
  v2[242] = @"CTFontSystemUICoreCondensedRegular";
  v1[243] = &unk_1ED082158;
  v2[243] = @"CTFontSystemUICoreCondensedBold";
  v1[244] = &unk_1ED082170;
  v2[244] = @"CTFontSystemUICoreCondensedThin";
  v1[245] = &unk_1ED082188;
  v2[245] = @"CTFontSystemUICoreCondensedLight";
  v1[246] = &unk_1ED0821A0;
  v2[246] = @"CTFontSystemUICoreCondensedUltraLight";
  v1[247] = &unk_1ED0821B8;
  v2[247] = @"CTFontSystemUICoreCondensedMedium";
  v1[248] = &unk_1ED0821D0;
  v2[248] = @"CTFontSystemUICoreCondensedSemiBold";
  v1[249] = &unk_1ED0821E8;
  v2[249] = @"CTFontSystemUICoreCondensedHeavy";
  v1[250] = &unk_1ED082200;
  v2[250] = @"CTFontSystemUICoreCondensedBlack";
  v1[251] = &unk_1ED082218;
  v2[251] = @"UICTFontTextStyleEmphasizedItalicCaption1";
  v1[252] = &unk_1ED082230;
  v2[252] = @"UICTFontTextStyleShortEmphasizedItalicCaption1";
  v1[253] = &unk_1ED082248;
  v2[253] = @"UICTFontTextStyleTallCaption1";
  v1[254] = &unk_1ED082260;
  v2[254] = @"UICTFontTextStyleTallItalicCaption1";
  v1[255] = &unk_1ED082278;
  v2[255] = @"UICTFontTextStyleTallEmphasizedCaption1";
  v1[256] = &unk_1ED082290;
  v2[256] = @"UICTFontTextStyleTallEmphasizedItalicCaption1";
  v1[257] = &unk_1ED0822A8;
  v2[257] = @"UICTFontTextStyleEmphasizedItalicCaption2";
  v1[258] = &unk_1ED0822C0;
  v2[258] = @"UICTFontTextStyleShortEmphasizedItalicCaption2";
  v1[259] = &unk_1ED0822D8;
  v2[259] = @"UICTFontTextStyleTallCaption2";
  v1[260] = &unk_1ED0822F0;
  v2[260] = @"UICTFontTextStyleTallItalicCaption2";
  v1[261] = &unk_1ED082308;
  v2[261] = @"UICTFontTextStyleTallEmphasizedCaption2";
  v1[262] = &unk_1ED082320;
  v2[262] = @"UICTFontTextStyleTallEmphasizedItalicCaption2";
  v1[263] = &unk_1ED082338;
  v2[263] = @"UICTFontTextStyleItalicExtraLargeTitle";
  v1[264] = &unk_1ED082350;
  v2[264] = @"UICTFontTextStyleEmphasizedItalicExtraLargeTitle";
  v1[265] = &unk_1ED082368;
  v2[265] = @"UICTFontTextStyleItalicExtraLargeTitle2";
  v1[266] = &unk_1ED082380;
  v2[266] = @"UICTFontTextStyleEmphasizedItalicExtraLargeTitle2";
  void v1[267] = &unk_1ED082398;
  v2[267] = @"UICTFontTextStyleCondensedHeadline";
  v1[268] = &unk_1ED0823B0;
  void v2[268] = @"UICTFontTextStyleCondensedTitle1";
  v1[269] = &unk_1ED0823C8;
  v2[269] = @"UICTFontTextStyleCondensedTitle2";
  v1[270] = &unk_1ED0823E0;
  v2[270] = @"UICTFontTextStyleCondensedTitle3";
  v1[271] = &unk_1ED0823F8;
  v2[271] = @"UICTFontTextStyleCondensedBody";
  v1[272] = &unk_1ED082410;
  v2[272] = @"UICTFontTextStylePreferredSizeRegular";
  v1[273] = &unk_1ED082428;
  v2[273] = @"UICTFontTextStylePreferredSizeBold";
  id result = (id)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v2 forKeys:v1 count:274];
  qword_1EB2CDB78 = (uint64_t)result;
  return result;
}

id ___Z28UITypeForTextStyleDictionaryv_block_invoke()
{
  v2[282] = *MEMORY[0x1E4F143B8];
  v1[0] = @"CTFontRegularUsage";
  v1[1] = @"CTFontEmphasizedUsage";
  v2[0] = &unk_1ED080A90;
  v2[1] = &unk_1ED080AA8;
  v1[2] = @"UICTFontTextStyleHeadline1";
  v1[3] = @"UICTFontTextStyleShortHeadline1";
  v2[2] = &unk_1ED080AC0;
  v2[3] = &unk_1ED080AD8;
  v1[4] = @"UICTFontTextStyleEmphasizedSubhead1";
  v1[5] = @"UICTFontTextStyleSubhead1";
  v2[4] = &unk_1ED080AF0;
  v2[5] = &unk_1ED080B08;
  v1[6] = @"UICTFontTextStyleItalicSubhead1";
  v1[7] = @"UICTFontTextStyleShortEmphasizedSubhead1";
  v2[6] = &unk_1ED080B20;
  v2[7] = &unk_1ED080B38;
  v1[8] = @"UICTFontTextStyleShortSubhead1";
  v1[9] = @"UICTFontTextStyleShortItalicSubhead1";
  v2[8] = &unk_1ED080B50;
  v2[9] = &unk_1ED080B68;
  v1[10] = @"CTFontObliqueUsage";
  v1[11] = @"CTFontEmphasizedObliqueUsage";
  v2[10] = &unk_1ED080B80;
  v2[11] = &unk_1ED080B98;
  v1[12] = @"UICTFontTextStyleHeadline";
  v1[13] = @"UICTFontTextStyleShortHeadline";
  v2[12] = &unk_1ED080AC0;
  v2[13] = &unk_1ED080AD8;
  v1[14] = @"UICTFontTextStyleHeadline2";
  v1[15] = @"UICTFontTextStyleItalicHeadline2";
  v2[14] = &unk_1ED080BB0;
  v2[15] = &unk_1ED080BC8;
  v1[16] = @"UICTFontTextStyleShortHeadline2";
  v1[17] = @"UICTFontTextStyleShortItalicHeadline2";
  v2[16] = &unk_1ED080BE0;
  v2[17] = &unk_1ED080BF8;
  v1[18] = @"UICTFontTextStyleEmphasizedBody";
  v1[19] = @"UICTFontTextStyleBody";
  v2[18] = &unk_1ED080C10;
  v2[19] = &unk_1ED080C28;
  v1[20] = @"UICTFontTextStyleEmphasizedItalicBody";
  v1[21] = @"UICTFontTextStyleItalicBody";
  v2[20] = &unk_1ED080C40;
  v2[21] = &unk_1ED080C58;
  v1[22] = @"UICTFontTextStyleShortEmphasizedBody";
  v1[23] = @"UICTFontTextStyleShortBody";
  v2[22] = &unk_1ED080C70;
  v2[23] = &unk_1ED080C88;
  v1[24] = @"UICTFontTextStyleShortEmphasizedItalicBody";
  v1[25] = @"UICTFontTextStyleShortItalicBody";
  v2[24] = &unk_1ED080CA0;
  v2[25] = &unk_1ED080CB8;
  v1[26] = @"UICTFontTextStyleEmphasizedSubhead";
  v1[27] = @"UICTFontTextStyleSubhead";
  v2[26] = &unk_1ED080AF0;
  v2[27] = &unk_1ED080B08;
  v1[28] = @"UICTFontTextStyleItalicSubhead";
  v1[29] = @"UICTFontTextStyleShortEmphasizedSubhead";
  v2[28] = &unk_1ED080B20;
  v2[29] = &unk_1ED080B38;
  v1[30] = @"UICTFontTextStyleShortSubhead";
  v1[31] = @"UICTFontTextStyleShortItalicSubhead";
  v2[30] = &unk_1ED080B50;
  v2[31] = &unk_1ED080B68;
  v1[32] = @"UICTFontTextStyleEmphasizedSubhead2";
  v1[33] = @"UICTFontTextStyleSubhead2";
  v2[32] = &unk_1ED080CD0;
  v2[33] = &unk_1ED080CE8;
  v1[34] = @"UICTFontTextStyleItalicSubhead2";
  v1[35] = @"UICTFontTextStyleShortEmphasizedSubhead2";
  v2[34] = &unk_1ED080D00;
  v2[35] = &unk_1ED080D18;
  v1[36] = @"UICTFontTextStyleShortSubhead2";
  v1[37] = @"UICTFontTextStyleShortItalicSubhead2";
  v2[36] = &unk_1ED080D30;
  v2[37] = &unk_1ED080D48;
  v1[38] = @"UICTFontTextStyleEmphasizedFootnote";
  v1[39] = @"UICTFontTextStyleFootnote";
  v2[38] = &unk_1ED080D60;
  v2[39] = &unk_1ED080D78;
  v1[40] = @"UICTFontTextStyleItalicFootnote";
  v1[41] = @"UICTFontTextStyleShortEmphasizedFootnote";
  v2[40] = &unk_1ED080D90;
  v2[41] = &unk_1ED080DA8;
  v1[42] = @"UICTFontTextStyleShortFootnote";
  v1[43] = @"UICTFontTextStyleShortItalicFootnote";
  v2[42] = &unk_1ED080DC0;
  v2[43] = &unk_1ED080DD8;
  v1[44] = @"UICTFontTextStyleEmphasizedCaption1";
  v1[45] = @"UICTFontTextStyleCaption1";
  v2[44] = &unk_1ED080DF0;
  v2[45] = &unk_1ED080E08;
  v1[46] = @"UICTFontTextStyleItalicCaption1";
  v1[47] = @"UICTFontTextStyleShortEmphasizedCaption1";
  v2[46] = &unk_1ED080E20;
  v2[47] = &unk_1ED080E38;
  v1[48] = @"UICTFontTextStyleShortCaption1";
  v1[49] = @"UICTFontTextStyleShortItalicCaption1";
  v2[48] = &unk_1ED080E50;
  v2[49] = &unk_1ED080E68;
  v1[50] = @"UICTFontTextStyleEmphasizedCaption2";
  v1[51] = @"UICTFontTextStyleCaption2";
  v2[50] = &unk_1ED080E80;
  v2[51] = &unk_1ED080E98;
  v1[52] = @"UICTFontTextStyleItalicCaption2";
  v1[53] = @"UICTFontTextStyleTallEmphasizedBody";
  v2[52] = &unk_1ED080EB0;
  v2[53] = &unk_1ED080EC8;
  v1[54] = @"UICTFontTextStyleTallBody";
  v1[55] = @"UICTFontTextStyleTallEmphasizedItalicBody";
  v2[54] = &unk_1ED080EE0;
  v2[55] = &unk_1ED080EF8;
  v1[56] = @"UICTFontTextStyleTallItalicBody";
  v1[57] = @"UICTFontTextStyleItalicHeadline";
  v2[56] = &unk_1ED080F10;
  v2[57] = &unk_1ED080F28;
  v1[58] = @"UICTFontTextStyleShortItalicHeadline";
  v1[59] = @"CTFontThinUsage";
  v2[58] = &unk_1ED080F40;
  v2[59] = &unk_1ED080F58;
  v1[60] = @"CTFontLightUsage";
  v1[61] = @"CTFontUltraLightUsage";
  v2[60] = &unk_1ED080F70;
  v2[61] = &unk_1ED080F88;
  v1[62] = @"CTFontMediumUsage";
  v1[63] = @"CTFontDemiUsage";
  v2[62] = &unk_1ED080FA0;
  v2[63] = &unk_1ED080FB8;
  v1[64] = @"CTFontBoldUsage";
  v2[64] = &unk_1ED080FD0;
  v1[65] = @"CTFontHeavyUsage";
  v2[65] = &unk_1ED080FE8;
  v1[66] = @"CTFontBlackUsage";
  v2[66] = &unk_1ED081000;
  v1[67] = @"UICTFontTextStyleCallout";
  v2[67] = &unk_1ED081018;
  v1[68] = @"UICTFontTextStyleItalicCallout";
  v2[68] = &unk_1ED081030;
  v1[69] = @"UICTFontTextStyleEmphasizedCallout";
  v2[69] = &unk_1ED081048;
  v1[70] = @"UICTFontTextStyleEmphasizedItalicCallout";
  v2[70] = &unk_1ED081060;
  v1[71] = @"UICTFontTextStyleShortCallout";
  v2[71] = &unk_1ED081078;
  v1[72] = @"UICTFontTextStyleShortItalicCallout";
  v2[72] = &unk_1ED081090;
  v1[73] = @"UICTFontTextStyleShortEmphasizedCallout";
  v2[73] = &unk_1ED0810A8;
  v1[74] = @"UICTFontTextStyleShortEmphasizedItalicCallout";
  v2[74] = &unk_1ED0810C0;
  v1[75] = @"UICTFontTextStyleTallCallout";
  v2[75] = &unk_1ED0810D8;
  v1[76] = @"UICTFontTextStyleTallItalicCallout";
  v2[76] = &unk_1ED0810F0;
  v1[77] = @"UICTFontTextStyleTallEmphasizedCallout";
  v2[77] = &unk_1ED081108;
  v1[78] = @"UICTFontTextStyleTallEmphasizedItalicCallout";
  v2[78] = &unk_1ED081120;
  v1[79] = @"UICTFontTextStyleEmphasizedFootnote2";
  v2[79] = &unk_1ED081138;
  v1[80] = @"UICTFontTextStyleFootnote2";
  v2[80] = &unk_1ED081150;
  v1[81] = @"UICTFontTextStyleItalicFootnote2";
  v2[81] = &unk_1ED081168;
  v1[82] = @"UICTFontTextStyleShortEmphasizedFootnote2";
  v2[82] = &unk_1ED081180;
  v1[83] = @"UICTFontTextStyleShortFootnote2";
  v2[83] = &unk_1ED081198;
  v1[84] = @"UICTFontTextStyleShortItalicFootnote2";
  v2[84] = &unk_1ED0811B0;
  v1[85] = @"UICTFontTextStyleShortEmphasizedCaption2";
  v2[85] = &unk_1ED0811C8;
  v1[86] = @"UICTFontTextStyleShortCaption2";
  v2[86] = &unk_1ED0811E0;
  v1[87] = @"UICTFontTextStyleShortItalicCaption2";
  v2[87] = &unk_1ED0811F8;
  v1[88] = @"CTFontThinItalicUsage";
  v2[88] = &unk_1ED081210;
  v1[89] = @"CTFontLightItalicUsage";
  v2[89] = &unk_1ED081228;
  v1[90] = @"CTFontUltraLightItalicUsage";
  v2[90] = &unk_1ED081240;
  v1[91] = @"CTFontMediumItalicUsage";
  v2[91] = &unk_1ED081258;
  v1[92] = @"CTFontDemiItalicUsage";
  v2[92] = &unk_1ED081270;
  v1[93] = @"CTFontBoldItalicUsage";
  v2[93] = &unk_1ED081288;
  v1[94] = @"CTFontHeavyItalicUsage";
  v2[94] = &unk_1ED0812A0;
  v1[95] = @"CTFontBlackItalicUsage";
  v2[95] = &unk_1ED0812B8;
  v1[96] = @"CTFontTextStyleUltraLight";
  v2[96] = &unk_1ED0812D0;
  v1[97] = @"CTFontTextStyleThin";
  v2[97] = &unk_1ED0812E8;
  v1[98] = @"CTFontSystemUIAlternateRegular";
  v2[98] = &unk_1ED081300;
  v1[99] = @"CTFontSystemUIAlternateBold";
  v2[99] = &unk_1ED081318;
  v1[100] = @"CTFontSystemUIAlternateThin";
  v2[100] = &unk_1ED081330;
  v1[101] = @"CTFontSystemUIAlternateLight";
  v2[101] = &unk_1ED081348;
  v1[102] = @"CTFontSystemUIAlternateUltraLight";
  v2[102] = &unk_1ED081360;
  v1[103] = @"CTFontSystemUIAlternateMedium";
  v2[103] = &unk_1ED081378;
  v1[104] = @"CTFontSystemUIAlternateSemiBold";
  v2[104] = &unk_1ED081390;
  v1[105] = @"CTFontSystemUIAlternateHeavy";
  v2[105] = &unk_1ED0813A8;
  v1[106] = @"CTFontSystemUIAlternateBlack";
  v2[106] = &unk_1ED0813C0;
  v1[107] = @"CTFontSystemUIAlternateItalic";
  v2[107] = &unk_1ED0813D8;
  v1[108] = @"CTFontSystemUIAlternateBoldItalic";
  v2[108] = &unk_1ED0813F0;
  v1[109] = @"CTFontSystemUIAlternateThinItalic";
  v2[109] = &unk_1ED081408;
  v1[110] = @"CTFontSystemUIAlternateLightItalic";
  v2[110] = &unk_1ED081420;
  v1[111] = @"CTFontSystemUIAlternateUltraLightItalic";
  v2[111] = &unk_1ED081438;
  v1[112] = @"CTFontSystemUIAlternateMediumItalic";
  v2[112] = &unk_1ED081450;
  v1[113] = @"CTFontSystemUIAlternateSemiBoldItalic";
  v2[113] = &unk_1ED081468;
  v1[114] = @"CTFontSystemUIAlternateHeavyItalic";
  v2[114] = &unk_1ED081480;
  v1[115] = @"CTFontSystemUIAlternateBlackItalic";
  v2[115] = &unk_1ED081498;
  v1[116] = @"CTFontSystemUIRoundedUltralight";
  v2[116] = &unk_1ED0814B0;
  v1[117] = @"CTFontSystemUIRoundedThin";
  v2[117] = &unk_1ED0814C8;
  v1[118] = @"CTFontSystemUIRoundedLight";
  v2[118] = &unk_1ED0814E0;
  v1[119] = @"CTFontSystemUIRoundedRegular";
  v2[119] = &unk_1ED0814F8;
  v1[120] = @"CTFontSystemUIRoundedMedium";
  v2[120] = &unk_1ED081510;
  v1[121] = @"CTFontSystemUIRoundedSemibold";
  v2[121] = &unk_1ED081528;
  v1[122] = @"CTFontSystemUIRoundedBold";
  v2[122] = &unk_1ED081540;
  v1[123] = @"CTFontSystemUIRoundedHeavy";
  v2[123] = &unk_1ED081558;
  v1[124] = @"CTFontSystemUIRoundedBlack";
  v2[124] = &unk_1ED081570;
  v2[152] = &unk_1ED081810;
  v1[153] = @"UICTFontTextStyleShortTitle3";
  v2[151] = &unk_1ED0817F8;
  v1[152] = @"UICTFontTextStyleEmphasizedItalicTitle3";
  v2[150] = &unk_1ED0817E0;
  v1[151] = @"UICTFontTextStyleEmphasizedTitle3";
  v1[125] = @"UICTFontTextStyleTitle1";
  v1[150] = @"UICTFontTextStyleItalicTitle3";
  v2[125] = &unk_1ED081588;
  v1[149] = @"UICTFontTextStyleTitle3";
  v2[149] = &unk_1ED0817C8;
  v1[148] = @"UICTFontTextStyleTallEmphasizedItalicTitle2";
  v2[148] = &unk_1ED0817B0;
  v1[147] = @"UICTFontTextStyleTallEmphasizedTitle2";
  v2[147] = &unk_1ED081798;
  v1[146] = @"UICTFontTextStyleTallItalicTitle2";
  v2[146] = &unk_1ED081780;
  v1[145] = @"UICTFontTextStyleTallTitle2";
  v2[145] = &unk_1ED081768;
  v1[144] = @"UICTFontTextStyleShortEmphasizedItalicTitle2";
  v2[144] = &unk_1ED081750;
  v1[143] = @"UICTFontTextStyleShortEmphasizedTitle2";
  v2[143] = &unk_1ED081738;
  v1[142] = @"UICTFontTextStyleShortItalicTitle2";
  v2[142] = &unk_1ED081720;
  v1[141] = @"UICTFontTextStyleShortTitle2";
  v2[141] = &unk_1ED081708;
  v1[140] = @"UICTFontTextStyleEmphasizedItalicTitle2";
  v2[140] = &unk_1ED0816F0;
  v1[139] = @"UICTFontTextStyleEmphasizedTitle2";
  v2[139] = &unk_1ED0816D8;
  v1[138] = @"UICTFontTextStyleItalicTitle2";
  v2[138] = &unk_1ED0816C0;
  v1[126] = @"UICTFontTextStyleItalicTitle1";
  v2[137] = &unk_1ED0816A8;
  v2[126] = &unk_1ED0815A0;
  v2[136] = &unk_1ED081690;
  v1[137] = @"UICTFontTextStyleTitle2";
  v2[135] = &unk_1ED081678;
  v1[136] = @"UICTFontTextStyleTallEmphasizedItalicTitle1";
  v2[134] = &unk_1ED081660;
  v1[135] = @"UICTFontTextStyleTallEmphasizedTitle1";
  v2[133] = &unk_1ED081648;
  v1[134] = @"UICTFontTextStyleTallItalicTitle1";
  v2[132] = &unk_1ED081630;
  v1[133] = @"UICTFontTextStyleTallTitle1";
  v2[131] = &unk_1ED081618;
  v1[132] = @"UICTFontTextStyleShortEmphasizedItalicTitle1";
  v2[130] = &unk_1ED081600;
  v1[131] = @"UICTFontTextStyleShortEmphasizedTitle1";
  v2[129] = &unk_1ED0815E8;
  v1[130] = @"UICTFontTextStyleShortItalicTitle1";
  v2[128] = &unk_1ED0815D0;
  v1[129] = @"UICTFontTextStyleShortTitle1";
  v2[127] = &unk_1ED0815B8;
  v1[128] = @"UICTFontTextStyleEmphasizedItalicTitle1";
  v1[127] = @"UICTFontTextStyleEmphasizedTitle1";
  v2[153] = &unk_1ED081828;
  v1[154] = @"UICTFontTextStyleShortItalicTitle3";
  v2[154] = &unk_1ED081840;
  v1[155] = @"UICTFontTextStyleShortEmphasizedTitle3";
  v2[155] = &unk_1ED081858;
  v1[156] = @"UICTFontTextStyleShortEmphasizedItalicTitle3";
  v2[156] = &unk_1ED081870;
  v1[157] = @"UICTFontTextStyleTallTitle3";
  v2[157] = &unk_1ED081888;
  v1[158] = @"UICTFontTextStyleTallItalicTitle3";
  v2[158] = &unk_1ED0818A0;
  v1[159] = @"UICTFontTextStyleTallEmphasizedTitle3";
  v2[159] = &unk_1ED0818B8;
  v1[160] = @"UICTFontTextStyleTallEmphasizedItalicTitle3";
  v2[160] = &unk_1ED0818D0;
  v1[161] = @"UICTFontTextStyleSubtitle3";
  v2[161] = &unk_1ED0818E8;
  v1[162] = @"UICTFontTextStyleSubtitle2";
  v2[162] = &unk_1ED081900;
  v1[163] = @"UICTFontTextStyleSubtitle1";
  v2[163] = &unk_1ED081918;
  v1[164] = @"UICTFontTextStyleSection1";
  v2[164] = &unk_1ED081930;
  v1[165] = @"UICTFontTextStyleSection2";
  v2[165] = &unk_1ED081948;
  v1[166] = @"UICTFontTextStyleSection3";
  v2[166] = &unk_1ED081960;
  v1[167] = @"UICTFontTextStyleTitle4";
  v2[167] = &unk_1ED081978;
  v1[168] = @"UICTFontTextStyleHeadline3";
  v2[168] = &unk_1ED081990;
  v1[169] = @"UICTFontTextStyleItalicSubtitle1";
  v2[169] = &unk_1ED0819A8;
  v1[170] = @"UICTFontTextStyleEmphasizedSubtitle1";
  v2[170] = &unk_1ED0819C0;
  v1[171] = @"UICTFontTextStyleEmphasizedItalicSubtitle1";
  v2[171] = &unk_1ED0819D8;
  v1[172] = @"UICTFontTextStyleTitle0";
  v2[172] = &unk_1ED0819F0;
  v1[173] = @"UICTFontTextStyleEmphasizedTitle0";
  v2[173] = &unk_1ED081A08;
  v1[174] = @"UICTFontTextStyleShortTitle0";
  v2[174] = &unk_1ED081A20;
  v1[175] = @"UICTFontTextStyleShortEmphasizedTitle0";
  v2[175] = &unk_1ED081A38;
  v1[176] = @"UICTFontTextStyleTallTitle0";
  v2[176] = &unk_1ED081A50;
  v1[177] = @"UICTFontTextStyleTallEmphasizedTitle0";
  v2[177] = &unk_1ED081A68;
  v1[178] = @"UICTFontTextStyleEmphasizedHeadline";
  v2[178] = &unk_1ED081A80;
  v1[179] = @"UICTFontTextStyleEmphasizedItalicHeadline";
  v2[179] = &unk_1ED081A98;
  v1[180] = @"UICTFontTextStyleShortEmphasizedHeadline";
  v2[180] = &unk_1ED081AB0;
  v1[181] = @"UICTFontTextStyleShortEmphasizedItalicHeadline";
  v2[181] = &unk_1ED081AC8;
  v1[182] = @"UICTFontTextStyleTallHeadline";
  v2[182] = &unk_1ED081AE0;
  v1[183] = @"UICTFontTextStyleTallEmphasizedHeadline";
  v2[183] = &unk_1ED081AF8;
  v1[184] = @"UICTFontTextStyleCaption3";
  v2[184] = &unk_1ED081B10;
  v1[185] = @"UICTFontTextStyleEmphasizedCaption3";
  v2[185] = &unk_1ED081B28;
  v1[186] = @"CTFontSystemUICondensedRegular";
  v2[186] = &unk_1ED081B40;
  v1[187] = @"CTFontSystemUICondensedBold";
  v2[187] = &unk_1ED081B58;
  v1[188] = @"CTFontSystemUICondensedThin";
  v2[188] = &unk_1ED081B70;
  v1[189] = @"CTFontSystemUICondensedLight";
  v2[189] = &unk_1ED081B88;
  v1[190] = @"CTFontSystemUICondensedUltraLight";
  v2[190] = &unk_1ED081BA0;
  v1[191] = @"CTFontSystemUICondensedMedium";
  v2[191] = &unk_1ED081BB8;
  v1[192] = @"CTFontSystemUICondensedSemiBold";
  v2[192] = &unk_1ED081BD0;
  v1[193] = @"CTFontSystemUICondensedHeavy";
  v2[193] = &unk_1ED081BE8;
  v1[194] = @"CTFontSystemUICondensedBlack";
  v2[194] = &unk_1ED081C00;
  v1[195] = @"CTFontSystemUISerifRegular";
  v2[195] = &unk_1ED081C18;
  v1[196] = @"CTFontSystemUISerifMedium";
  v2[196] = &unk_1ED081C30;
  v1[197] = @"CTFontSystemUISerifSemibold";
  v2[197] = &unk_1ED081C48;
  v1[198] = @"CTFontSystemUISerifBold";
  v2[198] = &unk_1ED081C60;
  v1[199] = @"CTFontSystemUISerifHeavy";
  v2[199] = &unk_1ED081C78;
  v1[200] = @"CTFontSystemUISerifBlack";
  v2[200] = &unk_1ED081C90;
  v1[201] = @"CTFontSystemUISerifItalic";
  v2[201] = &unk_1ED081CA8;
  v1[202] = @"CTFontSystemUISerifMediumItalic";
  v2[202] = &unk_1ED081CC0;
  v1[203] = @"CTFontSystemUISerifSemiboldItalic";
  v2[203] = &unk_1ED081CD8;
  v1[204] = @"CTFontSystemUISerifBoldItalic";
  v2[204] = &unk_1ED081CF0;
  v1[205] = @"CTFontSystemUISerifHeavyItalic";
  v2[205] = &unk_1ED081D08;
  v1[206] = @"CTFontSystemUISerifBlackItalic";
  v2[206] = &unk_1ED081D20;
  v1[207] = @"CTFontSystemUIMonospacedLight";
  v2[207] = &unk_1ED081D38;
  v1[208] = @"CTFontSystemUIMonospacedRegular";
  v2[208] = &unk_1ED081D50;
  v1[209] = @"CTFontSystemUIMonospacedMedium";
  v2[209] = &unk_1ED081D68;
  v1[210] = @"CTFontSystemUIMonospacedSemibold";
  v2[210] = &unk_1ED081D80;
  v1[211] = @"CTFontSystemUIMonospacedBold";
  v2[211] = &unk_1ED081D98;
  v1[212] = @"CTFontSystemUIMonospacedHeavy";
  v2[212] = &unk_1ED081DB0;
  v1[213] = @"CTFontSystemUIMonospacedLightItalic";
  v2[213] = &unk_1ED081DC8;
  v1[214] = @"CTFontSystemUIMonospacedRegularItalic";
  v2[214] = &unk_1ED081DE0;
  v1[215] = @"CTFontSystemUIMonospacedMediumItalic";
  v2[215] = &unk_1ED081DF8;
  v1[216] = @"CTFontSystemUIMonospacedSemiboldItalic";
  v2[216] = &unk_1ED081E10;
  v1[217] = @"CTFontSystemUIMonospacedBoldItalic";
  v2[217] = &unk_1ED081E28;
  v1[218] = @"CTFontSystemUIMonospacedHeavyItalic";
  v2[218] = &unk_1ED081E40;
  v1[219] = @"UICTFontTextStyleExtraLargeTitle";
  v2[219] = &unk_1ED081E58;
  v1[220] = @"UICTFontTextStyleEmphasizedExtraLargeTitle";
  v2[220] = &unk_1ED081E70;
  v1[221] = @"UICTFontTextStyleExtraLargeTitle2";
  v2[221] = &unk_1ED081E88;
  v1[222] = @"UICTFontTextStyleEmphasizedExtraLargeTitle2";
  v2[222] = &unk_1ED081EA0;
  v1[223] = @"CTFontSystemUICompactRoundedUltralight";
  v2[223] = &unk_1ED081EB8;
  v1[224] = @"CTFontSystemUICompactRoundedThin";
  v2[224] = &unk_1ED081ED0;
  v1[225] = @"CTFontSystemUICompactRoundedLight";
  v2[225] = &unk_1ED081EE8;
  v1[226] = @"CTFontSystemUICompactRoundedRegular";
  v2[226] = &unk_1ED081F00;
  v1[227] = @"CTFontSystemUICompactRoundedMedium";
  v2[227] = &unk_1ED081F18;
  v1[228] = @"CTFontSystemUICompactRoundedSemibold";
  v2[228] = &unk_1ED081F30;
  v1[229] = @"CTFontSystemUICompactRoundedBold";
  v2[229] = &unk_1ED081F48;
  v1[230] = @"CTFontSystemUICompactRoundedHeavy";
  v2[230] = &unk_1ED081F60;
  v1[231] = @"CTFontSystemUICompactRoundedBlack";
  v2[231] = &unk_1ED081F78;
  v1[232] = @"CTFontSystemUICoreRegular";
  v2[232] = &unk_1ED081F90;
  v1[233] = @"CTFontSystemUICoreBold";
  v2[233] = &unk_1ED081FA8;
  v1[234] = @"CTFontSystemUICoreThin";
  v2[234] = &unk_1ED081FC0;
  v1[235] = @"CTFontSystemUICoreLight";
  v2[235] = &unk_1ED081FD8;
  v1[236] = @"CTFontSystemUICoreUltraLight";
  v2[236] = &unk_1ED081FF0;
  v1[237] = @"CTFontSystemUICoreMedium";
  v2[237] = &unk_1ED082008;
  v1[238] = @"CTFontSystemUICoreSemiBold";
  v2[238] = &unk_1ED082020;
  v1[239] = @"CTFontSystemUICoreHeavy";
  v2[239] = &unk_1ED082038;
  v1[240] = @"CTFontSystemUICoreBlack";
  v2[240] = &unk_1ED082050;
  v1[241] = @"CTFontSystemUICoreItalic";
  v2[241] = &unk_1ED082068;
  v1[242] = @"CTFontSystemUICoreBoldItalic";
  v2[242] = &unk_1ED082080;
  v1[243] = @"CTFontSystemUICoreThinItalic";
  v2[243] = &unk_1ED082098;
  v1[244] = @"CTFontSystemUICoreLightItalic";
  v2[244] = &unk_1ED0820B0;
  v1[245] = @"CTFontSystemUICoreUltraLightItalic";
  v2[245] = &unk_1ED0820C8;
  v1[246] = @"CTFontSystemUICoreMediumItalic";
  v2[246] = &unk_1ED0820E0;
  v1[247] = @"CTFontSystemUICoreSemiBoldItalic";
  v2[247] = &unk_1ED0820F8;
  v1[248] = @"CTFontSystemUICoreHeavyItalic";
  v2[248] = &unk_1ED082110;
  v1[249] = @"CTFontSystemUICoreBlackItalic";
  v2[249] = &unk_1ED082128;
  v1[250] = @"CTFontSystemUICoreCondensedRegular";
  v2[250] = &unk_1ED082140;
  v1[251] = @"CTFontSystemUICoreCondensedBold";
  v2[251] = &unk_1ED082158;
  v1[252] = @"CTFontSystemUICoreCondensedThin";
  v2[252] = &unk_1ED082170;
  v1[253] = @"CTFontSystemUICoreCondensedLight";
  v2[253] = &unk_1ED082188;
  v1[254] = @"CTFontSystemUICoreCondensedUltraLight";
  v2[254] = &unk_1ED0821A0;
  v1[255] = @"CTFontSystemUICoreCondensedMedium";
  v2[255] = &unk_1ED0821B8;
  v1[256] = @"CTFontSystemUICoreCondensedSemiBold";
  v2[256] = &unk_1ED0821D0;
  v1[257] = @"CTFontSystemUICoreCondensedHeavy";
  v2[257] = &unk_1ED0821E8;
  v1[258] = @"CTFontSystemUICoreCondensedBlack";
  v2[258] = &unk_1ED082200;
  v1[259] = @"UICTFontTextStyleEmphasizedItalicCaption1";
  v2[259] = &unk_1ED082218;
  v1[260] = @"UICTFontTextStyleShortEmphasizedItalicCaption1";
  v2[260] = &unk_1ED082230;
  v1[261] = @"UICTFontTextStyleTallCaption1";
  v2[261] = &unk_1ED082248;
  v1[262] = @"UICTFontTextStyleTallItalicCaption1";
  v2[262] = &unk_1ED082260;
  v1[263] = @"UICTFontTextStyleTallEmphasizedCaption1";
  v2[263] = &unk_1ED082278;
  v1[264] = @"UICTFontTextStyleTallEmphasizedItalicCaption1";
  v2[264] = &unk_1ED082290;
  v1[265] = @"UICTFontTextStyleEmphasizedItalicCaption2";
  v2[265] = &unk_1ED0822A8;
  v1[266] = @"UICTFontTextStyleShortEmphasizedItalicCaption2";
  v2[266] = &unk_1ED0822C0;
  void v1[267] = @"UICTFontTextStyleTallCaption2";
  v2[267] = &unk_1ED0822D8;
  v1[268] = @"UICTFontTextStyleTallItalicCaption2";
  void v2[268] = &unk_1ED0822F0;
  v1[269] = @"UICTFontTextStyleTallEmphasizedCaption2";
  v2[269] = &unk_1ED082308;
  v1[270] = @"UICTFontTextStyleTallEmphasizedItalicCaption2";
  v2[270] = &unk_1ED082320;
  v1[271] = @"UICTFontTextStyleItalicExtraLargeTitle";
  v2[271] = &unk_1ED082338;
  v1[272] = @"UICTFontTextStyleEmphasizedItalicExtraLargeTitle";
  v2[272] = &unk_1ED082350;
  v1[273] = @"UICTFontTextStyleItalicExtraLargeTitle2";
  v2[273] = &unk_1ED082368;
  void v1[274] = @"UICTFontTextStyleEmphasizedItalicExtraLargeTitle2";
  v2[274] = &unk_1ED082380;
  v1[275] = @"UICTFontTextStyleCondensedHeadline";
  void v2[275] = &unk_1ED082398;
  v1[276] = @"UICTFontTextStyleCondensedTitle1";
  v2[276] = &unk_1ED0823B0;
  v1[277] = @"UICTFontTextStyleCondensedTitle2";
  v2[277] = &unk_1ED0823C8;
  v1[278] = @"UICTFontTextStyleCondensedTitle3";
  v2[278] = &unk_1ED0823E0;
  v1[279] = @"UICTFontTextStyleCondensedBody";
  v2[279] = &unk_1ED0823F8;
  v1[280] = @"UICTFontTextStylePreferredSizeRegular";
  v2[280] = &unk_1ED082410;
  v1[281] = @"UICTFontTextStylePreferredSizeBold";
  v2[281] = &unk_1ED082428;
  id result = (id)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v2 forKeys:v1 count:282];
  qword_1EB2CDB68 = (uint64_t)result;
  return result;
}

void ___ZL59CTFontDescriptorMatchFontDescriptorsWithProgressHandlerCorePK9__CFArrayPK7__CFSetmU13block_pointerFb29CTFontDescriptorMatchingStatePK14__CFDictionaryE_block_invoke(uint64_t a1)
{
  location[16] = *(id *)MEMORY[0x1E4F143B8];
  CFSetRef context = (void *)MEMORY[0x185327A40]();
  uint64_t v2 = *(void *)(a1 + 32);
  if (!v2)
  {
LABEL_222:
    BOOL v139 = 0;
    goto LABEL_218;
  }
  uint64_t v3 = a1;
  uint64_t v4 = *(void *)(a1 + 40);
  if (!-[FontAssetDownloadManager callProgressCallback:](v2, 0)) {
    goto LABEL_217;
  }
  id val = (id)v2;
  uint64_t v144 = v3;
  if ((v4 & 2) != 0)
  {
    CFStringRef explicit = (void *)atomic_load_explicit((atomic_ullong *volatile)(v2 + 8), memory_order_acquire);
  }
  else
  {
    CFStringRef explicit = (void *)[MEMORY[0x1E4F1CA48] array];
    CFArrayRef v6 = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)(v2 + 8), memory_order_acquire);
    if (v6)
    {
      CFIndex Count = CFArrayGetCount(v6);
      if (Count)
      {
        CFIndex v8 = Count;
        CFIndex v9 = 0;
        CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        while (1)
        {
          int ValueAtIndex = CFArrayGetValueAtIndex(v6, v9);
          MatchingFontDescriptorsWithOptions = (void *)CTFontDescriptorCreateMatchingFontDescriptorsWithOptions((uint64_t)ValueAtIndex, (const __CFSet *)atomic_load_explicit((atomic_ullong *volatile)val + 2, memory_order_acquire), 512);
          CFArrayRef v12 = MatchingFontDescriptorsWithOptions;
          CFArrayRef v13 = v12;
          if (!v12) {
            break;
          }
          CFIndex v14 = CFArrayGetCount(v12);

          if (!v14) {
            goto LABEL_27;
          }
          if (GSFontLibraryCore(0) && getGSFontUpdateFontAssetLastAccessedTimeSymbolLoc())
          {
            CFMutableArrayRef Mutable = CFArrayCreateMutable(allocator, 0, MEMORY[0x1E4F1D510]);
            if (MatchingFontDescriptorsWithOptions)
            {
              CFIndex v16 = CFArrayGetCount((CFArrayRef)MatchingFontDescriptorsWithOptions);
              if (v16)
              {
                for (CFIndex i = 0; i != v16; ++i)
                {
                  uint64_t v18 = CFArrayGetValueAtIndex((CFArrayRef)MatchingFontDescriptorsWithOptions, i);
                  uint64_t v19 = *((void *)v18 + 5);
                  if ((*(_DWORD *)(v19 + 16) & 0x80000000) == 0) {
                    TDescriptor::InitBaseFont(*((TDescriptor **)v18 + 5), 0, 0.0);
                  }
                  unint64_t v20 = atomic_load_explicit((atomic_ullong *volatile)(v19 + 32), memory_order_acquire);
                  location[0] = (id)0xAAAAAAAAAAAAAAAALL;
                  if (v20) {
                    (*(void (**)(id *__return_ptr))(*(void *)v20 + 200))(location);
                  }
                  else {
                    location[0] = 0;
                  }
                  if (atomic_load_explicit((atomic_ullong *volatile)location, memory_order_acquire))
                  {
                    id v21 = (id)atomic_load_explicit((atomic_ullong *volatile)location, memory_order_acquire);
                    CFArrayAppendValue(Mutable, v21);
                  }
                }
              }
            }
            if (CFArrayGetCount(Mutable) >= 1)
            {
              GSFontUpdateFontAssetLastAccessedTimeSymbolLoc = (void (*)(__CFArray *))getGSFontUpdateFontAssetLastAccessedTimeSymbolLoc();
              if (!GSFontUpdateFontAssetLastAccessedTimeSymbolLoc)
              {
                unsigned __int16 v140 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
                objc_msgSend(v140, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "void gsFontUpdateFontAssetLastAccessedTime(CFArrayRef)"), @"TDescriptorSourceDownloadableAsset.cpp", 52, @"%s", dlerror());
                __break(1u);
                goto LABEL_222;
              }
              GSFontUpdateFontAssetLastAccessedTimeSymbolLoc(Mutable);
            }
          }
LABEL_28:

          if (++v9 == v8) {
            goto LABEL_31;
          }
        }

LABEL_27:
        [explicit addObject:ValueAtIndex];
        goto LABEL_28;
      }
    }
  }
LABEL_31:
  if (![explicit count]) {
    goto LABEL_195;
  }
  id v23 = (void *)*((void *)val + 4);
  if (explicit) {
    [v23 setObject:explicit forKey:@"CTFontDescriptorMatchingDescriptors"];
  }
  else {
    [v23 removeObjectForKey:@"CTFontDescriptorMatchingDescriptors"];
  }
  long long v189 = 0u;
  long long v190 = 0u;
  *(_OWORD *)frouint64_t m = 0u;
  long long v188 = 0u;
  uint64_t v24 = [explicit countByEnumeratingWithState:from objects:location count:16];
  if (!v24)
  {
    char v36 = 2;
    goto LABEL_61;
  }
  LOBYTE(v25) = 0;
  uint64_t v26 = *(void *)v188;
  LOBYTE(v27) = 1;
  do
  {
    for (uint64_t j = 0; j != v24; ++j)
    {
      if (*(void *)v188 != v26) {
        objc_enumerationMutation(explicit);
      }
      uint64_t v29 = *((void *)from[1] + j);
      if (v27)
      {
        uint64_t v30 = (atomic_ullong *)(*(void *)(v29 + 40) + 8);
        atomic_load_explicit(v30, memory_order_acquire);
        CFDictionaryRef Value = (const __CFDictionary *)atomic_load_explicit(v30, memory_order_acquire);
        if (Value) {
          CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(Value, @"NSCTFontDownloadedAttribute");
        }
        int v27 = [(__CFDictionary *)Value BOOLValue];
        if (v25)
        {
LABEL_48:
          int v25 = 1;
          continue;
        }
      }
      else
      {
        int v27 = 0;
        if (v25) {
          goto LABEL_48;
        }
      }
      uint64_t v32 = (atomic_ullong *)(*(void *)(v29 + 40) + 8);
      atomic_load_explicit(v32, memory_order_acquire);
      CFDictionaryRef v33 = (const __CFDictionary *)atomic_load_explicit(v32, memory_order_acquire);
      if (v33) {
        CFDictionaryRef v33 = (const __CFDictionary *)CFDictionaryGetValue(v33, @"CTFontAllowCellularDownloadAttribute");
      }
      int v25 = [(__CFDictionary *)v33 BOOLValue];
    }
    uint64_t v24 = [explicit countByEnumeratingWithState:from objects:location count:16];
  }
  while (v24);
  if (v27) {
    char v34 = 6;
  }
  else {
    char v34 = 4;
  }
  if (v27) {
    char v35 = 2;
  }
  else {
    char v35 = 0;
  }
  if (v25) {
    char v36 = v34;
  }
  else {
    char v36 = v35;
  }
LABEL_61:
  v172[0] = 0;
  obuint64_t j = +[FontAssetDownloadManager availableMobileAssetsWithOptions:manager:error:]((uint64_t)FontAssetDownloadManager, v36, (uint64_t)val, v172);
  if (obj)
  {
    unsigned int v145 = (void *)[MEMORY[0x1E4F1CA48] array];
    long long v179 = 0u;
    long long v180 = 0u;
    long long v177 = 0u;
    long long v178 = 0u;
    long long v150 = (id *)[obj countByEnumeratingWithState:&v177 objects:&v201 count:16];
    if (v150)
    {
      dsemCGFloat a = *(dispatch_semaphore_t *)v178;
      do
      {
        for (CFIndex k = 0; k != v150; CFIndex k = (id *)((char *)k + 1))
        {
          if (*(dispatch_semaphore_t *)v178 != dsema) {
            objc_enumerationMutation(obj);
          }
          to = *(id **)(*((void *)&v177 + 1) + 8 * (void)k);
          char v154 = (void *)[to attributes];
          CFRange v37 = (void *)[MEMORY[0x1E4F1CA48] array];
          uint64_t v38 = (void *)[MEMORY[0x1E4F1CA48] array];
          id v158 = (id)[v154 objectForKey:@"FontInfo4"];
          uint64_t v39 = [v154 objectForKey:@"FontDesignLanguages"];
          long long v175 = 0u;
          long long v176 = 0u;
          long long v173 = 0u;
          long long v174 = 0u;
          uint64_t v163 = [v158 countByEnumeratingWithState:&v173 objects:v200 count:16];
          if (v163)
          {
            uint64_t v161 = *(void *)v174;
            do
            {
              CFAllocatorRef v40 = 0;
              do
              {
                if (*(void *)v174 != v161)
                {
                  CFAllocatorRef v41 = v40;
                  objc_enumerationMutation(v158);
                  CFAllocatorRef v40 = v41;
                }
                CFAllocatorRef allocatora = v40;
                CFArrayRef v42 = *(NSDictionary **)(*((void *)&v173 + 1) + 8 * (void)v40);
                long long handler = 0u;
                long long v168 = 0u;
                long long v169 = 0u;
                *(_OWORD *)double v170 = 0u;
                uint64_t v43 = [explicit countByEnumeratingWithState:&handler objects:v191 count:16];
                if (v43)
                {
                  uint64_t v44 = *(void *)v168;
                  do
                  {
                    for (uint64_t m = 0; m != v43; ++m)
                    {
                      if (*(void *)v168 != v44) {
                        objc_enumerationMutation(explicit);
                      }
                      uint64_t v46 = *(const __CTFontDescriptor **)(*((void *)&handler + 1) + 8 * m);
                      CFDictionaryRef v47 = CTFontDescriptorCopyAttributes(v46);
                      if (+[FontAssetDownloadManager fontInfo:andAssetDesignLanguages:matchesRequest:]((uint64_t)FontAssetDownloadManager, v42, v39, v47))
                      {
                        [v37 addObject:v46];
                        [v38 addObject:v42];
                      }
                    }
                    uint64_t v43 = [explicit countByEnumeratingWithState:&handler objects:v191 count:16];
                  }
                  while (v43);
                }
                CFAllocatorRef v40 = (CFAllocatorRef)((char *)allocatora + 1);
              }
              while ((CFAllocatorRef)((char *)allocatora + 1) != (CFAllocatorRef)v163);
              uint64_t v163 = [v158 countByEnumeratingWithState:&v173 objects:v200 count:16];
            }
            while (v163);
          }
          if ([v37 count])
          {
            [v145 addObject:to];
            uint64_t v194 = v37;
            uint64_t v195 = (uint64_t)v38;
            objc_msgSend(*((id *)val + 6), "setObject:forKeyedSubscript:", objc_msgSend(MEMORY[0x1E4F1C978], "arrayWithObjects:count:", &v194, 2), v154);
          }
        }
        long long v150 = (id *)[obj countByEnumeratingWithState:&v177 objects:&v201 count:16];
      }
      while (v150);
    }
    BOOL v48 = v145;
  }
  else
  {
    BOOL v48 = 0;
  }
  uint64_t v49 = v48;
  uint64_t v50 = objc_msgSend(NSNumber, "numberWithUnsignedInteger:", objc_msgSend(v48, "count"));
  id v51 = (void *)*((void *)val + 4);
  if (v50) {
    [v51 setObject:v50 forKey:@"CTFontDescriptorMatchingTotalAssetCount"];
  }
  else {
    [v51 removeObjectForKey:@"CTFontDescriptorMatchingTotalAssetCount"];
  }
  [*((id *)val + 4) removeObjectForKey:@"CTFontDescriptorMatchingDescriptors"];
  if (v172[0]) {
    BOOL v52 = obj == 0;
  }
  else {
    BOOL v52 = 0;
  }
  if (v52)
  {
    objc_msgSend(*((id *)val + 4), "setObject:forKey:");
    -[FontAssetDownloadManager callProgressCallback:]((uint64_t)val, 8);
    [*((id *)val + 4) removeObjectForKey:@"CTFontDescriptorMatchingError"];
  }
  self;
  long long v201 = 0u;
  long long v202 = 0u;
  long long v203 = 0u;
  long long v204 = 0u;
  uint64_t v53 = 0;
  uint64_t v54 = [v49 countByEnumeratingWithState:&v201 objects:location count:16];
  if (v54)
  {
    uint64_t v55 = *(void *)v202;
    do
    {
      for (uint64_t n = 0; n != v54; ++n)
      {
        if (*(void *)v202 != v55) {
          objc_enumerationMutation(v49);
        }
        uint64_t v57 = *(void **)(*((void *)&v201 + 1) + 8 * n);
        unint64_t v58 = (void *)[v57 attributes];
        self;
        uint64_t v59 = [v57 state];
        if (unint64_t)(v59 - 2) < 5 && ((0x1Bu >> (v59 - 2)))
        {
          uint64_t v63 = 0;
        }
        else
        {
          double Helper_x8__ASAttributeDownloadSize = gotLoadHelper_x8__ASAttributeDownloadSize(v60);
          uint64_t v63 = objc_msgSend((id)objc_msgSend(v58, "objectForKey:", **(void **)(v62 + 3888), Helper_x8__ASAttributeDownloadSize), "longValue");
        }
        v53 += v63;
      }
      uint64_t v54 = [v49 countByEnumeratingWithState:&v201 objects:location count:16];
    }
    while (v54);
  }
  uint64_t v64 = [NSNumber numberWithLong:v53];
  double v65 = (void *)*((void *)val + 4);
  if (v64) {
    [v65 setObject:v64 forKey:@"CTFontDescriptorMatchingTotalAssetSize"];
  }
  else {
    [v65 removeObjectForKey:@"CTFontDescriptorMatchingTotalAssetSize"];
  }
  dsemaCGFloat a = dispatch_semaphore_create(0);
  uint64_t v181 = 0;
  uint64_t v182 = &v181;
  uint64_t v183 = 0x2020000000;
  char v184 = 1;
  double Helper_x8__ASDownloadPriorityHigh = gotLoadHelper_x8__ASDownloadPriorityHigh(COERCE_DOUBLE(0x2020000000));
  Helper_x8__ASDownloadOptionPrioritCGFloat y = gotLoadHelper_x8__ASDownloadOptionPriority(Helper_x8__ASDownloadPriorityHigh);
  objc_msgSend(v68, "setObject:forKey:", Helper_x8__ASDownloadOptionPriority);
  double Helper_x8__ASDownloadOptionAllowBatteryPower = gotLoadHelper_x8__ASDownloadOptionAllowBatteryPower(v69);
  objc_msgSend(v72, "setObject:forKey:", MEMORY[0x1E4F1CC38], **(void **)(v71 + 3936), Helper_x8__ASDownloadOptionAllowBatteryPower);
  uint64_t v143 = (void *)[v49 count];
  BOOL v146 = (void *)[MEMORY[0x1E4F28B50] bundleWithIdentifier:@"com.apple.CoreText"];
  long long v179 = 0u;
  long long v180 = 0u;
  long long v177 = 0u;
  long long v178 = 0u;
  unint64_t v73 = 0x1E4F28000;
  objCGFloat a = (id)[v49 countByEnumeratingWithState:&v177 objects:&v201 count:16];
  if (obja)
  {
    int v162 = 0;
    CFIndex v153 = 0;
    uint64_t v155 = *(void *)v178;
    uint64_t v74 = *MEMORY[0x1E4F1C628];
LABEL_113:
    id v159 = 0;
    while (1)
    {
      if (*(void *)v178 != v155) {
        objc_enumerationMutation(v49);
      }
      double v164 = *(void **)(*((void *)&v177 + 1) + 8 * (void)v159);
      CFStringRef v75 = (void *)[v164 attributes];
      uint64_t v76 = (void *)[*((id *)val + 6) objectForKey:v75];
      if ([v76 count] == 2)
      {
        __CFString v77 = (void *)[v76 firstObject];
        long long v175 = 0u;
        long long v176 = 0u;
        long long v173 = 0u;
        long long v174 = 0u;
        uint64_t v78 = [v77 countByEnumeratingWithState:&v173 objects:v200 count:16];
        if (v78)
        {
          uint64_t v79 = *(void *)v174;
          while (2)
          {
            for (iCFIndex i = 0; ii != v78; ++ii)
            {
              if (*(void *)v174 != v79) {
                objc_enumerationMutation(v77);
              }
              CFRange v81 = (atomic_ullong *)(*(void *)(*(void *)(*((void *)&v173 + 1) + 8 * ii) + 40) + 8);
              atomic_load_explicit(v81, memory_order_acquire);
              CFDictionaryRef v82 = (const __CFDictionary *)atomic_load_explicit(v81, memory_order_acquire);
              if (v82) {
                CFDictionaryRef v82 = (const __CFDictionary *)CFDictionaryGetValue(v82, @"CTFontAllowCellularDownloadAttribute");
              }
              if ([(__CFDictionary *)v82 BOOLValue])
              {
                LODWORD(v78) = 1;
                goto LABEL_130;
              }
            }
            uint64_t v78 = [v77 countByEnumeratingWithState:&v173 objects:v200 count:16];
            if (v78) {
              continue;
            }
            break;
          }
LABEL_130:
          unint64_t v73 = 0x1E4F28000uLL;
        }
        double v83 = (void *)*((void *)val + 4);
        if (v77) {
          [v83 setObject:v77 forKey:@"CTFontDescriptorMatchingDescriptors"];
        }
        else {
          [v83 removeObjectForKey:@"CTFontDescriptorMatchingDescriptors"];
        }
        CopyValueForCurrentUser((const __CFDictionary *)objc_msgSend((id)objc_msgSend((id)objc_msgSend(v76, "objectAtIndex:", 1), "firstObject"), "objectForKey:", @"LocalizedFamilyNames"), 0, (atomic_ullong *)location);
        unint64_t v84 = atomic_load_explicit((atomic_ullong *volatile)location, memory_order_acquire);

        if (v84)
        {
          [*((id *)val + 4) setObject:v84 forKey:@"CTFontDescriptorMatchingLocalizedFamilyName"];
          uint64_t v85 = [NSString stringWithFormat:objc_msgSend(v146, "localizedStringForKey:value:table:", @"Downloading font \\U201C%@\\U201D\\U2026", &stru_1ED0677F8, 0), v84];
          char v86 = (void *)*((void *)val + 4);
          if (v85) {
            [v86 setObject:v85 forKey:@"CTFontDescriptorMatchingLocalizedDescription"];
          }
          else {
            [v86 removeObjectForKey:@"CTFontDescriptorMatchingLocalizedDescription"];
          }
        }
      }
      else
      {
        LODWORD(v78) = 0;
      }
      uint64_t v87 = [*(id *)(v73 + 3792) numberWithInt:v162];
      uint64_t v88 = (void *)*((void *)val + 4);
      if (v87) {
        [v88 setObject:v87 forKey:@"CTFontDescriptorMatchingProcessedAssetCount"];
      }
      else {
        [v88 removeObjectForKey:@"CTFontDescriptorMatchingProcessedAssetCount"];
      }
      self;
      unint64_t v89 = [v164 state];
      if (v89 > 6 || ((1 << v89) & 0x6C) == 0)
      {
        double v99 = gotLoadHelper_x8__ASAttributeDownloadSize(v90);
        long long v101 = objc_msgSend(v75, "objectForKey:", **(void **)(v100 + 3888), v99);
        uint64_t v102 = [v101 longValue];
        uint64_t v103 = (void *)*((void *)val + 4);
        if (v101) {
          [v103 setObject:v101 forKey:@"CTFontDescriptorMatchingCurrentAssetSize"];
        }
        else {
          [v103 removeObjectForKey:@"CTFontDescriptorMatchingCurrentAssetSize"];
        }
        uint64_t v104 = [*(id *)(v73 + 3792) numberWithLong:v153];
        unint64_t v105 = (void *)*((void *)val + 4);
        if (v104) {
          [v105 setObject:v104 forKey:@"CTFontDescriptorMatchingTotalDownloadedSize"];
        }
        else {
          [v105 removeObjectForKey:@"CTFontDescriptorMatchingTotalDownloadedSize"];
        }
        if (qword_1EB2CE938 != -1) {
          dispatch_once(&qword_1EB2CE938, &__block_literal_global_177);
        }
        dispatch_source_t v106 = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, (dispatch_queue_t)qword_1EB2CE940);
        uint64_t v194 = (void *)MEMORY[0x1E4F143A8];
        uint64_t v195 = 3221225472;
        uint64_t v196 = __57__FontAssetDownloadManager_executeDownloadingFontAssets___block_invoke;
        v197 = &unk_1E5290830;
        dispatch_source_t v198 = v106;
        v199 = dsemaa;
        v172[0] = MEMORY[0x1E4F143A8];
        v172[1] = 3221225472;
        v172[2] = (uint64_t)__57__FontAssetDownloadManager_executeDownloadingFontAssets___block_invoke_2;
        v172[3] = (uint64_t)&unk_1E5290880;
        v172[4] = (uint64_t)v164;
        v172[5] = (uint64_t)&v194;
        location[0] = (id)0xAAAAAAAAAAAAAAAALL;
        objc_initWeak(location, val);
        from[0] = (id)0xAAAAAAAAAAAAAAAALL;
        objc_initWeak(from, v106);
        *(void *)&long long handler = MEMORY[0x1E4F143A8];
        *((void *)&handler + 1) = 3221225472;
        *(void *)&long long v168 = __57__FontAssetDownloadManager_executeDownloadingFontAssets___block_invoke_4;
        *((void *)&v168 + 1) = &unk_1E52908A8;
        objc_copyWeak((id *)&v169 + 1, location);
        objc_copyWeak(v170, from);
        *(void *)&long long v169 = v172;
        dispatch_source_set_event_handler(v106, &handler);
        id v107 = (id)[v172 copy];
        uint64_t v108 = (void *)*((void *)val + 4);
        if (v107) {
          [v108 setObject:v107 forKey:@"CTFontDescriptorMatchingCancelDownloadHandler"];
        }
        else {
          [v108 removeObjectForKey:@"CTFontDescriptorMatchingCancelDownloadHandler"];
        }
        BOOL v109 = -[FontAssetDownloadManager callProgressCallback:]((uint64_t)val, 4);
        *((unsigned char *)v182 + 24) = v109;
        dispatch_time_t v110 = dispatch_time(0, 500000000);
        dispatch_source_set_timer(v106, v110, 0x1DCD6500uLL, 0x2FAF080uLL);
        dispatch_resume(v106);
        if (*((unsigned char *)v182 + 24))
        {
          v191[0] = MEMORY[0x1E4F143A8];
          v191[1] = 3221225472;
          v191[2] = __57__FontAssetDownloadManager_executeDownloadingFontAssets___block_invoke_5;
          v191[3] = &unk_1E52908F8;
          objc_copyWeak(v192, from);
          v191[4] = val;
          v191[5] = v164;
          int v193 = v162;
          v192[1] = v153;
          v192[2] = v143;
          v191[7] = &v181;
          v191[6] = v172;
          [v164 attachProgressCallBack:v191];
          gotLoadHelper_x8__OBJC_CLASS___MADownloadOptions(v111);
          id v113 = objc_alloc_init(*(Class *)(v112 + 4080));
          gotLoadHelper_x8__OBJC_CLASS___ASAsset(v114);
          uint64_t v115 = objc_opt_class();
          BOOL v116 = 1;
          if (v115)
          {
            if (([v115 nonUserInitiatedDownloadsAllowed] & 1) != 0
              || (MainBundle = CFBundleGetMainBundle()) != 0
              && (CFStringRef Identifier = CFBundleGetIdentifier(MainBundle)) != 0
              && CFStringHasPrefix(Identifier, @"com.apple."))
            {
              BOOL v116 = 0;
            }
          }
          [v113 setDiscretionary:v116];
          if (v78)
          {
            CFLog();
            [v113 setAllowsCellularAccess:1];
          }
          v171[0] = MEMORY[0x1E4F143A8];
          v171[1] = 3221225472;
          v171[2] = __57__FontAssetDownloadManager_executeDownloadingFontAssets___block_invoke_7;
          v171[3] = &unk_1E5290858;
          v171[4] = &v194;
          [v164 startDownload:v113 then:v171];

          dispatch_semaphore_wait(dsemaa, 0xFFFFFFFFFFFFFFFFLL);
          v153 += v102;
          uint64_t v119 = objc_msgSend(*(id *)(v73 + 3792), "numberWithLong:");
          unint64_t v120 = (void *)*((void *)val + 4);
          if (v119) {
            [v120 setObject:v119 forKey:@"CTFontDescriptorMatchingTotalDownloadedSize"];
          }
          else {
            [v120 removeObjectForKey:@"CTFontDescriptorMatchingTotalDownloadedSize"];
          }
          uint64_t v121 = [*(id *)(v73 + 3792) numberWithLong:(uint64_t)(((double)v162 + 1.0) / (double)(unint64_t)v143 * 100.0)];
          uint64_t v122 = (void *)*((void *)val + 4);
          if (v121) {
            [v122 setObject:v121 forKey:@"CTFontDescriptorMatchingPercentage"];
          }
          else {
            [v122 removeObjectForKey:@"CTFontDescriptorMatchingPercentage"];
          }
          objc_destroyWeak(v192);
        }
        else
        {
          dispatch_source_cancel(v106);
        }
        dispatch_release(v106);
        objc_destroyWeak(v170);
        objc_destroyWeak((id *)&v169 + 1);
        objc_destroyWeak(from);
        objc_destroyWeak(location);
      }
      uint64_t v91 = [v164 getLocalFileUrl];
      if (v91)
      {
        self;
        uint64_t v92 = (void *)[MEMORY[0x1E4F28CB8] defaultManager];
        long long v93 = objc_msgSend(v92, "enumeratorAtURL:includingPropertiesForKeys:options:errorHandler:", v91, objc_msgSend(MEMORY[0x1E4F1C978], "arrayWithObject:", v74), 0, &__block_literal_global_141);
        long long v189 = 0u;
        long long v190 = 0u;
        *(_OWORD *)frouint64_t m = 0u;
        long long v188 = 0u;
        uint64_t v94 = [v93 countByEnumeratingWithState:from objects:location count:16];
        if (v94)
        {
          uint64_t v95 = *(void *)v188;
          do
          {
            for (juint64_t j = 0; jj != v94; ++jj)
            {
              if (*(void *)v188 != v95) {
                objc_enumerationMutation(v93);
              }
              long long v97 = (void *)*((void *)from[1] + jj);
              id v186 = 0;
              if ((!objc_msgSend(v97, "getResourceValue:forKey:error:", &v186, v74, 0, v141, v142)
                 || ([v186 BOOLValue] & 1) == 0)
                && (FSFontProviderSynchronizeFontAsset() & 1) == 0)
              {
                id v185 = 0;
                if (!_CTFontManagerRegisterActionFontsForURL(v97, 1, 1, &v185))
                {
                  uint64_t v141 = v97;
                  id v142 = v185;
                  CFLog();
                }
              }
            }
            uint64_t v94 = [v93 countByEnumeratingWithState:from objects:location count:16];
          }
          while (v94);
        }
      }
      objc_msgSend(*((id *)val + 4), "removeObjectForKey:", @"CTFontDescriptorMatchingCancelDownloadHandler", v141);
      BOOL v98 = -[FontAssetDownloadManager callProgressCallback:]((uint64_t)val, 6) && *((unsigned char *)v182 + 24) != 0;
      *((unsigned char *)v182 + 24) = v98;
      [*((id *)val + 4) removeObjectForKey:@"CTFontDescriptorMatchingError"];
      [*((id *)val + 4) removeObjectForKey:@"CTFontDescriptorMatchingTotalDownloadedSize"];
      [*((id *)val + 4) removeObjectForKey:@"CTFontDescriptorMatchingPercentage"];
      [*((id *)val + 4) removeObjectForKey:@"CTFontDescriptorMatchingCurrentAssetSize"];
      if (!*((unsigned char *)v182 + 24)) {
        break;
      }
      [*((id *)val + 4) removeObjectForKey:@"CTFontDescriptorMatchingDescriptors"];
      ++v162;
      id v159 = (char *)v159 + 1;
      if (v159 == obja)
      {
        uint64_t v123 = [v49 countByEnumeratingWithState:&v177 objects:&v201 count:16];
        objCGFloat a = (id)v123;
        if (v123) {
          goto LABEL_113;
        }
        break;
      }
    }
  }
  dispatch_release(dsemaa);
  _Block_object_dispose(&v181, 8);
LABEL_195:
  uint64_t v124 = (void *)[MEMORY[0x1E4F1CA48] array];
  CFArrayRef v125 = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)val + 1, memory_order_acquire);
  if (v125)
  {
    CFIndex v126 = CFArrayGetCount(v125);
    if (v126)
    {
      CFIndex v127 = v126;
      CFIndex v128 = 0;
      while (1)
      {
        unsigned int v129 = CFArrayGetValueAtIndex(v125, v128);
        unint64_t v130 = (void *)CTFontDescriptorCreateMatchingFontDescriptorsWithOptions((uint64_t)v129, (const __CFSet *)atomic_load_explicit((atomic_ullong *volatile)val + 2, memory_order_acquire), 513);
        CFArrayRef v131 = v130;
        CFArrayRef v132 = v131;
        if (!v131) {
          break;
        }
        CFIndex v133 = CFArrayGetCount(v131);

        if (v133 < 1)
        {
LABEL_203:

          if (++v128 == v127) {
            goto LABEL_213;
          }
        }
        else
        {
          unsigned __int16 v134 = (void *)*((void *)val + 4);
          if (v129) {
            [v134 setObject:v129 forKey:@"CTFontDescriptorMatchingSourceDescriptor"];
          }
          else {
            [v134 removeObjectForKey:@"CTFontDescriptorMatchingSourceDescriptor"];
          }
          id v135 = (void *)*((void *)val + 4);
          if (v130) {
            [v135 setObject:v130 forKey:@"CTFontDescriptorMatchingResult"];
          }
          else {
            [v135 removeObjectForKey:@"CTFontDescriptorMatchingResult"];
          }
          BOOL v136 = -[FontAssetDownloadManager callProgressCallback:]((uint64_t)val, 7);
          [v124 addObjectsFromArray:v130];

          if (++v128 == v127 || !v136) {
            goto LABEL_213;
          }
        }
      }

      goto LABEL_203;
    }
  }
LABEL_213:
  [*((id *)val + 4) removeObjectForKey:@"CTFontDescriptorMatchingSourceDescriptor"];
  [*((id *)val + 4) removeObjectForKey:@"CTFontDescriptorMatchingResult"];
  unint64_t v138 = (void *)*((void *)val + 4);
  if (v124) {
    [v138 setObject:v124 forKey:@"CTFontDescriptorMatchingResult"];
  }
  else {
    [v138 removeObjectForKey:@"CTFontDescriptorMatchingResult"];
  }
  uint64_t v3 = v144;
  uint64_t v2 = (uint64_t)val;
LABEL_217:
  -[FontAssetDownloadManager callProgressCallback:](v2, 1);
  BOOL v139 = *(void **)(v3 + 32);
LABEL_218:
}

void sub_184ABBE8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id *location, uint64_t a20,uint64_t a21,id *a22,id *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  _Block_object_dispose(&a69, 8);
  _Unwind_Resume(a1);
}

id ___Z31StashIndexForFontNameDictionaryv_block_invoke()
{
  v2[377] = *MEMORY[0x1E4F143B8];
  v1[0] = @".AppleSystemUIFontEmphasized";
  v1[1] = @".AppleSystemUIFont";
  v2[0] = &unk_1ED081468;
  v2[1] = &unk_1ED081480;
  v1[2] = @".AppleSystemUIFontItalic";
  v1[3] = @".AppleSystemUIFontEmphasizedItalic";
  v2[2] = &unk_1ED081498;
  v2[3] = &unk_1ED0814B0;
  v1[4] = @".AppleSystemUIFontThin";
  v1[5] = @".AppleSystemUIFontLight";
  v2[4] = &unk_1ED0814C8;
  v2[5] = &unk_1ED0814E0;
  v1[6] = @".AppleSystemUIFontUltraLight";
  v1[7] = @".AppleSystemUIFontMedium";
  v2[6] = &unk_1ED0814F8;
  v2[7] = &unk_1ED081510;
  v1[8] = @".AppleSystemUIFontDemi";
  v1[9] = @".AppleSystemUIFontBold";
  v2[8] = &unk_1ED081528;
  v2[9] = &unk_1ED081540;
  v1[10] = @".AppleSystemUIFontHeavy";
  v1[11] = @".AppleSystemUIFontBlack";
  v2[10] = &unk_1ED081558;
  v2[11] = &unk_1ED081570;
  v1[12] = @".AppleSymbolsFB";
  v1[13] = @".TimesFB";
  v2[12] = &unk_1ED082440;
  v2[13] = &unk_1ED082458;
  v1[14] = @".TimesFB-Bold";
  v1[15] = @".TimesFB-BoldItalic";
  v2[14] = &unk_1ED082470;
  v2[15] = &unk_1ED082488;
  v1[16] = @".TimesFB-Italic";
  v1[17] = @".AppleSimplifiedChineseFont-UltraLight";
  v2[16] = &unk_1ED0824A0;
  v2[17] = &unk_1ED082110;
  v1[18] = @".AppleSimplifiedChineseFont-Thin";
  v1[19] = @".AppleSimplifiedChineseFont-Light";
  v2[18] = &unk_1ED082128;
  v2[19] = &unk_1ED082140;
  v1[20] = @".AppleSimplifiedChineseFont-Regular";
  v1[21] = @".AppleSimplifiedChineseFont-Medium";
  v2[20] = &unk_1ED082158;
  v2[21] = &unk_1ED082170;
  v1[22] = @".AppleSimplifiedChineseFont-Semibold";
  v1[23] = @".AppleSimplifiedChineseFont-Bold";
  v2[22] = &unk_1ED082188;
  v2[23] = &unk_1ED0821A0;
  v1[24] = @".AppleSimplifiedChineseFont-Heavy";
  v1[25] = @".AppleTraditionalChineseFont-UltraLight";
  v2[24] = &unk_1ED0821B8;
  v2[25] = &unk_1ED0821D0;
  v1[26] = @".AppleTraditionalChineseFont-Thin";
  v1[27] = @".AppleTraditionalChineseFont-Light";
  v2[26] = &unk_1ED0821E8;
  v2[27] = &unk_1ED082200;
  v1[28] = @".AppleTraditionalChineseFont-Regular";
  v1[29] = @".AppleTraditionalChineseFont-Medium";
  v2[28] = &unk_1ED082218;
  v2[29] = &unk_1ED082230;
  v1[30] = @".AppleTraditionalChineseFont-Semibold";
  v1[31] = @".AppleTraditionalChineseFont-Bold";
  v2[30] = &unk_1ED082248;
  v2[31] = &unk_1ED082260;
  v1[32] = @".AppleTraditionalChineseFont-Heavy";
  v1[33] = @".AppleHongKongChineseFont-UltraLight";
  v2[32] = &unk_1ED082278;
  v2[33] = &unk_1ED082290;
  v1[34] = @".AppleHongKongChineseFont-Thin";
  v1[35] = @".AppleHongKongChineseFont-Light";
  v2[34] = &unk_1ED0822A8;
  v2[35] = &unk_1ED0822C0;
  v1[36] = @".AppleHongKongChineseFont-Regular";
  v1[37] = @".AppleHongKongChineseFont-Medium";
  v2[36] = &unk_1ED0822D8;
  v2[37] = &unk_1ED0822F0;
  v1[38] = @".AppleHongKongChineseFont-Semibold";
  v1[39] = @".AppleHongKongChineseFont-Bold";
  v2[38] = &unk_1ED082308;
  v2[39] = &unk_1ED082320;
  v1[40] = @".AppleHongKongChineseFont-Heavy";
  v1[41] = @".AppleMacaoChineseFont-UltraLight";
  v2[40] = &unk_1ED082338;
  v2[41] = &unk_1ED082350;
  v1[42] = @".AppleMacaoChineseFont-Thin";
  v1[43] = @".AppleMacaoChineseFont-Light";
  v2[42] = &unk_1ED082368;
  v2[43] = &unk_1ED082380;
  v1[44] = @".AppleMacaoChineseFont-Regular";
  v1[45] = @".AppleMacaoChineseFont-Medium";
  v2[44] = &unk_1ED082410;
  v2[45] = &unk_1ED082428;
  v1[46] = @".AppleMacaoChineseFont-Semibold";
  v1[47] = @".AppleMacaoChineseFont-Bold";
  v2[46] = &unk_1ED0824B8;
  v2[47] = &unk_1ED0824D0;
  v1[48] = @".AppleMacaoChineseFont-Heavy";
  v1[49] = @".AppleJapaneseFont-Ultralight";
  v2[48] = &unk_1ED0824E8;
  v2[49] = &unk_1ED082500;
  v1[50] = @".AppleJapaneseFont-Thin";
  v1[51] = @".AppleJapaneseFont-Light";
  v2[50] = &unk_1ED082518;
  v2[51] = &unk_1ED082530;
  v1[52] = @".AppleJapaneseFont-Regular";
  v1[53] = @".AppleJapaneseFont-Medium";
  v2[52] = &unk_1ED082548;
  v2[53] = &unk_1ED082560;
  v1[54] = @".AppleJapaneseFont-Semibold";
  v1[55] = @".AppleJapaneseFont-Bold";
  v2[54] = &unk_1ED082578;
  v2[55] = &unk_1ED082590;
  v1[56] = @".AppleJapaneseFont-Heavy";
  v1[57] = @".AppleJapaneseFont-Black";
  v2[56] = &unk_1ED0825A8;
  v2[57] = &unk_1ED0825C0;
  v1[58] = @".AppleKoreanFont-UltraLight";
  v1[59] = @".AppleKoreanFont-Thin";
  v2[58] = &unk_1ED0825D8;
  v2[59] = &unk_1ED0825F0;
  v1[60] = @".AppleKoreanFont-Light";
  v1[61] = @".AppleKoreanFont-Regular";
  v2[60] = &unk_1ED082608;
  v2[61] = &unk_1ED082620;
  v1[62] = @".AppleKoreanFont-Medium";
  v1[63] = @".AppleKoreanFont-Semibold";
  v2[62] = &unk_1ED082638;
  v2[63] = &unk_1ED082650;
  v1[64] = @".AppleKoreanFont-Bold";
  v2[64] = &unk_1ED082668;
  v1[65] = @".AppleKoreanFont-Heavy";
  v2[65] = &unk_1ED082680;
  v1[66] = @".AppleArabicFont-Ultralight";
  v2[66] = &unk_1ED082698;
  v1[67] = @".AppleArabicFont-Thin";
  v2[67] = &unk_1ED0826B0;
  v1[68] = @".AppleArabicFont-Light";
  v2[68] = &unk_1ED0826C8;
  v1[69] = @".AppleArabicFont-Regular";
  v2[69] = &unk_1ED0826E0;
  v1[70] = @".AppleArabicFont-Medium";
  v2[70] = &unk_1ED0826F8;
  v1[71] = @".AppleArabicFont-Semibold";
  v2[71] = &unk_1ED082710;
  v1[72] = @".AppleArabicFont-Bold";
  v2[72] = &unk_1ED082728;
  v1[73] = @".AppleArabicFont-Heavy";
  v2[73] = &unk_1ED082740;
  v1[74] = @".AppleArabicFont-Black";
  v2[74] = &unk_1ED082758;
  v1[75] = @".AppleThaiFont-Light";
  v2[75] = &unk_1ED082770;
  v1[76] = @".AppleThaiFont-Regular";
  v2[76] = &unk_1ED082788;
  v1[77] = @".AppleThaiFont-Bold";
  v2[77] = &unk_1ED0827A0;
  v1[78] = @".AppleUrduFont-Regular";
  v2[78] = &unk_1ED0827B8;
  v1[79] = @".AppleUrduFont-Bold";
  v2[79] = &unk_1ED0827D0;
  v1[80] = @".AppleSystemUIFaceHeadline";
  v2[80] = &unk_1ED0827E8;
  v1[81] = @".AppleSystemUIFaceItalicHeadline";
  v2[81] = &unk_1ED082800;
  v1[82] = @".AppleSystemUIFaceShortHeadline";
  v2[82] = &unk_1ED080A90;
  v1[83] = @".AppleSystemUIFaceShortItalicHeadline";
  v2[83] = &unk_1ED080AA8;
  v1[84] = @".AppleSystemUIFaceHeadline2";
  v2[84] = &unk_1ED082818;
  v1[85] = @".AppleSystemUIFaceItalicHeadline2";
  v2[85] = &unk_1ED082830;
  v1[86] = @".AppleSystemUIFaceShortHeadline2";
  v2[86] = &unk_1ED082848;
  v1[87] = @".AppleSystemUIFaceShortItalicHeadline2";
  v2[87] = &unk_1ED082860;
  v1[88] = @".AppleSystemUIFaceEmphasizedBody";
  v2[88] = &unk_1ED082878;
  v1[89] = @".AppleSystemUIFaceBody";
  v2[89] = &unk_1ED082890;
  v1[90] = @".AppleSystemUIFaceEmphasizedItalicBody";
  v2[90] = &unk_1ED0828A8;
  v1[91] = @".AppleSystemUIFaceItalicBody";
  v2[91] = &unk_1ED0828C0;
  v1[92] = @".AppleSystemUIFaceShortEmphasizedBody";
  v2[92] = &unk_1ED0828D8;
  v1[93] = @".AppleSystemUIFaceShortBody";
  v2[93] = &unk_1ED0828F0;
  v1[94] = @".AppleSystemUIFaceShortEmphasizedItalicBody";
  v2[94] = &unk_1ED082908;
  v1[95] = @".AppleSystemUIFaceShortItalicBody";
  v2[95] = &unk_1ED082920;
  v1[96] = @".AppleSystemUIFaceTallEmphasizedBody";
  v2[96] = &unk_1ED082938;
  v1[97] = @".AppleSystemUIFaceTallBody";
  v2[97] = &unk_1ED082950;
  v1[98] = @".AppleSystemUIFaceTallEmphasizedItalicBody";
  v2[98] = &unk_1ED082968;
  v1[99] = @".AppleSystemUIFaceTallItalicBody";
  v2[99] = &unk_1ED082980;
  v1[100] = @".AppleSystemUIFaceEmphasizedSubhead";
  v2[100] = &unk_1ED082998;
  v1[101] = @".AppleSystemUIFaceSubhead";
  v2[101] = &unk_1ED0829B0;
  v1[102] = @".AppleSystemUIFaceItalicSubhead";
  v2[102] = &unk_1ED0829C8;
  v1[103] = @".AppleSystemUIFaceShortEmphasizedSubhead";
  v1[104] = @".AppleSystemUIFaceShortSubhead";
  v2[104] = &unk_1ED0829F8;
  v1[105] = @".AppleSystemUIFaceShortItalicSubhead";
  v2[105] = &unk_1ED082A10;
  v1[106] = @".AppleSystemUIFaceEmphasizedSubhead2";
  v2[106] = &unk_1ED082A28;
  v1[107] = @".AppleSystemUIFaceSubhead2";
  v2[107] = &unk_1ED080B80;
  v1[108] = @".AppleSystemUIFaceItalicSubhead2";
  v2[108] = &unk_1ED082A40;
  v1[109] = @".AppleSystemUIFaceShortEmphasizedSubhead2";
  v2[109] = &unk_1ED082A58;
  v1[110] = @".AppleSystemUIFaceShortSubhead2";
  v2[110] = &unk_1ED082A70;
  v1[111] = @".AppleSystemUIFaceShortItalicSubhead2";
  v2[111] = &unk_1ED082A88;
  v1[112] = @".AppleSystemUIFaceEmphasizedFootnote";
  v2[112] = &unk_1ED082AA0;
  v1[113] = @".AppleSystemUIFaceFootnote";
  v2[113] = &unk_1ED082AB8;
  v1[114] = @".AppleSystemUIFaceItalicFootnote";
  v2[114] = &unk_1ED082AD0;
  v1[115] = @".AppleSystemUIFaceShortEmphasizedFootnote";
  v2[115] = &unk_1ED082AE8;
  v1[116] = @".AppleSystemUIFaceShortFootnote";
  v2[116] = &unk_1ED082B00;
  v1[117] = @".AppleSystemUIFaceShortItalicFootnote";
  v2[117] = &unk_1ED082B18;
  v1[118] = @".AppleSystemUIFaceEmphasizedCaption1";
  v2[118] = &unk_1ED082B30;
  v1[119] = @".AppleSystemUIFaceCaption1";
  v2[119] = &unk_1ED082B48;
  v1[120] = @".AppleSystemUIFaceItalicCaption1";
  v2[120] = &unk_1ED082B60;
  v1[121] = @".AppleSystemUIFaceShortEmphasizedCaption1";
  v2[121] = &unk_1ED082B78;
  v1[122] = @".AppleSystemUIFaceShortCaption1";
  v2[122] = &unk_1ED082B90;
  v1[123] = @".AppleSystemUIFaceShortItalicCaption1";
  v2[123] = &unk_1ED082BA8;
  v1[124] = @".AppleSystemUIFaceEmphasizedCaption2";
  v2[124] = &unk_1ED082BC0;
  v1[125] = @".AppleSystemUIFaceCaption2";
  v2[201] = &unk_1ED082A10;
  v1[248] = @".AppleSystemUIFaceEmphasizedItalicSubtitle1";
  v1[247] = @".AppleSystemUIFaceEmphasizedSubtitle1";
  v2[247] = &unk_1ED081060;
  v1[246] = @".AppleSystemUIFaceItalicSubtitle1";
  v2[246] = &unk_1ED081048;
  v1[245] = @".AppleSystemUIFaceHeadline3";
  v2[245] = &unk_1ED081030;
  v1[244] = @".AppleSystemUIFaceTitle4";
  v2[244] = &unk_1ED081018;
  v1[243] = @".AppleSystemUIFaceSection3";
  v2[243] = &unk_1ED081000;
  v1[242] = @".AppleSystemUIFaceSection2";
  v2[242] = &unk_1ED080FE8;
  v1[241] = @".AppleSystemUIFaceSection1";
  v2[241] = &unk_1ED080FD0;
  v1[240] = @".AppleSystemUIFaceSubtitle1";
  v2[240] = &unk_1ED080FB8;
  v1[239] = @".AppleSystemUIFaceSubtitle2";
  v2[239] = &unk_1ED080FA0;
  v1[238] = @".AppleSystemUIFaceSubtitle3";
  v2[238] = &unk_1ED080F88;
  v1[237] = @".AppleSystemUIFaceTallEmphasizedItalicTitle3";
  v2[237] = &unk_1ED080F70;
  v1[236] = @".AppleSystemUIFaceTallEmphasizedTitle3";
  v2[236] = &unk_1ED080F58;
  v1[235] = @".AppleSystemUIFaceTallItalicTitle3";
  v2[235] = &unk_1ED080F40;
  v1[234] = @".AppleSystemUIFaceTallTitle3";
  v2[234] = &unk_1ED080F28;
  v1[233] = @".AppleSystemUIFaceShortEmphasizedItalicTitle3";
  v2[233] = &unk_1ED080F10;
  v1[232] = @".AppleSystemUIFaceShortEmphasizedTitle3";
  v2[232] = &unk_1ED080EF8;
  v1[231] = @".AppleSystemUIFaceShortItalicTitle3";
  v2[231] = &unk_1ED080EE0;
  v1[230] = @".AppleSystemUIFaceShortTitle3";
  v2[230] = &unk_1ED080EC8;
  v1[229] = @".AppleSystemUIFaceEmphasizedItalicTitle3";
  v2[229] = &unk_1ED080EB0;
  v1[228] = @".AppleSystemUIFaceEmphasizedTitle3";
  v2[228] = &unk_1ED080E98;
  v1[227] = @".AppleSystemUIFaceItalicTitle3";
  v2[227] = &unk_1ED080E80;
  v1[226] = @".AppleSystemUIFaceTitle3";
  v2[226] = &unk_1ED080E68;
  v1[225] = @".AppleSystemUIFaceTallEmphasizedItalicTitle2";
  v2[225] = &unk_1ED080E50;
  v1[224] = @".AppleSystemUIFaceTallEmphasizedTitle2";
  v2[224] = &unk_1ED080E38;
  v1[223] = @".AppleSystemUIFaceTallItalicTitle2";
  v2[223] = &unk_1ED080E20;
  v1[222] = @".AppleSystemUIFaceTallTitle2";
  v2[222] = &unk_1ED080E08;
  v1[221] = @".AppleSystemUIFaceShortEmphasizedItalicTitle2";
  v2[221] = &unk_1ED080DF0;
  v1[220] = @".AppleSystemUIFaceShortEmphasizedTitle2";
  v2[220] = &unk_1ED080DD8;
  v1[219] = @".AppleSystemUIFaceShortItalicTitle2";
  v2[219] = &unk_1ED080DC0;
  v1[218] = @".AppleSystemUIFaceShortTitle2";
  v2[218] = &unk_1ED080DA8;
  v1[217] = @".AppleSystemUIFaceEmphasizedItalicTitle2";
  v2[217] = &unk_1ED080D90;
  v1[216] = @".AppleSystemUIFaceEmphasizedTitle2";
  v2[216] = &unk_1ED080D78;
  v1[215] = @".AppleSystemUIFaceItalicTitle2";
  v2[215] = &unk_1ED080D60;
  v1[214] = @".AppleSystemUIFaceTitle2";
  v2[214] = &unk_1ED080D48;
  v1[213] = @".AppleSystemUIFaceTallEmphasizedItalicTitle1";
  v2[213] = &unk_1ED080D30;
  v1[212] = @".AppleSystemUIFaceTallEmphasizedTitle1";
  v2[212] = &unk_1ED080D18;
  v1[211] = @".AppleSystemUIFaceTallItalicTitle1";
  v2[211] = &unk_1ED080D00;
  v1[210] = @".AppleSystemUIFaceTallTitle1";
  v2[210] = &unk_1ED080CE8;
  v1[209] = @".AppleSystemUIFaceShortEmphasizedItalicTitle1";
  v2[209] = &unk_1ED080CD0;
  v1[208] = @".AppleSystemUIFaceShortEmphasizedTitle1";
  v2[208] = &unk_1ED080B68;
  v1[207] = @".AppleSystemUIFaceShortItalicTitle1";
  v2[207] = &unk_1ED080B50;
  v1[206] = @".AppleSystemUIFaceShortTitle1";
  v2[206] = &unk_1ED080B38;
  v1[205] = @".AppleSystemUIFaceEmphasizedItalicTitle1";
  v2[205] = &unk_1ED080B20;
  v1[204] = @".AppleSystemUIFaceEmphasizedTitle1";
  v2[204] = &unk_1ED080B08;
  v1[203] = @".AppleSystemUIFaceItalicTitle1";
  v2[203] = &unk_1ED080AF0;
  v1[202] = @".AppleSystemUIFaceTitle1";
  v2[202] = &unk_1ED080CB8;
  v2[200] = &unk_1ED0829F8;
  v1[201] = @".AppleSystemUIFaceShortItalicSubhead1";
  v2[103] = &unk_1ED0829E0;
  v1[199] = @".AppleSystemUIFaceShortEmphasizedSubhead1";
  v2[199] = &unk_1ED0829E0;
  v1[200] = @".AppleSystemUIFaceShortSubhead1";
  v2[125] = &unk_1ED082BD8;
  v2[197] = &unk_1ED0829B0;
  v1[198] = @".AppleSystemUIFaceItalicSubhead1";
  v2[198] = &unk_1ED0829C8;
  v2[196] = &unk_1ED082998;
  v1[197] = @".AppleSystemUIFaceSubhead1";
  v1[126] = @".AppleSystemUIFaceItalicCaption2";
  v1[195] = @".AppleSystemUIFaceShortHeadline1";
  v2[195] = &unk_1ED080A90;
  v1[196] = @".AppleSystemUIFaceEmphasizedSubhead1";
  v1[194] = @".AppleSystemUIFaceHeadline1";
  v2[194] = &unk_1ED0827E8;
  v1[193] = @".AppleSystemUIFontCompactRounded-Black";
  v2[193] = &unk_1ED081A80;
  v1[192] = @".AppleSystemUIFontCompactRounded-Heavy";
  v2[192] = &unk_1ED081A68;
  v1[191] = @".AppleSystemUIFontCompactRounded-Bold";
  v2[191] = &unk_1ED081A50;
  v1[190] = @".AppleSystemUIFontCompactRounded-Semibold";
  v2[190] = &unk_1ED081A38;
  v1[189] = @".AppleSystemUIFontCompactRounded-Medium";
  v2[189] = &unk_1ED081A20;
  v1[188] = @".AppleSystemUIFontCompactRounded-Regular";
  v2[188] = &unk_1ED081A08;
  v1[187] = @".AppleSystemUIFontCompactRounded-Light";
  v2[187] = &unk_1ED0819F0;
  v1[186] = @".AppleSystemUIFontCompactRounded-Thin";
  v2[186] = &unk_1ED0819D8;
  v1[185] = @".AppleSystemUIFontCompactRounded-Ultralight";
  v2[185] = &unk_1ED0819C0;
  v1[184] = @".AppleSystemUIFontRounded-Black";
  v2[184] = &unk_1ED0819A8;
  v1[183] = @".AppleSystemUIFontRounded-Heavy";
  v2[183] = &unk_1ED081990;
  v1[182] = @".AppleSystemUIFontRounded-Bold";
  v2[182] = &unk_1ED081978;
  v1[181] = @".AppleSystemUIFontRounded-Semibold";
  v2[181] = &unk_1ED081960;
  v1[180] = @".AppleSystemUIFontRounded-Medium";
  v2[180] = &unk_1ED081948;
  v1[179] = @".AppleSystemUIFontRounded-Regular";
  v2[179] = &unk_1ED081930;
  v1[178] = @".AppleSystemUIFontRounded-Light";
  v2[178] = &unk_1ED081918;
  v1[177] = @".AppleSystemUIFontRounded-Thin";
  v2[177] = &unk_1ED081900;
  v1[176] = @".AppleSystemUIFontRounded-Ultralight";
  v2[176] = &unk_1ED0818E8;
  v1[175] = @".AppleSystemUIFontCompact-BlackItalic";
  v2[175] = &unk_1ED0816F0;
  v1[174] = @".AppleSystemUIFontCompact-HeavyItalic";
  v2[174] = &unk_1ED0816D8;
  v1[173] = @".AppleSystemUIFontCompact-SemiboldItalic";
  v2[173] = &unk_1ED0816A8;
  v1[172] = @".AppleSystemUIFontCompact-MediumItalic";
  v2[172] = &unk_1ED081690;
  v1[171] = @".AppleSystemUIFontCompact-UltraLightItalic";
  v2[171] = &unk_1ED081678;
  v1[170] = @".AppleSystemUIFontCompact-LightItalic";
  v2[170] = &unk_1ED081660;
  v1[169] = @".AppleSystemUIFontCompact-ThinItalic";
  v2[169] = &unk_1ED081648;
  v1[168] = @".AppleSystemUIFontCompact-BoldItalic";
  v2[168] = &unk_1ED0816C0;
  v1[167] = @".AppleSystemUIFontCompact-Italic";
  v2[167] = &unk_1ED0823E0;
  v1[166] = @".AppleSystemUIFontCompact-Black";
  v2[166] = &unk_1ED081630;
  v1[165] = @".AppleSystemUIFontCompact-Heavy";
  v2[165] = &unk_1ED081618;
  v1[164] = @".AppleSystemUIFontCompact-Semibold";
  v2[164] = &unk_1ED0815E8;
  v1[163] = @".AppleSystemUIFontCompact-Medium";
  v2[163] = &unk_1ED0815D0;
  v1[162] = @".AppleSystemUIFontCompact-UltraLight";
  v2[162] = &unk_1ED0815B8;
  v1[161] = @".AppleSystemUIFontCompact-Light";
  v2[161] = &unk_1ED0815A0;
  v1[160] = @".AppleSystemUIFontCompact-Thin";
  v2[160] = &unk_1ED081588;
  v1[159] = @".AppleSystemUIFontCompact-Bold";
  v2[159] = &unk_1ED081600;
  v1[158] = @".AppleSystemUIFontCompact-Regular";
  v2[158] = &unk_1ED0823C8;
  v1[157] = @".AppleSystemUIFontThinAlways";
  v2[157] = &unk_1ED082398;
  v1[156] = @".AppleSystemUIFontUltraLightAlways";
  v2[156] = &unk_1ED081C00;
  v1[155] = @".AppleSystemUIFontBlackItalic";
  v2[155] = &unk_1ED081BE8;
  v1[154] = @".AppleSystemUIFontHeavyItalic";
  v2[154] = &unk_1ED081BD0;
  v1[153] = @".AppleSystemUIFontBoldItalic";
  v2[153] = &unk_1ED081BB8;
  v1[152] = @".AppleSystemUIFontDemiItalic";
  v2[152] = &unk_1ED081BA0;
  v1[151] = @".AppleSystemUIFontMediumItalic";
  v2[151] = &unk_1ED081B88;
  v1[150] = @".AppleSystemUIFontUltraLightItalic";
  v2[150] = &unk_1ED081B70;
  v1[149] = @".AppleSystemUIFontLightItalic";
  v2[149] = &unk_1ED081B58;
  v1[148] = @".AppleSystemUIFontThinItalic";
  v2[148] = &unk_1ED081B40;
  v1[147] = @".AppleSystemUIFaceShortItalicCaption2";
  v2[147] = &unk_1ED080CA0;
  v1[146] = @".AppleSystemUIFaceShortCaption2";
  v2[146] = &unk_1ED080C88;
  v1[145] = @".AppleSystemUIFaceShortEmphasizedCaption2";
  v2[145] = &unk_1ED080C70;
  v1[144] = @".AppleSystemUIFaceShortItalicFootnote2";
  v2[144] = &unk_1ED080C58;
  v1[143] = @".AppleSystemUIFaceShortFootnote2";
  v2[143] = &unk_1ED080C40;
  v1[142] = @".AppleSystemUIFaceShortEmphasizedFootnote2";
  v2[142] = &unk_1ED080C28;
  v1[141] = @".AppleSystemUIFaceItalicFootnote2";
  v2[141] = &unk_1ED080C10;
  v1[140] = @".AppleSystemUIFaceFootnote2";
  v2[140] = &unk_1ED080BF8;
  v1[139] = @".AppleSystemUIFaceEmphasizedFootnote2";
  v2[139] = &unk_1ED080BE0;
  v1[138] = @".AppleSystemUIFaceTallEmphasizedItalicCallout";
  v2[138] = &unk_1ED080BC8;
  v1[137] = @".AppleSystemUIFaceTallEmphasizedCallout";
  v2[137] = &unk_1ED080BB0;
  v1[136] = @".AppleSystemUIFaceTallItalicCallout";
  v2[136] = &unk_1ED080AD8;
  v1[135] = @".AppleSystemUIFaceTallCallout";
  v2[135] = &unk_1ED080AC0;
  v1[134] = @".AppleSystemUIFaceShortEmphasizedItalicCallout";
  v2[134] = &unk_1ED082C98;
  v1[133] = @".AppleSystemUIFaceShortEmphasizedCallout";
  v2[133] = &unk_1ED082C80;
  v1[132] = @".AppleSystemUIFaceShortItalicCallout";
  v2[132] = &unk_1ED080B98;
  v1[131] = @".AppleSystemUIFaceShortCallout";
  v2[131] = &unk_1ED082C68;
  v1[130] = @".AppleSystemUIFaceEmphasizedItalicCallout";
  v2[130] = &unk_1ED082C50;
  v1[129] = @".AppleSystemUIFaceEmphasizedCallout";
  v2[129] = &unk_1ED082C38;
  v1[128] = @".AppleSystemUIFaceItalicCallout";
  v2[128] = &unk_1ED082C20;
  v1[127] = @".AppleSystemUIFaceCallout";
  v2[127] = &unk_1ED082C08;
  v2[126] = &unk_1ED082BF0;
  v2[248] = &unk_1ED081078;
  v1[249] = @".AppleSystemUIFaceTitle0";
  v2[249] = &unk_1ED081090;
  v1[250] = @".AppleSystemUIFaceEmphasizedTitle0";
  v2[250] = &unk_1ED0810A8;
  v1[251] = @".AppleSystemUIFaceShortTitle0";
  v2[251] = &unk_1ED0810C0;
  v1[252] = @".AppleSystemUIFaceShortEmphasizedTitle0";
  v2[252] = &unk_1ED0810D8;
  v1[253] = @".AppleSystemUIFaceTallTitle0";
  v2[253] = &unk_1ED0810F0;
  v1[254] = @".AppleSystemUIFaceTallEmphasizedTitle0";
  v2[254] = &unk_1ED081108;
  v1[255] = @".AppleSystemUIFaceEmphasizedHeadline";
  v2[255] = &unk_1ED081120;
  v1[256] = @".AppleSystemUIFaceEmphasizedItalicHeadline";
  v2[256] = &unk_1ED081138;
  v1[257] = @".AppleSystemUIFaceShortEmphasizedHeadline";
  v2[257] = &unk_1ED081150;
  v1[258] = @".AppleSystemUIFaceShortEmphasizedItalicHeadline";
  v2[258] = &unk_1ED081168;
  v1[259] = @".AppleSystemUIFaceTallHeadline";
  v2[259] = &unk_1ED081180;
  v1[260] = @".AppleSystemUIFaceTallEmphasizedHeadline";
  v2[260] = &unk_1ED081198;
  v1[261] = @".AppleSystemUIFaceCaption3";
  v2[261] = &unk_1ED0811B0;
  v1[262] = @".AppleSystemUIFaceEmphasizedCaption3";
  v2[262] = &unk_1ED0811C8;
  v1[263] = @".AppleSystemUIFontCondensed-Regular";
  v2[263] = &unk_1ED081A98;
  v1[264] = @".AppleSystemUIFontCondensed-Bold";
  v2[264] = &unk_1ED081AB0;
  v1[265] = @".AppleSystemUIFontCondensed-Thin";
  v2[265] = &unk_1ED081AC8;
  v1[266] = @".AppleSystemUIFontCondensed-Light";
  v2[266] = &unk_1ED081AE0;
  void v1[267] = @".AppleSystemUIFontCondensed-UltraLight";
  v2[267] = &unk_1ED081AF8;
  v1[268] = @".AppleSystemUIFontCondensed-Medium";
  void v2[268] = &unk_1ED081C18;
  v1[269] = @".AppleSystemUIFontCondensed-Semibold";
  v2[269] = &unk_1ED081C30;
  v1[270] = @".AppleSystemUIFontCondensed-Heavy";
  v2[270] = &unk_1ED081C48;
  v1[271] = @".AppleSystemUIFontCondensed-Black";
  v2[271] = &unk_1ED081C60;
  v1[272] = @".AppleSystemUIFontSerif-Regular";
  v2[272] = &unk_1ED081D50;
  v1[273] = @".AppleSystemUIFontSerif-Medium";
  v2[273] = &unk_1ED081D68;
  void v1[274] = @".AppleSystemUIFontSerif-Semibold";
  v2[274] = &unk_1ED081D80;
  v1[275] = @".AppleSystemUIFontSerif-Bold";
  void v2[275] = &unk_1ED081D98;
  v1[276] = @".AppleSystemUIFontSerif-Heavy";
  v2[276] = &unk_1ED081DB0;
  v1[277] = @".AppleSystemUIFontSerif-Black";
  v2[277] = &unk_1ED081DC8;
  v1[278] = @".AppleSystemUIFontSerif-Italic";
  v2[278] = &unk_1ED081DE0;
  v1[279] = @".AppleSystemUIFontSerif-MediumItalic";
  v2[279] = &unk_1ED081DF8;
  v1[280] = @".AppleSystemUIFontSerif-SemiboldItalic";
  v2[280] = &unk_1ED081E10;
  v1[281] = @".AppleSystemUIFontSerif-BoldItalic";
  v2[281] = &unk_1ED081E28;
  void v1[282] = @".AppleSystemUIFontSerif-HeavyItalic";
  v2[282] = &unk_1ED081E40;
  v1[283] = @".AppleSystemUIFontSerif-BlackItalc";
  void v2[283] = &unk_1ED081B10;
  v1[284] = @".AppleSystemUIFontMonospaced-Light";
  v2[284] = &unk_1ED081B28;
  v1[285] = @".AppleSystemUIFontMonospaced-Regular";
  v2[285] = &unk_1ED081E58;
  v1[286] = @".AppleSystemUIFontMonospaced-Medium";
  v2[286] = &unk_1ED081E70;
  v1[287] = @".AppleSystemUIFontMonospaced-Semibold";
  v2[287] = &unk_1ED081E88;
  v1[288] = @".AppleSystemUIFontMonospaced-Bold";
  v2[288] = &unk_1ED081EA0;
  v1[289] = @".AppleSystemUIFontMonospaced-Heavy";
  v2[289] = &unk_1ED081EB8;
  v1[290] = @".AppleSystemUIFontMonospaced-LightItalic";
  v2[290] = &unk_1ED081ED0;
  v1[291] = @".AppleSystemUIFontMonospaced-RegularItalic";
  v2[291] = &unk_1ED081EE8;
  v1[292] = @".AppleSystemUIFontMonospaced-MediumItalic";
  v2[292] = &unk_1ED081F00;
  v1[293] = @".AppleSystemUIFontMonospaced-SemiboldItalic";
  v2[293] = &unk_1ED081F18;
  v1[294] = @".AppleSystemUIFontMonospaced-BoldItalic";
  v2[294] = &unk_1ED081F30;
  v1[295] = @".AppleSystemUIFontMonospaced-HeavyItalic";
  v2[295] = &unk_1ED081F48;
  v1[296] = @".AppleSystemUIFontSoft-Ultralight";
  v2[296] = &unk_1ED081F60;
  v1[297] = @".AppleSystemUIFontSoft-Thin";
  v2[297] = &unk_1ED081F78;
  v1[298] = @".AppleSystemUIFontSoft-Light";
  v2[298] = &unk_1ED081F90;
  v1[299] = @".AppleSystemUIFontSoft-Regular";
  v2[299] = &unk_1ED081FA8;
  v1[300] = @".AppleSystemUIFontSoft-Medium";
  v2[300] = &unk_1ED081FC0;
  v1[301] = @".AppleSystemUIFontSoft-Semibold";
  v2[301] = &unk_1ED081FD8;
  v1[302] = @".AppleSystemUIFontSoft-Bold";
  v2[302] = &unk_1ED081FF0;
  v1[303] = @".AppleSystemUIFontSoft-Heavy";
  v2[303] = &unk_1ED082008;
  v1[304] = @".AppleSystemUIFontSoft-Black";
  v2[304] = &unk_1ED082020;
  v1[305] = @".AppleSystemUIFontCompactSoft-Ultralight";
  v2[305] = &unk_1ED082038;
  v1[306] = @".AppleSystemUIFontCompactSoft-Thin";
  v2[306] = &unk_1ED082050;
  v1[307] = @".AppleSystemUIFontCompactSoft-Light";
  v2[307] = &unk_1ED082068;
  v1[308] = @".AppleSystemUIFontCompactSoft-Regular";
  v2[308] = &unk_1ED082080;
  v1[309] = @".AppleSystemUIFontCompactSoft-Medium";
  v2[309] = &unk_1ED082098;
  v1[310] = @".AppleSystemUIFontCompactSoft-Semibold";
  v2[310] = &unk_1ED0820B0;
  v1[311] = @".AppleSystemUIFontCompactSoft-Bold";
  v2[311] = &unk_1ED0820C8;
  v1[312] = @".AppleSystemUIFontCompactSoft-Heavy";
  v2[312] = &unk_1ED0820E0;
  v1[313] = @".AppleSystemUIFontCompactSoft-Black";
  v2[313] = &unk_1ED0820F8;
  v1[314] = @".AppleSystemFallback-Ultralight";
  v2[314] = &unk_1ED082CB0;
  v1[315] = @".AppleSystemFallback-Thin";
  v2[315] = &unk_1ED082CC8;
  v1[316] = @".AppleSystemFallback-Light";
  v2[316] = &unk_1ED082CE0;
  v1[317] = @".AppleSystemFallback-Regular";
  v2[317] = &unk_1ED082CF8;
  v1[318] = @".AppleSystemFallback-Medium";
  v2[318] = &unk_1ED082D10;
  v1[319] = @".AppleSystemFallback-Semibold";
  v2[319] = &unk_1ED082D28;
  v1[320] = @".AppleSystemFallback-Bold";
  v2[320] = &unk_1ED082D40;
  v1[321] = @".AppleSystemFallback-Heavy";
  v2[321] = &unk_1ED082D58;
  v1[322] = @".AppleSystemFallback-Black";
  v2[322] = &unk_1ED082D70;
  v1[323] = @".AppleSystemUIFaceExtraLargeTitle";
  v2[323] = &unk_1ED0811E0;
  v1[324] = @".AppleSystemUIFaceEmphasizedExtraLargeTitle";
  v2[324] = &unk_1ED0811F8;
  v1[325] = @".AppleSystemUIFaceExtraLargeTitle2";
  v2[325] = &unk_1ED081210;
  v1[326] = @".AppleSystemUIFaceEmphasizedExtraLargeTitle2";
  v2[326] = &unk_1ED081228;
  v1[327] = @".AppleSystemUIFontCore-Regular";
  v2[327] = &unk_1ED081720;
  v1[328] = @".AppleSystemUIFontCore-Bold";
  v2[328] = &unk_1ED0817E0;
  v1[329] = @".AppleSystemUIFontCore-Thin";
  v2[329] = &unk_1ED081768;
  v1[330] = @".AppleSystemUIFontCore-Light";
  v2[330] = &unk_1ED081780;
  v1[331] = @".AppleSystemUIFontCore-UltraLight";
  v2[331] = &unk_1ED081798;
  v1[332] = @".AppleSystemUIFontCore-Medium";
  v2[332] = &unk_1ED0817B0;
  v1[333] = @".AppleSystemUIFontCore-Semibold";
  v2[333] = &unk_1ED0817C8;
  v1[334] = @".AppleSystemUIFontCore-Heavy";
  v2[334] = &unk_1ED0817F8;
  v1[335] = @".AppleSystemUIFontCore-Black";
  v2[335] = &unk_1ED081810;
  v1[336] = @".AppleSystemUIFontCore-Italic";
  v2[336] = &unk_1ED081738;
  v1[337] = @".AppleSystemUIFontCore-BoldItalic";
  v2[337] = &unk_1ED0818A0;
  v1[338] = @".AppleSystemUIFontCore-ThinItalic";
  v2[338] = &unk_1ED081828;
  v1[339] = @".AppleSystemUIFontCore-LightItalic";
  v2[339] = &unk_1ED081840;
  v1[340] = @".AppleSystemUIFontCore-UltraLightItalic";
  v2[340] = &unk_1ED081858;
  v1[341] = @".AppleSystemUIFontCore-MediumItalic";
  v2[341] = &unk_1ED081870;
  v1[342] = @".AppleSystemUIFontCore-SemiboldItalic";
  v2[342] = &unk_1ED081888;
  v1[343] = @".AppleSystemUIFontCore-HeavyItalic";
  v2[343] = &unk_1ED0818B8;
  v1[344] = @".AppleSystemUIFontCore-BlackItalic";
  v2[344] = &unk_1ED0818D0;
  v1[345] = @".AppleSystemUIFontCoreCondensed-Regular";
  v2[345] = &unk_1ED081C78;
  v1[346] = @".AppleSystemUIFontCoreCondensed-Bold";
  v2[346] = &unk_1ED081C90;
  v1[347] = @".AppleSystemUIFontCoreCondensed-Thin";
  v2[347] = &unk_1ED081CA8;
  v1[348] = @".AppleSystemUIFontCoreCondensed-Light";
  v2[348] = &unk_1ED081CC0;
  v1[349] = @".AppleSystemUIFontCoreCondensed-UltraLight";
  v2[349] = &unk_1ED081CD8;
  v1[350] = @".AppleSystemUIFontCoreCondensed-Medium";
  v2[350] = &unk_1ED081CF0;
  v1[351] = @".AppleSystemUIFontCoreCondensed-Semibold";
  v2[351] = &unk_1ED081D08;
  v1[352] = @".AppleSystemUIFontCoreCondensed-Heavy";
  v2[352] = &unk_1ED081D20;
  v1[353] = @".AppleSystemUIFontCoreCondensed-Black";
  v2[353] = &unk_1ED081D38;
  v1[354] = @".AppleSystemUIFaceEmphasizedItalicCaption1";
  v2[354] = &unk_1ED081240;
  v1[355] = @".AppleSystemUIFaceShortEmphasizedItalicCaption1";
  v2[355] = &unk_1ED081258;
  v1[356] = @".AppleSystemUIFaceTallCaption1";
  v2[356] = &unk_1ED081270;
  v1[357] = @".AppleSystemUIFaceTallItalicCaption1";
  v2[357] = &unk_1ED081288;
  v1[358] = @".AppleSystemUIFaceTallEmphasizedCaption1";
  v2[358] = &unk_1ED0812A0;
  v1[359] = @".AppleSystemUIFaceTallEmphasizedItalicCaption1";
  v2[359] = &unk_1ED0812B8;
  v1[360] = @".AppleSystemUIFaceEmphasizedItalicCaption2";
  v2[360] = &unk_1ED0812D0;
  v1[361] = @".AppleSystemUIFaceShortEmphasizedItalicCaption2";
  v2[361] = &unk_1ED0812E8;
  v1[362] = @".AppleSystemUIFaceTallCaption2";
  v2[362] = &unk_1ED081300;
  v1[363] = @".AppleSystemUIFaceTallItalicCaption2";
  v2[363] = &unk_1ED081318;
  v1[364] = @".AppleSystemUIFaceTallEmphasizedCaption2";
  v2[364] = &unk_1ED081330;
  v1[365] = @".AppleSystemUIFaceTallEmphasizedItalicCaption2";
  v2[365] = &unk_1ED081348;
  v1[366] = @".AppleSystemUIFaceItalicExtraLargeTitle";
  v2[366] = &unk_1ED081360;
  v1[367] = @".AppleSystemUIFaceEmphasizedItalicExtraLargeTitle";
  v2[367] = &unk_1ED081378;
  v1[368] = @".AppleSystemUIFaceItalicExtraLargeTitle2";
  v2[368] = &unk_1ED081390;
  v1[369] = @".AppleSystemUIFaceEmphasizedItalicExtraLargeTitle2";
  v2[369] = &unk_1ED0813A8;
  v1[370] = @".AppleSystemUIFaceCondensedHeadline";
  v2[370] = &unk_1ED0813F0;
  v1[371] = @".AppleSystemUIFaceCondensedTitle1";
  v2[371] = &unk_1ED081408;
  v1[372] = @".AppleSystemUIFaceCondensedTitle2";
  v2[372] = &unk_1ED081420;
  v1[373] = @".AppleSystemUIFaceCondensedTitle3";
  v2[373] = &unk_1ED081438;
  v1[374] = @".AppleSystemUIFaceCondensedBody";
  v2[374] = &unk_1ED081450;
  v1[375] = @".AppleSystemUIFacePreferredSize-Regular";
  v2[375] = &unk_1ED0813C0;
  v1[376] = @".AppleSystemUIFacePreferredSize-Bold";
  v2[376] = &unk_1ED0813D8;
  id result = (id)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v2 forKeys:v1 count:377];
  qword_1EB2CDB98 = (uint64_t)result;
  return result;
}

CFSetRef TDescriptorSource::GetMatchableNameAttributes(void)::$_0::__invoke()
{
  v1[7] = *(const void **)MEMORY[0x1E4F143B8];
  v1[0] = @"NSCTFontPostScriptNameAttribute";
  v1[1] = @"NSFontNameAttribute";
  v1[2] = @"NSFontVisibleNameAttribute";
  v1[3] = @"NSFontFamilyAttribute";
  v1[4] = @"NSFontFaceAttribute";
  v1[5] = @"NSCTFontUIUsageAttribute";
  v1[6] = @"NSCTFontFileURLAttribute";
  CFSetRef result = CFSetCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v1, 7, MEMORY[0x1E4F1D548]);
  qword_1EB2CE1D8 = (uint64_t)result;
  return result;
}

_anonymous_namespace_::TCGImageData *anonymous namespace'::TCGImageData::TCGImageData(_anonymous_namespace_::TCGImageData *this, os_unfair_lock_s **context, unsigned int a3, unint64_t a4, double a5, CGPoint a6)
{
  v128[1] = *MEMORY[0x1E4F143B8];
  *(CGPoint *)this = a6;
  *((void *)this + 2) = 0;
  *(_OWORD *)((char *)this + 24) = *MEMORY[0x1E4F1DAD8];
  CGContextRef v12 = (CGContextRef)MEMORY[0x1E4F1DB30];
  *(_OWORD *)((char *)this + 40) = *MEMORY[0x1E4F1DB30];
  *((void *)this + 7) = 0;
  if (qword_1EB2CDFB0 != -1) {
    dispatch_once_f(&qword_1EB2CDFB0, context, (dispatch_function_t)GetGlyphAfterHiding(TFont const*,unsigned short)::$_0::__invoke);
  }
  if ((unsigned __int16)_MergedGlobals_11 == a3
    && ((IsGB18030ComplianceRequired() & 1) != 0 || CurrentLocaleIsChina()))
  {
    a3 = (unsigned __int16)word_1EB2CDF9A;
  }
  if (TBaseFont::GetGlyphCount((TBaseFont *)context[50]) > a3)
  {
    unint64_t v108 = 0xAAAAAAAAAAAAAAAALL;
    long long v105 = xmmword_184B8A050;
    long long v106 = unk_184B8A060;
    long long v107 = xmmword_184B8A070;
    TFont::FindColorBitmapForGlyph((TFont *)context, a3, a4, (uint64_t)&v105, a5);
    if ((_BYTE)v108)
    {
      CFArrayRef v13 = (unsigned __int16 *)v105;
      double v14 = *((double *)&v106 + 1);
      *((void *)this + 7) = v107;
      double v15 = v14 * a5;
      double v16 = (double)((int)bswap32(*v13) >> 16) / (v14 * a5);
      double v17 = (double)((int)bswap32(v13[1]) >> 16) / (v14 * a5);
      *((double *)this + 3) = v16;
      *((double *)this + 4) = v17;
      if ((*(unsigned int (**)(void))(*(void *)&context[50]->_os_unfair_lock_opaque + 712))()
        && (TFont::GetEmojiMLUpscalingTimeout((atomic_ullong *)context), v18))
      {
        uint64_t v19 = 0;
        double v20 = *((double *)this + 7);
        int v21 = v20 / *((double *)&v106 + 1) > v20 && v20 == 160.0;
        id v104 = 0;
        if ((*(unsigned char *)context & 2) == 0 && v21)
        {
          uint64_t v19 = [NSNumber numberWithUnsignedLong:(unint64_t)v106 ^ -(uint64_t)SBYTE9(v107)];
          TBaseFont::RetainedObject(context[50], 0, (const void *)1, &valuePtr);

          if (!atomic_load_explicit((atomic_ullong *volatile)&v104, memory_order_acquire))
          {
            *(void *)&valuePtr.double a = objc_opt_new();

            objc_msgSend((id)atomic_load_explicit((atomic_ullong *volatile)&v104, memory_order_acquire), "setName:", @"com.apple.CoreText.UpscaledGlyphs");
            objc_msgSend((id)atomic_load_explicit((atomic_ullong *volatile)&v104, memory_order_acquire), "setEvictsObjectsWithDiscardedContent:", 0);
            TBaseFont::SetObject(context[50], 0, (const void *)1, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v104, memory_order_acquire));
          }
          uint64_t v22 = objc_msgSend((id)atomic_load_explicit((atomic_ullong *volatile)&v104, memory_order_acquire), "objectForKey:", v19);
          if (v22)
          {
            id v23 = (void *)v22;
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) == 0)
            {
              CGImageRef v116 = (CGImageRef)0xAAAAAAAAAAAAAAAALL;
              *(void *)&valuePtr.double a = (id)[v23 valueForKey:@"image"];
              CGImageRef v116 = (CGImageRef)atomic_exchange((atomic_ullong *volatile)&valuePtr, 0);

              if (atomic_load_explicit((atomic_ullong *volatile)&v116, memory_order_acquire))
              {
                CFNumberRef v24 = (const __CFNumber *)[v23 valueForKey:@"scaleFactor"];
                valuePtr.double a = NAN;
                CFNumberGetValue(v24, kCFNumberDoubleType, &valuePtr);
                double a = valuePtr.a;

                CFStringRef explicit = (CGImage *)atomic_load_explicit((atomic_ullong *volatile)this + 2, memory_order_acquire);
                double v27 = v15 * a;
                double Width = (double)CGImageGetWidth(explicit);
                size_t Height = CGImageGetHeight(explicit);
                *((double *)this + 5) = Width / v27;
                *((double *)this + 6) = (double)Height / v27;
                CGImageRef v30 = v116;
LABEL_99:

                return this;
              }
            }
          }
          int v21 = 1;
        }
      }
      else
      {
        int v21 = 0;
        uint64_t v19 = 0;
        id v104 = 0;
      }
      CGFloat v99 = *(double *)&v19;
      uint64_t v31 = (CGImage *)(id)atomic_load_explicit((atomic_ullong *volatile)&v104, memory_order_acquire);
      uint64_t v32 = 0;
      id v103 = 0;
      if ((*(unsigned char *)context & 2) == 0)
      {
        uint64_t v32 = (CGImage *)[NSNumber numberWithUnsignedLong:(unint64_t)v106 ^ -(uint64_t)SBYTE9(v107)];
        p_CGAffineTransform valuePtr = (CGImage *)&valuePtr;
        TBaseFont::RetainedObject(context[50], 0, 0, &valuePtr);

        if (!atomic_load_explicit((atomic_ullong *volatile)&v103, memory_order_acquire))
        {
          *(void *)&valuePtr.double a = objc_opt_new();

          objc_msgSend((id)atomic_load_explicit((atomic_ullong *volatile)&v103, memory_order_acquire), "setName:", @"com.apple.CoreText.GlyphImages");
          objc_msgSend((id)atomic_load_explicit((atomic_ullong *volatile)&v103, memory_order_acquire), "setEvictsObjectsWithDiscardedContent:", 0);
          TBaseFont::SetObject(context[50], 0, 0, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v103, memory_order_acquire));
        }
        valuePtr.double a = -3.72066208e-103;
        CGImageRef v116 = (CGImageRef)(id)objc_msgSend((id)atomic_load_explicit((atomic_ullong *volatile)&v103, memory_order_acquire), "objectForKey:", v32);
        *(void *)&valuePtr.double a = atomic_exchange((atomic_ullong *volatile)&v116, 0);

        if (atomic_load_explicit((atomic_ullong *volatile)&valuePtr, memory_order_acquire))
        {
          unint64_t v33 = atomic_load_explicit((atomic_ullong *volatile)&valuePtr, memory_order_acquire);
          if (*MEMORY[0x1E4F1D260] != v33)
          {

            p_CGAffineTransform valuePtr = (CGImage *)atomic_load_explicit((atomic_ullong *volatile)this + 2, memory_order_acquire);
            double v34 = (double)CGImageGetWidth(p_valuePtr);
            size_t v35 = CGImageGetHeight(p_valuePtr);
            *((double *)this + 5) = v34 / v15;
            *((double *)this + 6) = (double)v35 / v15;
          }
        }
      }
      if (atomic_load_explicit((atomic_ullong *volatile)this + 2, memory_order_acquire)) {
        int v36 = v21;
      }
      else {
        int v36 = 1;
      }
      if (v36 != 1)
      {
LABEL_98:

        CGImageRef v30 = v31;
        goto LABEL_99;
      }
      if (atomic_load_explicit((atomic_ullong *volatile)this + 2, memory_order_acquire)) {
        goto LABEL_68;
      }
      if ((BYTE8(v107) & 1) == 0) {
        goto LABEL_68;
      }
      p_CGAffineTransform valuePtr = (CGImage *)*((void *)&v105 + 1);
      if ((unint64_t)(*((void *)&v105 + 1) - 11) > 0xFFFFFFFFFFFFFFF8) {
        goto LABEL_68;
      }
      unsigned int v37 = *((_DWORD *)v13 + 1);
      if (v37 == 1667919205
        && !(*(unsigned int (**)(os_unfair_lock_s *))(*(void *)&context[50]->_os_unfair_lock_opaque + 712))(context[50]))
      {
        goto LABEL_68;
      }
      int v38 = bswap32(v37);
      uint64_t v39 = (const void *)atomic_load_explicit((atomic_ullong *volatile)a4, memory_order_acquire);
      valuePtr.double a = 0.0;
      CGImageRef v116 = 0;
      if (v38 == 1885627936) {
        goto LABEL_60;
      }
      a4 = (unint64_t)p_valuePtr - 8;
      p_CGAffineTransform valuePtr = (CGImage *)(v13 + 4);
      if (v38 != 1701669475)
      {
        uint64_t v46 = (void *)CFRetain(v39);

        CreateImageWithDataProvider((atomic_ullong *)&v123, (CGDataProviderRef)atomic_load_explicit((atomic_ullong *volatile)&valuePtr, memory_order_acquire), v38);
        id v45 = v123;
        goto LABEL_59;
      }
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB2CDFD0, memory_order_acquire) & 1) == 0) {
        goto LABEL_103;
      }
      while (1)
      {
        CGImageRef image = p_valuePtr;
        if (qword_1EB2CDFD8 != -1) {
          dispatch_once(&qword_1EB2CDFD8, &__block_literal_global);
        }
        size_t v40 = 0;
        CFAllocatorRef v41 = (uint8_t *)atomic_exchange(&qword_1EB2CDFB8, 0);
        LODWORD(v100) = 0;
        if (a4 >= 0xC)
        {
          size_t v40 = 0;
          if (*((_DWORD *)v13 + 2) == 829058405 && v13[6] == 256)
          {
            int v42 = v13[9];
            LOWORD(v100) = v13[8];
            WORD1(v100) = v42;
            size_t v40 = 4 * v42 * (unsigned __int16)v100;
          }
        }
        if (v41 && emoji_compression_decode_scratch_buffer_size((int)v100) > qword_1EB2CDFC8)
        {
          atomic_store((unint64_t)v41, (unint64_t *)&qword_1EB2CDFB8);
          CFAllocatorRef v41 = 0;
        }
        CFArrayRef v13 = (unsigned __int16 *)malloc_type_malloc(v40, 0x2DEE3412uLL);
        a4 = emoji_compression_decode((uint64_t)image, a4, (uint64_t)v13, v40, 1, v41, &v100);
        if (v41) {
          atomic_store((unint64_t)v41, (unint64_t *)&qword_1EB2CDFB8);
        }
        size_t v43 = (unsigned __int16)v100;
        if ((_WORD)v100 && (size_t v44 = WORD1(v100), WORD1(v100)))
        {
          CGContextRef v12 = (CGContextRef)&valuePtr;

          id v45 = (id)atomic_exchange((atomic_ullong *volatile)&v116, (unint64_t)CGImageCreate(v43, v44, 8uLL, 0x20uLL, a4 / v44, (CGColorSpaceRef)qword_1EB2CDFC0, 0x2002u, (CGDataProviderRef)atomic_load_explicit((atomic_ullong *volatile)&valuePtr, memory_order_acquire), 0, 1, kCGRenderingIntentDefault));
LABEL_59:

          a4 = atomic_load_explicit((atomic_ullong *volatile)&v116, memory_order_acquire);
          double v47 = (double)CGImageGetWidth((CGImageRef)a4);
          size_t v48 = CGImageGetHeight((CGImageRef)a4);
          *((double *)this + 5) = v47 / v15;
          *((double *)this + 6) = (double)v48 / v15;
LABEL_60:
          id v123 = (id)atomic_exchange((atomic_ullong *volatile)&v116, 0);
        }
        else
        {
          *(_OWORD *)((char *)this + 40) = *(_OWORD *)v12;
          id v123 = 0;
        }

        p_CGAffineTransform valuePtr = (_anonymous_namespace_::TCGImageData *)((char *)this + 16);
        if (atomic_load_explicit((atomic_ullong *volatile)this + 2, memory_order_acquire) && BYTE9(v107))
        {
          imagedouble a = (atomic_ullong *)((char *)this + 16);
          a4 = atomic_load_explicit((atomic_ullong *volatile)this + 2, memory_order_acquire);
          unint64_t v49 = CGImageGetWidth((CGImageRef)a4);
          CFArrayRef v13 = (unsigned __int16 *)CGImageGetHeight((CGImageRef)a4);
          size_t BitsPerComponent = CGImageGetBitsPerComponent((CGImageRef)a4);
          size_t BytesPerRow = CGImageGetBytesPerRow((CGImageRef)a4);
          ColorSpace = CGImageGetColorSpace((CGImageRef)a4);
          CGContextRef v12 = CGBitmapContextCreate(0, v49, (size_t)v13, BitsPerComponent, BytesPerRow, ColorSpace, 2u);
          CGContextClear();
          valuePtr.double a = -1.0;
          valuePtr.CGFloat b = 0.0;
          valuePtr.c = 0.0;
          valuePtr.CGFloat d = 1.0;
          valuePtr.tdouble x = (double)v49;
          valuePtr.tCGFloat y = 0.0;
          CGContextConcatCTM(v12, &valuePtr);
          v129.origin.double x = 0.0;
          v129.origin.CGFloat y = 0.0;
          v129.size.CGFloat width = (double)v49;
          v129.size.CGFloat height = (double)(unint64_t)v13;
          CGContextDrawImage(v12, v129, (CGImageRef)a4);
          CGImageRef v116 = CGBitmapContextCreateImage(v12);
        }
        if (atomic_load_explicit((atomic_ullong *volatile)p_valuePtr, memory_order_acquire)) {
          unint64_t v51 = atomic_load_explicit((atomic_ullong *volatile)this + 2, memory_order_acquire);
        }
        else {
          unint64_t v51 = *MEMORY[0x1E4F1D260];
        }
        objc_msgSend((id)atomic_load_explicit((atomic_ullong *volatile)&v103, memory_order_acquire), "setObject:forKey:", v51, v32);
LABEL_68:
        if (atomic_load_explicit((atomic_ullong *volatile)this + 2, memory_order_acquire)) {
          int v52 = v21;
        }
        else {
          int v52 = 0;
        }
        if (v52 != 1) {
          goto LABEL_98;
        }
        int v21 = -1431655766;
        id v100 = (id)0xAAAAAAAAAAAAAAAALL;
        *(double *)&uint64_t v101 = NAN;
        unint64_t v102 = 0xAAAAAAAAAAAAAAAALL;
        uint64_t v32 = (CGImage *)atomic_load_explicit((atomic_ullong *volatile)this + 2, memory_order_acquire);
        uint64_t EmojiMLUpscalingTimeout = TFont::GetEmojiMLUpscalingTimeout((atomic_ullong *)context);
        if (v54) {
          break;
        }
        std::__throw_bad_optional_access[abi:nn180100]();
LABEL_103:
        if (__cxa_guard_acquire(&qword_1EB2CDFD0))
        {
          qword_1EB2CDFC8 = compression_decode_scratch_buffer_size(COMPRESSION_LZFSE) + 186336;
          __cxa_guard_release(&qword_1EB2CDFD0);
        }
      }
      double v55 = *(double *)&EmojiMLUpscalingTimeout;
      *(void *)&valuePtr.double a = MEMORY[0x1E4F143A8];
      *(void *)&valuePtr.CGFloat b = 3321888768;
      *(void *)&valuePtr.c = ___ZZN12_GLOBAL__N_112TCGImageDataC1EPK5TFonttRK12TsbixContextd7CGPointENKUlP7CGImagedE_cvU13block_pointerFvS9_dEEv_block_invoke;
      *(void *)&valuePtr.CGFloat d = &__block_descriptor_48_8_32c87_ZTSKZN12_GLOBAL__N_112TCGImageDataC1EPK5TFonttRK12TsbixContextd7CGPointEUlP7CGImagedE__e21_v24__0__CGImage__8d16l;
      *(void *)&valuePtr.tdouble x = v31;
      valuePtr.tCGFloat y = v99;
      uint64_t v56 = objc_msgSend((id)objc_msgSend(&valuePtr, "copy"), "autorelease");

      CGImageRef v116 = 0;
      int64x2_t v117 = &v116;
      uint64_t v118 = 0x3052000000;
      uint64_t v119 = __Block_byref_object_copy__54;
      unint64_t v120 = __Block_byref_object_dispose__55;
      CGImageRef v58 = (CGImageRef)qword_1EB2CE010;
      uint64_t v121 = qword_1EB2CE010;
      if (!qword_1EB2CE010)
      {
        id v123 = (id)MEMORY[0x1E4F143A8];
        uint64_t v124 = 3221225472;
        uint64_t v125 = (uint64_t)___ZL18getMADServiceClassv_block_invoke;
        CFIndex v126 = &unk_1E528A348;
        CFIndex v127 = &v116;
        MediaAnalysisServicesLibraryCore(v57);
        Class Class = objc_getClass("MADService");
        double v60 = v127;
        *((void *)v127[1] + 5) = Class;
        qword_1EB2CE010 = *((void *)v60[1] + 5);
        CGImageRef v58 = v117[5];
      }
      _Block_object_dispose(&v116, 8);
      CFArrayRef v61 = (char **)[(CGImage *)v58 service];
      uint64_t v62 = v61;
      CGImageRef v116 = 0;
      int64x2_t v117 = &v116;
      uint64_t v118 = 0x3052000000;
      uint64_t v119 = __Block_byref_object_copy__54;
      unint64_t v120 = __Block_byref_object_dispose__55;
      uint64_t v63 = (objc_class *)qword_1EB2CE018;
      uint64_t v121 = qword_1EB2CE018;
      if (!qword_1EB2CE018)
      {
        id v123 = (id)MEMORY[0x1E4F143A8];
        uint64_t v124 = 3221225472;
        uint64_t v125 = (uint64_t)___ZL27getMADMLScalingRequestClassv_block_invoke;
        CFIndex v126 = &unk_1E528A348;
        CFIndex v127 = &v116;
        MediaAnalysisServicesLibraryCore(v61);
        Class v64 = objc_getClass("MADMLScalingRequest");
        double v65 = v127;
        *((void *)v127[1] + 5) = v64;
        qword_1EB2CE018 = *((void *)v65[1] + 5);
        uint64_t v63 = v117[5];
      }
      _Block_object_dispose(&v116, 8);
      id v66 = (id)[[v63 alloc] initWithScaledImageWidth:320 scaledImageHeight:320];
      if (v66)
      {
        CGFloat v67 = *(double *)&v66;
        double v68 = v55;
        double v69 = dispatch_group_create();
        CGImageRef v116 = 0;
        int64x2_t v117 = &v116;
        uint64_t v118 = 0x3812000000;
        uint64_t v119 = __Block_byref_object_copy__0;
        uint64_t v121 = 0;
        id v122 = 0;
        unint64_t v120 = __Block_byref_object_dispose__0;
        id v123 = 0;
        uint64_t v124 = (uint64_t)&v123;
        uint64_t v125 = 0x2020000000;
        CFIndex v126 = 0;
        uint64_t v70 = CGImageGetColorSpace(v32);
        CGImageRef v71 = 0;
        if (CGColorSpaceGetModel(v70) != kCGColorSpaceModelRGB)
        {
          unint64_t v72 = CGImageGetWidth(v32);
          size_t v73 = CGImageGetHeight(v32);
          imageCGFloat b = v32;
          uint64_t v74 = v31;
          CFStringRef v75 = v62;
          uint64_t v76 = v56;
          size_t v77 = v73;
          DeviceRGB = CGColorSpaceCreateDeviceRGB();
          uint64_t v79 = CGBitmapContextCreate(0, v72, v77, 8uLL, 0, DeviceRGB, 2u);
          CGContextClear();
          v130.size.CGFloat width = (double)v72;
          v130.size.CGFloat height = (double)v77;
          uint64_t v56 = v76;
          uint64_t v62 = v75;
          uint64_t v31 = v74;
          uint64_t v32 = imageb;
          v130.origin.double x = 0.0;
          v130.origin.CGFloat y = 0.0;
          CGContextDrawImage(v79, v130, imageb);
          CGImageRef v71 = CGBitmapContextCreateImage(v79);
        }
        if (v71) {
          CGImageRef v80 = v71;
        }
        else {
          CGImageRef v80 = v32;
        }
        dispatch_group_enter(v69);
        *(CGFloat *)CFIndex v128 = v67;
        uint64_t v81 = [MEMORY[0x1E4F1C978] arrayWithObjects:v128 count:1];
        *(void *)&valuePtr.double a = MEMORY[0x1E4F143A8];
        *(void *)&valuePtr.CGFloat b = 3221225472;
        *(void *)&valuePtr.c = ___ZL22GetMLUpscaledImageDataP7CGImagemmdU13block_pointerFvS0_dE_block_invoke;
        *(void *)&valuePtr.CGFloat d = &unk_1E528A2E8;
        valuePtr.tdouble x = v67;
        *(void *)&valuePtr.tCGFloat y = v69;
        double v114 = &v123;
        CGImageRef v115 = v80;
        uint64_t v112 = v56;
        id v113 = &v116;
        [v62 performRequests:v81 onCGImage:v80 withOrientation:1 andIdentifier:0 completionHandler:&valuePtr];
        if (v68 >= 0.0)
        {
          double v82 = 0.5;
          if (v68 != 0.0) {
            double v82 = v68;
          }
          double v83 = v82 * 1000000000.0;
          BOOL v84 = v82 <= 2.0;
          double v85 = 2000000000.0;
          if (v84) {
            double v85 = v83;
          }
          dispatch_time_t v86 = dispatch_time(0, (uint64_t)v85);
          dispatch_group_wait(v69, v86);
          dispatch_release(v69);
          if (atomic_load_explicit((atomic_ullong *volatile)v117 + 6, memory_order_acquire)
            && *(double *)(v124 + 24) > 2.22044605e-16)
          {
            id v109 = (id)atomic_load_explicit((atomic_ullong *volatile)v117 + 6, memory_order_acquire);
            uint64_t v110 = *(void *)(v124 + 24);
            id v100 = (id)atomic_exchange((atomic_ullong *volatile)&v109, 0);
            uint64_t v101 = v110;
            LOBYTE(v102) = 1;

            _Block_object_dispose(&v123, 8);
            _Block_object_dispose(&v116, 8);

            double v87 = *(double *)&v101;
            uint64_t v88 = (CGImage *)atomic_load_explicit((atomic_ullong *volatile)this + 2, memory_order_acquire);
            double v89 = v15 * v87;
            double v90 = (double)CGImageGetWidth(v88);
            size_t v91 = CGImageGetHeight(v88);
            *((double *)this + 5) = v90 / v89;
            *((double *)this + 6) = (double)v91 / v89;
            goto LABEL_96;
          }
        }
        else
        {
          dispatch_release(v69);
        }
        LOBYTE(v100) = 0;
        LOBYTE(v102) = 0;

        _Block_object_dispose(&v123, 8);
        _Block_object_dispose(&v116, 8);
      }
      else
      {
        LOBYTE(v100) = 0;
        LOBYTE(v102) = 0;
      }
      uint64_t v92 = (void *)atomic_load_explicit((atomic_ullong *volatile)&v104, memory_order_acquire);
      objc_msgSend(v92, "setObject:forKey:", objc_msgSend(MEMORY[0x1E4F1CA98], "null"), *(void *)&v99);
LABEL_96:
      if ((_BYTE)v102) {

      }
      goto LABEL_98;
    }
  }
  return this;
}

unint64_t emoji_compression_decode_scratch_buffer_size(int a1)
{
  return (7 * HIWORD(a1) + 18) * (unint64_t)(unsigned __int16)a1
       + HIWORD(a1)
       + compression_decode_scratch_buffer_size(COMPRESSION_LZFSE)
       + 4096;
}

unint64_t emoji_compression_decode(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, char a5, uint8_t *a6, _WORD *a7)
{
  unint64_t v7 = a2 - 12;
  if (a2 < 0xC) {
    return 0;
  }
  unint64_t v9 = 0;
  if (*(_DWORD *)a1 == 829058405 && *(_WORD *)(a1 + 4) == 256)
  {
    int v11 = *(unsigned __int16 *)(a1 + 6);
    uint64_t v12 = *(unsigned __int16 *)(a1 + 8);
    uint64_t v13 = *(unsigned __int16 *)(a1 + 10);
    *a7 = v12;
    a7[1] = v13;
    unint64_t v9 = (4 * v12 * v13);
    if (a3)
    {
      if (v9 > a4) {
        return 0;
      }
      if ((v11 - 41217) > 1) {
        return 0;
      }
      double v16 = a6;
      if (!a6)
      {
        size_t v17 = compression_decode_scratch_buffer_size(COMPRESSION_LZFSE);
        double v16 = (uint8_t *)malloc_type_malloc(v13 + (7 * (int)v13 + 18) * (uint64_t)(int)v12 + v17 + 4096, 0x4D4BE486uLL);
        if (!v16) {
          return 0;
        }
      }
      v20[0] = a3;
      v20[1] = v13;
      v20[2] = v12;
      double v20[3] = 4 * v12;
      uint64_t v18 = vImageCompressionDecode_BGRA8888(a1 + 12, v7, v20, a5, v16);
      if (!a6) {
        free(v16);
      }
      if (v18) {
        return 0;
      }
    }
  }
  return v9;
}

uint64_t vImageCompressionDecode_BGRA8888(uint64_t a1, unint64_t a2, void *a3, char a4, uint8_t *a5)
{
  uint64_t result = -21773;
  if (a1)
  {
    if (a3)
    {
      uint64_t result = -21773;
      if (a5)
      {
        if (*a3)
        {
          uint64_t v8 = a3[1];
          unint64_t v9 = a3[2];
          if (a2 < 4) {
            unsigned int v10 = 0;
          }
          else {
            unsigned int v10 = *(_DWORD *)a1;
          }
          unint64_t v11 = v9 * v8;
          size_t v12 = v8 - v9 * v8 + 8 * v9 * v8;
          uint64_t v13 = a5 + 4096;
          double v14 = (int16x8_t *)&a5[v12 + 4096];
          size_t v15 = 3 * v9 * v8;
          uint64_t v16 = a3[1];
          compression_decode_buffer(a5 + 4096, v12, (const uint8_t *)(a1 + 4), a2 - 4, (char *)v14 + 18 * v9, COMPRESSION_LZFSE);
          if (v15 < v10) {
            return -21776;
          }
          size_t v17 = &v13[v11];
          uint64_t v18 = &v13[v11 + v16];
          uint64_t v19 = &v18[v15];
          uint64_t v309 = v16;
          uint64_t v307 = v17;
          if (v10 <= 0x1000)
          {
            memcpy(a5, &v18[v15], v10);
            bzero(&v18[v15], v15);
            int v21 = a5;
            if (!v10)
            {
              size_t v322 = v12;
              double v27 = 0;
              goto LABEL_24;
            }
          }
          else
          {
            double v20 = (uint8_t *)malloc_type_malloc(v10, 0x24DCC0CCuLL);
            if (!v20) {
              return -21771;
            }
            int v21 = v20;
            memcpy(v20, &v18[v15], v10);
            bzero(&v18[v15], v15);
          }
          unint64_t v24 = *v21;
          size_t v322 = v12;
          if ((uint64_t)v15 <= (uint64_t)(v24 >> 2))
          {
LABEL_18:
            double v27 = 0;
          }
          else
          {
            unint64_t v25 = 0;
            uint64_t v26 = &v19[v24 >> 2];
            while (1)
            {
              *v26++ = v24 & 3;
              if (v10 - 1 == v25) {
                break;
              }
              unint64_t v24 = v21[v25 + 1];
              v26 += v24 >> 2;
              ++v25;
              if (v26 >= &v19[v15])
              {
                if (v25 < v10) {
                  goto LABEL_18;
                }
                break;
              }
            }
            double v27 = (unsigned char *)(v26 - v19);
          }
          if (v10 > 0x1000) {
            free(v21);
          }
LABEL_24:
          long long v28 = a3;
          uint64_t v29 = v309;
          CGImageRef v30 = v307;
          if ((unint64_t)v27 < v15) {
            return -21776;
          }
          unint64_t v31 = 3 * v9;
          size_t v32 = 6 * v9;
          uint64_t v326 = &v14->i16[3 * v9];
          uint64_t v33 = 12 * v9;
          double v34 = (unsigned char *)*a3;
          size_t v35 = &v14->i16[6 * v9];
          if (v9 <= 7)
          {
            if (v309)
            {
              uint64_t v210 = 0;
              uint64_t v211 = (int16x8_t *)(v326 - 3);
              if (v31 <= 1) {
                uint64_t v212 = 1;
              }
              else {
                uint64_t v212 = 3 * v9;
              }
              uint64_t v311 = v212;
              v315 = (__int16 *)&a5[v322];
              uint64_t v305 = v33 + 4110;
              size_t v306 = v32 + 4110;
              uint64_t v213 = &a5[v322 + v33];
              unsigned int v324 = &a5[v322 + v32];
              uint64_t v325 = v213;
              uint64_t v319 = v33 + 4102;
              size_t v321 = v32 + 4096;
              uint64_t v303 = (__int16 *)(v213 + 4102);
              while (2)
              {
                if (v210)
                {
                  int v214 = v30;
                  memcpy(v14, v326, v32);
                  uint64_t v211 = (int16x8_t *)(v326 - 3);
                  uint64_t v33 = 12 * v9;
                  size_t v32 = 6 * v9;
                  CGImageRef v30 = v214;
                  uint64_t v29 = v309;
                  long long v28 = a3;
                }
                uint64_t v215 = (unsigned __int16 *)v14 + 3 * v9;
                if (v9)
                {
                  uint64_t v216 = 0;
                  unint64_t v217 = v9;
                  do
                  {
                    uint64_t v218 = &v35[v216];
                    int v219 = v18[v216];
                    unsigned int v220 = v219 | (v19[v216] << 8);
                    *uint64_t v218 = ((v219 & 1) - 1) & (v220 >> 1) | ((__int16)((_WORD)v219 << 15) >> 15) & -(__int16)(v220 >> 1);
                    int v221 = v18[v216 + 1];
                    unsigned int v222 = v221 | (v19[v216 + 1] << 8);
                    v218[1] = ((v221 & 1) - 1) & (v222 >> 1) | ((__int16)((_WORD)v221 << 15) >> 15) & -(__int16)(v222 >> 1);
                    int v223 = v18[v216 + 2];
                    unsigned int v224 = v223 | (v19[v216 + 2] << 8);
                    v218[2] = ((v223 & 1) - 1) & (v224 >> 1) | ((__int16)((_WORD)v223 << 15) >> 15) & -(__int16)(v224 >> 1);
                    v216 += 3;
                    --v217;
                  }
                  while (v217);
                }
                int v225 = *v30++;
                switch(v225)
                {
                  case 0:
                    v226 = v30;
                    memcpy(v326, (char *)v14 + 12 * v9, v32);
                    uint64_t v211 = (int16x8_t *)(v326 - 3);
                    uint64_t v33 = 12 * v9;
                    size_t v32 = 6 * v9;
                    CGImageRef v30 = v226;
                    uint64_t v215 = (unsigned __int16 *)v14 + 3 * v9;
                    uint64_t v29 = v309;
                    long long v28 = a3;
                    goto LABEL_174;
                  case 1:
                    *uint64_t v326 = v14->i16[0] + *v35;
                    v326[1] = v14->i16[1] + v35[1];
                    v326[2] = v14->i16[2] + v35[2];
                    if (v31 >= 9)
                    {
                      uint64_t v239 = 0;
                      unint64_t v240 = v315;
                      uint64_t v241 = 9;
                      uint64_t v242 = 3;
                      do
                      {
                        uint64_t v243 = v241;
                        uint64_t v244 = (char *)v240 + v306;
                        int v245 = *(__int16 *)((char *)v240 + v306 - 14);
                        int v246 = v240[2051];
                        int v247 = v240[2048];
                        unsigned int v248 = v246 - v247;
                        if (v246 - v247 < 0) {
                          unsigned int v248 = v247 - v246;
                        }
                        int v249 = v245 - v247;
                        if (v249 < 0) {
                          int v249 = -v249;
                        }
                        uint64_t v250 = (char *)v240 + v305;
                        __int16 v251 = *(__int16 *)((char *)v240 + v305 - 8);
                        if (v248 <= v249)
                        {
                          uint64_t v252 = v211;
                        }
                        else
                        {
                          LOWORD(v245) = v240[2051];
                          uint64_t v252 = v14;
                        }
                        __int16 v253 = v245 + v251;
                        *((_WORD *)v244 - 4) = v245 + v251;
                        uint64_t v254 = &v252->i8[2 * v239];
                        __int16 v255 = *((_WORD *)v254 + 4) + *((_WORD *)v250 - 3);
                        *((_WORD *)v244 - 3) = v255;
                        __int16 v256 = *((_WORD *)v254 + 5) + *((_WORD *)v250 - 2);
                        *((_WORD *)v244 - 2) = v256;
                        int v257 = v240[2054];
                        unsigned int v258 = v257 - v246;
                        if (v257 - v246 < 0) {
                          unsigned int v258 = v246 - v257;
                        }
                        int v259 = v253 - v246;
                        if (v259 >= 0) {
                          unsigned int v260 = v259;
                        }
                        else {
                          unsigned int v260 = -v259;
                        }
                        __int16 v261 = *((_WORD *)v250 - 1);
                        if (v258 <= v260)
                        {
                          *((_WORD *)v244 - 1) = v261 + v253;
                          *(__int16 *)((char *)v240 + v306) = *(__int16 *)((char *)v240 + v305) + v255;
                          uint64_t v262 = v242 + 5;
                        }
                        else
                        {
                          *((_WORD *)v244 - 1) = v261 + v257;
                          *(__int16 *)((char *)v240 + v306) = v240[2055] + *(__int16 *)((char *)v240 + v305);
                          uint64_t v262 = v239 + 8;
                          __int16 v256 = v240[2056];
                        }
                        v240 += 6;
                        v326[v262] = v35[v262] + v256;
                        uint64_t v241 = v243 + 6;
                        uint64_t v263 = v239 + 6;
                        unint64_t v264 = v239 + 15;
                        v239 += 6;
                        uint64_t v242 = v243;
                      }
                      while (v264 <= v31);
                      unint64_t v227 = v263 + 3;
                      long long v28 = a3;
                      uint64_t v29 = v309;
                    }
                    else
                    {
                      unint64_t v227 = 3;
                    }
                    if (v227 < v31)
                    {
                      uint64_t v265 = 2 * v227;
                      do
                      {
                        char v266 = &v324[v265];
                        int v267 = *(__int16 *)&v324[v265 + 4090];
                        int v268 = v14->i16[(unint64_t)v265 / 2];
                        int v269 = v14->i16[(unint64_t)v265 / 2 - 3];
                        unsigned int v270 = v268 - v269;
                        if (v268 - v269 < 0) {
                          unsigned int v270 = v269 - v268;
                        }
                        int v271 = v267 - v269;
                        if (v271 < 0) {
                          int v271 = -v271;
                        }
                        v272 = &v325[v265];
                        if (v270 <= v271)
                        {
                          uint64_t v273 = v211;
                        }
                        else
                        {
                          LOWORD(v267) = v14->i16[(unint64_t)v265 / 2];
                          uint64_t v273 = v14;
                        }
                        *((_WORD *)v266 + 2048) = v267 + *(_WORD *)&v325[v265 + 4096];
                        uint64_t v274 = &v273->i8[v265];
                        *((_WORD *)v266 + 2049) = *((_WORD *)v274 + 1) + *((_WORD *)v272 + 2049);
                        *((_WORD *)v266 + 2050) = *((_WORD *)v274 + 2) + *((_WORD *)v272 + 2050);
                        v227 += 3;
                        v265 += 6;
                      }
                      while (v227 < v31);
                    }
                    goto LABEL_174;
                  case 2:
                    *uint64_t v326 = *v35;
                    v326[1] = v35[1];
                    v326[2] = v35[2];
                    if (v31 >= 4)
                    {
                      uint64_t v228 = v303;
                      uint64_t v229 = &v14->i16[3 * v9];
                      unint64_t v230 = v31 - 3;
                      do
                      {
                        __int16 v231 = *v228++;
                        v229[3] = v231 + *v229;
                        ++v229;
                        --v230;
                      }
                      while (v230);
                    }
                    goto LABEL_174;
                  case 3:
                    uint64_t v232 = v14;
                    uint64_t v233 = v311;
                    if (!v9) {
                      goto LABEL_182;
                    }
                    do
                    {
                      v232->i16[v32 / 2] = v232->i16[(unint64_t)v33 / 2] + v232->i16[0];
                      uint64_t v232 = (int16x8_t *)((char *)v232 + 2);
                      --v233;
                    }
                    while (v233);
LABEL_174:
                    if (a4)
                    {
                      if (v9)
                      {
                        uint64_t v275 = 0;
                        UChar32 v276 = v34;
                        int v277 = v215;
                        do
                        {
                          int v278 = v13[v275];
                          int v279 = *v277 - ((__int16)(v277[2] + (v277[2] >> 15)) >> 1);
                          int v280 = v279 + v277[2];
                          int v281 = v279 - ((__int16)(v277[1] + (v277[1] >> 15)) >> 1);
                          int v282 = v281 + v277[1];
                          *UChar32 v276 = (unsigned __int16)(v281 * v278 + 128 + (((v281 * v278 + 128) & 0xFF00u) >> 8)) >> 8;
                          v276[1] = (unsigned __int16)(v280 * v278 + 128 + (((v280 * v278 + 128) & 0xFF00u) >> 8)) >> 8;
                          v276[2] = (unsigned __int16)(v282 * v278 + 128 + (((v282 * v278 + 128) & 0xFF00u) >> 8)) >> 8;
                          v276[3] = v278;
                          v276 += 4;
                          ++v275;
                          v277 += 3;
                        }
                        while (v9 != v275);
                      }
                    }
                    else if (v9)
                    {
                      uint64_t v283 = 0;
                      uint64_t v284 = v34;
                      char v285 = v215;
                      do
                      {
                        uint8_t v286 = v13[v283];
                        int v287 = *v285 - ((__int16)(v285[2] + (v285[2] >> 15)) >> 1) + v285[2];
                        __int16 v288 = *v285
                             - (__int16)v285[2] / 2
                             - ((__int16)(v285[1] + (v285[1] >> 15)) >> 1)
                             + v285[1];
                        *uint64_t v284 = *(unsigned char *)v285
                              - (__int16)v285[2] / 2
                              + -((__int16)(v285[1] + (v285[1] >> 15)) >> 1);
                        v284[1] = v287;
                        v284[2] = v288;
                        v284[3] = v286;
                        v284 += 4;
                        ++v283;
                        v285 += 3;
                      }
                      while (v9 != v283);
                    }
LABEL_182:
                    uint64_t result = 0;
                    v18 += v31;
                    v19 += v31;
                    v13 += v9;
                    v34 += v28[3];
                    if (++v210 == v29) {
                      return result;
                    }
                    continue;
                  case 4:
                    for (uint64_t i = 0; i != 3; ++i)
                      v326[i] = v35[i] + v14->i16[i];
                    uint64_t v235 = v315;
                    unint64_t v236 = v31 - 3;
                    if (v31 >= 4)
                    {
                      do
                      {
                        int v237 = *(__int16 *)((char *)v235 + v321) + v235[2051];
                        if (v237 + 1 >= 0) {
                          unsigned int v238 = v237 + 1;
                        }
                        else {
                          unsigned int v238 = v237 + 2;
                        }
                        *(__int16 *)((char *)v235 + v321 + 6) = *(__int16 *)((char *)v235 + v319) + (v238 >> 1);
                        ++v235;
                        --v236;
                      }
                      while (v236);
                    }
                    goto LABEL_174;
                  default:
                    goto LABEL_174;
                }
              }
            }
          }
          else if (v309)
          {
            BOOL v310 = (int8x16_t *)*a3;
            uint64_t v36 = 0;
            CFIndex v294 = (int16x8_t *)((char *)v14 + 2 * v31 - 16);
            int v295 = (int16x8_t *)&v35[v31 - 8];
            unint64_t v298 = ((v31 - 8) & 0xFFFFFFFFFFFFFFF8) + 8;
            uint64_t v37 = 8 - (v9 & 7);
            uint64_t v299 = -(uint64_t)(4 * v37);
            uint64_t v38 = v322 + v33 + 4096;
            uint64_t v316 = v309 + v309 * v9 + 4096;
            uint64_t v314 = v309 * ((4 * v9) | 1) + 4096;
            char v296 = (__int16 *)&a5[v322];
            size_t v293 = v32 + 4110;
            uint64_t v39 = v33 + 4110;
            size_t v40 = v322 + v32;
            CFAllocatorRef v41 = &a5[v322 + v32];
            uint64_t v292 = v33 + 4102;
            int8x16_t v42 = (int8x16_t)xmmword_184BA6050;
            int8x16_t v43 = (int8x16_t)xmmword_184BA6060;
            int8x16_t v44 = (int8x16_t)xmmword_184BA6070;
            int8x16_t v45 = (int8x16_t)xmmword_184BA6080;
            int8x16_t v46 = (int8x16_t)xmmword_184BA6090;
            int8x16_t v47 = (int8x16_t)xmmword_184BA60A0;
            int8x16_t v48 = (int8x16_t)xmmword_184BA60B0;
            int8x16_t v49 = (int8x16_t)xmmword_184BA60C0;
            int8x16_t v50 = (int8x16_t)xmmword_184BA60D0;
            int8x16_t v51 = (int8x16_t)xmmword_184BA60E0;
            int8x16_t v52 = (int8x16_t)xmmword_184BA60F0;
            v53.i64[0] = 0x1000100010001;
            v53.i64[1] = 0x1000100010001;
            v54.i64[0] = -1;
            v54.i64[1] = -1;
            size_t v318 = v32 + 4090;
            uint64_t v317 = v33 + 4096;
            uint64_t v323 = &a5[v322 + v33];
            uint64_t v297 = v38;
            v291 = &a5[v38];
            v320 = v41;
            uint64_t v55 = 4096;
            uint64_t v56 = 4096 - v37;
            unsigned int v289 = (int16x8_t *)&v326[v31 - 8];
            BOOL v290 = v41 + 4090;
            uint64_t v300 = -3 * v9;
            uint64_t v302 = v40 + 4096 - 2 * (3 * v37);
            size_t v304 = v40 + 4096;
            uint64_t v301 = v33 + 4110;
            while (1)
            {
              if (v36)
              {
                uint64_t v57 = v14;
                CGImageRef v58 = v30;
                uint64_t v59 = v35;
                double v60 = v19;
                CFArrayRef v61 = v18;
                uint64_t v62 = v14;
                uint64_t v63 = v56;
                uint64_t v64 = v36;
                uint64_t v65 = v55;
                memcpy(v57, v326, v32);
                uint64_t v55 = v65;
                uint64_t v36 = v64;
                uint64_t v56 = v63;
                double v14 = v62;
                uint64_t v18 = v61;
                uint64_t v19 = v60;
                size_t v35 = v59;
                unint64_t v31 = 3 * v9;
                v54.i64[0] = -1;
                v54.i64[1] = -1;
                v53.i64[0] = 0x1000100010001;
                v53.i64[1] = 0x1000100010001;
                int8x16_t v52 = (int8x16_t)xmmword_184BA60F0;
                int8x16_t v51 = (int8x16_t)xmmword_184BA60E0;
                int8x16_t v50 = (int8x16_t)xmmword_184BA60D0;
                int8x16_t v49 = (int8x16_t)xmmword_184BA60C0;
                int8x16_t v48 = (int8x16_t)xmmword_184BA60B0;
                int8x16_t v47 = (int8x16_t)xmmword_184BA60A0;
                int8x16_t v46 = (int8x16_t)xmmword_184BA6090;
                int8x16_t v45 = (int8x16_t)xmmword_184BA6080;
                int8x16_t v44 = (int8x16_t)xmmword_184BA6070;
                int8x16_t v43 = (int8x16_t)xmmword_184BA6060;
                int8x16_t v42 = (int8x16_t)xmmword_184BA6050;
                uint64_t v39 = v301;
                uint64_t v33 = 12 * v9;
                size_t v32 = 6 * v9;
                CGImageRef v30 = v58;
                uint64_t v29 = v309;
                long long v28 = a3;
              }
              if (v31 >= 8)
              {
                uint64_t v72 = v314;
                uint64_t v71 = v316;
                uint64_t v73 = v297;
                unint64_t v74 = 8;
                uint64_t v70 = v310;
                do
                {
                  v22.i64[0] = *(void *)&a5[v71];
                  v23.i64[0] = *(void *)&a5[v72];
                  int8x16_t v75 = vzip1q_s8(v22, (int8x16_t)v23);
                  int16x8_t v76 = (int16x8_t)vandq_s8(v75, v53);
                  int16x8_t v77 = (int16x8_t)vshrq_n_u16((uint16x8_t)v75, 1uLL);
                  int8x16_t v78 = vandq_s8((int8x16_t)vaddq_s16(v76, v54), (int8x16_t)v77);
                  int16x8_t v23 = vceqzq_s16(v76);
                  int8x16_t v22 = vorrq_s8(v78, vbicq_s8((int8x16_t)vnegq_s16(v77), (int8x16_t)v23));
                  *(int8x16_t *)&a5[v73] = v22;
                  v74 += 8;
                  v73 += 16;
                  v71 += 8;
                  v72 += 8;
                }
                while (v74 <= v31);
                double v69 = &a5[v73];
                double v68 = &a5[v71];
                CGFloat v67 = &a5[v72];
                unint64_t v66 = v298;
              }
              else
              {
                unint64_t v66 = 0;
                CGFloat v67 = v19;
                double v68 = v18;
                double v69 = (uint8_t *)v35;
                uint64_t v70 = v310;
              }
              if (v66 < v31)
              {
                unint64_t v79 = v300 + v66;
                do
                {
                  int v81 = *v68++;
                  int v80 = v81;
                  int v82 = *v67++;
                  *(_WORD *)double v69 = ((v80 & 1) - 1) & ((v80 | (v82 << 8)) >> 1) | ((__int16)((_WORD)v80 << 15) >> 15) & -(__int16)((v80 | (v82 << 8)) >> 1);
                  v69 += 2;
                  BOOL v83 = __CFADD__(v79++, 1);
                }
                while (!v83);
              }
              int v84 = *v30++;
              uint64_t v308 = v55;
              switch(v84)
              {
                case 0:
                  double v85 = v30;
                  memcpy(v326, v35, v32);
                  v54.i64[0] = -1;
                  v54.i64[1] = -1;
                  v53.i64[0] = 0x1000100010001;
                  v53.i64[1] = 0x1000100010001;
                  int8x16_t v52 = (int8x16_t)xmmword_184BA60F0;
                  int8x16_t v51 = (int8x16_t)xmmword_184BA60E0;
                  int8x16_t v50 = (int8x16_t)xmmword_184BA60D0;
                  int8x16_t v49 = (int8x16_t)xmmword_184BA60C0;
                  int8x16_t v48 = (int8x16_t)xmmword_184BA60B0;
                  int8x16_t v47 = (int8x16_t)xmmword_184BA60A0;
                  int8x16_t v46 = (int8x16_t)xmmword_184BA6090;
                  int8x16_t v45 = (int8x16_t)xmmword_184BA6080;
                  int8x16_t v44 = (int8x16_t)xmmword_184BA6070;
                  int8x16_t v43 = (int8x16_t)xmmword_184BA6060;
                  int8x16_t v42 = (int8x16_t)xmmword_184BA6050;
                  uint64_t v39 = v301;
                  uint64_t v33 = 12 * v9;
                  size_t v32 = 6 * v9;
                  CGImageRef v30 = v85;
                  uint64_t v29 = v309;
                  uint64_t v70 = v310;
                  long long v28 = a3;
                  uint64_t v55 = v308;
                  break;
                case 1:
                  *uint64_t v326 = v14->i16[0] + *v35;
                  v326[1] = v14->i16[1] + v35[1];
                  v326[2] = v14->i16[2] + v35[2];
                  if (v31 >= 9)
                  {
                    uint64_t v90 = 0;
                    size_t v91 = v296;
                    uint64_t v92 = 9;
                    uint64_t v93 = 3;
                    do
                    {
                      uint64_t v94 = v92;
                      uint64_t v95 = (char *)v91 + v293;
                      int v96 = *(__int16 *)((char *)v91 + v293 - 14);
                      int v97 = v91[2051];
                      int v98 = v91[2048];
                      unsigned int v99 = v97 - v98;
                      if (v97 - v98 < 0) {
                        unsigned int v99 = v98 - v97;
                      }
                      int v100 = v96 - v98;
                      if (v100 < 0) {
                        int v100 = -v100;
                      }
                      uint64_t v101 = (char *)v91 + v39;
                      __int16 v102 = *(__int16 *)((char *)v91 + v39 - 8);
                      if (v99 <= v100)
                      {
                        id v103 = (int16x8_t *)(v326 - 3);
                      }
                      else
                      {
                        LOWORD(v96) = v91[2051];
                        id v103 = v14;
                      }
                      __int16 v104 = v96 + v102;
                      *((_WORD *)v95 - 4) = v96 + v102;
                      long long v105 = &v103->i8[2 * v90];
                      __int16 v106 = *((_WORD *)v105 + 4) + *((_WORD *)v101 - 3);
                      *((_WORD *)v95 - 3) = v106;
                      __int16 v107 = *((_WORD *)v105 + 5) + *((_WORD *)v101 - 2);
                      *((_WORD *)v95 - 2) = v107;
                      int v108 = v91[2054];
                      unsigned int v109 = v108 - v97;
                      if (v108 - v97 < 0) {
                        unsigned int v109 = v97 - v108;
                      }
                      int v110 = v104 - v97;
                      if (v110 >= 0) {
                        unsigned int v111 = v110;
                      }
                      else {
                        unsigned int v111 = -v110;
                      }
                      __int16 v112 = *((_WORD *)v101 - 1);
                      if (v109 <= v111)
                      {
                        *((_WORD *)v95 - 1) = v112 + v104;
                        *(__int16 *)((char *)v91 + v293) = *(__int16 *)((char *)v91 + v39) + v106;
                        uint64_t v113 = v93 + 5;
                      }
                      else
                      {
                        *((_WORD *)v95 - 1) = v112 + v108;
                        *(__int16 *)((char *)v91 + v293) = v91[2055] + *(__int16 *)((char *)v91 + v39);
                        uint64_t v113 = v90 + 8;
                        __int16 v107 = v91[2056];
                      }
                      v91 += 6;
                      v326[v113] = v35[v113] + v107;
                      uint64_t v92 = v94 + 6;
                      uint64_t v114 = v90 + 6;
                      unint64_t v115 = v90 + 15;
                      v90 += 6;
                      uint64_t v93 = v94;
                    }
                    while (v115 <= v31);
                    unint64_t v86 = v114 + 3;
                    uint64_t v55 = v308;
                  }
                  else
                  {
                    unint64_t v86 = 3;
                  }
                  if (v86 < v31)
                  {
                    uint64_t v116 = 2 * v86;
                    do
                    {
                      int64x2_t v117 = &v320[v116];
                      int v118 = *(__int16 *)&v320[v116 + 4090];
                      int v119 = v14->i16[(unint64_t)v116 / 2];
                      int v120 = v14->i16[(unint64_t)v116 / 2 - 3];
                      unsigned int v121 = v119 - v120;
                      if (v119 - v120 < 0) {
                        unsigned int v121 = v120 - v119;
                      }
                      int v122 = v118 - v120;
                      if (v122 < 0) {
                        int v122 = -v122;
                      }
                      id v123 = &v323[v116];
                      BOOL v124 = v121 > v122;
                      if (v121 > v122) {
                        LOWORD(v118) = v14->i16[(unint64_t)v116 / 2];
                      }
                      uint64_t v125 = (int16x8_t *)(v326 - 3);
                      if (v124) {
                        uint64_t v125 = v14;
                      }
                      *((_WORD *)v117 + 2048) = v118 + *(_WORD *)&v323[v116 + 4096];
                      CFIndex v126 = &v125->i8[v116];
                      *((_WORD *)v117 + 2049) = *((_WORD *)v126 + 1) + *((_WORD *)v123 + 2049);
                      *((_WORD *)v117 + 2050) = *((_WORD *)v126 + 2) + *((_WORD *)v123 + 2050);
                      v86 += 3;
                      v116 += 6;
                    }
                    while (v86 < v31);
                  }
                  break;
                case 2:
                  *(void *)uint64_t v326 = *(void *)v35;
                  if (v31 >= 0xB)
                  {
                    CFIndex v127 = v326;
                    CFIndex v128 = v323 + 4102;
                    for (unint64_t j = 11; j <= v31; j += 3)
                    {
                      int16x8_t v130 = *(int16x8_t *)v128;
                      CFIndex v128 = (_OWORD *)((char *)v128 + 6);
                      *(int16x8_t *)(v127 + 3) = vaddq_s16(*(int16x8_t *)v127, v130);
                      v127 += 3;
                    }
                    unint64_t v87 = j - 8;
                  }
                  else
                  {
                    unint64_t v87 = 3;
                  }
                  if (v87 < v31)
                  {
                    unint64_t v131 = v300 + v87;
                    CFArrayRef v132 = &v291[2 * v87];
                    CFIndex v133 = &v290[2 * v87];
                    do
                    {
                      __int16 v134 = *(_WORD *)v132;
                      v132 += 2;
                      *((_WORD *)v133 + 3) = *(_WORD *)v133 + v134;
                      v133 += 2;
                      BOOL v83 = __CFADD__(v131++, 1);
                    }
                    while (!v83);
                  }
                  break;
                case 3:
                  if (v31 >= 0x10)
                  {
                    uint64_t v135 = 0;
                    BOOL v136 = v14;
                    do
                    {
                      int16x8_t v137 = vaddq_s16(v136[1], *(int16x8_t *)((char *)&v136[1] + v33));
                      unint64_t v138 = (int16x8_t *)((char *)v136 + v32);
                      int16x8_t *v138 = vaddq_s16(*v136, *(int16x8_t *)((char *)v136 + v33));
                      v138[1] = v137;
                      uint64_t v88 = v135 + 16;
                      unint64_t v139 = v135 + 32;
                      v136 += 2;
                      v135 += 16;
                    }
                    while (v139 <= v31);
                  }
                  else
                  {
                    uint64_t v88 = 0;
                  }
                  if ((v88 | 8uLL) <= v31)
                  {
                    *(int16x8_t *)&v326[v88] = vaddq_s16(*(int16x8_t *)((char *)v14 + 2 * v88), *(int16x8_t *)&v35[v88]);
                    v88 |= 8uLL;
                  }
                  if (v88 != v31) {
                    *unsigned int v289 = vaddq_s16(*v294, *v295);
                  }
                  break;
                case 4:
                  *uint64_t v326 = v14->i16[0] + *v35;
                  v326[1] = v14->i16[1] + v35[1];
                  v326[2] = v14->i16[2] + v35[2];
                  if (v31 >= 0xB)
                  {
                    unsigned __int16 v140 = v14;
                    for (unint64_t k = 11; k <= v31; k += 3)
                    {
                      size_t v142 = (size_t)v140->u64 + v32;
                      int8x16_t v143 = *(int8x16_t *)((char *)v140 + v32);
                      uint64_t v144 = (int16x8_t *)((char *)v140 + v292);
                      int16x8_t v145 = *(int16x8_t *)((char *)v140 + 6);
                      unsigned __int16 v140 = (int16x8_t *)((char *)v140 + 6);
                      uint16x8_t v146 = (uint16x8_t)vsubq_s16(v145, (int16x8_t)vmvnq_s8(v143));
                      *(int16x8_t *)(v142 + 6) = vsraq_n_s16(v144[-256], (int16x8_t)vsraq_n_u16(v146, v146, 0xFuLL), 1uLL);
                    }
                    unint64_t v89 = k - 8;
                  }
                  else
                  {
                    unint64_t v89 = 3;
                  }
                  if (v89 < v31)
                  {
                    unint64_t v147 = v300 + v89;
                    BOOL v148 = &v296[v89];
                    do
                    {
                      int v149 = *(__int16 *)((char *)v148 + v318) + v148[2048];
                      if (v149 + 1 >= 0) {
                        unsigned int v150 = v149 + 1;
                      }
                      else {
                        unsigned int v150 = v149 + 2;
                      }
                      *(__int16 *)((char *)v148 + v318 + 6) = *(__int16 *)((char *)v148 + v317) + (v150 >> 1);
                      ++v148;
                      BOOL v83 = __CFADD__(v147++, 1);
                    }
                    while (!v83);
                  }
                  break;
                default:
                  break;
              }
              if (a4)
              {
                uint64_t v152 = v302;
                size_t v151 = v304;
                uint64_t v153 = v56;
                uint64_t v154 = v55;
                unint64_t v155 = 8;
                char v156 = v70;
                do
                {
                  int8x16_t v157 = *(int8x16_t *)&a5[v151];
                  int8x16_t v158 = *(int8x16_t *)&a5[v151 + 16];
                  int8x16_t v159 = *(int8x16_t *)&a5[v151 + 32];
                  int16x8_t v160 = (int16x8_t)vqtbl1q_s8(v157, v43);
                  int16x8_t v161 = vaddq_s16((int16x8_t)vqtbl1q_s8(v158, v45), (int16x8_t)vqtbl1q_s8(v157, v42));
                  int16x8_t v162 = vaddq_s16((int16x8_t)vqtbl1q_s8(v158, v47), (int16x8_t)vqtbl1q_s8(v157, v44));
                  int16x8_t v163 = vaddq_s16(vaddq_s16((int16x8_t)vqtbl1q_s8(v158, v46), v160), (int16x8_t)vqtbl1q_s8(v159, v49));
                  int16x8_t v164 = vaddq_s16(v162, (int16x8_t)vqtbl1q_s8(v159, v50));
                  int16x8_t v165 = vsubq_s16(vaddq_s16(v161, (int16x8_t)vqtbl1q_s8(v159, v48)), vshrq_n_s16((int16x8_t)vsraq_n_u16((uint16x8_t)v164, (uint16x8_t)v164, 0xFuLL), 1uLL));
                  int16x8_t v166 = vaddq_s16(v165, v164);
                  int16x8_t v167 = vsubq_s16(v165, vshrq_n_s16((int16x8_t)vsraq_n_u16((uint16x8_t)v163, (uint16x8_t)v163, 0xFuLL), 1uLL));
                  int16x8_t v168 = vaddq_s16(v167, v163);
                  int16x8_t v169 = (int16x8_t)vmovl_u8(*(uint8x8_t *)&a5[v154]);
                  v160.i64[0] = 0x80008000800080;
                  v160.i64[1] = 0x80008000800080;
                  int16x8_t v170 = vmlaq_s16(v160, v167, v169);
                  v167.i64[0] = 0x80008000800080;
                  v167.i64[1] = 0x80008000800080;
                  int16x8_t v171 = vmlaq_s16(v167, v166, v169);
                  v166.i64[0] = 0x80008000800080;
                  v166.i64[1] = 0x80008000800080;
                  int16x8_t v172 = vmlaq_s16(v166, v168, v169);
                  *(int8x8_t *)v329.val[1].i8 = vaddhn_s16((int16x8_t)vshrq_n_u16((uint16x8_t)v172, 8uLL), v172);
                  v329.val[0] = vaddhn_high_s16(vaddhn_s16((int16x8_t)vshrq_n_u16((uint16x8_t)v170, 8uLL), v170), (int16x8_t)vshrq_n_u16((uint16x8_t)v171, 8uLL), v171);
                  v329.val[1].i64[1] = *(void *)&a5[v154];
                  int8x16_t v22 = vqtbl2q_s8(v329, v51);
                  int16x8_t v23 = (int16x8_t)vqtbl2q_s8(v329, v52);
                  int8x16_t *v156 = v22;
                  v156[1] = (int8x16_t)v23;
                  v156 += 2;
                  v155 += 8;
                  v154 += 8;
                  v153 += 8;
                  v151 += 48;
                  v152 += 48;
                }
                while (v155 <= v9);
                if ((v9 & 7) == 0) {
                  goto LABEL_115;
                }
                long long v173 = v156 - 2;
                long long v174 = (int8x16_t *)&a5[v152];
                int8x16_t v175 = v174[1];
                int8x16_t v176 = v174[2];
                int16x8_t v177 = vaddq_s16(vaddq_s16((int16x8_t)vqtbl1q_s8(v175, v46), (int16x8_t)vqtbl1q_s8(*v174, v43)), (int16x8_t)vqtbl1q_s8(v176, v49));
                int16x8_t v178 = vaddq_s16(vaddq_s16((int16x8_t)vqtbl1q_s8(v175, v47), (int16x8_t)vqtbl1q_s8(*v174, v44)), (int16x8_t)vqtbl1q_s8(v176, v50));
                int16x8_t v179 = vsubq_s16(vaddq_s16(vaddq_s16((int16x8_t)vqtbl1q_s8(v175, v45), (int16x8_t)vqtbl1q_s8(*v174, v42)), (int16x8_t)vqtbl1q_s8(v176, v48)), vshrq_n_s16((int16x8_t)vsraq_n_u16((uint16x8_t)v178, (uint16x8_t)v178, 0xFuLL), 1uLL));
                int16x8_t v180 = vaddq_s16(v179, v178);
                int16x8_t v181 = vsubq_s16(v179, vshrq_n_s16((int16x8_t)vsraq_n_u16((uint16x8_t)v177, (uint16x8_t)v177, 0xFuLL), 1uLL));
                int16x8_t v182 = vaddq_s16(v181, v177);
                int16x8_t v183 = (int16x8_t)vmovl_u8(*(uint8x8_t *)&a5[v153]);
                v184.i64[0] = 0x80008000800080;
                v184.i64[1] = 0x80008000800080;
                int16x8_t v185 = vmlaq_s16(v184, v181, v183);
                v181.i64[0] = 0x80008000800080;
                v181.i64[1] = 0x80008000800080;
                int16x8_t v186 = vmlaq_s16(v181, v180, v183);
                v180.i64[0] = 0x80008000800080;
                v180.i64[1] = 0x80008000800080;
                int16x8_t v23 = vmlaq_s16(v180, v182, v183);
                *(int8x8_t *)v330.val[1].i8 = vaddhn_s16((int16x8_t)vshrq_n_u16((uint16x8_t)v23, 8uLL), v23);
                v330.val[0] = vaddhn_high_s16(vaddhn_s16((int16x8_t)vshrq_n_u16((uint16x8_t)v185, 8uLL), v185), (int16x8_t)vshrq_n_u16((uint16x8_t)v186, 8uLL), v186);
                v330.val[1].i64[1] = *(void *)&a5[v153];
                *(int8x16_t *)((char *)v156 + v299) = vqtbl2q_s8(v330, v51);
                uint64_t v187 = v299;
                int8x16_t v22 = vqtbl2q_s8(v330, v52);
              }
              else
              {
                uint64_t v189 = v302;
                size_t v188 = v304;
                uint64_t v190 = v56;
                uint64_t v191 = v55;
                unint64_t v192 = 8;
                int v193 = v70;
                do
                {
                  int8x16_t v194 = *(int8x16_t *)&a5[v188];
                  int8x16_t v195 = *(int8x16_t *)&a5[v188 + 16];
                  int8x16_t v196 = *(int8x16_t *)&a5[v188 + 32];
                  v328.val[1] = vqtbl1q_s8(v194, v43);
                  int16x8_t v197 = vaddq_s16((int16x8_t)vqtbl1q_s8(v195, v45), (int16x8_t)vqtbl1q_s8(v194, v42));
                  int16x8_t v198 = vaddq_s16((int16x8_t)vqtbl1q_s8(v195, v47), (int16x8_t)vqtbl1q_s8(v194, v44));
                  int16x8_t v199 = vaddq_s16(vaddq_s16((int16x8_t)vqtbl1q_s8(v195, v46), (int16x8_t)v328.val[1]), (int16x8_t)vqtbl1q_s8(v196, v49));
                  int16x8_t v200 = vaddq_s16(v198, (int16x8_t)vqtbl1q_s8(v196, v50));
                  int16x8_t v201 = vsubq_s16(vaddq_s16(v197, (int16x8_t)vqtbl1q_s8(v196, v48)), vshrq_n_s16((int16x8_t)vsraq_n_u16((uint16x8_t)v200, (uint16x8_t)v200, 0xFuLL), 1uLL));
                  int8x16_t v202 = (int8x16_t)vaddq_s16(v201, v200);
                  int16x8_t v203 = vsubq_s16(v201, vshrq_n_s16((int16x8_t)vsraq_n_u16((uint16x8_t)v199, (uint16x8_t)v199, 0xFuLL), 1uLL));
                  *(int8x8_t *)v328.val[1].i8 = vmovn_s16(vaddq_s16(v203, v199));
                  v328.val[0] = vuzp1q_s8((int8x16_t)v203, v202);
                  v328.val[1].i64[1] = *(void *)&a5[v191];
                  int8x16_t v22 = vqtbl2q_s8(v328, v51);
                  int16x8_t v23 = (int16x8_t)vqtbl2q_s8(v328, v52);
                  int8x16_t *v193 = v22;
                  v193[1] = (int8x16_t)v23;
                  v193 += 2;
                  v192 += 8;
                  v191 += 8;
                  v190 += 8;
                  v188 += 48;
                  v189 += 48;
                }
                while (v192 <= v9);
                if ((v9 & 7) == 0) {
                  goto LABEL_115;
                }
                long long v173 = v193 - 2;
                long long v204 = (int8x16_t *)&a5[v189];
                int8x16_t v205 = v204[1];
                int8x16_t v206 = v204[2];
                v327.val[1] = (int8x16_t)vaddq_s16(vaddq_s16((int16x8_t)vqtbl1q_s8(v205, v46), (int16x8_t)vqtbl1q_s8(*v204, v43)), (int16x8_t)vqtbl1q_s8(v206, v49));
                int16x8_t v207 = vaddq_s16(vaddq_s16((int16x8_t)vqtbl1q_s8(v205, v47), (int16x8_t)vqtbl1q_s8(*v204, v44)), (int16x8_t)vqtbl1q_s8(v206, v50));
                int16x8_t v208 = vsubq_s16(vaddq_s16(vaddq_s16((int16x8_t)vqtbl1q_s8(v205, v45), (int16x8_t)vqtbl1q_s8(*v204, v42)), (int16x8_t)vqtbl1q_s8(v206, v48)), vshrq_n_s16((int16x8_t)vsraq_n_u16((uint16x8_t)v207, (uint16x8_t)v207, 0xFuLL), 1uLL));
                int16x8_t v23 = vaddq_s16(v208, v207);
                int16x8_t v209 = vsubq_s16(v208, vshrq_n_s16((int16x8_t)vsraq_n_u16((uint16x8_t)v327.val[1], (uint16x8_t)v327.val[1], 0xFuLL), 1uLL));
                *(int8x8_t *)v327.val[1].i8 = vmovn_s16(vaddq_s16(v209, (int16x8_t)v327.val[1]));
                v327.val[0] = vuzp1q_s8((int8x16_t)v209, (int8x16_t)v23);
                v327.val[1].i64[1] = *(void *)&a5[v190];
                *(int8x16_t *)((char *)v193 + v299) = vqtbl2q_s8(v327, v51);
                uint64_t v187 = v299;
                int8x16_t v22 = vqtbl2q_s8(v327, v52);
              }
              *(int8x16_t *)((char *)&v173[3] + v187) = v22;
LABEL_115:
              uint64_t result = 0;
              v18 += v31;
              v19 += v31;
              BOOL v310 = (int8x16_t *)((char *)v70 + v28[3]);
              ++v36;
              v316 += v31;
              v314 += v31;
              v55 += v9;
              v56 += v9;
              if (v36 == v29) {
                return result;
              }
            }
          }
          return 0;
        }
      }
    }
  }
  return result;
}

void TBaseFont::SetObject(os_unfair_lock_s *a1, int a2, const void *a3, const void *a4)
{
  uint64_t v8 = a1 + 111;
  os_unfair_lock_lock_with_options();
  unint64_t v9 = a1 + 138;
  if (!atomic_load_explicit((atomic_ullong *volatile)&v9[2 * a2], memory_order_acquire)) {

  }
  if (atomic_load_explicit((atomic_ullong *volatile)&v9[2 * a2], memory_order_acquire)) {
    CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v9[2 * a2], memory_order_acquire), a3, a4);
  }

  os_unfair_lock_unlock(v8);
}

void TBaseFont::RetainedObject(os_unfair_lock_s *a1@<X0>, int a2@<W1>, const void *a3@<X2>, void *a4@<X8>)
{
  uint64_t v8 = a1 + 111;
  os_unfair_lock_lock_with_options();
  *a4 = 0xAAAAAAAAAAAAAAAALL;
  CFDictionaryRef Value = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)&a1[2 * a2 + 138], memory_order_acquire);
  CFDictionaryRef v10 = Value;
  if (Value) {
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(Value, a3);
  }
  *a4 = Value;

  os_unfair_lock_unlock(v8);
}

uint64_t TFont::GetEmojiMLUpscalingTimeout(atomic_ullong *this)
{
  CFDictionaryRef v1 = (const __CFDictionary *)(id)atomic_load_explicit(this + 20, memory_order_acquire);
  if (v1)
  {
    CFDictionaryRef v2 = v1;
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v1, @"CTFontEmojiMLUpscalingTimeoutAttribute");

    if (Value)
    {
      uint64_t valuePtr = -1;
      CFNumberGetValue(Value, kCFNumberDoubleType, &valuePtr);
      return valuePtr;
    }
  }
  else
  {
  }
  return 0;
}

void ___Z22GetMorxConversionQueuev_block_invoke()
{
  unint64_t v0 = dispatch_queue_create("com.apple.CoreText.MorxConversion", 0);
  GetMorxConversionQueue(void)::sQueue = (uint64_t)v0;
  global_queue = dispatch_get_global_queue(-2, 0);
  dispatch_set_target_queue(v0, global_queue);
  CFDictionaryRef v2 = GetMorxConversionQueue(void)::sQueue;
  uint64_t v3 = (const void *)TDescriptorSource::DoNotCacheKey;

  dispatch_queue_set_specific(v2, v3, (void *)1, 0);
}

uint64_t ___Z17ConvertToMorxSyncPK9TBaseFont_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = ConvertArabicPresentationFormsToMorxInternal(*(const TBaseFont **)(a1 + 40), a2);
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

void __CTStringIsSuitableForVerticalLayout_block_invoke_2(uint64_t a1, double a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  Helper_x8__CEMStringIsSingleEmojuint64_t i = gotLoadHelper_x8__CEMStringIsSingleEmoji(a2);
  if (!*(void *)(v9 + 1800)
    || (CFDictionaryRef v10 = *(void **)(a1 + 32),
        uint64_t v11 = objc_msgSend(v7, "range", Helper_x8__CEMStringIsSingleEmoji),
        objc_msgSend(v10, "substringWithRange:", v11, v12),
        !CEMStringIsSingleEmoji_delayInitStub(v13)))
  {
    *a5 = 1;
    **(unsigned char **)(a1 + 40) = 1;
  }
}

uint64_t __CTStringIsSuitableForVerticalLayout_block_invoke(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned char *a7)
{
  uint64_t result = objc_msgSend((id)CTStringIsSuitableForVerticalLayout::nonCJKRegex, "enumerateMatchesInString:options:range:usingBlock:", MEMORY[0x1E4F143A8], 3221225472, __CTStringIsSuitableForVerticalLayout_block_invoke_2, &unk_1E528FCE8, a1[4], a7);
  if (*a7)
  {
    *(unsigned char *)(*(void *)(a1[5] + 8) + 24) = 0;
  }
  else
  {
    uint64_t v10 = a1[7];
    uint64_t v11 = *(void *)(a1[6] + 8);
    uint64_t v12 = *(void *)(v11 + 24);
    if (v10 && v12 == v10)
    {
      *(unsigned char *)(*(void *)(a1[5] + 8) + 24) = 0;
      *a7 = 1;
    }
    else
    {
      *(void *)(v11 + 24) = v12 + 1;
    }
  }
  return result;
}

uint64_t CTStringIsSuitableForVerticalLayout::$_0::__invoke(CTStringIsSuitableForVerticalLayout::$_0 *this, void *a2)
{
  unint64_t v3 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = [objc_alloc(MEMORY[0x1E4F28FD8]) initWithPattern:@"[^  [[\\p{Hani}\\p{Hira}\\p{Kana}\\p{Hang}]--\\p{vo=R}]  \\u3099\\u309A  \\p{Block=Katakana}  [[\\p{Block=Halfwidth_and_Fullwidth_Forms}\\p{Punctuation}]--\\p{vo=R}]  \\uFF0D  [\\p{gc=Zs}--\\u1680]]+" options:2 error:&v3];
  CTStringIsSuitableForVerticalLayout::nonCJKRegedouble x = result;
  return result;
}

void TFont::FindColorBitmapForGlyph(TFont *a1@<X0>, __int16 a2@<W1>, uint64_t a3@<X2>, uint64_t a4@<X8>, double a5@<D0>)
{
  uint64_t v6 = *(void *)(a3 + 8);
  if (!v6) {
    goto LABEL_48;
  }
  LOWORD(v8) = a2;
  unsigned int v10 = *(unsigned __int16 *)(v6 + 6) << 16;
  double EffectiveSize = TFont::GetEffectiveSize(a1);
  if (!v10) {
    goto LABEL_48;
  }
  char v12 = 0;
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  size_t v15 = 0;
  double v16 = round(EffectiveSize * a5);
  uint64_t v17 = bswap32(v10);
  unint64_t v19 = *(void *)(a3 + 8);
  unint64_t v18 = *(void *)(a3 + 16);
  double v20 = (unsigned int *)(v6 + 8);
  double v21 = 0.0;
  do
  {
    unsigned int v22 = *v20++;
    uint64_t v23 = bswap32(v22);
    unint64_t v24 = (unsigned __int16 *)(v6 + v23);
    BOOL v25 = v19 > v6 + v23 || v6 + v23 + 8 > v18;
    uint64_t v26 = (uint64_t)&v24[2 * (unsigned __int16)v8 + 2];
    unint64_t v27 = v26 + 4;
    unint64_t v28 = v26 + 8;
    if (v25 || v19 > v27 || v28 > v18) {
      goto LABEL_15;
    }
    unint64_t v31 = &v24[2 * (unsigned __int16)v8];
    unsigned int v32 = *((_DWORD *)v31 + 1);
    unsigned int v33 = *((_DWORD *)v31 + 2);
    if (v33 == v32) {
      goto LABEL_15;
    }
    unsigned int v34 = bswap32(v32);
    uint64_t v14 = bswap32(v33) - v34;
    size_t v15 = (char *)v24 + v34;
    size_t v35 = (unsigned __int16 *)(v15 + 8);
    BOOL v36 = v19 > (unint64_t)(v15 + 4) || (unint64_t)(v15 + 5) > v18;
    if (v36 || (unint64_t)v35 > v18) {
      goto LABEL_15;
    }
    unsigned int v38 = bswap32(*((_DWORD *)v15 + 1));
    if (v38 != 1685418085)
    {
      if (v38 != 1718380912) {
        goto LABEL_40;
      }
      char v12 = 1;
    }
    uint64_t v8 = bswap32(*v35) >> 16;
    uint64_t v39 = (uint64_t)&v24[2 * v8 + 2];
    unint64_t v40 = v39 + 4;
    unint64_t v41 = v39 + 8;
    if (v19 > v40 || v41 > v18)
    {
      size_t v15 = 0;
    }
    else
    {
      int8x16_t v43 = &v24[2 * v8];
      unsigned int v44 = *((_DWORD *)v43 + 1);
      LODWORD(v43) = *((_DWORD *)v43 + 2);
      unsigned int v34 = bswap32(v44);
      uint64_t v45 = bswap32(v43) - v34;
      BOOL v46 = v43 == v44;
      size_t v15 = v43 == v44 ? 0 : (char *)v24 + v34;
      if (!v46) {
        uint64_t v14 = v45;
      }
    }
LABEL_40:
    uint64_t v13 = v34 + v23;
    double v21 = (double)((int)bswap32(*v24) >> 16) * (double)((int)bswap32(v24[1]) >> 16) / 72.0;
    if (v21 >= v16) {
      break;
    }
LABEL_15:
    --v17;
  }
  while (v17);
  if (!v15
    || v19 > (unint64_t)v15
    || (unint64_t)(v15 + 6) > v18
    || !v14
    || v19 > (unint64_t)&v15[v14 - 1]
    || (unint64_t)&v15[v14] > v18)
  {
LABEL_48:
    char v48 = 0;
    *(unsigned char *)a4 = 0;
    goto LABEL_49;
  }
  char v47 = *(unsigned char *)(v6 + 3);
  *(void *)a4 = v15;
  *(void *)(a4 + 8) = v14;
  *(void *)(a4 + 16) = v13;
  *(double *)(a4 + 24) = v21 / v16;
  *(double *)(a4 + 32) = v21;
  *(unsigned char *)(a4 + 40) = v47;
  *(unsigned char *)(a4 + 41) = v12;
  *(_DWORD *)(a4 + 42) = 0;
  *(_WORD *)(a4 + 46) = 0;
  char v48 = 1;
LABEL_49:
  *(unsigned char *)(a4 + 48) = v48;
}

void TDescriptor::CopyAttributeForNonNormalized(atomic_ullong *this@<X0>, const __CFString **a2@<X2>, uint64_t a3@<X1>, atomic_ullong *a4@<X8>)
{
  if (a3 == 23)
  {
    CFDictionaryRef Value = (const __CFDictionary *)(id)atomic_load_explicit(this + 1, memory_order_acquire);
    CFDictionaryRef v7 = Value;
    if (Value) {
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(Value, @"NSCTFontDesignLanguagesAttribute");
    }
    *a4 = (atomic_ullong)Value;

    return;
  }
  if (a3 == 36)
  {
    *a4 = (atomic_ullong)(id)*MEMORY[0x1E4F1CFC8];
    return;
  }
  CFDictionaryRef v9 = (const __CFDictionary *)(id)atomic_load_explicit(this + 1, memory_order_acquire);
  if (!v9)
  {

    goto LABEL_16;
  }
  CFDictionaryRef v10 = v9;
  CFDictionaryRef v11 = (const __CFDictionary *)CFDictionaryGetValue(v9, @"NSCTFontLocalizedNamesForNonNormalizedAttribute");

  if (!v11)
  {
LABEL_16:
    *a4 = 0;
    return;
  }
  *a4 = 0;
  switch(a3)
  {
    case 4:
      char v12 = (const void **)&kCTFontStyleNameAttribute;
      break;
    case 3:
      char v12 = (const void **)&kCTFontFamilyNameAttribute;
      break;
    case 2:
      char v12 = (const void **)&kCTFontDisplayNameAttribute;
      break;
    default:
      return;
  }
  CFDictionaryRef v13 = (const __CFDictionary *)CFDictionaryGetValue(v11, *v12);
  CopyValueForCurrentUser(v13, a2, (atomic_ullong *)&v14);
}

uint64_t ConvertArabicPresentationFormsToMorxInternal(const TBaseFont *a1, uint64_t a2)
{
  CFDictionaryRef v2 = (const TBaseFont *)MEMORY[0x1F4188790](a1, a2);
  v16[1] = *MEMORY[0x1E4F143B8];
  memset(v11, 170, sizeof(v11));
  (*(void (**)(id *__return_ptr))(*(void *)v2 + 480))(&__p);
  OS2::OS2((atomic_ullong *)v11, (atomic_ullong *)&__p);

  if ((uint64_t)v11[2] >= 78 && (*((unsigned char *)v11[1] + 44) & 0x20) != 0)
  {
    memset(v15, 170, sizeof(v15));
    id __p = 0;
    CFDictionaryRef v13 = 0;
    uint64_t v14 = 0;
    v16[0] = v15;
    if (v3)
    {
      id v10 = (id)0xAAAAAAAAAAAAAAAALL;
      GlyphCFIndex Count = TBaseFont::GetGlyphCount(v2);
      TBaseFont::SetConvertedTables(v2, (CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire), 0);
    }
    uint64_t v6 = (void **)__p;
    if (__p)
    {
      CFDictionaryRef v7 = v13;
      uint64_t v8 = __p;
      if (v13 != __p)
      {
        do
        {
          v7 -= 118;
        }
        while (v7 != v6);
        uint64_t v8 = __p;
      }
      CFDictionaryRef v13 = v6;
      if (v15 > v8 || v16 <= (void *)v8) {
        operator delete(v8);
      }
    }
  }
  else
  {
    uint64_t v3 = 0;
  }

  return v3;
}

BOOL CTStringIsSuitableForVerticalLayout(void *a1, uint64_t a2)
{
  BOOL v2 = 0;
  if (a1 && (a2 & 0x8000000000000000) == 0)
  {
    if (CTStringIsSuitableForVerticalLayout::once != -1) {
      dispatch_once_f(&CTStringIsSuitableForVerticalLayout::once, 0, (dispatch_function_t)CTStringIsSuitableForVerticalLayout::$_0::__invoke);
    }
    uint64_t v9 = 0;
    id v10 = &v9;
    uint64_t v11 = 0x2020000000;
    char v12 = 1;
    v8[0] = 0;
    v8[1] = v8;
    id v8[2] = 0x2020000000;
    void v8[3] = 0;
    uint64_t v5 = [a1 length];
    v7[0] = MEMORY[0x1E4F143A8];
    v7[1] = 3221225472;
    v7[2] = __CTStringIsSuitableForVerticalLayout_block_invoke;
    v7[3] = &unk_1E528FD10;
    v7[4] = a1;
    v7[5] = &v9;
    v7[6] = v8;
    v7[7] = a2;
    objc_msgSend(a1, "enumerateSubstringsInRange:options:usingBlock:", 0, v5, 2, v7);
    BOOL v2 = *((unsigned char *)v10 + 24) != 0;
    _Block_object_dispose(v8, 8);
    _Block_object_dispose(&v9, 8);
  }
  return v2;
}

void AttributedString.AdaptiveImageGlyph.init(_convertingFrom:)(void *a1@<X0>, uint64_t *a2@<X8>)
{
  id v4 = objc_msgSend(a1, sel_imageContent);
  uint64_t v5 = sub_184B7A288();
  uint64_t v7 = v6;

  id v8 = objc_msgSend(a1, sel_contentIdentifier);
  uint64_t v9 = sub_184B7A2C8();
  uint64_t v11 = v10;

  id v12 = objc_msgSend(a1, sel_contentDescription);
  uint64_t v13 = sub_184B7A2C8();
  uint64_t v15 = v14;

  *a2 = v5;
  a2[1] = v7;
  a2[2] = v9;
  a2[3] = v11;
  a2[4] = v13;
  a2[5] = v15;
}

void AttributedString.AdaptiveImageGlyph.init(imageContent:)(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  id v6 = objc_allocWithZone((Class)CTAdaptiveImageGlyph);
  uint64_t v7 = (void *)sub_184B7A278();
  id v8 = objc_msgSend(v6, sel_initWithImageContent_, v7);

  id v9 = objc_msgSend(v8, sel_imageContent);
  uint64_t v20 = sub_184B7A288();
  uint64_t v11 = v10;

  id v12 = objc_msgSend(v8, sel_contentIdentifier);
  uint64_t v13 = sub_184B7A2C8();
  uint64_t v15 = v14;

  id v16 = objc_msgSend(v8, sel_contentDescription);
  uint64_t v17 = sub_184B7A2C8();
  uint64_t v19 = v18;
  sub_184AC1B98(a1, a2);

  *a3 = v20;
  a3[1] = v11;
  a3[2] = v13;
  a3[3] = v15;
  a3[4] = v17;
  a3[5] = v19;
}

uint64_t sub_184AC1B98(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62 != 1)
  {
    if (a2 >> 62 != 2) {
      return result;
    }
    swift_release();
  }

  return swift_release();
}

uint64_t AttributedString.AdaptiveImageGlyph.imageContent.getter()
{
  uint64_t v1 = *(void *)v0;
  sub_184AC1C24(*(void *)v0, *(void *)(v0 + 8));
  return v1;
}

uint64_t sub_184AC1C24(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62 != 1)
  {
    if (a2 >> 62 != 2) {
      return result;
    }
    swift_retain();
  }

  return swift_retain();
}

uint64_t AttributedString.AdaptiveImageGlyph.contentIdentifier.getter()
{
  uint64_t v1 = *(void *)(v0 + 16);
  swift_bridgeObjectRetain();
  return v1;
}

uint64_t AttributedString.AdaptiveImageGlyph.contentDescription.getter()
{
  uint64_t v1 = *(void *)(v0 + 32);
  swift_bridgeObjectRetain();
  return v1;
}

void static AttributedString.AdaptiveImageGlyph.contentType.getter()
{
  id v0 = objc_msgSend(self, sel_contentType);
  sub_184B7A2A8();
}

uint64_t AttributedString.AdaptiveImageGlyph.hash(into:)()
{
  uint64_t v1 = *v0;
  unint64_t v2 = v0[1];
  sub_184AC1C24(*v0, v2);
  sub_184B7A298();
  sub_184AC1B98(v1, v2);
  swift_bridgeObjectRetain();
  sub_184B7A2D8();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRetain();
  sub_184B7A2D8();

  return swift_bridgeObjectRelease();
}

BOOL sub_184AC1E00(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 == *a2;
}

uint64_t sub_184AC1E14()
{
  return sub_184B7A358();
}

uint64_t sub_184AC1E5C()
{
  return sub_184B7A348();
}

uint64_t sub_184AC1E88()
{
  return sub_184B7A358();
}

uint64_t sub_184AC1ECC()
{
  int v1 = *v0;
  unint64_t v2 = 0xD000000000000011;
  if (v1 != 1) {
    unint64_t v2 = 0xD000000000000012;
  }
  if (*v0) {
    return v2;
  }
  else {
    return 0x6E6F436567616D69;
  }
}

uint64_t sub_184AC1F30@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X8>)
{
  uint64_t result = sub_184AC36B0(a1, a2);
  *a3 = result;
  return result;
}

uint64_t sub_184AC1F58()
{
  return 0;
}

void sub_184AC1F64(unsigned char *a1@<X8>)
{
  *a1 = 3;
}

uint64_t sub_184AC1F70(uint64_t a1)
{
  unint64_t v2 = sub_184AC308C();

  return MEMORY[0x1F41862A8](a1, v2);
}

uint64_t sub_184AC1FAC(uint64_t a1)
{
  unint64_t v2 = sub_184AC308C();

  return MEMORY[0x1F41862B0](a1, v2);
}

uint64_t AttributedString.AdaptiveImageGlyph.encode(to:)(void *a1)
{
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  v13[4] = v1[2];
  uint64_t v5 = v1[3];
  v13[2] = v1[4];
  CFRange v13[3] = v5;
  v13[1] = v1[5];
  uint64_t v6 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F89038);
  uint64_t v7 = *(void *)(v6 - 8);
  MEMORY[0x1F4188790](v6, v8);
  uint64_t v10 = (char *)v13 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  __swift_project_boxed_opaque_existential_1(a1, a1[3]);
  sub_184AC308C();
  sub_184B7A378();
  uint64_t v14 = v3;
  uint64_t v15 = v4;
  char v16 = 0;
  sub_184AC30E0();
  uint64_t v11 = v13[5];
  sub_184B7A318();
  if (!v11)
  {
    LOBYTE(v14) = 1;
    sub_184B7A308();
    LOBYTE(v14) = 2;
    sub_184B7A308();
  }
  return (*(uint64_t (**)(char *, uint64_t))(v7 + 8))(v10, v6);
}

uint64_t AttributedString.AdaptiveImageGlyph.hashValue.getter()
{
  uint64_t v1 = *v0;
  unint64_t v2 = v0[1];
  sub_184B7A338();
  sub_184AC1C24(v1, v2);
  sub_184B7A298();
  sub_184AC1B98(v1, v2);
  swift_bridgeObjectRetain();
  sub_184B7A2D8();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRetain();
  sub_184B7A2D8();
  swift_bridgeObjectRelease();
  return sub_184B7A358();
}

uint64_t AttributedString.AdaptiveImageGlyph.init(from:)@<X0>(void *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v5 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F89048);
  uint64_t v6 = *(void *)(v5 - 8);
  MEMORY[0x1F4188790](v5, v7);
  uint64_t v9 = (char *)&v22 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  __swift_project_boxed_opaque_existential_1(a1, a1[3]);
  sub_184AC308C();
  sub_184B7A368();
  if (v2) {
    return __swift_destroy_boxed_opaque_existential_1((uint64_t)a1);
  }
  char v28 = 0;
  sub_184AC3178();
  sub_184B7A2F8();
  uint64_t v11 = v26;
  unint64_t v10 = v27;
  LOBYTE(v26) = 1;
  sub_184AC1C24(v11, v27);
  uint64_t v12 = sub_184B7A2E8();
  uint64_t v14 = v13;
  uint64_t v23 = v12;
  unint64_t v25 = v10;
  LOBYTE(v26) = 2;
  swift_bridgeObjectRetain();
  uint64_t v15 = v14;
  uint64_t v24 = 0;
  uint64_t v16 = sub_184B7A2E8();
  uint64_t v18 = v17;
  uint64_t v19 = *(void (**)(char *, uint64_t))(v6 + 8);
  uint64_t v24 = v16;
  v19(v9, v5);
  unint64_t v20 = v25;
  sub_184AC1C24(v11, v25);
  swift_bridgeObjectRetain();
  sub_184AC1B98(v11, v20);
  *a2 = v11;
  a2[1] = v20;
  a2[2] = v23;
  a2[3] = v15;
  a2[4] = v24;
  a2[5] = v18;
  __swift_destroy_boxed_opaque_existential_1((uint64_t)a1);
  sub_184AC1B98(v11, v20);
  swift_bridgeObjectRelease();
  return swift_bridgeObjectRelease();
}

uint64_t sub_184AC254C@<X0>(void *a1@<X0>, uint64_t *a2@<X8>)
{
  return AttributedString.AdaptiveImageGlyph.init(from:)(a1, a2);
}

uint64_t sub_184AC2564(void *a1)
{
  return AttributedString.AdaptiveImageGlyph.encode(to:)(a1);
}

uint64_t sub_184AC257C()
{
  uint64_t v1 = *v0;
  unint64_t v2 = v0[1];
  sub_184B7A338();
  sub_184AC1C24(v1, v2);
  sub_184B7A298();
  sub_184AC1B98(v1, v2);
  swift_bridgeObjectRetain();
  sub_184B7A2D8();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRetain();
  sub_184B7A2D8();
  swift_bridgeObjectRelease();
  return sub_184B7A358();
}

uint64_t sub_184AC2638()
{
  uint64_t v1 = *v0;
  unint64_t v2 = v0[1];
  sub_184AC1C24(*v0, v2);
  sub_184B7A298();
  sub_184AC1B98(v1, v2);
  swift_bridgeObjectRetain();
  sub_184B7A2D8();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRetain();
  sub_184B7A2D8();

  return swift_bridgeObjectRelease();
}

uint64_t sub_184AC26F0()
{
  uint64_t v1 = *v0;
  unint64_t v2 = v0[1];
  sub_184B7A338();
  sub_184AC1C24(v1, v2);
  sub_184B7A298();
  sub_184AC1B98(v1, v2);
  swift_bridgeObjectRetain();
  sub_184B7A2D8();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRetain();
  sub_184B7A2D8();
  swift_bridgeObjectRelease();
  return sub_184B7A358();
}

id static CTAdaptiveImageGlyph._adaptiveImageGlyph(convertingFrom:)(uint64_t *a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = a1[1];
  id v3 = objc_allocWithZone((Class)CTAdaptiveImageGlyph);
  swift_bridgeObjectRetain();
  uint64_t v4 = (void *)sub_184B7A2B8();
  swift_bridgeObjectRelease();
  id v5 = objc_msgSend(v3, sel_initWithContentIdentifier_, v4);

  if (!v5)
  {
    id v6 = objc_allocWithZone((Class)CTAdaptiveImageGlyph);
    sub_184AC1C24(v1, v2);
    uint64_t v7 = (void *)sub_184B7A278();
    id v5 = objc_msgSend(v6, sel_initWithImageContent_, v7);
    sub_184AC1B98(v1, v2);
  }
  return v5;
}

uint64_t sub_184AC288C@<X0>(uint64_t __s1@<X0>, uint64_t a2@<X2>, unint64_t a3@<X3>, char *a4@<X8>)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = (const void *)__s1;
  switch(a3 >> 62)
  {
    case 1uLL:
      uint64_t v9 = (a2 >> 32) - (int)a2;
      if (a2 >> 32 < (int)a2)
      {
        __break(1u);
LABEL_31:
        __break(1u);
LABEL_32:
        __break(1u);
        goto LABEL_33;
      }
      sub_184AC1C24(a2, a3);
      unint64_t v10 = (char *)sub_184B7A248();
      if (!v10) {
        goto LABEL_8;
      }
      uint64_t v11 = sub_184B7A268();
      if (__OFSUB__((int)a2, v11)) {
LABEL_33:
      }
        __break(1u);
      v10 += (int)a2 - v11;
LABEL_8:
      uint64_t v12 = sub_184B7A258();
      if (v12 >= v9) {
        size_t v13 = (a2 >> 32) - (int)a2;
      }
      else {
        size_t v13 = v12;
      }
      if (!v7)
      {
LABEL_35:
        __break(1u);
LABEL_36:
        __break(1u);
LABEL_37:
        __break(1u);
LABEL_38:
        __break(1u);
LABEL_39:
        __break(1u);
        JUMPOUT(0x184AC2AF0);
      }
      if (!v10) {
        goto LABEL_36;
      }
      int v14 = memcmp(v7, v10, v13);
      __s1 = sub_184AC1B98(a2, a3);
      BOOL v8 = v14 == 0;
LABEL_24:
      char v24 = v8;
LABEL_29:
      *a4 = v24;
      return __s1;
    case 2uLL:
      uint64_t v15 = *(void *)(a2 + 16);
      uint64_t v16 = *(void *)(a2 + 24);
      swift_retain();
      swift_retain();
      uint64_t v17 = (char *)sub_184B7A248();
      if (!v17) {
        goto LABEL_17;
      }
      uint64_t v18 = sub_184B7A268();
      if (__OFSUB__(v15, v18)) {
        goto LABEL_32;
      }
      v17 += v15 - v18;
LABEL_17:
      BOOL v19 = __OFSUB__(v16, v15);
      int64_t v20 = v16 - v15;
      if (v19) {
        goto LABEL_31;
      }
      uint64_t v21 = sub_184B7A258();
      if (v21 >= v20) {
        size_t v22 = v20;
      }
      else {
        size_t v22 = v21;
      }
      if (!v7) {
        goto LABEL_37;
      }
      if (!v17) {
        goto LABEL_38;
      }
      int v23 = memcmp(v7, v17, v22);
      swift_release();
      __s1 = swift_release();
      BOOL v8 = v23 == 0;
      goto LABEL_24;
    case 3uLL:
      if (!__s1) {
        goto LABEL_39;
      }
      char v24 = 1;
      goto LABEL_29;
    default:
      uint64_t __s2 = a2;
      __int16 v26 = a3;
      char v27 = BYTE2(a3);
      char v28 = BYTE3(a3);
      char v29 = BYTE4(a3);
      char v30 = BYTE5(a3);
      if (__s1)
      {
        __s1 = memcmp((const void *)__s1, &__s2, BYTE6(a3));
        BOOL v8 = __s1 == 0;
        goto LABEL_24;
      }
      __break(1u);
      goto LABEL_35;
  }
}

uint64_t sub_184AC2B00(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  __s1[2] = *MEMORY[0x1E4F143B8];
  switch(a2 >> 62)
  {
    case 1uLL:
      if (a1 >> 32 < (int)a1) {
        __break(1u);
      }
      sub_184AC1C24(a1, a2);
      char v5 = sub_184AC2D30((int)a1, a1 >> 32, a2 & 0x3FFFFFFFFFFFFFFFLL, a3, a4);
      sub_184AC1B98(a1, a2);
      goto LABEL_6;
    case 2uLL:
      uint64_t v10 = a2 & 0x3FFFFFFFFFFFFFFFLL;
      uint64_t v11 = *(void *)(a1 + 16);
      uint64_t v12 = *(void *)(a1 + 24);
      swift_retain();
      swift_retain();
      char v5 = sub_184AC2D30(v11, v12, v10, a3, a4);
      swift_release();
      swift_release();
LABEL_6:
      sub_184AC1B98(a3, a4);
      return v5 & 1;
    case 3uLL:
      memset(__s1, 0, 14);
      goto LABEL_8;
    default:
      __s1[0] = a1;
      LOWORD(__s1[1]) = a2;
      BYTE2(__s1[1]) = BYTE2(a2);
      BYTE3(__s1[1]) = BYTE3(a2);
      BYTE4(__s1[1]) = BYTE4(a2);
      BYTE5(__s1[1]) = BYTE5(a2);
LABEL_8:
      sub_184AC288C((uint64_t)__s1, a3, a4, &v14);
      sub_184AC1B98(a3, a4);
      if (!v4) {
        char v5 = v14;
      }
      return v5 & 1;
  }
}

uint64_t sub_184AC2D30(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t result = sub_184B7A248();
  uint64_t v11 = result;
  if (result)
  {
    uint64_t result = sub_184B7A268();
    if (__OFSUB__(a1, result))
    {
LABEL_9:
      __break(1u);
      return result;
    }
    v11 += a1 - result;
  }
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
    goto LABEL_9;
  }
  sub_184B7A258();
  sub_184AC288C(v11, a4, a5, &v13);
  if (!v5) {
    char v12 = v13;
  }
  return v12 & 1;
}

uint64_t _s10Foundation16AttributedStringV8CoreTextE18AdaptiveImageGlyphV2eeoiySbAF_AFtFZ_0(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = *a1;
  unint64_t v3 = a1[1];
  uint64_t v5 = a1[2];
  uint64_t v4 = a1[3];
  uint64_t v6 = a1[4];
  uint64_t v7 = a1[5];
  uint64_t v9 = *a2;
  unint64_t v8 = a2[1];
  uint64_t v11 = a2[2];
  uint64_t v10 = a2[3];
  uint64_t v12 = a2[4];
  uint64_t v13 = a2[5];
  uint64_t v14 = 0;
  switch(v3 >> 62)
  {
    case 1uLL:
      LODWORD(v14) = HIDWORD(v2) - v2;
      if (__OFSUB__(HIDWORD(v2), v2))
      {
        __break(1u);
LABEL_27:
        __break(1u);
LABEL_28:
        __break(1u);
LABEL_29:
        __break(1u);
        JUMPOUT(0x184AC2FE4);
      }
      uint64_t v14 = (int)v14;
LABEL_6:
      switch(v8 >> 62)
      {
        case 1uLL:
          LODWORD(v18) = HIDWORD(v9) - v9;
          if (__OFSUB__(HIDWORD(v9), v9)) {
            goto LABEL_28;
          }
          uint64_t v18 = (int)v18;
LABEL_11:
          if (v14 != v18) {
            return 0;
          }
          if (v14 >= 1)
          {
            uint64_t v29 = a2[4];
            uint64_t v30 = a2[5];
            uint64_t v21 = a1[5];
            uint64_t v22 = a1[4];
            uint64_t v23 = a2[3];
            sub_184AC1C24(*a2, a2[1]);
            char v24 = sub_184AC2B00(v2, v3, v9, v8);
            uint64_t v10 = v23;
            uint64_t v6 = v22;
            uint64_t v7 = v21;
            uint64_t v12 = v29;
            uint64_t v13 = v30;
            if ((v24 & 1) == 0) {
              return 0;
            }
          }
LABEL_14:
          if (v5 == v11 && v4 == v10
            || (v25 = v6, v26 = sub_184B7A328(), uint64_t v6 = v25, v27 = v26, result = 0, (v27 & 1) != 0))
          {
            if (v6 == v12 && v7 == v13)
            {
              return 1;
            }
            else
            {
              return sub_184B7A328();
            }
          }
          return result;
        case 2uLL:
          uint64_t v20 = *(void *)(v9 + 16);
          uint64_t v19 = *(void *)(v9 + 24);
          BOOL v17 = __OFSUB__(v19, v20);
          uint64_t v18 = v19 - v20;
          if (!v17) {
            goto LABEL_11;
          }
          goto LABEL_29;
        case 3uLL:
          if (v14) {
            return 0;
          }
          goto LABEL_14;
        default:
          uint64_t v18 = BYTE6(v8);
          goto LABEL_11;
      }
    case 2uLL:
      uint64_t v16 = *(void *)(v2 + 16);
      uint64_t v15 = *(void *)(v2 + 24);
      BOOL v17 = __OFSUB__(v15, v16);
      uint64_t v14 = v15 - v16;
      if (!v17) {
        goto LABEL_6;
      }
      goto LABEL_27;
    case 3uLL:
      goto LABEL_6;
    default:
      uint64_t v14 = BYTE6(v3);
      goto LABEL_6;
  }
}

uint64_t __swift_instantiateConcreteTypeFromMangledName(uint64_t *a1)
{
  uint64_t result = *a1;
  if (result < 0)
  {
    uint64_t result = swift_getTypeByMangledNameInContext2();
    *a1 = result;
  }
  return result;
}

void *__swift_project_boxed_opaque_existential_1(void *result, uint64_t a2)
{
  if ((*(_DWORD *)(*(void *)(a2 - 8) + 80) & 0x20000) != 0) {
    return (void *)(*result
  }
                    + ((*(_DWORD *)(*(void *)(a2 - 8) + 80) + 16) & ~(unint64_t)*(_DWORD *)(*(void *)(a2 - 8) + 80)));
  return result;
}

unint64_t sub_184AC308C()
{
  unint64_t result = qword_1E8F8A580[0];
  if (!qword_1E8F8A580[0])
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, qword_1E8F8A580);
  }
  return result;
}

unint64_t sub_184AC30E0()
{
  unint64_t result = qword_1E8F89040;
  if (!qword_1E8F89040)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E8F89040);
  }
  return result;
}

uint64_t __swift_destroy_boxed_opaque_existential_1(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 24) - 8);
  if ((*(unsigned char *)(v1 + 82) & 2) != 0) {
    return swift_release();
  }
  else {
    return (*(uint64_t (**)(void))(v1 + 8))();
  }
}

unint64_t sub_184AC3178()
{
  unint64_t result = qword_1E8F89050;
  if (!qword_1E8F89050)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E8F89050);
  }
  return result;
}

unint64_t sub_184AC31C4()
{
  unint64_t result = qword_1E8F89058;
  if (!qword_1E8F89058)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E8F89058);
  }
  return result;
}

uint64_t _s18AdaptiveImageGlyphVwCP(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *a1 = *a2;
  uint64_t v3 = v2 + 16;
  swift_retain();
  return v3;
}

uint64_t _s18AdaptiveImageGlyphVwxx(uint64_t a1)
{
  sub_184AC1B98(*(void *)a1, *(void *)(a1 + 8));
  swift_bridgeObjectRelease();

  return swift_bridgeObjectRelease();
}

uint64_t *_s18AdaptiveImageGlyphVwcp(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  unint64_t v5 = a2[1];
  sub_184AC1C24(*a2, v5);
  *a1 = v4;
  a1[1] = v5;
  uint64_t v6 = a2[3];
  a1[2] = a2[2];
  a1[3] = v6;
  uint64_t v7 = a2[4];
  uint64_t v8 = a2[5];
  a1[4] = v7;
  a1[5] = v8;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  return a1;
}

uint64_t *_s18AdaptiveImageGlyphVwca(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  unint64_t v5 = a2[1];
  sub_184AC1C24(*a2, v5);
  uint64_t v6 = *a1;
  unint64_t v7 = a1[1];
  *a1 = v4;
  a1[1] = v5;
  sub_184AC1B98(v6, v7);
  a1[2] = a2[2];
  a1[3] = a2[3];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  a1[4] = a2[4];
  a1[5] = a2[5];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

__n128 __swift_memcpy48_8(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 32) = v3;
  *(__n128 *)a1 = result;
  return result;
}

uint64_t *_s18AdaptiveImageGlyphVwta(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  unint64_t v5 = a1[1];
  *(_OWORD *)a1 = *(_OWORD *)a2;
  sub_184AC1B98(v4, v5);
  uint64_t v6 = *(void *)(a2 + 24);
  a1[2] = *(void *)(a2 + 16);
  a1[3] = v6;
  swift_bridgeObjectRelease();
  uint64_t v7 = *(void *)(a2 + 40);
  a1[4] = *(void *)(a2 + 32);
  a1[5] = v7;
  swift_bridgeObjectRelease();
  return a1;
}

unsigned char *__swift_memcpy1_1(unsigned char *result, unsigned char *a2)
{
  *__n128 result = *a2;
  return result;
}

uint64_t _s18AdaptiveImageGlyphV10CodingKeysOwet(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0xFE) {
    goto LABEL_17;
  }
  if (a2 + 2 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 2) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 2;
    }
  }
  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 2;
    }
    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 2;
    }
  }
LABEL_17:
  unsigned int v6 = *a1;
  BOOL v7 = v6 >= 3;
  int v8 = v6 - 3;
  if (!v7) {
    int v8 = -1;
  }
  return (v8 + 1);
}

unsigned char *_s18AdaptiveImageGlyphV10CodingKeysOwst(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 2 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 2) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xFE) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xFD)
  {
    unsigned int v6 = ((a2 - 254) >> 8) + 1;
    *__n128 result = a2 + 2;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x184AC355CLL);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *__n128 result = a2 + 2;
        break;
    }
  }
  return result;
}

uint64_t sub_184AC3584(unsigned __int8 *a1)
{
  return *a1;
}

unsigned char *sub_184AC3590(unsigned char *result, char a2)
{
  *__n128 result = a2;
  return result;
}

ValueMetadata *_s18AdaptiveImageGlyphV10CodingKeysOMa()
{
  return &_s18AdaptiveImageGlyphV10CodingKeysON;
}

unint64_t sub_184AC35AC()
{
  unint64_t result = qword_1E8F8A890[0];
  if (!qword_1E8F8A890[0])
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, qword_1E8F8A890);
  }
  return result;
}

unint64_t sub_184AC3604()
{
  unint64_t result = qword_1E8F8A9A0;
  if (!qword_1E8F8A9A0)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1E8F8A9A0);
  }
  return result;
}

unint64_t sub_184AC365C()
{
  unint64_t result = qword_1E8F8A9A8[0];
  if (!qword_1E8F8A9A8[0])
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, qword_1E8F8A9A8);
  }
  return result;
}

uint64_t sub_184AC36B0(uint64_t a1, uint64_t a2)
{
  BOOL v2 = a1 == 0x6E6F436567616D69 && a2 == 0xEC000000746E6574;
  if (v2 || (sub_184B7A328() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 0;
  }
  else if (a1 == 0xD000000000000011 && a2 == 0x8000000184BABBE0 || (sub_184B7A328() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    return 1;
  }
  else if (a1 == 0xD000000000000012 && a2 == 0x8000000184BABC00)
  {
    swift_bridgeObjectRelease();
    return 2;
  }
  else
  {
    char v6 = sub_184B7A328();
    swift_bridgeObjectRelease();
    if (v6) {
      return 2;
    }
    else {
      return 3;
    }
  }
}

double GetLanguageAwareAdjustRatio(void)
{
  if (qword_1EB2CDE88 != -1) {
    dispatch_once_f(&qword_1EB2CDE88, 0, (dispatch_function_t)GetLanguageAwareAdjustRatio(void)::$_0::__invoke);
  }
  return *(double *)&qword_1EB2CDE80;
}

void *GetLanguageAwareAdjustRatio(void)::$_0::__invoke()
{
  qword_1EB2CDE80 = 0x3FD51EB851EB851FLL;
  unint64_t result = objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F1CB18], "standardUserDefaults"), "valueForKey:", @"NSLanguageAwareAdjustmentRatio");
  if (result)
  {
    unint64_t result = (void *)[result doubleValue];
    double v2 = 1.0;
    if (v1 <= 1.0) {
      double v2 = v1;
    }
    BOOL v3 = v1 < 0.0;
    double v4 = 0.0;
    if (!v3) {
      double v4 = v2;
    }
    qword_1EB2CDE80 = *(void *)&v4;
  }
  return result;
}

__CFString *TCharStream::DebugDescription(TCharStream *this)
{
  v2.CFIndex length = *((void *)this + 2);
  v2.locatiouint64_t n = 0;
  return TCharStream::DebugDescriptionForRange(this, v2);
}

__CFString *TStorageRange::DebugDescription(TStorageRange *this)
{
  return TStorageRange::DebugDescriptionWithInfoFromRun(this, 0, *MEMORY[0x1E4F1DB30], -1);
}

uint64_t ChineseCompositionRules::GetCharacterClass(UChar32 c, int a2, int a3)
{
  uint64_t result = 8;
  if (c > 12288)
  {
    if ((c - 12289) <= 0x1E)
    {
      int v5 = 1 << (c - 1);
      if ((v5 & 0x77F9FF80) != 0) {
        return result;
      }
      if ((v5 & 3) != 0) {
        goto LABEL_14;
      }
    }
    char v6 = c - 1;
    if ((c - 65281) <= 0x3C)
    {
      if (((1 << v6) & 0x46000001) != 0)
      {
        BOOL v7 = a3 == 2 || a3 == 4;
        goto LABEL_31;
      }
      if (((1 << v6) & 0x1400000000000180) != 0) {
        return result;
      }
      if (((1 << v6) & 0x2800) != 0)
      {
LABEL_14:
        BOOL v7 = a3 == 4;
LABEL_31:
        if (v7) {
          return 7;
        }
        else {
          return 1;
        }
      }
    }
    if ((c - 65371) <= 5 && c != 65372) {
      return result;
    }
    goto LABEL_16;
  }
  if (c > 10628)
  {
    if ((c - 10629) < 2) {
      return result;
    }
  }
  else
  {
    switch(c)
    {
      case 40:
        return 5;
      case 41:
        return 6;
      case 8943:
        return result;
    }
  }
LABEL_16:
  if ((c - 33) > 0xD)
  {
    if ((c - 8208) < 0x18
      || (c - 58) <= 0x26 && ((1 << (c - 58)) & 0x7E0000003FLL) != 0)
    {
      return result;
    }
  }
  else if (c != 37 && c != 43)
  {
    return result;
  }
  if (!a2) {
    a2 = 1 << u_charType(c);
  }
  if ((a2 & 0xC0180D0) != 0) {
    return 8;
  }
  if ((a2 & 0x1000) != 0) {
    return 2;
  }
  if (uscript_getScript() == 18) {
    return 8;
  }
  uint64_t result = 8;
  if (c && c != 8203)
  {
    if (((u_getIntPropertyValue(c, UCHAR_EAST_ASIAN_WIDTH) - 3) & 0xFFFFFFFD) != 0) {
      return 4;
    }
    else {
      return 3;
    }
  }
  return result;
}

uint64_t ChineseCompositionRules::GetCharacterSpacing(int a1, int a2, UChar32 c, int a4, UChar32 a5, int a6, unsigned int *a7)
{
  CharacterClass Class = a4;
  if (a4 == 9) {
    CharacterClass Class = ChineseCompositionRules::GetCharacterClass(c, 0, a1);
  }
  unsigned int v14 = ChineseCompositionRules::GetCharacterClass(a5, a6, a1);
  *a7 = v14;
  if ((a6 & 0x6000) != 0 || a5 == 10) {
    int v16 = 1;
  }
  else {
    int v16 = 8;
  }
  if (CharacterClass != 1) {
    int v16 = CharacterClass;
  }
  if (a5) {
    int v17 = v16;
  }
  else {
    int v17 = CharacterClass;
  }
  if ((c - 48) > 9 || (uint64_t v18 = 5, a5 != 26085) && a5 != 26376)
  {
    if ((a5 - 48) > 9 || (uint64_t v18 = 5, c != 26085) && c != 26376)
    {
      if (a1 == 4 && v17 == 1)
      {
        uint64_t v18 = 0;
        if (v14 == 4) {
          char v19 = a2;
        }
        else {
          char v19 = 0;
        }
        if (v14 == 1 || (v19 & 1) != 0) {
          return v18;
        }
      }
      else if (a2)
      {
        uint64_t v18 = 0;
        if (v17 == 4 || v14 == 4) {
          return v18;
        }
      }
      return ChineseCompositionRules::GetCharacterSpacing(CTCompositionLanguage,BOOL,unsigned int,ChineseCompositionRules::CharacterClass,unsigned int,unsigned int,ChineseCompositionRules::CharacterClass*)::kTable[9 * v17 + v14];
    }
  }
  return v18;
}

uint64_t CJKCompositionEngine::IsEnabled(CJKCompositionEngine *this)
{
  if (CJKCompositionEngine::IsEnabled(void)::once != -1) {
    dispatch_once_f(&CJKCompositionEngine::IsEnabled(void)::once, 0, (dispatch_function_t)CJKCompositionEngine::IsEnabled(void)::$_0::__invoke);
  }
  return gCJKCompositionRulesEnabled;
}

uint64_t AddSpace(uint64_t result, const TCharStream *a2, uint64_t a3, double a4, uint64_t a5, double a6)
{
  uint64_t v10 = (TLine *)result;
  if (*(_WORD *)(result + 152))
  {
    uint64_t result = TLine::FindRunWithCharIndex((TLine *)result, a3, 1);
    uint64_t v20 = *(void *)(*(void *)(*((void *)v10 + 2) + 8 * result) + 48);
    if (a5 < 0)
    {
      BOOL v22 = 0;
      uint64_t v21 = 0;
    }
    else
    {
      uint64_t result = TLine::FindRunWithCharIndex(v10, a5, 1);
      uint64_t v21 = *(void *)(*(void *)(*((void *)v10 + 2) + 8 * result) + 48);
      BOOL v22 = v21 != 0;
      if (v21) {
        BOOL v23 = v20 == v21;
      }
      else {
        BOOL v23 = 1;
      }
      if (!v23)
      {
        if (*(unsigned __int8 *)(v20 + 224) != *(unsigned __int8 *)(v21 + 224)) {
          return result;
        }
        BOOL v22 = 1;
      }
    }
    if (a4 != 0.0)
    {
      uint64_t GlyphIndexForChar = TRun::GetGlyphIndexForCharIndex<false>(v20, a3);
      uint64_t result = AddSpace(v20, GlyphIndexForChar, a4, 0);
    }
    char v25 = !v22;
    if (a6 == 0.0) {
      char v25 = 1;
    }
    if ((v25 & 1) == 0)
    {
      uint64_t v26 = TRun::GetGlyphIndexForCharIndex<false>(v21, a5);
      return AddSpace(v21, v26, a6, 1);
    }
  }
  else
  {
    if (a4 != 0.0)
    {
      uint64_t v12 = 0xAAAAAAAAAAAAAAAALL;
      int64_t v43 = 0xAAAAAAAAAAAAAAAALL;
      unint64_t v44 = 0xAAAAAAAAAAAAAAAALL;
      TLine::GetClusterRange((TLine *)result, a2, a3, 2, &v43, 0, 0);
      int64_t v13 = v44 + v43;
      uint64_t v14 = v44 + v43 - 1;
      uint64_t v15 = *((void *)v10 + 2);
      uint64_t v16 = *((void *)v10 + 3);
      if (v15 == v16)
      {
        uint64_t v18 = *((void *)v10 + 2);
      }
      else
      {
        int64_t v17 = 0;
        uint64_t v18 = *((void *)v10 + 2);
        do
        {
          int64_t v19 = *(void *)(*(void *)(*(void *)v18 + 40) + 208) + v17;
          if (v19 >= v13)
          {
            uint64_t v12 = v14 - v17;
            goto LABEL_26;
          }
          v18 += 8;
          int64_t v17 = v19;
        }
        while (v18 != v16);
        uint64_t v12 = 0xAAAAAAAAAAAAAAAALL;
        uint64_t v18 = *((void *)v10 + 3);
      }
LABEL_26:
      while (1)
      {
        int64_t v27 = v14;
        uint64_t result = *(void *)(*(void *)v18 + 48);
        uint64_t v28 = *(void *)(result + 216);
        uint64_t v29 = *(void *)(result + 200);
        if (*(__int16 *)(*(void *)(v28 + 16) + 2 * v29 + 2 * v12) != -1
          && (*(_DWORD *)(*(void *)(v28 + 40) + 4 * v29 + 4 * v12) & 0x20) == 0)
        {
          break;
        }
        if (v43 >= v27 || v13 == 0x8000000000000000) {
          goto LABEL_37;
        }
        uint64_t v14 = v27 - 1;
        uint64_t v18 = *((void *)v10 + 2);
        if (v15 != v16)
        {
          int64_t v30 = 0;
          uint64_t v18 = *((void *)v10 + 2);
          while (1)
          {
            int64_t v31 = *(void *)(*(void *)(*(void *)v18 + 40) + 208) + v30;
            if (v31 >= v27) {
              break;
            }
            v18 += 8;
            int64_t v30 = v31;
            if (v18 == v16)
            {
              uint64_t v18 = *((void *)v10 + 3);
              goto LABEL_26;
            }
          }
          uint64_t v12 = v14 - v30;
        }
      }
      uint64_t result = AddSpace(result, v12, a4, 0);
    }
LABEL_37:
    if (a6 != 0.0)
    {
      uint64_t v32 = 0xAAAAAAAAAAAAAAAALL;
      int64_t v43 = 0xAAAAAAAAAAAAAAAALL;
      unint64_t v44 = 0xAAAAAAAAAAAAAAAALL;
      TLine::GetClusterRange(v10, a2, a5, 2, &v43, 0, 0);
      uint64_t v33 = *((void *)v10 + 2);
      uint64_t v34 = *((void *)v10 + 3);
      if (v33 == v34)
      {
        uint64_t v36 = *((void *)v10 + 2);
      }
      else
      {
        int64_t v35 = 0;
        uint64_t v36 = *((void *)v10 + 2);
        while (1)
        {
          int64_t v37 = *(void *)(*(void *)(*(void *)v36 + 40) + 208) + v35;
          if (v37 > v43) {
            break;
          }
          v36 += 8;
          int64_t v35 = v37;
          if (v36 == v34)
          {
            uint64_t v32 = 0xAAAAAAAAAAAAAAAALL;
            uint64_t v36 = *((void *)v10 + 3);
            goto LABEL_45;
          }
        }
        uint64_t v32 = v43 - v35;
      }
LABEL_45:
      int64_t v38 = v43;
LABEL_46:
      while (1)
      {
        uint64_t result = *(void *)(*(void *)v36 + 48);
        uint64_t v39 = *(void *)(result + 216);
        uint64_t v40 = *(void *)(result + 200);
        if (*(__int16 *)(*(void *)(v39 + 16) + 2 * v40 + 2 * v32) != -1
          && (*(_DWORD *)(*(void *)(v39 + 40) + 4 * v40 + 4 * v32) & 0x20) == 0)
        {
          return AddSpace(result, v32, a6, 1);
        }
        if (v43 > ++v38 || (uint64_t)(v44 + v43) <= v38) {
          return result;
        }
        uint64_t v36 = *((void *)v10 + 2);
        if (v33 != v34)
        {
          int64_t v41 = 0;
          uint64_t v36 = *((void *)v10 + 2);
          while (1)
          {
            int64_t v42 = *(void *)(*(void *)(*(void *)v36 + 40) + 208) + v41;
            if (v42 > v38) {
              break;
            }
            v36 += 8;
            int64_t v41 = v42;
            if (v36 == v34)
            {
              uint64_t v36 = *((void *)v10 + 3);
              goto LABEL_46;
            }
          }
          uint64_t v32 = v38 - v41;
        }
      }
    }
  }
  return result;
}

BOOL CJKCompositionEngine::IsEnabled(unsigned int a1, uint64_t a2)
{
  if (a1 < 2) {
    return 0;
  }
  if ((*(_WORD *)(a2 + 138) & 0x1000) != 0) {
    return 0;
  }
  uint64_t v3 = *(void *)(a2 + 120);
  if (v3)
  {
    if (*(unsigned char *)(v3 + 8)) {
      return 0;
    }
  }
  if (CJKCompositionEngine::IsEnabled(void)::once != -1) {
    dispatch_once_f(&CJKCompositionEngine::IsEnabled(void)::once, 0, (dispatch_function_t)CJKCompositionEngine::IsEnabled(void)::$_0::__invoke);
  }
  return gCJKCompositionRulesEnabled != 0;
}

void GetOpticalBoundsAdjustment(int a1, atomic_ullong *this, CFRange a3)
{
  atomic_load_explicit(this + 7, memory_order_acquire);
  uint64_t v8 = 0;
  double v9 = 0.0;
  a3.CFIndex length = 1;
  Imagedouble Bounds = TRun::GetImageBounds((TRun *)this, 0, a3, &v9, (double *)&v8);
  if (a1) {
    CGRectGetMaxX(*(CGRect *)&ImageBounds);
  }
  else {
    CGRectGetMinX(*(CGRect *)&ImageBounds);
  }
}

uint64_t CJKCompositionEngine::ShouldIgnoreCurlyQuotes(CJKCompositionEngine *this)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  os_unfair_lock_lock_with_options();
  if (dword_1EB2CDE94 != TGenerationSeed::sGeneration)
  {
    dword_1EB2CDE94 = TGenerationSeed::sGeneration;
    id v16 = (id)0xAAAAAAAAAAAAAAAALL;
    CopyPreferredLanguage((atomic_ullong *)&v16);
    unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&v16, memory_order_acquire);
    if (explicit)
    {
      *(void *)&long long v2 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v20[0] = v2;
      v20[1] = v2;
      uint64_t v19 = 0;
      int64x2_t v18 = 0uLL;
      uint64_t v21 = v20;
      CFStringRef v3 = (const __CFString *)atomic_load_explicit((atomic_ullong *volatile)&v16, memory_order_acquire);
      if (CFStringGetCStringPtr(v3, 0x600u)) {
        goto LABEL_10;
      }
      CFIndex Length = CFStringGetLength(v3);
      CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x600u);
      CFIndex v6 = MaximumSizeForEncoding + 1;
      BOOL v7 = (char *)v18.i64[0];
      if ((unint64_t)(MaximumSizeForEncoding + 1) <= v18.i64[1] - v18.i64[0])
      {
        if ((unint64_t)(MaximumSizeForEncoding + 1) < v18.i64[1] - v18.i64[0]) {
          v18.i64[1] = v18.i64[0] + v6;
        }
      }
      else
      {
        std::vector<char,TInlineBufferAllocator<char,30ul>>::__append(&v18, MaximumSizeForEncoding + 1 - (v18.i64[1] - v18.i64[0]));
        BOOL v7 = (char *)v18.i64[0];
      }
      int CString = CFStringGetCString(v3, v7, v6, 0x600u);
      int v9 = 0;
      if (CString)
      {
        if (v18.i64[0])
        {
LABEL_10:
          ulocdata_open();
          char v10 = 0;
          v17[3] = (void **)0x200000000;
          while (1)
          {
            char v11 = v10;
            memset(v17, 170, 20);
            int Delimiter = ulocdata_getDelimiter();
            if (Delimiter >= 1) {
              break;
            }
LABEL_15:
            char v10 = 1;
            if (v11)
            {
              int v9 = 0;
              goto LABEL_18;
            }
          }
          uint64_t v13 = 0;
          while ((*(unsigned __int16 *)((char *)v17 + v13) | 4) != 0x201D)
          {
            v13 += 2;
            if (2 * Delimiter == v13) {
              goto LABEL_15;
            }
          }
          int v9 = 1;
LABEL_18:
          ulocdata_close();
        }
      }
      v17[0] = (void **)&v18;
      std::vector<char,TInlineBufferAllocator<char,30ul>>::__destroy_vector::operator()[abi:nn180100](v17);
      LOBYTE(explicit) = v9 != 0;
    }
    _MergedGlobals_4 = explicit;
  }
  uint64_t v14 = _MergedGlobals_4;
  os_unfair_lock_unlock((os_unfair_lock_t)algn_1EB2CDE98);
  return v14;
}

uint64_t CJKCompositionEngine::GetCharacterClass(UChar32 c, int a2)
{
  uint64_t result = 0;
  if (c <= 65287)
  {
    switch(c)
    {
      case 12289:
        goto LABEL_14;
      case 12290:
        return 6;
      case 12291:
      case 12292:
      case 12293:
      case 12294:
      case 12295:
      case 12306:
      case 12307:
        goto LABEL_27;
      case 12296:
      case 12298:
        return 1;
      case 12297:
      case 12299:
        return 4;
      case 12300:
      case 12302:
      case 12304:
      case 12308:
      case 12310:
        return result;
      case 12301:
      case 12303:
      case 12305:
      case 12309:
      case 12311:
        goto LABEL_3;
      default:
        char v5 = c - 20;
        if ((c - 8212) > 0x12) {
          goto LABEL_23;
        }
        if (((1 << v5) & 0x60001) != 0) {
          return 13;
        }
        if (((1 << v5) & 0x110) != 0)
        {
          BOOL v6 = CJKCompositionEngine::ShouldIgnoreCurlyQuotes(0) == 0;
          unsigned int v7 = 2;
        }
        else
        {
          if (((1 << v5) & 0x220) == 0)
          {
LABEL_23:
            int v4 = 65281;
            goto LABEL_24;
          }
          BOOL v6 = CJKCompositionEngine::ShouldIgnoreCurlyQuotes(0) == 0;
          unsigned int v7 = 5;
        }
        if (v6) {
          uint64_t result = v7;
        }
        else {
          uint64_t result = 13;
        }
        break;
    }
    return result;
  }
  if (c > 65305)
  {
    if (c > 65370)
    {
      if (c == 65373) {
        return 4;
      }
      if (c == 65371) {
        return 1;
      }
    }
    else
    {
      if ((c - 65306) < 2) {
        return 9;
      }
      int v4 = 65311;
LABEL_24:
      if (c == v4) {
        return 9;
      }
    }
LABEL_27:
    if ((c - 33) > 0xD)
    {
      if ((c - 8208) < 0x18
        || (c - 58) <= 0x26 && ((1 << (c - 58)) & 0x7E0000003FLL) != 0)
      {
        return 13;
      }
    }
    else if (c != 37 && c != 43)
    {
      return 13;
    }
    if (!a2) {
      a2 = 1 << u_charType(c);
    }
    if ((a2 & 0xC0180D0) == 0)
    {
      if ((a2 & 0x1000) != 0) {
        return 12;
      }
      if (uscript_getScript() != 18)
      {
        if (((u_getIntPropertyValue(c, UCHAR_EAST_ASIAN_WIDTH) - 3) & 0xFFFFFFFD) != 0) {
          return 11;
        }
        else {
          return 14;
        }
      }
    }
    return 13;
  }
  switch(c)
  {
    case 65288:
      return result;
    case 65289:
LABEL_3:
      uint64_t result = 3;
      break;
    case 65292:
LABEL_14:
      uint64_t result = 7;
      break;
    case 65294:
      uint64_t result = 8;
      break;
    default:
      goto LABEL_27;
  }
  return result;
}

uint64_t CJKCompositionRules::GetCharacterClass(UChar32 a1, int a2)
{
  if ((a2 & 0xC0180D0) != 0) {
    return 7;
  }
  CJKCompositionEngine::GetCharacterClass(a1, a2);
  return 0;
}

uint64_t CJKAddSpace(uint64_t result, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, char a7)
{
  char v10 = (TLine *)result;
  if (*(_WORD *)(result + 152))
  {
    uint64_t result = TLine::FindRunWithCharIndex((TLine *)result, a3, 1);
    uint64_t v24 = *(void *)(*(void *)(*((void *)v10 + 2) + 8 * result) + 48);
    if (a4 < 0)
    {
      BOOL v26 = 0;
      uint64_t v25 = 0;
    }
    else
    {
      uint64_t result = TLine::FindRunWithCharIndex(v10, a4, 1);
      uint64_t v25 = *(void *)(*(void *)(*((void *)v10 + 2) + 8 * result) + 48);
      BOOL v26 = v25 != 0;
      if (v25) {
        BOOL v27 = v24 == v25;
      }
      else {
        BOOL v27 = 1;
      }
      if (!v27)
      {
        if (*(unsigned __int8 *)(v24 + 224) != *(unsigned __int8 *)(v25 + 224)) {
          return result;
        }
        BOOL v26 = 1;
      }
    }
    if (*(double *)a5 != 0.0)
    {
      CFIndex GlyphIndexForChar = TRun::GetGlyphIndexForCharIndex<false>(v24, a3);
      v56.locatiouint64_t n = 0;
      v56.CFIndex length = 0;
      uint64_t result = CJKAddSpace(v24, GlyphIndexForChar, *(double *)a5, v56, 0.0, 0, 0);
    }
    char v29 = !v26;
    if (*(double *)(a5 + 8) == 0.0) {
      char v29 = 1;
    }
    if ((v29 & 1) == 0)
    {
      CFIndex v30 = TRun::GetGlyphIndexForCharIndex<false>(v25, a4);
      double v31 = *(double *)(a5 + 8);
      v32.locatiouint64_t n = 1;
      v32.CFIndex length = 0;
      return CJKAddSpace(v25, v30, v31, v32, 0.0, 0, 0);
    }
  }
  else
  {
    if (*(double *)a5 != 0.0 || *(unsigned char *)(a5 + 16) != 0 || *(unsigned char *)(a5 + 18) != 0)
    {
      CFIndex v16 = 0xAAAAAAAAAAAAAAAALL;
      int64_t v53 = 0xAAAAAAAAAAAAAAAALL;
      unint64_t v54 = 0xAAAAAAAAAAAAAAAALL;
      TLine::GetClusterRange((TLine *)result, a2, a3, 2, &v53, 0, 0);
      int64_t v17 = v54 + v53;
      uint64_t v18 = v54 + v53 - 1;
      uint64_t v19 = *((void *)v10 + 2);
      uint64_t v20 = *((void *)v10 + 3);
      if (v19 == v20)
      {
        uint64_t v22 = *((void *)v10 + 2);
      }
      else
      {
        int64_t v21 = 0;
        uint64_t v22 = *((void *)v10 + 2);
        do
        {
          int64_t v23 = *(void *)(*(void *)(*(void *)v22 + 40) + 208) + v21;
          if (v23 >= v17)
          {
            CFIndex v16 = v18 - v21;
            goto LABEL_32;
          }
          v22 += 8;
          int64_t v21 = v23;
        }
        while (v22 != v20);
        CFIndex v16 = 0xAAAAAAAAAAAAAAAALL;
        uint64_t v22 = *((void *)v10 + 3);
      }
LABEL_32:
      while (1)
      {
        int64_t v33 = v18;
        uint64_t result = *(void *)(*(void *)v22 + 48);
        uint64_t v34 = *(void *)(result + 216);
        uint64_t v35 = *(void *)(result + 200);
        if (*(__int16 *)(*(void *)(v34 + 16) + 2 * v35 + 2 * v16) != -1
          && (*(_DWORD *)(*(void *)(v34 + 40) + 4 * v35 + 4 * v16) & 0x20) == 0)
        {
          break;
        }
        if (v53 >= v33 || v17 == 0x8000000000000000) {
          goto LABEL_45;
        }
        uint64_t v18 = v33 - 1;
        uint64_t v22 = *((void *)v10 + 2);
        if (v19 != v20)
        {
          int64_t v36 = 0;
          uint64_t v22 = *((void *)v10 + 2);
          while (1)
          {
            int64_t v37 = *(void *)(*(void *)(*(void *)v22 + 40) + 208) + v36;
            if (v37 >= v33) {
              break;
            }
            v22 += 8;
            int64_t v36 = v37;
            if (v22 == v20)
            {
              uint64_t v22 = *((void *)v10 + 3);
              goto LABEL_32;
            }
          }
          CFIndex v16 = v18 - v36;
        }
      }
      double v38 = -0.0416666667;
      if (!*(unsigned char *)(a5 + 18)) {
        double v38 = 0.0;
      }
      v57.locatiouint64_t n = 0;
      v57.CFIndex length = *(unsigned __int8 *)(a5 + 16);
      uint64_t result = CJKAddSpace(result, v16, *(double *)a5, v57, v38, a6, a7);
    }
LABEL_45:
    if (*(double *)(a5 + 8) != 0.0 || *(unsigned char *)(a5 + 17) != 0 || *(unsigned char *)(a5 + 19) != 0)
    {
      CFIndex v41 = 0xAAAAAAAAAAAAAAAALL;
      int64_t v53 = 0xAAAAAAAAAAAAAAAALL;
      unint64_t v54 = 0xAAAAAAAAAAAAAAAALL;
      TLine::GetClusterRange(v10, a2, a4, 2, &v53, 0, 0);
      uint64_t v42 = *((void *)v10 + 2);
      uint64_t v43 = *((void *)v10 + 3);
      if (v42 == v43)
      {
        uint64_t v45 = *((void *)v10 + 2);
      }
      else
      {
        int64_t v44 = 0;
        uint64_t v45 = *((void *)v10 + 2);
        while (1)
        {
          int64_t v46 = *(void *)(*(void *)(*(void *)v45 + 40) + 208) + v44;
          if (v46 > v53) {
            break;
          }
          v45 += 8;
          int64_t v44 = v46;
          if (v45 == v43)
          {
            CFIndex v41 = 0xAAAAAAAAAAAAAAAALL;
            uint64_t v45 = *((void *)v10 + 3);
            goto LABEL_59;
          }
        }
        CFIndex v41 = v53 - v44;
      }
LABEL_59:
      int64_t v47 = v53;
LABEL_60:
      while (1)
      {
        uint64_t result = *(void *)(*(void *)v45 + 48);
        uint64_t v48 = *(void *)(result + 216);
        uint64_t v49 = *(void *)(result + 200);
        if (*(__int16 *)(*(void *)(v48 + 16) + 2 * v49 + 2 * v41) != -1
          && (*(_DWORD *)(*(void *)(v48 + 40) + 4 * v49 + 4 * v41) & 0x20) == 0)
        {
          break;
        }
        if (v53 > ++v47 || (uint64_t)(v54 + v53) <= v47) {
          return result;
        }
        uint64_t v45 = *((void *)v10 + 2);
        if (v42 != v43)
        {
          int64_t v50 = 0;
          uint64_t v45 = *((void *)v10 + 2);
          while (1)
          {
            int64_t v51 = *(void *)(*(void *)(*(void *)v45 + 40) + 208) + v50;
            if (v51 > v47) {
              break;
            }
            v45 += 8;
            int64_t v50 = v51;
            if (v45 == v43)
            {
              uint64_t v45 = *((void *)v10 + 3);
              goto LABEL_60;
            }
          }
          CFIndex v41 = v47 - v50;
        }
      }
      double v52 = -0.0416666667;
      if (!*(unsigned char *)(a5 + 19)) {
        double v52 = 0.0;
      }
      v58.locatiouint64_t n = 1;
      v58.CFIndex length = *(unsigned __int8 *)(a5 + 17);
      return CJKAddSpace(result, v41, *(double *)(a5 + 8), v58, v52, 0, 0);
    }
  }
  return result;
}

BOOL CJKCompositionRules::ShouldGlyphImageRightFlush(uint64_t a1, uint64_t a2, UChar32 a3, BOOL *a4)
{
  CharacterClass Class = CJKCompositionRules::GetCharacterClass(a3, 0);
  int v7 = CharacterClass;
  if (a4)
  {
    BOOL v8 = CharacterClass == 2 && CJKCompositionEngine::GetCharacterClass(a3, 0) == 4;
    *a4 = v8;
  }
  return v7 == 2 || v7 == 4;
}

uint64_t TRunGlue::GetStringIndex(TRunGlue *this, uint64_t a2)
{
  if (*((void *)this + 19))
  {
    TRunGlue::FocusOnIndex(this, a2);
    uint64_t v4 = *((void *)this + 66);
    uint64_t v5 = a2 - *((void *)this + 20);
    return *(void *)(v4 + 8 * v5);
  }
  uint64_t v4 = *((void *)this + 66);
  if (v4)
  {
    uint64_t v5 = *((void *)this + 20) + a2;
    return *(void *)(v4 + 8 * v5);
  }
  return -1;
}

BOOL CJKCompositionRules::ShouldGlyphImageLeftFlush(uint64_t a1, uint64_t a2, UChar32 a3, BOOL *a4)
{
  CharacterClass Class = CJKCompositionRules::GetCharacterClass(a3, 0);
  unsigned int v7 = CharacterClass;
  if (a4)
  {
    if (CharacterClass) {
      BOOL v8 = 0;
    }
    else {
      BOOL v8 = CJKCompositionEngine::GetCharacterClass(a3, 0) == 1;
    }
    *a4 = v8;
  }
  return v7 < 2;
}

uint64_t AddSpace(uint64_t result, uint64_t a2, double a3, int a4)
{
  if ((*(_WORD *)(result + 178) & 0x1000) == 0)
  {
    uint64_t v7 = result;
    BOOL v8 = (TStorageRange *)(result + 192);
    unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(v7 + 56), memory_order_acquire);
    if (explicit) {
      double v10 = *(double *)(*(void *)(explicit + 40) + 16);
    }
    else {
      double v10 = 0.0;
    }
    uint64_t v11 = *(void *)(v7 + 216);
    uint64_t v12 = *(void *)(v11 + 32);
    if (v12 || (uint64_t v15 = *(void *)(v11 + 24)) == 0)
    {
      uint64_t v13 = v12 + 16 * *(void *)(v7 + 200) + 16 * a2;
      uint64_t v14 = *(void *)(v13 + 8);
    }
    else
    {
      uint64_t v13 = v15 + 8 * *(void *)(v7 + 200) + 8 * a2;
      uint64_t v14 = 0;
    }
    double v16 = *(double *)v13 + v10 * a3;
    TStorageRange::SetAdvance(v8, a2, *(CGSize *)(&v14 - 1));
    if (a4)
    {
      int64_t v17 = (double *)MEMORY[0x1E4F1DAD8];
      if ((*(unsigned char *)(v7 + 225) & 0x10) != 0)
      {
        [*(id *)(v7 + 216) originAtIndex:*(void *)(v7 + 200) + a2];
        double v19 = v20;
      }
      else
      {
        double v18 = *MEMORY[0x1E4F1DAD8];
        double v19 = *(double *)(MEMORY[0x1E4F1DAD8] + 8);
      }
      double v21 = v18 + v10 * a3;
      objc_msgSend(*(id *)(v7 + 216), "setOrigin:atIndex:", *(void *)(v7 + 200) + a2, v21, v19);
      if (v21 != *v17 || v19 != v17[1]) {
        *(unsigned char *)(v7 + 225) |= 0x10u;
      }
    }
    int64_t v23 = *(void **)(v7 + 216);
    uint64_t v24 = *(void *)(v7 + 200);
    uint64_t v25 = *(_DWORD *)(v23[5] + 4 * v24 + 4 * a2) | 0x400u;
    return [v23 setProps:v25 atIndex:v24 + a2];
  }
  return result;
}

void CJKCompositionEngine::IsEnabled(void)::$_0::__invoke()
{
  if (gCJKCompositionRulesEnabled) {
    gCJKCompositionRulesEnableCGFloat d = CFPreferencesGetAppBooleanValue(@"CTDisableNewCJKComposition", (CFStringRef)*MEMORY[0x1E4F1D3D8], 0) == 0;
  }
}

void std::__throw_bad_array_new_length[abi:nn180100]()
{
}

void std::__function::__func<OTL::Lookup::InitCoverageUnion(void)::{lambda(unsigned short,unsigned short,unsigned short)#1},std::allocator<OTL::Lookup::InitCoverageUnion(void)::{lambda(unsigned short,unsigned short,unsigned short)#1}>,BOOL ()(unsigned short,unsigned short,unsigned short)>::~__func()
{
}

void *std::__function::__func<OTL::Lookup::InitCoverageUnion(void)::{lambda(unsigned short,unsigned short,unsigned short)#1},std::allocator<OTL::Lookup::InitCoverageUnion(void)::{lambda(unsigned short,unsigned short,unsigned short)#1}>,BOOL ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1ED061AA8;
  result[1] = v3;
  return result;
}

uint64_t CJKAddSpace(uint64_t this, CFIndex a2, double a3, CFRange a4, double a5, int a6, char a7)
{
  if ((*(_WORD *)(this + 178) & 0x1000) != 0) {
    return this;
  }
  locatiouint64_t n = a4.location;
  uint64_t v12 = this;
  double v13 = *(double *)(*(void *)(atomic_load_explicit((atomic_ullong *volatile)(this + 56), memory_order_acquire) + 40)
                  + 16);
  double v14 = 0.0;
  if (LODWORD(a4.length))
  {
    if (a4.location)
    {
      a4.locatiouint64_t n = a2;
      GetOpticalBoundsAdjustment(0, (atomic_ullong *)this, a4);
      double v16 = v15;
      goto LABEL_10;
    }
    a4.locatiouint64_t n = a2;
    GetOpticalBoundsAdjustment(1, (atomic_ullong *)this, a4);
    double v14 = v18;
    if (a6 && (a7 & 1) == 0) {
      double v14 = v18 + v13 * -0.0416666667;
    }
  }
  double v16 = 0.0;
LABEL_10:
  uint64_t v19 = *(void *)(v12 + 216);
  uint64_t v20 = *(void *)(v19 + 32);
  if (v20 || (uint64_t v23 = *(void *)(v19 + 24)) == 0)
  {
    uint64_t v21 = v20 + 16 * *(void *)(v12 + 200) + 16 * a2;
    uint64_t v22 = *(void *)(v21 + 8);
  }
  else
  {
    uint64_t v21 = v23 + 8 * *(void *)(v12 + 200) + 8 * a2;
    uint64_t v22 = 0;
  }
  double v24 = (a3 + a5) * v13;
  double v25 = -0.0;
  if (a6) {
    double v25 = v14;
  }
  double v26 = v24 + v25;
  if (!a6) {
    double v24 = v24 - v14 - v16;
  }
  double v27 = v24 + *(double *)v21;
  TStorageRange::SetAdvance((TStorageRange *)(v12 + 192), a2, *(CGSize *)(&v22 - 1));
  if (location)
  {
    uint64_t v28 = (double *)MEMORY[0x1E4F1DAD8];
    if ((*(unsigned char *)(v12 + 225) & 0x10) != 0)
    {
      [*(id *)(v12 + 216) originAtIndex:*(void *)(v12 + 200) + a2];
      double v30 = v31;
    }
    else
    {
      double v29 = *MEMORY[0x1E4F1DAD8];
      double v30 = *(double *)(MEMORY[0x1E4F1DAD8] + 8);
    }
    double v32 = v26 - v16 + v29;
    objc_msgSend(*(id *)(v12 + 216), "setOrigin:atIndex:", *(void *)(v12 + 200) + a2, v32, v30);
    if (v32 != *v28 || v30 != v28[1]) {
      *(unsigned char *)(v12 + 225) |= 0x10u;
    }
  }
  else
  {
    TStorageRange::SetInterGlyphsExtraSpace((TStorageRange *)(v12 + 192), a2, v26);
  }
  uint64_t v34 = *(void **)(v12 + 216);
  uint64_t v35 = *(void *)(v12 + 200);
  uint64_t v36 = *(_DWORD *)(v34[5] + 4 * v35 + 4 * a2) | 0x400u;

  return [v34 setProps:v36 atIndex:v35 + a2];
}

unsigned __int16 *std::remove_if[abi:nn180100]<std::__wrap_iter<std::pair<unsigned short,unsigned short> *>,std::__not_fn_t<OTL::GSUB::GetSingleSubstLookups(OTL::FeatureBuffer const&,TInlineVector<std::pair<unsigned short,unsigned short>,30ul> *)::IsSingleSubst>>(unsigned __int16 *a1, unsigned __int16 *a2, void *a3, uint64_t a4)
{
  uint64_t v7 = a1;
  if (a1 != a2)
  {
    while (1)
    {
      BOOL v8 = TBaseFont::NthLookup<OTL::GSUB>(a4, a3, *v7);
      if (!v8 || *((_WORD *)v8 + 8) != 1) {
        break;
      }
      v7 += 2;
      if (v7 == a2) {
        return a2;
      }
    }
  }
  if (v7 != a2)
  {
    for (uint64_t i = v7 + 2; i != a2; i += 2)
    {
      double v10 = TBaseFont::NthLookup<OTL::GSUB>(a4, a3, *i);
      if (v10 && *((_WORD *)v10 + 8) == 1)
      {
        *uint64_t v7 = *i;
        v7[1] = i[1];
        v7 += 2;
      }
    }
  }
  return v7;
}

void std::__function::__func<OTL::GSUB::ApplyLookups(TRunGlue &,int,OTL::GlyphLookups &,SyncState &,void (*)(void *,CFRange,long),void *)::{lambda(CFRange,long)#1},std::allocator<OTL::GSUB::ApplyLookups(TRunGlue &,int,OTL::GlyphLookups &,SyncState &,void (*)(void *,CFRange,long),void *)::{lambda(CFRange,long)#1}>,void ()(CFRange,long)>::~__func()
{
}

void *std::__function::__func<OTL::GSUB::ApplyLookups(TRunGlue &,int,OTL::GlyphLookups &,SyncState &,void (*)(void *,CFRange,long),void *)::{lambda(CFRange,long)#1},std::allocator<OTL::GSUB::ApplyLookups(TRunGlue &,int,OTL::GlyphLookups &,SyncState &,void (*)(void *,CFRange,long),void *)::{lambda(CFRange,long)#1}>,void ()(CFRange,long)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1ED0619D0;
  result[1] = v3;
  return result;
}

uint64_t CJKCompositionEngine::SubstituteGlyphsForCJKComposition(TRunGlue &,TCharStream const&)::$_0::__invoke(uint64_t result, uint64_t a2)
{
  if (a2 == *(void *)result) {
    *(unsigned char *)(result + 8) = 1;
  }
  return result;
}

uint64_t TAATLookupTable::LookupSimpleArray(TAATLookupTable *this, unsigned int a2, unint64_t *a3)
{
  if (*((void *)this + 3) <= (unint64_t)a2) {
    return 0;
  }
  *a3 = 2;
  return *((void *)this + 2) + 2 * a2;
}

uint64_t TAATLookupTable::LookupTrimmedArray(TAATLookupTable *this, unsigned int a2, unint64_t *a3)
{
  if (*((unsigned __int16 *)this + 12) > a2 || *((unsigned __int16 *)this + 13) < a2) {
    return 0;
  }
  *a3 = 2;
  return *((void *)this + 2) + 2 * a2 - 2 * *((unsigned __int16 *)this + 12) + 4;
}

unint64_t TAATLookupTable::LookupVector(TAATLookupTable *this, unsigned int a2, unint64_t *a3)
{
  if (*((unsigned __int16 *)this + 16) > a2 || *((unsigned __int16 *)this + 17) < a2) {
    return 0;
  }
  *a3 = *((void *)this + 3);
  return *((void *)this + 2) + (a2 - (unint64_t)*((unsigned __int16 *)this + 16)) * *((void *)this + 3) + 6;
}

UInt16 *TAATLookupTable::LookupSegmentSingle(TAATLookupTable *this, unsigned int a2, unint64_t *a3)
{
  if (a2 == 0xFFFF) {
    return 0;
  }
  Segment = FindSegment((const SFNTLookupSegmentHeader *)(*((void *)this + 2) + 2), *((void *)this + 5), a2, a3);
  if (!Segment) {
    return 0;
  }
  else {
    return Segment->value;
  }
}

SFNTLookupSegment *TAATLookupTable::LookupSegmentArray(TAATLookupTable *this, unsigned int a2, unint64_t *a3)
{
  if (a2 == 0xFFFF) {
    return 0;
  }
  uint64_t result = FindSegment((const SFNTLookupSegmentHeader *)(*((void *)this + 2) + 2), *((void *)this + 5), a2, a3);
  if (result)
  {
    unint64_t v6 = *((void *)this + 2);
    unint64_t v7 = v6 + (bswap32(result->value[0]) >> 16) + 2 * a2 - 2 * (bswap32(result->firstGlyph) >> 16);
    if (v7 + 2 > *((void *)this + 5) || v6 > v7) {
      return 0;
    }
    else {
      return (SFNTLookupSegment *)v7;
    }
  }
  return result;
}

uint64_t TAATLookupTable::BadTable(TAATLookupTable *this, unsigned __int16 a2, unint64_t *a3)
{
  return 0;
}

uint64_t TAATLookupTable::IterateSegmentSingle(uint64_t result, uint64_t a2)
{
  long long v2 = *(unsigned __int16 **)(result + 16);
  if (v2[2])
  {
    uint64_t v4 = result;
    int v5 = 0;
    unint64_t v6 = (unint64_t)(v2 + 1);
    unsigned int v7 = __rev16(v2[2]);
    uint64_t v8 = bswap32(v2[1]) >> 16;
    int v9 = v2 + 6;
    do
    {
      if (v6 > (unint64_t)v9) {
        break;
      }
      if ((unint64_t)(v9 + 3) > *(void *)(v4 + 40)) {
        break;
      }
      uint64_t result = std::function<void ()(unsigned short,unsigned short,unsigned short const*)>::operator()(a2, bswap32(v9[1]) >> 16, bswap32(*v9) >> 16, (uint64_t)(v9 + 2));
      int v9 = (unsigned __int16 *)((char *)v9 + v8);
      ++v5;
    }
    while (v7 > (unsigned __int16)v5);
  }
  return result;
}

uint64_t std::function<void ()(unsigned short,unsigned short,unsigned short const*)>::operator()(uint64_t a1, __int16 a2, __int16 a3, uint64_t a4)
{
  __int16 v9 = a2;
  __int16 v8 = a3;
  uint64_t v7 = a4;
  uint64_t v4 = *(void *)(a1 + 24);
  if (v4) {
    return (*(uint64_t (**)(uint64_t, __int16 *, __int16 *, uint64_t *))(*(void *)v4 + 48))(v4, &v9, &v8, &v7);
  }
  uint64_t v6 = std::__throw_bad_function_call[abi:nn180100]();
  return TAATLookupTable::IterateSegmentArray(v6);
}

uint64_t TAATLookupTable::IterateSegmentArray(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = result;
  uint64_t v5 = *(void *)(result + 16);
  unsigned int v7 = *(unsigned __int16 *)(v5 + 2);
  unint64_t v6 = v5 + 2;
  unsigned int v8 = *(unsigned __int16 *)(v6 + 2);
  unsigned int v9 = __rev16(v8);
  double v10 = (unsigned __int16 *)(v6 + 10);
  uint64_t v11 = bswap32(v7) >> 16;
  if (*(void *)(a2 + 24)) {
    BOOL v12 = v9 >= 2;
  }
  else {
    BOOL v12 = 0;
  }
  if (v12)
  {
    double v13 = (unsigned __int16 *)((char *)v10 + (int)(v11 * (v9 - 2)));
    if (v6 > (unint64_t)v13 || (unint64_t)(v13 + 3) > *(void *)(result + 40)) {
      return result;
    }
    uint64_t result = std::function<void ()>::operator()(a2, (bswap32(*v13) >> 16) + 1);
  }
  if (v8)
  {
    int v15 = 0;
    do
    {
      if (v6 > (unint64_t)v10) {
        break;
      }
      if ((unint64_t)(v10 + 3) > *(void *)(v4 + 40)) {
        break;
      }
      unsigned int v16 = v10[1];
      if (v16 == 0xFFFF) {
        break;
      }
      uint64_t result = std::function<void ()(unsigned short,unsigned short,unsigned short const*)>::operator()(a3, __rev16(v16), bswap32(*v10) >> 16, (uint64_t)(v10 + 2));
      double v10 = (unsigned __int16 *)((char *)v10 + v11);
      ++v15;
    }
    while (v9 > (unsigned __int16)v15);
  }
  return result;
}

uint64_t TAATLookupTable::IterateTrimmedArray(uint64_t result, uint64_t a2)
{
  unsigned int v2 = *(unsigned __int16 *)(result + 24);
  unsigned int v3 = *(unsigned __int16 *)(result + 26);
  if (v2 <= v3 && v2 != (unsigned __int16)(v3 + 1))
  {
    uint64_t v5 = result;
    do
    {
      int v6 = (unsigned __int16)v2;
      uint64_t result = std::function<void ()(unsigned short,unsigned short const*)>::operator()(a2, v2, *(void *)(v5 + 16) + 2 * (unsigned __int16)v2 - 2 * *(unsigned __int16 *)(v5 + 24) + 4);
      ++v2;
    }
    while (v6 != v3);
  }
  return result;
}

SFNTLookupSegment *FindSegment(const SFNTLookupSegmentHeader *a1, unint64_t a2, unsigned int a3, unint64_t *a4)
{
  uint64_t v4 = bswap32(a1->binSearch.unitSize) >> 16;
  if (v4 < 6) {
    return 0;
  }
  unsigned int nUnits = a1->binSearch.nUnits;
  if (!a1->binSearch.nUnits) {
    return 0;
  }
  uint64_t result = a1->segments;
  unsigned int v8 = (char *)a1->segments + __rev16(nUnits) * v4;
  unint64_t v9 = (unint64_t)&v8[-v4];
  BOOL v10 = (unint64_t)v8 <= a2 && v9 >= (unint64_t)a1;
  if (!v10 || (unint64_t)v8 < v9) {
    return 0;
  }
  while (a3 > bswap32(result->lastGlyph) >> 16)
  {
    uint64_t result = (SFNTLookupSegment *)((char *)result + v4);
    if (v8 <= (char *)result) {
      return 0;
    }
  }
  if (a3 < bswap32(result->firstGlyph) >> 16) {
    return 0;
  }
  *a4 = v4 - 4;
  return result;
}

BOOL TAATMorphSubtableMorx::MorxContextualStateNeedsAction(TAATMorphSubtableMorx *this, unint64_t a2, int a3, int a4, const unsigned __int16 *a5, const STXEntryTwo *a6, uint64_t a7)
{
  unsigned int v7 = (unsigned __int16 *)a6 + (a4 + a3 * a5);
  BOOL v8 = v7 < (unsigned __int16 *)this || (unint64_t)(v7 + 1) > a2;
  BOOL result = 0;
  if (!v8)
  {
    uint64_t v9 = bswap32(*v7) >> 16;
    BOOL v10 = (unsigned __int16 *)(a7 + 8 * v9);
    if (v10 >= (unsigned __int16 *)this && (unint64_t)(v10 + 4) <= a2)
    {
      uint64_t v12 = a7 + 8 * v9;
      int v13 = *v10;
      BOOL v14 = (*(_WORD *)(v12 + 2) & 0xE0) == 0 && v13 == 0;
      if (!v14 || *(__int16 *)(v12 + 4) != -1 || *(__int16 *)(a7 + 8 * v9 + 6) != -1) {
        return 1;
      }
    }
  }
  return result;
}

BOOL TAATMorphSubtableMorx::MorxInsertionStateNeedsAction(TAATMorphSubtableMorx *this, unint64_t a2, int a3, int a4, const unsigned __int16 *a5, const STXEntryTwo *a6, uint64_t a7)
{
  unsigned int v7 = (unsigned __int16 *)a6 + (a4 + a3 * a5);
  if (v7 < (unsigned __int16 *)this || (unint64_t)(v7 + 1) > a2) {
    return 0;
  }
  uint64_t v9 = bswap32(*v7) >> 16;
  BOOL v10 = (unsigned __int16 *)(a7 + 8 * v9);
  if (v10 < (unsigned __int16 *)this || (unint64_t)(v10 + 4) > a2) {
    return 0;
  }
  uint64_t v12 = a7 + 8 * v9;
  __int16 v13 = *(_WORD *)(v12 + 2);
  int v14 = *v10;
  if ((v13 & 0xE0) != 0 || v14 != 0) {
    return 1;
  }
  return (*(__int16 *)(v12 + 4) != -1 || *(__int16 *)(a7 + 8 * v9 + 6) != -1) && (v13 & 0xFF03) != 0;
}

uint64_t TAATMorphSubtableMorx::InitRearrangementState(uint64_t a1, TRunGlue *a2, void *a3)
{
  int v6 = *(unsigned int **)(a1 + 104);
  uint64_t v5 = *(SFNTLookupTable **)(a1 + 112);
  unsigned int v7 = v6 + 3;
  a3[2] = bswap32(v6[3]);
  BOOL v8 = (const SFNTLookupTable *)((char *)v6 + bswap32(v6[4]) + 12);
  if (&v8->fsHeader > (SFNTLookupFormatSpecificHeader *)v5) {
    return 0;
  }
  uint64_t result = 0;
  switch(bswap32(v8->format) >> 16)
  {
    case 0u:
      goto LABEL_23;
    case 2u:
    case 4u:
    case 6u:
      if (v8->fsHeader.trimmedArray.valueArray > (SFNTLookupValue *)v5) {
        return 0;
      }
      id values = (UInt8 *)&v8->fsHeader.vector + 10;
      unsigned int v12 = bswap32(v8->fsHeader.theArray.lookupValues[0]) >> 16;
      unsigned int nUnits = v8->fsHeader.segment.binSearch.nUnits;
      goto LABEL_19;
    case 8u:
      p_searchRange = &v8->fsHeader.segment.binSearch.searchRange;
      if (v8->fsHeader.trimmedArray.valueArray > (SFNTLookupValue *)v5) {
        return 0;
      }
      uint64_t v15 = bswap32(v8->fsHeader.segment.binSearch.nUnits) >> 16;
      unint64_t v16 = (unint64_t)&p_searchRange[v15];
      unint64_t v17 = v8->fsHeader.vector.values <= (UInt8 *)v5
          ? (unint64_t)((char *)v5 - (char *)p_searchRange) >> 1
          : 0;
      BOOL v18 = v16 <= (unint64_t)v5 && v16 >= (unint64_t)p_searchRange;
      if (!v18 && v17 != v15) {
        return 0;
      }
      goto LABEL_23;
    case 0xAu:
      id values = v8->fsHeader.vector.values;
      if (v8->fsHeader.vector.values > (UInt8 *)v5) {
        return 0;
      }
      unsigned int v12 = bswap32(v8->fsHeader.theArray.lookupValues[0]) >> 16;
      unsigned int nUnits = v8->fsHeader.segment.binSearch.searchRange;
LABEL_19:
      unint64_t v20 = (unint64_t)&values[(bswap32(nUnits) >> 16) * (unint64_t)v12];
      if (v20 < (unint64_t)values || v20 > (unint64_t)v5) {
        return 0;
      }
LABEL_23:
      TAATLookupTable::SetTable(a1 + 24, v8, v5);
      if (*(int *)(a1 + 12) < 1)
      {
        *a3 = TRunGlue::length(a2) - 1;
        uint64_t v22 = TRunGlue::length(a2) - 1;
      }
      else
      {
        uint64_t v22 = 0;
        *a3 = 0;
      }
      a3[1] = v22;
      a3[3] = (char *)v7 + bswap32(v6[5]);
      a3[4] = (char *)v7 + bswap32(v6[6]);
      uint64_t result = 1;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t TAATMorphSubtableMorx::InitContextualState(uint64_t a1, TRunGlue *a2, uint64_t *a3)
{
  int v6 = *(unsigned int **)(a1 + 104);
  uint64_t v5 = *(SFNTLookupTable **)(a1 + 112);
  unsigned int v7 = v6 + 3;
  a3[1] = bswap32(v6[3]);
  BOOL v8 = (const SFNTLookupTable *)((char *)v6 + bswap32(v6[4]) + 12);
  if (&v8->fsHeader > (SFNTLookupFormatSpecificHeader *)v5) {
    return 0;
  }
  uint64_t result = 0;
  switch(bswap32(v8->format) >> 16)
  {
    case 0u:
      goto LABEL_23;
    case 2u:
    case 4u:
    case 6u:
      if (v8->fsHeader.trimmedArray.valueArray > (SFNTLookupValue *)v5) {
        return 0;
      }
      id values = (UInt8 *)&v8->fsHeader.vector + 10;
      unsigned int v12 = bswap32(v8->fsHeader.theArray.lookupValues[0]) >> 16;
      unsigned int nUnits = v8->fsHeader.segment.binSearch.nUnits;
      goto LABEL_19;
    case 8u:
      p_searchRange = &v8->fsHeader.segment.binSearch.searchRange;
      if (v8->fsHeader.trimmedArray.valueArray > (SFNTLookupValue *)v5) {
        return 0;
      }
      uint64_t v15 = bswap32(v8->fsHeader.segment.binSearch.nUnits) >> 16;
      unint64_t v16 = (unint64_t)&p_searchRange[v15];
      unint64_t v17 = v8->fsHeader.vector.values <= (UInt8 *)v5
          ? (unint64_t)((char *)v5 - (char *)p_searchRange) >> 1
          : 0;
      BOOL v18 = v16 <= (unint64_t)v5 && v16 >= (unint64_t)p_searchRange;
      if (!v18 && v17 != v15) {
        return 0;
      }
      goto LABEL_23;
    case 0xAu:
      id values = v8->fsHeader.vector.values;
      if (v8->fsHeader.vector.values > (UInt8 *)v5) {
        return 0;
      }
      unsigned int v12 = bswap32(v8->fsHeader.theArray.lookupValues[0]) >> 16;
      unsigned int nUnits = v8->fsHeader.segment.binSearch.searchRange;
LABEL_19:
      unint64_t v20 = (unint64_t)&values[(bswap32(nUnits) >> 16) * (unint64_t)v12];
      if (v20 < (unint64_t)values || v20 > (unint64_t)v5) {
        return 0;
      }
LABEL_23:
      TAATLookupTable::SetTable(a1 + 24, v8, v5);
      if (*(int *)(a1 + 12) <= 0) {
        uint64_t v22 = TRunGlue::length(a2) - 1;
      }
      else {
        uint64_t v22 = 0;
      }
      *a3 = v22;
      a3[2] = (uint64_t)v7 + bswap32(v6[5]);
      a3[3] = (uint64_t)v7 + bswap32(v6[6]);
      uint64_t result = 1;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t TAATMorphSubtableMorx::InitInsertionState(uint64_t a1, TRunGlue *a2, uint64_t *a3)
{
  int v6 = *(unsigned int **)(a1 + 104);
  uint64_t v5 = *(SFNTLookupTable **)(a1 + 112);
  unsigned int v7 = v6 + 3;
  a3[1] = bswap32(v6[3]);
  BOOL v8 = (const SFNTLookupTable *)((char *)v6 + bswap32(v6[4]) + 12);
  if (&v8->fsHeader > (SFNTLookupFormatSpecificHeader *)v5) {
    return 0;
  }
  uint64_t result = 0;
  switch(bswap32(v8->format) >> 16)
  {
    case 0u:
      goto LABEL_23;
    case 2u:
    case 4u:
    case 6u:
      if (v8->fsHeader.trimmedArray.valueArray > (SFNTLookupValue *)v5) {
        return 0;
      }
      id values = (UInt8 *)&v8->fsHeader.vector + 10;
      unsigned int v12 = bswap32(v8->fsHeader.theArray.lookupValues[0]) >> 16;
      unsigned int nUnits = v8->fsHeader.segment.binSearch.nUnits;
      goto LABEL_19;
    case 8u:
      p_searchRange = &v8->fsHeader.segment.binSearch.searchRange;
      if (v8->fsHeader.trimmedArray.valueArray > (SFNTLookupValue *)v5) {
        return 0;
      }
      uint64_t v15 = bswap32(v8->fsHeader.segment.binSearch.nUnits) >> 16;
      unint64_t v16 = (unint64_t)&p_searchRange[v15];
      unint64_t v17 = v8->fsHeader.vector.values <= (UInt8 *)v5
          ? (unint64_t)((char *)v5 - (char *)p_searchRange) >> 1
          : 0;
      BOOL v18 = v16 <= (unint64_t)v5 && v16 >= (unint64_t)p_searchRange;
      if (!v18 && v17 != v15) {
        return 0;
      }
      goto LABEL_23;
    case 0xAu:
      id values = v8->fsHeader.vector.values;
      if (v8->fsHeader.vector.values > (UInt8 *)v5) {
        return 0;
      }
      unsigned int v12 = bswap32(v8->fsHeader.theArray.lookupValues[0]) >> 16;
      unsigned int nUnits = v8->fsHeader.segment.binSearch.searchRange;
LABEL_19:
      unint64_t v20 = (unint64_t)&values[(bswap32(nUnits) >> 16) * (unint64_t)v12];
      if (v20 < (unint64_t)values || v20 > (unint64_t)v5) {
        return 0;
      }
LABEL_23:
      TAATLookupTable::SetTable(a1 + 24, v8, v5);
      if (*(int *)(a1 + 12) <= 0) {
        uint64_t v22 = TRunGlue::length(a2) - 1;
      }
      else {
        uint64_t v22 = 0;
      }
      *a3 = v22;
      a3[2] = (uint64_t)v7 + bswap32(v6[5]);
      a3[3] = (uint64_t)v7 + bswap32(v6[6]);
      uint64_t result = 1;
      break;
    default:
      return result;
  }
  return result;
}

void TAATMorphSubtableMorx::DoRearrangementSubtable(uint64_t a1, TRunGlue *a2, uint64_t *a3, TRunGlue *this, uint64_t a5, uint64_t a6, unint64_t a7, int *a8)
{
  uint64_t v10 = a5;
  uint64_t v11 = this;
  v53[4] = *MEMORY[0x1E4F143B8];
  unsigned int Class = (unsigned __int16)a7;
  unint64_t v15 = a7 >> 16;
  int GlyphID = TRunGlue::GetGlyphID(this, a5);
  double v52 = 0;
  memset(v53, 170, 24);
  int64x2_t v51 = 0uLL;
  double v53[3] = v53;
  while (1)
  {
    while (a6 && (GlyphID == 0xFFFF || TRunGlue::IsDeleted(v11, v10)))
    {
LABEL_21:
      v51.i64[1] = v51.i64[0];
      uint64_t v27 = a6 - 1;
      if (a6 > 1)
      {
        v10 += *(int *)(a1 + 12);
        unint64_t v25 = v15;
        --a6;
        goto LABEL_51;
      }
      unsigned int Class = 0;
      a6 = 0;
      if (v27) {
        goto LABEL_53;
      }
    }
    unint64_t v17 = (unsigned __int16 *)(a3[3] + 2 * (a3[2] * (unsigned __int16)v15 + Class));
    unint64_t v18 = *(void *)(a1 + 104);
    unint64_t v19 = *(void *)(a1 + 112);
    if (v18 > (unint64_t)v17 || (unint64_t)(v17 + 1) > v19) {
      break;
    }
    uint64_t v21 = bswap32(*v17) >> 16;
    uint64_t v22 = a3[4];
    uint64_t v23 = (unsigned __int16 *)(v22 + 4 * v21);
    if (v18 > (unint64_t)v23 || (unint64_t)(v23 + 2) > v19) {
      break;
    }
    unint64_t v25 = bswap32(*v23) >> 16;
    unsigned int v26 = bswap32(*(unsigned __int16 *)(v22 + 4 * v21 + 2)) >> 16;
    if ((v26 & 0xFFFFE00F) == 0) {
      goto LABEL_20;
    }
    if ((v26 & 0x8000) != 0)
    {
      a3[1] = v10;
      if ((v26 & 0x2000) == 0) {
        goto LABEL_17;
      }
LABEL_16:
      *a3 = v10;
      goto LABEL_17;
    }
    if ((v26 & 0x2000) != 0) {
      goto LABEL_16;
    }
LABEL_17:
    if ((v26 & 0xF) != 0 && !TAATMorphSubtable::DoRearrangement(a1, a2, v26 & 0xF, a3[1], *a3, a8)) {
      break;
    }
    if ((v26 & 0x4000) == 0) {
      goto LABEL_20;
    }
    uint64_t v28 = (_WORD *)v51.i64[1];
    double v29 = (unsigned __int16 *)v51.i64[0];
    if (v51.i64[0] != v51.i64[1])
    {
      while (*v29 != GlyphID || v29[1] != (unsigned __int16)v15 || v29[2] != v25)
      {
        v29 += 3;
        if (v29 == (unsigned __int16 *)v51.i64[1])
        {
          double v29 = (unsigned __int16 *)v51.i64[1];
          break;
        }
      }
    }
    if (v29 != (unsigned __int16 *)v51.i64[1])
    {
LABEL_20:
      unint64_t v15 = v25;
      goto LABEL_21;
    }
    if (v51.i64[1] >= (unint64_t)v52)
    {
      uint64_t v45 = v10;
      double v31 = v11;
      double v32 = a8;
      unint64_t v33 = 0xAAAAAAAAAAAAAAABLL * ((v51.i64[1] - v51.i64[0]) >> 1);
      unint64_t v34 = v33 + 1;
      if (v33 + 1 > 0x2AAAAAAAAAAAAAAALL) {
        abort();
      }
      if (0x5555555555555556 * ((uint64_t)&v52[-v51.i64[0]] >> 1) > v34) {
        unint64_t v34 = 0x5555555555555556 * ((uint64_t)&v52[-v51.i64[0]] >> 1);
      }
      if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v52[-v51.i64[0]] >> 1) >= 0x1555555555555555) {
        unint64_t v35 = 0x2AAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v35 = v34;
      }
      int64_t v50 = v53;
      if (v35) {
        uint64_t v36 = (char *)TInlineBufferAllocator<std::tuple<unsigned short,unsigned short,unsigned short>,4ul>::allocate((uint64_t)v53, v35);
      }
      else {
        uint64_t v36 = 0;
      }
      int64_t v37 = &v36[6 * v33];
      *(_WORD *)int64_t v37 = GlyphID;
      *((_WORD *)v37 + 1) = v15;
      *((_WORD *)v37 + 2) = v25;
      uint64_t v38 = v51.i64[1];
      uint64_t v39 = v51.i64[0];
      if (v51.i64[1] == v51.i64[0])
      {
        int64x2_t v43 = vdupq_n_s64(v51.u64[1]);
        uint64_t v40 = &v36[6 * v33];
        a8 = v32;
      }
      else
      {
        uint64_t v40 = &v36[6 * v33];
        a8 = v32;
        do
        {
          int v41 = *(_DWORD *)(v38 - 6);
          v38 -= 6;
          __int16 v42 = *(_WORD *)(v38 + 4);
          *(_DWORD *)(v40 - 6) = v41;
          v40 -= 6;
          *((_WORD *)v40 + 2) = v42;
        }
        while (v38 != v39);
        int64x2_t v43 = v51;
      }
      uint64_t v11 = v31;
      double v30 = v37 + 6;
      v51.i64[0] = (uint64_t)v40;
      v51.i64[1] = (uint64_t)(v37 + 6);
      int64x2_t v48 = v43;
      int64_t v44 = v52;
      double v52 = &v36[6 * v35];
      uint64_t v49 = v44;
      uint64_t v47 = v43.i64[0];
      std::__split_buffer<std::tuple<unsigned short,unsigned short,unsigned short>,TInlineBufferAllocator<std::tuple<unsigned short,unsigned short,unsigned short>,4ul> &>::~__split_buffer((uint64_t)&v47);
      uint64_t v10 = v45;
    }
    else
    {
      *(_WORD *)v51.i64[1] = GlyphID;
      v28[1] = v15;
      double v30 = v28 + 3;
      v28[2] = v25;
    }
    v51.i64[1] = (uint64_t)v30;
LABEL_51:
    int GlyphID = TRunGlue::GetGlyphID(v11, v10);
    unsigned int Class = TAATMorphSubtableMorx::FetchClass((TAATMorphSubtableMorx *)a1, GlyphID);
    unint64_t v15 = v25;
  }
LABEL_53:
  std::vector<std::tuple<unsigned short,unsigned short,unsigned short>,TInlineBufferAllocator<std::tuple<unsigned short,unsigned short,unsigned short>,4ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v51);
}

void TAATMorphSubtableMorx::DoInsertionSubtable(uint64_t a1, TRunGlue *a2, uint64_t *a3, TRunGlue *this, uint64_t a5, uint64_t a6, unint64_t a7, int *a8)
{
  uint64_t v8 = a6;
  uint64_t v9 = this;
  v80[5] = *MEMORY[0x1E4F143B8];
  unsigned int Class = (unsigned __int16)a7;
  unint64_t v11 = a7 >> 16;
  uint64_t v66 = a6 << 7;
  uint64_t v73 = a5;
  int GlyphID = TRunGlue::GetGlyphID(this, a5);
  unint64_t v79 = 0;
  memset(v80, 170, 24);
  int64x2_t v78 = 0uLL;
  v80[3] = v80;
  while (1)
  {
    if (v8 && (GlyphID == 0xFFFF || TRunGlue::IsDeleted(v9, v73)))
    {
      int v13 = 1;
      goto LABEL_58;
    }
    int v14 = (unsigned __int16 *)(a3[2] + 2 * (a3[1] * (unsigned __int16)v11 + Class));
    unint64_t v15 = *(void *)(a1 + 104);
    unint64_t v16 = *(void *)(a1 + 112);
    BOOL v17 = v15 > (unint64_t)v14 || (unint64_t)(v14 + 1) > v16;
    if (v17) {
      goto LABEL_89;
    }
    uint64_t v18 = bswap32(*v14) >> 16;
    uint64_t v19 = a3[3];
    unint64_t v20 = (unsigned __int16 *)(v19 + 8 * v18);
    if (v15 > (unint64_t)v20 || (unint64_t)(v20 + 4) > v16) {
      goto LABEL_89;
    }
    unsigned int v22 = *v20;
    uint64_t v23 = (unsigned __int16 *)(v19 + 8 * v18);
    unsigned int v24 = bswap32(v23[1]);
    unsigned int v25 = HIWORD(v24);
    unsigned int v26 = v23[2];
    unsigned int v27 = v23[3];
    int v28 = (v24 >> 21) & 0x1F;
    if (v26 != 0xFFFF && v28 != 0) {
      int v29 = (v24 >> 21) & 0x1F;
    }
    else {
      LOWORD(v29) = 0;
    }
    int v30 = HIWORD(v24) & 0x1F;
    BOOL v31 = v30 != 0;
    BOOL v32 = v27 != 0xFFFF;
    BOOL v33 = v31 && v32;
    __int16 v34 = v31 && v32 ? v30 : 0;
    if (v26 != 0xFFFF && v28 != 0 || v33) {
      break;
    }
    int v13 = 1;
LABEL_51:
    if ((v25 & 0x8000) != 0) {
      *a3 = v73;
    }
    unint64_t v46 = bswap32(v22) >> 16;
    if ((v25 & 0x4000) != 0) {
      uint64_t v47 = (unsigned __int16)(v29 + v34);
    }
    else {
      uint64_t v47 = 0;
    }
    if ((v25 & 0x4000) == 0) {
      goto LABEL_57;
    }
    int64x2_t v48 = (_WORD *)v78.i64[1];
    uint64_t v49 = (unsigned __int16 *)v78.i64[0];
    if (v78.i64[0] != v78.i64[1])
    {
      while (*v49 != GlyphID || v49[1] != (unsigned __int16)v11 || v49[2] != v46)
      {
        v49 += 3;
        if (v49 == (unsigned __int16 *)v78.i64[1])
        {
          uint64_t v49 = (unsigned __int16 *)v78.i64[1];
          break;
        }
      }
    }
    v8 += v47;
    if (v49 == (unsigned __int16 *)v78.i64[1])
    {
      if (v78.i64[1] >= (unint64_t)v79)
      {
        unint64_t v51 = 0xAAAAAAAAAAAAAAABLL * ((v78.i64[1] - v78.i64[0]) >> 1);
        unint64_t v52 = v51 + 1;
        if (v51 + 1 > 0x2AAAAAAAAAAAAAAALL) {
          abort();
        }
        if (0x5555555555555556 * ((uint64_t)&v79[-v78.i64[0]] >> 1) > v52) {
          unint64_t v52 = 0x5555555555555556 * ((uint64_t)&v79[-v78.i64[0]] >> 1);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v79[-v78.i64[0]] >> 1) >= 0x1555555555555555) {
          unint64_t v53 = 0x2AAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v53 = v52;
        }
        int16x8_t v77 = v80;
        if (v53) {
          unint64_t v54 = (char *)TInlineBufferAllocator<std::tuple<unsigned short,unsigned short,unsigned short>,4ul>::allocate((uint64_t)v80, v53);
        }
        else {
          unint64_t v54 = 0;
        }
        uint64_t v55 = &v54[6 * v51];
        *(_WORD *)uint64_t v55 = GlyphID;
        *((_WORD *)v55 + 1) = v11;
        *((_WORD *)v55 + 2) = v46;
        uint64_t v56 = v78.i64[1];
        uint64_t v57 = v78.i64[0];
        if (v78.i64[1] == v78.i64[0])
        {
          int64x2_t v61 = vdupq_n_s64(v78.u64[1]);
          CFRange v58 = &v54[6 * v51];
        }
        else
        {
          CFRange v58 = &v54[6 * v51];
          do
          {
            int v59 = *(_DWORD *)(v56 - 6);
            v56 -= 6;
            __int16 v60 = *(_WORD *)(v56 + 4);
            *(_DWORD *)(v58 - 6) = v59;
            v58 -= 6;
            *((_WORD *)v58 + 2) = v60;
          }
          while (v56 != v57);
          int64x2_t v61 = v78;
        }
        int64_t v50 = v55 + 6;
        v78.i64[0] = (uint64_t)v58;
        v78.i64[1] = (uint64_t)(v55 + 6);
        int64x2_t v75 = v61;
        uint64_t v62 = v79;
        unint64_t v79 = &v54[6 * v53];
        int16x8_t v76 = v62;
        uint64_t v74 = v61.i64[0];
        std::__split_buffer<std::tuple<unsigned short,unsigned short,unsigned short>,TInlineBufferAllocator<std::tuple<unsigned short,unsigned short,unsigned short>,4ul> &>::~__split_buffer((uint64_t)&v74);
      }
      else
      {
        *(_WORD *)v78.i64[1] = GlyphID;
        v48[1] = v11;
        int64_t v50 = v48 + 3;
        v48[2] = v46;
      }
      v78.i64[1] = (uint64_t)v50;
      int v63 = TRunGlue::GetGlyphID(v9, v73);
LABEL_87:
      int GlyphID = v63;
      unsigned int Class = TAATMorphSubtableMorx::FetchClass((TAATMorphSubtableMorx *)a1, v63);
      unint64_t v11 = v46;
    }
    else
    {
LABEL_57:
      unint64_t v11 = v46;
LABEL_58:
      v78.i64[1] = v78.i64[0];
      BOOL v17 = v8-- <= 1;
      if (!v17)
      {
        v73 += v13 * (uint64_t)*(int *)(a1 + 12);
        unint64_t v46 = v11;
        int v63 = TRunGlue::GetGlyphID(v9, v73);
        goto LABEL_87;
      }
      if (v8) {
        goto LABEL_89;
      }
      unsigned int Class = 0;
      v73 += v13 * (uint64_t)*(int *)(a1 + 12);
    }
  }
  __int16 v69 = v34;
  uint64_t v35 = v15 + bswap32(*(_DWORD *)(v15 + 28)) + 12;
  if (v26 != 0xFFFF && v28 != 0)
  {
    __int16 v65 = v29;
    int v29 = v22;
    unsigned int v36 = __rev16(v26);
    if (v73 < 0) {
      int v37 = 1;
    }
    else {
      int v37 = (v25 >> 11) & 1;
    }
    uint64_t v64 = v35;
    v73 &= ~(v73 >> 63);
    if (!TAATMorphSubtable::DoGlyphInsertion(a1, a2, (unsigned __int16)v28, v37, (v25 >> 13) & 1, v35 + 2 * v36, v15, v16, v73, v73, a8))goto LABEL_89; {
    if (*(int *)(a1 + 12) > 0)
    }
      int v38 = 1;
    else {
      int v38 = v37;
    }
    if (v38) {
      int v13 = (unsigned __int16)(v28 + 1);
    }
    else {
      int v13 = 1;
    }
    uint64_t v39 = a2;
    uint64_t v9 = a2;
    unsigned int v22 = v29;
    LOWORD(v29) = v65;
    uint64_t v35 = v64;
  }
  else
  {
    int v13 = 1;
    uint64_t v39 = a2;
  }
  unsigned int v68 = v22;
  if (v33)
  {
    unsigned int v40 = __rev16(v27);
    if (v73 < 0) {
      int v41 = 1;
    }
    else {
      int v41 = (v25 >> 10) & 1;
    }
    uint64_t v42 = v73 & ~(v73 >> 63);
    uint64_t v73 = v42;
    if ((v25 & 0x1000) != 0) {
      uint64_t v42 = *a3;
    }
    if (!TAATMorphSubtable::DoGlyphInsertion(a1, v39, (unsigned __int16)v30, v41, (unsigned __int16)(v25 & 0x1000) >> 12, v35 + 2 * v40, *(void *)(a1 + 104), *(void *)(a1 + 112), *a3, v42, a8))goto LABEL_89; {
    if (*(int *)(a1 + 12) > 0)
    }
      int v43 = 1;
    else {
      int v43 = v41;
    }
    if (v43) {
      int v44 = (unsigned __int16)v30;
    }
    else {
      int v44 = 0;
    }
    v13 += v44;
    uint64_t v39 = a2;
    uint64_t v9 = a2;
  }
  uint64_t v45 = TRunGlue::length(v39);
  unsigned int v22 = v68;
  __int16 v34 = v69;
  if (v45 <= v66) {
    goto LABEL_51;
  }
  *a8 = 6;
LABEL_89:
  std::vector<std::tuple<unsigned short,unsigned short,unsigned short>,TInlineBufferAllocator<std::tuple<unsigned short,unsigned short,unsigned short>,4ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v78);
}

uint64_t TAATMorphSubtableMorx::DoContextualSubstitution(uint64_t a1, uint64_t a2, unsigned int a3, TRunGlue *this, uint64_t a5, _DWORD *a6)
{
  uint64_t v11 = *(void *)(a1 + 104) + bswap32(*(_DWORD *)(*(void *)(a1 + 104) + 28)) + 12;
  uint64_t GlyphID = TRunGlue::GetGlyphID(this, a5);
  int v13 = (unsigned int *)(v11 + 4 * a3);
  int v14 = *(SFNTLookupTable **)(a1 + 112);
  if (*(void *)(a1 + 104) > (unint64_t)v13 || v13 + 1 > (unsigned int *)v14) {
    return 0;
  }
  uint64_t v16 = GlyphID;
  uint64_t v17 = bswap32(*v13);
  *(void *)&long long v18 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v44 = 0xAAAAAAAAAAAAAAAALL;
  long long v43 = v18;
  unint64_t v41 = (unint64_t)TAATLookupTable::BadTable;
  uint64_t v42 = 0;
  unint64_t v45 = 0xAAAAAAAAAAAAFFFFLL;
  TAATLookupTable::SetTable((uint64_t)&v41, (const SFNTLookupTable *)(v11 + v17), v14);
  uint64_t v19 = (uint64_t (*)(void, void, void))v41;
  if (v42) {
    BOOL v20 = (v42 & 1 | v41) == 0;
  }
  else {
    BOOL v20 = 1;
  }
  BOOL v21 = v20 && v41 == (void)TAATLookupTable::BadTable;
  uint64_t v22 = !v21;
  if (!v21)
  {
    double v46 = -3.72066208e-103;
    uint64_t v23 = (unint64_t *)((char *)&v41 + (v42 >> 1));
    if (v42) {
      uint64_t v19 = *(uint64_t (**)(void, void, void))(*v23 + v41);
    }
    unsigned int v24 = (_WORD *)v19(v23, v16, &v46);
    if (v24)
    {
      if (*(void *)(a1 + 104) <= (unint64_t)v24 && (unint64_t)(v24 + 1) <= *(void *)(a1 + 112))
      {
        unsigned int v26 = (unsigned __int16)*v24;
        unint64_t v27 = __rev16(v26);
        if (*v24 && v27 != v16)
        {
          if (v26 == 0xFFFF)
          {
            TRunGlue::Delete((void *)a2, a5, 0);
          }
          else
          {
            uint64_t v29 = *(void *)(a2 + 200);
            if (v29 && *(void *)(a2 + 624) > (int64_t)v27) {
              *(unsigned char *)(v29 + (v27 >> 3)) |= 1 << (v27 & 7);
            }
            if (*(void *)(a2 + 152))
            {
              TRunGlue::FocusOnIndex((TRunGlue *)a2, a5);
              uint64_t v30 = *(void *)(a2 + 152);
              uint64_t v31 = a5 - *(void *)(a2 + 160);
              [*(id *)(v30 + 216) setGlyph:v27 atIndex:*(void *)(v30 + 200) + v31];
              *(unsigned char *)(a2 + 592) = 1;
              [*(id *)(v30 + 216) setProps:*(_DWORD *)(*(void *)(*(void *)(v30 + 216) + 40) + 4 * *(void *)(v30 + 200) + 4 * v31) | 0x800u atIndex:*(void *)(v30 + 200) + v31];
              BOOL v32 = *(void **)(v30 + 216);
              uint64_t v33 = *(void *)(v30 + 200);
              int v34 = *(_DWORD *)(v32[5] + 4 * v33 + 4 * v31);
              if ((v34 & 0x40) != 0) {
                [v32 setProps:v34 & 0xFFFFEFBF | 0x1000 atIndex:v33 + v31];
              }
            }
            else
            {
              uint64_t v36 = *(void *)(a2 + 160) + a5;
              *(_WORD *)(*(void *)(a2 + 176) + 2 * v36) = v27;
              uint64_t v37 = *(void *)(a2 + 616);
              __int16 v47 = v27;
              double v46 = NAN;
              TFont::GetUnsummedAdvancesForGlyphs(v37, (uint64_t)&v47, &v46, 1, 1, 0, 0);
              uint64_t v38 = *(void *)(a2 + 184) + 16 * v36;
              *(double *)uint64_t v38 = v46;
              *(void *)(v38 + 8) = 0;
              uint64_t v39 = *(void *)(a2 + 520);
              if (v39)
              {
                int v40 = *(_DWORD *)(v39 + 4 * v36);
                if ((v40 & 0x1040) != 0) {
                  *(_DWORD *)(v39 + 4 * v36) = v40 & 0xFFFFEFBF | 0x1000;
                }
              }
            }
          }
          *a6 = 2;
        }
      }
    }
  }
  return v22;
}

void TAATMorphSubtableMorx::~TAATMorphSubtableMorx(TAATMorphSubtableMorx *this)
{
}

uint64_t TAATMorphSubtableMorx::GetEndPtr(TAATMorphSubtableMorx *this)
{
  return *((void *)this + 14);
}

uint64_t TAATMorphSubtableMorx::GetType(TAATMorphSubtableMorx *this)
{
  return *(unsigned char *)(*((void *)this + 13) + 7) & 0xF;
}

void *std::__function::__func<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#1},std::allocator<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#1}>,void ()(unsigned short,unsigned short const*)>::~__func(void *a1)
{
  *a1 = &unk_1ED0615E0;
  std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100](a1 + 1);
  return a1;
}

void std::__function::__func<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#1},std::allocator<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#1}>,void ()(unsigned short,unsigned short const*)>::~__func(void *a1)
{
  *a1 = &unk_1ED0615E0;
  std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100](a1 + 1);

  JUMPOUT(0x1853275C0);
}

void *std::__function::__func<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#1},std::allocator<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#1}>,void ()(unsigned short,unsigned short const*)>::__clone(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  unsigned int v2 = operator new(0x28uLL);
  *unsigned int v2 = &unk_1ED0615E0;
  std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)(v2 + 1), v1);
  return v2;
}

uint64_t std::__function::__func<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#1},std::allocator<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#1}>,void ()(unsigned short,unsigned short const*)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1ED0615E0;
  return std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)(a2 + 1), a1 + 8);
}

void *std::__function::__func<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#1},std::allocator<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#1}>,void ()(unsigned short,unsigned short const*)>::destroy(uint64_t a1)
{
  return std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100]((void *)(a1 + 8));
}

void std::__function::__func<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#1},std::allocator<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#1}>,void ()(unsigned short,unsigned short const*)>::destroy_deallocate(void *a1)
{
  std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100](a1 + 1);

  operator delete(a1);
}

uint64_t std::__function::__func<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#1},std::allocator<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#1}>,void ()(unsigned short,unsigned short const*)>::operator()(uint64_t a1, __int16 *a2, unsigned __int16 **a3)
{
  return std::function<void ()(unsigned short,unsigned short,unsigned short)>::operator()(a1 + 8, *a2, *a2, bswap32(**a3) >> 16);
}

void *std::__function::__func<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short const*)#1},std::allocator<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short const*)#1}>,void ()(unsigned short,unsigned short,unsigned short const*)>::~__func(void *a1)
{
  *a1 = &unk_1ED061670;
  std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100](a1 + 1);
  return a1;
}

void std::__function::__func<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short const*)#1},std::allocator<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short const*)#1}>,void ()(unsigned short,unsigned short,unsigned short const*)>::~__func(void *a1)
{
  *a1 = &unk_1ED061670;
  std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100](a1 + 1);

  JUMPOUT(0x1853275C0);
}

void *std::__function::__func<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short const*)#1},std::allocator<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short const*)#1}>,void ()(unsigned short,unsigned short,unsigned short const*)>::__clone(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  unsigned int v2 = operator new(0x28uLL);
  *unsigned int v2 = &unk_1ED061670;
  std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)(v2 + 1), v1);
  return v2;
}

uint64_t std::__function::__func<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short const*)#1},std::allocator<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short const*)#1}>,void ()(unsigned short,unsigned short,unsigned short const*)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1ED061670;
  return std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)(a2 + 1), a1 + 8);
}

void *std::__function::__func<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short const*)#1},std::allocator<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short const*)#1}>,void ()(unsigned short,unsigned short,unsigned short const*)>::destroy(uint64_t a1)
{
  return std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100]((void *)(a1 + 8));
}

void std::__function::__func<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short const*)#1},std::allocator<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short const*)#1}>,void ()(unsigned short,unsigned short,unsigned short const*)>::destroy_deallocate(void *a1)
{
  std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100](a1 + 1);

  operator delete(a1);
}

uint64_t std::__function::__func<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short const*)#1},std::allocator<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short const*)#1}>,void ()(unsigned short,unsigned short,unsigned short const*)>::operator()(uint64_t a1, __int16 *a2, __int16 *a3, unsigned __int16 **a4)
{
  return std::function<void ()(unsigned short,unsigned short,unsigned short)>::operator()(a1 + 8, *a2, *a3, bswap32(**a4) >> 16);
}

void *std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short const*)>::~__value_func[abi:nn180100](void *a1)
{
  unsigned int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::__function::__func<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short const*)#2},std::allocator<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short const*)#2}>,void ()(unsigned short,unsigned short,unsigned short const*)>::~__func(void *a1)
{
  *a1 = &unk_1ED061628;
  std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100](a1 + 1);
  return a1;
}

void std::__function::__func<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short const*)#2},std::allocator<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short const*)#2}>,void ()(unsigned short,unsigned short,unsigned short const*)>::~__func(void *a1)
{
  *a1 = &unk_1ED061628;
  std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100](a1 + 1);

  JUMPOUT(0x1853275C0);
}

char *std::__function::__func<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short const*)#2},std::allocator<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short const*)#2}>,void ()(unsigned short,unsigned short,unsigned short const*)>::__clone(uint64_t a1)
{
  uint64_t v2 = a1 + 8;
  unsigned int v3 = (char *)operator new(0x38uLL);
  *(void *)unsigned int v3 = &unk_1ED061628;
  std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)(v3 + 8), v2);
  *(_OWORD *)(v3 + 40) = *(_OWORD *)(a1 + 40);
  return v3;
}

__n128 std::__function::__func<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short const*)#2},std::allocator<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short const*)#2}>,void ()(unsigned short,unsigned short,unsigned short const*)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ED061628;
  std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::__value_func[abi:nn180100](a2 + 8, a1 + 8);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(a2 + 40) = result;
  return result;
}

void *std::__function::__func<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short const*)#2},std::allocator<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short const*)#2}>,void ()(unsigned short,unsigned short,unsigned short const*)>::destroy(uint64_t a1)
{
  return std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100]((void *)(a1 + 8));
}

void std::__function::__func<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short const*)#2},std::allocator<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short const*)#2}>,void ()(unsigned short,unsigned short,unsigned short const*)>::destroy_deallocate(void *a1)
{
  std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100](a1 + 1);

  operator delete(a1);
}

uint64_t std::__function::__func<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short const*)#2},std::allocator<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short const*)#2}>,void ()(unsigned short,unsigned short,unsigned short const*)>::operator()(uint64_t a1, unsigned __int16 *a2, unsigned __int16 *a3, unsigned __int16 **a4)
{
  return std::__invoke_void_return_wrapper<void,true>::__call[abi:nn180100]<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short const*)#2} &,unsigned short,unsigned short,unsigned short const*>(a1 + 8, a2, a3, a4);
}

uint64_t std::__invoke_void_return_wrapper<void,true>::__call[abi:nn180100]<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short const*)#2} &,unsigned short,unsigned short,unsigned short const*>(uint64_t result, unsigned __int16 *a2, unsigned __int16 *a3, unsigned __int16 **a4)
{
  uint64_t v4 = result;
  uint64_t v5 = *a2;
  unsigned int v6 = *a3;
  unint64_t v7 = *(void *)(result + 40);
  unint64_t v8 = *(void *)(result + 32) + (bswap32(**a4) >> 16);
  uint64_t v9 = v6 - v5 + 1;
  unint64_t v10 = v8 + 2 * v9;
  BOOL v11 = v10 < v8 || v10 > v7;
  if (!v11 || (v8 + 2 <= v7 ? (unint64_t v12 = (v7 - v8) >> 1) : (unint64_t v12 = 0), v12 == v9))
  {
    if (v5 <= v6 && v5 != (unsigned __int16)(v6 + 1))
    {
      unint64_t v13 = v8 - 2 * v5;
      int v14 = *a2;
      do
      {
        int v15 = (unsigned __int16)v14;
        __n128 result = std::function<void ()(unsigned short,unsigned short,unsigned short)>::operator()(v4, v14, v14, bswap32(*(unsigned __int16 *)(v13 + 2 * (unsigned __int16)v14)) >> 16);
        ++v14;
      }
      while (v15 != v6);
    }
  }
  return result;
}

void *std::__function::__func<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#2},std::allocator<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#2}>,void ()(unsigned short,unsigned short const*)>::~__func(void *a1)
{
  *a1 = &unk_1ED061550;
  std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100](a1 + 1);
  return a1;
}

void std::__function::__func<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#2},std::allocator<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#2}>,void ()(unsigned short,unsigned short const*)>::~__func(void *a1)
{
  *a1 = &unk_1ED061550;
  std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100](a1 + 1);

  JUMPOUT(0x1853275C0);
}

void *std::__function::__func<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#2},std::allocator<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#2}>,void ()(unsigned short,unsigned short const*)>::__clone(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x28uLL);
  *uint64_t v2 = &unk_1ED061550;
  std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)(v2 + 1), v1);
  return v2;
}

uint64_t std::__function::__func<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#2},std::allocator<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#2}>,void ()(unsigned short,unsigned short const*)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1ED061550;
  return std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)(a2 + 1), a1 + 8);
}

void *std::__function::__func<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#2},std::allocator<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#2}>,void ()(unsigned short,unsigned short const*)>::destroy(uint64_t a1)
{
  return std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100]((void *)(a1 + 8));
}

void *std::__function::__func<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#3},std::allocator<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#3}>,void ()(unsigned short,unsigned short const*)>::~__func(void *a1)
{
  *a1 = &unk_1ED061598;
  std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100](a1 + 1);
  return a1;
}

void std::__function::__func<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#3},std::allocator<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#3}>,void ()(unsigned short,unsigned short const*)>::~__func(void *a1)
{
  *a1 = &unk_1ED061598;
  std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100](a1 + 1);

  JUMPOUT(0x1853275C0);
}

void *std::__function::__func<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#3},std::allocator<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#3}>,void ()(unsigned short,unsigned short const*)>::__clone(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x28uLL);
  *uint64_t v2 = &unk_1ED061598;
  std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)(v2 + 1), v1);
  return v2;
}

uint64_t std::__function::__func<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#3},std::allocator<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#3}>,void ()(unsigned short,unsigned short const*)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1ED061598;
  return std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)(a2 + 1), a1 + 8);
}

void *std::__function::__func<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#3},std::allocator<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#3}>,void ()(unsigned short,unsigned short const*)>::destroy(uint64_t a1)
{
  return std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100]((void *)(a1 + 8));
}

void std::__function::__func<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#3},std::allocator<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#3}>,void ()(unsigned short,unsigned short const*)>::destroy_deallocate(void *a1)
{
  std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100](a1 + 1);

  operator delete(a1);
}

uint64_t std::__function::__func<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#3},std::allocator<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#3}>,void ()(unsigned short,unsigned short const*)>::operator()(uint64_t a1, __int16 *a2, unsigned __int16 **a3)
{
  return std::function<void ()(unsigned short,unsigned short,unsigned short)>::operator()(a1 + 8, *a2, *a2, bswap32(**a3) >> 16);
}

void *TInlineBufferAllocator<std::tuple<unsigned short,unsigned short,unsigned short>,4ul>::allocate(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 24);
  uint64_t v2 = (unint64_t *)(a1 + 24);
  uint64_t v3 = v4;
  unint64_t v5 = v4 + 6 * a2;
  if (v5 <= (unint64_t)v2)
  {
    *uint64_t v2 = v5;
    return (void *)v3;
  }
  else
  {
    if (a2 >= 0x2AAAAAAAAAAAAAABLL) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    return operator new(6 * a2);
  }
}

uint64_t std::__split_buffer<std::tuple<unsigned short,unsigned short,unsigned short>,TInlineBufferAllocator<std::tuple<unsigned short,unsigned short,unsigned short>,4ul> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != *(void *)(a1 + 8)) {
    *(void *)(a1 + 16) = (v2 - *(void *)(a1 + 8) - 6) % 6uLL + *(void *)(a1 + 8);
  }
  uint64_t v3 = *(void **)a1;
  if (*(void *)a1)
  {
    unint64_t v4 = *(void *)(a1 + 32);
    unint64_t v5 = (void *)(v4 + 24);
    if (v4 <= (unint64_t)v3 && v5 > v3)
    {
      if (*(void *)(a1 + 24) == *v5) {
        void *v5 = v3;
      }
    }
    else
    {
      operator delete(v3);
    }
  }
  return a1;
}

void *TRunGlue::Delete(void *this, uint64_t a2, int a3)
{
  unint64_t v5 = this;
  if (this[19])
  {
    TRunGlue::FocusOnIndex((TRunGlue *)this, a2);
    uint64_t v6 = v5[19];
    uint64_t v7 = a2 - v5[20];
    [*(id *)(v6 + 216) setGlyph:0xFFFFLL atIndex:*(void *)(v6 + 200) + v7];
    if ((*(unsigned char *)(v6 + 225) & 2) != 0) {
      *(unsigned char *)(v6 + 225) |= 8u;
    }
    TStorageRange::SetAdvance((TStorageRange *)(v6 + 192), v7, *MEMORY[0x1E4F1DB30]);
    [*(id *)(v6 + 216) setProps:*(_DWORD *)(*(void *)(*(void *)(v6 + 216) + 40) + 4 * *(void *)(v6 + 200) + 4 * v7) | 0x20u atIndex:*(void *)(v6 + 200) + v7];
    this = *(void **)(v6 + 216);
    uint64_t v8 = *(void *)(v6 + 200);
    LODWORD(v9) = *(_DWORD *)(this[5] + 4 * v8 + 4 * v7);
    if ((v9 & 0x40) != 0)
    {
      uint64_t v9 = v9 & 0xFFFFEFBF | 0x1000;
      this = (void *)[this setProps:v9 atIndex:v8 + v7];
    }
    if ((a3 & ~v9) != 0)
    {
      unint64_t v10 = *(void **)(v6 + 216);
      uint64_t v11 = *(void *)(v6 + 200) + v7;
      return (void *)[v10 setProps:v9 | a3 atIndex:v11];
    }
  }
  else
  {
    uint64_t v12 = this[20] + a2;
    uint64_t v13 = this[23];
    *(_WORD *)(this[22] + 2 * v12) = -1;
    *(_OWORD *)(v13 + 16 * v12) = *MEMORY[0x1E4F1DB30];
    uint64_t v14 = this[65];
    if (v14)
    {
      int v15 = *(_DWORD *)(v14 + 4 * v12) | a3;
      *(_DWORD *)(v14 + 4 * v12) = v15 | 0x20;
      if ((v15 & 0x1040) != 0) {
        *(_DWORD *)(v14 + 4 * v12) = v15 & 0xFFFFEF9F | 0x1020;
      }
    }
    else
    {
      *(unsigned char *)(this[26] + v12 / 8) |= 1 << (v12 & 7);
    }
  }
  return this;
}

void *std::__function::__func<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_0,std::allocator<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_0>,void ()(unsigned short,unsigned short,unsigned short)>::~__func(void *a1)
{
  *a1 = &unk_1ED0610D0;
  std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100](a1 + 5);
  return a1;
}

void std::__function::__func<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_0,std::allocator<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_0>,void ()(unsigned short,unsigned short,unsigned short)>::~__func(void *a1)
{
  *a1 = &unk_1ED0610D0;
  std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100](a1 + 5);

  JUMPOUT(0x1853275C0);
}

char *std::__function::__func<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_0,std::allocator<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_0>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x50uLL);
  *(void *)uint64_t v2 = &unk_1ED0610D0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  std::__function::__value_func<void ()(unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)(v2 + 40), a1 + 40);
  *((_WORD *)v2 + 36) = *(_WORD *)(a1 + 72);
  return v2;
}

uint64_t std::__function::__func<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_0,std::allocator<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_0>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ED0610D0;
  long long v4 = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v4;
  uint64_t result = std::__function::__value_func<void ()(unsigned short,unsigned short)>::__value_func[abi:nn180100](a2 + 40, a1 + 40);
  *(_WORD *)(a2 + 72) = *(_WORD *)(a1 + 72);
  return result;
}

void *std::__function::__func<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_0,std::allocator<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_0>,void ()(unsigned short,unsigned short,unsigned short)>::destroy(uint64_t a1)
{
  return std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100]((void *)(a1 + 40));
}

void std::__function::__func<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_0,std::allocator<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_0>,void ()(unsigned short,unsigned short,unsigned short)>::destroy_deallocate(void *a1)
{
  std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100](a1 + 5);

  operator delete(a1);
}

uint64_t std::__function::__func<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_0,std::allocator<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_0>,void ()(unsigned short,unsigned short,unsigned short)>::operator()(uint64_t result, __int16 *a2, __int16 *a3, unsigned __int16 *a4)
{
  unsigned int v4 = *a4;
  unsigned int v5 = *(_DWORD *)(result + 16);
  if (v5 > v4)
  {
    __int16 v6 = *a2;
    __int16 v7 = *a3;
    uint64_t v8 = *(void *)(result + 8);
    uint64_t v10 = *(void *)(result + 24);
    uint64_t v9 = *(void *)(result + 32);
    unint64_t v11 = *(void *)(v8 + 104);
    unint64_t v12 = *(void *)(v8 + 112);
    uint64_t v13 = (unsigned __int16 *)(v10 + 2 * *a4);
    if ((unint64_t)v13 >= v11 && (unint64_t)(v13 + 1) <= v12)
    {
      uint64_t v15 = bswap32(*v13) >> 16;
      uint64_t v16 = (unsigned __int16 *)(v9 + 4 * v15);
      if ((unint64_t)v16 >= v11 && (unint64_t)(v16 + 2) <= v12)
      {
        int v18 = *v16;
        if ((*(_WORD *)(v9 + 4 * v15 + 2) & 0xFE0) != 0 || v18 != 0) {
          return std::function<void ()(unsigned short,unsigned short)>::operator()(result + 40, v6, v7);
        }
      }
    }
    if (*(_WORD *)(result + 72))
    {
      BOOL v20 = (unsigned __int16 *)(v10 + 2 * (v4 + v5 * *(unsigned __int16 *)(result + 72)));
      if ((unint64_t)v20 >= v11 && (unint64_t)(v20 + 1) <= v12)
      {
        uint64_t v22 = bswap32(*v20) >> 16;
        uint64_t v23 = (_WORD *)(v9 + 4 * v22);
        if ((unint64_t)v23 >= v11
          && (unint64_t)(v23 + 2) <= v12
          && ((*(_WORD *)(v9 + 4 * v22 + 2) & 0xFE0) != 0 || *v23 != 0))
        {
          return std::function<void ()(unsigned short,unsigned short)>::operator()(result + 40, v6, v7);
        }
      }
    }
  }
  return result;
}

void *std::__function::__func<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_1,std::allocator<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_1>,void ()(unsigned short,unsigned short,unsigned short)>::~__func(void *a1)
{
  *a1 = &unk_1ED061118;
  std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100](a1 + 5);
  return a1;
}

void std::__function::__func<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_1,std::allocator<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_1>,void ()(unsigned short,unsigned short,unsigned short)>::~__func(void *a1)
{
  *a1 = &unk_1ED061118;
  std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100](a1 + 5);

  JUMPOUT(0x1853275C0);
}

char *std::__function::__func<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_1,std::allocator<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_1>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x50uLL);
  *(void *)uint64_t v2 = &unk_1ED061118;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  std::__function::__value_func<void ()(unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)(v2 + 40), a1 + 40);
  *((_WORD *)v2 + 36) = *(_WORD *)(a1 + 72);
  return v2;
}

uint64_t std::__function::__func<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_1,std::allocator<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_1>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ED061118;
  long long v4 = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v4;
  uint64_t result = std::__function::__value_func<void ()(unsigned short,unsigned short)>::__value_func[abi:nn180100](a2 + 40, a1 + 40);
  *(_WORD *)(a2 + 72) = *(_WORD *)(a1 + 72);
  return result;
}

void *std::__function::__func<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_1,std::allocator<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_1>,void ()(unsigned short,unsigned short,unsigned short)>::destroy(uint64_t a1)
{
  return std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100]((void *)(a1 + 40));
}

void std::__function::__func<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_1,std::allocator<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_1>,void ()(unsigned short,unsigned short,unsigned short)>::destroy_deallocate(void *a1)
{
  std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100](a1 + 5);

  operator delete(a1);
}

uint64_t std::__function::__func<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_1,std::allocator<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_1>,void ()(unsigned short,unsigned short,unsigned short)>::operator()(uint64_t result, __int16 *a2, __int16 *a3, unsigned __int16 *a4)
{
  unsigned int v4 = *a4;
  unsigned int v5 = (const unsigned __int16 *)*(unsigned int *)(result + 16);
  if (v5 > v4)
  {
    uint64_t v6 = result;
    __int16 v7 = *a2;
    __int16 v8 = *a3;
    uint64_t v9 = *(void *)(result + 8);
    uint64_t v10 = *(const STXEntryTwo **)(result + 24);
    uint64_t v11 = *(void *)(result + 32);
    unint64_t v12 = *(TAATMorphSubtableMorx **)(v9 + 104);
    unint64_t v13 = *(void *)(v9 + 112);
    uint64_t result = TAATMorphSubtableMorx::MorxContextualStateNeedsAction(v12, v13, 0, *a4, v5, v10, v11);
    if ((result & 1) != 0
      || *(_WORD *)(v6 + 72)
      && (uint64_t result = TAATMorphSubtableMorx::MorxContextualStateNeedsAction(v12, v13, *(unsigned __int16 *)(v6 + 72), v4, v5, v10, v11), result))
    {
      return std::function<void ()(unsigned short,unsigned short)>::operator()(v6 + 40, v7, v8);
    }
  }
  return result;
}

void *std::__function::__func<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_2,std::allocator<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_2>,void ()(unsigned short,unsigned short,unsigned short)>::~__func(void *a1)
{
  *a1 = &unk_1ED061160;
  std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100](a1 + 5);
  return a1;
}

void std::__function::__func<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_2,std::allocator<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_2>,void ()(unsigned short,unsigned short,unsigned short)>::~__func(void *a1)
{
  *a1 = &unk_1ED061160;
  std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100](a1 + 5);

  JUMPOUT(0x1853275C0);
}

uint64_t std::__function::__func<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_2,std::allocator<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_2>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ED061160;
  long long v4 = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v4;
  uint64_t result = std::__function::__value_func<void ()(unsigned short,unsigned short)>::__value_func[abi:nn180100](a2 + 40, a1 + 40);
  *(_WORD *)(a2 + 72) = *(_WORD *)(a1 + 72);
  return result;
}

void *std::__function::__func<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_2,std::allocator<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_2>,void ()(unsigned short,unsigned short,unsigned short)>::destroy(uint64_t a1)
{
  return std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100]((void *)(a1 + 40));
}

void *std::__function::__func<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_3,std::allocator<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_3>,void ()(unsigned short,unsigned short,unsigned short)>::~__func(void *a1)
{
  *a1 = &unk_1ED0611A8;
  std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100](a1 + 1);
  return a1;
}

void std::__function::__func<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_3,std::allocator<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_3>,void ()(unsigned short,unsigned short,unsigned short)>::~__func(void *a1)
{
  *a1 = &unk_1ED0611A8;
  std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100](a1 + 1);

  JUMPOUT(0x1853275C0);
}

void *std::__function::__func<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_3,std::allocator<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_3>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x28uLL);
  *uint64_t v2 = &unk_1ED0611A8;
  std::__function::__value_func<void ()(unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)(v2 + 1), v1);
  return v2;
}

uint64_t std::__function::__func<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_3,std::allocator<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_3>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1ED0611A8;
  return std::__function::__value_func<void ()(unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)(a2 + 1), a1 + 8);
}

void *std::__function::__func<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_3,std::allocator<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_3>,void ()(unsigned short,unsigned short,unsigned short)>::destroy(uint64_t a1)
{
  return std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100]((void *)(a1 + 8));
}

void std::__function::__func<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_3,std::allocator<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_3>,void ()(unsigned short,unsigned short,unsigned short)>::destroy_deallocate(void *a1)
{
  std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100](a1 + 1);

  operator delete(a1);
}

uint64_t std::__function::__func<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_3,std::allocator<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_3>,void ()(unsigned short,unsigned short,unsigned short)>::operator()(uint64_t result, unsigned __int16 *a2, unsigned __int16 *a3, _WORD *a4)
{
  int v4 = (unsigned __int16)*a4;
  if (*a4)
  {
    unsigned int v5 = *a3;
    unsigned int v6 = *a2;
    if (v6 <= v5 && v6 != (unsigned __int16)(v5 + 1))
    {
      uint64_t v7 = result + 8;
      do
      {
        if (v4 != (unsigned __int16)v6) {
          uint64_t result = std::function<void ()(unsigned short,unsigned short)>::operator()(v7, v6, v6);
        }
        BOOL v8 = v5 == (unsigned __int16)v6;
        LOWORD(v6) = v6 + 1;
      }
      while (!v8);
    }
  }
  return result;
}

void *std::__function::__func<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_4,std::allocator<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_4>,void ()(unsigned short,unsigned short,unsigned short)>::~__func(void *a1)
{
  *a1 = &unk_1ED0611F0;
  std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100](a1 + 5);
  return a1;
}

void std::__function::__func<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_4,std::allocator<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_4>,void ()(unsigned short,unsigned short,unsigned short)>::~__func(void *a1)
{
  *a1 = &unk_1ED0611F0;
  std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100](a1 + 5);

  JUMPOUT(0x1853275C0);
}

char *std::__function::__func<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_4,std::allocator<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_4>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x50uLL);
  *(void *)uint64_t v2 = &unk_1ED0611F0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  std::__function::__value_func<void ()(unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)(v2 + 40), a1 + 40);
  *((_WORD *)v2 + 36) = *(_WORD *)(a1 + 72);
  return v2;
}

uint64_t std::__function::__func<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_4,std::allocator<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_4>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ED0611F0;
  long long v4 = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v4;
  uint64_t result = std::__function::__value_func<void ()(unsigned short,unsigned short)>::__value_func[abi:nn180100](a2 + 40, a1 + 40);
  *(_WORD *)(a2 + 72) = *(_WORD *)(a1 + 72);
  return result;
}

void *std::__function::__func<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_4,std::allocator<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_4>,void ()(unsigned short,unsigned short,unsigned short)>::destroy(uint64_t a1)
{
  return std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100]((void *)(a1 + 40));
}

void std::__function::__func<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_4,std::allocator<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_4>,void ()(unsigned short,unsigned short,unsigned short)>::destroy_deallocate(void *a1)
{
  std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100](a1 + 5);

  operator delete(a1);
}

uint64_t std::__function::__func<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_4,std::allocator<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_4>,void ()(unsigned short,unsigned short,unsigned short)>::operator()(uint64_t result, __int16 *a2, __int16 *a3, unsigned __int16 *a4)
{
  unsigned int v4 = *a4;
  unsigned int v5 = (const unsigned __int16 *)*(unsigned int *)(result + 16);
  if (v5 > v4)
  {
    uint64_t v6 = result;
    __int16 v7 = *a2;
    __int16 v8 = *a3;
    uint64_t v9 = *(void *)(result + 8);
    uint64_t v10 = *(const STXEntryTwo **)(result + 24);
    uint64_t v11 = *(void *)(result + 32);
    unint64_t v12 = *(TAATMorphSubtableMorx **)(v9 + 104);
    unint64_t v13 = *(void *)(v9 + 112);
    uint64_t result = TAATMorphSubtableMorx::MorxInsertionStateNeedsAction(v12, v13, 0, *a4, v5, v10, v11);
    if ((result & 1) != 0
      || *(_WORD *)(v6 + 72)
      && (uint64_t result = TAATMorphSubtableMorx::MorxInsertionStateNeedsAction(v12, v13, *(unsigned __int16 *)(v6 + 72), v4, v5, v10, v11), result))
    {
      return std::function<void ()(unsigned short,unsigned short)>::operator()(v6 + 40, v7, v8);
    }
  }
  return result;
}

void TAATMorphSubtableMorx::DoLigatureAction<TRunGlue::TGlyphInVector>(TRunGlue&,unsigned short,TAATMorphSubtableMorx::MorxLigatureState *,MorphActionResultCode &)::{lambda(void)#1}::operator()(uint64_t a1)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(TRunGlue **)(a1 + 8);
  int v3 = *(_DWORD *)(*(void *)a1 + 12);
  if (v3 != *((_DWORD *)v2 + 6))
  {
    *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v44 = v4;
    long long v45 = v4;
    long long v42 = v4;
    long long v43 = v4;
    long long v40 = v4;
    long long v41 = v4;
    long long v38 = v4;
    long long v39 = v4;
    long long v36 = v4;
    long long v37 = v4;
    long long v35 = v4;
    long long v33 = v4;
    long long v34 = v4;
    long long v31 = v4;
    long long v32 = v4;
    long long v29 = v4;
    long long v30 = v4;
    std::vector<long,TInlineBufferAllocator<long,30ul>>::vector<std::__wrap_iter<long *>,0>((uint64_t)&v29, **(unsigned char ***)(a1 + 16), *(unsigned char **)(*(void *)(a1 + 16) + 8));
    uint64_t v6 = (void **)*((void *)&v29 + 1);
    unsigned int v5 = (void **)v29;
    if ((void)v29 != *((void *)&v29 + 1))
    {
      __int16 v7 = (void *)(*((void *)&v29 + 1) - 8);
      if (*((void *)&v29 + 1) - 8 > (unint64_t)v29)
      {
        unint64_t v8 = v29 + 8;
        do
        {
          uint64_t v9 = *(void *)(v8 - 8);
          *(void *)(v8 - 8) = *v7;
          *v7-- = v9;
          BOOL v10 = v8 >= (unint64_t)v7;
          v8 += 8;
        }
        while (!v10);
      }
    }
    uint64_t v11 = *(void ***)(a1 + 24);
    if ((unint64_t)v6 >= (unint64_t)v30)
    {
      uint64_t v13 = v6 - v5;
      unint64_t v14 = v13 + 1;
      if ((unint64_t)(v13 + 1) >> 61) {
        abort();
      }
      uint64_t v15 = v30 - (void)v5;
      if ((uint64_t)(v30 - (void)v5) >> 2 > v14) {
        unint64_t v14 = v15 >> 2;
      }
      if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v16 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v16 = v14;
      }
      v28[4] = (void **)&v30 + 1;
      if (v16)
      {
        uint64_t v17 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&v30 + 8, v16);
        uint64_t v6 = (void **)*((void *)&v29 + 1);
        unsigned int v5 = (void **)v29;
      }
      else
      {
        uint64_t v17 = 0;
      }
      int v18 = (void **)&v17[8 * v13];
      uint8_t *v18 = *v11;
      if (v6 == v5)
      {
        BOOL v20 = &v17[8 * v13];
      }
      else
      {
        uint64_t v19 = v6;
        BOOL v20 = &v17[8 * v13];
        do
        {
          uint64_t v21 = (uint64_t)*--v19;
          *((void *)v20 - 1) = v21;
          v20 -= 8;
        }
        while (v19 != v5);
      }
      unint64_t v12 = v18 + 1;
      *(void *)&long long v29 = v20;
      *((void *)&v29 + 1) = v18 + 1;
      uint64_t v22 = (void **)v30;
      *(void *)&long long v30 = &v17[8 * v16];
      v28[2] = v6;
      v28[3] = v22;
      v28[0] = v5;
      v28[1] = v5;
      std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)v28);
      unsigned int v5 = (void **)v29;
      uint64_t v11 = *(void ***)(a1 + 24);
    }
    else
    {
      *uint64_t v6 = *v11;
      unint64_t v12 = v6 + 1;
    }
    *((void *)&v29 + 1) = v12;
    unsigned int v24 = *v5;
    uint64_t v23 = v5 + 1;
    *uint64_t v11 = v24;
    if (v12 != v23) {
      memmove(**(void ***)(a1 + 16), v23, (char *)v12 - (char *)v23);
    }
    v28[0] = (void **)&v29;
    std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](v28);
    uint64_t v2 = *(TRunGlue **)(a1 + 8);
    int v3 = *((_DWORD *)v2 + 6);
  }
  *((void *)&v29 + 1) = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v25 = TRunGlue::length(v2);
  *(void *)&long long v29 = v2;
  DWORD2(v29) = v3;
  uint64_t v26 = -1;
  *(void *)&long long v30 = -1;
  *((void *)&v30 + 1) = v25;
  *(void *)&long long v31 = -1;
  uint64_t v27 = TRunGlue::length(v2);
  *((void *)&v31 + 1) = v27;
  *((void *)&v32 + 1) = -1;
  long long v33 = 0xFFFFFFFFFFFFFFFFLL;
  if (v3 < 0)
  {
    *(void *)&long long v30 = v25;
    *((void *)&v30 + 1) = -1;
    *(void *)&long long v31 = v27;
    *((void *)&v31 + 1) = -1;
    uint64_t v26 = v25;
  }
  *(void *)&long long v32 = v26;
  TGlyphIterator::DoLigature((TRunGlue **)&v29, **(void **)(a1 + 24), **(unsigned __int16 **)(a1 + 32), **(uint64_t ***)(a1 + 16), (uint64_t)(*(void *)(*(void *)(a1 + 16) + 8) - **(void **)(a1 + 16)) >> 3, 0);
}

char *std::vector<long,TInlineBufferAllocator<long,30ul>>::insert(uint64_t a1, char *__src, void *a3)
{
  long long v4 = __src;
  uint64_t v6 = *(char **)(a1 + 8);
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    unint64_t v12 = *(unsigned char **)a1;
    unint64_t v13 = ((uint64_t)&v6[-*(void *)a1] >> 3) + 1;
    if (v13 >> 61) {
      abort();
    }
    uint64_t v14 = (__src - v12) >> 3;
    uint64_t v15 = a1 + 24;
    uint64_t v16 = v7 - (void)v12;
    if (v16 >> 2 > v13) {
      unint64_t v13 = v16 >> 2;
    }
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v17 = v13;
    }
    uint64_t v24 = a1 + 24;
    if (v17) {
      int v18 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate(v15, v17);
    }
    else {
      int v18 = 0;
    }
    BOOL v20 = v18;
    uint64_t v21 = &v18[8 * v14];
    uint64_t v22 = v21;
    uint64_t v23 = &v18[8 * v17];
    std::__split_buffer<long,TInlineBufferAllocator<long,30ul> &>::push_back((uint64_t *)&v20, a3);
    long long v4 = std::vector<long,TInlineBufferAllocator<long,30ul>>::__swap_out_circular_buffer((void **)a1, (uint64_t)&v20, v4);
    std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v20);
  }
  else if (__src == v6)
  {
    *(void *)__src = *a3;
    *(void *)(a1 + 8) = __src + 8;
  }
  else
  {
    unint64_t v8 = __src + 8;
    uint64_t v9 = v6 - 8;
    BOOL v10 = *(void **)(a1 + 8);
    while (v9 < v6)
    {
      uint64_t v11 = *(void *)v9;
      v9 += 8;
      *v10++ = v11;
    }
    *(void *)(a1 + 8) = v10;
    if (v6 != v8) {
      memmove(&v6[-8 * ((v6 - v8) >> 3)], __src, v6 - v8);
    }
    *(void *)long long v4 = *a3;
  }
  return v4;
}

void TGlyphIterator::DoLigature(TRunGlue **this, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, const OTL::GDEF *a6)
{
  uint64_t v9 = a2;
  if (a6)
  {
    unsigned int GlyphID = TRunGlue::GetGlyphID(*this, a2);
    unint64_t v12 = (OTL::ClassDefTable *)*((void *)a6 + 2);
    if (v12) {
      int v13 = OTL::ClassDefTable::ClassOf(v12, GlyphID);
    }
    else {
      int v13 = 0;
    }
  }
  else
  {
    int v13 = 3;
  }
  char v14 = v13 == 3;
  TRunGlue::SetGlyphID<true>(*this, v9, a3);
  unsigned int GlyphProps = TRunGlue::GetGlyphProps(*this, v9);
  int v16 = v13 == 1;
  uint64_t v50 = a5;
  if (a5)
  {
    unsigned int v51 = GlyphProps;
    uint64_t v54 = v9;
    char v17 = 0;
    int v18 = a4;
    uint64_t v19 = a5;
    do
    {
      uint64_t v21 = *v18++;
      uint64_t v20 = v21;
      unsigned int v22 = TRunGlue::GetGlyphProps(*this, v21);
      char v23 = v22;
      if ((v22 & 0x10000000) != 0) {
        int v24 = HIBYTE(v22) & 0xF;
      }
      else {
        LOBYTE(v24) = 1;
      }
      if (a6)
      {
        unsigned int v25 = TRunGlue::GetGlyphID(*this, v54);
        uint64_t v26 = (OTL::ClassDefTable *)*((void *)a6 + 2);
        if (v26) {
          LODWORD(v26) = OTL::ClassDefTable::ClassOf(v26, v25);
        }
      }
      else
      {
        LODWORD(v26) = 3;
      }
      v17 += v24;
      BOOL v27 = v26 == 3;
      TRunGlue::Delete(*this, v20, 4096);
      v16 &= v27;
      v14 &= v27;
      --v19;
    }
    while (v19);
    uint64_t v9 = v54;
    unsigned int GlyphProps = v51;
  }
  else
  {
    char v17 = 0;
    char v23 = GlyphProps;
  }
  uint64_t v28 = v23 & 8 | GlyphProps & 0xFFFFFFF7;
  if (v14)
  {
    if (v28 != GlyphProps)
    {
      long long v29 = *this;
      TRunGlue::SetGlyphProps(v29, v9, v28);
    }
  }
  else
  {
    unsigned int v30 = GlyphProps >> 29;
    if ((GlyphProps & 0x10000000) != 0) {
      int v31 = HIBYTE(GlyphProps) & 0xF;
    }
    else {
      int v31 = 1;
    }
    unsigned int v55 = GlyphProps >> 29;
    if ((v16 & 1) == 0)
    {
      int v32 = *((_DWORD *)*this + 30);
      LODWORD(v28) = ((((_BYTE)v31 + v17) & 0xF) << 24) | (v32 << 29) | ((v23 & 8) + (GlyphProps & 0xFFFFFFF7)) & 0xFFFFFF | 0x10000000;
      do
      {
        ++v32;
        LODWORD(v28) = v28 + 0x20000000;
        unsigned int v30 = v32 & 7;
      }
      while ((v32 & 7) == 0);
      *((_DWORD *)*this + 30) = v32;
    }
    uint64_t v33 = v28 & 0xFFFFEFFF;
    if (v33 != GlyphProps) {
      TRunGlue::SetGlyphProps(*this, v9, v33);
    }
    uint64_t v34 = *((int *)this + 2) + v9;
    if (v34 >= 0 && TRunGlue::length(*this) > v34)
    {
      int v35 = -v31;
      if (v50)
      {
        uint64_t v36 = 0;
        unsigned int v37 = v31;
        do
        {
          long long v38 = this[3];
          if ((TRunGlue *)v34 == v38) {
            break;
          }
          char v52 = v35;
          char v39 = v31 + v35;
          while (1)
          {
            long long v40 = *this;
            if (v34 == a4[v36]) {
              break;
            }
            if (((TRunGlue::IsDeleted(v40, v34) | v16) & 1) == 0)
            {
              unsigned int v41 = TRunGlue::GetGlyphProps(*this, v34);
              int v42 = (v41 >> 28) & 1;
              if ((v41 & 0xF000000) == 0) {
                int v42 = 1;
              }
              if (v42) {
                unsigned int v43 = v37;
              }
              else {
                unsigned int v43 = HIBYTE(v41) & 0xF;
              }
              if (v37 < v43) {
                LOBYTE(v43) = v37;
              }
              TRunGlue::SetGlyphProps(*this, v34, (((v39 + (_BYTE)v43) & 0xF) << 24) | (v30 << 29) | v41 & 0xFFFFFF);
            }
            v34 += *((int *)this + 2);
            if ((TRunGlue *)v34 == v38)
            {
              uint64_t v34 = (uint64_t)v38;
              LOBYTE(v35) = v52;
              goto LABEL_56;
            }
          }
          unsigned int v44 = TRunGlue::GetGlyphProps(v40, v34);
          unsigned int v55 = v44 >> 29;
          unsigned int v37 = (v44 & 0x10000000) != 0 ? HIBYTE(v44) & 0xF : 1;
          LOBYTE(v31) = v37 + v31;
          v34 += *((int *)this + 2);
          ++v36;
          int v35 = -v37;
        }
        while (v36 != v50);
      }
      else
      {
        unsigned int v37 = v31;
      }
LABEL_56:
      if (v55)
      {
        long long v45 = this[3];
        if ((TRunGlue *)v34 != v45)
        {
          char v46 = v35 + v31;
          do
          {
            if (!TRunGlue::IsDeleted(*this, v34))
            {
              unsigned int v47 = TRunGlue::GetGlyphProps(*this, v34);
              if (v55 != v47 >> 29 || (v47 & 0x10000000) != 0) {
                return;
              }
              unsigned int v49 = HIBYTE(v47) & 0xF;
              if (v37 < v49) {
                LOBYTE(v49) = v37;
              }
              TRunGlue::SetGlyphProps(*this, v34, (((v46 + (_BYTE)v49) & 0xF) << 24) | (v30 << 29) | v47 & 0xFFFFFF);
            }
            v34 += *((int *)this + 2);
          }
          while ((TRunGlue *)v34 != v45);
        }
      }
    }
  }
}

uint64_t std::vector<long,TInlineBufferAllocator<long,30ul>>::vector<std::__wrap_iter<long *>,0>(uint64_t a1, unsigned char *a2, unsigned char *a3)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 264) = a1 + 24;
  int64_t v4 = a3 - a2;
  if (a3 != a2)
  {
    std::vector<long,TInlineBufferAllocator<long,30ul>>::__vallocate[abi:nn180100]((void *)a1, v4 >> 3);
    uint64_t v7 = *(void *)(a1 + 8);
    if (a3 != a2) {
      memmove(*(void **)(a1 + 8), a2, v4);
    }
    *(void *)(a1 + 8) = v7 + 8 * (v4 >> 3);
  }
  return a1;
}

void TRunGlue::SetGlyphProps(TRunGlue *this, uint64_t a2, uint64_t a3)
{
  if (*((void *)this + 19))
  {
    TRunGlue::FocusOnIndex(this, a2);
    uint64_t v6 = *((void *)this + 19);
    uint64_t v7 = *(void **)(v6 + 216);
    uint64_t v8 = a2 - *((void *)this + 20) + *(void *)(v6 + 200);
    [v7 setProps:a3 atIndex:v8];
    return;
  }
  uint64_t v9 = *((void *)this + 20) + a2;
  uint64_t v10 = *((void *)this + 65);
  if (v10)
  {
LABEL_8:
    *(_DWORD *)(v10 + 4 * v9) = a3;
    return;
  }
  if ((a3 & 0xFFFFFFDF) != 0)
  {
    TRunGlue::InitPropertiesFromDeletedGlyphs(this);
    uint64_t v10 = *((void *)this + 65);
    goto LABEL_8;
  }
  int v11 = 1 << (v9 & 7);
  uint64_t v12 = v9 / 8;
  uint64_t v13 = *((void *)this + 26);
  if ((a3 & 0x20) != 0) {
    char v14 = *(unsigned char *)(v13 + v12) | v11;
  }
  else {
    char v14 = *(unsigned char *)(v13 + v12) & ~(_BYTE)v11;
  }
  *(unsigned char *)(v13 + v12) = v14;
}

void TRunGlue::InitPropertiesFromDeletedGlyphs(TRunGlue *this)
{
  uint64_t v2 = (char *)this + 368;
  unint64_t v3 = TRunGlue::length(this);
  std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::resize((uint64_t)v2, v3);
  uint64_t v4 = *((void *)this + 46);
  *((void *)this + 65) = v4;
  uint64_t v5 = *((void *)this + 26);
  if (v5 != *((void *)this + 27))
  {
    uint64_t v6 = *((void *)this + 47) - v4;
    if (v6)
    {
      unint64_t v7 = v6 >> 2;
      uint64_t v8 = *((void *)this + 20);
      if (v7 <= 1) {
        unint64_t v7 = 1;
      }
      do
      {
        if ((*(unsigned __int8 *)(v5 + v8 / 8) >> (v8 & 7))) {
          *(_DWORD *)(v4 + 4 * v8) = 32;
        }
        ++v8;
        --v7;
      }
      while (v7);
    }
  }
}

void std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 2;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 4 * a2;
    }
  }
  else
  {
    std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__append((char **)a1, a2 - v2);
  }
}

void std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__append(char **a1, unint64_t a2)
{
  uint64_t v5 = a1[1];
  uint64_t v4 = a1[2];
  if (a2 <= (v4 - v5) >> 2)
  {
    if (a2)
    {
      bzero(a1[1], 4 * a2);
      v5 += 4 * a2;
    }
    a1[1] = v5;
  }
  else
  {
    uint64_t v6 = (uint64_t)(a1 + 3);
    unint64_t v7 = *a1;
    uint64_t v8 = v5 - *a1;
    unint64_t v9 = a2 + (v8 >> 2);
    if (v9 >> 62) {
      abort();
    }
    uint64_t v10 = v8 >> 2;
    uint64_t v11 = v4 - v7;
    if (v11 >> 1 > v9) {
      unint64_t v9 = v11 >> 1;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v9;
    }
    void v20[4] = a1 + 3;
    if (v12)
    {
      uint64_t v13 = (char *)TInlineBufferAllocator<unsigned int,30ul>::allocate(v6, v12);
      unint64_t v7 = *a1;
      uint64_t v5 = a1[1];
    }
    else
    {
      uint64_t v13 = 0;
    }
    char v14 = &v13[4 * v10];
    uint64_t v15 = &v13[4 * v12];
    bzero(v14, 4 * a2);
    int v16 = &v14[4 * a2];
    if (v5 != v7)
    {
      char v17 = v5;
      do
      {
        int v18 = *((_DWORD *)v17 - 1);
        v17 -= 4;
        *((_DWORD *)v14 - 1) = v18;
        v14 -= 4;
      }
      while (v17 != v7);
    }
    *a1 = v14;
    a1[1] = v16;
    uint64_t v19 = a1[2];
    a1[2] = v15;
    _OWORD v20[2] = v5;
    double v20[3] = v19;
    v20[0] = v7;
    v20[1] = v7;
    std::__split_buffer<unsigned int,TInlineBufferAllocator<unsigned int,30ul> &>::~__split_buffer((uint64_t)v20);
  }
}

uint64_t *std::__split_buffer<long,TInlineBufferAllocator<long,30ul> &>::push_back(uint64_t *result, void *a2)
{
  unint64_t v3 = result;
  uint64_t v4 = (char *)result[2];
  if (v4 == (char *)result[3])
  {
    uint64_t v5 = (char *)result[1];
    uint64_t v6 = (uint64_t)&v5[-*result];
    if ((unint64_t)v5 <= *result)
    {
      uint64_t v15 = (uint64_t)&v4[-*result];
      BOOL v14 = v15 == 0;
      uint64_t v16 = v15 >> 2;
      if (v14) {
        unint64_t v17 = 1;
      }
      else {
        unint64_t v17 = v16;
      }
      uint64_t v18 = result[4];
      v31[4] = v3[4];
      uint64_t v19 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate(v18, v17);
      uint64_t v20 = &v19[8 * (v17 >> 2)];
      uint64_t v22 = v3[1];
      uint64_t v21 = v3[2];
      char v23 = v20;
      uint64_t v24 = v21 - v22;
      if (v21 != v22)
      {
        char v23 = &v20[v24 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v25 = 8 * (v24 >> 3);
        uint64_t v26 = &v19[8 * (v17 >> 2)];
        BOOL v27 = (uint64_t *)v3[1];
        do
        {
          uint64_t v28 = *v27++;
          *(void *)uint64_t v26 = v28;
          v26 += 8;
          v25 -= 8;
        }
        while (v25);
      }
      uint64_t v29 = *v3;
      *unint64_t v3 = (uint64_t)v19;
      v3[1] = (uint64_t)v20;
      v31[0] = v29;
      v31[1] = v22;
      uint64_t v30 = v3[3];
      v3[2] = (uint64_t)v23;
      v3[3] = (uint64_t)&v19[8 * v17];
      v31[2] = v21;
      v31[3] = v30;
      uint64_t result = (uint64_t *)std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)v31);
      uint64_t v4 = (char *)v3[2];
    }
    else
    {
      uint64_t v7 = v6 >> 3;
      BOOL v8 = v6 >> 3 < -1;
      uint64_t v9 = (v6 >> 3) + 2;
      if (v8) {
        uint64_t v10 = v9;
      }
      else {
        uint64_t v10 = v7 + 1;
      }
      uint64_t v11 = -(v10 >> 1);
      unint64_t v12 = &v5[-8 * (v10 >> 1)];
      int64_t v13 = v4 - v5;
      if (v4 != v5)
      {
        uint64_t result = (uint64_t *)memmove(&v5[-8 * (v10 >> 1)], v5, v4 - v5);
        uint64_t v4 = (char *)v3[1];
      }
      v3[1] = (uint64_t)&v4[8 * v11];
      uint64_t v4 = &v12[v13];
    }
  }
  *(void *)uint64_t v4 = *a2;
  v3[2] = (uint64_t)(v4 + 8);
  return result;
}

uint64_t TAATMorphSubtable::DoSwashSubtable(void *a1, TRunGlue *a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, _DWORD *a7)
{
  uint64_t v21 = a2;
  uint64_t v22 = a3;
  if (a3 != a5)
  {
    uint64_t v11 = a1 + 3;
    do
    {
      if (!TRunGlue::TGlyph::IsDeleted((TRunGlue::TGlyph *)&v21))
      {
        uint64_t GlyphID = TRunGlue::GetGlyphID(v21, v22);
        unint64_t v23 = 0xAAAAAAAAAAAAAAAALL;
        int64_t v13 = (uint64_t (*)(void *, uint64_t, unint64_t *))a1[3];
        uint64_t v14 = a1[4];
        uint64_t v15 = (void *)((char *)v11 + (v14 >> 1));
        if (v14) {
          int64_t v13 = *(uint64_t (**)(void *, uint64_t, unint64_t *))(*v15 + v13);
        }
        uint64_t v16 = (_WORD *)v13(v15, GlyphID, &v23);
        if (v16)
        {
          if ((unint64_t)v16 >= a6 && (unint64_t)(v16 + 1) <= a1[12])
          {
            uint64_t v18 = __rev16((unsigned __int16)*v16);
            if (*v16) {
              BOOL v19 = v18 == GlyphID;
            }
            else {
              BOOL v19 = 1;
            }
            if (!v19)
            {
              TRunGlue::SetGlyphID<true>(v21, v22, v18);
              *a7 = 1;
            }
          }
        }
      }
      ++v22;
    }
    while (v22 != a5);
  }
  return 1;
}

BOOL TRunGlue::TGlyph::IsDeleted(TRunGlue::TGlyph *this)
{
  if (TRunGlue::GetGlyphID(*(TRunGlue **)this, *((void *)this + 1)) == 0xFFFF) {
    return 1;
  }
  unint64_t v2 = *(TRunGlue **)this;
  uint64_t v3 = *((void *)this + 1);

  return TRunGlue::IsDeleted(v2, v3);
}

uint64_t TAATMorphSubtable::DoGlyphInsertion(int a1, TRunGlue *this, unsigned int a3, int a4, int a5, unint64_t a6, unint64_t a7, unint64_t a8, uint64_t a9, uint64_t a10, int *a11)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = a3;
  if (a7 <= a6)
  {
    unint64_t v14 = a6 + 2 * a3;
    if (v14 >= a6 && v14 <= a8) {
      goto LABEL_11;
    }
  }
  BOOL v15 = a6 + 2 > a8 || a7 > a6;
  unint64_t v16 = (a8 - a6) >> 1;
  if (v15) {
    unint64_t v16 = 0;
  }
  if (v16 != a3) {
    return 0;
  }
LABEL_11:
  *(void *)&long long v17 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v17 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v48[3] = v17;
  v48[2] = v17;
  v48[1] = v17;
  v48[0] = v17;
  char v46 = 0;
  unsigned int v47 = 0;
  long long v45 = 0;
  unsigned int v49 = v48;
  if (a3)
  {
    int v38 = a4;
    int v39 = a5;
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    do
    {
      unsigned int v20 = bswap32(*(unsigned __int16 *)(a6 + 2 * v19)) >> 16;
      if (v18 >= v47)
      {
        uint64_t v21 = v45;
        uint64_t v22 = v18 - (char *)v45;
        if (v18 - (char *)v45 <= -3) {
          abort();
        }
        uint64_t v23 = v22 >> 1;
        if (v47 - (char *)v45 <= (unint64_t)((v22 >> 1) + 1)) {
          uint64_t v24 = v23 + 1;
        }
        else {
          uint64_t v24 = v47 - (char *)v45;
        }
        if ((unint64_t)(v47 - (char *)v45) >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v25 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v25 = v24;
        }
        unsigned int v44 = v48;
        if (v25)
        {
          uint64_t v26 = (char *)TInlineBufferAllocator<unsigned short,30ul>::allocate((uint64_t)v48, v25);
          uint64_t v21 = v45;
          uint64_t v18 = v46;
        }
        else
        {
          uint64_t v26 = 0;
        }
        BOOL v27 = &v26[2 * v23];
        *(_WORD *)BOOL v27 = v20;
        if (v18 == (char *)v21)
        {
          uint64_t v29 = &v26[2 * v23];
        }
        else
        {
          uint64_t v28 = (const unsigned __int16 *)v18;
          uint64_t v29 = &v26[2 * v23];
          do
          {
            __int16 v30 = *--v28;
            *((_WORD *)v29 - 1) = v30;
            v29 -= 2;
          }
          while (v28 != v21);
        }
        int v31 = v27 + 2;
        long long v45 = (const unsigned __int16 *)v29;
        char v46 = v27 + 2;
        int v32 = v47;
        unsigned int v47 = &v26[2 * v25];
        int v42 = v18;
        unsigned int v43 = v32;
        *(void *)long long v40 = v21;
        unsigned int v41 = v21;
        std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,30ul> &>::~__split_buffer((uint64_t)v40);
        uint64_t v18 = v31;
      }
      else
      {
        *(_WORD *)uint64_t v18 = v20;
        v18 += 2;
      }
      char v46 = v18;
      ++v19;
    }
    while (v19 != v13);
    uint64_t v33 = v45;
    a4 = v38;
    a5 = v39;
  }
  else
  {
    LODWORD(v18) = 0;
    uint64_t v33 = 0;
  }
  v40[0] = 0;
  uint64_t v34 = TRunGlue::DoGlyphInsertion(this, v33, (unsigned __int16)((v18 - v33) >> 1), a4, a5, a9, a10, 0, v40);
  uint64_t v35 = v34;
  if (v40[0]) {
    int v36 = 6;
  }
  else {
    int v36 = 5;
  }
  if (v34) {
    int v36 = 3;
  }
  *a11 = v36;
  *(void *)long long v40 = &v45;
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v40);
  return v35;
}

uint64_t TAATMorphSubtable::DoRearrangement(uint64_t a1, TRunGlue *a2, int a3, uint64_t a4, uint64_t a5, int *a6)
{
  uint64_t v90 = *MEMORY[0x1E4F143B8];
  int v9 = *(_DWORD *)(a1 + 12);
  if (v9 >= 0) {
    uint64_t v10 = a5;
  }
  else {
    uint64_t v10 = a4;
  }
  if (v9 >= 0) {
    uint64_t v11 = a4;
  }
  else {
    uint64_t v11 = a5;
  }
  uint64_t v12 = v10 - v11;
  int v13 = a3 - 1;
  switch(a3)
  {
    case 1:
    case 2:
      if ((v12 & 0x8000000000000000) == 0) {
        goto LABEL_15;
      }
      return 0;
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      if (v12 < 1) {
        return 0;
      }
      goto LABEL_15;
    case 8:
    case 9:
    case 10:
    case 11:
      if (v12 < 2) {
        return 0;
      }
      goto LABEL_15;
    case 12:
    case 13:
    case 14:
    case 15:
      if (v12 < 3) {
        return 0;
      }
      goto LABEL_15;
    default:
LABEL_15:
      if (v10 >= v11)
      {
        uint64_t v14 = v11;
        do
          TRunGlue::ClearGlyphCombiningMark(a2, v14++);
        while (v10 + 1 != v14);
      }
      if (!*((void *)a2 + 19))
      {
        long long v84 = 0u;
        long long v85 = 0u;
        *(_OWORD *)id __p = 0u;
        switch(v13)
        {
          case 0:
            TAATMorphSubtable::push(a2, __p, v11);
            v91.locatiouint64_t n = v11 + 1;
            v91.CFIndex length = v10 - v11;
            TRunGlue::MoveGlyphs(a2, v91, v11);
            goto LABEL_68;
          case 1:
            TAATMorphSubtable::push(a2, __p, v10);
            v94.locatiouint64_t n = v11;
            v94.CFIndex length = v10 - v11;
            TRunGlue::MoveGlyphs(a2, v94, v11 + 1);
            goto LABEL_56;
          case 2:
            TAATMorphSubtable::push(a2, __p, v11);
            TAATMorphSubtable::push(a2, __p, v10);
            goto LABEL_62;
          case 3:
            TAATMorphSubtable::push(a2, __p, v11);
            TAATMorphSubtable::push(a2, __p, v11 + 1);
            v95.locatiouint64_t n = v11 + 2;
            v95.CFIndex length = v10 + ~v11;
            TRunGlue::MoveGlyphs(a2, v95, v11);
            goto LABEL_54;
          case 4:
            TAATMorphSubtable::push(a2, __p, v11);
            TAATMorphSubtable::push(a2, __p, v11 + 1);
            v92.locatiouint64_t n = v11 + 2;
            v92.CFIndex length = v10 + ~v11;
            TRunGlue::MoveGlyphs(a2, v92, v11);
            goto LABEL_64;
          case 5:
            TAATMorphSubtable::push(a2, __p, v10 - 1);
            TAATMorphSubtable::push(a2, __p, v10);
            v96.CFIndex length = v10 + ~v11;
            v96.locatiouint64_t n = v11;
            TRunGlue::MoveGlyphs(a2, v96, v11 + 2);
            TAATMorphSubtable::pop(a2, __p, v11 + 1);
LABEL_56:
            uint64_t v10 = v11;
            goto LABEL_68;
          case 6:
            TAATMorphSubtable::push(a2, __p, v10 - 1);
            TAATMorphSubtable::push(a2, __p, v10);
            v97.CFIndex length = v10 + ~v11;
            v97.locatiouint64_t n = v11;
            TRunGlue::MoveGlyphs(a2, v97, v11 + 2);
            TAATMorphSubtable::pop(a2, __p, v11);
            uint64_t v10 = v11 + 1;
            goto LABEL_68;
          case 7:
            TAATMorphSubtable::push(a2, __p, v11);
            TAATMorphSubtable::push(a2, __p, v10);
            TAATMorphSubtable::push(a2, __p, v10 - 1);
            uint64_t v39 = v11 + 1;
            v98.CFIndex length = v12 - 2;
            v98.locatiouint64_t n = v11 + 1;
            TRunGlue::MoveGlyphs(a2, v98, v11 + 2);
            goto LABEL_59;
          case 8:
            TAATMorphSubtable::push(a2, __p, v11);
            TAATMorphSubtable::push(a2, __p, v10);
            TAATMorphSubtable::push(a2, __p, v10 - 1);
            v99.CFIndex length = v12 - 2;
            v99.locatiouint64_t n = v11 + 1;
            TRunGlue::MoveGlyphs(a2, v99, v11 + 2);
            TAATMorphSubtable::pop(a2, __p, v11 + 1);
LABEL_62:
            int v42 = a2;
            uint64_t v43 = v11;
            goto LABEL_65;
          case 9:
            TAATMorphSubtable::push(a2, __p, v11);
            TAATMorphSubtable::push(a2, __p, v11 + 1);
            TAATMorphSubtable::push(a2, __p, v10);
            v93.locatiouint64_t n = v11 + 2;
            v93.CFIndex length = v12 - 2;
            TRunGlue::MoveGlyphs(a2, v93, v11 + 1);
            TAATMorphSubtable::pop(a2, __p, v11);
LABEL_54:
            TAATMorphSubtable::pop(a2, __p, v10--);
            goto LABEL_68;
          case 10:
            TAATMorphSubtable::push(a2, __p, v11);
            TAATMorphSubtable::push(a2, __p, v11 + 1);
            TAATMorphSubtable::push(a2, __p, v10);
            v100.locatiouint64_t n = v11 + 2;
            v100.CFIndex length = v12 - 2;
            TRunGlue::MoveGlyphs(a2, v100, v11 + 1);
            TAATMorphSubtable::pop(a2, __p, v11);
LABEL_64:
            uint64_t v43 = v10 - 1;
            int v42 = a2;
            goto LABEL_65;
          case 11:
            TAATMorphSubtable::push(a2, __p, v11);
            TAATMorphSubtable::push(a2, __p, v11 + 1);
            uint64_t v36 = v10 - 1;
            TAATMorphSubtable::push(a2, __p, v10 - 1);
            TAATMorphSubtable::push(a2, __p, v10);
            TAATMorphSubtable::pop(a2, __p, v11 + 1);
            unsigned int v37 = a2;
            uint64_t v38 = v11;
            goto LABEL_67;
          case 12:
            TAATMorphSubtable::push(a2, __p, v11);
            TAATMorphSubtable::push(a2, __p, v11 + 1);
            uint64_t v39 = v10 - 1;
            TAATMorphSubtable::push(a2, __p, v10 - 1);
            TAATMorphSubtable::push(a2, __p, v10);
            TAATMorphSubtable::pop(a2, __p, v11 + 1);
LABEL_59:
            long long v40 = a2;
            uint64_t v41 = v11;
            goto LABEL_60;
          case 13:
            TAATMorphSubtable::push(a2, __p, v11);
            TAATMorphSubtable::push(a2, __p, v11 + 1);
            uint64_t v36 = v10 - 1;
            TAATMorphSubtable::push(a2, __p, v10 - 1);
            TAATMorphSubtable::push(a2, __p, v10);
            TAATMorphSubtable::pop(a2, __p, v11);
            unsigned int v37 = a2;
            uint64_t v38 = v11 + 1;
LABEL_67:
            TAATMorphSubtable::pop(v37, __p, v38);
            TAATMorphSubtable::pop(a2, __p, v10);
            uint64_t v10 = v36;
            goto LABEL_68;
          case 14:
            TAATMorphSubtable::push(a2, __p, v11);
            TAATMorphSubtable::push(a2, __p, v11 + 1);
            uint64_t v39 = v10 - 1;
            TAATMorphSubtable::push(a2, __p, v10 - 1);
            TAATMorphSubtable::push(a2, __p, v10);
            TAATMorphSubtable::pop(a2, __p, v11);
            long long v40 = a2;
            uint64_t v41 = v11 + 1;
LABEL_60:
            TAATMorphSubtable::pop(v40, __p, v41);
            int v42 = a2;
            uint64_t v43 = v39;
LABEL_65:
            TAATMorphSubtable::pop(v42, __p, v43);
LABEL_68:
            TAATMorphSubtable::pop(a2, __p, v10);
            uint64_t v35 = (void **)__p[1];
            uint64_t v34 = (void **)v84;
            break;
          default:
            uint64_t v34 = 0;
            uint64_t v35 = 0;
            break;
        }
        *a6 = 4;
        if ((unint64_t)((char *)v34 - (char *)v35) < 0x11)
        {
          unsigned int v44 = v35;
        }
        else
        {
          unsigned int v44 = (void **)__p[1];
          unint64_t v45 = (char *)v34 - (char *)__p[1];
          do
          {
            operator delete(*v35);
            ++v44;
            v45 -= 8;
            uint64_t v35 = v44;
          }
          while (v45 > 0x10);
          __p[1] = v44;
        }
        while (v44 != v34)
        {
          char v46 = *v44++;
          operator delete(v46);
        }
        if (__p[0]) {
          operator delete(__p[0]);
        }
        return 1;
      }
      uint64_t v82 = v11;
      uint64_t v15 = TRunGlue::PhysicalRunIndexWithGlyphIndex(a2, v11, &v82);
      if (v15 == -1) {
        uint64_t v16 = 0;
      }
      else {
        uint64_t v16 = *(void *)(*(void *)(*(void *)(*(void *)a2 + 16) + 8 * v15) + 48);
      }
      uint64_t v81 = v10;
      uint64_t v17 = TRunGlue::PhysicalRunIndexWithGlyphIndex(a2, v10, &v81);
      if (v17 == -1) {
        return 0;
      }
      uint64_t v18 = v17;
      uint64_t result = 0;
      if (v16)
      {
        uint64_t v20 = *(void *)(*(void *)(*(void *)(*(void *)a2 + 16) + 8 * v18) + 48);
        if (v20)
        {
          if (v16 != v20)
          {
            v89[0] = xmmword_184B87D58;
            v89[1] = unk_184B87D68;
            v89[2] = xmmword_184B87D78;
            v89[3] = unk_184B87D88;
            v88[0] = xmmword_184B87D18;
            v88[1] = unk_184B87D28;
            v88[2] = xmmword_184B87D38;
            v88[3] = unk_184B87D48;
            v87[0] = xmmword_184B87CD8;
            v87[1] = unk_184B87CE8;
            v87[2] = xmmword_184B87CF8;
            v87[3] = unk_184B87D08;
            *(_OWORD *)id __p = xmmword_184B87C98;
            long long v84 = unk_184B87CA8;
            long long v85 = xmmword_184B87CB8;
            long long v86 = unk_184B87CC8;
            switch(v13)
            {
              case 0:
                TAATMorphSubtable::CopyFromStorage(a2, v11, __p);
                v101.locatiouint64_t n = v10 - v11;
                v101.CFIndex length = v11;
                TAATMorphSubtable::MoveInStorage(a2, (TRunGlue *)(v11 + 1), v101);
                goto LABEL_96;
              case 1:
                TAATMorphSubtable::CopyFromStorage(a2, v10, __p);
                v103.CFIndex length = v11 + 1;
                v103.locatiouint64_t n = v10 - v11;
                TAATMorphSubtable::MoveInStorage(a2, (TRunGlue *)v11, v103);
                goto LABEL_86;
              case 2:
                TAATMorphSubtable::CopyFromStorage(a2, v11, __p);
                TAATMorphSubtable::CopyFromStorage(a2, v10, v87);
                int64x2_t v48 = a2;
                uint64_t v47 = v11;
                goto LABEL_95;
              case 3:
                TAATMorphSubtable::CopyFromStorage(a2, v11, __p);
                TAATMorphSubtable::CopyFromStorage(a2, v11 + 1, v87);
                v104.locatiouint64_t n = v10 + ~v11;
                v104.CFIndex length = v11;
                TAATMorphSubtable::MoveInStorage(a2, (TRunGlue *)(v11 + 2), v104);
                unsigned int v55 = a2;
                uint64_t v56 = v10;
                goto LABEL_91;
              case 4:
                TAATMorphSubtable::CopyFromStorage(a2, v11, __p);
                TAATMorphSubtable::CopyFromStorage(a2, v11 + 1, v87);
                v102.locatiouint64_t n = v10 + ~v11;
                v102.CFIndex length = v11;
                TAATMorphSubtable::MoveInStorage(a2, (TRunGlue *)(v11 + 2), v102);
                uint64_t v47 = v10 - 1;
                int64x2_t v48 = a2;
                goto LABEL_95;
              case 5:
                TAATMorphSubtable::CopyFromStorage(a2, v10 - 1, __p);
                TAATMorphSubtable::CopyFromStorage(a2, v10, v87);
                v105.locatiouint64_t n = v10 + ~v11;
                v105.CFIndex length = v11 + 2;
                TAATMorphSubtable::MoveInStorage(a2, (TRunGlue *)v11, v105);
                TAATMorphSubtable::CopyToStorage(a2, v11 + 1, (unsigned __int16 *)v87);
LABEL_86:
                uint64_t v49 = v11;
                goto LABEL_99;
              case 6:
                TAATMorphSubtable::CopyFromStorage(a2, v10 - 1, __p);
                TAATMorphSubtable::CopyFromStorage(a2, v10, v87);
                v106.locatiouint64_t n = v10 + ~v11;
                v106.CFIndex length = v11 + 2;
                TAATMorphSubtable::MoveInStorage(a2, (TRunGlue *)v11, v106);
                TAATMorphSubtable::CopyToStorage(a2, v11, (unsigned __int16 *)v87);
                uint64_t v49 = v11 + 1;
                goto LABEL_99;
              case 7:
                TAATMorphSubtable::CopyFromStorage(a2, v11, __p);
                TAATMorphSubtable::CopyFromStorage(a2, v10, v87);
                TAATMorphSubtable::CopyFromStorage(a2, v10 - 1, v88);
                v107.locatiouint64_t n = v12 - 2;
                v107.CFIndex length = v11 + 2;
                TAATMorphSubtable::MoveInStorage(a2, (TRunGlue *)(v11 + 1), v107);
                TAATMorphSubtable::CopyToStorage(a2, v11, (unsigned __int16 *)v88);
                int64x2_t v48 = a2;
                uint64_t v47 = v11 + 1;
                goto LABEL_95;
              case 8:
                TAATMorphSubtable::CopyFromStorage(a2, v11, __p);
                TAATMorphSubtable::CopyFromStorage(a2, v10, v87);
                TAATMorphSubtable::CopyFromStorage(a2, v10 - 1, v88);
                v108.locatiouint64_t n = v12 - 2;
                v108.CFIndex length = v11 + 2;
                TAATMorphSubtable::MoveInStorage(a2, (TRunGlue *)(v11 + 1), v108);
                TAATMorphSubtable::CopyToStorage(a2, v11 + 1, (unsigned __int16 *)v88);
                int64x2_t v48 = a2;
                uint64_t v47 = v11;
                goto LABEL_95;
              case 9:
                TAATMorphSubtable::CopyFromStorage(a2, v11, __p);
                TAATMorphSubtable::CopyFromStorage(a2, v11 + 1, v87);
                TAATMorphSubtable::CopyFromStorage(a2, v10, v88);
                v109.locatiouint64_t n = v12 - 2;
                v109.CFIndex length = v11 + 1;
                TAATMorphSubtable::MoveInStorage(a2, (TRunGlue *)(v11 + 2), v109);
                TAATMorphSubtable::CopyToStorage(a2, v11, (unsigned __int16 *)v88);
                unsigned int v55 = a2;
                uint64_t v56 = v10;
LABEL_91:
                TAATMorphSubtable::CopyToStorage(v55, v56, (unsigned __int16 *)v87);
                uint64_t v49 = v10 - 1;
                goto LABEL_99;
              case 10:
                TAATMorphSubtable::CopyFromStorage(a2, v11, __p);
                TAATMorphSubtable::CopyFromStorage(a2, v11 + 1, v87);
                TAATMorphSubtable::CopyFromStorage(a2, v10, v88);
                v110.locatiouint64_t n = v12 - 2;
                v110.CFIndex length = v11 + 1;
                TAATMorphSubtable::MoveInStorage(a2, (TRunGlue *)(v11 + 2), v110);
                TAATMorphSubtable::CopyToStorage(a2, v11, (unsigned __int16 *)v88);
                uint64_t v47 = v10 - 1;
                int64x2_t v48 = a2;
                goto LABEL_95;
              case 11:
                TAATMorphSubtable::CopyFromStorage(a2, v11, __p);
                TAATMorphSubtable::CopyFromStorage(a2, v11 + 1, v87);
                uint64_t v49 = v10 - 1;
                TAATMorphSubtable::CopyFromStorage(a2, v10 - 1, v88);
                TAATMorphSubtable::CopyFromStorage(a2, v10, v89);
                TAATMorphSubtable::CopyToStorage(a2, v11 + 1, (unsigned __int16 *)v89);
                uint64_t v50 = a2;
                uint64_t v51 = v11;
                goto LABEL_98;
              case 12:
                TAATMorphSubtable::CopyFromStorage(a2, v11, __p);
                TAATMorphSubtable::CopyFromStorage(a2, v11 + 1, v87);
                uint64_t v52 = v10 - 1;
                TAATMorphSubtable::CopyFromStorage(a2, v10 - 1, v88);
                TAATMorphSubtable::CopyFromStorage(a2, v10, v89);
                TAATMorphSubtable::CopyToStorage(a2, v11 + 1, (unsigned __int16 *)v89);
                unint64_t v53 = a2;
                uint64_t v54 = v11;
                goto LABEL_94;
              case 13:
                TAATMorphSubtable::CopyFromStorage(a2, v11, __p);
                TAATMorphSubtable::CopyFromStorage(a2, v11 + 1, v87);
                uint64_t v49 = v10 - 1;
                TAATMorphSubtable::CopyFromStorage(a2, v10 - 1, v88);
                TAATMorphSubtable::CopyFromStorage(a2, v10, v89);
                TAATMorphSubtable::CopyToStorage(a2, v11, (unsigned __int16 *)v89);
                uint64_t v50 = a2;
                uint64_t v51 = v11 + 1;
LABEL_98:
                TAATMorphSubtable::CopyToStorage(v50, v51, (unsigned __int16 *)v88);
                TAATMorphSubtable::CopyToStorage(a2, v10, (unsigned __int16 *)v87);
                goto LABEL_99;
              case 14:
                TAATMorphSubtable::CopyFromStorage(a2, v11, __p);
                TAATMorphSubtable::CopyFromStorage(a2, v11 + 1, v87);
                uint64_t v52 = v10 - 1;
                TAATMorphSubtable::CopyFromStorage(a2, v10 - 1, v88);
                TAATMorphSubtable::CopyFromStorage(a2, v10, v89);
                TAATMorphSubtable::CopyToStorage(a2, v11, (unsigned __int16 *)v89);
                unint64_t v53 = a2;
                uint64_t v54 = v11 + 1;
LABEL_94:
                TAATMorphSubtable::CopyToStorage(v53, v54, (unsigned __int16 *)v88);
                int64x2_t v48 = a2;
                uint64_t v47 = v52;
LABEL_95:
                TAATMorphSubtable::CopyToStorage(v48, v47, (unsigned __int16 *)v87);
LABEL_96:
                uint64_t v49 = v10;
LABEL_99:
                TAATMorphSubtable::CopyToStorage(a2, v49, (unsigned __int16 *)__p);
                break;
              default:
                break;
            }
            if (v10 >= v11)
            {
              uint64_t v57 = v10 + 1;
              do
                *(_DWORD *)(*(void *)(*(void *)(*(void *)(*(void *)a2 + 16)
                                                  + 8
                                                  * TRunGlue::PhysicalRunIndexWithGlyphIndex(a2, v11++, (uint64_t *)__p))
                                      + 48)
                          + 256) = 2;
              while (v57 != v11);
            }
LABEL_143:
            int v71 = 4;
LABEL_144:
            *a6 = v71;
            return 1;
          }
          uint64_t v21 = v81;
          uint64_t v22 = v82;
          if (a3 == 1)
          {
            uint64_t v23 = *(void *)(*(void *)(atomic_load_explicit((atomic_ullong *volatile)(v16 + 56), memory_order_acquire)+ 40)+ 400);
            if (!(*(unsigned int (**)(uint64_t))(*(void *)v23 + 712))(v23))
            {
              uint64_t v33 = (id *)(v16 + 216);
              [*(id *)(v16 + 216) initGlyphStackWithCapacity:4];
LABEL_44:
              [*(id *)(v16 + 216) pushGlyphAtIndex:*(void *)(v16 + 200) + v22];
              [*(id *)(v16 + 216) moveGlyphsFromRange:*(void *)(v16 + 200) + v22 + 1 toIndex:v21 - v22];
LABEL_140:
              uint64_t v72 = *(void *)(v16 + 200);
LABEL_141:
              [*v33 popGlyphAtIndex:v72 + v21];
LABEL_142:
              [*(id *)(v16 + 216) disposeGlyphStack];
              *(_DWORD *)(v16 + 256) = 2;
              goto LABEL_143;
            }
            uint64_t v24 = *(void **)(v16 + 216);
            uint64_t v25 = v24[2];
            uint64_t v26 = *(void *)(v16 + 200);
            if (v22 + 1 >= v21)
            {
LABEL_38:
              uint64_t v29 = v25 + 2 * v26;
              uint64_t v30 = v24[4];
              if (v30 || (uint64_t v58 = v24[3]) == 0)
              {
                uint64_t v31 = v30 + 16 * v26 + 16 * v22;
                CGFloat v32 = *(double *)(v31 + 8);
              }
              else
              {
                uint64_t v31 = v58 + 8 * v26 + 8 * v22;
                CGFloat v32 = 0.0;
              }
              uint64_t v59 = *(unsigned __int16 *)(v29 + 2 * v22);
              CGFloat v60 = *(double *)v31;
              uint64_t v61 = *(unsigned int *)(v24[5] + 4 * v26 + 4 * v22);
              int v62 = *(unsigned __int16 *)(v29 + 2 * v21);
              [v24 setGlyph:*(unsigned __int16 *)(v29 + 2 * v21) atIndex:v26 + v22];
              char v63 = *(unsigned char *)(v16 + 225);
              if (v62 == 0xFFFF && (v63 & 2) != 0) {
                *(unsigned char *)(v16 + 225) = v63 | 8;
              }
              uint64_t v65 = *(void *)(v16 + 216);
              uint64_t v66 = *(void *)(v65 + 32);
              if (v66 || (uint64_t v69 = *(void *)(v65 + 24)) == 0)
              {
                CGFloat v67 = (uint64_t *)(v66 + 16 * *(void *)(v16 + 200) + 16 * v21);
                uint64_t v68 = v67[1];
              }
              else
              {
                CGFloat v67 = (uint64_t *)(v69 + 8 * *(void *)(v16 + 200) + 8 * v21);
                uint64_t v68 = 0;
              }
              uint64_t v70 = *v67;
              TStorageRange::SetAdvance((TStorageRange *)(v16 + 192), v22, *(CGSize *)(&v68 - 1));
              [*(id *)(v16 + 216) setProps:*(unsigned int *)(*(void *)(*(void *)(v16 + 216) + 40) + 4 * *(void *)(v16 + 200) + 4 * v21) atIndex:*(void *)(v16 + 200) + v22];
              [*(id *)(v16 + 216) setGlyph:v59 atIndex:*(void *)(v16 + 200) + v21];
              if (v59 == 0xFFFF && (*(unsigned char *)(v16 + 225) & 2) != 0) {
                *(unsigned char *)(v16 + 225) |= 8u;
              }
              v111.CGFloat width = v60;
              v111.CGFloat height = v32;
              TStorageRange::SetAdvance((TStorageRange *)(v16 + 192), v21, v111);
              [*(id *)(v16 + 216) setProps:v61 atIndex:*(void *)(v16 + 200) + v21];
              int v71 = 1;
              goto LABEL_144;
            }
            uint64_t v27 = ~v22 + v21;
            uint64_t v28 = v26 + v22 + 1;
            while (*(__int16 *)(v25 + 2 * v28) == -1 || (*(_DWORD *)(v24[5] + 4 * v28) & 0x20) != 0)
            {
              ++v28;
              if (!--v27) {
                goto LABEL_38;
              }
            }
          }
          else
          {
            uint64_t v24 = *(void **)(v16 + 216);
          }
          [v24 initGlyphStackWithCapacity:4];
          uint64_t v33 = (id *)(v16 + 216);
          switch(a3)
          {
            case 1:
              goto LABEL_44;
            case 2:
              [*(id *)(v16 + 216) pushGlyphAtIndex:*(void *)(v16 + 200) + v21];
              objc_msgSend(*(id *)(v16 + 216), "moveGlyphsFromRange:toIndex:", *(void *)(v16 + 200) + v22, v21 - v22, *(void *)(v16 + 200) + v22 + 1);
              goto LABEL_123;
            case 3:
              [*(id *)(v16 + 216) pushGlyphAtIndex:*(void *)(v16 + 200) + v22];
              [*(id *)(v16 + 216) pushGlyphAtIndex:*(void *)(v16 + 200) + v21];
              goto LABEL_127;
            case 4:
              [*(id *)(v16 + 216) pushGlyphAtIndex:*(void *)(v16 + 200) + v22];
              [*(id *)(v16 + 216) pushGlyphAtIndex:v22 + *(void *)(v16 + 200) + 1];
              [*(id *)(v16 + 216) moveGlyphsFromRange:*(void *)(v16 + 200) + v22 + 2 toIndex:v21 + ~v22];
              goto LABEL_129;
            case 5:
              [*(id *)(v16 + 216) pushGlyphAtIndex:*(void *)(v16 + 200) + v22];
              [*(id *)(v16 + 216) pushGlyphAtIndex:v22 + *(void *)(v16 + 200) + 1];
              [*(id *)(v16 + 216) moveGlyphsFromRange:*(void *)(v16 + 200) + v22 + 2 toIndex:v21 + ~v22];
              goto LABEL_132;
            case 6:
              [*(id *)(v16 + 216) pushGlyphAtIndex:v21 + *(void *)(v16 + 200) - 1];
              [*(id *)(v16 + 216) pushGlyphAtIndex:*(void *)(v16 + 200) + v21];
              objc_msgSend(*(id *)(v16 + 216), "moveGlyphsFromRange:toIndex:", *(void *)(v16 + 200) + v22, v21 + ~v22, *(void *)(v16 + 200) + v22 + 2);
              [*(id *)(v16 + 216) popGlyphAtIndex:v22 + *(void *)(v16 + 200) + 1];
LABEL_123:
              uint64_t v72 = *(void *)(v16 + 200);
              uint64_t v21 = v22;
              goto LABEL_141;
            case 7:
              [*(id *)(v16 + 216) pushGlyphAtIndex:v21 + *(void *)(v16 + 200) - 1];
              [*(id *)(v16 + 216) pushGlyphAtIndex:*(void *)(v16 + 200) + v21];
              objc_msgSend(*(id *)(v16 + 216), "moveGlyphsFromRange:toIndex:", *(void *)(v16 + 200) + v22, v21 + ~v22, *(void *)(v16 + 200) + v22 + 2);
              [*(id *)(v16 + 216) popGlyphAtIndex:*(void *)(v16 + 200) + v22];
              uint64_t v72 = v22 + 1;
              goto LABEL_130;
            case 8:
              [*(id *)(v16 + 216) pushGlyphAtIndex:*(void *)(v16 + 200) + v22];
              [*(id *)(v16 + 216) pushGlyphAtIndex:*(void *)(v16 + 200) + v21];
              [*(id *)(v16 + 216) pushGlyphAtIndex:v21 + *(void *)(v16 + 200) - 1];
              objc_msgSend(*(id *)(v16 + 216), "moveGlyphsFromRange:toIndex:", *(void *)(v16 + 200) + v22 + 1, v21 - v22 - 2, v22 + *(void *)(v16 + 200) + 2);
              [*(id *)(v16 + 216) popGlyphAtIndex:*(void *)(v16 + 200) + v22];
              uint64_t v73 = *(void **)(v16 + 216);
              uint64_t v74 = *(void *)(v16 + 200) + v22 + 1;
              goto LABEL_139;
            case 9:
              [*(id *)(v16 + 216) pushGlyphAtIndex:*(void *)(v16 + 200) + v22];
              [*(id *)(v16 + 216) pushGlyphAtIndex:*(void *)(v16 + 200) + v21];
              [*(id *)(v16 + 216) pushGlyphAtIndex:v21 + *(void *)(v16 + 200) - 1];
              objc_msgSend(*(id *)(v16 + 216), "moveGlyphsFromRange:toIndex:", *(void *)(v16 + 200) + v22 + 1, v21 - v22 - 2, v22 + *(void *)(v16 + 200) + 2);
              [*(id *)(v16 + 216) popGlyphAtIndex:*(void *)(v16 + 200) + v22 + 1];
LABEL_127:
              uint64_t v73 = *(void **)(v16 + 216);
              uint64_t v74 = *(void *)(v16 + 200) + v22;
              goto LABEL_139;
            case 10:
              [*(id *)(v16 + 216) pushGlyphAtIndex:*(void *)(v16 + 200) + v22];
              [*(id *)(v16 + 216) pushGlyphAtIndex:*(void *)(v16 + 200) + v22 + 1];
              [*(id *)(v16 + 216) pushGlyphAtIndex:*(void *)(v16 + 200) + v21];
              objc_msgSend(*(id *)(v16 + 216), "moveGlyphsFromRange:toIndex:", v22 + *(void *)(v16 + 200) + 2, v21 - v22 - 2, *(void *)(v16 + 200) + v22 + 1);
              [*(id *)(v16 + 216) popGlyphAtIndex:*(void *)(v16 + 200) + v22];
LABEL_129:
              [*(id *)(v16 + 216) popGlyphAtIndex:*(void *)(v16 + 200) + v21];
              uint64_t v72 = v21 - 1;
LABEL_130:
              uint64_t v21 = *(void *)(v16 + 200);
              goto LABEL_141;
            case 11:
              [*(id *)(v16 + 216) pushGlyphAtIndex:*(void *)(v16 + 200) + v22];
              [*(id *)(v16 + 216) pushGlyphAtIndex:*(void *)(v16 + 200) + v22 + 1];
              [*(id *)(v16 + 216) pushGlyphAtIndex:*(void *)(v16 + 200) + v21];
              objc_msgSend(*(id *)(v16 + 216), "moveGlyphsFromRange:toIndex:", v22 + *(void *)(v16 + 200) + 2, v21 - v22 - 2, *(void *)(v16 + 200) + v22 + 1);
              [*(id *)(v16 + 216) popGlyphAtIndex:*(void *)(v16 + 200) + v22];
LABEL_132:
              uint64_t v73 = *(void **)(v16 + 216);
              uint64_t v74 = v21 + *(void *)(v16 + 200) - 1;
              goto LABEL_139;
            case 12:
              [*(id *)(v16 + 216) pushGlyphAtIndex:*(void *)(v16 + 200) + v22];
              [*(id *)(v16 + 216) pushGlyphAtIndex:*(void *)(v16 + 200) + v22 + 1];
              uint64_t v75 = v21 - 1;
              [*(id *)(v16 + 216) pushGlyphAtIndex:*(void *)(v16 + 200) + v21 - 1];
              [*(id *)(v16 + 216) pushGlyphAtIndex:*(void *)(v16 + 200) + v21];
              [*(id *)(v16 + 216) popGlyphAtIndex:*(void *)(v16 + 200) + v22 + 1];
              int16x8_t v76 = *(void **)(v16 + 216);
              uint64_t v77 = *(void *)(v16 + 200) + v22;
              goto LABEL_136;
            case 13:
              [*(id *)(v16 + 216) pushGlyphAtIndex:*(void *)(v16 + 200) + v22];
              [*(id *)(v16 + 216) pushGlyphAtIndex:*(void *)(v16 + 200) + v22 + 1];
              uint64_t v78 = v21 - 1;
              [*(id *)(v16 + 216) pushGlyphAtIndex:*(void *)(v16 + 200) + v21 - 1];
              [*(id *)(v16 + 216) pushGlyphAtIndex:*(void *)(v16 + 200) + v21];
              [*(id *)(v16 + 216) popGlyphAtIndex:*(void *)(v16 + 200) + v22 + 1];
              unint64_t v79 = *(void **)(v16 + 216);
              uint64_t v80 = *(void *)(v16 + 200) + v22;
              goto LABEL_138;
            case 14:
              [*(id *)(v16 + 216) pushGlyphAtIndex:*(void *)(v16 + 200) + v22];
              [*(id *)(v16 + 216) pushGlyphAtIndex:*(void *)(v16 + 200) + v22 + 1];
              uint64_t v75 = v21 - 1;
              [*(id *)(v16 + 216) pushGlyphAtIndex:*(void *)(v16 + 200) + v21 - 1];
              [*(id *)(v16 + 216) pushGlyphAtIndex:*(void *)(v16 + 200) + v21];
              [*(id *)(v16 + 216) popGlyphAtIndex:*(void *)(v16 + 200) + v22];
              int16x8_t v76 = *(void **)(v16 + 216);
              uint64_t v77 = *(void *)(v16 + 200) + v22 + 1;
LABEL_136:
              [v76 popGlyphAtIndex:v77];
              [*(id *)(v16 + 216) popGlyphAtIndex:*(void *)(v16 + 200) + v21];
              uint64_t v72 = *(void *)(v16 + 200);
              uint64_t v21 = v75;
              goto LABEL_141;
            case 15:
              [*(id *)(v16 + 216) pushGlyphAtIndex:*(void *)(v16 + 200) + v22];
              [*(id *)(v16 + 216) pushGlyphAtIndex:*(void *)(v16 + 200) + v22 + 1];
              uint64_t v78 = v21 - 1;
              [*(id *)(v16 + 216) pushGlyphAtIndex:*(void *)(v16 + 200) + v21 - 1];
              [*(id *)(v16 + 216) pushGlyphAtIndex:*(void *)(v16 + 200) + v21];
              [*(id *)(v16 + 216) popGlyphAtIndex:*(void *)(v16 + 200) + v22];
              unint64_t v79 = *(void **)(v16 + 216);
              uint64_t v80 = *(void *)(v16 + 200) + v22 + 1;
LABEL_138:
              [v79 popGlyphAtIndex:v80];
              uint64_t v73 = *(void **)(v16 + 216);
              uint64_t v74 = *(void *)(v16 + 200) + v78;
LABEL_139:
              [v73 popGlyphAtIndex:v74];
              goto LABEL_140;
            default:
              goto LABEL_142;
          }
        }
      }
      return result;
  }
}

void TAATMorphSubtable::push(TRunGlue *a1, void *a2, uint64_t a3)
{
  __int16 GlyphID = TRunGlue::GetGlyphID(a1, a3);
  double Advance = TRunGlue::GetAdvance(a1, a3);
  uint64_t v9 = v8;
  int GlyphProps = TRunGlue::GetGlyphProps(a1, a3);
  Origiuint64_t n = TRunGlue::GetOrigin(a1, a3);
  uint64_t v13 = v12;
  StringIndedouble x = TRunGlue::GetStringIndex(a1, a3);
  uint64_t v15 = (char *)a2[2];
  uint64_t v16 = (char *)a2[1];
  unint64_t v17 = (v15 - v16) >> 3;
  if (v15 == v16) {
    uint64_t v18 = 0;
  }
  else {
    uint64_t v18 = 73 * v17 - 1;
  }
  unint64_t v19 = a2[4];
  unint64_t v20 = a2[5] + v19;
  if (v18 == v20)
  {
    if (v19 >= 0x49)
    {
      a2[4] = v19 - 73;
      uint64_t v23 = *(void *)v16;
      uint64_t v21 = v16 + 8;
      uint64_t v22 = v23;
      a2[1] = v21;
      if (v15 == (char *)a2[3])
      {
        uint64_t v24 = (uint64_t)&v21[-*a2];
        if ((unint64_t)v21 <= *a2)
        {
          if (v15 == (char *)*a2) {
            unint64_t v51 = 1;
          }
          else {
            unint64_t v51 = (uint64_t)&v15[-*a2] >> 2;
          }
          uint64_t v52 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<TAATMorphSubtable::SimpleGlyphEntry *>>(v51);
          uint64_t v54 = &v52[8 * (v51 >> 2)];
          unsigned int v55 = (uint64_t *)a2[1];
          uint64_t v15 = v54;
          uint64_t v56 = a2[2] - (void)v55;
          if (v56)
          {
            uint64_t v15 = &v54[v56 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v57 = 8 * (v56 >> 3);
            uint64_t v58 = &v52[8 * (v51 >> 2)];
            do
            {
              uint64_t v59 = *v55++;
              *(void *)uint64_t v58 = v59;
              v58 += 8;
              v57 -= 8;
            }
            while (v57);
          }
          CGFloat v60 = (char *)*a2;
          *a2 = v52;
          a2[1] = v54;
          a2[2] = v15;
          a2[3] = &v52[8 * v53];
          if (v60)
          {
            operator delete(v60);
            uint64_t v15 = (char *)a2[2];
          }
        }
        else
        {
          int v25 = GlyphProps;
          uint64_t v26 = v24 >> 3;
          BOOL v27 = v24 >> 3 < -1;
          uint64_t v28 = (v24 >> 3) + 2;
          if (v27) {
            uint64_t v29 = v28;
          }
          else {
            uint64_t v29 = v26 + 1;
          }
          uint64_t v30 = -(v29 >> 1);
          uint64_t v31 = v29 >> 1;
          CGFloat v32 = &v21[-8 * v31];
          int64_t v33 = v15 - v21;
          if (v15 != v21)
          {
            memmove(&v21[-8 * v31], v21, v15 - v21);
            uint64_t v15 = (char *)a2[1];
          }
          uint64_t v34 = &v15[8 * v30];
          uint64_t v15 = &v32[v33];
          a2[1] = v34;
          a2[2] = &v32[v33];
          int GlyphProps = v25;
        }
      }
      *(void *)uint64_t v15 = v22;
      a2[2] += 8;
LABEL_91:
      uint64_t v16 = (char *)a2[1];
      unint64_t v20 = a2[5] + a2[4];
      goto LABEL_92;
    }
    int v118 = GlyphProps;
    uint64_t v35 = (char *)a2[3];
    uint64_t v36 = (char *)*a2;
    uint64_t v37 = (uint64_t)&v35[-*a2];
    if (v17 < v37 >> 3)
    {
      uint64_t v38 = operator new(0xFF8uLL);
      uint64_t v39 = v38;
      if (v35 == v15)
      {
        if (v16 == v36)
        {
          if (v15 == v16) {
            unint64_t v61 = 1;
          }
          else {
            unint64_t v61 = (v35 - v16) >> 2;
          }
          uint64_t v62 = 2 * v61;
          char v63 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<TAATMorphSubtable::SimpleGlyphEntry *>>(v61);
          uint64_t v16 = &v63[(v62 + 6) & 0xFFFFFFFFFFFFFFF8];
          uint64_t v65 = (uint64_t *)a2[1];
          uint64_t v66 = v16;
          uint64_t v67 = a2[2] - (void)v65;
          if (v67)
          {
            uint64_t v66 = &v16[v67 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v68 = 8 * (v67 >> 3);
            uint64_t v69 = &v63[(v62 + 6) & 0xFFFFFFFFFFFFFFF8];
            do
            {
              uint64_t v70 = *v65++;
              *(void *)uint64_t v69 = v70;
              v69 += 8;
              v68 -= 8;
            }
            while (v68);
          }
          int v71 = (char *)*a2;
          *a2 = v63;
          a2[1] = v16;
          a2[2] = v66;
          a2[3] = &v63[8 * v64];
          if (v71)
          {
            operator delete(v71);
            uint64_t v16 = (char *)a2[1];
          }
        }
        *((void *)v16 - 1) = v39;
        uint64_t v72 = (char *)a2[1];
        uint64_t v73 = (char *)a2[2];
        a2[1] = v72 - 8;
        uint64_t v74 = *((void *)v72 - 1);
        a2[1] = v72;
        if (v73 == (char *)a2[3])
        {
          uint64_t v75 = (uint64_t)&v72[-*a2];
          if ((unint64_t)v72 <= *a2)
          {
            if (v73 == (char *)*a2) {
              unint64_t v106 = 1;
            }
            else {
              unint64_t v106 = (uint64_t)&v73[-*a2] >> 2;
            }
            CFRange v107 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<TAATMorphSubtable::SimpleGlyphEntry *>>(v106);
            CFRange v109 = &v107[8 * (v106 >> 2)];
            CFRange v110 = (uint64_t *)a2[1];
            uint64_t v73 = v109;
            uint64_t v111 = a2[2] - (void)v110;
            if (v111)
            {
              uint64_t v73 = &v109[v111 & 0xFFFFFFFFFFFFFFF8];
              uint64_t v112 = 8 * (v111 >> 3);
              uint64_t v113 = &v107[8 * (v106 >> 2)];
              do
              {
                uint64_t v114 = *v110++;
                *(void *)uint64_t v113 = v114;
                v113 += 8;
                v112 -= 8;
              }
              while (v112);
            }
            unint64_t v115 = (char *)*a2;
            *a2 = v107;
            a2[1] = v109;
            a2[2] = v73;
            a2[3] = &v107[8 * v108];
            if (v115)
            {
              operator delete(v115);
              uint64_t v73 = (char *)a2[2];
            }
          }
          else
          {
            uint64_t v76 = v75 >> 3;
            BOOL v27 = v75 >> 3 < -1;
            uint64_t v77 = (v75 >> 3) + 2;
            if (v27) {
              uint64_t v78 = v77;
            }
            else {
              uint64_t v78 = v76 + 1;
            }
            uint64_t v79 = -(v78 >> 1);
            uint64_t v80 = v78 >> 1;
            uint64_t v81 = &v72[-8 * v80];
            int64_t v82 = v73 - v72;
            if (v73 != v72)
            {
              memmove(&v72[-8 * v80], v72, v73 - v72);
              uint64_t v72 = (char *)a2[1];
            }
            uint64_t v73 = &v81[v82];
            a2[1] = &v72[8 * v79];
            a2[2] = &v81[v82];
          }
        }
        *(void *)uint64_t v73 = v74;
      }
      else
      {
        *(void *)uint64_t v15 = v38;
      }
      a2[2] += 8;
      int GlyphProps = v118;
      goto LABEL_91;
    }
    __int16 v117 = GlyphID;
    uint64_t v40 = v37 >> 2;
    if (v35 == v36) {
      unint64_t v41 = 1;
    }
    else {
      unint64_t v41 = v40;
    }
    int v42 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<TAATMorphSubtable::SimpleGlyphEntry *>>(v41);
    uint64_t v44 = v43;
    unint64_t v45 = &v42[8 * v17];
    char v46 = &v42[8 * v43];
    uint64_t v47 = operator new(0xFF8uLL);
    if (v17 == v44)
    {
      uint64_t v48 = 8 * v17;
      if (v15 - v16 < 1)
      {
        BOOL v83 = v47;
        uint64_t v84 = v48 >> 2;
        if (v15 == v16) {
          unint64_t v85 = 1;
        }
        else {
          unint64_t v85 = v84;
        }
        long long v86 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<TAATMorphSubtable::SimpleGlyphEntry *>>(v85);
        unint64_t v45 = &v86[8 * (v85 >> 2)];
        char v46 = &v86[8 * v87];
        if (v42) {
          operator delete(v42);
        }
        int v42 = v86;
        uint64_t v47 = v83;
      }
      else
      {
        uint64_t v49 = v48 >> 3;
        if (v49 >= -1) {
          unint64_t v50 = v49 + 1;
        }
        else {
          unint64_t v50 = v49 + 2;
        }
        v45 -= 8 * (v50 >> 1);
      }
    }
    *(void *)unint64_t v45 = v47;
    uint64_t v88 = v45 + 8;
    uint64_t v89 = a2[2];
    if (v89 == a2[1])
    {
      CFRange v104 = v45;
      uint64_t v90 = v45 + 8;
LABEL_79:
      CFRange v105 = (char *)*a2;
      *a2 = v42;
      a2[1] = v104;
      a2[2] = v90;
      a2[3] = v46;
      __int16 GlyphID = v117;
      int GlyphProps = v118;
      if (v105) {
        operator delete(v105);
      }
      goto LABEL_91;
    }
    while (1)
    {
      if (v45 == v42)
      {
        if (v88 < v46)
        {
          uint64_t v92 = (v46 - v88) >> 3;
          if (v92 >= -1) {
            unint64_t v93 = v92 + 1;
          }
          else {
            unint64_t v93 = v92 + 2;
          }
          uint64_t v90 = &v88[8 * (v93 >> 1)];
          CFRange v91 = &v45[8 * (v93 >> 1)];
          if (v88 == v45) {
            unint64_t v45 = v88;
          }
          else {
            memmove(&v45[8 * (v93 >> 1)], v45, v88 - v45);
          }
          goto LABEL_75;
        }
        if (v46 == v45) {
          unint64_t v94 = 1;
        }
        else {
          unint64_t v94 = (v46 - v45) >> 2;
        }
        uint64_t v95 = 2 * v94;
        CFRange v96 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<TAATMorphSubtable::SimpleGlyphEntry *>>(v94);
        int v42 = v96;
        CFRange v91 = &v96[(v95 + 6) & 0xFFFFFFFFFFFFFFF8];
        uint64_t v90 = v91;
        uint64_t v98 = v88 - v45;
        if (v88 != v45)
        {
          uint64_t v90 = &v91[v98 & 0xFFFFFFFFFFFFFFF8];
          uint64_t v99 = 8 * (v98 >> 3);
          CFRange v100 = v91;
          CFRange v101 = v45;
          do
          {
            uint64_t v102 = *(void *)v101;
            v101 += 8;
            *(void *)CFRange v100 = v102;
            v100 += 8;
            v99 -= 8;
          }
          while (v99);
        }
        char v46 = &v96[8 * v97];
        operator delete(v45);
      }
      else
      {
        uint64_t v90 = v88;
        CFRange v91 = v45;
      }
      unint64_t v45 = v42;
LABEL_75:
      int v42 = v45;
      uint64_t v103 = *(void *)(v89 - 8);
      v89 -= 8;
      *((void *)v91 - 1) = v103;
      CFRange v104 = v91 - 8;
      uint64_t v88 = v90;
      unint64_t v45 = v104;
      if (v89 == a2[1]) {
        goto LABEL_79;
      }
    }
  }
LABEL_92:
  unint64_t v116 = *(void *)&v16[8 * (v20 / 0x49)] + 56 * (v20 % 0x49);
  *(_WORD *)unint64_t v116 = GlyphID;
  *(_DWORD *)(v116 + 2) = -1431655766;
  *(_WORD *)(v116 + 6) = -21846;
  *(double *)(v116 + 8) = Advance;
  *(void *)(v116 + 16) = v9;
  *(_DWORD *)(v116 + 24) = GlyphProps;
  *(_DWORD *)(v116 + 28) = -1431655766;
  *(double *)(v116 + 32) = Origin;
  *(void *)(v116 + 40) = v13;
  *(void *)(v116 + 48) = StringIndex;
  ++a2[5];
}

void *TAATMorphSubtable::pop(TRunGlue *this, void *a2, uint64_t a3)
{
  uint64_t v6 = a2[1];
  uint64_t v5 = a2[2];
  uint64_t v7 = 73 * ((v5 - v6) >> 3) - 1;
  if (v5 == v6) {
    uint64_t v7 = 0;
  }
  uint64_t v8 = a2[5] - 1;
  unint64_t v9 = v8 + a2[4];
  uint64_t v10 = (unsigned __int16 *)(*(void *)(v6 + 8 * (v9 / 0x49)) + 56 * (v9 % 0x49));
  uint64_t v11 = *v10;
  CGFloat v12 = *((double *)v10 + 1);
  CGFloat v13 = *((double *)v10 + 2);
  uint64_t v14 = *((unsigned int *)v10 + 6);
  CGFloat v15 = *((double *)v10 + 4);
  CGFloat v16 = *((double *)v10 + 5);
  uint64_t v17 = *((void *)v10 + 6);
  a2[5] = v8;
  if (v7 - v9 >= 0x92)
  {
    operator delete(*(void **)(v5 - 8));
    a2[2] -= 8;
  }
  TRunGlue::SetGlyphID<true>(this, a3, v11);
  v21.CGFloat width = v12;
  v21.CGFloat height = v13;
  TRunGlue::SetAdvance(this, a3, v21);
  TRunGlue::SetGlyphProps(this, a3, v14);
  v22.double x = v15;
  v22.CGFloat y = v16;
  TRunGlue::SetOrigin(this, a3, v22);

  return TRunGlue::SetStringIndex(this, a3, v17);
}

double TAATMorphSubtable::CopyFromStorage(TRunGlue *a1, uint64_t a2, _OWORD *a3)
{
  uint64_t v13 = a2;
  uint64_t v5 = TRunGlue::PhysicalRunIndexWithGlyphIndex(a1, a2, &v13);
  if (v5 == -1) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = *(void *)(*(void *)(*(void *)(*(void *)a1 + 16) + 8 * v5) + 48);
  }
  TStorageRange::GetGlyphEntry((TStorageRange *)(v6 + 192), v13, (uint64_t)v10);
  long long v7 = v10[1];
  *a3 = v10[0];
  a3[1] = v7;
  double result = *(double *)&v11;
  long long v9 = v12;
  a3[2] = v11;
  a3[3] = v9;
  return result;
}

TRunGlue *TAATMorphSubtable::MoveInStorage(TRunGlue *this, TRunGlue *a2, CFRange a3)
{
  CFIndex length = a3.length;
  locatiouint64_t n = a3.location;
  uint64_t v5 = a2;
  uint64_t v6 = this;
  v9[0] = xmmword_184B87D98;
  v9[1] = unk_184B87DA8;
  v9[2] = xmmword_184B87DB8;
  v9[3] = unk_184B87DC8;
  if (a3.length - (uint64_t)a2 >= (unint64_t)a3.location)
  {
    if (a3.location >= 1)
    {
      do
      {
        TAATMorphSubtable::CopyFromStorage(v6, (uint64_t)v5, v9);
        this = (TRunGlue *)TAATMorphSubtable::CopyToStorage(v6, length++, (unsigned __int16 *)v9);
        uint64_t v5 = (TRunGlue *)((char *)v5 + 1);
        --location;
      }
      while (location);
    }
  }
  else
  {
    CFIndex v7 = a3.location - 1;
    if (a3.location >= 1)
    {
      do
      {
        TAATMorphSubtable::CopyFromStorage(v6, (uint64_t)v5 + v7, v9);
        this = (TRunGlue *)TAATMorphSubtable::CopyToStorage(v6, length + v7, (unsigned __int16 *)v9);
        unint64_t v8 = v7-- + 1;
      }
      while (v8 > 1);
    }
  }
  return this;
}

uint64_t TAATMorphSubtable::CopyToStorage(TRunGlue *a1, uint64_t a2, unsigned __int16 *a3)
{
  uint64_t v9 = a2;
  uint64_t v5 = TRunGlue::PhysicalRunIndexWithGlyphIndex(a1, a2, &v9);
  if (v5 == -1) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = *(void *)(*(void *)(*(void *)(*(void *)a1 + 16) + 8 * v5) + 48);
  }
  uint64_t v7 = v9;

  return TStorageRange::SetGlyphEntry(v6 + 192, v7, a3);
}

uint64_t TStorageRange::GetGlyphEntry@<X0>(TStorageRange *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(_OWORD *)a3 = xmmword_184B87D98;
  *(_OWORD *)(a3 + 16) = unk_184B87DA8;
  uint64_t v6 = (void *)*((void *)this + 3);
  uint64_t v7 = *((void *)this + 1);
  *(_WORD *)a3 = *(_WORD *)(v6[2] + 2 * v7 + 2 * a2);
  uint64_t v8 = v6[4];
  if (v8 || (uint64_t v11 = v6[3]) == 0)
  {
    uint64_t v9 = (void *)(v8 + 16 * v7 + 16 * a2);
    uint64_t v10 = v9[1];
  }
  else
  {
    uint64_t v9 = (void *)(v11 + 8 * v7 + 8 * a2);
    uint64_t v10 = 0;
  }
  *(void *)(a3 + 8) = *v9;
  *(void *)(a3 + 16) = v10;
  uint64_t v12 = v6[6];
  *(_DWORD *)(a3 + 24) = *(_DWORD *)(v6[5] + 4 * v7 + 4 * a2);
  *(void *)(a3 + 32) = *(void *)(v12 + 8 * v7 + 8 * a2);
  uint64_t result = [v6 attachmentCountAtIndex:v7 + a2];
  *(void *)(a3 + 40) = result;
  if ((*((unsigned char *)this + 33) & 0x10) != 0)
  {
    uint64_t result = [*((id *)this + 3) originAtIndex:*((void *)this + 1) + a2];
  }
  else
  {
    uint64_t v14 = *MEMORY[0x1E4F1DAD8];
    uint64_t v15 = *(void *)(MEMORY[0x1E4F1DAD8] + 8);
  }
  *(void *)(a3 + 48) = v14;
  *(void *)(a3 + 56) = v15;
  return result;
}

uint64_t TStorageRange::SetGlyphEntry(uint64_t a1, uint64_t a2, unsigned __int16 *a3)
{
  int v6 = *a3;
  [*(id *)(a1 + 24) setGlyph:*a3 atIndex:*(void *)(a1 + 8) + a2];
  char v7 = *(unsigned char *)(a1 + 33);
  if (v6 == 0xFFFF && (v7 & 2) != 0) {
    *(unsigned char *)(a1 + 33) = v7 | 8;
  }
  TStorageRange::SetAdvance((TStorageRange *)a1, a2, *(CGSize *)(a3 + 4));
  [*(id *)(a1 + 24) setProps:*((unsigned int *)a3 + 6) atIndex:*(void *)(a1 + 8) + a2];
  [*(id *)(a1 + 24) setStringIndex:*((void *)a3 + 4) atIndex:*(void *)(a1 + 8) + a2];
  [*(id *)(a1 + 24) setAttachmentCount:*((void *)a3 + 5) atIndex:*(void *)(a1 + 8) + a2];
  double v9 = *((double *)a3 + 6);
  double v10 = *((double *)a3 + 7);
  uint64_t result = objc_msgSend(*(id *)(a1 + 24), "setOrigin:atIndex:", *(void *)(a1 + 8) + a2, v9, v10);
  if (v9 != *MEMORY[0x1E4F1DAD8] || v10 != *(double *)(MEMORY[0x1E4F1DAD8] + 8)) {
    *(unsigned char *)(a1 + 33) |= 0x10u;
  }
  return result;
}

void *TRunGlue::ClearGlyphCombiningMark(void *this, uint64_t a2)
{
  uint64_t v3 = this;
  if (this[19])
  {
    TRunGlue::FocusOnIndex((TRunGlue *)this, a2);
    uint64_t v4 = v3[19];
    uint64_t v5 = a2 - v3[20];
    this = *(void **)(v4 + 216);
    uint64_t v6 = *(void *)(v4 + 200);
    int v7 = *(_DWORD *)(this[5] + 4 * v6 + 4 * v5);
    if ((v7 & 0x40) != 0)
    {
      return (void *)[this setProps:v7 & 0xFFFFEFBF | 0x1000 atIndex:v6 + v5];
    }
  }
  else
  {
    uint64_t v8 = this[65];
    if (v8)
    {
      uint64_t v9 = this[20] + a2;
      int v10 = *(_DWORD *)(v8 + 4 * v9);
      if ((v10 & 0x40) != 0) {
        *(_DWORD *)(v8 + 4 * v9) = v10 & 0xFFFFEFBF | 0x1000;
      }
    }
  }
  return this;
}

double TRunGlue::GetOrigin(TRunGlue *this, uint64_t a2)
{
  if (*((void *)this + 19))
  {
    TRunGlue::FocusOnIndex(this, a2);
    uint64_t v4 = *((void *)this + 19);
    if ((*(unsigned char *)(v4 + 225) & 0x10) != 0)
    {
      [*(id *)(v4 + 216) originAtIndex:a2 - *((void *)this + 20) + *(void *)(v4 + 200)];
      return result;
    }
    goto LABEL_6;
  }
  uint64_t v6 = *((void *)this + 24);
  if (!v6)
  {
LABEL_6:
    uint64_t v7 = MEMORY[0x1E4F1DAD8];
    return *(double *)v7;
  }
  uint64_t v7 = v6 + 16 * (*((void *)this + 20) + a2);
  return *(double *)v7;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<TAATMorphSubtable::SimpleGlyphEntry *>>(unint64_t a1)
{
  if (a1 >> 61) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(8 * a1);
}

void *TRunGlue::MoveGlyphs(TRunGlue *this, CFRange a2, uint64_t a3)
{
  CFIndex length = a2.length;
  locatiouint64_t n = a2.location;
  if (*((void *)this + 19))
  {
    TRunGlue::FocusOnIndex(this, a2.location);
    uint64_t v7 = *((void *)this + 19);
    uint64_t v8 = *((void *)this + 20);
    uint64_t v9 = *(void *)(v7 + 200);
    int v10 = *(void **)(v7 + 216);
    return objc_msgSend(v10, "moveGlyphsFromRange:toIndex:", location - v8 + v9, length, a3 - v8 + v9);
  }
  else
  {
    uint64_t v12 = *((void *)this + 20);
    CFIndex v13 = v12 + a2.location;
    uint64_t v14 = v12 + a3;
    memmove((void *)(*((void *)this + 22) + 2 * (v12 + a3)), (const void *)(*((void *)this + 22) + 2 * (v12 + a2.location)), 2 * a2.length);
    memmove((void *)(*((void *)this + 23) + 16 * v14), (const void *)(*((void *)this + 23) + 16 * v13), 16 * length);
    uint64_t v15 = *((void *)this + 65);
    if (!v15)
    {
      TRunGlue::InitPropertiesFromDeletedGlyphs(this);
      uint64_t v15 = *((void *)this + 65);
    }
    double result = memmove((void *)(v15 + 4 * v14), (const void *)(v15 + 4 * v13), 4 * length);
    uint64_t v16 = *((void *)this + 24);
    if (v16) {
      double result = memmove((void *)(v16 + 16 * v14), (const void *)(v16 + 16 * v13), 16 * length);
    }
    uint64_t v17 = *((void *)this + 66);
    if (v17)
    {
      return memmove((void *)(v17 + 8 * v14), (const void *)(v17 + 8 * v13), 8 * length);
    }
  }
  return result;
}

void *TRunGlue::SetOrigin(void *this, uint64_t a2, CGPoint a3)
{
  double y = a3.y;
  double x = a3.x;
  uint64_t v6 = this;
  if (this[19])
  {
    TRunGlue::FocusOnIndex((TRunGlue *)this, a2);
    uint64_t v7 = v6[19];
    objc_msgSend(*(id *)(v7 + 216), "setOrigin:atIndex:", a2 - v6[20] + *(void *)(v7 + 200), x, y);
    if (x != *MEMORY[0x1E4F1DAD8] || y != *(double *)(MEMORY[0x1E4F1DAD8] + 8)) {
      *(unsigned char *)(v7 + 225) |= 0x10u;
    }
    uint64_t v9 = (TRun *)v6[19];
    return (void *)TRun::NoteCrossStreamPosition(v9, y);
  }
  else
  {
    uint64_t v10 = this[24];
    if (v10) {
      *(CGPoint *)(v10 + 16 * (this[20] + a2)) = a3;
    }
  }
  return this;
}

void *TRunGlue::SetStringIndex(void *this, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = this;
  if (this[19])
  {
    this = (void *)TRunGlue::FocusOnIndex((TRunGlue *)this, a2);
    uint64_t v6 = v5[19];
    if (v6)
    {
      this = (void *)[*(id *)(v6 + 216) setStringIndex:a3 atIndex:a2 - v5[20] + *(void *)(v6 + 200)];
      uint64_t v8 = v5[19];
      uint64_t v9 = *(void *)(v8 + 8);
      uint64_t v10 = *(void *)(v8 + 16) + v9;
      if (v9 > a3 || v10 <= a3)
      {
        this = (void *)TRunGlue::ActualCharRangeForStorage((TRunGlue *)(v6 + 192), v7);
        uint64_t v12 = v5[19];
        *(void *)(v12 + 8) = this;
        *(void *)(v12 + 16) = v13;
      }
    }
  }
  else
  {
    uint64_t v14 = this[66];
    if (v14) {
      *(void *)(v14 + 8 * (this[20] + a2)) = a3;
    }
  }
  return this;
}

uint64_t TRunGlue::ActualCharRangeForStorage(TRunGlue *this, const TStorageRange *a2)
{
  uint64_t v3 = (void *)(*(void *)(*((void *)this + 3) + 48) + 8 * *((void *)this + 1));
  uint64_t v4 = *std::__minmax_element_impl[abi:nn180100]<long const*,long const*,std::__identity,std::__less<void,void>>(v3, &v3[*((void *)this + 2)]);
  [*((id *)this + 3) attachmentCountAtIndex:*((void *)this + 1) + ((v5 - (uint64_t)v3) >> 3)];
  return v4;
}

void *std::__minmax_element_impl[abi:nn180100]<long const*,long const*,std::__identity,std::__less<void,void>>(void *result, void *a2)
{
  unint64_t v2 = result;
  if (result != a2 && result + 1 != a2)
  {
    uint64_t v5 = *result;
    uint64_t v4 = result[1];
    if (v4 < *result) {
      ++result;
    }
    uint64_t v6 = v4 >= *v2 ? v2 + 1 : v2;
    uint64_t v7 = v2 + 2;
    if (v7 != a2)
    {
      if (v4 <= v5) {
        uint64_t v8 = v5;
      }
      else {
        uint64_t v8 = v4;
      }
      if (v4 >= v5) {
        uint64_t v4 = v5;
      }
      while (v7 + 1 != a2)
      {
        uint64_t v10 = *v7;
        uint64_t v9 = v7[1];
        if (v9 >= *v7)
        {
          if (v10 < v4)
          {
            uint64_t v4 = *v7;
            double result = v7;
          }
          BOOL v11 = v9 < v8;
          if (v9 > v8) {
            uint64_t v8 = v7[1];
          }
          if (!v11) {
            uint64_t v6 = v7 + 1;
          }
        }
        else
        {
          uint64_t v4 = *result;
          if (v9 < *result)
          {
            uint64_t v4 = v7[1];
            double result = v7 + 1;
          }
          uint64_t v8 = *v6;
          if (v10 > *v6) {
            uint64_t v8 = *v7;
          }
          if (v10 >= *v6) {
            uint64_t v6 = v7;
          }
        }
        v7 += 2;
        if (v7 == a2) {
          return result;
        }
      }
      if (*v7 < *result) {
        return v7;
      }
    }
  }
  return result;
}

void TRun::TRun(TRun *this, CFRange a2, _CTGlyphStorage *a3, const TAttributes *a4, const __CTFont *a5)
{
  CFIndex length = a2.length;
  locatiouint64_t n = a2.location;
  *(void *)this = &unk_1ED05F378;
  *((void *)this + 1) = a2.location;
  *((void *)this + 4) = 0;
  *((void *)this + 2) = a2.length;
  *((void *)this + 3) = 0;
  TAttributes::TAttributes((TRun *)((char *)this + 40), a4, a5);
  v9.locatiouint64_t n = location;
  v9.CFIndex length = length;
  TStorageRange::TStorageRange((TRun *)((char *)this + 192), a3, v9);
  *((void *)this + 34) = 0;
  *((void *)this + 35) = 0;
  *((void *)this + 32) = 0;
  *((void *)this + 33) = -1;
  *((_OWORD *)this + 18) = *MEMORY[0x1E4F1DB30];
  *((_DWORD *)this + 76) = -1;
  *((void *)this + 39) = 0;
}

void std::vector<CGSize>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 4;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 16 * a2;
    }
  }
  else
  {
    std::vector<CGSize>::__append((void **)a1, a2 - v2);
  }
}

uint64_t TRun::operator==(uint64_t a1, uint64_t a2)
{
  BOOL v2 = *(void *)(a1 + 8) == *(void *)(a2 + 8) && *(void *)(a1 + 16) == *(void *)(a2 + 16);
  if (!v2
    || *(_DWORD *)(a1 + 256) != *(_DWORD *)(a2 + 256)
    || *(unsigned __int16 *)(a1 + 178) != *(unsigned __int16 *)(a2 + 178))
  {
    return 0;
  }
  Dictionardouble y = (const void *)TAttributes::GetDictionary((atomic_ullong *)(a1 + 40));
  unint64_t v6 = TAttributes::GetDictionary((atomic_ullong *)(a2 + 40));
  if (Dictionary == (const void *)v6
    || (uint64_t v7 = (const void *)v6, result = 0, Dictionary) && v7 && (result = CFEqual(Dictionary, v7), result))
  {
    uint64_t result = TStorageRange::operator==(a1 + 192, a2 + 192);
    if (result)
    {
      CFRange v9 = (double *)MEMORY[0x1E4F1DB30];
      uint64_t v10 = *(double **)(a1 + 312);
      if (!v10) {
        uint64_t v10 = (double *)MEMORY[0x1E4F1DB30];
      }
      if (*(void *)(a2 + 312)) {
        CFRange v9 = *(double **)(a2 + 312);
      }
      if (*v10 == *v9 && v10[1] == v9[1]) {
        return *(_DWORD *)(a1 + 304) == *(_DWORD *)(a2 + 304);
      }
      return 0;
    }
  }
  return result;
}

__CFString *TRun::DebugDescription(TRun *this)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  uint64_t v4 = (__CFString *)CFStringCreateWithFormat(v2, 0, @"(%ld, %ld)", *((void *)this + 1), *((void *)this + 2));
  CFStringAppendFormat(Mutable, 0, @"string range = %@, string = ", v4);

  uint64_t v5 = (TCharStream **)*((void *)this + 34);
  if (v5 && *v5)
  {
    unint64_t v6 = TCharStream::DebugDescriptionForRange(*v5, *(CFRange *)((char *)this + 8));
    CFStringAppendFormat(Mutable, 0, @"\"%@\"", v6);
  }
  else
  {
    CFStringAppend(Mutable, @"<not found>");
  }
  uint64_t v7 = (__CFString *)TAttributes::DebugDescription((atomic_ullong *)this + 5);
  CFStringAppendFormat(Mutable, 0, @", attributes = %@", v7);

  unint64_t explicit = (TFont **)atomic_load_explicit((atomic_ullong *volatile)this + 7, memory_order_acquire);
  CFRange v9 = (CGSize *)MEMORY[0x1E4F1DB30];
  if (*((void *)this + 39)) {
    CFRange v9 = (CGSize *)*((void *)this + 39);
  }
  uint64_t v10 = TStorageRange::DebugDescriptionWithInfoFromRun((TRun *)((char *)this + 192), explicit, *v9, *((void *)this + 33));
  CFStringAppendFormat(Mutable, 0, @", {%@}", v10);

  return Mutable;
}

id TRun::CopyDescriptionDictionary(TRun *this, char a2)
{
  v64[2] = *MEMORY[0x1E4F143B8];
  id v4 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
  uint64_t v5 = *((void *)this + 26);
  objc_msgSend(v4, "setObject:forKey:", objc_msgSend(NSNumber, "numberWithInteger:", v5), @"numGlyphs");
  unint64_t v6 = (TCharStream **)*((void *)this + 34);
  if (v6 && *v6)
  {
    uint64_t v7 = TCharStream::DebugDescriptionForRange(*v6, *(CFRange *)((char *)this + 8));
    if (v7) {
      [v4 setObject:v7 forKey:@"string"];
    }
  }
  uint64_t v8 = (unsigned __int16 *)(*(void *)(*((void *)this + 27) + 16) + 2 * *((void *)this + 25));
  uint64_t v9 = [MEMORY[0x1E4F1CA48] array];
  if ((a2 & 1) == 0)
  {
    uint64_t v10 = (void *)v9;
    char v11 = a2;
    uint64_t v12 = v4;
    if (v5 >= 1)
    {
      uint64_t v13 = v8;
      uint64_t v14 = v5;
      do
      {
        unsigned int v15 = *v13++;
        objc_msgSend(v10, "addObject:", objc_msgSend(NSNumber, "numberWithUnsignedShort:", v15));
        --v14;
      }
      while (v14);
    }
    id v4 = v12;
    [v12 setObject:v10 forKey:@"glyphs"];
    a2 = v11;
  }
  unint64_t explicit = (const __CTFont *)atomic_load_explicit((atomic_ullong *volatile)this + 7, memory_order_acquire);
  if (explicit)
  {
    uint64_t v17 = (void *)CTFontCopyAttribute(explicit, @"NSFontNameAttribute");
    [v4 setObject:v17 forKey:@"fontName"];
    uint64_t v18 = (double *)*((void *)explicit + 5);
    objc_msgSend(v4, "setObject:forKey:", objc_msgSend(NSNumber, "numberWithDouble:", v18[2]), @"fontSize");
    if (a2)
    {
      uint64_t v54 = v4;
      unint64_t v19 = (void *)[MEMORY[0x1E4F1CA48] array];
      if (v5 >= 1)
      {
        uint64_t v20 = v5;
        do
        {
          int v22 = *v8++;
          CGGlyph v21 = v22;
          if (v22 == 0xFFFF)
          {
            [v19 addObject:@"DELETED"];
          }
          else
          {
            id v56 = (id)0xAAAAAAAAAAAAAAAALL;
            TFont::CopyNameForGlyph((TFont *)v18, v21, (CFStringRef *)&v56);
            if (atomic_load_explicit((atomic_ullong *volatile)&v56, memory_order_acquire))
            {
              uint64_t v23 = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&v56, memory_order_acquire);
              uint64_t v24 = v19;
            }
            else
            {
              uint64_t v24 = v19;
              uint64_t v23 = @"** No Glyph Name **";
            }
            [v24 addObject:v23];
          }
          --v20;
        }
        while (v20);
      }
      id v4 = v54;
      [v54 setObject:v19 forKey:@"glyphNames"];
    }
  }
  if ((a2 & 2) != 0)
  {
    int v25 = (double *)*((void *)this + 39);
    uint64_t v26 = (double *)MEMORY[0x1E4F1DB30];
    if (!v25) {
      int v25 = (double *)MEMORY[0x1E4F1DB30];
    }
    double v27 = *v25;
    double v28 = v25[1];
    v63[0] = @"width";
    *(float *)&double v27 = v27;
    v64[0] = [NSNumber numberWithFloat:v27];
    v63[1] = @"height";
    *(float *)&double v29 = v28;
    v64[1] = [NSNumber numberWithFloat:v29];
    objc_msgSend(v4, "setObject:forKey:", objc_msgSend(MEMORY[0x1E4F1C9E8], "dictionaryWithObjects:forKeys:count:", v64, v63, 2), @"initialAdvance");
    while (1)
    {
      unint64_t v30 = atomic_load_explicit((atomic_ullong *volatile)this + 35, memory_order_acquire);
      if (v30) {
        break;
      }
      uint64_t v31 = *((void *)this + 34);
      if (!v31)
      {
        unint64_t v30 = 0;
        break;
      }
      TLine::CachePositions(v31);
    }
    v61[0] = @"width";
    double v32 = *((double *)this + 36);
    *(float *)&double v32 = v32;
    uint64_t v33 = [NSNumber numberWithFloat:v32];
    v61[1] = @"height";
    v62[0] = v33;
    double v34 = *((double *)this + 37);
    *(float *)&double v34 = v34;
    v62[1] = [NSNumber numberWithFloat:v34];
    objc_msgSend(v4, "setObject:forKey:", objc_msgSend(MEMORY[0x1E4F1C9E8], "dictionaryWithObjects:forKeys:count:", v62, v61, 2), @"cachedOffset");
    uint64_t v35 = (double *)*((void *)this + 39);
    if (!v35) {
      uint64_t v35 = v26;
    }
    double v36 = *((double *)this + 24) + *v35;
    *(float *)&double v36 = v36;
    objc_msgSend(v4, "setObject:forKey:", objc_msgSend(NSNumber, "numberWithFloat:", v36), @"width");
    uint64_t v37 = (void *)[MEMORY[0x1E4F1CA48] array];
    unsigned int v55 = (void *)[MEMORY[0x1E4F1CA48] array];
    uint64_t v38 = *((void *)this + 27);
    uint64_t v39 = *(void *)(v38 + 32);
    if (v39 || (uint64_t v42 = *(void *)(v38 + 24)) == 0)
    {
      int v40 = 0;
      unint64_t v41 = (double *)(v39 + 16 * *((void *)this + 25));
    }
    else
    {
      unint64_t v41 = (double *)(v42 + 8 * *((void *)this + 25));
      int v40 = 1;
    }
    if (v5 >= 1)
    {
      uint64_t v43 = (double *)(v30 + 8);
      uint64_t v44 = v41;
      do
      {
        v59[0] = @"x";
        if (v40) {
          unint64_t v45 = v41;
        }
        else {
          unint64_t v45 = v44;
        }
        double v46 = *v45;
        *(float *)&double v46 = *v45;
        uint64_t v47 = [NSNumber numberWithFloat:v46];
        v59[1] = @"y";
        v60[0] = v47;
        double v48 = 0.0;
        if ((v40 & 1) == 0) {
          double v48 = v44[1];
        }
        *(float *)&double v48 = v48;
        v60[1] = [NSNumber numberWithFloat:v48];
        objc_msgSend(v37, "addObject:", objc_msgSend(MEMORY[0x1E4F1C9E8], "dictionaryWithObjects:forKeys:count:", v60, v59, 2));
        v57[0] = @"x";
        double v49 = *(v43 - 1);
        *(float *)&double v49 = v49;
        uint64_t v50 = [NSNumber numberWithFloat:v49];
        v57[1] = @"y";
        v58[0] = v50;
        double v51 = *v43;
        v43 += 2;
        HIDWORD(v52) = HIDWORD(v51);
        *(float *)&double v52 = v51;
        v58[1] = [NSNumber numberWithFloat:v52];
        objc_msgSend(v55, "addObject:", objc_msgSend(MEMORY[0x1E4F1C9E8], "dictionaryWithObjects:forKeys:count:", v58, v57, 2));
        v44 += 2;
        ++v41;
        --v5;
      }
      while (v5);
    }
    [v4 setObject:v37 forKey:@"advances"];
    [v4 setObject:v55 forKey:@"positions"];
  }
  return v4;
}

double TRun::GetBackgroundRect(TRun *this)
{
  uint64_t v2 = *((void *)this + 34);
  if (v2)
  {
    if ((*((unsigned char *)this + 177) & 8) != 0
      && *((void *)this + 2) + *((void *)this + 1) == *(void *)(v2 + 80) + *(void *)(v2 + 72))
    {
      if (*((unsigned char *)this + 224)) {
        (*(void (**)(TRun *))(*(void *)this + 80))(this);
      }
      else {
        TRun::GetRightWhitespaceGlyphCountAndWidth(this);
      }
    }
  }
  else
  {
    (*(void (**)(TRun *))(*(void *)this + 56))(this);
    (*(void (**)(TRun *))(*(void *)this + 64))(this);
    TFont::GetWindowsDescent(*(void *)(atomic_load_explicit((atomic_ullong *volatile)this + 7, memory_order_acquire)
                                       + 40));
  }
  return 0.0;
}

void TRun::DrawRotatedGlyphsAtPositions(TRun *this, CGContextRef c, CFRange a3, CGPoint *a4, unsigned __int8 *a5, double a6)
{
  CFIndex length = a3.length;
  locatiouint64_t n = a3.location;
  if (a6 == 0.0)
  {
    int v16 = *a5;
    uint64_t v17 = (const TAttributes *)*((void *)a5 + 1);
    char v18 = a5[16];
    TRun::DrawGlyphsAtPositionsInternal(this, c, a3, a4, v16, v17, v18);
  }
  else
  {
    TextPositiouint64_t n = CGContextGetTextPosition(c);
    if (*((void *)a5 + 1)) {
      uint64_t v14 = (const TAttributes *)*((void *)a5 + 1);
    }
    else {
      uint64_t v14 = (TRun *)((char *)this + 40);
    }
    char v15 = *((unsigned char *)v14 + 137);
    if (v15)
    {
      v21.locatiouint64_t n = location;
      v21.CFIndex length = length;
      TRun::DrawBackground(this, c, v21, v14, 1);
    }
    CGContextSaveGState(c);
    *(_OWORD *)&v19.double a = xmmword_184B87DE0;
    v19.c = -1.0;
    memset(&v19.d, 0, 24);
    CGContextConcatCTM(c, &v19);
    CGContextSetTextPosition(c, TextPosition.y + TextPosition.x * 0.0 + 0.0 + a6, TextPosition.y * 0.0 - TextPosition.x + 0.0 + a6);
    v22.locatiouint64_t n = location;
    v22.CFIndex length = length;
    TRun::DrawGlyphsAtPositionsInternal(this, c, v22, a4, (v15 & 1) == 0, v14, 0);
    CGContextSetTextPosition(c, TextPosition.x, TextPosition.y);
    CGContextRestoreGState(c);
  }
}

void TRun::CopyPath(atomic_ullong *this@<X0>, void *a2@<X8>)
{
  id Mutable = CGPathCreateMutable();
  uint64_t v3 = *(TFont **)(atomic_load_explicit(this + 7, memory_order_acquire) + 40);
  uint64_t v4 = *(void *)(this[27] + 16);
  atomic_ullong v5 = this[25];
  while (1)
  {
    unint64_t explicit = atomic_load_explicit(this + 35, memory_order_acquire);
    if (explicit) {
      break;
    }
    uint64_t v7 = this[34];
    if (!v7)
    {
      unint64_t explicit = 0;
      break;
    }
    TLine::CachePositions(v7);
  }
  uint64_t v8 = this[26];
  if (v8 >= 1)
  {
    uint64_t v9 = 0;
    atomic_ullong v10 = v4 + 2 * v5;
    do
    {
      id v19 = (id)0xAAAAAAAAAAAAAAAALL;
      TFont::CreatePathForGlyph(v3, 0, *(unsigned __int16 *)(v10 + v9), &v19);
      *(void *)&long long v11 = -1;
      *((void *)&v11 + 1) = -1;
      *(_OWORD *)&m.c = v11;
      *(_OWORD *)&m.tdouble x = v11;
      *(_OWORD *)&m.double a = v11;
      CGAffineTransformMakeTranslation(&m, *(CGFloat *)(explicit + 8 * v9), *(CGFloat *)(explicit + 8 * v9 + 8));
      atomic_ullong v12 = this[39];
      double v13 = 1.0;
      if (v12)
      {
        uint64_t v14 = *(void *)(v12 + 56);
        double v15 = 1.0;
        if (v14 != *(void *)(v12 + 64))
        {
          int v16 = (double *)(v14 + 8 * v9);
          double v15 = *v16;
          double v13 = v16[1];
        }
      }
      else
      {
        double v15 = 1.0;
      }
      m.double a = v15 * m.a;
      m.CGFloat d = v13 * m.d;
      CGPathAddPath((CGMutablePathRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), &m, (CGPathRef)atomic_load_explicit((atomic_ullong *volatile)&v19, memory_order_acquire));

      v9 += 2;
      --v8;
    }
    while (v8);
  }
  *a2 = atomic_exchange((atomic_ullong *volatile)&Mutable, 0);
}

CFIndex TRun::NormalizeRange(TRun *this, CFRange a2, uint64_t *a3)
{
  locatiouint64_t n = a2.location;
  uint64_t v6 = *((void *)this + 1);
  uint64_t v7 = *((void *)this + 2);
  uint64_t v8 = *(void *)(*((void *)this + 27) + 48) + 8 * *((void *)this + 25);
  uint64_t v9 = (v6 - a2.location + v7) & ~((v6 - a2.location + v7) >> 63);
  if (a2.length <= v9)
  {
    uint64_t GlyphIndexForChar = TRun::GetGlyphIndexForCharIndex<false>((uint64_t)this, a2.length + a2.location - 1);
    uint64_t v11 = *(void *)(v8 + 8 * GlyphIndexForChar);
    uint64_t v9 = v11
       - location
       + [*((id *)this + 27) attachmentCountAtIndex:*((void *)this + 25) + GlyphIndexForChar]
       + 1;
  }
  *a3 = v9;
  if (location == *((void *)this + 1)) {
    return location;
  }
  CFIndex v13 = v7 + v6;
  do
  {
    CFIndex v12 = location;
    if (v9-- < 1) {
      break;
    }
    if (location >= v13) {
      break;
    }
    uint64_t v15 = TRun::GetGlyphIndexForCharIndex<false>((uint64_t)this, location++);
  }
  while (v12 != *(void *)(v8 + 8 * v15));
  return v12;
}

uint64_t TRun::GetTrailingBaseChar(TRun *this)
{
  PrevGlyphIndedouble x = *((void *)this + 1) + *((void *)this + 2) - 1;
  uint64_t GlyphIndexForChar = TRun::GetGlyphIndexForCharIndex<false>((uint64_t)this, PrevGlyphIndex);
  uint64_t v3 = *((void *)this + 1);
  while (v3 <= PrevGlyphIndex)
  {
    uint64_t v4 = GlyphIndexForChar;
    atomic_ullong v5 = (void *)*((void *)this + 27);
    uint64_t v6 = *((void *)this + 25);
    if (*(__int16 *)(v5[2] + 2 * v6 + 2 * GlyphIndexForChar) != -1
      && (*(_DWORD *)(v5[5] + 4 * v6 + 4 * GlyphIndexForChar) & 0x20) == 0
      && (*(_DWORD *)(v5[5] + 4 * v6 + 4 * GlyphIndexForChar) & 0x2040) != 0x40
      && (*(_DWORD *)(v5[5] + 4 * v6 + 4 * GlyphIndexForChar) & 0x300) == 0)
    {
      break;
    }
    if (*((int *)this + 64) > 1 || (*((unsigned char *)this + 224) & 1) != 0)
    {
      PrevGlyphIndedouble x = TRun::FindPrevGlyphIndex(this, PrevGlyphIndex, &GlyphIndexForChar);
      uint64_t v3 = *((void *)this + 1);
    }
    else
    {
      --GlyphIndexForChar;
      if (v4 <= 0) {
        return v3 - 1;
      }
      PrevGlyphIndedouble x = *(void *)(v5[6] + 8 * v6 + 8 * (v4 - 1));
    }
  }
  return PrevGlyphIndex;
}

uint64_t TRun::GetLeadingUncombinedCharCount(TRun *this)
{
  uint64_t NextChar = *((void *)this + 1);
  uint64_t GlyphIndexForChar = TRun::GetGlyphIndexForCharIndex<false>((uint64_t)this, NextChar);
  uint64_t v3 = *((void *)this + 1);
  uint64_t v4 = *((void *)this + 2) + v3;
  if (NextChar < v4)
  {
    do
    {
      uint64_t v5 = *((void *)this + 27);
      uint64_t v6 = *((void *)this + 25);
      if (*(__int16 *)(*(void *)(v5 + 16) + 2 * v6 + 2 * GlyphIndexForChar) != -1
        && (*(_DWORD *)(*(void *)(v5 + 40) + 4 * v6 + 4 * GlyphIndexForChar) & 0x20) == 0
        && (*(_DWORD *)(*(void *)(v5 + 40) + 4 * v6 + 4 * GlyphIndexForChar) & 0x2040) != 0x40
        && (*(_DWORD *)(*(void *)(v5 + 40) + 4 * v6 + 4 * GlyphIndexForChar) & 0x300) == 0)
      {
        break;
      }
      uint64_t NextChar = TRun::GetNextChar(this, NextChar, &GlyphIndexForChar);
    }
    while (NextChar < v4);
    uint64_t v3 = *((void *)this + 1);
  }
  return NextChar - v3;
}

uint64_t TRun::AppendMappedCharsInRange(uint64_t a1, uint64_t NextChar, uint64_t a3, uint64_t a4)
{
  std::vector<long,TInlineBufferAllocator<long,30ul>>::reserve((char **)a4, a3 + ((uint64_t)(*(void *)(a4 + 8) - *(void *)a4) >> 3));
  uint64_t v8 = NextChar + a3;
  uint64_t GlyphIndexForChar = TRun::GetGlyphIndexForCharIndex<false>(a1, NextChar);
  uint64_t v9 = *(void *)(*(void *)(a1 + 216) + 48) + 8 * *(void *)(a1 + 200);
  if (NextChar != *(void *)(v9 + 8 * GlyphIndexForChar)) {
    uint64_t NextChar = TRun::GetNextChar((TRun *)a1, NextChar, &GlyphIndexForChar);
  }
  while (NextChar < v8)
  {
    uint64_t v10 = GlyphIndexForChar;
    uint64_t v11 = *(void *)(a1 + 216);
    uint64_t v12 = *(void *)(a1 + 200);
    if (*(__int16 *)(*(void *)(v11 + 16) + 2 * v12 + 2 * GlyphIndexForChar) != -1
      && (*(_DWORD *)(*(void *)(v11 + 40) + 4 * v12 + 4 * GlyphIndexForChar) & 0x20) == 0)
    {
      uint64_t v14 = *(char **)a4;
      CFIndex v13 = *(char **)(a4 + 8);
      if (*(char **)a4 == v13 || *(void *)(v9 + 8 * GlyphIndexForChar) != *((void *)v13 - 1))
      {
        unint64_t v15 = *(void *)(a4 + 16);
        if ((unint64_t)v13 >= v15)
        {
          uint64_t v17 = (v13 - v14) >> 3;
          unint64_t v18 = v17 + 1;
          if ((unint64_t)(v17 + 1) >> 61) {
            abort();
          }
          uint64_t v19 = v15 - (void)v14;
          if (v19 >> 2 > v18) {
            unint64_t v18 = v19 >> 2;
          }
          unint64_t v20 = (unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8 ? 0x1FFFFFFFFFFFFFFFLL : v18;
          v31[4] = a4 + 24;
          if (v20)
          {
            CFRange v21 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate(a4 + 24, v20);
            uint64_t v14 = *(char **)a4;
            CFIndex v13 = *(char **)(a4 + 8);
          }
          else
          {
            CFRange v21 = 0;
          }
          CFRange v22 = &v21[8 * v17];
          *(void *)CFRange v22 = *(void *)(v9 + 8 * v10);
          if (v13 == v14)
          {
            uint64_t v24 = &v21[8 * v17];
          }
          else
          {
            uint64_t v23 = v13;
            uint64_t v24 = &v21[8 * v17];
            do
            {
              uint64_t v25 = *((void *)v23 - 1);
              v23 -= 8;
              *((void *)v24 - 1) = v25;
              v24 -= 8;
            }
            while (v23 != v14);
          }
          int v16 = v22 + 8;
          *(void *)a4 = v24;
          *(void *)(a4 + 8) = v22 + 8;
          uint64_t v26 = *(void *)(a4 + 16);
          *(void *)(a4 + 16) = &v21[8 * v20];
          v31[2] = v13;
          v31[3] = v26;
          v31[0] = v14;
          v31[1] = v14;
          std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)v31);
        }
        else
        {
          *(void *)CFIndex v13 = *(void *)(v9 + 8 * GlyphIndexForChar);
          int v16 = v13 + 8;
        }
        *(void *)(a4 + 8) = v16;
        if ((unint64_t)v16 - *(void *)a4 > 0xF0) {
          return 0;
        }
      }
    }
    if (*(int *)(a1 + 256) > 1)
    {
      uint64_t NextChar = TRun::FindNextGlyphIndex((TRun *)a1, NextChar, &GlyphIndexForChar);
    }
    else
    {
      uint64_t v27 = GlyphIndexForChar;
      if (*(unsigned char *)(a1 + 224))
      {
        uint64_t v28 = --GlyphIndexForChar;
        if (v27 > 0)
        {
LABEL_32:
          uint64_t NextChar = *(void *)(*(void *)(*(void *)(a1 + 216) + 48) + 8 * *(void *)(a1 + 200) + 8 * v28);
          continue;
        }
      }
      else
      {
        uint64_t v28 = GlyphIndexForChar + 1;
        uint64_t GlyphIndexForChar = v28;
        if (v28 < *(void *)(a1 + 208)) {
          goto LABEL_32;
        }
      }
      uint64_t NextChar = *(void *)(a1 + 16) + *(void *)(a1 + 8);
    }
  }
  return 1;
}

uint64_t TRun::ReverseGlyphs(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 208);
  if (v1 >= 2)
  {
    uint64_t v2 = this;
    uint64_t v3 = 0;
    uint64_t v4 = v1 - 1;
    do
    {
      this = [*(id *)(v2 + 216) swapGlyphsAtIndex:v3 + *(void *)(v2 + 200) withIndex:v4 + *(void *)(v2 + 200)];
      ++v3;
      --v4;
    }
    while (v3 < v4);
  }
  return this;
}

uint64_t TRun::DeleteChars(TRun *this, int64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v6 = a2;
  uint64_t v69 = *MEMORY[0x1E4F143B8];
  if (*((_DWORD *)this + 64))
  {
    if (a2 < 1)
    {
      return 0;
    }
    else
    {
      uint64_t v8 = 0;
      do
      {
        uint64_t v9 = *a3++;
        uint64_t GlyphIndexForChar = 0xAAAAAAAAAAAAAAAALL;
        uint64_t GlyphIndexForChar = TRun::GetGlyphIndexForCharIndex<false>((uint64_t)this, v9);
        if (*(void *)(*(void *)(*((void *)this + 27) + 48)
                       + 8 * *((void *)this + 25)
                       + 8 * GlyphIndexForChar) == v9)
          v8 += TRun::DeleteGlyphs(this, 1, (char *)&GlyphIndexForChar, a4);
        --v6;
      }
      while (v6);
    }
  }
  else
  {
    *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v67[14] = v10;
    v67[13] = v10;
    v67[12] = v10;
    v67[11] = v10;
    v67[10] = v10;
    v67[9] = v10;
    v67[8] = v10;
    v67[7] = v10;
    v67[6] = v10;
    v67[5] = v10;
    v67[4] = v10;
    v67[3] = v10;
    v67[2] = v10;
    v67[1] = v10;
    v67[0] = v10;
    uint64_t v65 = 0;
    uint64_t v66 = 0;
    uint64_t GlyphIndexForChar = 0;
    uint64_t v68 = v67;
    std::vector<long,TInlineBufferAllocator<long,30ul>>::reserve((char **)&GlyphIndexForChar, a2);
    uint64_t v11 = *((void *)this + 26);
    uint64_t v12 = *(void *)(*((void *)this + 27) + 48) + 8 * *((void *)this + 25);
    if (*((unsigned char *)this + 224))
    {
      if (v6 >= 1)
      {
        uint64_t v33 = 0;
        uint64_t v34 = v11 - 1;
        do
        {
          uint64_t v35 = a3[v33];
          do
          {
            uint64_t v36 = v34;
            uint64_t v37 = *(void *)(v12 + 8 * v34--);
          }
          while ((v36 & 0x8000000000000000) == 0 && v37 < v35);
          unint64_t v38 = v34 + 1;
          if (v37 == v35)
          {
            if ((v38 & 0x8000000000000000) != 0) {
              break;
            }
            uint64_t v39 = v65;
            if (v65 >= (void **)v66)
            {
              unint64_t v41 = (void **)GlyphIndexForChar;
              uint64_t v42 = ((uint64_t)v65 - GlyphIndexForChar) >> 3;
              unint64_t v43 = v42 + 1;
              if ((unint64_t)(v42 + 1) >> 61) {
LABEL_80:
              }
                abort();
              uint64_t v44 = (uint64_t)&v66[-GlyphIndexForChar];
              if ((uint64_t)&v66[-GlyphIndexForChar] >> 2 > v43) {
                unint64_t v43 = v44 >> 2;
              }
              if ((unint64_t)v44 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v45 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v45 = v43;
              }
              char v63 = v67;
              if (v45)
              {
                double v46 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v67, v45);
                unint64_t v41 = (void **)GlyphIndexForChar;
                uint64_t v39 = v65;
              }
              else
              {
                double v46 = 0;
              }
              uint64_t v47 = &v46[8 * v42];
              *(void *)uint64_t v47 = v38;
              if (v39 == v41)
              {
                uint64_t v49 = (uint64_t)&v46[8 * v42];
              }
              else
              {
                double v48 = v39;
                uint64_t v49 = (uint64_t)&v46[8 * v42];
                do
                {
                  uint64_t v50 = (uint64_t)*--v48;
                  *(void *)(v49 - 8) = v50;
                  v49 -= 8;
                }
                while (v48 != v41);
              }
              int v40 = (void **)(v47 + 8);
              uint64_t GlyphIndexForChar = v49;
              uint64_t v65 = (void **)(v47 + 8);
              double v51 = v66;
              uint64_t v66 = &v46[8 * v45];
              unint64_t v61 = v39;
              uint64_t v62 = v51;
              p_uint64_t GlyphIndexForChar = v41;
              CGFloat v60 = v41;
              std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&p_GlyphIndexForChar);
            }
            else
            {
              *uint64_t v65 = (void *)v38;
              int v40 = v39 + 1;
            }
            uint64_t v65 = v40;
          }
          else
          {
            ++v34;
          }
          ++v33;
        }
        while (v33 != v6);
      }
      double v52 = v65 - 1;
      if ((void **)GlyphIndexForChar != v65 && (unint64_t)v52 > GlyphIndexForChar)
      {
        unint64_t v54 = GlyphIndexForChar + 8;
        do
        {
          unsigned int v55 = *(void **)(v54 - 8);
          *(void *)(v54 - 8) = *v52;
          *v52-- = v55;
          BOOL v56 = v54 >= (unint64_t)v52;
          v54 += 8;
        }
        while (!v56);
      }
    }
    else if (v6 >= 1)
    {
      uint64_t v13 = 0;
      uint64_t v14 = 0;
      do
      {
        uint64_t v15 = a3[v13];
        do
        {
          uint64_t v16 = v14;
          uint64_t v17 = *(void *)(v12 + 8 * v14++);
        }
        while (v17 < v15 && v16 < v11);
        uint64_t v19 = (void *)(v14 - 1);
        if (v17 == v15)
        {
          if (v16 >= v11) {
            break;
          }
          unint64_t v20 = v65;
          if (v65 >= (void **)v66)
          {
            CFRange v22 = (void **)GlyphIndexForChar;
            uint64_t v23 = ((uint64_t)v65 - GlyphIndexForChar) >> 3;
            unint64_t v24 = v23 + 1;
            if ((unint64_t)(v23 + 1) >> 61) {
              goto LABEL_80;
            }
            uint64_t v25 = (uint64_t)&v66[-GlyphIndexForChar];
            if ((uint64_t)&v66[-GlyphIndexForChar] >> 2 > v24) {
              unint64_t v24 = v25 >> 2;
            }
            if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v26 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v26 = v24;
            }
            char v63 = v67;
            if (v26)
            {
              uint64_t v27 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v67, v26);
              CFRange v22 = (void **)GlyphIndexForChar;
              unint64_t v20 = v65;
            }
            else
            {
              uint64_t v27 = 0;
            }
            uint64_t v28 = &v27[8 * v23];
            *(void *)uint64_t v28 = v19;
            if (v20 == v22)
            {
              uint64_t v30 = (uint64_t)&v27[8 * v23];
            }
            else
            {
              double v29 = v20;
              uint64_t v30 = (uint64_t)&v27[8 * v23];
              do
              {
                uint64_t v31 = (uint64_t)*--v29;
                *(void *)(v30 - 8) = v31;
                v30 -= 8;
              }
              while (v29 != v22);
            }
            CFRange v21 = (void **)(v28 + 8);
            uint64_t GlyphIndexForChar = v30;
            uint64_t v65 = (void **)(v28 + 8);
            double v32 = v66;
            uint64_t v66 = &v27[8 * v26];
            unint64_t v61 = v20;
            uint64_t v62 = v32;
            p_uint64_t GlyphIndexForChar = v22;
            CGFloat v60 = v22;
            std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&p_GlyphIndexForChar);
          }
          else
          {
            *uint64_t v65 = v19;
            CFRange v21 = v20 + 1;
          }
          uint64_t v65 = v21;
        }
        else
        {
          --v14;
        }
        ++v13;
      }
      while (v13 != v6);
    }
    if ((void **)GlyphIndexForChar == v65) {
      uint64_t v8 = 0;
    }
    else {
      uint64_t v8 = TRun::DeleteGlyphs(this, ((uint64_t)v65 - GlyphIndexForChar) >> 3, (char *)GlyphIndexForChar, a4);
    }
    p_uint64_t GlyphIndexForChar = (void **)&GlyphIndexForChar;
    std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](&p_GlyphIndexForChar);
  }
  return v8;
}

uint64_t TRun::SetAttachmentsRightToLeft<true>(TRun *this, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v8 = 0;
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = *(void *)(*((void *)this + 27) + 48) + 8 * *((void *)this + 25);
  *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v34[14] = v10;
  v34[13] = v10;
  v34[12] = v10;
  v34[11] = v10;
  v34[10] = v10;
  v34[9] = v10;
  v34[8] = v10;
  v34[7] = v10;
  v34[6] = v10;
  v34[5] = v10;
  v34[4] = v10;
  v34[3] = v10;
  v34[2] = v10;
  v34[1] = v10;
  v34[0] = v10;
  memset(v33, 0, sizeof(v33));
  uint64_t v35 = v34;
  if (a2 >= 2)
  {
    uint64_t v8 = a2 - 1;
    uint64_t v11 = a3;
    uint64_t v12 = a2 - 1;
    do
    {
      uint64_t v13 = *v11++;
      uint64_t v14 = [*((id *)this + 27) attachmentCountAtIndex:*((void *)this + 25) + v13];
      uint64_t v15 = v13 + 1;
      if (v13 + 1 < *((void *)this + 26)) {
        objc_msgSend(*((id *)this + 27), "setAttachmentCount:atIndex:", v14 + objc_msgSend(*((id *)this + 27), "attachmentCountAtIndex:", *((void *)this + 25) + v15) + 1, *((void *)this + 25) + v15);
      }
      --v12;
    }
    while (v12);
  }
  uint64_t v16 = a3[v8];
  uint64_t v17 = *(void *)(v9 + 8 * v16);
  uint64_t v18 = *((void *)this + 1);
  if (v17 <= a4)
  {
    uint64_t v23 = *((void *)this + 2) + v18;
    uint64_t v32 = v16;
    uint64_t v24 = v16;
    while (1)
    {
      if (*((int *)this + 64) > 1)
      {
        NextGlyphIndedouble x = TRun::FindNextGlyphIndex(this, v17, &v32);
      }
      else
      {
        if (*((unsigned char *)this + 224))
        {
          uint64_t v25 = v24 - 1;
          uint64_t v32 = v24 - 1;
          if (v24 <= 0)
          {
LABEL_13:
            NextGlyphIndedouble x = *((void *)this + 2) + *((void *)this + 1);
            goto LABEL_17;
          }
        }
        else
        {
          uint64_t v25 = v24 + 1;
          uint64_t v32 = v24 + 1;
          if (v24 + 1 >= *((void *)this + 26)) {
            goto LABEL_13;
          }
        }
        NextGlyphIndedouble x = *(void *)(*(void *)(*((void *)this + 27) + 48) + 8 * *((void *)this + 25) + 8 * v25);
      }
LABEL_17:
      if (NextGlyphIndex >= v23)
      {
        uint64_t v30 = [*((id *)this + 27) attachmentCountAtIndex:*((void *)this + 25) + v16] + 1;
        goto LABEL_25;
      }
      uint64_t v24 = v32;
      uint64_t v27 = (void *)*((void *)this + 27);
      uint64_t v28 = *((void *)this + 25);
      if (a2 < 2
        || *(__int16 *)(v27[2] + 2 * v28 + 2 * v32) != -1 && (*(_DWORD *)(v27[5] + 4 * v28 + 4 * v32) & 0x20) == 0)
      {
        [v27 setStringIndex:v17 atIndex:v28 + v32];
        uint64_t v29 = [*((id *)this + 27) attachmentCountAtIndex:*((void *)this + 25) + v16];
        uint64_t v20 = v29 + [*((id *)this + 27) attachmentCountAtIndex:*((void *)this + 25) + v24] + 1;
        CFRange v21 = (void *)*((void *)this + 27);
        uint64_t v22 = *((void *)this + 25) + v24;
        goto LABEL_22;
      }
    }
  }
  uint64_t v19 = [*((id *)this + 27) attachmentCountAtIndex:*((void *)this + 25) + v16];
  if (v17 <= v18)
  {
    uint64_t v30 = v19 + 1;
  }
  else
  {
    uint64_t v20 = v19 + [*((id *)this + 27) attachmentCountAtIndex:*((void *)this + 25) + v16 + 1] + 1;
    CFRange v21 = (void *)*((void *)this + 27);
    uint64_t v22 = *((void *)this + 25) + v16 + 1;
LABEL_22:
    [v21 setAttachmentCount:v20 atIndex:v22];
    uint64_t v30 = 0;
  }
LABEL_25:
  uint64_t v32 = (uint64_t)v33;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v32);
  return v30;
}

uint64_t TRun::SetAttachmentsLeftToRight<false>(uint64_t a1, uint64_t a2, char *__src, uint64_t a4)
{
  uint64_t v5 = a2;
  uint64_t v65 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void *)(*(void *)(a1 + 216) + 48);
  uint64_t v8 = *(void *)(a1 + 200);
  *(void *)&long long v9 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v63[14] = v9;
  v63[13] = v9;
  v63[12] = v9;
  v63[11] = v9;
  v63[10] = v9;
  v63[9] = v9;
  v63[8] = v9;
  v63[7] = v9;
  v63[6] = v9;
  v63[5] = v9;
  v63[4] = v9;
  v63[3] = v9;
  void v63[2] = v9;
  v63[1] = v9;
  v63[0] = v9;
  unint64_t v61 = 0;
  uint64_t v62 = 0;
  CGFloat v60 = 0;
  uint64_t v64 = v63;
  std::vector<long,TInlineBufferAllocator<long,30ul>>::__insert_with_size[abi:nn180100]<long const*,long const*>((uint64_t *)&v60, __src, &__src[8 * a2], a2);
  unint64_t v10 = 126 - 2 * __clz(v61 - v60);
  uint64_t v11 = v7 + 8 * v8;
  v58[0] = v11;
  if (v61 == v60) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = v10;
  }
  std::__introsort<std::_ClassicAlgPolicy,LessByStringIndex &,long *,false>(v60, v61, v58, v12, 1);
  uint64_t v13 = v60;
  uint64_t v14 = v5 - 1;
  if (v5 >= 2)
  {
    uint64_t v56 = a4;
    uint64_t v57 = v5;
    uint64_t v15 = 0;
    uint64_t v16 = &v60[v5];
    uint64_t v17 = v16 - 2;
    while (1)
    {
      uint64_t v18 = v5;
      uint64_t v5 = v14;
      uint64_t v19 = v13;
      uint64_t v20 = v13[v14];
      uint64_t v59 = v20;
      uint64_t v21 = *(void *)(v11 + 8 * v20);
      uint64_t v22 = *(void **)(a1 + 216);
      uint64_t v23 = *(void *)(a1 + 200);
      if ((*(_DWORD *)(v22[5] + 4 * v23 + 4 * v20) & 0x380) == 0) {
        goto LABEL_24;
      }
      memset(v58, 170, sizeof(v58));
      TRun::FindInsertionGroup((TRun *)v58, a1, v20);
      if (v58[1] - v58[0] < 9) {
        break;
      }
      uint64_t v24 = 0;
      do
      {
        if (*(void *)(v11 + 8 * v17[v24]) != v21) {
          break;
        }
        --v24;
      }
      while (v5 + v24 > 0);
      uint64_t v25 = ((unint64_t)(v58[1] - v58[0]) >> 3) + v24;
      if (v18 < v57)
      {
        uint64_t v26 = v25 + v15;
        uint64_t v27 = v15;
        while (*(void *)(v11 + 8 * v16[v27]) == v21)
        {
          --v25;
          if (__CFADD__(v27++, 1))
          {
            uint64_t v25 = v26;
            break;
          }
        }
      }
      if (v25 <= 1) {
        break;
      }
      if (v58[0])
      {
        v58[1] = v58[0];
        operator delete((void *)v58[0]);
      }
      uint64_t v13 = v19;
LABEL_30:
      --v15;
      --v17;
      uint64_t v14 = v5 - 1;
      if (v5 <= 1)
      {
        uint64_t v14 = 0;
        a4 = v56;
        uint64_t v5 = v57;
        uint64_t v31 = 1;
        goto LABEL_33;
      }
    }
    if (v58[0])
    {
      v58[1] = v58[0];
      operator delete((void *)v58[0]);
    }
    uint64_t v22 = *(void **)(a1 + 216);
    uint64_t v23 = *(void *)(a1 + 200);
LABEL_24:
    uint64_t v29 = objc_msgSend(v22, "attachmentCountAtIndex:", v23 + v20, v56);
    if (*(int *)(a1 + 256) > 1 || (*(unsigned char *)(a1 + 224) & 1) != 0)
    {
      TRun::FindPrevGlyphIndex((TRun *)a1, v21, &v59);
      uint64_t v30 = v59;
    }
    else
    {
      uint64_t v30 = v20 - 1;
    }
    uint64_t v13 = v19;
    if ((v30 & 0x8000000000000000) == 0) {
      objc_msgSend(*(id *)(a1 + 216), "setAttachmentCount:atIndex:", v29 + objc_msgSend(*(id *)(a1 + 216), "attachmentCountAtIndex:", *(void *)(a1 + 200) + v30) + 1, *(void *)(a1 + 200) + v30);
    }
    goto LABEL_30;
  }
  uint64_t v31 = v5;
LABEL_33:
  uint64_t v32 = v13[v14];
  uint64_t v59 = v32;
  if ((*(_DWORD *)(*(void *)(*(void *)(a1 + 216) + 40) + 4 * *(void *)(a1 + 200) + 4 * v32) & 0x380) == 0)
  {
    uint64_t v33 = 0;
    goto LABEL_46;
  }
  memset(v58, 170, sizeof(v58));
  TRun::FindInsertionGroup((TRun *)v58, a1, v32);
  uint64_t v33 = (v58[1] - v58[0]) >> 3;
  if (v58[1] - v58[0] < 9) {
    goto LABEL_41;
  }
  if (v31 < v5)
  {
    uint64_t v34 = v31 - v5 + v33;
    uint64_t v35 = v5 - v31;
    uint64_t v36 = &v13[v31];
    while (1)
    {
      uint64_t v37 = *v36++;
      if (*(void *)(v11 + 8 * v37) != *(void *)(v11 + 8 * v32)) {
        break;
      }
      --v33;
      if (!--v35)
      {
        uint64_t v33 = v34;
        break;
      }
    }
  }
  if (v33 <= 1)
  {
LABEL_41:
    int v38 = 1;
    if (!v58[0]) {
      goto LABEL_43;
    }
    goto LABEL_42;
  }
  int v38 = 0;
  if (v58[0])
  {
LABEL_42:
    v58[1] = v58[0];
    operator delete((void *)v58[0]);
  }
LABEL_43:
  if (!v38)
  {
LABEL_71:
    uint64_t v54 = 0;
    goto LABEL_72;
  }
LABEL_46:
  uint64_t v39 = *(void *)(v11 + 8 * v32);
  uint64_t v40 = *(void *)(a1 + 8);
  if (v39 <= a4)
  {
    uint64_t v44 = *(void *)(a1 + 16) + v40;
    v58[0] = v32;
    uint64_t v45 = v32;
    while (1)
    {
      if (*(int *)(a1 + 256) > 1)
      {
        NextGlyphIndedouble x = TRun::FindNextGlyphIndex((TRun *)a1, v39, v58);
      }
      else
      {
        if (*(unsigned char *)(a1 + 224))
        {
          uint64_t v46 = v45 - 1;
          v58[0] = v45 - 1;
          if (v45 <= 0)
          {
LABEL_55:
            NextGlyphIndedouble x = *(void *)(a1 + 16) + *(void *)(a1 + 8);
            goto LABEL_59;
          }
        }
        else
        {
          uint64_t v46 = v45 + 1;
          v58[0] = v45 + 1;
          if (v45 + 1 >= *(void *)(a1 + 208)) {
            goto LABEL_55;
          }
        }
        NextGlyphIndedouble x = *(void *)(*(void *)(*(void *)(a1 + 216) + 48) + 8 * *(void *)(a1 + 200) + 8 * v46);
      }
LABEL_59:
      if (NextGlyphIndex >= v44)
      {
        uint64_t v54 = [*(id *)(a1 + 216) attachmentCountAtIndex:*(void *)(a1 + 200) + v32] + 1;
        goto LABEL_72;
      }
      uint64_t v45 = v58[0];
      double v48 = *(void **)(a1 + 216);
      uint64_t v49 = *(void *)(a1 + 200);
      if (v5 < 2
        || *(__int16 *)(v48[2] + 2 * v49 + 2 * v58[0]) != -1 && (*(_DWORD *)(v48[5] + 4 * v49 + 4 * v58[0]) & 0x20) == 0)
      {
        objc_msgSend(v48, "setStringIndex:atIndex:", v39, v49 + v58[0], v56);
        uint64_t v50 = [*(id *)(a1 + 216) attachmentCountAtIndex:*(void *)(a1 + 200) + v32];
        uint64_t v51 = v50 + [*(id *)(a1 + 216) attachmentCountAtIndex:*(void *)(a1 + 200) + v45] + 1;
        double v52 = *(void **)(a1 + 216);
        uint64_t v53 = *(void *)(a1 + 200) + v45;
        goto LABEL_70;
      }
    }
  }
  uint64_t v41 = [*(id *)(a1 + 216) attachmentCountAtIndex:*(void *)(a1 + 200) + v32];
  uint64_t v42 = v41;
  if (v39 > v40)
  {
    if (*(int *)(a1 + 256) > 1 || (*(unsigned char *)(a1 + 224) & 1) != 0)
    {
      TRun::FindPrevGlyphIndex((TRun *)a1, v39, &v59);
      uint64_t v43 = v59;
    }
    else
    {
      uint64_t v43 = v32 - 1;
    }
    uint64_t v51 = v42 - v33 + objc_msgSend(*(id *)(a1 + 216), "attachmentCountAtIndex:", *(void *)(a1 + 200) + v43, v56) + 1;
    double v52 = *(void **)(a1 + 216);
    uint64_t v53 = *(void *)(a1 + 200) + v43;
LABEL_70:
    [v52 setAttachmentCount:v51 atIndex:v53];
    goto LABEL_71;
  }
  uint64_t v54 = v41 + 1;
LABEL_72:
  v58[0] = (uint64_t)&v60;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v58);
  return v54;
}

uint64_t TRun::SetAttachmentsRightToLeft<false>(uint64_t a1, uint64_t a2, char *__src, uint64_t a4)
{
  uint64_t v5 = a2;
  uint64_t v71 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void *)(*(void *)(a1 + 216) + 48);
  uint64_t v8 = *(void *)(a1 + 200);
  *(void *)&long long v9 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v69[14] = v9;
  v69[13] = v9;
  v69[12] = v9;
  v69[11] = v9;
  v69[10] = v9;
  v69[9] = v9;
  v69[8] = v9;
  v69[7] = v9;
  v69[6] = v9;
  v69[5] = v9;
  v69[4] = v9;
  v69[3] = v9;
  v69[2] = v9;
  v69[1] = v9;
  v69[0] = v9;
  uint64_t v67 = 0;
  uint64_t v68 = 0;
  uint64_t v66 = 0;
  uint64_t v70 = v69;
  std::vector<long,TInlineBufferAllocator<long,30ul>>::__insert_with_size[abi:nn180100]<long const*,long const*>((uint64_t *)&v66, __src, &__src[8 * a2], a2);
  unint64_t v10 = 126 - 2 * __clz(v67 - v66);
  uint64_t v11 = v7 + 8 * v8;
  v64[0] = v11;
  if (v67 == v66) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = v10;
  }
  std::__introsort<std::_ClassicAlgPolicy,LessByStringIndex &,long *,false>(v66, v67, v64, v12, 1);
  uint64_t v13 = 0;
  uint64_t v14 = v66;
  if (v5 >= 2)
  {
    uint64_t v60 = a4;
    uint64_t v61 = v5;
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    uint64_t v17 = v5 - 1;
    uint64_t v62 = v5 - 1;
    char v63 = v66;
    uint64_t v18 = v66 - 1;
    uint64_t v19 = v66 + 1;
    while (1)
    {
      uint64_t v20 = v14[v16];
      uint64_t v65 = v20;
      uint64_t v21 = *(void *)(v11 + 8 * v20);
      uint64_t v22 = *(void **)(a1 + 216);
      uint64_t v23 = *(void *)(a1 + 200);
      if ((*(_DWORD *)(v22[5] + 4 * v23 + 4 * v20) & 0x380) == 0) {
        goto LABEL_26;
      }
      memset(v64, 170, sizeof(v64));
      TRun::FindInsertionGroup((TRun *)v64, a1, v20);
      unint64_t v24 = v64[1] - v64[0];
      if (v64[1] - v64[0] < 9) {
        break;
      }
      unint64_t v25 = v24 >> 3;
      if (v16)
      {
        uint64_t v26 = 0;
        uint64_t v27 = v25 + v15;
        while (*(void *)(v11 + 8 * v18[v26]) == v21)
        {
          --v26;
          if (v16 + v26 + 1 <= 1) {
            goto LABEL_15;
          }
        }
        uint64_t v27 = v25 + v26;
      }
      else
      {
        uint64_t v27 = v24 >> 3;
      }
LABEL_15:
      if (v16 + 1 < v61)
      {
        uint64_t v28 = v19;
        uint64_t v29 = v17;
        do
        {
          uint64_t v30 = *v28++;
          if (*(void *)(v11 + 8 * v30) != v21) {
            break;
          }
          --v27;
          --v29;
        }
        while (v29);
      }
      if (v27 <= 1) {
        break;
      }
      if (v64[0])
      {
        v64[1] = v64[0];
        operator delete((void *)v64[0]);
      }
      uint64_t v14 = v63;
LABEL_32:
      ++v16;
      --v15;
      ++v18;
      --v17;
      ++v19;
      uint64_t v13 = v62;
      if (v16 == v62)
      {
        a4 = v60;
        uint64_t v5 = v61;
        goto LABEL_34;
      }
    }
    if (v64[0])
    {
      v64[1] = v64[0];
      operator delete((void *)v64[0]);
    }
    uint64_t v22 = *(void **)(a1 + 216);
    uint64_t v23 = *(void *)(a1 + 200);
LABEL_26:
    uint64_t v31 = objc_msgSend(v22, "attachmentCountAtIndex:", v23 + v20, v60);
    if (*(int *)(a1 + 256) > 1 || (*(unsigned char *)(a1 + 224) & 1) != 0)
    {
      TRun::FindPrevGlyphIndex((TRun *)a1, v21, &v65);
      uint64_t v32 = v65;
    }
    else
    {
      uint64_t v32 = v20 - 1;
    }
    uint64_t v14 = v63;
    if (v32 < *(void *)(a1 + 208)) {
      objc_msgSend(*(id *)(a1 + 216), "setAttachmentCount:atIndex:", v31 + objc_msgSend(*(id *)(a1 + 216), "attachmentCountAtIndex:", *(void *)(a1 + 200) + v32) + 1, *(void *)(a1 + 200) + v32);
    }
    goto LABEL_32;
  }
LABEL_34:
  uint64_t v33 = v14[v13];
  uint64_t v65 = v33;
  if ((*(_DWORD *)(*(void *)(*(void *)(a1 + 216) + 40) + 4 * *(void *)(a1 + 200) + 4 * v33) & 0x380) == 0)
  {
    uint64_t v34 = 0;
    goto LABEL_54;
  }
  memset(v64, 170, sizeof(v64));
  TRun::FindInsertionGroup((TRun *)v64, a1, v33);
  uint64_t v34 = (v64[1] - v64[0]) >> 3;
  if (v64[1] - v64[0] < 9) {
    goto LABEL_49;
  }
  uint64_t v35 = *(void *)(v11 + 8 * v33);
  if (v13 >= 1)
  {
    uint64_t v36 = v34 - v13;
    if (v5 <= 1) {
      uint64_t v37 = 1;
    }
    else {
      uint64_t v37 = v5;
    }
    while (*(void *)(v11 + 8 * v14[v37 - 2]) == v35)
    {
      --v34;
      if ((unint64_t)--v37 <= 1)
      {
        uint64_t v34 = v36;
        break;
      }
    }
  }
  uint64_t v38 = v5 - (v13 + 1);
  if (v5 > v13 + 1)
  {
    uint64_t v39 = v13 - v5 + v34 + 1;
    uint64_t v40 = &v14[v13 + 1];
    while (1)
    {
      uint64_t v41 = *v40++;
      if (*(void *)(v11 + 8 * v41) != v35) {
        break;
      }
      --v34;
      if (!--v38)
      {
        uint64_t v34 = v39;
        break;
      }
    }
  }
  if (v34 <= 1)
  {
LABEL_49:
    int v42 = 1;
    if (!v64[0]) {
      goto LABEL_51;
    }
    goto LABEL_50;
  }
  int v42 = 0;
  if (v64[0])
  {
LABEL_50:
    v64[1] = v64[0];
    operator delete((void *)v64[0]);
  }
LABEL_51:
  if (!v42)
  {
LABEL_79:
    uint64_t v58 = 0;
    goto LABEL_80;
  }
LABEL_54:
  uint64_t v43 = *(void *)(v11 + 8 * v33);
  uint64_t v44 = *(void *)(a1 + 8);
  if (v43 <= a4)
  {
    uint64_t v48 = *(void *)(a1 + 16) + v44;
    v64[0] = v33;
    uint64_t v49 = v33;
    while (1)
    {
      if (*(int *)(a1 + 256) > 1)
      {
        NextGlyphIndedouble x = TRun::FindNextGlyphIndex((TRun *)a1, v43, v64);
      }
      else
      {
        if (*(unsigned char *)(a1 + 224))
        {
          uint64_t v50 = v49 - 1;
          v64[0] = v49 - 1;
          if (v49 <= 0)
          {
LABEL_63:
            NextGlyphIndedouble x = *(void *)(a1 + 16) + *(void *)(a1 + 8);
            goto LABEL_67;
          }
        }
        else
        {
          uint64_t v50 = v49 + 1;
          v64[0] = v49 + 1;
          if (v49 + 1 >= *(void *)(a1 + 208)) {
            goto LABEL_63;
          }
        }
        NextGlyphIndedouble x = *(void *)(*(void *)(*(void *)(a1 + 216) + 48) + 8 * *(void *)(a1 + 200) + 8 * v50);
      }
LABEL_67:
      if (NextGlyphIndex >= v48)
      {
        uint64_t v58 = [*(id *)(a1 + 216) attachmentCountAtIndex:*(void *)(a1 + 200) + v33] + 1;
        goto LABEL_80;
      }
      uint64_t v49 = v64[0];
      double v52 = *(void **)(a1 + 216);
      uint64_t v53 = *(void *)(a1 + 200);
      if (v5 < 2
        || *(__int16 *)(v52[2] + 2 * v53 + 2 * v64[0]) != -1 && (*(_DWORD *)(v52[5] + 4 * v53 + 4 * v64[0]) & 0x20) == 0)
      {
        objc_msgSend(v52, "setStringIndex:atIndex:", v43, v53 + v64[0], v60);
        uint64_t v54 = [*(id *)(a1 + 216) attachmentCountAtIndex:*(void *)(a1 + 200) + v33];
        uint64_t v55 = v54 + [*(id *)(a1 + 216) attachmentCountAtIndex:*(void *)(a1 + 200) + v49] + 1;
        uint64_t v56 = *(void **)(a1 + 216);
        uint64_t v57 = *(void *)(a1 + 200) + v49;
        goto LABEL_78;
      }
    }
  }
  uint64_t v45 = [*(id *)(a1 + 216) attachmentCountAtIndex:*(void *)(a1 + 200) + v33];
  uint64_t v46 = v45;
  if (v43 > v44)
  {
    if (*(int *)(a1 + 256) > 1 || (*(unsigned char *)(a1 + 224) & 1) != 0)
    {
      TRun::FindPrevGlyphIndex((TRun *)a1, v43, &v65);
      uint64_t v47 = v65;
    }
    else
    {
      uint64_t v47 = v33 - 1;
    }
    uint64_t v55 = v46 - v34 + objc_msgSend(*(id *)(a1 + 216), "attachmentCountAtIndex:", *(void *)(a1 + 200) + v47, v60) + 1;
    uint64_t v56 = *(void **)(a1 + 216);
    uint64_t v57 = *(void *)(a1 + 200) + v47;
LABEL_78:
    [v56 setAttachmentCount:v55 atIndex:v57];
    goto LABEL_79;
  }
  uint64_t v58 = v45 + 1;
LABEL_80:
  v64[0] = (uint64_t)&v66;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v64);
  return v58;
}

void TRun::TruncateBeginToChar(TRun *this, uint64_t a2)
{
  uint64_t NextChar = a2;
  uint64_t GlyphIndexForChar = TRun::GetGlyphIndexForCharIndex<false>((uint64_t)this, a2);
  uint64_t v7 = GlyphIndexForChar;
  if (*(void *)(*(void *)(*((void *)this + 27) + 48) + 8 * *((void *)this + 25) + 8 * GlyphIndexForChar) >= NextChar)
  {
    v5.locatiouint64_t n = GlyphIndexForChar;
  }
  else
  {
    uint64_t NextChar = TRun::GetNextChar(this, NextChar, &v7);
    v5.locatiouint64_t n = v7;
  }
  if (*((unsigned char *)this + 224))
  {
    v5.CFIndex length = v5.location + 1;
    v5.locatiouint64_t n = 0;
  }
  else
  {
    v5.CFIndex length = *((void *)this + 26) - v5.location;
  }
  TRun::TruncateStorageRange(this, v5);
  uint64_t v6 = *((void *)this + 1) - NextChar + *((void *)this + 2);
  *((void *)this + 1) = NextChar;
  *((void *)this + 2) = v6;
}

uint64_t TRun::AbsorbFollowingRun(TRun *this, TRun *a2)
{
  uint64_t v2 = *((void *)this + 25);
  uint64_t v3 = *((void *)this + 26);
  if (v3 + v2 != *((void *)a2 + 25)) {
    return 0;
  }
  uint64_t v4 = *((void *)a2 + 26);
  if (v4 < 0) {
    return 0;
  }
  uint64_t v5 = v3 + v4;
  if (v5 + v2 > *(void *)(*((void *)this + 27) + 8)) {
    return 0;
  }
  *((void *)this + 26) = v5;
  if (*((unsigned char *)a2 + 225)) {
    *((unsigned char *)this + 225) |= 1u;
  }
  *((double *)this + 24) = *((double *)this + 24) + *((double *)a2 + 24);
  return 1;
}

uint64_t TRun::FindNextGlyphIndex(TRun *this, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = a2;
  uint64_t v6 = (void *)*((void *)this + 27);
  uint64_t v7 = *((void *)this + 25);
  uint64_t v8 = v6[6] + 8 * v7;
  uint64_t v9 = *((void *)this + 1);
  uint64_t v10 = *((void *)this + 2);
  uint64_t v11 = v6[5] + 4 * v7;
  if ((*(_DWORD *)(v11 + 4 * *a3) & 0x380) == 0)
  {
LABEL_14:
    uint64_t v16 = v10 + v9;
    uint64_t v17 = v4 - 1;
    while (1)
    {
      uint64_t v18 = v17 + 2;
      if (v17 + 2 >= v16) {
        break;
      }
      uint64_t Glyph = TRun::FindGlyphIndex<false>((uint64_t)this, v18, 1);
      if (*(void *)(v8 + 8 * Glyph) > ++v17) {
        goto LABEL_17;
      }
    }
    if (*((unsigned char *)this + 224)) {
      uint64_t v19 = -1;
    }
    else {
      uint64_t v19 = *((void *)this + 26);
    }
    *a3 = v19;
    return v18;
  }
  uint64_t v12 = 1;
  if (*((unsigned char *)this + 224)) {
    uint64_t v12 = -1;
  }
  uint64_t Glyph = v12 + *a3;
  if (*((unsigned char *)this + 224)) {
    uint64_t v14 = -1;
  }
  else {
    uint64_t v14 = *((void *)this + 26);
  }
  if (Glyph == v14)
  {
LABEL_13:
    uint64_t v4 = objc_msgSend(*((id *)this + 27), "attachmentCountAtIndex:", *((void *)this + 25) + TRun::FindGlyphIndex<false>((uint64_t)this, a2, 1))+ a2;
    goto LABEL_14;
  }
  uint64_t v15 = v6[2] + 2 * v7;
  while (*(__int16 *)(v15 + 2 * Glyph) == -1
       || (*(_DWORD *)(v11 + 4 * Glyph) & 0x20) != 0
       || *(void *)(v8 + 8 * Glyph) != a2)
  {
    Glyph += v12;
    if (v14 == Glyph) {
      goto LABEL_13;
    }
  }
LABEL_17:
  *a3 = Glyph;
  return *(void *)(v8 + 8 * Glyph);
}

uint64_t TRun::FindGlyphIndex<false>(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3 = *(void **)(a1 + 216);
  uint64_t v4 = *(void *)(a1 + 200);
  uint64_t v5 = v3[6] + 8 * v4;
  char v6 = *(unsigned char *)(a1 + 224);
  if (v6) {
    int v7 = -a3;
  }
  else {
    int v7 = a3;
  }
  if (v7 >= 0) {
    uint64_t v8 = 0;
  }
  else {
    uint64_t v8 = *(void *)(a1 + 208) - 1;
  }
  if (v7 < 0) {
    uint64_t v9 = -1;
  }
  else {
    uint64_t v9 = *(void *)(a1 + 208);
  }
  if (*(int *)(a1 + 256) >= 2)
  {
    if (v8 == v9)
    {
      LOBYTE(v11) = 1;
      uint64_t v12 = v8;
    }
    else
    {
      uint64_t v17 = v3[2] + 2 * v4;
      uint64_t v18 = 4 * v4;
      int v11 = 1;
      uint64_t v12 = v8;
      do
      {
        if (*(__int16 *)(v17 + 2 * v8) != -1 && (*(_DWORD *)(v3[5] + v18 + 4 * v8) & 0x20) == 0)
        {
          uint64_t v19 = *(void *)(v5 + 8 * v8);
          if (v19 == a2) {
            goto LABEL_29;
          }
          int v20 = (v19 < a2) & ((v19 > *(void *)(v5 + 8 * v12)) | v11);
          v11 &= v20 ^ 1;
          if (v20) {
            uint64_t v12 = v8;
          }
        }
        v8 += v7;
      }
      while (v9 != v8);
      uint64_t v8 = v9;
    }
LABEL_29:
    if (v8 == v9) {
      uint64_t result = v12;
    }
    else {
      uint64_t result = v8;
    }
    if (v8 == v9)
    {
      if (v6) {
        int v22 = -1;
      }
      else {
        int v22 = 1;
      }
      uint64_t v23 = v9 - v7;
      if (v7 == v22) {
        uint64_t v23 = v12;
      }
      if (v11) {
        return v23;
      }
    }
  }
  else
  {
    if (v8 == v9)
    {
      uint64_t v10 = v8;
    }
    else
    {
      uint64_t v13 = v3[2] + 2 * v4;
      uint64_t v14 = 4 * v4;
      uint64_t v15 = v8;
      while (1)
      {
        uint64_t v10 = v8;
        if (*(__int16 *)(v13 + 2 * v15) != -1 && (*(_DWORD *)(v3[5] + v14 + 4 * v15) & 0x20) == 0)
        {
          uint64_t v16 = *(void *)(v5 + 8 * v15);
          uint64_t v8 = v15;
          if (v16 >= a2) {
            break;
          }
        }
        v15 += v7;
        if (v9 == v15)
        {
          uint64_t v10 = v8;
          uint64_t v8 = v9;
          goto LABEL_44;
        }
      }
      if (v16 <= a2) {
        uint64_t v8 = v15;
      }
      else {
        uint64_t v8 = v10;
      }
    }
LABEL_44:
    if (v8 == v9) {
      return v10;
    }
    else {
      return v8;
    }
  }
  return result;
}

uint64_t TRun::FindPrevGlyphIndex(TRun *this, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = a2;
  char v6 = (void *)*((void *)this + 27);
  uint64_t v7 = *((void *)this + 25);
  uint64_t v8 = v6[6] + 8 * v7;
  if (*((int *)this + 64) <= 1 && (*((unsigned char *)this + 224) & 1) != 0)
  {
    uint64_t Glyph = *a3 + 1;
    *a3 = Glyph;
    if (Glyph != *((void *)this + 26)) {
      return *(void *)(v8 + 8 * Glyph);
    }
    return *((void *)this + 1) - 1;
  }
  else
  {
    uint64_t v9 = *a3;
    uint64_t v10 = v6[5] + 4 * v7;
    if ((*(_DWORD *)(v10 + 4 * *a3) & 0x380) == 0) {
      goto LABEL_16;
    }
    if (*((unsigned char *)this + 224))
    {
      uint64_t Glyph = v9 + 1;
      uint64_t v13 = *((void *)this + 26);
      uint64_t v12 = 1;
    }
    else
    {
      uint64_t Glyph = v9 - 1;
      uint64_t v12 = -1;
      uint64_t v13 = -1;
    }
    if (Glyph != v13)
    {
      uint64_t v15 = v6[2] + 2 * v7;
      while (*(__int16 *)(v15 + 2 * Glyph) == -1
           || (*(_DWORD *)(v10 + 4 * Glyph) & 0x20) != 0
           || *(void *)(v8 + 8 * Glyph) != a2)
      {
        Glyph += v12;
        if (v13 == Glyph) {
          goto LABEL_15;
        }
      }
LABEL_18:
      *a3 = Glyph;
      return *(void *)(v8 + 8 * Glyph);
    }
LABEL_15:
    uint64_t v4 = objc_msgSend(*((id *)this + 27), "attachmentCountAtIndex:", *((void *)this + 25) + TRun::FindGlyphIndex<false>((uint64_t)this, a2, -1))+ a2;
LABEL_16:
    while (1)
    {
      uint64_t v14 = v4 - 1;
      if (v4 <= *((void *)this + 1)) {
        break;
      }
      uint64_t Glyph = TRun::FindGlyphIndex<false>((uint64_t)this, --v4, -1);
      if (Glyph != *a3) {
        goto LABEL_18;
      }
    }
  }
  return v14;
}

uint64_t *TRun::FindInsertionGroup(TRun *this, uint64_t a2, uint64_t a3)
{
  char v6 = (uint64_t *)operator new(8uLL);
  *(void *)this = v6;
  *v6++ = a3;
  *((void *)this + 2) = v6;
  *((void *)this + 1) = v6;
  uint64_t v7 = *(void *)(*(void *)(a2 + 216) + 48) + 8 * *(void *)(a2 + 200);
  uint64_t v8 = *(void *)(v7 + 8 * a3);
  uint64_t v46 = a3;
  if (*(int *)(a2 + 256) > 1 || (*(unsigned char *)(a2 + 224) & 1) != 0)
  {
    PrevGlyphIndedouble x = TRun::FindPrevGlyphIndex((TRun *)a2, v8, &v46);
  }
  else
  {
    uint64_t v46 = a3 - 1;
    if (a3 <= 0) {
      PrevGlyphIndedouble x = *(void *)(a2 + 8) - 1;
    }
    else {
      PrevGlyphIndedouble x = *(void *)(v7 + 8 * (a3 - 1));
    }
  }
  if (PrevGlyphIndex == v8)
  {
    do
    {
      int v11 = (uint64_t *)*((void *)this + 1);
      unint64_t v10 = *((void *)this + 2);
      if ((unint64_t)v11 >= v10)
      {
        uint64_t v13 = *(uint64_t **)this;
        uint64_t v14 = ((uint64_t)v11 - *(void *)this) >> 3;
        unint64_t v15 = v14 + 1;
        if ((unint64_t)(v14 + 1) >> 61) {
LABEL_74:
        }
          abort();
        uint64_t v16 = v10 - (void)v13;
        if (v16 >> 2 > v15) {
          unint64_t v15 = v16 >> 2;
        }
        if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v17 = v15;
        }
        if (v17)
        {
          uint64_t v18 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<long>>((uint64_t)this + 16, v17);
          uint64_t v13 = *(uint64_t **)this;
          int v11 = (uint64_t *)*((void *)this + 1);
        }
        else
        {
          uint64_t v18 = 0;
        }
        uint64_t v19 = (uint64_t *)&v18[8 * v14];
        *uint64_t v19 = v46;
        uint64_t v12 = v19 + 1;
        while (v11 != v13)
        {
          uint64_t v20 = *--v11;
          *--uint64_t v19 = v20;
        }
        *(void *)this = v19;
        *((void *)this + 1) = v12;
        *((void *)this + 2) = &v18[8 * v17];
        if (v13) {
          operator delete(v13);
        }
      }
      else
      {
        *int v11 = v46;
        uint64_t v12 = v11 + 1;
      }
      *((void *)this + 1) = v12;
      if (*(int *)(a2 + 256) > 1 || (*(unsigned char *)(a2 + 224) & 1) != 0)
      {
        uint64_t v23 = TRun::FindPrevGlyphIndex((TRun *)a2, v8, &v46);
      }
      else
      {
        uint64_t v21 = v46;
        uint64_t v22 = --v46;
        if (v21 <= 0) {
          uint64_t v23 = *(void *)(a2 + 8) - 1;
        }
        else {
          uint64_t v23 = *(void *)(*(void *)(*(void *)(a2 + 216) + 48) + 8 * *(void *)(a2 + 200) + 8 * v22);
        }
      }
    }
    while (v23 == v8);
  }
  uint64_t v45 = a3;
  if (*(int *)(a2 + 256) > 1)
  {
    NextGlyphIndedouble x = TRun::FindNextGlyphIndex((TRun *)a2, v8, &v45);
  }
  else
  {
    if (*(unsigned char *)(a2 + 224))
    {
      uint64_t v24 = a3 - 1;
      uint64_t v45 = a3 - 1;
      if (a3 <= 0) {
        goto LABEL_34;
      }
    }
    else
    {
      uint64_t v24 = a3 + 1;
      uint64_t v45 = a3 + 1;
      if (a3 + 1 >= *(void *)(a2 + 208))
      {
LABEL_34:
        NextGlyphIndedouble x = *(void *)(a2 + 16) + *(void *)(a2 + 8);
        goto LABEL_38;
      }
    }
    NextGlyphIndedouble x = *(void *)(*(void *)(*(void *)(a2 + 216) + 48) + 8 * *(void *)(a2 + 200) + 8 * v24);
  }
LABEL_38:
  if (NextGlyphIndex == v8)
  {
    do
    {
      uint64_t v27 = (uint64_t *)*((void *)this + 1);
      unint64_t v26 = *((void *)this + 2);
      if ((unint64_t)v27 >= v26)
      {
        uint64_t v29 = *(uint64_t **)this;
        uint64_t v30 = ((uint64_t)v27 - *(void *)this) >> 3;
        unint64_t v31 = v30 + 1;
        if ((unint64_t)(v30 + 1) >> 61) {
          goto LABEL_74;
        }
        uint64_t v32 = v26 - (void)v29;
        if (v32 >> 2 > v31) {
          unint64_t v31 = v32 >> 2;
        }
        if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v33 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v33 = v31;
        }
        if (v33)
        {
          uint64_t v34 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<long>>((uint64_t)this + 16, v33);
          uint64_t v29 = *(uint64_t **)this;
          uint64_t v27 = (uint64_t *)*((void *)this + 1);
        }
        else
        {
          uint64_t v34 = 0;
        }
        uint64_t v35 = (uint64_t *)&v34[8 * v30];
        *uint64_t v35 = v45;
        uint64_t v28 = v35 + 1;
        while (v27 != v29)
        {
          uint64_t v36 = *--v27;
          *--uint64_t v35 = v36;
        }
        *(void *)this = v35;
        *((void *)this + 1) = v28;
        *((void *)this + 2) = &v34[8 * v33];
        if (v29) {
          operator delete(v29);
        }
      }
      else
      {
        *uint64_t v27 = v45;
        uint64_t v28 = v27 + 1;
      }
      *((void *)this + 1) = v28;
      if (*(int *)(a2 + 256) > 1)
      {
        uint64_t v39 = TRun::FindNextGlyphIndex((TRun *)a2, v8, &v45);
      }
      else
      {
        uint64_t v37 = v45;
        if (*(unsigned char *)(a2 + 224))
        {
          uint64_t v38 = --v45;
          if (v37 > 0)
          {
LABEL_61:
            uint64_t v39 = *(void *)(*(void *)(*(void *)(a2 + 216) + 48) + 8 * *(void *)(a2 + 200) + 8 * v38);
            continue;
          }
        }
        else
        {
          uint64_t v38 = v45 + 1;
          uint64_t v45 = v38;
          if (v38 < *(void *)(a2 + 208)) {
            goto LABEL_61;
          }
        }
        uint64_t v39 = *(void *)(a2 + 16) + *(void *)(a2 + 8);
      }
    }
    while (v39 == v8);
  }
  uint64_t result = *(uint64_t **)this;
  uint64_t v41 = (uint64_t *)*((void *)this + 1);
  uint64_t v42 = (uint64_t)v41 - *(void *)this;
  if ((unint64_t)v42 >= 9)
  {
    if (*(unsigned char *)(a2 + 224))
    {
      unint64_t v43 = 126 - 2 * __clz(v42 >> 3);
      if (v41 == result) {
        uint64_t v44 = 0;
      }
      else {
        uint64_t v44 = v43;
      }
      return std::__introsort<std::_ClassicAlgPolicy,std::greater<long> &,long *,false>(result, v41, v44, 1);
    }
    else
    {
      char v47 = -86;
      return (uint64_t *)std::__sort<std::__less<long,long> &,long *>();
    }
  }
  return result;
}

uint64_t *TRun::GetLeadingWhitespace@<X0>(uint64_t *this@<X0>, double *a2@<X8>)
{
  if (this[26] <= 0)
  {
    *a2 = 0.0;
    a2[1] = 0.0;
    a2[2] = 0.0;
  }
  else
  {
    uint64_t v3 = this;
    uint64_t v4 = this[27];
    uint64_t v5 = *(void *)(v4 + 32);
    if (v5 || (uint64_t v8 = *(void *)(v4 + 24)) == 0)
    {
      int v6 = 0;
      uint64_t v7 = v5 + 16 * this[25];
    }
    else
    {
      uint64_t v7 = v8 + 8 * this[25];
      int v6 = 1;
    }
    this = (uint64_t *)TRun::ResolveCharIndex((TRun *)this, this[1]);
    uint64_t v9 = this;
    uint64_t v20 = v10;
    int v11 = (uint64_t *)v3[1];
    uint64_t v12 = 0;
    double v13 = 0.0;
    if ((uint64_t)v11 > (uint64_t)this || (uint64_t)v11 + v3[2] <= (uint64_t)this)
    {
      uint64_t v15 = (uint64_t)this;
    }
    else
    {
      uint64_t v15 = (uint64_t)this;
      do
      {
        uint64_t v16 = v3[27];
        uint64_t v17 = v3[25];
        if (*(__int16 *)(*(void *)(v16 + 16) + 2 * v17 + 2 * v20) != -1
          && (*(_DWORD *)(*(void *)(v16 + 40) + 4 * v17 + 4 * v20) & 0x21) == 0)
        {
          break;
        }
        ++v12;
        char v18 = v6 ? 3 : 4;
        double v13 = v13 + *(double *)(v7 + (v20 << v18));
        this = (uint64_t *)TRun::GetNextChar((TRun *)v3, v15, &v20);
        uint64_t v15 = (uint64_t)this;
        uint64_t v19 = (uint64_t *)v3[1];
        if ((uint64_t)v19 > (uint64_t)this) {
          break;
        }
      }
      while ((uint64_t)v19 + v3[2] > (uint64_t)this);
    }
    *(void *)a2 = v15 - (void)v9;
    *((void *)a2 + 1) = v12;
    a2[2] = v13;
  }
  return this;
}

void TRun::InitStretchFactors(TRun *this)
{
  uint64_t v2 = *((void *)this + 39);
  if (!v2) {
    operator new();
  }
  int64_t v3 = *((void *)this + 26);
  uint64_t v5 = *(void *)(v2 + 56);
  uint64_t v6 = *(void *)(v2 + 64);
  uint64_t v4 = v2 + 56;
  if (v3 > (v6 - v5) >> 4)
  {
    std::vector<CGSize>::resize(v4, v3, &kUnitSize);
  }
}

void std::vector<CGSize>::resize(uint64_t a1, unint64_t a2, _OWORD *a3)
{
  unint64_t v3 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 4;
  if (a2 <= v3)
  {
    if (a2 < v3) {
      *(void *)(a1 + 8) = *(void *)a1 + 16 * a2;
    }
  }
  else
  {
    std::vector<CGSize>::__append((void **)a1, a2 - v3, a3);
  }
}

uint64_t TRun::NoteCrossStreamPosition(TRun *this, double a2)
{
  uint64_t result = *((void *)this + 39);
  if (result)
  {
    double v4 = *(double *)(result + 16);
    double v5 = *(double *)(result + 24);
    if (v4 > a2) {
      double v4 = a2;
    }
    if (v5 < a2) {
      double v5 = a2;
    }
    *(double *)(result + 16) = v4;
    *(double *)(result + 24) = v5;
  }
  else if (a2 != 0.0)
  {
    operator new();
  }
  return result;
}

double TRun::UpdateWidth(TRun *this, TLine *a2, double a3)
{
  return 0.0;
}

uint64_t TRun::AcceptsOverhang(TRun *this)
{
  return 1;
}

void TRun::CopyEncapsulationPath(void *a1@<X8>)
{
  *a1 = 0;
}

void TRun::CopyRubyAnnotationLineForPosition(void *a1@<X8>)
{
  *a1 = 0;
}

void *std::vector<CGSize>::vector(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  double v4 = *(const void **)a2;
  uint64_t v3 = *(void *)(a2 + 8);
  int64_t v5 = v3 - *(void *)a2;
  if (v3 != *(void *)a2)
  {
    std::vector<CGSize>::__vallocate[abi:nn180100](a1, v5 >> 4);
    uint64_t v6 = (char *)a1[1];
    memmove(v6, v4, v5);
    a1[1] = &v6[v5];
  }
  return a1;
}

void std::vector<CGSize>::__append(void **a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  int64_t v5 = v6;
  uint64_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 4)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 16 * a2);
      v7 += 16 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = v7 - (unsigned char *)*a1;
    unint64_t v9 = a2 + (v8 >> 4);
    if (v9 >> 60) {
      abort();
    }
    uint64_t v10 = v8 >> 4;
    uint64_t v11 = v5 - (unsigned char *)*a1;
    if (v11 >> 3 > v9) {
      unint64_t v9 = v11 >> 3;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v12 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v9;
    }
    if (v12) {
      double v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CGSize>>(v4, v12);
    }
    else {
      double v13 = 0;
    }
    uint64_t v14 = &v13[16 * v10];
    uint64_t v15 = &v13[16 * v12];
    bzero(v14, 16 * a2);
    uint64_t v16 = &v14[16 * a2];
    char v18 = (char *)*a1;
    uint64_t v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        *((_OWORD *)v14 - 1) = *((_OWORD *)v17 - 1);
        v14 -= 16;
        v17 -= 16;
      }
      while (v17 != v18);
      uint64_t v17 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
    {
      operator delete(v17);
    }
  }
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<long>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(8 * a2);
}

uint64_t *std::__introsort<std::_ClassicAlgPolicy,std::greater<long> &,long *,false>(uint64_t *result, uint64_t *a2, uint64_t a3, char a4)
{
  unint64_t v9 = result;
  while (2)
  {
    uint64_t v10 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          unint64_t v9 = v10;
          uint64_t v11 = (char *)a2 - (char *)v10;
          unint64_t v12 = a2 - v10;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                uint64_t v39 = *(a2 - 1);
                uint64_t v40 = *v10;
                if (v39 > *v10)
                {
                  *uint64_t v10 = v39;
                  *(a2 - 1) = v40;
                }
                break;
              case 3uLL:
                uint64_t v41 = v10[1];
                uint64_t v42 = *(a2 - 1);
                if (v41 <= v42) {
                  uint64_t v43 = *(a2 - 1);
                }
                else {
                  uint64_t v43 = v10[1];
                }
                if (v41 >= v42) {
                  uint64_t v41 = *(a2 - 1);
                }
                *(a2 - 1) = v41;
                v10[1] = v43;
                uint64_t v44 = *(a2 - 1);
                if (v44 <= *v10) {
                  uint64_t v45 = *v10;
                }
                else {
                  uint64_t v45 = *(a2 - 1);
                }
                if (v44 >= *v10) {
                  uint64_t v44 = *v10;
                }
                *(a2 - 1) = v44;
                uint64_t v47 = *v10;
                uint64_t v46 = v10[1];
                if (v45 <= v46) {
                  uint64_t v47 = v10[1];
                }
                if (v45 < v46) {
                  uint64_t v46 = v45;
                }
                *uint64_t v10 = v47;
                v10[1] = v46;
                break;
              case 4uLL:
                uint64_t v49 = v10[1];
                uint64_t v48 = v10[2];
                if (*v10 <= v48) {
                  uint64_t v50 = v10[2];
                }
                else {
                  uint64_t v50 = *v10;
                }
                if (*v10 < v48) {
                  uint64_t v48 = *v10;
                }
                _OWORD v10[2] = v48;
                *uint64_t v10 = v50;
                uint64_t v51 = *(a2 - 1);
                if (v49 <= v51) {
                  uint64_t v52 = *(a2 - 1);
                }
                else {
                  uint64_t v52 = v49;
                }
                if (v49 < v51) {
                  uint64_t v51 = v49;
                }
                *(a2 - 1) = v51;
                uint64_t v53 = *v10;
                if (*v10 <= v52) {
                  uint64_t v54 = v52;
                }
                else {
                  uint64_t v54 = *v10;
                }
                if (*v10 >= v52) {
                  uint64_t v53 = v52;
                }
                *uint64_t v10 = v54;
                v10[1] = v53;
                uint64_t v55 = v10[2];
                uint64_t v56 = *(a2 - 1);
                if (v55 <= v56) {
                  uint64_t v57 = *(a2 - 1);
                }
                else {
                  uint64_t v57 = v10[2];
                }
                if (v55 >= v56) {
                  uint64_t v55 = *(a2 - 1);
                }
                *(a2 - 1) = v55;
                uint64_t v58 = v10[1];
                if (v58 <= v57) {
                  uint64_t v59 = v57;
                }
                else {
                  uint64_t v59 = v10[1];
                }
                if (v58 >= v57) {
                  uint64_t v58 = v57;
                }
                v10[1] = v59;
                _OWORD v10[2] = v58;
                break;
              case 5uLL:
                uint64_t v60 = *v10;
                uint64_t v61 = v10[1];
                if (*v10 <= v61) {
                  uint64_t v62 = v10[1];
                }
                else {
                  uint64_t v62 = *v10;
                }
                if (*v10 >= v61) {
                  uint64_t v60 = v10[1];
                }
                *uint64_t v10 = v62;
                v10[1] = v60;
                uint64_t v63 = v10[3];
                uint64_t v64 = *(a2 - 1);
                if (v63 <= v64) {
                  uint64_t v65 = *(a2 - 1);
                }
                else {
                  uint64_t v65 = v10[3];
                }
                if (v63 >= v64) {
                  uint64_t v63 = *(a2 - 1);
                }
                *(a2 - 1) = v63;
                v10[3] = v65;
                uint64_t v66 = *(a2 - 1);
                uint64_t v67 = v10[2];
                if (v66 <= v67) {
                  uint64_t v68 = v10[2];
                }
                else {
                  uint64_t v68 = *(a2 - 1);
                }
                if (v66 >= v67) {
                  uint64_t v66 = v10[2];
                }
                *(a2 - 1) = v66;
                uint64_t v70 = v10[2];
                uint64_t v69 = v10[3];
                uint64_t v71 = v10[1];
                if (v68 <= v69) {
                  uint64_t v70 = v10[3];
                }
                if (v68 < v69) {
                  uint64_t v69 = v68;
                }
                _OWORD v10[2] = v70;
                v10[3] = v69;
                uint64_t v72 = *(a2 - 1);
                if (v71 <= v72) {
                  uint64_t v73 = *(a2 - 1);
                }
                else {
                  uint64_t v73 = v71;
                }
                if (v71 < v72) {
                  uint64_t v72 = v71;
                }
                *(a2 - 1) = v72;
                uint64_t v74 = *v10;
                uint64_t v76 = v10[2];
                uint64_t v75 = v10[3];
                if (v75 <= *v10) {
                  uint64_t v77 = *v10;
                }
                else {
                  uint64_t v77 = v10[3];
                }
                if (v75 >= *v10) {
                  uint64_t v75 = *v10;
                }
                if (v77 <= v76) {
                  uint64_t v74 = v10[2];
                }
                if (v77 < v76) {
                  uint64_t v76 = v77;
                }
                if (v75 <= v73) {
                  uint64_t v78 = v73;
                }
                else {
                  uint64_t v78 = v75;
                }
                if (v75 >= v73) {
                  uint64_t v75 = v73;
                }
                if (v78 <= v76) {
                  uint64_t v73 = v76;
                }
                *uint64_t v10 = v74;
                v10[1] = v73;
                if (v78 >= v76) {
                  uint64_t v79 = v76;
                }
                else {
                  uint64_t v79 = v78;
                }
                _OWORD v10[2] = v79;
                v10[3] = v75;
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v11 <= 191)
          {
            uint64_t v80 = v10 + 1;
            BOOL v82 = v10 == a2 || v80 == a2;
            if (a4)
            {
              if (!v82)
              {
                uint64_t v83 = 8;
                uint64_t v84 = v10;
                do
                {
                  uint64_t v86 = *v84;
                  uint64_t v85 = v84[1];
                  uint64_t v84 = v80;
                  if (v85 > v86)
                  {
                    uint64_t v87 = v83;
                    do
                    {
                      *(uint64_t *)((char *)v10 + v87) = v86;
                      uint64_t v88 = v87 - 8;
                      if (v87 == 8)
                      {
                        uint64_t v89 = v10;
                        goto LABEL_158;
                      }
                      uint64_t v86 = *(uint64_t *)((char *)v10 + v87 - 16);
                      v87 -= 8;
                    }
                    while (v85 > v86);
                    uint64_t v89 = (uint64_t *)((char *)v10 + v88);
LABEL_158:
                    *uint64_t v89 = v85;
                  }
                  uint64_t v80 = v84 + 1;
                  v83 += 8;
                }
                while (v84 + 1 != a2);
              }
            }
            else if (!v82)
            {
              do
              {
                uint64_t v119 = *v9;
                uint64_t v118 = v9[1];
                unint64_t v9 = v80;
                if (v118 > v119)
                {
                  do
                  {
                    *uint64_t v80 = v119;
                    uint64_t v119 = *(v80 - 2);
                    --v80;
                  }
                  while (v118 > v119);
                  *uint64_t v80 = v118;
                }
                uint64_t v80 = v9 + 1;
              }
              while (v9 + 1 != a2);
            }
            return result;
          }
          if (!a3)
          {
            if (v10 != a2)
            {
              int64_t v90 = (v12 - 2) >> 1;
              int64_t v91 = v90;
              do
              {
                int64_t v92 = v91;
                if (v90 >= v91)
                {
                  uint64_t v93 = (2 * v91) | 1;
                  unint64_t v94 = &v10[v93];
                  if (2 * v92 + 2 < (uint64_t)v12)
                  {
                    uint64_t v97 = *v94;
                    uint64_t v95 = v94[1];
                    BOOL v96 = *v94 <= v95;
                    if (*v94 >= v95) {
                      uint64_t v97 = v94[1];
                    }
                    if (*v94 > v95) {
                      ++v94;
                    }
                    if (!v96) {
                      uint64_t v93 = 2 * v92 + 2;
                    }
                  }
                  else
                  {
                    uint64_t v97 = *v94;
                  }
                  uint64_t v98 = &v10[v92];
                  uint64_t v99 = *v98;
                  if (v97 <= *v98)
                  {
                    do
                    {
                      CFRange v100 = v94;
                      uint64_t *v98 = v97;
                      if (v90 < v93) {
                        break;
                      }
                      uint64_t v101 = (2 * v93) | 1;
                      unint64_t v94 = &v10[v101];
                      uint64_t v93 = 2 * v93 + 2;
                      if (v93 < (uint64_t)v12)
                      {
                        uint64_t v97 = *v94;
                        uint64_t result = v94 + 1;
                        uint64_t v102 = v94[1];
                        BOOL v103 = *v94 <= v102;
                        if (*v94 >= v102) {
                          uint64_t v97 = v94[1];
                        }
                        if (*v94 > v102) {
                          ++v94;
                        }
                        if (v103) {
                          uint64_t v93 = v101;
                        }
                      }
                      else
                      {
                        uint64_t v97 = *v94;
                        uint64_t v93 = v101;
                      }
                      uint64_t v98 = v100;
                    }
                    while (v97 <= v99);
                    *CFRange v100 = v99;
                  }
                }
                int64_t v91 = v92 - 1;
              }
              while (v92);
              uint64_t v104 = (unint64_t)v11 >> 3;
              do
              {
                uint64_t v105 = 0;
                uint64_t v106 = *v10;
                CFRange v107 = v10;
                do
                {
                  uint64_t v108 = &v107[v105 + 1];
                  uint64_t v109 = (2 * v105) | 1;
                  uint64_t v105 = 2 * v105 + 2;
                  if (v105 < v104)
                  {
                    uint64_t v111 = *v108;
                    uint64_t v110 = v108[1];
                    if (*v108 >= v110) {
                      uint64_t v111 = v108[1];
                    }
                    if (*v108 <= v110) {
                      uint64_t v105 = v109;
                    }
                    else {
                      ++v108;
                    }
                  }
                  else
                  {
                    uint64_t v111 = *v108;
                    uint64_t v105 = v109;
                  }
                  *CFRange v107 = v111;
                  CFRange v107 = v108;
                }
                while (v105 <= (uint64_t)((unint64_t)(v104 - 2) >> 1));
                if (v108 == --a2)
                {
                  uint64_t *v108 = v106;
                }
                else
                {
                  uint64_t *v108 = *a2;
                  *a2 = v106;
                  uint64_t v112 = (char *)v108 - (char *)v10 + 8;
                  if (v112 >= 9)
                  {
                    unint64_t v113 = (((unint64_t)v112 >> 3) - 2) >> 1;
                    uint64_t v114 = &v10[v113];
                    uint64_t v115 = *v114;
                    uint64_t v116 = *v108;
                    if (*v114 > *v108)
                    {
                      do
                      {
                        __int16 v117 = v114;
                        uint64_t *v108 = v115;
                        if (!v113) {
                          break;
                        }
                        unint64_t v113 = (v113 - 1) >> 1;
                        uint64_t v114 = &v10[v113];
                        uint64_t v115 = *v114;
                        uint64_t v108 = v117;
                      }
                      while (*v114 > v116);
                      *__int16 v117 = v116;
                    }
                  }
                }
                BOOL v96 = v104-- <= 2;
              }
              while (!v96);
            }
            return result;
          }
          unint64_t v13 = v12 >> 1;
          uint64_t v14 = &v10[v12 >> 1];
          if ((unint64_t)v11 >= 0x401)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::greater<long> &,long *>(v9, &v9[v12 >> 1], a2 - 1);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::greater<long> &,long *>(v9 + 1, v14 - 1, a2 - 2);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::greater<long> &,long *>(v9 + 2, &v9[v13 + 1], a2 - 3);
            uint64_t result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::greater<long> &,long *>(v14 - 1, v14, &v9[v13 + 1]);
            uint64_t v15 = *v9;
            *unint64_t v9 = *v14;
            *uint64_t v14 = v15;
          }
          else
          {
            uint64_t result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::greater<long> &,long *>(&v9[v12 >> 1], v9, a2 - 1);
          }
          --a3;
          uint64_t v16 = *v9;
          if ((a4 & 1) != 0 || *(v9 - 1) > v16) {
            break;
          }
          if (v16 <= *(a2 - 1))
          {
            unint64_t v31 = v9 + 1;
            do
            {
              uint64_t v10 = v31;
              if (v31 >= a2) {
                break;
              }
              ++v31;
            }
            while (v16 <= *v10);
          }
          else
          {
            uint64_t v10 = v9;
            do
            {
              uint64_t v30 = v10[1];
              ++v10;
            }
            while (v16 <= v30);
          }
          uint64_t v32 = a2;
          if (v10 < a2)
          {
            uint64_t v32 = a2;
            do
              uint64_t v33 = *--v32;
            while (v16 > v33);
          }
          if (v10 < v32)
          {
            uint64_t v34 = *v10;
            uint64_t v35 = *v32;
            do
            {
              *uint64_t v10 = v35;
              *uint64_t v32 = v34;
              do
              {
                uint64_t v36 = v10[1];
                ++v10;
                uint64_t v34 = v36;
              }
              while (v16 <= v36);
              do
              {
                uint64_t v37 = *--v32;
                uint64_t v35 = v37;
              }
              while (v16 > v37);
            }
            while (v10 < v32);
          }
          uint64_t v38 = v10 - 1;
          BOOL v4 = v10 - 1 >= v9;
          BOOL v5 = v10 - 1 == v9;
          if (v10 - 1 != v9) {
            *unint64_t v9 = *v38;
          }
          a4 = 0;
          uint64_t *v38 = v16;
        }
        uint64_t v17 = 0;
        do
          uint64_t v18 = v9[++v17];
        while (v18 > v16);
        uint64_t v19 = &v9[v17];
        uint64_t v20 = a2;
        if (v17 == 1)
        {
          uint64_t v20 = a2;
          do
          {
            if (v19 >= v20) {
              break;
            }
            uint64_t v22 = *--v20;
          }
          while (v22 <= v16);
        }
        else
        {
          do
            uint64_t v21 = *--v20;
          while (v21 <= v16);
        }
        if (v19 >= v20)
        {
          uint64_t v28 = v19 - 1;
        }
        else
        {
          uint64_t v23 = *v20;
          uint64_t v24 = v20;
          unint64_t v25 = &v9[v17];
          do
          {
            *unint64_t v25 = v23;
            uint64_t *v24 = v18;
            do
            {
              uint64_t v26 = v25[1];
              ++v25;
              uint64_t v18 = v26;
            }
            while (v26 > v16);
            do
            {
              uint64_t v27 = *--v24;
              uint64_t v23 = v27;
            }
            while (v27 <= v16);
          }
          while (v25 < v24);
          uint64_t v28 = v25 - 1;
        }
        if (v28 != v9) {
          *unint64_t v9 = *v28;
        }
        *uint64_t v28 = v16;
        if (v19 >= v20) {
          break;
        }
LABEL_33:
        uint64_t result = (uint64_t *)std::__introsort<std::_ClassicAlgPolicy,std::greater<long> &,long *,false>(v9, v28, a3, a4 & 1);
        a4 = 0;
        uint64_t v10 = v28 + 1;
      }
      BOOL v29 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::greater<long> &,long *>(v9, v28);
      uint64_t v10 = v28 + 1;
      uint64_t result = (uint64_t *)std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::greater<long> &,long *>(v28 + 1, a2);
      if (result) {
        break;
      }
      if (!v29) {
        goto LABEL_33;
      }
    }
    a2 = v28;
    if (!v29) {
      continue;
    }
    return result;
  }
}

uint64_t *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::greater<long> &,long *>(uint64_t *result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *result;
  uint64_t v5 = *a3;
  if (*a2 <= *result)
  {
    if (v5 > v3)
    {
      *a2 = v5;
      *a3 = v3;
      uint64_t v6 = *result;
      if (*a2 > *result)
      {
        *uint64_t result = *a2;
        *a2 = v6;
      }
    }
  }
  else
  {
    if (v5 <= v3)
    {
      *uint64_t result = v3;
      *a2 = v4;
      if (*a3 <= v4) {
        return result;
      }
      *a2 = *a3;
    }
    else
    {
      *uint64_t result = v5;
    }
    *a3 = v4;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::greater<long> &,long *>(void *a1, uint64_t *a2)
{
  uint64_t v2 = 1;
  switch(a2 - a1)
  {
    case 0:
    case 1:
      return v2;
    case 2:
      uint64_t v3 = *(a2 - 1);
      uint64_t v4 = *a1;
      if (v3 > *a1)
      {
        *a1 = v3;
        *(a2 - 1) = v4;
      }
      return 1;
    case 3:
      uint64_t v20 = a1[1];
      uint64_t v21 = *(a2 - 1);
      if (v20 <= v21) {
        uint64_t v22 = *(a2 - 1);
      }
      else {
        uint64_t v22 = a1[1];
      }
      if (v20 >= v21) {
        uint64_t v20 = *(a2 - 1);
      }
      *(a2 - 1) = v20;
      a1[1] = v22;
      uint64_t v23 = *(a2 - 1);
      if (v23 <= *a1) {
        uint64_t v24 = *a1;
      }
      else {
        uint64_t v24 = *(a2 - 1);
      }
      if (v23 >= *a1) {
        uint64_t v23 = *a1;
      }
      *(a2 - 1) = v23;
      uint64_t v26 = *a1;
      uint64_t v25 = a1[1];
      if (v24 <= v25) {
        uint64_t v26 = a1[1];
      }
      if (v24 < v25) {
        uint64_t v25 = v24;
      }
      *a1 = v26;
      a1[1] = v25;
      return 1;
    case 4:
      uint64_t v48 = a1[1];
      uint64_t v47 = a1[2];
      if (*a1 <= v47) {
        uint64_t v49 = a1[2];
      }
      else {
        uint64_t v49 = *a1;
      }
      if (*a1 < v47) {
        uint64_t v47 = *a1;
      }
      a1[2] = v47;
      *a1 = v49;
      uint64_t v50 = *(a2 - 1);
      if (v48 <= v50) {
        uint64_t v51 = *(a2 - 1);
      }
      else {
        uint64_t v51 = v48;
      }
      if (v48 < v50) {
        uint64_t v50 = v48;
      }
      *(a2 - 1) = v50;
      uint64_t v52 = *a1;
      if (*a1 <= v51) {
        uint64_t v53 = v51;
      }
      else {
        uint64_t v53 = *a1;
      }
      if (*a1 >= v51) {
        uint64_t v52 = v51;
      }
      *a1 = v53;
      a1[1] = v52;
      uint64_t v54 = a1[2];
      uint64_t v55 = *(a2 - 1);
      if (v54 <= v55) {
        uint64_t v56 = *(a2 - 1);
      }
      else {
        uint64_t v56 = a1[2];
      }
      if (v54 >= v55) {
        uint64_t v54 = *(a2 - 1);
      }
      *(a2 - 1) = v54;
      uint64_t v57 = a1[1];
      if (v57 <= v56) {
        uint64_t v58 = v56;
      }
      else {
        uint64_t v58 = a1[1];
      }
      if (v57 >= v56) {
        uint64_t v57 = v56;
      }
      a1[1] = v58;
      a1[2] = v57;
      return 1;
    case 5:
      uint64_t v27 = *a1;
      uint64_t v28 = a1[1];
      if (*a1 <= v28) {
        uint64_t v29 = a1[1];
      }
      else {
        uint64_t v29 = *a1;
      }
      if (*a1 >= v28) {
        uint64_t v27 = a1[1];
      }
      *a1 = v29;
      a1[1] = v27;
      uint64_t v30 = a1[3];
      uint64_t v31 = *(a2 - 1);
      if (v30 <= v31) {
        uint64_t v32 = *(a2 - 1);
      }
      else {
        uint64_t v32 = a1[3];
      }
      if (v30 >= v31) {
        uint64_t v30 = *(a2 - 1);
      }
      *(a2 - 1) = v30;
      a1[3] = v32;
      uint64_t v33 = *(a2 - 1);
      uint64_t v34 = a1[2];
      if (v33 <= v34) {
        uint64_t v35 = a1[2];
      }
      else {
        uint64_t v35 = *(a2 - 1);
      }
      if (v33 >= v34) {
        uint64_t v33 = a1[2];
      }
      *(a2 - 1) = v33;
      uint64_t v37 = a1[2];
      uint64_t v36 = a1[3];
      uint64_t v38 = a1[1];
      if (v35 <= v36) {
        uint64_t v37 = a1[3];
      }
      if (v35 < v36) {
        uint64_t v36 = v35;
      }
      a1[2] = v37;
      a1[3] = v36;
      uint64_t v39 = *(a2 - 1);
      if (v38 <= v39) {
        uint64_t v40 = *(a2 - 1);
      }
      else {
        uint64_t v40 = v38;
      }
      if (v38 < v39) {
        uint64_t v39 = v38;
      }
      *(a2 - 1) = v39;
      uint64_t v41 = *a1;
      uint64_t v43 = a1[2];
      uint64_t v42 = a1[3];
      if (v42 <= *a1) {
        uint64_t v44 = *a1;
      }
      else {
        uint64_t v44 = a1[3];
      }
      if (v42 >= *a1) {
        uint64_t v42 = *a1;
      }
      if (v44 <= v43) {
        uint64_t v41 = a1[2];
      }
      if (v44 < v43) {
        uint64_t v43 = v44;
      }
      if (v42 <= v40) {
        uint64_t v45 = v40;
      }
      else {
        uint64_t v45 = v42;
      }
      if (v42 >= v40) {
        uint64_t v42 = v40;
      }
      if (v45 <= v43) {
        uint64_t v40 = v43;
      }
      *a1 = v41;
      a1[1] = v40;
      if (v45 >= v43) {
        uint64_t v46 = v43;
      }
      else {
        uint64_t v46 = v45;
      }
      a1[2] = v46;
      a1[3] = v42;
      return 1;
    default:
      uint64_t v6 = a1 + 2;
      uint64_t v5 = a1[2];
      uint64_t v8 = *a1;
      uint64_t v7 = a1[1];
      if (v7 <= v5) {
        uint64_t v9 = a1[2];
      }
      else {
        uint64_t v9 = a1[1];
      }
      if (v7 < v5) {
        uint64_t v5 = a1[1];
      }
      if (v5 <= v8) {
        uint64_t v10 = *a1;
      }
      else {
        uint64_t v10 = v5;
      }
      if (v5 >= v8) {
        uint64_t v5 = *a1;
      }
      *uint64_t v6 = v5;
      if (v10 <= v9) {
        uint64_t v11 = v9;
      }
      else {
        uint64_t v11 = v8;
      }
      if (v10 >= v9) {
        uint64_t v10 = v9;
      }
      *a1 = v11;
      a1[1] = v10;
      unint64_t v12 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v13 = 0;
      uint64_t v14 = 24;
      break;
  }
  while (1)
  {
    uint64_t v15 = *v12;
    uint64_t v16 = *v6;
    if (*v12 > v16)
    {
      uint64_t v17 = v14;
      while (1)
      {
        *(void *)((char *)a1 + v17) = v16;
        uint64_t v18 = v17 - 8;
        if (v17 == 8) {
          break;
        }
        uint64_t v16 = *(void *)((char *)a1 + v17 - 16);
        v17 -= 8;
        if (v15 <= v16)
        {
          uint64_t v19 = (void *)((char *)a1 + v18);
          goto LABEL_27;
        }
      }
      uint64_t v19 = a1;
LABEL_27:
      *uint64_t v19 = v15;
      if (++v13 == 8) {
        return v12 + 1 == a2;
      }
    }
    uint64_t v6 = v12;
    v14 += 8;
    if (++v12 == a2) {
      return 1;
    }
  }
}

void GetLeftHangingCharacters(void)::$_0::__invoke()
{
  uint64_t v0 = 0;
  id Mutable = CFCharacterSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
  do
  {
    if (kHangers[v0 + 2])
    {
      v3.locatiouint64_t n = *(unsigned __int16 *)&kHangers[v0];
      v3.CFIndex length = 1;
      CFCharacterSetAddCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), v3);
    }
    v0 += 4;
  }
  while (v0 != 72);
  unint64_t v1 = atomic_exchange((atomic_ullong *volatile)&Mutable, 0);
  _CFCharacterSetCompact();
  _MergedGlobals_5 = v1;
}

void GetRightHangingCharacters(void)::$_0::__invoke()
{
  uint64_t v0 = 0;
  id Mutable = CFCharacterSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
  do
  {
    if (kHangers[v0 + 3])
    {
      v3.locatiouint64_t n = *(unsigned __int16 *)&kHangers[v0];
      v3.CFIndex length = 1;
      CFCharacterSetAddCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), v3);
    }
    v0 += 4;
  }
  while (v0 != 72);
  unint64_t v1 = atomic_exchange((atomic_ullong *volatile)&Mutable, 0);
  _CFCharacterSetCompact();
  qword_1EB2CDEB0 = v1;
}

void std::vector<CGSize>::__append(void **a1, unint64_t a2, _OWORD *a3)
{
  uint64_t v8 = a1[2];
  uint64_t v6 = (uint64_t)(a1 + 2);
  uint64_t v7 = v8;
  uint64_t v9 = *(_OWORD **)(v6 - 8);
  if (a2 <= (v8 - (unsigned char *)v9) >> 4)
  {
    if (a2)
    {
      uint64_t v16 = 16 * a2;
      uint64_t v17 = &v9[a2];
      do
      {
        *v9++ = *a3;
        v16 -= 16;
      }
      while (v16);
      uint64_t v9 = v17;
    }
    a1[1] = v9;
  }
  else
  {
    uint64_t v10 = (char *)v9 - (unsigned char *)*a1;
    unint64_t v11 = a2 + (v10 >> 4);
    if (v11 >> 60) {
      abort();
    }
    uint64_t v12 = v10 >> 4;
    uint64_t v13 = v7 - (unsigned char *)*a1;
    if (v13 >> 3 > v11) {
      unint64_t v11 = v13 >> 3;
    }
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v14 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v11;
    }
    if (v14) {
      uint64_t v15 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CGSize>>(v6, v14);
    }
    else {
      uint64_t v15 = 0;
    }
    uint64_t v18 = &v15[16 * v12];
    uint64_t v19 = &v18[16 * a2];
    uint64_t v20 = 16 * a2;
    uint64_t v21 = v18;
    do
    {
      *(_OWORD *)uint64_t v21 = *a3;
      v21 += 16;
      v20 -= 16;
    }
    while (v20);
    uint64_t v22 = &v15[16 * v14];
    uint64_t v24 = (char *)*a1;
    uint64_t v23 = (char *)a1[1];
    if (v23 != *a1)
    {
      do
      {
        *((_OWORD *)v18 - 1) = *((_OWORD *)v23 - 1);
        v18 -= 16;
        v23 -= 16;
      }
      while (v23 != v24);
      uint64_t v23 = (char *)*a1;
    }
    *a1 = v18;
    a1[1] = v19;
    a1[2] = v22;
    if (v23)
    {
      operator delete(v23);
    }
  }
}

uint64_t *std::vector<long,TInlineBufferAllocator<long,30ul>>::__insert_with_size[abi:nn180100]<long const*,long const*>(uint64_t *result, char *__src, char *a3, uint64_t a4)
{
  if (a4 < 1) {
    return result;
  }
  uint64_t v5 = __src;
  uint64_t v6 = (uint64_t)result;
  uint64_t v8 = result[1];
  uint64_t v7 = result[2];
  if (a4 > (v7 - v8) >> 3)
  {
    uint64_t v9 = *result;
    unint64_t v10 = a4 + ((v8 - *result) >> 3);
    if (v10 >> 61) {
      abort();
    }
    uint64_t v11 = -v9 >> 3;
    uint64_t v12 = (uint64_t)(result + 3);
    uint64_t v13 = v7 - v9;
    if (v13 >> 2 > v10) {
      unint64_t v10 = v13 >> 2;
    }
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v10;
    }
    v28[4] = v6 + 24;
    if (v14) {
      uint64_t v15 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate(v12, v14);
    }
    else {
      uint64_t v15 = 0;
    }
    uint64_t v24 = &v15[8 * v11];
    v28[0] = v15;
    v28[1] = v24;
    v28[3] = &v15[8 * v14];
    uint64_t v25 = 8 * a4;
    uint64_t v26 = &v24[8 * a4];
    do
    {
      uint64_t v27 = *(void *)v5;
      v5 += 8;
      *(void *)uint64_t v24 = v27;
      v24 += 8;
      v25 -= 8;
    }
    while (v25);
    v28[2] = v26;
    std::vector<long,TInlineBufferAllocator<long,30ul>>::__swap_out_circular_buffer((void **)v6, (uint64_t)v28, 0);
    return (uint64_t *)std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)v28);
  }
  uint64_t v16 = v8 >> 3;
  if (v8 >> 3 >= a4)
  {
    uint64_t v17 = &__src[8 * a4];
    uint64_t v19 = (void *)result[1];
LABEL_17:
    int64_t v20 = (int64_t)&v19[-a4];
    uint64_t v21 = v19;
    if (v20 < (unint64_t)v8)
    {
      uint64_t v22 = &v19[-a4];
      uint64_t v21 = v19;
      do
      {
        uint64_t v23 = *v22++;
        *v21++ = v23;
      }
      while ((unint64_t)v22 < v8);
    }
    *(void *)(v6 + 8) = v21;
    if (v19 != (void *)(8 * a4)) {
      uint64_t result = (uint64_t *)memmove(&v19[-(v20 >> 3)], 0, v20);
    }
    if (v17 != v5)
    {
      return (uint64_t *)memmove(0, v5, v17 - v5);
    }
    return result;
  }
  uint64_t v17 = &__src[8 * v16];
  int64_t v18 = a3 - v17;
  if (a3 != v17) {
    uint64_t result = (uint64_t *)memmove((void *)result[1], &__src[8 * v16], a3 - v17);
  }
  uint64_t v19 = (void *)(v8 + v18);
  *(void *)(v6 + 8) = v8 + v18;
  if (v8 >= 1) {
    goto LABEL_17;
  }
  return result;
}

uint64_t *std::__introsort<std::_ClassicAlgPolicy,LessByStringIndex &,long *,false>(uint64_t *result, uint64_t *a2, uint64_t *a3, uint64_t a4, char a5)
{
  uint64_t v11 = result;
  while (2)
  {
    uint64_t v12 = v11;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v11 = v12;
          uint64_t v13 = (char *)a2 - (char *)v12;
          unint64_t v14 = a2 - v12;
          if (v6 || !v5)
          {
            switch(v14)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                uint64_t v46 = *(a2 - 1);
                uint64_t v47 = *v12;
                if (*(void *)(*a3 + 8 * v46) < *(void *)(*a3 + 8 * *v12))
                {
                  *uint64_t v12 = v46;
                  *(a2 - 1) = v47;
                }
                break;
              case 3uLL:
                uint64_t v48 = *a3;
                uint64_t result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,LessByStringIndex &,long *>(v12, v12 + 1, a2 - 1, v48);
                break;
              case 4uLL:
                uint64_t result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,LessByStringIndex &,long *>(v12, v12 + 1, v12 + 2, a2 - 1, a3);
                break;
              case 5uLL:
                uint64_t result = std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,LessByStringIndex &,long *>(v12, v12 + 1, v12 + 2, v12 + 3, a2 - 1, a3);
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v13 <= 191)
          {
            uint64_t v49 = *a3;
            uint64_t v50 = v12 + 1;
            BOOL v52 = v12 == a2 || v50 == a2;
            if (a5)
            {
              if (!v52)
              {
                uint64_t v53 = 0;
                uint64_t v54 = v12;
                do
                {
                  uint64_t v56 = *v54;
                  uint64_t v55 = v54[1];
                  uint64_t v54 = v50;
                  if (*(void *)(v49 + 8 * v55) < *(void *)(v49 + 8 * v56))
                  {
                    uint64_t v57 = v53;
                    while (1)
                    {
                      *(uint64_t *)((char *)v12 + v57 + 8) = v56;
                      if (!v57) {
                        break;
                      }
                      uint64_t v56 = *(uint64_t *)((char *)v12 + v57 - 8);
                      v57 -= 8;
                      if (*(void *)(v49 + 8 * v55) >= *(void *)(v49 + 8 * v56))
                      {
                        uint64_t v58 = (uint64_t *)((char *)v12 + v57 + 8);
                        goto LABEL_83;
                      }
                    }
                    uint64_t v58 = v12;
LABEL_83:
                    *uint64_t v58 = v55;
                  }
                  uint64_t v50 = v54 + 1;
                  v53 += 8;
                }
                while (v54 + 1 != a2);
              }
            }
            else if (!v52)
            {
              do
              {
                uint64_t v88 = *v11;
                uint64_t v87 = v11[1];
                uint64_t v11 = v50;
                if (*(void *)(v49 + 8 * v87) < *(void *)(v49 + 8 * v88))
                {
                  do
                  {
                    uint64_t *v50 = v88;
                    uint64_t v88 = *(v50 - 2);
                    --v50;
                  }
                  while (*(void *)(v49 + 8 * v87) < *(void *)(v49 + 8 * v88));
                  uint64_t *v50 = v87;
                }
                uint64_t v50 = v11 + 1;
              }
              while (v11 + 1 != a2);
            }
            return result;
          }
          if (!a4)
          {
            if (v12 != a2)
            {
              int64_t v59 = (v14 - 2) >> 1;
              uint64_t v60 = *a3;
              int64_t v61 = v59;
              do
              {
                int64_t v62 = v61;
                if (v59 >= v61)
                {
                  uint64_t v63 = (2 * v61) | 1;
                  uint64_t v64 = &v12[v63];
                  if (2 * v62 + 2 < (uint64_t)v14)
                  {
                    uint64_t v65 = *v64;
                    if (*(void *)(v60 + 8 * *v64) < *(void *)(v60 + 8 * v64[1]))
                    {
                      uint64_t v65 = v64[1];
                      ++v64;
                      uint64_t v63 = 2 * v62 + 2;
                    }
                  }
                  else
                  {
                    uint64_t v65 = *v64;
                  }
                  uint64_t result = &v12[v62];
                  uint64_t v66 = *result;
                  if (*(void *)(v60 + 8 * v65) >= *(void *)(v60 + 8 * *result))
                  {
                    do
                    {
                      uint64_t v67 = v64;
                      *uint64_t result = v65;
                      if (v59 < v63) {
                        break;
                      }
                      uint64_t v68 = (2 * v63) | 1;
                      uint64_t v64 = &v12[v68];
                      uint64_t v63 = 2 * v63 + 2;
                      if (v63 < (uint64_t)v14)
                      {
                        uint64_t v65 = *v64;
                        if (*(void *)(v60 + 8 * *v64) >= *(void *)(v60 + 8 * v64[1]))
                        {
                          uint64_t v63 = v68;
                        }
                        else
                        {
                          uint64_t v65 = v64[1];
                          ++v64;
                        }
                      }
                      else
                      {
                        uint64_t v65 = *v64;
                        uint64_t v63 = v68;
                      }
                      uint64_t result = v67;
                    }
                    while (*(void *)(v60 + 8 * v65) >= *(void *)(v60 + 8 * v66));
                    *uint64_t v67 = v66;
                    uint64_t v60 = *a3;
                  }
                }
                int64_t v61 = v62 - 1;
              }
              while (v62);
              uint64_t v69 = (unint64_t)v13 >> 3;
              do
              {
                uint64_t v70 = 0;
                uint64_t v71 = *v12;
                uint64_t v72 = *a3;
                uint64_t v73 = v69 - 2;
                if (v69 < 2) {
                  uint64_t v73 = v69 - 1;
                }
                uint64_t v74 = v73 >> 1;
                uint64_t v75 = v12;
                do
                {
                  uint64_t v76 = &v75[v70 + 1];
                  uint64_t v77 = (2 * v70) | 1;
                  uint64_t v70 = 2 * v70 + 2;
                  if (v70 >= v69)
                  {
                    uint64_t v78 = *v76;
                    uint64_t v70 = v77;
                  }
                  else
                  {
                    uint64_t v78 = *v76;
                    uint64_t result = *(uint64_t **)(v72 + 8 * *v76);
                    if ((uint64_t)result >= *(void *)(v72 + 8 * v76[1]))
                    {
                      uint64_t v70 = v77;
                    }
                    else
                    {
                      uint64_t v78 = v76[1];
                      ++v76;
                    }
                  }
                  uint64_t *v75 = v78;
                  uint64_t v75 = v76;
                }
                while (v70 <= v74);
                if (v76 == --a2)
                {
                  *uint64_t v76 = v71;
                }
                else
                {
                  *uint64_t v76 = *a2;
                  *a2 = v71;
                  uint64_t v79 = (char *)v76 - (char *)v12 + 8;
                  if (v79 >= 9)
                  {
                    uint64_t v80 = *a3;
                    unint64_t v81 = (((unint64_t)v79 >> 3) - 2) >> 1;
                    BOOL v82 = &v12[v81];
                    uint64_t v83 = *v82;
                    uint64_t v84 = *v76;
                    if (*(void *)(*a3 + 8 * *v82) < *(void *)(*a3 + 8 * *v76))
                    {
                      do
                      {
                        uint64_t v85 = v82;
                        *uint64_t v76 = v83;
                        if (!v81) {
                          break;
                        }
                        unint64_t v81 = (v81 - 1) >> 1;
                        BOOL v82 = &v12[v81];
                        uint64_t v83 = *v82;
                        uint64_t result = *(uint64_t **)(v80 + 8 * v84);
                        uint64_t v76 = v85;
                      }
                      while (*(void *)(v80 + 8 * *v82) < (uint64_t)result);
                      uint64_t *v85 = v84;
                    }
                  }
                }
              }
              while (v69-- > 2);
            }
            return result;
          }
          unint64_t v15 = v14 >> 1;
          uint64_t v16 = &v12[v14 >> 1];
          uint64_t v17 = *a3;
          if ((unint64_t)v13 >= 0x401)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,LessByStringIndex &,long *>(v11, &v11[v14 >> 1], a2 - 1, v17);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,LessByStringIndex &,long *>(v11 + 1, v16 - 1, a2 - 2, *a3);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,LessByStringIndex &,long *>(v11 + 2, &v11[v15 + 1], a2 - 3, *a3);
            uint64_t result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,LessByStringIndex &,long *>(v16 - 1, v16, &v11[v15 + 1], *a3);
            uint64_t v18 = *v11;
            *uint64_t v11 = *v16;
            *uint64_t v16 = v18;
          }
          else
          {
            uint64_t result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,LessByStringIndex &,long *>(&v11[v14 >> 1], v11, a2 - 1, v17);
          }
          --a4;
          uint64_t v19 = *a3;
          uint64_t v20 = *v11;
          if (a5) {
            break;
          }
          uint64_t v21 = *(void *)(v19 + 8 * v20);
          if (*(void *)(v19 + 8 * *(v11 - 1)) < v21) {
            goto LABEL_13;
          }
          if (v21 >= *(void *)(v19 + 8 * *(a2 - 1)))
          {
            uint64_t v37 = v11 + 1;
            do
            {
              uint64_t v12 = v37;
              if (v37 >= a2) {
                break;
              }
              ++v37;
            }
            while (v21 >= *(void *)(v19 + 8 * *v12));
          }
          else
          {
            uint64_t v12 = v11;
            do
            {
              uint64_t v36 = v12[1];
              ++v12;
            }
            while (v21 >= *(void *)(v19 + 8 * v36));
          }
          uint64_t v38 = a2;
          if (v12 < a2)
          {
            uint64_t v38 = a2;
            do
              uint64_t v39 = *--v38;
            while (v21 < *(void *)(v19 + 8 * v39));
          }
          if (v12 < v38)
          {
            uint64_t v40 = *v12;
            uint64_t v41 = *v38;
            do
            {
              *uint64_t v12 = v41;
              uint64_t *v38 = v40;
              uint64_t v42 = *(void *)(v19 + 8 * v20);
              do
              {
                uint64_t v43 = v12[1];
                ++v12;
                uint64_t v40 = v43;
              }
              while (v42 >= *(void *)(v19 + 8 * v43));
              do
              {
                uint64_t v44 = *--v38;
                uint64_t v41 = v44;
              }
              while (v42 < *(void *)(v19 + 8 * v44));
            }
            while (v12 < v38);
          }
          uint64_t v45 = v12 - 1;
          BOOL v5 = v12 - 1 >= v11;
          BOOL v6 = v12 - 1 == v11;
          if (v12 - 1 != v11) {
            *uint64_t v11 = *v45;
          }
          a5 = 0;
          *uint64_t v45 = v20;
        }
        uint64_t v21 = *(void *)(v19 + 8 * v20);
LABEL_13:
        uint64_t v22 = 0;
        do
          uint64_t v23 = v11[++v22];
        while (*(void *)(v19 + 8 * v23) < v21);
        uint64_t v24 = &v11[v22];
        uint64_t v25 = a2;
        if (v22 == 1)
        {
          uint64_t v25 = a2;
          do
          {
            if (v24 >= v25) {
              break;
            }
            uint64_t v27 = *--v25;
          }
          while (*(void *)(v19 + 8 * v27) >= v21);
        }
        else
        {
          do
            uint64_t v26 = *--v25;
          while (*(void *)(v19 + 8 * v26) >= v21);
        }
        if (v24 >= v25)
        {
          uint64_t v34 = v24 - 1;
        }
        else
        {
          uint64_t v28 = *v25;
          uint64_t v29 = v25;
          uint64_t v30 = v24;
          do
          {
            *uint64_t v30 = v28;
            *uint64_t v29 = v23;
            uint64_t v31 = *(void *)(v19 + 8 * v20);
            do
            {
              uint64_t v32 = v30[1];
              ++v30;
              uint64_t v23 = v32;
            }
            while (*(void *)(v19 + 8 * v32) < v31);
            do
            {
              uint64_t v33 = *--v29;
              uint64_t v28 = v33;
            }
            while (*(void *)(v19 + 8 * v33) >= v31);
          }
          while (v30 < v29);
          uint64_t v34 = v30 - 1;
        }
        if (v34 != v11) {
          *uint64_t v11 = *v34;
        }
        uint64_t *v34 = v20;
        if (v24 >= v25) {
          break;
        }
LABEL_34:
        uint64_t result = (uint64_t *)std::__introsort<std::_ClassicAlgPolicy,LessByStringIndex &,long *,false>(v11, v34, a3, a4, a5 & 1);
        a5 = 0;
        uint64_t v12 = v34 + 1;
      }
      BOOL v35 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,LessByStringIndex &,long *>(v11, v34, a3);
      uint64_t v12 = v34 + 1;
      uint64_t result = (uint64_t *)std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,LessByStringIndex &,long *>(v34 + 1, a2, a3);
      if (result) {
        break;
      }
      if (!v35) {
        goto LABEL_34;
      }
    }
    a2 = v34;
    if (!v35) {
      continue;
    }
    return result;
  }
}

uint64_t *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,LessByStringIndex &,long *>(uint64_t *result, uint64_t *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *(void *)(a4 + 8 * *a2);
  uint64_t v6 = *result;
  uint64_t v7 = *a3;
  uint64_t v8 = *(void *)(a4 + 8 * *a3);
  if (v5 >= *(void *)(a4 + 8 * *result))
  {
    if (v8 < v5)
    {
      *a2 = v7;
      *a3 = v4;
      uint64_t v9 = *result;
      if (*(void *)(a4 + 8 * *a2) < *(void *)(a4 + 8 * *result))
      {
        *uint64_t result = *a2;
        *a2 = v9;
      }
    }
  }
  else
  {
    if (v8 >= v5)
    {
      *uint64_t result = v4;
      *a2 = v6;
      if (*(void *)(a4 + 8 * *a3) >= *(void *)(a4 + 8 * v6)) {
        return result;
      }
      *a2 = *a3;
    }
    else
    {
      *uint64_t result = v7;
    }
    *a3 = v6;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,LessByStringIndex &,long *>(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v6 = a2 - a1;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v8 = *(a2 - 1);
      uint64_t v9 = *a1;
      if (*(void *)(*a3 + 8 * v8) < *(void *)(*a3 + 8 * *a1))
      {
        *a1 = v8;
        *(a2 - 1) = v9;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,LessByStringIndex &,long *>(a1, a1 + 1, a2 - 1, *a3);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,LessByStringIndex &,long *>(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,LessByStringIndex &,long *>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1, a3);
      return 1;
    default:
      unint64_t v10 = a1 + 2;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,LessByStringIndex &,long *>(a1, a1 + 1, a1 + 2, *a3);
      uint64_t v11 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v12 = 0;
      uint64_t v13 = *a3;
      uint64_t v14 = 24;
      break;
  }
  while (1)
  {
    uint64_t v15 = *v11;
    uint64_t v16 = *v10;
    if (*(void *)(v13 + 8 * *v11) < *(void *)(v13 + 8 * *v10))
    {
      uint64_t v17 = v14;
      while (1)
      {
        *(uint64_t *)((char *)a1 + v17) = v16;
        uint64_t v18 = v17 - 8;
        if (v17 == 8) {
          break;
        }
        uint64_t v16 = *(uint64_t *)((char *)a1 + v17 - 16);
        v17 -= 8;
        if (*(void *)(v13 + 8 * v15) >= *(void *)(v13 + 8 * v16))
        {
          uint64_t v19 = (uint64_t *)((char *)a1 + v18);
          goto LABEL_12;
        }
      }
      uint64_t v19 = a1;
LABEL_12:
      *uint64_t v19 = v15;
      if (++v12 == 8) {
        return v11 + 1 == a2;
      }
    }
    unint64_t v10 = v11;
    v14 += 8;
    if (++v11 == a2) {
      return 1;
    }
  }
}

uint64_t *std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,LessByStringIndex &,long *>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  BOOL result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,LessByStringIndex &,long *>(a1, a2, a3, *a5);
  uint64_t v11 = *a5;
  uint64_t v12 = *a3;
  if (*(void *)(*a5 + 8 * *a4) < *(void *)(*a5 + 8 * *a3))
  {
    *a3 = *a4;
    *a4 = v12;
    uint64_t v13 = *a2;
    if (*(void *)(v11 + 8 * *a3) < *(void *)(v11 + 8 * *a2))
    {
      *a2 = *a3;
      *a3 = v13;
      uint64_t v14 = *a1;
      if (*(void *)(v11 + 8 * *a2) < *(void *)(v11 + 8 * *a1))
      {
        *a1 = *a2;
        *a2 = v14;
      }
    }
  }
  return result;
}

uint64_t *std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,LessByStringIndex &,long *>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6)
{
  BOOL result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,LessByStringIndex &,long *>(a1, a2, a3, a4, a6);
  uint64_t v13 = *a6;
  uint64_t v14 = *a4;
  if (*(void *)(*a6 + 8 * *a5) < *(void *)(*a6 + 8 * *a4))
  {
    *a4 = *a5;
    *a5 = v14;
    uint64_t v15 = *a3;
    if (*(void *)(v13 + 8 * *a4) < *(void *)(v13 + 8 * *a3))
    {
      *a3 = *a4;
      *a4 = v15;
      uint64_t v16 = *a2;
      if (*(void *)(v13 + 8 * *a3) < *(void *)(v13 + 8 * *a2))
      {
        *a2 = *a3;
        *a3 = v16;
        uint64_t v17 = *a1;
        if (*(void *)(v13 + 8 * *a2) < *(void *)(v13 + 8 * *a1))
        {
          *a1 = *a2;
          *a2 = v17;
        }
      }
    }
  }
  return result;
}

uint64_t TRun::FindGlyphIndex<true>(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3 = *(void *)(*(void *)(a1 + 216) + 48);
  uint64_t v5 = *(void *)(a1 + 200);
  uint64_t v4 = *(void *)(a1 + 208);
  uint64_t v6 = v3 + 8 * v5;
  char v7 = *(unsigned char *)(a1 + 224);
  if (v7) {
    int v8 = -a3;
  }
  else {
    int v8 = a3;
  }
  uint64_t v9 = v4 - 1;
  if (v8 < 0) {
    uint64_t v4 = -1;
  }
  else {
    uint64_t v9 = 0;
  }
  if (*(int *)(a1 + 256) >= 2)
  {
    if (v9 == v4)
    {
      LOBYTE(v11) = 1;
      uint64_t v12 = v9;
    }
    else
    {
      int v11 = 1;
      uint64_t v12 = v9;
      while (1)
      {
        uint64_t v16 = *(void *)(v6 + 8 * v9);
        if (v16 == a2) {
          break;
        }
        int v17 = (v16 < a2) & ((v16 > *(void *)(v6 + 8 * v12)) | v11);
        v11 &= v17 ^ 1;
        if (v17) {
          uint64_t v12 = v9;
        }
        v9 += v8;
        if (v4 == v9)
        {
          uint64_t v9 = v4;
          break;
        }
      }
    }
    if (v9 == v4) {
      uint64_t result = v12;
    }
    else {
      uint64_t result = v9;
    }
    if (v9 == v4)
    {
      if (v7) {
        int v19 = -1;
      }
      else {
        int v19 = 1;
      }
      uint64_t v20 = v4 - v8;
      if (v8 == v19) {
        uint64_t v20 = v12;
      }
      if (v11) {
        return v20;
      }
    }
  }
  else
  {
    if (v9 == v4)
    {
      uint64_t v10 = v9;
    }
    else
    {
      uint64_t v13 = *(void *)(v6 + 8 * v9);
      if (v13 >= a2)
      {
        uint64_t v15 = v9;
LABEL_36:
        if (v13 <= a2) {
          uint64_t v10 = v15;
        }
        else {
          uint64_t v10 = v9;
        }
      }
      else
      {
        uint64_t v14 = v3 + 8 * v5 + 8 * v8;
        while (v4 - v8 != v9)
        {
          uint64_t v15 = v9 + v8;
          uint64_t v13 = *(void *)(v14 + 8 * v9);
          uint64_t v9 = v15;
          if (v13 >= a2)
          {
            uint64_t v9 = v15 - v8;
            goto LABEL_36;
          }
        }
        uint64_t v10 = v4;
      }
    }
    if (v10 == v4) {
      return v9;
    }
    else {
      return v10;
    }
  }
  return result;
}

uint64_t TRunGlue::AdvanceInitialAdvance(TRunGlue *this, CGSize a2)
{
  double height = a2.height;
  double width = a2.width;
  if (*((void *)this + 19))
  {
    uint64_t v4 = *(void *)(*(void *)(*(void *)(*(void *)this + 16)
                               + 8 * TRunGlue::PhysicalRunIndexFromLogical(this, *((void *)this + 1)))
                   + 48);
    uint64_t v5 = *(void *)(v4 + 216);
    uint64_t v6 = *(void *)(v5 + 32);
    if (v6 || (uint64_t v13 = *(void *)(v5 + 24)) == 0)
    {
      char v7 = (double *)(v6 + 16 * *(void *)(v4 + 200));
      double v8 = v7[1];
    }
    else
    {
      char v7 = (double *)(v13 + 8 * *(void *)(v4 + 200));
      double v8 = 0.0;
    }
    v23.double width = width + *v7;
    v23.double height = height + v8;
    TStorageRange::SetAdvance((TStorageRange *)(v4 + 192), 0, v23);
    uint64_t v14 = (double *)MEMORY[0x1E4F1DAD8];
    if ((*(unsigned char *)(v4 + 225) & 0x10) != 0)
    {
      [*(id *)(v4 + 216) originAtIndex:*(void *)(v4 + 200)];
    }
    else
    {
      double v15 = *MEMORY[0x1E4F1DAD8];
      double v16 = *(double *)(MEMORY[0x1E4F1DAD8] + 8);
    }
    double v17 = width + v15;
    double v18 = height + v16;
    objc_msgSend(*(id *)(v4 + 216), "setOrigin:atIndex:", *(void *)(v4 + 200), v17, v18);
    if (v17 != *v14 || v18 != v14[1]) {
      *(unsigned char *)(v4 + 225) |= 0x10u;
    }
    return 1;
  }
  uint64_t v9 = (double *)*((void *)this + 24);
  if (v9)
  {
    uint64_t v10 = (double *)*((void *)this + 23);
    CGFloat v11 = a2.height + v10[1];
    *uint64_t v10 = a2.width + *v10;
    v10[1] = v11;
    double v12 = height + v9[1];
    *uint64_t v9 = a2.width + *v9;
    v9[1] = v12;
    return 1;
  }
  double v21 = *((double *)this + 68);
  if (fabs(v21) != INFINITY)
  {
    CGFloat v22 = a2.height + *((double *)this + 69);
    *((double *)this + 68) = width + v21;
    *((CGFloat *)this + 69) = v22;
    return 1;
  }
  return 0;
}

void *TKerningEngineImplementation::SetAdvance<TRunGlue::TGlyph>(void *a1, uint64_t a2, unsigned char *a3, double a4, double a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t result = TRunGlue::SetAdvance(a1, a2, *(CGSize *)&a4);
  if (a4 != *MEMORY[0x1E4F1DB30] || a5 != *(double *)(MEMORY[0x1E4F1DB30] + 8))
  {
    uint64_t result = (void *)TRunGlue::TGlyph::IsDeleted((TRunGlue::TGlyph *)v10);
    if (result) {
      *a3 = 1;
    }
  }
  return result;
}

uint64_t TKerningEngineImplementation::TransferDeletedAdvances(TRunGlue **this)
{
  uint64_t v2 = (CGSize *)MEMORY[0x1E4F1DB30];
  double width = *MEMORY[0x1E4F1DB30];
  double height = *(double *)(MEMORY[0x1E4F1DB30] + 8);
  uint64_t v5 = TRunGlue::length(*this);
  if (v5)
  {
    uint64_t v6 = v5 - 1;
    do
    {
      double v12 = *this;
      uint64_t v13 = v6;
      if (TRunGlue::TGlyph::IsDeleted((TRunGlue::TGlyph *)&v12))
      {
        double width = width + TRunGlue::GetAdvance(v12, v13);
        double height = height + v7;
        TRunGlue::SetAdvance(v12, v13, *v2);
      }
      else if (width != v2->width || height != v2->height)
      {
        v14.double width = width + TRunGlue::GetAdvance(v12, v13);
        v14.double height = height + v9;
        TRunGlue::SetAdvance(v12, v13, v14);
        double width = v2->width;
        double height = v2->height;
      }
      --v6;
    }
    while (v6 != -1);
  }
  if (width == v2->width && height == v2->height) {
    return 1;
  }
  v15.double width = width;
  v15.double height = height;
  uint64_t result = TRunGlue::AdvanceInitialAdvance(*this, v15);
  if (result) {
    return 1;
  }
  return result;
}

uint64_t TAATKerxEngine::KernRuns(uint64_t a1, unsigned char *a2, int *a3)
{
  uint64_t v233 = *MEMORY[0x1E4F143B8];
  int v4 = *a3;
  *a3 = 2;
  if (!TRunGlue::length(*(TRunGlue **)a1)) {
    return 1;
  }
  uint64_t v5 = *(void *)(a1 + 88);
  unsigned int v6 = *(_DWORD *)(v5 + 4);
  if (!v6) {
    return 1;
  }
  double v7 = (TRunGlue **)a1;
  unsigned int v8 = bswap32(v6);
  uint64_t v9 = v5 + 8;
  uint64_t v10 = *v7;
  CGFloat v11 = (TRunGlue *)*((void *)*v7 + 80);
  double v12 = (TRunGlue *)*((void *)*v7 + 81);
  v7[1] = v11;
  v7[2] = v12;
  if (*((unsigned char *)v10 + 634))
  {
    v7[1] = v12;
    v7[2] = v11;
  }
  uint64_t v13 = (TAATKerxEngine *)v7;
  uint64_t v14 = TRunGlue::length(v10);
  CGSize v15 = v13;
  uint64_t v193 = v14;
  unint64_t v16 = 0;
  if (v8 <= 1) {
    uint64_t v17 = 1;
  }
  else {
    uint64_t v17 = v8;
  }
  uint64_t v199 = v17;
  *(void *)&long long v18 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
  int8x16_t v194 = v13;
  int v191 = v4;
  do
  {
    int v19 = (unsigned int *)*((void *)v15 + 11);
    unint64_t v20 = *((void *)v15 + 12);
    double v21 = (unsigned int *)(v9 + 8);
    if ((unint64_t)v19 > v9 + 4 || (unint64_t)v21 > v20) {
      goto LABEL_257;
    }
    unint64_t v23 = v9 + bswap32(*(_DWORD *)v9);
    if (v23 > v20) {
      goto LABEL_257;
    }
    unsigned int v24 = bswap32(*(_DWORD *)(v9 + 4));
    if (*((unsigned char *)v15 + 104) != v24 >> 31) {
      goto LABEL_245;
    }
    if ((v24 & 0x40000000) != 0)
    {
      if (*((unsigned char *)v15 + 104)) {
        goto LABEL_245;
      }
    }
    else if (!v4 && v24 != 4)
    {
      goto LABEL_245;
    }
    uint64_t v25 = *((void *)v15 + 14);
    unint64_t v195 = v16;
    if (v16 < (*((void *)v15 + 15) - v25) >> 3)
    {
      uint64_t v26 = *(const unsigned __int8 **)(v25 + 8 * v16);
      if (v26)
      {
        BOOL v27 = TRunGlue::CoveredByBitmap(*(TRunGlue **)v15, v26, *(CFRange *)(*(void *)v15 + 8));
        CGSize v15 = v194;
        unint64_t v16 = v195;
        *(void *)&long long v18 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
        if (!v27) {
          goto LABEL_245;
        }
        int v19 = (unsigned int *)*((void *)v194 + 11);
      }
    }
    unint64_t v28 = v9 + 12;
    if (bswap32(*v19) < 0x40000)
    {
LABEL_25:
      unsigned int v29 = 0;
      goto LABEL_26;
    }
    unsigned int v29 = 0;
    if (v19 <= v21 && v28 <= *((void *)v15 + 12))
    {
      if (!*v21) {
        goto LABEL_25;
      }
      unsigned int v29 = bswap32(*v21);
      if (!*((void *)v15 + 48))
      {
        InitializedGraphicsFont = *(TBaseFont **)(*(void *)(*(void *)v15 + 616) + 400);
        if (InitializedGraphicsFont)
        {
          InitializedGraphicsFont = (TBaseFont *)TBaseFont::GetInitializedGraphicsFont(InitializedGraphicsFont);
          if (InitializedGraphicsFont) {
            InitializedGraphicsFont = (TBaseFont *)CGFontGetParserFont();
          }
          CGSize v15 = v194;
          unint64_t v16 = v195;
          *(void *)&long long v18 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
        }
        *((void *)v15 + 48) = InitializedGraphicsFont;
      }
    }
LABEL_26:
    if (v193 != 1)
    {
      switch((char)v24)
      {
        case 0:
          unint64_t v31 = *((void *)v15 + 12);
          unint64_t v32 = v9 + 28;
          if (v9 + 28 > v31) {
            goto LABEL_257;
          }
          long long v230 = v18;
          long long v231 = v18;
          long long v228 = v18;
          long long v229 = v18;
          *(_OWORD *)&v227[216] = v18;
          *(_OWORD *)&v227[232] = v18;
          *(_OWORD *)&v227[184] = v18;
          *(_OWORD *)&v227[200] = v18;
          *(_OWORD *)&v227[152] = v18;
          *(_OWORD *)&v227[168] = v18;
          *(_OWORD *)&v227[120] = v18;
          *(_OWORD *)&v227[136] = v18;
          *(_OWORD *)&v227[88] = v18;
          *(_OWORD *)&v227[104] = v18;
          *(_OWORD *)&v227[72] = v18;
          *(_OWORD *)&v227[24] = v18;
          *(_OWORD *)&v227[8] = v18;
          uint64_t v224 = (uint64_t)v15;
          uint64_t v225 = v9;
          unint64_t v226 = v9 + 12;
          *(void *)unint64_t v227 = v31;
          *(_DWORD *)&v227[8] = v24;
          memset(&v227[40], 0, 32);
          uint64_t v232 = &v227[72];
          LODWORD(v33) = bswap32(*(_DWORD *)(v9 + 12));
          unint64_t v34 = v32 + 6 * v33;
          if (v34 < v32 || v34 > v31)
          {
            if (v9 + 34 > v31) {
              LOWORD(v33) = 0;
            }
            else {
              unint64_t v33 = (v31 - v32) / 6;
            }
          }
          *(_WORD *)&v227[32] = v33;
          BOOL v35 = *(TRunGlue **)v15;
          uint64_t v36 = *(void *)(*(void *)v15 + 16);
          uint64_t v37 = TAATKerxEngine::KerxOrderedList::ProcessGlyphsT<TRunGlue::TGlyphInVector>;
          if (v36)
          {
            if (v36 == 1) {
              uint64_t v37 = TAATKerxEngine::KerxOrderedList::ProcessGlyphsT<TRunGlue::TGlyphInSingleRun>;
            }
            else {
              uint64_t v37 = TAATKerxEngine::KerxOrderedList::ProcessGlyphsT<TRunGlue::TGlyph>;
            }
          }
          *(void *)&v227[16] = v37;
          *(void *)&v227[24] = 0;
          if (v29)
          {
            std::vector<double,TInlineBufferAllocator<double,30ul>>::resize((uint64_t)&v227[48], v29);
            TAATKerxEngine::GetTupleScalars(v194, v29, *(double **)&v227[48]);
            BOOL v35 = *(TRunGlue **)v224;
          }
          uint64_t v180 = *(void *)(*((void *)v35 + 77) + 400);
          if (TBaseFont::GetGlyphCount((TBaseFont *)v180))
          {
            unint64_t v181 = (2 * v195) | 1;
            os_unfair_lock_lock_with_options();
            uint64_t v182 = *(void *)(v180 + 488);
            if (v181 >= (*(void *)(v180 + 496) - v182) >> 3 || (int16x8_t v183 = *(_WORD **)(v182 + 8 * v181)) == 0) {
              operator new[]();
            }
            *(_WORD *)&v227[34] = *v183;
            *(void *)&v227[40] = v183 + 1;
            os_unfair_lock_unlock((os_unfair_lock_t)(v180 + 444));
          }
          int16x8_t v184 = *(void (**)(void *, unsigned char *))&v227[16];
          int16x8_t v185 = (uint64_t *)((char *)&v224 + (*(uint64_t *)&v227[24] >> 1));
          if (v227[24]) {
            int16x8_t v184 = *(void (**)(void *, unsigned char *))(*v185 + *(unsigned int *)&v227[16]);
          }
          int v4 = v191;
          v184(v185, a2);
          int8x16_t v206 = (void ***)&v227[48];
          std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v206);
          goto LABEL_243;
        case 1:
          goto LABEL_48;
        case 2:
          uint64_t v83 = (SFNTLookupTable *)*((void *)v15 + 12);
          if (v9 + 28 > (unint64_t)v83) {
            goto LABEL_257;
          }
          *(void *)&v227[104] = v18;
          *(_OWORD *)&v227[120] = v18;
          *(_OWORD *)&v227[88] = v18;
          *(_OWORD *)&v227[40] = v18;
          *(void *)&v227[64] = *((void *)&v18 + 1);
          *(_DWORD *)&v227[12] = DWORD1(v18);
          *(void *)&v227[32] = *((void *)&v18 + 1);
          uint64_t v224 = (uint64_t)v15;
          uint64_t v225 = v9;
          unint64_t v226 = v9 + 12;
          *(void *)unint64_t v227 = v83;
          *(_DWORD *)&v227[8] = v24;
          *(void *)&v227[16] = TAATLookupTable::BadTable;
          *(void *)&v227[24] = 0;
          *(void *)&v227[56] = 0;
          *(_WORD *)&v227[64] = -1;
          *(void *)&v227[72] = TAATLookupTable::BadTable;
          *(void *)&v227[80] = 0;
          *(void *)&v227[112] = 0;
          *(_WORD *)&v227[120] = -1;
          TAATLookupTable::SetTable((uint64_t)&v227[16], (const SFNTLookupTable *)(v9 + bswap32(*(_DWORD *)(v9 + 16))), v83);
          TAATLookupTable::SetTable((uint64_t)&v227[72], (const SFNTLookupTable *)(v225 + bswap32(*(_DWORD *)(v9 + 20))), v83);
          *(void *)&v227[128] = v225 + bswap32(*(_DWORD *)(v9 + 24));
          uint64_t v84 = *(TRunGlue **)v224;
          uint64_t v85 = TRunGlue::length(*(TRunGlue **)v224);
          if (*((void *)v84 + 19))
          {
            TRunGlue::FocusOnIndex(v84, 0);
            uint64_t v86 = (unsigned __int16 *)(*((void *)v84 + 22) - 2 * *((void *)v84 + 20));
          }
          else
          {
            uint64_t v86 = (unsigned __int16 *)(*((void *)v84 + 22) + 2 * *((void *)v84 + 20));
          }
          CGSize v15 = v194;
          unint64_t v16 = v195;
          *(void *)&long long v18 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
          if (v85 <= 1) {
            goto LABEL_245;
          }
          uint64_t v156 = *v86;
          uint64_t v157 = 1;
          break;
        case 4:
          goto LABEL_105;
        case 6:
          uint64_t v87 = (SFNTLookupTable *)*((void *)v15 + 12);
          if (v9 + 36 > (unint64_t)v87) {
            goto LABEL_257;
          }
          unint64_t v221 = 0xAAAAAAAAAAAAFFFFLL;
          long long v222 = v18;
          v218[2] = 0xAAAAAAAAAAAAAAAALL;
          long long v219 = v18;
          unint64_t v215 = 0xAAAAAAAAAAAAAAAALL;
          unint64_t v217 = 0xAAAAAAAAAAAAFFFFLL;
          long long v214 = v18;
          int8x16_t v206 = (void ***)v15;
          uint64_t v207 = v9;
          uint64_t v208 = v9 + 12;
          int16x8_t v209 = v87;
          unsigned int v210 = v24;
          v213[0] = TAATLookupTable::BadTable;
          v213[1] = 0;
          uint64_t v216 = 0;
          v218[0] = TAATLookupTable::BadTable;
          v218[1] = 0;
          uint64_t v220 = 0;
          __int16 v211 = bswap32(*(unsigned __int16 *)(v9 + 16)) >> 16;
          __int16 v212 = bswap32(*(unsigned __int16 *)(v9 + 18)) >> 16;
          uint64_t v88 = v15;
          TAATLookupTable::SetTable((uint64_t)v213, (const SFNTLookupTable *)(v9 + bswap32(*(_DWORD *)(v9 + 20))), v87);
          TAATLookupTable::SetTable((uint64_t)v218, (const SFNTLookupTable *)(v207 + bswap32(*(_DWORD *)(v9 + 24))), v87);
          *(void *)&long long v222 = v207 + bswap32(*(_DWORD *)(v9 + 28));
          *((void *)&v222 + 1) = v207 + bswap32(*(_DWORD *)(v9 + 32));
          if (v29 > 3)
          {
            *(void *)&long long v155 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v155 + 1) = 0xAAAAAAAAAAAAAAAALL;
            *(_OWORD *)&v227[208] = v155;
            *(_OWORD *)&v227[224] = v155;
            *(_OWORD *)&v227[176] = v155;
            *(_OWORD *)&v227[192] = v155;
            *(_OWORD *)&v227[144] = v155;
            *(_OWORD *)&v227[160] = v155;
            *(_OWORD *)&v227[112] = v155;
            *(_OWORD *)&v227[128] = v155;
            *(_OWORD *)&v227[80] = v155;
            *(_OWORD *)&v227[96] = v155;
            *(_OWORD *)&v227[48] = v155;
            *(_OWORD *)&v227[64] = v155;
            *(_OWORD *)&v227[16] = v155;
            *(_OWORD *)&v227[32] = v155;
            *(_OWORD *)unint64_t v227 = v155;
            uint64_t v225 = 0;
            unint64_t v226 = 0;
            uint64_t v224 = 0;
            *(void *)&v227[240] = v227;
            std::vector<double,TInlineBufferAllocator<double,30ul>>::resize((uint64_t)&v224, v29);
            TAATKerxEngine::ProcessKerxIndexArrayWithTupleScalars(v88, v9 + 12, &v206, v29, (double *)v224, a2);
            int v223 = (void **)&v224;
            std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](&v223);
          }
          else
          {
            uint64_t v225 = -1;
            unint64_t v226 = -1;
            uint64_t v224 = -1;
            TAATKerxEngine::ProcessKerxIndexArrayWithTupleScalars(v88, v9 + 12, &v206, v29, (double *)&v224, a2);
          }
          unint64_t v16 = v195;
          *(void *)&long long v18 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
          CGSize v15 = v88;
          goto LABEL_245;
        default:
          goto LABEL_245;
      }
      while (1)
      {
        uint64_t GlyphID = TRunGlue::GetGlyphID(v84, v157);
        if (GlyphID == 0xFFFF || (uint64_t v159 = GlyphID, TRunGlue::IsDeleted(v84, v157)))
        {
          uint64_t v159 = v156;
          unint64_t v16 = v195;
          *(void *)&long long v18 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
        }
        else
        {
          int8x16_t v206 = (void ***)0xAAAAAAAAAAAAAAAALL;
          int16x8_t v160 = *(uint64_t (**)(void *, void, void ****))&v227[16];
          int16x8_t v161 = &v227[(*(uint64_t *)&v227[24] >> 1) + 16];
          if (v227[24]) {
            int16x8_t v160 = *(uint64_t (**)(void *, void, void ****))(*v161 + *(unsigned int *)&v227[16]);
          }
          int16x8_t v162 = (char *)v160(v161, (unsigned __int16)v156, &v206);
          if (!v162) {
            goto LABEL_208;
          }
          int16x8_t v163 = v206;
          int16x8_t v164 = &v162[(void)v206];
          if (v226 > (unint64_t)v162 || v164 < v162 || (unint64_t)v164 > *(void *)v227) {
            goto LABEL_243;
          }
          if (v206)
          {
            int v167 = 0;
            do
            {
              int v168 = *v162++;
              int v167 = v168 | (v167 << 8);
              int16x8_t v163 = (void ***)((char *)v163 - 1);
            }
            while (v163);
          }
          else
          {
LABEL_208:
            int v167 = 0;
          }
          int v223 = (void **)0xAAAAAAAAAAAAAAAALL;
          int16x8_t v169 = *(uint64_t (**)(void *, uint64_t, void ***))&v227[72];
          int16x8_t v170 = &v227[(*(uint64_t *)&v227[80] >> 1) + 72];
          if (v227[80]) {
            int16x8_t v169 = *(uint64_t (**)(void *, uint64_t, void ***))(*v170 + *(unsigned int *)&v227[72]);
          }
          int16x8_t v171 = (char *)v169(v170, v159, &v223);
          if (v171)
          {
            int16x8_t v172 = v223;
            long long v173 = &v171[(void)v223];
            BOOL v175 = v226 > (unint64_t)v171 || v173 < v171 || (unint64_t)v173 > *(void *)v227;
            *(void *)&long long v18 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
            if (v175)
            {
LABEL_248:
              unint64_t v16 = v195;
              goto LABEL_244;
            }
            int v176 = 0;
            if (v223)
            {
              do
              {
                int v177 = *v171++;
                int v176 = v177 | (v176 << 8);
                int16x8_t v172 = (void **)((char *)v172 - 1);
              }
              while (v172);
            }
          }
          else
          {
            int v176 = 0;
            *(void *)&long long v18 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
          }
          int16x8_t v178 = (_WORD *)(*(void *)&v227[128] + (v176 + v167));
          if (v226 > (unint64_t)v178 || (unint64_t)(v178 + 1) > *(void *)v227) {
            goto LABEL_248;
          }
          if (*v178)
          {
            TAATKerxEngine::HandleKern<TRunGlue::TGlyph>((void *)v224, (uint64_t)v84, v157, (int)bswap32((unsigned __int16)*v178) >> 16, *(int *)&v227[8]);
            *(void *)&long long v18 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
            *a2 = 1;
          }
          unint64_t v16 = v195;
        }
        CGSize v15 = v194;
        ++v157;
        uint64_t v156 = v159;
        if (v157 == v85) {
          goto LABEL_245;
        }
      }
    }
    if (v24 == 1)
    {
LABEL_48:
      uint64_t v38 = (SFNTLookupTable *)*((void *)v15 + 12);
      if (v9 + 32 > (unint64_t)v38)
      {
LABEL_257:
        size_t v188 = v15;
        uint64_t v190 = TFont::DebugDescription(*(TFont **)(*(void *)v15 + 616));
        CFLog();

        uint64_t v189 = *(void *)(*(void *)(*(void *)v188 + 616) + 400);
        (*(void (**)(uint64_t))(*(void *)v189 + 488))(v189);
        uint64_t result = 0;
        *((void *)v188 + 11) = 0;
        return result;
      }
      *(_OWORD *)&v227[136] = v18;
      *(_OWORD *)&v227[152] = v18;
      *(_OWORD *)&v227[104] = v18;
      *(_OWORD *)&v227[120] = v18;
      *(void *)&v227[80] = *((void *)&v18 + 1);
      *(_OWORD *)&v227[88] = v18;
      *(void *)&v227[48] = *((void *)&v18 + 1);
      *(_OWORD *)&v227[56] = v18;
      *(_OWORD *)&v227[8] = v18;
      *(void *)&v227[24] = v18;
      uint64_t v224 = (uint64_t)v15;
      uint64_t v225 = v9;
      unint64_t v226 = v9 + 12;
      *(void *)unint64_t v227 = v38;
      *(_DWORD *)&v227[8] = v24;
      *(void *)&v227[32] = TAATLookupTable::BadTable;
      *(void *)&v227[40] = 0;
      *(void *)&v227[72] = 0;
      *(_WORD *)&v227[80] = -1;
      *(_WORD *)&v227[88] = bswap32(*(_DWORD *)(v9 + 12));
      *(void *)&v227[16] = v28 + bswap32(*(_DWORD *)(v9 + 20));
      *(void *)&v227[24] = v28 + bswap32(*(_DWORD *)(v9 + 24));
      TAATLookupTable::SetTable((uint64_t)&v227[32], (const SFNTLookupTable *)(v28 + bswap32(*(_DWORD *)(v9 + 16))), v38);
      uint64_t v39 = 0;
      *(_WORD *)&v227[90] = 0;
      memset(&v227[96], 0, 64);
      *(void *)&v227[160] = -1;
      unint64_t v40 = v226;
      unsigned int v41 = *(_DWORD *)(v226 + 16);
      if ((*(_DWORD *)&v227[8] & 0x10000000) != 0) {
        uint64_t v42 = -1;
      }
      else {
        uint64_t v42 = 1;
      }
      uint64_t v43 = *(TRunGlue **)v224;
      int16x8_t v201 = *(TRunGlue **)v224;
      if ((*(_DWORD *)&v227[8] & 0x10000000) != 0)
      {
        uint64_t v39 = (void **)(TRunGlue::length(v201) - 1);
        uint64_t v43 = *(TRunGlue **)v224;
      }
      unint64_t v203 = v40 + bswap32(v41);
      uint64_t v44 = TRunGlue::length(v43);
      int v45 = 0;
      LOWORD(v46) = 0;
      *(void *)&long long v18 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
      while (2)
      {
        if (v44 < 1)
        {
          if (((v44 == 0) & (v45 ^ 1)) == 0) {
            goto LABEL_113;
          }
        }
        else if ((v45 & 1) == 0)
        {
          uint64_t v47 = TRunGlue::GetGlyphID(v201, (uint64_t)v39);
          if (v47 == 0xFFFF)
          {
            int v45 = 0;
            unsigned int v51 = 2;
          }
          else
          {
            uint64_t v48 = v47;
            int8x16_t v206 = (void ***)0xAAAAAAAAAAAAAAAALL;
            uint64_t v49 = *(uint64_t (**)(void *, uint64_t, void ****))&v227[32];
            uint64_t v50 = &v227[(*(uint64_t *)&v227[40] >> 1) + 32];
            if (v227[40]) {
              uint64_t v49 = *(uint64_t (**)(void *, uint64_t, void ****))(*v50 + *(unsigned int *)&v227[32]);
            }
            BOOL v52 = (unsigned __int16 *)v49(v50, v48, &v206);
            int v45 = 0;
            if (v52) {
              unsigned int v51 = bswap32(*v52) >> 16;
            }
            else {
              unsigned int v51 = 1;
            }
          }
          *(void *)&long long v18 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
          goto LABEL_68;
        }
        int v45 = 1;
        unsigned int v51 = *(unsigned __int16 *)&v227[90];
LABEL_68:
        uint64_t v53 = (unsigned __int16 *)(*(void *)&v227[16]
                                 + 2 * (*(unsigned __int16 *)&v227[88] * (unint64_t)(unsigned __int16)v46 + v51));
        BOOL v54 = v226 > (unint64_t)v53 || (unint64_t)(v53 + 1) > *(void *)v227;
        if (v54
          || ((unsigned int v55 = bswap32(*v53) >> 16,
               uint64_t v56 = *(void *)&v227[24],
               uint64_t v57 = (unsigned __int16 *)(*(void *)&v227[24] + 6 * v55),
               v226 <= (unint64_t)v57)
            ? (BOOL v58 = (unint64_t)(v57 + 3) > *(void *)v227)
            : (BOOL v58 = 1),
              v58))
        {
LABEL_113:
          int v4 = v191;
          unint64_t v16 = v195;
          goto LABEL_244;
        }
        unsigned int v59 = *v57;
        unsigned int v60 = bswap32(*(unsigned __int16 *)(*(void *)&v227[24] + 6 * v55 + 2));
        if ((v60 & 0x80000000) != 0)
        {
          if (*(uint64_t *)&v227[160] <= 6) {
            uint64_t v61 = *(void *)&v227[160] + 1;
          }
          else {
            uint64_t v61 = 0;
          }
          *(void *)&v227[160] = v61;
          *(void *)&v227[8 * v61 + 96] = v39;
        }
        unsigned int v62 = HIWORD(v60);
        if ((v60 & 0x20000000) != 0)
        {
          int v223 = v39;
          int8x16_t v206 = &v223;
          uint64_t v63 = std::__tree<std::__value_type<long,TAATDeltaYListEntry>,std::__map_value_compare<long,std::__value_type<long,TAATDeltaYListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TAATDeltaYListEntry>>>::__emplace_unique_key_args<long,std::piecewise_construct_t const&,std::tuple<long &&>,std::tuple<>>((uint64_t **)(v224 + 48), (uint64_t *)&v223, (uint64_t)&std::piecewise_construct, &v206);
          *(void *)&long long v18 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
          *((unsigned char *)v63 + 42) = 1;
          *((_WORD *)v63 + 20) = 0;
        }
        unsigned int v64 = *(unsigned __int16 *)(v56 + 6 * v55 + 4);
        if (v64 != 0xFFFF)
        {
          uint64_t v65 = *(void *)&v227[160];
          if ((*(void *)&v227[160] & 0x8000000000000000) == 0)
          {
            unint64_t v66 = v203 + 2 * __rev16(v64);
            unint64_t v67 = v226;
            unint64_t v68 = *(void *)v227;
            unint64_t v69 = v66 + 2;
            if (v226 > v66 || v69 > *(void *)v227) {
              goto LABEL_113;
            }
            while (1)
            {
              unsigned int v71 = *(unsigned __int16 *)(v69 - 2);
              if (v71 == 0xFFFF) {
                break;
              }
              if (v65 >= 1) {
                uint64_t v72 = v65 - 1;
              }
              else {
                uint64_t v72 = 7;
              }
              if (*(_WORD *)(v69 - 2))
              {
                uint64_t v73 = *(void *)&v227[8 * v65 + 96];
                if ((v73 & 0x8000000000000000) == 0)
                {
                  TAATKerxEngine::HandleKern<TRunGlue::TGlyph>((void *)v224, *(void *)v224, v73, (__int16)__rev16(v71), *(int *)&v227[8]);
                  *(void *)&long long v18 = 0xAAAAAAAAAAAAAAAALL;
                  *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
                  *a2 = 1;
                  unint64_t v67 = v226;
                  unint64_t v68 = *(void *)v227;
                }
              }
              if (v67 <= v69)
              {
                v69 += 2;
                uint64_t v65 = v72;
                if (v69 <= v68) {
                  continue;
                }
              }
              goto LABEL_113;
            }
          }
        }
        unsigned int v46 = bswap32(v59) >> 16;
        if (v45) {
          uint64_t v74 = 0;
        }
        else {
          uint64_t v74 = v42;
        }
        if ((v62 & 0x4000) != 0) {
          uint64_t v74 = 0;
        }
        uint64_t v39 = (void **)((char *)v39 + v74);
        v44 -= (v62 & 0x4000) == 0;
        continue;
      }
    }
    if (v24 == 4)
    {
LABEL_105:
      uint64_t v75 = (SFNTLookupTable *)*((void *)v15 + 12);
      if (v9 + 32 > (unint64_t)v75) {
        goto LABEL_257;
      }
      *(void *)&v227[80] = 0xAAAAAAAAAAAAFFFFLL;
      *(_OWORD *)&v227[88] = v18;
      *(void *)&v227[48] = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)&v227[56] = v18;
      *(_OWORD *)&v227[8] = v18;
      *(void *)&v227[24] = 0xAAAAAAAAAAAAAAAALL;
      uint64_t v224 = (uint64_t)v15;
      uint64_t v225 = v9;
      unint64_t v226 = v9 + 12;
      *(void *)unint64_t v227 = v75;
      *(_DWORD *)&v227[8] = v24;
      *(void *)&v227[32] = TAATLookupTable::BadTable;
      *(void *)&v227[40] = 0;
      *(void *)&v227[72] = 0;
      *(_WORD *)&v227[88] = bswap32(*(_DWORD *)(v9 + 12));
      *(void *)&v227[16] = v28 + bswap32(*(_DWORD *)(v9 + 20));
      *(void *)&v227[24] = v28 + bswap32(*(_DWORD *)(v9 + 24));
      TAATLookupTable::SetTable((uint64_t)&v227[32], (const SFNTLookupTable *)(v28 + bswap32(*(_DWORD *)(v9 + 16))), v75);
      *(_WORD *)&v227[90] = 0;
      *(void *)&v227[96] = -1;
      unsigned int v76 = bswap32(*(_DWORD *)(v226 + 16));
      unsigned int v77 = v76 & 0xC0000000;
      if ((v76 & 0xC0000000) == 0x40000000)
      {
        uint64_t v89 = (id **)v224;
        if (*(void *)(v224 + 400)) {
          goto LABEL_124;
        }
        int64_t v90 = (TAATAnkrTable *)operator new(0x58uLL, MEMORY[0x1E4FBA2D0]);
        int64_t v91 = (id *)v90;
        if (v90) {
          TAATAnkrTable::TAATAnkrTable(v90, (const TFont *)(*v89)[77]);
        }
        std::unique_ptr<TAATAnkrTable>::reset[abi:nn180100](v89 + 50, v91);
        unint64_t v16 = v195;
        *(void *)&long long v18 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
        if (v89[50])
        {
LABEL_124:
          uint64_t v92 = 1;
          if ((*(_DWORD *)&v227[8] & 0x10000000) != 0) {
            uint64_t v92 = -1;
          }
          uint64_t v204 = v92;
          uint64_t v93 = *(TRunGlue **)v224;
          int v196 = *(_DWORD *)&v227[8];
          unint64_t v192 = v23;
          if ((*(_DWORD *)&v227[8] & 0x10000000) != 0) {
            uint64_t v94 = TRunGlue::length(v93) - 1;
          }
          else {
            uint64_t v94 = 0;
          }
          uint64_t v198 = v76 & 0xFFFFFF;
          uint64_t v95 = TRunGlue::length(*(TRunGlue **)v224);
          char v96 = 0;
          LOWORD(v97) = 0;
          *(void *)&long long v18 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
          unsigned int v197 = v76 & 0xC0000000;
          while (2)
          {
            if (v95 < 1)
            {
              if ((v95 != 0) | v96 & 1) {
                goto LABEL_185;
              }
            }
            else if ((v96 & 1) == 0)
            {
              uint64_t v98 = TRunGlue::GetGlyphID(v93, v94);
              if (v98 == 0xFFFF)
              {
                char v96 = 0;
                unsigned int v102 = 2;
              }
              else
              {
                uint64_t v99 = v98;
                int8x16_t v206 = (void ***)0xAAAAAAAAAAAAAAAALL;
                CFRange v100 = *(uint64_t (**)(void *, uint64_t, void ****))&v227[32];
                uint64_t v101 = &v227[(*(uint64_t *)&v227[40] >> 1) + 32];
                if (v227[40]) {
                  CFRange v100 = *(uint64_t (**)(void *, uint64_t, void ****))(*v101 + *(unsigned int *)&v227[32]);
                }
                BOOL v103 = (unsigned __int16 *)v100(v101, v99, &v206);
                char v96 = 0;
                if (v103) {
                  unsigned int v102 = bswap32(*v103) >> 16;
                }
                else {
                  unsigned int v102 = 1;
                }
              }
              *(void *)&long long v18 = 0xAAAAAAAAAAAAAAAALL;
              *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
LABEL_143:
              uint64_t v104 = (unsigned __int16 *)(*(void *)&v227[16]
                                        + 2
                                        * (*(unsigned __int16 *)&v227[88] * (unint64_t)(unsigned __int16)v97
                                         + v102));
              BOOL v105 = v226 > (unint64_t)v104 || (unint64_t)(v104 + 1) > *(void *)v227;
              if (v105
                || ((unsigned int v106 = bswap32(*v104) >> 16,
                     CFRange v107 = (unsigned __int16 *)(*(void *)&v227[24] + 6 * v106),
                     v226 <= (unint64_t)v107)
                  ? (BOOL v108 = (unint64_t)(v107 + 3) > *(void *)v227)
                  : (BOOL v108 = 1),
                    v108))
              {
LABEL_185:
                CGSize v15 = v194;
                unint64_t v16 = v195;
                int v4 = v191;
                unint64_t v23 = v192;
                goto LABEL_245;
              }
              unsigned int v109 = *v107;
              int v110 = (int)bswap32(*(unsigned __int16 *)(*(void *)&v227[24] + 6 * v106 + 2)) >> 16;
              if (v110 < 0) {
                *(void *)&v227[96] = v94;
              }
              unsigned int v111 = *(unsigned __int16 *)(*(void *)&v227[24] + 6 * v106 + 4);
              if (v111 == 0xFFFF || *(void *)&v227[96] == -1) {
                goto LABEL_182;
              }
              uint64_t v112 = __rev16(v111);
              unsigned int v200 = v109;
              char v202 = v96;
              if (v77 == 0x40000000)
              {
                uint64_t v118 = v226 + v198;
                uint64_t v119 = (unsigned __int16 *)(v226 + v198 + 4 * v112);
                if (v226 > (unint64_t)v119 || (unint64_t)(v119 + 2) > *(void *)v227) {
                  goto LABEL_185;
                }
                uint64_t v121 = v224;
                unsigned int v122 = bswap32(*v119) >> 16;
                uint64_t v123 = TRunGlue::GetGlyphID(*(TRunGlue **)v224, *(uint64_t *)&v227[96]);
                double ControlPointCoordinates = TAATAnkrTable::GetControlPointCoordinates(*(TAATAnkrTable **)(v121 + 400), v123, v122);
                double v126 = v125;
                unsigned int v127 = bswap32(*(unsigned __int16 *)(v118 + 4 * v112 + 2)) >> 16;
                uint64_t v128 = v224;
                uint64_t v129 = TRunGlue::GetGlyphID(v93, v94);
                double v130 = TAATAnkrTable::GetControlPointCoordinates(*(TAATAnkrTable **)(v128 + 400), v129, v127);
              }
              else
              {
                if (v77)
                {
                  if (v77 != 0x80000000) {
                    goto LABEL_185;
                  }
                  unint64_t v113 = (unsigned __int16 *)(v226 + v198 + 8 * v112);
                  if (v226 > (unint64_t)v113 || (unint64_t)(v113 + 4) > *(void *)v227) {
                    goto LABEL_185;
                  }
                  uint64_t v115 = (unsigned __int16 *)(v226 + v198 + 8 * v112);
                  unsigned int v116 = (bswap32(*v113) >> 16) - (bswap32(v115[2]) >> 16);
                  unsigned int v117 = (bswap32(v115[1]) >> 16) - (bswap32(v115[3]) >> 16);
LABEL_174:
                  uint64_t v142 = v224;
                  int8x16_t v143 = *(TRunGlue **)v224;
                  uint64_t v144 = *(void *)&v227[96];
                  double v145 = TRunGlue::GetOrigin(*(TRunGlue **)v224, *(uint64_t *)&v227[96])
                       + *(double *)(v142 + 8) * (double)(__int16)v116;
                  double v147 = v146 + *(double *)(v142 + 16) * (double)(__int16)v117;
                  TRunGlue::ClearGlyphCombiningMark(v93, v94);
                  if ((v196 & 0x10000000) != 0)
                  {
                    if (v94 != v144)
                    {
                      uint64_t v151 = v94;
                      do
                      {
                        double v145 = v145 + TRunGlue::GetAdvance(v93, v151);
                        double v147 = v147 + v152;
                        ++v151;
                      }
                      while (v144 != v151);
                    }
                  }
                  else
                  {
                    double v148 = *MEMORY[0x1E4F1DB30];
                    double v149 = *(double *)(MEMORY[0x1E4F1DB30] + 8);
                    if (v144 < v94)
                    {
                      do
                      {
                        double v148 = v148 + TRunGlue::GetAdvance(v143, v144);
                        double v149 = v149 + v150;
                        ++v144;
                      }
                      while (v94 != v144);
                    }
                    double v145 = v145 - v148;
                    double v147 = v147 - v149;
                  }
                  v235.double x = v145;
                  v235.double y = v147;
                  TRunGlue::SetOrigin(v93, v94, v235);
                  *a2 = 1;
                  *(void *)&long long v18 = 0xAAAAAAAAAAAAAAAALL;
                  *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
                  unsigned int v77 = v197;
                  unsigned int v109 = v200;
                  char v96 = v202;
LABEL_182:
                  unsigned int v97 = bswap32(v109) >> 16;
                  uint64_t v153 = (v110 & 0x4000) == 0;
                  uint64_t v154 = v204;
                  if ((((unint64_t)v95 > 1) & v153) == 0) {
                    uint64_t v154 = 0;
                  }
                  v94 += v154;
                  v95 -= v153;
                  continue;
                }
                uint64_t v132 = v226 + v198;
                CFIndex v133 = (unsigned __int16 *)(v226 + v198 + 4 * v112);
                if (v226 > (unint64_t)v133 || (unint64_t)(v133 + 2) > *(void *)v227) {
                  goto LABEL_185;
                }
                uint64_t v135 = v224;
                unsigned int v136 = bswap32(*v133) >> 16;
                int v137 = TRunGlue::GetGlyphID(*(TRunGlue **)v224, *(uint64_t *)&v227[96]);
                double ControlPointCoordinates = TAATControlPointAccess::GetControlPointCoordinates(*(TAATControlPointAccess **)(v135 + 392), v137, v136);
                double v126 = v138;
                unsigned int v139 = bswap32(*(unsigned __int16 *)(v132 + 4 * v112 + 2)) >> 16;
                uint64_t v140 = v224;
                int v141 = TRunGlue::GetGlyphID(v93, v94);
                double v130 = TAATControlPointAccess::GetControlPointCoordinates(*(TAATControlPointAccess **)(v140 + 392), v141, v139);
              }
              unsigned int v116 = (int)(ControlPointCoordinates - v130);
              unsigned int v117 = (int)(v126 - v131);
              goto LABEL_174;
            }
            break;
          }
          char v96 = 1;
          unsigned int v102 = *(unsigned __int16 *)&v227[90];
          goto LABEL_143;
        }
      }
      else
      {
        if (v77) {
          goto LABEL_124;
        }
        uint64_t v78 = (void *)v224;
        if (*(void *)(v224 + 392)) {
          goto LABEL_124;
        }
        uint64_t v79 = (double *)(v224 + 392);
        uint64_t v80 = (TAATControlPointAccess *)operator new(0x448uLL, MEMORY[0x1E4FBA2D0]);
        if (v80)
        {
          TAATControlPointAccess::TAATControlPointAccess(v80, *(const TBaseFont **)(*(void *)(*v78 + 616) + 400));
          unint64_t v81 = (void **)v78[49];
          v78[49] = v82;
          if (!v81) {
            goto LABEL_124;
          }
          std::default_delete<TAATControlPointAccess>::operator()[abi:nn180100]((uint64_t)(v78 + 49), v81);
          *(void *)&long long v18 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
          unint64_t v16 = v195;
          if (*(void *)v79) {
            goto LABEL_124;
          }
        }
        else
        {
          *uint64_t v79 = 0.0;
LABEL_243:
          unint64_t v16 = v195;
          *(void *)&long long v18 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
        }
      }
LABEL_244:
      CGSize v15 = v194;
    }
LABEL_245:
    ++v16;
    uint64_t v9 = v23;
  }
  while (v16 != v199);
  int16x8_t v186 = (char *)v15 + 72;
  uint64_t result = TKerningEngineImplementation::MergeDeltas((TRunGlue **)v15, (void *)v15 + 3, (void *)v15 + 6, a2, (unsigned char *)v15 + 72);
  if (!result) {
    return result;
  }
  if (!*v186) {
    return 1;
  }

  return TKerningEngineImplementation::TransferDeletedAdvances((TRunGlue **)v194);
}

void TAATKerxEngine::GetTupleScalars(TAATKerxEngine *this, uint64_t a2, double *a3)
{
  *a3 = 1.0;
  uint64_t v5 = *(void *)(*(void *)this + 616);
  unsigned int v6 = (os_unfair_lock_s *)(v5 + 416);
  os_unfair_lock_lock_with_options();
  unint64_t v7 = a2 - 1;
  unsigned int v8 = *(const void **)(v5 + 424);
  if (v7 <= (uint64_t)(*(void *)(v5 + 432) - (void)v8) >> 3)
  {
    if (!v7) {
      goto LABEL_5;
    }
  }
  else
  {
    uint64_t v9 = (const void **)(v5 + 424);
    std::vector<double>::resize((uint64_t)v9, v7);
    FPFontGetVariationScalars();
    unsigned int v8 = *v9;
  }
  memmove(a3 + 1, v8, 8 * v7);
LABEL_5:

  os_unfair_lock_unlock(v6);
}

void std::vector<double>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 8 * a2;
    }
  }
  else
  {
    std::vector<double>::__append((char **)a1, a2 - v2);
  }
}

void TAATKerxEngine::ProcessKerxIndexArrayWithTupleScalars(TAATKerxEngine *a1, uint64_t a2, void ***a3, unsigned int a4, double *a5, unsigned char *a6)
{
  if (a4)
  {
    unint64_t v99 = a4;
    TAATKerxEngine::GetTupleScalars(a1, a4, a5);
  }
  else
  {
    unint64_t v99 = 0;
  }
  if (*((_WORD *)a3 + 18)) {
    BOOL v10 = *((unsigned __int16 *)a3 + 19) == 0;
  }
  else {
    BOOL v10 = 1;
  }
  char v11 = v10;
  if (*(unsigned char *)(a2 + 3))
  {
    if ((v11 & 1) == 0)
    {
      CGSize v15 = (TRunGlue *)**a3;
      uint64_t v16 = TRunGlue::length(v15);
      if (*((void *)v15 + 19))
      {
        TRunGlue::FocusOnIndex(v15, 0);
        uint64_t v17 = (unsigned __int16 *)(*((void *)v15 + 22) - 2 * *((void *)v15 + 20));
      }
      else
      {
        uint64_t v17 = (unsigned __int16 *)(*((void *)v15 + 22) + 2 * *((void *)v15 + 20));
      }
      if (v16 >= 2)
      {
        uint64_t v56 = *v17;
        uint64_t v57 = v99;
        if (v99 <= 1) {
          uint64_t v57 = 1;
        }
        uint64_t v98 = v57;
        for (uint64_t i = 1; i != v16; ++i)
        {
          uint64_t GlyphID = TRunGlue::GetGlyphID(v15, i);
          if (GlyphID == 0xFFFF || (uint64_t v60 = GlyphID, TRunGlue::IsDeleted(v15, i)))
          {
            uint64_t v60 = v56;
          }
          else
          {
            unint64_t v102 = 0xAAAAAAAAAAAAAAAALL;
            uint64_t v61 = a3[5];
            uint64_t v62 = (uint64_t)a3[6];
            uint64_t v63 = (void ***)((char *)a3 + (v62 >> 1) + 40);
            if (v62) {
              uint64_t v61 = *(void ***)(*v63 + v61);
            }
            unsigned int v64 = (unsigned __int8 *)((uint64_t (*)(void *, void, unint64_t *))v61)(v63, (unsigned __int16)v56, &v102);
            unint64_t v65 = v102;
            int v66 = 0;
            if (v64) {
              BOOL v67 = v102 == 0;
            }
            else {
              BOOL v67 = 1;
            }
            if (!v67)
            {
              do
              {
                int v68 = *v64++;
                int v66 = v68 | (v66 << 8);
                --v65;
              }
              while (v65);
            }
            unint64_t v101 = 0xAAAAAAAAAAAAAAAALL;
            unint64_t v69 = a3[12];
            uint64_t v70 = (uint64_t)a3[13];
            unsigned int v71 = (void ***)((char *)a3 + (v70 >> 1) + 96);
            if (v70) {
              unint64_t v69 = *(void ***)(*v71 + v69);
            }
            uint64_t v72 = (unsigned __int8 *)((uint64_t (*)(void *, uint64_t, unint64_t *))v69)(v71, v60, &v101);
            unint64_t v73 = v101;
            int v74 = 0;
            if (v72) {
              BOOL v75 = v101 == 0;
            }
            else {
              BOOL v75 = 1;
            }
            if (!v75)
            {
              do
              {
                int v76 = *v72++;
                int v74 = v76 | (v74 << 8);
                --v73;
              }
              while (v73);
            }
            uint64_t v77 = (v74 + v66);
            if (v74 + v66)
            {
              uint64_t v78 = a3[19];
              uint64_t v79 = a3[2];
              unint64_t v80 = (unint64_t)a3[3];
              if (a4)
              {
                unint64_t v81 = (unsigned int *)v78 + v77;
                if (v79 > (void **)v81 || (unint64_t)(v81 + 1) > v80) {
                  return;
                }
                uint64_t v83 = (unsigned __int16 *)((char *)a3[20] + bswap32(*v81));
                uint64_t v84 = &v83[v99];
                BOOL v85 = v79 <= (void **)v83 && v84 >= v83;
                if (!v85 || (unint64_t)v84 > v80)
                {
                  BOOL v87 = (unint64_t)(v83 + 1) > v80 || v79 > (void **)v83;
                  unint64_t v88 = (v80 - (unint64_t)v83) >> 1;
                  if (v87) {
                    unint64_t v88 = 0;
                  }
                  if (v88 != v99) {
                    return;
                  }
                }
                LOWORD(v89) = 0;
                int64_t v90 = a5;
                uint64_t v91 = v98;
                do
                {
                  unsigned int v92 = *v83++;
                  int v93 = bswap32(v92);
                  double v94 = *v90++;
                  unsigned int v89 = (int)(round(v94 * (double)(v93 >> 16)) + (double)(__int16)v89);
                  --v91;
                }
                while (v91);
              }
              else
              {
                uint64_t v95 = (unsigned __int16 *)v78 + v77;
                if (v79 > (void **)v95 || (unint64_t)(v95 + 1) > v80) {
                  return;
                }
                unsigned int v89 = bswap32(*v95) >> 16;
              }
              if ((_WORD)v89)
              {
                TAATKerxEngine::HandleKern<TRunGlue::TGlyph>(*a3, (uint64_t)v15, i, (__int16)v89, *((_DWORD *)a3 + 8));
                *a6 = 1;
              }
            }
          }
          uint64_t v56 = v60;
        }
      }
    }
  }
  else if ((v11 & 1) == 0)
  {
    double v12 = (TRunGlue *)**a3;
    uint64_t v13 = TRunGlue::length(v12);
    if (*((void *)v12 + 19))
    {
      TRunGlue::FocusOnIndex(v12, 0);
      uint64_t v14 = (unsigned __int16 *)(*((void *)v12 + 22) - 2 * *((void *)v12 + 20));
    }
    else
    {
      uint64_t v14 = (unsigned __int16 *)(*((void *)v12 + 22) + 2 * *((void *)v12 + 20));
    }
    if (v13 >= 2)
    {
      uint64_t v18 = *v14;
      uint64_t v19 = v99;
      if (v99 <= 1) {
        uint64_t v19 = 1;
      }
      uint64_t v97 = v19;
      for (uint64_t j = 1; j != v13; ++j)
      {
        uint64_t v21 = TRunGlue::GetGlyphID(v12, j);
        if (v21 == 0xFFFF || (uint64_t v22 = v21, TRunGlue::IsDeleted(v12, j)))
        {
          uint64_t v22 = v18;
        }
        else
        {
          unint64_t v102 = 0xAAAAAAAAAAAAAAAALL;
          unint64_t v23 = a3[5];
          uint64_t v24 = (uint64_t)a3[6];
          uint64_t v25 = (void ***)((char *)a3 + (v24 >> 1) + 40);
          if (v24) {
            unint64_t v23 = *(void ***)(*v25 + v23);
          }
          uint64_t v26 = (unsigned __int8 *)((uint64_t (*)(void *, void, unint64_t *))v23)(v25, (unsigned __int16)v18, &v102);
          unint64_t v27 = v102;
          int v28 = 0;
          if (v26) {
            BOOL v29 = v102 == 0;
          }
          else {
            BOOL v29 = 1;
          }
          if (!v29)
          {
            do
            {
              int v30 = *v26++;
              int v28 = v30 | (v28 << 8);
              --v27;
            }
            while (v27);
          }
          unint64_t v101 = 0xAAAAAAAAAAAAAAAALL;
          unint64_t v31 = a3[12];
          uint64_t v32 = (uint64_t)a3[13];
          unint64_t v33 = (void ***)((char *)a3 + (v32 >> 1) + 96);
          if (v32) {
            unint64_t v31 = *(void ***)(*v33 + v31);
          }
          unint64_t v34 = (unsigned __int8 *)((uint64_t (*)(void *, uint64_t, unint64_t *))v31)(v33, v22, &v101);
          unint64_t v35 = v101;
          int v36 = 0;
          if (v34) {
            BOOL v37 = v101 == 0;
          }
          else {
            BOOL v37 = 1;
          }
          if (!v37)
          {
            do
            {
              int v38 = *v34++;
              int v36 = v38 | (v36 << 8);
              --v35;
            }
            while (v35);
          }
          if (v36 + v28)
          {
            uint64_t v39 = (unsigned __int16 *)a3[19] + (v36 + v28);
            unint64_t v40 = a3[2];
            unint64_t v41 = (unint64_t)a3[3];
            BOOL v43 = v40 <= (void **)v39 && (unint64_t)(v39 + 1) <= v41;
            if (a4)
            {
              if (!v43) {
                return;
              }
              uint64_t v44 = (unsigned __int16 *)((char *)a3[20] + (bswap32(*v39) >> 16));
              int v45 = &v44[v99];
              BOOL v46 = v40 <= (void **)v44 && v45 >= v44;
              if (!v46 || (unint64_t)v45 > v41)
              {
                BOOL v48 = (unint64_t)(v44 + 1) > v41 || v40 > (void **)v44;
                unint64_t v49 = (v41 - (unint64_t)v44) >> 1;
                if (v48) {
                  unint64_t v49 = 0;
                }
                if (v49 != v99) {
                  return;
                }
              }
              LOWORD(v50) = 0;
              unsigned int v51 = a5;
              uint64_t v52 = v97;
              do
              {
                unsigned int v53 = *v44++;
                int v54 = bswap32(v53);
                double v55 = *v51++;
                unsigned int v50 = (int)(round(v55 * (double)(v54 >> 16)) + (double)(__int16)v50);
                --v52;
              }
              while (v52);
            }
            else
            {
              if (!v43) {
                return;
              }
              unsigned int v50 = bswap32(*v39) >> 16;
            }
            if ((_WORD)v50)
            {
              TAATKerxEngine::HandleKern<TRunGlue::TGlyph>(*a3, (uint64_t)v12, j, (__int16)v50, *((_DWORD *)a3 + 8));
              *a6 = 1;
            }
          }
        }
        uint64_t v18 = v22;
      }
    }
  }
}

void TAATKerxEngine::KerxOrderedList::ProcessGlyphsT<TRunGlue::TGlyphInVector>(uint64_t a1, unsigned char *a2)
{
  if (!*(void *)(a1 + 64)) {
    return;
  }
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v5 = **(TRunGlue ***)a1;
  uint64_t v6 = *((void *)v5 + 22);
  uint64_t v7 = *((void *)v5 + 20);
  uint64_t v8 = TRunGlue::length(v5);
  if (v8 < 2) {
    return;
  }
  uint64_t v9 = v8;
  uint64_t v10 = v4 + 16;
  char v11 = (unsigned __int16 *)(v6 + 2 * v7);
  uint64_t v12 = *v11;
  uint64_t v13 = v4 + 18;
  uint64_t v14 = 1;
  CGSize v15 = &std::piecewise_construct;
  while (1)
  {
    uint64_t v16 = v11[v14];
    if (v16 == 0xFFFF)
    {
      uint64_t v16 = v12;
      goto LABEL_16;
    }
    if (*(unsigned __int16 *)(a1 + 58) >= (unsigned __int16)v12)
    {
      if (*(_WORD *)(*(void *)(a1 + 64) + 2 * (unsigned __int16)v12))
      {
        unsigned int v17 = *(unsigned __int16 *)(a1 + 56);
        if (v17 > (unsigned __int16)(*(_WORD *)(*(void *)(a1 + 64) + 2 * (unsigned __int16)v12) - 1)) {
          break;
        }
      }
    }
LABEL_16:
    ++v14;
    uint64_t v12 = v16;
    if (v14 == v9) {
      return;
    }
  }
  unsigned __int16 v18 = *(_WORD *)(*(void *)(a1 + 64) + 2 * (unsigned __int16)v12) - 1;
  uint64_t v19 = (unsigned __int16 *)(v13 + 6 * v18);
  while (1)
  {
    unsigned int v20 = bswap32(*(v19 - 1)) >> 16;
    if (v20 != (unsigned __int16)v12) {
      break;
    }
    if (v16 <= bswap32(*v19) >> 16) {
      goto LABEL_18;
    }
LABEL_13:
    ++v18;
    v19 += 3;
    if (v17 == v18) {
      goto LABEL_16;
    }
  }
  if (v20 < (unsigned __int16)v12) {
    goto LABEL_13;
  }
LABEL_18:
  unsigned int v21 = v18;
  uint64_t v22 = (unsigned __int16 *)(v10 + 6 * v18);
  if ((unsigned __int16)v12 != bswap32(*v22) >> 16 || v16 != bswap32(v22[1]) >> 16) {
    goto LABEL_16;
  }
  unint64_t v23 = *(double **)(a1 + 72);
  uint64_t v24 = *(double **)(a1 + 80);
  unsigned int v25 = bswap32(*(unsigned __int16 *)(v10 + 6 * v21 + 4)) >> 16;
  if (v23 == v24) {
    goto LABEL_39;
  }
  unint64_t v26 = *(void *)(a1 + 16);
  unint64_t v27 = (char *)(*(void *)(a1 + 8) + v25);
  uint64_t v28 = (char *)v24 - (char *)v23;
  unint64_t v29 = v24 - v23;
  unint64_t v30 = *(void *)(a1 + 24);
  unint64_t v31 = &v27[v28 >> 2];
  if (v26 <= (unint64_t)v27 && v31 >= v27 && (unint64_t)v31 <= v30) {
    goto LABEL_36;
  }
  BOOL v34 = (unint64_t)(v27 + 2) > v30 || v26 > (unint64_t)v27;
  unint64_t v35 = (v30 - (unint64_t)v27) >> 1;
  if (v34) {
    unint64_t v35 = 0;
  }
  if (v35 == v29)
  {
LABEL_36:
    LOWORD(v25) = 0;
    if (v29 <= 1) {
      unint64_t v29 = 1;
    }
    do
    {
      unsigned int v36 = *(unsigned __int16 *)v27;
      v27 += 2;
      int v37 = bswap32(v36);
      double v38 = *v23++;
      unsigned int v25 = (int)(round(v38 * (double)(v37 >> 16)) + (double)(__int16)v25);
      --v29;
    }
    while (v29);
LABEL_39:
    if ((_WORD)v25)
    {
      uint64_t v39 = *(TRunGlue ***)a1;
      if ((*(unsigned char *)(a1 + 35) & 0x40) != 0)
      {
        uint64_t v59 = v10;
        BOOL v43 = (uint64_t **)(v39 + 6);
        uint64_t v61 = v14;
        uint64_t v62 = &v61;
        if ((unsigned __int16)v25 == 0x8000)
        {
          uint64_t v44 = v15;
          int v45 = std::__tree<std::__value_type<long,TAATDeltaYListEntry>,std::__map_value_compare<long,std::__value_type<long,TAATDeltaYListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TAATDeltaYListEntry>>>::__emplace_unique_key_args<long,std::piecewise_construct_t const&,std::tuple<long &&>,std::tuple<>>(v43, &v61, (uint64_t)v15, &v62);
          CGSize v15 = v44;
          *((unsigned char *)v45 + 42) = 1;
          *((_WORD *)v45 + 20) = 0;
        }
        else
        {
          uint64_t v56 = v15;
          uint64_t v57 = std::__tree<std::__value_type<long,TAATDeltaYListEntry>,std::__map_value_compare<long,std::__value_type<long,TAATDeltaYListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TAATDeltaYListEntry>>>::__emplace_unique_key_args<long,std::piecewise_construct_t const&,std::tuple<long &&>,std::tuple<>>(v43, &v61, (uint64_t)v15, &v62);
          CGSize v15 = v56;
          *((_WORD *)v57 + 20) += v25;
        }
        uint64_t v10 = v59;
      }
      else
      {
        unint64_t v40 = (char *)v39[5];
        unint64_t v41 = (uint64_t *)v39[4];
        if (v41 >= (uint64_t *)v40)
        {
          BOOL v46 = (char *)v39[3];
          uint64_t v58 = ((char *)v41 - v46) >> 4;
          uint64_t v60 = v10;
          unint64_t v47 = v58 + 1;
          if ((unint64_t)(v58 + 1) >> 60) {
            abort();
          }
          uint64_t v48 = v40 - v46;
          if (v48 >> 3 > v47) {
            unint64_t v47 = v48 >> 3;
          }
          if ((unint64_t)v48 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v49 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v49 = v47;
          }
          unsigned int v51 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CGSize>>((uint64_t)(v39 + 5), v49);
          uint64_t v52 = &v51[16 * v58];
          *(void *)uint64_t v52 = v14;
          *((_WORD *)v52 + 4) = v25;
          int v54 = v39[3];
          unsigned int v53 = v39[4];
          double v55 = v52;
          if (v53 != v54)
          {
            do
            {
              *((_OWORD *)v55 - 1) = *((_OWORD *)v53 - 1);
              v55 -= 16;
              unsigned int v53 = (TRunGlue *)((char *)v53 - 16);
            }
            while (v53 != v54);
            unsigned int v53 = v39[3];
          }
          uint64_t v42 = (TRunGlue *)(v52 + 16);
          void v39[3] = (TRunGlue *)v55;
          v39[4] = (TRunGlue *)(v52 + 16);
          v39[5] = (TRunGlue *)&v51[16 * v50];
          if (v53) {
            operator delete(v53);
          }
          uint64_t v10 = v60;
          CGSize v15 = &std::piecewise_construct;
        }
        else
        {
          uint64_t *v41 = v14;
          *((_WORD *)v41 + 4) = v25;
          uint64_t v42 = (TRunGlue *)(v41 + 2);
        }
        v39[4] = v42;
      }
      *a2 = 1;
    }
    goto LABEL_16;
  }
}

void TAATKerxEngine::KerxOrderedList::ProcessGlyphsT<TRunGlue::TGlyphInSingleRun>(uint64_t a1, unsigned char *a2)
{
  if (!*(void *)(a1 + 64)) {
    return;
  }
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v5 = **(TRunGlue ***)a1;
  uint64_t v6 = *((void *)v5 + 22);
  uint64_t v7 = *((void *)v5 + 20);
  uint64_t v8 = TRunGlue::length(v5);
  if (v8 < 2) {
    return;
  }
  uint64_t v9 = v8;
  uint64_t v53 = v4 + 16;
  uint64_t v10 = (unsigned __int16 *)(v6 + 2 * v7);
  uint64_t v11 = *v10;
  uint64_t v12 = v4 + 18;
  uint64_t v13 = 1;
  while (1)
  {
    uint64_t v14 = v10[v13];
    if (v14 == 0xFFFF || TRunGlue::IsDeleted(v5, v13))
    {
      uint64_t v14 = v11;
      goto LABEL_7;
    }
    if (*(unsigned __int16 *)(a1 + 58) >= (unsigned __int16)v11)
    {
      if (*(_WORD *)(*(void *)(a1 + 64) + 2 * (unsigned __int16)v11))
      {
        unsigned int v15 = *(unsigned __int16 *)(a1 + 56);
        if (v15 > (unsigned __int16)(*(_WORD *)(*(void *)(a1 + 64) + 2 * (unsigned __int16)v11) - 1)) {
          break;
        }
      }
    }
LABEL_7:
    ++v13;
    uint64_t v11 = v14;
    if (v13 == v9) {
      return;
    }
  }
  unsigned __int16 v16 = *(_WORD *)(*(void *)(a1 + 64) + 2 * (unsigned __int16)v11) - 1;
  unsigned int v17 = (unsigned __int16 *)(v12 + 6 * v16);
  while (1)
  {
    unsigned int v18 = bswap32(*(v17 - 1)) >> 16;
    if (v18 != (unsigned __int16)v11) {
      break;
    }
    if (v14 <= bswap32(*v17) >> 16) {
      goto LABEL_19;
    }
LABEL_17:
    ++v16;
    v17 += 3;
    if (v15 == v16) {
      goto LABEL_7;
    }
  }
  if (v18 < (unsigned __int16)v11) {
    goto LABEL_17;
  }
LABEL_19:
  uint64_t v19 = (unsigned __int16 *)(v53 + 6 * v16);
  if ((unsigned __int16)v11 != bswap32(*v19) >> 16 || v14 != bswap32(v19[1]) >> 16) {
    goto LABEL_7;
  }
  unsigned int v20 = *(double **)(a1 + 72);
  unsigned int v21 = *(double **)(a1 + 80);
  unsigned int v22 = bswap32(*(unsigned __int16 *)(v53 + 6 * v16 + 4)) >> 16;
  if (v20 == v21) {
    goto LABEL_40;
  }
  unint64_t v23 = *(void *)(a1 + 16);
  uint64_t v24 = (char *)(*(void *)(a1 + 8) + v22);
  uint64_t v25 = (char *)v21 - (char *)v20;
  unint64_t v26 = v21 - v20;
  unint64_t v27 = *(void *)(a1 + 24);
  uint64_t v28 = &v24[v25 >> 2];
  if (v23 <= (unint64_t)v24 && v28 >= v24 && (unint64_t)v28 <= v27) {
    goto LABEL_37;
  }
  BOOL v31 = (unint64_t)(v24 + 2) > v27 || v23 > (unint64_t)v24;
  unint64_t v32 = (v27 - (unint64_t)v24) >> 1;
  if (v31) {
    unint64_t v32 = 0;
  }
  if (v32 == v26)
  {
LABEL_37:
    LOWORD(v22) = 0;
    if (v26 <= 1) {
      unint64_t v26 = 1;
    }
    do
    {
      unsigned int v33 = *(unsigned __int16 *)v24;
      v24 += 2;
      int v34 = bswap32(v33);
      double v35 = *v20++;
      unsigned int v22 = (int)(round(v35 * (double)(v34 >> 16)) + (double)(__int16)v22);
      --v26;
    }
    while (v26);
LABEL_40:
    if ((_WORD)v22)
    {
      unsigned int v36 = *(TRunGlue ***)a1;
      if ((*(unsigned char *)(a1 + 35) & 0x40) != 0)
      {
        uint64_t v54 = v13;
        double v55 = &v54;
        unint64_t v40 = std::__tree<std::__value_type<long,TAATDeltaYListEntry>,std::__map_value_compare<long,std::__value_type<long,TAATDeltaYListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TAATDeltaYListEntry>>>::__emplace_unique_key_args<long,std::piecewise_construct_t const&,std::tuple<long &&>,std::tuple<>>((uint64_t **)v36 + 6, &v54, (uint64_t)&std::piecewise_construct, &v55);
        if ((unsigned __int16)v22 == 0x8000)
        {
          *((unsigned char *)v40 + 42) = 1;
          *((_WORD *)v40 + 20) = 0;
        }
        else
        {
          *((_WORD *)v40 + 20) += v22;
        }
      }
      else
      {
        int v37 = (char *)v36[5];
        double v38 = (uint64_t *)v36[4];
        if (v38 >= (uint64_t *)v37)
        {
          unint64_t v41 = (char *)v36[3];
          uint64_t v51 = ((char *)v38 - v41) >> 4;
          uint64_t v52 = *(TRunGlue ***)a1;
          unint64_t v42 = v51 + 1;
          if ((unint64_t)(v51 + 1) >> 60) {
            abort();
          }
          uint64_t v43 = v37 - v41;
          if (v43 >> 3 > v42) {
            unint64_t v42 = v43 >> 3;
          }
          if ((unint64_t)v43 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v44 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v44 = v42;
          }
          BOOL v46 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CGSize>>((uint64_t)(v36 + 5), v44);
          unsigned int v36 = v52;
          unint64_t v47 = &v46[16 * v51];
          *(void *)unint64_t v47 = v13;
          *((_WORD *)v47 + 4) = v22;
          unint64_t v49 = v52[3];
          uint64_t v48 = v52[4];
          uint64_t v50 = v47;
          if (v48 != v49)
          {
            do
            {
              *((_OWORD *)v50 - 1) = *((_OWORD *)v48 - 1);
              v50 -= 16;
              uint64_t v48 = (TRunGlue *)((char *)v48 - 16);
            }
            while (v48 != v49);
            uint64_t v48 = v52[3];
          }
          uint64_t v39 = (TRunGlue *)(v47 + 16);
          _OWORD v52[3] = (TRunGlue *)v50;
          v52[4] = (TRunGlue *)(v47 + 16);
          v52[5] = (TRunGlue *)&v46[16 * v45];
          if (v48)
          {
            operator delete(v48);
            unsigned int v36 = v52;
          }
        }
        else
        {
          uint64_t *v38 = v13;
          *((_WORD *)v38 + 4) = v22;
          uint64_t v39 = (TRunGlue *)(v38 + 2);
        }
        v36[4] = v39;
      }
      *a2 = 1;
    }
    goto LABEL_7;
  }
}

void TAATKerxEngine::KerxOrderedList::ProcessGlyphsT<TRunGlue::TGlyph>(void **a1, unsigned char *a2)
{
  if (!a1[8]) {
    return;
  }
  uint64_t v4 = a1[2];
  uint64_t v5 = (TRunGlue *)**a1;
  uint64_t v6 = TRunGlue::length(v5);
  if (*((void *)v5 + 19))
  {
    TRunGlue::FocusOnIndex(v5, 0);
    uint64_t v7 = (unsigned __int16 *)(*((void *)v5 + 22) - 2 * *((void *)v5 + 20));
  }
  else
  {
    uint64_t v7 = (unsigned __int16 *)(*((void *)v5 + 22) + 2 * *((void *)v5 + 20));
  }
  if (v6 < 2) {
    return;
  }
  uint64_t v8 = v4 + 2;
  uint64_t v9 = (char *)v4 + 18;
  uint64_t v10 = *v7;
  uint64_t v11 = 1;
  while (1)
  {
    uint64_t GlyphID = TRunGlue::GetGlyphID(v5, v11);
    if (GlyphID == 0xFFFF || (uint64_t v13 = GlyphID, TRunGlue::IsDeleted(v5, v11)))
    {
      uint64_t v13 = v10;
      goto LABEL_10;
    }
    if (*((unsigned __int16 *)a1 + 29) >= (unsigned __int16)v10)
    {
      if (*((_WORD *)a1[8] + (unsigned __int16)v10))
      {
        unsigned int v14 = *((unsigned __int16 *)a1 + 28);
        if (v14 > (unsigned __int16)(*((_WORD *)a1[8] + (unsigned __int16)v10) - 1)) {
          break;
        }
      }
    }
LABEL_10:
    ++v11;
    uint64_t v10 = v13;
    if (v11 == v6) {
      return;
    }
  }
  unsigned __int16 v15 = *((_WORD *)a1[8] + (unsigned __int16)v10) - 1;
  unsigned __int16 v16 = &v9[6 * v15];
  while (1)
  {
    unsigned int v17 = bswap32(*((unsigned __int16 *)v16 - 1)) >> 16;
    if (v17 != (unsigned __int16)v10) {
      break;
    }
    if (v13 <= bswap32(*(unsigned __int16 *)v16) >> 16) {
      goto LABEL_22;
    }
LABEL_20:
    ++v15;
    v16 += 6;
    if (v14 == v15) {
      goto LABEL_10;
    }
  }
  if (v17 < (unsigned __int16)v10) {
    goto LABEL_20;
  }
LABEL_22:
  unsigned int v18 = (unsigned __int16 *)v8 + 3 * v15;
  if ((unsigned __int16)v10 != bswap32(*v18) >> 16 || v13 != bswap32(v18[1]) >> 16) {
    goto LABEL_10;
  }
  uint64_t v19 = (double *)a1[9];
  unsigned int v20 = (double *)a1[10];
  unsigned int v21 = bswap32(*((unsigned __int16 *)v8 + 3 * v15 + 2)) >> 16;
  if (v19 == v20) {
    goto LABEL_43;
  }
  unsigned int v22 = (char *)a1[2];
  unint64_t v23 = (char *)a1[1] + v21;
  uint64_t v24 = (char *)v20 - (char *)v19;
  unint64_t v25 = v20 - v19;
  unint64_t v26 = (unint64_t)a1[3];
  unint64_t v27 = &v23[v24 >> 2];
  if (v22 <= v23 && v27 >= v23 && (unint64_t)v27 <= v26) {
    goto LABEL_40;
  }
  BOOL v30 = (unint64_t)(v23 + 2) > v26 || v22 > v23;
  unint64_t v31 = (v26 - (unint64_t)v23) >> 1;
  if (v30) {
    unint64_t v31 = 0;
  }
  if (v31 == v25)
  {
LABEL_40:
    LOWORD(v21) = 0;
    if (v25 <= 1) {
      unint64_t v25 = 1;
    }
    do
    {
      unsigned int v32 = *(unsigned __int16 *)v23;
      v23 += 2;
      int v33 = bswap32(v32);
      double v34 = *v19++;
      unsigned int v21 = (int)(round(v34 * (double)(v33 >> 16)) + (double)(__int16)v21);
      --v25;
    }
    while (v25);
LABEL_43:
    if ((_WORD)v21)
    {
      TAATKerxEngine::HandleKern<TRunGlue::TGlyph>(*a1, (uint64_t)v5, v11, (__int16)v21, *((_DWORD *)a1 + 8));
      *a2 = 1;
    }
    goto LABEL_10;
  }
}

BOOL TRunGlue::CoveredByBitmap(TRunGlue *this, const unsigned __int8 *a2, CFRange a3)
{
  CFIndex length = a3.length;
  locatiouint64_t n = a3.location;
  if (*((void *)this + 19) || (uint64_t v14 = TRunGlue::length(this), v14 < 1))
  {
LABEL_2:
    if (length < 1)
    {
      return 0;
    }
    else
    {
      uint64_t v7 = 0;
      BOOL v8 = 1;
      while (1)
      {
        uint64_t v9 = *(void **)(*(void *)(*(void *)(*(void *)this + 16) + 8 * (v7 + location)) + 40);
        uint64_t v10 = v9[26];
        if (v10 >= 1) {
          break;
        }
LABEL_9:
        BOOL v8 = ++v7 < length;
        if (v7 == length) {
          return v8;
        }
      }
      uint64_t v11 = (unsigned __int16 *)(*(void *)(v9[27] + 16) + 2 * v9[25]);
      while (1)
      {
        unsigned int v13 = *v11++;
        unint64_t v12 = v13;
        if (*((void *)this + 78) > (uint64_t)v13 && ((a2[v12 >> 3] >> (v12 & 7)) & 1) != 0) {
          break;
        }
        if (!--v10) {
          goto LABEL_9;
        }
      }
    }
  }
  else
  {
    unsigned __int16 v15 = (unsigned __int16 *)(*((void *)this + 22) + 2 * *((void *)this + 20));
    while (1)
    {
      unsigned int v17 = *v15++;
      unint64_t v16 = v17;
      if (*((void *)this + 78) > (uint64_t)v17 && ((a2[v16 >> 3] >> (v16 & 7)) & 1) != 0) {
        break;
      }
      if (!--v14) {
        goto LABEL_2;
      }
    }
    return 1;
  }
  return v8;
}

void std::vector<double>::__append(char **a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    BOOL v8 = *a1;
    uint64_t v9 = v7 - *a1;
    unint64_t v10 = a2 + (v9 >> 3);
    if (v10 >> 61) {
      abort();
    }
    uint64_t v11 = v9 >> 3;
    uint64_t v12 = v5 - v8;
    if (v12 >> 2 > v10) {
      unint64_t v10 = v12 >> 2;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v10;
    }
    if (v13)
    {
      uint64_t v14 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<long>>(v4, v13);
      BOOL v8 = *a1;
      uint64_t v7 = a1[1];
    }
    else
    {
      uint64_t v14 = 0;
    }
    unsigned __int16 v15 = &v14[8 * v11];
    unint64_t v16 = &v14[8 * v13];
    bzero(v15, 8 * a2);
    unsigned int v17 = &v15[8 * a2];
    while (v7 != v8)
    {
      uint64_t v18 = *((void *)v7 - 1);
      v7 -= 8;
      *((void *)v15 - 1) = v18;
      v15 -= 8;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

void std::vector<std::unique_ptr<unsigned short const[]>,TInlineBufferAllocator<std::unique_ptr<unsigned short const[]>,4ul>>::__append(long long *a1, unint64_t a2)
{
  uint64_t v5 = (void *)*((void *)a1 + 1);
  uint64_t v4 = *((void *)a1 + 2);
  if (a2 <= (v4 - (uint64_t)v5) >> 3)
  {
    if (a2)
    {
      bzero(*((void **)a1 + 1), 8 * a2);
      v5 += a2;
    }
    *((void *)a1 + 1) = v5;
  }
  else
  {
    uint64_t v6 = (uint64_t)a1 + 24;
    uint64_t v7 = *(void **)a1;
    uint64_t v8 = (uint64_t)v5 - *(void *)a1;
    unint64_t v9 = a2 + (v8 >> 3);
    if (v9 >> 61) {
      abort();
    }
    uint64_t v10 = v8 >> 3;
    uint64_t v11 = v4 - (void)v7;
    if (v11 >> 2 > v9) {
      unint64_t v9 = v11 >> 2;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v9;
    }
    uint64_t v23 = (uint64_t)a1 + 24;
    if (v12)
    {
      unint64_t v13 = (char *)TInlineBufferAllocator<std::unique_ptr<unsigned short const[]>,4ul>::allocate(v6, v12);
      uint64_t v7 = *(void **)a1;
      uint64_t v5 = (void *)*((void *)a1 + 1);
    }
    else
    {
      unint64_t v13 = 0;
    }
    uint64_t v14 = &v13[8 * v10];
    unsigned __int16 v15 = &v13[8 * v12];
    unsigned int v22 = v15;
    bzero(v14, 8 * a2);
    unint64_t v16 = &v14[8 * a2];
    *((void *)&v21 + 1) = v16;
    if (v5 != v7)
    {
      do
      {
        uint64_t v17 = *--v5;
        void *v5 = 0;
        *((void *)v14 - 1) = v17;
        v14 -= 8;
      }
      while (v5 != v7);
      unint64_t v16 = (char *)*((void *)&v21 + 1);
      unsigned __int16 v15 = v22;
    }
    long long v18 = *a1;
    *(void *)a1 = v14;
    *((void *)a1 + 1) = v16;
    long long v21 = v18;
    uint64_t v19 = (char *)*((void *)a1 + 2);
    *((void *)a1 + 2) = v15;
    unsigned int v22 = v19;
    uint64_t v20 = v18;
    std::__split_buffer<std::unique_ptr<unsigned short const[]>,TInlineBufferAllocator<std::unique_ptr<unsigned short const[]>,4ul> &>::~__split_buffer(&v20);
  }
}

void TAATKerxEngine::HandleKern<TRunGlue::TGlyph>(void *a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  __int16 v5 = a4;
  if ((a5 & 0x40000000) != 0)
  {
    unint64_t v12 = (uint64_t **)(a1 + 6);
    if (a4 == -32768)
    {
      uint64_t v26 = a3;
      unint64_t v27 = &v26;
      unint64_t v13 = std::__tree<std::__value_type<long,TAATDeltaYListEntry>,std::__map_value_compare<long,std::__value_type<long,TAATDeltaYListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TAATDeltaYListEntry>>>::__emplace_unique_key_args<long,std::piecewise_construct_t const&,std::tuple<long &&>,std::tuple<>>(v12, &v26, (uint64_t)&std::piecewise_construct, &v27);
      *((unsigned char *)v13 + 42) = 1;
      *((_WORD *)v13 + 20) = 0;
    }
    else
    {
      uint64_t v26 = a3;
      unint64_t v27 = &v26;
      unint64_t v25 = std::__tree<std::__value_type<long,TAATDeltaYListEntry>,std::__map_value_compare<long,std::__value_type<long,TAATDeltaYListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TAATDeltaYListEntry>>>::__emplace_unique_key_args<long,std::piecewise_construct_t const&,std::tuple<long &&>,std::tuple<>>(v12, &v26, (uint64_t)&std::piecewise_construct, &v27);
      *((_WORD *)v25 + 20) += v5;
    }
  }
  else
  {
    uint64_t v8 = (uint64_t)(a1 + 5);
    unint64_t v9 = a1[5];
    unint64_t v10 = a1[4];
    if (v10 >= v9)
    {
      uint64_t v14 = a1[3];
      uint64_t v15 = (uint64_t)(v10 - v14) >> 4;
      unint64_t v16 = v15 + 1;
      if ((unint64_t)(v15 + 1) >> 60) {
        abort();
      }
      uint64_t v17 = v9 - v14;
      if (v17 >> 3 > v16) {
        unint64_t v16 = v17 >> 3;
      }
      if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v18 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v18 = v16;
      }
      uint64_t v19 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CGSize>>(v8, v18);
      uint64_t v20 = &v19[16 * v15];
      unsigned int v22 = &v19[16 * v21];
      *(void *)uint64_t v20 = a3;
      *((_WORD *)v20 + 4) = v5;
      uint64_t v11 = v20 + 16;
      uint64_t v24 = (char *)a1[3];
      uint64_t v23 = (char *)a1[4];
      if (v23 != v24)
      {
        do
        {
          *((_OWORD *)v20 - 1) = *((_OWORD *)v23 - 1);
          v20 -= 16;
          v23 -= 16;
        }
        while (v23 != v24);
        uint64_t v23 = (char *)a1[3];
      }
      a1[3] = v20;
      a1[4] = v11;
      a1[5] = v22;
      if (v23) {
        operator delete(v23);
      }
    }
    else
    {
      *(void *)unint64_t v10 = a3;
      *(_WORD *)(v10 + 8) = a4;
      uint64_t v11 = (char *)(v10 + 16);
    }
    a1[4] = v11;
  }
}

uint64_t **std::__tree<std::__value_type<long,TAATDeltaYListEntry>,std::__map_value_compare<long,std::__value_type<long,TAATDeltaYListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TAATDeltaYListEntry>>>::__emplace_unique_key_args<long,std::piecewise_construct_t const&,std::tuple<long &&>,std::tuple<>>(uint64_t **a1, uint64_t *a2, uint64_t a3, void **a4)
{
  uint64_t v7 = a1 + 1;
  uint64_t v6 = a1[1];
  if (v6)
  {
    uint64_t v8 = *a2;
    while (1)
    {
      while (1)
      {
        unint64_t v9 = (uint64_t **)v6;
        uint64_t v10 = v6[4];
        if (v8 >= v10) {
          break;
        }
        uint64_t v6 = *v9;
        uint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      uint64_t v6 = v9[1];
      if (!v6)
      {
        uint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    unint64_t v9 = a1 + 1;
LABEL_10:
    uint64_t v11 = operator new(0x30uLL);
    v11[4] = **a4;
    *((_DWORD *)v11 + 10) = 0;
    std::__tree<std::__value_type<long,TAATDeltaYListEntry>,std::__map_value_compare<long,std::__value_type<long,TAATDeltaYListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TAATDeltaYListEntry>>>::__insert_node_at(a1, (uint64_t)v9, v7, v11);
    return (uint64_t **)v11;
  }
  return v9;
}

uint64_t *std::__tree<std::__value_type<long,TAATDeltaYListEntry>,std::__map_value_compare<long,std::__value_type<long,TAATDeltaYListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TAATDeltaYListEntry>>>::__insert_node_at(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  __int16 v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  uint64_t result = std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t std::default_delete<TAATControlPointAccess>::operator()[abi:nn180100](uint64_t a1, void **a2)
{
  if (a2)
  {

    uint64_t v4 = a2 + 2;
    std::vector<CGPoint,TInlineBufferAllocator<CGPoint,64ul>>::__destroy_vector::operator()[abi:nn180100](&v4);
    return MEMORY[0x1853275C0](a2, 0x10E0C40A1378614);
  }
  return result;
}

void std::vector<CGPoint,TInlineBufferAllocator<CGPoint,64ul>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  unint64_t v1 = *a1;
  unint64_t v2 = (void **)**a1;
  if (v2)
  {
    v1[1] = v2;
    uint64_t v3 = v1 + 131;
    if (v1 + 3 <= v2)
    {
      BOOL v4 = v3 >= v2;
      BOOL v5 = v3 == v2;
    }
    else
    {
      BOOL v4 = 0;
      BOOL v5 = 0;
    }
    if (!v5 && v4)
    {
      if (v1[2] == v1[131]) {
        *uint64_t v3 = v2;
      }
    }
    else
    {
      operator delete(v2);
    }
  }
}

CFArrayRef FontRequiresOpenTypeShaping(atomic_ullong *a1)
{
  CFArrayRef result = (const __CFArray *)atomic_load_explicit(a1 + 21, memory_order_acquire);
  if (result)
  {
    CFIndex Count = CFArrayGetCount(result);
    if (Count < 1)
    {
      return 0;
    }
    else
    {
      int ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)atomic_load_explicit(a1 + 21, memory_order_acquire), Count - 1);
      return (const __CFArray *)(-[CTFeatureSetting tag]((uint64_t)ValueAtIndex) != 0);
    }
  }
  return result;
}

BOOL TShapingEngine::ApplyVerticalForms(TShapingEngine *this, const UniChar *a2, CGGlyph *a3, CFIndex a4)
{
  uint64_t v68 = *MEMORY[0x1E4F143B8];
  int ShapingType = TBaseFont::GetShapingType(*(TBaseFont **)(*((void *)this + 5) + 400));
  if (ShapingType == 2)
  {
    *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
    void v66[3] = v10;
    v66[2] = v10;
    v66[1] = v10;
    v66[0] = v10;
    id values = 0;
    unsigned int v64 = 0;
    unint64_t explicit = 0;
    BOOL v67 = v66;
    if (a4)
    {
      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__vallocate[abi:nn180100](&values, a4);
      uint64_t v11 = v64;
      bzero(v64, 2 * a4);
      unsigned int v64 = &v11[2 * a4];
      unint64_t v12 = (CGGlyph *)values;
    }
    else
    {
      unint64_t v12 = 0;
    }
    CTFontGetGlyphsForCharacters(this, a2, v12, a4);
    BOOL v30 = (unsigned __int16 *)values;
    unint64_t v29 = (__int16 *)v64;
    if (values != v64)
    {
      unint64_t v31 = (__int16 *)values;
      do
      {
        __int16 v32 = *v31;
        if (!*v31) {
          __int16 v32 = -1;
        }
        *v31++ = v32;
      }
      while (v31 != v29);
    }
    *(void *)&long long v33 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v33 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v61[28] = v33;
    v61[29] = v33;
    v61[26] = v33;
    v61[27] = v33;
    v61[24] = v33;
    v61[25] = v33;
    v61[22] = v33;
    v61[23] = v33;
    v61[20] = v33;
    v61[21] = v33;
    v61[18] = v33;
    v61[19] = v33;
    v61[16] = v33;
    v61[17] = v33;
    v61[15] = v33;
    v61[14] = v33;
    v61[13] = v33;
    v61[12] = v33;
    v61[11] = v33;
    v61[10] = v33;
    v61[9] = v33;
    v61[8] = v33;
    v61[7] = v33;
    v61[6] = v33;
    v61[5] = v33;
    v61[4] = v33;
    v61[3] = v33;
    void v61[2] = v33;
    v61[1] = v33;
    v61[0] = v33;
    uint64_t v59 = 0;
    id keys = 0;
    uint64_t v60 = 0;
    uint64_t v62 = v61;
    if (a4)
    {
      std::vector<CGPoint,TInlineBufferAllocator<CGPoint,30ul>>::__vallocate[abi:nn180100]((char **)&keys, a4);
      double v34 = (char *)v59;
      bzero(v59, 16 * a4);
      uint64_t v59 = &v34[16 * a4];
      BOOL v30 = (unsigned __int16 *)values;
      double v35 = (CGSize *)keys;
    }
    else
    {
      double v35 = 0;
    }
    memcpy(__dst, &unk_184B882F0, sizeof(__dst));
    TRunGlue::TRunGlue((TRunGlue *)__dst, this, v30, v35, a4, 0, 0, 0);
    unint64_t InitialScriptAndLangSys = TOpenTypeMorph::GetInitialScriptAndLangSys(0, *((__CFString **)this + 5), v36);
    unint64_t v38 = InitialScriptAndLangSys & 0xFFFFFFFF00000000;
    uint64_t v39 = InitialScriptAndLangSys;
    v52.locatiouint64_t n = 0;
    v52.CFIndex length = a4;
    memset(__b, 170, sizeof(__b));
    if (v39 == 0xFFFFFFFFLL) {
      uint64_t v40 = 0;
    }
    else {
      uint64_t v40 = v39;
    }
    TOpenTypeMorph::TOpenTypeMorph((uint64_t *)__b, (uint64_t)__dst, 0, v40 | v38, &v52);
    TOpenTypeMorph::ApplyVerticalGlyphs((TOpenTypeMorph *)__b);
    std::vector<TGlyphAuxDataListEntry,TInlineBufferAllocator<TGlyphAuxDataListEntry,30ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&__b[4]);
    std::__function::__value_func<BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::~__value_func[abi:nn180100]((int64x2_t *)__dst[35].i64);
    __b[0] = &__dst[23];
    std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)__b);
    __b[0] = &__dst[13];
    std::vector<unsigned char,TInlineBufferAllocator<unsigned char,128ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)__b);
    __b[0] = &__dst[3].u64[1];
    std::vector<std::pair<UScriptCode,long>,TInlineBufferAllocator<std::pair<UScriptCode,long>,1ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)__b);
    __b[0] = &keys;
    std::vector<CGPoint,TInlineBufferAllocator<CGPoint,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)__b);
    unint64_t v41 = (char *)values;
    unint64_t v42 = v64;
    char v43 = 1;
    if (values != v64)
    {
      do
      {
        int v45 = *(unsigned __int16 *)v41;
        v41 += 2;
        int v44 = v45;
        if (v45 == 0xFFFF) {
          int v44 = 0;
        }
        if (!v44) {
          char v43 = 0;
        }
        *a3++ = v44;
      }
      while (v41 != v42);
    }
    __b[0] = &values;
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)__b);
    return v43 != 0;
  }
  if (ShapingType)
  {
    unint64_t v13 = +[_CTNativeGlyphStorage newWithCount:a4 capacity:a4];
    glyphs = (CGGlyph *)v13->_glyphs;
    CTFontGetGlyphsForCharacters(this, a2, glyphs, a4);
    uint64_t v15 = 2 * a4;
    if (a4)
    {
      uint64_t v16 = 2 * a4;
      uint64_t v17 = (__int16 *)glyphs;
      do
      {
        __int16 v18 = *v17;
        if (!*v17) {
          __int16 v18 = -1;
        }
        *v17++ = v18;
        v16 -= 2;
      }
      while (v16);
      int64_t v19 = 0;
      stringIndices = v13->_stringIndices;
      uint64_t v21 = 8 * a4;
      do
      {
        stringIndices[v19] = v19;
        ++v19;
        v21 -= 8;
      }
      while (v21);
    }
    unint64_t v49 = v13;
    id v54 = (id)0xAAAAAAAAAAAAAAAALL;
    TCFNumber::TCFNumber<int>(&v54, 0);
    id keys = @"NSFont";
    uint64_t v59 = @"CTVerticalForms";
    uint64_t v60 = @"NSLigature";
    unint64_t explicit = 0xAAAAAAAAAAAAAAAALL;
    unsigned int v22 = (char *)*MEMORY[0x1E4F1CFD0];
    id values = this;
    unsigned int v64 = v22;
    unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&v54, memory_order_acquire);
    CFDictionaryRef v23 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&keys, (const void **)&values, 3, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    v52.locatiouint64_t n = (CFIndex)a2;
    v52.CFIndex length = a4;
    CFDictionaryRef v53 = v23;
    uint64_t v24 = (std::__shared_weak_count *)operator new(0xB0uLL);
    v24->__shared_weak_owners_ = 0;
    v24->__shared_owners_ = 0;
    v24->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ED062240;
    TCharStreamUniChar::TCharStreamUniChar((TCharStreamUniChar *)&v24[1], (const unsigned __int16 *(*)(uint64_t, uint64_t *, const __CFDictionary **, void *))Provider, 0, &v52);
    __dst[8] = (int64x2_t)xmmword_184B88600;
    memset(&__dst[9], 170, 32);
    __dst[11] = (int64x2_t)unk_184B88630;
    __dst[6] = (int64x2_t)xmmword_184B885E0;
    __dst[7] = (int64x2_t)unk_184B885F0;
    memset(__dst, 170, 96);
    atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
    __dst[0].i64[0] = (uint64_t)&v24[1];
    __dst[0].i64[1] = (uint64_t)v24;
    memset(&__dst[1], 0, 24);
    __dst[4].i64[0] = (uint64_t)&__dst[2].i64[1];
    __dst[11].i8[8] = 0;
    *(int64x2_t *)((char *)&__dst[4] + 8) = 0u;
    *(int64x2_t *)((char *)&__dst[5] + 8) = 0u;
    *(int64x2_t *)((char *)&__dst[6] + 8) = 0u;
    __dst[7].i64[1] = 0;
    *(int64x2_t *)((char *)&__dst[8] + 8) = 0u;
    *(uint64_t *)((char *)__dst[9].i64 + 5) = 0;
    memset(&__dst[12], 0, 24);
    memset(&__dst[10], 0, 17);
    __dst[8].i64[0] = 0xFFEFFFFFFFFFFFFFLL;
    id v51 = (id)0xAAAAAAAAAAAAAAAALL;
    v71.locatiouint64_t n = 0;
    v71.CFIndex length = 0;
    TAttributes::TAttributes((TAttributes *)__b, v23, 0, v71, 0);
    uint64_t v25 = TCFBase<TRun>::Allocate();
    if (v25)
    {
      uint64_t v26 = (void *)v25;
      unint64_t v27 = (TRun *)(v25 + 72);
      void v26[2] = 0;
      v26[3] = 0;
      v26[4] = 0;
      v26[5] = v27;
      v26[6] = v27;
      v26[7] = CTGlyphRun::CloneEntire;
      v26[8] = CTGlyphRun::CloneRange;
      v70.locatiouint64_t n = 0;
      v70.CFIndex length = a4;
      uint64_t v28 = v49;
      TRun::TRun(v27, v70, v49, (const TAttributes *)__b);
      id v55 = v26;
      id v50 = (id)atomic_exchange((atomic_ullong *volatile)&v55, 0);
    }
    else
    {
      id v50 = 0;
      uint64_t v28 = v49;
    }
    id v51 = (id)atomic_exchange((atomic_ullong *volatile)&v50, 0);

    TAttributes::~TAttributes((TAttributes *)__b);
    __b[0] = (id)atomic_exchange((atomic_ullong *volatile)&v51, 0);
    TLine::AppendRun(__dst, (atomic_ullong *)__b);

    memcpy(__b, &unk_184B882F0, 0x290uLL);
    TRunGlue::TRunGlue((TRunGlue *)__b, (TLine *)__dst);
    TShapingEngine::ShapeGlyphs((TShapingEngine *)__b, (TRunGlue *)&v24[1], v46);
    std::__function::__value_func<BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::~__value_func[abi:nn180100](&__b[70]);
    id v55 = &__b[46];
    std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v55);
    id v55 = &__b[26];
    std::vector<unsigned char,TInlineBufferAllocator<unsigned char,128ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v55);
    id v55 = &__b[7];
    std::vector<std::pair<UScriptCode,long>,TInlineBufferAllocator<std::pair<UScriptCode,long>,1ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v55);

    TLine::~TLine((TLine *)__dst);
    std::__shared_weak_count::__release_shared[abi:nn180100](v24);

    if (a4)
    {
      char v43 = 1;
      do
      {
        int v48 = *glyphs++;
        int v47 = v48;
        if (v48 == 0xFFFF) {
          int v47 = 0;
        }
        if (!v47) {
          char v43 = 0;
        }
        *a3++ = v47;
        v15 -= 2;
      }
      while (v15);
    }
    else
    {
      char v43 = 1;
    }

    return v43 != 0;
  }

  return CTFontGetGlyphsForCharacters(this, a2, a3, a4);
}

uint64_t Provider(uint64_t a1, uint64_t *a2, const __CFDictionary **a3, void *a4)
{
  if (a1 < 0) {
    return 0;
  }
  uint64_t v4 = a4[1];
  BOOL v5 = v4 <= a1;
  uint64_t v6 = v4 - a1;
  if (v5) {
    return 0;
  }
  *a2 = v6;
  *a3 = (const __CFDictionary *)a4[2];
  return *a4 + 2 * a1;
}

char *std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__vallocate[abi:nn180100](void *a1, uint64_t a2)
{
  if (a2 < 0) {
    abort();
  }
  CFArrayRef result = (char *)TInlineBufferAllocator<unsigned short,30ul>::allocate((uint64_t)(a1 + 3), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[2 * a2];
  return result;
}

void std::__shared_ptr_emplace<TCharStreamUniChar>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ED062240;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TCharStreamUniChar>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ED062240;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1853275C0);
}

uint64_t std::__shared_ptr_emplace<TCharStreamUniChar>::__on_zero_shared(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 48))();
}

uint64_t TCFBase<TRun>::ClassEqual(uint64_t a1, uint64_t a2)
{
  return TRun::operator==(*(void *)(a1 + 40), *(void *)(a2 + 40));
}

void *TCFBase<TRun>::ClassHash(void *result)
{
  unint64_t v1 = result[3];
  uint64_t v2 = result[4];
  if (v2) {
    BOOL v3 = (result[4] & 1 | v1) == 0;
  }
  else {
    BOOL v3 = 1;
  }
  int v4 = !v3;
  if (v1) {
    BOOL v5 = 0;
  }
  else {
    BOOL v5 = v4 == 0;
  }
  if (!v5)
  {
    uint64_t v6 = (void *)(result[5] + (v2 >> 1));
    if (v2) {
      return (void *)(*(uint64_t (**)(void))(*v6 + v1))();
    }
    else {
      return (void *)((uint64_t (*)(void *))v1)(v6);
    }
  }
  return result;
}

__CFString *TCFBase<TRun>::ClassDebug(uint64_t a1)
{
  CFArrayRef result = TRun::DebugDescription(*(TRun **)(a1 + 40));
  if (result)
  {
    BOOL v3 = result;
    CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<%s: %p>{%@}", "CTRun", a1, result);
    CFRelease(v3);
    return (__CFString *)v4;
  }
  return result;
}

uint64_t TCharStream::LazyCopyChars(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = 0;
  uint64_t v4 = a1[1];
  uint64_t v5 = a1[2] + v4;
  if (a2 + a3 >= v5) {
    uint64_t v6 = a1[2] + v4;
  }
  else {
    uint64_t v6 = a2 + a3;
  }
  uint64_t v7 = v6 - v4;
  BOOL v8 = a2 <= v4 && v4 < a2 + a3;
  if (v8) {
    uint64_t v9 = a1[1];
  }
  else {
    uint64_t v9 = 0;
  }
  if (!v8) {
    uint64_t v7 = 0;
  }
  BOOL v10 = v4 <= a2 && a2 < v5;
  uint64_t v11 = v6 - a2;
  if (v10) {
    uint64_t v9 = a2;
  }
  if (!v10) {
    uint64_t v11 = v7;
  }
  if (v9 != a2 || v11 != a3) {
    return v3;
  }
  uint64_t v12 = a1[3];
  if (v12) {
    return v12 + 2 * a2 - 2 * v4;
  }
  return (*(uint64_t (**)(void))(*a1 + 72))();
}

uint64_t TUnicodeEncoder::HandleSurrogateChar(char ***a1, uint64_t a2, void *a3, int a4, uint64_t *a5)
{
  uint64_t v6 = (void *)(*a3 + 8 * a4);
  *a3 = v6;
  uint64_t v7 = *a5;
  uint64_t v8 = *a5 + 1;
  *a5 = v8;
  if (*(_WORD *)(a2 + 2 * v7))
  {
    *(_WORD *)(a2 + 2 * v8) = -1;
    *uint64_t v6 = 0;
    uint64_t v9 = *a1;
    BOOL v10 = (uint64_t *)(*a1)[1];
    unint64_t v11 = (unint64_t)(*a1)[2];
    if ((unint64_t)v10 < v11)
    {
      *BOOL v10 = v8;
      uint64_t v12 = (char *)(v10 + 1);
LABEL_29:
      uint64_t result = 0;
      v9[1] = v12;
      return result;
    }
    uint64_t v17 = (uint64_t *)*v9;
    uint64_t v18 = ((char *)v10 - *v9) >> 3;
    unint64_t v19 = v18 + 1;
    if (!((unint64_t)(v18 + 1) >> 61))
    {
      uint64_t v20 = v11 - (void)v17;
      if (v20 >> 2 > v19) {
        unint64_t v19 = v20 >> 2;
      }
      if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v21 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v21 = v19;
      }
      int v44 = v9 + 3;
      if (v21)
      {
        unsigned int v22 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)(v9 + 3), v21);
        uint64_t v17 = (uint64_t *)*v9;
        BOOL v10 = (uint64_t *)v9[1];
        uint64_t v8 = *a5;
      }
      else
      {
        unsigned int v22 = 0;
      }
      unint64_t v29 = (uint64_t *)&v22[8 * v18];
      *unint64_t v29 = v8;
      if (v10 == v17)
      {
        unint64_t v31 = &v22[8 * v18];
      }
      else
      {
        BOOL v30 = v10;
        unint64_t v31 = &v22[8 * v18];
        do
        {
          uint64_t v32 = *--v30;
          *((void *)v31 - 1) = v32;
          v31 -= 8;
        }
        while (v30 != v17);
      }
      uint64_t v12 = (char *)(v29 + 1);
      *uint64_t v9 = v31;
      uint64_t v40 = v17;
      unint64_t v41 = v17;
      v9[1] = (char *)(v29 + 1);
      unint64_t v42 = v10;
      long long v33 = v9[2];
      v9[2] = &v22[8 * v21];
      char v43 = v33;
      std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v40);
      goto LABEL_29;
    }
LABEL_39:
    abort();
  }
  unint64_t v13 = *a1;
  uint64_t v14 = (uint64_t *)(*a1)[1];
  unint64_t v15 = (unint64_t)(*a1)[2];
  if ((unint64_t)v14 >= v15)
  {
    CFDictionaryRef v23 = (uint64_t *)*v13;
    uint64_t v24 = ((char *)v14 - *v13) >> 3;
    unint64_t v25 = v24 + 1;
    if ((unint64_t)(v24 + 1) >> 61) {
      goto LABEL_39;
    }
    uint64_t v26 = v15 - (void)v23;
    if (v26 >> 2 > v25) {
      unint64_t v25 = v26 >> 2;
    }
    if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v27 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v27 = v25;
    }
    int v44 = v13 + 3;
    if (v27)
    {
      uint64_t v28 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)(v13 + 3), v27);
      CFDictionaryRef v23 = (uint64_t *)*v13;
      uint64_t v14 = (uint64_t *)v13[1];
      uint64_t v8 = *a5;
    }
    else
    {
      uint64_t v28 = 0;
    }
    double v35 = (uint64_t *)&v28[8 * v24];
    *double v35 = v8;
    if (v14 == v23)
    {
      int v37 = &v28[8 * v24];
    }
    else
    {
      unsigned int v36 = v14;
      int v37 = &v28[8 * v24];
      do
      {
        uint64_t v38 = *--v36;
        *((void *)v37 - 1) = v38;
        v37 -= 8;
      }
      while (v36 != v23);
    }
    uint64_t v16 = (char *)(v35 + 1);
    *unint64_t v13 = v37;
    uint64_t v40 = v23;
    unint64_t v41 = v23;
    v13[1] = (char *)(v35 + 1);
    unint64_t v42 = v14;
    uint64_t v39 = v13[2];
    v13[2] = &v28[8 * v27];
    char v43 = v39;
    std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v40);
  }
  else
  {
    *uint64_t v14 = v8;
    uint64_t v16 = (char *)(v14 + 1);
  }
  v13[1] = v16;
  return 8;
}

void TGlyphEncoder::AppendRunClone(uint64_t a1, atomic_ullong *a2, uint64_t a3, uint64_t a4)
{
  if ((a3 & 0x8000000000000000) == 0 && a4 > a3)
  {
    void v8[3] = v4;
    void v8[4] = v5;
    uint64_t v6 = *(int64x2_t **)(a1 + 200);
    (*(void (**)(id *__return_ptr))(atomic_load_explicit(a2, memory_order_acquire) + 64))(&v7);
    v8[0] = (id)atomic_exchange((atomic_ullong *volatile)&v7, 0);
    TLine::AppendRun(v6, (atomic_ullong *)v8);
  }
}

void TCFBase_NEW<CTRubyRun,CTRun *&,BOOL>(uint64_t *a1@<X0>, char *a2@<X1>, void *a3@<X8>)
{
  uint64_t v6 = TCFBase<TRun>::Allocate();
  if (v6)
  {
    id v7 = (void *)v6;
    uint64_t v8 = *a1;
    char v9 = *a2;
    uint64_t v10 = v6 + 72;
    v7[2] = 0;
    v7[3] = 0;
    v7[4] = 0;
    v7[5] = v10;
    v7[6] = v10;
    v7[7] = CTRubyRun::CloneEntire;
    void v7[8] = CTRubyRun::CloneRange;
    TRubyRun::TRubyRun(v10, v8, v9);
    id v11 = v7;
    *a3 = atomic_exchange((atomic_ullong *volatile)&v11, 0);
  }
  else
  {
    *a3 = 0;
  }
}

void TCFBase_NEW<CTTateChuYokoRun,CTRun *&>(uint64_t *a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = TCFBase<TRun>::Allocate();
  if (v4)
  {
    uint64_t v5 = (void *)v4;
    uint64_t v6 = *a1;
    uint64_t v7 = v4 + 72;
    v5[2] = 0;
    v5[3] = 0;
    v5[4] = 0;
    v5[5] = v7;
    v5[6] = v7;
    v5[7] = CTTateChuYokoRun::CloneEntire;
    v5[8] = CTTateChuYokoRun::CloneRange;
    TTateChuYokoRun::TTateChuYokoRun(v7, v6);
    id v8 = v5;
    *a2 = atomic_exchange((atomic_ullong *volatile)&v8, 0);
  }
  else
  {
    *a2 = 0;
  }
}

void TCFBase_NEW<CTTextEncapsulationRun,CTRun *&>(void *a1, uint64_t *a2)
{
  uint64_t v4 = TCFBase<TRun>::Allocate();
  if (v4)
  {
    uint64_t v5 = (void *)v4;
    uint64_t v6 = *a2;
    uint64_t v7 = v4 + 72;
    v5[2] = 0;
    v5[3] = 0;
    v5[4] = 0;
    v5[5] = v7;
    v5[6] = v7;
    v5[7] = CTTextEncapsulationRun::CloneEntire;
    v5[8] = CTTextEncapsulationRun::CloneRange;
    TTextEncapsulationRun::TTextEncapsulationRun(v7, v6);
    id v8 = v5;
    *a1 = atomic_exchange((atomic_ullong *volatile)&v8, 0);
  }
  else
  {
    *a1 = 0;
  }
}

void TGlyphEncoder::CreateRun(atomic_ullong *this, CFRange a2, const TAttributes *a3, const __CTFont *a4, const __CTFont *a5)
{
  CFIndex length = a2.length;
  locatiouint64_t n = (_CTGlyphStorage **)a2.location;
  *this = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v11 = TCFBase<TRun>::Allocate();
  if (v11)
  {
    uint64_t v12 = (void *)v11;
    unint64_t v13 = *location;
    uint64_t v14 = (TRun *)(v11 + 72);
    v12[2] = 0;
    void v12[3] = 0;
    v12[4] = 0;
    void v12[5] = v14;
    v12[6] = v14;
    v12[7] = CTGlyphRun::CloneEntire;
    v12[8] = CTGlyphRun::CloneRange;
    v18.locatiouint64_t n = length;
    v18.CFIndex length = (CFIndex)a3;
    TRun::TRun(v14, v18, v13, a4, a5);
    id v17 = v12;
    id v16 = (id)atomic_exchange((atomic_ullong *volatile)&v17, 0);
  }
  else
  {
    id v16 = 0;
  }
  *this = atomic_exchange((atomic_ullong *volatile)&v16, 0);

  id v17 = (id)0xAAAAAAAAAAAAAAAALL;
  TGlyphEncoder::CreateSpecialRun((atomic_ullong *)&v17, (uint64_t)location, atomic_load_explicit(this, memory_order_acquire), *((_WORD *)a4 + 69));
  if (atomic_load_explicit((atomic_ullong *volatile)&v17, memory_order_acquire)) {
    TCFRef<__CTFont const*>::Retain(this, (id)atomic_load_explicit((atomic_ullong *volatile)&v17, memory_order_acquire));
  }
  if (atomic_load_explicit(this, memory_order_acquire))
  {
    uint64_t v15 = *(void *)(atomic_load_explicit(this, memory_order_acquire) + 48);
    *(void *)(v15 + 8) = length;
    *(void *)(v15 + 16) = a3;
  }
}

void std::__throw_bad_optional_access[abi:nn180100]()
{
}

void std::__function::__func<TGlyphEncoder::AppendUnmappedCharRun(unsigned int,TCFRef<CTRun *> &,__CTFont const*,CFRange &,CFRange,TInlineVector<long,30ul> &,std::unique_ptr<TFontCascade const> &,__CFString const*,TGlyphEncoder::ClusterMatching,BOOL)::$_1::operator() const(CFRange,CTEmojiPolicy *)::{lambda(CFRange,unsigned int,BOOL *)#1},std::allocator<TGlyphEncoder::AppendUnmappedCharRun(unsigned int,TCFRef<CTRun *> &,__CTFont const*,CFRange &,CFRange,TInlineVector<long,30ul> &,std::unique_ptr<TFontCascade const> &,__CFString const*,TGlyphEncoder::ClusterMatching,BOOL)::$_1::operator() const(CFRange,CTEmojiPolicy *)::{lambda(CFRange,unsigned int,BOOL *)#1}>,void ()(CFRange,unsigned int,BOOL *)>::~__func()
{
}

__n128 std::__function::__func<TGlyphEncoder::AppendUnmappedCharRun(unsigned int,TCFRef<CTRun *> &,__CTFont const*,CFRange &,CFRange,TInlineVector<long,30ul> &,std::unique_ptr<TFontCascade const> &,__CFString const*,TGlyphEncoder::ClusterMatching,BOOL)::$_1::operator() const(CFRange,CTEmojiPolicy *)::{lambda(CFRange,unsigned int,BOOL *)#1},std::allocator<TGlyphEncoder::AppendUnmappedCharRun(unsigned int,TCFRef<CTRun *> &,__CTFont const*,CFRange &,CFRange,TInlineVector<long,30ul> &,std::unique_ptr<TFontCascade const> &,__CFString const*,TGlyphEncoder::ClusterMatching,BOOL)::$_1::operator() const(CFRange,CTEmojiPolicy *)::{lambda(CFRange,unsigned int,BOOL *)#1}>,void ()(CFRange,unsigned int,BOOL *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1ED0620D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<TGlyphEncoder::AppendUnmappedCharRun(unsigned int,TCFRef<CTRun *> &,__CTFont const*,CFRange &,CFRange,TInlineVector<long,30ul> &,std::unique_ptr<TFontCascade const> &,__CFString const*,TGlyphEncoder::ClusterMatching,BOOL)::$_1::operator() const(CFRange,CTEmojiPolicy *)::{lambda(CFRange,unsigned int,BOOL *)#1},std::allocator<TGlyphEncoder::AppendUnmappedCharRun(unsigned int,TCFRef<CTRun *> &,__CTFont const*,CFRange &,CFRange,TInlineVector<long,30ul> &,std::unique_ptr<TFontCascade const> &,__CFString const*,TGlyphEncoder::ClusterMatching,BOOL)::$_1::operator() const(CFRange,CTEmojiPolicy *)::{lambda(CFRange,unsigned int,BOOL *)#1}>,void ()(CFRange,unsigned int,BOOL *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ED0620D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<TGlyphEncoder::AppendUnmappedCharRun(unsigned int,TCFRef<CTRun *> &,__CTFont const*,CFRange &,CFRange,TInlineVector<long,30ul> &,std::unique_ptr<TFontCascade const> &,__CFString const*,TGlyphEncoder::ClusterMatching,BOOL)::$_1::operator() const(CFRange,CTEmojiPolicy *)::{lambda(CFRange,unsigned int,BOOL *)#1},std::allocator<TGlyphEncoder::AppendUnmappedCharRun(unsigned int,TCFRef<CTRun *> &,__CTFont const*,CFRange &,CFRange,TInlineVector<long,30ul> &,std::unique_ptr<TFontCascade const> &,__CFString const*,TGlyphEncoder::ClusterMatching,BOOL)::$_1::operator() const(CFRange,CTEmojiPolicy *)::{lambda(CFRange,unsigned int,BOOL *)#1}>,void ()(CFRange,unsigned int,BOOL *)>::operator()(uint64_t result, void *a2, UChar32 *a3, unsigned char **a4)
{
  uint64_t v4 = result;
  unsigned int v5 = *a3;
  if (*a2)
  {
    uint64_t v6 = *a4;
    if (v5 >= 0xFE0E && **(unsigned char **)(result + 8) != 0 && (v5 >> 4 < 0xFE1 || v5 - 127995 <= 4))
    {
      if (v5 == 65038) {
        int v9 = 1;
      }
      else {
        int v9 = 2;
      }
      ***(_DWORD ***)(result + 16) = v9;
    }
    *uint64_t v6 = 1;
  }
  else
  {
    __n128 result = u_hasBinaryProperty(*a3, UCHAR_EMOJI);
    **(unsigned char **)(v4 + 8) = result != 0;
    if (result)
    {
      __n128 result = u_hasBinaryProperty(v5, UCHAR_EMOJI_PRESENTATION);
      if (result) {
        ***(_DWORD ***)(v4 + 16) = 2;
      }
    }
  }
  return result;
}

void *std::__function::__value_func<void ()(CFRange,unsigned int,BOOL *)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void TFontCascade::~TFontCascade(TFontCascade *this)
{
  *((void *)this + 24) = 0;
}

void CTEmojiImageRun::CloneEntire(void *a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = TCFBase<TRun>::Allocate();
  if (v4)
  {
    unsigned int v5 = (void *)v4;
    uint64_t v6 = (TRun *)(v4 + 72);
    v5[2] = 0;
    v5[3] = 0;
    v5[4] = 0;
    v5[5] = v6;
    v5[6] = v6;
    v5[7] = CTEmojiImageRun::CloneEntire;
    v5[8] = CTEmojiImageRun::CloneRange;
    TRun::TRun(v6, (const TRun *)(a1 + 9));
    v5[9] = &unk_1ED05E390;
    v5[49] = a1[49];
    v5[50] = a1[50];
    id v8 = v5;
    id v7 = (id)atomic_exchange((atomic_ullong *volatile)&v8, 0);
  }
  else
  {
    id v7 = 0;
  }
  *a2 = atomic_exchange((atomic_ullong *volatile)&v7, 0);
}

void CTEmojiImageRun::CloneRange(uint64_t a1@<X0>, uint64_t a2@<X1>, CFIndex a3@<X2>, int a4@<W3>, void *a5@<X8>)
{
  uint64_t v10 = TCFBase<TRun>::Allocate();
  if (v10)
  {
    uint64_t v11 = (void *)v10;
    uint64_t v12 = v10 + 72;
    void v11[2] = 0;
    id v11[3] = 0;
    v11[4] = 0;
    v11[5] = v12;
    v11[6] = v12;
    v11[7] = CTEmojiImageRun::CloneEntire;
    v11[8] = CTEmojiImageRun::CloneRange;
    TRun::TRun(v12, a1 + 72, a2, a3, a4);
    v11[9] = &unk_1ED05E390;
    v11[49] = *(void *)(a1 + 392);
    v11[50] = *(void *)(a1 + 400);
    id v14 = v11;
    id v13 = (id)atomic_exchange((atomic_ullong *volatile)&v14, 0);
  }
  else
  {
    id v13 = 0;
  }
  *a5 = atomic_exchange((atomic_ullong *volatile)&v13, 0);
}

void CTMetricsDelegateRun::CloneEntire(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = TCFBase<TRun>::Allocate();
  if (v4)
  {
    unsigned int v5 = (void *)v4;
    uint64_t v6 = (TRun *)(v4 + 72);
    v5[2] = 0;
    v5[3] = 0;
    v5[4] = 0;
    v5[5] = v6;
    v5[6] = v6;
    v5[7] = CTMetricsDelegateRun::CloneEntire;
    v5[8] = CTMetricsDelegateRun::CloneRange;
    TRun::TRun(v6, (const TRun *)(a1 + 72));
    v5[9] = &unk_1ED05E990;
    id v8 = v5;
    id v7 = (id)atomic_exchange((atomic_ullong *volatile)&v8, 0);
  }
  else
  {
    id v7 = 0;
  }
  *a2 = atomic_exchange((atomic_ullong *volatile)&v7, 0);
}

void CTMetricsDelegateRun::CloneRange(uint64_t a1@<X0>, uint64_t a2@<X1>, CFIndex a3@<X2>, int a4@<W3>, void *a5@<X8>)
{
  uint64_t v10 = TCFBase<TRun>::Allocate();
  if (v10)
  {
    uint64_t v11 = (void *)v10;
    uint64_t v12 = v10 + 72;
    void v11[2] = 0;
    id v11[3] = 0;
    v11[4] = 0;
    v11[5] = v12;
    v11[6] = v12;
    v11[7] = CTMetricsDelegateRun::CloneEntire;
    v11[8] = CTMetricsDelegateRun::CloneRange;
    TRun::TRun(v12, a1 + 72, a2, a3, a4);
    v11[9] = &unk_1ED05E990;
    id v14 = v11;
    id v13 = (id)atomic_exchange((atomic_ullong *volatile)&v14, 0);
  }
  else
  {
    id v13 = 0;
  }
  *a5 = atomic_exchange((atomic_ullong *volatile)&v13, 0);
}

void CTRubyRun::CloneEntire(uint64_t a1@<X0>, void *a2@<X8>)
{
  TCFBase_NEW<CTRubyRun,TRubyRun const&>((const TRubyRun *)(a1 + 72), &v3);
  *a2 = atomic_exchange((atomic_ullong *volatile)&v3, 0);
}

void CTRubyRun::CloneRange(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int a4@<W3>, void *a5@<X8>)
{
  v8[0] = a2;
  v8[1] = a3;
  int v7 = a4;
  TCFBase_NEW<CTRubyRun,TRubyRun const&,CFRange &,TRun::SubrangingStyle &>(a1 + 72, v8, &v7, &v6);
  *a5 = atomic_exchange((atomic_ullong *volatile)&v6, 0);
}

void TCFBase_NEW<CTRubyRun,TRubyRun const&>(const TRubyRun *a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = TCFBase<TRun>::Allocate();
  if (v4)
  {
    unsigned int v5 = (void *)v4;
    id v6 = (TRubyRun *)(v4 + 72);
    v5[2] = 0;
    v5[3] = 0;
    v5[4] = 0;
    v5[5] = v6;
    v5[6] = v6;
    v5[7] = CTRubyRun::CloneEntire;
    v5[8] = CTRubyRun::CloneRange;
    TRubyRun::TRubyRun(v6, a1);
    id v7 = v5;
    *a2 = atomic_exchange((atomic_ullong *volatile)&v7, 0);
  }
  else
  {
    *a2 = 0;
  }
}

void TCFBase_NEW<CTRubyRun,TRubyRun const&,CFRange &,TRun::SubrangingStyle &>(uint64_t a1@<X0>, uint64_t *a2@<X1>, int *a3@<X2>, void *a4@<X8>)
{
  uint64_t v8 = TCFBase<TRun>::Allocate();
  if (v8)
  {
    int v9 = (void *)v8;
    uint64_t v10 = *a2;
    CFIndex v11 = a2[1];
    int v12 = *a3;
    uint64_t v13 = v8 + 72;
    v9[2] = 0;
    v9[3] = 0;
    _OWORD v9[4] = 0;
    v9[5] = v13;
    v9[6] = v13;
    v9[7] = CTRubyRun::CloneEntire;
    v9[8] = CTRubyRun::CloneRange;
    TRubyRun::TRubyRun(v13, a1, v10, v11, v12);
    id v14 = v9;
    *a4 = atomic_exchange((atomic_ullong *volatile)&v14, 0);
  }
  else
  {
    *a4 = 0;
  }
}

void CTTateChuYokoRun::CloneEntire(uint64_t a1@<X0>, void *a2@<X8>)
{
  TCFBase_NEW<CTTateChuYokoRun,TTateChuYokoRun const&>((const TTateChuYokoRun *)(a1 + 72), &v3);
  *a2 = atomic_exchange((atomic_ullong *volatile)&v3, 0);
}

void CTTateChuYokoRun::CloneRange(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int a4@<W3>, void *a5@<X8>)
{
  v8[0] = a2;
  v8[1] = a3;
  int v7 = a4;
  TCFBase_NEW<CTTateChuYokoRun,TTateChuYokoRun const&,CFRange &,TRun::SubrangingStyle &>(a1 + 72, v8, &v7, &v6);
  *a5 = atomic_exchange((atomic_ullong *volatile)&v6, 0);
}

void TCFBase_NEW<CTTateChuYokoRun,TTateChuYokoRun const&>(const TTateChuYokoRun *a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = TCFBase<TRun>::Allocate();
  if (v4)
  {
    unsigned int v5 = (void *)v4;
    id v6 = (TTateChuYokoRun *)(v4 + 72);
    v5[2] = 0;
    v5[3] = 0;
    v5[4] = 0;
    v5[5] = v6;
    v5[6] = v6;
    v5[7] = CTTateChuYokoRun::CloneEntire;
    v5[8] = CTTateChuYokoRun::CloneRange;
    TTateChuYokoRun::TTateChuYokoRun(v6, a1);
    id v7 = v5;
    *a2 = atomic_exchange((atomic_ullong *volatile)&v7, 0);
  }
  else
  {
    *a2 = 0;
  }
}

void TCFBase_NEW<CTTateChuYokoRun,TTateChuYokoRun const&,CFRange &,TRun::SubrangingStyle &>(uint64_t a1@<X0>, uint64_t *a2@<X1>, int *a3@<X2>, void *a4@<X8>)
{
  uint64_t v8 = TCFBase<TRun>::Allocate();
  if (v8)
  {
    int v9 = (void *)v8;
    uint64_t v10 = *a2;
    CFIndex v11 = a2[1];
    int v12 = *a3;
    uint64_t v13 = v8 + 72;
    v9[2] = 0;
    v9[3] = 0;
    _OWORD v9[4] = 0;
    v9[5] = v13;
    v9[6] = v13;
    v9[7] = CTTateChuYokoRun::CloneEntire;
    v9[8] = CTTateChuYokoRun::CloneRange;
    TTateChuYokoRun::TTateChuYokoRun(v13, a1, v10, v11, v12);
    id v14 = v9;
    *a4 = atomic_exchange((atomic_ullong *volatile)&v14, 0);
  }
  else
  {
    *a4 = 0;
  }
}

void CTTextEncapsulationRun::CloneEntire(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = TCFBase<TRun>::Allocate();
  if (v4)
  {
    unsigned int v5 = (void *)v4;
    id v6 = (TTextEncapsulationRun *)(v4 + 72);
    v5[2] = 0;
    v5[3] = 0;
    v5[4] = 0;
    v5[5] = v6;
    v5[6] = v6;
    v5[7] = CTTextEncapsulationRun::CloneEntire;
    v5[8] = CTTextEncapsulationRun::CloneRange;
    TTextEncapsulationRun::TTextEncapsulationRun(v6, (atomic_ullong *)(a1 + 72));
    id v8 = v5;
    id v7 = (id)atomic_exchange((atomic_ullong *volatile)&v8, 0);
  }
  else
  {
    id v7 = 0;
  }
  *a2 = atomic_exchange((atomic_ullong *volatile)&v7, 0);
}

void CTTextEncapsulationRun::CloneRange(uint64_t a1@<X0>, uint64_t a2@<X1>, CFIndex a3@<X2>, int a4@<W3>, void *a5@<X8>)
{
  uint64_t v10 = TCFBase<TRun>::Allocate();
  if (v10)
  {
    CFIndex v11 = (void *)v10;
    uint64_t v12 = v10 + 72;
    void v11[2] = 0;
    id v11[3] = 0;
    v11[4] = 0;
    v11[5] = v12;
    v11[6] = v12;
    v11[7] = CTTextEncapsulationRun::CloneEntire;
    v11[8] = CTTextEncapsulationRun::CloneRange;
    TTextEncapsulationRun::TTextEncapsulationRun(v12, a1 + 72, a2, a3, a4);
    id v14 = v11;
    id v13 = (id)atomic_exchange((atomic_ullong *volatile)&v14, 0);
  }
  else
  {
    id v13 = 0;
  }
  *a5 = atomic_exchange((atomic_ullong *volatile)&v13, 0);
}

void std::__function::__func<TGlyphEncoder::AppendUnmappedCharRun(unsigned int,TCFRef<CTRun *> &,__CTFont const*,CFRange &,CFRange,TInlineVector<long,30ul> &,std::unique_ptr<TFontCascade const> &,__CFString const*,TGlyphEncoder::ClusterMatching,BOOL)::$_0,std::allocator<TGlyphEncoder::AppendUnmappedCharRun(unsigned int,TCFRef<CTRun *> &,__CTFont const*,CFRange &,CFRange,TInlineVector<long,30ul> &,std::unique_ptr<TFontCascade const> &,__CFString const*,TGlyphEncoder::ClusterMatching,BOOL)::$_0>,BOOL ()(CFRange,unsigned int)>::~__func()
{
}

__n128 std::__function::__func<TGlyphEncoder::AppendUnmappedCharRun(unsigned int,TCFRef<CTRun *> &,__CTFont const*,CFRange &,CFRange,TInlineVector<long,30ul> &,std::unique_ptr<TFontCascade const> &,__CFString const*,TGlyphEncoder::ClusterMatching,BOOL)::$_0,std::allocator<TGlyphEncoder::AppendUnmappedCharRun(unsigned int,TCFRef<CTRun *> &,__CTFont const*,CFRange &,CFRange,TInlineVector<long,30ul> &,std::unique_ptr<TFontCascade const> &,__CFString const*,TGlyphEncoder::ClusterMatching,BOOL)::$_0>,BOOL ()(CFRange,unsigned int)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1ED060CE0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<TGlyphEncoder::AppendUnmappedCharRun(unsigned int,TCFRef<CTRun *> &,__CTFont const*,CFRange &,CFRange,TInlineVector<long,30ul> &,std::unique_ptr<TFontCascade const> &,__CFString const*,TGlyphEncoder::ClusterMatching,BOOL)::$_0,std::allocator<TGlyphEncoder::AppendUnmappedCharRun(unsigned int,TCFRef<CTRun *> &,__CTFont const*,CFRange &,CFRange,TInlineVector<long,30ul> &,std::unique_ptr<TFontCascade const> &,__CFString const*,TGlyphEncoder::ClusterMatching,BOOL)::$_0>,BOOL ()(CFRange,unsigned int)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ED060CE0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<TGlyphEncoder::AppendUnmappedCharRun(unsigned int,TCFRef<CTRun *> &,__CTFont const*,CFRange &,CFRange,TInlineVector<long,30ul> &,std::unique_ptr<TFontCascade const> &,__CFString const*,TGlyphEncoder::ClusterMatching,BOOL)::$_0,std::allocator<TGlyphEncoder::AppendUnmappedCharRun(unsigned int,TCFRef<CTRun *> &,__CTFont const*,CFRange &,CFRange,TInlineVector<long,30ul> &,std::unique_ptr<TFontCascade const> &,__CFString const*,TGlyphEncoder::ClusterMatching,BOOL)::$_0>,BOOL ()(CFRange,unsigned int)>::operator()(uint64_t a1, uint64_t a2, UChar32 *a3)
{
  unsigned int v4 = *a3;
  if (!**(unsigned char **)(a1 + 8))
  {
    if (u_hasBinaryProperty(*a3, UCHAR_EMOJI_PRESENTATION))
    {
      int v7 = 2;
    }
    else
    {
      if (v4 != 9792 && v4 != 9794 && v4 != 9877) {
        goto LABEL_26;
      }
      int v7 = 1;
    }
LABEL_25:
    **(_DWORD **)(a1 + 24) = v7;
    goto LABEL_26;
  }
  if (v4 >= 0xFE0E && **(unsigned char **)(a1 + 16) == 0 && (v4 >> 4 < 0xFE1 || v4 - 127995 <= 4))
  {
    if (v4 == 65038) {
      int v7 = 1;
    }
    else {
      int v7 = 2;
    }
    goto LABEL_25;
  }
LABEL_26:
  uint64_t v10 = *(unsigned char **)(a1 + 8);
  int v11 = *v10;
  *uint64_t v10 = 1;
  if (v11) {
    **(unsigned char **)(a1 + 16) = 1;
  }
  uint64_t result = u_hasBinaryProperty(v4, UCHAR_DEFAULT_IGNORABLE_CODE_POINT);
  if (result) {
    return !IsVisibleFormatter(v4);
  }
  return result;
}

void *std::__function::__value_func<BOOL ()(CFRange,unsigned int)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t TTypesetter::GetLevelsProvider@<X0>(uint64_t result@<X0>, uint64_t *a2@<X8>)
{
  id v3 = *(uint64_t **)(result + 32);
  if (!v3)
  {
    *a2 = 0;
    a2[1] = 0;
    goto LABEL_7;
  }
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1];
  *a2 = *v3;
  a2[1] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  if (!v4)
  {
LABEL_7:
    if ((*(unsigned char *)(result + 40) & 2) == 0)
    {
      id v6 = (id)0xAAAAAAAAAAAAAAAALL;
      (*(void (**)(id *__return_ptr))(**(void **)(result + 8) + 32))(&v6);
      if (atomic_load_explicit((atomic_ullong *volatile)&v6, memory_order_acquire))
      {
        atomic_load_explicit((atomic_ullong *volatile)&v6, memory_order_acquire);
        operator new();
      }
      operator new();
    }
    operator new();
  }
  return result;
}

uint64_t TRunGlue::operator=(uint64_t a1, long long *a2)
{
  long long v4 = *a2;
  long long v5 = a2[1];
  long long v6 = a2[2];
  *(void *)(a1 + 48) = *((void *)a2 + 6);
  *(_OWORD *)(a1 + 16) = v5;
  *(_OWORD *)(a1 + 32) = v6;
  *(_OWORD *)a1 = v4;
  std::vector<std::pair<UScriptCode,long>,TInlineBufferAllocator<std::pair<UScriptCode,long>,1ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<std::pair<UScriptCode,long> const*>,std::__wrap_iter<std::pair<UScriptCode,long> const*>>((char *)(a1 + 56), *((long long **)a2 + 7), *((long long **)a2 + 8), (uint64_t)(*((void *)a2 + 8) - *((void *)a2 + 7)) >> 4);
  long long v7 = *(long long *)((char *)a2 + 104);
  *(_OWORD *)(a1 + 120) = *(long long *)((char *)a2 + 120);
  *(_OWORD *)(a1 + 104) = v7;
  *(_OWORD *)(a1 + 136) = *(long long *)((char *)a2 + 136);
  long long v8 = *(long long *)((char *)a2 + 152);
  long long v9 = *(long long *)((char *)a2 + 168);
  long long v10 = *(long long *)((char *)a2 + 184);
  *(void *)(a1 + 200) = *((void *)a2 + 25);
  *(_OWORD *)(a1 + 184) = v10;
  *(_OWORD *)(a1 + 168) = v9;
  *(_OWORD *)(a1 + 152) = v8;
  std::vector<unsigned char,TInlineBufferAllocator<unsigned char,128ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned char const*>,std::__wrap_iter<unsigned char const*>>((void *)(a1 + 208), *((char **)a2 + 26), *((char **)a2 + 27), *((void *)a2 + 27) - *((void *)a2 + 26));
  std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned int const*>,std::__wrap_iter<unsigned int const*>>((void *)(a1 + 368), *((char **)a2 + 46), *((void *)a2 + 47), (uint64_t)(*((void *)a2 + 47) - *((void *)a2 + 46)) >> 2);
  long long v11 = *(long long *)((char *)a2 + 520);
  long long v12 = *(long long *)((char *)a2 + 536);
  *(void *)(a1 + 552) = *((void *)a2 + 69);
  *(_OWORD *)(a1 + 520) = v11;
  *(_OWORD *)(a1 + 536) = v12;
  std::function<BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::operator=((void *)(a1 + 560), (uint64_t)(a2 + 35));
  long long v13 = a2[40];
  long long v15 = a2[37];
  long long v14 = a2[38];
  *(_OWORD *)(a1 + 624) = a2[39];
  *(_OWORD *)(a1 + 640) = v13;
  *(_OWORD *)(a1 + 592) = v15;
  *(_OWORD *)(a1 + 608) = v14;
  return a1;
}

uint64_t TTypesetter::ApplyVerticalLayout(TLine &,TCharStream const*,signed char *)::$_0::operator()(void **a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v22 = a2;
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)**a1 + 40))(**a1);
  uint64_t v8 = v6;
  uint64_t v9 = *a1[1];
  uint64_t v10 = *(void *)(v9 + 8);
  uint64_t v11 = *(void *)(v9 + 16);
  uint64_t v12 = v11 + v10;
  if (v6 + v7 >= v11 + v10) {
    uint64_t v13 = v11 + v10;
  }
  else {
    uint64_t v13 = v6 + v7;
  }
  if (v10 <= v6 && v6 < v12)
  {
    uint64_t v16 = v13 - v6;
  }
  else if (v6 <= v10 && v10 < v6 + v7)
  {
    uint64_t v16 = v13 - v10;
    uint64_t v8 = v10;
  }
  else
  {
    uint64_t v8 = 0;
    uint64_t v16 = 0;
  }
  unsigned int FullChar = TCharStreamIterator::GetFullChar((TCharStreamIterator *)*a1, &v22, 0);
  IntPropertyCFDictionaryRef Value = u_getIntPropertyValue(FullChar, UCHAR_VERTICAL_ORIENTATION);
  if ((~FullChar & 0x2C0) != 0
    || (unsigned __int16)FullChar - 711 > 0x24
    || ((1 << (FullChar + 57)) & 0x180004001DLL) == 0)
  {
    if (FullChar >= 0xE000 && (FullChar >> 11 < 0x1F || FullChar >= 0xF0000 && FullChar - 1114110 <= 0xFFFFFC01)) {
      IntPropertyCFDictionaryRef Value = 1;
    }
  }
  else
  {
    IntPropertyCFDictionaryRef Value = 2;
  }
  while (++v22 < v8 + v16)
  {
    UChar32 v19 = TCharStreamIterator::GetFullChar((TCharStreamIterator *)*a1, &v22, 0);
    if (u_charType(v19) == 7)
    {
      IntPropertyCFDictionaryRef Value = 3;
      goto LABEL_32;
    }
  }
  if ((IntPropertyValue - 1) <= 1)
  {
    CFIndex v20 = *(unsigned __int16 *)(*(void *)(*(void *)(*a1[1] + 216) + 16)
                              + 2 * *(void *)(*a1[1] + 200)
                              + 2 * TRun::GetGlyphIndexForCharIndex<false>(*a1[1], a2));
    if (*a1[2] > v20)
    {
      if (CFBitVectorGetBitAtIndex((CFBitVectorRef)atomic_load_explicit(a1[3], memory_order_acquire), v20)) {
        IntPropertyCFDictionaryRef Value = 3;
      }
      else {
        IntPropertyCFDictionaryRef Value = IntPropertyValue;
      }
    }
  }
LABEL_32:
  *a3 = v8;
  a3[1] = v16;
  return IntPropertyValue;
}

void TTypesetter::SetVerticalFont(atomic_ullong *this, TRun *a2, const __CTFont *a3)
{
  long long v4 = (TAttributes *)(this + 5);
  TAttributes::SetVerticalFont((TAttributes *)(this + 5), a2);
  long long v5 = (char *)(this + 24);
  uint64_t v6 = *(void *)(atomic_load_explicit(this + 7, memory_order_acquire) + 40);
  uint64_t RenderingStyle = TAttributes::GetRenderingStyle(v4);

  TStorageRange::ResetAdvances((uint64_t)v5, v6, RenderingStyle);
}

char *std::vector<std::pair<UScriptCode,long>,TInlineBufferAllocator<std::pair<UScriptCode,long>,1ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<std::pair<UScriptCode,long> const*>,std::__wrap_iter<std::pair<UScriptCode,long> const*>>(char *result, long long *a2, long long *a3, unint64_t a4)
{
  uint64_t v6 = a2;
  uint64_t v7 = result;
  uint64_t v8 = *(void *)result;
  if (a4 > (uint64_t)(*((void *)result + 2) - *(void *)result) >> 4)
  {
    std::vector<std::pair<UScriptCode,long>,TInlineBufferAllocator<std::pair<UScriptCode,long>,1ul>>::__vdeallocate((uint64_t)result);
    if (a4 >> 60) {
      abort();
    }
    uint64_t v9 = *((void *)v7 + 2) - *(void *)v7;
    uint64_t v10 = v9 >> 3;
    if (v9 >> 3 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v11 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    uint64_t result = std::vector<std::pair<UScriptCode,long>,TInlineBufferAllocator<std::pair<UScriptCode,long>,1ul>>::__vallocate[abi:nn180100](v7, v11);
    long long v14 = (char *)*((void *)v7 + 1);
    uint64_t v13 = v7 + 8;
    uint64_t v12 = v14;
    long long v15 = v14;
    if (v6 != a3)
    {
      long long v15 = v12;
      do
      {
        long long v16 = *v6++;
        *(_OWORD *)long long v15 = v16;
        v15 += 16;
      }
      while (v6 != a3);
    }
LABEL_18:
    unint64_t v21 = (char *)(v15 - v12);
    goto LABEL_23;
  }
  uint64_t v13 = result + 8;
  uint64_t v12 = (char *)*((void *)result + 1);
  unint64_t v17 = (uint64_t)&v12[-v8] >> 4;
  if (v17 < a4)
  {
    CFRange v18 = &a2[v17];
    if (v12 != (char *)v8)
    {
      do
      {
        *(_DWORD *)uint64_t v8 = *(_DWORD *)v6;
        *(void *)(v8 + 8) = *((void *)v6++ + 1);
        v8 += 16;
      }
      while (v6 != v18);
    }
    long long v15 = v12;
    if (v18 != a3)
    {
      UChar32 v19 = v12;
      do
      {
        long long v20 = *v18++;
        *(_OWORD *)UChar32 v19 = v20;
        v19 += 16;
        v15 += 16;
      }
      while (v18 != a3);
    }
    goto LABEL_18;
  }
  uint64_t v22 = *(void *)result;
  if (a2 != a3)
  {
    uint64_t v23 = *(void *)result;
    do
    {
      *(_DWORD *)uint64_t v23 = *(_DWORD *)v6;
      *(void *)(v23 + 8) = *((void *)v6 + 1);
      v22 += 16;
      ++v6;
      v23 += 16;
    }
    while (v6 != a3);
  }
  unint64_t v21 = (char *)(v22 - v8);
  uint64_t v12 = (char *)v8;
LABEL_23:
  *uint64_t v13 = &v21[(void)v12];
  return result;
}

void std::vector<std::pair<UScriptCode,long>,TInlineBufferAllocator<std::pair<UScriptCode,long>,1ul>>::__vdeallocate(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  if (v2)
  {
    *(void *)(a1 + 8) = v2;
    id v3 = (void *)(a1 + 40);
    if (a1 + 24 <= (unint64_t)v2 && v3 > v2)
    {
      if (*(void *)(a1 + 16) == *(void *)(a1 + 40)) {
        *id v3 = v2;
      }
    }
    else
    {
      operator delete(v2);
    }
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
  }
}

char *std::vector<std::pair<UScriptCode,long>,TInlineBufferAllocator<std::pair<UScriptCode,long>,1ul>>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >> 60) {
    abort();
  }
  uint64_t result = (char *)TInlineBufferAllocator<std::pair<UScriptCode,long>,1ul>::allocate((uint64_t)(a1 + 3), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * a2];
  return result;
}

void *TInlineBufferAllocator<std::pair<UScriptCode,long>,1ul>::allocate(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v2 = (unint64_t *)(a1 + 16);
  uint64_t v3 = v4;
  unint64_t v5 = v4 + 16 * a2;
  if (v5 <= (unint64_t)v2)
  {
    *uint64_t v2 = v5;
    return (void *)v3;
  }
  else
  {
    if (a2 >> 60) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    return operator new(16 * a2);
  }
}

void *std::vector<unsigned char,TInlineBufferAllocator<unsigned char,128ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned char const*>,std::__wrap_iter<unsigned char const*>>(void *result, char *__src, char *a3, unint64_t a4)
{
  uint64_t v7 = result;
  uint64_t v8 = (char *)*result;
  if (result[2] - *result < a4)
  {
    std::vector<unsigned char,TInlineBufferAllocator<unsigned char,128ul>>::__vdeallocate((uint64_t)result);
    if ((a4 & 0x8000000000000000) != 0) {
      abort();
    }
    unint64_t v9 = v7[2] - *v7;
    uint64_t v10 = 2 * v9;
    if (2 * v9 <= a4) {
      uint64_t v10 = a4;
    }
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v11 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v11 = v10;
    }
    uint64_t result = std::vector<unsigned char,TInlineBufferAllocator<unsigned char,128ul>>::__vallocate[abi:nn180100](v7, v11);
    uint64_t v8 = (char *)v7[1];
    goto LABEL_15;
  }
  uint64_t v12 = (unsigned char *)result[1];
  if (v12 - v8 >= a4)
  {
LABEL_15:
    size_t v15 = a3 - __src;
    if (v15) {
      uint64_t result = memmove(v8, __src, v15);
    }
    long long v14 = &v8[v15];
    goto LABEL_18;
  }
  uint64_t v13 = &__src[v12 - v8];
  if (v12 != v8)
  {
    uint64_t result = memmove((void *)*result, __src, v12 - v8);
    uint64_t v8 = (char *)v7[1];
  }
  if (a3 != v13) {
    uint64_t result = memmove(v8, v13, a3 - v13);
  }
  long long v14 = &v8[a3 - v13];
LABEL_18:
  v7[1] = v14;
  return result;
}

void std::vector<unsigned char,TInlineBufferAllocator<unsigned char,128ul>>::__vdeallocate(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  if (v2)
  {
    *(void *)(a1 + 8) = v2;
    uint64_t v3 = (void *)(a1 + 152);
    if (a1 + 24 <= (unint64_t)v2 && v3 > v2)
    {
      if (*(void *)(a1 + 16) == *(void *)(a1 + 152)) {
        *uint64_t v3 = v2;
      }
    }
    else
    {
      operator delete(v2);
    }
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
  }
}

void *std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned int const*>,std::__wrap_iter<unsigned int const*>>(void *result, char *__src, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = result;
  uint64_t v8 = (char *)*result;
  if (a4 > (uint64_t)(result[2] - *result) >> 2)
  {
    std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__vdeallocate((uint64_t)result);
    if (a4 >> 62) {
      abort();
    }
    uint64_t v9 = v7[2] - *v7;
    uint64_t v10 = v9 >> 1;
    if (v9 >> 1 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v11 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    uint64_t result = std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__vallocate[abi:nn180100](v7, v11);
    uint64_t v13 = (char *)v7[1];
    uint64_t v12 = (char **)(v7 + 1);
    uint64_t v8 = v13;
LABEL_14:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      CFRange v18 = v8;
      UChar32 v19 = __src;
      goto LABEL_16;
    }
    goto LABEL_17;
  }
  uint64_t v12 = (char **)(result + 1);
  long long v14 = (unsigned char *)result[1];
  unint64_t v15 = (v14 - v8) >> 2;
  if (v15 >= a4) {
    goto LABEL_14;
  }
  long long v16 = &__src[4 * v15];
  if (v14 != v8)
  {
    uint64_t result = memmove((void *)*result, __src, 4 * v15);
    uint64_t v8 = *v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    CFRange v18 = v8;
    UChar32 v19 = v16;
LABEL_16:
    uint64_t result = memmove(v18, v19, v17);
  }
LABEL_17:
  *uint64_t v12 = &v8[v17];
  return result;
}

void VerticalFormsFeature(void)::$_0::__invoke()
{
  uint64_t v0 = [NSNumber numberWithUnsignedShort:4];
  id v1 = -[CTFeatureSetting initWithType:selector:tag:value:]([CTFeatureSetting alloc], v0, [NSNumber numberWithUnsignedShort:0], 0, 0);
  qword_1EB2CDED0 = atomic_exchange((atomic_ullong *volatile)&v1, 0);
}

void RotationCopyOf(__CTFont const*)::$_0::__invoke()
{
  v4[1] = *MEMORY[0x1E4F143B8];
  uint64_t v0 = [NSNumber numberWithUnsignedShort:4];
  id v1 = -[CTFeatureSetting initWithType:selector:tag:value:]([CTFeatureSetting alloc], v0, [NSNumber numberWithUnsignedShort:2], 0, 0);
  uint64_t v2 = v1;
  uint64_t v3 = @"NSCTFontFeatureSettingsAttribute";
  v4[0] = [MEMORY[0x1E4F1C978] arrayWithObjects:&v2 count:1];
  qword_1EB2CDEE0 = (uint64_t)CTFontDescriptorCreateWithAttributes((CFDictionaryRef)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v4 forKeys:&v3 count:1]);
}

void std::__shared_ptr_emplace<TCallbackBidiLevelsProvider>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ED062320;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TCallbackBidiLevelsProvider>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ED062320;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1853275C0);
}

uint64_t std::__shared_ptr_emplace<TCallbackBidiLevelsProvider>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<TCharStreamCFString>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ED062278;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TCharStreamCFString>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ED062278;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1853275C0);
}

void std::__shared_ptr_pointer<TBidiLevelsProvider  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1853275C0);
}

uint64_t std::__shared_ptr_pointer<TBidiLevelsProvider  *>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

CFTypeID CTLineGetTypeID(void)
{
  if (TCFBase<TLine>::GetTypeID(void)::once != -1) {
    dispatch_once_f(&TCFBase<TLine>::GetTypeID(void)::once, 0, (dispatch_function_t)TCFBase<TLine>::GetTypeID(void)::{lambda(void *)#1}::__invoke);
  }
  return TCFBase<TLine>::fTypeID;
}

CFArrayRef CTLineCreateWithRunArray(CFArrayRef theArray)
{
  CFArrayRef v1 = theArray;
  if (theArray)
  {
    if (CFArrayGetCount(theArray) < 1)
    {
      return 0;
    }
    else
    {
      uint64_t v2 = TCFBase<TLine>::Allocate();
      if (v2)
      {
        uint64_t v3 = (void *)v2;
        uint64_t v4 = (TLine *)(v2 + 48);
        v3[2] = 0;
        v3[3] = 0;
        v3[4] = 0;
        void v3[5] = v4;
        TLine::TLine(v4, v1);
        id v12 = v3;
        id v11 = (id)atomic_exchange((atomic_ullong *volatile)&v12, 0);
      }
      else
      {
        id v11 = 0;
      }
      CFArrayRef v1 = (CFArrayRef)atomic_exchange((atomic_ullong *volatile)&v11, 0);

      uint64_t v5 = *((void *)v1 + 5);
      uint64_t v6 = *(uint64_t **)(v5 + 16);
      uint64_t v7 = *(void *)(v5 + 24) - (void)v6;
      if (v7 >= 1)
      {
        uint64_t v8 = (unint64_t)v7 >> 3;
        if (v8 <= 1) {
          uint64_t v8 = 1;
        }
        do
        {
          uint64_t v9 = *v6++;
          *(void *)(*(void *)(v9 + 48) + 272) = v5;
          --v8;
        }
        while (v8);
      }
    }
  }
  return v1;
}

unint64_t CTLineCreateWithUniCharProvider(const unsigned __int16 *(*a1)(uint64_t, uint64_t *, const __CFDictionary **, void *), void (*a2)(const unsigned __int16 *, void *), void *a3)
{
  __dst[34] = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  memcpy(__dst, &unk_184B88B40, 0x110uLL);
  TTypesetterUniChar::TTypesetterUniChar((TTypesetterUniChar *)__dst, a1, a2, a3);
  id v8 = (id)0xAAAAAAAAAAAAAAAALL;
  TCFBase_NEW<CTLine,std::shared_ptr<TCharStream const> const&>(__dst, &v8);
  if (atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire))
  {
    TTypesetter::FillLine((TTypesetter *)__dst, *(TLine **)(atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire) + 40), 1.79769313e308, 0.0);
    unint64_t v6 = ExternalizeLine((atomic_ullong *)&v8);
  }
  else
  {
    unint64_t v6 = 0;
  }

  if (__dst[31]) {
    std::__shared_weak_count::__release_shared[abi:nn180100]((std::__shared_weak_count *)__dst[31]);
  }
  TLine::~TLine((TLine *)__dst);
  return v6;
}

CTLineRef CTLineCreateJustifiedLine(CTLineRef line, CGFloat justificationFactor, double justificationWidth)
{
  uint64_t v3 = 0;
  if (line && justificationWidth >= 0.0)
  {
    double v4 = 1.0;
    if (justificationFactor <= 1.0) {
      double v4 = justificationFactor;
    }
    BOOL v5 = justificationFactor < 0.0;
    double v6 = 0.0;
    if (!v5) {
      double v6 = v4;
    }
    TJustEngine::CreateJustifiedLine(*((const TCharStream ***)line + 5), 0, v6, justificationWidth, (unint64_t *)&v8);
    uint64_t v3 = (const __CTLine *)ExternalizeLine((atomic_ullong *)&v8);
  }
  return v3;
}

uint64_t CTLineGetRunCount(uint64_t result)
{
  if (result) {
    return (uint64_t)(*(void *)(*(void *)(result + 40) + 24) - *(void *)(*(void *)(result + 40) + 16)) >> 3;
  }
  return result;
}

uint64_t CTLineGetRunAtIndex(uint64_t result, uint64_t a2)
{
  if (result) {
    return *(void *)(*(void *)(*(void *)(result + 40) + 16) + 8 * a2);
  }
  return result;
}

CGRect CTLineGetImageBounds(CTLineRef line, CGContextRef context)
{
  if (line)
  {
    uint64_t v3 = (CFIndex *)*((void *)line + 5);
    v16.CFIndex length = v3[18];
    v16.locatiouint64_t n = 0;
    Imagedouble Bounds = TLine::GetImageBounds((TLine *)v3, context, v16);
    CGFloat y = v5;
    CGFloat width = v7;
    CGFloat height = v9;
    if (context)
    {
      TextPositiouint64_t n = CGContextGetTextPosition(context);
      v17.origin.double x = ImageBounds;
      v17.origin.CGFloat y = y;
      v17.size.CGFloat width = width;
      v17.size.CGFloat height = height;
      CGRect v18 = CGRectOffset(v17, TextPosition.x, TextPosition.y);
      Imagedouble Bounds = v18.origin.x;
      CGFloat y = v18.origin.y;
      CGFloat width = v18.size.width;
      CGFloat height = v18.size.height;
    }
  }
  else
  {
    Imagedouble Bounds = *MEMORY[0x1E4F1DB20];
    CGFloat y = *(double *)(MEMORY[0x1E4F1DB20] + 8);
    CGFloat width = *(double *)(MEMORY[0x1E4F1DB20] + 16);
    CGFloat height = *(double *)(MEMORY[0x1E4F1DB20] + 24);
  }
  double v12 = ImageBounds;
  double v13 = y;
  double v14 = width;
  double v15 = height;
  result.size.CGFloat height = v15;
  result.size.CGFloat width = v14;
  result.origin.CGFloat y = v13;
  result.origin.double x = v12;
  return result;
}

CFIndex CTLineGetStringIndexForPosition(CTLineRef line, CGPoint position)
{
  if (line) {
    return TLine::PositionToCharIndex(*((TLine **)line + 5), position);
  }
  else {
    return -1;
  }
}

unint64_t CTLineCopyCaretPathForStringIndex(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 0;
  }
  TLine::CopyCaretPath(*(TLine **)(a1 + 40), a2, (unint64_t *)&v4);
  unint64_t v2 = atomic_exchange((atomic_ullong *volatile)&v4, 0);

  return v2;
}

unint64_t CTLineCopyHighlightPathForStringRange(uint64_t a1, CFRange a2)
{
  if (!a1) {
    return 0;
  }
  TLine::CopyHighlightPath(*(TLine **)(a1 + 40), a2, (unint64_t *)&v4);
  unint64_t v2 = atomic_exchange((atomic_ullong *volatile)&v4, 0);

  return v2;
}

void CTLineEnumerateCaretOffsets(CTLineRef line, void *block)
{
  v3[4] = *MEMORY[0x1E4F143B8];
  if (line)
  {
    if (block)
    {
      unint64_t v2 = (uint64_t *)*((void *)line + 5);
      v3[0] = &unk_1ED05FBB8;
      v3[1] = _Block_copy(block);
      v3[3] = v3;
      TLine::EnumerateCaretOffsets(v2, (uint64_t)v3);
      std::__function::__value_func<void ()(double,long,BOOL,BOOL *)>::~__value_func[abi:nn180100](v3);
    }
  }
}

CFIndex CTLineGetRangeOfCharacterClusterAtIndex(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  void v60[2] = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return -1;
  }
  double v5 = *(TLine **)(a1 + 40);
  double v6 = (void *)*((void *)v5 + 9);
  if ((uint64_t)v6 > a2 || (uint64_t)v6 + *((void *)v5 + 10) <= a2) {
    return -1;
  }
  memset(v59, 170, sizeof(v59));
  CFIndex ClusterRange = TLine::GetClusterRange(v5, *(void **)v5, a2, 2, &v59[1], 0, v59);
  if (a3 | a4)
  {
    CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    id v57 = 0;
    if (a4) {

    }
    id v11 = (void *)*((void *)v5 + 2);
    double v12 = (void *)*((void *)v5 + 3);
    CFIndex v47 = ClusterRange;
    CFAllocatorRef allocator = v10;
    if (v11 == v12)
    {
      int64_t v16 = 0xAAAAAAAAAAAAAAAALL;
      double v14 = (void *)*((void *)v5 + 2);
    }
    else
    {
      uint64_t v13 = 0;
      double v14 = (void *)*((void *)v5 + 2);
      while (1)
      {
        uint64_t v15 = *(void *)(*(void *)(*v14 + 40) + 208) + v13;
        if (v15 > *(uint64_t *)&v59[1]) {
          break;
        }
        ++v14;
        uint64_t v13 = v15;
        if (v14 == v12)
        {
          int64_t v16 = 0xAAAAAAAAAAAAAAAALL;
          double v14 = (void *)*((void *)v5 + 3);
          goto LABEL_16;
        }
      }
      int64_t v16 = *(void *)&v59[1] - v13;
    }
LABEL_16:
    uint64_t v17 = *(void *)&v59[3];
    if (*(uint64_t *)&v59[3] < 1) {
      goto LABEL_50;
    }
    uint64_t v18 = v14 - v11;
    int v48 = v5;
    unint64_t v49 = (void *)a4;
    while (1)
    {
      UChar32 v19 = (void *)MEMORY[0x185327A40]();
      long long v20 = (void *)*((void *)v5 + 2);
      if (v18 >= (uint64_t)(*((void *)v5 + 3) - (void)v20) >> 3)
      {
LABEL_50:
        CFIndex ClusterRange = v47;
        if (a3)
        {
          if ((v59[0] & 0x80000000) == 0)
          {
            *(void *)a3 = atomic_exchange((atomic_ullong *volatile)&Mutable, 0);
            goto LABEL_53;
          }
          *(void *)&m.double a = CFArrayCreateMutable(allocator, 0, MEMORY[0x1E4F1D510]);
          CFIndex Count = CFArrayGetCount((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire));
          if (Count >= 1)
          {
            unint64_t v44 = Count + 1;
            do
            {
              int ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), v44 - 2);
              CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&m, memory_order_acquire), ValueAtIndex);
              --v44;
            }
            while (v44 > 1);
          }
          *(void *)a3 = atomic_exchange((atomic_ullong *volatile)&m, 0);

          if (!a4)
          {
LABEL_55:

            return ClusterRange;
          }
        }
        else
        {
LABEL_53:
          if (!a4) {
            goto LABEL_55;
          }
        }
        *(void *)a4 = atomic_exchange((atomic_ullong *volatile)&v57, 0);
        goto LABEL_55;
      }
      CFDictionaryRef v53 = v19;
      unint64_t v21 = *(__n128 **)(v20[v18] + 40);
      unint64_t v22 = v21[16].n128_u64[1];
      uint64_t v23 = v21[13].n128_i64[0];
      unint64_t v51 = v22;
      uint64_t v52 = *(void *)(v21[13].n128_u64[1] + 16);
      unint64_t v50 = v21[12].n128_u64[1];
      uint64_t v24 = v23 - v16;
      if (v23 >= v16) {
        uint64_t v23 = v16;
      }
      if (v23 < 1)
      {
        int64_t v26 = v16;
      }
      else
      {
        unint64_t v25 = (__int16 *)(v52 + 2 * v50);
        int64_t v26 = v16;
        do
        {
          int v28 = *v25++;
          int v27 = v28;
          BOOL v30 = v22-- != 0;
          uint64_t v31 = v27 == -1 && v30;
          v26 -= v31;
          --v23;
        }
        while (v23);
      }
      if (v24 >= v17) {
        uint64_t v24 = v17;
      }
      uint64_t v54 = v24;
      if (!a4) {
        goto LABEL_40;
      }
      uint64_t v32 = *(TFont **)(atomic_load_explicit(&v21[3].n128_i64[1], memory_order_acquire) + 40);
      TRun::GetPositions(v21, 0);
      if (v54 >= 1) {
        break;
      }
LABEL_49:
      v17 -= v54;
      ++v18;
      int64_t v16 = 0;
      double v5 = v48;
      a4 = (unint64_t)v49;
      if (v17 <= 0) {
        goto LABEL_50;
      }
    }
    double v34 = (CGFloat *)(v33 + 16 * v16 + 8);
    int64_t v35 = v16;
    do
    {
      id v56 = (id)0xAAAAAAAAAAAAAAAALL;
      TFont::CreatePathForGlyph(v32, 0, *(unsigned __int16 *)(v52 + 2 * v50 + 2 * v35), &v56);
      if (atomic_load_explicit((atomic_ullong *volatile)&v56, memory_order_acquire))
      {
        *(void *)&long long v36 = -1;
        *((void *)&v36 + 1) = -1;
        *(_OWORD *)&m.c = v36;
        *(_OWORD *)&m.tdouble x = v36;
        *(_OWORD *)&m.double a = v36;
        CGAffineTransformMakeTranslation(&m, *(v34 - 1), *v34);
        CGPathAddPath((CGMutablePathRef)atomic_load_explicit((atomic_ullong *volatile)&v57, memory_order_acquire), &m, (CGPathRef)atomic_load_explicit((atomic_ullong *volatile)&v56, memory_order_acquire));
      }

      ++v35;
      v34 += 2;
    }
    while (v35 < v54 + v16);
LABEL_40:
    if (v54 >= 1)
    {
      unint64_t v37 = v54 + 1;
      unint64_t v38 = v51 - v16;
      uint64_t v39 = (__int16 *)(v52 + 2 * v16 + 2 * v50);
      do
      {
        int v40 = *v39++;
        if (v40 != -1 || v38 == 0)
        {
          v60[0] = [NSNumber numberWithLong:v18];
          v60[1] = [NSNumber numberWithLong:v26];
          CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), (const void *)[MEMORY[0x1E4F1C978] arrayWithObjects:v60 count:2]);
          ++v26;
        }
        --v37;
        --v38;
      }
      while (v37 > 1);
    }
    goto LABEL_49;
  }
  return ClusterRange;
}

void CTLineDrawAttributedString(const __CFAttributedString *a1, CGContext *a2)
{
  __dst[34] = *(std::__shared_weak_count **)MEMORY[0x1E4F143B8];
  memcpy(__dst, &unk_184B88B40, 0x110uLL);
  TTypesetterAttrString::TTypesetterAttrString((TTypesetterAttrString *)__dst, a1, 0, 0);
  int v16 = unk_184B88CEC;
  long long v18 = unk_184B88D00;
  memset(&v9[8], 170, 24);
  *(void *)double v9 = 0;
  long long v7 = 0u;
  long long v8 = 0u;
  CFAllocatorRef v10 = &v9[8];
  BYTE8(v18) = 0;
  uint64_t v14 = 0;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  memset(&v15[8], 0, 20);
  long long v17 = 0uLL;
  LOBYTE(v18) = 0;
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  uint64_t v19 = 0;
  *(void *)uint64_t v15 = 0xFFEFFFFFFFFFFFFFLL;
  TTypesetter::FillLine((TTypesetter *)__dst, (TLine *)&v7, 1.79769313e308, 0.0);
  id v4 = (uint64_t *)v8;
  if ((uint64_t)(*((void *)&v8 + 1) - v8) >= 1)
  {
    unint64_t v5 = (*((void *)&v8 + 1) - (void)v8) >> 3;
    if (v5 <= 1) {
      unint64_t v5 = 1;
    }
    do
    {
      uint64_t v6 = *v4++;
      *(void *)(*(void *)(v6 + 48) + 272) = &v7;
      --v5;
    }
    while (v5);
  }
  TLine::DrawGlyphs((TLine *)&v7, a2);
  TLine::~TLine((TLine *)&v7);
  if (__dst[31]) {
    std::__shared_weak_count::__release_shared[abi:nn180100](__dst[31]);
  }
  TLine::~TLine((TLine *)__dst);
}

void *CTLineCreateCopyWithAttributeOverrides(void *a1, uint64_t a2)
{
  uint64_t v65 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  uint64_t v4 = a1[5];
  unint64_t v5 = *(char **)(v4 + 72);
  uint64_t v6 = *(void *)(v4 + 80);
  long long v7 = *(void **)v4;
  long long v8 = *(std::__shared_weak_count **)(v4 + 8);
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  long long v48 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v57 = 0u;
  uint64_t v59 = 0;
  long long v58 = 0u;
  *(void *)&long long v58 = v7[2];
  id v46 = (id)0xAAAAAAAAAAAAAAAALL;
  CFIndex v47 = v7;
  (*(void (**)(id *__return_ptr))(*v7 + 32))(&v46);
  MutableCopCGFloat y = CFAttributedStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, (CFAttributedStringRef)atomic_load_explicit((atomic_ullong *volatile)&v46, memory_order_acquire));
  CFAllocatorRef v10 = MutableCopy;
  uint64_t v11 = *(void *)(v4 + 96);
  if (v11 && (uint64_t v12 = *(void *)(v11 + 312)) != 0)
  {
    unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(v12 + 80), memory_order_acquire);
    if (explicit)
    {
      uint64_t v14 = *(void *)(v11 + 8);
      v66.CFIndex length = CFAttributedStringGetLength(MutableCopy) - v14;
      v66.locatiouint64_t n = v14;
      CFAttributedStringReplaceString(v10, v66, &stru_1ED0677F8);
    }
  }
  else
  {
    unint64_t explicit = 0;
  }
  id v45 = v5;
  if (v6 < 1) {
    goto LABEL_48;
  }
  uint64_t v40 = v4;
  unint64_t v38 = (__CFString *)explicit;
  CFIndex v39 = v6;
  unint64_t v41 = v8;
  char v15 = 0;
  int v16 = &v5[v6];
  long long v17 = v5;
  do
  {
    __dst[0] = (unint64_t)v17;
    CFDictionaryRef v18 = (CFDictionaryRef)(*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
    CFIndex v19 = *(void *)&__dst[0];
    if ((uint64_t)v16 >= *((void *)&__dst[0] + 1) + *(void *)&__dst[0]) {
      uint64_t v20 = (char *)(*((void *)&__dst[0] + 1) + *(void *)&__dst[0]);
    }
    else {
      uint64_t v20 = &v5[v6];
    }
    if (*(uint64_t *)&__dst[0] <= (uint64_t)v5 && (uint64_t)v5 < *((void *)&__dst[0] + 1) + *(void *)&__dst[0])
    {
      uint64_t v23 = v20 - v5;
      CFIndex v19 = (CFIndex)v5;
    }
    else if ((uint64_t)v5 <= *(uint64_t *)&__dst[0] && *(void *)&__dst[0] < (uint64_t)v16)
    {
      uint64_t v23 = (uint64_t)&v20[-*(void *)&__dst[0]];
    }
    else
    {
      CFIndex v19 = 0;
      uint64_t v23 = 0;
    }
    *(void *)&__dst[0] = v19;
    *((void *)&__dst[0] + 1) = v23;
    if (v23 < 1)
    {
      TCharStreamIterator::GetFullChar((TCharStreamIterator *)&v47, (uint64_t *)&v45, 0);
      long long v17 = (char *)v45 + 1;
    }
    else
    {
      effectiveRange.locatiouint64_t n = 0xAAAAAAAAAAAAAAAALL;
      effectiveRange.CFIndex length = 0xAAAAAAAAAAAAAAAALL;
      CFDictionaryRef Attributes = CFAttributedStringGetAttributes(v10, v19, &effectiveRange);
      if (*((void *)&__dst[0] + 1) + *(void *)&__dst[0] > effectiveRange.length + effectiveRange.location
        || Attributes != v18 && (!v18 || !Attributes || !CFEqual(Attributes, v18)))
      {
        v42[0] = MEMORY[0x1E4F143A8];
        v42[1] = 3321888768;
        v42[2] = __CTLineCreateCopyWithAttributeOverrides_block_invoke;
        v42[3] = &__block_descriptor_56_8_32c36_ZTS6TCFRefIP20__CFAttributedStringE_e15_v32__0_8_16_B24l;
        id v43 = v10;
        long long v44 = __dst[0];
        [(__CFDictionary *)v18 enumerateKeysAndObjectsUsingBlock:v42];

        char v15 = 1;
      }
      long long v17 = (char *)(*((void *)&__dst[0] + 1) + *(void *)&__dst[0]);
    }
    id v45 = v17;
  }
  while ((uint64_t)v17 < (uint64_t)v16);
  long long v8 = v41;
  if (v15)
  {
    memcpy(__dst, &unk_184B88B40, sizeof(__dst));
    TTypesetterAttrString::TTypesetterAttrString((TTypesetterAttrString *)__dst, v10, 0, 0);
    CTLineRef v25 = CTLineCreateWithAttributedString(v10);
    int64_t v26 = (CFIndex *)*((void *)v25 + 5);
    id v45 = (id)0xAAAAAAAAAAAAAAAALL;
    TCFBase_NEW<CTLine,std::shared_ptr<TCharStream const> const&>((uint64_t *)__dst, &v45);
    if (atomic_load_explicit((atomic_ullong *volatile)&v45, memory_order_acquire))
    {
      int v27 = *(CFIndex **)(atomic_load_explicit((atomic_ullong *volatile)&v45, memory_order_acquire) + 40);
      v28.CFIndex length = v39;
      if (*(unsigned char *)(v4 + 184)) {
        double v29 = *(double *)(v4 + 176);
      }
      else {
        double v29 = 0.0;
      }
      CFIndex v30 = *v26;
      effectiveRange.locatiouint64_t n = (CFIndex)v26;
      effectiveRange.CFIndex length = v30;
      uint64_t v61 = 0;
      uint64_t v62 = 0;
      v63[0] = 0;
      *(void *)((char *)v63 + 6) = 0;
      void v63[2] = 0;
      v28.locatiouint64_t n = (CFIndex)v5;
      TTypesetter::FillLine((const TLine **)&effectiveRange, (TLine *)v27, v28, 1.79769313e308, v29);
      unint64_t v31 = ExternalizeLine((atomic_ullong *)&v45);
      uint64_t v32 = (void *)v31;
      if (v38)
      {
        unint64_t HyphenatedLineWithOffset = CTLineCreateHyphenatedLineWithOffset(v31, v27[9], v27[10], v38, v29);
        if (HyphenatedLineWithOffset)
        {
          double v34 = (void *)HyphenatedLineWithOffset;
          CFRelease(v32);
          uint64_t v32 = v34;
        }
      }
      uint64_t v35 = *(void *)(v40 + 192);
      if (v35)
      {
        TruncatedLine = CreateTruncatedLine((uint64_t **)v32, *(_DWORD *)(v35 + 8), (void *)atomic_load_explicit((atomic_ullong *volatile)(v35 + 16), memory_order_acquire), (const void *)atomic_load_explicit((atomic_ullong *volatile)(v35 + 24), memory_order_acquire), *(double *)v35);

        uint64_t v32 = TruncatedLine;
      }
    }
    else
    {
      uint64_t v32 = 0;
    }

    if (*((void *)&__dst[15] + 1)) {
      std::__shared_weak_count::__release_shared[abi:nn180100](*((std::__shared_weak_count **)&__dst[15] + 1));
    }
    TLine::~TLine((TLine *)__dst);
  }
  else
  {
LABEL_48:
    uint64_t v32 = a1;
  }

  if (v8) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v8);
  }
  return v32;
}

void __CTLineCreateCopyWithAttributeOverrides_block_invoke(uint64_t a1, const __CFString *a2, const void *a3)
{
  objc_opt_class();
  isKindOfunsigned int Class = objc_opt_isKindOfClass();
  unint64_t explicit = (__CFAttributedString *)atomic_load_explicit((atomic_ullong *volatile)(a1 + 32), memory_order_acquire);
  CFRange v8 = *(CFRange *)(a1 + 40);
  if (isKindOfClass)
  {
    CFAttributedStringRemoveAttribute(explicit, v8, a2);
  }
  else
  {
    CFAttributedStringSetAttribute(explicit, v8, a2, a3);
  }
}

id __copy_helper_block_8_32c36_ZTS6TCFRefIP20__CFAttributedStringE(uint64_t a1, uint64_t a2)
{
  id result = (id)atomic_load_explicit((atomic_ullong *volatile)(a2 + 32), memory_order_acquire);
  *(void *)(a1 + 32) = result;
  return result;
}

void __destroy_helper_block_8_32c36_ZTS6TCFRefIP20__CFAttributedStringE(uint64_t a1)
{
}

void _CTLineEnumerateDecorations(uint64_t a1, CGContext *a2, uint64_t a3, uint64_t a4)
{
  if (a1)
  {
    uint64_t v4 = *(void *)(a1 + 40);
    unint64_t v7 = 0xAAAAAAAA00000000;
    uint64_t v8 = a4;
    uint64_t v6 = -1;
    v5[0] = xmmword_184B88AE8;
    memset(&v5[1], 255, 64);
    TLineDrawContext::TLineDrawContext((TLineDrawContext *)v5, a2);
    TLine::DrawGlyphsWithAttributeOverrides(v4, (uint64_t)v5);
  }
}

void CTLineDecorationApplyWithBlock(uint64_t a1, long long *a2, double a3, double a4, double a5, uint64_t a6, uint64_t a7)
{
  if (a1)
  {
    uint64_t v7 = *(void *)(a1 + 40);
    unint64_t v14 = 0xAAAAAAAA00000001;
    uint64_t v15 = a7;
    long long v8 = a2[1];
    long long v10 = *a2;
    long long v11 = v8;
    long long v12 = a2[2];
    v9[0] = 0xAAAAAAAA00000001;
    v9[1] = 0;
    *(double *)&v9[2] = a3;
    *(double *)&v9[3] = a4;
    double v13 = a5;
    TLine::DrawGlyphsWithAttributeOverrides(v7, (uint64_t)v9);
  }
}

void CTLineGetDefaultBounds(uint64_t a1, double *a2, double *a3, double *a4)
{
  double v13 = 0.0;
  double v14 = 0.0;
  double v12 = 0.0;
  if (a1)
  {
    uint64_t v7 = *(void **)(a1 + 40);
    if ((uint64_t)(v7[3] - v7[2]) >= 1)
    {
      RunWithCharIndedouble x = TLine::FindRunWithCharIndex(*(TLine **)(a1 + 40), v7[9], 1);
      uint64_t v9 = v7[2];
      if (RunWithCharIndex < (v7[3] - v9) >> 3)
      {
        uint64_t v10 = *(void *)(*(void *)(v9 + 8 * RunWithCharIndex) + 40);
        id v11 = (id)0xAAAAAAAAAAAAAAAALL;
        TAttributes::OriginalFont((atomic_ullong *)(v10 + 40), (atomic_ullong *)&v11);
        if (atomic_load_explicit((atomic_ullong *volatile)&v11, memory_order_acquire)) {
          TFont::GetDefaultMetrics(*(TFont **)(atomic_load_explicit((atomic_ullong *volatile)&v11, memory_order_acquire) + 40), &v14, &v13, &v12);
        }
      }
    }
    if (a2) {
      goto LABEL_8;
    }
  }
  else if (a2)
  {
LABEL_8:
    *a2 = v14;
  }
  if (a3) {
    *a3 = v13;
  }
  if (a4) {
    *a4 = v12;
  }
}

uint64_t **CTLineCreateTruncatedLineWithTokenCallback(uint64_t **a1, int a2, uint64_t a3, uint64_t a4, double a5)
{
  if (a3)
  {
    uint64_t v6 = v8;
    v8[0] = MEMORY[0x1E4F143A8];
    v8[1] = 3221225472;
    uint64_t v8[2] = __CTLineCreateTruncatedLineWithTokenCallback_block_invoke;
    void v8[3] = &__block_descriptor_48_e58_____CTRun__32__0____CTLine__8____qq_16____CFDictionary__24l;
    void v8[4] = a3;
    id v8[5] = a4;
  }
  else
  {
    uint64_t v6 = 0;
  }
  return CreateTruncatedLine(a1, a2, 0, v6, a5);
}

uint64_t __CTLineCreateTruncatedLineWithTokenCallback_block_invoke(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, void, void, uint64_t, void))(a1 + 32))(a2, *a3, a3[1], a4, *(void *)(a1 + 40));
}

void CTLineSyncWithRuns(uint64_t a1)
{
  if (a1) {
    TLine::SyncWithRuns(*(TLine **)(a1 + 40));
  }
}

CFIndex CTLineSuggestLineBreakWithOffset(CFIndex result, const TLine *a2, double a3, double a4, uint64_t a5, uint64_t *a6)
{
  if (result) {
    return TTypesetter::SuggestLineBreak(*(TTypesetter **)(result + 40), a2, 0, a3, a4, a6);
  }
  return result;
}

CFIndex TTypesetter::SuggestLineBreak(TTypesetter *this, const TLine *a2, uint64_t a3, double a4, double a5, uint64_t *a6)
{
  v11[4] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)this;
  v9[0] = (uint64_t)this;
  v9[1] = v6;
  v9[2] = 0;
  v9[3] = 0;
  v10[0] = 0;
  *(void *)((char *)v10 + 6) = 0;
  void v10[2] = a3;
  id v11[3] = 0;
  CFIndex v7 = TTypesetter::SuggestLineBreak(v9, (uint64_t)a2, (uint64_t)v11, a4, a5);
  std::__function::__value_func<unsigned char ()(long)>::~__value_func[abi:nn180100](v11);
  return v7;
}

CFIndex CTLineSuggestLineBreakWithTabOverflow(CFIndex result, const TLine *a2, uint64_t *a3, uint64_t *a4, double a5, double a6)
{
  if (result)
  {
    CFIndex v7 = *(TTypesetter **)(result + 40);
    uint64_t v8 = -1;
    id result = TTypesetter::SuggestLineBreak(v7, a2, (uint64_t)&v8, a5, a6, a4);
    if (a3) {
      *a3 = v8;
    }
  }
  return result;
}

uint64_t TCFBase<TLine>::ClassEqual(uint64_t a1, uint64_t a2)
{
  return TLine::operator==(*(void **)(a1 + 40), *(void **)(a2 + 40));
}

void *TCFBase<TLine>::ClassHash(void *result)
{
  unint64_t v1 = result[3];
  uint64_t v2 = result[4];
  if (v2) {
    BOOL v3 = (result[4] & 1 | v1) == 0;
  }
  else {
    BOOL v3 = 1;
  }
  int v4 = !v3;
  if (v1) {
    BOOL v5 = 0;
  }
  else {
    BOOL v5 = v4 == 0;
  }
  if (!v5)
  {
    uint64_t v6 = (void *)(result[5] + (v2 >> 1));
    if (v2) {
      return (void *)(*(uint64_t (**)(void))(*v6 + v1))();
    }
    else {
      return (void *)((uint64_t (*)(void *))v1)(v6);
    }
  }
  return result;
}

__CFString *TCFBase<TLine>::ClassDebug(uint64_t a1)
{
  id result = TLine::DebugDescription(*(TLine **)(a1 + 40));
  if (result)
  {
    BOOL v3 = result;
    CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<%s: %p>{%@}", "CTLine", a1, result);
    CFRelease(v3);
    return (__CFString *)v4;
  }
  return result;
}

void std::__shared_ptr_pointer<TCharStreamCFString  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1853275C0);
}

uint64_t std::__shared_ptr_pointer<TCharStreamCFString  *>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 56))();
  }
  return result;
}

void std::__function::__func<void({block_pointer})(double,long,BOOL,BOOL *),std::allocator<void({block_pointer})(double,long,BOOL,BOOL *)>,void ()(double,long,BOOL,BOOL *)>::~__func()
{
}

uint64_t std::__function::__func<void({block_pointer})(double,long,BOOL,BOOL *),std::allocator<void({block_pointer})(double,long,BOOL,BOOL *)>,void ()(double,long,BOOL,BOOL *)>::__clone()
{
  return 0;
}

void *std::__function::__func<void({block_pointer})(double,long,BOOL,BOOL *),std::allocator<void({block_pointer})(double,long,BOOL,BOOL *)>,void ()(double,long,BOOL,BOOL *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1ED05FBB8;
  uint64_t result = *(void **)(a1 + 8);
  if (result) {
    uint64_t result = _Block_copy(result);
  }
  a2[1] = result;
  return result;
}

void std::__function::__func<void({block_pointer})(double,long,BOOL,BOOL *),std::allocator<void({block_pointer})(double,long,BOOL,BOOL *)>,void ()(double,long,BOOL,BOOL *)>::destroy(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }
  *(void *)(a1 + 8) = 0;
}

uint64_t std::__function::__func<void({block_pointer})(double,long,BOOL,BOOL *),std::allocator<void({block_pointer})(double,long,BOOL,BOOL *)>,void ()(double,long,BOOL,BOOL *)>::operator()(uint64_t a1, double *a2)
{
  return (*(uint64_t (**)(double))(*(void *)(a1 + 8) + 16))(*a2);
}

void TLine::TLine(TLine *this, const __CFArray *a2)
{
  *((void *)this + 4) = 0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((void *)this + 8) = (char *)this + 40;
  *((unsigned char *)this + 184) = 0;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(void *)((char *)this + 149) = 0;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *((void *)this + 20) = 0;
  *((void *)this + 21) = 0;
  *((unsigned char *)this + 176) = 0;
  *((void *)this + 25) = 0;
  *((void *)this + 26) = 0;
  *((void *)this + 24) = 0;
  *((void *)this + 16) = 0xFFEFFFFFFFFFFFFFLL;
  *((_WORD *)this + 77) = 1;
  TLine::SetRunArray((int64x2_t *)this, a2);
  for (uint64_t i = *((void *)this + 2); ; i += 8)
  {
    if (i == *((void *)this + 3)) {
      operator new();
    }
    CFStringRef v4 = *(uint64_t **)(*(void *)(*(void *)i + 40) + 272);
    if (v4) {
      break;
    }
  }
  uint64_t v6 = *v4;
  uint64_t v5 = v4[1];
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  CFIndex v7 = (std::__shared_weak_count *)*((void *)this + 1);
  *(void *)this = v6;
  *((void *)this + 1) = v5;
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v7);
  }
}

uint64_t TLine::operator==(void *a1, void *a2)
{
  if (a1[9] != a2[9] || a1[10] != a2[10]) {
    return 0;
  }
  if (a1[18] != a2[18]) {
    return 0;
  }
  uint64_t v5 = a1[2];
  uint64_t v6 = a1[3] - v5;
  uint64_t v7 = v6 >> 3;
  uint64_t v8 = a2[2];
  if (v6 >> 3 != (a2[3] - v8) >> 3) {
    return 0;
  }
  if (v6 < 8) {
    return 1;
  }
  if (v7 <= 1) {
    uint64_t v10 = 1;
  }
  else {
    uint64_t v10 = v6 >> 3;
  }
  uint64_t result = TRun::operator==(*(void *)(*(void *)v5 + 40), *(void *)(*(void *)v8 + 40));
  if (result)
  {
    uint64_t v11 = 1;
    do
    {
      uint64_t v12 = v11;
      if (v10 == v11) {
        break;
      }
      char v13 = TRun::operator==(*(void *)(*(void *)(a1[2] + 8 * v11) + 40), *(void *)(*(void *)(a2[2] + 8 * v11) + 40));
      uint64_t v11 = v12 + 1;
    }
    while ((v13 & 1) != 0);
    return v12 >= v7;
  }
  return result;
}

__CFString *TLine::DebugDescription(TLine *this)
{
  uint64_t v2 = *((void *)this + 3) - *((void *)this + 2);
  uint64_t v3 = v2 >> 3;
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  NonDeletedGlyphCFIndex Count = TLine::GetNonDeletedGlyphCount(this);
  uint64_t v7 = (__CFString *)CFStringCreateWithFormat(v4, 0, @"(%ld, %ld)", *((void *)this + 9), *((void *)this + 10));
  CFStringAppendFormat(Mutable, 0, @"run count = %ld, string range = %@, CGFloat width = %lg, A/D/L = %g/%g/%g, glyph count = %ld, runs = (\n"), v2 >> 3, v7, *((void *)this + 13), *((void *)this + 14), *((void *)this + 15), *((void *)this + 16), NonDeletedGlyphCount;

  if (v2 >= 1)
  {
    uint64_t v8 = 0;
    if (v3 <= 1) {
      uint64_t v9 = 1;
    }
    else {
      uint64_t v9 = v3;
    }
    uint64_t v10 = 8 * v9;
    do
    {
      CFStringAppend(Mutable, @"\n");
      if (*(void *)(*((void *)this + 2) + v8))
      {
        CFStringAppendFormat(Mutable, 0, @"%@", *(void *)(*((void *)this + 2) + v8));
        CFStringRef v11 = @"\n\n";
      }
      else
      {
        CFStringRef v11 = @"<null CTRun?!>\n\n";
      }
      CFStringAppend(Mutable, v11);
      v8 += 8;
    }
    while (v10 != v8);
  }
  CFStringAppend(Mutable, @"\n"));
  return Mutable;
}

id TLine::CopyDescriptionDictionary(TLine *this, uint64_t a2)
{
  v15[4] = *MEMORY[0x1E4F143B8];
  id v4 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
  uint64_t v5 = (void *)[MEMORY[0x1E4F1CA48] array];
  uint64_t v6 = *((void *)this + 3) - *((void *)this + 2);
  uint64_t v7 = v6 >> 3;
  objc_msgSend(v4, "setObject:forKey:", objc_msgSend(NSNumber, "numberWithInteger:", v6 >> 3), @"numRuns");
  objc_msgSend(v4, "setObject:forKey:", objc_msgSend(NSNumber, "numberWithInteger:", *((void *)this + 18)), @"numGlyphs");
  if (v6 >= 1)
  {
    uint64_t v8 = 0;
    if (v7 <= 1) {
      uint64_t v9 = 1;
    }
    else {
      uint64_t v9 = v7;
    }
    uint64_t v10 = 8 * v9;
    do
    {
      uint64_t v11 = *(void *)(*(void *)(*((void *)this + 2) + v8) + 40);
      uint64_t v12 = (const void *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v11 + 16))(v11, a2);
      [v5 addObject:v12];
      CFRelease(v12);
      v8 += 8;
    }
    while (v10 != v8);
  }
  [v4 setObject:v5 forKey:@"runs"];
  if ((a2 & 2) != 0)
  {
    v14[0] = @"ascent";
    v15[0] = [NSNumber numberWithDouble:*((double *)this + 14)];
    v14[1] = @"descent";
    v15[1] = [NSNumber numberWithDouble:*((double *)this + 15)];
    v14[2] = @"leading";
    v15[2] = [NSNumber numberWithDouble:*((double *)this + 16)];
    v14[3] = @"width";
    _OWORD v15[3] = [NSNumber numberWithDouble:*((double *)this + 13)];
    objc_msgSend(v4, "setObject:forKey:", objc_msgSend(MEMORY[0x1E4F1C9E8], "dictionaryWithObjects:forKeys:count:", v15, v14, 4), @"lineMetrics");
  }
  return v4;
}

uint64_t TLine::PositionToCharIndex(TLine *this, CGPoint a2)
{
  v11[4] = *MEMORY[0x1E4F143B8];
  if (!*(void *)this || *((void *)this + 3) == *((void *)this + 2)) {
    return -1;
  }
  double x = a2.x;
  TLine::GetLeftHangersGlyphCountAndWidth(this, 0);
  double v5 = v4;
  if (v4 == 0.0) {
    double v5 = -0.0;
  }
  if (x + v5 < 0.0)
  {
    uint64_t result = *((void *)this + 9);
    if ((*((_WORD *)this + 76) & 8) == 0) {
      return result;
    }
LABEL_11:
    result += *((void *)this + 10);
    return result;
  }
  unint64_t v9 = 0xFFEFFFFFFFFFFFFFLL;
  uint64_t v10 = -1;
  uint64_t v8 = -1;
  uint64_t v7 = (double *)operator new(0x30uLL);
  *(void *)uint64_t v7 = &unk_1ED061EE0;
  *((void *)v7 + 1) = &v10;
  *((void *)v7 + 2) = &v9;
  *((void *)v7 + 3) = &v8;
  v7[4] = x;
  *((void *)v7 + 5) = this;
  id v11[3] = v7;
  TLine::EnumerateCaretOffsets((uint64_t *)this, (uint64_t)v11);
  std::__function::__value_func<void ()(double,long,BOOL,BOOL *)>::~__value_func[abi:nn180100](v11);
  uint64_t result = v10;
  if (v10 == -1)
  {
    uint64_t result = *((void *)this + 9);
    if ((*((_WORD *)this + 76) & 8) == 0) {
      goto LABEL_11;
    }
  }
  return result;
}

void TLine::CopyCaretPath(TLine *this@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X8>)
{
  if (!*(void *)this || *((void *)this + 3) == *((void *)this + 2))
  {
    *a3 = 0;
  }
  else
  {
    id Mutable = CGPathCreateMutable();
    unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
    if (explicit)
    {
      double v7 = *((double *)this + 14);
      double v8 = *((double *)this + 15);
      TLine::CharIndexToOffsets((uint64_t)this, a2);
      if (v9 == v10)
      {
        double v11 = -v8;
        double v12 = v7 + v8;
        char v13 = (CGPath *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      }
      else
      {
        double v14 = v10;
        double v12 = (v7 + v8) * 0.5;
        double v11 = -v8;
        double v15 = v12 - v8;
        double v16 = 1.0;
        double v17 = v12;
        CGPathAddRect((CGMutablePathRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, *(CGRect *)&v9);
        char v13 = (CGPath *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
        double v9 = v14;
      }
      double v18 = 1.0;
      double v19 = v11;
      double v20 = v12;
      CGPathAddRect(v13, 0, *(CGRect *)&v9);
      unint64_t explicit = atomic_exchange((atomic_ullong *volatile)&Mutable, 0);
    }
    *a3 = explicit;
  }
}

void TLine::CopyHighlightPath(TLine *this@<X0>, CFRange a2@<0:X1, 8:X2>, unint64_t *a3@<X8>)
{
  if (!*(void *)this) {
    goto LABEL_45;
  }
  locatiouint64_t n = a2.location;
  CFIndex v6 = *((void *)this + 9);
  uint64_t v7 = *((void *)this + 10);
  CFIndex v8 = v7 + v6;
  CFIndex v9 = a2.location + a2.length >= v7 + v6 ? v7 + v6 : a2.location + a2.length;
  if (v6 <= a2.location && a2.location < v8)
  {
    uint64_t v12 = v9 - a2.location;
  }
  else if (a2.location <= v6 && v6 < a2.location + a2.length)
  {
    uint64_t v12 = v9 - v6;
    locatiouint64_t n = *((void *)this + 9);
  }
  else
  {
    locatiouint64_t n = 0;
    uint64_t v12 = 0;
  }
  if (v12 <= 0 || (v14 = *((void *)this + 2), uint64_t v13 = *((void *)this + 3), v15 = v13 - v14, v13 == v14))
  {
LABEL_45:
    *a3 = 0;
  }
  else
  {
    id Mutable = CGPathCreateMutable();
    unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
    if (explicit)
    {
      id v43 = a3;
      double v17 = *(double **)(*(void *)(**((void **)this + 2) + 40) + 312);
      if (!v17) {
        double v17 = (double *)MEMORY[0x1E4F1DB30];
      }
      double v18 = *v17;
      TLine::GetLeftHangersGlyphCountAndWidth(this, 0);
      if (v15 >= 1)
      {
        uint64_t v20 = 0;
        uint64_t v21 = v15 >> 3;
        double v22 = *((double *)this + 15);
        double v23 = -v22;
        double v24 = v22 + *((double *)this + 14);
        double v25 = v19;
        if (v19 == 0.0) {
          double v25 = 0.0;
        }
        double v26 = v18 - v25;
        CFIndex v27 = location + v12;
        if (v21 <= 1) {
          uint64_t v21 = 1;
        }
        uint64_t v44 = v21;
        do
        {
          CFRange v28 = *(void **)(*(void *)(*((void *)this + 2) + 8 * v20) + 40);
          double v29 = (void *)v28[27];
          uint64_t v30 = v29[4];
          if (v30 || (uint64_t v34 = v29[3]) == 0)
          {
            int v31 = 0;
            uint64_t v32 = v28[25];
            uint64_t v33 = (CGFloat *)(v30 + 16 * v32);
          }
          else
          {
            uint64_t v32 = v28[25];
            uint64_t v33 = (CGFloat *)(v34 + 8 * v32);
            int v31 = 1;
          }
          uint64_t v35 = v28[26];
          if (v35 >= 1)
          {
            long long v36 = (CFIndex *)(v29[6] + 8 * v32);
            unint64_t v37 = v33;
            do
            {
              CFIndex v39 = *v36++;
              CFIndex v38 = v39;
              if (v31) {
                uint64_t v40 = v33;
              }
              else {
                uint64_t v40 = v37;
              }
              double v41 = *v40;
              if (location <= v38 && v27 > v38)
              {
                v46.origin.double x = v26;
                v46.origin.CGFloat y = v23;
                v46.size.CGFloat width = *v40;
                v46.size.CGFloat height = v24;
                CGPathAddRect((CGMutablePathRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, v46);
              }
              double v26 = v26 + v41;
              v37 += 2;
              ++v33;
              --v35;
            }
            while (v35);
          }
          ++v20;
        }
        while (v20 != v44);
      }
      unint64_t explicit = atomic_exchange((atomic_ullong *volatile)&Mutable, 0);
      a3 = v43;
    }
    *a3 = explicit;
  }
}

void TLine::DrawTransformedGlyphs(TLine *this, CGContextRef c)
{
  *(void *)&long long v4 = -1;
  *((void *)&v4 + 1) = -1;
  *(_OWORD *)&v68.c = v4;
  *(_OWORD *)&v68.tdouble x = v4;
  *(_OWORD *)&v68.double a = v4;
  CGContextGetTextMatrix(&v68, c);
  TLine::DrawBackground(this, c);
  uint64_t v7 = *((void *)this + 2);
  uint64_t v6 = *((void *)this + 3);
  uint64_t v8 = v6 - v7;
  if (v6 == v7)
  {
LABEL_8:
    char v11 = 1;
    goto LABEL_9;
  }
  while (1)
  {
    uint64_t v9 = *(void *)(*(void *)v7 + 40);
    uint64_t v10 = *(void *)(v9 + 312);
    if (!v10 || *(void *)(v10 + 56) == *(void *)(v10 + 64)) {
      goto LABEL_7;
    }
    t1.double a = -3.72066208e-103;
    TAttributes::CopyForegroundColorForContext((TAttributes *)(v9 + 40), c, v5, (CGColorRef *)&t1);
    if (atomic_load_explicit((atomic_ullong *volatile)&t1, memory_order_acquire))
    {
      if (CGColorGetAlpha((CGColorRef)atomic_load_explicit((atomic_ullong *volatile)&t1, memory_order_acquire)) < 1.0) {
        break;
      }
    }

LABEL_7:
    v7 += 8;
    if (v7 == v6) {
      goto LABEL_8;
    }
  }

  char v11 = 0;
LABEL_9:
  if (v8 < 1)
  {
    char v14 = 0;
    char v13 = 0;
  }
  else
  {
    uint64_t v12 = 0;
    char v13 = 0;
    char v14 = 0;
    uint64_t v15 = v8 >> 3;
    if (v8 >> 3 <= 1) {
      uint64_t v15 = 1;
    }
    uint64_t v16 = 8 * v15;
    float64x2_t v54 = (float64x2_t)vdupq_n_s64(0x3CB0000000000000uLL);
    do
    {
      uint64_t v17 = *(void *)(*((void *)this + 2) + v12);
      double v18 = *(__n128 **)(v17 + 40);
      unint64_t v19 = v18[13].n128_u64[0];
      if (v11)
      {
        *(void *)&long long v20 = -1;
        *((void *)&v20 + 1) = -1;
        *(_OWORD *)&v67.c = v20;
        *(_OWORD *)&v67.tdouble x = v20;
        *(_OWORD *)&v67.double a = v20;
        uint64_t v21 = v18 + 6;
        if (!v18[9].n128_u8[0]) {
          uint64_t v21 = (__n128 *)MEMORY[0x1E4F1DAB8];
        }
        __n128 v22 = v21[1];
        *(__n128 *)&t2.double a = *v21;
        *(__n128 *)&t2.c = v22;
        *(__n128 *)&t2.tdouble x = v21[2];
        CGAffineTransform t1 = v68;
        CGAffineTransformConcat(&v67, &t1, &t2);
        *(_OWORD *)&v64.double a = *(_OWORD *)&v67.a;
        *(_OWORD *)&v64.c = *(_OWORD *)&v67.c;
        *(_OWORD *)&v64.tdouble x = *(_OWORD *)&v68.tx;
        CGContextSetTextMatrix(c, &v64);
        __n128 Positions = TRun::GetPositions(v18, 0);
        t1.double a = -3.72066208e-103;
        t1.double b = 0.0;
        t1.c = -3.72066208e-103;
        (*(void (**)(__n128 *, CGContextRef, void, unint64_t, uint64_t, CGAffineTransform *, __n128))(v18->n128_u64[0] + 40))(v18, c, 0, v19, v24, &t1, Positions);
      }
      else
      {
        v74.locatiouint64_t n = 0;
        v74.CFIndex length = v18[13].n128_i64[0];
        TRun::DrawBackground(*(TRun **)(v17 + 40), c, v74, 0, 1);
        double a = v68.a;
        double b = v68.b;
        double v59 = v68.c;
        tdouble x = v68.tx;
        double d = v68.d;
        tCGFloat y = v68.ty;
        *(void *)&long long v27 = -1;
        *((void *)&v27 + 1) = -1;
        *(_OWORD *)&v67.c = v27;
        *(_OWORD *)&v67.tdouble x = v27;
        *(_OWORD *)&v67.double a = v27;
        CGContextGetCTM(&v67, c);
        v28.f64[0] = a;
        v28.f64[1] = b;
        v29.f64[0] = v59;
        v29.f64[1] = d;
        int64x2_t v30 = (int64x2_t)vandq_s8((int8x16_t)vcgeq_f64(v54, vabsq_f64(vaddq_f64(v29, (float64x2_t)xmmword_184B88D40))), (int8x16_t)vcgeq_f64(v54, vabsq_f64(vaddq_f64(v28, (float64x2_t)xmmword_184B88D30))));
        if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v30, 1), (int8x16_t)v30).u64[0] & 0x8000000000000000) != 0)
        {
          CGFloat v62 = v67.ty;
          CGFloat v60 = v67.tx;
          CGFloat v58 = v67.d;
          CGFloat v38 = v67.b;
          CGFloat v56 = v67.c;
          CGFloat v39 = v67.a;
          CGAffineTransformMakeTranslation(&t1, tx, ty);
        }
        else
        {
          double v31 = hypot(v59 + a * 0.0, d + b * 0.0);
          CGFloat v32 = 1.0;
          if (v31 <= 1.0)
          {
            CGFloat v35 = a;
            CGFloat v34 = b;
            CGFloat v37 = v59;
            CGFloat v36 = d;
          }
          else
          {
            double v33 = v31;
            t1.double a = a;
            t1.double b = b;
            t1.c = v59;
            t1.double d = d;
            t1.tdouble x = tx;
            t1.tCGFloat y = ty;
            CGAffineTransformScale(&t2, &t1, 1.0 / v31, 1.0 / v31);
            CGFloat v35 = t2.a;
            CGFloat v34 = t2.b;
            CGFloat v37 = t2.c;
            CGFloat v36 = t2.d;
            CGFloat v32 = v33;
            tdouble x = t2.tx;
            tCGFloat y = t2.ty;
          }
          t1.double a = v35;
          t1.double b = v34;
          t1.c = v37;
          t1.double d = v36;
          t1.tdouble x = tx;
          t1.tCGFloat y = ty;
          CGAffineTransform t2 = v67;
          CGAffineTransformConcat(&v66, &t1, &t2);
          CGFloat v39 = v66.a;
          CGFloat v38 = v66.b;
          CGFloat v56 = v66.c;
          CGFloat v58 = v66.d;
          CGFloat v60 = v66.tx;
          CGFloat v62 = v66.ty;
          CGAffineTransformMakeScale(&t1, v32, v32);
        }
        CGFloat v40 = t1.a;
        CGFloat v41 = t1.b;
        CGFloat v42 = t1.c;
        CGFloat v43 = t1.d;
        CGFloat v45 = t1.tx;
        CGFloat v44 = t1.ty;
        CGContextSaveGState(c);
        CGContextBeginTransparencyLayer(c, 0);
        t1.double a = v40;
        t1.double b = v41;
        t1.c = v42;
        t1.double d = v43;
        t1.tdouble x = v45;
        t1.tCGFloat y = v44;
        t2.double a = v39;
        t2.double b = v38;
        t2.c = v56;
        t2.double d = v58;
        t2.tdouble x = v60;
        t2.tCGFloat y = v62;
        CGAffineTransformConcat(&v65, &t1, &t2);
        CGContextSetCTM();
        t1.double a = -3.72066208e-103;
        (*(void (**)(CGAffineTransform *__return_ptr, __n128 *))(v18->n128_u64[0] + 32))(&t1, v18);
        CGContextAddPath(c, (CGPathRef)atomic_load_explicit((atomic_ullong *volatile)&t1, memory_order_acquire));
        BOOL v46 = TAttributes::SetContextAttributes(&v18[2].n128_i64[1], c, 0);
        CGContextFillPath(c);
        if (v46) {
          CGContextRestoreGState(c);
        }
        CGContextEndTransparencyLayer(c);

        CGContextRestoreGState(c);
      }
      unint64_t v47 = v18[10].n128_u64[0];
      if (v47)
      {
        int v48 = *(_DWORD *)(v47 + 56);
        LODWORD(v47) = *(_DWORD *)(v47 + 60);
        v13 |= v48 != 0;
      }
      v14 |= v47 != 0;
      CGAffineTransform v63 = v68;
      CGContextSetTextMatrix(c, &v63);
      v12 += 8;
    }
    while (v16 != v12);
  }
  double v50 = v68.tx;
  CGFloat v49 = v68.ty;
  TLine::GetLeftHangersGlyphCountAndWidth(this, 0);
  double v52 = v51;
  if (v51 == 0.0) {
    double v52 = 0.0;
  }
  double v53 = v50 - v52;
  if (v13)
  {
    CGContextSetTextPosition(c, v53, v49);
    t2.double a = -3.72066066e-103;
    t2.double b = 0.0;
    CGAffineTransform t1 = *(CGAffineTransform *)__const__ZN10TDecorator14DrawDecorationEP9CGContextRK5TLinePK13TInlineVectorI18DecorationOverrideLm30EE_c;
    long long v71 = unk_184BA6248;
    long long v72 = xmmword_184BA6258;
    uint64_t v73 = -1;
    TLineDrawContext::TLineDrawContext((TLineDrawContext *)&t1, c);
    TDecorator::DrawDecoration((uint64_t)&t2, (uint64_t)&t1, this, 0);
  }
  if (v14)
  {
    CGContextSetTextPosition(c, v53, v49);
    t2.double a = -3.72066066e-103;
    t2.double b = 0.0;
    CGAffineTransform t1 = *(CGAffineTransform *)__const__ZN10TDecorator14DrawDecorationEP9CGContextRK5TLinePK13TInlineVectorI18DecorationOverrideLm30EE_c;
    long long v71 = unk_184BA6248;
    long long v72 = xmmword_184BA6258;
    uint64_t v73 = -1;
    TLineDrawContext::TLineDrawContext((TLineDrawContext *)&t1, c);
    TDecorator::DrawDecoration((uint64_t)&t2, (uint64_t)&t1, this, 0);
  }
}

void TLine::DrawUnderlines(TLine *this, CGContext *a2)
{
  v3[0] = 0xAAAAAAAA00000000;
  v3[1] = 0;
  uint64_t v5 = -1;
  v4[0] = *(_OWORD *)__const__ZN10TDecorator14DrawDecorationEP9CGContextRK5TLinePK13TInlineVectorI18DecorationOverrideLm30EE_c;
  memset(&v4[1], 255, 64);
  TLineDrawContext::TLineDrawContext((TLineDrawContext *)v4, a2);
  TDecorator::DrawDecoration((uint64_t)v3, (uint64_t)v4, this, 0);
}

void TLine::DrawStrikethroughs(TLine *this, CGContext *a2)
{
  v3[0] = 0xAAAAAAAA00000001;
  v3[1] = 0;
  uint64_t v5 = -1;
  v4[0] = *(_OWORD *)__const__ZN10TDecorator14DrawDecorationEP9CGContextRK5TLinePK13TInlineVectorI18DecorationOverrideLm30EE_c;
  memset(&v4[1], 255, 64);
  TLineDrawContext::TLineDrawContext((TLineDrawContext *)v4, a2);
  TDecorator::DrawDecoration((uint64_t)v3, (uint64_t)v4, this, 0);
}

uint64_t TLine::DeleteChars(uint64_t this, uint64_t a2, const uint64_t *a3)
{
  if (a2 >= 1)
  {
    uint64_t v3 = (TLine *)this;
    if (*(void *)(this + 24) != *(void *)(this + 16))
    {
      uint64_t v6 = 0;
      uint64_t v7 = a3 + 1;
      do
      {
        uint64_t v8 = v6;
        uint64_t v9 = (uint64_t *)&a3[v6];
        RunWithCharIndedouble x = TLine::FindRunWithCharIndex(v3, *v9, 1);
        uint64_t v11 = RunWithCharIndex;
        uint64_t v12 = *(void **)(*(void *)(*((void *)v3 + 2) + 8 * RunWithCharIndex) + 48);
        uint64_t v13 = v12[26];
        if (a2 <= v6 + 1) {
          uint64_t v14 = v6 + 1;
        }
        else {
          uint64_t v14 = a2;
        }
        uint64_t v15 = v6;
        while (v14 - 1 != v15)
        {
          uint64_t v6 = v15 + 1;
          uint64_t v16 = v7[v15++];
          if (v16 >= v12[2] + v12[1]) {
            goto LABEL_12;
          }
        }
        uint64_t v6 = v14;
LABEL_12:
        this = TRun::DeleteChars(*(TRun **)(*(void *)(*((void *)v3 + 2) + 8 * RunWithCharIndex) + 48), v6 - v8, v9, *((void *)v3 + 9));
        *((void *)v3 + 18) += v12[26] - v13;
        if (this >= 1) {
          this = TLine::AttachToPreviousRun(v3, v11, this);
        }
      }
      while (v6 < a2);
    }
  }
  return this;
}

BOOL TLine::AttachToPreviousRun(TLine *this, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void **)(*(void *)(*((void *)this + 2) + 8 * a2) + 48);
  uint64_t v6 = v5[26];
  if (v6)
  {
    uint64_t v7 = v5[1];
    if (v7 > *((void *)this + 9))
    {
      uint64_t v9 = v5[2];
      RunWithCharIndedouble x = TLine::FindRunWithCharIndex(this, v7 - 1, 1);
      if (RunWithCharIndex != a2)
      {
        v5[1] = v7 + a3;
        v5[2] = v9 - a3;
        uint64_t v11 = *(void *)(*(void *)(*((void *)this + 2) + 8 * RunWithCharIndex) + 48);
        uint64_t v12 = *(void *)(v11 + 8);
        uint64_t v13 = *(void *)(v11 + 16);
        TRun::IncrementAttachCountForChar(v11, v7 - 1, a3);
        *(void *)(v11 + 8) = v12;
        *(void *)(v11 + 16) = v13 + a3;
      }
    }
  }
  else
  {
    TLine::DeleteRun(this, a2);
  }
  return v6 == 0;
}

uint64_t TLine::GetMappedCharsInRange(TLine *a1, uint64_t a2, uint64_t a3, void *a4)
{
  a4[1] = *a4;
  uint64_t v7 = *(uint64_t **)(*(void *)(*((void *)a1 + 2) + 8 * TLine::FindRunWithCharIndex(a1, a2, 1)) + 40);
  uint64_t v8 = v7[1];
  uint64_t v9 = v7[2];
  uint64_t v10 = v9 + v8;
  if (v9 + v8 >= a2 + a3) {
    uint64_t v11 = a2 + a3;
  }
  else {
    uint64_t v11 = v9 + v8;
  }
  if (a2 <= v8 && v8 < a2 + a3)
  {
    uint64_t v14 = v11 - v8;
  }
  else if (v8 <= a2 && a2 < v10)
  {
    uint64_t v14 = v11 - a2;
    uint64_t v8 = a2;
  }
  else
  {
    uint64_t v8 = 0;
    uint64_t v14 = 0;
  }
  uint64_t result = TRun::AppendMappedCharsInRange((uint64_t)v7, v8, v14, (uint64_t)a4);
  uint64_t v16 = a3 - v14;
  if (result) {
    BOOL v17 = v16 < 1;
  }
  else {
    BOOL v17 = 1;
  }
  if (!v17)
  {
    do
    {
      uint64_t v7 = (uint64_t *)v7[3];
      if (!v7) {
        break;
      }
      uint64_t v18 = v7[2] >= v16 ? v16 : v7[2];
      uint64_t result = TRun::AppendMappedCharsInRange((uint64_t)v7, v7[1], v18, (uint64_t)a4);
      v16 -= v18;
    }
    while (result && v16 > 0);
  }
  return result;
}

BOOL TLine::SplitRun(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = a1 + 16;
  uint64_t v7 = *(void *)(*(void *)(a1 + 16) + 8 * a2);
  uint64_t v8 = *(TRun **)(v7 + 48);
  uint64_t v9 = *((void *)v8 + 1);
  id v17 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr))(v7 + 64))(&v17);
  uint64_t v10 = *(void **)(atomic_load_explicit((atomic_ullong *volatile)&v17, memory_order_acquire) + 48);
  uint64_t v11 = v10[26];
  if (v11 >= 1)
  {
    uint64_t v12 = *((void *)v8 + 4);
    uint64_t v13 = (void *)(a1 + 88);
    if (v12) {
      uint64_t v13 = (void *)(v12 + 24);
    }
    *uint64_t v13 = v10;
    void v10[3] = v8;
    v10[4] = v12;
    *((void *)v8 + 4) = v10;
    unint64_t explicit = (void *)atomic_load_explicit((atomic_ullong *volatile)&v17, memory_order_acquire);
    uint64_t v15 = (char *)(*(void *)(a1 + 16) + 8 * a2);
    id v18 = explicit;
    std::vector<CTRun *,TInlineBufferAllocator<CTRun *,3ul>>::insert(v6, v15, &v18);
    TRun::TruncateBeginToChar(v8, v9 + a3);
  }

  return v11 > 0;
}

uint64_t TLine::AbsorbRunFollowing(TLine *this, uint64_t a2)
{
  uint64_t v2 = a2 + 1;
  uint64_t v3 = *((void *)this + 2);
  if (a2 + 1 >= (*((void *)this + 3) - v3) >> 3) {
    return 0;
  }
  uint64_t v5 = *(TRun **)(*(void *)(v3 + 8 * a2) + 48);
  uint64_t v6 = *(TRun **)(*(void *)(v3 + 8 * v2) + 48);
  uint64_t v7 = *((void *)v6 + 1);
  uint64_t v8 = *((void *)v6 + 2);
  uint64_t result = TRun::AbsorbFollowingRun(v5, v6);
  if (result)
  {
    uint64_t v10 = *((void *)v5 + 1);
    if (v7 >= v10) {
      uint64_t v11 = *((void *)v5 + 1);
    }
    else {
      uint64_t v11 = v7;
    }
    uint64_t v12 = *((void *)v5 + 2) + v10;
    if (v12 <= v8 + v7) {
      uint64_t v12 = v8 + v7;
    }
    *((void *)v5 + 1) = v11;
    *((void *)v5 + 2) = v12 - v11;
    TLine::SimpleRunDelete(this, v2);
    return 1;
  }
  return result;
}

CFIndex TLine::NormalizeRange(TLine *this, CFRange a2, uint64_t *a3, uint64_t *a4)
{
  CFIndex length = a2.length;
  locatiouint64_t n = a2.location;
  *a3 = 0;
  do
  {
    uint64_t v13 = 0xAAAAAAAAAAAAAAAALL;
    RunWithCharIndedouble x = TLine::FindRunWithCharIndex(this, location, 1);
    *a4 = RunWithCharIndex;
    uint64_t v10 = *(TRun **)(*(void *)(*((void *)this + 2) + 8 * RunWithCharIndex) + 40);
    v14.locatiouint64_t n = location;
    v14.CFIndex length = length;
    CFIndex result = TRun::NormalizeRange(v10, v14, &v13);
    locatiouint64_t n = result;
    CFIndex length = v12;
    *a3 += v13;
  }
  while (v12 && *((void *)v10 + 2) + *((void *)v10 + 1) <= result);
  return result;
}

uint64_t TLine::SetLevelRange(void *a1, CFRange a2, char a3, int a4)
{
  long long v4 = a1 + 2;
  if (a1[3] == a1[2]) {
    return 0;
  }
  uint64_t length = a2.length;
  locatiouint64_t n = a2.location;
  uint64_t v43 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v44 = 0xAAAAAAAAAAAAAAAALL;
  CFIndex v10 = TLine::NormalizeRange((TLine *)a1, a2, &v44, &v43);
  if (v11 >= 1)
  {
    uint64_t v12 = *(void *)(*(void *)(*(void *)(a1[2] + 8 * v43) + 48) + 8);
    if (v10 != v12) {
      TLine::SplitRun((uint64_t)a1, v43, v10 - v12);
    }
  }
  if (length >= 1)
  {
    do
    {
      v46.locatiouint64_t n = location;
      v46.uint64_t length = length;
      TLine::NormalizeRange((TLine *)a1, v46, &v44, &v43);
      uint64_t v14 = v44;
      if (v44 < 1) {
        break;
      }
      if (v13 >= 1)
      {
        uint64_t v15 = *(void *)(*v4 + 8 * v43);
        uint64_t v16 = *(void *)(v15 + 48);
        uint64_t v17 = *(void *)(v16 + 16);
        if (v44 < v17)
        {
          uint64_t v23 = *(void *)(v16 + 8);
          v47.locatiouint64_t n = location;
          v47.uint64_t length = length;
          CFIndex v24 = TLine::NormalizeRange((TLine *)a1, v47, &v44, &v43);
          if (v25 >= 1)
          {
            uint64_t v26 = v25;
            uint64_t v27 = v43;
            if (a4 == 1)
            {
              CFIndex v28 = v24;
              uint64_t v29 = *(void *)(*v4 + 8 * v43);
              uint64_t v39 = *(void *)(v29 + 48);
              uint64_t v40 = v23;
              id v42 = (id)0xAAAAAAAAAAAAAAAALL;
              (*(void (**)(id *__return_ptr, uint64_t, CFIndex, uint64_t, uint64_t))(v29 + 64))(&v42, v29, v24, v25, 1);
              uint64_t v30 = *(void *)(atomic_load_explicit((atomic_ullong *volatile)&v42, memory_order_acquire) + 48);
              if (*(uint64_t *)(v30 + 208) >= 1)
              {
                uint64_t v31 = [*(id *)(v30 + 216) copyWithRange:*(void *)(v30 + 200)];

                *(void *)(v30 + 216) = v31;
                *(void *)(v30 + 200) = 0;
                if (((((a3 & 1) == 0) ^ *(unsigned __int8 *)(v30 + 224)) & 1) == 0) {
                  TRun::ReverseGlyphs(v30);
                }
                *(unsigned char *)(v30 + 224) = a3;
                unint64_t explicit = (void *)atomic_load_explicit((atomic_ullong *volatile)&v42, memory_order_acquire);
                uint64_t v33 = v43;
                uint64_t v34 = ++v43;
                CGFloat v35 = (char *)(a1[2] + 8 * v33);
                id v45 = explicit;
                std::vector<CTRun *,TInlineBufferAllocator<CTRun *,3ul>>::insert((uint64_t)v4, v35, &v45);
                uint64_t v36 = *(void *)(v39 + 32);
                CGFloat v37 = (uint64_t *)(v36 + 24);
                if (!v36) {
                  CGFloat v37 = a1 + 11;
                }
                uint64_t *v37 = v30;
                *(void *)(v30 + 24) = v39;
                *(void *)(v30 + 32) = v36;
                *(void *)(v39 + 32) = v30;
                id v45 = (id)0xAAAAAAAAAAAAAAAALL;
                (*(void (**)(id *__return_ptr, uint64_t, CFIndex, uint64_t, uint64_t))(v29 + 64))(&v45, v29, v28 + v26, v17 + v40 - (v28 + v26), 1);
                id v41 = (id)atomic_exchange((atomic_ullong *volatile)&v45, 0);
                TLine::ReplaceRun(a1, v34, (atomic_ullong *)&v41);
              }
            }
            else
            {
              TLine::SplitRun((uint64_t)a1, v43, v25);
              uint64_t v38 = *(void *)(*(void *)(a1[2] + 8 * v27) + 48);
              if (((((a3 & 1) == 0) ^ *(unsigned __int8 *)(v38 + 224)) & 1) == 0) {
                TRun::ReverseGlyphs(v38);
              }
              *(unsigned char *)(v38 + 224) = a3;
            }
          }
          length -= v44;
          return -length;
        }
        if (a4 == 1)
        {
          id v45 = (id)0xAAAAAAAAAAAAAAAALL;
          (*(void (**)(id *__return_ptr))(v15 + 56))(&v45);
          uint64_t v18 = *(void *)(atomic_load_explicit((atomic_ullong *volatile)&v45, memory_order_acquire) + 48);
          uint64_t v19 = objc_msgSend(*(id *)(v18 + 216), "copyWithRange:", *(void *)(v18 + 200), *(void *)(v18 + 208));

          *(void *)(v18 + 216) = v19;
          *(void *)(v18 + 200) = 0;
          if (((((a3 & 1) == 0) ^ *(unsigned __int8 *)(v18 + 224)) & 1) == 0) {
            TRun::ReverseGlyphs(v18);
          }
          *(unsigned char *)(v18 + 224) = a3;
          uint64_t v20 = v43;
          id v42 = (id)atomic_exchange((atomic_ullong *volatile)&v45, 0);
          TLine::ReplaceRun(a1, v20, (atomic_ullong *)&v42);

          uint64_t v14 = v44;
        }
        else
        {
          if (((((a3 & 1) == 0) ^ *(unsigned __int8 *)(v16 + 224)) & 1) == 0) {
            TRun::ReverseGlyphs(*(void *)(v15 + 48));
          }
          *(unsigned char *)(v16 + 224) = a3;
        }
      }
      location += v14;
      BOOL v21 = length <= v14;
      length -= v14;
    }
    while (!v21);
  }
  return -length;
}

uint64_t TLine::SeparateCharWithGlyphIndex(TLine *this, uint64_t *a2, CFIndex a3)
{
  v102[2] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *((void *)this + 2);
  unsigned int v92 = (void *)((char *)this + 16);
  if (*a2 >= (*((void *)this + 3) - v3) >> 3) {
    return 0;
  }
  uint64_t v91 = *(void *)(v3 + 8 * *a2);
  uint64_t v5 = *(void *)(v91 + 48);
  uint64_t v6 = *(void **)(v5 + 216);
  uint64_t v7 = *(void *)(v5 + 200);
  if ((*(_DWORD *)(v6[5] + 4 * v7 + 4 * a3) & 0x380) != 0) {
    return 0;
  }
  uint64_t v8 = *(void *)(v6[6] + 8 * v7 + 8 * a3);
  uint64_t v9 = [v6 attachmentCountAtIndex:v7 + a3] + 1;
  uint64_t v93 = v9;
  if (a3 < 1)
  {
    uint64_t v12 = 0;
    uint64_t v13 = -1;
  }
  else
  {
    CFIndex v10 = *(void **)(v5 + 216);
    uint64_t v11 = *(void *)(v10[6] + 8 * *(void *)(v5 + 200));
    uint64_t v12 = objc_msgSend(v10, "attachmentCountAtIndex:") + 1;
    if (a3 != 1)
    {
      uint64_t v14 = v9 + v8;
      uint64_t v15 = 1;
      while (1)
      {
        uint64_t v16 = *(void **)(v5 + 216);
        uint64_t v17 = *(void *)(v5 + 200);
        uint64_t v18 = *(void *)(v16[6] + 8 * v17 + 8 * v15);
        if (v8 <= v18 && v14 > v18) {
          break;
        }
        uint64_t v20 = [v16 attachmentCountAtIndex:v15 + v17];
        if (v18 >= v11) {
          uint64_t v13 = v11;
        }
        else {
          uint64_t v13 = v18;
        }
        uint64_t v21 = v11 + v12;
        if (v11 + v12 <= v18 + v20 + 1) {
          uint64_t v21 = v18 + v20 + 1;
        }
        uint64_t v12 = v21 - v13;
        ++v15;
        uint64_t v11 = v13;
        if (a3 == v15) {
          goto LABEL_19;
        }
      }
    }
    uint64_t v13 = v11;
  }
LABEL_19:
  uint64_t v94 = v8;
  CFIndex v22 = a3 + 1;
  if (a3 + 1 >= *(void *)(v5 + 208))
  {
    uint64_t v26 = 0;
    uint64_t v34 = -1;
  }
  else
  {
    uint64_t v23 = *(void **)(v5 + 216);
    uint64_t v24 = *(void *)(v5 + 200);
    uint64_t v25 = *(void *)(v23[6] + 8 * v24 + 8 * v22);
    uint64_t v26 = [v23 attachmentCountAtIndex:v24 + v22] + 1;
    CFIndex v27 = a3 + 2;
    if (a3 + 2 < *(void *)(v5 + 208))
    {
      uint64_t v28 = v93 + v8;
      while (1)
      {
        uint64_t v29 = *(void **)(v5 + 216);
        uint64_t v30 = *(void *)(v5 + 200);
        uint64_t v31 = *(void *)(v29[6] + 8 * v30 + 8 * v27);
        if (v94 <= v31 && v28 > v31) {
          break;
        }
        uint64_t v33 = [v29 attachmentCountAtIndex:v27 + v30];
        if (v31 >= v25) {
          uint64_t v34 = v25;
        }
        else {
          uint64_t v34 = v31;
        }
        uint64_t v35 = v25 + v26;
        if (v25 + v26 <= v31 + v33 + 1) {
          uint64_t v35 = v31 + v33 + 1;
        }
        uint64_t v26 = v35 - v34;
        ++v27;
        uint64_t v25 = v34;
        if (v27 >= *(void *)(v5 + 208)) {
          goto LABEL_36;
        }
      }
    }
    uint64_t v34 = v25;
  }
LABEL_36:
  if (!(v12 | v26)) {
    return 0;
  }
  v101[0] = 0xAAAAAAAAAAAAAAAALL;
  v101[1] = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v97 = &v100;
  v102[0] = v101;
  __p[0] = &v100;
  __p[1] = v101;
  unint64_t v99 = (char *)v101;
  uint64_t v100 = v5;
  memset(v96, 0, sizeof(v96));
  std::__split_buffer<CTRun *,TInlineBufferAllocator<CTRun *,3ul> &>::~__split_buffer((uint64_t)v96);
  __p[1] = v101;
  char v88 = *(unsigned char *)(v5 + 224);
  if (v12 >= 1)
  {
    id v95 = (id)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(id *__return_ptr))(v91 + 56))(&v95);
    uint64_t v36 = *(TRun **)(atomic_load_explicit((atomic_ullong *volatile)&v95, memory_order_acquire) + 48);
    *((void *)v36 + 1) = v13;
    *((void *)v36 + 2) = v12;
    v103.locatiouint64_t n = 0;
    v103.uint64_t length = a3;
    TRun::TruncateStorageRange(v36, v103);
    unint64_t explicit = (void *)atomic_load_explicit((atomic_ullong *volatile)&v95, memory_order_acquire);
    uint64_t v38 = *a2;
    uint64_t v39 = *a2 + 1;
    if (v88)
    {
      uint64_t v40 = (uint64_t)v92;
      id v41 = (char *)(*v92 + 8 * v39);
    }
    else
    {
      *a2 = v39;
      uint64_t v40 = (uint64_t)v92;
      id v41 = (char *)(*v92 + 8 * v38);
    }
    *(void *)&v96[0] = explicit;
    std::vector<CTRun *,TInlineBufferAllocator<CTRun *,3ul>>::insert(v40, v41, v96);
    uint64_t v43 = (char *)__p[1];
    if (__p[1] >= v99)
    {
      int64_t v45 = ((char *)__p[1] - (char *)__p[0]) >> 3;
      if ((unint64_t)(v45 + 1) >> 61) {
        goto LABEL_100;
      }
      unint64_t v46 = (v99 - (char *)__p[0]) >> 2;
      if (v46 <= v45 + 1) {
        unint64_t v46 = v45 + 1;
      }
      if ((unint64_t)(v99 - (char *)__p[0]) >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v47 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v47 = v46;
      }
      uint64_t v97 = &v100;
      if (v47) {
        int v48 = (char *)TInlineBufferAllocator<CTRun *,3ul>::allocate((uint64_t)&v100, v47);
      }
      else {
        int v48 = 0;
      }
      CGFloat v49 = (TRun **)&v48[8 * v45];
      double v50 = &v48[8 * v47];
      *((void *)&v96[1] + 1) = v50;
      *CGFloat v49 = v36;
      uint64_t v44 = v49 + 1;
      *(void *)&v96[1] = v49 + 1;
      double v52 = (char *)__p[0];
      double v51 = (char *)__p[1];
      if (__p[1] == __p[0])
      {
        int64x2_t v54 = vdupq_n_s64((unint64_t)__p[1]);
      }
      else
      {
        do
        {
          double v53 = (TRun *)*((void *)v51 - 1);
          v51 -= 8;
          *--CGFloat v49 = v53;
        }
        while (v51 != v52);
        int64x2_t v54 = *(int64x2_t *)__p;
        double v50 = (char *)*((void *)&v96[1] + 1);
        uint64_t v44 = *(void **)&v96[1];
      }
      __p[0] = v49;
      __p[1] = v44;
      *(int64x2_t *)((char *)v96 + 8) = v54;
      long long v55 = v99;
      unint64_t v99 = v50;
      *((void *)&v96[1] + 1) = v55;
      *(void *)&v96[0] = v54.i64[0];
      std::__split_buffer<CTRun *,TInlineBufferAllocator<CTRun *,3ul> &>::~__split_buffer((uint64_t)v96);
    }
    else
    {
      *(void *)__p[1] = v36;
      uint64_t v44 = v43 + 8;
    }
    __p[1] = v44;
  }
  if (v26 < 1) {
    goto LABEL_80;
  }
  id v95 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr))(v91 + 56))(&v95);
  CGFloat v56 = *(TRun **)(atomic_load_explicit((atomic_ullong *volatile)&v95, memory_order_acquire) + 48);
  v104.locatiouint64_t n = a3 + 1;
  v104.uint64_t length = *(void *)(v5 + 208) - (a3 + 1);
  *((void *)v56 + 1) = v34;
  *((void *)v56 + 2) = v26;
  TRun::TruncateStorageRange(v56, v104);
  long long v57 = (void *)atomic_load_explicit((atomic_ullong *volatile)&v95, memory_order_acquire);
  uint64_t v58 = *a2;
  uint64_t v59 = *a2 + 1;
  if (v88)
  {
    *a2 = v59;
    uint64_t v60 = (uint64_t)v92;
    uint64_t v61 = (char *)(*v92 + 8 * v58);
  }
  else
  {
    uint64_t v60 = (uint64_t)v92;
    uint64_t v61 = (char *)(*v92 + 8 * v59);
  }
  *(void *)&v96[0] = v57;
  std::vector<CTRun *,TInlineBufferAllocator<CTRun *,3ul>>::insert(v60, v61, v96);
  CGFloat v62 = (char *)__p[1];
  if (__p[1] >= v99)
  {
    int64_t v64 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    if (!((unint64_t)(v64 + 1) >> 61))
    {
      unint64_t v65 = (v99 - (char *)__p[0]) >> 2;
      if (v65 <= v64 + 1) {
        unint64_t v65 = v64 + 1;
      }
      if ((unint64_t)(v99 - (char *)__p[0]) >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v66 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v66 = v65;
      }
      uint64_t v97 = &v100;
      if (v66) {
        CGAffineTransform v67 = (char *)TInlineBufferAllocator<CTRun *,3ul>::allocate((uint64_t)&v100, v66);
      }
      else {
        CGAffineTransform v67 = 0;
      }
      CGAffineTransform v68 = (TRun **)&v67[8 * v64];
      unint64_t v69 = &v67[8 * v66];
      *((void *)&v96[1] + 1) = v69;
      *CGAffineTransform v68 = v56;
      CGAffineTransform v63 = v68 + 1;
      *(void *)&v96[1] = v68 + 1;
      long long v71 = (char *)__p[0];
      CFRange v70 = (char *)__p[1];
      if (__p[1] == __p[0])
      {
        int64x2_t v73 = vdupq_n_s64((unint64_t)__p[1]);
      }
      else
      {
        do
        {
          long long v72 = (TRun *)*((void *)v70 - 1);
          v70 -= 8;
          *--CGAffineTransform v68 = v72;
        }
        while (v70 != v71);
        int64x2_t v73 = *(int64x2_t *)__p;
        unint64_t v69 = (char *)*((void *)&v96[1] + 1);
        CGAffineTransform v63 = *(void **)&v96[1];
      }
      __p[0] = v68;
      __p[1] = v63;
      *(int64x2_t *)((char *)v96 + 8) = v73;
      CFRange v74 = v99;
      unint64_t v99 = v69;
      *((void *)&v96[1] + 1) = v74;
      *(void *)&v96[0] = v73.i64[0];
      std::__split_buffer<CTRun *,TInlineBufferAllocator<CTRun *,3ul> &>::~__split_buffer((uint64_t)v96);
      goto LABEL_79;
    }
LABEL_100:
    abort();
  }
  *(void *)__p[1] = v56;
  CGAffineTransform v63 = v62 + 8;
LABEL_79:
  __p[1] = v63;

LABEL_80:
  *(void *)(v5 + 8) = v94;
  *(void *)(v5 + 16) = v93;
  v105.locatiouint64_t n = a3;
  v105.uint64_t length = 1;
  TRun::TruncateStorageRange((TRun *)v5, v105);
  unint64_t v75 = 126 - 2 * __clz(((char *)__p[1] - (char *)__p[0]) >> 3);
  if (__p[1] == __p[0]) {
    uint64_t v76 = 0;
  }
  else {
    uint64_t v76 = v75;
  }
  std::__introsort<std::_ClassicAlgPolicy,TLine::SeparateCharWithGlyphIndex(long *,long)::$_0 &,TRun **,false>((uint64_t)__p[0], (uint64_t *)__p[1], v76, 1);
  uint64_t v77 = *(void *)(v5 + 32);
  uint64_t v78 = (uint64_t *)__p[0];
  uint64_t v79 = *(void *)__p[0];
  if (v77)
  {
    *(void *)(v77 + 24) = v79;
    uint64_t v79 = *v78;
  }
  else
  {
    *((void *)this + 11) = v79;
    if (!v79) {
      goto LABEL_87;
    }
  }
  *(void *)(v79 + 32) = v77;
LABEL_87:
  uint64_t v80 = *(void *)(v5 + 24);
  unint64_t v81 = (char *)__p[1];
  uint64_t v82 = *((void *)__p[1] - 1);
  if (v80)
  {
    *(void *)(v80 + 32) = v82;
    uint64_t v82 = *((void *)v81 - 1);
LABEL_90:
    *(void *)(v82 + 24) = v80;
    goto LABEL_91;
  }
  *((void *)this + 12) = v82;
  if (v82) {
    goto LABEL_90;
  }
LABEL_91:
  if ((unint64_t)(v81 - (char *)v78) >= 9)
  {
    unint64_t v83 = (v81 - (char *)v78) >> 3;
    if (v83 <= 2) {
      unint64_t v83 = 2;
    }
    unint64_t v84 = v83 - 1;
    BOOL v85 = v78 + 1;
    do
    {
      uint64_t v86 = *(v85 - 1);
      uint64_t v87 = *v85;
      *(void *)(v86 + 24) = *v85;
      *(void *)(v87 + 32) = v86;
      ++v85;
      --v84;
    }
    while (v84);
  }
  __p[1] = v78;
  if (&v100 > v78 || v102 <= v78) {
    operator delete(v78);
  }
  return 1;
}

uint64_t TLine::SetTrailingWhitespaceLevel(TLine *this, char a2)
{
  uint64_t result = TLine::GetTrailingWhitespace((uint64_t)this, (double *)v6);
  v5.uint64_t length = v6[0];
  if (v6[0])
  {
    v5.locatiouint64_t n = *((void *)this + 9) - v6[0] + *((void *)this + 10);
    return TLine::SetLevelRange(this, v5, a2, 1);
  }
  return result;
}

uint64_t TLine::GetLeftWhitespaceGlyphCountAndWidth(TLine *this)
{
  uint64_t v2 = 0;
  uint64_t v3 = 0;
  uint64_t v4 = *((void *)this + 3) - *((void *)this + 2);
  uint64_t v5 = 8 * (((unint64_t)v4 >> 3) & ~(v4 >> 63));
  double v6 = 0.0;
  do
  {
    if (v5 == v2) {
      break;
    }
    uint64_t v7 = *(void **)(*(void *)(*((void *)this + 2) + v2) + 40);
    uint64_t v8 = (*(uint64_t (**)(void *))(*v7 + 80))(v7);
    v3 += v8;
    double v6 = v6 + v9;
    v2 += 8;
  }
  while (v8 >= v7[26]);
  return v3;
}

uint64_t TLine::GetLeftPartialHangingGlyphCountAndWidth(TLine *this, const unint64_t *a2)
{
  uint64_t v2 = *((void *)this + 3) - *((void *)this + 2);
  if (v2 < 1) {
    return 0;
  }
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  uint64_t v7 = (unint64_t)v2 >> 3;
  if (v7 <= 1) {
    uint64_t v7 = 1;
  }
  uint64_t v8 = v7 - 1;
  double v9 = 0.0;
  do
  {
    CFIndex v10 = *(TRun **)(*(void *)(*((void *)this + 2) + 8 * v5) + 40);
    uint64_t v11 = *((void *)v10 + 26);
    if (*(double *)&a2 == 0.0)
    {
      uint64_t v13 = (TParagraphStyle **)*((void *)v10 + 21);
      if (v13) {
        LOBYTE(v12) = TParagraphStyle::GetLineBoundsOptions(v13, a2);
      }
      else {
        LOBYTE(v12) = 0;
      }
    }
    else
    {
      uint64_t v12 = *a2;
    }
    LeftPartialHangingGlyphCountAnddouble Width = TRun::GetLeftPartialHangingGlyphCountAndWidth(v10, 0, v12, *(const TCharStream **)this);
    v6 += LeftPartialHangingGlyphCountAndWidth;
    double v9 = v9 + *(double *)&a2;
  }
  while (LeftPartialHangingGlyphCountAndWidth >= v11 && v8 != v5++);
  return v6;
}

void TLine::CopyPath(TLine *this@<X0>, void *a2@<X8>)
{
  id Mutable = CGPathCreateMutable();
  uint64_t v4 = *((void *)this + 3) - *((void *)this + 2);
  if (v4 >= 1)
  {
    uint64_t v5 = 0;
    uint64_t v6 = (unint64_t)v4 >> 3;
    if (v6 <= 1) {
      uint64_t v7 = 1;
    }
    else {
      uint64_t v7 = v6;
    }
    do
    {
      uint64_t v8 = *(atomic_ullong **)(*(void *)(*((void *)this + 2) + 8 * v5) + 40);
      id v9 = (id)0xAAAAAAAAAAAAAAAALL;
      TRun::CopyPath(v8, &v9);
      CGPathAddPath((CGMutablePathRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), 0, (CGPathRef)atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire));

      ++v5;
    }
    while (v7 != v5);
  }
  *a2 = atomic_exchange((atomic_ullong *volatile)&Mutable, 0);
}

void TLine::DoGlyphFixups(TLine *this)
{
  uint64_t v1 = *((void *)this + 3) - *((void *)this + 2);
  if (v1 >= 1)
  {
    uint64_t v3 = 0;
    uint64_t v4 = (unint64_t)v1 >> 3;
    if (v4 <= 1) {
      uint64_t v5 = 1;
    }
    else {
      uint64_t v5 = v4;
    }
    uint64_t v6 = (double *)MEMORY[0x1E4F1DB30];
    while (1)
    {
      uint64_t v7 = *(void *)(*(void *)(*((void *)this + 2) + 8 * v3) + 48);
      uint64_t v9 = *(void *)(v7 + 208);
      uint64_t v8 = *(void **)(v7 + 216);
      uint64_t v10 = v8[2];
      uint64_t v11 = *(void *)(v7 + 200);
      if ((*(unsigned char *)(v7 + 225) & 0x10) != 0 && ([v8 implementsOrigins] & 1) == 0) {
        break;
      }
      if (v9 >= 1)
      {
        uint64_t v12 = 0;
        uint64_t v13 = v10 + 2 * v11;
        do
        {
          if (*(__int16 *)(v13 + 2 * v12) == -1) {
            [*(id *)(v7 + 216) setProps:*(_DWORD *)(*(void *)(*(void *)(v7 + 216) + 40) + 4 * *(void *)(v7 + 200) + 4 * v12) | 0x20u atIndex:v12 + *(void *)(v7 + 200)];
          }
          ++v12;
        }
        while (v9 != v12);
      }
LABEL_59:
      if (++v3 == v5) {
        return;
      }
    }
    uint64_t v14 = objc_msgSend(*(id *)(v7 + 216), "copyWithRange:", *(void *)(v7 + 200), *(void *)(v7 + 208));

    *(void *)(v7 + 216) = v14;
    *(void *)(v7 + 200) = 0;
    double v15 = *v6;
    double v16 = v6[1];
    if (v9 < 1)
    {
LABEL_49:
      if (v15 != *v6 || v16 != v6[1])
      {
        int v48 = (double *)MEMORY[0x1E4F1DAD8];
        double v49 = *MEMORY[0x1E4F1DAD8];
        double v50 = *(double *)(MEMORY[0x1E4F1DAD8] + 8);
        objc_msgSend(*(id *)(v7 + 216), "setOrigin:atIndex:", *(void *)(v7 + 200), *MEMORY[0x1E4F1DAD8], v50);
        if (v49 != *v48 || v50 != v48[1]) {
          *(unsigned char *)(v7 + 225) |= 0x10u;
        }
        v55.CGFloat width = v15;
        v55.CGFloat height = v16;
        TRun::AdvanceInitialAdvance((TRun *)v7, v55);
      }
      goto LABEL_59;
    }
    double v52 = (TStorageRange *)(v7 + 192);
    uint64_t v17 = v10 + 2 * v11 - 2;
    while (1)
    {
      uint64_t v18 = 16 * v9 - 8;
      uint64_t v19 = 8 * v9 - 8;
      unint64_t v20 = v9;
      while (1)
      {
        uint64_t v9 = v20 - 1;
        if (*(__int16 *)(v17 + 2 * v20) != -1) {
          break;
        }
        [*(id *)(v7 + 216) setProps:*(_DWORD *)(*(void *)(*(void *)(v7 + 216) + 40) + 4 * *(void *)(v7 + 200) + 4 * v20 - 4) | 0x20u atIndex:v20 + *(void *)(v7 + 200) - 1];
        v18 -= 16;
        v19 -= 8;
        --v20;
        if ((unint64_t)(v9 + 1) <= 1) {
          goto LABEL_49;
        }
      }
      if (v15 != *v6 || v16 != v6[1]) {
        break;
      }
LABEL_30:
      if ((*(unsigned char *)(v7 + 225) & 0x10) != 0)
      {
        [*(id *)(v7 + 216) originAtIndex:*(void *)(v7 + 200) + v20 - 1];
        double v32 = v34;
        double v33 = v35;
        double v30 = *MEMORY[0x1E4F1DAD8];
        double v31 = *(double *)(MEMORY[0x1E4F1DAD8] + 8);
      }
      else
      {
        double v30 = *MEMORY[0x1E4F1DAD8];
        double v31 = *(double *)(MEMORY[0x1E4F1DAD8] + 8);
        double v32 = *MEMORY[0x1E4F1DAD8];
        double v33 = v31;
      }
      if (v32 != v30 || v33 != v31)
      {
        CGFloat v37 = *(void **)(v7 + 216);
        uint64_t v38 = v37[4];
        if (v38)
        {
          uint64_t v39 = *(void *)(v7 + 200);
          goto LABEL_39;
        }
        uint64_t v44 = v37[3];
        uint64_t v39 = *(void *)(v7 + 200);
        if (v44)
        {
          id v41 = (double *)(v44 + 8 * v39 + v19);
          double v43 = 0.0;
        }
        else
        {
LABEL_39:
          uint64_t v40 = (double *)(v38 + 16 * v39 + v18);
          double v42 = *v40;
          id v41 = v40 - 1;
          double v43 = v42;
        }
        double v45 = *v41;
        objc_msgSend(v37, "setOrigin:atIndex:", v39 + v20 - 1, v30, v31);
        if (v30 != *MEMORY[0x1E4F1DAD8] || v31 != *(double *)(MEMORY[0x1E4F1DAD8] + 8)) {
          *(unsigned char *)(v7 + 225) |= 0x10u;
        }
        v54.CGFloat width = v45 - v32;
        v54.CGFloat height = v43 - v33;
        TStorageRange::SetAdvance(v52, v20 - 1, v54);
        double v15 = v15 + v32;
        double v16 = v16 + v33;
      }
      if (v20 <= 1) {
        goto LABEL_49;
      }
    }
    uint64_t v22 = *(void *)(v7 + 216);
    uint64_t v23 = *(void *)(v22 + 32);
    if (v23)
    {
      uint64_t v24 = *(void *)(v7 + 200);
    }
    else
    {
      uint64_t v29 = *(void *)(v22 + 24);
      uint64_t v24 = *(void *)(v7 + 200);
      if (v29)
      {
        uint64_t v26 = (double *)(v29 + 8 * v24 + v19);
        double v28 = 0.0;
        goto LABEL_29;
      }
    }
    uint64_t v25 = (double *)(v23 + 16 * v24 + v18);
    double v27 = *v25;
    uint64_t v26 = v25 - 1;
    double v28 = v27;
LABEL_29:
    v53.CGFloat width = v15 + *v26;
    v53.CGFloat height = v16 + v28;
    TStorageRange::SetAdvance(v52, v20 - 1, v53);
    double v15 = *v6;
    double v16 = v6[1];
    goto LABEL_30;
  }
}

CGFloat TRun::AdvanceInitialAdvance(TRun *this, CGSize a2)
{
  uint64_t v2 = (double *)*((void *)this + 39);
  if (!v2) {
    operator new();
  }
  CGFloat result = a2.width + *v2;
  CGFloat v4 = a2.height + v2[1];
  *uint64_t v2 = result;
  v2[1] = v4;
  return result;
}

__n128 std::__stable_sort_move<std::_ClassicAlgPolicy,std::__less<void,void> &,TLine::EnumerateCaretOffsets(std::function<void ()(double,long,BOOL,BOOL *)>)::$_0::operator() const(unsigned long,int)::CaretPair *>(double *a1, double *a2, unint64_t a3, uint64_t a4, __n128 result)
{
  if (a3)
  {
    uint64_t v5 = (__n128 *)a4;
    uint64_t v8 = (__n128 *)a1;
    if (a3 == 2)
    {
      uint64_t v10 = (__n128 *)(a2 - 4);
      if (*(a2 - 4) >= *a1)
      {
        long long v24 = *((_OWORD *)a1 + 1);
        *(_OWORD *)a4 = *(_OWORD *)a1;
        *(_OWORD *)(a4 + 16) = v24;
        CGFloat result = *v10;
        long long v12 = *((_OWORD *)a2 - 1);
      }
      else
      {
        long long v11 = *((_OWORD *)a2 - 1);
        *(__n128 *)a4 = *v10;
        *(_OWORD *)(a4 + 16) = v11;
        CGFloat result = *(__n128 *)a1;
        long long v12 = *((_OWORD *)a1 + 1);
      }
      *(__n128 *)(a4 + 32) = result;
      *(_OWORD *)(a4 + 48) = v12;
    }
    else if (a3 == 1)
    {
      CGFloat result = *(__n128 *)a1;
      long long v9 = *((_OWORD *)a1 + 1);
      *(_OWORD *)a4 = *(_OWORD *)a1;
      *(_OWORD *)(a4 + 16) = v9;
    }
    else if ((uint64_t)a3 > 8)
    {
      uint64_t v25 = (__n128 *)&a1[4 * (a3 >> 1)];
      std::__stable_sort<std::_ClassicAlgPolicy,std::__less<void,void> &,TLine::EnumerateCaretOffsets(std::function<void ()(double,long,BOOL,BOOL *)>)::$_0::operator() const(unsigned long,int)::CaretPair *>(a1, v25, a3 >> 1, a4, a3 >> 1);
      std::__stable_sort<std::_ClassicAlgPolicy,std::__less<void,void> &,TLine::EnumerateCaretOffsets(std::function<void ()(double,long,BOOL,BOOL *)>)::$_0::operator() const(unsigned long,int)::CaretPair *>(&v8[2 * (a3 >> 1)], a2, a3 - (a3 >> 1), &v5[2 * (a3 >> 1)], a3 - (a3 >> 1));
      uint64_t v26 = &v8[2 * (a3 >> 1)];
      while (v26 != (__n128 *)a2)
      {
        if (v26->n128_f64[0] >= v8->n128_f64[0])
        {
          CGFloat result = *v8;
          __n128 v27 = v8[1];
          v8 += 2;
        }
        else
        {
          CGFloat result = *v26;
          __n128 v27 = v26[1];
          v26 += 2;
        }
        __n128 *v5 = result;
        v5[1] = v27;
        v5 += 2;
        if (v8 == v25)
        {
          if (v26 != (__n128 *)a2)
          {
            uint64_t v28 = 0;
            do
            {
              uint64_t v29 = &v5[v28];
              CGFloat result = v26[v28];
              __n128 v30 = v26[v28 + 1];
              *uint64_t v29 = result;
              v29[1] = v30;
              v28 += 2;
            }
            while (&v26[v28] != (__n128 *)a2);
          }
          return result;
        }
      }
      if (v8 != v25)
      {
        uint64_t v31 = 0;
        do
        {
          double v32 = &v5[v31];
          CGFloat result = v8[v31];
          __n128 v33 = v8[v31 + 1];
          *double v32 = result;
          v32[1] = v33;
          v31 += 2;
        }
        while (&v8[v31] != v25);
      }
    }
    else if (a1 != a2)
    {
      CGFloat result = *(__n128 *)a1;
      long long v13 = *((_OWORD *)a1 + 1);
      *(_OWORD *)a4 = *(_OWORD *)a1;
      *(_OWORD *)(a4 + 16) = v13;
      uint64_t v14 = a1 + 4;
      if (a1 + 4 != a2)
      {
        uint64_t v15 = 0;
        double v16 = (_OWORD *)a4;
        do
        {
          uint64_t v17 = v16;
          double v18 = *(double *)v16;
          v16 += 2;
          uint64_t v19 = v16;
          if (*v14 < v18)
          {
            long long v20 = v17[1];
            *double v16 = *v17;
            v16[1] = v20;
            uint64_t v19 = (_OWORD *)a4;
            if (v17 != (_OWORD *)a4)
            {
              uint64_t v21 = v15;
              while (1)
              {
                uint64_t v19 = (_OWORD *)(a4 + v21);
                if (*v14 >= *(double *)(a4 + v21 - 32)) {
                  break;
                }
                long long v22 = *(_OWORD *)(a4 + v21 - 16);
                *uint64_t v19 = *(_OWORD *)(a4 + v21 - 32);
                v19[1] = v22;
                v21 -= 32;
                if (!v21)
                {
                  uint64_t v19 = (_OWORD *)a4;
                  break;
                }
              }
            }
          }
          CGFloat result = *(__n128 *)v14;
          long long v23 = *((_OWORD *)v14 + 1);
          v14 += 4;
          *uint64_t v19 = result;
          v19[1] = v23;
          v15 += 32;
        }
        while (v14 != a2);
      }
    }
  }
  return result;
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,TLine::SeparateCharWithGlyphIndex(long *,long)::$_0 &,TRun **,false>(uint64_t result, uint64_t *a2, uint64_t a3, char a4)
{
  long long v9 = (uint64_t *)result;
  while (2)
  {
    uint64_t v10 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          long long v9 = v10;
          uint64_t v11 = (char *)a2 - (char *)v10;
          unint64_t v12 = a2 - v10;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                uint64_t v40 = *(a2 - 1);
                uint64_t v41 = *v10;
                if (*(void *)(v40 + 8) < *(void *)(*v10 + 8))
                {
                  *uint64_t v10 = v40;
                  *(a2 - 1) = v41;
                }
                break;
              case 3uLL:
                CGFloat result = (uint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TLine::SeparateCharWithGlyphIndex(long *,long)::$_0 &,TRun **>(v10, v10 + 1, a2 - 1);
                break;
              case 4uLL:
                CGFloat result = (uint64_t)std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,TLine::SeparateCharWithGlyphIndex(long *,long)::$_0 &,TRun **>(v10, v10 + 1, v10 + 2, a2 - 1);
                break;
              case 5uLL:
                double v42 = v10 + 1;
                double v43 = v10 + 2;
                uint64_t v44 = v10 + 3;
                CGFloat result = (uint64_t)std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,TLine::SeparateCharWithGlyphIndex(long *,long)::$_0 &,TRun **>(v10, v10 + 1, v10 + 2, v10 + 3);
                uint64_t v45 = *(a2 - 1);
                uint64_t v46 = v10[3];
                if (*(void *)(v45 + 8) < *(void *)(v46 + 8))
                {
                  *uint64_t v44 = v45;
                  *(a2 - 1) = v46;
                  uint64_t v47 = *v44;
                  uint64_t v48 = *v43;
                  uint64_t v49 = *(void *)(*v44 + 8);
                  if (v49 < *(void *)(*v43 + 8))
                  {
                    uint64_t *v43 = v47;
                    *uint64_t v44 = v48;
                    uint64_t v50 = *v42;
                    if (v49 < *(void *)(*v42 + 8))
                    {
                      v10[1] = v47;
                      void v10[2] = v50;
                      uint64_t v51 = *v10;
                      if (v49 < *(void *)(*v10 + 8))
                      {
                        *uint64_t v10 = v47;
                        v10[1] = v51;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v11 <= 191)
          {
            double v52 = v10 + 1;
            BOOL v54 = v10 == a2 || v52 == a2;
            if (a4)
            {
              if (!v54)
              {
                uint64_t v55 = 8;
                CGFloat v56 = v10;
                do
                {
                  uint64_t v58 = *v56;
                  uint64_t v57 = v56[1];
                  CGFloat v56 = v52;
                  uint64_t v59 = *(void *)(v57 + 8);
                  if (v59 < *(void *)(v58 + 8))
                  {
                    uint64_t v60 = v55;
                    do
                    {
                      *(uint64_t *)((char *)v10 + v60) = v58;
                      uint64_t v61 = v60 - 8;
                      if (v60 == 8)
                      {
                        CGFloat v62 = v10;
                        goto LABEL_85;
                      }
                      uint64_t v58 = *(uint64_t *)((char *)v10 + v60 - 16);
                      v60 -= 8;
                    }
                    while (v59 < *(void *)(v58 + 8));
                    CGFloat v62 = (uint64_t *)((char *)v10 + v61);
LABEL_85:
                    *CGFloat v62 = v57;
                  }
                  double v52 = v56 + 1;
                  v55 += 8;
                }
                while (v56 + 1 != a2);
              }
            }
            else if (!v54)
            {
              do
              {
                uint64_t v93 = *v9;
                uint64_t v92 = v9[1];
                long long v9 = v52;
                uint64_t v94 = *(void *)(v92 + 8);
                if (v94 < *(void *)(v93 + 8))
                {
                  do
                  {
                    uint64_t *v52 = v93;
                    uint64_t v93 = *(v52 - 2);
                    --v52;
                  }
                  while (v94 < *(void *)(v93 + 8));
                  uint64_t *v52 = v92;
                }
                double v52 = v9 + 1;
              }
              while (v9 + 1 != a2);
            }
            return result;
          }
          if (!a3)
          {
            if (v10 != a2)
            {
              int64_t v63 = (v12 - 2) >> 1;
              int64_t v64 = v63;
              do
              {
                int64_t v65 = v64;
                if (v63 >= v64)
                {
                  uint64_t v66 = (2 * v64) | 1;
                  CGAffineTransform v67 = &v10[v66];
                  uint64_t v68 = *v67;
                  if (2 * v65 + 2 < (uint64_t)v12)
                  {
                    CGFloat result = *(void *)(v68 + 8);
                    if (result < *(void *)(v67[1] + 8))
                    {
                      uint64_t v68 = v67[1];
                      ++v67;
                      uint64_t v66 = 2 * v65 + 2;
                    }
                  }
                  unint64_t v69 = &v10[v65];
                  uint64_t v70 = *v69;
                  uint64_t v71 = *(void *)(*v69 + 8);
                  if (*(void *)(v68 + 8) >= v71)
                  {
                    do
                    {
                      long long v72 = v67;
                      *unint64_t v69 = v68;
                      if (v63 < v66) {
                        break;
                      }
                      CGFloat result = (2 * v66) | 1;
                      CGAffineTransform v67 = &v10[result];
                      uint64_t v73 = 2 * v66 + 2;
                      uint64_t v68 = *v67;
                      if (v73 < (uint64_t)v12 && *(void *)(v68 + 8) < *(void *)(v67[1] + 8))
                      {
                        uint64_t v68 = v67[1];
                        ++v67;
                        CGFloat result = v73;
                      }
                      unint64_t v69 = v72;
                      uint64_t v66 = result;
                    }
                    while (*(void *)(v68 + 8) >= v71);
                    *long long v72 = v70;
                  }
                }
                int64_t v64 = v65 - 1;
              }
              while (v65);
              uint64_t v74 = (unint64_t)v11 >> 3;
              do
              {
                uint64_t v75 = 0;
                uint64_t v76 = *v10;
                uint64_t v77 = v10;
                do
                {
                  uint64_t v78 = &v77[v75];
                  uint64_t v81 = v78[1];
                  uint64_t v79 = v78 + 1;
                  uint64_t v80 = v81;
                  uint64_t v82 = (2 * v75) | 1;
                  uint64_t v83 = 2 * v75 + 2;
                  if (v83 < v74)
                  {
                    CGFloat result = *(void *)(v80 + 8);
                    if (result < *(void *)(v79[1] + 8))
                    {
                      uint64_t v80 = v79[1];
                      ++v79;
                      uint64_t v82 = v83;
                    }
                  }
                  *uint64_t v77 = v80;
                  uint64_t v77 = v79;
                  uint64_t v75 = v82;
                }
                while (v82 <= (uint64_t)((unint64_t)(v74 - 2) >> 1));
                if (v79 == --a2)
                {
                  *uint64_t v79 = v76;
                }
                else
                {
                  *uint64_t v79 = *a2;
                  *a2 = v76;
                  uint64_t v84 = (char *)v79 - (char *)v10 + 8;
                  if (v84 >= 9)
                  {
                    unint64_t v85 = (((unint64_t)v84 >> 3) - 2) >> 1;
                    uint64_t v86 = &v10[v85];
                    uint64_t v87 = *v86;
                    uint64_t v88 = *v79;
                    uint64_t v89 = *(void *)(*v79 + 8);
                    if (*(void *)(*v86 + 8) < v89)
                    {
                      do
                      {
                        int64_t v90 = v86;
                        *uint64_t v79 = v87;
                        if (!v85) {
                          break;
                        }
                        unint64_t v85 = (v85 - 1) >> 1;
                        uint64_t v86 = &v10[v85];
                        uint64_t v87 = *v86;
                        uint64_t v79 = v90;
                      }
                      while (*(void *)(*v86 + 8) < v89);
                      *int64_t v90 = v88;
                    }
                  }
                }
              }
              while (v74-- > 2);
            }
            return result;
          }
          unint64_t v13 = v12 >> 1;
          uint64_t v14 = &v10[v12 >> 1];
          if ((unint64_t)v11 >= 0x401)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TLine::SeparateCharWithGlyphIndex(long *,long)::$_0 &,TRun **>(v9, &v9[v12 >> 1], a2 - 1);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TLine::SeparateCharWithGlyphIndex(long *,long)::$_0 &,TRun **>(v9 + 1, v14 - 1, a2 - 2);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TLine::SeparateCharWithGlyphIndex(long *,long)::$_0 &,TRun **>(v9 + 2, &v9[v13 + 1], a2 - 3);
            CGFloat result = (uint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TLine::SeparateCharWithGlyphIndex(long *,long)::$_0 &,TRun **>(v14 - 1, v14, &v9[v13 + 1]);
            uint64_t v15 = *v9;
            *long long v9 = *v14;
            *uint64_t v14 = v15;
          }
          else
          {
            CGFloat result = (uint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TLine::SeparateCharWithGlyphIndex(long *,long)::$_0 &,TRun **>(&v9[v12 >> 1], v9, a2 - 1);
          }
          --a3;
          uint64_t v16 = *v9;
          if (a4) {
            break;
          }
          uint64_t v17 = *(void *)(v16 + 8);
          if (*(void *)(*(v9 - 1) + 8) < v17) {
            goto LABEL_13;
          }
          if (v17 >= *(void *)(*(a2 - 1) + 8))
          {
            double v32 = v9 + 1;
            do
            {
              uint64_t v10 = v32;
              if (v32 >= a2) {
                break;
              }
              ++v32;
            }
            while (v17 >= *(void *)(*v10 + 8));
          }
          else
          {
            uint64_t v10 = v9;
            do
            {
              uint64_t v31 = v10[1];
              ++v10;
            }
            while (v17 >= *(void *)(v31 + 8));
          }
          __n128 v33 = a2;
          if (v10 < a2)
          {
            __n128 v33 = a2;
            do
              uint64_t v34 = *--v33;
            while (v17 < *(void *)(v34 + 8));
          }
          if (v10 < v33)
          {
            uint64_t v35 = *v10;
            uint64_t v36 = *v33;
            do
            {
              *uint64_t v10 = v36;
              uint64_t *v33 = v35;
              do
              {
                uint64_t v37 = v10[1];
                ++v10;
                uint64_t v35 = v37;
              }
              while (v17 >= *(void *)(v37 + 8));
              do
              {
                uint64_t v38 = *--v33;
                uint64_t v36 = v38;
              }
              while (v17 < *(void *)(v38 + 8));
            }
            while (v10 < v33);
          }
          uint64_t v39 = v10 - 1;
          BOOL v4 = v10 - 1 >= v9;
          BOOL v5 = v10 - 1 == v9;
          if (v10 - 1 != v9) {
            *long long v9 = *v39;
          }
          a4 = 0;
          uint64_t *v39 = v16;
        }
        uint64_t v17 = *(void *)(v16 + 8);
LABEL_13:
        uint64_t v18 = 0;
        do
          uint64_t v19 = v9[++v18];
        while (*(void *)(v19 + 8) < v17);
        long long v20 = &v9[v18];
        uint64_t v21 = a2;
        if (v18 == 1)
        {
          uint64_t v21 = a2;
          do
          {
            if (v20 >= v21) {
              break;
            }
            uint64_t v23 = *--v21;
          }
          while (*(void *)(v23 + 8) >= v17);
        }
        else
        {
          do
            uint64_t v22 = *--v21;
          while (*(void *)(v22 + 8) >= v17);
        }
        if (v20 >= v21)
        {
          uint64_t v29 = v20 - 1;
        }
        else
        {
          uint64_t v24 = *v21;
          uint64_t v25 = v21;
          uint64_t v26 = &v9[v18];
          do
          {
            *uint64_t v26 = v24;
            *uint64_t v25 = v19;
            do
            {
              uint64_t v27 = v26[1];
              ++v26;
              uint64_t v19 = v27;
            }
            while (*(void *)(v27 + 8) < v17);
            do
            {
              uint64_t v28 = *--v25;
              uint64_t v24 = v28;
            }
            while (*(void *)(v28 + 8) >= v17);
          }
          while (v26 < v25);
          uint64_t v29 = v26 - 1;
        }
        if (v29 != v9) {
          *long long v9 = *v29;
        }
        *uint64_t v29 = v16;
        if (v20 >= v21) {
          break;
        }
LABEL_34:
        CGFloat result = std::__introsort<std::_ClassicAlgPolicy,TLine::SeparateCharWithGlyphIndex(long *,long)::$_0 &,TRun **,false>(v9, v29, a3, a4 & 1);
        a4 = 0;
        uint64_t v10 = v29 + 1;
      }
      BOOL v30 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,TLine::SeparateCharWithGlyphIndex(long *,long)::$_0 &,TRun **>(v9, v29);
      uint64_t v10 = v29 + 1;
      CGFloat result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,TLine::SeparateCharWithGlyphIndex(long *,long)::$_0 &,TRun **>(v29 + 1, a2);
      if (result) {
        break;
      }
      if (!v30) {
        goto LABEL_34;
      }
    }
    a2 = v29;
    if (!v30) {
      continue;
    }
    return result;
  }
}

uint64_t *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TLine::SeparateCharWithGlyphIndex(long *,long)::$_0 &,TRun **>(uint64_t *result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *result;
  uint64_t v5 = *(void *)(*a2 + 8);
  uint64_t v6 = *(void *)(*result + 8);
  uint64_t v7 = *a3;
  uint64_t v8 = *(void *)(*a3 + 8);
  if (v5 >= v6)
  {
    if (v8 < v5)
    {
      *a2 = v7;
      *a3 = v3;
      uint64_t v9 = *result;
      if (*(void *)(*a2 + 8) < *(void *)(*result + 8))
      {
        *CGFloat result = *a2;
        *a2 = v9;
      }
    }
  }
  else
  {
    if (v8 >= v5)
    {
      *CGFloat result = v3;
      *a2 = v4;
      if (*(void *)(*a3 + 8) >= v6) {
        return result;
      }
      *a2 = *a3;
    }
    else
    {
      *CGFloat result = v7;
    }
    *a3 = v4;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,TLine::SeparateCharWithGlyphIndex(long *,long)::$_0 &,TRun **>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v6 = *(a2 - 1);
      uint64_t v7 = *a1;
      if (*(void *)(v6 + 8) < *(void *)(*a1 + 8))
      {
        *a1 = v6;
        *(a2 - 1) = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TLine::SeparateCharWithGlyphIndex(long *,long)::$_0 &,TRun **>(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,TLine::SeparateCharWithGlyphIndex(long *,long)::$_0 &,TRun **>(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      uint64_t v18 = a1 + 1;
      uint64_t v19 = a1 + 2;
      long long v20 = a1 + 3;
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,TLine::SeparateCharWithGlyphIndex(long *,long)::$_0 &,TRun **>(a1, a1 + 1, a1 + 2, a1 + 3);
      uint64_t v21 = *(a2 - 1);
      uint64_t v22 = a1[3];
      if (*(void *)(v21 + 8) < *(void *)(v22 + 8))
      {
        uint64_t *v20 = v21;
        *(a2 - 1) = v22;
        uint64_t v23 = *v20;
        uint64_t v24 = *v19;
        uint64_t v25 = *(void *)(*v20 + 8);
        if (v25 < *(void *)(*v19 + 8))
        {
          *uint64_t v19 = v23;
          uint64_t *v20 = v24;
          uint64_t v26 = *v18;
          if (v25 < *(void *)(*v18 + 8))
          {
            a1[1] = v23;
            a1[2] = v26;
            uint64_t v27 = *a1;
            if (v25 < *(void *)(*a1 + 8))
            {
              *a1 = v23;
              a1[1] = v27;
            }
          }
        }
      }
      return 1;
    default:
      uint64_t v8 = a1 + 2;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TLine::SeparateCharWithGlyphIndex(long *,long)::$_0 &,TRun **>(a1, a1 + 1, a1 + 2);
      uint64_t v9 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v10 = 0;
      uint64_t v11 = 24;
      break;
  }
  while (1)
  {
    uint64_t v12 = *v9;
    uint64_t v13 = *v8;
    uint64_t v14 = *(void *)(*v9 + 8);
    if (v14 < *(void *)(*v8 + 8))
    {
      uint64_t v15 = v11;
      while (1)
      {
        *(uint64_t *)((char *)a1 + v15) = v13;
        uint64_t v16 = v15 - 8;
        if (v15 == 8) {
          break;
        }
        uint64_t v13 = *(uint64_t *)((char *)a1 + v15 - 16);
        v15 -= 8;
        if (v14 >= *(void *)(v13 + 8))
        {
          uint64_t v17 = (uint64_t *)((char *)a1 + v16);
          goto LABEL_13;
        }
      }
      uint64_t v17 = a1;
LABEL_13:
      *uint64_t v17 = v12;
      if (++v10 == 8) {
        return v9 + 1 == a2;
      }
    }
    uint64_t v8 = v9;
    v11 += 8;
    if (++v9 == a2) {
      return 1;
    }
  }
}

uint64_t *std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,TLine::SeparateCharWithGlyphIndex(long *,long)::$_0 &,TRun **>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  BOOL result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TLine::SeparateCharWithGlyphIndex(long *,long)::$_0 &,TRun **>(a1, a2, a3);
  uint64_t v9 = *a3;
  if (*(void *)(*a4 + 8) < *(void *)(*a3 + 8))
  {
    *a3 = *a4;
    *a4 = v9;
    uint64_t v10 = *a2;
    if (*(void *)(*a3 + 8) < *(void *)(*a2 + 8))
    {
      *a2 = *a3;
      *a3 = v10;
      uint64_t v11 = *a1;
      if (*(void *)(*a2 + 8) < *(void *)(*a1 + 8))
      {
        *a1 = *a2;
        *a2 = v11;
      }
    }
  }
  return result;
}

void std::__function::__func<TLine::PositionToCharIndex(CGPoint)::$_0,std::allocator<TLine::PositionToCharIndex(CGPoint)::$_0>,void ()(double,long,BOOL,BOOL *)>::~__func()
{
}

__n128 std::__function::__func<TLine::PositionToCharIndex(CGPoint)::$_0,std::allocator<TLine::PositionToCharIndex(CGPoint)::$_0>,void ()(double,long,BOOL,BOOL *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v2 = &unk_1ED061EE0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

__n128 std::__function::__func<TLine::PositionToCharIndex(CGPoint)::$_0,std::allocator<TLine::PositionToCharIndex(CGPoint)::$_0>,void ()(double,long,BOOL,BOOL *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ED061EE0;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 40) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<TLine::PositionToCharIndex(CGPoint)::$_0,std::allocator<TLine::PositionToCharIndex(CGPoint)::$_0>,void ()(double,long,BOOL,BOOL *)>::operator()(uint64_t a1, double *a2, uint64_t *a3, unsigned char *a4, unsigned char **a5)
{
  double v6 = *a2;
  uint64_t v7 = *a3;
  int v8 = *a4;
  BOOL v9 = *a4 != 0;
  uint64_t v10 = *a5;
  uint64_t v11 = *(TLine **)(a1 + 40);
  uint64_t result = TLine::FindRunWithCharIndex(v11, *a3, 1);
  int v13 = *(unsigned __int8 *)(*(void *)(*(void *)(*((void *)v11 + 2) + 8 * result) + 40) + 224);
  if (((v9 ^ ((v13 & 1) == 0)) & 1) == 0)
  {
    uint64_t v14 = *(double **)(a1 + 16);
    if (*v14 < v6 && *(double *)(a1 + 32) >= v6)
    {
      *uint64_t v14 = v6;
      if (v8) {
        uint64_t v16 = v7;
      }
      else {
        uint64_t v16 = v7 + 1;
      }
      **(void **)(a1 + 24) = v16;
    }
  }
  if ((((v8 != 0) ^ v13) & 1) == 0)
  {
    double v17 = *(double *)(a1 + 32);
    if (v17 <= v6)
    {
      if (v17 >= **(double **)(a1 + 16) + (v6 - **(double **)(a1 + 16)) * 0.5)
      {
        if (v8) {
          uint64_t v18 = v7;
        }
        else {
          uint64_t v18 = v7 + 1;
        }
      }
      else
      {
        uint64_t v18 = **(void **)(a1 + 24);
      }
      **(void **)(a1 + 8) = v18;
      *uint64_t v10 = 1;
    }
  }
  return result;
}

void std::__function::__func<TLine::CharIndexToOffsets(long)::$_0,std::allocator<TLine::CharIndexToOffsets(long)::$_0>,void ()(double,long,BOOL,BOOL *)>::~__func()
{
}

__n128 std::__function::__func<TLine::CharIndexToOffsets(long)::$_0,std::allocator<TLine::CharIndexToOffsets(long)::$_0>,void ()(double,long,BOOL,BOOL *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_1ED061E98;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 std::__function::__func<TLine::CharIndexToOffsets(long)::$_0,std::allocator<TLine::CharIndexToOffsets(long)::$_0>,void ()(double,long,BOOL,BOOL *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ED061E98;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__stable_sort_move<std::_ClassicAlgPolicy,TLine::EnumerateCaretOffsets(std::function<void ()(double,long,BOOL,BOOL *)>)::$_2 &,TLine::CaretInfo *>(__n128 *a1, __n128 *a2, unint64_t a3, __n128 *a4, __n128 result)
{
  if (a3)
  {
    uint64_t v5 = a4;
    int v8 = a1;
    if (a3 == 2)
    {
      BOOL v9 = a2 - 1;
      if (a2[-1].n128_f64[0] >= a1->n128_f64[0])
      {
        *a4 = *a1;
        __n128 result = *v9;
      }
      else
      {
        *a4 = *v9;
        __n128 result = *a1;
      }
      a4[1] = result;
    }
    else if (a3 == 1)
    {
      __n128 result = *a1;
      *a4 = *a1;
    }
    else if ((uint64_t)a3 > 8)
    {
      uint64_t v18 = &a1[a3 >> 1];
      std::__stable_sort<std::_ClassicAlgPolicy,TLine::EnumerateCaretOffsets(std::function<void ()(double,long,BOOL,BOOL *)>)::$_2 &,TLine::CaretInfo *>(a1, v18, a3 >> 1, a4, a3 >> 1);
      std::__stable_sort<std::_ClassicAlgPolicy,TLine::EnumerateCaretOffsets(std::function<void ()(double,long,BOOL,BOOL *)>)::$_2 &,TLine::CaretInfo *>(&v8[a3 >> 1], a2, a3 - (a3 >> 1), &v5[a3 >> 1], a3 - (a3 >> 1));
      uint64_t v19 = &v8[a3 >> 1];
      while (v19 != a2)
      {
        if (v19->n128_f64[0] >= v8->n128_f64[0])
        {
          __n128 v21 = *v8++;
          __n128 result = v21;
        }
        else
        {
          __n128 v20 = *v19++;
          __n128 result = v20;
        }
        *v5++ = result;
        if (v8 == v18)
        {
          if (v19 != a2)
          {
            uint64_t v22 = 0;
            do
            {
              __n128 result = v19[v22];
              v5[v22++] = result;
            }
            while (&v19[v22] != a2);
          }
          return result;
        }
      }
      if (v8 != v18)
      {
        uint64_t v23 = 0;
        do
        {
          __n128 result = v8[v23];
          v5[v23++] = result;
        }
        while (&v8[v23] != v18);
      }
    }
    else if (a1 != a2)
    {
      __n128 result = *a1;
      *a4 = *a1;
      n128_f64 = a1[1].n128_f64;
      if (&a1[1] != a2)
      {
        uint64_t v11 = 0;
        uint64_t v12 = (double *)a4;
        do
        {
          int v13 = v12;
          double v14 = *v12;
          v12 += 2;
          uint64_t v15 = v12;
          if (*n128_f64 < v14)
          {
            *(_OWORD *)uint64_t v12 = *(_OWORD *)v13;
            uint64_t v15 = (double *)a4;
            if (v13 != (double *)a4)
            {
              uint64_t v16 = v11;
              while (1)
              {
                uint64_t v15 = (double *)((char *)a4->n128_f64 + v16);
                if (*n128_f64 >= *(double *)((char *)a4[-1].n128_f64 + v16)) {
                  break;
                }
                *(__n128 *)uint64_t v15 = *(__n128 *)((char *)a4 + v16 - 16);
                v16 -= 16;
                if (!v16)
                {
                  uint64_t v15 = (double *)a4;
                  break;
                }
              }
            }
          }
          long long v17 = *(_OWORD *)n128_f64;
          n128_f64 += 2;
          result.n128_u64[0] = v17;
          *(_OWORD *)uint64_t v15 = v17;
          v11 += 16;
        }
        while (n128_f64 != (double *)a2);
      }
    }
  }
  return result;
}

double *std::__inplace_merge<std::_ClassicAlgPolicy,TLine::EnumerateCaretOffsets(std::function<void ()(double,long,BOOL,BOOL *)>)::$_2 &,TLine::CaretInfo *>(double *result, double *a2, double *a3, uint64_t a4, uint64_t a5, double *a6, uint64_t a7)
{
  if (a5)
  {
    uint64_t v8 = a5;
    while (a4 > a7 && v8 > a7)
    {
      if (!a4) {
        return result;
      }
      uint64_t v11 = 0;
      uint64_t v12 = -a4;
      while (*a2 >= result[v11])
      {
        v11 += 2;
        if (__CFADD__(v12++, 1)) {
          return result;
        }
      }
      uint64_t v14 = -v12;
      uint64_t v15 = &result[v11];
      if (-v12 >= v8)
      {
        if (v12 == -1)
        {
          long long v79 = *(_OWORD *)&result[v11];
          *(_OWORD *)&result[v11] = *(_OWORD *)a2;
          *(_OWORD *)a2 = v79;
          return result;
        }
        if (v12 > 0) {
          uint64_t v14 = 1 - v12;
        }
        uint64_t v25 = v14 >> 1;
        uint64_t v19 = &result[2 * (v14 >> 1) + v11];
        uint64_t v18 = a3;
        if (a3 != a2)
        {
          unint64_t v26 = ((char *)a3 - (char *)a2) >> 4;
          uint64_t v18 = a2;
          do
          {
            unint64_t v27 = v26 >> 1;
            uint64_t v28 = &v18[2 * (v26 >> 1)];
            double v30 = *v28;
            uint64_t v29 = v28 + 2;
            v26 += ~(v26 >> 1);
            if (v30 >= *v19) {
              unint64_t v26 = v27;
            }
            else {
              uint64_t v18 = v29;
            }
          }
          while (v26);
        }
        uint64_t v17 = ((char *)v18 - (char *)a2) >> 4;
      }
      else
      {
        if (v8 >= 0) {
          uint64_t v16 = v8;
        }
        else {
          uint64_t v16 = v8 + 1;
        }
        uint64_t v17 = v16 >> 1;
        uint64_t v18 = &a2[2 * (v16 >> 1)];
        uint64_t v19 = a2;
        if (v15 != a2)
        {
          unint64_t v20 = ((char *)a2 - (char *)result - v11 * 8) >> 4;
          uint64_t v19 = &result[v11];
          do
          {
            unint64_t v21 = v20 >> 1;
            uint64_t v22 = &v19[2 * (v20 >> 1)];
            double v24 = *v22;
            uint64_t v23 = v22 + 2;
            v20 += ~(v20 >> 1);
            if (*v18 < v24) {
              unint64_t v20 = v21;
            }
            else {
              uint64_t v19 = v23;
            }
          }
          while (v20);
        }
        uint64_t v25 = ((char *)v19 - (char *)result - v11 * 8) >> 4;
      }
      uint64_t v31 = v18;
      if (v19 != a2)
      {
        uint64_t v31 = v19;
        if (a2 != v18)
        {
          if (v19 + 2 == a2)
          {
            long long v77 = *(_OWORD *)v19;
            int64_t v37 = (char *)v18 - (char *)a2;
            long long v72 = a6;
            uint64_t v74 = v15;
            uint64_t v38 = a3;
            uint64_t v39 = v17;
            memmove(v19, a2, (char *)v18 - (char *)a2);
            uint64_t v17 = v39;
            a6 = v72;
            uint64_t v15 = v74;
            a3 = v38;
            uint64_t v31 = (double *)((char *)v19 + v37);
            *(_OWORD *)uint64_t v31 = v77;
          }
          else if (a2 + 2 == v18)
          {
            uint64_t v31 = v19 + 2;
            long long v78 = *((_OWORD *)v18 - 1);
            if (v18 - 2 != v19)
            {
              uint64_t v73 = a6;
              uint64_t v75 = v15;
              uint64_t v40 = a3;
              uint64_t v41 = v17;
              memmove(v19 + 2, v19, (char *)(v18 - 2) - (char *)v19);
              uint64_t v17 = v41;
              a6 = v73;
              uint64_t v15 = v75;
              a3 = v40;
            }
            *(_OWORD *)uint64_t v19 = v78;
          }
          else
          {
            uint64_t v32 = ((char *)a2 - (char *)v19) >> 4;
            if (v32 == ((char *)v18 - (char *)a2) >> 4)
            {
              uint64_t v33 = 0;
              do
              {
                long long v76 = *(_OWORD *)&v19[v33];
                *(_OWORD *)&v19[v33] = *(_OWORD *)&a2[v33];
                uint64_t v34 = (uint64_t)&v19[v33 + 2];
                *(_OWORD *)&a2[v33] = v76;
                uint64_t v35 = (uint64_t)&a2[v33 + 2];
                v33 += 2;
              }
              while ((double *)v34 != a2 && v35 != (void)v18);
              uint64_t v31 = a2;
            }
            else
            {
              uint64_t v42 = ((char *)v18 - (char *)a2) >> 4;
              uint64_t v43 = ((char *)a2 - (char *)v19) >> 4;
              do
              {
                uint64_t v44 = v43;
                uint64_t v43 = v42;
                uint64_t v42 = v44 % v42;
              }
              while (v42);
              if (v43)
              {
                uint64_t v45 = &v19[2 * v43];
                do
                {
                  long long v46 = *((_OWORD *)v45 - 1);
                  v45 -= 2;
                  uint64_t v47 = &v45[2 * v32];
                  uint64_t v48 = v45;
                  do
                  {
                    uint64_t v49 = v48;
                    uint64_t v48 = v47;
                    *(_OWORD *)uint64_t v49 = *(_OWORD *)v47;
                    BOOL v50 = __OFSUB__(v32, ((char *)v18 - (char *)v47) >> 4);
                    uint64_t v52 = v32 - (((char *)v18 - (char *)v47) >> 4);
                    char v51 = (v52 < 0) ^ v50;
                    uint64_t v47 = &v19[2 * v52];
                    if (v51) {
                      uint64_t v47 = &v48[2 * v32];
                    }
                  }
                  while (v47 != v45);
                  *(_OWORD *)uint64_t v48 = v46;
                }
                while (v45 != v19);
              }
              uint64_t v31 = &v19[2 * (((char *)v18 - (char *)a2) >> 4)];
            }
          }
        }
      }
      a4 = -(v25 + v12);
      uint64_t v53 = v8 - v17;
      if (v17 + v25 >= v8 - (v17 + v25) - v12)
      {
        uint64_t v56 = -(v25 + v12);
        uint64_t v57 = v17;
        uint64_t v58 = v8 - v17;
        BOOL v54 = a6;
        uint64_t v59 = v15;
        std::__inplace_merge<std::_ClassicAlgPolicy,TLine::EnumerateCaretOffsets(std::function<void ()(double,long,BOOL,BOOL *)>)::$_2 &,TLine::CaretInfo *>(v31, v18, a3, v56, v58, a6, a7);
        __n128 result = v59;
        uint64_t v18 = v19;
        uint64_t v53 = v57;
        a4 = v25;
        a3 = v31;
      }
      else
      {
        BOOL v54 = a6;
        uint64_t v55 = a3;
        std::__inplace_merge<std::_ClassicAlgPolicy,TLine::EnumerateCaretOffsets(std::function<void ()(double,long,BOOL,BOOL *)>)::$_2 &,TLine::CaretInfo *>(v15, v19, v31, v25, v17, a6, a7);
        a3 = v55;
        __n128 result = v31;
      }
      uint64_t v8 = v53;
      a2 = v18;
      a6 = v54;
      if (!v53) {
        return result;
      }
    }
    if (a4 <= v8)
    {
      if (result != a2)
      {
        uint64_t v66 = 0;
        do
        {
          *(_OWORD *)&a6[v66] = *(_OWORD *)&result[v66];
          v66 += 2;
        }
        while (&result[v66] != a2);
        if (v66 * 8)
        {
          CGAffineTransform v67 = a6;
          while (a2 != a3)
          {
            if (*a2 >= *v67)
            {
              long long v70 = *(_OWORD *)v67;
              v67 += 2;
              long long v69 = v70;
            }
            else
            {
              long long v68 = *(_OWORD *)a2;
              a2 += 2;
              long long v69 = v68;
            }
            *(_OWORD *)__n128 result = v69;
            result += 2;
            if (&a6[v66] == v67) {
              return result;
            }
          }
          return (double *)memmove(result, v67, (char *)a6 - (char *)v67 + v66 * 8);
        }
      }
    }
    else if (a2 != a3)
    {
      uint64_t v60 = 0;
      do
      {
        *(_OWORD *)&a6[v60] = *(_OWORD *)&a2[v60];
        v60 += 2;
      }
      while (&a2[v60] != a3);
      if (v60 * 8)
      {
        uint64_t v61 = &a6[v60];
        CGFloat v62 = a3 - 2;
        while (a2 != result)
        {
          double v63 = *(v61 - 2);
          double v64 = *(a2 - 2);
          if (v63 >= v64) {
            int64_t v65 = v61 - 2;
          }
          else {
            int64_t v65 = a2 - 2;
          }
          if (v63 >= v64) {
            v61 -= 2;
          }
          else {
            a2 -= 2;
          }
          *(_OWORD *)CGFloat v62 = *(_OWORD *)v65;
          v62 -= 2;
          if (v61 == a6) {
            return result;
          }
        }
        unint64_t v71 = 0;
        do
        {
          *(_OWORD *)&v62[v71] = *(_OWORD *)&v61[v71 - 2];
          v71 -= 2;
        }
        while (&v61[v71] != a6);
      }
    }
  }
  return result;
}

uint64_t TFrame::operator==(uint64_t a1, atomic_ullong *a2)
{
  if (*(void *)(a1 + 16) != a2[2]
    || *(void *)(a1 + 24) != a2[3]
    || *(void *)a1 != *a2
    || *(void *)(a1 + 8) != a2[1])
  {
    return 0;
  }
  unint64_t explicit = (const void *)atomic_load_explicit((atomic_ullong *volatile)(a1 + 80), memory_order_acquire);
  uint64_t v5 = (const void *)atomic_load_explicit(a2 + 10, memory_order_acquire);
  if (explicit == v5 || (uint64_t result = 0, explicit) && v5 && (uint64_t result = CFEqual(explicit, v5), result))
  {
    uint64_t v7 = (const void *)atomic_load_explicit((atomic_ullong *volatile)(a1 + 88), memory_order_acquire);
    uint64_t v8 = (const void *)atomic_load_explicit(a2 + 11, memory_order_acquire);
    if (v7 == v8 || (uint64_t result = 0, v7) && v8 && (uint64_t result = CFEqual(v7, v8), result))
    {
      BOOL v9 = (const void *)atomic_load_explicit((atomic_ullong *volatile)(a1 + 104), memory_order_acquire);
      uint64_t v10 = (const void *)atomic_load_explicit(a2 + 13, memory_order_acquire);
      if (v9 == v10 || (uint64_t result = 0, v9) && v10 && (uint64_t result = CFEqual(v9, v10), result))
      {
        uint64_t result = std::operator==[abi:nn180100]<CGPoint,std::allocator<CGPoint>>((double **)(a1 + 112), (uint64_t)(a2 + 14));
        if (result) {
          return !operator!=((atomic_ullong *)(a1 + 136), a2 + 17);
        }
      }
    }
  }
  return result;
}

BOOL operator!=(atomic_ullong *a1, atomic_ullong *a2)
{
  unint64_t explicit = (const void *)atomic_load_explicit(a1, memory_order_acquire);
  long long v3 = (const void *)atomic_load_explicit(a2, memory_order_acquire);
  if (explicit == v3) {
    return 0;
  }
  if (explicit) {
    BOOL v4 = v3 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  return v4 || CFEqual(explicit, v3) == 0;
}

BOOL std::operator==[abi:nn180100]<CGPoint,std::allocator<CGPoint>>(double **a1, uint64_t a2)
{
  long long v3 = *a1;
  uint64_t v2 = a1[1];
  BOOL v4 = *(double **)a2;
  if ((char *)v2 - (char *)*a1 != *(void *)(a2 + 8) - *(void *)a2) {
    return 0;
  }
  if (v3 == v2) {
    return 1;
  }
  do
  {
    double v5 = *v3;
    double v6 = v3[1];
    v3 += 2;
    double v7 = *v4;
    double v8 = v4[1];
    v4 += 2;
    BOOL result = v6 == v8 && v5 == v7;
  }
  while (result && v3 != v2);
  return result;
}

__CFString *TFrame::DebugDescription(TFrame *this)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  id Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  BOOL v4 = (__CFString *)CFStringCreateWithFormat(v2, 0, @"(%ld, %ld)", *((void *)this + 2), *((void *)this + 3));
  CFStringAppendFormat(Mutable, 0, @"visible string range = %@, path = %@, attributes = %@, lines = %@", v4, atomic_load_explicit((atomic_ullong *volatile)this + 10, memory_order_acquire), atomic_load_explicit((atomic_ullong *volatile)this + 11, memory_order_acquire), atomic_load_explicit((atomic_ullong *volatile)this + 13, memory_order_acquire));

  return Mutable;
}

id TFrame::CopyDescriptionDictionary(atomic_ullong *this, uint64_t a2)
{
  id v4 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
  double v5 = (void *)[MEMORY[0x1E4F1CA48] array];
  double v6 = this + 13;
  CFArrayRef v7 = (const __CFArray *)(id)atomic_load_explicit(this + 13, memory_order_acquire);
  CFArrayRef v8 = v7;
  if (v7) {
    CFIndex Count = CFArrayGetCount(v7);
  }
  else {
    CFIndex Count = 0;
  }

  objc_msgSend(v4, "setObject:forKey:", objc_msgSend(NSNumber, "numberWithInteger:", Count), @"numLines");
  CFArrayRef explicit = (const __CFArray *)atomic_load_explicit(v6, memory_order_acquire);
  if (explicit)
  {
    CFIndex v11 = CFArrayGetCount(explicit);
    if (v11)
    {
      CFIndex v12 = v11;
      for (CFIndex i = 0; i != v12; ++i)
      {
        int ValueAtIndex = (TLine **)CFArrayGetValueAtIndex(explicit, i);
        id v15 = TLine::CopyDescriptionDictionary(ValueAtIndex[5], a2);
        [v5 addObject:(id)CFMakeCollectable(v15)];
      }
    }
  }
  [v4 setObject:v5 forKey:@"lines"];
  return v4;
}

void TFrame::CopyVisibleString(atomic_ullong *this@<X0>, void *a2@<X8>)
{
  CFArrayRef v4 = (const __CFArray *)(id)atomic_load_explicit(this + 13, memory_order_acquire);
  if (!v4)
  {

    goto LABEL_7;
  }
  CFArrayRef v5 = v4;
  CFIndex Count = CFArrayGetCount(v4);

  if (Count <= 0)
  {
LABEL_7:
    *a2 = 0;
    return;
  }
  CFArrayRef v7 = *(void (**)(void))(***((void ***)CFArrayGetValueAtIndex((CFArrayRef)atomic_load_explicit(this + 13, memory_order_acquire), 0)+ 5)+ 16);

  v7();
}

void TFrame::DrawFrame(atomic_ullong *this, CGContext *a2)
{
  if (!*((_DWORD *)this + 36))
  {
    CFIndex Count = CFArrayGetCount((CFArrayRef)atomic_load_explicit(this + 13, memory_order_acquire));
    if (Count < 1) {
      return;
    }
    CFIndex v5 = Count;
    uint64_t v6 = 0;
    CFIndex v7 = 0;
    double v8 = *((double *)this + 6);
    double v9 = *((double *)this + 7);
    while (1)
    {
      uint64_t v10 = (TLine *)*((void *)TFrame::GetLineAtIndex(this, v7) + 5);
      if (!atomic_load_explicit(this + 17, memory_order_acquire)
        || CFBitVectorGetCount((CFBitVectorRef)atomic_load_explicit(this + 17, memory_order_acquire)) <= v7)
      {
        break;
      }
      BitAtIndedouble x = CFBitVectorGetBitAtIndex((CFBitVectorRef)atomic_load_explicit(this + 17, memory_order_acquire), v7);
      CGContextSetTextPosition(a2, v8 + *(double *)(this[14] + v6), v9 + *(double *)(this[14] + v6 + 8));
      if (!BitAtIndex) {
        goto LABEL_12;
      }
      CGContextSaveGState(a2);
      BoundingBodouble x = CGPathGetBoundingBox((CGPathRef)atomic_load_explicit(this + 10, memory_order_acquire));
      CGContextClipToRect(a2, BoundingBox);
      TLine::DrawGlyphs(v10, a2);
      CGContextRestoreGState(a2);
LABEL_13:
      ++v7;
      v6 += 16;
      if (v5 == v7) {
        return;
      }
    }
    CGContextSetTextPosition(a2, v8 + *(double *)(this[14] + v6), v9 + *(double *)(this[14] + v6 + 8));
LABEL_12:
    TLine::DrawGlyphs(v10, a2);
    goto LABEL_13;
  }

  TFrame::DrawFrameVertical(this, a2);
}

CFIndex TFrame::DrawFrameVertical(atomic_ullong *this, CGContext *a2)
{
  CFIndex result = CFArrayGetCount((CFArrayRef)atomic_load_explicit(this + 13, memory_order_acquire));
  if (result)
  {
    uint64_t v5 = result;
    *(void *)&long long v6 = -1;
    *((void *)&v6 + 1) = -1;
    *(_OWORD *)&v16.tdouble x = v6;
    *(_OWORD *)&v16.c = v6;
    *(_OWORD *)&v16.double a = v6;
    id v15 = a2;
    CGContextGetCTM(&v16, a2);
    *(void *)&long long v7 = -1;
    *((void *)&v7 + 1) = -1;
    *(_OWORD *)&v14.c = v7;
    *(_OWORD *)&v14.tdouble x = v7;
    *(_OWORD *)&v14.double a = v7;
    *(_OWORD *)&v17.double a = xmmword_184B88D60;
    v17.c = 1.0;
    memset(&v17.d, 0, 24);
    CGAffineTransformInvert(&v14, &v17);
    *(_OWORD *)&transform.double a = xmmword_184B88D60;
    transform.c = 1.0;
    memset(&transform.d, 0, 24);
    CGContextConcatCTM(a2, &transform);
    if (v5 >= 1)
    {
      uint64_t v8 = 0;
      for (CFIndex i = 0; i != v5; ++i)
      {
        uint64_t v10 = (TLine *)*((void *)TFrame::GetLineAtIndex(this, i) + 5);
        CFIndex v11 = (double *)(this[14] + v8);
        double v12 = v11[1] + *((double *)this + 7);
        CGContextSetTextPosition(a2, v14.tx + v12 * v14.c + v14.a * (*v11 + *((double *)this + 6)), v14.ty + v12 * v14.d + v14.b * (*v11 + *((double *)this + 6)));
        TLine::DrawGlyphs(v10, a2);
        v8 += 16;
      }
    }
    CGAffineTransform v17 = v16;
    return CGContextSetCTM();
  }
  return result;
}

void TextEncapsulationData::TextEncapsulationData(TextEncapsulationData *this, const __CFDictionary *a2)
{
  *(_DWORD *)this = 65537;
  *((void *)this + 1) = 0;
  CFArrayRef v4 = (double *)((char *)this + 8);
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0x3FF0000000000000;
  *((_WORD *)this + 20) = 400;
  *((void *)this + 6) = 0x3FF0000000000000;
  CFTypeID TypeID = CFNumberGetTypeID();
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a2, @"CTTextEncapsulationScale");
  if (Value && (CFStringRef v7 = Value, CFGetTypeID(Value) == TypeID))
  {
    int valuePtr = -1431655766;
    CFTypeID v8 = CFGetTypeID(v7);
    if (v8 == CFNumberGetTypeID() || v8 == CFBooleanGetTypeID())
    {
      CFNumberGetValue((CFNumberRef)v7, kCFNumberIntType, &valuePtr);
      IntCFStringRef Value = valuePtr;
    }
    else
    {
      if (v8 != CFStringGetTypeID()) {
        goto LABEL_9;
      }
      IntCFStringRef Value = CFStringGetIntValue(v7);
      int valuePtr = IntValue;
    }
    if (IntValue <= 2) {
      *(unsigned char *)this = IntValue;
    }
  }
  else
  {
    int valuePtr = -1431655766;
  }
LABEL_9:
  CFStringRef v10 = (const __CFString *)CFDictionaryGetValue(a2, @"CTTextEncapsulationPlatterSize");
  if (v10)
  {
    CFStringRef v11 = v10;
    if (CFGetTypeID(v10) == TypeID)
    {
      CFTypeID v12 = CFGetTypeID(v11);
      if (v12 == CFNumberGetTypeID() || v12 == CFBooleanGetTypeID())
      {
        CFNumberGetValue((CFNumberRef)v11, kCFNumberIntType, &valuePtr);
        unsigned int v13 = valuePtr;
      }
      else
      {
        if (v12 != CFStringGetTypeID()) {
          goto LABEL_20;
        }
        unsigned int v13 = CFStringGetIntValue(v11);
        int valuePtr = v13;
      }
      if (v13 <= 1) {
        *((unsigned char *)this + 1) = v13;
      }
    }
  }
LABEL_20:
  CFStringRef v14 = (const __CFString *)CFDictionaryGetValue(a2, @"CTTextEncapsulationShape");
  if (v14)
  {
    CFStringRef v15 = v14;
    if (CFGetTypeID(v14) == TypeID)
    {
      CFTypeID v16 = CFGetTypeID(v15);
      if (v16 == CFNumberGetTypeID() || v16 == CFBooleanGetTypeID())
      {
        CFNumberGetValue((CFNumberRef)v15, kCFNumberIntType, &valuePtr);
        unsigned int v17 = valuePtr;
      }
      else
      {
        if (v16 != CFStringGetTypeID()) {
          goto LABEL_29;
        }
        unsigned int v17 = CFStringGetIntValue(v15);
        int valuePtr = v17;
      }
      if (v17 <= 2) {
        *((unsigned char *)this + 2) = v17;
      }
    }
  }
LABEL_29:
  CFStringRef v18 = (const __CFString *)CFDictionaryGetValue(a2, @"CTTextEncapsulationStyle");
  if (v18)
  {
    CFStringRef v19 = v18;
    if (CFGetTypeID(v18) == TypeID)
    {
      CFTypeID v20 = CFGetTypeID(v19);
      if (v20 == CFNumberGetTypeID() || v20 == CFBooleanGetTypeID())
      {
        CFNumberGetValue((CFNumberRef)v19, kCFNumberIntType, &valuePtr);
        unsigned int v21 = valuePtr;
      }
      else
      {
        if (v20 != CFStringGetTypeID()) {
          goto LABEL_38;
        }
        unsigned int v21 = CFStringGetIntValue(v19);
        int valuePtr = v21;
      }
      if (v21 <= 1) {
        *((unsigned char *)this + 3) = v21;
      }
    }
  }
LABEL_38:
  CFStringRef v22 = (const __CFString *)CFDictionaryGetValue(a2, @"CTTextEncapsulationLineWidth");
  if (v22 && (CFStringRef v23 = v22, CFGetTypeID(v22) == TypeID))
  {
    double v26 = NAN;
    CFTypeID v24 = CFGetTypeID(v23);
    if (v24 == CFNumberGetTypeID() || v24 == CFBooleanGetTypeID())
    {
      CFNumberGetValue((CFNumberRef)v23, kCFNumberDoubleType, &v26);
      DoubleCFStringRef Value = v26;
    }
    else
    {
      if (v24 != CFStringGetTypeID()) {
        goto LABEL_45;
      }
      DoubleCFStringRef Value = CFStringGetDoubleValue(v23);
      double v26 = DoubleValue;
    }
    *CFArrayRef v4 = DoubleValue;
  }
  else
  {
    double v26 = NAN;
  }
LABEL_45:
  *((void *)this + 3) = CFDictionaryGetValue(a2, @"CTTextEncapsulationEnclosureColor");
}

void TextEncapsulationData::TextEncapsulationData(TextEncapsulationData *this, NSTextEncapsulation *a2)
{
  *(_DWORD *)this = 65537;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0x3FF0000000000000;
  *((_WORD *)this + 20) = 400;
  *((void *)this + 6) = 0x3FF0000000000000;
  unint64_t v4 = [(NSTextEncapsulation *)a2 scale];
  if (v4 <= 2) {
    *(unsigned char *)this = 0x20001u >> (8 * v4);
  }
  unint64_t v5 = [(NSTextEncapsulation *)a2 platterSize];
  if (v5)
  {
    if (v5 != 1) {
      goto LABEL_8;
    }
    char v6 = 1;
  }
  else
  {
    char v6 = 0;
  }
  *((unsigned char *)this + 1) = v6;
LABEL_8:
  unint64_t v7 = [(NSTextEncapsulation *)a2 shape];
  if (v7 <= 2) {
    *((unsigned char *)this + 2) = 0x20001u >> (8 * v7);
  }
  unint64_t v8 = [(NSTextEncapsulation *)a2 style];
  if (!v8)
  {
    char v9 = 0;
    goto LABEL_14;
  }
  if (v8 == 1)
  {
    char v9 = 1;
LABEL_14:
    *((unsigned char *)this + 3) = v9;
  }
  [(NSTextEncapsulation *)a2 lineWeight];
  *((void *)this + 1) = v10;
  *((void *)this + 3) = [(NSTextEncapsulation *)a2 color];
  [(NSTextEncapsulation *)a2 minimumWidth];
  *((void *)this + 2) = v11;
}

CFTypeID CTRunGetTypeID(void)
{
  if (TCFBase<TRun>::GetTypeID(void)::once != -1) {
    dispatch_once_f(&TCFBase<TRun>::GetTypeID(void)::once, 0, (dispatch_function_t)TCFBase<TRun>::GetTypeID(void)::{lambda(void *)#1}::__invoke);
  }
  return TCFBase<TRun>::fTypeID;
}

uint64_t CTRunGetScript(uint64_t result)
{
  if (result) {
    return ScriptTagForScriptCode(*(_DWORD *)(*(void *)(result + 40) + 304));
  }
  return result;
}

const CGGlyph *__cdecl CTRunGetGlyphsPtr(const CGGlyph *run)
{
  if (run)
  {
    uint64_t v1 = *((void *)run + 5);
    if ((*(unsigned char *)(v1 + 225) & 8) != 0) {
      return 0;
    }
    else {
      return (const CGGlyph *)(*(void *)(*(void *)(v1 + 216) + 16) + 2 * *(void *)(v1 + 200));
    }
  }
  return run;
}

const CGSize *__cdecl CTRunGetAdvancesPtr(const CGSize *run)
{
  if (run)
  {
    CGFloat height = run[2].height;
    if ((*(unsigned char *)(*(void *)&height + 225) & 0x18) != 0) {
      return 0;
    }
    uint64_t v2 = *(void *)(*(void *)&height + 216);
    uint64_t v3 = *(void *)(v2 + 32);
    if (!v3 && *(void *)(v2 + 24)) {
      return 0;
    }
    else {
      return (const CGSize *)(v3 + 16 * *(void *)(*(void *)&height + 200));
    }
  }
  return run;
}

const CGPoint *__cdecl CTRunGetPositionsPtr(CTRunRef run)
{
  if (!run) {
    return 0;
  }
  uint64_t v1 = (__n128 *)*((void *)run + 5);
  if ((v1[14].n128_u8[1] & 8) != 0) {
    return 0;
  }
  TRun::GetPositions(v1, 0);
  return result;
}

const CFIndex *__cdecl CTRunGetStringIndicesPtr(const CFIndex *run)
{
  if (run)
  {
    CFIndex v1 = run[5];
    if ((*(unsigned char *)(v1 + 225) & 8) != 0) {
      return 0;
    }
    else {
      return (const CFIndex *)(*(void *)(*(void *)(v1 + 216) + 48) + 8 * *(void *)(v1 + 200));
    }
  }
  return run;
}

void CTRunGetMetrics(uint64_t a1, double *a2, double *a3, double *a4)
{
  if (a1)
  {
    uint64_t v6 = *(void *)(a1 + 40);
    if (a2) {
      *a2 = (*(double (**)(void))(*(void *)v6 + 56))(*(void *)(a1 + 40));
    }
    if (a3) {
      *a3 = (*(double (**)(uint64_t))(*(void *)v6 + 64))(v6);
    }
    if (a4) {
      *a4 = (*(double (**)(uint64_t))(*(void *)v6 + 72))(v6);
    }
  }
}

CGRect CTRunGetImageBounds(CTRunRef run, CGContextRef context, CFRange range)
{
  if (!run) {
    goto LABEL_56;
  }
  locatiouint64_t n = range.location;
  uint64_t v5 = *((void *)run + 5);
  if ((*(unsigned char *)(v5 + 225) & 8) != 0)
  {
    uint64_t v7 = *(void *)(v5 + 264);
    uint64_t v8 = *(void *)(*(void *)(v5 + 216) + 16);
    uint64_t v9 = *(void *)(v5 + 200);
    uint64_t v6 = *(void *)(v5 + 208);
    if (v6 < 1 || range.location < 1)
    {
      locatiouint64_t n = 0;
    }
    else
    {
      CFIndex v11 = range.location;
      locatiouint64_t n = 0;
      do
      {
        uint64_t v13 = v7 == location || *(__int16 *)(v8 + 2 * v9 + 2 * location) != -1;
        if (++location >= v6) {
          break;
        }
        v11 -= v13;
      }
      while (v11);
    }
    if (range.length)
    {
      CFIndex v14 = 0;
      if (v6 > location && range.length >= 1)
      {
        CFIndex v14 = 0;
        CFIndex v15 = v7 - location;
        CFIndex v16 = v8 + 2 * location + 2 * v9;
        do
        {
          uint64_t v18 = v15 == v14 || *(__int16 *)(v16 + 2 * v14) != -1;
          uint64_t v19 = location + 1 + v14++;
          if (v19 >= v6) {
            break;
          }
          range.length -= v18;
        }
        while (range.length);
      }
    }
    else
    {
      CFIndex v14 = v6 - location;
    }
    range.CFIndex length = v14;
  }
  else
  {
    uint64_t v6 = *(void *)(v5 + 208);
  }
  if (location < 0 || location + range.length > v6) {
    goto LABEL_56;
  }
  CFIndex v20 = v6 - location;
  if (range.length) {
    CFIndex length = range.length;
  }
  else {
    CFIndex length = v20;
  }
  if (!length)
  {
    uint64_t v40 = (double *)MEMORY[0x1E4F1DB28];
LABEL_54:
    double x = *v40;
    CGFloat y = v40[1];
    CGFloat width = v40[2];
    CGFloat height = v40[3];
    goto LABEL_55;
  }
  uint64_t v22 = *(void *)(v5 + 312);
  CFStringRef v23 = (double *)MEMORY[0x1E4F1DB30];
  if (!v22) {
    uint64_t v22 = MEMORY[0x1E4F1DB30];
  }
  double v24 = *(double *)v22;
  uint64_t v45 = *(void *)(v22 + 8);
  double v46 = v24;
  if (!dyld_program_sdk_at_least()) {
    goto LABEL_51;
  }
  uint64_t v25 = *(void *)(v5 + 272);
  if (!v25)
  {
LABEL_56:
    uint64_t v40 = (double *)MEMORY[0x1E4F1DB20];
    goto LABEL_54;
  }
  TLine::GetLeftHangersGlyphCountAndWidth(*(TLine **)(v5 + 272), 0);
  if (v26 != 0.0)
  {
    double v24 = v24 - v26;
    double v46 = v24;
  }
  uint64_t v27 = *(void *)(v25 + 16);
  uint64_t v28 = *(void *)(v25 + 24);
  while (v27 != v28)
  {
    uint64_t v29 = *(void *)(*(void *)v27 + 40);
    if (v29 == v5) {
      break;
    }
    double v30 = *(double *)(v29 + 192);
    uint64_t v31 = *(double **)(v29 + 312);
    if (!v31) {
      uint64_t v31 = v23;
    }
    double v24 = v24 + v30 + *v31;
    double v46 = v24;
    v27 += 8;
  }
LABEL_51:
  double x = (*(double (**)(uint64_t, CGContextRef, CFIndex, CFIndex, double *, uint64_t *))(*(void *)v5 + 104))(v5, context, location, length, &v46, &v45);
  CGFloat y = v33;
  CGFloat width = v35;
  CGFloat height = v37;
  if (context)
  {
    TextPositiouint64_t n = CGContextGetTextPosition(context);
    v47.origin.double x = x;
    v47.origin.CGFloat y = y;
    v47.size.CGFloat width = width;
    v47.size.CGFloat height = height;
    CGRect v48 = CGRectOffset(v47, TextPosition.x, TextPosition.y);
    double x = v48.origin.x;
    CGFloat y = v48.origin.y;
    CGFloat width = v48.size.width;
    CGFloat height = v48.size.height;
  }
LABEL_55:
  double v41 = x;
  double v42 = y;
  double v43 = width;
  double v44 = height;
  result.size.CGFloat height = v44;
  result.size.CGFloat width = v43;
  result.origin.CGFloat y = v42;
  result.origin.double x = v41;
  return result;
}

double CTRunGetBackgroundBounds(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1) {
    return *MEMORY[0x1E4F1DB20];
  }
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = *(void *)(v3 + 272);
  if (!v4) {
    return *MEMORY[0x1E4F1DB20];
  }
  uint64_t v5 = a2;
  if ((*(unsigned char *)(v3 + 225) & 8) != 0)
  {
    uint64_t v7 = *(void *)(v3 + 264);
    uint64_t v8 = *(void *)(*(void *)(v3 + 216) + 16);
    uint64_t v9 = *(void *)(v3 + 200);
    uint64_t v6 = *(void *)(v3 + 208);
    if (v6 < 1 || a2 < 1)
    {
      uint64_t v5 = 0;
    }
    else
    {
      uint64_t v11 = a2;
      uint64_t v5 = 0;
      do
      {
        uint64_t v13 = v7 == v5 || *(__int16 *)(v8 + 2 * v9 + 2 * v5) != -1;
        if (++v5 >= v6) {
          break;
        }
        v11 -= v13;
      }
      while (v11);
    }
    if (a3)
    {
      uint64_t v14 = 0;
      if (v6 > v5 && a3 >= 1)
      {
        uint64_t v14 = 0;
        uint64_t v15 = v7 - v5;
        uint64_t v16 = v8 + 2 * v5 + 2 * v9;
        do
        {
          uint64_t v18 = v15 == v14 || *(__int16 *)(v16 + 2 * v14) != -1;
          uint64_t v19 = v5 + 1 + v14++;
          if (v19 >= v6) {
            break;
          }
          a3 -= v18;
        }
        while (a3);
      }
    }
    else
    {
      uint64_t v14 = v6 - v5;
    }
    a3 = v14;
  }
  else
  {
    uint64_t v6 = *(void *)(v3 + 208);
  }
  if (v5 < 0 || v5 + a3 > v6) {
    return *MEMORY[0x1E4F1DB20];
  }
  uint64_t v20 = v6 - v5;
  if (a3) {
    uint64_t v21 = a3;
  }
  else {
    uint64_t v21 = v20;
  }
  uint64_t v22 = *(double **)(v3 + 312);
  CFStringRef v23 = (double *)MEMORY[0x1E4F1DB30];
  if (!v22) {
    uint64_t v22 = (double *)MEMORY[0x1E4F1DB30];
  }
  double v24 = *v22;
  TLine::GetLeftHangersGlyphCountAndWidth(*(TLine **)(v3 + 272), 0);
  double v26 = v25;
  if (v25 == 0.0) {
    double v26 = 0.0;
  }
  double v27 = v24 - v26;
  for (uint64_t i = *(void *)(v4 + 16); i != *(void *)(v4 + 24); i += 8)
  {
    uint64_t v29 = *(void *)(*(void *)i + 40);
    if (v29 == v3) {
      break;
    }
    double v30 = *(double *)(v29 + 192);
    uint64_t v31 = *(double **)(v29 + 312);
    if (!v31) {
      uint64_t v31 = v23;
    }
    double v27 = v27 + v30 + *v31;
  }
  uint64_t v32 = *(void *)(v3 + 216);
  uint64_t v33 = *(void *)(v32 + 32);
  if (v33 || (uint64_t v36 = *(void *)(v32 + 24)) == 0)
  {
    int v34 = 0;
    double v35 = (double *)(v33 + 16 * *(void *)(v3 + 200));
  }
  else
  {
    double v35 = (double *)(v36 + 8 * *(void *)(v3 + 200));
    int v34 = 1;
  }
  if (v5 >= 1)
  {
    double v37 = v35;
    uint64_t v38 = v35;
    uint64_t v39 = v5;
    do
    {
      if (v34) {
        uint64_t v40 = v37;
      }
      else {
        uint64_t v40 = v38;
      }
      double v27 = v27 + *v40;
      v38 += 2;
      ++v37;
      --v39;
    }
    while (v39);
  }
  double v41 = *(int **)(atomic_load_explicit((atomic_ullong *volatile)(v3 + 56), memory_order_acquire) + 40);
  double v50 = NAN;
  double v51 = NAN;
  if ((*(_WORD *)(v4 + 154) & 0x100) != 0)
  {
    initedouble d = v41 + 12;
    if (!v41[12]) {
      initedouble d = TFont::InitStrikeMetrics((TFont *)v41);
    }
    double v51 = *((double *)inited + 1);
    if (!v41[12]) {
      TFont::InitStrikeMetrics((TFont *)v41);
    }
  }
  else
  {
    TFont::GetDefaultMetrics((TFont *)v41, &v51, &v50, &v49);
    TFont::GetWindowsDescent((uint64_t)v41);
  }
  TRun::GetCrossStreamMinMax((TRun *)v3);
  if (v21 >= 1)
  {
    uint64_t v43 = v21 + v5;
    double v44 = &v35[2 * v5];
    double v45 = 0.0;
    double v46 = &v35[v5];
    do
    {
      if (v34) {
        CGRect v47 = v46;
      }
      else {
        CGRect v47 = v44;
      }
      double v45 = v45 + *v47;
      ++v5;
      v44 += 2;
      ++v46;
    }
    while (v5 < v43);
  }
  return v27;
}

void CTRunDrawWithAttributeOverrides(uint64_t a1, CGContext *a2, uint64_t a3, uint64_t a4, const __CFDictionary *a5)
{
  if (a1)
  {
    CFIndex v6 = a3;
    uint64_t v8 = *(__n128 **)(a1 + 40);
    if ((v8[14].n128_u8[1] & 8) != 0)
    {
      unint64_t v10 = v8[16].n128_u64[1];
      uint64_t v11 = *(void *)(v8[13].n128_u64[1] + 16);
      unint64_t v12 = v8[12].n128_u64[1];
      uint64_t v9 = v8[13].n128_i64[0];
      if (v9 < 1 || a3 < 1)
      {
        CFIndex v6 = 0;
      }
      else
      {
        uint64_t v14 = a3;
        CFIndex v6 = 0;
        do
        {
          uint64_t v16 = v10 == v6 || *(__int16 *)(v11 + 2 * v12 + 2 * v6) != -1;
          if (++v6 >= v9) {
            break;
          }
          v14 -= v16;
        }
        while (v14);
      }
      if (a4)
      {
        uint64_t v17 = 0;
        if (v9 > v6 && a4 >= 1)
        {
          uint64_t v17 = 0;
          unint64_t v18 = v10 - v6;
          CFIndex v19 = v11 + 2 * v6 + 2 * v12;
          do
          {
            uint64_t v21 = v18 == v17 || *(__int16 *)(v19 + 2 * v17) != -1;
            uint64_t v22 = v6 + 1 + v17++;
            if (v22 >= v9) {
              break;
            }
            a4 -= v21;
          }
          while (a4);
        }
      }
      else
      {
        uint64_t v17 = v9 - v6;
      }
      a4 = v17;
    }
    else
    {
      uint64_t v9 = v8[13].n128_i64[0];
    }
    if ((v6 & 0x8000000000000000) == 0 && v6 + a4 <= v9)
    {
      uint64_t v23 = v9 - v6;
      CFIndex v24 = a4 ? a4 : v23;
      __n128 Positions = TRun::GetPositions((__n128 *)*(void *)(a1 + 40), 0);
      if (v25)
      {
        uint64_t v27 = v25;
        if (a5)
        {
          memset(v38, 170, sizeof(v38));
          long long v34 = unk_184B88DA0;
          long long v36 = unk_184B88DC0;
          long long v37 = xmmword_184B88DD0;
          long long v35 = xmmword_184B88DB0;
          memset(v33, 170, sizeof(v33));
          TAttributes::TAttributes((TAttributes *)v33, (const TAttributes *)&v8[2].n128_i8[8], a5);
          unint64_t v30 = 0xAAAAAAAAAAAAAA01;
          uint64_t v31 = v33;
          unint64_t v32 = 0xAAAAAAAAAAAAAA00;
          (*(void (**)(__n128 *, CGContext *, CFIndex, CFIndex, uint64_t, unint64_t *))(v8->n128_u64[0] + 40))(v8, a2, v6, v24, v27, &v30);
          TAttributes::~TAttributes((TAttributes *)v33);
        }
        else
        {
          v33[0] = 0xAAAAAAAAAAAAAA01;
          *(void *)&v33[1] = 0xAAAAAAAAAAAAAA00;
          (*(void (**)(__n128 *, CGContext *, CFIndex, CFIndex, uint64_t, _OWORD *, __n128))(v8->n128_u64[0] + 40))(v8, a2, v6, v24, v25, v33, Positions);
          if ((dyld_program_sdk_at_least() & 1) == 0)
          {
            TextPositiouint64_t n = CGContextGetTextPosition(a2);
            unsigned __int8 v29 = v8[11].n128_u8[1];
            if ((v29 & 4) != 0)
            {
              LODWORD(v30) = 0;
              uint64_t v31 = 0;
              long long v34 = unk_184BA61F0;
              long long v35 = xmmword_184BA6200;
              *(void *)&long long v36 = -1;
              v33[0] = __const__ZN10TDecorator14DrawDecorationEP9CGContextRK4TRun7CFRange7CGPoint_c;
              memset(&v33[1], 255, 32);
              TLineDrawContext::TLineDrawContext((TLineDrawContext *)v33, a2);
              v39.locatiouint64_t n = v6;
              v39.CFIndex length = v24;
              TDecorator::DrawDecoration((TDecorator *)&v30, (const TLineDrawContext *)v33, v8, v39, TextPosition);
              unsigned __int8 v29 = v8[11].n128_u8[1];
            }
            if ((v29 & 0x10) != 0)
            {
              LODWORD(v30) = 1;
              uint64_t v31 = 0;
              long long v34 = unk_184BA61F0;
              long long v35 = xmmword_184BA6200;
              *(void *)&long long v36 = -1;
              v33[0] = __const__ZN10TDecorator14DrawDecorationEP9CGContextRK4TRun7CFRange7CGPoint_c;
              memset(&v33[1], 255, 32);
              TLineDrawContext::TLineDrawContext((TLineDrawContext *)v33, a2);
              v40.locatiouint64_t n = v6;
              v40.CFIndex length = v24;
              TDecorator::DrawDecoration((TDecorator *)&v30, (const TLineDrawContext *)v33, v8, v40, TextPosition);
            }
          }
        }
      }
    }
  }
}

void CTRunDraw(CTRunRef run, CGContextRef context, CFRange range)
{
}

void CTRunDrawDecorations(uint64_t a1, CGContextRef c, uint64_t a3, uint64_t a4)
{
  if (a1)
  {
    CFIndex v4 = a3;
    CFIndex v6 = *(__n128 **)(a1 + 40);
    if ((v6[14].n128_u8[1] & 8) != 0)
    {
      unint64_t v8 = v6[16].n128_u64[1];
      uint64_t v9 = *(void *)(v6[13].n128_u64[1] + 16);
      unint64_t v10 = v6[12].n128_u64[1];
      uint64_t v7 = v6[13].n128_i64[0];
      if (v7 < 1 || a3 < 1)
      {
        CFIndex v4 = 0;
      }
      else
      {
        uint64_t v12 = a3;
        CFIndex v4 = 0;
        do
        {
          uint64_t v14 = v8 == v4 || *(__int16 *)(v9 + 2 * v10 + 2 * v4) != -1;
          if (++v4 >= v7) {
            break;
          }
          v12 -= v14;
        }
        while (v12);
      }
      if (a4)
      {
        uint64_t v15 = 0;
        if (v7 > v4 && a4 >= 1)
        {
          uint64_t v15 = 0;
          unint64_t v16 = v8 - v4;
          CFIndex v17 = v9 + 2 * v4 + 2 * v10;
          do
          {
            uint64_t v19 = v16 == v15 || *(__int16 *)(v17 + 2 * v15) != -1;
            uint64_t v20 = v4 + 1 + v15++;
            if (v20 >= v7) {
              break;
            }
            a4 -= v19;
          }
          while (a4);
        }
      }
      else
      {
        uint64_t v15 = v7 - v4;
      }
      a4 = v15;
    }
    else
    {
      uint64_t v7 = v6[13].n128_i64[0];
    }
    if ((v4 & 0x8000000000000000) == 0 && v4 + a4 <= v7)
    {
      CFIndex v21 = v7 - v4;
      if (a4) {
        CFIndex v22 = a4;
      }
      else {
        CFIndex v22 = v21;
      }
      TextPositiouint64_t n = CGContextGetTextPosition(c);
      unsigned __int8 v24 = v6[11].n128_u8[1];
      if ((v24 & 4) != 0)
      {
        int v25 = 0;
        uint64_t v26 = 0;
        long long v29 = xmmword_184BA61E0;
        long long v30 = unk_184BA61F0;
        long long v31 = xmmword_184BA6200;
        uint64_t v32 = -1;
        long long v27 = __const__ZN10TDecorator14DrawDecorationEP9CGContextRK4TRun7CFRange7CGPoint_c;
        long long v28 = unk_184BA61D0;
        TLineDrawContext::TLineDrawContext((TLineDrawContext *)&v27, c);
        v33.locatiouint64_t n = v4;
        v33.CFIndex length = v22;
        TDecorator::DrawDecoration((TDecorator *)&v25, (const TLineDrawContext *)&v27, v6, v33, TextPosition);
        unsigned __int8 v24 = v6[11].n128_u8[1];
      }
      if ((v24 & 0x10) != 0)
      {
        int v25 = 1;
        uint64_t v26 = 0;
        long long v29 = xmmword_184BA61E0;
        long long v30 = unk_184BA61F0;
        long long v31 = xmmword_184BA6200;
        uint64_t v32 = -1;
        long long v27 = __const__ZN10TDecorator14DrawDecorationEP9CGContextRK4TRun7CFRange7CGPoint_c;
        long long v28 = unk_184BA61D0;
        TLineDrawContext::TLineDrawContext((TLineDrawContext *)&v27, c);
        v34.locatiouint64_t n = v4;
        v34.CFIndex length = v22;
        TDecorator::DrawDecoration((TDecorator *)&v25, (const TLineDrawContext *)&v27, v6, v34, TextPosition);
      }
    }
  }
}

void *CTRunGetAttachmentCounts(void *result, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (result)
  {
    CFIndex v4 = a4;
    if (a4)
    {
      uint64_t v5 = a2;
      uint64_t v6 = result[5];
      if ((*(unsigned char *)(v6 + 225) & 8) != 0)
      {
        uint64_t v10 = *(void *)(v6 + 264);
        v19[0] = &unk_1ED05D698;
        v19[1] = a4;
        _OWORD v19[2] = v6 + 192;
        uint64_t v20 = v19;
        uint64_t v11 = *(void *)(v6 + 208);
        uint64_t v12 = *(void *)(*(void *)(v6 + 216) + 16) + 2 * *(void *)(v6 + 200);
        if (a3) {
          uint64_t v13 = a3;
        }
        else {
          uint64_t v13 = v11;
        }
        uint64_t v14 = 0;
        if (v11 >= 1 && a2 >= 1)
        {
          uint64_t v16 = 0;
          do
          {
            if (v10 == v14 || *(__int16 *)(v12 + 2 * v14) != -1) {
              ++v16;
            }
            ++v14;
          }
          while (v14 < v11 && v16 < a2);
        }
        if (v14 < v11 && v13 >= 1)
        {
          uint64_t v18 = 0;
          do
          {
            if (v10 == v14 || *(unsigned __int16 *)(v12 + 2 * v14) != 0xFFFF) {
              std::function<void ()(long,long)>::operator()((uint64_t)v20, v14, v18++);
            }
            ++v14;
          }
          while (v14 < v11 && v18 < v13);
        }
        return std::__function::__value_func<void ()(long,long)>::~__value_func[abi:nn180100](v19);
      }
      else if ((a2 & 0x8000000000000000) == 0)
      {
        uint64_t v7 = *(void *)(v6 + 208);
        if (a2 + a3 <= v7)
        {
          uint64_t v8 = v7 - a2;
          if (a3) {
            uint64_t v9 = a3;
          }
          else {
            uint64_t v9 = v8;
          }
          if (v9 >= 1)
          {
            do
            {
              CGRect result = (void *)[*(id *)(v6 + 216) attachmentCountAtIndex:v5 + *(void *)(v6 + 200)];
              *v4++ = result;
              ++v5;
              --v9;
            }
            while (v9);
          }
        }
      }
    }
  }
  return result;
}

uint64_t CTRunGetAttachmentCountsPtr(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 40);
    if ((*(unsigned char *)(v1 + 225) & 2) != 0) {
      return *(void *)(*(void *)(v1 + 216) + 56);
    }
    else {
      return 0;
    }
  }
  return result;
}

double CTRunSyncWithStorage(uint64_t a1)
{
  if (a1) {
    return TStorageRange::SyncWithStorage((TStorageRange *)(*(void *)(a1 + 48) + 192));
  }
  return result;
}

CGAffineTransform *__cdecl CTRunGetTextMatrix(CGAffineTransform *__return_ptr retstr, CGAffineTransform *run)
{
  uint64_t v2 = (_OWORD *)MEMORY[0x1E4F1DAB8];
  if (run)
  {
    tCGFloat y = run->ty;
    if (*(unsigned char *)(*(void *)&ty + 144)) {
      uint64_t v2 = (_OWORD *)(*(void *)&ty + 96);
    }
  }
  long long v4 = v2[1];
  *(_OWORD *)&retstr->double a = *v2;
  *(_OWORD *)&retstr->c = v4;
  *(_OWORD *)&retstr->tdouble x = v2[2];
  return run;
}

unint64_t CTRunCopyRubyAnnotationLineForPosition(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  (*(void (**)(id *__return_ptr))(**(void **)(a1 + 40) + 136))(&v3);
  unint64_t v1 = atomic_exchange((atomic_ullong *volatile)&v3, 0);

  return v1;
}

unint64_t CTRunCopyEncapsulationPath(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  (*(void (**)(id *__return_ptr))(**(void **)(a1 + 40) + 128))(&v3);
  unint64_t v1 = atomic_exchange((atomic_ullong *volatile)&v3, 0);

  return v1;
}

void std::__function::__func<CTRunGetGlyphs::$_0,std::allocator<CTRunGetGlyphs::$_0>,void ()(long,long)>::~__func()
{
}

__n128 std::__function::__func<CTRunGetGlyphs::$_0,std::allocator<CTRunGetGlyphs::$_0>,void ()(long,long)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1ED05FC00;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<CTRunGetGlyphs::$_0,std::allocator<CTRunGetGlyphs::$_0>,void ()(long,long)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ED05FC00;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<CTRunGetGlyphs::$_0,std::allocator<CTRunGetGlyphs::$_0>,void ()(long,long)>::operator()(uint64_t result, void *a2, void *a3)
{
  *(_WORD *)(*(void *)(result + 8) + 2 * *a3) = *(_WORD *)(*(void *)(result + 16) + 2 * *a2);
  return result;
}

void std::__function::__func<CTRunGetAdvances::$_1,std::allocator<CTRunGetAdvances::$_1>,void ()(long,long)>::~__func()
{
}

__n128 std::__function::__func<CTRunGetAdvances::$_1,std::allocator<CTRunGetAdvances::$_1>,void ()(long,long)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_1ED05FC48;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 std::__function::__func<CTRunGetAdvances::$_1,std::allocator<CTRunGetAdvances::$_1>,void ()(long,long)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ED05FC48;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<CTRunGetPositions::$_0,std::allocator<CTRunGetPositions::$_0>,void ()(long,long)>::~__func()
{
}

__n128 std::__function::__func<CTRunGetPositions::$_0,std::allocator<CTRunGetPositions::$_0>,void ()(long,long)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1ED05FCD8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<CTRunGetPositions::$_0,std::allocator<CTRunGetPositions::$_0>,void ()(long,long)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ED05FCD8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<CTRunGetStringIndices::$_0,std::allocator<CTRunGetStringIndices::$_0>,void ()(long,long)>::~__func()
{
}

__n128 std::__function::__func<CTRunGetStringIndices::$_0,std::allocator<CTRunGetStringIndices::$_0>,void ()(long,long)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1ED05FDB0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<CTRunGetStringIndices::$_0,std::allocator<CTRunGetStringIndices::$_0>,void ()(long,long)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ED05FDB0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<CTRunGetAttachmentCounts::$_0,std::allocator<CTRunGetAttachmentCounts::$_0>,void ()(long,long)>::~__func()
{
}

__n128 std::__function::__func<CTRunGetAttachmentCounts::$_0,std::allocator<CTRunGetAttachmentCounts::$_0>,void ()(long,long)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1ED05D698;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<CTRunGetAttachmentCounts::$_0,std::allocator<CTRunGetAttachmentCounts::$_0>,void ()(long,long)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ED05D698;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<CTRunGetAttachmentCounts::$_0,std::allocator<CTRunGetAttachmentCounts::$_0>,void ()(long,long)>::operator()(uint64_t a1, void *a2, uint64_t *a3)
{
  uint64_t v4 = *a3;
  uint64_t result = [*(id *)(*(void *)(a1 + 16) + 24) attachmentCountAtIndex:*(void *)(*(void *)(a1 + 16) + 8) + *a2];
  *(void *)(*(void *)(a1 + 8) + 8 * v4) = result;
  return result;
}

void std::__function::__func<CTRunGetPropertiesPtr::$_0,std::allocator<CTRunGetPropertiesPtr::$_0>,void ()(long,long)>::~__func()
{
}

__n128 std::__function::__func<CTRunGetPropertiesPtr::$_0,std::allocator<CTRunGetPropertiesPtr::$_0>,void ()(long,long)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1ED05FD68;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<CTRunGetPropertiesPtr::$_0,std::allocator<CTRunGetPropertiesPtr::$_0>,void ()(long,long)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ED05FD68;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<CTRunGetPropertiesPtr::$_0,std::allocator<CTRunGetPropertiesPtr::$_0>,void ()(long,long)>::operator()(uint64_t result, void *a2, void *a3)
{
  *(_DWORD *)(*(void *)(result + 8) + 4 * *a3) = *(_DWORD *)(*(void *)(result + 16) + 4 * *a2);
  return result;
}

void std::__function::__func<CTRunGetStretchFactors::$_0,std::allocator<CTRunGetStretchFactors::$_0>,void ()(long,long)>::~__func()
{
}

__n128 std::__function::__func<CTRunGetStretchFactors::$_0,std::allocator<CTRunGetStretchFactors::$_0>,void ()(long,long)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1ED05D650;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<CTRunGetStretchFactors::$_0,std::allocator<CTRunGetStretchFactors::$_0>,void ()(long,long)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ED05D650;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<CTRunGetStretchFactors::$_0,std::allocator<CTRunGetStretchFactors::$_0>,void ()(long,long)>::operator()(uint64_t result, void *a2, void *a3)
{
  uint64_t v3 = *(void *)(*(void *)(result + 8) + 312);
  if (!v3 || (uint64_t v4 = *(void *)(v3 + 56), v4 == *(void *)(v3 + 64))) {
    long long v5 = kUnitSize;
  }
  else {
    long long v5 = *(_OWORD *)(v4 + 16 * *a2);
  }
  *(_OWORD *)(*(void *)(result + 16) + 16 * *a3) = v5;
  return result;
}

void std::__function::__func<CTRunGetBaseAdvancesAndOrigins::$_0,std::allocator<CTRunGetBaseAdvancesAndOrigins::$_0>,void ()(long,long)>::~__func()
{
}

__n128 std::__function::__func<CTRunGetBaseAdvancesAndOrigins::$_0,std::allocator<CTRunGetBaseAdvancesAndOrigins::$_0>,void ()(long,long)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v2 = &unk_1ED05FFF0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

__n128 std::__function::__func<CTRunGetBaseAdvancesAndOrigins::$_0,std::allocator<CTRunGetBaseAdvancesAndOrigins::$_0>,void ()(long,long)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ED05FFF0;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 4CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<CTRunGetBaseAdvancesAndOrigins::$_0,std::allocator<CTRunGetBaseAdvancesAndOrigins::$_0>,void ()(long,long)>::operator()(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = result;
  uint64_t v4 = *a2;
  uint64_t v5 = *a3;
  uint64_t v6 = *(void *)(result + 24);
  if (*(_DWORD *)(result + 16) == 1)
  {
    uint64_t v7 = (uint64_t *)(v6 + 8 * v4);
    uint64_t v8 = 0;
  }
  else
  {
    uint64_t v7 = (uint64_t *)(v6 + 16 * v4);
    uint64_t v8 = v7[1];
  }
  uint64_t v9 = *v7;
  uint64_t v10 = (void *)(*(void *)(result + 8) + 16 * v5);
  *uint64_t v10 = v9;
  v10[1] = v8;
  uint64_t v11 = *(void *)(result + 40);
  if ((*(unsigned char *)(v11 + 33) & 0x10) != 0)
  {
    __n128 result = [*(id *)(v11 + 24) originAtIndex:*(void *)(v11 + 8) + v4];
  }
  else
  {
    uint64_t v12 = *MEMORY[0x1E4F1DAD8];
    uint64_t v13 = *(void *)(MEMORY[0x1E4F1DAD8] + 8);
  }
  uint64_t v14 = (void *)(*(void *)(v3 + 32) + 16 * v5);
  *uint64_t v14 = v12;
  v14[1] = v13;
  return result;
}

void std::__function::__func<CTRunGetBaseAdvancesAndOrigins::$_1,std::allocator<CTRunGetBaseAdvancesAndOrigins::$_1>,void ()(long,long)>::~__func()
{
}

__n128 std::__function::__func<CTRunGetBaseAdvancesAndOrigins::$_1,std::allocator<CTRunGetBaseAdvancesAndOrigins::$_1>,void ()(long,long)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_1ED060038;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 std::__function::__func<CTRunGetBaseAdvancesAndOrigins::$_1,std::allocator<CTRunGetBaseAdvancesAndOrigins::$_1>,void ()(long,long)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ED060038;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<CTRunGetBaseAdvancesAndOrigins::$_1,std::allocator<CTRunGetBaseAdvancesAndOrigins::$_1>,void ()(long,long)>::operator()(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *a3;
  uint64_t v5 = *(void *)(a1 + 24);
  if (*(_DWORD *)(a1 + 16) == 1)
  {
    uint64_t v6 = (uint64_t *)(v5 + 8 * v3);
    uint64_t v7 = 0;
  }
  else
  {
    uint64_t v6 = (uint64_t *)(v5 + 16 * v3);
    uint64_t v7 = v6[1];
  }
  uint64_t v8 = *v6;
  uint64_t v9 = (void *)(*(void *)(a1 + 8) + 16 * v4);
  *uint64_t v9 = v8;
  v9[1] = v7;
  __n128 result = *(__n128 *)MEMORY[0x1E4F1DAD8];
  *(_OWORD *)(*(void *)(a1 + 32) + 16 * v4) = *MEMORY[0x1E4F1DAD8];
  return result;
}

void std::__function::__func<CTRunGetBaseAdvancesAndOrigins::$_2,std::allocator<CTRunGetBaseAdvancesAndOrigins::$_2>,void ()(long,long)>::~__func()
{
}

__n128 std::__function::__func<CTRunGetBaseAdvancesAndOrigins::$_2,std::allocator<CTRunGetBaseAdvancesAndOrigins::$_2>,void ()(long,long)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v2 = &unk_1ED060080;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

__n128 std::__function::__func<CTRunGetBaseAdvancesAndOrigins::$_2,std::allocator<CTRunGetBaseAdvancesAndOrigins::$_2>,void ()(long,long)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ED060080;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 4CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

CFTypeID CTFrameGetTypeID(void)
{
  if (TCFBase<TFrame>::GetTypeID(void)::once != -1) {
    dispatch_once_f(&TCFBase<TFrame>::GetTypeID(void)::once, 0, (dispatch_function_t)TCFBase<TFrame>::GetTypeID(void)::{lambda(void *)#1}::__invoke);
  }
  return TCFBase<TFrame>::fTypeID;
}

CFRange CTFrameGetStringRange(CTFrameRef frame)
{
  if (frame)
  {
    uint64_t v1 = *((void *)frame + 5);
    frame = *(CTFrameRef *)v1;
    CFIndex v2 = *(void *)(v1 + 8);
  }
  else
  {
    CFIndex v2 = 0;
  }
  result.CFIndex length = v2;
  result.locatiouint64_t n = (CFIndex)frame;
  return result;
}

CFRange CTFrameGetVisibleStringRange(CTFrameRef frame)
{
  if (frame)
  {
    uint64_t v1 = *((void *)frame + 5);
    frame = *(CTFrameRef *)(v1 + 16);
    CFIndex v2 = *(void *)(v1 + 24);
  }
  else
  {
    CFIndex v2 = 0;
  }
  result.CFIndex length = v2;
  result.locatiouint64_t n = (CFIndex)frame;
  return result;
}

unint64_t CTFrameCopyVisibleString(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  TFrame::CopyVisibleString(*(atomic_ullong **)(a1 + 40), &v3);
  unint64_t v1 = atomic_exchange((atomic_ullong *volatile)&v3, 0);

  return v1;
}

CGPathRef CTFrameGetPath(CGPathRef frame)
{
  if (frame) {
    return (CGPathRef)atomic_load_explicit((atomic_ullong *volatile)(*((void *)frame + 5) + 80), memory_order_acquire);
  }
  return frame;
}

CFDictionaryRef CTFrameGetFrameAttributes(CFDictionaryRef frame)
{
  if (frame) {
    return (CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)(*((void *)frame + 5) + 88), memory_order_acquire);
  }
  return frame;
}

void CTFrameDraw(CTFrameRef frame, CGContextRef context)
{
  if (frame)
  {
    if (context) {
      TFrame::DrawFrame(*((atomic_ullong **)frame + 5), context);
    }
  }
}

uint64_t TCFBase<TFrame>::ClassEqual(uint64_t a1, uint64_t a2)
{
  return TFrame::operator==(*(void *)(a1 + 40), *(atomic_ullong **)(a2 + 40));
}

void *TCFBase<TFrame>::ClassHash(void *result)
{
  unint64_t v1 = result[3];
  uint64_t v2 = result[4];
  if (v2) {
    BOOL v3 = (result[4] & 1 | v1) == 0;
  }
  else {
    BOOL v3 = 1;
  }
  int v4 = !v3;
  if (v1) {
    BOOL v5 = 0;
  }
  else {
    BOOL v5 = v4 == 0;
  }
  if (!v5)
  {
    uint64_t v6 = (void *)(result[5] + (v2 >> 1));
    if (v2) {
      return (void *)(*(uint64_t (**)(void))(*v6 + v1))();
    }
    else {
      return (void *)((uint64_t (*)(void *))v1)(v6);
    }
  }
  return result;
}

__CFString *TCFBase<TFrame>::ClassDebug(uint64_t a1)
{
  CFRange result = TFrame::DebugDescription(*(TFrame **)(a1 + 40));
  if (result)
  {
    BOOL v3 = result;
    CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<%s: %p>{%@}", "CTFrame", a1, result);
    CFRelease(v3);
    return (__CFString *)v4;
  }
  return result;
}

CFTypeID CTTypesetterGetTypeID(void)
{
  if (TCFBase<TTypesetter>::GetTypeID(void)::once != -1) {
    dispatch_once_f(&TCFBase<TTypesetter>::GetTypeID(void)::once, 0, (dispatch_function_t)TCFBase<TTypesetter>::GetTypeID(void)::{lambda(void *)#1}::__invoke);
  }
  return TCFBase<TTypesetter>::fTypeID;
}

CFIndex CTTypesetterSuggestClusterBreak(CTTypesetterRef typesetter, CFIndex startIndex, double width)
{
  return TypesetterSuggestClusterBreak(typesetter, startIndex, width, 0.0);
}

uint64_t TypesetterSuggestClusterBreak(const __CTTypesetter *a1, uint64_t a2, double a3, double a4)
{
  v7[4] = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  uint64_t v4 = *((void *)a1 + 5);
  v7[3] = 0;
  uint64_t v5 = TTypesetter::SuggestClusterBreak(v4, a2, (uint64_t)v7, a3, a4);
  std::__function::__value_func<unsigned char ()(long)>::~__value_func[abi:nn180100](v7);
  return v5;
}

unint64_t CTTypesetterCreateWithUniCharProvider(const unsigned __int16 *(*a1)(uint64_t, uint64_t *, const __CFDictionary **, void *), void (*a2)(const unsigned __int16 *, void *), void *a3)
{
  if (!a1) {
    return 0;
  }
  id v12 = (id)0xAAAAAAAAAAAAAAAALL;
  uint64_t v6 = TCFBase<TTypesetter>::Allocate();
  if (v6)
  {
    uint64_t v7 = (void *)v6;
    uint64_t v8 = (TTypesetterUniChar *)(v6 + 48);
    v7[2] = 0;
    v7[3] = 0;
    v7[4] = 0;
    void v7[5] = v8;
    TTypesetterUniChar::TTypesetterUniChar(v8, a1, a2, a3);
    id v13 = v7;
    id v11 = (id)atomic_exchange((atomic_ullong *volatile)&v13, 0);
  }
  else
  {
    id v11 = 0;
  }
  id v12 = (id)atomic_exchange((atomic_ullong *volatile)&v11, 0);

  unint64_t v9 = atomic_exchange((atomic_ullong *volatile)&v12, 0);
  return v9;
}

unint64_t CTTypesetterCreateWithUniCharProviderAndOptions(const unsigned __int16 *(*a1)(uint64_t, uint64_t *, const __CFDictionary **, void *), void (*a2)(const unsigned __int16 *, void *), void *a3, const __CFDictionary *a4)
{
  if (!a1) {
    return 0;
  }
  id v14 = (id)0xAAAAAAAAAAAAAAAALL;
  uint64_t v8 = TCFBase<TTypesetter>::Allocate();
  if (v8)
  {
    unint64_t v9 = (void *)v8;
    uint64_t v10 = (TTypesetterUniChar *)(v8 + 48);
    v9[2] = 0;
    v9[3] = 0;
    uint64_t v9[4] = 0;
    v9[5] = v10;
    TTypesetterUniChar::TTypesetterUniChar(v10, a1, a2, a3, a4);
    id v15 = v9;
    id v13 = (id)atomic_exchange((atomic_ullong *volatile)&v15, 0);
  }
  else
  {
    id v13 = 0;
  }
  id v14 = (id)atomic_exchange((atomic_ullong *volatile)&v13, 0);

  if (atomic_load_explicit((atomic_ullong *volatile)&v14, memory_order_acquire)
    && *(unsigned char *)(*(void *)(atomic_load_explicit((atomic_ullong *volatile)&v14, memory_order_acquire) + 40) + 257))
  {
    unint64_t v11 = 0;
  }
  else
  {
    unint64_t v11 = atomic_exchange((atomic_ullong *volatile)&v14, 0);
  }

  return v11;
}

unint64_t CTTypesetterCreateWithRunArrayAndOptions(const __CFArray *a1, const __CFString *a2, const void *(*a3)(const __CTRun *, const __CFString *, void *), void *a4, const __CFDictionary *a5)
{
  id v16 = (id)0xAAAAAAAAAAAAAAAALL;
  uint64_t v10 = TCFBase<TTypesetter>::Allocate();
  if (v10)
  {
    unint64_t v11 = (void *)v10;
    id v12 = (TTypesetter *)(v10 + 48);
    void v11[2] = 0;
    id v11[3] = 0;
    v11[4] = 0;
    void v11[5] = v12;
    TTypesetter::TTypesetter(v12, a1, a2, a3, a4, a5);
    id v17 = v11;
    id v15 = (id)atomic_exchange((atomic_ullong *volatile)&v17, 0);
  }
  else
  {
    id v15 = 0;
  }
  id v16 = (id)atomic_exchange((atomic_ullong *volatile)&v15, 0);

  if (atomic_load_explicit((atomic_ullong *volatile)&v16, memory_order_acquire)
    && *(unsigned char *)(*(void *)(atomic_load_explicit((atomic_ullong *volatile)&v16, memory_order_acquire) + 40) + 257))
  {
    unint64_t v13 = 0;
  }
  else
  {
    unint64_t v13 = atomic_exchange((atomic_ullong *volatile)&v16, 0);
  }

  return v13;
}

BOOL TCFBase<TTypesetter>::ClassEqual(uint64_t a1, uint64_t a2)
{
  return *(void *)(a1 + 40) == *(void *)(a2 + 40);
}

void *TCFBase<TTypesetter>::ClassHash(void *result)
{
  unint64_t v1 = result[3];
  uint64_t v2 = result[4];
  if (v2) {
    BOOL v3 = (result[4] & 1 | v1) == 0;
  }
  else {
    BOOL v3 = 1;
  }
  int v4 = !v3;
  if (v1) {
    BOOL v5 = 0;
  }
  else {
    BOOL v5 = v4 == 0;
  }
  if (!v5)
  {
    uint64_t v6 = (void *)(result[5] + (v2 >> 1));
    if (v2) {
      return (void *)(*(uint64_t (**)(void))(*v6 + v1))();
    }
    else {
      return (void *)((uint64_t (*)(void *))v1)(v6);
    }
  }
  return result;
}

uint64_t TCFBase<TTypesetter>::ClassDebug()
{
  return 0;
}

CFTypeID CTFramesetterGetTypeID(void)
{
  if (_MergedGlobals_8 != -1) {
    dispatch_once_f(&_MergedGlobals_8, 0, (dispatch_function_t)TCFBase<TFramesetter>::GetTypeID(void)::{lambda(void *)#1}::__invoke);
  }
  return qword_1EB2CDF08;
}

CTFramesetterRef CTFramesetterCreateWithTypesetter(CTTypesetterRef typesetter)
{
  CTTypesetterRef v1 = typesetter;
  if (typesetter)
  {
    id v6 = (id)0xAAAAAAAAAAAAAAAALL;
    uint64_t v2 = (void *)TCFBase<TFramesetter>::Allocate();
    if (v2)
    {
      BOOL v3 = v2;
      v2[2] = 0;
      v2[3] = 0;
      v2[4] = 0;
      v2[5] = v2 + 6;
      v2[6] = &unk_1ED05E5F0;
      v2[7] = v1;
      id v7 = v3;
      id v5 = (id)atomic_exchange((atomic_ullong *volatile)&v7, 0);
    }
    else
    {
      id v5 = 0;
    }
    id v6 = (id)atomic_exchange((atomic_ullong *volatile)&v5, 0);

    CTTypesetterRef v1 = (CTTypesetterRef)atomic_exchange((atomic_ullong *volatile)&v6, 0);
  }
  return v1;
}

unint64_t CTFramesetterCreateWithUniCharProvider(const unsigned __int16 *(*a1)(uint64_t, uint64_t *, const __CFDictionary **, void *), void (*a2)(const unsigned __int16 *, void *), void *a3)
{
  if (!a1) {
    return 0;
  }
  id v11 = (id)0xAAAAAAAAAAAAAAAALL;
  id v6 = (void *)TCFBase<TFramesetter>::Allocate();
  if (v6)
  {
    id v7 = v6;
    v6[2] = 0;
    CFIndex v6[3] = 0;
    v6[4] = 0;
    v6[5] = v6 + 6;
    v6[6] = &unk_1ED05E960;
    TTypesetterUniChar::TTypesetterUniChar((TTypesetterUniChar *)(v6 + 7), a1, a2, a3);
    id v12 = v7;
    id v10 = (id)atomic_exchange((atomic_ullong *volatile)&v12, 0);
  }
  else
  {
    id v10 = 0;
  }
  id v11 = (id)atomic_exchange((atomic_ullong *volatile)&v10, 0);

  unint64_t v8 = atomic_exchange((atomic_ullong *volatile)&v11, 0);
  return v8;
}

CTTypesetterRef CTFramesetterGetTypesetter(CTTypesetterRef framesetter)
{
  if (framesetter) {
    return (CTTypesetterRef)(*(uint64_t (**)(void))(**((void **)framesetter + 5) + 24))();
  }
  return framesetter;
}

BOOL TCFBase<TFramesetter>::ClassEqual(uint64_t a1, uint64_t a2)
{
  return *(void *)(a1 + 40) == *(void *)(a2 + 40);
}

void *TCFBase<TFramesetter>::ClassHash(void *result)
{
  unint64_t v1 = result[3];
  uint64_t v2 = result[4];
  if (v2) {
    BOOL v3 = (result[4] & 1 | v1) == 0;
  }
  else {
    BOOL v3 = 1;
  }
  int v4 = !v3;
  if (v1) {
    BOOL v5 = 0;
  }
  else {
    BOOL v5 = v4 == 0;
  }
  if (!v5)
  {
    id v6 = (void *)(result[5] + (v2 >> 1));
    if (v2) {
      return (void *)(*(uint64_t (**)(void))(*v6 + v1))();
    }
    else {
      return (void *)((uint64_t (*)(void *))v1)(v6);
    }
  }
  return result;
}

uint64_t TCFBase<TFramesetter>::ClassDebug()
{
  return 0;
}

void TFramesetter::FrameInPath(TFramesetter *this, TFrame *a2, CFRange a3)
{
  CFIndex length = a3.length;
  locatiouint64_t n = a3.location;
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  int v23 = *((_DWORD *)a2 + 36);
  uint64_t v6 = (*(uint64_t (**)(TFramesetter *))(*(void *)this + 16))(this);
  atomic_load_explicit((atomic_ullong *volatile)a2 + 10, memory_order_acquire);
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v29[11] = v7;
  v29[12] = v7;
  v29[9] = v7;
  v29[10] = v7;
  v29[7] = v7;
  v29[8] = v7;
  v29[5] = v7;
  v29[6] = v7;
  v29[3] = v7;
  v29[4] = v7;
  v29[1] = v7;
  v29[2] = v7;
  v29[0] = v7;
  TClippingPathInfo::TClippingPathInfo((TClippingPathInfo *)v29, (CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)a2 + 12, memory_order_acquire), v23 != 0);
  uint64_t v20 = *((void *)a2 + 7);
  uint64_t v21 = *((void *)a2 + 6);
  uint64_t v18 = *((void *)a2 + 9);
  uint64_t v19 = *((void *)a2 + 8);
  if (location) {
    BOOL IsParagraphSeparator = TCharStream::IsParagraphSeparator(*(TCharStream **)v6, location - 1);
  }
  else {
    BOOL IsParagraphSeparator = 1;
  }
  if (v23) {
    BOOL v8 = 1;
  }
  else {
    BOOL v8 = *((unsigned char *)a2 + 162) == 0;
  }
  int v9 = !v8;
  int v16 = v9;
  theArraCGFloat y = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  uint64_t v26 = 0;
  long long v27 = 0;
  uint64_t v28 = 0;
  id v25 = 0;
  uint64_t v11 = v20;
  uint64_t v10 = v21;
  uint64_t v13 = v18;
  uint64_t v12 = v19;
  if (v23) {
    CGRectGetWidth(*(CGRect *)&v10);
  }
  else {
    CGRectGetHeight(*(CGRect *)&v10);
  }
  if (length >= 1)
  {
    if (*(void *)(v6 + 24) != *(void *)(v6 + 16)) {
      TLine::FindRunWithCharIndex((TLine *)v6, location, 1);
    }
    TFramesetter::GetCharMetricsForLine((TFramesetter *)v24, (uint64_t)this, location, location, (const void *)1, IsParagraphSeparator, v16);
    v24[6] = v24[2];
    v24[7] = v24[1];
    v24[0] = v24[0] + v24[3];
    v24[8] = v24[0];
    operator new();
  }
  if (v23) {
    CFArrayRef explicit = 0;
  }
  else {
    CFArrayRef explicit = (void *)atomic_load_explicit((atomic_ullong *volatile)&v25, memory_order_acquire);
  }
  TFrame::SetLines((uint64_t)a2, theArray, (uint64_t)&v26, explicit, location, length, location, 0);

  if (v26)
  {
    long long v27 = v26;
    operator delete(v26);
  }

  TClippingPathInfo::~TClippingPathInfo((TClippingPathInfo *)v29);
}

TFramesetter::TPathFrameLinesetter *TFramesetter::TPathFrameLinesetter::TPathFrameLinesetter(TFramesetter::TPathFrameLinesetter *this, const TFramesetter *a2, const CGPath *a3, double a4, char a5, const TClippingPathInfo *a6, char a7, CGRect a8, double a9, double a10, CFRange a11, const TAttributes *a12, BOOL a13, BOOL a14, BOOL a15)
{
  *(void *)this = a2;
  *((void *)this + 1) = a3;
  *((double *)this + 2) = a4;
  *((unsigned char *)this + 24) = a5;
  *((void *)this + 4) = a6;
  *(CGRect *)((char *)this + 4CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = a8;
  *(CFRange *)((char *)this + 72) = a11;
  *((double *)this + 11) = a9;
  *((double *)this + 12) = a10;
  *((void *)this + 13) = a12;
  if (a12)
  {
    id v17 = (TParagraphStyle **)*((void *)a12 + 16);
    if (v17) {
      LOBYTE(v17) = TParagraphStyle::GetLineBreakMode(v17, a2);
    }
  }
  else
  {
    LOBYTE(v17) = 0;
  }
  *((unsigned char *)this + 112) = (_BYTE)v17;
  *((unsigned char *)this + 113) = a13;
  *((unsigned char *)this + 114) = a14;
  *((unsigned char *)this + 115) = a15;
  *((void *)this + 15) = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((unsigned char *)this + 16CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = 0;
  *((unsigned char *)this + 161) = a7;
  unsigned int v18 = *((unsigned __int8 *)this + 112);
  *((unsigned char *)this + 162) = v18 != 1;
  *((unsigned char *)this + 163) = v18 > 1;
  *((double *)this + 21) = TFramesetter::GetHeadIndent(*((TFramesetter **)this + 13), (const TAttributes *)*((unsigned __int8 *)this + 114));
  uint64_t v20 = *((void *)this + 13);
  double TailIndent = 0.0;
  if (v20)
  {
    CFIndex v22 = *(TParagraphStyle ***)(v20 + 128);
    if (v22) {
      double TailIndent = TParagraphStyle::GetTailIndent(v22, v19);
    }
  }
  *((double *)this + 22) = TailIndent;
  return this;
}

CFIndex TFramesetter::TPathFrameLinesetter::LayoutLines(uint64_t a1, uint64_t a2, unsigned char *a3, double *a4, void *a5, double *a6)
{
  uint64_t v104 = *MEMORY[0x1E4F143B8];
  *(double *)(a1 + 184) = *a4;
  int v9 = (double *)(a1 + 184);
  *a4 = 0.0;
  *a5 = 0;
  *a6 = 0.0;
  uint64_t v10 = *(void *)(a1 + 80);
  v93.locatiouint64_t n = *(void *)(a1 + 72);
  int v11 = *(unsigned __int8 *)(a1 + 115);
  uint64_t v12 = *(const void **)(a1 + 8);
  double v13 = *(v9 - 21);
  uint64_t v83 = v9;
  id v14 = (uint64_t *)*((void *)v9 - 19);
  BOOL v15 = *((unsigned char *)v9 - 160) != 0;
  if (v11) {
    RectArrayFromPathVertical = CreateRectArrayFromPathVertical((uint64_t)v12, v15, v14, v13, *(double *)(a1 + 40) + *(double *)(a1 + 96), *(double *)(a1 + 40) + *(double *)(a1 + 88));
  }
  else {
    RectArrayFromPathVertical = CreateRectArrayFromPath(v12, v15, v14, 0, v13, *(double *)(a1 + 48) + *(double *)(a1 + 88), *(double *)(a1 + 48) + *(double *)(a1 + 96));
  }
  CFArrayRef v17 = RectArrayFromPathVertical;
  CFArrayRef v18 = RectArrayFromPathVertical;
  if (!v18)
  {

    goto LABEL_88;
  }
  CFArrayRef v19 = v18;
  CFIndex Count = CFArrayGetCount(v18);

  if (!Count)
  {
LABEL_88:
    CFIndex v77 = 0;
    goto LABEL_91;
  }
  uint64_t v86 = a3;
  CFArrayRef v87 = v17;
  int v21 = 0;
  uint64_t v89 = (atomic_ullong *)(a1 + 120);
  uint64_t v22 = 1;
  uint64_t v79 = a2;
  while (1)
  {
    locatiouint64_t n = v93.location;
    std::__function::__value_func<unsigned char ()(long)>::__value_func[abi:nn180100]((uint64_t)v101, a2);
    double v24 = *(double *)(a1 + 176);
    double MaxY = CGRectGetMaxY(*(CGRect *)(a1 + 40));
    if (*(unsigned char *)(a1 + 115))
    {
      double v26 = MaxY - *(double *)(a1 + 168);
      if (v24 <= 0.0)
      {
        double v27 = CGRectGetMinY(*(CGRect *)(a1 + 40)) - v24;
        goto LABEL_22;
      }
    }
    else
    {
      if (v21) {
        double v28 = *(double *)(a1 + 168);
      }
      else {
        double v28 = v24;
      }
      if (v21) {
        double v26 = v24;
      }
      else {
        double v26 = *(double *)(a1 + 168);
      }
      if (v28 <= 0.0)
      {
        double v27 = v28 + CGRectGetWidth(*(CGRect *)(a1 + 40));
        goto LABEL_22;
      }
      double v24 = v28;
    }
    double v27 = *(unsigned char *)(a1 + 115) ? MaxY - v24 : v24;
LABEL_22:
    uint64_t v29 = (*(uint64_t (**)(void))(**(void **)a1 + 16))();
    CFIndex v30 = CFArrayGetCount(v17);
    int v82 = v21;
    if (v10 >= 1)
    {
      CFIndex v31 = v30;
      CFIndex v32 = v30 - 1;
      if (v30 >= 1) {
        break;
      }
    }
    *(unsigned char *)(a1 + 16CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = 0;
    std::__function::__value_func<unsigned char ()(long)>::~__value_func[abi:nn180100](v101);
    uint64_t v76 = v22;
LABEL_78:
    BOOL v36 = v22 == v76;
    uint64_t v22 = v76;
    if (v36)
    {
      uint64_t v22 = v76;
      if (v82 == v21)
      {
        uint64_t v22 = v76;
        CFIndex v75 = location;
        if (location == v93.location) {
          goto LABEL_90;
        }
      }
    }
  }
  uint64_t v92 = (uint64_t *)v29;
  uint64_t v88 = 0;
  BOOL v33 = 0;
  CFIndex v34 = 0;
  CFIndex v80 = v93.location;
  int v81 = v22;
  unsigned int v91 = v22;
  while (1)
  {
    v35.CGFloat width = NAN;
    v35.CGFloat height = NAN;
    rect.origiuint64_t n = (CGPoint)v35;
    rect.size = v35;
    BOOL v36 = v21 && *(unsigned char *)(a1 + 115) == 0;
    CFIndex v37 = v36 ? v32 : v34;
    CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v17, v37);
    CGRectMakeWithDictionaryRepresentation(ValueAtIndex, &rect);
    CGFloat x = rect.origin.x;
    if (*(unsigned char *)(a1 + 115))
    {
      CGFloat y = rect.origin.y;
      CGFloat width = rect.size.width;
      CGFloat height = rect.size.height;
      double v43 = CGRectGetMaxY(*(CGRect *)&x);
      CGFloat v44 = rect.origin.y;
      if (rect.origin.y >= v26) {
        goto LABEL_68;
      }
      double v45 = v43;
      double v46 = rect.size.height;
      if (v43 > v26)
      {
        double v46 = rect.size.height - (v43 - v26);
        rect.size.CGFloat height = v46;
      }
      if (rect.origin.y < v27)
      {
        double v46 = v46 - (v27 - rect.origin.y);
        rect.size.CGFloat height = v46;
        rect.origin.CGFloat y = v27;
        CGFloat v44 = v27;
      }
      CGFloat v47 = rect.origin.x;
      CGFloat v48 = rect.size.width;
      double v49 = CGRectGetHeight(*(CGRect *)(&v44 - 1));
    }
    else
    {
      double v45 = rect.origin.x - *(double *)(a1 + 40);
      CGFloat v50 = rect.origin.y;
      CGFloat v51 = rect.size.width;
      CGFloat v52 = rect.size.height;
      double v53 = v45 + CGRectGetWidth(*(CGRect *)&x);
      if (v53 <= v26) {
        goto LABEL_68;
      }
      double v54 = rect.size.width;
      if (v45 < v26)
      {
        double v54 = rect.size.width - (v26 - v45);
        rect.size.CGFloat width = v54;
        rect.origin.CGFloat x = v26;
        double v45 = v26;
      }
      if (v53 > v27)
      {
        double v54 = v54 - (v53 - v27);
        rect.size.CGFloat width = v54;
      }
      CGFloat v55 = rect.origin.x;
      CGFloat v56 = rect.origin.y;
      CGFloat v57 = rect.size.height;
      double v49 = CGRectGetWidth(*(CGRect *)(&v54 - 2));
    }
    double v58 = v49;
    if (v49 > 0.0) {
      break;
    }
LABEL_68:
    if (v33) {
      goto LABEL_74;
    }
LABEL_69:
    if (v10 >= 1)
    {
      ++v34;
      --v32;
      if (v34 < v31) {
        continue;
      }
    }
LABEL_74:
    *(unsigned char *)(a1 + 16CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = v88 & 1;
    std::__function::__value_func<unsigned char ()(long)>::~__value_func[abi:nn180100](v101);
    CFIndex v75 = v93.location;
    a2 = v79;
    locatiouint64_t n = v80;
    LODWORD(v22) = v81;
    goto LABEL_75;
  }
  if (*(unsigned char *)(a1 + 163)) {
    double v59 = 1.79769313e308;
  }
  else {
    double v59 = v49;
  }
  if (*(unsigned char *)(a1 + 115)) {
    double v60 = MaxY - v45;
  }
  else {
    double v60 = v45;
  }
  if (*(unsigned char *)(a1 + 162))
  {
    uint64_t v61 = v103;
    std::__function::__value_func<unsigned char ()(long)>::__value_func[abi:nn180100]((uint64_t)v103, (uint64_t)v101);
    CFIndex v62 = TTypesetter::SuggestLineBreak((uint64_t)v92, v93.location, (uint64_t)v103, v59, v60);
  }
  else
  {
    uint64_t v61 = v102;
    std::__function::__value_func<unsigned char ()(long)>::__value_func[abi:nn180100]((uint64_t)v102, (uint64_t)v101);
    CFIndex v62 = TTypesetter::SuggestClusterBreak((uint64_t)v92, v93.location, (uint64_t)v102, v59, v60);
  }
  uint64_t v64 = v62;
  *uint64_t v86 = v63;
  std::__function::__value_func<unsigned char ()(long)>::~__value_func[abi:nn180100](v61);
  if (!v64 && CFArrayGetCount((CFArrayRef)atomic_load_explicit(v89, memory_order_acquire)))
  {
    CFArrayRef v17 = v87;
    if (v33) {
      goto LABEL_74;
    }
    goto LABEL_69;
  }
  BOOL v33 = *v86 != 0;
  if (v64 >= v10) {
    CFIndex v65 = v10;
  }
  else {
    CFIndex v65 = v64;
  }
  id v99 = (id)0xAAAAAAAAAAAAAAAALL;
  TCFBase_NEW<CTLine,std::shared_ptr<TCharStream const> const&>(v92, &v99);
  if (!atomic_load_explicit((atomic_ullong *volatile)&v99, memory_order_acquire))
  {

    *(unsigned char *)(a1 + 16CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = v88 & 1;
    std::__function::__value_func<unsigned char ()(long)>::~__value_func[abi:nn180100](v101);
    CFIndex v75 = v93.location;
    a2 = v79;
    locatiouint64_t n = v80;
    CFArrayRef v17 = v87;
    LODWORD(v22) = v81;
LABEL_75:
    uint64_t v76 = v91;
    if ((v88 & 0x100000000) == 0) {
      goto LABEL_78;
    }
    goto LABEL_90;
  }
  uint64_t v66 = *(unsigned __int16 **)(atomic_load_explicit((atomic_ullong *volatile)&v99, memory_order_acquire) + 40);
  v105.locatiouint64_t n = v93.location;
  v105.CFIndex length = v65;
  TTypesetter::FillLine((TTypesetter *)v92, (TLine *)v66, v105, v59, v60);
  id v98 = (id)0xAAAAAAAAAAAAAAAALL;
  id v98 = (id)ExternalizeLine((atomic_ullong *)&v99);
  if (v91)
  {
    unsigned int v68 = v66[76];
    int v21 = (v68 >> 3) & 1;
    if ((v68 & 8) != 0 && !*(unsigned char *)(a1 + 115)) {
      goto LABEL_84;
    }
  }
  BOOL v69 = TFramesetter::ParagraphEndsWith((TFramesetter *)v66, (const TLine *)*v92, v67);
  TFramesetter::GetLineMetrics((uint64_t)&v93.length, (TLine *)v66, (const void *)*(unsigned __int8 *)(a1 + 113), *(unsigned __int8 *)(a1 + 114), v69, *(unsigned __int8 *)(a1 + 161));
  uint64_t v70 = v94;
  *a4 = *(double *)&v93.length;
  *a5 = v70;
  double v71 = v96;
  *(void *)a6 = v95;
  double v72 = v97;
  *a4 = v71 + *a4;
  *a6 = v72 + *a6;
  int v73 = *(unsigned __int8 *)(a1 + 115);
  if (*(unsigned char *)(a1 + 115))
  {
    double v45 = CGRectGetMaxY(rect) - *(double *)(a1 + 48);
    int v73 = *(unsigned __int8 *)(a1 + 115);
  }
  uint64_t v74 = a4;
  if (v65 <= 0) {
    uint64_t v74 = v83;
  }
  if (TFramesetter::AppendLine(*(void *)(a1 + 104), v73 == 0, v21 != 0, v69, *(unsigned __int8 *)(a1 + 112), v34, (atomic_ullong *)&v98, v89, v58, v45, *(double *)(a1 + 88) - *v74, a1 + 128, (atomic_ullong *)(a1 + 152)))
  {
    v10 -= v65;
    v93.location += v65;

    unsigned int v91 = 0;
    LOBYTE(v88) = v69;
    BYTE4(v88) = 1;
    CFArrayRef v17 = v87;
    goto LABEL_68;
  }
  BYTE4(v88) = 1;
LABEL_84:

  *(unsigned char *)(a1 + 16CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = v88 & 1;
  std::__function::__value_func<unsigned char ()(long)>::~__value_func[abi:nn180100](v101);
  a2 = v79;
  locatiouint64_t n = v80;
  LODWORD(v22) = v81;
  if ((v88 & 0x100000000) == 0)
  {
    uint64_t v76 = 0;
    CFArrayRef v17 = v87;
    goto LABEL_78;
  }
  CFIndex v75 = v93.location;
  CFArrayRef v17 = v87;
LABEL_90:
  CFIndex v77 = v75 - *(void *)(a1 + 72);
LABEL_91:

  return v77;
}

uint64_t TFramesetter::GetCharMetricsForLine(TFramesetter *this, uint64_t a2, uint64_t a3, uint64_t a4, const void *a5, int a6, int a7)
{
  double v13 = (TLine *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  uint64_t v14 = *(void *)(*(void *)(*((void *)v13 + 2) + 8 * TLine::FindRunWithCharIndex(v13, a4, 1)) + 40);
  if ((*(_WORD *)(v14 + 178) & 0x40) != 0)
  {
    BOOL v15 = (void *)*((void *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)(v14 + 40), memory_order_acquire), @"CTRunDelegate")+ 5);
    int v16 = (double (*)(void, double))v15[2];
    double v17 = 0.0;
    double v18 = 0.0;
    if (v16) {
      double v18 = v16(v15[5], 0.0);
    }
    *(double *)this = v18;
    CFArrayRef v19 = (double (*)(void))v15[3];
    if (v19) {
      double v17 = v19(v15[5]);
    }
    *((double *)this + 1) = v17;
  }
  else
  {
    TFont::GetDefaultMetrics(*(TFont **)(atomic_load_explicit((atomic_ullong *volatile)(v14 + 56), memory_order_acquire) + 40), (double *)this, (double *)this + 1, (double *)this + 2);
  }
  uint64_t v20 = *(void *)(*(void *)(*((void *)v13 + 2) + 8 * TLine::FindRunWithCharIndex(v13, a3, 1)) + 40) + 40;

  return ApplyParagraphStyleSettings(v20, a5, a6, 0, a7, (float64x2_t *)this, 0);
}

uint64_t TFramesetterBase::Typesetter(TFramesetterBase *this)
{
  return *(void *)((*(uint64_t (**)(TFramesetterBase *))(*(void *)this + 24))(this) + 40);
}

unint64_t TFramesetterBase::GetTypesetter(atomic_ullong *this)
{
  return atomic_load_explicit(this + 1, memory_order_acquire);
}

void TFramesetterBase::~TFramesetterBase(id *this)
{
  *this = &unk_1ED05E5F0;
}

{
  uint64_t vars8;

  *this = &unk_1ED05E5F0;

  JUMPOUT(0x1853275C0);
}

void TClippingPathInfo::~TClippingPathInfo(TClippingPathInfo *this)
{
  uint64_t v2 = (void **)((char *)this + 152);
  std::vector<CTFramePathFillRule,TInlineBufferAllocator<CTFramePathFillRule,5ul>>::__destroy_vector::operator()[abi:nn180100](&v2);
  uint64_t v2 = (void **)((char *)this + 80);
  std::vector<double,TInlineBufferAllocator<double,5ul>>::__destroy_vector::operator()[abi:nn180100](&v2);
  uint64_t v2 = (void **)((char *)this + 8);
  std::vector<TCFRef<CGPath const*>,TInlineBufferAllocator<TCFRef<CGPath const*>,5ul>>::__destroy_vector::operator()[abi:nn180100](&v2);
}

void std::vector<CTFramePathFillRule,TInlineBufferAllocator<CTFramePathFillRule,5ul>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  unint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    v1[1] = v2;
    BOOL v3 = (void **)((char *)v1 + 44);
    if (v1 + 3 <= v2)
    {
      BOOL v4 = v3 >= v2;
      BOOL v5 = v3 == v2;
    }
    else
    {
      BOOL v4 = 0;
      BOOL v5 = 0;
    }
    if (!v5 && v4)
    {
      if (v1[2] == v1[6]) {
        v1[6] = v2;
      }
    }
    else
    {
      operator delete(v2);
    }
  }
}

void std::vector<double,TInlineBufferAllocator<double,5ul>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  unint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    v1[1] = v2;
    BOOL v3 = v1 + 8;
    if (v1 + 3 <= v2)
    {
      BOOL v4 = v3 >= v2;
      BOOL v5 = v3 == v2;
    }
    else
    {
      BOOL v4 = 0;
      BOOL v5 = 0;
    }
    if (!v5 && v4)
    {
      if (v1[2] == v1[8]) {
        *BOOL v3 = v2;
      }
    }
    else
    {
      operator delete(v2);
    }
  }
}

void std::vector<TCFRef<CGPath const*>,TInlineBufferAllocator<TCFRef<CGPath const*>,5ul>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  unint64_t v1 = *a1;
  uint64_t v2 = (id *)**a1;
  if (v2)
  {
    BOOL v4 = (id *)v1[1];
    BOOL v5 = (void **)**a1;
    uint64_t v6 = v1;
    if (v4 != v2)
    {
      do
      {
        long long v7 = v4 - 1;

        BOOL v4 = v7;
      }
      while (v7 != v2);
      uint64_t v6 = *a1;
      BOOL v5 = (void **)**a1;
    }
    v1[1] = v2;
    BOOL v8 = v6 + 8;
    if (v6 + 3 <= v5 && v8 > v5)
    {
      if (v6[2] == v6[8]) {
        *BOOL v8 = v5;
      }
    }
    else
    {
      operator delete(v5);
    }
  }
}

void std::default_delete<TFramesetter::TPathFrameLinesetter>::operator()[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 128);
  if (v2)
  {
    *(void *)(a1 + 136) = v2;
    operator delete(v2);
  }

  JUMPOUT(0x1853275C0);
}

void std::__function::__func<TFramesetter::FrameInPath(TFrame &,CFRange)::$_0,std::allocator<TFramesetter::FrameInPath(TFrame &,CFRange)::$_0>,unsigned char ()(long)>::~__func()
{
}

__n128 std::__function::__func<TFramesetter::FrameInPath(TFrame &,CFRange)::$_0,std::allocator<TFramesetter::FrameInPath(TFrame &,CFRange)::$_0>,unsigned char ()(long)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x50uLL);
  *(void *)uint64_t v2 = &unk_1ED061430;
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(v2 + 4CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(v2 + 56) = *(_OWORD *)(a1 + 56);
  *((void *)v2 + 9) = *(void *)(a1 + 72);
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<TFramesetter::FrameInPath(TFrame &,CFRange)::$_0,std::allocator<TFramesetter::FrameInPath(TFrame &,CFRange)::$_0>,unsigned char ()(long)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ED061430;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  long long v3 = *(_OWORD *)(a1 + 40);
  long long v4 = *(_OWORD *)(a1 + 56);
  *(void *)(a2 + 72) = *(void *)(a1 + 72);
  *(_OWORD *)(a2 + 56) = v4;
  *(_OWORD *)(a2 + 4CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = v3;
  *(__n128 *)(a2 + 24) = result;
  return result;
}

uint64_t std::__function::__func<TFramesetter::FrameInPath(TFrame &,CFRange)::$_0,std::allocator<TFramesetter::FrameInPath(TFrame &,CFRange)::$_0>,unsigned char ()(long)>::operator()(uint64_t a1, uint64_t *a2)
{
  TFramesetter::GetCharMetricsForLine((TFramesetter *)v13, *(void *)(a1 + 8), *(void *)(a1 + 40), *a2, (const void *)*(unsigned __int8 *)(a1 + 48), *(unsigned __int8 *)(a1 + 49), *(unsigned __int8 *)(a1 + 50));
  double v3 = v13[1];
  double v4 = v13[2];
  double v5 = v13[0] + v14;
  uint64_t v6 = *(double **)(a1 + 16);
  if (v13[0] + v14 < *v6) {
    double v5 = *v6;
  }
  *uint64_t v6 = v5;
  long long v7 = *(double **)(a1 + 24);
  double v8 = *v7;
  if (v3 >= *v7) {
    double v8 = v3;
  }
  *long long v7 = v8;
  int v9 = *(double **)(a1 + 32);
  double v10 = *v9;
  if (v4 >= *v9) {
    double v10 = v4;
  }
  *int v9 = v10;
  uint64_t result = 32;
  if (*(double *)(a1 + 56) >= *v6)
  {
    if (*(double *)(a1 + 72) < v10 || *(double *)(a1 + 64) < *v7) {
      return 32;
    }
    else {
      return 0;
    }
  }
  return result;
}

void std::__function::__func<TFramesetter::FrameInPath(TFrame &,CFRange)::$_1,std::allocator<TFramesetter::FrameInPath(TFrame &,CFRange)::$_1>,unsigned char ()(long)>::~__func()
{
}

__n128 std::__function::__func<TFramesetter::FrameInPath(TFrame &,CFRange)::$_1,std::allocator<TFramesetter::FrameInPath(TFrame &,CFRange)::$_1>,unsigned char ()(long)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x50uLL);
  *(void *)uint64_t v2 = &unk_1ED061478;
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(v2 + 4CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(v2 + 56) = *(_OWORD *)(a1 + 56);
  *((void *)v2 + 9) = *(void *)(a1 + 72);
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<TFramesetter::FrameInPath(TFrame &,CFRange)::$_1,std::allocator<TFramesetter::FrameInPath(TFrame &,CFRange)::$_1>,unsigned char ()(long)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ED061478;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  long long v3 = *(_OWORD *)(a1 + 40);
  long long v4 = *(_OWORD *)(a1 + 56);
  *(void *)(a2 + 72) = *(void *)(a1 + 72);
  *(_OWORD *)(a2 + 56) = v4;
  *(_OWORD *)(a2 + 4CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = v3;
  *(__n128 *)(a2 + 24) = result;
  return result;
}

uint64_t std::__function::__func<TFramesetter::FrameInPath(TFrame &,CFRange)::$_1,std::allocator<TFramesetter::FrameInPath(TFrame &,CFRange)::$_1>,unsigned char ()(long)>::operator()(uint64_t a1, uint64_t *a2)
{
  TFramesetter::GetCharMetricsForLine((TFramesetter *)v13, *(void *)(a1 + 8), *(void *)(a1 + 40), *a2, (const void *)*(unsigned __int8 *)(a1 + 48), *(unsigned __int8 *)(a1 + 49), *(unsigned __int8 *)(a1 + 50));
  double v3 = v13[1];
  double v4 = v13[2];
  double v5 = v13[0] + v14;
  uint64_t v6 = *(double **)(a1 + 16);
  if (v13[0] + v14 < *v6) {
    double v5 = *v6;
  }
  *uint64_t v6 = v5;
  long long v7 = *(double **)(a1 + 24);
  double v8 = *v7;
  if (v3 >= *v7) {
    double v8 = v3;
  }
  *long long v7 = v8;
  int v9 = *(double **)(a1 + 32);
  double v10 = *v9;
  if (v4 >= *v9) {
    double v10 = v4;
  }
  *int v9 = v10;
  uint64_t result = 32;
  if (*(double *)(a1 + 56) >= *v6)
  {
    if (*(double *)(a1 + 72) < v10 || *(double *)(a1 + 64) < *v7) {
      return 32;
    }
    else {
      return 0;
    }
  }
  return result;
}

CFBundleRef _CTGetFrameworkBundleForLocalization()
{
  CFBundleRef result = (CFBundleRef)sBundleForLocalization;
  if (!sBundleForLocalization) {
    return CFBundleGetBundleWithIdentifier(@"com.apple.CoreText");
  }
  return result;
}

CFTypeRef _CTSetFrameworkBundleForLocalization(CFTypeRef cf)
{
  if (sBundleForLocalization) {
    CFRelease((CFTypeRef)sBundleForLocalization);
  }
  if (cf) {
    CFTypeRef result = CFRetain(cf);
  }
  else {
    CFTypeRef result = 0;
  }
  sBundleForLocalizatiouint64_t n = (uint64_t)result;
  return result;
}

void CTCopyLocalizedString(CFStringRef key@<X0>, CFStringRef tableName@<X1>, void *a3@<X8>)
{
  BundleWithCFStringRef Identifier = (__CFBundle *)sBundleForLocalization;
  if (sBundleForLocalization
    || (BundleWithCFStringRef Identifier = CFBundleGetBundleWithIdentifier(@"com.apple.CoreText")) != 0)
  {
    id v7 = (id)CFBundleCopyLocalizedString(BundleWithIdentifier, key, 0, tableName);
    *a3 = atomic_exchange((atomic_ullong *volatile)&v7, 0);
  }
  else
  {
    *a3 = 0;
  }
}

void TTypesetterUniChar::TTypesetterUniChar(TTypesetterUniChar *this, const unsigned __int16 *(*a2)(uint64_t, uint64_t *, const __CFDictionary **, void *), void (*a3)(const unsigned __int16 *, void *), void *a4)
{
  double v8 = (std::__shared_weak_count *)operator new(0xB0uLL);
  v8->__shared_weak_owners_ = 0;
  v8->__shared_owners_ = 0;
  v8->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ED062240;
  TCharStreamUniChar::TCharStreamUniChar((TCharStreamUniChar *)&v8[1], a2, a3, a4);
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  *(void *)this = v9;
  *((void *)this + 1) = v8;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 8) = (char *)this + 40;
  *((unsigned char *)this + 184) = 0;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 12CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(void *)((char *)this + 149) = 0;
  *((void *)this + 2CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = 0;
  *((void *)this + 21) = 0;
  *((unsigned char *)this + 176) = 0;
  *((void *)this + 24) = 0;
  *((void *)this + 25) = 0;
  *((void *)this + 16) = 0xFFEFFFFFFFFFFFFFLL;
  *((void *)this + 26) = 0;
  *((void *)this + 27) = v9;
  *((_DWORD *)this + 65) = 0;
  *((unsigned char *)this + 264) = 0;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *((_WORD *)this + 128) = 0;
  *((_WORD *)this + 77) = 1;
  std::__shared_weak_count::__release_shared[abi:nn180100](v8);
  TTypesetterUniChar::Initialize(this);
}

uint64_t TTypesetterUniChar::Initialize(TTypesetterUniChar *this)
{
  __dst[82] = *(TCompositionEngine **)MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(*((void *)this + 27) + 16);
  char v26 = 0;
  id v3 = +[_CTNativeGlyphStorage newWithCount:v2 capacity:v2];
  unint64_t v25 = 0xAAAAAAAAFFFFFFFFLL;
  memset(&v24[80], 170, 160);
  memset(v24, 170, 32);
  double v4 = (void *)*((void *)this + 27);
  memset(&v24[16], 0, 184);
  *(void *)&v24[176] = v4[2];
  *(void *)&v24[200] = this;
  memset(&v24[208], 0, 32);
  LODWORD(v25) = 1065353216;
  uint64_t v5 = v4[7] - v4[6];
  *(void *)double v24 = v3;
  *(void *)&v24[8] = v4;
  if (v5 >= 1)
  {
    uint64_t v6 = 0;
    int v7 = 0;
    CFIndex v8 = 0;
    int64_t v9 = v5 / 0x18uLL;
    if (v9 <= 1) {
      uint64_t v10 = 1;
    }
    else {
      uint64_t v10 = v9;
    }
    do
    {
      int v11 = (const TCharStream *)*((void *)this + 27);
      uint64_t v12 = *((void *)v11 + 6) + v6;
      CFIndex v13 = *(void *)v12;
      v29.locatiouint64_t n = v8;
      v29.CFIndex length = *(void *)v12;
      TAttributes::TAttributes((TAttributes *)__dst, *(const __CFDictionary **)(v12 + 16), v11, v29, 0);
      v7 |= TGlyphEncoder::EncodeChars((_CTGlyphStorage **)v24, v8, v13, (uint64_t)__dst, 0);
      char v26 = v7;
      TAttributes::~TAttributes((TAttributes *)__dst);
      v8 += v13;
      v6 += 24;
      --v10;
    }
    while (v10);
  }

  *((void *)this + 9) = 0;
  *((void *)this + 1CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = v2;
  TLine::LinkRuns(this);
  if (TTypesetter::CanLayout(this))
  {
    double v17 = this;
    long long v18 = *(_OWORD *)((char *)this + 216);
    uint64_t v19 = *((void *)this + 29);
    uint64_t v20 = (char *)this + 240;
    int v14 = *((_DWORD *)this + 65);
    int v22 = -1431655766;
    uint64_t v23 = 0;
    int v21 = v14;
    LOBYTE(v22) = *((unsigned char *)this + 264);
    BYTE1(v22) = *((unsigned char *)this + 257);
    memcpy(__dst, &unk_184B89328, 0x290uLL);
    TRunGlue::TRunGlue((TRunGlue *)__dst, this);
    char v15 = TTypesetter::FinishEncoding((uint64_t)&v17, (TShapingEngine *)__dst, (const TCharStream *)&v26);
    TTypesetter::FinishLayout((uint64_t)&v17, __dst, (const TCharStream *)v26, v15);
    std::__function::__value_func<BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::~__value_func[abi:nn180100](&__dst[70]);
    double v27 = &__dst[46];
    std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v27);
    double v27 = &__dst[26];
    std::vector<unsigned char,TInlineBufferAllocator<unsigned char,128ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v27);
    double v27 = &__dst[7];
    std::vector<std::pair<UScriptCode,long>,TInlineBufferAllocator<std::pair<UScriptCode,long>,1ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v27);
  }
  return std::__hash_table<EncoderAttempt,std::hash<EncoderAttempt>,std::equal_to<EncoderAttempt>,std::allocator<EncoderAttempt>>::~__hash_table((uint64_t)&v24[208]);
}

void TTypesetterUniChar::TTypesetterUniChar(TTypesetterUniChar *this, const unsigned __int16 *(*a2)(uint64_t, uint64_t *, const __CFDictionary **, void *), void (*a3)(const unsigned __int16 *, void *), void *a4, const __CFDictionary *a5)
{
  uint64_t v10 = (std::__shared_weak_count *)operator new(0xB0uLL);
  v10->__shared_owners_ = 0;
  v10->__shared_weak_owners_ = 0;
  v10->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ED062240;
  TCharStreamUniChar::TCharStreamUniChar((TCharStreamUniChar *)&v10[1], a2, a3, a4);
  uint64_t v12 = v11;
  CFIndex v13 = v10;
  TTypesetter::TTypesetter(this, &v12, a5);
  if (v13) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v13);
  }
  TTypesetterUniChar::Initialize(this);
}

void *__Block_byref_object_copy_(void *a1, uint64_t a2)
{
  double v4 = *(unsigned char **)(a2 + 48);
  id v3 = *(unsigned char **)(a2 + 56);
  CFTypeRef result = a1 + 9;
  a1[6] = 0;
  a1[7] = 0;
  a1[8] = 0;
  a1[69] = result;
  int64_t v6 = v3 - v4;
  if (v3 != v4)
  {
    if (v6 < 0) {
      abort();
    }
    int v7 = TInlineBufferAllocator<CGPoint,30ul>::allocate((uint64_t)result, v6 >> 4);
    a1[6] = v7;
    a1[7] = v7;
    CFIndex v8 = &v7[16 * (v6 >> 4)];
    a1[8] = v8;
    CFTypeRef result = memmove(v7, v4, v6);
    a1[7] = v8;
  }
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{
}

void ___ZN21TTypesetterAttrString10InitializeEPK20__CFAttributedStringb_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void **)(*(void *)(a1 + 32) + 8);
  int v7 = (char *)v5[7];
  unint64_t v6 = v5[8];
  if ((unint64_t)v7 >= v6)
  {
    int64_t v9 = (char *)v5[6];
    uint64_t v10 = (v7 - v9) >> 4;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 60) {
      abort();
    }
    uint64_t v12 = v6 - (void)v9;
    if (v12 >> 3 > v11) {
      unint64_t v11 = v12 >> 3;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    if (v13)
    {
      int v14 = TInlineBufferAllocator<CGPoint,30ul>::allocate((uint64_t)(v5 + 9), v13);
      int64_t v9 = (char *)v5[6];
      int v7 = (char *)v5[7];
    }
    else
    {
      int v14 = 0;
    }
    char v15 = &v14[16 * v10];
    *(void *)char v15 = a2;
    *((void *)v15 + 1) = a3;
    int v16 = v15;
    if (v7 != v9)
    {
      do
      {
        *((_OWORD *)v16 - 1) = *((_OWORD *)v7 - 1);
        v16 -= 16;
        v7 -= 16;
      }
      while (v7 != v9);
      int64_t v9 = (char *)v5[6];
    }
    CFIndex v8 = v15 + 16;
    v5[6] = v16;
    v5[7] = v15 + 16;
    uint64_t v17 = v5[8];
    v5[8] = &v14[16 * v13];
    if (v9)
    {
      long long v18 = (char *)(v5 + 69);
      if (v5 + 9 <= (void *)v9 && v18 > v9)
      {
        if (v17 == *(void *)v18) {
          *(void *)long long v18 = v9;
        }
      }
      else
      {
        operator delete(v9);
      }
    }
  }
  else
  {
    *(void *)int v7 = a2;
    *((void *)v7 + 1) = a3;
    CFIndex v8 = v7 + 16;
  }
  v5[7] = v8;
}

void std::__shared_ptr_emplace<TCharStreamCFAttrString>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ED0622E8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TCharStreamCFAttrString>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ED0622E8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1853275C0);
}

unint64_t TFramesetterAttrString::GetTypesetter(TFramesetterAttrString *this)
{
  unint64_t v1 = (atomic_ullong *)((char *)this + 280);
  if (!atomic_load_explicit((atomic_ullong *volatile)this + 35, memory_order_acquire))
  {
    uint64_t v3 = *((void *)this + 28);
    id v13 = (id)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(id *__return_ptr))(*(void *)v3 + 32))(&v12);
    CFAttributedStringRef explicit = (const __CFAttributedString *)atomic_load_explicit((atomic_ullong *volatile)&v12, memory_order_acquire);
    uint64_t v5 = TCFBase<TTypesetter>::Allocate();
    if (v5)
    {
      unint64_t v6 = (void *)v5;
      int v7 = (TTypesetterAttrString *)(v5 + 48);
      v6[2] = 0;
      CFIndex v6[3] = 0;
      v6[4] = 0;
      v6[5] = v7;
      TTypesetterAttrString::TTypesetterAttrString(v7, explicit, 0, 0);
      id v14 = v6;
      id v13 = (id)atomic_exchange((atomic_ullong *volatile)&v14, 0);
    }
    else
    {
      id v13 = 0;
    }

    uint64_t v8 = 0;
    unint64_t v9 = atomic_exchange((atomic_ullong *volatile)&v13, 0);
    atomic_compare_exchange_strong((atomic_ullong *volatile)this + 35, (unint64_t *)&v8, v9);
    if (v8) {
      uint64_t v10 = (void *)v9;
    }
    else {
      uint64_t v10 = 0;
    }
  }
  return atomic_load_explicit(v1, memory_order_acquire);
}

uint64_t TFramesetterUniChar::Typesetter(TFramesetterUniChar *this)
{
  return (uint64_t)this + 8;
}

uint64_t TFramesetterUniChar::GetTypesetter(TFramesetterUniChar *this)
{
  return 0;
}

void TFramesetterUniChar::~TFramesetterUniChar(TFramesetterUniChar *this)
{
  *(void *)this = &unk_1ED05E960;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 32);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  TLine::~TLine((TFramesetterUniChar *)((char *)this + 8));
}

{
  std::__shared_weak_count *v2;
  uint64_t vars8;

  *(void *)this = &unk_1ED05E960;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 32);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  TLine::~TLine((TFramesetterUniChar *)((char *)this + 8));

  JUMPOUT(0x1853275C0);
}

void std::__function::__func<TASCIIDataCache::InitProps(void)::$_0,std::allocator<TASCIIDataCache::InitProps(void)::$_0>,void ()(long)>::~__func()
{
}

void *std::__function::__func<TASCIIDataCache::InitProps(void)::$_0,std::allocator<TASCIIDataCache::InitProps(void)::$_0>,void ()(long)>::__clone(uint64_t a1)
{
  CFTypeRef result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *CFTypeRef result = &unk_1ED060FB0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<TASCIIDataCache::InitProps(void)::$_0,std::allocator<TASCIIDataCache::InitProps(void)::$_0>,void ()(long)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1ED060FB0;
  a2[1] = v2;
  return result;
}

void std::__function::__func<TASCIIDataCache::InitProps(void)::$_1,std::allocator<TASCIIDataCache::InitProps(void)::$_1>,void ()(long)>::~__func()
{
}

void *std::__function::__func<TASCIIDataCache::InitProps(void)::$_1,std::allocator<TASCIIDataCache::InitProps(void)::$_1>,void ()(long)>::__clone(uint64_t a1)
{
  CFTypeRef result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *CFTypeRef result = &unk_1ED060FF8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<TASCIIDataCache::InitProps(void)::$_1,std::allocator<TASCIIDataCache::InitProps(void)::$_1>,void ()(long)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1ED060FF8;
  a2[1] = v2;
  return result;
}

uint64_t std::function<void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (v1)
  {
    uint64_t v2 = *(uint64_t (**)(void))(*(void *)v1 + 48);
    return v2();
  }
  else
  {
    uint64_t v4 = std::__throw_bad_function_call[abi:nn180100]();
    return TAATMorphTable::AddCoveredGlyphs(v4);
  }
}

uint64_t TAATMorphTable::AddCoveredGlyphs(TBaseFont **a1, void *a2, uint64_t a3, uint64_t a4)
{
  v47[71] = *MEMORY[0x1E4F143B8];
  uint64_t CommonTable = TBaseFont::GetCommonTable(a1[50], 1634561906, 0);
  if (!CommonTable) {
    return 0;
  }
  CFDataRef v9 = (const __CFData *)CommonTable;
  uint64_t v33 = a4;
  values[0] = a2;
  BOOL v10 = 1;
  CFArrayRef v38 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)values, 1, MEMORY[0x1E4F1D510]);
  BytePtr = CFDataGetBytePtr(v9);
  CFIndex Length = CFDataGetLength(v9);
  id v13 = &BytePtr[Length];
  if (BytePtr + 8 > &BytePtr[Length])
  {
    std::function<void ()(void)>::operator()(v33);
    BOOL v10 = 0;
    goto LABEL_31;
  }
  memset(v47, 170, 0x230uLL);
  char v14 = *(unsigned char *)a1;
  v47[2] = a1;
  LOBYTE(v47[3]) = 1;
  values[0] = &unk_1ED05E770;
  values[1] = (void *)BytePtr;
  v47[7] = TAATLookupTable::BadTable;
  v47[8] = 0;
  v47[12] = 0;
  LOWORD(v47[13]) = -1;
  LOBYTE(v47[14]) = v14 & 1;
  v47[4] = &unk_1ED05EB58;
  memset(&v47[19], 0, 24);
  v47[70] = &v47[22];
  values[2] = (void *)v13;
  double v45 = BytePtr + 8;
  double v46 = BytePtr + 8;
  unsigned int v15 = *((_DWORD *)BytePtr + 1);
  if (!v15)
  {
LABEL_30:
    values[0] = &unk_1ED05E770;
    id v39 = &v47[19];
    std::vector<unsigned char const*,TInlineBufferAllocator<unsigned char const*,48ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v39);
LABEL_31:

    return v10;
  }
  BOOL v10 = 0;
  int v16 = 0;
  unsigned int v17 = bswap32(*(_DWORD *)BytePtr);
  unsigned int v18 = bswap32(v15);
  if (v18 <= 1) {
    int v19 = 1;
  }
  else {
    int v19 = v18;
  }
  int v34 = v19;
  unsigned int v35 = v18;
  unsigned int v37 = HIWORD(v17);
  while (1)
  {
    if ((TAATMorphChainMorx::NextChain((TAATMorphChainMorx *)values, v37) & 1) == 0)
    {
      std::function<void ()(void)>::operator()(v33);
      goto LABEL_30;
    }
    BOOL v36 = v10;
    TFontFeatureSettingList::TFontFeatureSettingList((TFontFeatureSettingList *)&v39, v38);
    int v20 = TAATMorphChain::ResolveFlags((TAATMorphChain *)values, 0, (atomic_ullong *)&v39, 0, 0);
    std::__hash_table<std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>>>::~__hash_table((uint64_t)&v42);
    std::__hash_table<std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>>>::~__hash_table((uint64_t)&v41);
    std::__tree<std::__value_type<long,TAATDeltaYListEntry>,std::__map_value_compare<long,std::__value_type<long,TAATDeltaYListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TAATDeltaYListEntry>>>::destroy((uint64_t)v40, v40[1]);

    unsigned int v21 = *((_DWORD *)v45 + 3);
    if (v21) {
      break;
    }
LABEL_25:
    BOOL v10 = ++v16 >= v35;
    if (v16 == v34)
    {
      BOOL v10 = 1;
      goto LABEL_30;
    }
  }
  unint64_t v22 = 0;
  unsigned int v23 = bswap32(v21);
  if (v23 <= 1) {
    uint64_t v24 = 1;
  }
  else {
    uint64_t v24 = v23;
  }
  while (((*(uint64_t (**)(void *))(v47[4] + 16))(&v47[4]) & 1) != 0)
  {
    if ((v47[5] & v20) != 0)
    {
      if (v22 < (uint64_t)(v47[20] - v47[19]) >> 3 && (uint64_t v25 = *(void *)(v47[19] + 8 * v22)) != 0)
      {
        GlyphCFIndex Count = TBaseFont::GetGlyphCount(a1[50]);
        if (GlyphCount >= 1)
        {
          uint64_t v27 = GlyphCount;
          for (uint64_t i = 0; i != v27; ++i)
          {
            if ((*(unsigned __int8 *)(v25 + ((unsigned __int16)i >> 3)) >> (i & 7))) {
              std::function<void ()(unsigned short,unsigned short)>::operator()(a3, i, i);
            }
          }
        }
      }
      else
      {
        std::__function::__value_func<void ()(unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)v43, a3);
        char v29 = TAATMorphSubtableMorx::AddShapingGlyphs((uint64_t)&v47[4], (uint64_t)v43);
        std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100](v43);
        if ((v29 & 1) == 0) {
          break;
        }
      }
    }
    if (++v22 == v24) {
      goto LABEL_25;
    }
  }
  uint64_t v30 = *(void *)(v33 + 24);
  if (v30)
  {
    (*(void (**)(uint64_t))(*(void *)v30 + 48))(v30);
    BOOL v10 = v36;
    goto LABEL_30;
  }
  uint64_t v32 = std::__throw_bad_function_call[abi:nn180100]();
  return TAATMorphTable::AddShapingLanguages(v32);
}

BOOL TAATMorphTable::AddShapingLanguages(TBaseFont *a1, uint64_t a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t CommonTable = TBaseFont::GetCommonTable(a1, 1634561906, 0);
  if (CommonTable)
  {
    id v11 = (id)0xAAAAAAAAAAAAAAAALL;
    TAATLtagTable::TAATLtagTable((TAATLtagTable *)&keys, a1);
    TAATLtagTable::CopyLanguageTags((TAATLtagTable *)&keys, &v11);
    if (atomic_load_explicit((atomic_ullong *volatile)&v11, memory_order_acquire))
    {
      CFIndex Count = CFDictionaryGetCount((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v11, memory_order_acquire));
      *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v16[14] = v6;
      v16[13] = v6;
      v16[12] = v6;
      v16[11] = v6;
      v16[10] = v6;
      v16[9] = v6;
      v16[8] = v6;
      v16[7] = v6;
      v16[6] = v6;
      v16[4] = v6;
      v16[5] = v6;
      void v16[2] = v6;
      void v16[3] = v6;
      v16[0] = v6;
      v16[1] = v6;
      char v14 = 0;
      uint64_t v15 = 0;
      id keys = 0;
      unsigned int v17 = v16;
      if (Count)
      {
        std::vector<long,TInlineBufferAllocator<long,30ul>>::__vallocate[abi:nn180100](&keys, Count);
        int v7 = (char *)v14;
        bzero(v14, 8 * Count);
        char v14 = &v7[8 * Count];
      }
      CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v11, memory_order_acquire);
      CFDictionaryGetKeysAndValues(explicit, (const void **)keys, 0);
      if (Count >= 1)
      {
        for (uint64_t i = 0; i != Count; ++i)
          std::function<void ()(__CFString const*)>::operator()(a2, (uint64_t)keys[i]);
      }
      p_id keys = &keys;
      std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&p_keys);
    }
  }
  return CommonTable != 0;
}

uint64_t std::function<void ()(__CFString const*)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2)
  {
    std::__throw_bad_function_call[abi:nn180100]();
    JUMPOUT(0x184AE15F8);
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v2 + 48))(v2, &v4);
}

void std::__function::__func<TAATMorphTable::ShapeGlyphs(SyncState &,__CFString const*)::$_0,std::allocator<TAATMorphTable::ShapeGlyphs(SyncState &,__CFString const*)::$_0>,BOOL ()(TRunGlue::TGlyph)>::~__func()
{
}

void *std::__function::__func<TAATMorphTable::ShapeGlyphs(SyncState &,__CFString const*)::$_0,std::allocator<TAATMorphTable::ShapeGlyphs(SyncState &,__CFString const*)::$_0>,BOOL ()(TRunGlue::TGlyph)>::__clone()
{
  CFTypeRef result = operator new(0x10uLL);
  *CFTypeRef result = &unk_1ED060D70;
  return result;
}

void std::__function::__func<TAATMorphTable::ShapeGlyphs(SyncState &,__CFString const*)::$_0,std::allocator<TAATMorphTable::ShapeGlyphs(SyncState &,__CFString const*)::$_0>,BOOL ()(TRunGlue::TGlyph)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1ED060D70;
}

void std::__function::__func<TAATMorphTable::ShapeGlyphs(SyncState &,__CFString const*)::$_1,std::allocator<TAATMorphTable::ShapeGlyphs(SyncState &,__CFString const*)::$_1>,BOOL ()(TRunGlue::TGlyph)>::~__func()
{
}

void *std::__function::__func<TAATMorphTable::ShapeGlyphs(SyncState &,__CFString const*)::$_1,std::allocator<TAATMorphTable::ShapeGlyphs(SyncState &,__CFString const*)::$_1>,BOOL ()(TRunGlue::TGlyph)>::__clone()
{
  CFTypeRef result = operator new(0x10uLL);
  *CFTypeRef result = &unk_1ED060DB8;
  return result;
}

void std::__function::__func<TAATMorphTable::ShapeGlyphs(SyncState &,__CFString const*)::$_1,std::allocator<TAATMorphTable::ShapeGlyphs(SyncState &,__CFString const*)::$_1>,BOOL ()(TRunGlue::TGlyph)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1ED060DB8;
}

BOOL std::__function::__func<TAATMorphTable::ShapeGlyphs(SyncState &,__CFString const*)::$_1,std::allocator<TAATMorphTable::ShapeGlyphs(SyncState &,__CFString const*)::$_1>,BOOL ()(TRunGlue::TGlyph)>::operator()(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  return TRunGlue::TGlyph::IsIgnorable((TRunGlue::TGlyph *)&v3);
}

void std::__function::__func<TAATMorphTable::ShapeGlyphsWithMultipleFeatureSettings(SyncState &)::$_0,std::allocator<TAATMorphTable::ShapeGlyphsWithMultipleFeatureSettings(SyncState &)::$_0>,BOOL ()(TRunGlue::TGlyph)>::~__func()
{
}

void *std::__function::__func<TAATMorphTable::ShapeGlyphsWithMultipleFeatureSettings(SyncState &)::$_0,std::allocator<TAATMorphTable::ShapeGlyphsWithMultipleFeatureSettings(SyncState &)::$_0>,BOOL ()(TRunGlue::TGlyph)>::__clone()
{
  CFTypeRef result = operator new(0x10uLL);
  *CFTypeRef result = &unk_1ED060E00;
  return result;
}

void std::__function::__func<TAATMorphTable::ShapeGlyphsWithMultipleFeatureSettings(SyncState &)::$_0,std::allocator<TAATMorphTable::ShapeGlyphsWithMultipleFeatureSettings(SyncState &)::$_0>,BOOL ()(TRunGlue::TGlyph)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1ED060E00;
}

BOOL std::__function::__func<TAATMorphTable::ShapeGlyphsWithMultipleFeatureSettings(SyncState &)::$_0,std::allocator<TAATMorphTable::ShapeGlyphsWithMultipleFeatureSettings(SyncState &)::$_0>,BOOL ()(TRunGlue::TGlyph)>::operator()(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  return TRunGlue::TGlyph::IsIgnorable((TRunGlue::TGlyph *)&v3);
}

uint64_t TAATMorphChain::FlagsForOptionalLigatures(TAATMorphChain *this)
{
  uint64_t v1 = *((unsigned int *)this + 11);
  if (!v1) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v4 = *((void *)this + 6);
  uint64_t v5 = 12 * v1;
  long long v6 = (unsigned int *)(v4 + 4);
  do
  {
    if (*((_WORD *)v6 - 2) == 256)
    {
      unsigned int v7 = bswap32(*((unsigned __int16 *)v6 - 1)) >> 16;
      if (v7 >= 2 && (v7 & 1) == 0) {
        uint64_t result = (bswap32(*v6) | result) & bswap32(v6[1]);
      }
    }
    v6 += 3;
    v5 -= 12;
  }
  while (v5);
  return result;
}

void TAATMorphTableMorx::~TAATMorphTableMorx(TAATMorphTableMorx *this)
{
  *(void *)this = &unk_1ED05E7B0;
  *((void *)this + 8) = &unk_1ED05E770;
  uint64_t v1 = (void **)((char *)this + 256);
  std::vector<unsigned char const*,TInlineBufferAllocator<unsigned char const*,48ul>>::__destroy_vector::operator()[abi:nn180100](&v1);
}

{
  void **v2;

  *(void *)this = &unk_1ED05E7B0;
  *((void *)this + 8) = &unk_1ED05E770;
  uint64_t v2 = (void **)((char *)this + 256);
  std::vector<unsigned char const*,TInlineBufferAllocator<unsigned char const*,48ul>>::__destroy_vector::operator()[abi:nn180100](&v2);
  MEMORY[0x1853275C0](this, 0x10F3C406B59EFBDLL);
}

void TAATMorphChainMorx::~TAATMorphChainMorx(TAATMorphChainMorx *this)
{
  *(void *)this = &unk_1ED05E770;
  uint64_t v1 = (void **)((char *)this + 192);
  std::vector<unsigned char const*,TInlineBufferAllocator<unsigned char const*,48ul>>::__destroy_vector::operator()[abi:nn180100](&v1);
}

{
  void **v2;

  *(void *)this = &unk_1ED05E770;
  uint64_t v2 = (void **)((char *)this + 192);
  std::vector<unsigned char const*,TInlineBufferAllocator<unsigned char const*,48ul>>::__destroy_vector::operator()[abi:nn180100](&v2);
  MEMORY[0x1853275C0](this, 0x10F3C4076A4214ELL);
}

BOOL TAATMorphChainMorx::HasCoverage(TAATMorphChainMorx *this)
{
  return *((void *)this + 24) != *((void *)this + 25);
}

char *TInlineBufferAllocator<unsigned char const*,48ul>::allocate(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = (char *)(a1 + 384);
  uint64_t result = *(char **)(a1 + 384);
  uint64_t v4 = &result[8 * a2];
  if (v4 <= v2)
  {
    *(void *)uint64_t v2 = v4;
  }
  else
  {
    if (a2 >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    return (char *)operator new(8 * a2);
  }
  return result;
}

uint64_t std::__split_buffer<unsigned char const*,TInlineBufferAllocator<unsigned char const*,48ul> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3) {
    *(void *)(a1 + 16) = v2 + ((v3 - v2 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  uint64_t v4 = *(void **)a1;
  if (*(void *)a1)
  {
    unint64_t v5 = *(void *)(a1 + 32);
    long long v6 = (void *)(v5 + 384);
    if (v5 <= (unint64_t)v4 && v6 > v4)
    {
      if (*(void *)(a1 + 24) == *v6) {
        *long long v6 = v4;
      }
    }
    else
    {
      operator delete(v4);
    }
  }
  return a1;
}

uint64_t TTateChuYokoRun::TTateChuYokoRun(uint64_t a1, uint64_t a2)
{
  TRun::TRun((TRun *)a1, *(const TRun **)(a2 + 40));
  *(void *)uint64_t v3 = &unk_1ED05E4A8;
  *(double *)(a1 + 32CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = TRun::GetAscent(v3);
  *(double *)(a1 + 328) = TRun::GetDescent((TRun *)a1);
  *(void *)(a1 + 336) = 0;
  return a1;
}

void TTateChuYokoRun::TTateChuYokoRun(TTateChuYokoRun *this, const TTateChuYokoRun *a2)
{
  TRun::TRun(this, a2);
  *(void *)uint64_t v3 = &unk_1ED05E4A8;
  *((double *)this + 4CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = TRun::GetAscent(v3);
  *((double *)this + 41) = TRun::GetDescent(this);
  *((void *)this + 42) = 0;
}

uint64_t TTateChuYokoRun::TTateChuYokoRun(uint64_t a1, uint64_t a2, uint64_t a3, CFIndex a4, int a5)
{
  long long v6 = (TRun *)TRun::TRun(a1, a2, a3, a4, a5);
  *(void *)long long v6 = &unk_1ED05E4A8;
  *(double *)(a1 + 32CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = TRun::GetAscent(v6);
  *(double *)(a1 + 328) = TRun::GetDescent((TRun *)a1);
  *(void *)(a1 + 336) = 0;
  return a1;
}

void TTateChuYokoRun::CacheGlyphPositions(double **this, double *a2, double *a3)
{
  double v4 = *a2;
  double v5 = *a3;
  TRun::CacheGlyphPositions((TRun *)this, a2, a3);
  long long v6 = this[39];
  if (!v6) {
    long long v6 = (double *)MEMORY[0x1E4F1DB30];
  }
  double v7 = *((double *)this + 24) + *v6;
  double v8 = *((double *)this + 40) + *((double *)this + 41);
  if (v8 > v7 || vabdd_f64(v8, v7) < 0.001)
  {
    TRun::GetPositions((__n128 *)this, 0);
    *((double *)this + 42) = *v9 - v4 - v5;
  }
}

void TTateChuYokoRun::DrawGlyphsAtPositions(double *a1, CGContext *a2, CFRange a3, CGPoint *a4, unsigned __int8 *a5)
{
}

void TTateChuYokoRun::GetImageBounds(__n128 *this, CGContext *a2, CFRange a3, double *a4, double *a5)
{
  CFIndex length = a3.length;
  locatiouint64_t n = a3.location;
  v21.CGFloat width = NAN;
  v21.CGFloat height = NAN;
  TRun::GetPositions(this, &v21);
  double v11 = *a4;
  double v12 = *a5;
  v22.locatiouint64_t n = location;
  v22.CFIndex length = length;
  Imagedouble Bounds = TRun::GetImageBounds((TRun *)this, a2, v22, a4, a5);
  double v17 = this[21].n128_f64[0];
  if (v17 != 0.0)
  {
    double v18 = ImageBounds - (v12 + v11 * 0.0 + 0.0 - v17);
    double v19 = v14 - (v12 * 0.0 - v11 + 0.0 - v17);
    CGAffineTransform v20 = *(CGAffineTransform *)kRotateLeftTransform;
    CGRectApplyAffineTransform(*(CGRect *)(&v15 - 2), &v20);
  }
}

void TTateChuYokoRun::~TTateChuYokoRun(void **this)
{
  TRun::~TRun(this);

  JUMPOUT(0x1853275C0);
}

uint64_t TTateChuYokoRun::FindBreak@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, const TCharStream *a3@<X2>, int a4@<W3>, uint64_t a5@<X8>, double a6@<D0>)
{
  *(_OWORD *)a5 = xmmword_184B89AC8;
  *(void *)(a5 + 16) = -1;
  uint64_t result = TRun::FindBreak(a1, a2, a3, a4, a5, a6);
  *(unsigned char *)a5 |= 8u;
  return result;
}

double TTateChuYokoRun::GetAscent(TTateChuYokoRun *this)
{
  return *((double *)this + 40);
}

double TTateChuYokoRun::GetDescent(TTateChuYokoRun *this)
{
  return *((double *)this + 41);
}

double TTateChuYokoRun::GetLeading(TTateChuYokoRun *this)
{
  return 0.0;
}

CTFontDescriptorRef CTFontDescriptorCreateWithNameAndSize(CFStringRef name, CGFloat size)
{
  uint64_t v2 = (__CFString *)name;
  if (name)
  {
    id v9 = (id)0xAAAAAAAAAAAAAAAALL;
    uint64_t v4 = TCFBase<TDescriptor>::Allocate();
    if (v4)
    {
      double v5 = (void *)v4;
      long long v6 = (TDescriptor *)(v4 + 48);
      v5[2] = 0;
      v5[3] = TDescriptor::Hash;
      v5[4] = 0;
      _OWORD v5[5] = v6;
      TDescriptor::TDescriptor(v6, v2, size, 0);
      id v10 = v5;
      id v8 = (id)atomic_exchange((atomic_ullong *volatile)&v10, 0);
    }
    else
    {
      id v8 = 0;
    }
    id v9 = (id)atomic_exchange((atomic_ullong *volatile)&v8, 0);

    uint64_t v2 = (__CFString *)atomic_exchange((atomic_ullong *volatile)&v9, 0);
  }
  return (CTFontDescriptorRef)v2;
}

CTFontDescriptorRef CTFontDescriptorCreateCopyWithVariation(CTFontDescriptorRef original, CFNumberRef variationIdentifier, CGFloat variationValue)
{
  CFNumberRef v10 = variationIdentifier;
  CGFloat v9 = variationValue;
  if (!original) {
    return 0;
  }
  if (variationIdentifier)
  {
    id v8 = (id)0xAAAAAAAAAAAAAAAALL;
    CTFontDescriptorRef v6 = original;
    int v5 = 0;
    TCFBase_NEW<CTFontDescriptor,CTFontDescriptor*,__CFNumber const*&,double &,int>((uint64_t *)&v6, &v10, &v9, &v5, &v7);
    id v8 = (id)atomic_exchange((atomic_ullong *volatile)&v7, 0);

    uint64_t v3 = (const __CTFontDescriptor *)atomic_exchange((atomic_ullong *volatile)&v8, 0);
    return v3;
  }

  return original;
}

void TCFBase_NEW<CTFontDescriptor,CTFontDescriptor*,__CFNumber const*&,double &,int>(uint64_t *a1@<X0>, const __CFNumber **a2@<X1>, double *a3@<X2>, int *a4@<X3>, void *a5@<X8>)
{
  uint64_t v10 = TCFBase<TDescriptor>::Allocate();
  if (v10)
  {
    double v11 = (void *)v10;
    uint64_t v12 = *a1;
    CFNumberRef v13 = *a2;
    double v14 = *a3;
    int v15 = *a4;
    int v16 = (TDescriptor *)(v10 + 48);
    void v11[2] = 0;
    id v11[3] = TDescriptor::Hash;
    v11[4] = 0;
    void v11[5] = v16;
    TDescriptor::TDescriptor(v16, *(const TDescriptor **)(v12 + 40), v13, v14, v15);
    id v17 = v11;
    *a5 = atomic_exchange((atomic_ullong *volatile)&v17, 0);
  }
  else
  {
    *a5 = 0;
  }
}

CFTypeRef CTFontDescriptorCopyLocalizedAttribute(CTFontDescriptorRef descriptor, CFStringRef attribute, CFStringRef *language)
{
  uint64_t v3 = 0;
  if (descriptor && attribute)
  {
    TDescriptor::CopyLocalizedAttribute(*((atomic_ullong **)descriptor + 5), attribute, language, (atomic_ullong *)&v5);
    uint64_t v3 = (const void *)atomic_exchange((atomic_ullong *volatile)&v5, 0);
  }
  return v3;
}

unint64_t CTFontDescriptorsCopyLocalizedAttribute(const __CFArray *a1, const __CFString *a2)
{
  if (a1)
  {
    CFIndex Count = CFArrayGetCount(a1);
    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], Count, MEMORY[0x1E4F1D510]);
    CFIndex v6 = CFArrayGetCount(a1);
    id v13 = Mutable;
    if (v6)
    {
      CFIndex v7 = v6;
      for (CFIndex i = 0; i != v7; ++i)
      {
        CFDictionaryRef ValueAtIndex = (atomic_ullong **)CFArrayGetValueAtIndex(a1, i);
        TDescriptor::CopyLocalizedAttribute(ValueAtIndex[5], a2, 0, (atomic_ullong *)&v12);
        CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v13, memory_order_acquire), (const void *)atomic_load_explicit((atomic_ullong *volatile)&v12, memory_order_acquire));
      }
    }
  }
  else
  {
    id v13 = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  }
  unint64_t v10 = atomic_exchange((atomic_ullong *volatile)&v13, 0);

  return v10;
}

unint64_t CTFontDescriptorsCopyAttribute(const __CFArray *a1, void *a2)
{
  id values = a2;
  CFSetRef v3 = CFSetCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&values, 1, MEMORY[0x1E4F1D548]);
  unint64_t v4 = CTFontDescriptorsCopyAttributesInternal(a1, v3);

  return v4;
}

unint64_t CTFontDescriptorsCopyAttributesInternal(const __CFArray *a1, const __CFSet *a2)
{
  CFArrayRef v2 = (const __CFArray *)MEMORY[0x1F4188790](a1, a2);
  int v4 = v3;
  char v6 = v5;
  CFSetRef v8 = v7;
  CFArrayRef v9 = v2;
  uint64_t v100 = *MEMORY[0x1E4F143B8];
  if (v2) {
    CFIndex Count = CFArrayGetCount(v2);
  }
  else {
    CFIndex Count = 0;
  }
  unint64_t v63 = Count;
  if (v6) {
    CFMutableSetRef Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], Count, MEMORY[0x1E4F1D548]);
  }
  else {
    CFMutableSetRef Mutable = 0;
  }
  if (v8)
  {
    CFIndex v12 = CFSetGetCount(v8);
    *(void *)&long long v13 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v98 = v13;
    long long v97 = v13;
    long long v96 = v13;
    long long v95 = v13;
    long long v94 = v13;
    long long v93 = v13;
    long long v92 = v13;
    long long v91 = v13;
    long long v90 = v13;
    long long v89 = v13;
    long long v88 = v13;
    long long v87 = v13;
    long long v86 = v13;
    long long v85 = v13;
    long long v84 = v13;
    int v81 = 0;
    int v82 = 0;
    uint64_t v83 = 0;
    id v99 = &v84;
    if (v12)
    {
      std::vector<long,TInlineBufferAllocator<long,30ul>>::__vallocate[abi:nn180100](&v81, v12);
      char v14 = v6;
      int v15 = (char *)v82;
      bzero(v82, 8 * v12);
      int v16 = &v15[8 * v12];
      char v6 = v14;
      int v82 = v16;
      id v17 = (const void **)v81;
    }
    else
    {
      id v17 = 0;
    }
    CFSetGetValues(v8, v17);
  }
  else
  {
    CFIndex v12 = 0;
    *(void *)&long long v18 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v98 = v18;
    long long v97 = v18;
    long long v96 = v18;
    long long v95 = v18;
    long long v94 = v18;
    long long v93 = v18;
    long long v92 = v18;
    long long v91 = v18;
    long long v90 = v18;
    long long v89 = v18;
    long long v88 = v18;
    long long v87 = v18;
    long long v86 = v18;
    long long v85 = v18;
    long long v84 = v18;
    int v81 = 0;
    int v82 = 0;
    uint64_t v83 = 0;
    id v99 = &v84;
  }
  memset(v79, 170, sizeof(v79));
  id __p = 0;
  CFIndex v77 = 0;
  long long v78 = 0;
  CFIndex v80 = v79;
  char v57 = v6;
  if (v63)
  {
    if (!(v63 >> 60))
    {
      if (&v79[v63] <= (_OWORD *)&v80)
      {
        CFIndex v80 = &v79[v63];
        double v19 = v79;
      }
      else
      {
        double v19 = operator new(16 * v63);
      }
      int v64 = v6 & 3;
      CGSize v21 = &v19[v63];
      id __p = v19;
      long long v78 = v21;
      bzero(v19, 16 * v63);
      CFIndex v77 = v21;
      CFRange v22 = v74;
      memset(v74, 170, sizeof(v74));
      CFIndex v75 = v74;
      CFIndex v60 = v12;
      if (&v74[v63] <= &v75) {
        CFIndex v75 = &v74[v63];
      }
      else {
        CFRange v22 = operator new(8 * v63);
      }
      __base = v22;
      int v73 = &v22[v63];
      bzero(v22, 8 * v63);
      CFIndex v23 = 0;
      size_t v24 = 0;
      double v72 = v73;
      unint64_t v25 = v63;
      CFAllocatorRef v59 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      id v58 = (id)*MEMORY[0x1E4F1D260];
      int v62 = v4;
      CFArrayRef v61 = v9;
      while (1)
      {
        CFDictionaryRef ValueAtIndex = (const __CTFontDescriptor *)CFArrayGetValueAtIndex(v9, v23);
        uint64_t v27 = ValueAtIndex;
        id v65 = (id)0xAAAAAAAAAAAAAAAALL;
        if (v4)
        {
          double v28 = Mutable;
          id v66 = CFDictionaryCreateMutable(v59, v60, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          CFDictionaryRef v29 = CTFontDescriptorCopyAttributes(v27);
          uint64_t v30 = (const void **)v81;
          CFIndex v31 = (const void **)v82;
          while (v30 != v31)
          {
            uint64_t v32 = *v30;
            CFDictionaryRef v33 = v29;
            if (v33)
            {
              CFDictionaryRef v34 = v33;
              CFStringRef Value = CFDictionaryGetValue(v33, v32);

              if (Value) {
                CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v66, memory_order_acquire), v32, Value);
              }
            }
            else
            {
            }
            ++v30;
          }
          BOOL v36 = (void *)atomic_exchange((atomic_ullong *volatile)&v66, 0);

          CFMutableSetRef Mutable = v28;
          int v4 = v62;
          CFArrayRef v9 = v61;
          unint64_t v25 = v63;
        }
        else
        {
          BOOL v36 = (void *)CTFontDescriptorCopyAttribute(ValueAtIndex, *v81);
        }
        id v65 = v36;
        unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&v65, memory_order_acquire);
        if (!v64 && !explicit) {
          TCFRef<__CTFont const*>::Retain((atomic_ullong *)&v65, v58);
        }
        if (atomic_load_explicit((atomic_ullong *volatile)&v65, memory_order_acquire))
        {
          if (!Mutable) {
            goto LABEL_42;
          }
          CFSetRef v38 = Mutable;
          id v39 = (id)atomic_load_explicit((atomic_ullong *volatile)&v65, memory_order_acquire);
          CFRange v40 = v39;
          if (!v38)
          {

LABEL_42:
            uint64_t v42 = (const __CTFontDescriptor *)atomic_exchange((atomic_ullong *volatile)&v65, 0);
            *((void *)__base + v24) = (char *)__p + 16 * v24;
            size_t v20 = v24 + 1;
            double v43 = (const __CTFontDescriptor **)((char *)__p + 16 * v24);
            uint64_t *v43 = v27;
            v43[1] = v42;
            if (Mutable) {
              CFSetSetValue(Mutable, v42);
            }
            goto LABEL_44;
          }
          int v41 = CFSetContainsValue(v38, v39);

          if (!v41) {
            goto LABEL_42;
          }
        }
        size_t v20 = v24;
LABEL_44:

        ++v23;
        size_t v24 = v20;
        if (v23 == v25) {
          goto LABEL_45;
        }
      }
    }
LABEL_74:
    abort();
  }
  memset(v74, 170, sizeof(v74));
  size_t v20 = 0;
  __base = 0;
  double v72 = 0;
  int v73 = 0;
  CFIndex v75 = v74;
LABEL_45:
  if ((v57 & 2) != 0) {
    qsort(__base, v20, 8uLL, (int (__cdecl *)(const void *, const void *))CTFontDescriptorsCopyAttributesInternal(__CFArray const*,__CFSet const*,unsigned int,BOOL)::$_0::__invoke);
  }
  memset(v69, 170, sizeof(v69));
  id v66 = 0;
  CGAffineTransform v67 = 0;
  unsigned int v68 = 0;
  uint64_t v70 = v69;
  if (v20)
  {
    if (v20 >> 61) {
      goto LABEL_74;
    }
    if (&v69[v20] <= &v70)
    {
      uint64_t v70 = &v69[v20];
      size_t v44 = 8 * v20;
      double v45 = v69;
    }
    else
    {
      size_t v44 = 8 * v20;
      double v45 = operator new(8 * v20);
    }
    double v49 = (void **)&v45[v20];
    id v66 = v45;
    unsigned int v68 = v49;
    bzero(v45, v44);
    uint64_t v50 = 0;
    CGAffineTransform v67 = v49;
    do
    {
      *((void *)v66 + v5CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = *(void *)(*((void *)__base + v50) + 8);
      ++v50;
    }
    while (v20 != v50);
    double v46 = (const void **)v66;
    CGFloat v47 = v67;
    CGFloat v48 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
  }
  else
  {
    double v46 = 0;
    CGFloat v47 = 0;
    CGFloat v48 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
  }
  id v65 = CFArrayCreate(*v48, v46, ((char *)v47 - (char *)v46) >> 3, MEMORY[0x1E4F1D510]);
  unint64_t v51 = atomic_exchange((atomic_ullong *volatile)&v65, 0);

  CGFloat v52 = (void **)v66;
  double v53 = v67;
  if (v66 != v67)
  {
    do
    {
      double v54 = *v52++;
    }
    while (v52 != v53);
    CGFloat v52 = (void **)v66;
  }
  if (v52)
  {
    CGAffineTransform v67 = v52;
    if (v69 > v52 || &v70 <= (void **)v52) {
      operator delete(v52);
    }
  }
  if (__base)
  {
    double v72 = __base;
    if (v74 > __base || &v75 <= __base) {
      operator delete(__base);
    }
  }
  if (__p)
  {
    CFIndex v77 = __p;
    if (v79 > __p || &v80 <= __p) {
      operator delete(__p);
    }
  }
  id __p = &v81;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&__p);

  return v51;
}

unint64_t CTFontDescriptorsCopyAttributes(const __CFArray *a1, const __CFSet *a2)
{
  return CTFontDescriptorsCopyAttributesInternal(a1, a2);
}

uint64_t CTFontDescriptorIsValid(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 40);
    if ((*(_DWORD *)(v1 + 16) & 0x80000000) == 0) {
      TDescriptor::InitBaseFont(*(TDescriptor **)(result + 40), 0, 0.0);
    }
    unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(v1 + 32), memory_order_acquire);
    if (explicit)
    {
      int v3 = *(uint64_t (**)(void))(*(void *)explicit + 744);
      return v3();
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t CTFontDescriptorIsVisible(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 40);
    if ((*(_DWORD *)(v1 + 16) & 0x80000000) == 0) {
      TDescriptor::InitBaseFont(*(TDescriptor **)(result + 40), 0, 0.0);
    }
    unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(v1 + 32), memory_order_acquire);
    if (explicit) {
      return (*(unsigned int (**)(unint64_t))(*(void *)explicit + 696))(explicit) ^ 1;
    }
    else {
      return 1;
    }
  }
  return result;
}

uint64_t CTFontDescriptorIsAppleFont(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v1 = *(void *)(a1 + 40);
  if ((*(_DWORD *)(v1 + 16) & 0x80000000) == 0) {
    TDescriptor::InitBaseFont(*(TDescriptor **)(a1 + 40), 0, 0.0);
  }
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(v1 + 32), memory_order_acquire);
  if (!explicit) {
    return 0;
  }
  int v3 = *(uint64_t (**)(void))(*(void *)explicit + 704);

  return v3();
}

uint64_t CTFontDescriptorGetOptions(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(*(void *)(result + 40) + 16);
  }
  return result;
}

CTFontDescriptorRef CTFontDescriptorCreateCopyWithFamily(CTFontDescriptorRef original, CFStringRef family)
{
  if (!original) {
    return 0;
  }
  uint64_t v2 = *((void *)original + 5);
  if ((*(_DWORD *)(v2 + 16) & 0x80000000) == 0) {
    TDescriptor::InitBaseFont(*((TDescriptor **)original + 5), 0, 0.0);
  }
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(v2 + 32), memory_order_acquire);
  if (!explicit) {
    return 0;
  }
  (*(void (**)(id *__return_ptr))(*(void *)explicit + 752))(&v6);
  int v4 = (const __CTFontDescriptor *)atomic_exchange((atomic_ullong *volatile)&v6, 0);

  return v4;
}

double CTFontDescriptorGetLanguageAwareTextStyleSize(TDescriptorSource *a1, __CFString *a2, uint64_t *a3, const __CFString **a4, double *a5, const __CFString *a6)
{
  return TDescriptorSource::GetTextStyleSize(a1, a2, a3, a4, a5, 1, a6);
}

BOOL CTFontDescriptorHasPostScriptNameAlias(uint64_t a1, __CFString *a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t v3 = *(void *)(a1 + 40);
  if ((*(_DWORD *)(v3 + 16) & 0x80000000) == 0) {
    TDescriptor::InitBaseFont(*(TDescriptor **)(a1 + 40), 0, 0.0);
  }
  unint64_t explicit = (atomic_ullong *)atomic_load_explicit((atomic_ullong *volatile)(v3 + 32), memory_order_acquire);
  if (!explicit) {
    return 0;
  }

  return TBaseFont::HasPostScriptNameAlias(explicit, a2);
}

unint64_t CTFontDescriptorCreateForCSSFamily(__CFString *a1, __CFString *a2)
{
  TDescriptorSource::TDescriptorSource((TDescriptorSource *)&v6);
  TDescriptorSource::CreateDescriptorForCSSFamily(&v6, a1, a2, (atomic_ullong *)&v7);
  unint64_t v4 = atomic_exchange((atomic_ullong *volatile)&v7, 0);

  return v4;
}

unint64_t CTFontDescriptorCreateLastResort()
{
  TDescriptorSource::TDescriptorSource((TDescriptorSource *)&v2);
  TDescriptorSource::CopyLastResort(&v3);
  unint64_t v0 = atomic_exchange((atomic_ullong *volatile)&v3, 0);

  return v0;
}

unint64_t CTFontDescriptorCopyName(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = 0;
  if (a1 && a2)
  {
    uint64_t v3 = *(void *)(a1 + 40);
    if ((*(_DWORD *)(v3 + 16) & 0x80000000) == 0) {
      TDescriptor::InitBaseFont(*(TDescriptor **)(a1 + 40), 0, 0.0);
    }
    unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(v3 + 32), memory_order_acquire);
    if (explicit)
    {
      (*(void (**)(id *__return_ptr))(*(void *)explicit + 72))(&v6);
      unint64_t v2 = atomic_exchange((atomic_ullong *volatile)&v6, 0);
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

id CTFontDescriptorGetClientObject(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  id v3 = (id)atomic_load_explicit((atomic_ullong *volatile)(*(void *)(a1 + 40) + 40), memory_order_acquire);
  id v1 = (id)atomic_exchange((atomic_ullong *volatile)&v3, 0);

  return v1;
}

void CTFontDescriptorSetClientObject(uint64_t a1, void *a2)
{
  if (a1) {
    TCFRef<__CTFont const*>::Retain((atomic_ullong *)(*(void *)(a1 + 40) + 40), a2);
  }
}

unint64_t CTFontDescriptorCopyDefaultCascadeListForLanguages(uint64_t a1, __CFArray *a2)
{
  return CTFontDescriptorCopyDefaultCascadeListForLanguagesWithOption(a1, a2, -1);
}

unint64_t CTFontDescriptorCopyDefaultCascadeListForLanguagesWithOption(uint64_t a1, __CFArray *a2, uint64_t a3)
{
  uint64_t valuePtr = a3;
  if (!a1) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 40);
  if ((*(_DWORD *)(v4 + 16) & 0x80000000) == 0) {
    TDescriptor::InitBaseFont(*(TDescriptor **)(a1 + 40), 0, 0.0);
  }
  unint64_t explicit = (atomic_ullong *)atomic_load_explicit((atomic_ullong *volatile)(v4 + 32), memory_order_acquire);
  if (!explicit) {
    return 0;
  }
  if (valuePtr == -1)
  {
    TDescriptor::CopyAttribute((atomic_ullong *)v4, @"NSCTFontFallbackOptionAttribute", &v16);
    id v6 = (void *)atomic_exchange((atomic_ullong *volatile)&v16, 0);

    id v7 = v6;
    CFSetRef v8 = v7;
    if (v7)
    {
      CFNumberRef v9 = (const __CFNumber *)v7;
      CFNumberGetValue(v9, kCFNumberLongType, &valuePtr);
    }
    else
    {
      uint64_t valuePtr = 3;
    }
  }
  id v16 = (id)0xAAAAAAAAAAAAAAAALL;
  double v11 = (TDescriptor *)CreateCanonicalLanguages(a2, &v16);
  int v12 = *(_DWORD *)(v4 + 16);
  BOOL v13 = (TDescriptor::GetSystemUIFontOptions(v11) & v12) != 0;
  TBaseFont::CreateFallbacks(explicit, v13, valuePtr, 0, (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v16, memory_order_acquire), (atomic_ullong *)&v15);
  unint64_t v10 = atomic_exchange((atomic_ullong *volatile)&v15, 0);

  return v10;
}

CFComparisonResult CTFontDescriptorsCopyAttributesInternal(__CFArray const*,__CFSet const*,unsigned int,BOOL)::$_0::__invoke(void ***a1, void ***a2)
{
  return CompareLocalizedDescriptorsByTraitsAndPrecedence(**a1, **a2, 0, 1, 1, 1);
}

uint64_t TCFBase<TDescriptor>::ClassDebug(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40));
  if (result)
  {
    id v3 = (const void *)result;
    CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<%s: %p>{%@}", "CTFontDescriptor", a1, result);
    CFRelease(v3);
    return (uint64_t)v4;
  }
  return result;
}

CTFontRef CTFontCreateWithFontDescriptorAndOptions(CTFontDescriptorRef descriptor, CGFloat size, const CGAffineTransform *matrix, CTFontOptions options)
{
  CTFontDescriptorRef v24 = descriptor;
  sizedouble a = size;
  matrixdouble a = (CGAffineTransform *)matrix;
  if (!descriptor) {
    return 0;
  }
  id v7 = (TDescriptor *)*((void *)descriptor + 5);
  int v8 = *((_DWORD *)v7 + 4);
  uint64_t SystemUIFontOptions = TDescriptor::GetSystemUIFontOptions(descriptor);
  if ((SystemUIFontOptions & v8) != 0
    || (uint64_t SystemUIFontOptions = TFont::GetSystemUIFontOptions((TFont *)SystemUIFontOptions),
        (SystemUIFontOptions & options) == 0))
  {
    uint64_t v10 = TFont::GetSystemUIFontOptions((TFont *)SystemUIFontOptions);
    uint64_t v11 = options & 0x85 | 0x400;
    if ((v10 & options) == 0) {
      uint64_t v11 = options & 0x85;
    }
    id v21 = (id)0xAAAAAAAAAAAAAAAALL;
    TDescriptor::CreateMatchingDescriptor(v7, 0, size, (options >> 1) & 0x10000 | (((options >> 1) & 1) << 9) | v11, (atomic_ullong *)&v21);
    if (!atomic_load_explicit((atomic_ullong *volatile)&v21, memory_order_acquire))
    {
      if ((options & 0x20000000) != 0)
      {
        id v15 = 0;
        goto LABEL_12;
      }
      TDescriptorSource::TDescriptorSource((TDescriptorSource *)&v19);
      int v12 = *((_DWORD *)v7 + 4);
      BOOL v14 = (TDescriptor::GetSystemUIFontOptions(v13) & v12) != 0;
      TDescriptorSource::CreateDefaultDescriptor(v14, &v20);
    }
    id v20 = (id)0xAAAAAAAAAAAAAAAALL;
    unint64_t explicit = (const __CTFontDescriptor *)atomic_load_explicit((atomic_ullong *volatile)&v21, memory_order_acquire);
    TCFBase_NEW<CTFont,__CTFontDescriptor const*,double &,CGAffineTransform const*&,__CTFontDescriptor const*&>(&explicit, &sizea, &matrixa, &v24, &v19);
    id v20 = (id)atomic_exchange((atomic_ullong *volatile)&v19, 0);

    id v15 = (const __CTFont *)atomic_exchange((atomic_ullong *volatile)&v20, 0);
  }
  else
  {
    id v21 = (id)0xAAAAAAAAAAAAAAAALL;
    id v19 = descriptor;
    id v20 = (id)atomic_exchange((atomic_ullong *volatile)&v19, 0);
    TDescriptorSource::CopyPossibleSystemUIFontDescriptor((atomic_ullong *)&v20, 1, &v21);

    id v16 = (const __CTFontDescriptor *)atomic_load_explicit((atomic_ullong *volatile)&v21, memory_order_acquire);
    id v15 = CTFontCreateWithFontDescriptorAndOptions(v16, sizea, matrixa, options);
  }
LABEL_12:

  return v15;
}

CTFontRef CTFontCreateCopyWithSymbolicTraits(CTFontRef font, CGFloat size, const CGAffineTransform *matrix, CTFontSymbolicTraits symTraitValue, CTFontSymbolicTraits symTraitMask)
{
  if (!font) {
    return 0;
  }
  uint64_t v5 = *((void *)font + 5);
  if (!*(void *)(v5 + 400)) {
    return 0;
  }
  id v14 = (id)0xAAAAAAAAAAAAAAAALL;
  TFont::CopyDescriptor((TFont *)v5, 0, (atomic_ullong *)&v14);
  CopyWithSymbolicTraits = CTFontDescriptorCreateCopyWithSymbolicTraits((CTFontDescriptorRef)atomic_load_explicit((atomic_ullong *volatile)&v14, memory_order_acquire), symTraitValue, symTraitMask);
  uint64_t v11 = CopyWithSymbolicTraits;
  if (CopyWithSymbolicTraits)
  {
    if (size == 0.0) {
      size = *(double *)(v5 + 16);
    }
    int v12 = CTFontCreateWithFontDescriptor(CopyWithSymbolicTraits, size, matrix);
  }
  else
  {
    int v12 = 0;
  }

  return v12;
}

CTFontRef CTFontCreateCopyWithFamily(CTFontRef font, CGFloat size, const CGAffineTransform *matrix, CFStringRef family)
{
  if (!font) {
    return 0;
  }
  uint64_t v4 = *((void *)font + 5);
  uint64_t v5 = *(void *)(v4 + 400);
  if (!v5) {
    return 0;
  }
  id v10 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr))(*(void *)v5 + 752))(&v10);
  if (atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire))
  {
    if (size == 0.0) {
      size = *(double *)(v4 + 16);
    }
    int v8 = CTFontCreateWithFontDescriptor((CTFontDescriptorRef)atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire), size, matrix);
  }
  else
  {
    int v8 = 0;
  }

  return v8;
}

CTFontRef CTFontCreateForString(CTFontRef currentFont, CFStringRef string, CFRange range)
{
  return CTFontCreateForStringWithLanguage(currentFont, string, range, 0);
}

CTFontRef CTFontCreateForStringWithLanguage(CTFontRef currentFont, CFStringRef string, CFRange range, CFStringRef language)
{
  uint64_t v4 = 0;
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  if (currentFont && string)
  {
    CFIndex length = range.length;
    locatiouint64_t n = range.location;
    if (range.location + range.length > CFStringGetLength(string))
    {
      return 0;
    }
    else
    {
      uint64_t v10 = *((void *)currentFont + 5);
      *(void *)&long long v11 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v29[2] = v11;
      v29[3] = v11;
      v29[0] = v11;
      v29[1] = v11;
      memset(buffer, 0, sizeof(buffer));
      uint64_t v30 = v29;
      CharactersPtr = CFStringGetCharactersPtr(string);
      if (CharactersPtr)
      {
        BOOL v13 = (unsigned __int16 *)&CharactersPtr[location];
      }
      else
      {
        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::resize((uint64_t)buffer, length);
        v32.locatiouint64_t n = location;
        v32.CFIndex length = length;
        CFStringGetCharacters(string, v32, buffer[0]);
        BOOL v13 = buffer[0];
      }
      uint64_t v14 = (*(uint64_t (**)(void, unsigned __int16 *, CFIndex))(**(void **)(v10 + 400) + 816))(*(void *)(v10 + 400), v13, length);
      if (v14) {
        BOOL v16 = 0;
      }
      else {
        BOOL v16 = v15 == length;
      }
      if (v16
        || ((uint64_t v17 = v15, v14 + location == CFStringGetRangeOfCharacterClusterAtIndex()) ? (v19 = v17 == v18) : (v19 = 0),
            v19))
      {
        uint64_t v4 = currentFont;
      }
      else
      {
        id v25 = (id)0xAAAAAAAAAAAAAAAALL;
        uint64_t v26 = 0;
        uint64_t v20 = TCFBase<TFont>::Allocate();
        if (v20)
        {
          id v21 = (void *)v20;
          uint64_t v22 = v20 + 48;
          v21[2] = 0;
          v21[3] = TFont::Hash;
          v21[4] = 0;
          v21[5] = v22;
          TFont::TFont(v22, (unsigned int *)v10, v13, length, (__CFString *)language, 0xFFFFFFFFFFFFFFFFLL, 0, &v26);
          id v27 = v21;
          id v24 = (id)atomic_exchange((atomic_ullong *volatile)&v27, 0);
        }
        else
        {
          id v24 = 0;
        }
        id v25 = (id)atomic_exchange((atomic_ullong *volatile)&v24, 0);

        uint64_t v4 = (const __CTFont *)atomic_exchange((atomic_ullong *volatile)&v25, 0);
      }
      id v27 = buffer;
      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v27);
    }
  }
  return v4;
}

void *CTFontCreateForCharacters(void *a1, unsigned __int16 *a2, uint64_t a3, uint64_t *a4)
{
  return CTFontCreateForCharactersWithLanguageAndOption(a1, a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, a4);
}

void *CTFontCreateForCharactersWithLanguageAndOption(void *a1, unsigned __int16 *a2, uint64_t a3, __CFString *a4, unint64_t a5, uint64_t *a6)
{
  if (!a1) {
    return 0;
  }
  uint64_t v12 = a1[5];
  (*(void (**)(void))(**(void **)(v12 + 400) + 816))(*(void *)(v12 + 400));
  if (v13 != a3)
  {
    id v21 = (id)0xAAAAAAAAAAAAAAAALL;
    uint64_t v22 = 0;
    uint64_t v15 = TCFBase<TFont>::Allocate();
    if (v15)
    {
      BOOL v16 = (void *)v15;
      uint64_t v17 = v15 + 48;
      void v16[2] = 0;
      void v16[3] = TFont::Hash;
      v16[4] = 0;
      v16[5] = v17;
      TFont::TFont(v17, (unsigned int *)v12, a2, a3, a4, a5, a6 == 0, &v22);
      id v23 = v16;
      id v20 = (id)atomic_exchange((atomic_ullong *volatile)&v23, 0);
    }
    else
    {
      id v20 = 0;
    }
    id v21 = (id)atomic_exchange((atomic_ullong *volatile)&v20, 0);

    uint64_t v18 = v22;
    if (a6)
    {
      *a6 = v22;
      if (v18)
      {
LABEL_14:
        unint64_t v19 = atomic_exchange((atomic_ullong *volatile)&v21, 0);

        return (void *)v19;
      }
    }
    else if (v22 >= a3)
    {
      goto LABEL_14;
    }

    goto LABEL_14;
  }
  if (a6) {
    *a6 = a3;
  }

  return a1;
}

void *CTFontCreateForCharactersWithLanguage(void *a1, unsigned __int16 *a2, uint64_t a3, __CFString *a4, uint64_t *a5)
{
  return CTFontCreateForCharactersWithLanguageAndOption(a1, a2, a3, a4, 0xFFFFFFFFFFFFFFFFLL, a5);
}

uint64_t CTFontGetPhysicalSymbolicTraits(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(void *)(*(void *)(a1 + 40) + 400)) != 0) {
    return (*(uint64_t (**)(void))(*(void *)v1 + 528))();
  }
  else {
    return 0;
  }
}

unint64_t CTFontCreateForCharacterRange(uint64_t a1, const unsigned __int16 *a2, uint64_t a3, CFRange *a4)
{
  if (!a1) {
    return 0;
  }
  id v7 = *(atomic_ullong **)(a1 + 40);
  v15.locatiouint64_t n = 0;
  v15.CFIndex length = 0;
  id v14 = (id)0xAAAAAAAAAAAAAAAALL;
  uint64_t v8 = TCFBase<TFont>::Allocate();
  if (v8)
  {
    CFNumberRef v9 = (void *)v8;
    uint64_t v10 = (TFont *)(v8 + 48);
    v9[2] = 0;
    v9[3] = TFont::Hash;
    uint64_t v9[4] = 0;
    v9[5] = v10;
    TFont::TFont(v10, v7, a2, a3, &v15);
    id v16 = v9;
    id v13 = (id)atomic_exchange((atomic_ullong *volatile)&v16, 0);
  }
  else
  {
    id v13 = 0;
  }
  id v14 = (id)atomic_exchange((atomic_ullong *volatile)&v13, 0);

  if (a4) {
    *a4 = v15;
  }
  unint64_t v11 = atomic_exchange((atomic_ullong *volatile)&v14, 0);

  return v11;
}

CFDictionaryRef CTFontCopyTraits(CTFontRef font)
{
  if (!font) {
    return 0;
  }
  TBaseFont::CopyTraits(*(TBaseFont **)(*((void *)font + 5) + 400), **((_DWORD **)font + 5) & 1, &v3);
  CFDictionaryRef v1 = (const __CFDictionary *)atomic_exchange((atomic_ullong *volatile)&v3, 0);

  return v1;
}

double CTFontGetWidth(uint64_t a1)
{
  double v1 = 0.0;
  if (a1)
  {
    unint64_t v2 = *(atomic_ullong **)(*(void *)(a1 + 40) + 400);
    if (v2)
    {
      uint64_t explicit = atomic_load_explicit(v2 + 30, memory_order_acquire);
      if (explicit) {
        return *(double *)(explicit + 16);
      }
      uint64_t explicit = TBaseFont::CreateTraitsValues((TBaseFont *)v2);
      if (explicit) {
        return *(double *)(explicit + 16);
      }
    }
  }
  return v1;
}

uint64_t CTFontCopyQuickdrawInstances()
{
  return 0;
}

CFStringRef CTFontCopyDisplayName(CTFontRef font)
{
  if (!font) {
    return 0;
  }
  (*(void (**)(id *__return_ptr))(**(void **)(*((void *)font + 5) + 400) + 88))(&v3);
  CFStringRef v1 = (const __CFString *)atomic_exchange((atomic_ullong *volatile)&v3, 0);

  return v1;
}

CFStringRef CTFontCopyName(CTFontRef font, CFStringRef nameKey)
{
  CFStringRef v2 = 0;
  if (font && nameKey)
  {
    (*(void (**)(id *__return_ptr))(**(void **)(*((void *)font + 5) + 400) + 72))(&v4);
    CFStringRef v2 = (const __CFString *)atomic_exchange((atomic_ullong *volatile)&v4, 0);
  }
  return v2;
}

unint64_t CTFontCopyOTName(uint64_t a1, int a2)
{
  unint64_t v2 = 0;
  if (a1 && a2 < 0)
  {
    (*(void (**)(id *__return_ptr))(**(void **)(*(void *)(a1 + 40) + 400) + 80))(&v4);
    unint64_t v2 = atomic_exchange((atomic_ullong *volatile)&v4, 0);
  }
  return v2;
}

CFStringRef CTFontCopyLocalizedName(CTFontRef font, CFStringRef nameKey, CFStringRef *actualLanguage)
{
  CFStringRef v3 = 0;
  if (font && nameKey)
  {
    (*(void (**)(id *__return_ptr))(**(void **)(*((void *)font + 5) + 400) + 88))(&v5);
    CFStringRef v3 = (const __CFString *)atomic_exchange((atomic_ullong *volatile)&v5, 0);
  }
  return v3;
}

unint64_t CTFontCopyLocalizedNameWithLanguages(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = 0;
  if (a1 && a2 && a3)
  {
    (*(void (**)(id *__return_ptr))(**(void **)(*(void *)(a1 + 40) + 400) + 88))(&v5);
    unint64_t v3 = atomic_exchange((atomic_ullong *volatile)&v5, 0);
  }
  return v3;
}

unint64_t CTFontCopyLocalizedNameByIDWithLanguages(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = 0;
  if (a1 && a3)
  {
    (*(void (**)(id *__return_ptr))(**(void **)(*(void *)(a1 + 40) + 400) + 96))(&v5);
    unint64_t v3 = atomic_exchange((atomic_ullong *volatile)&v5, 0);
  }
  return v3;
}

unint64_t CTFontCopyLogicalCharacterSet(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  (*(void (**)(id *__return_ptr))(**(void **)(*(void *)(a1 + 40) + 400) + 768))(&v3);
  unint64_t v1 = atomic_exchange((atomic_ullong *volatile)&v3, 0);

  return v1;
}

CFStringEncoding CTFontGetStringEncoding(CTFontRef font)
{
  if (font) {
    return (*(uint64_t (**)(void))(**(void **)(*((void *)font + 5) + 400) + 416))();
  }
  else {
    return 256;
  }
}

uint64_t CTFontGetGlyphsForCharacterRange(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = 0;
  if (a1 && a2)
  {
    uint64_t result = *(void *)(*(void *)(a1 + 40) + 400);
    if (result)
    {
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)result + 672))(result, a3, a4, a2);
      return 1;
    }
  }
  return result;
}

uint64_t CTFontGetGlyphsAndAdvancesForCharacterRange(uint64_t a1, _WORD *a2, double *a3, uint64_t a4, uint64_t a5)
{
  uint64_t result = 0;
  if (a1)
  {
    id v7 = a2;
    if (a2)
    {
      uint64_t v8 = a3;
      if (a3)
      {
        uint64_t v9 = *(void *)(a1 + 40);
        uint64_t v10 = *(atomic_ullong **)(v9 + 400);
        if (v10)
        {
          uint64_t v11 = a5;
          uint64_t v12 = a4;
          if (a4 + a5 < 257 || *(unsigned char *)(v9 + 392)) {
            goto LABEL_9;
          }
          if ((*(unsigned int (**)(void))(*v10 + 712))(*(void *)(v9 + 400)))
          {
            uint64_t v10 = *(atomic_ullong **)(v9 + 400);
LABEL_9:
            (*(void (**)(atomic_ullong *, uint64_t, uint64_t, _WORD *))(*v10 + 672))(v10, v12, v11, v7);
            TFont::GetAdvancesForGlyphs(v9, (uint64_t)v7, v8, 2, v11, 0, 0, 0);
            return 1;
          }
          double UnscaledTrackAmount = TFont::GetUnscaledTrackAmount((TFont *)v9);
          TFont::GetScaledMatrix((TFont *)v9, &v22);
          double a = v22.a;
          uint64_t result = (uint64_t)TBaseFont::AcquireBMPDataCache(v10);
          if (result)
          {
            CFRange v15 = (os_unfair_lock_s *)result;
            v22.double b = 0.0;
            v22.c = -3.72066279e-103;
            *(void *)&v22.double a = result;
            if (v11 >= 1)
            {
              id v16 = (int8x16_t *)MEMORY[0x1E4F1DB30];
              do
              {
                TBMPDataCache::Iterator::GetDataForCharacter((TBMPDataCache::Iterator *)&v22, v12, (uint64_t)&v20);
                double v17 = v21;
                *v7++ = v20;
                int32x2_t v18 = vdup_n_s32(v17 != 0.0);
                v19.i64[0] = v18.u32[0];
                v19.i64[1] = v18.u32[1];
                *(int8x16_t *)uint64_t v8 = vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v19, 0x3FuLL)), (int8x16_t)COERCE_UNSIGNED_INT64(a * (UnscaledTrackAmount + v17)), *v16);
                v8 += 2;
                LODWORD(v12) = v12 + 1;
                --v11;
              }
              while (v11);
            }
            os_unfair_lock_unlock(v15 + 2);
            return 1;
          }
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return result;
}

BOOL CTFontGetVerticalGlyphsForCharacters(TShapingEngine *a1, const UniChar *a2, CGGlyph *a3, CFIndex a4)
{
  return a1 && a2 && a3 && TShapingEngine::ApplyVerticalForms(a1, a2, a3, a4);
}

__CFString *CTFontCopyStringForGlyph(uint64_t a1)
{
  if (!a1) {
    return &stru_1ED0677F8;
  }
  uint64_t v1 = *(void *)(*(void *)(a1 + 40) + 400);
  if (!v1) {
    return &stru_1ED0677F8;
  }
  id v4 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr))(*(void *)v1 + 680))(&v4);
  if (!atomic_load_explicit((atomic_ullong *volatile)&v4, memory_order_acquire))
  {

    return &stru_1ED0677F8;
  }
  unint64_t v2 = atomic_exchange((atomic_ullong *volatile)&v4, 0);

  return (__CFString *)v2;
}

CFIndex CTFontGetGlyphCount(CFIndex font)
{
  if (font) {
    return TBaseFont::GetGlyphCount(*(TBaseFont **)(*(void *)(font + 40) + 400));
  }
  return font;
}

CGFloat CTFontGetSlantAngle(CTFontRef font)
{
  if (!font) {
    return 0.0;
  }
  uint64_t v1 = (TFont *)*((void *)font + 5);
  uint64_t v2 = *((void *)v1 + 50);
  TFont::GetScaledMatrix(v1, &v4);
  (*(void (**)(uint64_t, CGAffineTransform *))(*(void *)v2 + 616))(v2, &v4);
  return result;
}

double CTFontGetDefaultAscent(uint64_t a1)
{
  if (!a1) {
    return 0.0;
  }
  double v4 = NAN;
  TFont::GetDefaultMetrics(*(TFont **)(a1 + 40), &v4, &v3, &v2);
  return v4;
}

double CTFontGetMaximumAdvance(uint64_t a1)
{
  if (!a1) {
    return 0.0;
  }
  TFont::GetMaxAdvance(*(TFont **)(a1 + 40));
  return result;
}

uint64_t CTFontGetClippingMetrics(uint64_t result, double *a2, double *a3)
{
  if (result) {
    return TFont::GetWinMetrics(*(TBaseFont ***)(result + 40), a2, a3);
  }
  return result;
}

uint64_t CTFontGetTypographicMetrics(uint64_t a1, double *a2, double *a3, double *a4, unsigned char *a5)
{
  if (!a1) {
    return 0;
  }
  id v6 = *(TBaseFont ***)(a1 + 40);
  uint64_t TypoMetrics = TFont::GetTypoMetrics(v6, a2, a3, a4);
  uint64_t v8 = TypoMetrics;
  if (!TypoMetrics)
  {
    if (a5) {
      goto LABEL_6;
    }
    return 0;
  }
  if (!a5) {
    return 1;
  }
  LOBYTE(TypoMetrics) = TFont::UseTypoMetrics((TFont *)v6);
LABEL_6:
  *a5 = TypoMetrics;
  return v8;
}

uint64_t CTFontShouldAntiAlias()
{
  return 1;
}

uint64_t CTFontSupportsConnectedLanguage(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(void *)(*(void *)(a1 + 40) + 400)) != 0) {
    return (*(uint64_t (**)(void))(*(void *)v1 + 392))();
  }
  else {
    return 0;
  }
}

double CTFontGetTrackingFloor(uint64_t a1)
{
  if (!a1) {
    return 0.0;
  }
  double result = COERCE_DOUBLE(TFont::GetTrackingFloor(*(TFont **)(a1 + 40)));
  if (!v2) {
    return -1.79769313e308;
  }
  return result;
}

CGGlyph CTFontGetGlyphWithName(CTFontRef font, CFStringRef glyphName)
{
  if (font && glyphName) {
    return TFont::GetGlyphWithName(*((TFont **)font + 5), glyphName);
  }
  else {
    return 0;
  }
}

CFStringRef CTFontCopyNameForGlyph(CTFontRef font, CGGlyph glyph)
{
  if (!font) {
    return 0;
  }
  TFont::CopyNameForGlyph(*((TFont **)font + 5), glyph, (CFStringRef *)&v4);
  CFStringRef v2 = (const __CFString *)atomic_exchange((atomic_ullong *volatile)&v4, 0);

  return v2;
}

double CTFontGetTransformedBoundingRectsForGlyphsAndStyle(uint64_t a1, unsigned __int32 a2, char a3, CGAffineTransform *a4, const unsigned __int16 *a5, CGRect *a6, unint64_t a7)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (!a1 || !a5) {
    return *MEMORY[0x1E4F1DB20];
  }
  memset(v19, 170, sizeof(v19));
  memset(v18, 0, sizeof(v18));
  __int16 v20 = v19;
  if (!a6)
  {
    std::vector<CGRect,TInlineBufferAllocator<CGRect,30ul>>::resize(v18, a7);
    a6 = (CGRect *)v18[0];
  }
  TFont::GetBoundingBoxesForGlyphs(*(TBaseFont ***)(a1 + 40), a4, a3, a5, a6, a7, a2);
  double v15 = v14;
  double v17 = v18;
  std::vector<CGRect,TInlineBufferAllocator<CGRect,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v17);
  return v15;
}

void std::vector<CGSize,TInlineBufferAllocator<CGSize,30ul>>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 4;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 16 * a2;
    }
  }
  else
  {
    std::vector<CGSize,TInlineBufferAllocator<CGSize,30ul>>::__append((char **)a1, a2 - v2);
  }
}

void CTFontGetVerticalTranslationsForGlyphs(CTFontRef font, const CGGlyph *glyphs, CGSize *translations, CFIndex count)
{
  if (font && glyphs && translations && count >= 1) {
    TFont::GetVerticalTranslationsForGlyphs(*((TFont **)font + 5), glyphs, (float64x2_t *)translations, count);
  }
}

CFIndex CTFontGetLigatureCaretPositions(CTFontRef font, CGGlyph glyph, CGFloat *positions, CFIndex maxPositions)
{
  if (font && (positions || !maxPositions)) {
    return TFont::GetLigatureCaretPositionsForGlyph(*((TFont **)font + 5), glyph, positions, maxPositions);
  }
  else {
    return 0;
  }
}

CGRect CTFontGetOpticalBoundsForGlyphs(CTFontRef font, const CGGlyph *glyphs, CGRect *boundingRects, CFIndex count, CFOptionFlags options)
{
  v24[1] = *MEMORY[0x1E4F143B8];
  if (font && glyphs && count > 0)
  {
    id v7 = boundingRects;
    *(void *)&long long v9 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v23[0] = v9;
    v23[1] = v9;
    id __p = 0;
    v24[0] = v23;
    if (!boundingRects)
    {
      if ((unint64_t)count >> 59) {
        abort();
      }
      if (&v23[2 * count] <= (_OWORD *)v24)
      {
        v24[0] = &v23[2 * count];
        size_t v10 = 32 * count;
        id v7 = (CGRect *)v23;
      }
      else
      {
        size_t v10 = 32 * count;
        id v7 = (CGRect *)operator new(32 * count);
      }
      bzero(v7, v10);
      id __p = v7;
    }
    double OpticalBoundsForGlyphs = TFont::GetOpticalBoundsForGlyphs(*((TFont **)font + 5), glyphs, v7, count);
    double v13 = v12;
    double v15 = v14;
    double v17 = v16;
    if (__p && (v23 > (_OWORD *)__p || v24 <= (void *)__p)) {
      operator delete(__p);
    }
  }
  else
  {
    double OpticalBoundsForGlyphs = *MEMORY[0x1E4F1DB20];
    double v13 = *(double *)(MEMORY[0x1E4F1DB20] + 8);
    double v15 = *(double *)(MEMORY[0x1E4F1DB20] + 16);
    double v17 = *(double *)(MEMORY[0x1E4F1DB20] + 24);
  }
  double v18 = OpticalBoundsForGlyphs;
  double v19 = v13;
  double v20 = v15;
  double v21 = v17;
  result.size.CGFloat height = v21;
  result.size.CGFloat width = v20;
  result.origin.CGFloat y = v19;
  result.origin.CGFloat x = v18;
  return result;
}

unint64_t CTFontCopyVariationAxesInternal(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  (*(void (**)(id *__return_ptr))(**(void **)(*(void *)(a1 + 40) + 400) + 120))(&v3);
  unint64_t v1 = atomic_exchange((atomic_ullong *volatile)&v3, 0);

  return v1;
}

CFDictionaryRef CTFontCopyVariation(CTFontRef font)
{
  if (!font) {
    return 0;
  }
  (*(void (**)(id *__return_ptr))(**(void **)(*((void *)font + 5) + 400) + 112))(&v3);
  CFDictionaryRef v1 = (const __CFDictionary *)atomic_exchange((atomic_ullong *volatile)&v3, 0);

  return v1;
}

CFArrayRef CTFontCopyFeatures(CTFontRef font)
{
  if (!font) {
    return 0;
  }
  (*(void (**)(id *__return_ptr))(**(void **)(*((void *)font + 5) + 400) + 136))(&v3);
  CFArrayRef v1 = (const __CFArray *)atomic_exchange((atomic_ullong *volatile)&v3, 0);

  return v1;
}

unint64_t CTFontCopyFeaturesInternal(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  (*(void (**)(id *__return_ptr))(**(void **)(*(void *)(a1 + 40) + 400) + 136))(&v3);
  unint64_t v1 = atomic_exchange((atomic_ullong *volatile)&v3, 0);

  return v1;
}

CFArrayRef CTFontCopyFeatureSettings(CFArrayRef font)
{
  if (font) {
    return (CFArrayRef)(id)atomic_load_explicit((atomic_ullong *volatile)(*((void *)font + 5) + 168), memory_order_acquire);
  }
  return font;
}

BOOL CTFontHasFeatureWithTypeAndSelector(uint64_t a1, int a2, int a3)
{
  return a1 && (id v3 = *(TBaseFont **)(*(void *)(a1 + 40) + 400)) != 0 && TBaseFont::HasFeature(v3, a2, a3);
}

unint64_t CTFontCopyOTFontFeatureTable(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  (*(void (**)(id *__return_ptr))(**(void **)(*(void *)(a1 + 40) + 400) + 144))(&v3);
  unint64_t v1 = atomic_exchange((atomic_ullong *volatile)&v3, 0);

  return v1;
}

__CFDictionary *CTFontCopyConvertedTables(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  CFMutableSetRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  id v5 = (id)0xAAAAAAAAAAAAAAAALL;
  id v6 = 0;
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 400);
  id v7 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr, uint64_t, uint64_t))(*(void *)v3 + 480))(&v7, v3, 1196643650);
  if (atomic_load_explicit((atomic_ullong *volatile)&v7, memory_order_acquire))
  {
    CopyConvertedMorxFromGSUB(v3, atomic_load_explicit((atomic_ullong *volatile)&v7, memory_order_acquire));
  }
  else
  {

    id v5 = 0;
  }
  if (atomic_load_explicit((atomic_ullong *volatile)&v5, memory_order_acquire))
  {
    CFDictionaryAddValue(Mutable, @"amor", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v5, memory_order_acquire));
    if (atomic_load_explicit((atomic_ullong *volatile)&v6, memory_order_acquire)) {
      CFDictionaryAddValue(Mutable, @"ltag", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v6, memory_order_acquire));
    }
  }

  return Mutable;
}

unint64_t CTFontCopySampleLettersWithLanguages(uint64_t a1, unsigned int a2, const __CFArray *a3, void **a4)
{
  if (!a1) {
    return 0;
  }
  TSampleManager::TSampleManager((TSampleManager *)&v10);
  TSampleManagerImp::Copy(v10, 0, *(atomic_ullong **)(*(void *)(a1 + 40) + 400), a2, a3, a4, (unint64_t *)&v12);
  id v11 = (id)atomic_exchange((atomic_ullong *volatile)&v12, 0);

  unint64_t v8 = atomic_exchange((atomic_ullong *volatile)&v11, 0);
  return v8;
}

unint64_t CTFontCopySampleString(uint64_t a1, unsigned int a2)
{
  return CTFontCopySampleStringWithLanguages(a1, a2, MEMORY[0x1E4F1CBF0], 0);
}

unint64_t CTFontCopySampleStringWithLanguages(uint64_t a1, unsigned int a2, const __CFArray *a3, void **a4)
{
  if (!a1) {
    return 0;
  }
  TSampleManager::TSampleManager((TSampleManager *)&v10);
  TSampleManager::CopySampleString(&v10, *(atomic_ullong **)(*(void *)(a1 + 40) + 400), a2, a3, a4, &v11);
  unint64_t v8 = atomic_exchange((atomic_ullong *volatile)&v11, 0);

  return v8;
}

unint64_t CTCopySampleStringForLanguage(void *a1, unsigned int a2)
{
  id v8 = (id)0xAAAAAAAAAAAAAAAALL;
  TSampleManager::TSampleManager((TSampleManager *)&v7);
  TSampleManagerImp::CopySampleLettersForLanguage(a1, (atomic_ullong *)v7, a2, &v8);
  TSampleManager::CreateStringWithLetters((TSampleManager *)atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire), v4, &v7);
  unint64_t v5 = atomic_exchange((atomic_ullong *volatile)&v7, 0);

  return v5;
}

char *CTFontSwapEmojiPolicy(unsigned int a1)
{
  return SetThreadSpecificData(7, a1, (uint64_t (*)(void *))ThreadSpecificNullDestructor<CTEmojiPolicy>);
}

void CTFontEnumerateOverlappingGlyphs(uint64_t a1, unsigned __int16 *a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6)
{
  if (a1 && a2 && a3)
  {
    if (a4) {
      EnumerateOverlappingGlyphs(*(atomic_ullong **)(*(void *)(a1 + 40) + 400), a2, a3, a4, a6);
    }
  }
}

uint64_t CTFontGetDescriptorOptions(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  unint64_t v1 = (id)atomic_load_explicit((atomic_ullong *volatile)(*(void *)(a1 + 40) + 8), memory_order_acquire);
  uint64_t v2 = *(unsigned int *)(v1[5] + 16);

  return v2;
}

BOOL CTFontHasDerivedOpticalSize(BOOL result)
{
  if (result) {
    return TFont::HasDerivedOpticalSize(*(TFont **)(result + 40));
  }
  return result;
}

void CTFontDrawGlyphsAtPoint(uint64_t a1, const CGGlyph *a2, unint64_t a3, CGContext *a4)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  if (a1 && a2 && a3)
  {
    if (a4)
    {
      id v7 = *(CGContext **)(a1 + 40);
      *(void *)&long long v8 = -1;
      *((void *)&v8 + 1) = -1;
      *(_OWORD *)&v26.c = v8;
      *(_OWORD *)&v26.tCGFloat x = v8;
      *(_OWORD *)&v26.double a = v8;
      GetFontScaleTransform(&v26, v7);
      CGContextGetCharacterSpacing();
      CGAffineTransformMakeTranslation(&v24, v9, v9);
      *(CGAffineTransform *)CGAffineTransform t1 = v26;
      CGAffineTransform t2 = v24;
      CGAffineTransformConcat(&v25, (CGAffineTransform *)t1, &t2);
      CGAffineTransform v26 = v25;
      *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long v54 = v10;
      long long v55 = v10;
      long long v52 = v10;
      long long v53 = v10;
      long long v50 = v10;
      long long v51 = v10;
      long long v48 = v10;
      long long v49 = v10;
      long long v46 = v10;
      long long v47 = v10;
      long long v44 = v10;
      long long v45 = v10;
      long long v42 = v10;
      long long v43 = v10;
      long long v41 = v10;
      long long v40 = v10;
      long long v39 = v10;
      long long v38 = v10;
      long long v37 = v10;
      long long v36 = v10;
      long long v35 = v10;
      long long v34 = v10;
      long long v33 = v10;
      long long v32 = v10;
      long long v31 = v10;
      long long v30 = v10;
      long long v29 = v10;
      long long v28 = v10;
      *(_OWORD *)&t1[40] = v10;
      *(_OWORD *)&t1[24] = v10;
      memset(t1, 0, 24);
      CGFloat v56 = &t1[24];
      std::vector<CGPoint,TInlineBufferAllocator<CGPoint,30ul>>::__vallocate[abi:nn180100]((char **)t1, a3);
      uint64_t v11 = *(void *)&t1[8];
      bzero(*(void **)&t1[8], 16 * a3);
      *(void *)&t1[8] = v11 + 16 * a3;
      TFont::GetUnsummedAdvancesForGlyphs((uint64_t)v7, (uint64_t)a2, *(double **)t1, 2, a3, 0, 0);
      memset(&t2, 255, sizeof(t2));
      long long v20 = xmmword_184B89B60;
      float64x2_t v21 = (float64x2_t)unk_184B89B70;
      long long v22 = xmmword_184B89B80;
      float64x2_t v19 = (float64x2_t)unk_184B89B50;
      long long v12 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
      *(_OWORD *)&t2.double a = *MEMORY[0x1E4F1DAB8];
      *(_OWORD *)&t2.c = v12;
      float64x2_t v14 = *(float64x2_t *)MEMORY[0x1E4F1DAB8];
      float64x2_t v13 = *(float64x2_t *)(MEMORY[0x1E4F1DAB8] + 16);
      *(_OWORD *)&t2.tCGFloat x = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 32);
      float64x2_t v19 = v14;
      float64x2_t v15 = *(float64x2_t *)(MEMORY[0x1E4F1DAB8] + 32);
      long long v20 = (__int128)v13;
      float64x2_t v21 = v15;
      *(void *)&long long v22 = 0;
      BYTE8(v22) = 0;
      HIDWORD(v22) = 13;
      uint64_t v23 = 0;
      v17[0] = v14;
      v17[1] = v13;
      v17[2] = v15;
      CGAffineTransform v16 = v26;
      DrawGlyphsWithAdvancesAndTransform((TBaseFont **)v7, a2, *(uint64_t *)t1, a3, a4, v17, &v16.a, (uint64_t)&t2);
      *(void *)&t2.double a = t1;
      std::vector<CGPoint,TInlineBufferAllocator<CGPoint,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&t2);
    }
  }
}

CGAffineTransform *GetFontScaleTransform(CGAffineTransform *a1, CGContext *a2)
{
  CGContextGetFontSize();
  double v5 = v4;
  if (*((_DWORD *)a2 + 12)) {
    initedouble d = (int *)((char *)a2 + 48);
  }
  else {
    initedouble d = TFont::InitStrikeMetrics(a2);
  }
  unsigned int v7 = *inited;
  double v8 = v5 * (TFont::GetEffectiveSize(a2) / *((double *)a2 + 2)) / (double)v7;

  return CGAffineTransformMakeScale(a1, v8, v8);
}

double CTFontGetSbixImageSizeForGlyph(uint64_t a1, unsigned int a2, CGContext *a3)
{
  if (!a3) {
    return 0.0;
  }
  double ContentsScale = GetContentsScale(a3);

  return CTFontGetSbixImageSizeForGlyphAndContentsScale(a1, a2, ContentsScale);
}

long double GetContentsScale(CGContext *a1)
{
  unsigned int Type = CGContextGetType();
  if (Type <= 6 && ((1 << Type) & 0x46) != 0) {
    return 300.0;
  }
  *(void *)&long long v4 = -1;
  *((void *)&v4 + 1) = -1;
  *(_OWORD *)&v5.c = v4;
  *(_OWORD *)&v5.tCGFloat x = v4;
  *(_OWORD *)&v5.double a = v4;
  CGContextGetUserSpaceToDeviceSpaceTransform(&v5, a1);
  return hypot(v5.c, v5.d);
}

double CTFontGetSbixImageSizeForGlyphAndContentsScale(uint64_t a1, unsigned int a2, double a3)
{
  if (!a1) {
    return 0.0;
  }
  CGAffineTransform v5 = *(TBaseFont ***)(a1 + 40);
  id v19 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr))(*(void *)v5[50] + 480))(&v19);
  if (atomic_load_explicit((atomic_ullong *volatile)&v19, memory_order_acquire))
  {
    memset(v18, 170, sizeof(v18));
    uint64_t explicit = (void *)atomic_load_explicit((atomic_ullong *volatile)&v19, memory_order_acquire);
    TBaseFont::GetGlyphCount(v5[50]);
    TsbixContext::TsbixContext((TsbixContext *)v18, explicit);
    v13[0] = -1;
    v13[1] = -1;
    id v14 = (id)0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v7 = -1;
    *((void *)&v7 + 1) = -1;
    long long v15 = v7;
    long long v16 = v7;
    *(double *)&uint64_t v17 = NAN;
    double ColorBitmapFontTranslate = TFont::GetColorBitmapFontTranslate((TFont *)v5);
    CGFloat v10 = v9;
    v20.CGFloat x = ColorBitmapFontTranslate;
    v20.CGFloat y = v10;
    double v11 = *(double *)&v17;
  }
  else
  {
    double v11 = 0.0;
  }

  return v11;
}

CGFont *TFont::HasBBoxes(TFont *this, const unsigned __int16 *a2, size_t a3, CGRect *a4)
{
  CGRect result = (CGFont *)TBaseFont::GetInitializedGraphicsFont(this);
  if (result)
  {
    return (CGFont *)CGFontGetGlyphBBoxes(result, a2, a3, a4);
  }
  return result;
}

double CTFontDrawGlyphsAtPositions(uint64_t a1, const CGGlyph *a2, const CGPoint *a3, uint64_t a4, CGContext *a5)
{
  *(void *)&double result = CTFontDrawGlyphsAtPositionsInternal(a1, a2, a3, a4, a5, 0, 0).n128_u64[0];
  return result;
}

CFArrayRef CTFontCopyDefaultCascadeList()
{
  unint64_t v0 = (const __CTFontDescriptor *)CTFontDescriptorCreateForUIType(0, 0, 0.0);
  memcpy(__dst, &unk_184B89B98, sizeof(__dst));
  TFont::TFont((TFont *)__dst, v0, 0.0, 0, 0, 0);
  CFArrayRef DefaultFallbacks = (const __CFArray *)TFont::GetDefaultFallbacks((TFont *)__dst);
  if (DefaultFallbacks) {
    CopCGFloat y = CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], DefaultFallbacks);
  }
  else {
    CopCGFloat y = 0;
  }
  TFont::~TFont((TFont *)__dst);

  return Copy;
}

unint64_t TFont::GetDefaultFallbacks(TFont *this)
{
  uint64_t v2 = (atomic_ullong *)*((void *)this + 50);
  int IsSystemUIFontAndForShaping = TFont::IsSystemUIFontAndForShaping((atomic_ullong *)this, &v6);
  unint64_t v4 = ((unint64_t)*(unsigned int *)this >> 6) & 7;

  return TBaseFont::GetDefaultFallbacks(v2, IsSystemUIFontAndForShaping, v4);
}

CFArrayRef CTFontCopyDefaultCascadeListForLanguages(CTFontRef font, CFArrayRef languagePrefList)
{
  if (!font) {
    return 0;
  }
  id v4 = (id)0xAAAAAAAAAAAAAAAALL;
  TFont::CreateDefaultCascadeList(*((TFont **)font + 5), languagePrefList, (atomic_ullong *)&v4);
  if (atomic_load_explicit((atomic_ullong *volatile)&v4, memory_order_acquire)) {
    CopCGFloat y = CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v4, memory_order_acquire));
  }
  else {
    CopCGFloat y = 0;
  }

  return Copy;
}

void CTFontInitializeShapingGlyphs(uint64_t a1)
{
  if (a1)
  {
    unint64_t v1 = *(TFont **)(a1 + 40);
    if (!*((void *)v1 + 40)) {
      TFont::InitShapingGlyphs(v1);
    }
  }
}

__n128 CTFontShapeGlyphs(const __CTFont *a1, unsigned __int16 *a2, CGSize *a3, CGPoint *a4, uint64_t *a5, uint64_t a6, void **a7, unsigned int a8, __CFString *a9, uint64_t a10)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  long long v38 = a2;
  if (!a1 || !a2 || !a3 || !a4 || !a5 || !a10 || (uint64_t)a7 <= 0) {
    return *(__n128 *)MEMORY[0x1E4F1DB30];
  }
  *(void *)&long long v32 = a6;
  memcpy(v42, &unk_184B89DC0, sizeof(v42));
  TRunGlue::TRunGlue((TRunGlue *)v42, a1, a2, a3, (uint64_t)a7, *a5, a4, a5);
  uint64_t v17 = (atomic_ullong *)*((void *)&v42[38] + 1);
  int ShapingType = TBaseFont::GetShapingType(*(TBaseFont **)(*((void *)&v42[38] + 1) + 400));
  BOOL HasAvailable = StackHasAvailable(0x8000uLL);
  if (!HasAvailable)
  {
    long long v29 = *MEMORY[0x1E4F1DB30];
    goto LABEL_34;
  }
  MEMORY[0x1F4188790](HasAvailable, v20);
  memset(v30, 170, 0x2000uLL);
  int v31 = ShapingType;
  if (ShapingType >= 2)
  {
    if (*(void *)&v42[39] <= 0x10000uLL) {
      size_t v21 = (unint64_t)(*(void *)&v42[39] + 7) >> 3;
    }
    else {
      size_t v21 = 0x2000;
    }
    bzero(v30, v21);
    TRunGlue::DetermineCoverage((uint64_t)v42, v30);
  }
  atomic_ullong v22 = v17[40];
  if (!v22)
  {
    if (qword_1EB2CDFA8 != -1) {
      dispatch_once_f(&qword_1EB2CDFA8, 0, (dispatch_function_t)GetShapingGlyphsQueue(void)::$_0::__invoke);
    }
    uint64_t v23 = qword_1EB2CDFA0;
    CFRetain(a1);
    dispatch_async_f(v23, a1, (dispatch_function_t)InitShapingGlyphsOnQueue(__CTFont const*,NSObject  {objcproto17OS_dispatch_queue}*)::$_0::__invoke);
  }
  v37[1] = (void **)*a5;
  v37[2] = a7;
  v37[0] = (void **)&unk_1ED05E588;
  v37[3] = (void **)v32;
  if ((a8 & 2) != 0)
  {
    v41[0] = &unk_1ED05FC90;
    v41[1] = a10;
    v41[2] = &v38;
    v41[3] = v41;
    std::function<BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::operator=(&v42[35], (uint64_t)v41);
    std::__function::__value_func<BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::~__value_func[abi:nn180100](v41);
    TRunGlue::InitPropertiesForCombining((TRunGlue *)v42, (const TCharStream *)v37);
    long long v35 = (void ***)v42;
    long long v36 = v37;
    char v34 = -86;
    char v33 = 0;
    TCombiningEngine::ResolveCombiningMarks(&v35, (a8 >> 2) & 1, &v34, &v33);
  }
  if ((a8 & 4) != 0) {
    TRunGlue::ReorderGlyphs((uint64_t)v42);
  }
  long long v35 = (void ***)0xAAAAAAAAAAAAAA00;
  LODWORD(v36) = -1431655936;
  if (v22)
  {
    CGAffineTransform v24 = v38;
    uint64_t v25 = TRunGlue::length((TRunGlue *)v42);
    BOOL v26 = TFont::NeedsShapingForGlyphs(v17, v24, v25, a9);
    int v27 = v31;
    if (v26)
    {
      if ((a8 & 2) == 0)
      {
        v40[0] = &unk_1ED05FC90;
        v40[1] = a10;
        v40[2] = &v38;
        v40[3] = v40;
        std::function<BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::operator=(&v42[35], (uint64_t)v40);
        std::__function::__value_func<BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::~__value_func[abi:nn180100](v40);
      }
      if (!TShapingEngine::ShapeGlyphs((uint64_t)v42, v27, a9, (uint64_t)&v35, (uint64_t)v37)) {
        goto LABEL_33;
      }
    }
  }
  else
  {
    if ((a8 & 2) == 0)
    {
      v39[0] = &unk_1ED05FC90;
      v39[1] = a10;
      v39[2] = &v38;
      void v39[3] = v39;
      std::function<BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::operator=(&v42[35], (uint64_t)v39);
      std::__function::__value_func<BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::~__value_func[abi:nn180100](v39);
    }
    int v27 = v31;
    if (!TShapingEngine::ShapeGlyphs((uint64_t)v42, v31, a9, (uint64_t)&v35, (uint64_t)v37)) {
      goto LABEL_33;
    }
  }
  TKerningEngine::PositionGlyphs((TRunGlue *)v42, v27, (const TFont *)v35, (char)v36, a9, (uint64_t)v37, a8);
LABEL_33:
  long long v29 = v42[34];
LABEL_34:
  long long v32 = v29;
  std::__function::__value_func<BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::~__value_func[abi:nn180100](&v42[35]);
  v37[0] = (void **)&v42[23];
  std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100](v37);
  v37[0] = (void **)&v42[13];
  std::vector<unsigned char,TInlineBufferAllocator<unsigned char,128ul>>::__destroy_vector::operator()[abi:nn180100](v37);
  v37[0] = (void **)&v42[3] + 1;
  std::vector<std::pair<UScriptCode,long>,TInlineBufferAllocator<std::pair<UScriptCode,long>,1ul>>::__destroy_vector::operator()[abi:nn180100](v37);
  return (__n128)v32;
}

unint64_t CTFontCopyColorGlyphCoverage(const void *a1)
{
  unint64_t v1 = _CTFontEnsureFontRef(a1);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = (TBaseFont **)*((void *)v1 + 5);
  GlyphCFIndex Count = TBaseFont::GetGlyphCount(v2[50]);
  id v20 = 0;
  if (TFont::ensureSVGTableObject((TFont *)v2))
  {
    if (!atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire))
    {
      CFMutableSetRef Mutable = CFBitVectorCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], GlyphCount);
      if (Mutable)
      {
        unint64_t v5 = (unint64_t)Mutable;
        CFBitVectorSetCount(Mutable, GlyphCount);
      }
    }
    if (atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire))
    {
      v18[1] = (id)MEMORY[0x1E4F143A8];
      _OWORD v18[2] = (id)3321888768;
      id v18[3] = __CTFontCopyColorGlyphCoverage_block_invoke;
      v18[4] = &__block_descriptor_48_8_40c29_ZTS6TCFRefIP13__CFBitVectorE_e13_v24__0___qq_8l;
      v18[5] = (id)GlyphCount;
      id v19 = (id)atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire);
      OTSVGTableEnumerateGlyphs();
    }
  }
  v18[0] = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr))(*(void *)v2[50] + 480))(v18);
  if (atomic_load_explicit((atomic_ullong *volatile)v18, memory_order_acquire))
  {
    if (!atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire))
    {
      BOOL v6 = CFBitVectorCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], GlyphCount);
      if (v6)
      {
        unint64_t v7 = (unint64_t)v6;
        CFBitVectorSetCount(v6, GlyphCount);
      }
    }
    if (atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire))
    {
      uint64_t v8 = 0xFFFFLL;
      if (GlyphCount < 0xFFFF) {
        uint64_t v8 = GlyphCount;
      }
      if (v8 >= 1)
      {
        CFIndex v9 = 0;
        uint64_t v10 = v8 & ~(v8 >> 63);
        do
        {
          if (TFont::HasColorBitmapForGlyph(v2, (unsigned __int16)v9, (const __CFData *)atomic_load_explicit((atomic_ullong *volatile)v18, memory_order_acquire)))
          {
            v21.locatiouint64_t n = v9;
            v21.CFIndex length = 1;
            CFBitVectorSetBits((CFMutableBitVectorRef)atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire), v21, 1u);
          }
          ++v9;
        }
        while (v10 != v9);
      }
    }
  }

  v18[0] = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr))(*(void *)v2[50] + 480))(v18);
  if (atomic_load_explicit((atomic_ullong *volatile)v18, memory_order_acquire))
  {
    if (!atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire))
    {
      double v11 = CFBitVectorCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], GlyphCount);
      if (v11)
      {
        unint64_t v12 = (unint64_t)v11;
        CFBitVectorSetCount(v11, GlyphCount);
      }
    }
    if (atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire))
    {
      CFDataRef explicit = (const __CFData *)atomic_load_explicit((atomic_ullong *volatile)v18, memory_order_acquire);
      v16[0] = MEMORY[0x1E4F143A8];
      v16[1] = 3321888768;
      void v16[2] = __CTFontCopyColorGlyphCoverage_block_invoke_22;
      void v16[3] = &__block_descriptor_48_8_40c29_ZTS6TCFRefIP13__CFBitVectorE_e13_v24__0___qq_8l;
      v16[4] = GlyphCount;
      id v17 = (id)atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire);
      EnumerateGlyphsWithLayerRecords(explicit, (uint64_t)v16);
    }
  }

  unint64_t v14 = atomic_exchange((atomic_ullong *volatile)&v20, 0);
  return v14;
}

void __CTFontCopyColorGlyphCoverage_block_invoke(uint64_t a1, CFRange a2)
{
  CFIndex v2 = *(void *)(a1 + 32);
  if (a2.location + a2.length >= v2) {
    CFIndex v3 = *(void *)(a1 + 32);
  }
  else {
    CFIndex v3 = a2.location + a2.length;
  }
  if (a2.location < 0 || a2.location >= v2)
  {
    BOOL v4 = a2.location + a2.length > 0 && a2.location < 1;
    a2.locatiouint64_t n = 0;
    if (v4) {
      a2.CFIndex length = v3;
    }
    else {
      a2.CFIndex length = 0;
    }
  }
  else
  {
    a2.CFIndex length = v3 - a2.location;
  }
  CFBitVectorSetBits((CFMutableBitVectorRef)atomic_load_explicit((atomic_ullong *volatile)(a1 + 40), memory_order_acquire), a2, 1u);
}

id __copy_helper_block_8_40c29_ZTS6TCFRefIP13__CFBitVectorE(uint64_t a1, uint64_t a2)
{
  id result = (id)atomic_load_explicit((atomic_ullong *volatile)(a2 + 40), memory_order_acquire);
  *(void *)(a1 + 4CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = result;
  return result;
}

void __destroy_helper_block_8_40c29_ZTS6TCFRefIP13__CFBitVectorE(uint64_t a1)
{
}

void __CTFontCopyColorGlyphCoverage_block_invoke_22(uint64_t a1, CFRange a2)
{
  CFIndex v2 = *(void *)(a1 + 32);
  if (a2.location + a2.length >= v2) {
    CFIndex v3 = *(void *)(a1 + 32);
  }
  else {
    CFIndex v3 = a2.location + a2.length;
  }
  if (a2.location < 0 || a2.location >= v2)
  {
    BOOL v4 = a2.location + a2.length > 0 && a2.location < 1;
    a2.locatiouint64_t n = 0;
    if (v4) {
      a2.CFIndex length = v3;
    }
    else {
      a2.CFIndex length = 0;
    }
  }
  else
  {
    a2.CFIndex length = v3 - a2.location;
  }
  CFBitVectorSetBits((CFMutableBitVectorRef)atomic_load_explicit((atomic_ullong *volatile)(a1 + 40), memory_order_acquire), a2, 1u);
}

CFBitVectorRef CTFontCopyGlyphCoverageForFeature(uint64_t a1, CFDictionaryRef theDict)
{
  if (a1 && (CFDictionaryRef v2 = theDict) != 0)
  {
    id v15 = 0;
    if (CFDictionaryGetValue(theDict, @"CTFeatureOpenTypeTag")
      && !CFDictionaryGetValue(v2, @"CTFeatureOpenTypeValue"))
    {
      CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      MutableCopCGFloat y = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v2);

      CFDataRef explicit = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire);
      LODWORD(MutableCopy) = 1;
      CFNumberRef v6 = CFNumberCreate(v4, kCFNumberIntType, &MutableCopy);
      CFDictionarySetValue(explicit, @"CTFeatureOpenTypeValue", v6);

      CFDictionaryRef v2 = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire);
    }
    unint64_t v7 = *(TBaseFont ***)(a1 + 40);
    uint64_t v8 = [[CTFeatureSetting alloc] initWithDictionary:v2];
    if (v8)
    {
      MutableCopCGFloat y = (id)0xAAAAAAAAAAAAAAAALL;
      TFont::CoverageForFeatureSetting(v7, v8, &MutableCopy);
      CFBitVectorRef v9 = (CFBitVectorRef)atomic_exchange((atomic_ullong *volatile)&MutableCopy, 0);
    }
    else
    {
      CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      GlyphCFIndex Count = TBaseFont::GetGlyphCount(v7[50]);
      CFBitVectorRef v9 = CFBitVectorCreate(v12, 0, GlyphCount);
    }

    return v9;
  }
  else
  {
    CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    return CFBitVectorCreate(v11, 0, 0);
  }
}

unint64_t CTFontCopyShapingLanguages(uint64_t a1)
{
  if (a1)
  {
    id v3 = (id)0xAAAAAAAAAAAAAAAALL;
    TFont::ShapingLanguages(*(TFont **)(a1 + 40), &v3);
  }
  else
  {
    id v3 = CFSetCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, MEMORY[0x1E4F1D548]);
  }
  unint64_t v1 = atomic_exchange((atomic_ullong *volatile)&v3, 0);

  return v1;
}

unint64_t CTFontCopyVariantsOfGlyph(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    id v4 = (id)0xAAAAAAAAAAAAAAAALL;
    TFont::CopyVariantsOfGlyph(*(TFont **)(a1 + 40), a2, &v4);
  }
  else
  {
    id v4 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  }
  unint64_t v2 = atomic_exchange((atomic_ullong *volatile)&v4, 0);

  return v2;
}

id CTFontCopyTallestTextStyleLanguageForString(const __CFString *a1)
{
  v25[4] = *MEMORY[0x1E4F143B8];
  if (qword_1EB2CE028 != -1) {
    dispatch_once_f(&qword_1EB2CE028, 0, (dispatch_function_t)GetExcessiveLineHeightCharacterSet(void)::$_0::__invoke);
  }
  if (!qword_1EB2CE020) {
    return 0;
  }
  *(_OWORD *)CFRange v21 = 0u;
  *(_OWORD *)id __p = 0u;
  unint64_t v23 = 0xAAAAAAAA3F800000;
  *(void *)&long long v2 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v20[0] = v2;
  v20[1] = v2;
  CFCharacterSetInitInlineBuffer();
  if (a1) {
    CFIndex Length = CFStringGetLength(a1);
  }
  else {
    CFIndex Length = 0;
  }
  v25[0] = &unk_1ED060158;
  v25[1] = v20;
  v25[2] = v21;
  v25[3] = v25;
  EnumerateCharactersInRange(a1, 0, Length, (uint64_t)v25);
  std::__function::__value_func<void ()(CFRange,unsigned int,BOOL *)>::~__value_func[abi:nn180100](v25);
  LOBYTE(v19) = -86;
  _ExuberatedGroupForPreferredLanguages((BOOL *)&v19, 0);
  int v4 = v19;
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableSetRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  unint64_t v7 = __p[0];
  if (__p[0])
  {
    do
    {
      if (v7[4] == 25)
      {
        CFArrayAppendValue(Mutable, @"vi");
      }
      else
      {
        uint64_t ShortName = uscript_getShortName();
        if (ShortName)
        {
          CFBitVectorRef v9 = (__CFString *)CFStringCreateWithFormat(v5, 0, @"und-%s", ShortName);
          id v19 = (id)0xAAAAAAAAAAAAAAAALL;
          LanguageIdentifierByNormalizing(v9, 0, (atomic_ullong *)&v19);
          if (atomic_load_explicit((atomic_ullong *volatile)&v19, memory_order_acquire))
          {
            if (!v4) {
              goto LABEL_20;
            }
            uint64_t v10 = (__CFString *)(id)atomic_load_explicit((atomic_ullong *volatile)&v19, memory_order_acquire);
            if (v10 == @"ar")
            {
            }
            else
            {
              CFAllocatorRef v11 = v10;
              if (!v10)
              {

                goto LABEL_20;
              }
              int v12 = CFEqual(v10, @"ar");

              if (!v12)
              {
LABEL_20:
                id v13 = (id)atomic_load_explicit((atomic_ullong *volatile)&v19, memory_order_acquire);
                CFArrayAppendValue(Mutable, v13);

                goto LABEL_21;
              }
            }
            CFArrayAppendValue(Mutable, @"ur");
          }
LABEL_21:
        }
      }
      unint64_t v7 = *(_DWORD **)v7;
    }
    while (v7);
  }
  id v19 = 0;
  BOOL v24 = -86;
  _ExuberatedGroupForPreferredLanguages(&v24, 0);
  _LargestExuberatedGroupForLanguages(Mutable, (const __CFString **)&v19, !v24, 0);
  id v14 = v19;

  id v15 = __p[0];
  if (__p[0])
  {
    do
    {
      long long v16 = (void *)*v15;
      operator delete(v15);
      id v15 = v16;
    }
    while (v16);
  }
  id v17 = v21[0];
  v21[0] = 0;
  if (v17) {
    operator delete(v17);
  }
  return v14;
}

CFCharacterSetRef _CTFontCopyPredefinedCharacterSet(TDescriptorSource *a1)
{
  return TDescriptorSource::CopyPredefinedCharacterSet(a1, (const __CFString *)1);
}

void *CTFontStrikeMetricsCreateDictionaryRepresentation(uint64_t a1)
{
  if (a1 && (unint64_t v1 = *(TBaseFont **)(*(void *)(a1 + 40) + 400)) != 0) {
    return TBaseFont::CreateStrikeMetricsDictionaryRepresentation(v1);
  }
  else {
    return 0;
  }
}

id CTFontCopyCharacterSetOfDefaultCascadeListForSystemUIFonts(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  unint64_t v1 = *(atomic_ullong **)(a1 + 40);
  if (!TFont::IsSystemUIFontAndForShaping(v1, &v5)) {
    return 0;
  }
  long long v2 = (atomic_ullong *)v1[50];
  if (!v2) {
    return 0;
  }
  DefaultComposite = (void *)TBaseFont::GetDefaultComposite(v2, 1, 3);

  return DefaultComposite;
}

CTFontRef CTFontCreateEmojiFontForFont(TFont **a1)
{
  if (!a1) {
    return 0;
  }
  long long v2 = a1[5];
  if (!(*(unsigned int (**)(void))(**((void **)v2 + 50) + 712))(*((void *)v2 + 50)))
  {
    TFont::CopyDescriptor(a1[5], 0, (atomic_ullong *)&v7);
    int v4 = (const __CTFontDescriptor *)atomic_exchange((atomic_ullong *volatile)&v7, 0);

    id v7 = (id)0xAAAAAAAAAAAAAAAALL;
    TDescriptorSource::TDescriptorSource((TDescriptorSource *)&v6);
    TDescriptorSource::CopyEmojiFontDescriptor((TDescriptorSource *)&v6, 0, v4, &v7);
    if (atomic_load_explicit((atomic_ullong *volatile)&v7, memory_order_acquire)) {
      CTFontRef v5 = CTFontCreateWithFontDescriptor((CTFontDescriptorRef)atomic_load_explicit((atomic_ullong *volatile)&v7, memory_order_acquire), *((CGFloat *)v2 + 2), 0);
    }
    else {
      CTFontRef v5 = 0;
    }

    return v5;
  }

  return (CTFontRef)a1;
}

CGImageRef CTFontCopyImageForGlyph(const void *a1, unsigned int a2, float64x2_t *a3, float64x2_t *a4, double a5)
{
  CFBitVectorRef v9 = _CTFontEnsureFontRef(a1);
  if (!v9) {
    return 0;
  }
  uint64_t v10 = (TBaseFont **)*((void *)v9 + 5);
  id v24 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr))(*(void *)v10[50] + 480))(&v24);
  if (atomic_load_explicit((atomic_ullong *volatile)&v24, memory_order_acquire))
  {
    memset(v23, 170, sizeof(v23));
    CFDataRef explicit = (void *)atomic_load_explicit((atomic_ullong *volatile)&v24, memory_order_acquire);
    TBaseFont::GetGlyphCount(v10[50]);
    TsbixContext::TsbixContext((TsbixContext *)v23, explicit);
    v18.f64[0] = NAN;
    v18.f64[1] = NAN;
    id v19 = (id)0xAAAAAAAAAAAAAAAALL;
    v12.f64[0] = NAN;
    v12.f64[1] = NAN;
    float64x2_t v20 = v12;
    float64x2_t v21 = v12;
    uint64_t v22 = -1;
    double ColorBitmapFontTranslate = TFont::GetColorBitmapFontTranslate((TFont *)v10);
    CGFloat v15 = v14;
    v25.CGFloat x = ColorBitmapFontTranslate;
    v25.CGFloat y = v15;
    CGImageRef v16 = CGImageRetain((CGImageRef)atomic_load_explicit((atomic_ullong *volatile)&v19, memory_order_acquire));
    if (v16)
    {
      if (a3) {
        *a3 = vaddq_f64(v20, v18);
      }
      if (a4) {
        *a4 = v21;
      }
    }
  }
  else
  {
    CGImageRef v16 = 0;
  }

  return v16;
}

double CTFontGetTypographicBoundsForAdaptiveImageProvider(void *a1)
{
  unint64_t v1 = EmojiFontForFont(a1);
  long long v2 = v1;
  if (v1)
  {
    uint64_t v3 = v1[5];
    __int16 v7 = *(_WORD *)TBaseFont::GetCachedSpaceAndJoinerGlyphs(*(atomic_ullong **)(v3 + 400), 0);
    double v6 = NAN;
    TFont::GetUnsummedAdvancesForGlyphs(v3, (uint64_t)&v7, &v6, 1, 1, 0, 0);
    int v4 = (TFont *)v2[5];
    if (!*((_DWORD *)v4 + 12))
    {
      TFont::InitStrikeMetrics(v4);
      int v4 = (TFont *)v2[5];
    }
    if (!*((_DWORD *)v4 + 12)) {
      TFont::InitStrikeMetrics(v4);
    }
  }
  return 0.0;
}

void *EmojiFontForFont(void *object)
{
  if (object
    && ((*(uint64_t (**)(void))(**(void **)(object[5] + 400) + 712))(*(void *)(object[5] + 400)) & 1) != 0)
  {
    return object;
  }
  AssociatedObject = objc_getAssociatedObject(object, (const void *)EmojiFontForFont(__CTFont const*)::sEmojiFontAssociationKey);
  if (!AssociatedObject)
  {
    AssociatedObject = CTFontCreateEmojiFontForFont((TFont **)object);
    uint64_t v3 = (const void *)EmojiFontForFont(__CTFont const*)::sEmojiFontAssociationKey;
    id v4 = (id)CFMakeCollectable(AssociatedObject);
    objc_setAssociatedObject(object, v3, v4, (void *)0x301);
  }
  return AssociatedObject;
}

CGImageRef CTFontCopyImageFromAdaptiveImageProvider(const __CTFont *a1, void *a2, float64x2_t *a3, double a4)
{
  if (!a1) {
    return 0;
  }
  v9.f64[0] = NAN;
  v9.f64[1] = NAN;
  id v10 = (id)0xAAAAAAAAAAAAAAAALL;
  v5.f64[0] = NAN;
  v5.f64[1] = NAN;
  float64x2_t v11 = v5;
  float64x2_t v12 = v5;
  uint64_t v13 = -1;
  if (a3)
  {
    float64x2_t v6 = v12;
    *a3 = vaddq_f64(v11, v9);
    a3[1] = v6;
  }
  CGImageRef v7 = CGImageRetain((CGImageRef)atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire));

  return v7;
}

_anonymous_namespace_::TCGImageData *anonymous namespace'::TCGImageData::TCGImageData(_anonymous_namespace_::TCGImageData *this, const __CTFont *a2, void *a3, double a4)
{
  uint64_t v8 = (_OWORD *)MEMORY[0x1E4F1DAD8];
  *(_OWORD *)this = *MEMORY[0x1E4F1DAD8];
  *((void *)this + 2) = 0;
  float64x2_t v9 = (char *)this + 24;
  *(_OWORD *)((char *)this + 24) = *v8;
  id v10 = (char *)this + 40;
  *(_OWORD *)((char *)this + 4CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = *MEMORY[0x1E4F1DB30];
  *((void *)this + 7) = 0;
  if (objc_opt_respondsToSelector())
  {
    float64x2_t v11 = EmojiFontForFont(a2);
    if (!v11) {
      return this;
    }
    float64x2_t v12 = (double *)v11[5];
    double v13 = v12[2];
    if (v13 <= 16.0)
    {
      double v14 = v13 * 0.25;
    }
    else
    {
      double v14 = 0.0;
      if (v13 < 24.0) {
        double v14 = (24.0 - v13) * 0.5;
      }
    }
    float64x2_t v18 = objc_msgSend(a3, "imageForProposedSize:scaleFactor:imageOffset:imageSize:", v9, v10, v13 + v14, v13 + v14, a4);
  }
  else
  {
    if ((objc_opt_respondsToSelector() & 1) == 0) {
      return this;
    }
    CGFloat v15 = EmojiFontForFont(a2);
    if (!v15) {
      return this;
    }
    float64x2_t v12 = (double *)v15[5];
    double v16 = v12[2];
    if (v16 <= 16.0)
    {
      double v17 = v16 * 0.25;
    }
    else
    {
      double v17 = 0.0;
      if (v16 < 24.0) {
        double v17 = (24.0 - v16) * 0.5;
      }
    }
    float64x2_t v18 = (void *)[a3 imageForPointSize:v9 scaleFactor:v10 imageOffset:v16 + v17 imageSize:a4];
  }
  id v21 = v18;
  if (atomic_load_explicit((atomic_ullong *volatile)&v21, memory_order_acquire))
  {
    *(double *)this = TFont::GetColorBitmapFontTranslate((TFont *)v12);
    *((void *)this + 1) = v19;
  }
  return this;
}

void CTFontDrawImageFromAdaptiveImageProviderAtPoint(const __CTFont *a1, void *a2, CGContext *a3, CGFloat a4, CGFloat a5)
{
  if (a1)
  {
    v12[0] = -1;
    v12[1] = -1;
    id v13 = (id)0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v10 = -1;
    *((void *)&v10 + 1) = -1;
    long long v14 = v10;
    long long v15 = v10;
    uint64_t v16 = -1;
    double ContentsScale = GetContentsScale(a3);
    v17.CGFloat x = a4;
    v17.CGFloat y = a5;
  }
}

double CTFontGetTypographicBoundsForEmojiImageProvider(void *a1, uint64_t a2, CGFloat *a3, CGFloat *a4)
{
  v12.origin.CGFloat x = CTFontGetTypographicBoundsForAdaptiveImageProvider(a1);
  CGFloat x = v12.origin.x;
  CGFloat y = v12.origin.y;
  CGFloat width = v12.size.width;
  CGFloat height = v12.size.height;
  double MaxX = CGRectGetMaxX(v12);
  if (a3)
  {
    v13.origin.CGFloat x = x;
    v13.origin.CGFloat y = y;
    v13.size.CGFloat width = width;
    v13.size.CGFloat height = height;
    *a3 = CGRectGetMaxY(v13);
  }
  if (a4)
  {
    v14.origin.CGFloat x = x;
    v14.origin.CGFloat y = y;
    v14.size.CGFloat width = width;
    v14.size.CGFloat height = height;
    *a4 = -CGRectGetMinY(v14);
  }
  return MaxX;
}

float64_t CTFontCopyImageFromEmojiImageProvider(const __CTFont *a1, void *a2, float64x2_t *a3, float64x2_t *a4, double a5)
{
  v7.f64[0] = NAN;
  v7.f64[1] = NAN;
  float64x2_t v9 = v7;
  float64x2_t v10 = v7;
  CTFontCopyImageFromAdaptiveImageProvider(a1, a2, &v9, a5);
  if (a3)
  {
    float64_t result = v9.f64[0];
    *a3 = v9;
  }
  if (a4)
  {
    float64_t result = v10.f64[0];
    *a4 = v10;
  }
  return result;
}

uint64_t TEmojiImageRun::TEmojiImageRun(uint64_t a1, uint64_t a2)
{
  TRun::TRun((TRun *)a1, *(const TRun **)(a2 + 40));
  *uint64_t v3 = &unk_1ED05E390;
  CFStringRef Value = CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit(v3 + 5, memory_order_acquire), @"CTEmojiImageProvider");
  if (!Value) {
    CFStringRef Value = CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)(a1 + 40), memory_order_acquire), @"CTAdaptiveImageProvider");
  }
  *(void *)(a1 + 32CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = Value;
  id v11 = EmojiFontForFont((void *)atomic_load_explicit((atomic_ullong *volatile)(a1 + 56), memory_order_acquire));
  if (atomic_load_explicit((atomic_ullong *volatile)&v11, memory_order_acquire)
    && atomic_load_explicit((atomic_ullong *volatile)&v11, memory_order_acquire))
  {

    *(unsigned char *)(a1 + 88) = 1;
  }

  uint64_t v5 = *(void *)(atomic_load_explicit((atomic_ullong *volatile)(a1 + 56), memory_order_acquire) + 40);
  CachedSpaceAndJoinerGlyphs = TBaseFont::GetCachedSpaceAndJoinerGlyphs(*(atomic_ullong **)(v5 + 400), 0);
  uint64_t v7 = *(unsigned __int16 *)CachedSpaceAndJoinerGlyphs;
  __int16 v12 = *(_WORD *)CachedSpaceAndJoinerGlyphs;
  id v11 = (id)-1;
  TFont::GetUnsummedAdvancesForGlyphs(v5, (uint64_t)&v12, (double *)&v11, 1, 1, 0, 0);
  *(void *)(a1 + 328) = v11;
  uint64_t v8 = *(void *)(a1 + 208);
  if (v8 >= 1)
  {
    for (uint64_t i = 0; i != v8; ++i)
    {
      [*(id *)(a1 + 216) setGlyph:v7 atIndex:i + *(void *)(a1 + 200)];
      if (v7 == 0xFFFF && (*(unsigned char *)(a1 + 225) & 2) != 0) {
        *(unsigned char *)(a1 + 225) |= 8u;
      }
      v13.CGFloat width = *(CGFloat *)(a1 + 328);
      v13.CGFloat height = 0.0;
      TStorageRange::SetAdvance((TStorageRange *)(a1 + 192), i, v13);
    }
  }
  return a1;
}

void TEmojiImageRun::DrawGlyphs(TEmojiImageRun *this, CGContextRef c, CFRange a3)
{
  locatiouint64_t n = a3.location;
  CFIndex v6 = *((void *)this + 26);
  if (a3.location + a3.length >= v6) {
    CFIndex v7 = *((void *)this + 26);
  }
  else {
    CFIndex v7 = a3.location + a3.length;
  }
  if (a3.location < 0 || a3.location >= v6)
  {
    BOOL v9 = a3.location + a3.length > 0 && a3.location < 1;
    locatiouint64_t n = 0;
    if (v9) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = 0;
    }
  }
  else
  {
    uint64_t v8 = v7 - a3.location;
  }
  if (v8 >= 1)
  {
    TextPositiouint64_t n = CGContextGetTextPosition(c);
    id v11 = (double *)*((void *)this + 39);
    if (!v11) {
      id v11 = (double *)MEMORY[0x1E4F1DB30];
    }
    CGFloat v12 = TextPosition.y + v11[1];
    v35.CGFloat x = TextPosition.x + *v11;
    v35.CGFloat y = v12;
    BOOL v29 = TAttributes::SetContextAttributes((atomic_ullong *)this + 5, c, 0);
    v30[0] = -1;
    v30[1] = -1;
    id v31 = (id)0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v13 = -1;
    *((void *)&v13 + 1) = -1;
    long long v32 = v13;
    long long v33 = v13;
    uint64_t v34 = -1;
    CFDataRef explicit = (const __CTFont *)atomic_load_explicit((atomic_ullong *volatile)this + 7, memory_order_acquire);
    long long v15 = (void *)*((void *)this + 40);
    double ContentsScale = GetContentsScale(c);
    CGPoint v17 = (void *)*((void *)this + 27);
    uint64_t v18 = *((void *)this + 25);
    uint64_t v19 = v17[4];
    if (v19 || (uint64_t v22 = v17[3]) == 0)
    {
      int v20 = 0;
      id v21 = (double *)(v19 + 16 * v18);
    }
    else
    {
      id v21 = (double *)(v22 + 8 * v18);
      int v20 = 1;
    }
    if (v6 >= 1)
    {
      CFIndex v23 = 0;
      uint64_t v24 = v17[2] + 2 * v18;
      CFIndex v25 = location + v8;
      BOOL v26 = v21;
      do
      {
        if ((*(_DWORD *)(*(void *)(*((void *)this + 27) + 40) + 4 * *((void *)this + 25) + 4 * v23) & 0x20) == 0)
        {
          if (location <= v23 && v25 > v23) {
          CGContextShowGlyphsAtPositionsWithString();
          }
          if (v20)
          {
            int v27 = &v21[v23];
            double v28 = 0.0;
          }
          else
          {
            double v28 = v26[1];
            int v27 = v26;
          }
          v35.CGFloat x = *v27 + v35.x;
          v35.CGFloat y = v28 + v35.y;
        }
        ++v23;
        v26 += 2;
        v24 += 2;
      }
      while (v6 != v23);
    }
    if (v29) {
      CGContextRestoreGState(c);
    }
    CGContextSetTextPosition(c, v35.x, v35.y);
  }
}

void TEmojiImageRun::DrawGlyphsAtPositions(uint64_t a1, CGContext *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  CFIndex v8 = a3;
  uint64_t v11 = *(void *)(a1 + 208);
  if (a3 + a4 >= v11) {
    CFIndex v12 = *(void *)(a1 + 208);
  }
  else {
    CFIndex v12 = a3 + a4;
  }
  if (a3 < 0 || a3 >= v11)
  {
    BOOL v14 = a3 + a4 > 0 && a3 < 1;
    CFIndex v8 = 0;
    if (v14) {
      CFIndex v13 = v12;
    }
    else {
      CFIndex v13 = 0;
    }
  }
  else
  {
    CFIndex v13 = v12 - a3;
  }
  if (v13 >= 1)
  {
    FillColorAsColor = (CGColor *)CGContextGetFillColorAsColor();
    Alphdouble a = CGColorGetAlpha(FillColorAsColor);
    if (*(void *)(a6 + 8)) {
      CGPoint v17 = *(const TAttributes **)(a6 + 8);
    }
    else {
      CGPoint v17 = (const TAttributes *)(a1 + 40);
    }
    if (*(unsigned char *)a6)
    {
      v65.locatiouint64_t n = v8;
      v65.CFIndex length = v13;
      TRun::DrawBackground((TRun *)a1, a2, v65, v17, 1);
    }
    *(void *)&long long v18 = -1;
    *((void *)&v18 + 1) = -1;
    *(_OWORD *)&v60.c = v18;
    *(_OWORD *)&v60.tCGFloat x = v18;
    *(_OWORD *)&v60.double a = v18;
    CGContextGetTextMatrix(&v60, a2);
    *(void *)&long long v19 = -1;
    *((void *)&v19 + 1) = -1;
    *(_OWORD *)&v59.c = v19;
    *(_OWORD *)&v59.tCGFloat x = v19;
    *(_OWORD *)&v59.double a = v19;
    CGContextGetCTM(&v59, a2);
    BOOL v20 = TAttributes::SetContextAttributes((atomic_ullong *)v17, a2, 0);
    CGSize v58 = (CGSize)*MEMORY[0x1E4F1DB30];
    *(void *)&long long v21 = -1;
    *((void *)&v21 + 1) = -1;
    uint64_t v22 = *(const TFont **)(atomic_load_explicit((atomic_ullong *volatile)(a1 + 56), memory_order_acquire) + 40);
    if (*(unsigned char *)v22)
    {
      LOWORD(t2.a) = TEmojiImageRun::DrawGlyphsAtPositions(CGContext *,CFRange,CGPoint const*,TRun::DrawGlyphsAtPositionsConfiguration const&)const::sVisibleGlyph;
      if (!TEmojiImageRun::DrawGlyphsAtPositions(CGContext *,CFRange,CGPoint const*,TRun::DrawGlyphsAtPositionsConfiguration const&)const::sVisibleGlyph)
      {
        *(_DWORD *)CGFloat v56 = 9731;
        if (!GetGlyphsForLongCharacters(v22, (const unsigned int *)v56, (unsigned __int16 *)&t2, 1)) {
          return;
        }
        TEmojiImageRun::DrawGlyphsAtPositions(CGContext *,CFRange,CGPoint const*,TRun::DrawGlyphsAtPositionsConfiguration const&)const::sVisibleuint64_t Glyph = LOWORD(t2.a);
      }
      TFont::GetUnscaledVerticalTranslationsForGlyphs(v22, (const unsigned __int16 *)&t2, &v58, 1);
      CFIndex v23 = (float64x2_t *)(a1 + 96);
      if (!*(unsigned char *)(a1 + 144)) {
        CFIndex v23 = (float64x2_t *)MEMORY[0x1E4F1DAB8];
      }
      CGSize v48 = (CGSize)vmlaq_n_f64(vmulq_n_f64(v23[1], v58.height), *v23, v58.width);
      CGSize v58 = v48;
      *(CGAffineTransform *)CGFloat v56 = v60;
      CGAffineTransformInvert(&t1, (CGAffineTransform *)v56);
      CGSize v58 = (CGSize)vmlaq_n_f64(vmulq_laneq_f64(*(float64x2_t *)&t1.c, (float64x2_t)v48, 1), *(float64x2_t *)&t1.a, v48.width);
      *(void *)&long long v21 = -1;
      *((void *)&v21 + 1) = -1;
    }
    *(void *)CGFloat v56 = -1;
    *(void *)&v56[8] = -1;
    *(_OWORD *)&v56[24] = v21;
    *(_OWORD *)&v56[40] = v21;
    *(void *)&v56[16] = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v57 = -1;
    CFDataRef explicit = (const __CTFont *)atomic_load_explicit((atomic_ullong *volatile)(a1 + 56), memory_order_acquire);
    CFIndex v25 = *(void **)(a1 + 320);
    double ContentsScale = GetContentsScale(a2);
    uint64_t v27 = *(void *)(*(void *)(a1 + 216) + 16) + 2 * v8 + 2 * *(void *)(a1 + 200);
    float64x2_t v47 = (float64x2_t)vdupq_n_s64(0x3CB0000000000000uLL);
    _D10 = 0;
    do
    {
      if ((*(_DWORD *)(*(void *)(*(void *)(a1 + 216) + 40) + 4 * *(void *)(a1 + 200) + 4 * v8) & 0x20) == 0)
      {
        CGAffineTransform v55 = v59;
        _V2.D[1] = v60.b;
        int64x2_t v30 = (int64x2_t)vandq_s8((int8x16_t)vcgeq_f64(v47, vabsq_f64(vaddq_f64(*(float64x2_t *)&v60.c, (float64x2_t)xmmword_184B88D40))), (int8x16_t)vcgeq_f64(v47, vabsq_f64(vaddq_f64(*(float64x2_t *)&v60.a, (float64x2_t)xmmword_184B88D30))));
        CGSize v49 = v58;
        if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v30, 1), (int8x16_t)v30).u64[0] & 0x8000000000000000) != 0)
        {
          CGAffineTransform v54 = v59;
          CGAffineTransformMakeTranslation(&v53, v60.tx, v60.ty);
          *(float64x2_t *)&v52.double a = vaddq_f64((float64x2_t)v49, *(float64x2_t *)(a5 + 16 * v8));
          if (atomic_load_explicit((atomic_ullong *volatile)&v56[16], memory_order_acquire) && Alpha != 0.0)
          {
            CGPoint v45 = (CGPoint)vaddq_f64(*(float64x2_t *)&v53.tx, vmlaq_n_f64(vmulq_n_f64(*(float64x2_t *)&v53.c, v52.b), *(float64x2_t *)&v53.a, v52.a));
            CGFloat y = v45.y;
          }
          CGAffineTransform t1 = v55;
          CGContextSetCTM();
          v51.double a = 0.0;
          CGContextShowGlyphsAtPositionsWithString();
          CGAffineTransform t2 = v54;
        }
        else
        {
          __asm { FMLA            D1, D10, V2.D[1]; __y }
          double v36 = hypot(vmlad_n_f64(v60.c, 0.0, v60.a), _D1);
          CGFloat v37 = 1.0;
          if (v36 > 1.0)
          {
            CGAffineTransform t1 = v60;
            CGAffineTransformScale(&t2, &t1, 1.0 / v36, 1.0 / v36);
            CGAffineTransform v60 = t2;
            CGFloat v37 = v36;
          }
          *(void *)&long long v38 = -1;
          *((void *)&v38 + 1) = -1;
          *(_OWORD *)&v52.c = v38;
          *(_OWORD *)&v52.tCGFloat x = v38;
          *(_OWORD *)&v52.double a = v38;
          CGAffineTransformMakeScale(&v52, v37, v37);
          *(void *)&long long v39 = -1;
          *((void *)&v39 + 1) = -1;
          *(_OWORD *)&v51.c = v39;
          *(_OWORD *)&v51.tCGFloat x = v39;
          *(_OWORD *)&v51.double a = v39;
          CGAffineTransform t1 = v60;
          CGAffineTransform t2 = v59;
          CGAffineTransformConcat(&v51, &t1, &t2);
          CGContextSetCTM();
          CGAffineTransform v50 = v51;
          float64x2_t v40 = *(float64x2_t *)&v52.a;
          float64x2_t v41 = *(float64x2_t *)&v52.c;
          float64x2_t v42 = *(float64x2_t *)&v52.tx;
          float64x2_t v64 = vaddq_f64((float64x2_t)v49, *(float64x2_t *)(a5 + 16 * v8));
          if (atomic_load_explicit((atomic_ullong *volatile)&v56[16], memory_order_acquire) && Alpha != 0.0)
          {
            CGPoint v43 = (CGPoint)vaddq_f64(v42, vmlaq_n_f64(vmulq_n_f64(v41, v64.f64[1]), v40, v64.f64[0]));
            CGFloat v44 = v43.y;
          }
          CGAffineTransform t1 = v55;
          CGContextSetCTM();
          uint64_t v62 = 0;
          CGContextShowGlyphsAtPositionsWithString();
          CGAffineTransform t2 = v50;
          CGContextSetCTM();
        }
        CGContextSetCTM();
      }
      ++v8;
      v27 += 2;
      --v13;
    }
    while (v13);
    if (v20) {
      CGContextRestoreGState(a2);
    }
  }
}

double TEmojiImageRun::GetImageBounds(TEmojiImageRun *this, CGContext *a2, CFRange a3, double *a4, double *a5)
{
  locatiouint64_t n = a3.location;
  CFIndex v9 = *((void *)this + 26);
  if (a3.location + a3.length >= v9) {
    CFIndex v10 = *((void *)this + 26);
  }
  else {
    CFIndex v10 = a3.location + a3.length;
  }
  if (a3.location < 0 || a3.location >= v9)
  {
    BOOL v12 = a3.location + a3.length > 0 && a3.location < 1;
    locatiouint64_t n = 0;
    if (v12) {
      uint64_t v11 = v10;
    }
    else {
      uint64_t v11 = 0;
    }
  }
  else
  {
    uint64_t v11 = v10 - a3.location;
  }
  double x = *MEMORY[0x1E4F1DB20];
  CGFloat y = *(double *)(MEMORY[0x1E4F1DB20] + 8);
  CGFloat width = *(double *)(MEMORY[0x1E4F1DB20] + 16);
  CGFloat height = *(double *)(MEMORY[0x1E4F1DB20] + 24);
  if (v11 >= 1)
  {
    r2.size.CGFloat width = NAN;
    r2.size.CGFloat height = NAN;
    id v41 = (id)0xAAAAAAAAAAAAAAAALL;
    v17.f64[0] = NAN;
    v17.f64[1] = NAN;
    float64x2_t v42 = v17;
    float64x2_t v43 = v17;
    uint64_t v44 = -1;
    CFDataRef explicit = (const __CTFont *)atomic_load_explicit((atomic_ullong *volatile)this + 7, memory_order_acquire);
    long long v19 = (void *)*((void *)this + 40);
    double ContentsScale = GetContentsScale(a2);
    uint64_t v21 = *((void *)this + 27);
    uint64_t v22 = *(void *)(v21 + 32);
    if (v22 || (uint64_t v25 = *(void *)(v21 + 24)) == 0)
    {
      int v23 = 0;
      uint64_t v24 = v22 + 16 * *((void *)this + 25);
    }
    else
    {
      uint64_t v24 = v25 + 8 * *((void *)this + 25);
      int v23 = 1;
    }
    CFIndex v26 = location + v11;
    if (v26)
    {
      CFIndex v27 = 0;
      v28.f64[0] = *a4;
      v28.f64[1] = *a5;
      float64x2_t v29 = v43;
      origiuint64_t n = vaddq_f64(vaddq_f64(v42, (float64x2_t)r2.size), v28);
      id v31 = (double *)(v24 + 8);
      do
      {
        if (location <= v27
          && v26 > v27
          && (*(_DWORD *)(*(void *)(*((void *)this + 27) + 40) + 4 * *((void *)this + 25) + 4 * v27) & 0x20) == 0)
        {
          float64_t v32 = origin.f64[1];
          v45.origin.double x = x;
          v45.origin.CGFloat y = y;
          v45.size.CGFloat width = width;
          v45.size.CGFloat height = height;
          r2.origiuint64_t n = (CGPoint)origin;
          uint64_t v34 = *(_OWORD *)&v29 >> 64;
          uint64_t v33 = (uint64_t)v29;
          CGRect v46 = CGRectUnion(v45, *(CGRect *)origin.f64);
          origiuint64_t n = (float64x2_t)r2.origin;
          double x = v46.origin.x;
          CGFloat y = v46.origin.y;
          CGFloat width = v46.size.width;
          CGFloat height = v46.size.height;
        }
        double v35 = *a4;
        if (v23)
        {
          double v36 = *(double *)(v24 + 8 * v27);
          *a4 = v36 + v35;
          float64x2_t v37 = (float64x2_t)*(unint64_t *)&v36;
          double v38 = 0.0;
        }
        else
        {
          float64x2_t v37 = *(float64x2_t *)(v31 - 1);
          *a4 = v37.f64[0] + v35;
          double v38 = *v31;
        }
        origiuint64_t n = vaddq_f64(origin, v37);
        *a5 = v38 + *a5;
        ++v27;
        v31 += 2;
      }
      while (v26 != v27);
    }
  }
  return x;
}

uint64_t _CTFontGetBaseFontType(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 40) + 400) + 16))();
}

CFArrayRef _CTFontGetPaletteColors(const void *a1)
{
  unint64_t v1 = _CTFontEnsureFontRef(a1);
  if (v1)
  {
    long long v2 = (atomic_ullong *)*((void *)v1 + 5);
    return (CFArrayRef)TFont::GetPaletteColors(v2);
  }
  else
  {
    CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t v5 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
    return CFArrayCreate(v4, 0, 0, v5);
  }
}

void TEmojiImageRun::~TEmojiImageRun(void **this)
{
  TRun::~TRun(this);

  JUMPOUT(0x1853275C0);
}

uint64_t TEmojiImageRun::CanUpdateWidth(TEmojiImageRun *this)
{
  return 0;
}

void std::vector<CGSize,TInlineBufferAllocator<CGSize,30ul>>::__append(char **a1, unint64_t a2)
{
  uint64_t v5 = a1[1];
  CFAllocatorRef v4 = a1[2];
  if (a2 <= (v4 - v5) >> 4)
  {
    if (a2)
    {
      bzero(a1[1], 16 * a2);
      v5 += 16 * a2;
    }
    a1[1] = v5;
  }
  else
  {
    unint64_t v6 = (unint64_t)(a1 + 3);
    uint64_t v7 = v5 - *a1;
    unint64_t v8 = a2 + (v7 >> 4);
    if (v8 >> 60) {
      abort();
    }
    uint64_t v9 = v7 >> 4;
    uint64_t v10 = v4 - *a1;
    if (v10 >> 3 > v8) {
      unint64_t v8 = v10 >> 3;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v11 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v8;
    }
    if (v11) {
      BOOL v12 = TInlineBufferAllocator<CGPoint,30ul>::allocate((uint64_t)(a1 + 3), v11);
    }
    else {
      BOOL v12 = 0;
    }
    CFIndex v13 = &v12[16 * v9];
    BOOL v14 = &v12[16 * v11];
    bzero(v13, 16 * a2);
    long long v15 = &v13[16 * a2];
    float64x2_t v17 = *a1;
    uint64_t v16 = a1[1];
    if (v16 != *a1)
    {
      do
      {
        *((_OWORD *)v13 - 1) = *((_OWORD *)v16 - 1);
        v13 -= 16;
        v16 -= 16;
      }
      while (v16 != v17);
      uint64_t v16 = *a1;
    }
    *a1 = v13;
    a1[1] = v15;
    long long v18 = a1[2];
    a1[2] = v14;
    if (v16)
    {
      long long v19 = (char *)(a1 + 63);
      if (v6 <= (unint64_t)v16 && v19 > v16)
      {
        if (v18 == *(char **)v19) {
          *(void *)long long v19 = v16;
        }
      }
      else
      {
        operator delete(v16);
      }
    }
  }
}

uint64_t GetGlyphAfterHiding(TFont const*,unsigned short)::$_0::__invoke(TFont *a1)
{
  _MergedGlobals_11 = TFont::GetGlyphWithName(a1, @"u1F1F9_u1F1FC");
  uint64_t result = TFont::GetGlyphWithName(a1, @"hiddenglyph");
  word_1EB2CDF9A = result;
  return result;
}

void CreateImageWithDataProvider(atomic_ullong *a1, CGDataProviderRef provider, int a3)
{
  *a1 = 0;
  if (!provider) {
    return;
  }
  switch(a3)
  {
    case 1785751328:
      if (qword_1EB2CDFF0 == -1)
      {
        uint64_t v5 = &qword_1EB2CDFF8;
        goto LABEL_11;
      }
      uint64_t v9 = &qword_1EB2CDFF0;
      uint64_t v10 = GetImageHintDict::$_1::__invoke;
      break;
    case 1953064550:
      if (qword_1EB2CE000 == -1)
      {
        uint64_t v5 = &qword_1EB2CE008;
        goto LABEL_11;
      }
      uint64_t v9 = &qword_1EB2CE000;
      uint64_t v10 = GetImageHintDict::$_2::__invoke;
      break;
    case 1886283552:
      if (qword_1EB2CDFE0 == -1)
      {
        uint64_t v5 = &qword_1EB2CDFE8;
        goto LABEL_11;
      }
      uint64_t v9 = &qword_1EB2CDFE0;
      uint64_t v10 = GetImageHintDict::$_0::__invoke;
      break;
    default:
      return;
  }
  dispatch_once_f(v9, 0, (dispatch_function_t)v10);
  uint64_t v5 = v9 + 1;
LABEL_11:
  CFDictionaryRef v6 = (const __CFDictionary *)*v5;
  if (*v5)
  {
    uint64_t v7 = CGImageSourceCreateWithDataProvider(provider, (CFDictionaryRef)*v5);
    unint64_t v8 = v7;
    if (v7) {
  }
    }
}

void CopyEmojiImage(unsigned int,void const*,unsigned long,double,double,__CFData const*,CGSize *)::$_0::__invoke(int a1, void *a2)
{
}

unint64_t GetImageHintDict(unsigned int)::$_0::__invoke()
{
  unint64_t result = CreateOptionsForImageSourceType((const __CFString *)*MEMORY[0x1E4F22678]);
  qword_1EB2CDFE8 = result;
  return result;
}

unint64_t CreateOptionsForImageSourceType(const __CFString *a1)
{
  uint64_t v2 = *MEMORY[0x1E4F2FF78];
  uint64_t v3 = *MEMORY[0x1E4F2FF08];
  CFAllocatorRef v4 = operator new(0x10uLL);
  *CFAllocatorRef v4 = v2;
  v4[1] = v3;
  uint64_t v5 = (const void *)*MEMORY[0x1E4F1CFD0];
  CFDictionaryRef v6 = operator new(0x10uLL);
  *CFDictionaryRef v6 = a1;
  v6[1] = v5;
  uint64_t v7 = (const void **)operator new(0x20uLL);
  v7[2] = (const void *)*MEMORY[0x1E4F2FF48];
  *(_OWORD *)uint64_t v7 = *(_OWORD *)v4;
  operator delete(v4);
  unint64_t v8 = (const void **)operator new(0x20uLL);
  uint64_t v8[2] = v5;
  *(_OWORD *)unint64_t v8 = *(_OWORD *)v6;
  operator delete(v6);
  id v11 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v7, v8, 3, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  unint64_t v9 = atomic_exchange((atomic_ullong *volatile)&v11, 0);

  operator delete(v8);
  operator delete(v7);
  return v9;
}

unint64_t GetImageHintDict(unsigned int)::$_1::__invoke()
{
  unint64_t result = CreateOptionsForImageSourceType((const __CFString *)*MEMORY[0x1E4F22610]);
  qword_1EB2CDFF8 = result;
  return result;
}

unint64_t GetImageHintDict(unsigned int)::$_2::__invoke()
{
  unint64_t result = CreateOptionsForImageSourceType((const __CFString *)*MEMORY[0x1E4F226E8]);
  qword_1EB2CE008 = result;
  return result;
}

uint64_t __Block_byref_object_copy__0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 48) = atomic_exchange((atomic_ullong *volatile)(a2 + 48), 0);
  return result;
}

void __Block_byref_object_dispose__0(uint64_t a1)
{
}

void ___ZL22GetMLUpscaledImageDataP7CGImagemmdU13block_pointerFvS0_dE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 | [*(id *)(a1 + 32) error])
  {
    CFAllocatorRef v4 = *(NSObject **)(a1 + 40);
    dispatch_group_leave(v4);
  }
  else
  {
    uint64_t v5 = objc_msgSend((id)objc_msgSend(*(id *)(a1 + 32), "results"), "firstObject");
    if (v5)
    {
      CFDictionaryRef v6 = v5;
      if ([v5 image])
      {
        uint64_t v7 = (CGImage *)[v6 image];
        CFMutableSetRef Mutable = CFDataCreateMutable(0, 0);
        unint64_t v9 = CGImageDestinationCreateWithData(Mutable, (CFStringRef)*MEMORY[0x1E4F22678], 1uLL, 0);
        CGImageDestinationAddImage(v9, v7, 0);
        CGImageDestinationFinalize(v9);
        uint64_t v10 = CGDataProviderCreateWithCFData(Mutable);

        CreateImageWithDataProvider((atomic_ullong *)&v16, v10, 1886283552);
        id v11 = *(CGImage **)(a1 + 72);
        CFDataRef explicit = (CGImage *)atomic_load_explicit((atomic_ullong *volatile)(*(void *)(*(void *)(a1 + 56) + 8) + 48), memory_order_acquire);
        double Width = (double)CGImageGetWidth(v11);
        CGImageGetHeight(v11);
        double v14 = (double)CGImageGetWidth(explicit);
        CGImageGetHeight(explicit);
        *(double *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) = v14 / Width;
        uint64_t v15 = *(void *)(a1 + 48);
        if (v15) {
          (*(void (**)(uint64_t, unint64_t, double))(v15 + 16))(v15, atomic_load_explicit((atomic_ullong *volatile)(*(void *)(*(void *)(a1 + 56) + 8) + 48), memory_order_acquire), *(double *)(*(void *)(*(void *)(a1 + 64) + 8) + 24));
        }
      }
    }
    dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
  }
}

void __Block_byref_object_copy__54(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__55(uint64_t a1)
{
}

Class ___ZL18getMADServiceClassv_block_invoke(uint64_t a1)
{
  MediaAnalysisServicesLibraryCore((char **)a1);
  Class result = objc_getClass("MADService");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 4CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = result;
  qword_1EB2CE010 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  return result;
}

void MediaAnalysisServicesLibraryCore(char **a1)
{
  if (!MediaAnalysisServicesLibraryCore(char **)::frameworkLibrary) {
    MediaAnalysisServicesLibraryCore(char **)::frameworkLibrarCGFloat y = _sl_dlopen();
  }
}

uint64_t ___ZL32MediaAnalysisServicesLibraryCorePPc_block_invoke()
{
  uint64_t result = _sl_dlopen();
  MediaAnalysisServicesLibraryCore(char **)::frameworkLibrarCGFloat y = result;
  return result;
}

Class ___ZL27getMADMLScalingRequestClassv_block_invoke(uint64_t a1)
{
  MediaAnalysisServicesLibraryCore((char **)a1);
  Class result = objc_getClass("MADMLScalingRequest");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 4CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = result;
  qword_1EB2CE018 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  return result;
}

uint64_t ___ZZN12_GLOBAL__N_112TCGImageDataC1EPK5TFonttRK12TsbixContextd7CGPointENKUlP7CGImagedE_cvU13block_pointerFvS9_dEEv_block_invoke(uint64_t result, uint64_t a2)
{
  v5[2] = *MEMORY[0x1E4F143B8];
  CFDataRef explicit = (void *)atomic_load_explicit((atomic_ullong *volatile)(result + 32), memory_order_acquire);
  if (explicit)
  {
    uint64_t v3 = result;
    v4[0] = @"image";
    v4[1] = @"scaleFactor";
    v5[0] = a2;
    v5[1] = objc_msgSend(NSNumber, "numberWithDouble:");
    return objc_msgSend(explicit, "setObject:forKey:", objc_msgSend(MEMORY[0x1E4F1C9E8], "dictionaryWithObjects:forKeys:count:", v5, v4, 2), *(void *)(v3 + 40));
  }
  return result;
}

id __copy_helper_block_8_32c87_ZTSKZN12_GLOBAL__N_112TCGImageDataC1EPK5TFonttRK12TsbixContextd7CGPointEUlP7CGImagedE_(uint64_t a1, uint64_t a2)
{
  id result = (id)atomic_load_explicit((atomic_ullong *volatile)(a2 + 32), memory_order_acquire);
  uint64_t v5 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = result;
  *(void *)(a1 + 4CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = v5;
  return result;
}

void __destroy_helper_block_8_32c87_ZTSKZN12_GLOBAL__N_112TCGImageDataC1EPK5TFonttRK12TsbixContextd7CGPointEUlP7CGImagedE_(uint64_t a1)
{
}

void DrawGlyphsAtPositions(TFont const*,unsigned short const*,CGPoint const*,unsigned long,CGContext *,anonymous namespace'::DrawGlyphsConfiguration const&)::$_0::operator()(uint64_t a1, float64x2_t *a2)
{
  v97[1] = *MEMORY[0x1E4F143B8];
  *(void *)&long long v3 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v96[14] = v3;
  v96[13] = v3;
  v96[12] = v3;
  v96[11] = v3;
  v96[10] = v3;
  v96[9] = v3;
  char v96[8] = v3;
  v96[7] = v3;
  v96[6] = v3;
  v96[5] = v3;
  v96[4] = v3;
  v96[3] = v3;
  _OWORD v96[2] = v3;
  v96[1] = v3;
  v96[0] = v3;
  unint64_t v4 = *(void *)(a1 + 24);
  id __p = 0;
  long long v94 = 0;
  long long v95 = 0;
  v97[0] = v96;
  if (v4)
  {
    if (v4 >> 61) {
LABEL_79:
    }
      abort();
    if ((void *)((char *)v96 + 8 * v4) <= v97)
    {
      v97[0] = (char *)v96 + 8 * v4;
      size_t v6 = 8 * v4;
      uint64_t v7 = v96;
    }
    else
    {
      size_t v6 = 8 * v4;
      uint64_t v7 = operator new(8 * v4);
    }
    unint64_t v8 = (char *)v7 + 8 * v4;
    id __p = v7;
    long long v95 = v8;
    bzero(v7, v6);
    long long v94 = v8;
    *(void *)&long long v9 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v90 = v9;
    long long v91 = v9;
    long long v88 = v9;
    long long v89 = v9;
    long long v86 = v9;
    long long v87 = v9;
    long long v84 = v9;
    long long v85 = v9;
    long long v82 = v9;
    long long v83 = v9;
    long long v80 = v9;
    long long v81 = v9;
    long long v78 = v9;
    long long v79 = v9;
    long long v77 = v9;
    long long v76 = v9;
    long long v75 = v9;
    long long v74 = v9;
    long long v73 = v9;
    long long v72 = v9;
    long long v71 = v9;
    long long v70 = v9;
    long long v69 = v9;
    long long v68 = v9;
    long long v67 = v9;
    long long v66 = v9;
    long long v65 = v9;
    long long v64 = v9;
    long long v63 = v9;
    long long v62 = v9;
    CGAffineTransform v59 = 0;
    CGAffineTransform v60 = 0;
    uint64_t v61 = 0;
    long long v92 = &v62;
    std::vector<CGPoint,TInlineBufferAllocator<CGPoint,30ul>>::__vallocate[abi:nn180100](&v59, v4);
    uint64_t v10 = (char *)v60;
    bzero(v60, 16 * v4);
    CGAffineTransform v60 = &v10[16 * v4];
    if (*(void *)(a1 + 24))
    {
      unint64_t v11 = 0;
      do
      {
        __int16 v12 = *(_WORD *)(*(void *)(a1 + 32) + 2 * v11);
        if (OTSVGTableGetDocumentIndexForGlyph() != -1 && OTSVGDocumentCreate())
        {
          uint64_t v13 = OTSVGGlyphRecordingCreate();
          if (v13)
          {
            *((void *)__p + v11) = v13;
            *(float64x2_t *)&v59[16 * v11] = vaddq_f64(a2[2], vmlaq_n_f64(vmulq_n_f64(a2[1], *(double *)(*(void *)(a1 + 48) + 16 * v11 + 8)), *a2, *(double *)(*(void *)(a1 + 48) + 16 * v11)));
          }
          OTSVGDocumentRelease();
        }
        if (!*((void *)__p + v11))
        {
          uint64_t v14 = *(void *)(a1 + 8);
          uint64_t v15 = *(void ***)(v14 + 8);
          unint64_t v16 = *(void *)(v14 + 16);
          if ((unint64_t)v15 >= v16)
          {
            long long v18 = *(void ***)v14;
            uint64_t v19 = (uint64_t)v15 - *(void *)v14;
            if (v19 <= -3) {
              goto LABEL_79;
            }
            uint64_t v20 = v19 >> 1;
            unint64_t v21 = v16 - (void)v18;
            if (v21 <= (v19 >> 1) + 1) {
              unint64_t v22 = v20 + 1;
            }
            else {
              unint64_t v22 = v21;
            }
            if (v21 >= 0x7FFFFFFFFFFFFFFELL) {
              uint64_t v23 = 0x7FFFFFFFFFFFFFFFLL;
            }
            else {
              uint64_t v23 = v22;
            }
            v58[4] = (void **)(v14 + 24);
            if (v23)
            {
              uint64_t v24 = (char *)TInlineBufferAllocator<unsigned short,30ul>::allocate(v14 + 24, v23);
              long long v18 = *(void ***)v14;
              uint64_t v15 = *(void ***)(v14 + 8);
            }
            else
            {
              uint64_t v24 = 0;
            }
            uint64_t v25 = &v24[2 * v20];
            *(_WORD *)uint64_t v25 = v12;
            if (v15 == v18)
            {
              CFIndex v27 = &v24[2 * v20];
            }
            else
            {
              CFIndex v26 = v15;
              CFIndex v27 = &v24[2 * v20];
              do
              {
                __int16 v28 = *((_WORD *)v26 - 1);
                CFIndex v26 = (void **)((char *)v26 - 2);
                *((_WORD *)v27 - 1) = v28;
                v27 -= 2;
              }
              while (v26 != v18);
            }
            float64x2_t v17 = v25 + 2;
            *(void *)uint64_t v14 = v27;
            v58[0] = v18;
            v58[1] = v18;
            *(void *)(v14 + 8) = v25 + 2;
            void v58[2] = v15;
            float64x2_t v29 = *(void ***)(v14 + 16);
            *(void *)(v14 + 16) = &v24[2 * v23];
            uint64_t v58[3] = v29;
            std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,30ul> &>::~__split_buffer((uint64_t)v58);
          }
          else
          {
            *(_WORD *)uint64_t v15 = v12;
            float64x2_t v17 = (_WORD *)v15 + 1;
          }
          *(void *)(v14 + 8) = v17;
          int64x2_t v30 = *(char ***)(a1 + 16);
          id v31 = (_OWORD *)(*(void *)(a1 + 48) + 16 * v11);
          uint64_t v33 = v30[1];
          unint64_t v32 = (unint64_t)v30[2];
          if ((unint64_t)v33 >= v32)
          {
            uint64_t v35 = (v33 - *v30) >> 4;
            unint64_t v36 = v35 + 1;
            if ((unint64_t)(v35 + 1) >> 60) {
              goto LABEL_79;
            }
            uint64_t v37 = v32 - (void)*v30;
            if (v37 >> 3 > v36) {
              unint64_t v36 = v37 >> 3;
            }
            if ((unint64_t)v37 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v38 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v38 = v36;
            }
            if (v38) {
              long long v39 = TInlineBufferAllocator<CGPoint,30ul>::allocate((uint64_t)(v30 + 3), v38);
            }
            else {
              long long v39 = 0;
            }
            float64x2_t v40 = &v39[16 * v35];
            *(_OWORD *)float64x2_t v40 = *v31;
            float64x2_t v42 = *v30;
            id v41 = v30[1];
            float64x2_t v43 = v40;
            if (v41 != *v30)
            {
              do
              {
                *((_OWORD *)v43 - 1) = *((_OWORD *)v41 - 1);
                v43 -= 16;
                v41 -= 16;
              }
              while (v41 != v42);
              id v41 = *v30;
            }
            uint64_t v34 = v40 + 16;
            *int64x2_t v30 = v43;
            v30[1] = v40 + 16;
            uint64_t v44 = v30[2];
            void v30[2] = &v39[16 * v38];
            if (v41)
            {
              CGRect v45 = (char *)(v30 + 63);
              if (v30 + 3 <= (char **)v41 && v45 > v41)
              {
                if (v44 == *(char **)v45) {
                  *(void *)CGRect v45 = v41;
                }
              }
              else
              {
                operator delete(v41);
              }
            }
          }
          else
          {
            *(_OWORD *)uint64_t v33 = *v31;
            uint64_t v34 = v33 + 16;
          }
          v30[1] = v34;
        }
        ++v11;
      }
      while (v11 < *(void *)(a1 + 24));
    }
  }
  else
  {
    long long v76 = v3;
    long long v75 = v3;
    long long v74 = v3;
    long long v73 = v3;
    long long v72 = v3;
    long long v71 = v3;
    long long v70 = v3;
    long long v69 = v3;
    long long v68 = v3;
    long long v67 = v3;
    long long v66 = v3;
    long long v90 = v3;
    long long v91 = v3;
    long long v88 = v3;
    long long v89 = v3;
    long long v86 = v3;
    long long v87 = v3;
    long long v84 = v3;
    long long v85 = v3;
    long long v82 = v3;
    long long v83 = v3;
    long long v80 = v3;
    long long v81 = v3;
    long long v78 = v3;
    long long v79 = v3;
    long long v77 = v3;
    long long v65 = v3;
    long long v64 = v3;
    long long v63 = v3;
    long long v62 = v3;
    CGAffineTransform v59 = 0;
    CGAffineTransform v60 = 0;
    uint64_t v61 = 0;
    long long v92 = &v62;
  }
  if ((*(_DWORD *)(a1 + 56) & 0x80000000) != 0)
  {
    if (__p != v94)
    {
      float64x2_t v47 = v94 - 8;
      if (v94 - 8 > __p)
      {
        CGSize v48 = (char *)__p + 8;
        do
        {
          uint64_t v49 = *((void *)v48 - 1);
          *((void *)v48 - 1) = *(void *)v47;
          *(void *)float64x2_t v47 = v49;
          v47 -= 8;
          BOOL v50 = v48 >= v47;
          v48 += 8;
        }
        while (!v50);
      }
    }
    CGAffineTransform v51 = v59;
    CGAffineTransform v52 = (char *)v60 - 16;
    if (v59 != v60 && v52 > v59)
    {
      do
      {
        uint64_t v54 = *(void *)v51;
        uint64_t v55 = *((void *)v51 + 1);
        *(_OWORD *)CGAffineTransform v51 = *(_OWORD *)v52;
        v51 += 16;
        *(void *)CGAffineTransform v52 = v54;
        *((void *)v52 + 1) = v55;
        v52 -= 16;
      }
      while (v51 < v52);
    }
  }
  OTSVGGlyphRecordingPlaybackRecordingsAtPositions();
  if (*(void *)(a1 + 24))
  {
    unint64_t v56 = 0;
    do
    {
      OTSVGGlyphRecordingRelease();
      ++v56;
    }
    while (v56 < *(void *)(a1 + 24));
  }
  v58[0] = (void **)&v59;
  std::vector<CGPoint,TInlineBufferAllocator<CGPoint,30ul>>::__destroy_vector::operator()[abi:nn180100](v58);
  if (__p)
  {
    long long v94 = (char *)__p;
    if (v96 > __p || v97 <= __p) {
      operator delete(__p);
    }
  }
}

void DrawGlyphsAtPositions(TFont const*,unsigned short const*,CGPoint const*,unsigned long,CGContext *,anonymous namespace'::DrawGlyphsConfiguration const&)::$_1::operator()(uint64_t a1, uint64_t a2, float64x2_t *a3)
{
  int v3 = *(_DWORD *)(a1 + 24);
  if (v3 < 0) {
    uint64_t v4 = -1;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 16);
  }
  if (v3 >= 0) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = *(void *)(a1 + 16) - 1;
  }
  if (v5 != v4)
  {
    unint64_t v16 = (const CGAffineTransform *)(a1 + 200);
    float64x2_t v17 = (const CGAffineTransform *)(a1 + 152);
    do
    {
      unint64_t v8 = (double *)(*(void *)(a1 + 32) + 16 * v5);
      double v10 = *v8;
      double v9 = v8[1];
      unsigned int v11 = *(unsigned __int16 *)(*(void *)(a1 + 40) + 2 * v5);
      v18[0] = -1;
      v18[1] = -1;
      id v19 = (id)0xAAAAAAAAAAAAAAAALL;
      *(void *)&long long v12 = -1;
      *((void *)&v12 + 1) = -1;
      long long v20 = v12;
      long long v21 = v12;
      uint64_t v22 = -1;
      if (atomic_load_explicit((atomic_ullong *volatile)&v19, memory_order_acquire))
      {
        if (!*(unsigned char *)(a1 + 80))
        {
          uint64_t v13 = (double *)(**(void **)a1 + 32 * v5);
          CGPoint v14 = (CGPoint)vaddq_f64(a3[2], vmlaq_n_f64(vmulq_n_f64(a3[1], v9 + *(double *)(a1 + 128) + v13[1] * *(double *)(a1 + 112) + *(double *)(a1 + 96) * *v13), *a3, v10 + *(double *)(a1 + 120) + v13[1] * *(double *)(a1 + 104) + *(double *)(a1 + 88) * *v13));
          CGFloat y = v14.y;
        }
        if (!*(unsigned char *)(a1 + 144))
        {
          v23.double x = v10;
          v23.CGFloat y = v9;
          DrawInvisibleGlyph(*(CGContext **)(a1 + 136), v11, v23, v17, v16);
        }
      }
      else if (!*(unsigned char *)(a1 + 144))
      {
        CGContextSetCTM();
        v24.double x = v10 + *(double *)(a1 + 64);
        v24.CGFloat y = v9 + *(double *)(a1 + 72);
        DrawVisibleGlyph(*(CGContextRef *)(a1 + 136), v11, v24, v17, v16);
        CGContextSetCTM();
      }

      v5 += *(int *)(a1 + 24);
    }
    while (v5 != v4);
  }
}

id __copy_helper_block_8_64c27_ZTS6TCFRefIPK10__CFStringE88c31_ZTS6TCFRefIPK14__CFDictionaryE(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 64) = (id)atomic_load_explicit((atomic_ullong *volatile)(a2 + 64), memory_order_acquire);
  id result = (id)atomic_load_explicit((atomic_ullong *volatile)(a2 + 88), memory_order_acquire);
  *(void *)(a1 + 88) = result;
  return result;
}

void __destroy_helper_block_8_64c27_ZTS6TCFRefIPK10__CFStringE88c31_ZTS6TCFRefIPK14__CFDictionaryE(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 64);
}

void std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 1;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 2 * a2;
    }
  }
  else
  {
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__append((char **)a1, a2 - v2);
  }
}

void std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__append(char **a1, unint64_t a2)
{
  uint64_t v5 = a1[1];
  uint64_t v4 = a1[2];
  if (a2 <= (v4 - v5) >> 1)
  {
    if (a2)
    {
      bzero(a1[1], 2 * a2);
      v5 += 2 * a2;
    }
    a1[1] = v5;
  }
  else
  {
    uint64_t v6 = (uint64_t)(a1 + 3);
    uint64_t v7 = *a1;
    uint64_t v8 = v5 - *a1;
    uint64_t v9 = a2 + (v8 >> 1);
    if (v9 < 0) {
      abort();
    }
    uint64_t v10 = v8 >> 1;
    unint64_t v11 = v4 - v7;
    if (v11 > v9) {
      uint64_t v9 = v11;
    }
    if (v11 >= 0x7FFFFFFFFFFFFFFELL) {
      uint64_t v12 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v12 = v9;
    }
    void v20[4] = a1 + 3;
    if (v12)
    {
      uint64_t v13 = (char *)TInlineBufferAllocator<unsigned short,30ul>::allocate(v6, v12);
      uint64_t v7 = *a1;
      uint64_t v5 = a1[1];
    }
    else
    {
      uint64_t v13 = 0;
    }
    CGPoint v14 = &v13[2 * v10];
    uint64_t v15 = &v13[2 * v12];
    bzero(v14, 2 * a2);
    unint64_t v16 = &v14[2 * a2];
    if (v5 != v7)
    {
      float64x2_t v17 = v5;
      do
      {
        __int16 v18 = *((_WORD *)v17 - 1);
        v17 -= 2;
        *((_WORD *)v14 - 1) = v18;
        v14 -= 2;
      }
      while (v17 != v7);
    }
    *a1 = v14;
    a1[1] = v16;
    id v19 = a1[2];
    a1[2] = v15;
    _OWORD v20[2] = v5;
    double v20[3] = v19;
    v20[0] = v7;
    v20[1] = v7;
    std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,30ul> &>::~__split_buffer((uint64_t)v20);
  }
}

__CFString *TCFBase<TFont>::ClassDebug(uint64_t a1)
{
  id result = TFont::DebugDescription(*(TFont **)(a1 + 40));
  if (result)
  {
    int v3 = result;
    CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<%s: %p>{%@}", "CTFont", a1, result);
    CFRelease(v3);
    return (__CFString *)v4;
  }
  return result;
}

void std::__function::__func<CTFontTransformGlyphsWithLanguage::$_0,std::allocator<CTFontTransformGlyphsWithLanguage::$_0>,BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::~__func()
{
}

void *std::__function::__func<CTFontTransformGlyphsWithLanguage::$_0,std::allocator<CTFontTransformGlyphsWithLanguage::$_0>,BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::__clone(uint64_t a1)
{
  id result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *id result = &unk_1ED0600C8;
  result[1] = v3;
  return result;
}

BOOL std::__function::__func<CTFontTransformGlyphsWithLanguage::$_0,std::allocator<CTFontTransformGlyphsWithLanguage::$_0>,BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::operator()(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4) {
    (*(void (**)(void, void, void, void, void))(v4 + 16))(*(void *)(a1 + 8), *a2, a2[1], *a3, *a4);
  }
  return v4 != 0;
}

void std::__function::__func<CTFontShapeGlyphs::$_0,std::allocator<CTFontShapeGlyphs::$_0>,BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::~__func()
{
}

__n128 std::__function::__func<CTFontShapeGlyphs::$_0,std::allocator<CTFontShapeGlyphs::$_0>,BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::__clone(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)unint64_t v2 = &unk_1ED05FC90;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<CTFontShapeGlyphs::$_0,std::allocator<CTFontShapeGlyphs::$_0>,BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ED05FC90;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<CTFontShapeGlyphs::$_0,std::allocator<CTFontShapeGlyphs::$_0>,BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::operator()(uint64_t a1, uint64_t a2, void **a3)
{
  uint64_t v4 = *a3;
  (*(void (**)(void))(*(void *)(a1 + 8) + 16))();
  **(void **)(a1 + 16) = *v4;
  return 1;
}

void std::__function::__func<CTFontCopyTallestTextStyleLanguageForString::$_0,std::allocator<CTFontCopyTallestTextStyleLanguageForString::$_0>,void ()(CFRange,unsigned int,BOOL *)>::~__func()
{
}

__n128 std::__function::__func<CTFontCopyTallestTextStyleLanguageForString::$_0,std::allocator<CTFontCopyTallestTextStyleLanguageForString::$_0>,void ()(CFRange,unsigned int,BOOL *)>::__clone(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)unint64_t v2 = &unk_1ED060158;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<CTFontCopyTallestTextStyleLanguageForString::$_0,std::allocator<CTFontCopyTallestTextStyleLanguageForString::$_0>,void ()(CFRange,unsigned int,BOOL *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ED060158;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<CTFontCopyTallestTextStyleLanguageForString::$_0,std::allocator<CTFontCopyTallestTextStyleLanguageForString::$_0>,void ()(CFRange,unsigned int,BOOL *)>::operator()(uint64_t a1, uint64_t a2, UTF32Char *a3)
{
  unint64_t v4 = *a3;
  uint64_t v5 = *(void *)(a1 + 8);
  int v6 = *(_DWORD *)(v5 + 8);
  unsigned int v7 = v6 & 4;
  if (*(_DWORD *)(v5 + 12) > v4 || *(_DWORD *)(v5 + 16) <= v4)
  {
    if ((v6 & 4) == 0) {
      return;
    }
LABEL_10:
    int Script = uscript_getScript();
    if (!Script) {
      return;
    }
    int v10 = Script;
    unint64_t v11 = *(float **)(a1 + 16);
    unint64_t v12 = Script;
    unint64_t v13 = *((void *)v11 + 1);
    if (v13)
    {
      uint8x8_t v14 = (uint8x8_t)vcnt_s8((int8x8_t)v13);
      v14.i16[0] = vaddlv_u8(v14);
      if (v14.u32[0] > 1uLL)
      {
        unint64_t v15 = Script;
        if (v13 <= Script) {
          unint64_t v15 = Script % v13;
        }
      }
      else
      {
        unint64_t v15 = (v13 - 1) & Script;
      }
      id v19 = *(uint64_t ***)(*(void *)v11 + 8 * v15);
      if (v19)
      {
        for (uint64_t i = *v19; i; uint64_t i = (uint64_t *)*i)
        {
          unint64_t v21 = i[1];
          if (v21 == Script)
          {
            if (*((_DWORD *)i + 4) == Script) {
              return;
            }
          }
          else
          {
            if (v14.u32[0] > 1uLL)
            {
              if (v21 >= v13) {
                v21 %= v13;
              }
            }
            else
            {
              v21 &= v13 - 1;
            }
            if (v21 != v15) {
              break;
            }
          }
        }
      }
    }
    else
    {
      unint64_t v15 = 0xAAAAAAAAAAAAAAAALL;
    }
    uint64_t v22 = operator new(0x18uLL);
    void *v22 = 0;
    v22[1] = v12;
    *((_DWORD *)v22 + 4) = v10;
    float v23 = (float)(unint64_t)(*((void *)v11 + 3) + 1);
    float v24 = v11[8];
    if (v13 && (float)(v24 * (float)v13) >= v23)
    {
LABEL_93:
      uint64_t v44 = *(void **)v11;
      CGRect v45 = *(void **)(*(void *)v11 + 8 * v15);
      if (v45)
      {
        void *v22 = *v45;
      }
      else
      {
        uint64_t v46 = *((void *)v11 + 2);
        void *v22 = v46;
        *((void *)v11 + 2) = v22;
        v44[v15] = v11 + 4;
        if (!v46)
        {
LABEL_102:
          ++*((void *)v11 + 3);
          return;
        }
        unint64_t v47 = *(void *)(v46 + 8);
        if ((v13 & (v13 - 1)) != 0)
        {
          if (v47 >= v13) {
            v47 %= v13;
          }
        }
        else
        {
          v47 &= v13 - 1;
        }
        CGRect v45 = (void *)(*(void *)v11 + 8 * v47);
      }
      *CGRect v45 = v22;
      goto LABEL_102;
    }
    BOOL v25 = 1;
    if (v13 >= 3) {
      BOOL v25 = (v13 & (v13 - 1)) != 0;
    }
    unint64_t v26 = v25 | (2 * v13);
    unint64_t v27 = vcvtps_u32_f32(v23 / v24);
    if (v26 <= v27) {
      int8x8_t prime = (int8x8_t)v27;
    }
    else {
      int8x8_t prime = (int8x8_t)v26;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v13 = *((void *)v11 + 1);
    }
    if (*(void *)&prime > v13) {
      goto LABEL_49;
    }
    if (*(void *)&prime < v13)
    {
      unint64_t v35 = vcvtps_u32_f32((float)*((unint64_t *)v11 + 3) / v11[8]);
      if (v13 < 3 || (uint8x8_t v36 = (uint8x8_t)vcnt_s8((int8x8_t)v13), v36.i16[0] = vaddlv_u8(v36), v36.u32[0] > 1uLL))
      {
        unint64_t v35 = std::__next_prime(v35);
      }
      else
      {
        uint64_t v37 = 1 << -(char)__clz(v35 - 1);
        if (v35 >= 2) {
          unint64_t v35 = v37;
        }
      }
      if (*(void *)&prime <= v35) {
        int8x8_t prime = (int8x8_t)v35;
      }
      if (*(void *)&prime >= v13)
      {
        unint64_t v13 = *((void *)v11 + 1);
      }
      else
      {
        if (prime)
        {
LABEL_49:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          float64x2_t v29 = operator new(8 * *(void *)&prime);
          int64x2_t v30 = *(void **)v11;
          *(void *)unint64_t v11 = v29;
          if (v30) {
            operator delete(v30);
          }
          uint64_t v31 = 0;
          *((int8x8_t *)v11 + 1) = prime;
          do
            *(void *)(*(void *)v11 + 8 * v31++) = 0;
          while (*(void *)&prime != v31);
          unint64_t v32 = (void *)*((void *)v11 + 2);
          if (v32)
          {
            unint64_t v33 = v32[1];
            uint8x8_t v34 = (uint8x8_t)vcnt_s8(prime);
            v34.i16[0] = vaddlv_u8(v34);
            if (v34.u32[0] > 1uLL)
            {
              if (v33 >= *(void *)&prime) {
                v33 %= *(void *)&prime;
              }
            }
            else
            {
              v33 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)v11 + 8 * v33) = v11 + 4;
            float64x2_t v42 = (void *)*v32;
            if (*v32)
            {
              do
              {
                unint64_t v43 = v42[1];
                if (v34.u32[0] > 1uLL)
                {
                  if (v43 >= *(void *)&prime) {
                    v43 %= *(void *)&prime;
                  }
                }
                else
                {
                  v43 &= *(void *)&prime - 1;
                }
                if (v43 != v33)
                {
                  if (!*(void *)(*(void *)v11 + 8 * v43))
                  {
                    *(void *)(*(void *)v11 + 8 * v43) = v32;
                    goto LABEL_84;
                  }
                  *unint64_t v32 = *v42;
                  void *v42 = **(void **)(*(void *)v11 + 8 * v43);
                  **(void **)(*(void *)v11 + 8 * v43) = v42;
                  float64x2_t v42 = v32;
                }
                unint64_t v43 = v33;
LABEL_84:
                unint64_t v32 = v42;
                float64x2_t v42 = (void *)*v42;
                unint64_t v33 = v43;
              }
              while (v42);
            }
          }
          unint64_t v13 = (unint64_t)prime;
          goto LABEL_88;
        }
        CGSize v48 = *(void **)v11;
        *(void *)unint64_t v11 = 0;
        if (v48) {
          operator delete(v48);
        }
        unint64_t v13 = 0;
        *((void *)v11 + 1) = 0;
      }
    }
LABEL_88:
    if ((v13 & (v13 - 1)) != 0)
    {
      if (v13 <= v12) {
        unint64_t v15 = v12 % v13;
      }
      else {
        unint64_t v15 = v12;
      }
    }
    else
    {
      unint64_t v15 = (v13 - 1) & v12;
    }
    goto LABEL_93;
  }
  if (WORD1(v4)) {
    BOOL v8 = 0;
  }
  else {
    BOOL v8 = (v6 & 2) == 0;
  }
  if (!v8)
  {
    if (!CFCharacterSetIsLongCharacterMember(*(CFCharacterSetRef *)v5, *a3)) {
      return;
    }
    goto LABEL_10;
  }
  uint64_t v16 = *(void *)(v5 + 24);
  if (v16)
  {
    if (v6)
    {
      unsigned int v40 = v7 >> 2;
      uint64_t v41 = *(unsigned __int8 *)(v16 + (v4 >> 8));
      if (*(unsigned char *)(v16 + (v4 >> 8)))
      {
        if (v41 == 255)
        {
          unsigned int v40 = v7 == 0;
        }
        else
        {
          BOOL v49 = v7 == 0;
          if ((*(unsigned __int8 *)(v16 + 32 * v41 + (v4 >> 3) + 224) >> (v4 & 7))) {
            unsigned int v40 = v49;
          }
        }
      }
      if (v40) {
        goto LABEL_10;
      }
    }
    else
    {
      BOOL v8 = v7 == 0;
      BOOL v17 = v7 != 0;
      char v18 = v8;
      if ((*(unsigned __int8 *)(v16 + (v4 >> 3)) >> (v4 & 7))) {
        BOOL v17 = v18;
      }
      if (v17) {
        goto LABEL_10;
      }
    }
  }
  else
  {
    BOOL v8 = v7 == 0;
    BOOL v38 = v7 != 0;
    char v39 = v8;
    if ((v6 & 1) == 0) {
      BOOL v38 = v39;
    }
    if (v38) {
      goto LABEL_10;
    }
  }
}

uint64_t TFont::GetSystemUIFontOptions(TFont *this)
{
  if (qword_1EB2CE040 != -1) {
    dispatch_once_f(&qword_1EB2CE040, 0, (dispatch_function_t)TFont::GetSystemUIFontOptions(void)::$_0::__invoke);
  }
  return qword_1EB2CE038;
}

void TFont::TFont(TFont *this, const __CTFontDescriptor *a2, double a3, CGAffineTransform *a4, int a5, const __CTFontDescriptor *a6)
{
  *(_DWORD *)this = 0;
  unint64_t v11 = (atomic_ullong *)((char *)this + 8);
  TFont::InitDescriptor(a2, (atomic_ullong *)this + 1);
  *((double *)this + 2) = TFont::InitSize(a6, a3, v12);
  *((void *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0x80000000;
  TFont::InitMatrix((TFont *)a4, (const CGAffineTransform *)a6, (void *)this + 5);
  *((void *)this + 23) = 0;
  *((_DWORD *)this + 12) = 0;
  long long v13 = *MEMORY[0x1E4F1DB28];
  long long v14 = *(_OWORD *)(MEMORY[0x1E4F1DB28] + 16);
  *(_OWORD *)((char *)this + 88) = *MEMORY[0x1E4F1DAD8];
  *(_OWORD *)((char *)this + 104) = v13;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 12CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = v14;
  *((unsigned char *)this + 136) = 0;
  *((void *)this + 24) = 0;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 1CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = 0u;
  *((void *)this + 22) = (char *)this + 184;
  *((_DWORD *)this + 5CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = 0;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((_DWORD *)this + 6CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = 1065353216;
  *(_OWORD *)((char *)this + 248) = 0u;
  *(_OWORD *)((char *)this + 264) = 0u;
  *((_DWORD *)this + 7CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = 1065353216;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 19) = 0u;
  *((_OWORD *)this + 2CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = 0u;
  *((_OWORD *)this + 21) = 0u;
  *((_OWORD *)this + 22) = 0u;
  *((_DWORD *)this + 92) = 0;
  *((void *)this + 47) = 0;
  *((void *)this + 48) = 0;
  *((unsigned char *)this + 392) = 0;
  *((void *)this + 5CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = TFont::InitBaseFont(v15, v11);
  *((void *)this + 51) = 0;
  *((_DWORD *)this + 104) = 0;
  *(_OWORD *)((char *)this + 456) = 0u;
  *(_OWORD *)((char *)this + 472) = 0u;
  *((void *)this + 54) = 0;
  *((void *)this + 55) = 0;
  *((void *)this + 53) = 0;
  *((_DWORD *)this + 112) = 0;
  *((_DWORD *)this + 122) = 1065353216;
  *((void *)this + 62) = 0;
  *((_DWORD *)this + 126) = 0;
  *((void *)this + 64) = 0;
  *((unsigned char *)this + 52CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = 0;
  *((void *)this + 67) = 0;
  *((void *)this + 68) = 0;
  *((void *)this + 66) = 0;
  if ((a5 & 8) == 0)
  {
    CFDataRef explicit = (const __CTFontDescriptor *)atomic_load_explicit(v11, memory_order_acquire);
    if (a6
      && (BOOL v17 = (atomic_ullong *)(*((void *)a6 + 5) + 8),
          atomic_load_explicit(v17, memory_order_acquire),
          (CFDictionaryRef v18 = (const __CFDictionary *)atomic_load_explicit(v17, memory_order_acquire)) != 0))
    {
      CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(v18, @"CTFontOriginalFeatureSettingsAttribute");
    }
    else
    {
      CFArrayRef Value = 0;
    }
    TFont::SetExtras((atomic_ullong *)this, explicit, Value);
  }
  TFont::SetFlags((atomic_ullong *)this, a5, a6);
  TFont::SetOpticalSize(this, a6);
  TFont::AddFontSpecificFeatureSettings(this);
}

void TFont::DefaultDescriptor(void *a1, atomic_ullong *this, int *a3)
{
  *a3 = TFont::IsSystemUIFontAndForShaping(this, &v7);
  if (this[50])
  {
    *a1 = 0;
  }
  else
  {
    TDescriptorSource::TDescriptorSource((TDescriptorSource *)&v6);
    TDescriptorSource::CreateDefaultDescriptor(*a3, a1);
  }
}

void TFont::UserFallbacksForLanguage(atomic_ullong *a1, uint64_t a2, __CFString *a3, int *a4)
{
  *a1 = 0xAAAAAAAAAAAAAAAALL;
  CFDictionaryRef Value = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)(a2 + 160), memory_order_acquire);
  CFDictionaryRef v9 = Value;
  if (Value) {
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(Value, @"NSCTFontCascadeListAttribute");
  }
  *a1 = (atomic_ullong)Value;

  id v22 = (id)0xAAAAAAAAAAAAAAAALL;
  if (a3)
  {
    LanguageIdentifierByNormalizing(a3, 0, (atomic_ullong *)&v22);
  }
  else
  {
    CFDictionaryRef v11 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)(a2 + 160), memory_order_acquire);
    CFDictionaryRef v12 = v11;
    if (v11) {
      CFDictionaryRef v11 = (const __CFDictionary *)CFDictionaryGetValue(v11, @"CTFontDescriptorLanguageAttribute");
    }
    LanguageIdentifierByNormalizing((__CFString *)v11, 0, (atomic_ullong *)&v22);
  }
  if (!atomic_load_explicit(a1, memory_order_acquire)
    && TDescriptorSource::CanLanguageAffectCascadeList((const __CFString *)atomic_load_explicit((atomic_ullong *volatile)&v22, memory_order_acquire), v10))
  {
    id values = (void *)atomic_load_explicit((atomic_ullong *volatile)&v22, memory_order_acquire);
    CFArrayRef v13 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&values, 1, MEMORY[0x1E4F1D510]);
    TFont::CreateDefaultCascadeList((TFont *)a2, v13, (atomic_ullong *)&values);
  }
  int EmojiPolicyFromLocale = GetEmojiPolicyFromLocale(a3);
  int v15 = EmojiPolicyFromLocale;
  if (a4)
  {
    *a4 = EmojiPolicyFromLocale;
    int v15 = -1431655766;
  }
  if (EmojiPolicyFromLocale)
  {
    if (atomic_load_explicit(a1, memory_order_acquire))
    {
      CFArrayRef explicit = 0;
    }
    else
    {
      TFont::CreateDefaultCascadeList((TFont *)a2, 0, (atomic_ullong *)&values);

      CFArrayRef explicit = (const __CFArray *)atomic_load_explicit(a1, memory_order_acquire);
    }
    id values = (void *)0xAAAAAAAAAAAAAAAALL;
    TCFMutableArray::TCFMutableArray((TCFMutableArray *)&values, (CFArrayRef)atomic_load_explicit(a1, memory_order_acquire));
    int IsSystemUIFontAndForShaping = TFont::IsSystemUIFontAndForShaping((atomic_ullong *)a2, (BOOL *)&v21);
    id v21 = (id)0xAAAAAAAAAAAAAAAALL;
    int v18 = v15;
    if (a4) {
      int v18 = *a4;
    }
    if (v18 == 2)
    {
      TDescriptorSource::TDescriptorSource((TDescriptorSource *)&v20);
      TDescriptorSource::CopyEmojiFontDescriptor(explicit, &v20, IsSystemUIFontAndForShaping, (atomic_ullong *)&v21);
    }
    else
    {
      TDescriptorSource::TDescriptorSource((TDescriptorSource *)&v20);
      TDescriptorSource::CopySystemFontDescriptorByName(&v20, @"Menlo-Regular", IsSystemUIFontAndForShaping, 0, (atomic_ullong *)&v21);
    }
    id v19 = (id)atomic_load_explicit((atomic_ullong *volatile)&v21, memory_order_acquire);
    CFArrayInsertValueAtIndex((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&values, memory_order_acquire), 0, v19);
  }
  if (((*(uint64_t (**)(void))(**(void **)(a2 + 400) + 160))(*(void *)(a2 + 400)) & 0x2000) != 0)
  {
    if (a4) {
      int v15 = *a4;
    }
    if (v15 != 1)
    {
      id values = (void *)0xAAAAAAAAAAAAAAAALL;
      TCFMutableArray::TCFMutableArray((TCFMutableArray *)&values, (CFArrayRef)atomic_load_explicit(a1, memory_order_acquire));
      CFArrayInsertValueAtIndex((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&values, memory_order_acquire), 0, (const void *)atomic_load_explicit((atomic_ullong *volatile)(a2 + 8), memory_order_acquire));
    }
  }
}

void TFont::CreateDefaultCascadeList(TFont *this@<X0>, const __CFArray *a2@<X1>, atomic_ullong *a3@<X8>)
{
  unint64_t v4 = (atomic_ullong *)*((void *)this + 50);
  if (v4)
  {
    id v7 = (id)0xAAAAAAAAAAAAAAAALL;
    CreateCanonicalLanguages(a2, &v7);
    int IsSystemUIFontAndForShaping = TFont::IsSystemUIFontAndForShaping((atomic_ullong *)this, &v8);
    TBaseFont::CreateFallbacks(v4, IsSystemUIFontAndForShaping, ((unint64_t)*(unsigned int *)this >> 6) & 7, 0, (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v7, memory_order_acquire), a3);
  }
  else
  {
    *a3 = 0;
  }
}

BOOL TFont::DerivedOpticalFont(atomic_ullong *a1, atomic_ullong *a2, unsigned int *a3, double a4)
{
  unint64_t explicit = atomic_load_explicit(a2, memory_order_acquire);
  if (!explicit) {
    return explicit != 0;
  }
  CFDictionaryRef v9 = (TDescriptor **)(id)atomic_load_explicit(a2, memory_order_acquire);
  CFStringRef v10 = v9;
  CFDictionaryRef v11 = v9[5];
  if ((*((_DWORD *)v11 + 4) & 0x80000000) == 0) {
    TDescriptor::InitBaseFont(v9[5], 0x8000, 0.0);
  }
  CFDictionaryRef v12 = (TSplicedFont *)atomic_load_explicit((atomic_ullong *volatile)v11 + 4, memory_order_acquire);

  id v34 = (id)0xAAAAAAAAAAAAAAAALL;
  DerivedOpticalFontDescriptor((atomic_ullong *)&v34, (TDescriptor **)atomic_load_explicit(a2, memory_order_acquire), a4, v12);
  if (atomic_load_explicit((atomic_ullong *volatile)&v34, memory_order_acquire)) {

  }
  CFArrayRef v13 = (id)atomic_load_explicit(a2, memory_order_acquire);
  long long v14 = (atomic_ullong *)(v13[5] + 8);
  atomic_load_explicit(v14, memory_order_acquire);
  CFDictionaryRef v15 = (const __CFDictionary *)atomic_load_explicit(v14, memory_order_acquire);
  uint64_t v16 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
  if (v15)
  {
    CFDictionaryRef Value = CFDictionaryGetValue(v15, @"NSCTFontFeatureSettingsAttribute");

    if (Value) {
      goto LABEL_15;
    }
  }
  else
  {
  }
  CFDictionaryRef v18 = (const __CFDictionary *)(id)atomic_load_explicit(a1 + 20, memory_order_acquire);
  if (!v18)
  {
    CFDictionaryRef v21 = 0;
    goto LABEL_14;
  }
  CFDictionaryRef v19 = v18;
  long long v20 = (void *)CFDictionaryGetValue(v18, @"CTFontOriginalFeatureSettingsAttribute");

  if (v20)
  {
    id values = v20;
    id keys = @"NSCTFontFeatureSettingsAttribute";
    CFDictionaryRef v21 = CFDictionaryCreate(*v16, (const void **)&keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    id values = (void *)atomic_load_explicit(a2, memory_order_acquire);
    id v33 = v21;
    TCFBase_NEW<CTFontDescriptor,CTFontDescriptor*,__CFDictionary const*&>((uint64_t *)&values, (const __CFDictionary **)&v33, &keys);

LABEL_14:
  }
LABEL_15:
  if (TFont::ShouldPropagateFeatureSetting(a1, (const TFontFeatureSettingList *)(a1 + 21)))
  {
    *a3 = *a3 & 0xFFFFFFF3 | 4;
    unint64_t v22 = atomic_load_explicit(a2, memory_order_acquire);
    LODWORD(values) = 35;
    CFAllocatorRef v23 = *v16;
    id keys = CFNumberCreate(*v16, kCFNumberIntType, &values);
    CFNumberRef v24 = (const __CFNumber *)atomic_exchange((atomic_ullong *volatile)&keys, 0);

    LODWORD(values) = 14;
    id keys = CFNumberCreate(v23, kCFNumberIntType, &values);
    CFNumberRef v25 = (const __CFNumber *)atomic_exchange((atomic_ullong *volatile)&keys, 0);

    uint64_t v26 = TCFBase<TDescriptor>::Allocate();
    if (v26)
    {
      unint64_t v27 = (void *)v26;
      __int16 v28 = (TDescriptor *)(v26 + 48);
      v27[2] = 0;
      v27[3] = TDescriptor::Hash;
      v27[4] = 0;
      v27[5] = v28;
      TDescriptor::TDescriptor(v28, *(const TDescriptor **)(v22 + 40), v24, v25);
      id keys = v27;
      id values = (void *)atomic_exchange((atomic_ullong *volatile)&keys, 0);
    }
    else
    {
      id values = 0;
    }
  }
  uint64_t EmojiMLUpscalingTimeout = TFont::GetEmojiMLUpscalingTimeout(a1);
  if (v30)
  {
    *a3 &= ~8u;
    TCFNumber::TCFNumber<double>(&v33, *(double *)&EmojiMLUpscalingTimeout);
    id values = (void *)atomic_load_explicit((atomic_ullong *volatile)&v33, memory_order_acquire);
    id keys = @"CTFontEmojiMLUpscalingTimeoutAttribute";
    CFDictionaryRef v31 = CFDictionaryCreate(*v16, (const void **)&keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);

    id values = (void *)atomic_load_explicit(a2, memory_order_acquire);
    id v33 = v31;
    TCFBase_NEW<CTFontDescriptor,CTFontDescriptor*,__CFDictionary const*&>((uint64_t *)&values, (const __CFDictionary **)&v33, &keys);
  }
  return explicit != 0;
}

void DerivedOpticalFontDescriptor(atomic_ullong *a1, TDescriptor **a2, double a3, TSplicedFont *a4)
{
  if (!a4 || !(*(unsigned int (**)(TSplicedFont *))(*(void *)a4 + 840))(a4)) {
    goto LABEL_19;
  }
  if ((*(unsigned int (**)(TSplicedFont *))(*(void *)a4 + 16))(a4) == 1414743620)
  {
    unint64_t OpticalSizeComponent = TSplicedFont::GetOpticalSizeComponent(a4, a3);
    if (OpticalSizeComponent)
    {
      LODWORD(v12) = 1024;
      TCFBase_NEW<CTFontDescriptor,TBaseFont const*&,$_24>(&v13, (uint64_t *)&OpticalSizeComponent, (int *)&v12);
      *a1 = atomic_exchange((atomic_ullong *volatile)&v13, 0);

      return;
    }
  }
  int v8 = (*(uint64_t (**)(TSplicedFont *))(*(void *)a4 + 16))(a4);
  BOOL v9 = v8 == 1414809156 || v8 == 1413695044;
  if (!v9
    || ((double v12 = NAN,
         *(double *)&id v13 = NAN,
         (*(unsigned int (**)(TSplicedFont *, id *, double *))(*(void *)a4 + 424))(a4, &v13, &v12))
      ? (BOOL v10 = *(double *)&v13 > a3)
      : (BOOL v10 = 1),
        v10 || (v12 != 0.0 ? (BOOL v11 = v12 < a3) : (BOOL v11 = 0), v11)))
  {
    TDescriptor::CreateMatchingDescriptor(a2[5], 0, a3, 1024, a1);
  }
  else
  {
LABEL_19:
    *a1 = 0;
  }
}

uint64_t TFont::TFont(uint64_t a1, unsigned int *a2, unsigned __int16 *a3, uint64_t a4, __CFString *a5, unint64_t a6, char a7, uint64_t *a8)
{
  *(_DWORD *)a1 = 0;
  *(void *)(a1 + 8) = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v16 = (atomic_ullong *)(a1 + 8);
  int v55 = -1431655766;
  TFont::DefaultDescriptor((void *)(a1 + 8), (atomic_ullong *)a2, &v55);
  if (atomic_load_explicit(v16, memory_order_acquire))
  {
    *(_DWORD *)a1 |= 8u;
    goto LABEL_63;
  }
  char v49 = a7;
  id v54 = (id)0xAAAAAAAAAAAAAAAALL;
  TFont::UserFallbacksForLanguage((atomic_ullong *)&v54, (uint64_t)a2, a5, 0);
  if (a6 == -1) {
    unint64_t v18 = ((unint64_t)*a2 >> 6) & 7;
  }
  else {
    unint64_t v18 = a6;
  }
  CFArrayRef explicit = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v54, memory_order_acquire);
  if (!a3)
  {
    id v53 = 0;
    goto LABEL_60;
  }
  BOOL v50 = a8;
  unint64_t v47 = v16;
  uint64_t v20 = 0;
  int v21 = v55;
  CFArrayRef v48 = explicit;
  CGAffineTransform v52 = (atomic_ullong *)*((void *)a2 + 50);
  int v51 = v55;
  while (2)
  {
    if (!v18 && v20)
    {
      id v53 = 0;
      uint64_t v16 = v47;
      a8 = v50;
      goto LABEL_60;
    }
    CFArrayRef CascadeListForFallbackStage = TBaseFont::GetCascadeListForFallbackStage(v52, v20, explicit, v21, v18, a3, a4);
    if (!CascadeListForFallbackStage) {
      goto LABEL_49;
    }
    id v53 = 0;
    if (!a4)
    {
      TBaseFont::DefaultFallbackDescriptor(CascadeListForFallbackStage, v21, &v57);

      goto LABEL_47;
    }
    CFArrayRef v23 = CascadeListForFallbackStage;
    uint64_t v24 = 0;
    while (v24 < a4)
    {
      uint64_t v25 = v24 + 1;
      unsigned int v26 = a3[v24];
      BOOL v27 = (v26 & 0xFC00) != 0xD800 || v25 == a4;
      if (v27 || (int v28 = a3[v25], (v28 & 0xFC00) != 0xDC00))
      {
        if (v26 < 0xFE0E)
        {
          BOOL v29 = 0;
          goto LABEL_24;
        }
        if (v26 >> 4 <= 0xFE0)
        {
          if (v26 == 65038) {
            int v30 = 1;
          }
          else {
            int v30 = 2;
          }
          goto LABEL_44;
        }
      }
      else
      {
        uint64_t v25 = v24 + 2;
        unsigned int v26 = (v26 << 10) - 56613888 + v28;
      }
      BOOL v29 = v26 - 127995 < 5;
LABEL_24:
      uint64_t v24 = v25;
      int v30 = 2;
      if (v26 == 8205 || v29) {
        goto LABEL_44;
      }
    }
    if (v20 != 2) {
      goto LABEL_43;
    }
    UChar32 v31 = *a3;
    if (a4 != 1 && (v31 & 0xFC00) == 0xD800)
    {
      int v32 = a3[1];
      BOOL v27 = (v32 & 0xFC00) == 56320;
      UChar32 v33 = (v31 << 10) - 56613888 + v32;
      if (v27) {
        UChar32 v31 = v33;
      }
    }
    if (u_hasBinaryProperty(v31, UCHAR_EMOJI_PRESENTATION))
    {
      int v30 = 2;
      goto LABEL_44;
    }
    if (v31 == 9792 || v31 == 9877 || v31 == 9794) {
      int v30 = 1;
    }
    else {
LABEL_43:
    }
      int v30 = 0;
LABEL_44:
    TBaseFont::FindFallbackDescriptorForCharacters((uint64_t)v52, (uint64_t)v23, a3, a4, v50, v30, v21, v20, (atomic_ullong *)&v57, v49);

    if (v20 == 1)
    {
      TDescriptorSource::CopyPossibleSystemUIFontDescriptor((atomic_ullong *)&v53, v21, &v57);
    }
    CFArrayRef explicit = v48;
LABEL_47:
    if (!atomic_load_explicit((atomic_ullong *volatile)&v53, memory_order_acquire))
    {

      int v21 = v51;
LABEL_49:
      if (++v20 == 3)
      {
        id v57 = (id)0xAAAAAAAAAAAAAAAALL;
        TDescriptorSource::TDescriptorSource((TDescriptorSource *)&v56);
        TDescriptorSource::CopySystemWideFallbackDescriptorForCharacters(&v56, (uint64_t)v52, (uint64_t)a3, a4, v21, v18, (atomic_ullong *)&v57);
        id v34 = (void *)atomic_load_explicit((atomic_ullong *volatile)&v57, memory_order_acquire);
        if (v34)
        {
          unint64_t v35 = (TDescriptor **)(id)atomic_load_explicit((atomic_ullong *volatile)&v57, memory_order_acquire);
          uint8x8_t v36 = v35;
          uint64_t v37 = v35[5];
          uint64_t v16 = v47;
          a8 = v50;
          if ((*((_DWORD *)v37 + 4) & 0x80000000) == 0) {
            TDescriptor::InitBaseFont(v35[5], 0, 0.0);
          }
          unint64_t v38 = atomic_load_explicit((atomic_ullong *volatile)v37 + 4, memory_order_acquire);
          uint64_t *v50 = (*(uint64_t (**)(unint64_t, unsigned __int16 *, uint64_t, void))(*(void *)v38
                                                                                                  + 808))(v38, a3, a4, 0);

          *(_DWORD *)a1 |= 8u;
          id v34 = (void *)atomic_exchange((atomic_ullong *volatile)&v57, 0);
        }
        else
        {
          a8 = v50;
          uint64_t *v50 = 0;
          uint64_t v16 = v47;
        }
        id v53 = v34;

        goto LABEL_60;
      }
      continue;
    }
    break;
  }
  BOOL v27 = (v20 & 0x7FFFFFFFFFFFFFFDLL) == 0;
  uint64_t v16 = v47;
  a8 = v50;
  if (v27) {
    *(_DWORD *)a1 |= 8u;
  }
LABEL_60:

  if (!TFont::DerivedOpticalFont((atomic_ullong *)a2, v16, (unsigned int *)a1, *((double *)a2 + 2)))
  {
    *a8 = 0;
    TDescriptorSource::TDescriptorSource((TDescriptorSource *)&v56);
    TDescriptorSource::CopyLastResort(&v57);

    *(_DWORD *)a1 |= 8u;
  }

LABEL_63:
  *(double *)(a1 + 16) = TFont::InitSize(0, *((double *)a2 + 2), v17);
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 32) = 0x80000000;
  TFont::InitMatrix(*((TFont **)a2 + 5), 0, (void *)(a1 + 40));
  *(void *)(a1 + 184) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  long long v39 = *MEMORY[0x1E4F1DB28];
  long long v40 = *(_OWORD *)(MEMORY[0x1E4F1DB28] + 16);
  *(_OWORD *)(a1 + 88) = *MEMORY[0x1E4F1DAD8];
  *(_OWORD *)(a1 + 104) = v39;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 12CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = v40;
  *(unsigned char *)(a1 + 136) = 0;
  *(void *)(a1 + 192) = 0;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 16CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = 0u;
  *(void *)(a1 + 176) = a1 + 184;
  *(_DWORD *)(a1 + 20CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = 0;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_DWORD *)(a1 + 24CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = 1065353216;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_DWORD *)(a1 + 28CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = 1065353216;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 32CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_DWORD *)(a1 + 368) = 0;
  *(void *)(a1 + 376) = 0;
  *(void *)(a1 + 384) = 0;
  *(unsigned char *)(a1 + 392) = 0;
  *(void *)(a1 + 40CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = TFont::InitBaseFont(v41, v16);
  *(void *)(a1 + 408) = 0;
  *(_DWORD *)(a1 + 416) = 0;
  *(_OWORD *)(a1 + 456) = 0u;
  *(_OWORD *)(a1 + 472) = 0u;
  *(void *)(a1 + 432) = 0;
  *(void *)(a1 + 44CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = 0;
  *(void *)(a1 + 424) = 0;
  *(_DWORD *)(a1 + 448) = 0;
  *(_DWORD *)(a1 + 488) = 1065353216;
  *(void *)(a1 + 496) = 0;
  *(_DWORD *)(a1 + 504) = 0;
  *(void *)(a1 + 512) = 0;
  *(unsigned char *)(a1 + 52CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = 0;
  *(void *)(a1 + 536) = 0;
  *(void *)(a1 + 544) = 0;
  *(void *)(a1 + 528) = 0;
  float64x2_t v42 = (const __CTFontDescriptor *)atomic_load_explicit((atomic_ullong *volatile)(a1 + 8), memory_order_acquire);
  CFDictionaryRef v43 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)a2 + 20, memory_order_acquire);
  CFDictionaryRef v44 = v43;
  if (v43) {
    CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(v43, @"CTFontOriginalFeatureSettingsAttribute");
  }
  else {
    CFArrayRef Value = 0;
  }

  TFont::SetExtras((atomic_ullong *)a1, v42, Value);
  *(_DWORD *)a1 = *a2 | 0xC0;
  TFont::SetOpticalSize((TFont *)a1, 0);
  TFont::AddFontSpecificFeatureSettings((TFont *)a1);
  return a1;
}

void TFont::TFont(TFont *this, atomic_ullong *a2, const unsigned __int16 *a3, uint64_t a4, CFRange *a5)
{
  int v8 = (const TFont *)a2;
  *(_DWORD *)this = 0;
  *((void *)this + 1) = 0xAAAAAAAAAAAAAAAALL;
  BOOL v10 = (atomic_ullong *)((char *)this + 8);
  int v30 = -1431655766;
  TFont::DefaultDescriptor((void *)this + 1, a2, &v30);
  if (atomic_load_explicit(v10, memory_order_acquire))
  {
    *(_DWORD *)this |= 8u;
    goto LABEL_26;
  }
  id v29 = (id)0xAAAAAAAAAAAAAAAALL;
  TFont::UserFallbacksForLanguage((atomic_ullong *)&v29, (uint64_t)v8, 0, 0);
  CFArrayRef explicit = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v29, memory_order_acquire);
  if (!a3)
  {
    id v28 = 0;
    goto LABEL_23;
  }
  unsigned int v26 = v8;
  BOOL v27 = a5;
  uint64_t v13 = 0;
  int v14 = v30;
  unint64_t v15 = ((unint64_t)*(unsigned int *)v8 >> 6) & 7;
  uint64_t v16 = (atomic_ullong *)*((void *)v8 + 50);
  while (1)
  {
    if (!v15 && v13)
    {
      id v28 = 0;
      int v8 = v26;
      goto LABEL_23;
    }
    CFArrayRef CascadeListForFallbackStage = TBaseFont::GetCascadeListForFallbackStage(v16, v13, explicit, v14, v15, a3, a4);
    if (!CascadeListForFallbackStage) {
      goto LABEL_13;
    }
    id v28 = (id)0xAAAAAAAAAAAAAAAALL;
    if (a4) {
      TBaseFont::FindFallbackDescriptorForCharacterRange((TBaseFont *)v16, CascadeListForFallbackStage, a3, v27, a4, (atomic_ullong *)&v28);
    }
    else {
      TBaseFont::DefaultFallbackDescriptor(CascadeListForFallbackStage, 0, &v28);
    }
    if (atomic_load_explicit((atomic_ullong *volatile)&v28, memory_order_acquire)) {
      break;
    }

LABEL_13:
    if (++v13 == 3)
    {
      id v32 = (id)0xAAAAAAAAAAAAAAAALL;
      TDescriptorSource::TDescriptorSource((TDescriptorSource *)&v31);
      TDescriptorSource::CopySystemWideFallbackDescriptorForCharacters(&v31, (uint64_t)v16, (uint64_t)a3, a4, v14, v15, (atomic_ullong *)&v32);
      unint64_t v18 = (void *)atomic_load_explicit((atomic_ullong *volatile)&v32, memory_order_acquire);
      if (v18)
      {
        CFDictionaryRef v19 = (TDescriptor **)(id)atomic_load_explicit((atomic_ullong *volatile)&v32, memory_order_acquire);
        uint64_t v20 = v19;
        int v21 = v19[5];
        int v8 = v26;
        if ((*((_DWORD *)v21 + 4) & 0x80000000) == 0) {
          TDescriptor::InitBaseFont(v19[5], 0, 0.0);
        }
        unint64_t v22 = atomic_load_explicit((atomic_ullong *volatile)v21 + 4, memory_order_acquire);
        v27->locatiouint64_t n = (*(uint64_t (**)(unint64_t, const unsigned __int16 *, uint64_t))(*(void *)v22 + 816))(v22, a3, a4);
        v27->CFIndex length = v23;

        *(_DWORD *)this |= 8u;
        unint64_t v18 = (void *)atomic_exchange((atomic_ullong *volatile)&v32, 0);
      }
      else
      {
        int v8 = v26;
      }
      id v28 = v18;

      goto LABEL_23;
    }
  }
  int v8 = v26;
  if ((v13 & 0x7FFFFFFFFFFFFFFDLL) == 0) {
    *(_DWORD *)this |= 8u;
  }
LABEL_23:

  if (!TFont::DerivedOpticalFont((atomic_ullong *)v8, v10, (unsigned int *)this, *((double *)v8 + 2)))
  {
    TDescriptorSource::TDescriptorSource((TDescriptorSource *)&v31);
    TDescriptorSource::CopyLastResort(&v32);

    *(_DWORD *)this |= 8u;
  }

LABEL_26:
  *((double *)this + 2) = TFont::InitSize(0, *((double *)v8 + 2), v11);
  *((void *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0x80000000;
  TFont::InitMatrix(*((TFont **)v8 + 5), 0, (void *)this + 5);
  *((_DWORD *)this + 12) = 0;
  *(_OWORD *)((char *)this + 88) = *MEMORY[0x1E4F1DAD8];
  long long v24 = *(_OWORD *)(MEMORY[0x1E4F1DB28] + 16);
  *(_OWORD *)((char *)this + 104) = *MEMORY[0x1E4F1DB28];
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 12CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = v24;
  *((unsigned char *)this + 136) = 0;
  *((void *)this + 24) = 0;
  *((void *)this + 23) = 0;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 1CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = 0u;
  *((void *)this + 22) = (char *)this + 184;
  *((_DWORD *)this + 5CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = 0;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *((_DWORD *)this + 6CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = 1065353216;
  *(_OWORD *)((char *)this + 248) = 0u;
  *(_OWORD *)((char *)this + 264) = 0u;
  *((_DWORD *)this + 7CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = 1065353216;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 19) = 0u;
  *((_OWORD *)this + 2CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = 0u;
  *((_OWORD *)this + 21) = 0u;
  *((_OWORD *)this + 22) = 0u;
  *((_DWORD *)this + 92) = 0;
  *((void *)this + 47) = 0;
  *((void *)this + 48) = 0;
  *((unsigned char *)this + 392) = 0;
  *((void *)this + 5CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = TFont::InitBaseFont(v25, v10);
  *((void *)this + 51) = 0;
  *((_DWORD *)this + 104) = 0;
  *(_OWORD *)((char *)this + 456) = 0u;
  *(_OWORD *)((char *)this + 472) = 0u;
  *((void *)this + 54) = 0;
  *((void *)this + 55) = 0;
  *((void *)this + 53) = 0;
  *((_DWORD *)this + 112) = 0;
  *((_DWORD *)this + 122) = 1065353216;
  *((void *)this + 62) = 0;
  *((_DWORD *)this + 126) = 0;
  *((void *)this + 64) = 0;
  *((unsigned char *)this + 52CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = 0;
  *((void *)this + 66) = 0;
  *((void *)this + 68) = 0;
  *((void *)this + 67) = 0;
  TFont::SetExtras((atomic_ullong *)this, (const __CTFontDescriptor *)atomic_load_explicit((atomic_ullong *volatile)this + 1, memory_order_acquire), 0);
  *(_DWORD *)this = *(_DWORD *)v8 | 0xC0;
  TFont::SetOpticalSize(this, 0);
  TFont::AddFontSpecificFeatureSettings(this);
}

void TFont::CoverageForFeatureSetting(TBaseFont **this@<X0>, CTFeatureSetting *a2@<X1>, void *a3@<X8>)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  id Mutable = CFBitVectorCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  GlyphCFIndex Count = (void *)TBaseFont::GetGlyphCount(this[50]);
  CFBitVectorSetCount((CFMutableBitVectorRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), (CFIndex)GlyphCount);
  id v7 = this[50];
  if (v7)
  {
    id v27 = (id)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(id *__return_ptr, const TBaseFont *, void))(*(void *)v7 + 136))(&v26, v7, 0);
    id v27 = (id)atomic_exchange((atomic_ullong *volatile)&v26, 0);

    id v26 = (id)0xAAAAAAAAAAAAAAAALL;
    int v21 = a2;
    TFontFeatures::SettingsByNormalizing((atomic_ullong *)&v27, v7, (uint64_t)a2, 0, (CFArrayRef *)&v26);
    CFArrayRef explicit = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v26, memory_order_acquire);
    if (explicit)
    {
      CFIndex Count = CFArrayGetCount(explicit);
      if (Count)
      {
        CFIndex v10 = Count;
        for (CFIndex i = 0; i != v10; ++i)
        {
          CFDictionaryRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(explicit, i);
          id v13 = (id)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
          id v14 = (id)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
          v24[1] = GlyphCount;
          id v25 = v13;
          uint8x8_t v36 = 0;
          unint64_t v15 = operator new(0x18uLL);
          *unint64_t v15 = &unk_1ED061CE8;
          v15[1] = GlyphCount;
          v15[2] = atomic_exchange((atomic_ullong *volatile)&v25, 0);
          uint8x8_t v36 = v15;
          v24[0] = v14;
          id v34 = 0;
          uint64_t v16 = operator new(0x10uLL);
          unint64_t v17 = atomic_exchange((atomic_ullong *volatile)v24, 0);
          *uint64_t v16 = &unk_1ED061D30;
          v16[1] = v17;
          id v34 = v16;
          if ((TAATMorphTable::AddCoveredGlyphs(this, ValueAtIndex, (uint64_t)v35, (uint64_t)v33) & 1) == 0)
          {
            v22[1] = GlyphCount;
            id v23 = v13;
            id v32 = 0;
            unint64_t v18 = operator new(0x18uLL);
            void *v18 = &unk_1ED061CE8;
            v18[1] = GlyphCount;
            void v18[2] = atomic_exchange((atomic_ullong *volatile)&v23, 0);
            id v32 = v18;
            v22[0] = v14;
            int v30 = 0;
            CFDictionaryRef v19 = operator new(0x10uLL);
            unint64_t v20 = atomic_exchange((atomic_ullong *volatile)v22, 0);
            *CFDictionaryRef v19 = &unk_1ED061D30;
            v19[1] = v20;
            int v30 = v19;
            TOpenTypeMorph::AddCoveredGlyphs((uint64_t)this, (uint64_t)v21, (uint64_t)v31, (uint64_t)v29);
            std::__function::__value_func<void ()(void)>::~__value_func[abi:nn180100](v29);

            std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100](v31);
          }
          std::__function::__value_func<void ()(void)>::~__value_func[abi:nn180100](v33);

          std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100](v35);
        }
      }
    }
  }
  *a3 = atomic_exchange((atomic_ullong *volatile)&Mutable, 0);
}

void TFont::ShapingLanguages(TFont *this@<X0>, void *a2@<X8>)
{
  uint64_t v3 = (TBaseFont *)*((void *)this + 50);
  if (v3)
  {
    id v4 = (id)0xAAAAAAAAAAAAAAAALL;
    TBaseFont::ShapingLanguages(v3, 0, &v4);
    if (atomic_load_explicit((atomic_ullong *volatile)&v4, memory_order_acquire))
    {
      CreateSetWithArray((const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v4, memory_order_acquire), a2);

      return;
    }
  }
  *a2 = 0;
}

BOOL TFont::UseTypoMetrics(TFont *this)
{
  uint64_t v1 = *((void *)this + 50);
  memset(v5, 170, sizeof(v5));
  (*(void (**)(id *__return_ptr))(*(void *)v1 + 480))(&v4);
  OS2::OS2((atomic_ullong *)v5, (atomic_ullong *)&v4);

  BOOL v2 = (uint64_t)v5[2] >= 78 && *((__int16 *)v5[1] + 31) < 0;
  return v2;
}

uint64_t TFont::GetTypoMetrics(TBaseFont **this, double *a2, double *a3, double *a4)
{
  uint64_t result = TBaseFont::GetInitializedGraphicsFont(this[50]);
  if (result)
  {
    uint64_t result = CGFontGetParserFont();
    if (result)
    {
      uint64_t result = FPFontGetTypoMetrics();
      if (result)
      {
        if (*((_DWORD *)this + 12)) {
          initedouble d = (int *)(this + 6);
        }
        else {
          initedouble d = TFont::InitStrikeMetrics((TFont *)this);
        }
        double v10 = *((double *)inited + 6);
        if (a2) {
          *a2 = v10 * *a2;
        }
        if (a3) {
          *a3 = v10 * *a3;
        }
        if (a4) {
          *a4 = v10 * *a4;
        }
        return 1;
      }
    }
  }
  return result;
}

double TFont::GetHorizontalAscentDescent(TBaseFont **this)
{
  if (*(unsigned char *)this)
  {
    void v3[5] = unk_184B8A268;
    v3[0] = __const__ZNK5TFont26GetHorizontalAscentDescentEv_metrics;
    memset(&v3[1], 255, 64);
    TFont::GetStrikeMetrics(this, 0, (uint64_t)v3);
    return *((double *)v3 + 1);
  }
  else
  {
    if (*((_DWORD *)this + 12)) {
      initedouble d = (int *)(this + 6);
    }
    else {
      initedouble d = TFont::InitStrikeMetrics((TFont *)this);
    }
    return *((double *)inited + 1);
  }
}

void TFont::GetControlPoints(TBaseFont **this@<X0>, unsigned int a2@<W2>, void *a3@<X8>)
{
  id __p = 0;
  unint64_t v18 = 0;
  uint64_t v19 = 0;
  if (!TBaseFont::GetInitializedGraphicsFont(this[50]) || !CGFontGetParserFont())
  {
    uint64_t v14 = 0;
    int v8 = 0;
    BOOL v9 = 0;
LABEL_13:
    *a3 = v9;
    a3[1] = v8;
    a3[2] = v14;
    return;
  }
  unsigned int v16 = 0;
  if ((FPFontGetControlPoints() & 1) == 0)
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    return;
  }
  unsigned int v6 = v16;
  if (a2 && v16 > a2)
  {
    unsigned int v16 = a2;
    unsigned int v6 = a2;
  }
  std::vector<CGSize>::resize((uint64_t)&__p, v6);
  if (FPFontGetControlPoints())
  {
    *(void *)&long long v7 = -1;
    *((void *)&v7 + 1) = -1;
    *(_OWORD *)&v15.c = v7;
    *(_OWORD *)&v15.tdouble x = v7;
    *(_OWORD *)&v15.double a = v7;
    TFont::GetScaledMatrix((TFont *)this, &v15);
    BOOL v9 = __p;
    int v8 = v18;
    if (__p != v18)
    {
      float64x2_t v10 = *(float64x2_t *)&v15.a;
      float64x2_t v11 = *(float64x2_t *)&v15.c;
      double v12 = (double *)__p;
      float64x2_t v13 = *(float64x2_t *)&v15.tx;
      do
      {
        *(float64x2_t *)double v12 = vaddq_f64(v13, vmlaq_n_f64(vmulq_n_f64(v11, v12[1]), v10, *v12));
        v12 += 2;
      }
      while (v12 != v8);
    }
    uint64_t v14 = v19;
    goto LABEL_13;
  }
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  if (__p)
  {
    unint64_t v18 = (double *)__p;
    operator delete(__p);
  }
}

void TFont::GetControlPointPositions(TBaseFont **this, unsigned __int16 a2, const __int16 *a3, double *a4, unint64_t a5)
{
  long long v7 = a3;
  int v8 = a3;
  if (a5 >= 2)
  {
    BOOL v9 = a3 + 1;
    int v10 = a3[1];
    int v11 = *a3;
    int v8 = v10 >= v11 ? a3 + 1 : a3;
    if (a5 != 2)
    {
      double v12 = a3 + 2;
      if (v10 >= v11) {
        BOOL v9 = a3;
      }
      if (v10 <= v11) {
        LOWORD(v13) = *a3;
      }
      else {
        LOWORD(v13) = a3[1];
      }
      if (v10 <= v11) {
        LOWORD(v11) = a3[1];
      }
      uint64_t v14 = 2 * a5 - 6;
      while (v14)
      {
        int v15 = v12[1];
        int v16 = *v12;
        if (v15 >= v16)
        {
          if (v16 < (__int16)v11)
          {
            LOWORD(v11) = *v12;
            BOOL v9 = v12;
          }
          BOOL v18 = v15 < (__int16)v13;
          if (v15 > (__int16)v13) {
            LOWORD(v13) = v12[1];
          }
          if (!v18) {
            int v8 = v12 + 1;
          }
        }
        else
        {
          int v11 = *v9;
          if (v15 < v11)
          {
            LOWORD(v11) = v12[1];
            BOOL v9 = v12 + 1;
          }
          int v13 = *v8;
          BOOL v17 = v16 < v13;
          if (v16 > v13) {
            LOWORD(v13) = *v12;
          }
          if (!v17) {
            int v8 = v12;
          }
        }
        v12 += 2;
        v14 -= 4;
        if (v14 == -2) {
          goto LABEL_34;
        }
      }
      int v19 = *v12;
      if (v19 >= *v9 && v19 >= *v8) {
        int v8 = v12;
      }
    }
  }
LABEL_34:
  unsigned int v20 = *v8 + 1;
  memset(v31, 170, sizeof(v31));
  TFont::GetControlPoints(this, v20, v31);
  int v21 = (void *)v31[0];
  int64_t v22 = v31[1] - v31[0];
  if (v31[1] != v31[0])
  {
    id v28 = 0;
    __dst = 0;
    uint64_t v30 = 0;
    std::vector<CGSize>::__vallocate[abi:nn180100](&v28, v22 >> 4);
    id v23 = (char *)__dst;
    memmove(__dst, v21, v22);
    __dst = &v23[v22];
    long long v24 = v28;
    uint64_t v25 = 2 * a5;
    do
    {
      uint64_t v26 = 0;
      if ((*v7 & 0x80000000) == 0)
      {
        unint64_t v27 = *(unsigned __int16 *)v7;
        if (v22 >> 4 > v27) {
          uint64_t v26 = v24[2 * v27];
        }
      }
      *(void *)a4++ = v26;
      ++v7;
      v25 -= 2;
    }
    while (v25);
    if (v24)
    {
      __dst = v24;
      operator delete(v24);
    }
  }
  if (v21) {
    operator delete(v21);
  }
}

BOOL TFont::HasColorBitmapForGlyph(TBaseFont **this, unsigned int a2, const __CFData *a3)
{
  __int16 v4 = a2;
  if (TBaseFont::GetGlyphCount(this[50]) <= a2) {
    return 0;
  }
  TBaseFont::GetGlyphCount(this[50]);
  TsbixContext::TsbixContext((TsbixContext *)v8, a3);
  TFont::FindColorBitmapForGlyph((TFont *)this, v4, (uint64_t)v8, (uint64_t)v9, 1.0);
  BOOL v6 = v9[48] != 0;

  return v6;
}

void OTL::GCommon::GetLookups(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v12[6] = v4;
  void v12[5] = v4;
  v12[4] = v4;
  void v12[3] = v4;
  void v12[2] = v4;
  v12[1] = v4;
  v12[0] = v4;
  int v10 = 0;
  uint64_t v11 = 0;
  BOOL v9 = 0;
  unint64_t v13 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v14 = v12;
  if (OTL::GCommon::GetLookups(a1, a2, (uint64_t)&v9, 0))
  {
    uint64_t v5 = v9;
    BOOL v6 = v10;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(void *)a3 = 0;
    *(void *)(a3 + 144) = a3 + 24;
    std::vector<std::pair<unsigned short,unsigned short>,TInlineBufferAllocator<std::pair<unsigned short,unsigned short>,30ul>>::__init_with_size[abi:nn180100]<std::__wrap_iter<std::pair<unsigned short,unsigned short> const*>,std::__wrap_iter<std::pair<unsigned short,unsigned short> const*>>((char *)a3, v5, v6, v6 - v5);
    char v7 = 1;
  }
  else
  {
    char v7 = 0;
    *(unsigned char *)a3 = 0;
  }
  *(unsigned char *)(a3 + 152) = v7;
  int v8 = (void **)&v9;
  std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100](&v8);
}

uint64_t OTL::GPOS::GetSinglePosAdjustments(OTL::GPOS *a1, unsigned __int16 **a2, uint64_t a3, double *a4, double *a5)
{
  int v10 = *(os_unfair_lock_s **)(*((void *)a1 + 2) + 400);
  os_unfair_lock_lock_with_options();
  double v12 = *a2;
  uint64_t v11 = a2[1];
  while (1)
  {
    if (v12 == v11)
    {
      uint64_t v14 = 0;
      goto LABEL_8;
    }
    unint64_t v13 = TBaseFont::NthLookup<OTL::GPOS>((uint64_t)v10, a1, *v12);
    if (v13)
    {
      if (OTL::GPOS::GetSinglePosAdjustmentsForLookup(a1, (const OTL::Lookup *)v13, a3, a4, a5)) {
        break;
      }
    }
    v12 += 2;
  }
  uint64_t v14 = 1;
LABEL_8:
  os_unfair_lock_unlock(v10 + 89);
  return v14;
}

uint64_t GetUnscaledAdvances(uint64_t a1, uint64_t a2, uint64_t a3, int a4, unint64_t a5, int a6)
{
  unint64_t v6 = a5;
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if (a6 == 2 || !a6 && (*(unsigned char *)a1 & 1) != 0)
  {
    *(void *)&long long v12 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v24[6] = v12;
    v24[5] = v12;
    v24[4] = v12;
    void v24[3] = v12;
    id v24[2] = v12;
    v24[1] = v12;
    v24[0] = v12;
    int64_t v22 = 0;
    id v23 = 0;
    int v21 = 0;
    unint64_t v25 = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v26 = v24;
    if (a5)
    {
      if (a5 >> 62) {
        abort();
      }
      unint64_t v13 = (char *)TInlineBufferAllocator<unsigned int,30ul>::allocate((uint64_t)v24, a5);
      uint64_t v14 = &v13[4 * v6];
      int v21 = (int *)v13;
      id v23 = v14;
      bzero(v13, 4 * v6);
      int64_t v22 = v14;
    }
    id v20 = (id)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(id *__return_ptr))(**(void **)(a1 + 400) + 496))(&v20);
    atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire);
    uint64_t GlyphVerticalAdvances = CGFontGetGlyphVerticalAdvances();
    uint64_t v16 = GlyphVerticalAdvances;
    if (v6 && GlyphVerticalAdvances)
    {
      BOOL v17 = v21;
      BOOL v18 = (double *)(a3 + 8);
      do
      {
        int v19 = *v17++;
        *(v18 - 1) = (double)v19;
        if (a4 >= 2) {
          bzero(v18, 8 * (a4 - (unint64_t)(((a4 - 1) & 0x1FFFFFFFFFFFFFFFLL) != 0)));
        }
        v18 += a4;
        --v6;
      }
      while (v6);
    }

    id v20 = &v21;
    std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v20);
    return v16;
  }
  else
  {
    int v10 = *(uint64_t (**)(void))(**(void **)(a1 + 400) + 512);
    return v10();
  }
}

double ApplyFixedAdvances(const __CFDictionary *a1, int a2, uint64_t a3, double *a4, int a5)
{
  double valuePtr = NAN;
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a1, @"NSCTFontFixedAdvanceAttribute");
  CFNumberGetValue(Value, kCFNumberDoubleType, &valuePtr);
  if (a2) {
    double valuePtr = round(valuePtr);
  }
  if (a3 < 1) {
    return 0.0;
  }
  double v10 = valuePtr;
  double result = 0.0;
  do
  {
    if (*a4 != 0.0)
    {
      *a4 = v10;
      double result = v10 + result;
    }
    a4 += a5;
    --a3;
  }
  while (a3);
  return result;
}

uint64_t TFont::GetUnscaledVerticalTranslationsForGlyphs(TFont *this, const unsigned __int16 *a2, CGSize *a3, uint64_t a4)
{
  id v11 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr))(**((void **)this + 50) + 496))(&v11);
  atomic_load_explicit((atomic_ullong *volatile)&v11, memory_order_acquire);
  uint64_t GlyphVerticalOffsets = CGFontGetGlyphVerticalOffsets();
  if (GlyphVerticalOffsets)
  {
    TFont::GetScaleFactor((double *)this);
    uint64_t v10 = v8;
    vDSP_vsmulD(&a3->width, 1, (const double *)&v10, &a3->width, 1, 2 * a4);
  }

  return GlyphVerticalOffsets;
}

void TFont::GetBoundingBoxesForGlyphs(TBaseFont **this, CGAffineTransform *a2, char a3, const unsigned __int16 *a4, CGRect *a5, uint64_t a6, unsigned __int32 a7)
{
  uint64_t v82 = *MEMORY[0x1E4F143B8];
  id v57 = a5;
  CGSize v58 = a4;
  if (a2)
  {
    int64x2_t v13 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(*(float64x2_t *)&a2->a, (float64x2_t)xmmword_184B895C0), (int8x16_t)vceqq_f64(*(float64x2_t *)&a2->c, (float64x2_t)xmmword_184B87DE0)), (int8x16_t)vceqzq_f64(*(float64x2_t *)&a2->tx));
    if (vandq_s8((int8x16_t)v13, (int8x16_t)vdupq_laneq_s64(v13, 1)).i64[0] >= 0) {
      uint64_t v14 = a2;
    }
    else {
      uint64_t v14 = 0;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  if (a7 == 2)
  {
    int v15 = 1;
  }
  else if (a7)
  {
    int v15 = 0;
  }
  else
  {
    int v15 = *(unsigned char *)this & 1;
  }
  if (TBaseFont::GetInitializedGraphicsFont(this[50]))
  {
    uint64_t ParserFont = CGFontGetParserFont();
    if (ParserFont)
    {
      long long v16 = *(_OWORD *)(MEMORY[0x1E4F1DB28] + 16);
      long long v59 = *MEMORY[0x1E4F1DB28];
      long long v60 = v16;
      *(void *)&long long v17 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v17 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long v80 = v17;
      long long v79 = v17;
      long long v78 = v17;
      long long v77 = v17;
      long long v76 = v17;
      long long v75 = v17;
      long long v74 = v17;
      long long v73 = v17;
      long long v72 = v17;
      long long v71 = v17;
      long long v70 = v17;
      long long v69 = v17;
      long long v68 = v17;
      *(_OWORD *)&v67[40] = v17;
      *(_OWORD *)&v67[24] = v17;
      memset(v67, 0, 24);
      long long v81 = &v67[24];
      int BoundingBoxesForSVGGlyphs = TFont::GetBoundingBoxesForSVGGlyphs((TFont *)this, v14, (uint64_t)a4, (uint64_t)a5, a6, a7, (double *)v67, (CGFloat *)&v59);
      *(void *)&long long v19 = -1;
      *((void *)&v19 + 1) = -1;
      *(_OWORD *)&v55.c = v19;
      *(_OWORD *)&v55.tCGFloat x = v19;
      *(_OWORD *)&v55.double a = v19;
      if (a3)
      {
        TFont::GetScaledMatrix((TFont *)this, &v55);
        if (!v14)
        {
LABEL_18:
          if (v15)
          {
            CGAffineTransform t1 = *(CGAffineTransform *)kRotateLeftTransform;
            CGAffineTransform t2 = v55;
            CGAffineTransformConcat(&v54, &t1, &t2);
            CGAffineTransform v55 = v54;
          }
          t1.double a = TFont::GetColorBitmapFontTranslate((TFont *)this);
          t1.double b = v22;
          if (a3)
          {
            CGFloat v26 = MEMORY[0x1E4F622E0];
            if (v15) {
              CGFloat v26 = MEMORY[0x1E4F622E8];
            }
            t2.double a = v26;
            uint64_t v27 = operator new(0x40uLL);
            *uint64_t v27 = &unk_1ED061D78;
            v27[1] = &v57;
            v27[2] = &t2;
            v27[3] = &ParserFont;
            v27[4] = &v58;
            v27[5] = &v55;
            v27[6] = &t1;
            v27[7] = &v59;
            long long v66 = v27;
            ForEachIndex(a6, BoundingBoxesForSVGGlyphs ^ 1, *(uint64_t **)v67, *(uint64_t **)&v67[8], (uint64_t)v65);
            unint64_t v25 = v65;
          }
          else
          {
            CGFloat v23 = MEMORY[0x1E4F622D0];
            if (v15) {
              CGFloat v23 = MEMORY[0x1E4F622D8];
            }
            t2.double a = v23;
            long long v24 = operator new(0x40uLL);
            void *v24 = &unk_1ED061DC0;
            v24[1] = &v57;
            id v24[2] = &t2;
            void v24[3] = &ParserFont;
            v24[4] = &v55;
            v24[5] = &v58;
            v24[6] = &t1;
            _OWORD v24[7] = &v59;
            long long v64 = v24;
            ForEachIndex(a6, BoundingBoxesForSVGGlyphs ^ 1, *(uint64_t **)v67, *(uint64_t **)&v67[8], (uint64_t)v63);
            unint64_t v25 = v63;
          }
          std::__function::__value_func<void ()(long)>::~__value_func[abi:nn180100](v25);
          *(void *)&t1.double a = v67;
          std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&t1);
          return;
        }
      }
      else
      {
        TFont::GetEffectiveMatrix((TFont *)this, (uint64_t)&t2);
        double EffectiveSize = TFont::GetEffectiveSize((TFont *)this);
        CGAffineTransform t1 = t2;
        CGAffineTransformScale(&v55, &t1, EffectiveSize, EffectiveSize);
        if (!v14) {
          goto LABEL_18;
        }
      }
      CGAffineTransform t1 = v55;
      long long v21 = *(_OWORD *)&v14->c;
      *(_OWORD *)&t2.double a = *(_OWORD *)&v14->a;
      *(_OWORD *)&t2.c = v21;
      *(_OWORD *)&t2.tCGFloat x = *MEMORY[0x1E4F1DAD8];
      CGAffineTransformConcat(&v54, &t1, &t2);
      CGAffineTransform v55 = v54;
      goto LABEL_18;
    }
  }
  else
  {
    uint64_t ParserFont = 0;
  }
  if (v15)
  {
    double BoundingBoxesForGlyphs = TFont::GetBoundingBoxesForGlyphs((TFont *)this, a4, a5, a6, (CTFontOrientation)a7);
    *(double *)&long long v59 = BoundingBoxesForGlyphs;
    *((void *)&v59 + 1) = v29;
    *(void *)&long long v60 = v30;
    *((void *)&v60 + 1) = v31;
    if (v14)
    {
      long long v32 = *(_OWORD *)&v14->c;
      *(_OWORD *)long long v67 = *(_OWORD *)&v14->a;
      *(_OWORD *)&v67[16] = v32;
      *(_OWORD *)&v67[32] = *(_OWORD *)&v14->tx;
      CGRect v83 = CGRectApplyAffineTransform(*(CGRect *)&BoundingBoxesForGlyphs, (CGAffineTransform *)v67);
      *(CGFloat *)&long long v59 = v83.origin.x;
      *((void *)&v59 + 1) = *(void *)&v83.origin.y;
      *(CGFloat *)&long long v60 = v83.size.width;
      *((void *)&v60 + 1) = *(void *)&v83.size.height;
      if (a6)
      {
        p_size = &a5->size;
        do
        {
          CGRect v84 = *(CGRect *)&p_size[-1].width;
          long long v34 = *(_OWORD *)&v14->c;
          *(_OWORD *)long long v67 = *(_OWORD *)&v14->a;
          *(_OWORD *)&v67[16] = v34;
          *(_OWORD *)&v67[32] = *(_OWORD *)&v14->tx;
          *(CGRect *)&p_size[-1].CGFloat width = CGRectApplyAffineTransform(v84, (CGAffineTransform *)v67);
          p_size += 2;
          --a6;
        }
        while (a6);
      }
    }
  }
  else
  {
    *(void *)&long long v35 = -1;
    *((void *)&v35 + 1) = -1;
    *(_OWORD *)&t2.c = v35;
    *(_OWORD *)&t2.tCGFloat x = v35;
    *(_OWORD *)&t2.double a = v35;
    TFont::GetEffectiveMatrix((TFont *)this, (uint64_t)&t1);
    double v36 = TFont::GetEffectiveSize((TFont *)this);
    *(CGAffineTransform *)long long v67 = t1;
    CGAffineTransformScale(&t2, (CGAffineTransform *)v67, v36, v36);
    if (v14)
    {
      *(CGAffineTransform *)long long v67 = t2;
      long long v37 = *(_OWORD *)&v14->c;
      *(_OWORD *)&t1.double a = *(_OWORD *)&v14->a;
      *(_OWORD *)&t1.c = v37;
      *(_OWORD *)&t1.tCGFloat x = *MEMORY[0x1E4F1DAD8];
      CGAffineTransformConcat(&v55, (CGAffineTransform *)v67, &t1);
      CGAffineTransform t2 = v55;
    }
    *(void *)long long v67 = 0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(unsigned char *__return_ptr))(*(void *)this[50] + 496))(v67);
    atomic_load_explicit((atomic_ullong *volatile)v67, memory_order_acquire);
    unint64_t v38 = v57;
    if (CGFontGetGlyphBBoxesForStyle())
    {
      long long v39 = *(_OWORD *)(MEMORY[0x1E4F1DB28] + 16);
      long long v59 = *MEMORY[0x1E4F1DB28];
      long long v60 = v39;
      double ColorBitmapFontTranslate = TFont::GetColorBitmapFontTranslate((TFont *)this);
      CGFloat v52 = v41;
      CGFloat v53 = ColorBitmapFontTranslate;
      if (a6 >= 1)
      {
        CGFloat v42 = *((double *)&v59 + 1);
        CGFloat v43 = *(double *)&v59;
        CFDictionaryRef v44 = &v38->size;
        CGFloat v46 = *((double *)&v60 + 1);
        CGFloat v45 = *(double *)&v60;
        do
        {
          CGRect v85 = CGRectOffset(*(CGRect *)&v44[-1].width, v53, v52);
          CGFloat x = v85.origin.x;
          CGFloat y = v85.origin.y;
          CGFloat width = v85.size.width;
          CGFloat height = v85.size.height;
          *(CGRect *)&v44[-1].CGFloat width = v85;
          v85.origin.CGFloat x = v43;
          v85.origin.CGFloat y = v42;
          v85.size.CGFloat width = v45;
          v85.size.CGFloat height = v46;
          if (CGRectIsEmpty(v85))
          {
            CGFloat v43 = x;
            CGFloat v42 = y;
            CGFloat v45 = width;
            CGFloat v46 = height;
          }
          else
          {
            v86.origin.CGFloat x = x;
            v86.origin.CGFloat y = y;
            v86.size.CGFloat width = width;
            v86.size.CGFloat height = height;
            if (!CGRectIsEmpty(v86))
            {
              v87.origin.CGFloat x = v43;
              v87.origin.CGFloat y = v42;
              v87.size.CGFloat width = v45;
              v87.size.CGFloat height = v46;
              v89.origin.CGFloat x = x;
              v89.origin.CGFloat y = y;
              v89.size.CGFloat width = width;
              v89.size.CGFloat height = height;
              CGRect v88 = CGRectUnion(v87, v89);
              CGFloat v43 = v88.origin.x;
              CGFloat v42 = v88.origin.y;
              CGFloat v45 = v88.size.width;
              CGFloat v46 = v88.size.height;
            }
          }
          *(CGFloat *)&long long v59 = v43;
          *((CGFloat *)&v59 + 1) = v42;
          v44 += 2;
          *(CGFloat *)&long long v60 = v45;
          *((CGFloat *)&v60 + 1) = v46;
          --a6;
        }
        while (a6);
      }
    }
    else
    {
      long long v51 = *(_OWORD *)(MEMORY[0x1E4F1DB20] + 16);
      long long v59 = *MEMORY[0x1E4F1DB20];
      long long v60 = v51;
    }
  }
}

unint64_t TFont::GetPaletteColors(atomic_ullong *this)
{
  unint64_t explicit = atomic_load_explicit(this + 62, memory_order_acquire);
  if (explicit) {
    return explicit;
  }
  id Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  memset(v22, 170, sizeof(v22));
  (*(void (**)(id *__return_ptr))(*(void *)this[50] + 480))(valuePtr);
  ColorPaletteTable::ColorPaletteTable((atomic_ullong *)v22, (atomic_ullong *)valuePtr);

  if (v22[2])
  {
    TFont::CopyAttribute((TFont *)this, @"CTFontPaletteAttribute", 49, (atomic_ullong *)valuePtr);
    CFNumberRef v3 = (const __CFNumber *)atomic_exchange((atomic_ullong *volatile)valuePtr, 0);

    TFont::CopyAttribute((TFont *)this, @"CTFontPaletteColorsAttribute", 50, (atomic_ullong *)valuePtr);
    CFDictionaryRef v4 = (const __CFDictionary *)atomic_exchange((atomic_ullong *volatile)valuePtr, 0);

    CFNumberRef v19 = v3;
    if (v3)
    {
      valuePtr[0] = (id)0xAAAAAAAAAAAAAAAALL;
      CFNumberGetValue(v3, kCFNumberLongType, valuePtr);
      if (valuePtr[0] == (id)-2)
      {
        int v5 = 2;
        int v6 = 2;
      }
      else
      {
        if (valuePtr[0] != (id)-1)
        {
          unint64_t PaletteWithFlags = (unint64_t)valuePtr[0] & ~((uint64_t)valuePtr[0] >> 63);
          goto LABEL_11;
        }
        int v5 = 1;
        int v6 = 1;
      }
      unint64_t PaletteWithFlags = (unint64_t)ColorPaletteTable::IndexOfFirstPaletteWithFlags((const UInt8 **)v22, v5, v6);
    }
    else
    {
      unint64_t PaletteWithFlags = 0;
    }
LABEL_11:
    memset(valuePtr, 170, sizeof(valuePtr));
    ColorPaletteTable::Palette::Palette((atomic_ullong *)valuePtr, (CFDataRef)atomic_load_explicit((atomic_ullong *volatile)v22, memory_order_acquire), PaletteWithFlags);
    BOOL v9 = (char *)valuePtr[2];
    if (valuePtr[2])
    {
      for (CFIndex i = 0; v9 != i; ++i)
      {
        if (!v4) {
          goto LABEL_21;
        }
        id v25 = (id)0xAAAAAAAAAAAAAAAALL;
        TCFNumber::TCFNumber<int>(&v25, (unsigned __int16)i);
        CFNumberRef Value = (void *)CFDictionaryGetValue(v4, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v25, memory_order_acquire));
        if (!Value) {
          goto LABEL_20;
        }
        long long v12 = Value;
        CFTypeID v13 = CFGetTypeID(Value);
        if (v13 == CGColorGetTypeID())
        {
          id v24 = v12;
          id v20 = (id)atomic_exchange((atomic_ullong *volatile)&v24, 0);
        }
        else
        {
          id v20 = CopyCGColor(v12);
          if (!atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire))
          {

LABEL_20:
LABEL_21:
            ColorPaletteTable::Palette::ColorForPaletteEntry((atomic_ullong *)valuePtr, (unsigned __int16)i, (atomic_ullong **)&v20, v8);
            goto LABEL_22;
          }
        }

LABEL_22:
        CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), (const void *)atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire));
      }
    }
  }
  uint64_t v14 = 0;
  unint64_t v15 = atomic_exchange((atomic_ullong *volatile)&Mutable, 0);
  long long v16 = this + 62;
  atomic_compare_exchange_strong(v16, (unint64_t *)&v14, v15);
  if (v14) {
    long long v17 = (void *)v15;
  }
  else {
    long long v17 = 0;
  }

  unint64_t explicit = atomic_load_explicit(v16, memory_order_acquire);
  return explicit;
}

void std::vector<long,TInlineBufferAllocator<long,30ul>>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 8 * a2;
    }
  }
  else
  {
    std::vector<long,TInlineBufferAllocator<long,30ul>>::__append((char **)a1, a2 - v2);
  }
}

uint64_t TFont::GetVerticalTranslationsForGlyphs(TFont *this, const unsigned __int16 *a2, float64x2_t *a3, uint64_t a4)
{
  id v12 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr))(**((void **)this + 50) + 496))(&v12);
  atomic_load_explicit((atomic_ullong *volatile)&v12, memory_order_acquire);
  uint64_t GlyphVerticalOffsets = CGFontGetGlyphVerticalOffsets();
  if (GlyphVerticalOffsets)
  {
    TFont::GetScaledMatrix(this, &v11);
    if (a4)
    {
      float64x2_t v8 = *(float64x2_t *)&v11.a;
      float64x2_t v9 = *(float64x2_t *)&v11.c;
      do
      {
        *a3 = vmlaq_n_f64(vmulq_n_f64(v9, a3->f64[1]), v8, a3->f64[0]);
        ++a3;
        --a4;
      }
      while (a4);
    }
  }

  return GlyphVerticalOffsets;
}

void TFont::CopyNameForGlyph(TFont *this@<X0>, CGGlyph a2@<W1>, CFStringRef *a3@<X8>)
{
  id v5 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr))(**((void **)this + 50) + 496))(&v5);
  *a3 = CGFontCopyGlyphNameForGlyph((CGFontRef)atomic_load_explicit((atomic_ullong *volatile)&v5, memory_order_acquire), a2);
}

uint64_t TFont::GetGlyphWithName(TFont *this, const __CFString *a2)
{
  id v5 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr))(**((void **)this + 50) + 496))(&v5);
  uint64_t GlyphWithGlyphName = CGFontGetGlyphWithGlyphName((CGFontRef)atomic_load_explicit((atomic_ullong *volatile)&v5, memory_order_acquire), a2);

  return GlyphWithGlyphName;
}

CGFloat TFont::GetStrikethroughPositionAndThickness(TFont *this)
{
  unint64_t v2 = (TBaseFont *)*((void *)this + 50);
  *(void *)&long long v3 = -1;
  *((void *)&v3 + 1) = -1;
  *(_OWORD *)&v12.c = v3;
  *(_OWORD *)&v12.tCGFloat x = v3;
  *(_OWORD *)&v12.double a = v3;
  TFont::GetScaledMatrix(this, &v12);
  double v4 = (*(double (**)(TBaseFont *, CGAffineTransform *))(*(void *)v2 + 608))(v2, &v12) * 0.5;
  double v11 = v4;
  TFont::GetUnderlinePositionAndThickness(this);
  double v10 = v5;
  if (v4 <= 0.0)
  {
    if (!TBaseFont::GetInitializedGraphicsFont(v2) || !CGFontGetParserFont() || (FPFontGetStrikeout() & 1) == 0)
    {
      memset(v9, 170, sizeof(v9));
      (*(void (**)(id *__return_ptr, TBaseFont *, uint64_t))(*(void *)v2 + 480))(&v8, v2, 1330851634);
      OS2::OS2((atomic_ullong *)v9, (atomic_ullong *)&v8);

      if ((uint64_t)v9[2] < 78)
      {

        return v11;
      }
      int v6 = bswap32(*((unsigned __int16 *)v9[1] + 14));
      double v10 = (double)((int)bswap32(*((unsigned __int16 *)v9[1] + 13)) >> 16);
      double v11 = (double)(v6 >> 16);
    }
    return v12.ty + v12.d * v11 + v12.b * 0.0 + fabs(v12.ty + v10 * v12.d + v12.b * 0.0) * -0.5;
  }
  return v4;
}

unint64_t TFont::GetSecondaryScaleData(atomic_ullong *this)
{
  unint64_t explicit = atomic_load_explicit(this + 45, memory_order_acquire);
  if (explicit == -1) {
    unint64_t v2 = 0;
  }
  else {
    unint64_t v2 = explicit;
  }
  if (!explicit)
  {
    double v4 = (TBaseFont *)this[50];
    if (v4 && TFont::IsSystemUIFontAndForShaping(this, &v11))
    {
      id v10 = (id)0xAAAAAAAAAAAAAAAALL;
      TBaseFont::CopyMetadata(v4, 1, &v10);
      CFDictionaryRef v5 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire);
      if (v5)
      {
        CFDictionaryRef v6 = v5;
        CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v5, @"textscale.secondary");

        if (Value)
        {
          id v8 = CFDictionaryGetValue(Value, @"v2");
          if (v8)
          {
            unint64_t v2 = (unint64_t)v8;
            atomic_store((unint64_t)v8, (unint64_t *)this + 45);

            return v2;
          }
        }
      }
      else
      {
      }
    }
    unint64_t v2 = 0;
    atomic_store(0xFFFFFFFFFFFFFFFFLL, (unint64_t *)this + 45);
  }
  return v2;
}

void TsbixContext::TsbixContext(TsbixContext *this, id a2)
{
  *(void *)this = a2;
  CFDataRef v3 = (const __CFData *)(id)atomic_load_explicit((atomic_ullong *volatile)this, memory_order_acquire);
  CFDataRef v4 = v3;
  if (v3) {
    BytePtr = CFDataGetBytePtr(v3);
  }
  else {
    BytePtr = 0;
  }

  *((void *)this + 1) = BytePtr;
  id v6 = (id)atomic_load_explicit((atomic_ullong *volatile)this, memory_order_acquire);
  CFDataRef v7 = (const __CFData *)v6;
  if (v7)
  {
    CFDataRef v8 = v7;
    float64x2_t v9 = CFDataGetBytePtr(v7);

    if (v9) {
      v9 += CFDataGetLength((CFDataRef)v6);
    }
  }
  else
  {

    float64x2_t v9 = 0;
  }

  *((void *)this + 2) = v9;
  unint64_t v10 = *((void *)this + 1);
  if (!v10
    || !*(_WORD *)v10
    || (unsigned int v11 = *(_DWORD *)(v10 + 4)) == 0
    || ((unint64_t v12 = v10 + 4 * bswap32(v11), v10 <= v12 + 4) ? (v13 = v12 + 8 > (unint64_t)v9) : (v13 = 1), v13))
  {
    *((void *)this + 1) = 0;
  }
}

void TFont::CopyVariantsOfGlyph(TFont *this@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  v28[4] = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  id Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  v28[0] = &unk_1ED061CA0;
  v28[1] = &Mutable;
  v28[3] = v28;
  TOpenTypeMorph::AddVariantsOfGlyph((uint64_t)this, a2, (uint64_t)v28);
  std::__function::__value_func<void ()(unsigned short,__CFDictionary const*)>::~__value_func[abi:nn180100](v28);
  id v25 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr))(**((void **)this + 50) + 480))(&v25);
  if (atomic_load_explicit((atomic_ullong *volatile)&v25, memory_order_acquire))
  {
    long long v17 = a3;
    *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v23 = v7;
    long long v24 = v7;
    long long v21 = v7;
    long long v22 = v7;
    *(_OWORD *)CFNumberRef v19 = v7;
    long long v20 = v7;
    unint64_t explicit = (void *)atomic_load_explicit((atomic_ullong *volatile)&v25, memory_order_acquire);
    GlyphCFIndex Count = TBaseFont::GetGlyphCount(*((TBaseFont **)this + 50));
    ZapfTable::ZapfTable((ZapfTable *)v19, explicit, GlyphCount);
    id v18 = (id)0xAAAAAAAAAAAAAAAALL;
    ZapfTable::VariantsForGlyph((ZapfTable *)v19, a2, (unint64_t *)&v18);
    CFArrayRef v10 = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v18, memory_order_acquire);
    if (v10)
    {
      CFIndex Count = CFArrayGetCount(v10);
      if (Count)
      {
        CFIndex v12 = Count;
        CFIndex v13 = 0;
        uint64_t v14 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
        do
        {
          CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(v10, v13);
          unsigned __int16 valuePtr = -21846;
          CFNumberGetValue(ValueAtIndex, kCFNumberShortType, &valuePtr);
          if (valuePtr != a2
            && !CFDictionaryContainsKey((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), ValueAtIndex))
          {
            CFArrayRef v16 = CFArrayCreate(v6, 0, 0, v14);
            CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), ValueAtIndex, v16);
          }
          ++v13;
        }
        while (v12 != v13);
      }
    }

    a3 = v17;
  }
  *a3 = atomic_exchange((atomic_ullong *volatile)&Mutable, 0);
}

__CFString *TFont::DebugDescription(TFont *this)
{
  CFAllocatorRef v6 = &stru_1ED0677F8;
  uint64_t v2 = *((void *)this + 50);
  if (v2)
  {
    id v5 = (id)atomic_load_explicit((atomic_ullong *volatile)(v2 + 96), memory_order_acquire);
  }
  id Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringAppendFormat(Mutable, 0, @"name = %@, size = %f, matriCGFloat x = %p, descriptor = %@", atomic_load_explicit((atomic_ullong *volatile)&v6, memory_order_acquire), *((void *)this + 2), *((void *)this + 5), atomic_load_explicit((atomic_ullong *volatile)this + 1, memory_order_acquire));

  return Mutable;
}

unint64_t TFontCascade::InitLastResort(TFontCascade *this)
{
  id v5 = (id)0xAAAAAAAAAAAAAAAALL;
  TDescriptorSource::TDescriptorSource((TDescriptorSource *)&v4);
  TDescriptorSource::CopyLastResort(&v5);
  TFontCascade::CreateFallbackFromDescriptor(this, (const __CTFontDescriptor *)atomic_load_explicit((atomic_ullong *volatile)&v5, memory_order_acquire), 8, &v4);
  this = (TFontCascade *)((char *)this + 32);

  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)this, memory_order_acquire);
  return explicit;
}

void TFontCascade::CreateFallbackFromDescriptor(TFontCascade *this@<X0>, const __CTFontDescriptor *a2@<X1>, int a3@<W2>, void *a4@<X8>)
{
  CFArrayRef v10 = a2;
  unint64_t explicit = (const __CTFontDescriptor *)atomic_load_explicit((atomic_ullong *volatile)(*(void *)(atomic_load_explicit((atomic_ullong *volatile)this, memory_order_acquire)+ 40)+ 160), memory_order_acquire);
  if (explicit) {
    a3 = 0;
  }
  int v9 = *((_DWORD *)this + 44) | a3;
  if (explicit) {
    unint64_t explicit = (const __CTFontDescriptor *)atomic_load_explicit((atomic_ullong *volatile)this + 1, memory_order_acquire);
  }
  long long v7 = explicit;
  TCFBase_NEW<CTFont,__CTFontDescriptor const*&,double const&,CGAffineTransform * const&,unsigned int &,__CTFontDescriptor const*>(&v10, (double *)this + 21, (CGAffineTransform **)this + 23, &v9, &v7, &v8);
  *a4 = atomic_exchange((atomic_ullong *volatile)&v8, 0);
}

unint64_t TFontCascade::InitEmojiFont(TFontCascade *this)
{
  uint64_t v2 = 88;
  if (*((uint64_t *)this + 10) > 0) {
    uint64_t v2 = 72;
  }
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)((char *)this + v2), memory_order_acquire);
  id v12 = 0;
  if (*((uint64_t *)this + 10) >= 1 && *((uint64_t *)this + 12) >= 1)
  {

    id v4 = (__CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v12, memory_order_acquire);
    CFArrayRef v5 = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)this + 11, memory_order_acquire);
    v13.CFIndex length = *((void *)this + 12);
    v13.locatiouint64_t n = 0;
    CFArrayAppendArray(v4, v5, v13);
    unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&v12, memory_order_acquire);
  }
  id v11 = (id)0xAAAAAAAAAAAAAAAALL;
  TDescriptorSource::TDescriptorSource((TDescriptorSource *)&v10);
  if (*((uint64_t *)this + 12) <= 0) {
    CFArrayRef v6 = 0;
  }
  else {
    CFArrayRef v6 = (const __CFArray *)explicit;
  }
  TDescriptorSource::CopyEmojiFontDescriptor((TDescriptorSource *)&v10, v6, (const __CTFontDescriptor *)atomic_load_explicit((atomic_ullong *volatile)this + 1, memory_order_acquire), &v11);
  TFontCascade::CreateFallbackFromDescriptor(this, (const __CTFontDescriptor *)atomic_load_explicit((atomic_ullong *volatile)&v11, memory_order_acquire), 8, &v10);
  long long v7 = (atomic_ullong *)((char *)this + 40);

  unint64_t v8 = atomic_load_explicit(v7, memory_order_acquire);
  return v8;
}

void *TFontCascade::GetFallbackFont(TFontCascade *this, const TBaseFont *a2, TDescriptor **explicit, int a4, double a5)
{
  keCGFloat y = a2;
  id v10 = NSMapGet(*((NSMapTable **)this + 24), a2);
  if (!v10)
  {
    id v21 = 0;
    if (*((_DWORD *)this + 45))
    {
      id v20 = (id)0xAAAAAAAAAAAAAAAALL;
      DerivedOpticalFontDescriptor((atomic_ullong *)&v20, explicit, *((double *)this + 21), a2);
      if (atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire))
      {

        unint64_t explicit = (TDescriptor **)atomic_load_explicit((atomic_ullong *volatile)&v21, memory_order_acquire);
        a4 |= 8u;
      }
      else
      {
        int v12 = *((_DWORD *)explicit[5] + 4);
        if ((TDescriptor::GetSystemUIFontOptions(v11) & v12) == 0)
        {
          LODWORD(CopyWithVariation) = 1024;
          TCFBase_NEW<CTFontDescriptor,TBaseFont const*&,$_24>(&v19, (uint64_t *)&key, (int *)&CopyWithVariation);

          unint64_t explicit = (TDescriptor **)atomic_load_explicit((atomic_ullong *volatile)&v21, memory_order_acquire);
        }
      }
    }
    id v20 = (id)0xAAAAAAAAAAAAAAAALL;
    TFontCascade::CreateFallbackFromDescriptor(this, (const __CTFontDescriptor *)explicit, a4, &v20);
    if (atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire))
    {
      if (*((_DWORD *)this + 45))
      {
        if (vabdd_f64(CTFontGetWeight(atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire)), a5) >= 0.001)
        {
          uint64_t v13 = *(void *)(*(void *)(atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire) + 40)
                          + 400);
          if (v13)
          {
            if ((*(unsigned int (**)(uint64_t))(*(void *)v13 + 104))(v13))
            {
              unint64_t v14 = CTFontCopyPhysicalFont(atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire));
              if (v14) {

              }
              id v19 = (id)0xAAAAAAAAAAAAAAAALL;
              id v19 = CTFontCopyFontDescriptor((CTFontRef)atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire));
              unsigned int v15 = ClassOfWeight(a5);
              CopyWithVariatiouint64_t n = (id)0xAAAAAAAAAAAAAAAALL;
              CopyWithVariatiouint64_t n = CTFontDescriptorCreateCopyWithVariation((CTFontDescriptorRef)atomic_load_explicit((atomic_ullong *volatile)&v19, memory_order_acquire), (CFNumberRef)&unk_1ED080868, (double)v15);
              if (atomic_load_explicit((atomic_ullong *volatile)&CopyWithVariation, memory_order_acquire)
                && operator!=((atomic_ullong *)&CopyWithVariation, (atomic_ullong *)&v19))
              {
                id v17 = CTFontCreateWithFontDescriptorAndOptions((CTFontDescriptorRef)atomic_load_explicit((atomic_ullong *volatile)&CopyWithVariation, memory_order_acquire), 0.0, 0, 0x400uLL);
              }
            }
          }
        }
      }
      NSMapInsert(*((NSMapTable **)this + 24), key, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire));
    }
    id v10 = (void *)atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire);
  }
  return v10;
}

void TCFBase_NEW<CTFontDescriptor,TBaseFont const*&,$_24>(void *a1, uint64_t *a2, int *a3)
{
  uint64_t v6 = TCFBase<TDescriptor>::Allocate();
  if (v6)
  {
    uint64_t v7 = *a2;
    int v8 = *a3;
    *(void *)(v6 + 16) = 0;
    *(void *)(v6 + 24) = TDescriptor::Hash;
    *(void *)(v6 + 32) = 0;
    *(void *)(v6 + 4CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = v6 + 48;
    *(void *)(v6 + 48) = &unk_1ED05D778;
    *(void *)(v6 + 56) = 0;
    *(_DWORD *)(v6 + 64) = v8 | 0x80000000;
    *(void *)(v6 + 72) = 0;
    if (v7) {
      atomic_fetch_add_explicit((atomic_uint *volatile)(v7 + 8), 1u, memory_order_relaxed);
    }
    *(void *)(v6 + 8CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = v7;
    *(void *)(v6 + 88) = 0;
    id v9 = (id)v6;
    *a1 = atomic_exchange((atomic_ullong *volatile)&v9, 0);
  }
  else
  {
    *a1 = 0;
  }
}

BOOL ShouldUseLastResort(UTF32Char a1)
{
  os_unfair_lock_lock_with_options();
  CFCharacterSetRef Mutable = (const __CFCharacterSet *)sLastResortSet;
  if (TGenerationSeed::sGeneration != sLastResortSetGeneration)
  {
    if (sLastResortSet) {
      CFRelease((CFTypeRef)sLastResortSet);
    }
    CFCharacterSetRef Mutable = CFCharacterSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
    sLastResortSet = (uint64_t)Mutable;
    sLastResortSetGeneratiouint64_t n = TGenerationSeed::sGeneration;
  }
  BOOL v3 = CFCharacterSetIsLongCharacterMember(Mutable, a1) != 0;
  os_unfair_lock_unlock((os_unfair_lock_t)&sLastResortSetLock);
  return v3;
}

void AddToUseLastResort(unsigned int a1)
{
  os_unfair_lock_lock_with_options();
  v3.locatiouint64_t n = a1;
  v3.CFIndex length = 1;
  CFCharacterSetAddCharactersInRange((CFMutableCharacterSetRef)sLastResortSet, v3);

  os_unfair_lock_unlock((os_unfair_lock_t)&sLastResortSetLock);
}

void TFontCascade::CreateFallback(CFStringRef theString@<X2>, uint64_t a2@<X0>, const __CTFont *a3@<X1>, int a4@<W3>, atomic_ullong *a5@<X8>)
{
  uint64_t v98 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *(void *)(a2 + 24);
  if (v8 <= 0)
  {
    if (!atomic_load_explicit((atomic_ullong *volatile)a2, memory_order_acquire))
    {
LABEL_159:
      *a5 = 0;
      return;
    }
    uint64_t v9 = *(void *)(atomic_load_explicit((atomic_ullong *volatile)a2, memory_order_acquire) + 40);
    TFont::CopyDescriptor((TFont *)v9, 1, (atomic_ullong *)valuePtr);

    *(void *)(a2 + 168) = *(void *)(v9 + 16);
    TFont::GetEffectiveMatrix((TFont *)v9, (uint64_t)valuePtr);
    uint64_t v10 = a2 + 120;
    long long v11 = *(_OWORD *)v94;
    *(_OWORD *)(a2 + 12CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = *(_OWORD *)valuePtr;
    *(_OWORD *)(a2 + 136) = v11;
    *(_OWORD *)(a2 + 152) = *(_OWORD *)&v94[16];
    int64x2_t v12 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(*(float64x2_t *)(a2 + 120), (float64x2_t)xmmword_184B895C0), (int8x16_t)vceqq_f64(*(float64x2_t *)(a2 + 136), (float64x2_t)xmmword_184B87DE0)), (int8x16_t)vceqzq_f64(*(float64x2_t *)(a2 + 152)));
    if (vandq_s8((int8x16_t)v12, (int8x16_t)vdupq_laneq_s64(v12, 1)).i64[0] < 0) {
      uint64_t v10 = 0;
    }
    *(void *)(a2 + 184) = v10;
    *(_DWORD *)(a2 + 176) = *(_DWORD *)v9;
    *(_DWORD *)(a2 + 18CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = TFont::IsSystemUIFontAndForShaping((atomic_ullong *)v9, (BOOL *)valuePtr);
    int v13 = *(_DWORD *)v9;
    (*(void (**)(id *__return_ptr))(**(void **)(v9 + 400) + 504))(valuePtr);

    CFArrayRef v14 = (const __CFArray *)(id)atomic_load_explicit((atomic_ullong *volatile)(a2 + 72), memory_order_acquire);
    CFArrayRef v15 = v14;
    if (v14) {
      CFIndex Count = CFArrayGetCount(v14);
    }
    else {
      CFIndex Count = 0;
    }
    *(void *)(a2 + 8CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = Count;

    if ((v13 & 0x1C0) != 0)
    {
      TFont::UserFallbacksForLanguage((atomic_ullong *)valuePtr, v9, (__CFString *)atomic_load_explicit((atomic_ullong *volatile)(a2 + 16), memory_order_acquire), (int *)(a2 + 48));

      CFArrayRef DefaultFallbacks = (void *)TFont::GetDefaultFallbacks((TFont *)v9);
      TCFRef<__CTFont const*>::Retain((atomic_ullong *)(a2 + 104), DefaultFallbacks);
    }
    CFArrayRef v18 = (const __CFArray *)(id)atomic_load_explicit((atomic_ullong *volatile)(a2 + 88), memory_order_acquire);
    CFArrayRef v19 = v18;
    if (v18) {
      CFArrayRef v18 = (const __CFArray *)CFArrayGetCount(v18);
    }
    *(void *)(a2 + 96) = v18;
    id v20 = (char *)v18 + Count;

    CFArrayRef v21 = (const __CFArray *)(id)atomic_load_explicit((atomic_ullong *volatile)(a2 + 104), memory_order_acquire);
    CFArrayRef v22 = v21;
    if (v21) {
      CFArrayRef v21 = (const __CFArray *)CFArrayGetCount(v21);
    }
    *(void *)(a2 + 112) = v21;
    long long v23 = (char *)v21 + (void)v20;

    *(void *)(a2 + 24) = v23;
    *(void *)(a2 + 192) = [objc_alloc(MEMORY[0x1E4F28E10]) initWithKeyOptions:514 valueOptions:0 capacity:*(void *)(a2 + 24)];
    uint64_t v8 = *(void *)(a2 + 24);
  }
  uint64_t v87 = v8;
  int v24 = a4;
  if (!a4)
  {
    Table = GetTable();
    if (!Table || (int v24 = Table[28]) == 0) {
      int v24 = *(_DWORD *)(a2 + 48);
    }
  }
  int v77 = v24;
  CFIndex Length = CFStringGetLength(theString);
  uint64_t v27 = Length;
  if (Length < 1)
  {
LABEL_146:
    long long v73 = (unsigned int *)*((void *)a3 + 5);
    if (v73 && v27 >= 1 && *((void *)v73 + 50))
    {
      *(void *)&long long v74 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v74 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long v96 = v74;
      long long v95 = v74;
      *(_OWORD *)&v94[24] = v74;
      *(_OWORD *)&v94[8] = v74;
      valuePtr[1] = 0;
      *(void *)long long v94 = 0;
      valuePtr[0] = 0;
      long long v97 = &v94[8];
      CharactersPtr = CFStringGetCharactersPtr(theString);
      if (!CharactersPtr)
      {
        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::resize((uint64_t)valuePtr, v27);
        v99.locatiouint64_t n = 0;
        v99.CFIndex length = v27;
        CFStringGetCharacters(theString, v99, (UniChar *)valuePtr[0]);
        CharactersPtr = (const UniChar *)valuePtr[0];
      }
      id v92 = (id)0xAAAAAAAAAAAAAAAALL;
      TDescriptorSource::TDescriptorSource((TDescriptorSource *)&v91);
      TDescriptorSource::CopySystemWideFallbackDescriptorForCharacters(&v91, *((void *)v73 + 50), (uint64_t)CharactersPtr, v27, *(_DWORD *)(a2 + 180), ((unint64_t)*v73 >> 6) & 7, (atomic_ullong *)&v92);
      if (atomic_load_explicit((atomic_ullong *volatile)&v92, memory_order_acquire))
      {
        *a5 = 0xAAAAAAAAAAAAAAAALL;
        TFontCascade::CreateFallbackFromDescriptor((TFontCascade *)a2, (const __CTFontDescriptor *)atomic_load_explicit((atomic_ullong *volatile)&v92, memory_order_acquire), 8, a5);
        if (atomic_load_explicit(a5, memory_order_acquire))
        {
          TCFRef<__CTFont const*>::Retain((atomic_ullong *)(a2 + 64), (id)atomic_load_explicit(a5, memory_order_acquire));

          id v92 = valuePtr;
          std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v92);
          return;
        }
      }
      id v92 = valuePtr;
      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v92);
    }
    goto LABEL_159;
  }
  CFIndex v28 = 0;
  CFIndex v78 = Length;
  CFStringRef v79 = theString;
  int v80 = a4;
  while (1)
  {
    LODWORD(v92) = 0;
    CharacterAtIndeCGFloat x = CFStringGetCharacterAtIndex(theString, v28);
    LOWORD(v92) = CharacterAtIndex;
    if ((CharacterAtIndex & 0xFC00) == 0xD800 && v28 + 1 < v27)
    {
      int v30 = CFStringGetCharacterAtIndex(theString, v28 + 1);
      WORD1(v92) = v30;
      int v31 = v30 + ((unsigned __int16)v92 << 10) - 56613888;
      if (((unsigned __int16)v92 & 0xFC00) != 0xD800) {
        int v31 = (unsigned __int16)v92;
      }
      uint64_t v32 = 1;
      if ((v30 & 0xFC00) == 0xDC00) {
        uint64_t v32 = 2;
      }
      uint64_t v89 = v32;
      if ((v30 & 0xFC00) == 0xDC00) {
        ++v28;
      }
      CFIndex v82 = v28;
      CharacterAtIndeCGFloat x = (v30 & 0xFC00) == 0xDC00 ? v31 : (unsigned __int16)v92;
    }
    else
    {
      CFIndex v82 = v28;
      uint64_t v89 = 1;
    }
    uint64_t v33 = v87;
    if (!ShouldUseLastResort(CharacterAtIndex)) {
      break;
    }
LABEL_34:
    CFIndex v28 = v82 + 1;
    uint64_t v27 = v78;
    theString = v79;
    if (v82 + 1 >= v78) {
      goto LABEL_146;
    }
  }
  int v34 = v77;
  if (!a4)
  {
    int v34 = v77;
    if (!*(void *)(a2 + 96))
    {
      if (u_hasBinaryProperty(CharacterAtIndex, UCHAR_EMOJI_PRESENTATION)) {
        int v34 = 2;
      }
      else {
        int v34 = v77;
      }
    }
  }
  unint64_t explicit = 0;
  CFIndex v36 = 0;
  unsigned int v84 = CharacterAtIndex - 57345;
  BOOL v38 = CharacterAtIndex == 1051575 || CharacterAtIndex - 57345 < 0x537;
  BOOL v88 = v38;
  BOOL v42 = (HIWORD(CharacterAtIndex) > 0xEu && CharacterAtIndex - 1114110 < 0xFFFFFC02 || CharacterAtIndex >> 11 < 0x1F)
     && CharacterAtIndex >> 13 > 6;
  BOOL v90 = v42;
  int v86 = v34;
  do
  {
    if (v36 >= v33)
    {
      int v43 = 0;
LABEL_92:
      BOOL v50 = 0;
      BOOL v55 = 1;
      if (a4 || explicit)
      {
        FallbackFont = 0;
      }
      else
      {
        if (atomic_load_explicit((atomic_ullong *volatile)(a2 + 40), memory_order_acquire)) {
          unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(a2 + 40), memory_order_acquire);
        }
        else {
          unint64_t explicit = TFontCascade::InitEmojiFont((TFontCascade *)a2);
        }
        BOOL v50 = 0;
        if ((const __CTFont *)explicit == a3) {
          FallbackFont = 0;
        }
        else {
          FallbackFont = (void *)explicit;
        }
        BOOL v55 = 1;
      }
      goto LABEL_106;
    }
    int v43 = 0;
    while (1)
    {
      CFIndex v44 = v36;
      if (!v36 && v34 == 2 && !explicit)
      {
        if (atomic_load_explicit((atomic_ullong *volatile)(a2 + 40), memory_order_acquire))
        {
          unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(a2 + 40), memory_order_acquire);
          if (explicit) {
            goto LABEL_102;
          }
        }
        else
        {
          unint64_t explicit = TFontCascade::InitEmojiFont((TFontCascade *)a2);
          if (explicit)
          {
LABEL_102:
            CFIndex v36 = 0;
            BOOL v50 = 0;
            FallbackFont = (void *)explicit;
            goto LABEL_105;
          }
        }
        unint64_t explicit = -1;
      }
      ++v36;
      CFIndex v45 = *(void *)(a2 + 80);
      uint64_t v46 = *(void *)(a2 + 96);
      if (*(void *)(a2 + 112) + v46 + v45 <= v44) {
        goto LABEL_89;
      }
      if (v46 + v45 <= v44)
      {
        v43 |= 8u;
        CFArrayRef v47 = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)(a2 + 104), memory_order_acquire);
        CFIndex v48 = v44 - v46 - v45;
      }
      else if (v45 <= v44)
      {
        CFArrayRef v47 = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)(a2 + 88), memory_order_acquire);
        CFIndex v48 = v44 - v45;
      }
      else
      {
        v43 |= 8u;
        CFArrayRef v47 = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)(a2 + 72), memory_order_acquire);
        CFIndex v48 = v44;
      }
      CFNumberRef ValueAtIndex = (TDescriptor **)CFArrayGetValueAtIndex(v47, v48);
      BOOL v50 = ValueAtIndex;
      if (!ValueAtIndex) {
        goto LABEL_89;
      }
      if ((*(_DWORD *)&v90 & ((v43 & 8) >> 3)) == 1)
      {
        if (!v88) {
          goto LABEL_89;
        }
        if (v84 <= 0x536)
        {
          long long v51 = ValueAtIndex[5];
          if ((*((_DWORD *)v51 + 4) & 0x80000000) == 0) {
            TDescriptor::InitBaseFont(ValueAtIndex[5], 0x8000, 0.0);
          }
          unint64_t v52 = atomic_load_explicit((atomic_ullong *volatile)v51 + 4, memory_order_acquire);
          if (v52)
          {
            if (!(*(unsigned int (**)(unint64_t))(*(void *)v52 + 712))(v52)) {
              goto LABEL_89;
            }
          }
        }
      }
      if (v34 != 1) {
        goto LABEL_103;
      }
      CGFloat v53 = v50[5];
      if ((*((_DWORD *)v53 + 4) & 0x80000000) == 0) {
        TDescriptor::InitBaseFont(v50[5], 0x8000, 0.0);
      }
      unint64_t v54 = atomic_load_explicit((atomic_ullong *volatile)v53 + 4, memory_order_acquire);
      if (!v54) {
        break;
      }
      if (!(*(unsigned int (**)(unint64_t))(*(void *)v54 + 712))(v54))
      {
LABEL_103:
        FallbackFont = 0;
        goto LABEL_105;
      }
LABEL_89:
      if (v33 == v36)
      {
        CFIndex v36 = v33;
        goto LABEL_92;
      }
    }
    FallbackFont = 0;
    CFIndex v36 = v44 + 1;
LABEL_105:
    BOOL v55 = v50 == 0;
    if (!v50)
    {
LABEL_106:
      if (!FallbackFont)
      {
        if (v36 == v33) {
          FallbackFont = (void *)atomic_load_explicit((atomic_ullong *volatile)(a2 + 64), memory_order_acquire);
        }
        else {
          FallbackFont = 0;
        }
        ++v36;
      }
    }
    if (FallbackFont) {
      BOOL v55 = 0;
    }
    if (v55) {
      goto LABEL_34;
    }
    if (!FallbackFont)
    {
      CGSize v58 = v50[5];
      if ((*((_DWORD *)v58 + 4) & 0x80000000) == 0) {
        TDescriptor::InitBaseFont(v50[5], 0x8000, 0.0);
      }
      id v57 = (const TBaseFont *)atomic_load_explicit((atomic_ullong *volatile)v58 + 4, memory_order_acquire);
      if (v57) {
        goto LABEL_120;
      }
LABEL_143:
      LODWORD(v64) = 0;
      goto LABEL_144;
    }
    id v57 = *(const TBaseFont **)(FallbackFont[5] + 400);
    if (!v57) {
      goto LABEL_143;
    }
LABEL_120:
    if ((*(unsigned int (**)(const TBaseFont *))(*(void *)v57 + 16))(v57) != 1414743620)
    {
      if ((*(uint64_t (**)(const TBaseFont *, id *, uint64_t, void))(*(void *)v57 + 808))(v57, &v92, v89, 0) < 1)goto LABEL_143; {
      if (!FallbackFont)
      }
      {
        double Weight = CTFontGetWeight((uint64_t)a3);
        FallbackFont = TFontCascade::GetFallbackFont((TFontCascade *)a2, v57, v50, v43, Weight);
      }
      *a5 = (atomic_ullong)FallbackFont;
      return;
    }
    unsigned int v83 = v43;
    double AccessibilityBoldWeightOfWeight = CTFontGetWeight((uint64_t)a3);
    valuePtr[0] = (id)CTFontCopyAttribute(a3, @"CTFontLegibilityWeightAttribute");
    long long v60 = (void *)atomic_exchange((atomic_ullong *volatile)valuePtr, 0);

    if (v60)
    {
      CFNumberRef v61 = v60;
      LODWORD(valuePtr[0]) = -1431655766;
      CFNumberGetValue(v61, kCFNumberIntType, valuePtr);
      int v62 = (int)valuePtr[0];

      if (v62 == 1) {
        double AccessibilityBoldWeightOfWeight = CTFontGetAccessibilityBoldWeightOfWeight(AccessibilityBoldWeightOfWeight);
      }
    }
    valuePtr[0] = (id)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(id *__return_ptr, const TBaseFont *))(*(void *)v57 + 504))(valuePtr, v57);
    CFArrayRef v63 = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)valuePtr, memory_order_acquire);
    if (v63)
    {
      CFIndex v64 = CFArrayGetCount(v63);
      if (v64)
      {
        CFIndex v65 = 0;
        while (1)
        {
          long long v66 = (TDescriptor **)CFArrayGetValueAtIndex(v63, v65);
          long long v67 = v66;
          long long v68 = v66[5];
          if ((*((_DWORD *)v68 + 4) & 0x80000000) == 0) {
            TDescriptor::InitBaseFont(v66[5], 0, 0.0);
          }
          unint64_t v69 = atomic_load_explicit((atomic_ullong *volatile)v68 + 4, memory_order_acquire);
          if (v69)
          {
            if ((*(uint64_t (**)(unint64_t, id *, uint64_t, void))(*(void *)v69 + 808))(v69, &v92, v89, 0) >= 1)break; {
          }
            }
          if (v64 == ++v65)
          {
            LODWORD(v64) = 0;
            int v70 = 1;
            goto LABEL_141;
          }
        }
        if ((*(unsigned int (**)(const TBaseFont *))(*(void *)v57 + 840))(v57)) {
          long long v71 = v57;
        }
        else {
          long long v71 = (const TBaseFont *)v69;
        }
        id v72 = TFontCascade::GetFallbackFont((TFontCascade *)a2, v71, v67, v83, AccessibilityBoldWeightOfWeight);
        int v70 = 0;
        *a5 = (atomic_ullong)v72;
        LODWORD(v64) = 1;
LABEL_141:
        a4 = v80;
        goto LABEL_142;
      }
    }
    else
    {
      LODWORD(v64) = 0;
    }
    int v70 = 1;
LABEL_142:

    if (v70) {
      goto LABEL_143;
    }
LABEL_144:
    uint64_t v33 = v87;
    int v34 = v86;
  }
  while (!v64);
}

void TCFBase_NEW<CTFont,__CTFontDescriptor const*&,double const&,CGAffineTransform * const&,unsigned int &,__CTFontDescriptor const*>(const __CTFontDescriptor **a1@<X0>, double *a2@<X1>, CGAffineTransform **a3@<X2>, int *a4@<X3>, const __CTFontDescriptor **a5@<X4>, void *a6@<X8>)
{
  uint64_t v12 = TCFBase<TFont>::Allocate();
  if (v12)
  {
    int v13 = (void *)v12;
    CFArrayRef v14 = *a1;
    double v15 = *a2;
    CFArrayRef v16 = *a3;
    int v17 = *a4;
    CFArrayRef v18 = *a5;
    CFArrayRef v19 = (TFont *)(v12 + 48);
    void v13[2] = 0;
    double v13[3] = TFont::Hash;
    v13[4] = 0;
    v13[5] = v19;
    TFont::TFont(v19, v14, v15, v16, v17, v18);
    id v20 = v13;
    *a6 = atomic_exchange((atomic_ullong *volatile)&v20, 0);
  }
  else
  {
    *a6 = 0;
  }
}

uint64_t GetGlyphsForLongCharacters(const TFont *a1, const unsigned int *a2, unsigned __int16 *a3, int64_t a4)
{
  uint64_t v73 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  void v71[3] = v7;
  v71[2] = v7;
  v71[1] = v7;
  v71[0] = v7;
  long long v68 = 0;
  unint64_t v69 = 0;
  int v70 = 0;
  id v72 = v71;
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::reserve(&v68, a4);
  if (a4 < 1)
  {
LABEL_65:
    uint64_t v57 = (*(uint64_t (**)(void, char *, unsigned __int16 *, int64_t))(**((void **)a1 + 50) + 664))(*((void *)a1 + 50), v68, a3, a4);
  }
  else
  {
    uint64_t v8 = 0;
    char v9 = 0;
    do
    {
      while (1)
      {
        unsigned int v10 = a2[v8];
        if (!HIWORD(v10)) {
          break;
        }
        int v24 = (v10 >> 10) - 10304;
        id v25 = v69;
        unint64_t v26 = (unint64_t)v70;
        if (v69 >= v70)
        {
          CFIndex v28 = (void **)v68;
          uint64_t v29 = v69 - v68;
          if (v69 - v68 <= -3) {
            goto LABEL_78;
          }
          uint64_t v30 = v29 >> 1;
          if (v70 - v68 <= (unint64_t)((v29 >> 1) + 1)) {
            uint64_t v31 = v30 + 1;
          }
          else {
            uint64_t v31 = v70 - v68;
          }
          if ((unint64_t)(v70 - v68) >= 0x7FFFFFFFFFFFFFFELL) {
            uint64_t v32 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v32 = v31;
          }
          *((void *)&v66[0] + 1) = v71;
          if (v32)
          {
            uint64_t v33 = (char *)TInlineBufferAllocator<unsigned short,30ul>::allocate((uint64_t)v71, v32);
            CFIndex v28 = (void **)v68;
            id v25 = v69;
          }
          else
          {
            uint64_t v33 = 0;
          }
          int v34 = &v33[2 * v30];
          *(_WORD *)int v34 = v24;
          if (v25 == (char *)v28)
          {
            CFIndex v36 = &v33[2 * v30];
          }
          else
          {
            long long v35 = (void **)v25;
            CFIndex v36 = &v33[2 * v30];
            do
            {
              __int16 v37 = *((_WORD *)v35 - 1);
              long long v35 = (void **)((char *)v35 - 2);
              *((_WORD *)v36 - 1) = v37;
              v36 -= 2;
            }
            while (v35 != v28);
          }
          uint64_t v27 = v34 + 2;
          long long v68 = v36;
          unint64_t v69 = v34 + 2;
          BOOL v38 = v70;
          int v70 = &v33[2 * v32];
          CFIndex v65 = v25;
          *(void *)&v66[0] = v38;
          CFArrayRef v63 = (char **)v28;
          CFIndex v64 = v28;
          std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,30ul> &>::~__split_buffer((uint64_t)&v63);
          unint64_t v26 = (unint64_t)v70;
        }
        else
        {
          *(_WORD *)unint64_t v69 = v24;
          uint64_t v27 = v25 + 2;
        }
        unint64_t v69 = v27;
        __int16 v39 = v10 & 0x3FF | 0xDC00;
        if ((unint64_t)v27 >= v26)
        {
          long long v40 = (void **)v68;
          uint64_t v41 = v27 - v68;
          if (v27 - v68 <= -3) {
LABEL_78:
          }
            abort();
          uint64_t v42 = v41 >> 1;
          unint64_t v43 = v26 - (void)v68;
          if (v43 <= (v41 >> 1) + 1) {
            unint64_t v44 = v42 + 1;
          }
          else {
            unint64_t v44 = v43;
          }
          if (v43 >= 0x7FFFFFFFFFFFFFFELL) {
            uint64_t v45 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v45 = v44;
          }
          *((void *)&v66[0] + 1) = v71;
          if (v45)
          {
            uint64_t v46 = (char *)TInlineBufferAllocator<unsigned short,30ul>::allocate((uint64_t)v71, v45);
            long long v40 = (void **)v68;
            uint64_t v27 = v69;
          }
          else
          {
            uint64_t v46 = 0;
          }
          CFArrayRef v47 = &v46[2 * v42];
          *(_WORD *)CFArrayRef v47 = v39;
          if (v27 == (char *)v40)
          {
            char v49 = &v46[2 * v42];
          }
          else
          {
            CFIndex v48 = (void **)v27;
            char v49 = &v46[2 * v42];
            do
            {
              __int16 v50 = *((_WORD *)v48 - 1);
              CFIndex v48 = (void **)((char *)v48 - 2);
              *((_WORD *)v49 - 1) = v50;
              v49 -= 2;
            }
            while (v48 != v40);
          }
          uint64_t v12 = v47 + 2;
          long long v68 = v49;
          unint64_t v69 = v47 + 2;
          long long v51 = v70;
          int v70 = &v46[2 * v45];
          CFIndex v65 = v27;
          *(void *)&v66[0] = v51;
          CFArrayRef v63 = (char **)v40;
          CFIndex v64 = v40;
          std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,30ul> &>::~__split_buffer((uint64_t)&v63);
        }
        else
        {
          *(_WORD *)uint64_t v27 = v39;
          uint64_t v12 = v27 + 2;
        }
        unint64_t v69 = v12;
        ++v8;
        char v9 = 1;
        if (v8 == a4) {
          goto LABEL_63;
        }
      }
      long long v11 = v69;
      if (v69 >= v70)
      {
        int v13 = (void **)v68;
        uint64_t v14 = v69 - v68;
        if (v69 - v68 <= -3) {
          goto LABEL_78;
        }
        uint64_t v15 = v14 >> 1;
        if (v70 - v68 <= (unint64_t)((v14 >> 1) + 1)) {
          uint64_t v16 = v15 + 1;
        }
        else {
          uint64_t v16 = v70 - v68;
        }
        if ((unint64_t)(v70 - v68) >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v17 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v17 = v16;
        }
        *((void *)&v66[0] + 1) = v71;
        if (v17)
        {
          CFArrayRef v18 = (char *)TInlineBufferAllocator<unsigned short,30ul>::allocate((uint64_t)v71, v17);
          int v13 = (void **)v68;
          long long v11 = v69;
        }
        else
        {
          CFArrayRef v18 = 0;
        }
        CFArrayRef v19 = &v18[2 * v15];
        *(_WORD *)CFArrayRef v19 = v10;
        if (v11 == (char *)v13)
        {
          CFArrayRef v21 = &v18[2 * v15];
        }
        else
        {
          id v20 = (void **)v11;
          CFArrayRef v21 = &v18[2 * v15];
          do
          {
            __int16 v22 = *((_WORD *)v20 - 1);
            id v20 = (void **)((char *)v20 - 2);
            *((_WORD *)v21 - 1) = v22;
            v21 -= 2;
          }
          while (v20 != v13);
        }
        uint64_t v12 = v19 + 2;
        long long v68 = v21;
        unint64_t v69 = v19 + 2;
        long long v23 = v70;
        int v70 = &v18[2 * v17];
        CFIndex v65 = v11;
        *(void *)&v66[0] = v23;
        CFArrayRef v63 = (char **)v13;
        CFIndex v64 = v13;
        std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,30ul> &>::~__split_buffer((uint64_t)&v63);
      }
      else
      {
        *(_WORD *)unint64_t v69 = v10;
        uint64_t v12 = v11 + 2;
      }
      unint64_t v69 = v12;
      ++v8;
    }
    while (v8 != a4);
    if ((v9 & 1) == 0) {
      goto LABEL_65;
    }
LABEL_63:
    *(void *)&long long v52 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v52 + 1) = 0xAAAAAAAAAAAAAAAALL;
    void v66[3] = v52;
    v66[2] = v52;
    v66[1] = v52;
    v66[0] = v52;
    CFIndex v64 = 0;
    CFIndex v65 = 0;
    CFArrayRef v63 = 0;
    long long v67 = v66;
    uint64_t v53 = v12 - v68;
    uint64_t v54 = (v12 - v68) >> 1;
    if (v12 == v68)
    {
      unint64_t v56 = 0;
    }
    else
    {
      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__vallocate[abi:nn180100](&v63, (v12 - v68) >> 1);
      BOOL v55 = (char *)v64;
      bzero(v64, v53 & 0xFFFFFFFFFFFFFFFELL);
      CFIndex v64 = &v55[2 * v54];
      uint64_t v12 = v68;
      unint64_t v56 = (void **)v63;
    }
    (*(void (**)(void, char *, void **, uint64_t))(**((void **)a1 + 50) + 664))(*((void *)a1 + 50), v12, v56, v54);
    if (v53 < 1)
    {
      uint64_t v57 = 0;
    }
    else
    {
      uint64_t v58 = 0;
      uint64_t v57 = 0;
      long long v59 = (void **)v63;
      do
      {
        if (*((_WORD *)v59 + v58)) {
          ++v57;
        }
        *a3++ = *((_WORD *)v59 + v58);
        if (*((_WORD *)a2 + 1)) {
          ++v58;
        }
        ++v58;
        ++a2;
      }
      while (v58 < v54);
    }
    int v62 = &v63;
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v62);
  }
  CFArrayRef v63 = &v68;
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v63);
  return v57;
}

CTFontRef VerticalCopyOf@<X0>(CTFontRef font@<X0>, CTFontRef *a2@<X8>)
{
  if (qword_1EB2CE078 != -1) {
    dispatch_once_f(&qword_1EB2CE078, 0, (dispatch_function_t)VerticalCopyOf(__CTFont const*)::$_0::__invoke);
  }
  CTFontRef result = CTFontCreateCopyWithAttributes(font, 0.0, 0, (CTFontDescriptorRef)qword_1EB2CE070);
  *a2 = result;
  return result;
}

uint64_t CTFontLogSuboptimalRequest::$_0::__invoke(CTFontLogSuboptimalRequest::$_0 *this, void *a2)
{
  return CFLog();
}

uint64_t OTL::Coverage::SearchUnknown(OTL::Coverage *this)
{
  return 0;
}

CGFloat std::__variant_detail::__visitation::__base::__dispatcher<1ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<TFont::GetLigatureCaretPositionsForGlyph(unsigned short,double *,long)::$_1> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,std::monostate,double,unsigned short> &&>(TFont ***a1, double *a2)
{
  uint64_t v2 = *a1;
  double v3 = *a2;
  TFont::GetScaledMatrix(**a1, &v5);
  CGFloat result = v5.tx + v5.c * 0.0 + v5.a * v3;
  *(CGFloat *)v2[2] = result;
  return result;
}

void std::__variant_detail::__visitation::__base::__dispatcher<2ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<TFont::GetLigatureCaretPositionsForGlyph(unsigned short,double *,long)::$_1> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,std::monostate,double,unsigned short> &&>(TBaseFont ****a1, __int16 *a2)
{
  if ((*a2 & 0x80000000) == 0)
  {
    uint64_t v2 = *a1;
    double v3 = **a1;
    __int16 v4 = *a2;
    TFont::GetControlPointPositions(v3, *((_WORD *)v2 + 4), &v4, (double *)v2[2], 1uLL);
  }
}

void std::vector<long,TInlineBufferAllocator<long,30ul>>::__append(char **a1, unint64_t a2)
{
  CGAffineTransform v5 = a1[1];
  __int16 v4 = a1[2];
  if (a2 <= (v4 - v5) >> 3)
  {
    if (a2)
    {
      bzero(a1[1], 8 * a2);
      v5 += 8 * a2;
    }
    a1[1] = v5;
  }
  else
  {
    uint64_t v6 = (uint64_t)(a1 + 3);
    long long v7 = *a1;
    uint64_t v8 = v5 - *a1;
    unint64_t v9 = a2 + (v8 >> 3);
    if (v9 >> 61) {
      abort();
    }
    uint64_t v10 = v8 >> 3;
    uint64_t v11 = v4 - v7;
    if (v11 >> 2 > v9) {
      unint64_t v9 = v11 >> 2;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v9;
    }
    void v20[4] = a1 + 3;
    if (v12)
    {
      int v13 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate(v6, v12);
      long long v7 = *a1;
      CGAffineTransform v5 = a1[1];
    }
    else
    {
      int v13 = 0;
    }
    uint64_t v14 = &v13[8 * v10];
    uint64_t v15 = &v13[8 * v12];
    bzero(v14, 8 * a2);
    uint64_t v16 = &v14[8 * a2];
    if (v5 != v7)
    {
      uint64_t v17 = v5;
      do
      {
        uint64_t v18 = *((void *)v17 - 1);
        v17 -= 8;
        *((void *)v14 - 1) = v18;
        v14 -= 8;
      }
      while (v17 != v7);
    }
    *a1 = v14;
    a1[1] = v16;
    CFArrayRef v19 = a1[2];
    a1[2] = v15;
    _OWORD v20[2] = v5;
    double v20[3] = v19;
    v20[0] = v7;
    v20[1] = v7;
    std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)v20);
  }
}

void anonymous namespace'::TSingleAttrDescriptor::~TSingleAttrDescriptor(id *this)
{
  *this = &unk_1ED05F890;
  uint64_t v2 = this + 2;
}

{
  id *v2;
  uint64_t vars8;

  *this = &unk_1ED05F890;
  uint64_t v2 = this + 2;

  JUMPOUT(0x1853275C0);
}

atomic_ullong *anonymous namespace'::TSingleAttrDescriptor::operator=(atomic_ullong *a1, atomic_ullong *a2)
{
  if (a1 != a2)
  {
    TCFRef<__CTFont const*>::Retain(a1 + 2, (id)atomic_load_explicit(a2 + 2, memory_order_acquire));
    TCFRef<__CTFont const*>::Retain(a1 + 3, (id)atomic_load_explicit(a2 + 3, memory_order_acquire));
    TCFRef<__CTFont const*>::Retain(a1 + 4, (id)atomic_load_explicit(a2 + 4, memory_order_acquire));
    TCFRef<__CTFont const*>::Retain(a1 + 5, (id)atomic_load_explicit(a2 + 5, memory_order_acquire));
  }
  return a1;
}

void VerticalCopyOf(__CTFont const*)::$_0::__invoke()
{
  LODWORD(valuePtr) = 2;
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFNumberRef v1 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
  CFNumberRef v3 = v1;
  unsigned __int16 valuePtr = @"NSCTFontOrientationAttribute";
  CFDictionaryRef v2 = CFDictionaryCreate(v0, (const void **)&valuePtr, (const void **)&v3, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  qword_1EB2CE070 = (uint64_t)CTFontDescriptorCreateWithAttributes(v2);
}

void std::__function::__func<TFont::InitShapingGlyphs(void)::$_0,std::allocator<TFont::InitShapingGlyphs(void)::$_0>,void ()(__CFDictionary *)>::~__func()
{
}

__n128 std::__function::__func<TFont::InitShapingGlyphs(void)::$_0,std::allocator<TFont::InitShapingGlyphs(void)::$_0>,void ()(__CFDictionary *)>::__clone(uint64_t a1)
{
  CFDictionaryRef v2 = (char *)operator new(0x30uLL);
  *(void *)CFDictionaryRef v2 = &unk_1ED061AF0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

__n128 std::__function::__func<TFont::InitShapingGlyphs(void)::$_0,std::allocator<TFont::InitShapingGlyphs(void)::$_0>,void ()(__CFDictionary *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ED061AF0;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 4CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<TFont::InitShapingGlyphs(void)::$_1,std::allocator<TFont::InitShapingGlyphs(void)::$_1>,void ()(unsigned short,unsigned short)>::~__func()
{
}

__n128 std::__function::__func<TFont::InitShapingGlyphs(void)::$_1,std::allocator<TFont::InitShapingGlyphs(void)::$_1>,void ()(unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  CFDictionaryRef v2 = (char *)operator new(0x18uLL);
  *(void *)CFDictionaryRef v2 = &unk_1ED061B38;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<TFont::InitShapingGlyphs(void)::$_2,std::allocator<TFont::InitShapingGlyphs(void)::$_2>,void ()(void)>::~__func()
{
}

void *std::__function::__func<TFont::InitShapingGlyphs(void)::$_2,std::allocator<TFont::InitShapingGlyphs(void)::$_2>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1ED061B80;
  result[1] = v3;
  return result;
}

void std::__function::__func<TFont::InitShapingGlyphs(void)::$_2,std::allocator<TFont::InitShapingGlyphs(void)::$_2>,void ()(void)>::operator()(uint64_t a1)
{
}

void std::__function::__func<TFont::InitShapingGlyphs(void)::$_3,std::allocator<TFont::InitShapingGlyphs(void)::$_3>,void ()(unsigned short,unsigned short)>::~__func()
{
}

void *std::__function::__func<TFont::InitShapingGlyphs(void)::$_3,std::allocator<TFont::InitShapingGlyphs(void)::$_3>,void ()(unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1ED061BC8;
  result[1] = v3;
  return result;
}

void std::__function::__func<TFont::InitShapingGlyphs(void)::$_4,std::allocator<TFont::InitShapingGlyphs(void)::$_4>,void ()(unsigned int)>::~__func()
{
}

void *std::__function::__func<TFont::InitShapingGlyphs(void)::$_4,std::allocator<TFont::InitShapingGlyphs(void)::$_4>,void ()(unsigned int)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1ED061C10;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<TFont::InitShapingGlyphs(void)::$_4,std::allocator<TFont::InitShapingGlyphs(void)::$_4>,void ()(unsigned int)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1ED061C10;
  a2[1] = v2;
  return result;
}

void std::__function::__func<TFont::InitShapingGlyphs(void)::$_5,std::allocator<TFont::InitShapingGlyphs(void)::$_5>,void ()(__CFDictionary *)>::~__func()
{
}

__n128 std::__function::__func<TFont::InitShapingGlyphs(void)::$_5,std::allocator<TFont::InitShapingGlyphs(void)::$_5>,void ()(__CFDictionary *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_1ED061C58;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 std::__function::__func<TFont::InitShapingGlyphs(void)::$_5,std::allocator<TFont::InitShapingGlyphs(void)::$_5>,void ()(__CFDictionary *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ED061C58;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<TFont::CoverageForFeatureSetting(CTFeatureSetting *)::$_0,std::allocator<TFont::CoverageForFeatureSetting(CTFeatureSetting *)::$_0>,void ()(unsigned short,unsigned short)>::~__func(uint64_t a1)
{
  *(void *)a1 = &unk_1ED061CE8;

  return a1;
}

void std::__function::__func<TFont::CoverageForFeatureSetting(CTFeatureSetting *)::$_0,std::allocator<TFont::CoverageForFeatureSetting(CTFeatureSetting *)::$_0>,void ()(unsigned short,unsigned short)>::~__func(uint64_t a1)
{
  *(void *)a1 = &unk_1ED061CE8;

  JUMPOUT(0x1853275C0);
}

void *std::__function::__func<TFont::CoverageForFeatureSetting(CTFeatureSetting *)::$_0,std::allocator<TFont::CoverageForFeatureSetting(CTFeatureSetting *)::$_0>,void ()(unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  uint64_t v2 = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t v2 = &unk_1ED061CE8;
  v2[1] = v3;
  v2[2] = (id)atomic_load_explicit((atomic_ullong *volatile)(a1 + 16), memory_order_acquire);
  return v2;
}

id std::__function::__func<TFont::CoverageForFeatureSetting(CTFeatureSetting *)::$_0,std::allocator<TFont::CoverageForFeatureSetting(CTFeatureSetting *)::$_0>,void ()(unsigned short,unsigned short)>::__clone(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  *a2 = &unk_1ED061CE8;
  a2[1] = v3;
  id result = (id)atomic_load_explicit((atomic_ullong *volatile)(a1 + 16), memory_order_acquire);
  a2[2] = result;
  return result;
}

void std::__function::__func<TFont::CoverageForFeatureSetting(CTFeatureSetting *)::$_0,std::allocator<TFont::CoverageForFeatureSetting(CTFeatureSetting *)::$_0>,void ()(unsigned short,unsigned short)>::destroy(uint64_t a1)
{
}

void std::__function::__func<TFont::CoverageForFeatureSetting(CTFeatureSetting *)::$_0,std::allocator<TFont::CoverageForFeatureSetting(CTFeatureSetting *)::$_0>,void ()(unsigned short,unsigned short)>::destroy_deallocate(id *a1)
{
  operator delete(a1);
}

void std::__function::__func<TFont::CoverageForFeatureSetting(CTFeatureSetting *)::$_0,std::allocator<TFont::CoverageForFeatureSetting(CTFeatureSetting *)::$_0>,void ()(unsigned short,unsigned short)>::operator()(uint64_t a1, CFRange a2)
{
  a2.locatiouint64_t n = *(unsigned __int16 *)a2.location;
  uint64_t v2 = *(unsigned __int16 *)a2.length;
  if (LODWORD(a2.location) <= v2 && *(void *)(a1 + 8) > v2)
  {
    a2.CFIndex length = v2 - a2.location + 1;
    CFBitVectorSetBits((CFMutableBitVectorRef)atomic_load_explicit((atomic_ullong *volatile)(a1 + 16), memory_order_acquire), a2, 1u);
  }
}

uint64_t std::__function::__func<TFont::CoverageForFeatureSetting(CTFeatureSetting *)::$_1,std::allocator<TFont::CoverageForFeatureSetting(CTFeatureSetting *)::$_1>,void ()(void)>::~__func(uint64_t a1)
{
  *(void *)a1 = &unk_1ED061D30;

  return a1;
}

void std::__function::__func<TFont::CoverageForFeatureSetting(CTFeatureSetting *)::$_1,std::allocator<TFont::CoverageForFeatureSetting(CTFeatureSetting *)::$_1>,void ()(void)>::~__func(uint64_t a1)
{
  *(void *)a1 = &unk_1ED061D30;

  JUMPOUT(0x1853275C0);
}

void *std::__function::__func<TFont::CoverageForFeatureSetting(CTFeatureSetting *)::$_1,std::allocator<TFont::CoverageForFeatureSetting(CTFeatureSetting *)::$_1>,void ()(void)>::__clone(uint64_t a1)
{
  CFNumberRef v1 = (atomic_ullong *)(a1 + 8);
  uint64_t v2 = operator new(0x10uLL);
  *uint64_t v2 = &unk_1ED061D30;
  v2[1] = (id)atomic_load_explicit(v1, memory_order_acquire);
  return v2;
}

id std::__function::__func<TFont::CoverageForFeatureSetting(CTFeatureSetting *)::$_1,std::allocator<TFont::CoverageForFeatureSetting(CTFeatureSetting *)::$_1>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1ED061D30;
  id result = (id)atomic_load_explicit((atomic_ullong *volatile)(a1 + 8), memory_order_acquire);
  a2[1] = result;
  return result;
}

void std::__function::__func<TFont::CoverageForFeatureSetting(CTFeatureSetting *)::$_1,std::allocator<TFont::CoverageForFeatureSetting(CTFeatureSetting *)::$_1>,void ()(void)>::destroy(uint64_t a1)
{
}

void std::__function::__func<TFont::CoverageForFeatureSetting(CTFeatureSetting *)::$_1,std::allocator<TFont::CoverageForFeatureSetting(CTFeatureSetting *)::$_1>,void ()(void)>::destroy_deallocate(id *a1)
{
  operator delete(a1);
}

void std::__function::__func<TFont::CoverageForFeatureSetting(CTFeatureSetting *)::$_1,std::allocator<TFont::CoverageForFeatureSetting(CTFeatureSetting *)::$_1>,void ()(void)>::operator()(uint64_t a1)
{
}

void std::__function::__func<TFont::GetBoundingBoxesForGlyphs(unsigned short const*,CGRect *,long,CTFontOrientation)::$_0,std::allocator<TFont::GetBoundingBoxesForGlyphs(unsigned short const*,CGRect *,long,CTFontOrientation)::$_0>,void ()(long)>::~__func()
{
}

__n128 std::__function::__func<TFont::GetBoundingBoxesForGlyphs(unsigned short const*,CGRect *,long,CTFontOrientation)::$_0,std::allocator<TFont::GetBoundingBoxesForGlyphs(unsigned short const*,CGRect *,long,CTFontOrientation)::$_0>,void ()(long)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1ED061E08;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<TFont::GetBoundingBoxesForGlyphs(unsigned short const*,CGRect *,long,CTFontOrientation)::$_0,std::allocator<TFont::GetBoundingBoxesForGlyphs(unsigned short const*,CGRect *,long,CTFontOrientation)::$_0>,void ()(long)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ED061E08;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

float64x2_t std::__function::__func<TFont::GetBoundingBoxesForGlyphs(unsigned short const*,CGRect *,long,CTFontOrientation)::$_0,std::allocator<TFont::GetBoundingBoxesForGlyphs(unsigned short const*,CGRect *,long,CTFontOrientation)::$_0>,void ()(long)>::operator()(uint64_t a1, void *a2)
{
  uint64_t v2 = *(double **)(a1 + 16);
  uint64_t v3 = (float64x2_t *)(**(void **)(a1 + 8) + 32 * *a2);
  float64x2_t result = vmulq_n_f64(v3[1], *v2);
  *uint64_t v3 = vmulq_n_f64(*v3, *v2);
  v3[1] = result;
  return result;
}

void std::__function::__func<TFont::GetBoundingBoxesForGlyphs(unsigned short const*,CGRect *,long,CTFontOrientation)::$_1,std::allocator<TFont::GetBoundingBoxesForGlyphs(unsigned short const*,CGRect *,long,CTFontOrientation)::$_1>,void ()(long)>::~__func()
{
}

__n128 std::__function::__func<TFont::GetBoundingBoxesForGlyphs(unsigned short const*,CGRect *,long,CTFontOrientation)::$_1,std::allocator<TFont::GetBoundingBoxesForGlyphs(unsigned short const*,CGRect *,long,CTFontOrientation)::$_1>,void ()(long)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1ED061E50;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<TFont::GetBoundingBoxesForGlyphs(unsigned short const*,CGRect *,long,CTFontOrientation)::$_1,std::allocator<TFont::GetBoundingBoxesForGlyphs(unsigned short const*,CGRect *,long,CTFontOrientation)::$_1>,void ()(long)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ED061E50;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<TFont::GetBoundingBoxesForGlyphs(CGAffineTransform const*,unsigned int,unsigned short const*,CGRect *,long,CTFontOrientation)::$_0,std::allocator<TFont::GetBoundingBoxesForGlyphs(CGAffineTransform const*,unsigned int,unsigned short const*,CGRect *,long,CTFontOrientation)::$_0>,void ()(long)>::~__func()
{
}

__n128 std::__function::__func<TFont::GetBoundingBoxesForGlyphs(CGAffineTransform const*,unsigned int,unsigned short const*,CGRect *,long,CTFontOrientation)::$_0,std::allocator<TFont::GetBoundingBoxesForGlyphs(CGAffineTransform const*,unsigned int,unsigned short const*,CGRect *,long,CTFontOrientation)::$_0>,void ()(long)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x40uLL);
  *(void *)uint64_t v2 = &unk_1ED061D78;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 4CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = result;
  *((void *)v2 + 7) = *(void *)(a1 + 56);
  return result;
}

__n128 std::__function::__func<TFont::GetBoundingBoxesForGlyphs(CGAffineTransform const*,unsigned int,unsigned short const*,CGRect *,long,CTFontOrientation)::$_0,std::allocator<TFont::GetBoundingBoxesForGlyphs(CGAffineTransform const*,unsigned int,unsigned short const*,CGRect *,long,CTFontOrientation)::$_0>,void ()(long)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ED061D78;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  long long v4 = *(_OWORD *)(a1 + 40);
  *(void *)(a2 + 56) = *(void *)(a1 + 56);
  *(_OWORD *)(a2 + 4CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = v4;
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<TFont::GetBoundingBoxesForGlyphs(CGAffineTransform const*,unsigned int,unsigned short const*,CGRect *,long,CTFontOrientation)::$_0,std::allocator<TFont::GetBoundingBoxesForGlyphs(CGAffineTransform const*,unsigned int,unsigned short const*,CGRect *,long,CTFontOrientation)::$_0>,void ()(long)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  v19.origin.CGFloat x = (**(double (***)(void, void))(a1 + 16))(**(void **)(a1 + 24), *(unsigned __int16 *)(**(void **)(a1 + 32) + 2 * *a2));
  long long v4 = (CGRect *)(**(void **)(a1 + 8) + 32 * v3);
  *long long v4 = v19;
  CGAffineTransform v5 = *(long long **)(a1 + 40);
  long long v6 = *v5;
  long long v7 = v5[2];
  *(_OWORD *)&v18.c = v5[1];
  *(_OWORD *)&v18.tCGFloat x = v7;
  *(_OWORD *)&v18.double a = v6;
  CGRect v20 = CGRectApplyAffineTransform(v19, &v18);
  *long long v4 = v20;
  CGRect v21 = CGRectOffset(v20, **(CGFloat **)(a1 + 48), *(CGFloat *)(*(void *)(a1 + 48) + 8));
  CGFloat x = v21.origin.x;
  CGFloat y = v21.origin.y;
  CGFloat width = v21.size.width;
  CGFloat height = v21.size.height;
  *(CGRect *)(**(void **)(a1 + 8) + 32 * v3) = v21;
  unint64_t v12 = *(CGFloat **)(a1 + 56);
  CGFloat v13 = *v12;
  CGFloat v14 = v12[1];
  CGFloat v15 = v12[2];
  CGFloat v16 = v12[3];
  v21.origin.CGFloat x = *v12;
  v21.origin.CGFloat y = v14;
  v21.size.CGFloat width = v15;
  v21.size.CGFloat height = v16;
  if (CGRectIsEmpty(v21))
  {
    CGFloat v13 = x;
    CGFloat v14 = y;
    CGFloat v15 = width;
    CGFloat v16 = height;
  }
  else
  {
    v22.origin.CGFloat x = x;
    v22.origin.CGFloat y = y;
    v22.size.CGFloat width = width;
    v22.size.CGFloat height = height;
    if (!CGRectIsEmpty(v22))
    {
      v23.origin.CGFloat x = v13;
      v23.origin.CGFloat y = v14;
      v23.size.CGFloat width = v15;
      v23.size.CGFloat height = v16;
      v25.origin.CGFloat x = x;
      v25.origin.CGFloat y = y;
      v25.size.CGFloat width = width;
      v25.size.CGFloat height = height;
      CGRect v24 = CGRectUnion(v23, v25);
      CGFloat v13 = v24.origin.x;
      CGFloat v14 = v24.origin.y;
      CGFloat v15 = v24.size.width;
      CGFloat v16 = v24.size.height;
    }
  }
  uint64_t v17 = *(CGFloat **)(a1 + 56);
  *uint64_t v17 = v13;
  v17[1] = v14;
  v17[2] = v15;
  float64x2_t v17[3] = v16;
}

void std::__function::__func<TFont::GetBoundingBoxesForGlyphs(CGAffineTransform const*,unsigned int,unsigned short const*,CGRect *,long,CTFontOrientation)::$_1,std::allocator<TFont::GetBoundingBoxesForGlyphs(CGAffineTransform const*,unsigned int,unsigned short const*,CGRect *,long,CTFontOrientation)::$_1>,void ()(long)>::~__func()
{
}

__n128 std::__function::__func<TFont::GetBoundingBoxesForGlyphs(CGAffineTransform const*,unsigned int,unsigned short const*,CGRect *,long,CTFontOrientation)::$_1,std::allocator<TFont::GetBoundingBoxesForGlyphs(CGAffineTransform const*,unsigned int,unsigned short const*,CGRect *,long,CTFontOrientation)::$_1>,void ()(long)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x40uLL);
  *(void *)uint64_t v2 = &unk_1ED061DC0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 4CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = result;
  *((void *)v2 + 7) = *(void *)(a1 + 56);
  return result;
}

__n128 std::__function::__func<TFont::GetBoundingBoxesForGlyphs(CGAffineTransform const*,unsigned int,unsigned short const*,CGRect *,long,CTFontOrientation)::$_1,std::allocator<TFont::GetBoundingBoxesForGlyphs(CGAffineTransform const*,unsigned int,unsigned short const*,CGRect *,long,CTFontOrientation)::$_1>,void ()(long)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ED061DC0;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  long long v4 = *(_OWORD *)(a1 + 40);
  *(void *)(a2 + 56) = *(void *)(a1 + 56);
  *(_OWORD *)(a2 + 4CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = v4;
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<TFont::GetBoundingBoxesForGlyphs(CGAffineTransform const*,unsigned int,unsigned short const*,CGRect *,long,CTFontOrientation)::$_1,std::allocator<TFont::GetBoundingBoxesForGlyphs(CGAffineTransform const*,unsigned int,unsigned short const*,CGRect *,long,CTFontOrientation)::$_1>,void ()(long)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  v14.origin.CGFloat x = (**(double (***)(void, void, void))(a1 + 16))(**(void **)(a1 + 24), *(void *)(a1 + 32), *(unsigned __int16 *)(**(void **)(a1 + 40) + 2 * *a2));
  *(CGRect *)(**(void **)(a1 + 8) + 32 * v3) = v14;
  CGRect v15 = CGRectOffset(v14, **(CGFloat **)(a1 + 48), *(CGFloat *)(*(void *)(a1 + 48) + 8));
  CGFloat x = v15.origin.x;
  CGFloat y = v15.origin.y;
  CGFloat width = v15.size.width;
  CGFloat height = v15.size.height;
  *(CGRect *)(**(void **)(a1 + 8) + 32 * v3) = v15;
  uint64_t v8 = *(CGFloat **)(a1 + 56);
  CGFloat v9 = *v8;
  CGFloat v10 = v8[1];
  CGFloat v11 = v8[2];
  CGFloat v12 = v8[3];
  v15.origin.CGFloat x = *v8;
  v15.origin.CGFloat y = v10;
  v15.size.CGFloat width = v11;
  v15.size.CGFloat height = v12;
  if (CGRectIsEmpty(v15))
  {
    CGFloat v9 = x;
    CGFloat v10 = y;
    CGFloat v11 = width;
    CGFloat v12 = height;
  }
  else
  {
    v16.origin.CGFloat x = x;
    v16.origin.CGFloat y = y;
    v16.size.CGFloat width = width;
    v16.size.CGFloat height = height;
    if (!CGRectIsEmpty(v16))
    {
      v17.origin.CGFloat x = v9;
      v17.origin.CGFloat y = v10;
      v17.size.CGFloat width = v11;
      v17.size.CGFloat height = v12;
      v19.origin.CGFloat x = x;
      v19.origin.CGFloat y = y;
      v19.size.CGFloat width = width;
      v19.size.CGFloat height = height;
      CGRect v18 = CGRectUnion(v17, v19);
      CGFloat v9 = v18.origin.x;
      CGFloat v10 = v18.origin.y;
      CGFloat v11 = v18.size.width;
      CGFloat v12 = v18.size.height;
    }
  }
  CGFloat v13 = *(CGFloat **)(a1 + 56);
  *CGFloat v13 = v9;
  v13[1] = v10;
  void v13[2] = v11;
  double v13[3] = v12;
}

void std::__function::__func<TFont::CopyVariantsOfGlyph(unsigned short)::$_0,std::allocator<TFont::CopyVariantsOfGlyph(unsigned short)::$_0>,void ()(unsigned short,__CFDictionary const*)>::~__func()
{
}

void *std::__function::__func<TFont::CopyVariantsOfGlyph(unsigned short)::$_0,std::allocator<TFont::CopyVariantsOfGlyph(unsigned short)::$_0>,void ()(unsigned short,__CFDictionary const*)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1ED061CA0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<TFont::CopyVariantsOfGlyph(unsigned short)::$_0,std::allocator<TFont::CopyVariantsOfGlyph(unsigned short)::$_0>,void ()(unsigned short,__CFDictionary const*)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1ED061CA0;
  a2[1] = v2;
  return result;
}

void std::__function::__func<TFont::CopyVariantsOfGlyph(unsigned short)::$_0,std::allocator<TFont::CopyVariantsOfGlyph(unsigned short)::$_0>,void ()(unsigned short,__CFDictionary const*)>::operator()(uint64_t a1, unsigned __int16 *a2, const void **a3)
{
  int v4 = *a2;
  CGAffineTransform v5 = *a3;
  id v12 = (id)0xAAAAAAAAAAAAAAAALL;
  TCFNumber::TCFNumber<int>(&v12, v4);
  long long v6 = *(atomic_ullong **)(a1 + 8);
  id v7 = (id)atomic_load_explicit((atomic_ullong *volatile)&v12, memory_order_acquire);
  CFDictionaryRef Value = (void *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit(v6, memory_order_acquire), v7);

  if (Value)
  {
    if (!v5) {
      goto LABEL_7;
    }
  }
  else
  {
    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    if (!Mutable) {
      goto LABEL_7;
    }
    CFDictionaryRef Value = Mutable;
    CGFloat v10 = *(atomic_ullong **)(a1 + 8);
    id v11 = (id)atomic_load_explicit((atomic_ullong *volatile)&v12, memory_order_acquire);
    CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit(v10, memory_order_acquire), v11, Value);

    CFRelease(Value);
    if (!v5) {
      goto LABEL_7;
    }
  }
  v13.CFIndex length = CFArrayGetCount((CFArrayRef)Value);
  v13.locatiouint64_t n = 0;
  if (!CFArrayContainsValue((CFArrayRef)Value, v13, v5)) {
    CFArrayAppendValue((CFMutableArrayRef)Value, v5);
  }
LABEL_7:
}

void *std::__function::__value_func<void ()(unsigned short,__CFDictionary const*)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t HangulShapingEngine::SetFeatures(HangulShapingEngine *this, OTL::GSUB *a2, OTL::GlyphLookups *a3)
{
  uint64_t v192 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *((void *)this + 1);
  if (*(void *)(v5 + 40) == -1) {
    TRunGlue::ComputeEndIndex(*((void **)this + 1));
  }
  if (*(uint64_t *)(v5 + 48) < 1) {
    return 0;
  }
  long long v155 = a3;
  uint64_t v153 = this;
  uint64_t v6 = 0;
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v169 = v7;
  long long v167 = v7;
  long long v168 = v7;
  long long v165 = v7;
  long long v166 = v7;
  v163[2] = v7;
  long long v164 = v7;
  v163[0] = v7;
  v163[1] = v7;
  do
  {
    uint64_t v8 = &v163[v6];
    *uint64_t v8 = 0;
    v8[1] = 0;
    uint64_t v8[2] = 0;
    id v8[5] = (char *)&v163[v6 + 1] + 8;
    v6 += 3;
  }
  while (v6 != 9);
  for (uint64_t i = 0; i != 3; ++i)
  {
    *(void *)&long long v184 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v182 = v10;
    long long v183 = v10;
    long long v180 = v10;
    long long v181 = v10;
    long long v178 = v10;
    long long v179 = v10;
    long long v177 = v10;
    long long v176 = 0uLL;
    uint64_t v175 = 0;
    *((void *)&v184 + 1) = &v177;
    int v159 = *(_DWORD *)&HangulShapingEngine::SetFeatures(OTL::GSUB &,OTL::GlyphLookups &)::tagArray[4 * i];
    OTL::FeatureBuffer::FeatureBuffer<unsigned int const*>(&v188, &v159, &v160);
    OTL::GCommon::GetLookups((uint64_t)a2, (uint64_t)&v188, (uint64_t)&v175, 0);
    int16x8_t v170 = (void **)&v188;
    std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](&v170);
    id v12 = (int *)v175;
    id v11 = (int *)v176;
    if (v175 != (void)v176)
    {
      CFRange v13 = (char **)&v163[3 * i];
      CGRect v14 = v13[1];
      do
      {
        int v15 = *v12;
        unint64_t v16 = (unint64_t)v13[2];
        if ((unint64_t)v14 >= v16)
        {
          uint64_t v17 = (v14 - *v13) >> 2;
          if ((unint64_t)(v17 + 1) >> 62) {
LABEL_205:
          }
            abort();
          uint64_t v18 = v16 - (void)*v13;
          uint64_t v19 = v18 >> 1;
          if (v18 >> 1 <= (unint64_t)(v17 + 1)) {
            uint64_t v19 = v17 + 1;
          }
          if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v20 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v20 = v19;
          }
          *((void *)&v190[0] + 1) = v13 + 3;
          if (v20) {
            CGRect v21 = (char *)TInlineBufferAllocator<std::pair<unsigned short,unsigned short>,4ul>::allocate((uint64_t)(v13 + 3), v20);
          }
          else {
            CGRect v21 = 0;
          }
          CGRect v22 = &v21[4 * v17];
          CGRect v23 = &v21[4 * v20];
          *(void *)&v190[0] = v23;
          *(_DWORD *)CGRect v22 = v15;
          CGRect v14 = v22 + 4;
          v189.i64[1] = (uint64_t)(v22 + 4);
          CGRect v25 = *v13;
          unint64_t v24 = (unint64_t)v13[1];
          if ((char *)v24 == *v13)
          {
            int64x2_t v27 = vdupq_n_s64(v24);
          }
          else
          {
            do
            {
              int v26 = *(_DWORD *)(v24 - 4);
              v24 -= 4;
              *((_DWORD *)v22 - 1) = v26;
              v22 -= 4;
            }
            while ((char *)v24 != v25);
            int64x2_t v27 = *(int64x2_t *)v13;
            CGRect v14 = (char *)v189.i64[1];
            CGRect v23 = *(char **)&v190[0];
          }
          *CFRange v13 = v22;
          v13[1] = v14;
          int64x2_t v189 = v27;
          CFIndex v28 = v13[2];
          void v13[2] = v23;
          *(void *)&v190[0] = v28;
          size_t v188 = (char *)v27.i64[0];
          std::__split_buffer<std::pair<unsigned short,unsigned short>,TInlineBufferAllocator<std::pair<unsigned short,unsigned short>,4ul> &>::~__split_buffer((uint64_t)&v188);
        }
        else
        {
          *(_DWORD *)CGRect v14 = v15;
          v14 += 4;
        }
        v13[1] = v14;
        ++v12;
      }
      while (v12 != v11);
    }
    size_t v188 = (char *)&v175;
    std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v188);
  }
  uint64_t v29 = (TRunGlue *)*((void *)this + 1);
  uint64_t v30 = TRunGlue::length(v29);
  uint64_t v175 = *(void *)this;
  long long v176 = 0u;
  long long v177 = 0u;
  long long v178 = 0u;
  long long v179 = 0u;
  long long v180 = 0u;
  long long v181 = 0u;
  long long v182 = 0u;
  long long v183 = 0u;
  long long v184 = 0u;
  long long v185 = 0u;
  uint64_t v187 = 0;
  long long v186 = 0u;
  *(void *)&long long v186 = *(void *)(v175 + 16);
  unsigned __int16 v162 = -1;
  *(void *)&long long v31 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v31 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v190[14] = v31;
  v190[13] = v31;
  v190[12] = v31;
  v190[11] = v31;
  v190[10] = v31;
  v190[9] = v31;
  v190[8] = v31;
  v190[7] = v31;
  v190[6] = v31;
  v190[5] = v31;
  v190[4] = v31;
  v190[3] = v31;
  v190[2] = v31;
  v190[1] = v31;
  v190[0] = v31;
  int64x2_t v189 = 0uLL;
  size_t v188 = 0;
  int v191 = v190;
  if (!v30)
  {
    uint64_t v139 = 0;
    goto LABEL_202;
  }
  uint64_t v32 = v30;
  uint64_t v154 = v29;
  unint64_t v33 = 0;
  char v151 = 0;
  uint64_t v152 = 0;
  unint64_t v34 = 0;
  uint64_t v35 = 0;
  unint64_t v36 = -1;
  unint64_t v37 = -1;
  uint64_t v38 = -1;
  do
  {
    StringIndeCGFloat x = TRunGlue::GetStringIndex(v29, v34);
    unsigned int Char = TCharStreamIterator::GetChar((TCharStreamIterator *)&v175, StringIndex);
    uint64_t v41 = v34 + 1;
    if (Char >> 1 == 6167)
    {
      double Advance = TRunGlue::GetAdvance(v29, v34);
      double v43 = Advance;
      if (v33)
      {
        if (Advance != 0.0)
        {
          TRunGlue::Rotate(*((TRunGlue **)v153 + 1), v35, v34, v34 + 1, 0);
          if (v188 != (char *)v189.i64[0]) {
            v189.i64[0] -= 8;
          }
          ++v36;
          ++v37;
          if (v38 == -1) {
            uint64_t v38 = -1;
          }
          else {
            ++v38;
          }
          char v151 = 1;
        }
      }
      else
      {
        int v56 = v162;
        if (v162 == 0xFFFF)
        {
          LOWORD(v17CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = 9676;
          uint64_t v57 = *(void *)(*(void *)(*((void *)v153 + 1) + 616) + 400);
          (*(void (**)(uint64_t, void ***, unsigned __int16 *, uint64_t))(*(void *)v57 + 664))(v57, &v170, &v162, 1);
          int v56 = v162;
        }
        if (v56 {
          && (uint64_t v58 = (int *)*((void *)v153 + 1),
        }
              LOWORD(v17CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = v56,
              uint64_t v152 = 1,
              TRunGlue::DoGlyphInsertion((TRunGlue *)v58, (const unsigned __int16 *)&v170, 1u, (v43 == 0.0) ^ (v58[6] < 0), 0, v34, v34, 1, 0)))
        {
          uint64_t v152 = 1;
          v193.locatiouint64_t n = v34;
          v193.CFIndex length = 1;
          OTL::GlyphLookups::Substituted((uint64_t *)v155, v193, 2);
          uint64_t v41 = v34 + 2;
          ++v32;
        }
        else
        {
          uint64_t v41 = v34 + 1;
        }
      }
      uint64_t v35 = v41;
      uint64_t v59 = v41 - 1;
      long long v60 = (void **)v189.i64[0];
      if (v189.i64[0] >= (unint64_t)v189.i64[1])
      {
        int v62 = (void **)v188;
        uint64_t v63 = (v189.i64[0] - (uint64_t)v188) >> 3;
        unint64_t v64 = v63 + 1;
        if ((unint64_t)(v63 + 1) >> 61) {
          goto LABEL_205;
        }
        uint64_t v65 = v189.i64[1] - (void)v188;
        if ((v189.i64[1] - (uint64_t)v188) >> 2 > v64) {
          unint64_t v64 = v65 >> 2;
        }
        if ((unint64_t)v65 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v66 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v66 = v64;
        }
        long long v174 = v190;
        if (v66)
        {
          long long v67 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v190, v66);
          int v62 = (void **)v188;
          long long v60 = (void **)v189.i64[0];
        }
        else
        {
          long long v67 = 0;
        }
        long long v76 = &v67[8 * v63];
        *(void *)long long v76 = v59;
        if (v60 == v62)
        {
          CFIndex v78 = &v67[8 * v63];
        }
        else
        {
          int v77 = v60;
          CFIndex v78 = &v67[8 * v63];
          do
          {
            uint64_t v79 = (uint64_t)*--v77;
            *((void *)v78 - 1) = v79;
            v78 -= 8;
          }
          while (v77 != v62);
        }
        CFNumberRef v61 = v76 + 8;
        size_t v188 = v78;
        v189.i64[0] = (uint64_t)(v76 + 8);
        uint64_t v80 = v189.i64[1];
        v189.i64[1] = (uint64_t)&v67[8 * v66];
        int16x8_t v172 = v60;
        uint64_t v173 = v80;
        int16x8_t v170 = v62;
        int16x8_t v171 = v62;
        std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v170);
      }
      else
      {
        *(void *)v189.i64[0] = v59;
        CFNumberRef v61 = v60 + 1;
      }
      unint64_t v33 = 0;
      v189.i64[0] = (uint64_t)v61;
      unint64_t v55 = v35;
      goto LABEL_97;
    }
    UChar32 v44 = Char;
    uint64_t v156 = v32;
    uint64_t v158 = v34 + 1;
    if (v36 != -1)
    {
      uint64_t v46 = (unsigned int *)*((void *)&v163[0] + 1);
      for (uint64_t j = *(unsigned int **)&v163[0]; j != v46; ++j)
      {
        unsigned int v47 = *j;
        unint64_t v33 = v33 & 0xFFFFFFFF00000000 | v47;
        OTL::GlyphLookups::SetLookupInRange<false>((uint64_t *)v155, v33, v36, 1);
      }
      char v49 = (unsigned int *)*((void *)&v164 + 1);
      for (unint64_t k = (unsigned int *)v164; k != v49; ++k)
      {
        unsigned int v50 = *k;
        unint64_t v36 = v36 & 0xFFFFFFFF00000000 | v50;
        OTL::GlyphLookups::SetLookupInRange<false>((uint64_t *)v155, v36, v37, 1);
      }
      if (v38 != -1)
      {
        long long v52 = (unsigned int *)*((void *)&v167 + 1);
        for (CGAffineTransform m = (unsigned int *)v167; m != v52; ++m)
        {
          unsigned int v53 = *m;
          unint64_t v37 = v37 & 0xFFFFFFFF00000000 | v53;
          OTL::GlyphLookups::SetLookupInRange<false>((uint64_t *)v155, v37, v38, 1);
        }
      }
    }
    IntPropertyCFDictionaryRef Value = u_getIntPropertyValue(v44, UCHAR_HANGUL_SYLLABLE_TYPE);
    if (IntPropertyValue == 1)
    {
      uint64_t v32 = v156;
      unint64_t v55 = v34 + 1;
      if (v158 == v156)
      {
        unint64_t v33 = 1;
LABEL_70:
        uint64_t v29 = v154;
LABEL_71:
        long long v68 = (void **)v189.i64[0];
        if (v189.i64[0] >= (unint64_t)v189.i64[1])
        {
          int v70 = (void **)v188;
          uint64_t v71 = (v189.i64[0] - (uint64_t)v188) >> 3;
          unint64_t v72 = v71 + 1;
          if ((unint64_t)(v71 + 1) >> 61) {
            goto LABEL_205;
          }
          uint64_t v73 = v189.i64[1] - (void)v188;
          if ((v189.i64[1] - (uint64_t)v188) >> 2 > v72) {
            unint64_t v72 = v73 >> 2;
          }
          if ((unint64_t)v73 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v74 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v74 = v72;
          }
          long long v174 = v190;
          if (v74)
          {
            long long v75 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v190, v74);
            int v70 = (void **)v188;
            long long v68 = (void **)v189.i64[0];
          }
          else
          {
            long long v75 = 0;
          }
          long long v81 = (unint64_t *)&v75[8 * v71];
          unint64_t *v81 = v34;
          if (v68 == v70)
          {
            unsigned int v83 = &v75[8 * v71];
            unint64_t v55 = v34 + 1;
          }
          else
          {
            CFIndex v82 = v68;
            unsigned int v83 = &v75[8 * v71];
            unint64_t v55 = v34 + 1;
            do
            {
              uint64_t v84 = (uint64_t)*--v82;
              *((void *)v83 - 1) = v84;
              v83 -= 8;
            }
            while (v82 != v70);
          }
          unint64_t v69 = v81 + 1;
          size_t v188 = v83;
          v189.i64[0] = (uint64_t)(v81 + 1);
          uint64_t v85 = v189.i64[1];
          v189.i64[1] = (uint64_t)&v75[8 * v74];
          int16x8_t v172 = v68;
          uint64_t v173 = v85;
          int16x8_t v170 = v70;
          int16x8_t v171 = v70;
          std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v170);
        }
        else
        {
          *(void *)v189.i64[0] = v34;
          unint64_t v69 = v68 + 1;
        }
        v189.i64[0] = (uint64_t)v69;
        uint64_t v38 = -1;
        unint64_t v37 = -1;
        unint64_t v36 = -1;
LABEL_97:
        unint64_t v34 = v35;
        goto LABEL_98;
      }
      uint64_t v29 = v154;
      uint64_t v86 = TRunGlue::GetStringIndex(v154, v158);
      UChar32 v87 = TCharStreamIterator::GetChar((TCharStreamIterator *)&v175, v86);
      int v88 = 0;
      uint64_t v89 = v34 + 2;
      int v90 = 1;
      unsigned int v91 = v44;
      unint64_t v33 = 1;
    }
    else
    {
      unint64_t v33 = IntPropertyValue;
      uint64_t v32 = v156;
      unint64_t v55 = v34 + 1;
      if (IntPropertyValue == 2) {
        goto LABEL_70;
      }
      uint64_t v29 = v154;
      if (IntPropertyValue == 3) {
        goto LABEL_71;
      }
      if ((unsigned __int16)(v44 + 10332) < 0xD45Cu)
      {
        unint64_t v33 = 0;
        goto LABEL_71;
      }
      if ((unsigned __int16)((-16384 * (v44 + 21504)) | ((unsigned __int16)(28087 * (v44 + 21504)) >> 2)) >= 0x925u)
      {
        unint64_t v33 = 5;
        uint64_t v35 = v34;
        goto LABEL_71;
      }
      int v90 = 0;
      unsigned int v91 = ((28533 * (unsigned __int16)(v44 + 21504)) >> 24) | 0x1100;
      UChar32 v87 = (unsigned __int16)(v44 + 21504) % 0x24Cu / 0x1C + 4449;
      uint64_t v89 = v34 + 1;
      int v88 = 1;
      unint64_t v33 = 4;
    }
    if (u_getIntPropertyValue(v87, UCHAR_HANGUL_SYLLABLE_TYPE) != 2)
    {
      uint64_t v35 = v34;
      unint64_t v55 = v34 + 1;
      goto LABEL_71;
    }
    if (v89 == v32)
    {
      UChar32 v92 = 0;
      uint64_t v93 = v32;
    }
    else
    {
      uint64_t v94 = TRunGlue::GetStringIndex(v29, v89);
      int v95 = v90;
      UChar32 v96 = TCharStreamIterator::GetChar((TCharStreamIterator *)&v175, v94);
      int32_t v97 = u_getIntPropertyValue(v96, UCHAR_HANGUL_SYLLABLE_TYPE);
      if (v97 == 3) {
        uint64_t v93 = v89 + 1;
      }
      else {
        uint64_t v93 = v89;
      }
      if (v97 == 3) {
        UChar32 v92 = v96;
      }
      else {
        UChar32 v92 = 0;
      }
      int v90 = v95;
    }
    if (v91 - 4352 > 0x12) {
      goto LABEL_125;
    }
    if ((unsigned __int16)(v87 - 4449) > 0x14u) {
      goto LABEL_125;
    }
    __int16 v98 = v92 - 4519;
    if (v92)
    {
      if ((unsigned __int16)(v92 - 4519) > 0x1Bu) {
        goto LABEL_125;
      }
    }
    uint64_t v150 = v93;
    if (!v92) {
      __int16 v98 = 0;
    }
    LOWORD(v159) = 28 * v87 + 588 * v91 + v98 - 18076;
    unsigned __int16 v161 = -21846;
    if (!(*(uint64_t (**)(void))(**(void **)(*(void *)(*((void *)v153 + 1) + 616) + 400) + 664))())
    {
      uint64_t v93 = v150;
LABEL_125:
      if (v92) {
        int v101 = v88;
      }
      else {
        int v101 = 0;
      }
      if (v101 == 1)
      {
        uint64_t v102 = v93;
        if ((unsigned __int16)(v44 + 10332) >= 0xD45Cu)
        {
          LOWORD(v91) = ((unsigned __int16)(v44 + 21504) / 0x24Cu) | 0x1100;
          UChar32 v87 = (unsigned __int16)(v44 + 21504) % 0x24Cu / 0x1C + 4449;
        }
        LOWORD(v17CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = v91;
        WORD1(v17CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = v87;
        WORD2(v17CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = v92;
        int v159 = -1431655766;
        LOWORD(v16CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = -21846;
        if ((*(uint64_t (**)(void))(**(void **)(*(void *)(*((void *)v153 + 1) + 616) + 400) + 664))() == 3)
        {
          TRunGlue::SetGlyphID<true>(*((TRunGlue **)v153 + 1), v34, (unsigned __int16)v159);
          if (TRunGlue::DoGlyphInsertion(*((TRunGlue **)v153 + 1), (const unsigned __int16 *)&v159 + 1, 1u, 0, 0, v34, v34, 0, 0))
          {
            v194.locatiouint64_t n = v34;
            v194.CFIndex length = 1;
            OTL::GlyphLookups::Substituted((uint64_t *)v155, v194, 2);
            ++v102;
            ++v156;
          }
          TRunGlue::SetGlyphID<true>(*((TRunGlue **)v153 + 1), v34 + 2, (unsigned __int16)v160);
          uint64_t v152 = 1;
        }
        uint64_t v32 = v156;
        uint64_t v93 = v102;
      }
      else
      {
        if (!v92)
        {
          uint64_t v38 = -1;
          uint64_t v32 = v156;
          goto LABEL_139;
        }
        uint64_t v32 = v156;
      }
      uint64_t v38 = v34 + 2;
LABEL_139:
      uint64_t v103 = v93 - 1;
      uint64_t v104 = (void **)v189.i64[0];
      if (v189.i64[0] >= (unint64_t)v189.i64[1])
      {
        unsigned int v106 = (void **)v188;
        uint64_t v107 = (v189.i64[0] - (uint64_t)v188) >> 3;
        unint64_t v108 = v107 + 1;
        if ((unint64_t)(v107 + 1) >> 61) {
          goto LABEL_205;
        }
        uint64_t v109 = v93;
        uint64_t v110 = v189.i64[1] - (void)v188;
        if ((v189.i64[1] - (uint64_t)v188) >> 2 > v108) {
          unint64_t v108 = v110 >> 2;
        }
        if ((unint64_t)v110 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v111 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v111 = v108;
        }
        long long v174 = v190;
        if (v111)
        {
          uint64_t v112 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v190, v111);
          unsigned int v106 = (void **)v188;
          uint64_t v104 = (void **)v189.i64[0];
        }
        else
        {
          uint64_t v112 = 0;
        }
        unint64_t v113 = &v112[8 * v107];
        *(void *)unint64_t v113 = v103;
        if (v104 == v106)
        {
          uint64_t v115 = &v112[8 * v107];
        }
        else
        {
          uint64_t v114 = v104;
          uint64_t v115 = &v112[8 * v107];
          do
          {
            uint64_t v116 = (uint64_t)*--v114;
            *((void *)v115 - 1) = v116;
            v115 -= 8;
          }
          while (v114 != v106);
        }
        CFRange v105 = v113 + 8;
        size_t v188 = v115;
        v189.i64[0] = (uint64_t)(v113 + 8);
        uint64_t v117 = v189.i64[1];
        v189.i64[1] = (uint64_t)&v112[8 * v111];
        int16x8_t v172 = v104;
        uint64_t v173 = v117;
        int16x8_t v170 = v106;
        int16x8_t v171 = v106;
        std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v170);
        uint64_t v93 = v109;
      }
      else
      {
        *(void *)v189.i64[0] = v103;
        CFRange v105 = v104 + 1;
      }
      v189.i64[0] = (uint64_t)v105;
      unint64_t v37 = v34 + 1;
      unint64_t v36 = v34;
      unint64_t v55 = v93;
      goto LABEL_98;
    }
    TRunGlue::SetGlyphID<true>(*((TRunGlue **)v153 + 1), v34, v161);
    CFRange v99 = (void **)v189.i64[0];
    if (v189.i64[0] >= (unint64_t)v189.i64[1])
    {
      uint64_t v118 = (void **)v188;
      uint64_t v119 = (v189.i64[0] - (uint64_t)v188) >> 3;
      unint64_t v120 = v119 + 1;
      if ((unint64_t)(v119 + 1) >> 61) {
        goto LABEL_205;
      }
      uint64_t v121 = v189.i64[1] - (void)v188;
      if ((v189.i64[1] - (uint64_t)v188) >> 2 > v120) {
        unint64_t v120 = v121 >> 2;
      }
      if ((unint64_t)v121 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v122 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v122 = v120;
      }
      long long v174 = v190;
      if (v122)
      {
        uint64_t v123 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v190, v122);
        uint64_t v118 = (void **)v188;
        CFRange v99 = (void **)v189.i64[0];
      }
      else
      {
        uint64_t v123 = 0;
      }
      BOOL v124 = (unint64_t *)&v123[8 * v119];
      *BOOL v124 = v34;
      if (v99 == v118)
      {
        double v126 = &v123[8 * v119];
      }
      else
      {
        double v125 = v99;
        double v126 = &v123[8 * v119];
        do
        {
          uint64_t v127 = (uint64_t)*--v125;
          *((void *)v126 - 1) = v127;
          v126 -= 8;
        }
        while (v125 != v118);
      }
      uint64_t v100 = v124 + 1;
      size_t v188 = v126;
      v189.i64[0] = (uint64_t)(v124 + 1);
      uint64_t v128 = v189.i64[1];
      v189.i64[1] = (uint64_t)&v123[8 * v122];
      int16x8_t v172 = v99;
      uint64_t v173 = v128;
      int16x8_t v170 = v118;
      int16x8_t v171 = v118;
      std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v170);
    }
    else
    {
      *(void *)v189.i64[0] = v34;
      uint64_t v100 = v99 + 1;
    }
    v189.i64[0] = (uint64_t)v100;
    unint64_t v129 = v34;
    if (v90)
    {
      unint64_t v129 = v34 + 1;
      TRunGlue::Delete(*((void **)v153 + 1), v158, 0);
    }
    if (v92) {
      TRunGlue::Delete(*((void **)v153 + 1), v129 + 1, 0);
    }
    uint64_t v152 = 1;
    uint64_t v38 = -1;
    unint64_t v37 = -1;
    unint64_t v36 = -1;
    unint64_t v55 = v150;
    uint64_t v32 = v156;
LABEL_98:
    uint64_t v35 = v34;
    unint64_t v34 = v55;
  }
  while (v55 != v32);
  if (v36 != -1)
  {
    double v131 = (unsigned int *)*((void *)&v163[0] + 1);
    for (uint64_t n = *(unsigned int **)&v163[0]; n != v131; ++n)
    {
      unsigned int v132 = *n;
      unint64_t v34 = v34 & 0xFFFFFFFF00000000 | v132;
      OTL::GlyphLookups::SetLookupInRange<false>((uint64_t *)v155, v34, v36, 1);
    }
    __int16 v134 = (unsigned int *)*((void *)&v164 + 1);
    for (iuint64_t i = (unsigned int *)v164; ii != v134; ++ii)
    {
      unsigned int v135 = *ii;
      unint64_t v34 = v34 & 0xFFFFFFFF00000000 | v135;
      OTL::GlyphLookups::SetLookupInRange<false>((uint64_t *)v155, v34, v37, 1);
    }
    if (v38 != -1)
    {
      int v137 = (unsigned int *)*((void *)&v167 + 1);
      for (juint64_t j = (unsigned int *)v167; jj != v137; ++jj)
      {
        unsigned int v138 = *jj;
        unint64_t v34 = v34 & 0xFFFFFFFF00000000 | v138;
        OTL::GlyphLookups::SetLookupInRange<false>((uint64_t *)v155, v34, v38, 1);
      }
    }
  }
  if (v151)
  {
    uint64_t v139 = v152;
    uint64_t v140 = (TRunGlue *)*((void *)v153 + 1);
    if (*((void *)v140 + 19))
    {
      int v141 = v188;
      uint64_t v142 = (char *)v189.i64[0];
      if (v188 == (char *)v189.i64[0])
      {
        uint64_t v143 = 0;
        double v145 = (TRunGlue *)*((void *)v153 + 1);
      }
      else
      {
        uint64_t v143 = 0;
        do
        {
          uint64_t v144 = *(void *)v141;
          if (v143 != *(void *)v141)
          {
            do
              TRunGlue::OrGlyphProps(v140, v143++, 8u);
            while (v144 != v143);
            uint64_t v143 = v144;
          }
          ++v143;
          v141 += 8;
        }
        while (v141 != v142);
        double v145 = (TRunGlue *)*((void *)v153 + 1);
      }
      uint64_t v146 = TRunGlue::length(v145);
      if (v143 != v146)
      {
        uint64_t v147 = v146;
        do
          TRunGlue::OrGlyphProps(v140, v143++, 8u);
        while (v147 != v143);
      }
    }
  }
  else
  {
    uint64_t v139 = v152;
  }
LABEL_202:
  int16x8_t v170 = (void **)&v188;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](&v170);
  for (kunint64_t k = 6; kk != -3; kk -= 3)
  {
    size_t v188 = (char *)&v163[kk];
    std::vector<std::pair<UScriptCode,long>,TInlineBufferAllocator<std::pair<UScriptCode,long>,1ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v188);
  }
  return v139;
}

void HangulShapingEngine::AddShapingGlyphs(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v3 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v7[0] = v3;
  v7[1] = v3;
  v7[2] = v3;
  v7[3] = v3;
  uint64_t v8 = (char *)v7 + 4;
  v6[1] = (char *)v7 + 4;
  v6[2] = (char *)v7 + 4;
  LODWORD(v7[0]) = 0;
  v6[0] = v7;
  (*(void (**)(void))(**(void **)(a1 + 400) + 672))();
  for (uint64_t i = (__int16 *)v7; i != (__int16 *)((char *)v7 + 4); ++i)
  {
    if (*i) {
      std::function<void ()(unsigned short,unsigned short)>::operator()(a2, *i, *i);
    }
  }
  uint64_t v5 = (void **)v6;
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100](&v5);
}

void *TInlineBufferAllocator<std::pair<unsigned short,unsigned short>,4ul>::allocate(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v2 = (unint64_t *)(a1 + 16);
  uint64_t v3 = v4;
  unint64_t v5 = v4 + 4 * a2;
  if (v5 <= (unint64_t)v2)
  {
    *uint64_t v2 = v5;
    return (void *)v3;
  }
  else
  {
    if (a2 >> 62) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    return operator new(4 * a2);
  }
}

uint64_t std::__split_buffer<std::pair<unsigned short,unsigned short>,TInlineBufferAllocator<std::pair<unsigned short,unsigned short>,4ul> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3) {
    *(void *)(a1 + 16) = v2 + ((v3 - v2 + 3) & 0xFFFFFFFFFFFFFFFCLL);
  }
  uint64_t v4 = *(void **)a1;
  if (*(void *)a1)
  {
    unint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = (void *)(v5 + 16);
    if (v5 <= (unint64_t)v4 && v6 > v4)
    {
      if (*(void *)(a1 + 24) == *v6) {
        *uint64_t v6 = v4;
      }
    }
    else
    {
      operator delete(v4);
    }
  }
  return a1;
}

void TRunGlue::OrGlyphProps(TRunGlue *this, uint64_t a2, unsigned int a3)
{
  if (*((void *)this + 19))
  {
    TRunGlue::FocusOnIndex(this, a2);
    uint64_t v6 = *((void *)this + 19);
    uint64_t v7 = a2 - *((void *)this + 20);
    uint64_t v8 = *(_DWORD *)(*((void *)this + 65) + 4 * v7) | a3;
    uint64_t v9 = *(void **)(v6 + 216);
    uint64_t v10 = *(void *)(v6 + 200) + v7;
    [v9 setProps:v8 atIndex:v10];
    return;
  }
  uint64_t v11 = *((void *)this + 20) + a2;
  uint64_t v12 = *((void *)this + 65);
  if (v12)
  {
LABEL_8:
    *(_DWORD *)(v12 + 4 * v11) |= a3;
    return;
  }
  if ((a3 & 0xFFFFFFDF) != 0)
  {
    TRunGlue::InitPropertiesFromDeletedGlyphs(this);
    uint64_t v12 = *((void *)this + 65);
    goto LABEL_8;
  }
  int v13 = 1 << (v11 & 7);
  uint64_t v14 = v11 / 8;
  uint64_t v15 = *((void *)this + 26);
  if ((a3 & 0x20) != 0) {
    char v16 = *(unsigned char *)(v15 + v14) | v13;
  }
  else {
    char v16 = *(unsigned char *)(v15 + v14) & ~(_BYTE)v13;
  }
  *(unsigned char *)(v15 + v14) = v16;
}

uint64_t TDescriptor::CreateBaseFont(uint64_t this, CGFont *a2)
{
  if (this) {
    operator new();
  }
  return this;
}

void TDescriptor::TDescriptor(TDescriptor *this, const TDescriptor *a2, const __CFNumber *a3, double a4, int a5)
{
  *(void *)this = &unk_1ED05D778;
  *((void *)this + 1) = 0;
  *((_DWORD *)this + 4) = *((_DWORD *)a2 + 4) & 0x7FFFFFFF | a5;
  *((void *)this + 3) = 0;
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)a2 + 4, memory_order_acquire);
  if (explicit)
  {
    if ((*(_DWORD *)(explicit + 180) & 0x10000000) != 0)
    {
      unint64_t explicit = 0;
    }
    else
    {
      atomic_fetch_or_explicit((atomic_uint *volatile)this + 4, 0x80000000, memory_order_relaxed);
      atomic_fetch_add_explicit((atomic_uint *volatile)(explicit + 8), 1u, memory_order_relaxed);
    }
  }
  *((void *)this + 4) = explicit;
  *((void *)this + 5) = (id)atomic_load_explicit((atomic_ullong *volatile)a2 + 5, memory_order_acquire);
  id v12 = (id)0xAAAAAAAAAAAAAAAALL;
  TDescriptor::CopyAttributes((atomic_ullong *)a2, &v12);
  id v11 = (id)0xAAAAAAAAAAAAAAAALL;
  TCFMutableDictionary::TCFMutableDictionary((TCFMutableDictionary *)&v11, (CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v12, memory_order_acquire));
  id v10 = (id)0xAAAAAAAAAAAAAAAALL;
  CopyVariationWithValue(0, a3, a4, &v10);
  if (atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire))
  {
    CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v11, memory_order_acquire), @"NSCTFontVariationAttribute", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire));
    if ((*((_DWORD *)a2 + 4) & 0x80000000) == 0) {
      TDescriptor::InitBaseFont(a2, 0, 0.0);
    }
    TDescriptor::MergeVariationWithBase(this, (const TBaseFont *)atomic_load_explicit((atomic_ullong *volatile)a2 + 4, memory_order_acquire), (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire), (atomic_ullong *)&v11);
  }
}

void TDescriptor::TDescriptor(TDescriptor *this, atomic_ullong *a2, int a3)
{
  *(void *)this = &unk_1ED05D778;
  TDescriptor::CopyAttributes(a2, (void *)this + 1);
  *((_DWORD *)this + 4) = *((_DWORD *)a2 + 4) | a3;
  *((void *)this + 3) = 0;
  unint64_t explicit = atomic_load_explicit(a2 + 4, memory_order_acquire);
  if (explicit) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(explicit + 8), 1u, memory_order_relaxed);
  }
  *((void *)this + 4) = explicit;
  *((void *)this + 5) = (id)atomic_load_explicit(a2 + 5, memory_order_acquire);
}

uint64_t TDescriptor::CopyAttribute@<X0>(atomic_ullong *this@<X0>, void *a2@<X8>)
{
  if ((this[2] & 0x80000000) == 0) {
    TDescriptor::InitBaseFont((TDescriptor *)this, 0, 0.0);
  }
  uint64_t result = atomic_load_explicit(this + 4, memory_order_acquire);
  if (result)
  {
    uint64_t v7 = *(uint64_t (**)(void))(*(void *)result + 48);
    return v7();
  }
  else
  {
    *a2 = 0;
  }
  return result;
}

void TDescriptor::CopyLocalizedAttribute(atomic_ullong *this@<X0>, const __CFString *key@<X1>, const __CFString **a3@<X2>, atomic_ullong *a4@<X8>)
{
  if ((this[2] & 0x80000000) == 0) {
    TDescriptor::InitBaseFont((TDescriptor *)this, 0, 0.0);
  }
  unint64_t explicit = atomic_load_explicit(this + 4, memory_order_acquire);
  if (explicit)
  {
    FontAttributeID = GetFontAttributeID(key);
    id v10 = *(void (**)(unint64_t, const void *, const __CFString **))(*(void *)explicit + 48);
    v10(explicit, FontAttributeID, a3);
  }
  else
  {
    id v11 = GetFontAttributeID(key);
    TDescriptor::CopyAttributeForNonNormalized(this, a3, (uint64_t)v11, a4);
  }
}

CFStringRef TDescriptor::DebugDescription(atomic_ullong *this)
{
  CFAllocatorRef v1 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  unint64_t Attributes = TDescriptor::GetAttributes(this, 1);
  return CFStringCreateWithFormat(v1, 0, @"attributes = %@>", Attributes);
}

void CTFontDescriptor::CTFontDescriptor(CTFontDescriptor *this, const CTFontDescriptor *a2, const __CFDictionary *a3, int a4)
{
  *((void *)this + 2) = 0;
  *((void *)this + 3) = TDescriptor::Hash;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = (char *)this + 48;
  if (a3) {
    operator new();
  }
  uint64_t v6 = *((void *)a2 + 5);
  if ((*(_DWORD *)(v6 + 16) & 0x80000000) == 0) {
    TDescriptor::InitBaseFont(*((TDescriptor **)a2 + 5), 0, 0.0);
  }
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(v6 + 32), memory_order_acquire);
  *((void *)this + 6) = &unk_1ED05D778;
  *((void *)this + 7) = 0;
  *((_DWORD *)this + 16) = a4 | 0x80000000;
  *((void *)this + 9) = 0;
  if (explicit) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(explicit + 8), 1u, memory_order_relaxed);
  }
  *((void *)this + 1CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = explicit;
  *((void *)this + 11) = 0;
}

CFTypeID CTFontCollectionGetTypeID(void)
{
  if (_MergedGlobals_14 != -1) {
    dispatch_once_f(&_MergedGlobals_14, 0, (dispatch_function_t)TCFBase<TCollection>::GetTypeID(void)::{lambda(void *)#1}::__invoke);
  }
  return qword_1EB2CE0D0;
}

CTFontCollectionRef CTFontCollectionCreateFromAvailableFonts(CFDictionaryRef options)
{
  CFDictionaryRef v9 = options;
  CFAllocatorRef v1 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFDictionaryRef v2 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CTFontDescriptorRef v3 = CTFontDescriptorCreateWithAttributes(v2);
  id values = v3;
  CFArrayRef v4 = CFArrayCreate(v1, (const void **)&values, 1, MEMORY[0x1E4F1D510]);
  id values = (void *)0xAAAAAAAAAAAAAAAALL;
  CFArrayRef v7 = v4;
  TCFBase_NEW<CTCollection,__CFArray const*,__CFDictionary const*&>(&v8, (void **)&v7, &v9);
  id values = (void *)atomic_exchange((atomic_ullong *volatile)&v8, 0);

  unint64_t v5 = (const __CTFontCollection *)atomic_exchange((atomic_ullong *volatile)&values, 0);
  return v5;
}

void TCFBase_NEW<CTCollection,__CFArray const*,__CFDictionary const*&>(void *a1, void **a2, const __CFDictionary **a3)
{
  uint64_t v6 = TCFBase<TCollection>::Allocate();
  if (v6)
  {
    uint64_t v7 = v6;
    id v8 = *a2;
    CFDictionaryRef v9 = *a3;
    *(void *)(v7 + 16) = CTCollection::Destruct;
    *(void *)(v7 + 24) = 0;
    *(void *)(v7 + 32) = 0;
    *(void *)(v7 + 4CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = v7 + 48;
    *(_DWORD *)(v7 + 48) = MakeFlags(v9);
    *(void *)(v7 + 56) = v8;
    *(void *)(v7 + 104) = 0;
    *(_OWORD *)(v7 + 64) = 0u;
    *(_OWORD *)(v7 + 8CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = 0u;
    *(_DWORD *)(v7 + 96) = 0;
    id v10 = (id)v7;
    *a1 = atomic_exchange((atomic_ullong *volatile)&v10, 0);
  }
  else
  {
    *a1 = 0;
  }
}

CTFontCollectionRef CTFontCollectionCreateWithFontDescriptors(CFArrayRef queryDescriptors, CFDictionaryRef options)
{
  id v9 = (id)0xAAAAAAAAAAAAAAAALL;
  uint64_t v4 = TCFBase<TCollection>::Allocate();
  if (v4)
  {
    uint64_t v5 = v4;
    *(void *)(v4 + 16) = CTCollection::Destruct;
    *(void *)(v4 + 24) = 0;
    *(void *)(v4 + 32) = 0;
    *(void *)(v4 + 4CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = v4 + 48;
    *(_DWORD *)(v4 + 48) = MakeFlags(options);
    *(void *)(v5 + 56) = queryDescriptors;
    *(void *)(v5 + 104) = 0;
    *(_OWORD *)(v5 + 64) = 0u;
    *(_OWORD *)(v5 + 8CTRunDrawWithAttributeOverrides((uint64_t)run, context, range.location, range.length, 0) = 0u;
    *(_DWORD *)(v5 + 96) = 0;
    id v10 = (id)v5;
    id v8 = (id)atomic_exchange((atomic_ullong *volatile)&v10, 0);
  }
  else
  {
    id v8 = 0;
  }
  id v9 = (id)atomic_exchange((atomic_ullong *volatile)&v8, 0);

  uint64_t v6 = (const __CTFontCollection *)atomic_exchange((atomic_ullong *volatile)&v9, 0);
  return v6;
}

CTFontCollectionRef CTFontCollectionCreateCopyWithFontDescriptors(CTFontCollectionRef original, CFArrayRef queryDescriptors, CFDictionaryRef options)
{
  if (!original) {
    return 0;
  }
  id v12 = (id)0xAAAAAAAAAAAAAAAALL;
  uint64_t v6 = TCFBase<TCollection>::Allocate();
  if (v6)
  {
    uint64_t v7 = (void *)v6;
    id v8 = (TCollection *)(v6 + 48);
    v7[2] = CTCollection::Destruct;
    v7[3] = 0;
    _OWORD v7[4] = 0;
    void v7[5] = v8;
    TCollection::TCollection(v8, original, queryDescriptors, options);
    id v13 = v7;
    id v11 = (id)atomic_exchange((atomic_ullong *volatile)&v13, 0);
  }
  else
  {
    id v11 = 0;
  }
  id v12 = (id)atomic_exchange((atomic_ullong *volatile)&v11, 0);

  id v9 = (const __CTFontCollection *)atomic_exchange((atomic_ullong *volatile)&v12, 0);
  return v9;
}

unint64_t CTFontCollectionCreateForLocale(uint64_t a1, const __CFDictionary *a2)
{
  CFDictionaryRef v12 = a2;
  if (!a1) {
    return 0;
  }
  id v11 = (id)0xAAAAAAAAAAAAAAAALL;
  CFDictionaryRef v2 = (__CFString *)MEMORY[0x185325F30]();
  LanguageIdentifierByNormalizing(v2, 2u, (atomic_ullong *)&v11);
  id values = (void *)atomic_load_explicit((atomic_ullong *volatile)&v11, memory_order_acquire);
  id keys = @"NSCTFontDesignLanguagesAttribute";
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFDictionaryRef v4 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CTFontDescriptorRef v5 = CTFontDescriptorCreateWithAttributes(v4);
  CTFontDescriptorRef v6 = v5;
  if (v5)
  {
    id keys = v5;
    CFArrayRef v7 = CFArrayCreate(v3, (const void **)&keys, 1, MEMORY[0x1E4F1D510]);
    id keys = (void *)0xAAAAAAAAAAAAAAAALL;
    CFArrayRef v10 = v7;
    TCFBase_NEW<CTCollection,__CFArray const*,__CFDictionary const*&>(&values, (void **)&v10, &v12);
    id keys = (void *)atomic_exchange((atomic_ullong *volatile)&values, 0);

    unint64_t v8 = atomic_exchange((atomic_ullong *volatile)&keys, 0);
  }
  else
  {
    unint64_t v8 = 0;
  }

  return v8;
}

CFArrayRef CTFontCollectionCreateMatchingFontDescriptors(CFArrayRef collection)
{
  if (collection) {
    return (CFArrayRef)TCollection::CopyMatchingFontDescriptorsUnlocked(*((atomic_ullong **)collection + 5), (const __CFArray *)**((unsigned int **)collection + 5), (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)(*((void *)collection + 5) + 8), memory_order_acquire));
  }
  return collection;
}

CFArrayRef CTFontCollectionCreateMatchingFontDescriptorsWithOptions(CFArrayRef collection, CFDictionaryRef options)
{
  if (collection) {
    return (CFArrayRef)TCollection::CopyMatchingFontDescriptors(*((atomic_ullong **)collection + 5), options);
  }
  return collection;
}

CFArrayRef CTFontCollectionCreateMatchingFontDescriptorsSortedWithCallback(CFArrayRef collection, CTFontCollectionSortDescriptorsCallback sortCallback, void *refCon)
{
  if (collection) {
    return TCollection::CopyMatchingFontDescriptors(*((atomic_ullong **)collection + 5), (CFComparisonResult (__cdecl *)(const void *, const void *, void *))sortCallback, refCon);
  }
  return collection;
}

CFArrayRef CTFontCollectionCopyFontAttribute(CFArrayRef collection, CFStringRef attributeName, CTFontCollectionCopyOptions options)
{
  if (collection) {
    return (CFArrayRef)TCollection::CopyFontAttribute(*((atomic_ullong **)collection + 5), (__CFString *)attributeName);
  }
  return collection;
}

CFArrayRef CTFontCollectionCopyFontAttributes(CFArrayRef collection, CFSetRef attributeNames, CTFontCollectionCopyOptions options)
{
  if (collection) {
    return (CFArrayRef)TCollection::CopyFontAttributes(*((atomic_ullong **)collection + 5), attributeNames);
  }
  return collection;
}

Class TCFBase<TCollection>::GetTypeID(void)::{lambda(void *)#1}::__invoke()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB2CE0D8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB2CE0D8))
  {
    qword_1EB2CE0E0 = 0;
    unk_1EB2CE0E8 = "CTFontCollection";
    qword_1EB2CE0F0 = 0;
    unk_1EB2CE0F8 = 0;
    qword_1EB2CE100 = (uint64_t)TCFBase<TCollection>::ClassDestruct;
    qword_1EB2CE108 = (uint64_t)TCFBase<TCollection>::ClassEqual;
    qword_1EB2CE110 = (uint64_t)TCFBase<TCollection>::ClassHash;
    unk_1EB2CE118 = 0;
    qword_1EB2CE120 = (uint64_t)TCFBase<TCollection>::ClassDebug;
    unk_1EB2CE128 = 0;
    qword_1EB2CE130 = 0;
    unk_1EB2CE138 = 0;
    __cxa_guard_release(&qword_1EB2CE0D8);
  }
  uint64_t v0 = _CFRuntimeRegisterClass();
  qword_1EB2CE0D0 = v0;

  return _CTFontCollectionEnableBridging(v0);
}

void TCFBase<TCollection>::ClassDestruct(uint64_t a1)
{
  CFDictionaryRef v2 = *(void (**)(uint64_t))(a1 + 16);
  if (v2) {
    v2(a1);
  }
  uint64_t v3 = *(void *)(a1 + 40);

  CFDictionaryRef v4 = *(void **)(v3 + 8);
}

uint64_t TCFBase<TCollection>::ClassEqual(uint64_t a1, uint64_t a2)
{
  return TCollection::operator==(*(void *)(a1 + 40), *(void *)(a2 + 40));
}

void *TCFBase<TCollection>::ClassHash(void *result)
{
  unint64_t v1 = result[3];
  uint64_t v2 = result[4];
  if (v2) {
    BOOL v3 = (result[4] & 1 | v1) == 0;
  }
  else {
    BOOL v3 = 1;
  }
  int v4 = !v3;
  if (v1) {
    BOOL v5 = 0;
  }
  else {
    BOOL v5 = v4 == 0;
  }
  if (!v5)
  {
    CTFontDescriptorRef v6 = (void *)(result[5] + (v2 >> 1));
    if (v2) {
      return (void *)(*(uint64_t (**)(void))(*v6 + v1))();
    }
    else {
      return (void *)((uint64_t (*)(void *))v1)(v6);
    }
  }
  return result;
}

uint64_t TCFBase<TCollection>::ClassDebug()
{
  return 0;
}

uint64_t TCFBase<TCollection>::Allocate()
{
  if (_MergedGlobals_14 != -1) {
    dispatch_once_f(&_MergedGlobals_14, 0, (dispatch_function_t)TCFBase<TCollection>::GetTypeID(void)::{lambda(void *)#1}::__invoke);
  }

  return _CFRuntimeCreateInstance();
}

uint64_t MakeFlags(CFDictionaryRef theDict)
{
  if (!theDict) {
    return 0;
  }
  LODWORD(v2) = 0;
  BOOL v3 = &kCollectionFlagsMapping;
  do
  {
    int v4 = *v3;
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, *((const void **)v3 + 2));
    int valuePtr = -1431655766;
    if (!Value || (CFNumberGetValue(Value, kCFNumberIntType, &valuePtr), !valuePtr)) {
      int v4 = 0;
    }
    uint64_t v2 = v4 | v2;
    v3 += 6;
  }
  while (v3 != (int *)&kCTFontCopyrightNameKey);
  return v2;
}

void TCollection::InitWithCopy(TCollection *this, const __CTFontCollection *a2, const __CFArray *a3, const __CFDictionary *a4)
{
  uint64_t v6 = *((void *)a2 + 5);
  *(_DWORD *)this |= *(_DWORD *)v6;
  *((void *)this + 4) = *(void *)(v6 + 32);
  TCFRef<__CTFont const*>::Retain((atomic_ullong *)this + 5, (id)atomic_load_explicit((atomic_ullong *volatile)(v6 + 40), memory_order_acquire));
  TCFRef<__CTFont const*>::Retain((atomic_ullong *)this + 3, (id)atomic_load_explicit((atomic_ullong *volatile)(v6 + 24), memory_order_acquire));
  id v8 = (id)0xAAAAAAAAAAAAAAAALL;
  TCFMutableArray::TCFMutableArray((TCFMutableArray *)&v8, (CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)(v6 + 8), memory_order_acquire));
  if (a3)
  {
    uint64_t Count = CFArrayGetCount(a3);
    if (Count >= 1)
    {
      v9.CFIndex length = Count;
      v9.locatiouint64_t n = 0;
      CFArrayAppendArray((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire), a3, v9);
    }
  }
  TCFRef<__CTFont const*>::Retain((atomic_ullong *)this + 1, (id)atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire));
  TCFRef<__CTFont const*>::Retain((atomic_ullong *)this + 2, (id)atomic_load_explicit((atomic_ullong *volatile)(v6 + 16), memory_order_acquire));
}

void TCollection::TCollection(TCollection *this, const __CTFontCollection *a2, const __CFArray *a3, CFDictionaryRef theDict)
{
  *(_DWORD *)this = MakeFlags(theDict);
  *((void *)this + 7) = 0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 36) = 0u;
  if (a2)
  {
    TCollection::InitWithCopy(this, a2, a3, v7);
    *(_DWORD *)this &= ~0x80000000;
  }
}

uint64_t TCollection::operator==(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1;
  }
  if (((*(_DWORD *)a2 ^ *(_DWORD *)a1) & 0x7FFFFFFF) != 0) {
    return 0;
  }
  unint64_t explicit = (const void *)atomic_load_explicit((atomic_ullong *volatile)(a1 + 8), memory_order_acquire);
  uint64_t v6 = (const void *)atomic_load_explicit((atomic_ullong *volatile)(a2 + 8), memory_order_acquire);
  if (explicit == v6) {
    goto LABEL_26;
  }
  if (explicit) {
    BOOL v7 = v6 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (v7) {
    return 0;
  }
  uint64_t result = CFEqual(explicit, v6);
  if (result)
  {
LABEL_26:
    id v8 = (const void *)atomic_load_explicit((atomic_ullong *volatile)(a1 + 16), memory_order_acquire);
    CFRange v9 = (const void *)atomic_load_explicit((atomic_ullong *volatile)(a2 + 16), memory_order_acquire);
    if (v8 == v9 || (uint64_t result = 0, v8) && v9 && (uint64_t result = CFEqual(v8, v9), result))
    {
      CFArrayRef v10 = (const void *)atomic_load_explicit((atomic_ullong *volatile)(a1 + 24), memory_order_acquire);
      id v11 = (const void *)atomic_load_explicit((atomic_ullong *volatile)(a2 + 24), memory_order_acquire);
      if (v10 == v11 || (uint64_t result = 0, v10) && v11 && (uint64_t result = CFEqual(v10, v11), result))
      {
        if (*(void *)(a1 + 32) != *(void *)(a2 + 32)) {
          return 0;
        }
        return StringEqual<TCFRef<__CFString const*>,TCFRef<__CFString const*>>((atomic_ullong *)(a1 + 40), (atomic_ullong *)(a2 + 40));
      }
    }
  }
  return result;
}

unint64_t TCollection::CopyMatchesForDescriptors(TCollection *this, const __CFArray *a2)
{
  uint64_t v3 = 0;
  uint64_t v4 = 288;
  do
  {
    if ((kCollectionFlagsMapping[v3] & a2) != 0) {
      v4 |= *(void *)&kCollectionFlagsMapping[v3 + 2];
    }
    v3 += 6;
  }
  while (v3 != 30);
  id Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  if (this)
  {
    CFIndex Count = CFArrayGetCount(this);
    if (Count)
    {
      CFIndex v6 = Count;
      CFIndex v7 = 0;
      uint64_t v8 = v4 | 1;
      do
      {
        CFNumberRef ValueAtIndex = (TDescriptor **)CFArrayGetValueAtIndex(this, v7);
        id v13 = (id)0xAAAAAAAAAAAAAAAALL;
        TDescriptor::CreateMatchingDescriptors(ValueAtIndex[5], 0, v8, (atomic_ullong *)&v13);
        if (atomic_load_explicit((atomic_ullong *volatile)&v13, memory_order_acquire))
        {
          id v12 = (id)atomic_load_explicit((atomic_ullong *volatile)&v13, memory_order_acquire);
          TCFMutableArray::AppendArray<TCFRef<__CFArray const*>>((atomic_ullong *)&Mutable, (atomic_ullong *)&v12);
        }
        ++v7;
      }
      while (v6 != v7);
    }
  }
  if (CFArrayGetCount((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire)) <= 0) {
    unint64_t v10 = 0;
  }
  else {
    unint64_t v10 = atomic_exchange((atomic_ullong *volatile)&Mutable, 0);
  }

  return v10;
}

unint64_t TCollection::CopyMatchingFontDescriptorsUnlocked(atomic_ullong *this, const __CFArray *a2, const __CFArray *a3)
{
  CFArrayRef v3 = a3;
  CFArrayRef v4 = a2;
  BOOL v5 = this;
  v89[33] = *MEMORY[0x1E4F143B8];
  CFArrayRef explicit = (const __CFArray *)atomic_load_explicit(this + 1, memory_order_acquire);
  id v67 = (id)0xAAAAAAAAAAAAAAAALL;
  if (explicit == a3 && *((_DWORD *)this + 16) == a2 && *((_DWORD *)this + 12) == TGenerationSeed::sGeneration) {
    CFIndex v7 = (void *)atomic_load_explicit(this + 7, memory_order_acquire);
  }
  else {
    CFIndex v7 = 0;
  }
  id v67 = v7;
  if (!atomic_load_explicit((atomic_ullong *volatile)&v67, memory_order_acquire))
  {
    if (!v3) {
      goto LABEL_81;
    }
    CFArrayRef v61 = explicit;
    if (CFArrayGetCount(v3) != 1) {
      goto LABEL_12;
    }
    CFRange v9 = (atomic_ullong *)*((void *)CFArrayGetValueAtIndex(v3, 0) + 5);
    *(void *)&long long v88 = 0xAAAAAAAAAAAAAAAALL;
    TDescriptor::CopyAttributes(v9, &v88);
    CFDictionaryRef v10 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)&v88, memory_order_acquire);
    if (v10)
    {
      CFDictionaryRef v11 = v10;
      CFIndex Count = CFDictionaryGetCount(v10);

      if (Count)
      {
LABEL_12:
        unint64_t v13 = TCollection::CopyMatchesForDescriptors(v3, v4);
        if (!v13) {
          goto LABEL_81;
        }
        uint64_t v14 = (void *)atomic_exchange((atomic_ullong *volatile)&v67, v13);
        goto LABEL_20;
      }
    }
    else
    {
    }
    uint64_t v15 = 0;
    uint64_t v16 = 288;
    do
    {
      if ((kCollectionFlagsMapping[v15] & v4) != 0) {
        v16 |= *(void *)&kCollectionFlagsMapping[v15 + 2];
      }
      v15 += 6;
    }
    while (v15 != 30);
    TDescriptorSource::TDescriptorSource((TDescriptorSource *)&values);
    TDescriptorSource::CopyAllDescriptorsInternal((atomic_ullong **)&values, 0, v16 | 1, &v88);

    uint64_t v14 = (void *)v88;
LABEL_20:

    if (atomic_load_explicit(v5 + 2, memory_order_acquire))
    {
      CFArrayRef v17 = (const __CFArray *)TCollection::CopyMatchesForDescriptors((TCollection *)atomic_load_explicit(v5 + 2, memory_order_acquire), v4);
      if (v17)
      {
        int v59 = (int)v4;
        long long v60 = v5;
        id v66 = (id)0xAAAAAAAAAAAAAAAALL;
        TCFMutableArray::TCFMutableArray((TCFMutableArray *)&v66, (CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v67, memory_order_acquire));
        CFIndex v63 = CFArrayGetCount(v17);
        if (v63)
        {
          CFIndex v18 = 0;
          CFArrayRef v62 = v17;
          while (1)
          {
            CFNumberRef ValueAtIndex = (const __CTFontDescriptor *)CFArrayGetValueAtIndex(v17, v18);
            CFDictionaryRef v20 = CTFontDescriptorCopyAttributes(ValueAtIndex);
            CFDictionaryRef v21 = v20;
            CFDictionaryRef v22 = v21;
            int64_t v23 = v21 ? CFDictionaryGetCount(v21) : 0;

            *(void *)&long long v24 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v24 + 1) = 0xAAAAAAAAAAAAAAAALL;
            *(_OWORD *)&v89[27] = v24;
            *(_OWORD *)&v89[29] = v24;
            *(_OWORD *)&v89[23] = v24;
            *(_OWORD *)&v89[25] = v24;
            *(_OWORD *)&v89[19] = v24;
            *(_OWORD *)&v89[21] = v24;
            *(_OWORD *)&v89[15] = v24;
            *(_OWORD *)&v89[17] = v24;
            *(_OWORD *)&v89[11] = v24;
            *(_OWORD *)&v89[13] = v24;
            *(_OWORD *)&v89[7] = v24;
            *(_OWORD *)&v89[9] = v24;
            *(_OWORD *)&v89[3] = v24;
            *(_OWORD *)&v89[5] = v24;
            *(_OWORD *)&v89[1] = v24;
            long long v88 = 0uLL;
            v89[0] = 0;
            v89[31] = &v89[1];
            CFIndex v65 = v18;
            if (!v23) {
              break;
            }
            std::vector<long,TInlineBufferAllocator<long,30ul>>::__vallocate[abi:nn180100](&v88, v23);
            uint64_t v25 = *((void *)&v88 + 1);
            bzero(*((void **)&v88 + 1), 8 * v23);
            *((void *)&v88 + 1) = v25 + 8 * v23;
            *(void *)&long long v26 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v26 + 1) = 0xAAAAAAAAAAAAAAAALL;
            long long v85 = v26;
            long long v86 = v26;
            long long v83 = v26;
            long long v84 = v26;
            long long v81 = v26;
            long long v82 = v26;
            long long v79 = v26;
            long long v80 = v26;
            long long v77 = v26;
            long long v78 = v26;
            long long v75 = v26;
            long long v76 = v26;
            long long v73 = v26;
            long long v74 = v26;
            long long v72 = v26;
            id values = 0;
            int v70 = 0;
            uint64_t v71 = 0;
            UChar32 v87 = &v72;
            std::vector<long,TInlineBufferAllocator<long,30ul>>::__vallocate[abi:nn180100](&values, v23);
            int64x2_t v27 = (char *)v70;
            bzero(v70, 8 * v23);
            int v70 = &v27[8 * v23];
            if (v20) {
              goto LABEL_29;
            }
LABEL_30:
            CFDictionaryRef v64 = v20;
            CFIndex v28 = CFArrayGetCount((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v66, memory_order_acquire));
            if (v28 >= 1)
            {
              do
              {
                uint64_t v29 = (const __CTFontDescriptor *)CFArrayGetValueAtIndex((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v66, memory_order_acquire), v28 - 1);
                CFDictionaryRef v30 = CTFontDescriptorCopyAttributes(v29);
                if (v23 < 1)
                {
                  uint64_t v31 = 0;
                }
                else
                {
                  uint64_t v31 = 0;
                  while (1)
                  {
                    CFDictionaryRef v32 = v30;
                    if (!v32) {
                      break;
                    }
                    CFDictionaryRef v33 = v32;
                    CFNumberRef Value = CFDictionaryGetValue(v32, *(const void **)(v88 + 8 * v31));

                    if (!Value || !CFEqual(Value, values[v31])) {
                      goto LABEL_40;
                    }
                    if (v23 == ++v31) {
                      goto LABEL_41;
                    }
                  }
                }
LABEL_40:
                if (v31 == v23) {
LABEL_41:
                }
                  CFArrayRemoveValueAtIndex((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v66, memory_order_acquire), v28 - 1);
              }
              while (v28-- > 1);
            }
            p_id values = &values;
            std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&p_values);
            id values = (void **)&v88;
            std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](&values);

            CFIndex v18 = v65 + 1;
            CFArrayRef v17 = v62;
            if (v65 + 1 == v63) {
              goto LABEL_48;
            }
          }
          long long v85 = v24;
          long long v86 = v24;
          long long v83 = v24;
          long long v84 = v24;
          long long v81 = v24;
          long long v82 = v24;
          long long v79 = v24;
          long long v80 = v24;
          long long v77 = v24;
          long long v78 = v24;
          long long v75 = v24;
          long long v76 = v24;
          long long v73 = v24;
          long long v74 = v24;
          long long v72 = v24;
          id values = 0;
          int v70 = 0;
          uint64_t v71 = 0;
          UChar32 v87 = &v72;
          if (!v20) {
            goto LABEL_30;
          }
LABEL_29:
          CFDictionaryGetKeysAndValues(v20, (const void **)v88, (const void **)values);
          goto LABEL_30;
        }
LABEL_48:
        TCFRef<__CTFont const*>::Retain((atomic_ullong *)&v67, (id)atomic_load_explicit((atomic_ullong *volatile)&v66, memory_order_acquire));

        BOOL v5 = v60;
        LODWORD(v4) = v59;
      }
    }
    if (!v5[4])
    {
LABEL_65:
      CFArrayRef v49 = (const __CFArray *)(id)atomic_load_explicit((atomic_ullong *volatile)&v67, memory_order_acquire);
      CFArrayRef v50 = v49;
      if (v49) {
        BOOL v51 = CFArrayGetCount(v49) > 0;
      }
      else {
        BOOL v51 = 0;
      }

      if ((v4 & 1) != 0 && v51)
      {
        unint64_t v52 = atomic_load_explicit((atomic_ullong *volatile)&v67, memory_order_acquire);
        CFMutableSetRef Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D548]);
        CFMutableSetRef v54 = Mutable;
        if (v52) {
          [(__CFSet *)Mutable addObjectsFromArray:v52];
        }
        *(void *)&long long v55 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v55 + 1) = 0xAAAAAAAAAAAAAAAALL;
        long long v88 = v55;
        *(_OWORD *)uint64_t v89 = v55;
        TFontDescriptorDuplicateFilter::TFontDescriptorDuplicateFilter((TFontDescriptorDuplicateFilter *)&v88, v54, &TFontDescriptorDuplicateFilter::kCTFontDescriptorDuplicateFilterSetCallBacks);
        TFontDescriptorDuplicateFilter::PerformFilter((atomic_ullong *)&v88);
        if (CFSetGetCount((CFSetRef)atomic_load_explicit(v89, memory_order_acquire)) >= 1)
        {
          CreateSortedArrayWithSet((CFSetRef)atomic_load_explicit(v89, memory_order_acquire), 0, 0, (CFArrayRef *)&values);
          unint64_t v56 = atomic_exchange((atomic_ullong *volatile)&values, 0);
        }
        TFontDescriptorDuplicateFilter::~TFontDescriptorDuplicateFilter((id *)&v88);
      }
      if (v61 == v3)
      {
        uint64_t v57 = (void *)atomic_load_explicit((atomic_ullong *volatile)&v67, memory_order_acquire);
        if ((void *)atomic_load_explicit(v5 + 7, memory_order_acquire) != v57 || *((_DWORD *)v5 + 16) != v4)
        {
          TCFRef<__CTFont const*>::Retain(v5 + 7, v57);
          *((_DWORD *)v5 + 16) = v4;
        }
        *((_DWORD *)v5 + 12) = TGenerationSeed::sGeneration;
      }
      goto LABEL_7;
    }
    id values = (void **)0xAAAAAAAAAAAAAAAALL;
    CFArrayRef v36 = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v67, memory_order_acquire);
    unint64_t v37 = (unsigned int (*)(const void *, const UInt8 *))v5[4];
    BytePtr = (const UInt8 *)atomic_load_explicit(v5 + 5, memory_order_acquire);
    if (v36)
    {
      CFIndex v39 = CFArrayGetCount(v36);
      long long v40 = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v39, MEMORY[0x1E4F1D548]);
      CFArrayRef v41 = v3;
      int v42 = (int)v4;
      if (BytePtr) {
        BytePtr = CFDataGetBytePtr((CFDataRef)BytePtr);
      }
      CFIndex v44 = CFArrayGetCount(v36);
      if (v44)
      {
        CFIndex v45 = v44;
        for (CFIndex i = 0; i != v45; ++i)
        {
          unsigned int v47 = CFArrayGetValueAtIndex(v36, i);
          if (v37(v47, BytePtr)) {
            CFSetAddValue(v40, v47);
          }
        }
      }
      CreateSortedArrayWithSet(v40, 0, 0, (CFArrayRef *)&v88);
      double v43 = (void **)atomic_exchange((atomic_ullong *volatile)&v88, 0);

      LODWORD(v4) = v42;
      CFArrayRef v3 = v41;
    }
    else
    {
      double v43 = 0;
    }
    id values = v43;
    if (atomic_load_explicit((atomic_ullong *volatile)&values, memory_order_acquire))
    {
      unint64_t v48 = atomic_load_explicit((atomic_ullong *volatile)&v67, memory_order_acquire);
      if (v48 != atomic_load_explicit((atomic_ullong *volatile)&values, memory_order_acquire)) {

      }
      goto LABEL_65;
    }

LABEL_81:
    unint64_t v8 = 0;
    goto LABEL_82;
  }
LABEL_7:
  unint64_t v8 = atomic_exchange((atomic_ullong *volatile)&v67, 0);
LABEL_82:

  return v8;
}

void TCFMutableArray::AppendArray<TCFRef<__CFArray const*>>(atomic_ullong *a1, atomic_ullong *a2)
{
  CFArrayRef explicit = (__CFArray *)atomic_load_explicit(a1, memory_order_acquire);
  CFArrayRef v3 = (const __CFArray *)atomic_load_explicit(a2, memory_order_acquire);
  CFArrayRef v4 = (const __CFArray *)(id)atomic_load_explicit(a2, memory_order_acquire);
  CFArrayRef v5 = v4;
  if (v4) {
    v6.CFIndex length = CFArrayGetCount(v4);
  }
  else {
    v6.CFIndex length = 0;
  }
  v6.locatiouint64_t n = 0;
  CFArrayAppendArray(explicit, v3, v6);
}

unint64_t TCollection::CopyMatchingFontDescriptors(atomic_ullong *this, CFDictionaryRef theDict)
{
  if (theDict) {
    CFArrayRef Flags = (const __CFArray *)MakeFlags(theDict);
  }
  else {
    CFArrayRef Flags = (const __CFArray *)*(unsigned int *)this;
  }
  CFArrayRef explicit = (const __CFArray *)atomic_load_explicit(this + 1, memory_order_acquire);

  return TCollection::CopyMatchingFontDescriptorsUnlocked(this, Flags, explicit);
}

void TFontDescriptorDuplicateFilter::PerformFilter(atomic_ullong *a1)
{
  CFArrayRef v2 = (const __CFArray *)(id)atomic_load_explicit(a1 + 3, memory_order_acquire);
  if (v2)
  {
    CFArrayRef v3 = v2;
    uint64_t Count = CFArrayGetCount(v2);

    if (Count >= 1)
    {
      CFArrayRef explicit = (const __CFArray *)atomic_load_explicit(a1 + 3, memory_order_acquire);
      v6.locatiouint64_t n = 0;
      v6.CFIndex length = Count;
      CFArrayApplyFunction(explicit, v6, (CFArrayApplierFunction)TFontDescriptorFilter::FilterFunctionToAdd, a1);
    }
  }
  else
  {
  }
}

const __CFArray *TCollection::CopyMatchingFontDescriptors(atomic_ullong *this, CFComparisonResult (__cdecl *a2)(const void *, const void *, void *), void *a3)
{
  CFArrayRef v5 = (const __CFArray *)TCollection::CopyMatchingFontDescriptorsUnlocked(this, (const __CFArray *)*(unsigned int *)this, (const __CFArray *)atomic_load_explicit(this + 1, memory_order_acquire));
  CFArrayRef v6 = v5;
  if (a2 && v5)
  {
    MutableCopCGFloat y = CFArrayCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v5);
    CFRelease(v6);
    CFArrayRef explicit = (__CFArray *)atomic_load_explicit((atomic_ullong *volatile)&MutableCopy, memory_order_acquire);
    v10.CFIndex length = CFArrayGetCount((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&MutableCopy, memory_order_acquire));
    v10.locatiouint64_t n = 0;
    CFArraySortValues(explicit, v10, a2, a3);
    CFArrayRef v6 = (const __CFArray *)atomic_exchange((atomic_ullong *volatile)&MutableCopy, 0);
  }
  return v6;
}

unint64_t TCollection::CopyFontAttribute(atomic_ullong *this, __CFString *a2)
{
  CFArrayRef v3 = (const __CFArray *)TCollection::CopyMatchingFontDescriptorsUnlocked(this, (const __CFArray *)*(unsigned int *)this, (const __CFArray *)atomic_load_explicit(this + 1, memory_order_acquire));
  unint64_t v4 = CTFontDescriptorsCopyAttribute(v3, a2);

  return v4;
}

unint64_t TCollection::CopyFontAttributes(atomic_ullong *this, const __CFSet *a2)
{
  CFArrayRef v3 = (const __CFArray *)TCollection::CopyMatchingFontDescriptorsUnlocked(this, (const __CFArray *)*(unsigned int *)this, (const __CFArray *)atomic_load_explicit(this + 1, memory_order_acquire));
  unint64_t v4 = CTFontDescriptorsCopyAttributesInternal(v3, a2);

  return v4;
}

void TFontDescriptorFilter::FilterFunctionToAdd(TFontDescriptorFilter *this, atomic_ullong *a2, void *a3)
{
  if ((*(unsigned int (**)(atomic_ullong *, TFontDescriptorFilter *, void *))(*a2 + 56))(a2, this, a3))
  {
    CFArrayRef explicit = (__CFSet *)atomic_load_explicit(a2 + 2, memory_order_acquire);
    CFSetAddValue(explicit, this);
  }
}

void CopyFontNameInternal(CGFontRef font@<X0>, uint64_t a2@<X1>, int a3@<W2>, atomic_ullong *a4@<X8>)
{
  if (!((unint64_t)font | a2) || a3 == -1)
  {
    *a4 = 0;
    return;
  }
  if ((a3 & 0x80000000) == 0)
  {
    *a4 = 0;
    if (a3 == 6)
    {
      CFIndex v7 = (void *)atomic_exchange(a4, (unint64_t)CGFontCopyPostScriptName(font));

      return;
    }
    if (a2 || CGFontNameTableCreate())
    {
      if (a3 == 1 || a3 == 2) {

      }
      if (!atomic_load_explicit(a4, memory_order_acquire)) {
    }
      }
    if (atomic_load_explicit(a4, memory_order_acquire)
      || a3 > 0x13
      || ((0xB7FFFu >> a3) & 1) == 0
      || !**((void **)&unk_1E528A570 + a3)
      || ((id)atomic_exchange(a4, CGFontCopyName()),
          unint64_t explicit = atomic_load_explicit(a4, memory_order_acquire),
          a3 != 2)
      || explicit)
    {
LABEL_47:
      CGFontNameTableRelease();
      return;
    }
    id v20 = 0;
    CFRange v9 = (__CFString *)CGFontCopyFullName(font);
    uint64_t v10 = CGFontCopyFamilyName();
    CFDictionaryRef v11 = (__CFString *)v10;
    if (v9 && v10)
    {
      id v12 = v9;
      unint64_t v13 = v11;
      if (v12 == v13)
      {

        id v16 = v12;
LABEL_42:

        goto LABEL_44;
      }
      uint64_t v14 = v13;
      if (!v12 || !v13)
      {

LABEL_34:
        if (!CFStringHasPrefix(v9, v11))
        {
          TCFRef<__CTFont const*>::Retain((atomic_ullong *)&v20, v9);
          goto LABEL_44;
        }
        CFAllocatorRef v17 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        MutableCopCGFloat y = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v9);
        v23.CFIndex length = CFStringGetLength(v11);
        v23.locatiouint64_t n = 0;
        CFStringDelete((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&MutableCopy, memory_order_acquire), v23);
        CFCharacterSetRef v18 = CFCharacterSetCreateWithCharactersInString(v17, @" -");
        if (v18
          && CFStringGetLength((CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&MutableCopy, memory_order_acquire)) >= 1)
        {
          do
          {
            CharacterAtIndeCGFloat x = CFStringGetCharacterAtIndex((CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&MutableCopy, memory_order_acquire), 0);
            if (!CFCharacterSetIsLongCharacterMember(v18, CharacterAtIndex)) {
              break;
            }
            v24.locatiouint64_t n = 0;
            v24.CFIndex length = 1;
            CFStringDelete((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&MutableCopy, memory_order_acquire), v24);
          }
          while (CFStringGetLength((CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&MutableCopy, memory_order_acquire)) > 0);
        }
        if (CFStringGetLength((CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&MutableCopy, memory_order_acquire)) >= 1)(id)atomic_exchange((atomic_ullong *volatile)&v20, atomic_exchange((atomic_ullong *volatile)&MutableCopy, 0)); {

        }
        id v16 = MutableCopy;
        goto LABEL_42;
      }
      int v15 = CFEqual(v12, v13);

      if (!v15) {
        goto LABEL_34;
      }
    }
LABEL_44:
    if (!atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire)) {
      TCFRef<__CTFont const*>::Retain((atomic_ullong *)&v20, @"Regular");
    }

    goto LABEL_47;
  }

  CopyStaticOTFeatureName(0, a3, a4);
}

void CopyLocalizedFontNameFromResources(__CFString *a1@<X0>, id a2@<X2>, const __CFString **a3@<X3>, int a4@<W1>, __CFString *a5@<X8>)
{
  if (a4 == 4)
  {
LABEL_4:
    CFStringRef v9 = @"FontNames";
    goto LABEL_6;
  }
  if (a4 != 2)
  {
    if (a4 != 1)
    {
LABEL_10:
      id v11 = a1;
      a5->isdouble a = (void *)atomic_exchange((atomic_ullong *volatile)&v11, 0);
      goto LABEL_11;
    }
    goto LABEL_4;
  }
  CFStringRef v9 = @"StyleNames";
LABEL_6:
  id v11 = a2;
  if (!atomic_load_explicit((atomic_ullong *volatile)&v11, memory_order_acquire))
  {
    CreateNormalizedPreferredLanguages(&v10);
  }
  a5->isdouble a = (void *)0xAAAAAAAAAAAAAAAALL;
  CopyDefaultLocalizedName(a5, a1, v9, (const __CFString **)a2, (unint64_t)a3);
  if (!atomic_load_explicit((atomic_ullong *volatile)a5, memory_order_acquire))
  {

    goto LABEL_10;
  }
LABEL_11:
}

void CopyDefaultLocalizedName(const __CFString *a1, const __CFString *a2, const __CFString *a3, const __CFString **a4, unint64_t a5)
{
  if (!a2 || (explicit = a2, (CFBundleRef v9 = _CTGetFrameworkBundleForLocalization()) == 0))
  {
    a1->isdouble a = 0;
    return;
  }
  id v10 = v9;
  Predefinedouble d = CFCharacterSetGetPredefined(kCFCharacterSetDecimalDigit);
  v48.CFIndex length = CFStringGetLength(explicit);
  v48.locatiouint64_t n = 0;
  CFIndex v12 = RangeOfCharactersFromSet(explicit, Predefined, v48, 0);
  id v45 = 0;
  id v46 = 0;
  if (v12 != -1)
  {
    CFIndex v14 = v12;
    CFIndex v15 = v13;
    CFAllocatorRef v16 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    v49.locatiouint64_t n = v12;
    v49.CFIndex length = v13;
    MutableCopCGFloat y = (id)CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E4F1CF80], explicit, v49);

    if (atomic_load_explicit((atomic_ullong *volatile)&v46, memory_order_acquire))
    {
      MutableCopCGFloat y = CFStringCreateMutableCopy(v16, 0, explicit);

      v47.locatiouint64_t n = v14;
      v47.CFIndex length = v15;
      CFStringReplace((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&v45, memory_order_acquire), v47, @"%d");
      CFStringRef explicit = (const __CFString *)atomic_load_explicit((atomic_ullong *volatile)&v45, memory_order_acquire);
    }
  }
  MutableCopCGFloat y = (id)0xAAAAAAAAAAAAAAAALL;
  CopyLowercasedString(explicit, &MutableCopy);
  id v43 = 0;
  if (!((unint64_t)a4 | a5))
  {
    id v42 = (id)CFBundleCopyLocalizedString(v10, (CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&MutableCopy, memory_order_acquire), 0, a3);

    CFArrayRef v18 = (const __CFArray *)(id)atomic_load_explicit((atomic_ullong *volatile)&v43, memory_order_acquire);
    CFArrayRef v30 = (const __CFArray *)(id)atomic_load_explicit((atomic_ullong *volatile)&MutableCopy, memory_order_acquire);
    if (v18 == v30)
    {
    }
    else
    {
      CFArrayRef v31 = v30;
      if (!v18 || !v30)
      {

        goto LABEL_50;
      }
      int v32 = CFEqual(v18, v30);

      if (!v32) {
        goto LABEL_51;
      }
    }
    id v42 = (id)CFBundleCopyLocalizedString(v10, explicit, @"LocalizedFontNameNotFound", a3);

    CFDictionaryRef v33 = (__CFString *)(id)atomic_load_explicit((atomic_ullong *volatile)&v43, memory_order_acquire);
    if (v33 == @"LocalizedFontNameNotFound")
    {
    }
    else
    {
      unint64_t v34 = v33;
      if (!v33)
      {
        CFArrayRef v18 = 0;
        goto LABEL_50;
      }
      int v35 = CFEqual(v33, @"LocalizedFontNameNotFound");

      if (!v35) {
        goto LABEL_51;
      }
    }
    CFArrayRef v18 = (const __CFArray *)atomic_exchange((atomic_ullong *volatile)&v43, 0);
    goto LABEL_50;
  }
  if (qword_1EB2CE158 != -1) {
    dispatch_once_f(&qword_1EB2CE158, v10, (dispatch_function_t)CopyDefaultLocalizedName(__CFString const*,__CFString const*,__CFArray const*,__CFString const**)::$_0::__invoke);
  }
  if (!qword_1EB2CE150)
  {
    CFArrayRef v36 = 0;
    goto LABEL_55;
  }
  CFArrayRef v17 = CFBundleCopyLocalizationsForPreferences((CFArrayRef)qword_1EB2CE150, (CFArrayRef)a4);
  CFArrayRef v18 = v17;
  if (!v17) {
    goto LABEL_50;
  }
  CFIndex Count = CFArrayGetCount(v17);
  if (!Count) {
    goto LABEL_50;
  }
  CFIndex v20 = Count;
  CFIndex v39 = (void *)a5;
  CFStringRef v40 = a1;
  CFIndex v21 = 0;
  while (1)
  {
    CFNumberRef ValueAtIndex = (__CFString *)CFArrayGetValueAtIndex(v18, v21);
    atomic_load_explicit((atomic_ullong *volatile)&MutableCopy, memory_order_acquire);
    id v42 = (id)CFBundleCopyLocalizedStringForLocalization();

    CFRange v23 = (__CFString *)(id)atomic_load_explicit((atomic_ullong *volatile)&v43, memory_order_acquire);
    CFRange v24 = (__CFString *)(id)atomic_load_explicit((atomic_ullong *volatile)&MutableCopy, memory_order_acquire);
    if (v23 == v24)
    {

LABEL_22:
      id v42 = (id)CFBundleCopyLocalizedStringForLocalization();

      CFIndex v28 = (__CFString *)(id)atomic_load_explicit((atomic_ullong *volatile)&v43, memory_order_acquire);
      if (v28 == @"LocalizedFontNameNotFound")
      {

LABEL_27:
        CFRange v23 = (__CFString *)atomic_exchange((atomic_ullong *volatile)&v43, 0);
LABEL_28:

        goto LABEL_29;
      }
      CFRange v23 = v28;
      if (!v28) {
        goto LABEL_28;
      }
      int v29 = CFEqual(v28, @"LocalizedFontNameNotFound");

      if (v29) {
        goto LABEL_27;
      }
      goto LABEL_29;
    }
    uint64_t v25 = v24;
    if (v23) {
      BOOL v26 = v24 == 0;
    }
    else {
      BOOL v26 = 1;
    }
    if (v26)
    {

      goto LABEL_28;
    }
    int v27 = CFEqual(v23, v24);

    if (v27) {
      goto LABEL_22;
    }
LABEL_29:
    if (atomic_load_explicit((atomic_ullong *volatile)&v43, memory_order_acquire)) {
      break;
    }
    if (v20 == ++v21) {
      goto LABEL_48;
    }
  }
  if (v39)
  {
    LanguageIdentifierByNormalizing(ValueAtIndex, 1u, (atomic_ullong *)&v42);
    void *v39 = atomic_exchange((atomic_ullong *volatile)&v42, 0);
  }
LABEL_48:
  a1 = v40;
LABEL_50:

LABEL_51:
  CFArrayRef v36 = (void *)atomic_load_explicit((atomic_ullong *volatile)&v43, memory_order_acquire);
  if (v36)
  {
    if (atomic_load_explicit((atomic_ullong *volatile)&v45, memory_order_acquire))
    {
      CFStringRef v37 = (const __CFString *)atomic_load_explicit((atomic_ullong *volatile)&v43, memory_order_acquire);
      IntCFNumberRef Value = CFStringGetIntValue((CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&v46, memory_order_acquire));
      CreateLocalizedStringWithFormat(v37, &v42, IntValue);
    }
    CFArrayRef v36 = (void *)atomic_exchange((atomic_ullong *volatile)&v43, 0);
  }
LABEL_55:
  a1->isdouble a = v36;
}

void FontNameCodeForKey(__CFString const*)::$_0::__invoke()
{
  id v0 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)FontNameCodeForKey(__CFString const*)::keys, (const void **)&FontNameCodeForKey(__CFString const*)::values, 20, MEMORY[0x1E4F1D530], 0);
  _MergedGlobals_15 = atomic_exchange((atomic_ullong *volatile)&v0, 0);
}

CFArrayRef CopyDefaultLocalizedName(__CFString const*,__CFString const*,__CFArray const*,__CFString const**)::$_0::__invoke(__CFBundle *a1)
{
  CFArrayRef result = CFBundleCopyBundleLocalizations(a1);
  qword_1EB2CE150 = (uint64_t)result;
  return result;
}

atomic_ullong *anonymous namespace'::TFeatureSelector::TFeatureSelector(atomic_ullong *this, const __CFString *a2, unsigned int a3, int a4)
{
  *this = 0;
  id Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"CTFeatureOpenTypeTag", a2);
  TCFNumber::TCFNumber<unsigned int>(&v10, a3);
  CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"CTFeatureOpenTypeValue", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire));

  if (a4)
  {
    CFStringRef explicit = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
    CFDictionarySetValue(explicit, @"CTFeatureSelectorDefault", (const void *)*MEMORY[0x1E4F1CFD0]);
  }

  return this;
}

void *TFontFeatures::GetFeatureSelector(atomic_ullong *this, int a2, int a3)
{
  id v8 = (id)0xAAAAAAAAAAAAAAAALL;
  TCFNumber::TCFNumber<int>(&v7, a2);
  id v8 = TFontFeatures::GetFeatureType(this, (const __CFNumber *)atomic_load_explicit((atomic_ullong *volatile)&v7, memory_order_acquire));

  TCFNumber::TCFNumber<int>(&v7, a3);

  return Selector;
}

void TFontFeatures::HandleAlias(TFeatureSetting const&,BOOL,TCFMutableArray &,TCFMutableArray &)const::$_1::operator()(atomic_ullong *a1, atomic_ullong *a2)
{
  CFArrayRef v3 = [[CTFeatureSetting alloc] initWithDictionary:atomic_load_explicit(a2, memory_order_acquire)];
  CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit(a1, memory_order_acquire), v3);
}

void TFeatureSetting::TFeatureSetting(TFeatureSetting *this, CFTypeRef cf, const __CFNumber *a3)
{
  keys[2] = *(void **)MEMORY[0x1E4F143B8];
  *(void *)this = 0;
  CFTypeID v6 = CFGetTypeID(cf);
  CFTypeID TypeID = CFNumberGetTypeID();
  if (!a3)
  {
    if (v6 == TypeID) {
      return;
    }
    a3 = (const __CFNumber *)*MEMORY[0x1E4F1CFD0];
  }
  id v8 = @"CTFeatureOpenTypeTag";
  if (v6 == TypeID) {
    id v8 = @"CTFeatureTypeIdentifier";
  }
  CFBundleRef v9 = @"CTFeatureOpenTypeValue";
  if (v6 == TypeID) {
    CFBundleRef v9 = @"CTFeatureSelectorIdentifier";
  }
  keys[0] = v8;
  keys[1] = v9;
  values[0] = (void *)cf;
  values[1] = a3;
  CFDictionaryRef v10 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)keys, (const void **)values, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  TCFRef<__CTFont const*>::Retain((atomic_ullong *)this, v10);
}

const void *TFontFeatureSettingList::GetAATSettingOfType(TFontFeatureSettingList *this, unsigned int a2)
{
  CFArrayRef v2 = (char **)*((void *)this + 2);
  if (!v2) {
    return 0;
  }
  CFArrayRef v3 = (char **)((char *)this + 16);
  do
  {
    unsigned int v4 = *((unsigned __int16 *)v2 + 16);
    BOOL v5 = v4 >= a2;
    if (v4 >= a2) {
      CFTypeID v6 = v2;
    }
    else {
      CFTypeID v6 = v2 + 1;
    }
    if (v5) {
      CFArrayRef v3 = v2;
    }
    CFArrayRef v2 = (char **)*v6;
  }
  while (*v6);
  if (v3 == (char **)((char *)this + 16)) {
    return 0;
  }
  if (*((unsigned __int16 *)v3 + 16) > a2) {
    return 0;
  }
  CFIndex v7 = (CFIndex)v3[6];
  if (v7 == -1) {
    return 0;
  }
  else {
    return CFArrayGetValueAtIndex((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)this, memory_order_acquire), v7);
  }
}

void TFontFeatureSettingList::IndexesOfAATSetting(TFontFeatureSettingList *this@<X0>, unsigned __int16 a2@<W1>, int a3@<W2>, char **a4@<X8>)
{
  unsigned __int16 v24 = a2;
  a4[2] = 0;
  CFTypeID v6 = a4 + 2;
  *a4 = 0;
  a4[1] = 0;
  CFIndex v7 = std::__tree<std::__value_type<unsigned short,AATFeaturePair>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,AATFeaturePair>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,AATFeaturePair>>>::__equal_range_multi<unsigned short>((uint64_t)this + 8, &v24);
  if (v7 != v8)
  {
    CFBundleRef v9 = v7;
    CFDictionaryRef v10 = v8;
    id v11 = 0;
    do
    {
      if (*((unsigned __int16 *)v9 + 20) == a3)
      {
        if ((unint64_t)v11 >= *v6)
        {
          CFIndex v13 = *a4;
          uint64_t v14 = (v11 - *a4) >> 3;
          unint64_t v15 = v14 + 1;
          if ((unint64_t)(v14 + 1) >> 61) {
            abort();
          }
          uint64_t v16 = *v6 - (void)v13;
          if (v16 >> 2 > v15) {
            unint64_t v15 = v16 >> 2;
          }
          if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v17 = v15;
          }
          if (v17)
          {
            CFArrayRef v18 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<long>>((uint64_t)v6, v17);
            CFIndex v13 = *a4;
            id v11 = a4[1];
          }
          else
          {
            CFArrayRef v18 = 0;
          }
          uint64_t v19 = &v18[8 * v14];
          *(void *)uint64_t v19 = v9[6];
          CFIndex v12 = v19 + 8;
          while (v11 != v13)
          {
            uint64_t v20 = *((void *)v11 - 1);
            v11 -= 8;
            *((void *)v19 - 1) = v20;
            v19 -= 8;
          }
          *a4 = v19;
          a4[1] = v12;
          a4[2] = &v18[8 * v17];
          if (v13) {
            operator delete(v13);
          }
        }
        else
        {
          *(void *)id v11 = v9[6];
          CFIndex v12 = v11 + 8;
        }
        a4[1] = v12;
        id v11 = v12;
      }
      CFIndex v21 = (uint64_t *)v9[1];
      if (v21)
      {
        do
        {
          CFDictionaryRef v22 = v21;
          CFIndex v21 = (uint64_t *)*v21;
        }
        while (v21);
      }
      else
      {
        do
        {
          CFDictionaryRef v22 = (uint64_t *)v9[2];
          BOOL v23 = *v22 == (void)v9;
          CFBundleRef v9 = v22;
        }
        while (!v23);
      }
      CFBundleRef v9 = v22;
    }
    while (v22 != v10);
  }
}

void ReplaceNameIDKeyWithLocalizedName(const __CFDictionary *a1, const void *a2, const void *a3, uint64_t a4, const __CFString *a5)
{
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a1, a2);
  if (Value)
  {
    int valuePtr = -1431655766;
    CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
    id v11 = (id)0xAAAAAAAAAAAAAAAALL;
    CopyLocalizedFontNameInternal(0, 0, a4, valuePtr, 0, a5, (atomic_ullong *)&v11);
    if (atomic_load_explicit((atomic_ullong *volatile)&v11, memory_order_acquire)) {
      CFDictionarySetValue(a1, a3, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v11, memory_order_acquire));
    }

    CFDictionaryRemoveValue(a1, a2);
  }
}

void *std::__hash_table<std::__hash_value_type<unsigned short,unsigned short>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,unsigned short>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,unsigned short>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,unsigned short>>>::clear(void *result)
{
  if (result[3])
  {
    unint64_t v1 = result;
    CFArrayRef result = (void *)result[2];
    if (result)
    {
      do
      {
        CFArrayRef v2 = (void *)*result;
        operator delete(result);
        CFArrayRef result = v2;
      }
      while (v2);
    }
    v1[2] = 0;
    uint64_t v3 = v1[1];
    if (v3)
    {
      for (uint64_t i = 0; i != v3; ++i)
        *(void *)(*v1 + 8 * i) = 0;
    }
    v1[3] = 0;
  }
  return result;
}

__CFData *LKTAddRange(__CFData *result, unsigned int a2, unsigned int a3, __int16 a4)
{
  if (result)
  {
    CFIndex v7 = result;
    if (*((_DWORD *)CFDataGetMutableBytePtr(result) + 2) <= a2 || *((_DWORD *)CFDataGetMutableBytePtr(v7) + 2) <= a3)
    {
      return 0;
    }
    else
    {
      if (a2 <= a3)
      {
        uint64_t v8 = a2;
        do
        {
          *(_WORD *)&CFDataGetMutableBytePtr(v7)[2 * v8 + 18] = a4;
          *(unsigned char *)(*(void *)CFDataGetMutableBytePtr(v7) + v8++) = 1;
        }
        while (a3 + 1 != v8);
      }
      if (*((unsigned __int16 *)CFDataGetMutableBytePtr(v7) + 7) > a2) {
        *((_WORD *)CFDataGetMutableBytePtr(v7) + 7) = a2;
      }
      if (*((unsigned __int16 *)CFDataGetMutableBytePtr(v7) + 8) < a3) {
        *((_WORD *)CFDataGetMutableBytePtr(v7) + 8) = a3;
      }
      return (__CFData *)1;
    }
  }
  return result;
}

void LKTCreateLookupTable(__CFData *a1@<X0>, atomic_ullong *a2@<X8>)
{
  uint64_t v68 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
LABEL_50:
    *a2 = 0;
    return;
  }
  if (*((__int16 *)CFDataGetMutableBytePtr(a1) + 7) == -1 && !*((_WORD *)CFDataGetMutableBytePtr(a1) + 8))
  {
    if (CFDataGetMutableBytePtr(a1) && *(void *)CFDataGetMutableBytePtr(a1))
    {
      *(void *)&long long v54 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v54 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long v66 = v54;
      long long v65 = v54;
      long long v64 = v54;
      long long v63 = v54;
      memset(v62, 0, sizeof(v62));
      id v67 = &v63;
      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::reserve(v62, 3uLL);
      Append2_BE((uint64_t)v62, 8u);
      MutableBytePtr = CFDataGetMutableBytePtr(a1);
      Append2_BE((uint64_t)v62, *((unsigned __int16 *)MutableBytePtr + 7));
      Append2_BE((uint64_t)v62, 0);
      *a2 = (atomic_ullong)CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)v62[0], v62[1] - v62[0]);
      v59[0] = (void **)v62;
      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100](v59);
      return;
    }
    goto LABEL_50;
  }
  if (CFDataGetMutableBytePtr(a1))
  {
    memset(v62, 170, sizeof(v62));
    FindTightRanges(v62, a1, 1);
    unint64_t v4 = 6 * ((v62[1] - v62[0]) >> 2) + 18;
    if (v62[0]) {
      operator delete(v62[0]);
    }
  }
  else
  {
    unint64_t v4 = 0;
  }
  if (CFDataGetMutableBytePtr(a1))
  {
    memset(v62, 170, sizeof(v62));
    FindTightRanges(v62, a1, 0);
    unint64_t v5 = 6 * ((v62[1] - v62[0]) >> 2) + 18;
    if (v62[1] != v62[0])
    {
      CFTypeID v6 = v62[0];
      do
      {
        int v7 = *((unsigned __int16 *)v6 + 1);
        int v8 = *(unsigned __int16 *)v6;
        v6 += 4;
        v5 += (2 * (v7 - v8) + 2);
      }
      while (v6 != v62[1]);
    }
    if (v62[0]) {
      operator delete(v62[0]);
    }
    if (v5 < v4)
    {
      int v9 = 4;
    }
    else
    {
      unint64_t v5 = v4;
      int v9 = 2;
    }
  }
  else
  {
    unint64_t v5 = 0;
    if (v4) {
      int v9 = 4;
    }
    else {
      int v9 = 2;
    }
  }
  if (CFDataGetMutableBytePtr(a1))
  {
    int v10 = *((unsigned __int16 *)CFDataGetMutableBytePtr(a1) + 8);
    unint64_t v11 = ((2 * (v10 - *((unsigned __int16 *)CFDataGetMutableBytePtr(a1) + 7)) + 2) & 0x1FFFFFFFELL) + 6;
  }
  else
  {
    unint64_t v11 = 0;
  }
  if (v11 >= v5) {
    int v12 = v9;
  }
  else {
    int v12 = 8;
  }
  *a2 = 0;
  if (v12 == 8)
  {
    if (CFDataGetMutableBytePtr(a1))
    {
      int v27 = *((unsigned __int16 *)CFDataGetMutableBytePtr(a1) + 8);
      int v28 = v27 - *((unsigned __int16 *)CFDataGetMutableBytePtr(a1) + 7);
      *(void *)&long long v29 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v29 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long v66 = v29;
      int v30 = v28 + 1;
      LOBYTE(v27) = v28 == -1;
      long long v65 = v29;
      long long v64 = v29;
      long long v63 = v29;
      memset(v62, 0, sizeof(v62));
      id v67 = &v63;
      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::reserve(v62, (v28 + 4) & 0x7FFFFFFF);
      Append2_BE((uint64_t)v62, 8u);
      CFArrayRef v31 = CFDataGetMutableBytePtr(a1);
      Append2_BE((uint64_t)v62, *((unsigned __int16 *)v31 + 7));
      Append2_BE((uint64_t)v62, (unsigned __int16)v30);
      if ((v27 & 1) == 0)
      {
        int v32 = 0;
        do
        {
          CFDictionaryRef v33 = CFDataGetMutableBytePtr(a1);
          unint64_t v34 = CFDataGetMutableBytePtr(a1);
          Append2_BE((uint64_t)v62, *(unsigned __int16 *)&v33[2 * v32++ + 18 + 2 * *((unsigned __int16 *)v34 + 7)]);
        }
        while (v30 != v32);
      }
      v57[0] = (atomic_ullong)CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)v62[0], v62[1] - v62[0]);
      v59[0] = (void **)v62;
      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100](v59);
    }
    else
    {
      v57[0] = 0;
    }

    BOOL v26 = (void **)v57[0];
  }
  else if (v12 == 4)
  {
    if (CFDataGetMutableBytePtr(a1))
    {
      memset(v57, 170, sizeof(v57));
      FindTightRanges((char **)v57, a1, 0);
      int v35 = (unsigned __int16 *)v57[0];
      atomic_ullong v36 = v57[1];
      unint64_t v37 = (unint64_t)(v57[1] - v57[0]) >> 2;
      unsigned int v38 = (unsigned __int16)v37;
      __int16 v39 = __clz((unsigned __int16)v37);
      unsigned __int16 v40 = 31 - v39;
      LOBYTE(v39) = ~(_BYTE)v39;
      int v41 = 6 << v39;
      int v42 = 3 * ((-1 << v39) + v37);
      *(void *)&long long v43 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v43 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long v66 = v43;
      long long v65 = v43;
      unsigned int v44 = 6 * v37 + 18;
      long long v64 = v43;
      long long v63 = v43;
      memset(v62, 0, sizeof(v62));
      id v67 = &v63;
      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::reserve(v62, v44 >> 1);
      *(void *)&long long v45 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v45 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v60[3] = v45;
      void v60[2] = v45;
      v60[1] = v45;
      v60[0] = v45;
      memset(v59, 0, sizeof(v59));
      CFArrayRef v61 = v60;
      Append2_BE((uint64_t)v62, 4u);
      Append2_BE((uint64_t)v62, 6u);
      Append2_BE((uint64_t)v62, v38);
      Append2_BE((uint64_t)v62, v41 & 0xFFFE);
      Append2_BE((uint64_t)v62, v40);
      Append2_BE((uint64_t)v62, 2 * (v42 & 0x7FFF));
      if ((unsigned __int16 *)v36 != v35)
      {
        id v46 = v35;
        do
        {
          unsigned int v47 = v46[1];
          unsigned int v48 = v47 - *v46 + 1;
          Append2_BE((uint64_t)v62, v47);
          Append2_BE((uint64_t)v62, *v46);
          Append2_BE((uint64_t)v62, (unsigned __int16)v44);
          CFRange v49 = CFDataGetMutableBytePtr(a1);
          if (v48)
          {
            CFArrayRef v50 = &v49[2 * *v46 + 18];
            uint64_t v51 = 2 * v48;
            do
            {
              unsigned int v52 = *(unsigned __int16 *)v50;
              v50 += 2;
              Append2_BE((uint64_t)v59, v52);
              v51 -= 2;
            }
            while (v51);
          }
          LOWORD(v44) = v44 + 2 * v48;
          v46 += 2;
        }
        while (v46 != (unsigned __int16 *)v36);
      }
      Append2_BE((uint64_t)v62, 0xFFFFu);
      Append2_BE((uint64_t)v62, 0xFFFFu);
      unsigned int v53 = CFDataGetMutableBytePtr(a1);
      Append2_BE((uint64_t)v62, *((unsigned __int16 *)v53 + 6));
      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__insert_with_size[abi:nn180100]<std::__wrap_iter<unsigned short *>,std::__wrap_iter<unsigned short *>>((uint64_t)v62, (uint64_t)v62[1], (char *)v59[0], (char *)v59[1], ((char *)v59[1] - (char *)v59[0]) >> 1);
      id v56 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)v62[0], v62[1] - v62[0]);
      uint64_t v58 = (void **)v59;
      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100](&v58);
      v59[0] = (void **)v62;
      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100](v59);
      if (v35)
      {
        v57[1] = (atomic_ullong)v35;
        operator delete(v35);
      }
    }
    else
    {
      id v56 = 0;
    }

    BOOL v26 = (void **)v56;
  }
  else
  {
    if (CFDataGetMutableBytePtr(a1))
    {
      memset(v59, 170, sizeof(v59));
      FindTightRanges((char **)v59, a1, 1);
      CFIndex v13 = v59[0];
      uint64_t v14 = v59[1];
      unint64_t v15 = (unint64_t)((char *)v59[1] - (char *)v59[0]) >> 2;
      unsigned int v16 = (unsigned __int16)v15;
      __int16 v17 = __clz((unsigned __int16)v15);
      unsigned __int16 v18 = 31 - v17;
      LOBYTE(v17) = ~(_BYTE)v17;
      int v19 = 6 << v17;
      int v20 = 3 * ((-1 << v17) + v15);
      *(void *)&long long v21 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v21 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long v66 = v21;
      long long v65 = v21;
      long long v64 = v21;
      long long v63 = v21;
      memset(v62, 0, sizeof(v62));
      id v67 = &v63;
      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::reserve(v62, (6 * v15 + 18) >> 1);
      Append2_BE((uint64_t)v62, 2u);
      Append2_BE((uint64_t)v62, 6u);
      Append2_BE((uint64_t)v62, v16);
      Append2_BE((uint64_t)v62, v19 & 0xFFFE);
      Append2_BE((uint64_t)v62, v18);
      Append2_BE((uint64_t)v62, 2 * (v20 & 0x7FFF));
      if (v14 != v13)
      {
        CFDictionaryRef v22 = v13;
        do
        {
          Append2_BE((uint64_t)v62, *((unsigned __int16 *)v22 + 1));
          Append2_BE((uint64_t)v62, *(unsigned __int16 *)v22);
          BOOL v23 = CFDataGetMutableBytePtr(a1);
          int v24 = *(unsigned __int16 *)v22;
          CFDictionaryRef v22 = (void **)((char *)v22 + 4);
          Append2_BE((uint64_t)v62, *(unsigned __int16 *)&v23[2 * v24 + 18]);
        }
        while (v22 != v14);
      }
      Append2_BE((uint64_t)v62, 0xFFFFu);
      Append2_BE((uint64_t)v62, 0xFFFFu);
      uint64_t v25 = CFDataGetMutableBytePtr(a1);
      Append2_BE((uint64_t)v62, *((unsigned __int16 *)v25 + 6));
      uint64_t v58 = (void **)CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)v62[0], v62[1] - v62[0]);
      v57[0] = (atomic_ullong)v62;
      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v57);
      if (v13) {
        operator delete(v13);
      }
    }
    else
    {
      uint64_t v58 = 0;
    }

    BOOL v26 = v58;
  }
}

uint64_t LKTGetValue(__CFData *a1, unsigned int a2)
{
  if (!a1)
  {
    unsigned int v5 = 0;
    int v6 = 0;
    return v6 | v5;
  }
  if (*((_DWORD *)CFDataGetMutableBytePtr(a1) + 2) <= a2)
  {
    unsigned int v5 = 0;
    goto LABEL_7;
  }
  MutableBytePtr = CFDataGetMutableBytePtr(a1);
  unsigned int v5 = *(unsigned __int8 *)(*(void *)MutableBytePtr + a2);
  if (!*(unsigned char *)(*(void *)MutableBytePtr + a2))
  {
LABEL_7:
    int v6 = 0;
    return v6 | v5;
  }
  unsigned int v5 = *(unsigned __int16 *)&CFDataGetMutableBytePtr(a1)[2 * a2 + 18];
  int v6 = 0x10000;
  return v6 | v5;
}

__CFData *NewLKTHandle(int64_t a1, __int16 a2)
{
  CFIndex v4 = 2 * a1 + 18;
  id Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v4);
  int v6 = Mutable;
  if (Mutable)
  {
    CFDataSetLength(Mutable, v4);
    int v7 = malloc_type_calloc(a1, 1uLL, 0xEDF80FDDuLL);
    if (v7)
    {
      *(void *)CFDataGetMutableBytePtr(v6) = v7;
      *((_DWORD *)CFDataGetMutableBytePtr(v6) + 2) = a1;
      *((_WORD *)CFDataGetMutableBytePtr(v6) + 6) = a2;
      *((_WORD *)CFDataGetMutableBytePtr(v6) + 7) = -1;
      *((_WORD *)CFDataGetMutableBytePtr(v6) + 8) = 0;
      MutableBytePtr = CFDataGetMutableBytePtr(v6);
      if (a1 >= 1)
      {
        int v9 = MutableBytePtr + 18;
        unint64_t v10 = a1 + 1;
        do
        {
          *v9++ = a2;
          --v10;
        }
        while (v10 > 1);
      }
    }
    else
    {
      CFRelease(v6);
      return 0;
    }
  }
  return v6;
}

void DisposeLKTHandle(__CFData *a1)
{
  if (a1)
  {
    MutableBytePtr = (void **)CFDataGetMutableBytePtr(a1);
    free(*MutableBytePtr);
    CFRelease(a1);
  }
}

uint64_t Append2_BE(uint64_t result, unsigned int a2)
{
  CFArrayRef v2 = (void *)result;
  __int16 v3 = __rev16(a2);
  CFIndex v4 = *(_WORD **)(result + 8);
  unint64_t v5 = *(void *)(result + 16);
  if ((unint64_t)v4 >= v5)
  {
    uint64_t v7 = result + 24;
    int v8 = (_WORD *)*v2;
    uint64_t v9 = (uint64_t)v4 - *v2;
    if (v9 <= -3) {
      abort();
    }
    uint64_t v10 = v9 >> 1;
    unint64_t v11 = v5 - (void)v8;
    if (v11 <= (v9 >> 1) + 1) {
      unint64_t v12 = v10 + 1;
    }
    else {
      unint64_t v12 = v11;
    }
    if (v11 >= 0x7FFFFFFFFFFFFFFELL) {
      uint64_t v13 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v13 = v12;
    }
    void v20[4] = v2 + 3;
    if (v13)
    {
      uint64_t v14 = (char *)TInlineBufferAllocator<unsigned short,30ul>::allocate(v7, v13);
      int v8 = (_WORD *)*v2;
      CFIndex v4 = (_WORD *)v2[1];
    }
    else
    {
      uint64_t v14 = 0;
    }
    unint64_t v15 = &v14[2 * v10];
    *(_WORD *)unint64_t v15 = v3;
    if (v4 == v8)
    {
      __int16 v17 = &v14[2 * v10];
    }
    else
    {
      unsigned int v16 = v4;
      __int16 v17 = &v14[2 * v10];
      do
      {
        __int16 v18 = *--v16;
        *((_WORD *)v17 - 1) = v18;
        v17 -= 2;
      }
      while (v16 != v8);
    }
    int v6 = v15 + 2;
    *CFArrayRef v2 = v17;
    v2[1] = v15 + 2;
    uint64_t v19 = v2[2];
    v2[2] = &v14[2 * v13];
    _OWORD v20[2] = v4;
    double v20[3] = v19;
    v20[0] = v8;
    v20[1] = v8;
    CFArrayRef result = std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,30ul> &>::~__split_buffer((uint64_t)v20);
  }
  else
  {
    *CFIndex v4 = v3;
    int v6 = v4 + 1;
  }
  v2[1] = v6;
  return result;
}

void FindTightRanges(char **a1, CFMutableDataRef theData, uint64_t a3)
{
  unint64_t v5 = a1;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unsigned int v6 = *((unsigned __int16 *)CFDataGetMutableBytePtr(theData) + 7);
  uint64_t v7 = *((unsigned __int16 *)CFDataGetMutableBytePtr(theData) + 8);
  if (v6 <= v7)
  {
    int v8 = 0;
    int v32 = v7 + 1;
    uint64_t v9 = v7 + 1;
    int v35 = v5;
    uint64_t v33 = -(uint64_t)v7;
    uint64_t v34 = v7 + 1;
    do
    {
      MutableBytePtr = CFDataGetMutableBytePtr(theData);
      uint64_t v11 = v6;
      LODWORD(v12) = v6 + 1;
      if (a3)
      {
        if (v6 < v7)
        {
          uint64_t v13 = v5;
          int v14 = *(unsigned __int16 *)&MutableBytePtr[2 * v6 + 18];
          __int16 v15 = v11;
          uint64_t v16 = v11;
          while (*(unsigned char *)(*(void *)CFDataGetMutableBytePtr(theData) + v16 + 1)
               && *(unsigned __int16 *)&CFDataGetMutableBytePtr(theData)[2 * v16 + 20] == v14)
          {
            if (v7 == ++v16)
            {
              LODWORD(v12) = v32;
              goto LABEL_17;
            }
          }
          LODWORD(v12) = v16 + 1;
LABEL_17:
          unint64_t v5 = v13;
          LOWORD(v11) = v15;
        }
      }
      else if (v6 < v7)
      {
        uint64_t v12 = v6 + 1;
        while (*(unsigned char *)(*(void *)CFDataGetMutableBytePtr(theData) + v12))
        {
          ++v12;
          if (v33 + v12 == 1)
          {
            LODWORD(v12) = v32;
            break;
          }
        }
        LOWORD(v11) = v6;
      }
      __int16 v17 = v12 - 1;
      unint64_t v18 = (unint64_t)v5[2];
      if ((unint64_t)v8 >= v18)
      {
        uint64_t v19 = a3;
        int v20 = *v5;
        uint64_t v21 = (v8 - *v5) >> 2;
        unint64_t v22 = v21 + 1;
        if ((unint64_t)(v21 + 1) >> 62) {
          abort();
        }
        uint64_t v23 = v18 - (void)v20;
        if (v23 >> 1 > v22) {
          unint64_t v22 = v23 >> 1;
        }
        if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v24 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v24 = v22;
        }
        if (v24 >> 62) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        uint64_t v25 = v7;
        __int16 v26 = v11;
        int v27 = (char *)operator new(4 * v24);
        int v28 = &v27[4 * v21];
        *(_WORD *)int v28 = v26;
        *((_WORD *)v28 + 1) = v17;
        if (v8 == v20)
        {
          int v20 = v8;
          long long v29 = &v27[4 * v21];
          a3 = v19;
          uint64_t v7 = v25;
        }
        else
        {
          long long v29 = &v27[4 * v21];
          a3 = v19;
          uint64_t v7 = v25;
          do
          {
            int v30 = *((_DWORD *)v8 - 1);
            v8 -= 4;
            *((_DWORD *)v29 - 1) = v30;
            v29 -= 4;
          }
          while (v8 != v20);
        }
        CFArrayRef v31 = &v27[4 * v24];
        int v8 = v28 + 4;
        uint64_t v9 = v34;
        unint64_t v5 = v35;
        *int v35 = v29;
        v35[1] = v28 + 4;
        v35[2] = v31;
        if (v20) {
          operator delete(v20);
        }
      }
      else
      {
        *(_WORD *)int v8 = v11;
        *((_WORD *)v8 + 1) = v17;
        v8 += 4;
      }
      v5[1] = v8;
      if (v12 <= v7)
      {
        uint64_t v12 = v12;
        while (!*(unsigned char *)(*(void *)CFDataGetMutableBytePtr(theData) + v12))
        {
          if (v9 == ++v12) {
            return;
          }
        }
      }
      unsigned int v6 = v12;
    }
    while (v12 <= v7);
  }
}

char *std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__insert_with_size[abi:nn180100]<std::__wrap_iter<unsigned short *>,std::__wrap_iter<unsigned short *>>(uint64_t a1, uint64_t __dst, char *__src, char *a4, uint64_t a5)
{
  unint64_t v5 = (char *)__dst;
  if (a5 < 1) {
    return v5;
  }
  uint64_t v7 = __src;
  unint64_t v10 = *(void *)(a1 + 8);
  uint64_t v9 = *(void *)(a1 + 16);
  if (a5 > (uint64_t)(v9 - v10) >> 1)
  {
    uint64_t v11 = *(void **)a1;
    uint64_t v12 = a5 + ((uint64_t)(v10 - *(void *)a1) >> 1);
    if (v12 < 0) {
      abort();
    }
    uint64_t v13 = (__dst - (uint64_t)v11) >> 1;
    uint64_t v14 = a1 + 24;
    unint64_t v15 = v9 - (void)v11;
    if (v15 <= v12) {
      uint64_t v16 = v12;
    }
    else {
      uint64_t v16 = v15;
    }
    if (v15 >= 0x7FFFFFFFFFFFFFFELL) {
      uint64_t v17 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v17 = v16;
    }
    v33[4] = a1 + 24;
    if (v17) {
      unint64_t v18 = (char *)TInlineBufferAllocator<unsigned short,30ul>::allocate(v14, v17);
    }
    else {
      unint64_t v18 = 0;
    }
    int v28 = &v18[2 * v13];
    v33[0] = v18;
    v33[1] = v28;
    void v33[3] = &v18[2 * v17];
    uint64_t v29 = 2 * a5;
    int v30 = &v28[2 * a5];
    do
    {
      __int16 v31 = *(_WORD *)v7;
      v7 += 2;
      *(_WORD *)int v28 = v31;
      v28 += 2;
      v29 -= 2;
    }
    while (v29);
    v33[2] = v30;
    unint64_t v5 = std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__swap_out_circular_buffer((void **)a1, (uint64_t)v33, v5);
    std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,30ul> &>::~__split_buffer((uint64_t)v33);
    return v5;
  }
  uint64_t v19 = v10 - __dst;
  uint64_t v20 = (uint64_t)(v10 - __dst) >> 1;
  if (v20 >= a5)
  {
    uint64_t v21 = &__src[2 * a5];
    uint64_t v23 = *(char **)(a1 + 8);
LABEL_18:
    unint64_t v24 = &v5[2 * a5];
    uint64_t v25 = &v23[-2 * a5];
    __int16 v26 = v23;
    if ((unint64_t)v25 < v10)
    {
      __int16 v26 = v23;
      do
      {
        __int16 v27 = *(_WORD *)v25;
        v25 += 2;
        *(_WORD *)__int16 v26 = v27;
        v26 += 2;
      }
      while ((unint64_t)v25 < v10);
    }
    *(void *)(a1 + 8) = v26;
    if (v23 != v24) {
      memmove(&v23[-2 * ((v23 - v24) >> 1)], v5, v23 - v24);
    }
    if (v21 != v7) {
      memmove(v5, v7, v21 - v7);
    }
    return v5;
  }
  uint64_t v21 = &__src[2 * v20];
  int64_t v22 = a4 - v21;
  if (a4 != v21) {
    memmove(*(void **)(a1 + 8), &__src[2 * v20], a4 - v21);
  }
  uint64_t v23 = (char *)(v10 + v22);
  *(void *)(a1 + 8) = v10 + v22;
  if (v19 >= 1) {
    goto LABEL_18;
  }
  return v5;
}

const void *TRunEncoder::EncodeWithLineOptions(uint64_t *a1, atomic_ullong *a2, unsigned int a3)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  v35[5] = unk_184B8A5EC;
  long long v38 = unk_184B8A600;
  memset(v28, 170, sizeof(v28));
  long long v26 = 0u;
  int64x2_t v25 = 0u;
  uint64_t v27 = 0;
  uint64_t v29 = v28;
  BYTE8(v38) = 0;
  uint64_t v33 = 0;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  memset(v35, 0, 20);
  uint64_t v36 = 0;
  uint64_t v37 = 0;
  LOBYTE(v38) = 0;
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  uint64_t v39 = 0;
  unint64_t v34 = 0xFFEFFFFFFFFFFFFFLL;
  v16[0] = (id)atomic_load_explicit(a2, memory_order_acquire);
  TLine::AppendRun(&v25, (atomic_ullong *)v16);

  if ((a3 & 4) != 0) {
    TAttributes::SetRareAttributes((TAttributes *)(*(void *)(atomic_load_explicit(a2, memory_order_acquire) + 48) + 40), 4);
  }
  uint64_t v6 = *(void *)(atomic_load_explicit(a2, memory_order_acquire) + 40);
  int v8 = *(void **)(v6 + 8);
  uint64_t v7 = *(void **)(v6 + 16);
  *(void *)&long long v30 = v8;
  *((void *)&v30 + 1) = v7;
  if ((a3 & 1) != 0 && TTypesetter::CanLayout((TTypesetter *)((a3 >> 6) & 1), (uint64_t)v7))
  {
    uint64_t v23 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v24 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v10 = (uint64_t (*)(void *, void *, uint64_t))a1[1];
    uint64_t v9 = a1[2];
    v22[0] = &unk_1ED05F2C8;
    v22[1] = v8;
    LOWORD(v24) = 0;
    uint64_t v23 = v10(v8, v7, v9);
    uint64_t v11 = *a1;
    uint64_t v12 = a1[2];
    id v18 = 0;
    uint64_t v19 = v11;
    uint64_t v20 = 0;
    uint64_t v21 = v12;
    v16[0] = &unk_1ED05F1A8;
    v16[1] = v8;
    void v16[3] = 0;
    id v17 = 0;
    void v16[2] = v7;
    v15[0] = v22;
    v15[1] = v16;
    TBidiEngine::ReorderGlyphs((uint64_t)v15, (TLine *)&v25);
    v16[0] = &unk_1ED05E8F8;
  }
  if ((uint64_t)(*((void *)&v26 + 1) - v26) < 9) {
    RunCFArraCGFloat y = *(const void **)v26;
  }
  else {
    RunCFArraCGFloat y = (const void *)TLine::GetRunCFArray((const void ***)&v25);
  }
  CFRetain(RunCFArray);
  TLine::~TLine((TLine *)&v25);
  return RunCFArray;
}

void TTypesetter::RelayoutRunUsingCallback(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  CFStringRef explicit = (const __CFString *)atomic_load_explicit((atomic_ullong *volatile)(*(void *)(a1 + 8) + 32), memory_order_acquire);
  id v16 = (id)(*(uint64_t (**)(uint64_t, const __CFString *, void))(a1 + 16))(a2, explicit, *(void *)(a1 + 24));
  if (atomic_load_explicit((atomic_ullong *volatile)&v16, memory_order_acquire))
  {
    v20[0] = xmmword_184B8A6A8;
    memset(&v20[1], 170, 32);
    long long v21 = unk_184B8A6D8;
    *(_OWORD *)&v19[96] = xmmword_184B8A688;
    *(_OWORD *)&v19[112] = unk_184B8A698;
    memset(v19, 170, 96);
    uint64_t v9 = operator new(0x48uLL);
    v9[1] = 0;
    v9[2] = 0;
    *uint64_t v9 = &unk_1ED062278;
    TCharStreamCFString::TCharStreamCFString((TCharStreamCFString *)(v9 + 3), explicit, 0);
    *(void *)uint64_t v19 = v10;
    *(void *)&v19[8] = v9;
    memset(&v19[16], 0, 24);
    *(void *)&v19[64] = &v19[40];
    BYTE8(v21) = 0;
    memset(&v19[72], 0, 56);
    *(_OWORD *)((char *)v20 + 8) = 0u;
    *(void *)((char *)&v20[1] + 5) = 0;
    _OWORD v20[2] = 0uLL;
    LOBYTE(v21) = 0;
    uint64_t v23 = 0;
    uint64_t v24 = 0;
    uint64_t v22 = 0;
    *(void *)&v20[0] = 0xFFEFFFFFFFFFFFFFLL;
    CFTypeID v11 = CFGetTypeID((CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)&v16, memory_order_acquire));
    if (v11 == CFArrayGetTypeID())
    {
      TLine::SetRunArray((int64x2_t *)v19, (CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v16, memory_order_acquire));
    }
    else
    {
      __dst[0] = (id)atomic_exchange((atomic_ullong *volatile)&v16, 0);
      TLine::AppendRun((int64x2_t *)v19, (atomic_ullong *)__dst);

      *(_OWORD *)&v19[72] = *(_OWORD *)(*(void *)(a2 + 40) + 8);
    }
    memcpy(__dst, &unk_184B8A700, sizeof(__dst));
    TRunGlue::TRunGlue((TRunGlue *)__dst, (TLine *)v19);
    LOBYTE(v17) = 0;
    char v15 = 0;
    if (TTypesetter::DoAttachments(a1, (void ***)__dst, &v17, &v15))
    {
      char v13 = TShapingEngine::ShapeGlyphs((TShapingEngine *)__dst, *(TRunGlue **)(a1 + 8), v12);
      char v14 = v15 | v13;
    }
    else
    {
      char v14 = v15;
    }
    TTypesetter::FinishLayout(a1, (TCompositionEngine **)__dst, (const TCharStream *)(char)v17, v14);
    DoGlyphFixupsCheck(v19);
    if (*(void *)&v19[24] != *(void *)&v19[16]) {
      TLine::ReplaceRun(a3, a4, (uint64_t)v19);
    }
    std::__function::__value_func<BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::~__value_func[abi:nn180100](&__dst[70]);
    id v17 = &__dst[46];
    std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100](&v17);
    id v17 = &__dst[26];
    std::vector<unsigned char,TInlineBufferAllocator<unsigned char,128ul>>::__destroy_vector::operator()[abi:nn180100](&v17);
    id v17 = &__dst[7];
    std::vector<std::pair<UScriptCode,long>,TInlineBufferAllocator<std::pair<UScriptCode,long>,1ul>>::__destroy_vector::operator()[abi:nn180100](&v17);
    TLine::~TLine((TLine *)v19);
  }
}

void TTraitsValues::TTraitsValues(TTraitsValues *this, CFDictionaryRef theDict)
{
  this->var0 = 0;
  this->vaCGFloat r1 = 0.0;
  p_vaCGFloat r1 = &this->var1;
  this->vaCGRect r2 = 0.0;
  this->var3 = 0.0;
  if (theDict)
  {
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, @"NSCTFontWeightTrait");
    if (Value) {
      CFNumberGetValue(Value, kCFNumberDoubleType, p_var1);
    }
    CFNumberRef v6 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"NSCTFontProportionTrait");
    if (v6) {
      CFNumberGetValue(v6, kCFNumberDoubleType, &this->var2);
    }
    CFNumberRef v7 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"NSCTFontSlantTrait");
    if (v7) {
      CFNumberGetValue(v7, kCFNumberDoubleType, &this->var3);
    }
  }
}