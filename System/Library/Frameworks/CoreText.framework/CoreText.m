unint64_t CTFontGetClientObject(unint64_t result)
{
  if (result) {
    return atomic_load_explicit((atomic_ullong *volatile)(*(void *)(result + 40) + 528), memory_order_acquire);
  }
  return result;
}

uint64_t _s18AdaptiveImageGlyphVwet(uint64_t a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *(unsigned char *)(a1 + 48)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 24);
  if (v2 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

ValueMetadata *type metadata accessor for AttributedString.AdaptiveImageGlyph()
{
  return &type metadata for AttributedString.AdaptiveImageGlyph;
}

double CTFontDescriptorGetTextStyleSize(TDescriptorSource *a1, __CFString *a2, uint64_t *a3, const __CFString **a4, double *a5)
{
  return TDescriptorSource::GetTextStyleSize(a1, a2, a3, a4, a5, 0, 0);
}

id TTypesetterAttrString::Initialize(TTypesetterAttrString *this, const __CFAttributedString *a2, char a3)
{
  v4 = this;
  __dst[82] = *(id *)MEMORY[0x1E4F143B8];
  CFIndex v5 = *(void *)(*((void *)this + 27) + 16);
  id result = +[_CTNativeGlyphStorage newWithCount:v5 capacity:v5];
  if (result)
  {
    id v7 = result;
    char v85 = 0;
    memset(v83, 170, sizeof(v83));
    unint64_t v84 = 0xAAAAAAAAFFFFFFFFLL;
    memset(v79, 170, 32);
    uint64_t v8 = *((void *)v4 + 27);
    *(void *)v79 = result;
    *(void *)&v79[8] = v8;
    memset(&v79[16], 0, 160);
    long long v80 = 0u;
    unint64_t v82 = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v81 = 0;
    *(void *)&long long v80 = *(void *)(v8 + 16);
    unint64_t v82 = (unint64_t)v4;
    memset(v83, 0, sizeof(v83));
    LODWORD(v84) = 1065353216;
    int v9 = ShouldCheckForKnownUrduSequences();
    Table = (void **)GetTable();
    v50 = v7;
    if (Table) {
      v11 = (char *)*Table;
    }
    else {
      v11 = 0;
    }
    v78.CFIndex length = 0;
    v78.CFIndex location = 0;
    if (v5 >= 1)
    {
      CFIndex v12 = 0;
      long long v60 = xmmword_184B89728;
      memset(v59, 170, sizeof(v59));
      long long v57 = unk_184B896F8;
      long long v58 = xmmword_184B896E8;
      long long v55 = unk_184B89718;
      long long v56 = xmmword_184B89708;
      memset(v54, 170, sizeof(v54));
      unint64_t v13 = 0xAAAAAAAAAAAAAA00;
      unint64_t v14 = 0xAAAAAAAAAAAAAA00;
      v49 = v4;
      int v52 = v9;
      do
      {
        effectiveRange.CFIndex length = 0xAAAAAAAAAAAAAAAALL;
        effectiveRange.CFIndex location = 0xAAAAAAAAAAAAAAAALL;
        if ((_BYTE)v13)
        {
          CFIndex location = v78.location;
          CFIndex length = v78.length;
          v78.CFIndex length = 0;
          v78.CFIndex location = 0;
          effectiveRange.CFIndex location = location;
          effectiveRange.CFIndex length = length;
          CFDictionaryRef Attributes = (const __CFDictionary *)v14;
          unint64_t v13 = 0xAAAAAAAAAAAAAA00;
        }
        else
        {
          CFDictionaryRef Attributes = CFAttributedStringGetAttributes(a2, v12, &effectiveRange);
          CFIndex location = effectiveRange.location;
          CFIndex length = effectiveRange.length;
        }
        CFIndex v18 = location + length;
        if (location + length < v5)
        {
          while (1)
          {
            CFDictionaryRef v19 = CFAttributedStringGetAttributes(a2, v18, &v78);
            if (v19 != Attributes) {
              break;
            }
            effectiveRange.length += v78.length;
            CFIndex v18 = effectiveRange.location + effectiveRange.length;
            if (effectiveRange.location + effectiveRange.length >= v5)
            {
              unint64_t v14 = (unint64_t)Attributes;
              goto LABEL_15;
            }
          }
          unint64_t v14 = (unint64_t)v19;
LABEL_15:
          unint64_t v13 = 0xAAAAAAAAAAAAAA01;
        }
        long long v73 = v60;
        long long v74 = v59[2];
        long long v75 = v59[1];
        long long v76 = v59[0];
        long long v69 = v58;
        long long v70 = v57;
        long long v71 = v56;
        long long v72 = v55;
        v68[0] = v54[1];
        v68[1] = v54[0];
        LOBYTE(v68[0]) = 0;
        BYTE8(v76) = 0;
        if (v11
          && Attributes == (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)v11, memory_order_acquire))
        {
          v20 = (TAttributes *)(v11 + 8);
        }
        else
        {
          TAttributes::TAttributes((TAttributes *)__dst, Attributes, *((const TCharStream **)v4 + 27), effectiveRange, 0);
          if (BYTE8(v76))
          {
            TAttributes::operator=((uint64_t)v68, (uint64_t)__dst);
          }
          else
          {
            *(_WORD *)((char *)&v70 + 1) = 0;
            BYTE3(v70) = 0;
            BYTE8(v70) = 0;
            BYTE8(v73) = 0;
            *(void *)&long long v76 = 0;
            memset(v68, 0, sizeof(v68));
            long long v69 = 0u;
            *((void *)&v74 + 1) = 0;
            *(void *)&long long v75 = 0;
            TAttributes::operator=((uint64_t)v68, (uint64_t)__dst);
            BYTE8(v76) = 1;
          }
          TAttributes::~TAttributes((TAttributes *)__dst);
          if (!BYTE8(v76)) {
            std::__throw_bad_optional_access[abi:nn180100]();
          }
          v20 = (TAttributes *)v68;
        }
        unint64_t v61 = v13;
        v62 = v20;
        if (Attributes) {
          int v21 = v9;
        }
        else {
          int v21 = 0;
        }
        if (v21 != 1) {
          goto LABEL_45;
        }
        Value = CFDictionaryGetValue(Attributes, @"NSFont");
        if (!Value) {
          goto LABEL_45;
        }
        v23 = (int *)*((void *)Value + 5);
        if (!v23 || !TFont::IsSystemUIFontAndForShaping(*((atomic_ullong **)Value + 5), (BOOL *)__dst))
        {
          int v9 = v52;
LABEL_45:
          char v42 = TGlyphEncoder::EncodeChars(v79, effectiveRange.location, effectiveRange.length, v62, 0);
          v85 |= v42;
          goto LABEL_46;
        }
        __dst[0] = 0;
        __dst[1] = __dst;
        __dst[2] = (id)0x23012000000;
        __dst[3] = __Block_byref_object_copy_;
        __dst[4] = __Block_byref_object_dispose_;
        memset(&__dst[5], 0, 32);
        *(void *)&long long v24 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v24 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)&__dst[9] = v24;
        *(_OWORD *)&__dst[11] = v24;
        *(_OWORD *)&__dst[13] = v24;
        *(_OWORD *)&__dst[15] = v24;
        *(_OWORD *)&__dst[17] = v24;
        *(_OWORD *)&__dst[19] = v24;
        *(_OWORD *)&__dst[21] = v24;
        *(_OWORD *)&__dst[23] = v24;
        *(_OWORD *)&__dst[25] = v24;
        *(_OWORD *)&__dst[27] = v24;
        *(_OWORD *)&__dst[29] = v24;
        *(_OWORD *)&__dst[31] = v24;
        *(_OWORD *)&__dst[33] = v24;
        *(_OWORD *)&__dst[35] = v24;
        *(_OWORD *)&__dst[37] = v24;
        *(_OWORD *)&__dst[39] = v24;
        *(_OWORD *)&__dst[41] = v24;
        *(_OWORD *)&__dst[43] = v24;
        *(_OWORD *)&__dst[45] = v24;
        *(_OWORD *)&__dst[47] = v24;
        *(_OWORD *)&__dst[49] = v24;
        *(_OWORD *)&__dst[51] = v24;
        *(_OWORD *)&__dst[53] = v24;
        *(_OWORD *)&__dst[55] = v24;
        *(_OWORD *)&__dst[57] = v24;
        *(_OWORD *)&__dst[59] = v24;
        *(_OWORD *)&__dst[61] = v24;
        *(_OWORD *)&__dst[63] = v24;
        *(_OWORD *)&__dst[65] = v24;
        *(_OWORD *)&__dst[67] = v24;
        __dst[69] = &__dst[9];
        CFStringRef String = CFAttributedStringGetString(a2);
        v67[0] = MEMORY[0x1E4F143A8];
        v67[1] = 3221225472;
        v67[2] = ___ZN21TTypesetterAttrString10InitializeEPK20__CFAttributedStringb_block_invoke;
        v67[3] = &unk_1E5289E78;
        v67[4] = __dst;
        EnumerateKnownUrduSequencesInString((uint64_t)String, effectiveRange.location, effectiveRange.length, (uint64_t)v67);
        if (*((void *)__dst[1] + 6) == *((void *)__dst[1] + 7))
        {
          int v9 = v52;
        }
        else
        {
          int v26 = *v23;
          int v27 = (*(uint64_t (**)(void))(**((void **)v23 + 50) + 160))(*((void *)v23 + 50));
          CFStringRef AltUrduUIFontNameForSymbolicTraits = (const __CFString *)GetAltUrduUIFontNameForSymbolicTraits(v27 | ((v26 & 1) << 11));
          v29.f64[0] = NAN;
          v29.f64[1] = NAN;
          float64x2_t v65 = v29;
          float64x2_t v66 = v29;
          float64x2_t v64 = v29;
          v30 = (float64x2_t *)*((void *)v23 + 5);
          if (!v30) {
            v30 = (float64x2_t *)MEMORY[0x1E4F1DAB8];
          }
          float64x2_t v32 = v30[1];
          float64x2_t v31 = v30[2];
          float64x2_t v64 = *v30;
          float64x2_t v65 = v32;
          float64x2_t v66 = v31;
          int64x2_t v33 = (int64x2_t)vandq_s8((int8x16_t)vceqq_f64(v64, (float64x2_t)xmmword_184B895C0), vandq_s8((int8x16_t)vceqq_f64(v32, (float64x2_t)xmmword_184B87DE0), (int8x16_t)vceqzq_f64(v31)));
          if (vandq_s8((int8x16_t)v33, (int8x16_t)vdupq_laneq_s64(v33, 1)).i64[0] >= 0) {
            v34 = (const CGAffineTransform *)&v64;
          }
          else {
            v34 = 0;
          }
          v35 = CTFontCreateWithNameAndOptions(AltUrduUIFontNameForSymbolicTraits, *((CGFloat *)v23 + 2), v34, 0x20000400uLL);
          if (v35)
          {
            v63[6] = xmmword_184B897C8;
            memset(&v63[7], 170, 40);
            v63[3] = unk_184B89798;
            memset(&v63[4], 255, 32);
            memset(v63, 170, 48);
            v51 = v35;
            TAttributes::TAttributes((TAttributes *)v63, v62, v35);
            v36 = (uint64_t *)*((void *)__dst[1] + 6);
            v37 = (uint64_t *)*((void *)__dst[1] + 7);
            while (v36 != v37)
            {
              uint64_t v39 = *v36;
              uint64_t v38 = v36[1];
              if (*v36 <= v12)
              {
                char v41 = v85;
              }
              else
              {
                char v40 = TGlyphEncoder::EncodeChars(v79, v12, *v36 - v12, v62, 0);
                char v41 = v85 | v40;
              }
              char v85 = TGlyphEncoder::EncodeChars(v79, v39, v38, v63, 0) | v41;
              CFIndex v12 = v38 + v39;
              v36 += 2;
            }
            TAttributes::~TAttributes((TAttributes *)v63);
            v4 = v49;
            v35 = v51;
          }

          CFIndex v45 = effectiveRange.location - v12 + effectiveRange.length;
          effectiveRange.CFIndex location = v12;
          effectiveRange.CFIndex length = v45;
          int v9 = v52;
          if (v45 < 1)
          {
            int v46 = 0;
            goto LABEL_63;
          }
        }
        int v46 = 1;
LABEL_63:
        _Block_object_dispose(__dst, 8);
        std::vector<TGlyphAuxDataListEntry,TInlineBufferAllocator<TGlyphAuxDataListEntry,30ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&__dst[6]);
        if (v46) {
          goto LABEL_45;
        }
LABEL_46:
        int v43 = BYTE8(v76);
        if (BYTE8(v76) && (a3 & 1) == 0)
        {
          if (v11)
          {
            TCFRef<__CTFont const*>::Retain((atomic_ullong *)v11, Attributes);
            TAttributes::operator=((uint64_t)(v11 + 8), (uint64_t)v62);
          }
          else
          {
            v11 = (char *)operator new(0xA0uLL, MEMORY[0x1E4FBA2D0]);
            if (v11)
            {
              __dst[0] = Attributes;
              *(void *)v11 = atomic_exchange((atomic_ullong *volatile)__dst, 0);
              *(_WORD *)(v11 + 57) = 0;
              v11[59] = 0;
              v11[64] = 0;
              v11[112] = 0;
              *((void *)v11 + 19) = 0;
              *(_OWORD *)(v11 + 24) = 0u;
              *(_OWORD *)(v11 + 40) = 0u;
              *(_OWORD *)(v11 + 8) = 0u;
              *((void *)v11 + 16) = 0;
              *((void *)v11 + 17) = 0;
              TAttributes::operator=((uint64_t)(v11 + 8), (uint64_t)v62);
            }
            SetThreadSpecificData(0, (uint64_t)v11, (uint64_t (*)(void *))TTypesetter::DestroyAttributesCache);
          }
          int v43 = BYTE8(v76);
        }
        CFIndex v44 = effectiveRange.length;
        if (v43) {
          TAttributes::~TAttributes((TAttributes *)v68);
        }
        v12 += v44;
        unint64_t v13 = v61;
      }
      while (v12 < v5);
    }

    *((void *)v4 + 9) = 0;
    *((void *)v4 + 10) = v5;
    TLine::LinkRuns(v4);
    if (TTypesetter::CanLayout(v4))
    {
      *(_OWORD *)((char *)v68 + 8) = *(_OWORD *)((char *)v4 + 216);
      uint64_t v47 = *((void *)v4 + 29);
      *(void *)&v68[0] = v4;
      *((void *)&v68[1] + 1) = v47;
      *((void *)&v69 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(void *)&long long v69 = (char *)v4 + 240;
      DWORD2(v69) = *((_DWORD *)v4 + 65);
      BYTE12(v69) = *((unsigned char *)v4 + 264);
      BYTE13(v69) = *((unsigned char *)v4 + 257);
      *(void *)&long long v70 = 0;
      memcpy(__dst, &unk_184B89800, 0x290uLL);
      TRunGlue::TRunGlue((TRunGlue *)__dst, v4);
      char v48 = TTypesetter::FinishEncoding((uint64_t)v68, (TShapingEngine *)__dst, (const TCharStream *)&v85);
      TTypesetter::FinishLayout((uint64_t)v68, (TCompositionEngine **)__dst, (const TCharStream *)v85, v48);
      std::__function::__value_func<BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::~__value_func[abi:nn180100](&__dst[70]);
      *(void *)&v63[0] = &__dst[46];
      std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v63);
      *(void *)&v63[0] = &__dst[26];
      std::vector<unsigned char,TInlineBufferAllocator<unsigned char,128ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v63);
      *(void *)&v63[0] = &__dst[7];
      std::vector<std::pair<UScriptCode,long>,TInlineBufferAllocator<std::pair<UScriptCode,long>,1ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v63);
    }
    return (id)std::__hash_table<EncoderAttempt,std::hash<EncoderAttempt>,std::equal_to<EncoderAttempt>,std::allocator<EncoderAttempt>>::~__hash_table((uint64_t)v83);
  }
  return result;
}

void TAttributes::~TAttributes(TAttributes *this)
{
  std::unique_ptr<TBaselineAttributes>::reset[abi:nn180100]((uint64_t *)this + 18, 0);
  uint64_t v2 = *((void *)this + 16);
  *((void *)this + 16) = 0;
  if (v2) {
    MEMORY[0x1853275C0](v2, 0x10C0C40E6EFC850);
  }
  uint64_t v3 = *((void *)this + 15);
  *((void *)this + 15) = 0;
  if (v3) {
    std::default_delete<TAttributes::RareData>::operator()[abi:nn180100]((uint64_t)this + 120, v3);
  }
}

uint64_t TAttributes::operator=(uint64_t a1, uint64_t a2)
{
  TCFRef<__CTFont const*>::Retain((atomic_ullong *)a1, (id)atomic_load_explicit((atomic_ullong *volatile)a2, memory_order_acquire));
  TCFRef<__CTFont const*>::Retain((atomic_ullong *)(a1 + 8), (id)atomic_load_explicit((atomic_ullong *volatile)(a2 + 8), memory_order_acquire));
  TCFRef<__CTFont const*>::Retain((atomic_ullong *)(a1 + 16), (id)atomic_load_explicit((atomic_ullong *volatile)(a2 + 16), memory_order_acquire));
  TCFRef<__CTFont const*>::Retain((atomic_ullong *)(a1 + 24), (id)atomic_load_explicit((atomic_ullong *volatile)(a2 + 24), memory_order_acquire));
  TCFRef<__CTFont const*>::Retain((atomic_ullong *)(a1 + 32), (id)atomic_load_explicit((atomic_ullong *volatile)(a2 + 32), memory_order_acquire));
  TCFRef<__CTFont const*>::Retain((atomic_ullong *)(a1 + 40), (id)atomic_load_explicit((atomic_ullong *volatile)(a2 + 40), memory_order_acquire));
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  long long v4 = *(_OWORD *)(a2 + 56);
  long long v5 = *(_OWORD *)(a2 + 72);
  long long v6 = *(_OWORD *)(a2 + 88);
  *(unsigned char *)(a1 + 104) = *(unsigned char *)(a2 + 104);
  *(_OWORD *)(a1 + 88) = v6;
  *(_OWORD *)(a1 + 72) = v5;
  *(_OWORD *)(a1 + 56) = v4;
  *(unsigned char *)(a1 + 112) = *(unsigned char *)(a2 + 112);
  id v7 = (uint64_t *)(a1 + 120);
  if (*(void *)(a2 + 120)) {
    operator new();
  }
  uint64_t v8 = *v7;
  *id v7 = 0;
  if (v8) {
    std::default_delete<TAttributes::RareData>::operator()[abi:nn180100](a1 + 120, v8);
  }
  if (*(void *)(a2 + 128)) {
    operator new();
  }
  uint64_t v9 = *(void *)(a1 + 128);
  *(void *)(a1 + 128) = 0;
  if (v9) {
    MEMORY[0x1853275C0](v9, 0x10C0C40E6EFC850);
  }
  *(_DWORD *)(a1 + 136) = *(_DWORD *)(a2 + 136);
  if (*(void *)(a2 + 144)) {
    operator new();
  }
  std::unique_ptr<TBaselineAttributes>::reset[abi:nn180100]((uint64_t *)(a1 + 144), 0);
  return a1;
}

void TCFRef<__CTFont const*>::Retain(atomic_ullong *a1, id a2)
{
  if ((id)atomic_load_explicit(a1, memory_order_acquire) != a2)
  {
    uint64_t v2 = (void *)atomic_exchange(a1, (unint64_t)a2);
  }
}

uint64_t *std::unique_ptr<TBaselineAttributes>::reset[abi:nn180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  *id result = a2;
  if (v2)
  {

    JUMPOUT(0x1853275C0);
  }
  return result;
}

void std::default_delete<TAttributes::RareData>::operator()[abi:nn180100](uint64_t a1, uint64_t a2)
{
  if (a2)
  {

    uint64_t v3 = *(std::__shared_weak_count **)(a2 + 88);
    if (v3) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v3);
    }
    JUMPOUT(0x1853275C0);
  }
}

void TRun::~TRun(void **this)
{
  *this = &unk_1ED05F378;
  free(this[35]);
  uint64_t v2 = (uint64_t)this[39];
  this[39] = 0;
  if (v2) {
    std::default_delete<TRun::RareData>::operator()[abi:nn180100]((uint64_t)(this + 39), v2);
  }
  TStorageRange::~TStorageRange(this + 24);
  TAttributes::~TAttributes((TAttributes *)(this + 5));
}

{
  uint64_t vars8;

  TRun::~TRun(this);

  JUMPOUT(0x1853275C0);
}

void TStorageRange::~TStorageRange(id *this)
{
  uint64_t v2 = (std::__shared_weak_count *)this[6];
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
}

uint64_t OTL::GSUB::AddShapingGlyphs(void *a1, unsigned __int16 **a2, uint64_t a3, uint64_t a4)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v18[0] = v8;
  v18[1] = v8;
  std::__function::__value_func<void ()(unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)v18, a3);
  uint64_t v9 = *(os_unfair_lock_s **)(a1[2] + 400);
  os_unfair_lock_lock_with_options();
  v10 = *a2;
  v11 = a2[1];
  while (1)
  {
    if (v10 == v11)
    {
      uint64_t v14 = 1;
      goto LABEL_8;
    }
    CFIndex v12 = TBaseFont::NthLookup<OTL::GSUB>((uint64_t)v9, a1, *v10);
    if (v12)
    {
      uint64_t v13 = (uint64_t)v12;
      std::__function::__value_func<void ()(unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)v17, a3);
      std::__function::__value_func<void ()(void)>::__value_func[abi:nn180100]((uint64_t)v16, a4);
      LODWORD(v13) = OTL::GSUB::AddShapingGlyphsForLookup((uint64_t)a1, v13, (uint64_t)v17, (uint64_t)v16);
      std::__function::__value_func<void ()(void)>::~__value_func[abi:nn180100](v16);
      std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100](v17);
      if (!v13) {
        break;
      }
    }
    v10 += 2;
  }
  uint64_t v14 = 0;
LABEL_8:
  os_unfair_lock_unlock(v9 + 89);
  std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100](v18);
  return v14;
}

uint64_t std::__function::__value_func<void ()(unsigned short,unsigned short)>::__value_func[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t std::__function::__func<TFont::InitShapingGlyphs(void)::$_3,std::allocator<TFont::InitShapingGlyphs(void)::$_3>,void ()(unsigned short,unsigned short)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1ED061BC8;
  a2[1] = v2;
  return result;
}

char *TBaseFont::NthLookup<OTL::GSUB>(uint64_t a1, void *a2, unsigned int a3)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  unsigned int v19 = a3;
  uint64_t v4 = a1 + 360;
  long long v5 = std::__hash_table<std::__hash_value_type<unsigned int,OTL::Lookup>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,OTL::Lookup>>>::find<unsigned int>((void *)(a1 + 360), &v19);
  if (v5) {
    return (char *)(v5 + 3);
  }
  id v7 = (unsigned __int16 *)a2[8];
  if (v19 >= bswap32(*v7) >> 16) {
    return 0;
  }
  unint64_t v8 = (unint64_t)v7 + (bswap32(v7[v19 + 1]) >> 16);
  unint64_t v10 = a2[4];
  unint64_t v9 = a2[5];
  if (v8 + 4 < v10 || v8 + 6 > v9) {
    return 0;
  }
  unint64_t v12 = v8
      + 2 * (bswap32(*(unsigned __int16 *)(v8 + 4)) >> 16)
      + (((unint64_t)*(unsigned __int16 *)(v8 + 2) >> 11) & 2)
      + 6;
  BOOL v13 = v10 <= v8 && v12 >= v8;
  if (!v13 || v12 > v9) {
    return 0;
  }
  OTL::Lookup::Lookup<OTL::GSUB>((OTL::Lookup *)v22, (uint64_t)a2, v8);
  v20 = (long long *)v22;
  int v21 = &v19;
  v15 = std::__hash_table<std::__hash_value_type<unsigned int,OTL::Lookup>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,OTL::Lookup>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<OTL::Lookup&&>>(v4, &v19, (uint64_t)&std::piecewise_construct, &v21, &v20);
  char v17 = v16;
  OTL::Lookup::~Lookup((OTL::Lookup *)v22);
  if (!v17) {
    return 0;
  }
  long long v6 = (char *)(v15 + 3);
  OTL::Lookup::InitCoverageUnion(v6);
  return v6;
}

void *std::__function::__value_func<void ()(void)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__function::__value_func<void ()(void)>::__value_func[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t std::__function::__func<TFont::InitShapingGlyphs(void)::$_2,std::allocator<TFont::InitShapingGlyphs(void)::$_2>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1ED061B80;
  a2[1] = v2;
  return result;
}

__n128 std::__function::__func<TFont::InitShapingGlyphs(void)::$_1,std::allocator<TFont::InitShapingGlyphs(void)::$_1>,void ()(unsigned short,unsigned short)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ED061B38;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

BOOL OTL::Coverage::IterateFmt1(void *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unint64_t v2 = a1[1];
  uint64_t v4 = (unsigned __int16 *)(*a1 + 4);
  unsigned int v5 = __rev16(*(unsigned __int16 *)(*a1 + 2));
  long long v6 = &v4[v5];
  if (*a1 + 6 <= v2) {
    unsigned int v7 = (v2 - v4) >> 1;
  }
  else {
    unsigned int v7 = 0;
  }
  unsigned int v8 = bswap32(v7) >> 16;
  BOOL v9 = v6 < v4 || (unint64_t)v6 > v2;
  if (v9) {
    unsigned __int16 v10 = v7;
  }
  else {
    unsigned __int16 v10 = v5;
  }
  if (v9) {
    unsigned int v11 = v8;
  }
  else {
    unsigned int v11 = *(unsigned __int16 *)(*a1 + 2);
  }
  if (!v11) {
    return 1;
  }
  if ((v10 & 0xFFFE) != 0) {
    uint64_t v13 = v10;
  }
  else {
    uint64_t v13 = 1;
  }
  unsigned int v14 = bswap32(*v4) >> 16;
  int v15 = std::function<BOOL ()(unsigned short,unsigned short,unsigned short)>::operator()(a2, v14, v14, 0);
  BOOL result = 0;
  if (v15)
  {
    unint64_t v17 = 0;
    uint64_t v18 = v3 + 6;
    uint64_t v19 = v13 - 1;
    do
    {
      unint64_t v20 = v17 + 1;
      if (v19 == v17) {
        break;
      }
      unsigned int v21 = bswap32(*(unsigned __int16 *)(v18 + 2 * v17)) >> 16;
      char v22 = std::function<BOOL ()(unsigned short,unsigned short,unsigned short)>::operator()(a2, v21, v21, v20);
      unint64_t v17 = v20;
    }
    while ((v22 & 1) != 0);
    return v20 >= v10;
  }
  return result;
}

uint64_t std::function<BOOL ()(unsigned short,unsigned short,unsigned short)>::operator()(uint64_t a1, __int16 a2, __int16 a3, __int16 a4)
{
  __int16 v11 = a2;
  __int16 v10 = a3;
  __int16 v9 = a4;
  uint64_t v4 = *(void *)(a1 + 24);
  if (v4) {
    return (*(uint64_t (**)(uint64_t, __int16 *, __int16 *, __int16 *))(*(void *)v4 + 48))(v4, &v11, &v10, &v9);
  }
  uint64_t v6 = std::__throw_bad_function_call[abi:nn180100]();
  return std::__invoke_void_return_wrapper<BOOL,false>::__call[abi:nn180100]<OTL::Lookup::InitCoverageUnion(void)::{lambda(unsigned short,unsigned short,unsigned short)#1} &,unsigned short,unsigned short,unsigned short>(v6, v7, v8);
}

uint64_t std::__invoke_void_return_wrapper<BOOL,false>::__call[abi:nn180100]<OTL::Lookup::InitCoverageUnion(void)::{lambda(unsigned short,unsigned short,unsigned short)#1} &,unsigned short,unsigned short,unsigned short>(uint64_t a1, unsigned __int16 *a2, unsigned __int16 *a3)
{
  unsigned int v3 = *a2;
  unsigned int v4 = *a3;
  if (v3 <= v4 && v3 != (unsigned __int16)(v4 + 1))
  {
    do
    {
      uint64_t v5 = (unsigned __int16)(v3 - *(_WORD *)(*(void *)a1 + 4)) >> 3;
      *(unsigned char *)(*(void *)(*(void *)a1 + 40) + v5) |= 1 << ((v3 - *(_WORD *)(*(void *)a1 + 4)) & 7);
    }
    while (v4 != (unsigned __int16)v3++);
  }
  return 1;
}

uint64_t std::__function::__func<OTL::Lookup::InitCoverageUnion(void)::{lambda(unsigned short,unsigned short,unsigned short)#1},std::allocator<OTL::Lookup::InitCoverageUnion(void)::{lambda(unsigned short,unsigned short,unsigned short)#1}>,BOOL ()(unsigned short,unsigned short,unsigned short)>::operator()(uint64_t a1, unsigned __int16 *a2, unsigned __int16 *a3)
{
  return std::__invoke_void_return_wrapper<BOOL,false>::__call[abi:nn180100]<OTL::Lookup::InitCoverageUnion(void)::{lambda(unsigned short,unsigned short,unsigned short)#1} &,unsigned short,unsigned short,unsigned short>(a1 + 8, a2, a3);
}

uint64_t std::__function::__func<OTL::GSUB::AddShapingGlyphsForLookup(OTL::Lookup const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0,std::allocator<OTL::GSUB::AddShapingGlyphsForLookup(OTL::Lookup const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0>,BOOL ()(unsigned short,unsigned short,unsigned short)>::operator()(uint64_t a1, __int16 *a2, __int16 *a3)
{
  return 1;
}

BOOL OTL::GSUB::AddShapingGlyphsForLookup(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v54[0] = v6;
  v54[1] = v6;
  std::__function::__value_func<void ()(unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)v54, a3);
  v53[0] = a2;
  v53[1] = a4;
  v53[2] = (uint64_t)v54;
  unint64_t v47 = (unsigned __int16)(-21845 * ((*(_DWORD *)(a2 + 96) - *(_DWORD *)(a2 + 88)) >> 4));
  if (-21845 * (unsigned __int16)((*(_DWORD *)(a2 + 96) - *(_DWORD *)(a2 + 88)) >> 4))
  {
    uint64_t v48 = a2;
    unint64_t v7 = 0;
    BOOL v49 = 0;
    while (1)
    {
      uint64_t v8 = *(void *)(v48 + 88);
      if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(v48 + 96) - v8) >> 4) <= v7) {
        uint64_t v9 = 0;
      }
      else {
        uint64_t v9 = *(void *)(v8 + 48 * v7);
      }
      if (*(_WORD *)(v48 + 16) == 4)
      {
        unint64_t v10 = *(void *)(a1 + 40);
        unint64_t v11 = v9 + 6;
        if ((unint64_t)(v9 + 4) < *(void *)(a1 + 32) || v11 > v10) {
          goto LABEL_87;
        }
        uint64_t v13 = __rev16(*(unsigned __int16 *)(v9 + 4));
        unint64_t v14 = v11 + 2 * v13;
        unint64_t v15 = v9 + 8 <= v10 ? (v10 - v11) >> 1 : 0;
        BOOL v16 = v14 <= v10 && v14 >= v11;
        int v52 = v13;
        unint64_t v50 = v15;
        if (!v16 && v15 != v13) {
          goto LABEL_87;
        }
        if (*(_WORD *)(v9 + 4))
        {
          for (unint64_t i = 0; i != v52; ++i)
          {
            unint64_t v19 = bswap32(*(unsigned __int16 *)(v9 + 4)) >> 16;
            unint64_t v20 = v11 + 2 * v19;
            if (v20 < v11 || v20 > v10)
            {
              if (v50 == v19 && i < v19)
              {
LABEL_36:
                uint64_t v23 = (unsigned __int16 *)(v9 + (bswap32(*(unsigned __int16 *)(v9 + 2 * i + 6)) >> 16));
                long long v24 = v23 + 1;
                if ((unint64_t)(v23 + 1) <= v10)
                {
                  unsigned int v25 = *v23;
                  uint64_t v26 = __rev16(v25);
                  unint64_t v27 = (unint64_t)&v24[v26];
                  unint64_t v28 = (unint64_t)(v23 + 2) <= v10 ? (v10 - (unint64_t)v24) >> 1 : 0;
                  BOOL v29 = v27 <= v10 && v27 >= (unint64_t)v24;
                  BOOL v30 = v29 || v28 == v26;
                  if (v30 && v25 != 0)
                  {
                    unint64_t v32 = 0;
                    do
                    {
                      unint64_t v33 = bswap32(*v23) >> 16;
                      unint64_t v34 = (unint64_t)&v24[v33];
                      if (v34 < (unint64_t)v24 || v34 > v10)
                      {
                        if (v28 != v33 || v32 >= v33) {
                          break;
                        }
                      }
                      else if (v32 >= v33)
                      {
                        break;
                      }
                      v37 = (char *)v23 + (bswap32(v24[v32]) >> 16);
                      uint64_t v38 = (unsigned __int16 *)(v37 + 4);
                      if ((unint64_t)(v37 + 4) > v10) {
                        break;
                      }
                      uint64_t v39 = bswap32(*((unsigned __int16 *)v37 + 1)) >> 16;
                      char v40 = &v38[v39 - 1];
                      unint64_t v41 = (unint64_t)(v37 + 6) <= v10 ? (v10 - (unint64_t)v38) >> 1 : 0;
                      BOOL v42 = (unint64_t)v40 <= v10 && v40 >= v38;
                      if (!v42 && v41 != v39 - 1) {
                        break;
                      }
                      if (v39)
                      {
                        if (v39 == 1)
                        {
                          if ((OTL::GSUB::AddShapingGlyphsForLookup(OTL::Lookup const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)const::$_1::operator()(v53, v7) & 1) == 0)goto LABEL_87; {
                        }
                          }
                        else
                        {
                          unsigned int v44 = bswap32(*v38) >> 16;
                          std::function<void ()(unsigned short,unsigned short)>::operator()(a3, v44, v44);
                        }
                      }
                      ++v32;
                    }
                    while (v26 != v32);
                  }
                }
              }
            }
            else if (i < v19)
            {
              goto LABEL_36;
            }
          }
        }
      }
      else if (!OTL::GSUB::AddShapingGlyphsForLookup(OTL::Lookup const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)const::$_1::operator()(v53, v7))
      {
        goto LABEL_87;
      }
      BOOL v49 = ++v7 >= v47;
      if (v7 == v47) {
        goto LABEL_87;
      }
    }
  }
  BOOL v49 = 1;
LABEL_87:
  std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100](v54);
  return v49;
}

uint64_t std::function<void ()(unsigned short,unsigned short)>::operator()(uint64_t a1, __int16 a2, __int16 a3)
{
  __int16 v9 = a2;
  __int16 v8 = a3;
  uint64_t v3 = *(void *)(a1 + 24);
  if (v3) {
    return (*(uint64_t (**)(uint64_t, __int16 *, __int16 *))(*(void *)v3 + 48))(v3, &v9, &v8);
  }
  uint64_t v5 = std::__throw_bad_function_call[abi:nn180100]();
  return std::__function::__func<TFont::InitShapingGlyphs(void)::$_3,std::allocator<TFont::InitShapingGlyphs(void)::$_3>,void ()(unsigned short,unsigned short)>::operator()(v5, v6, v7);
}

uint64_t std::__function::__func<TFont::InitShapingGlyphs(void)::$_3,std::allocator<TFont::InitShapingGlyphs(void)::$_3>,void ()(unsigned short,unsigned short)>::operator()(uint64_t result, unsigned __int16 *a2, unsigned __int16 *a3)
{
  unsigned int v3 = *a2;
  unsigned int v4 = *a3;
  if (v3 <= v4 && v3 != (unsigned __int16)(v4 + 1))
  {
    do
      *(unsigned char *)(*(void *)(result + 8) + ((unsigned __int16)v3 >> 3)) |= 1 << (v3 & 7);
    while (v4 != (unsigned __int16)v3++);
  }
  return result;
}

uint64_t std::__function::__func<TFont::InitShapingGlyphs(void)::$_1,std::allocator<TFont::InitShapingGlyphs(void)::$_1>,void ()(unsigned short,unsigned short)>::operator()(uint64_t result, unsigned __int16 *a2, unsigned __int16 *a3)
{
  unsigned int v3 = *a2;
  unsigned int v4 = *a3;
  if (v3 <= v4 && v3 != (unsigned __int16)(v4 + 1))
  {
    do
    {
      int v5 = 1 << (v3 & 7);
      uint64_t v6 = (unsigned __int16)v3 >> 3;
      *(unsigned char *)(*(void *)(result + 8) + v6) |= v5;
      *(unsigned char *)(*(void *)(result + 16) + v6) |= v5;
    }
    while (v4 != (unsigned __int16)v3++);
  }
  return result;
}

uint64_t OTL::GSUB::AddShapingGlyphsForLookup(OTL::Lookup const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)const::$_1::operator()(uint64_t *a1, unsigned int a2)
{
  v11[4] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(*a1 + 88);
  if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(*a1 + 96) - v3) >> 4) > a2)
  {
    unsigned int v4 = (void *)(v3 + 48 * a2 + 8);
    std::__function::__value_func<void ()(unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)v9, a1[2]);
    int v5 = operator new(0x28uLL);
    uint64_t v6 = v5;
    *int v5 = &unk_1ED061A60;
    if (v10)
    {
      if (v10 == v9)
      {
        v5[4] = v5 + 1;
        (*(void (**)(void *))(v9[0] + 24))(v9);
      }
      else
      {
        v5[4] = v10;
        unint64_t v10 = 0;
      }
    }
    else
    {
      v5[4] = 0;
    }
    v11[3] = v6;
    char v7 = OTL::Coverage::Iterate(v4, (uint64_t)v11);
    std::__function::__value_func<BOOL ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100](v11);
    std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100](v9);
    if (v7) {
      return 1;
    }
  }
  std::function<void ()(void)>::operator()(a1[1]);
  return 0;
}

uint64_t OTL::Coverage::Iterate(void *a1, uint64_t a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (*a1)
  {
    unsigned int v3 = bswap32(*(unsigned __int16 *)*a1) >> 16;
    if (v3 == 2)
    {
      unsigned int v4 = v8;
      std::__function::__value_func<BOOL ()(unsigned short,unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)v8, a2);
      uint64_t v5 = OTL::Coverage::IterateFmt2(a1, (uint64_t)v8);
      goto LABEL_7;
    }
    if (v3 == 1)
    {
      unsigned int v4 = v9;
      std::__function::__value_func<BOOL ()(unsigned short,unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)v9, a2);
      uint64_t v5 = OTL::Coverage::IterateFmt1(a1, (uint64_t)v9);
LABEL_7:
      uint64_t v6 = v5;
      std::__function::__value_func<BOOL ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100](v4);
      return v6;
    }
  }
  return 0;
}

void *std::__function::__value_func<BOOL ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100](void *a1)
{
  unint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<OTL::GSUB::AddShapingGlyphsForLookup(OTL::Lookup const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0,std::allocator<OTL::GSUB::AddShapingGlyphsForLookup(OTL::Lookup const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0>,BOOL ()(unsigned short,unsigned short,unsigned short)>::destroy_deallocate(void *a1)
{
  std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100](a1 + 1);

  operator delete(a1);
}

void *std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100](void *a1)
{
  unint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__function::__value_func<BOOL ()(unsigned short,unsigned short,unsigned short)>::__value_func[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *std::__function::__func<OTL::GSUB::AddShapingGlyphsForLookup(OTL::Lookup const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0,std::allocator<OTL::GSUB::AddShapingGlyphsForLookup(OTL::Lookup const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0>,BOOL ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  unint64_t v2 = operator new(0x28uLL);
  *unint64_t v2 = &unk_1ED061A60;
  std::__function::__value_func<void ()(unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)(v2 + 1), v1);
  return v2;
}

uint64_t std::__throw_bad_function_call[abi:nn180100]()
{
  return std::__split_buffer<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,TInlineBufferAllocator<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,30ul> &>::clear[abi:nn180100]();
}

void std::__split_buffer<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,TInlineBufferAllocator<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,30ul> &>::clear[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 104;
    unsigned int v4 = (void **)(i - 96);
    std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__destroy_vector::operator()[abi:nn180100](&v4);
  }
}

void OTL::GlyphLookups::SetLookupInRange<false>(uint64_t *a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  __int16 v9 = (unsigned __int16 *)*a1;
  __int16 v8 = (unsigned __int16 *)a1[1];
  if ((unsigned __int16 *)*a1 != v8)
  {
    while (*v9 != (unsigned __int16)a2 || v9[1] != HIWORD(a2))
    {
      v9 += 52;
      if (v9 == v8) {
        goto LABEL_17;
      }
    }
  }
  if (v9 == v8)
  {
LABEL_17:
    unint64_t v37 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v17 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v17 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v35 = v17;
    long long v36 = v17;
    long long v33 = v17;
    long long v34 = v17;
    *(_OWORD *)&v32[16] = v17;
    *(_OWORD *)unint64_t v32 = v17;
    v30[0] = a3;
    v30[1] = a4;
    TInlineVector<CFRange,4ul>::TInlineVector(v31, v30, 1uLL);
    *(_DWORD *)unint64_t v32 = a2;
    std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::vector<std::__wrap_iter<CFRange const*>,0>((uint64_t)&v32[8], (unsigned char *)v31[0], (unsigned char *)v31[1]);
    BOOL v29 = v31;
    std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v29);
    std::vector<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,TInlineBufferAllocator<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,30ul>>::emplace_back<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>>(a1, (uint64_t)v32);
    v31[0] = (void **)&v32[8];
    std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__destroy_vector::operator()[abi:nn180100](v31);
  }
  else
  {
    unint64_t v11 = (char *)*((void *)v9 + 1);
    unint64_t v12 = (char *)*((void *)v9 + 2);
    if (v11 == v12
      || (uint64_t v13 = *((void *)v12 - 1), (v13 & 0x8000000000000000) == 0)
      && (a3 == *((void *)v12 - 2) ? (BOOL v14 = a4 == v13) : (BOOL v14 = 0), !v14))
    {
      unint64_t v15 = *((void *)v9 + 3);
      if ((unint64_t)v12 >= v15)
      {
        uint64_t v18 = (v12 - v11) >> 4;
        unint64_t v19 = v18 + 1;
        if ((unint64_t)(v18 + 1) >> 60) {
          abort();
        }
        uint64_t v20 = v15 - (void)v11;
        if (v20 >> 3 > v19) {
          unint64_t v19 = v20 >> 3;
        }
        if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v21 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v21 = v19;
        }
        *(void *)&long long v33 = v9 + 16;
        if (v21) {
          char v22 = (char *)TInlineBufferAllocator<CFRange,4ul>::allocate((uint64_t)(v9 + 16), v21);
        }
        else {
          char v22 = 0;
        }
        uint64_t v23 = &v22[16 * v18];
        *(void *)uint64_t v23 = a3;
        *((void *)v23 + 1) = a4;
        uint64_t v24 = *((void *)v9 + 1);
        unint64_t v25 = *((void *)v9 + 2);
        if (v25 == v24)
        {
          int64x2_t v27 = vdupq_n_s64(v25);
          uint64_t v26 = &v22[16 * v18];
        }
        else
        {
          uint64_t v26 = &v22[16 * v18];
          do
          {
            *((_OWORD *)v26 - 1) = *(_OWORD *)(v25 - 16);
            v26 -= 16;
            v25 -= 16;
          }
          while (v25 != v24);
          int64x2_t v27 = *(int64x2_t *)(v9 + 4);
        }
        BOOL v16 = v23 + 16;
        *((void *)v9 + 1) = v26;
        *((void *)v9 + 2) = v23 + 16;
        *(int64x2_t *)&v32[8] = v27;
        uint64_t v28 = *((void *)v9 + 3);
        *((void *)v9 + 3) = &v22[16 * v21];
        *(void *)&v32[24] = v28;
        *(void *)unint64_t v32 = v27.i64[0];
        std::__split_buffer<CFRange,TInlineBufferAllocator<CFRange,4ul> &>::~__split_buffer((uint64_t)v32);
      }
      else
      {
        *(void *)unint64_t v12 = a3;
        *((void *)v12 + 1) = a4;
        BOOL v16 = v12 + 16;
      }
      *((void *)v9 + 2) = v16;
    }
  }
}

void std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    v1[1] = v2;
    uint64_t v3 = v1 + 11;
    if (v1 + 3 <= v2)
    {
      BOOL v4 = v3 >= v2;
      BOOL v5 = v3 == v2;
    }
    else
    {
      BOOL v4 = 0;
      BOOL v5 = 0;
    }
    if (!v5 && v4)
    {
      if (v1[2] == v1[11]) {
        *uint64_t v3 = v2;
      }
    }
    else
    {
      operator delete(v2);
    }
  }
}

_DWORD *std::vector<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,TInlineBufferAllocator<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,30ul>>::emplace_back<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>>(uint64_t *a1, uint64_t a2)
{
  BOOL v5 = (_DWORD *)a1[1];
  unint64_t v4 = a1[2];
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = (uint64_t)(a1 + 3);
    uint64_t v8 = 0x4EC4EC4EC4EC4EC5 * (((uint64_t)v5 - *a1) >> 3);
    unint64_t v9 = v8 + 1;
    if ((unint64_t)(v8 + 1) > 0x276276276276276) {
      abort();
    }
    unint64_t v10 = 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(v4 - *a1) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x13B13B13B13B13BLL) {
      unint64_t v11 = 0x276276276276276;
    }
    else {
      unint64_t v11 = v9;
    }
    v15[4] = a1 + 3;
    if (v11) {
      unint64_t v12 = TInlineBufferAllocator<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,30ul>::allocate(v7, v11);
    }
    else {
      unint64_t v12 = 0;
    }
    uint64_t v13 = &v12[104 * v8];
    v15[0] = v12;
    v15[1] = v13;
    v15[3] = &v12[104 * v11];
    *(_DWORD *)uint64_t v13 = *(_DWORD *)a2;
    std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::vector<std::__wrap_iter<CFRange const*>,0>((uint64_t)(v13 + 8), *(unsigned char **)(a2 + 8), *(unsigned char **)(a2 + 16));
    v15[2] = v13 + 104;
    std::vector<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,TInlineBufferAllocator<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,30ul>>::__swap_out_circular_buffer(a1, v15);
    uint64_t v6 = (_DWORD *)a1[1];
    std::__split_buffer<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,TInlineBufferAllocator<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,30ul> &>::~__split_buffer(v15);
  }
  else
  {
    *BOOL v5 = *(_DWORD *)a2;
    uint64_t v6 = v5 + 26;
    std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::vector<std::__wrap_iter<CFRange const*>,0>((uint64_t)(v5 + 2), *(unsigned char **)(a2 + 8), *(unsigned char **)(a2 + 16));
  }
  a1[1] = (uint64_t)v6;
  return v6 - 26;
}

void *TInlineVector<CFRange,4ul>::TInlineVector(void *a1, const void *a2, unint64_t a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  a1[11] = a1 + 3;
  if (a3)
  {
    std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__vallocate[abi:nn180100](a1, a3);
    uint64_t v6 = (char *)a1[1];
    memmove(v6, a2, 16 * a3);
    a1[1] = &v6[16 * a3];
  }
  return a1;
}

uint64_t std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::vector<std::__wrap_iter<CFRange const*>,0>(uint64_t a1, unsigned char *a2, unsigned char *a3)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 88) = a1 + 24;
  int64_t v4 = a3 - a2;
  if (a3 != a2)
  {
    std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__vallocate[abi:nn180100]((void *)a1, v4 >> 4);
    uint64_t v7 = *(void *)(a1 + 8);
    if (a3 != a2) {
      memmove(*(void **)(a1 + 8), a2, v4);
    }
    *(void *)(a1 + 8) = v7 + 16 * (v4 >> 4);
  }
  return a1;
}

char *std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >> 60) {
    abort();
  }
  BOOL result = (char *)TInlineBufferAllocator<CFRange,4ul>::allocate((uint64_t)(a1 + 3), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * a2];
  return result;
}

void *TInlineBufferAllocator<CFRange,4ul>::allocate(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 64);
  uint64_t v2 = (unint64_t *)(a1 + 64);
  uint64_t v3 = v4;
  unint64_t v5 = v4 + 16 * a2;
  if (v5 <= (unint64_t)v2)
  {
    *uint64_t v2 = v5;
    return (void *)v3;
  }
  else
  {
    if (a2 >> 60) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    return operator new(16 * a2);
  }
}

char *TInlineBufferAllocator<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,30ul>::allocate(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = (char *)(a1 + 3120);
  BOOL result = *(char **)(a1 + 3120);
  uint64_t v4 = &result[104 * a2];
  if (v4 <= v2)
  {
    *(void *)uint64_t v2 = v4;
  }
  else
  {
    if (a2 >= 0x276276276276277) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    return (char *)operator new(104 * a2);
  }
  return result;
}

uint64_t *std::vector<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,TInlineBufferAllocator<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,30ul>>::__swap_out_circular_buffer(uint64_t *result, void *a2)
{
  uint64_t v3 = result;
  uint64_t v5 = *result;
  uint64_t v4 = result[1];
  uint64_t v6 = a2[1];
  while (v4 != v5)
  {
    int v7 = *(_DWORD *)(v4 - 104);
    v4 -= 104;
    *(_DWORD *)(v6 - 104) = v7;
    v6 -= 104;
    BOOL result = (uint64_t *)std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::vector<std::__wrap_iter<CFRange const*>,0>(v6 + 8, *(unsigned char **)(v4 + 8), *(unsigned char **)(v4 + 16));
  }
  a2[1] = v6;
  uint64_t v8 = *v3;
  *uint64_t v3 = v6;
  a2[1] = v8;
  uint64_t v9 = v3[1];
  v3[1] = a2[2];
  a2[2] = v9;
  uint64_t v10 = v3[2];
  v3[2] = a2[3];
  a2[3] = v10;
  *a2 = a2[1];
  return result;
}

void *std::__split_buffer<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,TInlineBufferAllocator<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,30ul> &>::~__split_buffer(void *a1)
{
  std::__split_buffer<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,TInlineBufferAllocator<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,30ul> &>::clear[abi:nn180100]((uint64_t)a1);
  uint64_t v2 = (void *)*a1;
  if (*a1)
  {
    unint64_t v3 = a1[4];
    uint64_t v4 = (void *)(v3 + 3120);
    if (v3 <= (unint64_t)v2 && v4 > v2)
    {
      if (a1[3] == *v4) {
        void *v4 = v2;
      }
    }
    else
    {
      operator delete(v2);
    }
  }
  return a1;
}

uint64_t OTL::Coverage::IterateFmt2(void *a1, uint64_t a2)
{
  unint64_t v3 = a1[1];
  uint64_t v4 = (unsigned __int16 *)(*a1 + 4);
  unsigned int v5 = *(unsigned __int16 *)(*a1 + 2);
  LODWORD(v6) = __rev16(v5);
  int v7 = &v4[3 * v6];
  if (v7 < v4 || (unint64_t)v7 > v3)
  {
    if (*a1 + 10 > v3) {
      LODWORD(v6) = 0;
    }
    else {
      unint64_t v6 = (v3 - (unint64_t)v4) / 6;
    }
    unsigned int v5 = bswap32(v6) >> 16;
    LODWORD(v6) = (unsigned __int16)v6;
  }
  if (!v5) {
    return 1;
  }
  uint64_t v9 = &v4[3 * v6];
  do
  {
    uint64_t result = std::function<BOOL ()(unsigned short,unsigned short,unsigned short)>::operator()(a2, bswap32(*v4) >> 16, bswap32(v4[1]) >> 16, bswap32(v4[2]) >> 16);
    v4 += 3;
    if (result) {
      BOOL v11 = v4 == v9;
    }
    else {
      BOOL v11 = 1;
    }
  }
  while (!v11);
  return result;
}

uint64_t std::__function::__func<OTL::Lookup::InitCoverageUnion(void)::{lambda(unsigned short,unsigned short,unsigned short)#1},std::allocator<OTL::Lookup::InitCoverageUnion(void)::{lambda(unsigned short,unsigned short,unsigned short)#1}>,BOOL ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1ED061AA8;
  a2[1] = v2;
  return result;
}

void OTL::Lookup::~Lookup(OTL::Lookup *this)
{
  uint64_t v4 = (void **)((char *)this + 88);
  std::vector<std::pair<OTL::LookupSubtable const*,OTL::Coverage>,TInlineBufferAllocator<std::pair<OTL::LookupSubtable const*,OTL::Coverage>,4ul>>::__destroy_vector::operator()[abi:nn180100](&v4);
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 46) {
    free(v2);
  }
  uint64_t v3 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v3) {
    MEMORY[0x1853275C0](v3, 0x1000C401B2BBF36);
  }
}

void std::vector<std::pair<OTL::LookupSubtable const*,OTL::Coverage>,TInlineBufferAllocator<std::pair<OTL::LookupSubtable const*,OTL::Coverage>,4ul>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    v1[1] = v2;
    uint64_t v3 = v1 + 27;
    if (v1 + 3 <= v2)
    {
      BOOL v4 = v3 >= v2;
      BOOL v5 = v3 == v2;
    }
    else
    {
      BOOL v4 = 0;
      BOOL v5 = 0;
    }
    if (!v5 && v4)
    {
      if (v1[2] == v1[27]) {
        *uint64_t v3 = v2;
      }
    }
    else
    {
      operator delete(v2);
    }
  }
}

void *std::__hash_table<std::__hash_value_type<unsigned int,OTL::Lookup>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,OTL::Lookup>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<OTL::Lookup&&>>(uint64_t a1, unsigned int *a2, uint64_t a3, _DWORD **a4, long long **a5)
{
  unint64_t v8 = *a2;
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v11 = *a2;
      if (v9 <= v8) {
        unint64_t v11 = v8 % v9;
      }
    }
    else
    {
      unint64_t v11 = (v9 - 1) & v8;
    }
    unint64_t v12 = *(void ***)(*(void *)a1 + 8 * v11);
    if (v12)
    {
      uint64_t v13 = *v12;
      if (*v12)
      {
        do
        {
          unint64_t v14 = v13[1];
          if (v14 == v8)
          {
            if (*((_DWORD *)v13 + 4) == v8) {
              return v13;
            }
          }
          else
          {
            if (v10.u32[0] > 1uLL)
            {
              if (v14 >= v9) {
                v14 %= v9;
              }
            }
            else
            {
              v14 &= v9 - 1;
            }
            if (v14 != v11) {
              break;
            }
          }
          uint64_t v13 = (void *)*v13;
        }
        while (v13);
      }
    }
  }
  else
  {
    unint64_t v11 = 0xAAAAAAAAAAAAAAAALL;
  }
  unint64_t v15 = (void *)(a1 + 16);
  v27[2] = 0xAAAAAAAAAAAAAA01;
  uint64_t v13 = operator new(0x150uLL);
  v27[1] = a1 + 16;
  *uint64_t v13 = 0;
  v13[1] = v8;
  BOOL v16 = *a5;
  *((_DWORD *)v13 + 4) = **a4;
  OTL::Lookup::Lookup((uint64_t)(v13 + 3), v16);
  float v17 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v18 = *(float *)(a1 + 32);
  if (!v9 || (float)(v18 * (float)v9) < v17)
  {
    BOOL v19 = 1;
    if (v9 >= 3) {
      BOOL v19 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v9);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = v20;
    }
    std::__hash_table<std::__hash_value_type<unsigned int,OTL::Lookup>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,OTL::Lookup>>>::__rehash<true>(a1, v22);
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v9 <= v8) {
        unint64_t v11 = v8 % v9;
      }
      else {
        unint64_t v11 = v8;
      }
    }
    else
    {
      unint64_t v11 = (v9 - 1) & v8;
    }
  }
  uint64_t v23 = *(void *)a1;
  uint64_t v24 = *(void **)(*(void *)a1 + 8 * v11);
  if (v24)
  {
    *uint64_t v13 = *v24;
LABEL_38:
    *uint64_t v24 = v13;
    goto LABEL_39;
  }
  *uint64_t v13 = *v15;
  void *v15 = v13;
  *(void *)(v23 + 8 * v11) = v15;
  if (*v13)
  {
    unint64_t v25 = *(void *)(*v13 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v25 >= v9) {
        v25 %= v9;
      }
    }
    else
    {
      v25 &= v9 - 1;
    }
    uint64_t v24 = (void *)(*(void *)a1 + 8 * v25);
    goto LABEL_38;
  }
LABEL_39:
  v27[0] = 0;
  ++*(void *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned int,OTL::Lookup>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,OTL::Lookup>,void *>>>>::reset[abi:nn180100](v27, 0);
  return v13;
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned int,OTL::Lookup>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,OTL::Lookup>,void *>>>>::reset[abi:nn180100](uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  *a1 = a2;
  if (v2)
  {
    if (*((unsigned char *)a1 + 16)) {
      OTL::Lookup::~Lookup((OTL::Lookup *)(v2 + 24));
    }
    operator delete((void *)v2);
  }
}

uint64_t OTL::Lookup::Lookup(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  *(_WORD *)(a1 + 16) = *((_WORD *)a2 + 8);
  *(_OWORD *)a1 = v3;
  uint64_t v4 = *((void *)a2 + 3);
  *((void *)a2 + 3) = 0;
  *(void *)(a1 + 24) = v4;
  *(unsigned char *)(a1 + 32) = *((unsigned char *)a2 + 32);
  unsigned int v5 = *((_DWORD *)a2 + 10);
  *(_DWORD *)(a1 + 40) = v5;
  *(_WORD *)(a1 + 44) = *((_WORD *)a2 + 22);
  *(void *)(a1 + 80) = a1 + 46;
  if (v5 >= 2)
  {
    unint64_t v6 = (long long *)*((void *)a2 + 10);
    if (v6 == (long long *)((char *)a2 + 46))
    {
      long long v7 = *v6;
      *(_OWORD *)(a1 + 60) = *(long long *)((char *)v6 + 14);
      *(_OWORD *)(a1 + 46) = v7;
    }
    else
    {
      *(void *)(a1 + 80) = v6;
      *((void *)a2 + 10) = (char *)a2 + 46;
    }
  }
  unint64_t v9 = (long long *)*((void *)a2 + 11);
  unint64_t v8 = (long long *)*((void *)a2 + 12);
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 304) = a1 + 112;
  std::vector<std::pair<OTL::LookupSubtable const*,OTL::Coverage>,TInlineBufferAllocator<std::pair<OTL::LookupSubtable const*,OTL::Coverage>,4ul>>::__init_with_size[abi:nn180100]<std::__wrap_iter<std::pair<OTL::LookupSubtable const*,OTL::Coverage> const*>,std::__wrap_iter<std::pair<OTL::LookupSubtable const*,OTL::Coverage> const*>>((char *)(a1 + 88), v9, v8, 0xAAAAAAAAAAAAAAABLL * (v8 - v9));
  return a1;
}

char *std::vector<std::pair<OTL::LookupSubtable const*,OTL::Coverage>,TInlineBufferAllocator<std::pair<OTL::LookupSubtable const*,OTL::Coverage>,4ul>>::__init_with_size[abi:nn180100]<std::__wrap_iter<std::pair<OTL::LookupSubtable const*,OTL::Coverage> const*>,std::__wrap_iter<std::pair<OTL::LookupSubtable const*,OTL::Coverage> const*>>(char *result, long long *a2, long long *a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v6 = result;
    uint64_t result = std::vector<std::pair<OTL::LookupSubtable const*,OTL::Coverage>,TInlineBufferAllocator<std::pair<OTL::LookupSubtable const*,OTL::Coverage>,4ul>>::__vallocate[abi:nn180100](result, a4);
    long long v7 = (_OWORD *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      long long v8 = *a2;
      long long v9 = a2[2];
      v7[1] = a2[1];
      v7[2] = v9;
      *long long v7 = v8;
      v7 += 3;
      a2 += 3;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

char *std::vector<std::pair<OTL::LookupSubtable const*,OTL::Coverage>,TInlineBufferAllocator<std::pair<OTL::LookupSubtable const*,OTL::Coverage>,4ul>>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >= 0x555555555555556) {
    abort();
  }
  uint64_t result = (char *)TInlineBufferAllocator<std::pair<OTL::LookupSubtable const*,OTL::Coverage>,4ul>::allocate((uint64_t)(a1 + 3), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[48 * a2];
  return result;
}

void *std::vector<std::pair<OTL::LookupSubtable const*,OTL::Coverage>,TInlineBufferAllocator<std::pair<OTL::LookupSubtable const*,OTL::Coverage>,4ul>>::reserve(void *result, unint64_t a2)
{
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(result[2] - *result) >> 4) < a2)
  {
    if (a2 >= 0x555555555555556) {
      abort();
    }
    long long v3 = (char **)result;
    uint64_t v4 = (result[1] - *result) / 48;
    BOOL v16 = result + 3;
    unsigned int v5 = (char *)TInlineBufferAllocator<std::pair<OTL::LookupSubtable const*,OTL::Coverage>,4ul>::allocate((uint64_t)(result + 3), a2);
    long long v7 = *v3;
    unint64_t v6 = (unint64_t)v3[1];
    if ((char *)v6 == *v3)
    {
      int64x2_t v11 = vdupq_n_s64(v6);
      long long v8 = &v5[48 * v4];
    }
    else
    {
      long long v8 = &v5[48 * v4];
      do
      {
        long long v9 = *(_OWORD *)(v6 - 48);
        long long v10 = *(_OWORD *)(v6 - 16);
        *((_OWORD *)v8 - 2) = *(_OWORD *)(v6 - 32);
        *((_OWORD *)v8 - 1) = v10;
        *((_OWORD *)v8 - 3) = v9;
        v8 -= 48;
        v6 -= 48;
      }
      while ((char *)v6 != v7);
      int64x2_t v11 = *(int64x2_t *)v3;
    }
    *long long v3 = v8;
    v3[1] = &v5[48 * v4];
    int64x2_t v14 = v11;
    unint64_t v12 = v3[2];
    v3[2] = &v5[48 * a2];
    unint64_t v15 = v12;
    uint64_t v13 = v11.i64[0];
    return (void *)std::__split_buffer<std::pair<OTL::LookupSubtable const*,OTL::Coverage>,TInlineBufferAllocator<std::pair<OTL::LookupSubtable const*,OTL::Coverage>,4ul> &>::~__split_buffer((uint64_t)&v13);
  }
  return result;
}

void *TInlineBufferAllocator<std::pair<OTL::LookupSubtable const*,OTL::Coverage>,4ul>::allocate(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 192);
  uint64_t v2 = (unint64_t *)(a1 + 192);
  uint64_t v3 = v4;
  unint64_t v5 = v4 + 48 * a2;
  if (v5 <= (unint64_t)v2)
  {
    *uint64_t v2 = v5;
    return (void *)v3;
  }
  else
  {
    if (a2 >= 0x555555555555556) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    return operator new(48 * a2);
  }
}

uint64_t std::__split_buffer<std::pair<OTL::LookupSubtable const*,OTL::Coverage>,TInlineBufferAllocator<std::pair<OTL::LookupSubtable const*,OTL::Coverage>,4ul> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != *(void *)(a1 + 8)) {
    *(void *)(a1 + 16) = (v2 - *(void *)(a1 + 8) - 48) % 0x30uLL + *(void *)(a1 + 8);
  }
  uint64_t v3 = *(void **)a1;
  if (*(void *)a1)
  {
    unint64_t v4 = *(void *)(a1 + 32);
    unint64_t v5 = (void *)(v4 + 192);
    if (v4 <= (unint64_t)v3 && v5 > v3)
    {
      if (*(void *)(a1 + 24) == *v5) {
        *unint64_t v5 = v3;
      }
    }
    else
    {
      operator delete(v3);
    }
  }
  return a1;
}

char *OTL::Lookup::InitCoverageUnion(char *this)
{
  void v16[4] = *MEMORY[0x1E4F143B8];
  if (!this[32])
  {
    uint64_t v1 = this;
    this[32] = 1;
    uint64_t v2 = *((void *)this + 11);
    uint64_t v3 = *((void *)this + 12);
    if (v2 != v3)
    {
      char v4 = 0;
      unsigned __int16 v5 = 0;
      unsigned __int16 v6 = -1;
      do
      {
        unsigned int v7 = *(unsigned __int16 *)(v2 + 40);
        unsigned int v8 = *(unsigned __int16 *)(v2 + 42);
        unsigned __int16 v9 = v6;
        if (v7 < v6) {
          unsigned __int16 v9 = *(_WORD *)(v2 + 40);
        }
        unsigned __int16 v10 = v5;
        if (v5 <= v8) {
          unsigned __int16 v10 = *(_WORD *)(v2 + 42);
        }
        BOOL v11 = v7 > v8;
        BOOL v12 = v7 <= v8;
        if (!v11)
        {
          unsigned __int16 v5 = v10;
          unsigned __int16 v6 = v9;
        }
        v4 |= v12;
        v2 += 48;
      }
      while (v2 != v3);
      if (v4)
      {
        if (v6 == v5)
        {
          *((_DWORD *)this + 10) = 1;
          *((_WORD *)this + 22) = v5;
        }
        else
        {
          uint64_t v13 = this + 40;
          this = (char *)OTL::CoverageBitmap::Reset((_DWORD *)this + 10, v6, v5);
          uint64_t v14 = v1[11];
          for (uint64_t i = v1[12]; v14 != i; v14 += 48)
          {
            v16[0] = &unk_1ED061AA8;
            v16[1] = v13;
            v16[3] = v16;
            OTL::Coverage::Iterate((void *)(v14 + 8), (uint64_t)v16);
            this = (char *)std::__function::__value_func<BOOL ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100](v16);
          }
        }
      }
    }
  }
  return this;
}

uint64_t std::__function::__func<TOpenTypeMorph::AddShapingGlyphs(TFont const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(unsigned int)>,std::function<void ()(void)>)::$_0::operator() const(unsigned int,OTL::ScriptTable const*,BOOL &)::{lambda(unsigned int,OTL::LangSysTable const*,BOOL &)#1},std::allocator<TOpenTypeMorph::AddShapingGlyphs(TFont const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(unsigned int)>,std::function<void ()(void)>)::$_0::operator() const(unsigned int,OTL::ScriptTable const*,BOOL &)::{lambda(unsigned int,OTL::LangSysTable const*,BOOL &)#1}>,BOOL ()(unsigned int,OTL::LangSysTable const*,BOOL &)>::operator()(uint64_t a1, unsigned int *a2)
{
  v57[4] = *MEMORY[0x1E4F143B8];
  unsigned int v3 = *a2;
  unint64_t v39 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v37[3] = v4;
  long long v38 = v4;
  v37[1] = v4;
  v37[2] = v4;
  v37[0] = v4;
  OTL::GCommon::GCommon((uint64_t)v37, 0, *(unsigned char **)(a1 + 16), **(CFDataRef **)(a1 + 24), *(void *)(a1 + 32), *(_DWORD *)(a1 + 8), v3);
  *(void *)&v37[0] = &unk_1ED05FB20;
  if (HIDWORD(v38) && HIDWORD(v38) != *(_DWORD *)(a1 + 8)) {
    return 1;
  }
  if (v3) {
    std::function<void ()>::operator()(*(void *)(a1 + 40), v3);
  }
  int v6 = DWORD2(v38);
  if (SDWORD2(v38) > 1818324767)
  {
    if (DWORD2(v38) == 1818324768)
    {
      LaoClassTable = GetLaoClassTable();
      goto LABEL_17;
    }
    if (DWORD2(v38) == 1952997737)
    {
      LaoClassTable = GetThaiClassTable();
      goto LABEL_17;
    }
LABEL_20:
    uint64_t v13 = *(void **)(a1 + 16);
    uint64_t v14 = (uint64_t *)(a1 + 48);
    if (!v3) {
      uint64_t v14 = (uint64_t *)(a1 + 56);
    }
    std::__function::__value_func<void ()(unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)v57, *v14);
    UniversalShapingEngine::AddShapingGlyphsForScript(v13, v6, (uint64_t)v57);
    goto LABEL_23;
  }
  if (DWORD2(v38) == 1751215719)
  {
    uint64_t v8 = *(void *)(a1 + 16);
    unsigned __int16 v9 = (uint64_t *)(a1 + 48);
    if (!v3) {
      unsigned __int16 v9 = (uint64_t *)(a1 + 56);
    }
    std::__function::__value_func<void ()(unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)v57, *v9);
    HangulShapingEngine::AddShapingGlyphs(v8, (uint64_t)v57);
    goto LABEL_23;
  }
  if (DWORD2(v38) != 1802005874) {
    goto LABEL_20;
  }
  LaoClassTable = GetKhmerClassTable();
LABEL_17:
  uint64_t v10 = (uint64_t)LaoClassTable;
  uint64_t v11 = *(void *)(a1 + 16);
  BOOL v12 = (uint64_t *)(a1 + 48);
  if (!v3) {
    BOOL v12 = (uint64_t *)(a1 + 56);
  }
  std::__function::__value_func<void ()(unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)v57, *v12);
  OpenTypeClassTable::AddShapingGlyphs(v10, v11, (uint64_t)v57);
LABEL_23:
  std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100](v57);
  *(void *)&long long v15 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v55[8] = v15;
  v55[7] = v15;
  v55[6] = v15;
  v55[5] = v15;
  v55[4] = v15;
  v55[3] = v15;
  v55[2] = v15;
  v55[1] = v15;
  v55[0] = v15;
  int v52 = 0;
  v53 = 0;
  uint64_t v54 = 0;
  long long v56 = v55;
  OTL::GCommon::GetFeatures((OTL::GCommon *)v37, (OTL::FeatureList *)&v52);
  *(void *)&long long v16 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v50[14] = v16;
  v50[13] = v16;
  v50[12] = v16;
  v50[11] = v16;
  v50[10] = v16;
  v50[9] = v16;
  v50[8] = v16;
  v50[7] = v16;
  v50[6] = v16;
  v50[5] = v16;
  v50[4] = v16;
  v50[3] = v16;
  v50[2] = v16;
  v50[1] = v16;
  v50[0] = v16;
  int64x2_t v48 = 0uLL;
  unint64_t v49 = 0;
  v51 = v50;
  float v17 = v52;
  for (uint64_t i = v53; v17 != i; ++v17)
  {
    unsigned int v19 = *v17;
    if (IsOTFeatureTurnedOnByShapingEngine(*v17))
    {
      uint64_t v20 = v48.i64[1];
      if (v48.i64[1] >= v49)
      {
        uint64_t v22 = (v48.i64[1] - v48.i64[0]) >> 3;
        unint64_t v23 = v22 + 1;
        if ((unint64_t)(v22 + 1) >> 61) {
          abort();
        }
        uint64_t v24 = v49 - v48.i64[0];
        if ((uint64_t)(v49 - v48.i64[0]) >> 2 > v23) {
          unint64_t v23 = v24 >> 2;
        }
        if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v25 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v25 = v23;
        }
        *((void *)&v45[0] + 1) = v50;
        uint64_t v26 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v50, v25);
        int64x2_t v27 = (unsigned int *)&v26[8 * v22];
        *int64x2_t v27 = v19;
        v27[1] = 1;
        uint64_t v28 = v48.i64[1];
        uint64_t v29 = v48.i64[0];
        if (v48.i64[1] == v48.i64[0])
        {
          int64x2_t v32 = vdupq_n_s64(v48.u64[1]);
          uint64_t v30 = (uint64_t)&v26[8 * v22];
        }
        else
        {
          uint64_t v30 = (uint64_t)&v26[8 * v22];
          do
          {
            uint64_t v31 = *(void *)(v28 - 8);
            v28 -= 8;
            *(void *)(v30 - 8) = v31;
            v30 -= 8;
          }
          while (v28 != v29);
          int64x2_t v32 = v48;
        }
        uint64_t v21 = (uint64_t)(v27 + 2);
        v48.i64[0] = v30;
        v48.i64[1] = (uint64_t)(v27 + 2);
        int64x2_t v44 = v32;
        unint64_t v33 = v49;
        unint64_t v49 = (unint64_t)&v26[8 * v25];
        *(void *)&v45[0] = v33;
        int v43 = (int64x2_t *)v32.i64[0];
        std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v43);
      }
      else
      {
        *(_DWORD *)v48.i64[1] = v19;
        *(_DWORD *)(v20 + 4) = 1;
        uint64_t v21 = v20 + 8;
      }
      v48.i64[1] = v21;
    }
  }
  ConvertSettingsToOTFeatures(&v52, (atomic_ullong *)(*(void *)(a1 + 16) + 168), **(_DWORD **)(a1 + 16) & 1, &v48, 0, 0, 1);
  *(void *)&long long v34 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v34 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v45[6] = v34;
  v45[5] = v34;
  v45[4] = v34;
  v45[3] = v34;
  v45[2] = v34;
  v45[1] = v34;
  v45[0] = v34;
  unint64_t v46 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v47 = v45;
  int64x2_t v44 = 0uLL;
  int v43 = 0;
  OTL::GCommon::GetLookups((uint64_t)v37, (uint64_t)&v48, (uint64_t)&v43, 1);
  long long v35 = (uint64_t *)(a1 + 48);
  if (!v3) {
    long long v35 = (uint64_t *)(a1 + 56);
  }
  std::__function::__value_func<void ()(unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)v42, *v35);
  std::__function::__value_func<void ()(void)>::__value_func[abi:nn180100]((uint64_t)v41, *(void *)(a1 + 64));
  uint64_t v5 = OTL::GSUB::AddShapingGlyphs(v37, (unsigned __int16 **)&v43, (uint64_t)v42, (uint64_t)v41);
  std::__function::__value_func<void ()(void)>::~__value_func[abi:nn180100](v41);
  std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100](v42);
  char v40 = &v43;
  std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v40);
  int v43 = &v48;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v43);
  v48.i64[0] = (uint64_t)&v52;
  std::vector<unsigned int,TInlineBufferAllocator<unsigned int,36ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v48);
  return v5;
}

BOOL IsOTFeatureTurnedOnByShapingEngine(unsigned int a1)
{
  unsigned int v2 = a1;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB2CE4D8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB2CE4D8))
  {
    xmmword_1EB2CE578 = 0u;
    unk_1EB2CE588 = 0u;
    dword_1EB2CE598 = 1065353216;
    __cxa_guard_release(&qword_1EB2CE4D8);
  }
  if (qword_1EB2CE4E0 != -1) {
    dispatch_once_f(&qword_1EB2CE4E0, 0, (dispatch_function_t)IsOTFeatureTurnedOnByShapingEngine::$_0::__invoke);
  }
  return std::__hash_table<std::__hash_value_type<unsigned int,OTL::Lookup>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,OTL::Lookup>>>::find<unsigned int>(&xmmword_1EB2CE578, &v2) != 0;
}

uint64_t *std::__hash_table<std::__hash_value_type<unsigned int,OTL::Lookup>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,OTL::Lookup>>>::find<unsigned int>(void *a1, unsigned int *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = *a2;
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v5 = *a2;
    if (*(void *)&v2 <= v3) {
      unint64_t v5 = v3 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v5 = (v2.i32[0] - 1) & v3;
  }
  int v6 = *(uint64_t ***)(*a1 + 8 * v5);
  if (!v6) {
    return 0;
  }
  for (uint64_t result = *v6; result; uint64_t result = (uint64_t *)*result)
  {
    unint64_t v8 = result[1];
    if (v8 == v3)
    {
      if (*((_DWORD *)result + 4) == v3) {
        return result;
      }
    }
    else
    {
      if (v4.u32[0] > 1uLL)
      {
        if (v8 >= *(void *)&v2) {
          v8 %= *(void *)&v2;
        }
      }
      else
      {
        v8 &= *(void *)&v2 - 1;
      }
      if (v8 != v5) {
        return 0;
      }
    }
  }
  return result;
}

BOOL OTL::GCommon::GetFeatures(OTL::GCommon *this, OTL::FeatureList *a2)
{
  unint64_t v3 = (unsigned __int16 *)*((void *)this + 7);
  if (v3)
  {
    uint64_t v5 = *((void *)this + 6);
    if (v5)
    {
      unsigned int v6 = *v3;
      unsigned int v7 = *(unsigned __int16 *)(v5 + 4);
      unint64_t v8 = __rev16(v7);
      std::vector<unsigned int,TInlineBufferAllocator<unsigned int,36ul>>::resize((uint64_t)a2, v8);
      uint64_t v9 = *(void *)a2;
      if (v7)
      {
        unint64_t v10 = 0;
        unsigned int v11 = bswap32(v6) >> 16;
        if (v8 <= 1) {
          uint64_t v12 = 1;
        }
        else {
          uint64_t v12 = v8;
        }
        uint64_t v13 = *((void *)this + 6) + 6;
        while (1)
        {
          unsigned int v14 = bswap32(*(unsigned __int16 *)(v13 + 2 * v10)) >> 16;
          if (v14 >= v11) {
            break;
          }
          *(_DWORD *)(v9 + 4 * v10++) = bswap32(*(_DWORD *)(*((void *)this + 7) + 6 * v14 + 2));
          if (v12 == v10) {
            goto LABEL_12;
          }
        }
        std::vector<unsigned int,TInlineBufferAllocator<unsigned int,36ul>>::resize((uint64_t)a2, v10);
      }
LABEL_12:
      std::__sort<std::__less<unsigned int,unsigned int> &,unsigned int *>();
    }
  }
  return *(void *)a2 != *((void *)a2 + 1);
}

void std::vector<unsigned int,TInlineBufferAllocator<unsigned int,36ul>>::__append(char **a1, unint64_t a2)
{
  uint64_t v5 = a1[1];
  uint8x8_t v4 = a1[2];
  if (a2 <= (v4 - v5) >> 2)
  {
    if (a2)
    {
      bzero(a1[1], 4 * a2);
      v5 += 4 * a2;
    }
    a1[1] = v5;
  }
  else
  {
    unint64_t v7 = (unint64_t)(a1 + 3);
    unsigned int v6 = *a1;
    uint64_t v8 = v5 - *a1;
    unint64_t v9 = a2 + (v8 >> 2);
    if (v9 >> 62) {
      abort();
    }
    unint64_t v10 = v4 - v6;
    unint64_t v11 = (v4 - v6) >> 1;
    if (v11 <= v9) {
      unint64_t v11 = a2 + (v8 >> 2);
    }
    if (v10 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    if (v12)
    {
      uint64_t v13 = a1[21];
      unint64_t v14 = (unint64_t)&v13[4 * v12];
      if (v14 <= (unint64_t)(a1 + 21))
      {
        a1[21] = (char *)v14;
      }
      else
      {
        if (v12 >> 62) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        uint64_t v13 = (char *)operator new(4 * v12);
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    long long v15 = &v13[4 * (v8 >> 2)];
    long long v16 = &v13[4 * v12];
    bzero(v15, 4 * a2);
    float v17 = &v15[4 * a2];
    while (v5 != v6)
    {
      int v18 = *((_DWORD *)v5 - 1);
      v5 -= 4;
      *((_DWORD *)v15 - 1) = v18;
      v15 -= 4;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v6)
    {
      if (v7 > (unint64_t)v6 || (unsigned int v19 = (void **)(a1 + 21), a1 + 21 <= (char **)v6))
      {
        operator delete(v6);
      }
      else if (&v6[v10] == *v19)
      {
        *unsigned int v19 = v6;
      }
    }
  }
}

void std::vector<unsigned int,TInlineBufferAllocator<unsigned int,36ul>>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 2;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 4 * a2;
    }
  }
  else
  {
    std::vector<unsigned int,TInlineBufferAllocator<unsigned int,36ul>>::__append((char **)a1, a2 - v2);
  }
}

void std::vector<unsigned int,TInlineBufferAllocator<unsigned int,36ul>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = (void **)**a1;
  if (v2)
  {
    v1[1] = v2;
    unint64_t v3 = v1 + 21;
    if (v1 + 3 <= v2)
    {
      BOOL v4 = v3 >= v2;
      BOOL v5 = v3 == v2;
    }
    else
    {
      BOOL v4 = 0;
      BOOL v5 = 0;
    }
    if (!v5 && v4)
    {
      if (v1[2] == v1[21]) {
        *unint64_t v3 = v2;
      }
    }
    else
    {
      operator delete(v2);
    }
  }
}

char **OTL::FeatureBuffer::FeatureBuffer<unsigned int const*>(char **a1, _DWORD *a2, _DWORD *a3)
{
  *a1 = 0;
  a1[1] = 0;
  uint64_t v4 = (uint64_t)(a1 + 3);
  a1[2] = 0;
  a1[33] = (char *)(a1 + 3);
  if (a2 != a3)
  {
    unsigned int v6 = a2;
    unint64_t v7 = 0;
    do
    {
      unint64_t v8 = (unint64_t)a1[2];
      if ((unint64_t)v7 >= v8)
      {
        uint64_t v9 = (v7 - *a1) >> 3;
        if ((unint64_t)(v9 + 1) >> 61) {
          abort();
        }
        uint64_t v10 = v8 - (void)*a1;
        uint64_t v11 = v10 >> 2;
        if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
          uint64_t v11 = v9 + 1;
        }
        if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v12 = v11;
        }
        uint64_t v25 = v4;
        uint64_t v13 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate(v4, v12);
        unint64_t v14 = &v13[8 * v9];
        *(_DWORD *)unint64_t v14 = *v6;
        *((_DWORD *)v14 + 1) = 1;
        long long v16 = *a1;
        unint64_t v15 = (unint64_t)a1[1];
        if ((char *)v15 == *a1)
        {
          int64x2_t v19 = vdupq_n_s64(v15);
          float v17 = &v13[8 * v9];
        }
        else
        {
          float v17 = &v13[8 * v9];
          do
          {
            uint64_t v18 = *(void *)(v15 - 8);
            v15 -= 8;
            *((void *)v17 - 1) = v18;
            v17 -= 8;
          }
          while ((char *)v15 != v16);
          int64x2_t v19 = *(int64x2_t *)a1;
        }
        unint64_t v7 = v14 + 8;
        *a1 = v17;
        a1[1] = v14 + 8;
        int64x2_t v23 = v19;
        uint64_t v20 = a1[2];
        a1[2] = &v13[8 * v12];
        uint64_t v24 = v20;
        uint64_t v22 = v19.i64[0];
        std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v22);
      }
      else
      {
        *(_DWORD *)unint64_t v7 = *v6;
        *((_DWORD *)v7 + 1) = 1;
        v7 += 8;
      }
      a1[1] = v7;
      ++v6;
    }
    while (v6 != a3);
  }
  return a1;
}

void *TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 240);
  unint64_t v2 = (unint64_t *)(a1 + 240);
  uint64_t v3 = v4;
  unint64_t v5 = v4 + 8 * a2;
  if (v5 <= (unint64_t)v2)
  {
    *unint64_t v2 = v5;
    return (void *)v3;
  }
  else
  {
    if (a2 >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    return operator new(8 * a2);
  }
}

uint64_t std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3) {
    *(void *)(a1 + 16) = v2 + ((v3 - v2 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  uint64_t v4 = *(void **)a1;
  if (*(void *)a1)
  {
    unint64_t v5 = *(void *)(a1 + 32);
    unsigned int v6 = (void *)(v5 + 240);
    if (v5 <= (unint64_t)v4 && v6 > v4)
    {
      if (*(void *)(a1 + 24) == *v6) {
        *unsigned int v6 = v4;
      }
    }
    else
    {
      operator delete(v4);
    }
  }
  return a1;
}

void *UniversalShapingEngine::AddShapingGlyphsForScript(void *result, int a2, uint64_t a3)
{
  v5[4] = *MEMORY[0x1E4F143B8];
  if (a2 != 1145457748)
  {
    uint64_t v4 = (uint64_t)result;
    std::__function::__value_func<void ()(unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)v5, a3);
    UniversalClassTable::AddShapingGlyphsForScript(v4, a2, (uint64_t)v5);
    return std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100](v5);
  }
  return result;
}

uint64_t UniversalClassTable::AddShapingGlyphsForScript(uint64_t a1, int a2, uint64_t a3)
{
  int v3 = a2;
  char v4 = 0;
  uint64_t v151 = *MEMORY[0x1E4F143B8];
  unint64_t v5 = "****-";
  do
  {
    if (*(_DWORD *)v5 != v3) {
      goto LABEL_229;
    }
    uint64_t v6 = *((unsigned __int16 *)v5 + 6);
    *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v149[4] = v7;
    v149[5] = v7;
    v149[2] = v7;
    v149[3] = v7;
    v149[0] = v7;
    v149[1] = v7;
    v146 = 0;
    v147 = 0;
    v148 = 0;
    v150 = v149;
    unsigned int v8 = *((_DWORD *)v5 + 1);
    unsigned int v9 = v8 + *((unsigned __int16 *)v5 + 4);
    unsigned int v10 = v9 + *((unsigned __int16 *)v5 + 5);
    if (v8 > v10) {
      goto LABEL_228;
    }
    v140 = (char *)&kClassDataTable + 2 * v6;
    unsigned int v11 = v9 - 1;
    unsigned int v12 = *((_DWORD *)v5 + 1);
    do
    {
      if (v12 <= v11) {
        __int16 v13 = *(_WORD *)&v140[2 * (v12 - v8)];
      }
      else {
        __int16 v13 = UniversalClassTable::determineCharClass(v12);
      }
      if ((v13 & 0x8FE) == 0x812)
      {
        if (!HIWORD(v8))
        {
          unint64_t v14 = v147;
          if (v147 >= (__int16 *)v148)
          {
            unint64_t v15 = v146;
            uint64_t v16 = (char *)v147 - (char *)v146;
            if ((char *)v147 - (char *)v146 <= -3) {
              goto LABEL_231;
            }
            uint64_t v17 = v16 >> 1;
            if (v148 - (char *)v146 <= (unint64_t)((v16 >> 1) + 1)) {
              uint64_t v18 = v17 + 1;
            }
            else {
              uint64_t v18 = v148 - (char *)v146;
            }
            if ((unint64_t)(v148 - (char *)v146) >= 0x7FFFFFFFFFFFFFFELL) {
              uint64_t v19 = 0x7FFFFFFFFFFFFFFFLL;
            }
            else {
              uint64_t v19 = v18;
            }
            *((void *)&v144[0] + 1) = v149;
            if (v19)
            {
              uint64_t v20 = (char *)TInlineBufferAllocator<unsigned short,48ul>::allocate((uint64_t)v149, v19);
              unint64_t v15 = v146;
              unint64_t v14 = v147;
            }
            else
            {
              uint64_t v20 = 0;
            }
            uint64_t v54 = &v20[2 * v17];
            *(_WORD *)uint64_t v54 = v12;
            if (v14 == v15) {
              goto LABEL_191;
            }
            uint64_t v55 = v14;
            long long v56 = &v20[2 * v17];
            do
            {
              __int16 v57 = *--v55;
              *((_WORD *)v56 - 1) = v57;
              v56 -= 2;
            }
            while (v55 != v15);
            goto LABEL_192;
          }
          goto LABEL_41;
        }
        int v25 = (v12 >> 10) - 10304;
        uint64_t v26 = v147;
        unint64_t v27 = (unint64_t)v148;
        if (v147 >= (__int16 *)v148)
        {
          uint64_t v30 = v146;
          uint64_t v31 = (char *)v147 - (char *)v146;
          if ((char *)v147 - (char *)v146 <= -3) {
            goto LABEL_231;
          }
          uint64_t v32 = v31 >> 1;
          if (v148 - (char *)v146 <= (unint64_t)((v31 >> 1) + 1)) {
            uint64_t v33 = v32 + 1;
          }
          else {
            uint64_t v33 = v148 - (char *)v146;
          }
          if ((unint64_t)(v148 - (char *)v146) >= 0x7FFFFFFFFFFFFFFELL) {
            uint64_t v34 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v34 = v33;
          }
          *((void *)&v144[0] + 1) = v149;
          if (v34)
          {
            long long v35 = (char *)TInlineBufferAllocator<unsigned short,48ul>::allocate((uint64_t)v149, v34);
            uint64_t v30 = v146;
            uint64_t v26 = v147;
          }
          else
          {
            long long v35 = 0;
          }
          long long v58 = &v35[2 * v32];
          *(_WORD *)long long v58 = v25;
          if (v26 == v30)
          {
            long long v60 = &v35[2 * v32];
          }
          else
          {
            v59 = v26;
            long long v60 = &v35[2 * v32];
            do
            {
              __int16 v61 = *--v59;
              *((_WORD *)v60 - 1) = v61;
              v60 -= 2;
            }
            while (v59 != v30);
          }
          uint64_t v28 = (__int16 *)(v58 + 2);
          v146 = (__int16 *)v60;
          v147 = (__int16 *)(v58 + 2);
          v62 = v148;
          v148 = &v35[2 * v34];
          v143 = (char *)v26;
          *(void *)&v144[0] = v62;
          v141 = v30;
          v142 = v30;
          std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,48ul> &>::~__split_buffer((uint64_t)&v141);
          unint64_t v27 = (unint64_t)v148;
        }
        else
        {
          __int16 *v147 = v25;
          uint64_t v28 = v26 + 1;
        }
        v147 = v28;
        __int16 v63 = v12 & 0x3FF | 0xDC00;
        if ((unint64_t)v28 >= v27)
        {
          float64x2_t v64 = v146;
          uint64_t v65 = (char *)v28 - (char *)v146;
          if ((char *)v28 - (char *)v146 <= -3) {
            goto LABEL_231;
          }
          uint64_t v66 = v65 >> 1;
          unint64_t v67 = v27 - (void)v146;
          if (v67 <= (v65 >> 1) + 1) {
            unint64_t v68 = v66 + 1;
          }
          else {
            unint64_t v68 = v67;
          }
          if (v67 >= 0x7FFFFFFFFFFFFFFELL) {
            uint64_t v69 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v69 = v68;
          }
          *((void *)&v144[0] + 1) = v149;
          if (v69)
          {
            long long v70 = (char *)TInlineBufferAllocator<unsigned short,48ul>::allocate((uint64_t)v149, v69);
            float64x2_t v64 = v146;
            uint64_t v28 = v147;
          }
          else
          {
            long long v70 = 0;
          }
          long long v71 = &v70[2 * v66];
          *(_WORD *)long long v71 = v63;
          if (v28 == v64) {
            goto LABEL_216;
          }
          long long v72 = v28;
          long long v73 = &v70[2 * v66];
          do
          {
            __int16 v74 = *--v72;
            *((_WORD *)v73 - 1) = v74;
            v73 -= 2;
          }
          while (v72 != v64);
          goto LABEL_217;
        }
LABEL_201:
        *uint64_t v28 = v63;
        uint64_t v29 = v28 + 1;
        goto LABEL_218;
      }
      if ((v13 & 0x1000) != 0)
      {
        if (!HIWORD(v8))
        {
          unint64_t v14 = v147;
          if (v147 >= (__int16 *)v148)
          {
            unint64_t v15 = v146;
            uint64_t v45 = (char *)v147 - (char *)v146;
            if ((char *)v147 - (char *)v146 <= -3) {
              goto LABEL_231;
            }
            uint64_t v46 = v45 >> 1;
            if (v148 - (char *)v146 <= (unint64_t)((v45 >> 1) + 1)) {
              uint64_t v47 = v46 + 1;
            }
            else {
              uint64_t v47 = v148 - (char *)v146;
            }
            if ((unint64_t)(v148 - (char *)v146) >= 0x7FFFFFFFFFFFFFFELL) {
              uint64_t v19 = 0x7FFFFFFFFFFFFFFFLL;
            }
            else {
              uint64_t v19 = v47;
            }
            *((void *)&v144[0] + 1) = v149;
            if (v19)
            {
              uint64_t v20 = (char *)TInlineBufferAllocator<unsigned short,48ul>::allocate((uint64_t)v149, v19);
              unint64_t v15 = v146;
              unint64_t v14 = v147;
            }
            else
            {
              uint64_t v20 = 0;
            }
            uint64_t v54 = &v20[2 * v46];
            *(_WORD *)uint64_t v54 = v12;
            if (v14 != v15)
            {
              unint64_t v84 = v14;
              long long v56 = &v20[2 * v46];
              do
              {
                __int16 v85 = *--v84;
                *((_WORD *)v56 - 1) = v85;
                v56 -= 2;
              }
              while (v84 != v15);
              goto LABEL_192;
            }
            goto LABEL_191;
          }
          goto LABEL_41;
        }
        int v36 = (v12 >> 10) - 10304;
        unint64_t v37 = v147;
        unint64_t v38 = (unint64_t)v148;
        if (v147 >= (__int16 *)v148)
        {
          int64x2_t v48 = v146;
          uint64_t v49 = (char *)v147 - (char *)v146;
          if ((char *)v147 - (char *)v146 <= -3) {
            goto LABEL_231;
          }
          uint64_t v50 = v49 >> 1;
          if (v148 - (char *)v146 <= (unint64_t)((v49 >> 1) + 1)) {
            uint64_t v51 = v50 + 1;
          }
          else {
            uint64_t v51 = v148 - (char *)v146;
          }
          if ((unint64_t)(v148 - (char *)v146) >= 0x7FFFFFFFFFFFFFFELL) {
            uint64_t v52 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v52 = v51;
          }
          *((void *)&v144[0] + 1) = v149;
          if (v52)
          {
            v53 = (char *)TInlineBufferAllocator<unsigned short,48ul>::allocate((uint64_t)v149, v52);
            int64x2_t v48 = v146;
            unint64_t v37 = v147;
          }
          else
          {
            v53 = 0;
          }
          v86 = &v53[2 * v50];
          *(_WORD *)v86 = v36;
          if (v37 == v48)
          {
            v88 = &v53[2 * v50];
          }
          else
          {
            v87 = v37;
            v88 = &v53[2 * v50];
            do
            {
              __int16 v89 = *--v87;
              *((_WORD *)v88 - 1) = v89;
              v88 -= 2;
            }
            while (v87 != v48);
          }
          uint64_t v28 = (__int16 *)(v86 + 2);
          v146 = (__int16 *)v88;
          v147 = (__int16 *)(v86 + 2);
          v90 = v148;
          v148 = &v53[2 * v52];
          v143 = (char *)v37;
          *(void *)&v144[0] = v90;
          v141 = v48;
          v142 = v48;
          std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,48ul> &>::~__split_buffer((uint64_t)&v141);
          unint64_t v38 = (unint64_t)v148;
        }
        else
        {
          __int16 *v147 = v36;
          uint64_t v28 = v37 + 1;
        }
        v147 = v28;
        __int16 v63 = v12 & 0x3FF | 0xDC00;
        if ((unint64_t)v28 >= v38)
        {
          float64x2_t v64 = v146;
          uint64_t v91 = (char *)v28 - (char *)v146;
          if ((char *)v28 - (char *)v146 <= -3) {
            goto LABEL_231;
          }
          uint64_t v92 = v91 >> 1;
          unint64_t v93 = v38 - (void)v146;
          if (v93 <= (v91 >> 1) + 1) {
            unint64_t v94 = v92 + 1;
          }
          else {
            unint64_t v94 = v93;
          }
          if (v93 >= 0x7FFFFFFFFFFFFFFELL) {
            uint64_t v69 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v69 = v94;
          }
          *((void *)&v144[0] + 1) = v149;
          if (v69)
          {
            long long v70 = (char *)TInlineBufferAllocator<unsigned short,48ul>::allocate((uint64_t)v149, v69);
            float64x2_t v64 = v146;
            uint64_t v28 = v147;
          }
          else
          {
            long long v70 = 0;
          }
          long long v71 = &v70[2 * v92];
          *(_WORD *)long long v71 = v63;
          if (v28 != v64)
          {
            v95 = v28;
            long long v73 = &v70[2 * v92];
            do
            {
              __int16 v96 = *--v95;
              *((_WORD *)v73 - 1) = v96;
              v73 -= 2;
            }
            while (v95 != v64);
            goto LABEL_217;
          }
          goto LABEL_216;
        }
        goto LABEL_201;
      }
      if (v13 == 20 || v13 == 15)
      {
        if (!HIWORD(v8))
        {
          unint64_t v14 = v147;
          if (v147 >= (__int16 *)v148)
          {
            unint64_t v15 = v146;
            uint64_t v22 = (char *)v147 - (char *)v146;
            if ((char *)v147 - (char *)v146 <= -3) {
              goto LABEL_231;
            }
            uint64_t v23 = v22 >> 1;
            if (v148 - (char *)v146 <= (unint64_t)((v22 >> 1) + 1)) {
              uint64_t v24 = v23 + 1;
            }
            else {
              uint64_t v24 = v148 - (char *)v146;
            }
            if ((unint64_t)(v148 - (char *)v146) >= 0x7FFFFFFFFFFFFFFELL) {
              uint64_t v19 = 0x7FFFFFFFFFFFFFFFLL;
            }
            else {
              uint64_t v19 = v24;
            }
            *((void *)&v144[0] + 1) = v149;
            if (v19)
            {
              uint64_t v20 = (char *)TInlineBufferAllocator<unsigned short,48ul>::allocate((uint64_t)v149, v19);
              unint64_t v15 = v146;
              unint64_t v14 = v147;
            }
            else
            {
              uint64_t v20 = 0;
            }
            uint64_t v54 = &v20[2 * v23];
            *(_WORD *)uint64_t v54 = v12;
            if (v14 != v15)
            {
              v97 = v14;
              long long v56 = &v20[2 * v23];
              do
              {
                __int16 v98 = *--v97;
                *((_WORD *)v56 - 1) = v98;
                v56 -= 2;
              }
              while (v97 != v15);
              goto LABEL_192;
            }
            goto LABEL_191;
          }
          goto LABEL_41;
        }
        int v42 = (v12 >> 10) - 10304;
        int v43 = v147;
        unint64_t v44 = (unint64_t)v148;
        if (v147 >= (__int16 *)v148)
        {
          long long v75 = v146;
          uint64_t v76 = (char *)v147 - (char *)v146;
          if ((char *)v147 - (char *)v146 <= -3) {
            goto LABEL_231;
          }
          uint64_t v77 = v76 >> 1;
          if (v148 - (char *)v146 <= (unint64_t)((v76 >> 1) + 1)) {
            uint64_t v78 = v77 + 1;
          }
          else {
            uint64_t v78 = v148 - (char *)v146;
          }
          if ((unint64_t)(v148 - (char *)v146) >= 0x7FFFFFFFFFFFFFFELL) {
            uint64_t v79 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v79 = v78;
          }
          *((void *)&v144[0] + 1) = v149;
          if (v79)
          {
            long long v80 = (char *)TInlineBufferAllocator<unsigned short,48ul>::allocate((uint64_t)v149, v79);
            long long v75 = v146;
            int v43 = v147;
          }
          else
          {
            long long v80 = 0;
          }
          v99 = &v80[2 * v77];
          *(_WORD *)v99 = v42;
          if (v43 == v75)
          {
            v101 = &v80[2 * v77];
          }
          else
          {
            v100 = v43;
            v101 = &v80[2 * v77];
            do
            {
              __int16 v102 = *--v100;
              *((_WORD *)v101 - 1) = v102;
              v101 -= 2;
            }
            while (v100 != v75);
          }
          uint64_t v28 = (__int16 *)(v99 + 2);
          v146 = (__int16 *)v101;
          v147 = (__int16 *)(v99 + 2);
          v103 = v148;
          v148 = &v80[2 * v79];
          v143 = (char *)v43;
          *(void *)&v144[0] = v103;
          v141 = v75;
          v142 = v75;
          std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,48ul> &>::~__split_buffer((uint64_t)&v141);
          unint64_t v44 = (unint64_t)v148;
        }
        else
        {
          __int16 *v147 = v42;
          uint64_t v28 = v43 + 1;
        }
        v147 = v28;
        __int16 v63 = v12 & 0x3FF | 0xDC00;
        if ((unint64_t)v28 >= v44)
        {
          float64x2_t v64 = v146;
          uint64_t v104 = (char *)v28 - (char *)v146;
          if ((char *)v28 - (char *)v146 <= -3) {
            goto LABEL_231;
          }
          uint64_t v105 = v104 >> 1;
          unint64_t v106 = v44 - (void)v146;
          if (v106 <= (v104 >> 1) + 1) {
            unint64_t v107 = v105 + 1;
          }
          else {
            unint64_t v107 = v106;
          }
          if (v106 >= 0x7FFFFFFFFFFFFFFELL) {
            uint64_t v69 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v69 = v107;
          }
          *((void *)&v144[0] + 1) = v149;
          if (v69)
          {
            long long v70 = (char *)TInlineBufferAllocator<unsigned short,48ul>::allocate((uint64_t)v149, v69);
            float64x2_t v64 = v146;
            uint64_t v28 = v147;
          }
          else
          {
            long long v70 = 0;
          }
          long long v71 = &v70[2 * v105];
          *(_WORD *)long long v71 = v63;
          if (v28 != v64)
          {
            v108 = v28;
            long long v73 = &v70[2 * v105];
            do
            {
              __int16 v109 = *--v108;
              *((_WORD *)v73 - 1) = v109;
              v73 -= 2;
            }
            while (v108 != v64);
            goto LABEL_217;
          }
          goto LABEL_216;
        }
        goto LABEL_201;
      }
      if (((1 << u_charType(v12)) & 0x140) == 0) {
        goto LABEL_219;
      }
      if (HIWORD(v8))
      {
        int v81 = (v12 >> 10) - 10304;
        unint64_t v82 = v147;
        unint64_t v83 = (unint64_t)v148;
        if (v147 >= (__int16 *)v148)
        {
          v110 = v146;
          uint64_t v111 = (char *)v147 - (char *)v146;
          if ((char *)v147 - (char *)v146 <= -3) {
            goto LABEL_231;
          }
          uint64_t v112 = v111 >> 1;
          if (v148 - (char *)v146 <= (unint64_t)((v111 >> 1) + 1)) {
            uint64_t v113 = v112 + 1;
          }
          else {
            uint64_t v113 = v148 - (char *)v146;
          }
          if ((unint64_t)(v148 - (char *)v146) >= 0x7FFFFFFFFFFFFFFELL) {
            uint64_t v114 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v114 = v113;
          }
          *((void *)&v144[0] + 1) = v149;
          if (v114)
          {
            v115 = (char *)TInlineBufferAllocator<unsigned short,48ul>::allocate((uint64_t)v149, v114);
            v110 = v146;
            unint64_t v82 = v147;
          }
          else
          {
            v115 = 0;
          }
          v119 = &v115[2 * v112];
          *(_WORD *)v119 = v81;
          if (v82 == v110)
          {
            v121 = &v115[2 * v112];
          }
          else
          {
            v120 = v82;
            v121 = &v115[2 * v112];
            do
            {
              __int16 v122 = *--v120;
              *((_WORD *)v121 - 1) = v122;
              v121 -= 2;
            }
            while (v120 != v110);
          }
          uint64_t v28 = (__int16 *)(v119 + 2);
          v146 = (__int16 *)v121;
          v147 = (__int16 *)(v119 + 2);
          v123 = v148;
          v148 = &v115[2 * v114];
          v143 = (char *)v82;
          *(void *)&v144[0] = v123;
          v141 = v110;
          v142 = v110;
          std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,48ul> &>::~__split_buffer((uint64_t)&v141);
          unint64_t v83 = (unint64_t)v148;
        }
        else
        {
          __int16 *v147 = v81;
          uint64_t v28 = v82 + 1;
        }
        v147 = v28;
        __int16 v63 = v12 & 0x3FF | 0xDC00;
        if ((unint64_t)v28 < v83) {
          goto LABEL_201;
        }
        float64x2_t v64 = v146;
        uint64_t v124 = (char *)v28 - (char *)v146;
        if ((char *)v28 - (char *)v146 <= -3) {
          goto LABEL_231;
        }
        uint64_t v125 = v124 >> 1;
        unint64_t v126 = v83 - (void)v146;
        if (v126 <= (v124 >> 1) + 1) {
          unint64_t v127 = v125 + 1;
        }
        else {
          unint64_t v127 = v126;
        }
        if (v126 >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v69 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v69 = v127;
        }
        *((void *)&v144[0] + 1) = v149;
        if (v69)
        {
          long long v70 = (char *)TInlineBufferAllocator<unsigned short,48ul>::allocate((uint64_t)v149, v69);
          float64x2_t v64 = v146;
          uint64_t v28 = v147;
        }
        else
        {
          long long v70 = 0;
        }
        long long v71 = &v70[2 * v125];
        *(_WORD *)long long v71 = v63;
        if (v28 != v64)
        {
          v128 = v28;
          long long v73 = &v70[2 * v125];
          do
          {
            __int16 v129 = *--v128;
            *((_WORD *)v73 - 1) = v129;
            v73 -= 2;
          }
          while (v128 != v64);
          goto LABEL_217;
        }
LABEL_216:
        long long v73 = v71;
LABEL_217:
        uint64_t v29 = (__int16 *)(v71 + 2);
        v146 = (__int16 *)v73;
        v147 = (__int16 *)(v71 + 2);
        v130 = v148;
        v148 = &v70[2 * v69];
        v143 = (char *)v28;
        *(void *)&v144[0] = v130;
        v141 = v64;
        v142 = v64;
        std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,48ul> &>::~__split_buffer((uint64_t)&v141);
        goto LABEL_218;
      }
      unint64_t v14 = v147;
      if (v147 >= (__int16 *)v148)
      {
        unint64_t v15 = v146;
        uint64_t v39 = (char *)v147 - (char *)v146;
        if ((char *)v147 - (char *)v146 <= -3) {
          goto LABEL_231;
        }
        uint64_t v40 = v39 >> 1;
        if (v148 - (char *)v146 <= (unint64_t)((v39 >> 1) + 1)) {
          uint64_t v41 = v40 + 1;
        }
        else {
          uint64_t v41 = v148 - (char *)v146;
        }
        if ((unint64_t)(v148 - (char *)v146) >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v19 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v19 = v41;
        }
        *((void *)&v144[0] + 1) = v149;
        if (v19)
        {
          uint64_t v20 = (char *)TInlineBufferAllocator<unsigned short,48ul>::allocate((uint64_t)v149, v19);
          unint64_t v15 = v146;
          unint64_t v14 = v147;
        }
        else
        {
          uint64_t v20 = 0;
        }
        uint64_t v54 = &v20[2 * v40];
        *(_WORD *)uint64_t v54 = v12;
        if (v14 != v15)
        {
          v116 = v14;
          long long v56 = &v20[2 * v40];
          do
          {
            __int16 v117 = *--v116;
            *((_WORD *)v56 - 1) = v117;
            v56 -= 2;
          }
          while (v116 != v15);
          goto LABEL_192;
        }
LABEL_191:
        long long v56 = v54;
LABEL_192:
        uint64_t v29 = (__int16 *)(v54 + 2);
        v146 = (__int16 *)v56;
        v147 = (__int16 *)(v54 + 2);
        v118 = v148;
        v148 = &v20[2 * v19];
        v143 = (char *)v14;
        *(void *)&v144[0] = v118;
        v141 = v15;
        v142 = v15;
        std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,48ul> &>::~__split_buffer((uint64_t)&v141);
        goto LABEL_218;
      }
LABEL_41:
      *unint64_t v14 = v12;
      uint64_t v29 = v14 + 1;
LABEL_218:
      v147 = v29;
LABEL_219:
      ++v12;
    }
    while (v12 <= v10);
    int v3 = a2;
    if (v146 != v147)
    {
      *(void *)&long long v131 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v131 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v144[4] = v131;
      v144[5] = v131;
      v144[2] = v131;
      v144[3] = v131;
      v144[0] = v131;
      v144[1] = v131;
      v141 = 0;
      v142 = 0;
      v143 = 0;
      v145 = v144;
      unint64_t v132 = (char *)v147 - (char *)v146;
      if ((char *)v147 - (char *)v146 < 0) {
LABEL_231:
      }
        abort();
      v133 = (__int16 *)TInlineBufferAllocator<unsigned short,48ul>::allocate((uint64_t)v144, v132 >> 1);
      v141 = v133;
      v143 = (char *)v133 + v132;
      bzero(v133, v132 & 0xFFFFFFFFFFFFFFFELL);
      v142 = (__int16 *)((char *)v133 + v132);
      (*(void (**)(void))(**(void **)(a1 + 400) + 664))();
      v134 = v141;
      v135 = v142;
      while (v134 != v135)
      {
        if (*v134) {
          std::function<void ()(unsigned short,unsigned short)>::operator()(a3, *v134, *v134);
        }
        ++v134;
      }
      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,48ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v141);
    }
LABEL_228:
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,48ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v146);
    char v4 = 1;
LABEL_229:
    v5 += 16;
  }
  while (v5 != (const char *)&kClassDataTable);
  return v4 & 1;
}

_DWORD *OTL::CoverageBitmap::Reset(_DWORD *this, int a2, int a3)
{
  int v3 = this;
  if (a2 == a3)
  {
    *this = 1;
    *((_WORD *)this + 2) = a2;
  }
  else
  {
    *((_WORD *)this + 2) = a2 & 0xFFF8;
    uint64_t v4 = a3 - (a2 & 0xFFF8u) + 1;
    *this = v4;
    if (v4 <= 0x10000) {
      size_t v5 = (unint64_t)(v4 + 7) >> 3;
    }
    else {
      size_t v5 = 0x2000;
    }
    if (v5 > 0x1E)
    {
      this = malloc_type_calloc(1uLL, v5, 0xEC86B7EuLL);
      v3[5] = this;
    }
    else
    {
      uint64_t v6 = (void *)*((void *)this + 5);
      *uint64_t v6 = 0;
      v6[1] = 0;
      *(void *)((char *)v6 + 22) = 0;
      v6[2] = 0;
    }
  }
  return this;
}

uint64_t std::__split_buffer<CFRange,TInlineBufferAllocator<CFRange,4ul> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3) {
    *(void *)(a1 + 16) = v2 + ((v3 - v2 + 15) & 0xFFFFFFFFFFFFFFF0);
  }
  uint64_t v4 = *(void **)a1;
  if (*(void *)a1)
  {
    unint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = (void *)(v5 + 64);
    if (v5 <= (unint64_t)v4 && v6 > v4)
    {
      if (*(void *)(a1 + 24) == *v6) {
        *uint64_t v6 = v4;
      }
    }
    else
    {
      operator delete(v4);
    }
  }
  return a1;
}

void std::default_delete<TRun::RareData>::operator()[abi:nn180100](uint64_t a1, uint64_t a2)
{
  if (a2)
  {

    uint64_t v3 = *(void **)(a2 + 56);
    if (v3)
    {
      *(void *)(a2 + 64) = v3;
      operator delete(v3);
    }
    JUMPOUT(0x1853275C0);
  }
}

CGFloat CTFontGetSize(CTFontRef font)
{
  if (font) {
    return *(double *)(*((void *)font + 5) + 16);
  }
  else {
    return 0.0;
  }
}

void *TCFBase<TFont>::ClassHash(void *result)
{
  unint64_t v1 = result[3];
  uint64_t v2 = result[4];
  if (v2) {
    BOOL v3 = (result[4] & 1 | v1) == 0;
  }
  else {
    BOOL v3 = 1;
  }
  int v4 = !v3;
  if (v1) {
    BOOL v5 = 0;
  }
  else {
    BOOL v5 = v4 == 0;
  }
  if (!v5)
  {
    uint64_t v6 = (void *)(result[5] + (v2 >> 1));
    if (v2) {
      return (void *)(*(uint64_t (**)(void))(*v6 + v1))();
    }
    else {
      return (void *)((uint64_t (*)(void *))v1)(v6);
    }
  }
  return result;
}

uint64_t OTL::GSUB::ApplySubstLookupRecords(void *a1, unint64_t a2, unsigned __int16 *a3, int a4, uint64_t a5, uint64_t a6, uint64_t *a7, unint64_t a8, _WORD *a9, uint64_t a10, unint64_t a11)
{
  unsigned int v11 = a7;
  v59[4] = *MEMORY[0x1E4F143B8];
  unint64_t v56 = a8;
  uint64_t v47 = *(void *)(a5 + 72);
  if (a4)
  {
    int v13 = a4;
    unint64_t v14 = a3;
    unint64_t v15 = a2;
    char v49 = 0;
    uint64_t v16 = a3;
    while (1)
    {
      a8 = v56;
      if ((unint64_t)v14 < v15) {
        break;
      }
      uint64_t v17 = v16 + 2;
      if ((unint64_t)(v16 + 2) > a1[5]) {
        break;
      }
      unint64_t v18 = bswap32(*v16) >> 16;
      if (v56 > v18)
      {
        *(void *)(a5 + 48) = v11[v18];
        uint64_t v19 = TBaseFont::NthLookup<OTL::GSUB>(*(void *)(a1[2] + 400), a1, bswap32(v16[1]) >> 16);
        if (v19)
        {
          uint64_t v20 = v19;
          __int16 v55 = 0;
          *(void *)&long long v21 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v21 + 1) = 0xAAAAAAAAAAAAAAAALL;
          v57[1] = 0xAAAAAAAAAAAAAAAALL;
          long long v58 = v21;
          v57[0] = v21;
          v54[0] = a10;
          v54[1] = a5;
          _OWORD v54[2] = v11;
          v54[3] = &v56;
          v59[0] = &unk_1ED05D3B8;
          v59[1] = v54;
          _OWORD v59[3] = v59;
          std::__function::__value_func<void ()(CFRange,long)>::swap[abi:nn180100](v59, v57);
          std::__function::__value_func<void ()(CFRange,long)>::~__value_func[abi:nn180100](v59);
          uint64_t v22 = *(void *)(a10 + 40);
          *(void *)&long long v58 = *(void *)(a10 + 32);
          *((void *)&v58 + 1) = v22;
          *(void *)(a5 + 72) = *((void *)v20 + 3);
          if (a11 <= 0x3E)
          {
            int v23 = *((unsigned __int16 *)v20 + 8);
            unsigned int v24 = -1431655765 * ((*((_DWORD *)v20 + 24) - *((_DWORD *)v20 + 22)) >> 4);
            uint64_t v25 = *(void *)(a5 + 48);
            uint64_t GlyphID = TRunGlue::GetGlyphID(*(TRunGlue **)a5, v25);
            uint64_t v27 = (unsigned __int16)v24;
            if ((_WORD)v24)
            {
              uint64_t v28 = GlyphID;
              uint64_t v29 = 0;
              unint64_t v30 = 0;
              uint64_t v31 = 48 * v27;
              do
              {
                *(void *)(a5 + 48) = v25;
                uint64_t v32 = *((void *)v20 + 11);
                if (0xAAAAAAAAAAAAAAABLL * ((*((void *)v20 + 12) - v32) >> 4) <= v30) {
                  break;
                }
                uint64_t v33 = v32 + v29;
                uint64_t v34 = *(uint64_t (**)(void *, uint64_t))(v32 + v29 + 24);
                uint64_t v35 = *(void *)(v33 + 32);
                int v36 = (void *)(v33 + (v35 >> 1) + 8);
                if (v35) {
                  uint64_t v34 = *(uint64_t (**)(void *, uint64_t))(*v36 + v34);
                }
                int v37 = v34(v36, v28);
                if (v37)
                {
                  uint64_t v38 = *((void *)v20 + 11);
                  if (0xAAAAAAAAAAAAAAABLL * ((*((void *)v20 + 12) - v38) >> 4) <= v30) {
                    LODWORD(v39) = 0;
                  }
                  else {
                    uint64_t v39 = *(void *)(v38 + v29);
                  }
                  if (OTL::GSUB::ApplyLookupSubtable((int)a1, (int)v20, v23, v39, (TGlyphIterator *)a5, v37, 0, (int)&v55, (uint64_t)v57, a11 + 1))
                  {
                    char v49 = 1;
                    break;
                  }
                }
                ++v30;
                v29 += 48;
              }
              while (v31 != v29);
              unsigned int v11 = a7;
            }
            unint64_t v15 = a2;
            unint64_t v14 = a3;
          }
          if (v55)
          {
            *a9 += v55;
            uint64_t v40 = &v11[v56];
            uint64_t v41 = v11;
            if (v56)
            {
              uint64_t v42 = 8 * v56;
              uint64_t v41 = v11;
              while (TRunGlue::GetGlyphID(*(TRunGlue **)a5, *v41) != 0xFFFF)
              {
                ++v41;
                v42 -= 8;
                if (!v42)
                {
                  uint64_t v41 = v40;
                  goto LABEL_35;
                }
              }
            }
            if (v41 != v40)
            {
              for (uint64_t i = v41 + 1; i != v40; ++i)
              {
                if (TRunGlue::GetGlyphID(*(TRunGlue **)a5, *i) != 0xFFFF) {
                  *v41++ = *i;
                }
              }
            }
LABEL_35:
            unint64_t v56 = v41 - v11;
          }
          std::__function::__value_func<void ()(CFRange,long)>::~__value_func[abi:nn180100](v57);
        }
      }
      uint64_t v16 = v17;
      if (!--v13)
      {
        a8 = v56;
        break;
      }
    }
    char v44 = v49;
  }
  else
  {
    char v44 = 0;
  }
  uint64_t v45 = a6;
  if (a8) {
    uint64_t v45 = v11[a8 - 1];
  }
  *(void *)(a5 + 48) = v45;
  *(void *)(a5 + 72) = v47;
  return v44 & 1;
}

uint64_t OTL::GSUB::ApplySingleSubst(uint64_t a1, unsigned __int16 *a2, uint64_t a3, unsigned int a4, uint64_t a5)
{
  unsigned int GlyphID = TRunGlue::GetGlyphID(*(TRunGlue **)a3, *(void *)(a3 + 48));
  unsigned int v11 = bswap32(*a2) >> 16;
  if (v11 == 2)
  {
    unint64_t v12 = *(void *)(a1 + 40);
    int v13 = a2 + 3;
    if ((unint64_t)(a2 + 3) <= v12)
    {
      uint64_t v14 = bswap32(a2[2]) >> 16;
      BOOL v15 = __CFADD__(v13, 2 * v14);
      char v16 = (unint64_t)&v13[v14] > v12 || v15;
      unint64_t v17 = (v12 - (unint64_t)v13) >> 1;
      unint64_t v18 = (unint64_t)(a2 + 4) <= v12 ? v17 : 0;
      char v19 = v18 == v14 ? 0 : v16;
      if (v14 >= a4 && (v19 & 1) == 0) {
        unsigned int GlyphID = bswap32(a2[a4 + 2]) >> 16;
      }
    }
  }
  else if (v11 == 1)
  {
    GlyphID += bswap32(a2[2]) >> 16;
  }
  TRunGlue::SetGlyphID<true>(*(TRunGlue **)a3, *(void *)(a3 + 48), (unsigned __int16)GlyphID);
  std::function<void ()(CFRange,long)>::operator()(a5, *(void *)(a3 + 48), 1, 1);
  return 1;
}

uint64_t *std::function<void ()(CFRange,long)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v10[0] = a2;
  v10[1] = a3;
  uint64_t v9 = a4;
  uint64_t v4 = *(void *)(a1 + 24);
  if (v4) {
    return (uint64_t *)(*(uint64_t (**)(uint64_t, void *, uint64_t *))(*(void *)v4 + 48))(v4, v10, &v9);
  }
  uint64_t v6 = (uint64_t ***)std::__throw_bad_function_call[abi:nn180100]();
  return std::__invoke_void_return_wrapper<void,true>::__call[abi:nn180100]<OTL::GSUB::ApplyLookups(TRunGlue &,int,OTL::GlyphLookups &,SyncState &,void (*)(void *,CFRange,long),void *)::{lambda(CFRange,long)#1} &,CFRange,long>(v6, v7, v8);
}

uint64_t *std::__invoke_void_return_wrapper<void,true>::__call[abi:nn180100]<OTL::GSUB::ApplyLookups(TRunGlue &,int,OTL::GlyphLookups &,SyncState &,void (*)(void *,CFRange,long),void *)::{lambda(CFRange,long)#1} &,CFRange,long>(uint64_t ***a1, CFIndex *a2, uint64_t *a3)
{
  CFIndex v4 = *a2;
  CFIndex v5 = a2[1];
  uint64_t v6 = *a3;
  v11.CFIndex location = *a2;
  v11.CFIndex length = v5;
  uint64_t result = OTL::GlyphLookups::Substituted(**a1, v11, v6);
  unsigned int v8 = (*a1)[1];
  if (v8)
  {
    uint64_t v9 = (*a1)[2];
    return (uint64_t *)((uint64_t (*)(uint64_t *, CFIndex, CFIndex, uint64_t))v8)(v9, v4, v5, v6);
  }
  return result;
}

uint64_t *std::__function::__func<OTL::GSUB::ApplyLookups(TRunGlue &,int,OTL::GlyphLookups &,SyncState &,void (*)(void *,CFRange,long),void *)::{lambda(CFRange,long)#1},std::allocator<OTL::GSUB::ApplyLookups(TRunGlue &,int,OTL::GlyphLookups &,SyncState &,void (*)(void *,CFRange,long),void *)::{lambda(CFRange,long)#1}>,void ()(CFRange,long)>::operator()(uint64_t a1, CFIndex *a2, uint64_t *a3)
{
  return std::__invoke_void_return_wrapper<void,true>::__call[abi:nn180100]<OTL::GSUB::ApplyLookups(TRunGlue &,int,OTL::GlyphLookups &,SyncState &,void (*)(void *,CFRange,long),void *)::{lambda(CFRange,long)#1} &,CFRange,long>((uint64_t ***)(a1 + 8), a2, a3);
}

void TRunGlue::SetGlyphID<true>(TRunGlue *this, uint64_t a2, uint64_t a3)
{
  if (a3 == 0xFFFF)
  {
    TRunGlue::Delete(this, a2, 0);
  }
  else
  {
    uint64_t v6 = *((void *)this + 25);
    if (v6 && *((void *)this + 78) > (uint64_t)a3) {
      *(unsigned char *)(v6 + ((unint64_t)a3 >> 3)) |= 1 << (a3 & 7);
    }
    if (*((void *)this + 19))
    {
      TRunGlue::FocusOnIndex(this, a2);
      uint64_t v7 = *((void *)this + 19);
      uint64_t v8 = a2 - *((void *)this + 20);
      [*(id *)(v7 + 216) setGlyph:a3 atIndex:*(void *)(v7 + 200) + v8];
      if (*((unsigned char *)this + 633) && *((unsigned char *)this + 632))
      {
        *((unsigned char *)this + 592) = 1;
        [*(id *)(v7 + 216) setProps:*(_DWORD *)(*(void *)(*(void *)(v7 + 216) + 40) + 4 * *(void *)(v7 + 200) + 4 * v8) | 0x800u atIndex:*(void *)(v7 + 200) + v8];
      }
      else
      {
        uint64_t v14 = *((void *)this + 77);
        uint64_t RenderingStyle = TAttributes::GetRenderingStyle((TAttributes *)(v7 + 40));
        TStorageRange::ResetAdvance(v7 + 192, v8, v14, RenderingStyle);
      }
      char v16 = *(void **)(v7 + 216);
      uint64_t v17 = *(void *)(v7 + 200);
      int v18 = *(_DWORD *)(v16[5] + 4 * v17 + 4 * v8);
      if ((v18 & 0x40) != 0)
      {
        [v16 setProps:v18 & 0xFFFFEFBF | 0x1000 atIndex:v17 + v8];
      }
    }
    else
    {
      uint64_t v9 = *((void *)this + 20) + a2;
      *(_WORD *)(*((void *)this + 22) + 2 * v9) = a3;
      uint64_t v10 = *((void *)this + 77);
      __int16 v20 = a3;
      uint64_t v19 = NAN;
      TFont::GetUnsummedAdvancesForGlyphs(v10, (uint64_t)&v20, &v19, 1, 1, 0, 0);
      CFRange v11 = (uint64_t *)(*((void *)this + 23) + 16 * v9);
      uint64_t *v11 = *(void *)&v19;
      v11[1] = 0;
      uint64_t v12 = *((void *)this + 65);
      if (v12)
      {
        int v13 = *(_DWORD *)(v12 + 4 * v9);
        if ((v13 & 0x1040) != 0) {
          *(_DWORD *)(v12 + 4 * v9) = v13 & 0xFFFFEFBF | 0x1000;
        }
      }
    }
  }
}

uint64_t *OTL::GlyphLookups::Substituted(uint64_t *this, CFRange a2, uint64_t a3)
{
  CFIndex v3 = a3 - a2.length;
  if (a3 - a2.length >= 1)
  {
    uint64_t v4 = *this;
    uint64_t v5 = this[1];
    if (*this != v5)
    {
      uint64_t v6 = (uint64_t *)(a2.location + a2.length);
      do
      {
        uint64_t v7 = *(CFIndex **)(v4 + 8);
        uint64_t v8 = *(CFIndex **)(v4 + 16);
        while (v7 != v8)
        {
          CFIndex v9 = *v7;
          uint64_t v10 = v7 + 1;
          CFIndex v11 = v7[1];
          this = (uint64_t *)(v11 + *v7);
          if ((uint64_t)this >= (uint64_t)v6) {
            uint64_t v12 = v6;
          }
          else {
            uint64_t v12 = (uint64_t *)(v11 + *v7);
          }
          BOOL v13 = a2.location <= v9 && v9 < (uint64_t)v6;
          CFIndex location = *v7;
          if ((v13 || (v9 <= a2.location ? (v15 = a2.location < (uint64_t)this) : (v15 = 0), CFIndex location = a2.location, v15))
            && (uint64_t)v12 > location)
          {
            CFIndex v9 = v7[1];
          }
          else
          {
            uint64_t v10 = v7;
            if (v9 <= a2.location) {
              goto LABEL_22;
            }
          }
          CFIndex *v10 = v9 + v3;
LABEL_22:
          v7 += 2;
        }
        v4 += 104;
      }
      while (v4 != v5);
    }
  }
  return this;
}

unsigned __int16 *OTL::GSUB::ApplyChainContextSubstFormat2(void *a1, unsigned __int16 *a2, uint64_t a3, _WORD *a4, uint64_t a5, unint64_t a6)
{
  uint64_t v95 = *(void *)(a3 + 48);
  unsigned int GlyphID = TRunGlue::GetGlyphID(*(TRunGlue **)a3, v95);
  unint64_t v13 = a1[5];
  uint64_t v14 = a2 + 6;
  if ((unint64_t)(a2 + 5) < a1[4] || (unint64_t)v14 > v13) {
    return 0;
  }
  uint64_t v16 = __rev16(a2[5]);
  unint64_t v17 = (unint64_t)&v14[v16];
  unint64_t v18 = (unint64_t)(a2 + 7) <= v13 ? (v13 - (unint64_t)v14) >> 1 : 0;
  BOOL v19 = v17 <= v13 && v17 >= (unint64_t)v14;
  BOOL v20 = v19 || v18 == v16;
  if (!v20) {
    return 0;
  }
  long long v21 = (unsigned __int16 *)((char *)a2 + (bswap32(a2[3]) >> 16));
  if ((unint64_t)(v21 + 1) > v13) {
    return 0;
  }
  unsigned int v22 = GlyphID;
  unsigned int v23 = bswap32(*v21) >> 16;
  if (v23 == 2)
  {
    uint64_t v24 = 6 * (bswap32(v21[1]) >> 16) + 4;
  }
  else if (v23 == 1)
  {
    uint64_t v24 = 2 * (bswap32(v21[2]) >> 16) + 6;
  }
  else
  {
    uint64_t v24 = 0;
  }
  uint64_t result = 0;
  uint64_t v26 = (char *)v21 + v24;
  if (v26 < (char *)v21 || (unint64_t)v26 > v13) {
    return result;
  }
  if (!a2[5]) {
    return 0;
  }
  unsigned int v27 = a2[2];
  unsigned int v28 = a2[4];
  *(void *)&long long v29 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v29 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v97[29] = v29;
  v97[30] = v29;
  v97[27] = v29;
  v97[28] = v29;
  v97[25] = v29;
  v97[26] = v29;
  v97[23] = v29;
  v97[24] = v29;
  v97[21] = v29;
  v97[22] = v29;
  v97[19] = v29;
  v97[20] = v29;
  v97[17] = v29;
  v97[18] = v29;
  v97[16] = v29;
  unint64_t v98 = 0xAAAAAAAAAAAAAAAALL;
  v97[15] = v29;
  v97[14] = v29;
  v97[13] = v29;
  v97[12] = v29;
  v97[11] = v29;
  v97[10] = v29;
  v97[9] = v29;
  v97[8] = v29;
  v97[7] = v29;
  v97[5] = v29;
  v97[6] = v29;
  v97[3] = v29;
  v97[4] = v29;
  v97[1] = v29;
  v97[2] = v29;
  v97[0] = v29;
  uint64_t v96 = v95;
  v88 = (OTL::ClassDefTable *)v21;
  unsigned int v30 = OTL::ClassDefTable::ClassOf((OTL::ClassDefTable *)v21, v22);
  unint64_t v93 = (unint64_t)a2;
  uint64_t result = ChainContextSubstFormat2::NthChainSubClassSet((ChainContextSubstFormat2 *)a2, v30, v13);
  if (!result) {
    return result;
  }
  uint64_t v31 = result;
  if (TGlyphIterator::Next((TGlyphIterator *)a3, 1))
  {
    uint64_t v32 = *(void *)(a3 + 48);
    unsigned int v33 = TRunGlue::GetGlyphID(*(TRunGlue **)a3, v32);
    int v34 = OTL::ClassDefTable::ClassOf(v88, v33);
    uint64_t v35 = v32;
    int v89 = v34;
    uint64_t v36 = v95;
  }
  else
  {
    int v89 = 0;
    uint64_t v36 = v95;
    uint64_t v35 = v95;
  }
  unint64_t v37 = v93;
  unint64_t v83 = a6;
  unint64_t v84 = a1;
  uint64_t v38 = v31 + 1;
  __int16 v85 = a4;
  uint64_t v86 = a5;
  if ((unint64_t)(v31 + 1) < v93
    || (LODWORD(v39) = __rev16((unsigned __int16)*v31),
        unint64_t v40 = (unint64_t)&v38[v39],
        v40 < (unint64_t)v38)
    || v40 > v13)
  {
    BOOL v41 = (unint64_t)(v31 + 2) <= v13 && (unint64_t)v38 >= v93;
    LODWORD(v39) = (v13 - v38) >> 1;
    if (!v41) {
      LODWORD(v39) = 0;
    }
    if (!(bswap32(v39) >> 16)) {
      goto LABEL_129;
    }
  }
  else if (!*v31)
  {
LABEL_129:
    uint64_t result = 0;
    *(void *)(a3 + 48) = v36;
    return result;
  }
  unint64_t v42 = 0;
  int v43 = (unsigned __int16 *)(v93 + (bswap32(v27) >> 16));
  v90 = (unsigned __int16 *)(v93 + (bswap32(v28) >> 16));
  uint64_t v91 = v43 + 1;
  v87 = v90 + 1;
  if ((v39 & 0xFFFE) != 0) {
    uint64_t v39 = (unsigned __int16)v39;
  }
  else {
    uint64_t v39 = 1;
  }
  uint64_t v94 = v39;
  uint64_t v92 = v35;
  while (1)
  {
    if (v42 >= bswap32((unsigned __int16)*v31) >> 16) {
      goto LABEL_128;
    }
    unsigned int v44 = (unsigned __int16)v31[v42 + 1];
    BOOL v20 = v44 == 0;
    uint64_t v45 = (_WORD *)((char *)v31 + __rev16(v44));
    if (v20 || (unint64_t)v45 > v13) {
      goto LABEL_128;
    }
    uint64_t v47 = v45 + 1;
    if ((unint64_t)v45 < v37 || (unint64_t)v47 > v13) {
      goto LABEL_129;
    }
    if (*v45)
    {
      if ((unint64_t)v91 > v13) {
        goto LABEL_129;
      }
      unsigned int v49 = bswap32(*v43) >> 16;
      if (v49 == 2) {
        uint64_t v50 = 6 * (bswap32(*v91) >> 16) + 4;
      }
      else {
        uint64_t v50 = v49 == 1 ? 2 * (bswap32(v43[2]) >> 16) + 6 : 0;
      }
      uint64_t v52 = (char *)v43 + v50;
      if (v52 < (char *)v43 || (unint64_t)v52 > v13) {
        goto LABEL_129;
      }
      uint64_t v53 = __rev16((unsigned __int16)*v45);
      uint64_t v54 = &v47[v53];
      BOOL v55 = v54 < v47 || (unint64_t)v54 > v13;
      if (v55 && ((unint64_t)(v45 + 2) > v13 || (v13 - (unint64_t)v47) >> 1 != v53)) {
        goto LABEL_129;
      }
      *(void *)(a3 + 48) = v36;
      if (v53 <= 1) {
        int v56 = 1;
      }
      else {
        int v56 = v53;
      }
      while (TGlyphIterator::PrevContext((TGlyphIterator *)a3, 1))
      {
        unsigned int v57 = TRunGlue::GetGlyphID(*(TRunGlue **)a3, *(void *)(a3 + 48));
        if (OTL::ClassDefTable::ClassOf((OTL::ClassDefTable *)v43, v57) != bswap32((unsigned __int16)*v47) >> 16) {
          break;
        }
        ++v47;
        if (!--v56)
        {
          CFIndex v51 = *(void *)(a3 + 48);
          uint64_t v35 = v92;
          unint64_t v37 = v93;
          *(void *)(a3 + 48) = v92;
          uint64_t v36 = v95;
          goto LABEL_77;
        }
      }
      goto LABEL_127;
    }
    CFIndex v51 = v36;
LABEL_77:
    long long v58 = v47 + 1;
    if ((unint64_t)v47 < v37 || (unint64_t)v58 > v13) {
      goto LABEL_129;
    }
    unsigned int v60 = (unsigned __int16)*v47;
    if (*v47)
    {
      unint64_t v61 = __rev16(v60);
      if (v61 <= 0x40)
      {
        unint64_t v62 = v61 - 1;
        __int16 v63 = &v58[v61 - 1];
        if (v63 < v58 || (unint64_t)v63 > v13)
        {
          unint64_t v65 = (unint64_t)(v47 + 2) <= v13 ? (v13 - (unint64_t)v58) >> 1 : 0;
          if (v65 != v62) {
            goto LABEL_129;
          }
        }
        uint64_t v66 = &v47[v61];
        if (v35 == v36 || v60 == 256)
        {
          CFIndex v67 = v36;
        }
        else
        {
          CFIndex v67 = v36;
          if (v89 == bswap32(*v58) >> 16)
          {
            *(void *)&v97[0] = v35;
            long long v58 = v47 + 2;
            if (v60 == 512)
            {
              CFIndex v67 = v35;
            }
            else
            {
              CFIndex v68 = v51;
              if (TGlyphIterator::Next((TGlyphIterator *)a3, 1))
              {
                long long v58 = EqualClassSequenceAndNote<BigEndianScalar<unsigned short>>(v88, v58, v66, a3, (void *)v97 + 1);
                CFIndex v67 = *(void *)(a3 + 48);
                uint64_t v35 = v92;
                *(void *)(a3 + 48) = v92;
              }
              else
              {
                uint64_t v35 = v92;
                CFIndex v67 = v92;
              }
              uint64_t v36 = v95;
              unint64_t v37 = v93;
              CFIndex v51 = v68;
            }
          }
        }
        if (v58 == v66) {
          break;
        }
      }
    }
LABEL_128:
    if (++v42 == v94) {
      goto LABEL_129;
    }
  }
  uint64_t v69 = v66 + 1;
  if ((unint64_t)(v66 + 1) > v13) {
    goto LABEL_129;
  }
  if (*v66)
  {
    if ((unint64_t)v87 > v13) {
      goto LABEL_129;
    }
    unsigned int v70 = bswap32(*v90) >> 16;
    if (v70 == 2) {
      uint64_t v71 = 6 * (bswap32(*v87) >> 16) + 4;
    }
    else {
      uint64_t v71 = v70 == 1 ? 2 * (bswap32(v90[2]) >> 16) + 6 : 0;
    }
    long long v72 = (char *)v90 + v71;
    if (v72 < (char *)v90 || (unint64_t)v72 > v13) {
      goto LABEL_129;
    }
    uint64_t v73 = __rev16(*v66);
    __int16 v74 = &v69[v73];
    BOOL v75 = v74 < v69 || (unint64_t)v74 > v13;
    if (v75 && ((unint64_t)(v66 + 2) > v13 || (v13 - (unint64_t)v69) >> 1 != v73)) {
      goto LABEL_129;
    }
    CFIndex v76 = v51;
    *(void *)(a3 + 48) = *(&v96 + v62);
    if (v73 <= 1) {
      int v77 = 1;
    }
    else {
      int v77 = v73;
    }
    while (TGlyphIterator::NextContext((TGlyphIterator *)a3, 1))
    {
      unsigned int v78 = TRunGlue::GetGlyphID(*(TRunGlue **)a3, *(void *)(a3 + 48));
      if (OTL::ClassDefTable::ClassOf((OTL::ClassDefTable *)v90, v78) != bswap32(*v69) >> 16) {
        break;
      }
      ++v69;
      if (!--v77)
      {
        CFIndex v67 = *(void *)(a3 + 48);
        unint64_t v37 = v93;
        *(void *)(a3 + 48) = v92;
        uint64_t v36 = v95;
        CFIndex v51 = v76;
        goto LABEL_130;
      }
    }
LABEL_127:
    uint64_t v35 = v92;
    unint64_t v37 = v93;
    *(void *)(a3 + 48) = v92;
    uint64_t v36 = v95;
    goto LABEL_128;
  }
LABEL_130:
  if ((unint64_t)v69 < v37 || (unint64_t)(v69 + 1) > v13) {
    goto LABEL_129;
  }
  CFIndex v79 = v67;
  CFIndex v80 = v51;
  if (OTL::GSUB::ApplySubstLookupRecords(v84, v37, v69 + 1, bswap32(*v69) >> 16, a3, v36, &v96, v61, v85, v86, v83)&& *(void *)(*(void *)a3 + 152))
  {
    CFIndex v81 = v80 - v79;
    if (v80 >= v79) {
      v82.CFIndex location = v79;
    }
    else {
      v82.CFIndex location = v80;
    }
    if (v80 - v79 < 0) {
      CFIndex v81 = v79 - v80;
    }
    v82.CFIndex length = v81 + 1;
    TRunGlue::ClearSafeToBreakAfter(*(void *)a3, v82);
  }
  return (unsigned __int16 *)1;
}

BOOL TGlyphIterator::MatchCoverSequence<(MatchDirection)0>(uint64_t a1, uint64_t a2, int a3, unsigned __int16 *a4, uint64_t a5, unint64_t a6, uint64_t *a7)
{
  uint64_t v12 = a2;
  uint64_t v14 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = a2;
  if (TGlyphIterator::NextContext((TGlyphIterator *)a1, 1))
  {
    uint64_t v21 = v14;
    while (1)
    {
      uint64_t v12 = *(void *)(a1 + 48);
      uint64_t GlyphID = TRunGlue::GetGlyphID(*(TRunGlue **)a1, v12);
      unint64_t v24 = 0xAAAAAAAAAAAAAAAALL;
      *(void *)&long long v16 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long v22 = v16;
      long long v23 = v16;
      unsigned int v17 = *a4++;
      OTL::Coverage::Coverage((OTL::Coverage *)&v22, (unsigned __int16 *)(a5 + (bswap32(v17) >> 16)), a6, 1);
      unint64_t v18 = (unsigned int (*)(void *, uint64_t))v23;
      BOOL v19 = (void *)((char *)&v22 + (*((uint64_t *)&v23 + 1) >> 1));
      if (BYTE8(v23)) {
        unint64_t v18 = *(unsigned int (**)(void *, uint64_t))(*v19 + v23);
      }
      if (!v18(v19, GlyphID)) {
        break;
      }
      if (!--a3) {
        break;
      }
      if ((TGlyphIterator::NextContext((TGlyphIterator *)a1, 1) & 1) == 0)
      {
        a3 = 1;
        break;
      }
    }
    uint64_t v14 = v21;
  }
  if (a7) {
    *a7 = v12;
  }
  *(void *)(a1 + 48) = v14;
  return a3 == 0;
}

uint64_t TGlyphIterator::NextContext(TGlyphIterator *this, uint64_t a2)
{
  if (*((void *)this + 6) == *((void *)this + 5)) {
    return 0;
  }
  uint64_t v3 = a2;
  if (a2 >= 1)
  {
    while (1)
    {
      uint64_t v5 = *((int *)this + 2);
      uint64_t v6 = *((void *)this + 6) + v5;
      *((void *)this + 6) = v6;
      if ((int)v5 < 1)
      {
        if ((v5 & 0x80000000) != 0 && v6 <= *((void *)this + 5)) {
          return 0;
        }
      }
      else if (v6 >= *((void *)this + 5))
      {
        return 0;
      }
      if ((TGlyphIterator::CurrentGlyphIsIgnored(this, 0) & 1) == 0)
      {
        uint64_t result = 1;
        if (v3-- <= 1) {
          return result;
        }
      }
    }
  }
  return 1;
}

uint64_t TRunGlue::GlyphRangeByTrimming(TRunGlue *a1, uint64_t a2)
{
  uint64_t v4 = TRunGlue::length(a1);
  if (v4 < 1) {
    return 0;
  }
  uint64_t v5 = 0;
  while (std::function<BOOL ()(TRunGlue::TGlyph)>::operator()(a2, (uint64_t)a1, v5))
  {
    if (v4 == ++v5) {
      return v4;
    }
  }
  uint64_t v6 = v4 - v5;
  if (v6 >= 1)
  {
    uint64_t v7 = v5 + v6;
    do
    {
      if (!std::function<BOOL ()(TRunGlue::TGlyph)>::operator()(a2, (uint64_t)a1, --v7)) {
        break;
      }
      --v6;
    }
    while (v7 > v5);
  }
  return v5;
}

uint64_t std::function<BOOL ()(TRunGlue::TGlyph)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v7[0] = a2;
  v7[1] = a3;
  uint64_t v3 = *(void *)(a1 + 24);
  if (v3) {
    return (*(uint64_t (**)(uint64_t, void *))(*(void *)v3 + 48))(v3, v7);
  }
  uint64_t v5 = std::__throw_bad_function_call[abi:nn180100]();
  return std::__function::__func<TOpenTypeMorph::ShapeGlyphs(SyncState &)::$_1,std::allocator<TOpenTypeMorph::ShapeGlyphs(SyncState &)::$_1>,BOOL ()(TRunGlue::TGlyph)>::operator()(v5, v6);
}

BOOL std::__function::__func<TOpenTypeMorph::ShapeGlyphs(SyncState &)::$_1,std::allocator<TOpenTypeMorph::ShapeGlyphs(SyncState &)::$_1>,BOOL ()(TRunGlue::TGlyph)>::operator()(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  return TRunGlue::TGlyph::IsIgnorable((TRunGlue::TGlyph *)&v3);
}

BOOL TRunGlue::TGlyph::IsIgnorable(TRunGlue::TGlyph *this)
{
  if ((unsigned __int16)(TRunGlue::GetGlyphID(*(TRunGlue **)this, *((void *)this + 1)) + 1) < 2u) {
    return 1;
  }
  long long v3 = *(TRunGlue **)this;
  uint64_t v4 = *((void *)this + 1);

  return TRunGlue::IsDeleted(v3, v4);
}

uint64_t OTL::GPOS::ApplyPairPosAccelerated(OTL::GPOS *this, const OTL::Lookup *a2, TGlyphIterator *a3)
{
  v140[1] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (unsigned __int16 *)*((void *)this + 5);
  unsigned int v5 = -1431655765 * ((*((_DWORD *)a2 + 24) - *((_DWORD *)a2 + 22)) >> 4);
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v139[22] = v6;
  v139[23] = v6;
  v139[20] = v6;
  v139[21] = v6;
  v139[18] = v6;
  v139[19] = v6;
  v139[16] = v6;
  v139[17] = v6;
  v139[15] = v6;
  v139[14] = v6;
  v139[13] = v6;
  v139[12] = v6;
  v139[11] = v6;
  v139[10] = v6;
  v139[9] = v6;
  v139[8] = v6;
  v139[7] = v6;
  v139[6] = v6;
  v139[5] = v6;
  v139[4] = v6;
  v139[3] = v6;
  v139[2] = v6;
  v139[1] = v6;
  v139[0] = v6;
  __p = 0;
  v137 = 0;
  v138 = 0;
  v140[0] = v139;
  uint64_t v7 = (unsigned __int16)v5;
  if ((_WORD)v5)
  {
    if (&v139[2 * (unsigned __int16)v5] <= (_OWORD *)v140)
    {
      v140[0] = &v139[2 * (unsigned __int16)v5];
      uint64_t v8 = v139;
    }
    else
    {
      uint64_t v8 = operator new(32 * (unsigned __int16)v5);
    }
    CFIndex v9 = &v8[2 * v7];
    __p = v8;
    v138 = v9;
    bzero(v8, 32 * v7);
    v137 = v9;
  }
  uint64_t v10 = *((void *)this + 2);
  CFIndex v11 = *(os_unfair_lock_s **)(v10 + 400);
  uint64_t v113 = (os_unfair_lock_s *)(v10 + 448);
  os_unfair_lock_lock_with_options();
  uint64_t v12 = *((void *)this + 2);
  if (!TGlyphIterator::Next(a3, 1)) {
    goto LABEL_193;
  }
  uint64_t v124 = v4;
  uint64_t v125 = v7;
  char v119 = 0;
  v118 = v11;
  lock = v11 + 111;
  v121 = a3;
  uint64_t v117 = v12;
  uint64_t v112 = (void *)(v12 + 472);
  do
  {
    unint64_t v13 = v121;
    uint64_t v14 = *((void *)v121 + 6);
    unsigned int GlyphID = TRunGlue::GetGlyphID(*(TRunGlue **)v121, v14);
    if (!OTL::CoverageBitmap::Covers((const OTL::Lookup *)((char *)a2 + 40), GlyphID)) {
      goto LABEL_182;
    }
    if (!TGlyphIterator::Next(v121, 1))
    {
      char v48 = v119;
      break;
    }
    uint64_t v15 = *((void *)v121 + 6);
    unsigned int v16 = TRunGlue::GetGlyphID(*(TRunGlue **)v121, v15);
    *((void *)v121 + 6) = v14;
    unsigned int v123 = v16;
    unint64_t v17 = v16 | (GlyphID << 16);
    int8x8_t v18 = *(int8x8_t *)(v117 + 464);
    if (!*(void *)&v18) {
      goto LABEL_26;
    }
    uint8x8_t v19 = (uint8x8_t)vcnt_s8(v18);
    v19.i16[0] = vaddlv_u8(v19);
    if (v19.u32[0] > 1uLL)
    {
      unint64_t v20 = v16 | (GlyphID << 16);
      if (*(void *)&v18 <= v17) {
        unint64_t v20 = v17 % *(void *)&v18;
      }
    }
    else
    {
      unint64_t v20 = (v18.i32[0] - 1) & v17;
    }
    uint64_t v21 = *(uint64_t ***)(*(void *)(v117 + 456) + 8 * v20);
    if (!v21 || (long long v22 = *v21) == 0)
    {
LABEL_26:
      if (!v125) {
        goto LABEL_182;
      }
      uint64_t v114 = v15;
      unint64_t v115 = v16 | (GlyphID << 16);
      uint64_t v116 = v14;
      unint64_t v24 = 0;
      while (1)
      {
        uint64_t v25 = *((void *)a2 + 11);
        if (0xAAAAAAAAAAAAAAABLL * ((*((void *)a2 + 12) - v25) >> 4) <= v24) {
          goto LABEL_193;
        }
        uint64_t v26 = v25 + 48 * v24;
        unsigned int v27 = *(uint64_t (**)(void *, void))(v26 + 24);
        uint64_t v28 = *(void *)(v26 + 32);
        long long v29 = (void *)(v26 + (v28 >> 1) + 8);
        if (v28) {
          unsigned int v27 = *(uint64_t (**)(void *, void))(*v29 + v27);
        }
        unsigned int v30 = v27(v29, GlyphID);
        if (!v30) {
          goto LABEL_63;
        }
        unsigned int v31 = v30;
        uint64_t v32 = __p;
        unsigned int v33 = (char *)__p + 32 * v24;
        int v34 = *(unsigned __int16 **)v33;
        if (!*(void *)v33)
        {
          uint64_t v45 = *((void *)a2 + 11);
          if (0xAAAAAAAAAAAAAAABLL * ((*((void *)a2 + 12) - v45) >> 4) <= v24) {
            int v34 = 0;
          }
          else {
            int v34 = *(unsigned __int16 **)(v45 + 48 * v24);
          }
          char v48 = 0;
          if (*((void *)this + 4) > (unint64_t)v34 || v34 + 4 > v124) {
            goto LABEL_195;
          }
          unsigned int v49 = bswap32(*v34) >> 16;
          if (v49 == 2)
          {
            if (v34 + 8 > v124) {
              goto LABEL_193;
            }
            int v56 = (char *)v34 + (bswap32(v34[4]) >> 16);
            if (v56 + 2 > (char *)v124) {
              goto LABEL_193;
            }
            unsigned int v57 = bswap32(*(unsigned __int16 *)v56) >> 16;
            if (v57 == 2)
            {
              uint64_t v58 = 6 * (bswap32(*((unsigned __int16 *)v56 + 1)) >> 16) + 4;
            }
            else if (v57 == 1)
            {
              uint64_t v58 = 2 * (bswap32(*((unsigned __int16 *)v56 + 2)) >> 16) + 6;
            }
            else
            {
              uint64_t v58 = 0;
            }
            char v48 = 0;
            v59 = &v56[v58];
            if (v59 < v56 || v59 > (char *)v124) {
              goto LABEL_195;
            }
            unsigned int v60 = (char *)v34 + (bswap32(v34[5]) >> 16);
            if (v60 + 2 > (char *)v124) {
              goto LABEL_193;
            }
            unsigned int v61 = bswap32(*(unsigned __int16 *)v60) >> 16;
            if (v61 == 2) {
              uint64_t v62 = 6 * (bswap32(*((unsigned __int16 *)v60 + 1)) >> 16) + 4;
            }
            else {
              uint64_t v62 = v61 == 1 ? 2 * (bswap32(*((unsigned __int16 *)v60 + 2)) >> 16) + 6 : 0;
            }
            char v48 = 0;
            __int16 v63 = &v60[v62];
            if (v63 < v60 || v63 > (char *)v124) {
              goto LABEL_195;
            }
            os_unfair_lock_lock_with_options();
            uint64_t v64 = *(void *)&v118[112]._os_unfair_lock_opaque;
            if (v24 >= (*(void *)&v118[114]._os_unfair_lock_opaque - v64) >> 3
              || (unint64_t v65 = *(unsigned __int16 **)(v64 + 8 * v24)) == 0)
            {
              LOWORD(v128) = 0;
              v135[0] = &unk_1ED0618B0;
              v135[1] = &v128;
              v135[3] = v135;
              OTL::ClassDefTable::Iterate(v56, (uint64_t)v135);
              std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100](v135);
              __int16 v133 = 0;
              v134[0] = &unk_1ED0618F8;
              v134[1] = &v133;
              v134[3] = v134;
              OTL::ClassDefTable::Iterate(v60, (uint64_t)v134);
              std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100](v134);
              operator new[]();
            }
            uint64_t v66 = *v65;
            CFIndex v67 = v65 + 2;
            unsigned __int16 v68 = v65[1];
            *(void *)unsigned int v33 = v34;
            *((_DWORD *)v33 + 2) = 2;
            *((_WORD *)v33 + 6) = v66;
            *((_WORD *)v33 + 7) = v68;
            *((void *)v33 + 2) = v67;
            *((void *)v33 + 3) = &v67[v66 + 1];
            os_unfair_lock_unlock(lock);
          }
          else
          {
            if (v49 != 1) {
              goto LABEL_63;
            }
            uint64_t v50 = v34 + 5;
            if (v34 + 5 > v124) {
              goto LABEL_193;
            }
            uint64_t v51 = bswap32(v34[4]) >> 16;
            unint64_t v52 = (unint64_t)&v50[v51];
            unint64_t v53 = v34 + 6 <= v124 ? (unint64_t)((char *)v124 - (char *)v50) >> 1 : 0;
            BOOL v54 = v52 <= (unint64_t)v124 && v52 >= (unint64_t)v50;
            if (!v54 && v53 != v51) {
              goto LABEL_193;
            }
            *(void *)unsigned int v33 = v34;
            *((_DWORD *)v33 + 2) = 1;
            *(void *)(v33 + 20) = 0;
            *(void *)(v33 + 12) = 0;
            *((_DWORD *)v33 + 7) = 0;
          }
        }
        unsigned int v35 = v34[2];
        __int32 v36 = __rev16(v35);
        unsigned int v37 = v34[3];
        __int32 v38 = __rev16(v37);
        int v39 = *((_DWORD *)v33 + 2);
        if (v39 == 2)
        {
          uint64_t v46 = (char *)&v32[4 * v24];
          if (GlyphID <= *((unsigned __int16 *)v46 + 6)) {
            unsigned int v47 = *(unsigned __int16 *)(*((void *)v46 + 2) + 2 * GlyphID);
          }
          else {
            unsigned int v47 = 0;
          }
          if (v123 <= *((unsigned __int16 *)v46 + 7)) {
            unsigned int v55 = *(unsigned __int16 *)(v32[4 * v24 + 3] + 2 * v123);
          }
          else {
            unsigned int v55 = 0;
          }
          int v43 = (unsigned __int16 *)PairPosFormat2::ValuePair((PairPosFormat2 *)v34, v47, v55, (unint64_t)v124);
          unint64_t v42 = v34;
          if (v43) {
            goto LABEL_86;
          }
        }
        else if (v39 == 1 && v31 <= bswap32(v34[4]) >> 16)
        {
          unint64_t v40 = PairPosFormat1::NthPairSet((PairPosFormat1 *)v34, v31 - 1, (unint64_t)v124);
          if (!v40) {
            goto LABEL_193;
          }
          unint64_t v42 = v40;
          int v43 = PairSet::ValuePair((PairSet *)v40, v123, v36, v38, v124, v41);
          if (v43)
          {
LABEL_86:
            v44.i32[0] = v35;
            int8x8_t v69 = vcnt_s8(v44);
            v69.i16[0] = vaddlv_u8((uint8x8_t)v69);
            uint64_t v70 = v69.u32[0];
            v69.i32[0] = v37;
            uint8x8_t v71 = (uint8x8_t)vcnt_s8(v69);
            v71.i16[0] = vaddlv_u8(v71);
            uint64_t v72 = (v71.i32[0] + v70);
            unint64_t v13 = v121;
            if (v34 <= v43)
            {
              uint64_t v73 = &v43[v72];
              if (v73 >= v43 && v73 <= v124) {
                goto LABEL_99;
              }
            }
            BOOL v75 = v43 + 1 > v124 || v34 > v43;
            unint64_t v76 = (unint64_t)((char *)v124 - (char *)v43) >> 1;
            if (v75) {
              unint64_t v76 = 0;
            }
            if (v76 == v72)
            {
LABEL_99:
              if (v35)
              {
                uint64_t v77 = *((void *)this + 2);
                v128 = (TRunGlue *)v43;
                LODWORD(v129) = v36;
                v130 = v42;
                uint64_t v131 = v77;
                unint64_t v132 = this;
                float v78 = ValueRecord::operator()((unsigned __int16 **)&v128, *(TRunGlue **)v121, v116);
                if (v37) {
                  goto LABEL_101;
                }
LABEL_107:
                if ((v36 & 0xFFBB) == 0)
                {
                  unint64_t v82 = *(void *)(v117 + 464);
                  if (v82)
                  {
                    uint8x8_t v83 = (uint8x8_t)vcnt_s8((int8x8_t)v82);
                    v83.i16[0] = vaddlv_u8(v83);
                    if (v83.u32[0] > 1uLL)
                    {
                      unint64_t v84 = v115;
                      if (v82 <= v115) {
                        unint64_t v84 = v115 % v82;
                      }
                    }
                    else
                    {
                      unint64_t v84 = (v82 - 1) & v115;
                    }
                    __int16 v85 = *(void ***)(*(void *)(v117 + 456) + 8 * v84);
                    if (v85)
                    {
                      uint64_t v86 = *v85;
                      if (*v85)
                      {
                        do
                        {
                          unint64_t v87 = v86[1];
                          if (v87 == v115)
                          {
                            if (*((_DWORD *)v86 + 4) == v115) {
                              goto LABEL_180;
                            }
                          }
                          else
                          {
                            if (v83.u32[0] > 1uLL)
                            {
                              if (v87 >= v82) {
                                v87 %= v82;
                              }
                            }
                            else
                            {
                              v87 &= v82 - 1;
                            }
                            if (v87 != v84) {
                              break;
                            }
                          }
                          uint64_t v86 = (void *)*v86;
                        }
                        while (v86);
                      }
                    }
                  }
                  else
                  {
                    unint64_t v84 = 0xAAAAAAAAAAAAAAAALL;
                  }
                  uint64_t v86 = operator new(0x18uLL);
                  void *v86 = 0;
                  v86[1] = v115;
                  v86[2] = v115;
                  float v88 = (float)(unint64_t)(*(void *)(v117 + 480) + 1);
                  float v89 = *(float *)(v117 + 488);
                  if (!v82 || (float)(v89 * (float)v82) < v88)
                  {
                    BOOL v90 = (v82 & (v82 - 1)) != 0;
                    if (v82 < 3) {
                      BOOL v90 = 1;
                    }
                    unint64_t v91 = v90 | (2 * v82);
                    unint64_t v92 = vcvtps_u32_f32(v88 / v89);
                    if (v91 <= v92) {
                      int8x8_t prime = (int8x8_t)v92;
                    }
                    else {
                      int8x8_t prime = (int8x8_t)v91;
                    }
                    if (*(void *)&prime == 1)
                    {
                      int8x8_t prime = (int8x8_t)2;
                    }
                    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
                    {
                      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
                      unint64_t v82 = *(void *)(v117 + 464);
                    }
                    if (*(void *)&prime <= v82)
                    {
                      if (*(void *)&prime < v82)
                      {
                        unint64_t v100 = vcvtps_u32_f32((float)*(unint64_t *)(v117 + 480) / *(float *)(v117 + 488));
                        if (v82 < 3
                          || (uint8x8_t v101 = (uint8x8_t)vcnt_s8((int8x8_t)v82), v101.i16[0] = vaddlv_u8(v101),
                                                                        v101.u32[0] > 1uLL))
                        {
                          unint64_t v100 = std::__next_prime(v100);
                        }
                        else
                        {
                          uint64_t v102 = 1 << -(char)__clz(v100 - 1);
                          if (v100 >= 2) {
                            unint64_t v100 = v102;
                          }
                        }
                        if (*(void *)&prime <= v100) {
                          int8x8_t prime = (int8x8_t)v100;
                        }
                        if (*(void *)&prime >= v82)
                        {
                          unint64_t v82 = *(void *)(v117 + 464);
                        }
                        else
                        {
                          if (prime) {
                            goto LABEL_137;
                          }
                          __int16 v109 = *(void **)(v117 + 456);
                          *(void *)(v117 + 456) = 0;
                          if (v109) {
                            operator delete(v109);
                          }
                          unint64_t v82 = 0;
                          *(void *)(v117 + 464) = 0;
                        }
                      }
                    }
                    else
                    {
LABEL_137:
                      if (*(void *)&prime >> 61) {
                        std::__throw_bad_array_new_length[abi:nn180100]();
                      }
                      uint64_t v94 = operator new(8 * *(void *)&prime);
                      uint64_t v95 = *(void **)(v117 + 456);
                      *(void *)(v117 + 456) = v94;
                      if (v95) {
                        operator delete(v95);
                      }
                      uint64_t v96 = 0;
                      *(int8x8_t *)(v117 + 464) = prime;
                      do
                        *(void *)(*(void *)(v117 + 456) + 8 * v96++) = 0;
                      while (*(void *)&prime != v96);
                      v97 = (void *)*v112;
                      if (*v112)
                      {
                        unint64_t v98 = v97[1];
                        uint8x8_t v99 = (uint8x8_t)vcnt_s8(prime);
                        v99.i16[0] = vaddlv_u8(v99);
                        if (v99.u32[0] > 1uLL)
                        {
                          if (v98 >= *(void *)&prime) {
                            v98 %= *(void *)&prime;
                          }
                        }
                        else
                        {
                          v98 &= *(void *)&prime - 1;
                        }
                        *(void *)(*(void *)(v117 + 456) + 8 * v98) = v112;
                        v103 = (void *)*v97;
                        if (*v97)
                        {
                          do
                          {
                            unint64_t v104 = v103[1];
                            if (v99.u32[0] > 1uLL)
                            {
                              if (v104 >= *(void *)&prime) {
                                v104 %= *(void *)&prime;
                              }
                            }
                            else
                            {
                              v104 &= *(void *)&prime - 1;
                            }
                            if (v104 != v98)
                            {
                              uint64_t v105 = *(void *)(v117 + 456);
                              if (!*(void *)(v105 + 8 * v104))
                              {
                                *(void *)(v105 + 8 * v104) = v97;
                                goto LABEL_162;
                              }
                              void *v97 = *v103;
                              void *v103 = **(void **)(*(void *)(v117 + 456) + 8 * v104);
                              **(void **)(*(void *)(v117 + 456) + 8 * v104) = v103;
                              v103 = v97;
                            }
                            unint64_t v104 = v98;
LABEL_162:
                            v97 = v103;
                            v103 = (void *)*v103;
                            unint64_t v98 = v104;
                          }
                          while (v103);
                        }
                      }
                      unint64_t v82 = (unint64_t)prime;
                    }
                    if ((v82 & (v82 - 1)) != 0)
                    {
                      unint64_t v84 = v115;
                      if (v82 <= v115) {
                        unint64_t v84 = v115 % v82;
                      }
                    }
                    else
                    {
                      unint64_t v84 = (v82 - 1) & v115;
                    }
                  }
                  uint64_t v106 = *(void *)(v117 + 456);
                  unint64_t v107 = *(void **)(v106 + 8 * v84);
                  if (v107)
                  {
                    void *v86 = *v107;
                    goto LABEL_178;
                  }
                  void *v86 = *v112;
                  *uint64_t v112 = v86;
                  *(void *)(v106 + 8 * v84) = v112;
                  if (*v86)
                  {
                    unint64_t v108 = *(void *)(*v86 + 8);
                    if ((v82 & (v82 - 1)) != 0)
                    {
                      if (v108 >= v82) {
                        v108 %= v82;
                      }
                    }
                    else
                    {
                      v108 &= v82 - 1;
                    }
                    unint64_t v107 = (void *)(*(void *)(v117 + 456) + 8 * v108);
LABEL_178:
                    *unint64_t v107 = v86;
                  }
                  ++*(void *)(v117 + 480);
LABEL_180:
                  *((float *)v86 + 5) = v78;
                }
              }
              else
              {
                float v78 = 0.0;
                if (!v37) {
                  goto LABEL_107;
                }
LABEL_101:
                uint64_t v79 = *((void *)this + 2);
                v128 = (TRunGlue *)&v43[v70];
                LODWORD(v129) = v38;
                v130 = v42;
                uint64_t v131 = v79;
                unint64_t v132 = this;
                if (ValueRecord::operator()((unsigned __int16 **)&v128, *(TRunGlue **)v121, v114) != 0.0)
                {
                  v128 = *(TRunGlue **)v121;
                  uint64_t v129 = v116;
                  TRunGlue::TGlyph::clearSafeToBreakAfter((uint64_t)&v128);
                }
                *((void *)v121 + 6) = v114;
              }
LABEL_181:
              char v119 = 1;
              goto LABEL_182;
            }
LABEL_193:
            char v48 = 0;
            goto LABEL_195;
          }
        }
LABEL_63:
        if (++v24 == v125)
        {
          unint64_t v13 = v121;
          goto LABEL_182;
        }
      }
    }
    while (1)
    {
      unint64_t v23 = v22[1];
      if (v23 == v17) {
        break;
      }
      if (v19.u32[0] > 1uLL)
      {
        if (v23 >= *(void *)&v18) {
          v23 %= *(void *)&v18;
        }
      }
      else
      {
        v23 &= *(void *)&v18 - 1;
      }
      if (v23 != v20) {
        goto LABEL_26;
      }
LABEL_25:
      long long v22 = (uint64_t *)*v22;
      if (!v22) {
        goto LABEL_26;
      }
    }
    if (*((_DWORD *)v22 + 4) != v17) {
      goto LABEL_25;
    }
    float v80 = *((float *)v22 + 5);
    if (v80 != 0.0)
    {
      CFIndex v81 = *(TRunGlue **)v121;
      v141.width = TRunGlue::GetAdvance(*(TRunGlue **)v121, v14) + *((double *)v81 + 80) * v80;
      TRunGlue::SetAdvance(v81, v14, v141);
      goto LABEL_181;
    }
LABEL_182:
    char v48 = v119;
  }
  while ((TGlyphIterator::Next(v13, 1) & 1) != 0);
LABEL_195:
  os_unfair_lock_unlock(v113);
  if (__p)
  {
    v137 = __p;
    if (v139 > __p || v140 <= __p) {
      operator delete(__p);
    }
  }
  return v48 & 1;
}

uint64_t TGlyphIterator::Next(TGlyphIterator *this, uint64_t a2)
{
  if (*((void *)this + 6) == *((void *)this + 3)) {
    return 0;
  }
  uint64_t v3 = a2;
  if (a2 >= 1)
  {
    while (1)
    {
      uint64_t v5 = *((int *)this + 2);
      uint64_t v6 = *((void *)this + 6) + v5;
      *((void *)this + 6) = v6;
      if ((int)v5 < 1)
      {
        if ((v5 & 0x80000000) != 0 && v6 <= *((void *)this + 3)) {
          return 0;
        }
      }
      else if (v6 >= *((void *)this + 3))
      {
        return 0;
      }
      if ((TGlyphIterator::CurrentGlyphIsIgnored(this, 0) & 1) == 0)
      {
        uint64_t result = 1;
        if (v3-- <= 1) {
          return result;
        }
      }
    }
  }
  return 1;
}

uint64_t OTL::Coverage::SearchFmt2Binary(OTL::Coverage *this, unsigned int a2)
{
  unint64_t v2 = *((void *)this + 1);
  uint64_t v3 = (unsigned __int16 *)(*(void *)this + 4);
  unsigned int v4 = *(unsigned __int16 *)(*(void *)this + 2);
  LODWORD(v5) = __rev16(v4);
  uint64_t v6 = &v3[3 * v5];
  BOOL v7 = v6 < v3 || (unint64_t)v6 > v2;
  if (v7)
  {
    if (*(void *)this + 10 > v2) {
      LODWORD(v5) = 0;
    }
    else {
      unint64_t v5 = (v2 - (unint64_t)v3) / 6;
    }
    unsigned int v4 = bswap32(v5) >> 16;
  }
  if (!v4) {
    return 0;
  }
  unsigned int v8 = *v3;
  if (a2 < bswap32(v8) >> 16) {
    return 0;
  }
  unsigned int v9 = __clz((unsigned __int16)v5) ^ 0x1F;
  uint64_t v10 = &v3[3 * (-1 << v9) + 3 * (unsigned __int16)v5];
  if (bswap32(*v10) >> 16 <= a2)
  {
    unsigned int v8 = *v10;
    uint64_t v3 = v10;
  }
  unint64_t v11 = (6 << v9);
  if (v11 >= 7)
  {
    do
    {
      if (a2 >= bswap32(*(unsigned __int16 *)((char *)v3 + (v11 >> 1))) >> 16) {
        uint64_t v3 = (unsigned __int16 *)((char *)v3 + (v11 >> 1));
      }
      BOOL v7 = v11 > 0xD;
      v11 >>= 1;
    }
    while (v7);
    unsigned int v8 = *v3;
  }
  unsigned int v12 = bswap32(v8) >> 16;
  if (v12 <= a2 && a2 <= bswap32(v3[1]) >> 16) {
    return a2 - v12 + (bswap32(v3[2]) >> 16) + 1;
  }
  else {
    return 0;
  }
}

uint64_t OTL::Coverage::SearchFmt1Binary(OTL::Coverage *this, unsigned int a2)
{
  unint64_t v2 = *((void *)this + 1);
  uint64_t v3 = (char *)(*(void *)this + 4);
  unsigned int v4 = __rev16(*(unsigned __int16 *)(*(void *)this + 2));
  unint64_t v5 = (unsigned __int16 *)&v3[2 * v4];
  if (*(void *)this + 6 <= v2) {
    unsigned int v6 = (v2 - v3) >> 1;
  }
  else {
    unsigned int v6 = 0;
  }
  unsigned int v7 = bswap32(v6) >> 16;
  BOOL v8 = v5 < (unsigned __int16 *)v3 || (unint64_t)v5 > v2;
  if (v8) {
    unsigned __int16 v9 = v6;
  }
  else {
    unsigned __int16 v9 = v4;
  }
  if (v8) {
    unsigned int v10 = v7;
  }
  else {
    unsigned int v10 = *(unsigned __int16 *)(*(void *)this + 2);
  }
  if (!v10 || a2 < bswap32(*(unsigned __int16 *)v3) >> 16) {
    return 0;
  }
  char v12 = __clz(v9) ^ 0x1F;
  unint64_t v13 = (unsigned __int16 *)&v3[2 * (-1 << v12) + 2 * v9];
  unsigned int v14 = *v13;
  if (bswap32(v14) >> 16 <= a2)
  {
    uint64_t v15 = (char *)v13;
  }
  else
  {
    unsigned int v14 = *(unsigned __int16 *)v3;
    uint64_t v15 = (char *)(*(void *)this + 4);
  }
  unint64_t v16 = (2 << v12);
  if (v16 >= 3)
  {
    do
    {
      if (a2 >= bswap32(*(unsigned __int16 *)&v15[v16 >> 1]) >> 16) {
        v15 += v16 >> 1;
      }
      BOOL v8 = v16 > 5;
      v16 >>= 1;
    }
    while (v8);
    unsigned int v14 = *(unsigned __int16 *)v15;
  }
  unint64_t v17 = (unint64_t)(v15 - v3) >> 1;
  if (a2 == bswap32(v14) >> 16) {
    return (v17 + 1);
  }
  else {
    return 0;
  }
}

uint64_t TGlyphIterator::NextCoveredBy(TGlyphIterator *this, const OTL::Lookup *a2)
{
  if (*((void *)this + 6) == *((void *)this + 3)) {
    return 0;
  }
  do
  {
    uint64_t v5 = *((int *)this + 2);
    uint64_t v6 = *((void *)this + 6) + v5;
    *((void *)this + 6) = v6;
    if ((int)v5 < 1)
    {
      if ((v5 & 0x80000000) != 0 && v6 <= *((void *)this + 3)) {
        return 0;
      }
    }
    else if (v6 >= *((void *)this + 3))
    {
      return 0;
    }
  }
  while ((TGlyphIterator::CurrentGlyphIsIgnored(this, a2) & 1) != 0);
  return 1;
}

uint64_t TGlyphIterator::CurrentGlyphIsIgnored(TGlyphIterator *this, const OTL::Lookup *a2)
{
  unsigned int v4 = *(TRunGlue **)this;
  uint64_t v5 = *((void *)this + 6);
  unsigned int GlyphID = TRunGlue::GetGlyphID(*(TRunGlue **)this, v5);
  unsigned int v7 = GlyphID;
  if (a2)
  {
    if (!OTL::CoverageBitmap::Covers((const OTL::Lookup *)((char *)a2 + 40), GlyphID) || v7 == 0xFFFF) {
      return 1;
    }
  }
  else if (GlyphID == 0xFFFF)
  {
    return 1;
  }
  if (TRunGlue::IsDeleted(v4, v5)) {
    return 1;
  }
  uint64_t v10 = *((void *)this + 9);
  if (v10) {
    return (*(unsigned __int8 *)(v10 + ((unint64_t)v7 >> 3)) >> (v7 & 7)) & 1;
  }
  else {
    return 0;
  }
}

uint64_t TRunGlue::GetGlyphID(TRunGlue *this, uint64_t a2)
{
  if (*((void *)this + 19))
  {
    TRunGlue::FocusOnIndex(this, a2);
    uint64_t v4 = *((void *)this + 22);
    uint64_t v5 = a2 - *((void *)this + 20);
  }
  else
  {
    uint64_t v4 = *((void *)this + 22);
    uint64_t v5 = *((void *)this + 20) + a2;
  }
  return *(unsigned __int16 *)(v4 + 2 * v5);
}

uint64_t TRunGlue::FocusOnIndex(TRunGlue *this, uint64_t a2)
{
  if (!*((void *)this + 19)) {
    return -1;
  }
  if (*((void *)this + 20) > a2 || *((void *)this + 21) <= a2) {
    TRunGlue::SelectRunForIndex(this, a2);
  }
  return *((void *)this + 16);
}

BOOL OTL::CoverageBitmap::Covers(OTL::CoverageBitmap *this, unsigned int a2)
{
  unsigned int v2 = *(_DWORD *)this;
  if (!*(_DWORD *)this) {
    return 0;
  }
  if (v2 == 1) {
    return *((unsigned __int16 *)this + 2) == a2;
  }
  unsigned int v4 = *((unsigned __int16 *)this + 2);
  BOOL v5 = a2 >= v4;
  unsigned __int16 v6 = a2 - v4;
  if (v5 && v2 > v6) {
    return (*(unsigned __int8 *)(*((void *)this + 5) + ((unint64_t)v6 >> 3)) >> (v6 & 7)) & 1;
  }
  else {
    return 0;
  }
}

BOOL TRunGlue::IsDeleted(TRunGlue *this, uint64_t a2)
{
  if (*((void *)this + 19))
  {
    TRunGlue::FocusOnIndex(this, a2);
    int v4 = *(_DWORD *)(*((void *)this + 65) + 4 * (a2 - *((void *)this + 20)));
LABEL_5:
    int v7 = v4 & 0x20;
    return v7 != 0;
  }
  uint64_t v5 = *((void *)this + 20) + a2;
  uint64_t v6 = *((void *)this + 65);
  if (v6)
  {
    int v4 = *(_DWORD *)(v6 + 4 * v5);
    goto LABEL_5;
  }
  uint64_t v9 = v5 + 7;
  if (v5 >= 0) {
    uint64_t v9 = *((void *)this + 20) + a2;
  }
  int v7 = (1 << (v5 & 7)) & *(unsigned __int8 *)(*((void *)this + 26) + (v9 >> 3));
  return v7 != 0;
}

void *TRunGlue::UpdateForCurrentRealRun(void *this)
{
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(this[19] + 56), memory_order_acquire);
  if (this[76] != explicit)
  {
    this[76] = explicit;
    this[77] = *(void *)(explicit + 40);
  }
  uint64_t v2 = this[19];
  uint64_t v3 = *(void **)(v2 + 216);
  uint64_t v4 = *(void *)(v2 + 200);
  this[22] = v3[2] + 2 * v4;
  this[65] = v3[5] + 4 * v4;
  this[66] = v3[6] + 8 * v4;
  return this;
}

unsigned __int16 *PairSet::ValuePair(PairSet *this, int a2, __int32 a3, __int32 a4, unsigned __int16 *a5, int8x8_t a6)
{
  if (*(_WORD *)this) {
    BOOL v6 = (char *)this + 4 > (char *)a5;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6) {
    return 0;
  }
  int v7 = (unsigned __int16 *)((char *)this + 2);
  if (a2 < (int)bswap32(*((unsigned __int16 *)this + 1)) >> 16) {
    return 0;
  }
  unsigned int v10 = __rev16(*(unsigned __int16 *)this);
  unsigned int v11 = __clz(v10);
  int v12 = v11 ^ 0x1F;
  unsigned int v13 = 1 << (v11 ^ 0x1F);
  unsigned int v14 = v10 - v13;
  a6.i32[0] = a3;
  int8x8_t v15 = vcnt_s8(a6);
  v15.i16[0] = vaddlv_u8((uint8x8_t)v15);
  __int32 v16 = v15.i32[0];
  v15.i32[0] = a4;
  uint8x8_t v17 = (uint8x8_t)vcnt_s8(v15);
  v17.i16[0] = vaddlv_u8(v17);
  unsigned __int32 v18 = v16 + v17.i32[0] + 1;
  uint8x8_t v19 = &v7[v14 * (unint64_t)v18];
  BOOL v20 = v19 < (unsigned __int16 *)this || v19 + 1 > a5;
  if (!v20 && a2 >= (int)bswap32(*v19) >> 16) {
    int v7 = v19;
  }
  if (v12)
  {
    do
    {
      uint64_t v21 = &v7[v18 * (unint64_t)(v13 >> 1)];
      BOOL v22 = v21 < (unsigned __int16 *)this || v21 + 1 > a5;
      if (!v22 && a2 >= (int)bswap32(*v21) >> 16) {
        v7 += v18 * (unint64_t)(v13 >> 1);
      }
      BOOL v6 = v13 > 3;
      v13 >>= 1;
    }
    while (v6);
  }
  uint64_t v8 = 0;
  if (v7 >= (unsigned __int16 *)this && v7 + 1 <= a5)
  {
    if (a2 == (int)bswap32(*v7) >> 16) {
      return v7 + 1;
    }
    else {
      return 0;
    }
  }
  return (unsigned __int16 *)v8;
}

unsigned __int16 *PairPosFormat1::NthPairSet(PairPosFormat1 *this, unsigned int a2, unint64_t a3)
{
  if (a2 >= bswap32(*((unsigned __int16 *)this + 4)) >> 16) {
    return 0;
  }
  if (!*((_WORD *)this + a2 + 5)) {
    return 0;
  }
  uint64_t v3 = (unsigned __int16 *)((char *)this + __rev16(*((unsigned __int16 *)this + a2 + 5)));
  uint64_t v4 = v3 + 1;
  if ((unint64_t)(v3 + 1) > a3) {
    return 0;
  }
  uint64_t v6 = bswap32(*v3) >> 16;
  unint64_t v7 = (unint64_t)&v4[v6];
  if ((unint64_t)(v3 + 2) <= a3) {
    unint64_t v8 = (a3 - (unint64_t)v4) >> 1;
  }
  else {
    unint64_t v8 = 0;
  }
  if (v7 >= (unint64_t)v4 && v7 <= a3 || v8 == v6) {
    return v3;
  }
  else {
    return 0;
  }
}

void *TRunGlue::SetAdvance(void *this, uint64_t a2, CGSize a3)
{
  CGFloat height = a3.height;
  CGFloat width = a3.width;
  uint64_t v6 = this;
  if (this[19])
  {
    TRunGlue::FocusOnIndex((TRunGlue *)this, a2);
    unint64_t v7 = (TStorageRange *)(v6[19] + 192);
    uint64_t v8 = a2 - v6[20];
    CGFloat v9 = width;
    CGFloat v10 = height;
    return (void *)TStorageRange::SetAdvance(v7, v8, *(CGSize *)&v9);
  }
  else
  {
    *(CGSize *)(this[23] + 16 * (this[20] + a2)) = a3;
  }
  return this;
}

double TRunGlue::GetAdvance(TRunGlue *this, uint64_t a2)
{
  if (*((void *)this + 19))
  {
    TRunGlue::FocusOnIndex(this, a2);
    uint64_t v4 = *((void *)this + 19);
    uint64_t v5 = a2 - *((void *)this + 20);
    uint64_t v6 = *(void *)(v4 + 216);
    uint64_t v7 = *(void *)(v6 + 32);
    if (!v7)
    {
      uint64_t v11 = *(void *)(v6 + 24);
      if (v11)
      {
        uint64_t v9 = v11 + 8 * *(void *)(v4 + 200) + 8 * v5;
        return *(double *)v9;
      }
    }
    uint64_t v8 = v7 + 16 * *(void *)(v4 + 200);
  }
  else
  {
    uint64_t v5 = *((void *)this + 20) + a2;
    uint64_t v8 = *((void *)this + 23);
  }
  uint64_t v9 = v8 + 16 * v5;
  return *(double *)v9;
}

double ValueRecord::operator()(unsigned __int16 **a1, TRunGlue *this, uint64_t a3)
{
  v29[0] = this;
  v29[1] = a3;
  uint64_t v6 = *a1;
  int v7 = *((_DWORD *)a1 + 2);
  if (v7)
  {
    unsigned int v9 = *v6++;
    unsigned int v8 = v9;
    if (v9)
    {
      TRunGlue::TGlyph::AdjustXPositionBy((TRunGlue::TGlyph *)v29, (double)((int)bswap32(v8) >> 16));
      int v7 = *((_DWORD *)a1 + 2);
    }
  }
  if ((v7 & 2) != 0)
  {
    unsigned int v11 = *v6++;
    unsigned int v10 = v11;
    if (v11)
    {
      TRunGlue::TGlyph::AdjustYPositionBy((TRunGlue::TGlyph *)v29, (double)((int)bswap32(v10) >> 16));
      int v7 = *((_DWORD *)a1 + 2);
    }
  }
  double v12 = 0.0;
  if ((v7 & 4) != 0)
  {
    unsigned int v14 = *v6++;
    unsigned int v13 = v14;
    if (v14)
    {
      if ((*(unsigned char *)a1[3] & 1) == 0)
      {
        double v12 = (double)((int)bswap32(v13) >> 16);
        v30.CGFloat width = TRunGlue::GetAdvance(this, a3) + *((double *)this + 80) * v12;
        TRunGlue::SetAdvance(this, a3, v30);
        int v7 = *((_DWORD *)a1 + 2);
      }
    }
  }
  if ((v7 & 8) != 0)
  {
    unsigned int v16 = *v6++;
    unsigned int v15 = v16;
    if (v16)
    {
      if (*(unsigned char *)a1[3])
      {
        v31.CGFloat width = TRunGlue::GetAdvance(this, a3) + *((double *)this + 81) * (double)((int)bswap32(v15) >> 16);
        TRunGlue::SetAdvance(this, a3, v31);
        int v7 = *((_DWORD *)a1 + 2);
      }
    }
  }
  if ((v7 & 0xF0) != 0)
  {
    unint64_t v28 = 0xAAAAAAAAAAAAAAAALL;
    VariationValues = (const __int16 *)TFont::GetVariationValues((atomic_ullong *)a1[3], &v28);
    if (VariationValues)
    {
      unsigned __int32 v18 = VariationValues;
      if (((_BYTE)a1[1] & 0x10) != 0)
      {
        unsigned int v19 = *v6++;
        double v20 = OTL::GDEF::DeltaValue(*((OTL::GDEF **)a1[4] + 3), (char *)a1[2], *((void *)a1[4] + 5), bswap32(v19) >> 16, v28, VariationValues);
        if (v20 != 0.0) {
          TRunGlue::TGlyph::AdjustXPositionBy((TRunGlue::TGlyph *)v29, v20);
        }
      }
      if (((_BYTE)a1[1] & 0x20) != 0)
      {
        unsigned int v21 = *v6++;
        double v22 = OTL::GDEF::DeltaValue(*((OTL::GDEF **)a1[4] + 3), (char *)a1[2], *((void *)a1[4] + 5), bswap32(v21) >> 16, v28, v18);
        if (v22 != 0.0) {
          TRunGlue::TGlyph::AdjustYPositionBy((TRunGlue::TGlyph *)v29, v22);
        }
      }
      if (((_BYTE)a1[1] & 0x40) != 0)
      {
        unsigned int v23 = *v6++;
        double v24 = OTL::GDEF::DeltaValue(*((OTL::GDEF **)a1[4] + 3), (char *)a1[2], *((void *)a1[4] + 5), bswap32(v23) >> 16, v28, v18);
        if (v24 != 0.0 && (*(unsigned char *)a1[3] & 1) == 0)
        {
          double v25 = v24;
          v32.CGFloat width = TRunGlue::GetAdvance(this, a3) + *((double *)this + 80) * v24;
          TRunGlue::SetAdvance(this, a3, v32);
          double v12 = v12 + v25;
        }
      }
      if (((_BYTE)a1[1] & 0x80) != 0)
      {
        double v26 = OTL::GDEF::DeltaValue(*((OTL::GDEF **)a1[4] + 3), (char *)a1[2], *((void *)a1[4] + 5), bswap32(*v6) >> 16, v28, v18);
        if (v26 != 0.0 && (*(unsigned char *)a1[3] & 1) != 0)
        {
          v33.CGFloat width = TRunGlue::GetAdvance(this, a3) + *((double *)this + 81) * v26;
          TRunGlue::SetAdvance(this, a3, v33);
        }
      }
    }
  }
  return v12;
}

unint64_t TFont::GetVariationValues(atomic_ullong *this, unint64_t *a2)
{
  unint64_t explicit = atomic_load_explicit(this + 42, memory_order_acquire);
  if (!explicit)
  {
    uint64_t v5 = (TBaseFont *)this[50];
    (*(void (**)(id *__return_ptr, TBaseFont *))(*(void *)v5 + 120))(&v8, v5);
    unint64_t v6 = atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire);

    if (v6)
    {
      if (TBaseFont::GetInitializedGraphicsFont(v5))
      {
        if (CGFontGetParserFont())
        {
          id v8 = (id)0xAAAAAAAAAAAAAAAALL;
          if (FPFontGetVariationValues()) {
            operator new[]();
          }
        }
      }
    }
    unint64_t explicit = 0;
    atomic_store(0xFFFFFFFFFFFFFFFFLL, (unint64_t *)this + 42);
    goto LABEL_11;
  }
  if (explicit == -1)
  {
    unint64_t explicit = 0;
LABEL_11:
    *a2 = 0;
    return explicit;
  }
  *a2 = this[41];
  return explicit;
}

double OTL::GDEF::DeltaValue(OTL::GDEF *this, char *a2, unint64_t a3, int a4, unint64_t a5, const __int16 *a6)
{
  if (a4 && (unint64_t v6 = &a2[a4], (unint64_t)(v6 + 6) <= a3) && *((_WORD *)v6 + 2) == 128) {
    return ItemVariationStore::ValueForDeltaSet((OTL::GDEF *)((char *)this + 32), bswap32(*(unsigned __int16 *)v6) >> 16, bswap32(*((unsigned __int16 *)v6 + 1)) >> 16, a5, a6, 0);
  }
  else {
    return 0.0;
  }
}

char *PairPosFormat2::ValuePair(PairPosFormat2 *this, unsigned int a2, unsigned int a3, unint64_t a4)
{
  if (a2 >= bswap32(*((unsigned __int16 *)this + 6)) >> 16) {
    return 0;
  }
  unsigned int v4 = bswap32(*((unsigned __int16 *)this + 7)) >> 16;
  if (v4 <= a3) {
    return 0;
  }
  v5.i32[0] = *((unsigned __int16 *)this + 2);
  v5.i32[1] = *((unsigned __int16 *)this + 3);
  uint16x4_t v6 = vpaddl_u8((uint8x8_t)vcnt_s8(v5));
  unsigned __int32 v7 = vpadal_u16((uint32x2_t)vdup_lane_s32((int32x2_t)vpaddl_u16(v6), 1), v6).u32[0];
  id v8 = (char *)this + 2 * (a3 + a2 * (unint64_t)v4) * v7 + 16;
  unint64_t v9 = (unint64_t)&v8[2 * v7];
  if (v8 >= (char *)this && v9 >= (unint64_t)v8 && v9 <= a4) {
    return v8;
  }
  uint64_t v12 = 0;
  BOOL v13 = (unint64_t)(v8 + 2) <= a4 && v8 >= (char *)this;
  unint64_t v14 = (a4 - (unint64_t)v8) >> 1;
  if (!v13) {
    unint64_t v14 = 0;
  }
  if (v14 == v7) {
    return v8;
  }
  return (char *)v12;
}

TRunGlue *TRunGlue::SelectRunForIndex(TRunGlue *this, uint64_t a2)
{
  uint64_t v2 = this;
  if (a2 < 0)
  {
    *((void *)this + 16) = *((void *)this + 1) - 1;
    uint64_t v7 = -1;
LABEL_7:
    *((void *)v2 + 20) = v7;
    *((void *)v2 + 21) = v7;
    return this;
  }
  this = (TRunGlue *)TRunGlue::length(this);
  if ((uint64_t)this <= a2)
  {
    *((void *)v2 + 16) = *((void *)v2 + 2) + *((void *)v2 + 1);
    uint64_t v7 = *((void *)v2 + 4);
    goto LABEL_7;
  }
  uint64_t v4 = *((void *)v2 + 20);
  if (v4 == *((void *)v2 + 21))
  {
    uint64_t v5 = *((void *)v2 + 1);
    uint64_t v6 = *((void *)v2 + 2) + v5;
LABEL_10:
    *((void *)v2 + 16) = v5 - 1;
    *((void *)v2 + 21) = 0;
    goto LABEL_12;
  }
  if (v4 > a2)
  {
    uint64_t v6 = *((void *)v2 + 16);
    uint64_t v5 = *((void *)v2 + 1);
    goto LABEL_10;
  }
  uint64_t v6 = *((void *)v2 + 2) + *((void *)v2 + 1);
  do
  {
LABEL_12:
    uint64_t v8 = *((void *)v2 + 16) + 1;
    *((void *)v2 + 16) = v8;
    if (v8 >= v6) {
      break;
    }
    uint64_t v9 = *(void *)v2;
    uint64_t v10 = *(void *)(*(void *)(*(void *)(v9 + 16) + 8 * TRunGlue::PhysicalRunIndexFromLogical(v2, v8)) + 48);
    uint64_t v11 = *((void *)v2 + 21);
    *((void *)v2 + 19) = v10;
    *((void *)v2 + 20) = v11;
    uint64_t v12 = *(void *)(v10 + 208) + v11;
    *((void *)v2 + 21) = v12;
  }
  while (v12 <= a2);

  return (TRunGlue *)TRunGlue::UpdateForCurrentRealRun(v2);
}

uint64_t TRunGlue::PhysicalRunIndexFromLogical(TRunGlue *this, uint64_t a2)
{
  uint64_t v2 = a2;
  if (*((int *)this + 6) <= 0)
  {
    uint64_t v4 = *((void *)this + 17);
    uint64_t v5 = *((void *)this + 18) + v4;
    if (v4 > a2 || v5 <= a2)
    {
      TRunGlue::InitLevelRange(this);
      uint64_t v4 = *((void *)this + 17);
      uint64_t v5 = *((void *)this + 18) + v4;
    }
    uint64_t v7 = *((void *)this + 1);
    uint64_t v8 = *((void *)this + 2) + v7;
    if (v8 >= v5) {
      uint64_t v9 = v5;
    }
    else {
      uint64_t v9 = *((void *)this + 2) + v7;
    }
    if (v4 <= v7 && v7 < v5)
    {
      uint64_t v11 = v9 - v7;
    }
    else if (v7 > v4)
    {
      uint64_t v7 = 0;
      uint64_t v11 = 0;
    }
    else
    {
      if (v4 < v8) {
        uint64_t v7 = v4;
      }
      else {
        uint64_t v7 = 0;
      }
      if (v4 < v8) {
        uint64_t v11 = v9 - v4;
      }
      else {
        uint64_t v11 = 0;
      }
    }
    return v11 + ~v2 + 2 * v7;
  }
  return v2;
}

double ItemVariationStore::ValueForDeltaSet(ItemVariationStore *this, unsigned int a2, unsigned int a3, unint64_t a4, const __int16 *a5, const double *a6)
{
  double v6 = 0.0;
  if ((a3 & a2) != 0xFFFF)
  {
    unint64_t v8 = *(void *)this;
    if (*(void *)this)
    {
      if (*((void *)this + 4) > (unint64_t)a2)
      {
        unsigned int v9 = *(_DWORD *)(*((void *)this + 5) + 4 * a2);
        if (v9)
        {
          uint64_t v10 = bswap32(v9);
          uint64_t v11 = (unsigned __int16 *)(v8 + v10);
          unint64_t v12 = *((void *)this + 1);
          BOOL v13 = (unsigned __int16 *)(v8 + v10 + 6);
          if ((unint64_t)v13 <= v12)
          {
            unint64_t v14 = bswap32(v11[2]) >> 16;
            unsigned int v15 = bswap32(*v11) >> 16;
            int v16 = bswap32(v11[1]);
            unint64_t v17 = HIWORD(v16) & 0x7FFF;
            unint64_t v18 = (v17 + v14) << (v16 < 0);
            unint64_t v19 = (unint64_t)&v11[v14 + 3] + v18 * (unint64_t)v15;
            BOOL v20 = v19 < (unint64_t)v11 || v19 > v12;
            if (!v20)
            {
              if (v15 <= a3)
              {
                double v25 = 0;
                unint64_t v17 = 0xAAAAAAAAAAAAAAAALL;
                int v24 = 170;
                unint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
                unint64_t v18 = 0xAAAAAAAAAAAAAAAALL;
              }
              else
              {
                int v24 = v16 >> 31;
                double v25 = (unsigned int *)((char *)&v13[v14] + v18 * (unint64_t)a3);
              }
              double v26 = (char *)v25 + v18;
              if ((unint64_t)v26 <= v12 && v8 <= (unint64_t)v25 && v26 >= (char *)v25)
              {
                if (v24)
                {
                  if (v17)
                  {
                    uint64_t v50 = &v25[v17];
                    uint64_t v52 = v10;
                    unint64_t v27 = v17;
                    while (1)
                    {
                      unsigned int v28 = *v13++;
                      unint64_t v29 = bswap32(v28) >> 16;
                      if (*((void *)this + 2) <= v29) {
                        break;
                      }
                      if (a6) {
                        double v30 = a6[v29];
                      }
                      else {
                        double v30 = ItemVariationStore::VariationRegionList::ComputeScalar(*((ItemVariationStore::VariationRegionList **)this + 3), v29, a4, a5);
                      }
                      unsigned int v31 = *v25++;
                      double v6 = v6 + v30 * (double)(int)bswap32(v31);
                      if (!--v27)
                      {
                        double v25 = v50;
                        uint64_t v10 = v52;
                        goto LABEL_24;
                      }
                    }
                  }
                  else
                  {
LABEL_24:
                    BOOL v20 = v14 > v17;
                    unint64_t v32 = v14 - v17;
                    if (!v20) {
                      return v6;
                    }
                    CGSize v33 = (unsigned __int16 *)(v10 + 2 * v17 + v8 + 6);
                    while (1)
                    {
                      unsigned int v34 = *v33++;
                      unint64_t v35 = bswap32(v34) >> 16;
                      if (*((void *)this + 2) <= v35) {
                        break;
                      }
                      if (a6) {
                        double v36 = a6[v35];
                      }
                      else {
                        double v36 = ItemVariationStore::VariationRegionList::ComputeScalar(*((ItemVariationStore::VariationRegionList **)this + 3), v35, a4, a5);
                      }
                      unsigned int v37 = *(unsigned __int16 *)v25;
                      double v25 = (unsigned int *)((char *)v25 + 2);
                      double v6 = v6 + v36 * (double)((int)bswap32(v37) >> 16);
                      if (!--v32) {
                        return v6;
                      }
                    }
                  }
                }
                else if (v17)
                {
                  uint64_t v51 = (unsigned int *)((char *)v25 + 2 * v17);
                  uint64_t v53 = v10;
                  unint64_t v38 = v17;
                  while (1)
                  {
                    unsigned int v39 = *v13++;
                    unint64_t v40 = bswap32(v39) >> 16;
                    if (*((void *)this + 2) <= v40) {
                      break;
                    }
                    if (a6) {
                      double v41 = a6[v40];
                    }
                    else {
                      double v41 = ItemVariationStore::VariationRegionList::ComputeScalar(*((ItemVariationStore::VariationRegionList **)this + 3), v40, a4, a5);
                    }
                    unsigned int v42 = *(unsigned __int16 *)v25;
                    double v25 = (unsigned int *)((char *)v25 + 2);
                    double v6 = v6 + v41 * (double)((int)bswap32(v42) >> 16);
                    if (!--v38)
                    {
                      double v25 = v51;
                      uint64_t v10 = v53;
                      goto LABEL_41;
                    }
                  }
                }
                else
                {
LABEL_41:
                  BOOL v20 = v14 > v17;
                  unint64_t v43 = v14 - v17;
                  if (!v20) {
                    return v6;
                  }
                  int8x8_t v44 = (unsigned __int16 *)(v10 + 2 * v17 + v8 + 6);
                  while (1)
                  {
                    unsigned int v45 = *v44++;
                    unint64_t v46 = bswap32(v45) >> 16;
                    if (*((void *)this + 2) <= v46) {
                      break;
                    }
                    if (a6) {
                      double v47 = a6[v46];
                    }
                    else {
                      double v47 = ItemVariationStore::VariationRegionList::ComputeScalar(*((ItemVariationStore::VariationRegionList **)this + 3), v46, a4, a5);
                    }
                    int v48 = *(char *)v25;
                    double v25 = (unsigned int *)((char *)v25 + 1);
                    double v6 = v6 + v47 * (double)v48;
                    if (!--v43) {
                      return v6;
                    }
                  }
                }
                return 0.0;
              }
            }
          }
        }
      }
    }
  }
  return v6;
}

double ItemVariationStore::VariationRegionList::ComputeScalar(ItemVariationStore::VariationRegionList *this, uint64_t a2, unint64_t a3, const __int16 *a4)
{
  unint64_t v4 = bswap32(*(unsigned __int16 *)this) >> 16;
  if (v4 >= a3) {
    unint64_t v5 = a3;
  }
  else {
    unint64_t v5 = v4;
  }
  if (!v5) {
    return 1.0;
  }
  uint64_t v7 = (ItemVariationStore::VariationRegionList *)((char *)this + 6 * v4 * a2 + 4);
  double v8 = 1.0;
  while (1)
  {
    int v9 = *a4++;
    double v10 = ItemVariationStore::RegionAxisCoordinates::ComputeScalar(v7, v9);
    if (v10 == 0.0) {
      break;
    }
    double v8 = v8 * v10;
    uint64_t v7 = (ItemVariationStore::RegionAxisCoordinates *)((char *)v7 + 6);
    if (!--v5) {
      return v8;
    }
  }
  return 0.0;
}

double ItemVariationStore::RegionAxisCoordinates::ComputeScalar(ItemVariationStore::RegionAxisCoordinates *this, int a2)
{
  int v2 = bswap32(*(unsigned __int16 *)this);
  unsigned int v3 = *((unsigned __int16 *)this + 1);
  int v4 = (int)bswap32(v3) >> 16;
  double result = 1.0;
  if (v4 >= v2 >> 16)
  {
    int v6 = (int)bswap32(*((unsigned __int16 *)this + 2)) >> 16;
    if (v6 >= v4)
    {
      int v7 = v2 >> 16;
      BOOL v8 = v6 > 0 && v7 < 0;
      if (!v8 && v3 != 0)
      {
        double result = 0.0;
        if (v7 <= a2 && v6 >= a2)
        {
          double result = 1.0;
          if (v4 != a2)
          {
            if (v4 <= a2)
            {
              double v11 = (double)(v6 - a2);
              int v12 = v6 - v4;
            }
            else
            {
              double v11 = (double)(a2 - v7);
              int v12 = v4 - v7;
            }
            return v11 / (double)v12;
          }
        }
      }
    }
  }
  return result;
}

void *OTL::ClassDefTable::Iterate(void *result, uint64_t a2)
{
  unsigned int v3 = result;
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  unsigned int v4 = bswap32(*(unsigned __int16 *)result) >> 16;
  if (v4 == 2)
  {
    unsigned int v10 = *((unsigned __int16 *)result + 1);
    std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)v13, a2);
    if (v10)
    {
      double v11 = (unsigned __int16 *)v3 + 2;
      uint64_t v12 = (uint64_t)v3 + 6 * __rev16(v10) + 4;
      do
      {
        std::function<void ()(unsigned short,unsigned short,unsigned short)>::operator()((uint64_t)v13, bswap32(*v11) >> 16, bswap32(v11[1]) >> 16, bswap32(v11[2]) >> 16);
        v11 += 3;
      }
      while (v11 != (unsigned __int16 *)v12);
    }
    if (v14)
    {
      if (v14 == v13)
      {
        int v16 = v15;
        (*(void (**)(void *, void *))(v13[0] + 24))(v13, v15);
      }
      else
      {
        int v16 = v14;
        unint64_t v14 = 0;
      }
    }
    else
    {
      int v16 = 0;
    }
    std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100](v15);
    return std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100](v13);
  }
  else if (v4 == 1 && *((_WORD *)result + 2))
  {
    uint64_t v5 = 0;
    unsigned int v6 = bswap32(*((unsigned __int16 *)result + 1)) >> 16;
    unsigned int v7 = __rev16(*((unsigned __int16 *)result + 2));
    if (v7 <= 1) {
      uint64_t v8 = 1;
    }
    else {
      uint64_t v8 = v7;
    }
    int v9 = (char *)result + 6;
    do
    {
      double result = (void *)std::function<void ()(unsigned short,unsigned short,unsigned short)>::operator()(a2, (unsigned __int16)v6 + (unsigned __int16)v5, (unsigned __int16)v6 + (unsigned __int16)v5, bswap32(*(unsigned __int16 *)&v9[2 * v5]) >> 16);
      ++v5;
    }
    while (v8 != v5);
  }
  return result;
}

uint64_t std::function<void ()(unsigned short,unsigned short,unsigned short)>::operator()(uint64_t a1, __int16 a2, __int16 a3, __int16 a4)
{
  __int16 v12 = a2;
  __int16 v11 = a3;
  __int16 v10 = a4;
  uint64_t v4 = *(void *)(a1 + 24);
  if (v4) {
    return (*(uint64_t (**)(uint64_t, __int16 *, __int16 *, __int16 *))(*(void *)v4 + 48))(v4, &v12, &v11, &v10);
  }
  uint64_t v6 = std::__throw_bad_function_call[abi:nn180100]();
  return std::__function::__func<OTL::GPOS::ApplyPairPosAccelerated(OTL::Lookup const&,TGlyphIterator &)::$_3,std::allocator<OTL::GPOS::ApplyPairPosAccelerated(OTL::Lookup const&,TGlyphIterator &)::$_3>,void ()(unsigned short,unsigned short,unsigned short)>::operator()(v6, v7, v8, v9);
}

uint64_t std::__function::__func<OTL::GPOS::ApplyPairPosAccelerated(OTL::Lookup const&,TGlyphIterator &)::$_3,std::allocator<OTL::GPOS::ApplyPairPosAccelerated(OTL::Lookup const&,TGlyphIterator &)::$_3>,void ()(unsigned short,unsigned short,unsigned short)>::operator()(uint64_t result, unsigned __int16 *a2, unsigned __int16 *a3, __int16 *a4)
{
  unsigned int v4 = *a2;
  unsigned int v5 = *a3;
  if (v4 <= v5 && v4 != (unsigned __int16)(v5 + 1))
  {
    __int16 v6 = *a4;
    uint64_t v7 = *(void *)(result + 8);
    do
      *(_WORD *)(v7 + 2 * (unsigned __int16)v4) = v6;
    while (v5 != (unsigned __int16)v4++);
  }
  return result;
}

uint64_t std::__function::__func<OTL::GPOS::ApplyPairPosAccelerated(OTL::Lookup const&,TGlyphIterator &)::$_1,std::allocator<OTL::GPOS::ApplyPairPosAccelerated(OTL::Lookup const&,TGlyphIterator &)::$_1>,void ()(unsigned short,unsigned short,unsigned short)>::operator()(uint64_t result, uint64_t a2, unsigned __int16 *a3)
{
  unsigned int v3 = *a3;
  unsigned int v4 = *(_WORD **)(result + 8);
  if ((unsigned __int16)*v4 < v3) {
    _WORD *v4 = v3;
  }
  return result;
}

uint64_t std::__function::__func<OTL::GPOS::ApplyPairPosAccelerated(OTL::Lookup const&,TGlyphIterator &)::$_2,std::allocator<OTL::GPOS::ApplyPairPosAccelerated(OTL::Lookup const&,TGlyphIterator &)::$_2>,void ()(unsigned short,unsigned short,unsigned short)>::operator()(uint64_t result, unsigned __int16 *a2, unsigned __int16 *a3, __int16 *a4)
{
  unsigned int v4 = *a2;
  unsigned int v5 = *a3;
  if (v4 <= v5 && v4 != (unsigned __int16)(v5 + 1))
  {
    __int16 v6 = *a4;
    uint64_t v7 = *(void *)(result + 8);
    do
      *(_WORD *)(v7 + 2 * (unsigned __int16)v4) = v6;
    while (v5 != (unsigned __int16)v4++);
  }
  return result;
}

uint64_t std::__function::__func<OTL::GPOS::ApplyPairPosAccelerated(OTL::Lookup const&,TGlyphIterator &)::$_0,std::allocator<OTL::GPOS::ApplyPairPosAccelerated(OTL::Lookup const&,TGlyphIterator &)::$_0>,void ()(unsigned short,unsigned short,unsigned short)>::operator()(uint64_t result, uint64_t a2, unsigned __int16 *a3)
{
  unsigned int v3 = *a3;
  unsigned int v4 = *(_WORD **)(result + 8);
  if ((unsigned __int16)*v4 < v3) {
    _WORD *v4 = v3;
  }
  return result;
}

void *std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100](void *a1)
{
  int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::__value_func[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *TSimpleTracking::TrackRun(void *this, TRun *a2, double a3)
{
  unsigned int v4 = this;
  uint64_t v6 = this[26];
  uint64_t v5 = this[27];
  uint64_t v7 = *(void *)(v5 + 32);
  if (v7 || (uint64_t v10 = *(void *)(v5 + 24)) == 0)
  {
    int v8 = 0;
    uint64_t v9 = v7 + 16 * this[25];
  }
  else
  {
    uint64_t v9 = v10 + 8 * this[25];
    int v8 = 1;
  }
  if (v6 >= 1)
  {
    uint64_t v11 = 0;
    uint64_t v12 = v9;
    do
    {
      uint64_t v13 = v4[27];
      uint64_t v14 = v4[25];
      if (*(__int16 *)(*(void *)(v13 + 16) + 2 * v14 + 2 * v11) != -1
        && (*(_DWORD *)(*(void *)(v13 + 40) + 4 * v14 + 4 * v11) & 0x20) == 0)
      {
        if (v8)
        {
          unsigned int v15 = (double *)(v9 + 8 * v11);
          uint64_t v16 = 0;
        }
        else
        {
          uint64_t v16 = *(void *)(v12 + 8);
          unsigned int v15 = (double *)v12;
        }
        double v17 = *v15 + a3;
        if (v17 < 0.0) {
          double v17 = 0.0;
        }
        this = (void *)TStorageRange::SetAdvance((TStorageRange *)(v4 + 24), v11, *(CGSize *)(&v16 - 1));
      }
      ++v11;
      v12 += 16;
    }
    while (v6 != v11);
  }
  return this;
}

uint64_t TStorageRange::SetAdvance(TStorageRange *this, uint64_t a2, CGSize a3)
{
  uint64_t v3 = (void *)*((void *)this + 3);
  uint64_t v4 = v3[4];
  if (v4 || (uint64_t v7 = v3[3]) == 0)
  {
    uint64_t v5 = *((void *)this + 1);
    uint64_t v6 = (double *)(v4 + 16 * v5 + 16 * a2);
  }
  else
  {
    uint64_t v5 = *((void *)this + 1);
    uint64_t v6 = (double *)(v7 + 8 * v5 + 8 * a2);
  }
  *(double *)this = *(double *)this + a3.width - *v6;
  return objc_msgSend(v3, "setAdvance:atIndex:", v5 + a2);
}

uint64_t TASCIIEncoder::Encode(TASCIIEncoder *this, int a2)
{
  uint64_t v3 = *(void *)(*((void *)this + 4) + 48);
  uint64_t v4 = *(atomic_ullong **)(atomic_load_explicit((atomic_ullong *volatile)(v3 + 56), memory_order_acquire) + 40);
  if (v4[50])
  {
    unint64_t explicit = (atomic_ullong *)atomic_load_explicit(v4 + 48, memory_order_acquire);
    if (!explicit) {
      TFont::InitASCIIDataCache((TFont *)v4);
    }
    uint64_t v6 = *((void *)this + 3);
    if (v6 >= 1)
    {
      int v7 = 0;
      int v8 = (void *)*((void *)this + 1);
      uint64_t v9 = *((void *)this + 2);
      uint64_t v10 = v8[5];
      uint64_t v11 = v8[6];
      uint64_t v12 = v6 + v9;
      double v26 = explicit + 1;
      uint64_t v27 = v8[2];
      double v25 = explicit + 49;
      double v13 = 0.0;
      while (1)
      {
        *(void *)(v11 + 8 * v9) = v9;
        unsigned int Char = TCharStreamIterator::GetChar(*(TCharStreamIterator **)this, v9);
        __int16 v15 = Char;
        unsigned __int16 v16 = Char - 32;
        if (Char < 0x20)
        {
          if ((unsigned __int16)(Char - 14) < 0xFFFBu) {
            goto LABEL_25;
          }
          unint64_t v19 = atomic_load_explicit(explicit + 242, memory_order_acquire);
          if (!v19) {
            TASCIIDataCache::InitC0Whitespace((TASCIIDataCache *)explicit);
          }
          unint64_t v20 = v19 + 16 * (unsigned __int16)(v15 - 9);
          uint64_t v17 = *(void *)v20;
          double v18 = *(double *)(v20 + 8);
        }
        else
        {
          if (Char > 0x7F)
          {
            if ((unsigned __int16)((unsigned __int16)(Char - 256) >> 5) < 0x7FDu)
            {
              LODWORD(v17) = 0;
              double v18 = 0.0;
              goto LABEL_18;
            }
            unsigned __int16 v16 = Char - 64;
          }
          unint64_t v21 = atomic_load_explicit(explicit + 241, memory_order_acquire);
          if (!v21) {
            TASCIIDataCache::InitProps((TASCIIDataCache *)explicit);
          }
          double v18 = *(double *)&v25[v16];
          LODWORD(v17) = *((unsigned __int16 *)v26 + v16) | (*(unsigned __int16 *)(v21 + 2 * v16) << 16);
        }
LABEL_18:
        if ((_WORD)v17)
        {
          if ((v17 & 0x40000) != 0) {
            *(unsigned char *)(v3 + 225) |= 1u;
          }
          unsigned int v22 = WORD1(v17) & 0x7FFF;
          if (a2)
          {
            unsigned int v23 = v7 | 1;
            if ((int)v17 < 0) {
              unsigned int v22 = WORD1(v17) & 0x7FEF | 0x10;
            }
            else {
              unsigned int v23 = v7;
            }
          }
          else
          {
            unsigned int v23 = (v17 >> 20) & 1 | v7;
          }
          int v7 = (v22 >> 1) & 0x10 | v23;
          *(_WORD *)(v27 + 2 * v9) = v17;
          *(_DWORD *)(v10 + 4 * v9) = v22;
          objc_msgSend(*((id *)this + 1), "setAdvance:atIndex:", v9, v18, 0.0, v25, v26);
          double v13 = v13 + v18;
          goto LABEL_28;
        }
LABEL_25:
        v7 |= 8u;
LABEL_28:
        if (++v9 >= v12) {
          goto LABEL_31;
        }
      }
    }
    LOBYTE(v7) = 0;
    double v13 = 0.0;
LABEL_31:
    *(double *)(v3 + 192) = v13;
  }
  else
  {
    LOBYTE(v7) = 8;
  }
  return (char)v7;
}

uint64_t TCharStreamIterator::GetChar(TCharStreamIterator *this, uint64_t a2)
{
  uint64_t v3 = (char *)this + 8;
  uint64_t v4 = *((void *)this + 22);
  BOOL v5 = __OFSUB__(a2, v4);
  uint64_t v6 = a2 - v4;
  if (v6 < 0 != v5 || *((void *)this + 23) <= a2) {
    return (*(uint64_t (**)(void, char *))(**(void **)this + 80))(*(void *)this, v3);
  }
  uint64_t v7 = *((void *)this + 18);
  if (v7)
  {
    return *(unsigned __int16 *)(v7 + 2 * v6);
  }
  else
  {
    uint64_t v10 = *((void *)this + 19);
    if (v10) {
      return (unsigned __int16)*(char *)(v10 + v6);
    }
    else {
      return *(unsigned __int16 *)&v3[2 * v6];
    }
  }
}

uint64_t OTL::Coverage::SearchFmt2Linear(OTL::Coverage *this, unsigned int a2)
{
  uint64_t v2 = *(void *)this;
  unint64_t v3 = *((void *)this + 1);
  unint64_t v4 = *(void *)this + 4;
  unsigned int v5 = *(unsigned __int16 *)(*(void *)this + 2);
  unint64_t v6 = __rev16(v5);
  unint64_t v7 = v4 + 6 * v6;
  if (v7 < v4 || v7 > v3)
  {
    if (v2 + 10 > v3) {
      LODWORD(v6) = 0;
    }
    else {
      unint64_t v6 = (v3 - v4) / 6;
    }
    unsigned int v5 = bswap32(v6) >> 16;
    unint64_t v6 = (unsigned __int16)v6;
  }
  if (!v5) {
    return 0;
  }
  uint64_t v9 = (unsigned __int16 *)(v2 + 8);
  uint64_t v10 = 6 * v6;
  while (1)
  {
    if (a2 <= bswap32(*(v9 - 1)) >> 16)
    {
      unsigned int v11 = bswap32(*(v9 - 2)) >> 16;
      if (v11 <= a2) {
        break;
      }
    }
    v9 += 3;
    v10 -= 6;
    if (!v10) {
      return 0;
    }
  }
  return a2 - v11 + (bswap32(*v9) >> 16) + 1;
}

uint64_t std::__function::__func<OTL::GPOS::ApplyPairPosAccelerated(OTL::Lookup const&,TGlyphIterator &)::$_3,std::allocator<OTL::GPOS::ApplyPairPosAccelerated(OTL::Lookup const&,TGlyphIterator &)::$_3>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1ED061988;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<OTL::GPOS::ApplyPairPosAccelerated(OTL::Lookup const&,TGlyphIterator &)::$_2,std::allocator<OTL::GPOS::ApplyPairPosAccelerated(OTL::Lookup const&,TGlyphIterator &)::$_2>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1ED061940;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<OTL::GPOS::ApplyPairPosAccelerated(OTL::Lookup const&,TGlyphIterator &)::$_1,std::allocator<OTL::GPOS::ApplyPairPosAccelerated(OTL::Lookup const&,TGlyphIterator &)::$_1>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1ED0618F8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<OTL::GPOS::ApplyPairPosAccelerated(OTL::Lookup const&,TGlyphIterator &)::$_0,std::allocator<OTL::GPOS::ApplyPairPosAccelerated(OTL::Lookup const&,TGlyphIterator &)::$_0>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1ED0618B0;
  a2[1] = v2;
  return result;
}

uint64_t TGlyphIterator::PrevContext(TGlyphIterator *this, uint64_t a2)
{
  if (*((void *)this + 6) == *((void *)this + 4)) {
    return 0;
  }
  uint64_t v3 = a2;
  if (a2 >= 1)
  {
    while (1)
    {
      uint64_t v5 = *((int *)this + 2);
      uint64_t v6 = *((void *)this + 6) - v5;
      *((void *)this + 6) = v6;
      if ((int)v5 < 1)
      {
        if ((v5 & 0x80000000) != 0 && v6 >= *((void *)this + 4)) {
          return 0;
        }
      }
      else if (v6 <= *((void *)this + 4))
      {
        return 0;
      }
      if ((TGlyphIterator::CurrentGlyphIsIgnored(this, 0) & 1) == 0)
      {
        uint64_t result = 1;
        if (v3-- <= 1) {
          return result;
        }
      }
    }
  }
  return 1;
}

unsigned __int16 *ChainContextSubstFormat2::NthChainSubClassSet(ChainContextSubstFormat2 *this, unsigned int a2, unint64_t a3)
{
  if (a2 >= bswap32(*((unsigned __int16 *)this + 5)) >> 16) {
    return 0;
  }
  if (!*((_WORD *)this + a2 + 6)) {
    return 0;
  }
  uint64_t v3 = (unsigned __int16 *)((char *)this + __rev16(*((unsigned __int16 *)this + a2 + 6)));
  unint64_t v4 = v3 + 1;
  if ((unint64_t)(v3 + 1) > a3) {
    return 0;
  }
  uint64_t v6 = bswap32(*v3) >> 16;
  unint64_t v7 = (unint64_t)&v4[v6];
  if ((unint64_t)(v3 + 2) <= a3) {
    unint64_t v8 = (a3 - (unint64_t)v4) >> 1;
  }
  else {
    unint64_t v8 = 0;
  }
  if (v7 >= (unint64_t)v4 && v7 <= a3 || v8 == v6) {
    return v3;
  }
  else {
    return 0;
  }
}

uint64_t *std::__function::__func<OTL::GSUB::ApplySubstLookupRecords(OTL::LookupSubtable const*,OTL::SubstLookupRecord const*,unsigned int,TGlyphIterator &,long,long *,unsigned long,unsigned short *,OTL::SubstitutionState *,unsigned long)::$_1,std::allocator<OTL::GSUB::ApplySubstLookupRecords(OTL::LookupSubtable const*,OTL::SubstLookupRecord const*,unsigned int,TGlyphIterator &,long,long *,unsigned long,unsigned short *,OTL::SubstitutionState *,unsigned long)::$_1>,void ()(CFRange,long)>::operator()(uint64_t a1, uint64_t *a2, unint64_t *a3)
{
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  unint64_t v6 = *a3;
  unint64_t v7 = *(void **)(a1 + 8);
  uint64_t v8 = v7[2];
  uint64_t v9 = (uint64_t *)v7[3];
  unint64_t v10 = *a3 - v5;
  uint64_t v11 = *v9;
  if (*(int *)(v7[1] + 8) <= 0)
  {
    if (v11)
    {
      for (uint64_t i = 0; i != v11; ++i)
      {
        uint64_t v16 = *(void *)(v8 + 8 * i);
        if (v16 > v4)
        {
          *(void *)(v8 + 8 * i) = v16 + v10;
          uint64_t v11 = *v9;
        }
      }
    }
  }
  else if (v11)
  {
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    uint64_t v14 = v8 + 8 * v6;
    while (*(void *)(v8 + v12) != v4)
    {
      ++v13;
      v12 += 8;
      if (v11 == v13) {
        goto LABEL_23;
      }
    }
    unint64_t v17 = v6 - 1;
    unint64_t v18 = v11 + v6 - 1;
    if (v18 <= 0x40)
    {
      unint64_t v19 = (void *)(v8 + v12 + 8);
      if (8 * v11 - 8 != v12)
      {
        uint64_t v26 = v8 + 8 * v6;
        memmove((void *)(v8 + 8 * v18 - (8 * v11 - v12 - 8)), v19, 8 * v11 - v12 - 8);
        unint64_t v17 = v6 - 1;
        unint64_t v18 = v11 + v6 - 1;
        uint64_t v14 = v26;
      }
      if (v6 >= 2)
      {
        uint64_t v20 = v4 + 1;
        unint64_t v21 = v17;
        do
        {
          *v19++ = v20++;
          --v21;
        }
        while (v21);
      }
      *v9 += v17;
      if (v6 != v5 && v6 + v13 < v18)
      {
        unsigned int v22 = (void *)(v14 + v12);
        uint64_t v23 = ~v13 + v11;
        do
        {
          *v22++ += v10;
          --v23;
        }
        while (v23);
      }
    }
  }
LABEL_23:
  uint64_t v24 = **(void **)(a1 + 8);

  return std::function<void ()(CFRange,long)>::operator()(v24, v4, v5, v6);
}

uint64_t std::__function::__func<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_2,std::allocator<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_2>,void ()(unsigned short,unsigned short,unsigned short)>::operator()(uint64_t result, __int16 *a2, __int16 *a3, unsigned __int16 *a4)
{
  unsigned int v4 = *a4;
  unsigned int v5 = *(_DWORD *)(result + 16);
  if (v5 > v4)
  {
    __int16 v6 = *a2;
    __int16 v7 = *a3;
    uint64_t v8 = *(void *)(result + 8);
    uint64_t v10 = *(void *)(result + 24);
    uint64_t v9 = *(void *)(result + 32);
    unint64_t v11 = *(void *)(v8 + 104);
    unint64_t v12 = *(void *)(v8 + 112);
    uint64_t v13 = (unsigned __int16 *)(v10 + 2 * *a4);
    if ((unint64_t)v13 >= v11 && (unint64_t)(v13 + 1) <= v12)
    {
      unsigned int v15 = bswap32(*v13) >> 16;
      uint64_t v16 = (unsigned __int16 *)(v9 + 6 * v15);
      if ((unint64_t)v16 >= v11 && (unint64_t)(v16 + 3) <= v12)
      {
        int v18 = *v16;
        if ((*(_WORD *)(v9 + 6 * v15 + 2) & 0xE0) != 0 || v18 != 0) {
          return std::function<void ()(unsigned short,unsigned short)>::operator()(result + 40, v6, v7);
        }
      }
    }
    if (*(_WORD *)(result + 72))
    {
      uint64_t v20 = (unsigned __int16 *)(v10 + 2 * (v4 + v5 * *(unsigned __int16 *)(result + 72)));
      if ((unint64_t)v20 >= v11 && (unint64_t)(v20 + 1) <= v12)
      {
        unsigned int v22 = bswap32(*v20) >> 16;
        uint64_t v23 = (_WORD *)(v9 + 6 * v22);
        if ((unint64_t)v23 >= v11
          && (unint64_t)(v23 + 3) <= v12
          && ((*(_WORD *)(v9 + 6 * v22 + 2) & 0xE0) != 0 || *v23 != 0))
        {
          return std::function<void ()(unsigned short,unsigned short)>::operator()(result + 40, v6, v7);
        }
      }
    }
  }
  return result;
}

BOOL std::__function::__func<TAATMorphTable::ShapeGlyphs(SyncState &,__CFString const*)::$_0,std::allocator<TAATMorphTable::ShapeGlyphs(SyncState &,__CFString const*)::$_0>,BOOL ()(TRunGlue::TGlyph)>::operator()(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  return TRunGlue::TGlyph::IsIgnorable((TRunGlue::TGlyph *)&v3);
}

void std::__function::__func<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_2,std::allocator<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_2>,void ()(unsigned short,unsigned short,unsigned short)>::destroy_deallocate(void *a1)
{
  std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100](a1 + 5);

  operator delete(a1);
}

char *std::__function::__func<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_2,std::allocator<TAATMorphSubtableMorx::AddShapingGlyphs(std::function<void ()(unsigned short,unsigned short)>)::$_2>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x50uLL);
  *(void *)uint64_t v2 = &unk_1ED061160;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  std::__function::__value_func<void ()(unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)(v2 + 40), a1 + 40);
  *((_WORD *)v2 + 36) = *(_WORD *)(a1 + 72);
  return v2;
}

void TASCIIDataCache::InitC0Whitespace(TASCIIDataCache *this)
{
  uint64_t v1 = *MEMORY[0x1E4F143B8];
  operator new[]();
}

uint64_t TStorageRange::ResetAdvance(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a1 + 8) + a2;
  char v8 = *(unsigned char *)(a1 + 33);
  uint64_t v9 = *(void **)(a1 + 24);
  if ((v8 & 4) != 0)
  {
    [v9 customAdvanceForIndex:v7];
  }
  else
  {
    __int16 v14 = *(_WORD *)(v9[2] + 2 * v7);
    uint64_t v13 = NAN;
    TFont::GetUnsummedAdvancesForGlyphs(a3, (uint64_t)&v14, &v13, 1, 1, 0, a4);
    uint64_t v10 = *(void *)&v13;
  }
  uint64_t v11 = 0;
  return TStorageRange::SetAdvance((TStorageRange *)a1, a2, *(CGSize *)&v10);
}

CFRange CTLineGetStringRange(CTLineRef line)
{
  if (line)
  {
    uint64_t v1 = *((void *)line + 5);
    line = *(CTLineRef *)(v1 + 72);
    CFIndex v2 = *(void *)(v1 + 80);
  }
  else
  {
    CFIndex v2 = 0;
  }
  result.CFIndex length = v2;
  result.CFIndex location = (CFIndex)line;
  return result;
}

CFArrayRef CTLineGetGlyphRuns(CFArrayRef line)
{
  if (line) {
    return (CFArrayRef)TLine::GetRunCFArray(*((const void ****)line + 5));
  }
  return line;
}

double CTLineGetTypographicBounds(CTLineRef line, CGFloat *ascent, CGFloat *descent, CGFloat *leading)
{
  if (!line) {
    return 0.0;
  }
  unsigned int v4 = (double *)*((void *)line + 5);
  if (ascent) {
    *ascent = v4[14];
  }
  if (descent) {
    *descent = v4[15];
  }
  if (leading)
  {
    double v5 = v4[16];
    if (v5 == -1.79769313e308) {
      double v5 = 0.0;
    }
    *leading = v5;
  }
  return v4[13];
}

uint64_t TCFBase<TRun>::ClassDestruct(uint64_t a1)
{
  CFIndex v2 = *(void (**)(uint64_t))(a1 + 16);
  if (v2) {
    v2(a1);
  }
  long long v3 = ***(uint64_t (****)(void))(a1 + 40);

  return v3();
}

uint64_t _s18AdaptiveImageGlyphVwst(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)(result + 40) = 0;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(void *)CFRange result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(unsigned char *)(result + 48) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 24) = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 48) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

uint64_t CTLineGetStringIndexOfTabOverflow(uint64_t result, const TLine *a2, double a3)
{
  if (result) {
    return TTypesetter::GetTabOverflowIndex(*(TTypesetter **)(result + 40), a2, a3);
  }
  return result;
}

void CTFontDrawGlyphsWithAdvances(uint64_t a1, CGGlyph *a2, float64x2_t *a3, unint64_t a4, CGContext *a5)
{
}

CGFloat CTFontGetLeading(CTFontRef font)
{
  if (!font) {
    return 0.0;
  }
  uint64_t v1 = (int *)*((void *)font + 5);
  if (v1[12]) {
    inited = v1 + 12;
  }
  else {
    inited = TFont::InitStrikeMetrics((TFont *)v1);
  }
  return *((double *)inited + 3);
}

CFRange CTRunGetStringRange(CTRunRef run)
{
  if (run)
  {
    uint64_t v1 = *((void *)run + 5);
    run = *(CTRunRef *)(v1 + 8);
    CFIndex v2 = *(void *)(v1 + 16);
  }
  else
  {
    CFIndex v2 = 0;
  }
  result.CFIndex length = v2;
  result.CFIndex location = (CFIndex)run;
  return result;
}

uint64_t TCFBase<TDescriptor>::ClassDestruct(uint64_t a1)
{
  CFIndex v2 = *(void (**)(uint64_t))(a1 + 16);
  if (v2) {
    v2(a1);
  }
  long long v3 = ***(uint64_t (****)(void))(a1 + 40);

  return v3();
}

void TCFBase<TLine>::ClassDestruct(uint64_t a1)
{
  CFIndex v2 = *(void (**)(uint64_t))(a1 + 16);
  if (v2) {
    v2(a1);
  }
  long long v3 = *(TLine **)(a1 + 40);

  TLine::~TLine(v3);
}

uint64_t CTFontIsTextStyleFont(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(void *)(*(void *)(a1 + 40) + 400)) != 0) {
    return (*(uint64_t (**)(void))(*(void *)v1 + 856))();
  }
  else {
    return 0;
  }
}

uint64_t CTFontGetUIFontType(const void *a1)
{
  TextStyle = CTFontGetTextStyle(a1);
  if (!TextStyle) {
    return 0xFFFFFFFFLL;
  }
  LODWORD(result) = MapTextStyleValue((uint64_t)TextStyle);
  if (result >= 0x145) {
    return 2;
  }
  else {
    return result;
  }
}

uint64_t TComponentFont::GetTextStyle(TComponentFont *this)
{
  return *((void *)this + 94);
}

void *CTFontGetTextStyle(const void *a1)
{
  uint64_t result = _CTFontEnsureFontRef(a1);
  if (result)
  {
    CFIndex v2 = *(uint64_t (**)(void))(**(void **)(result[5] + 400) + 776);
    return (void *)v2();
  }
  return result;
}

void TAttributes::HandleFontAttribute(const void *a1, unsigned char *a2)
{
  long long v3 = (void *)_CTFontEnsureFontRef(a1);
  if (v3)
  {
    unsigned int v4 = v3;
    a2[8] = 1;
    double v5 = (atomic_ullong *)(*(void *)a2 + 16);
    TCFRef<__CTFont const*>::Retain(v5, v4);
  }
}

const void *_CTFontEnsureFontRef(const void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    CFTypeID v2 = CFGetTypeID(result);
    if (TCFBase<TFont>::GetTypeID(void)::once != -1) {
      dispatch_once_f(&TCFBase<TFont>::GetTypeID(void)::once, 0, (dispatch_function_t)TCFBase<TFont>::GetTypeID(void)::{lambda(void *)#1}::__invoke);
    }
    if (v2 == TCFBase<TFont>::fTypeID) {
      return v1;
    }
    else {
      return 0;
    }
  }
  return result;
}

unint64_t CTRunGetFont(unint64_t result)
{
  if (result) {
    return atomic_load_explicit((atomic_ullong *volatile)(*(void *)(result + 40) + 56), memory_order_acquire);
  }
  return result;
}

void *TCFBase<TDescriptor>::ClassHash(void *result)
{
  unint64_t v1 = result[3];
  uint64_t v2 = result[4];
  if (v2) {
    BOOL v3 = (result[4] & 1 | v1) == 0;
  }
  else {
    BOOL v3 = 1;
  }
  int v4 = !v3;
  if (v1) {
    BOOL v5 = 0;
  }
  else {
    BOOL v5 = v4 == 0;
  }
  if (!v5)
  {
    __int16 v6 = (void *)(result[5] + (v2 >> 1));
    if (v2) {
      return (void *)(*(uint64_t (**)(void))(*v6 + v1))();
    }
    else {
      return (void *)((uint64_t (*)(void *))v1)(v6);
    }
  }
  return result;
}

uint64_t CTFontIsVertical(uint64_t result)
{
  if (result) {
    return **(unsigned char **)(result + 40) & 1;
  }
  return result;
}

CFDictionaryRef CTRunGetAttributes(CFDictionaryRef run)
{
  if (run) {
    return (CFDictionaryRef)TAttributes::GetDictionary((atomic_ullong *)(*((void *)run + 5) + 40));
  }
  return run;
}

void CTFontSetClientObject(uint64_t a1, void *a2)
{
  if (a1) {
    TCFRef<__CTFont const*>::Retain((atomic_ullong *)(*(void *)(a1 + 40) + 528), a2);
  }
}

void TOpenTypeMorph::TOpenTypeMorph(TOpenTypeMorph *this, TRunGlue *a2, const TCharStream *a3)
{
  *(void *)this = a2;
  uint64_t v5 = *((void *)a2 + 77);
  *((void *)this + 1) = v5;
  *((_DWORD *)this + 4) = *((_DWORD *)a2 + 6);
  *((unsigned char *)this + 20) = *((unsigned char *)a2 + 634);
  *((unsigned char *)this + 21) = 1;
  *((_DWORD *)this + 6) = -1;
  *(void *)((char *)this + 28) = 0;
  *(void *)((char *)this + 44) = 0;
  *(void *)((char *)this + 36) = 0;
  *((_DWORD *)this + 13) = 0;
  *((void *)this + 67) = (char *)this + 56;
  uint64_t CommonTable = TBaseFont::GetCommonTable(*(TBaseFont **)(v5 + 400), 1196643650, 0);
  *((void *)this + 68) = CommonTable;
  *((void *)this + 69) = a3;
  *((_OWORD *)this + 37) = 0u;
  *((_OWORD *)this + 38) = 0u;
  *((_OWORD *)this + 39) = 0u;
  *((void *)this + 70) = 0;
  *((void *)this + 72) = 0;
  *((void *)this + 71) = 0;
  *((unsigned char *)this + 584) = 0;
  *((_DWORD *)this + 162) = 2;
  *((_OWORD *)this + 41) = 0u;
  *((_OWORD *)this + 42) = 0u;
  *((void *)this + 86) = 0;
  *((void *)this + 89) = 0;
  *((void *)this + 88) = 0;
  *((unsigned char *)this + 720) = 0;
  *((void *)this + 80) = &unk_1ED05FB20;
  if (!CommonTable) {
    return;
  }
  CFDataRef v7 = (const __CFData *)TBaseFont::GetCommonTable(*(TBaseFont **)(*((void *)this + 1) + 400), 1195656518, 0);
  OTL::GDEF::GDEF((OTL::GDEF *)v85, v7);
  long long v8 = *(_OWORD *)&v85[48];
  *((_OWORD *)this + 37) = *(_OWORD *)&v85[32];
  *((_OWORD *)this + 38) = v8;
  *((_OWORD *)this + 39) = *(_OWORD *)&v85[64];
  long long v9 = *(_OWORD *)&v85[16];
  *((_OWORD *)this + 35) = *(_OWORD *)v85;
  *((_OWORD *)this + 36) = v9;
  uint64_t v77 = (char *)this + 560;
  CFIndex v11 = *(void *)(*(void *)this + 8);
  uint64_t v10 = *(void *)(*(void *)this + 16);
  uint64_t v12 = *(void *)(*(void *)(*(void *)(**(void **)this + 16) + 8 * v11) + 48);
  *((unsigned char *)this + 21) = *(_DWORD *)(v12 + 256) == 0;
  unint64_t ScriptAndLangSys = TAttributes::GetScriptAndLangSys((atomic_ullong *)(v12 + 40));
  *((void *)this + 3) = ScriptAndLangSys;
  if (ScriptAndLangSys == -1)
  {
    LODWORD(ScriptAndLangSys) = *(_DWORD *)(v12 + 304);
    *((_DWORD *)this + 6) = ScriptAndLangSys;
    if (!a3)
    {
LABEL_58:
      if (v10 < 2) {
        return;
      }
      CFIndex v63 = 1;
      while (1)
      {
        uint64_t v64 = *(void *)(*(void *)(*(void *)(**(void **)this + 16) + 8 * v11 + 8 * v63) + 48);
        if (!TOpenTypeMorph::CompareRuns((atomic_ullong *)v12, (atomic_ullong *)v64, v14)) {
          break;
        }
        char v65 = *((unsigned char *)this + 21);
        if (v65) {
          char v65 = *(_DWORD *)(v64 + 256) == 0;
        }
        *((unsigned char *)this + 21) = v65;
        ++v63;
        if (v11 + v63 >= v10 + v11) {
          return;
        }
      }
      uint64_t v66 = *(TRunGlue **)this;
      v67.CFIndex location = v11;
      v67.CFIndex length = v63;
      goto LABEL_71;
    }
  }
  else if (!a3)
  {
    goto LABEL_58;
  }
  uint64_t v15 = *(void *)(*((void *)this + 1) + 400);
  if ((*(_DWORD *)(v15 + 184) & 0x400) == 0)
  {
    TBaseFont::DetermineFontFlags(*(TBaseFont **)(*((void *)this + 1) + 400), 0x400u);
    LODWORD(ScriptAndLangSys) = *((_DWORD *)this + 6);
  }
  unint64_t v76 = (_OWORD *)((char *)this + 648);
  if ((*(_DWORD *)(v15 + 180) & 0x400) != 0)
  {
    if (ScriptAndLangSys == -1)
    {
      unint64_t v19 = (unsigned char *)*((void *)this + 1);
      CFDataRef v20 = (const __CFData *)*((void *)this + 68);
      unsigned int v21 = *((_DWORD *)this + 7);
      unsigned int v22 = (char *)this + 560;
      int v23 = 0;
      goto LABEL_57;
    }
    int v16 = ScriptTagForScriptCode(ScriptAndLangSys);
    OTL::GCommon::GCommon((uint64_t)v85, 0, *((unsigned char **)this + 1), *((CFDataRef *)this + 68), (uint64_t)v77, v16, *((_DWORD *)this + 7));
    long long v17 = *(_OWORD *)&v85[24];
    long long v18 = *(_OWORD *)&v85[56];
    *(_OWORD *)((char *)this + 680) = *(_OWORD *)&v85[40];
    *(_OWORD *)((char *)this + 696) = v18;
    *(_OWORD *)((char *)this + 705) = *(_OWORD *)&v85[65];
    *unint64_t v76 = *(_OWORD *)&v85[8];
    *(_OWORD *)((char *)this + 664) = v17;
    if (!*((unsigned char *)this + 720))
    {
      if (v16 != *((_DWORD *)this + 178)) {
        *((_DWORD *)this + 6) = -1;
      }
      goto LABEL_58;
    }
    LODWORD(ScriptAndLangSys) = *((_DWORD *)this + 6);
  }
  if (ScriptAndLangSys == 128)
  {
    unint64_t v19 = (unsigned char *)*((void *)this + 1);
    CFDataRef v20 = (const __CFData *)*((void *)this + 68);
    unsigned int v21 = *((_DWORD *)this + 7);
    unsigned int v22 = (char *)this + 560;
    int v23 = 1835103336;
LABEL_57:
    OTL::GCommon::GCommon((uint64_t)v85, 0, v19, v20, (uint64_t)v22, v23, v21);
    long long v61 = *(_OWORD *)&v85[24];
    long long v62 = *(_OWORD *)&v85[56];
    *(_OWORD *)((char *)this + 680) = *(_OWORD *)&v85[40];
    *(_OWORD *)((char *)this + 696) = v62;
    *(_OWORD *)((char *)this + 705) = *(_OWORD *)&v85[65];
    *unint64_t v76 = *(_OWORD *)&v85[8];
    *(_OWORD *)((char *)this + 664) = v61;
    goto LABEL_58;
  }
  *(void *)__int16 v85 = a3;
  long long v86 = 0u;
  uint64_t v24 = *((void *)a3 + 2);
  uint64_t v71 = v10 + v11;
  uint64_t v69 = 8 * v11;
  int v25 = -1;
  uint64_t v75 = 1;
  uint64_t v87 = 0;
  *(void *)&long long v86 = v24;
  CFIndex v26 = v11;
  memset(&v85[8], 0, 160);
  CFIndex v73 = v11;
  while (1)
  {
    CFIndex v74 = v26 + 1;
    uint64_t v28 = *(void *)(v12 + 8);
    uint64_t v27 = *(void *)(v12 + 16);
    GlyphIndexForunsigned int Char = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v84 = v28;
    GlyphIndexForunsigned int Char = TRun::GetGlyphIndexForCharIndex<false>(v12, v28);
    if (v27 >= 1) {
      break;
    }
LABEL_45:
    int v49 = *((_DWORD *)this + 6);
    if (v49)
    {
      if (!*((_DWORD *)this + 178))
      {
        uint64_t v50 = (unsigned char *)*((void *)this + 1);
        CFDataRef v51 = (const __CFData *)*((void *)this + 68);
        int v52 = ScriptTagForScriptCode(*((_DWORD *)this + 6));
        OTL::GCommon::GCommon((uint64_t)&v78, 0, v50, v51, (uint64_t)v77, v52, *((_DWORD *)this + 7));
        long long v53 = v82[0];
        *(_OWORD *)((char *)this + 680) = v81;
        *(_OWORD *)((char *)this + 696) = v53;
        *(_OWORD *)((char *)this + 705) = *(_OWORD *)((char *)v82 + 9);
        long long v54 = v80;
        *unint64_t v76 = v79;
        *(_OWORD *)((char *)this + 664) = v54;
        int v49 = *((_DWORD *)this + 6);
      }
    }
    else
    {
      if (v25 == -1) {
        int v49 = 25;
      }
      else {
        int v49 = v25;
      }
      *((_DWORD *)this + 6) = v49;
      unsigned int v55 = (unsigned char *)*((void *)this + 1);
      CFDataRef v56 = (const __CFData *)*((void *)this + 68);
      int v57 = ScriptTagForScriptCode(v49);
      OTL::GCommon::GCommon((uint64_t)&v78, 0, v55, v56, (uint64_t)v77, v57, *((_DWORD *)this + 7));
      long long v58 = v82[0];
      *(_OWORD *)((char *)this + 680) = v81;
      *(_OWORD *)((char *)this + 696) = v58;
      *(_OWORD *)((char *)this + 705) = *(_OWORD *)((char *)v82 + 9);
      long long v59 = v80;
      *unint64_t v76 = v79;
      *(_OWORD *)((char *)this + 664) = v59;
    }
    *(_DWORD *)(v12 + 304) = v49;
    int v25 = v49;
LABEL_53:
    if (v74 == v71) {
      return;
    }
    unsigned int v60 = *(atomic_ullong **)(*(void *)(*(void *)(**(void **)this + 16) + 8 * v74) + 48);
    if (!TOpenTypeMorph::CompareRuns((atomic_ullong *)v12, v60, v29))
    {
      v67.CFIndex length = v74 - v11;
      uint64_t v66 = *(TRunGlue **)this;
      v67.CFIndex location = v11;
LABEL_71:
      TRunGlue::SetRunRange(v66, v67);
      return;
    }
    ++v75;
    CFIndex v26 = v74;
    uint64_t v12 = (uint64_t)v60;
  }
  uint64_t v72 = v26;
  char v30 = 0;
  Nextunsigned int Char = v28;
  uint64_t v32 = v27 + v28;
  uint64_t v70 = NextChar;
  while (1)
  {
    Fullunsigned int Char = TCharStreamIterator::GetFullChar((TCharStreamIterator *)v85, &v84, 0);
    int v34 = ScriptCodeForLongCharacter(FullChar);
    if (!v34)
    {
      if (!IsRightAssociative(FullChar)) {
        goto LABEL_36;
      }
      uint64_t v35 = v84 + 1;
      uint64_t v78 = v84 + 1;
      uint64_t v36 = *(void *)this;
      uint64_t v37 = *(void *)(*(void *)this + 40);
      if (v37 == -1)
      {
        TRunGlue::ComputeEndIndex(*(void **)this);
        uint64_t v37 = *(void *)(v36 + 40);
      }
      uint64_t v38 = *(void *)(v36 + 48) + v37;
      if (v35 >= v38) {
        goto LABEL_36;
      }
      while (1)
      {
        unsigned int v39 = TCharStreamIterator::GetFullChar((TCharStreamIterator *)v85, &v78, 0);
        int v40 = ScriptCodeForLongCharacter(v39);
        if (v40) {
          break;
        }
        if (++v78 >= v38) {
          goto LABEL_36;
        }
      }
      int v34 = v40;
    }
    if (v34 == v25)
    {
      if ((v30 & 1) == 0) {
        goto LABEL_34;
      }
      goto LABEL_35;
    }
    if (!v25) {
      break;
    }
    if (!uscript_hasScript())
    {
      if (v30) {
        goto LABEL_67;
      }
      if (v25 != -1) {
        goto LABEL_70;
      }
      *((_DWORD *)this + 6) = v34;
      double v41 = (unsigned char *)*((void *)this + 1);
      CFDataRef v42 = (const __CFData *)*((void *)this + 68);
      int v43 = ScriptTagForScriptCode(v34);
      OTL::GCommon::GCommon((uint64_t)&v78, 0, v41, v42, (uint64_t)v77, v43, *((_DWORD *)this + 7));
      long long v44 = v82[0];
      *(_OWORD *)((char *)this + 680) = v81;
      *(_OWORD *)((char *)this + 696) = v44;
      *(_OWORD *)((char *)this + 705) = *(_OWORD *)((char *)v82 + 9);
      long long v45 = v80;
      *unint64_t v76 = v79;
      *(_OWORD *)((char *)this + 664) = v45;
      if (v34 != 25)
      {
        if (v72 >= v73)
        {
          unint64_t v46 = (uint64_t *)(*(void *)(**(void **)this + 16) + v69);
          uint64_t v47 = v75;
          do
          {
            uint64_t v48 = *v46++;
            *(_DWORD *)(*(void *)(v48 + 48) + 304) = v34;
            char v30 = 1;
            --v47;
          }
          while (v47);
        }
        else
        {
          char v30 = 1;
        }
        int v25 = v34;
        goto LABEL_36;
      }
      int v25 = 25;
LABEL_34:
      *(_DWORD *)(v12 + 304) = v25;
LABEL_35:
      char v30 = 1;
    }
LABEL_36:
    Nextunsigned int Char = TRun::GetNextChar((TRun *)v12, v84, &GlyphIndexForChar);
    uint64_t v84 = NextChar;
    if (NextChar >= v32)
    {
      CFIndex v11 = v73;
      if (v30) {
        goto LABEL_53;
      }
      goto LABEL_45;
    }
  }
  if ((v30 & 1) == 0)
  {
LABEL_70:
    v67.CFIndex location = v73;
    v67.CFIndex length = v72 - v73;
    uint64_t v66 = *(TRunGlue **)this;
    goto LABEL_71;
  }
LABEL_67:
  unsigned __int16 v68 = *(TRunGlue **)this;
  if (*(void *)(*(void *)this + 152) && TLine::SplitRun(*(void *)v68, v72, NextChar - v70))
  {
    TRunGlue::UpdateForSplitRun(v68, 1);
    uint64_t v66 = *(TRunGlue **)this;
    v67.CFIndex location = v73;
    *(_DWORD *)(*(void *)(*(void *)(*(void *)(**(void **)this + 16) + 8 * v74) + 48) + 304) = -1;
    v67.CFIndex length = v72 - v73 + 1;
    goto LABEL_71;
  }
  *((void *)this + 68) = 0;
}

uint64_t TOpenTypeMorph::CompareRuns(atomic_ullong *this, atomic_ullong *a2, const TRun *a3)
{
  if (*((unsigned __int8 *)this + 224) != *((unsigned __int8 *)a2 + 224)) {
    return 0;
  }
  uint64_t v5 = *(void *)(atomic_load_explicit(this + 7, memory_order_acquire) + 40);
  uint64_t v6 = *(void *)(atomic_load_explicit(a2 + 7, memory_order_acquire) + 40);
  uint64_t result = TFont::Compare((TFont *)v5, (const TFont *)v6, 1);
  if (result == 1)
  {
    AATSettingOfType = TFontFeatureSettingList::GetAATSettingOfType((TFontFeatureSettingList *)(v5 + 168), 0x16u);
    CFIndex v11 = TFontFeatureSettingList::GetAATSettingOfType((TFontFeatureSettingList *)(v6 + 168), 0x16u);
    if (AATSettingOfType == v11) {
      return 1;
    }
    if (AATSettingOfType) {
      BOOL v12 = v11 == 0;
    }
    else {
      BOOL v12 = 1;
    }
    if (!v12) {
      return CFEqual(AATSettingOfType, v11) != 0;
    }
    return 0;
  }
  if (result == 2)
  {
    unint64_t explicit = (const void *)atomic_load_explicit(this + 8, memory_order_acquire);
    long long v9 = (const void *)atomic_load_explicit(a2 + 8, memory_order_acquire);
    if (explicit == v9) {
      return 1;
    }
    uint64_t result = 0;
    if (explicit)
    {
      if (v9)
      {
        uint64_t result = CFEqual(explicit, v9);
        if (result) {
          return 1;
        }
      }
    }
  }
  return result;
}

uint64_t *TOpenTypeMorph::TOpenTypeMorph(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, CFRange *a5)
{
  *a1 = a2;
  uint64_t v8 = *(void *)(a2 + 616);
  a1[1] = v8;
  *((_DWORD *)a1 + 4) = *(_DWORD *)(a2 + 24);
  *((unsigned char *)a1 + 20) = *(unsigned char *)(a2 + 634);
  *((unsigned char *)a1 + 21) = 1;
  a1[3] = a4;
  a1[5] = 0;
  a1[6] = 0;
  a1[4] = 0;
  a1[67] = (uint64_t)(a1 + 7);
  uint64_t CommonTable = TBaseFont::GetCommonTable(*(TBaseFont **)(v8 + 400), 1196643650, 0);
  a1[68] = CommonTable;
  a1[69] = a3;
  *((_OWORD *)a1 + 37) = 0u;
  *((_OWORD *)a1 + 38) = 0u;
  *((_OWORD *)a1 + 39) = 0u;
  a1[70] = 0;
  a1[72] = 0;
  a1[71] = 0;
  *((unsigned char *)a1 + 584) = 0;
  *((_DWORD *)a1 + 162) = 2;
  *((_OWORD *)a1 + 41) = 0u;
  *((_OWORD *)a1 + 42) = 0u;
  a1[86] = 0;
  a1[89] = 0;
  a1[88] = 0;
  *((unsigned char *)a1 + 720) = 0;
  a1[80] = (uint64_t)&unk_1ED05FB20;
  if (!CommonTable) {
    return a1;
  }
  CFDataRef v10 = (const __CFData *)TBaseFont::GetCommonTable(*(TBaseFont **)(a1[1] + 400), 1195656518, 0);
  OTL::GDEF::GDEF((OTL::GDEF *)v52, v10);
  long long v11 = *(_OWORD *)&v52[48];
  *((_OWORD *)a1 + 37) = *(_OWORD *)&v52[32];
  *((_OWORD *)a1 + 38) = v11;
  *((_OWORD *)a1 + 39) = *(_OWORD *)&v52[64];
  long long v12 = *(_OWORD *)&v52[16];
  *((_OWORD *)a1 + 35) = *(_OWORD *)v52;
  *((_OWORD *)a1 + 36) = v12;
  if (!a3) {
    goto LABEL_44;
  }
  uint64_t v13 = *(void *)(a1[1] + 400);
  if ((*(_DWORD *)(v13 + 184) & 0x400) == 0) {
    TBaseFont::DetermineFontFlags(*(TBaseFont **)(a1[1] + 400), 0x400u);
  }
  if ((*(_DWORD *)(v13 + 180) & 0x400) != 0 || *((_DWORD *)a1 + 6) == 128) {
    goto LABEL_44;
  }
  long long v53 = 0u;
  memset(&v52[8], 0, 160);
  uint64_t v14 = *(void *)(a3 + 16);
  uint64_t v54 = 0;
  *(void *)&long long v53 = v14;
  uint64_t location = a5->location;
  uint64_t length = a5->length;
  uint64_t v51 = a5->location;
  *(void *)int v52 = a3;
  if (length < 1)
  {
    int v18 = -1;
    goto LABEL_24;
  }
  char v49 = 0;
  uint64_t v17 = length + location;
  int v18 = -1;
  while (1)
  {
    Fullunsigned int Char = TCharStreamIterator::GetFullChar((TCharStreamIterator *)v52, &v51, 0);
    int v20 = ScriptCodeForLongCharacter(FullChar);
    if (!v20)
    {
      if (!IsRightAssociative(FullChar)) {
        goto LABEL_20;
      }
      uint64_t v21 = v51 + 1;
      uint64_t v50 = v51 + 1;
      uint64_t v22 = *a1;
      uint64_t v23 = *(void *)(*a1 + 40);
      if (v23 == -1)
      {
        TRunGlue::ComputeEndIndex((void *)*a1);
        uint64_t v23 = *(void *)(v22 + 40);
      }
      uint64_t v24 = *(void *)(v22 + 48) + v23;
      if (v21 >= v24) {
        goto LABEL_20;
      }
      while (1)
      {
        unsigned int v25 = TCharStreamIterator::GetFullChar((TCharStreamIterator *)v52, &v50, 0);
        int v26 = ScriptCodeForLongCharacter(v25);
        if (v26) {
          break;
        }
        if (++v50 >= v24) {
          goto LABEL_20;
        }
      }
      int v20 = v26;
    }
    if (v20 != v18 && !uscript_hasScript()) {
      break;
    }
LABEL_20:
    uint64_t location = v51 + 1;
    uint64_t v51 = location;
    if (location >= v17)
    {
      uint64_t location = a5->location;
      goto LABEL_24;
    }
  }
  if ((v49 & 1) == 0)
  {
    *((_DWORD *)a1 + 6) = v20;
    char v49 = 1;
    int v18 = v20;
    goto LABEL_20;
  }
  uint64_t v48 = a5->location;
  a5->uint64_t length = location - a5->location;
  uint64_t location = v48;
LABEL_24:
  uint64_t v27 = (void *)*a1;
  unint64_t v29 = *(void *)(*a1 + 64);
  unint64_t v28 = *(void *)(*a1 + 72);
  if (v29 >= v28)
  {
    uint64_t v31 = v27[7];
    uint64_t v32 = (uint64_t)(v29 - v31) >> 4;
    unint64_t v33 = v32 + 1;
    if ((unint64_t)(v32 + 1) >> 60) {
      abort();
    }
    uint64_t v34 = v28 - v31;
    if (v34 >> 3 > v33) {
      unint64_t v33 = v34 >> 3;
    }
    if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v35 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v35 = v33;
    }
    uint64_t v36 = (char *)TInlineBufferAllocator<std::pair<UScriptCode,long>,1ul>::allocate((uint64_t)(v27 + 10), v35);
    uint64_t v37 = &v36[16 * v32];
    *(_DWORD *)uint64_t v37 = v18;
    *((void *)v37 + 1) = location;
    unsigned int v39 = (char *)v27[7];
    uint64_t v38 = (char *)v27[8];
    int v40 = v37;
    if (v38 != v39)
    {
      do
      {
        *((_OWORD *)v40 - 1) = *((_OWORD *)v38 - 1);
        v40 -= 16;
        v38 -= 16;
      }
      while (v38 != v39);
      uint64_t v38 = (char *)v27[7];
    }
    char v30 = v37 + 16;
    v27[7] = v40;
    v27[8] = v37 + 16;
    uint64_t v41 = v27[9];
    v27[9] = &v36[16 * v35];
    if (v38)
    {
      CFDataRef v42 = (char *)(v27 + 12);
      if (v27 + 10 <= (void *)v38 && v42 > v38)
      {
        if (v41 == *(void *)v42) {
          *(void *)CFDataRef v42 = v38;
        }
      }
      else
      {
        operator delete(v38);
      }
    }
  }
  else
  {
    *(_DWORD *)unint64_t v29 = v18;
    *(void *)(v29 + 8) = location;
    char v30 = (char *)(v29 + 16);
  }
  v27[8] = v30;
LABEL_44:
  int v44 = ScriptTagForScriptCode(*((_DWORD *)a1 + 6));
  OTL::GCommon::GCommon((uint64_t)v52, 0, (unsigned char *)a1[1], (CFDataRef)a1[68], (uint64_t)(a1 + 70), v44, *((_DWORD *)a1 + 7));
  long long v45 = *(_OWORD *)&v52[24];
  long long v46 = *(_OWORD *)&v52[56];
  *(_OWORD *)(a1 + 85) = *(_OWORD *)&v52[40];
  *(_OWORD *)(a1 + 87) = v46;
  *(_OWORD *)((char *)a1 + 705) = *(_OWORD *)&v52[65];
  *(_OWORD *)(a1 + 81) = *(_OWORD *)&v52[8];
  *(_OWORD *)(a1 + 83) = v45;
  if (!*((unsigned char *)a1 + 720) && v44 != *((_DWORD *)a1 + 178)) {
    *((_DWORD *)a1 + 6) = -1;
  }
  TRunGlue::SetCharRange(*a1, *a5);
  return a1;
}

uint64_t *TOpenTypePositioningEngine::TOpenTypePositioningEngine(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, CFRange *a5)
{
  int v6 = a4;
  v48[3] = *MEMORY[0x1E4F143B8];
  *a1 = a2;
  uint64_t v9 = *(void *)(a2 + 616);
  a1[1] = v9;
  *((_DWORD *)a1 + 4) = *(_DWORD *)(a2 + 24);
  *((unsigned char *)a1 + 20) = *(unsigned char *)(a2 + 634);
  a1[3] = 0xFFFFFFFFLL;
  *((_DWORD *)a1 + 8) = HIDWORD(a4);
  CFDataRef v10 = (OTL::GDEF *)(a1 + 5);
  CFDataRef CommonTable = (const __CFData *)TBaseFont::GetCommonTable(*(TBaseFont **)(v9 + 400), 1195656518, 0);
  OTL::GDEF::GDEF(v10, CommonTable);
  *((unsigned char *)a1 + 120) = 0;
  *((unsigned char *)a1 + 208) = 0;
  a1[30] = 0;
  a1[29] = 0;
  a1[27] = a3;
  a1[28] = (uint64_t)(a1 + 29);
  TOpenTypePositioningEngine::SetScript((uint64_t)a1, v6);
  uint64_t v12 = *(void *)(*a1 + 56);
  uint64_t v13 = *(void *)(*a1 + 64);
  uint64_t v47 = 0;
  v48[0] = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v45 = 0;
  uint64_t v46 = 0;
  v48[1] = 0xAAAAAAAAAAAAAAAALL;
  v48[2] = v48;
  if (v13 != v12)
  {
    std::vector<std::pair<UScriptCode,long>,TInlineBufferAllocator<std::pair<UScriptCode,long>,1ul>>::__vallocate[abi:nn180100](&v45, (v13 - v12) >> 4);
    uint64_t v14 = 0;
    uint64_t v15 = v46;
    do
    {
      *(_OWORD *)(v15 + v14) = *(_OWORD *)(v12 + v14);
      v14 += 16;
    }
    while (v12 + v14 != v13);
    uint64_t v16 = v15 + v14;
    uint64_t v46 = v16;
    uint64_t v17 = v45;
    if (v45 != v16)
    {
      uint64_t v18 = v16;
      while (v18 != v45)
      {
        uint64_t v19 = v18 - 16;
        CFIndex v20 = *(void *)(v18 - 8);
        v18 -= 16;
        if (v20 <= a5->location)
        {
          uint64_t v17 = v19 + 16;
          break;
        }
      }
      if (v17 - 16 != v16)
      {
        int v21 = *(_DWORD *)(v17 - 16);
        int v22 = *((_DWORD *)a1 + 6);
        if (v22 == -1)
        {
          TOpenTypePositioningEngine::SetScript((uint64_t)a1, v21);
          if (v17 != v46) {
            a5->uint64_t length = *(void *)(v17 + 8) - a5->location;
          }
        }
        else if (v22 != v21)
        {
          TOpenTypePositioningEngine::SetScript((uint64_t)a1, -1);
        }
      }
    }
  }
  if (a3 && *((_DWORD *)a1 + 6) == -1)
  {
    uint64_t v23 = *(void *)(a1[1] + 400);
    if ((*(_DWORD *)(v23 + 184) & 0x400) == 0) {
      TBaseFont::DetermineFontFlags(*(TBaseFont **)(a1[1] + 400), 0x400u);
    }
    if ((*(_DWORD *)(v23 + 180) & 0x400) == 0)
    {
      long long v43 = 0u;
      long long v33 = 0u;
      long long v34 = 0u;
      long long v35 = 0u;
      long long v36 = 0u;
      long long v37 = 0u;
      long long v38 = 0u;
      long long v39 = 0u;
      long long v40 = 0u;
      long long v41 = 0u;
      long long v42 = 0u;
      uint64_t v24 = *(void *)(a3 + 16);
      uint64_t v44 = 0;
      *(void *)&long long v43 = v24;
      CFIndex location = a5->location;
      uint64_t length = a5->length;
      CFIndex v31 = a5->location;
      uint64_t v32 = (void **)a3;
      if (length >= 1)
      {
        uint64_t v27 = length + location;
        while (1)
        {
          Fullunsigned int Char = TCharStreamIterator::GetFullChar((TCharStreamIterator *)&v32, &v31, 0);
          int v29 = ScriptCodeForLongCharacter(FullChar);
          if (v29) {
            break;
          }
          if (++v31 >= v27) {
            goto LABEL_26;
          }
        }
        TOpenTypePositioningEngine::SetScript((uint64_t)a1, v29);
      }
    }
  }
LABEL_26:
  TRunGlue::SetCharRange(*a1, *a5);
  uint64_t v32 = (void **)&v45;
  std::vector<std::pair<UScriptCode,long>,TInlineBufferAllocator<std::pair<UScriptCode,long>,1ul>>::__destroy_vector::operator()[abi:nn180100](&v32);
  return a1;
}

void std::vector<std::pair<UScriptCode,long>,TInlineBufferAllocator<std::pair<UScriptCode,long>,1ul>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  unint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    v1[1] = v2;
    BOOL v3 = v1 + 5;
    if (v1 + 3 <= v2)
    {
      BOOL v4 = v3 >= v2;
      BOOL v5 = v3 == v2;
    }
    else
    {
      BOOL v4 = 0;
      BOOL v5 = 0;
    }
    if (!v5 && v4)
    {
      if (v1[2] == v1[5]) {
        *BOOL v3 = v2;
      }
    }
    else
    {
      operator delete(v2);
    }
  }
}

uint64_t TRunGlue::SetCharRange(uint64_t this, CFRange a2)
{
  if (*(void *)(this + 40) != a2.location || *(void *)(this + 48) != a2.length)
  {
    uint64_t v3 = *(void *)(this + 160);
    uint64_t v4 = *(int *)(this + 24);
    uint64_t v5 = v3;
    if ((v4 & 0x80000000) != 0) {
      uint64_t v5 = *(void *)(this + 168) - 1;
    }
    uint64_t v6 = *(void *)(this + 32);
    if ((v5 & 0x8000000000000000) == 0 && v6 > v5)
    {
      while (*(void *)(*(void *)(this + 528) + 8 * v5) < a2.location)
      {
        v5 += v4;
        if (v5 < 0 || v6 <= v5) {
          goto LABEL_14;
        }
      }
      *(void *)(this + 160) = v5;
      uint64_t v3 = v5;
      v5 += v4;
    }
LABEL_14:
    if ((v5 & 0x8000000000000000) == 0 && v6 > v5)
    {
      do
      {
        if (*(void *)(*(void *)(this + 528) + 8 * v5) >= a2.location + a2.length) {
          break;
        }
        v5 += v4;
        if (v5 < 0) {
          break;
        }
      }
      while (v6 > v5);
    }
    *(void *)(this + 168) = v5;
    if ((v4 & 0x80000000) != 0)
    {
      *(void *)(this + 160) = v5 + 1;
      *(void *)(this + 168) = v3 + 1;
    }
    *(CFRange *)(this + 40) = a2;
  }
  return this;
}

void TOpenTypePositioningEngine::TOpenTypePositioningEngine(TOpenTypePositioningEngine *this, TRunGlue *a2, const TCharStream *a3)
{
  *(void *)this = a2;
  uint64_t v5 = *((void *)a2 + 77);
  *((void *)this + 1) = v5;
  *((_DWORD *)this + 4) = *((_DWORD *)a2 + 6);
  *((unsigned char *)this + 20) = *((unsigned char *)a2 + 634);
  *((void *)this + 3) = 0xFFFFFFFFLL;
  *((_DWORD *)this + 8) = 0;
  uint64_t v6 = (TOpenTypePositioningEngine *)((char *)this + 40);
  CFDataRef CommonTable = (const __CFData *)TBaseFont::GetCommonTable(*(TBaseFont **)(v5 + 400), 1195656518, 0);
  OTL::GDEF::GDEF(v6, CommonTable);
  *((unsigned char *)this + 120) = 0;
  *((unsigned char *)this + 208) = 0;
  *((void *)this + 29) = 0;
  *((void *)this + 30) = 0;
  *((void *)this + 27) = a3;
  *((void *)this + 28) = (char *)this + 232;
  uint64_t v8 = *(void *)(*(void *)this + 8);
  uint64_t v9 = *(void *)(*(void *)this + 16);
  uint64_t v10 = *(void *)(*(void *)(*(void *)(**(void **)this + 16) + 8 * v8) + 48);
  unint64_t ScriptAndLangSys = TAttributes::GetScriptAndLangSys((atomic_ullong *)(v10 + 40));
  int v12 = ScriptAndLangSys;
  *((_DWORD *)this + 6) = ScriptAndLangSys;
  *((_DWORD *)this + 8) = HIDWORD(ScriptAndLangSys);
  if (ScriptAndLangSys == -1) {
    int v12 = *(_DWORD *)(v10 + 304);
  }
  TOpenTypePositioningEngine::SetScript((uint64_t)this, v12);
  if (*((void *)this + 27))
  {
    int v13 = *((_DWORD *)this + 6);
    if (v13 == -1 || v13 != *(_DWORD *)(v10 + 304))
    {
      uint64_t v14 = *(void *)(*((void *)this + 1) + 400);
      if ((*(_DWORD *)(v14 + 184) & 0x400) == 0) {
        TBaseFont::DetermineFontFlags(*(TBaseFont **)(*((void *)this + 1) + 400), 0x400u);
      }
      if ((*(_DWORD *)(v14 + 180) & 0x400) == 0)
      {
        uint64_t v24 = a3;
        long long v35 = 0u;
        long long v25 = 0u;
        long long v26 = 0u;
        long long v27 = 0u;
        long long v28 = 0u;
        long long v29 = 0u;
        long long v30 = 0u;
        long long v31 = 0u;
        long long v32 = 0u;
        long long v33 = 0u;
        long long v34 = 0u;
        uint64_t v15 = *((void *)a3 + 2);
        uint64_t v16 = v9 + v8;
        uint64_t v36 = 0;
        *(void *)&long long v35 = v15;
        while (1)
        {
          uint64_t v17 = *(void *)(v10 + 8);
          uint64_t v18 = *(void *)(v10 + 16);
          Nextunsigned int Char = v17;
          if (v18 >= 1) {
            break;
          }
LABEL_14:
          if (++v8 == v16) {
            return;
          }
          uint64_t v10 = *(void *)(*(void *)(*(void *)(**(void **)this + 16) + 8 * v8) + 48);
        }
        uint64_t v19 = v18 + v17;
        while (1)
        {
          Fullunsigned int Char = TCharStreamIterator::GetFullChar((TCharStreamIterator *)&v24, &NextChar, 0);
          int v21 = ScriptCodeForLongCharacter(FullChar);
          if (v21) {
            break;
          }
          uint64_t v22 = NextChar;
          GlyphIndexForunsigned int Char = TRun::GetGlyphIndexForCharIndex<false>(v10, NextChar);
          Nextunsigned int Char = TRun::GetNextChar((TRun *)v10, v22, &GlyphIndexForChar);
          if (NextChar >= v19) {
            goto LABEL_14;
          }
        }
        TOpenTypePositioningEngine::SetScript((uint64_t)this, v21);
      }
    }
  }
}

uint64_t OTL::GDEF::GDEF(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  *(void *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + 24) = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  uint64_t v4 = (void *)(a1 + 32);
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  if (a2)
  {
    if (a2 + 12 > a3 || *(_WORD *)a2 != 256) {
      goto LABEL_23;
    }
    if (*(_WORD *)(a2 + 4))
    {
      uint64_t v5 = (char *)(a2 + __rev16(*(unsigned __int16 *)(a2 + 4)));
      *(void *)(a1 + 16) = v5;
      if ((unint64_t)(v5 + 2) > a3
        || ((unsigned int v6 = bswap32(*(unsigned __int16 *)v5) >> 16, v6 == 2)
          ? (uint64_t v7 = 6 * (bswap32(*((unsigned __int16 *)v5 + 1)) >> 16) + 4)
          : v6 != 1
          ? (uint64_t v7 = 0)
          : (uint64_t v7 = 2 * (bswap32(*((unsigned __int16 *)v5 + 2)) >> 16) + 6),
            (uint64_t v8 = &v5[v7], v8 >= v5) ? (v9 = (unint64_t)v8 > a3) : (v9 = 1),
            v9))
      {
        *(void *)(a1 + 16) = 0;
      }
    }
    unsigned int v10 = bswap32(*(unsigned __int16 *)(a2 + 2)) >> 16;
    if (v10 >= 2)
    {
      if (a2 + 14 <= a3)
      {
        if (v10 < 3)
        {
LABEL_21:
          *(unsigned char *)(a1 + 24) = 1;
          return a1;
        }
        if (a2 + 18 <= a3)
        {
          unsigned int v11 = *(_DWORD *)(a2 + 14);
          if (v11) {
            ItemVariationStore::Initialize(v4, a2 + bswap32(v11), a3);
          }
          goto LABEL_21;
        }
      }
LABEL_23:
      *(void *)a1 = 0;
    }
  }
  return a1;
}

uint64_t OTL::GDEF::GDEF(OTL::GDEF *this, CFDataRef theData)
{
  if (theData)
  {
    BytePtr = CFDataGetBytePtr(theData);
    uint64_t v5 = CFDataGetBytePtr(theData);
    if (v5)
    {
      unint64_t v6 = (unint64_t)&v5[CFDataGetLength(theData)];
      goto LABEL_6;
    }
  }
  else
  {
    BytePtr = 0;
  }
  unint64_t v6 = 0;
LABEL_6:

  return OTL::GDEF::GDEF((uint64_t)this, (uint64_t)BytePtr, v6);
}

uint64_t ItemVariationStore::Initialize(void *a1, uint64_t a2, unint64_t a3)
{
  if (!a2) {
    return 1;
  }
  unint64_t v3 = a2 + 8;
  if (a2 + 8 > a3) {
    return 0;
  }
  uint64_t v4 = bswap32(*(unsigned __int16 *)(a2 + 6)) >> 16;
  unint64_t v5 = v3 + 4 * v4;
  if (v5 < v3 || v5 > a3)
  {
    unint64_t v7 = a2 + 12 <= a3 ? (a3 - v3) >> 2 : 0;
    if (v7 != v4) {
      return 0;
    }
  }
  uint64_t v8 = *(unsigned int *)(a2 + 2);
  if (v8)
  {
    BOOL v9 = (unsigned __int16 *)(a2 + bswap32(v8));
    if ((unint64_t)(v9 + 2) <= a3)
    {
      uint64_t v10 = bswap32(v9[1]) >> 16;
      unint64_t v11 = (unint64_t)&v9[3 * (bswap32(*v9) >> 16) * v10 + 2];
      if (v11 >= (unint64_t)v9 && v11 <= a3)
      {
        *a1 = a2;
        a1[1] = a3;
        a1[2] = v10;
        a1[3] = v9;
        uint64_t v8 = 1;
        a1[4] = v4;
        a1[5] = v3;
        return v8;
      }
    }
    return 0;
  }
  return v8;
}

const __CFData *TOpenTypePositioningEngine::SetScript(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 24) = a2;
  *(_DWORD *)(a1 + 28) = ScriptTagForScriptCode(a2);
  CFDataRef result = (const __CFData *)TBaseFont::GetCommonTable(*(TBaseFont **)(*(void *)(a1 + 8) + 400), 1196445523, 0);
  if (result)
  {
    uint64_t v4 = *(unsigned char **)(a1 + 8);
    int v5 = *(_DWORD *)(a1 + 28);
    unsigned int v6 = *(_DWORD *)(a1 + 32);
    if (*(unsigned char *)(a1 + 208)) {
      *(unsigned char *)(a1 + 208) = 0;
    }
    CFDataRef result = (const __CFData *)OTL::GCommon::GCommon(a1 + 120, 1, v4, result, a1 + 40, v5, v6);
    *(void *)(a1 + 120) = &unk_1ED05FAF8;
    *(unsigned char *)(a1 + 208) = 1;
  }
  return result;
}

uint64_t TBaseFont::GetCommonTable(TBaseFont *this, uint64_t a2, unsigned int *a3)
{
  int v3 = a2;
  while (1)
  {
    int v5 = *((_DWORD *)this + 44);
    if (v3 > 1634561905) {
      break;
    }
    if (v3 <= 1634428273)
    {
      switch(v3)
      {
        case 1195656518:
          unsigned int v6 = (atomic_ullong *)((char *)this + 16);
          if (atomic_load_explicit((atomic_ullong *volatile)this + 2, memory_order_acquire)) {
            BOOL v10 = 0;
          }
          else {
            BOOL v10 = (v5 & 0x100) == 0;
          }
          if (!v10)
          {
            if ((v5 & 0x100) == 0) {
              return atomic_load_explicit(v6, memory_order_acquire);
            }
            return 0;
          }
          id v31 = (id)0xAAAAAAAAAAAAAAAALL;
          (*(void (**)(id *__return_ptr, TBaseFont *, uint64_t, unsigned int *))(*(void *)this + 496))(&v31, this, a2, a3);
          id v30 = CGFontCopyTableForTag((CGFontRef)atomic_load_explicit((atomic_ullong *volatile)&v31, memory_order_acquire), 0x47444546u);
          unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&v30, memory_order_acquire);
          if (explicit) {
            goto LABEL_42;
          }
          uint64_t v8 = (atomic_uint *)((char *)this + 176);
          unsigned int v9 = 256;
          break;
        case 1196445523:
          unsigned int v6 = (atomic_ullong *)((char *)this + 24);
          if (atomic_load_explicit((atomic_ullong *volatile)this + 3, memory_order_acquire) || (v5 & 0x80) != 0)
          {
            if ((v5 & 0x80) == 0) {
              return atomic_load_explicit(v6, memory_order_acquire);
            }
            return 0;
          }
          id v31 = (id)0xAAAAAAAAAAAAAAAALL;
          (*(void (**)(id *__return_ptr, TBaseFont *, uint64_t, unsigned int *))(*(void *)this + 496))(&v31, this, a2, a3);
          id v30 = CGFontCopyTableForTag((CGFontRef)atomic_load_explicit((atomic_ullong *volatile)&v31, memory_order_acquire), 0x47504F53u);
          unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&v30, memory_order_acquire);
          if (explicit) {
            goto LABEL_42;
          }
          uint64_t v8 = (atomic_uint *)((char *)this + 176);
          unsigned int v9 = 128;
          break;
        case 1196643650:
          unsigned int v6 = (atomic_ullong *)((char *)this + 32);
          if (atomic_load_explicit((atomic_ullong *volatile)this + 4, memory_order_acquire) || (v5 & 0x40) != 0)
          {
            if ((v5 & 0x40) == 0) {
              return atomic_load_explicit(v6, memory_order_acquire);
            }
            return 0;
          }
          id v31 = (id)0xAAAAAAAAAAAAAAAALL;
          (*(void (**)(id *__return_ptr, TBaseFont *, uint64_t, unsigned int *))(*(void *)this + 496))(&v31, this, a2, a3);
          id v30 = CGFontCopyTableForTag((CGFontRef)atomic_load_explicit((atomic_ullong *volatile)&v31, memory_order_acquire), 0x47535542u);
          unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&v30, memory_order_acquire);
          if (!explicit)
          {
            uint64_t v8 = (atomic_uint *)((char *)this + 176);
            unsigned int v9 = 64;
            break;
          }
LABEL_42:
          uint64_t v11 = 0;
          unint64_t v12 = atomic_exchange((atomic_ullong *volatile)&v30, 0);
          atomic_compare_exchange_strong(v6, (unint64_t *)&v11, v12);
          if (v11) {
            int v13 = (void *)v12;
          }
          else {
            int v13 = 0;
          }

LABEL_54:
          if (explicit) {
            return atomic_load_explicit(v6, memory_order_acquire);
          }
          return 0;
        default:
          return 0;
      }
LABEL_53:
      atomic_fetch_or_explicit(v8, v9, memory_order_relaxed);
      goto LABEL_54;
    }
    if (v3 == 1634428274)
    {
      if ((v5 & 0x2000000) == 0) {
        goto LABEL_13;
      }
      int v14 = 134234112;
      if (a3) {
        *a3 = 1801810552;
      }
LABEL_87:
      unsigned int v6 = (atomic_ullong *)((char *)this + 48);
      if (!atomic_load_explicit((atomic_ullong *volatile)this + 6, memory_order_acquire) && (v5 & 0x4000) == 0)
      {
        id v31 = (id)0xAAAAAAAAAAAAAAAALL;
        (*(void (**)(id *__return_ptr, TBaseFont *, uint64_t, unsigned int *))(*(void *)this + 496))(&v31, this, a2, a3);
        id v30 = CGFontCopyTableForTag((CGFontRef)atomic_load_explicit((atomic_ullong *volatile)&v31, memory_order_acquire), 0x6B657278u);
        unint64_t v26 = atomic_load_explicit((atomic_ullong *volatile)&v30, memory_order_acquire);
        if (v26)
        {
          uint64_t v27 = 0;
          unint64_t v28 = atomic_exchange((atomic_ullong *volatile)&v30, 0);
          atomic_compare_exchange_strong(v6, (unint64_t *)&v27, v28);
          if (v27) {
            long long v29 = (void *)v28;
          }
          else {
            long long v29 = 0;
          }
        }
        else
        {
          atomic_fetch_or_explicit((atomic_uint *volatile)this + 44, 0x4000u, memory_order_relaxed);
        }

        uint64_t result = 0;
        if (!v26 || (v14 & v5) == 0x4000) {
          return result;
        }
        return atomic_load_explicit(v6, memory_order_acquire);
      }
      if ((v14 & v5) != 0x4000) {
        return atomic_load_explicit(v6, memory_order_acquire);
      }
      return 0;
    }
    if (v3 != 1634497633) {
      return 0;
    }
    if ((v5 & 0x2000000) != 0)
    {
      if (a3) {
        *a3 = 1819566439;
      }
      int v16 = 272629760;
LABEL_78:
      unsigned int v6 = (atomic_ullong *)((char *)this + 56);
      if (!atomic_load_explicit((atomic_ullong *volatile)this + 7, memory_order_acquire) && (v5 & 0x400000) == 0)
      {
        id v31 = (id)0xAAAAAAAAAAAAAAAALL;
        (*(void (**)(id *__return_ptr, TBaseFont *, uint64_t, unsigned int *))(*(void *)this + 496))(&v31, this, a2, a3);
        id v30 = CGFontCopyTableForTag((CGFontRef)atomic_load_explicit((atomic_ullong *volatile)&v31, memory_order_acquire), 0x6C746167u);
        unint64_t v22 = atomic_load_explicit((atomic_ullong *volatile)&v30, memory_order_acquire);
        if (v22)
        {
          uint64_t v23 = 0;
          unint64_t v24 = atomic_exchange((atomic_ullong *volatile)&v30, 0);
          atomic_compare_exchange_strong(v6, (unint64_t *)&v23, v24);
          if (v23) {
            long long v25 = (void *)v24;
          }
          else {
            long long v25 = 0;
          }
        }
        else
        {
          atomic_fetch_or_explicit((atomic_uint *volatile)this + 44, 0x400000u, memory_order_relaxed);
        }

        uint64_t result = 0;
        if (!v22 || (v16 & v5) == 0x400000) {
          return result;
        }
        return atomic_load_explicit(v6, memory_order_acquire);
      }
      if ((v16 & v5) != 0x400000) {
        return atomic_load_explicit(v6, memory_order_acquire);
      }
      return 0;
    }
LABEL_13:
    TBaseFont::InitAnnexTables(this);
    a3 = 0;
  }
  if (v3 > 1801810541)
  {
    if (v3 <= 1819566438)
    {
      if (v3 != 1801810542)
      {
        if (v3 != 1801810552 || (~v5 & 0xA000000) == 0) {
          return 0;
        }
        int v14 = 0x4000;
        goto LABEL_87;
      }
      unsigned int v6 = (atomic_ullong *)((char *)this + 40);
      if (atomic_load_explicit((atomic_ullong *volatile)this + 5, memory_order_acquire) || (v5 & 1) != 0)
      {
        if ((v5 & 1) == 0) {
          return atomic_load_explicit(v6, memory_order_acquire);
        }
        return 0;
      }
      id v31 = (id)0xAAAAAAAAAAAAAAAALL;
      (*(void (**)(id *__return_ptr, TBaseFont *, uint64_t, unsigned int *))(*(void *)this + 496))(&v31, this, a2, a3);
      id v30 = CGFontCopyTableForTag((CGFontRef)atomic_load_explicit((atomic_ullong *volatile)&v31, memory_order_acquire), 0x6B65726Eu);
      unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&v30, memory_order_acquire);
      if (explicit) {
        goto LABEL_42;
      }
      uint64_t v8 = (atomic_uint *)((char *)this + 176);
      unsigned int v9 = 1;
    }
    else
    {
      if (v3 == 1819566439)
      {
        if ((~v5 & 0x12000000) == 0) {
          return 0;
        }
        int v16 = 0x400000;
        goto LABEL_78;
      }
      if (v3 == 1836020344)
      {
        if ((~v5 & 0x22000000) != 0)
        {
          int v17 = 4;
          goto LABEL_66;
        }
        return 0;
      }
      if (v3 != 1953653099) {
        return 0;
      }
      unsigned int v6 = (atomic_ullong *)((char *)this + 72);
      if (atomic_load_explicit((atomic_ullong *volatile)this + 9, memory_order_acquire) || (v5 & 8) != 0)
      {
        if ((v5 & 8) == 0) {
          return atomic_load_explicit(v6, memory_order_acquire);
        }
        return 0;
      }
      id v31 = (id)0xAAAAAAAAAAAAAAAALL;
      (*(void (**)(id *__return_ptr, TBaseFont *, uint64_t, unsigned int *))(*(void *)this + 496))(&v31, this, a2, a3);
      id v30 = CGFontCopyTableForTag((CGFontRef)atomic_load_explicit((atomic_ullong *volatile)&v31, memory_order_acquire), 0x7472616Bu);
      unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&v30, memory_order_acquire);
      if (explicit) {
        goto LABEL_42;
      }
      uint64_t v8 = (atomic_uint *)((char *)this + 176);
      unsigned int v9 = 8;
    }
    goto LABEL_53;
  }
  if (v3 != 1634561906) {
    return 0;
  }
  if ((v5 & 0x2000000) == 0) {
    goto LABEL_13;
  }
  int v17 = 536870916;
  if (a3) {
    *a3 = 1836020344;
  }
LABEL_66:
  unsigned int v6 = (atomic_ullong *)((char *)this + 64);
  if (atomic_load_explicit((atomic_ullong *volatile)this + 8, memory_order_acquire) || (v5 & 4) != 0)
  {
    if ((v17 & v5) != 4) {
      return atomic_load_explicit(v6, memory_order_acquire);
    }
    return 0;
  }
  id v31 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr, TBaseFont *, uint64_t, unsigned int *))(*(void *)this + 496))(&v31, this, a2, a3);
  id v30 = CGFontCopyTableForTag((CGFontRef)atomic_load_explicit((atomic_ullong *volatile)&v31, memory_order_acquire), 0x6D6F7278u);
  unint64_t v18 = atomic_load_explicit((atomic_ullong *volatile)&v30, memory_order_acquire);
  if (v18)
  {
    uint64_t v19 = 0;
    unint64_t v20 = atomic_exchange((atomic_ullong *volatile)&v30, 0);
    atomic_compare_exchange_strong(v6, (unint64_t *)&v19, v20);
    if (v19) {
      int v21 = (void *)v20;
    }
    else {
      int v21 = 0;
    }
  }
  else
  {
    atomic_fetch_or_explicit((atomic_uint *volatile)this + 44, 4u, memory_order_relaxed);
  }

  uint64_t result = 0;
  if (v18 && (v17 & v5) != 4) {
    return atomic_load_explicit(v6, memory_order_acquire);
  }
  return result;
}

uint64_t OTL::GCommon::GCommon(uint64_t a1, int a2, unsigned char *a3, CFDataRef theData, uint64_t a5, int a6, unsigned int a7)
{
  v44[4] = *MEMORY[0x1E4F143B8];
  *(void *)a1 = &unk_1ED05FB48;
  *(_DWORD *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = a3;
  *(void *)(a1 + 24) = a5;
  if (!theData || (*(void *)(a1 + 32) = CFDataGetBytePtr(theData), (BytePtr = CFDataGetBytePtr(theData)) == 0))
  {
    *(_OWORD *)(a1 + 65) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
    *(_OWORD *)(a1 + 40) = 0u;
LABEL_45:
    *(void *)(a1 + 32) = 0;
    return a1;
  }
  unint64_t v14 = (unint64_t)&BytePtr[CFDataGetLength(theData)];
  *(void *)(a1 + 40) = v14;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(unsigned char *)(a1 + 80) = 0;
  uint64_t v15 = *(unsigned __int16 **)(a1 + 32);
  if ((unint64_t)(v15 + 5) > v14 || bswap32(*v15) >> 16 > 1) {
    goto LABEL_45;
  }
  if (v15[1] && (unint64_t)(v15 + 7) > v14) {
    goto LABEL_45;
  }
  if (!v15[3]) {
    goto LABEL_19;
  }
  int v17 = (unsigned __int16 *)((char *)v15 + __rev16(v15[3]));
  unint64_t v18 = v17 + 1;
  if ((unint64_t)(v17 + 1) > v14) {
    goto LABEL_19;
  }
  uint64_t v19 = bswap32(*v17) >> 16;
  unint64_t v20 = (unint64_t)&v18[3 * v19];
  if (v20 < (unint64_t)v18 || v20 > v14)
  {
    unint64_t v22 = (v14 - (unint64_t)v18) / 6;
    if ((unint64_t)(v17 + 4) > v14) {
      unint64_t v22 = 0;
    }
    if (v22 != v19) {
LABEL_19:
    }
      int v17 = 0;
  }
  *(void *)(a1 + 56) = v17;
  if (!v15[4]
    || (v23 = (unsigned __int16 *)((char *)v15 + __rev16(v15[4])), unint64_t v24 = v23 + 1, (unint64_t)(v23 + 1) > v14))
  {
    *(void *)(a1 + 64) = 0;
    goto LABEL_23;
  }
  uint64_t v37 = bswap32(*v23) >> 16;
  unint64_t v38 = (unint64_t)&v24[v37];
  if ((unint64_t)(v23 + 2) <= v14) {
    unint64_t v39 = (v14 - (unint64_t)v24) >> 1;
  }
  else {
    unint64_t v39 = 0;
  }
  BOOL v42 = v38 >= (unint64_t)v24 && v38 <= v14 || v39 == v37;
  if (!v42) {
    uint64_t v23 = 0;
  }
  *(void *)(a1 + 64) = v23;
  if (!v17 || !v42)
  {
LABEL_23:
    *(void *)(a1 + 32) = 0;
    if (a2) {
      return a1;
    }
    goto LABEL_24;
  }
  OTL::GCommon::InitLangSysTable(a1, (uint64_t)a3, a6, a7);
  if (a2) {
    return a1;
  }
LABEL_24:
  if (*(unsigned char *)(a1 + 80))
  {
    if (*a3)
    {
      char v43 = 0;
      unint64_t v26 = *(void *)(a1 + 40);
      uint64_t v25 = *(void *)(a1 + 48);
      unint64_t v27 = *(void *)(a1 + 32);
      v44[0] = &unk_1ED0613E8;
      v44[1] = &v43;
      v44[3] = v44;
      OTL::GCommon::IterateFeatureTables(v27, v25, v26, (uint64_t)v44);
      std::__function::__value_func<BOOL ()(unsigned int,OTL::FeatureTable const*,BOOL &)>::~__value_func[abi:nn180100](v44);
      if (!v43)
      {
        unint64_t v28 = *(_WORD **)(a1 + 56);
        if (*v28)
        {
          char v29 = 0;
          LODWORD(v30) = __rev16((unsigned __int16)*v28);
          if (v30 <= 1) {
            uint64_t v30 = 1;
          }
          else {
            uint64_t v30 = v30;
          }
          id v31 = (unsigned int *)(v28 + 1);
          do
          {
            unsigned int v32 = *v31;
            id v31 = (unsigned int *)((char *)v31 + 6);
            unsigned int v33 = bswap32(v32);
            if (v33 == 1986359924 || v33 == 1987212338) {
              char v29 = 1;
            }
            if (v33 == 1986359924 || v33 == 1987212338) {
              break;
            }
            --v30;
          }
          while (v30);
          if (v29) {
            OTL::GCommon::InitLangSysTable(a1, (uint64_t)a3, 0, 0);
          }
        }
      }
    }
  }
  return a1;
}

void OTL::GCommon::InitLangSysTable(uint64_t a1, uint64_t a2, int a3, unsigned int a4)
{
  while (1)
  {
    unint64_t v9 = *(void *)(a1 + 32);
    unint64_t v8 = *(void *)(a1 + 40);
    uint64_t v10 = __rev16(*(unsigned __int16 *)(v9 + 4));
    uint64_t v11 = (unsigned __int16 *)(v9 + v10);
    unint64_t v12 = (unsigned int *)(v9 + v10 + 2);
    if (!*(_WORD *)(v9 + 4) || (unint64_t)v12 > v8) {
      break;
    }
    unsigned int v14 = *v11;
    unint64_t v15 = __rev16(v14);
    int v16 = (char *)v12 + 6 * v15;
    if (v16 < (char *)v12 || (unint64_t)v16 > v8)
    {
      if ((unint64_t)(v11 + 4) <= v8) {
        unint64_t v18 = (v8 - (unint64_t)v12) / 6;
      }
      else {
        unint64_t v18 = 0;
      }
      if (v18 != v15 || v14 == 0) {
        return;
      }
    }
    else if (!*v11)
    {
      return;
    }
    if (a3) {
      int v20 = a3;
    }
    else {
      int v20 = 1818326126;
    }
    signed int v21 = v20 & 0xFFFFFF00 | 0x20;
    if (v21 > 1835822367)
    {
      if (v21 <= 1869773087)
      {
        if (v21 == 1835822368) {
          goto LABEL_60;
        }
        if (v21 == 1836674336) {
          goto LABEL_39;
        }
      }
      else
      {
        switch(v21)
        {
          case 1869773088:
            goto LABEL_53;
          case 1952803872:
            goto LABEL_52;
          case 1953328160:
            goto LABEL_33;
        }
      }
    }
    else if (v21 <= 1735029279)
    {
      a3 = 1650814567;
      unsigned int v22 = 1651402547;
      if (v21 == 1651402528) {
        goto LABEL_61;
      }
      if (v21 == 1684370976) {
        goto LABEL_36;
      }
    }
    else
    {
      switch(v21)
      {
        case 1735029280:
          goto LABEL_46;
        case 1735750176:
          goto LABEL_47;
        case 1802396704:
          goto LABEL_28;
      }
    }
    if (v20 > 1835825516)
    {
      if (v20 <= 1869773152)
      {
        if (v20 == 1835825517)
        {
LABEL_60:
          unsigned int v22 = 1835822387;
          a3 = 1835825517;
          goto LABEL_61;
        }
        if (v20 != 1836674418)
        {
LABEL_59:
          a3 = v20;
          unsigned int v22 = v20;
          goto LABEL_61;
        }
LABEL_39:
        unsigned int v22 = 1836674354;
        a3 = 1836674418;
        goto LABEL_61;
      }
      if (v20 == 1869773153)
      {
LABEL_53:
        unsigned int v22 = 1869773107;
        a3 = 1869773153;
        goto LABEL_61;
      }
      if (v20 != 1952542060)
      {
        if (v20 != 1952803957) {
          goto LABEL_59;
        }
LABEL_52:
        unsigned int v22 = 1952803891;
        a3 = 1952803957;
        goto LABEL_61;
      }
LABEL_33:
      unsigned int v22 = 1953328179;
      a3 = 1952542060;
      goto LABEL_61;
    }
    if (v20 <= 1735748209)
    {
      if (v20 == 1650814567)
      {
        a3 = 1650814567;
        unsigned int v22 = 1651402547;
        goto LABEL_61;
      }
      if (v20 != 1684371041) {
        goto LABEL_59;
      }
LABEL_36:
      unsigned int v22 = 1684370995;
      a3 = 1684371041;
      goto LABEL_61;
    }
    if (v20 == 1735748210)
    {
LABEL_46:
      unsigned int v22 = 1735029299;
      a3 = 1735748210;
      goto LABEL_61;
    }
    if (v20 == 1735750261)
    {
LABEL_47:
      unsigned int v22 = 1735750195;
      a3 = 1735750261;
      goto LABEL_61;
    }
    if (v20 != 1802396769) {
      goto LABEL_59;
    }
LABEL_28:
    unsigned int v22 = 1802396723;
    a3 = 1802396769;
LABEL_61:
    uint64_t v23 = 0;
    unint64_t v24 = (unsigned __int16 *)(v9 + v10 + 6);
    unint64_t v25 = 1;
    while (1)
    {
      unint64_t v26 = (unsigned __int16 *)((char *)v11 + (bswap32(*v24) >> 16));
      if ((unint64_t)(v26 + 2) > v8) {
        break;
      }
      unsigned int v27 = *((_DWORD *)v24 - 1);
      unsigned int v28 = bswap32(v27);
      if (v27 == 1414284868 && v23 == 0)
      {
        *(_DWORD *)(a1 + 72) = 1145457748;
        goto LABEL_89;
      }
      if ((v28 << 24) - 973078528 >= 0xF7000001)
      {
        signed int v30 = v28 & 0xFFFFFF00 | 0x20;
        if (v30 > 1835822367)
        {
          if (v30 <= 1869773087)
          {
            int v31 = 1835825517;
            if (v30 != 1835822368)
            {
              int v31 = 1836674418;
              int v32 = 1836674336;
              goto LABEL_82;
            }
          }
          else
          {
            int v31 = 1869773153;
            if (v30 != 1869773088)
            {
              int v31 = 1952803957;
              if (v30 != 1952803872)
              {
                int v31 = 1952542060;
                int v32 = 1953328160;
                goto LABEL_82;
              }
            }
          }
        }
        else if (v30 <= 1735029279)
        {
          int v31 = 1650814567;
          if (v30 != 1651402528)
          {
            int v31 = 1684371041;
            int v32 = 1684370976;
            goto LABEL_82;
          }
        }
        else
        {
          int v31 = 1735748210;
          if (v30 != 1735029280)
          {
            if (v30 == 1735750176)
            {
              int v31 = 1735750261;
            }
            else
            {
              int v31 = 1802396769;
              int v32 = 1802396704;
LABEL_82:
              if (v30 != v32) {
                int v31 = v28;
              }
            }
          }
        }
        if (v31 == a3)
        {
          *(_DWORD *)(a1 + 72) = a3;
          *(_DWORD *)(a1 + 76) = v28;
          goto LABEL_89;
        }
      }
      if (v28 != a3 || *(_DWORD *)(a1 + 76)) {
        goto LABEL_90;
      }
      *(_DWORD *)(a1 + 72) = a3;
LABEL_89:
      uint64_t v23 = v26;
LABEL_90:
      if (v28 < v22)
      {
        v24 += 3;
        BOOL v42 = v25++ >= v15;
        if (!v42) {
          continue;
        }
      }
      break;
    }
    if (v23) {
      goto LABEL_101;
    }
    uint64_t v33 = a2;
    long long v34 = *(TBaseFont **)(a2 + 400);
    if ((*((_DWORD *)v34 + 46) & 0x400) == 0) {
      TBaseFont::DetermineFontFlags(v34, 0x400u);
    }
    int v35 = *((_DWORD *)v34 + 45);
    a2 = v33;
    if ((v35 & 0x400) == 0) {
      return;
    }
    uint64_t v23 = (unsigned __int16 *)((char *)v11 + (bswap32(v11[3]) >> 16));
    unint64_t v8 = *(void *)(a1 + 40);
    if ((unint64_t)(v23 + 2) > v8) {
      return;
    }
    *(_DWORD *)(a1 + 72) = bswap32(*v12);
    unint64_t v9 = *(void *)(a1 + 32);
LABEL_101:
    if (*v23)
    {
      uint64_t v36 = (char *)v23 + __rev16(*v23);
      unint64_t v37 = (unint64_t)(v36 + 6);
      if ((unint64_t)(v36 + 4) < v9 || v37 > v8) {
        return;
      }
      uint64_t v39 = bswap32(*((unsigned __int16 *)v36 + 2)) >> 16;
      unint64_t v40 = v37 + 2 * v39;
      unint64_t v41 = (unint64_t)(v36 + 8) <= v8 ? (v8 - v37) >> 1 : 0;
      BOOL v42 = v40 <= v8 && v40 >= v37;
      if (!v42 && v41 != v39) {
        return;
      }
      if (!a4)
      {
LABEL_159:
        *(void *)(a1 + 48) = v36;
        *(unsigned char *)(a1 + 80) = 1;
        return;
      }
      *(void *)(a1 + 48) = v36;
    }
    uint64_t v44 = v23 + 2;
    if (v9 > (unint64_t)(v23 + 2)
      || ((LODWORD(v45) = __rev16(v23[1]),
           unint64_t v46 = (unint64_t)&v44[3 * v45],
           v46 >= (unint64_t)v44)
        ? (BOOL v47 = v46 > v8)
        : (BOOL v47 = 1),
          v47))
    {
      LODWORD(v45) = 0;
      if (v9 <= (unint64_t)v44 && (unint64_t)(v23 + 5) <= v8) {
        unint64_t v45 = (v8 - (unint64_t)v44) / 6;
      }
      if (!(bswap32(v45) >> 16)) {
        goto LABEL_154;
      }
LABEL_130:
      if ((v45 & 0xFFFE) != 0) {
        uint64_t v48 = (unsigned __int16)v45;
      }
      else {
        uint64_t v48 = 1;
      }
      char v49 = v23 + 4;
      uint64_t v50 = v23 + 4;
      while (1)
      {
        unsigned int v52 = *v50;
        v50 += 3;
        unsigned int v51 = v52;
        if (v52)
        {
          uint64_t v36 = (char *)v23 + __rev16(v51);
          unint64_t v53 = (unint64_t)(v36 + 6);
          if ((unint64_t)(v36 + 4) < v9 || v53 > v8) {
            return;
          }
          uint64_t v55 = bswap32(*((unsigned __int16 *)v36 + 2)) >> 16;
          unint64_t v56 = v53 + 2 * v55;
          unint64_t v57 = (unint64_t)(v36 + 8) <= v8 ? (v8 - v53) >> 1 : 0;
          BOOL v58 = v56 <= v8 && v56 >= v53;
          if (!v58 && v57 != v55) {
            return;
          }
          unsigned int v60 = *((_DWORD *)v49 - 1);
          if (bswap32(v60) == a4) {
            goto LABEL_159;
          }
          if (!v60) {
            *(void *)(a1 + 48) = v36;
          }
        }
        char v49 = v50;
        if (!--v48) {
          goto LABEL_154;
        }
      }
    }
    if (v23[1]) {
      goto LABEL_130;
    }
LABEL_154:
    if (a4)
    {
      if (!*(unsigned char *)(a1 + 80))
      {
        a4 = FallbackForLangSysTag(a4);
        if (a4) {
          continue;
        }
      }
    }
    return;
  }
}

uint64_t ScriptTagForScriptCode(int a1)
{
  uint64_t v2 = 1652128365;
  switch(a1)
  {
    case -1:
      return 0;
    case 0:
    case 1:
    case 102:
    case 103:
    case 129:
    case 174:
      return 1145457748;
    case 2:
      return 1634885986;
    case 3:
      int v3 = 3084;
      int v4 = 1634885986;
      return v4 | v3;
    case 4:
      return 1650814567;
    case 5:
      return 1651470447;
    case 6:
      return 1667786098;
    case 7:
      return 1668247668;
    case 8:
      return 1668903532;
    case 9:
      return 1685287540;
    case 10:
      return 1684371041;
    case 11:
      return 1702127721;
    case 12:
      return 1734700914;
    case 13:
      return 1735357544;
    case 14:
      return 1735550315;
    case 15:
      return 1735748210;
    case 16:
      return 1735750261;
    case 17:
      return 1751215721;
    case 18:
      return 1751215719;
    case 19:
      return 1751474802;
    case 20:
    case 22:
    case 54:
      return 1801547361;
    case 21:
      return 1802396769;
    case 23:
      return 1802005874;
    case 24:
      return 1818324768;
    case 25:
      return 1818326126;
    case 26:
      return 1835825517;
    case 27:
      int v5 = 1836016745;
      return (v5 + 2558);
    case 28:
      return 1836674418;
    case 29:
      return 1869046125;
    case 30:
      return 1769234796;
    case 31:
      return 1869773153;
    case 32:
      return 1920298610;
    case 33:
      return 1936289384;
    case 34:
    case 95:
    case 96:
    case 97:
      return 1937338979;
    case 35:
      return 1952542060;
    case 36:
      return 1952803957;
    case 37:
      return 1952997729;
    case 38:
      int v6 = 1952997729;
      return v6 | 8u;
    case 39:
      return 1953063540;
    case 40:
      return 1667329651;
    case 41:
      return 2036932640;
    case 42:
      return 1952935015;
    case 43:
      int v6 = 1751215719;
      return v6 | 8u;
    case 44:
      return 1651861604;
    case 45:
      return 1952540514;
    case 46:
      return 1651663209;
    case 47:
      return 1668313716;
    case 48:
      return 1818848610;
    case 49:
      int v7 = 1818848610;
      return (v7 + 256);
    case 50:
      return 1869835617;
    case 51:
      unsigned __int16 v8 = 24951;
      return v8 | 0x73680000u;
    case 52:
      return 1952541797;
    case 53:
      return 1969709426;
    case 55:
      return 1651861353;
    case 56:
      return 1735156071;
    case 57:
      return 1802002802;
    case 58:
      return 1937337455;
    case 59:
      return 1952541813;
    case 60:
      return 1952869991;
    case 61:
      return 2020631919;
    case 62:
      return 1650551913;
    case 63:
      return 1650553963;
    case 65:
      return 1651663208;
    case 66:
      return 1667785069;
    case 71:
      return 1701280112;
    case 75:
      return 1752002151;
    case 76:
      return 1752526439;
    case 78:
      return 1784772193;
    case 79:
      return 1801546857;
    case 82:
      return 1818587235;
    case 83:
      return 1818848865;
    case 84:
      return 1835101796;
    case 86:
      return 1835364975;
    case 87:
      return 1852534560;
    case 88:
      return 1869769576;
    case 89:
      return 1885696621;
    case 90:
      return 1885888871;
    case 91:
      return 1885892216;
    case 99:
      return 1986095392;
    case 101:
      return 2020832632;
    case 104:
      return 1667330665;
    case 106:
      return 1818324577;
    case 107:
      return 1819894633;
    case 108:
      int v7 = 1819894633;
      return (v7 + 256);
    case 109:
      return 1869374315;
    case 110:
      return 1919577703;
    case 111:
      return 1935766898;
    case 112:
      return 1936158327;
    case 113:
      return 1937075812;
    case 115:
      return 1836344681;
    case 116:
      return 1634889065;
    case 117:
      return 1635152756;
    case 118:
      return 1667328877;
    case 120:
      return 1802791017;
    case 121:
      return 1835101801;
    case 122:
      return 1885891689;
    case 123:
      return 1885891696;
    case 125:
      return 1886549097;
    case 126:
      return 1935764850;
    case 127:
      return 1952544372;
    case 128:
      return 1835103336;
    case 130:
      return 1650552181;
    case 131:
      return 1818850165;
    case 133:
      return 1935766114;
    case 134:
      return 1650553715;
    case 135:
      return 1685418092;
    case 136:
      return 1701601889;
    case 137:
      return 1735549294;
    case 140:
      int v5 = 1835361382;
      return (v5 + 2558);
    case 141:
      return 1835364963;
    case 142:
      return 1851880034;
    case 143:
      return 1851941236;
    case 144:
      return 1885432941;
    case 145:
      int v3 = 2560;
      int v4 = 1936286820;
      return v4 | v3;
    case 146:
      return 2002874977;
    case 149:
      return 1836216175;
    case 150:
      return 1853057141;
    case 151:
      unsigned __int16 v8 = 29284;
      return v8 | 0x73680000u;
    case 152:
      return 1936683617;
    case 153:
      return 1952541554;
    case 154:
      return 1952542311;
    case 156:
      return 1751938423;
    case 157:
      return 1802006378;
    case 158:
      return 1953067624;
    case 159:
      return 1634166882;
    case 160:
      return 1835100266;
    case 161:
      return 1634234221;
    case 162:
      return 1751217266;
    case 163:
      return 1836016745;
    case 164:
      return 1836412020;
    case 165:
      return 1885435235;
    case 166:
      return 1936286820;
    case 167:
      return 1633971309;
    case 168:
      return 1651010419;
    case 169:
      return 1835102819;
    case 170:
      return 1852143457;
    case 171:
      return 1869834085;
    case 175:
      return 1735356013;
    case 176:
      unsigned __int16 v11 = 31087;
      return v11 | 0x736F0000u;
    case 177:
      return 2053205602;
    case 178:
      return 1685022578;
    case 179:
      return 1735356007;
    case 180:
      return 1835101025;
    case 181:
      return 1835361382;
    case 182:
      return 1919903847;
    case 183:
      unsigned __int16 v11 = 26468;
      return v11 | 0x736F0000u;
    case 184:
      int v3 = 11;
      int v4 = 1936680804;
      return v4 | v3;
    case 193:
      return 1668312430;
    case 194:
      return 1869965170;
    case 195:
      return 1953395553;
    case 196:
      return 1953461359;
    case 197:
      return 1986622568;
    case 198:
      return 1801549673;
    case 199:
      return 1851877229;
    case 201:
      return v2;
    case 202:
      return 1836413795;
    default:
      os_unfair_lock_lock_with_options();
      unint64_t v9 = (_OWORD *)qword_1EB2CE4D0;
      if (qword_1EB2CE4D0) {
        goto LABEL_68;
      }
      unint64_t v9 = operator new(0x28uLL, MEMORY[0x1E4FBA2D0]);
      if (v9)
      {
        *unint64_t v9 = 0u;
        v9[1] = 0u;
        *((_DWORD *)v9 + 8) = 1065353216;
        qword_1EB2CE4D0 = (uint64_t)v9;
LABEL_68:
        uint64_t v10 = std::__hash_table<std::__hash_value_type<UScriptCode,unsigned int>,std::__unordered_map_hasher<UScriptCode,std::__hash_value_type<UScriptCode,unsigned int>,std::hash<UScriptCode>,std::equal_to<UScriptCode>,true>,std::__unordered_map_equal<UScriptCode,std::__hash_value_type<UScriptCode,unsigned int>,std::equal_to<UScriptCode>,std::hash<UScriptCode>,true>,std::allocator<std::__hash_value_type<UScriptCode,unsigned int>>>::find<UScriptCode>(v9, a1);
        if (v10)
        {
          uint64_t v2 = *((unsigned int *)v10 + 5);
          goto LABEL_176;
        }
      }
      else
      {
        qword_1EB2CE4D0 = 0;
      }
      ShortName = (const char *)uscript_getShortName();
      if (ShortName && (int v13 = (char *)ShortName, strlen(ShortName) > 3))
      {
        uint64_t v2 = (v13[1] << 16) | (__tolower(*v13) << 24) | (v13[2] << 8) | v13[3];
        unsigned int v14 = (float *)qword_1EB2CE4D0;
        if (!qword_1EB2CE4D0) {
          goto LABEL_176;
        }
        int v15 = a1;
        int v16 = a1;
        int v17 = v2;
      }
      else
      {
        uint64_t v2 = 1145457748;
        unsigned int v14 = (float *)qword_1EB2CE4D0;
        if (!qword_1EB2CE4D0) {
          goto LABEL_176;
        }
        int v15 = a1;
        int v16 = a1;
        int v17 = 1145457748;
      }
      std::__hash_table<std::__hash_value_type<UScriptCode,unsigned int>,std::__unordered_map_hasher<UScriptCode,std::__hash_value_type<UScriptCode,unsigned int>,std::hash<UScriptCode>,std::equal_to<UScriptCode>,true>,std::__unordered_map_equal<UScriptCode,std::__hash_value_type<UScriptCode,unsigned int>,std::equal_to<UScriptCode>,std::hash<UScriptCode>,true>,std::allocator<std::__hash_value_type<UScriptCode,unsigned int>>>::__emplace_unique_key_args<UScriptCode,std::pair<UScriptCode,unsigned int>>(v14, v15, v16, v17);
LABEL_176:
      os_unfair_lock_unlock(&stru_1EB2CE494);
      return v2;
  }
}

uint64_t FallbackForLangSysTag(unsigned int a1)
{
  if (HIWORD(a1) == 23112)
  {
    if (a1 == 1514689613) {
      return 1514686496;
    }
    else {
      return 0;
    }
  }
  else
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB2CE498, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB2CE498))
    {
      xmmword_1EB2CE528 = 0u;
      *(_OWORD *)&qword_1EB2CE538 = 0u;
      dword_1EB2CE548 = 1065353216;
      __cxa_guard_release(&qword_1EB2CE498);
    }
    if (qword_1EB2CE4A0 != -1) {
      dispatch_once_f(&qword_1EB2CE4A0, 0, (dispatch_function_t)FallbackForLangSysTag::$_0::__invoke);
    }
    if (result) {
      return *(unsigned int *)(result + 20);
    }
  }
  return result;
}

void ConvertSettingsToOTFeatures(unsigned int **a1, atomic_ullong *a2, int a3, int64x2_t *a4, uint64_t (*a5)(void), _DWORD *a6, int a7)
{
  unsigned __int16 v11 = *a1;
  unint64_t v10 = (unint64_t)a1[1];
  CFArrayRef explicit = (const __CFArray *)atomic_load_explicit(a2, memory_order_acquire);
  if (explicit && (int v15 = (TFontFeatureSettingList *)a2, Count = CFArrayGetCount(explicit), Count >= 1))
  {
    uint64_t v17 = Count;
    v154 = v15;
    v152 = a6;
    if ((unint64_t)v11 < v10)
    {
      uint64_t v151 = a5;
      int v18 = 0;
      if (a3) {
        int v19 = 32;
      }
      else {
        int v19 = 16;
      }
      int v155 = v19;
      uint64_t v147 = (uint64_t)&a4[1].i64[1];
      v153 = (void *)((char *)v15 + 16);
      int v150 = a7;
      while (1)
      {
        int v20 = (_DWORD *)a4->i64[0];
        signed int v21 = (_DWORD *)a4->i64[1];
        unsigned int v22 = *v11;
        if ((_DWORD *)a4->i64[0] != v21)
        {
          do
          {
            if (*v20 == v22) {
              goto LABEL_12;
            }
            v20 += 2;
          }
          while (v20 != v21);
          int v20 = (_DWORD *)a4->i64[1];
        }
LABEL_12:
        MasterFeatureMapEntry = FindMasterFeatureMapEntry(v22);
        if (MasterFeatureMapEntry)
        {
          unint64_t v24 = MasterFeatureMapEntry;
          int v25 = *((_DWORD *)MasterFeatureMapEntry + 2);
          if ((v25 & v155) == 0)
          {
            uint64_t v29 = *((unsigned __int16 *)MasterFeatureMapEntry + 2);
            if (a7 == 1 && (v25 & 2) != 0)
            {
              if (v25)
              {
                uint64_t v36 = *v153;
                if (!*v153) {
                  goto LABEL_49;
                }
                unint64_t v37 = v153;
                do
                {
                  unsigned int v38 = *(unsigned __int16 *)(v36 + 32);
                  BOOL v39 = v38 >= v29;
                  if (v38 >= v29) {
                    unint64_t v40 = (uint64_t *)v36;
                  }
                  else {
                    unint64_t v40 = (uint64_t *)(v36 + 8);
                  }
                  if (v39) {
                    unint64_t v37 = (void *)v36;
                  }
                  uint64_t v36 = *v40;
                }
                while (*v40);
                if (v37 == v153 || *((unsigned __int16 *)v37 + 16) > v29 || v37[6] == -1)
                {
LABEL_49:
                  if (v20 != v21) {
                    goto LABEL_108;
                  }
                  BOOL v42 = (_DWORD *)a4->i64[1];
                  unint64_t v41 = a4[1].u64[0];
                  if ((unint64_t)v42 < v41)
                  {
                    *BOOL v42 = *(_DWORD *)v24;
                    int v43 = 1;
                    goto LABEL_82;
                  }
                  uint64_t v62 = ((uint64_t)v42 - a4->i64[0]) >> 3;
                  unint64_t v63 = v62 + 1;
                  if ((unint64_t)(v62 + 1) >> 61) {
                    goto LABEL_240;
                  }
                  uint64_t v64 = v41 - a4->i64[0];
                  if (v64 >> 2 > v63) {
                    unint64_t v63 = v64 >> 2;
                  }
                  if ((unint64_t)v64 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v65 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v65 = v63;
                  }
                  v158 = &a4[1].i8[8];
                  uint64_t v66 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate(v147, v65);
                  CFRange v67 = &v66[8 * v62];
                  *(_DWORD *)CFRange v67 = *(_DWORD *)v24;
                  *((_DWORD *)v67 + 1) = 1;
                  uint64_t v69 = (_DWORD *)a4->i64[0];
                  unint64_t v68 = a4->u64[1];
                  if (v68 != a4->i64[0])
                  {
                    uint64_t v70 = &v66[8 * v62];
                    do
                    {
                      uint64_t v71 = *(void *)(v68 - 8);
                      v68 -= 8;
                      *((void *)v70 - 1) = v71;
                      v70 -= 8;
                    }
                    while ((_DWORD *)v68 != v69);
                    goto LABEL_104;
                  }
                  goto LABEL_105;
                }
              }
              else if (TFontFeatureSettingList::IndexOfAATSetting(v15, v29, *((unsigned __int16 *)MasterFeatureMapEntry + 3) ^ 1u) == -1)
              {
                goto LABEL_49;
              }
              if (v20 == v21 || v151 && (v151(*(unsigned int *)v24) & 1) != 0) {
                goto LABEL_109;
              }
              unint64_t v26 = v20 + 2;
              signed int v30 = (_DWORD *)a4->i64[1];
              if (v20 + 2 == v30) {
                goto LABEL_18;
              }
              do
              {
                int v31 = v26[1];
                *(v26 - 2) = *v26;
                *(v26 - 1) = v31;
                v26 += 2;
              }
              while (v26 != v30);
              goto LABEL_17;
            }
            if ((v25 & 0x40) != 0)
            {
              uint64_t v44 = *v153;
              if (*v153)
              {
                unint64_t v45 = v153;
                do
                {
                  unsigned int v46 = *(unsigned __int16 *)(v44 + 32);
                  BOOL v47 = v46 >= v29;
                  if (v46 >= v29) {
                    uint64_t v48 = (uint64_t *)v44;
                  }
                  else {
                    uint64_t v48 = (uint64_t *)(v44 + 8);
                  }
                  if (v47) {
                    unint64_t v45 = (void *)v44;
                  }
                  uint64_t v44 = *v48;
                }
                while (*v48);
                if (v45 != v153 && *((unsigned __int16 *)v45 + 16) <= v29)
                {
                  CFIndex v32 = v45[6];
                  goto LABEL_31;
                }
              }
            }
            else
            {
              CFIndex v32 = TFontFeatureSettingList::IndexOfAATSetting(v15, v29, *((unsigned __int16 *)MasterFeatureMapEntry + 3));
LABEL_31:
              if (v32 != -1)
              {
                if ((v24[1] & 0x40) != 0
                  && (ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)v154, memory_order_acquire), v32), (CFNumberRef v33 = (const __CFNumber *)-[CTFeatureSetting type]((uint64_t)ValueAtIndex)) != 0)&& (LOWORD(valuePtr[0]) = -21846, CFNumberGetValue(v33, kCFNumberShortType, valuePtr), LOWORD(valuePtr[0]) == *((unsigned __int16 *)v24 + 2))&& (v34 = (const __CFNumber *)-[CTFeatureSetting selector]((uint64_t)ValueAtIndex)) != 0)
                {
                  LODWORD(valuePtr[0]) = -1431655766;
                  CFNumberGetValue(v34, kCFNumberIntType, valuePtr);
                  int v35 = (int)valuePtr[0];
                }
                else
                {
                  int v35 = 1;
                }
                int v149 = v35;
                unsigned int v51 = CFArrayGetValueAtIndex((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)v154, memory_order_acquire), v32);
                CFStringRef v52 = (const __CFString *)-[CTFeatureSetting tag]((uint64_t)v51);
                unsigned int v53 = FourCharCodeFromString(v52);
                if (!v53 || v53 == *(_DWORD *)v24) {
                  goto LABEL_79;
                }
                memset(valuePtr, 170, sizeof(valuePtr));
                TFontFeatureSettingList::IndexesOfAATSetting(v154, *((_WORD *)v24 + 2), *((unsigned __int16 *)v24 + 3), valuePtr);
                uint64_t v54 = valuePtr[0] + 8;
                do
                {
                  uint64_t v55 = v54;
                  unint64_t v56 = valuePtr[1];
                  if (v54 == valuePtr[1]) {
                    break;
                  }
                  unint64_t v57 = CFArrayGetValueAtIndex((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)v154, memory_order_acquire), *(void *)v54);
                  CFStringRef v58 = (const __CFString *)-[CTFeatureSetting tag]((uint64_t)v57);
                  if (!v58) {
                    break;
                  }
                  unsigned int v59 = FourCharCodeFromString(v58);
                  uint64_t v54 = v55 + 8;
                }
                while (v59 != *(_DWORD *)v24);
                if (valuePtr[0])
                {
                  valuePtr[1] = valuePtr[0];
                  operator delete(valuePtr[0]);
                }
                BOOL v88 = v55 == v56;
                a7 = v150;
                if (!v88)
                {
LABEL_79:
                  int v15 = v154;
                  if (v20 != v21) {
                    goto LABEL_108;
                  }
                  BOOL v42 = (_DWORD *)a4->i64[1];
                  unint64_t v60 = a4[1].u64[0];
                  if ((unint64_t)v42 < v60)
                  {
                    *BOOL v42 = *(_DWORD *)v24;
                    int v43 = v149;
LABEL_82:
                    v42[1] = v43;
                    long long v61 = v42 + 2;
LABEL_107:
                    a4->i64[1] = (uint64_t)v61;
                    a7 = v150;
LABEL_108:
                    v18 |= v24[1] & 0xFFFFFE00;
                    goto LABEL_109;
                  }
                  uint64_t v72 = ((uint64_t)v42 - a4->i64[0]) >> 3;
                  unint64_t v73 = v72 + 1;
                  if ((unint64_t)(v72 + 1) >> 61) {
                    goto LABEL_240;
                  }
                  uint64_t v74 = v60 - a4->i64[0];
                  if (v74 >> 2 > v73) {
                    unint64_t v73 = v74 >> 2;
                  }
                  if ((unint64_t)v74 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v65 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v65 = v73;
                  }
                  v158 = &a4[1].i8[8];
                  uint64_t v66 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate(v147, v65);
                  CFRange v67 = &v66[8 * v72];
                  *(_DWORD *)CFRange v67 = *(_DWORD *)v24;
                  *((_DWORD *)v67 + 1) = v149;
                  uint64_t v75 = (_DWORD *)a4->i64[0];
                  unint64_t v68 = a4->u64[1];
                  if (v68 != a4->i64[0])
                  {
                    uint64_t v70 = &v66[8 * v72];
                    do
                    {
                      uint64_t v76 = *(void *)(v68 - 8);
                      v68 -= 8;
                      *((void *)v70 - 1) = v76;
                      v70 -= 8;
                    }
                    while ((_DWORD *)v68 != v75);
LABEL_104:
                    int64x2_t v77 = *a4;
LABEL_106:
                    long long v61 = v67 + 8;
                    a4->i64[0] = (uint64_t)v70;
                    a4->i64[1] = (uint64_t)(v67 + 8);
                    *(int64x2_t *)&valuePtr[1] = v77;
                    uint64_t v78 = a4[1].i64[0];
                    a4[1].i64[0] = (uint64_t)&v66[8 * v65];
                    uint64_t v157 = v78;
                    valuePtr[0] = (char *)v77.i64[0];
                    std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)valuePtr);
                    int v15 = v154;
                    goto LABEL_107;
                  }
LABEL_105:
                  int64x2_t v77 = vdupq_n_s64(v68);
                  uint64_t v70 = v67;
                  goto LABEL_106;
                }
LABEL_83:
                int v15 = v154;
                goto LABEL_109;
              }
            }
            if (v20 == v21
              || v151 && (((uint64_t (*)(void, uint64_t))v151)(*(unsigned int *)v24, v29) & 1) != 0)
            {
              goto LABEL_83;
            }
            unint64_t v26 = v20 + 2;
            char v49 = (_DWORD *)a4->i64[1];
            int v15 = v154;
            if (v20 + 2 == v49) {
              goto LABEL_18;
            }
            do
            {
              int v50 = v26[1];
              *(v26 - 2) = *v26;
              *(v26 - 1) = v50;
              v26 += 2;
            }
            while (v26 != v49);
LABEL_17:
            int v20 = v26 - 2;
            goto LABEL_18;
          }
          if (v20 != v21)
          {
            unint64_t v26 = v20 + 2;
            unsigned int v27 = (_DWORD *)a4->i64[1];
            if (v20 + 2 != v27)
            {
              do
              {
                int v28 = v26[1];
                *(v26 - 2) = *v26;
                *(v26 - 1) = v28;
                v26 += 2;
              }
              while (v26 != v27);
              goto LABEL_17;
            }
LABEL_18:
            a4->i64[1] = (uint64_t)v20;
          }
        }
LABEL_109:
        if ((unint64_t)++v11 >= v10) {
          goto LABEL_161;
        }
      }
    }
    int v18 = 0;
    do
    {
LABEL_161:
      unint64_t v104 = CFArrayGetValueAtIndex((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)v15, memory_order_acquire), v17 - 1);
      uint64_t v105 = -[CTFeatureSetting tag]((uint64_t)v104);
      if (!v105) {
        break;
      }
      CFStringRef v106 = (const __CFString *)v105;
      if (-[CTFeatureSetting type]((uint64_t)v104)) {
        break;
      }
      unsigned int v107 = FourCharCodeFromString(v106);
      if (v107)
      {
        unsigned int v108 = v107;
        CFNumberRef v109 = (const __CFNumber *)-[CTFeatureSetting value]((uint64_t)v104);
        LODWORD(valuePtr[0]) = -1431655766;
        CFNumberGetValue(v109, kCFNumberIntType, valuePtr);
        unsigned int v110 = valuePtr[0];
        if (LODWORD(valuePtr[0]))
        {
          uint64_t v112 = (unsigned int *)a4->i64[1];
          unint64_t v111 = a4[1].u64[0];
          if ((unint64_t)v112 >= v111)
          {
            uint64_t v114 = ((uint64_t)v112 - a4->i64[0]) >> 3;
            unint64_t v115 = v114 + 1;
            if ((unint64_t)(v114 + 1) >> 61) {
              goto LABEL_240;
            }
            uint64_t v116 = v111 - a4->i64[0];
            if (v116 >> 2 > v115) {
              unint64_t v115 = v116 >> 2;
            }
            if ((unint64_t)v116 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v117 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v117 = v115;
            }
            v158 = &a4[1].i8[8];
            v118 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&a4[1].i64[1], v117);
            char v119 = (unsigned int *)&v118[8 * v114];
            unsigned int *v119 = v108;
            v119[1] = v110;
            uint64_t v121 = a4->i64[0];
            unint64_t v120 = a4->u64[1];
            if (v120 == a4->i64[0])
            {
              int64x2_t v124 = vdupq_n_s64(v120);
              __int16 v122 = &v118[8 * v114];
              int v15 = v154;
            }
            else
            {
              __int16 v122 = &v118[8 * v114];
              int v15 = v154;
              do
              {
                uint64_t v123 = *(void *)(v120 - 8);
                v120 -= 8;
                *((void *)v122 - 1) = v123;
                v122 -= 8;
              }
              while (v120 != v121);
              int64x2_t v124 = *a4;
            }
            uint64_t v113 = v119 + 2;
            a4->i64[0] = (uint64_t)v122;
            a4->i64[1] = (uint64_t)(v119 + 2);
            *(int64x2_t *)&valuePtr[1] = v124;
            uint64_t v125 = a4[1].i64[0];
            a4[1].i64[0] = (uint64_t)&v118[8 * v117];
            uint64_t v157 = v125;
            valuePtr[0] = (char *)v124.i64[0];
            std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)valuePtr);
          }
          else
          {
            *uint64_t v112 = v108;
            v112[1] = v110;
            uint64_t v113 = v112 + 2;
          }
          a4->i64[1] = (uint64_t)v113;
        }
      }
    }
    while (v17-- > 1);
    a6 = v152;
    if (!v152) {
      goto LABEL_186;
    }
  }
  else
  {
    if (a3)
    {
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB2CE508, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EB2CE508))
      {
        qword_1EB2CE5F0 = 0;
        unk_1EB2CE5F8 = 0;
        qword_1EB2CE600 = 0;
        qword_1EB2CE680 = (uint64_t)algn_1EB2CE608;
        __cxa_guard_release(&qword_1EB2CE508);
      }
      if (qword_1EB2CE510 != -1) {
        dispatch_once_f(&qword_1EB2CE510, 0, (dispatch_function_t)GetDefaultFeatureList<true>(void)::{lambda(void *)#1}::__invoke);
      }
      long long v79 = &qword_1EB2CE5F0;
    }
    else
    {
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB2CE518, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EB2CE518))
      {
        qword_1EB2CE688 = 0;
        unk_1EB2CE690 = 0;
        qword_1EB2CE698 = 0;
        qword_1EB2CE718 = (uint64_t)&unk_1EB2CE6A0;
        __cxa_guard_release(&qword_1EB2CE518);
      }
      if (qword_1EB2CE520 != -1) {
        dispatch_once_f(&qword_1EB2CE520, 0, (dispatch_function_t)GetDefaultFeatureList<false>(void)::{lambda(void *)#1}::__invoke);
      }
      long long v79 = &qword_1EB2CE688;
    }
    if ((unint64_t)v11 >= v10)
    {
      int v18 = 0;
    }
    else
    {
      int v18 = 0;
      do
      {
        long long v81 = (unsigned int *)a4->i64[0];
        long long v80 = (unsigned int *)a4->i64[1];
        unsigned int v82 = *v11;
        if ((unsigned int *)a4->i64[0] != v80)
        {
          while (*v81 != v82)
          {
            v81 += 2;
            if (v81 == v80)
            {
              long long v81 = (unsigned int *)a4->i64[1];
              break;
            }
          }
        }
        uint8x8_t v83 = FindMasterFeatureMapEntry(v82);
        if (v83)
        {
          uint64_t v84 = (unsigned int *)v83;
          __int16 v85 = (unsigned int *)a4->i64[1];
          if (v81 == v85)
          {
            uint64_t v84 = (unsigned int *)*v79;
            long long v86 = (unsigned int *)v79[1];
            if ((unsigned int *)*v79 != v86)
            {
              unsigned int v87 = *v11;
              while (*v84 <= v87)
              {
                BOOL v88 = *v84 != v87 || (v84[2] & 0x44) == 4;
                if (!v88)
                {
                  if (v84 == v86) {
                    break;
                  }
                  float v89 = a6;
                  unint64_t v90 = a4[1].u64[0];
                  if ((unint64_t)v81 >= v90)
                  {
                    uint64_t v92 = ((uint64_t)v85 - a4->i64[0]) >> 3;
                    unint64_t v93 = v92 + 1;
                    if ((unint64_t)(v92 + 1) >> 61) {
LABEL_240:
                    }
                      abort();
                    uint64_t v94 = v90 - a4->i64[0];
                    if (v94 >> 2 > v93) {
                      unint64_t v93 = v94 >> 2;
                    }
                    if ((unint64_t)v94 >= 0x7FFFFFFFFFFFFFF8) {
                      unint64_t v95 = 0x1FFFFFFFFFFFFFFFLL;
                    }
                    else {
                      unint64_t v95 = v93;
                    }
                    v158 = &a4[1].i8[8];
                    uint64_t v96 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&a4[1].i64[1], v95);
                    v97 = &v96[8 * v92];
                    *(_DWORD *)v97 = *v84;
                    *((_DWORD *)v97 + 1) = 1;
                    uint64_t v99 = a4->i64[0];
                    unint64_t v98 = a4->u64[1];
                    if (v98 == a4->i64[0])
                    {
                      int64x2_t v102 = vdupq_n_s64(v98);
                      unint64_t v100 = &v96[8 * v92];
                    }
                    else
                    {
                      unint64_t v100 = &v96[8 * v92];
                      do
                      {
                        uint64_t v101 = *(void *)(v98 - 8);
                        v98 -= 8;
                        *((void *)v100 - 1) = v101;
                        v100 -= 8;
                      }
                      while (v98 != v99);
                      int64x2_t v102 = *a4;
                    }
                    unint64_t v91 = v97 + 8;
                    a4->i64[0] = (uint64_t)v100;
                    a4->i64[1] = (uint64_t)(v97 + 8);
                    *(int64x2_t *)&valuePtr[1] = v102;
                    uint64_t v103 = a4[1].i64[0];
                    a4[1].i64[0] = (uint64_t)&v96[8 * v95];
                    uint64_t v157 = v103;
                    valuePtr[0] = (char *)v102.i64[0];
                    std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)valuePtr);
                  }
                  else
                  {
                    *long long v81 = v87;
                    v81[1] = 1;
                    unint64_t v91 = v81 + 2;
                  }
                  a4->i64[1] = (uint64_t)v91;
                  a6 = v89;
                  goto LABEL_128;
                }
                v84 += 3;
                if (v84 == v86) {
                  break;
                }
              }
            }
          }
          else
          {
LABEL_128:
            v18 |= v84[2] & 0xFFFFFE00;
          }
        }
        ++v11;
      }
      while ((unint64_t)v11 < v10);
    }
    if (!a6) {
      goto LABEL_186;
    }
  }
  if (!*a6)
  {
    LOWORD(v18) = v18 | 0x200;
    if ((v18 & 0x200) == 0) {
      goto LABEL_210;
    }
    goto LABEL_190;
  }
  if ((v18 & 0x4000) != 0)
  {
    *a6 = 2;
    v18 ^= 0x4000u;
  }
LABEL_186:
  if (!v18) {
    return;
  }
  if ((v18 & 0x200) != 0)
  {
LABEL_190:
    v128 = (_DWORD *)a4->i64[0];
    unint64_t v127 = (_DWORD *)a4->i64[1];
    uint64_t v129 = (_DWORD *)a4->i64[0];
    if ((_DWORD *)a4->i64[0] != v127)
    {
      uint64_t v129 = (_DWORD *)a4->i64[0];
      while (*v129 != 1801810542)
      {
        v129 += 2;
        if (v129 == v127) {
          goto LABEL_201;
        }
      }
    }
    if (v129 != v127)
    {
      v130 = v129 + 2;
      if (v129 + 2 == v127)
      {
        unint64_t v127 = v129;
      }
      else
      {
        do
        {
          int v131 = v130[1];
          *(v130 - 2) = *v130;
          *(v130 - 1) = v131;
          v130 += 2;
        }
        while (v130 != v127);
        unint64_t v127 = v130 - 2;
      }
      a4->i64[1] = (uint64_t)v127;
    }
LABEL_201:
    if (v128 != v127)
    {
      while (*v128 != 1986753134)
      {
        v128 += 2;
        if (v128 == v127) {
          goto LABEL_210;
        }
      }
    }
    if (v128 != v127)
    {
      unint64_t v132 = v128 + 2;
      if (v128 + 2 != v127)
      {
        do
        {
          int v133 = v132[1];
          *(v132 - 2) = *v132;
          *(v132 - 1) = v133;
          v132 += 2;
        }
        while (v132 != v127);
        v128 = v132 - 2;
      }
      a4->i64[1] = (uint64_t)v128;
    }
  }
LABEL_210:
  if ((v18 & 0x800) != 0)
  {
    v135 = (_DWORD *)a4->i64[0];
    v134 = (_DWORD *)a4->i64[1];
    if ((_DWORD *)a4->i64[0] != v134)
    {
      while (*v135 != 1885432948)
      {
        v135 += 2;
        if (v135 == v134) {
          goto LABEL_220;
        }
      }
    }
    if (v135 != v134)
    {
      v136 = v135 + 2;
      if (v135 + 2 != v134)
      {
        do
        {
          int v137 = v136[1];
          *(v136 - 2) = *v136;
          *(v136 - 1) = v137;
          v136 += 2;
        }
        while (v136 != v134);
        v135 = v136 - 2;
      }
      a4->i64[1] = (uint64_t)v135;
    }
  }
LABEL_220:
  if ((v18 & 0x2000) != 0)
  {
    v138 = (_DWORD *)a4->i64[0];
    v143 = (_DWORD *)a4->i64[1];
    v140 = &a4->i64[1];
    v142 = v143;
    if (v138 != v143)
    {
      while (*v138 != 1987212338)
      {
        v138 += 2;
        if (v138 == v142) {
          return;
        }
      }
    }
    if (v138 != v142)
    {
      v144 = v138 + 2;
      if (v138 + 2 != v142)
      {
        do
        {
          int v145 = v144[1];
          *(v144 - 2) = *v144;
          *(v144 - 1) = v145;
          v144 += 2;
        }
        while (v144 != v142);
        goto LABEL_237;
      }
LABEL_238:
      uint64_t *v140 = (uint64_t)v138;
    }
  }
  else if ((v18 & 0x1000) != 0)
  {
    v138 = (_DWORD *)a4->i64[0];
    CGSize v141 = (_DWORD *)a4->i64[1];
    v140 = &a4->i64[1];
    v139 = v141;
    if (v138 != v141)
    {
      while (*v138 != 1986359924)
      {
        v138 += 2;
        if (v138 == v139) {
          return;
        }
      }
    }
    if (v138 != v139)
    {
      v144 = v138 + 2;
      if (v138 + 2 != v139)
      {
        do
        {
          int v146 = v144[1];
          *(v144 - 2) = *v144;
          *(v144 - 1) = v146;
          v144 += 2;
        }
        while (v144 != v139);
LABEL_237:
        v138 = v144 - 2;
        goto LABEL_238;
      }
      goto LABEL_238;
    }
  }
}

uint64_t *FindMasterFeatureMapEntry(unsigned int a1)
{
  if (qword_1EB2CE500 != -1) {
    dispatch_once_f(&qword_1EB2CE500, 0, (dispatch_function_t)FindMasterFeatureMapEntry::$_0::__invoke);
  }
  if (result) {
    return (uint64_t *)result[3];
  }
  return result;
}

uint64_t *std::unordered_map<unsigned int,anonymous namespace'::FeatureMapEntry const*>::find[abi:nn180100](uint64_t a1, unint64_t a2, unsigned int a3)
{
  if (!a2) {
    return 0;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a3;
    if (a3 >= a2) {
      unint64_t v4 = a3 % a2;
    }
  }
  else
  {
    unint64_t v4 = (a2 - 1) & a3;
  }
  int v5 = *(uint64_t ***)(a1 + 8 * v4);
  if (!v5) {
    return 0;
  }
  for (uint64_t result = *v5; result; uint64_t result = (uint64_t *)*result)
  {
    unint64_t v7 = result[1];
    if (v7 == a3)
    {
      if (*((_DWORD *)result + 4) == a3) {
        return result;
      }
    }
    else
    {
      if (v3.u32[0] > 1uLL)
      {
        if (v7 >= a2) {
          v7 %= a2;
        }
      }
      else
      {
        v7 &= a2 - 1;
      }
      if (v7 != v4) {
        return 0;
      }
    }
  }
  return result;
}

uint64_t TFontFeatureSettingList::IndexOfAATSetting(TFontFeatureSettingList *this, unsigned __int16 a2, int a3)
{
  unsigned __int16 v10 = a2;
  unint64_t v4 = std::__tree<std::__value_type<unsigned short,AATFeaturePair>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,AATFeaturePair>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,AATFeaturePair>>>::__equal_range_multi<unsigned short>((uint64_t)this + 8, &v10);
  if (v4 == v5) {
    return -1;
  }
  while (*((unsigned __int16 *)v4 + 20) != a3)
  {
    int v6 = (uint64_t *)v4[1];
    if (v6)
    {
      do
      {
        unint64_t v7 = v6;
        int v6 = (uint64_t *)*v6;
      }
      while (v6);
    }
    else
    {
      do
      {
        unint64_t v7 = (uint64_t *)v4[2];
        BOOL v8 = *v7 == (void)v4;
        unint64_t v4 = v7;
      }
      while (!v8);
    }
    unint64_t v4 = v7;
    if (v7 == v5) {
      return -1;
    }
  }
  return v4[6];
}

uint64_t *std::__tree<std::__value_type<unsigned short,AATFeaturePair>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,AATFeaturePair>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,AATFeaturePair>>>::__equal_range_multi<unsigned short>(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t v2 = (uint64_t *)(a1 + 8);
  uint8x8_t v3 = *(uint64_t **)(a1 + 8);
  if (!v3) {
    return v2;
  }
  unsigned int v4 = *a2;
  while (1)
  {
    unsigned int v5 = *((unsigned __int16 *)v3 + 16);
    if (v4 >= v5) {
      break;
    }
    uint64_t v2 = v3;
LABEL_7:
    uint8x8_t v3 = (uint64_t *)*v3;
    if (!v3) {
      return v2;
    }
  }
  if (v5 < v4)
  {
    ++v3;
    goto LABEL_7;
  }
  unint64_t v7 = (uint64_t **)*v3;
  uint64_t result = v3;
  if (*v3)
  {
    uint64_t result = v3;
    do
    {
      unsigned int v8 = *((unsigned __int16 *)v7 + 16);
      BOOL v9 = v8 >= v4;
      if (v8 >= v4) {
        unsigned __int16 v10 = v7;
      }
      else {
        unsigned __int16 v10 = v7 + 1;
      }
      if (v9) {
        uint64_t result = (uint64_t *)v7;
      }
      unint64_t v7 = (uint64_t **)*v10;
    }
    while (*v10);
  }
  uint64_t v11 = v3[1];
  if (v11)
  {
    do
    {
      if (v4 >= *(unsigned __int16 *)(v11 + 32)) {
        unint64_t v12 = (uint64_t *)(v11 + 8);
      }
      else {
        unint64_t v12 = (uint64_t *)v11;
      }
      uint64_t v11 = *v12;
    }
    while (*v12);
  }
  return result;
}

void TTenuousComponentFont::CopyGraphicsFont(atomic_ullong *this@<X0>, void *a2@<X8>)
{
  if (atomic_load_explicit(this + 96, memory_order_acquire) && !*((unsigned char *)this + 792))
  {
    TTenuousComponentFont::InitializeVariationGraphicsFont(this);
    *a2 = (id)atomic_load_explicit(this + 98, memory_order_acquire);
  }
  else
  {
    TBaseFont::CopyNativeFont(this, a2);
  }
}

void TBaseFont::InitAnnexTables(TBaseFont *this)
{
  int v2 = *((_DWORD *)this + 44);
  unsigned int v3 = v2 | 0x2000000;
  if ((*((_DWORD *)this + 45) & 0x20000000) != 0
    || (*((_DWORD *)this + 44) & 0xC0) == 0xC0
    || (CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)&unk_1ED07DE48, (const void *)atomic_load_explicit((atomic_ullong *volatile)this + 12, memory_order_acquire))) == 0)
  {
    ConvertToMorxSync((atomic_uint *)this);
LABEL_15:
    atomic_fetch_or_explicit((atomic_uint *volatile)this + 44, v3, memory_order_relaxed);
    return;
  }
  CFDictionaryRef v5 = Value;
  id v19 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr, TBaseFont *, __CFString *))(*(void *)this + 72))(&v19, this, @"CTFontVersionName");
  if (!atomic_load_explicit((atomic_ullong *volatile)&v19, memory_order_acquire)
    || (v6 = (const __CFDictionary *)CFDictionaryGetValue(v5, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v19, memory_order_acquire))) == 0|| (CFDictionaryRef v7 = v6, (v8 = CFDictionaryGetValue(v6, @"aka")) != 0)&& (CFDictionaryRef v7 = (const __CFDictionary *)CFDictionaryGetValue(v5, v8)) == 0)
  {
    unsigned int v3 = v2 | 0x2004000;
    goto LABEL_13;
  }
  BOOL v9 = CFDictionaryGetValue(v7, @"kerx");
  unsigned __int16 v10 = CFDictionaryGetValue(v7, @"morx");
  if (v9)
  {
    uint64_t v11 = (void *)CFRetain(v9);
    uint64_t v12 = 0;
    atomic_compare_exchange_strong((atomic_ullong *volatile)this + 6, (unint64_t *)&v12, (unint64_t)v11);
    if (v12)
    {

      goto LABEL_19;
    }

    int v13 = 167772160;
  }
  else
  {
    int v13 = 33570816;
  }
  unsigned int v3 = v2 | v13;
LABEL_19:
  CFBooleanRef v14 = (const __CFBoolean *)CFDictionaryGetValue(v7, @"ignoreGDEF");
  if (v14 && CFBooleanGetValue(v14)) {
    v3 |= 0x100u;
  }
  CFBooleanRef v15 = (const __CFBoolean *)CFDictionaryGetValue(v7, @"converted");
  if (!v15 || !CFBooleanGetValue(v15))
  {
    if (v10)
    {
      uint64_t v17 = (void *)CFRetain(v10);
      uint64_t v18 = 0;
      atomic_compare_exchange_strong((atomic_ullong *volatile)this + 8, (unint64_t *)&v18, (unint64_t)v17);
      if (v18)
      {
      }
      else
      {

        v3 |= 0x20000000u;
      }
      goto LABEL_14;
    }
LABEL_13:
    v3 |= 4u;
LABEL_14:

    goto LABEL_15;
  }
  int v16 = CFDictionaryGetValue(v7, @"ltag");
  TBaseFont::SetConvertedTables(this, v10, v16);
  atomic_fetch_or_explicit((atomic_uint *volatile)this + 44, v3, memory_order_relaxed);
}

uint64_t TCFBase<TRunDelegate>::ClassDestruct(uint64_t result)
{
  unint64_t v1 = *(uint64_t (**)(void))(result + 16);
  if (v1) {
    return v1();
  }
  return result;
}

void CTLineDraw(CTLineRef line, CGContextRef context)
{
  if (line)
  {
    if (context) {
      TLine::DrawGlyphs(*((TLine **)line + 5), context);
    }
  }
}

uint64_t OTL::GSUB::ApplyLookups(void *a1, TRunGlue *a2, int a3, unsigned __int16 **a4, unsigned char *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v86 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = (char *)a4[1] - (char *)*a4;
  if (v7)
  {
    unsigned int v8 = a4;
    uint64_t v66 = (unsigned __int8 *)*((void *)a2 + 25);
    unint64_t v12 = *((void *)a2 + 78);
    char v74 = 0;
    unint64_t v13 = v7 / 104;
    unint64_t v14 = (v12 + 7) >> 3;
    *(void *)&long long v15 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v84 = v15;
    long long v85 = v15;
    if (v12 > 0x10000) {
      unint64_t v14 = 0x2000;
    }
    unint64_t v61 = v14;
    long long v83 = v15;
    *((void *)&v84 + 1) = 0;
    v73[0] = a4;
    v73[1] = a6;
    v73[2] = a7;
    uint64_t v75 = (TRunGlue *)&unk_1ED0619D0;
    uint64_t v76 = v73;
    uint64_t v78 = &v75;
    std::__function::__value_func<void ()(CFRange,long)>::swap[abi:nn180100](&v75, &v83);
    std::__function::__value_func<void ()(CFRange,long)>::~__value_func[abi:nn180100](&v75);
    *(void *)&long long v85 = &v74;
    unint64_t v68 = a2;
    *((void *)&v85 + 1) = TRunGlue::length(a2) << 7;
    uint64_t v16 = *(void *)(a1[2] + 400);
    lock = (os_unfair_lock_s *)(v16 + 356);
    os_unfair_lock_lock_with_options();
    BOOL v17 = 0;
    uint64_t v18 = 0;
    uint64_t v59 = v16;
    unint64_t v60 = v13;
    if (v13 <= 1) {
      uint64_t v19 = 1;
    }
    else {
      uint64_t v19 = v13;
    }
    uint64_t v58 = v19;
    uint64_t v64 = v8;
    uint64_t v71 = a1;
    do
    {
      char v62 = v17;
      uint64_t v63 = v18;
      unsigned int v20 = *(_DWORD *)&(*v8)[52 * v18];
      __int16 v72 = 0;
      signed int v21 = TBaseFont::NthLookup<OTL::GSUB>(v16, a1, (unsigned __int16)v20);
      if (v21)
      {
        unsigned int v22 = v21;
        if (!v66 || OTL::CoverageBitmap::CoversBitmap((OTL::CoverageBitmap *)(v21 + 40), v66, v61))
        {
          unsigned int v23 = HIWORD(v20);
          int v24 = *((unsigned __int16 *)v22 + 8);
          int v25 = a3;
          if (v24 == 8) {
            int v25 = -a3;
          }
          unsigned int v67 = v25;
          unint64_t v26 = *v64;
          unsigned int v27 = v64[1];
          if (*v64 != v27)
          {
            while (*v26 != (unsigned __int16)v20 || v26[1] != v23)
            {
              v26 += 52;
              if (v26 == v27)
              {
                unint64_t v26 = v64[1];
                break;
              }
            }
          }
          signed int v30 = (void *)*((void *)v26 + 1);
          uint64_t v29 = (void *)*((void *)v26 + 2);
          unint64_t v65 = v29;
          while (v30 != v29)
          {
            uint64_t v32 = *v30;
            uint64_t v31 = v30[1];
            uint64_t v69 = v30;
            if (v31 < 0) {
              uint64_t v31 = TRunGlue::length(v68) - v32;
            }
            unint64_t v82 = 0xAAAAAAAAAAAAAAAALL;
            *(void *)&long long v33 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v33 + 1) = 0xAAAAAAAAAAAAAAAALL;
            long long v80 = v33;
            long long v81 = v33;
            uint64_t v75 = v68;
            uint64_t v76 = (void *)(v67 | 0xAAAAAAAA00000000);
            int64x2_t v77 = (TRunGlue **)(v32 - 1);
            uint64_t v78 = (TRunGlue **)(v31 + v32);
            uint64_t v79 = -1;
            uint64_t v34 = TRunGlue::length(v68);
            *(void *)&long long v81 = -1;
            *((void *)&v81 + 1) = -1;
            *(void *)&long long v80 = v34;
            unint64_t v82 = 0;
            int v35 = v77;
            if ((v67 & 0x80000000) != 0)
            {
              uint64_t v36 = v79;
              int64x2_t v77 = v78;
              uint64_t v78 = v35;
              uint64_t v79 = v34;
              *(void *)&long long v80 = v36;
              int v35 = v77;
            }
            unint64_t v37 = *((void *)v22 + 3);
            *((void *)&v80 + 1) = v35;
            unint64_t v82 = v37;
            if (TGlyphIterator::NextCoveredBy((TGlyphIterator *)&v75, (const OTL::Lookup *)v22))
            {
              while (1)
              {
                unsigned int v38 = -1431655765 * ((*((_DWORD *)v22 + 24) - *((_DWORD *)v22 + 22)) >> 4);
                uint64_t v39 = *((void *)&v80 + 1);
                uint64_t GlyphID = TRunGlue::GetGlyphID(v75, *((uint64_t *)&v80 + 1));
                uint64_t v41 = (unsigned __int16)v38;
                if ((_WORD)v38)
                {
                  uint64_t v42 = GlyphID;
                  uint64_t v43 = 0;
                  unint64_t v44 = 0;
                  uint64_t v45 = 48 * v41;
                  do
                  {
                    *((void *)&v80 + 1) = v39;
                    uint64_t v46 = *((void *)v22 + 11);
                    if (0xAAAAAAAAAAAAAAABLL * ((*((void *)v22 + 12) - v46) >> 4) <= v44) {
                      break;
                    }
                    uint64_t v47 = v46 + v43;
                    uint64_t v48 = *(uint64_t (**)(void *, uint64_t))(v46 + v43 + 24);
                    uint64_t v49 = *(void *)(v47 + 32);
                    int v50 = (void *)(v47 + (v49 >> 1) + 8);
                    if (v49) {
                      uint64_t v48 = *(uint64_t (**)(void *, uint64_t))(*v50 + v48);
                    }
                    unsigned int v51 = v48(v50, v42);
                    if (v51)
                    {
                      uint64_t v52 = *((void *)v22 + 11);
                      unsigned int v53 = 0xAAAAAAAAAAAAAAABLL * ((*((void *)v22 + 12) - v52) >> 4) <= v44
                          ? 0
                          : *(unsigned __int16 **)(v52 + v43);
                      char v54 = 1;
                      if (OTL::GSUB::ApplyLookupSubtable(v71, (int)v22, v24, v53, (TGlyphIterator *)&v75, v51, v23, &v72, (uint64_t)&v83, 1uLL))goto LABEL_39; {
                    }
                      }
                    ++v44;
                    v43 += 48;
                  }
                  while (v45 != v43);
                  char v54 = 0;
LABEL_39:
                  *a5 |= v54;
                }
                if (v74) {
                  break;
                }
                if ((TGlyphIterator::NextCoveredBy((TGlyphIterator *)&v75, (const OTL::Lookup *)v22) & 1) == 0) {
                  goto LABEL_42;
                }
              }
              char v55 = v62;
              goto LABEL_46;
            }
LABEL_42:
            signed int v30 = v69 + 2;
            uint64_t v29 = v65;
          }
        }
      }
      unsigned int v8 = v64;
      uint64_t v18 = v63 + 1;
      uint64_t v16 = v59;
      BOOL v17 = v63 + 1 >= v60;
      a1 = v71;
    }
    while (v63 + 1 != v58);
    char v55 = 1;
LABEL_46:
    os_unfair_lock_unlock(lock);
    std::__function::__value_func<void ()(CFRange,long)>::~__value_func[abi:nn180100](&v83);
  }
  else
  {
    char v55 = 1;
  }
  return v55 & 1;
}

BOOL OTL::CoverageBitmap::CoversBitmap(OTL::CoverageBitmap *this, const unsigned __int8 *a2, unint64_t a3)
{
  uint64_t v3 = *(unsigned int *)this;
  if (!v3) {
    return 0;
  }
  unint64_t v4 = *((unsigned __int16 *)this + 2);
  if (a3 <= v4 >> 3) {
    return 0;
  }
  unint64_t v5 = v4 >> 3;
  if (v3 == 1) {
    return (a2[v5] >> (v4 & 7)) & 1;
  }
  unint64_t v7 = a3 - v5;
  unint64_t v8 = (unint64_t)(v3 + 7) >> 3;
  BOOL v9 = v3 > 0x10000;
  unint64_t v10 = 0x2000;
  if (!v9) {
    unint64_t v10 = v8;
  }
  if (v10 < v7) {
    unint64_t v7 = v10;
  }
  if (!v7) {
    return 0;
  }
  uint64_t v11 = (unsigned __int8 *)*((void *)this + 5);
  unint64_t v12 = &a2[v5];
  unint64_t v13 = v7 - 1;
  do
  {
    int v15 = *v11++;
    int v14 = v15;
    int v16 = *v12++;
    int v17 = v16 & v14;
    BOOL result = v17 != 0;
    if (v17) {
      BOOL v18 = 1;
    }
    else {
      BOOL v18 = v13 == 0;
    }
    --v13;
  }
  while (!v18);
  return result;
}

uint64_t OTL::GSUB::ApplyLookupSubtable(void *a1, int a2, int a3, unsigned __int16 *a4, TGlyphIterator *this, unsigned int a6, unsigned int a7, _WORD *a8, uint64_t a9, unint64_t a10)
{
  uint64_t v10 = 0;
  switch(a3)
  {
    case 1:
      return OTL::GSUB::ApplySingleSubst((uint64_t)a1, a4, (uint64_t)this, a6, a9);
    case 2:
      if (*a4 != 256
        || !OTL::GSUB::ApplyMultipleSubst((uint64_t)a1, (uint64_t)a4, (uint64_t *)this, a6, a8, a9))
      {
        goto LABEL_33;
      }
      uint64_t v13 = TRunGlue::length(*(TRunGlue **)this);
      uint64_t v10 = 1;
      if (v13 > *(void *)(a9 + 40)) {
        **(unsigned char **)(a9 + 32) = 1;
      }
      goto LABEL_34;
    case 3:
      if (*a4 != 256) {
        goto LABEL_33;
      }
      return OTL::GSUB::ApplyAlternateSubst((uint64_t)a1, (uint64_t)a4, (uint64_t)this, a6, a7, a9);
    case 4:
      if (*a4 != 256) {
        goto LABEL_33;
      }
      return OTL::GSUB::ApplyLigatureSubst((uint64_t)a1, (uint64_t)a4, this, a6, a8, a9);
    case 5:
      unsigned int v14 = bswap32(*a4) >> 16;
      switch(v14)
      {
        case 3u:
          uint64_t result = OTL::GSUB::ApplyContextSubstFormat3(a1, (unint64_t)a4, (uint64_t)this, a8, a9, a10);
          break;
        case 2u:
          uint64_t result = (uint64_t)OTL::GSUB::ApplyContextSubstFormat2(a1, a4, (uint64_t)this, a8, a9, a10);
          break;
        case 1u:
          uint64_t result = OTL::GSUB::ApplyContextSubstFormat1(a1, (ContextSubstFormat1 *)a4, (uint64_t)this, a6, a8, a9, a10);
          break;
        default:
          goto LABEL_33;
      }
      break;
    case 6:
      unsigned int v15 = bswap32(*a4) >> 16;
      switch(v15)
      {
        case 3u:
          uint64_t result = OTL::GSUB::ApplyChainContextSubstFormat3(a1, (unint64_t)a4, (uint64_t)this, a8, a9, a10);
          break;
        case 2u:
          uint64_t result = (uint64_t)OTL::GSUB::ApplyChainContextSubstFormat2(a1, a4, (uint64_t)this, a8, a9, a10);
          break;
        case 1u:
          uint64_t result = OTL::GSUB::ApplyChainContextSubstFormat1(a1, (ChainContextSubstFormat1 *)a4, (uint64_t)this, a6, a8, a9, a10);
          break;
        default:
LABEL_33:
          uint64_t v10 = 0;
LABEL_34:
          uint64_t result = v10;
          break;
      }
      break;
    case 8:
      if (*a4 != 256) {
        goto LABEL_33;
      }
      return OTL::GSUB::ApplyReverseChainSingleSubst((uint64_t)a1, (unint64_t)a4, (uint64_t)this, a6, a9);
    default:
      goto LABEL_34;
  }
  return result;
}

uint64_t OTL::GSUB::ApplyLigatureSubst(uint64_t a1, uint64_t a2, TGlyphIterator *this, unsigned int a4, _WORD *a5, uint64_t a6)
{
  v74[31] = *MEMORY[0x1E4F143B8];
  unint64_t v6 = *(void *)(a1 + 40);
  unint64_t v7 = (unsigned __int16 *)(a2 + 4);
  unint64_t v8 = a2 + 6;
  if ((unint64_t)(a2 + 4) < *(void *)(a1 + 32) || v8 > v6) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v14 = bswap32(*(unsigned __int16 *)(a2 + 4)) >> 16;
  BOOL v15 = __CFADD__(v8, 2 * v14);
  char v16 = v8 + 2 * v14 > v6 || v15;
  if (a2 + 8 <= v6) {
    unint64_t v17 = (v6 - v8) >> 1;
  }
  else {
    unint64_t v17 = 0;
  }
  if (v17 == v14) {
    char v16 = 0;
  }
  if (v14 >= a4 && (v16 & 1) == 0)
  {
    unsigned int v20 = this;
    uint64_t v66 = a1;
    uint64_t v21 = *((void *)this + 6);
    uint64_t v69 = v21;
    if (TGlyphIterator::Next(this, 1))
    {
      uint64_t v68 = *((void *)v20 + 6);
      uint64_t v69 = v68;
      int GlyphID = TRunGlue::GetGlyphID(*(TRunGlue **)v20, v68);
    }
    else
    {
      int GlyphID = 0xFFFF;
      uint64_t v68 = v21;
    }
    uint64_t v23 = v21;
    unsigned int v24 = a4 - 1;
    uint64_t v25 = bswap32(*v7) >> 16;
    unint64_t v26 = v8 + 2 * v25;
    uint64_t v67 = a6;
    unint64_t v65 = a5;
    if (v26 < v8 || v26 > v6)
    {
      char v27 = 0;
      if (v17 != v25 || v24 >= v25) {
        goto LABEL_43;
      }
    }
    else if (v24 >= v25)
    {
LABEL_42:
      char v27 = 0;
LABEL_43:
      *((void *)v20 + 6) = v23;
      return v27 & 1;
    }
    int v28 = (unsigned __int16 *)(a2 + (bswap32(*(unsigned __int16 *)(a2 + 2 * v24 + 6)) >> 16));
    uint64_t v29 = v28 + 1;
    if ((unint64_t)(v28 + 1) > v6) {
      goto LABEL_42;
    }
    unsigned int v30 = *v28;
    uint64_t v31 = __rev16(v30);
    unint64_t v32 = (unint64_t)&v29[v31];
    unint64_t v33 = (unint64_t)(v28 + 2) <= v6 ? (v6 - (unint64_t)v29) >> 1 : 0;
    BOOL v34 = v32 <= v6 && v32 >= (unint64_t)v29;
    BOOL v35 = v34 || v33 == v31;
    if (!v35 || v30 == 0) {
      goto LABEL_42;
    }
    unint64_t v37 = 0;
    char v27 = 0;
    unsigned int v38 = v74;
    uint64_t v39 = v31 - 1;
    *(void *)&long long v40 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v40 + 1) = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v41 = v68;
    uint64_t v42 = v68;
    while (1)
    {
      unint64_t v43 = bswap32(*v28) >> 16;
      unint64_t v44 = (unint64_t)&v29[v43];
      if (v44 < (unint64_t)v29 || v44 > v6)
      {
        if (v33 != v43 || v37 >= v43) {
          goto LABEL_43;
        }
      }
      else if (v37 >= v43)
      {
        goto LABEL_43;
      }
      uint64_t v47 = (unsigned __int16 *)((char *)v28 + (bswap32(v29[v37]) >> 16));
      uint64_t v48 = v47 + 2;
      if ((unint64_t)(v47 + 2) > v6) {
        goto LABEL_43;
      }
      uint64_t v49 = bswap32(v47[1]) >> 16;
      int v50 = &v48[v49 - 1];
      unint64_t v51 = (v6 - (unint64_t)v48) >> 1;
      if ((unint64_t)(v47 + 3) > v6) {
        unint64_t v51 = 0;
      }
      BOOL v52 = (unint64_t)v50 <= v6 && v50 >= v48;
      if (!v52 && v51 != v49 - 1) {
        goto LABEL_43;
      }
      if (!v49) {
        goto LABEL_83;
      }
      if (v49 == 2) {
        break;
      }
      uint64_t v54 = (v49 - 1);
      if (v49 == 1)
      {
        uint64_t v57 = v23;
        TGlyphIterator::DoLigature((TRunGlue **)v20, v23, bswap32(*v47) >> 16, 0, 0, *(const OTL::GDEF **)(v66 + 24));
        char v27 = 1;
        std::function<void ()(CFRange,long)>::operator()(v67, v57, 1, 1);
        uint64_t v23 = v57;
        goto LABEL_43;
      }
      if (v42 == v23)
      {
        uint64_t v42 = v23;
LABEL_74:
        uint64_t v41 = v23;
        if (v27) {
          goto LABEL_43;
        }
        goto LABEL_84;
      }
      if (GlyphID == bswap32(*v48) >> 16)
      {
        uint64_t v59 = v39;
        unint64_t v60 = v38;
        unint64_t v61 = v33;
        int v62 = GlyphID;
        uint64_t v63 = v23;
        v38[13] = v40;
        v38[14] = v40;
        v38[11] = v40;
        v38[12] = v40;
        v38[9] = v40;
        v38[10] = v40;
        v38[7] = v40;
        v38[8] = v40;
        v38[5] = v40;
        v38[6] = v40;
        v38[3] = v40;
        v38[4] = v40;
        v38[1] = v40;
        v38[2] = v40;
        *unsigned int v38 = v40;
        uint64_t v71 = 0;
        __int16 v72 = 0;
        uint64_t v73 = 0;
        v74[30] = v38;
        std::vector<long,TInlineBufferAllocator<long,30ul>>::__vallocate[abi:nn180100](&v71, (v49 - 1));
        uint64_t v64 = (TRunGlue **)v20;
        char v55 = (char *)v72;
        bzero(v72, 8 * v54);
        unint64_t v56 = &v55[8 * v54];
        unsigned int v20 = (TGlyphIterator *)v64;
        __int16 v72 = v56;
        *uint64_t v71 = v68;
        if (TGlyphIterator::Next((TGlyphIterator *)v64, 1))
        {
          unsigned int v20 = (TGlyphIterator *)v64;
          if (&v48[v54] == EqualSequenceAndNote<BigEndianScalar<unsigned short>>(v47 + 3, &v48[v54], (uint64_t *)v64, v71 + 1))
          {
            TGlyphIterator::DoLigature(v64, v63, bswap32(*v47) >> 16, v71, v54, *(const OTL::GDEF **)(v66 + 24));
            char v27 = 1;
            std::function<void ()(CFRange,long)>::operator()(v67, v63, 1, 1);
            *v65 += v54;
          }
        }
        *((void *)v20 + 6) = v68;
        uint64_t v70 = (void **)&v71;
        std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](&v70);
        uint64_t v42 = v68;
        uint64_t v41 = v68;
        uint64_t v23 = v63;
        int GlyphID = v62;
        unsigned int v38 = v60;
        unint64_t v33 = v61;
        uint64_t v39 = v59;
        *(void *)&long long v40 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v40 + 1) = 0xAAAAAAAAAAAAAAAALL;
        if (v27) {
          goto LABEL_43;
        }
      }
      else
      {
        uint64_t v41 = v42;
        if (v27) {
          goto LABEL_43;
        }
      }
LABEL_84:
      BOOL v35 = v39 == v37++;
      if (v35) {
        goto LABEL_43;
      }
    }
    if (v41 != v23)
    {
      if (GlyphID == bswap32(*v48) >> 16)
      {
        char v27 = 1;
        uint64_t v58 = v23;
        TGlyphIterator::DoLigature((TRunGlue **)v20, v23, bswap32(*v47) >> 16, &v69, 1, *(const OTL::GDEF **)(v66 + 24));
        std::function<void ()(CFRange,long)>::operator()(v67, v58, 1, 1);
        uint64_t v23 = v58;
        ++*v65;
        goto LABEL_43;
      }
LABEL_83:
      if (v27) {
        goto LABEL_43;
      }
      goto LABEL_84;
    }
    goto LABEL_74;
  }
  return result;
}

void *std::__function::__value_func<void ()(CFRange,long)>::~__value_func[abi:nn180100](void *a1)
{
  int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t TOpenTypePositioningEngine::PositionRuns(uint64_t a1, unsigned char *a2, int *a3)
{
  uint64_t v3 = (void **)a1;
  uint64_t v199 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(*(void *)a1 + 112);
  *(void *)(*(void *)a1 + 112) = a1 + 224;
  long long v168 = 0u;
  long long v169 = 0u;
  *(_OWORD *)__dst = 0u;
  long long v167 = 0u;
  if (!*(unsigned char *)(a1 + 208))
  {
    if ((*(_DWORD *)(a1 + 24) | 0x20) == 0x22)
    {
      *(void *)&v173[0] = 0xAAAAAAAAAAAAAA00;
      uint64_t v10 = *(void *)(a1 + 216);
      uint64_t v11 = *(void **)a1;
      v171.i64[0] = (uint64_t)&unk_1ED05F298;
      v171.i64[1] = v10;
      unint64_t v172 = (unint64_t)v11;
      if (v10) {
        off_1ED05F2A8((JoiningScriptShapingEngine *)&v171);
      }
      uint64_t v12 = 1;
      *a2 = 1;
      goto LABEL_233;
    }
    goto LABEL_28;
  }
  int v6 = *(_DWORD *)(a1 + 192);
  int v8 = *(_DWORD *)(a1 + 24);
  unsigned int v7 = *(_DWORD *)(a1 + 28);
  if (v6 == v7)
  {
    int v9 = 0;
    switch(v8)
    {
      case 2:
      case 34:
      case 38:
        int v9 = 2;
        goto LABEL_15;
      case 4:
      case 10:
      case 15:
      case 16:
      case 21:
      case 23:
      case 26:
      case 31:
      case 35:
      case 36:
        int v9 = 0;
        *(void *)__dst = 0x626C776D6162766DLL;
        goto LABEL_15;
      case 18:
        goto LABEL_15;
      case 28:
        *(void *)__dst = 0x626C776D6162766DLL;
        goto LABEL_107;
      default:
        break;
    }
  }
  *(void *)__dst = 0x626C776D6162766DLL;
  int v9 = 2;
  if (v8 == -1 || v8 == 25)
  {
LABEL_15:
    uint64_t v13 = (uint64_t)(v3 + 5);
  }
  else
  {
    FirstBlockForScript(0, v7, (uint64_t)&v171);
    if (v171.i64[0])
    {
      if (!*((unsigned char *)v3 + 208)) {
        goto LABEL_245;
      }
LABEL_107:
      uint64_t v13 = (uint64_t)(v3 + 5);
      if (v3[5]) {
        *a2 |= ZeroMarkWidths((TRunGlue *)*v3, (uint64_t)(v3 + 5));
      }
      int v9 = 1;
    }
    else
    {
      if (!*((unsigned char *)v3 + 208))
      {
LABEL_245:
        std::__throw_bad_optional_access[abi:nn180100]();
LABEL_246:
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v13 = (uint64_t)(v3 + 5);
      int v9 = 2;
    }
  }
  if (!v3[21] || (uint64_t v14 = v3[22]) == 0 || !*v14)
  {
    if (v9 == 2)
    {
      int v24 = *((_DWORD *)v3 + 6);
      if (v24 == 19 || v24 == 2)
      {
        char v25 = ZeroCombiningMarkWidths((TRunGlue *)*v3);
      }
      else
      {
        if (TBaseFont::GetCommonTable((TBaseFont *)v3[1][50], 1801810542, 0)) {
          goto LABEL_28;
        }
        char v25 = ZeroMarkWidths((TRunGlue *)*v3, v13);
      }
      *a2 |= v25;
      *a3 = 2;
    }
LABEL_28:
    uint64_t v12 = 1;
    goto LABEL_233;
  }
  int v148 = v9;
  uint64_t v147 = v13;
  uint64_t v149 = v4;
  BOOL v15 = (OTL::GPOS *)(v3 + 15);
  *(void *)&long long v16 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v179[6] = v16;
  v179[5] = v16;
  v179[4] = v16;
  v179[3] = v16;
  v179[2] = v16;
  v179[1] = v16;
  v179[0] = v16;
  unint64_t v180 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v178 = 0;
  v176 = 0;
  v177 = 0;
  v181 = v179;
  unint64_t v17 = v3[1];
  unint64_t v18 = (*((unsigned int *)v3 + 8)
       + ((*((int *)v3 + 6) + 2654435769) << 6)
       + ((unint64_t)(*((int *)v3 + 6) + 2654435769) >> 2)
       + 2654435769u) ^ (*((int *)v3 + 6) + 2654435769);
  unint64_t v19 = (*a3 + (v18 << 6) + (v18 >> 2) + 2654435769u) ^ v18;
  unint64_t v20 = (unint64_t)(v17 + 25);
  os_unfair_lock_lock_with_options();
  int8x8_t v21 = (int8x8_t)v17[32];
  int v150 = v3;
  if (v21)
  {
    uint8x8_t v22 = (uint8x8_t)vcnt_s8(v21);
    v22.i16[0] = vaddlv_u8(v22);
    if (v22.u32[0] > 1uLL)
    {
      unint64_t v23 = v19;
      if (*(void *)&v21 <= v19) {
        unint64_t v23 = v19 % *(void *)&v21;
      }
    }
    else
    {
      unint64_t v23 = v19 & (*(void *)&v21 - 1);
    }
    unint64_t v26 = *(uint64_t ***)(v17[31] + 8 * v23);
    if (v26)
    {
      for (uint64_t i = *v26; i; uint64_t i = (uint64_t *)*i)
      {
        unint64_t v28 = i[1];
        if (v28 == v19)
        {
          if (i[2] == v19)
          {
            std::vector<std::pair<unsigned short,unsigned short>,TInlineBufferAllocator<std::pair<unsigned short,unsigned short>,30ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<std::pair<unsigned short,unsigned short>*>,std::__wrap_iter<std::pair<unsigned short,unsigned short>*>>((char *)&v176, (int *)i[3], (int *)i[4], (i[4] - i[3]) >> 2);
            *a3 = *((_DWORD *)i + 44);
            goto LABEL_141;
          }
        }
        else
        {
          if (v22.u32[0] > 1uLL)
          {
            if (v28 >= *(void *)&v21) {
              v28 %= *(void *)&v21;
            }
          }
          else
          {
            v28 &= *(void *)&v21 - 1;
          }
          if (v28 != v23) {
            break;
          }
        }
      }
    }
  }
  v163 = a3;
  *(void *)&long long v29 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v29 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v197 = v29;
  long long v196 = v29;
  long long v195 = v29;
  long long v194 = v29;
  long long v193 = v29;
  long long v192 = v29;
  long long v191 = v29;
  long long v190 = v29;
  long long v189 = v29;
  v186 = 0;
  unint64_t v187 = 0;
  uint64_t v188 = 0;
  v198 = &v189;
  OTL::GCommon::GetFeatures((OTL::GCommon *)(v3 + 15), (OTL::FeatureList *)&v186);
  *(void *)&long long v30 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v30 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v173[14] = v30;
  v173[13] = v30;
  v173[12] = v30;
  v173[11] = v30;
  v173[10] = v30;
  v173[9] = v30;
  v173[8] = v30;
  v173[7] = v30;
  v173[6] = v30;
  v173[5] = v30;
  v173[4] = v30;
  v173[3] = v30;
  v173[2] = v30;
  v173[1] = v30;
  v173[0] = v30;
  unint64_t v172 = 0;
  int64x2_t v171 = 0uLL;
  *(void *)&v173[15] = v173;
  if (OTL::FeatureList::StripMissingFeaturesFrom((unsigned int **)&v186, __dst))
  {
    for (uint64_t j = 0; j != 16; ++j)
    {
      unsigned int v32 = __dst[j];
      if (!v32) {
        break;
      }
      uint64_t v33 = v171.i64[1];
      if (v171.i64[1] >= v172)
      {
        uint64_t v35 = (v171.i64[1] - v171.i64[0]) >> 3;
        unint64_t v36 = v35 + 1;
        if ((unint64_t)(v35 + 1) >> 61) {
          abort();
        }
        uint64_t v37 = v172 - v171.i64[0];
        if ((uint64_t)(v172 - v171.i64[0]) >> 2 > v36) {
          unint64_t v36 = v37 >> 2;
        }
        unint64_t v38 = (unint64_t)v37 >= 0x7FFFFFFFFFFFFFF8 ? 0x1FFFFFFFFFFFFFFFLL : v36;
        v184[1] = v173;
        uint64_t v39 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v173, v38);
        long long v40 = (unsigned int *)&v39[8 * v35];
        *long long v40 = v32;
        v40[1] = 1;
        uint64_t v41 = v171.i64[1];
        uint64_t v42 = v171.i64[0];
        if (v171.i64[1] == v171.i64[0])
        {
          int64x2_t v45 = vdupq_n_s64(v171.u64[1]);
          uint64_t v43 = (uint64_t)&v39[8 * v35];
        }
        else
        {
          uint64_t v43 = (uint64_t)&v39[8 * v35];
          do
          {
            uint64_t v44 = *(void *)(v41 - 8);
            v41 -= 8;
            *(void *)(v43 - 8) = v44;
            v43 -= 8;
          }
          while (v41 != v42);
          int64x2_t v45 = v171;
        }
        uint64_t v34 = (uint64_t)(v40 + 2);
        v171.i64[0] = v43;
        v171.i64[1] = (uint64_t)(v40 + 2);
        int64x2_t v183 = v45;
        unint64_t v46 = v172;
        unint64_t v172 = (unint64_t)&v39[8 * v38];
        v184[0] = v46;
        v182 = (int64x2_t *)v45.i64[0];
        std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v182);
      }
      else
      {
        *(_DWORD *)v171.i64[1] = v32;
        *(_DWORD *)(v33 + 4) = 1;
        uint64_t v34 = v33 + 8;
      }
      v171.i64[1] = v34;
    }
  }
  ConvertSettingsToOTFeatures((unsigned int **)&v186, v17 + 21, *((unsigned __int8 *)v3 + 20), &v171, 0, v163, 1);
  OTL::GCommon::GetLookups((uint64_t)v15, (uint64_t)&v171, (uint64_t)&v176, 1);
  v182 = 0;
  int64x2_t v183 = 0uLL;
  v184[15] = v184;
  std::vector<std::pair<unsigned short,unsigned short>,TInlineBufferAllocator<std::pair<unsigned short,unsigned short>,30ul>>::__init_with_size[abi:nn180100]<std::__wrap_iter<std::pair<unsigned short,unsigned short> const*>,std::__wrap_iter<std::pair<unsigned short,unsigned short> const*>>((char *)&v182, v176, v177, v177 - v176);
  int v185 = *v163;
  unint64_t v47 = v17[32];
  if (v47)
  {
    uint8x8_t v48 = (uint8x8_t)vcnt_s8((int8x8_t)v47);
    v48.i16[0] = vaddlv_u8(v48);
    if (v48.u32[0] > 1uLL)
    {
      unint64_t v49 = v19;
      if (v47 <= v19) {
        unint64_t v49 = v19 % v47;
      }
    }
    else
    {
      unint64_t v49 = (v47 - 1) & v19;
    }
    int v50 = *(void **)(v17[31] + 8 * v49);
    if (v50)
    {
      for (k = (void *)*v50; k; k = (void *)*k)
      {
        unint64_t v52 = k[1];
        if (v52 == v19)
        {
          if (k[2] == v19) {
            goto LABEL_140;
          }
        }
        else
        {
          if (v48.u32[0] > 1uLL)
          {
            if (v52 >= v47) {
              v52 %= v47;
            }
          }
          else
          {
            v52 &= v47 - 1;
          }
          if (v52 != v49) {
            break;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v49 = 0xAAAAAAAAAAAAAAAALL;
  }
  unsigned int v53 = (char *)operator new(0xB8uLL);
  *(void *)unsigned int v53 = 0;
  *((void *)v53 + 1) = v19;
  *((void *)v53 + 2) = v19;
  uint64_t v54 = (int *)v182;
  char v55 = (int *)v183.i64[0];
  *((void *)v53 + 4) = 0;
  *((void *)v53 + 5) = 0;
  *((void *)v53 + 3) = 0;
  *((void *)v53 + 21) = v53 + 48;
  std::vector<std::pair<unsigned short,unsigned short>,TInlineBufferAllocator<std::pair<unsigned short,unsigned short>,30ul>>::__init_with_size[abi:nn180100]<std::__wrap_iter<std::pair<unsigned short,unsigned short> const*>,std::__wrap_iter<std::pair<unsigned short,unsigned short> const*>>(v53 + 24, v54, v55, v55 - v54);
  *((_DWORD *)v53 + 44) = v185;
  float v56 = (float)(unint64_t)(v17[34] + 1);
  float v57 = *((float *)v17 + 70);
  if (!v47 || (float)(v57 * (float)v47) < v56)
  {
    BOOL v58 = 1;
    if (v47 >= 3) {
      BOOL v58 = (v47 & (v47 - 1)) != 0;
    }
    unint64_t v59 = v58 | (2 * v47);
    unint64_t v60 = vcvtps_u32_f32(v56 / v57);
    if (v59 <= v60) {
      int8x8_t prime = (int8x8_t)v60;
    }
    else {
      int8x8_t prime = (int8x8_t)v59;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    }
    unint64_t v47 = v17[32];
    if (*(void *)&prime > v47) {
      goto LABEL_91;
    }
    if (*(void *)&prime < v47)
    {
      unint64_t v68 = vcvtps_u32_f32((float)(unint64_t)v17[34] / *((float *)v17 + 70));
      if (v47 < 3 || (uint8x8_t v69 = (uint8x8_t)vcnt_s8((int8x8_t)v47), v69.i16[0] = vaddlv_u8(v69), v69.u32[0] > 1uLL))
      {
        unint64_t v68 = std::__next_prime(v68);
      }
      else
      {
        uint64_t v70 = 1 << -(char)__clz(v68 - 1);
        if (v68 >= 2) {
          unint64_t v68 = v70;
        }
      }
      if (*(void *)&prime <= v68) {
        int8x8_t prime = (int8x8_t)v68;
      }
      if (*(void *)&prime >= v47)
      {
        unint64_t v47 = v17[32];
      }
      else
      {
        if (prime)
        {
LABEL_91:
          if (*(void *)&prime >> 61) {
            goto LABEL_246;
          }
          int v62 = operator new(8 * *(void *)&prime);
          uint64_t v63 = (void *)v17[31];
          v17[31] = v62;
          if (v63) {
            operator delete(v63);
          }
          uint64_t v64 = 0;
          v17[32] = prime;
          do
            *(void *)(v17[31] + 8 * v64++) = 0;
          while (*(void *)&prime != v64);
          unint64_t v65 = (void *)v17[33];
          if (v65)
          {
            unint64_t v66 = v65[1];
            uint8x8_t v67 = (uint8x8_t)vcnt_s8(prime);
            v67.i16[0] = vaddlv_u8(v67);
            if (v67.u32[0] > 1uLL)
            {
              if (v66 >= *(void *)&prime) {
                v66 %= *(void *)&prime;
              }
            }
            else
            {
              v66 &= *(void *)&prime - 1;
            }
            *(void *)(v17[31] + 8 * v66) = v17 + 33;
            uint64_t v71 = (void *)*v65;
            if (*v65)
            {
              do
              {
                unint64_t v72 = v71[1];
                if (v67.u32[0] > 1uLL)
                {
                  if (v72 >= *(void *)&prime) {
                    v72 %= *(void *)&prime;
                  }
                }
                else
                {
                  v72 &= *(void *)&prime - 1;
                }
                if (v72 != v66)
                {
                  uint64_t v73 = v17[31];
                  if (!*(void *)(v73 + 8 * v72))
                  {
                    *(void *)(v73 + 8 * v72) = v65;
                    goto LABEL_121;
                  }
                  *unint64_t v65 = *v71;
                  *uint64_t v71 = **(void **)(v17[31] + 8 * v72);
                  **(void **)(v17[31] + 8 * v72) = v71;
                  uint64_t v71 = v65;
                }
                unint64_t v72 = v66;
LABEL_121:
                unint64_t v65 = v71;
                uint64_t v71 = (void *)*v71;
                unint64_t v66 = v72;
              }
              while (v71);
            }
          }
          unint64_t v47 = (unint64_t)prime;
          goto LABEL_125;
        }
        int v146 = (void *)v17[31];
        v17[31] = 0;
        if (v146) {
          operator delete(v146);
        }
        unint64_t v47 = 0;
        v17[32] = 0;
      }
    }
LABEL_125:
    if ((v47 & (v47 - 1)) != 0)
    {
      if (v47 <= v19) {
        unint64_t v49 = v19 % v47;
      }
      else {
        unint64_t v49 = v19;
      }
    }
    else
    {
      unint64_t v49 = (v47 - 1) & v19;
    }
  }
  uint64_t v74 = v17[31];
  uint64_t v75 = *(void **)(v74 + 8 * v49);
  if (v75)
  {
    *(void *)unsigned int v53 = *v75;
LABEL_138:
    *uint64_t v75 = v53;
    goto LABEL_139;
  }
  *(void *)unsigned int v53 = v17[33];
  v17[33] = v53;
  *(void *)(v74 + 8 * v49) = v17 + 33;
  if (*(void *)v53)
  {
    unint64_t v76 = *(void *)(*(void *)v53 + 8);
    if ((v47 & (v47 - 1)) != 0)
    {
      if (v76 >= v47) {
        v76 %= v47;
      }
    }
    else
    {
      v76 &= v47 - 1;
    }
    uint64_t v75 = (void *)(v17[31] + 8 * v76);
    goto LABEL_138;
  }
LABEL_139:
  ++v17[34];
LABEL_140:
  v170 = &v182;
  std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v170);
  v182 = &v171;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v182);
  v171.i64[0] = (uint64_t)&v186;
  std::vector<unsigned int,TInlineBufferAllocator<unsigned int,36ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v171);
  unint64_t v20 = (unint64_t)(v17 + 25);
LABEL_141:
  int64x2_t v77 = v176;
  uint64_t v78 = v177;
  os_unfair_lock_unlock((os_unfair_lock_t)v20);
  if (v77 == v78)
  {
    uint64_t v12 = 1;
    uint64_t v4 = v149;
  }
  else
  {
    LOWORD(v182) = -21846;
    LOWORD(v182) = *(_WORD *)(v3[1][50] + 440);
    if ((unsigned __int16)v182 == 0xFFFF)
    {
      uint64_t v79 = v3[22];
      unint64_t v80 = (unint64_t)v3[19];
      unint64_t v81 = (unint64_t)v3[20];
      v175[0] = &unk_1ED0612C8;
      v175[1] = &v182;
      v175[3] = v175;
      OTL::GCommon::IterateFeatureTables(v80, v79, v81, (uint64_t)v175);
      std::__function::__value_func<BOOL ()(unsigned int,OTL::FeatureTable const*,BOOL &)>::~__value_func[abi:nn180100](v175);
      __int16 v82 = (__int16)v182;
      if ((unsigned __int16)v182 == 0xFFFF)
      {
        __int16 v82 = 0;
        LOWORD(v182) = 0;
      }
      *(_WORD *)(v3[1][50] + 440) = v82;
    }
    memset(v173, 170, sizeof(v173));
    int64x2_t v171 = 0uLL;
    unint64_t v172 = 0;
    v174 = v173;
    uint64_t v83 = TRunGlue::length((TRunGlue *)*v3);
    long long v84 = v176;
    long long v85 = v177;
    if (v176 != v177)
    {
      uint64_t v86 = v83;
      do
      {
        unsigned int v87 = *v84++;
        unint64_t v20 = v20 & 0xFFFFFFFF00000000 | v87;
        OTL::GlyphLookups::SetLookupInRange<false>(v171.i64, v20, 0, v86);
      }
      while (v84 != v85);
    }
    if (v171.i64[1] != v171.i64[0])
    {
      int v151 = (unsigned __int16)v182;
      int v152 = *((_DWORD *)v3 + 4);
      unint64_t v88 = (v171.i64[1] - v171.i64[0]) / 104;
      uint64_t v157 = (unsigned __int8 *)(*v3)[25];
      unint64_t v89 = (*v3)[78];
      unint64_t v90 = (v89 + 7) >> 3;
      BOOL v91 = v89 > 0x10000;
      uint64_t v92 = 0x2000;
      if (!v91) {
        uint64_t v92 = v90;
      }
      unint64_t v153 = v92;
      v159 = (TRunGlue *)*v3;
      uint64_t v154 = TRunGlue::length((TRunGlue *)*v3);
      v156 = (os_unfair_lock_s *)v3[17][50];
      os_unfair_lock_lock_with_options();
      uint64_t v93 = 0;
      if (v88 <= 1) {
        uint64_t v94 = 1;
      }
      else {
        uint64_t v94 = v88;
      }
      uint64_t v155 = v94;
      do
      {
        uint64_t v158 = v93;
        unsigned int v95 = *(_DWORD *)(v171.i64[0] + 104 * v93);
        uint64_t v96 = TBaseFont::NthLookup<OTL::GPOS>((uint64_t)v156, v15, (unsigned __int16)v95);
        if (v96)
        {
          v97 = v96;
          unsigned int v98 = *((unsigned __int16 *)v96 + 8);
          if (v154 != 1 || (v98 <= 8 ? (BOOL v99 = ((1 << v98) & 0x182) == 0) : (BOOL v99 = 1), !v99))
          {
            if (!v157 || OTL::CoverageBitmap::CoversBitmap((OTL::CoverageBitmap *)(v96 + 40), v157, v153))
            {
              if (v98 == 3)
              {
                if ((*(_WORD *)(*(void *)v97 + 2) & 0x100) != 0) {
                  int v100 = -1;
                }
                else {
                  int v100 = 1;
                }
              }
              else
              {
                int v100 = 1;
              }
              uint64_t v101 = (unsigned __int16 *)v171.i64[0];
              if (v171.i64[0] != v171.i64[1])
              {
                while (*v101 != (unsigned __int16)v95 || v101[1] != HIWORD(v95))
                {
                  v101 += 52;
                  if (v101 == (unsigned __int16 *)v171.i64[1])
                  {
                    uint64_t v101 = (unsigned __int16 *)v171.i64[1];
                    break;
                  }
                }
              }
              uint64_t v103 = (void *)*((void *)v101 + 1);
              os_unfair_lock_t lock = (os_unfair_lock_t)*((void *)v101 + 2);
              if (v103 != (void *)lock)
              {
                unsigned int v161 = v100 * v152;
                BOOL v105 = v151 == (unsigned __int16)v95 && v98 == 2;
                BOOL v160 = v105;
                do
                {
                  uint64_t v106 = *v103;
                  uint64_t v107 = v103[1];
                  v164 = v103;
                  *(void *)&long long v192 = 0xAAAAAAAAAAAAAAAALL;
                  *(void *)&long long v108 = 0xAAAAAAAAAAAAAAAALL;
                  *((void *)&v108 + 1) = 0xAAAAAAAAAAAAAAAALL;
                  long long v190 = v108;
                  long long v191 = v108;
                  v186 = v159;
                  unint64_t v187 = v161 | 0xAAAAAAAA00000000;
                  uint64_t v188 = v106 - 1;
                  *(void *)&long long v189 = v107 + v106;
                  *((void *)&v189 + 1) = -1;
                  uint64_t v109 = TRunGlue::length(v159);
                  *(void *)&long long v191 = -1;
                  *((void *)&v191 + 1) = -1;
                  *(void *)&long long v190 = v109;
                  *(void *)&long long v192 = 0;
                  uint64_t v110 = v188;
                  if ((v161 & 0x80000000) != 0)
                  {
                    uint64_t v111 = *((void *)&v189 + 1);
                    uint64_t v188 = v189;
                    *(void *)&long long v189 = v110;
                    *((void *)&v189 + 1) = v109;
                    *(void *)&long long v190 = v111;
                    uint64_t v110 = v188;
                  }
                  uint64_t v112 = *((void *)v97 + 3);
                  *((void *)&v190 + 1) = v110;
                  *(void *)&long long v192 = v112;
                  if (v160)
                  {
                    *a2 |= OTL::GPOS::ApplyPairPosAccelerated(v15, (const OTL::Lookup *)v97, (TGlyphIterator *)&v186);
                  }
                  else if (TGlyphIterator::NextCoveredBy((TGlyphIterator *)&v186, (const OTL::Lookup *)v97))
                  {
                    do
                    {
                      unsigned int v113 = -1431655765 * ((*((_DWORD *)v97 + 24) - *((_DWORD *)v97 + 22)) >> 4);
                      uint64_t v114 = *((void *)&v190 + 1);
                      uint64_t GlyphID = TRunGlue::GetGlyphID(v186, *((uint64_t *)&v190 + 1));
                      uint64_t v116 = (unsigned __int16)v113;
                      if ((_WORD)v113)
                      {
                        uint64_t v117 = GlyphID;
                        uint64_t v118 = 0;
                        unint64_t v119 = 0;
                        uint64_t v120 = 48 * v116;
                        do
                        {
                          *((void *)&v190 + 1) = v114;
                          uint64_t v121 = *((void *)v97 + 11);
                          if (0xAAAAAAAAAAAAAAABLL * ((*((void *)v97 + 12) - v121) >> 4) <= v119) {
                            break;
                          }
                          uint64_t v122 = v121 + v118;
                          uint64_t v123 = *(uint64_t (**)(void *, uint64_t))(v121 + v118 + 24);
                          uint64_t v124 = *(void *)(v122 + 32);
                          uint64_t v125 = (void *)(v122 + (v124 >> 1) + 8);
                          if (v124) {
                            uint64_t v123 = *(uint64_t (**)(void *, uint64_t))(*v125 + v123);
                          }
                          unsigned int v126 = v123(v125, v117);
                          if (v126)
                          {
                            uint64_t v127 = *((void *)v97 + 11);
                            v128 = 0xAAAAAAAAAAAAAAABLL * ((*((void *)v97 + 12) - v127) >> 4) <= v119
                                 ? 0
                                 : *(unsigned __int16 **)(v127 + v118);
                            uint64_t v129 = v122 + 8;
                            char v130 = 1;
                            if (OTL::GPOS::ApplyLookupSubtable(v15, (uint64_t)v97, v98, v128, (TGlyphIterator *)&v186, v129, v126, 1uLL))goto LABEL_201; {
                          }
                            }
                          ++v119;
                          v118 += 48;
                        }
                        while (v120 != v118);
                      }
                      char v130 = 0;
LABEL_201:
                      *a2 |= v130;
                    }
                    while ((TGlyphIterator::NextCoveredBy((TGlyphIterator *)&v186, (const OTL::Lookup *)v97) & 1) != 0);
                  }
                  uint64_t v103 = v164 + 2;
                }
                while (v164 + 2 != (void *)lock);
              }
            }
          }
        }
        uint64_t v93 = v158 + 1;
      }
      while (v158 + 1 != v155);
      os_unfair_lock_unlock(v156 + 89);
      uint64_t v3 = v150;
    }
    if (v3[30])
    {
      double v131 = *((double *)*v3 + 80);
      double v132 = *((double *)*v3 + 81);
      uint64_t v4 = v149;
      if ((*v3)[19] || (*v3)[24])
      {
        int v133 = (double *)v3[28];
        if (v133 != (double *)(v3 + 29))
        {
          v134 = (double *)MEMORY[0x1E4F1DAD8];
          do
          {
            double v135 = v133[5];
            double v136 = v133[6];
            if (v135 != 0.0 || v136 != 0.0)
            {
              double v137 = v131 * v135;
              double v138 = v132 * v136;
              double v139 = -(v131 * v135);
              if (!*((unsigned char *)v3 + 20)) {
                double v139 = v137;
              }
              if (v139 != *v134 || v138 != v134[1])
              {
                double v141 = v132 * v136;
                TRunGlue::SetOrigin(*v3, *((void *)v133 + 4), *(CGPoint *)&v139);
                v142 = (TRun *)(*v3)[19];
                if (v142) {
                  TRun::NoteCrossStreamPosition(v142, v132 * v138);
                }
              }
            }
            v143 = (double *)*((void *)v133 + 1);
            if (v143)
            {
              do
              {
                v144 = v143;
                v143 = *(double **)v143;
              }
              while (v143);
            }
            else
            {
              do
              {
                v144 = (double *)*((void *)v133 + 2);
                BOOL v99 = *(void *)v144 == (void)v133;
                int v133 = v144;
              }
              while (!v99);
            }
            int v133 = v144;
          }
          while (v144 != (double *)(v3 + 29));
        }
        uint64_t v12 = 1;
        *a2 = 1;
      }
      else
      {
        uint64_t v12 = 0;
      }
    }
    else
    {
      uint64_t v12 = 1;
      uint64_t v4 = v149;
    }
    v186 = (TRunGlue *)&v171;
    std::vector<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,TInlineBufferAllocator<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v186);
  }
  if (v148 == 2) {
    *a2 |= ZeroMarkWidths((TRunGlue *)*v3, v147);
  }
  v171.i64[0] = (uint64_t)&v176;
  std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v171);
LABEL_233:
  (*v3)[14] = v4;
  return v12;
}

uint64_t TRunGlue::length(TRunGlue *this)
{
  if (!*((void *)this + 19)) {
    return *((void *)this + 21) - *((void *)this + 20);
  }
  uint64_t result = *((void *)this + 4);
  if (result == -1)
  {
    TRunGlue::ComputeEndIndex(this);
    return *((void *)this + 4);
  }
  return result;
}

char *std::vector<std::pair<unsigned short,unsigned short>,TInlineBufferAllocator<std::pair<unsigned short,unsigned short>,30ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<std::pair<unsigned short,unsigned short>*>,std::__wrap_iter<std::pair<unsigned short,unsigned short>*>>(char *result, int *a2, int *a3, unint64_t a4)
{
  int v6 = a2;
  unsigned int v7 = result;
  int v8 = *(char **)result;
  if (a4 > (uint64_t)(*((void *)result + 2) - *(void *)result) >> 2)
  {
    std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__vdeallocate((uint64_t)result);
    if (a4 >> 62) {
      abort();
    }
    uint64_t v9 = *((void *)v7 + 2) - *(void *)v7;
    uint64_t v10 = v9 >> 1;
    if (v9 >> 1 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v11 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    uint64_t result = std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__vallocate[abi:nn180100](v7, v11);
    uint64_t v14 = (char *)*((void *)v7 + 1);
    uint64_t v13 = v7 + 8;
    uint64_t v12 = v14;
    BOOL v15 = v14;
    if (v6 != a3)
    {
      BOOL v15 = v12;
      do
      {
        int v16 = *v6++;
        *(_DWORD *)BOOL v15 = v16;
        v15 += 4;
      }
      while (v6 != a3);
    }
LABEL_18:
    uint8x8_t v22 = (char *)(v15 - v12);
    goto LABEL_23;
  }
  uint64_t v13 = result + 8;
  uint64_t v12 = (char *)*((void *)result + 1);
  unint64_t v17 = (v12 - v8) >> 2;
  if (v17 < a4)
  {
    unint64_t v18 = &a2[v17];
    if (v12 != v8)
    {
      do
      {
        int v19 = *v6++;
        *(_DWORD *)int v8 = v19;
        v8 += 4;
      }
      while (v6 != v18);
    }
    BOOL v15 = v12;
    if (v18 != a3)
    {
      unint64_t v20 = v12;
      do
      {
        int v21 = *v18++;
        *(_DWORD *)unint64_t v20 = v21;
        v20 += 4;
        v15 += 4;
      }
      while (v18 != a3);
    }
    goto LABEL_18;
  }
  unint64_t v23 = *(char **)result;
  if (a2 != a3)
  {
    int v24 = *(char **)result;
    do
    {
      int v25 = *v6++;
      *(_DWORD *)int v24 = v25;
      v24 += 4;
      v23 += 4;
    }
    while (v6 != a3);
  }
  uint8x8_t v22 = (char *)(v23 - v8);
  uint64_t v12 = v8;
LABEL_23:
  *uint64_t v13 = &v22[(void)v12];
  return result;
}

char *std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >> 62) {
    abort();
  }
  uint64_t result = (char *)TInlineBufferAllocator<unsigned int,30ul>::allocate((uint64_t)(a1 + 3), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[4 * a2];
  return result;
}

BOOL OTL::GCommon::GetLookups(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v36 = a3;
  uint64_t v4 = *(void *)(a1 + 48);
  if (!v4) {
    return 0;
  }
  int v8 = *(unsigned __int16 **)(a1 + 56);
  uint64_t v35 = bswap32(**(unsigned __int16 **)(a1 + 64)) >> 16;
  unsigned int v9 = bswap32(*v8) >> 16;
  unsigned int v10 = *(unsigned __int16 *)(v4 + 4);
  v33[0] = TFont::GetFeatureTableSubstitutions(*(void *)(a1 + 16), *(_DWORD *)(a1 + 8));
  v33[1] = &v34;
  v33[2] = a1;
  v33[3] = &v35;
  v33[4] = &v36;
  uint64_t v34 = 0;
  if (a4)
  {
    unsigned int v11 = bswap32(*(unsigned __int16 *)(*(void *)(a1 + 48) + 2)) >> 16;
    if (v11 < v9) {
      OTL::GCommon::GetLookups(OTL::FeatureBuffer const&,TInlineVector<std::pair<unsigned short,unsigned short>,30ul> *,BOOL)const::$_0::operator()((uint64_t)v33, v11, 0);
    }
  }
  uint64_t v13 = *(_DWORD **)a2;
  uint64_t v12 = *(_DWORD **)(a2 + 8);
  if (v13 != v12)
  {
    uint64_t v14 = 2 * __rev16(v10);
    do
    {
      int v15 = v13[1];
      if (v15 && v10)
      {
        int v16 = (unsigned __int16 *)(*(void *)(a1 + 48) + 6);
        uint64_t v17 = v14;
        while (1)
        {
          unsigned int v18 = bswap32(*v16) >> 16;
          if (v18 < v9 && bswap32(*(_DWORD *)(*(void *)(a1 + 56) + 6 * v18 + 2)) == *v13) {
            break;
          }
          ++v16;
          v17 -= 2;
          if (!v17) {
            goto LABEL_15;
          }
        }
        OTL::GCommon::GetLookups(OTL::FeatureBuffer const&,TInlineVector<std::pair<unsigned short,unsigned short>,30ul> *,BOOL)const::$_0::operator()((uint64_t)v33, v18, v15 - 1);
      }
LABEL_15:
      v13 += 2;
    }
    while (v13 != v12);
  }
  uint64_t v20 = *(void *)v36;
  int v19 = *(unsigned __int16 **)(v36 + 8);
  unint64_t v21 = 126 - 2 * __clz(((uint64_t)v19 - *(void *)v36) >> 2);
  if (v19 == *(unsigned __int16 **)v36) {
    uint64_t v22 = 0;
  }
  else {
    uint64_t v22 = v21;
  }
  std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned short,unsigned short> *,false>(*(void *)v36, *(unsigned __int16 **)(v36 + 8), v22, 1);
  uint64_t v23 = v36;
  if (v19 != (unsigned __int16 *)v20)
  {
    int v24 = (_WORD *)(v20 - 4);
    while (v24 + 4 != v19)
    {
      int v26 = (unsigned __int16)v24[2];
      v24 += 2;
      int v25 = v26;
      if (v26 == (unsigned __int16)v24[2] && v24[1] == v24[3])
      {
        for (uint64_t i = v24 + 4; i != v19; i += 2)
        {
          int v29 = v25;
          int v25 = *i;
          if (v29 != v25 || (unsigned __int16)v24[1] != i[1])
          {
            v24[2] = v25;
            v24 += 2;
            v24[1] = i[1];
          }
        }
        uint64_t v31 = v24 + 2;
        goto LABEL_38;
      }
    }
  }
  uint64_t v31 = v19;
LABEL_38:
  std::vector<std::pair<unsigned short,unsigned short>,TInlineBufferAllocator<std::pair<unsigned short,unsigned short>,30ul>>::erase(v23, v31, v19);
  return *(void *)v36 != *(void *)(v36 + 8);
}

void OTL::GCommon::GetLookups(OTL::FeatureBuffer const&,TInlineVector<std::pair<unsigned short,unsigned short>,30ul> *,BOOL)const::$_0::operator()(uint64_t a1, unsigned __int16 a2, __int16 a3)
{
  unsigned __int16 v36 = a2;
  uint64_t v5 = *(void *)(a1 + 16);
  int v6 = std::__hash_table<std::__hash_value_type<unsigned short,OTL::FeatureTable const*>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,OTL::FeatureTable const*>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,OTL::FeatureTable const*>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,OTL::FeatureTable const*>>>::find<unsigned short>(*(void **)a1, &v36);
  if (**(uint64_t ****)(a1 + 8) == v6)
  {
    unsigned int v7 = (uint64_t *)(*(void *)(v5 + 56) + (bswap32(*(unsigned __int16 *)(*(void *)(v5 + 56) + 6 * v36 + 6)) >> 16));
    unint64_t v10 = *(void *)(v5 + 40);
    unsigned int v11 = (char *)v7 + 4;
    if ((unint64_t)v7 + 4 > v10) {
      return;
    }
    unsigned int v8 = *((unsigned __int16 *)v7 + 1);
    uint64_t v9 = __rev16(v8);
    unint64_t v12 = (unint64_t)&v11[2 * v9];
    unint64_t v13 = (unint64_t)v7 + 6 <= v10 ? (v10 - (unint64_t)v11) >> 1 : 0;
    BOOL v14 = v12 <= v10 && v12 >= (unint64_t)v11;
    if (!v14 && v13 != v9) {
      return;
    }
  }
  else
  {
    unsigned int v7 = v6[3];
    unsigned int v8 = *((unsigned __int16 *)v7 + 1);
    uint64_t v9 = __rev16(v8);
  }
  if (v8)
  {
    int v16 = (unsigned __int16 *)v7 + 2;
    uint64_t v17 = (uint64_t)v7 + 2 * v9 + 4;
    do
    {
      unint64_t v18 = bswap32(*v16) >> 16;
      if (**(void **)(a1 + 24) > v18)
      {
        int v19 = **(char ****)(a1 + 32);
        unint64_t v21 = v19[1];
        unint64_t v20 = (unint64_t)v19[2];
        if ((unint64_t)v21 >= v20)
        {
          uint64_t v23 = (v21 - *v19) >> 2;
          unint64_t v24 = v23 + 1;
          if ((unint64_t)(v23 + 1) >> 62) {
            abort();
          }
          uint64_t v25 = v20 - (void)*v19;
          if (v25 >> 1 > v24) {
            unint64_t v24 = v25 >> 1;
          }
          if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v26 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v26 = v24;
          }
          char v27 = (char *)TInlineBufferAllocator<unsigned int,30ul>::allocate((uint64_t)(v19 + 3), v26);
          unint64_t v28 = &v27[4 * v23];
          *(_WORD *)unint64_t v28 = v18;
          *((_WORD *)v28 + 1) = a3;
          long long v30 = *v19;
          int v29 = v19[1];
          uint64_t v31 = v28;
          if (v29 != *v19)
          {
            do
            {
              int v32 = *((_DWORD *)v29 - 1);
              v29 -= 4;
              *((_DWORD *)v31 - 1) = v32;
              v31 -= 4;
            }
            while (v29 != v30);
            int v29 = *v19;
          }
          uint64_t v22 = v28 + 4;
          *int v19 = v31;
          v19[1] = v28 + 4;
          uint64_t v33 = v19[2];
          v19[2] = &v27[4 * v26];
          if (v29)
          {
            uint64_t v34 = (char *)(v19 + 18);
            if (v19 + 3 <= (char **)v29 && v34 > v29)
            {
              if (v33 == *(char **)v34) {
                *(void *)uint64_t v34 = v29;
              }
            }
            else
            {
              operator delete(v29);
            }
          }
        }
        else
        {
          *(_WORD *)unint64_t v21 = v18;
          *((_WORD *)v21 + 1) = a3;
          uint64_t v22 = v21 + 4;
        }
        v19[1] = v22;
      }
      ++v16;
    }
    while (v16 != (unsigned __int16 *)v17);
  }
}

void *TInlineBufferAllocator<unsigned int,30ul>::allocate(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 120);
  int v2 = (unint64_t *)(a1 + 120);
  uint64_t v3 = v4;
  unint64_t v5 = v4 + 4 * a2;
  if (v5 <= (unint64_t)v2)
  {
    *int v2 = v5;
    return (void *)v3;
  }
  else
  {
    if (a2 >> 62) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    return operator new(4 * a2);
  }
}

uint64_t **std::__hash_table<std::__hash_value_type<unsigned short,OTL::FeatureTable const*>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,OTL::FeatureTable const*>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,OTL::FeatureTable const*>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,OTL::FeatureTable const*>>>::find<unsigned short>(void *a1, unsigned __int16 *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = *a2;
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v5 = *a2;
    if (*(void *)&v2 <= v3) {
      unint64_t v5 = v3 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v5 = (v2.i32[0] - 1) & v3;
  }
  int v6 = *(uint64_t ****)(*a1 + 8 * v5);
  if (!v6) {
    return 0;
  }
  for (uint64_t result = *v6; result; uint64_t result = (uint64_t **)*result)
  {
    unint64_t v8 = (unint64_t)result[1];
    if (v8 == v3)
    {
      if (*((unsigned __int16 *)result + 8) == v3) {
        return result;
      }
    }
    else
    {
      if (v4.u32[0] > 1uLL)
      {
        if (v8 >= *(void *)&v2) {
          v8 %= *(void *)&v2;
        }
      }
      else
      {
        v8 &= *(void *)&v2 - 1;
      }
      if (v8 != v5) {
        return 0;
      }
    }
  }
  return result;
}

long long *TFont::GetFeatureTableSubstitutions(uint64_t a1, unsigned int a2)
{
  if (qword_1EB2CE068 != -1) {
    dispatch_once_f(&qword_1EB2CE068, 0, (dispatch_function_t)TFont::GetFeatureTableSubstitutions(OTL::GCommon::Table)const::$_0::__invoke);
  }
  uint8x8_t v4 = (atomic_ullong *)(a1 + 8 * a2 + 344);
  unint64_t explicit = atomic_load_explicit(v4, memory_order_acquire);
  if (explicit)
  {
    if (explicit == -1) {
      return &xmmword_1EB2CE080;
    }
    else {
      return (long long *)explicit;
    }
  }
  else
  {
    if (a2) {
      uint64_t v7 = 1196445523;
    }
    else {
      uint64_t v7 = 1196643650;
    }
    CFDataRef CommonTable = (const __CFData *)TBaseFont::GetCommonTable(*(TBaseFont **)(a1 + 400), v7, 0);
    if (CommonTable)
    {
      CFDataRef v9 = CommonTable;
      BytePtr = CFDataGetBytePtr(CommonTable);
      if (BytePtr)
      {
        uint64_t v11 = (uint64_t)BytePtr;
        *(void *)&long long v12 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)__n = v12;
        long long v17 = v12;
        unint64_t v18 = 0xAAAAAAAAFFFFFFFFLL;
        unint64_t v13 = CFDataGetBytePtr(v9);
        if (v13) {
          unint64_t v14 = (unint64_t)&v13[CFDataGetLength(v9)];
        }
        else {
          unint64_t v14 = 0;
        }
        OTL::GCommon::FeatureTableSubstitutionsForFont(v11, v14, (atomic_ullong *)a1, (uint64_t)__n);
        if (*((void *)&v17 + 1)) {
          operator new();
        }
        std::__hash_table<EncoderAttempt,std::hash<EncoderAttempt>,std::equal_to<EncoderAttempt>,std::allocator<EncoderAttempt>>::~__hash_table((uint64_t)__n);
      }
    }
    atomic_store(0xFFFFFFFFFFFFFFFFLL, (unint64_t *)v4);
    return &xmmword_1EB2CE080;
  }
}

_DWORD *std::vector<std::pair<unsigned short,unsigned short>,TInlineBufferAllocator<std::pair<unsigned short,unsigned short>,30ul>>::erase(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  if (a2 != a3)
  {
    unint64_t v3 = *(_DWORD **)(a1 + 8);
    uint8x8_t v4 = a2;
    if (a3 != v3)
    {
      uint64_t v5 = a3 - a2;
      uint8x8_t v4 = a2;
      do
      {
        _DWORD *v4 = v4[v5];
        ++v4;
      }
      while (&v4[v5] != v3);
    }
    *(void *)(a1 + 8) = v4;
  }
  return a2;
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned short,unsigned short> *,false>(uint64_t result, unsigned __int16 *a2, uint64_t a3, char a4)
{
  CFDataRef v9 = (unsigned __int16 *)result;
  while (2)
  {
    unint64_t v10 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          CFDataRef v9 = v10;
          uint64_t v11 = (char *)a2 - (char *)v10;
          unint64_t v12 = ((char *)a2 - (char *)v10) >> 2;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                unsigned int v105 = *(a2 - 2);
                unsigned int v106 = *v10;
                char v107 = -1;
                if (v105 >= v106) {
                  char v107 = 1;
                }
                if (v105 == v106)
                {
                  unsigned int v108 = *(a2 - 1);
                  unsigned int v109 = v10[1];
                  BOOL v4 = v108 >= v109;
                  BOOL v110 = v108 == v109;
                  char v107 = -1;
                  if (v4) {
                    char v107 = 1;
                  }
                  if (v110) {
                    char v107 = 0;
                  }
                }
                if (v107 < 0)
                {
                  unsigned __int16 *v10 = v105;
                  *(a2 - 2) = v106;
                  unsigned __int16 v111 = v10[1];
                  v10[1] = *(a2 - 1);
                  *(a2 - 1) = v111;
                }
                break;
              case 3uLL:
                uint64_t result = (uint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned short,unsigned short> *>(v10, v10 + 2, a2 - 2);
                break;
              case 4uLL:
                uint64_t result = (uint64_t)std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned short,unsigned short> *>(v10, v10 + 2, v10 + 4, a2 - 2);
                break;
              case 5uLL:
                uint64_t result = (uint64_t)std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned short,unsigned short> *>(v10, v10 + 2, v10 + 4, v10 + 6, a2 - 2);
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v11 <= 95)
          {
            uint64_t v112 = v10 + 2;
            BOOL v114 = v10 == a2 || v112 == a2;
            if (a4)
            {
              if (!v114)
              {
                uint64_t v115 = 0;
                uint64_t v116 = v10;
                do
                {
                  uint64_t v117 = v112;
                  unsigned int v118 = v116[2];
                  unsigned int v119 = *v116;
                  BOOL v120 = v118 == v119;
                  if (v118 >= v119) {
                    char v121 = 1;
                  }
                  else {
                    char v121 = -1;
                  }
                  if (v120)
                  {
                    unsigned int v122 = v116[3];
                    unsigned int v123 = v116[1];
                    BOOL v124 = v122 == v123;
                    if (v122 >= v123) {
                      char v125 = 1;
                    }
                    else {
                      char v125 = -1;
                    }
                    if (v124) {
                      char v121 = 0;
                    }
                    else {
                      char v121 = v125;
                    }
                  }
                  if (v121 < 0)
                  {
                    unsigned int v126 = (unsigned __int16)*(_DWORD *)v117;
                    unsigned int v127 = HIWORD(*(_DWORD *)v117);
                    uint64_t v128 = v115;
                    while (1)
                    {
                      uint64_t v129 = (char *)v10 + v128;
                      *((_WORD *)v129 + 2) = v119;
                      *((_WORD *)v129 + 3) = *(unsigned __int16 *)((char *)v10 + v128 + 2);
                      if (!v128) {
                        break;
                      }
                      unsigned int v119 = *((unsigned __int16 *)v129 - 2);
                      if (v119 <= v126) {
                        char v130 = 1;
                      }
                      else {
                        char v130 = -1;
                      }
                      if (v119 == v126)
                      {
                        unsigned int v131 = *(unsigned __int16 *)((char *)v10 + v128 - 2);
                        BOOL v132 = v131 == v127;
                        char v130 = v131 <= v127 ? 1 : -1;
                        if (v132) {
                          char v130 = 0;
                        }
                      }
                      v128 -= 4;
                      if ((v130 & 0x80) == 0)
                      {
                        int v133 = (unsigned __int16 *)((char *)v10 + v128 + 4);
                        goto LABEL_235;
                      }
                    }
                    int v133 = v10;
LABEL_235:
                    unsigned __int16 *v133 = v126;
                    v133[1] = v127;
                  }
                  uint64_t v112 = v117 + 2;
                  v115 += 4;
                  uint64_t v116 = v117;
                }
                while (v117 + 2 != a2);
              }
            }
            else if (!v114)
            {
              v202 = v10 + 3;
              do
              {
                v203 = v112;
                unsigned int v204 = v9[2];
                unsigned int v205 = *v9;
                BOOL v206 = v204 == v205;
                if (v204 >= v205) {
                  char v207 = 1;
                }
                else {
                  char v207 = -1;
                }
                if (v206)
                {
                  unsigned int v208 = v9[3];
                  unsigned int v209 = v9[1];
                  BOOL v210 = v208 == v209;
                  char v207 = v208 >= v209 ? 1 : -1;
                  if (v210) {
                    char v207 = 0;
                  }
                }
                if (v207 < 0)
                {
                  unsigned int v211 = (unsigned __int16)*(_DWORD *)v203;
                  unsigned int v212 = HIWORD(*(_DWORD *)v203);
                  v213 = v202;
                  do
                  {
                    *(v213 - 1) = v205;
                    unsigned __int16 *v213 = *(v213 - 2);
                    unsigned int v205 = *(v213 - 5);
                    if (v205 <= v211) {
                      char v214 = 1;
                    }
                    else {
                      char v214 = -1;
                    }
                    if (v205 == v211)
                    {
                      unsigned int v215 = *(v213 - 4);
                      BOOL v216 = v215 == v212;
                      char v214 = v215 <= v212 ? 1 : -1;
                      if (v216) {
                        char v214 = 0;
                      }
                    }
                    v213 -= 2;
                  }
                  while (v214 < 0);
                  *(v213 - 1) = v211;
                  unsigned __int16 *v213 = v212;
                }
                uint64_t v112 = v203 + 2;
                v202 += 2;
                CFDataRef v9 = v203;
              }
              while (v203 + 2 != a2);
            }
            return result;
          }
          if (!a3)
          {
            if (v10 != a2)
            {
              int64_t v134 = (v12 - 2) >> 1;
              int64_t v135 = v134;
              do
              {
                int64_t v136 = v135;
                if (v134 >= v135)
                {
                  uint64_t v137 = (2 * v135) | 1;
                  double v138 = &v10[2 * v137];
                  if (2 * v136 + 2 < (uint64_t)v12)
                  {
                    unsigned int v139 = v138[2];
                    unsigned int v140 = *v138;
                    BOOL v141 = v140 == v139;
                    if (v140 >= v139) {
                      char v142 = 1;
                    }
                    else {
                      char v142 = -1;
                    }
                    if (v141)
                    {
                      unsigned int v143 = v10[2 * v137 + 1];
                      unsigned int v144 = v138[3];
                      BOOL v145 = v143 == v144;
                      char v142 = v143 >= v144 ? 1 : -1;
                      if (v145) {
                        char v142 = 0;
                      }
                    }
                    if (v142 < 0)
                    {
                      v138 += 2;
                      uint64_t v137 = 2 * v136 + 2;
                    }
                  }
                  int v146 = &v10[2 * v136];
                  unsigned int v147 = *v138;
                  unsigned int v148 = *v146;
                  BOOL v149 = v147 == v148;
                  if (v147 >= v148) {
                    char v150 = 1;
                  }
                  else {
                    char v150 = -1;
                  }
                  if (v149)
                  {
                    unsigned int v151 = v138[1];
                    unsigned int v152 = v10[2 * v136 + 1];
                    BOOL v153 = v151 == v152;
                    char v150 = v151 >= v152 ? 1 : -1;
                    if (v153) {
                      char v150 = 0;
                    }
                  }
                  if ((v150 & 0x80) == 0)
                  {
                    unsigned int v154 = (unsigned __int16)*(_DWORD *)v146;
                    unsigned int v155 = HIWORD(*(_DWORD *)v146);
                    do
                    {
                      v156 = v138;
                      unsigned __int16 *v146 = v147;
                      v146[1] = v138[1];
                      if (v134 < v137) {
                        break;
                      }
                      uint64_t v157 = (2 * v137) | 1;
                      double v138 = &v10[2 * v157];
                      uint64_t v137 = 2 * v137 + 2;
                      if (v137 < (uint64_t)v12)
                      {
                        unsigned int v158 = v138[2];
                        unsigned int v159 = *v138;
                        BOOL v160 = v159 == v158;
                        if (v159 >= v158) {
                          char v161 = 1;
                        }
                        else {
                          char v161 = -1;
                        }
                        if (v160)
                        {
                          unsigned int v162 = v10[2 * v157 + 1];
                          unsigned int v163 = v138[3];
                          BOOL v164 = v162 == v163;
                          char v161 = v162 >= v163 ? 1 : -1;
                          if (v164) {
                            char v161 = 0;
                          }
                        }
                        if (v161 < 0) {
                          v138 += 2;
                        }
                        else {
                          uint64_t v137 = v157;
                        }
                      }
                      else
                      {
                        uint64_t v137 = v157;
                      }
                      unsigned int v147 = *v138;
                      if (v147 >= v154) {
                        char v165 = 1;
                      }
                      else {
                        char v165 = -1;
                      }
                      if (v147 == v154)
                      {
                        unsigned int v166 = v138[1];
                        BOOL v167 = v166 == v155;
                        if (v166 >= v155) {
                          char v168 = 1;
                        }
                        else {
                          char v168 = -1;
                        }
                        if (v167) {
                          char v165 = 0;
                        }
                        else {
                          char v165 = v168;
                        }
                      }
                      int v146 = v156;
                    }
                    while ((v165 & 0x80) == 0);
                    unsigned __int16 *v156 = v154;
                    v156[1] = v155;
                  }
                }
                int64_t v135 = v136 - 1;
              }
              while (v136);
              uint64_t v169 = (unint64_t)v11 >> 2;
              do
              {
                uint64_t v170 = 0;
                int v171 = *(_DWORD *)v10;
                uint64_t v172 = v169 - 2;
                if (v169 < 2) {
                  uint64_t v172 = v169 - 1;
                }
                uint64_t v173 = v172 >> 1;
                v174 = v10;
                do
                {
                  uint64_t result = v170 + 1;
                  v175 = &v174[2 * v170 + 2];
                  uint64_t v176 = (2 * v170) | 1;
                  uint64_t v177 = 2 * v170 + 2;
                  if (v177 < v169)
                  {
                    unsigned int v178 = v175[2];
                    unsigned int v179 = *v175;
                    BOOL v180 = v179 == v178;
                    if (v179 >= v178) {
                      char v181 = 1;
                    }
                    else {
                      char v181 = -1;
                    }
                    if (v180)
                    {
                      unsigned int v182 = v174[2 * result + 1];
                      unsigned int v183 = v175[3];
                      BOOL v184 = v182 == v183;
                      if (v182 >= v183) {
                        uint64_t result = 1;
                      }
                      else {
                        uint64_t result = 255;
                      }
                      if (v184) {
                        char v181 = 0;
                      }
                      else {
                        char v181 = result;
                      }
                    }
                    if (v181 < 0)
                    {
                      v175 += 2;
                      uint64_t v176 = v177;
                    }
                  }
                  unsigned __int16 *v174 = *v175;
                  v174[1] = v175[1];
                  v174 = v175;
                  uint64_t v170 = v176;
                }
                while (v176 <= v173);
                if (v175 == a2 - 2)
                {
                  *(_DWORD *)v175 = v171;
                }
                else
                {
                  unsigned __int16 *v175 = *(a2 - 2);
                  v175[1] = *(a2 - 1);
                  *((_DWORD *)a2 - 1) = v171;
                  uint64_t v185 = (char *)v175 - (char *)v10 + 4;
                  if (v185 >= 5)
                  {
                    unint64_t v186 = (((unint64_t)v185 >> 2) - 2) >> 1;
                    unint64_t v187 = &v10[2 * v186];
                    unsigned int v188 = *v187;
                    unsigned int v189 = *v175;
                    BOOL v190 = v188 == v189;
                    if (v188 >= v189) {
                      char v191 = 1;
                    }
                    else {
                      char v191 = -1;
                    }
                    if (v190)
                    {
                      unsigned int v192 = v187[1];
                      unsigned int v193 = v175[1];
                      BOOL v194 = v192 == v193;
                      char v191 = v192 >= v193 ? 1 : -1;
                      if (v194) {
                        char v191 = 0;
                      }
                    }
                    if (v191 < 0)
                    {
                      unsigned int v195 = (unsigned __int16)*(_DWORD *)v175;
                      unsigned int v196 = HIWORD(*(_DWORD *)v175);
                      do
                      {
                        uint64_t result = (uint64_t)v187;
                        unsigned __int16 *v175 = v188;
                        v175[1] = v187[1];
                        if (!v186) {
                          break;
                        }
                        unint64_t v186 = (v186 - 1) >> 1;
                        unint64_t v187 = &v10[2 * v186];
                        unsigned int v188 = *v187;
                        if (v188 >= v195) {
                          char v197 = 1;
                        }
                        else {
                          char v197 = -1;
                        }
                        if (v188 == v195)
                        {
                          unsigned int v198 = v187[1];
                          BOOL v199 = v198 == v196;
                          if (v198 >= v196) {
                            char v200 = 1;
                          }
                          else {
                            char v200 = -1;
                          }
                          if (v199) {
                            char v197 = 0;
                          }
                          else {
                            char v197 = v200;
                          }
                        }
                        v175 = (unsigned __int16 *)result;
                      }
                      while (v197 < 0);
                      *(_WORD *)uint64_t result = v195;
                      *(_WORD *)(result + 2) = v196;
                    }
                  }
                }
                a2 -= 2;
              }
              while (v169-- > 2);
            }
            return result;
          }
          unint64_t v13 = v12 >> 1;
          unint64_t v14 = &v10[2 * (v12 >> 1)];
          if ((unint64_t)v11 >= 0x201)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned short,unsigned short> *>(v9, &v9[2 * (v12 >> 1)], a2 - 2);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned short,unsigned short> *>(v9 + 2, v14 - 2, a2 - 4);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned short,unsigned short> *>(v9 + 4, &v9[2 * v13 + 2], a2 - 6);
            uint64_t result = (uint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned short,unsigned short> *>(v14 - 2, v14, &v9[2 * v13 + 2]);
            unsigned __int16 v15 = *v9;
            *CFDataRef v9 = *v14;
            *unint64_t v14 = v15;
            unsigned __int16 v16 = v9[1];
            v9[1] = v14[1];
            v14[1] = v16;
          }
          else
          {
            uint64_t result = (uint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned short,unsigned short> *>(&v9[2 * (v12 >> 1)], v9, a2 - 2);
          }
          --a3;
          if (a4) {
            break;
          }
          unsigned int v17 = *(v9 - 2);
          unsigned int v18 = *v9;
          BOOL v19 = v17 == v18;
          if (v17 >= v18) {
            char v20 = 1;
          }
          else {
            char v20 = -1;
          }
          if (v19)
          {
            unsigned int v21 = *(v9 - 1);
            unsigned int v22 = v9[1];
            BOOL v23 = v21 == v22;
            char v20 = v21 >= v22 ? 1 : -1;
            if (v23) {
              char v20 = 0;
            }
          }
          if (v20 < 0) {
            break;
          }
          unsigned int v63 = HIWORD(*(_DWORD *)v9);
          unsigned int v64 = *(a2 - 2);
          if (v64 <= (unsigned __int16)*(_DWORD *)v9) {
            char v65 = 1;
          }
          else {
            char v65 = -1;
          }
          if (v64 == (unsigned __int16)*(_DWORD *)v9)
          {
            unsigned int v66 = *(a2 - 1);
            BOOL v67 = v66 == v63;
            if (v66 <= v63) {
              char v68 = 1;
            }
            else {
              char v68 = -1;
            }
            if (v67) {
              char v65 = 0;
            }
            else {
              char v65 = v68;
            }
          }
          unsigned int v69 = (unsigned __int16)*(_DWORD *)v9;
          uint64_t v70 = v9;
          if (v65 < 0)
          {
            do
            {
              unint64_t v10 = v70 + 2;
              unsigned int v77 = v70[2];
              BOOL v78 = v77 == v69;
              if (v77 <= v69) {
                char v79 = 1;
              }
              else {
                char v79 = -1;
              }
              if (v78)
              {
                unsigned int v80 = v70[3];
                BOOL v81 = v80 == v63;
                if (v80 <= v63) {
                  char v82 = 1;
                }
                else {
                  char v82 = -1;
                }
                if (v81) {
                  char v79 = 0;
                }
                else {
                  char v79 = v82;
                }
              }
              uint64_t v70 = v10;
            }
            while ((v79 & 0x80) == 0);
          }
          else
          {
            uint64_t v71 = v9 + 2;
            do
            {
              unint64_t v10 = v71;
              if (v71 >= a2) {
                break;
              }
              unsigned int v72 = *v71;
              BOOL v73 = v72 == v69;
              if (v72 <= v69) {
                char v74 = 1;
              }
              else {
                char v74 = -1;
              }
              if (v73)
              {
                unsigned int v75 = v71[1];
                BOOL v76 = v75 == v63;
                char v74 = v75 <= v63 ? 1 : -1;
                if (v76) {
                  char v74 = 0;
                }
              }
              v71 += 2;
            }
            while ((v74 & 0x80) == 0);
          }
          uint64_t v83 = a2;
          if (v10 < a2)
          {
            long long v84 = a2;
            uint64_t v83 = a2;
            do
            {
              unsigned int v85 = *(v83 - 2);
              v83 -= 2;
              BOOL v86 = v85 == v69;
              if (v85 <= v69) {
                char v87 = 1;
              }
              else {
                char v87 = -1;
              }
              if (v86)
              {
                unsigned int v88 = *(v84 - 1);
                BOOL v89 = v88 == v63;
                char v87 = v88 <= v63 ? 1 : -1;
                if (v89) {
                  char v87 = 0;
                }
              }
              long long v84 = v83;
            }
            while (v87 < 0);
          }
          if (v10 < v83)
          {
            unsigned __int16 v90 = *v10;
            unsigned __int16 v91 = *v83;
            do
            {
              unsigned __int16 *v10 = v91;
              *uint64_t v83 = v90;
              unsigned __int16 v92 = v10[1];
              v10[1] = v83[1];
              v83[1] = v92;
              uint64_t v93 = v10;
              do
              {
                unsigned int v94 = v10[2];
                v10 += 2;
                unsigned __int16 v90 = v94;
                BOOL v95 = v94 == v69;
                if (v94 <= v69) {
                  char v96 = 1;
                }
                else {
                  char v96 = -1;
                }
                if (v95)
                {
                  unsigned int v97 = v93[3];
                  BOOL v98 = v97 == v63;
                  char v96 = v97 <= v63 ? 1 : -1;
                  if (v98) {
                    char v96 = 0;
                  }
                }
                uint64_t v93 = v10;
              }
              while ((v96 & 0x80) == 0);
              BOOL v99 = v83;
              do
              {
                unsigned int v100 = *(v83 - 2);
                v83 -= 2;
                unsigned __int16 v91 = v100;
                BOOL v101 = v100 == v69;
                if (v100 <= v69) {
                  char v102 = 1;
                }
                else {
                  char v102 = -1;
                }
                if (v101)
                {
                  unsigned int v103 = *(v99 - 1);
                  BOOL v104 = v103 == v63;
                  char v102 = v103 <= v63 ? 1 : -1;
                  if (v104) {
                    char v102 = 0;
                  }
                }
                BOOL v99 = v83;
              }
              while (v102 < 0);
            }
            while (v10 < v83);
          }
          BOOL v4 = v10 - 2 >= v9;
          BOOL v5 = v10 - 2 == v9;
          if (v10 - 2 != v9)
          {
            *CFDataRef v9 = *(v10 - 2);
            v9[1] = *(v10 - 1);
          }
          a4 = 0;
          *(v10 - 2) = v69;
          *(v10 - 1) = v63;
        }
        uint64_t v24 = 0;
        unsigned int v25 = (unsigned __int16)*(_DWORD *)v9;
        unsigned int v26 = HIWORD(*(_DWORD *)v9);
        do
        {
          unsigned int v27 = v9[v24 + 2];
          if (v27 >= v25) {
            char v28 = 1;
          }
          else {
            char v28 = -1;
          }
          if (v27 == v25)
          {
            unsigned int v29 = v9[v24 + 3];
            BOOL v30 = v29 == v26;
            char v28 = v29 >= v26 ? 1 : -1;
            if (v30) {
              char v28 = 0;
            }
          }
          v24 += 2;
        }
        while (v28 < 0);
        uint64_t v31 = &v9[v24];
        int v32 = a2;
        if (v24 == 2)
        {
          long long v40 = a2;
          while (v31 < v40)
          {
            uint64_t v33 = v40 - 2;
            unsigned int v41 = *(v40 - 2);
            BOOL v42 = v41 == v25;
            if (v41 >= v25) {
              char v43 = 1;
            }
            else {
              char v43 = -1;
            }
            if (v42)
            {
              unsigned int v44 = *(v40 - 1);
              BOOL v45 = v44 == v26;
              if (v44 >= v26) {
                char v46 = 1;
              }
              else {
                char v46 = -1;
              }
              if (v45) {
                char v43 = 0;
              }
              else {
                char v43 = v46;
              }
            }
            long long v40 = v33;
            if (v43 < 0) {
              goto LABEL_63;
            }
          }
          uint64_t v33 = v40;
        }
        else
        {
          do
          {
            uint64_t v33 = v32 - 2;
            unsigned int v34 = *(v32 - 2);
            BOOL v35 = v34 == v25;
            if (v34 >= v25) {
              char v36 = 1;
            }
            else {
              char v36 = -1;
            }
            if (v35)
            {
              unsigned int v37 = *(v32 - 1);
              BOOL v38 = v37 == v26;
              if (v37 >= v26) {
                char v39 = 1;
              }
              else {
                char v39 = -1;
              }
              if (v38) {
                char v36 = 0;
              }
              else {
                char v36 = v39;
              }
            }
            int v32 = v33;
          }
          while ((v36 & 0x80) == 0);
        }
LABEL_63:
        if (v31 >= v33)
        {
          unint64_t v10 = v31;
        }
        else
        {
          unsigned __int16 v47 = *v33;
          uint8x8_t v48 = v33;
          unint64_t v10 = v31;
          do
          {
            unsigned __int16 *v10 = v47;
            *uint8x8_t v48 = v27;
            unsigned __int16 v49 = v10[1];
            v10[1] = v48[1];
            v48[1] = v49;
            int v50 = v10;
            do
            {
              unsigned int v51 = v10[2];
              v10 += 2;
              LOWORD(v27) = v51;
              BOOL v52 = v51 == v25;
              if (v51 >= v25) {
                char v53 = 1;
              }
              else {
                char v53 = -1;
              }
              if (v52)
              {
                unsigned int v54 = v50[3];
                BOOL v55 = v54 == v26;
                char v53 = v54 >= v26 ? 1 : -1;
                if (v55) {
                  char v53 = 0;
                }
              }
              int v50 = v10;
            }
            while (v53 < 0);
            float v56 = v48;
            do
            {
              unsigned int v57 = *(v48 - 2);
              v48 -= 2;
              unsigned __int16 v47 = v57;
              BOOL v58 = v57 == v25;
              if (v57 >= v25) {
                char v59 = 1;
              }
              else {
                char v59 = -1;
              }
              if (v58)
              {
                unsigned int v60 = *(v56 - 1);
                BOOL v61 = v60 == v26;
                char v59 = v60 >= v26 ? 1 : -1;
                if (v61) {
                  char v59 = 0;
                }
              }
              float v56 = v48;
            }
            while ((v59 & 0x80) == 0);
          }
          while (v10 < v48);
        }
        if (v10 - 2 != v9)
        {
          *CFDataRef v9 = *(v10 - 2);
          v9[1] = *(v10 - 1);
        }
        *(v10 - 2) = v25;
        *(v10 - 1) = v26;
        if (v31 >= v33) {
          break;
        }
LABEL_97:
        uint64_t result = std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned short,unsigned short> *,false>(v9, v10 - 2, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v62 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned short,unsigned short> *>(v9, v10 - 2);
      uint64_t result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned short,unsigned short> *>(v10, a2);
      if (result) {
        break;
      }
      if (!v62) {
        goto LABEL_97;
      }
    }
    a2 = v10 - 2;
    if (!v62) {
      continue;
    }
    return result;
  }
}

void std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__vdeallocate(uint64_t a1)
{
  int8x8_t v2 = *(void **)a1;
  if (v2)
  {
    *(void *)(a1 + 8) = v2;
    unint64_t v3 = (void *)(a1 + 144);
    if (a1 + 24 <= (unint64_t)v2 && v3 > v2)
    {
      if (*(void *)(a1 + 16) == *(void *)(a1 + 144)) {
        *unint64_t v3 = v2;
      }
    }
    else
    {
      operator delete(v2);
    }
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
  }
}

void std::vector<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,TInlineBufferAllocator<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,30ul>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  unint64_t v1 = *a1;
  int8x8_t v2 = (char *)**a1;
  if (v2)
  {
    BOOL v4 = (char *)v1[1];
    BOOL v5 = (void **)**a1;
    int v6 = v1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = v4 - 104;
        unint64_t v10 = (void **)(v4 - 96);
        std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__destroy_vector::operator()[abi:nn180100](&v10);
        BOOL v4 = v7;
      }
      while (v7 != v2);
      int v6 = *a1;
      BOOL v5 = (void **)**a1;
    }
    v1[1] = v2;
    unint64_t v8 = v6 + 393;
    if (v6 + 3 <= v5 && v8 > v5)
    {
      if (v6[2] == v6[393]) {
        *unint64_t v8 = v5;
      }
    }
    else
    {
      operator delete(v5);
    }
  }
}

uint64_t ZeroCombiningMarkWidths(TRunGlue *a1)
{
  uint64_t v2 = TRunGlue::length(a1);
  if (v2)
  {
    uint64_t v3 = v2;
    char v4 = 0;
    uint64_t v5 = 0;
    int v6 = (double *)MEMORY[0x1E4F1DB30];
    do
    {
      if ((TRunGlue::GetGlyphProps(a1, v5) & 0x1040) != 0)
      {
        double Advance = TRunGlue::GetAdvance(a1, v5);
        double v9 = v8;
        double v11 = v6[1];
        if (Advance != *v6 || v9 != v11)
        {
          double v10 = *v6;
          TRunGlue::SetAdvance(a1, v5, *(CGSize *)(&v11 - 1));
          char v4 = 1;
        }
      }
      ++v5;
    }
    while (v3 != v5);
  }
  else
  {
    char v4 = 0;
  }
  return v4 & 1;
}

uint64_t TRunGlue::GetGlyphProps(TRunGlue *this, uint64_t a2)
{
  if (*((void *)this + 19))
  {
    TRunGlue::FocusOnIndex(this, a2);
    return *(unsigned int *)(*((void *)this + 65) + 4 * (a2 - *((void *)this + 20)));
  }
  else
  {
    uint64_t v5 = *((void *)this + 20) + a2;
    uint64_t v6 = *((void *)this + 65);
    if (v6)
    {
      return *(unsigned int *)(v6 + 4 * v5);
    }
    else
    {
      uint64_t v7 = v5 + 7;
      if (v5 >= 0) {
        uint64_t v7 = *((void *)this + 20) + a2;
      }
      return 32 * ((*(unsigned __int8 *)(*((void *)this + 26) + (v7 >> 3)) >> (v5 & 7)) & 1u);
    }
  }
}

uint64_t ZeroMarkWidths(TRunGlue *CommonTable, uint64_t a2)
{
  uint64_t v2 = CommonTable;
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  if (*(void *)(a2 + 16))
  {
    uint64_t v4 = *((void *)CommonTable + 77);
    uint64_t v5 = *(void *)(v4 + 400);
    if ((*(_DWORD *)(v5 + 184) & 0x400) == 0) {
      TBaseFont::DetermineFontFlags(*(TBaseFont **)(v4 + 400), 0x400u);
    }
    if ((*(_DWORD *)(v5 + 180) & 0x400) != 0) {
      goto LABEL_6;
    }
    CFDataRef CommonTable = (TRunGlue *)TBaseFont::GetCommonTable(*(TBaseFont **)(v4 + 400), 1634561906, 0);
    if (CommonTable) {
      goto LABEL_6;
    }
    CFDataRef CommonTable = (TRunGlue *)TBaseFont::GetCommonTable(*(TBaseFont **)(v4 + 400), 1196643650, 0);
    if (!CommonTable) {
      goto LABEL_6;
    }
    CFDataRef v39 = CommonTable;
    int v40 = *((uint64_t *)v2 + 2) < 1
        ? 0
        : ScriptTagForScriptCode(*(_DWORD *)(*(void *)(*(void *)(*(void *)(*(void *)v2 + 16)
                                                                   + 8 * *((void *)v2 + 1))
                                                       + 48)
                                           + 304));
    unint64_t v44 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v41 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v41 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v42[3] = v41;
    long long v43 = v41;
    v42[1] = v41;
    v42[2] = v41;
    v42[0] = v41;
    CFDataRef CommonTable = (TRunGlue *)OTL::GCommon::GCommon((uint64_t)v42, 0, (unsigned char *)v4, v39, a2, v40, 0);
    if (DWORD2(v43))
    {
LABEL_6:
      uint64_t v6 = *((void *)v2 + 78);
      if ((unint64_t)v6 <= 0x10000) {
        unint64_t v7 = (unint64_t)(v6 + 7) >> 3;
      }
      else {
        unint64_t v7 = 0x2000;
      }
      MEMORY[0x1F4188790](CommonTable, v7);
      double v9 = (unsigned __int8 *)v42 - v8;
      bzero((char *)v42 - v8, v10);
      double v11 = *(unsigned __int16 **)(a2 + 16);
      if (v11) {
        OTL::ClassDefTable::PopulateGlyphClassBitmap(v11, 3, v9, v6);
      }
      int v12 = *((_DWORD *)v2 + 6);
      uint64_t v13 = TRunGlue::length(v2);
      uint64_t v14 = v13;
      if (v12 < 0)
      {
        if (v13)
        {
          char v15 = 0;
          uint64_t v28 = v13 - 1;
          double v29 = 0.0;
          BOOL v30 = (double *)MEMORY[0x1E4F1DB30];
          do
          {
            unsigned int GlyphID = TRunGlue::GetGlyphID(v2, v28);
            if (GlyphID != 0xFFFF)
            {
              unsigned int v32 = GlyphID;
              if (!TRunGlue::IsDeleted(v2, v28))
              {
                if (v6 > v32 && ((v9[(unint64_t)v32 >> 3] >> (v32 & 7)) & 1) != 0)
                {
                  double Advance = TRunGlue::GetAdvance(v2, v28);
                  double v35 = v34;
                  double v29 = v29 + Advance;
                  if (v29 != 0.0 && (TRunGlue::GetGlyphProps(v2, v28) & 0x4000) != 0)
                  {
                    v48.x = TRunGlue::GetOrigin(v2, v28) - v29;
                    TRunGlue::SetOrigin(v2, v28, v48);
                  }
                  double v37 = v30[1];
                  if (Advance != *v30 || v35 != v37)
                  {
                    double v36 = *v30;
                    TRunGlue::SetAdvance(v2, v28, *(CGSize *)(&v37 - 1));
                    char v15 = 1;
                  }
                }
                else
                {
                  double v29 = 0.0;
                }
              }
            }
            --v28;
          }
          while (v28 != -1);
          return v15 & 1;
        }
      }
      else if (v13)
      {
        char v15 = 0;
        uint64_t v16 = 0;
        double v17 = 0.0;
        unsigned int v18 = (double *)MEMORY[0x1E4F1DB30];
        do
        {
          unsigned int v19 = TRunGlue::GetGlyphID(v2, v16);
          if (v19 != 0xFFFF)
          {
            unsigned int v20 = v19;
            if (!TRunGlue::IsDeleted(v2, v16))
            {
              if (v6 > v20 && ((v9[(unint64_t)v20 >> 3] >> (v20 & 7)) & 1) != 0)
              {
                double v21 = TRunGlue::GetAdvance(v2, v16);
                double v23 = v22;
                if (v17 != 0.0 && (TRunGlue::GetGlyphProps(v2, v16) & 0x4000) != 0)
                {
                  v47.x = v17 + TRunGlue::GetOrigin(v2, v16);
                  TRunGlue::SetOrigin(v2, v16, v47);
                }
                double v17 = v17 + v21;
                double v25 = v18[1];
                if (v21 != *v18 || v23 != v25)
                {
                  double v24 = *v18;
                  TRunGlue::SetAdvance(v2, v16, *(CGSize *)(&v25 - 1));
                  char v15 = 1;
                }
              }
              else
              {
                double v17 = 0.0;
              }
            }
          }
          ++v16;
        }
        while (v14 != v16);
        return v15 & 1;
      }
    }
    char v15 = 0;
    return v15 & 1;
  }

  return ZeroCombiningMarkWidths(CommonTable);
}

char *TBaseFont::NthLookup<OTL::GPOS>(uint64_t a1, void *a2, unsigned int a3)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  unsigned int v19 = a3;
  uint64_t v4 = a1 + 400;
  uint64_t v5 = std::__hash_table<std::__hash_value_type<unsigned int,OTL::Lookup>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,OTL::Lookup>>>::find<unsigned int>((void *)(a1 + 400), &v19);
  if (v5) {
    return (char *)(v5 + 3);
  }
  unint64_t v7 = (unsigned __int16 *)a2[8];
  if (v19 >= bswap32(*v7) >> 16) {
    return 0;
  }
  unint64_t v8 = (unint64_t)v7 + (bswap32(v7[v19 + 1]) >> 16);
  unint64_t v10 = a2[4];
  unint64_t v9 = a2[5];
  if (v8 + 4 < v10 || v8 + 6 > v9) {
    return 0;
  }
  unint64_t v12 = v8
      + 2 * (bswap32(*(unsigned __int16 *)(v8 + 4)) >> 16)
      + (((unint64_t)*(unsigned __int16 *)(v8 + 2) >> 11) & 2)
      + 6;
  BOOL v13 = v10 <= v8 && v12 >= v8;
  if (!v13 || v12 > v9) {
    return 0;
  }
  OTL::Lookup::Lookup<OTL::GPOS>((OTL::Lookup *)v22, (uint64_t)a2, v8);
  unsigned int v20 = (long long *)v22;
  double v21 = &v19;
  char v15 = std::__hash_table<std::__hash_value_type<unsigned int,OTL::Lookup>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,OTL::Lookup>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<OTL::Lookup&&>>(v4, &v19, (uint64_t)&std::piecewise_construct, &v21, &v20);
  char v17 = v16;
  OTL::Lookup::~Lookup((OTL::Lookup *)v22);
  if (!v17) {
    return 0;
  }
  uint64_t v6 = (char *)(v15 + 3);
  OTL::Lookup::InitCoverageUnion(v6);
  return v6;
}

uint64_t OTL::Coverage::SearchFmt1Linear(OTL::Coverage *this, int a2)
{
  unint64_t v2 = *((void *)this + 1);
  unint64_t v3 = *(void *)this + 4;
  unsigned int v4 = __rev16(*(unsigned __int16 *)(*(void *)this + 2));
  unint64_t v5 = v3 + 2 * v4;
  if (*(void *)this + 6 <= v2) {
    unsigned int v6 = (v2 - v3) >> 1;
  }
  else {
    unsigned int v6 = 0;
  }
  unsigned int v7 = bswap32(v6) >> 16;
  BOOL v8 = v5 < v3 || v5 > v2;
  if (v8) {
    LOWORD(v9) = v6;
  }
  else {
    LOWORD(v9) = v4;
  }
  if (v8) {
    unsigned int v10 = v7;
  }
  else {
    unsigned int v10 = *(unsigned __int16 *)(*(void *)this + 2);
  }
  if (!v10) {
    return 0;
  }
  uint64_t v11 = 0;
  if ((v9 & 0xFFFE) != 0) {
    uint64_t v9 = (unsigned __int16)v9;
  }
  else {
    uint64_t v9 = 1;
  }
  while (a2 != bswap32(*(unsigned __int16 *)(v3 + 2 * v11)) >> 16)
  {
    if (v9 == ++v11) {
      return 0;
    }
  }
  return (v11 + 1);
}

void *TRunGlue::ComputeEndIndex(void *this)
{
  uint64_t v2 = this[1];
  uint64_t v1 = this[2];
  uint64_t v3 = *(void *)(*this + 16);
  unsigned int v4 = *(void **)(*(void *)(v3 + 8 * v2) + 40);
  uint64_t v5 = v4[26];
  this[4] = v5;
  uint64_t v7 = v4[1];
  uint64_t v6 = v4[2];
  this[5] = v7;
  this[6] = v6;
  if (v1 >= 2)
  {
    uint64_t v8 = v1 + v2;
    uint64_t v9 = v2 + 1;
    do
    {
      unsigned int v10 = *(void **)(*(void *)(v3 + 8 * v9) + 40);
      v5 += v10[26];
      this[4] = v5;
      uint64_t v12 = v10[1];
      uint64_t v11 = v10[2];
      uint64_t v13 = v6 + v7;
      if (v12 < v7) {
        uint64_t v7 = v12;
      }
      uint64_t v14 = v11 + v12;
      if (v13 <= v14) {
        uint64_t v13 = v14;
      }
      uint64_t v6 = v13 - v7;
      this[5] = v7;
      this[6] = v6;
      ++v9;
    }
    while (v9 < v8);
  }
  return this;
}

void *std::__function::__value_func<void ()(CFRange,long)>::swap[abi:nn180100](void *result, void *a2)
{
  v6[3] = *MEMORY[0x1E4F143B8];
  if (a2 != result)
  {
    uint64_t v3 = result;
    unsigned int v4 = (void *)result[3];
    uint64_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        memset(v6, 170, 24);
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

uint64_t OTL::GSUB::ApplyChainContextSubstFormat3(void *a1, unint64_t a2, uint64_t a3, _WORD *a4, uint64_t a5, unint64_t a6)
{
  unint64_t v6 = a1[5];
  uint64_t v7 = (unsigned __int16 *)(a2 + 4);
  if (a2 + 4 > v6) {
    return 0;
  }
  uint64_t v11 = *(void *)(a3 + 48);
  unsigned int v12 = *(unsigned __int16 *)(a2 + 2);
  uint64_t v13 = __rev16(v12);
  if (*(_WORD *)(a2 + 2))
  {
    uint64_t v14 = *(void *)(a3 + 32);
    if (*(int *)(a3 + 8) < 1)
    {
      if (v11 + v13 >= v14) {
        return 0;
      }
    }
    else if (v11 - v13 <= v14)
    {
      return 0;
    }
  }
  char v15 = &v7[v13];
  if ((unint64_t)(v15 + 1) > v6 || !*v15) {
    return 0;
  }
  unsigned int v16 = __rev16(*v15);
  char v17 = &v15[v16 + 1];
  unsigned int v18 = v17 + 1;
  if ((unint64_t)v17 < a2 || (unint64_t)v18 > v6) {
    return 0;
  }
  unsigned int v20 = *v17;
  uint64_t v21 = v16 - 1 + (bswap32(v20) >> 16);
  if (v21)
  {
    uint64_t v22 = *(void *)(a3 + 40);
    if (*(int *)(a3 + 8) < 1)
    {
      if (v11 - v21 <= v22) {
        return 0;
      }
    }
    else if (v11 + v21 >= v22)
    {
      return 0;
    }
  }
  *(void *)&long long v23 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v23 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v40[29] = v23;
  v40[30] = v23;
  v40[27] = v23;
  v40[28] = v23;
  v40[25] = v23;
  v40[26] = v23;
  v40[23] = v23;
  v40[24] = v23;
  v40[21] = v23;
  v40[22] = v23;
  v40[19] = v23;
  v40[20] = v23;
  v40[17] = v23;
  v40[18] = v23;
  v40[16] = v23;
  unint64_t v41 = 0xAAAAAAAAAAAAAAAALL;
  v40[15] = v23;
  v40[14] = v23;
  v40[13] = v23;
  v40[12] = v23;
  v40[11] = v23;
  v40[10] = v23;
  v40[9] = v23;
  v40[8] = v23;
  v40[7] = v23;
  v40[5] = v23;
  v40[6] = v23;
  v40[3] = v23;
  v40[4] = v23;
  v40[1] = v23;
  v40[2] = v23;
  v40[0] = v23;
  uint64_t v39 = v11;
  if (v16 < 2)
  {
    uint64_t v33 = a1;
    unint64_t v25 = 1;
    goto LABEL_23;
  }
  if (v16 > 0x40) {
    return 0;
  }
  uint64_t result = TGlyphIterator::MatchCoverSequenceAndNote(a3, v16 - 1, (uint64_t)(v15 + 2), (uint64_t)v40, a2, v6);
  if (!result) {
    return result;
  }
  uint64_t v33 = a1;
  unint64_t v25 = result + 1;
LABEL_23:
  CFIndex v38 = v11;
  if (!v12
    || (uint64_t result = TGlyphIterator::MatchCoverSequence<(MatchDirection)1>(a3, v11, v13, v7, a2, v6, &v38), result))
  {
    unsigned int v26 = __rev16(v20);
    uint64_t v27 = *(&v39 + v25 - 1);
    CFIndex v37 = v27;
    if (!v20
      || (uint64_t result = TGlyphIterator::MatchCoverSequence<(MatchDirection)0>(a3, v27, v26, v18, a2, v6, &v37), result))
    {
      uint64_t v28 = &v18[v26];
      double v29 = v28 + 1;
      if ((unint64_t)v28 < a2 || (unint64_t)v29 > v6) {
        return 0;
      }
      if (OTL::GSUB::ApplySubstLookupRecords(v33, a2, v29, bswap32(*v28) >> 16, a3, v11, &v39, v25, a4, a5, a6)&& *(void *)(*(void *)a3 + 152))
      {
        if (v38 >= v37) {
          v31.CFIndex location = v37;
        }
        else {
          v31.CFIndex location = v38;
        }
        if (v38 - v37 >= 0) {
          CFIndex v32 = v38 - v37;
        }
        else {
          CFIndex v32 = v37 - v38;
        }
        v31.uint64_t length = v32 + 1;
        TRunGlue::ClearSafeToBreakAfter(*(void *)a3, v31);
      }
      return 1;
    }
  }
  return result;
}

uint64_t std::__hash_table<EncoderAttempt,std::hash<EncoderAttempt>,std::equal_to<EncoderAttempt>,std::allocator<EncoderAttempt>>::~__hash_table(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  unsigned int v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

uint64_t std::__function::__func<OTL::GSUB::ApplyLookups(TRunGlue &,int,OTL::GlyphLookups &,SyncState &,void (*)(void *,CFRange,long),void *)::{lambda(CFRange,long)#1},std::allocator<OTL::GSUB::ApplyLookups(TRunGlue &,int,OTL::GlyphLookups &,SyncState &,void (*)(void *,CFRange,long),void *)::{lambda(CFRange,long)#1}>,void ()(CFRange,long)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1ED0619D0;
  a2[1] = v2;
  return result;
}

void *OTL::GCommon::FeatureTableSubstitutionsForFont@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, atomic_ullong *a3@<X2>, uint64_t a4@<X8>)
{
  v14[4] = *MEMORY[0x1E4F143B8];
  unint64_t v13 = a2;
  *(_OWORD *)a4 = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  *(void *)(a4 + 32) = 0xAAAAAAAA3F800000;
  uint64_t result = (void *)OTL::GCommon::GetFeatureVariationsTable(a1, a2);
  unsigned int v12 = result;
  if (result)
  {
    uint64_t v8 = (uint64_t)result;
    unint64_t v11 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t VariationValues = TFont::GetVariationValues(a3, &v11);
    uint64_t v9 = operator new(0x30uLL);
    *uint64_t v9 = &unk_1ED0613A0;
    v9[1] = &v13;
    v9[2] = &v12;
    void v9[3] = &v11;
    v9[4] = &VariationValues;
    v9[5] = a4;
    v14[3] = v9;
    OTL::GCommon::IterateConditionSetTables((uint64_t)v9, v8, a2, (uint64_t)v14);
    return std::__function::__value_func<BOOL ()(OTL::ConditionSetTable const*,OTL::FeatureTableSubstitutionTable const*,BOOL &)>::~__value_func[abi:nn180100](v14);
  }
  return result;
}

uint64_t OTL::GCommon::GetFeatureVariationsTable(uint64_t a1, unint64_t a2)
{
  if (*(_WORD *)a1 != 256) {
    return 0;
  }
  if (!*(_WORD *)(a1 + 2)) {
    return 0;
  }
  unsigned int v2 = *(_DWORD *)(a1 + 10);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = a1 + bswap32(v2);
  unint64_t v4 = v3 + 8;
  if (v3 + 8 > a2) {
    return 0;
  }
  uint64_t v5 = bswap32(*(_DWORD *)(v3 + 4));
  unint64_t v6 = v4 + 8 * v5;
  unint64_t v7 = v3 + 16 <= a2 ? (a2 - v4) >> 3 : 0;
  BOOL v8 = v6 <= a2 && v6 >= v4;
  if (!v8 && v7 != v5) {
    return 0;
  }
  if (*(_WORD *)v3 == 256) {
    return v3;
  }
  return 0;
}

uint64_t std::__function::__func<OTL::GSUB::ApplySubstLookupRecords(OTL::LookupSubtable const*,OTL::SubstLookupRecord const*,unsigned int,TGlyphIterator &,long,long *,unsigned long,unsigned short *,OTL::SubstitutionState *,unsigned long)::$_1,std::allocator<OTL::GSUB::ApplySubstLookupRecords(OTL::LookupSubtable const*,OTL::SubstLookupRecord const*,unsigned int,TGlyphIterator &,long,long *,unsigned long,unsigned short *,OTL::SubstitutionState *,unsigned long)::$_1>,void ()(CFRange,long)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1ED05D3B8;
  a2[1] = v2;
  return result;
}

uint64_t OTL::GPOS::ApplyLookupSubtable(void *a1, uint64_t a2, int a3, unsigned __int16 *a4, TGlyphIterator *this, uint64_t a6, unsigned int a7, unint64_t a8)
{
  switch(a3)
  {
    case 1:
      uint64_t result = OTL::GPOS::ApplySinglePos((uint64_t)a1, a4, (uint64_t)this, a7);
      break;
    case 2:
      uint64_t result = OTL::GPOS::ApplyPairPos(a1, a4, this, a7);
      break;
    case 3:
      if (*a4 != 256) {
        goto LABEL_20;
      }
      uint64_t result = OTL::GPOS::ApplyCursivePos(a1, (uint64_t)a4, this, a6, a7, HIBYTE(*(unsigned __int16 *)(*(void *)a2 + 2)) & 1);
      break;
    case 4:
      if (*a4 != 256) {
        goto LABEL_20;
      }
      uint64_t result = OTL::GPOS::ApplyMarkBasePos((uint64_t)a1, a4, (uint64_t)this, a7);
      break;
    case 5:
      if (*a4 != 256) {
        goto LABEL_20;
      }
      uint64_t result = OTL::GPOS::ApplyMarkLigPos((uint64_t)a1, a4, this, a7);
      break;
    case 6:
      if (*a4 != 256) {
        goto LABEL_20;
      }
      uint64_t result = OTL::GPOS::ApplyMarkMarkPos((uint64_t)a1, a2, a4, this, a7);
      break;
    case 7:
      unsigned int v9 = bswap32(*a4) >> 16;
      switch(v9)
      {
        case 3u:
          uint64_t result = OTL::GPOS::ApplyContextPosFormat3(a1, (unint64_t)a4, (uint64_t)this, a8);
          break;
        case 2u:
          uint64_t result = OTL::GPOS::ApplyContextPosFormat2(a1, (unint64_t)a4, (uint64_t)this, a8);
          break;
        case 1u:
          uint64_t result = OTL::GPOS::ApplyContextPosFormat1(a1, (unint64_t)a4, this, a7, a8);
          break;
        default:
          goto LABEL_20;
      }
      break;
    case 8:
      unsigned int v10 = bswap32(*a4) >> 16;
      switch(v10)
      {
        case 3u:
          uint64_t result = OTL::GPOS::ApplyChainContextPosFormat3(a1, (unint64_t)a4, (uint64_t)this, a8);
          break;
        case 2u:
          uint64_t result = OTL::GPOS::ApplyChainContextPosFormat2(a1, a4, (uint64_t)this, a8);
          break;
        case 1u:
          uint64_t result = OTL::GPOS::ApplyChainContextPosFormat1(a1, (unint64_t)a4, this, a7, a8);
          break;
        default:
          goto LABEL_20;
      }
      break;
    default:
LABEL_20:
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t OTL::GPOS::ApplyPairPos(void *a1, unsigned __int16 *a2, TGlyphIterator *this, unsigned int a4)
{
  unint64_t v4 = (unsigned __int16 *)a1[5];
  if (a1[4] > (unint64_t)a2 || a2 + 4 > v4) {
    return 0;
  }
  uint64_t v10 = *((void *)this + 6);
  if (!TGlyphIterator::Next(this, 1)) {
    goto LABEL_61;
  }
  uint64_t v51 = *((void *)this + 6);
  unsigned int GlyphID = TRunGlue::GetGlyphID(*(TRunGlue **)this, v51);
  __int32 v12 = __rev16(a2[2]);
  unsigned int v13 = a2[3];
  __int32 v52 = __rev16(v13);
  unsigned int v14 = bswap32(*a2) >> 16;
  if (v14 == 2)
  {
    if (a2 + 8 > v4) {
      goto LABEL_61;
    }
    uint64_t v28 = (unsigned __int16 *)((char *)a2 + (bswap32(a2[4]) >> 16));
    if (v28 + 1 > v4) {
      goto LABEL_61;
    }
    unsigned int v29 = bswap32(*v28) >> 16;
    if (v29 == 2) {
      uint64_t v30 = 6 * (bswap32(v28[1]) >> 16) + 4;
    }
    else {
      uint64_t v30 = v29 == 1 ? 2 * (bswap32(v28[2]) >> 16) + 6 : 0;
    }
    CFRange v31 = (char *)v28 + v30;
    if (v31 < (char *)v28) {
      goto LABEL_61;
    }
    if (v31 > (char *)v4) {
      goto LABEL_61;
    }
    CFIndex v32 = (unsigned __int16 *)((char *)a2 + (bswap32(a2[5]) >> 16));
    if (v32 + 1 > v4) {
      goto LABEL_61;
    }
    unsigned int v33 = bswap32(*v32) >> 16;
    if (v33 == 2) {
      uint64_t v34 = 6 * (bswap32(v32[1]) >> 16) + 4;
    }
    else {
      uint64_t v34 = v33 == 1 ? 2 * (bswap32(v32[2]) >> 16) + 6 : 0;
    }
    double v35 = (char *)v32 + v34;
    if (v35 < (char *)v32 || v35 > (char *)v4) {
      goto LABEL_61;
    }
    __int32 v50 = a2[2];
    unsigned int v36 = TRunGlue::GetGlyphID(*(TRunGlue **)this, v10);
    unsigned int v37 = OTL::ClassDefTable::ClassOf((OTL::ClassDefTable *)v28, v36);
    unsigned int v38 = OTL::ClassDefTable::ClassOf((OTL::ClassDefTable *)v32, GlyphID);
    unsigned int v26 = (unsigned __int16 *)PairPosFormat2::ValuePair((PairPosFormat2 *)a2, v37, v38, (unint64_t)v4);
    unint64_t v25 = a2;
  }
  else
  {
    BOOL v15 = v14 == 1;
    unsigned int v16 = a2 + 5;
    if (!v15 || v16 > v4) {
      goto LABEL_61;
    }
    uint64_t v18 = bswap32(a2[4]) >> 16;
    BOOL v19 = __CFADD__(v16, 2 * v18);
    char v20 = &v16[v18] > v4 || v19;
    unint64_t v21 = (unint64_t)((char *)v4 - (char *)v16) >> 1;
    if (a2 + 6 > v4) {
      unint64_t v21 = 0;
    }
    char v22 = v21 == v18 ? 0 : v20;
    if (v18 < a4) {
      goto LABEL_61;
    }
    if (v22) {
      goto LABEL_61;
    }
    __int32 v50 = a2[2];
    long long v23 = PairPosFormat1::NthPairSet((PairPosFormat1 *)a2, a4 - 1, (unint64_t)v4);
    if (!v23) {
      goto LABEL_61;
    }
    unint64_t v25 = v23;
    unsigned int v26 = PairSet::ValuePair((PairSet *)v23, GlyphID, v12, v52, v4, v24);
  }
  if (!v26)
  {
LABEL_61:
    uint64_t result = 0;
    *((void *)this + 6) = v10;
    return result;
  }
  v27.i32[0] = v50;
  int8x8_t v39 = vcnt_s8(v27);
  v39.i16[0] = vaddlv_u8((uint8x8_t)v39);
  uint64_t v40 = v39.u32[0];
  v39.i32[0] = v13;
  uint8x8_t v41 = (uint8x8_t)vcnt_s8(v39);
  v41.i16[0] = vaddlv_u8(v41);
  uint64_t v42 = (v41.i32[0] + v40);
  if (v26 < a2 || ((long long v43 = &v26[v42], v43 >= v26) ? (v44 = v43 > v4) : (v44 = 1), v44))
  {
    BOOL v45 = v26 + 1 <= v4 && v26 >= a2;
    unint64_t v46 = (unint64_t)((char *)v4 - (char *)v26) >> 1;
    if (!v45) {
      unint64_t v46 = 0;
    }
    if (v46 != v42) {
      return 0;
    }
  }
  if (v50)
  {
    uint64_t v47 = a1[2];
    char v53 = v26;
    __int32 v54 = v12;
    BOOL v55 = v25;
    uint64_t v56 = v47;
    unsigned int v57 = a1;
    ValueRecord::operator()(&v53, *(TRunGlue **)this, v10);
  }
  if (v13)
  {
    uint64_t v48 = a1[2];
    char v53 = &v26[v40];
    __int32 v54 = v52;
    BOOL v55 = v25;
    uint64_t v56 = v48;
    unsigned int v57 = a1;
    ValueRecord::operator()(&v53, *(TRunGlue **)this, v51);
  }
  else
  {
    *((void *)this + 6) = v10;
  }
  return 1;
}

CGFloat CTFontGetDescent(CTFontRef font)
{
  if (!font) {
    return 0.0;
  }
  uint64_t v1 = (int *)*((void *)font + 5);
  if (v1[12]) {
    inited = v1 + 12;
  }
  else {
    inited = TFont::InitStrikeMetrics((TFont *)v1);
  }
  return *((double *)inited + 2);
}

double CTFontGetAscentForSystemFontOfSize(double a1)
{
  return (double)*((int *)kFont2X + 6) * a1 / *((double *)kFont2X + 1);
}

uint64_t CTLineIsRightToLeft(uint64_t result)
{
  if (result) {
    return (*(unsigned __int16 *)(*(void *)(result + 40) + 152) >> 3) & 1;
  }
  return result;
}

uint64_t TAttributes::HandleRunDelegateAttribute(uint64_t result, uint64_t a2)
{
  if (result) {
    *(_WORD *)(*(void *)a2 + 138) |= 0x40u;
  }
  return result;
}

void *TCFBase<TRunDelegate>::ClassHash(void *result)
{
  unint64_t v1 = result[3];
  uint64_t v2 = result[4];
  if (v2) {
    BOOL v3 = (result[4] & 1 | v1) == 0;
  }
  else {
    BOOL v3 = 1;
  }
  int v4 = !v3;
  if (v1) {
    BOOL v5 = 0;
  }
  else {
    BOOL v5 = v4 == 0;
  }
  if (!v5)
  {
    unint64_t v6 = (void *)(result[5] + (v2 >> 1));
    if (v2) {
      return (void *)(*(uint64_t (**)(void))(*v6 + v1))();
    }
    else {
      return (void *)((uint64_t (*)(void *))v1)(v6);
    }
  }
  return result;
}

TDescriptorSource *CTFontDescriptorCanCreateWithTextStyle(TDescriptorSource *a1)
{
  TDescriptorSource::TDescriptorSource((TDescriptorSource *)v4);
  return TDescriptorSource::IsValidTextStyle(a1, v2);
}

BOOL TBaseFont::GetStrikeMetricsForSystemFont(atomic_ullong *this, char a2, StrikeMetrics *a3, double a4)
{
  if (a2) {
    return 0;
  }
  id v19 = (id)0xAAAAAAAAAAAAAAAALL;
  CopyStrikeMetricsDictionaryRepresentationForSystemFont((const __CFString *)atomic_load_explicit(this + 12, memory_order_acquire), &v19);
  unint64_t explicit = (void *)atomic_load_explicit((atomic_ullong *volatile)&v19, memory_order_acquire);
  BOOL v4 = explicit != 0;
  if (explicit)
  {
    int v8 = objc_msgSend((id)objc_msgSend(explicit, "objectForKeyedSubscript:", @"unitsPerEm"), "unsignedIntValue");
    long long v18 = *MEMORY[0x1E4F1DAD8];
    long long v16 = *MEMORY[0x1E4F1DB28];
    long long v17 = *(_OWORD *)(MEMORY[0x1E4F1DB28] + 16);
    *(_DWORD *)a3 = v8;
    *(_OWORD *)((char *)a3 + 24) = 0u;
    *(_OWORD *)((char *)a3 + 8) = 0u;
    *(_OWORD *)((char *)a3 + 40) = v18;
    *(_OWORD *)((char *)a3 + 56) = v16;
    *(_OWORD *)((char *)a3 + 72) = v17;
    *((unsigned char *)a3 + 88) = 0;
    objc_msgSend((id)objc_msgSend(explicit, "objectForKeyedSubscript:", @"ascent", v16, v17, v18), "doubleValue");
    *((void *)a3 + 1) = v9;
    objc_msgSend((id)objc_msgSend(explicit, "objectForKeyedSubscript:", @"descent"), "doubleValue");
    *((void *)a3 + 2) = v10;
    objc_msgSend((id)objc_msgSend(explicit, "objectForKeyedSubscript:", @"leading"), "doubleValue");
    *((void *)a3 + 3) = v11;
    __int32 v12 = (void *)[explicit objectForKeyedSubscript:@"capHeight"];
    if (v12)
    {
      [v12 doubleValue];
    }
    else
    {
      InitializedGraphicsFont = (CGFont *)TBaseFont::GetInitializedGraphicsFont((TBaseFont *)this);
      double CapHeight = (double)CGFontGetCapHeight(InitializedGraphicsFont);
    }
    *((double *)a3 + 4) = CapHeight;
    CGRectMakeWithDictionaryRepresentation((CFDictionaryRef)[explicit objectForKeyedSubscript:@"bbox"], (CGRect *)((char *)a3 + 56));
    *((unsigned char *)a3 + 88) = objc_msgSend((id)objc_msgSend(explicit, "objectForKeyedSubscript:", @"forceAscenderDelta"), "BOOLValue");
  }

  return v4;
}

uint64_t TBaseFont::SystemUIFontAttributesForSymbolicTraits(TBaseFont *this, atomic_ullong *a2, uint64_t *a3, int a4, const TDescriptor *a5)
{
  int v10 = *((_DWORD *)a5 + 4);
  if ((TDescriptor::GetSystemUIFontOptions(this) & v10) != 0)
  {
    id v48 = (id)0xAAAAAAAAAAAAAAAALL;
    TDescriptor::CopyAttribute((atomic_ullong *)a5, @"NSCTFontUIUsageAttribute", &v47);
    id v48 = (id)atomic_exchange((atomic_ullong *volatile)&v47, 0);

    if (!atomic_load_explicit((atomic_ullong *volatile)&v48, memory_order_acquire))
    {
      TBaseFont::CopyAttributeInternal((atomic_ullong *)this, @"NSCTFontUIUsageAttribute", &v47);
    }
    if (atomic_load_explicit((atomic_ullong *volatile)&v48, memory_order_acquire)
      && (FontNameForTextStyle = (TDescriptorSource *)TDescriptorSource::FindFontNameForTextStyle((TDescriptorSource *)atomic_load_explicit((atomic_ullong *volatile)&v48, memory_order_acquire), 0, 0, 0, 0, (const __CFString **)v11)) != 0|| this&& ((int v13 = (*(uint64_t (**)(TBaseFont *))(*(void *)this + 16))(this), v13 != 1414809156)? (v14 = v13 == 1413695044): (v14 = 1), v14&& (explicit = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)this + 90, memory_order_acquire)) != 0&& (FontNameForTextStyle = (TDescriptorSource *)CFDictionaryGetValue(explicit, @"name")) != 0))
    {

      goto LABEL_24;
    }
    atomic_load_explicit((atomic_ullong *volatile)a5 + 1, memory_order_acquire);
    CFDictionaryRef v16 = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)a5 + 1, memory_order_acquire);
    if (v16)
    {
      FontNameForTextStyle = (TDescriptorSource *)CFDictionaryGetValue(v16, @"NSFontNameAttribute");

      if (FontNameForTextStyle) {
        goto LABEL_24;
      }
    }
    else
    {
    }
  }
  if ((*((_DWORD *)a5 + 4) & 0x80000000) == 0) {
    TDescriptor::InitBaseFont(a5, 0, 0.0);
  }
  long long v17 = (atomic_ullong *)atomic_load_explicit((atomic_ullong *volatile)a5 + 4, memory_order_acquire);
  if (!v17) {
    return 0;
  }
  if ((*(unsigned int (**)(atomic_ullong *))(*v17 + 16))(v17) != 1414743620) {
    return 0;
  }
  FontNameForTextStyle = (TDescriptorSource *)atomic_load_explicit(v17 + 12, memory_order_acquire);
  if (!FontNameForTextStyle) {
    return 0;
  }
LABEL_24:
  CFStringRef v18 = (const __CFString *)(*(uint64_t (**)(TBaseFont *))(*(void *)this + 160))(this);
  uint64_t result = (uint64_t)TDescriptorSource::FindFontNameForNameAndTrait(FontNameForTextStyle, v18, a3, a4);
  if (!result) {
    return result;
  }
  char v20 = (TDescriptorSource *)result;
  CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit(a2, memory_order_acquire), @"NSFontNameAttribute", (const void *)result);
  long long v23 = (const void *)TDescriptorSource::TextStyleForUIFontName(v20, v21, v22);
  if (!v23) {
    goto LABEL_63;
  }
  CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit(a2, memory_order_acquire), @"NSCTFontUIUsageAttribute", v23);
  id v48 = (id)0xAAAAAAAAAAAAAAAALL;
  TDescriptor::CopyAttribute((atomic_ullong *)a5, @"NSCTFontTextStyleTraitsAttribute", &v47);
  id v48 = (id)atomic_exchange((atomic_ullong *volatile)&v47, 0);

  if ((a4 & 2) != 0)
  {
    CFDictionaryRef v25 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)&v48, memory_order_acquire);
    CFDictionaryRef v26 = v25;
    if (v25) {
      BOOL v24 = CFDictionaryContainsKey(v25, @"NSCTFontWeightTrait") != 0;
    }
    else {
      BOOL v24 = 0;
    }
  }
  else
  {
    BOOL v24 = 0;
  }
  if ((a4 & 0x60) != 0)
  {
    CFDictionaryRef v27 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)&v48, memory_order_acquire);
    CFDictionaryRef v28 = v27;
    if (v27) {
      BOOL v29 = CFDictionaryContainsKey(v27, @"NSCTFontProportionTrait") != 0;
    }
    else {
      BOOL v29 = 0;
    }
  }
  else
  {
    BOOL v29 = 0;
  }
  if (v24 || v29)
  {
    id v47 = (id)0xAAAAAAAAAAAAAAAALL;
    TCFMutableDictionary::TCFMutableDictionary((TCFMutableDictionary *)&v47, (CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v48, memory_order_acquire));
    if (v24) {
      CFDictionaryRemoveValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v47, memory_order_acquire), @"NSCTFontWeightTrait");
    }
    if (v29) {
      CFDictionaryRemoveValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v47, memory_order_acquire), @"NSCTFontProportionTrait");
    }
    TCFRef<__CTFont const*>::Retain((atomic_ullong *)&v48, (id)atomic_load_explicit((atomic_ullong *volatile)&v47, memory_order_acquire));
  }
  unsigned int valuePtr = 0;
  CFDictionaryRef v30 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)&v48, memory_order_acquire);
  if (v30)
  {
    CFDictionaryRef v31 = v30;
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v30, @"NSCTFontSymbolicTrait");

    if (Value) {
      CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
    }
    if ((a4 & 1) == 0) {
      goto LABEL_49;
    }
LABEL_51:
    unsigned int v33 = (a3 & 1) != 0 && CFStringFind((CFStringRef)v20, @"Italic", 0).location == -1;
    goto LABEL_54;
  }

  if (a4) {
    goto LABEL_51;
  }
LABEL_49:
  unsigned int v33 = valuePtr;
LABEL_54:
  if (v33 != valuePtr)
  {
    CreateTraitsWithSymbolicTraits((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v48, memory_order_acquire), v33, v33 | a4, (CFDictionaryRef *)&v47);
  }
  CFDictionaryRef v34 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)&v48, memory_order_acquire);
  if (v34)
  {
    CFDictionaryRef v35 = v34;
    CFIndex Count = CFDictionaryGetCount(v34);

    if (Count) {
      CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit(a2, memory_order_acquire), @"NSCTFontTraitsAttribute", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v48, memory_order_acquire));
    }
  }
  else
  {
  }
  TDescriptor::CopyAttribute((atomic_ullong *)a5, @"NSCTFontTextStylePlatformAttribute", &v47);
  unsigned int v37 = (void *)atomic_exchange((atomic_ullong *volatile)&v47, 0);

  if (v37) {
    CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit(a2, memory_order_acquire), @"NSCTFontTextStylePlatformAttribute", v37);
  }

LABEL_63:
  TDescriptor::CopyAttribute((atomic_ullong *)a5, @"NSCTFontOpticalSizeAttribute", &v48);
  unsigned int v38 = (void *)atomic_exchange((atomic_ullong *volatile)&v48, 0);

  if (v38) {
    CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit(a2, memory_order_acquire), @"NSCTFontOpticalSizeAttribute", v38);
  }
  id v48 = (id)0xAAAAAAAAAAAAAAAALL;
  TDescriptor::CopyAttribute((atomic_ullong *)a5, @"NSFontSizeAttribute", &v47);
  id v48 = (id)atomic_exchange((atomic_ullong *volatile)&v47, 0);

  TDescriptor::CopyAttribute((atomic_ullong *)a5, @"NSCTFontSizeCategoryAttribute", &v47);
  int8x8_t v39 = (void *)atomic_exchange((atomic_ullong *volatile)&v47, 0);

  if (v39)
  {
    CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit(a2, memory_order_acquire), @"NSCTFontSizeCategoryAttribute", v39);
    unint64_t v40 = atomic_load_explicit((atomic_ullong *volatile)&v48, memory_order_acquire);
    if ((a3 & 0x40) != 0 || !v40)
    {
      TDescriptor::CopyAttribute((atomic_ullong *)a5, @"NSCTFontTextStylePlatformAttribute", &v47);
      uint8x8_t v41 = (void *)atomic_exchange((atomic_ullong *volatile)&v47, 0);

      CFNumberRef v42 = v39;
      LODWORD(v47) = -1431655766;
      CFNumberGetValue(v42, kCFNumberIntType, &v47);
      unsigned int v43 = v47;
      if (v41)
      {
        CFNumberRef v44 = v41;
        LODWORD(v47) = -1431655766;
        CFNumberGetValue(v44, kCFNumberIntType, &v47);
        double v45 = TDescriptorSource::MapTextStyleSizeCategory(v20, v43, (uint64_t *)v47, 0, 0, 0, 0);
      }
      else
      {
        double v45 = TDescriptorSource::MapTextStyleSizeCategory(v20, v47, (uint64_t *)0xFFFFFFFFLL, 0, 0, 0, 0);
      }

      TCFNumber::TCFNumber<double>(&v47, v45);
    }
  }
  if (atomic_load_explicit((atomic_ullong *volatile)&v48, memory_order_acquire)) {
    CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit(a2, memory_order_acquire), @"NSFontSizeAttribute", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v48, memory_order_acquire));
  }
  id v47 = (id)0xAAAAAAAAAAAAAAAALL;
  TDescriptor::CopyAttribute((atomic_ullong *)a5, @"NSCTFontFeatureSettingsAttribute", &v47);
  if (atomic_load_explicit((atomic_ullong *volatile)&v47, memory_order_acquire)) {
    CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit(a2, memory_order_acquire), @"NSCTFontFeatureSettingsAttribute", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v47, memory_order_acquire));
  }

  return 1;
}

void TTenuousComponentFont::CopyAttribute(atomic_ullong *this@<X0>, uint64_t a2@<X1>, atomic_ullong *a3@<X8>)
{
  uint64_t v98 = *MEMORY[0x1E4F143B8];
  if (a2 <= 14)
  {
    if (a2 == 5)
    {
      v94.i64[0] = 0xAAAAAAAAAAAAAAAALL;
      (*(void (**)(int64x2_t *__return_ptr, atomic_ullong *))(*this + 152))(&v94, this);
      v90[0] = (id)atomic_exchange(v94.i64, 0);

      *a3 = atomic_exchange((atomic_ullong *volatile)v90, 0);
      id v7 = v90[0];
    }
    else
    {
      if (a2 != 7)
      {
        if (a2 != 12)
        {
LABEL_11:
          if ((*(uint64_t (**)(atomic_ullong *))(*this + 896))(this))
          {
LABEL_12:
            TBaseFont::CopyAttribute((TBaseFont *)this, a2, a3);
            return;
          }
        }
LABEL_50:
        *a3 = 0;
        return;
      }
      (*(void (**)(int64x2_t *__return_ptr, atomic_ullong *))(*this + 112))(&v94, this);
      unint64_t v8 = atomic_exchange(v94.i64, 0);
LABEL_37:
      *a3 = v8;
LABEL_38:
      id v7 = (id)v94.i64[0];
    }

    return;
  }
  switch(a2)
  {
    case '+':
      CFStringRef v6 = @"NSCTFontUIUsageAttribute";
      goto LABEL_16;
    case ',':
    case '-':
    case '.':
    case '/':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
      goto LABEL_11;
    case '0':
      CFStringRef v6 = @"sizeCategory";
LABEL_16:
      ComponentAttribute = (void *)TComponentFont::GetComponentAttribute(this, v6);
      goto LABEL_137;
    case '8':
      CFDictionaryRef v10 = (const __CFDictionary *)(id)atomic_load_explicit(this + 90, memory_order_acquire);
      CFDictionaryRef v11 = v10;
      if (!v10) {
        goto LABEL_45;
      }
      __int32 v12 = @"platform";
      goto LABEL_44;
    case '9':
      if (atomic_load_explicit(this + 97, memory_order_acquire)) {
        goto LABEL_136;
      }
      *(void *)&long long v13 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v96[14] = v13;
      v96[13] = v13;
      v96[12] = v13;
      v96[11] = v13;
      v96[10] = v13;
      v96[9] = v13;
      v96[8] = v13;
      v96[7] = v13;
      v96[6] = v13;
      v96[5] = v13;
      v96[4] = v13;
      v96[3] = v13;
      v96[2] = v13;
      v96[1] = v13;
      v96[0] = v13;
      int64x2_t v94 = 0uLL;
      BOOL v95 = 0;
      unsigned int v97 = v96;
      v92[14] = v13;
      v92[13] = v13;
      v92[12] = v13;
      v92[11] = v13;
      v92[10] = v13;
      v92[9] = v13;
      v92[8] = v13;
      v92[7] = v13;
      v92[6] = v13;
      v92[5] = v13;
      v92[4] = v13;
      v92[3] = v13;
      v92[2] = v13;
      v92[1] = v13;
      v92[0] = v13;
      v90[1] = 0;
      unsigned __int16 v91 = 0;
      v90[0] = 0;
      uint64_t v93 = v92;
      if (((*(uint64_t (**)(atomic_ullong *))(*this + 856))(this) & 1) != 0
        || (*(unsigned int (**)(atomic_ullong *))(*this + 848))(this))
      {
        BOOL v14 = (__CFString *)(*(uint64_t (**)(atomic_ullong *))(*this + 536))(this);
        if (v14)
        {
          p_isa = &v14->isa;
          if (v14 != @"NSCTFontUIFontDesignDefault"
            && (!@"NSCTFontUIFontDesignDefault" || !CFEqual(v14, @"NSCTFontUIFontDesignDefault")))
          {
            std::vector<__CFString const*,TInlineBufferAllocator<__CFString const*,30ul>>::push_back[abi:nn180100]((uint64_t)&v94, &kCTFontUIFontDesignTrait);
            double valuePtr = *(double *)&p_isa;
            std::vector<__CFString const*,TInlineBufferAllocator<__CFString const*,30ul>>::push_back[abi:nn180100]((uint64_t)v90, &valuePtr);
          }
        }
      }
      CFDictionaryRef v16 = (const __CFDictionary *)(id)atomic_load_explicit(this + 90, memory_order_acquire);
      if (v16)
      {
        CFDictionaryRef v17 = v16;
        CFNumberRef Value = CFDictionaryGetValue(v16, @"weight");

        if (Value)
        {
          uint64_t v19 = v94.i64[1];
          if (v94.i64[1] >= (unint64_t)v95)
          {
            uint64_t v23 = (v94.i64[1] - v94.i64[0]) >> 3;
            if ((unint64_t)(v23 + 1) >> 61) {
              goto LABEL_139;
            }
            unint64_t v24 = (uint64_t)&v95[-v94.i64[0]] >> 2;
            if (v24 <= v23 + 1) {
              unint64_t v24 = v23 + 1;
            }
            if ((unint64_t)&v95[-v94.i64[0]] >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v25 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v25 = v24;
            }
            BOOL v89 = v96;
            if (v25) {
              CFDictionaryRef v26 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v96, v25);
            }
            else {
              CFDictionaryRef v26 = 0;
            }
            CFDictionaryRef v27 = &v26[8 * v23];
            CFDictionaryRef v28 = &v26[8 * v25];
            unsigned int v88 = v28;
            *(void *)CFDictionaryRef v27 = @"NSCTFontWeightTrait";
            char v20 = v27 + 8;
            v87.i64[1] = (uint64_t)(v27 + 8);
            uint64_t v29 = v94.i64[1];
            uint64_t v30 = v94.i64[0];
            if (v94.i64[1] == v94.i64[0])
            {
              int64x2_t v32 = vdupq_n_s64(v94.u64[1]);
            }
            else
            {
              do
              {
                uint64_t v31 = *(void *)(v29 - 8);
                v29 -= 8;
                *((void *)v27 - 1) = v31;
                v27 -= 8;
              }
              while (v29 != v30);
              int64x2_t v32 = v94;
              char v20 = (void *)v87.i64[1];
              CFDictionaryRef v28 = v88;
            }
            v94.i64[0] = (uint64_t)v27;
            v94.i64[1] = (uint64_t)v20;
            int64x2_t v87 = v32;
            unsigned int v33 = v95;
            BOOL v95 = v28;
            unsigned int v88 = v33;
            double valuePtr = *(double *)v32.i64;
            std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&valuePtr);
          }
          else
          {
            *(void *)v94.i64[1] = @"NSCTFontWeightTrait";
            char v20 = (void *)(v19 + 8);
          }
          v94.i64[1] = (uint64_t)v20;
          CFDictionaryRef v34 = (char *)v90[1];
          if (v90[1] >= v91)
          {
            int64_t v36 = ((char *)v90[1] - (char *)v90[0]) >> 3;
            if ((unint64_t)(v36 + 1) >> 61) {
              goto LABEL_139;
            }
            unint64_t v37 = (v91 - (char *)v90[0]) >> 2;
            if (v37 <= v36 + 1) {
              unint64_t v37 = v36 + 1;
            }
            if ((unint64_t)(v91 - (char *)v90[0]) >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v38 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v38 = v37;
            }
            BOOL v89 = v92;
            if (v38) {
              int8x8_t v39 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v92, v38);
            }
            else {
              int8x8_t v39 = 0;
            }
            unint64_t v40 = &v39[8 * v36];
            uint8x8_t v41 = &v39[8 * v38];
            unsigned int v88 = v41;
            *(void *)unint64_t v40 = Value;
            CFDictionaryRef v35 = v40 + 8;
            v87.i64[1] = (uint64_t)(v40 + 8);
            unsigned int v43 = (char *)v90[0];
            CFNumberRef v42 = (char *)v90[1];
            if (v90[1] == v90[0])
            {
              int64x2_t v45 = vdupq_n_s64((unint64_t)v90[1]);
            }
            else
            {
              do
              {
                uint64_t v44 = *((void *)v42 - 1);
                v42 -= 8;
                *((void *)v40 - 1) = v44;
                v40 -= 8;
              }
              while (v42 != v43);
              int64x2_t v45 = *(int64x2_t *)v90;
              CFDictionaryRef v35 = (void *)v87.i64[1];
              uint8x8_t v41 = v88;
            }
            v90[0] = v40;
            v90[1] = v35;
            int64x2_t v87 = v45;
            unint64_t v46 = v91;
            unsigned __int16 v91 = v41;
            unsigned int v88 = v46;
            double valuePtr = *(double *)v45.i64;
            std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&valuePtr);
          }
          else
          {
            *(void *)v90[1] = Value;
            CFDictionaryRef v35 = v34 + 8;
          }
          v90[1] = v35;
        }
      }
      else
      {
      }
      CFDictionaryRef v47 = (const __CFDictionary *)(id)atomic_load_explicit(this + 90, memory_order_acquire);
      if (v47)
      {
        CFDictionaryRef v48 = v47;
        CFDictionaryRef v49 = (const __CFDictionary *)CFDictionaryGetValue(v47, @"FontMetrics");

        if (v49)
        {
          CFNumberRef v50 = (const __CFNumber *)CFDictionaryGetValue(v49, @"width");
          if (v50)
          {
            uint64_t v51 = (void **)v50;
            double valuePtr = NAN;
            CFNumberGetValue(v50, kCFNumberDoubleType, &valuePtr);
            if (valuePtr != 0.0)
            {
              std::vector<__CFString const*,TInlineBufferAllocator<__CFString const*,30ul>>::push_back[abi:nn180100]((uint64_t)&v94, &kCTFontWidthTrait);
              double valuePtr = *(double *)&v51;
              std::vector<__CFString const*,TInlineBufferAllocator<__CFString const*,30ul>>::push_back[abi:nn180100]((uint64_t)v90, &valuePtr);
            }
          }
          CFStringRef v52 = (const __CFString *)TComponentFont::GetComponentAttribute(this, @"NSCTFontUIUsageAttribute");
          if (v52
            && CFStringFind(v52, @"Italic", 0).location == -1
            && CFDictionaryGetValue(v49, @"italicAngle"))
          {
            std::vector<__CFString const*,TInlineBufferAllocator<__CFString const*,30ul>>::push_back[abi:nn180100]((uint64_t)&v94, &kCTFontSymbolicTrait);
            double valuePtr = COERCE_DOUBLE(&unk_1ED082E18);
            std::vector<__CFString const*,TInlineBufferAllocator<__CFString const*,30ul>>::push_back[abi:nn180100]((uint64_t)v90, &valuePtr);
          }
        }
      }
      else
      {
      }
      CFDictionaryRef v53 = (const __CFDictionary *)(id)atomic_load_explicit(this + 90, memory_order_acquire);
      if (!v53)
      {

        goto LABEL_130;
      }
      CFDictionaryRef v54 = v53;
      BOOL v55 = CFDictionaryGetValue(v53, @"grade");

      if (!v55) {
        goto LABEL_130;
      }
      uint64_t v56 = v94.i64[1];
      if (v94.i64[1] >= (unint64_t)v95)
      {
        uint64_t v58 = (v94.i64[1] - v94.i64[0]) >> 3;
        if ((unint64_t)(v58 + 1) >> 61) {
          goto LABEL_139;
        }
        unint64_t v59 = (uint64_t)&v95[-v94.i64[0]] >> 2;
        if (v59 <= v58 + 1) {
          unint64_t v59 = v58 + 1;
        }
        if ((unint64_t)&v95[-v94.i64[0]] >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v60 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v60 = v59;
        }
        BOOL v89 = v96;
        if (v60) {
          BOOL v61 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v96, v60);
        }
        else {
          BOOL v61 = 0;
        }
        BOOL v62 = &v61[8 * v58];
        unsigned int v63 = &v61[8 * v60];
        unsigned int v88 = v63;
        *(void *)BOOL v62 = @"NSCTFontGradeTrait";
        unsigned int v57 = v62 + 8;
        v87.i64[1] = (uint64_t)(v62 + 8);
        uint64_t v64 = v94.i64[1];
        uint64_t v65 = v94.i64[0];
        if (v94.i64[1] == v94.i64[0])
        {
          int64x2_t v67 = vdupq_n_s64(v94.u64[1]);
        }
        else
        {
          do
          {
            uint64_t v66 = *(void *)(v64 - 8);
            v64 -= 8;
            *((void *)v62 - 1) = v66;
            v62 -= 8;
          }
          while (v64 != v65);
          int64x2_t v67 = v94;
          unsigned int v57 = (void *)v87.i64[1];
          unsigned int v63 = v88;
        }
        v94.i64[0] = (uint64_t)v62;
        v94.i64[1] = (uint64_t)v57;
        int64x2_t v87 = v67;
        char v68 = v95;
        BOOL v95 = v63;
        unsigned int v88 = v68;
        double valuePtr = *(double *)v67.i64;
        std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&valuePtr);
      }
      else
      {
        *(void *)v94.i64[1] = @"NSCTFontGradeTrait";
        unsigned int v57 = (void *)(v56 + 8);
      }
      v94.i64[1] = (uint64_t)v57;
      unsigned int v69 = (char *)v90[1];
      if (v90[1] >= v91)
      {
        int64_t v71 = ((char *)v90[1] - (char *)v90[0]) >> 3;
        if (!((unint64_t)(v71 + 1) >> 61))
        {
          unint64_t v72 = (v91 - (char *)v90[0]) >> 2;
          if (v72 <= v71 + 1) {
            unint64_t v72 = v71 + 1;
          }
          if ((unint64_t)(v91 - (char *)v90[0]) >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v73 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v73 = v72;
          }
          BOOL v89 = v92;
          if (v73) {
            char v74 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v92, v73);
          }
          else {
            char v74 = 0;
          }
          unsigned int v75 = &v74[8 * v71];
          BOOL v76 = &v74[8 * v73];
          unsigned int v88 = v76;
          *(void *)unsigned int v75 = v55;
          uint64_t v70 = v75 + 8;
          v87.i64[1] = (uint64_t)(v75 + 8);
          BOOL v78 = (char *)v90[0];
          unsigned int v77 = (char *)v90[1];
          if (v90[1] == v90[0])
          {
            int64x2_t v80 = vdupq_n_s64((unint64_t)v90[1]);
          }
          else
          {
            do
            {
              uint64_t v79 = *((void *)v77 - 1);
              v77 -= 8;
              *((void *)v75 - 1) = v79;
              v75 -= 8;
            }
            while (v77 != v78);
            int64x2_t v80 = *(int64x2_t *)v90;
            uint64_t v70 = (void *)v87.i64[1];
            BOOL v76 = v88;
          }
          v90[0] = v75;
          v90[1] = v70;
          int64x2_t v87 = v80;
          BOOL v81 = v91;
          unsigned __int16 v91 = v76;
          unsigned int v88 = v81;
          double valuePtr = *(double *)v80.i64;
          std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&valuePtr);
          goto LABEL_129;
        }
LABEL_139:
        abort();
      }
      *(void *)v90[1] = v55;
      uint64_t v70 = v69 + 8;
LABEL_129:
      v90[1] = v70;
LABEL_130:
      if (v94.i64[0] != v94.i64[1])
      {
        char v82 = (void **)CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)v94.i64[0], (const void **)v90[0], (v94.i64[1] - v94.i64[0]) >> 3, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        uint64_t v83 = 0;
        double valuePtr = *(double *)&v82;
        unint64_t v84 = atomic_exchange((atomic_ullong *volatile)&valuePtr, 0);
        atomic_compare_exchange_strong(this + 97, (unint64_t *)&v83, v84);
        if (v83) {
          unsigned int v85 = (void *)v84;
        }
        else {
          unsigned int v85 = 0;
        }
      }
      double valuePtr = COERCE_DOUBLE(v90);
      std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&valuePtr);
      v90[0] = &v94;
      std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v90);
LABEL_136:
      ComponentAttribute = (void *)atomic_load_explicit(this + 97, memory_order_acquire);
LABEL_137:
      *a3 = (atomic_ullong)ComponentAttribute;
      return;
    case ':':
      CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit(this + 90, memory_order_acquire);
      if (!explicit) {
        goto LABEL_36;
      }
      char v22 = @"languageAwareLineHeightRatio";
      goto LABEL_35;
    case ';':
      CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit(this + 90, memory_order_acquire);
      if (!explicit) {
        goto LABEL_36;
      }
      char v22 = @"lineSpacingOverride";
LABEL_35:
      CFDictionaryRef explicit = (const __CFDictionary *)CFDictionaryGetValue(explicit, v22);
LABEL_36:
      v94.i64[0] = (uint64_t)explicit;
      unint64_t v8 = atomic_exchange(v94.i64, 0);
      goto LABEL_37;
    case '<':
      CFDictionaryRef v10 = (const __CFDictionary *)(id)atomic_load_explicit(this + 90, memory_order_acquire);
      CFDictionaryRef v11 = v10;
      if (!v10) {
        goto LABEL_45;
      }
      __int32 v12 = @"legibilityWeight";
      goto LABEL_44;
    case '=':
      CFDictionaryRef v10 = (const __CFDictionary *)(id)atomic_load_explicit(this + 90, memory_order_acquire);
      CFDictionaryRef v11 = v10;
      if (!v10) {
        goto LABEL_45;
      }
      __int32 v12 = @"ignoreLegibilityWeight";
LABEL_44:
      CFDictionaryRef v10 = (const __CFDictionary *)CFDictionaryGetValue(v11, v12);
LABEL_45:
      *a3 = (atomic_ullong)v10;

      return;
    case '>':
      if ((this[89] & 4) == 0 || *((unsigned char *)this + 792)) {
        goto LABEL_50;
      }
      v94.i64[0] = 0xAAAAAAAAAAAAAAAALL;
      TTenuousComponentFont::CopyDefaultVariation((TTenuousComponentFont *)&v94, (uint64_t)this);
      CreateCodableVariationFromDefaultVariation((const __CFDictionary *)atomic_load_explicit(this + 96, memory_order_acquire), (const __CFDictionary *)atomic_load_explicit(v94.i64, memory_order_acquire), (unint64_t *)v90);
      *a3 = atomic_exchange((atomic_ullong *volatile)v90, 0);

      goto LABEL_38;
    default:
      if (a2 != 15) {
        goto LABEL_11;
      }
      goto LABEL_12;
  }
}

id TDescriptor::CopyAttribute@<X0>(atomic_ullong *this@<X0>, const __CFString *key@<X2>, void *a3@<X8>)
{
  atomic_load_explicit(this + 1, memory_order_acquire);
  CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit(this + 1, memory_order_acquire);
  if (explicit && (CFNumberRef Value = (void *)CFDictionaryGetValue(explicit, key)) != 0)
  {
    id result = Value;
    *a3 = result;
  }
  else
  {
    if ((this[2] & 0x80000000) == 0) {
      TDescriptor::InitBaseFont((TDescriptor *)this, 0, 0.0);
    }
    id result = (id)atomic_load_explicit(this + 4, memory_order_acquire);
    if (result)
    {
      unint64_t v8 = *(uint64_t (**)(void))(*(void *)result + 40);
      return (id)v8();
    }
    else
    {
      *a3 = 0;
    }
  }
  return result;
}

uint64_t TComponentFont::IsTextStyleFont(TComponentFont *this)
{
  return (*((unsigned __int8 *)this + 713) >> 3) & 1;
}

unsigned int *TComponentFont::GetSymbolicTraitsInternal(atomic_ullong *this)
{
  if ((*(unsigned int (**)(atomic_ullong *))(*this + 840))(this)) {
    return (unsigned int *)*((unsigned int *)this + 163);
  }
  id result = (unsigned int *)atomic_load_explicit(this + 30, memory_order_acquire);
  if (result) {
    return (unsigned int *)*result;
  }
  id result = (unsigned int *)TBaseFont::CreateTraitsValues((TBaseFont *)this);
  if (result) {
    return (unsigned int *)*result;
  }
  return result;
}

uint64_t TComponentFont::IsOpticalFont(TComponentFont *this)
{
  return (*((unsigned __int8 *)this + 712) >> 4) & 1;
}

void TBaseFont::CopyAttribute(TBaseFont *this@<X0>, uint64_t a2@<X1>, atomic_ullong *a3@<X8>)
{
  *a3 = 0;
  switch(a2)
  {
    case 0:
      return;
    case 1:
    case 34:
      CFDictionaryRef explicit = (void *)atomic_load_explicit((atomic_ullong *volatile)this + 12, memory_order_acquire);
      goto LABEL_17;
    case 2:
    case 3:
    case 4:
      (*(void (**)(id *__return_ptr))(*(void *)this + 72))(&v12);
      goto LABEL_42;
    case 5:
      id v12 = (id)0xAAAAAAAAAAAAAAAALL;
      (*(void (**)(id *__return_ptr))(*(void *)this + 152))(&v12);
      unint64_t v11 = atomic_exchange((atomic_ullong *volatile)&v12, 0);

      id v9 = (id)v11;
      goto LABEL_44;
    case 6:
      (*(void (**)(id *__return_ptr))(*(void *)this + 120))(&v12);
      goto LABEL_42;
    case 7:
    case 62:
      (*(void (**)(id *__return_ptr))(*(void *)this + 112))(&v12);
      goto LABEL_42;
    case 12:
    case 13:
      BOOL v5 = @"NSCTFontMatrixAttribute";
      goto LABEL_40;
    case 15:
      (*(void (**)(id *__return_ptr))(*(void *)this + 184))(&v12);
      goto LABEL_42;
    case 16:
      (*(void (**)(id *__return_ptr))(*(void *)this + 336))(&v12);
      goto LABEL_42;
    case 19:
      (*(void (**)(id *__return_ptr))(*(void *)this + 136))(&v12);
      goto LABEL_42;
    case 23:
      (*(void (**)(id *__return_ptr))(*(void *)this + 368))(&v12);
      goto LABEL_42;
    case 24:
      (*(void (**)(id *__return_ptr))(*(void *)this + 504))(&v12);
      goto LABEL_42;
    case 25:
      (*(void (**)(id *__return_ptr))(*(void *)this + 192))(&v12);
      goto LABEL_42;
    case 26:
      (*(void (**)(id *__return_ptr))(*(void *)this + 216))(&v12);
      goto LABEL_42;
    case 27:
      (*(void (**)(id *__return_ptr))(*(void *)this + 224))(&v12);
      goto LABEL_42;
    case 28:
      (*(void (**)(id *__return_ptr))(*(void *)this + 232))(&v12);
      goto LABEL_42;
    case 29:
      (*(void (**)(id *__return_ptr))(*(void *)this + 248))(&v12);
      goto LABEL_42;
    case 30:
      (*(void (**)(id *__return_ptr))(*(void *)this + 264))(&v12);
      goto LABEL_42;
    case 31:
      (*(void (**)(id *__return_ptr))(*(void *)this + 280))(&v12);
      goto LABEL_42;
    case 32:
      (*(void (**)(id *__return_ptr))(*(void *)this + 296))(&v12);
      goto LABEL_42;
    case 33:
      (*(void (**)(id *__return_ptr))(*(void *)this + 200))(&v12);
      goto LABEL_42;
    case 35:
      (*(void (**)(id *__return_ptr))(*(void *)this + 312))(&v12);
      goto LABEL_42;
    case 36:
      (*(void (**)(id *__return_ptr))(*(void *)this + 328))(&v12);
      goto LABEL_42;
    case 45:
      (*(void (**)(id *__return_ptr))(*(void *)this + 432))(&v12);
      goto LABEL_42;
    case 46:
      (*(void (**)(id *__return_ptr))(*(void *)this + 440))(&v12);
      goto LABEL_42;
    case 47:
      (*(void (**)(id *__return_ptr))(*(void *)this + 448))(&v12);
      goto LABEL_42;
    case 51:
      BOOL v5 = @"CTFontMorxConversionResultAttribute";
LABEL_40:
      TBaseFont::CopyAttributeInternal((atomic_ullong *)this, v5, &v12);
      goto LABEL_42;
    case 54:
      BOOL IsUserInstalled = TBaseFont::IsUserInstalled(this);
      id v7 = (void **)MEMORY[0x1E4F1CFD0];
      if (!IsUserInstalled) {
        id v7 = (void **)MEMORY[0x1E4F1CFC8];
      }
      goto LABEL_16;
    case 63:
      if ((*((_DWORD *)this + 46) & 0x800) == 0)
      {
        atomic_load_explicit((atomic_ullong *volatile)this + 12, memory_order_acquire);
        atomic_fetch_or_explicit((atomic_uint *volatile)this + 45, 0, memory_order_relaxed);
        atomic_fetch_or_explicit((atomic_uint *volatile)this + 46, 0x800u, memory_order_relaxed);
      }
      id v7 = (void **)MEMORY[0x1E4F1CFC8];
      if ((*((_DWORD *)this + 45) & 0x800) != 0) {
        id v7 = (void **)MEMORY[0x1E4F1CFD0];
      }
LABEL_16:
      CFDictionaryRef explicit = *v7;
LABEL_17:
      id v12 = explicit;
      unint64_t v8 = atomic_exchange((atomic_ullong *volatile)&v12, 0);
      goto LABEL_43;
    case 64:
      TBaseFont::CopyWeightAxisValue((atomic_ullong *)this, (unint64_t *)&v12);
LABEL_42:
      unint64_t v8 = atomic_exchange((atomic_ullong *volatile)&v12, 0);
LABEL_43:

      id v9 = v12;
LABEL_44:

      break;
    default:
      CFDictionaryRef v10 = (void *)atomic_exchange(a3, 0);

      break;
  }
}

{
  id v5;

  *a3 = 0;
  switch(a2)
  {
    case 1:
    case 2:
    case 3:
    case 4:
      goto LABEL_3;
    default:
      if (a2 == 34) {
LABEL_3:
      }
        (*(void (**)(id *__return_ptr))(*(void *)this + 88))(&v5);
      else {
        (*(void (**)(id *__return_ptr))(*(void *)this + 40))(&v5);
      }

      return;
  }
}

const __CFDictionary *TComponentFont::GetDesignUITrait(atomic_ullong *this)
{
  CFDictionaryRef result = (const __CFDictionary *)atomic_load_explicit(this + 90, memory_order_acquire);
  if (result) {
    return (const __CFDictionary *)CFDictionaryGetValue(result, @"NSCTFontUIFontDesignTrait");
  }
  return result;
}

uint64_t TDescriptorSource::TextStyleForUIFontName(TDescriptorSource *this, const __CFString *a2, uint64_t *a3)
{
  var18.isa = (void *)0xAAAAAAAAAAAAAAAALL;
  if (!TDescriptorSource::StashIndexForFontName(this, &var18, a3)) {
    return 0;
  }
  if (qword_1EB2CDBB0 != -1) {
    dispatch_once(&qword_1EB2CDBB0, &__block_literal_global_2745);
  }
  BOOL v3 = (void *)qword_1EB2CDBA8;
  uint64_t v4 = [NSNumber numberWithLong:var18.isa];

  return [v3 objectForKeyedSubscript:v4];
}

TDescriptorSource *TDescriptorSource::IsValidTextStyle(TDescriptorSource *this, const __CFString *a2)
{
  CFStringRef v2 = (TDescriptorSource *)MapTextStyleValue((uint64_t)this);
  if (v2 > 0x144) {
    return 0;
  }
  CFDictionaryRef result = (TDescriptorSource *)TDescriptorSource::UIFontNameForUIType(v2);
  if (result)
  {
    var18.isa = (void *)0xAAAAAAAAAAAAAAAALL;
    CFDictionaryRef result = (TDescriptorSource *)TDescriptorSource::StashIndexForFontName(result, &var18, v4);
    if (result)
    {
      memcpy(__dst, &__const__ZN17TDescriptorSource16IsValidTextStyleEPK10__CFString_overrideSpec, sizeof(__dst));
      return (TDescriptorSource *)(FindTextStyle((unint64_t)var18.isa, (uint64_t)__dst, -1) != 0);
    }
  }
  return result;
}

void TDescriptorSource::CreateDescriptorForTextStyle(__CFString *a1@<X1>, __CFString *a2@<X2>, unint64_t a3@<X3>, const __CFDictionary *a4@<X4>, void *a5@<X8>)
{
  CFDictionaryRef explicit = a1;
  v43[4] = *MEMORY[0x1E4F143B8];
  unsigned int v11 = MapTextStyleValue((uint64_t)a1);
  if (v11 >= 0x145) {
    uint64_t v12 = 2;
  }
  else {
    uint64_t v12 = v11;
  }
  uint64_t v39 = 0;
  unint64_t v40 = 0xAAAAAAAAFFFFFFFFLL;
  if (!explicit) {
    CFDictionaryRef explicit = @"CTFontRegularUsage";
  }
  value = 0;
  double v38 = 0.0;
  int v13 = SetDescriptorInfoForUIType((uint64_t)&value, (TDescriptorSource *)v12);
  FontNameForTextStyle = (TDescriptorSource *)value;
  if (v13) {
    BOOL v15 = value == 0;
  }
  else {
    BOOL v15 = 1;
  }
  if (v15)
  {
    *a5 = 0;
  }
  else
  {
    uint64_t ContentSizeCategoryIndex = CTFontDescriptorGetContentSizeCategoryIndex(a2);
    if (a4)
    {
      CFNumberRef v17 = (const __CFNumber *)CFDictionaryGetValue(a4, @"NSCTFontTextStylePlatformAttribute");
      if (v17)
      {
        LODWORD(valuePtr) = -1431655766;
        CFNumberGetValue(v17, kCFNumberIntType, &valuePtr);
        uint64_t v18 = valuePtr;
      }
      else
      {
        uint64_t v18 = 0xFFFFFFFFLL;
      }
      CFDictionaryRef v19 = (const __CFDictionary *)CFDictionaryGetValue(a4, @"NSCTFontTraitsAttribute");
      if (v19)
      {
        CFStringRef v20 = (const __CFString *)v19;
        if (CFDictionaryGetCount(v19) == 1
          && (GetSymbolicTraitsFromTraits((const __CFDictionary *)v20) & 0x40) != 0)
        {
          FontNameForTextStyle = (TDescriptorSource *)TDescriptorSource::FindFontNameForTextStyle((TDescriptorSource *)explicit, v20, 0, 0, 0, v21);
        }
      }
    }
    else
    {
      uint64_t v18 = 0xFFFFFFFFLL;
    }
    double v22 = TDescriptorSource::MapTextStyleSizeCategory(FontNameForTextStyle, ContentSizeCategoryIndex, (uint64_t *)v18, 0, 0, 0, 0);
    id v36 = 0;
    if (TDescriptorSource::IsVariableSizeTextStyleName((TDescriptorSource *)explicit, v23))
    {
      TDescriptorSource::CreateVariableSizeTextStyle((TDescriptorSource *)explicit, a4, &valuePtr);

      CFDictionaryRef explicit = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&v36, memory_order_acquire);
    }
    if (a3 | (unint64_t)a4)
    {
      CFMutableDictionaryRef valuePtr = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      unint64_t v24 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&valuePtr, memory_order_acquire);
      CFDictionaryAddValue(v24, @"NSFontNameAttribute", value);
      double v25 = v38;
      if (v22 != 0.0) {
        double v25 = v22;
      }
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&valuePtr, memory_order_acquire), @"NSFontSizeAttribute", (const void *)[NSNumber numberWithDouble:v25]);
      if (a3) {
        CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&valuePtr, memory_order_acquire), @"CTFontDescriptorLanguageAttribute", (const void *)a3);
      }
      if (v12)
      {
        CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&valuePtr, memory_order_acquire), @"NSCTFontUIUsageAttribute", explicit);
        CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&valuePtr, memory_order_acquire), @"NSCTFontSizeCategoryAttribute", (const void *)[NSNumber numberWithUnsignedInt:ContentSizeCategoryIndex]);
        if (a4) {
          TCFMutableDictionary::SetPairs((atomic_ullong *)&valuePtr, a4);
        }
      }
      CFDictionaryRef v34 = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&valuePtr, memory_order_acquire);
      if (v12 <= 1) {
        int v26 = 20;
      }
      else {
        int v26 = 1028;
      }
      int v33 = v26;
      TCFBase_NEW<CTFontDescriptor,__CFDictionary const*&,unsigned int &>(&v34, &v33, &v35);
      *a5 = atomic_exchange((atomic_ullong *volatile)&v35, 0);

      CFDictionaryRef v27 = valuePtr;
    }
    else
    {
      v43[0] = value;
      v42[0] = @"NSFontNameAttribute";
      v42[1] = @"NSFontSizeAttribute";
      v43[1] = [NSNumber numberWithDouble:v22];
      v43[2] = explicit;
      v42[2] = @"NSCTFontUIUsageAttribute";
      v42[3] = @"NSCTFontSizeCategoryAttribute";
      v43[3] = [NSNumber numberWithUnsignedInt:ContentSizeCategoryIndex];
      CFDictionaryRef v28 = (const __CFDictionary *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v43 forKeys:v42 count:4];
      uint64_t v29 = TCFBase<TDescriptor>::Allocate();
      if (v29)
      {
        uint64_t v30 = (__CFDictionary *)v29;
        if (v12 <= 1) {
          int v31 = 20;
        }
        else {
          int v31 = 1028;
        }
        int64x2_t v32 = (TDescriptor *)(v29 + 48);
        *((void *)v30 + 2) = 0;
        *((void *)v30 + 3) = TDescriptor::Hash;
        *((void *)v30 + 4) = 0;
        *((void *)v30 + 5) = v32;
        TDescriptor::TDescriptor(v32, v28, v31);
        CFMutableDictionaryRef valuePtr = v30;
        id v35 = (id)atomic_exchange((atomic_ullong *volatile)&valuePtr, 0);
      }
      else
      {
        id v35 = 0;
      }
      *a5 = atomic_exchange((atomic_ullong *volatile)&v35, 0);
      CFDictionaryRef v27 = (TDescriptorSource *)v35;
    }
  }
}

__CFString *TDescriptorSource::FindFontNameForTextStyle(TDescriptorSource *this, const __CFString *a2, const __CFDictionary *a3, BOOL *a4, const __CFString **a5, const __CFString **a6)
{
  unsigned int v11 = (TDescriptorSource *)MapTextStyleValue((uint64_t)this);
  v19.info = 0;
  if (v11)
  {
    char v13 = 0;
    if (!a3) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  v19.isa = 0;
  int IsVariableSizeTextStyleInstance = TDescriptorSource::IsVariableSizeTextStyleInstance(this, &v19, a5, v12);

  if (!IsVariableSizeTextStyleInstance)
  {
    char v13 = 0;
    unsigned int v11 = 0;
    if (!a3) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  unsigned int v11 = (TDescriptorSource *)MapTextStyleValue(atomic_load_explicit(&v19.info, memory_order_acquire));
  if (a4) {
    *(void *)a4 = atomic_exchange(&v19.info, 0);
  }
  char v13 = 1;
  if (a3) {
LABEL_10:
  }
    *(unsigned char *)a3 = v13;
LABEL_11:
  if (v11 > 0x144)
  {
    FontNameForNameAndTrait = 0;
  }
  else
  {
    uint64_t v15 = TDescriptorSource::UIFontNameForUIType(v11);
    FontNameForNameAndTrait = (__CFString *)v15;
    if (a2)
    {
      if (v15)
      {
        SymbolicTraitsFromTraits = (uint64_t *)GetSymbolicTraitsFromTraits((const __CFDictionary *)a2);
        if (SymbolicTraitsFromTraits) {
          FontNameForNameAndTrait = TDescriptorSource::FindFontNameForNameAndTrait((TDescriptorSource *)FontNameForNameAndTrait, 0, SymbolicTraitsFromTraits, (int)SymbolicTraitsFromTraits);
        }
      }
    }
  }

  return FontNameForNameAndTrait;
}

double TDescriptorSource::GetTextStyleSize(TDescriptorSource *a1, __CFString *a2, uint64_t *a3, const __CFString **a4, double *a5, int a6, const __CFString *a7)
{
  id v41 = 0;
  id v42 = 0;
  *(void *)&long long v32 = &v42;
  *((void *)&v32 + 1) = 0;
  double v39 = COERCE_DOUBLE(&v41);
  CFStringRef v40 = 0;
  int IsVariableSizeTextStyleInstance = TDescriptorSource::IsVariableSizeTextStyleInstance(a1, (const __CFString *)((char *)&v32 + 8), &v40, a4);

  if (IsVariableSizeTextStyleInstance)
  {
    uint64_t v15 = (TDescriptorSource *)MapTextStyleValue(atomic_load_explicit((atomic_ullong *volatile)&v42, memory_order_acquire));
    double v16 = 0.0;
    if (v15 <= 0x144 && TDescriptorSource::UIFontNameForUIType(v15))
    {
      int ContentSizeCategoryIndex = CTFontDescriptorGetContentSizeCategoryIndex(a2);
      objc_msgSend((id)atomic_load_explicit((atomic_ullong *volatile)&v41, memory_order_acquire), "doubleValue");
      if (v18 == 0.0) {
        double v18 = 12.0;
      }
      double v16 = dbl_184B8B128[ContentSizeCategoryIndex] * v18;
      if (a5)
      {
        double v19 = v16 * 1.2;
LABEL_21:
        *a5 = v19;
      }
    }
  }
  else
  {
    CFStringRef v20 = (TDescriptorSource *)MapTextStyleValue((uint64_t)a1);
    double v16 = 0.0;
    if (v20 <= 0x144)
    {
      uint64_t v21 = TDescriptorSource::UIFontNameForUIType(v20);
      if (v21)
      {
        double v22 = (TDescriptorSource *)v21;
        unsigned int v23 = CTFontDescriptorGetContentSizeCategoryIndex(a2);
        double v39 = NAN;
        double v16 = TDescriptorSource::MapTextStyleSizeCategory(v22, v23, a3, (double *)a4, a5, &v39, a7);
        if (a5)
        {
          if (a6)
          {
            double v24 = v39;
            if (v39 <= 0.0 || v39 > 1.0)
            {
              if (v39 == 0.0) {
                double v24 = 1.0;
              }
              double v19 = v24 * *a5;
              goto LABEL_21;
            }
            id v38 = (id)0xAAAAAAAAAAAAAAAALL;
            TDescriptorSource::TDescriptorSource((TDescriptorSource *)&v32);
            TDescriptorSource::CreateDescriptorForTextStyle((__CFString *)a1, a2, (unint64_t)a7, 0, &v38);
            double v25 = (id)atomic_load_explicit((atomic_ullong *volatile)&v38, memory_order_acquire);
            uint64_t v26 = v25[5];

            if ((*(_DWORD *)(v26 + 16) & 0x80000000) == 0) {
              TDescriptor::InitBaseFont((TDescriptor *)v26, 0, 0.0);
            }
            CFDictionaryRef explicit = (_DWORD *)atomic_load_explicit((atomic_ullong *volatile)(v26 + 32), memory_order_acquire);
            long long v34 = xmmword_184B8B1A8;
            long long v35 = unk_184B8B1B8;
            long long v36 = xmmword_184B8B1C8;
            long long v37 = unk_184B8B1D8;
            long long v32 = xmmword_184B8B188;
            long long v33 = unk_184B8B198;
            if (explicit[62]) {
              inited = explicit + 62;
            }
            else {
              inited = TBaseFont::InitFontMetrics((TBaseFont *)explicit, 0.0);
            }
            StrikeMetrics::StrikeMetrics((uint64_t)&v32, (uint64_t)inited);
            unsigned int v29 = v32;
            double v30 = (*(double (**)(_DWORD *, double, double))(*(void *)explicit + 640))(explicit, v16, *((double *)&v33 + 1));
            *a5 = v16 * (v30 + *((double *)&v32 + 1) + *(double *)&v33) / (double)v29;
          }
        }
      }
    }
  }

  return v16;
}

uint64_t MapTextStyleValue(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (qword_1EB2CDB70 != -1) {
      dispatch_once(&qword_1EB2CDB70, &__block_literal_global_645);
    }
    CFStringRef v2 = (void *)[(id)qword_1EB2CDB68 objectForKeyedSubscript:v1];
    return [v2 unsignedIntValue];
  }
  return result;
}

uint64_t TDescriptorSource::StashIndexForFontName(TDescriptorSource *this, const __CFString *a2, uint64_t *a3)
{
  if (qword_1EB2CDBA0 != -1) {
    dispatch_once(&qword_1EB2CDBA0, &__block_literal_global_2248);
  }
  uint64_t result = [(id)qword_1EB2CDB98 objectForKeyedSubscript:this];
  if (result)
  {
    unsigned int v6 = [(id)result unsignedIntValue];
    if (v6 > 0x179)
    {
      return 0;
    }
    else
    {
      a2->isa = (void *)v6;
      return 1;
    }
  }
  return result;
}

uint64_t CTFontDescriptorGetContentSizeCategoryIndex(__CFString *cf)
{
  if (!cf
    || @"UICTContentSizeCategoryL" == cf
    || @"UICTContentSizeCategoryL" && CFEqual(cf, @"UICTContentSizeCategoryL"))
  {
    return 3;
  }
  CFTypeID v2 = CFGetTypeID(cf);
  if (v2 == CFNumberGetTypeID())
  {
    unsigned int valuePtr = -1431655766;
    CFNumberGetValue((CFNumberRef)cf, kCFNumberIntType, &valuePtr);
    return valuePtr;
  }
  uint64_t v4 = (void *)[&unk_1ED07E4B0 objectForKeyedSubscript:cf];
  if (!v4) {
    return 3;
  }

  return [v4 unsignedIntValue];
}

double TDescriptorSource::MapTextStyleSizeCategory(TDescriptorSource *a1, unsigned int a2, uint64_t *a3, double *a4, double *a5, double *a6, const __CFString *a7)
{
  double v7 = 0.0;
  if (a1)
  {
    int v12 = (int)a3;
    v19.isa = (void *)0xAAAAAAAAAAAAAAAALL;
    if (TDescriptorSource::StashIndexForFontName(a1, &v19, a3))
    {
      memcpy(__dst, &__const__ZN17TDescriptorSource24MapTextStyleSizeCategoryEPK10__CFStringj23CTFontTextStylePlatformPdS4_S4_S2__overrideSpec, sizeof(__dst));
      __dst[5] = 3;
      TextStyle = FindTextStyle((unint64_t)v19.isa, (uint64_t)__dst, v12);
      if (TextStyle)
      {
        uint64_t v15 = (uint64_t)TextStyle;
        if (a4) {
          *a4 = GetWeightForLocalTrait(TextStyle[5]);
        }
        uint64_t v16 = v15 + 24;
        if (a5) {
          *a5 = *(double *)(v16 + 24 * a2 + 8) * 0.5;
        }
        if (a6) {
          *a6 = LanguageAwareLineSpacingOverrideRatio(v15, a7);
        }
        return *(double *)(v16 + 24 * a2) * 0.5;
      }
    }
  }
  return v7;
}

unsigned int *FindTextStyle(unint64_t a1, uint64_t a2, int a3)
{
  if (qword_1EB2CDBD0 != -1) {
    dispatch_once(&qword_1EB2CDBD0, &__block_literal_global_3039);
  }
  if (a1 - 151 >= 5) {
    unsigned int v6 = -1;
  }
  else {
    unsigned int v6 = a1 - 151;
  }
  unint64_t v7 = a1;
  if ((v6 & 0x80000000) == 0)
  {
    unint64_t v8 = &kCondensedMapping[44 * v6];
    memcpy((void *)(a2 + 24), v8 + 5, 0x120uLL);
    if (*(double *)(a2 + 24) != 0.0)
    {
      for (uint64_t i = 0; i != 264; i += 24)
      {
        uint64_t v10 = a2 + i;
        if (*(double *)(a2 + i + 48) == 0.0)
        {
          *(_OWORD *)(a2 + i + 48) = *(_OWORD *)(v10 + 24);
          *(void *)(a2 + i + 64) = *(void *)(v10 + 40);
        }
      }
    }
    unsigned int v11 = &kCondensedMapping[44 * v6];
    *(void *)(a2 + 328) = v11[43];
    *(_OWORD *)(a2 + 312) = *(_OWORD *)(v11 + 41);
    *(_DWORD *)(a2 + 20) = *((_DWORD *)v11 + 8);
    unint64_t v7 = *v8;
  }
  if (v7 > 0x96) {
    return 0;
  }
  if (_MergedGlobals_82) {
    unint64_t v12 = 116;
  }
  else {
    unint64_t v12 = 151;
  }
  int v13 = a3 + 1;
  if ((a3 + 1) > 2)
  {
    BOOL v14 = (void **)&_MergedGlobals_2;
  }
  else
  {
    BOOL v14 = (void **)(&off_1E528F3C8 + v13);
    unint64_t v12 = qword_184BA1778[v13];
  }
  uint64_t v16 = (char *)*v14;
  if (v7 >= v12) {
    CFNumberRef v17 = &kTypeHierarchySpecPhonePad;
  }
  else {
    CFNumberRef v17 = *v14;
  }
  double v18 = &v17[84 * v7];
  unsigned int v19 = *v18;
  v65.unint64_t isa = 0;
  CFStringRef v20 = (TDescriptorSource *)TDescriptorSource::UIFontNameForUIType((TDescriptorSource *)HIWORD(v19));
  if (v20)
  {
    TDescriptorSource::StashIndexForFontName(v20, &v65, v21);
    unint64_t isa = (unint64_t)v65.isa;
  }
  else
  {
    unint64_t isa = 0;
  }
  BOOL v23 = *(double *)(a2 + 24) == 0.0 && v7 != a1;
  if (v7 == a1)
  {
    if (v19 < 0x10000) {
      goto LABEL_39;
    }
    double v25 = (char *)&kTypeHierarchySpecPhonePad + 336 * isa;
    if (isa >= 0x97) {
      double v25 = 0;
    }
    double v18 = (unsigned int *)(isa >= v12 ? v25 : &v16[336 * isa]);
    if (v18)
    {
LABEL_39:
      BOOL v64 = v23;
      if (dyld_program_sdk_at_least()) {
        goto LABEL_50;
      }
      unsigned int v26 = *v18;
      unint64_t v28 = 9;
      do
      {
        unint64_t v29 = v28 >> 1;
        double v30 = &v27[2 * (v28 >> 1)];
        unsigned int v32 = *v30;
        int v31 = v30 + 2;
        v28 += ~(v28 >> 1);
        if (v32 >= v26) {
          unint64_t v28 = v29;
        }
        else {
          CFDictionaryRef v27 = v31;
        }
      }
      while (v28);
      if (v27 == (_DWORD *)&kOtherSpecCore || *v27 != v26)
      {
LABEL_50:
        int v24 = 0;
      }
      else
      {
        memmove((void *)(a2 + 24), v18 + 6, 0xA8uLL);
        uint64_t v33 = 0;
        long long v34 = (long long *)(a2 + 192);
        do
        {
          long long v35 = (char *)v34 + v33;
          long long v36 = *v34;
          *((void *)v35 + 2) = *(void *)(a2 + 208);
          *(_OWORD *)long long v35 = v36;
          v33 += 24;
        }
        while (v33 != 120);
        *(_DWORD *)(a2 + 20) = v27[1];
        int v24 = 1;
      }
      double v18 = &v17[84 * v7];
      BOOL v23 = v64;
    }
    else
    {
      int v24 = 0;
      double v18 = &v17[84 * v7];
    }
  }
  else
  {
    int v24 = 1;
  }
  long long v37 = (char *)&v17[84 * v7];
  *(_OWORD *)a2 = *(_OWORD *)v18;
  int v39 = *((_DWORD *)v37 + 4);
  id v38 = (int *)(v37 + 16);
  *(_DWORD *)(a2 + 16) = v39;
  if ((v24 & 1) == 0) {
    *(_DWORD *)(a2 + 20) = v17[84 * v7 + 5];
  }
  if (v19 >= 0x10000)
  {
    uint64_t v44 = v18;
    int64x2_t v45 = v38 - 2;
    unint64_t v46 = v38 - 1;
    CFDictionaryRef v47 = (char *)&kTypeHierarchySpecPhonePad + 336 * isa;
    if (isa >= 0x97) {
      CFDictionaryRef v47 = 0;
    }
    if (isa >= v12) {
      CFDictionaryRef v48 = v47;
    }
    else {
      CFDictionaryRef v48 = &v16[336 * isa];
    }
    int v49 = *v38;
    if ((v24 ^ 1 | v23) == 1)
    {
      BOOL v50 = v23;
      memmove((void *)(a2 + 24), v48 + 24, 0x120uLL);
      uint64_t v51 = *((void *)v48 + 41);
      *(_OWORD *)(a2 + 312) = *(_OWORD *)(v48 + 312);
      *(void *)(a2 + 328) = v51;
      if (!v50) {
        *(_DWORD *)(a2 + 20) = *((_DWORD *)v48 + 5);
      }
      int v24 = 1;
    }
    double v52 = 4.0;
    if (v16 == (char *)&kTypeHierarchySpecWatch) {
      double v52 = 2.0;
    }
    int v53 = *((_DWORD *)v48 + 3);
    int v54 = *v46;
    unsigned int v55 = *(_DWORD *)(a2 + 20);
    if ((v49 & 0x20) != 0)
    {
      double v18 = v44;
      if (v55 - 2 < 5) {
        unsigned int v55 = dword_184BA1790[v55 - 2];
      }
    }
    else
    {
      double v18 = v44;
      if ((v49 & 0x40) != 0)
      {
        if (v55 - 3 >= 2)
        {
          if (v55 == 6) {
            unsigned int v55 = 7;
          }
        }
        else
        {
          unsigned int v55 = 6;
        }
      }
      else if ((v49 & 0x80) != 0)
      {
        if (v55 == 3)
        {
          unsigned int v55 = 4;
        }
        else if (v55 == 4)
        {
          unsigned int v55 = 5;
        }
      }
      else
      {
        if (v55 == 6) {
          int v56 = 8;
        }
        else {
          int v56 = *(_DWORD *)(a2 + 20);
        }
        if ((v49 & 0x100) != 0) {
          unsigned int v55 = v56;
        }
      }
    }
    BOOL v57 = v55 < 9 && *v45 == 1;
    unsigned int v58 = v55 + 9;
    if (!v57) {
      unsigned int v58 = v55;
    }
    *(_DWORD *)(a2 + 20) = v58;
    BOOL v60 = v54 == 1 || v54 == -1;
    if (v53) {
      BOOL v61 = 1;
    }
    else {
      BOOL v61 = !v60;
    }
    if (v61) {
      goto LABEL_110;
    }
    uint64_t v62 = 32;
    while (v54 != 1)
    {
      if (v54 == -1)
      {
        double v63 = v52 + *(double *)(a2 + v62);
        goto LABEL_107;
      }
LABEL_108:
      v62 += 24;
      if (v62 == 320)
      {
        *(_DWORD *)(a2 + 12) = v54;
        goto LABEL_110;
      }
    }
    double v63 = *(double *)(a2 + v62) - v52;
LABEL_107:
    *(double *)(a2 + v62) = v63;
    goto LABEL_108;
  }
  if (v23)
  {
    CFStringRef v40 = v18;
    id v41 = (char *)&v17[84 * v7];
    memmove((void *)(a2 + 24), v41 + 24, 0x120uLL);
    uint64_t v42 = *((void *)v41 + 5);
    long long v43 = *(_OWORD *)(v41 + 24);
    double v18 = v40;
    *(_OWORD *)(a2 + 312) = v43;
    *(void *)(a2 + 328) = v42;
  }
LABEL_110:
  if (v24) {
    return (unsigned int *)a2;
  }
  else {
    return v18;
  }
}

uint64_t TDescriptorSource::UIFontNameForUIType(TDescriptorSource *this)
{
  if (qword_1EB2CDB90 != -1) {
    dispatch_once(&qword_1EB2CDB90, &__block_literal_global_1700);
  }
  CFTypeID v2 = (void *)qword_1EB2CDB88;
  uint64_t v3 = [NSNumber numberWithUnsignedInt:this];

  return [v2 objectForKeyedSubscript:v3];
}

double LanguageAwareLineSpacingOverrideRatio(uint64_t a1, const __CFString *a2)
{
  if (qword_1EB2CDBC8 != -1) {
  int ExuberatedGroupForLanguage = ExuberatedGroupForTallPseudolanguageIfEnabled();
  }
  if (a2)
  {
    int ExuberatedGroupForLanguage = GetExuberatedGroupForLanguage(a2, 0);
    if (!ExuberatedGroupForLanguage) {
      return 0.0;
    }
  }
  else if (!ExuberatedGroupForLanguage)
  {
    int ExuberatedGroupForLanguage = _ExuberatedGroupForPreferredLanguages(0, 0);
    if (!ExuberatedGroupForLanguage) {
      return 0.0;
    }
  }
  if (!dword_1EB2CDB2C)
  {
    double v6 = *(double *)(a1 + 8 * ExuberatedGroupForLanguage + 296);
    if (v6 != 0.0) {
      return v6 / *(double *)(a1 + 104);
    }
  }

  return GetLanguageAwareAdjustRatio();
}

uint64_t _ExuberatedGroupForPreferredLanguages(BOOL *a1, const __CFString **a2)
{
  if (qword_1EB2CE288 != -1) {
    dispatch_once_f(&qword_1EB2CE288, 0, (dispatch_function_t)GetLocaleChangedCount(void)::$_0::__invoke);
  }
  if (dword_1EB2CE270 != gLocaleChangedCount)
  {
    dword_1EB2CE274 = 0;
    CFArrayRef v4 = CFLocaleCopyPreferredLanguages();
    if (qword_1EB2CE288 != -1) {
      dispatch_once_f(&qword_1EB2CE288, 0, (dispatch_function_t)GetLocaleChangedCount(void)::$_0::__invoke);
    }
    dword_1EB2CE270 = gLocaleChangedCount;
    if (v4)
    {

      dword_1EB2CE274 = _LargestExuberatedGroupForLanguages(v4, (const __CFString **)&qword_1EB2CE2A8, 1, (BOOL *)&byte_1EB2CE25A);
    }
  }
  if (a2) {
    *a2 = (const __CFString *)(id)qword_1EB2CE2A8;
  }
  if (a1) {
    *a1 = byte_1EB2CE25A;
  }
  return dword_1EB2CE274;
}

uint64_t ExuberatedGroupForTallPseudolanguageIfEnabled(void)
{
  if (qword_1EB2CE290 != -1) {
    dispatch_once_f(&qword_1EB2CE290, 0, (dispatch_function_t)ExuberatedGroupForTallPseudolanguageIfEnabled(void)::$_0::__invoke);
  }
  return dword_1EB2CE268;
}

uint64_t TDescriptorSource::IsVariableSizeTextStyleInstance(TDescriptorSource *this, const __CFString *a2, const __CFString **a3, const __CFString **a4)
{
  uint64_t v12 = 0;
  int v13 = &v12;
  uint64_t v14 = 0x2020000000;
  char v15 = 0;
  if (this)
  {
    CFTypeID v7 = CFGetTypeID(this);
    if (v7 == CFStringGetTypeID())
    {
      uint64_t v8 = [(TDescriptorSource *)this length];
      if (qword_1EB2CDBC0 != -1) {
        dispatch_once(&qword_1EB2CDBC0, &__block_literal_global_2747);
      }
      v11[0] = MEMORY[0x1E4F143A8];
      v11[1] = 3221225472;
      v11[2] = ___ZN17TDescriptorSource31IsVariableSizeTextStyleInstanceEPK10__CFStringPS2_S3__block_invoke;
      v11[3] = &unk_1E528B838;
      v11[6] = v8;
      v11[7] = a3;
      v11[8] = a2;
      v11[4] = this;
      void v11[5] = &v12;
      [(id)qword_1EB2CDBB8 enumerateObjectsUsingBlock:v11];
    }
  }
  uint64_t v9 = *((unsigned __int8 *)v13 + 24);
  _Block_object_dispose(&v12, 8);
  return v9;
}

uint64_t ___ZN17TDescriptorSource31IsVariableSizeTextStyleInstanceEPK10__CFStringPS2_S3__block_invoke(uint64_t a1, void *a2, unsigned char *a3)
{
  uint64_t v6 = [a2 length];
  uint64_t v7 = v6 + 1;
  if (*(void *)(a1 + 48) > (unint64_t)(v6 + 1)
    && (uint64_t v8 = v6, [*(id *)(a1 + 32) hasPrefix:a2])
    && [*(id *)(a1 + 32) characterAtIndex:v8] == 45)
  {
    uint64_t result = [*(id *)(a1 + 32) substringFromIndex:v7];
    if (!result) {
      return result;
    }
  }
  else
  {
    uint64_t result = [*(id *)(a1 + 32) isEqualToString:a2];
    if ((result & 1) == 0) {
      return result;
    }
    uint64_t result = @"12";
  }
  if (*(void *)(a1 + 56))
  {
    uint64_t result = (uint64_t)CFRetain((CFTypeRef)result);
    **(void **)(a1 + 56) = result;
  }
  if (*(void *)(a1 + 64))
  {
    uint64_t result = (uint64_t)CFRetain(a2);
    **(void **)(a1 + 64) = result;
  }
  *a3 = 1;
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
  return result;
}

uint64_t SetDescriptorInfoForUIType(uint64_t a1, TDescriptorSource *this)
{
  switch((int)this)
  {
    case 0:
      uint64_t v3 = @"Helvetica";
      goto LABEL_13;
    case 1:
      uint64_t v3 = @"Menlo-Regular";
      goto LABEL_15;
    case 2:
    case 3:
LABEL_28:
      uint64_t result = TDescriptorSource::UIFontNameForUIType(this);
      if (!result) {
        return result;
      }
      *(void *)a1 = result;
      *(void *)(a1 + 8) = 0x402A000000000000;
      return 1;
    case 4:
    case 17:
    case 21:
    case 24:
    case 25:
      uint64_t v3 = @".AppleSystemUIFont";
      goto LABEL_3;
    case 5:
      uint64_t v3 = @".AppleSystemUIFontEmphasized";
LABEL_3:
      uint64_t v4 = 0x4026000000000000;
      goto LABEL_25;
    case 6:
    case 19:
      uint64_t v3 = @".AppleSystemUIFont";
      goto LABEL_24;
    case 7:
      uint64_t v3 = @".AppleSystemUIFontEmphasized";
      goto LABEL_24;
    case 8:
    case 26:
      uint64_t v3 = @".AppleSystemUIFont";
LABEL_13:
      uint64_t v4 = 0x4028000000000000;
      goto LABEL_25;
    case 9:
    case 16:
    case 23:
      uint64_t v3 = @".AppleSystemUIFont";
      goto LABEL_22;
    case 10:
    case 22:
      uint64_t v3 = @".AppleSystemUIFont";
LABEL_15:
      uint64_t v4 = 0x4024000000000000;
      goto LABEL_25;
    case 11:
    case 12:
    case 13:
      uint64_t v3 = @".AppleSystemUIFont";
      goto LABEL_19;
    case 14:
      uint64_t v3 = @"Helvetica";
LABEL_19:
      uint64_t v4 = 0x402C000000000000;
      goto LABEL_25;
    case 15:
      *(void *)(a1 + 16) = @"UICTFontTextStyleHeadline";
      *(_DWORD *)(a1 + 24) = 3;
      return 1;
    case 18:
      uint64_t v3 = @".AppleSystemUIFontBold";
LABEL_22:
      uint64_t v4 = 0x402A000000000000;
      goto LABEL_25;
    case 20:
      uint64_t v3 = @".AppleSystemUIFontBold";
LABEL_24:
      uint64_t v4 = 0x4022000000000000;
LABEL_25:
      *(void *)a1 = v3;
      *(void *)(a1 + 8) = v4;
      return 1;
    default:
      switch((int)this)
      {
        case 1000:
        case 1003:
        case 1005:
        case 1006:
          uint64_t v3 = @".AppleSystemUIFontBold";
          goto LABEL_13;
        case 1001:
        case 1002:
          uint64_t v3 = @".AppleSystemUIFontBold";
          goto LABEL_19;
        default:
          goto LABEL_28;
      }
  }
}

uint64_t TDescriptorSource::IsVariableSizeTextStyleName(TDescriptorSource *this, const __CFString *a2)
{
  if (qword_1EB2CDBC0 != -1) {
    dispatch_once(&qword_1EB2CDBC0, &__block_literal_global_2747);
  }
  uint64_t v3 = (void *)qword_1EB2CDBB8;

  return [v3 containsObject:this];
}

void TCFBase_NEW<CTFontDescriptor,__CFDictionary const*&,unsigned int &>(const __CFDictionary **a1@<X0>, int *a2@<X1>, void *a3@<X8>)
{
  uint64_t v6 = TCFBase<TDescriptor>::Allocate();
  if (v6)
  {
    uint64_t v7 = (void *)v6;
    CFDictionaryRef v8 = *a1;
    int v9 = *a2;
    uint64_t v10 = (TDescriptor *)(v6 + 48);
    void v7[2] = 0;
    v7[3] = TDescriptor::Hash;
    v7[4] = 0;
    v7[5] = v10;
    TDescriptor::TDescriptor(v10, v8, v9);
    id v11 = v7;
    *a3 = atomic_exchange((atomic_ullong *volatile)&v11, 0);
  }
  else
  {
    *a3 = 0;
  }
}

uint64_t TCFBase<TDescriptor>::Allocate()
{
  if (TCFBase<TDescriptor>::GetTypeID(void)::once != -1) {
    dispatch_once_f(&TCFBase<TDescriptor>::GetTypeID(void)::once, 0, (dispatch_function_t)TCFBase<TDescriptor>::GetTypeID(void)::{lambda(void *)#1}::__invoke);
  }

  return _CFRuntimeCreateInstance();
}

void TDescriptor::TDescriptor(TDescriptor *this, const __CFDictionary *a2, int a3)
{
  *((void *)this + 1) = 0;
  uint64_t v4 = (atomic_ullong *)((char *)this + 8);
  *(void *)this = &unk_1ED05D778;
  *((_DWORD *)this + 4) = a3 & 0x7FFFFFFF;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 3) = 0;
  if ((a3 & 0x40000000) != 0) {
    atomic_fetch_or_explicit((atomic_uint *volatile)this + 4, 0x80000000, memory_order_relaxed);
  }
  TCFRef<__CTFont const*>::Retain(v4, a2);
}

CFDictionaryRef GetSymbolicTraitsFromTraits(const __CFDictionary *result)
{
  if (result)
  {
    uint64_t result = (const __CFDictionary *)CFDictionaryGetValue(result, @"NSCTFontSymbolicTrait");
    if (result)
    {
      unsigned int valuePtr = -1431655766;
      CFNumberGetValue(result, kCFNumberIntType, &valuePtr);
      return (const __CFDictionary *)valuePtr;
    }
  }
  return result;
}

void TCFMutableDictionary::SetPairs(atomic_ullong *this, CFDictionaryRef theDict)
{
  CFDictionaryRef explicit = (void *)atomic_load_explicit(this, memory_order_acquire);
  if (theDict) {
    CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)SetValuesToDictionaryFromDictionary(__CFDictionary *,__CFDictionary const*)::$_0::__invoke, explicit);
  }
}

uint64_t MapTightTrait(__int16 a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a1 < 0)
  {
    if (a2) {
      int v8 = a8;
    }
    else {
      int v8 = a7;
    }
    int v11 = a6;
    int v12 = a7;
    int v13 = a8;
  }
  else
  {
    if (a2) {
      int v8 = a5;
    }
    else {
      int v8 = a4;
    }
    int v11 = a3;
    int v12 = a4;
    int v13 = a5;
  }
  int v14 = v8;
  int v9 = (TDescriptorSource *)*(&v11 + (a1 & 3));

  return TDescriptorSource::UIFontNameForUIType(v9);
}

void addNames(__CFString *a1, __CFString *a2, __CFString *a3, atomic_ullong *a4)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  int v11 = @"type";
  int v12 = @"string";
  int v13 = @"1";
  int v14 = a1;
  CFArrayAppendValue(Mutable, (const void *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v13 forKeys:&v11 count:2]);
  int v11 = @"type";
  int v12 = @"string";
  int v13 = @"2";
  int v14 = a2;
  CFArrayAppendValue(Mutable, (const void *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v13 forKeys:&v11 count:2]);
  if (a3 == @".AppleSystemUIFont") {
    goto LABEL_4;
  }
  if (!a3)
  {
    uint64_t v10 = 0;
    goto LABEL_6;
  }
  int v9 = CFEqual(a3, @".AppleSystemUIFont");
  uint64_t v10 = a3;
  if (v9) {
LABEL_4:
  }
    uint64_t v10 = @".AppleSystemUIFontRegular";
LABEL_6:
  int v11 = @"type";
  int v12 = @"string";
  int v13 = @"4";
  int v14 = v10;
  CFArrayAppendValue(Mutable, (const void *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v13 forKeys:&v11 count:2]);
  int v11 = @"type";
  int v12 = @"string";
  int v13 = @"3";
  int v14 = a3;
  CFArrayAppendValue(Mutable, (const void *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v13 forKeys:&v11 count:2]);
  int v11 = @"type";
  int v12 = @"string";
  int v13 = @"18";
  int v14 = a3;
  CFArrayAppendValue(Mutable, (const void *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v13 forKeys:&v11 count:2]);
  int v11 = @"type";
  int v12 = @"string";
  int v13 = @"7";
  int v14 = @"Apple Inc.";
  CFArrayAppendValue(Mutable, (const void *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v13 forKeys:&v11 count:2]);
  CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit(a4, memory_order_acquire), @"name", a3);
  CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit(a4, memory_order_acquire), @"familyName", a1);
  CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit(a4, memory_order_acquire), @"version", @"1.0");
  CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit(a4, memory_order_acquire), @"FontNames", Mutable);
}

double GetWeightForLocalTrait(unsigned int a1)
{
  if (a1 > 0x11) {
    uint64_t v1 = &kCTFontWeightRegular;
  }
  else {
    uint64_t v1 = (uint64_t *)*(&off_1E528F338 + (int)a1);
  }
  return *(double *)v1;
}

void TBaseFont::CopyTraitsInternal(atomic_ullong *this@<X0>, atomic_ullong *a2@<X8>)
{
  *a2 = 0xAAAAAAAAAAAAAAAALL;
  TBaseFont::CopyAttributeInternal(this, @"NSCTFontTraitsAttribute", &v13);
  *a2 = atomic_exchange((atomic_ullong *volatile)&v13, 0);

  if (!atomic_load_explicit(a2, memory_order_acquire))
  {
    int v12 = 0;
    id v13 = (id)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(id *__return_ptr, atomic_ullong *, int *))(*this + 656))(&v13, this, &v12);
    if (atomic_load_explicit((atomic_ullong *volatile)&v13, memory_order_acquire))
    {
      id v11 = (id)0xAAAAAAAAAAAAAAAALL;
      (*(void (**)(id *__return_ptr, atomic_ullong *))(*this + 120))(&v11, this);
      if (atomic_load_explicit((atomic_ullong *volatile)&v11, memory_order_acquire))
      {
        id v10 = (id)0xAAAAAAAAAAAAAAAALL;
        (*(void (**)(id *__return_ptr, atomic_ullong *))(*this + 112))(&v10, this);
        id v8 = 0;
        id v9 = 0;
        id v7 = (id)0xAAAAAAAAAAAAAAAALL;
        CreateTraitsWithVariation((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v13, memory_order_acquire), (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire), (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v11, memory_order_acquire), (const TBaseFont *)this, (atomic_ullong *)&v9, (atomic_ullong *)&v8, &v7);
        if (!v12) {
          TCFRef<__CTFont const*>::Retain(a2, (id)atomic_load_explicit((atomic_ullong *volatile)&v7, memory_order_acquire));
        }
        if (atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire))
        {
          id v6 = (id)atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire);
          TBaseFont::SetAttributeInternal<TCFRef<__CFSet const*>>(this, (atomic_ullong *)&v6, @"CTFontCSSWeightAttribute");
        }
        if (atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire))
        {
          id v5 = (id)atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire);
          TBaseFont::SetAttributeInternal<TCFRef<__CFSet const*>>(this, (atomic_ullong *)&v5, @"CTFontCSSWidthAttribute");
        }
      }

      if (!atomic_load_explicit(a2, memory_order_acquire)) {
      if (atomic_load_explicit(a2, memory_order_acquire))
      }
      {
        id v11 = (id)0xAAAAAAAAAAAAAAAALL;
        (*(void (**)(id *__return_ptr, atomic_ullong *, unint64_t))(*this + 824))(&v11, this, atomic_load_explicit(a2, memory_order_acquire));
        if (atomic_load_explicit((atomic_ullong *volatile)&v11, memory_order_acquire)) {
          TCFRef<__CTFont const*>::Retain(a2, (id)atomic_load_explicit((atomic_ullong *volatile)&v11, memory_order_acquire));
        }

        id v4 = (id)atomic_load_explicit(a2, memory_order_acquire);
        TBaseFont::SetAttributeInternal<TCFRef<__CFSet const*>>(this, (atomic_ullong *)&v4, @"NSCTFontTraitsAttribute");
      }
    }
  }
}

void TBaseFont::CopyCSSWeight(atomic_ullong *this@<X0>, atomic_ullong *a2@<X8>)
{
  *a2 = 0xAAAAAAAAAAAAAAAALL;
  TBaseFont::CopyAttributeInternal(this, @"CTFontCSSWeightAttribute", v14);
  *a2 = atomic_exchange((atomic_ullong *volatile)v14, 0);

  if (!atomic_load_explicit(a2, memory_order_acquire))
  {
    if ((*(unsigned int (**)(atomic_ullong *))(*this + 704))(this))
    {
      CopyAttributeForSystemFont((const __CFString *)atomic_load_explicit(this + 12, memory_order_acquire), @"CTFontCSSWeightAttribute", (const __CFString **)v14);

      if (atomic_load_explicit(a2, memory_order_acquire))
      {
        id v16 = (id)atomic_load_explicit(a2, memory_order_acquire);
        TBaseFont::SetAttributeInternal<TCFRef<__CFSet const*>>(this, (atomic_ullong *)&v16, @"CTFontCSSWeightAttribute");
        id v4 = v16;
LABEL_27:

        return;
      }
    }
    id v15 = (id)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(id *__return_ptr, atomic_ullong *))(*this + 112))(&v15, this);
    CFDictionaryRef v5 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire);
    if (v5)
    {
      CFDictionaryRef v6 = v5;
      CFIndex Count = CFDictionaryGetCount(v5);

      if (Count > 0) {
        goto LABEL_19;
      }
    }
    else
    {
    }
    memset(v14, 170, sizeof(v14));
    (*(void (**)(id *__return_ptr, atomic_ullong *, uint64_t))(*this + 480))(&v13, this, 1330851634);
    OS2::OS2((atomic_ullong *)v14, (atomic_ullong *)&v13);

    if ((uint64_t)v14[2] >= 78)
    {
      unsigned int v8 = bswap32(*((unsigned __int16 *)v14[1] + 2)) >> 16;
      if (v8 < 0xB) {
        LOWORD(v8) = 100 * v8;
      }
      int v9 = (unsigned __int16)v8;
      if ((unsigned __int16)v8 >= 0x3E8u) {
        int v9 = 1000;
      }
      if ((_WORD)v8) {
        int v10 = v9;
      }
      else {
        int v10 = 1;
      }
      int valuePtr = v10;
      id v13 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
    }
LABEL_19:
    if (!atomic_load_explicit(a2, memory_order_acquire))
    {
      uint64_t explicit = atomic_load_explicit(this + 30, memory_order_acquire);
      if (!explicit) {
        uint64_t explicit = TBaseFont::CreateTraitsValues((TBaseFont *)this);
      }
      TBaseFont::CopyAttributeInternal(this, @"CTFontCSSWeightAttribute", v14);

      if (atomic_load_explicit(a2, memory_order_acquire)) {
        goto LABEL_26;
      }
      if (explicit)
      {
        LODWORD(v13) = ClassOfWeight(*(double *)(explicit + 8));
        v14[0] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &v13);
      }
    }
    if (!atomic_load_explicit(a2, memory_order_acquire))
    {
      LODWORD(v13) = 400;
      v14[0] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &v13);
    }
    id v12 = (id)atomic_load_explicit(a2, memory_order_acquire);
    TBaseFont::SetAttributeInternal<TCFRef<__CFSet const*>>(this, (atomic_ullong *)&v12, @"CTFontCSSWeightAttribute");

LABEL_26:
    id v4 = v15;
    goto LABEL_27;
  }
}

uint64_t std::vector<__CFString const*,TInlineBufferAllocator<__CFString const*,30ul>>::push_back[abi:nn180100](uint64_t result, void *a2)
{
  uint64_t v3 = (int64x2_t *)result;
  CFDictionaryRef v5 = *(void **)(result + 8);
  unint64_t v4 = *(void *)(result + 16);
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = result + 24;
    uint64_t v8 = ((uint64_t)v5 - v3->i64[0]) >> 3;
    if ((unint64_t)(v8 + 1) >> 61) {
      abort();
    }
    uint64_t v9 = v4 - v3->i64[0];
    uint64_t v10 = v9 >> 2;
    if (v9 >> 2 <= (unint64_t)(v8 + 1)) {
      uint64_t v10 = v8 + 1;
    }
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    BOOL v23 = &v3[1].i64[1];
    if (v11) {
      id v12 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate(v7, v11);
    }
    else {
      id v12 = 0;
    }
    id v13 = &v12[8 * v8];
    int v14 = &v12[8 * v11];
    double v22 = v14;
    *(void *)id v13 = *a2;
    CFDictionaryRef v6 = v13 + 8;
    v21.i64[1] = (uint64_t)(v13 + 8);
    uint64_t v16 = v3->i64[0];
    unint64_t v15 = v3->u64[1];
    if (v15 == v3->i64[0])
    {
      int64x2_t v18 = vdupq_n_s64(v15);
    }
    else
    {
      do
      {
        uint64_t v17 = *(void *)(v15 - 8);
        v15 -= 8;
        *((void *)v13 - 1) = v17;
        v13 -= 8;
      }
      while (v15 != v16);
      int64x2_t v18 = *v3;
      CFDictionaryRef v6 = (void *)v21.i64[1];
      int v14 = v22;
    }
    v3->i64[0] = (uint64_t)v13;
    v3->i64[1] = (uint64_t)v6;
    int64x2_t v21 = v18;
    unsigned int v19 = (char *)v3[1].i64[0];
    v3[1].i64[0] = (uint64_t)v14;
    double v22 = v19;
    uint64_t v20 = v18.i64[0];
    uint64_t result = std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v20);
  }
  else
  {
    *CFDictionaryRef v5 = *a2;
    CFDictionaryRef v6 = v5 + 1;
  }
  v3->i64[1] = (uint64_t)v6;
  return result;
}

void TBaseFont::CopyCSSWidth(atomic_ullong *this@<X0>, atomic_ullong *a2@<X8>)
{
  *a2 = 0xAAAAAAAAAAAAAAAALL;
  TBaseFont::CopyAttributeInternal(this, @"CTFontCSSWidthAttribute", v12);
  *a2 = atomic_exchange((atomic_ullong *volatile)v12, 0);

  if (!atomic_load_explicit(a2, memory_order_acquire))
  {
    if ((*(unsigned int (**)(atomic_ullong *))(*this + 704))(this))
    {
      CopyAttributeForSystemFont((const __CFString *)atomic_load_explicit(this + 12, memory_order_acquire), @"CTFontCSSWidthAttribute", (const __CFString **)v12);

      if (atomic_load_explicit(a2, memory_order_acquire))
      {
        id v14 = (id)atomic_load_explicit(a2, memory_order_acquire);
        TBaseFont::SetAttributeInternal<TCFRef<__CFSet const*>>(this, (atomic_ullong *)&v14, @"CTFontCSSWidthAttribute");
        id v4 = v14;
LABEL_20:

        return;
      }
    }
    id v13 = (id)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(id *__return_ptr, atomic_ullong *))(*this + 112))(&v13, this);
    CFDictionaryRef v5 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)&v13, memory_order_acquire);
    if (v5)
    {
      CFDictionaryRef v6 = v5;
      CFIndex Count = CFDictionaryGetCount(v5);

      if (Count > 0) {
        goto LABEL_12;
      }
    }
    else
    {
    }
    memset(v12, 170, sizeof(v12));
    (*(void (**)(id *__return_ptr, atomic_ullong *, uint64_t))(*this + 480))(&valuePtr, this, 1330851634);
    OS2::OS2((atomic_ullong *)v12, (atomic_ullong *)&valuePtr);

    if ((uint64_t)v12[2] >= 78)
    {
      id valuePtr = COERCE_ID(WidthPercentOfClass(bswap32(*((unsigned __int16 *)v12[1] + 3)) >> 16));
      id v11 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberDoubleType, &valuePtr);
    }
LABEL_12:
    if (!atomic_load_explicit(a2, memory_order_acquire))
    {
      uint64_t explicit = atomic_load_explicit(this + 30, memory_order_acquire);
      if (!explicit) {
        uint64_t explicit = TBaseFont::CreateTraitsValues((TBaseFont *)this);
      }
      TBaseFont::CopyAttributeInternal(this, @"CTFontCSSWidthAttribute", v12);

      if (atomic_load_explicit(a2, memory_order_acquire)) {
        goto LABEL_19;
      }
      if (explicit)
      {
        unsigned int v9 = ClassOfWidth(*(double *)(explicit + 16));
        v12[0] = COERCE_ID(WidthPercentOfClass(v9));
        id valuePtr = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberDoubleType, v12);
      }
    }
    if (!atomic_load_explicit(a2, memory_order_acquire))
    {
      LODWORD(valuePtr) = 100;
      v12[0] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
    }
    id v10 = (id)atomic_load_explicit(a2, memory_order_acquire);
    TBaseFont::SetAttributeInternal<TCFRef<__CFSet const*>>(this, (atomic_ullong *)&v10, @"CTFontCSSWidthAttribute");

LABEL_19:
    id v4 = v13;
    goto LABEL_20;
  }
}

void TBaseFont::ModifyTraitsDictionary(void *a1@<X8>)
{
  *a1 = 0;
}

void TBaseFont::CopyFileURL(TBaseFont *this@<X0>, void *a2@<X8>)
{
  if ((*((_DWORD *)this + 45) & 0x20000000) == 0)
  {
    id v7 = (id)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(id *__return_ptr))(*(void *)this + 200))(&v7);
    CFURLRef explicit = (const __CFURL *)atomic_load_explicit((atomic_ullong *volatile)&v7, memory_order_acquire);
    if (explicit)
    {
      id v8 = 0;
      if (CFURLGetBaseURL(explicit))
      {

        CFURLRef explicit = (const __CFURL *)atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire);
      }
      CFURLRef explicit = (const __CFURL *)CFURLCopyFileSystemPath(explicit, kCFURLPOSIXPathStyle);
    }
    CFStringRef v4 = explicit;
    if (v4)
    {
      CFDictionaryRef v5 = (__CFString *)v4;
      CFIndex Length = CFStringGetLength(v4);

      if (Length >= 1)
      {
        id v8 = CFURLCreateWithFileSystemPath((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFStringRef)explicit, kCFURLPOSIXPathStyle, 0);
        *a2 = atomic_exchange((atomic_ullong *volatile)&v8, 0);

        return;
      }
    }
    else
    {
    }
  }
  *a2 = 0;
}

void TInstanceFont::ModifyTraitsDictionary(TInstanceFont *this@<X0>, const __CFDictionary *a2@<X1>, void *a3@<X8>)
{
  if (*((unsigned char *)this + 624))
  {
    id v6 = (id)0xAAAAAAAAAAAAAAAALL;
    TCFMutableDictionary::TCFMutableDictionary((TCFMutableDictionary *)&v6, a2);
    TCFNumber::TCFNumber<double>(&v5, *((double *)this + 77));
    CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v6, memory_order_acquire), @"NSCTFontWeightTrait", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v5, memory_order_acquire));

    *a3 = atomic_exchange((atomic_ullong *volatile)&v6, 0);
  }
  else
  {
    *a3 = 0;
  }
}

void TSplicedFontDict::CreateTraitsValuesPerFontInfo(atomic_ullong *this@<X0>, double a2@<D0>, uint64_t a3@<D1>, char *a4@<D2>, BOOL a5@<W1>, BOOL a6@<W2>, BOOL a7@<W3>, void *a8@<X8>)
{
  uint64_t v27[3] = *MEMORY[0x1E4F143B8];
  BOOL v26 = a5;
  BOOL v25 = a6;
  BOOL v24 = a7;
  v22.uint64_t length = a3;
  double valuePtr = a2;
  v22.data = a4;
  HIDWORD(v22.info) = 0;
  if (!a6 || !a7)
  {
    TSplicedFontDict::GetTraitsValuesFromMetrics(this, &v26, &v25, &v24, &valuePtr, (double *)&v22.length, (double *)&v22.data, (unsigned int *)&v22.info + 1);
    a5 = v26;
    a6 = v25;
    a7 = v24;
  }
  if (!a5 || !a6 || !a7)
  {
    int64x2_t v21 = a8;
    uint64_t v10 = 0;
    v27[0] = @"CTFontFullName";
    v27[1] = @"CTFontFamilyName";
    v27[2] = @"CTFontSubFamilyName";
    while (1)
    {
      int v11 = FontNameCodeForKey((const __CFString *)v27[v10]);
      CFDictionaryRef v12 = TSplicedFontDict::FindFontName(this, v11, 0);
      if (v12)
      {
        v22.unint64_t isa = (void *)0xAAAAAAAAAAAAAAAALL;
        CreateTraitsByStyleGlossaryString(&v22, (const __CFString *)v12);
        if (atomic_load_explicit((atomic_ullong *volatile)&v22, memory_order_acquire))
        {
          if (!v26)
          {
            CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v22, memory_order_acquire), @"NSCTFontWeightTrait");
            if (Value)
            {
              CFNumberGetValue(Value, kCFNumberDoubleType, &valuePtr);
              BOOL v26 = 1;
            }
          }
          if (!v25)
          {
            CFNumberRef v14 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v22, memory_order_acquire), @"NSCTFontProportionTrait");
            if (v14)
            {
              CFNumberGetValue(v14, kCFNumberDoubleType, &v22.length);
              BOOL v25 = 1;
            }
          }
          if (!v24)
          {
            CFNumberRef v15 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v22, memory_order_acquire), @"NSCTFontSlantTrait");
            if (v15)
            {
              CFNumberGetValue(v15, kCFNumberDoubleType, &v22.data);
              BOOL v24 = 1;
            }
          }
        }
        BOOL v16 = v26;
        BOOL v17 = v25;
        BOOL v18 = v24;

        if (v16 && v17 && v18) {
          break;
        }
      }

      if (++v10 == 3) {
        goto LABEL_25;
      }
    }

LABEL_25:
    a8 = v21;
  }
  CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit(this, memory_order_acquire);
  if (explicit) {
    CFStringRef v20 = (const __CFString *)CFDictionaryGetValue(explicit, @"NSCTFontUIFontDesignTrait");
  }
  else {
    CFStringRef v20 = 0;
  }
  CreateTraitValues(valuePtr, *(double *)&v22.length, *(double *)&v22.data, v20, v26, v25, v24, SHIDWORD(v22.info), a8);
}

void TSplicedFont::CreateTraitsValuesPerFontInfo(uint64_t a1@<X0>, _DWORD *a2@<X1>, void *a3@<X8>)
{
  *a2 = 1;
  uint64_t v3 = *(void *)(a1 + 616);
  if (!v3)
  {
    BOOL v7 = 0;
    double v4 = 2.0;
    uint64_t v5 = 2.0;
LABEL_8:
    double v6 = 2.0;
    goto LABEL_9;
  }
  double v4 = *(double *)(v3 + 32);
  uint64_t v5 = 2.0;
  if (v4 == 2.0)
  {
    BOOL v7 = 0;
    double v4 = 0.0;
    goto LABEL_8;
  }
  double v6 = 0.0;
  if (*(unsigned char *)(v3 + 52)) {
    double v6 = 0.0694444444;
  }
  uint64_t v5 = *(void *)(v3 + 40);
  BOOL v7 = 1;
LABEL_9:
  TSplicedFontDict::CreateTraitsValuesPerFontInfo((atomic_ullong *)(a1 + 600), v4, v5, *(char **)&v6, v7, v3 != 0, v3 != 0, a3);
}

void TSplicedFont::CopyVariation(TSplicedFont *this@<X0>, void *a2@<X8>)
{
  double v4 = (atomic_ullong *)((char *)this + 600);
  if (TSplicedFontDict::ComponentHasVariations((atomic_ullong *)this + 75))
  {
    CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit(v4, memory_order_acquire);
    if (explicit && (CFNumberRef Value = (void *)CFDictionaryGetValue(explicit, @"variations")) != 0)
    {
      id v9 = Value;
      *a2 = atomic_exchange((atomic_ullong *volatile)&v9, 0);
    }
    else
    {
      uint64_t v7 = *(void *)(*((void *)this + 76) + 40);
      if ((*(_DWORD *)(v7 + 16) & 0x80000000) == 0) {
        TDescriptor::InitBaseFont((TDescriptor *)v7, 0, 0.0);
      }
      id v8 = *(void (**)(void))(*(void *)atomic_load_explicit((atomic_ullong *volatile)(v7 + 32), memory_order_acquire)
                            + 112);
      v8();
    }
  }
  else
  {
    *a2 = 0;
  }
}

double CTFontGetDescentForSystemFontOfSize(double a1)
{
  return (double)-*((_DWORD *)kFont2X + 7) * a1 / *((double *)kFont2X + 1);
}

uint64_t CTRunDelegate::Destruct(uint64_t this, const void *a2)
{
  uint64_t v2 = *(void *)(this + 40);
  uint64_t v3 = *(uint64_t (**)(void))(v2 + 8);
  if (v3) {
    return v3(*(void *)(v2 + 40));
  }
  return this;
}

void TDelegateRun::~TDelegateRun(id *this)
{
  *this = &unk_1ED05D7A0;

  TRun::~TRun(this);
}

{
  uint64_t vars8;

  *this = &unk_1ED05D7A0;

  TRun::~TRun(this);

  JUMPOUT(0x1853275C0);
}

char *std::vector<JustLeftRightMaxima,TInlineBufferAllocator<JustLeftRightMaxima,30ul>>::__vallocate[abi:nn180100](char **a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    abort();
  }
  uint64_t result = TInlineBufferAllocator<std::pair<double,CFRange>,30ul>::allocate((uint64_t)(a1 + 3), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[24 * a2];
  return result;
}

void EnumerateOverlappingGlyphs(atomic_ullong *a1, unsigned __int16 *a2, uint64_t a3, int a4, uint64_t a5)
{
  v79[1] = *MEMORY[0x1E4F143B8];
  memset(v78, 170, sizeof(v78));
  int64x2_t v76 = 0uLL;
  unsigned int v77 = 0;
  v79[0] = v78;
  unint64_t MergeTable = TBaseFont::GetMergeTable(a1);
  if (!MergeTable)
  {
    BOOL v12 = (*(unsigned int (**)(atomic_ullong *))(*a1 + 392))(a1)
       && (*(unsigned int (**)(atomic_ullong *))(*a1 + 208))(a1) != 5;
    (*(void (**)(uint64_t, void, uint64_t, BOOL))(a5 + 16))(a5, 0, a3, v12);
LABEL_87:
    int v11 = (unsigned char *)v76.i64[0];
    if (!v76.i64[0]) {
      return;
    }
    goto LABEL_88;
  }
  if (a3 > 1)
  {
    id v13 = (OTL::MergeTable *)MergeTable;
    if (*(_WORD *)(*(void *)(MergeTable + 8) + 2) == 256)
    {
      char v14 = **(unsigned char **)(MergeTable + 24);
      if (a4 < 0) {
        char v14 = **(unsigned char **)(MergeTable + 24) >> 4;
      }
      char v15 = v14 & 1;
      uint64_t v16 = v76.i64[1];
      if (v76.i64[1] < (unint64_t)v77)
      {
        *(void *)v76.i64[1] = 0;
        *(void *)(v16 + 8) = a3;
        int v11 = (unsigned char *)(v16 + 24);
        *(unsigned char *)(v16 + 16) = v15;
        goto LABEL_85;
      }
      unint64_t v53 = 0xAAAAAAAAAAAAAAABLL * ((v76.i64[1] - v76.i64[0]) >> 3);
      unint64_t v54 = v53 + 1;
      if (v53 + 1 > 0xAAAAAAAAAAAAAAALL) {
        goto LABEL_94;
      }
      if (0x5555555555555556 * ((uint64_t)&v77[-v76.i64[0]] >> 3) > v54) {
        unint64_t v54 = 0x5555555555555556 * ((uint64_t)&v77[-v76.i64[0]] >> 3);
      }
      if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v77[-v76.i64[0]] >> 3) >= 0x555555555555555) {
        unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v19 = v54;
      }
      unsigned int v75 = v78;
      CFStringRef v20 = TInlineBufferAllocator<std::pair<double,CFRange>,30ul>::allocate((uint64_t)v78, v19);
      int64x2_t v21 = &v20[8 * ((v76.i64[1] - v76.i64[0]) >> 3)];
      *(void *)int64x2_t v21 = 0;
      *((void *)v21 + 1) = a3;
      v21[16] = v15;
      unint64_t v23 = v76.u64[1];
      uint64_t v55 = v76.i64[0];
      if (v76.i64[1] != v76.i64[0])
      {
        BOOL v24 = &v20[24 * v53];
        do
        {
          long long v56 = *(_OWORD *)(v23 - 24);
          *(v24 - 8) = *(unsigned char *)(v23 - 8);
          *(_OWORD *)(v24 - 24) = v56;
          v24 -= 24;
          v23 -= 24;
        }
        while (v23 != v55);
        goto LABEL_69;
      }
LABEL_70:
      int64x2_t v57 = vdupq_n_s64(v23);
      BOOL v24 = v21;
      goto LABEL_71;
    }
    uint64_t v70 = a5;
    uint64_t v26 = OTL::MergeTable::MergeClassForGlyph((OTL::MergeTable *)MergeTable, *a2);
    uint64_t v27 = 0;
    char v28 = 0;
    uint64_t v29 = 1;
    uint64_t v30 = 1;
    while (1)
    {
      uint64_t v31 = OTL::MergeTable::MergeClassForGlyph(v13, a2[v29]);
      uint64_t v32 = v31;
      unsigned int v33 = bswap32(*(unsigned __int16 *)(*((void *)v13 + 1) + 2)) >> 16;
      if (v33 <= (unsigned __int16)v26 || v33 <= v31) {
        break;
      }
      unsigned int v37 = *(unsigned __int8 *)(*((void *)v13 + 3) + (unsigned __int16)v26 * (unint64_t)v33 + v31);
      if (v31 == (unsigned __int16)v26 && v37 == 0) {
        goto LABEL_40;
      }
      if (a4 < 0) {
        v37 >>= 4;
      }
      if (!v37) {
        break;
      }
      if (v37) {
        char v28 = 1;
      }
      if ((v37 & 4) == 0) {
LABEL_40:
      }
        uint64_t v26 = v31;
      ++v30;
      uint64_t v32 = v26;
LABEL_55:
      ++v29;
      uint64_t v26 = v32;
      if (v29 == a3)
      {
        uint64_t v52 = v76.i64[1];
        if (v76.i64[1] < (unint64_t)v77)
        {
          *(void *)v76.i64[1] = v27;
          *(void *)(v52 + 8) = v30;
          int v11 = (unsigned char *)(v52 + 24);
          *(unsigned char *)(v52 + 16) = v28;
          a5 = v70;
          goto LABEL_85;
        }
        unint64_t v59 = 0xAAAAAAAAAAAAAAABLL * ((v76.i64[1] - v76.i64[0]) >> 3);
        unint64_t v60 = v59 + 1;
        if (v59 + 1 <= 0xAAAAAAAAAAAAAAALL)
        {
          if (0x5555555555555556 * ((uint64_t)&v77[-v76.i64[0]] >> 3) > v60) {
            unint64_t v60 = 0x5555555555555556 * ((uint64_t)&v77[-v76.i64[0]] >> 3);
          }
          if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v77[-v76.i64[0]] >> 3) >= 0x555555555555555) {
            unint64_t v61 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v61 = v60;
          }
          unsigned int v75 = v78;
          uint64_t v62 = TInlineBufferAllocator<std::pair<double,CFRange>,30ul>::allocate((uint64_t)v78, v61);
          double v63 = &v62[24 * v59];
          *(void *)double v63 = v27;
          *((void *)v63 + 1) = v30;
          v63[16] = v28;
          uint64_t v65 = v76.i64[1];
          uint64_t v64 = v76.i64[0];
          if (v76.i64[1] == v76.i64[0])
          {
            int64x2_t v57 = vdupq_n_s64(v76.u64[1]);
            BOOL v24 = &v62[24 * v59];
            a5 = v70;
          }
          else
          {
            BOOL v24 = &v62[24 * v59];
            a5 = v70;
            do
            {
              long long v66 = *(_OWORD *)(v65 - 24);
              *(v24 - 8) = *(unsigned char *)(v65 - 8);
              *(_OWORD *)(v24 - 24) = v66;
              v24 -= 24;
              v65 -= 24;
            }
            while (v65 != v64);
            int64x2_t v57 = v76;
          }
          int v11 = v63 + 24;
          unsigned int v58 = &v62[24 * v61];
          goto LABEL_84;
        }
LABEL_94:
        abort();
      }
    }
    uint64_t v35 = v76.i64[1];
    if (v76.i64[1] >= (unint64_t)v77)
    {
      int v39 = a2;
      uint64_t v40 = a3;
      unint64_t v41 = 0xAAAAAAAAAAAAAAABLL * ((v76.i64[1] - v76.i64[0]) >> 3);
      unint64_t v42 = v41 + 1;
      if (v41 + 1 > 0xAAAAAAAAAAAAAAALL) {
        goto LABEL_94;
      }
      if (0x5555555555555556 * ((uint64_t)&v77[-v76.i64[0]] >> 3) > v42) {
        unint64_t v42 = 0x5555555555555556 * ((uint64_t)&v77[-v76.i64[0]] >> 3);
      }
      if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v77[-v76.i64[0]] >> 3) >= 0x555555555555555) {
        unint64_t v43 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v43 = v42;
      }
      unsigned int v75 = v78;
      uint64_t v44 = TInlineBufferAllocator<std::pair<double,CFRange>,30ul>::allocate((uint64_t)v78, v43);
      int64x2_t v45 = &v44[24 * v41];
      *(void *)int64x2_t v45 = v27;
      *((void *)v45 + 1) = v30;
      v45[16] = v28;
      uint64_t v47 = v76.i64[1];
      uint64_t v46 = v76.i64[0];
      if (v76.i64[1] == v76.i64[0])
      {
        int64x2_t v50 = vdupq_n_s64(v76.u64[1]);
        CFDictionaryRef v48 = &v44[24 * v41];
        a3 = v40;
      }
      else
      {
        CFDictionaryRef v48 = &v44[24 * v41];
        a3 = v40;
        do
        {
          long long v49 = *(_OWORD *)(v47 - 24);
          *(v48 - 8) = *(unsigned char *)(v47 - 8);
          *(_OWORD *)(v48 - 24) = v49;
          v48 -= 24;
          v47 -= 24;
        }
        while (v47 != v46);
        int64x2_t v50 = v76;
      }
      a2 = v39;
      long long v36 = v45 + 24;
      v76.i64[0] = (uint64_t)v48;
      v76.i64[1] = (uint64_t)(v45 + 24);
      int64x2_t v73 = v50;
      uint64_t v51 = v77;
      unsigned int v77 = &v44[24 * v43];
      char v74 = v51;
      uint64_t v72 = v50.i64[0];
      std::__split_buffer<std::pair<double,CFRange>,TInlineBufferAllocator<std::pair<double,CFRange>,30ul> &>::~__split_buffer((uint64_t)&v72);
    }
    else
    {
      *(void *)v76.i64[1] = v27;
      *(void *)(v35 + 8) = v30;
      long long v36 = (char *)(v35 + 24);
      *(unsigned char *)(v35 + 16) = v28;
    }
    char v28 = 0;
    v76.i64[1] = (uint64_t)v36;
    uint64_t v30 = 1;
    uint64_t v27 = v29;
    goto LABEL_55;
  }
  uint64_t v10 = v76.i64[1];
  if (v76.i64[1] < (unint64_t)v77)
  {
    *(void *)v76.i64[1] = 0;
    *(void *)(v10 + 8) = a3;
    int v11 = (unsigned char *)(v10 + 24);
    *(unsigned char *)(v10 + 16) = 0;
    goto LABEL_85;
  }
  unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * ((v76.i64[1] - v76.i64[0]) >> 3);
  unint64_t v18 = v17 + 1;
  if (v17 + 1 > 0xAAAAAAAAAAAAAAALL) {
    goto LABEL_94;
  }
  if (0x5555555555555556 * ((uint64_t)&v77[-v76.i64[0]] >> 3) > v18) {
    unint64_t v18 = 0x5555555555555556 * ((uint64_t)&v77[-v76.i64[0]] >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v77[-v76.i64[0]] >> 3) >= 0x555555555555555) {
    unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v19 = v18;
  }
  unsigned int v75 = v78;
  CFStringRef v20 = TInlineBufferAllocator<std::pair<double,CFRange>,30ul>::allocate((uint64_t)v78, v19);
  int64x2_t v21 = &v20[8 * ((v76.i64[1] - v76.i64[0]) >> 3)];
  *(void *)int64x2_t v21 = 0;
  *((void *)v21 + 1) = a3;
  v21[16] = 0;
  unint64_t v23 = v76.u64[1];
  uint64_t v22 = v76.i64[0];
  if (v76.i64[1] == v76.i64[0]) {
    goto LABEL_70;
  }
  BOOL v24 = &v20[24 * v17];
  do
  {
    long long v25 = *(_OWORD *)(v23 - 24);
    *(v24 - 8) = *(unsigned char *)(v23 - 8);
    *(_OWORD *)(v24 - 24) = v25;
    v24 -= 24;
    v23 -= 24;
  }
  while (v23 != v22);
LABEL_69:
  int64x2_t v57 = v76;
LABEL_71:
  int v11 = v21 + 24;
  unsigned int v58 = &v20[24 * v19];
LABEL_84:
  v76.i64[0] = (uint64_t)v24;
  v76.i64[1] = (uint64_t)v11;
  int64x2_t v73 = v57;
  int64x2_t v67 = v77;
  unsigned int v77 = v58;
  char v74 = v67;
  uint64_t v72 = v57.i64[0];
  std::__split_buffer<std::pair<double,CFRange>,TInlineBufferAllocator<std::pair<double,CFRange>,30ul> &>::~__split_buffer((uint64_t)&v72);
LABEL_85:
  v76.i64[1] = (uint64_t)v11;
  char v68 = (void *)v76.i64[0];
  if ((unsigned char *)v76.i64[0] != v11)
  {
    do
    {
      (*(void (**)(uint64_t, void, void, void))(a5 + 16))(a5, *v68, v68[1], *((unsigned __int8 *)v68 + 16));
      v68 += 3;
    }
    while (v68 != (void *)v11);
    goto LABEL_87;
  }
LABEL_88:
  v76.i64[1] = (uint64_t)v11;
  if (v78 > v11 || v79 <= (void *)v11) {
    operator delete(v11);
  }
}

uint64_t OTL::MergeTable::MergeClassForGlyph(OTL::MergeTable *this, unsigned int a2)
{
  uint64_t v2 = *((void *)this + 1);
  if (!*(_WORD *)(v2 + 6)) {
    return 0;
  }
  unsigned int v4 = __rev16(*(unsigned __int16 *)(v2 + 6));
  if (v4 <= 1) {
    uint64_t v5 = 1;
  }
  else {
    uint64_t v5 = v4;
  }
  double v6 = (unsigned __int16 *)*((void *)this + 4);
  while (1)
  {
    unsigned int v7 = *v6++;
    uint64_t result = OTL::ClassDefTable::ClassOf((OTL::ClassDefTable *)(v2 + (bswap32(v7) >> 16)), a2);
    if (result) {
      break;
    }
    if (!--v5) {
      return 0;
    }
  }
  return result;
}

uint64_t OTL::ClassDefTable::ClassOf(OTL::ClassDefTable *this, unsigned int a2)
{
  unsigned int v2 = bswap32(*(unsigned __int16 *)this) >> 16;
  if (v2 == 2)
  {
    if (*((_WORD *)this + 1) && a2 >= bswap32(*((unsigned __int16 *)this + 2)) >> 16)
    {
      unsigned int v5 = __rev16(*((unsigned __int16 *)this + 1));
      unsigned int v6 = __clz(v5);
      int v7 = v6 ^ 0x1F;
      unsigned int v8 = 1 << (v6 ^ 0x1F);
      unsigned int v9 = v5 - v8;
      if (a2 < bswap32(*((unsigned __int16 *)this + 3 * (v5 - v8) + 2)) >> 16) {
        unsigned int v9 = 0;
      }
      if (v7)
      {
        do
        {
          if (a2 >= bswap32(*((unsigned __int16 *)this + 3 * v9 + 3 * (v8 >> 1) + 2)) >> 16) {
            v9 += v8 >> 1;
          }
          BOOL v10 = v8 > 3;
          v8 >>= 1;
        }
        while (v10);
      }
      if (a2 >= bswap32(*((unsigned __int16 *)this + 3 * v9 + 2)) >> 16
        && a2 <= bswap32(*((unsigned __int16 *)this + 3 * v9 + 3)) >> 16)
      {
        unsigned int v4 = (char *)this + 6 * v9 + 8;
        return bswap32(*(unsigned __int16 *)v4) >> 16;
      }
    }
    return 0;
  }
  if (v2 != 1) {
    return 0;
  }
  unsigned int v3 = bswap32(*((unsigned __int16 *)this + 1)) >> 16;
  if (v3 > a2 || v3 + (bswap32(*((unsigned __int16 *)this + 2)) >> 16) <= a2) {
    return 0;
  }
  unsigned int v4 = (char *)this + 2 * (int)(a2 - v3) + 6;
  return bswap32(*(unsigned __int16 *)v4) >> 16;
}

uint64_t TKerningEngine::PositionGlyphs(TKerningEngine *this, TRunGlue *a2, const TCharStream *a3)
{
  char v3 = (char)a3;
  v46[1] = *MEMORY[0x1E4F143B8];
  uint64_t result = TRunGlue::length(this);
  if (result)
  {
    unsigned __int8 v38 = 0;
    int v7 = *(TTrackingEngine **)this;
    uint64_t v9 = *(void *)(*(void *)this + 16);
    uint64_t v8 = *(void *)(*(void *)this + 24);
    memset(v45, 170, sizeof(v45));
    v43[0] = 0;
    v43[1] = 0;
    uint64_t v44 = 0;
    v46[0] = v45;
    uint64_t v10 = v8 - v9;
    if (v8 != v9)
    {
      if ((unint64_t)v10 >= 0x5555555555555551) {
        abort();
      }
      uint64_t v11 = v10 >> 3;
      *(void *)&__dst[2] = v45;
      BOOL v12 = TInlineBufferAllocator<std::pair<double,CFRange>,30ul>::allocate((uint64_t)v45, v10 >> 3);
      int64x2_t v13 = vdupq_n_s64((unint64_t)v43[1]);
      v43[0] = v12;
      v43[1] = v12;
      *(int64x2_t *)((char *)__dst + 8) = v13;
      char v14 = v44;
      uint64_t v44 = &v12[24 * v11];
      *((void *)&__dst[1] + 1) = v14;
      *(void *)&__dst[0] = v13.i64[0];
      std::__split_buffer<std::pair<double,CFRange>,TInlineBufferAllocator<std::pair<double,CFRange>,30ul> &>::~__split_buffer((uint64_t)__dst);
    }
    unsigned int v33 = v7;
    *(void *)&long long v15 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
    while (1)
    {
      uint64_t v16 = *((void *)this + 19);
      uint64_t CommonTable = -1;
      double v37 = NAN;
      v41[13] = v15;
      v41[14] = v15;
      v41[11] = v15;
      v41[12] = v15;
      v41[9] = v15;
      v41[10] = v15;
      v41[7] = v15;
      v41[8] = v15;
      v41[5] = v15;
      v41[6] = v15;
      v41[3] = v15;
      void v41[4] = v15;
      v41[1] = v15;
      v41[2] = v15;
      v41[0] = v15;
      memset(v40, 0, sizeof(v40));
      unint64_t v42 = v41;
      int KernSetting = -1431655766;
      int KernSetting = TAttributes::GetKernSetting((TAttributes *)(v16 + 40), &v37, 0);
      int v18 = *(_DWORD *)(v16 + 260);
      if ((v18 & 2) != 0) {
        break;
      }
      uint64_t CommonTable = TBaseFont::GetCommonTable(*(TBaseFont **)(*((void *)this + 77) + 400), 1634428274, 0);
      if (!CommonTable) {
        break;
      }
      if (KernSetting != 2)
      {
        TKerningEngineImplementation::DetermineSimilarRuns((uint64_t)this, v40);
        uint64_t v19 = 0;
LABEL_15:
        if (CommonTable == -1) {
          uint64_t CommonTable = TBaseFont::GetCommonTable(*(TBaseFont **)(*((void *)this + 77) + 400), 1634428274, 0);
        }
        memcpy(__dst, &unk_184B880E0, 0x198uLL);
        TAATKerxEngine::TAATKerxEngine((TAATKerxEngine *)__dst, this, (CFDataRef)CommonTable);
        if (*((void *)&__dst[5] + 1))
        {
          TAATKerxEngine::KernRuns((uint64_t)__dst, &v38, &KernSetting);
          uint64_t v19 = *((void *)this + 2);
        }
        if (KernSetting != 2)
        {
          memset(v35, 170, sizeof(v35));
          v34[0] = xmmword_184B88278;
          v34[1] = unk_184B88288;
          memset(&v34[2], 170, 32);
          TAATKernEngine::TAATKernEngine((TAATKernEngine *)v34, this);
          if (*(void *)&v35[32])
          {
            TAATKernEngine::KernRuns((uint64_t)v34, &v38, &KernSetting);
            uint64_t v19 = *((void *)this + 2);
          }
          std::__tree<std::__value_type<long,TAATDeltaYListEntry>,std::__map_value_compare<long,std::__value_type<long,TAATDeltaYListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TAATDeltaYListEntry>>>::destroy((uint64_t)&v34[3] + 8, *(void **)v35);
          if (*(void *)&v34[2])
          {
            *((void *)&v34[2] + 1) = *(void *)&v34[2];
            operator delete(*(void **)&v34[2]);
          }
        }
        TAATKerxEngine::~TAATKerxEngine((id **)__dst);
        goto LABEL_25;
      }
      uint64_t v19 = 0;
LABEL_25:
      if ((v18 & 6) != 0)
      {
        char v21 = TRunGlue::FilterJoiners(this);
        v38 |= v21;
      }
      uint64_t v22 = *((void *)this + 1);
      if (v19) {
        uint64_t v23 = v19;
      }
      else {
        uint64_t v23 = *((void *)this + 2);
      }
      AppendTrackAmountForRunIndex((unint64_t *)v43, *((void *)this + 1), v37);
      if (v23 != 1)
      {
        uint64_t v24 = 0;
        uint64_t v25 = v22 + 1;
        do
        {
          AppendTrackAmountForRunIndex((unint64_t *)v43, v25 + v24, v40[0][v24]);
          ++v24;
        }
        while (v23 - 1 != v24);
      }
      BOOL RunRange = TRunGlue::NextRunRange(this, v23);
      *(void *)&__dst[0] = v40;
      std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)__dst);
      *(void *)&long long v15 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
      if (!RunRange)
      {
        if ((v3 & 4) != 0)
        {
          *(void *)&__dst[0] = this;
          *((void *)&__dst[0] + 1) = a2;
          char v28 = TCombiningEngine::ResolveCombiningMarks((void ****)__dst, 2, 0, 0);
          v38 |= v28;
        }
        uint64_t v29 = (char *)v43[0];
        uint64_t v30 = (char *)v43[1];
        if (v43[0] == v43[1])
        {
          if (!v43[0]) {
            return v38;
          }
        }
        else
        {
          do
          {
            v27.CFIndex location = *((void *)v29 + 2);
            char v31 = TTrackingEngine::TrackRuns(v33, a2, *((const TCharStream **)v29 + 1), v27, *(double *)v29);
            v38 |= v31;
            v29 += 24;
          }
          while (v29 != v30);
          uint64_t v29 = (char *)v43[0];
          if (!v43[0]) {
            return v38;
          }
        }
        v43[1] = v29;
        if (v45 > v29 || v46 <= (void *)v29) {
          operator delete(v29);
        }
        return v38;
      }
    }
    TKerningEngineImplementation::DetermineSimilarRuns((uint64_t)this, v40);
    *(void *)&__dst[15] = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v20 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __dst[13] = v20;
    __dst[14] = v20;
    __dst[11] = v20;
    __dst[12] = v20;
    __dst[9] = v20;
    __dst[10] = v20;
    __dst[7] = v20;
    __dst[8] = v20;
    __dst[5] = v20;
    __dst[6] = v20;
    __dst[3] = v20;
    unsigned int __dst[4] = v20;
    __dst[1] = v20;
    __dst[2] = v20;
    __dst[0] = v20;
    TOpenTypePositioningEngine::TOpenTypePositioningEngine((TOpenTypePositioningEngine *)__dst, this, a2);
    if (StackHasAvailable(0x4000uLL)) {
      TOpenTypePositioningEngine::PositionRuns((uint64_t)__dst, &v38, &KernSetting);
    }
    uint64_t v19 = *((void *)this + 2);
    std::__tree<std::__value_type<long,TGlyphDeltaListEntry>,std::__map_value_compare<long,std::__value_type<long,TGlyphDeltaListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TGlyphDeltaListEntry>>>::destroy(*((void **)&__dst[14] + 1));
    if (KernSetting == 2) {
      goto LABEL_25;
    }
    goto LABEL_15;
  }
  return result;
}

BOOL StackHasAvailable(unint64_t a1)
{
  unsigned int v2 = pthread_self();
  stackaddr_np = pthread_get_stackaddr_np(v2);
  return (unint64_t)&vars0 + pthread_get_stacksize_np(v2) - (void)stackaddr_np > a1;
}

void std::__tree<std::__value_type<long,TGlyphDeltaListEntry>,std::__map_value_compare<long,std::__value_type<long,TGlyphDeltaListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TGlyphDeltaListEntry>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<long,TGlyphDeltaListEntry>,std::__map_value_compare<long,std::__value_type<long,TGlyphDeltaListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TGlyphDeltaListEntry>>>::destroy(*a1);
    std::__tree<std::__value_type<long,TGlyphDeltaListEntry>,std::__map_value_compare<long,std::__value_type<long,TGlyphDeltaListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TGlyphDeltaListEntry>>>::destroy(a1[1]);
    operator delete(a1);
  }
}

uint64_t TRunGlue::FilterJoiners(TRunGlue *this)
{
  if (((*(uint64_t (**)(void))(**(void **)(*((void *)this + 77) + 400) + 688))(*(void *)(*((void *)this + 77) + 400)) & 1) != 0
    || (char v3 = (char *)TBaseFont::GetCachedSpaceAndJoinerGlyphs(*(atomic_ullong **)(*((void *)this + 77) + 400), 0)
           + 2,
        v3 == v2)
    || (v4 = (unsigned __int16 *)v2, v15 = 0, v13 = this, v14 = 0, (uint64_t v5 = TRunGlue::length(this)) == 0))
  {
    char v7 = 0;
  }
  else
  {
    uint64_t v6 = v5;
    char v7 = 0;
    for (i = 0; i != v6; uint64_t v14 = i)
    {
      int GlyphID = TRunGlue::GetGlyphID(this, i);
      if (GlyphID != 0xFFFF)
      {
        int v10 = GlyphID;
        if (!TRunGlue::IsDeleted(this, i))
        {
          uint64_t v11 = (unsigned __int16 *)v3;
          while (*v11 != v10)
          {
            if (++v11 == v4)
            {
              uint64_t v11 = v4;
              break;
            }
          }
          if (v11 != v4)
          {
            TRunGlue::FilterJoiner(this, (TRunGlue::TGlyph *)&v13, &v15);
            char v7 = 1;
          }
        }
      }
      ++i;
    }
  }
  return v7 & 1;
}

atomic_ullong *TBaseFont::GetCachedSpaceAndJoinerGlyphs(atomic_ullong *this, TBaseFont **a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  char v3 = (TBaseFont *)(this + 29);
  if (!atomic_load_explicit(this + 29, memory_order_acquire))
  {
    unsigned int v4 = (unsigned __int16 *)(this + 28);
    *(void *)unint64_t v17 = 0x34F200D200C0020;
    if (a2)
    {
      uint64_t v5 = a2;
    }
    else
    {
      uint64_t v16 = this;
      uint64_t v5 = (TBaseFont **)&v16;
    }
    TcmapTable::Map(v5, v17, v4, 4, 1);
    uint64_t v6 = 0;
    char v7 = (TBaseFont *)((char *)this + 226);
    while (*(_WORD *)((char *)v7 + v6))
    {
      v6 += 2;
      if (v6 == 6)
      {
        uint64_t v8 = v3;
        goto LABEL_10;
      }
    }
    uint64_t v8 = (TBaseFont *)((char *)v7 + v6);
LABEL_10:
    if (v8 == v3)
    {
      uint64_t v11 = (TBaseFont *)((char *)this + 228);
      uint64_t v8 = v3;
    }
    else
    {
      if ((TBaseFont *)((char *)v8 + 2) != v3)
      {
        uint64_t v9 = 2 * ((v8 - v7) >> 1);
        int v10 = (char *)this + 228;
        do
        {
          if (*(_WORD *)&v10[v9])
          {
            *(_WORD *)uint64_t v8 = *(_WORD *)&v10[v9];
            uint64_t v8 = (TBaseFont *)((char *)v8 + 2);
          }
          v9 += 2;
        }
        while (v9 != 4);
      }
      if (v7 == v8)
      {
        uint64_t v8 = (TBaseFont *)((char *)this + 226);
LABEL_28:
        __dmb(0xBu);
        *(void *)char v3 = v8;
        return this + 28;
      }
      uint64_t v11 = (TBaseFont *)((char *)this + 228);
      if ((TBaseFont *)((char *)this + 228) == v8) {
        goto LABEL_28;
      }
    }
    uint64_t v12 = 0;
    int64x2_t v13 = v11;
    do
    {
      int v14 = *(unsigned __int16 *)v13;
      int64x2_t v13 = (TBaseFont *)((char *)v13 + 2);
      if (v14 == *(unsigned __int16 *)v7) {
        ++v12;
      }
    }
    while (v13 != v8);
    if (v12 == (v8 - v11) >> 1) {
      uint64_t v8 = (TBaseFont *)((char *)this + 226);
    }
    goto LABEL_28;
  }
  return this + 28;
}

uint64_t TTenuousComponentFont::IsLastResort(TTenuousComponentFont *this)
{
  if ((*(uint64_t (**)(TTenuousComponentFont *))(*(void *)this + 848))(this)) {
    return 0;
  }
  if ((*((_DWORD *)this + 46) & 2) == 0) {
    TBaseFont::DetermineFontFlags(this, 2u);
  }
  return (*((_DWORD *)this + 45) >> 1) & 1;
}

uint64_t TTenuousComponentFont::IsAppleColorEmoji(TTenuousComponentFont *this)
{
  if ((*(uint64_t (**)(TTenuousComponentFont *))(*(void *)this + 848))(this)) {
    return 0;
  }
  if ((*((_DWORD *)this + 46) & 0x40) == 0) {
    TBaseFont::DetermineFontFlags(this, 0x40u);
  }
  return (*((_DWORD *)this + 45) >> 6) & 1;
}

uint64_t TComponentFont::IsSystemUI(TComponentFont *this)
{
  return (*((unsigned __int8 *)this + 713) >> 4) & 1;
}

double CTLineGetTrailingWhitespaceWidth(CTLineRef line)
{
  if (!line) {
    return 0.0;
  }
  TLine::GetTrailingWhitespace(*((void *)line + 5), v2);
  return v2[2];
}

uint64_t TLine::GetTrailingWhitespace@<X0>(uint64_t this@<X0>, double *a2@<X8>)
{
  uint64_t v4 = *(void *)(this + 16);
  uint64_t v3 = *(void *)(this + 24);
  uint64_t v5 = v3 - v4;
  if (v3 == v4
    || (uint64_t v6 = this,
        this = TLine::FindRunWithCharIndex((TLine *)this, *(void *)(this + 72) + *(void *)(this + 80) - 1, 1),
        this < 0)
    || v5 >> 3 <= this
    || ((*(_WORD *)(v6 + 152) & 8) != 0
      ? (uint64_t v7 = 0)
      : (uint64_t v7 = ((uint64_t)(*(void *)(v6 + 24) - *(void *)(v6 + 16)) >> 3) - 1),
        this != v7))
  {
    *a2 = 0.0;
    a2[1] = 0.0;
    a2[2] = 0.0;
  }
  else
  {
    uint64_t v8 = *(void *)(*(void *)(*(void *)(v6 + 16) + 8 * this) + 40);
    int v9 = *(unsigned __int8 *)(v8 + 224);
    int64x2_t v10 = 0uLL;
    double v11 = 0.0;
    do
    {
      int64x2_t v12 = v10;
      this = TRun::GetTrailingWhitespace(v8, (double *)v13.i64);
      int64x2_t v10 = vaddq_s64(v13, v12);
      double v11 = v11 + v14;
      if (v13.i64[0] < *(void *)(v8 + 16)) {
        break;
      }
      uint64_t v8 = *(void *)(v8 + 32);
      if (!v8) {
        break;
      }
    }
    while (*(unsigned __int8 *)(v8 + 224) == v9);
    *(int64x2_t *)a2 = v10;
    a2[2] = v11;
  }
  return this;
}

uint64_t TLine::FindRunWithCharIndex(TLine *this, uint64_t a2, int a3)
{
  uint64_t v3 = (void *)*((void *)this + 2);
  uint64_t v4 = *((void *)this + 3) - (void)v3;
  if (v4 == 8) {
    return 0;
  }
  uint64_t v7 = *(void *)(*v3 + 40);
  uint64_t v8 = *(void *)(v7 + 8);
  uint64_t v9 = *(void *)(v7 + 16) + v8;
  if (v8 <= a2 && v9 > a2)
  {
    uint64_t v26 = 0;
LABEL_32:
    *((void *)this + 17) = v26;
    return v26;
  }
  uint64_t result = v4 >> 3;
  uint64_t v11 = *((void *)this + 17);
  if (v11 >= v4 >> 3)
  {
    if (result >= 0) {
      uint64_t v12 = v4 >> 3;
    }
    else {
      uint64_t v12 = result + 1;
    }
    uint64_t v11 = v12 >> 1;
    *((void *)this + 17) = v12 >> 1;
  }
  uint64_t v13 = *(void *)(v3[v11] + 40);
  uint64_t v14 = *(void *)(v13 + 8);
  uint64_t v15 = *(void *)(v13 + 16) + v14;
  if (v14 <= a2 && v15 > a2) {
    return v11;
  }
  uint64_t v26 = v11 + 1;
  if (v11 + 1 < result)
  {
    uint64_t v17 = *(void *)(v3[v26] + 40);
    uint64_t v18 = *(void *)(v17 + 8);
    uint64_t v19 = *(void *)(v17 + 16) + v18;
    if (v18 <= a2 && v19 > a2) {
      goto LABEL_32;
    }
  }
  __int16 v21 = *((_WORD *)this + 76);
  if (v11 >= 2 && (v21 & 1) != 0)
  {
    uint64_t v26 = v11 - 1;
    uint64_t v22 = *(void *)(v3[v11 - 1] + 40);
    uint64_t v23 = *(void *)(v22 + 8);
    uint64_t v24 = *(void *)(v22 + 16) + v23;
    if (v23 <= a2 && v24 > a2) {
      goto LABEL_32;
    }
LABEL_43:
    uint64_t v26 = result - 1;
    if (a3 < 0)
    {
      uint64_t v34 = -1;
    }
    else
    {
      uint64_t v26 = 0;
      uint64_t v34 = v4 >> 3;
    }
    if (v26 == v34) {
      goto LABEL_68;
    }
    while (1)
    {
      uint64_t v35 = *(void *)(v3[v26] + 40);
      uint64_t v36 = *(void *)(v35 + 8);
      uint64_t v37 = *(void *)(v35 + 16) + v36;
      if (v36 <= a2 && v37 > a2) {
        break;
      }
      v26 += a3;
      if (v34 == v26) {
        goto LABEL_68;
      }
    }
LABEL_67:
    if (v26 >= result) {
      goto LABEL_68;
    }
    goto LABEL_32;
  }
  if ((v21 & 1) != 0 || v4 < 808 || (*((_WORD *)this + 77) & 0x40) != 0) {
    goto LABEL_43;
  }
  CFRange v27 = &v3[result];
  unint64_t v28 = v4 >> 3;
  uint64_t v29 = v3;
  while (1)
  {
    unint64_t v30 = v28 >> 1;
    char v31 = &v29[v28 >> 1];
    uint64_t v32 = *(void *)(*v31 + 40);
    uint64_t v33 = *(void *)(v32 + 8);
    if (*(void *)(v32 + 16) + v33 <= a2)
    {
      uint64_t v29 = v31 + 1;
      unint64_t v30 = v28 + ~v30;
      goto LABEL_41;
    }
    if (v33 <= a2) {
      break;
    }
    CFRange v27 = &v29[v28 >> 1];
LABEL_41:
    unint64_t v28 = v30;
    if (!v30) {
      goto LABEL_68;
    }
  }
  if (v28 >= 2)
  {
    do
    {
      unint64_t v39 = v30 >> 1;
      uint64_t v40 = &v29[v30 >> 1];
      uint64_t v42 = *v40;
      unint64_t v41 = v40 + 1;
      v30 += ~(v30 >> 1);
      if (*(void *)(*(void *)(v42 + 40) + 16) + *(void *)(*(void *)(v42 + 40) + 8) <= a2) {
        uint64_t v29 = v41;
      }
      else {
        unint64_t v30 = v39;
      }
    }
    while (v30);
  }
  unint64_t v43 = v31 + 1;
  if (v27 != v31 + 1)
  {
    unint64_t v44 = v27 - (v31 + 1);
    CFRange v27 = v43;
    do
    {
      unint64_t v45 = v44 >> 1;
      uint64_t v46 = &v27[v44 >> 1];
      uint64_t v48 = *v46;
      uint64_t v47 = v46 + 1;
      v44 += ~(v44 >> 1);
      if (*(void *)(*(void *)(v48 + 40) + 8) > a2) {
        unint64_t v44 = v45;
      }
      else {
        CFRange v27 = v47;
      }
    }
    while (v44);
  }
  if (v29 != v27)
  {
    uint64_t v26 = v29 - v3;
    goto LABEL_67;
  }
LABEL_68:
  if (v4 >= 1)
  {
    uint64_t v49 = 0;
    uint64_t v50 = *((void *)this + 9) + *((void *)this + 10);
    if (result <= 1) {
      uint64_t v51 = 1;
    }
    else {
      uint64_t v51 = result;
    }
    do
    {
      if (*(void *)(*(void *)(v3[v49] + 40) + 8) < v50)
      {
        uint64_t v50 = *(void *)(*(void *)(v3[v49] + 40) + 8);
        uint64_t result = v49;
      }
      ++v49;
    }
    while (v51 != v49);
  }
  return result;
}

uint64_t TRun::GetTrailingWhitespace@<X0>(uint64_t this@<X0>, double *a2@<X8>)
{
  if (*(uint64_t *)(this + 208) <= 0)
  {
    *a2 = 0.0;
    a2[1] = 0.0;
    a2[2] = 0.0;
  }
  else
  {
    uint64_t v3 = (void *)this;
    uint64_t v4 = *(void *)(this + 216);
    uint64_t v5 = *(void *)(v4 + 32);
    if (v5 || (uint64_t v8 = *(void *)(v4 + 24)) == 0)
    {
      int v6 = 0;
      uint64_t v7 = v5 + 16 * *(void *)(this + 200);
    }
    else
    {
      uint64_t v7 = v8 + 8 * *(void *)(this + 200);
      int v6 = 1;
    }
    this = TRun::ResolveCharIndex((TRun *)this, *(void *)(this + 8) + *(void *)(this + 16) - 1);
    uint64_t v25 = v9;
    uint64_t v10 = this + 1;
    uint64_t v11 = v3[1];
    uint64_t v12 = 0;
    double v13 = 0.0;
    if (v11 > this || v3[2] + v11 <= this)
    {
      uint64_t v15 = this + 1;
    }
    else
    {
      uint64_t v16 = this + 1;
      while (1)
      {
        uint64_t v15 = this;
        uint64_t v17 = v3[27];
        uint64_t v18 = v3[25];
        if (*(__int16 *)(*(void *)(v17 + 16) + 2 * v18 + 2 * v25) != -1
          && (*(_DWORD *)(*(void *)(v17 + 40) + 4 * v18 + 4 * v25) & 0x21) == 0)
        {
          break;
        }
        ++v12;
        if (v6) {
          char v19 = 3;
        }
        else {
          char v19 = 4;
        }
        double v13 = v13 + *(double *)(v7 + (v25 << v19));
        this = TRun::GetPrevChar((TRun *)v3, this, &v25);
        uint64_t v20 = v3[1];
        if (v20 <= this)
        {
          uint64_t v16 = v15;
          if (v3[2] + v20 > this) {
            continue;
          }
        }
        goto LABEL_27;
      }
      double v24 = NAN;
      BOOL v23 = -86;
      this = TAttributes::GetKernSetting((TAttributes *)(v3 + 5), &v24, &v23);
      double v21 = v24;
      if (v24 <= 0.0 || !v23) {
        double v21 = -0.0;
      }
      double v13 = v13 + v21;
      uint64_t v15 = v16;
    }
LABEL_27:
    *(void *)a2 = v10 - v15;
    *((void *)a2 + 1) = v12;
    a2[2] = v13;
  }
  return this;
}

BOOL TAttributes::GetKernSetting(TAttributes *this, double *a2, BOOL *a3)
{
  *a2 = 0.0;
  if (a3) {
    *a3 = 0;
  }
  uint64_t v3 = *((void *)this + 15);
  if (!v3) {
    return (*((_WORD *)this + 69) & 0x40) == 0;
  }
  if (*(unsigned char *)(v3 + 24))
  {
    *a2 = *(double *)(v3 + 16);
    if (a3) {
      *a3 = 1;
    }
    if (*(unsigned char *)(v3 + 8))
    {
      double v4 = *(double *)v3;
      goto LABEL_11;
    }
  }
  else if (*(unsigned char *)(v3 + 8))
  {
    double v4 = *(double *)v3;
    *a2 = *(double *)v3;
LABEL_11:
    if (v4 == 0.0) {
      return 0;
    }
  }
  if ((*(_WORD *)(v3 + 66) & 1) == 0) {
    return (*((_WORD *)this + 69) & 0x40) == 0;
  }
  return 0;
}

unint64_t *AppendTrackAmountForRunIndex(unint64_t *result, uint64_t a2, double a3)
{
  if (a3 != 0.0)
  {
    uint64_t v5 = result;
    unint64_t v7 = *result;
    unint64_t v6 = result[1];
    if (*result != v6 && *(double *)(v6 - 24) == a3 && (uint64_t v8 = *(void *)(v6 - 8), v8 + *(void *)(v6 - 16) == a2))
    {
      *(void *)(v6 - 8) = v8 + 1;
    }
    else
    {
      unint64_t v9 = result[2];
      if (v6 >= v9)
      {
        unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v6 - v7) >> 3);
        unint64_t v12 = v11 + 1;
        if (v11 + 1 > 0xAAAAAAAAAAAAAAALL) {
          abort();
        }
        uint64_t v13 = (uint64_t)(result + 3);
        unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v9 - v7) >> 3);
        if (2 * v14 > v12) {
          unint64_t v12 = 2 * v14;
        }
        if (v14 >= 0x555555555555555) {
          unint64_t v15 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v15 = v12;
        }
        uint64_t v25 = v5 + 3;
        if (v15)
        {
          uint64_t v16 = TInlineBufferAllocator<std::pair<double,CFRange>,30ul>::allocate(v13, v15);
          unint64_t v7 = *v5;
          unint64_t v6 = v5[1];
        }
        else
        {
          uint64_t v16 = 0;
        }
        uint64_t v17 = &v16[24 * v11];
        *(double *)uint64_t v17 = a3;
        *((void *)v17 + 1) = a2;
        *((void *)v17 + 2) = 1;
        if (v6 == v7)
        {
          int64x2_t v20 = vdupq_n_s64(v7);
          uint64_t v18 = &v16[24 * v11];
        }
        else
        {
          uint64_t v18 = &v16[24 * v11];
          do
          {
            long long v19 = *(_OWORD *)(v6 - 24);
            *((void *)v18 - 1) = *(void *)(v6 - 8);
            *(_OWORD *)(v18 - 24) = v19;
            v18 -= 24;
            v6 -= 24;
          }
          while (v6 != v7);
          int64x2_t v20 = *(int64x2_t *)v5;
        }
        unint64_t v10 = (unint64_t)(v17 + 24);
        *uint64_t v5 = (unint64_t)v18;
        v5[1] = (unint64_t)(v17 + 24);
        int64x2_t v23 = v20;
        unint64_t v21 = v5[2];
        v5[2] = (unint64_t)&v16[24 * v15];
        unint64_t v24 = v21;
        uint64_t v22 = v20.i64[0];
        uint64_t result = (unint64_t *)std::__split_buffer<std::pair<double,CFRange>,TInlineBufferAllocator<std::pair<double,CFRange>,30ul> &>::~__split_buffer((uint64_t)&v22);
      }
      else
      {
        *(double *)unint64_t v6 = a3;
        *(void *)(v6 + 8) = a2;
        *(void *)(v6 + 16) = 1;
        unint64_t v10 = v6 + 24;
      }
      v5[1] = v10;
    }
  }
  return result;
}

char *TInlineBufferAllocator<std::pair<double,CFRange>,30ul>::allocate(uint64_t a1, unint64_t a2)
{
  unsigned int v2 = (char *)(a1 + 720);
  uint64_t result = *(char **)(a1 + 720);
  double v4 = &result[24 * a2];
  if (v4 <= v2)
  {
    *(void *)unsigned int v2 = v4;
  }
  else
  {
    if (a2 >= 0xAAAAAAAAAAAAAABLL) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    return (char *)operator new(24 * a2);
  }
  return result;
}

uint64_t std::__split_buffer<std::pair<double,CFRange>,TInlineBufferAllocator<std::pair<double,CFRange>,30ul> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != *(void *)(a1 + 8)) {
    *(void *)(a1 + 16) = (v2 - *(void *)(a1 + 8) - 24) % 0x18uLL + *(void *)(a1 + 8);
  }
  uint64_t v3 = *(void **)a1;
  if (*(void *)a1)
  {
    unint64_t v4 = *(void *)(a1 + 32);
    uint64_t v5 = (void *)(v4 + 720);
    if (v4 <= (unint64_t)v3 && v5 > v3)
    {
      if (*(void *)(a1 + 24) == *v5) {
        *uint64_t v5 = v3;
      }
    }
    else
    {
      operator delete(v3);
    }
  }
  return a1;
}

uint64_t TKerningEngineImplementation::DetermineSimilarRuns(uint64_t result, double **a2)
{
  uint64_t v2 = *(void *)(result + 16);
  if (v2 >= 2)
  {
    unint64_t v4 = (TRunGlue *)result;
    CFIndex v5 = *(void *)(result + 8);
    uint64_t v6 = *(void *)(*(void *)(*(void *)(*(void *)result + 16) + 8 * v5) + 48);
    double v25 = NAN;
    int KernSetting = TAttributes::GetKernSetting((TAttributes *)(v6 + 40), &v25, 0);
    CFIndex v8 = v5 + 1;
    while (1)
    {
      uint64_t v9 = *(void *)(*(void *)(*(void *)(*(void *)v4 + 16) + 8 * v8) + 48);
      double v24 = NAN;
      if (*(unsigned __int8 *)(v6 + 224) != *(unsigned __int8 *)(v9 + 224)) {
        break;
      }
      if (*(_DWORD *)(v6 + 304) != *(_DWORD *)(v9 + 304)) {
        break;
      }
      if (!TFont::Compare(*(TFont **)(atomic_load_explicit((atomic_ullong *volatile)(v6 + 56), memory_order_acquire)+ 40), *(const TFont **)(atomic_load_explicit((atomic_ullong *volatile)(v9 + 56), memory_order_acquire)+ 40), 0))break; {
      uint64_t result = TAttributes::GetKernSetting((TAttributes *)(v9 + 40), &v24, 0);
      }
      if (KernSetting != result) {
        break;
      }
      unint64_t v10 = a2[1];
      unint64_t v11 = (unint64_t)a2[2];
      if ((unint64_t)v10 >= v11)
      {
        uint64_t v13 = *a2;
        uint64_t v14 = v10 - *a2;
        unint64_t v15 = v14 + 1;
        if ((unint64_t)(v14 + 1) >> 61) {
          abort();
        }
        uint64_t v16 = v11 - (void)v13;
        if (v16 >> 2 > v15) {
          unint64_t v15 = v16 >> 2;
        }
        if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v17 = v15;
        }
        v26[4] = a2 + 3;
        if (v17)
        {
          uint64_t v18 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)(a2 + 3), v17);
          uint64_t v13 = *a2;
          unint64_t v10 = a2[1];
        }
        else
        {
          uint64_t v18 = 0;
        }
        long long v19 = (double *)&v18[8 * v14];
        *long long v19 = v24;
        if (v10 == v13)
        {
          unint64_t v21 = &v18[8 * v14];
        }
        else
        {
          int64x2_t v20 = v10;
          unint64_t v21 = &v18[8 * v14];
          do
          {
            uint64_t v22 = *((void *)v20-- - 1);
            *((void *)v21 - 1) = v22;
            v21 -= 8;
          }
          while (v20 != v13);
        }
        unint64_t v12 = v19 + 1;
        *a2 = (double *)v21;
        a2[1] = v19 + 1;
        int64x2_t v23 = a2[2];
        a2[2] = (double *)&v18[8 * v17];
        v26[2] = v10;
        v26[3] = v23;
        v26[0] = v13;
        v26[1] = v13;
        uint64_t result = std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)v26);
      }
      else
      {
        double *v10 = v24;
        unint64_t v12 = v10 + 1;
      }
      a2[1] = v12;
      if (++v8 >= v2 + v5) {
        return result;
      }
    }
    v27.uint64_t length = v8 - v5;
    v27.CFIndex location = v5;
    return (uint64_t)TRunGlue::SetRunRange(v4, v27);
  }
  return result;
}

uint64_t TFont::Compare(TFont *this, const TFont *a2, int a3)
{
  if (this == a2) {
    return 2;
  }
  v49[9] = v3;
  v49[10] = v4;
  if (*((double *)this + 2) != *((double *)a2 + 2) || ((*(unsigned __int8 *)this ^ *(unsigned __int8 *)a2) & 1) != 0) {
    return 0;
  }
  uint64_t v8 = *((void *)this + 5);
  uint64_t v9 = *((void *)a2 + 5);
  if (v8 != v9)
  {
    unint64_t v10 = (const void *)(v8 ? *((void *)this + 5) : MEMORY[0x1E4F1DAB8]);
    unint64_t v11 = (const void *)(v9 ? *((void *)a2 + 5) : MEMORY[0x1E4F1DAB8]);
    if (memcmp(v10, v11, 0x30uLL)) {
      return 0;
    }
  }
  CFDictionaryRef explicit = (const void *)atomic_load_explicit((atomic_ullong *volatile)this + 1, memory_order_acquire);
  uint64_t v13 = (const void *)atomic_load_explicit((atomic_ullong *volatile)a2 + 1, memory_order_acquire);
  if (explicit == v13) {
    return TFont::CompareExtras((atomic_ullong *)this, (atomic_ullong *)a2);
  }
  if (!explicit || !v13)
  {
    if (!a3) {
      return 0;
    }
LABEL_21:
    id v15 = (id)atomic_load_explicit((atomic_ullong *volatile)(*((void *)this + 50) + 96), memory_order_acquire);
    id v16 = (id)atomic_load_explicit((atomic_ullong *volatile)(*((void *)a2 + 50) + 96), memory_order_acquire);
    id v17 = v15;
    id v18 = v16;
    if (v17 == v18)
    {
    }
    else
    {
      long long v19 = v18;
      if (!v17 || !v18)
      {

        goto LABEL_28;
      }
      int v20 = CFEqual(v17, v18);

      if (!v20)
      {
LABEL_28:
        v43[0] = (id)0xAAAAAAAAAAAAAAAALL;
        (*(void (**)(id *__return_ptr))(**((void **)this + 50) + 72))(v43);
        v38[0] = (id)0xAAAAAAAAAAAAAAAALL;
        (*(void (**)(id *__return_ptr))(**((void **)a2 + 50) + 72))(v38);
        v49[0] = (id)atomic_load_explicit((atomic_ullong *volatile)v43, memory_order_acquire);
        id v48 = (id)atomic_load_explicit((atomic_ullong *volatile)v38, memory_order_acquire);
        BOOL v21 = StringEqual<TCFRef<__CFString const*>,TCFRef<__CFString const*>>((atomic_ullong *)v49, (atomic_ullong *)&v48);

        if (!v21) {
          goto LABEL_49;
        }
      }
    }
    int ShapingType = TBaseFont::GetShapingType(*((TBaseFont **)this + 50));
    if (ShapingType)
    {
      int v23 = ShapingType;
      if (ShapingType == TBaseFont::GetShapingType(*((TBaseFont **)a2 + 50)))
      {
        double v24 = (TBaseFont *)*((void *)this + 50);
        if (v23 == 1)
        {
          uint64_t CommonTable = (const void *)TBaseFont::GetCommonTable(v24, 1819566439, 0);
          uint64_t v26 = (const void *)TBaseFont::GetCommonTable(*((TBaseFont **)a2 + 50), 1819566439, 0);
          if (CommonTable == v26 || CommonTable && v26 && CFEqual(CommonTable, v26))
          {
            CFRange v27 = (const void *)TBaseFont::GetCommonTable(*((TBaseFont **)this + 50), 1836020344, 0);
            unint64_t v28 = (const void *)TBaseFont::GetCommonTable(*((TBaseFont **)a2 + 50), 1836020344, 0);
            if (v27 == v28)
            {

              return TFont::CompareExtras((atomic_ullong *)this, (atomic_ullong *)a2);
            }
            if (v27 && v28)
            {
              BOOL v29 = CFEqual(v27, v28) != 0;
              goto LABEL_54;
            }
          }
          goto LABEL_49;
        }
        unint64_t v30 = (const void *)TBaseFont::GetCommonTable(v24, 1196643650, 0);
        char v31 = (const void *)TBaseFont::GetCommonTable(*((TBaseFont **)a2 + 50), 1196643650, 0);
        if (v30 == v31 || v30 && v31 && CFEqual(v30, v31))
        {
          *(void *)&long long v32 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v32 + 1) = 0xAAAAAAAAAAAAAAAALL;
          long long v46 = v32;
          long long v47 = v32;
          long long v44 = v32;
          long long v45 = v32;
          *(_OWORD *)unint64_t v43 = v32;
          CFDataRef v33 = (const __CFData *)TBaseFont::GetCommonTable(*((TBaseFont **)this + 50), 1195656518, 0);
          OTL::GDEF::GDEF((OTL::GDEF *)v43, v33);
          *(void *)&long long v34 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v34 + 1) = 0xAAAAAAAAAAAAAAAALL;
          long long v41 = v34;
          long long v42 = v34;
          long long v39 = v34;
          long long v40 = v34;
          *(_OWORD *)unsigned __int8 v38 = v34;
          CFDataRef v35 = (const __CFData *)TBaseFont::GetCommonTable(*((TBaseFont **)a2 + 50), 1195656518, 0);
          OTL::GDEF::GDEF((OTL::GDEF *)v38, v35);
          if ((void)v44 != (void)v39)
          {
            BOOL v29 = 0;
            if ((void)v44 && (void)v39)
            {
              if (OTL::ClassDefTable::operator==((unsigned __int16 *)v44, (unsigned __int16 *)v39)) {
                goto LABEL_48;
              }
              BOOL v29 = 0;
            }
LABEL_54:

            if (v29) {
              return TFont::CompareExtras((atomic_ullong *)this, (atomic_ullong *)a2);
            }
            return 0;
          }
LABEL_48:
          FeatureTableSubstitutions = TFont::GetFeatureTableSubstitutions((uint64_t)this, 0);
          uint64_t v37 = TFont::GetFeatureTableSubstitutions((uint64_t)a2, 0);
          BOOL v29 = std::operator==[abi:nn180100]<unsigned short,OTL::FeatureTable const*,std::hash<unsigned short>,std::equal_to<unsigned short>,std::allocator<std::pair<unsigned short const,OTL::FeatureTable const*>>>((uint64_t)FeatureTableSubstitutions, v37);
          goto LABEL_54;
        }
      }
    }
LABEL_49:

    return 0;
  }
  uint64_t result = CFEqual(explicit, v13);
  if (!result && (a3 & 1) != 0) {
    goto LABEL_21;
  }
  if (result) {
    return TFont::CompareExtras((atomic_ullong *)this, (atomic_ullong *)a2);
  }
  return result;
}

uint64_t TRun::TRun(uint64_t a1, uint64_t a2, uint64_t a3, CFIndex a4, int a5)
{
  *(void *)a1 = &unk_1ED05F378;
  *(void *)(a1 + 8) = a3;
  *(void *)(a1 + 16) = a4;
  *(_WORD *)(a1 + 89) = 0;
  *(unsigned char *)(a1 + 91) = 0;
  *(unsigned char *)(a1 + 96) = 0;
  *(unsigned char *)(a1 + 144) = 0;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 168) = 0;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  TAttributes::operator=(a1 + 40, a2 + 40);
  TStorageRange::TStorageRange((TStorageRange *)(a1 + 192), (const TStorageRange *)(a2 + 192));
  *(void *)(a1 + 256) = *(void *)(a2 + 256);
  uint64_t v10 = *(void *)(a2 + 272);
  *(void *)(a1 + 264) = -1;
  *(void *)(a1 + 272) = v10;
  unint64_t v11 = (_OWORD *)MEMORY[0x1E4F1DB30];
  *(void *)(a1 + 280) = 0;
  *(_OWORD *)(a1 + 288) = *v11;
  *(_DWORD *)(a1 + 304) = *(_DWORD *)(a2 + 304);
  if (*(void *)(a2 + 312)) {
    operator new();
  }
  unint64_t v12 = 0;
  *(void *)(a1 + 312) = 0;
  uint64_t v13 = *(void *)(a2 + 8);
  CFIndex v14 = *(void *)(a2 + 16);
  if (a3 != v13 || a4 != v14)
  {
    uint64_t v16 = a3 + a4;
    if (a5 == 3 || *(_DWORD *)(a1 + 256) != 2) {
      goto LABEL_25;
    }
    CFIndex v17 = v14 + v13;
    BOOL v19 = a3 == v13 || v17 == v16;
    if (a5 == 1 && v19)
    {
      CFIndex v20 = v17 - v16;
      if (!v20) {
        CFIndex v14 = a4;
      }
      if (a3 == v13) {
        v21.uint64_t length = v20;
      }
      else {
        v21.uint64_t length = v14;
      }
      if (a3 == v13) {
        v21.CFIndex location = a3 + a4;
      }
      else {
        v21.CFIndex location = *(void *)(a2 + 8);
      }
      if (TRun::IsRangeMonotonic((TRun *)a2, v21))
      {
LABEL_25:
        GlyphIndexForunsigned int Char = TRun::GetGlyphIndexForCharIndex<false>(a2, v16 - 1);
        uint64_t v23 = TRun::GetGlyphIndexForCharIndex<false>(a2, a3);
        uint64_t v24 = *(void *)(*(void *)(a2 + 216) + 48);
        uint64_t v25 = *(void *)(a2 + 200);
        if (*(unsigned char *)(a1 + 224)) {
          uint64_t v26 = -1;
        }
        else {
          uint64_t v26 = 1;
        }
        uint64_t v56 = *(void *)(a2 + 200);
        uint64_t v57 = *(void *)(*(void *)(a2 + 216) + 48);
        if ((a5 & 0xFFFFFFFD) == 1 || *(_DWORD *)(a1 + 256) == 1)
        {
          uint64_t v27 = *(void *)(a2 + 208);
          if (*(unsigned char *)(a1 + 224)) {
            uint64_t v28 = -1;
          }
          else {
            uint64_t v28 = *(void *)(a2 + 208);
          }
          uint64_t v29 = v28 - v26;
          do
          {
            uint64_t v30 = GlyphIndexForChar;
            if (v29 == GlyphIndexForChar) {
              break;
            }
            GlyphIndexForChar += v26;
            uint64_t v31 = *(void *)(v24 + 8 * v26 + 8 * v25 + 8 * v30);
          }
          while (a3 <= v31 && v16 > v31);
          if ((*(unsigned char *)(a1 + 224) & 1) == 0) {
            uint64_t v27 = -1;
          }
          uint64_t v33 = v27 + v26;
          do
          {
            uint64_t v34 = v23;
            if (v33 == v23) {
              break;
            }
            v23 -= v26;
            uint64_t v35 = *(void *)(v24 - 8 * v26 + 8 * v25 + 8 * v34);
          }
          while (a3 <= v35 && v16 > v35);
          uint64_t v23 = v34;
          GlyphIndexForunsigned int Char = v30;
        }
        uint64_t v37 = v23 - GlyphIndexForChar;
        if (v23 >= GlyphIndexForChar) {
          CFIndex v38 = GlyphIndexForChar;
        }
        else {
          CFIndex v38 = v23;
        }
        if (v23 - GlyphIndexForChar < 0) {
          uint64_t v37 = GlyphIndexForChar - v23;
        }
        uint64_t v58 = v37;
        unint64_t v39 = v37 + 1;
        v60.CFIndex location = v38;
        v60.uint64_t length = v37 + 1;
        TStorageRange::SetStorageSubRange((TStorageRange *)(a1 + 192), v60);
        if (a5 != 2) {
          goto LABEL_87;
        }
        uint64_t v59 = TRun::GetGlyphIndexForCharIndex<false>(a2, v16 - 1);
        if (TRun::GetNextChar((TRun *)a2, v16 - 1, &v59) == v16)
        {
          uint64_t v40 = *(void *)(a1 + 8);
          if (v40 == *(void *)(a2 + 8)) {
            goto LABEL_87;
          }
          if (v40 >= 1)
          {
            uint64_t v48 = *(void *)(a2 + 216);
            uint64_t v49 = *(void *)(a2 + 200);
            uint64_t v50 = v23;
            while (v50 - v26 >= 0 && *(void *)(a2 + 208) > v50 - v26)
            {
              uint64_t v51 = v50 - v26;
              uint64_t v52 = *(void *)(*(void *)(v48 + 48) - 8 * v26 + 8 * v49 + 8 * v50);
              v50 -= v26;
              if (v52 < v40)
              {
                if ((*(_DWORD *)(*(void *)(v48 + 40) + 4 * v49 + 4 * v51) & 8) != 0) {
                  goto LABEL_80;
                }
                break;
              }
            }
          }
          if (*(void *)(v57 + 8 * v56 + 8 * v23) == v40
            && TRun::ResolveCharIndex((TRun *)a2, v40) == *(void *)(a1 + 8))
          {
LABEL_87:
            if (v38 != *(void *)(a2 + 200))
            {
              long long v41 = *(_OWORD **)(a1 + 312);
              if (v41) {
                *long long v41 = *MEMORY[0x1E4F1DB30];
              }
            }
            uint64_t v42 = *(void *)(a2 + 312);
            if (v42 && *(void *)(v42 + 56) != *(void *)(v42 + 64))
            {
              TRun::InitStretchFactors((TRun *)a1);
              uint64_t v43 = *(void *)(a1 + 312);
              std::vector<CGSize>::resize(v43 + 56, v39);
              long long v44 = *(_OWORD **)(v43 + 56);
              uint64_t v45 = *(void *)(a2 + 312);
              if (!v45 || (uint64_t v46 = *(void *)(v45 + 56), v46 == *(void *)(v45 + 64)))
              {
                unint64_t v47 = v58 + 2;
                do
                {
                  *v44++ = kUnitSize;
                  --v47;
                }
                while (v47 > 1);
              }
              else
              {
                memmove(v44, (const void *)(v46 + 16 * v38), 16 * v39);
              }
            }
            return a1;
          }
        }
LABEL_80:
        *(_DWORD *)(a1 + 256) = 3;
        unint64_t v53 = *(_OWORD **)(a1 + 312);
        if (!v53) {
          return a1;
        }
        _OWORD *v53 = *MEMORY[0x1E4F1DB30];
        goto LABEL_82;
      }
      unint64_t v12 = *(_OWORD **)(a1 + 312);
    }
    *(_DWORD *)(a1 + 256) = 3;
    if (!v12) {
      return a1;
    }
    *unint64_t v12 = *v11;
LABEL_82:
    uint64_t v54 = *(void *)(a1 + 312);
    if (v54)
    {
      uint64_t v55 = *(void *)(v54 + 56);
      if (v55 != *(void *)(v54 + 64)) {
        *(void *)(v54 + 64) = v55;
      }
    }
  }
  return a1;
}

uint64_t TRun::ResolveCharIndex(TRun *this, uint64_t a2)
{
  GlyphIndexForunsigned int Char = TRun::GetGlyphIndexForCharIndex<false>((uint64_t)this, a2);
  Nextunsigned int Char = TRun::GetNextChar(this, a2, &GlyphIndexForChar);
  uint64_t v5 = *((void *)this + 2) + *((void *)this + 1);
  if (NextChar < v5) {
    return TRun::GetPrevChar(this, NextChar, &GlyphIndexForChar);
  }
  uint64_t v7 = TRun::GetGlyphIndexForCharIndex<false>((uint64_t)this, v5 - 1);
  GlyphIndexForunsigned int Char = v7;
  uint64_t v8 = (void *)*((void *)this + 27);
  uint64_t v9 = *((void *)this + 25);
  uint64_t v10 = *(void *)(v8[6] + 8 * v9 + 8 * v7);
  if (*(__int16 *)(v8[2] + 2 * v9 + 2 * v7) == -1 || (*(_DWORD *)(v8[5] + 4 * v9 + 4 * v7) & 0x20) != 0)
  {
    uint64_t v14 = v7;
    Prevunsigned int Char = TRun::GetPrevChar(this, v10, &v14);
    uint64_t v11 = *((void *)this + 1);
    if (v11 <= PrevChar && *((void *)this + 2) + v11 > PrevChar)
    {
      GlyphIndexForunsigned int Char = v14;
      return PrevChar;
    }
  }
  return v10;
}

uint64_t TRun::GetGlyphIndexForCharIndex<false>(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 208);
  if (v2 < 1) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v6 = a2 - v5;
  if (a2 - v5 >= v2) {
    unint64_t v7 = v2 - 1;
  }
  else {
    unint64_t v7 = a2 - v5;
  }
  if (v6 >= 0) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = 0;
  }
  char v9 = *(unsigned char *)(a1 + 224);
  if (v9) {
    uint64_t v10 = v2 + ~v8;
  }
  else {
    uint64_t v10 = v8;
  }
  uint64_t v11 = *(void **)(a1 + 216);
  uint64_t v12 = v11[6];
  uint64_t v13 = *(void *)(a1 + 200);
  uint64_t v14 = v12 + 8 * v13;
  uint64_t v15 = *(void *)(v14 + 8 * v10);
  if (v15 == a2) {
    return v10;
  }
  if (*(_DWORD *)(a1 + 256) != 2)
  {
    if (v15 >= a2)
    {
      if (v9)
      {
        if (v2 + ~v8 <= v2 - 1) {
          uint64_t v10 = v2 - 1;
        }
        else {
          uint64_t v10 = v2 + ~v8;
        }
        uint64_t v18 = v2 - v8;
        while (v10 + 1 != v18)
        {
          uint64_t v19 = *(void *)(v14 + 8 * v18++);
          if (v19 <= a2) {
            return v18 - 1;
          }
        }
      }
      else if (v8 < 1)
      {
        return v8;
      }
      else
      {
        do
        {
          uint64_t v10 = v7 - 1;
          if (v7 < 2) {
            break;
          }
          uint64_t v17 = *(void *)(v12 + 8 * v13 - 8 + 8 * v7--);
        }
        while (v17 > a2);
      }
      return v10;
    }
    if ([v11 attachmentCountAtIndex:v10 + v13] + v15 >= a2) {
      return v10;
    }
  }

  return TRun::FindGlyphIndex<false>(a1, a2, 1);
}

uint64_t TRun::GetNextChar(TRun *this, uint64_t NextGlyphIndex, uint64_t *a3)
{
  int v6 = *((_DWORD *)this + 64);
  if (v6)
  {
    while (1)
    {
      if (v6 > 1)
      {
        uint64_t result = TRun::FindNextGlyphIndex(this, NextGlyphIndex, a3);
      }
      else
      {
        uint64_t v7 = *a3;
        if (*((unsigned char *)this + 224))
        {
          uint64_t v8 = v7 - 1;
          *a3 = v7 - 1;
          if (v7 > 0)
          {
LABEL_8:
            uint64_t result = *(void *)(*(void *)(*((void *)this + 27) + 48) + 8 * *((void *)this + 25) + 8 * v8);
            goto LABEL_9;
          }
        }
        else
        {
          uint64_t v8 = v7 + 1;
          *a3 = v7 + 1;
          if (v7 + 1 < *((void *)this + 26)) {
            goto LABEL_8;
          }
        }
        uint64_t result = *((void *)this + 2) + *((void *)this + 1);
      }
LABEL_9:
      if (result == NextGlyphIndex)
      {
        int v6 = *((_DWORD *)this + 64);
      }
      else
      {
        if (result >= *((void *)this + 2) + *((void *)this + 1)) {
          return result;
        }
        uint64_t v10 = *((void *)this + 27);
        uint64_t v11 = *((void *)this + 25);
        if (*(__int16 *)(*(void *)(v10 + 16) + 2 * v11 + 2 * *a3) != -1
          && (*(_DWORD *)(*(void *)(v10 + 40) + 4 * v11 + 4 * *a3) & 0x20) == 0)
        {
          return result;
        }
        int v6 = *((_DWORD *)this + 64);
        NextGlyphIndex = result;
      }
    }
  }
  while (1)
  {
    if (v6 > 1)
    {
      NextGlyphIndex = TRun::FindNextGlyphIndex(this, NextGlyphIndex, a3);
    }
    else
    {
      uint64_t v14 = *a3;
      if (*((unsigned char *)this + 224))
      {
        uint64_t v15 = v14 - 1;
        *a3 = v14 - 1;
        if (v14 > 0)
        {
LABEL_24:
          NextGlyphIndex = *(void *)(*(void *)(*((void *)this + 27) + 48)
                                     + 8 * *((void *)this + 25)
                                     + 8 * v15);
          goto LABEL_25;
        }
      }
      else
      {
        uint64_t v15 = v14 + 1;
        *a3 = v14 + 1;
        if (v14 + 1 < *((void *)this + 26)) {
          goto LABEL_24;
        }
      }
      NextGlyphIndex = *((void *)this + 2) + *((void *)this + 1);
    }
LABEL_25:
    if (NextGlyphIndex >= *((void *)this + 2) + *((void *)this + 1)) {
      return NextGlyphIndex;
    }
    uint64_t v12 = *((void *)this + 27);
    uint64_t v13 = *((void *)this + 25);
    if (*(__int16 *)(*(void *)(v12 + 16) + 2 * v13 + 2 * *a3) != -1
      && (*(_DWORD *)(*(void *)(v12 + 40) + 4 * v13 + 4 * *a3) & 0x20) == 0)
    {
      return NextGlyphIndex;
    }
    int v6 = *((_DWORD *)this + 64);
  }
}

uint64_t TGlyphEncoder::EncodeChars(_CTGlyphStorage **a1, CFIndex a2, CFIndex a3, uint64_t a4, int a5)
{
  uint64_t v175 = *MEMORY[0x1E4F143B8];
  id v148 = (id)0xAAAAAAAAAAAAAAAALL;
  uint64_t v10 = TCFBase<TRun>::Allocate();
  if (v10)
  {
    uint64_t v11 = (void *)v10;
    uint64_t v12 = *a1;
    uint64_t v13 = (TRun *)(v10 + 72);
    v11[2] = 0;
    v11[3] = 0;
    v11[4] = 0;
    void v11[5] = v13;
    v11[6] = v13;
    v11[7] = CTGlyphRun::CloneEntire;
    v11[8] = CTGlyphRun::CloneRange;
    v176.CFIndex location = a2;
    v176.uint64_t length = a3;
    TRun::TRun(v13, v176, v12, (const TAttributes *)a4);
    *(void *)&long long valuePtr = v11;
    *(void *)&v154.CGFloat width = atomic_exchange((atomic_ullong *volatile)&valuePtr, 0);
  }
  else
  {
    v154.CGFloat width = 0.0;
  }
  id v148 = (id)atomic_exchange((atomic_ullong *volatile)&v154, 0);

  if ((*(_WORD *)(a4 + 138) & 8) != 0) {
    goto LABEL_11;
  }
  uint64_t v15 = *(void *)(a4 + 120);
  if (v15)
  {
    if ((*(_WORD *)(v15 + 66) & 4) != 0) {
      goto LABEL_11;
    }
  }
  uint64_t v16 = *(TParagraphStyle ***)(a4 + 128);
  if (!v16) {
    goto LABEL_10;
  }
  unsigned int BaseWritingDirection = TParagraphStyle::GetBaseWritingDirection(v16, v14);
  if (BaseWritingDirection == 1)
  {
LABEL_11:
    uint64_t v18 = 2;
    goto LABEL_12;
  }
  if (BaseWritingDirection == 255)
  {
LABEL_10:
    if (GetDefaultWritingDirection() == 1) {
      goto LABEL_11;
    }
  }
  uint64_t v18 = 0;
LABEL_12:
  __int16 v19 = *(_WORD *)(a4 + 138);
  if ((v19 & 0x98F6) == 0)
  {
LABEL_61:
    int v65 = 0;
LABEL_62:
    CFDictionaryRef explicit = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)(a4 + 24), memory_order_acquire);
    if (*(unsigned char *)(a4 + 50))
    {
      if (a3)
      {
        stringIndices = (*a1)->_stringIndices;
        uint64_t v68 = 8 * a3;
        CFIndex v69 = a2;
        do
        {
          stringIndices[v69] = v69;
          ++v69;
          v68 -= 8;
        }
        while (v68);
      }
      LOBYTE(v18) = v18 | 8;
      goto LABEL_67;
    }
    *(void *)&long long v73 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v73 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long valuePtr = v73;
    *(_OWORD *)unsigned int v159 = v73;
    unint64_t v74 = atomic_load_explicit((atomic_ullong *volatile)&v148, memory_order_acquire);
    unsigned int v75 = *a1;
    *(void *)&long long valuePtr = a1 + 1;
    *((void *)&valuePtr + 1) = v75;
    *(void *)unsigned int v159 = a2;
    *(void *)&v159[8] = a3;
    *(void *)&v159[16] = v74;
    unint64_t v76 = atomic_load_explicit((atomic_ullong *volatile)(a4 + 16), memory_order_acquire);
    if (explicit) {
      BOOL v77 = 1;
    }
    else {
      BOOL v77 = TFont::ShapesPreferredLanguage(*(atomic_ullong **)(v76 + 40));
    }
    int v94 = TASCIIEncoder::Encode((TASCIIEncoder *)&valuePtr, v77);
    LODWORD(v18) = v94 | v18;
    if ((((int)v18 < 4) & ~v65) == 0)
    {
      if ((v94 & 0x10) != 0)
      {
        uint64_t v95 = *(void *)(atomic_load_explicit((atomic_ullong *volatile)&v148, memory_order_acquire) + 48);
        *(unsigned char *)(v95 + 225) |= 8u;
      }
LABEL_67:
      uint64_t v70 = (int64x2_t *)a1[25];
      uint64_t v71 = (v70[1].i64[1] - v70[1].i64[0]) >> 3;
      if ((v18 & 8) != 0)
      {
        *(void *)&long long v72 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v72 + 1) = 0xAAAAAAAAAAAAAAAALL;
        long long v173 = v72;
        long long v172 = v72;
        long long v171 = v72;
        long long v170 = v72;
        long long v169 = v72;
        long long v168 = v72;
        long long v167 = v72;
        long long v166 = v72;
        long long v165 = v72;
        long long v164 = v72;
        long long v163 = v72;
        long long v162 = v72;
        long long v161 = v72;
        long long v160 = v72;
        *(_OWORD *)&v159[8] = v72;
        long long valuePtr = 0uLL;
        *(void *)unsigned int v159 = 0;
        v174 = &v159[8];
        v154.CGFloat width = -3.72066208e-103;
        if ((*(_WORD *)(a4 + 138) & 0x200) != 0) {
          TAttributes::OriginalFont((atomic_ullong *)a4, (atomic_ullong *)&v154);
        }
        else {
          *(void *)&v154.CGFloat width = (id)atomic_load_explicit((atomic_ullong *volatile)(a4 + 16), memory_order_acquire);
        }
        v150[0] = 0;
        char v78 = TGlyphEncoder::RunUnicodeEncoderRecursively((uint64_t *)a1, 0, (atomic_ullong *)&v148, (_WORD **)atomic_load_explicit((atomic_ullong *volatile)&v154, memory_order_acquire), a2, a3, (char **)&valuePtr, a5, (TFontCascade **)v150, explicit, 0, 1);
        uint64_t v79 = (char *)a1[25]->_advanceWidths - (char *)a1[25]->_glyphs;
        uint64_t v80 = v71 + 1;
        if (v71 + 1 < v79 >> 3)
        {
          uint64_t v81 = v79 >> 3;
          uint64_t v82 = v71;
          do
          {
            glyphs = a1[25]->_glyphs;
            uint64_t v84 = *(void *)(*(void *)&glyphs[4 * v82] + 40);
            uint64_t v85 = *(void *)(*(void *)&glyphs[4 * v80] + 40);
            if (*(void *)(v84 + 216) == *(void *)(v85 + 216)
              && TFont::operator==(*(TFont **)(atomic_load_explicit((atomic_ullong *volatile)(v84 + 56), memory_order_acquire)+ 40), *(TFont **)(atomic_load_explicit((atomic_ullong *volatile)(v85 + 56), memory_order_acquire)+ 40)))
            {
              unsigned int v86 = TLine::AbsorbRunFollowing((TLine *)a1[25], v82);
              if (v86) {
                uint64_t v80 = v82;
              }
              v81 -= v86;
            }
            uint64_t v82 = v80++;
          }
          while (v80 < v81);
        }
        LOBYTE(v18) = v78 | v18;
        if ((void)valuePtr != *((void *)&valuePtr + 1))
        {
          LOBYTE(p_valuePtr) = -86;
          std::__sort<std::__less<long,long> &,long *>();
          long long v87 = valuePtr;
          if ((void)valuePtr != *((void *)&valuePtr + 1))
          {
            unsigned int v88 = (uint64_t *)(valuePtr + 8);
            while (v88 != *((uint64_t **)&valuePtr + 1))
            {
              uint64_t v89 = *(v88 - 1);
              uint64_t v90 = *v88++;
              if (v89 == v90)
              {
                unsigned __int16 v91 = v88 - 2;
                while (v88 != *((uint64_t **)&v87 + 1))
                {
                  uint64_t v92 = v89;
                  uint64_t v89 = *v88;
                  if (v92 != *v88)
                  {
                    v91[1] = v89;
                    ++v91;
                  }
                  ++v88;
                }
                uint64_t v93 = v91 + 1;
                goto LABEL_103;
              }
            }
          }
          uint64_t v93 = (void *)*((void *)&valuePtr + 1);
LABEL_103:
          if (*((void **)&v87 + 1) != v93) {
            *((void *)&valuePtr + 1) = v93;
          }
          uint64_t v98 = (TLine *)a1[25];
          if (a2) {
            TLine::DeleteChars((uint64_t)v98, (uint64_t)((uint64_t)v93 - v87) >> 3, (const uint64_t *)v87);
          }
          else {
            TLine::DeleteGlyphs(v98, 0, (uint64_t)((uint64_t)v93 - v87) >> 3, (const uint64_t *)v87);
          }
          LOBYTE(v18) = v18 | 0x10;
        }
        BOOL v99 = (TFontCascade *)v150[0];
        v150[0] = 0;
        if (v99)
        {
          TFontCascade::~TFontCascade(v99);
          MEMORY[0x1853275C0]();
        }

        *(void *)&v154.CGFloat width = &valuePtr;
        std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v154);
        if (!v65) {
          goto LABEL_165;
        }
      }
      else
      {
        *(void *)&long long valuePtr = atomic_exchange((atomic_ullong *volatile)&v148, 0);
        TLine::AppendRun(v70, (atomic_ullong *)&valuePtr);

        if (!v65) {
          goto LABEL_165;
        }
      }
      unsigned int v100 = (TLine *)a1[25];
      uint64_t v101 = *((void *)v100 + 3) - *((void *)v100 + 2);
      if (v71 < v101 >> 3)
      {
        uint64_t v102 = v101 >> 3;
        do
        {
          unsigned int v103 = *(atomic_ullong **)(*(void *)&a1[25]->_glyphs[4 * v71] + 48);
          atomic_ullong v104 = v103[25];
          uint64_t v105 = v103[26];
          atomic_ullong v106 = v103[27];
          uint64_t v107 = *(void *)(v106 + 16) + 2 * v104;
          unsigned int v108 = (double *)(*(void *)(v106 + 24) + 8 * v104);
          uint64_t v109 = *(void *)(atomic_load_explicit(v103 + 7, memory_order_acquire) + 40);
          uint64_t RenderingStyle = TAttributes::GetRenderingStyle((TAttributes *)(v103 + 5));
          TFont::GetAdvancesForGlyphs(v109, v107, v108, 1, v105, 0, RenderingStyle, 0);
          v103[24] = v111;
          ++v71;
        }
        while (v102 != v71);
        unsigned int v100 = (TLine *)a1[25];
      }
      TLine::SyncWithRuns(v100);
      goto LABEL_165;
    }
    char v96 = (int64x2_t *)a1[25];
    *(void *)&v154.CGFloat width = atomic_exchange((atomic_ullong *volatile)&v148, 0);
    TLine::AppendRun(v96, (atomic_ullong *)&v154);
    CGFloat width = v154.width;
LABEL_155:

LABEL_165:
    return (char)v18;
  }
  if ((v19 & 0x30) != 0)
  {
    if ((v19 & 0x10) != 0)
    {
      CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)a4, memory_order_acquire), @"CTImposedGlyph");
      LOWORD(valuePtr) = -21846;
      CFNumberGetValue(Value, kCFNumberShortType, &valuePtr);
      if ((_WORD)valuePtr)
      {
        unsigned __int16 v151 = valuePtr;
        uint64_t v21 = *(void *)(atomic_load_explicit((atomic_ullong *volatile)&v148, memory_order_acquire) + 48);
        uint64_t v22 = *(void *)(atomic_load_explicit((atomic_ullong *volatile)(v21 + 56), memory_order_acquire) + 40);
        uint64_t v23 = v151;
        if (TBaseFont::GetGlyphCount(*(TBaseFont **)(v22 + 400)) > v23)
        {
          v150[0] = (id)-1;
          v150[1] = (id)-1;
          TFont::GetUnsummedAdvancesForGlyphs(v22, (uint64_t)&v151, (double *)v150, 2, 1, 0, 0);
          uint64_t v24 = (uint64_t)*a1;
          uint64_t v25 = (unsigned __int16 *)&(*a1)->_glyphs[a2];
          if (a3 >= 1)
          {
            unint64_t v26 = a3 + 1;
            uint64_t v27 = (unsigned __int16 *)&(*a1)->_glyphs[a2];
            do
            {
              *v27++ = v151;
              --v26;
            }
            while (v26 > 1);
          }
          if (a3)
          {
            uint64_t v28 = *(void *)(v24 + 48);
            uint64_t v29 = 8 * a3;
            CFIndex v30 = a2;
            do
            {
              *(void *)(v28 + 8 * v30) = v30;
              ++v30;
              v29 -= 8;
            }
            while (v29);
          }
          *(void *)&long long v31 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v31 + 1) = 0xAAAAAAAAAAAAAAAALL;
          v156[3] = v31;
          v156[2] = v31;
          v156[1] = v31;
          v156[0] = v31;
          v154.CGFloat height = 0.0;
          uint64_t v155 = 0;
          v154.CGFloat width = 0.0;
          uint64_t v157 = v156;
          uint64_t v32 = TCharStream::LazyCopyChars(a1[1], a2, a3);
          uint64_t v33 = (id *)&(*a1)->_advanceWidths[a2];
          props = (*a1)->_props;
          *(void *)&long long v35 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v35 + 1) = 0xAAAAAAAAAAAAAAAALL;
          long long v173 = v35;
          uint64_t v36 = (uint64_t)&props[a2];
          long long v172 = v35;
          long long v171 = v35;
          long long v170 = v35;
          long long v169 = v35;
          long long v168 = v35;
          long long v167 = v35;
          long long v166 = v35;
          long long v165 = v35;
          long long v164 = v35;
          long long v163 = v35;
          long long v162 = v35;
          long long v161 = v35;
          long long v160 = v35;
          *(_OWORD *)&v159[8] = v35;
          long long valuePtr = 0uLL;
          *(void *)unsigned int v159 = 0;
          v174 = &v159[8];
          id v152 = 0;
          p_long long valuePtr = (uint64_t)&valuePtr;
          char v37 = TUnicodeEncoder::EncodePortion((char ***)&p_valuePtr, 0, v32, a3, *(void *)(v22 + 400), 0, (uint64_t)v25, (uint64_t)v33, 1, v36, (double *)&v152, 0);
          if (a3 >= 1 && (v37 & 0x10) != 0)
          {
            unint64_t v38 = a3 + 1;
            do
            {
              *v25++ = v151;
              --v38;
            }
            while (v38 > 1);
            unint64_t v39 = a3 + 1;
            uint64_t v40 = (_DWORD *)v36;
            do
            {
              *v40++ &= ~0x20u;
              --v39;
            }
            while (v39 > 1);
          }
          if (a3)
          {
            uint64_t v41 = 4 * a3;
            uint64_t v42 = (unsigned char *)v36;
            while ((*v42 & 4) == 0)
            {
              v42 += 4;
              v41 -= 4;
              if (!v41) {
                goto LABEL_159;
              }
            }
          }
          else
          {
            uint64_t v42 = (unsigned char *)v36;
          }
          if (v42 != (unsigned char *)(v36 + 4 * a3)) {
            *(unsigned char *)(v21 + 225) |= 1u;
          }
LABEL_159:
          if (a3 >= 1)
          {
            unint64_t v142 = a3 + 1;
            do
            {
              *v33++ = v150[0];
              --v142;
            }
            while (v142 > 1);
          }
          char v143 = v37 & 0xEE;
          *(double *)(v21 + 192) = *(double *)v150 * (double)a3;
          if ((void)valuePtr != *((void *)&valuePtr + 1)) {
            TRun::DeleteGlyphs((TRun *)v21, (uint64_t)(*((void *)&valuePtr + 1) - valuePtr) >> 3, (char *)valuePtr, a2);
          }
          unsigned int v144 = (int64x2_t *)a1[25];
          id v149 = (id)atomic_exchange((atomic_ullong *volatile)&v148, 0);
          TLine::AppendRun(v144, (atomic_ullong *)&v149);

          p_long long valuePtr = (uint64_t)&valuePtr;
          std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&p_valuePtr);
          *(void *)&long long valuePtr = &v154;
          std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&valuePtr);
          LOBYTE(v18) = v18 | v143 | 1;
          goto LABEL_165;
        }
      }
    }
    uint64_t v43 = (void *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)a4, memory_order_acquire), @"NSGlyphInfo");
    if (v43)
    {
      TGlyphInfo::TGlyphInfo((TGlyphInfo *)v150, v43);
      id v152 = (id)0xAAAAAAAAAAAAAAAALL;
      (*((void (**)(id *__return_ptr))a1[1]->super.isa + 2))(&v152);
      uint64_t v44 = *(void *)(atomic_load_explicit((atomic_ullong *volatile)&v148, memory_order_acquire) + 48);
      uint64_t GlyphForFont = TGlyphInfo::GetGlyphForFont((TGlyphInfo *)v150, (const __CTFont *)atomic_load_explicit((atomic_ullong *volatile)(v44 + 56), memory_order_acquire), (const __CFString *)atomic_load_explicit((atomic_ullong *volatile)&v152, memory_order_acquire));
      if ((GlyphForFont & 0xFF0000) != 0)
      {
        uint64_t v46 = (*a1)->_stringIndices;
        unint64_t v47 = (CGGlyph *)&(*a1)->_glyphs[a2];
        *unint64_t v47 = GlyphForFont;
        v154.CGFloat width = NAN;
        v154.CGFloat height = NAN;
        CTFontGetAdvancesForGlyphs((CTFontRef)atomic_load_explicit((atomic_ullong *volatile)(v44 + 56), memory_order_acquire), kCTFontOrientationDefault, v47, &v154, 1);
        -[_CTGlyphStorage setAdvance:atIndex:](*a1, "setAdvance:atIndex:", a2, v154.width, v154.height);
        if (a3)
        {
          uint64_t v48 = 8 * a3;
          uint64_t v49 = 8 * a3;
          do
          {
            v46[a2] = a2;
            ++a2;
            v49 -= 8;
          }
          while (v49);
          *(CGFloat *)(v44 + 192) = v154.width;
          if (a3 >= 2)
          {
            *(void *)&long long v50 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v50 + 1) = 0xAAAAAAAAAAAAAAAALL;
            long long v173 = v50;
            uint64_t v51 = a3 - 1;
            long long v172 = v50;
            long long v171 = v50;
            long long v170 = v50;
            long long v169 = v50;
            long long v168 = v50;
            long long v167 = v50;
            long long v166 = v50;
            long long v165 = v50;
            long long v164 = v50;
            long long v163 = v50;
            long long v162 = v50;
            long long v161 = v50;
            long long v160 = v50;
            *(_OWORD *)&v159[8] = v50;
            long long valuePtr = 0uLL;
            *(void *)unsigned int v159 = 0;
            v174 = &v159[8];
            std::vector<long,TInlineBufferAllocator<long,30ul>>::__vallocate[abi:nn180100](&valuePtr, a3 - 1);
            uint64_t v52 = *((void *)&valuePtr + 1);
            bzero(*((void **)&valuePtr + 1), v48 - 8);
            unint64_t v53 = (void *)(v52 + 8 * v51);
            *((void *)&valuePtr + 1) = v53;
            uint64_t v54 = (char *)valuePtr;
            if ((void *)valuePtr != v53)
            {
              uint64_t v55 = 1;
              uint64_t v56 = (void *)valuePtr;
              do
                *v56++ = v55++;
              while (v56 != v53);
            }
            TRun::DeleteGlyphs((TRun *)v44, v51, v54, (uint64_t)a1[25][1]._glyphs);
            p_long long valuePtr = (uint64_t)&valuePtr;
            std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&p_valuePtr);
          }
        }
        else
        {
          *(CGFloat *)(v44 + 192) = v154.width;
        }
        uint64_t v112 = (int64x2_t *)a1[25];
        *(void *)&long long valuePtr = atomic_exchange((atomic_ullong *volatile)&v148, 0);
        TLine::AppendRun(v112, (atomic_ullong *)&valuePtr);

        LOBYTE(v18) = v18 | 1;
        goto LABEL_165;
      }
    }
    goto LABEL_61;
  }
  v150[0] = (id)0xAAAAAAAAAAAAAAAALL;
  TGlyphEncoder::CreateSpecialRun((atomic_ullong *)v150, (uint64_t)a1, atomic_load_explicit((atomic_ullong *volatile)&v148, memory_order_acquire), *(_WORD *)(a4 + 138));
  if (atomic_load_explicit((atomic_ullong *volatile)v150, memory_order_acquire))
  {
    TCFRef<__CTFont const*>::Retain((atomic_ullong *)&v148, (id)atomic_load_explicit((atomic_ullong *volatile)v150, memory_order_acquire));
    __int16 v57 = *(_WORD *)(a4 + 138);
    if ((v57 & 0x40) != 0 && a3 == 1)
    {
      if (TCharStreamIterator::GetChar((TCharStreamIterator *)(a1 + 1), a2) == 65532)
      {
        uint64_t v58 = *(void *)(atomic_load_explicit((atomic_ullong *volatile)&v148, memory_order_acquire) + 48);
        unsigned int v59 = *(unsigned __int16 *)TBaseFont::GetCachedSpaceAndJoinerGlyphs(*(atomic_ullong **)(*(void *)(atomic_load_explicit((atomic_ullong *volatile)(*(void *)(atomic_load_explicit((atomic_ullong *volatile)&v148, memory_order_acquire) + 40)+ 56), memory_order_acquire)+ 40)+ 400), 0);
        if (v59 <= 1) {
          uint64_t v60 = 1;
        }
        else {
          uint64_t v60 = v59;
        }
        [*(id *)(v58 + 216) setGlyph:v60 atIndex:*(void *)(v58 + 200)];
        char v61 = *(unsigned char *)(v58 + 225);
        if (v60 == 0xFFFF && (v61 & 2) != 0) {
          *(unsigned char *)(v58 + 225) = v61 | 8;
        }
        [*(id *)(v58 + 216) setStringIndex:a2 atIndex:*(void *)(v58 + 200)];
        double v63 = (int64x2_t *)a1[25];
        *(void *)&long long valuePtr = atomic_exchange((atomic_ullong *volatile)&v148, 0);
        TLine::AppendRun(v63, (atomic_ullong *)&valuePtr);

LABEL_154:
        CGFloat width = *(double *)v150;
        goto LABEL_155;
      }
      if ((*(_WORD *)(a4 + 138) & 4) == 0) {
        goto LABEL_120;
      }
    }
    else
    {
      if ((v57 & 4) == 0)
      {
LABEL_120:
        int v65 = 0;
        goto LABEL_121;
      }
      if (!a3)
      {
LABEL_124:
        int v146 = a1;
        *(void *)&long long v116 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v116 + 1) = 0xAAAAAAAAAAAAAAAALL;
        long long v173 = v116;
        long long v172 = v116;
        long long v171 = v116;
        long long v170 = v116;
        long long v169 = v116;
        long long v168 = v116;
        long long v167 = v116;
        long long v166 = v116;
        long long v165 = v116;
        long long v164 = v116;
        long long v163 = v116;
        long long v162 = v116;
        long long v161 = v116;
        long long v160 = v116;
        *(_OWORD *)&v159[8] = v116;
        long long valuePtr = 0uLL;
        *(void *)unsigned int v159 = 0;
        v174 = &v159[8];
        uint64_t v117 = *(void *)(atomic_load_explicit((atomic_ullong *volatile)&v148, memory_order_acquire) + 48);
        p_long long valuePtr = a2;
        if (a3 >= 1)
        {
          uint64_t v147 = a3 + a2;
          unsigned int v118 = (TCharStreamIterator *)(v146 + 1);
          unsigned int v119 = (CGSize *)MEMORY[0x1E4F1DB30];
          uint64_t v120 = a2;
          do
          {
            uint64_t v121 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)v118 + 40))(*(void *)v118, v120, 2);
            uint64_t v123 = v121 + v122;
            if (v120 < v121 + v122)
            {
              uint64_t v124 = v121;
              do
              {
                if (v120 != v124)
                {
                  uint64_t v125 = v120 - a2;
                  [*(id *)(v117 + 216) setGlyph:0xFFFFLL atIndex:*(void *)(v117 + 200) + v125];
                  if ((*(unsigned char *)(v117 + 225) & 2) != 0) {
                    *(unsigned char *)(v117 + 225) |= 8u;
                  }
                  TStorageRange::SetAdvance((TStorageRange *)(v117 + 192), v125, *v119);
                  [*(id *)(v117 + 216) setProps:*(_DWORD *)(*(void *)(*(void *)(v117 + 216) + 40) + 4 * *(void *)(v117 + 200) + 4 * v125) | 0x20u atIndex:*(void *)(v117 + 200) + v125];
                  uint64_t v18 = v18 | 0x10;
                }
                if (!((TCharStreamIterator::GetFullChar(v118, &p_valuePtr, 0) - 0x10000) >> 20))
                {
                  CFIndex v126 = a2;
                  uint64_t v127 = v18;
                  uint64_t v128 = *((void *)&valuePtr + 1);
                  if (*((void *)&valuePtr + 1) >= *(void *)v159)
                  {
                    CGFloat v130 = *(double *)&valuePtr;
                    uint64_t v131 = (uint64_t)(*((void *)&valuePtr + 1) - valuePtr) >> 3;
                    unint64_t v132 = v131 + 1;
                    if ((unint64_t)(v131 + 1) >> 61) {
                      abort();
                    }
                    uint64_t v133 = *(void *)v159 - valuePtr;
                    if ((uint64_t)(*(void *)v159 - valuePtr) >> 2 > v132) {
                      unint64_t v132 = v133 >> 2;
                    }
                    if ((unint64_t)v133 >= 0x7FFFFFFFFFFFFFF8) {
                      unint64_t v134 = 0x1FFFFFFFFFFFFFFFLL;
                    }
                    else {
                      unint64_t v134 = v132;
                    }
                    *((void *)&v156[0] + 1) = &v159[8];
                    if (v134)
                    {
                      int64_t v135 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&v159[8], v134);
                      uint64_t v128 = *((void *)&valuePtr + 1);
                      CGFloat v130 = *(double *)&valuePtr;
                    }
                    else
                    {
                      int64_t v135 = 0;
                    }
                    int64_t v136 = (uint64_t *)&v135[8 * v131];
                    uint64_t *v136 = p_valuePtr;
                    if (v128 == *(void *)&v130)
                    {
                      double v138 = &v135[8 * v131];
                    }
                    else
                    {
                      uint64_t v137 = v128;
                      double v138 = &v135[8 * v131];
                      do
                      {
                        uint64_t v139 = *(void *)(v137 - 8);
                        v137 -= 8;
                        *((void *)v138 - 1) = v139;
                        v138 -= 8;
                      }
                      while (v137 != *(void *)&v130);
                    }
                    uint64_t v129 = v136 + 1;
                    *(void *)&long long valuePtr = v138;
                    *((void *)&valuePtr + 1) = v136 + 1;
                    uint64_t v140 = *(void *)v159;
                    *(void *)unsigned int v159 = &v135[8 * v134];
                    uint64_t v155 = v128;
                    *(void *)&v156[0] = v140;
                    v154.CGFloat width = v130;
                    v154.CGFloat height = v130;
                    std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v154);
                  }
                  else
                  {
                    **((void **)&valuePtr + 1) = p_valuePtr;
                    uint64_t v129 = (void *)(v128 + 8);
                  }
                  *((void *)&valuePtr + 1) = v129;
                  uint64_t v18 = v127;
                  a2 = v126;
                }
                uint64_t v120 = p_valuePtr + 1;
                p_long long valuePtr = v120;
              }
              while (v120 < v123);
            }
          }
          while (v120 < v147);
        }
        BOOL v141 = (int64x2_t *)v146[25];
        *(void *)&v154.CGFloat width = atomic_exchange((atomic_ullong *volatile)&v148, 0);
        TLine::AppendRun(v141, (atomic_ullong *)&v154);

        TLine::DeleteChars((uint64_t)v146[25], (uint64_t)(*((void *)&valuePtr + 1) - valuePtr) >> 3, (const uint64_t *)valuePtr);
        *(void *)&v154.CGFloat width = &valuePtr;
        std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v154);
        goto LABEL_154;
      }
    }
    unsigned int v113 = (*a1)->_stringIndices;
    uint64_t v114 = 8 * a3;
    CFIndex v115 = a2;
    do
    {
      v113[v115] = v115;
      ++v115;
      v114 -= 8;
    }
    while (v114);
    goto LABEL_124;
  }
  uint64_t v64 = TAttributes::GetRenderingStyle((TAttributes *)a4);
  if ((v64 & 0xFF00000000) != 0)
  {
    int v65 = (~(_BYTE)v64 & 5) != 0;
LABEL_121:

    goto LABEL_62;
  }
  std::__throw_bad_optional_access[abi:nn180100]();
  return TCFBase<TRun>::Allocate();
}

uint64_t TCFBase<TRun>::Allocate()
{
  if (TCFBase<TRun>::GetTypeID(void)::once != -1) {
    dispatch_once_f(&TCFBase<TRun>::GetTypeID(void)::once, 0, (dispatch_function_t)TCFBase<TRun>::GetTypeID(void)::{lambda(void *)#1}::__invoke);
  }

  return _CFRuntimeCreateInstance();
}

void TRun::TRun(TRun *this, CFRange a2, _CTGlyphStorage *a3, const TAttributes *a4)
{
  CFIndex length = a2.length;
  CFIndex location = a2.location;
  *(void *)this = &unk_1ED05F378;
  *(CFRange *)((char *)this + 8) = a2;
  *(_WORD *)((char *)this + 89) = 0;
  *((unsigned char *)this + 91) = 0;
  *((unsigned char *)this + 96) = 0;
  *((unsigned char *)this + 144) = 0;
  *((void *)this + 23) = 0;
  *((void *)this + 20) = 0;
  *((void *)this + 21) = 0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  TAttributes::operator=((uint64_t)this + 40, (uint64_t)a4);
  v8.CFIndex location = location;
  v8.CFIndex length = length;
  TStorageRange::TStorageRange((TRun *)((char *)this + 192), a3, v8);
  *((void *)this + 34) = 0;
  *((void *)this + 35) = 0;
  *((void *)this + 32) = 0;
  *((void *)this + 33) = -1;
  *((_OWORD *)this + 18) = *MEMORY[0x1E4F1DB30];
  *((_DWORD *)this + 76) = -1;
  *((void *)this + 39) = 0;
}

void TStorageRange::TStorageRange(TStorageRange *this, _CTGlyphStorage *a2, CFRange a3)
{
  CFIndex length = a3.length;
  CFIndex location = a3.location;
  *(void *)this = 0;
  *(CFRange *)((char *)this + 8) = a3;
  *((void *)this + 3) = a2;
  *((unsigned char *)this + 32) = 0;
  *((unsigned char *)this + 33) &= ~1u;
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    char v6 = 2;
  }
  else {
    char v6 = 0;
  }
  *((unsigned char *)this + 33) = *((unsigned char *)this + 33) & 0xFD | v6;
  int v7 = [*((id *)this + 3) isMemberOfClass:objc_opt_class()];
  char v8 = 0;
  if (v7)
  {
    if ([*((id *)this + 3) hasCustomAdvances]) {
      char v8 = 4;
    }
    else {
      char v8 = 0;
    }
  }
  char v9 = *((unsigned char *)this + 33);
  char v10 = v9 & 0xE3 | v8;
  *((unsigned char *)this + 33) = v10;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 5) = 0;
  if ((v9 & 2) != 0 && length)
  {
    uint64_t v11 = (__int16 *)(*(void *)(*((void *)this + 3) + 16) + 2 * location);
    while (1)
    {
      int v12 = *v11++;
      if (v12 == -1) {
        break;
      }
      if (!--length) {
        return;
      }
    }
    *((unsigned char *)this + 33) = v10 | 8;
  }
}

void TStorageRange::TStorageRange(TStorageRange *this, const TStorageRange *a2)
{
  *(void *)this = *(void *)a2;
  *(_OWORD *)((char *)this + 8) = *(_OWORD *)((char *)a2 + 8);
  *((void *)this + 3) = *((id *)a2 + 3);
  *((unsigned char *)this + 32) = *((unsigned char *)a2 + 32);
  int v4 = *((unsigned char *)this + 33) & 0xFE | *((unsigned char *)a2 + 33) & 1;
  *((unsigned char *)this + 33) = v4;
  unsigned int v5 = v4 & 0xFFFFFFFD | (2 * ((*((unsigned __int8 *)a2 + 33) >> 1) & 1));
  *((unsigned char *)this + 33) = v5;
  unsigned int v6 = v5 & 0xFFFFFFFB | (4 * ((*((unsigned __int8 *)a2 + 33) >> 2) & 1));
  *((unsigned char *)this + 33) = v6;
  LOBYTE(v6) = v6 & 0xF7 | (8 * ((*((unsigned char *)a2 + 33) & 8) != 0));
  *((unsigned char *)this + 33) = v6;
  *((unsigned char *)this + 33) = v6 & 0xEF | *((unsigned char *)a2 + 33) & 0x10;
  uint64_t v7 = *((void *)a2 + 6);
  *((void *)this + 5) = *((void *)a2 + 5);
  *((void *)this + 6) = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  *((void *)this + 7) = *((void *)a2 + 7);
}

uint64_t GetDefaultWritingDirection(void)
{
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3321888768;
  block[2] = ___Z26GetDefaultWritingDirectionv_block_invoke;
  block[3] = &__block_descriptor_33_8_32c40_ZTSKZ26GetDefaultWritingDirectionvE3__0_e5_v8__0l;
  if (qword_1EB2CDF90 != -1) {
    dispatch_once(&qword_1EB2CDF90, block);
  }
  return _MergedGlobals_10;
}

id TParagraphStyle::GetBaseWritingDirection(TParagraphStyle **this, const void *a2)
{
  int v2 = *((unsigned __int8 *)this + 8);
  uint64_t v3 = *this;
  if (v2) {
    return (id)*((char *)TParagraphStyle::GetNative(v3, a2) + 34);
  }

  return [(TParagraphStyle *)v3 baseWritingDirection];
}

uint64_t TRun::GetPrevChar(TRun *this, uint64_t PrevGlyphIndex, uint64_t *a3)
{
  int v6 = *((_DWORD *)this + 64);
  if (v6)
  {
    while (1)
    {
      while (1)
      {
        if (v6 > 1 || (*((unsigned char *)this + 224) & 1) != 0)
        {
          uint64_t result = TRun::FindPrevGlyphIndex(this, PrevGlyphIndex, a3);
        }
        else
        {
          uint64_t v7 = *a3;
          uint64_t v8 = *a3 - 1;
          *a3 = v8;
          uint64_t result = v7 <= 0
                 ? *((void *)this + 1) - 1
                 : *(void *)(*(void *)(*((void *)this + 27) + 48) + 8 * *((void *)this + 25) + 8 * v8);
        }
        if (result != PrevGlyphIndex) {
          break;
        }
        int v6 = *((_DWORD *)this + 64);
      }
      if (result < *((void *)this + 1)) {
        break;
      }
      uint64_t v10 = *((void *)this + 27);
      uint64_t v11 = *((void *)this + 25);
      if (*(__int16 *)(*(void *)(v10 + 16) + 2 * v11 + 2 * *a3) != -1
        && (*(_DWORD *)(*(void *)(v10 + 40) + 4 * v11 + 4 * *a3) & 0x20) == 0)
      {
        break;
      }
      int v6 = *((_DWORD *)this + 64);
      PrevGlyphIndex = result;
    }
  }
  else
  {
    while (1)
    {
      if (v6 > 1 || (*((unsigned char *)this + 224) & 1) != 0)
      {
        PrevGlyphIndex = TRun::FindPrevGlyphIndex(this, PrevGlyphIndex, a3);
      }
      else
      {
        uint64_t v14 = *a3;
        uint64_t v15 = *a3 - 1;
        *a3 = v15;
        PrevGlyphIndex = v14 <= 0
                       ? *((void *)this + 1) - 1
                       : *(void *)(*(void *)(*((void *)this + 27) + 48) + 8 * *((void *)this + 25) + 8 * v15);
      }
      if (PrevGlyphIndex < *((void *)this + 1)) {
        break;
      }
      uint64_t v12 = *((void *)this + 27);
      uint64_t v13 = *((void *)this + 25);
      if (*(__int16 *)(*(void *)(v12 + 16) + 2 * v13 + 2 * *a3) != -1
        && (*(_DWORD *)(*(void *)(v12 + 40) + 4 * v13 + 4 * *a3) & 0x20) == 0)
      {
        break;
      }
      int v6 = *((_DWORD *)this + 64);
    }
    return PrevGlyphIndex;
  }
  return result;
}

TRunGlue *TRunGlue::SetRunRange(TRunGlue *this, CFRange a2)
{
  int v2 = this;
  if (a2.location == *((void *)this + 1) && a2.length == *((void *)this + 2))
  {
    int v4 = *((_DWORD *)this + 6);
    *(CFRange *)((char *)this + 8) = a2;
    *((void *)this + 4) = -1;
    *((void *)this + 5) = -1;
    *((void *)this + 6) = 0;
    if ((v4 & 0x80000000) == 0) {
      return this;
    }
  }
  else
  {
    *(CFRange *)((char *)this + 8) = a2;
    *((void *)this + 4) = -1;
    *((void *)this + 5) = -1;
    *((void *)this + 6) = 0;
  }
  *((void *)this + 16) = a2.location;
  uint64_t v5 = *(void *)(*(void *)(*(void *)(*(void *)this + 16)
                             + 8 * TRunGlue::PhysicalRunIndexFromLogical(this, a2.location))
                 + 48);
  *((void *)v2 + 19) = v5;
  *((void *)v2 + 20) = 0;
  *((void *)v2 + 21) = *(void *)(v5 + 208);

  return (TRunGlue *)TRunGlue::UpdateForCurrentRealRun(v2);
}

double TStorageRange::SetStorageSubRange(TStorageRange *this, CFRange a2)
{
  CFIndex v3 = *((void *)this + 1) + a2.location;
  *(void *)this = 0;
  *((void *)this + 1) = v3;
  *((void *)this + 2) = a2.length;
  char v4 = *((unsigned char *)this + 33);
  if (v4)
  {
    *((unsigned char *)this + 33) = v4 & 0xFE;
    if (a2.length >= 1)
    {
      uint64_t v5 = (char *)(*(void *)(*((void *)this + 3) + 40) + 4 * v3);
      CFIndex length = a2.length;
      while (1)
      {
        char v7 = *v5;
        v5 += 4;
        if ((v7 & 4) != 0) {
          break;
        }
        if (!--length) {
          goto LABEL_8;
        }
      }
      *((unsigned char *)this + 33) = v4 | 1;
    }
  }
LABEL_8:
  double __C = NAN;
  uint64_t v8 = *((void *)this + 3);
  uint64_t v9 = *(void *)(v8 + 32);
  if (v9 || (uint64_t v11 = *(void *)(v8 + 24)) == 0)
  {
    uint64_t v10 = (const double *)(v9 + 16 * v3);
    a2.CFIndex location = 2;
  }
  else
  {
    uint64_t v10 = (const double *)(v11 + 8 * v3);
    a2.CFIndex location = 1;
  }
  vDSP_sveD(v10, a2.location, &__C, a2.length);
  double result = __C;
  *(double *)this = __C;
  return result;
}

unint64_t TBaseFont::GetMergeTable(atomic_ullong *this)
{
  unint64_t explicit = atomic_load_explicit(this + 74, memory_order_acquire);
  if (explicit == -1) {
    return 0;
  }
  if (!explicit)
  {
    id v4 = (id)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(id *__return_ptr))(*this + 480))(&v4);
    if (atomic_load_explicit((atomic_ullong *volatile)&v4, memory_order_acquire)) {
      operator new();
    }

    unint64_t explicit = 0;
    atomic_store(0xFFFFFFFFFFFFFFFFLL, (unint64_t *)this + 74);
  }
  return explicit;
}

void TAttributes::OriginalFont(atomic_ullong *this@<X0>, atomic_ullong *a2@<X8>)
{
  *a2 = 0;
  if (atomic_load_explicit(this, memory_order_acquire))
  {
    CFNumberRef Value = CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit(this, memory_order_acquire), @"NSOriginalFont");
    if (!Value)
    {
      if (!*((unsigned char *)this + 48))
      {
        unint64_t explicit = (void *)atomic_load_explicit(this + 2, memory_order_acquire);
        goto LABEL_6;
      }
      CFNumberRef Value = CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit(this, memory_order_acquire), @"NSFont");
    }
    unint64_t explicit = (void *)_CTFontEnsureFontRef(Value);
LABEL_6:
    id v6 = explicit;
  }
  if (!atomic_load_explicit(a2, memory_order_acquire))
  {
    if (qword_1EB2CE318 != -1) {
      dispatch_once_f(&qword_1EB2CE318, 0, (dispatch_function_t)TAttributes::GetDefaultFont(void)::{lambda(void *)#1}::__invoke);
    }
    id v6 = (id)qword_1EB2CE2E8;
  }
  if (*((unsigned char *)this + 50))
  {
    VerticalCopyOf((CTFontRef)atomic_load_explicit(a2, memory_order_acquire), (CTFontRef *)&v6);
  }
}

void __CTFontDrawGlyphsWithAdvancesInternal_block_invoke(void *a1, uint64_t a2, size_t count, int a4)
{
  uint64_t v5 = (CGContext *)a1[4];
  id v6 = (const CGGlyph *)(a1[5] + 2 * a2);
  char v7 = (const CGSize *)(a1[6] + 16 * a2);
  if (a4)
  {
    CGContextGetShouldDrawBitmapRuns();
    CGContextSetShouldDrawBitmapRuns();
    CGContextShowGlyphsWithAdvances(v5, v6, v7, count);
    CGContextSetShouldDrawBitmapRuns();
  }
  else
  {
    uint64_t v8 = (CGContext *)a1[4];
    CGContextShowGlyphsWithAdvances(v8, v6, v7, count);
  }
}

void ___ZL21DrawGlyphsAtPositionsPK5TFontPKtPK7CGPointmP9CGContextRKN12_GLOBAL__N_123DrawGlyphsConfigurationE_block_invoke(void *a1, uint64_t a2, size_t count, int a4)
{
  uint64_t v5 = (CGContext *)a1[4];
  id v6 = (const unsigned __int16 *)(a1[5] + 2 * a2);
  char v7 = (const CGPoint *)(a1[6] + 16 * a2);
  uint64_t v8 = (const uint64_t *)(a1[7] + 8 * a2);
  CFStringRef explicit = (const __CFString *)atomic_load_explicit(a1 + 8, memory_order_acquire);
  CFIndex v11 = a1[9];
  CFIndex v10 = a1[10];
  CFDictionaryRef v12 = (const __CFDictionary *)atomic_load_explicit(a1 + 11, memory_order_acquire);
  if (a4)
  {
    CGContextGetShouldDrawBitmapRuns();
    CGContextSetShouldDrawBitmapRuns();
    v14.CFIndex location = v11;
    v14.CFIndex length = v10;
    DrawGlyphsAtPositionsWithString(v5, v6, v7, v8, count, explicit, v14, v12);
    CGContextSetShouldDrawBitmapRuns();
  }
  else
  {
    v15.CFIndex location = v11;
    v15.CFIndex length = v10;
    DrawGlyphsAtPositionsWithString(v5, v6, v7, v8, count, explicit, v15, v12);
  }
}

void DrawGlyphsAtPositionsWithString(CGContext *a1, const unsigned __int16 *a2, const CGPoint *a3, const uint64_t *a4, size_t count, const __CFString *a6, CFRange a7, const __CFDictionary *a8)
{
  if (a4 && a6) {
    CGContextShowGlyphsAtPositionsWithString();
  }
  else {
    CGContextShowGlyphsAtPositions(a1, a2, a3, count);
  }
}

id **std::unique_ptr<OTL::MergeTable const>::reset[abi:nn180100](id **result, id *a2)
{
  int v2 = *result;
  *double result = a2;
  if (v2)
  {

    JUMPOUT(0x1853275C0);
  }
  return result;
}

atomic_ullong *OTL::MergeTable::MergeTable(atomic_ullong *a1, atomic_ullong *a2)
{
  *a1 = (atomic_ullong)(id)atomic_load_explicit(a2, memory_order_acquire);
  CFStringRef explicit = (const UInt8 *)atomic_load_explicit(a1, memory_order_acquire);
  if (explicit) {
    CFStringRef explicit = CFDataGetBytePtr((CFDataRef)explicit);
  }
  a1[1] = (atomic_ullong)explicit;
  CFDataRef v4 = (const __CFData *)atomic_load_explicit(a1, memory_order_acquire);
  if (v4 && (BytePtr = CFDataGetBytePtr(v4)) != 0) {
    unint64_t v6 = (unint64_t)&BytePtr[CFDataGetLength(v4)];
  }
  else {
    unint64_t v6 = 0;
  }
  a1[3] = 0;
  a1[2] = v6;
  a1[4] = 0;
  char v7 = (_WORD *)a1[1];
  if (v7)
  {
    uint64_t v8 = v7 + 4;
    if ((unint64_t)(v7 + 4) > v6
      || !v7[1]
      || !v7[2]
      || ((unsigned int v9 = __rev16((unsigned __int16)v7[1]),
           CFIndex v10 = (char *)v7 + __rev16((unsigned __int16)v7[2]),
           uint64_t v11 = v9 * v9,
           unint64_t v12 = (unint64_t)&v10[v11],
           (unint64_t)(v10 + 1) <= v6)
        ? (BOOL v13 = v6 - (void)v10 == v11)
        : (BOOL v13 = 0),
          !v13 ? (char v14 = 0) : (char v14 = 1),
          v12 <= v6 ? (BOOL v15 = v12 >= (unint64_t)v10) : (BOOL v15 = 0),
          !v15 && (v14 & 1) == 0))
    {
LABEL_53:
      a1[1] = 0;
      return a1;
    }
    a1[3] = (atomic_ullong)v10;
    if (v7[3])
    {
      unsigned int v16 = (unsigned __int16)*v8;
      if (*v8)
      {
        unint64_t v17 = __rev16((unsigned __int16)v7[3]);
        uint64_t v18 = (_WORD *)((char *)v7 + __rev16(v16));
        unint64_t v19 = (unint64_t)&v18[v17];
        BOOL v20 = (unint64_t)(v18 + 1) <= v6 && v17 == (v6 - (unint64_t)v18) >> 1;
        BOOL v21 = v20;
        BOOL v22 = v19 <= v6 && v19 >= (unint64_t)v18;
        if (v22 || v21)
        {
          if (v17 <= 1) {
            unint64_t v17 = 1;
          }
          uint64_t v24 = v18;
          while (1)
          {
            unsigned int v25 = *v24++;
            unint64_t v26 = (char *)v7 + (bswap32(v25) >> 16);
            if ((unint64_t)(v26 + 2) > v6) {
              break;
            }
            unsigned int v27 = bswap32(*(unsigned __int16 *)v26) >> 16;
            if (v27 == 2) {
              uint64_t v28 = 6 * (bswap32(*((unsigned __int16 *)v26 + 1)) >> 16) + 4;
            }
            else {
              uint64_t v28 = v27 == 1 ? 2 * (bswap32(*((unsigned __int16 *)v26 + 2)) >> 16) + 6 : 0;
            }
            uint64_t v29 = &v26[v28];
            if (v29 < v26 || (unint64_t)v29 > v6) {
              break;
            }
            if (!--v17)
            {
              a1[4] = (atomic_ullong)v18;
              return a1;
            }
          }
        }
      }
      goto LABEL_53;
    }
  }
  return a1;
}

uint64_t TBaseFont::SupportsConnectedLanguage(TBaseFont *this)
{
  v13[2] = *MEMORY[0x1E4F143B8];
  if ((*((_DWORD *)this + 46) & 0x800000) != 0) {
    return (*((_DWORD *)this + 45) >> 23) & 1;
  }
  CFStringRef explicit = (const __CFString *)atomic_load_explicit((atomic_ullong *volatile)this + 12, memory_order_acquire);
  if (explicit == @".SFUI"
    || explicit && CFStringHasPrefix(explicit, @".SFUI")
    || IsPingFangPostScriptName(explicit))
  {
    goto LABEL_26;
  }
  if (qword_1EB2CDAC0 == -1)
  {
    if (!explicit) {
      goto LABEL_17;
    }
  }
  else
  {
    dispatch_once_f(&qword_1EB2CDAC0, 0, (dispatch_function_t)TBaseFont::SupportsConnectedLanguage(void)const::$_0::__invoke);
    if (!explicit) {
      goto LABEL_17;
    }
  }
  if (qword_1EB2CDAB8 && CFSetContainsValue((CFSetRef)qword_1EB2CDAB8, explicit)) {
    goto LABEL_25;
  }
  CFIndex location = CFStringFind(explicit, @"-", 0).location;
  if (location != -1)
  {
    v14.CFIndex length = location;
    v14.CFIndex location = 0;
    CFDataRef v4 = (__CFString *)CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E4F1CF80], explicit, v14);
    CFSetRef v5 = (const __CFSet *)qword_1EB2CDAB8;
    unint64_t v6 = v4;
    char v7 = v6;
    if (v5)
    {
      int v8 = CFSetContainsValue(v5, v6);

      if (v8)
      {
        atomic_fetch_or_explicit((atomic_uint *volatile)this + 45, 0x800000u, memory_order_relaxed);
        atomic_fetch_or_explicit((atomic_uint *volatile)this + 46, 0x800000u, memory_order_relaxed);
        id v9 = v4;
LABEL_28:

        return 1;
      }
    }
    else
    {
    }
  }
LABEL_17:
  if (((*(uint64_t (**)(TBaseFont *))(*(void *)this + 704))(this) & 1) == 0)
  {
    v13[0] = 0xAAAAAAAAAAAAAAAALL;
    v13[1] = 0xAAAAAAAAAAAAAAAALL;
    id v12 = 0;
    if (TBaseFont::GetOS2UnicodeRanges(this, v13, (atomic_ullong *)&v12))
    {
      uint64_t v11 = 0;
      while (((*(_DWORD *)((char *)v13 + (((unint64_t)dword_184BA88F0[v11] >> 3) & 0x1FFFFFFC)) >> dword_184BA88F0[v11]) & 1) == 0)
      {
        if (++v11 == 8) {
          goto LABEL_22;
        }
      }
      atomic_fetch_or_explicit((atomic_uint *volatile)this + 45, 0x800000u, memory_order_relaxed);
      atomic_fetch_or_explicit((atomic_uint *volatile)this + 46, 0x800000u, memory_order_relaxed);
      id v9 = v12;
      goto LABEL_28;
    }
LABEL_22:
  }
  if (((*(uint64_t (**)(TBaseFont *))(*(void *)this + 704))(this) & 1) != 0
    || !(*(unsigned int (**)(TBaseFont *))(*(void *)this + 376))(this))
  {
LABEL_26:
    uint64_t result = 0;
    atomic_fetch_or_explicit((atomic_uint *volatile)this + 45, 0, memory_order_relaxed);
    atomic_fetch_or_explicit((atomic_uint *volatile)this + 46, 0x800000u, memory_order_relaxed);
    return result;
  }
LABEL_25:
  atomic_fetch_or_explicit((atomic_uint *volatile)this + 45, 0x800000u, memory_order_relaxed);
  atomic_fetch_or_explicit((atomic_uint *volatile)this + 46, 0x800000u, memory_order_relaxed);
  return 1;
}

BOOL StringEqual<TCFRef<__CFString const*>,TCFRef<__CFString const*>>(atomic_ullong *a1, atomic_ullong *a2)
{
  CFStringRef explicit = (const void *)atomic_load_explicit(a1, memory_order_acquire);
  CFIndex v3 = (const void *)atomic_load_explicit(a2, memory_order_acquire);
  if (explicit == v3) {
    return 1;
  }
  if (explicit) {
    BOOL v4 = v3 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  return !v4 && CFEqual(explicit, v3) != 0;
}

BOOL std::operator==[abi:nn180100]<unsigned short,OTL::FeatureTable const*,std::hash<unsigned short>,std::equal_to<unsigned short>,std::allocator<std::pair<unsigned short const,OTL::FeatureTable const*>>>(uint64_t a1, void *a2)
{
  if (*(void *)(a1 + 24) != a2[3]) {
    return 0;
  }
  CFIndex v3 = (unsigned __int16 *)(a1 + 16);
  do
  {
    CFIndex v3 = *(unsigned __int16 **)v3;
    BOOL v4 = v3 == 0;
    if (!v3) {
      break;
    }
    CFSetRef v5 = std::__hash_table<std::__hash_value_type<unsigned short,OTL::FeatureTable const*>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,OTL::FeatureTable const*>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,OTL::FeatureTable const*>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,OTL::FeatureTable const*>>>::find<unsigned short>(a2, v3 + 8);
    if (!v5) {
      break;
    }
  }
  while (v3[8] == *((unsigned __int16 *)v5 + 8) && *((void *)v3 + 3) == (void)v5[3]);
  return v4;
}

uint64_t TSplicedFont::IsLastResort(TSplicedFont *this)
{
  return 0;
}

void TLine::DeleteGlyphs(TLine *this, uint64_t a2, uint64_t a3, const uint64_t *a4)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *((void *)this + 3) - *((void *)this + 2);
  if (v4)
  {
    uint64_t v6 = a3;
    int v8 = this;
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    uint64_t v11 = v4 >> 3;
    do
    {
      if (a2 >= v11) {
        return;
      }
      id v12 = *(TRun **)(*(void *)(*((void *)v8 + 2) + 8 * a2) + 48);
      uint64_t v13 = *((void *)v12 + 26);
      if (v6 > v10)
      {
        unint64_t v14 = 0;
        while (a4[v10 + v14] - v9 < v13)
        {
          if (v6 - v10 == ++v14)
          {
            unint64_t v14 = v6 - v10;
            break;
          }
        }
        if (v14)
        {
          uint64_t v25 = v11;
          *(void *)&long long v15 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
          v30[13] = v15;
          v30[14] = v15;
          v30[11] = v15;
          v30[12] = v15;
          v30[9] = v15;
          v30[10] = v15;
          v30[7] = v15;
          v30[8] = v15;
          v30[5] = v15;
          v30[6] = v15;
          v30[3] = v15;
          v30[4] = v15;
          v30[1] = v15;
          void v30[2] = v15;
          v30[0] = v15;
          unsigned int v27 = 0;
          uint64_t v28 = 0;
          uint64_t v29 = 0;
          long long v31 = v30;
          std::vector<long,TInlineBufferAllocator<long,30ul>>::__vallocate[abi:nn180100](&v27, v14);
          unsigned int v16 = a4;
          unint64_t v17 = (char *)v28;
          bzero(v28, 8 * v14);
          uint64_t v18 = 0;
          unint64_t v19 = &v17[8 * v14];
          a4 = v16;
          uint64_t v28 = v19;
          BOOL v20 = v27;
          do
          {
            v20[v18] = v16[v10 + v18] - v9;
            ++v18;
          }
          while (v14 != v18);
          int v8 = this;
          uint64_t v21 = TRun::DeleteGlyphs(v12, v14, (char *)v20, *((void *)this + 9));
          *((void *)this + 18) += *((void *)v12 + 26) - v13;
          v10 += v18;
          if (v21 > 0 && TLine::AttachToPreviousRun(this, a2, v21))
          {
            uint64_t v6 = a3;
            if (v10 >= a3)
            {
LABEL_19:
              int v22 = 3;
            }
            else
            {
              uint64_t v25 = (uint64_t)(*((void *)this + 3) - *((void *)this + 2)) >> 3;
              v9 += v13;
              int v22 = 2;
            }
            unint64_t v26 = (void **)&v27;
            std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](&v26);
            uint64_t v11 = v25;
            continue;
          }
          uint64_t v6 = a3;
          if (v10 >= a3) {
            goto LABEL_19;
          }
          unint64_t v26 = (void **)&v27;
          std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](&v26);
          uint64_t v11 = v25;
        }
      }
      int v22 = 0;
      ++a2;
      v9 += v13;
    }
    while (v22 != 3);
  }
}

uint64_t TRun::DeleteGlyphs(TRun *this, uint64_t a2, char *a3, uint64_t a4)
{
  if (*((_DWORD *)this + 64))
  {
    if (*((unsigned char *)this + 224)) {
      uint64_t v7 = TRun::SetAttachmentsRightToLeft<false>((uint64_t)this, a2, a3, a4);
    }
    else {
      uint64_t v7 = TRun::SetAttachmentsLeftToRight<false>((uint64_t)this, a2, a3, a4);
    }
  }
  else if (*((unsigned char *)this + 224))
  {
    uint64_t v7 = TRun::SetAttachmentsRightToLeft<true>(this, a2, (uint64_t *)a3, a4);
  }
  else
  {
    uint64_t v7 = TRun::SetAttachmentsLeftToRight<true>((uint64_t)this, a2, (uint64_t)a3, a4);
  }
  uint64_t v8 = v7;
  TStorageRange::DeleteGlyphs((uint64_t)this + 192, a2, (const uint64_t *)a3);
  return v8;
}

uint64_t TBaseFont::GetOS2UnicodeRanges(TBaseFont *a1, _DWORD *a2, atomic_ullong *a3)
{
  if (TBaseFont::GetInitializedGraphicsFont(a1) && CGFontGetParserFont())
  {
    FPFontGetOS2UnicodeRanges();
    return 1;
  }
  else
  {
    id v10 = 0;
    if (a3) {
      TCFRef<__CTFont const*>::Retain((atomic_ullong *)&v10, (id)atomic_load_explicit(a3, memory_order_acquire));
    }
    if (!atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire))
    {
      (*(void (**)(id *__return_ptr, TBaseFont *, uint64_t))(*(void *)a1 + 480))(v9, a1, 1330851634);
    }
    if (atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire))
    {
      if (a3 && !atomic_load_explicit(a3, memory_order_acquire)) {
        TCFRef<__CTFont const*>::Retain(a3, (id)atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire));
      }
      memset(v9, 170, sizeof(v9));
      OS2::OS2((OS2 *)v9, (id)atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire));
      BOOL v6 = (uint64_t)v9[2] > 77;
      if ((uint64_t)v9[2] >= 78)
      {
        uint64_t v7 = (char *)v9[1];
        *a2 = bswap32(*(_DWORD *)((char *)v9[1] + 42));
        a2[1] = bswap32(*(_DWORD *)(v7 + 46));
        a2[2] = bswap32(*(_DWORD *)(v7 + 50));
        a2[3] = bswap32(*(_DWORD *)(v7 + 54));
      }
    }
    else
    {
      BOOL v6 = 0;
      *(void *)a2 = 0;
      *((void *)a2 + 1) = 0;
    }
  }
  return v6;
}

CGFloat CTFontGetAscent(CTFontRef font)
{
  if (!font) {
    return 0.0;
  }
  uint64_t v1 = (int *)*((void *)font + 5);
  if (v1[12]) {
    inited = v1 + 12;
  }
  else {
    inited = TFont::InitStrikeMetrics((TFont *)v1);
  }
  return *((double *)inited + 1);
}

CFIndex CTLineGetGlyphCount(CFIndex line)
{
  if (line) {
    return TLine::GetNonDeletedGlyphCount(*(TLine **)(line + 40));
  }
  return line;
}

uint64_t CTFontIsSystemUIFont(uint64_t result)
{
  if (result) {
    return TFont::IsSystemUIFontAndForShaping(*(atomic_ullong **)(result + 40), &v1);
  }
  return result;
}

unint64_t CTLineCreateHyphenatedLineWithOffset(uint64_t a1, CFIndex a2, CFIndex a3, __CFString *a4, double a5)
{
  __dst[34] = *MEMORY[0x1E4F143B8];
  id v36 = (id)CTLineCreateFromLineWithOffset(a1, a2, a3, a5);
  if (!atomic_load_explicit((atomic_ullong *volatile)&v36, memory_order_acquire)) {
    goto LABEL_28;
  }
  uint64_t v8 = *(void *)(atomic_load_explicit((atomic_ullong *volatile)&v36, memory_order_acquire) + 40);
  uint64_t v9 = *(void *)(v8 + 72);
  uint64_t v10 = *(void *)(v8 + 80);
  if (a1)
  {
    uint64_t v11 = *(void *)(a1 + 40);
    uint64_t v12 = *(void *)(v11 + 72);
    uint64_t v13 = *(void *)(v11 + 80);
  }
  else
  {
    uint64_t v12 = 0;
    uint64_t v13 = 0;
  }
  uint64_t v14 = v10 + v9;
  if (v10 + v9 >= v12 + v13)
  {
    BOOL v17 = 0;
  }
  else
  {
    *(void *)&long long v15 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&__dst[9] = v15;
    *(_OWORD *)&__dst[7] = v15;
    *(_OWORD *)&__dst[5] = v15;
    *(_OWORD *)&__dst[3] = v15;
    memset(__dst, 0, 24);
    __dst[11] = &__dst[3];
    unsigned int v16 = (_WORD *)TCharStream::LazyCopyChars(*(void **)v8, v10 + v9, 1);
    BOOL v17 = v16 && *v16 == 173;
    *(void *)char v37 = __dst;
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v37);
  }
  uint64_t RunWithCharIndex = TLine::FindRunWithCharIndex((TLine *)v8, v14 - 1, 1);
  uint64_t v19 = *(void *)(v8 + 16);
  if (RunWithCharIndex < (*(void *)(v8 + 24) - v19) >> 3)
  {
    uint64_t v20 = RunWithCharIndex;
    uint64_t v21 = *(void *)(*(void *)(v19 + 8 * RunWithCharIndex) + 40);
    memcpy(__dst, &unk_184B88B40, 0x110uLL);
    CFDictionaryRef v22 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)(v21 + 40), memory_order_acquire);
    TTypesetterString::TTypesetterString((TTypesetterString *)__dst, a4, v22);

    memset(&v38[16], 170, 32);
    long long v39 = unk_184B88D00;
    *(_OWORD *)&v37[96] = xmmword_184B88CB0;
    *(_OWORD *)&v37[112] = unk_184B88CC0;
    *(_OWORD *)unint64_t v38 = xmmword_184B88CD0;
    memset(v37, 170, 96);
    uint64_t v24 = __dst[0];
    uint64_t v23 = __dst[1];
    if (__dst[1]) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(__dst[1] + 8), 1uLL, memory_order_relaxed);
    }
    *(void *)char v37 = v24;
    *(void *)&v37[8] = v23;
    memset(&v37[16], 0, 24);
    *(void *)&v37[64] = &v37[40];
    BYTE8(v39) = 0;
    memset(&v37[72], 0, 56);
    memset(&v38[8], 0, 21);
    *(void *)&v38[32] = 0;
    *(void *)&v38[40] = 0;
    LOBYTE(v39) = 0;
    uint64_t v41 = 0;
    uint64_t v42 = 0;
    uint64_t v40 = 0;
    *(void *)unint64_t v38 = 0xFFEFFFFFFFFFFFFFLL;
    TTypesetter::FillLine((TTypesetter *)__dst, (TLine *)v37, 1.79769313e308, 0.0);
    uint64_t v25 = *(void *)&v37[16];
    if ((uint64_t)(*(void *)&v37[24] - *(void *)&v37[16]) >= 1)
    {
      if ((*(unsigned char *)(v21 + 224) & 1) == 0) {
        ++v20;
      }
      id v35 = **(id **)&v37[16];
      uint64_t v26 = *(void *)&v37[24] - (*(void *)&v37[16] + 8);
      if (*(void *)&v37[24] != *(void *)&v37[16] + 8) {
        memmove(*(void **)&v37[16], (const void *)(*(void *)&v37[16] + 8), *(void *)&v37[24] - (*(void *)&v37[16] + 8));
      }
      *(void *)&v37[24] = v25 + v26;
      uint64_t v27 = *(void *)(atomic_load_explicit((atomic_ullong *volatile)&v35, memory_order_acquire) + 48);
      *(void *)(v27 + 8) += v14;
      objc_msgSend(*(id *)(v27 + 216), "puntStringIndicesInRange:by:", *(void *)(v27 + 200), *(void *)(v27 + 208), v10 + v9);
      uint64_t v28 = TRun::EnsureRareData((TRun *)v27);
      TCFRef<__CTFont const*>::Retain((atomic_ullong *)(v28 + 80), a4);
      *(void *)(v27 + 272) = v8;
      TLine::DetachRuns((atomic_ullong *)v8);
      TLine::InsertLastRun((TLine *)v8, v20, (atomic_ullong *)&v35);
      if (v17)
      {
        *(void *)(v8 + 72) = v9;
        *(void *)(v8 + 80) = v10 + 1;
      }
      else
      {
        *(void *)(v27 + 8) = v14;
        *(void *)(v27 + 16) = 0;
      }
      TLine::ResetLine((TLine *)v8, *(const TCharStream **)v8);
      if ((~*(unsigned __int16 *)(v8 + 152) & 3) == 0)
      {
        CFIndex v30 = *(TLine **)v8;
        v34[0] = (TLine *)v8;
        v34[1] = v30;
        TTabEngine::ApplyTabs(v34, a5, 1.79769313e308, v29, (uint64_t)v33);
      }
    }
    unint64_t v31 = atomic_exchange((atomic_ullong *volatile)&v36, 0);
    TLine::~TLine((TLine *)v37);
    if (__dst[31]) {
      std::__shared_weak_count::__release_shared[abi:nn180100]((std::__shared_weak_count *)__dst[31]);
    }
    TLine::~TLine((TLine *)__dst);
  }
  else
  {
LABEL_28:
    unint64_t v31 = 0;
  }

  return v31;
}

void TLine::SyncWithRuns(TLine *this)
{
  *((void *)this + 13) = 0;
  *((void *)this + 14) = 0;
  *((void *)this + 15) = 0;
  *((void *)this + 16) = 0xFFEFFFFFFFFFFFFFLL;
  *((void *)this + 18) = 0;
  *((_WORD *)this + 76) &= 8u;
  *((_WORD *)this + 77) &= 0x161u;
  uint64_t v1 = *((void *)this + 3) - *((void *)this + 2);
  if (v1 >= 1)
  {
    uint64_t v3 = 0;
    uint64_t v4 = (unint64_t)v1 >> 3;
    if (v4 <= 1) {
      uint64_t v5 = 1;
    }
    else {
      uint64_t v5 = v4;
    }
    do
    {
      BOOL v6 = *(const TRun **)(*(void *)(*((void *)this + 2) + 8 * v3) + 48);
      (*(void (**)(const TRun *))(*(void *)v6 + 144))(v6);
      TLine::UpdateCachedMetricsForRun(this, v6);
      ++v3;
    }
    while (v5 != v3);
  }
}

uint64_t TRun::FindBreak@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, const TCharStream *a3@<X2>, int a4@<W3>, uint64_t a5@<X8>, double a6@<D0>)
{
  if (*(uint64_t *)(result + 208) <= 0)
  {
    *(unsigned char *)a5 = 0;
    *(void *)(a5 + 8) = 0;
    *(void *)(a5 + 16) = 0;
    return result;
  }
  uint64_t v10 = result;
  uint64_t v11 = *(void **)(result + 216);
  uint64_t v12 = v11[4];
  if (v12 || (uint64_t v14 = v11[3]) == 0)
  {
    int v62 = 0;
    uint64_t v13 = *(void *)(result + 200);
    uint64_t v61 = v12 + 16 * v13;
  }
  else
  {
    uint64_t v13 = *(void *)(result + 200);
    uint64_t v61 = v14 + 8 * v13;
    int v62 = 1;
  }
  uint64_t v66 = v11[6];
  char v64 = *(unsigned char *)(result + 225);
  GlyphIndexForunsigned int Char = TRun::GetGlyphIndexForCharIndex<true>(result, a2);
  int v15 = *(_DWORD *)(*(void *)(*(void *)(v10 + 216) + 40) + 4 * *(void *)(v10 + 200) + 4 * GlyphIndexForChar) >> 1;
  uint64_t result = (uint64_t)GetTable();
  double v17 = 0.0002;
  if (result)
  {
    uint64_t v18 = *(double **)(result + 64);
    if (v18) {
      double v17 = *v18;
    }
  }
  int v19 = v15 & 0x10;
  uint64_t v20 = *(void *)(v10 + 8);
  if (v20 == a2)
  {
    uint64_t v21 = *(double **)(v10 + 312);
    if (!v21) {
      uint64_t v21 = (double *)MEMORY[0x1E4F1DB30];
    }
    if (*(double *)(v10 + 192) + *v21 - a6 <= v17) {
      a6 = 1.79769313e308;
    }
  }
  uint64_t v22 = *(void *)(v10 + 16) + v20;
  uint64_t v23 = -1;
  if (*(unsigned char *)(v10 + 224)) {
    uint64_t v24 = 1;
  }
  else {
    uint64_t v24 = -1;
  }
  if (v22 <= a2)
  {
    int v65 = 0;
    uint64_t v25 = 0;
    double v27 = 0.0;
    double v26 = 0.0;
    uint64_t v28 = a2;
    goto LABEL_82;
  }
  char v57 = *(unsigned char *)(v10 + 224);
  int v58 = a4;
  uint64_t v25 = 0;
  int v65 = 0;
  uint64_t v56 = *(void *)(v10 + 208);
  double v26 = 0.0;
  double v27 = 0.0;
  uint64_t v28 = a2;
  uint64_t v59 = v66 + 8 * v13;
  uint64_t v63 = v13;
  while (1)
  {
    while (1)
    {
      uint64_t v29 = GlyphIndexForChar;
      uint64_t result = *(void *)(v10 + 216);
      uint64_t v30 = *(void *)(v10 + 200);
      unsigned int v31 = *(_DWORD *)(*(void *)(result + 40) + 4 * v30 + 4 * GlyphIndexForChar);
      if ((v31 & 2) == 0) {
        break;
      }
      if ((v31 & 0x20) == 0)
      {
        LOBYTE(v19) = v19 | 2;
        uint64_t v45 = *(void *)(v59 + 8 * GlyphIndexForChar);
        uint64_t result = [(id)result attachmentCountAtIndex:v30 + GlyphIndexForChar];
        uint64_t v28 = v45 + result + 1;
        goto LABEL_81;
      }
      if (*(int *)(v10 + 256) > 1)
      {
        uint64_t result = TRun::FindNextGlyphIndex((TRun *)v10, v28, &GlyphIndexForChar);
        uint64_t v28 = result;
      }
      else
      {
        if (*(unsigned char *)(v10 + 224))
        {
          uint64_t v32 = --GlyphIndexForChar;
          if (v29 > 0)
          {
LABEL_27:
            uint64_t v28 = *(void *)(*(void *)(result + 48) + 8 * v30 + 8 * v32);
            goto LABEL_28;
          }
        }
        else
        {
          uint64_t v32 = ++GlyphIndexForChar;
          if (v29 + 1 < *(void *)(v10 + 208)) {
            goto LABEL_27;
          }
        }
        uint64_t v28 = *(void *)(v10 + 16) + *(void *)(v10 + 8);
      }
LABEL_28:
      if (v28 >= v22) {
        goto LABEL_81;
      }
    }
    if ((v64 & 1) == 0) {
      break;
    }
    int v33 = (v31 >> 2) & 1;
    if (v58 || (v31 & 4) == 0) {
      goto LABEL_32;
    }
    v19 |= 4u;
    if (*(int *)(v10 + 256) > 1)
    {
      uint64_t result = TRun::FindNextGlyphIndex((TRun *)v10, v28, &GlyphIndexForChar);
      uint64_t v28 = result;
    }
    else
    {
      if (*(unsigned char *)(v10 + 224))
      {
        uint64_t v41 = --GlyphIndexForChar;
        if (v29 > 0)
        {
LABEL_76:
          uint64_t v28 = *(void *)(*(void *)(result + 48) + 8 * v30 + 8 * v41);
          goto LABEL_77;
        }
      }
      else
      {
        uint64_t v41 = ++GlyphIndexForChar;
        if (v29 + 1 < *(void *)(v10 + 208)) {
          goto LABEL_76;
        }
      }
      uint64_t v28 = *(void *)(v10 + 16) + *(void *)(v10 + 8);
    }
LABEL_77:
    uint64_t v13 = v63;
    if (v28 >= v22) {
      goto LABEL_82;
    }
  }
  int v33 = 0;
LABEL_32:
  char v34 = 3;
  if (!v62) {
    char v34 = 4;
  }
  double v35 = v26 + *(double *)(v61 + (GlyphIndexForChar << v34));
  if (!GlyphIndexForChar)
  {
    id v36 = *(double **)(v10 + 312);
    if (!v36) {
      id v36 = (double *)MEMORY[0x1E4F1DB30];
    }
    double v35 = v35 + *v36;
  }
  if (v35 - a6 <= v17)
  {
    double v27 = 0.0;
    uint64_t v23 = -1;
    goto LABEL_56;
  }
  if (v25 > v28 || (char v37 = v65, (uint64_t)&v65[v25] <= v28))
  {
    int v38 = v33;
    v16.n128_f64[0] = v35 - a6;
    uint64_t result = (*(uint64_t (**)(const TCharStream *, uint64_t, uint64_t, __n128))(*(void *)a3 + 40))(a3, v28, 2, v16);
    int v33 = v38;
    uint64_t v25 = result;
  }
  int v65 = v37;
  if ((char *)v28 != &v37[v25 - 1])
  {
    BOOL v42 = v23 == -1;
    if (v23 == -1) {
      uint64_t v23 = v28;
    }
    if (v42) {
      double v27 = v26;
    }
LABEL_56:
    if (v33) {
      v19 |= 4u;
    }
    if (*(int *)(v10 + 256) > 1)
    {
      uint64_t result = TRun::FindNextGlyphIndex((TRun *)v10, v28, &GlyphIndexForChar);
      uint64_t v28 = result;
      goto LABEL_65;
    }
    if (*(unsigned char *)(v10 + 224))
    {
      uint64_t v43 = v29 - 1;
      GlyphIndexForunsigned int Char = v29 - 1;
      if (v29 <= 0) {
        goto LABEL_61;
      }
    }
    else
    {
      uint64_t v43 = v29 + 1;
      GlyphIndexForunsigned int Char = v29 + 1;
      if (v29 + 1 >= *(void *)(v10 + 208))
      {
LABEL_61:
        uint64_t v28 = *(void *)(v10 + 16) + *(void *)(v10 + 8);
LABEL_65:
        double v26 = v35;
        goto LABEL_77;
      }
    }
    uint64_t v28 = *(void *)(*(void *)(*(void *)(v10 + 216) + 48) + 8 * *(void *)(v10 + 200) + 8 * v43);
    goto LABEL_65;
  }
  long long v39 = *(TParagraphStyle ***)(v10 + 168);
  if (v39) {
    char LineBoundsOptions = TParagraphStyle::GetLineBoundsOptions(v39, v37);
  }
  else {
    char LineBoundsOptions = 0;
  }
  if ((v57 & 1) == 0)
  {
    uint64_t result = TRun::GetRightHangersGlyphCountAndWidth((atomic_ullong *)v10, v29, LineBoundsOptions, a3, 1);
    if (result < 1) {
      goto LABEL_81;
    }
    uint64_t v44 = result + v29;
    GlyphIndexForunsigned int Char = result + v29;
    if (result + v29 == v56) {
      goto LABEL_112;
    }
    goto LABEL_74;
  }
  uint64_t result = TRun::GetLeftHangersGlyphCountAndWidth((atomic_ullong *)v10, v29, LineBoundsOptions, a3, -1);
  if (result < 1) {
    goto LABEL_81;
  }
  uint64_t v44 = v29 - result;
  GlyphIndexForunsigned int Char = v29 - result;
  if (v29 - result != -1)
  {
LABEL_74:
    uint64_t v28 = *(void *)(v59 + 8 * v44);
    goto LABEL_77;
  }
LABEL_112:
  uint64_t v28 = v22;
LABEL_81:
  uint64_t v13 = v63;
LABEL_82:
  char v46 = v19 & 0xFD;
  if (v23 >= v28) {
    char v46 = v19;
  }
  if (v23 == -1) {
    uint64_t v47 = v28;
  }
  else {
    uint64_t v47 = v23;
  }
  if (v23 == -1) {
    double v48 = v26;
  }
  else {
    double v48 = v27;
  }
  if (v23 == -1) {
    char v46 = v19;
  }
  uint64_t v49 = v47 - a2;
  if (v49 >= 1 && v49 < *(void *)(v10 + 16) && (v46 & 2) == 0)
  {
    uint64_t v51 = *(void *)(v10 + 208);
    uint64_t v52 = GlyphIndexForChar;
    do
    {
      uint64_t v53 = v52 + v24;
      if (v52 + v24 < 0 || v51 <= v53) {
        goto LABEL_107;
      }
      uint64_t v54 = *(void *)(v66 + 8 * v24 + 8 * v13 + 8 * v52);
      BOOL v55 = v25 > v54 || (uint64_t)&v65[v25] <= v54;
      uint64_t v52 = v53;
    }
    while (!v55);
    if ((*(_DWORD *)(*(void *)(*(void *)(v10 + 216) + 40) + 4 * *(void *)(v10 + 200) + 4 * v53) & 8) == 0)
    {
LABEL_107:
      if (GlyphIndexForChar < 0
        || v51 <= GlyphIndexForChar
        || (*(_DWORD *)(*(void *)(*(void *)(v10 + 216) + 40) + 4 * *(void *)(v10 + 200) + 4 * GlyphIndexForChar) & 0x380) == 0)
      {
        goto LABEL_111;
      }
    }
    v46 |= 0x10u;
  }
LABEL_111:
  *(unsigned char *)a5 = v46;
  *(void *)(a5 + 8) = v49;
  *(double *)(a5 + 16) = v48;
  return result;
}

double CTLineGetPenOffsetForFlush(CTLineRef line, CGFloat flushFactor, double flushWidth)
{
  if (!line) {
    return 0.0;
  }
  uint64_t v5 = (double *)*((void *)line + 5);
  double v6 = v5[13];
  TLine::GetLeftHangersGlyphCountAndWidth((TLine *)v5, 0);
  double v8 = v7;
  TLine::GetRightHangersGlyphCountAndWidth((TLine *)v5, 0);
  double v10 = 1.0;
  if (flushFactor <= 1.0) {
    double v10 = flushFactor;
  }
  if (flushFactor < 0.0) {
    double v10 = 0.0;
  }
  if (flushWidth <= 0.0) {
    return v10 * v8;
  }
  else {
    return v10 * (flushWidth - (v6 - v8 - v9));
  }
}

uint64_t TLine::GetRightHangersGlyphCountAndWidth(TLine *this, const unint64_t *a2)
{
  uint64_t v2 = *((void *)this + 3) - *((void *)this + 2);
  if (v2 >= 1)
  {
    uint64_t v5 = 0;
    unint64_t v6 = (unint64_t)v2 >> 3;
    BOOL v7 = (*((_WORD *)this + 76) & 8) == 0;
    unint64_t v8 = v6 - 1;
    double v9 = 0.0;
    while (1)
    {
      uint64_t v10 = *(void *)(*((void *)this + 2) + 8 * v8);
      uint64_t v11 = *(atomic_ullong **)(v10 + 40);
      CFIndex v12 = v11[26];
      if (!v7) {
        break;
      }
      uint64_t RightWhitespaceGlyphCountAndWidth = TRun::GetRightWhitespaceGlyphCountAndWidth(*(TRun **)(v10 + 40));
      v5 += RightWhitespaceGlyphCountAndWidth;
      double v9 = v9 + *(double *)&a2;
      if (RightWhitespaceGlyphCountAndWidth < v12)
      {
        uint64_t v14 = RightWhitespaceGlyphCountAndWidth;
        if (*(double *)&a2 == 0.0)
        {
LABEL_6:
          int v15 = (TParagraphStyle **)v11[21];
          if (v15) {
            LOBYTE(v16) = TParagraphStyle::GetLineBoundsOptions(v15, a2);
          }
          else {
            LOBYTE(v16) = 0;
          }
          goto LABEL_10;
        }
LABEL_9:
        uint64_t v16 = *a2;
LABEL_10:
        CFIndex RightHangersGlyphCountAndWidth = TRun::GetRightHangersGlyphCountAndWidth(v11, v12 + ~v14, v16, *(const TCharStream **)this, -1);
        v5 += RightHangersGlyphCountAndWidth;
        double v9 = v9 + *(double *)&a2;
        if (RightHangersGlyphCountAndWidth < v12) {
          return v5;
        }
        BOOL v7 = 0;
        goto LABEL_13;
      }
      BOOL v7 = 1;
LABEL_13:
      unint64_t v18 = v8-- + 1;
      if (v18 <= 1) {
        return v5;
      }
    }
    uint64_t v14 = 0;
    if (*(double *)&a2 == 0.0) {
      goto LABEL_6;
    }
    goto LABEL_9;
  }
  return 0;
}

CFIndex TRun::GetRightHangersGlyphCountAndWidth(atomic_ullong *this, uint64_t a2, char a3, const TCharStream *a4, int a5)
{
  char v7 = a3;
  CFIndex v8 = a2;
  double v9 = (TRun *)this;
  uint64_t v10 = (void *)this[27];
  uint64_t v11 = v10[4];
  if (v11 || (uint64_t v15 = v10[3]) == 0)
  {
    int v12 = 0;
    atomic_ullong v13 = this[25];
    uint64_t v14 = v11 + 16 * v13;
  }
  else
  {
    atomic_ullong v13 = this[25];
    uint64_t v14 = v15 + 8 * v13;
    int v12 = 1;
  }
  CFIndex v46 = this[26];
  if (a2 < 0)
  {
    TAttributes::GetCompositionLanguage((TAttributes *)(this + 5), (const void *)a2);
    CFIndex v27 = v8;
    goto LABEL_31;
  }
  if ((a3 & 4) != 0 && v46 > a2)
  {
    uint64_t v16 = v10[2] + 2 * v13;
    uint64_t v63 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v17 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v17 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)uint64_t v61 = v17;
    long long v62 = v17;
    TAATPropTable::TAATPropTable((TAATPropTable *)v61, (const __CTFont *)atomic_load_explicit(this + 7, memory_order_acquire));
    double v48 = a4;
    long long v59 = 0u;
    long long v49 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    long long v58 = 0u;
    uint64_t v18 = *((void *)a4 + 2);
    uint64_t v60 = 0;
    *(void *)&long long v59 = v18;
    uint64_t v40 = a4;
    if (qword_1EB2CDEB8 != -1) {
      dispatch_once_f(&qword_1EB2CDEB8, 0, (dispatch_function_t)GetRightHangingCharacters(void)::$_0::__invoke);
    }
    int v41 = a5;
    BOOL v42 = v9;
    uint64_t v19 = *(void *)(*((void *)v9 + 27) + 48) + 8 * *((void *)v9 + 25);
    uint64_t v20 = a5;
    CFIndex v21 = v14 + 16 * v8;
    CFIndex v22 = v8;
    uint64_t v23 = 16 * a5;
    CFIndex v24 = v14 + 8 * v22;
    uint64_t v25 = 8 * a5;
    double v26 = 0.0;
    CFIndex v44 = v22;
    CFCharacterSetRef theSet = (const __CFCharacterSet *)qword_1EB2CDEB0;
    CFIndex v27 = v22;
    do
    {
      uint64_t v47 = *(void *)(v19 + 8 * v27);
      uint64_t v28 = (uint64_t (*)(void *, void))*((void *)&v62 + 1);
      uint64_t v29 = (uint64_t *)((char *)v61 + (v63 >> 1));
      if (v63) {
        uint64_t v28 = *(uint64_t (**)(void *, void))(*v29 + DWORD2(v62));
      }
      if ((v28(v29, *(unsigned __int16 *)(v16 + 2 * v27)) & 0x2000) == 0)
      {
        Fullunsigned int Char = TCharStreamIterator::GetFullChar((TCharStreamIterator *)&v48, &v47, 0);
        if (!CFCharacterSetIsLongCharacterMember(theSet, FullChar)) {
          break;
        }
      }
      unsigned int v31 = (double *)(v12 ? v24 : v21);
      double v26 = v26 + *v31;
      v27 += v20;
      if (v27 < 0) {
        break;
      }
      v21 += v23;
      v24 += v25;
    }
    while (v46 > v27);

    double v9 = v42;
    uint64_t CompositionLanguage = TAttributes::GetCompositionLanguage((TRun *)((char *)v42 + 40), v32);
    if (v27 < 0)
    {
      char v7 = a3;
      CFIndex v8 = v44;
      a5 = v41;
      goto LABEL_31;
    }
    uint64_t v35 = CompositionLanguage;
    char v7 = a3;
    CFIndex v8 = v44;
    a4 = v40;
    a5 = v41;
  }
  else
  {
    uint64_t v35 = TAttributes::GetCompositionLanguage((TAttributes *)(this + 5), (const void *)a2);
    CFIndex v27 = v8;
  }
  if (v46 > v27 && v35 >= 2)
  {
    double v48 = a4;
    long long v59 = 0u;
    long long v49 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    long long v58 = 0u;
    uint64_t v36 = *((void *)a4 + 2);
    uint64_t v60 = 0;
    *(void *)&long long v59 = v36;
    v61[0] = *(void *)(*(void *)(*((void *)v9 + 27) + 48) + 8 * *((void *)v9 + 25) + 8 * v27);
    char v37 = (CJKCompositionEngine *)TCharStreamIterator::GetFullChar((TCharStreamIterator *)&v48, v61, 0);
    UChar32 v38 = (int)v37;
    if (CJKCompositionEngine::IsEnabled(v37))
    {
      LOBYTE(v47) = -86;
      if (CJKCompositionRules::ShouldGlyphImageRightFlush(v35, *((unsigned __int8 *)v9 + 90), v38, (BOOL *)&v47))
      {
        v34.CFIndex location = v27;
        GetOpticalBoundsAdjustment(1, (atomic_ullong *)v9, v34);
        if (!(_BYTE)v47) {
          atomic_load_explicit((atomic_ullong *volatile)v9 + 7, memory_order_acquire);
        }
      }
    }
  }
LABEL_31:
  if (a5 >= 1) {
    return v27 - v8;
  }
  if (v27 < 0 || v46 <= v27) {
    return v8 - v27;
  }
  return v8 - v27 + TRun::GetRightPartialHangingGlyphCountAndWidth(v9, v27, v7, (const TCharStream *)v34.length);
}

uint64_t TRun::GetRightWhitespaceGlyphCountAndWidth(TRun *this)
{
  uint64_t v1 = *((void *)this + 26);
  uint64_t v2 = (void *)*((void *)this + 27);
  uint64_t v3 = v1 - 1;
  uint64_t v4 = v2[4];
  if (v4 || (uint64_t v8 = v2[3]) == 0)
  {
    int v5 = 0;
    uint64_t v6 = *((void *)this + 25);
    uint64_t v7 = v4 + 16 * v6;
  }
  else
  {
    uint64_t v6 = *((void *)this + 25);
    uint64_t v7 = v8 + 8 * v6;
    int v5 = 1;
  }
  if (v1 < 1)
  {
    uint64_t v13 = v1 - 1;
  }
  else
  {
    uint64_t v9 = v2[5] + 4 * v6;
    uint64_t v10 = v7 + 16 * v1 - 16;
    uint64_t v11 = v7 + 8 * v1 - 8;
    double v12 = 0.0;
    uint64_t v13 = v1 - 1;
    while ((*(_DWORD *)(v9 + 4 * v13) & 0x20) != 0 || (*(_DWORD *)(v9 + 4 * v13) & 5) == 1)
    {
      if (v5) {
        uint64_t v14 = (double *)v11;
      }
      else {
        uint64_t v14 = (double *)v10;
      }
      double v12 = v12 + *v14;
      v10 -= 16;
      v11 -= 8;
      if (v13-- <= 0)
      {
        uint64_t v13 = -1;
        return v3 - v13;
      }
    }
  }
  return v3 - v13;
}

uint64_t TRun::GetRightPartialHangingGlyphCountAndWidth(TRun *this, uint64_t a2, char a3, const TCharStream *a4)
{
  uint64_t v6 = (void *)*((void *)this + 27);
  uint64_t v7 = v6[4];
  if (v7 || (uint64_t v11 = v6[3]) == 0)
  {
    int v8 = 0;
    uint64_t v9 = *((void *)this + 25);
    uint64_t v10 = v7 + 16 * v9;
  }
  else
  {
    uint64_t v9 = *((void *)this + 25);
    uint64_t v10 = v11 + 8 * v9;
    int v8 = 1;
  }
  if ((a3 & 0x18) != 0)
  {
    uint64_t v12 = v6[2] + 2 * v9;
    uint64_t v13 = *(TFont **)(atomic_load_explicit((atomic_ullong *volatile)this + 7, memory_order_acquire) + 40);
    TFont::GetMaxAdvance(v13);
    if ((a3 & 0x10) != 0)
    {
      *(_WORD *)uint64_t v28 = *(_WORD *)(v12 + 2 * a2);
      v25.CGFloat width = NAN;
      v25.CGFloat height = NAN;
      v27.origin = (CGPoint)v25;
      v27.size = v25;
      v30.origin.x = TFont::GetOpticalBoundsForGlyphs(v13, (const unsigned __int16 *)v28, &v27, 1);
      CGRectGetMaxX(v30);
    }
    else
    {
      double v15 = v14;
      uint64_t v16 = v10 + 16 * a2;
      uint64_t v17 = v10 + 8 * a2;
      double v18 = 0.0;
      double v19 = -1.79769313e308;
      do
      {
        if (v15 < v18) {
          break;
        }
        *(_WORD *)uint64_t v28 = *(_WORD *)(v12 + 2 * a2);
        v20.CGFloat width = NAN;
        v20.CGFloat height = NAN;
        v27.origin = (CGPoint)v20;
        v27.size = v20;
        v29.origin.x = TFont::GetBoundingBoxesForGlyphs(v13, (const unsigned __int16 *)v28, &v27, 1, kCTFontOrientationDefault);
        double v21 = CGRectGetMaxX(v29) - v18;
        CFIndex v22 = (double *)(v8 ? v17 : v16);
        double v23 = v21 - *v22;
        if (v19 < v23) {
          double v19 = v23;
        }
        double v18 = v18 + *v22;
        v16 -= 16;
        v17 -= 8;
      }
      while (a2-- > 0);
    }
  }
  else
  {
    v27.origin.x = NAN;
    v28[0] = -86;
    TAttributes::GetKernSetting((TRun *)((char *)this + 40), &v27.origin.x, v28);
  }
  return 0;
}

char *std::vector<CTRun *,TInlineBufferAllocator<CTRun *,3ul>>::insert(uint64_t a1, char *__src, void *a3)
{
  uint64_t v4 = __src;
  uint64_t v6 = *(char **)(a1 + 8);
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    uint64_t v12 = *(char **)a1;
    CGRect v29 = 0;
    unint64_t v13 = ((v6 - v12) >> 3) + 1;
    if (v13 >> 61) {
      abort();
    }
    uint64_t v14 = __src - v12;
    uint64_t v15 = (__src - v12) >> 3;
    uint64_t v16 = v7 - (void)v12;
    if (v16 >> 2 > v13) {
      unint64_t v13 = v16 >> 2;
    }
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v17 = v13;
    }
    uint64_t v31 = a1 + 24;
    if (v17) {
      double v18 = (char *)TInlineBufferAllocator<CTRun *,3ul>::allocate(a1 + 24, v17);
    }
    else {
      double v18 = 0;
    }
    double v19 = &v18[8 * v15];
    CGRect v27 = v18;
    uint64_t v28 = v19;
    CGSize v20 = &v18[8 * v17];
    CGRect v30 = v20;
    if (v15 == v17)
    {
      if (v14 < 1)
      {
        if (v12 == v4) {
          unint64_t v22 = 1;
        }
        else {
          unint64_t v22 = v14 >> 2;
        }
        uint64_t v36 = a1 + 24;
        double v23 = (char *)TInlineBufferAllocator<CTRun *,3ul>::allocate(a1 + 24, v22);
        CFIndex v24 = &v23[8 * (v22 >> 2)];
        CGRect v27 = v23;
        uint64_t v28 = v24;
        uint64_t v32 = v18;
        int v33 = &v18[8 * v15];
        CGRect v30 = &v23[8 * v22];
        CFRange v34 = v33;
        uint64_t v35 = v20;
        std::__split_buffer<CTRun *,TInlineBufferAllocator<CTRun *,3ul> &>::~__split_buffer((uint64_t)&v32);
        double v19 = v24;
      }
      else
      {
        unint64_t v21 = v15 + 2;
        if (v15 >= -1) {
          unint64_t v21 = v15 + 1;
        }
        v19 -= 8 * (v21 >> 1);
        uint64_t v28 = v19;
      }
    }
    *(void *)double v19 = *a3;
    CGRect v29 = v19 + 8;
    uint64_t v4 = std::vector<long,TInlineBufferAllocator<long,30ul>>::__swap_out_circular_buffer((void **)a1, (uint64_t)&v27, v4);
    std::__split_buffer<CTRun *,TInlineBufferAllocator<CTRun *,3ul> &>::~__split_buffer((uint64_t)&v27);
  }
  else if (__src == v6)
  {
    *(void *)__src = *a3;
    *(void *)(a1 + 8) = __src + 8;
  }
  else
  {
    int v8 = __src + 8;
    uint64_t v9 = v6 - 8;
    uint64_t v10 = *(void **)(a1 + 8);
    while (v9 < v6)
    {
      uint64_t v11 = *(void *)v9;
      v9 += 8;
      *v10++ = v11;
    }
    *(void *)(a1 + 8) = v10;
    if (v6 != v8) {
      memmove(&v6[-8 * ((v6 - v8) >> 3)], __src, v6 - v8);
    }
    *(void *)uint64_t v4 = *a3;
  }
  return v4;
}

void TLine::AppendRun(int64x2_t *this, atomic_ullong *a2)
{
  unint64_t v3 = atomic_exchange(a2, 0);
  int v5 = (unint64_t *)this[1].i64[1];
  unint64_t v4 = this[2].u64[0];
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = this[1].i64[0];
    uint64_t v8 = ((uint64_t)v5 - v7) >> 3;
    if ((unint64_t)(v8 + 1) >> 61) {
      abort();
    }
    uint64_t v9 = &this[2].i8[8];
    uint64_t v10 = v4 - v7;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v8 + 1)) {
      uint64_t v11 = v8 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    CFIndex v24 = &this[2].i8[8];
    if (v12) {
      unint64_t v13 = (char *)TInlineBufferAllocator<CTRun *,3ul>::allocate((uint64_t)v9, v12);
    }
    else {
      unint64_t v13 = 0;
    }
    uint64_t v14 = (unint64_t *)&v13[8 * v8];
    uint64_t v15 = &v13[8 * v12];
    double v23 = v15;
    *uint64_t v14 = v3;
    uint64_t v6 = v14 + 1;
    v22.i64[1] = (uint64_t)(v14 + 1);
    uint64_t v17 = this[1].i64[0];
    unint64_t v16 = this[1].u64[1];
    if (v16 == v17)
    {
      int64x2_t v19 = vdupq_n_s64(v16);
    }
    else
    {
      do
      {
        unint64_t v18 = *(void *)(v16 - 8);
        v16 -= 8;
        *--uint64_t v14 = v18;
      }
      while (v16 != v17);
      int64x2_t v19 = this[1];
      uint64_t v6 = (void *)v22.i64[1];
      uint64_t v15 = v23;
    }
    this[1].i64[0] = (uint64_t)v14;
    this[1].i64[1] = (uint64_t)v6;
    int64x2_t v22 = v19;
    uint64_t v20 = this[2].i64[0];
    this[2].i64[0] = (uint64_t)v15;
    double v23 = (char *)v20;
    uint64_t v21 = v19.i64[0];
    std::__split_buffer<CTRun *,TInlineBufferAllocator<CTRun *,3ul> &>::~__split_buffer((uint64_t)&v21);
  }
  else
  {
    *int v5 = v3;
    uint64_t v6 = v5 + 1;
  }
  this[1].i64[1] = (uint64_t)v6;
  TLine::UpdateCachedMetricsForRun((TLine *)this, *(const TRun **)(v3 + 40));
}

void *TInlineBufferAllocator<CTRun *,3ul>::allocate(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 24);
  uint64_t v2 = (unint64_t *)(a1 + 24);
  uint64_t v3 = v4;
  unint64_t v5 = v4 + 8 * a2;
  if (v5 <= (unint64_t)v2)
  {
    *uint64_t v2 = v5;
    return (void *)v3;
  }
  else
  {
    if (a2 >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    return operator new(8 * a2);
  }
}

uint64_t std::__split_buffer<CTRun *,TInlineBufferAllocator<CTRun *,3ul> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3) {
    *(void *)(a1 + 16) = v2 + ((v3 - v2 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  uint64_t v4 = *(void **)a1;
  if (*(void *)a1)
  {
    unint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = (void *)(v5 + 24);
    if (v5 <= (unint64_t)v4 && v6 > v4)
    {
      if (*(void *)(a1 + 24) == *v6) {
        *uint64_t v6 = v4;
      }
    }
    else
    {
      operator delete(v4);
    }
  }
  return a1;
}

void TAttributes::TAttributes(TAttributes *this, const __CFDictionary *a2, const TCharStream *a3, CFRange a4, int a5)
{
  *((_OWORD *)this + 1) = 0u;
  uint64_t v7 = (atomic_ullong *)((char *)this + 16);
  *((unsigned char *)this + 56) = 0;
  *((unsigned char *)this + 104) = 0;
  *((unsigned char *)this + 112) = 0;
  *((void *)this + 18) = 0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_DWORD *)this + 12) = 0;
  *((void *)this + 15) = 0;
  *((void *)this + 16) = 0;
  *((_DWORD *)this + 34) = 0;
  if (a2)
  {
    CFTypeRef cf = 0;
    TAttributes::ApplyFont(this, a2, 0, a3, a4, &cf);
    if (cf)
    {
      uint64_t v9 = (TParagraphStyle *)operator new(0x10uLL, MEMORY[0x1E4FBA2D0]);
      if (v9)
      {
        *(void *)uint64_t v9 = 0;
        *((unsigned char *)v9 + 8) = 0;
      }
      uint64_t v10 = *((void *)this + 16);
      *((void *)this + 16) = v9;
      if (v10)
      {
        MEMORY[0x1853275C0](v10, 0x10C0C40E6EFC850);
        uint64_t v9 = (TParagraphStyle *)*((void *)this + 16);
      }
      if (v9)
      {
        int v11 = TParagraphStyle::SetStyle(v9, cf);
        unint64_t v12 = (TParagraphStyle **)*((void *)this + 16);
        if (v11)
        {
          if ((unint64_t)TParagraphStyle::GetLineBoundsOptions(v12, v8) >= 4) {
            *((_WORD *)this + 69) |= 0x100u;
          }
        }
        else
        {
          *((void *)this + 16) = 0;
          if (v12) {
            MEMORY[0x1853275C0](v12, 0x10C0C40E6EFC850);
          }
        }
      }
      else
      {
        *((void *)this + 16) = 0;
      }
    }
  }
  else
  {
    if (qword_1EB2CE310 != -1) {
      dispatch_once_f(&qword_1EB2CE310, 0, (dispatch_function_t)TAttributes::GetDefaultAttributes(void)::{lambda(void *)#1}::__invoke);
    }
    TCFRef<__CTFont const*>::Retain((atomic_ullong *)this, (id)_MergedGlobals_18);
    if (qword_1EB2CE318 != -1) {
      dispatch_once_f(&qword_1EB2CE318, 0, (dispatch_function_t)TAttributes::GetDefaultFont(void)::{lambda(void *)#1}::__invoke);
    }
    TCFRef<__CTFont const*>::Retain(v7, (id)qword_1EB2CE2E8);
  }
  unsigned int CompositionLanguage = TAttributes::GetCompositionLanguage(this, v8);
  *((unsigned char *)this + 112) = CompositionLanguage;
  if (a5)
  {
    TAttributes::SetRareAttributes(this, 32);
    unsigned int CompositionLanguage = *((unsigned __int8 *)this + 112);
  }
  if (CompositionLanguage >= 2 && CJKCompositionEngine::IsEnabled(CompositionLanguage, (uint64_t)this)) {
    *((_WORD *)this + 69) |= 0x100u;
  }
  else {
    *((unsigned char *)this + 112) = 1;
  }
}

uint64_t TLine::GetLeftHangersGlyphCountAndWidth(TLine *this, const unint64_t *a2)
{
  uint64_t v2 = *((void *)this + 3) - *((void *)this + 2);
  if (v2 >= 1)
  {
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    uint64_t v7 = (unint64_t)v2 >> 3;
    int v8 = (*((unsigned __int16 *)this + 76) >> 3) & 1;
    if (v7 <= 1) {
      uint64_t v9 = 1;
    }
    else {
      uint64_t v9 = v7;
    }
    double v10 = 0.0;
    while (1)
    {
      int v11 = *(atomic_ullong **)(*(void *)(*((void *)this + 2) + 8 * v5) + 40);
      CFIndex v12 = v11[26];
      if ((v8 & 1) == 0) {
        break;
      }
      uint64_t v13 = (*(uint64_t (**)(atomic_ullong *))(*v11 + 80))(v11);
      v6 += v13;
      double v10 = v10 + *(double *)&a2;
      if (v13 < v12)
      {
        uint64_t v14 = v13;
        if (*(double *)&a2 == 0.0)
        {
LABEL_9:
          uint64_t v15 = (TParagraphStyle **)v11[21];
          if (v15) {
            LOBYTE(v16) = TParagraphStyle::GetLineBoundsOptions(v15, a2);
          }
          else {
            LOBYTE(v16) = 0;
          }
          goto LABEL_13;
        }
LABEL_12:
        uint64_t v16 = *a2;
LABEL_13:
        CFIndex LeftHangersGlyphCountAndWidth = TRun::GetLeftHangersGlyphCountAndWidth(v11, v14, v16, *(const TCharStream **)this, 1);
        v6 += LeftHangersGlyphCountAndWidth;
        double v10 = v10 + *(double *)&a2;
        if (LeftHangersGlyphCountAndWidth < v12) {
          return v6;
        }
        LOBYTE(v8) = 0;
        goto LABEL_16;
      }
      LOBYTE(v8) = 1;
LABEL_16:
      if (v9 == ++v5) {
        return v6;
      }
    }
    uint64_t v14 = 0;
    if (*(double *)&a2 == 0.0) {
      goto LABEL_9;
    }
    goto LABEL_12;
  }
  return 0;
}

id TParagraphStyle::GetLineBoundsOptions(TParagraphStyle **this, const void *a2)
{
  int v3 = *((unsigned __int8 *)this + 8);
  uint64_t v4 = *this;
  if (v3) {
    return (id)TParagraphStyle::GetNative(v4, a2)[5];
  }
  if ((objc_opt_respondsToSelector() & 1) == 0) {
    return 0;
  }
  uint64_t v6 = *this;

  return [(TParagraphStyle *)v6 _lineBoundsOptions];
}

CFIndex TRun::GetLeftHangersGlyphCountAndWidth(atomic_ullong *this, uint64_t a2, char a3, const TCharStream *a4, int a5)
{
  char v7 = a3;
  CFIndex v8 = a2;
  uint64_t v9 = (TRun *)this;
  double v10 = (void *)this[27];
  uint64_t v11 = v10[4];
  if (v11 || (uint64_t v35 = v10[3]) == 0)
  {
    int v47 = 0;
    atomic_ullong v12 = this[25];
    uint64_t v13 = v11 + 16 * v12;
    if (a2 < 0)
    {
LABEL_21:
      TAttributes::GetCompositionLanguage((TAttributes *)(this + 5), (const void *)a2);
      CFIndex v22 = v8;
      goto LABEL_37;
    }
  }
  else
  {
    atomic_ullong v12 = this[25];
    uint64_t v13 = v35 + 8 * v12;
    int v47 = 1;
    if (a2 < 0) {
      goto LABEL_21;
    }
  }
  CFIndex v14 = this[26];
  if ((a3 & 4) != 0 && v14 > a2)
  {
    uint64_t v15 = v10[2] + 2 * v12;
    uint64_t v64 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v16 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)long long v62 = v16;
    long long v63 = v16;
    TAATPropTable::TAATPropTable((TAATPropTable *)v62, (const __CTFont *)atomic_load_explicit(this + 7, memory_order_acquire));
    long long v49 = a4;
    long long v60 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    long long v58 = 0u;
    long long v59 = 0u;
    uint64_t v17 = *((void *)a4 + 2);
    uint64_t v61 = 0;
    *(void *)&long long v60 = v17;
    int v41 = a4;
    CFIndex v18 = v14;
    if (qword_1EB2CDEA8 != -1) {
      dispatch_once_f(&qword_1EB2CDEA8, 0, (dispatch_function_t)GetLeftHangingCharacters(void)::$_0::__invoke);
    }
    uint64_t v43 = v9;
    int v44 = a5;
    uint64_t v19 = *(void *)(*((void *)v9 + 27) + 48) + 8 * *((void *)v9 + 25);
    uint64_t v20 = a5;
    CFIndex v21 = v13 + 16 * v8;
    CFIndex v22 = v8;
    uint64_t v23 = 16 * a5;
    CFIndex v24 = v13 + 8 * v22;
    uint64_t v25 = 8 * a5;
    double v26 = 0.0;
    CFIndex v45 = v22;
    CFCharacterSetRef theSet = (const __CFCharacterSet *)_MergedGlobals_5;
    do
    {
      uint64_t v48 = *(void *)(v19 + 8 * v22);
      CGRect v27 = (uint64_t (*)(void *, void))*((void *)&v63 + 1);
      uint64_t v28 = (uint64_t *)((char *)v62 + (v64 >> 1));
      if (v64) {
        CGRect v27 = *(uint64_t (**)(void *, void))(*v28 + DWORD2(v63));
      }
      if ((v27(v28, *(unsigned __int16 *)(v15 + 2 * v22)) & 0x4000) == 0)
      {
        Fullunsigned int Char = TCharStreamIterator::GetFullChar((TCharStreamIterator *)&v49, &v48, 0);
        if (!CFCharacterSetIsLongCharacterMember(theSet, FullChar)) {
          break;
        }
      }
      CGRect v30 = (double *)(v47 ? v24 : v21);
      double v26 = v26 + *v30;
      v22 += v20;
      if (v22 < 0) {
        break;
      }
      v21 += v23;
      v24 += v25;
    }
    while (v18 > v22);

    uint64_t v9 = v43;
    uint64_t CompositionLanguage = TAttributes::GetCompositionLanguage((TRun *)((char *)v43 + 40), v31);
    if (v22 < 0)
    {
      a5 = v44;
      CFIndex v8 = v45;
LABEL_37:
      if ((a5 & 0x80000000) == 0) {
        return v22 - v8;
      }
      return v8 - v22;
    }
    uint64_t v34 = CompositionLanguage;
    a5 = v44;
    CFIndex v8 = v45;
    char v7 = a3;
    CFIndex v14 = v18;
    a4 = v41;
  }
  else
  {
    uint64_t v34 = TAttributes::GetCompositionLanguage((TAttributes *)(this + 5), (const void *)a2);
    CFIndex v22 = v8;
  }
  if (v14 > v22 && v34 >= 2)
  {
    long long v49 = a4;
    long long v60 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    long long v58 = 0u;
    long long v59 = 0u;
    uint64_t v36 = *((void *)a4 + 2);
    uint64_t v61 = 0;
    *(void *)&long long v60 = v36;
    v62[0] = *(void *)(*(void *)(*((void *)v9 + 27) + 48) + 8 * *((void *)v9 + 25) + 8 * v22);
    char v37 = (CJKCompositionEngine *)TCharStreamIterator::GetFullChar((TCharStreamIterator *)&v49, v62, 0);
    UChar32 v38 = (int)v37;
    if (CJKCompositionEngine::IsEnabled(v37))
    {
      uint64_t v39 = *((void *)v9 + 20);
      if (!v39 || (*(_WORD *)(v39 + 66) & 0x20) == 0)
      {
        LOBYTE(v48) = -86;
        if (CJKCompositionRules::ShouldGlyphImageLeftFlush(v34, *((unsigned __int8 *)v9 + 90), v38, (BOOL *)&v48))
        {
          v33.CFIndex location = v22;
          GetOpticalBoundsAdjustment(0, (atomic_ullong *)v9, v33);
          if (!(_BYTE)v48) {
            atomic_load_explicit((atomic_ullong *volatile)v9 + 7, memory_order_acquire);
          }
        }
      }
    }
    else if ((v34 - 3) <= 1u)
    {
      ChineseCompositionRules::GetCharacterClass(v38, 0, v34);
    }
  }
  if ((a5 & 0x80000000) == 0)
  {
    if (v14 > v22) {
      return v22 - v8 + TRun::GetLeftPartialHangingGlyphCountAndWidth(v9, v22, v7, (const TCharStream *)v33.length);
    }
    return v22 - v8;
  }
  return v8 - v22;
}

void TLine::UpdateCachedMetricsForRun(TLine *this, const TRun *a2)
{
  *((void *)this + 18) += *((void *)a2 + 26);
  uint64_t v4 = *((void *)a2 + 39);
  uint64_t v5 = (double *)MEMORY[0x1E4F1DB30];
  if (v4) {
    uint64_t v5 = (double *)*((void *)a2 + 39);
  }
  *((double *)this + 13) = *((double *)this + 13) + *((double *)a2 + 24) + *v5;
  char v6 = *((unsigned char *)a2 + 225);
  if (v6)
  {
    *((_WORD *)this + 76) |= 2u;
    char v6 = *((unsigned char *)a2 + 225);
  }
  if ((v6 & 8) != 0) {
    *((_WORD *)this + 77) |= 8u;
  }
  if (*((unsigned char *)a2 + 224)) {
    *((_WORD *)this + 76) |= 1u;
  }
  if (*((_DWORD *)a2 + 64) == 3) {
    *((_WORD *)this + 76) |= 4u;
  }
  if (*((unsigned __int8 *)a2 + 90) | *((unsigned __int8 *)a2 + 144)
    || v4 && *(void *)(v4 + 56) != *(void *)(v4 + 64))
  {
    *((_WORD *)this + 77) |= 2u;
  }
  __int16 v7 = *((_WORD *)a2 + 89);
  if ((v7 & 0x9842) != 0) {
    *((_WORD *)this + 76) |= 0x10u;
  }
  if ((v7 & 0x800) != 0) {
    *((_WORD *)this + 76) |= 0x20u;
  }
  CFIndex v8 = (atomic_ullong *)((char *)a2 + 40);
  if ((v7 & 0x100) != 0) {
    *((_WORD *)this + 77) |= 4u;
  }
  if (TAttributes::GetCompositionLanguage((const TRun *)((char *)a2 + 40), a2) >= 2) {
    *((_WORD *)this + 77) |= 0x200u;
  }
  uint64_t v10 = *((void *)a2 + 23);
  if (v10 && *(unsigned char *)(v10 + 264)
    || (uint64_t v11 = *(void *)(*(void *)(atomic_load_explicit((atomic_ullong *volatile)a2 + 7, memory_order_acquire) + 40)
                        + 400),
        (*(unsigned int (**)(uint64_t))(*(void *)v11 + 384))(v11)))
  {
    *((_WORD *)this + 77) |= 0x10u;
  }
  if (*((unsigned char *)a2 + 177)) {
    BackgroundColor = (void *)TAttributes::GetBackgroundColor((TAttributes *)atomic_load_explicit(v8, memory_order_acquire), 0, v9);
  }
  else {
    BackgroundColor = 0;
  }
  uint64_t v13 = (atomic_ullong *)((char *)this + 168);
  if (atomic_load_explicit((atomic_ullong *volatile)this + 21, memory_order_acquire))
  {
    CFStringRef explicit = (const void *)atomic_load_explicit(v13, memory_order_acquire);
    if (BackgroundColor != explicit && (!BackgroundColor || !explicit || !CFEqual(explicit, BackgroundColor))) {
  }
    }
  else if (*((void *)this + 3) - *((void *)this + 2) == 8)
  {
    TCFRef<__CTFont const*>::Retain((atomic_ullong *)this + 21, BackgroundColor);
  }
  uint64_t v15 = *((void *)a2 + 20);
  if (v15) {
    double v16 = *(double *)(v15 + 48);
  }
  else {
    double v16 = 0.0;
  }
  double v17 = v16 + (*(double (**)(const TRun *))(*(void *)a2 + 56))(a2);
  if (v17 > *((double *)this + 14)) {
    *((double *)this + 14) = v17;
  }
  double v18 = (*(double (**)(const TRun *))(*(void *)a2 + 64))(a2) - v16;
  if (v18 > *((double *)this + 15)) {
    *((double *)this + 15) = v18;
  }
  double v19 = (*(double (**)(const TRun *))(*(void *)a2 + 72))(a2);
  if (v19 > *((double *)this + 16)) {
    *((double *)this + 16) = v19;
  }
}

uint64_t TAttributes::GetCompositionLanguage(TAttributes *this, const void *a2)
{
  uint64_t result = *((unsigned __int8 *)this + 112);
  if (!result)
  {
    uint64_t v4 = (TParagraphStyle **)*((void *)this + 16);
    if (!v4 || (uint64_t result = (uint64_t)TParagraphStyle::GetCompositionLanguage(v4, a2), !result))
    {
      if ((*((_WORD *)this + 69) & 0x200) != 0) {
        return CTParagraphStyleGetCompositionLanguageForLanguage((__CFString *)atomic_load_explicit((atomic_ullong *volatile)this + 3, memory_order_acquire));
      }
      else {
        return 0;
      }
    }
  }
  return result;
}

uint64_t TBaseFont::HasScriptSpecificMetrics(TBaseFont *this)
{
  if ((*((_DWORD *)this + 46) & 0x2000000) != 0) {
    return (*((_DWORD *)this + 45) >> 25) & 1;
  }
  id v11 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr, TBaseFont *, uint64_t))(*(void *)this + 480))(&v11, this, 1111577413);
  *(void *)&long long v2 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
  void v10[2] = v2;
  v10[3] = v2;
  v10[0] = v2;
  v10[1] = v2;
  CFDataRef explicit = (const __CFData *)atomic_load_explicit((atomic_ullong *volatile)&v11, memory_order_acquire);
  if (!explicit)
  {
    BytePtr = 0;
    goto LABEL_7;
  }
  BytePtr = CFDataGetBytePtr(explicit);
  uint64_t v5 = CFDataGetBytePtr(explicit);
  if (!v5)
  {
LABEL_7:
    unint64_t v6 = 0;
    goto LABEL_8;
  }
  unint64_t v6 = (unint64_t)&v5[CFDataGetLength(explicit)];
LABEL_8:
  OTL::BASE::BASE((uint64_t)v10, (uint64_t)BytePtr, v6);
  uint64_t HasScriptSpecificMetrics = OTL::BASE::HasScriptSpecificMetrics((OTL::BASE *)v10);
  if (HasScriptSpecificMetrics) {
    unsigned int v8 = 0x2000000;
  }
  else {
    unsigned int v8 = 0;
  }
  atomic_fetch_or_explicit((atomic_uint *volatile)this + 45, v8, memory_order_relaxed);
  atomic_fetch_or_explicit((atomic_uint *volatile)this + 46, 0x2000000u, memory_order_relaxed);

  return HasScriptSpecificMetrics;
}

double TRun::GetAscent(TRun *this)
{
  uint64_t v1 = *((void *)this + 39);
  if (!v1 || (double result = *(double *)(v1 + 32), result <= 0.0))
  {
    int v3 = *(int **)(atomic_load_explicit((atomic_ullong *volatile)this + 7, memory_order_acquire) + 40);
    if (v3[12]) {
      inited = v3 + 12;
    }
    else {
      inited = TFont::InitStrikeMetrics((TFont *)v3);
    }
    return *((double *)inited + 1);
  }
  return result;
}

double TRun::GetLeading(TRun *this)
{
  uint64_t v1 = *((void *)this + 39);
  if (!v1 || (double result = *(double *)(v1 + 48), result <= 0.0))
  {
    int v3 = *(int **)(atomic_load_explicit((atomic_ullong *volatile)this + 7, memory_order_acquire) + 40);
    if (v3[12]) {
      inited = v3 + 12;
    }
    else {
      inited = TFont::InitStrikeMetrics((TFont *)v3);
    }
    return *((double *)inited + 3);
  }
  return result;
}

double TRun::GetDescent(TRun *this)
{
  uint64_t v1 = *((void *)this + 39);
  if (!v1 || (double result = *(double *)(v1 + 40), result <= 0.0))
  {
    int v3 = *(int **)(atomic_load_explicit((atomic_ullong *volatile)this + 7, memory_order_acquire) + 40);
    if (v3[12]) {
      inited = v3 + 12;
    }
    else {
      inited = TFont::InitStrikeMetrics((TFont *)v3);
    }
    return *((double *)inited + 2);
  }
  return result;
}

uint64_t TRun::GetLeftPartialHangingGlyphCountAndWidth(TRun *this, uint64_t a2, char a3, const TCharStream *a4)
{
  unint64_t v6 = (void *)*((void *)this + 27);
  uint64_t v7 = v6[4];
  if (v7 || (uint64_t v11 = v6[3]) == 0)
  {
    int v8 = 0;
    uint64_t v9 = *((void *)this + 25);
    uint64_t v10 = v7 + 16 * v9;
  }
  else
  {
    uint64_t v9 = *((void *)this + 25);
    uint64_t v10 = v11 + 8 * v9;
    int v8 = 1;
  }
  if ((a3 & 0x18) != 0)
  {
    uint64_t v12 = *((void *)this + 26);
    uint64_t v13 = v6[2] + 2 * v9;
    CFIndex v14 = *(TFont **)(atomic_load_explicit((atomic_ullong *volatile)this + 7, memory_order_acquire) + 40);
    v28.origin.x = TFont::GetBoundingBox(v14);
    double MinX = CGRectGetMinX(v28);
    if ((a3 & 0x10) != 0)
    {
      unsigned __int16 v27 = *(_WORD *)(v13 + 2 * a2);
      v24.CGFloat width = NAN;
      v24.CGFloat height = NAN;
      v26.origin = (CGPoint)v24;
      v26.size = v24;
      v30.origin.x = TFont::GetOpticalBoundsForGlyphs(v14, &v27, &v26, 1);
      CGRectGetMinX(v30);
    }
    else
    {
      double v16 = -MinX;
      uint64_t v17 = v10 + 16 * a2;
      uint64_t v18 = v10 + 8 * a2;
      double v19 = 0.0;
      double v20 = 1.79769313e308;
      do
      {
        if (v19 > v16) {
          break;
        }
        unsigned __int16 v27 = *(_WORD *)(v13 + 2 * a2);
        v21.CGFloat width = NAN;
        v21.CGFloat height = NAN;
        v26.origin = (CGPoint)v21;
        v26.size = v21;
        v29.origin.x = TFont::GetBoundingBoxesForGlyphs(v14, &v27, &v26, 1, kCTFontOrientationDefault);
        double v22 = v19 + CGRectGetMinX(v29);
        if (v22 < v20) {
          double v20 = v22;
        }
        uint64_t v23 = (double *)(v8 ? v18 : v17);
        double v19 = v19 + *v23;
        ++a2;
        v17 += 16;
        v18 += 8;
      }
      while (a2 < v12);
    }
  }
  return 0;
}

void TAttributes::ApplyFont(TAttributes *this, const __CFDictionary *a2, const __CTFont *a3, const TCharStream *a4, CFRange a5, const void **a6)
{
  CFIndex length = a5.length;
  CFIndex location = a5.location;
  uint64_t v83 = *MEMORY[0x1E4F143B8];
  memset(v78, 170, sizeof(v78));
  __p = 0;
  unint64_t v76 = 0;
  uint64_t v77 = 0;
  uint64_t v79 = v78;
  int v13 = *((unsigned __int8 *)this + 50);
  context.b = -3.72066208e-103;
  *(void *)&context.double a = this;
  *(void *)&context.c = a4;
  *(void *)&context.d = location;
  *(void *)&context.tx = length;
  *(void *)&context.ty = a6;
  p_p = &__p;
  unint64_t v82 = 0xAAAAAAAAAAAA0000;
  CFIndex v14 = (void (__cdecl *)(const void *, const void *, void *))TAttributes::ApplyAttributeHandlers;
  int v69 = v13;
  if (a3)
  {
    if (!*((unsigned char *)this + 51))
    {
      int v16 = 0;
      unsigned __int8 v15 = 0;
LABEL_17:
      double v22 = *(TFont **)(atomic_load_explicit((atomic_ullong *volatile)this + 2, memory_order_acquire) + 40);
      *(void *)&long long v23 = -1;
      *((void *)&v23 + 1) = -1;
      *(_OWORD *)&context.c = v23;
      *(_OWORD *)&context.tx = v23;
      *(_OWORD *)&context.double a = v23;
      TFont::GetEffectiveMatrix(v22, (uint64_t)&context);
      float64x2_t v24 = (float64x2_t)vdupq_n_s64(0x3CB0000000000000uLL);
      int64x2_t v25 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f64(v24, (float64x2_t)vandq_s8(*(int8x16_t *)&context.tx, (int8x16_t)vdupq_n_s64(0x7FFFFFFFFFFFFFFFuLL))), (int8x16_t)vcgeq_f64(v24, vabsq_f64(vaddq_f64(*(float64x2_t *)&context.a, (float64x2_t)xmmword_184B88D30)))), (int8x16_t)vcgeq_f64(v24, vabsq_f64(vaddq_f64(*(float64x2_t *)&context.c, (float64x2_t)xmmword_184B88D40))));
      if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v25, 1), (int8x16_t)v25).u64[0] & 0x8000000000000000) == 0)
      {
        int v69 = 0;
        long long v26 = *(_OWORD *)&context.c;
        *(_OWORD *)((char *)this + 56) = *(_OWORD *)&context.a;
        *(_OWORD *)((char *)this + 72) = v26;
        *(_OWORD *)((char *)this + 88) = *(_OWORD *)&context.tx;
        *((unsigned char *)this + 104) = 1;
      }
      if ((*((_WORD *)this + 69) & 0x2000) != 0)
      {
        context.double a = -3.72066208e-103;
        TAttributes::OriginalFont((atomic_ullong *)this, (atomic_ullong *)&context);
        uint64_t v27 = *(void *)(atomic_load_explicit((atomic_ullong *volatile)&context, memory_order_acquire) + 40);
        if ((*(uint64_t (**)(void))(**(void **)(v27 + 400) + 776))()
          || TFont::GetSecondaryScaleData((atomic_ullong *)v27))
        {
          uint64_t v28 = TAttributes::EnsureRareData(this);
          CGFloat v29 = *(double *)(v27 + 16);
          CGRect v30 = (const __CTFont *)(id)atomic_load_explicit((atomic_ullong *volatile)this + 2, memory_order_acquire);
          uint64_t v31 = (atomic_ullong ***)v30;
          uint64_t v32 = (atomic_ullong *)(v28 + 96);
          unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(v28 + 96), memory_order_acquire);
          if (explicit)
          {
            *(void *)&v71.double a = CTFontCreateCopyWithAttributes(v30, v29, 0, 0);

            uint64_t v34 = (TBaselineAttributes *)TAttributes::EnsureBaselineAttributes(this);
            TBaselineAttributes::SetReferenceFont(v34, (void *)atomic_load_explicit(v32, memory_order_acquire));
          }
          else
          {
            TCFRef<__CTFont const*>::Retain((atomic_ullong *)(v28 + 96), v30);
          }
          CFNumberRef v35 = CustomRatioFromAttributes((const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)this, memory_order_acquire));
          unsigned __int8 v37 = v36;
          int matched = TextScaleWeightMatchVariableOnly((const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)this, memory_order_acquire));
          v71.double a = -3.72066208e-103;
          CopySecondaryScaleRecipeInternal((atomic_ullong *)&v71, v31, (atomic_ullong **)atomic_load_explicit((atomic_ullong *volatile)&context, memory_order_acquire), (uint64_t)v35, v37, matched);
          unint64_t v39 = atomic_load_explicit((atomic_ullong *volatile)&v71, memory_order_acquire);
          BOOL v21 = v39 != 0;
          if (v39)
          {
            valuePtr.double a = 0.0;
            CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v71, memory_order_acquire), @"CTBaselineOffset");
            if (Value)
            {
              CFNumberRef v41 = Value;
              CFTypeID v42 = CFGetTypeID(Value);
              if (v42 == CFNumberGetTypeID() || v42 == CFBooleanGetTypeID())
              {
                CFNumberGetValue(v41, kCFNumberDoubleType, &valuePtr);
              }
              else if (v42 == CFStringGetTypeID())
              {
                valuePtr.double a = CFStringGetDoubleValue((CFStringRef)v41);
              }
            }
            if (!*((unsigned char *)this + 50))
            {
              double a = valuePtr.a;
              uint64_t v44 = *((void *)this + 15);
              double OriginalValueOf = 0.0;
              if (v44)
              {
                CFStringRef v46 = *(const __CFString **)(v44 + 40);
                if (v46) {
                  double OriginalValueOf = TAttributes::GetOriginalValueOf((atomic_ullong *)this, v46);
                }
              }
              *(double *)(v28 + 48) = a + OriginalValueOf;
            }
            DoubleCFNumberRef Value = 0.0;
            CFNumberRef v47 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v71, memory_order_acquire), @"CTTracking");
            if (v47)
            {
              CFNumberRef v48 = v47;
              CFTypeID v49 = CFGetTypeID(v47);
              if (v49 == CFNumberGetTypeID() || v49 == CFBooleanGetTypeID())
              {
                CFNumberGetValue(v48, kCFNumberDoubleType, &DoubleValue);
              }
              else if (v49 == CFStringGetTypeID())
              {
                DoubleCFNumberRef Value = CFStringGetDoubleValue((CFStringRef)v48);
              }
            }
            if ((*((_WORD *)this + 69) & 0x1000) == 0)
            {
              double v50 = DoubleValue;
              *(double *)(v28 + 16) = v50 + TAttributes::GetOriginalValueOf((atomic_ullong *)this, @"CTTracking");
              *(unsigned char *)(v28 + 24) = 1;
            }
            id v72 = (id)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v71, memory_order_acquire), @"NSFont");
            id v73 = (id)atomic_exchange((atomic_ullong *volatile)&v72, 0);
            if (atomic_load_explicit((atomic_ullong *volatile)&v73, memory_order_acquire))
            {

              *((unsigned char *)this + 48) = 1;
            }
          }
          else if (explicit)
          {
            if (!*((unsigned char *)this + 50))
            {
              uint64_t v66 = *((void *)this + 15);
              double v67 = 0.0;
              if (v66)
              {
                CFStringRef v68 = *(const __CFString **)(v66 + 40);
                if (v68) {
                  double v67 = TAttributes::GetOriginalValueOf((atomic_ullong *)this, v68) + 0.0;
                }
              }
              *(double *)(v28 + 48) = v67;
            }
            if ((*((_WORD *)this + 69) & 0x1000) == 0)
            {
              *(double *)(v28 + 16) = TAttributes::GetOriginalValueOf((atomic_ullong *)this, @"CTTracking") + 0.0;
              *(unsigned char *)(v28 + 24) = 1;
            }
          }
        }
        else
        {
          BOOL v21 = 0;
        }
      }
      else
      {
        BOOL v21 = 0;
      }
      int v20 = 1;
      goto LABEL_48;
    }
    LOBYTE(context.b) = 1;
    CFIndex v14 = (void (__cdecl *)(const void *, const void *, void *))TAttributes::ApplyFontAttributeHandlers;
  }
  CFDictionaryApplyFunction(a2, v14, &context);
  unsigned __int8 v15 = v82;
  int v16 = BYTE1(v82);
  BOOL v18 = (unsigned __int16)v82 > 0xFFu || __p != v76;
  *((unsigned char *)this + 51) = v18;
  if (LOBYTE(context.b))
  {
    if (!a3) {
      TCFRef<__CTFont const*>::Retain((atomic_ullong *)this, a2);
    }
    goto LABEL_17;
  }
  MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, a2);
  if (qword_1EB2CE318 != -1) {
    dispatch_once_f(&qword_1EB2CE318, 0, (dispatch_function_t)TAttributes::GetDefaultFont(void)::{lambda(void *)#1}::__invoke);
  }
  TCFRef<__CTFont const*>::Retain((atomic_ullong *)this + 2, (id)qword_1EB2CE2E8);
  CFDictionarySetValue(MutableCopy, @"NSFont", (const void *)atomic_load_explicit((atomic_ullong *volatile)this + 2, memory_order_acquire));

  int v20 = 0;
  BOOL v21 = 0;
LABEL_48:
  long long v51 = (char *)__p;
  long long v52 = v76;
  while (v51 != v52)
  {
    *(void *)&long long v53 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v53 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&context.double a = v53;
    *(_OWORD *)&context.c = v53;
    std::__function::__value_func<void ()(TAttributes &)>::__value_func[abi:nn180100]((uint64_t)&context, (uint64_t)v51);
    if (!*(void *)&context.d) {
      std::__throw_bad_function_call[abi:nn180100]();
    }
    (*(void (**)(void, TAttributes *))(**(void **)&context.d + 48))(*(void *)&context.d, this);
    std::__function::__value_func<void ()(TAttributes &)>::~__value_func[abi:nn180100](&context);
    v51 += 32;
  }
  uint64_t v54 = *((void *)this + 15);
  if (v54 && *(unsigned char *)(v54 + 24) && (*(double *)(v54 + 16) != 0.0 ? (BOOL v55 = v16 == 0) : (BOOL v55 = 0), v55))
  {
    if (v21) {
      goto LABEL_64;
    }
    context.double a = -3.72066208e-103;
    long long v57 = (atomic_ullong *)((char *)this + 16);
    long long v58 = (const __CTFont *)atomic_load_explicit((atomic_ullong *volatile)this + 2, memory_order_acquire);
    int v56 = 0;
  }
  else
  {
    if (!v16) {
      goto LABEL_64;
    }
    int v56 = v15;
    if (v15 == 1) {
      goto LABEL_64;
    }
    context.double a = -3.72066208e-103;
    long long v57 = (atomic_ullong *)((char *)this + 16);
    long long v58 = (const __CTFont *)atomic_load_explicit((atomic_ullong *volatile)this + 2, memory_order_acquire);
  }
  TAttributes::CopyOfFontWithLigatureSetting((CTFontRef *)&context, v58, v56);
  if (atomic_load_explicit((atomic_ullong *volatile)&context, memory_order_acquire))
  {

    *((unsigned char *)this + 48) = 1;
  }

LABEL_64:
  if (*((unsigned char *)this + 50))
  {
    if (!v69)
    {
      long long v59 = (char *)this + 56;
      if (!*((unsigned char *)this + 104)) {
        long long v59 = (char *)MEMORY[0x1E4F1DAB8];
      }
      CGFloat v60 = *(double *)v59;
      *(_OWORD *)&context.b = *(_OWORD *)(v59 + 8);
      context.double a = *((CGFloat *)v59 + 3);
      context.d = v60;
      *(_OWORD *)&context.tx = *((_OWORD *)v59 + 2);
      CGAffineTransform v71 = *(CGAffineTransform *)kRotateLeftTransform;
      CGAffineTransformConcat(&valuePtr, &context, &v71);
      long long v61 = *(_OWORD *)&valuePtr.c;
      *(_OWORD *)((char *)this + 56) = *(_OWORD *)&valuePtr.a;
      *(_OWORD *)((char *)this + 72) = v61;
      *(_OWORD *)((char *)this + 88) = *(_OWORD *)&valuePtr.tx;
      *((unsigned char *)this + 104) = 1;
    }
    VerticalCopyOf((CTFontRef)atomic_load_explicit((atomic_ullong *volatile)this + 2, memory_order_acquire), (CTFontRef *)&context);
    if (atomic_load_explicit((atomic_ullong *volatile)&context, memory_order_acquire))
    {

      *((unsigned char *)this + 48) = 1;
    }
  }
  if (v20) {
    TAttributes::SetLayoutAttributesForFont((atomic_ullong *)this);
  }
  long long v62 = (char *)__p;
  if (__p)
  {
    long long v63 = v76;
    uint64_t v64 = __p;
    if (v76 != __p)
    {
      do
        long long v63 = (char *)std::__function::__value_func<void ()(TAttributes &)>::~__value_func[abi:nn180100]((void *)v63 - 4);
      while (v63 != v62);
      uint64_t v64 = __p;
    }
    unint64_t v76 = v62;
    if (v78 > v64 || &v79 <= (unsigned char **)v64) {
      operator delete(v64);
    }
  }
}

uint64_t (*TAttributes::ApplyAttributeHandlers(TAttributes *this, const void *a2, const void *a3, void *a4))(const void *, const void *)
{
  if (qword_1EB2CE2F8 != -1) {
    dispatch_once_f(&qword_1EB2CE2F8, 0, (dispatch_function_t)TAttributes::ApplyAttributeHandlers(void const*,void const*,void *)::$_0::__invoke);
  }
  double result = (uint64_t (*)(const void *, const void *))CFDictionaryGetValue((CFDictionaryRef)qword_1EB2CE2F0, this);
  if (result)
  {
    return (uint64_t (*)(const void *, const void *))result(a2, a3);
  }
  return result;
}

__n128 TFont::GetEffectiveMatrix@<Q0>(TFont *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = (__n128 *)(*(uint64_t (**)(void))(**((void **)this + 50) + 168))(*((void *)this + 50));
  uint64_t v5 = (__n128 *)*((void *)this + 5);
  if (v5) {
    BOOL v6 = v4 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    __n128 v9 = *v4;
    __n128 v10 = v4[2];
    *(__n128 *)&t1.c = v4[1];
    *(__n128 *)&t1.tx = v10;
    *(__n128 *)&t1.double a = v9;
    __n128 v11 = *v5;
    __n128 v12 = v5[2];
    *(__n128 *)&v16.c = v5[1];
    *(__n128 *)&v16.tx = v12;
    *(__n128 *)&v16.double a = v11;
    CGAffineTransformConcat((CGAffineTransform *)a2, &t1, &v16);
    return result;
  }
  if (v4)
  {
    __n128 result = *v4;
    __n128 v7 = v4[1];
    __n128 v8 = v4[2];
  }
  else
  {
    if (!v5)
    {
      CFIndex v14 = (__n128 *)MEMORY[0x1E4F1DAB8];
      long long v15 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
      *(_OWORD *)a2 = *MEMORY[0x1E4F1DAB8];
      *(_OWORD *)(a2 + 16) = v15;
      __n128 result = v14[2];
      *(__n128 *)(a2 + 32) = result;
      return result;
    }
    __n128 result = *v5;
    __n128 v7 = v5[1];
    __n128 v8 = v5[2];
  }
  *(__n128 *)(a2 + 16) = v7;
  *(__n128 *)(a2 + 32) = v8;
  *(__n128 *)a2 = result;
  return result;
}

unint64_t TComponentFont::GetFontMatrix(TComponentFont *this)
{
  if ((*((unsigned char *)this + 712) & 0x40) == 0) {
    return 0;
  }
  if (!*((void *)this + 91))
  {
    CFArrayRef ComponentAttribute = (const __CFArray *)TComponentFont::GetComponentAttribute((atomic_ullong *)this, @"Matrix");
    if (ComponentAttribute)
    {
      CFArrayRef v4 = ComponentAttribute;
      uint64_t v5 = malloc_type_calloc(1uLL, 0x30uLL, 0x1000040EED21634uLL);
      BOOL v6 = v5;
      if (v5)
      {
        CFIndex v7 = 0;
        long long v8 = *MEMORY[0x1E4F1DAB8];
        long long v9 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 32);
        v5[1] = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
        v5[2] = v9;
        *uint64_t v5 = v8;
        do
        {
          CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(v4, v7);
          if (ValueAtIndex)
          {
            uint64_t valuePtr = -1;
            CFNumberGetValue(ValueAtIndex, kCFNumberDoubleType, &valuePtr);
            uint64_t v11 = valuePtr;
          }
          else
          {
            uint64_t v11 = 0;
          }
          v6[v7++] = v11;
        }
        while (v7 != 6);
      }
      uint64_t v12 = 0;
      atomic_compare_exchange_strong((atomic_ullong *volatile)this + 91, (unint64_t *)&v12, (unint64_t)v6);
      if (v12) {
        free(v6);
      }
    }
  }
  return atomic_load_explicit((atomic_ullong *volatile)this + 91, memory_order_acquire);
}

atomic_ullong *TAttributes::SetLayoutAttributesForFont(atomic_ullong *this)
{
  __n128 result = *(atomic_ullong **)(atomic_load_explicit(this + 2, memory_order_acquire) + 40);
  if (result)
  {
    BOOL v4 = -86;
    __n128 result = (atomic_ullong *)TFont::IsSystemUIFontAndForShaping(result, &v4);
    if (result)
    {
      __int16 v3 = *((_WORD *)this + 69);
      *((_WORD *)this + 69) = v3 | 0x200;
      if (v4) {
        *((_WORD *)this + 69) = v3 | 0x600;
      }
    }
  }
  return result;
}

uint64_t TFont::IsSystemUIFontAndForShaping(atomic_ullong *this, BOOL *a2)
{
  if (atomic_load_explicit(this + 1, memory_order_acquire)
    && (int v4 = *(_DWORD *)(*(void *)(atomic_load_explicit(this + 1, memory_order_acquire) + 40) + 16),
        (TDescriptor::GetSystemUIFontOptions((TDescriptor *)this) & v4) != 0))
  {
    BOOL v5 = (*(unsigned char *)this & 0x20) == 0;
    uint64_t result = 1;
  }
  else
  {
    BOOL v5 = 0;
    uint64_t result = 0;
  }
  *a2 = v5;
  return result;
}

uint64_t TDescriptor::GetSystemUIFontOptions(TDescriptor *this)
{
  if (qword_1EB2CE0B0 != -1) {
    dispatch_once_f(&qword_1EB2CE0B0, 0, (dispatch_function_t)TDescriptor::GetSystemUIFontOptions(void)::$_0::__invoke);
  }
  return _MergedGlobals_13;
}

uint64_t CTParagraphStyleGetCompositionLanguageForLanguage(__CFString *cf1)
{
  if (!cf1 || cf1 == @"en-US-POSIX" || CFEqual(cf1, @"en-US-POSIX"))
  {
    os_unfair_lock_lock_with_options();
    if (dword_1EB2CE3A4 != TGenerationSeed::sGeneration)
    {
      dword_1EB2CE3A4 = TGenerationSeed::sGeneration;
      CFArrayRef v2 = CFLocaleCopyPreferredLanguages();
      _MergedGlobals_22 = CompositionLanguageWithPreferences(v2);
    }
    uint64_t v3 = _MergedGlobals_22;
    os_unfair_lock_unlock((os_unfair_lock_t)algn_1EB2CE3A8);
  }
  else
  {
    values = cf1;
    CFArrayRef v4 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&values, 1, MEMORY[0x1E4F1D510]);
    uint64_t v3 = CompositionLanguageWithPreferences(v4);
  }
  return v3;
}

void TAttributes::HandleForegroundNSColorAttribute(id a1, uint64_t *a2)
{
  if (a1)
  {
    uint64_t v2 = *a2;
    *(unsigned char *)(v2 + 136) = *(unsigned char *)(*a2 + 136) | 2;
    TCFRef<__CTFont const*>::Retain((atomic_ullong *)(v2 + 32), a1);
  }
}

uint64_t TParagraphStyle::SetStyle(TParagraphStyle *this, CFTypeRef cf)
{
  if (!cf) {
    return 0;
  }
  *(void *)this = cf;
  CFTypeID v3 = CFGetTypeID(cf);
  if (v3 == CTParagraphStyleGetTypeID())
  {
    uint64_t result = 1;
    *((unsigned char *)this + 8) = 1;
  }
  else
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB2CE430, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB2CE430))
    {
      _MergedGlobals_23 = (uint64_t)NSClassFromString(&cfstr_Nsparagraphsty.isa);
      __cxa_guard_release(&qword_1EB2CE430);
    }
    if (objc_opt_isKindOfClass())
    {
      *((unsigned char *)this + 8) = 0;
      return 1;
    }
    else
    {
      uint64_t result = 0;
      *(void *)this = 0;
    }
  }
  return result;
}

CFTypeID CTParagraphStyleGetTypeID(void)
{
  if (qword_1EB2CE3B0 != -1) {
    dispatch_once_f(&qword_1EB2CE3B0, 0, (dispatch_function_t)TCFBase<TNativeParagraphStyle>::GetTypeID(void)::{lambda(void *)#1}::__invoke);
  }
  return qword_1EB2CE3B8;
}

id TParagraphStyle::GetCompositionLanguage(TParagraphStyle **this, const void *a2)
{
  int v3 = *((unsigned __int8 *)this + 8);
  CFArrayRef v4 = *this;
  if (v3) {
    return (id)*((unsigned __int8 *)TParagraphStyle::GetNative(v4, a2) + 48);
  }
  if ((objc_opt_respondsToSelector() & 1) == 0) {
    return 0;
  }
  BOOL v6 = *this;

  return [(TParagraphStyle *)v6 compositionLanguage];
}

uint64_t TAttributes::HandleParagraphStyleAttribute(uint64_t result, uint64_t a2)
{
  **(void **)(a2 + 40) = result;
  return result;
}

char *std::vector<long,TInlineBufferAllocator<long,30ul>>::__swap_out_circular_buffer(void **a1, uint64_t a2, char *__src)
{
  BOOL v5 = *(char **)(a2 + 8);
  BOOL v6 = (char *)*a1;
  CFIndex v7 = v5;
  if (*a1 != __src)
  {
    long long v8 = __src;
    CFIndex v7 = *(char **)(a2 + 8);
    do
    {
      uint64_t v9 = *((void *)v8 - 1);
      v8 -= 8;
      *((void *)v7 - 1) = v9;
      v7 -= 8;
    }
    while (v8 != v6);
  }
  *(void *)(a2 + 8) = v7;
  __n128 v10 = a1[1];
  uint64_t v11 = *(void *)(a2 + 16);
  int64_t v12 = v10 - __src;
  if (v10 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v10 - __src);
    CFIndex v7 = *(char **)(a2 + 8);
  }
  *(void *)(a2 + 16) = v11 + v12;
  int v13 = (char *)*a1;
  *a1 = v7;
  *(void *)(a2 + 8) = v13;
  CFIndex v14 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(void *)(a2 + 16) = v14;
  long long v15 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(void *)(a2 + 24) = v15;
  *(void *)a2 = *(void *)(a2 + 8);
  return v5;
}

double TDelegateRun::GetAscent(TDelegateRun *this)
{
  return *((double *)this + 47);
}

double TDelegateRun::GetDescent(TDelegateRun *this)
{
  return *((double *)this + 48);
}

uint64_t TRun::GetGlyphIndexForCharIndex<true>(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 208);
  if (v2 < 1) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v6 = a2 - v5;
  if (a2 - v5 >= v2) {
    unint64_t v7 = v2 - 1;
  }
  else {
    unint64_t v7 = a2 - v5;
  }
  if (v6 >= 0) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = 0;
  }
  char v9 = *(unsigned char *)(a1 + 224);
  if (v9) {
    uint64_t v10 = v2 + ~v8;
  }
  else {
    uint64_t v10 = v8;
  }
  uint64_t v11 = *(void **)(a1 + 216);
  uint64_t v12 = v11[6];
  uint64_t v13 = *(void *)(a1 + 200);
  uint64_t v14 = v12 + 8 * v13;
  uint64_t v15 = *(void *)(v14 + 8 * v10);
  if (v15 == a2) {
    return v10;
  }
  if (*(_DWORD *)(a1 + 256) != 2)
  {
    if (v15 >= a2)
    {
      if (v9)
      {
        if (v2 + ~v8 <= v2 - 1) {
          uint64_t v10 = v2 - 1;
        }
        else {
          uint64_t v10 = v2 + ~v8;
        }
        uint64_t v18 = v2 - v8;
        while (v10 + 1 != v18)
        {
          uint64_t v19 = *(void *)(v14 + 8 * v18++);
          if (v19 <= a2) {
            return v18 - 1;
          }
        }
      }
      else if (v8 < 1)
      {
        return v8;
      }
      else
      {
        do
        {
          uint64_t v10 = v7 - 1;
          if (v7 < 2) {
            break;
          }
          uint64_t v17 = *(void *)(v12 + 8 * v13 - 8 + 8 * v7--);
        }
        while (v17 > a2);
      }
      return v10;
    }
    if ([v11 attachmentCountAtIndex:v10 + v13] + v15 >= a2) {
      return v10;
    }
  }

  return TRun::FindGlyphIndex<true>(a1, a2, 1);
}

uint64_t *TParagraphStyle::GetNative(TParagraphStyle *this, const void *a2)
{
  if (this)
  {
    CFTypeID v3 = CFGetTypeID(this);
    if (v3 == CTParagraphStyleGetTypeID()) {
      return (uint64_t *)*((void *)this + 5);
    }
  }
  if (v5)
  {
    TParagraphStyle::GetNative(void const*)::sBackstop = 0;
    *(void *)algn_1E8F8AE48 = 0;
    qword_1E8F8AE50 = 0;
    qword_1E8F8AE58 = (uint64_t)TNativeParagraphStyle::CopyDefaultTabStops(v5);
    word_1E8F8AE60 = 1024;
    byte_1E8F8AE62 = -1;
    qword_1E8F8AE68 = 0;
    byte_1E8F8AE70 = 0;
  }
  return &TParagraphStyle::GetNative(void const*)::sBackstop;
}

double TDelegateRun::GetLeading(TDelegateRun *this)
{
  return 0.0;
}

CGRect CTFontGetBoundingBox(CTFontRef font)
{
  if (font)
  {
    double BoundingBox = TFont::GetBoundingBox(*((TFont **)font + 5));
  }
  else
  {
    double BoundingBox = *MEMORY[0x1E4F1DB20];
    double v2 = *(double *)(MEMORY[0x1E4F1DB20] + 8);
    double v3 = *(double *)(MEMORY[0x1E4F1DB20] + 16);
    double v4 = *(double *)(MEMORY[0x1E4F1DB20] + 24);
  }
  result.size.CGFloat height = v4;
  result.size.CGFloat width = v3;
  result.origin.y = v2;
  result.origin.x = BoundingBox;
  return result;
}

double TFont::GetBoundingBox(TFont *this)
{
  if (*((_DWORD *)this + 12)) {
    inited = (int *)((char *)this + 48);
  }
  else {
    inited = TFont::InitStrikeMetrics(this);
  }
  return *((double *)inited + 7);
}

uint64_t TBaseFont::GetFontMatrix(TBaseFont *this)
{
  return 0;
}

const void *TAttributes::GetBackgroundColor(TAttributes *this, const __CFDictionary *a2, const __CFString **a3)
{
  uint64_t v5 = @"CTBackgroundColor";
  CGRect result = CFDictionaryGetValue(this, @"CTBackgroundColor");
  if (a2 && result
    || !result
    && (uint64_t v5 = @"NSBackgroundColor", result = CFDictionaryGetValue(this, @"NSBackgroundColor"), a2)
    && result)
  {
    *(void *)a2 = v5;
  }
  return result;
}

void TAttributes::HandleShadowAttribute(void *a1, uint64_t *a2)
{
  if (a1)
  {
    id v4 = objc_msgSend(a1, sel_shadowColor);
    uint64_t v5 = *a2;
    char v6 = *(unsigned char *)(*a2 + 136);
    if (v4)
    {
      *(unsigned char *)(v5 + 136) = v6 | 8;
      TCFRef<__CTFont const*>::Retain((atomic_ullong *)(v5 + 40), a1);
    }
    else
    {
      *(unsigned char *)(v5 + 136) = v6 | 0x10;
    }
  }
}

uint64_t OTL::BASE::HasScriptSpecificMetrics(OTL::BASE *this)
{
  *(void *)&_OWORD v34[4] = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)this;
  if (!*(void *)this) {
    return 0;
  }
  char v3 = 0;
  uint64_t v4 = 0;
  qmemcpy(__s, "gnahbfcilfcirfcitfcioediptdihtamnmor", sizeof(__s));
  unint64_t v5 = *((void *)this + 1);
  unsigned int v6 = *(unsigned __int16 *)(v1 + 4);
  uint64_t v7 = v1 + __rev16(v6);
  if (v7 + 4 > v5 || v6 == 0) {
    uint64_t v9 = 0;
  }
  else {
    uint64_t v9 = v7;
  }
  unsigned int v10 = *(unsigned __int16 *)(v1 + 6);
  uint64_t v11 = v1 + __rev16(v10);
  if (v11 + 4 > v5 || v10 == 0) {
    uint64_t v11 = 0;
  }
  v32[0] = v9;
  v32[1] = v11;
  while (1)
  {
    char v13 = v3;
    uint64_t v14 = (unsigned __int16 *)v32[v4];
    if (v14)
    {
      unsigned int v15 = *v14;
      CGAffineTransform v16 = (char *)v14 + __rev16(v15);
      uint64_t v17 = v15 ? v16 : 0;
      unint64_t v18 = *((void *)this + 1);
      uint64_t v19 = (unsigned int *)(v17 + 2);
      if (*(void *)this <= (unint64_t)v17 && (unint64_t)v19 <= v18)
      {
        unsigned int v21 = *(unsigned __int16 *)v17;
        uint64_t v22 = __rev16(v21);
        long long v23 = &v19[v22];
        unint64_t v24 = (unint64_t)(v17 + 6) <= v18 ? (v18 - (unint64_t)v19) >> 2 : 0;
        BOOL v25 = (unint64_t)v23 <= v18 && v23 >= v19;
        BOOL v26 = v25 || v24 == v22;
        if (v26 && v21 != 0) {
          break;
        }
      }
    }
LABEL_41:
    char v3 = 1;
    uint64_t v4 = 1;
    if (v13) {
      return 0;
    }
  }
  uint64_t v28 = 4 * v22;
  while (1)
  {
    CGFloat v29 = wmemchr(__s, bswap32(*v19), 9uLL);
    CGRect v30 = v29 ? v29 : (__int32 *)v34;
    if ((char *)v30 - (char *)__s == 36) {
      return 1;
    }
    ++v19;
    v28 -= 4;
    if (!v28) {
      goto LABEL_41;
    }
  }
}

uint64_t OTL::BASE::BASE(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  *(_OWORD *)(a1 + 16) = 0u;
  uint64_t v4 = (void *)(a1 + 16);
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  if (a2)
  {
    if (a2 + 8 > a3 || *(_WORD *)a2 != 256) {
      goto LABEL_9;
    }
    if (!*(_WORD *)(a2 + 2)) {
      return a1;
    }
    if (a2 + 12 > a3)
    {
LABEL_9:
      *(void *)a1 = 0;
      return a1;
    }
    unsigned int v5 = *(_DWORD *)(a2 + 8);
    if (v5) {
      ItemVariationStore::Initialize(v4, a2 + bswap32(v5), a3);
    }
  }
  return a1;
}

void TLine::DetachRuns(atomic_ullong *this)
{
  uint64_t v2 = this[3] - this[2];
  if (v2 >= 1)
  {
    uint64_t v3 = 0;
    uint64_t v4 = (unint64_t)v2 >> 3;
    if (v4 <= 1) {
      uint64_t v5 = 1;
    }
    else {
      uint64_t v5 = v4;
    }
    do
      TLine::DetachRun((TLine *)this, v3++);
    while (v5 != v3);
  }
}

uint64_t CompositionLanguageWithPreferences(const __CFArray *a1)
{
  if (a1)
  {
    CFIndex Count = CFArrayGetCount(a1);
    if (Count)
    {
      CFIndex v3 = Count;
      CFIndex v4 = 0;
      while (1)
      {
        CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a1, v4);
        if (ValueAtIndex == @"zh") {
          break;
        }
        CFStringRef v6 = ValueAtIndex;
        if (ValueAtIndex)
        {
          int HasPrefix = CFStringHasPrefix(ValueAtIndex, @"zh");
          if (v6 == @"wuu") {
            break;
          }
          if (HasPrefix) {
            break;
          }
          int v8 = CFStringHasPrefix(v6, @"wuu");
          if (v6 == @"yue") {
            break;
          }
          if (v8) {
            break;
          }
          int v9 = CFStringHasPrefix(v6, @"yue");
          if (v6 == @"ja" || v9 || CFStringHasPrefix(v6, @"ja")) {
            break;
          }
        }
        if (v3 == ++v4) {
          return 1;
        }
      }
      CFArrayRef v11 = CFBundleCopyLocalizationsForPreferences((CFArrayRef)&unk_1ED085028, a1);
      CFArrayRef v12 = v11;
      if (v12)
      {
        CFArrayRef v13 = v12;
        CFIndex v14 = CFArrayGetCount(v12);

        if (!v14) {
          goto LABEL_37;
        }
        CFArrayRef v12 = v11;
        if (v12)
        {
          CFArrayRef v15 = v12;
          CGAffineTransform v16 = (__CFString *)CFArrayGetValueAtIndex(v12, 0);

          uint64_t v10 = 1;
          if (v16 == @"zxx" || !v16 || CFEqual(v16, @"zxx")) {
            goto LABEL_38;
          }
          if (v16 == @"zh-Hans")
          {
            uint64_t v10 = 3;
            goto LABEL_38;
          }
          uint64_t v10 = 3;
          if (CFEqual(v16, @"zh-Hans")
            || v16 == @"wuu-Hans"
            || CFEqual(v16, @"wuu-Hans")
            || v16 == @"yue-Hans"
            || CFEqual(v16, @"yue-Hans"))
          {
            goto LABEL_38;
          }
          if (v16 == @"zh-Hant")
          {
            uint64_t v10 = 4;
            goto LABEL_38;
          }
          uint64_t v10 = 4;
          if (CFEqual(v16, @"zh-Hant")
            || v16 == @"yue-Hant"
            || CFEqual(v16, @"yue-Hant")
            || v16 == @"wuu-Hant"
            || CFEqual(v16, @"wuu-Hant"))
          {
            goto LABEL_38;
          }
          if (v16 == @"ja" || CFEqual(v16, @"ja"))
          {
            uint64_t v10 = 2;
LABEL_38:

            return v10;
          }
LABEL_37:
          uint64_t v10 = 1;
          goto LABEL_38;
        }
      }

      goto LABEL_37;
    }
  }
  return 1;
}

uint64_t TFont::GetMaxAdvance(TFont *this)
{
  uint64_t v2 = *((void *)this + 50);
  TFont::GetScaledMatrix(this, &v4);
  return (*(uint64_t (**)(uint64_t, CGAffineTransform *, void))(*(void *)v2 + 624))(v2, &v4, *(_DWORD *)this & 1);
}

void TLine::InsertLastRun(TLine *a1, uint64_t a2, atomic_ullong *a3)
{
  unint64_t v6 = atomic_exchange(a3, 0);
  CGAffineTransform v4 = *(const TRun **)(v6 + 48);
  uint64_t v5 = *((void *)a1 + 12);
  if (v5)
  {
    *(void *)(v5 + 24) = v4;
    *((void *)a1 + 12) = v4;
    *((void *)v4 + 3) = 0;
    *((void *)v4 + 4) = v5;
  }
  std::vector<CTRun *,TInlineBufferAllocator<CTRun *,3ul>>::insert((uint64_t)a1 + 16, (char *)(*((void *)a1 + 2) + 8 * a2), (char *)&v6);
  TLine::UpdateCachedMetricsForRun(a1, v4);
}

char *std::vector<CTRun *,TInlineBufferAllocator<CTRun *,3ul>>::insert(uint64_t a1, char *__src, char *a3)
{
  CFIndex v3 = a3;
  CGAffineTransform v4 = __src;
  unint64_t v6 = *(char **)(a1 + 8);
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    CFArrayRef v12 = *(char **)a1;
    unint64_t v13 = ((uint64_t)&v6[-*(void *)a1] >> 3) + 1;
    unint64_t v29 = 0xAAAAAAAAAAAAAAAALL;
    if (v13 >> 61) {
      abort();
    }
    uint64_t v14 = __src - v12;
    uint64_t v15 = (__src - v12) >> 3;
    uint64_t v16 = v7 - (void)v12;
    if (v16 >> 2 > v13) {
      unint64_t v13 = v16 >> 2;
    }
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v17 = v13;
    }
    uint64_t v31 = a1 + 24;
    if (v17) {
      unint64_t v18 = (char *)TInlineBufferAllocator<CTRun *,3ul>::allocate(a1 + 24, v17);
    }
    else {
      unint64_t v18 = 0;
    }
    uint64_t v19 = &v18[8 * v15];
    uint64_t v27 = v18;
    uint64_t v28 = v19;
    int v20 = &v18[8 * v17];
    CGRect v30 = v20;
    if (v15 == v17)
    {
      if (v14 < 1)
      {
        if (v12 == v4) {
          unint64_t v22 = 1;
        }
        else {
          unint64_t v22 = v14 >> 2;
        }
        uint64_t v36 = a1 + 24;
        long long v23 = (char *)TInlineBufferAllocator<CTRun *,3ul>::allocate(a1 + 24, v22);
        unint64_t v24 = &v23[8 * (v22 >> 2)];
        uint64_t v27 = v23;
        uint64_t v28 = v24;
        uint64_t v32 = v18;
        CFRange v33 = &v18[8 * v15];
        CGRect v30 = &v23[8 * v22];
        uint64_t v34 = v33;
        CFNumberRef v35 = v20;
        std::__split_buffer<CTRun *,TInlineBufferAllocator<CTRun *,3ul> &>::~__split_buffer((uint64_t)&v32);
        uint64_t v19 = v24;
      }
      else
      {
        unint64_t v21 = v15 + 2;
        if (v15 >= -1) {
          unint64_t v21 = v15 + 1;
        }
        v19 -= 8 * (v21 >> 1);
        uint64_t v28 = v19;
      }
    }
    *(void *)uint64_t v19 = *(void *)a3;
    unint64_t v29 = (unint64_t)(v19 + 8);
    CGAffineTransform v4 = std::vector<long,TInlineBufferAllocator<long,30ul>>::__swap_out_circular_buffer((void **)a1, (uint64_t)&v27, v4);
    std::__split_buffer<CTRun *,TInlineBufferAllocator<CTRun *,3ul> &>::~__split_buffer((uint64_t)&v27);
  }
  else if (__src == v6)
  {
    *(void *)__src = *(void *)a3;
    *(void *)(a1 + 8) = __src + 8;
  }
  else
  {
    int v8 = __src + 8;
    int v9 = v6 - 8;
    uint64_t v10 = *(void **)(a1 + 8);
    while (v9 < v6)
    {
      uint64_t v11 = *(void *)v9;
      v9 += 8;
      *v10++ = v11;
    }
    *(void *)(a1 + 8) = v10;
    if (v6 != v8) {
      memmove(&v6[-8 * ((v6 - v8) >> 3)], __src, v6 - v8);
    }
    if (v4 <= v3) {
      v3 += 8 * (*(void *)(a1 + 8) > (unint64_t)v3);
    }
    *(void *)CGAffineTransform v4 = *(void *)v3;
  }
  return v4;
}

uint64_t TRun::EnsureRareData(TRun *this)
{
  uint64_t result = *((void *)this + 39);
  if (!result) {
    operator new();
  }
  return result;
}

CGFloat TSplicedFontDict::GetMaxAdvance(atomic_ullong *this, double a2, const CGAffineTransform *a3)
{
  CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit(this, memory_order_acquire);
  if (explicit)
  {
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(explicit, @"FontMetrics");
    if (Value)
    {
      CFDictionaryRef v7 = Value;
      if (CFDictionaryGetCount(Value) >= 1)
      {
        CFStringRef v8 = (const __CFString *)CFDictionaryGetValue(v7, @"advanceMax");
        if (v8) {
          return a3->tx + a3->c * 0.0 + a3->a * CFStringGetDoubleValue(v8);
        }
      }
    }
  }
  return a2;
}

uint64_t TSplicedFont::GetFontMatrix(TSplicedFont *this)
{
  uint64_t v1 = *(void *)(*((void *)this + 76) + 40);
  if ((*(_DWORD *)(v1 + 16) & 0x80000000) == 0) {
    TDescriptor::InitBaseFont(*(TDescriptor **)(*((void *)this + 76) + 40), 0, 0.0);
  }
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)atomic_load_explicit((atomic_ullong *volatile)(v1 + 32), memory_order_acquire)
                           + 168);

  return v2();
}

double TAttributes::GetOriginalValueOf(atomic_ullong *this, const __CFString *a2)
{
  double valuePtr = 0.0;
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit(this, memory_order_acquire), a2);
  if (Value)
  {
    CFNumberRef v3 = Value;
    CFTypeID v4 = CFGetTypeID(Value);
    if (v4 == CFNumberGetTypeID() || v4 == CFBooleanGetTypeID())
    {
      CFNumberGetValue(v3, kCFNumberDoubleType, &valuePtr);
    }
    else if (v4 == CFStringGetTypeID())
    {
      return CFStringGetDoubleValue((CFStringRef)v3);
    }
  }
  return valuePtr;
}

uint64_t TextScaleWeightMatchVariableOnly(const __CFDictionary *a1)
{
  uint64_t result = CFDictionaryContainsKey(a1, @"NSTextScaleStaticWeightMatching");
  if (result)
  {
    CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(a1, @"NSTextScaleStaticWeightMatching");
    return !Value || CFBooleanGetValue(Value) == 0;
  }
  return result;
}

CFNumberRef CustomRatioFromAttributes(const __CFDictionary *a1)
{
  CFNumberRef result = (const __CFNumber *)CFDictionaryGetValue(a1, @"NSTextScaleRatio");
  if (result)
  {
    CFNumberRef v2 = result;
    uint64_t valuePtr = -1;
    CFTypeID v3 = CFGetTypeID(result);
    if (v3 == CFNumberGetTypeID() || v3 == CFBooleanGetTypeID())
    {
      CFNumberGetValue(v2, kCFNumberDoubleType, &valuePtr);
      DoubleCFBooleanRef Value = *(double *)&valuePtr;
    }
    else
    {
      if (v3 != CFStringGetTypeID()) {
        return 0;
      }
      DoubleCFBooleanRef Value = CFStringGetDoubleValue((CFStringRef)v2);
    }
    if (DoubleValue < 0.0) {
      DoubleCFBooleanRef Value = 0.0;
    }
    return *(const __CFNumber **)&DoubleValue;
  }
  return result;
}

unint64_t TLine::GetRunCFArray(const void ***this)
{
  uint64_t v1 = (atomic_ullong *)(this + 20);
  if (!atomic_load_explicit((atomic_ullong *volatile)this + 20, memory_order_acquire))
  {
    id v6 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], this[2], this[3] - this[2], MEMORY[0x1E4F1D510]);
    unint64_t v2 = atomic_exchange((atomic_ullong *volatile)&v6, 0);

    uint64_t v3 = 0;
    atomic_compare_exchange_strong(v1, (unint64_t *)&v3, v2);
    if (v3) {
      CFTypeID v4 = (void *)v2;
    }
    else {
      CFTypeID v4 = 0;
    }
  }
  return atomic_load_explicit(v1, memory_order_acquire);
}

uint64_t **CTLineCreateTruncatedLineWithTokenHandler(uint64_t **a1, int a2, const void *a3, double a4)
{
  return CreateTruncatedLine(a1, a2, 0, a3, a4);
}

CGAffineTransform *__cdecl CTFontGetMatrix(CGAffineTransform *__return_ptr retstr, CGAffineTransform *font)
{
  unint64_t v2 = (_OWORD *)MEMORY[0x1E4F1DAB8];
  if (font && *(void *)(*(void *)&font->ty + 40)) {
    unint64_t v2 = *(_OWORD **)(*(void *)&font->ty + 40);
  }
  long long v3 = v2[1];
  *(_OWORD *)&retstr->double a = *v2;
  *(_OWORD *)&retstr->c = v3;
  *(_OWORD *)&retstr->tx = v2[2];
  return font;
}

uint64_t _CTGetVisibleFormatterCharacterSet()
{
  if (qword_1EB2CE778 != -1) {
    dispatch_once_f(&qword_1EB2CE778, 0, (dispatch_function_t)_CTGetVisibleFormatterCharacterSet::$_0::__invoke);
  }
  return qword_1EB2CE770;
}

CFIndex CTRunGetGlyphCount(CFIndex run)
{
  if (run) {
    return TRun::GetNonDeletedGlyphCount(*(TRun **)(run + 40));
  }
  return run;
}

BOOL TGlyphIterator::MatchCoverSequence<(MatchDirection)1>(uint64_t a1, uint64_t a2, int a3, unsigned __int16 *a4, uint64_t a5, unint64_t a6, uint64_t *a7)
{
  uint64_t v12 = a2;
  uint64_t v14 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = a2;
  if (TGlyphIterator::PrevContext((TGlyphIterator *)a1, 1))
  {
    uint64_t v21 = v14;
    while (1)
    {
      uint64_t v12 = *(void *)(a1 + 48);
      uint64_t GlyphID = TRunGlue::GetGlyphID(*(TRunGlue **)a1, v12);
      unint64_t v24 = 0xAAAAAAAAAAAAAAAALL;
      *(void *)&long long v16 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long v22 = v16;
      long long v23 = v16;
      unsigned int v17 = *a4++;
      OTL::Coverage::Coverage((OTL::Coverage *)&v22, (unsigned __int16 *)(a5 + (bswap32(v17) >> 16)), a6, 1);
      unint64_t v18 = (unsigned int (*)(void *, uint64_t))v23;
      uint64_t v19 = (void *)((char *)&v22 + (*((uint64_t *)&v23 + 1) >> 1));
      if (BYTE8(v23)) {
        unint64_t v18 = *(unsigned int (**)(void *, uint64_t))(*v19 + v23);
      }
      if (!v18(v19, GlyphID)) {
        break;
      }
      if (!--a3) {
        break;
      }
      if ((TGlyphIterator::PrevContext((TGlyphIterator *)a1, 1) & 1) == 0)
      {
        a3 = 1;
        break;
      }
    }
    uint64_t v14 = v21;
  }
  if (a7) {
    *a7 = v12;
  }
  *(void *)(a1 + 48) = v14;
  return a3 == 0;
}

OTL::Lookup *OTL::Lookup::Lookup<OTL::GPOS>(OTL::Lookup *this, uint64_t a2, unint64_t a3)
{
  *(void *)this = a3;
  unint64_t v4 = *(void *)(a2 + 40);
  *((void *)this + 1) = v4;
  *((_WORD *)this + 8) = 0;
  *((void *)this + 3) = 0;
  *((unsigned char *)this + 32) = 0;
  *((_DWORD *)this + 10) = 0;
  *((_WORD *)this + 22) = 0;
  *((void *)this + 10) = (char *)this + 46;
  *((void *)this + 11) = 0;
  uint64_t v5 = (int64x2_t *)((char *)this + 88);
  *((void *)this + 12) = 0;
  *((void *)this + 13) = 0;
  CFTypeID v42 = (char *)this + 112;
  *((void *)this + 38) = (char *)this + 112;
  if (a3 + 6 <= v4)
  {
    LODWORD(v6) = bswap32(*(unsigned __int16 *)(a3 + 4)) >> 16;
    unint64_t v7 = *(unsigned __int16 *)(a3 + 2);
    unint64_t v8 = a3 + 2 * v6 + ((v7 >> 11) & 2) + 6;
    if (v8 >= a3 && v8 <= v4)
    {
      if ((v7 & 0x1EFF) != 0)
      {
        OTL::Lookup::PopulateIgnoreSet(this, *(const OTL::GDEF **)(a2 + 24));
        a3 = *(void *)this;
        unint64_t v4 = *((void *)this + 1);
        LODWORD(v6) = bswap32(*(unsigned __int16 *)(*(void *)this + 4)) >> 16;
      }
      unint64_t v11 = 2 * v6 + a3 + 6;
      if (v11 < a3 + 6 || v11 > v4)
      {
        if (a3 + 8 > v4) {
          return this;
        }
        unint64_t v6 = (v4 - (a3 + 6)) >> 1;
      }
      if (v6)
      {
        uint64_t v13 = v6;
        std::vector<std::pair<OTL::LookupSubtable const*,OTL::Coverage>,TInlineBufferAllocator<std::pair<OTL::LookupSubtable const*,OTL::Coverage>,4ul>>::reserve(v5, v6);
        uint64_t v14 = 0;
        unsigned int v15 = **(unsigned __int16 **)this;
        __int16 v41 = __rev16(v15);
        do
        {
          uint64_t v16 = *(void *)this + (bswap32(*(unsigned __int16 *)(*(void *)this + 2 * v14 + 6)) >> 16);
          if (v15 == 2304)
          {
            unint64_t v17 = *((void *)this + 1);
            if (v16 + 8 > v17 || *(_WORD *)v16 != 256) {
              return this;
            }
            unsigned int v18 = *(unsigned __int16 *)(v16 + 2);
            if (v18 == 2304)
            {
              uint64_t v16 = 0;
              __int16 v21 = 9;
            }
            else
            {
              __int16 v19 = __rev16(v18);
              uint64_t v20 = v16 + bswap32(*(_DWORD *)(v16 + 4));
              if (v20 + 2 <= v17) {
                uint64_t v16 = v20;
              }
              else {
                uint64_t v16 = 0;
              }
              if (v20 + 2 <= v17) {
                __int16 v21 = v19;
              }
              else {
                __int16 v21 = 9;
              }
            }
          }
          else
          {
            __int16 v21 = v41;
          }
          (*(void (**)(_OWORD *__return_ptr, uint64_t))(*(void *)a2 + 16))(v43, a2);
          long long v45 = v43[0];
          long long v46 = v43[1];
          uint64_t v47 = v44;
          unint64_t v22 = *((void *)this + 12);
          unint64_t v23 = *((void *)this + 13);
          if (v22 >= v23)
          {
            unint64_t v26 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v22 - v5->i64[0]) >> 4);
            unint64_t v27 = v26 + 1;
            if (v26 + 1 > 0x555555555555555) {
              abort();
            }
            unint64_t v28 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v23 - v5->i64[0]) >> 4);
            if (2 * v28 > v27) {
              unint64_t v27 = 2 * v28;
            }
            if (v28 >= 0x2AAAAAAAAAAAAAALL) {
              unint64_t v29 = 0x555555555555555;
            }
            else {
              unint64_t v29 = v27;
            }
            long long v51 = v42;
            if (v29) {
              CGRect v30 = (char *)TInlineBufferAllocator<std::pair<OTL::LookupSubtable const*,OTL::Coverage>,4ul>::allocate((uint64_t)v42, v29);
            }
            else {
              CGRect v30 = 0;
            }
            uint64_t v31 = &v30[48 * v26];
            *(void *)uint64_t v31 = v16;
            long long v32 = v46;
            *(_OWORD *)(v31 + 8) = v45;
            *(_OWORD *)(v31 + 24) = v32;
            *((void *)v31 + 5) = v47;
            uint64_t v34 = *((void *)this + 11);
            unint64_t v33 = *((void *)this + 12);
            if (v33 == v34)
            {
              int64x2_t v38 = vdupq_n_s64(v33);
              CFNumberRef v35 = &v30[48 * v26];
            }
            else
            {
              CFNumberRef v35 = &v30[48 * v26];
              do
              {
                long long v36 = *(_OWORD *)(v33 - 48);
                long long v37 = *(_OWORD *)(v33 - 16);
                *((_OWORD *)v35 - 2) = *(_OWORD *)(v33 - 32);
                *((_OWORD *)v35 - 1) = v37;
                *((_OWORD *)v35 - 3) = v36;
                v35 -= 48;
                v33 -= 48;
              }
              while (v33 != v34);
              int64x2_t v38 = *v5;
            }
            BOOL v25 = v31 + 48;
            *((void *)this + 11) = v35;
            *((void *)this + 12) = v31 + 48;
            int64x2_t v49 = v38;
            uint64_t v39 = *((void *)this + 13);
            *((void *)this + 13) = &v30[48 * v29];
            uint64_t v50 = v39;
            uint64_t v48 = v38.i64[0];
            std::__split_buffer<std::pair<OTL::LookupSubtable const*,OTL::Coverage>,TInlineBufferAllocator<std::pair<OTL::LookupSubtable const*,OTL::Coverage>,4ul> &>::~__split_buffer((uint64_t)&v48);
          }
          else
          {
            *(void *)unint64_t v22 = v16;
            long long v24 = v46;
            *(_OWORD *)(v22 + 8) = v45;
            *(_OWORD *)(v22 + 24) = v24;
            *(void *)(v22 + 40) = v47;
            BOOL v25 = (char *)(v22 + 48);
          }
          *((void *)this + 12) = v25;
          ++v14;
        }
        while (v14 != v13);
        *((_WORD *)this + 8) = v21;
      }
    }
  }
  return this;
}

OTL::Lookup *OTL::Lookup::Lookup<OTL::GSUB>(OTL::Lookup *this, uint64_t a2, unint64_t a3)
{
  *(void *)this = a3;
  unint64_t v4 = *(void *)(a2 + 40);
  *((void *)this + 1) = v4;
  *((_WORD *)this + 8) = 0;
  *((void *)this + 3) = 0;
  *((unsigned char *)this + 32) = 0;
  *((_DWORD *)this + 10) = 0;
  *((_WORD *)this + 22) = 0;
  *((void *)this + 10) = (char *)this + 46;
  *((void *)this + 11) = 0;
  uint64_t v5 = (int64x2_t *)((char *)this + 88);
  *((void *)this + 12) = 0;
  *((void *)this + 13) = 0;
  CFTypeID v42 = (char *)this + 112;
  *((void *)this + 38) = (char *)this + 112;
  if (a3 + 6 <= v4)
  {
    LODWORD(v6) = bswap32(*(unsigned __int16 *)(a3 + 4)) >> 16;
    unint64_t v7 = *(unsigned __int16 *)(a3 + 2);
    unint64_t v8 = a3 + 2 * v6 + ((v7 >> 11) & 2) + 6;
    if (v8 >= a3 && v8 <= v4)
    {
      if ((v7 & 0x1EFF) != 0)
      {
        OTL::Lookup::PopulateIgnoreSet(this, *(const OTL::GDEF **)(a2 + 24));
        a3 = *(void *)this;
        unint64_t v4 = *((void *)this + 1);
        LODWORD(v6) = bswap32(*(unsigned __int16 *)(*(void *)this + 4)) >> 16;
      }
      unint64_t v11 = 2 * v6 + a3 + 6;
      if (v11 < a3 + 6 || v11 > v4)
      {
        if (a3 + 8 > v4) {
          return this;
        }
        unint64_t v6 = (v4 - (a3 + 6)) >> 1;
      }
      if (v6)
      {
        uint64_t v13 = v6;
        std::vector<std::pair<OTL::LookupSubtable const*,OTL::Coverage>,TInlineBufferAllocator<std::pair<OTL::LookupSubtable const*,OTL::Coverage>,4ul>>::reserve(v5, v6);
        uint64_t v14 = 0;
        unsigned int v15 = **(unsigned __int16 **)this;
        __int16 v41 = __rev16(v15);
        do
        {
          uint64_t v16 = *(void *)this + (bswap32(*(unsigned __int16 *)(*(void *)this + 2 * v14 + 6)) >> 16);
          if (v15 == 1792)
          {
            unint64_t v17 = *((void *)this + 1);
            if (v16 + 8 > v17 || *(_WORD *)v16 != 256) {
              return this;
            }
            unsigned int v18 = *(unsigned __int16 *)(v16 + 2);
            if (v18 == 1792)
            {
              uint64_t v16 = 0;
              __int16 v21 = 7;
            }
            else
            {
              __int16 v19 = __rev16(v18);
              uint64_t v20 = v16 + bswap32(*(_DWORD *)(v16 + 4));
              if (v20 + 2 <= v17) {
                uint64_t v16 = v20;
              }
              else {
                uint64_t v16 = 0;
              }
              if (v20 + 2 <= v17) {
                __int16 v21 = v19;
              }
              else {
                __int16 v21 = 7;
              }
            }
          }
          else
          {
            __int16 v21 = v41;
          }
          (*(void (**)(_OWORD *__return_ptr, uint64_t))(*(void *)a2 + 16))(v43, a2);
          long long v45 = v43[0];
          long long v46 = v43[1];
          uint64_t v47 = v44;
          unint64_t v22 = *((void *)this + 12);
          unint64_t v23 = *((void *)this + 13);
          if (v22 >= v23)
          {
            unint64_t v26 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v22 - v5->i64[0]) >> 4);
            unint64_t v27 = v26 + 1;
            if (v26 + 1 > 0x555555555555555) {
              abort();
            }
            unint64_t v28 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v23 - v5->i64[0]) >> 4);
            if (2 * v28 > v27) {
              unint64_t v27 = 2 * v28;
            }
            if (v28 >= 0x2AAAAAAAAAAAAAALL) {
              unint64_t v29 = 0x555555555555555;
            }
            else {
              unint64_t v29 = v27;
            }
            long long v51 = v42;
            if (v29) {
              CGRect v30 = (char *)TInlineBufferAllocator<std::pair<OTL::LookupSubtable const*,OTL::Coverage>,4ul>::allocate((uint64_t)v42, v29);
            }
            else {
              CGRect v30 = 0;
            }
            uint64_t v31 = &v30[48 * v26];
            *(void *)uint64_t v31 = v16;
            long long v32 = v46;
            *(_OWORD *)(v31 + 8) = v45;
            *(_OWORD *)(v31 + 24) = v32;
            *((void *)v31 + 5) = v47;
            uint64_t v34 = *((void *)this + 11);
            unint64_t v33 = *((void *)this + 12);
            if (v33 == v34)
            {
              int64x2_t v38 = vdupq_n_s64(v33);
              CFNumberRef v35 = &v30[48 * v26];
            }
            else
            {
              CFNumberRef v35 = &v30[48 * v26];
              do
              {
                long long v36 = *(_OWORD *)(v33 - 48);
                long long v37 = *(_OWORD *)(v33 - 16);
                *((_OWORD *)v35 - 2) = *(_OWORD *)(v33 - 32);
                *((_OWORD *)v35 - 1) = v37;
                *((_OWORD *)v35 - 3) = v36;
                v35 -= 48;
                v33 -= 48;
              }
              while (v33 != v34);
              int64x2_t v38 = *v5;
            }
            BOOL v25 = v31 + 48;
            *((void *)this + 11) = v35;
            *((void *)this + 12) = v31 + 48;
            int64x2_t v49 = v38;
            uint64_t v39 = *((void *)this + 13);
            *((void *)this + 13) = &v30[48 * v29];
            uint64_t v50 = v39;
            uint64_t v48 = v38.i64[0];
            std::__split_buffer<std::pair<OTL::LookupSubtable const*,OTL::Coverage>,TInlineBufferAllocator<std::pair<OTL::LookupSubtable const*,OTL::Coverage>,4ul> &>::~__split_buffer((uint64_t)&v48);
          }
          else
          {
            *(void *)unint64_t v22 = v16;
            long long v24 = v46;
            *(_OWORD *)(v22 + 8) = v45;
            *(_OWORD *)(v22 + 24) = v24;
            *(void *)(v22 + 40) = v47;
            BOOL v25 = (char *)(v22 + 48);
          }
          *((void *)this + 12) = v25;
          ++v14;
        }
        while (v14 != v13);
        *((_WORD *)this + 8) = v21;
      }
    }
  }
  return this;
}

OTL::Coverage *OTL::Coverage::Coverage(OTL::Coverage *this, unsigned __int16 *a2, unint64_t a3, char a4)
{
  *(void *)this = a2;
  *((void *)this + 1) = a3;
  *((_DWORD *)this + 8) = 0xFFFF;
  BOOL v12 = 0;
  if ((unint64_t)(a2 + 2) > a3 || (a4 & 1) == 0 && !OTL::Coverage::Init(this, &v12)) {
    goto LABEL_2;
  }
  unsigned int v8 = bswap32(*a2) >> 16;
  if (v8 == 2)
  {
    if (v12)
    {
      uint64_t v5 = OTL::Coverage::SearchFmt2Linear;
      goto LABEL_3;
    }
    BOOL v9 = bswap32(a2[1]) >> 16 > 7;
    uint64_t v10 = OTL::Coverage::SearchFmt2Linear;
    unint64_t v11 = OTL::Coverage::SearchFmt2Binary;
    goto LABEL_15;
  }
  if (v8 != 1)
  {
LABEL_2:
    *(void *)this = 0;
    uint64_t v5 = OTL::Coverage::SearchUnknown;
LABEL_3:
    *((void *)this + 2) = v5;
    goto LABEL_4;
  }
  if (v12)
  {
    uint64_t v5 = OTL::Coverage::SearchFmt1Linear;
    goto LABEL_3;
  }
  BOOL v9 = bswap32(a2[1]) >> 16 > 4;
  uint64_t v10 = OTL::Coverage::SearchFmt1Linear;
  unint64_t v11 = OTL::Coverage::SearchFmt1Binary;
LABEL_15:
  if (v9) {
    uint64_t v10 = v11;
  }
  *((void *)this + 2) = v10;
LABEL_4:
  *((void *)this + 3) = 0;
  return this;
}

uint64_t OTL::Coverage::Init(OTL::Coverage *this, BOOL *a2)
{
  unint64_t v2 = *(unsigned __int16 **)this;
  unsigned int v3 = bswap32(**(unsigned __int16 **)this) >> 16;
  if (v3 == 2)
  {
    unsigned int v18 = v2 + 2;
    unsigned int v19 = v2[1];
    unint64_t v20 = *((void *)this + 1);
    unsigned int v21 = __rev16(v19);
    unint64_t v22 = (unint64_t)&v2[3 * v21 + 2];
    if (v22 < (unint64_t)(v2 + 2) || v22 > v20)
    {
      if ((unint64_t)(v2 + 5) > v20) {
        LODWORD(v24) = 0;
      }
      else {
        unint64_t v24 = (v20 - (unint64_t)v18) / 6;
      }
      unsigned int v19 = bswap32(v24) >> 16;
      unsigned int v21 = (unsigned __int16)v24;
    }
    if (v19)
    {
      char v25 = 0;
      LOWORD(v13) = 0;
      unint64_t v26 = &v18[3 * v21];
      unsigned __int16 v15 = -1;
      do
      {
        unsigned int v27 = bswap32(*v18) >> 16;
        unsigned int v28 = bswap32(v18[1]);
        if (v27 <= HIWORD(v28))
        {
          if ((v25 & (v27 <= (unsigned __int16)v13)) == 1) {
            *a2 = 1;
          }
          if (v27 < v15) {
            unsigned __int16 v15 = v27;
          }
          if ((unsigned __int16)v13 <= HIWORD(v28)) {
            LOWORD(v13) = HIWORD(v28);
          }
          char v25 = 1;
        }
        else
        {
          *a2 = 1;
        }
        v18 += 3;
      }
      while (v18 != v26);
      goto LABEL_50;
    }
    LOWORD(v13) = 0;
  }
  else
  {
    if (v3 != 1) {
      return 0;
    }
    unint64_t v4 = v2 + 2;
    unsigned int v5 = v2[1];
    unint64_t v6 = *((void *)this + 1);
    uint64_t v7 = __rev16(v5);
    unint64_t v8 = (unint64_t)&v2[v7 + 2];
    if ((unint64_t)(v2 + 3) <= v6) {
      unsigned int v9 = (v6 - (v2 + 4)) >> 1;
    }
    else {
      unsigned int v9 = 0;
    }
    unsigned int v10 = bswap32(v9) >> 16;
    BOOL v11 = v8 < (unint64_t)v4 || v8 > v6;
    if (v11) {
      uint64_t v12 = (unsigned __int16)v9;
    }
    else {
      uint64_t v12 = v7;
    }
    if (v11) {
      unsigned int v13 = v10;
    }
    else {
      unsigned int v13 = v5;
    }
    if (v13)
    {
      LOWORD(v13) = 0;
      uint64_t v14 = 2 * v12;
      unsigned __int16 v15 = -1;
      char v16 = 1;
      do
      {
        unsigned int v17 = bswap32(*v4) >> 16;
        if ((v16 & 1) == 0 && v17 <= (unsigned __int16)v13) {
          *a2 = 1;
        }
        char v16 = 0;
        if (v17 < v15) {
          unsigned __int16 v15 = v17;
        }
        if (v17 > (unsigned __int16)v13) {
          LOWORD(v13) = v17;
        }
        ++v4;
        v14 -= 2;
      }
      while (v14);
      goto LABEL_50;
    }
  }
  unsigned __int16 v15 = -1;
LABEL_50:
  *((_WORD *)this + 16) = v15;
  *((_WORD *)this + 17) = v13;
  return 1;
}

OTL::Coverage *OTL::LookupWithCoverage::GetCoverage@<X0>(OTL::Coverage *this@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if ((unint64_t)this + 4 <= a2) {
    return OTL::Coverage::Coverage((OTL::Coverage *)a3, (unsigned __int16 *)((char *)this + (bswap32(*((unsigned __int16 *)this + 1)) >> 16)), a2, 0);
  }
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = OTL::Coverage::SearchUnknown;
  *(void *)(a3 + 24) = 0;
  *(_DWORD *)(a3 + 32) = 0xFFFF;
  return this;
}

OTL::Coverage *OTL::GSUB::GetCoverageForSubtable@<X0>(OTL::LookupWithCoverage *this@<X3>, OTL::Coverage *result@<X0>, unint64_t a3@<X1>, int a4@<W2>, uint64_t a5@<X8>)
{
  if (a3 > (unint64_t)this || (unint64_t v5 = *((void *)result + 5), (unint64_t)this + 2 > v5))
  {
LABEL_17:
    *(void *)a5 = 0;
    *(void *)(a5 + 8) = 0;
    *(void *)(a5 + 16) = OTL::Coverage::SearchUnknown;
    *(void *)(a5 + 24) = 0;
    *(_DWORD *)(a5 + 32) = 0xFFFF;
  }
  else
  {
    switch(a4)
    {
      case 1:
      case 2:
      case 3:
      case 4:
      case 8:
        return OTL::LookupWithCoverage::GetCoverage(this, v5, a5);
      case 5:
        unsigned int v6 = bswap32(*(unsigned __int16 *)this) >> 16;
        if (v6 - 1 < 2) {
          return OTL::LookupWithCoverage::GetCoverage(this, v5, a5);
        }
        if (v6 != 3 || (unint64_t)this + 8 > v5) {
          goto LABEL_17;
        }
        unsigned int v8 = *((unsigned __int16 *)this + 3);
        goto LABEL_23;
      case 6:
        unsigned int v9 = bswap32(*(unsigned __int16 *)this) >> 16;
        if (v9 - 1 < 2) {
          return OTL::LookupWithCoverage::GetCoverage(this, v5, a5);
        }
        BOOL v10 = v9 == 3;
        BOOL v11 = (char *)this + 4;
        if (!v10 || (unint64_t)v11 > v5) {
          goto LABEL_17;
        }
        unsigned int v13 = &v11[2 * (bswap32(*((unsigned __int16 *)this + 1)) >> 16)];
        uint64_t v14 = (unsigned __int16 *)(v13 + 2);
        unint64_t v15 = (unint64_t)(v13 + 4);
        if (v14 < (unsigned __int16 *)this || v15 > v5) {
          goto LABEL_17;
        }
        unsigned int v8 = *v14;
LABEL_23:
        CFNumberRef result = OTL::Coverage::Coverage((OTL::Coverage *)a5, (unsigned __int16 *)((char *)this + (bswap32(v8) >> 16)), v5, 0);
        break;
      default:
        goto LABEL_17;
    }
  }
  return result;
}

OTL::Coverage *OTL::GPOS::GetCoverageForSubtable@<X0>(OTL::LookupWithCoverage *this@<X3>, OTL::Coverage *result@<X0>, unint64_t a3@<X1>, int a4@<W2>, uint64_t a5@<X8>)
{
  if (a3 > (unint64_t)this) {
    goto LABEL_19;
  }
  unint64_t v5 = *((void *)result + 5);
  if ((unint64_t)this + 2 > v5) {
    goto LABEL_19;
  }
  if ((a4 - 1) < 6) {
    return OTL::LookupWithCoverage::GetCoverage(this, v5, a5);
  }
  if (a4 == 7)
  {
    unsigned int v9 = bswap32(*(unsigned __int16 *)this) >> 16;
    if (v9 - 1 < 2) {
      return OTL::LookupWithCoverage::GetCoverage(this, v5, a5);
    }
    if (v9 == 3 && (unint64_t)this + 8 <= v5)
    {
      unsigned int v8 = *((unsigned __int16 *)this + 3);
      return OTL::Coverage::Coverage((OTL::Coverage *)a5, (unsigned __int16 *)((char *)this + (bswap32(v8) >> 16)), v5, 0);
    }
LABEL_19:
    *(void *)a5 = 0;
    *(void *)(a5 + 8) = 0;
    *(void *)(a5 + 16) = OTL::Coverage::SearchUnknown;
    *(void *)(a5 + 24) = 0;
    *(_DWORD *)(a5 + 32) = 0xFFFF;
    return result;
  }
  if (a4 != 8) {
    goto LABEL_19;
  }
  unsigned int v6 = bswap32(*(unsigned __int16 *)this) >> 16;
  if (v6 - 1 < 2) {
    return OTL::LookupWithCoverage::GetCoverage(this, v5, a5);
  }
  if (v6 != 3) {
    goto LABEL_19;
  }
  if ((unint64_t)this + 4 > v5) {
    goto LABEL_19;
  }
  uint64_t v7 = (char *)this + 2 * (bswap32(*((unsigned __int16 *)this + 1)) >> 16) + 4;
  if (v7 + 2 < (char *)this || (unint64_t)(v7 + 4) > v5) {
    goto LABEL_19;
  }
  unsigned int v8 = *((unsigned __int16 *)v7 + 1);
  return OTL::Coverage::Coverage((OTL::Coverage *)a5, (unsigned __int16 *)((char *)this + (bswap32(v8) >> 16)), v5, 0);
}

void *OTL::Lookup::PopulateIgnoreSet(OTL::Lookup *this, const OTL::GDEF *a2)
{
  v8[4] = *MEMORY[0x1E4F143B8];
  CFNumberRef result = operator new(0x2000uLL, MEMORY[0x1E4FBA2D0]);
  uint64_t v5 = *((void *)this + 3);
  *((void *)this + 3) = result;
  if (v5)
  {
    MEMORY[0x1853275C0](v5, 0x1000C401B2BBF36);
    CFNumberRef result = (void *)*((void *)this + 3);
  }
  if (result)
  {
    bzero(result, 0x2000uLL);
    uint64_t v6 = *((void *)this + 3);
    uint64_t v7 = *(void *)this;
    v8[0] = &unk_1ED061358;
    v8[1] = v6;
    v8[3] = v8;
    OTL::GDEF::IterateGlyphsIgnoredByLookupTable(a2, v7, (uint64_t)v8);
    return std::__function::__value_func<void ()(unsigned short)>::~__value_func[abi:nn180100](v8);
  }
  return result;
}

OTL::Coverage *OTL::GDEF::IterateGlyphsIgnoredByLookupTable(OTL::Coverage *result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  v11[4] = *MEMORY[0x1E4F143B8];
  unsigned int v6 = bswap32(*(unsigned __int16 *)(a2 + 2)) >> 16;
  if ((v6 & 0xE) != 0)
  {
    v11[0] = &unk_1ED061820;
    v11[1] = a3;
    v11[3] = v11;
    OTL::GDEF::IterateGlyphsWithClassMask(result, v6 & 0xE, (uint64_t)v11);
    CFNumberRef result = (OTL::Coverage *)std::__function::__value_func<void ()(unsigned short)>::~__value_func[abi:nn180100](v11);
  }
  if ((v6 & 8) == 0)
  {
    if ((v6 & 0x10) != 0)
    {
      unsigned int v8 = bswap32(*(unsigned __int16 *)(a2 + 2 * (bswap32(*(unsigned __int16 *)(a2 + 4)) >> 16) + 6)) >> 16;
      uint64_t v7 = v10;
      v10[0] = &unk_1ED061790;
      v10[1] = a3;
      v10[3] = v10;
      OTL::GDEF::IterateMarkGlyphsNotInSet(v5, v8, (uint64_t)v10);
    }
    else
    {
      if (v6 < 0x100) {
        return result;
      }
      uint64_t v7 = v9;
      v9[0] = &unk_1ED0617D8;
      v9[1] = a3;
      id v9[3] = v9;
      OTL::GDEF::IterateMarkGlyphsNotOfAttachmentType(v5, v6 >> 8, (uint64_t)v9);
    }
    return (OTL::Coverage *)std::__function::__value_func<void ()(unsigned short)>::~__value_func[abi:nn180100](v7);
  }
  return result;
}

void *std::__function::__value_func<void ()(unsigned short)>::~__value_func[abi:nn180100](void *a1)
{
  unint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *OTL::GDEF::IterateGlyphsWithClassMask(void *result, int a2, uint64_t a3)
{
  void v9[4] = *MEMORY[0x1E4F143B8];
  unsigned int v3 = (void *)result[2];
  if (v3)
  {
    std::__function::__value_func<void ()(unsigned short)>::__value_func[abi:nn180100]((uint64_t)v7, a3);
    unint64_t v4 = operator new(0x30uLL);
    uint64_t v5 = v4;
    *(void *)unint64_t v4 = &unk_1ED061748;
    v4[2] = a2;
    if (v8)
    {
      if (v8 == v7)
      {
        *((void *)v4 + 5) = v4 + 4;
        (*(void (**)(void *))(v7[0] + 24))(v7);
      }
      else
      {
        *((void *)v4 + 5) = v8;
        unsigned int v8 = 0;
      }
    }
    else
    {
      *((void *)v4 + 5) = 0;
    }
    id v9[3] = v5;
    OTL::ClassDefTable::Iterate(v3, (uint64_t)v9);
    std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100](v9);
    return std::__function::__value_func<void ()(unsigned short)>::~__value_func[abi:nn180100](v7);
  }
  return result;
}

CGFloat CTFontGetCapHeight(CTFontRef font)
{
  if (!font) {
    return 0.0;
  }
  uint64_t v1 = (int *)*((void *)font + 5);
  if (v1[12]) {
    inited = v1 + 12;
  }
  else {
    inited = TFont::InitStrikeMetrics((TFont *)v1);
  }
  return *((double *)inited + 4);
}

uint64_t CTFontGetUIFontDesign(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(void *)(*(void *)(a1 + 40) + 400)) != 0) {
    return (*(uint64_t (**)(void))(*(void *)v1 + 536))();
  }
  else {
    return 0;
  }
}

unsigned __int16 *std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned short,unsigned short> *>(unsigned __int16 *a1, unsigned __int16 *a2, unsigned __int16 *a3, unsigned __int16 *a4, unsigned __int16 *a5)
{
  CFNumberRef result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned short,unsigned short> *>(a1, a2, a3, a4);
  unsigned int v11 = *a5;
  unsigned int v12 = *a4;
  char v13 = -1;
  if (v11 >= v12) {
    char v13 = 1;
  }
  if (v11 == v12)
  {
    unsigned int v14 = a5[1];
    unsigned int v15 = a4[1];
    BOOL v16 = v14 >= v15;
    BOOL v17 = v14 == v15;
    char v13 = -1;
    if (v16) {
      char v13 = 1;
    }
    if (v17) {
      char v13 = 0;
    }
  }
  if (v13 < 0)
  {
    *a4 = v11;
    *a5 = v12;
    unsigned __int16 v18 = a4[1];
    a4[1] = a5[1];
    a5[1] = v18;
    unsigned int v19 = *a4;
    unsigned int v20 = *a3;
    char v21 = -1;
    if (v19 >= v20) {
      char v21 = 1;
    }
    if (v19 == v20)
    {
      unsigned int v22 = a4[1];
      unsigned int v23 = a3[1];
      BOOL v16 = v22 >= v23;
      BOOL v24 = v22 == v23;
      char v21 = -1;
      if (v16) {
        char v21 = 1;
      }
      if (v24) {
        char v21 = 0;
      }
    }
    if (v21 < 0)
    {
      *a3 = v19;
      *a4 = v20;
      unsigned __int16 v25 = a3[1];
      a3[1] = a4[1];
      a4[1] = v25;
      unsigned int v26 = *a3;
      unsigned int v27 = *a2;
      char v28 = -1;
      if (v26 >= v27) {
        char v28 = 1;
      }
      if (v26 == v27)
      {
        unsigned int v29 = a3[1];
        unsigned int v30 = a2[1];
        BOOL v16 = v29 >= v30;
        BOOL v31 = v29 == v30;
        char v28 = -1;
        if (v16) {
          char v28 = 1;
        }
        if (v31) {
          char v28 = 0;
        }
      }
      if (v28 < 0)
      {
        *a2 = v26;
        *a3 = v27;
        unsigned __int16 v32 = a2[1];
        a2[1] = a3[1];
        a3[1] = v32;
        unsigned int v33 = *a2;
        unsigned int v34 = *a1;
        char v35 = -1;
        if (v33 >= v34) {
          char v35 = 1;
        }
        if (v33 == v34)
        {
          unsigned int v36 = a2[1];
          unsigned int v37 = a1[1];
          BOOL v16 = v36 >= v37;
          BOOL v38 = v36 == v37;
          char v35 = -1;
          if (v16) {
            char v35 = 1;
          }
          if (v38) {
            char v35 = 0;
          }
        }
        if (v35 < 0)
        {
          *a1 = v33;
          *a2 = v34;
          unsigned __int16 v39 = a1[1];
          a1[1] = a2[1];
          a2[1] = v39;
        }
      }
    }
  }
  return result;
}

unsigned __int16 *std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned short,unsigned short> *>(unsigned __int16 *a1, unsigned __int16 *a2, unsigned __int16 *a3, unsigned __int16 *a4)
{
  CFNumberRef result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned short,unsigned short> *>(a1, a2, a3);
  unsigned int v9 = *a4;
  unsigned int v10 = *a3;
  char v11 = -1;
  if (v9 >= v10) {
    char v11 = 1;
  }
  if (v9 == v10)
  {
    unsigned int v12 = a4[1];
    unsigned int v13 = a3[1];
    BOOL v14 = v12 >= v13;
    BOOL v15 = v12 == v13;
    char v11 = -1;
    if (v14) {
      char v11 = 1;
    }
    if (v15) {
      char v11 = 0;
    }
  }
  if (v11 < 0)
  {
    *a3 = v9;
    *a4 = v10;
    unsigned __int16 v16 = a3[1];
    a3[1] = a4[1];
    a4[1] = v16;
    unsigned int v17 = *a3;
    unsigned int v18 = *a2;
    char v19 = -1;
    if (v17 >= v18) {
      char v19 = 1;
    }
    if (v17 == v18)
    {
      unsigned int v20 = a3[1];
      unsigned int v21 = a2[1];
      BOOL v14 = v20 >= v21;
      BOOL v22 = v20 == v21;
      char v19 = -1;
      if (v14) {
        char v19 = 1;
      }
      if (v22) {
        char v19 = 0;
      }
    }
    if (v19 < 0)
    {
      *a2 = v17;
      *a3 = v18;
      unsigned __int16 v23 = a2[1];
      a2[1] = a3[1];
      a3[1] = v23;
      unsigned int v24 = *a2;
      unsigned int v25 = *a1;
      char v26 = -1;
      if (v24 >= v25) {
        char v26 = 1;
      }
      if (v24 == v25)
      {
        unsigned int v27 = a2[1];
        unsigned int v28 = a1[1];
        BOOL v14 = v27 >= v28;
        BOOL v29 = v27 == v28;
        char v26 = -1;
        if (v14) {
          char v26 = 1;
        }
        if (v29) {
          char v26 = 0;
        }
      }
      if (v26 < 0)
      {
        *a1 = v24;
        *a2 = v25;
        unsigned __int16 v30 = a1[1];
        a1[1] = a2[1];
        a2[1] = v30;
      }
    }
  }
  return result;
}

unsigned __int16 *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned short,unsigned short> *>(unsigned __int16 *result, unsigned __int16 *a2, unsigned __int16 *a3)
{
  unsigned int v3 = *a2;
  unsigned int v4 = *result;
  if (v3 >= v4) {
    char v5 = 1;
  }
  else {
    char v5 = -1;
  }
  if (v3 == v4)
  {
    unsigned int v6 = a2[1];
    unsigned int v7 = result[1];
    BOOL v8 = v6 >= v7;
    BOOL v9 = v6 == v7;
    char v10 = -1;
    if (v8) {
      char v10 = 1;
    }
    if (v9) {
      char v5 = 0;
    }
    else {
      char v5 = v10;
    }
  }
  unsigned int v11 = *a3;
  char v12 = -1;
  if (v11 >= v3) {
    char v12 = 1;
  }
  if (v5 < 0)
  {
    if (v11 == v3)
    {
      unsigned int v25 = a3[1];
      unsigned int v26 = a2[1];
      BOOL v8 = v25 >= v26;
      BOOL v27 = v25 == v26;
      char v12 = -1;
      if (v8) {
        char v12 = 1;
      }
      if (v27) {
        char v12 = 0;
      }
    }
    if (v12 < 0)
    {
      *result++ = v11;
      *a3 = v4;
      char v35 = a3 + 1;
    }
    else
    {
      *CFNumberRef result = v3;
      *a2 = v4;
      unsigned int v28 = result[1];
      result[1] = a2[1];
      a2[1] = v28;
      unsigned int v29 = *a3;
      unsigned int v30 = *a2;
      char v31 = -1;
      if (v29 >= v30) {
        char v31 = 1;
      }
      if (v29 == v30)
      {
        unsigned int v32 = a3[1];
        BOOL v8 = v32 >= v28;
        BOOL v33 = v32 == v28;
        char v34 = -1;
        if (v8) {
          char v34 = 1;
        }
        if (v33) {
          char v31 = 0;
        }
        else {
          char v31 = v34;
        }
      }
      if ((v31 & 0x80) == 0) {
        return result;
      }
      *a2 = v29;
      *a3 = v30;
      char v35 = a3 + 1;
      CFNumberRef result = a2 + 1;
    }
    unsigned int v17 = v35;
    goto LABEL_52;
  }
  if (v11 == v3)
  {
    unsigned int v13 = a3[1];
    unsigned int v14 = a2[1];
    BOOL v8 = v13 >= v14;
    BOOL v15 = v13 == v14;
    char v16 = -1;
    if (v8) {
      char v16 = 1;
    }
    if (v15) {
      char v12 = 0;
    }
    else {
      char v12 = v16;
    }
  }
  if (v12 < 0)
  {
    *a2 = v11;
    *a3 = v3;
    unsigned int v17 = a2 + 1;
    unsigned __int16 v18 = a2[1];
    a2[1] = a3[1];
    a3[1] = v18;
    unsigned int v19 = *a2;
    unsigned int v20 = *result;
    char v21 = -1;
    if (v19 >= v20) {
      char v21 = 1;
    }
    if (v19 == v20)
    {
      unsigned int v22 = *v17;
      unsigned int v23 = result[1];
      BOOL v8 = v22 >= v23;
      BOOL v24 = v22 == v23;
      char v21 = -1;
      if (v8) {
        char v21 = 1;
      }
      if (v24) {
        char v21 = 0;
      }
    }
    if (v21 < 0)
    {
      *result++ = v19;
      *a2 = v20;
LABEL_52:
      unsigned __int16 v36 = *result;
      *CFNumberRef result = *v17;
      *unsigned int v17 = v36;
    }
  }
  return result;
}

CFIndex TCharStream::FindLineBreak(TCharStream *this, CFRange a2, int a3, __CFString *a4)
{
  CFIndex length = a2.length;
  if (a2.length)
  {
    CFIndex location = a2.location;
    memset(&ut, 0, sizeof(ut));
    ut.magic = 878368812;
    ut.sizeOfStruct = 144;
    if ((**(uint64_t (***)(void))this)())
    {
      CFIndex v9 = location + length;
      if (a3)
      {
        utext_setNativeIndex(&ut, v9 - 1);
      }
      else
      {
        CFIndex v11 = *((void *)this + 2);
        if (v9 >= v11)
        {
          CFIndex length = v11 - location;
          goto LABEL_18;
        }
        utext_setNativeIndex(&ut, location + length);
        unsigned int v12 = utext_next32(&ut);
        int isWhitespace = u_isWhitespace(v12);
        NativeIndex = (TCharStream *)utext_getNativeIndex(&ut);
        if (v12 >> 1 != 4103 && !isWhitespace)
        {
          if (TCharStream::CopyBreakIterator(a4, v14))
          {
            ubrk_setUText();
            CFIndex v15 = (int)ubrk_preceding();
            if (a4) {
              ubrk_close();
            }
            if (location >= v15)
            {
              if (v9 >= *((void *)this + 2)) {
                goto LABEL_18;
              }
              uint64_t v16 = (*(uint64_t (**)(TCharStream *, CFIndex, uint64_t))(*(void *)this + 40))(this, location + length, 2);
              CFIndex v15 = v16;
              if (v16 <= location)
              {
                CFIndex length = v17 - location + v16;
                goto LABEL_18;
              }
            }
            CFIndex length = v15 - location;
          }
LABEL_18:
          utext_close(&ut);
          return length;
        }
      }
      CFIndex length = TCharStream::FindLineBreakInWhitespace(NativeIndex, &ut) - location;
      goto LABEL_18;
    }
  }
  return length;
}

uint64_t TCharStreamCFString::OpenUText(atomic_ullong *this, UText *a2)
{
  unint64_t explicit = atomic_load_explicit(this + 4, memory_order_acquire);
  return MEMORY[0x1F40D8658](a2, explicit);
}

uint64_t TCharStream::CopyBreakIterator(id this, const __CFString *a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (this || (Table = GetTable()) == 0 || (uint64_t v6 = Table[2]) == 0)
  {
    id v8 = this;
    if (!atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire))
    {
      unsigned int v3 = (__CFString *)CFPreferencesCopyValue(@"AppleTextBreakLocale", (CFStringRef)*MEMORY[0x1E4F1D3B8], (CFStringRef)*MEMORY[0x1E4F1D3F0], (CFStringRef)*MEMORY[0x1E4F1D3C8]);
      if (v3)
      {
        unsigned int v4 = (void *)atomic_exchange((atomic_ullong *volatile)&v8, (unint64_t)CFLocaleCreateCanonicalLocaleIdentifierFromString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v3));
      }
      else
      {
        CopyPreferredLanguage((atomic_ullong *)v9);

        unsigned int v4 = *(void **)v9;
      }
    }
    memset(v23, 0, sizeof(v23));
    long long v22 = 0u;
    long long v21 = 0u;
    long long v20 = 0u;
    long long v19 = 0u;
    long long v18 = 0u;
    long long v17 = 0u;
    long long v16 = 0u;
    long long v15 = 0u;
    long long v14 = 0u;
    long long v13 = 0u;
    long long v12 = 0u;
    long long v11 = 0u;
    long long v10 = 0u;
    *(_OWORD *)&void v9[5] = 0u;
    qmemcpy(v9, "en_US", 5);
    if (atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire)) {
      CFStringGetCString((CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire), v9, 255, 0x600u);
    }
    uint64_t v6 = ubrk_open();
    if (!this) {
      SetThreadSpecificData(1, v6, MEMORY[0x1E4FBA5E8]);
    }
  }
  return v6;
}

int64_t TCharStream::FindLineBreakInWhitespace(TCharStream *this, UText *ut)
{
  while (1)
  {
    int v3 = utext_next32(ut);
    unsigned int v4 = v3;
    if (v3 > 12) {
      break;
    }
    if ((v3 - 10) < 3 || v3 == -1) {
      goto LABEL_13;
    }
LABEL_8:
    int v5 = u_charType(v3);
    if (v4 >> 1 != 4103 && v5 != 12) {
      goto LABEL_16;
    }
  }
  if ((v3 - 8232) < 2) {
    goto LABEL_13;
  }
  if (v3 != 13)
  {
    if (v3 == 133) {
      goto LABEL_13;
    }
    goto LABEL_8;
  }
  UChar32 v6 = utext_next32(ut);
  if (v6 == 10 || v6 == -1)
  {
LABEL_13:
    return utext_getNativeIndex(ut);
  }
LABEL_16:

  return utext_getPreviousNativeIndex(ut);
}

double CTSwapLineBreakEpsilon(double a1)
{
  double v1 = 0.0002;
  if (a1 != 0.0002) {
    operator new();
  }
  unint64_t v2 = SetThreadSpecificData(4, 0, (uint64_t (*)(void *))PointerToEpsilonDestructor);
  if (v2)
  {
    double v1 = *(double *)v2;
    MEMORY[0x1853275C0]();
  }
  return v1;
}

void TTypesetter::RelayoutRun(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  if (!*(void *)(a1 + 16))
  {
    uint64_t v7 = *(void *)(a2 + 40);
    uint64_t v8 = *(void *)(v7 + 8);
    CFIndex v9 = *(void *)(v7 + 16);
    id v38 = (id)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(id *__return_ptr))(**(void **)(a1 + 8) + 16))(&v38);
    if (!atomic_load_explicit((atomic_ullong *volatile)&v38, memory_order_acquire))
    {
LABEL_19:

      return;
    }
    long long v21 = a3;
    uint64_t v22 = a4;
    CFStringRef explicit = (const __CFString *)atomic_load_explicit((atomic_ullong *volatile)&v38, memory_order_acquire);
    long long v11 = (std::__shared_weak_count *)operator new(0x48uLL);
    v11->__shared_weak_owners_ = 0;
    v11->__shared_owners_ = 0;
    v11->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ED062278;
    TCharStreamCFString::TCharStreamCFString((TCharStreamCFString *)&v11[1], explicit, 0);
    v42[0] = xmmword_184B88A60;
    memset(&v42[1], 170, 32);
    long long v43 = unk_184B88A90;
    *(_OWORD *)&v41[96] = xmmword_184B88A40;
    *(_OWORD *)&v41[112] = unk_184B88A50;
    memset(v41, 170, 96);
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    *(void *)__int16 v41 = v11 + 1;
    *(void *)&v41[8] = v11;
    memset(&v41[16], 0, 24);
    *(void *)&v41[64] = &v41[40];
    BYTE8(v43) = 0;
    memset(&v41[72], 0, 56);
    *(_OWORD *)((char *)v42 + 8) = 0u;
    *(void *)((char *)&v42[1] + 5) = 0;
    v42[2] = 0uLL;
    LOBYTE(v43) = 0;
    uint64_t v45 = 0;
    uint64_t v46 = 0;
    uint64_t v44 = 0;
    *(void *)&v42[0] = 0xFFEFFFFFFFFFFFFFLL;
    if (v9 <= *(void *)(v7 + 208)) {
      CFIndex v12 = *(void *)(v7 + 208);
    }
    else {
      CFIndex v12 = v9;
    }
    long long v13 = +[_CTNativeGlyphStorage newWithCount:v9 capacity:v12];
    memset(v36, 170, sizeof(v36));
    unint64_t v37 = 0xAAAAAAAAFFFFFFFFLL;
    v24[0] = v13;
    v24[1] = (_CTGlyphStorage *)&v11[1];
    long long v25 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    *(void *)&long long v35 = v11[1].__shared_weak_owners_;
    v36[0] = 0;
    v36[1] = v41;
    memset(&v36[2], 0, 32);
    LODWORD(v37) = 1065353216;
    int v14 = TGlyphEncoder::EncodeChars(v24, 0, v9, v7 + 40, 1);
    char v23 = v14;

    *(void *)&v41[72] = v8;
    *(void *)&v41[80] = v9;
    long long v16 = *(uint64_t **)&v41[24];
    long long v15 = *(uint64_t **)&v41[16];
    while (v15 != v16)
    {
      uint64_t v17 = *v15++;
      uint64_t v18 = *(void *)(v17 + 48);
      *(void *)(v18 + 8) += v8;
      objc_msgSend(*(id *)(v18 + 216), "puntStringIndicesInRange:by:", *(void *)(v18 + 200), *(void *)(v18 + 208), v8);
    }
    if (*(unsigned char *)(v7 + 224))
    {
      char v23 = v14 | 2;
      memcpy(__dst, &unk_184B88750, sizeof(__dst));
      TRunGlue::TRunGlue((TRunGlue *)__dst, (TLine *)v41);
    }
    else
    {
      memcpy(__dst, &unk_184B88750, sizeof(__dst));
      TRunGlue::TRunGlue((TRunGlue *)__dst, (TLine *)v41);
      if (!v14)
      {
        char v20 = 0;
        char v19 = 0;
        goto LABEL_16;
      }
    }
    char v19 = TTypesetter::FinishEncoding(a1, (TShapingEngine *)__dst, (const TCharStream *)&v23);
    char v20 = v23;
LABEL_16:
    TTypesetter::FinishLayout(a1, __dst, (const TCharStream *)v20, v19);
    if (*(void *)&v41[24] != *(void *)&v41[16]) {
      TLine::ReplaceRun(v21, v22, (uint64_t)v41);
    }
    std::__function::__value_func<BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::~__value_func[abi:nn180100](&__dst[70]);
    unsigned __int16 v39 = &__dst[46];
    std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v39);
    unsigned __int16 v39 = &__dst[26];
    std::vector<unsigned char,TInlineBufferAllocator<unsigned char,128ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v39);
    unsigned __int16 v39 = &__dst[7];
    std::vector<std::pair<UScriptCode,long>,TInlineBufferAllocator<std::pair<UScriptCode,long>,1ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v39);
    std::__hash_table<EncoderAttempt,std::hash<EncoderAttempt>,std::equal_to<EncoderAttempt>,std::allocator<EncoderAttempt>>::~__hash_table((uint64_t)&v36[2]);
    TLine::~TLine((TLine *)v41);
    std::__shared_weak_count::__release_shared[abi:nn180100](v11);
    goto LABEL_19;
  }

  TTypesetter::RelayoutRunUsingCallback(a1, a2, a3, a4);
}

CTLineRef CTLineCreateTruncatedLine(CTLineRef line, double width, CTLineTruncationType truncationType, CTLineRef truncationToken)
{
  if (!truncationToken) {
    operator new();
  }
  if (*(double *)(*((void *)truncationToken + 5) + 104) <= width) {
    TruncatedLine = CreateTruncatedLine((uint64_t **)line, truncationType, truncationToken, 0, width);
  }
  else {
    TruncatedLine = 0;
  }

  return (CTLineRef)TruncatedLine;
}

uint64_t **CreateTruncatedLine(uint64_t **a1, int a2, void *a3, const void *a4, double a5)
{
  if (!a1 || a5 <= 0.0) {
    return 0;
  }
  long long v10 = a1[5];
  Table = GetTable();
  double v12 = 0.0002;
  if (Table)
  {
    long long v13 = (double *)*((void *)Table + 8);
    if (v13) {
      double v12 = *v13;
    }
  }
  if (v12 + a5 < *((double *)v10 + 13))
  {
    id v20 = (id)0xAAAAAAAAAAAAAAAALL;
    TCFBase_NEW<CTLine,std::shared_ptr<TCharStream const> const&>(a1[5], &v20);
    if (atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire))
    {
      uint64_t v14 = *(void *)(atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire) + 40);
      uint64_t v17 = -1;
      *(void *)&long long v15 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long v18 = v15;
      long long v19 = v15;
      TTruncator::TTruncator((uint64_t)&v17, (uint64_t)a1, v14);
      TLine::SetTruncationInfo(v14, a2, a3, a4);
    }

    return 0;
  }

  return a1;
}

void TLine::SetTruncationInfo(int a1, int a2, id a3, const void *a4)
{
  id v6 = a3;
  id v5 = _Block_copy(a4);
  operator new();
}

uint64_t TTruncator::TTruncator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 16) = a2;
  uint64_t v4 = *(void *)(a2 + 40);
  *(void *)(a1 + 24) = v4;
  *(void *)(a1 + 32) = a3;
  uint64_t v5 = *(void *)(v4 + 80);
  *(void *)(a1 + 8) = *(void *)(v4 + 72) + v5 - 1;
  TLine::GetTrailingWhitespace(v4, v8);
  double v6 = v8[0];
  *(double *)a1 = v8[2];
  if (v6 != 0.0 && *(void *)&v6 != v5) {
    *(void *)(a1 + 8) -= *(void *)&v6;
  }
  return a1;
}

void TTruncator::Truncate(uint64_t **this, unsigned __int32 a2, __CTLine *a3, uint64_t a4, double a5)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (*((double *)this[3] + 13) <= *(double *)this + a5)
  {
    TTruncator::TruncateEndWhitespace((TTruncator *)this, a5);
  }
  else
  {
    *(_OWORD *)&v12[96] = xmmword_184BA8508;
    *(_OWORD *)&v12[112] = unk_184BA8518;
    long long v14 = unk_184BA8558;
    *(_OWORD *)long long v13 = xmmword_184BA8528;
    memset(&v13[16], 170, 32);
    memset(v12, 170, 96);
    uint64_t v7 = this[4];
    uint64_t v9 = *v7;
    uint64_t v8 = v7[1];
    if (v8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    }
    *(void *)double v12 = v9;
    *(void *)&v12[8] = v8;
    memset(&v12[16], 0, 24);
    *(void *)&v12[64] = &v12[40];
    BYTE8(v14) = 0;
    memset(&v12[72], 0, 56);
    memset(&v13[8], 0, 21);
    *(_OWORD *)&v13[32] = 0uLL;
    LOBYTE(v14) = 0;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    uint64_t v15 = 0;
    *(void *)long long v13 = 0xFFEFFFFFFFFFFFFFLL;
    if (a3) {
      TTruncator::TruncateWithToken((TTruncator *)this, a5, (int64x2_t *)v12, (CTLineTruncationType)a2, a3);
    }
    else {
      TTruncator::TruncateWithTokenHandler((TTruncator *)this, (uint64_t)v12, a2, a4, a5);
    }
    if (a2 == 2) {
      TTruncator::AppendLine((unint64_t)this, (const TLine *)v12);
    }
    TTruncator::HandleLeveledRuns((TTruncator *)this, v10, v11);
    TLine::~TLine((TLine *)v12);
  }
}

uint64_t TTruncator::TruncateWithTokenHandler(TTruncator *this, uint64_t a2, int a3, uint64_t a4, double a5)
{
  uint64_t v10 = *((void *)this + 3);
  CFIndex v11 = *(void *)(v10 + 72);
  uint64_t v12 = *(void *)(v10 + 80);
  uint64_t v13 = v12 + v11;
  unsigned __int8 v48 = -86;
  double v14 = a5 * 0.5;
  if (a3 == 2) {
    double v15 = v14;
  }
  else {
    double v15 = a5;
  }
  double v16 = v15 + *(double *)this;
  unsigned int v43 = a3 - 1;
  CFIndex v17 = v11;
  uint64_t v18 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v19 = 0xAAAAAAAAAAAAAAAALL;
  while (1)
  {
    id v20 = (int64x2_t *)*((void *)this + 4);
    v20[4].i64[1] = v11;
    v20[5].i64[0] = v12;
    if (v43 >= 2)
    {
      if (a3) {
        goto LABEL_10;
      }
      CFIndex started = TTruncator::TruncateStartChars(this, v17, v15 + *(double *)this, v20, (BOOL *)&v48);
    }
    else
    {
      CFIndex started = TTruncator::TruncateEndChars(this, v13, v15, (TLine *)v20, (BOOL *)&v48);
    }
    uint64_t v18 = started;
    unint64_t v19 = v22;
LABEL_10:
    if (TTruncator::NoRunAdded((uint64_t)this, a4, 0, -1, a5)) {
      return v18;
    }
    if (a3 == 2)
    {
      CFIndex v23 = TTruncator::TruncateStartChars(this, v17, v16 + v15 - *(double *)(*((void *)this + 4) + 104), (int64x2_t *)a2, (BOOL *)&v48);
      uint64_t v25 = v24;
      if (TTruncator::NoRunAdded((uint64_t)this, a4, a2, v18, a5)) {
        return v18;
      }
      unint64_t v19 = v25 - v18 + v23;
    }
    uint64_t v46 = v18;
    unint64_t v47 = v19;
    id v45 = (id)0xAAAAAAAAAAAAAAAALL;
    TTruncator::CreateToken((uint64_t)this, &v46, a4, (unint64_t *)&v45);
    if (!atomic_load_explicit((atomic_ullong *volatile)&v45, memory_order_acquire)) {
      goto LABEL_45;
    }
    uint64_t v26 = *(void *)(atomic_load_explicit((atomic_ullong *volatile)&v45, memory_order_acquire) + 40);
    long long v27 = *(double **)(v26 + 312);
    if (!v27) {
      long long v27 = (double *)MEMORY[0x1E4F1DB30];
    }
    double v28 = *(double *)(v26 + 192) + *v27;
    if (a3 == 1)
    {
      TRun::GetTrailingWhitespace(v26, v44);
      double v28 = v28 - v44[2];
    }
    if (v28 == 0.0) {
      goto LABEL_45;
    }
    double v29 = *(double *)(*((void *)this + 4) + 104);
    if (a3 == 2) {
      double v30 = *(double *)(a2 + 104);
    }
    else {
      double v30 = -0.0;
    }
    Table = GetTable();
    double v32 = 0.0002;
    if (Table)
    {
      long long v33 = (double *)*((void *)Table + 8);
      double v32 = 0.0002;
      if (v33) {
        double v32 = *v33;
      }
    }
    double v34 = v29 + v30;
    if (v28 + v29 + v30 - a5 > v32)
    {
      double v35 = -v28;
      if (a3 == 2)
      {
        double v16 = v16 - v28 * (*(double *)(a2 + 104) / v34);
        double v36 = *(double *)(*((void *)this + 4) + 104) / v34;
        TLine::ClearLine((TLine *)a2);
      }
      else
      {
        double v36 = 1.0;
      }
      double v15 = v15 + v35 * v36;
      goto LABEL_36;
    }
    if (!a3)
    {
      CFIndex v17 = v47 + v46;
      if ((uint64_t)(v47 + v46) <= (uint64_t)(v19 + v18))
      {
        TLine::InsertRun(*((TLine **)this + 4), 0, (const TRun **)atomic_load_explicit((atomic_ullong *volatile)&v45, memory_order_acquire));
        goto LABEL_45;
      }
      goto LABEL_36;
    }
    if (a3 != 1) {
      break;
    }
    uint64_t v13 = v46;
    if (v46 >= v18) {
      goto LABEL_38;
    }
LABEL_36:
    TLine::ClearLine(*((TLine **)this + 4));

    uint64_t v37 = *((void *)this + 3);
    CFIndex v11 = *(void *)(v37 + 72);
    uint64_t v12 = *(void *)(v37 + 80);
  }
  if (a3 != 2) {
    goto LABEL_45;
  }
LABEL_38:
  unint64_t inserted = TLine::InsertPartialRun(*((TLine **)this + 4), (uint64_t)(*(void *)(*((void *)this + 4) + 24) - *(void *)(*((void *)this + 4) + 16)) >> 3, atomic_load_explicit((atomic_ullong *volatile)&v45, memory_order_acquire), *(void *)(v26 + 8), *(void *)(v26 + 16));
  uint64_t v39 = *(void *)(inserted + 48);
  char v40 = *(unsigned char *)(*(void *)(inserted + 40) + 224);
  if ((v40 & 1) == v48) {
    char v41 = *(unsigned char *)(*(void *)(inserted + 40) + 224);
  }
  else {
    char v41 = v40 + 1;
  }
  if (((*(unsigned __int8 *)(v39 + 224) ^ ((v41 & 1) == 0)) & 1) == 0) {
    TRun::ReverseGlyphs(*(void *)(inserted + 48));
  }
  *(unsigned char *)(v39 + 224) = v41;
LABEL_45:

  return v18;
}

CFIndex TTruncator::TruncateEndChars(TTruncator *this, uint64_t a2, double a3, TLine *a4, BOOL *a5)
{
  double v6 = this;
  uint64_t v7 = *((void *)this + 3);
  uint64_t v9 = *(void *)(v7 + 72);
  uint64_t v8 = *(void *)(v7 + 80);
  *a5 = (*(unsigned char *)(v7 + 152) & 8) != 0;
  CFIndex v10 = a2 - v9;
  uint64_t v63 = v8;
  uint64_t v64 = v9;
  if (a2 <= v9)
  {
    uint64_t RunWithCharIndex = 0;
    uint64_t v18 = v9;
    CFIndex v12 = v9;
  }
  else
  {
    CFIndex v12 = v9;
    while (1)
    {
      uint64_t RunWithCharIndex = TLine::FindRunWithCharIndex(*((TLine **)v6 + 3), v9, 1);
      double v14 = v6;
      uint64_t v15 = *(void *)(*(void *)(*((void *)v6 + 3) + 16) + 8 * RunWithCharIndex);
      uint64_t v16 = *(void *)(v15 + 40);
      uint64_t v17 = *(void *)(v16 + 16);
      uint64_t v18 = v17 + *(void *)(v16 + 8);
      if (v18 > a2) {
        break;
      }
      unint64_t v19 = *(double **)(v16 + 312);
      if (!v19) {
        unint64_t v19 = (double *)MEMORY[0x1E4F1DB30];
      }
      id v20 = *(uint64_t **)(v16 + 232);
      double v21 = 0.0;
      if (v20)
      {
        unint64_t v22 = ~*(void *)(v16 + 248) + v18 + *(void *)(v16 + 200);
        uint64_t v23 = *v20;
        if (v22 < (*(void *)(*(void *)(v16 + 232) + 8) - v23) >> 3) {
          double v21 = *(double *)(v23 + 8 * v22);
        }
      }
      double v24 = *(double *)(v16 + 192);
      double v25 = *v19;
      Table = GetTable();
      double v27 = 0.0002;
      if (Table)
      {
        double v28 = (double *)*((void *)Table + 8);
        double v27 = 0.0002;
        if (v28) {
          double v27 = *v28;
        }
      }
      if (v24 + v25 - v21 - a3 > v27)
      {
        *a5 = *(unsigned char *)(v16 + 224);
        break;
      }
      TLine::InsertPartialRun(a4, (uint64_t)(*((void *)a4 + 3) - *((void *)a4 + 2)) >> 3, v15, *(void *)(*(void *)(v15 + 40) + 8), *(void *)(*(void *)(v15 + 40) + 16));
      v12 += v17;
      v10 -= v17;
      double v29 = *(double **)(v16 + 312);
      if (!v29) {
        double v29 = (double *)MEMORY[0x1E4F1DB30];
      }
      a3 = a3 - (*(double *)(v16 + 192) + *v29);
      uint64_t v9 = v18;
      double v6 = v14;
      if (v18 >= a2) {
        goto LABEL_20;
      }
    }
    uint64_t v18 = v9;
    double v6 = v14;
  }
LABEL_20:
  uint64_t v30 = *(void *)(*(void *)(*((void *)v6 + 3) + 16) + 8 * RunWithCharIndex);
  v67.CFIndex location = v12;
  v67.CFIndex length = v10;
  uint64_t v31 = TRun::CountCharsInWidth(*(TRun **)(v30 + 40), v67, a3, 1);
  if (v31 < 1)
  {
    long long v33 = a4;
  }
  else
  {
    uint64_t v32 = v31;
    long long v33 = a4;
    if (TTruncator::AppendTruncatedRun((uint64_t)v6, (int64x2_t *)a4, v30, v18, v31, 1))
    {
      v12 += v32;
      v10 -= v32;
    }
  }
  uint64_t v34 = *((void *)v33 + 2);
  uint64_t v35 = *((void *)v33 + 3) - v34;
  if (v35 >= 1)
  {
    do
    {
      uint64_t v36 = ((unint64_t)v35 >> 3) - 1;
      uint64_t v37 = *(void **)(v34 + 8 * v36);
      uint64_t v38 = v37[5];
      TRun::GetTrailingWhitespace(v38, v66);
      uint64_t v39 = *(void *)&v66[0];
      if (*(uint64_t *)&v66[0] < 1) {
        break;
      }
      v12 -= *(void *)&v66[0];
      v10 += *(void *)&v66[0];
      uint64_t v40 = *(void *)(v38 + 8);
      uint64_t v41 = *(void *)(v38 + 16);
      CFTypeID v42 = v37;
      TLine::SimpleRunDelete(v33, v36);
      if (v41 - v39 >= 1)
      {
        if (TTruncator::AppendTruncatedRun((uint64_t)v6, (int64x2_t *)v33, (uint64_t)v37, v40, v41 - v39, 1))
        {
          *((void *)v33 + 10) -= v39;
          TLine::SyncWithRuns(v33);
        }

        break;
      }
      *((void *)v33 + 10) -= v39;
      TLine::SyncWithRuns(v33);

      uint64_t v34 = *((void *)v33 + 2);
      uint64_t v35 = *((void *)v33 + 3) - v34;
    }
    while (v35 > 0);
  }
  if (v10 >= 1 && (uint64_t)(*((void *)v33 + 3) - *((void *)v33 + 2)) >= 1)
  {
    uint64_t v43 = (*(uint64_t (**)(void, CFIndex, uint64_t))(***((void ***)v6 + 3) + 40))(**((void **)v6 + 3), v12, 2);
    uint64_t v45 = v43;
    uint64_t v46 = v43 + v44 >= v63 + v64 ? v63 + v64 : v43 + v44;
    if (v64 <= v43 && v43 < v63 + v64)
    {
      uint64_t v49 = v46 - v43;
    }
    else if (v43 <= v64 && v64 < v43 + v44)
    {
      uint64_t v49 = v46 - v64;
      uint64_t v45 = v64;
    }
    else
    {
      uint64_t v45 = 0;
      uint64_t v49 = 0;
    }
    if (v45 < v12)
    {
      uint64_t v50 = v45 + v49;
      do
      {
        uint64_t v51 = TLine::FindRunWithCharIndex(v33, v12 - 1, 1);
        uint64_t v52 = *(void *)(*(void *)(*((void *)v33 + 2) + 8 * v51) + 40);
        uint64_t v53 = *(void *)(v52 + 8);
        uint64_t v54 = *(void *)(v52 + 16);
        if (v50 >= v54 + v53) {
          uint64_t v55 = v54 + v53;
        }
        else {
          uint64_t v55 = v50;
        }
        BOOL v56 = v53 <= v45 && v45 < v54 + v53;
        uint64_t v57 = v45;
        if (!v56 && (v45 <= v53 ? (v58 = v53 < v50) : (v58 = 0), uint64_t v57 = v53, !v58) || (v59 = v55 - v57, v55 - v57 < 1))
        {
          TLine::SyncWithRuns(v33);
          return v45;
        }
        v12 -= v59;
        v10 += v59;
        TLine::DeleteRun(v33, v51);
      }
      while (*((void *)v33 + 3) != *((void *)v33 + 2) && v45 < v12);
      TLine::SyncWithRuns(v33);
      if (v54 - v59 >= 1)
      {
        uint64_t v60 = TLine::FindRunWithCharIndex(*((TLine **)v6 + 3), v53, 1);
        TTruncator::AppendTruncatedRun((uint64_t)v6, (int64x2_t *)v33, *(void *)(*(void *)(*((void *)v6 + 3) + 16) + 8 * v60), v53, v54 - v59, 1);
      }
    }
  }
  return v12;
}

uint64_t TRun::CountCharsInWidth(TRun *this, CFRange a2, double a3, int a4)
{
  CFIndex length = a2.length;
  CFIndex location = a2.location;
  Table = GetTable();
  double v10 = 0.0002;
  if (Table)
  {
    CFIndex v11 = (double *)*((void *)Table + 8);
    if (v11) {
      double v10 = *v11;
    }
  }
  CFIndex v12 = *((void *)this + 1);
  CFIndex v13 = *((void *)this + 2) + v12;
  if (location + length >= v13) {
    CFIndex v14 = *((void *)this + 2) + v12;
  }
  else {
    CFIndex v14 = location + length;
  }
  uint64_t v15 = v14 - v12;
  BOOL v16 = location <= v12 && v12 < location + length;
  if (v16) {
    CFIndex v17 = *((void *)this + 1);
  }
  else {
    CFIndex v17 = 0;
  }
  if (!v16) {
    uint64_t v15 = 0;
  }
  uint64_t v18 = v14 - location;
  if (v12 <= location && location < v13)
  {
    uint64_t v20 = v18;
  }
  else
  {
    CFIndex location = v17;
    uint64_t v20 = v15;
  }
  uint64_t v21 = *((void *)this + 27);
  uint64_t v22 = *(void *)(v21 + 32);
  if (v22 || (uint64_t v35 = *(void *)(v21 + 24)) == 0)
  {
    int v23 = 0;
    uint64_t v24 = v22 + 16 * *((void *)this + 25);
    if (a4 < 0) {
      goto LABEL_44;
    }
    goto LABEL_23;
  }
  uint64_t v24 = v35 + 8 * *((void *)this + 25);
  int v23 = 1;
  if ((a4 & 0x80000000) == 0)
  {
LABEL_23:
    GlyphIndexForunsigned int Char = TRun::GetGlyphIndexForCharIndex<false>((uint64_t)this, location);
    if (v20 < 1) {
      return v20;
    }
    uint64_t NextGlyphIndex = location;
    while (1)
    {
      uint64_t v26 = GlyphIndexForChar;
      if (v23) {
        char v27 = 3;
      }
      else {
        char v27 = 4;
      }
      double v28 = (uint64_t *)*((void *)this + 29);
      double v29 = 0.0;
      if (v28)
      {
        unint64_t v30 = *((void *)this + 25) + GlyphIndexForChar - *((void *)this + 31);
        uint64_t v31 = *v28;
        if (v30 < (*(void *)(*((void *)this + 29) + 8) - v31) >> 3) {
          double v29 = *(double *)(v31 + 8 * v30);
        }
      }
      double v32 = *(double *)(v24 + (GlyphIndexForChar << v27)) - v29;
      if (v32 - a3 > v10) {
        return NextGlyphIndex - location;
      }
      if (*((int *)this + 64) > 1)
      {
        uint64_t NextGlyphIndex = TRun::FindNextGlyphIndex(this, NextGlyphIndex, &GlyphIndexForChar);
      }
      else if (*((unsigned char *)this + 224))
      {
        uint64_t v34 = --GlyphIndexForChar;
        if (v26 <= 0)
        {
LABEL_39:
          uint64_t NextGlyphIndex = *((void *)this + 2) + *((void *)this + 1);
          goto LABEL_40;
        }
        uint64_t NextGlyphIndex = *(void *)(*(void *)(*((void *)this + 27) + 48) + 8 * *((void *)this + 25) + 8 * v34);
      }
      else
      {
        uint64_t v33 = GlyphIndexForChar + 1;
        GlyphIndexForunsigned int Char = v33;
        if (v33 >= *((void *)this + 26)) {
          goto LABEL_39;
        }
        uint64_t NextGlyphIndex = *(void *)(*(void *)(*((void *)this + 27) + 48) + 8 * *((void *)this + 25) + 8 * v33);
      }
LABEL_40:
      a3 = a3 - v32 - v29;
      if (NextGlyphIndex >= location + v20) {
        return v20;
      }
    }
  }
LABEL_44:
  CFIndex v36 = location + v20;
  uint64_t PrevGlyphIndex = TRun::ResolveCharIndex(this, location + v20 - 1);
  GlyphIndexForunsigned int Char = v38;
  for (CFIndex i = location + v20; PrevGlyphIndex >= location; CFIndex i = v40)
  {
    uint64_t v40 = PrevGlyphIndex;
    uint64_t v41 = GlyphIndexForChar;
    double v42 = v23 ? *(double *)(v24 + 8 * GlyphIndexForChar) : *(double *)(v24 + 16 * GlyphIndexForChar);
    if (v42 - a3 > v10) {
      break;
    }
    if (*((int *)this + 64) > 1 || (*((unsigned char *)this + 224) & 1) != 0)
    {
      uint64_t PrevGlyphIndex = TRun::FindPrevGlyphIndex(this, PrevGlyphIndex, &GlyphIndexForChar);
    }
    else
    {
      uint64_t v43 = --GlyphIndexForChar;
      if (v41 <= 0) {
        uint64_t PrevGlyphIndex = *((void *)this + 1) - 1;
      }
      else {
        uint64_t PrevGlyphIndex = *(void *)(*(void *)(*((void *)this + 27) + 48) + 8 * *((void *)this + 25) + 8 * v43);
      }
    }
    a3 = a3 - v42;
  }
  return v36 - i;
}

BOOL TTruncator::NoRunAdded(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, double a5)
{
  if (!a3) {
    a3 = *(void *)(a1 + 32);
  }
  uint64_t v7 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(a3 + 24);
  if (v6 == v7)
  {
    uint64_t v8 = *(void *)(a1 + 24);
    uint64_t v10 = *(void *)(v8 + 72);
    uint64_t v9 = *(void *)(v8 + 80);
    if (a4 == -1) {
      uint64_t v11 = v10;
    }
    else {
      uint64_t v11 = a4;
    }
    TTruncator::CreateAndAppendToken(a1, v11, v10 - v11 + v9, a5, 0, a2);
  }
  return v6 == v7;
}

void TTruncator::CreateToken(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, unint64_t *a4@<X8>)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *a2;
  uint64_t v9 = a2[1];
  uint64_t v10 = *(void *)(*(void *)(*(void *)(*(void *)(a1 + 24) + 16)
                              + 8 * TLine::FindRunWithCharIndex(*(TLine **)(a1 + 24), *a2, 1))
                  + 40);
  id v43 = 0;
  if (a3)
  {
    unint64_t Dictionary = TAttributes::GetDictionary((atomic_ullong *)(v10 + 40));
    id v12 = (id)atomic_exchange((atomic_ullong *volatile)&v43, (*(uint64_t (**)(uint64_t, void, uint64_t *, unint64_t))(a3 + 16))(a3, *(void *)(a1 + 16), a2, Dictionary));
  }
  else
  {
    id v42 = 0;
    if ((*(_WORD *)(v10 + 178) & 0x40) != 0)
    {
      CFDictionaryRef v13 = (const __CFDictionary *)TAttributes::GetDictionary((atomic_ullong *)(v10 + 40));
      MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v13);
      if (MutableCopy)
      {
        unint64_t v15 = (unint64_t)MutableCopy;
        CFDictionaryRemoveValue(MutableCopy, @"CTRunDelegate");
      }
    }
    if (*(unsigned char *)(v10 + 90)) {
      CFStringRef v16 = @"";
    }
    else {
      CFStringRef v16 = @"";
    }
    CFIndex v17 = (std::__shared_weak_count *)operator new(0x48uLL);
    v17->__shared_weak_owners_ = 0;
    v17->__shared_owners_ = 0;
    v17->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ED062278;
    TCharStreamCFString::TCharStreamCFString((TCharStreamCFString *)&v17[1], v16, 0);
    CFIndex shared_weak_owners = v17[1].__shared_weak_owners_;
    *(_OWORD *)uint64_t v45 = xmmword_184BA8528;
    memset(&v45[16], 170, 32);
    long long v46 = unk_184BA8558;
    *(_OWORD *)&v44[96] = xmmword_184BA8508;
    *(_OWORD *)&v44[112] = unk_184BA8518;
    memset(v44, 170, 96);
    atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    *(void *)uint64_t v44 = v17 + 1;
    *(void *)&v44[8] = v17;
    memset(&v44[16], 0, 24);
    *(void *)&v44[64] = &v44[40];
    BYTE8(v46) = 0;
    memset(&v44[72], 0, 56);
    memset(&v45[8], 0, 21);
    *(void *)&v45[40] = 0;
    LOBYTE(v46) = 0;
    uint64_t v49 = 0;
    uint64_t v47 = 0;
    uint64_t v48 = 0;
    *(void *)&v45[32] = 0;
    *(void *)uint64_t v45 = 0xFFEFFFFFFFFFFFFFLL;
    id v19 = +[_CTNativeGlyphStorage newWithCount:shared_weak_owners capacity:shared_weak_owners];
    unint64_t v41 = 0xAAAAAAAAFFFFFFFFLL;
    memset(v40, 170, sizeof(v40));
    v28[0] = v19;
    v28[1] = &v17[1];
    long long v38 = 0u;
    long long v39 = 0u;
    long long v29 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v37 = 0u;
    uint64_t v20 = v17[1].__shared_weak_owners_;
    v40[0] = 0;
    v40[1] = v44;
    *(void *)&long long v39 = v20;
    memset(&v40[2], 0, 32);
    LODWORD(v41) = 1065353216;
    if (atomic_load_explicit((atomic_ullong *volatile)&v42, memory_order_acquire))
    {
      v51.CFIndex location = 0;
      v51.CFIndex length = 0;
      TAttributes::TAttributes((TAttributes *)v27, (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v42, memory_order_acquire), 0, v51, 0);
      TGlyphEncoder::EncodeChars((_CTGlyphStorage **)v28, 0, shared_weak_owners, (uint64_t)v27, 0);
      TAttributes::~TAttributes((TAttributes *)v27);
    }
    else
    {
      TGlyphEncoder::EncodeChars((_CTGlyphStorage **)v28, 0, shared_weak_owners, v10 + 40, 0);
    }

    if (*(void *)&v44[24] - *(void *)&v44[16] == 8) {
      TCFRef<__CTFont const*>::Retain((atomic_ullong *)&v43, **(id **)&v44[16]);
    }
    std::__hash_table<EncoderAttempt,std::hash<EncoderAttempt>,std::equal_to<EncoderAttempt>,std::allocator<EncoderAttempt>>::~__hash_table((uint64_t)&v40[2]);
    TLine::~TLine((TLine *)v44);
    std::__shared_weak_count::__release_shared[abi:nn180100](v17);
    id v12 = v42;
  }

  if (atomic_load_explicit((atomic_ullong *volatile)&v43, memory_order_acquire))
  {
    uint64_t v21 = *(void *)(atomic_load_explicit((atomic_ullong *volatile)&v43, memory_order_acquire) + 48);
    if (v21)
    {
      uint64_t v22 = *(void *)(v21 + 16);
      uint64_t v23 = v8 - *(void *)(v21 + 8);
      *(void *)(v21 + 8) = v8;
      objc_msgSend(*(id *)(v21 + 216), "puntStringIndicesInRange:by:", *(void *)(v21 + 200), *(void *)(v21 + 208), v23);
      if (v22 + v8 >= 1)
      {
        GlyphIndexForunsigned int Char = TRun::GetGlyphIndexForCharIndex<false>(v21, v22 + v8 - 1);
        objc_msgSend(*(id *)(v21 + 216), "setAttachmentCount:atIndex:", v9- v22+ objc_msgSend(*(id *)(v21 + 216), "attachmentCountAtIndex:", *(void *)(v21 + 200) + GlyphIndexForChar), *(void *)(v21 + 200) + GlyphIndexForChar);
        *(void *)(v21 + 8) = v8;
        *(void *)(v21 + 16) = v9;
      }
    }
    char v25 = *(unsigned char *)(v10 + 224);
    if (v25)
    {
      v28[0] = (id)0xAAAAAAAAAAAAAAAALL;
      (*(void (**)(id *__return_ptr))(atomic_load_explicit((atomic_ullong *volatile)&v43, memory_order_acquire)+ 56))(v28);
      *(unsigned char *)(*(void *)(atomic_load_explicit((atomic_ullong *volatile)v28, memory_order_acquire) + 48) + 224) = v25;
      TCFRef<__CTFont const*>::Retain((atomic_ullong *)&v43, (id)atomic_load_explicit((atomic_ullong *volatile)v28, memory_order_acquire));
    }
    unint64_t v26 = atomic_exchange((atomic_ullong *volatile)&v43, 0);
  }
  else
  {
    unint64_t v26 = 0;
  }
  *a4 = v26;
}

unint64_t TAttributes::GetDictionary(atomic_ullong *this)
{
  if (!*((unsigned char *)this + 48) && !*((unsigned char *)this + 49) && (*((_WORD *)this + 69) & 0x3000) == 0) {
    return atomic_load_explicit(this, memory_order_acquire);
  }
  CFStringRef explicit = (void *)atomic_load_explicit(this + 1, memory_order_acquire);
  if (!explicit)
  {
    id v10 = (id)0xAAAAAAAAAAAAAAAALL;
    TCFMutableDictionary::TCFMutableDictionary((TCFMutableDictionary *)&v10, (CFDictionaryRef)atomic_load_explicit(this, memory_order_acquire));
    if (*((unsigned char *)this + 48)) {
      CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire), @"NSFont", (const void *)atomic_load_explicit(this + 2, memory_order_acquire));
    }
    if (*((unsigned char *)this + 49))
    {
      atomic_ullong v3 = this[15];
      if (v3) {
        double v4 = *(double *)(v3 + 48);
      }
      else {
        double v4 = 0.0;
      }
      TCFNumber::TCFNumber<double>(&v9, v4);
      CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire), @"CTBaselineOffset", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire));
    }
    if ((*((_WORD *)this + 69) & 0x1000) != 0)
    {
      CFDictionaryRemoveValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire), @"CTTracking");
    }
    else if ((*((_WORD *)this + 69) & 0x2000) != 0)
    {
      atomic_ullong v5 = this[15];
      if (v5)
      {
        if (*(unsigned char *)(v5 + 24))
        {
          TCFNumber::TCFNumber<double>(&v9, *(double *)(v5 + 16));
          CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire), @"CTTracking", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire));
        }
      }
    }
    uint64_t v6 = 0;
    CFStringRef explicit = (void *)atomic_exchange((atomic_ullong *volatile)&v10, 0);
    uint64_t v7 = this + 1;
    atomic_compare_exchange_strong(v7, (unint64_t *)&v6, (unint64_t)explicit);
    if (v6)
    {

      CFStringRef explicit = (void *)atomic_load_explicit(v7, memory_order_acquire);
    }
    else
    {
    }
  }
  return (unint64_t)explicit;
}

BOOL TTruncator::AppendTruncatedRun(uint64_t a1, int64x2_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v6 = *(void *)(a1 + 8);
  if (a4 > v6) {
    return 0;
  }
  uint64_t v9 = a5;
  if (a6)
  {
    uint64_t v13 = a5 + a4 - 1;
    BOOL v14 = v6 < v13;
    uint64_t v15 = v6 - v13;
    if (v14)
    {
      uint64_t v9 = v15 + a5;
      if (v15 + a5 < 1) {
        return 0;
      }
    }
  }
  id v20 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr, uint64_t))(a3 + 56))(&v20, a3);
  CFStringRef v16 = *(TRun **)(atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire) + 48);
  TRun::TruncateUnorderedEnd(v16, a4, v9, a6, **(void **)(a1 + 24), 2);
  uint64_t v17 = *((void *)v16 + 26);
  BOOL v7 = v17 > 0;
  if (v17 >= 1)
  {
    id v19 = (id)atomic_exchange((atomic_ullong *volatile)&v20, 0);
    TLine::AppendRun(a2, (atomic_ullong *)&v19);
  }
  return v7;
}

void *TTruncator::HandleLeveledRuns(TTruncator *this, TLine *a2, unsigned __int8 *a3)
{
  CFNumberRef result = (void *)*((void *)this + 4);
  __int16 v5 = *((_WORD *)result + 76);
  if (v5)
  {
    if ((*(_WORD *)(*((void *)this + 3) + 152) & 8) != 0) {
      *((_WORD *)result + 76) = v5 | 8;
    }
    return TRunReorder::ReorderRuns(result, a2, a3);
  }
  return result;
}

BOOL TTruncator::CreateAndAppendToken(uint64_t a1, uint64_t a2, uint64_t a3, double a4, uint64_t a5, uint64_t a6)
{
  v14[0] = a2;
  v14[1] = a3;
  id v13 = (id)0xAAAAAAAAAAAAAAAALL;
  TTruncator::CreateToken(a1, v14, a6, (unint64_t *)&v13);
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&v13, memory_order_acquire);
  if (explicit)
  {
    uint64_t v9 = *(void *)(atomic_load_explicit((atomic_ullong *volatile)&v13, memory_order_acquire) + 40);
    uint64_t v10 = *(void *)(a1 + 32);
    uint64_t v11 = *(double **)(v9 + 312);
    if (!v11) {
      uint64_t v11 = (double *)MEMORY[0x1E4F1DB30];
    }
    if (*(double *)(v10 + 104) + *(double *)(v9 + 192) + *v11 <= a4) {
      TLine::InsertPartialRun((TLine *)v10, (uint64_t)(*(void *)(v10 + 24) - *(void *)(v10 + 16)) >> 3, atomic_load_explicit((atomic_ullong *volatile)&v13, memory_order_acquire), *(void *)(v9 + 8), *(void *)(v9 + 16));
    }
  }

  return explicit != 0;
}

double TLine::ClearLine(TLine *this)
{
  unint64_t v2 = (void **)*((void *)this + 2);
  atomic_ullong v3 = (void **)*((void *)this + 3);
  if (v2 != v3)
  {
    do
    {
      double v4 = *v2++;
    }
    while (v2 != v3);
    unint64_t v2 = (void **)*((void *)this + 2);
  }
  *((void *)this + 3) = v2;
  double result = 0.0;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(void *)((char *)this + 149) = 0;
  *((void *)this + 16) = 0xFFEFFFFFFFFFFFFFLL;
  return result;
}

CFStringRef TCharStreamCFString::CopyChars@<X0>(atomic_ullong *this@<X0>, CFRange range@<0:X1, 8:X2>, CFStringRef *a3@<X8>)
{
  CFStringRef result = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFStringRef)atomic_load_explicit(this + 4, memory_order_acquire), range);
  *a3 = result;
  return result;
}

void TLine::ReplaceRun(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v5 = *(void *)(a3 + 24);
  uint64_t v7 = *(void *)(*(void *)v6 + 48);
  uint64_t v8 = *(void *)(*(void *)(v5 - 8) + 48);
  uint64_t v9 = a1 + 2;
  uint64_t v10 = *(void *)(*(void *)(a1[2] + 8 * a2) + 40);
  uint64_t v11 = *(void *)(v10 + 32);
  if (v11)
  {
    *(void *)(v11 + 24) = v7;
  }
  else
  {
    a1[11] = v7;
    if (!v7) {
      goto LABEL_5;
    }
  }
  *(void *)(v7 + 32) = v11;
LABEL_5:
  uint64_t v12 = v5 - v6;
  uint64_t v13 = *(void *)(v10 + 24);
  if (v13)
  {
    *(void *)(v8 + 24) = v13;
    *(void *)(v13 + 32) = v8;
  }
  else
  {
    a1[12] = v8;
    if (v8) {
      *(void *)(v8 + 24) = 0;
    }
  }
  TLine::SimpleRunDelete((TLine *)a1, a2);
  if (v12 >= 1)
  {
    uint64_t v14 = (v12 >> 3) - 1;
    do
    {
      uint64_t v15 = (char *)(*v9 + 8 * a2);
      id v17 = *(id *)(*(void *)(a3 + 16) + 8 * v14);
      std::vector<CTRun *,TInlineBufferAllocator<CTRun *,3ul>>::insert((uint64_t)v9, v15, &v17);
      uint64_t v16 = v14-- + 1;
    }
    while (v16 > 1);
  }
}

double TFont::SwapPerThreadLineHeightAdjustment(TFont *this, double a2)
{
  double result = COERCE_DOUBLE(SetThreadSpecificData(6, *(uint64_t *)&a2, (uint64_t (*)(void *))ThreadSpecificNullDestructor<double>));
  if (result == 0.0) {
    return 0.2;
  }
  return result;
}

char *TFont::SwapPerThreadSize(TFont *this, double a2)
{
  double v2 = NAN;
  if (a2 != 0.0) {
    double v2 = a2;
  }
  if (a2 == 12.0) {
    uint64_t v3 = 0;
  }
  else {
    uint64_t v3 = *(void *)&v2;
  }
  return SetThreadSpecificData(5, v3, (uint64_t (*)(void *))ThreadSpecificNullDestructor<unsigned long>);
}

char *SetThreadSpecificData(int a1, uint64_t a2, uint64_t (*a3)(void *))
{
  double result = (char *)GetTable();
  if (result)
  {
    uint64_t v7 = &result[16 * a1];
    double result = *(char **)v7;
    if (a3) {
      uint64_t v8 = a3;
    }
    else {
      uint64_t v8 = NullDestructor;
    }
    *(void *)uint64_t v7 = a2;
    *((void *)v7 + 1) = v8;
  }
  return result;
}

void *GetTable(void)
{
  if (GetInternalKey(void)::sOnce != -1) {
    dispatch_once_f(&GetInternalKey(void)::sOnce, 0, (dispatch_function_t)GetInternalKey(void)::$_0::__invoke);
  }
  v0 = pthread_getspecific(0x5FuLL);
  if (!v0) {
    operator new();
  }
  return v0;
}

uint64_t TTypesetter::GetTabOverflowIndex(TTypesetter *this, const TLine *a2, double a3)
{
  void v10[4] = *MEMORY[0x1E4F143B8];
  uint64_t result = -1;
  uint64_t v9 = -1;
  if ((*((_WORD *)this + 76) & 2) != 0)
  {
    uint64_t v5 = *(void *)this;
    v7[0] = (uint64_t)this;
    v7[1] = v5;
    void v7[2] = 0;
    void v7[3] = 0;
    v8[0] = 0;
    *(void *)((char *)v8 + 6) = 0;
    v8[2] = &v9;
    v10[3] = 0;
    TTypesetter::FindGraphicalBreak(v7, (uint64_t)a2, (uint64_t)v10, (uint64_t)&v6, 1.79769313e308, a3);
    std::__function::__value_func<unsigned char ()(long)>::~__value_func[abi:nn180100](v10);
    return v9;
  }
  return result;
}

CTFontDescriptorRef CTFontDescriptorCreateCopyWithSymbolicTraits(CTFontDescriptorRef original, CTFontSymbolicTraits symTraitValue, CTFontSymbolicTraits symTraitMask)
{
  CopyWithCFDictionaryRef Attributes = (atomic_ullong **)original;
  unsigned int v29 = symTraitValue;
  if (original)
  {
    uint64_t v5 = *((void *)original + 5);
    if ((*(_DWORD *)(v5 + 16) & 0x80000000) == 0) {
      TDescriptor::InitBaseFont(*((TDescriptor **)original + 5), 0, 0.0);
    }
    unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(v5 + 32), memory_order_acquire);
    if (explicit)
    {
      int v7 = (unsigned __int16)symTraitMask & (unsigned __int16)v29 & 0x800;
      int v8 = (unsigned __int16)symTraitMask & (unsigned __int16)v29 & 0x1000;
      unsigned int v9 = v29 & 0xFFFFE7FF;
      v29 &= 0xFFFFE7FF;
      if ((symTraitMask & 0xFFFFE7FF) == 0)
      {
        id valuePtr = (id)(v8 | v7 | v9);
        CFAllocatorRef v16 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        CFNumberRef v17 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberLongType, &valuePtr);
        values = v17;
        id valuePtr = @"NSCTFontSymbolicTrait";
        uint64_t v18 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
        id v19 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
        CFDictionaryRef v20 = CFDictionaryCreate(v16, (const void **)&valuePtr, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        values = v20;
        id valuePtr = @"NSCTFontTraitsAttribute";
        CFDictionaryRef v21 = CFDictionaryCreate(v16, (const void **)&valuePtr, (const void **)&values, 1, v18, v19);
        CopyWithCFDictionaryRef Attributes = (atomic_ullong **)CTFontDescriptorCreateCopyWithAttributes((CTFontDescriptorRef)CopyWithAttributes, v21);

        id v22 = v17;
LABEL_25:

        return (CTFontDescriptorRef)CopyWithAttributes;
      }
      id v28 = (id)0xAAAAAAAAAAAAAAAALL;
      TBaseFont::CreateVariantWithSymbolicTraits((atomic_ullong *)explicit, &v29, (const __CTFontDescriptor *)CopyWithAttributes, symTraitMask & 0xFFFFE7FF, &v28);
      if (!atomic_load_explicit((atomic_ullong *volatile)&v28, memory_order_acquire))
      {
        CopyWithCFDictionaryRef Attributes = 0;
LABEL_24:
        id v22 = v28;
        goto LABEL_25;
      }
      TDescriptor::CopyAttributes(CopyWithAttributes[5], &valuePtr);
      CFDictionaryRef v10 = (const __CFDictionary *)atomic_exchange((atomic_ullong *volatile)&valuePtr, 0);

      uint64_t v11 = CTFontDescriptorCopyAttributes((CTFontDescriptorRef)atomic_load_explicit((atomic_ullong *volatile)&v28, memory_order_acquire));
      uint64_t v12 = v11;
      unint64_t v13 = atomic_load_explicit((atomic_ullong *volatile)&v28, memory_order_acquire);
      if (v13
        && (int v14 = *(_DWORD *)(*(void *)(v13 + 40) + 16),
            (TDescriptor::GetSystemUIFontOptions(v11) & v14) != 0)
        || v10 && CFDictionaryGetCount(v10) == 1 && CFDictionaryGetValue(v10, @"NSFontNameAttribute"))
      {
        LOBYTE(v15) = 0;
        if (v7) {
          goto LABEL_20;
        }
      }
      else
      {
        int v15 = (*(_DWORD *)(explicit + 180) >> 28) & 1;
        if (v7) {
          goto LABEL_20;
        }
      }
      if ((v15 & 1) == 0)
      {
        CopyWithCFDictionaryRef Attributes = (atomic_ullong **)atomic_exchange((atomic_ullong *volatile)&v28, 0);
LABEL_23:

        goto LABEL_24;
      }
LABEL_20:
      id v27 = (id)0xAAAAAAAAAAAAAAAALL;
      TCFMutableDictionary::TCFMutableDictionary((TCFMutableDictionary *)&v27, v10);
      TCFMutableDictionary::SetPairs((atomic_ullong *)&v27, v12);
      if (v7)
      {
        id valuePtr = (id)(v7 | v29 | v8);
        CFAllocatorRef v23 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        CFNumberRef v24 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberLongType, &valuePtr);
        values = v24;
        id valuePtr = @"NSCTFontSymbolicTrait";
        CFDictionaryRef v25 = CFDictionaryCreate(v23, (const void **)&valuePtr, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v27, memory_order_acquire), @"NSCTFontTraitsAttribute", v25);
      }
      CopyWithCFDictionaryRef Attributes = (atomic_ullong **)CTFontDescriptorCreateWithAttributesAndOptions(atomic_load_explicit((atomic_ullong *volatile)&v27, memory_order_acquire), *((_DWORD *)CopyWithAttributes[5] + 4));

      goto LABEL_23;
    }
    return 0;
  }
  return (CTFontDescriptorRef)CopyWithAttributes;
}

unint64_t TOpenTypeMorph::GetInitialScriptAndLangSys(__CFString *this, __CFString *a2, const TFont *a3)
{
  if (this)
  {
    uint64_t v3 = ScriptAndLangSysFromCanonicalLanguage(this);
LABEL_6:
    unint64_t v5 = v3 & 0xFFFFFFFF00000000;
    return v5 | v3;
  }
  BOOL v7 = -86;
  int IsSystemUIFontAndForShaping = TFont::IsSystemUIFontAndForShaping((atomic_ullong *)a2, &v7);
  unint64_t v5 = 0;
  LODWORD(v3) = -1;
  if (IsSystemUIFontAndForShaping && v7)
  {
    uint64_t v3 = ScriptAndLangSysForPreferredLanguage();
    goto LABEL_6;
  }
  return v5 | v3;
}

unint64_t CTFontDescriptorCreateWithTextStyleAndAttributes(__CFString *a1, __CFString *a2, const __CFDictionary *a3)
{
  TDescriptorSource::TDescriptorSource((TDescriptorSource *)&v8);
  TDescriptorSource::CreateDescriptorForTextStyle(a1, a2, 0, a3, &v9);
  unint64_t v6 = atomic_exchange((atomic_ullong *volatile)&v9, 0);

  return v6;
}

CFDictionaryRef CTFontDescriptorCopyAttributes(CTFontDescriptorRef descriptor)
{
  if (!descriptor) {
    return 0;
  }
  TDescriptor::CopyAttributes(*((atomic_ullong **)descriptor + 5), &v3);
  CFDictionaryRef v1 = (const __CFDictionary *)atomic_exchange((atomic_ullong *volatile)&v3, 0);

  return v1;
}

BOOL TFont::NeedsShapingForGlyphs(atomic_ullong *this, const unsigned __int16 *a2, uint64_t a3, const __CFString *a4)
{
  if (a4 || TFont::ShapesPreferredLanguage(this)) {
    BOOL v7 = this + 39;
  }
  else {
    BOOL v7 = this + 40;
  }
  unint64_t explicit = atomic_load_explicit(v7, memory_order_acquire);
  if (explicit == -1) {
    return 1;
  }
  uint64_t v9 = a3 - 1;
  if (a3 < 1) {
    return 0;
  }
  do
  {
    unsigned int v10 = *a2++;
    int v11 = (1 << (v10 & 7)) & *(unsigned __int8 *)(explicit + ((unint64_t)v10 >> 3));
    BOOL result = v11 != 0;
    if (v11) {
      BOOL v13 = 1;
    }
    else {
      BOOL v13 = v9 == 0;
    }
    --v9;
  }
  while (!v13);
  return result;
}

void TDescriptor::InitBaseFont(TDescriptor *this, uint64_t a2, double a3)
{
  __int16 v4 = a2;
  id v47 = (id)0xAAAAAAAAAAAAAAAALL;
  TDescriptor::CreateMatchingDescriptorInternal((atomic_ullong *)&v47, this, 0, a2);
  unsigned int v46 = 0x80000000;
  if (atomic_load_explicit((atomic_ullong *volatile)&v47, memory_order_acquire))
  {
    uint64_t v45 = (atomic_uint *)0xAAAAAAAAAAAAAAAALL;
    unint64_t v6 = (TDescriptor **)(id)atomic_load_explicit((atomic_ullong *volatile)&v47, memory_order_acquire);
    BOOL v7 = v6;
    uint64_t v8 = v6[5];
    if ((*((_DWORD *)v8 + 4) & 0x80000000) == 0) {
      TDescriptor::InitBaseFont(v6[5], 0, 0.0);
    }
    unint64_t explicit = (atomic_uint *)atomic_load_explicit((atomic_ullong *volatile)v8 + 4, memory_order_acquire);

    uint64_t v45 = explicit;
    if (explicit)
    {
      unsigned int v10 = (id)atomic_load_explicit((atomic_ullong *volatile)&v47, memory_order_acquire);
      uint64_t v11 = v10[5];

      if (v4 < 0 || !TDescriptor::IsSystemUIFont(this) && !TDescriptor::IsSystemUIFont((TDescriptor *)v11))
      {
LABEL_29:
        uint64_t v12 = v45;
        if (!v45)
        {
LABEL_45:
          uint64_t v41 = 0;
          unint64_t v42 = (unint64_t)v45;
          atomic_fetch_add_explicit(v45 + 2, 1u, memory_order_relaxed);
          atomic_compare_exchange_strong((atomic_ullong *volatile)this + 4, (unint64_t *)&v41, v42);
          if (v41)
          {
            uint64_t v43 = (uint64_t)v45;
            if (v45)
            {
              if (atomic_fetch_add_explicit(v45 + 2, 0xFFFFFFFF, memory_order_release) == 1)
              {
                __dmb(9u);
                (*(void (**)(uint64_t))(*(void *)v43 + 8))(v43);
              }
            }
          }
          goto LABEL_49;
        }
LABEL_30:
        (*(void (**)(uint64_t *__return_ptr, atomic_uint *))(*(void *)v12 + 120))(&valuePtr, v12);
        unint64_t v25 = atomic_load_explicit(&valuePtr, memory_order_acquire);

        if (v25)
        {
          CFDictionaryRef v26 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)this + 1, memory_order_acquire);
          CFDictionaryRef v27 = v26;
          if (v26
            && (id v28 = (void *)CFDictionaryGetValue(v26, @"NSCTFontVariationAttribute")) != 0
            && (unsigned int v29 = v28, v30 = CFGetTypeID(v28), v30 == CFDictionaryGetTypeID()))
          {

            values = v29;
            uint64_t valuePtr = @"NSCTFontVariationAttribute";
            CFDictionaryRef v31 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&valuePtr, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            TCFBase_NEW<CTFontDescriptor,TBaseFont const*&,unsigned int &>((uint64_t *)&v45, (int *)&v46, &valuePtr);
            long long v32 = (void *)atomic_exchange(&valuePtr, 0);

            values = v32;
            CFDictionaryRef v44 = v31;
            TCFBase_NEW<CTFontDescriptor,CTFontDescriptor*,__CFDictionary const*&>((uint64_t *)&values, &v44, &valuePtr);

            long long v33 = (id)atomic_load_explicit((atomic_ullong *volatile)&v47, memory_order_acquire);
            int v34 = *(_DWORD *)(v33[5] + 16);

            if (v34 < 0)
            {
              long long v35 = (TDescriptor **)(id)atomic_load_explicit((atomic_ullong *volatile)&v47, memory_order_acquire);
              long long v36 = v35;
              long long v37 = v35[5];
              if ((*((_DWORD *)v37 + 4) & 0x80000000) == 0) {
                TDescriptor::InitBaseFont(v35[5], 0, 0.0);
              }
              long long v38 = (atomic_uint *)atomic_load_explicit((atomic_ullong *volatile)v37 + 4, memory_order_acquire);

              if (v38) {
                uint64_t v45 = v38;
              }
            }
          }
          else
          {

            if ((*(unsigned int (**)(atomic_uint *))(*(void *)v45 + 16))(v45) == 1414088260)
            {
              atomic_load_explicit((atomic_ullong *volatile)(v11 + 8), memory_order_acquire);
              CFDictionaryRef v39 = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)(v11 + 8), memory_order_acquire);
              if (v39)
              {
                CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v39, @"NSCTFontTraitsAttribute");
                if (Value)
                {
                  if (CFDictionaryGetValue(Value, @"NSCTFontWeightTrait")) {
                    operator new();
                  }
                }
              }
            }
          }
        }
        goto LABEL_45;
      }
      v46 |= *(_DWORD *)(v11 + 16) & 0x404;
      uint64_t v12 = v45;
      if ((*(unsigned int (**)(atomic_uint *))(*(void *)v45 + 16))(v45) != 1414743620
        || !(*(unsigned int (**)(atomic_uint *))(*(void *)v45 + 840))(v45))
      {
        goto LABEL_30;
      }
      CFDictionaryRef v13 = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)this + 1, memory_order_acquire);
      if (v13)
      {
        int v14 = CFDictionaryGetValue(v13, @"NSCTFontOpticalSizeAttribute");
        if (v14)
        {
          int v15 = v14;
          CFTypeID v16 = CFGetTypeID(v14);
          if (v16 == CFNumberGetTypeID()) {
            goto LABEL_15;
          }
        }
        if (a3 == 0.0)
        {
          int v15 = CFDictionaryGetValue(v13, @"NSFontSizeAttribute");
          if (!v15)
          {
LABEL_16:
            CFDictionaryRef v18 = (const __CFDictionary *)CFDictionaryGetValue(v13, @"NSCTFontVariationAttribute");
            if (v18) {
              int v15 = CFDictionaryGetValue(v18, &unk_1ED080880);
            }
            if (v15) {
              goto LABEL_19;
            }
LABEL_23:
            double v21 = 12.0;
LABEL_24:
            id v22 = (TSplicedFont *)v45;
LABEL_25:
            unint64_t OpticalSizeComponent = TSplicedFont::GetOpticalSizeComponent(v22, v21);
            uint64_t v12 = (atomic_uint *)OpticalSizeComponent;
            if (OpticalSizeComponent)
            {
              (*(void (**)(uint64_t *__return_ptr, unint64_t))(*(void *)OpticalSizeComponent + 128))(&valuePtr, OpticalSizeComponent);
              unint64_t v24 = atomic_load_explicit(&valuePtr, memory_order_acquire);

              if (v24) {
                v46 |= 0x8000u;
              }
              uint64_t v45 = v12;
              goto LABEL_30;
            }
            goto LABEL_29;
          }
LABEL_15:
          CFTypeID v17 = CFGetTypeID(v15);
          if (v17 == CFNumberGetTypeID())
          {
LABEL_19:
            CFTypeID v19 = CFGetTypeID(v15);
            CFTypeID TypeID = CFNumberGetTypeID();
            double v21 = 12.0;
            if (v19 == TypeID)
            {
              uint64_t valuePtr = -1;
              CFNumberGetValue((CFNumberRef)v15, kCFNumberDoubleType, &valuePtr);
              double v21 = *(double *)&valuePtr;
            }
            goto LABEL_24;
          }
          goto LABEL_16;
        }
      }
      else if (a3 == 0.0)
      {
        goto LABEL_23;
      }
      id v22 = (TSplicedFont *)v45;
      double v21 = a3;
      goto LABEL_25;
    }
  }
LABEL_49:
  atomic_fetch_or_explicit((atomic_uint *volatile)this + 4, v46, memory_order_relaxed);
}

void TTenuousComponentFont::CopyOpticalSizeAxis(TBaseFont *this@<X0>, atomic_ullong *a2@<X8>)
{
  if ((*((unsigned char *)this + 713) & 0x40) != 0) {
    TBaseFont::CopyOpticalSizeAxis(this, a2);
  }
  else {
    *a2 = 0;
  }
}

void TBaseFont::CopyOpticalSizeAxis(TBaseFont *this@<X0>, atomic_ullong *a2@<X8>)
{
  *a2 = 0;
  id v10 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr))(*(void *)this + 120))(&v10);
  if (atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire))
  {
    CFArrayRef explicit = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire);
    if (explicit)
    {
      CFIndex Count = CFArrayGetCount(explicit);
      if (Count)
      {
        CFIndex v5 = Count;
        CFIndex v6 = 0;
        while (1)
        {
          CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(explicit, v6);
          CFDictionaryRef Value = (void *)CFDictionaryGetValue(ValueAtIndex, @"NSCTVariationAxisIdentifier");
          if (Value == &unk_1ED082DE8 || Value && CFEqual(Value, &unk_1ED082DE8)) {
            break;
          }
          if (v5 == ++v6) {
            goto LABEL_11;
          }
        }
        id v9 = ValueAtIndex;
      }
    }
  }
LABEL_11:
}

void TTenuousComponentFont::CopyVariationAxes(atomic_ullong *this@<X0>, unint64_t *a2@<X8>)
{
  if ((this[89] & 4) != 0)
  {
    CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit(this + 90, memory_order_acquire);
    if (explicit && (CFDictionaryRef Value = (void *)CFDictionaryGetValue(explicit, @"variationAxes")) != 0)
    {
      id v6 = Value;
      *a2 = atomic_exchange((atomic_ullong *volatile)&v6, 0);
    }
    else
    {
      TBaseFont::CopyVariationAxes(this, a2);
    }
  }
  else
  {
    *a2 = 0;
  }
}

BOOL TDescriptor::IsSystemUIFont(TDescriptor *this)
{
  int v1 = *((_DWORD *)this + 4);
  if (qword_1EB2CE0B0 != -1) {
    dispatch_once_f(&qword_1EB2CE0B0, 0, (dispatch_function_t)TDescriptor::GetSystemUIFontOptions(void)::$_0::__invoke);
  }
  return (_MergedGlobals_13 & v1) != 0;
}

BOOL TSplicedFont::IsOpticalFont(TSplicedFont *this)
{
  return *((void *)this + 77) != 0;
}

void TDescriptor::CreateMatchingDescriptorInternal(atomic_ullong *this, const __CFSet *a2, const __CFSet *a3, uint64_t a4)
{
  uint64_t v130 = *MEMORY[0x1E4F143B8];
  *this = 0;
  uint64_t v125 = (atomic_ullong *)0xAAAAAAAAAAAAAAAALL;
  TDescriptorSource::TDescriptorSource((TDescriptorSource *)&v125);
  CFDictionaryRef Attributes = (const __CFDictionary *)TDescriptor::GetAttributes((atomic_ullong *)a2, 1);
  if (!Attributes || CFDictionaryGetCount(Attributes) < 1)
  {
    BOOL IsSystemUIFont = TDescriptor::IsSystemUIFont(a2);
    TDescriptorSource::CreateDefaultDescriptor(IsSystemUIFont, &valuePtr);
    unint64_t v16 = atomic_exchange((atomic_ullong *volatile)&valuePtr, 0);
    goto LABEL_149;
  }
  CFSetRef v119 = a3;
  uint64_t v9 = AsMatchingOptions(*((_DWORD *)a2 + 4));
  CFTypeID TypeID = CFStringGetTypeID();
  CFTypeID v11 = CFNumberGetTypeID();
  CFDictionaryRef Value = (__CFString *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)a2 + 1, memory_order_acquire), @"CTFontDescriptorLanguageAttribute");
  if (Value)
  {
    CFDictionaryRef v13 = Value;
    if (CFGetTypeID(Value) == TypeID) {
      int v14 = v13;
    }
    else {
      int v14 = 0;
    }
    unsigned int v118 = v14;
  }
  else
  {
    unsigned int v118 = 0;
  }
  CFNumberRef v17 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)a2 + 1, memory_order_acquire), @"CTFontLanguageAwareLineHeightRatioAttribute");
  if (v17)
  {
    CFNumberRef v18 = v17;
    if (CFGetTypeID(v17) == v11) {
      CFNumberRef v19 = v18;
    }
    else {
      CFNumberRef v19 = 0;
    }
    CFNumberRef v117 = v19;
  }
  else
  {
    CFNumberRef v117 = 0;
  }
  CFNumberRef v20 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)a2 + 1, memory_order_acquire), @"CTFontLineSpacingOverrideAttribute");
  if (v20)
  {
    CFNumberRef v21 = v20;
    if (CFGetTypeID(v20) == v11) {
      CFNumberRef v22 = v21;
    }
    else {
      CFNumberRef v22 = 0;
    }
    CFNumberRef v116 = v22;
  }
  else
  {
    CFNumberRef v116 = 0;
  }
  CFNumberRef v23 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)a2 + 1, memory_order_acquire), @"CTFontLegibilityWeightAttribute");
  if (v23)
  {
    CFNumberRef v24 = v23;
    if (CFGetTypeID(v23) == v11) {
      CFNumberRef v25 = v24;
    }
    else {
      CFNumberRef v25 = 0;
    }
  }
  else
  {
    CFNumberRef v25 = 0;
  }
  CFDictionaryRef v26 = CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)a2 + 1, memory_order_acquire), @"CTFontIgnoreLegibilityWeightAttribute");
  if (v26)
  {
    CFDictionaryRef v27 = v26;
    CFTypeID v28 = CFGetTypeID(v26);
    if (v28 == CFBooleanGetTypeID()) {
      unsigned int v29 = v27;
    }
    else {
      unsigned int v29 = 0;
    }
    uint64_t v114 = v29;
    if (v25) {
      goto LABEL_32;
    }
  }
  else
  {
    uint64_t v114 = 0;
    if (v25)
    {
LABEL_32:
      LODWORD(valuePtr) = -1431655766;
      CFNumberGetValue(v25, kCFNumberIntType, &valuePtr);
      uint64_t v30 = (int)valuePtr;
      goto LABEL_35;
    }
  }
  uint64_t v30 = -1;
LABEL_35:
  uint64_t v115 = v30;
  CFDictionaryRef v31 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)a2 + 1, memory_order_acquire), @"NSCTFontTraitsAttribute");
  if (v31)
  {
    CFDictionaryRef v32 = v31;
    CFTypeID v33 = CFGetTypeID(v31);
    if (v33 == CFDictionaryGetTypeID()) {
      CFDictionaryRef v34 = v32;
    }
    else {
      CFDictionaryRef v34 = 0;
    }
  }
  else
  {
    CFDictionaryRef v34 = 0;
  }
  uint64_t v35 = v9 | a4;
  long long v36 = (__CFString *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)a2 + 1, memory_order_acquire), @"NSCTFontUIUsageAttribute");
  long long v37 = v36;
  if (v36)
  {
    if (CFGetTypeID(v36) == TypeID) {
      long long v38 = v37;
    }
    else {
      long long v38 = 0;
    }
    if (!v34)
    {
      CFNumberRef v42 = 0;
      if (v38)
      {
        char v43 = 1;
        unint64_t v113 = 0;
        uint64_t v41 = 0;
        goto LABEL_65;
      }
LABEL_74:
      CFNumberRef v111 = v42;
      CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)a2 + 1, memory_order_acquire);
      CFStringRef v53 = (const __CFString *)CFDictionaryGetValue(explicit, @"NSFontNameAttribute");
      if (!v53 || (v54 = v53, CFTypeID v55 = CFGetTypeID(v53), v55 != CFStringGetTypeID()))
      {
        CFStringRef v56 = (const __CFString *)CFDictionaryGetValue(explicit, @"NSCTFontPostScriptNameAttribute");
        if (!v56)
        {
          CFStringRef v54 = 0;
          if (!explicit) {
            goto LABEL_90;
          }
LABEL_83:
          CFIndex Count = CFDictionaryGetCount(explicit);
          if (Count >= 2)
          {
            CFIndex v60 = Count;
            *(void *)&long long v61 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v61 + 1) = 0xAAAAAAAAAAAAAAAALL;
            v128[14] = v61;
            v128[13] = v61;
            v128[12] = v61;
            v128[11] = v61;
            v128[10] = v61;
            v128[9] = v61;
            v128[8] = v61;
            v128[7] = v61;
            v128[6] = v61;
            v128[5] = v61;
            v128[4] = v61;
            v128[3] = v61;
            v128[2] = v61;
            v128[1] = v61;
            v128[0] = v61;
            v127[0] = 0;
            v127[1] = 0;
            uint64_t valuePtr = 0;
            uint64_t v129 = v128;
            std::vector<long,TInlineBufferAllocator<long,30ul>>::__vallocate[abi:nn180100](&valuePtr, Count);
            long long v62 = (char *)v127[0];
            bzero(v127[0], 8 * v60);
            v127[0] = &v62[8 * v60];
            uint64_t v63 = (TDescriptorSource **)valuePtr;
            CFDictionaryGetKeysAndValues(explicit, (const void **)&valuePtr->isa, 0);
            while (1)
            {
              int v65 = *v63;
              if (TDescriptorSource::IsSearchableAttribute(*v63, v64))
              {
                if (!CFEqual(v65, @"NSFontNameAttribute")
                  && !CFEqual(v65, @"NSCTFontPostScriptNameAttribute"))
                {
                  break;
                }
              }
              ++v63;
              if (!--v60)
              {
                id values = &valuePtr;
                std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&values);
                goto LABEL_90;
              }
            }
            id v123 = 0;
            id values = &valuePtr;
            std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&values);
            LOBYTE(v54) = 0;
LABEL_93:
            MatchableCFDictionaryRef Attributes = v119;

            unint64_t v68 = atomic_load_explicit(this, memory_order_acquire);
            if (MatchableAttributes || v68 || !v111)
            {
              unint64_t v48 = v35 | 2;
              goto LABEL_146;
            }
            uint64_t valuePtr = (__CFString *)0xAAAAAAAAAAAAAAAALL;
            CFDictionaryRef v69 = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)a2 + 1, memory_order_acquire);
            MatchableNameCFDictionaryRef Attributes = (const __CFSet *)TDescriptorSource::GetMatchableNameAttributes(v67);
            TDescriptorSource::CopyMandatoryMatchableRequest(v69, MatchableNameAttributes, &valuePtr);
            CFDictionaryRef v71 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)&valuePtr, memory_order_acquire);
            if (v71)
            {
              CFDictionaryRef v72 = v71;
              CFIndex v73 = CFDictionaryGetCount(v71);

              if (v73)
              {
                MatchableCFDictionaryRef Attributes = 0;
                unint64_t v48 = v35 | 2;
LABEL_102:

                goto LABEL_146;
              }
            }
            else
            {
            }
            MatchableCFDictionaryRef Attributes = (const __CFSet *)TDescriptorSource::GetMatchableAttributes(v74);
            unint64_t v48 = v35 & 0xFFFFFFFFFFFFFFFDLL;
            goto LABEL_102;
          }
LABEL_90:
          if (v54)
          {
            TDescriptorSource::CopyFontDescriptorPerPostScriptName(&v125, v54, v35 | 2, 0, (uint64_t)v118, &v123);
            LOBYTE(v54) = 1;
          }
          else
          {
            id v123 = 0;
          }
          goto LABEL_93;
        }
        CFStringRef v57 = v56;
        CFTypeID v58 = CFGetTypeID(v56);
        if (v58 == CFStringGetTypeID()) {
          CFStringRef v54 = v57;
        }
        else {
          CFStringRef v54 = 0;
        }
      }
      if (!explicit) {
        goto LABEL_90;
      }
      goto LABEL_83;
    }
    long long v37 = v38;
  }
  else if (!v34)
  {
    CFNumberRef v42 = 0;
    goto LABEL_74;
  }
  CFDictionaryRef v39 = (__CFString *)CFDictionaryGetValue(v34, @"NSCTFontUIFontDesignTrait");
  if (v39)
  {
    uint64_t v40 = v39;
    if (CFGetTypeID(v39) == TypeID) {
      uint64_t v41 = v40;
    }
    else {
      uint64_t v41 = 0;
    }
  }
  else
  {
    uint64_t v41 = 0;
  }
  CFDictionaryRef v44 = CFDictionaryGetValue(v34, @"NSCTFontWeightTrait");
  if (v44)
  {
    unint64_t v45 = (unint64_t)v44;
    if (CFGetTypeID(v44) == v11) {
      unint64_t v46 = v45;
    }
    else {
      unint64_t v46 = 0;
    }
    unint64_t v113 = v46;
  }
  else
  {
    unint64_t v113 = 0;
  }
  CFNumberRef v47 = (const __CFNumber *)CFDictionaryGetValue(v34, @"NSCTFontSymbolicTrait");
  CFNumberRef v42 = v47;
  if (v47 && CFGetTypeID(v47) != v11) {
    CFNumberRef v42 = 0;
  }
  if (v37)
  {
    char v43 = 0;
LABEL_65:
    unint64_t v48 = v35 | 0x402;
    if ((v37 == @"CTFont" || CFStringHasPrefix(v37, @"CTFont"))
      && CFStringHasSuffix(v37, @"Usage")
      && v113 | (unint64_t)v41)
    {
      if (v41)
      {
        TDescriptorSource::CreateDescriptorForUIFontDesign(v34, (TDescriptorSource *)&v125, v41, v48, v118, v117, v116, v115, (unint64_t *)&valuePtr, v114);
        id v50 = (id)atomic_exchange(this, atomic_exchange((atomic_ullong *volatile)&valuePtr, 0));
      }
      else
      {
        uint64_t valuePtr = (__CFString *)0xAAAAAAAAAAAAAAAALL;
        TCFMutableDictionary::TCFMutableDictionary((TCFMutableDictionary *)&valuePtr, v34);
        CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&valuePtr, memory_order_acquire), @"NSCTFontUIFontDesignTrait", @"NSCTFontUIFontDesignDefault");
        TDescriptorSource::CreateDescriptorForUIFontDesign((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&valuePtr, memory_order_acquire), (TDescriptorSource *)&v125, @"NSCTFontUIFontDesignDefault", v48, v118, v117, v116, v115, (unint64_t *)&values, v114);

        id v50 = values;
      }
    }
    if (atomic_load_explicit(this, memory_order_acquire)) {
      goto LABEL_145;
    }
    char v124 = 0;
    id v122 = 0;
    id v123 = 0;
    uint64_t valuePtr = (__CFString *)&v123;
    v127[0] = 0;
    id values = &v122;
    CFStringRef v121 = 0;
    FontNameForTextStyle = TDescriptorSource::FindFontNameForTextStyle((TDescriptorSource *)v37, 0, (const __CFDictionary *)&v124, (BOOL *)v127, &v121, v49);

    if (!FontNameForTextStyle) {
      goto LABEL_143;
    }
    if (v42
      && (LODWORD(valuePtr) = -1431655766,
          CFNumberGetValue(v42, kCFNumberIntType, &valuePtr),
          char v76 = (char)valuePtr,
          valuePtr))
    {
      FontNameForNameAndTrait = TDescriptorSource::FindFontNameForNameAndTrait((TDescriptorSource *)FontNameForTextStyle, 0, (uint64_t *)valuePtr, (int)valuePtr);
      FontNameForTextStyle = FontNameForNameAndTrait;
      BOOL v78 = (v76 & 1) != 0 && CFStringFind(FontNameForNameAndTrait, @"Italic", 0).location == -1;
      unsigned int v110 = v78;
    }
    else
    {
      unsigned int v110 = 0;
    }
    CFNumberRef v79 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)a2 + 1, memory_order_acquire), @"NSCTFontSizeCategoryAttribute");
    if (v79)
    {
      CFNumberRef v80 = v79;
      if (CFGetTypeID(v79) == v11) {
        CFNumberRef v81 = v80;
      }
      else {
        CFNumberRef v81 = 0;
      }
      CFNumberRef v112 = v81;
    }
    else
    {
      CFNumberRef v112 = 0;
    }
    if (v41 == @"NSCTFontUIFontDesignDefault"
      || v41 && @"NSCTFontUIFontDesignDefault" && CFEqual(v41, @"NSCTFontUIFontDesignDefault"))
    {
      uint64_t v41 = 0;
    }
    unint64_t v82 = v48;
    CFNumberRef v83 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)a2 + 1, memory_order_acquire), @"NSCTFontTextStylePlatformAttribute");
    if (v83)
    {
      CFNumberRef v84 = v83;
      if (CFGetTypeID(v83) == v11) {
        CFNumberRef v85 = v84;
      }
      else {
        CFNumberRef v85 = 0;
      }
      if (v43) {
        goto LABEL_130;
      }
    }
    else
    {
      CFNumberRef v85 = 0;
      if (v43)
      {
LABEL_130:
        CFNumberRef v86 = 0;
        goto LABEL_141;
      }
    }
    CFNumberRef v87 = (const __CFNumber *)CFDictionaryGetValue(v34, @"NSCTFontProportionTrait");
    if (v87)
    {
      CFNumberRef v88 = v87;
      if (CFGetTypeID(v87) == v11) {
        CFNumberRef v86 = v88;
      }
      else {
        CFNumberRef v86 = 0;
      }
    }
    else
    {
      CFNumberRef v86 = 0;
    }
    CFNumberRef v89 = (const __CFNumber *)CFDictionaryGetValue(v34, @"NSCTFontGradeTrait");
    if (v89)
    {
      CFNumberRef v90 = v89;
      if (CFGetTypeID(v89) == v11) {
        CFNumberRef v91 = v90;
      }
      else {
        CFNumberRef v91 = 0;
      }
      goto LABEL_142;
    }
LABEL_141:
    CFNumberRef v91 = 0;
LABEL_142:
    TDescriptorSource::CopySplicedDescriptorForName(FontNameForTextStyle, v118, v117, v116, v115, v114, (unint64_t *)&valuePtr, v112, v41, (const __CFNumber *)v113, v86, v91, v85, v110, (void *)atomic_load_explicit((atomic_ullong *volatile)&v122, memory_order_acquire));

    unint64_t v48 = v82;
LABEL_143:

    id v51 = v123;
    goto LABEL_144;
  }
  if (!v41) {
    goto LABEL_74;
  }
  unint64_t v48 = v35 | 0x402;
  TDescriptorSource::CreateDescriptorForUIFontDesign(v34, (TDescriptorSource *)&v125, v41, v48, v118, v117, v116, v115, (unint64_t *)&valuePtr, v114);

  id v51 = valuePtr;
LABEL_144:

LABEL_145:
  LOBYTE(v54) = 0;
  MatchableCFDictionaryRef Attributes = v119;
LABEL_146:
  unint64_t v92 = atomic_load_explicit(this, memory_order_acquire);
  if ((v54 & 1) != 0 || v92) {
    goto LABEL_150;
  }
  TDescriptorSource::CopyDescriptorForRequest(&v125, (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)a2 + 1, memory_order_acquire), MatchableAttributes, v34, v48, &valuePtr);
  unint64_t v16 = atomic_exchange((atomic_ullong *volatile)&valuePtr, 0);
LABEL_149:

LABEL_150:
  if (atomic_load_explicit(this, memory_order_acquire))
  {
    int v93 = *((_DWORD *)a2 + 4) & 0x7FFFFFFF;
    CFDictionaryRef v94 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)a2 + 1, memory_order_acquire);
    CFDictionaryRef v95 = v94;
    if (v94)
    {
      char v96 = (void *)CFDictionaryGetValue(v94, @"NSCTFontCharacterSetAttribute");
      unsigned int v97 = v96;
      if (v96)
      {
        CFTypeID v98 = CFGetTypeID(v96);
        if (v98 != CFCharacterSetGetTypeID()) {
          unsigned int v97 = 0;
        }
      }
    }
    else
    {
      unsigned int v97 = 0;
    }

    if (v97 || v93)
    {
      if (v97)
      {
        uint64_t valuePtr = @"NSCTFontCharacterSetAttribute";
        id values = v97;
        CFDictionaryRef v99 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&valuePtr, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        unsigned int v100 = (const CTFontDescriptor *)atomic_load_explicit(this, memory_order_acquire);
        uint64_t v101 = (CTFontDescriptor *)TCFBase<TDescriptor>::Allocate(96);
        if (v101)
        {
          CTFontDescriptor::CTFontDescriptor(v101, v100, v99, v93);
          uint64_t valuePtr = v102;
          id values = (id)atomic_exchange((atomic_ullong *volatile)&valuePtr, 0);
        }
        else
        {
          id values = 0;
        }

        id v109 = v99;
      }
      else
      {
        unsigned int v103 = (id)atomic_load_explicit(this, memory_order_acquire);
        uint64_t v104 = v103[5];

        if ((*(_DWORD *)(v104 + 16) & v93) != 0) {
          return;
        }
        unint64_t v105 = atomic_load_explicit(this, memory_order_acquire);
        uint64_t v106 = TCFBase<TDescriptor>::Allocate(96);
        if (v106)
        {
          uint64_t v107 = (__CFString *)v106;
          unsigned int v108 = (TDescriptor *)(v106 + 48);
          v107->datdouble a = 0;
          v107->CFIndex length = (uint64_t)TDescriptor::Hash;
          v107[1].unint64_t isa = 0;
          v107[1].info = (uint64_t)v108;
          TDescriptor::TDescriptor(v108, *(atomic_ullong **)(v105 + 40), v93);
          uint64_t valuePtr = v107;
          id values = (id)atomic_exchange((atomic_ullong *volatile)&valuePtr, 0);
        }
        else
        {
          id values = 0;
        }

        id v109 = values;
      }
    }
  }
}

void TDescriptor::CopyAttributes(atomic_ullong *this@<X0>, void *a2@<X8>)
{
  id v3 = (id)TDescriptor::GetAttributes(this, 1);
  *a2 = atomic_exchange((atomic_ullong *volatile)&v3, 0);
}

BOOL TCFBase<TDescriptor>::ClassEqual(uint64_t a1, uint64_t a2)
{
  return TDescriptor::Equal(*(atomic_ullong **)(a1 + 40), *(atomic_ullong **)(a2 + 40));
}

BOOL TDescriptor::Equal(atomic_ullong *this, atomic_ullong *a2)
{
  if (this == a2) {
    return 1;
  }
  unint64_t v4 = TDescriptor::Hash((TDescriptor *)this);
  if (v4 != TDescriptor::Hash((TDescriptor *)a2) || ((*((_DWORD *)a2 + 4) ^ *((_DWORD *)this + 4)) & 0x7FFCC408) != 0) {
    return 0;
  }
  if ((this[2] & 0x80000000) != 0 && (a2[2] & 0x80000000) != 0)
  {
    if ((this[2] & 0x80000000) == 0) {
      TDescriptor::InitBaseFont((TDescriptor *)this, 0, 0.0);
    }
    unint64_t explicit = atomic_load_explicit(this + 4, memory_order_acquire);
    if ((a2[2] & 0x80000000) == 0) {
      TDescriptor::InitBaseFont((TDescriptor *)a2, 0, 0.0);
    }
    unint64_t v10 = atomic_load_explicit(a2 + 4, memory_order_acquire);
    if (explicit && v10)
    {
      if ((*(unsigned int (**)(unint64_t))(*(void *)explicit + 32))(explicit)) {
        goto LABEL_9;
      }
    }
    else if (!(explicit | v10))
    {
      goto LABEL_9;
    }
    return 0;
  }
LABEL_9:
  uint64_t v5 = 1;
  CFDictionaryRef Attributes = (const void *)TDescriptor::GetAttributes(this, 1);
  uint64_t v8 = (const void *)TDescriptor::GetAttributes(a2, 1);
  if (Attributes != v8)
  {
    uint64_t v5 = 0;
    if (Attributes)
    {
      if (v8) {
        return CFEqual(Attributes, v8) != 0;
      }
    }
  }
  return v5;
}

unint64_t TDescriptor::GetAttributes(atomic_ullong *this, int a2)
{
  double v2 = this + 1;
  if (atomic_load_explicit(this + 1, memory_order_acquire)) {
    BOOL v3 = 1;
  }
  else {
    BOOL v3 = a2 == 0;
  }
  if (!v3)
  {
    if ((this[2] & 0x80000000) == 0) {
      TDescriptor::InitBaseFont((TDescriptor *)this, 0, 0.0);
    }
    unint64_t explicit = (atomic_ullong *)atomic_load_explicit(this + 4, memory_order_acquire);
    if (explicit)
    {
      TBaseFont::CreateDescriptorAttributes(explicit, (CFDictionaryRef *)&v10);
      unint64_t v6 = atomic_exchange((atomic_ullong *volatile)&v10, 0);

      uint64_t v7 = 0;
      atomic_compare_exchange_strong(this + 1, (unint64_t *)&v7, v6);
      if (v7) {
        uint64_t v8 = (void *)v6;
      }
      else {
        uint64_t v8 = 0;
      }
    }
  }
  return atomic_load_explicit(v2, memory_order_acquire);
}

unint64_t TFont::Hash(TFont *this)
{
  unint64_t v2 = *((void *)this + 2) + 2654435769;
  if (*((double *)this + 2) == 0.0) {
    unint64_t v2 = 2654435769;
  }
  unint64_t v3 = (*(unsigned int *)this + (v2 << 6) + (v2 >> 2) + 2654435769u) ^ v2;
  if (atomic_load_explicit((atomic_ullong *volatile)this + 1, memory_order_acquire)) {
    v3 ^= (v3 << 6)
  }
        + 2654435769u
        + (v3 >> 2)
        + TDescriptor::Hash(*(TDescriptor **)(atomic_load_explicit((atomic_ullong *volatile)this + 1, memory_order_acquire)+ 40));
  unint64_t v4 = (double *)*((void *)this + 5);
  if (v4)
  {
    double v5 = v4[1];
    double v6 = v4[2];
    double v7 = v4[3];
    double v8 = v4[4];
    double v9 = v4[5];
    BOOL v10 = *v4 == 0.0;
    unint64_t v11 = *(void *)v4 + 2654435769;
    if (v10) {
      unint64_t v11 = 2654435769;
    }
    uint64_t v12 = *(void *)&v5 + 2654435769;
    if (v5 == 0.0) {
      uint64_t v12 = 2654435769;
    }
    unint64_t v13 = ((v11 >> 2) + (v11 << 6) + v12) ^ v11;
    uint64_t v14 = *(void *)&v6 + 2654435769;
    if (v6 == 0.0) {
      uint64_t v14 = 2654435769;
    }
    unint64_t v15 = (v14 + (v13 << 6) + (v13 >> 2)) ^ v13;
    uint64_t v16 = *(void *)&v7 + 2654435769;
    if (v7 == 0.0) {
      uint64_t v16 = 2654435769;
    }
    unint64_t v17 = (v16 + (v15 << 6) + (v15 >> 2)) ^ v15;
    uint64_t v18 = *(void *)&v8 + 2654435769;
    if (v8 == 0.0) {
      uint64_t v18 = 2654435769;
    }
    unint64_t v19 = (v18 + (v17 << 6) + (v17 >> 2)) ^ v17;
    uint64_t v20 = *(void *)&v9 + 2654435769;
    if (v9 == 0.0) {
      uint64_t v20 = 2654435769;
    }
    v3 ^= (v3 << 6) + 2654435769u + (v3 >> 2) + ((v20 + (v19 << 6) + (v19 >> 2)) ^ v19);
  }
  if (atomic_load_explicit((atomic_ullong *volatile)this + 20, memory_order_acquire)) {
    v3 ^= (v3 << 6)
  }
        + 2654435769u
        + (v3 >> 2)
        + CFHash((CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)this + 20, memory_order_acquire));
  return v3;
}

unint64_t TDescriptor::Hash(TDescriptor *this)
{
  unint64_t v1 = *((void *)this + 3);
  if (!v1)
  {
    if ((*((_DWORD *)this + 4) & 0x80000000) == 0) {
      TDescriptor::InitBaseFont(this, 0, 0.0);
    }
    unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)this + 4, memory_order_acquire);
    if (explicit
      && (id v4 = (id)atomic_load_explicit((atomic_ullong *volatile)(explicit + 96), memory_order_acquire)) != 0)
    {
      double v5 = v4;
      CFHashCode v6 = CFHash(v4);
    }
    else
    {
      CFDictionaryRef Attributes = (const void *)TDescriptor::GetAttributes((atomic_ullong *)this, 1);
      CFHashCode v6 = CFHash(Attributes);
      double v5 = 0;
    }
    unint64_t v1 = (((v6 + 2654435769u) << 6) + ((v6 + 2654435769u) >> 2) + (*((_DWORD *)this + 4) & 0x7FFCC408) + 2654435769) ^ (v6 + 2654435769u);
    *((void *)this + 3) = v1;
  }
  return v1;
}

uint64_t TComponentFont::Equal(TComponentFont *this, const TBaseFont *a2)
{
  if (this == a2) {
    return 1;
  }
  int v4 = (*(uint64_t (**)(TComponentFont *))(*(void *)this + 16))(this);
  if (v4 != (*(unsigned int (**)(const TBaseFont *))(*(void *)a2 + 16))(a2)
    || *((_DWORD *)this + 178) != *((_DWORD *)a2 + 178))
  {
    return 0;
  }
  unint64_t explicit = (const void *)atomic_load_explicit((atomic_ullong *volatile)this + 93, memory_order_acquire);
  CFHashCode v6 = (const void *)atomic_load_explicit((atomic_ullong *volatile)a2 + 93, memory_order_acquire);
  if (explicit == v6) {
    return 1;
  }
  uint64_t result = 0;
  if (explicit)
  {
    if (v6)
    {
      uint64_t result = CFEqual(explicit, v6);
      if (result) {
        return 1;
      }
    }
  }
  return result;
}

uint64_t TTenuousComponentFont::GetType(TTenuousComponentFont *this)
{
  return 1414809156;
}

unint64_t TAttributes::GetScriptAndLangSys(atomic_ullong *this)
{
  if (atomic_load_explicit(this + 3, memory_order_acquire))
  {
    uint64_t v1 = ScriptAndLangSysFromCanonicalLanguage((__CFString *)atomic_load_explicit(this + 3, memory_order_acquire));
LABEL_6:
    unint64_t v2 = v1 & 0xFFFFFFFF00000000;
    return v1 | v2;
  }
  if ((*((_WORD *)this + 69) & 0x400) != 0)
  {
    uint64_t v1 = ScriptAndLangSysForPreferredLanguage();
    goto LABEL_6;
  }
  unint64_t v2 = 0;
  LODWORD(v1) = -1;
  return v1 | v2;
}

BOOL TFont::ShapesPreferredLanguage(atomic_ullong *this)
{
  CFDataRef explicit = (const __CFData *)atomic_load_explicit(this + 38, memory_order_acquire);
  if (!explicit) {
    return 0;
  }
  unint64_t v2 = ScriptAndLangSysForPreferredLanguage();
  unint64_t v3 = HIDWORD(v2);
  if (!HIDWORD(v2)) {
    return 0;
  }
  BytePtr = (__int32 *)CFDataGetBytePtr(explicit);
  CFIndex Length = CFDataGetLength(explicit);
  CFHashCode v6 = wmemchr(BytePtr, v3, Length >> 2);
  if (v6) {
    double v7 = v6;
  }
  else {
    double v7 = (__int32 *)((char *)BytePtr + Length);
  }
  return (char *)v7 - (char *)BytePtr != Length;
}

void TDescriptorSource::TDescriptorSource(TDescriptorSource *this)
{
  if (qword_1EB2CE200 != -1) {
    dispatch_once_f(&qword_1EB2CE200, 0, (dispatch_function_t)TDescriptorSource::GetCache(void)::{lambda(void *)#1}::__invoke);
  }
  int v2 = dword_1EB2CE16C;
  if (v2 != GetLocaleChangedCount())
  {
    objc_msgSend((id)atomic_load_explicit((atomic_ullong *volatile)qword_1EB2CE1F8, memory_order_acquire), "removeAllObjects");
    dword_1EB2CE16C = GetLocaleChangedCount();
  }
  *(void *)this = qword_1EB2CE1F8;
  if (qword_1EB2CE178 != -1) {
    dispatch_once_f(&qword_1EB2CE178, 0, (dispatch_function_t)TDescriptorSource::TDescriptorSource(void)::$_0::__invoke);
  }
}

uint64_t ScriptAndLangSysForPreferredLanguage(void)
{
  {
    ScriptAndLangSysForPreferredLanguage(void)::sPreferredunint64_t ScriptAndLangSys = 0xFFFFFFFFLL;
  }
  os_unfair_lock_lock_with_options();
  LocaleChangedCFIndex Count = GetLocaleChangedCount();
  if (ScriptAndLangSysForPreferredLanguage(void)::sLocaleChangedCount != LocaleChangedCount)
  {
    ScriptAndLangSysForPreferredLanguage(void)::sLocaleChangedCFIndex Count = LocaleChangedCount;
    CopyPreferredLanguage((atomic_ullong *)&v3);
    ScriptAndLangSysForPreferredLanguage(void)::sPreferredunint64_t ScriptAndLangSys = ScriptAndLangSysFromCanonicalLanguage((__CFString *)atomic_load_explicit((atomic_ullong *volatile)&v3, memory_order_acquire));
  }
  uint64_t v1 = ScriptAndLangSysForPreferredLanguage(void)::sPreferredScriptAndLangSys;
  os_unfair_lock_unlock(&ScriptAndLangSysForPreferredLanguage(void)::sLock);
  return v1;
}

uint64_t GetLocaleChangedCount(void)
{
  if (qword_1EB2CE288 != -1) {
    dispatch_once_f(&qword_1EB2CE288, 0, (dispatch_function_t)GetLocaleChangedCount(void)::$_0::__invoke);
  }
  return gLocaleChangedCount;
}

uint64_t AsMatchingOptions(int a1)
{
  if (qword_1EB2CE0B0 != -1) {
    dispatch_once_f(&qword_1EB2CE0B0, 0, (dispatch_function_t)TDescriptor::GetSystemUIFontOptions(void)::$_0::__invoke);
  }
  uint64_t v2 = a1 & 0x95;
  if ((_MergedGlobals_13 & a1) != 0) {
    v2 |= 0x400uLL;
  }
  return v2 | a1 & 0x10000;
}

uint64_t TSplicedFont::GetType(TSplicedFont *this)
{
  return 1414743620;
}

void TDescriptorSource::CopySplicedDescriptorForName(void *a1@<X1>, __CFString *a2@<X3>, const __CFNumber *a3@<X4>, const __CFNumber *a4@<X5>, uint64_t a5@<X6>, const void *a6@<X7>, unint64_t *a7@<X8>, const __CFNumber *a8, __CFString *a9, const __CFNumber *a10, const __CFNumber *a11, const __CFNumber *a12, const __CFNumber *a13, unsigned int a14, void *a15)
{
  unint64_t v19 = (TDescriptorSource *)os_unfair_lock_lock_with_options();
  TDescriptorSource::EnsureSplicedFontStash(v19);
  id v24 = (id)0xAAAAAAAAAAAAAAAALL;
  TDescriptorSource::CopySpliceFontForName((uint64_t *)&v24, a1, a2, a3, a4, a5, a6, a8, a9, a10, a11, a12, a13, a14, a15);
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&v24, memory_order_acquire);
  if (explicit) {
    unint64_t explicit = atomic_exchange((atomic_ullong *volatile)&v24, 0);
  }
  *a7 = explicit;

  os_unfair_lock_unlock((os_unfair_lock_t)&TDescriptorSource::sSplicedFontsLock);
}

void TDescriptorSource::CopySpliceFontForName(uint64_t *__return_ptr a1@<X8>, id a2@<X0>, __CFString *a3@<X1>, const __CFNumber *a4@<X2>, const __CFNumber *a5@<X3>, uint64_t a6@<X4>, const void *a7@<X5>, const __CFNumber *a8@<X6>, __CFString *a9@<X7>, const __CFNumber *a10, const __CFNumber *a11, const __CFNumber *a12, const __CFNumber *a13, unsigned int a14, void *a15)
{
  if (!TDescriptorSource::sSplicedFonts || (id v16 = a2) == 0)
  {
    *a1 = 0;
    return;
  }
  id v65 = a2;
  CFNumberRef v21 = (const void *)*MEMORY[0x1E4F1CFD0];
  if ((const void *)*MEMORY[0x1E4F1CFD0] == a7)
  {
    a6 = 0;
  }
  else if (a6 == -1)
  {
    a6 = _AXSEnhanceTextLegibilityEnabled() != 0;
  }
  CFStringRef v64 = a3;
  if (a3)
  {
    LODWORD(valuePtr.receiver) = 0;
    LocalizedTrimSetKey = GetLocalizedTrimSetKey(a3, (unsigned int *)&valuePtr);
    v67[0] = 0;
    CFNumberRef v23 = GetLocalizedTrimSetKey(0, v67);
    if (LocalizedTrimSetKey != v23 && (!LocalizedTrimSetKey || !v23 || !CFEqual(LocalizedTrimSetKey, v23))
      || LODWORD(valuePtr.receiver) != v67[0]
      || GetExuberatedGroupForLanguage(a3, 0))
    {
      goto LABEL_18;
    }
    id v24 = (void *)atomic_exchange((atomic_ullong *volatile)&v64, 0);
    goto LABEL_17;
  }
  if (CurrentLocaleIsExuberated())
  {
    valuePtr.unint64_t receiver = &v64;
    valuePtr.super_class = 0;
    _ExuberatedGroupForPreferredLanguages(0, (const __CFString **)&valuePtr.super_class);
    id v24 = (void *)atomic_exchange((atomic_ullong *volatile)valuePtr.receiver, (unint64_t)valuePtr.super_class);
LABEL_17:
  }
LABEL_18:
  uint64_t v59 = (uint64_t *)a3;
  if (a8)
  {
    valuePtr.unint64_t receiver = (id)0xAAAAAAAAAAAAAAAALL;
    CFNumberGetValue(a8, kCFNumberLongType, &valuePtr);
    unint64_t receiver = (unint64_t)valuePtr.receiver;
  }
  else
  {
    unint64_t receiver = 3;
  }
  if (a13)
  {
    LODWORD(valuePtr.receiver) = -1431655766;
    CFNumberGetValue(a13, kCFNumberIntType, &valuePtr);
    int v26 = (int)valuePtr.receiver;
  }
  else
  {
    int v26 = -1;
  }
  unsigned int v60 = v26;
  if (a12)
  {
    LODWORD(valuePtr.receiver) = -1431655766;
    CFNumberGetValue(a12, kCFNumberIntType, &valuePtr);
    uint64_t receiver_low = LODWORD(valuePtr.receiver);
  }
  else
  {
    uint64_t receiver_low = 0;
  }
  if (v21 == a7
    || a6
    || receiver != 3
    || (unint64_t v28 = atomic_load_explicit((atomic_ullong *volatile)&v64, memory_order_acquire), a13)
    || a15
    || a14
    || a5
    || a4
    || a11
    || a10
    || a9
    || v28
    || receiver_low)
  {
    unsigned int v29 = [_CTSplicedFontKey alloc];
    unint64_t explicit = (void *)atomic_load_explicit((atomic_ullong *volatile)&v64, memory_order_acquire);
    if (v29)
    {
      valuePtr.unint64_t receiver = v29;
      valuePtr.super_class = (Class)_CTSplicedFontKey;
      id v31 = objc_msgSendSuper2(&valuePtr, sel_init);
      if (v31)
      {
        *((void *)v31 + 4) = [v16 copy];
        *((void *)v31 + 5) = explicit;
        if (a4)
        {
          *(void *)CFRange v67 = -1;
          CFNumberGetValue(a4, kCFNumberDoubleType, v67);
          uint64_t v32 = *(void *)v67;
        }
        else
        {
          uint64_t v32 = 0x7FEFFFFFFFFFFFFFLL;
        }
        *((void *)v31 + 6) = v32;
        if (a5)
        {
          *(void *)CFRange v67 = -1;
          CFNumberGetValue(a5, kCFNumberDoubleType, v67);
          uint64_t v33 = *(void *)v67;
        }
        else
        {
          uint64_t v33 = 0x7FEFFFFFFFFFFFFFLL;
        }
        CFTypeID v58 = a7;
        *((void *)v31 + 7) = v33;
        *((unsigned char *)v31 + 16) = v21 == a7;
        *((void *)v31 + 8) = a6;
        *((void *)v31 + 9) = receiver;
        *((void *)v31 + 10) = a9;
        uint64_t v34 = a6;
        if (a10)
        {
          *(void *)CFRange v67 = -1;
          CFNumberGetValue(a10, kCFNumberDoubleType, v67);
          uint64_t v35 = *(void *)v67;
        }
        else
        {
          uint64_t v35 = 0x7FEFFFFFFFFFFFFFLL;
        }
        long long v36 = v16;
        *((void *)v31 + 11) = v35;
        long long v37 = v21;
        if (a11)
        {
          *(void *)CFRange v67 = -1;
          CFNumberGetValue(a11, kCFNumberDoubleType, v67);
          uint64_t v38 = *(void *)v67;
        }
        else
        {
          uint64_t v38 = 0x7FEFFFFFFFFFFFFFLL;
        }
        *((void *)v31 + 12) = v38;
        *((_DWORD *)v31 + 5) = receiver_low;
        *((_DWORD *)v31 + 6) = v60;
        *((_DWORD *)v31 + 7) = a14;
        *((void *)v31 + 13) = a15;
        uint64_t v39 = [v36 hash];
        uint64_t v40 = [explicit hash];
        uint64_t v41 = [(__CFString *)a9 hash];
        uint64_t v42 = [*((id *)v31 + 13) hash];
        double v43 = *((double *)v31 + 7);
        double v44 = *((double *)v31 + 11);
        double v45 = *((double *)v31 + 12);
        unint64_t v46 = *((void *)v31 + 6) + 2654435769;
        if (*((double *)v31 + 6) == 0.0) {
          unint64_t v46 = 2654435769;
        }
        uint64_t v47 = *(void *)&v43 + 2654435769;
        if (v43 == 0.0) {
          uint64_t v47 = 2654435769;
        }
        unint64_t v48 = ((v46 >> 2) + (v46 << 6) + v47) ^ v46;
        unint64_t v49 = (v34 + (v48 << 6) + (v48 >> 2) + 2654435769u) ^ v48;
        if (v37 == v58) {
          uint64_t v50 = 2654435770;
        }
        else {
          uint64_t v50 = 2654435769;
        }
        unint64_t v51 = (v50 + (v49 << 6) + (v49 >> 2)) ^ v49;
        unint64_t v52 = (receiver + (v51 << 6) + (v51 >> 2) + 2654435769u) ^ v51;
        uint64_t v53 = *(void *)&v44 + 2654435769;
        if (v44 == 0.0) {
          uint64_t v53 = 2654435769;
        }
        unint64_t v54 = (v53 + (v52 << 6) + (v52 >> 2)) ^ v52;
        uint64_t v55 = *(void *)&v45 + 2654435769;
        if (v45 == 0.0) {
          uint64_t v55 = 2654435769;
        }
        unint64_t v56 = (v55 + (v54 << 6) + (v54 >> 2)) ^ v54;
        unint64_t v57 = ((v56 << 6) + receiver_low + (v56 >> 2) + 2654435769u) ^ v56;
        id v16 = v36;
        a6 = v34;
        a7 = v58;
        *((void *)v31 + 1) = v40 ^ v39 ^ v41 ^ v42 ^ ((v57 << 6) + v60 + (v57 >> 2) + 2654435769u) ^ v57 ^ (((((v57 << 6) + v60 + (v57 >> 2) + 2654435769u) ^ v57) << 6) + a14 + ((((v57 << 6) + v60 + (v57 >> 2) + 2654435769u) ^ v57) >> 2) + 2654435769u);
      }
    }
    else
    {
      id v31 = 0;
    }
  }
  *a1 = 0xAAAAAAAAAAAAAAAALL;
  *a1 = (uint64_t)(id)CFDictionaryGetValue((CFDictionaryRef)TDescriptorSource::sSplicedFonts, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v65, memory_order_acquire));
  if (!atomic_load_explicit(a1, memory_order_acquire))
  {
    MakeSpliceDescriptor((TDescriptorSource *)v16, receiver, v59, a9, a10, a11, receiver_low, v60, &valuePtr, a14, a4, a5, a6, a7, (void *)atomic_load_explicit((atomic_ullong *volatile)&v65, memory_order_acquire), (uint64_t)a15);

    if (atomic_load_explicit(a1, memory_order_acquire)) {
      CFDictionarySetValue((CFMutableDictionaryRef)TDescriptorSource::sSplicedFonts, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v65, memory_order_acquire), (const void *)atomic_load_explicit(a1, memory_order_acquire));
    }
  }
}

BOOL CurrentLocaleIsExuberated(void)
{
  if (qword_1EB2CE290 != -1) {
    dispatch_once_f(&qword_1EB2CE290, 0, (dispatch_function_t)ExuberatedGroupForTallPseudolanguageIfEnabled(void)::$_0::__invoke);
  }
  return dword_1EB2CE268 || _ExuberatedGroupForPreferredLanguages(0, 0) != 0;
}

void TDescriptorSource::EnsureSplicedFontStash(TDescriptorSource *this)
{
  if (TDescriptorSource::sSplicedFonts)
  {
    if (TDescriptorSource::EnsureSplicedFontStash(void)::sGeneration == TGenerationSeed::sGeneration) {
      return;
    }
    TDescriptorSource::EnsureSplicedFontStash(void)::sGeneration = TGenerationSeed::sGeneration;
    CFRelease((CFTypeRef)TDescriptorSource::sSplicedFonts);
  }
  else
  {
    TDescriptorSource::EnsureSplicedFontStash(void)::sGeneration = TGenerationSeed::sGeneration;
  }
  id Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  id v1 = (id)atomic_exchange((atomic_ullong *volatile)&Mutable, 0);

  TDescriptorSource::sSplicedFonts = atomic_exchange((atomic_ullong *volatile)&v1, 0);
}

unint64_t TSplicedFont::GetOpticalSizeComponent(TSplicedFont *this, double a2)
{
  if (!*((void *)this + 77)) {
    return 0;
  }
  CFArrayRef v4 = (const __CFArray *)(id)atomic_load_explicit((atomic_ullong *volatile)this + 78, memory_order_acquire);
  CFArrayRef v5 = v4;
  CFIndex v6 = v4 ? CFArrayGetCount(v4) : 0;

  if (a2 + 0.01 <= 0.0 || v6 < 1) {
    return 0;
  }
  CFIndex v9 = 0;
  BOOL v10 = (double *)*((void *)this + 77);
  while (a2 + 0.01 < *v10)
  {
    ++v9;
    v10 += 7;
    if (v6 == v9)
    {
      CFArrayRef v11 = (const __CFArray *)(id)atomic_load_explicit((atomic_ullong *volatile)this + 78, memory_order_acquire);
      CFArrayRef v12 = v11;
      CFIndex v13 = v6 - 1;
      goto LABEL_15;
    }
  }
  CFArrayRef v11 = (const __CFArray *)(id)atomic_load_explicit((atomic_ullong *volatile)this + 78, memory_order_acquire);
  CFArrayRef v12 = v11;
  CFIndex v13 = v9;
LABEL_15:
  CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v11, v13);
  uint64_t v15 = *((void *)ValueAtIndex + 5);
  if ((*(_DWORD *)(v15 + 16) & 0x80000000) == 0) {
    TDescriptor::InitBaseFont(*((TDescriptor **)ValueAtIndex + 5), 0, 0.0);
  }
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(v15 + 32), memory_order_acquire);

  return explicit;
}

__CFString *TDescriptorSource::FindFontNameForNameAndTrait(TDescriptorSource *this, const __CFString *a2, uint64_t *a3, int a4)
{
  int v5 = (int)a3;
  int v6 = (int)a2;
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  v47.unint64_t isa = (void *)0xAAAAAAAAAAAAAAAALL;
  int v8 = TDescriptorSource::StashIndexForFontName(this, &v47, a3);
  uint64_t result = 0;
  if (!v8) {
    return result;
  }
  unint64_t isa = v47.isa;
  if ((uint64_t)v47.isa > 295) {
    return result;
  }
  if ((v5 & 0x40) != 0)
  {
    uint64_t v11 = 0;
    while ((void *)kCondensedMapping[v11] != v47.isa)
    {
      v11 += 44;
      if (v11 == 220) {
        goto LABEL_7;
      }
    }
    CFIndex v13 = &kCondensedMapping[v11];
LABEL_13:
    uint64_t result = (__CFString *)v13[2];
    if (result) {
      return result;
    }
    goto LABEL_14;
  }
LABEL_7:
  if ((unint64_t)v47.isa - 151 >= 5) {
    unsigned int v12 = -1;
  }
  else {
    unsigned int v12 = LODWORD(v47.isa) - 151;
  }
  if ((v12 & 0x80000000) == 0)
  {
    CFIndex v13 = &kCondensedMapping[44 * v12];
    goto LABEL_13;
  }
LABEL_14:
  if (v47.isa <= (void *)0x96)
  {
    uint64_t v15 = (char *)&kTypeHierarchySpecPhonePad + 336 * (uint64_t)v47.isa;
    BOOL v16 = (v15[16] & 0xE0) != 0;
    int v18 = *((_DWORD *)v15 + 2);
    int v17 = *((_DWORD *)v15 + 3);
    int v6 = v18 & 1 | (2 * v16);
    if (v17 == 1)
    {
      v6 |= 0x8000u;
    }
    else if (v17 == -1)
    {
      v6 |= 0x10000u;
    }
  }
  else
  {
    unint64_t v14 = (unint64_t)v47.isa - 156;
    if (v47.isa >= (void *)0x9C)
    {
      if (v14 < 0x16 || (unint64_t v14 = (unint64_t)v47.isa - 198, (unint64_t)v47.isa - 198 <= 0x13)) {
        int v6 = kOtherSpec[10 * v14 + 2] & 1 | (2 * (kOtherSpec[10 * v14 + 1] > 5));
      }
    }
  }
  int v19 = v6 & ~a4;
  char v20 = a4 & v5;
  int v21 = v19 | a4 & v5;
  switch((unint64_t)v47.isa)
  {
    case 0uLL:
    case 1uLL:
    case 2uLL:
    case 3uLL:
    case 0x79uLL:
    case 0x7AuLL:
    case 0x7BuLL:
    case 0x7CuLL:
    case 0x7DuLL:
    case 0x7EuLL:
      return (__CFString *)MapTightLooseTraits(v21, 0x37u, 0x64u, 0xEBu, 0xECu, 0x38u, 0x65u, 0xEDu, 0xEEu, 0xEFu, 0xEFu, 0xF0u, 0xF0u);
    case 4uLL:
    case 5uLL:
    case 6uLL:
    case 7uLL:
      uint64_t v35 = @".AppleSystemUIFaceShortItalicHeadline2";
      if ((v21 & 1) == 0) {
        uint64_t v35 = @".AppleSystemUIFaceShortHeadline2";
      }
      long long v36 = @".AppleSystemUIFaceHeadline2";
      if (v21) {
        long long v36 = @".AppleSystemUIFaceItalicHeadline2";
      }
      BOOL v37 = (v21 & 0x8000) == 0;
      goto LABEL_92;
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xBuLL:
    case 0xCuLL:
    case 0xDuLL:
    case 0xEuLL:
    case 0xFuLL:
    case 0x10uLL:
    case 0x11uLL:
    case 0x12uLL:
    case 0x13uLL:
      return (__CFString *)MapTightLooseTraits(v21, 0x3Eu, 0x40u, 0x3Du, 0x3Fu, 0x42u, 0x44u, 0x41u, 0x43u, 0x61u, 0x63u, 0x60u, 0x62u);
    case 0x14uLL:
    case 0x15uLL:
    case 0x16uLL:
    case 0x17uLL:
    case 0x18uLL:
    case 0x19uLL:
      unsigned int v22 = (v47.isa < (void *)0x19) & (0x1B00000u >> SLOBYTE(v47.isa));
      __int16 v23 = v21;
      int v24 = 70;
      int v25 = 71;
      int v26 = 69;
      int v27 = 73;
      int v28 = 74;
      int v29 = 72;
      goto LABEL_36;
    case 0x1AuLL:
    case 0x1BuLL:
    case 0x1CuLL:
    case 0x1DuLL:
    case 0x1EuLL:
    case 0x1FuLL:
      unsigned int v22 = (v47.isa < (void *)0x1F) & (0x6C000000u >> SLOBYTE(v47.isa));
      __int16 v23 = v21;
      int v24 = 76;
      int v25 = 77;
      int v26 = 75;
      int v27 = 79;
      int v28 = 80;
      int v29 = 78;
      goto LABEL_36;
    case 0x20uLL:
    case 0x21uLL:
    case 0x22uLL:
    case 0x23uLL:
    case 0x24uLL:
    case 0x25uLL:
      unsigned int v22 = (v47.isa < (void *)0x25) & (0x1B00000000uLL >> SLOBYTE(v47.isa));
      __int16 v23 = v21;
      int v24 = 82;
      int v25 = 83;
      int v26 = 81;
      int v27 = 85;
      int v28 = 86;
      int v29 = 84;
      goto LABEL_36;
    case 0x26uLL:
    case 0x27uLL:
    case 0x28uLL:
    case 0x29uLL:
    case 0x2AuLL:
    case 0x2BuLL:
    case 0x86uLL:
    case 0x87uLL:
    case 0x88uLL:
    case 0x89uLL:
    case 0x8AuLL:
      return (__CFString *)MapTightLooseTraits(v21, 0x58u, 0x59u, 0x57u, 0x133u, 0x5Bu, 0x5Cu, 0x5Au, 0x134u, 0x135u, 0x136u, 0x137u, 0x138u);
    case 0x2CuLL:
    case 0x2DuLL:
    case 0x2EuLL:
    case 0x41uLL:
    case 0x42uLL:
    case 0x43uLL:
    case 0x8CuLL:
    case 0x8DuLL:
    case 0x8EuLL:
    case 0x8FuLL:
    case 0x90uLL:
      return (__CFString *)MapTightLooseTraits(v21, 0x5Eu, 0x5Fu, 0x5Du, 0x139u, 0x81u, 0x82u, 0x80u, 0x13Au, 0x13Bu, 0x13Cu, 0x13Du, 0x13Eu);
    case 0x2FuLL:
    case 0x30uLL:
    case 0x31uLL:
    case 0x32uLL:
    case 0x33uLL:
    case 0x34uLL:
    case 0x35uLL:
    case 0x36uLL:
    case 0x37uLL:
    case 0x38uLL:
    case 0x39uLL:
    case 0x3AuLL:
      return (__CFString *)MapTightLooseTraits(v21, 0x6Eu, 0x6Fu, 0x70u, 0x71u, 0x72u, 0x73u, 0x74u, 0x75u, 0x76u, 0x77u, 0x78u, 0x79u);
    case 0x3BuLL:
    case 0x3CuLL:
    case 0x3DuLL:
    case 0x3EuLL:
    case 0x3FuLL:
    case 0x40uLL:
      unsigned int v22 = (v47.isa < (void *)0x40) & (0xD800000000000000 >> SLOBYTE(v47.isa));
      __int16 v23 = v21;
      int v24 = 123;
      int v25 = 124;
      int v26 = 122;
      int v27 = 126;
      int v28 = 127;
      int v29 = 125;
LABEL_36:
      return (__CFString *)MapTightTrait(v23, v22, v24, v25, v26, v27, v28, v29);
    case 0x44uLL:
    case 0x45uLL:
    case 0x46uLL:
    case 0x47uLL:
    case 0x48uLL:
    case 0x49uLL:
    case 0x4AuLL:
    case 0x4BuLL:
    case 0x4CuLL:
    case 0x4DuLL:
    case 0x4EuLL:
    case 0x4FuLL:
      return (__CFString *)MapTightLooseTraits(v21, 0xB6u, 0xB7u, 0xB8u, 0xB9u, 0xBAu, 0xBBu, 0xBCu, 0xBDu, 0xBEu, 0xBFu, 0xC0u, 0xC1u);
    case 0x50uLL:
    case 0x51uLL:
    case 0x52uLL:
    case 0x53uLL:
    case 0x54uLL:
    case 0x55uLL:
    case 0x56uLL:
    case 0x57uLL:
    case 0x58uLL:
    case 0x59uLL:
    case 0x5AuLL:
    case 0x5BuLL:
      return (__CFString *)MapTightLooseTraits(v21, 0xC2u, 0xC3u, 0xC4u, 0xC5u, 0xC6u, 0xC7u, 0xC8u, 0xC9u, 0xCAu, 0xCBu, 0xCCu, 0xCDu);
    case 0x5CuLL:
    case 0x5DuLL:
    case 0x5EuLL:
    case 0x5FuLL:
    case 0x60uLL:
    case 0x61uLL:
    case 0x62uLL:
    case 0x63uLL:
    case 0x64uLL:
    case 0x65uLL:
    case 0x66uLL:
    case 0x67uLL:
      return (__CFString *)MapTightLooseTraits(v21, 0xCEu, 0xCFu, 0xD0u, 0xD1u, 0xD2u, 0xD3u, 0xD4u, 0xD5u, 0xD6u, 0xD7u, 0xD8u, 0xD9u);
    case 0x6AuLL:
    case 0x70uLL:
    case 0x71uLL:
    case 0x72uLL:
      *(_OWORD *)&v47.info = xmmword_184B8AC30;
      uint64_t v38 = (TDescriptorSource *)*(unsigned int *)((unint64_t)&v47.info | (4 * (v21 & 3)));
      return (__CFString *)TDescriptorSource::UIFontNameForUIType(v38);
    case 0x73uLL:
    case 0x74uLL:
    case 0x75uLL:
    case 0x76uLL:
    case 0x77uLL:
    case 0x78uLL:
      return (__CFString *)MapTightLooseTraits(v21, 0xE5u, 0xE5u, 0xE6u, 0xE6u, 0xE7u, 0xE7u, 0xE8u, 0xE8u, 0xE9u, 0xE9u, 0xEAu, 0xEAu);
    case 0x7FuLL:
    case 0x80uLL:
      uint64_t v33 = @".AppleSystemUIFaceEmphasizedCaption3";
      uint64_t v34 = @".AppleSystemUIFaceCaption3";
      goto LABEL_131;
    case 0x81uLL:
    case 0x82uLL:
    case 0x91uLL:
    case 0x92uLL:
      uint64_t v35 = @".AppleSystemUIFaceEmphasizedItalicExtraLargeTitle";
      BOOL v39 = (v21 & 1) == 0;
      uint64_t v40 = @".AppleSystemUIFaceItalicExtraLargeTitle";
      if ((v21 & 1) == 0) {
        uint64_t v35 = @".AppleSystemUIFaceEmphasizedExtraLargeTitle";
      }
      long long v36 = @".AppleSystemUIFaceExtraLargeTitle";
      goto LABEL_89;
    case 0x83uLL:
    case 0x84uLL:
    case 0x93uLL:
    case 0x94uLL:
      uint64_t v35 = @".AppleSystemUIFaceEmphasizedItalicExtraLargeTitle2";
      BOOL v39 = (v21 & 1) == 0;
      uint64_t v40 = @".AppleSystemUIFaceItalicExtraLargeTitle2";
      if ((v21 & 1) == 0) {
        uint64_t v35 = @".AppleSystemUIFaceEmphasizedExtraLargeTitle2";
      }
      long long v36 = @".AppleSystemUIFaceExtraLargeTitle2";
LABEL_89:
      if (!v39) {
        long long v36 = v40;
      }
      BOOL v37 = (v21 & 2) == 0;
LABEL_92:
      if (v37) {
        return v36;
      }
      else {
        return v35;
      }
    case 0x95uLL:
    case 0x96uLL:
      uint64_t v33 = @".AppleSystemUIFacePreferredSize-Bold";
      uint64_t v34 = @".AppleSystemUIFacePreferredSize-Regular";
LABEL_131:
      BOOL v42 = (v21 & 2) == 0;
      goto LABEL_132;
    case 0x9CuLL:
    case 0x9DuLL:
    case 0x9EuLL:
    case 0x9FuLL:
    case 0xA5uLL:
    case 0xADuLL:
      if ((v21 & 0x40) != 0) {
        goto LABEL_47;
      }
      uint64_t result = @".AppleSystemUIFont";
      switch(v21 & 3)
      {
        case 1:
          uint64_t result = @".AppleSystemUIFontItalic";
          break;
        case 2:
          unint64_t v44 = (unint64_t)v47.isa & 0xFFFFFFFFFFFFFFF7;
          double v45 = @".AppleSystemUIFontEmphasized";
          unint64_t v46 = @".AppleSystemUIFontBold";
          goto LABEL_142;
        case 3:
          unint64_t v44 = (unint64_t)v47.isa & 0xFFFFFFFFFFFFFFF7;
          double v45 = @".AppleSystemUIFontEmphasizedItalic";
          unint64_t v46 = @".AppleSystemUIFontBoldItalic";
LABEL_142:
          if (v44 == 165) {
            uint64_t result = v46;
          }
          else {
            uint64_t result = v45;
          }
          break;
        default:
          return result;
      }
      return result;
    case 0xA0uLL:
    case 0xA8uLL:
LABEL_47:
      if ((v21 & 0x40) != 0) {
        goto LABEL_51;
      }
      uint64_t v33 = @".AppleSystemUIFontThinItalic";
      uint64_t v34 = @".AppleSystemUIFontThin";
      goto LABEL_113;
    case 0xA1uLL:
    case 0xA9uLL:
LABEL_51:
      if ((v21 & 0x40) != 0) {
        goto LABEL_55;
      }
      uint64_t v33 = @".AppleSystemUIFontLightItalic";
      uint64_t v34 = @".AppleSystemUIFontLight";
      goto LABEL_113;
    case 0xA2uLL:
    case 0xAAuLL:
LABEL_55:
      if ((v21 & 0x40) != 0) {
        goto LABEL_59;
      }
      uint64_t v33 = @".AppleSystemUIFontUltraLightItalic";
      uint64_t v34 = @".AppleSystemUIFontUltraLight";
      goto LABEL_113;
    case 0xA3uLL:
    case 0xABuLL:
LABEL_59:
      if ((v21 & 0x40) != 0) {
        goto LABEL_63;
      }
      uint64_t v33 = @".AppleSystemUIFontMediumItalic";
      uint64_t v34 = @".AppleSystemUIFontMedium";
      goto LABEL_113;
    case 0xA4uLL:
    case 0xACuLL:
LABEL_63:
      if ((v21 & 0x40) != 0) {
        goto LABEL_67;
      }
      v47.info = @".AppleSystemUIFont";
      v47.datdouble a = (char *)@".AppleSystemUIFontItalic";
      uint64_t v30 = @".AppleSystemUIFontDemi";
      id v31 = @".AppleSystemUIFontDemiItalic";
      goto LABEL_98;
    case 0xA6uLL:
    case 0xAEuLL:
LABEL_67:
      if ((v21 & 0x40) != 0) {
        goto LABEL_71;
      }
      v47.info = @".AppleSystemUIFont";
      v47.datdouble a = (char *)@".AppleSystemUIFontItalic";
      uint64_t v30 = @".AppleSystemUIFontHeavy";
      id v31 = @".AppleSystemUIFontHeavyItalic";
      goto LABEL_98;
    case 0xA7uLL:
    case 0xAFuLL:
LABEL_71:
      if ((v21 & 0x40) == 0)
      {
        v47.info = @".AppleSystemUIFont";
        v47.datdouble a = (char *)@".AppleSystemUIFontItalic";
        uint64_t v30 = @".AppleSystemUIFontBlack";
        id v31 = @".AppleSystemUIFontBlackItalic";
        goto LABEL_98;
      }
      uint64_t result = @".AppleSystemUIFontCondensed-Thin";
      switch((unint64_t)v47.isa)
      {
        case 0x9DuLL:
        case 0xA5uLL:
          uint64_t v33 = @".AppleSystemUIFontCondensed-Bold";
          uint64_t v34 = @".AppleSystemUIFontCondensed-Regular";
          goto LABEL_131;
        case 0xA0uLL:
          return result;
        case 0xA1uLL:
          uint64_t result = @".AppleSystemUIFontCondensed-Light";
          break;
        case 0xA2uLL:
          uint64_t result = @".AppleSystemUIFontCondensed-UltraLight";
          break;
        case 0xA3uLL:
          uint64_t result = @".AppleSystemUIFontCondensed-Medium";
          break;
        case 0xA4uLL:
          uint64_t result = @".AppleSystemUIFontCondensed-Semibold";
          break;
        case 0xA6uLL:
          uint64_t result = @".AppleSystemUIFontCondensed-Heavy";
          break;
        case 0xA7uLL:
          uint64_t result = @".AppleSystemUIFontCondensed-Black";
          break;
        default:
          goto LABEL_97;
      }
      break;
    case 0xB2uLL:
    case 0xB3uLL:
    case 0xB4uLL:
    case 0xB5uLL:
    case 0xBBuLL:
    case 0xC3uLL:
LABEL_97:
      v47.info = @".AppleSystemUIFontCompact-Regular";
      v47.datdouble a = (char *)@".AppleSystemUIFontCompact-Italic";
      uint64_t v30 = @".AppleSystemUIFontCompact-Bold";
      id v31 = @".AppleSystemUIFontCompact-BoldItalic";
      goto LABEL_98;
    case 0xB6uLL:
      uint64_t v33 = @".AppleSystemUIFontCompact-ThinItalic";
      uint64_t v34 = @".AppleSystemUIFontCompact-Thin";
      goto LABEL_113;
    case 0xB7uLL:
      uint64_t v33 = @".AppleSystemUIFontCompact-LightItalic";
      uint64_t v34 = @".AppleSystemUIFontCompact-Light";
      goto LABEL_113;
    case 0xB8uLL:
      uint64_t v33 = @".AppleSystemUIFontCompact-UltraLightItalic";
      uint64_t v34 = @".AppleSystemUIFontCompact-UltraLight";
      goto LABEL_113;
    case 0xB9uLL:
      uint64_t v33 = @".AppleSystemUIFontCompact-MediumItalic";
      uint64_t v34 = @".AppleSystemUIFontCompact-Medium";
      goto LABEL_113;
    case 0xBAuLL:
      v47.info = @".AppleSystemUIFontCompact-Regular";
      v47.datdouble a = (char *)@".AppleSystemUIFontCompact-Italic";
      uint64_t v30 = @".AppleSystemUIFontCompact-Semibold";
      id v31 = @".AppleSystemUIFontCompact-SemiboldItalic";
      goto LABEL_98;
    case 0xBCuLL:
      v47.info = @".AppleSystemUIFontCompact-Regular";
      v47.datdouble a = (char *)@".AppleSystemUIFontCompact-Italic";
      uint64_t v30 = @".AppleSystemUIFontCompact-Heavy";
      id v31 = @".AppleSystemUIFontCompact-HeavyItalic";
      goto LABEL_98;
    case 0xBDuLL:
      v47.info = @".AppleSystemUIFontCompact-Regular";
      v47.datdouble a = (char *)@".AppleSystemUIFontCompact-Italic";
      uint64_t v30 = @".AppleSystemUIFontCompact-Black";
      id v31 = @".AppleSystemUIFontCompact-BlackItalic";
      goto LABEL_98;
    case 0xC6uLL:
    case 0xC7uLL:
    case 0xC8uLL:
    case 0xC9uLL:
    case 0xCFuLL:
    case 0xD7uLL:
      if ((v21 & 0x40) != 0) {
        goto LABEL_49;
      }
      v47.info = @".AppleSystemUIFontCore-Regular";
      v47.datdouble a = (char *)@".AppleSystemUIFontCore-Italic";
      uint64_t v30 = @".AppleSystemUIFontCore-Bold";
      id v31 = @".AppleSystemUIFontCore-BoldItalic";
      goto LABEL_98;
    case 0xCAuLL:
    case 0xD2uLL:
LABEL_49:
      if ((v21 & 0x40) != 0) {
        goto LABEL_53;
      }
      uint64_t v33 = @".AppleSystemUIFontCore-ThinItalic";
      uint64_t v34 = @".AppleSystemUIFontCore-Thin";
      goto LABEL_113;
    case 0xCBuLL:
    case 0xD3uLL:
LABEL_53:
      if ((v21 & 0x40) != 0) {
        goto LABEL_57;
      }
      uint64_t v33 = @".AppleSystemUIFontCore-LightItalic";
      uint64_t v34 = @".AppleSystemUIFontCore-Light";
      goto LABEL_113;
    case 0xCCuLL:
    case 0xD4uLL:
LABEL_57:
      if ((v21 & 0x40) != 0) {
        goto LABEL_61;
      }
      uint64_t v33 = @".AppleSystemUIFontCore-UltraLightItalic";
      uint64_t v34 = @".AppleSystemUIFontCore-UltraLight";
      goto LABEL_113;
    case 0xCDuLL:
    case 0xD5uLL:
LABEL_61:
      if ((v21 & 0x40) != 0) {
        goto LABEL_65;
      }
      uint64_t v33 = @".AppleSystemUIFontCore-MediumItalic";
      uint64_t v34 = @".AppleSystemUIFontCore-Medium";
LABEL_113:
      BOOL v42 = (v21 & 1) == 0;
LABEL_132:
      if (v42) {
        return v34;
      }
      else {
        return v33;
      }
    case 0xCEuLL:
    case 0xD6uLL:
LABEL_65:
      if ((v21 & 0x40) != 0) {
        goto LABEL_69;
      }
      v47.info = @".AppleSystemUIFontCore-Regular";
      v47.datdouble a = (char *)@".AppleSystemUIFontCore-Italic";
      uint64_t v30 = @".AppleSystemUIFontCore-Semibold";
      id v31 = @".AppleSystemUIFontCore-SemiboldItalic";
      goto LABEL_98;
    case 0xD0uLL:
    case 0xD8uLL:
LABEL_69:
      if ((v21 & 0x40) != 0) {
        goto LABEL_73;
      }
      v47.info = @".AppleSystemUIFontCore-Regular";
      v47.datdouble a = (char *)@".AppleSystemUIFontCore-Italic";
      uint64_t v30 = @".AppleSystemUIFontCore-Heavy";
      id v31 = @".AppleSystemUIFontCore-HeavyItalic";
      goto LABEL_98;
    case 0xD1uLL:
    case 0xD9uLL:
LABEL_73:
      if ((v21 & 0x40) != 0)
      {
        uint64_t result = @".AppleSystemUIFontCoreCondensed-Thin";
        switch((unint64_t)v47.isa)
        {
          case 0xC7uLL:
          case 0xCFuLL:
            uint64_t v33 = @".AppleSystemUIFontCoreCondensed-Bold";
            uint64_t v34 = @".AppleSystemUIFontCoreCondensed-Regular";
            goto LABEL_131;
          case 0xCAuLL:
            return result;
          case 0xCBuLL:
            uint64_t result = @".AppleSystemUIFontCoreCondensed-Light";
            break;
          case 0xCCuLL:
            uint64_t result = @".AppleSystemUIFontCoreCondensed-UltraLight";
            break;
          case 0xCDuLL:
            uint64_t result = @".AppleSystemUIFontCoreCondensed-Medium";
            break;
          case 0xCEuLL:
            uint64_t result = @".AppleSystemUIFontCoreCondensed-Semibold";
            break;
          case 0xD0uLL:
            uint64_t result = @".AppleSystemUIFontCoreCondensed-Heavy";
            break;
          case 0xD1uLL:
            uint64_t result = @".AppleSystemUIFontCoreCondensed-Black";
            break;
          default:
            goto LABEL_103;
        }
      }
      else
      {
        v47.info = @".AppleSystemUIFontCore-Regular";
        v47.datdouble a = (char *)@".AppleSystemUIFontCore-Italic";
        uint64_t v30 = @".AppleSystemUIFontCore-Black";
        id v31 = @".AppleSystemUIFontCore-BlackItalic";
LABEL_98:
        v47.CFIndex length = (uint64_t)v30;
        unint64_t v48 = v31;
        uint64_t result = (__CFString *)*(&v47.info + (v21 & 3));
      }
      break;
    case 0xDAuLL:
    case 0xDBuLL:
    case 0xDCuLL:
    case 0xDDuLL:
    case 0xDEuLL:
      goto LABEL_135;
    case 0xE3uLL:
    case 0xE4uLL:
    case 0xE5uLL:
    case 0xE6uLL:
    case 0xE7uLL:
      uint64_t v32 = @".AppleSystemUIFontCompactRounded-Semibold";
      goto LABEL_136;
    case 0xECuLL:
LABEL_103:
      int v41 = v21 & 0x42;
      if (v41 != 66) {
        goto LABEL_118;
      }
      return @".AppleSystemUIFontCondensed-Bold";
    case 0xEDuLL:
      int v41 = v21 & 0x42;
LABEL_118:
      if (v41 != 64) {
        goto LABEL_120;
      }
      return @".AppleSystemUIFontCondensed-Regular";
    case 0xEEuLL:
    case 0xEFuLL:
    case 0xF0uLL:
    case 0xF1uLL:
    case 0xF2uLL:
    case 0xF3uLL:
    case 0xF4uLL:
LABEL_120:
      if ((v21 & 0x40) != 0) {
        goto LABEL_123;
      }
      uint64_t result = @".AppleSystemUIFontThin";
      switch((unint64_t)v47.isa)
      {
        case 0xECuLL:
        case 0xEDuLL:
          uint64_t v33 = @".AppleSystemUIFontBold";
          uint64_t v34 = @".AppleSystemUIFont";
          goto LABEL_131;
        case 0xEEuLL:
          return result;
        case 0xEFuLL:
          uint64_t result = @".AppleSystemUIFontLight";
          break;
        case 0xF0uLL:
          uint64_t result = @".AppleSystemUIFontUltraLight";
          break;
        case 0xF1uLL:
          uint64_t result = @".AppleSystemUIFontMedium";
          break;
        case 0xF2uLL:
          uint64_t result = @".AppleSystemUIFontDemi";
          break;
        case 0xF3uLL:
          uint64_t result = @".AppleSystemUIFontHeavy";
          break;
        case 0xF4uLL:
          uint64_t result = @".AppleSystemUIFontBlack";
          break;
        default:
          goto LABEL_123;
      }
      return result;
    case 0xF5uLL:
LABEL_123:
      int v43 = v21 & 0x42;
      if (v43 != 66) {
        goto LABEL_126;
      }
      return @".AppleSystemUIFontCoreCondensed-Bold";
    case 0xF6uLL:
      int v43 = v21 & 0x42;
LABEL_126:
      if (v43 != 64) {
        goto LABEL_128;
      }
      return @".AppleSystemUIFontCoreCondensed-Regular";
    case 0xF7uLL:
    case 0xF8uLL:
    case 0xF9uLL:
    case 0xFAuLL:
    case 0xFBuLL:
    case 0xFCuLL:
    case 0xFDuLL:
LABEL_128:
      if ((v21 & 0x40) != 0)
      {
LABEL_135:
        uint64_t v32 = @".AppleSystemUIFontRounded-Semibold";
LABEL_136:
        if ((v21 & 2) != 0) {
          return v32;
        }
        else {
          return (__CFString *)this;
        }
      }
      else
      {
        uint64_t result = @".AppleSystemUIFontCore-Thin";
        switch((unint64_t)v47.isa)
        {
          case 0xF5uLL:
          case 0xF6uLL:
            uint64_t v33 = @".AppleSystemUIFontCore-Bold";
            uint64_t v34 = @".AppleSystemUIFontCore-Regular";
            goto LABEL_131;
          case 0xF7uLL:
            return result;
          case 0xF8uLL:
            uint64_t result = @".AppleSystemUIFontCore-Light";
            break;
          case 0xF9uLL:
            uint64_t result = @".AppleSystemUIFontCore-UltraLight";
            break;
          case 0xFAuLL:
            uint64_t result = @".AppleSystemUIFontCore-Medium";
            break;
          case 0xFBuLL:
            uint64_t result = @".AppleSystemUIFontCore-Semibold";
            break;
          case 0xFCuLL:
            uint64_t result = @".AppleSystemUIFontCore-Heavy";
            break;
          case 0xFDuLL:
            uint64_t result = @".AppleSystemUIFontCore-Black";
            break;
          default:
            goto LABEL_135;
        }
      }
      return result;
    default:
      uint64_t result = FindSerifWithTraits((unint64_t)v47.isa, v19 | v20, a4);
      if (!result)
      {
        uint64_t result = FindMonospacedWithTraits((unint64_t)isa, v21, a4);
        if (!result) {
          return (__CFString *)this;
        }
      }
      return result;
  }
  return result;
}

uint64_t MapTightLooseTraits(int a1, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int a5, unsigned int a6, unsigned int a7, unsigned int a8, unsigned int a9, unsigned int a10, unsigned int a11, unsigned int a12, unsigned int a13)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if ((a1 & 0x18000) == 0x10000)
  {
    unsigned int v15 = a10;
    unsigned int v16 = a11;
    unsigned int v17 = a12;
    unsigned int v18 = a13;
  }
  else if ((a1 & 0x18000) == 0x8000)
  {
    unsigned int v15 = a6;
    unsigned int v16 = a7;
    unsigned int v17 = a8;
    unsigned int v18 = a9;
  }
  else
  {
    unsigned int v15 = a2;
    unsigned int v16 = a3;
    unsigned int v17 = a4;
    unsigned int v18 = a5;
  }
  CFIndex v13 = (TDescriptorSource *)*(&v15 + (a1 & 3));

  return TDescriptorSource::UIFontNameForUIType(v13);
}

void TBaseFont::CreateVariantWithSymbolicTraits(atomic_ullong *this@<X0>, unsigned int *a2@<X1>, const __CTFontDescriptor *a3@<X3>, int a4@<W2>, void *a5@<X8>)
{
  v115[1] = *MEMORY[0x1E4F143B8];
  CFIndex v9 = (TDescriptor *)(*(uint64_t (**)(atomic_ullong *))(*this + 160))(this);
  int v10 = (int)v9;
  uint64_t v11 = (uint64_t *)*a2;
  uint64_t v12 = *((void *)a3 + 5);
  int v13 = *(_DWORD *)(v12 + 16);
  int v14 = TDescriptor::GetSystemUIFontOptions(v9) & v13;
  if ((v11 ^ v10) & a4 | v14)
  {
    id Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    unsigned int v15 = *a2 & a4 | v10 & ~a4;
    *a2 = v15;
    if (v14) {
      int v16 = (v15 >> 10) & 1;
    }
    else {
      int v16 = 0;
    }
    if (v14 && ((v15 & 0x400) == 0 || (v10 & 0x400) != 0))
    {
      if (TBaseFont::SystemUIFontAttributesForSymbolicTraits((TBaseFont *)this, (atomic_ullong *)&Mutable, v11, a4, (const TDescriptor *)v12))
      {
        *(double *)&id v110 = COERCE_DOUBLE(atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire));
        LODWORD(v108) = 1028;
        TCFBase_NEW<CTFontDescriptor,__CFDictionary const*&,unsigned int &>((const __CFDictionary **)&v110, (int *)&v108, &valuePtr);
        *a5 = atomic_exchange((atomic_ullong *volatile)&valuePtr, 0);
        id v17 = valuePtr;
LABEL_137:

        id v18 = Mutable;
        goto LABEL_138;
      }
      unsigned int v15 = *a2;
    }
    *a2 = v15 & 0xFFFE7FFF;
    id v108 = (id)0xAAAAAAAAAAAAAAAALL;
    atomic_load_explicit((atomic_ullong *volatile)(v12 + 8), memory_order_acquire);
    CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)(v12 + 8), memory_order_acquire);
    if (explicit) {
      CFDictionaryRef explicit = (const __CFDictionary *)CFDictionaryGetValue(explicit, @"NSFontFamilyAttribute");
    }
    id v108 = explicit;
    TDescriptor::CopyAttribute((atomic_ullong *)v12, @"NSCTFontTraitsAttribute", &valuePtr);
    id v98 = (id)atomic_exchange((atomic_ullong *volatile)&valuePtr, 0);

    if (atomic_load_explicit((atomic_ullong *volatile)&v108, memory_order_acquire)) {
      int v21 = v16;
    }
    else {
      int v21 = 1;
    }
    if (v21 == 1)
    {
      if (v16)
      {
        CFDictionaryRef Value = @"NSCTFontUIFontDesignMonospaced";
        if (!@"NSCTFontUIFontDesignMonospaced") {
          goto LABEL_26;
        }
        goto LABEL_25;
      }
      CFDictionaryRef v23 = (const __CFDictionary *)v98;
      CFDictionaryRef v24 = v23;
      if (v23) {
        CFDictionaryRef Value = (__CFString *)CFDictionaryGetValue(v23, @"NSCTFontUIFontDesignTrait");
      }
      else {
        CFDictionaryRef Value = 0;
      }

      if (Value)
      {
LABEL_25:
        UIFontFamilyNameForDesign = TDescriptorSource::GetUIFontFamilyNameForDesign(Value, v20);
        TCFRef<__CTFont const*>::Retain((atomic_ullong *)&v108, UIFontFamilyNameForDesign);
      }
    }
LABEL_26:
    CFDictionaryRef v95 = a3;
    CFDictionaryRef v99 = (TDescriptor *)v12;
    id v107 = (id)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(id *__return_ptr, atomic_ullong *))(*this + 120))(&v107, this);
    id v106 = (id)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(id *__return_ptr, atomic_ullong *))(*this + 112))(&v106, this);
    id v105 = 0;
    CFArrayRef v26 = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v107, memory_order_acquire);
    double v27 = 0.0;
    unsigned int v100 = a2;
    int v96 = v14;
    char v93 = a4;
    if (v26 && (CFIndex Count = CFArrayGetCount(v26)) != 0)
    {
      CFIndex v29 = Count;
      CFNumberRef v102 = 0;
      CFIndex v30 = 0;
      double v31 = 0.0;
      double v32 = 0.0;
      do
      {
        CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v26, v30);
        uint64_t v34 = CFDictionaryGetValue(ValueAtIndex, @"NSCTVariationAxisIdentifier");
        if (v34)
        {
          uint64_t v35 = v34;
          if (CFEqual(v34, &unk_1ED082E00))
          {
            TCFRef<__CTFont const*>::Retain((atomic_ullong *)&v105, ValueAtIndex);
          }
          else if (CFEqual(v35, &unk_1ED082DD0))
          {
            CFNumberRef v36 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, @"NSCTVariationAxisMaximumValue");
            CFNumberRef v37 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, @"NSCTVariationAxisMinimumValue");
            CFDictionaryRef v38 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)&v106, memory_order_acquire);
            CFDictionaryRef v39 = v38;
            CFNumberRef v40 = v38 ? (const __CFNumber *)CFDictionaryGetValue(v38, &unk_1ED082DD0) : 0;

            CFNumberRef v41 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, @"NSCTVariationAxisDefaultValue");
            CFNumberRef v102 = v41;
            CFNumberRef v42 = v40 ? v40 : v41;
            if (v36 && v37 && v42 && !CFEqual(v36, v37))
            {
              *(double *)&id valuePtr = NAN;
              CFNumberGetValue(v36, kCFNumberDoubleType, &valuePtr);
              double v32 = *(double *)&valuePtr;
              *(double *)&id valuePtr = NAN;
              CFNumberGetValue(v37, kCFNumberDoubleType, &valuePtr);
              double v31 = *(double *)&valuePtr;
              *(double *)&id valuePtr = NAN;
              CFNumberGetValue(v42, kCFNumberDoubleType, &valuePtr);
              double v27 = (*(double *)&valuePtr - v31) / (v32 - v31);
            }
          }
        }
        ++v30;
      }
      while (v29 != v30);
    }
    else
    {
      CFNumberRef v102 = 0;
      double v32 = 0.0;
      double v31 = 0.0;
    }
    if (!atomic_load_explicit((atomic_ullong *volatile)&v108, memory_order_acquire))
    {
      (*(void (**)(id *__return_ptr, atomic_ullong *, __CFString *))(*this + 72))(&valuePtr, this, @"CTFontSyntheticFamilyName");
    }
    if (!atomic_load_explicit((atomic_ullong *volatile)&v108, memory_order_acquire)
      && !atomic_load_explicit((atomic_ullong *volatile)&v105, memory_order_acquire))
    {
      *a5 = 0;
LABEL_136:

      id v17 = v108;
      goto LABEL_137;
    }
    uint64_t v43 = (*(uint64_t (**)(atomic_ullong *))(*this + 776))(this);
    if ((v93 & 2) != 0 && !v43)
    {
      unint64_t v44 = v100;
      double v45 = 0.400000006;
      if ((*(unsigned char *)v100 & 2) == 0) {
        double v45 = 0.0;
      }
LABEL_67:
      float v50 = v45;
      if ((*(unsigned int (**)(atomic_ullong *))(*this + 696))(this)) {
        int v51 = 2;
      }
      else {
        int v51 = 0;
      }
      int v52 = *((_DWORD *)v99 + 4);
      id v104 = (id)0xAAAAAAAAAAAAAAAALL;
      TDescriptorSource::TDescriptorSource((TDescriptorSource *)&valuePtr);
      if (v96) {
        int v53 = v51 | 0x400;
      }
      else {
        int v53 = v51;
      }
      CFStringRef v54 = (const __CFString *)atomic_load_explicit((atomic_ullong *volatile)&v108, memory_order_acquire);
      if (v96) {
        uint64_t v55 = v95;
      }
      else {
        uint64_t v55 = 0;
      }
      int v97 = v53 | v52 & 0x10000;
      TDescriptorSource::CopyMatchingDescriptorsForFamily((TDescriptorSource *)&valuePtr, v54, &v104);
      *(void *)&long long v56 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v56 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v114[14] = v56;
      v114[13] = v56;
      v114[12] = v56;
      v114[11] = v56;
      v114[10] = v56;
      v114[9] = v56;
      v114[8] = v56;
      v114[7] = v56;
      v114[6] = v56;
      v114[5] = v56;
      v114[4] = v56;
      v114[3] = v56;
      v114[2] = v56;
      v114[1] = v56;
      v114[0] = v56;
      CFNumberRef v112 = 0;
      unint64_t v113 = 0;
      *(double *)&id valuePtr = 0.0;
      v115[0] = v114;
      *v44 &= 0xFFFBBFFu;
      CFArrayRef v57 = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v104, memory_order_acquire);
      float v94 = v50;
      if (v57 && (CFTypeID v58 = v44, (v59 = CFArrayGetCount(v57)) != 0))
      {
        CFIndex v60 = v59;
        CFIndex v61 = 0;
        double v62 = v50;
        double v63 = INFINITY;
        do
        {
          CFStringRef v64 = (TDescriptor **)CFArrayGetValueAtIndex(v57, v61);
          id v65 = (const __CTFontDescriptor *)v64;
          uint64_t v66 = v64[5];
          if ((*((_DWORD *)v66 + 4) & 0x80000000) == 0) {
            TDescriptor::InitBaseFont(v64[5], 0, 0.0);
          }
          CFRange v67 = (atomic_ullong *)atomic_load_explicit((atomic_ullong *volatile)v66 + 4, memory_order_acquire);
          if (v67)
          {
            uint64_t TraitsValues = atomic_load_explicit(v67 + 30, memory_order_acquire);
            if (!TraitsValues) {
              uint64_t TraitsValues = TBaseFont::CreateTraitsValues((TBaseFont *)v67);
            }
            if (TraitsValues && *v58 == (*(_DWORD *)TraitsValues & 0xFFFBBFF))
            {
              CFDictionaryRef v69 = v112;
              if (v112 >= v113)
              {
                uint64_t v71 = (v112 - (unsigned char *)valuePtr) >> 3;
                if ((unint64_t)(v71 + 1) >> 61) {
                  abort();
                }
                unint64_t v72 = (v113 - (unsigned char *)valuePtr) >> 2;
                if (v72 <= v71 + 1) {
                  unint64_t v72 = v71 + 1;
                }
                unint64_t v73 = (unint64_t)(v113 - (unsigned char *)valuePtr) >= 0x7FFFFFFFFFFFFFF8 ? 0x1FFFFFFFFFFFFFFFLL : v72;
                if (v73)
                {
                  unint64_t v74 = (char *)v115[0];
                  if (v115[0] + 8 * v73 <= (unint64_t)v115)
                  {
                    v115[0] += 8 * v73;
                  }
                  else
                  {
                    if (v73 >> 61) {
                      std::__throw_bad_array_new_length[abi:nn180100]();
                    }
                    unint64_t v74 = (char *)operator new(8 * v73);
                  }
                }
                else
                {
                  unint64_t v74 = 0;
                }
                unsigned int v75 = &v74[8 * v71];
                *(void *)unsigned int v75 = v65;
                uint64_t v70 = v75 + 8;
                uint64_t v77 = valuePtr;
                char v76 = v112;
                if (v112 != valuePtr)
                {
                  do
                  {
                    uint64_t v78 = *--v76;
                    *((void *)v75 - 1) = v78;
                    v75 -= 8;
                  }
                  while (v76 != v77);
                  char v76 = valuePtr;
                }
                id valuePtr = v75;
                CFNumberRef v112 = v70;
                CFNumberRef v79 = v113;
                unint64_t v113 = &v74[8 * v73];
                if (v76)
                {
                  CFTypeID v58 = v100;
                  if (v114 <= (_OWORD *)v76 && v115 > v76)
                  {
                    if (v79 == (char *)v115[0]) {
                      v115[0] = v76;
                    }
                  }
                  else
                  {
                    operator delete(v76);
                  }
                }
                else
                {
                  CFTypeID v58 = v100;
                }
              }
              else
              {
                *(void *)CFNumberRef v112 = v65;
                uint64_t v70 = v69 + 8;
              }
              CFNumberRef v112 = v70;
              double v81 = (*(double *)(TraitsValues + 8) - v62) * (*(double *)(TraitsValues + 8) - v62);
              if (v32 > v31)
              {
                id v103 = (id)0xAAAAAAAAAAAAAAAALL;
                (*(void (**)(id *__return_ptr, atomic_ullong *))(*v67 + 112))(&v103, v67);
                CFDictionaryRef v82 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)&v103, memory_order_acquire);
                CFDictionaryRef v83 = v82;
                if (v82) {
                  CFNumberRef v84 = (const __CFNumber *)CFDictionaryGetValue(v82, &unk_1ED082DD0);
                }
                else {
                  CFNumberRef v84 = 0;
                }

                if (v84) {
                  CFNumberRef v85 = v84;
                }
                else {
                  CFNumberRef v85 = v102;
                }
                *(double *)&id v110 = NAN;
                CFNumberGetValue(v85, kCFNumberDoubleType, &v110);
                double v81 = v81
                    + (v27 - (*(double *)&v110 - v31) / (v32 - v31)) * (v27 - (*(double *)&v110 - v31) / (v32 - v31));
              }
              if (v63 > v81)
              {
                uint64_t v55 = v65;
                double v63 = v81;
                if (fabs(v81) < 0.001) {
                  break;
                }
              }
            }
          }
          ++v61;
          id v65 = v55;
        }
        while (v61 != v60);
      }
      else
      {
        id v65 = v55;
      }
      TDescriptor::CopyAttribute((atomic_ullong *)v99, @"NSFontSizeAttribute", &v110);
      CFNumberRef v86 = (void *)atomic_exchange((atomic_ullong *volatile)&v110, 0);

      if (v65)
      {
        id v103 = v65;
        *(double *)&id v110 = COERCE_DOUBLE(atomic_exchange((atomic_ullong *volatile)&v103, 0));
        CFNumberRef v87 = a5;
LABEL_129:
        TDescriptorSource::CopyFontDescriptorWithOptions((atomic_ullong *)&v110, v97, v86, v87);

        id v88 = v103;
LABEL_130:

        goto LABEL_131;
      }
      if (valuePtr != v112)
      {
        id v103 = *(id *)valuePtr;
        *(double *)&id v110 = COERCE_DOUBLE(atomic_exchange((atomic_ullong *volatile)&v103, 0));
        CFNumberRef v87 = a5;
        goto LABEL_129;
      }
      if (atomic_load_explicit((atomic_ullong *volatile)&v105, memory_order_acquire))
      {
        double v89 = (double)ClassOfWeight(v94);
        CFDictionaryRef v90 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)&v106, memory_order_acquire);
        if (v90)
        {
          CFDictionaryRef v91 = v90;
          CFNumberRef v92 = (const __CFNumber *)CFDictionaryGetValue(v90, &unk_1ED082E00);

          if (v92)
          {
            *(double *)&id v110 = NAN;
            CFNumberGetValue(v92, kCFNumberDoubleType, &v110);
            if (vabdd_f64(*(double *)&v110, v89) < 0.001) {
              goto LABEL_147;
            }
          }
        }
        else
        {
        }
        CopyVariationWithValue((const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v106, memory_order_acquire), (const __CFNumber *)&unk_1ED082E00, v89, &v110);

        if (IsValueInRangeOfAxis(v89, (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v105, memory_order_acquire)))
        {
          *(double *)&id v110 = -3.72066208e-103;
          atomic_load_explicit((atomic_ullong *volatile)&v106, memory_order_acquire);
          TCFBase_NEW<CTFontDescriptor,TBaseFont const*,__CFDictionary const*,unsigned int>(&v103);
          *(double *)&id v110 = COERCE_DOUBLE(atomic_exchange((atomic_ullong *volatile)&v103, 0));

          TDescriptorSource::CopyFontDescriptorWithOptions((atomic_ullong *)&v110, v97, v86, a5);
          id v88 = v110;
          goto LABEL_130;
        }
      }
LABEL_147:
      *a5 = 0;
LABEL_131:

      if (*(double *)&valuePtr != 0.0)
      {
        CFNumberRef v112 = (char *)valuePtr;
        if (v114 > valuePtr || v115 <= valuePtr) {
          operator delete(valuePtr);
        }
      }

      goto LABEL_136;
    }
    uint64_t v46 = atomic_load_explicit(this + 30, memory_order_acquire);
    if (!v46) {
      uint64_t v46 = TBaseFont::CreateTraitsValues((TBaseFont *)this);
    }
    CFDictionaryRef v47 = (const __CFDictionary *)v98;
    if (v47)
    {
      CFDictionaryRef v48 = v47;
      CFNumberRef v49 = (const __CFNumber *)CFDictionaryGetValue(v47, @"NSCTFontWeightTrait");

      if (v49)
      {
        LODWORD(valuePtr) = -1;
        CFNumberGetValue(v49, kCFNumberFloatType, &valuePtr);
        double v45 = *(float *)&valuePtr;
LABEL_66:
        unint64_t v44 = v100;
        goto LABEL_67;
      }
    }
    else
    {
    }
    if (v46) {
      double v45 = *(double *)(v46 + 8);
    }
    else {
      double v45 = 0.0;
    }
    goto LABEL_66;
  }
  *(double *)&id valuePtr = COERCE_DOUBLE(a3);
  *a5 = atomic_exchange((atomic_ullong *volatile)&valuePtr, 0);
  id v18 = valuePtr;
LABEL_138:
}

void TDescriptorSource::CreateDescriptorForUIFontDesign(CFDictionaryRef theDict@<X2>, TDescriptorSource *a2@<X0>, __CFString *a3@<X1>, uint64_t a4@<X3>, __CFString *a5@<X4>, const __CFNumber *a6@<X5>, const __CFNumber *a7@<X6>, uint64_t a8@<X7>, unint64_t *a9@<X8>, const void *a10)
{
  if (!theDict) {
    goto LABEL_65;
  }
  CFIndex Count = CFDictionaryGetCount(theDict);
  unint64_t v18 = Count - 1;
  if (Count < 1) {
    goto LABEL_65;
  }
  unint64_t v19 = Count;
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, @"NSCTFontWeightTrait");
  if (Value)
  {
    valuePtr[0] = (const void *)-1;
    CFNumberGetValue(Value, kCFNumberDoubleType, valuePtr);
    double v22 = *(double *)valuePtr;
    unint64_t v19 = v18;
  }
  else
  {
    double v22 = 0.0;
  }
  if (v19 < 2)
  {
    CFStringRef v64 = a2;
    BOOL v25 = 0;
    CFNumberRef v26 = 0;
    CFNumberRef v27 = 0;
    goto LABEL_37;
  }
  CFNumberRef v23 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"NSCTFontSlantTrait");
  CFNumberRef v24 = v23;
  if (v23)
  {
    --v19;
    valuePtr[0] = (const void *)-1;
    CFNumberGetValue(v23, kCFNumberDoubleType, valuePtr);
    BOOL v25 = *(double *)valuePtr != 0.0;
    if (v19 < 2)
    {
      CFNumberRef v27 = 0;
      CFNumberRef v29 = 0;
      goto LABEL_55;
    }
    BOOL v61 = *(double *)valuePtr != 0.0;
  }
  else
  {
    BOOL v61 = 0;
  }
  CFNumberRef v28 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"NSCTFontProportionTrait");
  CFStringRef v64 = a2;
  if (v28)
  {
    valuePtr[0] = (const void *)-1;
    CFNumberRef v26 = v28;
    CFNumberGetValue(v28, kCFNumberDoubleType, valuePtr);
    if (*(double *)valuePtr == 0.0 && --v19 < 2)
    {
      CFNumberRef v27 = 0;
      CFNumberRef v29 = v26;
      a2 = v64;
      BOOL v25 = v61;
      goto LABEL_55;
    }
  }
  else
  {
    CFNumberRef v26 = 0;
  }
  CFNumberRef v30 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"NSCTFontSymbolicTrait");
  if (v30)
  {
    LODWORD(valuePtr[0]) = -1431655766;
    CFNumberGetValue(v30, kCFNumberIntType, valuePtr);
    if (v26) {
      BOOL v31 = v22 == 0.0;
    }
    else {
      BOOL v31 = 1;
    }
    if (!v31 && v24 != 0 || LODWORD(valuePtr[0]) == 0)
    {
      BOOL v25 = v61;
LABEL_33:
      if (--v19 < 2)
      {
        CFNumberRef v27 = 0;
        CFNumberRef v29 = v26;
        a2 = v64;
        goto LABEL_55;
      }
      BOOL v61 = v25;
      goto LABEL_35;
    }
    if (LODWORD(valuePtr[0]) == 1)
    {
      BOOL v25 = 1;
      goto LABEL_33;
    }
  }
LABEL_35:
  CFNumberRef v27 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"NSCTFontGradeTrait");
  if (!v27)
  {
    CFNumberRef v29 = v26;
    a2 = v64;
    BOOL v25 = v61;
    goto LABEL_41;
  }
  --v19;
  BOOL v25 = v61;
LABEL_37:
  BOOL v31 = v19 == 1;
  CFNumberRef v29 = v26;
  a2 = v64;
  if (v31) {
    goto LABEL_55;
  }
LABEL_41:
  if (@"NSCTFontUIFontDesignDefault" != a3)
  {
    if (!a3
      || !@"NSCTFontUIFontDesignDefault"
      || (*(_DWORD *)v62 = v25, v34 = CFEqual(a3, @"NSCTFontUIFontDesignDefault"), BOOL v25 = *(_DWORD *)v62, !v34))
    {
      if (@"NSCTFontUIFontDesignCore" == a3)
      {
        BOOL v36 = 1;
      }
      else
      {
        if (!a3 || !@"NSCTFontUIFontDesignCore") {
          goto LABEL_65;
        }
        *(_DWORD *)double v63 = v25;
        int v35 = CFEqual(a3, @"NSCTFontUIFontDesignCore");
        BOOL v25 = *(_DWORD *)v63;
        BOOL v36 = v35 != 0;
      }
      if (v29 && v36) {
        goto LABEL_55;
      }
LABEL_65:
      id v71 = (id)0xAAAAAAAAAAAAAAAALL;
      TCFMutableDictionary::TCFMutableDictionary((TCFMutableDictionary *)&v71, theDict);
      CFDictionaryRemoveValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v71, memory_order_acquire), @"NSCTFontSlantTrait");
      CFDictionaryRemoveValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v71, memory_order_acquire), @"NSCTFontProportionTrait");
      CFDictionaryRemoveValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v71, memory_order_acquire), @"NSCTFontSymbolicTrait");
      id values = (void *)atomic_load_explicit((atomic_ullong *volatile)&v71, memory_order_acquire);
      valuePtr[0] = @"NSCTFontTraitsAttribute";
      CFDictionaryRef v54 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], valuePtr, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      valuePtr[0] = (const void *)0xAAAAAAAAAAAAAAAALL;
      TDescriptorSource::CopySplicedDescriptorsForRequest((CFArrayRef *)valuePtr, a2, v54, a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, a8, (uint64_t)a10);
      CFArrayRef v55 = (const __CFArray *)(id)atomic_load_explicit((atomic_ullong *volatile)valuePtr, memory_order_acquire);
      CFArrayRef v56 = v55;
      if (v55 && CFArrayGetCount(v55) >= 1)
      {
        CFArrayRef v57 = (const __CFArray *)(id)atomic_load_explicit((atomic_ullong *volatile)valuePtr, memory_order_acquire);
        CFArrayRef v58 = v57;
        if (v57) {
          CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v57, 0);
        }
        else {
          CFDictionaryRef ValueAtIndex = 0;
        }
        CFIndex v60 = (const void *)*MEMORY[0x1E4F1D260];

        if (ValueAtIndex != v60)
        {
          TDescriptorSource::CreateVariantWithTraitsMatchingDescriptors((TDescriptorSource *)atomic_load_explicit((atomic_ullong *volatile)valuePtr, memory_order_acquire), theDict, a9);
          goto LABEL_74;
        }
      }
      else
      {
      }
      *a9 = 0;
LABEL_74:

      id v53 = v71;
      goto LABEL_75;
    }
  }
  if (!v29) {
    goto LABEL_65;
  }
LABEL_55:
  id v71 = 0;
  NameForSystemFontOfdouble Weight = TDescriptorSource::GetNameForSystemFontOfWeight(a3, 0, v22, v25, &v71, v21);
  if (!NameForSystemFontOfWeight) {
    goto LABEL_65;
  }
  *a9 = 0xAAAAAAAAAAAAAAAALL;
  TDescriptorSource::CopySplicedDescriptorForName(NameForSystemFontOfWeight, a5, a6, a7, a8, a10, a9, 0, 0, 0, v29, v27, 0, 0, 0);
  if (!v71) {
    return;
  }
  uint64_t v70 = (void *)0xAAAAAAAAAAAAAAAALL;
  TDescriptorSource::CopySplicedDescriptorForName(v71, a5, a6, a7, a8, a10, (unint64_t *)&v70, 0, 0, 0, v29, v27, 0, 0, 0);
  double Weight = CTFontDescriptorGetWeight(atomic_load_explicit((atomic_ullong *volatile)a9, memory_order_acquire));
  double v39 = CTFontDescriptorGetWeight(atomic_load_explicit((atomic_ullong *volatile)&v70, memory_order_acquire));
  BOOL v31 = Weight == v39;
  double v40 = (v22 - Weight) / (v39 - Weight);
  if (v31) {
    double v41 = 0.0;
  }
  else {
    double v41 = v40;
  }
  valuePtr[0] = CTFontDescriptorCopyAttribute((CTFontDescriptorRef)atomic_load_explicit((atomic_ullong *volatile)a9, memory_order_acquire), @"NSCTFontVariationAxesAttribute");
  CFArrayRef v42 = (const __CFArray *)atomic_exchange((atomic_ullong *volatile)valuePtr, 0);

  valuePtr[0] = CTFontDescriptorCopyAttribute((CTFontDescriptorRef)atomic_load_explicit((atomic_ullong *volatile)a9, memory_order_acquire), @"NSCTFontVariationAttribute");
  id v69 = (id)atomic_exchange((atomic_ullong *volatile)valuePtr, 0);

  AddDefaultsToVariation(v42, (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v69, memory_order_acquire), valuePtr);
  valuePtr[0] = CTFontDescriptorCopyAttribute((CTFontDescriptorRef)atomic_load_explicit((atomic_ullong *volatile)&v70, memory_order_acquire), @"NSCTFontVariationAttribute");
  id v68 = (id)atomic_exchange((atomic_ullong *volatile)valuePtr, 0);

  AddDefaultsToVariation(v42, (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v68, memory_order_acquire), valuePtr);
  CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v69, memory_order_acquire);
  if (explicit) {
    CFDictionaryRef explicit = (const __CFDictionary *)CFDictionaryGetValue(explicit, &unk_1ED0809E8);
  }
  valuePtr[0] = (const void *)-1;
  CFNumberGetValue(explicit, kCFNumberDoubleType, valuePtr);
  unint64_t v44 = valuePtr[0];
  CFDictionaryRef v45 = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v68, memory_order_acquire);
  if (v45) {
    CFDictionaryRef v45 = (const __CFDictionary *)CFDictionaryGetValue(v45, &unk_1ED0809E8);
  }
  valuePtr[0] = (const void *)-1;
  CFNumberGetValue(v45, kCFNumberDoubleType, valuePtr);
  double v46 = std::__lerp[abi:nn180100]<double>(*(double *)&v44, *(double *)valuePtr, v41);
  CFAllocatorRef v47 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFDictionaryRef v48 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  CFNumberRef v49 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  id Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  TCFNumber::TCFNumber<double>(&v67, v22);
  id values = (void *)atomic_load_explicit((atomic_ullong *volatile)&v67, memory_order_acquire);
  valuePtr[0] = @"NSCTFontWeightTrait";
  CFDictionaryRef v51 = CFDictionaryCreate(v47, valuePtr, (const void **)&values, 1, v48, v49);
  CFDictionaryAddValue(Mutable, @"NSCTFontTraitsAttribute", v51);

  TCFNumber::TCFNumber<double>(&v67, v46);
  id values = (void *)atomic_load_explicit((atomic_ullong *volatile)&v67, memory_order_acquire);
  valuePtr[0] = &unk_1ED0809E8;
  CFDictionaryRef v52 = CFDictionaryCreate(v47, valuePtr, (const void **)&values, 1, v48, v49);
  CFDictionaryAddValue(Mutable, @"NSCTFontVariationAttribute", v52);

  id v53 = v70;
LABEL_75:
}

uint64_t ScriptAndLangSysFromCanonicalLanguage(__CFString *a1)
{
  uint64_t v92 = *MEMORY[0x1E4F143B8];
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB2CE4C8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB2CE4C8))
  {
    qword_1EB2CE4C0 = 0xFFFFFFFFLL;
    __cxa_guard_release(&qword_1EB2CE4C8);
  }
  os_unfair_lock_lock_with_options();
  uint64_t v2 = (void *)qword_1EB2CE4B8;
  if ((__CFString *)qword_1EB2CE4B8 != a1)
  {
    qword_1EB2CE4B8 = a1;

    if (!a1)
    {
      int FirstLangSysTagForISO3LanguageTag = 0;
      int Value = -1;
      goto LABEL_16;
    }
    *(void *)&long long v3 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v86[0] = v3;
    v86[1] = v3;
    int64x2_t v84 = 0uLL;
    uint64_t v85 = 0;
    CFNumberRef v87 = v86;
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
    *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
    if (!CStringPtr)
    {
      CFIndex Length = CFStringGetLength(a1);
      CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x600u);
      CFIndex v8 = MaximumSizeForEncoding + 1;
      CFIndex v9 = (char *)v84.i64[0];
      if ((unint64_t)(MaximumSizeForEncoding + 1) <= v84.i64[1] - v84.i64[0])
      {
        if ((unint64_t)(MaximumSizeForEncoding + 1) < v84.i64[1] - v84.i64[0]) {
          v84.i64[1] = v84.i64[0] + v8;
        }
      }
      else
      {
        std::vector<char,TInlineBufferAllocator<char,30ul>>::__append(&v84, MaximumSizeForEncoding + 1 - (v84.i64[1] - v84.i64[0]));
        CFIndex v9 = (char *)v84.i64[0];
      }
      CFStringGetCString(a1, v9, v8, 0x600u);
      *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
    }
    v81[0] = v5;
    v81[1] = v5;
    v81[6] = v5;
    v81[4] = v5;
    v81[5] = v5;
    v81[2] = v5;
    v81[3] = v5;
    unint64_t v82 = 0xAAAAAAAAAAAAAAAALL;
    CFDictionaryRef v83 = (char *)v81 + 4;
    CFNumberRef v79 = (char *)v81 + 4;
    CFNumberRef v80 = (char *)v81 + 4;
    LODWORD(v81[0]) = 0;
    __p = v81;
    uscript_getCode();
    int v10 = (char *)__p;
    if (__p == v79)
    {
      int FirstLangSysTagForISO3LanguageTag = 0;
      int Value = -1;
      if (__p) {
        goto LABEL_12;
      }
      goto LABEL_15;
    }
    int Value = *(_DWORD *)__p;
    if (*(_DWORD *)__p == -1)
    {
      int FirstLangSysTagForISO3LanguageTag = 0;
      goto LABEL_12;
    }
    if (!Value)
    {
      if (qword_1EB2CE4F8 != -1) {
        dispatch_once_f(&qword_1EB2CE4F8, 0, (dispatch_function_t)ScriptAndLangSysFromScriptCode(UScriptCode,__CFString const*)::$_1::__invoke);
      }
      if (qword_1EB2CE4F0) {
        int Value = CFDictionaryGetValue((CFDictionaryRef)qword_1EB2CE4F0, a1);
      }
      else {
        int Value = 0;
      }
    }
    if (Value <= 95)
    {
      if (!Value)
      {
        int v15 = 1;
        int v16 = -1;
        goto LABEL_40;
      }
      if (Value == 95)
      {
        int v15 = 0;
        int v16 = 34;
        int Value = 1398362693;
        goto LABEL_40;
      }
      goto LABEL_39;
    }
    if (Value == 96)
    {
      int v15 = 0;
      int Value = 1398362698;
    }
    else
    {
      if (Value != 97)
      {
LABEL_39:
        int v15 = 1;
        int v16 = Value;
        int Value = 0;
LABEL_40:
        CFLocaleGetLanguageRegionEncodingForLocaleIdentifier();
        if (!v15)
        {
          int FirstLangSysTagForISO3LanguageTag = Value;
          goto LABEL_11;
        }
        *(void *)&long long v17 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v17 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v90[1] = v17;
        v90[0] = v17;
        int64x2_t v88 = 0uLL;
        uint64_t v89 = 0;
        CFDictionaryRef v91 = v90;
        unint64_t v18 = CFStringGetCStringPtr(a1, 0x600u);
        if (!v18)
        {
          CFIndex v19 = CFStringGetLength(a1);
          unint64_t v20 = CFStringGetMaximumSizeForEncoding(v19, 0x600u) + 1;
          int v21 = (char *)v88.i64[0];
          if (v20 <= v88.i64[1] - v88.i64[0])
          {
            if (v20 < v88.i64[1] - v88.i64[0]) {
              v88.i64[1] = v88.i64[0] + v20;
            }
          }
          else
          {
            std::vector<char,TInlineBufferAllocator<char,30ul>>::__append(&v88, v20 - (v88.i64[1] - v88.i64[0]));
            int v21 = (char *)v88.i64[0];
          }
          if (CFStringGetCString(a1, v21, v20, 0x600u)) {
            unint64_t v18 = (const char *)v88.i64[0];
          }
          else {
            unint64_t v18 = 0;
          }
        }
        ISO3Language = (char *)uloc_getISO3Language();
        if (!ISO3Language || !*ISO3Language)
        {
          if (!v18) {
            goto LABEL_842;
          }
          size_t v26 = strlen(v18);
          if (v26 != 3 && (v26 < 4 || v18[3] != 45)) {
            goto LABEL_842;
          }
          if (*v18) {
            unsigned int v27 = (*v18 << 24) | (v18[1] << 16) | (v18[2] << 8) | 0x20;
          }
          else {
            unsigned int v27 = 0;
          }
          int FirstLangSysTagForISO3LanguageTag = FindFirstLangSysTagForISO3LanguageTag(v27);
          if (!FirstLangSysTagForISO3LanguageTag)
          {
            int v28 = TagByUppercasing(v27);
            unint64_t v29 = 0xFFFFFFFFFFFFE730;
            while (*(_DWORD *)&kLanguageToLangSysMappings[v29 + 6356] != v28)
            {
              v29 += 8;
              if (!v29) {
                goto LABEL_835;
              }
            }
            int FirstLangSysTagForISO3LanguageTag = Value;
            if (!v29) {
              goto LABEL_835;
            }
          }
          goto LABEL_836;
        }
        signed int v23 = (*ISO3Language << 24) | (ISO3Language[1] << 16) | (ISO3Language[2] << 8) | 0x20;
        int FirstLangSysTagForISO3LanguageTag = FindFirstLangSysTagForISO3LanguageTag(v23);
        if (FirstLangSysTagForISO3LanguageTag) {
          goto LABEL_831;
        }
        unsigned int v24 = 1634885920;
        if (v23 <= 1836412959)
        {
          if (v23 > 1718973983)
          {
            if (v23 <= 1768842271)
            {
              if (v23 > 1751474463)
              {
                if (v23 > 1752003359)
                {
                  if (v23 > 1752132127)
                  {
                    if (v23 <= 1752525343)
                    {
                      if (v23 <= 1752331807)
                      {
                        if (v23 != 1752132128)
                        {
                          int v25 = 1752329504;
                          goto LABEL_747;
                        }
LABEL_681:
                        unsigned int v24 = 1918986784;
                        goto LABEL_829;
                      }
                      if (v23 != 1752331808)
                      {
                        int v61 = 1752395296;
                        goto LABEL_785;
                      }
LABEL_617:
                      unsigned int v24 = 1751282464;
                      goto LABEL_829;
                    }
                    if (v23 <= 1768645919)
                    {
                      if (v23 != 1752525344)
                      {
                        int v46 = 1768186144;
                        goto LABEL_793;
                      }
LABEL_748:
                      unsigned int v24 = 1752002080;
                      goto LABEL_829;
                    }
                    if (v23 != 1768645920 && v23 != 1768649760) {
                      goto LABEL_830;
                    }
                    unsigned int v24 = 1768650016;
LABEL_829:
                    int FirstLangSysTagForISO3LanguageTag = FindFirstLangSysTagForISO3LanguageTag(v24);
                    signed int v23 = v24;
                    if (!FirstLangSysTagForISO3LanguageTag) {
                      goto LABEL_830;
                    }
LABEL_831:
                    if (FirstLangSysTagForISO3LanguageTag == 1514686496
                      || FirstLangSysTagForISO3LanguageTag == 1514689568
                      || FirstLangSysTagForISO3LanguageTag == 1514689312)
                    {
                      int v28 = LangSysForChineseLocale(a1);
LABEL_835:
                      int FirstLangSysTagForISO3LanguageTag = v28;
                    }
LABEL_836:
                    if (FirstLangSysTagForISO3LanguageTag)
                    {
                      if (FirstLangSysTagForISO3LanguageTag != 1297042976)
                      {
LABEL_852:
                        uint64_t v77 = &v88;
                        std::vector<char,TInlineBufferAllocator<char,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v77);
LABEL_11:
                        int v10 = (char *)__p;
                        int Value = v16;
                        if (__p)
                        {
LABEL_12:
                          CFNumberRef v79 = v10;
                          if (v81 > (_OWORD *)v10 || &v83 <= (char **)v10) {
                            operator delete(v10);
                          }
                        }
LABEL_15:
                        __p = &v84;
                        std::vector<char,TInlineBufferAllocator<char,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&__p);
LABEL_16:
                        LODWORD(qword_1EB2CE4C0) = Value;
                        HIDWORD(qword_1EB2CE4C0) = FirstLangSysTagForISO3LanguageTag;
                        goto LABEL_17;
                      }
                      int FirstLangSysTagForISO3LanguageTag = 1297042976;
                      CFDictionaryRef ComponentsFromLocaleIdentifier = CFLocaleCreateComponentsFromLocaleIdentifier((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1);
                      unint64_t v74 = (__CFString *)CFDictionaryGetValue(ComponentsFromLocaleIdentifier, (const void *)*MEMORY[0x1E4F1D1F0]);
                      if (v74 == @"TH" || v74 && CFEqual(v74, @"TH")) {
                        int FirstLangSysTagForISO3LanguageTag = 1297043028;
                      }
LABEL_851:

                      goto LABEL_852;
                    }
LABEL_842:
                    int FirstLangSysTagForISO3LanguageTag = 1230000193;
                    CFDictionaryRef ComponentsFromLocaleIdentifier = CFLocaleCreateComponentsFromLocaleIdentifier((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1);
                    unsigned int v75 = (__CFString *)CFDictionaryGetValue(ComponentsFromLocaleIdentifier, (const void *)*MEMORY[0x1E4F1D238]);
                    if (v75 != @"fonipa")
                    {
                      CFStringRef v76 = v75;
                      if (!v75)
                      {
LABEL_849:
                        int FirstLangSysTagForISO3LanguageTag = 0;
                        goto LABEL_851;
                      }
                      if (CFStringCompare(v75, @"fonipa", 1uLL))
                      {
                        if (v76 == @"fonnapa"
                          || CFStringCompare(v76, @"fonnapa", 1uLL) == kCFCompareEqualTo)
                        {
                          goto LABEL_851;
                        }
                        if (v76 == @"fonupa" || CFStringCompare(v76, @"fonupa", 1uLL) == kCFCompareEqualTo)
                        {
                          int FirstLangSysTagForISO3LanguageTag = 1431326792;
                          goto LABEL_851;
                        }
                        goto LABEL_849;
                      }
                    }
                    int FirstLangSysTagForISO3LanguageTag = 1230000200;
                    goto LABEL_851;
                  }
                  if (v23 > 1752005151)
                  {
                    if (v23 > 1752066591)
                    {
                      if (v23 == 1752066592) {
                        goto LABEL_748;
                      }
                      unsigned __int16 v54 = 28448;
                    }
                    else
                    {
                      if (v23 == 1752005152) {
                        goto LABEL_748;
                      }
                      unsigned __int16 v54 = 25632;
                    }
                    int v43 = v54 | 0x686E0000;
                    goto LABEL_700;
                  }
                  if (v23 == 1752003360 || v23 == 1752004384) {
                    goto LABEL_748;
                  }
                  unsigned __int16 v44 = 31008;
LABEL_746:
                  int v25 = v44 | 0x686D0000;
LABEL_747:
                  if (v23 == v25) {
                    goto LABEL_748;
                  }
LABEL_830:
                  int FirstLangSysTagForISO3LanguageTag = TagByUppercasing(v23);
                  goto LABEL_831;
                }
                if (v23 > 1752000543)
                {
                  if (v23 <= 1752001567)
                  {
                    if (v23 == 1752000544 || v23 == 1752000800) {
                      goto LABEL_748;
                    }
                    unsigned __int16 v44 = 27168;
                  }
                  else if (v23 > 1752002591)
                  {
                    if (v23 == 1752002592) {
                      goto LABEL_748;
                    }
                    unsigned __int16 v44 = 28960;
                  }
                  else
                  {
                    if (v23 == 1752001568) {
                      goto LABEL_748;
                    }
                    unsigned __int16 v44 = 27936;
                  }
                  goto LABEL_746;
                }
                if (v23 > 1751999263)
                {
                  if (v23 > 1751999775)
                  {
                    if (v23 == 1751999776) {
                      goto LABEL_748;
                    }
                    unsigned __int16 v44 = 26400;
                  }
                  else
                  {
                    if (v23 == 1751999264) {
                      goto LABEL_748;
                    }
                    unsigned __int16 v44 = 25632;
                  }
                  goto LABEL_746;
                }
                if (v23 == 1751474464) {
                  goto LABEL_748;
                }
                if (v23 != 1751804192)
                {
                  unsigned __int16 v44 = 24864;
                  goto LABEL_746;
                }
LABEL_823:
                unsigned int v24 = 1836278048;
                goto LABEL_829;
              }
              if (v23 <= 1735292703)
              {
                if (v23 <= 1734631711)
                {
                  if (v23 > 1734441503)
                  {
                    if (v23 <= 1734504479)
                    {
                      if (v23 != 1734441504)
                      {
                        int v37 = 1734504224;
                        goto LABEL_477;
                      }
LABEL_582:
                      unsigned int v24 = 1869770016;
                      goto LABEL_829;
                    }
                    if (v23 != 1734504480)
                    {
                      int v72 = 1734504736;
LABEL_630:
                      if (v23 != v72) {
                        goto LABEL_830;
                      }
                    }
LABEL_740:
                    unsigned int v24 = 1734500640;
                    goto LABEL_829;
                  }
                  if (v23 != 1718973984)
                  {
                    if (v23 != 1734438432)
                    {
                      if (v23 != 1734440992) {
                        goto LABEL_830;
                      }
                      goto LABEL_582;
                    }
LABEL_786:
                    unsigned int v24 = 2053664544;
                    goto LABEL_829;
                  }
LABEL_815:
                  unsigned int v24 = 1718971424;
                  goto LABEL_829;
                }
                if (v23 > 1735030047)
                {
                  if (v23 <= 1735224607)
                  {
                    if (v23 == 1735030048) {
                      goto LABEL_681;
                    }
                    if (v23 != 1735094304) {
                      goto LABEL_830;
                    }
                    goto LABEL_854;
                  }
                  if (v23 == 1735224608) {
                    goto LABEL_740;
                  }
                  int v69 = 1735290656;
                  goto LABEL_724;
                }
                if (v23 == 1734631712) {
                  goto LABEL_681;
                }
                if (v23 != 1734697760)
                {
                  int v69 = 1734831904;
LABEL_724:
                  if (v23 != v69) {
                    goto LABEL_830;
                  }
                  goto LABEL_725;
                }
LABEL_530:
                unsigned int v24 = 1735549472;
                goto LABEL_829;
              }
              if (v23 > 1735747871)
              {
                if (v23 > 1751213343)
                {
                  if (v23 > 1751218207)
                  {
                    if (v23 != 1751218208 && v23 != 1751412256) {
                      goto LABEL_830;
                    }
                    unsigned int v24 = 1751214368;
                    goto LABEL_829;
                  }
                  if (v23 != 1751213344)
                  {
                    int v61 = 1751214880;
                    goto LABEL_785;
                  }
                  goto LABEL_582;
                }
                if (v23 != 1735747872 && v23 != 1735749152)
                {
                  int v72 = 1736007968;
                  goto LABEL_630;
                }
                goto LABEL_678;
              }
              if (v23 > 1735554591)
              {
                if (v23 <= 1735618335)
                {
                  if (v23 == 1735554592) {
                    goto LABEL_530;
                  }
                  unsigned __int16 v50 = 31008;
LABEL_476:
                  int v37 = v50 | 0x67720000;
LABEL_477:
                  if (v23 != v37) {
                    goto LABEL_830;
                  }
                  goto LABEL_530;
                }
                if (v23 == 1735618336) {
                  goto LABEL_740;
                }
                if (v23 != 1735747360) {
                  goto LABEL_830;
                }
LABEL_678:
                unsigned int v24 = 1735552544;
                goto LABEL_829;
              }
              if (v23 == 1735292704) {
                goto LABEL_678;
              }
              if (v23 != 1735355680)
              {
                unsigned __int16 v50 = 27168;
                goto LABEL_476;
              }
LABEL_857:
              unsigned int v24 = 1802464032;
              goto LABEL_829;
            }
            if (v23 > 1819437343)
            {
              if (v23 > 1835561503)
              {
                if (v23 > 1835954207)
                {
                  if (v23 <= 1836279839)
                  {
                    if (v23 <= 1836214815)
                    {
                      if (v23 == 1835954208) {
                        goto LABEL_786;
                      }
                      int v33 = 1836148512;
LABEL_822:
                      if (v23 != v33) {
                        goto LABEL_830;
                      }
                      goto LABEL_823;
                    }
                    if (v23 != 1836214816)
                    {
                      int v36 = 1836278560;
                      goto LABEL_754;
                    }
LABEL_860:
                    unsigned int v24 = 1667788064;
                    goto LABEL_829;
                  }
                  if (v23 <= 1836347935)
                  {
                    if (v23 != 1836279840)
                    {
                      int v33 = 1836280096;
                      goto LABEL_822;
                    }
LABEL_782:
                    unsigned int v24 = 1835820832;
                    goto LABEL_829;
                  }
                  if (v23 != 1836347936)
                  {
                    int v33 = 1836411168;
                    goto LABEL_822;
                  }
LABEL_824:
                  unsigned int v24 = 1836544544;
                  goto LABEL_829;
                }
                if (v23 <= 1835823391)
                {
                  if (v23 != 1835561504)
                  {
                    if (v23 == 1835626016) {
                      goto LABEL_823;
                    }
                    int v36 = 1835758880;
                    goto LABEL_754;
                  }
                  goto LABEL_860;
                }
                if (v23 <= 1835889183)
                {
                  if (v23 != 1835823392)
                  {
                    int v33 = 1835825440;
                    goto LABEL_822;
                  }
LABEL_755:
                  unsigned int v24 = 1835101728;
                  goto LABEL_829;
                }
                if (v23 == 1835889184) {
                  goto LABEL_748;
                }
                int v36 = 1835952928;
LABEL_754:
                if (v23 != v36) {
                  goto LABEL_830;
                }
                goto LABEL_755;
              }
              if (v23 > 1819764511)
              {
                if (v23 > 1835298591)
                {
                  if (v23 > 1835426079)
                  {
                    if (v23 == 1835426080) {
                      goto LABEL_823;
                    }
                    int v33 = 1835426336;
                  }
                  else
                  {
                    if (v23 == 1835298592) {
                      goto LABEL_740;
                    }
                    int v33 = 1835364128;
                  }
                  goto LABEL_822;
                }
                if (v23 != 1819764512)
                {
                  if (v23 == 1819961376) {
                    goto LABEL_786;
                  }
                  int v33 = 1835104288;
                  goto LABEL_822;
                }
                goto LABEL_794;
              }
              if (v23 > 1819567903)
              {
                if (v23 <= 1819570975)
                {
                  if (v23 != 1819567904)
                  {
                    int v46 = 1819569952;
                    goto LABEL_793;
                  }
LABEL_666:
                  unsigned int v24 = 1818326560;
                  goto LABEL_829;
                }
                if (v23 != 1819570976)
                {
                  if (v23 != 1819702048) {
                    goto LABEL_830;
                  }
                  goto LABEL_666;
                }
LABEL_794:
                unsigned int v24 = 1819638048;
                goto LABEL_829;
              }
              if (v23 == 1819437344 || v23 == 1819438368) {
                goto LABEL_794;
              }
              int v46 = 1819503904;
LABEL_793:
              if (v23 != v46) {
                goto LABEL_830;
              }
              goto LABEL_794;
            }
            if (v23 <= 1802662943)
            {
              if (v23 <= 1802073375)
              {
                if (v23 > 1784772639)
                {
                  if (v23 <= 1801615647)
                  {
                    if (v23 == 1784772640) {
                      goto LABEL_823;
                    }
                    int v40 = 1786340640;
                    goto LABEL_654;
                  }
                  if (v23 != 1801615648)
                  {
                    if (v23 != 1802005280) {
                      goto LABEL_830;
                    }
                    goto LABEL_640;
                  }
LABEL_641:
                  unsigned int v24 = 1801549088;
                  goto LABEL_829;
                }
                if (v23 == 1768842272 || v23 == 1784769312) {
                  goto LABEL_823;
                }
                int v43 = 1784771616;
LABEL_700:
                if (v23 != v43) {
                  goto LABEL_830;
                }
LABEL_701:
                unsigned int v24 = 1818322976;
                goto LABEL_829;
              }
              if (v23 > 1802397471)
              {
                if (v23 > 1802463519)
                {
                  if (v23 != 1802463520 && v23 != 1802532384) {
                    goto LABEL_830;
                  }
                  unsigned int v24 = 1802464544;
                  goto LABEL_829;
                }
                if (v23 != 1802397472)
                {
                  if (v23 != 1802399264) {
                    goto LABEL_830;
                  }
                  goto LABEL_857;
                }
                goto LABEL_598;
              }
              if (v23 != 1802073376)
              {
                if (v23 != 1802334752)
                {
                  if (v23 != 1802396448) {
                    goto LABEL_830;
                  }
                  goto LABEL_641;
                }
LABEL_761:
                unsigned int v24 = 1802859040;
                goto LABEL_829;
              }
LABEL_658:
              unsigned int v24 = 2054840608;
              goto LABEL_829;
            }
            if (v23 > 1818453279)
            {
              if (v23 > 1818851103)
              {
                if (v23 > 1818980127)
                {
                  if (v23 == 1818980128) {
                    goto LABEL_794;
                  }
                  unsigned __int16 v62 = 29472;
                }
                else
                {
                  if (v23 == 1818851104) {
                    goto LABEL_823;
                  }
                  unsigned __int16 v62 = 25120;
                }
                int v46 = v62 | 0x6C6B0000;
                goto LABEL_793;
              }
              if (v23 == 1818453280 || v23 == 1818453536) {
                goto LABEL_823;
              }
              if (v23 != 1818519840) {
                goto LABEL_830;
              }
LABEL_598:
              unsigned int v24 = 1802464800;
              goto LABEL_829;
            }
            if (v23 <= 1802991903)
            {
              if (v23 != 1802662944)
              {
                if (v23 == 1802920480) {
                  goto LABEL_823;
                }
                int v33 = 1802924576;
                goto LABEL_822;
              }
              goto LABEL_641;
            }
            if (v23 <= 1818389279)
            {
              if (v23 != 1802991904)
              {
                int v33 = 1803052064;
                goto LABEL_822;
              }
              goto LABEL_598;
            }
            if (v23 != 1818389280)
            {
              int v56 = 1818389536;
              goto LABEL_706;
            }
LABEL_690:
            unsigned int v24 = 1651401504;
            goto LABEL_829;
          }
          if (v23 > 1652058911)
          {
            if (v23 > 1668968223)
            {
              if (v23 > 1701732895)
              {
                if (v23 > 1717988639)
                {
                  if (v23 > 1718969887)
                  {
                    if (v23 > 1718970655)
                    {
                      if (v23 == 1718970656) {
                        goto LABEL_815;
                      }
                      unsigned __int16 v31 = 28960;
                    }
                    else
                    {
                      if (v23 == 1718969888) {
                        goto LABEL_815;
                      }
                      unsigned __int16 v31 = 26656;
                    }
                  }
                  else if (v23 > 1718969119)
                  {
                    if (v23 == 1718969120) {
                      goto LABEL_815;
                    }
                    unsigned __int16 v31 = 25888;
                  }
                  else
                  {
                    if (v23 == 1717988640) {
                      goto LABEL_815;
                    }
                    unsigned __int16 v31 = 25120;
                  }
                  if (v23 != (v31 | 0x66750000)) {
                    goto LABEL_830;
                  }
                  goto LABEL_815;
                }
                if (v23 <= 1702062879)
                {
                  if (v23 == 1701732896) {
                    goto LABEL_711;
                  }
                  if (v23 == 1702061856) {
                    goto LABEL_725;
                  }
                  if (v23 != 1702062368) {
                    goto LABEL_830;
                  }
                }
                else
                {
                  if (v23 > 1717662751)
                  {
                    unsigned int v24 = 1634427168;
                    if (v23 == 1717662752) {
                      goto LABEL_829;
                    }
                    int v56 = 1717726240;
LABEL_706:
                    if (v23 != v56) {
                      goto LABEL_830;
                    }
LABEL_707:
                    unsigned int v24 = 1651075872;
                    goto LABEL_829;
                  }
                  if (v23 != 1702062880)
                  {
                    int v55 = 1702457120;
                    goto LABEL_710;
                  }
                }
                unsigned int v24 = 1768975136;
                goto LABEL_829;
              }
              if (v23 <= 1684633375)
              {
                if (v23 > 1684627999)
                {
                  if (v23 > 1684631583)
                  {
                    if (v23 != 1684631584)
                    {
                      if (v23 != 1684631840) {
                        goto LABEL_830;
                      }
                      goto LABEL_658;
                    }
                  }
                  else if (v23 != 1684628000 && v23 != 1684630304)
                  {
                    goto LABEL_830;
                  }
LABEL_659:
                  unsigned int v24 = 1684631072;
                  goto LABEL_829;
                }
                if (v23 == 1668968224) {
                  goto LABEL_786;
                }
                if (v23 != 1684500256)
                {
                  int v65 = 1684562976;
                  goto LABEL_567;
                }
LABEL_855:
                unsigned int v24 = 1685023008;
                goto LABEL_829;
              }
              if (v23 > 1685418015)
              {
                if (v23 <= 1701538591)
                {
                  if (v23 == 1685418016) {
                    goto LABEL_823;
                  }
                  int v58 = 1700948768;
                  goto LABEL_482;
                }
                if (v23 != 1701538592)
                {
                  int v36 = 1701669664;
                  goto LABEL_754;
                }
                goto LABEL_865;
              }
              if (v23 == 1684633376 || v23 == 1684763424) {
                goto LABEL_659;
              }
              int v71 = 1685354784;
LABEL_720:
              if (v23 == v71)
              {
                unsigned int v24 = 1852141600;
                goto LABEL_829;
              }
              goto LABEL_830;
            }
            if (v23 <= 1668182559)
            {
              if (v23 <= 1667526431)
              {
                if (v23 <= 1652061471)
                {
                  if (v23 == 1652058912) {
                    goto LABEL_794;
                  }
                  if (v23 != 1652059424 && v23 != 1652060704) {
                    goto LABEL_830;
                  }
                  goto LABEL_431;
                }
                if (v23 <= 1667463199)
                {
                  if (v23 != 1652061472)
                  {
                    int v38 = 1652187936;
                    goto LABEL_781;
                  }
LABEL_431:
                  unsigned int v24 = 1651859744;
                  goto LABEL_829;
                }
                if (v23 != 1667463200)
                {
                  int v63 = 1667463456;
                  goto LABEL_827;
                }
LABEL_828:
                unsigned int v24 = 2053660960;
                goto LABEL_829;
              }
              if (v23 > 1667981855)
              {
                if (v23 <= 1668115999)
                {
                  if (v23 == 1667981856) {
                    goto LABEL_761;
                  }
                  if (v23 != 1668047904) {
                    goto LABEL_830;
                  }
LABEL_856:
                  unsigned int v24 = 1937338912;
                  goto LABEL_829;
                }
                if (v23 == 1668116000) {
                  goto LABEL_786;
                }
                int v61 = 1668182048;
LABEL_785:
                if (v23 != v61) {
                  goto LABEL_830;
                }
                goto LABEL_786;
              }
              if (v23 == 1667526432) {
                goto LABEL_786;
              }
              if (v23 != 1667856160)
              {
                int v61 = 1667922208;
                goto LABEL_785;
              }
LABEL_775:
              unsigned int v24 = 1869244704;
              goto LABEL_829;
            }
            if (v23 > 1668443167)
            {
              if (v23 <= 1668511519)
              {
                if (v23 != 1668443168 && v23 != 1668443424)
                {
                  int v61 = 1668509728;
                  goto LABEL_785;
                }
              }
              else if (v23 > 1668768799)
              {
                if (v23 != 1668768800)
                {
                  int v61 = 1668966432;
                  goto LABEL_785;
                }
              }
              else if (v23 != 1668511520)
              {
                int v56 = 1668576032;
                goto LABEL_706;
              }
            }
            else
            {
              if (v23 <= 1668375583)
              {
                if (v23 == 1668182560) {
                  goto LABEL_617;
                }
                if (v23 != 1668243744)
                {
                  int v61 = 1668315168;
                  goto LABEL_785;
                }
                goto LABEL_823;
              }
              if (v23 <= 1668442655)
              {
                if (v23 == 1668375584) {
                  goto LABEL_748;
                }
                int v51 = 1668379936;
                goto LABEL_805;
              }
              if (v23 != 1668442656 && v23 != 1668442912) {
                goto LABEL_830;
              }
            }
            unsigned int v24 = 1668441376;
            goto LABEL_829;
          }
          if (v23 <= 1635150879)
          {
            if (v23 <= 1634298143)
            {
              if (v23 > 1633908511)
              {
                if (v23 > 1633969695)
                {
                  if (v23 > 1634034463)
                  {
                    if (v23 == 1634034464) {
                      goto LABEL_829;
                    }
                    int v35 = 1634099744;
                  }
                  else
                  {
                    if (v23 == 1633969696) {
                      goto LABEL_829;
                    }
                    int v35 = 1634034208;
                  }
                  goto LABEL_769;
                }
                if (v23 == 1633908512 || v23 == 1633908768) {
                  goto LABEL_829;
                }
                unsigned __int16 v68 = 31008;
LABEL_625:
                int v35 = v68 | 0x61630000;
                goto LABEL_769;
              }
              if (v23 > 1633839135)
              {
                if (v23 <= 1633905951)
                {
                  if (v23 == 1633839136) {
                    goto LABEL_829;
                  }
                  int v35 = 1633842720;
                  goto LABEL_769;
                }
                if (v23 == 1633905952) {
                  goto LABEL_829;
                }
                unsigned __int16 v68 = 28960;
                goto LABEL_625;
              }
              if (v23 != 1633772832)
              {
                if (v23 == 1633775392) {
                  goto LABEL_829;
                }
                int v48 = 1633776672;
LABEL_416:
                if (v23 != v48) {
                  goto LABEL_830;
                }
                goto LABEL_671;
              }
              goto LABEL_671;
            }
            if (v23 > 1634755615)
            {
              if (v23 <= 1634890527)
              {
                if (v23 == 1634755616 || v23 == 1634886176) {
                  goto LABEL_829;
                }
                unsigned __int16 v60 = 28960;
              }
              else
              {
                if (v23 > 1634892319)
                {
                  if (v23 == 1634892320) {
                    goto LABEL_829;
                  }
                  int v35 = 1635088928;
                  goto LABEL_769;
                }
                if (v23 == 1634890528) {
                  goto LABEL_829;
                }
                unsigned __int16 v60 = 31008;
              }
              int v35 = v60 | 0x61720000;
              goto LABEL_769;
            }
            if (v23 > 1634366751)
            {
              if (v23 <= 1634497311)
              {
                if (v23 == 1634366752) {
                  goto LABEL_655;
                }
                int v48 = 1634496032;
                goto LABEL_416;
              }
              if (v23 == 1634497312)
              {
LABEL_671:
                unsigned int v24 = 1936812320;
                goto LABEL_829;
              }
              int v35 = 1634755360;
LABEL_769:
              if (v23 != v35) {
                goto LABEL_830;
              }
              goto LABEL_829;
            }
            if (v23 == 1634298144) {
              goto LABEL_856;
            }
            if (v23 == 1634365472) {
              goto LABEL_829;
            }
            int v40 = 1634366496;
LABEL_654:
            if (v23 != v40) {
              goto LABEL_830;
            }
LABEL_655:
            unsigned int v24 = 1785881120;
            goto LABEL_829;
          }
          if (v23 > 1650946079)
          {
            if (v23 > 1651275039)
            {
              if (v23 <= 1651796511)
              {
                if (v23 == 1651275040) {
                  goto LABEL_748;
                }
                if (v23 != 1651338528)
                {
                  if (v23 != 1651471136) {
                    goto LABEL_830;
                  }
                  goto LABEL_617;
                }
                goto LABEL_782;
              }
              if (v23 > 1651926303)
              {
                if (v23 == 1651926304) {
                  goto LABEL_823;
                }
                int v33 = 1651930400;
                goto LABEL_822;
              }
              if (v23 == 1651796512) {
                goto LABEL_823;
              }
              int v56 = 1651797792;
              goto LABEL_706;
            }
            if (v23 > 1651012127)
            {
              if (v23 <= 1651142943)
              {
                if (v23 != 1651012128)
                {
                  int v33 = 1651142176;
                  goto LABEL_822;
                }
                goto LABEL_782;
              }
              if (v23 == 1651142944) {
                goto LABEL_782;
              }
              int v56 = 1651273248;
              goto LABEL_706;
            }
            if (v23 != 1650946080)
            {
              if (v23 == 1650946336) {
                goto LABEL_681;
              }
              int v56 = 1651010336;
              goto LABEL_706;
            }
          }
          else
          {
            if (v23 <= 1635410463)
            {
              if (v23 <= 1635347487)
              {
                if (v23 == 1635150880) {
                  goto LABEL_829;
                }
                if (v23 != 1635345184)
                {
                  unsigned __int16 v42 = 26656;
LABEL_444:
                  int v35 = v42 | 0x61790000;
                  goto LABEL_769;
                }
              }
              else
              {
                if (v23 <= 1635348511)
                {
                  if (v23 == 1635347488) {
                    goto LABEL_829;
                  }
                  unsigned __int16 v42 = 28192;
                  goto LABEL_444;
                }
                if (v23 == 1635348512) {
                  goto LABEL_829;
                }
                if (v23 != 1635349024) {
                  goto LABEL_830;
                }
              }
              unsigned int v24 = 1635347744;
              goto LABEL_829;
            }
            if (v23 <= 1650680607)
            {
              if (v23 == 1635410464 || v23 == 1635412512)
              {
                unsigned int v24 = 1635411232;
                goto LABEL_829;
              }
              int v35 = 1650620960;
              goto LABEL_769;
            }
            if (v23 > 1650750495)
            {
              if (v23 == 1650750496) {
                goto LABEL_740;
              }
              if (v23 != 1650945568) {
                goto LABEL_830;
              }
            }
            else if (v23 != 1650680608)
            {
              int v56 = 1650682912;
              goto LABEL_706;
            }
          }
          unsigned int v24 = 1650551840;
          goto LABEL_829;
        }
        if (v23 > 1952741407)
        {
          if (v23 <= 2053598495)
          {
            if (v23 > 2020504095)
            {
              if (v23 > 2053204255)
              {
                if (v23 <= 2053207583)
                {
                  if (v23 <= 2053206303)
                  {
                    if (v23 != 2053204256 && v23 != 2053205280)
                    {
                      unsigned __int16 v30 = 28448;
                      goto LABEL_751;
                    }
                  }
                  else if (v23 > 2053206815)
                  {
                    if (v23 != 2053206816)
                    {
                      unsigned __int16 v30 = 29728;
                      goto LABEL_751;
                    }
                  }
                  else if (v23 != 2053206304)
                  {
                    unsigned __int16 v30 = 29216;
                    goto LABEL_751;
                  }
LABEL_799:
                  unsigned int v24 = 2053206048;
                  goto LABEL_829;
                }
                if (v23 <= 2053334047)
                {
                  if (v23 > 2053208095)
                  {
                    if (v23 != 2053208096)
                    {
                      int v70 = 2053333280;
                      goto LABEL_798;
                    }
                  }
                  else if (v23 != 2053207584)
                  {
                    unsigned __int16 v30 = 30496;
LABEL_751:
                    int v70 = v30 | 0x7A610000;
                    goto LABEL_798;
                  }
                  goto LABEL_799;
                }
                if (v23 <= 2053466143)
                {
                  if (v23 != 2053334048)
                  {
                    int v63 = 2053335072;
                    goto LABEL_827;
                  }
                  goto LABEL_799;
                }
                if (v23 == 2053466144) {
                  goto LABEL_828;
                }
                int v63 = 2053595680;
LABEL_827:
                if (v23 != v63) {
                  goto LABEL_830;
                }
                goto LABEL_828;
              }
              if (v23 > 2037736735)
              {
                if (v23 <= 2053202719)
                {
                  if (v23 == 2037736736) {
                    goto LABEL_786;
                  }
                  if (v23 != 2053202208)
                  {
                    unsigned __int16 v30 = 25120;
                    goto LABEL_751;
                  }
                }
                else if (v23 > 2053203231)
                {
                  if (v23 != 2053203232)
                  {
                    unsigned __int16 v30 = 26144;
                    goto LABEL_751;
                  }
                }
                else if (v23 != 2053202720)
                {
                  unsigned __int16 v30 = 25632;
                  goto LABEL_751;
                }
                goto LABEL_799;
              }
              if (v23 > 2036622367)
              {
                if (v23 > 2036951071)
                {
                  if (v23 != 2036951072)
                  {
                    int v40 = 2037736480;
                    goto LABEL_654;
                  }
                }
                else if (v23 != 2036622368)
                {
                  int v40 = 2036884512;
                  goto LABEL_654;
                }
                unsigned int v24 = 2036950048;
                goto LABEL_829;
              }
              if (v23 == 2020504096) {
                goto LABEL_855;
              }
              if (v23 == 2020631840)
              {
LABEL_854:
                unsigned int v24 = 1802528032;
                goto LABEL_829;
              }
              if (v23 != 2020830240) {
                goto LABEL_830;
              }
LABEL_454:
              unsigned int v24 = 1684368928;
              goto LABEL_829;
            }
            if (v23 > 1970957855)
            {
              if (v23 <= 2003990815)
              {
                if (v23 <= 1986751263)
                {
                  if (v23 == 1970957856 || v23 == 1970959136)
                  {
                    unsigned int v24 = 1970954784;
                    goto LABEL_829;
                  }
                  int v58 = 1986161440;
LABEL_482:
                  if (v23 != v58) {
                    goto LABEL_830;
                  }
                  goto LABEL_690;
                }
                if (v23 <= 1987211039)
                {
                  if (v23 == 1986751264) {
                    goto LABEL_823;
                  }
                  int v33 = 1986753568;
                  goto LABEL_822;
                }
                if (v23 != 1987211040)
                {
                  if (v23 != 2002940448) {
                    goto LABEL_830;
                  }
                  goto LABEL_681;
                }
LABEL_865:
                unsigned int v24 = 1702065184;
                goto LABEL_829;
              }
              if (v23 <= 2020107551)
              {
                if (v23 != 2003990816)
                {
                  if (v23 != 2004051744)
                  {
                    int v61 = 2004186400;
                    goto LABEL_785;
                  }
LABEL_725:
                  unsigned int v24 = 1735355936;
                  goto LABEL_829;
                }
                goto LABEL_824;
              }
              if (v23 <= 2020439583)
              {
                if (v23 == 2020107552) {
                  goto LABEL_701;
                }
                int v33 = 2020437280;
                goto LABEL_822;
              }
              if (v23 == 2020439584) {
                goto LABEL_782;
              }
              int v38 = 2020439840;
            }
            else
            {
              if (v23 <= 1953855775)
              {
                if (v23 > 1953004063)
                {
                  if (v23 <= 1953330975)
                  {
                    if (v23 != 1953004064)
                    {
                      int v38 = 1953195808;
                      goto LABEL_781;
                    }
LABEL_819:
                    unsigned int v24 = 1953327136;
                    goto LABEL_829;
                  }
                  if (v23 == 1953330976) {
                    goto LABEL_823;
                  }
                  int v66 = 1953788192;
LABEL_818:
                  if (v23 != v66) {
                    goto LABEL_830;
                  }
                  goto LABEL_819;
                }
                if (v23 == 1952741408) {
                  goto LABEL_782;
                }
                if (v23 != 1952801568)
                {
                  int v66 = 1953003040;
                  goto LABEL_818;
                }
LABEL_711:
                unsigned int v24 = 1802268192;
                goto LABEL_829;
              }
              if (v23 > 1969384479)
              {
                if (v23 > 1970171167)
                {
                  if (v23 != 1970171168)
                  {
                    int v33 = 1970432800;
                    goto LABEL_822;
                  }
                }
                else
                {
                  if (v23 == 1969384480) {
                    goto LABEL_707;
                  }
                  if (v23 != 1970107680) {
                    goto LABEL_830;
                  }
                }
                unsigned int v24 = 1684368416;
                goto LABEL_829;
              }
              if (v23 == 1953855776) {
                goto LABEL_711;
              }
              unsigned int v24 = 1634427168;
              if (v23 == 1953982752) {
                goto LABEL_829;
              }
              int v38 = 1954052384;
            }
LABEL_781:
            if (v23 != v38) {
              goto LABEL_830;
            }
            goto LABEL_782;
          }
          if (v23 <= 2054189855)
          {
            if (v23 > 2054186271)
            {
              if (v23 > 2054188063)
              {
                if (v23 <= 2054188831)
                {
                  if (v23 == 2054188064 || v23 == 2054188320) {
                    goto LABEL_799;
                  }
                  unsigned __int16 v47 = 28192;
                }
                else if (v23 > 2054189343)
                {
                  if (v23 == 2054189344) {
                    goto LABEL_799;
                  }
                  unsigned __int16 v47 = 29216;
                }
                else
                {
                  if (v23 == 2054188832) {
                    goto LABEL_799;
                  }
                  unsigned __int16 v47 = 28704;
                }
              }
              else if (v23 <= 2054187039)
              {
                if (v23 == 2054186272 || v23 == 2054186528) {
                  goto LABEL_799;
                }
                unsigned __int16 v47 = 26400;
              }
              else if (v23 > 2054187551)
              {
                if (v23 == 2054187552) {
                  goto LABEL_799;
                }
                unsigned __int16 v47 = 27424;
              }
              else
              {
                if (v23 == 2054187040) {
                  goto LABEL_799;
                }
                unsigned __int16 v47 = 26912;
              }
            }
            else
            {
              if (v23 <= 2053927199)
              {
                if (v23 <= 2053664287)
                {
                  if (v23 != 2053598496 && v23 != 2053598752)
                  {
                    int v63 = 2053661728;
                    goto LABEL_827;
                  }
                  goto LABEL_828;
                }
                if (v23 > 2053926175)
                {
                  if (v23 == 2053926176) {
                    goto LABEL_823;
                  }
                  unsigned __int16 v41 = 28192;
                }
                else
                {
                  if (v23 == 2053664288) {
                    goto LABEL_828;
                  }
                  unsigned __int16 v41 = 27168;
                }
                int v63 = v41 | 0x7A6C0000;
                goto LABEL_827;
              }
              if (v23 <= 2054185247)
              {
                if (v23 == 2053927200) {
                  goto LABEL_828;
                }
                if (v23 == 2053990688) {
                  goto LABEL_823;
                }
                int v70 = 2054123296;
                goto LABEL_798;
              }
              if (v23 > 2054185759)
              {
                if (v23 == 2054185760) {
                  goto LABEL_799;
                }
                unsigned __int16 v47 = 25632;
              }
              else
              {
                if (v23 == 2054185248) {
                  goto LABEL_799;
                }
                unsigned __int16 v47 = 25120;
              }
            }
          }
          else
          {
            if (v23 > 2054450207)
            {
              if (v23 > 2054452511)
              {
                if (v23 > 2054776607)
                {
                  if (v23 > 2054778399)
                  {
                    if (v23 == 2054778400) {
                      goto LABEL_828;
                    }
                    int v63 = 2054842912;
                    goto LABEL_827;
                  }
                  if (v23 == 2054776608) {
                    goto LABEL_828;
                  }
                  unsigned __int16 v64 = 27168;
                }
                else
                {
                  if (v23 <= 2054453535)
                  {
                    if (v23 == 2054452512) {
                      goto LABEL_799;
                    }
                    unsigned __int16 v34 = 30752;
                    goto LABEL_766;
                  }
                  if (v23 == 2054453536) {
                    goto LABEL_799;
                  }
                  unsigned __int16 v64 = 25120;
                }
                int v63 = v64 | 0x7A790000;
                goto LABEL_827;
              }
              if (v23 <= 2054451231)
              {
                if (v23 == 2054450208 || v23 == 2054450464) {
                  goto LABEL_799;
                }
                unsigned __int16 v34 = 28192;
              }
              else if (v23 > 2054451999)
              {
                if (v23 == 2054452000) {
                  goto LABEL_799;
                }
                unsigned __int16 v34 = 29728;
              }
              else
              {
                if (v23 == 2054451232) {
                  goto LABEL_799;
                }
                unsigned __int16 v34 = 28960;
              }
LABEL_766:
              int v70 = v34 | 0x7A740000;
              goto LABEL_798;
            }
            if (v23 > 2054191647)
            {
              if (v23 <= 2054386207)
              {
                if (v23 != 2054191648)
                {
                  if (v23 != 2054251808)
                  {
                    int v33 = 2054384928;
                    goto LABEL_822;
                  }
                  goto LABEL_828;
                }
                goto LABEL_799;
              }
              if (v23 > 2054448415)
              {
                if (v23 == 2054448416) {
                  goto LABEL_799;
                }
                unsigned __int16 v34 = 26400;
              }
              else
              {
                if (v23 == 2054386208) {
                  goto LABEL_799;
                }
                unsigned __int16 v34 = 25376;
              }
              goto LABEL_766;
            }
            if (v23 <= 2054190623)
            {
              if (v23 == 2054189856 || v23 == 2054190112) {
                goto LABEL_799;
              }
              unsigned __int16 v47 = 29984;
            }
            else if (v23 > 2054191135)
            {
              if (v23 == 2054191136) {
                goto LABEL_799;
              }
              unsigned __int16 v47 = 31008;
            }
            else
            {
              if (v23 == 2054190624) {
                goto LABEL_799;
              }
              unsigned __int16 v47 = 30496;
            }
          }
          int v70 = v47 | 0x7A700000;
LABEL_798:
          if (v23 != v70) {
            goto LABEL_830;
          }
          goto LABEL_799;
        }
        if (v23 > 1903584543)
        {
          if (v23 > 1919052575)
          {
            if (v23 > 1936092447)
            {
              if (v23 > 1936876319)
              {
                if (v23 > 1937203999)
                {
                  if (v23 <= 1937208863)
                  {
                    if (v23 != 1937204000 && v23 != 1937205280) {
                      goto LABEL_830;
                    }
                    unsigned int v24 = 1937203488;
                    goto LABEL_829;
                  }
                  if (v23 == 1937208864) {
                    goto LABEL_824;
                  }
                  int v66 = 1952543008;
                  goto LABEL_818;
                }
                if (v23 > 1936879647)
                {
                  if (v23 == 1936879648) {
                    goto LABEL_617;
                  }
                  int v35 = 1936943136;
                  goto LABEL_769;
                }
                if (v23 == 1936876320)
                {
LABEL_760:
                  unsigned int v24 = 1936876576;
                  goto LABEL_829;
                }
                int v32 = 1936879392;
LABEL_759:
                if (v23 != v32) {
                  goto LABEL_830;
                }
                goto LABEL_760;
              }
              if (v23 <= 1936418591)
              {
                if (v23 == 1936092448) {
                  goto LABEL_748;
                }
                if (v23 != 1936155424)
                {
                  int v35 = 1936225568;
                  goto LABEL_769;
                }
                goto LABEL_711;
              }
              if (v23 <= 1936750111)
              {
                if (v23 == 1936418592) {
                  goto LABEL_782;
                }
                int v43 = 1936421408;
                goto LABEL_700;
              }
              if (v23 != 1936750112)
              {
                int v55 = 1936750880;
LABEL_710:
                if (v23 != v55) {
                  goto LABEL_830;
                }
                goto LABEL_711;
              }
LABEL_862:
              unsigned int v24 = 1869768992;
              goto LABEL_829;
            }
            if (v23 <= 1919776543)
            {
              if (v23 <= 1919772191)
              {
                if (v23 == 1919052576) {
                  goto LABEL_690;
                }
                if (v23 == 1919052832) {
                  goto LABEL_707;
                }
                unsigned __int16 v45 = 25376;
              }
              else if (v23 > 1919774239)
              {
                if (v23 == 1919774240) {
                  goto LABEL_663;
                }
                unsigned __int16 v45 = 28448;
              }
              else
              {
                if (v23 == 1919772192) {
                  goto LABEL_663;
                }
                unsigned __int16 v45 = 27680;
              }
              if (v23 != (v45 | 0x726D0000)) {
                goto LABEL_830;
              }
LABEL_663:
              unsigned int v24 = 1919905056;
              goto LABEL_829;
            }
            if (v23 > 1935897375)
            {
              if (v23 > 1935960095)
              {
                if (v23 == 1935960096) {
                  goto LABEL_761;
                }
                unsigned __int16 v59 = 28192;
              }
              else
              {
                if (v23 == 1935897376) {
                  goto LABEL_454;
                }
                unsigned __int16 v59 = 25376;
              }
              int v32 = v59 | 0x73640000;
              goto LABEL_759;
            }
            if (v23 == 1919776544 || v23 == 1919777056) {
              goto LABEL_663;
            }
            int v65 = 1920430624;
LABEL_567:
            if (v23 != v65) {
              goto LABEL_830;
            }
            goto LABEL_824;
          }
          if (v23 > 1903650847)
          {
            if (v23 > 1903718175)
            {
              if (v23 <= 1903719455)
              {
                if (v23 == 1903718176 || v23 == 1903718432) {
                  goto LABEL_806;
                }
                unsigned __int16 v52 = 29216;
              }
              else
              {
                if (v23 > 1903720223)
                {
                  if (v23 != 1903720224)
                  {
                    int v46 = 1918986016;
                    goto LABEL_793;
                  }
                  goto LABEL_806;
                }
                if (v23 == 1903719456) {
                  goto LABEL_806;
                }
                unsigned __int16 v52 = 29984;
              }
            }
            else if (v23 <= 1903715103)
            {
              if (v23 == 1903650848 || v23 == 1903653664) {
                goto LABEL_806;
              }
              unsigned __int16 v52 = 24864;
            }
            else if (v23 > 1903717407)
            {
              if (v23 == 1903717408) {
                goto LABEL_806;
              }
              unsigned __int16 v52 = 28192;
            }
            else
            {
              if (v23 == 1903715104) {
                goto LABEL_806;
              }
              unsigned __int16 v52 = 26656;
            }
            int v51 = v52 | 0x71780000;
            goto LABEL_805;
          }
          if (v23 > 1903587103)
          {
            if (v23 <= 1903589151)
            {
              if (v23 != 1903587104 && v23 != 1903587360)
              {
                unsigned __int16 v39 = 29472;
                goto LABEL_804;
              }
            }
            else if (v23 > 1903649055)
            {
              if (v23 != 1903649056)
              {
                int v51 = 1903649568;
                goto LABEL_805;
              }
            }
            else if (v23 != 1903589152)
            {
              unsigned __int16 v39 = 31264;
              goto LABEL_804;
            }
          }
          else if (v23 <= 1903585823)
          {
            if (v23 != 1903584544 && v23 != 1903585312)
            {
              unsigned __int16 v39 = 26912;
              goto LABEL_804;
            }
          }
          else if (v23 > 1903586591)
          {
            if (v23 != 1903586592)
            {
              unsigned __int16 v39 = 28192;
              goto LABEL_804;
            }
          }
          else if (v23 != 1903585824)
          {
            unsigned __int16 v39 = 27680;
LABEL_804:
            int v51 = v39 | 0x71760000;
LABEL_805:
            if (v23 != v51) {
              goto LABEL_830;
            }
          }
LABEL_806:
          unsigned int v24 = 1903519008;
          goto LABEL_829;
        }
        if (v23 <= 1885500703)
        {
          if (v23 <= 1853449247)
          {
            if (v23 > 1851878943)
            {
              if (v23 <= 1852597535)
              {
                if (v23 == 1851878944) {
                  goto LABEL_786;
                }
                if (v23 == 1852335136) {
                  goto LABEL_678;
                }
                int v55 = 1852404000;
                goto LABEL_710;
              }
              if (v23 > 1852793375)
              {
                if (v23 != 1852793376)
                {
                  int v71 = 1852860704;
                  goto LABEL_720;
                }
              }
              else
              {
                if (v23 == 1852597536) {
                  goto LABEL_794;
                }
                if (v23 != 1852731168) {
                  goto LABEL_830;
                }
              }
              unsigned int v24 = 1852797472;
              goto LABEL_829;
            }
            if (v23 > 1836475935)
            {
              if (v23 > 1836545823)
              {
                if (v23 == 1836545824) {
                  goto LABEL_748;
                }
                int v36 = 1836675360;
                goto LABEL_754;
              }
              if (v23 != 1836475936)
              {
                int v36 = 1836542752;
                goto LABEL_754;
              }
LABEL_640:
              unsigned int v24 = 1836019232;
              goto LABEL_829;
            }
            if (v23 == 1836412960) {
              goto LABEL_681;
            }
            if (v23 == 1836413216) {
              goto LABEL_748;
            }
            int v65 = 1836475680;
            goto LABEL_567;
          }
          if (v23 <= 1869310239)
          {
            if (v23 <= 1869243167)
            {
              if (v23 == 1853449248) {
                goto LABEL_794;
              }
              if (v23 == 1868720928) {
                goto LABEL_690;
              }
              unsigned __int16 v49 = 25120;
            }
            else if (v23 > 1869247263)
            {
              if (v23 == 1869247264) {
                goto LABEL_775;
              }
              unsigned __int16 v49 = 30496;
            }
            else
            {
              if (v23 == 1869243168) {
                goto LABEL_775;
              }
              unsigned __int16 v49 = 26400;
            }
            if (v23 != (v49 | 0x6F6A0000)) {
              goto LABEL_830;
            }
            goto LABEL_775;
          }
          if (v23 <= 1869771551)
          {
            if (v23 != 1869310240)
            {
              if (v23 == 1869767456) {
                goto LABEL_582;
              }
              int v33 = 1869770272;
              goto LABEL_822;
            }
            goto LABEL_711;
          }
          if (v23 <= 1869903647)
          {
            if (v23 == 1869771552) {
              goto LABEL_823;
            }
            if (v23 != 1869773088) {
              goto LABEL_830;
            }
            goto LABEL_862;
          }
          if (v23 == 1869903648) {
            goto LABEL_775;
          }
          int v57 = 1885500448;
          goto LABEL_773;
        }
        if (v23 > 1903519263)
        {
          if (v23 > 1903522591)
          {
            if (v23 <= 1903524127)
            {
              if (v23 == 1903522592 || v23 == 1903523616) {
                goto LABEL_806;
              }
              unsigned __int16 v53 = 30752;
            }
            else
            {
              if (v23 > 1903583519)
              {
                if (v23 != 1903583520)
                {
                  unsigned __int16 v39 = 25376;
                  goto LABEL_804;
                }
                goto LABEL_806;
              }
              if (v23 == 1903524128) {
                goto LABEL_806;
              }
              unsigned __int16 v53 = 31264;
            }
          }
          else if (v23 <= 1903520543)
          {
            if (v23 == 1903519264 || v23 == 1903519520) {
              goto LABEL_806;
            }
            unsigned __int16 v53 = 26656;
          }
          else if (v23 > 1903521823)
          {
            if (v23 == 1903521824) {
              goto LABEL_806;
            }
            unsigned __int16 v53 = 29216;
          }
          else
          {
            if (v23 == 1903520544) {
              goto LABEL_806;
            }
            unsigned __int16 v53 = 27680;
          }
        }
        else
        {
          if (v23 <= 1886221599)
          {
            if (v23 > 1885823263)
            {
              if (v23 <= 1886088991)
              {
                if (v23 == 1885823264) {
                  goto LABEL_829;
                }
                int v43 = 1885893152;
                goto LABEL_700;
              }
              if (v23 == 1886088992) {
                goto LABEL_711;
              }
              int v38 = 1886155808;
              goto LABEL_781;
            }
            if (v23 == 1885500704)
            {
LABEL_774:
              unsigned int v24 = 1886745376;
              goto LABEL_829;
            }
            if (v23 == 1885695008) {
              goto LABEL_823;
            }
            int v67 = 1885696800;
LABEL_553:
            if (v23 == v67)
            {
              unsigned int v24 = 1717662496;
              goto LABEL_829;
            }
            goto LABEL_830;
          }
          if (v23 <= 1886610719)
          {
            if (v23 == 1886221600 || v23 == 1886282272) {
              goto LABEL_701;
            }
            int v67 = 1886548768;
            goto LABEL_553;
          }
          if (v23 <= 1903518239)
          {
            if (v23 == 1886610720) {
              goto LABEL_823;
            }
            int v57 = 1886614560;
LABEL_773:
            if (v23 != v57) {
              goto LABEL_830;
            }
            goto LABEL_774;
          }
          if (v23 == 1903518240) {
            goto LABEL_806;
          }
          unsigned __int16 v53 = 25632;
        }
        int v51 = v53 | 0x71750000;
        goto LABEL_805;
      }
      int v15 = 0;
      int Value = 1398362702;
    }
    int v16 = 34;
    goto LABEL_40;
  }
LABEL_17:
  uint64_t v12 = qword_1EB2CE4C0;
  os_unfair_lock_unlock(&_MergedGlobals_26);
  return v12;
}

BOOL TBaseFont::Equal(atomic_ullong *this, atomic_ullong *a2)
{
  if (this == a2) {
    return 1;
  }
  int v4 = (*(uint64_t (**)(atomic_ullong *))(*this + 16))(this);
  if (v4 != (*(unsigned int (**)(atomic_ullong *))(*a2 + 16))(a2)) {
    return 0;
  }
  CFDictionaryRef explicit = (const void *)atomic_load_explicit(this + 10, memory_order_acquire);
  int v6 = (const void *)atomic_load_explicit(a2 + 10, memory_order_acquire);
  if (explicit != v6)
  {
    if (explicit) {
      BOOL v7 = v6 == 0;
    }
    else {
      BOOL v7 = 1;
    }
    if (!v7) {
      return CFEqual(explicit, v6) != 0;
    }
    return 0;
  }
  return 1;
}

BOOL TSplicedFont::Equal(atomic_ullong *this, atomic_ullong *a2)
{
  if (this == a2) {
    return 1;
  }
  int v4 = (*(uint64_t (**)(atomic_ullong *))(*this + 16))(this);
  BOOL result = 0;
  if (v4 == (*(unsigned int (**)(atomic_ullong *))(*a2 + 16))(a2))
  {
    CFDictionaryRef explicit = (const void *)atomic_load_explicit(this + 75, memory_order_acquire);
    int v6 = (const void *)atomic_load_explicit(a2 + 75, memory_order_acquire);
    if (explicit == v6) {
      return 1;
    }
    BOOL v7 = !explicit || v6 == 0;
    if (!v7 && CFEqual(explicit, v6)) {
      return 1;
    }
  }
  return result;
}

uint64_t TDescriptorSource::IsSearchableAttribute(TDescriptorSource *this, const __CFString *a2)
{
  if (qword_1EB2CE1D0 != -1) {
    dispatch_once_f(&qword_1EB2CE1D0, 0, (dispatch_function_t)TDescriptorSource::GetMatchableAttributes(void)::$_0::__invoke);
  }
  uint64_t result = qword_1EB2CE1C8;
  if (qword_1EB2CE1C8) {
    return CFSetContainsValue((CFSetRef)qword_1EB2CE1C8, this) != 0;
  }
  return result;
}

CTLineRef CTTypesetterCreateLine(CTTypesetterRef typesetter, CFRange stringRange)
{
  return (CTLineRef)TypesetterCreateLine(typesetter, stringRange, 0.0);
}

unint64_t CTLineCreateWithString(const __CFString *a1, const __CFDictionary *a2)
{
  __dst[34] = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  int v4 = ShouldCheckForKnownUrduSequences();
  if (a2
    && v4
    && (int Value = (atomic_ullong **)CFDictionaryGetValue(a2, @"NSFont")) != 0
    && TFont::IsSystemUIFontAndForShaping(Value[5], (BOOL *)__dst)
    && (v11.length = CFStringGetLength(a1), v11.CFIndex location = 0, StringContainsKnownUrduSequences(a1, v11)))
  {
    CFAttributedStringRef v6 = CFAttributedStringCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1, a2);
    unint64_t v7 = (unint64_t)CTLineCreateWithAttributedString(v6);
  }
  else
  {
    memcpy(__dst, &unk_184B88B40, 0x110uLL);
    TTypesetterString::TTypesetterString((TTypesetterString *)__dst, a1, a2);
    id v9 = (id)0xAAAAAAAAAAAAAAAALL;
    TCFBase_NEW<CTLine,std::shared_ptr<TCharStream const> const&>(__dst, &v9);
    if (atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire))
    {
      TTypesetter::FillLine((TTypesetter *)__dst, *(TLine **)(atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire) + 40), 1.79769313e308, 0.0);
      unint64_t v7 = ExternalizeLine((atomic_ullong *)&v9);
    }
    else
    {
      unint64_t v7 = 0;
    }

    if (__dst[31]) {
      std::__shared_weak_count::__release_shared[abi:nn180100]((std::__shared_weak_count *)__dst[31]);
    }
    TLine::~TLine((TLine *)__dst);
  }
  return v7;
}

uint64_t ShouldCheckForKnownUrduSequences(void)
{
  uint64_t result = _os_feature_enabled_impl();
  if (!result) {
    return result;
  }
  if (qword_1EB2CE288 != -1) {
    dispatch_once_f(&qword_1EB2CE288, 0, (dispatch_function_t)GetLocaleChangedCount(void)::$_0::__invoke);
  }
  int v1 = gLocaleChangedCount;
  if (dword_1EB2CE26C == gLocaleChangedCount) {
    return byte_1EB2CE259 != 0;
  }
  CFArrayRef v2 = CFLocaleCopyPreferredLanguages();
  CFArrayRef v3 = v2;
  int v18 = v1;
  if (!v2 || (CFIndex Count = CFArrayGetCount(v2)) == 0)
  {
    char v19 = 0;
    goto LABEL_37;
  }
  char v19 = 0;
  CFIndex v5 = 0;
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFIndex v7 = Count - 1;
  CFIndex v8 = (const void *)*MEMORY[0x1E4F1D218];
  while (1)
  {
    CFDictionaryRef ValueAtIndex = (__CFString *)CFArrayGetValueAtIndex(v3, v5);
    id ComponentsFromLocaleIdentifier = CFLocaleCreateComponentsFromLocaleIdentifier(v6, ValueAtIndex);
    CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&ComponentsFromLocaleIdentifier, memory_order_acquire);
    if (!explicit)
    {
      uint64_t v12 = 0;
      goto LABEL_14;
    }
    int Value = (__CFString *)CFDictionaryGetValue(explicit, v8);
    if (Value == @"ks") {
      break;
    }
    uint64_t v12 = Value;
    if (Value)
    {
      if (CFEqual(Value, @"ks")) {
        break;
      }
    }
LABEL_14:
    id v21 = (id)0xAAAAAAAAAAAAAAAALL;
    LanguageIdentifierByNormalizing(ValueAtIndex, 0, (atomic_ullong *)&v21);
    int v13 = (__CFString *)(id)atomic_load_explicit((atomic_ullong *volatile)&v21, memory_order_acquire);
    if (v13 == ValueAtIndex)
    {
    }
    else
    {
      int v14 = v13;
      if (ValueAtIndex && v13)
      {
        int v15 = CFEqual(v13, ValueAtIndex);

        if (v15) {
          goto LABEL_23;
        }
      }
      else
      {
      }
      id v20 = CFLocaleCreateComponentsFromLocaleIdentifier(v6, (CFLocaleIdentifier)atomic_load_explicit((atomic_ullong *volatile)&v21, memory_order_acquire));

      CFDictionaryRef v16 = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&ComponentsFromLocaleIdentifier, memory_order_acquire);
      if (!v16) {
        goto LABEL_30;
      }
      uint64_t v12 = (__CFString *)CFDictionaryGetValue(v16, v8);
    }
LABEL_23:
    if (v12 == @"ur") {
      goto LABEL_26;
    }
    if (!v12) {
      goto LABEL_31;
    }
    if (CFEqual(v12, @"ur"))
    {
LABEL_26:
      char v19 = 1;
LABEL_27:
      LOBYTE(v12) = 1;
      goto LABEL_31;
    }
    if (v12 == @"ar" || CFEqual(v12, @"ar")) {
      goto LABEL_27;
    }
LABEL_30:
    LOBYTE(v12) = 0;
LABEL_31:

    if ((v12 & 1) == 0 && v7 != v5++) {
      continue;
    }
    goto LABEL_37;
  }

LABEL_37:
  byte_1EB2CE259 = v19;
  dword_1EB2CE26C = v18;

  return byte_1EB2CE259 != 0;
}

CTLineRef CTLineCreateWithAttributedString(CFAttributedStringRef attrString)
{
  CFAttributedStringRef v1 = attrString;
  __dst[34] = *MEMORY[0x1E4F143B8];
  if (attrString)
  {
    memcpy(__dst, &unk_184B88B40, 0x110uLL);
    TTypesetterAttrString::TTypesetterAttrString((TTypesetterAttrString *)__dst, v1, 0, 0);
    id v3 = (id)0xAAAAAAAAAAAAAAAALL;
    TCFBase_NEW<CTLine,std::shared_ptr<TCharStream const> const&>(__dst, &v3);
    if (atomic_load_explicit((atomic_ullong *volatile)&v3, memory_order_acquire))
    {
      TTypesetter::FillLine((TTypesetter *)__dst, *(TLine **)(atomic_load_explicit((atomic_ullong *volatile)&v3, memory_order_acquire) + 40), 1.79769313e308, 0.0);
      CFAttributedStringRef v1 = (const __CFAttributedString *)ExternalizeLine((atomic_ullong *)&v3);
    }
    else
    {
      CFAttributedStringRef v1 = 0;
    }

    if (__dst[31]) {
      std::__shared_weak_count::__release_shared[abi:nn180100]((std::__shared_weak_count *)__dst[31]);
    }
    TLine::~TLine((TLine *)__dst);
  }
  return v1;
}

unint64_t CTLineCreateFromLineWithOffset(uint64_t a1, CFIndex a2, CFIndex a3, double a4)
{
  if (!a1) {
    return 0;
  }
  unint64_t v5 = 0;
  CFAllocatorRef v6 = *(uint64_t **)(a1 + 40);
  CFIndex v7 = v6[9];
  CFIndex v8 = v6[10] + v7;
  if (a3) {
    CFIndex v9 = a3;
  }
  else {
    CFIndex v9 = v8 - a2;
  }
  if ((v9 & 0x8000000000000000) == 0 && a2 >= v7 && v9 + a2 <= v8)
  {
    id v16 = (id)0xAAAAAAAAAAAAAAAALL;
    TCFBase_NEW<CTLine,std::shared_ptr<TCharStream const> const&>(v6, &v16);
    if (atomic_load_explicit((atomic_ullong *volatile)&v16, memory_order_acquire))
    {
      if (v8 <= a2) {
        v12.CFIndex location = 0;
      }
      else {
        v12.CFIndex location = a2;
      }
      int v13 = *(TLine **)(atomic_load_explicit((atomic_ullong *volatile)&v16, memory_order_acquire) + 40);
      int v14 = (const TLine *)*v6;
      if (v8 <= a2) {
        v12.CFIndex length = 0;
      }
      else {
        v12.CFIndex length = v9;
      }
      v17[0] = (const TLine *)v6;
      v17[1] = v14;
      v17[2] = 0;
      v17[3] = 0;
      v18[0] = 0;
      *(void *)((char *)v18 + 6) = 0;
      _OWORD v18[2] = 0;
      TTypesetter::FillLine(v17, v13, v12, 1.79769313e308, a4);
      unint64_t v5 = ExternalizeLine((atomic_ullong *)&v16);
    }
    else
    {
      unint64_t v5 = 0;
    }
  }
  return v5;
}

void TCFBase_NEW<CTLine,std::shared_ptr<TCharStream const> const&>(uint64_t *a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = TCFBase<TLine>::Allocate();
  if (v4)
  {
    uint64_t v6 = *a1;
    uint64_t v5 = a1[1];
    if (v5) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
    }
    *(void *)(v4 + 48) = v6;
    *(void *)(v4 + 16) = 0;
    *(void *)(v4 + 24) = 0;
    *(void *)(v4 + 32) = 0;
    *(void *)(v4 + 40) = v4 + 48;
    *(void *)(v4 + 56) = v5;
    *(void *)(v4 + 64) = 0;
    *(void *)(v4 + 72) = 0;
    *(void *)(v4 + 80) = 0;
    *(void *)(v4 + 112) = v4 + 88;
    *(unsigned char *)(v4 + 232) = 0;
    *(_OWORD *)(v4 + 120) = 0u;
    *(_OWORD *)(v4 + 136) = 0u;
    *(_OWORD *)(v4 + 152) = 0u;
    *(_OWORD *)(v4 + 168) = 0u;
    *(_OWORD *)(v4 + 184) = 0u;
    *(void *)(v4 + 197) = 0;
    *(void *)(v4 + 208) = 0;
    *(void *)(v4 + 216) = 0;
    *(unsigned char *)(v4 + 224) = 0;
    *(void *)(v4 + 248) = 0;
    *(void *)(v4 + 256) = 0;
    *(void *)(v4 + 240) = 0;
    *(void *)(v4 + 176) = 0xFFEFFFFFFFFFFFFFLL;
    id v7 = (id)v4;
    *a2 = atomic_exchange((atomic_ullong *volatile)&v7, 0);
  }
  else
  {
    *a2 = 0;
  }
}

uint64_t TCFBase<TLine>::Allocate()
{
  if (TCFBase<TLine>::GetTypeID(void)::once != -1) {
    dispatch_once_f(&TCFBase<TLine>::GetTypeID(void)::once, 0, (dispatch_function_t)TCFBase<TLine>::GetTypeID(void)::{lambda(void *)#1}::__invoke);
  }

  return _CFRuntimeCreateInstance();
}

unint64_t ExternalizeLine(atomic_ullong *a1)
{
  if (!atomic_load_explicit(a1, memory_order_acquire)) {
    return atomic_exchange(a1, 0);
  }
  uint64_t v2 = *(void *)(atomic_load_explicit(a1, memory_order_acquire) + 40);
  id v3 = *(uint64_t **)(v2 + 16);
  uint64_t v4 = *(void *)(v2 + 24) - (void)v3;
  if (v4 >= 1)
  {
    uint64_t v5 = (unint64_t)v4 >> 3;
    if ((unint64_t)v4 >> 3 <= 1) {
      uint64_t v5 = 1;
    }
    do
    {
      uint64_t v6 = *v3++;
      *(void *)(*(void *)(v6 + 48) + 272) = v2;
      --v5;
    }
    while (v5);
  }
  if ((*(_WORD *)(v2 + 154) & 8) != 0)
  {
    uint64_t v7 = v4 >> 3;
    uint64_t v8 = *(void *)(v2 + 72);
    uint64_t v9 = *(void *)(v2 + 88);
    if (v9) {
      goto LABEL_8;
    }
    uint64_t RunWithCharIndex = TLine::FindRunWithCharIndex((TLine *)v2, *(void *)(v2 + 72), 1);
    if (RunWithCharIndex >= v7)
    {
      uint64_t v9 = 0;
    }
    else
    {
      uint64_t v9 = *(void *)(*(void *)(*(void *)(v2 + 16) + 8 * RunWithCharIndex) + 48);
      if (v9)
      {
LABEL_8:
        if (*(unsigned char *)(v9 + 224)) {
          uint64_t v10 = *(void *)(v9 + 208) - 1;
        }
        else {
          uint64_t v10 = 0;
        }
        uint64_t v12 = *(void *)(v9 + 216);
        uint64_t v13 = *(void *)(v9 + 200);
        if (*(__int16 *)(*(void *)(v12 + 16) + 2 * v13 + 2 * v10) == -1
          && *(void *)(*(void *)(v12 + 48) + 8 * v13 + 8 * v10) == v8)
        {
          *(void *)(v9 + 264) = v10;
        }
      }
    }
    if (v4 >= 1)
    {
      uint64_t v14 = v7 - 1;
      do
      {
        int v15 = *(TRun **)(*(void *)(*(void *)(v2 + 16) + 8 * v14) + 48);
        if (v15 != (TRun *)v9 && !TRun::GetNonDeletedGlyphCount(v15)) {
          TLine::DeleteRun((TLine *)v2, v14);
        }
        uint64_t v16 = v14-- + 1;
      }
      while (v16 > 1);
    }
  }
  if ((*(_WORD *)(v2 + 154) & 0x20) != 0) {
    TLine::DoGlyphFixups((TLine *)v2);
  }
  return atomic_exchange(a1, 0);
}

void TTypesetter::FillLine(const TLine **a1, TLine *this, CFRange a3, double a4, double a5)
{
  TLine::CopyStringRange(this, *a1, a3);
  if (*((_WORD *)this + 76))
  {
    TTypesetter::FinishLineFill((uint64_t)a1, (uint64_t)this, a4, a5);
  }
}

void TLine::CopyStringRange(TLine *this, const TLine *a2, CFRange a3)
{
  CFIndex length = a3.length;
  CFIndex location = a3.location;
  uint64_t v121 = *MEMORY[0x1E4F143B8];
  BOOL v7 = a3.location == *((void *)a2 + 9) && a3.length == *((void *)a2 + 10);
  if (v7 && (*((_WORD *)a2 + 76) & 1) == 0)
  {
    TLine::operator=((uint64_t)this, (uint64_t *)a2);
    return;
  }
  uint64_t v9 = *(void *)a2;
  uint64_t v8 = *((void *)a2 + 1);
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = (std::__shared_weak_count *)*((void *)this + 1);
  *(void *)this = v9;
  *((void *)this + 1) = v8;
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v10);
  }
  *((void *)this + 9) = location;
  *((void *)this + 10) = length;
  if (*((unsigned char *)a2 + 155)) {
    *((_WORD *)this + 77) |= 0x100u;
  }
  uint64_t v11 = *((void *)a2 + 3) - *((void *)a2 + 2);
  if (v11 && length)
  {
    __int16 v12 = *((_WORD *)a2 + 77);
    if ((v12 & 0x20) != 0)
    {
      *((_WORD *)this + 77) |= 0x20u;
      __int16 v12 = *((_WORD *)a2 + 77);
    }
    uint64_t v13 = v11 >> 3;
    if ((v12 & 0x40) != 0)
    {
      if ((v12 & 0x80) != 0) {
        *((_WORD *)this + 77) |= 0x80u;
      }
      memset(v108, 0, sizeof(v108));
      unint64_t v109 = 0xAAAAAAAA3F800000;
      *(void *)&long long v33 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v33 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v119[14] = v33;
      v119[13] = v33;
      v119[12] = v33;
      v119[11] = v33;
      v119[10] = v33;
      v119[9] = v33;
      v119[8] = v33;
      v119[7] = v33;
      v119[6] = v33;
      v119[5] = v33;
      v119[4] = v33;
      v119[3] = v33;
      v119[2] = v33;
      v119[1] = v33;
      v119[0] = v33;
      unint64_t v116 = 0;
      CFNumberRef v117 = 0;
      unsigned int v118 = 0;
      uint64_t v120 = v119;
      if (v11 >= 1)
      {
        uint64_t v34 = 0;
        uint64_t v35 = location + length;
        if (v13 <= 1) {
          uint64_t v36 = 1;
        }
        else {
          uint64_t v36 = v11 >> 3;
        }
        do
        {
          uint64_t v37 = *(void *)(*((void *)a2 + 2) + 8 * v34);
          unint64_t v38 = *(void *)(v37 + 40);
          v110[0] = (void **)v38;
          uint64_t v40 = *(void *)(v38 + 8);
          uint64_t v39 = *(void *)(v38 + 16);
          CFIndex v41 = v39 + v40;
          if (v39 + v40 >= v35) {
            uint64_t v42 = v35;
          }
          else {
            uint64_t v42 = v39 + v40;
          }
          if (location <= v40 && v40 < v35)
          {
            uint64_t v45 = v42 - v40;
          }
          else if (v40 <= location && location < v41)
          {
            uint64_t v45 = v42 - location;
            uint64_t v40 = location;
          }
          else
          {
            uint64_t v40 = 0;
            uint64_t v45 = 0;
          }
          if (v45 < 1)
          {
            if (*((void *)this + 2) != *((void *)this + 3))
            {
              int v46 = v117;
              if (v117 >= v118)
              {
                int v48 = (char *)v116;
                uint64_t v49 = (uint64_t)&v117[-v116] >> 3;
                unint64_t v50 = v49 + 1;
                if ((unint64_t)(v49 + 1) >> 61) {
LABEL_162:
                }
                  abort();
                uint64_t v51 = (uint64_t)&v118[-v116];
                if ((uint64_t)&v118[-v116] >> 2 > v50) {
                  unint64_t v50 = v51 >> 2;
                }
                if ((unint64_t)v51 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v52 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v52 = v50;
                }
                *((void *)&v114[0] + 1) = v119;
                if (v52)
                {
                  unsigned __int16 v53 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v119, v52);
                  int v48 = (char *)v116;
                  int v46 = v117;
                }
                else
                {
                  unsigned __int16 v53 = 0;
                }
                unsigned __int16 v54 = &v53[8 * v49];
                *(void *)unsigned __int16 v54 = v34;
                if (v46 == v48)
                {
                  int v56 = &v53[8 * v49];
                }
                else
                {
                  int v55 = v46;
                  int v56 = &v53[8 * v49];
                  do
                  {
                    uint64_t v57 = *((void *)v55 - 1);
                    v55 -= 8;
                    *((void *)v56 - 1) = v57;
                    v56 -= 8;
                  }
                  while (v55 != v48);
                }
                unsigned __int16 v47 = v54 + 8;
                unint64_t v116 = (unint64_t)v56;
                CFNumberRef v117 = v54 + 8;
                int v58 = v118;
                unsigned int v118 = &v53[8 * v52];
                unint64_t v113 = (void **)v46;
                *(void *)&v114[0] = v58;
                CFNumberRef v111 = (void **)v48;
                CFNumberRef v112 = v48;
                std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v111);
              }
              else
              {
                *(void *)CFNumberRef v117 = v34;
                unsigned __int16 v47 = v46 + 8;
              }
              CFNumberRef v117 = v47;
            }
          }
          else
          {
            std::__hash_table<std::__hash_value_type<TRun const*,long>,std::__unordered_map_hasher<TRun const*,std::__hash_value_type<TRun const*,long>,std::hash<TRun const*>,std::equal_to<TRun const*>,true>,std::__unordered_map_equal<TRun const*,std::__hash_value_type<TRun const*,long>,std::equal_to<TRun const*>,std::hash<TRun const*>,true>,std::allocator<std::__hash_value_type<TRun const*,long>>>::__emplace_unique_key_args<TRun const*,std::piecewise_construct_t const&,std::tuple<TRun const* const&>,std::tuple<>>((uint64_t)v108, v38, v110)[3] = v34;
            TLine::InsertPartialRun(this, (uint64_t)(*((void *)this + 3) - *((void *)this + 2)) >> 3, v37, v40, v45);
          }
          ++v34;
        }
        while (v34 != v36);
      }
      uint64_t v59 = *((void *)this + 2);
      uint64_t v60 = *((void *)this + 3);
      if (v59 == v60) {
        goto LABEL_160;
      }
      *(void *)&long long v61 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v61 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v114[14] = v61;
      v114[13] = v61;
      v114[12] = v61;
      v114[11] = v61;
      v114[10] = v61;
      v114[9] = v61;
      v114[8] = v61;
      v114[7] = v61;
      v114[6] = v61;
      v114[5] = v61;
      v114[4] = v61;
      v114[3] = v61;
      v114[2] = v61;
      v114[1] = v61;
      v114[0] = v61;
      CFNumberRef v112 = 0;
      unint64_t v113 = 0;
      CFNumberRef v111 = 0;
      uint64_t v115 = v114;
      std::vector<long,TInlineBufferAllocator<long,30ul>>::reserve((char **)&v111, (v60 - v59) >> 3);
      unint64_t v62 = *((void *)a2 + 11);
      unint64_t v107 = v62;
      if (!v62) {
        goto LABEL_132;
      }
LABEL_96:
      if (!*((void *)&v108[0] + 1)) {
        goto LABEL_131;
      }
      unint64_t v63 = 0x9DDFEA08EB382D69 * (((8 * v62) + 8) ^ HIDWORD(v62));
      unint64_t v64 = 0x9DDFEA08EB382D69 * (HIDWORD(v62) ^ (v63 >> 47) ^ v63);
      unint64_t v65 = 0x9DDFEA08EB382D69 * (v64 ^ (v64 >> 47));
      uint8x8_t v66 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)v108 + 8));
      v66.i16[0] = vaddlv_u8(v66);
      if (v66.u32[0] > 1uLL)
      {
        unint64_t v67 = v65;
        if (v65 >= *((void *)&v108[0] + 1)) {
          unint64_t v67 = v65 % *((void *)&v108[0] + 1);
        }
      }
      else
      {
        unint64_t v67 = v65 & (*((void *)&v108[0] + 1) - 1);
      }
      unsigned __int16 v68 = *(void **)(*(void *)&v108[0] + 8 * v67);
      if (!v68) {
        goto LABEL_131;
      }
      int v69 = (void *)*v68;
      if (!v69) {
        goto LABEL_131;
      }
      while (1)
      {
        unint64_t v70 = v69[1];
        if (v70 == v65)
        {
          if (v69[2] == v62)
          {
            int v71 = std::__hash_table<std::__hash_value_type<TRun const*,long>,std::__unordered_map_hasher<TRun const*,std::__hash_value_type<TRun const*,long>,std::hash<TRun const*>,std::equal_to<TRun const*>,true>,std::__unordered_map_equal<TRun const*,std::__hash_value_type<TRun const*,long>,std::equal_to<TRun const*>,std::hash<TRun const*>,true>,std::allocator<std::__hash_value_type<TRun const*,long>>>::__emplace_unique_key_args<TRun const*,std::piecewise_construct_t const&,std::tuple<TRun const* const&>,std::tuple<>>((uint64_t)v108, v62, &v107);
            int v72 = v71;
            unint64_t v73 = (void **)v112;
            if (v112 < (char *)v113)
            {
              *(void *)CFNumberRef v112 = v71[3];
              unint64_t v74 = v73 + 1;
              goto LABEL_130;
            }
            unsigned int v75 = v111;
            uint64_t v76 = (v112 - (char *)v111) >> 3;
            unint64_t v77 = v76 + 1;
            if ((unint64_t)(v76 + 1) >> 61) {
              goto LABEL_162;
            }
            uint64_t v78 = (char *)v113 - (char *)v111;
            if (((char *)v113 - (char *)v111) >> 2 > v77) {
              unint64_t v77 = v78 >> 2;
            }
            if ((unint64_t)v78 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v79 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v79 = v77;
            }
            v110[4] = (void **)v114;
            if (v79)
            {
              CFNumberRef v80 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v114, v79);
              unsigned int v75 = v111;
              unint64_t v73 = (void **)v112;
            }
            else
            {
              CFNumberRef v80 = 0;
            }
            double v81 = &v80[8 * v76];
            *(void *)double v81 = v72[3];
            if (v73 == v75)
            {
              CFDictionaryRef v83 = &v80[8 * v76];
            }
            else
            {
              unint64_t v82 = v73;
              CFDictionaryRef v83 = &v80[8 * v76];
              do
              {
                uint64_t v84 = (uint64_t)*--v82;
                *((void *)v83 - 1) = v84;
                v83 -= 8;
              }
              while (v82 != v75);
            }
            unint64_t v74 = (void **)(v81 + 8);
            CFNumberRef v111 = (void **)v83;
            CFNumberRef v112 = v81 + 8;
            uint64_t v85 = v113;
            unint64_t v113 = (void **)&v80[8 * v79];
            v110[2] = v73;
            v110[3] = v85;
            v110[0] = v75;
            v110[1] = v75;
            std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)v110);
LABEL_130:
            CFNumberRef v112 = (char *)v74;
LABEL_131:
            unint64_t v62 = *(void *)(v62 + 24);
            unint64_t v107 = v62;
            if (!v62)
            {
LABEL_132:
              CFNumberRef v86 = (char *)v116;
              CFNumberRef v87 = v117;
              if ((char *)v116 != v117)
              {
                int64x2_t v88 = v117 - 8;
                if ((unint64_t)(v117 - 8) > v116)
                {
                  unint64_t v89 = v116 + 8;
                  do
                  {
                    uint64_t v90 = *(void *)(v89 - 8);
                    *(void *)(v89 - 8) = *(void *)v88;
                    *(void *)int64x2_t v88 = v90;
                    v88 -= 8;
                    BOOL v91 = v89 >= (unint64_t)v88;
                    v89 += 8;
                  }
                  while (!v91);
                }
              }
              char v93 = (char *)v111;
              uint64_t v92 = v112;
              while (v86 != v87)
              {
                if (v93 != v92)
                {
                  uint64_t v94 = *(void *)v86;
                  CFDictionaryRef v95 = v93;
                  do
                  {
                    if (*(void *)v95 > v94) {
                      --*(void *)v95;
                    }
                    v95 += 8;
                  }
                  while (v95 != v92);
                }
                v86 += 8;
              }
              int v96 = v93 + 8;
              int v97 = v93;
              if (v93 != v92)
              {
                int v97 = v93;
                if (v96 != v92)
                {
                  uint64_t v98 = *(void *)v93;
                  CFDictionaryRef v99 = v93 + 8;
                  int v97 = v93;
                  unsigned int v100 = v93 + 8;
                  do
                  {
                    uint64_t v102 = *(void *)v100;
                    v100 += 8;
                    uint64_t v101 = v102;
                    if (v102 < v98)
                    {
                      uint64_t v98 = v101;
                      int v97 = v99;
                    }
                    CFDictionaryRef v99 = v100;
                  }
                  while (v100 != v92);
                }
              }
              if (v93 != v92)
              {
                uint64_t v103 = *(void *)v97;
                if (v103)
                {
                  id v104 = v93;
                  do
                  {
                    *(void *)v104 -= v103;
                    v104 += 8;
                  }
                  while (v104 != v92);
                }
              }
              if (v93 != v92)
              {
                while (v96 != v92)
                {
                  uint64_t v106 = *((void *)v96 - 1);
                  uint64_t v105 = *(void *)v96;
                  v96 += 8;
                  if (v105 < v106)
                  {
                    *((_WORD *)this + 77) |= 0x40u;
                    break;
                  }
                }
              }
              TLine::LinkRunsWithOrder(this, (uint64_t *)&v111);
              v110[0] = (void **)&v111;
              std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](v110);
LABEL_160:
              CFNumberRef v111 = (void **)&v116;
              std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](&v111);
              std::__hash_table<EncoderAttempt,std::hash<EncoderAttempt>,std::equal_to<EncoderAttempt>,std::allocator<EncoderAttempt>>::~__hash_table((uint64_t)v108);
              return;
            }
            goto LABEL_96;
          }
        }
        else
        {
          if (v66.u32[0] > 1uLL)
          {
            if (v70 >= *((void *)&v108[0] + 1)) {
              v70 %= *((void *)&v108[0] + 1);
            }
          }
          else
          {
            v70 &= *((void *)&v108[0] + 1) - 1;
          }
          if (v70 != v67) {
            goto LABEL_131;
          }
        }
        int v69 = (void *)*v69;
        if (!v69) {
          goto LABEL_131;
        }
      }
    }
    uint64_t RunWithCharIndex = TLine::FindRunWithCharIndex(a2, location, 1);
    if (RunWithCharIndex >= v13) {
      return;
    }
    CFIndex v15 = location + length;
    uint64_t v16 = (char *)this + 96;
    while (1)
    {
      uint64_t v17 = *(void *)(*((void *)a2 + 2) + 8 * RunWithCharIndex);
      uint64_t v18 = *(void *)(v17 + 40);
      uint64_t v20 = *(void *)(v18 + 8);
      uint64_t v19 = *(void *)(v18 + 16);
      uint64_t v21 = v19 + v20;
      if (v19 + v20 >= v15) {
        CFIndex v22 = v15;
      }
      else {
        CFIndex v22 = v19 + v20;
      }
      uint64_t v23 = v22 - location;
      BOOL v24 = v20 <= location && location < v21;
      if (v24) {
        CFIndex v25 = location;
      }
      else {
        CFIndex v25 = 0;
      }
      if (!v24) {
        uint64_t v23 = 0;
      }
      uint64_t v26 = v22 - v20;
      BOOL v27 = location <= v20 && v20 < v15;
      if (v27) {
        uint64_t v28 = v20;
      }
      else {
        uint64_t v28 = v25;
      }
      if (v27) {
        uint64_t v29 = v26;
      }
      else {
        uint64_t v29 = v23;
      }
      if (v29 < 1) {
        return;
      }
      uint64_t v30 = *(void *)(TLine::InsertPartialRun(this, (uint64_t)(*((void *)this + 3) - *((void *)this + 2)) >> 3, v17, v28, v29)+ 40);
      if (*((void *)this + 11))
      {
        uint64_t v31 = *(void *)v16;
        *(void *)(*(void *)v16 + 24) = v30;
      }
      else
      {
        *((void *)this + 11) = v30;
        int v32 = (void *)((char *)this + 96);
        if (!v30) {
          goto LABEL_49;
        }
        uint64_t v31 = 0;
      }
      *(void *)(v30 + 32) = v31;
      *(void *)uint64_t v16 = v30;
      int v32 = (void *)(v30 + 24);
LABEL_49:
      *int v32 = 0;
      length -= v29;
      if (length >= 1)
      {
        uint64_t RunWithCharIndex = TLine::FindRunWithCharIndex(a2, v21, 1);
        if (RunWithCharIndex < v13) {
          continue;
        }
      }
      return;
    }
  }
}

unint64_t TLine::InsertPartialRun(TLine *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  id v9 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 64))(&v9, a3, a4, a5, 2);
  TLine::InsertRun(a1, a2, (const TRun **)atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire));
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire);

  return explicit;
}

void TLine::InsertRun(TLine *a1, uint64_t a2, const TRun **a3)
{
  uint64_t v5 = (uint64_t)a1 + 16;
  uint64_t v6 = (char *)(*((void *)a1 + 2) + 8 * a2);
  BOOL v7 = a3;
  std::vector<CTRun *,TInlineBufferAllocator<CTRun *,3ul>>::insert(v5, v6, &v7);
  TLine::UpdateCachedMetricsForRun(a1, a3[5]);
}

void CTGlyphRun::CloneRange(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int a4@<W3>, void *a5@<X8>)
{
  v8[0] = a2;
  v8[1] = a3;
  int v7 = a4;
  TCFBase_NEW<CTGlyphRun,TRun const&,CFRange &,TRun::SubrangingStyle &>(a1 + 72, v8, &v7, &v6);
  *a5 = atomic_exchange((atomic_ullong *volatile)&v6, 0);
}

void TCFBase_NEW<CTGlyphRun,TRun const&,CFRange &,TRun::SubrangingStyle &>(uint64_t a1@<X0>, uint64_t *a2@<X1>, int *a3@<X2>, void *a4@<X8>)
{
  uint64_t v8 = TCFBase<TRun>::Allocate();
  if (v8)
  {
    id v9 = (void *)v8;
    uint64_t v10 = *a2;
    CFIndex v11 = a2[1];
    int v12 = *a3;
    uint64_t v13 = v8 + 72;
    v9[2] = 0;
    id v9[3] = 0;
    void v9[4] = 0;
    void v9[5] = v13;
    v9[6] = v13;
    v9[7] = CTGlyphRun::CloneEntire;
    v9[8] = CTGlyphRun::CloneRange;
    TRun::TRun(v13, a1, v10, v11, v12);
    id v14 = v9;
    *a4 = atomic_exchange((atomic_ullong *volatile)&v14, 0);
  }
  else
  {
    *a4 = 0;
  }
}

uint64_t TRun::GetNonDeletedGlyphCount(TRun *this)
{
  uint64_t v1 = *((void *)this + 26);
  if ((*((unsigned char *)this + 225) & 8) != 0)
  {
    uint64_t v2 = 0;
    if (v1)
    {
      id v3 = (__int16 *)(*(void *)(*((void *)this + 27) + 16) + 2 * *((void *)this + 25));
      uint64_t v4 = 2 * v1;
      do
      {
        int v5 = *v3++;
        if (v5 != -1) {
          ++v2;
        }
        v4 -= 2;
      }
      while (v4);
    }
    if (*((void *)this + 33) == -1) {
      return v2;
    }
    else {
      return v2 + 1;
    }
  }
  return v1;
}

uint64_t TLine::operator=(uint64_t a1, uint64_t a2)
{
  v18[4] = *MEMORY[0x1E4F143B8];
  if (*(_WORD *)(a2 + 154))
  {
    *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
    uint64_t v5 = *(void *)a2;
    uint64_t v4 = *(void *)(a2 + 8);
    if (v4) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
    }
    id v6 = *(std::__shared_weak_count **)(a1 + 8);
    *(void *)a1 = v5;
    *(void *)(a1 + 8) = v4;
    if (v6) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v6);
    }
    *(_OWORD *)(a1 + 104) = *(_OWORD *)(a2 + 104);
    *(_OWORD *)(a1 + 120) = *(_OWORD *)(a2 + 120);
    *(void *)(a1 + 136) = *(void *)(a2 + 136);
    *(void *)(a1 + 144) = *(void *)(a2 + 144);
    *(_WORD *)(a1 + 152) = *(_WORD *)(a2 + 152);
    TCFRef<__CTFont const*>::Retain((atomic_ullong *)(a1 + 168), (id)atomic_load_explicit((atomic_ullong *volatile)(a2 + 168), memory_order_acquire));
    __int16 v7 = *(_WORD *)(a1 + 154);
    *(_WORD *)(a1 + 154) = *(_WORD *)(a2 + 154);
    *(_WORD *)(a2 + 154) = v7;
    id v9 = *(unsigned char **)(a1 + 16);
    uint64_t v8 = *(unsigned char **)(a1 + 24);
    uint64_t v17 = 0;
    memset(v18, 170, 24);
    CFIndex v15 = 0;
    __dst = 0;
    void v18[3] = v18;
    int64_t v10 = v8 - v9;
    if (v8 != v9)
    {
      std::vector<CTRun *,TInlineBufferAllocator<CTRun *,3ul>>::__vallocate[abi:nn180100](&v15, v10 >> 3);
      CFIndex v11 = (char *)__dst;
      memmove(__dst, v9, v10);
      __dst = &v11[v10];
    }
    std::vector<CTRun *,TInlineBufferAllocator<CTRun *,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<CTRun * const*>,std::__wrap_iter<CTRun * const*>>((char *)(a1 + 16), *(char **)(a2 + 16), *(void *)(a2 + 24), (uint64_t)(*(void *)(a2 + 24) - *(void *)(a2 + 16)) >> 3);
    std::vector<CTRun *,TInlineBufferAllocator<CTRun *,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<CTRun * const*>,std::__wrap_iter<CTRun * const*>>((char *)(a2 + 16), v15, (uint64_t)__dst, ((unsigned char *)__dst - v15) >> 3);
    std::vector<std::tuple<unsigned short,unsigned short,unsigned short>,TInlineBufferAllocator<std::tuple<unsigned short,unsigned short,unsigned short>,4ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v15);
    uint64_t v12 = *(void *)(a1 + 88);
    *(void *)(a1 + 88) = *(void *)(a2 + 88);
    *(void *)(a2 + 88) = v12;
    uint64_t v13 = *(void *)(a1 + 96);
    *(void *)(a1 + 96) = *(void *)(a2 + 96);
    *(void *)(a2 + 96) = v13;
  }
  else
  {
    TLine::operator=(a1, (uint64_t *)a2);
  }
  return a1;
}

void TLine::~TLine(TLine *this)
{
  uint64_t v2 = (void *)((char *)this + 16);
  __int16 v3 = *((_WORD *)this + 77);
  uint64_t v4 = *((void *)this + 3) - *((void *)this + 2);
  uint64_t v5 = v4 >> 3;
  if (!atomic_load_explicit((atomic_ullong *volatile)this + 20, memory_order_acquire))
  {
LABEL_18:
    uint64_t v6 = 0;
    goto LABEL_19;
  }
  if (CFGetRetainCount((CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)this + 20, memory_order_acquire)) == 1
    || !*(void *)this)
  {
    if (v4 >= 1)
    {
      uint64_t v6 = 0;
      if (v5 <= 1) {
        uint64_t v7 = 1;
      }
      else {
        uint64_t v7 = v4 >> 3;
      }
      while (1)
      {
        uint64_t v8 = *(void **)(*v2 + 8 * v6);
        if (v8)
        {
          if (CFGetRetainCount(*(CFTypeRef *)(*v2 + 8 * v6)) != 2 && *(void *)this) {
            goto LABEL_5;
          }
          if ((v3 & 1) == 0) {
            *(void *)(v8[6] + 272) = 0;
          }
          CFRelease(v8);
        }
        if (v7 == ++v6) {
          goto LABEL_25;
        }
      }
    }
    goto LABEL_18;
  }
  uint64_t v6 = 0;
LABEL_5:
  TLine::CachePositions((uint64_t)this);
LABEL_19:
  if (v6 < v5)
  {
    do
    {
      id v9 = *(void **)(*v2 + 8 * v6);
      if (v9)
      {
        if ((v3 & 1) == 0) {
          *(void *)(v9[6] + 272) = 0;
        }
        CFRelease(v9);
      }
      ++v6;
    }
    while (v5 != v6);
  }
LABEL_25:
  uint64_t v10 = *((void *)this + 26);
  if (v10) {
    MEMORY[0x1853275A0](v10, 0x1000C8099076E91);
  }
  uint64_t v11 = *((void *)this + 24);
  *((void *)this + 24) = 0;
  if (v11) {
    std::default_delete<TLine::TruncationInfo>::operator()[abi:nn180100]((uint64_t)this + 192, v11);
  }

  std::vector<std::tuple<unsigned short,unsigned short,unsigned short>,TInlineBufferAllocator<std::tuple<unsigned short,unsigned short,unsigned short>,4ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)v2);
  uint64_t v12 = (std::__shared_weak_count *)*((void *)this + 1);
  if (v12) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v12);
  }
}

void std::__shared_weak_count::__release_shared[abi:nn180100](std::__shared_weak_count *a1)
{
  if (!atomic_fetch_add(&a1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a1->__on_zero_shared)(a1);
    std::__shared_weak_count::__release_weak(a1);
  }
}

void std::vector<std::tuple<unsigned short,unsigned short,unsigned short>,TInlineBufferAllocator<std::tuple<unsigned short,unsigned short,unsigned short>,4ul>>::__destroy_vector::operator()[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  if (v2)
  {
    *(void *)(a1 + 8) = v2;
    __int16 v3 = (void *)(a1 + 48);
    if (a1 + 24 <= (unint64_t)v2)
    {
      BOOL v4 = v3 >= v2;
      BOOL v5 = v3 == v2;
    }
    else
    {
      BOOL v4 = 0;
      BOOL v5 = 0;
    }
    if (!v5 && v4)
    {
      if (*(void *)(a1 + 16) == *(void *)(a1 + 48)) {
        *__int16 v3 = v2;
      }
    }
    else
    {
      operator delete(v2);
    }
  }
}

char *std::vector<CTRun *,TInlineBufferAllocator<CTRun *,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<CTRun * const*>,std::__wrap_iter<CTRun * const*>>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  id v9 = *(char **)result;
  unint64_t v10 = (v8 - *(void *)result) >> 3;
  if (v10 < a4)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      uint64_t v11 = (void **)(result + 48);
      if (result + 24 <= v9 && v11 > (void **)v9)
      {
        if (&v9[8 * v10] == *v11) {
          char *v11 = v9;
        }
      }
      else
      {
        operator delete(v9);
      }
      uint64_t v8 = 0;
      *uint64_t v7 = 0;
      v7[1] = 0;
      void v7[2] = 0;
    }
    if (a4 >> 61) {
      abort();
    }
    uint64_t v20 = v8 >> 2;
    if (v8 >> 2 <= a4) {
      uint64_t v20 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v21 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v21 = v20;
    }
    uint64_t result = std::vector<CTRun *,TInlineBufferAllocator<CTRun *,3ul>>::__vallocate[abi:nn180100](v7, v21);
    CFIndex v22 = (char *)v7[1];
    id v14 = (void **)(v7 + 1);
    id v9 = v22;
LABEL_23:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      uint64_t v18 = v9;
      uint64_t v19 = __src;
      goto LABEL_25;
    }
    goto LABEL_26;
  }
  id v14 = (void **)(result + 8);
  uint64_t v13 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v13 - v9) >> 3;
  if (v15 >= a4) {
    goto LABEL_23;
  }
  uint64_t v16 = &__src[8 * v15];
  if (v13 != v9)
  {
    uint64_t result = (char *)memmove(*(void **)result, __src, 8 * v15);
    id v9 = (char *)*v14;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    uint64_t v18 = v9;
    uint64_t v19 = v16;
LABEL_25:
    uint64_t result = (char *)memmove(v18, v19, v17);
  }
LABEL_26:
  *id v14 = &v9[v17];
  return result;
}

char *std::vector<CTRun *,TInlineBufferAllocator<CTRun *,3ul>>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >> 61) {
    abort();
  }
  uint64_t result = (char *)TInlineBufferAllocator<CTRun *,3ul>::allocate((uint64_t)(a1 + 3), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * a2];
  return result;
}

void TTypesetter::FillLine(TTypesetter *this, TLine *a2, double a3, double a4)
{
  TLine::operator=((uint64_t)a2, (uint64_t)this);
  if (*((_WORD *)a2 + 76))
  {
    uint64_t v8 = this;
    long long v9 = *(_OWORD *)((char *)this + 216);
    uint64_t v10 = *((void *)this + 29);
    uint64_t v11 = (char *)this + 240;
    int v12 = *((_DWORD *)this + 65);
    char v13 = *((unsigned char *)this + 264);
    char v14 = *((unsigned char *)this + 257);
    uint64_t v15 = 0;
    TTypesetter::FinishLineFill((uint64_t)&v8, (uint64_t)a2, a3, a4);
  }
}

void TTypesetterAttrString::TTypesetterAttrString(TTypesetterAttrString *this, const __CFAttributedString *a2, const __CFDictionary *a3, char a4)
{
  uint64_t v8 = (std::__shared_weak_count *)operator new(0x50uLL);
  v8->__shared_owners_ = 0;
  v8->__shared_weak_owners_ = 0;
  v8->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ED0622E8;
  TCharStreamCFAttrString::TCharStreamCFAttrString((TCharStreamCFAttrString *)&v8[1], a2);
  uint64_t v10 = v9;
  uint64_t v11 = v8;
  TTypesetter::TTypesetter(this, &v10, a3);
  if (v11) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v11);
  }
  TTypesetterAttrString::Initialize(this, a2, a4);
}

void TCharStreamCFAttrString::TCharStreamCFAttrString(TCharStreamCFAttrString *this, const __CFAttributedString *a2)
{
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  *(void *)this = &unk_1ED05F140;
  *((void *)this + 1) = 0;
  *((void *)this + 6) = CFAttributedStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2);
  id v3 = (id)CFAttributedStringGetString((CFAttributedStringRef)atomic_load_explicit((atomic_ullong *volatile)this + 6, memory_order_acquire));
  id v4 = (id)atomic_exchange((atomic_ullong *volatile)&v3, 0);
  TCharStreamCFString::SetString(this, (atomic_ullong *)&v4);
}

void TTypesetter::TTypesetter(TTypesetter *this, uint64_t *a2, CFDictionaryRef theDict)
{
  uint64_t v4 = *a2;
  uint64_t v3 = a2[1];
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)this = v4;
  *((void *)this + 1) = v3;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 8) = (char *)this + 40;
  *((unsigned char *)this + 184) = 0;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(void *)((char *)this + 149) = 0;
  *((void *)this + 20) = 0;
  *((void *)this + 21) = 0;
  *((unsigned char *)this + 176) = 0;
  *((void *)this + 25) = 0;
  *((void *)this + 26) = 0;
  *((void *)this + 24) = 0;
  *((void *)this + 16) = 0xFFEFFFFFFFFFFFFFLL;
  *((void *)this + 27) = *a2;
  *((_DWORD *)this + 65) = 0;
  *((unsigned char *)this + 264) = 0;
  *((_WORD *)this + 128) = 0;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *((_WORD *)this + 77) = 1;
  if (theDict) {
    TTypesetter::UnpackOptions(this, theDict);
  }
}

const UniChar *TCharStreamCFString::SetString(void *a1, atomic_ullong *a2)
{
  uint64_t v3 = a1 + 4;

  a1[2] = CFStringGetLength((CFStringRef)atomic_load_explicit(v3, memory_order_acquire));
  uint64_t result = CFStringGetCharactersPtr((CFStringRef)atomic_load_explicit(v3, memory_order_acquire));
  a1[3] = result;
  return result;
}

uint64_t std::__shared_ptr_emplace<TCharStreamCFAttrString>::__on_zero_shared(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 48))();
}

void TCharStreamCFAttrString::~TCharStreamCFAttrString(id *this)
{
  *this = &unk_1ED05F140;
  uint64_t v2 = this + 5;

  *this = &unk_1ED05E8F8;
}

{
  uint64_t vars8;

  TCharStreamCFAttrString::~TCharStreamCFAttrString(this);

  JUMPOUT(0x1853275C0);
}

double TLine::UpdateWidth(atomic_ullong *this, double a2)
{
  double v2 = 0.0;
  if ((this[19] & 0x10) != 0)
  {

    __int16 v5 = *((_WORD *)this + 76);
    if ((v5 & 8) != 0) {
      uint64_t v6 = ((this[3] - this[2]) >> 3) - 1;
    }
    else {
      uint64_t v6 = 0;
    }
    if ((v5 & 8) != 0) {
      uint64_t v7 = -1;
    }
    else {
      uint64_t v7 = (this[3] - this[2]) >> 3;
    }
    if ((v5 & 8) != 0) {
      uint64_t v8 = -1;
    }
    else {
      uint64_t v8 = 1;
    }
    if (v6 != v7)
    {
      double v9 = 0.0;
      uint64_t v10 = (double *)MEMORY[0x1E4F1DB30];
      do
      {
        uint64_t v11 = *(void *)(*(void *)(this[2] + 8 * v6) + 40);
        if ((*(uint64_t (**)(uint64_t))(*(void *)v11 + 88))(v11))
        {
          TLine::DetachRun((TLine *)this, v6);
          uint64_t v13 = *(void *)(*(void *)(this[2] + 8 * v6) + 48);
          double v14 = *(double *)(v13 + 192);
          uint64_t v15 = *(double **)(v13 + 312);
          if (!v15) {
            uint64_t v15 = v10;
          }
          double v16 = *v15;
          v12.n128_f64[0] = v2 + v9 + a2;
          double v17 = (*(double (**)(void, atomic_ullong *, uint64_t, __n128))(*(void *)v13 + 96))(*(void *)(*(void *)(this[2] + 8 * v6) + 48), this, v6, v12);
          if ((*(double (**)(uint64_t))(*(void *)v13 + 56))(v13) > *((double *)this + 14)) {
            *((double *)this + 14) = (*(double (**)(uint64_t))(*(void *)v13 + 56))(v13);
          }
          double v18 = v14 + v16;
          double v2 = v2 + v17;
          if ((*(double (**)(uint64_t))(*(void *)v13 + 64))(v13) > *((double *)this + 15)) {
            *((double *)this + 15) = (*(double (**)(uint64_t))(*(void *)v13 + 64))(v13);
          }
        }
        else
        {
          uint64_t v19 = *(double **)(v11 + 312);
          if (!v19) {
            uint64_t v19 = v10;
          }
          double v18 = *(double *)(v11 + 192) + *v19;
        }
        double v9 = v9 + v18;
        v6 += v8;
      }
      while (v7 != v6);
    }
    *((double *)this + 13) = v2 + *((double *)this + 13);
  }
  return v2;
}

uint64_t TRun::CanUpdateWidth(TRun *this)
{
  return 0;
}

uint64_t TDelegateRun::CanUpdateWidth(TDelegateRun *this)
{
  return 1;
}

double TDelegateRun::UpdateWidth(TDelegateRun *this, TLine *a2, double a3)
{
  uint64_t v3 = (TDelegateRun *)((char *)this + 192);
  uint64_t v4 = *((void *)this + 26);
  __int16 v5 = (double (*)(uint64_t, TLine *, double))*((void *)this + 45);
  double v6 = 0.0;
  double v7 = 0.0;
  if (v5)
  {
    uint64_t v8 = *((void *)this + 41);
    uint64_t v9 = *((void *)this + 46);
    if (v8 == 2) {
      v5(v9, a2, a3);
    }
    else {
      double v10 = v5(v9, a2, a3);
    }
    double v7 = v10;
  }
  double v11 = v7 * (double)v4 - *(double *)v3;
  if (v11 != 0.0)
  {
    if (v4 >= 1)
    {
      for (uint64_t i = 0; i != v4; ++i)
      {
        v14.CGFloat height = 0.0;
        v14.CGFloat width = v7;
        TStorageRange::SetAdvance(v3, i, v14);
      }
    }
    return v11;
  }
  return v6;
}

void TLine::DeleteRun(TLine *this, uint64_t a2)
{
  uint64_t v4 = *((void *)this + 2);
  __int16 v5 = *(void **)(*(void *)(v4 + 8 * a2) + 48);
  double v7 = (void *)v5[3];
  uint64_t v6 = v5[4];
  if (*((void *)this + 3) - v4 >= 9)
  {
    uint64_t v9 = v5[1];
    uint64_t v8 = v5[2];
    if (v9 == *((void *)this + 9))
    {
      if (!v7)
      {
        uint64_t RunWithCharIndex = TLine::FindRunWithCharIndex(this, v8 + v9, 1);
        if (RunWithCharIndex == a2) {
          return;
        }
        double v7 = *(void **)(*(void *)(*((void *)this + 2) + 8 * RunWithCharIndex) + 48);
      }
      uint64_t v11 = v7[1];
      if (v9 >= v11) {
        uint64_t v12 = v7[1];
      }
      else {
        uint64_t v12 = v9;
      }
      uint64_t v13 = v7[2] + v11;
      if (v13 <= v8 + v9) {
        uint64_t v13 = v8 + v9;
      }
      v7[1] = v12;
      void v7[2] = v13 - v12;
    }
    else
    {
      uint64_t v14 = v9 - 1;
      if (!v6)
      {
        uint64_t v15 = TLine::FindRunWithCharIndex(this, v9 - 1, -1);
        if (v15 == a2) {
          return;
        }
        uint64_t v6 = *(void *)(*(void *)(*((void *)this + 2) + 8 * v15) + 48);
      }
      uint64_t v16 = *(void *)(v6 + 8);
      uint64_t v17 = *(void *)(v6 + 16) + v16;
      uint64_t v18 = v8 + v9;
      BOOL v19 = __OFSUB__(v8 + v9, v17);
      uint64_t v20 = v8 + v9 - v17;
      if (!((v20 < 0) ^ v19 | (v20 == 0)))
      {
        if (v9 >= v16) {
          uint64_t v21 = *(void *)(v6 + 8);
        }
        else {
          uint64_t v21 = v9;
        }
        uint64_t v22 = v18 - v21;
        uint64_t v23 = objc_msgSend(*(id *)(v6 + 216), "copyWithRange:", *(void *)(v6 + 200), *(void *)(v6 + 208));

        *(void *)(v6 + 216) = v23;
        *(void *)(v6 + 200) = 0;
        TRun::IncrementAttachCountForChar(v6, v14, v20);
        *(void *)(v6 + 8) = v21;
        *(void *)(v6 + 16) = v22;
      }
    }
  }
  *((void *)this + 18) -= v5[26];
  TLine::SimpleRunDelete(this, a2);
  if (v6)
  {
    *(void *)(v6 + 24) = v7;
    if (!v7)
    {
      *((void *)this + 12) = v6;
      *(void *)(v6 + 24) = 0;
      return;
    }
  }
  else
  {
    *((void *)this + 11) = v7;
    if (!v7)
    {
      *((void *)this + 12) = 0;
      return;
    }
  }
  uint64_t v7[4] = v6;
}

void TLine::DetachRun(TLine *this, uint64_t a2)
{
  uint64_t v4 = *(void *)(*((void *)this + 2) + 8 * a2);
  id v8 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr))(v4 + 56))(&v8);
  uint64_t v5 = *(void *)(atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire) + 48);
  uint64_t v6 = objc_msgSend(*(id *)(v5 + 216), "copyWithRange:", *(void *)(v5 + 200), *(void *)(v5 + 208));

  *(void *)(v5 + 216) = v6;
  *(void *)(v5 + 200) = 0;
  id v7 = (id)atomic_exchange((atomic_ullong *volatile)&v8, 0);
  TLine::ReplaceRun(this, a2, (atomic_ullong *)&v7);
}

void CTDelegateRun::CloneEntire(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = TCFBase<TRun>::Allocate();
  if (v4)
  {
    uint64_t v5 = (void *)v4;
    uint64_t v6 = (TDelegateRun *)(v4 + 72);
    v5[2] = 0;
    v5[3] = 0;
    v5[4] = 0;
    void v5[5] = v6;
    v5[6] = v6;
    v5[7] = CTDelegateRun::CloneEntire;
    v5[8] = CTDelegateRun::CloneRange;
    TDelegateRun::TDelegateRun(v6, (const TDelegateRun *)(a1 + 72));
    id v8 = v5;
    id v7 = (id)atomic_exchange((atomic_ullong *volatile)&v8, 0);
  }
  else
  {
    id v7 = 0;
  }
  *a2 = atomic_exchange((atomic_ullong *volatile)&v7, 0);
}

void TDelegateRun::TDelegateRun(TDelegateRun *this, const TDelegateRun *a2)
{
  TRun::TRun(this, a2);
  void *v4 = &unk_1ED05D7A0;
  *((void *)this + 40) = (id)atomic_load_explicit((atomic_ullong *volatile)a2 + 40, memory_order_acquire);
  long long v5 = *(_OWORD *)((char *)a2 + 328);
  long long v6 = *(_OWORD *)((char *)a2 + 344);
  *((void *)this + 45) = *((void *)a2 + 45);
  *(_OWORD *)((char *)this + 328) = v5;
  *(_OWORD *)((char *)this + 344) = v6;
  *((void *)this + 46) = *((void *)a2 + 46);
  *((void *)this + 47) = *((void *)a2 + 47);
  *((_OWORD *)this + 24) = *((_OWORD *)a2 + 24);
}

void TRun::TRun(TRun *this, const TRun *a2)
{
  *(void *)this = &unk_1ED05F378;
  long long v4 = *(_OWORD *)((char *)a2 + 8);
  *(_OWORD *)((char *)this + 40) = 0u;
  long long v5 = (char *)this + 40;
  *(_WORD *)((char *)this + 89) = 0;
  *((unsigned char *)this + 91) = 0;
  *((unsigned char *)this + 96) = 0;
  *((unsigned char *)this + 144) = 0;
  *((void *)this + 23) = 0;
  *((void *)this + 20) = 0;
  *((void *)this + 21) = 0;
  *(_OWORD *)((char *)this + 8) = v4;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  TAttributes::operator=((uint64_t)this + 40, (uint64_t)a2 + 40);
  TStorageRange::TStorageRange((TStorageRange *)(v5 + 152), (const TRun *)((char *)a2 + 192));
  *((void *)v5 + 27) = *((void *)a2 + 32);
  uint64_t v6 = *((void *)a2 + 34);
  *((void *)v5 + 28) = -1;
  *((void *)v5 + 29) = v6;
  id v7 = (_OWORD *)MEMORY[0x1E4F1DB30];
  *((void *)v5 + 30) = 0;
  *(_OWORD *)(v5 + 248) = *v7;
  *((_DWORD *)v5 + 66) = *((_DWORD *)a2 + 76);
  if (*((void *)a2 + 39)) {
    operator new();
  }
  *((void *)this + 39) = 0;
}

void TLine::ReplaceRun(void *a1, uint64_t a2, atomic_ullong *a3)
{
  long long v4 = *(void **)(a1[2] + 8 * a2);
  uint64_t v5 = v4[5];
  unint64_t v6 = atomic_exchange(a3, 0);
  uint64_t v7 = *(void *)(v6 + 48);
  uint64_t v8 = *(void *)(v5 + 32);
  if (v8)
  {
    *(void *)(v8 + 24) = v7;
  }
  else
  {
    a1[11] = v7;
    if (!v7)
    {
      uint64_t v9 = *(void *)(v5 + 24);
      if (!v9)
      {
        a1[12] = 0;
        goto LABEL_7;
      }
      goto LABEL_5;
    }
  }
  *(void *)(v7 + 32) = v8;
  uint64_t v9 = *(void *)(v5 + 24);
  if (!v9)
  {
    a1[12] = v7;
    *(void *)(v7 + 24) = 0;
    goto LABEL_7;
  }
LABEL_5:
  *(void *)(v7 + 24) = v9;
  *(void *)(v9 + 32) = v7;
LABEL_7:
  *(void *)(a1[2] + 8 * a2) = v6;
}

void TLine::SimpleRunDelete(TLine *this, uint64_t a2)
{
  uint64_t v3 = (id *)(*((void *)this + 2) + 8 * a2);

  long long v4 = (id *)*((void *)this + 3);
  int64_t v5 = (char *)v4 - (char *)(v3 + 1);
  if (v4 != v3 + 1) {
    memmove(v3, v3 + 1, (char *)v4 - (char *)(v3 + 1));
  }
  *((void *)this + 3) = (char *)v3 + v5;
}

uint64_t TRun::IncrementAttachCountForChar(uint64_t this, uint64_t a2, uint64_t a3)
{
  if (*(uint64_t *)(this + 208) >= 1)
  {
    uint64_t v4 = this;
    GlyphIndexForunsigned int Char = TRun::GetGlyphIndexForCharIndex<false>(this, a2);
    uint64_t v6 = [*(id *)(v4 + 216) attachmentCountAtIndex:*(void *)(v4 + 200) + GlyphIndexForChar] + a3;
    uint64_t v7 = *(void **)(v4 + 216);
    uint64_t v8 = *(void *)(v4 + 200) + GlyphIndexForChar;
    return [v7 setAttachmentCount:v6 atIndex:v8];
  }
  return this;
}

void TTypesetter::FinishLineFill(uint64_t a1, uint64_t a2, double a3, double a4)
{
  TTypesetter::MakeLineConsistent(a1, (TLine *)a2);
  TTypesetter::ReorderRunsIfNecessary(a1, a2);
  TLine::UpdateWidth((atomic_ullong *)a2, a4);
  if ((*(_WORD *)(a2 + 152) & 2) != 0)
  {
    uint64_t v9 = *(TLine **)(a1 + 8);
    v11[0] = (TLine *)a2;
    v11[1] = v9;
    TTabEngine::ApplyTabs(v11, a4, a3, v8, (uint64_t)v10);
  }
  *(double *)(a2 + 176) = a4;
  *(unsigned char *)(a2 + 184) = 1;
}

void TTypesetter::ReorderRunsIfNecessary(uint64_t a1, uint64_t a2)
{
  if ((*(_WORD *)(a2 + 152) & 1) != 0 && !*(unsigned char *)(a1 + 45))
  {
    uint64_t v3 = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v4 = (std::__shared_weak_count *)0xAAAAAAAAAAAAAAAALL;
    TTypesetter::GetLevelsProvider(a1, &v3);
    TRunReorder::ReorderRuns(v3, a2);
    if (v4) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v4);
    }
  }
}

void TTypesetter::MakeLineConsistent(uint64_t a1, TLine *this)
{
  if ((*((_WORD *)this + 76) & 4) != 0)
  {
    uint64_t v3 = *((void *)this + 2);
    uint64_t v4 = *((void *)this + 3) - v3;
    if (v4 >= 8)
    {
      uint64_t v6 = 0;
      uint64_t v7 = (unint64_t)v4 >> 3;
      do
      {
        uint64_t v8 = *(void *)(v3 + 8 * v6);
        if (*(_DWORD *)(*(void *)(v8 + 40) + 256) == 3)
        {
          TTypesetter::RelayoutRun(a1, v8, this, v6);
          uint64_t v3 = *((void *)this + 2);
          uint64_t v7 = (*((void *)this + 3) - v3) >> 3;
        }
        ++v6;
      }
      while (v6 < v7);
      TLine::SyncWithRuns(this);
    }
  }
}

uint64_t TLine::CachePositions(uint64_t this)
{
  if (!*(unsigned char *)(this + 156))
  {
    uint64_t v1 = this;
    uint64_t v2 = *(void *)(this + 16);
    uint64_t v3 = *(void *)(this + 24) - v2;
    if (v3 >= 1)
    {
      uint64_t v4 = *(void *)(*(void *)v2 + 40);
      uint64_t v10 = 0;
      double v11 = 0.0;
      TLine::GetLeftHangersGlyphCountAndWidth((TLine *)this, 0);
      if (v5 != 0.0) {
        double v11 = 0.0 - v5;
      }
      this = (*(uint64_t (**)(uint64_t, double *, uint64_t *))(*(void *)v4 + 112))(v4, &v11, &v10);
      if ((unint64_t)v3 >= 9)
      {
        uint64_t v6 = v3 >> 3;
        if (v3 >> 3 <= 2) {
          uint64_t v6 = 2;
        }
        uint64_t v7 = 8 * v6;
        uint64_t v8 = 8;
        do
        {
          uint64_t v9 = *(void *)(*(void *)(*(void *)(v1 + 16) + v8) + 40);
          this = (*(uint64_t (**)(uint64_t, double *, uint64_t *))(*(void *)v9 + 112))(v9, &v11, &v10);
          v8 += 8;
        }
        while (v7 != v8);
      }
    }
    *(unsigned char *)(v1 + 156) = 1;
  }
  return this;
}

void TRun::CacheGlyphPositions(TRun *this, double *a2, double *a3)
{
  uint64_t v71 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *((void *)this + 26);
  if ((unint64_t)v3 >> 60) {
    return;
  }
  uint64_t v4 = a3;
  double v5 = a2;
  double v7 = *a2;
  double v8 = *a3;
  uint64_t v9 = (double *)malloc_type_realloc(0, 16 * v3, 0xFE0C88B4uLL);
  if (!v9) {
    return;
  }
  uint64_t v10 = (float64x2_t *)v9;
  *((double *)this + 36) = v7;
  *((double *)this + 37) = v8;
  double v11 = (double *)*((void *)this + 39);
  if (!v11) {
    double v11 = (double *)MEMORY[0x1E4F1DB30];
  }
  double v12 = *v11;
  double v13 = v8 + v11[1];
  uint64_t v14 = *((void *)this + 20);
  if (v14) {
    double v15 = *(double *)(v14 + 48);
  }
  else {
    double v15 = 0.0;
  }
  double v16 = v7 + v12;
  double v17 = v13 + v15;
  if (*((unsigned char *)this + 90) || *((unsigned char *)this + 144))
  {
    unint64_t v63 = v4;
    uint64_t v18 = (void *)*((void *)this + 27);
    uint64_t v19 = *((void *)this + 25);
    uint64_t v20 = v18[4];
    if (v20 || (uint64_t v23 = v18[3]) == 0)
    {
      int v21 = 0;
      uint64_t v22 = v20 + 16 * v19;
    }
    else
    {
      uint64_t v22 = v23 + 8 * v19;
      int v21 = 1;
    }
    unint64_t v62 = v5;
    uint64_t v24 = v18[2];
    uint8x8_t v66 = *(TFont **)(atomic_load_explicit((atomic_ullong *volatile)this + 7, memory_order_acquire) + 40);
    CFIndex v25 = (char *)this + 96;
    if (!*((unsigned char *)this + 144)) {
      CFIndex v25 = (char *)MEMORY[0x1E4F1DAB8];
    }
    double v26 = *(double *)v25;
    double v27 = *((double *)v25 + 1);
    double v28 = *((double *)v25 + 2);
    CGFloat v29 = *((double *)v25 + 5);
    *(void *)&long long v30 = -1;
    *((void *)&v30 + 1) = -1;
    *(_OWORD *)&v69.c = v30;
    *(_OWORD *)&v69.tx = v30;
    *(_OWORD *)&v69.double a = v30;
    v70.double a = v26;
    v70.b = v27;
    v70.c = v28;
    long long v65 = *(_OWORD *)(v25 + 24);
    *(_OWORD *)&v70.d = v65;
    v70.ty = v29;
    CGAffineTransformInvert(&v69, &v70);
    v69.ty = -v69.ty;
    if (v3)
    {
      uint64_t v31 = 0;
      int v32 = (double *)MEMORY[0x1E4F1DAD8];
      uint64_t v64 = v24 + 2 * v19;
      do
      {
        uint64_t v67 = v3;
        if ((unint64_t)v3 >= 0x40) {
          uint64_t v3 = 64;
        }
        bzero(&v70, 0x400uLL);
        if (*(unsigned char *)v66)
        {
          TFont::GetUnscaledVerticalTranslationsForGlyphs(v66, (const unsigned __int16 *)(v64 + 2 * v31), (CGSize *)&v70, v3);
          p_b = &v70.b;
          uint64_t v34 = v3;
          do
          {
            double v35 = *(p_b - 1);
            double v36 = v28 * *p_b + v26 * v35;
            CGFloat v37 = *(double *)&v65 * *p_b + v27 * v35;
            *(p_b - 1) = v36;
            CGFloat *p_b = v37;
            p_b += 2;
            --v34;
          }
          while (v34);
        }
        uint64_t v38 = v3 + v31;
        uint64_t v39 = (double *)(v22 + 16 * v31);
        uint64_t v40 = &v70.b;
        do
        {
          double v41 = *(v40 - 1);
          double v42 = *v40;
          if ((*((unsigned char *)this + 225) & 0x10) != 0)
          {
            [*((id *)this + 27) originAtIndex:v31 + *((void *)this + 25)];
          }
          else
          {
            double v43 = *v32;
            double v44 = v32[1];
          }
          v10[v31] = vaddq_f64(*(float64x2_t *)&v69.tx, vmlaq_n_f64(vmulq_n_f64(*(float64x2_t *)&v69.c, v17 + v42 + v44), *(float64x2_t *)&v69.a, v16 + v41 + v43));
          if (v21)
          {
            uint64_t v45 = (double *)(v22 + 8 * v31);
            double v46 = 0.0;
          }
          else
          {
            double v46 = v39[1];
            uint64_t v45 = v39;
          }
          double v16 = v16 + *v45;
          double v17 = v17 + v46;
          ++v31;
          v40 += 2;
          v39 += 2;
        }
        while (v31 < v38);
        BOOL v47 = __OFSUB__(v67, v3);
        uint64_t v3 = v67 - v3;
      }
      while (!((v3 < 0) ^ v47 | (v3 == 0)));
    }
    double v5 = v62;
    uint64_t v4 = v63;
    goto LABEL_34;
  }
  uint64_t v49 = *((void *)this + 27);
  uint64_t v50 = *(void *)(v49 + 32);
  if (v50 || (uint64_t v52 = *(void *)(v49 + 24)) == 0)
  {
    int v51 = 0;
    unsigned __int16 v68 = (double *)(v50 + 16 * *((void *)this + 25));
    if (v3) {
      goto LABEL_43;
    }
  }
  else
  {
    unsigned __int16 v68 = (double *)(v52 + 8 * *((void *)this + 25));
    int v51 = 1;
    if (v3)
    {
LABEL_43:
      uint64_t v53 = v3;
      uint64_t v54 = 0;
      int v55 = v9 + 1;
      int v56 = (double *)MEMORY[0x1E4F1DAD8];
      uint64_t v57 = v68;
      do
      {
        if ((*((unsigned char *)this + 225) & 0x10) != 0)
        {
          [*((id *)this + 27) originAtIndex:v54 + *((void *)this + 25)];
        }
        else
        {
          double v58 = *v56;
          double v59 = v56[1];
        }
        *(v55 - 1) = v16 + v58;
        *int v55 = v17 + v59;
        if (v51)
        {
          uint64_t v60 = &v68[v54];
          double v61 = 0.0;
        }
        else
        {
          double v61 = v57[1];
          uint64_t v60 = v57;
        }
        double v16 = v16 + *v60;
        double v17 = v17 + v61;
        ++v54;
        v57 += 2;
        v55 += 2;
      }
      while (v53 != v54);
    }
  }
LABEL_34:
  uint64_t v48 = 0;
  atomic_compare_exchange_strong((atomic_ullong *volatile)this + 35, (unint64_t *)&v48, (unint64_t)v10);
  if (v48) {
    free(v10);
  }
  *double v5 = v16;
  double *v4 = v17 - v15;
}

uint64_t std::__shared_ptr_emplace<TCharStreamCFString>::__on_zero_shared(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 48))();
}

void TCharStreamCFString::~TCharStreamCFString(id *this)
{
  *this = &unk_1ED05E8F8;
  uint64_t v1 = this + 4;
}

{
  id *v1;
  uint64_t vars8;

  *this = &unk_1ED05E8F8;
  uint64_t v1 = this + 4;

  JUMPOUT(0x1853275C0);
}

void TTypesetterString::TTypesetterString(TTypesetterString *this, const __CFString *a2, const __CFDictionary *a3)
{
  uint64_t v6 = (std::__shared_weak_count *)operator new(0x48uLL);
  v6->__shared_weak_owners_ = 0;
  v6->__shared_owners_ = 0;
  v6->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ED062278;
  TCharStreamCFString::TCharStreamCFString((TCharStreamCFString *)&v6[1], a2, a3);
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  *(void *)this = v7;
  *((void *)this + 1) = v6;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 8) = (char *)this + 40;
  *((unsigned char *)this + 184) = 0;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(void *)((char *)this + 149) = 0;
  *((void *)this + 20) = 0;
  *((void *)this + 21) = 0;
  *((unsigned char *)this + 176) = 0;
  *((void *)this + 24) = 0;
  *((void *)this + 25) = 0;
  *((void *)this + 16) = 0xFFEFFFFFFFFFFFFFLL;
  *((void *)this + 26) = 0;
  *((void *)this + 27) = v7;
  *((_DWORD *)this + 65) = 0;
  *((unsigned char *)this + 264) = 0;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *((_WORD *)this + 128) = 0;
  *((_WORD *)this + 77) = 1;
  std::__shared_weak_count::__release_shared[abi:nn180100](v6);
  TTypesetterString::Initialize(this, v8, a3);
}

void TCharStreamCFString::TCharStreamCFString(TCharStreamCFString *this, const __CFString *a2, const __CFDictionary *a3)
{
  *(void *)this = &unk_1ED05E8F8;
  *((void *)this + 1) = 0;
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  *((void *)this + 4) = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2);
  if (a3) {
    CFDictionaryRef Copy = CFDictionaryCreateCopy(v5, a3);
  }
  else {
    CFDictionaryRef Copy = 0;
  }
  *((void *)this + 5) = Copy;
  *((void *)this + 2) = CFStringGetLength((CFStringRef)atomic_load_explicit((atomic_ullong *volatile)this + 4, memory_order_acquire));
  *((void *)this + 3) = CFStringGetCharactersPtr((CFStringRef)atomic_load_explicit((atomic_ullong *volatile)this + 4, memory_order_acquire));
}

uint64_t TLine::operator=(uint64_t a1, uint64_t *a2)
{
  uint64_t v114 = *MEMORY[0x1E4F143B8];
  if ((uint64_t *)a1 == a2) {
    return a1;
  }
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 9);
  uint64_t v5 = *a2;
  uint64_t v4 = a2[1];
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 8);
  *(void *)a1 = v5;
  *(void *)(a1 + 8) = v4;
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v6);
  }
  *(_OWORD *)(a1 + 104) = *(_OWORD *)(a2 + 13);
  *(_OWORD *)(a1 + 120) = *(_OWORD *)(a2 + 15);
  *(void *)(a1 + 136) = a2[17];
  *(void *)(a1 + 144) = a2[18];
  *(_WORD *)(a1 + 152) = *((_WORD *)a2 + 76);
  *(_WORD *)(a1 + 154) = *((_WORD *)a2 + 77) & 0xFFFE;
  TCFRef<__CTFont const*>::Retain((atomic_ullong *)(a1 + 168), (id)atomic_load_explicit(a2 + 21, memory_order_acquire));
  uint64_t v7 = a2[2];
  uint64_t v8 = a2[3] - v7;
  uint64_t v9 = v8 >> 3;
  if (!(v8 >> 3)) {
    return a1;
  }
  if (v9 == 1)
  {
    (*(void (**)(id *__return_ptr))(*(void *)v7 + 56))(v109);
    unint64_t v10 = atomic_exchange((atomic_ullong *volatile)v109, 0);
    double v12 = *(unint64_t **)(a1 + 24);
    unint64_t v11 = *(void *)(a1 + 32);
    if ((unint64_t)v12 >= v11)
    {
      uint64_t v69 = *(void *)(a1 + 16);
      uint64_t v70 = ((uint64_t)v12 - v69) >> 3;
      if ((unint64_t)(v70 + 1) >> 61) {
LABEL_131:
      }
        abort();
      uint64_t v71 = v11 - v69;
      uint64_t v72 = v71 >> 2;
      if (v71 >> 2 <= (unint64_t)(v70 + 1)) {
        uint64_t v72 = v70 + 1;
      }
      if ((unint64_t)v71 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v73 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v73 = v72;
      }
      *((void *)&v112[0] + 1) = a1 + 40;
      if (v73) {
        unint64_t v74 = (char *)TInlineBufferAllocator<CTRun *,3ul>::allocate(a1 + 40, v73);
      }
      else {
        unint64_t v74 = 0;
      }
      uint64_t v94 = (unint64_t *)&v74[8 * v70];
      CFDictionaryRef v95 = &v74[8 * v73];
      *(void *)&v112[0] = v95;
      *uint64_t v94 = v10;
      double v13 = v94 + 1;
      v111.i64[1] = (uint64_t)(v94 + 1);
      uint64_t v97 = *(void *)(a1 + 16);
      unint64_t v96 = *(void *)(a1 + 24);
      if (v96 == v97)
      {
        int64x2_t v99 = vdupq_n_s64(v96);
      }
      else
      {
        do
        {
          unint64_t v98 = *(void *)(v96 - 8);
          v96 -= 8;
          *--uint64_t v94 = v98;
        }
        while (v96 != v97);
        int64x2_t v99 = *(int64x2_t *)(a1 + 16);
        double v13 = (void *)v111.i64[1];
        CFDictionaryRef v95 = *(char **)&v112[0];
      }
      *(void *)(a1 + 16) = v94;
      *(void *)(a1 + 24) = v13;
      int64x2_t v111 = v99;
      uint64_t v100 = *(void *)(a1 + 32);
      *(void *)(a1 + 32) = v95;
      *(void *)&v112[0] = v100;
      id v110 = (char *)v99.i64[0];
      std::__split_buffer<CTRun *,TInlineBufferAllocator<CTRun *,3ul> &>::~__split_buffer((uint64_t)&v110);
    }
    else
    {
      *double v12 = v10;
      double v13 = v12 + 1;
    }
    *(void *)(a1 + 24) = v13;

    uint64_t v101 = *(void *)(**(void **)(a1 + 16) + 48);
    *(void *)(a1 + 88) = v101;
    if (v101)
    {
      *(void *)(a1 + 96) = v101;
      *(void *)(v101 + 24) = 0;
      *(void *)(v101 + 32) = 0;
    }
    else
    {
      *(void *)(a1 + 96) = 0;
    }
    return a1;
  }
  unint64_t v14 = a2[11];
  if (v14)
  {
    int64_t v103 = v8 >> 3;
    long long v106 = 0u;
    long long v107 = 0u;
    unint64_t v108 = 0xAAAAAAAA3F800000;
    if (v8 < 1)
    {
LABEL_71:
      *(void *)&long long v53 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v53 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v112[14] = v53;
      v112[13] = v53;
      v112[12] = v53;
      v112[11] = v53;
      v112[10] = v53;
      v112[9] = v53;
      v112[8] = v53;
      v112[7] = v53;
      v112[6] = v53;
      v112[5] = v53;
      v112[4] = v53;
      v112[3] = v53;
      v112[2] = v53;
      v112[1] = v53;
      v112[0] = v53;
      int64x2_t v111 = 0uLL;
      id v110 = 0;
      unint64_t v113 = v112;
      std::vector<long,TInlineBufferAllocator<long,30ul>>::reserve(&v110, v103);
      unint64_t v105 = v14;
      do
      {
        uint64_t v54 = std::__hash_table<std::__hash_value_type<TRun const*,long>,std::__unordered_map_hasher<TRun const*,std::__hash_value_type<TRun const*,long>,std::hash<TRun const*>,std::equal_to<TRun const*>,true>,std::__unordered_map_equal<TRun const*,std::__hash_value_type<TRun const*,long>,std::equal_to<TRun const*>,std::hash<TRun const*>,true>,std::allocator<std::__hash_value_type<TRun const*,long>>>::__emplace_unique_key_args<TRun const*,std::piecewise_construct_t const&,std::tuple<TRun const* const&>,std::tuple<>>((uint64_t)&v106, v14, &v105);
        int v55 = v54;
        int v56 = (char *)v111.i64[0];
        if (v111.i64[0] >= (unint64_t)v111.i64[1])
        {
          double v58 = v110;
          uint64_t v59 = (v111.i64[0] - (uint64_t)v110) >> 3;
          unint64_t v60 = v59 + 1;
          if ((unint64_t)(v59 + 1) >> 61) {
            goto LABEL_131;
          }
          uint64_t v61 = v111.i64[1] - (void)v110;
          if ((v111.i64[1] - (uint64_t)v110) >> 2 > v60) {
            unint64_t v60 = v61 >> 2;
          }
          if ((unint64_t)v61 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v62 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v62 = v60;
          }
          v109[4] = v112;
          if (v62)
          {
            unint64_t v63 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v112, v62);
            double v58 = v110;
            int v56 = (char *)v111.i64[0];
          }
          else
          {
            unint64_t v63 = 0;
          }
          uint64_t v64 = &v63[8 * v59];
          *(void *)uint64_t v64 = v55[3];
          if (v56 == v58)
          {
            uint8x8_t v66 = &v63[8 * v59];
          }
          else
          {
            long long v65 = v56;
            uint8x8_t v66 = &v63[8 * v59];
            do
            {
              uint64_t v67 = *((void *)v65 - 1);
              v65 -= 8;
              *((void *)v66 - 1) = v67;
              v66 -= 8;
            }
            while (v65 != v58);
          }
          uint64_t v57 = v64 + 8;
          id v110 = v66;
          v111.i64[0] = (uint64_t)(v64 + 8);
          unsigned __int16 v68 = (void *)v111.i64[1];
          v111.i64[1] = (uint64_t)&v63[8 * v62];
          v109[2] = v56;
          v109[3] = v68;
          v109[0] = v58;
          v109[1] = v58;
          std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)v109);
        }
        else
        {
          *(void *)v111.i64[0] = v54[3];
          uint64_t v57 = v56 + 8;
        }
        v111.i64[0] = (uint64_t)v57;
        unint64_t v14 = *(void *)(v14 + 24);
        unint64_t v105 = v14;
      }
      while (v14);
      TLine::LinkRunsWithOrder((void *)a1, (uint64_t *)&v110);
      v109[0] = &v110;
      std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v109);
      std::__hash_table<EncoderAttempt,std::hash<EncoderAttempt>,std::equal_to<EncoderAttempt>,std::allocator<EncoderAttempt>>::~__hash_table((uint64_t)&v106);
      return a1;
    }
    uint64_t v15 = 0;
    uint64_t v16 = v8 >> 3;
    if (v103 <= 1) {
      uint64_t v16 = 1;
    }
    uint64_t v104 = v16;
    while (1)
    {
      uint64_t v17 = *(void *)(a2[2] + 8 * v15);
      unint64_t v18 = *(void *)(v17 + 40);
      unint64_t v19 = 0x9DDFEA08EB382D69 * (((8 * v18) + 8) ^ HIDWORD(v18));
      unint64_t v20 = 0x9DDFEA08EB382D69 * (HIDWORD(v18) ^ (v19 >> 47) ^ v19);
      unint64_t v21 = 0x9DDFEA08EB382D69 * (v20 ^ (v20 >> 47));
      unint64_t v22 = *((void *)&v106 + 1);
      if (*((void *)&v106 + 1))
      {
        uint8x8_t v23 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v106 + 8));
        v23.i16[0] = vaddlv_u8(v23);
        if (v23.u32[0] > 1uLL)
        {
          unint64_t v24 = 0x9DDFEA08EB382D69 * (v20 ^ (v20 >> 47));
          if (v21 >= *((void *)&v106 + 1)) {
            unint64_t v24 = v21 % *((void *)&v106 + 1);
          }
        }
        else
        {
          unint64_t v24 = v21 & (*((void *)&v106 + 1) - 1);
        }
        CFIndex v25 = *(void ***)(v106 + 8 * v24);
        if (v25)
        {
          for (uint64_t i = *v25; i; uint64_t i = (void *)*i)
          {
            unint64_t v27 = i[1];
            if (v27 == v21)
            {
              if (i[2] == v18) {
                goto LABEL_54;
              }
            }
            else
            {
              if (v23.u32[0] > 1uLL)
              {
                if (v27 >= *((void *)&v106 + 1)) {
                  v27 %= *((void *)&v106 + 1);
                }
              }
              else
              {
                v27 &= *((void *)&v106 + 1) - 1;
              }
              if (v27 != v24) {
                break;
              }
            }
          }
        }
      }
      else
      {
        unint64_t v24 = 0xAAAAAAAAAAAAAAAALL;
      }
      uint64_t i = operator new(0x20uLL);
      *uint64_t i = 0;
      i[1] = v21;
      i[2] = v18;
      i[3] = 0;
      float v28 = (float)(unint64_t)(*((void *)&v107 + 1) + 1);
      if (!v22 || (float)(*(float *)&v108 * (float)v22) < v28)
      {
        BOOL v29 = (v22 & (v22 - 1)) != 0;
        if (v22 < 3) {
          BOOL v29 = 1;
        }
        unint64_t v30 = v29 | (2 * v22);
        unint64_t v31 = vcvtps_u32_f32(v28 / *(float *)&v108);
        if (v30 <= v31) {
          size_t v32 = v31;
        }
        else {
          size_t v32 = v30;
        }
        std::__hash_table<std::__hash_value_type<TRun const*,long>,std::__unordered_map_hasher<TRun const*,std::__hash_value_type<TRun const*,long>,std::hash<TRun const*>,std::equal_to<TRun const*>,true>,std::__unordered_map_equal<TRun const*,std::__hash_value_type<TRun const*,long>,std::equal_to<TRun const*>,std::hash<TRun const*>,true>,std::allocator<std::__hash_value_type<TRun const*,long>>>::__rehash<true>((uint64_t)&v106, v32);
        unint64_t v22 = *((void *)&v106 + 1);
        if ((*((void *)&v106 + 1) & (*((void *)&v106 + 1) - 1)) != 0)
        {
          if (v21 >= *((void *)&v106 + 1)) {
            unint64_t v24 = v21 % *((void *)&v106 + 1);
          }
          else {
            unint64_t v24 = v21;
          }
        }
        else
        {
          unint64_t v24 = (*((void *)&v106 + 1) - 1) & v21;
        }
      }
      uint64_t v33 = v106;
      uint64_t v34 = *(void **)(v106 + 8 * v24);
      if (v34)
      {
        *uint64_t i = *v34;
      }
      else
      {
        *uint64_t i = v107;
        *(void *)&long long v107 = i;
        *(void *)(v33 + 8 * v24) = &v107;
        if (!*i) {
          goto LABEL_53;
        }
        unint64_t v35 = *(void *)(*i + 8);
        if ((v22 & (v22 - 1)) != 0)
        {
          if (v35 >= v22) {
            v35 %= v22;
          }
        }
        else
        {
          v35 &= v22 - 1;
        }
        uint64_t v34 = (void *)(v106 + 8 * v35);
      }
      void *v34 = i;
LABEL_53:
      ++*((void *)&v107 + 1);
LABEL_54:
      i[3] = v15;
      (*(void (**)(id *__return_ptr, uint64_t))(v17 + 56))(v109, v17);
      unint64_t v36 = atomic_exchange((atomic_ullong *volatile)v109, 0);
      uint64_t v38 = *(unint64_t **)(a1 + 24);
      unint64_t v37 = *(void *)(a1 + 32);
      if ((unint64_t)v38 >= v37)
      {
        uint64_t v40 = *(void *)(a1 + 16);
        uint64_t v41 = ((uint64_t)v38 - v40) >> 3;
        if ((unint64_t)(v41 + 1) >> 61) {
          goto LABEL_131;
        }
        uint64_t v42 = v37 - v40;
        uint64_t v43 = v42 >> 2;
        if (v42 >> 2 <= (unint64_t)(v41 + 1)) {
          uint64_t v43 = v41 + 1;
        }
        if ((unint64_t)v42 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v44 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v44 = v43;
        }
        *((void *)&v112[0] + 1) = a1 + 40;
        if (v44) {
          uint64_t v45 = (char *)TInlineBufferAllocator<CTRun *,3ul>::allocate(a1 + 40, v44);
        }
        else {
          uint64_t v45 = 0;
        }
        double v46 = (unint64_t *)&v45[8 * v41];
        BOOL v47 = &v45[8 * v44];
        *(void *)&v112[0] = v47;
        *double v46 = v36;
        uint64_t v39 = v46 + 1;
        v111.i64[1] = (uint64_t)(v46 + 1);
        uint64_t v49 = *(void *)(a1 + 16);
        unint64_t v48 = *(void *)(a1 + 24);
        if (v48 == v49)
        {
          int64x2_t v51 = vdupq_n_s64(v48);
        }
        else
        {
          do
          {
            unint64_t v50 = *(void *)(v48 - 8);
            v48 -= 8;
            *--double v46 = v50;
          }
          while (v48 != v49);
          int64x2_t v51 = *(int64x2_t *)(a1 + 16);
          uint64_t v39 = (void *)v111.i64[1];
          BOOL v47 = *(char **)&v112[0];
        }
        *(void *)(a1 + 16) = v46;
        *(void *)(a1 + 24) = v39;
        int64x2_t v111 = v51;
        uint64_t v52 = *(void *)(a1 + 32);
        *(void *)(a1 + 32) = v47;
        *(void *)&v112[0] = v52;
        id v110 = (char *)v51.i64[0];
        std::__split_buffer<CTRun *,TInlineBufferAllocator<CTRun *,3ul> &>::~__split_buffer((uint64_t)&v110);
      }
      else
      {
        *uint64_t v38 = v36;
        uint64_t v39 = v38 + 1;
      }
      *(void *)(a1 + 24) = v39;

      if (++v15 == v104) {
        goto LABEL_71;
      }
    }
  }
  if (v8 >= 1)
  {
    uint64_t v75 = 0;
    if (v9 <= 1) {
      uint64_t v76 = 1;
    }
    else {
      uint64_t v76 = v8 >> 3;
    }
    do
    {
      (*(void (**)(id *__return_ptr))(*(void *)(a2[2] + 8 * v75) + 56))(v109);
      unint64_t v77 = atomic_exchange((atomic_ullong *volatile)v109, 0);
      unint64_t v79 = *(unint64_t **)(a1 + 24);
      unint64_t v78 = *(void *)(a1 + 32);
      if ((unint64_t)v79 >= v78)
      {
        uint64_t v81 = *(void *)(a1 + 16);
        uint64_t v82 = ((uint64_t)v79 - v81) >> 3;
        if ((unint64_t)(v82 + 1) >> 61) {
          goto LABEL_131;
        }
        uint64_t v83 = v78 - v81;
        uint64_t v84 = v83 >> 2;
        if (v83 >> 2 <= (unint64_t)(v82 + 1)) {
          uint64_t v84 = v82 + 1;
        }
        if ((unint64_t)v83 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v85 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v85 = v84;
        }
        *((void *)&v112[0] + 1) = a1 + 40;
        if (v85) {
          CFNumberRef v86 = (char *)TInlineBufferAllocator<CTRun *,3ul>::allocate(a1 + 40, v85);
        }
        else {
          CFNumberRef v86 = 0;
        }
        CFNumberRef v87 = (unint64_t *)&v86[8 * v82];
        int64x2_t v88 = &v86[8 * v85];
        *(void *)&v112[0] = v88;
        unint64_t *v87 = v77;
        CFNumberRef v80 = v87 + 1;
        v111.i64[1] = (uint64_t)(v87 + 1);
        uint64_t v90 = *(void *)(a1 + 16);
        unint64_t v89 = *(void *)(a1 + 24);
        if (v89 == v90)
        {
          int64x2_t v92 = vdupq_n_s64(v89);
        }
        else
        {
          do
          {
            unint64_t v91 = *(void *)(v89 - 8);
            v89 -= 8;
            *--CFNumberRef v87 = v91;
          }
          while (v89 != v90);
          int64x2_t v92 = *(int64x2_t *)(a1 + 16);
          CFNumberRef v80 = (void *)v111.i64[1];
          int64x2_t v88 = *(char **)&v112[0];
        }
        *(void *)(a1 + 16) = v87;
        *(void *)(a1 + 24) = v80;
        int64x2_t v111 = v92;
        uint64_t v93 = *(void *)(a1 + 32);
        *(void *)(a1 + 32) = v88;
        *(void *)&v112[0] = v93;
        id v110 = (char *)v92.i64[0];
        std::__split_buffer<CTRun *,TInlineBufferAllocator<CTRun *,3ul> &>::~__split_buffer((uint64_t)&v110);
      }
      else
      {
        *unint64_t v79 = v77;
        CFNumberRef v80 = v79 + 1;
      }
      *(void *)(a1 + 24) = v80;

      ++v75;
    }
    while (v75 != v76);
  }
  return a1;
}

void CTGlyphRun::CloneEntire(uint64_t a1@<X0>, void *a2@<X8>)
{
  TCFBase_NEW<CTGlyphRun,TRun const&>((const TRun *)(a1 + 72), &v3);
  *a2 = atomic_exchange((atomic_ullong *volatile)&v3, 0);
}

void TCFBase_NEW<CTGlyphRun,TRun const&>(const TRun *a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = TCFBase<TRun>::Allocate();
  if (v4)
  {
    uint64_t v5 = (void *)v4;
    uint64_t v6 = (TRun *)(v4 + 72);
    v5[2] = 0;
    v5[3] = 0;
    v5[4] = 0;
    void v5[5] = v6;
    v5[6] = v6;
    v5[7] = CTGlyphRun::CloneEntire;
    v5[8] = CTGlyphRun::CloneRange;
    TRun::TRun(v6, a1);
    id v7 = v5;
    *a2 = atomic_exchange((atomic_ullong *volatile)&v7, 0);
  }
  else
  {
    *a2 = 0;
  }
}

void *std::__hash_table<std::__hash_value_type<TRun const*,long>,std::__unordered_map_hasher<TRun const*,std::__hash_value_type<TRun const*,long>,std::hash<TRun const*>,std::equal_to<TRun const*>,true>,std::__unordered_map_equal<TRun const*,std::__hash_value_type<TRun const*,long>,std::equal_to<TRun const*>,std::hash<TRun const*>,true>,std::allocator<std::__hash_value_type<TRun const*,long>>>::__emplace_unique_key_args<TRun const*,std::piecewise_construct_t const&,std::tuple<TRun const* const&>,std::tuple<>>(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v5 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  unint64_t v6 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v5 >> 47) ^ v5);
  unint64_t v7 = 0x9DDFEA08EB382D69 * (v6 ^ (v6 >> 47));
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v10 = 0x9DDFEA08EB382D69 * (v6 ^ (v6 >> 47));
      if (v7 >= v8) {
        unint64_t v10 = v7 % v8;
      }
    }
    else
    {
      unint64_t v10 = (v8 - 1) & v7;
    }
    unint64_t v11 = *(void ***)(*(void *)a1 + 8 * v10);
    if (v11)
    {
      for (uint64_t i = *v11; i; uint64_t i = (void *)*i)
      {
        unint64_t v13 = i[1];
        if (v13 == v7)
        {
          if (i[2] == a2) {
            return i;
          }
        }
        else
        {
          if (v9.u32[0] > 1uLL)
          {
            if (v13 >= v8) {
              v13 %= v8;
            }
          }
          else
          {
            v13 &= v8 - 1;
          }
          if (v13 != v10) {
            break;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v10 = 0xAAAAAAAAAAAAAAAALL;
  }
  uint64_t i = operator new(0x20uLL);
  *uint64_t i = 0;
  i[1] = v7;
  i[2] = *a3;
  i[3] = 0;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (!v8 || (float)(v15 * (float)v8) < v14)
  {
    BOOL v16 = 1;
    if (v8 >= 3) {
      BOOL v16 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v8);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t v19 = v18;
    }
    else {
      size_t v19 = v17;
    }
    std::__hash_table<std::__hash_value_type<TRun const*,long>,std::__unordered_map_hasher<TRun const*,std::__hash_value_type<TRun const*,long>,std::hash<TRun const*>,std::equal_to<TRun const*>,true>,std::__unordered_map_equal<TRun const*,std::__hash_value_type<TRun const*,long>,std::equal_to<TRun const*>,std::hash<TRun const*>,true>,std::allocator<std::__hash_value_type<TRun const*,long>>>::__rehash<true>(a1, v19);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        unint64_t v10 = v7 % v8;
      }
      else {
        unint64_t v10 = v7;
      }
    }
    else
    {
      unint64_t v10 = (v8 - 1) & v7;
    }
  }
  uint64_t v20 = *(void *)a1;
  unint64_t v21 = *(void **)(*(void *)a1 + 8 * v10);
  if (v21)
  {
    *uint64_t i = *v21;
LABEL_38:
    *unint64_t v21 = i;
    goto LABEL_39;
  }
  *uint64_t i = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(v20 + 8 * v10) = a1 + 16;
  if (*i)
  {
    unint64_t v22 = *(void *)(*i + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v22 >= v8) {
        v22 %= v8;
      }
    }
    else
    {
      v22 &= v8 - 1;
    }
    unint64_t v21 = (void *)(*(void *)a1 + 8 * v22);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return i;
}

void CTDelegateRun::CloneRange(uint64_t a1@<X0>, uint64_t a2@<X1>, CFIndex a3@<X2>, int a4@<W3>, void *a5@<X8>)
{
  uint64_t v10 = TCFBase<TRun>::Allocate();
  if (v10)
  {
    unint64_t v11 = (void *)v10;
    uint64_t v12 = v10 + 72;
    v11[2] = 0;
    v11[3] = 0;
    v11[4] = 0;
    void v11[5] = v12;
    v11[6] = v12;
    v11[7] = CTDelegateRun::CloneEntire;
    v11[8] = CTDelegateRun::CloneRange;
    TDelegateRun::TDelegateRun(v12, a1 + 72, a2, a3, a4);
    id v14 = v11;
    id v13 = (id)atomic_exchange((atomic_ullong *volatile)&v14, 0);
  }
  else
  {
    id v13 = 0;
  }
  *a5 = atomic_exchange((atomic_ullong *volatile)&v13, 0);
}

uint64_t TDelegateRun::TDelegateRun(uint64_t a1, uint64_t a2, uint64_t a3, CFIndex a4, int a5)
{
  *(void *)TRun::TRun(a1, a2, a3, a4, a5) = &unk_1ED05D7A0;
  *(void *)(a1 + 320) = (id)atomic_load_explicit((atomic_ullong *volatile)(a2 + 320), memory_order_acquire);
  long long v7 = *(_OWORD *)(a2 + 328);
  long long v8 = *(_OWORD *)(a2 + 344);
  *(void *)(a1 + 360) = *(void *)(a2 + 360);
  *(_OWORD *)(a1 + 328) = v7;
  *(_OWORD *)(a1 + 344) = v8;
  *(void *)(a1 + 368) = *(void *)(a2 + 368);
  *(void *)(a1 + 376) = *(void *)(a2 + 376);
  *(_OWORD *)(a1 + 384) = *(_OWORD *)(a2 + 384);
  return a1;
}

void std::default_delete<TLine::TruncationInfo>::operator()[abi:nn180100](uint64_t a1, uint64_t a2)
{
  if (a2)
  {

    JUMPOUT(0x1853275C0);
  }
}

char **std::vector<long,TInlineBufferAllocator<long,30ul>>::reserve(char **result, unint64_t a2)
{
  if (a2 > (result[2] - *result) >> 3)
  {
    if (a2 >> 61) {
      abort();
    }
    id v3 = result;
    uint64_t v4 = result[1] - *result;
    v12[4] = result + 3;
    unint64_t v5 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)(result + 3), a2);
    long long v7 = *v3;
    unint64_t v6 = v3[1];
    long long v8 = &v5[v4 & 0xFFFFFFFFFFFFFFF8];
    if (v6 != *v3)
    {
      uint8x8_t v9 = v3[1];
      long long v8 = &v5[v4 & 0xFFFFFFFFFFFFFFF8];
      do
      {
        uint64_t v10 = *((void *)v9 - 1);
        v9 -= 8;
        *((void *)v8 - 1) = v10;
        v8 -= 8;
      }
      while (v9 != v7);
    }
    *id v3 = v8;
    v3[1] = &v5[v4 & 0xFFFFFFFFFFFFFFF8];
    unint64_t v11 = v3[2];
    v3[2] = &v5[8 * a2];
    v12[2] = v6;
    id v12[3] = v11;
    v12[0] = v7;
    v12[1] = v7;
    return (char **)std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)v12);
  }
  return result;
}

void TLine::LinkRunsWithOrder(void *a1, uint64_t *a2)
{
  v53[2] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = a1[2];
  uint64_t v3 = a1[3];
  uint64_t v4 = (v3 - v2) >> 3;
  if (v4 == (a2[1] - *a2) >> 3)
  {
    *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v52[14] = v7;
    v52[13] = v7;
    v52[12] = v7;
    v52[11] = v7;
    v52[10] = v7;
    v52[9] = v7;
    v52[8] = v7;
    v52[7] = v7;
    v52[6] = v7;
    v52[5] = v7;
    v52[4] = v7;
    v52[3] = v7;
    v52[2] = v7;
    v52[1] = v7;
    v52[0] = v7;
    int64x2_t v51 = 0;
    int64x2_t v50 = 0uLL;
    v53[0] = v52;
    uint64_t v44 = (v3 - v2) >> 3;
    uint64_t v45 = v3 - v2;
    if (v3 != v2)
    {
      if (v3 - v2 < 0) {
LABEL_49:
      }
        abort();
      uint64_t v49 = v52;
      long long v8 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v52, (v3 - v2) >> 3);
      uint64_t v9 = v50.i64[1];
      uint64_t v10 = v50.i64[0];
      if (v50.i64[1] == v50.i64[0])
      {
        int64x2_t v13 = vdupq_n_s64(v50.u64[1]);
        unint64_t v11 = v8;
      }
      else
      {
        unint64_t v11 = v8;
        do
        {
          uint64_t v12 = *(void *)(v9 - 8);
          v9 -= 8;
          *((void *)v11 - 1) = v12;
          v11 -= 8;
        }
        while (v9 != v10);
        int64x2_t v13 = v50;
      }
      v50.i64[0] = (uint64_t)v11;
      v50.i64[1] = (uint64_t)v8;
      int64x2_t v47 = v13;
      id v14 = v51;
      int64x2_t v51 = &v8[8 * v4];
      unint64_t v48 = v14;
      uint64_t v46 = v13.i64[0];
      std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v46);
      uint64_t v2 = a1[2];
      uint64_t v3 = a1[3];
    }
    if (v2 != v3)
    {
      float v15 = (char *)v50.i64[1];
      do
      {
        uint64_t v16 = *(void *)(*(void *)v2 + 48);
        if (v15 >= v51)
        {
          uint64_t v17 = (uint64_t)&v15[-v50.i64[0]] >> 3;
          if ((unint64_t)(v17 + 1) >> 61) {
            goto LABEL_49;
          }
          unint64_t v18 = (uint64_t)&v51[-v50.i64[0]] >> 2;
          if (v18 <= v17 + 1) {
            unint64_t v18 = v17 + 1;
          }
          if ((unint64_t)&v51[-v50.i64[0]] >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v19 = v18;
          }
          uint64_t v49 = v52;
          if (v19) {
            uint64_t v20 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v52, v19);
          }
          else {
            uint64_t v20 = 0;
          }
          unint64_t v21 = &v20[8 * v17];
          unint64_t v22 = &v20[8 * v19];
          unint64_t v48 = v22;
          *(void *)unint64_t v21 = v16;
          float v15 = v21 + 8;
          v47.i64[1] = (uint64_t)(v21 + 8);
          uint64_t v23 = v50.i64[1];
          uint64_t v24 = v50.i64[0];
          if (v50.i64[1] == v50.i64[0])
          {
            int64x2_t v26 = vdupq_n_s64(v50.u64[1]);
          }
          else
          {
            do
            {
              uint64_t v25 = *(void *)(v23 - 8);
              v23 -= 8;
              *((void *)v21 - 1) = v25;
              v21 -= 8;
            }
            while (v23 != v24);
            int64x2_t v26 = v50;
            float v15 = (char *)v47.i64[1];
            unint64_t v22 = v48;
          }
          v50.i64[0] = (uint64_t)v21;
          v50.i64[1] = (uint64_t)v15;
          int64x2_t v47 = v26;
          unint64_t v27 = v51;
          int64x2_t v51 = v22;
          unint64_t v48 = v27;
          uint64_t v46 = v26.i64[0];
          std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v46);
        }
        else
        {
          *(void *)float v15 = v16;
          v15 += 8;
        }
        v50.i64[1] = (uint64_t)v15;
        v2 += 8;
      }
      while (v2 != v3);
    }
    if (v45 >= 1)
    {
      uint64_t v28 = 0;
      uint64_t v29 = v44;
      if (v44 <= 1) {
        uint64_t v29 = 1;
      }
      uint64_t v30 = *a2;
      do
      {
        uint64_t v31 = *(void *)(v30 + 8 * v28);
        uint64_t v32 = v28;
        while (v28 != v31)
        {
          uint64_t v33 = v32;
          uint64_t v32 = v31;
          uint64_t v34 = v50.i64[0];
          uint64_t v35 = *(void *)(v50.i64[0] + 8 * v33);
          *(void *)(v50.i64[0] + 8 * v33) = *(void *)(v50.i64[0] + 8 * v32);
          *(void *)(v34 + 8 * v32) = v35;
          uint64_t v30 = *a2;
          *(void *)(*a2 + 8 * v33) = v33;
          uint64_t v31 = *(void *)(v30 + 8 * v32);
        }
        *(void *)(v30 + 8 * v32) = v32;
        ++v28;
      }
      while (v28 != v29);
    }
    int64x2_t v36 = v50;
    if (v50.i64[0] != v50.i64[1])
    {
      unint64_t v37 = a1 + 12;
      uint64_t v38 = a1[11];
      uint64_t v39 = (uint64_t *)v50.i64[0];
      while (1)
      {
        uint64_t v40 = *v39;
        if (v38) {
          break;
        }
        uint64_t v41 = 0;
        uint64_t v42 = 0;
        a1[11] = v40;
        uint64_t v38 = v40;
        uint64_t v43 = a1 + 12;
        if (v40) {
          goto LABEL_42;
        }
LABEL_43:
        *uint64_t v43 = 0;
        ++v39;
        uint64_t v38 = v42;
        if (v39 == (uint64_t *)v36.i64[1]) {
          goto LABEL_44;
        }
      }
      uint64_t v41 = *v37;
      *(void *)(*v37 + 24) = v40;
LABEL_42:
      *(void *)(v40 + 32) = v41;
      void *v37 = v40;
      uint64_t v43 = (void *)(v40 + 24);
      uint64_t v42 = v38;
      goto LABEL_43;
    }
LABEL_44:
    if (v36.i64[0])
    {
      v50.i64[1] = v36.i64[0];
      if ((unint64_t)v52 > v36.i64[0] || (unint64_t)v53 <= v36.i64[0]) {
        operator delete((void *)v36.i64[0]);
      }
    }
  }
}

const __CFNumber *TTypesetter::UnpackOptions(TTypesetter *this, CFDictionaryRef theDict)
{
  CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(theDict, @"CTTypesetterOptionVerticalLayout");
  if (Value && CFBooleanGetValue(Value)) {
    *((_WORD *)this + 77) |= 0x100u;
  }
  CFBooleanRef v5 = (const __CFBoolean *)CFDictionaryGetValue(theDict, @"CTTypesetterOptionAllowUnboundedLayout");
  if (v5 && CFBooleanGetValue(v5)) {
    *((unsigned char *)this + 256) = 1;
  }
  unint64_t v6 = (uint64_t (**)(const void *, void, uint64_t, unsigned __int8 *))CFDictionaryGetValue(theDict, @"CTTypesetterOptionBidiLevelsProvider");
  if (v6)
  {
    long long v7 = v6;
    uint64_t v8 = *(void *)(*((void *)this + 27) + 16);
    uint64_t v9 = operator new(0x38uLL);
    v9[1] = 0;
    v9[2] = 0;
    *uint64_t v9 = &unk_1ED062320;
    id v9[3] = &unk_1ED05F2C8;
    void v9[4] = 0;
    *((_WORD *)v9 + 24) = 0;
    unsigned __int8 v14 = 0;
    void v9[5] = v7[2](v7, 0, v8, &v14);
    *((_WORD *)v9 + 24) = v14 | 0x100;
    uint64_t v10 = (std::__shared_weak_count *)*((void *)this + 31);
    *((void *)this + 30) = v9 + 3;
    *((void *)this + 31) = v9;
    if (v10) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v10);
    }
  }
  CFBooleanRef v11 = (const __CFBoolean *)CFDictionaryGetValue(theDict, @"CTTypesetterOptionDisableBidiProcessing");
  if (v11 && CFBooleanGetValue(v11)) {
    *((_DWORD *)this + 65) |= 1u;
  }
  CFNumberRef result = (const __CFNumber *)CFDictionaryGetValue(theDict, @"CTTypesetterOptionForcedEmbeddingLevel");
  if (result)
  {
    CFNumberRef result = (const __CFNumber *)CFNumberGetValue(result, kCFNumberCharType, (char *)this + 264);
    if (*((unsigned char *)this + 264)) {
      int v13 = 2;
    }
    else {
      int v13 = 1;
    }
    *((_DWORD *)this + 65) |= v13;
  }
  return result;
}

uint64_t CTFontHasExuberatedLineHeight(uint64_t a1)
{
  if (!a1) {
    return CurrentLocaleIsExuberated();
  }
  uint64_t result = *(void *)(*(void *)(a1 + 40) + 400);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 784))();
  }
  return result;
}

uint64_t TShapingEngine::ShapeGlyphs(TShapingEngine *this, TRunGlue *a2, const TCharStream *a3)
{
  uint64_t v25 = a2;
  v28[91] = *MEMORY[0x1E4F143B8];
  uint64_t result = TRunGlue::length(this);
  if (result)
  {
    CFBooleanRef v5 = 0;
    unsigned __int8 v26 = 0;
    v24[1] = &v28[8];
    while (1)
    {
      uint64_t v6 = *((void *)this + 77);
      int ShapingType = TBaseFont::GetShapingType(*(TBaseFont **)(v6 + 400));
      if (ShapingType) {
        break;
      }
      uint64_t v13 = 1;
LABEL_35:
      if (!TRunGlue::NextRunRange(this, v13))
      {
        *((void *)this + 25) = 0;
        return v26;
      }
    }
    int v8 = ShapingType;
    if (ShapingType != 2
      && (ShapingType != 3 || (FontRequiresOpenTypeShaping((atomic_ullong *)v6) & 1) == 0))
    {
      memset(v28, 170, 0x2A0uLL);
      TAATMorphTableMorx::TAATMorphTableMorx((TAATMorphTableMorx *)v28, this);
      if (v28[5])
      {
        TAATMorphTable::ShapeGlyphs(v28, &v26, 0);
        uint64_t v13 = *((void *)this + 2);
        if (v13 >= 1)
        {
          uint64_t v18 = *((void *)this + 1);
          uint64_t v19 = v13 + v18;
          uint64_t v20 = *(void *)(*(void *)this + 16);
          do
          {
            uint64_t v21 = *(void *)(*(void *)(v20 + 8 * v18) + 48);
            unsigned int v22 = *(_DWORD *)(v21 + 260) & 0xFFFFFFF9;
            *(_DWORD *)(v21 + 260) = v22;
            if (v8 == 1) {
              int v23 = 4;
            }
            else {
              int v23 = 2;
            }
            *(_DWORD *)(v21 + 260) = v23 | v22;
            ++v18;
          }
          while (v18 < v19);
        }
      }
      else
      {
        uint64_t v13 = 1;
      }
      unint64_t v27 = (void **)&v28[32];
      v28[0] = (uint64_t)&unk_1ED05E7B0;
      v28[8] = (uint64_t)&unk_1ED05E770;
      std::vector<unsigned char const*,TInlineBufferAllocator<unsigned char const*,48ul>>::__destroy_vector::operator()[abi:nn180100](&v27);
      goto LABEL_34;
    }
    memset(v28, 170, 0x2D8uLL);
    TOpenTypeMorph::TOpenTypeMorph((TOpenTypeMorph *)v28, this, v25);
    if (v28[68])
    {
      if (v5)
      {
LABEL_11:
        unint64_t v11 = *((void *)this + 78);
        if (v11 <= 0x10000) {
          size_t v12 = (v11 + 7) >> 3;
        }
        else {
          size_t v12 = 0x2000;
        }
        bzero(v5, v12);
        TRunGlue::DetermineCoverage((uint64_t)this, (unsigned __int8 *)v5);
        TOpenTypeMorph::ShapeGlyphs((uint64_t)v28, (uint64_t)&v26);
        uint64_t v13 = *((void *)this + 2);
        if (v13 >= 1)
        {
          uint64_t v14 = *((void *)this + 1);
          uint64_t v15 = v13 + v14;
          uint64_t v16 = *(void *)(*(void *)this + 16);
          do
          {
            uint64_t v17 = *(void *)(*(void *)(v16 + 8 * v14) + 48);
            *(_DWORD *)(v17 + 260) = *(_DWORD *)(v17 + 260) & 0xFFFFFFF9 | 2;
            ++v14;
          }
          while (v14 < v15);
        }
        goto LABEL_33;
      }
      BOOL HasAvailable = StackHasAvailable(0x8000uLL);
      if (HasAvailable)
      {
        MEMORY[0x1F4188790](HasAvailable, v10);
        CFBooleanRef v5 = &v24[-1024];
        memset(&v24[-1024], 170, 0x2000uLL);
        goto LABEL_11;
      }
      CFBooleanRef v5 = 0;
    }
    uint64_t v13 = 1;
LABEL_33:
    std::vector<TGlyphAuxDataListEntry,TInlineBufferAllocator<TGlyphAuxDataListEntry,30ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v28[4]);
LABEL_34:
    TRunGlue::UpdateAdvancesIfNeeded(this);
    goto LABEL_35;
  }
  return result;
}

void TRunGlue::UpdateAdvancesIfNeeded(TRunGlue *this)
{
  *((_WORD *)this + 316) = 256;
  if (*((unsigned char *)this + 592))
  {
    *((unsigned char *)this + 592) = 0;
    if (*((void *)this + 19))
    {
      if (*((uint64_t *)this + 2) >= 1)
      {
        uint64_t v2 = 0;
        do
        {
          uint64_t v3 = *(void *)(*(void *)(*(void *)(*(void *)this + 16) + 8 * (v2 + *((void *)this + 1))) + 48);
          uint64_t v4 = v3 + 192;
          uint64_t v5 = *(void *)(atomic_load_explicit((atomic_ullong *volatile)(v3 + 56), memory_order_acquire) + 40);
          uint64_t RenderingStyle = TAttributes::GetRenderingStyle((TAttributes *)(v3 + 40));
          TStorageRange::UpdateAdvances(v4, v5, RenderingStyle);
          ++v2;
        }
        while (v2 < *((void *)this + 2));
      }
    }
    else
    {
      uint64_t v7 = *((void *)this + 77);
      uint64_t v8 = *((void *)this + 22);
      uint64_t v9 = (double *)*((void *)this + 23);
      uint64_t v10 = TRunGlue::length(this);
      TFont::GetUnsummedAdvancesForGlyphs(v7, v8, v9, 2, v10, 0, 0);
    }
  }
}

void std::vector<TGlyphAuxDataListEntry,TInlineBufferAllocator<TGlyphAuxDataListEntry,30ul>>::__destroy_vector::operator()[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  if (v2)
  {
    *(void *)(a1 + 8) = v2;
    uint64_t v3 = (void *)(a1 + 504);
    if (a1 + 24 <= (unint64_t)v2)
    {
      BOOL v4 = v3 >= v2;
      BOOL v5 = v3 == v2;
    }
    else
    {
      BOOL v4 = 0;
      BOOL v5 = 0;
    }
    if (!v5 && v4)
    {
      if (*(void *)(a1 + 16) == *(void *)(a1 + 504)) {
        *uint64_t v3 = v2;
      }
    }
    else
    {
      operator delete(v2);
    }
  }
}

double CTFontTransformGlyphsWithLanguage(const __CTFont *a1, unsigned __int16 *a2, CGSize *a3, uint64_t a4, int a5, __CFString *a6, uint64_t a7)
{
  v28[82] = *MEMORY[0x1E4F143B8];
  if (a1 && a2 && a3 && a4 > 0)
  {
    if (a5) {
      char v13 = a5;
    }
    else {
      char v13 = 3;
    }
    memcpy(v28, &unk_184B89DC0, 0x290uLL);
    TRunGlue::TRunGlue((TRunGlue *)v28, a1, a2, a3, a4, 0, 0, 0);
    uint64_t v14 = (atomic_ullong *)v28[77];
    int ShapingType = TBaseFont::GetShapingType(*(TBaseFont **)(v28[77] + 400));
    BOOL HasAvailable = StackHasAvailable(0x8000uLL);
    if (!HasAvailable)
    {
      double v19 = *MEMORY[0x1E4F1DB30];
      goto LABEL_33;
    }
    MEMORY[0x1F4188790](HasAvailable, v17);
    memset(v23, 170, sizeof(v23));
    if (ShapingType >= 2)
    {
      if (v28[78] <= 0x10000uLL) {
        size_t v18 = (unint64_t)(v28[78] + 7) >> 3;
      }
      else {
        size_t v18 = 0x2000;
      }
      bzero(v23, v18);
      TRunGlue::DetermineCoverage((uint64_t)v28, v23);
    }
    uint64_t v24 = (void **)0xAAAAAAAAAAAAAA00;
    int v25 = -1431655936;
    if ((v13 & 1) == 0)
    {
      if ((v13 & 2) == 0) {
        goto LABEL_29;
      }
LABEL_28:
      if (TKerningEngine::PositionGlyphs((TRunGlue *)v28, ShapingType, (const TFont *)v24, v25, a6, 0, 1))
      {
LABEL_29:
        double v19 = *(double *)&v28[68];
LABEL_33:
        std::__function::__value_func<BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::~__value_func[abi:nn180100](&v28[70]);
        uint64_t v24 = (void **)&v28[46];
        std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100](&v24);
        uint64_t v24 = (void **)&v28[26];
        std::vector<unsigned char,TInlineBufferAllocator<unsigned char,128ul>>::__destroy_vector::operator()[abi:nn180100](&v24);
        uint64_t v24 = (void **)&v28[7];
        std::vector<std::pair<UScriptCode,long>,TInlineBufferAllocator<std::pair<UScriptCode,long>,1ul>>::__destroy_vector::operator()[abi:nn180100](&v24);
        return v19;
      }
LABEL_32:
      double v19 = INFINITY;
      goto LABEL_33;
    }
    if (v14[40])
    {
      if (TFont::NeedsShapingForGlyphs(v14, a2, a4, a6))
      {
        v27[0] = &unk_1ED0600C8;
        v27[1] = a7;
        uint64_t v27[3] = v27;
        std::function<BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::operator=(&v28[70], (uint64_t)v27);
        std::__function::__value_func<BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::~__value_func[abi:nn180100](v27);
        BOOL v20 = TShapingEngine::ShapeGlyphs((uint64_t)v28, ShapingType, a6, (uint64_t)&v24, 0);
LABEL_30:
        if (!a7 && !v20) {
          goto LABEL_32;
        }
        goto LABEL_26;
      }
    }
    else
    {
      v26[0] = &unk_1ED0600C8;
      v26[1] = a7;
      v26[3] = v26;
      std::function<BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::operator=(&v28[70], (uint64_t)v26);
      std::__function::__value_func<BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::~__value_func[abi:nn180100](v26);
      BOOL v20 = TShapingEngine::ShapeGlyphs((uint64_t)v28, ShapingType, a6, (uint64_t)&v24, 0);
      if (!v20) {
        goto LABEL_30;
      }
      if (qword_1EB2CDFA8 != -1) {
        dispatch_once_f(&qword_1EB2CDFA8, 0, (dispatch_function_t)GetShapingGlyphsQueue(void)::$_0::__invoke);
      }
      uint64_t v21 = qword_1EB2CDFA0;
      CFRetain(a1);
      dispatch_async_f(v21, a1, (dispatch_function_t)InitShapingGlyphsOnQueue(__CTFont const*,NSObject  {objcproto17OS_dispatch_queue}*)::$_0::__invoke);
    }
    LOBYTE(v20) = 1;
LABEL_26:
    if ((v13 & 2) == 0 || !v20) {
      goto LABEL_29;
    }
    goto LABEL_28;
  }
  return *MEMORY[0x1E4F1DB30];
}

uint64_t TBaseFont::GetShapingType(TBaseFont *this)
{
  if ((*((_DWORD *)this + 46) & 0x30000) != 0) {
    return HIWORD(*((_DWORD *)this + 45)) & 3;
  }
  if (TBaseFont::GetCommonTable(this, 1634561906, 0))
  {
    if ((*((_DWORD *)this + 46) & 0x30000) != 0) {
      return HIWORD(*((_DWORD *)this + 45)) & 3;
    }
    uint64_t result = 1;
  }
  else
  {
    uint64_t result = 2 * (TBaseFont::GetCommonTable(this, 1196643650, 0) != 0);
  }
  atomic_fetch_or_explicit((atomic_uint *volatile)this + 45, result << 16, memory_order_relaxed);
  atomic_fetch_or_explicit((atomic_uint *volatile)this + 46, 0x30000u, memory_order_relaxed);
  return result;
}

void *std::__function::__value_func<BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::vector<unsigned char,TInlineBufferAllocator<unsigned char,128ul>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    v1[1] = v2;
    uint64_t v3 = v1 + 19;
    if (v1 + 3 <= v2)
    {
      BOOL v4 = v3 >= v2;
      BOOL v5 = v3 == v2;
    }
    else
    {
      BOOL v4 = 0;
      BOOL v5 = 0;
    }
    if (!v5 && v4)
    {
      if (v1[2] == v1[19]) {
        *uint64_t v3 = v2;
      }
    }
    else
    {
      operator delete(v2);
    }
  }
}

uint64_t TRunGlue::DetermineCoverage(uint64_t this, unsigned __int8 *a2)
{
  uint64_t v3 = (void *)this;
  *(void *)(this + 200) = a2;
  if (*(void *)(this + 152))
  {
    uint64_t v4 = *(void *)(this + 16);
    if (v4 >= 1)
    {
      for (uint64_t i = 0; i < v4; ++i)
      {
        uint64_t v6 = *(void **)(*(void *)(*(void *)(*(void *)this + 16) + 8 * (*(void *)(this + 8) + i)) + 40);
        uint64_t v7 = v6[26];
        if (v7 >= 1)
        {
          uint64_t v8 = (unsigned __int16 *)(*(void *)(v6[27] + 16) + 2 * v6[25]);
          do
          {
            unsigned int v10 = *v8++;
            unint64_t v9 = v10;
            if (*(void *)(this + 624) > (uint64_t)v10) {
              a2[v9 >> 3] |= 1 << (v9 & 7);
            }
            --v7;
          }
          while (v7);
          uint64_t v4 = *(void *)(this + 16);
        }
      }
    }
  }
  else
  {
    this = TRunGlue::length((TRunGlue *)this);
    if (this >= 1)
    {
      for (uint64_t j = 0; j != this; ++j)
      {
        unint64_t v12 = *(unsigned __int16 *)(v3[22] + 2 * (j + v3[20]));
        if (v3[78] > (int64_t)v12) {
          a2[v12 >> 3] |= 1 << (v12 & 7);
        }
      }
    }
  }
  return this;
}

uint64_t TOpenTypeMorph::ShapeGlyphs(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (TRunGlue **)MEMORY[0x1F4188790](a1, a2);
  uint64_t v4 = v3;
  BOOL v5 = v2;
  uint64_t v146 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *v2;
  v142[0] = &unk_1ED060E48;
  v142[3] = v142;
  TRunGlue::GlyphRangeByTrimming(v6, (uint64_t)v142);
  uint64_t v8 = v7;
  std::__function::__value_func<BOOL ()(TRunGlue::TGlyph)>::~__value_func[abi:nn180100](v142);
  if (v8 < 1) {
    return 1;
  }
  unint64_t v9 = (unint64_t)&v143;
  uint64_t v101 = *((void *)*v5 + 13);
  uint64_t v102 = v4;
  *((void *)*v5 + 13) = v5 + 4;
  memset(v140, 170, sizeof(v140));
  double v138 = 0;
  uint64_t v139 = 0;
  uint64_t v137 = 0;
  BOOL v141 = v140;
  long long v113 = 0u;
  long long v114 = 0u;
  memset(v112, 0, sizeof(v112));
  unint64_t v109 = 0;
  v110[0] = 0xAAAAAAAAAAAAAAAALL;
  __p = 0;
  unint64_t v108 = 0;
  v110[1] = v110;
  int64x2_t v111 = 0;
  BOOL v106 = 0;
  *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v124 = v10;
  long long v123 = v10;
  long long v122 = v10;
  long long v121 = v10;
  long long v120 = v10;
  long long v119 = v10;
  long long v118 = v10;
  uint64_t v115 = 0;
  *(void *)&long long v125 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v125 + 1) = &v118;
  unint64_t v11 = (const OTL::GSUB *)(v5 + 80);
  LODWORD(v134) = 1920365166;
  unint64_t v116 = 0;
  uint64_t v117 = 0;
  OTL::FeatureBuffer::FeatureBuffer<unsigned int const*>((char **)__b, &v134, (_DWORD *)&v134 + 1);
  BOOL SingleSubstLookups = OTL::GSUB::GetSingleSubstLookups(v5 + 80, (uint64_t)__b, (uint64_t)&v115);
  uint64_t v128 = (void **)__b;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](&v128);
  unint64_t v105 = v5;
  if (SingleSubstLookups)
  {
    memset(&__b[24], 170, 0xC30uLL);
    memset(__b, 0, 24);
    BOOL v145 = &__b[24];
    uint64_t v13 = TRunGlue::length(*v5);
    uint64_t v14 = v115;
    uint64_t v15 = v116;
    if (v115 != v116)
    {
      uint64_t v16 = v13;
      do
      {
        unsigned int v17 = *(_DWORD *)v14;
        uint64_t v14 = (void **)((char *)v14 + 4);
        unint64_t v9 = v9 & 0xFFFFFFFF00000000 | v17;
        OTL::GlyphLookups::SetLookupInRange<false>((uint64_t *)__b, v9, 0, v16);
      }
      while (v14 != v15);
    }
    BOOL v5 = v105;
    OTL::GSUB::ApplyLookups(v11, *v105, *((_DWORD *)v105 + 4), (unsigned __int16 **)__b, v4, 0, 0);
    uint64_t v128 = (void **)__b;
    std::vector<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,TInlineBufferAllocator<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,30ul>>::__destroy_vector::operator()[abi:nn180100](&v128);
    unint64_t v9 = (unint64_t)&v143;
  }
  *(void *)__b = &v115;
  std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)__b);
  long long v134 = xmmword_184BA1E60;
  long long v143 = xmmword_184BA1E70;
  *(void *)&long long v18 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v124 = v18;
  long long v123 = v18;
  long long v122 = v18;
  long long v121 = v18;
  long long v120 = v18;
  long long v119 = v18;
  long long v118 = v18;
  uint64_t v115 = 0;
  unint64_t v116 = 0;
  uint64_t v117 = 0;
  if (*((int *)v5 + 4) <= 0) {
    double v19 = &v143;
  }
  else {
    double v19 = &v134;
  }
  *(void *)&long long v125 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v125 + 1) = &v118;
  OTL::FeatureBuffer::FeatureBuffer<unsigned int const*>((char **)__b, v19, (_DWORD *)v19 + 4);
  unint64_t Lookups = OTL::GCommon::GetLookups((uint64_t)v11, (uint64_t)__b, (uint64_t)&v115, 0);
  uint64_t v128 = (void **)__b;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](&v128);
  if (Lookups)
  {
    uint64_t v21 = v115;
    unsigned int v22 = v116;
    while (v21 != v22)
    {
      unsigned int v23 = *(_DWORD *)v21;
      uint64_t v21 = (void **)((char *)v21 + 4);
      unint64_t Lookups = Lookups & 0xFFFFFFFF00000000 | v23;
      OTL::GlyphLookups::SetLookupInRange<false>((uint64_t *)&v137, Lookups, 0, -1);
    }
  }
  uint64_t v24 = v105;
  int v25 = *((_DWORD *)v105 + 6);
  if (!*((unsigned char *)v105 + 21))
  {
    unsigned __int8 v26 = v4;
    unint64_t v27 = (unint64_t)&v143;
    if (v25 == 2)
    {
LABEL_22:
      *(void *)&__b[24] = 0xAAAAAAAAAAAAAA00;
      uint64_t v30 = *v105;
      *(void *)&__b[8] = v105[69];
      *(void *)&__b[16] = v30;
      *(void *)__b = &unk_1ED05E898;
      *v26 |= ArabicShapingEngine::ApplyScriptShaping((ArabicShapingEngine *)__b, v11, (OTL::GlyphLookups *)&v137, v112, &v106);
      uint64_t v31 = TOpenTypeMorph::ApplyShapingEngine<TInlineVector<unsigned int,1ul>>(OTL::GlyphLookups &,unsigned int *,BOOL (**),TInlineVector<unsigned int,1ul> &,SyncState &,BOOL *)::{lambda#1}::__invoke;
LABEL_23:
      int64x2_t v111 = (BOOL (*))v31;
    }
    else if (v25 == 34)
    {
LABEL_21:
      *(void *)&__b[24] = 0xAAAAAAAAAAAAAA00;
      uint64_t v29 = *v105;
      *(void *)&__b[8] = v105[69];
      *(void *)&__b[16] = v29;
      *(void *)__b = &unk_1ED05E8C8;
      *v26 |= JoiningScriptShapingEngine::ApplyScriptShaping((JoiningScriptShapingEngine *)__b, v11, (OTL::GlyphLookups *)&v137, &v106);
    }
    goto LABEL_107;
  }
  unsigned __int8 v26 = v4;
  unint64_t v27 = (unint64_t)&v143;
  switch(v25)
  {
    case 2:
      goto LABEL_22;
    case 3:
    case 6:
    case 8:
    case 12:
    case 14:
    case 19:
    case 25:
    case 29:
    case 32:
      goto LABEL_107;
    case 4:
      if (((*((_DWORD *)v105 + 179) << 24) - 956301313) <= 0xF9FFFFFE && *((int *)v105 + 4) >= 1)
      {
        memset(__b, 170, 0x380uLL);
        BengaliShapingEngine::BengaliShapingEngine((BengaliShapingEngine *)__b, v105[69], *v105, v11);
      }
      goto LABEL_64;
    case 10:
      if (((*((_DWORD *)v105 + 179) << 24) - 956301313) <= 0xF9FFFFFE && *((int *)v105 + 4) >= 1)
      {
        memset(__b, 170, 0x380uLL);
        DevanagariShapingEngine::DevanagariShapingEngine((DevanagariShapingEngine *)__b, v105[69], *v105, v11);
      }
      goto LABEL_64;
    case 15:
      if (((*((_DWORD *)v105 + 179) << 24) - 956301313) <= 0xF9FFFFFE && *((int *)v105 + 4) >= 1)
      {
        memset(__b, 170, 0x380uLL);
        GujaratiShapingEngine::GujaratiShapingEngine((GujaratiShapingEngine *)__b, v105[69], *v105, v11);
      }
      goto LABEL_64;
    case 16:
      if (((*((_DWORD *)v105 + 179) << 24) - 956301313) <= 0xF9FFFFFE && *((int *)v105 + 4) >= 1)
      {
        memset(__b, 170, 0x380uLL);
        GurmukhiShapingEngine::GurmukhiShapingEngine((GurmukhiShapingEngine *)__b, v105[69], *v105, v11);
      }
      goto LABEL_64;
    case 17:
    case 54:
      goto LABEL_80;
    case 18:
      if (v105[69])
      {
        uint64_t v32 = *v105;
        *(void *)__b = v105[69];
        *(void *)&__b[8] = v32;
        if ((*((_DWORD *)v32 + 6) & 0x80000000) != 0) {
          char v33 = 0;
        }
        else {
          char v33 = HangulShapingEngine::SetFeatures((HangulShapingEngine *)__b, v11, (OTL::GlyphLookups *)&v137);
        }
        *v4 |= v33;
      }
LABEL_80:
      int v55 = v108;
      if (v108 >= v109)
      {
        uint64_t v57 = (char *)__p;
        uint64_t v58 = (v108 - (unsigned char *)__p) >> 2;
        unint64_t v59 = v58 + 1;
        if (!((unint64_t)(v58 + 1) >> 62))
        {
          uint64_t v60 = v109 - (unsigned char *)__p;
          if ((v109 - (unsigned char *)__p) >> 1 > v59) {
            unint64_t v59 = v60 >> 1;
          }
          if ((unint64_t)v60 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v61 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v61 = v59;
          }
          *(void *)&__b[32] = v110;
          if (v61)
          {
            unint64_t v62 = (char *)TInlineBufferAllocator<unsigned int,1ul>::allocate((uint64_t)v110, v61);
            uint64_t v57 = (char *)__p;
            int v55 = v108;
          }
          else
          {
            unint64_t v62 = 0;
          }
          unint64_t v63 = &v62[4 * v58];
          *(_DWORD *)unint64_t v63 = 1667329140;
          if (v55 == v57)
          {
            long long v65 = &v62[4 * v58];
          }
          else
          {
            uint64_t v64 = v55;
            long long v65 = &v62[4 * v58];
            do
            {
              int v66 = *((_DWORD *)v64 - 1);
              v64 -= 4;
              *((_DWORD *)v65 - 1) = v66;
              v65 -= 4;
            }
            while (v64 != v57);
          }
          int v56 = v63 + 4;
          __p = v65;
          unint64_t v108 = v63 + 4;
          uint64_t v67 = v109;
          unint64_t v109 = &v62[4 * v61];
          *(void *)&__b[16] = v55;
          *(void *)&__b[24] = v67;
          *(void *)__b = v57;
          *(void *)&__b[8] = v57;
          std::__split_buffer<unsigned int,TInlineBufferAllocator<unsigned int,1ul> &>::~__split_buffer((uint64_t)__b);
          uint64_t v24 = v105;
          goto LABEL_97;
        }
LABEL_146:
        abort();
      }
      *(_DWORD *)unint64_t v108 = 1667329140;
      int v56 = v55 + 4;
LABEL_97:
      unint64_t v108 = v56;
LABEL_107:
      *(void *)__b = &v115;
      std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)__b);
      if (v24[86])
      {
        *(void *)&long long v134 = v24;
        *((void *)&v134 + 1) = v112;
        p_p = &__p;
        int64_t v136 = &v111;
        uint64_t v104 = *((void *)*v24 + 2);
        uint64_t v100 = v11;
        if (v104 > 1)
        {
          uint64_t v103 = *((void *)*v24 + 1);
          unint64_t v132 = 0xAAAAAAAAAAAAAAAALL;
          *(void *)&long long v81 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v81 + 1) = 0xAAAAAAAAAAAAAAAALL;
          v131[6] = v81;
          v131[5] = v81;
          v131[4] = v81;
          v131[3] = v81;
          v131[2] = v81;
          v131[1] = v81;
          v131[0] = v81;
          uint64_t v129 = 0;
          uint64_t v130 = 0;
          uint64_t v128 = 0;
          uint64_t v133 = v131;
          long long v126 = v81;
          long long v125 = v81;
          long long v124 = v81;
          long long v123 = v81;
          long long v122 = v81;
          long long v121 = v81;
          long long v120 = v81;
          long long v119 = v81;
          long long v118 = v81;
          uint64_t v115 = 0;
          unint64_t v116 = 0;
          uint64_t v117 = 0;
          uint64_t v127 = &v118;
          if (*((_DWORD *)v24 + 6) != 2 && OTL::GCommon::GetFeatures(v11, (OTL::FeatureList *)&v115))
          {
            *(void *)&long long v82 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v82 + 1) = 0xAAAAAAAAAAAAAAAALL;
            *(_OWORD *)&__b[248] = v82;
            *(_OWORD *)&__b[232] = v82;
            *(_OWORD *)&__b[216] = v82;
            *(_OWORD *)&__b[200] = v82;
            *(_OWORD *)&__b[184] = v82;
            *(_OWORD *)&__b[168] = v82;
            *(_OWORD *)&__b[152] = v82;
            *(_OWORD *)&__b[136] = v82;
            *(_OWORD *)&__b[120] = v82;
            *(_OWORD *)&__b[104] = v82;
            *(_OWORD *)&__b[88] = v82;
            *(_OWORD *)&__b[72] = v82;
            *(_OWORD *)&__b[56] = v82;
            *(_OWORD *)&__b[40] = v82;
            *(_OWORD *)&__b[24] = v82;
            memset(__b, 0, 24);
            *(void *)&__b[264] = &__b[24];
            GetOTFeaturesForOptionalLigatures((uint64_t)&v115, (char **)__b);
            OTL::GCommon::GetLookups((uint64_t)v11, (uint64_t)__b, (uint64_t)&v128, 0);
            *(void *)&long long v143 = __b;
            std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v143);
          }
          uint64_t v83 = 0;
          uint64_t v84 = 0;
          CFNumberRef v86 = v128;
          unint64_t v85 = (unsigned __int16 *)v129;
          do
          {
            uint64_t v87 = *(void *)*v105;
            uint64_t v88 = *(void *)(*(void *)(*(void *)(v87 + 16)
                                        + 8 * TRunGlue::PhysicalRunIndexFromLogical(*v105, v84 + v103))
                            + 48);
            uint64_t v89 = *(void *)(atomic_load_explicit((atomic_ullong *volatile)(v88 + 56), memory_order_acquire) + 40);
            uint64_t v90 = *(void *)(v88 + 208);
            *(void *)&__b[136] = 0xAAAAAAAAAAAAAAAALL;
            *(void *)&long long v91 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v91 + 1) = 0xAAAAAAAAAAAAAAAALL;
            *(_OWORD *)&__b[104] = v91;
            *(_OWORD *)&__b[120] = v91;
            *(_OWORD *)&__b[72] = v91;
            *(_OWORD *)&__b[88] = v91;
            *(_OWORD *)&__b[40] = v91;
            *(_OWORD *)&__b[56] = v91;
            *(_OWORD *)&__b[24] = v91;
            memset(__b, 0, 24);
            *(void *)&__b[144] = &__b[24];
            if (TOpenTypeMorph::ShapeGlyphs(SyncState &)::$_2::operator()((uint64_t *)&v134, v89 + 168, (uint64_t)__b))
            {
              int64x2_t v92 = *(unsigned int **)__b;
              uint64_t v93 = *(unsigned int **)&__b[8];
              while (v92 != v93)
              {
                uint64_t v94 = *v92;
                CFDictionaryRef v95 = v86;
                if (v86 != (void **)v85)
                {
                  CFDictionaryRef v95 = v86;
                  while (*(unsigned __int16 *)v95 != (unsigned __int16)v94)
                  {
                    CFDictionaryRef v95 = (void **)((char *)v95 + 4);
                    if (v95 == (void **)v85) {
                      goto LABEL_129;
                    }
                  }
                }
                if (v95 == (void **)v85)
                {
LABEL_129:
                  unint64_t v9 = v9 & 0xFFFFFFFF00000000 | v94;
                  OTL::GlyphLookups::SetLookupInRange<true>((uint64_t *)&v137, v9, v83, v90);
                }
                else
                {
                  unint64_t v27 = v27 & 0xFFFFFFFF00000000 | v94;
                  OTL::GlyphLookups::SetLookupInRange<false>((uint64_t *)&v137, v27, v83, v90);
                }
                ++v92;
              }
            }
            v83 += v90;
            *(void *)&long long v143 = __b;
            std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v143);
            ++v84;
          }
          while (v84 != v104);
          *(void *)__b = &v115;
          std::vector<unsigned int,TInlineBufferAllocator<unsigned int,36ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)__b);
          *(void *)__b = &v128;
          std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)__b);
          uint64_t v24 = v105;
          uint64_t v80 = v101;
          unsigned __int8 v26 = v102;
        }
        else
        {
          *(void *)&long long v73 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v73 + 1) = 0xAAAAAAAAAAAAAAAALL;
          *(_OWORD *)&__b[120] = v73;
          *(_OWORD *)&__b[104] = v73;
          *(_OWORD *)&__b[88] = v73;
          *(_OWORD *)&__b[72] = v73;
          *(_OWORD *)&__b[56] = v73;
          *(_OWORD *)&__b[40] = v73;
          *(_OWORD *)&__b[24] = v73;
          memset(__b, 0, 24);
          uint64_t v74 = (uint64_t)v24[1] + 168;
          *(void *)&__b[136] = 0xAAAAAAAAAAAAAAAALL;
          *(void *)&__b[144] = &__b[24];
          if (TOpenTypeMorph::ShapeGlyphs(SyncState &)::$_2::operator()((uint64_t *)&v134, v74, (uint64_t)__b))
          {
            uint64_t v75 = TRunGlue::length(*v105);
            uint64_t v76 = *(unsigned int **)__b;
            unint64_t v77 = *(unsigned int **)&__b[8];
            if (*(void *)__b != *(void *)&__b[8])
            {
              uint64_t v78 = v75;
              do
              {
                unsigned int v79 = *v76++;
                unint64_t v9 = v9 & 0xFFFFFFFF00000000 | v79;
                OTL::GlyphLookups::SetLookupInRange<false>((uint64_t *)&v137, v9, 0, v78);
              }
              while (v76 != v77);
            }
          }
          uint64_t v115 = (void **)__b;
          std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100](&v115);
          uint64_t v24 = v105;
          uint64_t v80 = v101;
        }
        if (*((_DWORD *)v24 + 6) != 2)
        {
          unint64_t v96 = 126 - 2 * __clz(0x4EC4EC4EC4EC4EC5 * ((v138 - v137) >> 3));
          if (v138 == v137) {
            uint64_t v97 = 0;
          }
          else {
            uint64_t v97 = v96;
          }
          std::__introsort<std::_ClassicAlgPolicy,OTL::GlyphLookups::SortLookups(void)::{lambda(std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&)#1} &,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>*,false>((unsigned __int16 *)v137, (unsigned __int16 *)v138, v97, 1);
        }
        uint64_t v28 = OTL::GSUB::ApplyLookups(v100, *v24, *((_DWORD *)v24 + 4), (unsigned __int16 **)&v137, v26, 0, 0);
        if (v106) {
          JoiningScriptShapingEngine::FinishStretching(v24[69], *v24, v98);
        }
      }
      else
      {
        uint64_t v28 = 1;
        uint64_t v80 = v101;
      }
      *((void *)*v24 + 13) = v80;
      if (__p)
      {
        unint64_t v108 = (char *)__p;
        if (v110 > __p || (char *)v110 + 4 <= __p) {
          operator delete(__p);
        }
      }
      *(void *)__b = &v137;
      std::vector<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,TInlineBufferAllocator<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)__b);
      return v28;
    case 21:
      if (((*((_DWORD *)v105 + 179) << 24) - 956301313) <= 0xF9FFFFFE && *((int *)v105 + 4) >= 1)
      {
        memset(__b, 170, 0x380uLL);
        KannadaShapingEngine::KannadaShapingEngine((KannadaShapingEngine *)__b, v105[69], *v105, v11);
      }
      goto LABEL_64;
    case 23:
      *(void *)&long long v34 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v34 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)&__b[464] = v34;
      *(_OWORD *)&__b[480] = v34;
      *(_OWORD *)&__b[432] = v34;
      *(_OWORD *)&__b[448] = v34;
      *(_OWORD *)&__b[400] = v34;
      *(_OWORD *)&__b[416] = v34;
      *(_OWORD *)&__b[368] = v34;
      *(_OWORD *)&__b[384] = v34;
      *(_OWORD *)&__b[336] = v34;
      *(_OWORD *)&__b[352] = v34;
      *(_OWORD *)&__b[304] = v34;
      *(_OWORD *)&__b[320] = v34;
      *(_OWORD *)&__b[272] = v34;
      *(_OWORD *)&__b[288] = v34;
      *(_OWORD *)&__b[240] = v34;
      *(_OWORD *)&__b[256] = v34;
      *(_OWORD *)&__b[208] = v34;
      *(_OWORD *)&__b[224] = v34;
      *(_OWORD *)&__b[176] = v34;
      *(_OWORD *)&__b[192] = v34;
      *(_OWORD *)&__b[144] = v34;
      *(_OWORD *)&__b[160] = v34;
      *(_OWORD *)&__b[112] = v34;
      *(_OWORD *)&__b[128] = v34;
      *(_OWORD *)&__b[80] = v34;
      *(_OWORD *)&__b[96] = v34;
      *(_OWORD *)&__b[48] = v34;
      *(_OWORD *)&__b[64] = v34;
      *(_OWORD *)&__b[16] = v34;
      *(_OWORD *)&__b[32] = v34;
      *(_OWORD *)__b = v34;
      OpenTypeShapingEngine::OpenTypeShapingEngine((OpenTypeShapingEngine *)__b, v105[69], *v105);
      *(void *)__b = &unk_1ED05E718;
      *v4 |= OpenTypeShapingEngine::ApplyScriptShaping((OpenTypeShapingEngine *)__b, v112);
      TOpenTypeMorph::SetLookups((TOpenTypeMorph *)v105, v112, (OTL::GlyphLookups *)&v137);
      unint64_t v35 = 126 - 2 * __clz(0x4EC4EC4EC4EC4EC5 * ((v138 - v137) >> 3));
      if (v138 == v137) {
        uint64_t v36 = 0;
      }
      else {
        uint64_t v36 = v35;
      }
      std::__introsort<std::_ClassicAlgPolicy,OTL::GlyphLookups::SortLookups(void)::{lambda(std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&)#1} &,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>*,false>((unsigned __int16 *)v137, (unsigned __int16 *)v138, v36, 1);
      OTL::GSUB::ApplyLookups(v11, *v105, *((_DWORD *)v105 + 4), (unsigned __int16 **)&v137, v4, 0, 0);
      uint64_t v38 = (unsigned __int16 *)v137;
      unint64_t v37 = v138;
      if (v138 != v137)
      {
        do
        {
          uint64_t v39 = v37 - 104;
          uint64_t v128 = (void **)(v37 - 96);
          std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__destroy_vector::operator()[abi:nn180100](&v128);
          unint64_t v37 = v39;
        }
        while (v39 != (char *)v38);
      }
      double v138 = (char *)v38;
      KhmerShapingEngine::GetPresentationFeatures((KhmerShapingEngine *)__b, (char *)v112, (uint64_t (**)(KhmerShapingEngine *))&v111);
      uint64_t v40 = (void **)v108;
      if (v108 >= v109)
      {
        uint64_t v49 = (void **)__p;
        uint64_t v50 = (v108 - (unsigned char *)__p) >> 2;
        unint64_t v51 = v50 + 1;
        if ((unint64_t)(v50 + 1) >> 62) {
          goto LABEL_146;
        }
        uint64_t v52 = v109 - (unsigned char *)__p;
        if ((v109 - (unsigned char *)__p) >> 1 > v51) {
          unint64_t v51 = v52 >> 1;
        }
        if ((unint64_t)v52 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v53 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v53 = v51;
        }
        *((void *)&v131[0] + 1) = v110;
        if (v53)
        {
          uint64_t v54 = (char *)TInlineBufferAllocator<unsigned int,1ul>::allocate((uint64_t)v110, v53);
          uint64_t v49 = (void **)__p;
          uint64_t v40 = (void **)v108;
        }
        else
        {
          uint64_t v54 = 0;
        }
        unsigned __int16 v68 = &v54[4 * v50];
        *(_DWORD *)unsigned __int16 v68 = 1818847073;
        if (v40 == v49)
        {
          uint64_t v70 = &v54[4 * v50];
        }
        else
        {
          uint64_t v69 = v40;
          uint64_t v70 = &v54[4 * v50];
          do
          {
            int v71 = *((_DWORD *)v69 - 1);
            uint64_t v69 = (void **)((char *)v69 - 4);
            *((_DWORD *)v70 - 1) = v71;
            v70 -= 4;
          }
          while (v69 != v49);
        }
        uint64_t v41 = v68 + 4;
        __p = v70;
        unint64_t v108 = v68 + 4;
        uint64_t v72 = v109;
        unint64_t v109 = &v54[4 * v53];
        uint64_t v130 = v40;
        *(void *)&v131[0] = v72;
        uint64_t v128 = v49;
        uint64_t v129 = v49;
        std::__split_buffer<unsigned int,TInlineBufferAllocator<unsigned int,1ul> &>::~__split_buffer((uint64_t)&v128);
        uint64_t v24 = v105;
      }
      else
      {
        *(_DWORD *)unint64_t v108 = 1818847073;
        uint64_t v41 = (char *)v40 + 4;
      }
      unint64_t v108 = v41;
LABEL_106:
      OpenTypeShapingEngine::~OpenTypeShapingEngine((OpenTypeShapingEngine *)__b);
      goto LABEL_107;
    case 24:
      *(void *)&long long v42 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v42 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)&__b[464] = v42;
      *(_OWORD *)&__b[480] = v42;
      *(_OWORD *)&__b[432] = v42;
      *(_OWORD *)&__b[448] = v42;
      *(_OWORD *)&__b[400] = v42;
      *(_OWORD *)&__b[416] = v42;
      *(_OWORD *)&__b[368] = v42;
      *(_OWORD *)&__b[384] = v42;
      *(_OWORD *)&__b[336] = v42;
      *(_OWORD *)&__b[352] = v42;
      *(_OWORD *)&__b[304] = v42;
      *(_OWORD *)&__b[320] = v42;
      *(_OWORD *)&__b[272] = v42;
      *(_OWORD *)&__b[288] = v42;
      *(_OWORD *)&__b[240] = v42;
      *(_OWORD *)&__b[256] = v42;
      *(_OWORD *)&__b[208] = v42;
      *(_OWORD *)&__b[224] = v42;
      *(_OWORD *)&__b[176] = v42;
      *(_OWORD *)&__b[192] = v42;
      *(_OWORD *)&__b[144] = v42;
      *(_OWORD *)&__b[160] = v42;
      *(_OWORD *)&__b[112] = v42;
      *(_OWORD *)&__b[128] = v42;
      *(_OWORD *)&__b[80] = v42;
      *(_OWORD *)&__b[96] = v42;
      *(_OWORD *)&__b[48] = v42;
      *(_OWORD *)&__b[64] = v42;
      *(_OWORD *)&__b[16] = v42;
      *(_OWORD *)&__b[32] = v42;
      *(_OWORD *)__b = v42;
      OpenTypeShapingEngine::OpenTypeShapingEngine((OpenTypeShapingEngine *)__b, v105[69], *v105);
      *(void *)__b = &unk_1ED05E558;
      *v4 |= OpenTypeShapingEngine::ApplyScriptShaping((OpenTypeShapingEngine *)__b, v112);
      OpenTypeShapingEngine::~OpenTypeShapingEngine((OpenTypeShapingEngine *)__b);
      goto LABEL_64;
    case 26:
      if (((*((_DWORD *)v105 + 179) << 24) - 956301313) <= 0xF9FFFFFE && *((int *)v105 + 4) >= 1)
      {
        memset(__b, 170, 0x380uLL);
        MalayalamShapingEngine::MalayalamShapingEngine((MalayalamShapingEngine *)__b, v105[69], *v105, v11);
      }
      goto LABEL_64;
    case 28:
      if (v105[69] && *((_DWORD *)v105 + 179))
      {
        uint64_t v43 = *v105;
        *(void *)__b = v105[69];
        *(void *)&__b[8] = v43;
        *v4 |= MyanmarShapingEngine::ApplyScriptShaping((MyanmarShapingEngine *)__b, v11, (OTL::GlyphLookups *)&v137);
        strcpy((char *)v112, "serpsvbaswlbstsp");
        BYTE1(v112[4]) = 0;
        HIWORD(v112[4]) = 0;
        goto LABEL_107;
      }
      strcpy((char *)v112, "gilcagil");
      BYTE1(v112[2]) = 0;
      HIWORD(v112[2]) = 0;
      uint64_t v31 = TOpenTypeMorph::ApplyShapingEngine<TInlineVector<unsigned int,1ul>>(OTL::GlyphLookups &,unsigned int *,BOOL (**),TInlineVector<unsigned int,1ul> &,SyncState &,BOOL *)::{lambda#2}::__invoke;
      goto LABEL_23;
    case 31:
      if (((*((_DWORD *)v105 + 179) << 24) - 956301313) <= 0xF9FFFFFE && *((int *)v105 + 4) >= 1)
      {
        memset(__b, 170, 0x380uLL);
        OriyaShapingEngine::OriyaShapingEngine((OriyaShapingEngine *)__b, v105[69], *v105, v11);
      }
      goto LABEL_64;
    case 34:
      goto LABEL_21;
    case 35:
      if (((*((_DWORD *)v105 + 179) << 24) - 956301313) <= 0xF9FFFFFE && *((int *)v105 + 4) >= 1)
      {
        memset(__b, 170, 0x380uLL);
        TamilShapingEngine::TamilShapingEngine((TamilShapingEngine *)__b, v105[69], *v105, v11);
      }
      goto LABEL_64;
    case 36:
      if (((*((_DWORD *)v105 + 179) << 24) - 956301313) <= 0xF9FFFFFE && *((int *)v105 + 4) >= 1)
      {
        memset(__b, 170, 0x380uLL);
        TeluguShapingEngine::TeluguShapingEngine((TeluguShapingEngine *)__b, v105[69], *v105, v11);
      }
      goto LABEL_64;
    case 38:
      *(void *)&long long v44 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v44 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)&__b[464] = v44;
      *(_OWORD *)&__b[480] = v44;
      *(_OWORD *)&__b[432] = v44;
      *(_OWORD *)&__b[448] = v44;
      *(_OWORD *)&__b[400] = v44;
      *(_OWORD *)&__b[416] = v44;
      *(_OWORD *)&__b[368] = v44;
      *(_OWORD *)&__b[384] = v44;
      *(_OWORD *)&__b[336] = v44;
      *(_OWORD *)&__b[352] = v44;
      *(_OWORD *)&__b[304] = v44;
      *(_OWORD *)&__b[320] = v44;
      *(_OWORD *)&__b[272] = v44;
      *(_OWORD *)&__b[288] = v44;
      *(_OWORD *)&__b[240] = v44;
      *(_OWORD *)&__b[256] = v44;
      *(_OWORD *)&__b[208] = v44;
      *(_OWORD *)&__b[224] = v44;
      *(_OWORD *)&__b[176] = v44;
      *(_OWORD *)&__b[192] = v44;
      *(_OWORD *)&__b[144] = v44;
      *(_OWORD *)&__b[160] = v44;
      *(_OWORD *)&__b[112] = v44;
      *(_OWORD *)&__b[128] = v44;
      *(_OWORD *)&__b[80] = v44;
      *(_OWORD *)&__b[96] = v44;
      *(_OWORD *)&__b[48] = v44;
      *(_OWORD *)&__b[64] = v44;
      *(_OWORD *)&__b[16] = v44;
      *(_OWORD *)&__b[32] = v44;
      *(_OWORD *)__b = v44;
      OpenTypeShapingEngine::OpenTypeShapingEngine((OpenTypeShapingEngine *)__b, v105[69], *v105);
      *(void *)__b = &unk_1ED05E6C0;
      *v4 |= OpenTypeShapingEngine::ApplyScriptShaping((OpenTypeShapingEngine *)__b, v112);
      goto LABEL_106;
    default:
      if (*((_DWORD *)v105 + 178) != 1145457748)
      {
LABEL_64:
        uint64_t v45 = v105[69];
        if (v45)
        {
          uint64_t v46 = *v105;
          uint64_t v47 = ScriptTagForScriptCode(*((_DWORD *)v105 + 6));
          *(void *)__b = v45;
          *(void *)&__b[8] = v46;
          UniversalClassTable::ClassTableForScript(v47, &v128);
          *(void *)&__b[16] = v128;
          if (v128)
          {
            *v4 |= UniversalShapingEngine::ApplyScriptShaping((UniversalShapingEngine *)__b, v11, (OTL::GlyphLookups *)&v137);
            strcpy((char *)v112, "svbaswlbnlahserpstsp");
            BYTE1(v112[5]) = 0;
            HIWORD(v112[5]) = 0;
            uint64_t v48 = *(void *)&__b[16];
            *(void *)&__b[16] = 0;
            if (v48) {
              MEMORY[0x1853275C0](v48, 0x1050C409ECFBC67);
            }
          }
        }
      }
      goto LABEL_107;
  }
}

void std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    v1[1] = v2;
    uint64_t v3 = v1 + 33;
    if (v1 + 3 <= v2)
    {
      BOOL v4 = v3 >= v2;
      BOOL v5 = v3 == v2;
    }
    else
    {
      BOOL v4 = 0;
      BOOL v5 = 0;
    }
    if (!v5 && v4)
    {
      if (v1[2] == v1[33]) {
        *uint64_t v3 = v2;
      }
    }
    else
    {
      operator delete(v2);
    }
  }
}

void std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    v1[1] = v2;
    uint64_t v3 = v1 + 18;
    if (v1 + 3 <= v2)
    {
      BOOL v4 = v3 >= v2;
      BOOL v5 = v3 == v2;
    }
    else
    {
      BOOL v4 = 0;
      BOOL v5 = 0;
    }
    if (!v5 && v4)
    {
      if (v1[2] == v1[18]) {
        *uint64_t v3 = v2;
      }
    }
    else
    {
      operator delete(v2);
    }
  }
}

void OTL::GlyphLookups::SetLookupInRange<true>(uint64_t *a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  unint64_t v9 = (unsigned __int16 *)*a1;
  uint64_t v8 = (unsigned __int16 *)a1[1];
  if ((unsigned __int16 *)*a1 != v8)
  {
    while (*v9 != (unsigned __int16)a2 || v9[1] != HIWORD(a2))
    {
      v9 += 52;
      if (v9 == v8) {
        goto LABEL_13;
      }
    }
  }
  if (v9 == v8)
  {
LABEL_13:
    unint64_t v46 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v16 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v44 = v16;
    long long v45 = v16;
    long long v42 = v16;
    long long v43 = v16;
    *(_OWORD *)&v41[16] = v16;
    *(_OWORD *)uint64_t v41 = v16;
    v39[0] = a3;
    v39[1] = a4;
    TInlineVector<CFRange,4ul>::TInlineVector(v40, v39, 1uLL);
    *(_DWORD *)uint64_t v41 = a2;
    std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::vector<std::__wrap_iter<CFRange const*>,0>((uint64_t)&v41[8], (unsigned char *)v40[0], (unsigned char *)v40[1]);
    uint64_t v38 = v40;
    std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v38);
    std::vector<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,TInlineBufferAllocator<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,30ul>>::emplace_back<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>>(a1, (uint64_t)v41);
    v40[0] = (void **)&v41[8];
    std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__destroy_vector::operator()[abi:nn180100](v40);
    return;
  }
  unint64_t v12 = (char *)*((void *)v9 + 1);
  unint64_t v11 = (char *)*((void *)v9 + 2);
  if (v12 != v11)
  {
    uint64_t v13 = *((void *)v11 - 1);
    if (v13 < 0) {
      return;
    }
    uint64_t v14 = *((void *)v11 - 2);
    uint64_t v15 = v14 + v13;
    if (v14 + v13 == a3)
    {
      *((void *)v11 - 1) = v13 + a4;
      return;
    }
    uint64_t v17 = a3 + a4;
    if (a3 + a4 == v14)
    {
      *((void *)v11 - 2) = a3;
      *((void *)v11 - 1) = v13 + a4;
      return;
    }
    if (v17 >= v15) {
      uint64_t v18 = v14 + v13;
    }
    else {
      uint64_t v18 = a3 + a4;
    }
    BOOL v19 = v14 <= a3 && a3 < v15;
    uint64_t v20 = a3;
    if (v19 || (a3 <= v14 ? (BOOL v21 = v14 < v17) : (BOOL v21 = 0), v20 = *((void *)v11 - 2), v21))
    {
      if (v18 > v20)
      {
        if (v14 >= a3) {
          uint64_t v22 = a3;
        }
        else {
          uint64_t v22 = *((void *)v11 - 2);
        }
        if (v17 <= v15) {
          uint64_t v23 = v14 + v13;
        }
        else {
          uint64_t v23 = a3 + a4;
        }
        *((void *)v11 - 2) = v22;
        *((void *)v11 - 1) = v23 - v22;
        return;
      }
    }
    if (a3 == v14 && a4 == v13) {
      return;
    }
  }
  unint64_t v25 = *((void *)v9 + 3);
  if ((unint64_t)v11 >= v25)
  {
    uint64_t v27 = (v11 - v12) >> 4;
    unint64_t v28 = v27 + 1;
    if ((unint64_t)(v27 + 1) >> 60) {
      abort();
    }
    uint64_t v29 = v25 - (void)v12;
    if (v29 >> 3 > v28) {
      unint64_t v28 = v29 >> 3;
    }
    if ((unint64_t)v29 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v30 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v30 = v28;
    }
    *(void *)&long long v42 = v9 + 16;
    if (v30) {
      uint64_t v31 = (char *)TInlineBufferAllocator<CFRange,4ul>::allocate((uint64_t)(v9 + 16), v30);
    }
    else {
      uint64_t v31 = 0;
    }
    uint64_t v32 = &v31[16 * v27];
    *(void *)uint64_t v32 = a3;
    *((void *)v32 + 1) = a4;
    uint64_t v33 = *((void *)v9 + 1);
    unint64_t v34 = *((void *)v9 + 2);
    if (v34 == v33)
    {
      int64x2_t v36 = vdupq_n_s64(v34);
      unint64_t v35 = &v31[16 * v27];
    }
    else
    {
      unint64_t v35 = &v31[16 * v27];
      do
      {
        *((_OWORD *)v35 - 1) = *(_OWORD *)(v34 - 16);
        v35 -= 16;
        v34 -= 16;
      }
      while (v34 != v33);
      int64x2_t v36 = *(int64x2_t *)(v9 + 4);
    }
    unsigned __int8 v26 = v32 + 16;
    *((void *)v9 + 1) = v35;
    *((void *)v9 + 2) = v32 + 16;
    *(int64x2_t *)&v41[8] = v36;
    uint64_t v37 = *((void *)v9 + 3);
    *((void *)v9 + 3) = &v31[16 * v30];
    *(void *)&v41[24] = v37;
    *(void *)uint64_t v41 = v36.i64[0];
    std::__split_buffer<CFRange,TInlineBufferAllocator<CFRange,4ul> &>::~__split_buffer((uint64_t)v41);
  }
  else
  {
    *(void *)unint64_t v11 = a3;
    *((void *)v11 + 1) = a4;
    unsigned __int8 v26 = v11 + 16;
  }
  *((void *)v9 + 2) = v26;
}

BOOL TOpenTypeMorph::ShapeGlyphs(SyncState &)::$_2::operator()(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v97 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *a1;
  unint64_t v6 = *(int *)(*a1 + 24) + 2654435769;
  unint64_t v7 = (*(unsigned int *)(*a1 + 28) + (v6 << 6) + (v6 >> 2) + 2654435769u) ^ v6;
  unint64_t v8 = (*(int *)(*a1 + 16) + (v7 << 6) + (v7 >> 2) + 2654435769u) ^ v7;
  unint64_t v9 = (os_unfair_lock_s *)(a2 + 32);
  os_unfair_lock_lock_with_options();
  int8x8_t v10 = *(int8x8_t *)(a2 + 48);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8(v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v12 = v8;
      if (v8 >= *(void *)&v10) {
        unint64_t v12 = v8 % *(void *)&v10;
      }
    }
    else
    {
      unint64_t v12 = v8 & (*(void *)&v10 - 1);
    }
    uint64_t v13 = *(uint64_t ****)(*(void *)(a2 + 40) + 8 * v12);
    if (v13)
    {
      for (uint64_t i = *v13; i; uint64_t i = (uint64_t **)*i)
      {
        unint64_t v15 = (unint64_t)i[1];
        if (v15 == v8)
        {
          if (i[2] == (uint64_t *)v8)
          {
            std::vector<std::pair<unsigned short,unsigned short>,TInlineBufferAllocator<std::pair<unsigned short,unsigned short>,30ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<std::pair<unsigned short,unsigned short>*>,std::__wrap_iter<std::pair<unsigned short,unsigned short>*>>((char *)a3, (int *)i[3], (int *)i[4], ((char *)i[4] - (char *)i[3]) >> 2);
            goto LABEL_126;
          }
        }
        else
        {
          if (v11.u32[0] > 1uLL)
          {
            if (v15 >= *(void *)&v10) {
              v15 %= *(void *)&v10;
            }
          }
          else
          {
            v15 &= *(void *)&v10 - 1;
          }
          if (v15 != v12) {
            break;
          }
        }
      }
    }
  }
  *(void *)&long long v16 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v95[8] = v16;
  v95[7] = v16;
  v95[6] = v16;
  v95[5] = v16;
  v95[4] = v16;
  v95[3] = v16;
  v95[2] = v16;
  v95[1] = v16;
  v95[0] = v16;
  memset(v94, 0, sizeof(v94));
  unint64_t v96 = v95;
  os_unfair_lock_t lock = v9;
  OTL::GCommon::GetFeatures((OTL::GCommon *)(v5 + 640), (OTL::FeatureList *)v94);
  *(void *)&long long v17 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v17 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v92[14] = v17;
  v92[13] = v17;
  v92[12] = v17;
  v92[11] = v17;
  v92[10] = v17;
  v92[9] = v17;
  v92[8] = v17;
  v92[7] = v17;
  v92[6] = v17;
  v92[5] = v17;
  v92[4] = v17;
  v92[3] = v17;
  v92[2] = v17;
  v92[1] = v17;
  v92[0] = v17;
  unint64_t v91 = 0;
  int64x2_t v90 = 0uLL;
  uint64_t v93 = v92;
  if (OTL::FeatureList::StripMissingFeaturesFrom(v94, (unsigned int *)a1[1]))
  {
    uint64_t v18 = 0;
    uint64_t v19 = a1[1];
    do
    {
      int v20 = *(_DWORD *)(v19 + 4 * v18);
      if (!v20) {
        break;
      }
      uint64_t v21 = v90.i64[1];
      if (v90.i64[1] >= v91)
      {
        uint64_t v23 = (v90.i64[1] - v90.i64[0]) >> 3;
        unint64_t v24 = v23 + 1;
        if ((unint64_t)(v23 + 1) >> 61) {
LABEL_136:
        }
          abort();
        uint64_t v25 = v91 - v90.i64[0];
        if ((uint64_t)(v91 - v90.i64[0]) >> 2 > v24) {
          unint64_t v24 = v25 >> 2;
        }
        unint64_t v26 = (unint64_t)v25 >= 0x7FFFFFFFFFFFFFF8 ? 0x1FFFFFFFFFFFFFFFLL : v24;
        uint64_t v89 = v92;
        uint64_t v27 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v92, v26);
        unint64_t v28 = &v27[8 * v23];
        *(_DWORD *)unint64_t v28 = v20;
        *((_DWORD *)v28 + 1) = 1;
        uint64_t v29 = v90.i64[1];
        uint64_t v30 = v90.i64[0];
        if (v90.i64[1] == v90.i64[0])
        {
          int64x2_t v33 = vdupq_n_s64(v90.u64[1]);
          uint64_t v31 = (uint64_t)&v27[8 * v23];
        }
        else
        {
          uint64_t v31 = (uint64_t)&v27[8 * v23];
          do
          {
            uint64_t v32 = *(void *)(v29 - 8);
            v29 -= 8;
            *(void *)(v31 - 8) = v32;
            v31 -= 8;
          }
          while (v29 != v30);
          int64x2_t v33 = v90;
        }
        uint64_t v22 = (uint64_t)(v28 + 8);
        v90.i64[0] = v31;
        v90.i64[1] = (uint64_t)(v28 + 8);
        int64x2_t v87 = v33;
        unint64_t v34 = v91;
        unint64_t v91 = (unint64_t)&v27[8 * v26];
        unint64_t v88 = v34;
        CFNumberRef v86 = (int64x2_t *)v33.i64[0];
        std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v86);
      }
      else
      {
        *(_DWORD *)v90.i64[1] = v20;
        *(_DWORD *)(v21 + 4) = 1;
        uint64_t v22 = v21 + 8;
      }
      v90.i64[1] = v22;
      ++v18;
    }
    while (v18 != 16);
  }
  unint64_t v35 = (int **)a1[2];
  uint64_t v37 = *v35;
  int64x2_t v36 = v35[1];
  if (*v35 != v36)
  {
    uint64_t v38 = (_DWORD *)v90.i64[1];
    do
    {
      int v39 = *v37;
      if ((unint64_t)v38 >= v91)
      {
        uint64_t v40 = ((uint64_t)v38 - v90.i64[0]) >> 3;
        if ((unint64_t)(v40 + 1) >> 61) {
          goto LABEL_136;
        }
        unint64_t v41 = (uint64_t)(v91 - v90.i64[0]) >> 2;
        if (v41 <= v40 + 1) {
          unint64_t v41 = v40 + 1;
        }
        if (v91 - v90.i64[0] >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v42 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v42 = v41;
        }
        uint64_t v89 = v92;
        long long v43 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v92, v42);
        long long v44 = &v43[8 * v40];
        *(_DWORD *)long long v44 = v39;
        *((_DWORD *)v44 + 1) = 0;
        uint64_t v45 = v90.i64[1];
        uint64_t v46 = v90.i64[0];
        if (v90.i64[1] == v90.i64[0])
        {
          int64x2_t v49 = vdupq_n_s64(v90.u64[1]);
          uint64_t v47 = (uint64_t)&v43[8 * v40];
        }
        else
        {
          uint64_t v47 = (uint64_t)&v43[8 * v40];
          do
          {
            uint64_t v48 = *(void *)(v45 - 8);
            v45 -= 8;
            *(void *)(v47 - 8) = v48;
            v47 -= 8;
          }
          while (v45 != v46);
          int64x2_t v49 = v90;
        }
        uint64_t v38 = v44 + 8;
        v90.i64[0] = v47;
        v90.i64[1] = (uint64_t)(v44 + 8);
        int64x2_t v87 = v49;
        unint64_t v50 = v91;
        unint64_t v91 = (unint64_t)&v43[8 * v42];
        unint64_t v88 = v50;
        CFNumberRef v86 = (int64x2_t *)v49.i64[0];
        std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v86);
      }
      else
      {
        *uint64_t v38 = v39;
        v38[1] = 0;
        v38 += 2;
      }
      v90.i64[1] = (uint64_t)v38;
      ++v37;
    }
    while (v37 != v36);
  }
  ConvertSettingsToOTFeatures(v94, (atomic_ullong *)a2, *(unsigned __int8 *)(v5 + 20), &v90, *(uint64_t (**)(void))a1[3], 0, 1);
  OTL::GCommon::GetLookups(v5 + 640, (uint64_t)&v90, a3, 1);
  unint64_t v51 = *(int **)a3;
  uint64_t v52 = *(int **)(a3 + 8);
  unint64_t v53 = *(void *)(a2 + 48);
  if (v53)
  {
    uint8x8_t v54 = (uint8x8_t)vcnt_s8((int8x8_t)v53);
    v54.i16[0] = vaddlv_u8(v54);
    if (v54.u32[0] > 1uLL)
    {
      unint64_t v55 = v8;
      if (v53 <= v8) {
        unint64_t v55 = v8 % v53;
      }
    }
    else
    {
      unint64_t v55 = (v53 - 1) & v8;
    }
    int v56 = *(void **)(*(void *)(a2 + 40) + 8 * v55);
    if (v56)
    {
      for (uint64_t j = (void *)*v56; j; uint64_t j = (void *)*j)
      {
        unint64_t v58 = j[1];
        if (v58 == v8)
        {
          if (j[2] == v8) {
            goto LABEL_125;
          }
        }
        else
        {
          if (v54.u32[0] > 1uLL)
          {
            if (v58 >= v53) {
              v58 %= v53;
            }
          }
          else
          {
            v58 &= v53 - 1;
          }
          if (v58 != v55) {
            break;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v55 = 0xAAAAAAAAAAAAAAAALL;
  }
  unint64_t v59 = (char *)operator new(0xB0uLL);
  *(void *)unint64_t v59 = 0;
  *((void *)v59 + 1) = v8;
  *((void *)v59 + 2) = v8;
  *((void *)v59 + 4) = 0;
  *((void *)v59 + 5) = 0;
  *((void *)v59 + 3) = 0;
  *((void *)v59 + 21) = v59 + 48;
  std::vector<std::pair<unsigned short,unsigned short>,TInlineBufferAllocator<std::pair<unsigned short,unsigned short>,30ul>>::__init_with_size[abi:nn180100]<std::__wrap_iter<std::pair<unsigned short,unsigned short> const*>,std::__wrap_iter<std::pair<unsigned short,unsigned short> const*>>(v59 + 24, v51, v52, v52 - v51);
  float v60 = (float)(unint64_t)(*(void *)(a2 + 64) + 1);
  float v61 = *(float *)(a2 + 72);
  if (!v53 || (float)(v61 * (float)v53) < v60)
  {
    BOOL v62 = 1;
    if (v53 >= 3) {
      BOOL v62 = (v53 & (v53 - 1)) != 0;
    }
    unint64_t v63 = v62 | (2 * v53);
    unint64_t v64 = vcvtps_u32_f32(v60 / v61);
    if (v63 <= v64) {
      int8x8_t prime = (int8x8_t)v64;
    }
    else {
      int8x8_t prime = (int8x8_t)v63;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    }
    unint64_t v53 = *(void *)(a2 + 48);
    if (*(void *)&prime > v53) {
      goto LABEL_81;
    }
    if (*(void *)&prime < v53)
    {
      unint64_t v72 = vcvtps_u32_f32((float)*(unint64_t *)(a2 + 64) / *(float *)(a2 + 72));
      if (v53 < 3 || (uint8x8_t v73 = (uint8x8_t)vcnt_s8((int8x8_t)v53), v73.i16[0] = vaddlv_u8(v73), v73.u32[0] > 1uLL))
      {
        unint64_t v72 = std::__next_prime(v72);
      }
      else
      {
        uint64_t v74 = 1 << -(char)__clz(v72 - 1);
        if (v72 >= 2) {
          unint64_t v72 = v74;
        }
      }
      if (*(void *)&prime <= v72) {
        int8x8_t prime = (int8x8_t)v72;
      }
      if (*(void *)&prime >= v53)
      {
        unint64_t v53 = *(void *)(a2 + 48);
      }
      else
      {
        if (prime)
        {
LABEL_81:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          int v66 = operator new(8 * *(void *)&prime);
          uint64_t v67 = *(void **)(a2 + 40);
          *(void *)(a2 + 40) = v66;
          if (v67) {
            operator delete(v67);
          }
          uint64_t v68 = 0;
          *(int8x8_t *)(a2 + 48) = prime;
          do
            *(void *)(*(void *)(a2 + 40) + 8 * v68++) = 0;
          while (*(void *)&prime != v68);
          uint64_t v69 = *(void **)(a2 + 56);
          if (v69)
          {
            unint64_t v70 = v69[1];
            uint8x8_t v71 = (uint8x8_t)vcnt_s8(prime);
            v71.i16[0] = vaddlv_u8(v71);
            if (v71.u32[0] > 1uLL)
            {
              if (v70 >= *(void *)&prime) {
                v70 %= *(void *)&prime;
              }
            }
            else
            {
              v70 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)(a2 + 40) + 8 * v70) = a2 + 56;
            uint64_t v75 = (void *)*v69;
            if (*v69)
            {
              do
              {
                unint64_t v76 = v75[1];
                if (v71.u32[0] > 1uLL)
                {
                  if (v76 >= *(void *)&prime) {
                    v76 %= *(void *)&prime;
                  }
                }
                else
                {
                  v76 &= *(void *)&prime - 1;
                }
                if (v76 != v70)
                {
                  uint64_t v77 = *(void *)(a2 + 40);
                  if (!*(void *)(v77 + 8 * v76))
                  {
                    *(void *)(v77 + 8 * v76) = v69;
                    goto LABEL_106;
                  }
                  *uint64_t v69 = *v75;
                  *uint64_t v75 = **(void **)(*(void *)(a2 + 40) + 8 * v76);
                  **(void **)(*(void *)(a2 + 40) + 8 * v76) = v75;
                  uint64_t v75 = v69;
                }
                unint64_t v76 = v70;
LABEL_106:
                uint64_t v69 = v75;
                uint64_t v75 = (void *)*v75;
                unint64_t v70 = v76;
              }
              while (v75);
            }
          }
          unint64_t v53 = (unint64_t)prime;
          goto LABEL_110;
        }
        uint64_t v83 = *(void **)(a2 + 40);
        *(void *)(a2 + 40) = 0;
        if (v83) {
          operator delete(v83);
        }
        unint64_t v53 = 0;
        *(void *)(a2 + 48) = 0;
      }
    }
LABEL_110:
    if ((v53 & (v53 - 1)) != 0)
    {
      if (v53 <= v8) {
        unint64_t v55 = v8 % v53;
      }
      else {
        unint64_t v55 = v8;
      }
    }
    else
    {
      unint64_t v55 = (v53 - 1) & v8;
    }
  }
  uint64_t v78 = *(void *)(a2 + 40);
  unsigned int v79 = *(void **)(v78 + 8 * v55);
  if (v79)
  {
    *(void *)unint64_t v59 = *v79;
  }
  else
  {
    *(void *)unint64_t v59 = *(void *)(a2 + 56);
    *(void *)(a2 + 56) = v59;
    *(void *)(v78 + 8 * v55) = a2 + 56;
    if (!*(void *)v59) {
      goto LABEL_124;
    }
    unint64_t v80 = *(void *)(*(void *)v59 + 8);
    if ((v53 & (v53 - 1)) != 0)
    {
      if (v80 >= v53) {
        v80 %= v53;
      }
    }
    else
    {
      v80 &= v53 - 1;
    }
    unsigned int v79 = (void *)(*(void *)(a2 + 40) + 8 * v80);
  }
  *unsigned int v79 = v59;
LABEL_124:
  ++*(void *)(a2 + 64);
LABEL_125:
  CFNumberRef v86 = &v90;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v86);
  v90.i64[0] = (uint64_t)v94;
  std::vector<unsigned int,TInlineBufferAllocator<unsigned int,36ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v90);
  unint64_t v9 = lock;
LABEL_126:
  BOOL v81 = *(void *)a3 != *(void *)(a3 + 8);
  os_unfair_lock_unlock(v9);
  return v81;
}

void *std::__function::__value_func<BOOL ()(TRunGlue::TGlyph)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

BOOL OTL::GSUB::GetSingleSubstLookups(void *a1, uint64_t a2, uint64_t a3)
{
  BOOL v5 = 0;
  if (OTL::GCommon::GetLookups((uint64_t)a1, a2, a3, 0))
  {
    uint64_t v6 = *(void *)(a1[2] + 400);
    unint64_t v7 = (os_unfair_lock_s *)(v6 + 356);
    os_unfair_lock_lock_with_options();
    unint64_t v8 = *(unsigned __int16 **)(a3 + 8);
    unint64_t v9 = std::remove_if[abi:nn180100]<std::__wrap_iter<std::pair<unsigned short,unsigned short> *>,std::__not_fn_t<OTL::GSUB::GetSingleSubstLookups(OTL::FeatureBuffer const&,TInlineVector<std::pair<unsigned short,unsigned short>,30ul> *)::IsSingleSubst>>(*(unsigned __int16 **)a3, v8, a1, v6);
    std::vector<std::pair<unsigned short,unsigned short>,TInlineBufferAllocator<std::pair<unsigned short,unsigned short>,30ul>>::erase(a3, v9, v8);
    BOOL v5 = *(void *)a3 != *(void *)(a3 + 8);
    os_unfair_lock_unlock(v7);
  }
  return v5;
}

void std::__introsort<std::_ClassicAlgPolicy,OTL::GlyphLookups::SortLookups(void)::{lambda(std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&)#1} &,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>*,false>(unsigned __int16 *a1, unsigned __int16 *a2, uint64_t a3, char a4)
{
  uint64_t v223 = *MEMORY[0x1E4F143B8];
  while (2)
  {
    unint64_t v9 = a2;
    BOOL v206 = (__int16 *)(a2 - 52);
    int8x8_t v10 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v10;
          uint64_t v11 = (char *)v9 - (char *)v10;
          unint64_t v12 = 0x4EC4EC4EC4EC4EC5 * (((char *)v9 - (char *)v10) >> 3);
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return;
              case 2uLL:
                unsigned int v97 = *(a2 - 52);
                unsigned int v98 = *a1;
                BOOL v99 = v97 == v98;
                if (v97 >= v98) {
                  char v100 = 1;
                }
                else {
                  char v100 = -1;
                }
                if (v99)
                {
                  unsigned int v101 = *(a2 - 51);
                  unsigned int v102 = a1[1];
                  BOOL v4 = v101 >= v102;
                  BOOL v103 = v101 == v102;
                  char v100 = -1;
                  if (v4) {
                    char v100 = 1;
                  }
                  if (v103) {
                    char v100 = 0;
                  }
                }
                if (v100 < 0)
                {
                  std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>::swap[abi:nn180100]((__int16 *)a1, (__int16 *)a2 - 52);
                }
                break;
              case 3uLL:
                std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,OTL::GlyphLookups::SortLookups(void)::{lambda(std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&)#1} &,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>*>((__int16 *)a1, (__int16 *)a1 + 52, v206);
                break;
              case 4uLL:
                std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,OTL::GlyphLookups::SortLookups(void)::{lambda(std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&)#1} &,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>*>((__int16 *)a1, (__int16 *)a1 + 52, (__int16 *)a1 + 104, v206);
                break;
              case 5uLL:
                std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,OTL::GlyphLookups::SortLookups(void)::{lambda(std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&)#1} &,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>*>((__int16 *)a1, (__int16 *)a1 + 52, (__int16 *)a1 + 104, (__int16 *)a1 + 156, v206);
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v11 <= 2495)
          {
            if (a4)
            {
              if (a1 != v9)
              {
                uint64_t v104 = a1 + 52;
                if (a1 + 52 != a2)
                {
                  uint64_t v105 = 0;
                  BOOL v106 = a1;
                  do
                  {
                    long long v107 = v104;
                    unsigned int v108 = v106[52];
                    unsigned int v109 = *v106;
                    BOOL v110 = v108 == v109;
                    if (v108 >= v109) {
                      char v111 = 1;
                    }
                    else {
                      char v111 = -1;
                    }
                    if (v110)
                    {
                      unsigned int v112 = v106[53];
                      unsigned int v113 = v106[1];
                      BOOL v114 = v112 == v113;
                      char v111 = v112 >= v113 ? 1 : -1;
                      if (v114) {
                        char v111 = 0;
                      }
                    }
                    if (v111 < 0)
                    {
                      unint64_t v222 = 0xAAAAAAAAAAAAAAAALL;
                      *(void *)&long long v115 = 0xAAAAAAAAAAAAAAAALL;
                      *((void *)&v115 + 1) = 0xAAAAAAAAAAAAAAAALL;
                      long long v220 = v115;
                      long long v221 = v115;
                      long long v218 = v115;
                      long long v219 = v115;
                      long long v217 = v115;
                      long long v216 = v115;
                      LODWORD(v216) = *(_DWORD *)v107;
                      std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::vector<std::__wrap_iter<CFRange const*>,0>((uint64_t)&v216 + 8, *((unsigned char **)v106 + 14), *((unsigned char **)v106 + 15));
                      LOWORD(v116) = *v106;
                      uint64_t v117 = v105;
                      while (1)
                      {
                        long long v118 = (char *)a1 + v117;
                        *((_WORD *)v118 + 52) = v116;
                        *((_WORD *)v118 + 53) = *(unsigned __int16 *)((char *)a1 + v117 + 2);
                        std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<CFRange const*>,std::__wrap_iter<CFRange const*>>((char *)a1 + v117 + 112, *(char **)((char *)a1 + v117 + 8), *(void *)((char *)a1 + v117 + 16), (uint64_t)(*(void *)((char *)a1 + v117 + 16) - *(void *)((char *)a1 + v117 + 8)) >> 4);
                        if (!v117) {
                          break;
                        }
                        unsigned int v116 = *((unsigned __int16 *)v118 - 52);
                        if ((unsigned __int16)v216 >= v116) {
                          char v119 = 1;
                        }
                        else {
                          char v119 = -1;
                        }
                        if ((unsigned __int16)v216 == v116)
                        {
                          unsigned int v120 = *(unsigned __int16 *)((char *)a1 + v117 - 102);
                          BOOL v121 = WORD1(v216) == v120;
                          char v119 = WORD1(v216) >= v120 ? 1 : -1;
                          if (v121) {
                            char v119 = 0;
                          }
                        }
                        v117 -= 104;
                        if ((v119 & 0x80) == 0)
                        {
                          uint64_t v122 = (uint64_t)a1 + v117 + 104;
                          goto LABEL_230;
                        }
                      }
                      uint64_t v122 = (uint64_t)a1;
LABEL_230:
                      *(_DWORD *)uint64_t v122 = v216;
                      std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<CFRange const*>,std::__wrap_iter<CFRange const*>>((char *)(v122 + 8), *((char **)&v216 + 1), v217, (uint64_t)(v217 - *((void *)&v216 + 1)) >> 4);
                      *(void *)&long long v209 = (char *)&v216 + 8;
                      std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v209);
                    }
                    uint64_t v104 = v107 + 52;
                    v105 += 104;
                    BOOL v106 = v107;
                  }
                  while (v107 + 52 != a2);
                }
              }
            }
            else if (a1 != v9)
            {
              char v191 = a1 + 52;
              if (a1 + 52 != a2)
              {
                unsigned int v192 = (char *)(a1 + 56);
                do
                {
                  unsigned int v193 = v191;
                  unsigned int v194 = a1[52];
                  unsigned int v195 = *a1;
                  BOOL v196 = v194 == v195;
                  if (v194 >= v195) {
                    char v197 = 1;
                  }
                  else {
                    char v197 = -1;
                  }
                  if (v196)
                  {
                    unsigned int v198 = a1[53];
                    unsigned int v199 = a1[1];
                    BOOL v200 = v198 == v199;
                    char v197 = v198 >= v199 ? 1 : -1;
                    if (v200) {
                      char v197 = 0;
                    }
                  }
                  if (v197 < 0)
                  {
                    unint64_t v222 = 0xAAAAAAAAAAAAAAAALL;
                    *(void *)&long long v201 = 0xAAAAAAAAAAAAAAAALL;
                    *((void *)&v201 + 1) = 0xAAAAAAAAAAAAAAAALL;
                    long long v220 = v201;
                    long long v221 = v201;
                    long long v218 = v201;
                    long long v219 = v201;
                    long long v217 = v201;
                    long long v216 = v201;
                    LODWORD(v216) = *(_DWORD *)v193;
                    std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::vector<std::__wrap_iter<CFRange const*>,0>((uint64_t)&v216 + 8, *((unsigned char **)a1 + 14), *((unsigned char **)a1 + 15));
                    LOWORD(v202) = *a1;
                    v203 = v192;
                    do
                    {
                      *((_WORD *)v203 - 4) = v202;
                      *((_WORD *)v203 - 3) = *((_WORD *)v203 - 55);
                      std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<CFRange const*>,std::__wrap_iter<CFRange const*>>(v203, *((char **)v203 - 13), *((void *)v203 - 12), (uint64_t)(*((void *)v203 - 12) - *((void *)v203 - 13)) >> 4);
                      unsigned int v202 = *((unsigned __int16 *)v203 - 108);
                      if ((unsigned __int16)v216 >= v202) {
                        char v204 = 1;
                      }
                      else {
                        char v204 = -1;
                      }
                      if ((unsigned __int16)v216 == v202)
                      {
                        unsigned int v205 = *((unsigned __int16 *)v203 - 107);
                        char v204 = WORD1(v216) >= v205 ? 1 : -1;
                        if (WORD1(v216) == v205) {
                          char v204 = 0;
                        }
                      }
                      v203 -= 104;
                    }
                    while (v204 < 0);
                    *((_DWORD *)v203 - 2) = v216;
                    std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<CFRange const*>,std::__wrap_iter<CFRange const*>>(v203, *((char **)&v216 + 1), v217, (uint64_t)(v217 - *((void *)&v216 + 1)) >> 4);
                    *(void *)&long long v209 = (char *)&v216 + 8;
                    std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v209);
                  }
                  char v191 = v193 + 52;
                  v192 += 104;
                  a1 = v193;
                }
                while (v193 + 52 != a2);
              }
            }
            return;
          }
          if (!a3)
          {
            if (a1 != v9)
            {
              int64_t v123 = (v12 - 2) >> 1;
              int64_t v124 = v123;
              do
              {
                int64_t v125 = v124;
                if (v123 >= v124)
                {
                  uint64_t v126 = (2 * v124) | 1;
                  uint64_t v127 = &a1[52 * v126];
                  if (2 * v124 + 2 < (uint64_t)v12)
                  {
                    unsigned int v128 = v127[52];
                    unsigned int v129 = *v127;
                    BOOL v130 = v129 == v128;
                    if (v129 >= v128) {
                      char v131 = 1;
                    }
                    else {
                      char v131 = -1;
                    }
                    if (v130)
                    {
                      unsigned int v132 = v127[1];
                      unsigned int v133 = v127[53];
                      BOOL v134 = v132 == v133;
                      char v131 = v132 >= v133 ? 1 : -1;
                      if (v134) {
                        char v131 = 0;
                      }
                    }
                    if (v131 < 0)
                    {
                      v127 += 52;
                      uint64_t v126 = 2 * v124 + 2;
                    }
                  }
                  int64_t v135 = (char *)&a1[52 * v124];
                  unsigned int v136 = *v127;
                  unsigned int v137 = *(unsigned __int16 *)v135;
                  BOOL v138 = v136 == v137;
                  if (v136 >= v137) {
                    char v139 = 1;
                  }
                  else {
                    char v139 = -1;
                  }
                  if (v138)
                  {
                    unsigned int v140 = v127[1];
                    unsigned int v141 = *((unsigned __int16 *)v135 + 1);
                    BOOL v142 = v140 == v141;
                    char v139 = v140 >= v141 ? 1 : -1;
                    if (v142) {
                      char v139 = 0;
                    }
                  }
                  if ((v139 & 0x80) == 0)
                  {
                    unint64_t v222 = 0xAAAAAAAAAAAAAAAALL;
                    *(void *)&long long v143 = 0xAAAAAAAAAAAAAAAALL;
                    *((void *)&v143 + 1) = 0xAAAAAAAAAAAAAAAALL;
                    long long v220 = v143;
                    long long v221 = v143;
                    long long v218 = v143;
                    long long v219 = v143;
                    long long v217 = v143;
                    long long v216 = v143;
                    LODWORD(v216) = *(_DWORD *)v135;
                    std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::vector<std::__wrap_iter<CFRange const*>,0>((uint64_t)&v216 + 8, *(unsigned char **)&a1[52 * v125 + 4], *(unsigned char **)&a1[52 * v125 + 8]);
                    LOWORD(v144) = *v127;
                    do
                    {
                      BOOL v145 = (char *)v127;
                      *(_WORD *)int64_t v135 = v144;
                      *((_WORD *)v135 + 1) = v127[1];
                      std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<CFRange const*>,std::__wrap_iter<CFRange const*>>(v135 + 8, *((char **)v127 + 1), *((void *)v127 + 2), (uint64_t)(*((void *)v127 + 2) - *((void *)v127 + 1)) >> 4);
                      if (v123 < v126)
                      {
                        v156 = (char *)(v127 + 4);
                        __int16 v157 = v216;
                        goto LABEL_289;
                      }
                      uint64_t v127 = &a1[52 * ((2 * v126) | 1)];
                      if (2 * v126 + 2 < (uint64_t)v12)
                      {
                        unsigned int v146 = v127[52];
                        unsigned int v147 = *v127;
                        BOOL v148 = v147 == v146;
                        if (v147 >= v146) {
                          char v149 = 1;
                        }
                        else {
                          char v149 = -1;
                        }
                        if (v148)
                        {
                          unsigned int v150 = v127[1];
                          unsigned int v151 = v127[53];
                          BOOL v152 = v150 == v151;
                          char v149 = v150 >= v151 ? 1 : -1;
                          if (v152) {
                            char v149 = 0;
                          }
                        }
                        if (v149 < 0)
                        {
                          v127 += 52;
                          uint64_t v126 = 2 * v126 + 2;
                        }
                        else
                        {
                          uint64_t v126 = (2 * v126) | 1;
                        }
                      }
                      else
                      {
                        uint64_t v126 = (2 * v126) | 1;
                      }
                      unsigned int v144 = *v127;
                      __int16 v157 = v216;
                      if (v144 >= (unsigned __int16)v216) {
                        char v153 = 1;
                      }
                      else {
                        char v153 = -1;
                      }
                      if (v144 == (unsigned __int16)v216)
                      {
                        unsigned int v154 = v127[1];
                        BOOL v155 = v154 == WORD1(v216);
                        char v153 = v154 >= WORD1(v216) ? 1 : -1;
                        if (v155) {
                          char v153 = 0;
                        }
                      }
                      int64_t v135 = v145;
                    }
                    while ((v153 & 0x80) == 0);
                    v156 = v145 + 8;
LABEL_289:
                    *(_WORD *)BOOL v145 = v157;
                    *((_WORD *)v145 + 1) = WORD1(v216);
                    std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<CFRange const*>,std::__wrap_iter<CFRange const*>>(v156, *((char **)&v216 + 1), v217, (uint64_t)(v217 - *((void *)&v216 + 1)) >> 4);
                    *(void *)&long long v209 = (char *)&v216 + 8;
                    std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v209);
                  }
                }
                int64_t v124 = v125 - 1;
              }
              while (v125);
              int64_t v158 = v11 / 0x68uLL;
              do
              {
                if (v158 >= 2)
                {
                  unint64_t v215 = 0xAAAAAAAAAAAAAAAALL;
                  *(void *)&long long v159 = 0xAAAAAAAAAAAAAAAALL;
                  *((void *)&v159 + 1) = 0xAAAAAAAAAAAAAAAALL;
                  long long v213 = v159;
                  long long v214 = v159;
                  long long v211 = v159;
                  long long v212 = v159;
                  long long v209 = v159;
                  long long v210 = v159;
                  LODWORD(v209) = *(_DWORD *)a1;
                  std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::vector<std::__wrap_iter<CFRange const*>,0>((uint64_t)&v209 + 8, *((unsigned char **)a1 + 1), *((unsigned char **)a1 + 2));
                  uint64_t v160 = 0;
                  long long v161 = (char *)a1;
                  do
                  {
                    long long v162 = (unsigned __int16 *)&v161[104 * v160 + 104];
                    uint64_t v163 = (2 * v160) | 1;
                    uint64_t v164 = 2 * v160 + 2;
                    if (v164 < v158)
                    {
                      unsigned int v165 = v162[52];
                      unsigned int v166 = *v162;
                      BOOL v167 = v166 == v165;
                      if (v166 >= v165) {
                        char v168 = 1;
                      }
                      else {
                        char v168 = -1;
                      }
                      if (v167)
                      {
                        unsigned int v169 = v162[1];
                        unsigned int v170 = v162[53];
                        BOOL v171 = v169 == v170;
                        char v168 = v169 >= v170 ? 1 : -1;
                        if (v171) {
                          char v168 = 0;
                        }
                      }
                      if (v168 < 0)
                      {
                        v162 += 52;
                        uint64_t v163 = v164;
                      }
                    }
                    *(_WORD *)long long v161 = *v162;
                    *((_WORD *)v161 + 1) = v162[1];
                    std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<CFRange const*>,std::__wrap_iter<CFRange const*>>(v161 + 8, *((char **)v162 + 1), *((void *)v162 + 2), (uint64_t)(*((void *)v162 + 2) - *((void *)v162 + 1)) >> 4);
                    long long v161 = (char *)v162;
                    uint64_t v160 = v163;
                  }
                  while (v163 <= (uint64_t)((unint64_t)(v158 - 2) >> 1));
                  long long v172 = (char *)(v162 + 4);
                  if (v162 == a2 - 52)
                  {
                    *(_DWORD *)long long v162 = v209;
                    std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<CFRange const*>,std::__wrap_iter<CFRange const*>>(v172, *((char **)&v209 + 1), v210, (uint64_t)(v210 - *((void *)&v209 + 1)) >> 4);
                  }
                  else
                  {
                    long long v173 = (char *)*((void *)a2 - 12);
                    *long long v162 = *(a2 - 52);
                    v162[1] = *(a2 - 51);
                    std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<CFRange const*>,std::__wrap_iter<CFRange const*>>(v172, v173, *((void *)a2 - 11), (uint64_t)(*((void *)a2 - 11) - (void)v173) >> 4);
                    *((_DWORD *)a2 - 26) = v209;
                    std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<CFRange const*>,std::__wrap_iter<CFRange const*>>((char *)a2 - 96, *((char **)&v209 + 1), v210, (uint64_t)(v210 - *((void *)&v209 + 1)) >> 4);
                    uint64_t v174 = (char *)v162 - (char *)a1 + 104;
                    if (v174 >= 105)
                    {
                      unint64_t v175 = (v174 / 0x68uLL - 2) >> 1;
                      CFRange v176 = &a1[52 * v175];
                      unsigned int v177 = *v176;
                      unsigned int v178 = *v162;
                      BOOL v179 = v177 == v178;
                      if (v177 >= v178) {
                        char v180 = 1;
                      }
                      else {
                        char v180 = -1;
                      }
                      if (v179)
                      {
                        unsigned int v181 = v176[1];
                        unsigned int v182 = v162[1];
                        BOOL v183 = v181 == v182;
                        char v180 = v181 >= v182 ? 1 : -1;
                        if (v183) {
                          char v180 = 0;
                        }
                      }
                      if (v180 < 0)
                      {
                        unint64_t v222 = 0xAAAAAAAAAAAAAAAALL;
                        *(void *)&long long v184 = 0xAAAAAAAAAAAAAAAALL;
                        *((void *)&v184 + 1) = 0xAAAAAAAAAAAAAAAALL;
                        long long v220 = v184;
                        long long v221 = v184;
                        long long v218 = v184;
                        long long v219 = v184;
                        long long v217 = v184;
                        long long v216 = v184;
                        LODWORD(v216) = *(_DWORD *)v162;
                        std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::vector<std::__wrap_iter<CFRange const*>,0>((uint64_t)&v216 + 8, *((unsigned char **)v162 + 1), *((unsigned char **)v162 + 2));
                        LOWORD(v185) = *v176;
                        do
                        {
                          unint64_t v186 = v176;
                          *long long v162 = v185;
                          v162[1] = v176[1];
                          std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<CFRange const*>,std::__wrap_iter<CFRange const*>>((char *)v162 + 8, *((char **)v176 + 1), *((void *)v176 + 2), (uint64_t)(*((void *)v176 + 2) - *((void *)v176 + 1)) >> 4);
                          if (!v175) {
                            break;
                          }
                          unint64_t v175 = (v175 - 1) >> 1;
                          CFRange v176 = &a1[52 * v175];
                          unsigned int v185 = *v176;
                          if (v185 >= (unsigned __int16)v216) {
                            char v187 = 1;
                          }
                          else {
                            char v187 = -1;
                          }
                          if (v185 == (unsigned __int16)v216)
                          {
                            unsigned int v188 = v176[1];
                            BOOL v189 = v188 == WORD1(v216);
                            char v187 = v188 >= WORD1(v216) ? 1 : -1;
                            if (v189) {
                              char v187 = 0;
                            }
                          }
                          long long v162 = v186;
                        }
                        while (v187 < 0);
                        *(_DWORD *)unint64_t v186 = v216;
                        std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<CFRange const*>,std::__wrap_iter<CFRange const*>>((char *)v186 + 8, *((char **)&v216 + 1), v217, (uint64_t)(v217 - *((void *)&v216 + 1)) >> 4);
                        unsigned int v208 = (void **)&v216 + 1;
                        std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__destroy_vector::operator()[abi:nn180100](&v208);
                      }
                    }
                  }
                  *(void *)&long long v216 = (char *)&v209 + 8;
                  std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v216);
                }
                a2 -= 52;
              }
              while ((unint64_t)v158-- > 2);
            }
            return;
          }
          uint64_t v13 = (__int16 *)&a1[52 * (v12 >> 1)];
          if ((unint64_t)v11 >= 0x3401)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,OTL::GlyphLookups::SortLookups(void)::{lambda(std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&)#1} &,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>*>((__int16 *)a1, (__int16 *)&a1[52 * (v12 >> 1)], v206);
            uint64_t v14 = 52 * (v12 >> 1);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,OTL::GlyphLookups::SortLookups(void)::{lambda(std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&)#1} &,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>*>((__int16 *)a1 + 52, (__int16 *)&a1[v14 - 52], (__int16 *)a2 - 104);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,OTL::GlyphLookups::SortLookups(void)::{lambda(std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&)#1} &,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>*>((__int16 *)a1 + 104, (__int16 *)&a1[v14 + 52], (__int16 *)a2 - 156);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,OTL::GlyphLookups::SortLookups(void)::{lambda(std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&)#1} &,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>*>((__int16 *)&a1[v14 - 52], v13, (__int16 *)&a1[v14 + 52]);
            std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>::swap[abi:nn180100]((__int16 *)a1, v13);
          }
          else
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,OTL::GlyphLookups::SortLookups(void)::{lambda(std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&)#1} &,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>*>((__int16 *)&a1[52 * (v12 >> 1)], (__int16 *)a1, v206);
          }
          --a3;
          unint64_t v9 = a2;
          if (a4) {
            break;
          }
          unsigned int v15 = *(a1 - 52);
          unsigned int v16 = *a1;
          BOOL v17 = v15 == v16;
          if (v15 >= v16) {
            char v18 = 1;
          }
          else {
            char v18 = -1;
          }
          if (v17)
          {
            unsigned int v19 = *(a1 - 51);
            unsigned int v20 = a1[1];
            BOOL v21 = v19 == v20;
            char v18 = v19 >= v20 ? 1 : -1;
            if (v21) {
              char v18 = 0;
            }
          }
          if (v18 < 0) {
            break;
          }
          unint64_t v222 = 0xAAAAAAAAAAAAAAAALL;
          *(void *)&long long v59 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v59 + 1) = 0xAAAAAAAAAAAAAAAALL;
          long long v220 = v59;
          long long v221 = v59;
          long long v218 = v59;
          long long v219 = v59;
          long long v217 = v59;
          long long v216 = v59;
          LODWORD(v216) = *(_DWORD *)a1;
          std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::vector<std::__wrap_iter<CFRange const*>,0>((uint64_t)&v216 + 8, *((unsigned char **)a1 + 1), *((unsigned char **)a1 + 2));
          unsigned __int16 v60 = v216;
          unsigned int v61 = (unsigned __int16)*v206;
          if ((unsigned __int16)v216 == v61)
          {
            unsigned int v62 = WORD1(v216);
            unsigned int v63 = *(a2 - 51);
            BOOL v64 = WORD1(v216) == v63;
            if (WORD1(v216) >= v63) {
              char v65 = 1;
            }
            else {
              char v65 = -1;
            }
            if (v64) {
              char v65 = 0;
            }
          }
          else
          {
            if ((unsigned __int16)v216 >= v61) {
              char v65 = 1;
            }
            else {
              char v65 = -1;
            }
            unsigned int v62 = WORD1(v216);
          }
          int v66 = a1;
          if (v65 < 0)
          {
            do
            {
              int8x8_t v10 = v66 + 52;
              unsigned int v73 = v66[52];
              BOOL v74 = (unsigned __int16)v216 == v73;
              if ((unsigned __int16)v216 >= v73) {
                char v75 = 1;
              }
              else {
                char v75 = -1;
              }
              if (v74)
              {
                unsigned int v76 = v66[53];
                BOOL v77 = v62 == v76;
                char v75 = v62 >= v76 ? 1 : -1;
                if (v77) {
                  char v75 = 0;
                }
              }
              v66 += 52;
            }
            while ((v75 & 0x80) == 0);
          }
          else
          {
            uint64_t v67 = a1 + 52;
            do
            {
              int8x8_t v10 = v67;
              if (v67 >= a2) {
                break;
              }
              unsigned int v68 = *v67;
              BOOL v69 = (unsigned __int16)v216 == v68;
              if ((unsigned __int16)v216 >= v68) {
                char v70 = 1;
              }
              else {
                char v70 = -1;
              }
              if (v69)
              {
                unsigned int v71 = v67[1];
                BOOL v72 = v62 == v71;
                char v70 = v62 >= v71 ? 1 : -1;
                if (v72) {
                  char v70 = 0;
                }
              }
              v67 += 52;
            }
            while ((v70 & 0x80) == 0);
          }
          uint64_t v78 = (__int16 *)a2;
          if (v10 < a2)
          {
            unsigned int v79 = a2;
            uint64_t v78 = (__int16 *)a2;
            do
            {
              unsigned int v80 = (unsigned __int16)*(v78 - 52);
              v78 -= 52;
              BOOL v81 = (unsigned __int16)v216 == v80;
              if ((unsigned __int16)v216 >= v80) {
                char v82 = 1;
              }
              else {
                char v82 = -1;
              }
              if (v81)
              {
                unsigned int v83 = *(v79 - 51);
                BOOL v84 = v62 == v83;
                char v82 = v62 >= v83 ? 1 : -1;
                if (v84) {
                  char v82 = 0;
                }
              }
              unsigned int v79 = (unsigned __int16 *)v78;
            }
            while (v82 < 0);
          }
          while (v10 < (unsigned __int16 *)v78)
          {
            std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>::swap[abi:nn180100]((__int16 *)v10, v78);
            unsigned __int16 v60 = v216;
            unint64_t v85 = v10;
            do
            {
              unsigned int v86 = v10[52];
              v10 += 52;
              BOOL v87 = (unsigned __int16)v216 == v86;
              if ((unsigned __int16)v216 >= v86) {
                char v88 = 1;
              }
              else {
                char v88 = -1;
              }
              if (v87)
              {
                unsigned int v89 = v85[53];
                BOOL v90 = WORD1(v216) == v89;
                char v88 = WORD1(v216) >= v89 ? 1 : -1;
                if (v90) {
                  char v88 = 0;
                }
              }
              unint64_t v85 = v10;
            }
            while ((v88 & 0x80) == 0);
            unint64_t v91 = v78;
            do
            {
              unsigned int v92 = (unsigned __int16)*(v78 - 52);
              v78 -= 52;
              BOOL v93 = (unsigned __int16)v216 == v92;
              if ((unsigned __int16)v216 >= v92) {
                char v94 = 1;
              }
              else {
                char v94 = -1;
              }
              if (v93)
              {
                unsigned int v95 = (unsigned __int16)*(v91 - 51);
                BOOL v96 = WORD1(v216) == v95;
                char v94 = WORD1(v216) >= v95 ? 1 : -1;
                if (v96) {
                  char v94 = 0;
                }
              }
              unint64_t v91 = v78;
            }
            while (v94 < 0);
          }
          if (v10 - 52 != a1)
          {
            *a1 = *(v10 - 52);
            a1[1] = *(v10 - 51);
            std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<CFRange const*>,std::__wrap_iter<CFRange const*>>((char *)a1 + 8, *((char **)v10 - 12), *((void *)v10 - 11), (uint64_t)(*((void *)v10 - 11) - *((void *)v10 - 12)) >> 4);
            unsigned __int16 v60 = v216;
          }
          *(v10 - 52) = v60;
          *(v10 - 51) = WORD1(v216);
          std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<CFRange const*>,std::__wrap_iter<CFRange const*>>((char *)v10 - 96, *((char **)&v216 + 1), v217, (uint64_t)(v217 - *((void *)&v216 + 1)) >> 4);
          *(void *)&long long v209 = (char *)&v216 + 8;
          std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v209);
          a4 = 0;
        }
        unint64_t v222 = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&long long v22 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v22 + 1) = 0xAAAAAAAAAAAAAAAALL;
        long long v220 = v22;
        long long v221 = v22;
        long long v218 = v22;
        long long v219 = v22;
        long long v217 = v22;
        long long v216 = v22;
        LODWORD(v216) = *(_DWORD *)a1;
        std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::vector<std::__wrap_iter<CFRange const*>,0>((uint64_t)&v216 + 8, *((unsigned char **)a1 + 1), *((unsigned char **)a1 + 2));
        uint64_t v23 = 0;
        unsigned __int16 v24 = v216;
        do
        {
          unsigned int v25 = a1[v23 + 52];
          BOOL v26 = v25 == (unsigned __int16)v216;
          if (v25 >= (unsigned __int16)v216) {
            char v27 = 1;
          }
          else {
            char v27 = -1;
          }
          if (v26)
          {
            unsigned int v28 = a1[v23 + 53];
            BOOL v29 = v28 == WORD1(v216);
            char v27 = v28 >= WORD1(v216) ? 1 : -1;
            if (v29) {
              char v27 = 0;
            }
          }
          v23 += 52;
        }
        while (v27 < 0);
        uint64_t v30 = &a1[v23];
        uint64_t v31 = a2;
        if (v23 == 52)
        {
          uint64_t v38 = a2;
          while (v30 < v38)
          {
            int64x2_t v33 = (__int16 *)(v38 - 52);
            unsigned int v39 = *(v38 - 52);
            BOOL v40 = v39 == (unsigned __int16)v216;
            if (v39 >= (unsigned __int16)v216) {
              char v41 = 1;
            }
            else {
              char v41 = -1;
            }
            if (v40)
            {
              unsigned int v42 = *(v38 - 51);
              BOOL v43 = v42 == WORD1(v216);
              if (v42 >= WORD1(v216)) {
                char v44 = 1;
              }
              else {
                char v44 = -1;
              }
              if (v43) {
                char v41 = 0;
              }
              else {
                char v41 = v44;
              }
            }
            uint64_t v38 = (unsigned __int16 *)v33;
            if (v41 < 0) {
              goto LABEL_62;
            }
          }
          int64x2_t v33 = (__int16 *)v38;
        }
        else
        {
          do
          {
            int64x2_t v33 = (__int16 *)(v31 - 52);
            unsigned int v32 = *(v31 - 52);
            BOOL v34 = v32 == (unsigned __int16)v216;
            if (v32 >= (unsigned __int16)v216) {
              char v35 = 1;
            }
            else {
              char v35 = -1;
            }
            if (v34)
            {
              unsigned int v36 = *(v31 - 51);
              BOOL v37 = v36 == WORD1(v216);
              char v35 = v36 >= WORD1(v216) ? 1 : -1;
              if (v37) {
                char v35 = 0;
              }
            }
            v31 -= 52;
          }
          while ((v35 & 0x80) == 0);
        }
LABEL_62:
        if (v30 < (unsigned __int16 *)v33)
        {
          uint64_t v45 = v33;
          int8x8_t v10 = v30;
          do
          {
            std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>::swap[abi:nn180100]((__int16 *)v10, v45);
            unsigned __int16 v24 = v216;
            uint64_t v46 = v10;
            do
            {
              unsigned int v47 = v10[52];
              v10 += 52;
              BOOL v48 = v47 == (unsigned __int16)v216;
              if (v47 >= (unsigned __int16)v216) {
                char v49 = 1;
              }
              else {
                char v49 = -1;
              }
              if (v48)
              {
                unsigned int v50 = v46[53];
                BOOL v51 = v50 == WORD1(v216);
                char v49 = v50 >= WORD1(v216) ? 1 : -1;
                if (v51) {
                  char v49 = 0;
                }
              }
              uint64_t v46 = v10;
            }
            while (v49 < 0);
            uint64_t v52 = v45;
            do
            {
              unsigned int v53 = (unsigned __int16)*(v45 - 52);
              v45 -= 52;
              BOOL v54 = v53 == (unsigned __int16)v216;
              if (v53 >= (unsigned __int16)v216) {
                char v55 = 1;
              }
              else {
                char v55 = -1;
              }
              if (v54)
              {
                unsigned int v56 = (unsigned __int16)*(v52 - 51);
                BOOL v57 = v56 == WORD1(v216);
                char v55 = v56 >= WORD1(v216) ? 1 : -1;
                if (v57) {
                  char v55 = 0;
                }
              }
              uint64_t v52 = v45;
            }
            while ((v55 & 0x80) == 0);
          }
          while (v10 < (unsigned __int16 *)v45);
        }
        else
        {
          int8x8_t v10 = v30;
        }
        if (v10 - 52 != a1)
        {
          *a1 = *(v10 - 52);
          a1[1] = *(v10 - 51);
          std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<CFRange const*>,std::__wrap_iter<CFRange const*>>((char *)a1 + 8, *((char **)v10 - 12), *((void *)v10 - 11), (uint64_t)(*((void *)v10 - 11) - *((void *)v10 - 12)) >> 4);
          unsigned __int16 v24 = v216;
        }
        *(v10 - 52) = v24;
        *(v10 - 51) = WORD1(v216);
        std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<CFRange const*>,std::__wrap_iter<CFRange const*>>((char *)v10 - 96, *((char **)&v216 + 1), v217, (uint64_t)(v217 - *((void *)&v216 + 1)) >> 4);
        *(void *)&long long v209 = (char *)&v216 + 8;
        std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v209);
        if (v30 >= (unsigned __int16 *)v33) {
          break;
        }
LABEL_95:
        std::__introsort<std::_ClassicAlgPolicy,OTL::GlyphLookups::SortLookups(void)::{lambda(std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&)#1} &,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>*,false>(a1, v10 - 52, a3, a4 & 1);
        a4 = 0;
      }
      char v58 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,OTL::GlyphLookups::SortLookups(void)::{lambda(std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&)#1} &,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>*>((__int16 *)a1, v10 - 52);
      if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,OTL::GlyphLookups::SortLookups(void)::{lambda(std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&)#1} &,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>*>((__int16 *)v10, a2))break; {
      if ((v58 & 1) == 0)
      }
        goto LABEL_95;
    }
    a2 = v10 - 52;
    if ((v58 & 1) == 0) {
      continue;
    }
    break;
  }
}

uint64_t TKerningEngine::PositionGlyphs(TRunGlue *this, int a2, const TFont *a3, char a4, __CFString *a5, uint64_t a6, char a7)
{
  Initialunint64_t ScriptAndLangSys = (unint64_t)a3;
  int v12 = a2;
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  int v29 = a7 & 1;
  char v28 = 0;
  if (a2 == 2)
  {
    uint64_t v14 = -1;
  }
  else
  {
    uint64_t CommonTable = TBaseFont::GetCommonTable(*(TBaseFont **)(*((void *)this + 77) + 400), 1634428274, 0);
    uint64_t v14 = CommonTable;
    if (CommonTable && (a7 & 2) == 0)
    {
      CFDataRef v25 = (const __CFData *)CommonTable;
      uint64_t v16 = 1;
LABEL_13:
      CFDataRef v23 = v25;
      if (v25 == (const __CFData *)-1) {
        CFDataRef v23 = (const __CFData *)TBaseFont::GetCommonTable(*(TBaseFont **)(*((void *)this + 77) + 400), 1634428274, 0);
      }
      memcpy(__dst, &unk_184B880E0, sizeof(__dst));
      TAATKerxEngine::TAATKerxEngine((TAATKerxEngine *)__dst, this, v23);
      if (*(void *)&__dst[88]) {
        uint64_t v16 = TAATKerxEngine::KernRuns((uint64_t)__dst, &v28, &v29);
      }
      TAATKerxEngine::~TAATKerxEngine((id **)__dst);
      if (v29 != 2)
      {
        *(_OWORD *)__dst = xmmword_184B88278;
        *(_OWORD *)&__dst[16] = unk_184B88288;
        memset(&__dst[32], 170, 88);
        TAATKernEngine::TAATKernEngine((TAATKernEngine *)__dst, this);
        if (*(void *)&__dst[96]) {
          uint64_t v16 = TAATKernEngine::KernRuns((uint64_t)__dst, &v28, &v29);
        }
        std::__tree<std::__value_type<long,TAATDeltaYListEntry>,std::__map_value_compare<long,std::__value_type<long,TAATDeltaYListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TAATDeltaYListEntry>>>::destroy((uint64_t)&__dst[56], *(void **)&__dst[64]);
        if (*(void *)&__dst[32])
        {
          *(void *)&__dst[40] = *(void *)&__dst[32];
          operator delete(*(void **)&__dst[32]);
        }
      }
      goto LABEL_22;
    }
  }
  int v26 = v12;
  if (!a4) {
    Initialunint64_t ScriptAndLangSys = TOpenTypeMorph::GetInitialScriptAndLangSys(a5, *((__CFString **)this + 77), a3);
  }
  CFDataRef v25 = (const __CFData *)v14;
  CFIndex v17 = *((void *)this + 5);
  if (v17 == -1)
  {
    TRunGlue::ComputeEndIndex(this);
    CFIndex v17 = *((void *)this + 5);
  }
  uint64_t v18 = *((void *)this + 6);
  CFIndex v19 = v18 + v17;
  v27.CFIndex location = v17;
  CFIndex location = v17;
  do
  {
    v27.CFIndex length = v19 - location;
    *(void *)&__dst[240] = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v21 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v21 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&__dst[208] = v21;
    *(_OWORD *)&__dst[224] = v21;
    *(_OWORD *)&__dst[176] = v21;
    *(_OWORD *)&__dst[192] = v21;
    *(_OWORD *)&__dst[144] = v21;
    *(_OWORD *)&__dst[160] = v21;
    *(_OWORD *)&__dst[112] = v21;
    *(_OWORD *)&__dst[128] = v21;
    *(_OWORD *)&__dst[80] = v21;
    *(_OWORD *)&__dst[96] = v21;
    *(_OWORD *)&__dst[48] = v21;
    *(_OWORD *)&__dst[64] = v21;
    *(_OWORD *)&__dst[16] = v21;
    *(_OWORD *)&__dst[32] = v21;
    *(_OWORD *)__dst = v21;
    TOpenTypePositioningEngine::TOpenTypePositioningEngine((uint64_t *)__dst, (uint64_t)this, a6, InitialScriptAndLangSys, &v27);
    uint64_t v16 = TOpenTypePositioningEngine::PositionRuns((uint64_t)__dst, &v28, &v29);
    v27.location += v27.length;
    CFIndex location = v27.location;
    std::__tree<std::__value_type<long,TGlyphDeltaListEntry>,std::__map_value_compare<long,std::__value_type<long,TGlyphDeltaListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TGlyphDeltaListEntry>>>::destroy(*(void **)&__dst[232]);
  }
  while (location < v19);
  *((void *)this + 5) = v17;
  *((void *)this + 6) = v18;
  uint64_t v22 = *((void *)this + 4);
  *((void *)this + 20) = 0;
  *((void *)this + 21) = v22;
  int v12 = v26;
  if (v29 != 2) {
    goto LABEL_13;
  }
LABEL_22:
  if (v12) {
    TRunGlue::FilterJoiners(this);
  }
  return v16;
}

char *std::vector<std::pair<unsigned short,unsigned short>,TInlineBufferAllocator<std::pair<unsigned short,unsigned short>,30ul>>::__init_with_size[abi:nn180100]<std::__wrap_iter<std::pair<unsigned short,unsigned short> const*>,std::__wrap_iter<std::pair<unsigned short,unsigned short> const*>>(char *result, int *a2, int *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__vallocate[abi:nn180100](result, a4);
    unint64_t v7 = (_DWORD *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      int v8 = *a2++;
      *v7++ = v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void *std::function<BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::operator=(void *a1, uint64_t a2)
{
  v4[4] = *MEMORY[0x1E4F143B8];
  std::__function::__value_func<BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::__value_func[abi:nn180100]((uint64_t)v4, a2);
  std::__function::__value_func<BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::swap[abi:nn180100](v4, a1);
  std::__function::__value_func<BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::~__value_func[abi:nn180100](v4);
  return a1;
}

uint64_t std::__function::__value_func<BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::__value_func[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

BOOL TShapingEngine::ShapeGlyphs(uint64_t a1, int a2, __CFString *this, uint64_t a4, uint64_t a5)
{
  __b[91] = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 1;
  }
  unint64_t v9 = *(__CFString **)(a1 + 616);
  if (a2 == 2 || a2 == 3 && (FontRequiresOpenTypeShaping(*(atomic_ullong **)(a1 + 616)) & 1) != 0)
  {
    Initialunint64_t ScriptAndLangSys = TOpenTypeMorph::GetInitialScriptAndLangSys(this, v9, (const TFont *)this);
    uint64_t v11 = InitialScriptAndLangSys;
    if (*(unsigned char *)(a4 + 8))
    {
      *(void *)a4 = InitialScriptAndLangSys;
    }
    else
    {
      *(void *)a4 = InitialScriptAndLangSys;
      *(unsigned char *)(a4 + 8) = 1;
    }
    CFIndex v14 = *(void *)(a1 + 40);
    if (v14 == -1)
    {
      TRunGlue::ComputeEndIndex((void *)a1);
      CFIndex v14 = *(void *)(a1 + 40);
    }
    uint64_t v20 = *(void *)(a1 + 48);
    CFIndex v15 = v20 + v14;
    v22.CFIndex location = v14;
    char v16 = 1;
    CFIndex location = v14;
    do
    {
      v22.CFIndex length = v15 - location;
      memset(__b, 170, 0x2D8uLL);
      TOpenTypeMorph::TOpenTypeMorph(__b, a1, a5, v11, &v22);
      if (__b[68])
      {
        char v21 = 0;
        char v16 = TOpenTypeMorph::ShapeGlyphs((uint64_t)__b, (uint64_t)&v21);
      }
      v22.location += v22.length;
      CFIndex location = v22.location;
      std::vector<TGlyphAuxDataListEntry,TInlineBufferAllocator<TGlyphAuxDataListEntry,30ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&__b[4]);
      int v13 = v16 & 1;
    }
    while (location < v15 && v13 != 0);
    *(void *)(a1 + 40) = v14;
    *(void *)(a1 + 48) = v20;
    uint64_t v19 = *(void *)(a1 + 32);
    *(void *)(a1 + 160) = 0;
    *(void *)(a1 + 168) = v19;
  }
  else
  {
    memset(__b, 170, 0x2A0uLL);
    TAATMorphTableMorx::TAATMorphTableMorx((TAATMorphTableMorx *)__b, (TRunGlue *)a1);
    if (__b[5])
    {
      LOBYTE(v22.location) = 0;
      int v13 = TAATMorphTable::ShapeGlyphs(__b, &v22, (CFIndex)this);
    }
    else
    {
      int v13 = 1;
    }
    __b[0] = (uint64_t)&unk_1ED05E7B0;
    __b[8] = (uint64_t)&unk_1ED05E770;
    v22.CFIndex location = (CFIndex)&__b[32];
    std::vector<unsigned char const*,TInlineBufferAllocator<unsigned char const*,48ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v22);
  }
  TRunGlue::UpdateAdvancesIfNeeded((TRunGlue *)a1);
  return v13 != 0;
}

void TStorageRange::UpdateAdvances(uint64_t a1, uint64_t a2, uint64_t x2_0)
{
  uint64_t v86 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(a1 + 16);
  char v7 = *(unsigned char *)(a1 + 33);
  if ((v7 & 2) != 0)
  {
    uint64_t v31 = *(void *)(a1 + 8);
    unsigned int v32 = *(void **)(a1 + 24);
    uint64_t v33 = v32[3];
    if (v33)
    {
      BOOL v34 = (double *)(v33 + 8 * v31);
      uint64_t v35 = a2;
      int v36 = 1;
    }
    else
    {
      BOOL v34 = (double *)(v32[4] + 16 * v31);
      uint64_t v35 = a2;
      int v36 = 2;
    }
    TFont::GetAdvancesForGlyphs(v35, v32[2] + 2 * v31, v34, v36, v6, 0, x2_0, 0);
    *(void *)a1 = v37;
    return;
  }
  if ((*(unsigned char *)(a1 + 33) & 4) != 0)
  {
    if ([*(id *)(a1 + 24) implementsCustomAdvancesForIndexes])
    {
      *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v84[14] = v8;
      v84[13] = v8;
      v84[12] = v8;
      v84[11] = v8;
      v84[10] = v8;
      v84[9] = v8;
      v84[8] = v8;
      v84[7] = v8;
      v84[6] = v8;
      v84[5] = v8;
      v84[4] = v8;
      v84[3] = v8;
      v84[2] = v8;
      v84[1] = v8;
      v84[0] = v8;
      BOOL v81 = 0;
      char v82 = 0;
      unsigned int v83 = 0;
      unint64_t v85 = v84;
      if (v6 >= 1)
      {
        unint64_t v9 = 0;
        for (uint64_t i = 0; i != (void *)v6; uint64_t i = (char *)i + 1)
        {
          if ((*(_DWORD *)(*(void *)(*(void *)(a1 + 24) + 40) + 4 * *(void *)(a1 + 8) + 4 * i) & 0x800) != 0)
          {
            if (v9 >= v83)
            {
              int v12 = (char *)v81;
              uint64_t v13 = v9 - v81;
              unint64_t v14 = v13 + 1;
              if ((unint64_t)(v13 + 1) >> 61) {
                abort();
              }
              uint64_t v15 = (char *)v83 - (char *)v81;
              if (((char *)v83 - (char *)v81) >> 2 > v14) {
                unint64_t v14 = v15 >> 2;
              }
              if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v16 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v16 = v14;
              }
              *((void *)&v50 + 1) = v84;
              if (v16)
              {
                CFIndex v17 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v84, v16);
                unint64_t v9 = v82;
                int v12 = (char *)v81;
              }
              else
              {
                CFIndex v17 = 0;
              }
              uint64_t v18 = &v17[8 * v13];
              *(void *)uint64_t v18 = i;
              if (v9 == (void **)v12)
              {
                uint64_t v20 = (void **)&v17[8 * v13];
              }
              else
              {
                uint64_t v19 = (char *)v9;
                uint64_t v20 = (void **)&v17[8 * v13];
                do
                {
                  char v21 = (void *)*((void *)v19 - 1);
                  v19 -= 8;
                  *--uint64_t v20 = v21;
                }
                while (v19 != v12);
              }
              uint64_t v11 = (void **)(v18 + 8);
              BOOL v81 = v20;
              char v82 = (void **)(v18 + 8);
              CFRange v22 = v83;
              unsigned int v83 = (void **)&v17[8 * v16];
              char v49 = v9;
              *(void *)&long long v50 = v22;
              unsigned int v47 = (double *)v12;
              BOOL v48 = v12;
              std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v47);
              unint64_t v9 = v11;
            }
            else
            {
              *v9++ = i;
              uint64_t v11 = v9;
            }
            char v82 = v11;
          }
        }
        if (v81 != v9)
        {
          *(void *)&long long v23 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v23 + 1) = 0xAAAAAAAAAAAAAAAALL;
          long long v78 = v23;
          long long v79 = v23;
          int64_t v24 = (char *)v9 - (char *)v81;
          unint64_t v25 = v9 - v81;
          long long v76 = v23;
          long long v77 = v23;
          long long v74 = v23;
          long long v75 = v23;
          long long v72 = v23;
          long long v73 = v23;
          long long v70 = v23;
          long long v71 = v23;
          long long v68 = v23;
          long long v69 = v23;
          long long v66 = v23;
          long long v67 = v23;
          long long v65 = v23;
          long long v64 = v23;
          long long v63 = v23;
          long long v62 = v23;
          long long v61 = v23;
          long long v60 = v23;
          long long v59 = v23;
          long long v58 = v23;
          long long v57 = v23;
          long long v56 = v23;
          long long v55 = v23;
          long long v54 = v23;
          long long v53 = v23;
          long long v52 = v23;
          long long v51 = v23;
          long long v50 = v23;
          unsigned int v47 = 0;
          BOOL v48 = 0;
          char v49 = 0;
          unsigned int v80 = &v50;
          std::vector<CGPoint,TInlineBufferAllocator<CGPoint,30ul>>::__vallocate[abi:nn180100]((char **)&v47, v25);
          int v26 = (char *)v48;
          bzero(v48, (2 * v24) & 0xFFFFFFFFFFFFFFF0);
          BOOL v48 = &v26[2 * v24];
          [*(id *)(a1 + 24) getCustomAdvances:v47 forIndexes:v81 count:v25];
          uint64_t v27 = 0;
          uint64_t v28 = 0;
          if (v25 <= 1) {
            uint64_t v29 = 1;
          }
          else {
            uint64_t v29 = v25;
          }
          do
          {
            uint64_t v30 = (uint64_t)v81[v28];
            TStorageRange::SetAdvance((TStorageRange *)a1, v30, *(CGSize *)&v47[v27]);
            [*(id *)(a1 + 24) setProps:*(_DWORD *)(*(void *)(*(void *)(a1 + 24) + 40) + 4 * *(void *)(a1 + 8) + 4 * v30) & 0xFFFFF7FF atIndex:*(void *)(a1 + 8) + v30];
            ++v28;
            v27 += 2;
          }
          while (v29 != v28);
          uint64_t v46 = (char **)&v47;
          std::vector<CGPoint,TInlineBufferAllocator<CGPoint,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v46);
        }
      }
      unsigned int v47 = (double *)&v81;
      std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v47);
      return;
    }
    char v7 = *(unsigned char *)(a1 + 33);
  }
  if ((v7 & 4) != 0)
  {
    if (v6 >= 1)
    {
      for (uint64_t j = 0; j != v6; ++j)
      {
        char v44 = *(void **)(a1 + 24);
        uint64_t v45 = *(void *)(a1 + 8);
        if ((*(_DWORD *)(v44[5] + 4 * v45 + 4 * j) & 0x800) != 0)
        {
          [v44 customAdvanceForIndex:j + v45];
          TStorageRange::SetAdvance((TStorageRange *)a1, j, v87);
          [*(id *)(a1 + 24) setProps:*(_DWORD *)(*(void *)(*(void *)(a1 + 24) + 40) + 4 * *(void *)(a1 + 8) + 4 * j) & 0xFFFFF7FF atIndex:j + *(void *)(a1 + 8)];
        }
      }
    }
  }
  else
  {
    uint64_t v38 = *(void *)(*(void *)(a1 + 24) + 16) + 2 * *(void *)(a1 + 8);
    *(void *)&long long v39 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v39 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v78 = v39;
    long long v79 = v39;
    long long v76 = v39;
    long long v77 = v39;
    long long v74 = v39;
    long long v75 = v39;
    long long v72 = v39;
    long long v73 = v39;
    long long v70 = v39;
    long long v71 = v39;
    long long v68 = v39;
    long long v69 = v39;
    long long v66 = v39;
    long long v67 = v39;
    long long v65 = v39;
    long long v64 = v39;
    long long v63 = v39;
    long long v62 = v39;
    long long v61 = v39;
    long long v60 = v39;
    long long v59 = v39;
    long long v58 = v39;
    long long v57 = v39;
    long long v56 = v39;
    long long v55 = v39;
    long long v54 = v39;
    long long v53 = v39;
    long long v52 = v39;
    long long v51 = v39;
    long long v50 = v39;
    unsigned int v47 = 0;
    BOOL v48 = 0;
    char v49 = 0;
    unsigned int v80 = &v50;
    if (v6)
    {
      std::vector<CGPoint,TInlineBufferAllocator<CGPoint,30ul>>::__vallocate[abi:nn180100]((char **)&v47, v6);
      BOOL v40 = (char *)v48;
      bzero(v48, 16 * v6);
      BOOL v48 = &v40[16 * v6];
      TFont::GetAdvancesForGlyphs(a2, v38, v47, 2, v6, 0, x2_0, 0);
      if (v6 >= 1)
      {
        uint64_t v41 = 0;
        for (uint64_t k = 0; k != v6; ++k)
        {
          if ((*(_DWORD *)(*(void *)(*(void *)(a1 + 24) + 40) + 4 * *(void *)(a1 + 8) + 4 * k) & 0x800) != 0)
          {
            TStorageRange::SetAdvance((TStorageRange *)a1, k, *(CGSize *)&v47[v41]);
            [*(id *)(a1 + 24) setProps:*(_DWORD *)(*(void *)(*(void *)(a1 + 24) + 40) + 4 * *(void *)(a1 + 8) + 4 * k) & 0xFFFFF7FF atIndex:k + *(void *)(a1 + 8)];
          }
          v41 += 2;
        }
      }
    }
    else
    {
      TFont::GetAdvancesForGlyphs(a2, v38, 0, 2, 0, 0, x2_0, 0);
    }
    BOOL v81 = (void **)&v47;
    std::vector<CGPoint,TInlineBufferAllocator<CGPoint,30ul>>::__destroy_vector::operator()[abi:nn180100](&v81);
  }
}

uint64_t GetOTFeaturesForOptionalLigatures(uint64_t result, char **a2)
{
  uint64_t v3 = (__int32 **)result;
  uint64_t v4 = *(void *)(result + 8);
  char v5 = &kMasterFeatureMap;
  uint64_t v6 = (uint64_t)(a2 + 3);
  do
  {
    if (*((unsigned char *)v5 + 9))
    {
      __int32 v7 = *(_DWORD *)v5;
      uint64_t result = (uint64_t)wmemchr(*v3, *(_DWORD *)v5, (v4 - (uint64_t)*v3) >> 2);
      uint64_t v8 = result ? result : v4;
      if (v8 != v4)
      {
        int8x8_t v10 = (__int32 *)a2[1];
        unint64_t v9 = (unint64_t)a2[2];
        if ((unint64_t)v10 >= v9)
        {
          uint64_t v12 = ((char *)v10 - *a2) >> 3;
          unint64_t v13 = v12 + 1;
          if ((unint64_t)(v12 + 1) >> 61) {
            abort();
          }
          uint64_t v14 = v9 - (void)*a2;
          if (v14 >> 2 > v13) {
            unint64_t v13 = v14 >> 2;
          }
          if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v15 = v13;
          }
          uint64_t v27 = v6;
          unint64_t v16 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate(v6, v15);
          CFIndex v17 = (__int32 *)&v16[8 * v12];
          *CFIndex v17 = v7;
          v17[1] = 1;
          uint64_t v19 = *a2;
          unint64_t v18 = (unint64_t)a2[1];
          if ((char *)v18 == *a2)
          {
            int64x2_t v22 = vdupq_n_s64(v18);
            uint64_t v20 = &v16[8 * v12];
          }
          else
          {
            uint64_t v20 = &v16[8 * v12];
            do
            {
              uint64_t v21 = *(void *)(v18 - 8);
              v18 -= 8;
              *((void *)v20 - 1) = v21;
              v20 -= 8;
            }
            while ((char *)v18 != v19);
            int64x2_t v22 = *(int64x2_t *)a2;
          }
          uint64_t v11 = (char *)(v17 + 2);
          *a2 = v20;
          a2[1] = (char *)(v17 + 2);
          int64x2_t v25 = v22;
          long long v23 = a2[2];
          a2[2] = &v16[8 * v15];
          int v26 = v23;
          uint64_t v24 = v22.i64[0];
          uint64_t result = std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v24);
        }
        else
        {
          __int32 *v10 = v7;
          v10[1] = 1;
          uint64_t v11 = (char *)(v10 + 2);
        }
        a2[1] = v11;
      }
    }
    char v5 = (uint64_t *)((char *)v5 + 12);
  }
  while (v5 != (uint64_t *)&unk_184BA84A4);
  return result;
}

void *std::__function::__value_func<BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::swap[abi:nn180100](void *result, void *a2)
{
  v6[3] = *MEMORY[0x1E4F143B8];
  if (a2 != result)
  {
    uint64_t v3 = result;
    uint64_t v4 = (void *)result[3];
    char v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        memset(v6, 170, 24);
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

uint64_t std::__function::__func<CTFontTransformGlyphsWithLanguage::$_0,std::allocator<CTFontTransformGlyphsWithLanguage::$_0>,BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1ED0600C8;
  a2[1] = v2;
  return result;
}

uint64_t CTLineHasBidiLevels(uint64_t result)
{
  if (result) {
    return *(_WORD *)(*(void *)(result + 40) + 152) & 1;
  }
  return result;
}

void CopyStrikeMetricsDictionaryRepresentationForSystemFont(const __CFString *a1@<X0>, void *a2@<X8>)
{
  CopyAttributeForSystemFont(a1, @"CTFontStrikeMetrics", (const __CFString **)&v3);
  *a2 = atomic_exchange((atomic_ullong *volatile)&v3, 0);
}

void TSplicedFont::CreateCascadeList(atomic_ullong *this@<X0>, const TSplicedFontDict *a2@<X1>, void *a3@<X8>)
{
  CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit(this, memory_order_acquire);
  if (explicit)
  {
    int v6 = (int)a2;
    CFArrayRef theArray = (const __CFArray *)CFDictionaryGetValue(explicit, @"Components");
    if (theArray)
    {
      id Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
      CFDictionaryRef v7 = (const __CFDictionary *)atomic_load_explicit(this, memory_order_acquire);
      if (v7) {
        v6 |= CFDictionaryGetValue(v7, @"FontMetrics") != 0;
      }
      if (TSplicedFontDict::IsInvisibleSplice(this)) {
        v6 |= 2u;
      }
      if (TSplicedFontDict::ComponentHasVariations(this)) {
        v6 |= 4u;
      }
      if (TSplicedFontDict::ComponentHasOpticalSizeAxis(this)) {
        v6 |= 0x4000u;
      }
      CFDictionaryRef v8 = (const __CFDictionary *)atomic_load_explicit(this, memory_order_acquire);
      if (v8 && CFDictionaryGetValue(v8, @"language")) {
        v6 |= 0x40000u;
      }
      CFDictionaryRef v9 = (const __CFDictionary *)atomic_load_explicit(this, memory_order_acquire);
      unsigned int v32 = a3;
      if (v9 && CFDictionaryGetValue(v9, @"lineSpacingOverride"))
      {
        v6 |= 0x80000u;
      }
      else
      {
        CFDictionaryRef v10 = (const __CFDictionary *)atomic_load_explicit(this, memory_order_acquire);
        if (v10 && CFDictionaryGetValue(v10, @"languageAwareLineHeightRatio")) {
          v6 |= 8u;
        }
      }
      if (TSplicedFontDict::IsTextStyle(this)) {
        int v11 = v6 | 0x800;
      }
      else {
        int v11 = v6;
      }
      if ((v11 & 0x800) != 0
        || (CFDictionaryRef v12 = (const __CFDictionary *)atomic_load_explicit(this, memory_order_acquire)) != 0
        && CFDictionaryGetValue(v12, @"NSCTFontUIFontDesignTrait"))
      {
        v11 |= 0x8000u;
      }
      CFIndex Count = CFArrayGetCount(theArray);
      if (Count)
      {
        CFIndex v14 = Count;
        CFIndex v15 = 0;
        while (1)
        {
          CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, v15);
          if (!CFDictionaryGetValue(ValueAtIndex, @"Components")) {
            goto LABEL_37;
          }
          v35.info = 0xAAAAAAAAAAAAAAAALL;
          v35.unint64_t isa = ValueAtIndex;
          CreateSplicedFontFromStash(&v35.info, &v35, 0, 0);

          if (!atomic_load_explicit(&v35.info, memory_order_acquire)) {
            break;
          }
          CFIndex v17 = (TDescriptor **)(id)atomic_load_explicit(&v35.info, memory_order_acquire);
          unint64_t v18 = v17;
          uint64_t v19 = v17[5];
          if ((*((_DWORD *)v19 + 4) & 0x80000000) == 0) {
            TDescriptor::InitBaseFont(v17[5], 0, 0.0);
          }
          unint64_t v20 = atomic_load_explicit((atomic_ullong *volatile)v19 + 4, memory_order_acquire);

          if ((*(unsigned int (**)(unint64_t))(*(void *)v20 + 16))(v20) != 1414743620
            || ((*(uint64_t (**)(unint64_t))(*(void *)v20 + 840))(v20) & 1) == 0)
          {
            break;
          }
          id v21 = (id)atomic_load_explicit(&v35.info, memory_order_acquire);
          CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), v21);

          info = (void *)v35.info;
LABEL_78:

          if (v14 == ++v15) {
            goto LABEL_79;
          }
        }

LABEL_37:
        CFBooleanRef Value = (atomic_ullong *)CFDictionaryGetValue(ValueAtIndex, @"name");
        if (Value)
        {
          int v24 = v11;
          if (CFDictionaryGetValue(ValueAtIndex, @"opticalSize"))
          {
            if (TSplicedFontDict::IsSystemUISplice(this)) {
              int v25 = 102416;
            }
            else {
              int v25 = 16;
            }
            int v24 = v25 | v11;
          }
          if (CFDictionaryGetValue(ValueAtIndex, @"hmtxPerAltFont")
            || CFDictionaryGetValue(ValueAtIndex, @"hmtxOverride"))
          {
            v24 |= 0x20u;
          }
          if (CFDictionaryGetValue(ValueAtIndex, @"UnicodeRange")) {
            v24 |= 0x80u;
          }
          if (CFDictionaryGetValue(ValueAtIndex, @"UnicodeCharSet")) {
            v24 |= 0x200u;
          }
          if (CFDictionaryGetValue(ValueAtIndex, @"UnicodeCharSetTrim")) {
            v24 |= 0x400u;
          }
          if (CFDictionaryGetValue(ValueAtIndex, @"languagePropertiesCacheKey")) {
            v24 |= 0x10000u;
          }
          if (CFDictionaryGetValue(ValueAtIndex, @"capHeight")) {
            int v26 = v24 | 0x2000;
          }
          else {
            int v26 = v24;
          }
          if ((v26 & 4) != 0 || !CFDictionaryGetValue(ValueAtIndex, @"hasVariations"))
          {
            int v27 = v26;
            if ((v26 & 2) != 0) {
              goto LABEL_74;
            }
          }
          else
          {
            int v27 = v26 | 4;
            if ((v26 & 0x4000) == 0 && CFDictionaryGetValue(ValueAtIndex, @"hasOpticalSizeAxis")) {
              int v27 = v26 | 0x4004;
            }
            if ((v27 & 2) != 0) {
LABEL_74:
            }
              operator new();
          }
          if ((v27 & 0x20000) != 0) {
            uint64_t v28 = 1;
          }
          else {
            uint64_t v28 = 5;
          }
          uint64_t v29 = (atomic_ullong *)CFDictionaryGetValue(ValueAtIndex, @"url");
          v35.unint64_t isa = (void *)0xAAAAAAAAAAAAAAAALL;
          CopyComponentFontDescriptorWithBaseSystemFallback(&v35, Value, v29, v28);
          if (atomic_load_explicit((atomic_ullong *volatile)&v35, memory_order_acquire)
            && ((v27 & 1) != 0 || ValueAtIndex && CFDictionaryGetCount(ValueAtIndex) >= 2))
          {
            uint64_t v30 = *(void *)(atomic_load_explicit((atomic_ullong *volatile)&v35, memory_order_acquire) + 40);
            if ((*(_DWORD *)(v30 + 16) & 0x80000000) == 0) {
              TDescriptor::InitBaseFont((TDescriptor *)v30, 0, 0.0);
            }
            atomic_load_explicit((atomic_ullong *volatile)(v30 + 32), memory_order_acquire);
            operator new();
          }
          CFBooleanRef Value = (atomic_ullong *)atomic_exchange((atomic_ullong *volatile)&v35, 0);

          if (Value)
          {
            uint64_t v31 = Value;
            CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), v31);
          }
        }
        info = Value;
        goto LABEL_78;
      }
LABEL_79:
      if (CFArrayGetCount((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire)))
      {
        *unsigned int v32 = atomic_exchange((atomic_ullong *volatile)&Mutable, 0);

        return;
      }

      a3 = v32;
    }
  }
  *a3 = 0;
}

void TBaseFont::TBaseFont(TBaseFont *this, id a2)
{
  *((_DWORD *)this + 2) = 0;
  *(void *)this = &unk_1ED05F4D8;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((void *)this + 12) = 0;
  *((void *)this + 13) = a2;
  *((_DWORD *)this + 28) = 0;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 164) = 0u;
  *(void *)((char *)this + 180) = 0x3000000010000000;
  *((_OWORD *)this + 16) = 0u;
  *((_OWORD *)this + 17) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((void *)this + 29) = 0;
  *((void *)this + 30) = 0;
  uint64_t v4 = (_OWORD *)MEMORY[0x1E4F1DAD8];
  char v5 = (_OWORD *)MEMORY[0x1E4F1DB28];
  *((_DWORD *)this + 62) = 0;
  long long v6 = v5[1];
  *((_OWORD *)this + 19) = *v5;
  *((_OWORD *)this + 20) = v6;
  *((_OWORD *)this + 18) = *v4;
  *((unsigned char *)this + 336) = 0;
  *(_OWORD *)((char *)this + 344) = 0u;
  *(_OWORD *)((char *)this + 360) = 0u;
  *(_OWORD *)((char *)this + 376) = 0u;
  *((_DWORD *)this + 98) = 1065353216;
  *((_OWORD *)this + 25) = 0u;
  *((_OWORD *)this + 26) = 0u;
  *((_DWORD *)this + 108) = 1065353216;
  *((_WORD *)this + 220) = -1;
  *(void *)((char *)this + 460) = 0;
  *((_DWORD *)this + 117) = 0;
  *(void *)((char *)this + 444) = 0;
  *(void *)((char *)this + 452) = 0;
  *((void *)this + 60) = (char *)this + 472;
  *((void *)this + 61) = 0;
  *((void *)this + 62) = 0;
  *((void *)this + 63) = 0;
  *((void *)this + 68) = (char *)this + 512;
  *(_OWORD *)((char *)this + 568) = 0u;
  *(_OWORD *)((char *)this + 584) = 0u;
  *(_OWORD *)((char *)this + 552) = 0u;
  TBaseFont::Init((atomic_ullong *)this, (CGFont *)a2);
}

void TBaseFont::Init(atomic_ullong *this, CGFont *a2)
{
  BOOL v10 = -86;
  if (a2)
  {
    CreateFontURLFromFont(a2, &v10, (atomic_ullong *)&v11);

    if (v10)
    {
LABEL_3:
      uint64_t v4 = (atomic_uint *)this + 45;
      unsigned int v5 = 0x20000000;
      goto LABEL_15;
    }
  }
  else
  {
    if (!atomic_load_explicit(this + 10, memory_order_acquire)) {
      return;
    }
    BOOL v6 = IsInMemoryFontURL((const __CFURL *)atomic_load_explicit(this + 10, memory_order_acquire));
    BOOL v10 = v6;
    if (v6) {
      goto LABEL_3;
    }
  }
  if (!atomic_load_explicit(this + 11, memory_order_acquire))
  {
    CFURLRef explicit = (const __CFURL *)atomic_load_explicit(this + 10, memory_order_acquire);
    if (explicit)
    {
      id v11 = 0;
      if (CFURLGetBaseURL(explicit))
      {

        CFURLRef explicit = (const __CFURL *)atomic_load_explicit((atomic_ullong *volatile)&v11, memory_order_acquire);
      }
      id v9 = (id)CFURLCopyFileSystemPath(explicit, kCFURLPOSIXPathStyle);
    }
    else
    {
      id v9 = 0;
    }
  }
  if (!IsSystemFontPath((CFStringRef)atomic_load_explicit(this + 11, memory_order_acquire))) {
    goto LABEL_16;
  }
  unsigned int v5 = 16;
  atomic_fetch_or_explicit((atomic_uint *volatile)this + 45, 0x10u, memory_order_relaxed);
  uint64_t v4 = (atomic_uint *)(this + 23);
LABEL_15:
  atomic_fetch_or_explicit(v4, v5, memory_order_relaxed);
LABEL_16:
  if (!atomic_load_explicit(this + 12, memory_order_acquire))
  {
    if (a2)
    {
      id v8 = (id)atomic_exchange(this + 12, (unint64_t)CGFontCopyPostScriptName(a2));
    }
    else
    {
      CopyPostScriptNameFromFontURL((const __CFURL *)atomic_load_explicit(this + 10, memory_order_acquire), (CFStringRef *)&v11);

      id v8 = v11;
    }
  }
}

void TTenuousComponentFont::InitWithOpticalSize(atomic_ullong *this, double a2)
{
  if ((*((unsigned char *)this + 713) & 0x40) != 0)
  {
    id v10 = (id)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(id *__return_ptr))(*this + 128))(&v10);
    if (atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire))
    {
      id v9 = (id)0xAAAAAAAAAAAAAAAALL;
      (*(void (**)(id *__return_ptr, atomic_ullong *))(*this + 112))(&v9, this);
      double v8 = NAN;
      CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire), @"NSCTVariationAxisMinimumValue");
      CFNumberGetValue(Value, kCFNumberDoubleType, &v8);
      double v5 = v8;
      if (v8 <= a2)
      {
        double valuePtr = NAN;
        CFNumberRef v6 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire), @"NSCTVariationAxisMaximumValue");
        CFNumberGetValue(v6, kCFNumberDoubleType, &valuePtr);
        if (valuePtr >= a2) {
          double v5 = a2;
        }
        else {
          double v5 = valuePtr;
        }
      }
      CFNumberRef v7 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire), @"NSCTVariationAxisDefaultValue");
      if (v5 == 0.0 || v7 && (double valuePtr = NAN, CFNumberGetValue(v7, kCFNumberDoubleType, &valuePtr), valuePtr == v5))
      {
        TCFRef<__CTFont const*>::Retain(this + 96, (id)atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire));
        *((unsigned char *)this + 792) = 1;
      }
      else
      {
        CopyVariationWithValue((const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire), (const __CFNumber *)&unk_1ED082E30, v5, &valuePtr);
      }
    }
  }
}

CTFontRef CTFontCreateWithFontDescriptor(CTFontDescriptorRef descriptor, CGFloat size, const CGAffineTransform *matrix)
{
  CTFontDescriptorRef v12 = descriptor;
  CGFloat v11 = size;
  id v10 = (CGAffineTransform *)matrix;
  if (!descriptor) {
    return 0;
  }
  id v3 = (TDescriptor *)*((void *)descriptor + 5);
  id v9 = (id)0xAAAAAAAAAAAAAAAALL;
  TDescriptor::CreateMatchingDescriptor(v3, 0, size, 0, (atomic_ullong *)&v9);
  id v8 = (id)0xAAAAAAAAAAAAAAAALL;
  CFURLRef explicit = (const __CTFontDescriptor *)atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire);
  TCFBase_NEW<CTFont,__CTFontDescriptor const*,double &,CGAffineTransform const*&,__CTFontDescriptor const*&>(&explicit, &v11, &v10, &v12, &v7);
  id v8 = (id)atomic_exchange((atomic_ullong *volatile)&v7, 0);

  uint64_t v4 = (const __CTFont *)atomic_exchange((atomic_ullong *volatile)&v8, 0);
  return v4;
}

void TDescriptor::CreateMatchingDescriptor(TDescriptor *this@<X0>, const __CFSet *a2@<X1>, double a3@<D0>, uint64_t a4@<X2>, atomic_ullong *a5@<X8>)
{
  uint64_t v5 = a4;
  int v32 = -1431655766;
  int v10 = *((_DWORD *)this + 4) | a4 & 0x10485;
  int v32 = v10;
  if (qword_1EB2CE0B0 != -1) {
    dispatch_once_f(&qword_1EB2CE0B0, 0, (dispatch_function_t)TDescriptor::GetSystemUIFontOptions(void)::$_0::__invoke);
  }
  if ((_MergedGlobals_13 & v10) == 0)
  {
    atomic_load_explicit((atomic_ullong *volatile)this + 1, memory_order_acquire);
    CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)this + 1, memory_order_acquire);
    if (explicit)
    {
      if (CFDictionaryGetValue(explicit, @"NSCTFontUIUsageAttribute")) {
        v32 |= 0x404u;
      }
    }
  }
  atomic_load_explicit((atomic_ullong *volatile)this + 1, memory_order_acquire);
  CFDictionaryRef v11 = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)this + 1, memory_order_acquire);
  if (v11)
  {
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v11, @"NSCTFontEnabledAttribute");
    if (Value)
    {
      CFNumberRef v13 = Value;
      LODWORD(v28[0]) = 0;
      CFTypeID v14 = CFGetTypeID(Value);
      if (v14 == CFNumberGetTypeID() || v14 == CFBooleanGetTypeID())
      {
        CFNumberGetValue(v13, kCFNumberIntType, v28);
        IntCFNumberRef Value = (SInt32)v28[0];
      }
      else if (v14 == CFStringGetTypeID())
      {
        IntCFNumberRef Value = CFStringGetIntValue((CFStringRef)v13);
      }
      else
      {
        IntCFNumberRef Value = 0;
      }
      uint64_t v5 = (IntValue != 0) | (unint64_t)v5;
    }
  }
  if (a2)
  {
    TDescriptor::CreateMatchingDescriptorInternal(a5, this, a2, v5);
    return;
  }
  uint64_t v31 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v17 = *((void *)this + 4);
  uint64_t v31 = v17;
  if (v17 && !(*(unsigned int (**)(uint64_t))(*(void *)v17 + 840))(v17)
    || (int v18 = v32, a3 <= 0.0) && v32 == *((_DWORD *)this + 4))
  {
    if ((*((_DWORD *)this + 4) & 0x80000000) == 0) {
      TDescriptor::InitBaseFont(this, v5, 0.0);
    }
    unint64_t v19 = atomic_load_explicit((atomic_ullong *volatile)this + 4, memory_order_acquire);
    uint64_t v31 = v19;
    if (!v32)
    {
      if (v19 && (*(unsigned int (**)(unint64_t))(*(void *)v19 + 16))(v19) == 1414809156)
      {
        int v32 = 1028;
      }
      else
      {
        atomic_load_explicit((atomic_ullong *volatile)this + 1, memory_order_acquire);
        CFDictionaryRef v23 = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)this + 1, memory_order_acquire);
        if (v23)
        {
          CFDictionaryRef v23 = (const __CFDictionary *)CFDictionaryGetValue(v23, @"NSCTFontTraitsAttribute");
          if (v23)
          {
            CFDictionaryRef v24 = v23;
            CFTypeID v25 = CFGetTypeID(v23);
            if (v25 == CFDictionaryGetTypeID()) {
              CFDictionaryRef v23 = v24;
            }
            else {
              CFDictionaryRef v23 = 0;
            }
          }
        }
        CFDictionaryRef v26 = v23;
        CFDictionaryRef v27 = v26;
        if (v26 && CFDictionaryContainsKey(v26, @"NSCTFontUIFontDesignTrait")) {
          v32 |= 0x404u;
        }
      }
    }
    if ((*((_DWORD *)this + 4) & 0x8000) != 0)
    {
      int64x2_t v22 = 0;
      v32 |= 0x8000u;
    }
    else
    {
      int64x2_t v22 = 0;
    }
  }
  else
  {
    *(void *)&long long v20 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v29 = v20;
    long long v30 = v20;
    *(_OWORD *)uint64_t v28 = v20;
    CFDictionaryRef Attributes = (const __CFDictionary *)TDescriptor::GetAttributes((atomic_ullong *)this, 1);
    TDescriptor::TDescriptor((TDescriptor *)v28, Attributes, v18);
    if ((v29 & 0x80000000) == 0) {
      TDescriptor::InitBaseFont((TDescriptor *)v28, v5, a3);
    }
    int64x2_t v22 = (atomic_uint *)atomic_load_explicit((atomic_ullong *volatile)&v30, memory_order_acquire);
    uint64_t v31 = (uint64_t)v22;
    if (v22) {
      atomic_fetch_add_explicit(v22 + 2, 1u, memory_order_relaxed);
    }
    v32 |= v29 & 0x8404;
    TDescriptor::~TDescriptor((TDescriptor *)v28);
  }
  if (v31)
  {
    TCFBase_NEW<CTFontDescriptor,TBaseFont const*&,unsigned int &>(&v31, &v32, v28);
    *a5 = atomic_exchange((atomic_ullong *volatile)v28, 0);

    if (!v22) {
      return;
    }
  }
  else
  {
    *a5 = 0;
    if (!v22) {
      return;
    }
  }
  if (atomic_fetch_add_explicit(v22 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v22 + 8))(v22);
  }
}

void TDescriptor::~TDescriptor(TDescriptor *this)
{
  *(void *)this = &unk_1ED05D778;
  CFDictionaryRef explicit = (atomic_uint *)atomic_load_explicit((atomic_ullong *volatile)this + 4, memory_order_acquire);
  if (explicit && atomic_fetch_add_explicit(explicit + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)explicit + 8))(explicit);
  }
}

{
  uint64_t vars8;

  TDescriptor::~TDescriptor(this);

  JUMPOUT(0x1853275C0);
}

void TCFBase_NEW<CTFontDescriptor,TBaseFont const*&,unsigned int &>(uint64_t *a1@<X0>, int *a2@<X1>, void *a3@<X8>)
{
  uint64_t v6 = TCFBase<TDescriptor>::Allocate(96);
  if (v6)
  {
    uint64_t v7 = *a1;
    int v8 = *a2;
    *(void *)(v6 + 16) = 0;
    *(void *)(v6 + 24) = TDescriptor::Hash;
    *(void *)(v6 + 32) = 0;
    *(void *)(v6 + 40) = v6 + 48;
    *(void *)(v6 + 48) = &unk_1ED05D778;
    *(void *)(v6 + 56) = 0;
    *(_DWORD *)(v6 + 64) = v8 | 0x80000000;
    *(void *)(v6 + 72) = 0;
    if (v7) {
      atomic_fetch_add_explicit((atomic_uint *volatile)(v7 + 8), 1u, memory_order_relaxed);
    }
    *(void *)(v6 + 80) = v7;
    *(void *)(v6 + 88) = 0;
    id v9 = (id)v6;
    *a3 = atomic_exchange((atomic_ullong *volatile)&v9, 0);
  }
  else
  {
    *a3 = 0;
  }
}

void TCFBase_NEW<CTFont,__CTFontDescriptor const*,double &,CGAffineTransform const*&,__CTFontDescriptor const*&>(const __CTFontDescriptor **a1@<X0>, double *a2@<X1>, CGAffineTransform **a3@<X2>, const __CTFontDescriptor **a4@<X3>, void *a5@<X8>)
{
  uint64_t v10 = TCFBase<TFont>::Allocate();
  if (v10)
  {
    CFDictionaryRef v11 = (void *)v10;
    CTFontDescriptorRef v12 = *a1;
    double v13 = *a2;
    CFTypeID v14 = *a3;
    CFIndex v15 = *a4;
    unint64_t v16 = (TFont *)(v10 + 48);
    v11[2] = 0;
    v11[3] = TFont::Hash;
    v11[4] = 0;
    void v11[5] = v16;
    TFont::TFont(v16, v12, v13, v14, v15);
    id v17 = v11;
    *a5 = atomic_exchange((atomic_ullong *volatile)&v17, 0);
  }
  else
  {
    *a5 = 0;
  }
}

uint64_t TCFBase<TFont>::Allocate()
{
  if (TCFBase<TFont>::GetTypeID(void)::once != -1) {
    dispatch_once_f(&TCFBase<TFont>::GetTypeID(void)::once, 0, (dispatch_function_t)TCFBase<TFont>::GetTypeID(void)::{lambda(void *)#1}::__invoke);
  }

  return _CFRuntimeCreateInstance();
}

void TFont::TFont(TFont *this, const __CTFontDescriptor *a2, double a3, CGAffineTransform *a4, const __CTFontDescriptor *a5)
{
  *(_DWORD *)this = 0;
  id v9 = (atomic_ullong *)((char *)this + 8);
  TFont::InitDescriptor(a2, (atomic_ullong *)this + 1);
  *((double *)this + 2) = TFont::InitSize(a5, a3, v10);
  *((void *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0x80000000;
  TFont::InitMatrix((TFont *)a4, (const CGAffineTransform *)a5, (void *)this + 5);
  *((_DWORD *)this + 12) = 0;
  *(_OWORD *)((char *)this + 88) = *MEMORY[0x1E4F1DAD8];
  long long v11 = *(_OWORD *)(MEMORY[0x1E4F1DB28] + 16);
  *(_OWORD *)((char *)this + 104) = *MEMORY[0x1E4F1DB28];
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 120) = v11;
  *((unsigned char *)this + 136) = 0;
  *((void *)this + 24) = 0;
  *((void *)this + 23) = 0;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((void *)this + 22) = (char *)this + 184;
  *((_DWORD *)this + 50) = 0;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *((_DWORD *)this + 60) = 1065353216;
  *(_OWORD *)((char *)this + 248) = 0u;
  *(_OWORD *)((char *)this + 264) = 0u;
  *((_DWORD *)this + 70) = 1065353216;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 19) = 0u;
  *((_OWORD *)this + 20) = 0u;
  *((_OWORD *)this + 21) = 0u;
  *((_OWORD *)this + 22) = 0u;
  *((_DWORD *)this + 92) = 0;
  *((void *)this + 47) = 0;
  *((void *)this + 48) = 0;
  *((unsigned char *)this + 392) = 0;
  *((void *)this + 50) = TFont::InitBaseFont(v12, v9);
  *((void *)this + 51) = 0;
  *((_DWORD *)this + 104) = 0;
  *(_OWORD *)((char *)this + 456) = 0u;
  *(_OWORD *)((char *)this + 472) = 0u;
  *((void *)this + 54) = 0;
  *((void *)this + 55) = 0;
  *((void *)this + 53) = 0;
  *((_DWORD *)this + 112) = 0;
  *((_DWORD *)this + 122) = 1065353216;
  *((void *)this + 62) = 0;
  *((_DWORD *)this + 126) = 0;
  *((void *)this + 64) = 0;
  *((unsigned char *)this + 520) = 0;
  *((void *)this + 66) = 0;
  *((void *)this + 68) = 0;
  *((void *)this + 67) = 0;
  TFont::SetExtras((atomic_ullong *)this, a5, 0);
  TFont::SetFlags((atomic_ullong *)this, 0, a5);
  TFont::SetOpticalSize(this, a5);
  TFont::AddFontSpecificFeatureSettings(this);
}

void TFont::SetOpticalSize(TFont *this, const __CTFontDescriptor *a2)
{
  uint64_t v2 = (atomic_ullong *)*((void *)this + 50);
  if (v2)
  {
    double valuePtr = 0.0;
    CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)this + 20, memory_order_acquire);
    if (explicit) {
      CFStringRef Value = (const __CFString *)CFDictionaryGetValue(explicit, @"NSCTFontOpticalSizeAttribute");
    }
    else {
      CFStringRef Value = 0;
    }
    int v7 = (*(uint64_t (**)(atomic_ullong *, uint64_t))(*v2 + 472))(v2, 1398030676);
    id v73 = 0;
    if (!v7) {
      goto LABEL_12;
    }
    uint64_t v8 = *((void *)this + 50);
    if ((*(_DWORD *)(v8 + 184) & 0x100) == 0) {
      TBaseFont::DetermineFontFlags(*((TBaseFont **)this + 50), 0x100u);
    }
    if ((*(_DWORD *)(v8 + 180) & 0x100) != 0)
    {
LABEL_12:
      char v9 = 0;
      BOOL v10 = 0;
      if (!Value) {
        goto LABEL_30;
      }
    }
    else if ((*(uint64_t (**)(void, uint64_t))(**((void **)this + 50) + 472))(*((void *)this + 50), 1953653099))
    {
      char v9 = 0;
      BOOL v10 = 1;
      if (!Value) {
        goto LABEL_30;
      }
    }
    else
    {
      (*(void (**)(id *__return_ptr, atomic_ullong *))(*v2 + 128))(&v75, v2);

      BOOL v10 = atomic_load_explicit((atomic_ullong *volatile)&v73, memory_order_acquire) != 0;
      char v9 = 1;
      if (!Value) {
        goto LABEL_30;
      }
    }
    CFTypeID v11 = CFGetTypeID(Value);
    if (v11 == CFNumberGetTypeID())
    {
      uint64_t v12 = a2;
      CFNumberGetValue((CFNumberRef)Value, kCFNumberDoubleType, &valuePtr);
      if (valuePtr <= 0.0) {
        goto LABEL_125;
      }
      goto LABEL_31;
    }
    if (v11 == CFStringGetTypeID())
    {
      if ((v9 & 1) == 0)
      {
        (*(void (**)(id *__return_ptr, atomic_ullong *))(*v2 + 128))(&v75, v2);
      }
      if (Value == @"auto" || CFStringCompare(Value, @"auto", 1uLL) == kCFCompareEqualTo)
      {
        uint64_t v12 = a2;
        int v15 = 0;
        double valuePtr = *((double *)this + 2);
        BOOL v16 = atomic_load_explicit((atomic_ullong *volatile)&v73, memory_order_acquire) != 0;
        int v13 = 1;
        goto LABEL_32;
      }
      uint64_t v12 = a2;
      if (Value == @"none" || CFStringCompare(Value, @"none", 1uLL) == kCFCompareEqualTo)
      {
        int v13 = 0;
        unint64_t v14 = atomic_load_explicit((atomic_ullong *volatile)&v73, memory_order_acquire);
        int v15 = v14 != 0;
        if (v14) {
          BOOL v16 = 1;
        }
        else {
          BOOL v16 = v10;
        }
        if (!v14 && v10)
        {
          BOOL v16 = 0;
          int v15 = 0;
          int v13 = 0;
          double valuePtr = 0.0;
        }
        goto LABEL_32;
      }
LABEL_31:
      int v15 = 0;
      int v13 = 0;
      BOOL v16 = v10;
LABEL_32:
      *((double *)this + 3) = valuePtr;
      if (TFont::IsSystemUIFontAndForShaping((atomic_ullong *)this, (BOOL *)&v75)) {
        int v17 = 1;
      }
      else {
        int v17 = (*(uint64_t (**)(void))(**((void **)this + 50) + 712))(*((void *)this + 50));
      }
      double v18 = *((double *)this + 3);
      if (v18 == 0.0) {
        int v19 = v15;
      }
      else {
        int v19 = 1;
      }
      BOOL v20 = v19 == 1 || (v16 | v17) == 0;
      int v21 = v13;
      if (!v20)
      {
        if (((v13 | v17) & 1) == 0
          && TBaseFont::GetInitializedGraphicsFont((TBaseFont *)v2)
          && CGFontGetParserFont()
          && (FPFontHasNamedInstanceWithOpticalSize() & 1) != 0)
        {
          goto LABEL_125;
        }
        double v18 = *((double *)this + 2);
        *((double *)this + 3) = v18;
        int v21 = 1;
      }
      if (((v18 == 0.0) & ~v15) != 0)
      {
LABEL_125:

        return;
      }
      if (!v16) {
        goto LABEL_58;
      }
      if ((v9 & 1) == 0)
      {
        int v22 = v21;
        (*(void (**)(id *__return_ptr, atomic_ullong *))(*v2 + 128))(&v75, v2);

        int v21 = v22;
      }
      if (!atomic_load_explicit((atomic_ullong *volatile)&v73, memory_order_acquire))
      {
LABEL_58:
        if ((v7 | v17)) {
          goto LABEL_125;
        }
        *(double *)&id v75 = NAN;
        *(double *)&id v72 = NAN;
        if (!(*(unsigned int (**)(atomic_ullong *, id *, id *))(*v2 + 424))(v2, &v75, &v72)) {
          goto LABEL_125;
        }
        double v27 = *((double *)this + 3);
        if (*(double *)&v75 <= v27 && (v27 < *(double *)&v72 || *(double *)&v72 == 0.0)) {
          goto LABEL_125;
        }
        uint64_t TraitsValues = atomic_load_explicit(v2 + 30, memory_order_acquire);
        if (!TraitsValues) {
          uint64_t TraitsValues = TBaseFont::CreateTraitsValues((TBaseFont *)v2);
        }
        long long v71 = (void *)0xAAAAAAAAAAAAAAAALL;
        (*(void (**)(void **__return_ptr))(**((void **)this + 50) + 72))(&v71);
        id v70 = (id)0xAAAAAAAAAAAAAAAALL;
        TDescriptorSource::TDescriptorSource((TDescriptorSource *)&v69);
        TDescriptorSource::CopyMatchingDescriptorsForFamily((TDescriptorSource *)&v69, (const __CFString *)atomic_load_explicit((atomic_ullong *volatile)&v71, memory_order_acquire), &v70);
        CFArrayRef v29 = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v70, memory_order_acquire);
        if (v29)
        {
          CFIndex Count = CFArrayGetCount(v29);
          if (Count)
          {
            CFIndex v31 = Count;
            CFIndex v32 = 0;
            while (1)
            {
              CFDictionaryRef ValueAtIndex = (TDescriptor **)CFArrayGetValueAtIndex(v29, v32);
              BOOL v34 = ValueAtIndex;
              __CFString v35 = ValueAtIndex[5];
              if ((*((_DWORD *)v35 + 4) & 0x80000000) == 0) {
                TDescriptor::InitBaseFont(ValueAtIndex[5], 0, 0.0);
              }
              unint64_t v36 = atomic_load_explicit((atomic_ullong *volatile)v35 + 4, memory_order_acquire);
              if (v36)
              {
                uint64_t v37 = atomic_load_explicit((atomic_ullong *volatile)(v36 + 240), memory_order_acquire);
                if (!v37) {
                  uint64_t v37 = TBaseFont::CreateTraitsValues((TBaseFont *)v36);
                }
                if (*(_DWORD *)v37 == *(_DWORD *)TraitsValues
                  && *(double *)(v37 + 8) == *(double *)(TraitsValues + 8)
                  && *(double *)(v37 + 16) == *(double *)(TraitsValues + 16)
                  && *(double *)(v37 + 24) == *(double *)(TraitsValues + 24))
                {
                  double v68 = NAN;
                  double v69 = NAN;
                  if ((*(unsigned int (**)(unint64_t, double *, double *))(*(void *)v36 + 424))(v36, &v69, &v68))
                  {
                    double v38 = *((double *)this + 3);
                    if (v69 <= v38 && v38 < v68) {
                      break;
                    }
                  }
                }
              }
              if (v31 == ++v32) {
                goto LABEL_77;
              }
            }
            id v67 = v34;

            long long v66 = (atomic_uint *)*((void *)this + 50);
            atomic_fetch_add_explicit((atomic_uint *volatile)(v36 + 8), 1u, memory_order_relaxed);
            *((void *)this + 50) = v36;
            if (v66 && atomic_fetch_add_explicit(v66 + 2, 0xFFFFFFFF, memory_order_release) == 1)
            {
              __dmb(9u);
              (*(void (**)(atomic_uint *))(*(void *)v66 + 8))(v66);
            }
          }
        }
LABEL_77:

        id v39 = v71;
        goto LABEL_124;
      }
      int v23 = v21;
      *(double *)&id v72 = -3.72066208e-103;
      (*(void (**)(id *__return_ptr))(**((void **)this + 50) + 112))(&v72);
      CFDictionaryRef v24 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)&v72, memory_order_acquire);
      CFDictionaryRef v25 = v24;
      if (v24) {
        CFNumberRef v26 = (const __CFNumber *)CFDictionaryGetValue(v24, &unk_1ED080850);
      }
      else {
        CFNumberRef v26 = 0;
      }

      if (!v12) {
        goto LABEL_88;
      }
      BOOL v40 = (atomic_ullong *)(*((void *)v12 + 5) + 8);
      atomic_load_explicit(v40, memory_order_acquire);
      CFDictionaryRef v41 = (const __CFDictionary *)atomic_load_explicit(v40, memory_order_acquire);
      if (!v41) {
        goto LABEL_88;
      }
      CFDictionaryRef v42 = (const __CFDictionary *)CFDictionaryGetValue(v41, @"NSCTFontVariationAttribute");
      CFDictionaryRef v43 = v42;
      if (!v42) {
        goto LABEL_89;
      }
      CFTypeID v44 = CFGetTypeID(v42);
      if (v44 == CFDictionaryGetTypeID())
      {
        CFDictionaryRef v45 = (const __CFDictionary *)CFDictionaryGetValue(v43, &unk_1ED080850);
        CFDictionaryRef v43 = v45;
        if (v45)
        {
          CFTypeID v46 = CFGetTypeID(v45);
          if (v46 == CFNumberGetTypeID()) {
            CFNumberRef v26 = v43;
          }
          else {
            CFDictionaryRef v43 = 0;
          }
        }
      }
      else
      {
LABEL_88:
        CFDictionaryRef v43 = 0;
      }
LABEL_89:
      CFNumberRef v47 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v73, memory_order_acquire), @"NSCTVariationAxisDefaultValue");
      *(double *)&id v75 = NAN;
      CFNumberGetValue(v47, kCFNumberDoubleType, &v75);
      id v48 = v75;
      if (v15)
      {
        *((double *)this + 3) = *(double *)&v75;
        double v49 = *(double *)&v48;
      }
      else
      {
        double v49 = *((double *)this + 3);
      }
      ClampValueToRangeOfAxis(v49, (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v73, memory_order_acquire));
      double v51 = v50;
      long long v71 = 0;
      if (v26)
      {
        *(double *)&id v75 = NAN;
        CFNumberGetValue(v26, kCFNumberDoubleType, &v75);
        if ((v13 & (v43 != 0)) != 0) {
          double v51 = *(double *)&v75;
        }
        if (vabdd_f64(*(double *)&v75, v51) < 0.0001
          || (v13 & 1) == 0 && !TFont::HasDerivedOpticalSize(this) && (v26 == v43 || v43 && CFEqual(v26, v43)))
        {
          goto LABEL_123;
        }
        uint64_t v52 = (uint64_t)v71;
      }
      else
      {
        if (v15)
        {
LABEL_123:
          id v39 = v72;
LABEL_124:

          goto LABEL_125;
        }
        if (*(double *)&v48 != v50)
        {
LABEL_103:
          long long v53 = (TDescriptor **)(id)atomic_load_explicit((atomic_ullong *volatile)this + 1, memory_order_acquire);
          long long v54 = v53;
          long long v55 = v53[5];
          if ((*((_DWORD *)v55 + 4) & 0x80000000) == 0) {
            TDescriptor::InitBaseFont(v53[5], 0, 0.0);
          }
          long long v56 = (const TBaseFont *)atomic_load_explicit((atomic_ullong *volatile)v55 + 4, memory_order_acquire);

          if (v56)
          {
            if (GetTenuousComponentFont(v56)) {
              operator new();
            }
            *(double *)&id v75 = -3.72066208e-103;
            CopyVariationWithValue((const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v72, memory_order_acquire), (const __CFNumber *)&unk_1ED080850, v51, &v75);
            operator new();
          }
          goto LABEL_123;
        }
        uint64_t v52 = *((void *)this + 50);
        long long v71 = (void *)v52;
      }
      if (v52)
      {
        long long v57 = (atomic_ullong *)((char *)this + 8);
        long long v58 = (id)atomic_load_explicit((atomic_ullong *volatile)this + 1, memory_order_acquire);
        int v59 = *(_DWORD *)(v58[5] + 16);

        if (v23) {
          int v60 = 0x8000;
        }
        else {
          int v60 = 0;
        }
        LODWORD(v70) = v59 & 0xFFFF7FFF | v60;
        TCFBase_NEW<CTFontDescriptor,TBaseFont const*&,unsigned int &>((uint64_t *)&v71, (int *)&v70, &v75);

        long long v61 = (atomic_uint *)*((void *)this + 50);
        long long v62 = (TDescriptor **)(id)atomic_load_explicit(v57, memory_order_acquire);
        long long v63 = v62;
        long long v64 = v62[5];
        if ((*((_DWORD *)v64 + 4) & 0x80000000) == 0) {
          TDescriptor::InitBaseFont(v62[5], 0, 0.0);
        }
        unint64_t v65 = atomic_load_explicit((atomic_ullong *volatile)v64 + 4, memory_order_acquire);
        if (v65) {
          atomic_fetch_add_explicit((atomic_uint *volatile)(v65 + 8), 1u, memory_order_relaxed);
        }
        *((void *)this + 50) = v65;

        if (v61 && atomic_fetch_add_explicit(v61 + 2, 0xFFFFFFFF, memory_order_release) == 1)
        {
          __dmb(9u);
          (*(void (**)(atomic_uint *))(*(void *)v61 + 8))(v61);
        }
        goto LABEL_123;
      }
      goto LABEL_103;
    }
LABEL_30:
    uint64_t v12 = a2;
    goto LABEL_31;
  }
}

void TTenuousComponentFont::CopyVariation(atomic_ullong *this@<X0>, TTenuousComponentFont *a2@<X8>)
{
  if ((this[89] & 4) != 0)
  {
    if (*((unsigned char *)this + 793))
    {
      id v10 = (id)0xAAAAAAAAAAAAAAAALL;
      TBaseFont::CopyAttributeInternal(this, @"NSCTFontVariationAttribute", &v9);
      id v10 = (id)atomic_exchange((atomic_ullong *volatile)&v9, 0);

      unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire);
      uint64_t v5 = (const void **)MEMORY[0x1E4F1D260];
      if (!explicit)
      {
        id v9 = (id)0xAAAAAAAAAAAAAAAALL;
        (*(void (**)(id *__return_ptr, atomic_ullong *))(*this + 120))(&v9, this);
        CreateValidVariation((const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire), (void *)atomic_load_explicit(this + 96, memory_order_acquire), (CFDictionaryRef *)&v8);

        if (atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire))
        {
          id v7 = (id)atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire);
          TBaseFont::SetAttributeInternal<TCFRef<__CFSet const*>>(this, (atomic_ullong *)&v7, @"NSCTFontVariationAttribute");
        }
        else
        {
          TBaseFont::SetAttributeInternal<__CFDictionary const*>(this, *v5, @"NSCTFontVariationAttribute");
        }
      }
      if (*v5 == (const void *)atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire)) {
        unint64_t v6 = 0;
      }
      else {
        unint64_t v6 = atomic_exchange((atomic_ullong *volatile)&v10, 0);
      }
      *(void *)a2 = v6;
    }
    else if (atomic_load_explicit(this + 96, memory_order_acquire))
    {
      *(void *)a2 = (id)atomic_load_explicit(this + 96, memory_order_acquire);
    }
    else
    {
      TTenuousComponentFont::CopyDefaultVariation(a2, (uint64_t)this);
    }
  }
  else
  {
    *(void *)a2 = 0;
  }
}

double TFont::InitSize(TFont *this, double a2, const __CTFontDescriptor *a3)
{
  double v3 = a2;
  double valuePtr = a2;
  if (a2 <= 0.0)
  {
    if (this)
    {
      CFNumberRef v4 = (const __CFNumber *)CTFontDescriptorCopyAttribute(this, @"NSFontSizeAttribute");
      if (v4)
      {
        CFNumberRef v5 = v4;
        CFTypeID v6 = CFGetTypeID(v4);
        if (v6 == CFNumberGetTypeID()) {
          CFNumberGetValue(v5, kCFNumberDoubleType, &valuePtr);
        }
        CFRelease(v5);
        double v3 = valuePtr;
      }
    }
    if (v3 <= 0.0)
    {
      Table = (double *)GetTable();
      double v3 = 12.0;
      if (Table)
      {
        uint64_t v8 = *((void *)Table + 10);
        if (v8)
        {
          if (v8 == -1) {
            return 0.0;
          }
          else {
            return Table[10];
          }
        }
      }
    }
  }
  return v3;
}

CFTypeRef CTFontDescriptorCopyAttribute(CTFontDescriptorRef descriptor, CFStringRef attribute)
{
  uint64_t v2 = 0;
  if (descriptor && attribute)
  {
    TDescriptor::CopyAttributeExternal(*((atomic_ullong **)descriptor + 5), attribute, (atomic_ullong *)&v4);
    uint64_t v2 = (const void *)atomic_exchange((atomic_ullong *volatile)&v4, 0);
  }
  return v2;
}

void TDescriptor::CopyAttributeExternal(atomic_ullong *this@<X0>, const __CFString *cf1@<X1>, atomic_ullong *a3@<X8>)
{
  atomic_load_explicit(this + 1, memory_order_acquire);
  CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit(this + 1, memory_order_acquire);
  if (explicit && (CFStringRef Value = (void *)CFDictionaryGetValue(explicit, cf1)) != 0)
  {
    *a3 = (atomic_ullong)Value;
  }
  else if (CFEqual(cf1, @"NSFontDescriptorHiddenAttribute") {
         || CFEqual(cf1, @"NSFontDescriptorNegativeAttribute")
  }
         || (FontAttributeID = (char *)GetFontAttributeID(cf1), (unint64_t)(FontAttributeID - 8) <= 0x3B)
         && ((1 << (FontAttributeID - 8)) & 0x80096100000727FLL) != 0)
  {
    *a3 = 0;
  }
  else
  {
    if ((this[2] & 0x80000000) == 0) {
      TDescriptor::InitBaseFont((TDescriptor *)this, 0, 0.0);
    }
    unint64_t v9 = atomic_load_explicit(this + 4, memory_order_acquire);
    if (v9)
    {
      id v10 = *(void (**)(void))(*(void *)v9 + 40);
      v10();
    }
    else
    {
      TDescriptor::CopyAttributeForNonNormalized(this, 0, (uint64_t)FontAttributeID, a3);
    }
  }
}

const void *GetFontAttributeID(const __CFString *key)
{
  if (qword_1EB2CE898 != -1) {
    dispatch_once_f(&qword_1EB2CE898, 0, (dispatch_function_t)GetFontAttributeID(__CFString const*)::$_0::__invoke);
  }
  CFDictionaryRef v2 = (const __CFDictionary *)_MergedGlobals_33;

  return CFDictionaryGetValue(v2, key);
}

unint64_t TFont::InitBaseFont(uint64_t a1, atomic_ullong *a2)
{
  if (!atomic_load_explicit(a2, memory_order_acquire)) {
    return 0;
  }
  double v3 = (TDescriptor **)(id)atomic_load_explicit(a2, memory_order_acquire);
  id v4 = v3;
  CFNumberRef v5 = v3[5];
  if ((*((_DWORD *)v5 + 4) & 0x80000000) == 0) {
    TDescriptor::InitBaseFont(v3[5], 0, 0.0);
  }
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)v5 + 4, memory_order_acquire);

  if (explicit)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(explicit + 8), 1u, memory_order_relaxed);
  }
  else
  {
    int v8 = *(_DWORD *)(*(void *)(atomic_load_explicit(a2, memory_order_acquire) + 40) + 16);
    BOOL v9 = (TDescriptor::GetSystemUIFontOptions(v7) & v8) != 0;
    id v15 = (id)0xAAAAAAAAAAAAAAAALL;
    TDescriptorSource::TDescriptorSource((TDescriptorSource *)&v14);
    TDescriptorSource::CreateDefaultDescriptor(v9, &v15);
    id v10 = (TDescriptor **)(id)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire);
    CFTypeID v11 = v10;
    uint64_t v12 = v10[5];
    if ((*((_DWORD *)v12 + 4) & 0x80000000) == 0) {
      TDescriptor::InitBaseFont(v10[5], 0, 0.0);
    }
    unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)v12 + 4, memory_order_acquire);
    if (explicit) {
      atomic_fetch_add_explicit((atomic_uint *volatile)(explicit + 8), 1u, memory_order_relaxed);
    }
  }
  return explicit;
}

void TFont::InitMatrix(TFont *this@<X0>, const CGAffineTransform *a2@<X1>, void *a3@<X8>)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (!this)
  {
    if (!a2) {
      goto LABEL_23;
    }
    BOOL v9 = (atomic_ullong *)(*(void *)&a2->ty + 8);
    atomic_load_explicit(v9, memory_order_acquire);
    CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit(v9, memory_order_acquire);
    if (explicit && (CFDataRef v11 = (const __CFData *)CFDictionaryGetValue(explicit, @"NSCTFontMatrixAttribute")) != 0)
    {
      CFDataRef v12 = v11;
      id v7 = operator new(0x30uLL, MEMORY[0x1E4FBA2D0]);
      if (!v7) {
        goto LABEL_24;
      }
      CFIndex Length = CFDataGetLength(v12);
      if (Length < 16)
      {
        double v18 = (_OWORD *)MEMORY[0x1E4F1DAB8];
        long long v19 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 32);
        *((_OWORD *)v7 + 1) = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
        *((_OWORD *)v7 + 2) = v19;
        *(_OWORD *)id v7 = *v18;
        float64x2_t v20 = *((float64x2_t *)v7 + 2);
LABEL_21:
        int64x2_t v22 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(*(float64x2_t *)v7, (float64x2_t)xmmword_184B895C0), (int8x16_t)vceqq_f64(*((float64x2_t *)v7 + 1), (float64x2_t)xmmword_184B87DE0)), (int8x16_t)vceqzq_f64(v20));
        if ((vandq_s8((int8x16_t)v22, (int8x16_t)vdupq_laneq_s64(v22, 1)).u64[0] & 0x8000000000000000) == 0) {
          goto LABEL_24;
        }
        MEMORY[0x1853275C0](v7, 0x1000C40EED21634);
LABEL_23:
        id v7 = 0;
        goto LABEL_24;
      }
      if ((unint64_t)Length < 0x19)
      {
        v23.i64[0] = -1;
        v23.i64[1] = -1;
        v27.CFIndex location = 0;
        v27.CFIndex length = 16;
        CFDataGetBytes(v12, v27, (UInt8 *)&v23);
        float64x2_t v21 = vcvt_hight_f64_f32(v23);
        *(float64x2_t *)id v7 = vcvtq_f64_f32(*(float32x2_t *)v23.f32);
        *((float64x2_t *)v7 + 1) = v21;
      }
      else
      {
        v14.i64[0] = -1;
        v14.i64[1] = -1;
        float32x4_t v23 = v14;
        float32x4_t v24 = v14;
        v26.CFIndex location = 0;
        v26.CFIndex length = 32;
        CFDataGetBytes(v12, v26, (UInt8 *)&v23);
        float32x4_t v15 = v24;
        *(float32x4_t *)id v7 = v23;
        *((float32x4_t *)v7 + 1) = v15;
      }
    }
    else
    {
      atomic_load_explicit(v9, memory_order_acquire);
      CFDictionaryRef v16 = (const __CFDictionary *)atomic_load_explicit(v9, memory_order_acquire);
      if (v16) {
        CFStringRef Value = (void *)CFDictionaryGetValue(v16, @"NSFontMatrixAttribute");
      }
      else {
        CFStringRef Value = 0;
      }
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0
        || strcmp((const char *)[Value objCType], "{CGAffineTransform=dddddd}"))
      {
        goto LABEL_23;
      }
      id v7 = operator new(0x30uLL, MEMORY[0x1E4FBA2D0]);
      if (!v7) {
        goto LABEL_24;
      }
      [Value getValue:v7];
    }
    *((void *)v7 + 4) = 0;
    *((void *)v7 + 5) = 0;
    float64x2_t v20 = 0uLL;
    goto LABEL_21;
  }
  CFTypeID v6 = operator new(0x30uLL, MEMORY[0x1E4FBA2D0]);
  id v7 = v6;
  if (v6)
  {
    long long v8 = *((_OWORD *)this + 1);
    *CFTypeID v6 = *(_OWORD *)this;
    v6[1] = v8;
    *((void *)v6 + 4) = 0;
    *((void *)v6 + 5) = 0;
  }
LABEL_24:
  *a3 = v7;
}

void TFont::AddFontSpecificFeatureSettings(TFont *this)
{
  uint64_t v2 = *((void *)this + 50);
  if (v2
    && (*(unsigned int (**)(uint64_t))(*(void *)v2 + 712))(v2)
    && IsGB18030ComplianceRequired())
  {
    double v3 = this;
    uint64_t v4 = 444;
    uint64_t v5 = 1;
    int v6 = 1;
  }
  else
  {
    if ((*(unsigned char *)this & 4) == 0) {
      return;
    }
    double v3 = this;
    uint64_t v4 = 35;
    uint64_t v5 = 14;
    int v6 = 0;
  }

  TFont::AppendFeatureSettingWithTypeAndSelector((uint64_t)v3, v4, v5, v6);
}

void TFont::SetExtras(atomic_ullong *this, const __CTFontDescriptor *a2, const __CFArray *a3)
{
  if (a2 && (a3 || (*(_DWORD *)this & 8) == 0))
  {
    CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    v33[0] = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    id v7 = (void *)atomic_exchange((atomic_ullong *volatile)v33, 0);

    if (!v7)
    {
LABEL_51:

      return;
    }
    uint64_t v8 = *((void *)a2 + 5);
    char v9 = CopyAttributeToExtras(v8, (__CFDictionary *)v7, @"NSCTFontOpticalSizeAttribute", 3);
    CFArrayRef Value = a3;
    if (a3
      || (atomic_load_explicit((atomic_ullong *volatile)(v8 + 8), memory_order_acquire),
          (CFDictionaryRef v22 = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)(v8 + 8), memory_order_acquire)) != 0)
      && (CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(v22, @"NSCTFontFeatureSettingsAttribute")) != 0)
    {
      id v32 = (id)0xAAAAAAAAAAAAAAAALL;
      CreateFeatureSettingsByConverting(Value, &v32);
      if (atomic_load_explicit((atomic_ullong *volatile)&v32, memory_order_acquire))
      {
        TFont::UpdateFeatureSettings((uint64_t)this, (__CFDictionary *)v7, (id)atomic_load_explicit((atomic_ullong *volatile)&v32, memory_order_acquire), 0);
        *(_DWORD *)this &= ~8u;
        if (!a3)
        {
          if (TFont::IsSystemUIFontAndForShaping(this, (BOOL *)v33))
          {
            CFArrayRef explicit = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v32, memory_order_acquire);
            v33[0] = 0;
            v33[1] = 0;
            if (explicit)
            {
              id Mutable = CFSetCreateMutable(v6, 0, MEMORY[0x1E4F1D548]);
              CFIndex Count = CFArrayGetCount(explicit);
              if (Count)
              {
                CFIndex v14 = Count;
                for (CFIndex i = 0; i != v14; ++i)
                {
                  CFDictionaryRef ValueAtIndex = (CTFeatureSetting *)CFArrayGetValueAtIndex(explicit, i);
                  if ((IsFontSpecificFeatureSetting(ValueAtIndex) & 1) == 0
                    && !CFSetContainsValue(Mutable, ValueAtIndex))
                  {
                    TCFLazyMutableArray::LazyCreate((TCFLazyMutableArray *)v33);
                    CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)v33, memory_order_acquire), ValueAtIndex);
                    CFSetAddValue(Mutable, ValueAtIndex);
                  }
                }
              }
            }
            id v31 = (id)atomic_exchange((atomic_ullong *volatile)v33, 0);

            int v17 = (void *)atomic_exchange((atomic_ullong *volatile)&v31, 0);
            if (v17) {
              CFDictionaryAddValue((CFMutableDictionaryRef)v7, @"CTFontOriginalFeatureSettingsAttribute", v17);
            }
          }
        }
      }
    }
    double v18 = this + 1;
    if (atomic_load_explicit(this + 1, memory_order_acquire))
    {
      long long v19 = (uint64_t *)(id)atomic_load_explicit(v18, memory_order_acquire);
      *((unsigned char *)this + 392) = CopyAttributeToExtras(v19[5], (__CFDictionary *)v7, @"NSCTFontFixedAdvanceAttribute", 2);

      float64x2_t v20 = (uint64_t *)(id)atomic_load_explicit(v18, memory_order_acquire);
      char v21 = CopyAttributeToExtras(v20[5], (__CFDictionary *)v7, @"CTFontEmojiMLUpscalingTimeoutAttribute", 2);
    }
    else
    {
      char v21 = 0;
    }
    if ((const __CTFontDescriptor *)atomic_load_explicit(v18, memory_order_acquire) == a2)
    {
LABEL_49:
      if (CFDictionaryGetCount((CFDictionaryRef)v7))
      {
        id v30 = v7;
        TCFRef<__CTFont const*>::Retain(this + 20, v30);
      }
      goto LABEL_51;
    }
    atomic_load_explicit((atomic_ullong *volatile)(v8 + 8), memory_order_acquire);
    CFDictionaryRef v23 = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)(v8 + 8), memory_order_acquire);
    if (v23) {
      CFDictionaryRef v23 = (const __CFDictionary *)CFDictionaryGetValue(v23, @"NSCTFontCascadeListAttribute");
    }
    CFDictionaryRef v24 = v23;
    if (v24 && atomic_load_explicit(this + 1, memory_order_acquire))
    {
      uint64_t v25 = (id)atomic_load_explicit(this + 1, memory_order_acquire);
      CFRange v26 = (atomic_ullong *)(v25[5] + 8);
      atomic_load_explicit(v26, memory_order_acquire);
      CFDictionaryRef v27 = (const __CFDictionary *)atomic_load_explicit(v26, memory_order_acquire);
      if (v27) {
        CFDictionaryRef v27 = (const __CFDictionary *)CFDictionaryGetValue(v27, @"NSCTFontCascadeListAttribute");
      }
      CFDictionaryRef v28 = v27;

      if (v28 != v24 && (!v28 || !CFEqual(v28, v24))) {
        CFDictionarySetValue((CFMutableDictionaryRef)v7, @"NSCTFontCascadeListAttribute", v24);
      }
    }
    CopyAttributeToExtras(v8, (__CFDictionary *)v7, @"NSCTFontBaselineAdjustAttribute", 2);
    if (*((unsigned char *)this + 392))
    {
      if (v9) {
        goto LABEL_45;
      }
    }
    else
    {
      *((unsigned char *)this + 392) = CopyAttributeToExtras(v8, (__CFDictionary *)v7, @"NSCTFontFixedAdvanceAttribute", 2);
      if (v9)
      {
LABEL_45:
        CopyAttributeToExtras(v8, (__CFDictionary *)v7, @"NSCTFontTrackAttribute", 2);
LABEL_46:
        CopyAttributeToExtras(v8, (__CFDictionary *)v7, @"NSCTFontUnscaledTrackingAttribute", 2);
        CopyAttributeToExtras(v8, (__CFDictionary *)v7, @"CTFontPaletteAttribute", 2);
        CopyAttributeToExtras(v8, (__CFDictionary *)v7, @"CTFontPaletteColorsAttribute", 0);
        CopyAttributeToExtras(v8, (__CFDictionary *)v7, @"CTFontDescriptorLanguageAttribute", 4);
        CopyAttributeToExtras(v8, (__CFDictionary *)v7, @"NSCTFontVariationAttribute", 0);
        if ((v21 & 1) == 0) {
          CopyAttributeToExtras(v8, (__CFDictionary *)v7, @"CTFontEmojiMLUpscalingTimeoutAttribute", 2);
        }

        goto LABEL_49;
      }
    }
    atomic_ullong v29 = this[50];
    if (!v29 || !(*(unsigned int (**)(atomic_ullong))(*(void *)v29 + 840))(v29)) {
      goto LABEL_46;
    }
    goto LABEL_45;
  }
}

unint64_t CopyAttributeToExtras(uint64_t a1, __CFDictionary *a2, void *key, int a4)
{
  atomic_load_explicit((atomic_ullong *volatile)(a1 + 8), memory_order_acquire);
  unint64_t result = atomic_load_explicit((atomic_ullong *volatile)(a1 + 8), memory_order_acquire);
  if (result)
  {
    unint64_t result = (unint64_t)CFDictionaryGetValue((CFDictionaryRef)result, key);
    if (result)
    {
      uint64_t v8 = (__CFString *)result;
      CFTypeID v9 = CFGetTypeID((CFTypeRef)result);
      switch(a4)
      {
        case 0:
          CFTypeID TypeID = CFDictionaryGetTypeID();
          goto LABEL_15;
        case 1:
          CFTypeID TypeID = CFNullGetTypeID();
          goto LABEL_15;
        case 2:
          CFTypeID TypeID = CFNumberGetTypeID();
          goto LABEL_15;
        case 3:
          if (CFNumberGetTypeID() != v9)
          {
            if (CFStringGetTypeID() != v9) {
              goto LABEL_13;
            }
            if (v8 != @"auto")
            {
              CFComparisonResult v11 = CFStringCompare(v8, @"auto", 1uLL);
              if (v8 != @"none" && v11 && CFStringCompare(v8, @"none", 1uLL)) {
                goto LABEL_13;
              }
            }
          }
          goto LABEL_16;
        case 4:
          CFTypeID TypeID = CFStringGetTypeID();
LABEL_15:
          if (v9 == TypeID) {
            goto LABEL_16;
          }
LABEL_13:
          unint64_t result = 0;
          break;
        default:
LABEL_16:
          CFDictionarySetValue(a2, key, v8);
          unint64_t result = 1;
          break;
      }
    }
  }
  return result;
}

void TFont::SetFlags(atomic_ullong *this, int a2, const __CTFontDescriptor *a3)
{
  if (a3)
  {
    uint64_t v6 = *((void *)a3 + 5);
    atomic_load_explicit((atomic_ullong *volatile)(v6 + 8), memory_order_acquire);
    CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)(v6 + 8), memory_order_acquire);
    if (explicit
      && (CFNumberRef v8 = (const __CFNumber *)CFDictionaryGetValue(explicit, @"NSCTFontOrientationAttribute")) != 0
      && (CFNumberRef v9 = v8, v10 = CFGetTypeID(v8), v10 == CFNumberGetTypeID()))
    {
      LODWORD(v41[0]) = -1431655766;
      CFNumberGetValue(v9, kCFNumberIntType, v41);
      if (LODWORD(v41[0]) == 1)
      {
        a2 &= ~1u;
      }
      else if (LODWORD(v41[0]) == 2)
      {
        a2 |= 1u;
      }
    }
    else
    {
      TDescriptor::CopyAttributes(*((atomic_ullong **)a3 + 5), v41);
      CFComparisonResult v11 = (void *)atomic_exchange((atomic_ullong *volatile)v41, 0);

      CFDictionaryRef v12 = v11;
      CFDictionaryRef v13 = v12;
      if (v12) {
        CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v12, @"NSCTFontTraitsAttribute");
      }
      else {
        CFDictionaryRef Value = 0;
      }

      a2 |= (GetSymbolicTraitsFromTraits(Value) >> 11) & 1;
    }
    CFDictionaryRef v16 = (atomic_ullong *)(v6 + 8);
    atomic_load_explicit((atomic_ullong *volatile)(v6 + 8), memory_order_acquire);
    CFDictionaryRef v17 = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)(v6 + 8), memory_order_acquire);
    if (v17)
    {
      CFBooleanRef v18 = (const __CFBoolean *)CFDictionaryGetValue(v17, @"CTFontCacheGlyphImagesAttribute");
      if (v18)
      {
        CFBooleanRef v19 = v18;
        CFTypeID v20 = CFGetTypeID(v18);
        if (v20 == CFBooleanGetTypeID() && !CFBooleanGetValue(v19)) {
          a2 |= 2u;
        }
      }
    }
    atomic_load_explicit(v16, memory_order_acquire);
    CFDictionaryRef v21 = (const __CFDictionary *)atomic_load_explicit(v16, memory_order_acquire);
    if (v21)
    {
      CFNumberRef v22 = (const __CFNumber *)CFDictionaryGetValue(v21, @"CTFontDisableColorBitmapSizeModAttribute");
      if (v22)
      {
        CFNumberRef v23 = v22;
        IntCFDictionaryRef Value = -1431655766;
        LODWORD(v41[0]) = -1431655766;
        CFTypeID v25 = CFGetTypeID(v22);
        if (v25 == CFNumberGetTypeID() || v25 == CFBooleanGetTypeID())
        {
          CFNumberGetValue(v23, kCFNumberIntType, v41);
          char v26 = 1;
          IntCFDictionaryRef Value = (SInt32)v41[0];
        }
        else if (v25 == CFStringGetTypeID())
        {
          IntCFDictionaryRef Value = CFStringGetIntValue((CFStringRef)v23);
          char v26 = 1;
        }
        else
        {
          char v26 = 0;
        }
        if ((v26 & (IntValue != 0)) != 0) {
          a2 |= 0x10u;
        }
      }
    }
    CFDictionaryRef v27 = (atomic_ullong *)(v6 + 8);
    atomic_load_explicit((atomic_ullong *volatile)(v6 + 8), memory_order_acquire);
    CFDictionaryRef v28 = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)(v6 + 8), memory_order_acquire);
    if (v28)
    {
      CFArrayRef v29 = (const __CFArray *)CFDictionaryGetValue(v28, @"NSCTFontFeatureSettingsAttribute");
      if (v29)
      {
        id v45 = (id)0xAAAAAAAAAAAAAAAALL;
        CreateFeatureSettingsByConverting(v29, &v45);
        if (atomic_load_explicit((atomic_ullong *volatile)&v45, memory_order_acquire))
        {
          long long v42 = xmmword_184B8A330;
          memset(v43, 170, sizeof(v43));
          unint64_t v44 = 0xAAAAAAAAFFFFFFFFLL;
          memset(v41, 170, sizeof(v41));
          TFontFeatureSettingList::TFontFeatureSettingList((TFontFeatureSettingList *)v41, (id)atomic_load_explicit((atomic_ullong *volatile)&v45, memory_order_acquire));
          if (TFont::ShouldPropagateFeatureSetting(this, (const TFontFeatureSettingList *)v41)) {
            a2 |= 4u;
          }
          std::__hash_table<std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>>>::~__hash_table((uint64_t)v43);
          std::__hash_table<std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>>>::~__hash_table((uint64_t)&v41[5]);
          std::__tree<std::__value_type<long,TAATDeltaYListEntry>,std::__map_value_compare<long,std::__value_type<long,TAATDeltaYListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TAATDeltaYListEntry>>>::destroy((uint64_t)&v41[1], (void *)v41[2]);
        }
      }
    }
    atomic_load_explicit(v27, memory_order_acquire);
    CFDictionaryRef v30 = (const __CFDictionary *)atomic_load_explicit(v27, memory_order_acquire);
    if (v30
      && (CFNumberRef v31 = (const __CFNumber *)CFDictionaryGetValue(v30, @"NSCTFontFallbackOptionAttribute")) != 0
      && (CFNumberRef v32 = v31, v33 = CFGetTypeID(v31), v33 == CFNumberGetTypeID()))
    {
      v41[0] = (id)0xAAAAAAAAAAAAAAAALL;
      CFNumberGetValue(v32, kCFNumberLongType, v41);
      int v15 = (int)v41[0];
    }
    else
    {
      int v15 = 3;
    }
    atomic_load_explicit((atomic_ullong *volatile)(v6 + 8), memory_order_acquire);
    CFDictionaryRef v34 = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)(v6 + 8), memory_order_acquire);
    if (v34)
    {
      __CFString v35 = (__CFString *)CFDictionaryGetValue(v34, @"CTFontDescriptorLanguageAttribute");
      if (v35)
      {
        unint64_t v36 = v35;
        CFTypeID v37 = CFGetTypeID(v35);
        if (v37 == CFStringGetTypeID())
        {
          v41[0] = (id)0xAAAAAAAAAAAAAAAALL;
          LanguageIdentifierByNormalizing(v36, 0, (atomic_ullong *)v41);
          double v38 = (__CFString *)(id)atomic_load_explicit((atomic_ullong *volatile)v41, memory_order_acquire);
          if (v38 == @"zh-")
          {
          }
          else
          {
            id v39 = v38;
            if (!v38)
            {

              goto LABEL_50;
            }
            int HasPrefix = CFStringHasPrefix(v38, @"zh-");

            if (!HasPrefix) {
              goto LABEL_50;
            }
          }
          a2 |= 0x20u;
LABEL_50:
        }
      }
    }
  }
  else
  {
    int v15 = 3;
  }
  *(_DWORD *)this = a2 | (v15 << 6);
}

void TFont::InitDescriptor(TFont *this@<X0>, atomic_ullong *a2@<X8>)
{
  *a2 = (atomic_ullong)this;
  if (!this)
  {
    TDescriptorSource::TDescriptorSource((TDescriptorSource *)&v5);
    TDescriptorSource::CreateDefaultDescriptor(0, &v6);
  }
}

CFDictionaryRef ClampValueToRangeOfAxis(double a1, const __CFDictionary *result)
{
  if (result)
  {
    CFDictionaryRef v2 = result;
    double v3 = trunc(a1 * 10000.0) / 10000.0;
    double v4 = NAN;
    unint64_t result = (const __CFDictionary *)CompareValueWithValueInAxisForKey(v3, result, @"NSCTVariationAxisMinimumValue", &v4);
    if (result != (const __CFDictionary *)-1) {
      return (const __CFDictionary *)CompareValueWithValueInAxisForKey(v3, v2, @"NSCTVariationAxisMaximumValue", &v4);
    }
  }
  return result;
}

CFComparisonResult CompareValueWithValueInAxisForKey(double a1, const __CFDictionary *a2, const __CFString *a3, double *a4)
{
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a2, a3);
  CFNumberRef v7 = Value;
  if (a4)
  {
    uint64_t valuePtr = -1;
    CFNumberGetValue(Value, kCFNumberDoubleType, &valuePtr);
    *(void *)a4 = valuePtr;
  }
  return CFNumberCompare((CFNumberRef)[NSNumber numberWithDouble:a1], v7, 0);
}

void TBaseFont::DetermineFontFlags(TBaseFont *this, unsigned int a2)
{
  unsigned int v2 = a2;
  CFStringRef explicit = (const __CFString *)atomic_load_explicit((atomic_ullong *volatile)this + 12, memory_order_acquire);
  if ((a2 & 0x3D2) != 0)
  {
    if (explicit == @"LastResort") {
      goto LABEL_5;
    }
    if (!explicit)
    {
      int v5 = 0;
      if (!IsSystemFontPostScriptName(0)) {
        goto LABEL_18;
      }
      goto LABEL_16;
    }
    if (CFEqual(explicit, @"LastResort"))
    {
LABEL_5:
      v2 |= 8u;
      int v5 = 10;
    }
    else
    {
      int v5 = 0;
    }
    if ((IsSystemFontPostScriptName(explicit) & 1) == 0)
    {
      if (explicit
        && (CFStringHasPrefix(explicit, @"Batang")
         || CFStringHasPrefix(explicit, @"Dotum")
         || CFStringHasPrefix(explicit, @"Gulim")
         || CFStringHasPrefix(explicit, @"Gungsuh")))
      {
        v5 |= 0x80u;
      }
      goto LABEL_18;
    }
LABEL_16:
    v5 |= HIBYTE(*((_DWORD *)this + 45)) & 0x10;
    if (IsPingFangPostScriptName(explicit)) {
      v5 |= 0x100u;
    }
LABEL_18:
    CFNumberRef v7 = _CTGetEmojiFontName(1);
    if (v7 == explicit || explicit && v7 && CFEqual(explicit, v7))
    {
      int v8 = 576;
    }
    else
    {
      CFNumberRef v9 = _CTGetEmojiFontName(0);
      if (v9 != explicit && (!explicit || !v9 || !CFEqual(explicit, v9))) {
        goto LABEL_29;
      }
      int v8 = 64;
    }
    v5 |= v8;
LABEL_29:
    if ((v5 & 0x240) != 0) {
      unsigned int v6 = v5 | 0x10;
    }
    else {
      unsigned int v6 = v5;
    }
    v2 |= 0x3D2u;
    if ((v2 & 8) == 0) {
      goto LABEL_42;
    }
    goto LABEL_33;
  }
  unsigned int v6 = 0;
  if ((a2 & 8) == 0) {
    goto LABEL_42;
  }
LABEL_33:
  if (!explicit
    || !CFStringGetLength(explicit)
    || CFStringGetCharacterAtIndex(explicit, 0) == 46
    || IsInvisibleSystemFontName(explicit)
    || IsInvisibleSystemFontPostScriptNameWithoutPrecedingPeriod(explicit))
  {
    v6 |= 8u;
    if ((v6 & 8) != 0) {
      goto LABEL_42;
    }
    goto LABEL_39;
  }
  id v14 = (id)0xAAAAAAAAAAAAAAAALL;
  TBaseFont::CopyMetadata(this, 0, &v14);
  CFDictionaryRef v10 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)&v14, memory_order_acquire);
  if (v10)
  {
    CFDictionaryRef v11 = v10;
    CFNumberRef Value = CFDictionaryGetValue(v10, @"MTD_Typeface_info_PlatformDelivery");

    if (Value)
    {
      CFTypeID v13 = CFGetTypeID(Value);
      if (v13 == CFArrayGetTypeID())
      {
        v15.CFIndex length = CFArrayGetCount((CFArrayRef)Value);
        v15.CFIndex location = 0;
        if (CFArrayContainsValue((CFArrayRef)Value, v15, @"iOS-invisible")) {
          v6 |= 8u;
        }
      }
    }
  }
  else
  {
  }
  if ((v6 & 8) == 0)
  {
LABEL_39:
    id v14 = (id)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(id *__return_ptr, TBaseFont *))(*(void *)this + 200))(&v14, this);
    atomic_load_explicit((atomic_ullong *volatile)&v14, memory_order_acquire);
    if (FSFontIsHidden()) {
      v6 |= 8u;
    }
  }
LABEL_42:
  if ((v2 & 0x400) != 0 && (*(unsigned int (**)(TBaseFont *))(*(void *)this + 760))(this) == 2) {
    v6 |= 0x400u;
  }
  atomic_fetch_or_explicit((atomic_uint *volatile)this + 45, v6, memory_order_relaxed);
  atomic_fetch_or_explicit((atomic_uint *volatile)this + 46, v2, memory_order_relaxed);
}

__CFString *_CTGetEmojiFontName(int a1)
{
  if (a1) {
    return @".AppleColorEmojiUI";
  }
  else {
    return @"AppleColorEmoji";
  }
}

void TTenuousComponentFont::CopyDefaultVariation(TTenuousComponentFont *this, uint64_t a2)
{
  if ((*(unsigned char *)(a2 + 712) & 4) != 0)
  {
    CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)(a2 + 720), memory_order_acquire);
    if (explicit && (CFNumberRef Value = (void *)CFDictionaryGetValue(explicit, @"variations")) != 0)
    {
      id v6 = Value;
      *(void *)this = atomic_exchange((atomic_ullong *volatile)&v6, 0);
    }
    else
    {
      TBaseFont::CopyVariation((atomic_ullong *)a2, (unint64_t *)this);
    }
  }
  else
  {
    *(void *)this = 0;
  }
}

BOOL IsSystemFontPath(CFStringRef theString)
{
  if (qword_1EB2CE470 != -1) {
    dispatch_once_f(&qword_1EB2CE470, 0, (dispatch_function_t)GetSystemLibraryFontsPath(void)::$_0::__invoke);
  }
  if ((CFStringRef)qword_1EB2CE478 == theString
    || theString && qword_1EB2CE478 && CFStringHasPrefix(theString, (CFStringRef)qword_1EB2CE478))
  {
    return 1;
  }
  if (qword_1EB2CE480 != -1) {
    dispatch_once_f(&qword_1EB2CE480, 0, (dispatch_function_t)GetSystemLibraryPrivateFontsPath(void)::$_0::__invoke);
  }
  if ((CFStringRef)qword_1EB2CE488 == theString) {
    return 1;
  }
  BOOL result = 0;
  if (theString)
  {
    if (qword_1EB2CE488) {
      return CFStringHasPrefix(theString, (CFStringRef)qword_1EB2CE488) != 0;
    }
  }
  return result;
}

CFStringRef IsSystemFontPostScriptName(const __CFString *result)
{
  if (result)
  {
    CFStringRef v1 = result;
    if (FontServicesLibraryCore(0)
      && getFSFontIsOverriddenSystemFontNameSymbolLoc()
      && (SoftLinked__FSFontIsOverriddenSystemFontName(v1) & 1) != 0)
    {
      return 0;
    }
    else
    {
      if (qword_1EB2CE8B8 != -1) {
        dispatch_once(&qword_1EB2CE8B8, &__block_literal_global_20);
      }
      BOOL result = (const __CFString *)qword_1EB2CE8B0;
      if (qword_1EB2CE8B0) {
        return (const __CFString *)(CFDictionaryContainsKey((CFDictionaryRef)qword_1EB2CE8B0, v1) != 0);
      }
    }
  }
  return result;
}

const __CFString *CopyAttributeForSystemFont@<X0>(const __CFString *result@<X0>, const __CFString *a2@<X1>, const __CFString **a3@<X8>)
{
  if (result)
  {
    CFStringRef v5 = result;
    if (FontServicesLibraryCore(0)
      && getFSFontIsOverriddenSystemFontNameSymbolLoc()
      && (SoftLinked__FSFontIsOverriddenSystemFontName(v5) & 1) != 0)
    {
      BOOL result = 0;
    }
    else
    {
      if (qword_1EB2CE8E8 != -1) {
        dispatch_once(&qword_1EB2CE8E8, &__block_literal_global_107);
      }
      CFDictionaryRef Value = (const __CFDictionary *)qword_1EB2CE8E0;
      if (qword_1EB2CE8E0)
      {
        CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)qword_1EB2CE8E0, @"Attrs");
        if (Value)
        {
          CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(Value, v5);
          if (Value) {
            CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(Value, a2);
          }
        }
      }
      BOOL result = Value;
    }
  }
  *a3 = result;
  return result;
}

uint64_t FontServicesLibraryCore(char **a1)
{
  if (!FontServicesLibraryCore(char **)::frameworkLibrary) {
    FontServicesLibraryCore(char **)::frameworkLibrary = _sl_dlopen();
  }
  return FontServicesLibraryCore(char **)::frameworkLibrary;
}

uint64_t SoftLinked__FSFontIsOverriddenSystemFontName(const __CFString *a1)
{
  IsOverriddenSystemFontNameSymbolLoc = (uint64_t (*)(const __CFString *))getFSFontIsOverriddenSystemFontNameSymbolLoc();
  if (IsOverriddenSystemFontNameSymbolLoc)
  {
    return IsOverriddenSystemFontNameSymbolLoc(a1);
  }
  else
  {
    double v4 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    uint64_t result = objc_msgSend(v4, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "BOOL SoftLinked__FSFontIsOverriddenSystemFontName(CFStringRef)"), @"MetadataSupport.cpp", 27, @"%s", dlerror());
    __break(1u);
  }
  return result;
}

uint64_t getFSFontIsOverriddenSystemFontNameSymbolLoc(void)
{
  uint64_t v3 = 0;
  double v4 = &v3;
  uint64_t v5 = 0x2020000000;
  uint64_t v0 = getFSFontIsOverriddenSystemFontNameSymbolLoc(void)::ptr;
  uint64_t v6 = getFSFontIsOverriddenSystemFontNameSymbolLoc(void)::ptr;
  if (!getFSFontIsOverriddenSystemFontNameSymbolLoc(void)::ptr)
  {
    v2[0] = MEMORY[0x1E4F143A8];
    v2[1] = 3221225472;
    v2[2] = ___ZL44getFSFontIsOverriddenSystemFontNameSymbolLocv_block_invoke;
    double v2[3] = &unk_1E528A348;
    v2[4] = &v3;
    ___ZL44getFSFontIsOverriddenSystemFontNameSymbolLocv_block_invoke(v2);
    uint64_t v0 = v4[3];
  }
  _Block_object_dispose(&v3, 8);
  return v0;
}

BOOL TSplicedFontDict::IsSystemUISplice(atomic_ullong *this)
{
  CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit(this, memory_order_acquire);
  if (explicit)
  {
    CFDictionaryRef Value = CFDictionaryGetValue(explicit, @"NSCTFontUIFontDesignTrait");
    if (Value)
    {
      int HasPrefix = CFEqual(Value, @"NSCTFontUIFontDesignDefault");
      return HasPrefix != 0;
    }
  }
  uint64_t v5 = 1;
  FontName = (__CFString *)TSplicedFontDict::FindFontName(this, 1, 0);
  if (FontName != @".AppleSystemUIFont")
  {
    if (!FontName) {
      return 0;
    }
    int HasPrefix = CFStringHasPrefix(FontName, @".AppleSystemUIFont");
    return HasPrefix != 0;
  }
  return v5;
}

void CopyVariationWithValue(const __CFDictionary *a1@<X0>, const __CFNumber *a2@<X1>, double a3@<D0>, void *a4@<X8>)
{
  v10[1] = *MEMORY[0x1E4F143B8];
  if (a1 && CFDictionaryGetCount(a1))
  {
    MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, a1);
    CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&MutableCopy, memory_order_acquire), a2, (const void *)[NSNumber numberWithDouble:a3]);
    *a4 = atomic_exchange((atomic_ullong *volatile)&MutableCopy, 0);
  }
  else
  {
    CFNumberRef v9 = a2;
    v10[0] = [NSNumber numberWithDouble:a3];
    *a4 = (id)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v10 forKeys:&v9 count:1];
  }
}

BOOL IsPingFangPostScriptName(CFStringRef theString)
{
  if (theString == @".PingFang") {
    return 1;
  }
  if (!theString) {
    return 0;
  }
  int HasPrefix = CFStringHasPrefix(theString, @".PingFang");
  BOOL result = 1;
  if (theString != @"PingFang" && !HasPrefix) {
    return CFStringHasPrefix(theString, @"PingFang") != 0;
  }
  return result;
}

const __CFDictionary *TSplicedFontDict::ComponentHasVariations(atomic_ullong *this)
{
  CFDictionaryRef result = (const __CFDictionary *)atomic_load_explicit(this, memory_order_acquire);
  if (result)
  {
    CFDictionaryRef result = (const __CFDictionary *)CFDictionaryGetValue(result, @"hasVariations");
    if (result) {
      return (const __CFDictionary *)(CFBooleanGetValue(result) != 0);
    }
  }
  return result;
}

const __CFDictionary *TSplicedFontDict::IsTextStyle(atomic_ullong *this)
{
  CFDictionaryRef result = (const __CFDictionary *)atomic_load_explicit(this, memory_order_acquire);
  if (result)
  {
    CFDictionaryRef result = (const __CFDictionary *)CFDictionaryGetValue(result, @"isTextStyle");
    if (result) {
      return (const __CFDictionary *)(CFBooleanGetValue(result) != 0);
    }
  }
  return result;
}

const __CFDictionary *TSplicedFontDict::ComponentHasOpticalSizeAxis(atomic_ullong *this)
{
  CFDictionaryRef result = (const __CFDictionary *)atomic_load_explicit(this, memory_order_acquire);
  if (result)
  {
    CFDictionaryRef result = (const __CFDictionary *)CFDictionaryGetValue(result, @"hasOpticalSizeAxis");
    if (result) {
      return (const __CFDictionary *)(CFBooleanGetValue(result) != 0);
    }
  }
  return result;
}

void CreateFeatureSettingsByConverting(const __CFArray *a1@<X0>, void *a2@<X8>)
{
  if (a1 && (uint64_t v4 = CFArrayGetCount(a1), v4 > 0))
  {
    id Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v4, MEMORY[0x1E4F1D510]);
    if (Mutable
      && (unint64_t v6 = 0x1EB2CD000uLL,
          objc_opt_class(),
          CFTypeID TypeID = CFArrayGetTypeID(),
          CFTypeID v8 = CFDictionaryGetTypeID(),
          CFTypeID v33 = CFNumberGetTypeID(),
          CFTypeID v34 = TypeID,
          CFGetTypeID(a1) == TypeID))
    {
      CFNumberRef v31 = a2;
      CFIndex Count = CFArrayGetCount(a1);
      if (Count)
      {
        CFIndex v10 = Count;
        CFIndex v11 = 0;
        CFTypeID v32 = v8;
        do
        {
          CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(a1, v11);
          if (objc_opt_isKindOfClass())
          {
            CFArrayAppendValue(Mutable, ValueAtIndex);
          }
          else
          {
            CFTypeID v13 = CFGetTypeID(ValueAtIndex);
            if (v13 == v8)
            {
              id v14 = (void *)[objc_alloc((Class)(v6 + 1184)) initWithDictionary:ValueAtIndex];
              CFRange v15 = v14;
              if (v14)
              {
                id v16 = v14;
                CFArrayAppendValue(Mutable, v16);
                CFDictionaryRef v17 = v16;
                unint64_t v6 = 0x1EB2CD000;
              }
              id v18 = v15;
              goto LABEL_26;
            }
            CFTypeID v19 = v13;
            if (v13 != v34)
            {
              CFNumberRef v23 = 0;
              goto LABEL_20;
            }
            CFIndex v20 = CFArrayGetCount((CFArrayRef)ValueAtIndex);
            if (v20 >= 1)
            {
              CFIndex v21 = v20;
              CFNumberRef v22 = CFArrayGetValueAtIndex((CFArrayRef)ValueAtIndex, 0);
              CFTypeID v19 = CFGetTypeID(v22);
              if (v21 == 1) {
                CFNumberRef v23 = 0;
              }
              else {
                CFNumberRef v23 = (NSNumber *)CFArrayGetValueAtIndex((CFArrayRef)ValueAtIndex, 1);
              }
              CFDictionaryRef ValueAtIndex = v22;
              unint64_t v6 = 0x1EB2CD000uLL;
LABEL_20:
              id v36 = 0;
              id v24 = objc_alloc((Class)(v6 + 1184));
              if (v19 == v33)
              {
                uint64_t v25 = (uint64_t)ValueAtIndex;
                uint64_t v26 = (uint64_t)v23;
                uint64_t v27 = 0;
                CFDictionaryRef v28 = 0;
              }
              else
              {
                uint64_t v25 = 0;
                uint64_t v26 = 0;
                uint64_t v27 = (uint64_t)ValueAtIndex;
                CFDictionaryRef v28 = v23;
              }
              id v35 = -[CTFeatureSetting initWithType:selector:tag:value:](v24, v25, v26, v27, v28);

              CFTypeID v8 = v32;
              if (atomic_load_explicit((atomic_ullong *volatile)&v36, memory_order_acquire))
              {
                id v29 = (id)atomic_load_explicit((atomic_ullong *volatile)&v36, memory_order_acquire);
                CFArrayAppendValue(Mutable, v29);
              }
              id v18 = v36;
LABEL_26:
            }
          }
          ++v11;
        }
        while (v10 != v11);
      }
      if (CFArrayGetCount(Mutable) <= 0) {
        CFDictionaryRef v30 = 0;
      }
      else {
        CFDictionaryRef v30 = Mutable;
      }
      id v36 = v30;
      *CFNumberRef v31 = atomic_exchange((atomic_ullong *volatile)&v36, 0);
    }
    else
    {
      *a2 = 0;
    }
  }
  else
  {
    *a2 = 0;
  }
}

BOOL TFont::ShouldPropagateFeatureSetting(atomic_ullong *this, const TFontFeatureSettingList *a2)
{
  if (!TFont::IsSystemUIFontAndForShaping(this, &v8)
    || TFontFeatureSettingList::IndexOfAATSetting(a2, 0x23u, 14) == -1)
  {
    return 0;
  }
  uint64_t v4 = (__CFString *)(id)atomic_load_explicit((atomic_ullong *volatile)(this[50] + 96), memory_order_acquire);
  uint64_t v5 = v4;
  if (v4 == @".SF")
  {
    BOOL v6 = 1;
  }
  else if (v4)
  {
    BOOL v6 = CFStringHasPrefix(v4, @".SF") != 0;
  }
  else
  {
    BOOL v6 = 0;
  }

  return v6;
}

uint64_t TTenuousComponentFont::GetScriptAnalysisValue(atomic_ullong *this)
{
  if (*((unsigned char *)this + 714)) {
    return 2;
  }
  else {
    return TBaseFont::GetScriptAnalysisValue(this);
  }
}

BOOL TFont::HasDerivedOpticalSize(TFont *this)
{
  BOOL result = 1;
  if (!atomic_load_explicit((atomic_ullong *volatile)this + 1, memory_order_acquire)
    || (*(_DWORD *)(*(void *)(atomic_load_explicit((atomic_ullong *volatile)this + 1, memory_order_acquire) + 40)
                  + 16) & 0x8000) == 0)
  {
    uint64_t v1 = *((void *)this + 50);
    if (!v1 || ((*(uint64_t (**)(uint64_t))(*(void *)v1 + 456))(v1) & 1) == 0) {
      return 0;
    }
  }
  return result;
}

void TTenuousComponentFont::TTenuousComponentFont(TTenuousComponentFont *this, atomic_ullong *a2, double a3)
{
  TComponentFont::TComponentFont(this, (const TComponentFont *)a2);
  *BOOL v6 = &unk_1ED05EC18;
  *((void *)this + 95) = (id)atomic_load_explicit(a2 + 95, memory_order_acquire);
  *((_DWORD *)this + 199) = 0;
  *((unsigned char *)this + 800) = 0;
  *((void *)this + 96) = 0;
  *((void *)this + 98) = 0;
  *((void *)this + 97) = 0;
  *((_WORD *)this + 396) = 0;
  TTenuousComponentFont::InitWithOpticalSize((atomic_ullong *)this, a3);
}

void *___ZL44getFSFontIsOverriddenSystemFontNameSymbolLocv_block_invoke(void *a1)
{
  CFNumberRef v7 = 0;
  uint64_t v3 = FontServicesLibraryCore(&v7);
  if (!v3)
  {
    a1 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    uint64_t v6 = [NSString stringWithUTF8String:"void *FontServicesLibrary()"];
    uint64_t v4 = (char *)objc_msgSend(a1, "handleFailureInFunction:file:lineNumber:description:", v6, @"MetadataSupport.cpp", 26, @"%s", v7);
    __break(1u);
    goto LABEL_5;
  }
  uint64_t v1 = (void *)v3;
  uint64_t v4 = v7;
  if (v7) {
LABEL_5:
  }
    free(v4);
  BOOL result = dlsym(v1, "FSFontIsOverriddenSystemFontName");
  *(void *)(*(void *)(a1[4] + 8) + 24) = result;
  getFSFontIsOverriddenSystemFontNameSymbolLoc(void)::ptr = *(void *)(*(void *)(a1[4] + 8) + 24);
  return result;
}

void TFont::AppendFeatureSettingWithTypeAndSelector(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  id v14 = (id)0xAAAAAAAAAAAAAAAALL;
  TCFMutableArray::TCFMutableArray((TCFMutableArray *)&v14, (CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)(a1 + 168), memory_order_acquire));
  uint64_t v8 = [NSNumber numberWithUnsignedShort:a2];
  CFNumberRef v9 = -[CTFeatureSetting initWithType:selector:tag:value:]([CTFeatureSetting alloc], v8, [NSNumber numberWithUnsignedShort:a3], 0, 0);
  CFIndex v10 = v9;
  if (v9)
  {
    CFIndex v11 = v9;
    CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v14, memory_order_acquire), v11);

    id v13 = (id)atomic_load_explicit((atomic_ullong *volatile)(a1 + 160), memory_order_acquire);
    if (!atomic_load_explicit((atomic_ullong *volatile)&v13, memory_order_acquire))
    {
      id Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      id v12 = (id)atomic_exchange((atomic_ullong *volatile)&Mutable, 0);
    }
    TFont::UpdateFeatureSettings(a1, (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v13, memory_order_acquire), (id)atomic_load_explicit((atomic_ullong *volatile)&v14, memory_order_acquire), a4);

    *(_DWORD *)a1 &= ~8u;
  }
}

uint64_t IsGB18030ComplianceRequired(void)
{
  if (qword_1EB2CE450 != -1) {
    dispatch_once_f(&qword_1EB2CE450, 0, (dispatch_function_t)IsGB18030ComplianceRequired(void)::$_0::__invoke);
  }
  return _MergedGlobals_25;
}

uint64_t TGlyphEncoder::RunUnicodeEncoderRecursively(uint64_t *a1, unsigned int a2, atomic_ullong *a3, _WORD **a4, uint64_t a5, uint64_t a6, char **a7, int a8, TFontCascade **a9, __CFString *a10, int a11, BOOL a12)
{
  uint64_t v216 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v17 = *(TRun **)(atomic_load_explicit(a3, memory_order_acquire) + 48);
  unsigned int v202 = a7;
  unsigned int v199 = v17;
  BOOL v200 = (TCharStreamIterator *)(a1 + 1);
  BOOL v189 = *(double **)(*a1 + 24);
  BOOL v190 = *(unsigned __int16 **)(*a1 + 16);
  unsigned int v188 = *(unsigned int **)(*a1 + 40);
  uint64_t NextUnmappedCharRange = TRun::GetNextUnmappedCharRange(v17, a5);
  if (a5 > NextUnmappedCharRange)
  {
    LOBYTE(v20) = 0;
    goto LABEL_308;
  }
  uint64_t v21 = NextUnmappedCharRange;
  uint64_t v22 = v19;
  int v20 = 0;
  char v23 = 0;
  unsigned int v183 = a2;
  unsigned int v179 = a2 + 1;
  uint64_t v24 = a5 + a6;
  if (a12) {
    uint64_t v25 = 2654435770;
  }
  else {
    uint64_t v25 = 2654435769;
  }
  uint64_t v173 = v25;
  BOOL v171 = a1 + 28;
  uint64_t v196 = (uint64_t)a1;
  uint64_t v194 = a5;
  int v172 = a8;
  uint64_t v26 = a5;
  uint64_t v174 = a5;
  uint64_t v185 = v24;
  do
  {
    if (v24 <= v21) {
      break;
    }
    uint64_t v27 = v24 - v194;
    CFIndex ClusterRange = TGlyphEncoder::GetClusterRange((uint64_t)a1, a11, v21, v22, v194, v24 - v194);
    CFIndex v30 = v29;
    double v201 = *((double *)v199 + 24);
    v222.CFIndex location = ClusterRange;
    v222.CFIndex length = v29;
    unsigned __int8 v31 = TUnicodeEncoder::Encode(&v202, (const __CTFont *)atomic_load_explicit((atomic_ullong *volatile)v199 + 7, memory_order_acquire), a10, v200, v222, v190, v189, v188, &v201, a12);
    *((double *)v199 + 24) = v201;
    if ((v31 & 4) != 0) {
      *((_DWORD *)v199 + 65) |= 1u;
    }
    if ((v31 & 0x10) != 0) {
      *((unsigned char *)v199 + 225) |= 8u;
    }
    v20 |= v31;
    if (a8 || (v20 & 8) == 0) {
      goto LABEL_59;
    }
    CFTypeID v32 = *a9;
    if (v183 || v32) {
      goto LABEL_20;
    }
    if ((*a4[5] & 0x1C0) == 0) {
      goto LABEL_59;
    }
    CFTypeID v33 = (char *)operator new(0xC8uLL, MEMORY[0x1E4FBA2D0]);
    if (!v33)
    {
      *a9 = 0;
LABEL_59:
      uint64_t v62 = ClusterRange + v30;
      goto LABEL_60;
    }
    *(void *)CFTypeID v33 = a4;
    *((void *)v33 + 1) = 0;
    *((void *)v33 + 2) = a10;
    *((void *)v33 + 3) = 0;
    *((void *)v33 + 4) = 0;
    *((void *)v33 + 5) = 0;
    *((_DWORD *)v33 + 12) = 0;
    *(_OWORD *)(v33 + 56) = 0u;
    *(_OWORD *)(v33 + 72) = 0u;
    *(_OWORD *)(v33 + 88) = 0u;
    *(_OWORD *)(v33 + 104) = 0u;
    *(_OWORD *)(v33 + 168) = 0u;
    *(_OWORD *)(v33 + 184) = 0u;
    CFTypeID v34 = *a9;
    *a9 = (TFontCascade *)v33;
    if (v34)
    {
      TFontCascade::~TFontCascade(v34);
      MEMORY[0x1853275C0]();
      CFTypeID v32 = *a9;
LABEL_20:
      if (!v32) {
        goto LABEL_59;
      }
      if (v183 >= 0x20)
      {
        if (atomic_fetch_add(TGlyphEncoder::RunUnicodeEncoderRecursively(unsigned int,TCFRef<CTRun *> &&,__CTFont const*,CFRange,TInlineVector<long,30ul> &,TGlyphEncoder::Fallbacks,std::unique_ptr<TFontCascade const,TGlyphEncoder::Fallbacks::default_delete<TFontCascade>> &,__CFString const*,TGlyphEncoder::ClusterMatching,BOOL)::sLogCount, 1u) <= 9)
        {
          v217.CFIndex location = ClusterRange;
          v217.CFIndex length = v30;
          unsigned int v169 = (unsigned int *)TCharStream::DebugDescriptionForRange(*(TCharStream **)v200, v217);
          CFLog();
        }
        goto LABEL_59;
      }
    }
    uint64_t v35 = TRun::GetNextUnmappedCharRange(v199, ClusterRange);
    uint64_t v37 = v35;
    uint64_t v197 = v36;
    uint64_t v198 = v35;
    if (a11) {
      BOOL v38 = v35 == ClusterRange;
    }
    else {
      BOOL v38 = 0;
    }
    int v39 = !v38;
    CFIndex v180 = v30;
    if (!v38 && v36 == 1 && (Char = TCharStreamIterator::GetChar(v200, v35), uint64_t v37 = v198, Char == 32))
    {
      int v39 = 0;
      uint64_t v192 = v198;
      uint64_t v41 = 1;
      uint64_t v42 = v198;
      uint64_t v43 = 1;
    }
    else
    {
      if (a11 == 3 && v37 != ClusterRange)
      {
        uint64_t v44 = *(void *)(*(void *)(atomic_load_explicit((atomic_ullong *volatile)v199 + 7, memory_order_acquire) + 40)
                        + 400);
        int v45 = (*(uint64_t (**)(uint64_t))(*(void *)v44 + 712))(v44);
        uint64_t v37 = v198;
        v39 &= v45 ^ 1;
      }
      if (v39)
      {
        uint64_t v192 = v37;
        uint64_t v41 = v197;
        uint64_t v42 = v37;
        uint64_t v43 = v197;
        if (v197 >= 1)
        {
          int v175 = v20;
          uint64_t v46 = TGlyphEncoder::GetClusterRange((uint64_t)a1, 2, v198, v197, v194, v27);
          uint64_t v41 = v47;
          uint64_t v48 = ClusterRange + v180;
          unint64_t v186 = (__CTFont *)v46;
          uint64_t v49 = v46;
          uint64_t v177 = v47;
          while (1)
          {
            uint64_t v192 = v49;
            uint64_t v50 = v41 + v49;
            v213.CFIndex location = v41 + v49;
            uint64_t v51 = TRun::GetNextUnmappedCharRange(v199, v41 + v49);
            CFIndex v53 = v51 + v52 >= v48 ? ClusterRange + v180 : v51 + v52;
            BOOL v54 = ClusterRange <= v51 && v51 < v48;
            uint64_t v55 = v51;
            if (!v54)
            {
              if (v51 > ClusterRange) {
                break;
              }
              uint64_t v55 = ClusterRange;
              if (ClusterRange >= v51 + v52) {
                break;
              }
            }
            if (v53 <= v55) {
              break;
            }
            uint64_t v56 = TGlyphEncoder::GetClusterRange(v196, 2, v51, v52, v194, v27);
            if (v57 < 1) {
              break;
            }
            uint64_t v58 = v56;
            if (v56 > v50) {
              break;
            }
            uint64_t v59 = v57;
            Fullint Char = TCharStreamIterator::GetFullChar(v200, &v213.location, 0);
            if (((1 << u_charType(FullChar)) & 0x30000000) != 0) {
              break;
            }
            uint64_t v49 = v192;
            if (v58 < v192) {
              uint64_t v49 = v58;
            }
            uint64_t v61 = v58 + v59;
            if (v50 > v58 + v59) {
              uint64_t v61 = v50;
            }
            uint64_t v41 = v61 - v49;
          }
          int v39 = 1;
          int v20 = v175;
          a1 = (uint64_t *)v196;
          uint64_t v42 = (uint64_t)v186;
          uint64_t v43 = v177;
        }
      }
      else
      {
        uint64_t v192 = v37;
        uint64_t v43 = v197;
        uint64_t v41 = v197;
        uint64_t v42 = v37;
      }
    }
    unsigned int v176 = v20 & 0xFFFFFFF7;
    int v178 = v39;
    CFHashCode v64 = CFHash((CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)v199 + 7, memory_order_acquire));
    CFHashCode v65 = v64;
    unint64_t v66 = (v43 + 2654435769 + (v42 << 6) + ((unint64_t)v42 >> 2)) ^ v42;
    unint64_t v67 = (v64 + 2654435769u + (v66 << 6) + (v66 >> 2)) ^ v66;
    unint64_t v68 = (v173 + (v67 << 6) + (v67 >> 2)) ^ v67;
    unint64_t v69 = a1[27];
    if (v69)
    {
      uint8x8_t v70 = (uint8x8_t)vcnt_s8((int8x8_t)v69);
      v70.i16[0] = vaddlv_u8(v70);
      if (v70.u32[0] > 1uLL)
      {
        unint64_t v71 = (v173 + (v67 << 6) + (v67 >> 2)) ^ v67;
        if (v68 >= v69) {
          unint64_t v71 = v68 % v69;
        }
      }
      else
      {
        unint64_t v71 = v68 & (v69 - 1);
      }
      uint64_t v73 = a1[26];
      long long v74 = *(uint64_t ***)(v73 + 8 * v71);
      if (v74)
      {
        for (CFIndex i = *v74; i; CFIndex i = (uint64_t *)*i)
        {
          unint64_t v76 = i[1];
          if (v76 == v68)
          {
            BOOL v77 = i[2] == v42 && i[3] == v43;
            if (v77 && i[4] == v64 && *((unsigned char *)i + 40) == a12)
            {
              if (v197 >= 1)
              {
                CFIndex v110 = v198;
                TGlyphEncoder::AppendRunClone((uint64_t)a1, a3, v194, v198);
                int v109 = 0;
                uint64_t v41 = v197;
                CFIndex v105 = v174;
                goto LABEL_173;
              }
LABEL_303:
              uint64_t v62 = ClusterRange + v180;
              int v20 = v176;
              goto LABEL_304;
            }
          }
          else
          {
            if (v70.u32[0] > 1uLL)
            {
              if (v76 >= v69) {
                v76 %= v69;
              }
            }
            else
            {
              v76 &= v69 - 1;
            }
            if (v76 != v71) {
              break;
            }
          }
        }
      }
      if (v70.u32[0] > 1uLL)
      {
        unint64_t v72 = (v173 + (v67 << 6) + (v67 >> 2)) ^ v67;
        if (v68 >= v69) {
          unint64_t v72 = v68 % v69;
        }
      }
      else
      {
        unint64_t v72 = v68 & (v69 - 1);
      }
      long long v78 = *(uint64_t ***)(v73 + 8 * v72);
      if (v78)
      {
        for (uint64_t j = *v78; j; uint64_t j = (uint64_t *)*j)
        {
          unint64_t v80 = j[1];
          if (v80 == v68)
          {
            BOOL v81 = j[2] == v42 && j[3] == v43;
            if (v81 && j[4] == v64 && *((unsigned char *)j + 40) == a12) {
              goto LABEL_164;
            }
          }
          else
          {
            if (v70.u32[0] > 1uLL)
            {
              if (v80 >= v69) {
                v80 %= v69;
              }
            }
            else
            {
              v80 &= v69 - 1;
            }
            if (v80 != v72) {
              break;
            }
          }
        }
      }
    }
    else
    {
      unint64_t v72 = 0xAAAAAAAAAAAAAAAALL;
    }
    uint64_t v27 = (uint64_t)operator new(0x30uLL);
    *(void *)uint64_t v27 = 0;
    *(void *)(v27 + 8) = v68;
    *(void *)(v27 + 16) = v42;
    *(void *)(v27 + 24) = v43;
    *(void *)(v27 + 32) = v65;
    *(unsigned char *)(v27 + 40) = a12;
    *(_DWORD *)(v27 + 41) = -1431655766;
    *(_DWORD *)(v27 + 44) = -1431655766;
    float v82 = (float)(unint64_t)(*(void *)(v196 + 232) + 1);
    float v83 = *(float *)(v196 + 240);
    if (!v69 || (float)(v83 * (float)v69) < v82)
    {
      BOOL v84 = (v69 & (v69 - 1)) != 0;
      if (v69 < 3) {
        BOOL v84 = 1;
      }
      unint64_t v85 = v84 | (2 * v69);
      unint64_t v86 = vcvtps_u32_f32(v82 / v83);
      if (v85 <= v86) {
        int8x8_t prime = (int8x8_t)v86;
      }
      else {
        int8x8_t prime = (int8x8_t)v85;
      }
      if (*(void *)&prime == 1)
      {
        int8x8_t prime = (int8x8_t)2;
        uint64_t v88 = v196;
      }
      else
      {
        uint64_t v88 = v196;
        if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
        {
          int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
          unint64_t v69 = *(void *)(v196 + 216);
        }
      }
      if (*(void *)&prime > v69) {
        goto LABEL_120;
      }
      if (*(void *)&prime < v69)
      {
        unint64_t v95 = vcvtps_u32_f32((float)*(unint64_t *)(v88 + 232) / *(float *)(v88 + 240));
        if (v69 < 3 || (uint8x8_t v96 = (uint8x8_t)vcnt_s8((int8x8_t)v69), v96.i16[0] = vaddlv_u8(v96), v96.u32[0] > 1uLL))
        {
          unint64_t v95 = std::__next_prime(v95);
        }
        else
        {
          uint64_t v97 = 1 << -(char)__clz(v95 - 1);
          if (v95 >= 2) {
            unint64_t v95 = v97;
          }
        }
        if (*(void *)&prime <= v95) {
          int8x8_t prime = (int8x8_t)v95;
        }
        if (*(void *)&prime >= v69)
        {
          unint64_t v69 = *(void *)(v88 + 216);
        }
        else
        {
          if (prime)
          {
LABEL_120:
            if (*(void *)&prime >> 61) {
              std::__throw_bad_array_new_length[abi:nn180100]();
            }
            unsigned int v89 = operator new(8 * *(void *)&prime);
            BOOL v90 = *(void **)(v88 + 208);
            *(void *)(v88 + 208) = v89;
            if (v90) {
              operator delete(v90);
            }
            uint64_t v91 = 0;
            *(int8x8_t *)(v88 + 216) = prime;
            do
              *(void *)(*(void *)(v88 + 208) + 8 * v91++) = 0;
            while (*(void *)&prime != v91);
            unsigned int v92 = (void *)*v171;
            if (*v171)
            {
              unint64_t v93 = v92[1];
              uint8x8_t v94 = (uint8x8_t)vcnt_s8(prime);
              v94.i16[0] = vaddlv_u8(v94);
              if (v94.u32[0] > 1uLL)
              {
                if (v93 >= *(void *)&prime) {
                  v93 %= *(void *)&prime;
                }
              }
              else
              {
                v93 &= *(void *)&prime - 1;
              }
              *(void *)(*(void *)(v88 + 208) + 8 * v93) = v171;
              unsigned int v98 = (void *)*v92;
              if (*v92)
              {
                do
                {
                  unint64_t v99 = v98[1];
                  if (v94.u32[0] > 1uLL)
                  {
                    if (v99 >= *(void *)&prime) {
                      v99 %= *(void *)&prime;
                    }
                  }
                  else
                  {
                    v99 &= *(void *)&prime - 1;
                  }
                  if (v99 != v93)
                  {
                    uint64_t v100 = *(void *)(v88 + 208);
                    if (!*(void *)(v100 + 8 * v99))
                    {
                      *(void *)(v100 + 8 * v99) = v92;
                      goto LABEL_145;
                    }
                    *unsigned int v92 = *v98;
                    *unsigned int v98 = **(void **)(*(void *)(v88 + 208) + 8 * v99);
                    **(void **)(*(void *)(v88 + 208) + 8 * v99) = v98;
                    unsigned int v98 = v92;
                  }
                  unint64_t v99 = v93;
LABEL_145:
                  unsigned int v92 = v98;
                  unsigned int v98 = (void *)*v98;
                  unint64_t v93 = v99;
                }
                while (v98);
              }
            }
            unint64_t v69 = (unint64_t)prime;
            goto LABEL_149;
          }
          unsigned int v165 = *(void **)(v88 + 208);
          *(void *)(v88 + 208) = 0;
          if (v165) {
            operator delete(v165);
          }
          unint64_t v69 = 0;
          *(void *)(v88 + 216) = 0;
        }
      }
LABEL_149:
      if ((v69 & (v69 - 1)) != 0)
      {
        if (v68 >= v69) {
          unint64_t v72 = v68 % v69;
        }
        else {
          unint64_t v72 = v68;
        }
      }
      else
      {
        unint64_t v72 = (v69 - 1) & v68;
      }
    }
    uint64_t v101 = *(void *)(v196 + 208);
    unsigned int v102 = *(uint64_t **)(v101 + 8 * v72);
    if (v102)
    {
      *(void *)uint64_t v27 = *v102;
      uint64_t v103 = v196;
    }
    else
    {
      *(void *)uint64_t v27 = *v171;
      *BOOL v171 = v27;
      *(void *)(v101 + 8 * v72) = v171;
      uint64_t v103 = v196;
      if (!*(void *)v27) {
        goto LABEL_163;
      }
      unint64_t v104 = *(void *)(*(void *)v27 + 8);
      if ((v69 & (v69 - 1)) != 0)
      {
        if (v104 >= v69) {
          v104 %= v69;
        }
      }
      else
      {
        v104 &= v69 - 1;
      }
      unsigned int v102 = (uint64_t *)(*(void *)(v196 + 208) + 8 * v104);
    }
    *unsigned int v102 = v27;
LABEL_163:
    ++*(void *)(v103 + 232);
LABEL_164:
    a1 = (uint64_t *)v196;
    if (v41 <= 0) {
      goto LABEL_303;
    }
    TGlyphEncoder::AppendRunClone(v196, a3, v194, v192);
    CFIndex v105 = v174;
    if (v178)
    {
      uint64_t v106 = v198;
      uint64_t v107 = v198 + v197;
      if (v198 + v197 >= v43 + v42) {
        uint64_t v108 = v43 + v42;
      }
      else {
        uint64_t v108 = v198 + v197;
      }
      if (v42 > v198 || v198 >= v43 + v42)
      {
        uint64_t v111 = v108 - v42;
        BOOL v112 = v42 < v107;
        if (v42 < v107) {
          uint64_t v113 = v42;
        }
        else {
          uint64_t v113 = 0;
        }
        if (!v112) {
          uint64_t v111 = 0;
        }
        if (v198 > v42) {
          uint64_t v113 = 0;
        }
        uint64_t v198 = v113;
        if (v106 <= v42) {
          uint64_t v114 = v111;
        }
        else {
          uint64_t v114 = 0;
        }
        uint64_t v197 = v114;
      }
      else
      {
        uint64_t v197 = v108 - v198;
      }
      int v195 = 1;
      CFIndex v110 = v192;
    }
    else
    {
      int v109 = 1;
      CFIndex v110 = v192;
LABEL_173:
      if (v110 == v105)
      {
        int v195 = 0;
        CFIndex v110 = v105;
      }
      else
      {
        if (v41 + v110 != v185) {
          int v109 = 0;
        }
        int v195 = v109;
      }
    }
    long long v115 = 0;
    CFIndex v193 = v110;
    BOOL v116 = a12;
    while (1)
    {
      uint64_t v117 = *(void *)(atomic_load_explicit(a3, memory_order_acquire) + 48);
      CFDictionaryRef explicit = a4;
      if ((v195 & 1) == 0) {
        CFDictionaryRef explicit = (void *)atomic_load_explicit((atomic_ullong *volatile)(v117 + 56), memory_order_acquire);
      }
      if (explicit
        && ((*(uint64_t (**)(void))(**(void **)(explicit[5] + 400) + 688))(*(void *)(explicit[5] + 400)) & 1) != 0
        || (*(_WORD *)(v117 + 178) & 0x40) != 0)
      {
        uint64_t v164 = (int64x2_t *)a1[25];
        (*(void (**)(uint64_t *__return_ptr))(atomic_load_explicit(a3, memory_order_acquire) + 64))(&v211);
        v213.CFIndex location = atomic_exchange(&v211, 0);
        TLine::AppendRun(v164, &v213.location);

        LODWORD(v27) = 0;
        goto LABEL_291;
      }
      uint64_t v181 = v117;
      char v187 = (__CTFont *)(v117 + 40);
      id v209 = (id)0xAAAAAAAAAAAAAAAALL;
      char v119 = explicit;
      id v208 = (id)0xAAAAAAAAAAAAAAAALL;
      id v209 = v119;
      (*(void (**)(id *__return_ptr))(**(void **)v200 + 16))(&v208);
      BOOL v207 = v198 > v110;
      char v206 = 0;
      int v205 = 0;
      char v204 = (__CFString *)0xAAAAAAAAAAAAAAAALL;
      unsigned int v120 = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&v208, memory_order_acquire);
      BOOL v121 = operator new(0x20uLL);
      void *v121 = &unk_1ED060CE0;
      v121[1] = &v207;
      v121[2] = &v206;
      v121[3] = &v205;
      v212[3] = v121;
      CreateStringByDeletingLongCharactersPassingTest(v120, (uint64_t)v212, &v204);
      std::__function::__value_func<BOOL ()(CFRange,unsigned int)>::~__value_func[abi:nn180100](v212);
      if (v205) {
        int v122 = v195;
      }
      else {
        int v122 = 0;
      }
      if (v122 != 1)
      {
        uint64_t v126 = (uint64_t)*a9;
        CFStringRef v127 = (const __CFString *)atomic_load_explicit((atomic_ullong *volatile)&v204, memory_order_acquire);
        TFontCascade::CreateFallback(v127, v126, (const __CTFont *)explicit, v205, &v213.location);

        goto LABEL_252;
      }
      if ((uint64_t)v115 >= 1)
      {
        v213.CFIndex location = 0xAAAAAAAAAAAAAAAALL;
        int64_t v123 = *a9;
        int64_t v124 = (atomic_ullong *)((char *)*a9 + 32);
        if (atomic_load_explicit(v124, memory_order_acquire)) {
          inited = (const __CTFont *)atomic_load_explicit(v124, memory_order_acquire);
        }
        else {
          inited = (const __CTFont *)TFontCascade::InitLastResort(v123);
        }
        v218.CFIndex location = (CFIndex)a1;
        v218.CFIndex length = v193;
        TGlyphEncoder::CreateRun(&v213.location, v218, v115, v187, inited);
        BYTE4(v170) = v116;
        LODWORD(v170) = 1;
        TGlyphEncoder::RunUnicodeEncoderRecursively(a1, v179, &v213, explicit, v193, v115, a7, 0, a9, a10, v170);
      }
      uint64_t v128 = (*(uint64_t (**)(void, CFIndex, uint64_t))(**(void **)v200 + 40))(*(void *)v200, v110, 2);
      uint64_t v130 = v129;
      CFIndex v131 = v128 + v129;
      if (v128 + v129 > v197 + v198)
      {
        uint64_t v211 = (uint64_t)&v205;
        BOOL v207 = 0;
        (*(void (**)(id *__return_ptr))(**(void **)v200 + 16))(&v210);
        CFStringRef v132 = (const __CFString *)atomic_load_explicit((atomic_ullong *volatile)&v210, memory_order_acquire);
        v213.CFIndex location = (CFIndex)&unk_1ED0620D8;
        v213.CFIndex length = (CFIndex)&v207;
        long long v214 = &v211;
        unint64_t v215 = &v213;
        EnumerateCharactersInRange(v132, 0, v130, (uint64_t)&v213);
        std::__function::__value_func<void ()(CFRange,unsigned int,BOOL *)>::~__value_func[abi:nn180100](&v213);
      }
      uint64_t v133 = v110 + v41;
      while (v110 <= v131 && v133 > v131)
      {
        uint64_t v135 = (*(uint64_t (**)(void, CFIndex, uint64_t))(**(void **)v200 + 40))(*(void *)v200, v131, 2);
        uint64_t v137 = v136;
        int v203 = 0;
        uint64_t v211 = (uint64_t)&v203;
        BOOL v207 = 0;
        (*(void (**)(id *__return_ptr))(**(void **)v200 + 16))(&v210);
        CFStringRef v138 = (const __CFString *)atomic_load_explicit((atomic_ullong *volatile)&v210, memory_order_acquire);
        v213.CFIndex location = (CFIndex)&unk_1ED0620D8;
        v213.CFIndex length = (CFIndex)&v207;
        long long v214 = &v211;
        unint64_t v215 = &v213;
        EnumerateCharactersInRange(v138, 0, v137, (uint64_t)&v213);
        std::__function::__value_func<void ()(CFRange,unsigned int,BOOL *)>::~__value_func[abi:nn180100](&v213);

        if (v203 != v205) {
          break;
        }
        if (v135 < v128) {
          uint64_t v128 = v135;
        }
        if (v131 <= v135 + v137) {
          CFIndex v131 = v135 + v137;
        }
        uint64_t v130 = v131 - v128;
      }
      CFIndex v139 = v130 + v128;
      uint64_t v140 = v130 + v128 >= v133 ? v133 : v130 + v128;
      if (v110 > v128 || v128 >= v133)
      {
        CFIndex v141 = v140 - v110;
        BOOL v142 = v110 < v139;
        if (v110 < v139) {
          CFIndex v143 = v110;
        }
        else {
          CFIndex v143 = 0;
        }
        if (!v142) {
          CFIndex v141 = 0;
        }
        BOOL v144 = v128 <= v110;
        CFIndex v110 = v128 <= v110 ? v143 : 0;
        uint64_t v41 = v144 ? v141 : 0;
      }
      else
      {
        uint64_t v41 = v140 - v128;
        CFIndex v110 = v128;
      }
      a1 = (uint64_t *)v196;
      int v145 = v205;
      if (explicit)
      {
        int v146 = v205 == 2;
        if (v146 == (*(unsigned int (**)(void))(**(void **)(explicit[5] + 400) + 712))(*(void *)(explicit[5] + 400))) {
          goto LABEL_246;
        }
      }
      else if (v205 != 2)
      {
        goto LABEL_250;
      }
      v213.CFIndex location = 0xAAAAAAAAAAAAAAAALL;
      (*(void (**)(CFRange *__return_ptr))(**(void **)v200 + 16))(&v213);
      uint64_t v147 = (uint64_t)*a9;
      CFStringRef v148 = (const __CFString *)atomic_load_explicit(&v213.location, memory_order_acquire);
      TFontCascade::CreateFallback(v148, v147, (const __CTFont *)explicit, v205, &v211);

      if (!atomic_load_explicit((atomic_ullong *volatile)&v209, memory_order_acquire))
      {
        char v149 = *a9;
        unsigned int v150 = (atomic_ullong *)((char *)*a9 + 32);
        if (atomic_load_explicit(v150, memory_order_acquire)) {
          unsigned int v151 = (void *)atomic_load_explicit(v150, memory_order_acquire);
        }
        else {
          unsigned int v151 = (void *)TFontCascade::InitLastResort(v149);
        }
        TCFRef<__CTFont const*>::Retain((atomic_ullong *)&v209, v151);
      }

LABEL_246:
      if (v145 == 2)
      {
        CFStringRef Length = (const __CFString *)(id)atomic_load_explicit((atomic_ullong *volatile)&v204, memory_order_acquire);
        char v153 = (__CFString *)Length;
        if (Length) {
          CFStringRef Length = (const __CFString *)CFStringGetLength(Length);
        }
        BOOL v116 = (uint64_t)Length > 0;

        goto LABEL_251;
      }
LABEL_250:
      BOOL v116 = 0;
LABEL_251:
      v213.CFIndex location = 0xAAAAAAAAAAAAAAAALL;
      v219.CFIndex location = v196;
      v219.CFIndex length = v110;
      TGlyphEncoder::CreateRun(&v213.location, v219, (const TAttributes *)v41, v187, (const __CTFont *)atomic_load_explicit((atomic_ullong *volatile)&v209, memory_order_acquire));
      BYTE4(v170) = v116;
      LODWORD(v170) = 3;
      LODWORD(v27) = TGlyphEncoder::RunUnicodeEncoderRecursively(v196, v179, &v213, explicit, v110, v41, a7, 0, a9, a10, v170);

      LOBYTE(v122) = 1;
LABEL_252:

      if (v122) {
        goto LABEL_290;
      }
      if (atomic_load_explicit((atomic_ullong *volatile)&v209, memory_order_acquire) || v198 != v110) {
        break;
      }
      uint64_t v211 = v198;
      v213.CFIndex location = 0xAAAAAAAAAAAAAAAALL;
      v213.CFIndex length = 0xAAAAAAAAAAAAAAAALL;
      TCharStreamIterator::GetFullChar(v200, &v211, &v213);
      CFIndex location = v198;
      CFIndex v155 = v198 + v41;
      if (v213.length + v213.location >= v198 + v41) {
        CFIndex v156 = v198 + v41;
      }
      else {
        CFIndex v156 = v213.length + v213.location;
      }
      if (v198 > v213.location || v213.location >= v155)
      {
        CFIndex v158 = v156 - v198;
        if (v198 < v213.length + v213.location && v213.location <= v198) {
          uint64_t v157 = v158;
        }
        else {
          uint64_t v157 = 0;
        }
      }
      else
      {
        uint64_t v157 = v156 - v213.location;
      }
      CFIndex v110 = v157 + v198;
      if (v197 >= v41) {
        goto LABEL_278;
      }
      uint64_t v211 = v157 + v198;
      v213.CFIndex location = 0xAAAAAAAAAAAAAAAALL;
      v213.CFIndex length = 0xAAAAAAAAAAAAAAAALL;
      TCharStreamIterator::GetFullChar(v200, &v211, &v213);
      if (v213.length + v213.location >= v155) {
        CFIndex v160 = v198 + v41;
      }
      else {
        CFIndex v160 = v213.length + v213.location;
      }
      if (v198 <= v213.location && v213.location < v155)
      {
        uint64_t v197 = v160 - v213.location;
        CFIndex location = v213.location;
LABEL_278:
        a1 = (uint64_t *)v196;
        goto LABEL_279;
      }
      CFIndex location = 0;
      if (v213.location > v198)
      {
        uint64_t v197 = 0;
        goto LABEL_278;
      }
      uint64_t v197 = 0;
      a1 = (uint64_t *)v196;
      if (v198 < v213.length + v213.location)
      {
        uint64_t v197 = v160 - v198;
        CFIndex location = v198;
      }
LABEL_279:
      long long v115 = (const TAttributes *)((char *)v115 + v157);
      BOOL v54 = v41 <= v157;
      v41 -= v157;
      if (v54) {
        break;
      }
      uint64_t v198 = location;
    }
    if ((uint64_t)v115 < 1) {
      goto LABEL_314;
    }
    v213.CFIndex location = 0xAAAAAAAAAAAAAAAALL;
    long long v161 = *a9;
    long long v162 = (atomic_ullong *)((char *)*a9 + 32);
    uint64_t v163 = (const __CTFont *)(atomic_load_explicit(v162, memory_order_acquire)
                            ? atomic_load_explicit(v162, memory_order_acquire)
                            : TFontCascade::InitLastResort(v161));
    v220.CFIndex location = (CFIndex)a1;
    v220.CFIndex length = v193;
    TGlyphEncoder::CreateRun(&v213.location, v220, v115, v187, v163);
    BYTE4(v170) = v116;
    LODWORD(v170) = v195;
    LODWORD(v27) = TGlyphEncoder::RunUnicodeEncoderRecursively(a1, v179, &v213, explicit, v193, v115, a7, 0, a9, a10, v170);

    if (v41 >= 1)
    {
LABEL_314:
      if (!atomic_load_explicit((atomic_ullong *volatile)&v209, memory_order_acquire)) {
        TCFRef<__CTFont const*>::Retain((atomic_ullong *)&v209, (id)atomic_load_explicit((atomic_ullong *volatile)(v181 + 56), memory_order_acquire));
      }
      v213.CFIndex location = 0xAAAAAAAAAAAAAAAALL;
      v221.CFIndex location = (CFIndex)a1;
      v221.CFIndex length = v110;
      TGlyphEncoder::CreateRun(&v213.location, v221, (const TAttributes *)v41, v187, (const __CTFont *)atomic_load_explicit((atomic_ullong *volatile)&v209, memory_order_acquire));
      BYTE4(v170) = v116;
      LODWORD(v170) = v195;
      LODWORD(v27) = TGlyphEncoder::RunUnicodeEncoderRecursively(a1, v179, &v213, explicit, v110, v41, a7, 0, a9, a10, v170);
    }
LABEL_290:

LABEL_291:
    int v20 = v27 | v176;
    uint64_t v62 = v110 + v41;
    uint64_t v194 = v110 + v41;
LABEL_304:
    uint64_t v26 = v174;
    a8 = v172;
    if (a11 == 2)
    {
      uint64_t v24 = v185;
LABEL_307:
      TGlyphEncoder::AppendRunClone((uint64_t)a1, a3, v194, v24);
      unsigned int v166 = (void *)atomic_exchange(a3, 0);
      goto LABEL_309;
    }
    char v23 = 1;
LABEL_60:
    uint64_t v21 = TRun::GetNextUnmappedCharRange(v199, v62);
    uint64_t v22 = v63;
    uint64_t v24 = v185;
  }
  while (v26 <= v21);
  if (v23) {
    goto LABEL_307;
  }
LABEL_308:
  BOOL v167 = (int64x2_t *)a1[25];
  v213.CFIndex location = atomic_exchange(a3, 0);
  TLine::AppendRun(v167, &v213.location);
  unsigned int v166 = (void *)v213.location;
LABEL_309:

  return (char)v20;
}

uint64_t TRun::GetNextUnmappedCharRange(TRun *this, uint64_t a2)
{
  uint64_t v2 = *((void *)this + 2) + *((void *)this + 1);
  if (v2 > a2)
  {
    GlyphIndexForint Char = TRun::GetGlyphIndexForCharIndex<false>((uint64_t)this, a2);
    uint64_t NextUnmappedGlyphRange = TStorageRange::GetNextUnmappedGlyphRange((TRun *)((char *)this + 192), GlyphIndexForChar);
    if (NextUnmappedGlyphRange < *((void *)this + 26))
    {
      CFNumberRef v7 = (void *)*((void *)this + 27);
      uint64_t v8 = *((void *)this + 25);
      uint64_t v2 = *(void *)(v7[6] + 8 * v8 + 8 * NextUnmappedGlyphRange);
      [v7 attachmentCountAtIndex:v8 + v6 + NextUnmappedGlyphRange - 1];
    }
  }
  return v2;
}

uint64_t TStorageRange::GetNextUnmappedGlyphRange(TStorageRange *this, uint64_t a2)
{
  uint64_t v4 = (char *)this + 16;
  uint64_t result = *((void *)this + 2);
  uint64_t v5 = *(void *)(*((void *)v4 + 1) + 16);
  if (v5)
  {
    if (result > a2)
    {
      uint64_t v6 = *((void *)this + 1);
      uint64_t v7 = v5 + 2 * v6;
      uint64_t v8 = 2 * v6 + 2 * a2 + v5 + 2;
      while (*(_WORD *)(v7 + 2 * a2))
      {
        ++a2;
        v8 += 2;
        if (result == a2) {
          return result;
        }
      }
      uint64_t v9 = result - a2;
      if (result - a2 < 2)
      {
        uint64_t v12 = 1;
      }
      else
      {
        uint64_t v10 = 0;
        while (!*(_WORD *)(v8 + 2 * v10))
        {
          uint64_t v11 = v10 + 2;
          ++v10;
          if (v11 >= v9)
          {
            uint64_t v12 = result - a2;
            goto LABEL_15;
          }
        }
        uint64_t v12 = v10 + 1;
      }
LABEL_15:
      if (v12 < v9)
      {
        id v13 = (__int16 *)(v8 + 2 * v12 - 2);
        while (1)
        {
          int v14 = *v13++;
          if (v14 != -1) {
            break;
          }
          if (++v12 >= v9) {
            return a2;
          }
        }
      }
    }
    return a2;
  }
  return result;
}

uint64_t TGlyphEncoder::GetClusterRange(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v8 = a4;
  uint64_t v9 = a3;
  uint64_t v11 = (TCharStreamIterator *)(a1 + 8);
  uint64_t v10 = *(void *)(a1 + 8);
  switch(a2)
  {
    case 0:
      if (a5 > a3 || a3 >= a5 + a6)
      {
        if (a5 < a3 + a4) {
          uint64_t v17 = a5;
        }
        else {
          uint64_t v17 = 0;
        }
        if (a3 <= a5) {
          return v17;
        }
        else {
          return 0;
        }
      }
      return v9;
    case 1:
      uint64_t ClusterRangeForRange = TCharStream::GetClusterRangeForRange(v10, a3, a4, 2);
      goto LABEL_7;
    case 2:
      uint64_t ClusterRangeForRange = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v10 + 40))(v10, a3, 2);
LABEL_7:
      uint64_t v9 = ClusterRangeForRange;
      if (ClusterRangeForRange + v13 >= a5 + a6) {
        uint64_t v14 = a5 + a6;
      }
      else {
        uint64_t v14 = ClusterRangeForRange + v13;
      }
      if (a5 <= ClusterRangeForRange && ClusterRangeForRange < a5 + a6)
      {
        uint64_t v8 = v14 - ClusterRangeForRange;
LABEL_22:
        if (!v8) {
          return v9;
        }
LABEL_23:
        if (v8 + v9 < a5 + a6) {
          TCharStreamIterator::GetChar(v11, v8 + v9);
        }
        return v9;
      }
      if (ClusterRangeForRange > a5 || a5 >= ClusterRangeForRange + v13) {
        return 0;
      }
      uint64_t v8 = v14 - a5;
      uint64_t v9 = a5;
      if (v14 != a5) {
        goto LABEL_23;
      }
      return v9;
    case 3:
      uint64_t v9 = a5;
      uint64_t v8 = a6;
      if (!a6) {
        return v9;
      }
      goto LABEL_23;
    default:
      goto LABEL_22;
  }
}

void TFont::GetAdvancesForGlyphs(uint64_t a1, uint64_t a2, double *a3, int a4, uint64_t a5, int a6, uint64_t a7, double *a8)
{
  v16.f64[0] = NAN;
  v16.f64[1] = NAN;
  float64x2_t v51 = v16;
  float64x2_t v52 = v16;
  float64x2_t v50 = v16;
  TFont::GetEffectiveMatrix((TFont *)a1, (uint64_t)&v50);
  int64x2_t v17 = (int64x2_t)vandq_s8((int8x16_t)vceqq_f64(v50, (float64x2_t)xmmword_184B895C0), vandq_s8((int8x16_t)vceqq_f64(v51, (float64x2_t)xmmword_184B87DE0), (int8x16_t)vceqzq_f64(v52)));
  unint64_t v18 = vandq_s8((int8x16_t)v17, (int8x16_t)vdupq_laneq_s64(v17, 1)).u64[0];
  double UnscaledTrackAmount = TFont::GetUnscaledTrackAmount((TFont *)a1);
  int v20 = (*(uint64_t (**)(void))(**(void **)(a1 + 400) + 712))();
  int v21 = v20;
  if ((a7 & 0xFF00000000) != 0) {
    a7 = a7;
  }
  else {
    a7 = 5;
  }
  if (a6 == 2 || !a6 && (*(unsigned char *)a1 & 1) != 0)
  {
    if (GetUnscaledAdvances(a1, a2, (uint64_t)a3, a4, a5, a6))
    {
      if (*(unsigned char *)(a1 + 392))
      {
        if ((a7 & 4) != 0) {
          int v27 = v21;
        }
        else {
          int v27 = 1;
        }
        ApplyFixedAdvances((const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)(a1 + 160), memory_order_acquire), v27, a5, a3, a4);
      }
      else
      {
        TFont::GetScaleFactor((double *)a1);
        double v33 = v32;
        if ((v18 & 0x8000000000000000) != 0)
        {
          BOOL v42 = v32 != 1.0;
          if (UnscaledTrackAmount != 0.0) {
            BOOL v42 = 1;
          }
          if ((v42 | v21) == 1)
          {
            if (a5 >= 1)
            {
              double v43 = 0.0;
              uint64_t v44 = a3;
              uint64_t v45 = a5;
              do
              {
                if (*v44 != 0.0)
                {
                  double v46 = v33 * (UnscaledTrackAmount + *v44);
                  double v47 = round(v46);
                  if (v21) {
                    double v46 = v47;
                  }
                  *uint64_t v44 = v46;
                  double v43 = v43 + v46;
                }
                v44 += a4;
                --v45;
              }
              while (v45);
            }
          }
          else
          {
            __C.double a = NAN;
            vDSP_sveD(a3, a4, &__C.a, a5);
          }
        }
        else
        {
          *(void *)&long long v34 = -1;
          *((void *)&v34 + 1) = -1;
          *(_OWORD *)&v49.c = v34;
          *(_OWORD *)&v49.tx = v34;
          *(_OWORD *)&v49.double a = v34;
          CGAffineTransformMakeScale(&v48, v33, v33);
          *(float64x2_t *)&__C.double a = v50;
          *(float64x2_t *)&__C.c = v51;
          *(float64x2_t *)&__C.tx = v52;
          CGAffineTransform t2 = v48;
          CGAffineTransformConcat(&v49, &__C, &t2);
          if (a5 >= 1)
          {
            double a = v49.a;
            double v36 = 0.0;
            double v37 = v49.c * 0.0;
            BOOL v38 = a3;
            uint64_t v39 = a5;
            do
            {
              if (*v38 != 0.0)
              {
                double v40 = v37 + a * (UnscaledTrackAmount + *v38);
                double v41 = round(v40);
                if (v21) {
                  double v40 = v41;
                }
                *BOOL v38 = v40;
                double v36 = v36 + v40;
              }
              v38 += a4;
              --v39;
            }
            while (v39);
          }
        }
      }
      if (a8)
      {
        double v28 = 0.0;
        if (a5 >= 1)
        {
          double v29 = *a8;
          double v30 = a8[2] * 0.0;
          do
          {
            double v31 = v30 + v29 * *a3;
            *a3 = v31;
            double v28 = v28 + v31;
            a3 += a4;
            --a5;
          }
          while (a5);
        }
      }
    }
  }
  else
  {
    BOOL AdvancesForGlyphsWithStyleFromCG = TFont::GetAdvancesForGlyphsWithStyleFromCG(a1, a7, a2, a3, a4, a5, (uint64_t)&v50, v18 >> 63, UnscaledTrackAmount, v20);
    double v23 = 0.0;
    if (AdvancesForGlyphsWithStyleFromCG)
    {
      if (a8)
      {
        if (a5 >= 1)
        {
          double v24 = *a8;
          double v25 = a8[2] * 0.0;
          do
          {
            double v26 = v25 + v24 * *a3;
            *a3 = v26;
            double v23 = v23 + v26;
            a3 += a4;
            --a5;
          }
          while (a5);
        }
      }
      else
      {
        __C.double a = NAN;
        vDSP_sveD(a3, a4, &__C.a, a5);
      }
    }
  }
}

uint64_t TUnicodeEncoder::Encode(char ***this, const __CTFont *a2, const __CFString *a3, TCharStreamIterator *a4, CFRange a5, unsigned __int16 *a6, double *a7, unsigned int *a8, double *a9, BOOL a10)
{
  CFIndex location = a5.location;
  uint64_t v101 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *((void *)a2 + 5);
  uint64_t v88 = *(TBaseFont **)(v10 + 400);
  if (v88)
  {
    CFIndex length = a5.length;
    uint64_t v15 = *(void *)(v10 + 40);
    if (v15 && *(double *)(v15 + 8) * *(double *)(v15 + 16) != 0.0 || (*(unsigned char *)v10 & 1) != 0 || *(unsigned char *)(v10 + 392)) {
      char v84 = 1;
    }
    else {
      char v84 = (*(uint64_t (**)(TBaseFont *))(*(void *)v88 + 712))(v88);
    }
    double UnscaledTrackAmount = TFont::GetUnscaledTrackAmount((TFont *)v10);
    TFont::GetScaledMatrix((TFont *)v10, (CGAffineTransform *)&v96);
    if (length >= 1)
    {
      int v17 = 0;
      uint64_t v18 = location + length;
      unint64_t v85 = (char *)a4 + 8;
      double v19 = v96;
      uint64_t v20 = location;
      unsigned int v89 = a7;
      float v83 = a4;
      uint64_t v91 = a6;
      uint64_t v81 = v18;
      while (1)
      {
        uint64_t v95 = v20;
        unsigned int Char = TCharStreamIterator::GetChar(a4, v20);
        if ((Char & 0xFC00) == 0xD800 && v20 + 1 < v18)
        {
          int v60 = TCharStreamIterator::GetChar(a4, v20 + 1);
          if ((v60 & 0xFC00) == 0xDC00)
          {
            unsigned int Char = v60 + (Char << 10) - 56613888;
            uint64_t v95 = v20 + 1;
          }
        }
        CFIndex v23 = *((void *)a4 + 22);
        uint64_t v24 = *((void *)a4 + 23);
        double v25 = (char *)*((void *)a4 + 18);
        double v26 = v85;
        if (*((void *)a4 + 19)) {
          double v26 = 0;
        }
        if (!v25) {
          double v25 = v26;
        }
        if (v25) {
          uint64_t v27 = (uint64_t)&v25[-2 * v23];
        }
        else {
          uint64_t v27 = 0;
        }
        if (v18 >= v24) {
          uint64_t v28 = *((void *)a4 + 23);
        }
        else {
          uint64_t v28 = v18;
        }
        uint64_t v29 = location;
        if (v23 > location || location >= v24)
        {
          uint64_t v31 = v28 - v23;
          if (v23 < v18) {
            uint64_t v32 = *((void *)a4 + 22);
          }
          else {
            uint64_t v32 = 0;
          }
          if (v23 >= v18) {
            uint64_t v31 = 0;
          }
          if (location <= v23) {
            uint64_t v29 = v32;
          }
          else {
            uint64_t v29 = 0;
          }
          if (location <= v23) {
            uint64_t v30 = v31;
          }
          else {
            uint64_t v30 = 0;
          }
        }
        else
        {
          uint64_t v30 = v28 - location;
        }
        uint64_t v33 = (uint64_t)v91;
        uint64_t v87 = v30;
        uint64_t v34 = v29 + v30;
        if (v84)
        {
          uint64_t v35 = v20;
          uint64_t v20 = v29 + v30;
          goto LABEL_92;
        }
        uint64_t v82 = v27;
        uint64_t v92 = v29;
        double v36 = (void **)TBaseFont::AcquireBMPDataCache((atomic_ullong *)v88);
        if (v36) {
          break;
        }
        uint64_t v35 = v20;
LABEL_91:
        uint64_t v20 = v34;
        uint64_t v29 = v92;
        uint64_t v27 = v82;
LABEL_92:
        uint64_t v93 = v29;
        if (v20 - v35 < 1)
        {
          uint64_t v20 = v35;
          if ((v17 & 1) == 0) {
            goto LABEL_96;
          }
        }
        else
        {
          *(void *)&long long v62 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v62 + 1) = 0xAAAAAAAAAAAAAAAALL;
          v99[2] = v62;
          v99[3] = v62;
          v99[0] = v62;
          v99[1] = v62;
          double v96 = 0.0;
          double v97 = 0.0;
          unsigned int v98 = 0;
          uint64_t v100 = v99;
          if (!v27) {
            uint64_t v27 = TCharStream::LazyCopyChars(*(void **)a4, v29, v87) - 2 * v29;
          }
          uint64_t v63 = v27 + 2 * v35;
          (*(void (**)(TBaseFont *, uint64_t, uint64_t, uint64_t))(*(void *)v88 + 664))(v88, v63, v33 + 2 * v35, v20 - v35);
          a7 = v89;
          TFont::GetUnsummedAdvancesForGlyphs(v10, v33 + 2 * v35, &v89[v35], 1, v20 - v35, 0, 0);
          bzero(&a8[v35], 4 * (v20 - v35));
          v17 |= TUnicodeEncoder::EncodePortion(this, v35, v63, v20 - v35, (uint64_t)v88, a10, v33, (uint64_t)v89, 1, (uint64_t)a8, a9, 0);
          v94[0] = (void **)&v96;
          std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100](v94);
          uint64_t v18 = v81;
          if ((v17 & 1) == 0)
          {
LABEL_96:
            BOOL v64 = TBaseFont::GetShapingType(v88) == 2;
            CFHashCode v65 = (atomic_ullong *)v10;
            a4 = v83;
            uint64_t v66 = v93;
            if (!v64) {
              goto LABEL_142;
            }
            uint64_t v67 = *(void *)(v10 + 400);
            if ((*(_DWORD *)(v67 + 184) & 0x400) == 0)
            {
              TBaseFont::DetermineFontFlags(*(TBaseFont **)(v10 + 400), 0x400u);
              uint64_t v66 = v93;
              CFHashCode v65 = (atomic_ullong *)v10;
            }
            if ((*(_DWORD *)(v67 + 180) & 0x400) != 0)
            {
LABEL_142:
              if (!v65[40])
              {
                TFont::InitShapingGlyphs((TFont *)v10);
                uint64_t v66 = v93;
                CFHashCode v65 = (atomic_ullong *)v10;
              }
              v17 |= TFont::NeedsShapingForGlyphs(v65, (const unsigned __int16 *)(v33 + 2 * v66), v87, a3);
            }
            else
            {
              v17 |= 1u;
            }
            goto LABEL_107;
          }
        }
        a4 = v83;
LABEL_107:
        if (v20 >= v18) {
          return (char)v17;
        }
      }
      v94[1] = 0;
      v94[2] = (void **)0xAAAAAAAAFFFFFFFFLL;
      double v37 = 0.0;
      unint64_t v80 = (os_unfair_lock_s *)v36;
      v94[0] = v36;
      while (1)
      {
        if (Char >> 11 >= 0x1B)
        {
          if (Char < 0xE000) {
            goto LABEL_89;
          }
          if (Char >> 9 >= 0x7F && (Char >> 4 < 0xFE1 || Char - 917760 <= 0xEF)) {
            break;
          }
        }
        *a9 = v37 + *a9;
        TBMPDataCache::Iterator::GetDataForCharacter((TBMPDataCache::Iterator *)v94, Char, (uint64_t)&v96);
        int v38 = LOWORD(v96);
        unsigned int v39 = v98;
        double v40 = -0.0;
        if (v97 != 0.0) {
          double v40 = UnscaledTrackAmount;
        }
        double v41 = v97 + v40;
        int v42 = v17 | 8;
        if (LOWORD(v96)) {
          int v42 = v17;
        }
        if ((v98 & 0x50) != 0) {
          v42 |= 4u;
        }
        if ((v98 & 0x20) != 0)
        {
          double v41 = 0.0;
          int v43 = v42 | 0x10;
        }
        else
        {
          int v43 = v42;
        }
        double v44 = v19 * v41;
        *(_WORD *)(v33 + 2 * v20) = LOWORD(v96);
        a7[v20] = v19 * v41;
        a8[v20] = v39 & 0xFFFF7FFF;
        if (v20 < v95 && v95 < v18)
        {
          ++v20;
          if (v38)
          {
            *(_WORD *)(v33 + 2 * v20) = -1;
            a7[v20] = 0.0;
            uint64_t v45 = *this;
            double v46 = (*this)[1];
            double v47 = (*this)[2];
            if (v46 >= v47)
            {
              CGAffineTransform v49 = *v45;
              uint64_t v50 = (v46 - *v45) >> 3;
              unint64_t v51 = v50 + 1;
              if ((unint64_t)(v50 + 1) >> 61) {
                abort();
              }
              uint64_t v52 = v47 - v49;
              if (v52 >> 2 > v51) {
                unint64_t v51 = v52 >> 2;
              }
              if ((unint64_t)v52 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v53 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v53 = v51;
              }
              *((void *)&v99[0] + 1) = v45 + 3;
              if (v53)
              {
                BOOL v54 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)(v45 + 3), v53);
                CGAffineTransform v49 = *v45;
                double v46 = v45[1];
              }
              else
              {
                BOOL v54 = 0;
              }
              uint64_t v55 = (uint64_t *)&v54[8 * v50];
              *uint64_t v55 = v20;
              if (v46 == v49)
              {
                uint64_t v57 = &v54[8 * v50];
              }
              else
              {
                uint64_t v56 = v46;
                uint64_t v57 = &v54[8 * v50];
                do
                {
                  uint64_t v58 = *((void *)v56 - 1);
                  v56 -= 8;
                  *((void *)v57 - 1) = v58;
                  v57 -= 8;
                }
                while (v56 != v49);
              }
              CGAffineTransform v48 = (char *)(v55 + 1);
              *uint64_t v45 = v57;
              double v96 = *(double *)&v49;
              double v97 = *(double *)&v49;
              v45[1] = (char *)(v55 + 1);
              unsigned int v98 = v46;
              uint64_t v59 = v45[2];
              v45[2] = &v54[8 * v53];
              *(void *)&v99[0] = v59;
              std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v96);
            }
            else
            {
              *(void *)double v46 = v20;
              CGAffineTransform v48 = v46 + 8;
            }
            v45[1] = v48;
            a7 = v89;
            uint64_t v33 = (uint64_t)v91;
          }
        }
        int v17 = v43 | (v39 >> 14) & 2;
        double v37 = v44 + 0.0;
        if (++v20 >= v34) {
          goto LABEL_89;
        }
        uint64_t v95 = v20;
        unsigned int Char = TCharStreamIterator::GetFullChar(a4, &v95, 0);
      }
      if (v20 < 1)
      {
LABEL_89:
        uint64_t v35 = v20;
        goto LABEL_90;
      }
      __int16 v61 = TCharStreamIterator::GetChar(a4, v20 - 1);
      if (v20 != 1 && (v61 & 0xFC00) == 0xDC00)
      {
        uint64_t v35 = v20 - 2;
        if ((TCharStreamIterator::GetChar(a4, v20 - 2) & 0xFC00) == 0xD800) {
          goto LABEL_87;
        }
        TCharStreamIterator::GetChar(a4, v20 - 1);
      }
      uint64_t v35 = v20 - 1;
LABEL_87:
      if (v35 >= location) {
        double v37 = v37 - a7[v35];
      }
      else {
        uint64_t v35 = v20;
      }
      uint64_t v33 = (uint64_t)v91;
      CFIndex v68 = *((void *)a4 + 22);
      uint64_t v69 = *((void *)a4 + 23);
      uint8x8_t v70 = (char *)*((void *)a4 + 18);
      unint64_t v71 = v85;
      if (*((void *)a4 + 19)) {
        unint64_t v71 = 0;
      }
      if (!v70) {
        uint8x8_t v70 = v71;
      }
      if (v70) {
        uint64_t v72 = (uint64_t)&v70[-2 * v68];
      }
      else {
        uint64_t v72 = 0;
      }
      if (v18 >= v69) {
        uint64_t v73 = *((void *)a4 + 23);
      }
      else {
        uint64_t v73 = v18;
      }
      CFIndex v74 = location;
      if (v68 > location || location >= v69)
      {
        uint64_t v76 = v73 - v68;
        if (v68 < v18) {
          CFIndex v77 = *((void *)a4 + 22);
        }
        else {
          CFIndex v77 = 0;
        }
        if (v68 >= v18) {
          uint64_t v76 = 0;
        }
        if (location <= v68) {
          CFIndex v74 = v77;
        }
        else {
          CFIndex v74 = 0;
        }
        if (location <= v68) {
          uint64_t v75 = v76;
        }
        else {
          uint64_t v75 = 0;
        }
      }
      else
      {
        uint64_t v75 = v73 - location;
      }
      uint64_t v82 = v72;
      uint64_t v87 = v75;
      uint64_t v92 = v74;
      uint64_t v34 = v74 + v75;
LABEL_90:
      os_unfair_lock_unlock(v80 + 2);
      *a9 = v37 + *a9;
      goto LABEL_91;
    }
    LOBYTE(v17) = 0;
  }
  else
  {
    LOBYTE(v17) = 8;
  }
  return (char)v17;
}

void TFont::GetUnsummedAdvancesForGlyphs(uint64_t a1, uint64_t a2, double *a3, int a4, uint64_t a5, int a6, uint64_t a7)
{
  v14.f64[0] = NAN;
  v14.f64[1] = NAN;
  float64x2_t v32 = v14;
  float64x2_t v33 = v14;
  float64x2_t v31 = v14;
  TFont::GetEffectiveMatrix((TFont *)a1, (uint64_t)&v31);
  int64x2_t v15 = (int64x2_t)vandq_s8((int8x16_t)vceqq_f64(v31, (float64x2_t)xmmword_184B895C0), vandq_s8((int8x16_t)vceqq_f64(v32, (float64x2_t)xmmword_184B87DE0), (int8x16_t)vceqzq_f64(v33)));
  unint64_t v16 = vandq_s8((int8x16_t)v15, (int8x16_t)vdupq_laneq_s64(v15, 1)).u64[0];
  double UnscaledTrackAmount = TFont::GetUnscaledTrackAmount((TFont *)a1);
  int v18 = (*(uint64_t (**)(void))(**(void **)(a1 + 400) + 712))();
  int v19 = v18;
  if ((a7 & 0xFF00000000) != 0) {
    a7 = a7;
  }
  else {
    a7 = 5;
  }
  if (a6 == 2 || !a6 && (*(unsigned char *)a1 & 1) != 0)
  {
    if (GetUnscaledAdvances(a1, a2, (uint64_t)a3, a4, a5, a6))
    {
      if (*(unsigned char *)(a1 + 392))
      {
        if ((a7 & 4) != 0) {
          int v20 = v19;
        }
        else {
          int v20 = 1;
        }
        ApplyFixedAdvances((const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)(a1 + 160), memory_order_acquire), v20, a5, a3, a4);
      }
      else
      {
        TFont::GetScaleFactor((double *)a1);
        if ((v16 & 0x8000000000000000) != 0)
        {
          BOOL v27 = v21 != 1.0;
          if (UnscaledTrackAmount != 0.0) {
            BOOL v27 = 1;
          }
          if (a5 >= 1 && v27 | v19)
          {
            do
            {
              if (*a3 != 0.0)
              {
                double v28 = v21 * (UnscaledTrackAmount + *a3);
                *a3 = v28;
                if (v19) {
                  *a3 = round(v28);
                }
              }
              a3 += a4;
              --a5;
            }
            while (a5);
          }
        }
        else
        {
          *(void *)&long long v22 = -1;
          *((void *)&v22 + 1) = -1;
          *(_OWORD *)&v30.c = v22;
          *(_OWORD *)&v30.tx = v22;
          *(_OWORD *)&v30.double a = v22;
          CGAffineTransformMakeScale(&v29, v21, v21);
          *(float64x2_t *)&t1.double a = v31;
          *(float64x2_t *)&t1.c = v32;
          *(float64x2_t *)&t1.tx = v33;
          CGAffineTransform t2 = v29;
          CGAffineTransformConcat(&v30, &t1, &t2);
          if (a5 >= 1)
          {
            double a = v30.a;
            double v24 = v30.c * 0.0;
            do
            {
              if (*a3 != 0.0)
              {
                double v25 = v24 + a * (UnscaledTrackAmount + *a3);
                double v26 = round(v25);
                if (v19) {
                  double v25 = v26;
                }
                *a3 = v25;
              }
              a3 += a4;
              --a5;
            }
            while (a5);
          }
        }
      }
    }
  }
  else
  {
    TFont::GetAdvancesForGlyphsWithStyleFromCG(a1, a7, a2, a3, a4, a5, (uint64_t)&v31, v16 >> 63, UnscaledTrackAmount, v18);
  }
}

double TFont::GetUnscaledTrackAmount(TFont *this)
{
  signed int valuePtr = -1431655766;
  int v1 = *((_DWORD *)this + 8);
  if (v1 == 0x80000000)
  {
    signed int valuePtr = 0;
    CFDictionaryRef v3 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)this + 20, memory_order_acquire);
    if (v3)
    {
      CFDictionaryRef v4 = v3;
      CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v3, @"NSCTFontUnscaledTrackingAttribute");

      if (Value)
      {
        CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
        goto LABEL_16;
      }
    }
    else
    {
    }
    uint64_t v6 = (_DWORD *)*((void *)this + 50);
    double v7 = *((double *)this + 3);
    if (v7 <= 0.0)
    {
      if ((v6[46] & 0x100) == 0) {
        TBaseFont::DetermineFontFlags(*((TBaseFont **)this + 50), 0x100u);
      }
      if ((v6[45] & 0x100) == 0 || !(*(unsigned int (**)(_DWORD *))(*(void *)v6 + 696))(v6)) {
        goto LABEL_16;
      }
      double v7 = *((double *)this + 2);
    }
    if (v7 != 0.0)
    {
      unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)this + 20, memory_order_acquire);
      inited = (int *)((char *)this + 48);
      int v10 = *(_DWORD *)this;
      if (!*((_DWORD *)this + 12)) {
        inited = TFont::InitStrikeMetrics(this);
      }
      signed int valuePtr = (int)(*(double (**)(_DWORD *, unint64_t, void, void, double))(*(void *)v6 + 552))(v6, explicit, v10 & 1, *inited, v7);
    }
LABEL_16:
    atomic_exchange((atomic_uint *volatile)this + 8, valuePtr);
    return (double)valuePtr;
  }
  return (double)v1;
}

CGAffineTransform *TFont::GetScaledMatrix@<X0>(TFont *this@<X0>, CGAffineTransform *a2@<X8>)
{
  TFont::GetScaleFactor((double *)this);
  CGFloat v5 = v4;
  TFont::GetEffectiveMatrix(this, (uint64_t)&v8);
  *(void *)&long long v6 = -1;
  *((void *)&v6 + 1) = -1;
  *(_OWORD *)&v11.c = v6;
  *(_OWORD *)&v11.tx = v6;
  *(_OWORD *)&v11.double a = v6;
  CGAffineTransformMakeScale(&v11, v5, v5);
  CGAffineTransform t1 = v8;
  CGAffineTransform t2 = v11;
  return CGAffineTransformConcat(a2, &t1, &t2);
}

BOOL TFont::GetAdvancesForGlyphsWithStyleFromCG(uint64_t a1, uint64_t a2, uint64_t a3, double *a4, int a5, uint64_t a6, uint64_t a7, int a8, double a9, unsigned __int8 a10)
{
  uint64_t InitializedGraphicsFont = TBaseFont::GetInitializedGraphicsFont(*(TBaseFont **)(a1 + 400));
  if ((~a2 & 5) == 0 && a5 == 1 && !*(unsigned char *)(a1 + 392) && CGFontGetParserFont())
  {
    *(void *)&long long v25 = -1;
    *((void *)&v25 + 1) = -1;
    *(_OWORD *)&v39.c = v25;
    *(_OWORD *)&v39.tx = v25;
    *(_OWORD *)&v39.double a = v25;
    TFont::GetScaleFactor((double *)a1);
    CGAffineTransformMakeScale(&v39, v26, v26);
    if ((a8 & 1) == 0)
    {
      long long v27 = *(_OWORD *)(a7 + 16);
      *(_OWORD *)&t1.double a = *(_OWORD *)a7;
      *(_OWORD *)&t1.c = v27;
      *(_OWORD *)&t1.tx = *(_OWORD *)(a7 + 32);
      CGAffineTransform t2 = v39;
      CGAffineTransformConcat(&v38, &t1, &t2);
      CGAffineTransform v39 = v38;
    }
    FPFontGetGlyphIdealAdvanceWidths();
    if (a6 >= 1)
    {
      double a = v39.a;
      double v29 = v39.c * 0.0;
      CGAffineTransform v30 = a4;
      uint64_t v31 = a6;
      do
      {
        if (*v30 != 0.0) {
          double *v30 = v29 + a * (*v30 + a9);
        }
        ++v30;
        --v31;
      }
      while (v31);
      if (a10)
      {
        unint64_t v32 = a6 + 1;
        do
        {
          *a4 = round(*a4);
          ++a4;
          --v32;
        }
        while (v32 > 1);
      }
    }
    return 1;
  }
  if (a2)
  {
    if ((a2 & 4) != 0) {
      int v22 = a10;
    }
    else {
      int v22 = 1;
    }
    BOOL result = GetGlyphAdvancesForStyle(InitializedGraphicsFont, 0, a2 | 4, a3, a6, a4, a5);
    if (result)
    {
      if (*(unsigned char *)(a1 + 392))
      {
        ApplyFixedAdvances((const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)(a1 + 160), memory_order_acquire), v22, a6, a4, a5);
      }
      else
      {
        *(void *)&long long v33 = -1;
        *((void *)&v33 + 1) = -1;
        *(_OWORD *)&t1.c = v33;
        *(_OWORD *)&t1.tx = v33;
        *(_OWORD *)&t1.double a = v33;
        TFont::GetScaledMatrix((TFont *)a1, &t1);
        if (a6 >= 1)
        {
          double v34 = t1.a;
          double v35 = t1.c * 0.0;
          do
          {
            if (*a4 != 0.0)
            {
              double v36 = v35 + v34 * (*a4 + a9);
              double v37 = round(v36);
              if (v22) {
                double v36 = v37;
              }
              *a4 = v36;
            }
            a4 += a5;
            --a6;
          }
          while (a6);
        }
      }
      return 1;
    }
  }
  else
  {
    double EffectiveSize = TFont::GetEffectiveSize((TFont *)a1);
    *(void *)&long long v21 = -1;
    *((void *)&v21 + 1) = -1;
    *(_OWORD *)&t2.c = v21;
    *(_OWORD *)&t2.tx = v21;
    *(_OWORD *)&t2.double a = v21;
    if (a8)
    {
      CGAffineTransformMakeScale(&t2, EffectiveSize, EffectiveSize);
    }
    else
    {
      CGFloat v24 = *(double *)(a7 + 16);
      t1.double a = *(CGFloat *)a7;
      t1.b = 0.0;
      t1.c = v24;
      t1.d = 1.0;
      *(_OWORD *)&t1.tx = *(_OWORD *)(a7 + 32);
      CGAffineTransformScale(&t2, &t1, EffectiveSize, EffectiveSize);
    }
    return GetGlyphAdvancesForStyle(InitializedGraphicsFont, (uint64_t)&t2, a2, a3, a6, a4, a5);
  }
  return result;
}

uint64_t TBaseFont::GetInitializedGraphicsFont(TBaseFont *this)
{
  uint64_t explicit = (*(uint64_t (**)(TBaseFont *))(*(void *)this + 568))(this);
  if (!explicit)
  {
    (*(void (**)(id *__return_ptr, TBaseFont *))(*(void *)this + 496))(&v4, this);
    uint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&v4, memory_order_acquire);
  }
  return explicit;
}

unint64_t TTenuousComponentFont::GetGraphicsFont(atomic_ullong *this)
{
  if (atomic_load_explicit(this + 96, memory_order_acquire) && !*((unsigned char *)this + 792))
  {
    TTenuousComponentFont::InitializeVariationGraphicsFont(this);
    uint64_t v2 = this + 98;
  }
  else
  {
    uint64_t v2 = this + 13;
  }
  return atomic_load_explicit(v2, memory_order_acquire);
}

void TTenuousComponentFont::InitializeVariationGraphicsFont(atomic_ullong *this)
{
  if (!atomic_load_explicit(this + 98, memory_order_acquire)
    && (*(unsigned int (**)(atomic_ullong *))(*this + 896))(this))
  {
    id v7 = (id)0xAAAAAAAAAAAAAAAALL;
    TBaseFont::CopyNativeFont(this, &v7);
    id v6 = 0;
    if (*((unsigned char *)this + 793)) {
      CreateFontWithVariation((CGFont *)atomic_load_explicit((atomic_ullong *volatile)&v7, memory_order_acquire), (const __CFDictionary *)atomic_load_explicit(this + 96, memory_order_acquire), (atomic_ullong *)&v5);
    }
    else {
      TCGFontCache::CopyFontWithOpticalSizeVariation((TCGFontCache *)atomic_load_explicit((atomic_ullong *volatile)&v7, memory_order_acquire), (CGFont *)atomic_load_explicit(this + 10, memory_order_acquire), (CFDictionaryRef)atomic_load_explicit(this + 96, memory_order_acquire), (atomic_ullong *)&v5);
    }

    uint64_t v2 = 0;
    unint64_t v3 = atomic_exchange((atomic_ullong *volatile)&v6, 0);
    atomic_compare_exchange_strong(this + 98, (unint64_t *)&v2, v3);
    if (v2) {
      id v4 = (void *)v3;
    }
    else {
      id v4 = 0;
    }
  }
}

double *TFont::GetScaleFactor(double *this)
{
  if (this[18] == 0.0)
  {
    uint64_t v1 = (uint64_t)this;
    double EffectiveSize = TFont::GetEffectiveSize((TFont *)this);
    if (*(_DWORD *)(v1 + 48)) {
      this = (double *)(v1 + 48);
    }
    else {
      this = (double *)TFont::InitStrikeMetrics((TFont *)v1);
    }
    *(double *)(v1 + 144) = EffectiveSize / (double)*(unsigned int *)this;
  }
  return this;
}

uint64_t TBMPDataCache::Iterator::GetDataForCharacter@<X0>(TBMPDataCache::Iterator *this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  unsigned __int8 v3 = a2;
  unsigned int v6 = a2 & 0xFFFFFF00;
  if ((a2 & 0xFFFFFF00) == *((_DWORD *)this + 4))
  {
    uint64_t result = *((void *)this + 1);
LABEL_5:
    int v8 = *(unsigned __int16 *)(*(void *)(result + 1568)
                             + 2
                             * ((v3 & 7)
                              + *(unsigned __int8 *)(result + ((unint64_t)v3 >> 3) + 1536)));
    float v9 = *(float *)(result + 4 * v3 + 512);
    *(_WORD *)a3 = *(_WORD *)(result + 2 * v3);
    *(double *)(a3 + 8) = v9;
    *(_DWORD *)(a3 + 16) = v8;
    return result;
  }
  uint64_t result = TBMPDataCache::PageForCharacter(*(os_unfair_lock_s **)this, a2);
  if (result)
  {
    *((void *)this + 1) = result;
    *((_DWORD *)this + 4) = v6;
    goto LABEL_5;
  }
  *(_WORD *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 16) = 0;
  return result;
}

uint64_t TBMPDataCache::PageForCharacter(os_unfair_lock_s *this, unsigned int a2)
{
  unsigned int v8 = a2 >> 8;
  float v9 = &v8;
  id v4 = std::__hash_table<std::__hash_value_type<unsigned int,std::unique_ptr<TUnicodeDataCachePage>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::unique_ptr<TUnicodeDataCachePage>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::unique_ptr<TUnicodeDataCachePage>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::unique_ptr<TUnicodeDataCachePage>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)&this[4], &v8, (uint64_t)&std::piecewise_construct, &v9)+ 3;
  if (*v4) {
    return *v4;
  }
  os_unfair_lock_unlock(this + 2);
  unsigned int v6 = (TBMPDataCachePage *)operator new(0x680uLL, MEMORY[0x1E4FBA2D0]);
  uint64_t v7 = (uint64_t)v6;
  if (!HIWORD(a2))
  {
    if (v6)
    {
      TBMPDataCachePage::TBMPDataCachePage(v6, *(const TBaseFont **)&this->_os_unfair_lock_opaque, a2);
      goto LABEL_9;
    }
LABEL_11:
    os_unfair_lock_lock_with_options();
    return 0;
  }
  if (!v6) {
    goto LABEL_11;
  }
  TSupplementaryDataCachePage::TSupplementaryDataCachePage(v6, *(const TBaseFont **)&this->_os_unfair_lock_opaque);
LABEL_9:
  os_unfair_lock_lock_with_options();
  if (*v4)
  {
    float v9 = (unsigned int *)(v7 + 1568);
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v9);
    MEMORY[0x1853275C0](v7, 0x1010C40E4D70334);
  }
  else
  {
    std::unique_ptr<TUnicodeDataCachePage>::reset[abi:nn180100](v4, v7);
  }
  return *v4;
}

void *std::__hash_table<std::__hash_value_type<unsigned int,std::unique_ptr<TUnicodeDataCachePage>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::unique_ptr<TUnicodeDataCachePage>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::unique_ptr<TUnicodeDataCachePage>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::unique_ptr<TUnicodeDataCachePage>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(uint64_t a1, unsigned int *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v6 = *a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v9 = *a2;
      if (v7 <= v6) {
        unint64_t v9 = v6 % v7;
      }
    }
    else
    {
      unint64_t v9 = (v7 - 1) & v6;
    }
    int v10 = *(void ***)(*(void *)a1 + 8 * v9);
    if (v10)
    {
      CGAffineTransform v11 = *v10;
      if (*v10)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v12 == v6)
          {
            if (*((_DWORD *)v11 + 4) == v6) {
              return v11;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v12 >= v7) {
                v12 %= v7;
              }
            }
            else
            {
              v12 &= v7 - 1;
            }
            if (v12 != v9) {
              break;
            }
          }
          CGAffineTransform v11 = (void *)*v11;
        }
        while (v11);
      }
    }
  }
  else
  {
    unint64_t v9 = 0xAAAAAAAAAAAAAAAALL;
  }
  CGAffineTransform v11 = operator new(0x20uLL);
  void *v11 = 0;
  v11[1] = v6;
  *((_DWORD *)v11 + 4) = **a4;
  v11[3] = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    std::__hash_table<std::__hash_value_type<unsigned int,OTL::Lookup>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,OTL::Lookup>>>::__rehash<true>(a1, v18);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v9 = v6 % v7;
      }
      else {
        unint64_t v9 = v6;
      }
    }
    else
    {
      unint64_t v9 = (v7 - 1) & v6;
    }
  }
  uint64_t v19 = *(void *)a1;
  int v20 = *(void **)(*(void *)a1 + 8 * v9);
  if (v20)
  {
    void *v11 = *v20;
LABEL_38:
    void *v20 = v11;
    goto LABEL_39;
  }
  void *v11 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v11;
  *(void *)(v19 + 8 * v9) = a1 + 16;
  if (*v11)
  {
    unint64_t v21 = *(void *)(*v11 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v21 >= v7) {
        v21 %= v7;
      }
    }
    else
    {
      v21 &= v7 - 1;
    }
    int v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v11;
}

_DWORD *TBaseFont::AcquireBMPDataCache(atomic_ullong *this)
{
  unint64_t explicit = atomic_load_explicit(this + 26, memory_order_acquire);
  if (explicit) {
    goto LABEL_2;
  }
  uint64_t result = operator new(0x38uLL, MEMORY[0x1E4FBA2D0]);
  unint64_t explicit = (unint64_t)result;
  if (result)
  {
    unint64_t v5 = 0;
    *(void *)uint64_t result = this;
    result[2] = 0;
    *((_OWORD *)result + 1) = 0u;
    uint64_t v4 = (uint64_t)(result + 4);
    *(_OWORD *)(explicit + 32) = 0u;
    *(_DWORD *)(explicit + 48) = 1065353216;
    atomic_compare_exchange_strong(this + 26, &v5, explicit);
    if (v5)
    {
      std::__hash_table<std::__hash_value_type<unsigned int,std::unique_ptr<TUnicodeDataCachePage>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::unique_ptr<TUnicodeDataCachePage>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::unique_ptr<TUnicodeDataCachePage>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::unique_ptr<TUnicodeDataCachePage>>>>::~__hash_table(v4);
      MEMORY[0x1853275C0](explicit, 0x10E0C4057E07A5FLL);
      unint64_t explicit = v5;
    }
    goto LABEL_2;
  }
  atomic_compare_exchange_strong(this + 26, &explicit, 0);
  if (explicit)
  {
LABEL_2:
    os_unfair_lock_lock_with_options();
    return (_DWORD *)explicit;
  }
  return result;
}

int *TFont::InitStrikeMetrics(TFont *this)
{
  uint64_t v2 = (int *)((char *)this + 48);
  TFont::GetStrikeMetrics((TBaseFont **)this, *(_DWORD *)this & 1, (uint64_t)&v4);
  if (v2 != &v4)
  {
    *((_DWORD *)this + 12) = v4;
    *(_OWORD *)((char *)this + 56) = v5;
    *(_OWORD *)((char *)this + 72) = v6;
    *(_OWORD *)((char *)this + 88) = v7;
    *(_OWORD *)((char *)this + 104) = v8;
    *(_OWORD *)((char *)this + 120) = v9;
    *((unsigned char *)this + 136) = v10;
  }
  return v2;
}

void TFont::GetStrikeMetrics(TBaseFont **this@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  v6.f64[0] = NAN;
  v6.f64[1] = NAN;
  float64x2_t v12 = v6;
  float64x2_t v13 = v6;
  float64x2_t v11 = v6;
  __n128 EffectiveMatrix = TFont::GetEffectiveMatrix((TFont *)this, (uint64_t)&v11);
  if ((*(unsigned int (**)(__n128))(*(void *)this[50] + 720))(EffectiveMatrix)) {
    double EffectiveSize = *((double *)this + 2);
  }
  else {
    double EffectiveSize = TFont::GetEffectiveSize((TFont *)this);
  }
  int64x2_t v9 = (int64x2_t)vandq_s8((int8x16_t)vceqq_f64(v11, (float64x2_t)xmmword_184B895C0), vandq_s8((int8x16_t)vceqq_f64(v12, (float64x2_t)xmmword_184B87DE0), (int8x16_t)vceqzq_f64(v13)));
  if (vandq_s8((int8x16_t)v9, (int8x16_t)vdupq_laneq_s64(v9, 1)).i64[0] >= 0) {
    char v10 = (const CGAffineTransform *)&v11;
  }
  else {
    char v10 = 0;
  }
  TBaseFont::GetStrikeMetrics(this[50], EffectiveSize, v10, a2, a3);
}

double TFont::GetEffectiveSize(TFont *this)
{
  double v1 = *((double *)this + 51);
  if (v1 == 0.0)
  {
    double v1 = *((double *)this + 2);
    if (!(*(unsigned int (**)(void))(**((void **)this + 50) + 712))(*((void *)this + 50)))
    {
LABEL_11:
      *((double *)this + 51) = v1;
      return v1;
    }
    if ((*(unsigned char *)this & 0x10) == 0)
    {
      if (v1 <= 16.0)
      {
        double v3 = v1 * 0.25;
      }
      else
      {
        double v3 = 0.0;
        if (v1 < 24.0) {
          double v3 = (24.0 - v1) * 0.5;
        }
      }
      double v1 = v1 + v3;
      if (v1 == *((double *)this + 2)) {
        double v1 = v1 + 0.0001;
      }
      goto LABEL_11;
    }
  }
  return v1;
}

void TBaseFont::GetStrikeMetrics(TBaseFont *this@<X0>, double a2@<D0>, const CGAffineTransform *a3@<X1>, int a4@<W2>, uint64_t a5@<X8>)
{
  long long v19 = xmmword_184BA8AA8;
  long long v20 = unk_184BA8AB8;
  long long v21 = xmmword_184BA8AC8;
  long long v22 = unk_184BA8AD8;
  long long v17 = __const__ZNK9TBaseFont16GetStrikeMetricsEdPK17CGAffineTransformb_metrics;
  long long v18 = unk_184BA8A98;
  if (a4)
  {
    (*(void (**)(long long *__return_ptr, TBaseFont *, uint64_t, double))(*(void *)this + 632))(&v17, this, 1, 0.0);
  }
  else
  {
    if (*((_DWORD *)this + 62)) {
      inited = (_DWORD *)((char *)this + 248);
    }
    else {
      inited = TBaseFont::InitFontMetrics(this, a2);
    }
    StrikeMetrics::StrikeMetrics((uint64_t)&v17, (uint64_t)inited);
    *((void *)&v18 + 1) = (*(double (**)(TBaseFont *, double, double))(*(void *)this + 640))(this, a2, *((double *)&v18 + 1));
  }
  *(void *)&long long v10 = -1;
  *((void *)&v10 + 1) = -1;
  *(_OWORD *)&v16.c = v10;
  *(_OWORD *)&v16.tx = v10;
  *(_OWORD *)&v16.double a = v10;
  CGAffineTransformMakeScale(&v16, a2 / (double)v17, a2 / (double)v17);
  if (a3)
  {
    long long v11 = *(_OWORD *)&a3->c;
    *(_OWORD *)&t1.double a = *(_OWORD *)&a3->a;
    *(_OWORD *)&t1.c = v11;
    *(_OWORD *)&t1.tx = *(_OWORD *)&a3->tx;
    CGAffineTransform t2 = v16;
    CGAffineTransformConcat(&v15, &t1, &t2);
    CGAffineTransform v16 = v15;
  }
  CGAffineTransform v12 = v16;
  StrikeMetrics::ApplyTransform((StrikeMetrics *)&v17, &v12);
  StrikeMetrics::StrikeMetrics(a5, (uint64_t)&v17);
}

__n128 StrikeMetrics::StrikeMetrics(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = 0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = *MEMORY[0x1E4F1DAD8];
  __n128 result = *(__n128 *)MEMORY[0x1E4F1DB28];
  long long v3 = *(_OWORD *)(MEMORY[0x1E4F1DB28] + 16);
  *(_OWORD *)(a1 + 56) = *MEMORY[0x1E4F1DB28];
  *(_OWORD *)(a1 + 72) = v3;
  *(unsigned char *)(a1 + 88) = 0;
  if (a1 != a2)
  {
    *(_DWORD *)a1 = *(_DWORD *)a2;
    *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
    *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
    *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
    __n128 result = *(__n128 *)(a2 + 56);
    long long v4 = *(_OWORD *)(a2 + 72);
    *(__n128 *)(a1 + 56) = result;
    *(_OWORD *)(a1 + 72) = v4;
    *(unsigned char *)(a1 + 88) = *(unsigned char *)(a2 + 88);
  }
  return result;
}

StrikeMetrics *StrikeMetrics::ApplyTransform(StrikeMetrics *this, CGAffineTransform *a2)
{
  CGRect v14 = *(CGRect *)((char *)this + 56);
  long long v4 = *(_OWORD *)&a2->c;
  *(_OWORD *)&v13.double a = *(_OWORD *)&a2->a;
  *(_OWORD *)&v13.c = v4;
  *(_OWORD *)&v13.tx = *(_OWORD *)&a2->tx;
  *(CGRect *)((char *)this + 56) = CGRectApplyAffineTransform(v14, &v13);
  a2->tx = 0.0;
  a2->ty = 0.0;
  double v5 = *((double *)this + 2);
  double v6 = *((double *)this + 1) * a2->d + a2->b * 0.0 + 0.0;
  *((double *)this + 1) = v6;
  double v7 = a2->ty + v5 * a2->d + a2->b * 0.0;
  *((double *)this + 2) = v7;
  double v8 = *((double *)this + 4);
  double v9 = a2->ty + *((double *)this + 3) * a2->d + a2->b * 0.0;
  *((double *)this + 3) = v9;
  double v10 = a2->ty + v8 * a2->d + a2->b * 0.0;
  *((double *)this + 4) = v10;
  float64x2_t v11 = vaddq_f64(vaddq_f64(*(float64x2_t *)&a2->a, *(float64x2_t *)&a2->c), *(float64x2_t *)&a2->tx);
  *(float64x2_t *)((char *)this + 40) = v11;
  if (v11.f64[1] < 0.0)
  {
    *((double *)this + 1) = -v6;
    *((double *)this + 2) = -v7;
    *((double *)this + 3) = -v9;
    *((double *)this + 4) = -v10;
  }
  return this;
}

uint64_t TTenuousComponentFont::IsAppleColorEmojiUI(TTenuousComponentFont *this)
{
  if ((*(uint64_t (**)(TTenuousComponentFont *))(*(void *)this + 848))(this)) {
    return 0;
  }
  if ((*((_DWORD *)this + 46) & 0x200) == 0) {
    TBaseFont::DetermineFontFlags(this, 0x200u);
  }
  return (*((_DWORD *)this + 45) >> 9) & 1;
}

double TComponentFont::GetOpticalLeading(TComponentFont *this, double a2, double a3)
{
  if ((*(unsigned int (**)(TComponentFont *))(*(void *)this + 840))(this))
  {
    CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)this + 90, memory_order_acquire);
    if (!explicit) {
      return InterpolateOpticalValue(a2, a3, *((double *)this + 75), *((double *)this + 76), *((double *)this + 83), *((double *)this + 82));
    }
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(explicit, @"lineSpacingOverride");
    if (!Value) {
      return InterpolateOpticalValue(a2, a3, *((double *)this + 75), *((double *)this + 76), *((double *)this + 83), *((double *)this + 82));
    }
    double valuePtr = NAN;
    CFNumberGetValue(Value, kCFNumberDoubleType, &valuePtr);
    if (valuePtr <= 0.0) {
      return InterpolateOpticalValue(a2, a3, *((double *)this + 75), *((double *)this + 76), *((double *)this + 83), *((double *)this + 82));
    }
  }
  return a3;
}

double InterpolateOpticalValue(double a1, double a2, double a3, double a4, double a5, double a6)
{
  if (a3 - a1 > -0.01 && a3 - a1 < 0.01)
  {
    if (a4 == 0.0) {
      return a2;
    }
    return a4;
  }
  if (a6 == 0.0) {
    return a4;
  }
  if (a6 - a4 > -0.01 && a6 - a4 < 0.01) {
    return a6;
  }
  if (a4 != 0.0) {
    a2 = a4;
  }
  double v7 = 0.0;
  if (a3 != a5) {
    double v7 = (a1 - a3) / (a5 - a3);
  }
  return std::__lerp[abi:nn180100]<double>(a2, a6, v7);
}

void TBaseFont::CopyNativeFont(atomic_ullong *this@<X0>, void *a2@<X8>)
{
  if (atomic_load_explicit(this + 13, memory_order_acquire))
  {
    *a2 = (id)atomic_load_explicit(this + 13, memory_order_acquire);
    return;
  }
  id v24 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr))(*this + 200))(&v24);
  if (!atomic_load_explicit((atomic_ullong *volatile)&v24, memory_order_acquire)) {
    goto LABEL_11;
  }
  id v23 = (id)0xAAAAAAAAAAAAAAAALL;
  CFDictionaryRef explicit = (TCGFontCache *)atomic_load_explicit((atomic_ullong *volatile)&v24, memory_order_acquire);
  CFStringRef v5 = (const __CFString *)atomic_load_explicit(this + 11, memory_order_acquire);
  if ((*(unsigned int (**)(atomic_ullong *))(*this + 16))(this) == 1414088260) {
    CFStringRef v6 = 0;
  }
  else {
    CFStringRef v6 = (const __CFString *)atomic_load_explicit(this + 12, memory_order_acquire);
  }
  TCGFontCache::CopyFont(explicit, v5, v6, (atomic_ullong *)&v23);
  if (!atomic_load_explicit((atomic_ullong *volatile)&v23, memory_order_acquire))
  {
    atomic_load_explicit((atomic_ullong *volatile)&v24, memory_order_acquire);
    atomic_load_explicit(this + 11, memory_order_acquire);
    atomic_load_explicit(this + 12, memory_order_acquire);
    CFLog();

LABEL_11:
    id v23 = (id)0xAAAAAAAAAAAAAAAALL;
    int v11 = (*(uint64_t (**)(atomic_ullong *))(*this + 16))(this);
    if (v11 == 1414809156 || v11 == 1413695044)
    {
      TDescriptorSource::TDescriptorSource((TDescriptorSource *)&v22);
      TDescriptorSource::CreateDefaultDescriptor(0, &v23);
    }
    else
    {
      TDescriptorSource::TDescriptorSource((TDescriptorSource *)&v22);
      TDescriptorSource::CopyLastResort(&v23);
    }
    id v22 = (id)0xAAAAAAAAAAAAAAAALL;
    TBaseFont::CopyNativeFontForDescriptor((atomic_ullong *)&v22, (atomic_uint *)this, atomic_load_explicit((atomic_ullong *volatile)&v23, memory_order_acquire));
    if (!atomic_load_explicit((atomic_ullong *volatile)&v22, memory_order_acquire))
    {
      int v13 = (*(uint64_t (**)(atomic_ullong *))(*this + 16))(this);
      if (v13 == 1414809156 || v13 == 1413695044)
      {
        TDescriptorSource::TDescriptorSource((TDescriptorSource *)v20);
        TDescriptorSource::CopyLastResort(&v21);

        TBaseFont::CopyNativeFontForDescriptor((atomic_ullong *)&v21, (atomic_uint *)this, atomic_load_explicit((atomic_ullong *volatile)&v23, memory_order_acquire));
      }
    }
    if (atomic_load_explicit((atomic_ullong *volatile)&v22, memory_order_acquire))
    {
      uint64_t v15 = 0;
      unint64_t v16 = atomic_exchange((atomic_ullong *volatile)&v22, 0);
      long long v17 = this + 13;
      atomic_compare_exchange_strong(v17, (unint64_t *)&v15, v16);
      if (v15) {
        long long v18 = (void *)v16;
      }
      else {
        long long v18 = 0;
      }

      id v19 = (id)atomic_load_explicit(v17, memory_order_acquire);
    }
    else
    {
      CFLog();
      id v19 = 0;
    }
    *a2 = v19;

    goto LABEL_33;
  }
  id v7 = (id)atomic_load_explicit((atomic_ullong *volatile)&v23, memory_order_acquire);
  uint64_t v8 = 0;
  double v9 = this + 13;
  atomic_compare_exchange_strong(v9, (unint64_t *)&v8, (unint64_t)v7);
  if (v8)
  {

    id v10 = (id)atomic_load_explicit(v9, memory_order_acquire);
  }
  else
  {

    id v10 = (id)atomic_exchange((atomic_ullong *volatile)&v23, 0);
  }
  *a2 = v10;
LABEL_33:
}

double std::__lerp[abi:nn180100]<double>(double a1, double a2, double a3)
{
  if (a1 <= 0.0 && a2 >= 0.0 || a1 >= 0.0 && a2 <= 0.0) {
    return (1.0 - a3) * a1 + a3 * a2;
  }
  BOOL v4 = a3 <= 1.0;
  if (a3 != 1.0)
  {
    double v5 = a1 + a3 * (a2 - a1);
    int v6 = v4;
    int v7 = (a2 > a1) ^ v6;
    if (v5 <= a2) {
      double v8 = a2;
    }
    else {
      double v8 = v5;
    }
    if (v5 < a2) {
      a2 = v5;
    }
    if (v7) {
      return v8;
    }
  }
  return a2;
}

uint64_t TBaseFont::IsAppleColorEmoji(TBaseFont *this)
{
  if ((*((_DWORD *)this + 46) & 0x40) == 0) {
    TBaseFont::DetermineFontFlags(this, 0x40u);
  }
  return (*((_DWORD *)this + 45) >> 6) & 1;
}

double TComponentFont::GetUnscaledTrackAmount(TComponentFont *this, const __CFDictionary *a2, double a3, const __CFData *a4, unsigned int a5)
{
  if ((*(unsigned int (**)(TComponentFont *))(*(void *)this + 840))(this))
  {
    double v10 = *((double *)this + 78);
    if (v10 != 0.0) {
      return InterpolateOpticalValue(a3, 0.0, *((double *)this + 75), v10, *((double *)this + 85), *((double *)this + 82))* (double)a5/ 1000.0;
    }
  }

  return TBaseFont::GetUnscaledTrackAmount(this, a2, a3, a4);
}

unint64_t TInstanceFont::GetGraphicsFont(atomic_ullong *this)
{
  return atomic_load_explicit(this + 79, memory_order_acquire);
}

BOOL GetGlyphAdvancesForStyle(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, void *a6, int a7)
{
  uint64_t v8 = a5;
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (a7 == 2) {
    return (CGFontGetGlyphAdvancesForStyle() & 1) != 0;
  }
  *(void *)&long long v9 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v19[28] = v9;
  v19[29] = v9;
  v19[26] = v9;
  v19[27] = v9;
  v19[24] = v9;
  v19[25] = v9;
  v19[22] = v9;
  v19[23] = v9;
  v19[20] = v9;
  v19[21] = v9;
  v19[18] = v9;
  v19[19] = v9;
  v19[16] = v9;
  v19[17] = v9;
  v19[15] = v9;
  v19[14] = v9;
  v19[13] = v9;
  v19[12] = v9;
  v19[11] = v9;
  v19[10] = v9;
  v19[9] = v9;
  v19[8] = v9;
  v19[7] = v9;
  v19[6] = v9;
  v19[4] = v9;
  v19[5] = v9;
  v19[2] = v9;
  v19[3] = v9;
  v19[0] = v9;
  v19[1] = v9;
  unint64_t v16 = 0;
  long long v17 = 0;
  uint64_t v18 = 0;
  long long v20 = v19;
  if (a5)
  {
    std::vector<CGPoint,TInlineBufferAllocator<CGPoint,30ul>>::__vallocate[abi:nn180100](&v16, a5);
    int v11 = (char *)v17;
    bzero(v17, 16 * v8);
    long long v17 = &v11[16 * v8];
    if (CGFontGetGlyphAdvancesForStyle())
    {
      if (v8 >= 1)
      {
        CGAffineTransform v12 = v16;
        do
        {
          uint64_t v13 = *(void *)v12;
          v12 += 16;
          *a6 = v13;
          a6 += a7;
          --v8;
        }
        while (v8);
      }
      goto LABEL_11;
    }
  }
  else if (CGFontGetGlyphAdvancesForStyle())
  {
LABEL_11:
    uint64_t v15 = &v16;
    std::vector<CGPoint,TInlineBufferAllocator<CGPoint,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v15);
    return 1;
  }
  uint64_t v15 = &v16;
  std::vector<CGPoint,TInlineBufferAllocator<CGPoint,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v15);
  return 0;
}

unint64_t TBaseFont::GetGraphicsFont(atomic_ullong *this)
{
  return atomic_load_explicit(this + 13, memory_order_acquire);
}

uint64_t TBaseFont::IsAppleColorEmojiUI(TBaseFont *this)
{
  if ((*((_DWORD *)this + 46) & 0x200) == 0) {
    TBaseFont::DetermineFontFlags(this, 0x200u);
  }
  return (*((_DWORD *)this + 45) >> 9) & 1;
}

double TBaseFont::GetOpticalLeading(TBaseFont *this, double a2, double a3)
{
  return a3;
}

uint64_t *std::unique_ptr<TUnicodeDataCachePage>::reset[abi:nn180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  *__n128 result = a2;
  if (v2)
  {
    long long v3 = (void **)(v2 + 1568);
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100](&v3);
    return (uint64_t *)MEMORY[0x1853275C0](v2, 0x1010C40E4D70334);
  }
  return result;
}

uint64_t TSplicedFont::GetGraphicsFont(TSplicedFont *this)
{
  uint64_t v1 = *(void *)(*((void *)this + 76) + 40);
  if ((*(_DWORD *)(v1 + 16) & 0x80000000) == 0) {
    TDescriptor::InitBaseFont(*(TDescriptor **)(*((void *)this + 76) + 40), 0, 0.0);
  }
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)atomic_load_explicit((atomic_ullong *volatile)(v1 + 32), memory_order_acquire)
                           + 568);

  return v2();
}

uint64_t TSplicedFont::GetUnscaledTrackAmount(TSplicedFont *this, const __CFDictionary *a2, __n128 a3)
{
  unint64_t v3 = a3.n128_u64[0];
  uint64_t v4 = *(void *)(*((void *)this + 76) + 40);
  if ((*(_DWORD *)(v4 + 16) & 0x80000000) == 0) {
    TDescriptor::InitBaseFont(*(TDescriptor **)(*((void *)this + 76) + 40), 0, 0.0);
  }
  double v5 = *(uint64_t (**)(__n128))(*(void *)atomic_load_explicit((atomic_ullong *volatile)(v4 + 32), memory_order_acquire)+ 552);
  a3.n128_u64[0] = v3;

  return v5(a3);
}

void TCFBase<TNativeTextTab>::ClassDestruct(uint64_t a1)
{
  uint64_t v2 = *(void (**)(uint64_t))(a1 + 16);
  if (v2) {
    v2(a1);
  }
  unint64_t v3 = *(const void **)(*(void *)(a1 + 40) + 16);
  if (v3)
  {
    CFRelease(v3);
  }
}

uint64_t _CTGetVisibleFormatterCharacterSet::$_0::__invoke(_CTGetVisibleFormatterCharacterSet::$_0 *this, void *a2)
{
  v4[4] = *MEMORY[0x1E4F143B8];
  CFMutableCharacterSetRef Mutable = CFCharacterSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
  v4[0] = &unk_1ED061FB8;
  v4[1] = Mutable;
  v4[3] = v4;
  ForEachVisibleFormatter((uint64_t)v4);
  std::__function::__value_func<void ()>::~__value_func[abi:nn180100](v4);
  uint64_t result = _CFCharacterSetCompact();
  qword_1EB2CE770 = (uint64_t)Mutable;
  return result;
}

uint64_t IterateItems(uint64_t result, int *a2, uint64_t a3, uint64_t a4)
{
  if (result)
  {
    if (*a2 > 0) {
      return 0;
    }
    int v7 = (UniChar *)operator new(4uLL);
    chars = v7;
    *(_DWORD *)int v7 = 0;
    id v19 = v7 + 2;
    long long v20 = v7 + 2;
    ItemCFIndex Count = uset_getItemCount();
    if (ItemCount >= 1)
    {
      int v9 = ItemCount;
      int v10 = 0;
      char v11 = 0;
      CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      while (1)
      {
        int Item = uset_getItem();
        int v14 = Item;
        int v15 = *a2;
        if (*a2 == 15)
        {
          std::vector<unsigned short>::resize((uint64_t)&chars, Item + 1);
          *a2 = 0;
          uset_getItem();
          int v15 = *a2;
        }
        if (v15 > 0) {
          goto LABEL_17;
        }
        if (v14 < 1) {
          break;
        }
        CFStringRef v16 = CFStringCreateWithCharacters(v12, chars, v14);
        if (v16)
        {
          CFStringRef v17 = v16;
          std::function<void ()(__CFString const*)>::operator()(a4, (uint64_t)v16);
          CFRelease(v17);
LABEL_13:
          char v11 = 1;
        }
        if (v9 == ++v10) {
          goto LABEL_17;
        }
      }
      std::function<void ()(unsigned int,unsigned int)>::operator()(a3, -1431655766, -1431655765);
      goto LABEL_13;
    }
    char v11 = 0;
LABEL_17:
    if (chars)
    {
      id v19 = chars;
      operator delete(chars);
    }
    return v11 & 1;
  }
  return result;
}

uint64_t std::function<void ()(unsigned int,unsigned int)>::operator()(uint64_t a1, int a2, int a3)
{
  int v7 = a2;
  int v6 = a3;
  uint64_t v3 = *(void *)(a1 + 24);
  if (v3) {
    return (*(uint64_t (**)(uint64_t, int *, int *))(*(void *)v3 + 48))(v3, &v7, &v6);
  }
  uint64_t v5 = std::__throw_bad_function_call[abi:nn180100]();
  return std::__function::__func<ForEachVisibleFormatter(std::function<void ()>)::$_0,std::allocator<ForEachVisibleFormatter(std::function<void ()>)::$_0>,void ()(unsigned int,unsigned int)>::operator()(v5);
}

uint64_t std::__function::__func<ForEachVisibleFormatter(std::function<void ()(unsigned int)>)::$_0,std::allocator<ForEachVisibleFormatter(std::function<void ()(unsigned int)>)::$_0>,void ()(unsigned int,unsigned int)>::operator()(uint64_t result, int *a2, int *a3)
{
  int v3 = *a2;
  int v4 = *a3;
  if (*a2 != *a3)
  {
    uint64_t v5 = result + 8;
    do
      uint64_t result = std::function<void ()>::operator()(v5, v3++);
    while (v4 != v3);
  }
  return result;
}

void *ForEachVisibleFormatter(uint64_t a1)
{
  void v9[4] = *MEMORY[0x1E4F143B8];
  std::function<void ()>::operator()(a1, 6155);
  std::function<void ()>::operator()(a1, 6156);
  std::function<void ()>::operator()(a1, 6157);
  std::function<void ()>::operator()(a1, 6158);
  std::function<void ()>::operator()(a1, 6159);
  std::function<void ()>::operator()(a1, 8204);
  std::function<void ()>::operator()(a1, 8205);
  std::function<void ()>::operator()(a1, 78896);
  std::function<void ()>::operator()(a1, 78897);
  std::function<void ()>::operator()(a1, 78898);
  std::function<void ()>::operator()(a1, 78899);
  std::function<void ()>::operator()(a1, 78900);
  std::function<void ()>::operator()(a1, 78901);
  std::function<void ()>::operator()(a1, 78902);
  std::function<void ()>::operator()(a1, 78903);
  std::function<void ()>::operator()(a1, 78904);
  std::function<void ()>::operator()(a1, 78905);
  std::function<void ()>::operator()(a1, 78906);
  std::function<void ()>::operator()(a1, 78907);
  std::function<void ()>::operator()(a1, 78908);
  std::function<void ()>::operator()(a1, 78909);
  std::function<void ()>::operator()(a1, 78910);
  std::function<void ()>::operator()(a1, 78911);
  UErrorCode pErrorCode = U_ZERO_ERROR;
  BinaryPropertySet = u_getBinaryPropertySet(UCHAR_PREPENDED_CONCATENATION_MARK, &pErrorCode);
  std::__function::__value_func<void ()>::__value_func[abi:nn180100]((uint64_t)v7, a1);
  int v3 = operator new(0x28uLL);
  int v4 = v3;
  *int v3 = &unk_1ED05FE88;
  if (v8)
  {
    if (v8 == v7)
    {
      v3[4] = v3 + 1;
      (*(void (**)(void *))(v7[0] + 24))(v7);
    }
    else
    {
      v3[4] = v8;
      uint64_t v8 = 0;
    }
  }
  else
  {
    v3[4] = 0;
  }
  id v9[3] = v4;
  IterateItemRanges((uint64_t)BinaryPropertySet, (int *)&pErrorCode, (uint64_t)v9);
  std::__function::__value_func<void ()(unsigned int,unsigned int)>::~__value_func[abi:nn180100](v9);
  return std::__function::__value_func<void ()>::~__value_func[abi:nn180100](v7);
}

uint64_t std::function<void ()(unsigned int)>::operator()(uint64_t a1, int a2)
{
  int v5 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2) {
    return (*(uint64_t (**)(uint64_t, int *))(*(void *)v2 + 48))(v2, &v5);
  }
  uint64_t v4 = std::__throw_bad_function_call[abi:nn180100]();
  return std::__function::__func<TFont::InitShapingGlyphs(void)::$_4,std::allocator<TFont::InitShapingGlyphs(void)::$_4>,void ()>::operator()(v4);
}

void std::__function::__func<TFont::InitShapingGlyphs(void)::$_4,std::allocator<TFont::InitShapingGlyphs(void)::$_4>,void ()(unsigned int)>::operator()(uint64_t a1, unsigned int *a2)
{
  unsigned int v9 = *a2;
  STL::insert_sorted<TInlineVector<unsigned int,30ul>>(*(char ***)(a1 + 8), (char *)&v9);
  LangSysTagsWithFallback(v9, &v7);
  int v3 = v7;
  uint64_t v4 = v8;
  if (v7 != v8)
  {
    do
    {
      int v5 = *(_DWORD *)v3;
      v3 += 4;
      int v6 = v5;
      STL::insert_sorted<TInlineVector<unsigned int,30ul>>(*(char ***)(a1 + 8), (char *)&v6);
    }
    while (v3 != v4);
    int v3 = v7;
  }
  if (v3)
  {
    uint64_t v8 = v3;
    operator delete(v3);
  }
}

char **STL::insert_sorted<TInlineVector<unsigned int,30ul>>(char **result, char *a2)
{
  int v3 = (void **)result;
  int v5 = *result;
  uint64_t v4 = result[1];
  uint64_t v6 = v4 - *result;
  if (v4 == *result)
  {
    uint64_t v8 = result[1];
  }
  else
  {
    unint64_t v7 = v6 >> 2;
    uint64_t v8 = *result;
    do
    {
      unint64_t v9 = v7 >> 1;
      int v10 = &v8[4 * (v7 >> 1)];
      unsigned int v12 = *(_DWORD *)v10;
      char v11 = v10 + 4;
      v7 += ~(v7 >> 1);
      if (v12 < *(_DWORD *)a2) {
        uint64_t v8 = v11;
      }
      else {
        unint64_t v7 = v9;
      }
    }
    while (v7);
  }
  unint64_t v13 = (unint64_t)result[2];
  if ((unint64_t)v4 >= v13)
  {
    unint64_t v18 = (v6 >> 2) + 1;
    unint64_t v36 = 0xAAAAAAAAAAAAAAAALL;
    if (v18 >> 62) {
      abort();
    }
    uint64_t v19 = v8 - v5;
    uint64_t v20 = (v8 - v5) >> 2;
    unint64_t v21 = v13 - (void)v5;
    unint64_t v22 = (uint64_t)(v13 - (void)v5) >> 1;
    if (v22 > v18) {
      unint64_t v18 = v22;
    }
    if (v21 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v23 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v23 = v18;
    }
    CGAffineTransform v38 = result + 3;
    if (v23) {
      id v24 = (char *)TInlineBufferAllocator<unsigned int,30ul>::allocate((uint64_t)(result + 3), v23);
    }
    else {
      id v24 = 0;
    }
    long long v27 = &v24[4 * v20];
    double v34 = v24;
    double v35 = v27;
    double v28 = &v24[4 * v23];
    double v37 = v28;
    if (v20 == v23)
    {
      if (v19 < 1)
      {
        if (v8 == v5) {
          unint64_t v30 = 1;
        }
        else {
          unint64_t v30 = v19 >> 1;
        }
        int v43 = v3 + 3;
        uint64_t v31 = (char *)TInlineBufferAllocator<unsigned int,30ul>::allocate((uint64_t)(v3 + 3), v30);
        unint64_t v32 = &v31[v30 & 0xFFFFFFFFFFFFFFFCLL];
        double v34 = v31;
        double v35 = v32;
        CGAffineTransform v39 = v24;
        double v40 = &v24[4 * v20];
        double v37 = &v31[4 * v30];
        double v41 = v40;
        int v42 = v28;
        std::__split_buffer<unsigned int,TInlineBufferAllocator<unsigned int,30ul> &>::~__split_buffer((uint64_t)&v39);
        long long v27 = v32;
      }
      else
      {
        unint64_t v29 = v20 + 2;
        if (v20 >= -1) {
          unint64_t v29 = v20 + 1;
        }
        v27 -= 4 * (v29 >> 1);
        double v35 = v27;
      }
    }
    *(_DWORD *)long long v27 = *(_DWORD *)a2;
    unint64_t v36 = (unint64_t)(v27 + 4);
    std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__swap_out_circular_buffer(v3, (uint64_t)&v34, v8);
    return (char **)std::__split_buffer<unsigned int,TInlineBufferAllocator<unsigned int,30ul> &>::~__split_buffer((uint64_t)&v34);
  }
  else if (v8 == v4)
  {
    *(_DWORD *)uint64_t v4 = *(_DWORD *)a2;
    result[1] = v4 + 4;
  }
  else
  {
    int v14 = v8 + 4;
    int v15 = v4 - 4;
    CFStringRef v16 = result[1];
    while (v15 < v4)
    {
      int v17 = *(_DWORD *)v15;
      v15 += 4;
      *(_DWORD *)CFStringRef v16 = v17;
      v16 += 4;
    }
    result[1] = v16;
    if (v4 != v14)
    {
      uint64_t result = (char **)memmove(&v4[-4 * ((v4 - v14) >> 2)], v8, v4 - v14);
      CFStringRef v16 = (char *)v3[1];
    }
    BOOL v26 = v8 <= a2 && v16 > a2;
    *(_DWORD *)uint64_t v8 = *(_DWORD *)&a2[4 * v26];
  }
  return result;
}

void LangSysTagsWithFallback(unsigned int a1@<W0>, char **a2@<X8>)
{
  if (HIWORD(a1) == 23112)
  {
    if (a1 == 1514686496)
    {
      uint64_t v4 = (char *)operator new(4uLL);
      *a2 = v4;
      *(_DWORD *)uint64_t v4 = 1514689613;
      v4 += 4;
      a2[1] = v4;
      a2[2] = v4;
      return;
    }
    goto LABEL_33;
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB2CE4A8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB2CE4A8))
  {
    *(_OWORD *)&qword_1EB2CE560 = 0u;
    *(_OWORD *)&qword_1EB2CE550 = 0u;
    dword_1EB2CE570 = 1065353216;
    __cxa_guard_release(&qword_1EB2CE4A8);
  }
  if (qword_1EB2CE4B0 != -1) {
    dispatch_once_f(&qword_1EB2CE4B0, 0, (dispatch_function_t)LangSysTagsWithFallback::$_0::__invoke);
  }
  uint64_t v6 = v5;
  if (v5)
  {
    unint64_t v7 = v5;
    do
      unint64_t v7 = (uint64_t *)*v7;
    while (v7 && *((_DWORD *)v7 + 4) == a1);
  }
  else
  {
    unint64_t v7 = 0;
  }
  if (v7 == v5)
  {
LABEL_33:
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    return;
  }
  uint64_t v8 = 0;
  a2[2] = 0;
  unint64_t v9 = a2 + 2;
  *a2 = 0;
  a2[1] = 0;
  do
  {
    if ((unint64_t)v8 >= *v9)
    {
      char v11 = *a2;
      uint64_t v12 = (v8 - *a2) >> 2;
      unint64_t v13 = v12 + 1;
      if ((unint64_t)(v12 + 1) >> 62) {
        abort();
      }
      uint64_t v14 = *v9 - (void)v11;
      if (v14 >> 1 > v13) {
        unint64_t v13 = v14 >> 1;
      }
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v15 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v15 = v13;
      }
      if (v15)
      {
        CFStringRef v16 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>((uint64_t)(a2 + 2), v15);
        char v11 = *a2;
        uint64_t v8 = a2[1];
      }
      else
      {
        CFStringRef v16 = 0;
      }
      int v17 = &v16[4 * v12];
      *(_DWORD *)int v17 = *((_DWORD *)v6 + 5);
      int v10 = v17 + 4;
      while (v8 != v11)
      {
        int v18 = *((_DWORD *)v8 - 1);
        v8 -= 4;
        *((_DWORD *)v17 - 1) = v18;
        v17 -= 4;
      }
      *a2 = v17;
      a2[1] = v10;
      a2[2] = &v16[4 * v15];
      if (v11) {
        operator delete(v11);
      }
    }
    else
    {
      *(_DWORD *)uint64_t v8 = *((_DWORD *)v6 + 5);
      int v10 = v8 + 4;
    }
    a2[1] = v10;
    uint64_t v6 = (uint64_t *)*v6;
    uint64_t v8 = v10;
  }
  while (v6 != v7);
}

uint64_t std::__split_buffer<unsigned int,TInlineBufferAllocator<unsigned int,30ul> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3) {
    *(void *)(a1 + 16) = v2 + ((v3 - v2 + 3) & 0xFFFFFFFFFFFFFFFCLL);
  }
  uint64_t v4 = *(void **)a1;
  if (*(void *)a1)
  {
    unint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = (void *)(v5 + 120);
    if (v5 <= (unint64_t)v4 && v6 > v4)
    {
      if (*(void *)(a1 + 24) == *v6) {
        *uint64_t v6 = v4;
      }
    }
    else
    {
      operator delete(v4);
    }
  }
  return a1;
}

char *std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__swap_out_circular_buffer(void **a1, uint64_t a2, char *__src)
{
  unint64_t v5 = *(char **)(a2 + 8);
  uint64_t v6 = (char *)*a1;
  unint64_t v7 = v5;
  if (*a1 != __src)
  {
    uint64_t v8 = __src;
    unint64_t v7 = *(char **)(a2 + 8);
    do
    {
      int v9 = *((_DWORD *)v8 - 1);
      v8 -= 4;
      *((_DWORD *)v7 - 1) = v9;
      v7 -= 4;
    }
    while (v8 != v6);
  }
  *(void *)(a2 + 8) = v7;
  int v10 = a1[1];
  uint64_t v11 = *(void *)(a2 + 16);
  int64_t v12 = v10 - __src;
  if (v10 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v10 - __src);
    unint64_t v7 = *(char **)(a2 + 8);
  }
  *(void *)(a2 + 16) = v11 + v12;
  unint64_t v13 = (char *)*a1;
  *a1 = v7;
  *(void *)(a2 + 8) = v13;
  uint64_t v14 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(void *)(a2 + 16) = v14;
  unint64_t v15 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(void *)(a2 + 24) = v15;
  *(void *)a2 = *(void *)(a2 + 8);
  return v5;
}

void std::__function::__func<_CTGetVisibleFormatterCharacterSet::$_0::operator() const(void *)::{lambda(unsigned int)#1},std::allocator<_CTGetVisibleFormatterCharacterSet::$_0::operator() const(void *)::{lambda(unsigned int)#1}>,void ()(unsigned int)>::operator()(uint64_t a1, unsigned int *a2)
{
  v2.CFIndex location = *a2;
  v2.CFIndex length = 1;
  CFCharacterSetAddCharactersInRange(*(CFMutableCharacterSetRef *)(a1 + 8), v2);
}

uint64_t std::__function::__value_func<void ()(unsigned int)>::__value_func[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t std::__function::__func<_CTGetVisibleFormatterCharacterSet::$_0::operator() const(void *)::{lambda(unsigned int)#1},std::allocator<_CTGetVisibleFormatterCharacterSet::$_0::operator() const(void *)::{lambda(unsigned int)#1}>,void ()(unsigned int)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1ED061FB8;
  a2[1] = v2;
  return result;
}

uint64_t IterateItemRanges(uint64_t a1, int *a2, uint64_t a3)
{
  v8[4] = *MEMORY[0x1E4F143B8];
  std::__function::__value_func<void ()(unsigned int,unsigned int)>::__value_func[abi:nn180100]((uint64_t)v8, a3);
  v7[0] = &unk_1ED05FD20;
  void v7[3] = v7;
  uint64_t v5 = IterateItems(a1, a2, (uint64_t)v8, (uint64_t)v7);
  std::__function::__value_func<void ()(__CFString const*)>::~__value_func[abi:nn180100](v7);
  std::__function::__value_func<void ()(unsigned int,unsigned int)>::~__value_func[abi:nn180100](v8);
  return v5;
}

void *std::__function::__value_func<void ()(unsigned int,unsigned int)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<ForEachVisibleFormatter(std::function<void ()(unsigned int)>)::$_0,std::allocator<ForEachVisibleFormatter(std::function<void ()(unsigned int)>)::$_0>,void ()(unsigned int,unsigned int)>::destroy_deallocate(void *a1)
{
  std::__function::__value_func<void ()>::~__value_func[abi:nn180100](a1 + 1);

  operator delete(a1);
}

uint64_t std::__function::__value_func<void ()(unsigned int,unsigned int)>::__value_func[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *std::__function::__value_func<void ()(__CFString const*)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::__function::__func<ForEachVisibleFormatter(std::function<void ()(unsigned int)>)::$_0,std::allocator<ForEachVisibleFormatter(std::function<void ()(unsigned int)>)::$_0>,void ()(unsigned int,unsigned int)>::__clone(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x28uLL);
  *uint64_t v2 = &unk_1ED05FE88;
  std::__function::__value_func<void ()>::__value_func[abi:nn180100]((uint64_t)(v2 + 1), v1);
  return v2;
}

void *std::__function::__value_func<BOOL ()(unsigned int,OTL::FeatureTable const*,BOOL &)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t CTFontDescriptorGetSymbolicTraits(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v1 = *(void *)(a1 + 40);
  if ((*(_DWORD *)(v1 + 16) & 0x80000000) == 0
    || (unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(v1 + 32), memory_order_acquire)) == 0)
  {
    TDescriptor::CopyAttribute((atomic_ullong *)v1, @"NSCTFontTraitsAttribute", &v7);
    CFDictionaryRef v2 = (const __CFDictionary *)atomic_exchange((atomic_ullong *volatile)&v7, 0);

    CFDictionaryRef SymbolicTraitsFromTraits = GetSymbolicTraitsFromTraits(v2);
    return (uint64_t)SymbolicTraitsFromTraits;
  }
  uint64_t v6 = *(uint64_t (**)(void))(*(void *)explicit + 160);

  return v6();
}

void TCFBase<TFont>::ClassDestruct(uint64_t a1)
{
  CFDictionaryRef v2 = *(void (**)(uint64_t))(a1 + 16);
  if (v2) {
    v2(a1);
  }
  uint64_t v3 = *(TFont **)(a1 + 40);

  TFont::~TFont(v3);
}

BOOL OTL::FeatureList::StripMissingFeaturesFrom(unsigned int **this, unsigned int *__dst)
{
  if (!*__dst) {
    return 0;
  }
  uint64_t v4 = __dst;
  do
  {
    unsigned int v5 = v4[1];
    ++v4;
  }
  while (v5);
  if (v4 > __dst)
  {
    uint64_t v6 = *this;
    id v7 = __dst;
    do
    {
      uint64_t v8 = this[1];
      if (v8 == v6) {
        goto LABEL_14;
      }
      unint64_t v9 = v8 - v6;
      unsigned int v10 = *v7;
      uint64_t v11 = v6;
      do
      {
        unint64_t v12 = v9 >> 1;
        unint64_t v13 = &v11[v9 >> 1];
        unsigned int v15 = *v13;
        uint64_t v14 = v13 + 1;
        v9 += ~(v9 >> 1);
        if (v15 < v10) {
          uint64_t v11 = v14;
        }
        else {
          unint64_t v9 = v12;
        }
      }
      while (v9);
      if (v11 == v8 || v10 < *v11)
      {
LABEL_14:
        if (v4 != v7 + 1)
        {
          memmove(v7, v7 + 1, (char *)v4 - (char *)(v7 + 1));
          uint64_t v6 = *this;
        }
        --v4;
      }
      else
      {
        ++v7;
      }
    }
    while (v7 < v4);
  }
  unsigned int *v4 = 0;
  return v4 != __dst;
}

void CTFontDrawGlyphs(CTFontRef font, const CGGlyph *glyphs, const CGPoint *positions, size_t count, CGContextRef context)
{
  if (font && glyphs && positions && count)
  {
    if (context)
    {
      unint64_t v9 = (TBaseFont **)*((void *)font + 5);
      TFont::SetInContext(v9, context);
      *(void *)&long long v10 = -1;
      *((void *)&v10 + 1) = -1;
      *(_OWORD *)&v13.c = v10;
      *(_OWORD *)&v13.tx = v10;
      *(_OWORD *)&v13.double a = v10;
      TFont::GetEffectiveMatrix((TFont *)v9, (uint64_t)&v13);
      memset(v12, 255, 48);
      memset(&v12[48], 170, 24);
      CGAffineTransform v11 = v13;
      CGAffineTransform v14 = v13;
      CGAffineTransformInvert((CGAffineTransform *)v12, &v14);
      *(void *)&v12[48] = 0;
      v12[56] = 0;
      *(_DWORD *)&v12[60] = 13;
      *(void *)&v12[64] = 0;
      DrawGlyphsAtPositions(v9, glyphs, positions, count, context, (uint64_t)&v11);
    }
  }
}

void TDecorationRun::CalculateGlyphIntersections(uint64_t a1, CGFloat *a2, __n128 *a3, uint64_t a4, CGFloat a5, double a6)
{
  uint64_t v79 = *MEMORY[0x1E4F143B8];
  if (a3[13].n128_u64[0])
  {
    unint64_t v12 = *(TFont **)(atomic_load_explicit(&a3[3].n128_i64[1], memory_order_acquire) + 40);
    CGAffineTransform v13 = (const unsigned __int16 *)(*(void *)(a3[13].n128_u64[1] + 16) + 2 * a3[12].n128_u64[1]);
    *(void *)&long long v14 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v68 = 0xAAAAAAAAAAAAAA00;
    *(_OWORD *)&v67[160] = v14;
    *(_OWORD *)&v67[176] = v14;
    *(_OWORD *)&v67[128] = v14;
    *(_OWORD *)&v67[144] = v14;
    *(_OWORD *)&v67[96] = v14;
    *(_OWORD *)&v67[112] = v14;
    *(_OWORD *)&v67[80] = v14;
    *(_OWORD *)&v67[48] = v14;
    *(_OWORD *)&v67[64] = v14;
    *(_OWORD *)&v67[16] = v14;
    *(_OWORD *)&v67[32] = v14;
    *(_OWORD *)uint64_t v67 = v14;
    v67[0] = 0;
    unsigned int v15 = (void *)a3[17].n128_u64[0];
    if (v15)
    {
      *(void *)uint64_t v67 = *v15;
      memset(&v67[8], 0, 184);
      *(void *)&v67[168] = *(void *)(*(void *)v67 + 16);
      LOBYTE(v68) = 1;
    }
    memset(v77, 170, sizeof(v77));
    unint64_t v16 = a3[13].n128_u64[0];
    CFIndex v74 = 0;
    uint64_t v75 = 0;
    uint64_t v76 = 0;
    long long v78 = v77;
    if (v16)
    {
      std::vector<CGRect,TInlineBufferAllocator<CGRect,30ul>>::__vallocate[abi:nn180100]((char **)&v74, v16);
      int v17 = v75;
      int v18 = &v75[2 * v16];
      uint64_t v19 = 32 * v16;
      uint64_t v20 = (_OWORD *)MEMORY[0x1E4F1DB28];
      do
      {
        long long v21 = v20[1];
        *int v17 = *v20;
        v17[1] = v21;
        v17 += 2;
        v19 -= 32;
      }
      while (v19);
      uint64_t v75 = v18;
      unint64_t v22 = v74;
      uint64_t v23 = a3[13].n128_i64[0];
    }
    else
    {
      uint64_t v23 = 0;
      unint64_t v22 = 0;
    }
    TFont::GetBoundingBoxesForGlyphs(v12, v13, v22, v23, kCTFontOrientationDefault);
    TRun::GetPositions(a3, 0);
    uint64_t v25 = a3[13].n128_i64[0];
    if (v25 < 1) {
      goto LABEL_68;
    }
    uint64_t v26 = v24;
    uint64_t v27 = 0;
    CGFloat v28 = *a2;
    CGFloat v64 = a2[1];
    CGFloat v62 = a2[3];
    CGFloat v63 = a2[2];
    CGFloat v29 = *MEMORY[0x1E4F1DAD8];
    CGFloat v30 = *(double *)(MEMORY[0x1E4F1DAD8] + 8);
    CGFloat v31 = *(double *)(a1 + 24);
    CGFloat v32 = *(double *)(a1 + 56);
    while (1)
    {
      unint64_t v33 = a3[13].n128_u64[1];
      unint64_t v34 = a3[12].n128_u64[1];
      if (*(__int16 *)(*(void *)(v33 + 16) + 2 * v34 + 2 * v27) == -1
        || (*(_DWORD *)(*(void *)(v33 + 40) + 4 * v34 + 4 * v27) & 0x20) != 0
        || CGRectIsEmpty(v74[v27]))
      {
        goto LABEL_67;
      }
      int v35 = ScriptTagForScriptCode(a3[19].n128_i32[0]);
      if (v35) {
        goto LABEL_17;
      }
      if ((_BYTE)v68) {
        break;
      }
LABEL_20:
      CGAffineTransform v38 = (double *)(v26 + 16 * v27);
      CGFloat v39 = *v38;
      CGFloat v40 = v38[1];
      *(void *)&long long v41 = -1;
      *((void *)&v41 + 1) = -1;
      *(_OWORD *)&v66.c = v41;
      *(_OWORD *)&v66.tx = v41;
      *(_OWORD *)&v66.double a = v41;
      CGAffineTransformMakeTranslation(&v66, v39, v40);
      t1.double a = v28;
      t1.b = v64;
      t1.c = v63;
      t1.d = v62;
      t1.tx = v29;
      t1.ty = v30;
      CGAffineTransform t2 = v66;
      CGAffineTransformConcat(&v73, &t1, &t2);
      CGAffineTransform v66 = v73;
      unsigned int v42 = v13[v27];
      CGRect v80 = v74[v27];
      CGAffineTransform t1 = v73;
      CGRect v81 = CGRectApplyAffineTransform(v80, &t1);
      v82.origin.x = v32;
      v82.origin.y = a5;
      v82.size.CGFloat width = v31;
      v82.size.CGFloat height = a6 - a5;
      if (!CGRectIntersectsRect(v81, v82)) {
        goto LABEL_67;
      }
      id v65 = (id)0xAAAAAAAAAAAAAAAALL;
      TFont::CreatePathForGlyph(v12, 0, v42, &v65);
      if (!atomic_load_explicit((atomic_ullong *volatile)&v65, memory_order_acquire)) {
        goto LABEL_66;
      }
      *(void *)&long long v43 = -1;
      *((void *)&v43 + 1) = -1;
      *(_OWORD *)&t2.double a = v43;
      *(_OWORD *)&t2.c = v43;
      *(_OWORD *)&t2.tx = v43;
      CGAffineTransform t1 = v66;
      CGAffineTransformInvert(&t2, &t1);
      memset(v71, 170, sizeof(v71));
      memset(&t1, 255, sizeof(t1));
      *(_OWORD *)&t1.double a = *MEMORY[0x1E4F1DAD8];
      *(_OWORD *)&t1.c = *(_OWORD *)&t1.a;
      t1.tx = t2.ty + t2.d * a5 + t2.b * 0.0;
      t1.ty = t2.ty + t2.d * a6 + t2.b * 0.0;
      v71[0] = 0;
      LODWORD(v71[1]) = 0;
      memset(&v71[2], 0, 24);
      uint64_t v72 = &v71[5];
      if (t1.tx > t1.ty)
      {
        t1.tx = t2.ty + t2.d * a6 + t2.b * 0.0;
        t1.ty = t2.ty + t2.d * a5 + t2.b * 0.0;
      }
      CGPathApply((CGPathRef)atomic_load_explicit((atomic_ullong *volatile)&v65, memory_order_acquire), &t1, (CGPathApplierFunction)TDecorationRun::CalculateGlyphIntersections(CGAffineTransform,TRun const&,double,double,std::function<void ()(double,double)> const&)const::$_0::__invoke);
      double v44 = (void *)v71[2];
      if (v71[2] == v71[3]) {
        goto LABEL_62;
      }
      double v60 = v28;
      __int16 v61 = v12;
      *(void *)&v73.double a = &unk_1ED05D370;
      *(void *)&v73.b = &v66;
      *(void *)&v73.c = a4;
      *(void *)&v73.d = &v73;
      unint64_t v45 = 126 - 2 * __clz((uint64_t)(v71[3] - v71[2]) >> 4);
      if (v71[3] == v71[2]) {
        uint64_t v46 = 0;
      }
      else {
        uint64_t v46 = v45;
      }
      uint64_t v48 = v71[2];
      uint64_t v47 = v71[3];
      if (v71[2] == v71[3]) {
        goto LABEL_61;
      }
      uint64_t v58 = v26;
      uint64_t v59 = a4;
      int v49 = 0;
      uint64_t v50 = 0;
      int v51 = 0;
      double v52 = NAN;
      double v53 = NAN;
      do
      {
        int v54 = v49;
        int v55 = *(_DWORD *)(v48 + 8);
        if (v55) {
          int v56 = v49;
        }
        else {
          int v56 = v49 + 1;
        }
        if (v55 == 2) {
          --v49;
        }
        else {
          int v49 = v56;
        }
        if (v54 && !v49)
        {
          double v53 = *(double *)v48;
          goto LABEL_52;
        }
        if (!v54 && v49)
        {
          if (!v51) {
            goto LABEL_44;
          }
          if (!v50)
          {
            std::function<void ()(double,double)>::operator()(*(uint64_t *)&v73.d, v52, v53);
LABEL_44:
            double v52 = *(double *)v48;
          }
LABEL_51:
          int v51 = 1;
          goto LABEL_52;
        }
        if (v55 != 1 || v54 || v49) {
          goto LABEL_52;
        }
        if (v51)
        {
          if (v50)
          {
            double v53 = *(double *)v48;
            goto LABEL_51;
          }
          std::function<void ()(double,double)>::operator()(*(uint64_t *)&v73.d, v52, v53);
        }
        double v53 = *(double *)v48;
        int v51 = 1;
        double v52 = *(double *)v48;
LABEL_52:
        if ((*(_DWORD *)(v48 + 12) - 1) >= 0x40) {
          int v57 = 0;
        }
        else {
          int v57 = 1 << (*(unsigned char *)(v48 + 12) - 1);
        }
        v50 ^= v57;
        v48 += 16;
      }
      while (v48 != v47);
      uint64_t v26 = v58;
      a4 = v59;
      if (v51) {
        std::function<void ()(double,double)>::operator()(*(uint64_t *)&v73.d, v52, v53);
      }
LABEL_61:
      std::__function::__value_func<void ()(double,double)>::~__value_func[abi:nn180100](&v73);
      double v44 = (void *)v71[2];
      unint64_t v12 = v61;
      CGFloat v28 = v60;
LABEL_62:
      if (v44)
      {
        v71[3] = v44;
        if (&v71[5] > v44 || &v72 <= v44) {
          operator delete(v44);
        }
      }
LABEL_66:

LABEL_67:
      if (++v27 == v25)
      {
LABEL_68:
        *(void *)&t1.double a = &v74;
        std::vector<CGRect,TInlineBufferAllocator<CGRect,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&t1);
        return;
      }
    }
    t1.double a = *(CGFloat *)(*(void *)(a3[13].n128_u64[1] + 48) + 8 * a3[12].n128_u64[1] + 8 * v27);
    Fullunsigned int Char = TCharStreamIterator::GetFullChar((TCharStreamIterator *)v67, (uint64_t *)&t1, 0);
    int v37 = ScriptCodeForLongCharacter(FullChar);
    int v35 = ScriptTagForScriptCode(v37);
LABEL_17:
    if (v35 == 1751215719 || v35 == 1751215721 || v35 == 1801547361) {
      goto LABEL_67;
    }
    goto LABEL_20;
  }
}

id TTenuousComponentFont::CopyFontURL@<X0>(atomic_ullong *this@<X0>, void *a2@<X8>)
{
  if ((*(unsigned int (**)(atomic_ullong *))(*this + 896))(this)) {
    id result = (id)atomic_load_explicit(this + 10, memory_order_acquire);
  }
  else {
    id result = 0;
  }
  *a2 = result;
  return result;
}

double TBaseFont::GetUnscaledTrackAmount(TBaseFont *this, const __CFDictionary *a2, double a3, const __CFData *a4)
{
  id v15 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr))(*(void *)this + 480))(&v15);
  if (atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire))
  {
    double v14 = 0.0;
    if (a2)
    {
      CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a2, @"NSCTFontTrackAttribute");
      if (Value)
      {
        CFNumberRef v9 = Value;
        CFTypeID v10 = CFGetTypeID(Value);
        if (v10 == CFNumberGetTypeID())
        {
          CFNumberGetValue(v9, kCFNumberDoubleType, &v14);
LABEL_12:
          unint64_t explicit = (TAATTrakTable *)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire);
          double v11 = TAATTrakTable::UnscaledTrackAmountForSize(explicit, a4, a3, v14);
          goto LABEL_13;
        }
      }
    }
    else if (((*(uint64_t (**)(TBaseFont *))(*(void *)this + 848))(this) & 1) == 0)
    {
      goto LABEL_12;
    }
    if ((*(unsigned int (**)(TBaseFont *))(*(void *)this + 848))(this))
    {
      if (qword_1EB2CDB00 != -1) {
        dispatch_once_f(&qword_1EB2CDB00, 0, (dispatch_function_t)TBaseFont::GetUnscaledTrackAmount(__CFDictionary const*,double,BOOL,unsigned int)const::$_0::__invoke);
      }
      *(void *)&double v14 = qword_1EB2CDB08;
    }
    goto LABEL_12;
  }
  double v11 = 0.0;
LABEL_13:

  return v11;
}

void TBaseFont::CopyTable(atomic_uint *this@<X0>, uint64_t a2@<X1>, atomic_ullong *a3@<X8>)
{
  if (a2 && (uint64_t v6 = (TBaseFont *)TableFlagForIdentifier(a2), (this[44] & v6) == 0))
  {
    unsigned int v7 = v6;
    if (TBaseFont::IsCommonTableFlag(v6))
    {
      id v9 = (id)TBaseFont::GetCommonTable((TBaseFont *)this, a2, 0);
      *a3 = atomic_exchange((atomic_ullong *volatile)&v9, 0);
    }
    else
    {
      uint64_t InitializedGraphicsFont = (CGFont *)TBaseFont::GetInitializedGraphicsFont((TBaseFont *)this);
      *a3 = (atomic_ullong)CGFontCopyTableForTag(InitializedGraphicsFont, a2);
      if (!atomic_load_explicit(a3, memory_order_acquire)) {
        atomic_fetch_or_explicit(this + 44, v7, memory_order_relaxed);
      }
    }
  }
  else
  {
    *a3 = 0;
  }
}

uint64_t TBaseFont::IsCommonTableFlag(TBaseFont *this)
{
  int v1 = (int)this;
  uint64_t result = 1;
  if (v1 <= 127)
  {
    unsigned int v3 = v1 - 1;
    if (v3 <= 0x3F && ((1 << v3) & 0x8000000000000089) != 0) {
      return result;
    }
    return 0;
  }
  if (v1 >= 0x4000)
  {
    if (v1 != 0x4000 && v1 != 0x400000) {
      return 0;
    }
  }
  else if (v1 != 128 && v1 != 256)
  {
    return 0;
  }
  return result;
}

void TLine::DrawGlyphs(TLine *this, CGContextRef c)
{
  if ((*((_WORD *)this + 77) & 2) != 0)
  {
    TLine::DrawTransformedGlyphs(this, c);
  }
  else
  {
    CGPoint TextPosition = CGContextGetTextPosition(c);
    TLine::GetLeftHangersGlyphCountAndWidth(this, 0);
    double v6 = v5;
    if (v5 == 0.0) {
      double v6 = 0.0;
    }
    double v7 = TextPosition.x - v6;
    CGContextSetTextPosition(c, TextPosition.x - v6, TextPosition.y);
    TLine::DrawBackground(this, c);
    uint64_t v8 = *((void *)this + 3) - *((void *)this + 2);
    if (v8 >= 1)
    {
      int v9 = 0;
      int v10 = 0;
      uint64_t v11 = 0;
      uint64_t v12 = (unint64_t)v8 >> 3;
      if (v12 <= 1) {
        uint64_t v13 = 1;
      }
      else {
        uint64_t v13 = v12;
      }
      do
      {
        uint64_t v14 = *(void *)(*(void *)(*((void *)this + 2) + 8 * v11) + 40);
        (*(void (**)(uint64_t, CGContextRef, void, void))(*(void *)v14 + 24))(v14, c, 0, *(void *)(v14 + 208));
        v9 |= (*(unsigned char *)(v14 + 177) & 4) >> 2;
        v10 |= (*(unsigned char *)(v14 + 177) & 0x10) >> 4;
        ++v11;
      }
      while (v13 != v11);
      if (v9)
      {
        CGContextSetTextPosition(c, v7, TextPosition.y);
        TLine::DrawUnderlines(this, c);
      }
      if (v10)
      {
        CGContextSetTextPosition(c, v7, TextPosition.y);
        TLine::DrawStrikethroughs(this, c);
      }
    }
  }
}

void TRun::DrawGlyphs(TRun *this, CGContextRef c, CFRange a3)
{
  unint64_t length = a3.length;
  CFIndex location = a3.location;
  v56[1] = *MEMORY[0x1E4F143B8];
  CGPoint TextPosition = CGContextGetTextPosition(c);
  double x = TextPosition.x;
  double y = TextPosition.y;
  if (!location)
  {
    int v10 = (double *)*((void *)this + 39);
    if (!v10) {
      int v10 = (double *)MEMORY[0x1E4F1DB30];
    }
    double x = TextPosition.x + *v10;
    double y = TextPosition.y + v10[1];
    if (*((uint64_t *)this + 26) >= 1)
    {
      if ((*((unsigned char *)this + 225) & 0x10) != 0)
      {
        [*((id *)this + 27) originAtIndex:*((void *)this + 25)];
      }
      else
      {
        double v11 = *MEMORY[0x1E4F1DAD8];
        double v12 = *(double *)(MEMORY[0x1E4F1DAD8] + 8);
      }
      double x = x + v11;
      double y = y + v12;
    }
  }
  uint64_t v13 = *((void *)this + 20);
  if (v13)
  {
    double v14 = *(double *)(v13 + 48);
    if (!location) {
      goto LABEL_14;
    }
LABEL_13:
    if (v14 == 0.0) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }
  double v14 = 0.0;
  if (location) {
    goto LABEL_13;
  }
LABEL_14:
  CGContextSetTextPosition(c, x, y + v14);
LABEL_15:
  v57.CFIndex location = location;
  v57.unint64_t length = length;
  TRun::DrawBackground(this, c, v57, 0, 0);
  id v15 = (void *)*((void *)this + 27);
  uint64_t v16 = v15[2];
  uint64_t v50 = *((void *)this + 25);
  memset(v55, 170, sizeof(v55));
  __dst = 0;
  double v53 = 0;
  uint64_t v17 = 16 * length;
  uint64_t v54 = 0;
  v56[0] = v55;
  uint64_t v51 = v16;
  if (length)
  {
    std::vector<CGSize,TInlineBufferAllocator<CGSize,64ul>>::__vallocate[abi:nn180100](&__dst, length);
    int v18 = (char *)v53;
    bzero(v53, 16 * length);
    uint64_t v19 = &v18[16 * length];
    double v53 = v19;
    id v15 = (void *)*((void *)this + 27);
  }
  else
  {
    uint64_t v19 = 0;
  }
  uint64_t v20 = v15[4];
  if (v20)
  {
    uint64_t v21 = *((void *)this + 25);
LABEL_20:
    unint64_t v22 = (char *)(v20 + 16 * v21 + 16 * location);
    uint64_t v23 = v54;
    uint64_t v24 = (char *)__dst;
    unint64_t v25 = (v54 - (uint64_t)__dst) >> 4;
    if (v25 >= length)
    {
      unint64_t v26 = (v19 - (unsigned char *)__dst) >> 4;
      if (v26 >= length)
      {
        if (length) {
          memmove(__dst, v22, 16 * length);
        }
        else {
          uint64_t v17 = 0;
        }
        uint64_t v19 = v24;
      }
      else
      {
        if (v19 != __dst)
        {
          memmove(__dst, v22, v19 - (unsigned char *)__dst);
          uint64_t v19 = (char *)v53;
        }
        uint64_t v17 = 16 * length - 16 * v26;
        if (v26 != length) {
          memmove(v19, &v22[16 * v26], 16 * length - 16 * v26);
        }
      }
    }
    else
    {
      if (__dst)
      {
        double v53 = __dst;
        if (v55 > __dst || v56 <= __dst)
        {
          operator delete(__dst);
        }
        else if ((char *)__dst + 16 * v25 == (void *)v56[0])
        {
          v56[0] = __dst;
        }
        uint64_t v23 = 0;
        __dst = 0;
        double v53 = 0;
        uint64_t v54 = 0;
      }
      if (length >> 60) {
        abort();
      }
      uint64_t v32 = v23 >> 3;
      if (v23 >> 3 <= length) {
        uint64_t v32 = length;
      }
      if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v33 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v33 = v32;
      }
      std::vector<CGSize,TInlineBufferAllocator<CGSize,64ul>>::__vallocate[abi:nn180100](&__dst, v33);
      uint64_t v19 = (char *)v53;
      memmove(v53, v22, 16 * length);
    }
    double v53 = &v19[v17];
    goto LABEL_51;
  }
  uint64_t v27 = v15[3];
  uint64_t v21 = *((void *)this + 25);
  if (!v27) {
    goto LABEL_20;
  }
  if (!length) {
    goto LABEL_65;
  }
  CGFloat v28 = (uint64_t *)(v27 + 8 * v21 + 8 * location);
  CGFloat v29 = __dst;
  uint64_t v30 = 8 * length;
  do
  {
    uint64_t v31 = *v28++;
    *CGFloat v29 = v31;
    v29[1] = 0;
    v29 += 2;
    v30 -= 8;
  }
  while (v30);
LABEL_51:
  if ((*((unsigned char *)this + 225) & 0x10) != 0 && (uint64_t)length >= 1)
  {
    uint64_t v34 = 0;
    uint64_t v35 = 0;
    unint64_t v36 = (double *)MEMORY[0x1E4F1DAD8];
    do
    {
      if ((*((unsigned char *)this + 225) & 0x10) != 0)
      {
        [*((id *)this + 27) originAtIndex:location + v35 + *((void *)this + 25)];
        double v37 = *v36;
        double v38 = v36[1];
      }
      else
      {
        double v37 = *v36;
        double v38 = v36[1];
        double v39 = *v36;
        double v40 = v38;
      }
      if (v39 != v37 || v40 != v38)
      {
        unsigned int v42 = (char *)__dst;
        if (v35)
        {
          long long v43 = (double *)((char *)__dst + v34);
          double v44 = v40 + *(double *)((char *)__dst + v34 - 8);
          *(v43 - 2) = v39 + *(double *)((char *)__dst + v34 - 16);
          *(v43 - 1) = v44;
        }
        unint64_t v45 = (double *)&v42[v34];
        double v46 = v45[1] - v40;
        *unint64_t v45 = *v45 - v39;
        v45[1] = v46;
      }
      ++v35;
      v34 += 16;
    }
    while (length != v35);
  }
LABEL_65:
  uint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)this + 7, memory_order_acquire);
  if (explicit)
  {
    BOOL v48 = TAttributes::SetContextAttributes((atomic_ullong *)this + 5, c, 0);
    CTFontDrawGlyphsWithAdvancesInternal(explicit, (CGGlyph *)(v51 + 2 * v50 + 2 * location), (float64x2_t *)__dst, length, c, (uint64_t)this);
    if (v48) {
      CGContextRestoreGState(c);
    }
    if (v14 != 0.0)
    {
      CGPoint v49 = CGContextGetTextPosition(c);
      CGContextSetTextPosition(c, v49.x, v49.y - v14);
    }
  }
  if (__dst)
  {
    double v53 = __dst;
    if (v55 > __dst || v56 <= __dst) {
      operator delete(__dst);
    }
  }
}

void CTFontDrawGlyphsWithAdvancesInternal(uint64_t a1, CGGlyph *a2, float64x2_t *a3, unint64_t a4, CGContextRef c, uint64_t a6)
{
  uint64_t v89 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    double v6 = a2;
    if (a2)
    {
      double v7 = a3;
      if (a3)
      {
        unint64_t v8 = a4;
        if (a4)
        {
          if (c)
          {
            uint64_t v10 = a6;
            if (a6)
            {
              unsigned __int8 v11 = *(unsigned char *)(a6 + 224) & 1;
              if (v11) {
                int v12 = -1;
              }
              else {
                int v12 = 1;
              }
            }
            else
            {
              unsigned __int8 v11 = 0;
              int v12 = 1;
            }
            int v64 = v12;
            BOOL v13 = a6 != 0;
            double v14 = *(TBaseFont ***)(a1 + 40);
            *(void *)&long long v15 = -1;
            *((void *)&v15 + 1) = -1;
            *(_OWORD *)&v84.c = v15;
            *(_OWORD *)&v84.tdouble x = v15;
            *(_OWORD *)&v84.CGFloat a = v15;
            CGContextGetTextMatrix(&v84, c);
            *(void *)&long long v16 = -1;
            *((void *)&v16 + 1) = -1;
            *(_OWORD *)&v83.c = v16;
            *(_OWORD *)&v83.tdouble x = v16;
            *(_OWORD *)&v83.CGFloat a = v16;
            long long v86 = *(_OWORD *)&v84.a;
            *(_OWORD *)uint64_t v87 = *(_OWORD *)&v84.c;
            *(_OWORD *)&v87[16] = *(_OWORD *)&v84.tx;
            CGAffineTransformInvert(&v83, (CGAffineTransform *)&v86);
            int Type = CGContextGetType();
            if (Type == 1 || v10 && v83.d < 0.0) {
              goto LABEL_19;
            }
            uint64_t v18 = TFont::ensureSVGTableObject((TFont *)v14);
            if (((v18 == 0) & v11) == 1)
            {
              if ((*(uint64_t (**)(TBaseFont *, uint64_t))(*(void *)v14[50] + 472))(v14[50], 1935829368))goto LABEL_19; {
            }
              }
            else if (v18)
            {
LABEL_19:
              *(_OWORD *)&v87[80] = xmmword_184B89B80;
              long long v19 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
              long long v86 = *MEMORY[0x1E4F1DAB8];
              *(_OWORD *)uint64_t v87 = v19;
              *(_OWORD *)&v87[16] = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 32);
              *(_OWORD *)&v87[32] = v86;
              *(_OWORD *)&v87[48] = v19;
              *(_OWORD *)&v87[64] = *(_OWORD *)&v87[16];
              *(void *)&v87[80] = v10;
              v87[88] = v13;
              *(_DWORD *)&v87[92] = Type;
              *(void *)&v87[96] = 0;
              v82[1] = *(float64x2_t *)&v83.c;
              _OWORD v82[2] = *(float64x2_t *)&v83.tx;
              v81[2] = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 32);
              v82[0] = *(float64x2_t *)&v83.a;
              v81[0] = v86;
              v81[1] = v19;
              DrawGlyphsWithAdvancesAndTransform(v14, v6, (uint64_t)v7, v8, c, v82, (double *)v81, (uint64_t)&v86);
              return;
            }
            if ((*(unsigned int (**)(TBaseFont *, uint64_t))(*(void *)v14[50] + 472))(v14[50], 1129270354))
            {
              goto LABEL_19;
            }
            double ColorBitmapFontTranslate = *MEMORY[0x1E4F1DAD8];
            double v21 = *(double *)(MEMORY[0x1E4F1DAD8] + 8);
            id v80 = (id)0xAAAAAAAAAAAAAAAALL;
            (*(void (**)(id *__return_ptr))(*(void *)v14[50] + 480))(&v80);
            if (!atomic_load_explicit((atomic_ullong *volatile)&v80, memory_order_acquire)) {
              goto LABEL_49;
            }
            memset(v79, 170, sizeof(v79));
            uint64_t explicit = (void *)atomic_load_explicit((atomic_ullong *volatile)&v80, memory_order_acquire);
            TBaseFont::GetGlyphCount(v14[50]);
            TsbixContext::TsbixContext((TsbixContext *)v79, explicit);
            if (v79[1]) {
              int v63 = (*((unsigned __int16 *)v79[1] + 1) >> 9) & 1;
            }
            else {
              int v63 = 0;
            }
            memset(&v87[8], 170, 0x3C0uLL);
            long long v86 = 0uLL;
            *(void *)uint64_t v87 = 0;
            uint64_t v88 = &v87[8];
            std::vector<CGRect,TInlineBufferAllocator<CGRect,30ul>>::__vallocate[abi:nn180100]((char **)&v86, v8);
            uint64_t v23 = *((void *)&v86 + 1);
            bzero(*((void **)&v86 + 1), 32 * v8);
            *((void *)&v86 + 1) = v23 + 32 * v8;
            if (((*(uint64_t (**)(void))(*(void *)v14[50] + 712))() & 1) != 0
              || TFont::HasBBoxes(v14[50], v6, v8, (CGRect *)v86))
            {
              *(void *)&long long v24 = -1;
              *((void *)&v24 + 1) = -1;
              *(_OWORD *)&v78.c = v24;
              *(_OWORD *)&v78.tdouble x = v24;
              *(_OWORD *)&v78.CGFloat a = v24;
              GetFontScaleTransform(&v78, (CGContext *)v14);
              *(void *)&long long v25 = -1;
              *((void *)&v25 + 1) = -1;
              *(_OWORD *)&v77.c = v25;
              *(_OWORD *)&v77.tdouble x = v25;
              *(_OWORD *)&v77.CGFloat a = v25;
              CGContextGetCTM(&v77, c);
              CGFloat a = v84.a;
              CGFloat b = v84.b;
              CGFloat v28 = v84.c;
              CGFloat d = v84.d;
              CGFloat v30 = v84.c + v84.a * 0.0;
              CGFloat v31 = v84.d + v84.b * 0.0;
              double v32 = fabs(v30);
              double v33 = fabs(v31);
              double v34 = hypot(v30, v31);
              CGFloat v35 = 1.0;
              BOOL v36 = v34 <= 1.0;
              tdouble x = v84.tx;
              tCGFloat y = v84.ty;
              if (v32 <= v33) {
                BOOL v36 = 0;
              }
              BOOL v62 = v36;
              if (!v36)
              {
                v76.CGFloat a = a;
                v76.CGFloat b = b;
                v76.c = v28;
                v76.CGFloat d = d;
                v76.tdouble x = v84.tx;
                v76.tCGFloat y = v84.ty;
                CGAffineTransformScale((CGAffineTransform *)t1, &v76, 1.0 / v34, 1.0 / v34);
                CGFloat a = *(double *)t1;
                CGFloat b = *(double *)&t1[8];
                CGFloat v28 = *(double *)&t1[16];
                CGFloat d = *(double *)&t1[24];
                CGFloat v35 = v34;
                tdouble x = *(double *)&t1[32];
                tCGFloat y = *(double *)&t1[40];
              }
              *(void *)&long long v39 = -1;
              *((void *)&v39 + 1) = -1;
              *(_OWORD *)&v75.c = v39;
              *(_OWORD *)&v75.tdouble x = v39;
              *(_OWORD *)&v75.CGFloat a = v39;
              *(CGFloat *)CGAffineTransform t1 = a;
              *(CGFloat *)&t1[8] = b;
              *(CGFloat *)&t1[16] = v28;
              *(CGFloat *)&t1[24] = d;
              *(CGFloat *)&t1[32] = tx;
              *(CGFloat *)&t1[40] = ty;
              CGAffineTransform t2 = v77;
              CGAffineTransformConcat(&v75, (CGAffineTransform *)t1, &t2);
              CGAffineTransform v74 = v75;
              CGContextSetCTM();
              FillColorAsColor = (CGColor *)CGContextGetFillColorAsColor();
              AlphCGFloat a = CGColorGetAlpha(FillColorAsColor);
              double ContentsScale = GetContentsScale(c);
              double ColorBitmapFontTranslate = TFont::GetColorBitmapFontTranslate((TFont *)v14);
              double v21 = v43;
              *(void *)&long long v44 = -1;
              *((void *)&v44 + 1) = -1;
              *(_OWORD *)&t2.c = v44;
              *(_OWORD *)&t2.tdouble x = v44;
              *(_OWORD *)&t2.CGFloat a = v44;
              float64x2_t v65 = *(float64x2_t *)&v84.tx;
              if (v62) {
                CGAffineTransform t2 = v83;
              }
              else {
                CGAffineTransformMakeScale(&t2, v35, v35);
              }
              uint64_t v45 = 0;
              double v60 = v6;
              double v46 = v7;
              unint64_t v47 = v8;
              uint64_t v61 = v10;
              float64x2_t v48 = v65;
              do
              {
                double v49 = v48.f64[1];
                float64x2_t v66 = v48;
                if (v62)
                {
                  double v50 = v48.f64[0];
                }
                else
                {
                  double v50 = v83.tx + v48.f64[1] * v83.c + v83.a * v48.f64[0];
                  double v49 = v83.ty + v48.f64[1] * v83.d + v83.b * v48.f64[0];
                }
                unsigned int v51 = *v6;
                *(void *)CGAffineTransform t1 = -1;
                *(void *)&t1[8] = -1;
                *(void *)&t1[16] = 0xAAAAAAAAAAAAAAAALL;
                *(void *)&long long v52 = -1;
                *((void *)&v52 + 1) = -1;
                *(_OWORD *)&t1[24] = v52;
                *(_OWORD *)&t1[40] = v52;
                uint64_t v73 = -1;
                v92.double x = ColorBitmapFontTranslate;
                v92.CGFloat y = v21;
                if (atomic_load_explicit((atomic_ullong *volatile)&t1[16], memory_order_acquire))
                {
                  if (Alpha != 0.0)
                  {
                    CGPoint v53 = (CGPoint)vaddq_f64(*(float64x2_t *)&t2.tx, vmlaq_n_f64(vmulq_n_f64(*(float64x2_t *)&t2.c, v49+ v78.ty+ *(double *)(v86 + v45 + 8) * v78.d+ v78.b * *(double *)(v86 + v45)), *(float64x2_t *)&t2.a, v50+ v78.tx+ *(double *)(v86 + v45 + 8) * v78.c+ v78.a * *(double *)(v86 + v45)));
                    CGFloat y = v53.y;
                  }
                  if ((v63 & 1) == 0)
                  {
                    v90.double x = v50;
                    v90.CGFloat y = v49;
                    DrawInvisibleGlyph(c, v51, v90, MEMORY[0x1E4F1DAB8], MEMORY[0x1E4F1DAB8]);
                  }
                }
                else if ((v63 & 1) == 0)
                {
                  CGAffineTransform v71 = v77;
                  CGContextSetCTM();
                  v91.double x = ColorBitmapFontTranslate + v50;
                  v91.CGFloat y = v21 + v49;
                  DrawVisibleGlyph(c, v51, v91, MEMORY[0x1E4F1DAB8], MEMORY[0x1E4F1DAB8]);
                  CGAffineTransform v70 = v75;
                  CGContextSetCTM();
                }
                float64x2_t v55 = *v46++;

                float64x2_t v48 = vaddq_f64(v66, v55);
                v45 += 32;
                ++v6;
                --v47;
                uint64_t v10 = v61;
              }
              while (v47);
              CGAffineTransform v69 = v77;
              CGContextSetCTM();
              double v6 = v60;
            }
            *(void *)CGAffineTransform t1 = &v86;
            std::vector<CGRect,TInlineBufferAllocator<CGRect,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)t1);

            if (!v63)
            {
              float64x2_t v58 = *(float64x2_t *)&v84.tx;
              do
              {
                float64x2_t v59 = *v7++;
                float64x2_t v58 = vaddq_f64(v58, v59);
                --v8;
              }
              while (v8);
              CGContextSetTextPosition(c, v58.f64[0], v58.f64[1]);
            }
            else
            {
LABEL_49:
              if (ColorBitmapFontTranslate != 0.0 || v21 != 0.0)
              {
                CGPoint TextPosition = CGContextGetTextPosition(c);
                CGContextSetTextPosition(c, ColorBitmapFontTranslate + TextPosition.x, v21 + TextPosition.y);
              }
              if (v10)
              {
                CGAffineTransform v68 = v84;
                BOOL v57 = HandleFlippedTextMatrix(c, &v68);
              }
              else
              {
                BOOL v57 = 0;
              }
              v67[0] = MEMORY[0x1E4F143A8];
              v67[1] = 3221225472;
              v67[2] = __CTFontDrawGlyphsWithAdvancesInternal_block_invoke;
              v67[3] = &__block_descriptor_56_e16_v28__0___qq_8B24l;
              unsigned int v67[4] = c;
              void v67[5] = v6;
              v67[6] = v7;
              EnumerateOverlappingGlyphs((atomic_ullong *)v14[50], v6, v8, v64, (uint64_t)v67);
              if (v57) {
                RestoreFlippedTextMatrix(c);
              }
            }
          }
        }
      }
    }
  }
}

void TTenuousComponentFont::CopyTable(atomic_uint *this@<X0>, uint64_t a2@<X1>, atomic_ullong *a3@<X8>)
{
  if ((int)a2 <= 1398163231)
  {
    if (a2 == 1129270354
      || a2 == 1398030676
      && ((*(uint64_t (**)(atomic_uint *, uint64_t))(*(void *)this + 472))(this, 1398030676) & 1) == 0)
    {
      goto LABEL_13;
    }
  }
  else if (a2 == 1398163232 || a2 == 1634561906 || a2 == 1935829368)
  {
    goto LABEL_13;
  }
  if (((*(uint64_t (**)(atomic_uint *))(*(void *)this + 896))(this) & 1) == 0)
  {
LABEL_13:
    *a3 = 0;
    return;
  }

  TBaseFont::CopyTable(this, a2, a3);
}

uint64_t TFont::ensureSVGTableObject(TFont *this)
{
  CFDictionaryRef v2 = (os_unfair_lock_s *)((char *)this + 504);
  os_unfair_lock_lock_with_options();
  if (*((unsigned char *)this + 520)) {
    BOOL v3 = 1;
  }
  else {
    BOOL v3 = MEMORY[0x1E4F83A38] == 0;
  }
  if (!v3)
  {
    id v6 = (id)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(id *__return_ptr))(**((void **)this + 50) + 480))(&v6);
    if (atomic_load_explicit((atomic_ullong *volatile)&v6, memory_order_acquire))
    {
      atomic_load_explicit((atomic_ullong *volatile)&v6, memory_order_acquire);
      if (!*((_DWORD *)this + 12)) {
        TFont::InitStrikeMetrics(this);
      }
      *((void *)this + 64) = OTSVGTableCreateFromData();
    }
  }
  *((unsigned char *)this + 520) = 1;
  uint64_t v4 = *((void *)this + 64);
  os_unfair_lock_unlock(v2);
  return v4;
}

BOOL TAttributes::SetContextAttributes(atomic_ullong *this, CGContext *a2, char a3)
{
  if ((a3 & 1) == 0) {
    atomic_load_explicit(this + 2, memory_order_acquire);
  }
  TFont::SetInContext(*(TBaseFont ***)(atomic_load_explicit(this + 2, memory_order_acquire) + 40), a2);
  char v6 = *((unsigned char *)this + 136);
  if (!v6)
  {
    CGContextSetFillColorWithColor(a2, 0);
    return 0;
  }
  BOOL v7 = (v6 & 0x1C) != 0;
  if ((this[17] & 0x1C) != 0)
  {
    CGContextSaveGState(a2);
    char v6 = *((unsigned char *)this + 136);
  }
  if (v6)
  {
    if ((v6 & 4) == 0) {
      goto LABEL_8;
    }
LABEL_16:
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit(this, memory_order_acquire), @"NSStrokeWidth");
    if (!Value) {
      goto LABEL_23;
    }
    double valuePtr = NAN;
    CFNumberGetValue(Value, kCFNumberDoubleType, &valuePtr);
    double v11 = *(double *)(*(void *)(atomic_load_explicit(this + 2, memory_order_acquire) + 40) + 16);
    double v12 = valuePtr * (v11 * 0.01);
    double valuePtr = v12;
    if (v12 <= 0.0)
    {
      if (v12 >= 0.0)
      {
        CGContextSetTextDrawingMode(a2, kCGTextFill);
        goto LABEL_23;
      }
      CGContextSetTextDrawingMode(a2, kCGTextFillStroke);
      double v13 = -valuePtr;
    }
    else
    {
      CGContextSetTextDrawingMode(a2, kCGTextStroke);
      double v13 = valuePtr;
    }
    CGContextSetLineWidth(a2, v13);
LABEL_23:
    StrokeColor = (void *)TAttributes::GetStrokeColor((TAttributes *)atomic_load_explicit(this, memory_order_acquire), 0, v10);
    if (!StrokeColor)
    {
      if ((this[17] & 2) != 0) {
        StrokeColor = (void *)atomic_load_explicit(this + 4, memory_order_acquire);
      }
      else {
        StrokeColor = 0;
      }
    }
    TAttributes::SetStrokeColor(a2, StrokeColor, v15);
    char v6 = *((unsigned char *)this + 136);
    if ((v6 & 0x10) == 0) {
      goto LABEL_9;
    }
LABEL_28:
    CGContextSetStyle();
    return v7;
  }
  if ((v6 & 2) != 0) {
    uint64_t explicit = (void *)atomic_load_explicit(this + 4, memory_order_acquire);
  }
  else {
    uint64_t explicit = 0;
  }
  TAttributes::SetFillColor(a2, explicit, v5);
  char v6 = *((unsigned char *)this + 136);
  if ((v6 & 4) != 0) {
    goto LABEL_16;
  }
LABEL_8:
  if ((v6 & 0x10) != 0) {
    goto LABEL_28;
  }
LABEL_9:
  if ((v6 & 8) != 0) {
    SetNSShadow(a2, (id)atomic_load_explicit(this + 5, memory_order_acquire));
  }
  return v7;
}

void TFont::SetInContext(TBaseFont **this, CGContext *a2)
{
  uint64_t InitializedGraphicsFont = (CGFont *)TBaseFont::GetInitializedGraphicsFont(this[50]);
  if (InitializedGraphicsFont)
  {
    CGContextSetFont(a2, InitializedGraphicsFont);
    CGFloat v5 = *((double *)this + 2);
    CGContextSetFontSize(a2, v5);
  }
}

void TAttributes::SetFillColor(CGContextRef c, void *cf, const void *a3)
{
  if (!cf)
  {
    if (qword_1EB2CE328 != -1) {
      dispatch_once_f(&qword_1EB2CE328, 0, (dispatch_function_t)GetBlackColor(void)::$_0::__invoke);
    }
    BOOL v7 = (CGColor *)qword_1EB2CE320;
    char v6 = c;
    goto LABEL_7;
  }
  CFTypeID v5 = CFGetTypeID(cf);
  if (v5 == CGColorGetTypeID())
  {
    char v6 = c;
    BOOL v7 = (CGColor *)cf;
LABEL_7:
    CGContextSetFillColorWithColor(v6, v7);
    return;
  }

  SetNSColor(c, cf);
}

void SetNSColor(CGContext *a1, id a2)
{
  BOOL v3 = (CGColor *)objc_msgSend(a2, sel_CGColor);
  CGContextSetFillColorWithColor(a1, v3);

  CGContextSetStrokeColorWithColor(a1, v3);
}

char *std::vector<CGSize,TInlineBufferAllocator<CGSize,64ul>>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >> 60) {
    abort();
  }
  uint64_t v4 = (char *)(a1 + 131);
  uint64_t result = (char *)a1[131];
  char v6 = &result[16 * a2];
  if (v6 <= v4) {
    *(void *)uint64_t v4 = v6;
  }
  else {
    uint64_t result = (char *)operator new(16 * a2);
  }
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * a2];
  return result;
}

void TRun::DrawBackground(TRun *this, CGContextRef c, CFRange a3, const TAttributes *a4, int a5)
{
  CFIndex length = a3.length;
  CFIndex location = a3.location;
  if (!a4)
  {
    uint64_t v10 = *((void *)this + 34);
    if (v10 && atomic_load_explicit((atomic_ullong *volatile)(v10 + 168), memory_order_acquire)) {
      return;
    }
    a4 = (TRun *)((char *)this + 40);
  }
  if (TAttributes::SetContextAttributesForBackground(a4, c))
  {
    CGPoint TextPosition = CGContextGetTextPosition(c);
    double x = TextPosition.x;
    double y = TextPosition.y;
    if (a5)
    {
      while (!atomic_load_explicit((atomic_ullong *volatile)this + 35, memory_order_acquire))
      {
        uint64_t v14 = *((void *)this + 34);
        if (!v14) {
          break;
        }
        TLine::CachePositions(v14);
      }
      double x = TextPosition.x + *((double *)this + 36);
      double y = TextPosition.y + *((double *)this + 37);
    }
    v36.origin.double x = (*(double (**)(TRun *))(*(void *)this + 152))(this);
    CGRect v37 = CGRectOffset(v36, x, y);
    double v15 = v37.origin.x;
    CGFloat v16 = v37.origin.y;
    CGFloat height = v37.size.height;
    if (length >= *((void *)this + 26))
    {
      double width = v37.size.width;
    }
    else
    {
      v34.CFIndex location = 0;
      v34.CFIndex length = location;
      double v18 = TStorageRange::GetWidth((TRun *)((char *)this + 192), v34);
      long long v19 = (double *)*((void *)this + 39);
      uint64_t v20 = (double *)MEMORY[0x1E4F1DB30];
      if (!v19) {
        long long v19 = (double *)MEMORY[0x1E4F1DB30];
      }
      double v21 = v18 + *v19;
      v35.CFIndex location = location;
      v35.CFIndex length = length;
      double v22 = TStorageRange::GetWidth((TRun *)((char *)this + 192), v35);
      double v23 = 0.0;
      if (!location)
      {
        long long v24 = (double *)*((void *)this + 39);
        if (!v24) {
          long long v24 = v20;
        }
        double v23 = *v24;
      }
      double v15 = v15 + v21;
      double width = v22 + v23;
    }
    *(void *)&long long v26 = -1;
    *((void *)&v26 + 1) = -1;
    *(_OWORD *)&v32.c = v26;
    *(_OWORD *)&v32.tdouble x = v26;
    *(_OWORD *)&v32.CGFloat a = v26;
    CGContextGetUserSpaceToDeviceSpaceTransform(&v32, c);
    CGAffineTransform v33 = v32;
    v38.origin.double x = v15;
    v38.origin.double y = v16;
    v38.size.double width = width;
    v38.size.CGFloat height = height;
    CGRect v39 = CGRectApplyAffineTransform(v38, &v33);
    CGFloat v27 = v39.origin.y;
    CGFloat v28 = v39.size.height;
    CGFloat v29 = floor(v39.origin.x);
    CGFloat v30 = floor(CGRectGetMaxX(v39)) - v29;
    CGAffineTransform v33 = v32;
    CGAffineTransformInvert(&v31, &v33);
    CGAffineTransform v33 = v31;
    v40.origin.double x = v29;
    v40.origin.double y = v27;
    v40.size.double width = v30;
    v40.size.CGFloat height = v28;
    CGRect v41 = CGRectApplyAffineTransform(v40, &v33);
    CGContextFillRect(c, v41);
    CGContextRestoreGState(c);
  }
}

uint64_t TAttributes::SetContextAttributesForBackground(TAttributes *this, CGContextRef c)
{
  char v2 = *((unsigned char *)this + 137);
  if (v2)
  {
    CGContextSaveGState(c);
    BackgroundColor = (void *)TAttributes::GetBackgroundColor((TAttributes *)atomic_load_explicit((atomic_ullong *volatile)this, memory_order_acquire), 0, v5);
    TAttributes::SetFillColor(c, BackgroundColor, v7);
    CGContextSetShadowWithColor(c, *MEMORY[0x1E4F1DB30], 0.0, 0);
  }
  return v2 & 1;
}

BOOL HandleFlippedTextMatrix(CGContext *a1, CGAffineTransform *a2)
{
  double d = a2->d;
  if (d < 0.0)
  {
    CGContextSaveGState(a1);
    CGContextTranslateCTM(a1, 0.0, a2->ty + a2->ty);
    CGContextScaleCTM(a1, 1.0, -1.0);
    a2->double d = -a2->d;
    long long v5 = *(_OWORD *)&a2->tx;
    *(_OWORD *)&v7.c = *(_OWORD *)&a2->c;
    *(_OWORD *)&v7.tdouble x = v5;
    *(_OWORD *)&v7.CGFloat a = *(_OWORD *)&a2->a;
    CGContextSetTextMatrix(a1, &v7);
  }
  return d < 0.0;
}

uint64_t TTrackingEngine::TrackRuns(TTrackingEngine *this, TLine *a2, const TCharStream *a3, CFRange a4, double a5)
{
  uint64_t result = 0;
  __b[65] = *MEMORY[0x1E4F143B8];
  if (a4.location >= 1 && a5 != 0.0)
  {
    uint64_t v10 = (uint64_t)a3 + a4.location - 1;
    if (v10 < 1)
    {
      uint64_t v11 = 0;
      uint64_t v10 = 0;
    }
    else
    {
      uint64_t v11 = 0;
      double v12 = (uint64_t *)*((void *)this + 2);
      double v13 = (char *)a3 + a4.location - 1;
      do
      {
        uint64_t v14 = *v12++;
        v11 += *(void *)(*(void *)(v14 + 40) + 208);
        --v13;
      }
      while (v13);
    }
    int v15 = 0;
    for (uint64_t i = *(void *)(*(void *)(*((void *)this + 2) + 8 * v10) + 48); ; v11 -= *(void *)(i + 208))
    {
      if ((*(_WORD *)(i + 178) & 0x40) == 0)
      {
        if (*(unsigned char *)(i + 260)) {
          goto LABEL_14;
        }
        uint64_t v17 = *(void *)(*(void *)(atomic_load_explicit((atomic_ullong *volatile)(i + 56), memory_order_acquire) + 40)
                        + 400);
        if ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v17 + 472))(v17, 1786082164)) {
          goto LABEL_14;
        }
        memset(__b, 170, 0x208uLL);
        uint64_t v18 = *(void *)(i + 8);
        __b[0] = *(void *)(i + 16) + v18;
        __b[1] = v18;
        LOBYTE(__b[5]) = 0;
        __b[2] = 0;
        __b[3] = 0;
        *(void *)((char *)&__b[3] + 5) = 0;
        __b[6] = this;
        __b[7] = a2;
        memset(&__b[8], 0, 208);
        __b[28] = *((void *)a2 + 2);
        __b[64] = &__b[34];
        BOOL Run = TScriptRun::NextRun((uint64_t)__b, 0);
        int v22 = __b[4];
        double v23 = (void **)&__b[31];
        std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](&v23);
        if (!Run) {
          goto LABEL_17;
        }
        if (v22 == 1634885986)
        {
LABEL_14:
          v15 |= TJustEngine::ApplyTrackingToRun(this, a2, (const TCharStream *)v10, v11, a5);
        }
        else
        {
LABEL_17:
          TSimpleTracking::TrackRun((void *)i, v20, a5);
          int v15 = 1;
        }
      }
      if (v10 <= (uint64_t)a3) {
        break;
      }
      uint64_t v21 = *((void *)this + 2) + 8 * v10--;
      uint64_t i = *(void *)(*(void *)(v21 - 8) + 48);
    }
    return v15 & 1;
  }
  return result;
}

uint64_t TTenuousComponentFont::HasTable(atomic_uint *this, int a2)
{
  uint64_t result = 0;
  if (a2 <= 1634561905)
  {
    if (a2 == 1129270354) {
      return result;
    }
    if (a2 != 1398030676)
    {
      if (a2 == 1398163232) {
        return result;
      }
      goto LABEL_11;
    }
    return (*((unsigned __int8 *)this + 712) >> 2) & 1;
  }
  if (a2 == 1634561906 || a2 == 1935829368) {
    return result;
  }
  if (a2 == 1953653099) {
    return (*((unsigned __int8 *)this + 712) >> 2) & 1;
  }
LABEL_11:
  uint64_t result = (*(uint64_t (**)(atomic_uint *))(*(void *)this + 896))(this);
  if (result)
  {
    return TBaseFont::HasTable(this, a2);
  }
  return result;
}

unint64_t TTenuousComponentFont::Substantiate(TTenuousComponentFont *this)
{
  char v2 = (os_unfair_lock_s *)((char *)this + 796);
  os_unfair_lock_lock_with_options();
  unint64_t explicit = 1;
  if (!atomic_load_explicit((atomic_ullong *volatile)this + 10, memory_order_acquire))
  {
    if (atomic_exchange((atomic_uchar *volatile)this + 800, 1u)) {
      goto LABEL_17;
    }
    unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)this + 12, memory_order_acquire);
    if (explicit)
    {
      CFArrayRef ComponentAttribute = (atomic_ullong *)TComponentFont::GetComponentAttribute((atomic_ullong *)this, @"url");
      if (ComponentAttribute)
      {
        v11.unint64_t isa = (void *)0xAAAAAAAAAAAAAAAALL;
        CopyComponentFontDescriptorWithBaseSystemFallback(&v11, (atomic_ullong *)explicit, ComponentAttribute, 1024);
        if (atomic_load_explicit((atomic_ullong *volatile)&v11, memory_order_acquire))
        {
          long long v5 = (TDescriptor **)(id)atomic_load_explicit((atomic_ullong *volatile)&v11, memory_order_acquire);
          char v6 = v5;
          CGAffineTransform v7 = v5[5];
          if ((*((_DWORD *)v7 + 4) & 0x80000000) == 0) {
            TDescriptor::InitBaseFont(v5[5], 0, 0.0);
          }
          unint64_t v8 = atomic_load_explicit((atomic_ullong *volatile)v7 + 4, memory_order_acquire);

          if (v8)
          {
            (*(void (**)(id *__return_ptr, unint64_t))(*(void *)v8 + 200))(&v10, v8);

LABEL_13:
            unint64_t explicit = 1;
            goto LABEL_18;
          }
        }
        else
        {
          CFLog();
        }
      }
      else
      {

        if (atomic_load_explicit((atomic_ullong *volatile)this + 11, memory_order_acquire))
        {
          atomic_load_explicit((atomic_ullong *volatile)this + 11, memory_order_acquire);
          v11.unint64_t isa = (void *)CGFontURLCreate();
        }
        if (atomic_load_explicit((atomic_ullong *volatile)this + 10, memory_order_acquire)) {
          goto LABEL_13;
        }
        CFLog();
      }
LABEL_17:
      unint64_t explicit = 0;
    }
  }
LABEL_18:
  os_unfair_lock_unlock(v2);
  return explicit;
}

uint64_t TBaseFont::HasTable(atomic_uint *this, int a2)
{
  if (a2 && (int v4 = TableFlagForIdentifier(a2), (this[44] & v4) == 0))
  {
    int v6 = v4;
    uint64_t InitializedGraphicsFont = (CGFont *)TBaseFont::GetInitializedGraphicsFont((TBaseFont *)this);
    CFArrayRef v8 = CGFontCopyTableTags(InitializedGraphicsFont);
    CFArrayRef v9 = v8;
    if (v8 && (CFIndex Count = CFArrayGetCount(v8)) != 0)
    {
      CFIndex v11 = Count;
      char v5 = 0;
      CFIndex v12 = 0;
      unsigned int v13 = 0x7FFFFF;
      do
      {
        int ValueAtIndex = CFArrayGetValueAtIndex(v9, v12);
        if (ValueAtIndex == a2)
        {
          char v5 = 1;
          int v15 = v6;
        }
        else
        {
          int v15 = TableFlagForIdentifier(ValueAtIndex);
        }
        v13 &= ~v15;
        ++v12;
      }
      while (v11 != v12);
    }
    else
    {
      char v5 = 0;
      unsigned int v13 = 0x7FFFFF;
    }
    atomic_fetch_or_explicit(this + 44, v13, memory_order_relaxed);
  }
  else
  {
    char v5 = 0;
  }
  return v5 & 1;
}

uint64_t TableFlagForIdentifier(int a1)
{
  if (a1 <= 1717920115)
  {
    if (a1 <= 1296388678)
    {
      if (a1 <= 1195656517)
      {
        if (a1 == 1111577413) {
          return 0x10000;
        }
        if (a1 == 1129270354) {
          return 32;
        }
      }
      else
      {
        switch(a1)
        {
          case 1195656518:
            return 256;
          case 1196445523:
            return 128;
          case 1196643650:
            return 64;
        }
      }
    }
    else if (a1 > 1398163231)
    {
      switch(a1)
      {
        case 1398163232:
          return 1024;
        case 1634626418:
          return 0x20000;
        case 1651731566:
          return 0x8000;
      }
    }
    else
    {
      switch(a1)
      {
        case 1296388679:
          return 2;
        case 1330851634:
          return 0x100000;
        case 1398030676:
          return 0x200000;
      }
    }
  }
  else if (a1 > 1819566438)
  {
    if (a1 > 1886547823)
    {
      switch(a1)
      {
        case 1886547824:
          return 2048;
        case 1935829368:
          return 0x2000;
        case 1953653099:
          return 8;
      }
    }
    else
    {
      switch(a1)
      {
        case 1819566439:
          return 0x400000;
        case 1836020344:
          return 4;
        case 1869636196:
          return 0x40000;
      }
    }
  }
  else if (a1 > 1801810541)
  {
    switch(a1)
    {
      case 1801810542:
        return 1;
      case 1801810552:
        return 0x4000;
      case 1818452338:
        return 4096;
    }
  }
  else
  {
    switch(a1)
    {
      case 1717920116:
        return 16;
      case 1751474532:
        return 0x80000;
      case 1786082164:
        return 512;
    }
  }
  return 0;
}

BOOL TScriptRun::NextRun(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)a1;
  uint64_t v4 = *(void *)(a1 + 16) + *(void *)(a1 + 8);
  if (v4 >= *(void *)a1)
  {
    uint64_t v53 = *(void *)(a1 + 16) + *(void *)(a1 + 8);
    uint64_t v8 = v4;
LABEL_10:
    uint64_t v50 = v4;
    *(void *)(a1 + 24) = 0;
    if (v8 >= v3)
    {
      int v13 = 0;
    }
    else
    {
      int v13 = 0;
      uint64_t v14 = (TCharStreamIterator *)(a1 + 56);
      unsigned int v51 = (unint64_t *)(a1 + 512);
      do
      {
        Fullunsigned int Char = TCharStreamIterator::GetFullChar(v14, &v53, 0);
        int Script = uscript_getScript();
        int v17 = Script;
        if (Script <= 1)
        {
          if (*(unsigned char *)(a1 + 40))
          {
            int v17 = *(_DWORD *)(a1 + 36);
          }
          else if ((a2 & 0xFF00000000) != 0)
          {
            int v17 = a2;
          }
          else
          {
            int v17 = Script;
          }
        }
        IntPropertyCFNumberRef Value = u_getIntPropertyValue(FullChar, UCHAR_BIDI_PAIRED_BRACKET_TYPE);
        int32_t v19 = IntPropertyValue;
        if (IntPropertyValue)
        {
          if (IntPropertyValue == 1)
          {
            ++*(void *)(a1 + 24);
            uint64_t v20 = *(char **)(a1 + 256);
            unint64_t v21 = *(void *)(a1 + 264);
            if ((unint64_t)v20 >= v21)
            {
              CGFloat v28 = *(char **)(a1 + 248);
              uint64_t v29 = (v20 - v28) >> 3;
              unint64_t v30 = v29 + 1;
              if ((unint64_t)(v29 + 1) >> 61) {
                abort();
              }
              if ((uint64_t)(v21 - (void)v28) >> 2 > v30) {
                unint64_t v30 = (uint64_t)(v21 - (void)v28) >> 2;
              }
              if (v21 - (unint64_t)v28 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v31 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v31 = v30;
              }
              CGAffineTransform v32 = (char *)*v51;
              unint64_t v33 = *v51 + 8 * v31;
              if (v33 <= (unint64_t)v51)
              {
                unint64_t *v51 = v33;
              }
              else
              {
                if (v31 >> 61) {
                  std::__throw_bad_array_new_length[abi:nn180100]();
                }
                unint64_t v49 = v31;
                CGAffineTransform v32 = (char *)operator new(8 * v31);
                unint64_t v31 = v49;
              }
              CFRange v34 = &v32[8 * v29];
              *(_DWORD *)CFRange v34 = FullChar;
              *((_DWORD *)v34 + 1) = v13;
              CFRange v35 = v34;
              if (v20 == v28)
              {
                uint64_t v14 = (TCharStreamIterator *)(a1 + 56);
              }
              else
              {
                uint64_t v14 = (TCharStreamIterator *)(a1 + 56);
                do
                {
                  uint64_t v36 = *((void *)v20 - 1);
                  v20 -= 8;
                  *((void *)v35 - 1) = v36;
                  v35 -= 8;
                }
                while (v20 != v28);
                uint64_t v20 = *(char **)(a1 + 248);
                unint64_t v21 = *(void *)(a1 + 264);
              }
              int v22 = v34 + 8;
              *(void *)(a1 + 248) = v35;
              *(void *)(a1 + 256) = v34 + 8;
              *(void *)(a1 + 264) = &v32[8 * v31];
              if (v20)
              {
                if (a1 + 272 <= (unint64_t)v20 && v51 > (unint64_t *)v20)
                {
                  if (v21 == *v51) {
                    unint64_t *v51 = (unint64_t)v20;
                  }
                }
                else
                {
                  operator delete(v20);
                }
                uint64_t v14 = (TCharStreamIterator *)(a1 + 56);
              }
            }
            else
            {
              *(_DWORD *)uint64_t v20 = FullChar;
              *((_DWORD *)v20 + 1) = v13;
              int v22 = v20 + 8;
            }
            *(void *)(a1 + 256) = v22;
          }
          else
          {
            int v23 = MEMORY[0x185327FA0](FullChar);
            long long v24 = *(_DWORD **)(a1 + 248);
            long long v25 = *(_DWORD **)(a1 + 256);
            if (v24 != v25)
            {
              long long v26 = v25 - 2;
              while (*v26 != v23)
              {
                uint64_t v27 = *(void *)(a1 + 24);
                if (v27) {
                  *(void *)(a1 + 24) = v27 - 1;
                }
                *(void *)(a1 + 256) = v26;
                BOOL v12 = v26 == v24;
                v26 -= 2;
                if (v12) {
                  goto LABEL_56;
                }
              }
              int v17 = v26[1];
            }
          }
        }
LABEL_56:
        if (v13 == v17 || v13 < 2 || v17 < 2)
        {
          if (v13 <= 1 && v17 >= 2)
          {
            uint64_t v40 = *(void *)(a1 + 24);
            if (v40)
            {
              CGRect v41 = (int *)(*(void *)(a1 + 256) - 4);
              uint64_t v42 = -8 * v40;
              do
              {
                *CGRect v41 = v17;
                v41 -= 2;
                v42 += 8;
              }
              while (v42);
            }
            *(void *)(a1 + 24) = 0;
            int v13 = v17;
          }
        }
        else if (!uscript_hasScript())
        {
          break;
        }
        if (v19 == 2)
        {
          uint64_t v44 = *(void *)(a1 + 256);
          if (*(void *)(a1 + 248) != v44)
          {
            uint64_t v45 = *(void *)(a1 + 24);
            if (v45) {
              *(void *)(a1 + 24) = v45 - 1;
            }
            *(void *)(a1 + 256) = v44 - 8;
          }
        }
        uint64_t v8 = v53 + 1;
        uint64_t v53 = v8;
      }
      while (v8 < *(void *)a1);
    }
    *(void *)(a1 + 8) = v50;
    *(void *)(a1 + 16) = v8 - v50;
    int v46 = ScriptTagForScriptCode(v13);
    *(_DWORD *)(a1 + 32) = v46;
    if (v46 != 1145457748)
    {
      *(_DWORD *)(a1 + 36) = v13;
      *(unsigned char *)(a1 + 40) = 1;
    }
    uint64_t v4 = v50;
  }
  else
  {
    char v5 = *(TLine **)(a1 + 48);
    uint64_t v6 = 2863311360;
    char v7 = 1;
    uint64_t v8 = v4;
    while (1)
    {
      uint64_t RunWithCharIndex = TLine::FindRunWithCharIndex(v5, v8, 1);
      char v5 = *(TLine **)(a1 + 48);
      uint64_t v10 = *(void *)(*(void *)(*((void *)v5 + 2) + 8 * RunWithCharIndex) + 40);
      uint64_t v11 = *(unsigned int *)(v10 + 304);
      if (v11 == -1) {
        break;
      }
      if ((v7 & 1) != 0 || (BOOL v12 = v6 == v11, v11 = v6, v12))
      {
        char v7 = 0;
        uint64_t v8 = *(void *)(v10 + 16) + *(void *)(v10 + 8);
        uint64_t v6 = v11;
        if (v8 < *(void *)a1) {
          continue;
        }
      }
      goto LABEL_84;
    }
    uint64_t v53 = v8;
    if (v7)
    {
      uint64_t v3 = *(void *)a1;
      goto LABEL_10;
    }
LABEL_84:
    int v47 = ScriptTagForScriptCode(v6);
    *(_DWORD *)(a1 + 32) = v47;
    if (v47 != 1145457748)
    {
      *(_DWORD *)(a1 + 36) = v6;
      *(unsigned char *)(a1 + 40) = 1;
    }
    *(void *)(a1 + 8) = v4;
    *(void *)(a1 + 16) = v8 - v4;
  }
  return v4 < v8;
}

uint64_t TCharStreamIterator::GetFullChar(TCharStreamIterator *this, uint64_t *a2, CFRange *a3)
{
  uint64_t Char = TCharStreamIterator::GetChar(this, *a2);
  uint64_t v7 = Char;
  if ((Char & 0xF800) != 0xD800) {
    goto LABEL_13;
  }
  if ((Char & 0xFC00) != 0xDC00)
  {
    if ((Char & 0xFC00) == 0xD800)
    {
      uint64_t v8 = *a2 + 1;
      if (v8 < *(void *)(*(void *)this + 16))
      {
        int v9 = TCharStreamIterator::GetChar(this, *a2 + 1);
        if ((v9 & 0xFC00) == 0xDC00)
        {
          uint64_t v7 = (v9 + (v7 << 10) - 56613888);
          if (a3)
          {
            a3->CFIndex location = *a2;
            a3->CFIndex length = 2;
          }
          *a2 = v8;
          return v7;
        }
      }
    }
    goto LABEL_13;
  }
  uint64_t v10 = *a2;
  if (*a2 <= *(void *)(*(void *)this + 8)
    || (v11 = v10 - 1, int v12 = TCharStreamIterator::GetChar(this, v10 - 1), (v12 & 0xFC00) != 0xD800))
  {
LABEL_13:
    if (a3)
    {
      a3->CFIndex location = *a2;
      a3->CFIndex length = 1;
    }
    return v7;
  }
  uint64_t v7 = (v7 + (v12 << 10) - 56613888);
  if (a3)
  {
    a3->CFIndex location = v11;
    a3->CFIndex length = 2;
  }
  return v7;
}

uint64_t TCharStreamCFString::GetCharacterAtIndex(atomic_ullong *this, CFStringInlineBuffer *buffer, int64_t a3)
{
  if (!buffer->theString)
  {
    CFStringRef explicit = (const __CFString *)atomic_load_explicit(this + 4, memory_order_acquire);
    CFIndex v6 = this[2];
    buffer->theCFStringRef String = explicit;
    buffer->rangeToBuffer.CFIndex location = 0;
    buffer->rangeToBuffer.CFIndex length = v6;
    CharactersPtr = CFStringGetCharactersPtr(explicit);
    buffer->directUniCharBuffer = CharactersPtr;
    if (CharactersPtr)
    {
      buffer->directCStringBuffer = 0;
LABEL_5:
      CFIndex length = buffer->rangeToBuffer.length;
      buffer->CFIndex bufferedRangeStart = 0;
      buffer->bufferedRangeEndouble d = length;
      goto LABEL_6;
    }
    CStringPtr = CFStringGetCStringPtr(explicit, 0x600u);
    directUniCharBuffer = buffer->directUniCharBuffer;
    buffer->directCStringBuffer = CStringPtr;
    buffer->CFIndex bufferedRangeStart = 0;
    buffer->bufferedRangeEndouble d = 0;
    if ((unint64_t)directUniCharBuffer | (unint64_t)CStringPtr) {
      goto LABEL_5;
    }
  }
LABEL_6:
  if (a3 < 0) {
    return 0;
  }
  CFIndex v11 = buffer->rangeToBuffer.length;
  if (v11 <= a3)
  {
    return 0;
  }
  else
  {
    int v12 = buffer->directUniCharBuffer;
    if (v12)
    {
      return v12[buffer->rangeToBuffer.location + a3];
    }
    else
    {
      directCStringBuffer = buffer->directCStringBuffer;
      if (directCStringBuffer)
      {
        return (unsigned __int16)directCStringBuffer[buffer->rangeToBuffer.location + a3];
      }
      else
      {
        if (buffer->bufferedRangeEnd <= a3
          || (CFIndex bufferedRangeStart = buffer->bufferedRangeStart, bufferedRangeStart > a3))
        {
          CFIndex v17 = a3 - 4;
          if ((unint64_t)a3 < 4) {
            CFIndex v17 = 0;
          }
          if (v17 + 64 < v11) {
            CFIndex v11 = v17 + 64;
          }
          buffer->CFIndex bufferedRangeStart = v17;
          buffer->bufferedRangeEndouble d = v11;
          v18.CFIndex location = buffer->rangeToBuffer.location + v17;
          v18.CFIndex length = v11 - v17;
          CFStringGetCharacters(buffer->theString, v18, buffer->buffer);
          CFIndex bufferedRangeStart = buffer->bufferedRangeStart;
        }
        return buffer->buffer[a3 - bufferedRangeStart];
      }
    }
  }
}

void TLine::DrawBackground(TLine *this, CGContext *a2)
{
  if (atomic_load_explicit((atomic_ullong *volatile)this + 21, memory_order_acquire))
  {
    uint64_t v3 = *((void *)this + 2);
    if (*((void *)this + 3) != v3)
    {
      uint64_t v5 = *(void *)(*(void *)v3 + 40);
      if (TAttributes::SetContextAttributesForBackground((TAttributes *)(v5 + 40), a2))
      {
        CGPoint TextPosition = CGContextGetTextPosition(a2);
        double x = TextPosition.x;
        double v8 = *((double *)this + 15);
        TFont::GetWindowsDescent(*(void *)(atomic_load_explicit((atomic_ullong *volatile)(v5 + 56), memory_order_acquire)+ 40));
        if (v8 >= v9) {
          double v9 = v8;
        }
        double v10 = TextPosition.y - v9;
        double v11 = *((double *)this + 13);
        double v12 = *((double *)this + 14) + v9;
        if ((*(unsigned char *)(v5 + 177) & 8) != 0)
        {
          TLine::GetTrailingWhitespace((uint64_t)this, v14);
          double v13 = v15;
          double v11 = v11 - v15;
          if ((*((_WORD *)this + 76) & 8) == 0) {
            double v13 = -0.0;
          }
          double x = TextPosition.x + v13;
        }
        v17.origin.double x = x;
        v17.origin.double y = v10;
        v17.size.double width = v11;
        v17.size.CGFloat height = v12;
        CGContextFillRect(a2, v17);
        CGContextRestoreGState(a2);
      }
    }
  }
}

double TAATTrakTable::UnscaledTrackAmountForSize(TAATTrakTable *this, const __CFData *a2, double a3, double a4)
{
  double v4 = 0.0;
  if (!this) {
    return v4;
  }
  int v6 = (int)a2;
  BytePtr = CFDataGetBytePtr(this);
  if (!BytePtr) {
    return v4;
  }
  double v10 = BytePtr;
  double v11 = CFDataGetBytePtr(this);
  if (!v11) {
    return v4;
  }
  unint64_t v12 = (unint64_t)&v11[CFDataGetLength(this)];
  if ((unint64_t)(v10 + 10) > v12 || *(_WORD *)v10 != 256) {
    return v4;
  }
  uint64_t v13 = 6;
  if (v6) {
    uint64_t v13 = 8;
  }
  unsigned int v14 = *(unsigned __int16 *)&v10[v13];
  if (!v14) {
    return v4;
  }
  double v15 = &v10[__rev16(v14)];
  CGFloat v16 = (unsigned int *)(v15 + 16);
  if ((unint64_t)(v15 + 16) > v12) {
    return v4;
  }
  CGRect v17 = (unsigned int *)(v15 + 8);
  if (!*(_WORD *)v15) {
    return v4;
  }
  uint64_t v18 = __rev16(*(unsigned __int16 *)v15);
  int32_t v19 = &v17[2 * v18];
  BOOL v20 = v19 < v17 || (unint64_t)v19 > v12;
  if (v20 && v18 != (v12 - (unint64_t)v17) >> 3) {
    return v4;
  }
  unsigned int v21 = *((unsigned __int16 *)v15 + 1);
  if (!*((_WORD *)v15 + 1)) {
    return v4;
  }
  int v22 = (unsigned int *)&v10[bswap32(*((_DWORD *)v15 + 1))];
  uint64_t v23 = __rev16(v21);
  long long v24 = &v22[v23];
  if ((v24 < v22 || (unint64_t)v24 > v12)
    && ((unint64_t)(v22 + 1) > v12 || (v12 - (unint64_t)v22) >> 2 != v23))
  {
    return v4;
  }
  unsigned int v27 = vcvtd_n_s64_f64(a3, 0x10uLL);
  if (a3 * 65536.0 < 2147483650.0) {
    signed int v28 = v27;
  }
  else {
    signed int v28 = 0x7FFFFFFF;
  }
  if (a3 * 65536.0 <= -2147483650.0) {
    signed int v28 = 0x80000000;
  }
  if (v23 < 2 || (int)bswap32(*v22) > v28)
  {
    unsigned __int16 v29 = 0;
    unsigned __int16 v30 = 0;
    goto LABEL_36;
  }
  if ((int)bswap32(v22[v23 - 1]) <= v28)
  {
    unsigned __int16 v29 = v23 - 1;
  }
  else
  {
    if (v21 == 256)
    {
      unsigned __int16 v29 = 0;
      unsigned __int16 v30 = 1;
      goto LABEL_36;
    }
    unsigned __int16 v29 = 0;
    uint64_t v61 = v22 + 1;
    unsigned int v62 = (4 * v23 + 262136) >> 2;
    unsigned __int16 v63 = v62 + 1;
    unsigned __int16 v64 = v62 + 2;
    uint64_t v65 = 4 * v23 - 4;
    unsigned __int16 v30 = 1;
    while (1)
    {
      signed int v66 = bswap32(*(v61 - 1));
      if (v66 == v28) {
        break;
      }
      signed int v67 = bswap32(*v61);
      if (v66 < v28 && v67 > v28) {
        goto LABEL_36;
      }
      ++v29;
      ++v30;
      ++v61;
      v65 -= 4;
      if (!v65)
      {
        unsigned __int16 v29 = v63;
        unsigned __int16 v30 = v64;
        goto LABEL_36;
      }
    }
  }
  unsigned __int16 v30 = v29;
LABEL_36:
  unsigned int v31 = vcvtd_n_s64_f64(a4, 0x10uLL);
  if (a4 * 65536.0 < 2147483650.0) {
    int v32 = v31;
  }
  else {
    int v32 = 0x7FFFFFFF;
  }
  if (a4 * 65536.0 <= -2147483650.0) {
    signed int v33 = 0x80000000;
  }
  else {
    signed int v33 = v32;
  }
  if (v18 >= 2 && (int)bswap32(*v17) <= v33)
  {
    uint64_t v53 = &v17[2 * v18];
    if ((int)bswap32(*(v53 - 2)) <= v33)
    {
      unsigned __int16 v34 = v18 - 1;
    }
    else
    {
      if (v16 == v53)
      {
        unsigned __int16 v34 = 0;
        unsigned __int16 v35 = 1;
        goto LABEL_45;
      }
      unsigned __int16 v34 = 0;
      unsigned int v54 = (8 * v18 + 524272) >> 3;
      unsigned __int16 v55 = v54 + 1;
      unsigned __int16 v56 = v54 + 2;
      uint64_t v57 = 8 * v18 - 8;
      unsigned __int16 v35 = 1;
      while (1)
      {
        signed int v58 = bswap32(*(v16 - 2));
        if (v58 == v33) {
          break;
        }
        signed int v59 = bswap32(*v16);
        if (v58 < v33 && v59 > v33) {
          goto LABEL_45;
        }
        ++v34;
        ++v35;
        v16 += 2;
        v57 -= 8;
        if (!v57)
        {
          unsigned __int16 v34 = v55;
          unsigned __int16 v35 = v56;
          goto LABEL_45;
        }
      }
    }
    unsigned __int16 v35 = v34;
  }
  else
  {
    unsigned __int16 v34 = 0;
    unsigned __int16 v35 = 0;
  }
LABEL_45:
  unint64_t v36 = *(void *)&v17[2 * v34];
  unint64_t v37 = *(void *)&v17[2 * v35];
  double v38 = 0.0;
  if (v29 != v30)
  {
    float v39 = (float)(int)bswap32(v22[v29]) * 0.000015259;
    float v40 = (float)(int)bswap32(v22[v30]) * 0.000015259;
    if (v39 != v40) {
      double v38 = (a3 - v39) / (v40 - v39);
    }
  }
  CGRect v41 = &v10[__rev16(HIWORD(v36))];
  unint64_t v42 = (unint64_t)&v41[2 * v23];
  BOOL v43 = v42 < (unint64_t)v41 || v42 > v12;
  if (!v43 || ((unint64_t)(v41 + 2) <= v12 ? (BOOL v44 = (v12 - (unint64_t)v41) >> 1 == v23) : (BOOL v44 = 0), v44))
  {
    double v4 = (double)((int)bswap32(*(unsigned __int16 *)&v41[2 * v29]) >> 16);
    if (v29 != v30) {
      double v4 = std::__lerp[abi:nn180100]<double>(v4, (double)((int)bswap32(*(unsigned __int16 *)&v41[2 * v30]) >> 16), v38);
    }
  }
  else
  {
    double v4 = 0.0;
  }
  if (v36 == v37) {
    return v4;
  }
  float v46 = (float)(int)bswap32(v36) * 0.000015259;
  float v47 = (float)(int)bswap32(v37) * 0.000015259;
  double v48 = 0.0;
  if (v46 != v47) {
    double v48 = (a4 - v46) / (v47 - v46);
  }
  unint64_t v49 = &v10[__rev16(HIWORD(v37))];
  unint64_t v50 = (unint64_t)&v49[2 * v23];
  BOOL v51 = v50 < (unint64_t)v49 || v50 > v12;
  if (!v51 || (double v52 = 0.0, (unint64_t)(v49 + 2) <= v12) && (v12 - (unint64_t)v49) >> 1 == v23)
  {
    double v52 = (double)((int)bswap32(*(unsigned __int16 *)&v49[2 * v29]) >> 16);
    if (v29 != v30) {
      double v52 = std::__lerp[abi:nn180100]<double>(v52, (double)((int)bswap32(*(unsigned __int16 *)&v49[2 * v30]) >> 16), v38);
    }
  }

  return std::__lerp[abi:nn180100]<double>(v4, v52, v48);
}

uint64_t ScriptCodeForLongCharacter(unsigned int a1)
{
  uint64_t Script = uscript_getScript();
  uint64_t result = 54;
  if ((int)Script > 21)
  {
    if ((Script - 102) < 2) {
      return 0;
    }
    if (Script == 22) {
      return result;
    }
    return Script;
  }
  if (Script >= 2)
  {
    if (Script == 20) {
      return result;
    }
    return Script;
  }
  if (a1 < 0x1D000) {
    return 0;
  }
  if (a1 < 0x1D100) {
    return 201;
  }
  if (a1 >= 0x1D200) {
    return 0;
  }
  return 202;
}

void TDelegateRun::DrawGlyphs(TRun *this, CGContextRef c, CFRange a3)
{
  if (*((double *)this + 49) != 0.0) {
    TRun::DrawGlyphs(this, c, a3);
  }
}

uint64_t std::function<void ()(double,double)>::operator()(uint64_t a1, double a2, double a3)
{
  double v5 = a3;
  double v6 = a2;
  if (a1) {
    return (*(uint64_t (**)(uint64_t, double *, double *))(*(void *)a1 + 48))(a1, &v6, &v5);
  }
  uint64_t v4 = std::__throw_bad_function_call[abi:nn180100]();
}

double std::__function::__func<void TDecorationRun::DrawLine<anonymous namespace'::TRunAdapter>(CGContext *,CGPoint,anonymous namespace'::TRunAdapter,anonymous namespace'::TRunAdapter,CGPoint,CGPoint,double const*,unsigned long)::{lambda(double,double)#1},std::allocator<void TDecorationRun::DrawLine<anonymous namespace'::TRunAdapter>(CGContext *,CGPoint,anonymous namespace'::TRunAdapter,anonymous namespace'::TRunAdapter,CGPoint,CGPoint,double const*,unsigned long)::{lambda(double,double)#1}>,void ()(double,double)>::operator()(uint64_t a1, double *a2, double *a3)
{
  double v3 = *a3;
  double v4 = **(double **)(a1 + 8);
  double v5 = *a2 - v4;
  uint64_t v6 = *(void *)(a1 + 24);
  uint64_t v7 = *(double **)(a1 + 32);
  double v8 = *v7;
  if (v5 - *v7 > **(double **)v6)
  {
    double v10 = v7[1];
    double v11 = *(double **)(v6 + 8);
    double v12 = v11[1];
    v14.double x = v8 + *v11;
    v14.double y = v10 + v12;
    v15.double x = v5 + *v11;
    v15.double y = *(double *)(*(void *)(a1 + 16) + 8) + v12;
    TDecorationRun::DrawLineSegment(**(TDecorationRun ***)(v6 + 24), **(const CGFloat ***)(v6 + 32), v14, v15, **(const double ***)(v6 + 40));
    double v4 = **(double **)(a1 + 8);
    uint64_t v7 = *(double **)(a1 + 32);
  }
  double result = v3 + v4;
  *uint64_t v7 = result;
  return result;
}

uint64_t std::__function::__func<TDecorationRun::CalculateGlyphIntersections(CGAffineTransform,TRun const&,double,double,std::function<void ()(double,double)> const&)::$_1,std::allocator<TDecorationRun::CalculateGlyphIntersections(CGAffineTransform,TRun const&,double,double,std::function<void ()(double,double)> const&)::$_1>,void ()(double,double)>::operator()(uint64_t a1, double *a2, double *a3)
{
  double v3 = *(double **)(a1 + 8);
  return std::function<void ()(double,double)>::operator()(*(void *)(*(void *)(a1 + 16) + 24), v3[4] + v3[2] * 0.0 + *v3 * *a2, v3[4] + v3[2] * 0.0 + *v3 * *a3);
}

uint64_t TBaseFont::IsSystemUI(TBaseFont *this)
{
  return 0;
}

uint64_t TSplicedFont::HasTable(TSplicedFont *this)
{
  uint64_t v1 = *(void *)(*((void *)this + 76) + 40);
  if ((*(_DWORD *)(v1 + 16) & 0x80000000) == 0) {
    TDescriptor::InitBaseFont(*(TDescriptor **)(*((void *)this + 76) + 40), 0, 0.0);
  }
  char v2 = *(uint64_t (**)(void))(*(void *)atomic_load_explicit((atomic_ullong *volatile)(v1 + 32), memory_order_acquire)
                           + 472);

  return v2();
}

void DrawGlyphsWithAdvancesAndTransform(TBaseFont **a1, const CGGlyph *a2, uint64_t a3, unint64_t a4, CGContext *a5, float64x2_t *a6, double *a7, uint64_t a8)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a8 + 104) && a6[1].f64[1] < 0.0) {
    a7[3] = -a7[3];
  }
  *(void *)&long long v16 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v32[28] = v16;
  v32[29] = v16;
  v32[26] = v16;
  v32[27] = v16;
  v32[24] = v16;
  v32[25] = v16;
  v32[22] = v16;
  v32[23] = v16;
  v32[20] = v16;
  v32[21] = v16;
  v32[18] = v16;
  v32[19] = v16;
  v32[16] = v16;
  v32[17] = v16;
  v32[15] = v16;
  v32[14] = v16;
  v32[13] = v16;
  v32[12] = v16;
  v32[11] = v16;
  v32[10] = v16;
  v32[9] = v16;
  v32[8] = v16;
  v32[7] = v16;
  v32[6] = v16;
  v32[4] = v16;
  v32[5] = v16;
  void v32[2] = v16;
  v32[3] = v16;
  v32[0] = v16;
  v32[1] = v16;
  unsigned __int16 v29 = 0;
  unsigned __int16 v30 = 0;
  uint64_t v31 = 0;
  signed int v33 = v32;
  std::vector<CGPoint,TInlineBufferAllocator<CGPoint,30ul>>::__vallocate[abi:nn180100]((char **)&v29, a4);
  CGRect v17 = (char *)v30;
  bzero(v30, 16 * a4);
  uint64_t v18 = 0;
  unsigned __int16 v30 = &v17[16 * a4];
  int32_t v19 = v29;
  BOOL v20 = (double *)(a3 + 8);
  double v22 = v24;
  double v21 = v26;
  do
  {
    v19[v18] = (const CGPoint)vaddq_f64(a6[2], vmlaq_n_f64(vmulq_n_f64(a6[1], v21), *a6, v22));
    double v23 = *(v20 - 1);
    double v22 = v22 + *v20 * a7[2] + *a7 * v23;
    double v21 = v21 + *v20 * a7[3] + a7[1] * v23;
    ++v18;
    v20 += 2;
  }
  while (a4 != v18);
  CGFloat v25 = v22;
  CGFloat v27 = v21;
  DrawGlyphsAtPositions(a1, a2, v19, a4, a5, a8);
  CGContextSetTextPosition(a5, v25, v27);
  signed int v28 = (char **)&v29;
  std::vector<CGPoint,TInlineBufferAllocator<CGPoint,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v28);
}

void TDecorationRun::DrawDecorationRun<anonymous namespace'::TRunAdapter>(CGContext *,anonymous namespace'::TRunAdapter,anonymous namespace'::TRunAdapter,double)::{lambda(CGPoint,CGPoint)#1}::operator()(uint64_t a1, double a2, double a3, double a4, double a5)
{
  double v6 = a4;
  v55[4] = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *(void *)(a1 + 56);
  if (!**(unsigned char **)a1)
  {
    double v9 = *(double **)(a1 + 8);
    double v10 = v9[1];
    double v11 = v9[2];
    double v12 = v9[3];
    double v13 = v9[4];
    double v14 = v9[5];
    double v15 = v13 + a3 * v11 + *v9 * a2;
    a3 = v14 + a3 * v12 + v10 * a2;
    double v6 = v13 + a5 * v11 + *v9 * a4;
    a5 = v14 + a5 * v12 + v10 * a4;
    a2 = v15;
  }
  long long v16 = *(double **)(a1 + 24);
  CGRect v17 = **(CGContext ***)(a1 + 16);
  double v18 = *v16;
  double v19 = v16[1];
  BOOL v20 = **(uint64_t ***)(a1 + 32);
  double v21 = **(uint64_t ***)(a1 + 40);
  uint64_t v22 = *(void *)(a1 + 48);
  double v23 = *(const CGFloat **)v22;
  uint64_t v24 = (uint64_t)(*(void *)(v22 + 8) - *(void *)v22) >> 3;
  *(double *)unsigned int v54 = *v16;
  *(double *)&v54[1] = v19;
  *(double *)&long long v53 = a2;
  *((double *)&v53 + 1) = a3;
  BOOL v51 = v23;
  double v52 = v17;
  uint64_t v50 = v24;
  double v25 = *(double *)(v8 + 32) * 0.75;
  uint64_t v48 = *(void *)(v8 + 32);
  double v49 = v25;
  if (*(unsigned char *)(v8 + 16))
  {
    a5 = a5 - a3 * 2.0;
    a3 = a3 - a3 * 2.0;
    *((double *)&v53 + 1) = a3;
  }
  unint64_t v42 = &v49;
  BOOL v43 = (double *)v54;
  uint64_t v44 = v8;
  uint64_t v45 = &v52;
  float v46 = &v51;
  float v47 = &v50;
  if (*(_DWORD *)v8)
  {
    if (v6 - a2 <= v25) {
      return;
    }
    double v26 = a2 + v18;
    double v27 = v19 + a3;
    double v28 = v6 + v18;
    double v29 = v19 + a5;
    goto LABEL_14;
  }
  *(void *)&long long v30 = -1;
  *((void *)&v30 + 1) = -1;
  *(_OWORD *)&v41.c = v30;
  *(_OWORD *)&v41.tdouble x = v30;
  *(_OWORD *)&v41.CGFloat a = v30;
  CGContextGetTextMatrix(&v41, v17);
  long long v40 = v53;
  if (v20 == v21)
  {
    unint64_t v37 = &v49;
  }
  else
  {
    do
    {
      uint64_t v31 = *v20++;
      int v32 = *(__n128 **)(v31 + 40);
      CGAffineTransform v39 = v41;
      double v33 = *(double *)(v8 + 32) * 0.5;
      CGFloat v34 = *((double *)&v53 + 1) - v33;
      double v35 = *((double *)&v53 + 1) + v33;
      unint64_t v36 = operator new(0x28uLL);
      void *v36 = &unk_1ED0614C0;
      v36[1] = &v48;
      v36[2] = &v53;
      v36[3] = &v42;
      v36[4] = &v40;
      v55[3] = v36;
      TDecorationRun::CalculateGlyphIntersections(v8, &v39.a, v32, (uint64_t)v55, v34, v35);
      std::__function::__value_func<void ()(double,double)>::~__value_func[abi:nn180100](v55);
    }
    while (v20 != v21);
    unint64_t v37 = v42;
  }
  if (v6 - *(double *)&v40 > *v37)
  {
    double v38 = v43[1];
    double v26 = *(double *)&v40 + *v43;
    double v27 = *((double *)&v40 + 1) + v38;
    double v28 = v6 + *v43;
    double v29 = a5 + v38;
    CGRect v17 = *v45;
    double v23 = *v46;
    uint64_t v24 = *v47;
LABEL_14:
    TDecorationRun::DrawLineSegment(v17, v23, *(CGPoint *)&v26, *(CGPoint *)&v28, (const double *)v24);
  }
}

void *std::__function::__value_func<void ()(double,double)>::~__value_func[abi:nn180100](void *a1)
{
  char v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void TDecorationRun::DrawLineSegment(TDecorationRun *this, const CGFloat *a2, CGPoint a3, CGPoint a4, const double *a5)
{
  CGFloat y = a4.y;
  CGFloat x = a4.x;
  CGFloat v7 = a3.y;
  CGFloat v8 = a3.x;
  CGContextSetLineDash(this, a3.x, a2, (size_t)a5);
  CGContextMoveToPoint(this, v8, v7);
  CGContextAddLineToPoint(this, x, y);

  CGContextStrokePath(this);
}

uint64_t TFont::GetWindowsDescent(uint64_t this)
{
  *(double *)&unint64_t v3 = NAN;
  unint64_t v3 = *(unint64_t *)(this + 152);
  if (*(double *)&v3 == 0.0)
  {
    uint64_t v1 = this;
    this = TFont::GetWinMetrics((TBaseFont **)this, 0, (double *)&v3);
    if (this)
    {
      unint64_t v2 = v3;
    }
    else
    {
      if (*(_DWORD *)(v1 + 48)) {
        this = v1 + 48;
      }
      else {
        this = (uint64_t)TFont::InitStrikeMetrics((TFont *)v1);
      }
      unint64_t v3 = *(unint64_t *)(this + 16);
      unint64_t v2 = v3;
    }
    atomic_store(v2, (unint64_t *)(v1 + 152));
  }
  return this;
}

uint64_t TFont::GetWinMetrics(TBaseFont **this, double *a2, double *a3)
{
  uint64_t result = TBaseFont::GetInitializedGraphicsFont(this[50]);
  if (result)
  {
    uint64_t result = CGFontGetParserFont();
    if (result)
    {
      uint64_t result = FPFontGetWinMetrics();
      if (result)
      {
        if (*((_DWORD *)this + 12)) {
          initedouble d = (int *)(this + 6);
        }
        else {
          initedouble d = TFont::InitStrikeMetrics((TFont *)this);
        }
        double v8 = *((double *)inited + 6);
        if (a2) {
          *a2 = v8 * *a2;
        }
        if (a3) {
          *a3 = v8 * *a3;
        }
        return 1;
      }
    }
  }
  return result;
}

void SetNSShadow(CGContext *a1, id a2)
{
  objc_msgSend(a2, sel_shadowOffset);
  uint64_t v5 = v4;
  uint64_t v7 = v6;
  objc_msgSend(a2, sel_shadowBlurRadius);
  CGFloat v9 = v8;
  double v10 = (CGColor *)objc_msgSend(objc_msgSend(a2, sel_shadowColor), sel_CGColor);
  uint64_t v11 = v5;
  uint64_t v12 = v7;

  CGContextSetShadowWithColor(a1, *(CGSize *)&v11, v9, v10);
}

void anonymous namespace'::TCGImageData::DrawAtPoint(_anonymous_namespace_::TCGImageData *this, CGContextRef c, CGPoint a3)
{
  double y = a3.y;
  double x = a3.x;
  double v7 = *((double *)this + 5);
  double v8 = *((double *)this + 6);
  CGPoint TextPosition = CGContextGetTextPosition(c);
  *(void *)&long long v10 = -1;
  *((void *)&v10 + 1) = -1;
  *(_OWORD *)&v19.c = v10;
  *(_OWORD *)&v19.tdouble x = v10;
  *(_OWORD *)&v19.CGFloat a = v10;
  CGContextGetUserSpaceToDeviceSpaceTransform(&v19, c);
  long long v11 = *(_OWORD *)&v19.a;
  long long v12 = *(_OWORD *)&v19.c;
  double v13 = *(double *)this;
  double v14 = *((double *)this + 1);
  double v15 = *((double *)this + 3);
  double v16 = *((double *)this + 4);
  if (atomic_load_explicit((atomic_ullong *volatile)this + 2, memory_order_acquire))
  {
    double v17 = *((double *)&v11 + 1) + *((double *)&v12 + 1);
    double v18 = 1.0;
    if (*((double *)&v11 + 1) * *(double *)&v12 == 0.0) {
      double v18 = *(double *)&v12 + *(double *)&v11;
    }
    else {
      double v17 = 1.0;
    }
    v20.origin.double y = round(v17 * (v16 + y + TextPosition.y + v14)) / v17 - TextPosition.y;
    v20.origin.double x = round(v18 * (v15 + x + TextPosition.x + v13)) / v18 - TextPosition.x;
    v20.size.CGFloat height = round(v8 * v17) / v17;
    v20.size.double width = round(v7 * v18) / v18;
    CGContextDrawImage(c, v20, (CGImageRef)atomic_load_explicit((atomic_ullong *volatile)this + 2, memory_order_acquire));
  }
}

void DrawInvisibleGlyph(CGContext *a1, CGGlyph a2, CGPoint a3, const CGAffineTransform *a4, const CGAffineTransform *a5)
{
  CGFloat y = a3.y;
  CGFloat x = a3.x;
  CGContextGetAlpha();
  CGFloat v12 = v11;
  CGContextSetAlpha(a1, 0.0);
  v14.CGFloat x = x;
  v14.CGFloat y = y;
  DrawVisibleGlyph(a1, a2, v14, a4, a5);

  CGContextSetAlpha(a1, v12);
}

void DrawVisibleGlyph(CGContextRef c, CGGlyph a2, CGPoint a3, const CGAffineTransform *a4, const CGAffineTransform *a5)
{
  CGPoint Lpositions = a3;
  CGGlyph glyphs = a2;
  int64x2_t v6 = (int64x2_t)vandq_s8((int8x16_t)vceqq_f64(*(float64x2_t *)&a4->a, (float64x2_t)xmmword_184B895C0), vandq_s8((int8x16_t)vceqq_f64(*(float64x2_t *)&a4->c, (float64x2_t)xmmword_184B87DE0), (int8x16_t)vceqzq_f64(*(float64x2_t *)&a4->tx)));
  if ((vandq_s8((int8x16_t)v6, (int8x16_t)vdupq_laneq_s64(v6, 1)).u64[0] & 0x8000000000000000) != 0)
  {
    CGContextShowGlyphsAtPositions(c, &glyphs, &Lpositions, 1uLL);
  }
  else
  {
    *(void *)&long long v9 = -1;
    *((void *)&v9 + 1) = -1;
    *(_OWORD *)&v16.c = v9;
    *(_OWORD *)&v16.tCGFloat x = v9;
    *(_OWORD *)&v16.CGFloat a = v9;
    CGContextGetTextMatrix(&v16, c);
    CGPoint v10 = (CGPoint)vaddq_f64(*(float64x2_t *)&a5->tx, vmlaq_n_f64(vmulq_n_f64(*(float64x2_t *)&a5->c, Lpositions.y), *(float64x2_t *)&a5->a, Lpositions.x));
    *(void *)&long long v11 = -1;
    *((void *)&v11 + 1) = -1;
    *(_OWORD *)&v15.c = v11;
    *(_OWORD *)&v15.tCGFloat x = v11;
    *(_OWORD *)&v15.CGFloat a = v11;
    long long v12 = *(_OWORD *)&a4->c;
    *(_OWORD *)&t1.CGFloat a = *(_OWORD *)&a4->a;
    *(_OWORD *)&t1.c = v12;
    *(_OWORD *)&t1.tCGFloat x = *(_OWORD *)&a4->tx;
    CGPoint Lpositions = v10;
    CGAffineTransform t2 = v16;
    CGAffineTransformConcat(&v15, &t1, &t2);
    CGAffineTransform v14 = v15;
    CGContextSetTextMatrix(c, &v14);
    CGContextShowGlyphsAtPositions(c, &glyphs, &Lpositions, 1uLL);
    CGAffineTransform v13 = v16;
    CGContextSetTextMatrix(c, &v13);
  }
}

CFIndex CTTypesetterSuggestLineBreak(CTTypesetterRef typesetter, CFIndex startIndex, double width)
{
  return TypesetterSuggestLineBreak(typesetter, startIndex, width, 0.0);
}

void TLine::ResetLine(TLine *this, const TCharStream *a2)
{
  uint64_t v4 = *((void *)this + 3) - *((void *)this + 2);
  if (v4 >= 1)
  {
    uint64_t v5 = 0;
    uint64_t v6 = (unint64_t)v4 >> 3;
    if (v6 <= 1) {
      uint64_t v7 = 1;
    }
    else {
      uint64_t v7 = v6;
    }
    do
    {
      uint64_t v8 = *(void *)(*(void *)(*((void *)this + 2) + 8 * v5) + 48);
      if ((*(_WORD *)(v8 + 178) & 0x40) == 0)
      {
        uint64_t v9 = *(void *)(atomic_load_explicit((atomic_ullong *volatile)(v8 + 56), memory_order_acquire) + 40);
        uint64_t RenderingStyle = TAttributes::GetRenderingStyle((TAttributes *)(v8 + 40));
        TStorageRange::ResetAdvances(v8 + 192, v9, RenderingStyle);
        uint64_t v11 = *(void *)(v8 + 312);
        if (v11)
        {
          uint64_t v12 = *(void *)(v11 + 56);
          if (v12 != *(void *)(v11 + 64)) {
            *(void *)(v11 + 64) = v12;
          }
        }
      }
      ++v5;
    }
    while (v7 != v5);
  }
  TKerningEngine::PositionGlyphs(this, a2, (const TCharStream *)4);

  TLine::SyncWithRuns(this);
}

void TStorageRange::ResetAdvances(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 16);
  if ((*(unsigned char *)(a1 + 33) & 4) != 0)
  {
    if (v4 < 1) {
      return;
    }
    for (uint64_t i = 0; i != v4; ++i)
    {
      [*(id *)(a1 + 24) customAdvanceForIndex:i + *(void *)(a1 + 8)];
      v17.CGFloat height = 0.0;
      TStorageRange::SetAdvance((TStorageRange *)a1, i, v17);
    }
  }
  else
  {
    uint64_t v6 = *(void *)(a1 + 8);
    uint64_t v7 = *(void **)(a1 + 24);
    uint64_t v8 = v7[3];
    if (v8)
    {
      uint64_t v9 = (double *)(v8 + 8 * v6);
      uint64_t v10 = a2;
      uint64_t v11 = v7[2] + 2 * v6;
      int v12 = 1;
    }
    else
    {
      uint64_t v9 = (double *)(v7[4] + 16 * v6);
      uint64_t v10 = a2;
      uint64_t v11 = v7[2] + 2 * v6;
      int v12 = 2;
    }
    TFont::GetAdvancesForGlyphs(v10, v11, v9, v12, v4, 0, a3, 0);
    *(void *)a1 = v14;
  }
  if ((*(unsigned char *)(a1 + 33) & 0x10) != 0 && v4 >= 1)
  {
    uint64_t v15 = 0;
    CGAffineTransform v16 = (double *)MEMORY[0x1E4F1DAD8];
    do
      objc_msgSend(*(id *)(a1 + 24), "setOrigin:atIndex:", v15++, *v16, v16[1]);
    while (v4 != v15);
  }
}

CFIndex TypesetterSuggestLineBreak(const __CTTypesetter *a1, uint64_t a2, double a3, double a4)
{
  void v7[4] = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  uint64_t v4 = *((void *)a1 + 5);
  void v7[3] = 0;
  CFIndex v5 = TTypesetter::SuggestLineBreak(v4, a2, (uint64_t)v7, a3, a4);
  std::__function::__value_func<unsigned char ()(long)>::~__value_func[abi:nn180100](v7);
  return v5;
}

CFIndex TTypesetter::SuggestLineBreak(uint64_t a1, uint64_t a2, uint64_t a3, double a4, double a5)
{
  v18[4] = *MEMORY[0x1E4F143B8];
  uint64_t v10 = a1;
  long long v11 = *(_OWORD *)(a1 + 216);
  uint64_t v12 = *(void *)(a1 + 232);
  uint64_t v13 = a1 + 240;
  int v14 = *(_DWORD *)(a1 + 260);
  char v15 = *(unsigned char *)(a1 + 264);
  char v16 = *(unsigned char *)(a1 + 257);
  uint64_t v17 = 0;
  std::__function::__value_func<unsigned char ()(long)>::__value_func[abi:nn180100]((uint64_t)v18, a3);
  CFIndex v8 = TTypesetter::SuggestLineBreak(&v10, a2, (uint64_t)v18, a4, a5);
  std::__function::__value_func<unsigned char ()(long)>::~__value_func[abi:nn180100](v18);
  return v8;
}

CFIndex TTypesetter::SuggestLineBreak(uint64_t *a1, uint64_t a2, uint64_t a3, double a4, double a5)
{
  v15[4] = *MEMORY[0x1E4F143B8];
  std::__function::__value_func<unsigned char ()(long)>::__value_func[abi:nn180100]((uint64_t)v15, a3);
  TTypesetter::FindGraphicalBreak(a1, a2, (uint64_t)v15, (uint64_t)v13, a4, a5);
  unsigned int v10 = v13[0];
  CFIndex Chars = v14;
  std::__function::__value_func<unsigned char ()(long)>::~__value_func[abi:nn180100](v15);
  if ((v10 & 1) == 0)
  {
    if (!Chars)
    {
      CFIndex Chars = TTypesetter::DecomposeLastChars((const TLine **)a1, a2, 0, a4);
      if (!Chars) {
        CFIndex Chars = *(void *)(a3 + 24) == 0;
      }
    }
    return TTypesetter::FindLineBreak((TLine **)a1, a2, Chars, v10);
  }
  return Chars;
}

void TRun::TruncateUnorderedEnd(TRun *this, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10 = a2;
  if (a4)
  {
    uint64_t v12 = *((void *)this + 1);
    do
    {
      uint64_t v13 = a3;
      uint64_t v14 = a3 + v10;
      if (a3 + v10 <= v12) {
        break;
      }
      uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a5 + 40))(a5, v14 - 1, a6);
      uint64_t v12 = *((void *)this + 1);
      if (v15 < v12)
      {
        *((void *)this + 2) = 0;
        goto LABEL_30;
      }
      a3 = v15 - v10;
    }
    while (v15 + v16 > v14);
  }
  else
  {
    GlyphIndexForuint64_t Char = TRun::GetGlyphIndexForCharIndex<false>((uint64_t)this, a2);
    if (v10 >= *((void *)this + 2) + *((void *)this + 1))
    {
LABEL_14:
      Nextuint64_t Char = v10;
    }
    else
    {
      while (1)
      {
        uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a5 + 40))(a5, v10, a6);
        uint64_t v19 = v17 + v18;
        Nextuint64_t Char = *((void *)this + 2) + *((void *)this + 1);
        if (v17 + v18 > NextChar) {
          break;
        }
        if (v17 >= v10) {
          goto LABEL_14;
        }
        uint64_t v21 = v19 - 1;
        if (v19 - 1 != v10) {
          GlyphIndexForuint64_t Char = TRun::GetGlyphIndexForCharIndex<false>((uint64_t)this, v19 - 1);
        }
        Nextuint64_t Char = TRun::GetNextChar(this, v21, &GlyphIndexForChar);
        a3 = v10 + a3 - NextChar;
        uint64_t v10 = NextChar;
        if (NextChar >= *((void *)this + 2) + *((void *)this + 1)) {
          goto LABEL_17;
        }
      }
      a3 = 0;
    }
LABEL_17:
    uint64_t v10 = NextChar;
    uint64_t v13 = a3;
  }
  *((void *)this + 1) = v10;
  *((void *)this + 2) = v13;
  if (v13)
  {
    CFIndex location = *((void *)this + 26);
    double v23 = (uint64_t *)(*(void *)(*((void *)this + 27) + 48) + 8 * *((void *)this + 25));
    char v24 = *((unsigned char *)this + 224);
    if (!a4) {
      char v24 = (v24 & 1) == 0;
    }
    if (v24)
    {
      CFIndex v25 = location - 1;
      CFIndex v26 = (location - 1) & ((location - 1) >> 63);
      double v27 = v23 - 2;
      while (1)
      {
        v28.CFIndex location = location - 1;
        if (location - 1 < 1) {
          break;
        }
        uint64_t v29 = v27[location];
        BOOL v30 = v10 > v29 || v13 + v10 <= v29;
        CFIndex location = v28.location;
        if (v30) {
          goto LABEL_39;
        }
      }
      v28.CFIndex location = v26;
LABEL_39:
      uint64_t v31 = v25 - v28.location;
    }
    else
    {
      uint64_t v31 = location - 1;
      if (location < 1 || ((uint64_t v32 = v13 + v10, v10 <= *v23) ? (v33 = v32 <= *v23) : (v33 = 1), v33))
      {
        v28.CFIndex location = 0;
        uint64_t v31 = 0;
      }
      else
      {
        uint64_t v34 = 1;
        while (location != v34)
        {
          uint64_t v35 = v23[v34++];
          if (v10 > v35 || v32 <= v35)
          {
            v28.CFIndex location = 0;
            uint64_t v31 = v34 - 2;
            goto LABEL_40;
          }
        }
        v28.CFIndex location = 0;
      }
    }
LABEL_40:
    v28.CFIndex length = v31 + 1;
    TRun::TruncateStorageRange(this, v28);
  }
  else
  {
LABEL_30:
    v38.CFIndex location = 0;
    v38.CFIndex length = 0;
    TStorageRange::SetStorageSubRange((TRun *)((char *)this + 192), v38);
  }
}

CGFloat CTLineGetOffsetForStringIndex(CTLineRef line, CFIndex charIndex, CGFloat *secondaryOffset)
{
  if (!line) {
    return 0.0;
  }
  TLine::CharIndexToOffsets(*((void *)line + 5), charIndex);
  if (secondaryOffset) {
    *(void *)secondaryOffset = v5;
  }
  return result;
}

uint64_t TLine::CharIndexToOffsets(uint64_t this, uint64_t a2)
{
  void v48[4] = *MEMORY[0x1E4F143B8];
  if (!*(void *)this) {
    return this;
  }
  uint64_t v2 = this;
  uint64_t v3 = *(void *)(this + 72);
  uint64_t v4 = *(void *)(this + 80);
  uint64_t v5 = v3 <= a2 ? a2 : *(void *)(this + 72);
  uint64_t v6 = v4 + v3;
  uint64_t v7 = v5 >= v4 + v3 ? v4 + v3 : v5;
  uint64_t v8 = v7 - (v6 <= v5);
  if (v8 < 0) {
    return this;
  }
  uint64_t v9 = *(void *)(this + 24) - *(void *)(this + 16);
  this = TLine::FindRunWithCharIndex((TLine *)this, v8, 1);
  if (this >= v9 >> 3) {
    return this;
  }
  uint64_t v10 = this;
  uint64_t v11 = *(void *)(*(void *)(*(void *)(v2 + 16) + 8 * this) + 40);
  if (v6 <= v5)
  {
    int v12 = *(unsigned __int8 *)(v11 + 224) ^ ((*(_WORD *)(v2 + 152) & 8) >> 3);
LABEL_19:
    uint64_t v15 = *(void *)(*(void *)(*(void *)(v2 + 16) + 8 * this) + 40);
LABEL_20:
    uint64_t v16 = v10;
    goto LABEL_21;
  }
  uint64_t v13 = *(void *)(v2 + 72);
  if (v13 >= v7 || *(void *)(v2 + 80) + v13 < v7)
  {
    LOBYTE(v12) = 0;
    goto LABEL_19;
  }
  uint64_t RunWithCharIndex = TLine::FindRunWithCharIndex((TLine *)v2, v7 - 1, 1);
  uint64_t v15 = *(void *)(*(void *)(*(void *)(v2 + 16) + 8 * RunWithCharIndex) + 40);
  if (RunWithCharIndex == v10)
  {
    LOBYTE(v12) = 0;
    goto LABEL_20;
  }
  uint64_t v16 = RunWithCharIndex;
  BOOL v45 = (*(unsigned char *)(v11 + 224) & 1) == 0 || v10 + 1 != RunWithCharIndex;
  if (*(unsigned char *)(v15 + 224)) {
    LOBYTE(v12) = v45;
  }
  else {
    LOBYTE(v12) = *(unsigned char *)(v11 + 224) | (RunWithCharIndex + 1 != v10);
  }
LABEL_21:
  this = TLine::GetLeftHangersGlyphCountAndWidth((TLine *)v2, 0);
  uint64_t v47 = 0;
  if (v12)
  {
    if (*(unsigned char *)(v15 + 224))
    {
      if (v16 >= 1)
      {
        CFIndex v26 = *(uint64_t **)(v2 + 16);
        double v27 = 0.0;
        do
        {
          uint64_t v28 = *v26++;
          uint64_t v29 = *(void *)(v28 + 40);
          double v30 = *(double *)(v29 + 192);
          uint64_t v31 = *(double **)(v29 + 312);
          if (!v31) {
            uint64_t v31 = (double *)MEMORY[0x1E4F1DB30];
          }
          double v27 = v27 + v30 + *v31;
          --v16;
        }
        while (v16);
      }
    }
    else if ((v16 & 0x8000000000000000) == 0)
    {
      uint64_t v17 = *(uint64_t **)(v2 + 16);
      uint64_t v18 = v16 + 1;
      double v19 = 0.0;
      do
      {
        uint64_t v20 = *v17++;
        uint64_t v21 = *(void *)(v20 + 40);
        double v22 = *(double *)(v21 + 192);
        double v23 = *(double **)(v21 + 312);
        if (!v23) {
          double v23 = (double *)MEMORY[0x1E4F1DB30];
        }
        double v19 = v19 + v22 + *v23;
        --v18;
      }
      while (v18);
    }
    double v32 = 0.0;
    if (*(unsigned char *)(v11 + 224))
    {
      if ((v10 & 0x8000000000000000) == 0)
      {
        CFRange v38 = *(uint64_t **)(v2 + 16);
        uint64_t v39 = v10 + 1;
        do
        {
          uint64_t v40 = *v38++;
          uint64_t v41 = *(void *)(v40 + 40);
          double v42 = *(double *)(v41 + 192);
          BOOL v43 = *(double **)(v41 + 312);
          if (!v43) {
            BOOL v43 = (double *)MEMORY[0x1E4F1DB30];
          }
          double v32 = v32 + v42 + *v43;
          --v39;
        }
        while (v39);
      }
    }
    else if (v10 >= 1)
    {
      BOOL v33 = *(uint64_t **)(v2 + 16);
      do
      {
        uint64_t v34 = *v33++;
        uint64_t v35 = *(void *)(v34 + 40);
        double v36 = *(double *)(v35 + 192);
        unint64_t v37 = *(double **)(v35 + 312);
        if (!v37) {
          unint64_t v37 = (double *)MEMORY[0x1E4F1DB30];
        }
        double v32 = v32 + v36 + *v37;
        --v10;
      }
      while (v10);
    }
  }
  else
  {
    uint64_t v46 = *(void *)(v2 + 80) + *(void *)(v2 + 72);
    char v24 = operator new(0x28uLL);
    *char v24 = &unk_1ED061E98;
    v24[1] = &v46;
    void v24[2] = &v47;
    *((unsigned char *)v24 + 24) = v6 <= v5;
    v24[4] = v8;
    v48[3] = v24;
    TLine::EnumerateCaretOffsets((uint64_t *)v2, (uint64_t)v48);
    return (uint64_t)std::__function::__value_func<void ()(double,long,BOOL,BOOL *)>::~__value_func[abi:nn180100](v48);
  }
  return this;
}

void *std::__function::__value_func<void ()(double,long,BOOL,BOOL *)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t *TLine::EnumerateCaretOffsets(uint64_t *this, uint64_t a2)
{
  uint64_t v237 = *MEMORY[0x1E4F143B8];
  if (!*this) {
    return this;
  }
  uint64_t v3 = this;
  if (this[18])
  {
    unint64_t explicit = atomic_load_explicit(this + 26, memory_order_acquire);
    if (explicit)
    {
      unint64_t v5 = atomic_load_explicit(this + 25, memory_order_acquire);
      if (v5)
      {
        unint64_t v6 = explicit + 16 * v5;
        do
        {
          v230.i8[0] = 0;
          this = (uint64_t *)std::function<void ()(double,long,BOOL,BOOL *)>::operator()(*(void *)(a2 + 24), *(unsigned int *)(explicit + 8), *(unsigned char *)(explicit + 12), (uint64_t)&v230, *(double *)explicit);
          explicit += 16;
          if (v230.i8[0]) {
            BOOL v7 = 1;
          }
          else {
            BOOL v7 = explicit == v6;
          }
        }
        while (!v7);
      }
      return this;
    }
    this = (uint64_t *)TLine::GetLeftHangersGlyphCountAndWidth((TLine *)this, 0);
    if (v8 == 0.0) {
      double v9 = 0.0;
    }
    else {
      double v9 = 0.0 - v8;
    }
    unint64_t v10 = v3[18];
    if ((v10 >> 31)) {
      return this;
    }
    this = (uint64_t *)operator new[](32 * v10, MEMORY[0x1E4FBA2D0]);
    if (!this) {
      return this;
    }
    uint64_t v11 = this;
    unint64_t v215 = 0;
    if (v10 >> 61) {
      size_t v12 = -1;
    }
    else {
      size_t v12 = 8 * v10;
    }
    uint64_t v13 = (double *)operator new[](v12, MEMORY[0x1E4FBA2D0]);
    if (v13)
    {
      uint64_t v14 = v13;
      uint64_t v15 = v3[2];
      uint64_t v16 = v3[3] - v15;
      if (v16 >= 1)
      {
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        uint64_t v19 = (unint64_t)v16 >> 3;
        if (v19 <= 1) {
          uint64_t v19 = 1;
        }
        double v20 = 0.0;
        uint64_t v21 = (double *)MEMORY[0x1E4F1DB30];
        do
        {
          double v22 = *(void **)(*(void *)(v15 + 8 * v18) + 40);
          double v23 = (double *)v22[39];
          if (!v23) {
            double v23 = v21;
          }
          double v20 = v20 + *v23;
          uint64_t v24 = v22[26];
          if (v24 >= 1)
          {
            if (v24 + v17 > (uint64_t)v10) {
              goto LABEL_259;
            }
            uint64_t v25 = v22[27];
            uint64_t v26 = *(void *)(v25 + 32);
            if (v26 || (uint64_t v29 = *(void *)(v25 + 24)) == 0)
            {
              int v27 = 0;
              uint64_t v28 = (double *)(v26 + 16 * v22[25]);
            }
            else
            {
              uint64_t v28 = (double *)(v29 + 8 * v22[25]);
              int v27 = 1;
            }
            double v30 = v28;
            do
            {
              v13[v17++] = v20;
              if (v27) {
                uint64_t v31 = v28;
              }
              else {
                uint64_t v31 = v30;
              }
              double v20 = v20 + *v31;
              v30 += 2;
              ++v28;
              --v24;
            }
            while (v24);
          }
          ++v18;
        }
        while (v18 != v19);
      }
      uint64_t v201 = a2;
      unint64_t v32 = 2 * v10;
      v214[0] = v11;
      v214[1] = &v215;
      double v213 = 0.0;
      memset(v212, 170, sizeof(v212));
      CFIndex ClusterRange = TLine::GetClusterRange((TLine *)v3, (void *)*v3, v3[9], 3, &v212[1], &v213, v212);
      uint64_t v210 = v34;
      unint64_t v35 = v215;
      if (v215 < 2 * v10)
      {
        CFIndex v36 = ClusterRange;
        unint64_t v204 = 0;
        uint64_t v37 = *(void *)&v212[1];
        double v38 = v14[*(void *)&v212[1]];
        int v208 = v212[0];
        BOOL v39 = v212[0] < 1;
        double v40 = v213;
        if (v212[0] >= 1) {
          double v40 = -0.0;
        }
        uint64_t v41 = &v11[2 * v215];
        *((_DWORD *)v41 + 2) = ClusterRange;
        *((unsigned char *)v41 + 12) = 1;
        *((unsigned char *)v41 + 13) = v39;
        uint64_t v205 = v3[10] + v3[9];
        *(double *)uint64_t v41 = v9 + v38 + v40;
        unint64_t v215 = v35 + 1;
        BOOL v207 = (__n128 *)v11;
        int v203 = v14;
LABEL_45:
        memset(v232, 170, sizeof(v232));
        v231 = 0;
        int64x2_t v230 = 0uLL;
        v233 = v232;
        if (v210 < 2) {
          goto LABEL_144;
        }
        uint64_t v206 = v37;
        uint64_t v42 = *(void *)&v212[3];
        CFIndex v43 = v36 + v210;
        CFIndex v44 = v36;
        do
        {
          uint64_t v45 = (*(uint64_t (**)(uint64_t, CFIndex, uint64_t))(*(void *)*v3 + 40))(*v3, v44, 3);
          uint64_t v47 = v45;
          uint64_t v48 = v3[9];
          uint64_t v49 = v3[10];
          uint64_t v50 = v49 + v48;
          if (v45 + v46 >= v49 + v48) {
            uint64_t v51 = v49 + v48;
          }
          else {
            uint64_t v51 = v45 + v46;
          }
          BOOL v52 = v48 <= v45 && v45 < v50;
          if (v52)
          {
            uint64_t v54 = v51 - v45;
          }
          else if (v45 <= v48 && v48 < v45 + v46)
          {
            uint64_t v54 = v51 - v48;
            uint64_t v47 = v3[9];
          }
          else
          {
            uint64_t v47 = 0;
            uint64_t v54 = 0;
          }
          if (v54 <= 0)
          {
            v230.i64[1] = v230.i64[0];
            goto LABEL_195;
          }
          unsigned __int16 v55 = (void *)v230.i64[1];
          if (v230.i64[1] >= (unint64_t)v231)
          {
            unint64_t v57 = 0xAAAAAAAAAAAAAAABLL * ((v230.i64[1] - v230.i64[0]) >> 3);
            unint64_t v58 = v57 + 1;
            if (v57 + 1 > 0xAAAAAAAAAAAAAAALL) {
              goto LABEL_262;
            }
            if (0x5555555555555556 * ((uint64_t)&v231[-v230.i64[0]] >> 3) > v58) {
              unint64_t v58 = 0x5555555555555556 * ((uint64_t)&v231[-v230.i64[0]] >> 3);
            }
            if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v231[-v230.i64[0]] >> 3) >= 0x555555555555555) {
              unint64_t v59 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              unint64_t v59 = v58;
            }
            *((void *)&v235[0] + 1) = v232;
            double v60 = TInlineBufferAllocator<std::pair<double,CFRange>,30ul>::allocate((uint64_t)v232, v59);
            uint64_t v61 = &v60[24 * v57];
            *(void *)uint64_t v61 = v47;
            *((void *)v61 + 1) = v54;
            *((void *)v61 + 2) = 0;
            uint64_t v62 = v230.i64[1];
            uint64_t v63 = v230.i64[0];
            if (v230.i64[1] == v230.i64[0])
            {
              int64x2_t v66 = vdupq_n_s64(v230.u64[1]);
              unsigned __int16 v64 = &v60[24 * v57];
            }
            else
            {
              unsigned __int16 v64 = &v60[24 * v57];
              do
              {
                long long v65 = *(_OWORD *)(v62 - 24);
                *((void *)v64 - 1) = *(void *)(v62 - 8);
                *(_OWORD *)(v64 - 24) = v65;
                v64 -= 24;
                v62 -= 24;
              }
              while (v62 != v63);
              int64x2_t v66 = v230;
            }
            unsigned __int16 v56 = v61 + 24;
            v230.i64[0] = (uint64_t)v64;
            v230.i64[1] = (uint64_t)(v61 + 24);
            *(int64x2_t *)&v234[8] = v66;
            signed int v67 = v231;
            v231 = &v60[24 * v59];
            *(void *)&v235[0] = v67;
            *(void *)v234 = v66.i64[0];
            std::__split_buffer<std::pair<double,CFRange>,TInlineBufferAllocator<std::pair<double,CFRange>,30ul> &>::~__split_buffer((uint64_t)v234);
          }
          else
          {
            *(void *)v230.i64[1] = v47;
            v55[1] = v54;
            unsigned __int16 v56 = v55 + 3;
            v55[2] = 0;
          }
          v230.i64[1] = (uint64_t)v56;
          CFIndex v44 = v47 + v54;
        }
        while (v47 + v54 < v43);
        uint64_t v68 = *v3;
        uint64_t v69 = v206 - 1;
        uint64_t v216 = (char *)*v3;
        int v70 = v208;
        if (v208 >= 0) {
          uint64_t v69 = v42 + v206;
        }
        uint64_t v202 = v42 + v206 - 1;
        if (v208 >= 0) {
          uint64_t v71 = v206;
        }
        else {
          uint64_t v71 = v42 + v206 - 1;
        }
        long long v217 = 0u;
        long long v218 = 0u;
        long long v219 = 0u;
        long long v220 = 0u;
        long long v221 = 0u;
        long long v222 = 0u;
        long long v223 = 0u;
        long long v224 = 0u;
        long long v225 = 0u;
        long long v226 = 0u;
        uint64_t v228 = 0;
        long long v227 = 0u;
        *(void *)&long long v227 = *(void *)(v68 + 16);
        uint64_t v211 = v69;
        if (v71 == v69)
        {
          char v209 = 1;
          unint64_t v32 = 2 * v10;
          goto LABEL_132;
        }
        char v209 = 1;
        while (1)
        {
          uint64_t v72 = v3[2];
          uint64_t v73 = v3[3];
          if (v72 == v73)
          {
            unint64_t v76 = 0xAAAAAAAAAAAAAAAALL;
          }
          else
          {
            uint64_t v74 = 0;
            while (1)
            {
              uint64_t v75 = *(void *)(*(void *)(*(void *)v72 + 40) + 208) + v74;
              if (v75 > v71) {
                break;
              }
              v72 += 8;
              uint64_t v74 = v75;
              if (v72 == v73)
              {
                unint64_t v76 = 0xAAAAAAAAAAAAAAAALL;
                uint64_t v72 = v3[3];
                goto LABEL_92;
              }
            }
            unint64_t v76 = v71 - v74;
          }
LABEL_92:
          uint64_t v77 = *(void *)(*(void *)v72 + 40);
          CFIndex v78 = *(void *)(v77 + 8);
          CFIndex v79 = *(void *)(v77 + 16) + v78;
          if (v43 >= v79) {
            CFIndex v80 = *(void *)(v77 + 16) + v78;
          }
          else {
            CFIndex v80 = v36 + v210;
          }
          CFIndex v81 = v80 - v78;
          BOOL v82 = v36 <= v78 && v78 < v43;
          if (v82) {
            CFIndex v83 = *(void *)(v77 + 8);
          }
          else {
            CFIndex v83 = 0;
          }
          if (!v82) {
            CFIndex v81 = 0;
          }
          CFIndex v84 = v80 - v36;
          BOOL v85 = v78 <= v36 && v36 < v79;
          if (v85) {
            v86.CFIndex location = v36;
          }
          else {
            v86.CFIndex location = v83;
          }
          if (v85) {
            v86.CFIndex length = v84;
          }
          else {
            v86.CFIndex length = v81;
          }
          if (!TRun::IsRangeMonotonic((TRun *)v77, v86))
          {
            uint64_t v42 = 0;
LABEL_131:
            unsigned __int16 v56 = (void *)v230.i64[1];
            int v70 = v208;
            unint64_t v32 = 2 * v10;
LABEL_132:
            CGPoint v90 = (uint64_t *)v230.i64[0];
            uint64_t v14 = v203;
            if (v42 == 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v56 - v230.i64[0]) >> 3))
            {
              if (v70 < 0)
              {
                if ((void *)v230.i64[0] != v56)
                {
                  unint64_t v91 = (unint64_t)(v56 - 3);
                  if ((unint64_t)(v56 - 3) > v230.i64[0])
                  {
                    do
                    {
                      uint64_t v92 = *v90;
                      uint64_t v93 = v90[1];
                      *(_OWORD *)CGPoint v90 = *(_OWORD *)v91;
                      *(void *)unint64_t v91 = v92;
                      *(void *)(v91 + 8) = v93;
                      uint64_t v94 = v90[2];
                      _OWORD v90[2] = *(void *)(v91 + 16);
                      *(void *)(v91 + 16) = v94;
                      v90 += 3;
                      v91 -= 24;
                    }
                    while ((unint64_t)v90 < v91);
                  }
                }
                uint64_t v206 = v202;
              }
              uint64_t v95 = v3[2];
              uint64_t v96 = v3[3];
              if (v95 == v96)
              {
                unint64_t v99 = 0xAAAAAAAAAAAAAAAALL;
              }
              else
              {
                uint64_t v97 = 0;
                while (1)
                {
                  uint64_t v98 = *(void *)(*(void *)(*(void *)v95 + 40) + 208) + v97;
                  if (v98 > v206) {
                    break;
                  }
                  v95 += 8;
                  uint64_t v97 = v98;
                  if (v95 == v96)
                  {
                    unint64_t v99 = 0xAAAAAAAAAAAAAAAALL;
                    uint64_t v95 = v3[3];
                    goto LABEL_160;
                  }
                }
                unint64_t v99 = v206 - v97;
              }
LABEL_160:
              uint64_t v113 = *(atomic_ullong **)(*(void *)v95 + 40);
              atomic_ullong v114 = v113[27];
              uint64_t v115 = *(void *)(v114 + 32);
              if (v115 || (uint64_t v117 = *(void *)(v114 + 24)) == 0) {
                BOOL v116 = (double *)(v115 + 16 * v113[25] + 16 * v99);
              }
              else {
                BOOL v116 = (double *)(v117 + 8 * v113[25] + 8 * v99);
              }
              uint64_t v118 = v42 - 1;
              double v119 = *v116;
              unint64_t v120 = atomic_load_explicit(v113 + 7, memory_order_acquire);
              uint64_t v121 = *(unsigned __int16 *)(*(void *)(v113[27] + 16) + 2 * v113[25] + 2 * v99);
              *(void *)&long long v122 = 0xAAAAAAAAAAAAAAAALL;
              *((void *)&v122 + 1) = 0xAAAAAAAAAAAAAAAALL;
              v235[13] = v122;
              v235[14] = v122;
              v235[11] = v122;
              v235[12] = v122;
              v235[9] = v122;
              v235[10] = v122;
              v235[7] = v122;
              v235[8] = v122;
              v235[5] = v122;
              v235[6] = v122;
              v235[3] = v122;
              v235[4] = v122;
              v235[1] = v122;
              v235[2] = v122;
              v235[0] = v122;
              memset(v234, 0, sizeof(v234));
              v236 = v235;
              if (v120)
              {
                int64_t LigatureCaretPositionsForGlyph = TFont::GetLigatureCaretPositionsForGlyph(*(TFont **)(v120 + 40), v121, 0, 0);
                if (LigatureCaretPositionsForGlyph >= 1)
                {
                  uint64_t v124 = LigatureCaretPositionsForGlyph;
                  std::vector<double,TInlineBufferAllocator<double,30ul>>::resize((uint64_t)v234, LigatureCaretPositionsForGlyph);
                  if (*(void *)v234) {
                    TFont::GetLigatureCaretPositionsForGlyph(*(TFont **)(v120 + 40), v121, *(double **)v234, v124);
                  }
LABEL_168:
                  uint64_t v14 = v203;
                  if (v42 >= 2)
                  {
                    int64_t v125 = *(uint64_t **)v234;
                    goto LABEL_175;
                  }
                  goto LABEL_177;
                }
              }
              if (((v42 > 1) & v209) == 1)
              {
                std::vector<double,TInlineBufferAllocator<double,30ul>>::resize((uint64_t)v234, v42 - 1);
                double v126 = v119 / (double)v42;
                int64_t v125 = *(uint64_t **)v234;
                **(double **)v234 = v126;
                uint64_t v14 = v203;
                if ((unint64_t)v42 >= 3)
                {
                  uint64_t v127 = v42 - 2;
                  uint64_t v128 = (double *)(v125 + 1);
                  double v129 = v119 / (double)v42;
                  do
                  {
                    double v129 = v126 + v129;
                    *v128++ = v129;
                    --v127;
                  }
                  while (v127);
                  goto LABEL_168;
                }
LABEL_175:
                uint64_t v130 = (void *)(v230.i64[0] + 16);
                do
                {
                  uint64_t v131 = *v125++;
                  void *v130 = v131;
                  v130 += 3;
                  --v118;
                }
                while (v118);
LABEL_177:
                *(double *)(v230.i64[1] - 8) = v119;
                uint64_t v229 = (uint64_t)v234;
                std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v229);
                unint64_t v132 = v230.u64[1];
                uint64_t v133 = (void *)v230.i64[0];
                if (v230.i64[1] < (unint64_t)v231)
                {
                  uint64_t v134 = v230.i64[0] + 24;
                  unint64_t v32 = 2 * v10;
                  if (v230.i64[0] == v230.i64[1])
                  {
                    *(void *)(v230.i64[0] + 8) = 0;
                    v133[2] = 0;
                    void *v133 = -1;
                    v230.i64[1] = (uint64_t)(v133 + 3);
                  }
                  else
                  {
                    unint64_t v135 = v230.i64[1] - 24;
                    uint64_t v136 = v230.i64[1];
                    while (v135 < v132)
                    {
                      long long v137 = *(_OWORD *)v135;
                      *(void *)(v136 + 16) = *(void *)(v135 + 16);
                      *(_OWORD *)uint64_t v136 = v137;
                      v136 += 24;
                      v135 += 24;
                    }
                    v230.i64[1] = v136;
                    if (v132 != v134)
                    {
                      uint64_t v141 = (uint64_t)(v132 - v134) >> 3;
                      BOOL v142 = (void *)(v132 - 8);
                      uint64_t v143 = v141;
                      do
                      {
                        *((_OWORD *)v142 - 1) = *(_OWORD *)&v133[v143 - 3];
                        void *v142 = v133[v143 - 1];
                        v142 -= 3;
                        v143 -= 3;
                      }
                      while (v143 * 8);
                    }
                    v133[1] = 0;
                    v133[2] = 0;
                    void *v133 = -1;
                  }
LABEL_206:
                  uint64_t v152 = v230.i64[0];
                  uint64_t v153 = -1 - 0x5555555555555555 * ((v230.i64[1] - v230.i64[0]) >> 3);
                  uint64_t v154 = v212[0];
                  if (v212[0] >= 0) {
                    uint64_t v155 = 1;
                  }
                  else {
                    uint64_t v155 = -1 - 0x5555555555555555 * ((v230.i64[1] - v230.i64[0]) >> 3);
                  }
                  if (v212[0] < 0) {
                    uint64_t v153 = 1;
                  }
                  unint64_t v100 = v215;
                  uint64_t v156 = v155 - v153;
                  uint64_t v11 = (uint64_t *)v207;
                  if (v156)
                  {
                    uint64_t v157 = 24 * (v155 + v212[0]);
                    uint64_t v158 = 24 * v155;
                    long long v159 = &v207[v215];
                    do
                    {
                      if (v100 >= v32) {
                        goto LABEL_246;
                      }
                      unint64_t v160 = v100;
                      double v161 = *(double *)(v152 + v158 - 8);
                      double v162 = v38 + v161;
                      if ((int)v154 < 1)
                      {
                        char v163 = 0;
                      }
                      else
                      {
                        double v162 = v162 + *(double *)(v152 + v158 + 16) - v161;
                        char v163 = 1;
                      }
                      v159->n128_u32[2] = *(void *)(v152 + v158 + 8) + *(void *)(v152 + v158) - 1;
                      v159->n128_u8[12] = 0;
                      v159->n128_u8[13] = v163;
                      v159->n128_f64[0] = v9 + v162;
                      unint64_t v215 = v100 + 1;
                      if (v100 + 1 >= v32) {
                        goto LABEL_246;
                      }
                      uint64_t v164 = (CFIndex *)(v152 + v157);
                      double v165 = *(double *)(v152 + v157 - 8);
                      double v166 = v38 + v165;
                      if ((int)v154 <= 0)
                      {
                        double v166 = v166 + *(double *)(v152 + v157 + 16) - v165;
                        char v167 = 1;
                      }
                      else
                      {
                        char v167 = 0;
                      }
                      CFIndex v36 = *v164;
                      uint64_t v168 = v164[1];
                      v159[1].n128_u32[2] = v36;
                      v159[1].n128_u8[12] = 1;
                      v159[1].n128_u8[13] = v167;
                      v159[1].n128_f64[0] = v9 + v166;
                      v100 += 2;
                      unint64_t v215 = v160 + 2;
                      v152 += 24 * v154;
                      v159 += 2;
                      v156 += v154;
                    }
                    while (v156);
                    uint64_t v210 = v168;
                    unint64_t v100 = v160 + 2;
                  }
LABEL_145:
                  if (v100 >= v32) {
                    goto LABEL_246;
                  }
                  int v101 = v212[0];
                  BOOL v102 = v212[0] > 0;
                  double v103 = v213;
                  if (v212[0] <= 0) {
                    double v103 = -0.0;
                  }
                  unint64_t v104 = &v11[2 * v100];
                  uint64_t v105 = v210 + v36;
                  *((_DWORD *)v104 + 2) = v210 + v36 - 1;
                  *((unsigned char *)v104 + 12) = 0;
                  *((unsigned char *)v104 + 13) = v102;
                  *(double *)unint64_t v104 = v9 + v38 + v103;
                  unint64_t v215 = v100 + 1;
                  if (v210 + v36 < v205)
                  {
                    CFIndex v106 = TLine::GetClusterRange((TLine *)v3, (void *)*v3, v105, 3, &v212[1], &v213, v212);
                    if (v106 <= v105)
                    {
                      CFIndex v36 = v106;
                      if (v106 + v107 > v105)
                      {
                        uint64_t v210 = v107;
                        if (v212[0] == v101)
                        {
                          unint64_t v109 = v215;
                        }
                        else
                        {
                          TLine::EnumerateCaretOffsets(std::function<void ()(double,long,BOOL,BOOL *)>)const::$_0::operator()((uint64_t)v214, v204, v101, v108);
                          unint64_t v109 = v215;
                          unint64_t v204 = v215;
                        }
                        unint64_t v32 = 2 * v10;
                        if (v109 < 2 * v10)
                        {
                          double v38 = v14[*(void *)&v212[1]];
                          BOOL v110 = v212[0] < 1;
                          double v111 = v213;
                          if (v212[0] >= 1) {
                            double v111 = -0.0;
                          }
                          BOOL v112 = &v11[2 * v109];
                          *((_DWORD *)v112 + 2) = v36;
                          *((unsigned char *)v112 + 12) = 1;
                          *((unsigned char *)v112 + 13) = v110;
                          *(double *)BOOL v112 = v9 + v38 + v111;
                          unint64_t v215 = v109 + 1;
                          std::vector<std::pair<CFRange,double>,TInlineBufferAllocator<std::pair<CFRange,double>,30ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v230);
                          uint64_t v37 = *(void *)&v212[1];
                          int v208 = v212[0];
                          goto LABEL_45;
                        }
LABEL_246:
                        std::vector<std::pair<CFRange,double>,TInlineBufferAllocator<std::pair<CFRange,double>,30ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v230);
                        goto LABEL_259;
                      }
                    }
                  }
                  std::vector<std::pair<CFRange,double>,TInlineBufferAllocator<std::pair<CFRange,double>,30ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v230);
                  TLine::EnumerateCaretOffsets(std::function<void ()(double,long,BOOL,BOOL *)>)const::$_0::operator()((uint64_t)v214, v204, v212[0], v169);
                  int64_t v171 = v215;
                  if (v215 < 3)
                  {
                    BOOL v189 = (__n128 *)&v11[2 * v215];
                    uint64_t v194 = (__n128 *)v11;
                    uint64_t v177 = v201;
                  }
                  else
                  {
                    int v172 = v11 + 2;
                    unsigned __int32 v173 = *((_DWORD *)v11 + 6);
                    uint64_t v174 = -1;
                    uint64_t v175 = 1;
                    uint64_t v176 = 2;
                    uint64_t v177 = v201;
                    do
                    {
                      uint64_t v178 = v175;
                      uint64_t v175 = v176;
                      unsigned __int32 v179 = v173;
                      unsigned __int32 v173 = v207[v175].n128_u32[2];
                      if (v179 == v173)
                      {
                        double v180 = v207[v178].n128_f64[0];
                        if (v180 == v207[v175].n128_f64[0])
                        {
                          uint64_t v181 = v174;
                          unsigned int v182 = v172;
                          while (!__CFADD__(v181++, 1))
                          {
                            long long v184 = (double *)(v182 - 2);
                            int v185 = *((unsigned __int8 *)v182 - 3);
                            v182 -= 2;
                            if (v185)
                            {
                              *long long v184 = v180;
                              break;
                            }
                          }
                        }
                      }
                      uint64_t v176 = v175 + 1;
                      v172 += 2;
                      --v174;
                    }
                    while (v175 + 1 != v171);
                    n128_f64 = v207[2].n128_f64;
                    unint64_t v187 = 2;
                    v170.n128_u64[0] = 0.5;
                    do
                    {
                      double v188 = (*(n128_f64 - 2) + *n128_f64) * 0.5;
                      *(n128_f64 - 2) = v188;
                      double *n128_f64 = v188;
                      n128_f64 += 4;
                      v187 += 2;
                    }
                    while (v187 < v171);
                    BOOL v189 = &v207[v171];
                    if (v171 > 128)
                    {
                      if (v171 >= 0x7FFFFFFFFFFFFFFLL) {
                        unint64_t v190 = 0x7FFFFFFFFFFFFFFLL;
                      }
                      else {
                        unint64_t v190 = v171;
                      }
                      char v191 = (const std::nothrow_t *)MEMORY[0x1E4FBA2D0];
                      while (1)
                      {
                        uint64_t v192 = (__n128 *)operator new(16 * v190, v191);
                        if (v192) {
                          break;
                        }
                        BOOL v52 = v190 > 1;
                        v190 >>= 1;
                        if (!v52)
                        {
                          std::__stable_sort<std::_ClassicAlgPolicy,TLine::EnumerateCaretOffsets(std::function<void ()(double,long,BOOL,BOOL *)>)::$_2 &,TLine::CaretInfo *>(v207, v189, v171, 0, 0, v193);
                          goto LABEL_248;
                        }
                      }
                      int v195 = v192;
                      std::__stable_sort<std::_ClassicAlgPolicy,TLine::EnumerateCaretOffsets(std::function<void ()(double,long,BOOL,BOOL *)>)::$_2 &,TLine::CaretInfo *>(v207, v189, v171, v192, v190, v193);
                      operator delete(v195);
LABEL_248:
                      uint64_t v177 = v201;
                      goto LABEL_249;
                    }
                    uint64_t v194 = v207;
                  }
                  std::__stable_sort<std::_ClassicAlgPolicy,TLine::EnumerateCaretOffsets(std::function<void ()(double,long,BOOL,BOOL *)>)::$_2 &,TLine::CaretInfo *>(v194, v189, v171, 0, 0, v170);
LABEL_249:
                  unint64_t v196 = v215;
                  uint64_t v14 = v203;
                  if (v215)
                  {
                    uint64_t v197 = v207;
                    uint64_t v198 = &v207[v215];
                    do
                    {
                      v230.i8[0] = 0;
                      std::function<void ()(double,long,BOOL,BOOL *)>::operator()(*(void *)(v177 + 24), v197->n128_u32[2], v197->n128_i8[12], (uint64_t)&v230, v197->n128_f64[0]);
                      ++v197;
                      if (v230.i8[0]) {
                        BOOL v199 = 1;
                      }
                      else {
                        BOOL v199 = v197 == v198;
                      }
                    }
                    while (!v199);
                    unint64_t v196 = v215;
                  }
                  uint64_t v200 = 0;
                  atomic_store(v196, (unint64_t *)v3 + 25);
                  uint64_t v11 = (uint64_t *)v207;
                  atomic_compare_exchange_strong(v3 + 26, (unint64_t *)&v200, (unint64_t)v207);
                  if (!v200) {
                    uint64_t v11 = 0;
                  }
                  goto LABEL_259;
                }
                uint64_t v216 = 0;
                long long v217 = 0uLL;
                unint64_t v138 = 1 - 0x5555555555555555 * ((v230.i64[1] - v230.i64[0]) >> 3);
                if (v138 <= 0xAAAAAAAAAAAAAAALL)
                {
                  if (0x5555555555555556 * ((uint64_t)&v231[-v230.i64[0]] >> 3) > v138) {
                    unint64_t v138 = 0x5555555555555556 * ((uint64_t)&v231[-v230.i64[0]] >> 3);
                  }
                  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v231[-v230.i64[0]] >> 3) >= 0x555555555555555) {
                    unint64_t v139 = 0xAAAAAAAAAAAAAAALL;
                  }
                  else {
                    unint64_t v139 = v138;
                  }
                  *((void *)&v218 + 1) = v232;
                  if (v139)
                  {
                    uint64_t v140 = TInlineBufferAllocator<std::pair<double,CFRange>,30ul>::allocate((uint64_t)v232, v139);
                    *(void *)&long long v218 = &v140[24 * v139];
                  }
                  else
                  {
                    *(void *)&long long v218 = 0;
                    *((void *)&v235[0] + 1) = v232;
                    uint64_t v140 = TInlineBufferAllocator<std::pair<double,CFRange>,30ul>::allocate((uint64_t)v232, 1uLL);
                    memset(v234, 0, sizeof(v234));
                    *(void *)&v235[0] = 0;
                    uint64_t v216 = v140;
                    *(void *)&long long v218 = v140 + 24;
                    std::__split_buffer<std::pair<double,CFRange>,TInlineBufferAllocator<std::pair<double,CFRange>,30ul> &>::~__split_buffer((uint64_t)v234);
                  }
                  BOOL v144 = v140 + 24;
                  *((void *)v140 + 1) = 0;
                  *((void *)v140 + 2) = 0;
                  *(void *)uint64_t v140 = -1;
                  *((void *)&v217 + 1) = v140 + 24;
                  int v145 = (void *)v230.i64[0];
                  uint64_t v14 = v203;
                  if ((void *)v230.i64[0] != v133)
                  {
                    int v146 = v133;
                    do
                    {
                      long long v147 = *(_OWORD *)(v146 - 3);
                      *((void *)v140 - 1) = *(v146 - 1);
                      *(_OWORD *)(v140 - 24) = v147;
                      v140 -= 24;
                      v146 -= 3;
                    }
                    while (v146 != v145);
                    BOOL v144 = (char *)*((void *)&v217 + 1);
                  }
                  *(void *)&long long v217 = v140;
                  CFStringRef v148 = (void *)v230.i64[1];
                  if ((void *)v230.i64[1] != v133)
                  {
                    do
                    {
                      long long v149 = *(_OWORD *)v133;
                      *((void *)v144 + 2) = v133[2];
                      *(_OWORD *)BOOL v144 = v149;
                      v144 += 24;
                      v133 += 3;
                    }
                    while (v133 != v148);
                    uint64_t v140 = (char *)v217;
                    uint64_t v133 = (void *)v230.i64[1];
                  }
                  unsigned int v150 = (char *)v230.i64[0];
                  v230.i64[0] = (uint64_t)v140;
                  v230.i64[1] = (uint64_t)v144;
                  unsigned int v151 = v231;
                  v231 = (char *)v218;
                  *((void *)&v217 + 1) = v133;
                  *(void *)&long long v218 = v151;
                  uint64_t v216 = v150;
                  *(void *)&long long v217 = v150;
                  std::__split_buffer<std::pair<double,CFRange>,TInlineBufferAllocator<std::pair<double,CFRange>,30ul> &>::~__split_buffer((uint64_t)&v216);
                  unint64_t v32 = 2 * v10;
                  goto LABEL_206;
                }
LABEL_262:
                abort();
              }
              v230.i64[1] = v230.i64[0];
              uint64_t v229 = (uint64_t)v234;
              std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v229);
LABEL_195:
              uint64_t v11 = (uint64_t *)v207;
              uint64_t v14 = v203;
              unint64_t v32 = 2 * v10;
            }
            else
            {
              v230.i64[1] = v230.i64[0];
              uint64_t v11 = (uint64_t *)v207;
            }
LABEL_144:
            unint64_t v100 = v215;
            goto LABEL_145;
          }
          uint64_t v229 = *(void *)(*(void *)(*(void *)(v77 + 216) + 48) + 8 * *(void *)(v77 + 200) + 8 * v76);
          memset(v234, 170, 16);
          Fulluint64_t Char = TCharStreamIterator::GetFullChar((TCharStreamIterator *)&v216, &v229, (CFRange *)v234);
          if (CFUniCharIsMemberOf()) {
            goto LABEL_114;
          }
          if (CFUniCharIsMemberOf()) {
            break;
          }
LABEL_120:
          if ((FullChar - 1792) >> 9 < 0xB || FullChar >> 8 > 0x30 || FullChar - 11904 <= 0x17F) {
            char v209 = 0;
          }
          uint64_t v88 = v42 - (*(void *)&v234[8] > 1);
          uint64_t v42 = v88 - [*(id *)(v77 + 216) attachmentCountAtIndex:*(void *)(v77 + 200) + v76];
          v71 += v208;
          if (v42 < 1 || v71 == v211) {
            goto LABEL_131;
          }
        }
        if (v230.i64[0] != v230.i64[1]
          && *(void *)v234 == *(void *)(v230.i64[1] - 24)
          && *(void *)&v234[8] == *(void *)(v230.i64[1] - 16))
        {
          v230.i64[1] -= 24;
        }
LABEL_114:
        --v42;
        goto LABEL_120;
      }
LABEL_259:
      this = (uint64_t *)MEMORY[0x1853275A0](v14, 0x1000C8000313F17);
      if (!v11) {
        return this;
      }
    }
    return (uint64_t *)MEMORY[0x1853275A0](v11, 0x1000C8099076E91);
  }
  v230.i8[0] = 0;
  this = (uint64_t *)std::function<void ()(double,long,BOOL,BOOL *)>::operator()(*(void *)(a2 + 24), this[9], 1, (uint64_t)&v230, 0.0);
  if (!v230.i8[0]) {
    return (uint64_t *)std::function<void ()(double,long,BOOL,BOOL *)>::operator()(*(void *)(a2 + 24), v3[9] + v3[10] - 1, 0, (uint64_t)&v230, 0.0);
  }
  return this;
}

uint64_t std::function<void ()(double,long,BOOL,BOOL *)>::operator()(uint64_t a1, uint64_t a2, char a3, uint64_t a4, double a5)
{
  double v14 = a5;
  uint64_t v13 = a2;
  char v12 = a3;
  uint64_t v11 = a4;
  if (a1) {
    return (*(uint64_t (**)(uint64_t, double *, uint64_t *, char *, uint64_t *))(*(void *)a1 + 48))(a1, &v14, &v13, &v12, &v11);
  }
  uint64_t v6 = std::__throw_bad_function_call[abi:nn180100]();
  return std::__function::__func<TLine::CharIndexToOffsets(long)::$_0,std::allocator<TLine::CharIndexToOffsets(long)::$_0>,void ()(double,long,BOOL,BOOL *)>::operator()(v6, v7, v8, v9, v10);
}

uint64_t std::__function::__func<TLine::CharIndexToOffsets(long)::$_0,std::allocator<TLine::CharIndexToOffsets(long)::$_0>,void ()(double,long,BOOL,BOOL *)>::operator()(uint64_t result, uint64_t *a2, uint64_t *a3, unsigned __int8 *a4, unsigned char **a5)
{
  if (*(unsigned __int8 *)(result + 24) != *a4)
  {
    uint64_t v5 = *a2;
    uint64_t v6 = *a3;
    uint64_t v7 = *(void *)(result + 32);
    if (v7 == *a3)
    {
      **a5 = 1;
LABEL_7:
      **(void **)(result + 16) = v5;
      return result;
    }
    if (v7 < *a3)
    {
      double v8 = *(void **)(result + 8);
      if (*v8 > v6)
      {
        *double v8 = v6;
        goto LABEL_7;
      }
    }
  }
  return result;
}

CFIndex TLine::GetClusterRange(TLine *a1, void *a2, uint64_t a3, uint64_t a4, void *a5, double *a6, int *a7)
{
  uint64_t RunWithCharIndex = TLine::FindRunWithCharIndex(a1, a3, 1);
  if (RunWithCharIndex < 1)
  {
    uint64_t v15 = 0;
  }
  else
  {
    uint64_t v15 = 0;
    uint64_t v16 = (uint64_t *)*((void *)a1 + 2);
    uint64_t v17 = RunWithCharIndex;
    do
    {
      uint64_t v18 = *v16++;
      v15 += *(void *)(*(void *)(v18 + 40) + 208);
      --v17;
    }
    while (v17);
  }
  return TLine::GetClusterRange(a1, a2, RunWithCharIndex, v15, a3, a4, a5, a6, a7);
}

CFIndex TLine::GetClusterRange(TLine *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, double *a8, int *a9)
{
  uint64_t v15 = objc_opt_new();
  uint64_t v17 = *((void *)a1 + 2);
  uint64_t v16 = *((void *)a1 + 3);
  uint64_t v148 = a6;
  uint64_t v18 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*a2 + 40))(a2, a5, a6);
  uint64_t v20 = *((void *)a1 + 9);
  uint64_t v21 = *((void *)a1 + 10) + v20;
  if (v18 + v19 >= v21) {
    uint64_t v22 = *((void *)a1 + 10) + v20;
  }
  else {
    uint64_t v22 = v18 + v19;
  }
  uint64_t v23 = v22 - v20;
  BOOL v24 = v18 <= v20 && v20 < v18 + v19;
  if (v24) {
    CFIndex v25 = *((void *)a1 + 9);
  }
  else {
    CFIndex v25 = 0;
  }
  if (!v24) {
    uint64_t v23 = 0;
  }
  uint64_t v26 = v22 - v18;
  BOOL v27 = v20 <= v18 && v18 < v21;
  if (v27) {
    CFIndex v28 = v18;
  }
  else {
    CFIndex v28 = v25;
  }
  if (v27) {
    CFIndex v29 = v26;
  }
  else {
    CFIndex v29 = v23;
  }
  CFIndex v171 = v29;
  uint64_t v157 = a3;
  uint64_t v30 = *(void *)(*(void *)(*((void *)a1 + 2) + 8 * a3) + 40);
  GlyphIndexForuint64_t Char = TRun::GetGlyphIndexForCharIndex<true>(v30, a5);
  BOOL v166 = (~*(_DWORD *)(*(void *)(*(void *)(v30 + 216) + 40) + 4 * *(void *)(v30 + 200) + 4 * GlyphIndexForChar) & 0x1020) == 0;
  int v150 = *(_DWORD *)(v30 + 304);
  int v151 = *(unsigned __int8 *)(v30 + 224);
  uint64_t v175 = a2;
  long long v186 = 0u;
  long long v185 = 0u;
  long long v184 = 0u;
  long long v183 = 0u;
  long long v182 = 0u;
  long long v181 = 0u;
  long long v180 = 0u;
  long long v179 = 0u;
  long long v178 = 0u;
  long long v176 = 0u;
  long long v177 = 0u;
  uint64_t v149 = (uint64_t)a2;
  uint64_t v32 = a2[2];
  uint64_t v187 = 0;
  *(void *)&long long v186 = v32;
  __n128 v170 = a1;
  CFIndex v33 = CharRangeForGlyphIndex(a1, (TCharStreamIterator *)&v175, *(const TStorageRange **)(v30 + 200), *(void **)(v30 + 216), GlyphIndexForChar);
  CFIndex v35 = v34;
  id v169 = v15;
  objc_msgSend(v15, "addIndexesInRange:", v33, v34);
  CFIndex v36 = *(void **)(v30 + 216);
  uint64_t v37 = v36[4];
  if (v37 || (uint64_t v41 = v36[3]) == 0)
  {
    uint64_t v38 = *(void *)(v30 + 200);
    uint64_t v165 = v37 + 16 * v38;
    BOOL v39 = (double *)(v165 + 16 * GlyphIndexForChar);
    int v40 = 2;
  }
  else
  {
    uint64_t v38 = *(void *)(v30 + 200);
    uint64_t v165 = v41 + 8 * v38;
    BOOL v39 = (double *)(v165 + 8 * GlyphIndexForChar);
    int v40 = 1;
  }
  int v164 = v40;
  BOOL v142 = a9;
  uint64_t v172 = GlyphIndexForChar + a4;
  double v42 = *v39;
  uint64_t v43 = v157;
  CFIndex v167 = v35;
  if ((*(_DWORD *)(v36[5] + 4 * v38 + 4 * GlyphIndexForChar) & 0x404) == 0)
  {
    CFIndex v44 = *(uint64_t **)(v30 + 232);
    double v45 = 0.0;
    if (v44)
    {
      unint64_t v46 = v38 + GlyphIndexForChar - *(void *)(v30 + 248);
      uint64_t v47 = *v44;
      if (v46 < (*(void *)(*(void *)(v30 + 232) + 8) - v47) >> 3) {
        double v45 = *(double *)(v47 + 8 * v46);
      }
    }
    double v42 = v42 - v45;
  }
  char v152 = *(unsigned char *)(v30 + 224);
  if (v152) {
    int v48 = -1;
  }
  else {
    int v48 = 1;
  }
  int v145 = v48;
  uint64_t v146 = GlyphIndexForChar;
  uint64_t v153 = (v16 - v17) >> 3;
  uint64_t v154 = *(void *)(v30 + 208);
  uint64_t v174 = 1;
  if (*(unsigned char *)(v30 + 224)) {
    uint64_t v49 = 1;
  }
  else {
    uint64_t v49 = -1;
  }
  if (*(unsigned char *)(v30 + 224)) {
    uint64_t v50 = 0;
  }
  else {
    uint64_t v50 = -1;
  }
  uint64_t v147 = v50;
  uint64_t v155 = v30;
  uint64_t v51 = v30;
  int v158 = v164;
  uint64_t v160 = v165;
  uint64_t v162 = v49;
  uint64_t v52 = GlyphIndexForChar;
  uint64_t v168 = v30 + 192;
  uint64_t v53 = v30 + 192;
  while (1)
  {
    v52 += v162;
    if (v52 >= 0 && v154 > v52)
    {
      uint64_t v54 = v51;
      goto LABEL_55;
    }
    v43 += v162;
    if (v43 < 0) {
      break;
    }
    if (v153 <= v43) {
      break;
    }
    uint64_t v54 = *(void *)(*(void *)(*((void *)v170 + 2) + 8 * v43) + 40);
    if (*(void *)(v54 + 24) != v51 || *(unsigned __int8 *)(v54 + 224) != v151 || *(_DWORD *)(v54 + 304) != v150) {
      break;
    }
    uint64_t v55 = *(void *)(v54 + 216);
    uint64_t v56 = *(void *)(v55 + 32);
    if (v56 || (uint64_t v58 = *(void *)(v55 + 24)) == 0)
    {
      uint64_t v160 = v56 + 16 * *(void *)(v54 + 200);
      int v57 = 2;
    }
    else
    {
      uint64_t v160 = v58 + 8 * *(void *)(v54 + 200);
      int v57 = 1;
    }
    int v158 = v57;
    uint64_t v53 = v54 + 192;
    uint64_t v154 = *(void *)(v54 + 208);
    if (v152) {
      uint64_t v52 = 0;
    }
    else {
      uint64_t v52 = v154 - 1;
    }
LABEL_55:
    CFIndex v59 = CharRangeForGlyphIndex(v170, (TCharStreamIterator *)&v175, *(const TStorageRange **)(v53 + 8), *(void **)(v53 + 24), v52);
    CFIndex v61 = v59;
    uint64_t v62 = v60;
    CFIndex v63 = v59 + v60;
    CFIndex v64 = v171 + v28;
    if (v59 + v60 >= v171 + v28) {
      CFIndex v65 = v171 + v28;
    }
    else {
      CFIndex v65 = v59 + v60;
    }
    BOOL v66 = v28 <= v59 && v59 < v64;
    CFIndex v67 = v59;
    if ((v66 || (v59 <= v28 ? (v68 = v28 < v63) : (v68 = 0), CFIndex v67 = v28, v68)) && v65 != v67)
    {
      BOOL v166 = 0;
    }
    else
    {
      if (!v166
        && (*(_DWORD *)(*(void *)(*(void *)(v53 + 24) + 40) + 4 * *(void *)(v53 + 8) + 4 * v52) & 0x20) != 0)
      {
        break;
      }
      uint64_t ClusterRangeForRange = TCharStream::GetClusterRangeForRange(v149, v59, v60, v148);
      CFIndex v71 = ClusterRangeForRange + v70;
      if (ClusterRangeForRange + v70 >= v64) {
        CFIndex v72 = v171 + v28;
      }
      else {
        CFIndex v72 = ClusterRangeForRange + v70;
      }
      if (v28 > ClusterRangeForRange || ClusterRangeForRange >= v64)
      {
        uint64_t v73 = v72 - v28;
        if (v28 >= v71 || ClusterRangeForRange > v28) {
          uint64_t v73 = 0;
        }
      }
      else
      {
        uint64_t v73 = v72 - ClusterRangeForRange;
      }
      if (v73 > 0 || v64 == ClusterRangeForRange)
      {
        BOOL v166 = 0;
      }
      else
      {
        if (!v166 || v71 != v28) {
          break;
        }
        unsigned int v76 = *(_DWORD *)(*(void *)(*(void *)(v53 + 24) + 40) + 4 * *(void *)(v53 + 8) + 4 * v52);
        if ((v76 & 0x20) != 0) {
          int v77 = (v76 >> 12) & 1;
        }
        else {
          LOBYTE(v77) = 0;
        }
        BOOL v166 = v77;
      }
      if (ClusterRangeForRange < v28) {
        CFIndex v28 = ClusterRangeForRange;
      }
      if (v64 > v71) {
        CFIndex v71 = v64;
      }
      CFIndex v171 = v71 - v28;
    }
    objc_msgSend(v169, "addIndexesInRange:", v61, v62, v142);
    CFIndex v78 = v167 + v33;
    if (v61 < v33) {
      CFIndex v33 = v61;
    }
    if (v78 <= v63) {
      CFIndex v78 = v63;
    }
    CFIndex v167 = v78 - v33;
    v172 += v147;
    ++v174;
    CFIndex v79 = (double *)(v160 + 8 * v52);
    if (v158 != 1) {
      CFIndex v79 = (double *)(v160 + 16 * v52);
    }
    double v42 = v42 + *v79;
    uint64_t v51 = v54;
  }
  uint64_t v80 = v155;
  uint64_t v81 = v146;
  if (v152) {
    uint64_t v82 = -1;
  }
  else {
    uint64_t v82 = 0;
  }
  uint64_t v161 = v82;
  uint64_t v163 = *(void *)(v155 + 208);
  uint64_t v159 = v155;
  CFIndex v83 = v167;
  uint64_t v84 = v172;
  while (1)
  {
    v81 += v145;
    uint64_t v85 = v168;
    if (v81 < 0 || v163 <= v81)
    {
      uint64_t v173 = v84;
      uint64_t v86 = v157 + v145;
      if (v86 < 0) {
        goto LABEL_163;
      }
      if (v153 <= v86) {
        goto LABEL_163;
      }
      uint64_t v87 = *(void *)(*(void *)(*((void *)v170 + 2) + 8 * v86) + 40);
      if (*(void *)(v87 + 32) != v80 || *(unsigned __int8 *)(v87 + 224) != v151 || *(_DWORD *)(v87 + 304) != v150) {
        goto LABEL_163;
      }
      uint64_t v88 = *(void *)(v87 + 216);
      uint64_t v89 = *(void *)(v88 + 32);
      v157 += v145;
      if (v89 || (uint64_t v91 = *(void *)(v88 + 24)) == 0)
      {
        uint64_t v165 = v89 + 16 * *(void *)(v87 + 200);
        int v90 = 2;
      }
      else
      {
        uint64_t v165 = v91 + 8 * *(void *)(v87 + 200);
        int v90 = 1;
      }
      int v164 = v90;
      uint64_t v85 = v87 + 192;
      uint64_t v163 = *(void *)(v87 + 208);
      if (v152) {
        uint64_t v81 = v163 - 1;
      }
      else {
        uint64_t v81 = 0;
      }
      uint64_t v80 = v87;
    }
    uint64_t v92 = *(void **)(v85 + 24);
    uint64_t v168 = v85;
    uint64_t v93 = *(const TStorageRange **)(v85 + 8);
    int v94 = *(_DWORD *)(v92[5] + 4 * (void)v93 + 4 * v81);
    CFIndex v95 = CharRangeForGlyphIndex(v170, (TCharStreamIterator *)&v175, v93, v92, v81);
    CFIndex v97 = v95;
    uint64_t v98 = v96;
    if ((v94 & 0x20) == 0) {
      break;
    }
    CFIndex v112 = v171 + v28;
    if (v95 < v28) {
      CFIndex v28 = v95;
    }
    CFIndex v99 = v95 + v96;
    if (v112 <= v95 + v96) {
      CFIndex v112 = v95 + v96;
    }
    CFIndex v171 = v112 - v28;
LABEL_156:
    objc_msgSend(v169, "addIndexesInRange:", v97, v98, v142);
    CFIndex v113 = v83 + v33;
    if (v97 < v33) {
      CFIndex v33 = v97;
    }
    if (v113 <= v99) {
      CFIndex v113 = v99;
    }
    CFIndex v83 = v113 - v33;
    ++v174;
    v84 += v161;
    atomic_ullong v114 = (double *)(v165 + 8 * v81);
    if (v164 != 1) {
      atomic_ullong v114 = (double *)(v165 + 16 * v81);
    }
    double v42 = v42 + *v114;
  }
  uint64_t v156 = v80;
  CFIndex v99 = v95 + v96;
  CFIndex v100 = v171 + v28;
  if (v95 + v96 >= v171 + v28) {
    CFIndex v101 = v171 + v28;
  }
  else {
    CFIndex v101 = v95 + v96;
  }
  BOOL v102 = v28 <= v95 && v95 < v100;
  CFIndex v103 = v95;
  if (v102 || v95 <= v28 && (CFIndex v103 = v28, v28 < v99))
  {
    if (v101 != v103)
    {
      uint64_t v146 = v81;
      uint64_t v80 = v156;
      uint64_t v159 = v156;
      goto LABEL_156;
    }
  }
  uint64_t v173 = v84;
  CFIndex v104 = v83;
  uint64_t v105 = TCharStream::GetClusterRangeForRange(v149, v95, v96, v148);
  uint64_t v107 = v105;
  CFIndex v108 = v105 + v106;
  if (v105 + v106 >= v100) {
    CFIndex v109 = v171 + v28;
  }
  else {
    CFIndex v109 = v105 + v106;
  }
  if ((v28 <= v105 && (uint64_t v110 = v105, v105 < v100) || v105 <= v28 && (uint64_t v110 = v28, v28 < v108)) && v109 != v110
    || objc_msgSend(v169, "countOfIndexesInRange:", v28, v171, v142) != v171)
  {
    if (v107 < v28) {
      CFIndex v28 = v107;
    }
    if (v100 <= v108) {
      CFIndex v111 = v108;
    }
    else {
      CFIndex v111 = v100;
    }
    CFIndex v171 = v111 - v28;
    uint64_t v146 = v81;
    uint64_t v80 = v156;
    uint64_t v159 = v156;
    CFIndex v83 = v104;
    uint64_t v84 = v173;
    goto LABEL_156;
  }
LABEL_163:
  if (a7)
  {
    *a7 = v173;
    a7[1] = v174;
  }
  if (v142) {
    int *v142 = v145;
  }
  if (a8)
  {
    uint64_t v115 = *(void **)(v159 + 216);
    uint64_t v116 = v115[4];
    if (v116 || (uint64_t v120 = v115[3]) == 0)
    {
      int v117 = 0;
      uint64_t v118 = *(void *)(v159 + 200);
      uint64_t v119 = v116 + 16 * v118;
    }
    else
    {
      uint64_t v118 = *(void *)(v159 + 200);
      uint64_t v119 = v120 + 8 * v118;
      int v117 = 1;
    }
    if ((*(_WORD *)(v159 + 178) & 0x40) == 0 && (*(_DWORD *)(v115[5] + 4 * v118 + 4 * v146) & 0x1446) == 0)
    {
      uint64_t v124 = *(void *)(v115[6] + 8 * v118 + 8 * v146);
      uint64_t v125 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v149 + 40))(v149, v124, 2);
      uint64_t v126 = *((void *)v170 + 9);
      if (v126 < v125 + v127 && v125 <= v126) {
        uint64_t v129 = *((void *)v170 + 9);
      }
      else {
        uint64_t v129 = 0;
      }
      if (v126 <= v125 && v125 < *((void *)v170 + 10) + v126) {
        uint64_t v131 = v125;
      }
      else {
        uint64_t v131 = v129;
      }
      if (v131 == v124
        && !atomic_load_explicit((atomic_ullong *volatile)(*(void *)(atomic_load_explicit((atomic_ullong *volatile)(v159 + 56), memory_order_acquire)+ 40)+ 168), memory_order_acquire))
      {
        char v132 = 3;
        if (!v117) {
          char v132 = 4;
        }
        double v133 = *(double *)(v119 + (v146 << v132));
        uint64_t v134 = *(uint64_t **)(v159 + 232);
        double v135 = 0.0;
        if (v134)
        {
          unint64_t v136 = *(void *)(v159 + 200) + v146 - *(void *)(v159 + 248);
          uint64_t v137 = *v134;
          if (v136 < (*(void *)(*(void *)(v159 + 232) + 8) - v137) >> 3) {
            double v135 = *(double *)(v137 + 8 * v136);
          }
        }
        double v138 = v42 - (v133 - v135);
        uint64_t v139 = *(void *)(atomic_load_explicit((atomic_ullong *volatile)(v159 + 56), memory_order_acquire) + 40);
        __int16 v140 = *(_WORD *)(*(void *)(*(void *)(v159 + 216) + 16) + 2 * *(void *)(v159 + 200) + 2 * v146);
        uint64_t RenderingStyle = TAttributes::GetRenderingStyle((TAttributes *)(v159 + 40));
        v189[0] = v140;
        double v188 = NAN;
        TFont::GetUnsummedAdvancesForGlyphs(v139, (uint64_t)v189, &v188, 1, 1, 0, RenderingStyle);
        double v42 = v138 + v188;
      }
      else
      {
        double v188 = NAN;
        if (TAttributes::GetKernSetting((TAttributes *)(v159 + 40), &v188, 0))
        {
          double v42 = v42 - v188;
          if (v42 < 0.0) {
            double v42 = 0.0;
          }
        }
      }
    }
    if (_os_feature_enabled_impl())
    {
      if (v146 == *(void *)(v159 + 208) - 1)
      {
        double v121 = COERCE_DOUBLE(TStorageRange::GetOriginalFinalAdvanceWidth((TStorageRange *)(v159 + 192)));
        if (v122) {
          double v42 = v121;
        }
      }
    }
    *a8 = v42;
  }

  return v33;
}

CFIndex CharRangeForGlyphIndex(const TLine *a1, TCharStreamIterator *a2, const TStorageRange *a3, void *a4, uint64_t a5)
{
  CFIndex location = *(void *)(a4[6] + 8 * (void)a3 + 8 * a5);
  v14.CFIndex length = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v15 = location;
  v14.CFIndex location = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v8 = [a4 attachmentCountAtIndex:(char *)a3 + a5];
  if (v8)
  {
    CFIndex length = v8 + 1;
  }
  else
  {
    TCharStreamIterator::GetFullChar(a2, &v15, &v14);
    CFIndex location = v14.location;
    CFIndex length = v14.length;
  }
  CFIndex v10 = *((void *)a1 + 9);
  if (v10 > location || location >= *((void *)a1 + 10) + v10)
  {
    if (location <= v10 && v10 < location + length) {
      return *((void *)a1 + 9);
    }
    else {
      return 0;
    }
  }
  return location;
}

uint64_t TCharStream::GetClusterRangeForRange(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 40))(a1, a2, a4);
  if (v8 + v9 < a2 + a3)
  {
    uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 40))(a1, a2 + a3 - 1, a4);
    if (v10 < v8) {
      return v10;
    }
  }
  return v8;
}

uint64_t TTypesetter::SuggestClusterBreak(uint64_t a1, uint64_t a2, uint64_t a3, double a4, double a5)
{
  v25[4] = *MEMORY[0x1E4F143B8];
  Table = GetTable();
  double v12 = 0.0002;
  if (Table)
  {
    uint64_t v13 = (double *)*((void *)Table + 8);
    if (v13) {
      double v12 = *v13;
    }
  }
  if (v12 >= a4) {
    goto LABEL_9;
  }
  std::__function::__value_func<unsigned char ()(long)>::__value_func[abi:nn180100]((uint64_t)v25, a3);
  TTypesetter::FindGraphicalBreak((uint64_t *)a1, a2, (uint64_t)v25, (uint64_t)v22, a4, a5);
  char v14 = v22[0];
  CFIndex Chars = v23;
  double v16 = v24;
  std::__function::__value_func<unsigned char ()(long)>::~__value_func[abi:nn180100](v25);
  if ((v14 & 3) != 0) {
    return Chars;
  }
  v11.n128_f64[0] = v16 - a4;
  if (v16 - a4 <= v12) {
    CFIndex Chars = TTypesetter::DecomposeLastChars((const TLine **)a1, a2, Chars, a4);
  }
  if (!Chars) {
LABEL_9:
  }
    CFIndex Chars = *(void *)(a3 + 24) == 0;
  CFIndex v17 = Chars + a2;
  uint64_t v18 = (*(uint64_t (**)(void, CFIndex, uint64_t, __n128))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8), v17 - 1, 2, v11);
  if (v18 + v19 >= v17) {
    uint64_t v20 = v17 - 1;
  }
  else {
    uint64_t v20 = v18 + v19 - 1;
  }
  if (v18 + v19 > v17) {
    uint64_t v20 = v18 - 1;
  }
  if (v18 <= a2) {
    uint64_t v20 = v18 + v19 - 1;
  }
  return v20 - a2 + 1;
}

{
  uint64_t v8;
  uint64_t v10;
  long long v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  char v15;
  char v16;
  uint64_t v17;
  void v18[5];

  v18[4] = *MEMORY[0x1E4F143B8];
  uint64_t v10 = a1;
  __n128 v11 = *(_OWORD *)(a1 + 216);
  double v12 = *(void *)(a1 + 232);
  uint64_t v13 = a1 + 240;
  char v14 = *(_DWORD *)(a1 + 260);
  uint64_t v15 = *(unsigned char *)(a1 + 264);
  double v16 = *(unsigned char *)(a1 + 257);
  CFIndex v17 = 0;
  std::__function::__value_func<unsigned char ()(long)>::__value_func[abi:nn180100]((uint64_t)v18, a3);
  uint64_t v8 = TTypesetter::SuggestClusterBreak((uint64_t)&v10, a2, (uint64_t)v18, a4, a5);
  std::__function::__value_func<unsigned char ()(long)>::~__value_func[abi:nn180100](v18);
  return v8;
}

uint64_t TCharStream::GetRangeOfCharacterClusterAtIndex(const __CFString *a1, uint64_t a2, uint64_t a3)
{
  RangeOfCharacterClusterAtIndeCGFloat x = CFStringGetRangeOfCharacterClusterAtIndex();
  uint64_t v6 = RangeOfCharacterClusterAtIndex;
  int64_t v8 = v7;
  if (a3 <= 2 && (RangeOfCharacterClusterAtIndex & 0x8000000000000000) == 0)
  {
    CFIndex Length = CFStringGetLength(a1);
    *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v41[6] = v10;
    v41[7] = v10;
    void v41[4] = v10;
    v41[5] = v10;
    v41[2] = v10;
    v41[3] = v10;
    v41[0] = v10;
    v41[1] = v10;
    theCFStringRef String = a1;
    uint64_t v45 = 0;
    CFIndex v46 = Length;
    CharactersPtr = CFStringGetCharactersPtr(a1);
    CStringPtr = 0;
    uint64_t v43 = CharactersPtr;
    if (!CharactersPtr) {
      CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
    }
    int64_t v47 = 0;
    int64_t v48 = 0;
    CFIndex v44 = CStringPtr;
    int64_t v13 = v8 + v6;
    if (v8 + v6 >= 0 && v13 < Length)
    {
      while (1)
      {
        CFIndex v14 = v46;
        if (v46 <= v13) {
          return v6;
        }
        uint64_t v15 = v43;
        if (v43)
        {
          int64_t v16 = v45 + v13;
        }
        else
        {
          if (v44) {
            return v6;
          }
          int64_t v17 = v47;
          if (v48 <= v13 || v47 > v13)
          {
            int64_t v19 = v13 - 4;
            if ((unint64_t)v13 < 4) {
              int64_t v19 = 0;
            }
            if (v19 + 64 < v46) {
              CFIndex v14 = v19 + 64;
            }
            int64_t v47 = v19;
            int64_t v48 = v14;
            v49.CFIndex location = v45 + v19;
            v49.CFIndex length = v14 - v19;
            CFStringGetCharacters(theString, v49, (UniChar *)v41);
            int64_t v17 = v47;
          }
          int64_t v16 = v13 - v17;
          uint64_t v15 = (const UniChar *)v41;
        }
        if (v15[v16] != 8204) {
          return v6;
        }
        int64_t v20 = v8 + 1;
        int64_t v21 = v13 + 1;
        if (v13 + 1 >= Length) {
          return v6;
        }
        uint64_t v22 = CFStringGetRangeOfCharacterClusterAtIndex();
        uint64_t v24 = v23;
        CFIndex v25 = v46;
        if (v46 <= v21) {
          goto LABEL_41;
        }
        uint64_t v26 = v43;
        if (v43) {
          break;
        }
        if (!v44)
        {
          if (v48 <= v21 || (int64_t v36 = v47, v47 > v21))
          {
            int64_t v37 = v13 - 3;
            if ((unint64_t)v21 < 4) {
              int64_t v37 = 0;
            }
            if (v37 + 64 < v46) {
              CFIndex v25 = v37 + 64;
            }
            int64_t v47 = v37;
            int64_t v48 = v25;
            v50.CFIndex location = v45 + v37;
            v50.CFIndex length = v25 - v37;
            CFStringGetCharacters(theString, v50, (UniChar *)v41);
            int64_t v36 = v47;
          }
          int64_t v27 = v21 - v36;
          uint64_t v26 = (const UniChar *)v41;
          goto LABEL_26;
        }
        UniChar v28 = v44[v45 + v21];
LABEL_30:
        if ((v28 & 0xFC00) == 0xD800 && v24 >= 2)
        {
          int64_t v30 = v13 + 2;
          CFIndex v31 = v46;
          if (v46 <= v30) {
            return v6;
          }
          uint64_t v32 = v43;
          if (v43)
          {
            int64_t v33 = v45 + v30;
            goto LABEL_37;
          }
          if (v44)
          {
            UniChar v34 = v44[v45 + v30];
          }
          else
          {
            if (v48 <= v30 || (int64_t v38 = v47, v47 > v30))
            {
              int64_t v39 = v30 - 4;
              if ((unint64_t)v30 < 4) {
                int64_t v39 = 0;
              }
              if (v39 + 64 < v46) {
                CFIndex v31 = v39 + 64;
              }
              int64_t v47 = v39;
              int64_t v48 = v31;
              v51.CFIndex location = v45 + v39;
              v51.CFIndex length = v31 - v39;
              CFStringGetCharacters(theString, v51, (UniChar *)v41);
              int64_t v38 = v47;
            }
            int64_t v33 = v30 - v38;
            uint64_t v32 = (const UniChar *)v41;
LABEL_37:
            UniChar v34 = v32[v33];
          }
          if ((v34 & 0xFC00) != 0xDC00) {
            return v6;
          }
        }
LABEL_41:
        if (!CFUniCharIsMemberOf()) {
          return v6;
        }
        if (v22 >= v6) {
          uint64_t v35 = v6;
        }
        else {
          uint64_t v35 = v22;
        }
        if (v20 + v6 <= v22 + v24) {
          int64_t v13 = v22 + v24;
        }
        else {
          int64_t v13 = v20 + v6;
        }
        int64_t v8 = v13 - v35;
        if (v13 < Length)
        {
          uint64_t v6 = v35;
          if ((v13 & 0x8000000000000000) == 0) {
            continue;
          }
        }
        return v35;
      }
      int64_t v27 = v45 + v21;
LABEL_26:
      UniChar v28 = v26[v27];
      goto LABEL_30;
    }
    return v6;
  }
  return v6;
}

uint64_t TCharStreamCFString::GetClusterRangeAtIndex(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return TCharStream::GetRangeOfCharacterClusterAtIndex((const __CFString *)atomic_load_explicit((atomic_ullong *volatile)(a1 + 32), memory_order_acquire), a2, a3);
}

uint64_t TAttributes::GetRenderingStyle(TAttributes *this)
{
  if ((*((_WORD *)this + 69) & 0x80) == 0) {
    return 0;
  }
  unsigned int valuePtr = 5;
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)this, memory_order_acquire), @"CTRenderingStyle");
  if (Value)
  {
    CFNumberRef v3 = Value;
    CFTypeID v4 = CFGetTypeID(Value);
    if (v4 == CFNumberGetTypeID() || v4 == CFBooleanGetTypeID())
    {
      CFNumberGetValue(v3, kCFNumberIntType, &valuePtr);
    }
    else if (v4 == CFStringGetTypeID())
    {
      unsigned int valuePtr = CFStringGetIntValue((CFStringRef)v3);
    }
  }
  return valuePtr | 0x100000000;
}

void TTypesetter::FindGraphicalBreak(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>, double a5@<D0>, double a6@<D1>)
{
  uint64_t v6 = a4;
  uint64_t v109 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *a1;
  if (*(void *)(*a1 + 80) + *(void *)(*a1 + 72) <= a2)
  {
    *(unsigned char *)a4 = 1;
    *(void *)(a4 + 8) = 0;
    *(void *)(a4 + 16) = 0;
    return;
  }
  uint64_t v11 = a2;
  std::__function::__value_func<unsigned char ()(long)>::__value_func[abi:nn180100]((uint64_t)v82, a3);
  TLine::FindWidthOverflow(v7, v11, 0, (uint64_t)v82, (uint64_t)&v100, a5);
  char v13 = v100;
  CFIndex v14 = *((void *)&v100 + 1);
  double v15 = *(double *)&v101;
  std::__function::__value_func<unsigned char ()(long)>::~__value_func[abi:nn180100](v82);
  char v16 = v13 & 0x20;
  if ((v13 & 0x5C) == 0) {
    goto LABEL_67;
  }
  int64_t v17 = (const TLine *)*a1;
  long long v63 = xmmword_184B88A60;
  int v76 = unk_184B88A7C;
  long long v61 = unk_184B88A90;
  memset(v62, 170, sizeof(v62));
  long long v78 = unk_184B88A90;
  memset(v60, 170, sizeof(v60));
  long long v58 = unk_184B88A50;
  long long v59 = xmmword_184B88A40;
  memset(v57, 170, sizeof(v57));
  memset(&v69[8], 170, 24);
  *(void *)uint64_t v69 = 0;
  memset(v68, 0, sizeof(v68));
  uint64_t v70 = &v69[8];
  BYTE8(v78) = 0;
  uint64_t v74 = 0;
  long long v71 = 0u;
  long long v72 = 0u;
  long long v73 = 0u;
  memset(&v75[8], 0, 20);
  LOBYTE(v78) = 0;
  uint64_t v81 = 0;
  uint64_t v79 = 0;
  uint64_t v80 = 0;
  long long v77 = 0uLL;
  *(void *)uint64_t v75 = 0xFFEFFFFFFFFFFFFFLL;
  if ((v13 & 8) != 0)
  {
    v110.CFIndex length = *((void *)v17 + 10) - v11;
    v110.CFIndex location = v11;
    TLine::CopyStringRange((TLine *)v68, v17, v110);
    TTypesetter::ReorderRunsIfNecessary((uint64_t)a1, (uint64_t)v68);
    if (TLine::UpdateWidth((atomic_ullong *)v68, a6) != 0.0)
    {
      std::__function::__value_func<unsigned char ()(long)>::__value_func[abi:nn180100]((uint64_t)v67, a3);
      int64_t v17 = (const TLine *)v68;
      TLine::FindWidthOverflow((uint64_t)v68, v11, 0, (uint64_t)v67, (uint64_t)&v100, a5);
      char v13 = v100;
      CFIndex v14 = *((void *)&v100 + 1);
      double v15 = *(double *)&v101;
      std::__function::__value_func<unsigned char ()(long)>::~__value_func[abi:nn180100](v67);
    }
  }
  if ((v13 & 0x54) == 0) {
    goto LABEL_66;
  }
  uint64_t v51 = v6;
  char v50 = v16;
  uint64_t v56 = v17;
  if ((v13 & 0x10) != 0)
  {
    CFIndex v21 = v14;
    if (v14 >= 1)
    {
      uint64_t v55 = *((void *)v56 + 9);
      uint64_t v54 = *((void *)v56 + 10);
      uint64_t v22 = 0x7FFFFFFFFFFFFFFFLL;
      CFIndex v23 = v14;
      while (1)
      {
        long long v107 = v61;
        *(_DWORD *)&v105[28] = HIDWORD(v62[1]);
        *((void *)&v102 + 1) = *((void *)&v57[1] + 1);
        long long v103 = v57[0];
        *(void *)&long long v102 = 0;
        long long v100 = 0u;
        long long v101 = 0u;
        *(void *)CFIndex v104 = (char *)&v102 + 8;
        BYTE8(v107) = 0;
        memset(&v105[8], 0, 20);
        memset(&v104[8], 0, 56);
        long long v106 = 0uLL;
        LOBYTE(v107) = 0;
        memset(v108, 0, sizeof(v108));
        *(void *)uint64_t v105 = 0xFFEFFFFFFFFFFFFFLL;
        v112.CFIndex location = v11;
        v112.CFIndex length = v23;
        TLine::CopyStringRange((TLine *)&v100, v56, v112);
        TTypesetter::MakeLineConsistent((uint64_t)a1, (TLine *)&v100);
        if ((v105[24] & 2) != 0)
        {
          TTypesetter::ReorderRunsIfNecessary((uint64_t)a1, (uint64_t)&v100);
          uint64_t v24 = a1[1];
          *(void *)&long long v65 = &v100;
          *((void *)&v65 + 1) = v24;
          unint64_t v96 = 0xAAAAAAAAAAAAAAAALL;
          double v97 = NAN;
          *(double *)&unint64_t v98 = -3.72066208e-103;
          TTabEngine::ApplyTabs((TLine **)&v65, a6, a5, v25, (uint64_t)&v96);
          if ((_BYTE)v98)
          {
            uint64_t v26 = (unint64_t *)a1[6];
            if (v26) {
              break;
            }
          }
        }
        *(void *)&long long v85 = 0;
        uint64_t v27 = v11;
        TLine::FindWidthOverflow((uint64_t)&v100, v11, 1, (uint64_t)&v83, (uint64_t)&v96, a5);
        char v13 = v96;
        double v28 = v97;
        double v15 = *(double *)&v98;
        std::__function::__value_func<unsigned char ()(long)>::~__value_func[abi:nn180100](&v83);
        if ((v13 & 2) != 0) {
          goto LABEL_35;
        }
        CFIndex v21 = *(void *)&v28;
        if ((v13 & 1) != 0 || *(uint64_t *)&v28 >= v22)
        {
          if (*(void *)&v28 + v27 < v54 + v55) {
            v13 &= ~1u;
          }
          goto LABEL_35;
        }
        TLine::GetTrailingWhitespace((uint64_t)&v100, (double *)&v96);
        if ((uint64_t)(v96 + *(void *)&v28) >= v23)
        {
          char v13 = 1;
          double v15 = *(double *)&v104[40];
          double v28 = *(double *)&v23;
LABEL_35:
          TLine::~TLine((TLine *)&v100);
          CFIndex v21 = *(void *)&v28;
          uint64_t v11 = v27;
          goto LABEL_36;
        }
        if ((v13 & 0x10) == 0) {
          goto LABEL_35;
        }
        v23 += ~v96;
        TLine::~TLine((TLine *)&v100);
        uint64_t v22 = *(void *)&v28;
        uint64_t v11 = v27;
        if (v23 <= 0) {
          goto LABEL_36;
        }
      }
      *uint64_t v26 = v96;
      CFIndex v21 = v96 - v11;
      double v15 = v97 - a6;
      TLine::~TLine((TLine *)&v100);
      char v13 = 5;
    }
LABEL_36:
    unint64_t v52 = v21;
    uint64_t v6 = v51;
    int64_t v17 = v56;
    if ((v13 & 0x40) == 0)
    {
LABEL_30:
      CFIndex v14 = v52;
      goto LABEL_66;
    }
  }
  else
  {
    unint64_t v52 = v14;
    if ((v13 & 4) != 0)
    {
      *(_DWORD *)&v105[28] = HIDWORD(v62[1]);
      long long v107 = v61;
      *((void *)&v102 + 1) = *((void *)&v57[1] + 1);
      long long v103 = v57[0];
      *(void *)&long long v102 = 0;
      long long v100 = 0u;
      long long v101 = 0u;
      *(void *)CFIndex v104 = (char *)&v102 + 8;
      BYTE8(v107) = 0;
      memset(&v104[8], 0, 56);
      memset(&v105[8], 0, 20);
      LOBYTE(v107) = 0;
      memset(v108, 0, sizeof(v108));
      long long v106 = 0uLL;
      *(void *)uint64_t v105 = 0xFFEFFFFFFFFFFFFFLL;
      v111.CFIndex location = v11;
      v111.CFIndex length = v14;
      TLine::CopyStringRange((TLine *)&v100, v17, v111);
      TTypesetter::MakeLineConsistent((uint64_t)a1, (TLine *)&v100);
      TTypesetter::ReorderRunsIfNecessary((uint64_t)a1, (uint64_t)&v100);
      uint64_t v18 = a1[1];
      v64[0] = (uint64_t)&v100;
      v64[1] = v18;
      unint64_t v96 = 0xAAAAAAAAAAAAAAAALL;
      double v97 = NAN;
      *(double *)&unint64_t v98 = -3.72066208e-103;
      TTabEngine::ApplyTabs((TLine **)v64, a6, a5, v19, (uint64_t)&v96);
      if ((_BYTE)v98 && (int64_t v20 = (unint64_t *)a1[6]) != 0)
      {
        unint64_t *v20 = v96;
        unint64_t v52 = v96 - v11;
        double v15 = v97 - a6;
        char v13 = 5;
      }
      else
      {
        *(void *)&long long v85 = 0;
        TLine::FindWidthOverflow((uint64_t)&v100, v11, 1, (uint64_t)&v83, (uint64_t)&v65, a5);
        char v13 = v65;
        unint64_t v29 = *((void *)&v65 + 1);
        double v15 = v66;
        std::__function::__value_func<unsigned char ()(long)>::~__value_func[abi:nn180100](&v83);
        unint64_t v52 = v29;
        if ((v13 & 1) != 0 && (int64_t)(v29 + v11) < *((void *)v17 + 10) + *((void *)v17 + 9)) {
          v13 &= ~1u;
        }
      }
      TLine::~TLine((TLine *)&v100);
    }
    if ((v13 & 0x40) == 0) {
      goto LABEL_30;
    }
  }
  uint64_t v30 = 0;
  CFIndex v53 = *((void *)v17 + 9);
  CFIndex v31 = *((void *)v17 + 10) + v53;
  char v32 = v13 & 0xFE;
  if ((uint64_t)(v52 + v11) >= v31) {
    char v32 = v13;
  }
  char v49 = v32;
  double v33 = 0.0;
  char v13 = 0;
  while (1)
  {
    long long v102 = v57[1];
    long long v103 = v57[0];
    *(_OWORD *)&v104[32] = v59;
    *(_OWORD *)&v104[48] = v58;
    *(_OWORD *)CFIndex v104 = v60[1];
    *(_OWORD *)&v104[16] = v60[0];
    long long v107 = v61;
    memset(v108, 170, sizeof(v108));
    *(_OWORD *)uint64_t v105 = v63;
    *(_OWORD *)&v105[16] = v62[1];
    long long v106 = v62[0];
    long long v100 = v57[3];
    long long v101 = v57[2];
    uint64_t v35 = *(void *)*a1;
    uint64_t v34 = *(void *)(*a1 + 8);
    if (v34) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v34 + 8), 1uLL, memory_order_relaxed);
    }
    *(void *)&long long v100 = v35;
    *((void *)&v100 + 1) = v34;
    *(void *)&long long v102 = 0;
    long long v101 = 0uLL;
    BYTE8(v107) = 0;
    memset(&v105[8], 0, 21);
    memset(&v104[8], 0, 56);
    long long v106 = 0uLL;
    LOBYTE(v107) = 0;
    memset(v108, 0, sizeof(v108));
    *(void *)CFIndex v104 = (char *)&v102 + 8;
    *(void *)uint64_t v105 = 0xFFEFFFFFFFFFFFFFLL;
    v113.CFIndex location = v11;
    v113.CFIndex length = v14;
    TLine::CopyStringRange((TLine *)&v100, v56, v113);
    TTypesetter::MakeLineConsistent((uint64_t)a1, (TLine *)&v100);
    if ((v105[26] & 4) == 0)
    {
      if (!v30)
      {
        uint64_t v30 = v52;
        double v33 = v15;
      }
      goto LABEL_64;
    }
    char v36 = v105[24];
    if ((v105[24] & 2) != 0) {
      break;
    }
LABEL_47:
    if ((v36 & 8) != 0)
    {
      TLine::GetLeftPartialHangingGlyphCountAndWidth((TLine *)&v100, 0);
      double v41 = v43;
      TLine::GetRightHangersGlyphCountAndWidth((TLine *)&v100, 0);
    }
    else
    {
      TLine::GetLeftHangersGlyphCountAndWidth((TLine *)&v100, 0);
      double v41 = v40;
      TLine::GetRightPartialHangingGlyphCountAndWidth((TLine *)&v100, 0);
    }
    double v44 = v42 + v41;
    long long v65 = xmmword_184B88AB8;
    double v66 = NAN;
    uint64_t v99 = 0;
    TLine::FindWidthOverflow((uint64_t)&v100, v11, 1, (uint64_t)&v96, (uint64_t)&v65, v42 + v41 + a5);
    std::__function::__value_func<unsigned char ()(long)>::~__value_func[abi:nn180100](&v96);
    double v45 = v66 - v44;
    double v66 = v66 - v44;
    char v46 = v65;
    if ((v65 & 2) != 0)
    {
      uint64_t v30 = *((void *)&v65 + 1);
      double v33 = v45;
      char v13 = v65;
LABEL_64:
      TLine::~TLine((TLine *)&v100);
      goto LABEL_65;
    }
    if (v65)
    {
      char v46 = v49;
      LOBYTE(v65) = v49;
    }
    if (*((uint64_t *)&v65 + 1) > v30)
    {
      char v13 = v46;
      uint64_t v30 = *((void *)&v65 + 1);
      double v33 = v45;
    }
    if (*((uint64_t *)&v65 + 1) < v14) {
      goto LABEL_64;
    }
    v64[0] = v14;
    if (v53 > v14 || v31 <= v14) {
      goto LABEL_64;
    }
    unint64_t v47 = a1[1];
    long long v84 = 0u;
    long long v85 = 0u;
    long long v86 = 0u;
    long long v87 = 0u;
    long long v88 = 0u;
    long long v89 = 0u;
    long long v90 = 0u;
    long long v91 = 0u;
    long long v92 = 0u;
    long long v93 = 0u;
    uint64_t v95 = 0;
    long long v94 = 0u;
    uint64_t v48 = *(void *)(v47 + 16);
    unint64_t v83 = v47;
    *(void *)&long long v94 = v48;
    TCharStreamIterator::GetFullChar((TCharStreamIterator *)&v83, v64, 0);
    CFIndex v14 = v64[0] + 1;
    TLine::~TLine((TLine *)&v100);
    if (v14 + v11 > v31) {
      goto LABEL_65;
    }
  }
  TTypesetter::ReorderRunsIfNecessary((uint64_t)a1, (uint64_t)&v100);
  uint64_t v37 = a1[1];
  *(void *)&long long v65 = &v100;
  *((void *)&v65 + 1) = v37;
  unint64_t v83 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v84 = -1;
  *((void *)&v84 + 1) = 0xAAAAAAAAAAAAAAAALL;
  TTabEngine::ApplyTabs((TLine **)&v65, a6, a5, v38, (uint64_t)&v83);
  if (!BYTE8(v84) || (int64_t v39 = (unint64_t *)a1[6]) == 0)
  {
    char v36 = v105[24];
    goto LABEL_47;
  }
  *int64_t v39 = v83;
  uint64_t v30 = v83 - v11;
  double v33 = *(double *)&v84 - a6;
  TLine::~TLine((TLine *)&v100);
  char v13 = 5;
LABEL_65:
  CFIndex v14 = v30;
  double v15 = v33;
  uint64_t v6 = v51;
  char v16 = v50;
LABEL_66:
  TLine::~TLine((TLine *)v68);
LABEL_67:
  *(unsigned char *)uint64_t v6 = v13 | v16;
  *(void *)(v6 + 8) = v14;
  *(double *)(v6 + 16) = v15;
}

uint64_t std::__function::__value_func<unsigned char ()(long)>::__value_func[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t CTLineSuggestClusterBreakWithTabOverflow(uint64_t result, const TLine *a2, uint64_t *a3, uint64_t *a4, double a5, double a6)
{
  if (result)
  {
    uint64_t v7 = *(TTypesetter **)(result + 40);
    uint64_t v8 = -1;
    CGFloat result = TTypesetter::SuggestClusterBreak(v7, a2, (uint64_t)&v8, a5, a6, a4);
    if (a3) {
      *a3 = v8;
    }
  }
  return result;
}

uint64_t TTypesetter::SuggestClusterBreak(TTypesetter *this, const TLine *a2, uint64_t a3, double a4, double a5, uint64_t *a6)
{
  v11[4] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)this;
  v9[0] = this;
  v9[1] = v6;
  v9[2] = 0;
  id v9[3] = 0;
  v10[0] = 0;
  *(void *)((char *)v10 + 6) = 0;
  void v10[2] = a3;
  v11[3] = 0;
  uint64_t v7 = TTypesetter::SuggestClusterBreak((uint64_t)v9, (uint64_t)a2, (uint64_t)v11, a4, a5);
  std::__function::__value_func<unsigned char ()(long)>::~__value_func[abi:nn180100](v11);
  return v7;
}

void *std::__function::__value_func<unsigned char ()(long)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t TLine::FindWidthOverflow@<X0>(uint64_t this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>, double a6@<D0>)
{
  uint64_t v7 = (void *)this;
  uint64_t v10 = *(void *)(this + 16);
  uint64_t v9 = *(void *)(this + 24);
  uint64_t v11 = v9 - v10;
  if (v9 == v10 || (this = TLine::FindRunWithCharIndex((TLine *)this, a2, 1), this < 0) || v11 >> 3 <= this)
  {
    uint64_t v16 = v7[9] - a2 + v7[10];
    double v18 = 0.0;
    char v19 = 1;
    goto LABEL_25;
  }
  double v15 = *(void **)(*(void *)(v7[2] + 8 * this) + 40);
  this = (uint64_t)(*(void *(**)(uint64_t *__return_ptr, void *, uint64_t, void, uint64_t, double))(*v15 + 48))(&v26, v15, a2, *v7, a3, a6);
  uint64_t v16 = v27;
  double v17 = v28;
  double v18 = v28 + 0.0;
  char v19 = (16 * *((unsigned char *)v7 + 154)) & 0x40 | v26;
  if ((v26 & 2) == 0)
  {
    if (v27 >= 1)
    {
      uint64_t v20 = v15[1];
      if (v20 <= v27 + a2 && v15[2] + v20 > v27 + a2) {
        goto LABEL_25;
      }
      do
      {
        a6 = a6 - v17;
        if (a6 <= 0.0) {
          break;
        }
        double v15 = (void *)v15[3];
        if (!v15) {
          break;
        }
        uint64_t v22 = v15[1];
        uint64_t v23 = v15[2];
        uint64_t v24 = *(void *)(a4 + 24);
        if (v24)
        {
          uint64_t v26 = v15[1];
          this = (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v24 + 48))(v24, &v26);
          if (this)
          {
            v19 |= this;
            goto LABEL_25;
          }
        }
        this = (uint64_t)(*(void *(**)(uint64_t *__return_ptr, void *, uint64_t, void, uint64_t, double))(*v15 + 48))(&v26, v15, v22, *v7, a3, a6);
        double v17 = v28;
        v19 |= v26;
        if (v22 - a2 + v27 > v16) {
          uint64_t v16 = v22 - a2 + v27;
        }
        double v18 = v18 + v28;
        if ((v19 & 2) != 0) {
          goto LABEL_25;
        }
      }
      while (v27 >= v23 && v27 != 0);
    }
    v19 |= v7[9] - a2 + v7[10] == v16;
  }
LABEL_25:
  *(unsigned char *)a5 = v19;
  *(void *)(a5 + 8) = v16;
  *(double *)(a5 + 16) = v18;
  return this;
}

CFIndex TTypesetter::DecomposeLastChars(const TLine **a1, CFIndex a2, CFIndex a3, double a4)
{
  CFIndex v4 = a3;
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a2 + a3;
  if (a2 + a3 >= *((void *)a1[1] + 2) - 1) {
    return v4;
  }
  uint64_t v9 = *(TRun **)(*(void *)(*((void *)*a1 + 2) + 8 * TLine::FindRunWithCharIndex(*a1, a2 + a3, 1)) + 40);
  *(void *)&v30[0] = TRun::GetGlyphIndexForCharIndex<false>((uint64_t)v9, v5);
  Nextuint64_t Char = TRun::GetNextChar(v9, v5, (uint64_t *)v30);
  uint64_t v11 = *((void *)a1[1] + 2);
  if (NextChar > v11) {
    return v4;
  }
  uint64_t v16 = a1[1];
  long long v27 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  uint64_t v14 = NextChar - v5;
  uint64_t v28 = 0;
  *(void *)&long long v27 = v11;
  do
  {
    CFIndex v12 = v4;
    if (--v14 < 1) {
      break;
    }
    long long v40 = unk_184B88A90;
    memset(v39, 170, sizeof(v39));
    memset(v32, 170, sizeof(v32));
    memset(v30, 0, sizeof(v30));
    uint64_t v31 = 0;
    double v33 = v32;
    BYTE8(v40) = 0;
    uint64_t v37 = 0;
    memset(v39, 0, 21);
    long long v35 = 0u;
    long long v36 = 0u;
    long long v34 = 0u;
    v39[3] = 0;
    v39[4] = 0;
    LOBYTE(v40) = 0;
    uint64_t v42 = 0;
    uint64_t v43 = 0;
    uint64_t v41 = 0;
    unint64_t v38 = 0xFFEFFFFFFFFFFFFFLL;
    uint64_t v29 = v4 + a2;
    TCharStreamIterator::GetFullChar((TCharStreamIterator *)&v16, &v29, 0);
    CFIndex v4 = v29 - a2 + 1;
    v45.CFIndex location = a2;
    v45.CFIndex length = v4;
    TTypesetter::FillLine(a1, (TLine *)v30, v45, a4, 0.0);
    double v15 = *(double *)&v36;
    TLine::~TLine((TLine *)v30);
  }
  while (v15 <= a4);
  return v12;
}

void std::vector<std::pair<CFRange,double>,TInlineBufferAllocator<std::pair<CFRange,double>,30ul>>::__destroy_vector::operator()[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  if (v2)
  {
    *(void *)(a1 + 8) = v2;
    uint64_t v3 = (void *)(a1 + 744);
    if (a1 + 24 <= (unint64_t)v2)
    {
      BOOL v4 = v3 >= v2;
      BOOL v5 = v3 == v2;
    }
    else
    {
      BOOL v4 = 0;
      BOOL v5 = 0;
    }
    if (!v5 && v4)
    {
      if (*(void *)(a1 + 16) == *(void *)(a1 + 744)) {
        *uint64_t v3 = v2;
      }
    }
    else
    {
      operator delete(v2);
    }
  }
}

void TRun::TruncateStorageRange(TRun *this, CFRange a2)
{
  CFIndex location = a2.location;
  TStorageRange::SetStorageSubRange((TRun *)((char *)this + 192), a2);
  if (location)
  {
    BOOL v4 = (_OWORD *)*((void *)this + 39);
    if (v4) {
      _OWORD *v4 = *MEMORY[0x1E4F1DB30];
    }
  }
  uint64_t v5 = *((void *)this + 39);
  if (v5)
  {
    if (*(void *)(v5 + 56) != *(void *)(v5 + 64) && location >= 1)
    {
      TRun::InitStretchFactors(this);
      uint64_t v7 = *((void *)this + 39);
      uint64_t v9 = *(void *)(v7 + 56);
      uint64_t v8 = *(unsigned char **)(v7 + 64);
      uint64_t v10 = (unsigned char *)(v9 + 16 * location);
      int64_t v11 = v8 - v10;
      if (v8 != v10) {
        memmove(*(void **)(v7 + 56), v10, v8 - v10);
      }
      *(void *)(v7 + 64) = v9 + v11;
    }
  }
}

uint64_t TRun::IsRangeMonotonic(TRun *this, CFRange a2)
{
  if (*((int *)this + 64) < 2) {
    return 1;
  }
  CFIndex length = a2.length;
  CFIndex location = a2.location;
  GlyphIndexForuint64_t Char = TRun::GetGlyphIndexForCharIndex<false>((uint64_t)this, a2.location);
  uint64_t v6 = TRun::GetGlyphIndexForCharIndex<false>((uint64_t)this, length + location - 1);
  uint64_t v7 = GlyphIndexForChar >= v6 ? v6 : GlyphIndexForChar;
  uint64_t v8 = GlyphIndexForChar <= v6 ? v6 : GlyphIndexForChar;
  uint64_t v9 = v8 + 1;
  if (v7 == v8 + 1) {
    return 1;
  }
  char v10 = *((unsigned char *)this + 224);
  uint64_t v11 = *(void *)(*((void *)this + 27) + 48) + 8 * *((void *)this + 25);
  while (location == *(void *)(v11 + 8 * v7))
  {
    CFIndex v12 = (void *)*((void *)this + 27);
    uint64_t v13 = *((void *)this + 25);
    if ((*(_DWORD *)(v12[5] + 4 * v13 + 4 * v7) & 0x380) != 0) {
      break;
    }
    uint64_t v14 = [v12 attachmentCountAtIndex:v7 + v13];
    uint64_t v15 = ~v14;
    if ((v10 & 1) == 0) {
      uint64_t v15 = v14 + 1;
    }
    location += v15;
    if (v9 == ++v7) {
      return 1;
    }
  }
  return 0;
}

uint64_t TDelegateRun::FindBreak@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, const TCharStream *a3@<X2>, int a4@<W3>, uint64_t a5@<X8>, double a6@<D0>)
{
  *(_OWORD *)a5 = xmmword_184BA8BD0;
  *(void *)(a5 + 16) = -1;
  uint64_t result = TRun::FindBreak(a1, a2, a3, a4, a5, a6);
  *(unsigned char *)a5 |= 8u;
  return result;
}

void TLine::EnumerateCaretOffsets(std::function<void ()(double,long,BOOL,BOOL *)>)const::$_0::operator()(uint64_t a1, unint64_t a2, int a3, __n128 a4)
{
  uint64_t v5 = *(double **)a1;
  BOOL v4 = *(void **)(a1 + 8);
  if (a3 < 0)
  {
    uint64_t v6 = &v5[2 * a2];
    uint64_t v7 = &v5[2 * *v4 - 2];
    if (*v4 != a2 && v7 > v6)
    {
      unint64_t v9 = (unint64_t)(v6 + 2);
      do
      {
        a4 = *(__n128 *)(v9 - 16);
        *(_OWORD *)(v9 - 16) = *(_OWORD *)v7;
        *(__n128 *)uint64_t v7 = a4;
        v7 -= 2;
        BOOL v10 = v9 >= (unint64_t)v7;
        v9 += 16;
      }
      while (!v10);
      uint64_t v5 = *(double **)a1;
      BOOL v4 = *(void **)(a1 + 8);
    }
  }
  uint64_t v11 = a2 >> 1;
  CFIndex v12 = &v5[4 * (a2 >> 1)];
  uint64_t v13 = &v5[4 * (*v4 >> 1)];
  if ((char *)v13 - (char *)v12 <= 4096)
  {
    std::__stable_sort<std::_ClassicAlgPolicy,std::__less<void,void> &,TLine::EnumerateCaretOffsets(std::function<void ()(double,long,BOOL,BOOL *)>)::$_0::operator() const(unsigned long,int)::CaretPair *>((uint64_t)&v5[4 * (a2 >> 1)], &v5[4 * (*v4 >> 1)], ((char *)v13 - (char *)v12) >> 5, 0, 0, a4);
  }
  else
  {
    uint64_t v14 = std::get_temporary_buffer[abi:nn180100]<TLine::EnumerateCaretOffsets(std::function<void ()(double,long,BOOL,BOOL *)>)::$_0::operator() const(unsigned long,int)::CaretPair>(((char *)v13 - (char *)v12) >> 5);
    std::__stable_sort<std::_ClassicAlgPolicy,std::__less<void,void> &,TLine::EnumerateCaretOffsets(std::function<void ()(double,long,BOOL,BOOL *)>)::$_0::operator() const(unsigned long,int)::CaretPair *>((uint64_t)v12, v13, ((char *)v13 - (char *)v12) >> 5, (uint64_t)v14, v15, v16);
    if (v14) {
      operator delete(v14);
    }
  }
  if (((char *)v13 - (char *)v12) >> 5 >= v11) {
    uint64_t v17 = v11;
  }
  else {
    uint64_t v17 = ((char *)v13 - (char *)v12) >> 5;
  }
  long long v18 = (double *)std::get_temporary_buffer[abi:nn180100]<TLine::EnumerateCaretOffsets(std::function<void ()(double,long,BOOL,BOOL *)>)::$_0::operator() const(unsigned long,int)::CaretPair>(v17);
  std::__inplace_merge<std::_ClassicAlgPolicy,std::__less<void,void> &,TLine::EnumerateCaretOffsets(std::function<void ()(double,long,BOOL,BOOL *)>)::$_0::operator() const(unsigned long,int)::CaretPair *>(v5, v12, v13, v11, ((char *)v13 - (char *)v12) >> 5, v18, v19);
  if (v18)
  {
    operator delete(v18);
  }
}

void *std::get_temporary_buffer[abi:nn180100]<TLine::EnumerateCaretOffsets(std::function<void ()(double,long,BOOL,BOOL *)>)::$_0::operator() const(unsigned long,int)::CaretPair>(uint64_t a1)
{
  if (a1 < 1) {
    return 0;
  }
  if (a1 >= 0x3FFFFFFFFFFFFFFLL) {
    unint64_t v1 = 0x3FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v1 = a1;
  }
  uint64_t v2 = (const std::nothrow_t *)MEMORY[0x1E4FBA2D0];
  while (1)
  {
    uint64_t result = operator new(32 * v1, v2);
    if (result) {
      break;
    }
    BOOL v4 = v1 > 1;
    v1 >>= 1;
    if (!v4) {
      return 0;
    }
  }
  return result;
}

double *std::__inplace_merge<std::_ClassicAlgPolicy,std::__less<void,void> &,TLine::EnumerateCaretOffsets(std::function<void ()(double,long,BOOL,BOOL *)>)::$_0::operator() const(unsigned long,int)::CaretPair *>(double *result, double *a2, double *a3, uint64_t a4, uint64_t a5, double *a6, uint64_t a7)
{
  if (a5)
  {
    uint64_t v8 = a5;
    while (a4 > a7 && v8 > a7)
    {
      if (!a4) {
        return result;
      }
      uint64_t v11 = 0;
      uint64_t v12 = -a4;
      while (*a2 >= result[v11])
      {
        v11 += 4;
        if (__CFADD__(v12++, 1)) {
          return result;
        }
      }
      uint64_t v14 = -v12;
      uint64_t v15 = &result[v11];
      if (-v12 >= v8)
      {
        if (v12 == -1)
        {
          uint64_t v79 = &result[v11];
          long long v91 = *(_OWORD *)v79;
          long long v96 = *((_OWORD *)v79 + 1);
          long long v80 = *((_OWORD *)a2 + 1);
          *(_OWORD *)uint64_t v79 = *(_OWORD *)a2;
          *((_OWORD *)v79 + 1) = v80;
          *(_OWORD *)a2 = v91;
          *((_OWORD *)a2 + 1) = v96;
          return result;
        }
        if (v12 > 0) {
          uint64_t v14 = 1 - v12;
        }
        uint64_t v25 = v14 >> 1;
        uint64_t v19 = &result[4 * (v14 >> 1) + v11];
        long long v18 = a3;
        if (a3 != a2)
        {
          unint64_t v26 = ((char *)a3 - (char *)a2) >> 5;
          long long v18 = a2;
          do
          {
            unint64_t v27 = v26 >> 1;
            uint64_t v28 = &v18[4 * (v26 >> 1)];
            double v30 = *v28;
            uint64_t v29 = v28 + 4;
            v26 += ~(v26 >> 1);
            if (v30 >= *v19) {
              unint64_t v26 = v27;
            }
            else {
              long long v18 = v29;
            }
          }
          while (v26);
        }
        uint64_t v17 = ((char *)v18 - (char *)a2) >> 5;
      }
      else
      {
        if (v8 >= 0) {
          uint64_t v16 = v8;
        }
        else {
          uint64_t v16 = v8 + 1;
        }
        uint64_t v17 = v16 >> 1;
        long long v18 = &a2[4 * (v16 >> 1)];
        uint64_t v19 = a2;
        if (v15 != a2)
        {
          unint64_t v20 = ((char *)a2 - (char *)result - v11 * 8) >> 5;
          uint64_t v19 = &result[v11];
          do
          {
            unint64_t v21 = v20 >> 1;
            long long v22 = &v19[4 * (v20 >> 1)];
            double v24 = *v22;
            long long v23 = v22 + 4;
            v20 += ~(v20 >> 1);
            if (*v18 < v24) {
              unint64_t v20 = v21;
            }
            else {
              uint64_t v19 = v23;
            }
          }
          while (v20);
        }
        uint64_t v25 = ((char *)v19 - (char *)result - v11 * 8) >> 5;
      }
      uint64_t v31 = v18;
      if (v19 != a2)
      {
        uint64_t v31 = v19;
        if (a2 != v18)
        {
          if (v19 + 4 == a2)
          {
            long long v89 = *(_OWORD *)v19;
            long long v93 = *((_OWORD *)v19 + 1);
            int64_t v37 = (char *)v18 - (char *)a2;
            long long v84 = a6;
            long long v86 = v15;
            unint64_t v38 = a3;
            uint64_t v39 = v17;
            memmove(v19, a2, (char *)v18 - (char *)a2);
            uint64_t v17 = v39;
            a6 = v84;
            uint64_t v15 = v86;
            a3 = v38;
            uint64_t v31 = (double *)((char *)v19 + v37);
            *(_OWORD *)uint64_t v31 = v89;
            *((_OWORD *)v31 + 1) = v93;
          }
          else if (a2 + 4 == v18)
          {
            uint64_t v31 = v19 + 4;
            long long v90 = *((_OWORD *)v18 - 2);
            long long v94 = *((_OWORD *)v18 - 1);
            if (v18 - 4 != v19)
            {
              long long v85 = a6;
              long long v87 = v15;
              long long v40 = a3;
              uint64_t v41 = v17;
              memmove(v19 + 4, v19, (char *)(v18 - 4) - (char *)v19);
              uint64_t v17 = v41;
              a6 = v85;
              uint64_t v15 = v87;
              a3 = v40;
            }
            *(_OWORD *)uint64_t v19 = v90;
            *((_OWORD *)v19 + 1) = v94;
          }
          else
          {
            uint64_t v32 = ((char *)a2 - (char *)v19) >> 5;
            if (v32 == ((char *)v18 - (char *)a2) >> 5)
            {
              uint64_t v33 = 0;
              do
              {
                long long v34 = &a2[v33];
                long long v35 = &v19[v33];
                long long v88 = *(_OWORD *)&v19[v33];
                long long v92 = *(_OWORD *)&v19[v33 + 2];
                long long v36 = *(_OWORD *)&a2[v33 + 2];
                *(_OWORD *)long long v35 = *(_OWORD *)&a2[v33];
                *((_OWORD *)v35 + 1) = v36;
                *(_OWORD *)long long v34 = v88;
                *((_OWORD *)v34 + 1) = v92;
                if (&v19[v33 + 4] == a2) {
                  break;
                }
                v33 += 4;
              }
              while (v34 + 4 != v18);
              uint64_t v31 = a2;
            }
            else
            {
              uint64_t v42 = ((char *)v18 - (char *)a2) >> 5;
              uint64_t v43 = ((char *)a2 - (char *)v19) >> 5;
              do
              {
                uint64_t v44 = v43;
                uint64_t v43 = v42;
                uint64_t v42 = v44 % v42;
              }
              while (v42);
              if (v43)
              {
                CFRange v45 = &v19[4 * v43];
                do
                {
                  long long v46 = *((_OWORD *)v45 - 2);
                  long long v47 = *((_OWORD *)v45 - 1);
                  v45 -= 4;
                  long long v95 = v47;
                  uint64_t v48 = &v45[4 * v32];
                  char v49 = v45;
                  do
                  {
                    char v50 = v49;
                    char v49 = v48;
                    long long v51 = *((_OWORD *)v48 + 1);
                    *(_OWORD *)char v50 = *(_OWORD *)v48;
                    *((_OWORD *)v50 + 1) = v51;
                    BOOL v52 = __OFSUB__(v32, ((char *)v18 - (char *)v48) >> 5);
                    uint64_t v54 = v32 - (((char *)v18 - (char *)v48) >> 5);
                    char v53 = (v54 < 0) ^ v52;
                    uint64_t v48 = &v19[4 * v54];
                    if (v53) {
                      uint64_t v48 = &v49[4 * v32];
                    }
                  }
                  while (v48 != v45);
                  *(_OWORD *)char v49 = v46;
                  *((_OWORD *)v49 + 1) = v95;
                }
                while (v45 != v19);
              }
              uint64_t v31 = &v19[4 * (((char *)v18 - (char *)a2) >> 5)];
            }
          }
        }
      }
      a4 = -(v25 + v12);
      uint64_t v55 = v8 - v17;
      if (v17 + v25 >= v8 - (v17 + v25) - v12)
      {
        uint64_t v59 = -(v25 + v12);
        uint64_t v60 = v17;
        uint64_t v61 = v8 - v17;
        int v57 = a6;
        uint64_t v62 = v15;
        std::__inplace_merge<std::_ClassicAlgPolicy,std::__less<void,void> &,TLine::EnumerateCaretOffsets(std::function<void ()(double,long,BOOL,BOOL *)>)::$_0::operator() const(unsigned long,int)::CaretPair *>(v31, v18, a3, v59, v61, a6, a7);
        uint64_t result = v62;
        long long v18 = v19;
        uint64_t v55 = v60;
        a4 = v25;
        a3 = v31;
      }
      else
      {
        uint64_t v56 = v25;
        int v57 = a6;
        long long v58 = a3;
        std::__inplace_merge<std::_ClassicAlgPolicy,std::__less<void,void> &,TLine::EnumerateCaretOffsets(std::function<void ()(double,long,BOOL,BOOL *)>)::$_0::operator() const(unsigned long,int)::CaretPair *>(v15, v19, v31, v56, v17, a6, a7);
        a3 = v58;
        uint64_t result = v31;
      }
      uint64_t v8 = v55;
      a2 = v18;
      a6 = v57;
      if (!v55) {
        return result;
      }
    }
    if (a4 <= v8)
    {
      if (result != a2)
      {
        unint64_t v73 = 0;
        do
        {
          uint64_t v74 = &a6[v73];
          long long v75 = *(_OWORD *)&result[v73 + 2];
          *(_OWORD *)uint64_t v74 = *(_OWORD *)&result[v73];
          *((_OWORD *)v74 + 1) = v75;
          v73 += 4;
        }
        while (&result[v73] != a2);
        if (v73 * 8)
        {
          int v76 = a6;
          while (a2 != a3)
          {
            if (*a2 >= *v76)
            {
              long long v77 = *(_OWORD *)v76;
              long long v78 = *((_OWORD *)v76 + 1);
              v76 += 4;
            }
            else
            {
              long long v77 = *(_OWORD *)a2;
              long long v78 = *((_OWORD *)a2 + 1);
              a2 += 4;
            }
            *(_OWORD *)uint64_t result = v77;
            *((_OWORD *)result + 1) = v78;
            result += 4;
            if (&a6[v73] == v76) {
              return result;
            }
          }
          return (double *)memmove(result, v76, (char *)a6 - (char *)v76 + v73 * 8);
        }
      }
    }
    else if (a2 != a3)
    {
      unint64_t v63 = 0;
      do
      {
        CFIndex v64 = &a6[v63];
        long long v65 = *(_OWORD *)&a2[v63 + 2];
        *(_OWORD *)CFIndex v64 = *(_OWORD *)&a2[v63];
        *((_OWORD *)v64 + 1) = v65;
        v63 += 4;
      }
      while (&a2[v63] != a3);
      if (v63 * 8)
      {
        double v66 = &a6[v63];
        CFIndex v67 = a3 - 4;
        while (a2 != result)
        {
          double v68 = *(v66 - 4);
          double v69 = *(a2 - 4);
          BOOL v70 = v68 < v69;
          if (v68 >= v69) {
            long long v71 = v66 - 4;
          }
          else {
            long long v71 = a2 - 4;
          }
          if (v68 < v69) {
            a2 -= 4;
          }
          long long v72 = *((_OWORD *)v71 + 1);
          if (!v70) {
            v66 -= 4;
          }
          *(_OWORD *)CFIndex v67 = *(_OWORD *)v71;
          *((_OWORD *)v67 + 1) = v72;
          v67 -= 4;
          if (v66 == a6) {
            return result;
          }
        }
        unint64_t v81 = 0;
        do
        {
          uint64_t v82 = &v67[v81];
          long long v83 = *(_OWORD *)&v66[v81 - 2];
          *(_OWORD *)uint64_t v82 = *(_OWORD *)&v66[v81 - 4];
          *((_OWORD *)v82 + 1) = v83;
          v81 -= 4;
        }
        while (&v66[v81] != a6);
      }
    }
  }
  return result;
}

__n128 std::__stable_sort<std::_ClassicAlgPolicy,TLine::EnumerateCaretOffsets(std::function<void ()(double,long,BOOL,BOOL *)>)::$_2 &,TLine::CaretInfo *>(__n128 *a1, __n128 *a2, unint64_t a3, __n128 *a4, uint64_t a5, __n128 result)
{
  if (a3 >= 2)
  {
    uint64_t v7 = (double *)a1;
    if (a3 == 2)
    {
      uint64_t v8 = a2 - 1;
      result.n128_u64[0] = a2[-1].n128_u64[0];
      if (result.n128_f64[0] < a1->n128_f64[0])
      {
        uint64_t result = *a1;
        *a1 = *v8;
        *uint64_t v8 = result;
      }
    }
    else if ((uint64_t)a3 > 128)
    {
      uint64_t v19 = (double *)a4;
      unint64_t v20 = a3 >> 1;
      unint64_t v21 = &a1[a3 >> 1];
      unint64_t v22 = a3 >> 1;
      if ((uint64_t)a3 <= a5)
      {
        __n128 v23 = std::__stable_sort_move<std::_ClassicAlgPolicy,TLine::EnumerateCaretOffsets(std::function<void ()(double,long,BOOL,BOOL *)>)::$_2 &,TLine::CaretInfo *>(a1, v21, v22, a4, result);
        double v24 = (__n128 *)&v19[2 * v20];
        result.n128_u64[0] = std::__stable_sort_move<std::_ClassicAlgPolicy,TLine::EnumerateCaretOffsets(std::function<void ()(double,long,BOOL,BOOL *)>)::$_2 &,TLine::CaretInfo *>((__n128 *)&v7[2 * (a3 >> 1)], a2, a3 - (a3 >> 1), v24, v23).n128_u64[0];
        uint64_t v25 = &v19[2 * a3];
        unint64_t v26 = v24;
        while (v26 != (__n128 *)v25)
        {
          if (v26->n128_f64[0] >= *v19)
          {
            __n128 v28 = *(__n128 *)v19;
            v19 += 2;
            uint64_t result = v28;
          }
          else
          {
            __n128 v27 = *v26++;
            uint64_t result = v27;
          }
          *(__n128 *)uint64_t v7 = result;
          v7 += 2;
          if (v19 == (double *)v24)
          {
            if (v26 != (__n128 *)v25)
            {
              unint64_t v29 = 0;
              do
              {
                uint64_t result = v26[v29 / 0x10];
                *(__n128 *)&v7[v29 / 8] = result;
                v29 += 16;
              }
              while (&v26[v29 / 0x10] != (__n128 *)v25);
            }
            return result;
          }
        }
        if (v19 != (double *)v24)
        {
          uint64_t v30 = 0;
          do
          {
            uint64_t result = *(__n128 *)&v19[v30];
            *(__n128 *)&v7[v30] = result;
            v30 += 2;
          }
          while (&v19[v30] != (double *)v24);
        }
      }
      else
      {
        std::__stable_sort<std::_ClassicAlgPolicy,TLine::EnumerateCaretOffsets(std::function<void ()(double,long,BOOL,BOOL *)>)::$_2 &,TLine::CaretInfo *>(a1, v21, v22, a4, a5);
        std::__stable_sort<std::_ClassicAlgPolicy,TLine::EnumerateCaretOffsets(std::function<void ()(double,long,BOOL,BOOL *)>)::$_2 &,TLine::CaretInfo *>(&v7[2 * (a3 >> 1)], a2, a3 - (a3 >> 1), v19, a5);
        std::__inplace_merge<std::_ClassicAlgPolicy,TLine::EnumerateCaretOffsets(std::function<void ()(double,long,BOOL,BOOL *)>)::$_2 &,TLine::CaretInfo *>(v7, &v7[2 * (a3 >> 1)], a2->n128_f64, a3 >> 1, a3 - (a3 >> 1), v19, a5);
      }
    }
    else if (a1 != a2)
    {
      BOOL v10 = a1 + 1;
      if (&a1[1] != a2)
      {
        uint64_t v11 = 0;
        uint64_t v12 = a1;
        do
        {
          uint64_t v13 = v10;
          result.n128_u64[0] = v12[1].n128_u64[0];
          if (result.n128_f64[0] < v12->n128_f64[0])
          {
            unint64_t v14 = v12[1].n128_u64[1];
            uint64_t v15 = v11;
            while (1)
            {
              *(__n128 *)((char *)a1 + v15 + 16) = *(__n128 *)((char *)a1 + v15);
              if (!v15) {
                break;
              }
              double v16 = *(double *)((char *)a1[-1].n128_f64 + v15);
              v15 -= 16;
              if (result.n128_f64[0] >= v16)
              {
                uint64_t v17 = (__n128 *)((char *)a1 + v15 + 16);
                goto LABEL_15;
              }
            }
            uint64_t v17 = a1;
LABEL_15:
            v17->n128_u64[0] = result.n128_u64[0];
            v17->n128_u64[1] = v14;
          }
          BOOL v10 = v13 + 1;
          v11 += 16;
          uint64_t v12 = v13;
        }
        while (&v13[1] != a2);
      }
    }
  }
  return result;
}

void std::__stable_sort<std::_ClassicAlgPolicy,std::__less<void,void> &,TLine::EnumerateCaretOffsets(std::function<void ()(double,long,BOOL,BOOL *)>)::$_0::operator() const(unsigned long,int)::CaretPair *>(uint64_t a1, double *a2, unint64_t a3, uint64_t a4, uint64_t a5, __n128 a6)
{
  if (a3 >= 2)
  {
    uint64_t v7 = a1;
    if (a3 == 2)
    {
      uint64_t v8 = a2 - 4;
      if (*(a2 - 4) < *(double *)a1)
      {
        long long v10 = *(_OWORD *)a1;
        long long v9 = *(_OWORD *)(a1 + 16);
        long long v11 = *((_OWORD *)a2 - 1);
        *(_OWORD *)a1 = *(_OWORD *)v8;
        *(_OWORD *)(a1 + 16) = v11;
        *(_OWORD *)uint64_t v8 = v10;
        *((_OWORD *)a2 - 1) = v9;
      }
    }
    else if ((uint64_t)a3 > 128)
    {
      uint64_t v23 = a4;
      unint64_t v24 = a3 >> 1;
      uint64_t v25 = (double *)(a1 + 32 * (a3 >> 1));
      unint64_t v26 = a3 >> 1;
      if ((uint64_t)a3 <= a5)
      {
        __n128 v27 = std::__stable_sort_move<std::_ClassicAlgPolicy,std::__less<void,void> &,TLine::EnumerateCaretOffsets(std::function<void ()(double,long,BOOL,BOOL *)>)::$_0::operator() const(unsigned long,int)::CaretPair *>((double *)a1, v25, v26, a4, a6);
        uint64_t v28 = v23 + 32 * v24;
        std::__stable_sort_move<std::_ClassicAlgPolicy,std::__less<void,void> &,TLine::EnumerateCaretOffsets(std::function<void ()(double,long,BOOL,BOOL *)>)::$_0::operator() const(unsigned long,int)::CaretPair *>((double *)(v7 + 32 * (a3 >> 1)), a2, a3 - (a3 >> 1), v28, v27);
        unint64_t v29 = (double *)(v23 + 32 * a3);
        uint64_t v30 = (double *)v28;
        while (v30 != v29)
        {
          if (*v30 >= *(double *)v23)
          {
            long long v31 = *(_OWORD *)v23;
            long long v32 = *(_OWORD *)(v23 + 16);
            v23 += 32;
          }
          else
          {
            long long v31 = *(_OWORD *)v30;
            long long v32 = *((_OWORD *)v30 + 1);
            v30 += 4;
          }
          *(_OWORD *)uint64_t v7 = v31;
          *(_OWORD *)(v7 + 16) = v32;
          v7 += 32;
          if (v23 == v28)
          {
            if (v30 != v29)
            {
              uint64_t v33 = 0;
              do
              {
                long long v34 = (_OWORD *)(v7 + v33 * 8);
                long long v35 = *(_OWORD *)&v30[v33 + 2];
                _OWORD *v34 = *(_OWORD *)&v30[v33];
                v34[1] = v35;
                v33 += 4;
              }
              while (&v30[v33] != v29);
            }
            return;
          }
        }
        if (v23 != v28)
        {
          uint64_t v36 = 0;
          do
          {
            int64_t v37 = (_OWORD *)(v7 + v36);
            long long v38 = *(_OWORD *)(v23 + v36 + 16);
            _OWORD *v37 = *(_OWORD *)(v23 + v36);
            v37[1] = v38;
            v36 += 32;
          }
          while (v23 + v36 != v28);
        }
      }
      else
      {
        std::__stable_sort<std::_ClassicAlgPolicy,std::__less<void,void> &,TLine::EnumerateCaretOffsets(std::function<void ()(double,long,BOOL,BOOL *)>)::$_0::operator() const(unsigned long,int)::CaretPair *>(a1, v25, v26, a4, a5);
        std::__stable_sort<std::_ClassicAlgPolicy,std::__less<void,void> &,TLine::EnumerateCaretOffsets(std::function<void ()(double,long,BOOL,BOOL *)>)::$_0::operator() const(unsigned long,int)::CaretPair *>(v7 + 32 * (a3 >> 1), a2, a3 - (a3 >> 1), v23, a5);
        std::__inplace_merge<std::_ClassicAlgPolicy,std::__less<void,void> &,TLine::EnumerateCaretOffsets(std::function<void ()(double,long,BOOL,BOOL *)>)::$_0::operator() const(unsigned long,int)::CaretPair *>((double *)v7, (double *)(v7 + 32 * (a3 >> 1)), a2, a3 >> 1, a3 - (a3 >> 1), (double *)v23, a5);
      }
    }
    else if ((double *)a1 != a2)
    {
      uint64_t v13 = a1 + 32;
      if ((double *)(a1 + 32) != a2)
      {
        uint64_t v14 = 0;
        uint64_t v15 = a1;
        do
        {
          uint64_t v16 = v13;
          double v17 = *(double *)(v15 + 32);
          if (v17 < *(double *)v15)
          {
            long long v39 = *(_OWORD *)(v15 + 40);
            uint64_t v40 = *(void *)(v15 + 56);
            uint64_t v18 = v14;
            while (1)
            {
              uint64_t v19 = a1 + v18;
              long long v20 = *(_OWORD *)(a1 + v18 + 16);
              *(_OWORD *)(v19 + 32) = *(_OWORD *)(a1 + v18);
              *(_OWORD *)(v19 + 48) = v20;
              if (!v18) {
                break;
              }
              v18 -= 32;
              if (v17 >= *(double *)(v19 - 32))
              {
                uint64_t v21 = a1 + v18 + 32;
                goto LABEL_15;
              }
            }
            uint64_t v21 = a1;
LABEL_15:
            *(double *)uint64_t v21 = v17;
            *(_OWORD *)(v21 + 8) = v39;
            *(void *)(v21 + 24) = v40;
          }
          uint64_t v13 = v16 + 32;
          v14 += 32;
          uint64_t v15 = v16;
        }
        while ((double *)(v16 + 32) != a2);
      }
    }
  }
}

uint64_t TLine::GetRightPartialHangingGlyphCountAndWidth(TLine *this, const unint64_t *a2)
{
  uint64_t v4 = 0;
  uint64_t v5 = (uint64_t)(*((void *)this + 3) - *((void *)this + 2)) >> 3;
  double v6 = 0.0;
  do
  {
    uint64_t v7 = v5 - 1;
    if (v5 < 1) {
      break;
    }
    uint64_t v8 = *(TRun **)(*(void *)(*((void *)this + 2) + 8 * v5 - 8) + 40);
    uint64_t v9 = *((void *)v8 + 26);
    if (*(double *)&a2 == 0.0)
    {
      long long v11 = (TParagraphStyle **)*((void *)v8 + 21);
      LOBYTE(v10) = v11 ? TParagraphStyle::GetLineBoundsOptions(v11, a2) : 0;
    }
    else
    {
      uint64_t v10 = *a2;
    }
    uint64_t RightPartialHangingGlyphCountAndWidth = TRun::GetRightPartialHangingGlyphCountAndWidth(v8, v9 - 1, v10, *(const TCharStream **)this);
    v4 += RightPartialHangingGlyphCountAndWidth;
    double v6 = v6 + *(double *)&a2;
    uint64_t v5 = v7;
  }
  while (RightPartialHangingGlyphCountAndWidth >= v9);
  return v4;
}

uint64_t TFont::GetLigatureCaretPositionsForGlyph(TFont *this, uint64_t a2, double *a3, uint64_t a4)
{
  uint64_t v5 = a4;
  double v6 = a3;
  uint64_t v65 = *MEMORY[0x1E4F143B8];
  if (a3) {
    BOOL v9 = a4 < 1;
  }
  else {
    BOOL v9 = 1;
  }
  char v10 = v9;
  id v56 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr))(**((void **)this + 50) + 480))(&v56);
  CFDataRef v11 = (const __CFData *)(id)atomic_load_explicit((atomic_ullong *volatile)&v56, memory_order_acquire);
  CFDataRef v12 = v11;
  if (v11) {
    BytePtr = CFDataGetBytePtr(v11);
  }
  else {
    BytePtr = 0;
  }

  unint64_t v54 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v55 = 0xAAAAAAAAAAAAAAAALL;
  id v14 = (id)atomic_load_explicit((atomic_ullong *volatile)&v56, memory_order_acquire);
  CFDataRef v15 = (const __CFData *)v14;
  if (!v15)
  {

    goto LABEL_14;
  }
  CFDataRef v16 = v15;
  double v17 = CFDataGetBytePtr(v15);

  if (!v17)
  {
LABEL_14:
    unint64_t v18 = 0;
    goto LABEL_15;
  }
  unint64_t v18 = (unint64_t)&v17[CFDataGetLength((CFDataRef)v14)];
LABEL_15:
  unint64_t v54 = (unint64_t)BytePtr;
  unint64_t v55 = v18;
  if (BytePtr && (unint64_t)(BytePtr + 6) > v18)
  {
    unint64_t v54 = 0;
  }
  else
  {

    if (BytePtr)
    {
      if (v10)
      {
        LigatureCaretCFIndex Count = TLCARTable::GetLigatureCaretCount((TLCARTable *)&v54, a2);
      }
      else
      {
        *(void *)&long long v20 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)&v63[56] = v20;
        *(_OWORD *)&v63[40] = v20;
        *(_OWORD *)&v63[24] = v20;
        *(_OWORD *)&v63[8] = v20;
        CFIndex v64 = &v63[8];
        if (&v63[2 * v5 + 8] <= &v63[68])
        {
          CFIndex v64 = &v63[2 * v5 + 8];
          size_t v21 = 2 * v5;
          unint64_t v22 = &v63[8];
        }
        else
        {
          size_t v21 = 2 * v5;
          unint64_t v22 = operator new(2 * v5);
        }
        __p[0] = v22;
        *(void *)unint64_t v63 = &v22[2 * v5];
        bzero(v22, v21);
        __p[1] = &v22[2 * v5];
        v58[0] = 0;
        uint64_t LigatureCaretPositions = TLCARTable::GetLigatureCaretPositions((TLCARTable *)&v54, a2, (__int16 *)v22, v5, v58);
        LigatureCaretCFIndex Count = LigatureCaretPositions;
        if (LigatureCaretPositions >= 1)
        {
          if (v58[0] == 1)
          {
            if (LigatureCaretPositions >= v5) {
              unint64_t v30 = v5;
            }
            else {
              unint64_t v30 = LigatureCaretPositions;
            }
            TFont::GetControlPointPositions((TBaseFont **)this, a2, (const __int16 *)__p[0], v6, v30);
          }
          else if (v58[0])
          {
            LigatureCaretCFIndex Count = 0;
          }
          else
          {
            unint64_t v24 = (__int16 *)__p[0];
            if (LigatureCaretPositions < v5) {
              uint64_t v5 = LigatureCaretPositions;
            }
            TFont::GetScaledMatrix(this, &v53);
            double a = v53.a;
            tCGFloat x = v53.tx;
            double v27 = v53.c * 0.0;
            uint64_t v28 = 2 * v5;
            do
            {
              int v29 = *v24++;
              *v6++ = tx + v27 + a * (double)v29;
              v28 -= 2;
            }
            while (v28);
          }
        }
        if (__p[0])
        {
          __p[1] = __p[0];
          if (&v63[8] > __p[0] || &v63[68] <= __p[0]) {
            operator delete(__p[0]);
          }
        }
      }
      goto LABEL_52;
    }
  }
  CFDataRef CommonTable = (const __CFData *)TBaseFont::GetCommonTable(*((TBaseFont **)this + 50), 1195656518, 0);
  if (!CommonTable) {
    goto LABEL_51;
  }
  *(void *)&long long v33 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v33 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v63[32] = v33;
  *(_OWORD *)&v63[48] = v33;
  *(_OWORD *)unint64_t v63 = v33;
  *(_OWORD *)&v63[16] = v33;
  *(_OWORD *)__p = v33;
  OTL::GDEF::GDEF((OTL::GDEF *)__p, CommonTable);
  if (!__p[0]) {
    goto LABEL_51;
  }
  if (!*((_WORD *)__p[0] + 4)) {
    goto LABEL_51;
  }
  long long v34 = (unsigned __int16 *)__p[1];
  long long v35 = (unsigned __int16 *)((char *)__p[0] + __rev16(*((unsigned __int16 *)__p[0] + 4)));
  if (v35 + 2 > __p[1]) {
    goto LABEL_51;
  }
  OTL::Coverage::Coverage((OTL::Coverage *)v58, (unsigned __int16 *)((char *)v35 + (bswap32(*v35) >> 16)), (unint64_t)__p[1], 0);
  uint64_t v36 = v60;
  int64_t v37 = (void *)((char *)v58 + (v61 >> 1));
  if (v61) {
    uint64_t v36 = *(double **)(*v37 + v60);
  }
  unsigned int v38 = ((uint64_t (*)(void *, uint64_t))v36)(v37, a2);
  if (!v38
    || v38 > bswap32(v35[1]) >> 16
    || (uint64_t v40 = (unsigned __int16 *)((char *)v35 + (bswap32(v35[v38 + 1]) >> 16)), v41 = v40 + 1, v40 + 1 > v34))
  {
LABEL_51:
    LigatureCaretCFIndex Count = 0;
    goto LABEL_52;
  }
  LigatureCaretCFIndex Count = __rev16((unsigned __int16)*v40);
  if (*v40) {
    char v42 = v10;
  }
  else {
    char v42 = 1;
  }
  if ((v42 & 1) == 0)
  {
    unint64_t v52 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t VariationValues = (__int16 *)TFont::GetVariationValues((atomic_ullong *)this, &v52);
    uint64_t v43 = LigatureCaretCount >= v5 ? v5 : LigatureCaretCount;
    if (v43)
    {
      unint64_t v50 = v52;
      while (1)
      {
        unsigned int v44 = *v41++;
        CFRange v45 = (_WORD *)((char *)v40 + (bswap32(v44) >> 16));
        *(void *)long long v58 = this;
        long long v46 = v45 + 1;
        __int16 v59 = a2;
        uint64_t v60 = v6;
        if (v45 + 1 > v34)
        {
LABEL_75:
          uint64_t v48 = 0;
          goto LABEL_76;
        }
        unsigned int v47 = bswap32(*v45) >> 16;
        if (v47 == 3) {
          break;
        }
        if (v47 != 2)
        {
          if (v47 != 1 || v45 + 2 > v34) {
            goto LABEL_75;
          }
          double v4 = (double)((int)bswap32(*v46) >> 16);
          goto LABEL_72;
        }
        if (v45 + 2 > v34) {
          goto LABEL_75;
        }
        *(void *)&double v4 = bswap32(*v46) >> 16;
        uint64_t v48 = 2;
LABEL_76:
        *(double *)long long v51 = v4;
        v51[1] = v48;
        int v57 = v58;
        ((void (*)(unsigned __int16 **, void *))off_1ED062738[v48])(&v57, v51);
        ++v6;
        if (!--v43) {
          goto LABEL_52;
        }
      }
      if (v45 + 3 > v34) {
        goto LABEL_75;
      }
      double v4 = (double)((int)bswap32(*v46) >> 16);
      if (v50) {
        double v4 = OTL::GDEF::DeltaValue((OTL::GDEF *)__p, (char *)v45, (unint64_t)v34, bswap32(v45[2]) >> 16, v50, VariationValues)+ v4;
      }
LABEL_72:
      uint64_t v48 = 1;
      goto LABEL_76;
    }
  }
LABEL_52:

  return LigatureCaretCount;
}

CFIndex TTypesetter::FindLineBreak(TLine **a1, CFIndex a2, CFIndex a3, unsigned int a4)
{
  if (*((void *)*a1 + 3) == *((void *)*a1 + 2)) {
    unint64_t explicit = 0;
  }
  else {
    unint64_t explicit = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)(*(void *)(*(void *)(*((void *)*a1 + 2)+ 8* TLine::FindRunWithCharIndex(*a1, a2 + a3, 1))+ 40)+ 64), memory_order_acquire);
  }
  BOOL v9 = a1[1];
  v10.CFIndex location = a2;
  v10.CFIndex length = a3;

  return TCharStream::FindLineBreak(v9, v10, (a4 >> 1) & 1, explicit);
}

CFComparisonResult CompareDescriptorsByTraitsAndPrecedenceForSingleFamily(void *a1, void *a2, void *a3)
{
  return CompareLocalizedDescriptorsByTraitsAndPrecedence(a1, a2, a3, 0, 0, 1);
}

unint64_t CTTypesetterCreateWithRunArray(const __CFArray *a1, const __CFString *a2, const void *(*a3)(const __CTRun *, const __CFString *, void *), void *a4)
{
  id v14 = (id)0xAAAAAAAAAAAAAAAALL;
  uint64_t v8 = TCFBase<TTypesetter>::Allocate();
  if (v8)
  {
    BOOL v9 = (void *)v8;
    CFRange v10 = (TTypesetter *)(v8 + 48);
    v9[2] = 0;
    id v9[3] = 0;
    void v9[4] = 0;
    void v9[5] = v10;
    TTypesetter::TTypesetter(v10, a1, a2, a3, a4, 0);
    id v15 = v9;
    id v13 = (id)atomic_exchange((atomic_ullong *volatile)&v15, 0);
  }
  else
  {
    id v13 = 0;
  }
  id v14 = (id)atomic_exchange((atomic_ullong *volatile)&v13, 0);

  unint64_t v11 = atomic_exchange((atomic_ullong *volatile)&v14, 0);
  return v11;
}

CTTypesetterRef CTTypesetterCreateWithAttributedStringAndOptions(CFAttributedStringRef string, CFDictionaryRef options)
{
  if (!string) {
    return 0;
  }
  id v10 = (id)0xAAAAAAAAAAAAAAAALL;
  uint64_t v4 = TCFBase<TTypesetter>::Allocate();
  if (v4)
  {
    uint64_t v5 = (void *)v4;
    double v6 = (TTypesetterAttrString *)(v4 + 48);
    v5[2] = 0;
    v5[3] = 0;
    v5[4] = 0;
    void v5[5] = v6;
    TTypesetterAttrString::TTypesetterAttrString(v6, string, options, 0);
    id v11 = v5;
    id v9 = (id)atomic_exchange((atomic_ullong *volatile)&v11, 0);
  }
  else
  {
    id v9 = 0;
  }
  id v10 = (id)atomic_exchange((atomic_ullong *volatile)&v9, 0);

  if (atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire)
    && *(unsigned char *)(*(void *)(atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire) + 40) + 257))
  {
    uint64_t v7 = 0;
  }
  else
  {
    uint64_t v7 = (const __CTTypesetter *)atomic_exchange((atomic_ullong *volatile)&v10, 0);
  }

  return v7;
}

CTTypesetterRef CTTypesetterCreateWithAttributedString(CFAttributedStringRef string)
{
  CFAttributedStringRef v1 = string;
  if (string)
  {
    id v7 = (id)0xAAAAAAAAAAAAAAAALL;
    uint64_t v2 = TCFBase<TTypesetter>::Allocate();
    if (v2)
    {
      uint64_t v3 = (void *)v2;
      uint64_t v4 = (TTypesetterAttrString *)(v2 + 48);
      v3[2] = 0;
      v3[3] = 0;
      v3[4] = 0;
      v3[5] = v4;
      TTypesetterAttrString::TTypesetterAttrString(v4, v1, 0, 0);
      id v8 = v3;
      id v6 = (id)atomic_exchange((atomic_ullong *volatile)&v8, 0);
    }
    else
    {
      id v6 = 0;
    }
    id v7 = (id)atomic_exchange((atomic_ullong *volatile)&v6, 0);

    CFAttributedStringRef v1 = (const __CFAttributedString *)atomic_exchange((atomic_ullong *volatile)&v7, 0);
  }
  return v1;
}

uint64_t TCFBase<TTypesetter>::Allocate()
{
  if (TCFBase<TTypesetter>::GetTypeID(void)::once != -1) {
    dispatch_once_f(&TCFBase<TTypesetter>::GetTypeID(void)::once, 0, (dispatch_function_t)TCFBase<TTypesetter>::GetTypeID(void)::{lambda(void *)#1}::__invoke);
  }

  return _CFRuntimeCreateInstance();
}

void TTypesetter::TTypesetter(TTypesetter *this, const __CFArray *a2, const __CFString *a3, const void *(*a4)(const __CTRun *, const __CFString *, void *), void *a5, const __CFDictionary *a6)
{
  __dst[82] = *(TCompositionEngine **)MEMORY[0x1E4F143B8];
  CFDataRef v12 = operator new(0x48uLL);
  v12[1] = 0;
  v12[2] = 0;
  *CFDataRef v12 = &unk_1ED062278;
  TCharStreamCFString::TCharStreamCFString((TCharStreamCFString *)(v12 + 3), a3, 0);
  *(void *)this = v13;
  *((void *)this + 1) = v12;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 8) = (char *)this + 40;
  *((unsigned char *)this + 184) = 0;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(void *)((char *)this + 149) = 0;
  *((void *)this + 20) = 0;
  *((void *)this + 21) = 0;
  *((unsigned char *)this + 176) = 0;
  *((void *)this + 24) = 0;
  *((void *)this + 25) = 0;
  *((void *)this + 16) = 0xFFEFFFFFFFFFFFFFLL;
  *((void *)this + 26) = 0;
  *((void *)this + 27) = v13;
  *((void *)this + 28) = a4;
  *((void *)this + 29) = a5;
  *((void *)this + 30) = 0;
  *((_DWORD *)this + 65) = 0;
  *((unsigned char *)this + 264) = 0;
  *((void *)this + 31) = 0;
  *((_WORD *)this + 128) = 0;
  TLine::SetRunArray((int64x2_t *)this, a2);
  TLine::LinkRuns(this);
  if (a6) {
    TTypesetter::UnpackOptions(this, a6);
  }
  if (TTypesetter::CanLayout(this))
  {
    uint64_t v19 = this;
    long long v20 = *(_OWORD *)((char *)this + 216);
    uint64_t v21 = *((void *)this + 29);
    unint64_t v22 = (char *)this + 240;
    int v14 = *((_DWORD *)this + 65);
    int v24 = -1431655766;
    uint64_t v25 = 0;
    int v23 = v14;
    LOBYTE(v24) = *((unsigned char *)this + 264);
    BYTE1(v24) = *((unsigned char *)this + 257);
    memcpy(__dst, &unk_184B8A700, 0x290uLL);
    TRunGlue::TRunGlue((TRunGlue *)__dst, this);
    LOBYTE(v26) = 0;
    char v18 = 0;
    if (TTypesetter::DoAttachments((uint64_t)&v19, (void ***)__dst, &v26, &v18))
    {
      char v16 = TShapingEngine::ShapeGlyphs((TShapingEngine *)__dst, *((TRunGlue **)this + 27), v15);
      char v17 = v18 | v16;
    }
    else
    {
      char v17 = v18;
    }
    TTypesetter::FinishLayout((uint64_t)&v19, __dst, (const TCharStream *)(char)v26, v17);
    DoGlyphFixupsCheck(this);
    std::__function::__value_func<BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::~__value_func[abi:nn180100](&__dst[70]);
    unint64_t v26 = &__dst[46];
    std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v26);
    unint64_t v26 = &__dst[26];
    std::vector<unsigned char,TInlineBufferAllocator<unsigned char,128ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v26);
    unint64_t v26 = &__dst[7];
    std::vector<std::pair<UScriptCode,long>,TInlineBufferAllocator<std::pair<UScriptCode,long>,1ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v26);
  }
}

uint64_t TKerningEngine::PositionGlyphs(TKerningEngine *this, TLine *a2, const TCharStream *a3)
{
  __dst[82] = *MEMORY[0x1E4F143B8];
  memcpy(__dst, &__const__ZN14TKerningEngine14PositionGlyphsER5TLineRK11TCharStreama_glyphs, 0x290uLL);
  TRunGlue::TRunGlue((TRunGlue *)__dst, this);
  uint64_t v7 = TKerningEngine::PositionGlyphs((TKerningEngine *)__dst, a2, a3, v6);
  std::__function::__value_func<BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::~__value_func[abi:nn180100](&__dst[70]);
  id v9 = (void **)&__dst[46];
  std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100](&v9);
  id v9 = (void **)&__dst[26];
  std::vector<unsigned char,TInlineBufferAllocator<unsigned char,128ul>>::__destroy_vector::operator()[abi:nn180100](&v9);
  id v9 = (void **)&__dst[7];
  std::vector<std::pair<UScriptCode,long>,TInlineBufferAllocator<std::pair<UScriptCode,long>,1ul>>::__destroy_vector::operator()[abi:nn180100](&v9);
  return v7;
}

uint64_t CTFontTransformGlyphs(const __CTFont *a1, unsigned __int16 *a2, CGSize *a3, uint64_t a4, int a5)
{
  uint64_t v5 = 0;
  v21[82] = *MEMORY[0x1E4F143B8];
  if (a1 && a2 && a3)
  {
    if (a4 >= 1)
    {
      if (a5) {
        char v10 = a5;
      }
      else {
        char v10 = 3;
      }
      memcpy(v21, &unk_184B89DC0, 0x290uLL);
      TRunGlue::TRunGlue((TRunGlue *)v21, a1, a2, a3, a4, 0, 0, 0);
      id v11 = (atomic_ullong *)v21[77];
      int ShapingType = TBaseFont::GetShapingType(*(TBaseFont **)(v21[77] + 400));
      BOOL HasAvailable = StackHasAvailable(0x8000uLL);
      if (HasAvailable)
      {
        MEMORY[0x1F4188790](HasAvailable, v14);
        memset(v18, 170, 0x2000uLL);
        if (ShapingType >= 2)
        {
          if (v21[78] <= 0x10000uLL) {
            size_t v15 = (unint64_t)(v21[78] + 7) >> 3;
          }
          else {
            size_t v15 = 0x2000;
          }
          bzero(v18, v15);
          TRunGlue::DetermineCoverage((uint64_t)v21, v18);
        }
        uint64_t v19 = (void **)0xAAAAAAAAAAAAAA00;
        int v20 = -1431655936;
        if ((v10 & 1) == 0)
        {
LABEL_24:
          uint64_t v5 = 1;
          if ((v10 & 2) != 0) {
            goto LABEL_25;
          }
LABEL_27:
          std::__function::__value_func<BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::~__value_func[abi:nn180100](&v21[70]);
          uint64_t v19 = (void **)&v21[46];
          std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100](&v19);
          uint64_t v19 = (void **)&v21[26];
          std::vector<unsigned char,TInlineBufferAllocator<unsigned char,128ul>>::__destroy_vector::operator()[abi:nn180100](&v19);
          uint64_t v19 = (void **)&v21[7];
          std::vector<std::pair<UScriptCode,long>,TInlineBufferAllocator<std::pair<UScriptCode,long>,1ul>>::__destroy_vector::operator()[abi:nn180100](&v19);
          return v5;
        }
        if (v11[40])
        {
          if (TFont::NeedsShapingForGlyphs(v11, a2, a4, 0))
          {
            uint64_t v5 = TShapingEngine::ShapeGlyphs((uint64_t)v21, ShapingType, 0, (uint64_t)&v19, 0);
            if ((v10 & 2) == 0) {
              goto LABEL_27;
            }
LABEL_25:
            if (v5)
            {
              v21[68] = 0x7FF0000000000000;
              uint64_t v5 = TKerningEngine::PositionGlyphs((TRunGlue *)v21, ShapingType, (const TFont *)v19, v20, 0, 0, 1);
            }
            goto LABEL_27;
          }
          goto LABEL_24;
        }
        if (TShapingEngine::ShapeGlyphs((uint64_t)v21, ShapingType, 0, (uint64_t)&v19, 0))
        {
          if (qword_1EB2CDFA8 != -1) {
            dispatch_once_f(&qword_1EB2CDFA8, 0, (dispatch_function_t)GetShapingGlyphsQueue(void)::$_0::__invoke);
          }
          char v16 = qword_1EB2CDFA0;
          CFRetain(a1);
          dispatch_async_f(v16, a1, (dispatch_function_t)InitShapingGlyphsOnQueue(__CTFont const*,NSObject  {objcproto17OS_dispatch_queue}*)::$_0::__invoke);
          goto LABEL_24;
        }
      }
      uint64_t v5 = 0;
      goto LABEL_27;
    }
    return 1;
  }
  return v5;
}

void *TTypesetterString::Initialize(void *this, const __CFString *a2, const __CFDictionary *a3)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  CFIndex v3 = *(void *)(this[27] + 16);
  if (v3 < 1) {
    return this;
  }
  uint64_t v5 = this;
  this = +[_CTNativeGlyphStorage newWithCount:v3 capacity:v3];
  if (!this) {
    return this;
  }
  signed __int8 v6 = this;
  char v22 = -86;
  unint64_t v21 = 0xAAAAAAAAFFFFFFFFLL;
  memset(&v20[80], 170, 160);
  memset(v20, 170, 32);
  uint64_t v7 = v5[27];
  *(void *)int v20 = this;
  *(void *)&unsigned char v20[8] = v7;
  memset(&v20[16], 0, 184);
  *(void *)&v20[176] = *(void *)(v7 + 16);
  *(void *)&v20[200] = v5;
  memset(&v20[208], 0, 32);
  LODWORD(v21) = 1065353216;
  Table = (atomic_ullong **)GetTable();
  if (Table && (id v9 = *Table) != 0)
  {
    if ((const __CFDictionary *)atomic_load_explicit(v9, memory_order_acquire) == a3)
    {
      char v22 = TGlyphEncoder::EncodeChars((_CTGlyphStorage **)v20, 0, v3, (uint64_t)(v9 + 1), 0);
      goto LABEL_11;
    }
    __dst[6] = xmmword_184B88F60;
    memset(&__dst[7], 170, 40);
    __dst[3] = unk_184B88F30;
    memset(&__dst[4], 255, 32);
    memset(__dst, 170, 48);
    v26.CFIndex location = 0;
    v26.CFIndex length = v3;
    TAttributes::TAttributes((TAttributes *)__dst, a3, (const TCharStream *)v5[27], v26, 0);
    char v22 = TGlyphEncoder::EncodeChars((_CTGlyphStorage **)v20, 0, v3, (uint64_t)__dst, 0);
    id v13 = (id)atomic_load_explicit((atomic_ullong *volatile)(v5[27] + 40), memory_order_acquire);

    TAttributes::operator=((uint64_t)(v9 + 1), (uint64_t)__dst);
  }
  else
  {
    __dst[6] = xmmword_184B88F60;
    memset(&__dst[7], 170, 40);
    __dst[3] = unk_184B88F30;
    memset(&__dst[4], 255, 32);
    memset(__dst, 170, 48);
    v27.CFIndex location = 0;
    v27.CFIndex length = v3;
    TAttributes::TAttributes((TAttributes *)__dst, a3, (const TCharStream *)v5[27], v27, 0);
    char v22 = TGlyphEncoder::EncodeChars((_CTGlyphStorage **)v20, 0, v3, (uint64_t)__dst, 0);
    char v10 = (char *)operator new(0xA0uLL, MEMORY[0x1E4FBA2D0]);
    if (v10)
    {
      id v13 = (id)atomic_load_explicit((atomic_ullong *volatile)(v5[27] + 40), memory_order_acquire);
      *(void *)char v10 = atomic_exchange((atomic_ullong *volatile)&v13, 0);
      *(_WORD *)(v10 + 57) = 0;
      v10[59] = 0;
      v10[64] = 0;
      v10[112] = 0;
      *((void *)v10 + 19) = 0;
      *(_OWORD *)(v10 + 24) = 0u;
      *(_OWORD *)(v10 + 40) = 0u;
      *(_OWORD *)(v10 + 8) = 0u;
      *((void *)v10 + 16) = 0;
      *((void *)v10 + 17) = 0;
      TAttributes::operator=((uint64_t)(v10 + 8), (uint64_t)__dst);
    }
    SetThreadSpecificData(0, (uint64_t)v10, (uint64_t (*)(void *))TTypesetter::DestroyAttributesCache);
  }
  TAttributes::~TAttributes((TAttributes *)__dst);
LABEL_11:

  v5[9] = 0;
  v5[10] = v3;
  TLine::LinkRuns(v5);
  if (TTypesetter::CanLayout((TTypesetter *)v5))
  {
    id v13 = v5;
    long long v14 = *(_OWORD *)(v5 + 27);
    uint64_t v15 = v5[29];
    char v16 = v5 + 30;
    int v11 = *((_DWORD *)v5 + 65);
    int v18 = -1431655766;
    uint64_t v19 = 0;
    int v17 = v11;
    LOBYTE(v18) = *((unsigned char *)v5 + 264);
    BYTE1(v18) = *((unsigned char *)v5 + 257);
    memcpy(__dst, &unk_184B88F98, sizeof(__dst));
    TRunGlue::TRunGlue((TRunGlue *)__dst, (TLine *)v5);
    char v12 = TTypesetter::FinishEncoding((uint64_t)&v13, (TShapingEngine *)__dst, (const TCharStream *)&v22);
    TTypesetter::FinishLayout((uint64_t)&v13, (TCompositionEngine **)__dst, (const TCharStream *)v22, v12);
    std::__function::__value_func<BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::~__value_func[abi:nn180100](&__dst[35]);
    int v23 = (void **)&__dst[23];
    std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100](&v23);
    int v23 = (void **)&__dst[13];
    std::vector<unsigned char,TInlineBufferAllocator<unsigned char,128ul>>::__destroy_vector::operator()[abi:nn180100](&v23);
    int v23 = (void **)&__dst[3] + 1;
    std::vector<std::pair<UScriptCode,long>,TInlineBufferAllocator<std::pair<UScriptCode,long>,1ul>>::__destroy_vector::operator()[abi:nn180100](&v23);
  }
  return (void *)std::__hash_table<EncoderAttempt,std::hash<EncoderAttempt>,std::equal_to<EncoderAttempt>,std::allocator<EncoderAttempt>>::~__hash_table((uint64_t)&v20[208]);
}

void TRunGlue::TRunGlue(TRunGlue *this, TLine *a2)
{
  uint64_t v3 = (uint64_t)(*((void *)a2 + 3) - *((void *)a2 + 2)) >> 3;
  *(void *)this = a2;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = v3;
  *((void *)this + 4) = *((void *)a2 + 18);
  *(_OWORD *)((char *)this + 40) = *(_OWORD *)((char *)a2 + 72);
  *((void *)this + 8) = 0;
  *((void *)this + 9) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 16) = 0;
  *((void *)this + 13) = 0;
  *((void *)this + 14) = 0;
  *((void *)this + 12) = (char *)this + 80;
  *((_DWORD *)this + 30) = 0;
  uint64_t v4 = *(void *)(**((void **)a2 + 2) + 48);
  *((void *)this + 19) = v4;
  *((void *)this + 20) = 0;
  *((void *)this + 21) = *(void *)(v4 + 208);
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *((void *)this + 47) = 0;
  *((void *)this + 48) = 0;
  *((void *)this + 45) = (char *)this + 232;
  *((void *)this + 46) = 0;
  *((void *)this + 64) = (char *)this + 392;
  uint64_t v5 = (_OWORD *)MEMORY[0x1E4F1DB30];
  *((void *)this + 67) = 0;
  *((_OWORD *)this + 34) = *v5;
  *((void *)this + 73) = 0;
  *((_WORD *)this + 296) = 0;
  *((void *)this + 75) = 0;
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(v4 + 56), memory_order_acquire);
  *((void *)this + 76) = explicit;
  uint64_t v7 = *(void *)(explicit + 40);
  *((void *)this + 77) = v7;
  *((void *)this + 78) = TBaseFont::GetGlyphCount(*(TBaseFont **)(v7 + 400));
  *((unsigned char *)this + 632) = (*(uint64_t (**)(void))(**(void **)(*((void *)this + 77) + 400) + 104))(*(void *)(*((void *)this + 77) + 400));
  *((unsigned char *)this + 633) = 1;
  *((unsigned char *)this + 634) = *(unsigned char *)(*((void *)this + 19) + 90);
  *((double *)this + 80) = TRunGlue::InitScale(this);
  *((void *)this + 81) = v8;
  TRunGlue::InitLevelRange(this);
  uint64_t v9 = *((void *)this + 19);
  if (*(unsigned char *)(v9 + 224))
  {
    *((_DWORD *)this + 6) = -1;
    uint64_t v10 = *(void *)this;
    uint64_t v9 = *(void *)(*(void *)(*(void *)(v10 + 16) + 8 * TRunGlue::PhysicalRunIndexFromLogical(this, 0)) + 48);
    *((void *)this + 19) = v9;
    *((void *)this + 21) = *(void *)(v9 + 208);
    uint64_t v11 = *((void *)this + 17) + *((void *)this + 18) - 1;
    if (v11 != *((void *)this + 16))
    {
      TRunGlue::SelectRun(this, v11);
      uint64_t v9 = *((void *)this + 19);
    }
  }
  else
  {
    *((_DWORD *)this + 6) = 1;
  }
  char v12 = *(void **)(v9 + 216);
  uint64_t v13 = *(void *)(v9 + 200);
  *((void *)this + 22) = v12[2] + 2 * v13;
  *((void *)this + 65) = v12[5] + 4 * v13;
  *((void *)this + 66) = v12[6] + 8 * v13;
}

void TRunGlue::TRunGlue(TRunGlue *this, const __CTFont *a2, unsigned __int16 *a3, CGSize *a4, uint64_t a5, uint64_t a6, CGPoint *a7, uint64_t *a8)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((_DWORD *)this + 6) = 1;
  *((void *)this + 4) = a5;
  *((void *)this + 5) = a6;
  *((void *)this + 6) = a5;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 9) = 0;
  *((void *)this + 13) = 0;
  *((void *)this + 14) = 0;
  *((void *)this + 12) = (char *)this + 80;
  *((_DWORD *)this + 30) = 0;
  *((void *)this + 16) = -1;
  *((void *)this + 17) = -1;
  *((void *)this + 18) = 0;
  *((void *)this + 19) = 0;
  *((void *)this + 20) = 0;
  *((void *)this + 21) = a5;
  *((void *)this + 22) = a3;
  *((void *)this + 23) = a4;
  *((void *)this + 24) = a7;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 216) = 0u;
  *((void *)this + 45) = (char *)this + 232;
  if ((unint64_t)(a5 + 14) >= 0xF)
  {
    uint64_t v11 = (void *)((char *)this + 208);
    if (a5 >= -7) {
      uint64_t v12 = a5 + 7;
    }
    else {
      uint64_t v12 = a5 + 14;
    }
    std::vector<unsigned char,TInlineBufferAllocator<unsigned char,128ul>>::__vallocate[abi:nn180100](v11, v12 >> 3);
    uint64_t v13 = (char *)*((void *)this + 27);
    bzero(v13, v12 >> 3);
    *((void *)this + 27) = &v13[v12 >> 3];
  }
  *((void *)this + 47) = 0;
  *((void *)this + 48) = 0;
  *((void *)this + 46) = 0;
  *((void *)this + 64) = (char *)this + 392;
  *((void *)this + 65) = 0;
  *((void *)this + 66) = a8;
  *((void *)this + 67) = 0;
  *((_OWORD *)this + 34) = *MEMORY[0x1E4F1DB30];
  *((void *)this + 73) = 0;
  *((_WORD *)this + 296) = 0;
  *((void *)this + 75) = 0;
  *((void *)this + 76) = a2;
  uint64_t v14 = *((void *)a2 + 5);
  *((void *)this + 77) = v14;
  *((void *)this + 78) = TBaseFont::GetGlyphCount(*(TBaseFont **)(v14 + 400));
  *((unsigned char *)this + 632) = (*(uint64_t (**)(void))(**(void **)(*((void *)this + 77) + 400) + 104))(*(void *)(*((void *)this + 77) + 400));
  *((unsigned char *)this + 633) = 1;
  *((unsigned char *)this + 634) = **((unsigned char **)this + 77) & 1;
  *((double *)this + 80) = TRunGlue::InitScale(this);
  *((void *)this + 81) = v15;
}

uint64_t TTenuousComponentFont::HasVariations(TTenuousComponentFont *this)
{
  return (*((unsigned __int8 *)this + 712) >> 2) & 1;
}

BOOL TRunGlue::NextRunRange(TRunGlue *this, uint64_t a2)
{
  uint64_t v2 = *((void *)this + 1) + a2;
  uint64_t v3 = *(void *)(*(void *)this + 16);
  uint64_t v4 = *(void *)(*(void *)this + 24) - v3;
  uint64_t v5 = v4 >> 3;
  if (v2 >= v4 >> 3) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = *((void *)this + 1) + a2;
  }
  if (v4 != 8)
  {
    *((void *)this + 1) = v6;
    *((void *)this + 2) = v5 - v6;
    *((void *)this + 4) = -1;
    *((void *)this + 5) = -1;
    *((void *)this + 6) = 0;
    *((void *)this + 16) = v6;
    uint64_t v8 = *(void *)(*(void *)(v3 + 8 * v6) + 48);
    *((void *)this + 19) = v8;
    *((void *)this + 20) = 0;
    *((void *)this + 21) = *(void *)(v8 + 208);
    if (*(unsigned char *)(v8 + 224))
    {
      *((_DWORD *)this + 6) = -1;
      uint64_t v9 = TRunGlue::PhysicalRunIndexFromLogical(this, v6);
      uint64_t v10 = *((void *)this + 16);
      if (v9 != v10)
      {
        uint64_t v11 = *(void *)(*(void *)this + 16);
        uint64_t v12 = *(void *)(*(void *)(*(void *)(v11 + 8 * v9) + 48) + 208);
        if (v9 > v10)
        {
          uint64_t v13 = v11 - 8;
          uint64_t v14 = v9;
          do
          {
            uint64_t v15 = v12;
            v12 += *(void *)(*(void *)(*(void *)(v13 + 8 * v14--) + 48) + 208);
          }
          while (v14 > v10);
          *((void *)this + 20) = v15;
        }
        *((void *)this + 21) = v12;
        *((void *)this + 16) = v9;
      }
    }
    else
    {
      *((_DWORD *)this + 6) = 1;
    }
    TRunGlue::UpdateForCurrentRealRun(this);
    *((void *)this + 25) = 0;
    *((void *)this + 78) = TBaseFont::GetGlyphCount(*(TBaseFont **)(*((void *)this + 77) + 400));
    if (*((unsigned char *)this + 633)) {
      *((_WORD *)this + 316) = (*(uint64_t (**)(void))(**(void **)(*((void *)this + 77) + 400) + 104))(*(void *)(*((void *)this + 77) + 400)) | 0x100;
    }
    *((unsigned char *)this + 592) = 0;
    *((unsigned char *)this + 634) = *(unsigned char *)(*((void *)this + 19) + 90);
    *((double *)this + 80) = TRunGlue::InitScale(this);
    *((void *)this + 81) = v16;
  }
  return v2 < v5;
}

uint64_t TBaseFont::GetGlyphCount(TBaseFont *this)
{
  uint64_t result = *((void *)this + 25);
  if (!result)
  {
    uint64_t InitializedGraphicsFont = TBaseFont::GetInitializedGraphicsFont(this);
    uint64_t v4 = *(uint64_t (**)(TBaseFont *, uint64_t))(*(void *)this + 872);
    return v4(this, InitializedGraphicsFont);
  }
  return result;
}

double TRunGlue::InitScale(TRunGlue *this)
{
  uint64_t v2 = (int *)*((void *)this + 77);
  if (v2[12]) {
    initedouble d = v2 + 12;
  }
  else {
    initedouble d = TFont::InitStrikeMetrics((TFont *)v2);
  }
  double result = *((double *)inited + 5);
  if (*((unsigned char *)this + 634)) {
    return *((double *)inited + 6);
  }
  return result;
}

char *std::vector<unsigned char,TInlineBufferAllocator<unsigned char,128ul>>::__vallocate[abi:nn180100](void *a1, size_t __sz)
{
  if ((__sz & 0x8000000000000000) != 0) {
    abort();
  }
  uint64_t v5 = (char *)(a1 + 19);
  double result = (char *)a1[19];
  if (&result[__sz] <= v5) {
    *(void *)uint64_t v5 = &result[__sz];
  }
  else {
    double result = (char *)operator new(__sz);
  }
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[__sz];
  return result;
}

void *TRunGlue::InitLevelRange(void *this)
{
  uint64_t v1 = *(void *)(*this + 16);
  uint64_t v2 = (*(void *)(*this + 24) - v1) >> 3;
  if (*(_WORD *)(*this + 152))
  {
    int v4 = *(unsigned __int8 *)(this[19] + 224);
    uint64_t v5 = this[1];
    this[17] = v5;
    if (v5 + 1 >= v2)
    {
      uint64_t v8 = 1;
    }
    else
    {
      uint64_t v6 = v2 - v5;
      uint64_t v7 = v1 + 8 * v5;
      uint64_t v8 = 1;
      while (*(unsigned __int8 *)(*(void *)(*(void *)(v7 + 8 * v8) + 40) + 224) == v4)
      {
        if (v6 == ++v8)
        {
          uint64_t v8 = v6;
          break;
        }
      }
    }
    this[18] = v8;
  }
  else
  {
    uint64_t v3 = this[1];
    this[17] = v3;
    this[18] = v2 - v3;
  }
  return this;
}

void TTypesetter::FinishLayout(uint64_t a1, TCompositionEngine **this, const TCharStream *a3, char a4)
{
  uint64_t v5 = *this;
  uint64_t v6 = *(TRunGlue **)(a1 + 8);
  char v7 = TKerningEngine::PositionGlyphs((TKerningEngine *)this, v6, a3);
  char v9 = TCompositionEngine::AdjustSpacing(v5, v6, v8);
  char v11 = TBaselineEngine::AlignBaselines(v5, v6, v10);
  if ((*((_WORD *)v5 + 76) & 0x20) != 0 || (v7 | a4) | (v9 | v11))
  {
    TLine::SyncWithRuns(v5);
  }
}

uint64_t TCompositionEngine::AdjustSpacing(TCompositionEngine *this, TLine *a2, const TCharStream *a3)
{
  uint64_t v4 = MEMORY[0x1F4188790](this, a2);
  unint64_t v98 = v5;
  uint64_t v133 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void *)(v4 + 72);
  uint64_t v6 = *(void *)(v4 + 80);
  v99[0] = v7;
  v99[1] = v6;
  if (!v6) {
    return v6;
  }
  uint64_t v8 = v4;
  if ((*(_WORD *)(v4 + 154) & 0x200) == 0) {
    return 0;
  }
  if (CJKCompositionEngine::IsEnabled(void)::once != -1) {
    dispatch_once_f(&CJKCompositionEngine::IsEnabled(void)::once, 0, (dispatch_function_t)CJKCompositionEngine::IsEnabled(void)::$_0::__invoke);
  }
  if (gCJKCompositionRulesEnabled)
  {
    uint64_t v10 = *(void *)(v8 + 72);
    uint64_t v11 = *(void *)(v8 + 80);
    v100[0] = v10;
    v100[1] = v11;
    if (!v11 || (*(_WORD *)(v8 + 154) & 0x200) == 0) {
      return 0;
    }
    memcpy(__dst, &unk_184B87850, sizeof(__dst));
    TRunGlue::TRunGlue((TRunGlue *)__dst, (TLine *)v8);
    if (BYTE1(__dst[79])) {
      BYTE1(__dst[79]) = 0;
    }
    CFIndex v12 = __dst[1];
    CFIndex v13 = __dst[2];
    long long v95 = (TLine *)v8;
    if (!TRunGlue::length((TRunGlue *)__dst))
    {
      unsigned int v34 = 0;
      goto LABEL_87;
    }
    CFIndex v90 = v13;
    CFIndex v91 = v12;
    unsigned __int8 v121 = 0;
    long long v119 = 0u;
    *(_OWORD *)&v109[8] = 0u;
    long long v110 = 0u;
    long long v111 = 0u;
    long long v112 = 0u;
    long long v113 = 0u;
    long long v114 = 0u;
    long long v115 = 0u;
    long long v116 = 0u;
    long long v117 = 0u;
    long long v118 = 0u;
    uint64_t v15 = *((void *)v98 + 2);
    *(void *)uint64_t v109 = v98;
    *(void *)&long long v119 = v15;
    uint64_t v120 = 0;
    while (1)
    {
      unsigned int CompositionLanguage = TAttributes::GetCompositionLanguage((TAttributes *)(__dst[19] + 40), v14);
      if (CompositionLanguage >= 2)
      {
        unsigned int v17 = CompositionLanguage;
        int v18 = (unsigned char *)__dst[77];
        CFDataRef CommonTable = (const __CFData *)TBaseFont::GetCommonTable(*(TBaseFont **)(__dst[77] + 400), 1196643650, 0);
        if (CommonTable)
        {
          unint64_t v131 = 0xAAAAAAAAAAAAAAAALL;
          *(void *)&long long v20 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
          v130[5] = v20;
          v130[6] = v20;
          v130[3] = v20;
          v130[4] = v20;
          v130[1] = v20;
          v130[2] = v20;
          v130[0] = v20;
          uint64_t v127 = 0;
          uint64_t v128 = 0;
          uint64_t v129 = 0;
          char v132 = v130;
          unint64_t v108 = 0xAAAAAAAAAAAAAAAALL;
          long long v106 = v20;
          long long v107 = v20;
          long long v104 = v20;
          long long v105 = v20;
          *(_OWORD *)long long v103 = v20;
          memset(&v125[1], 0, 48);
          int64_t v123 = 0;
          long long v124 = 0uLL;
          LOBYTE(v125[0]) = 0;
          OTL::GCommon::GCommon((uint64_t)v103, 0, v18, CommonTable, (uint64_t)&v123, 0, 0);
          v103[0] = (uint64_t)&unk_1ED05FB20;
          uint64_t v126 = 0x484F504568776964;
          OTL::FeatureBuffer::FeatureBuffer<unsigned int const*>((char **)&v123, &v126, &v127);
          BOOL SingleSubstLookups = OTL::GSUB::GetSingleSubstLookups(v103, (uint64_t)&v123, (uint64_t)&v127);
          StringIndeCGFloat x = (uint64_t)&v123;
          std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&StringIndex);
          if (SingleSubstLookups)
          {
            memset(v125, 170, 0xC30uLL);
            int64_t v123 = 0;
            long long v124 = 0uLL;
            v125[390] = v125;
            uint64_t v22 = *(void *)(__dst[19] + 208);
            if (v22 >= 1)
            {
              uint64_t v23 = 0;
              char v24 = 0;
              double Advance = NAN;
              while (1)
              {
                StringIndeCGFloat x = TRunGlue::GetStringIndex((TRunGlue *)__dst, v23);
                Fulluint64_t Char = TCharStreamIterator::GetFullChar((TCharStreamIterator *)v109, &StringIndex, 0);
                if (FullChar > 65280)
                {
                  if ((FullChar - 65281) > 0x1E) {
                    goto LABEL_31;
                  }
                  int v27 = 1 << (FullChar - 1);
                  if ((v27 & 0x2980) != 0) {
                    goto LABEL_32;
                  }
                  if ((v27 & 0x46000001) != 0)
                  {
                    if (v17 != 2) {
                      goto LABEL_32;
                    }
                  }
                  else
                  {
LABEL_31:
                    if (FullChar == 65371 || FullChar == 65373) {
                      goto LABEL_32;
                    }
                  }
                }
                else if ((FullChar - 12289) <= 0x16 && ((1 << (FullChar - 1)) & 0x79FF83) != 0 {
                       || (FullChar - 8216) <= 5 && ((1 << (FullChar - 24)) & 0x33) != 0)
                }
                {
LABEL_32:
                  uint64_t v28 = (unsigned int *)v127;
                  int v29 = v128;
                  while (v28 != v29)
                  {
                    unsigned int v30 = *v28++;
                    unint64_t v3 = v3 & 0xFFFFFFFF00000000 | v30;
                    OTL::GlyphLookups::SetLookupInRange<false>((uint64_t *)&v123, v3, v23, 1);
                  }
                  if (v23 + 1 == v22)
                  {
                    uint64_t v31 = (*(uint64_t (**)(TCharStream *, uint64_t, uint64_t))(*(void *)v98 + 40))(v98, StringIndex, 2);
                    if (v31 + v32 == *(void *)(__dst[0] + 80) + *(void *)(__dst[0] + 72))
                    {
                      double Advance = TRunGlue::GetAdvance((TRunGlue *)__dst, v23);
                      char v24 = 1;
                    }
                  }
                }
                if (++v23 == v22)
                {
                  uint64_t v22 = *(void *)(__dst[19] + 208);
                  goto LABEL_40;
                }
              }
            }
            char v24 = 0;
            double Advance = NAN;
LABEL_40:
            StringIndeCGFloat x = v22 - 1;
            unint64_t v102 = 0xAAAAAAAAAAAAAA00;
            if (v24) {
              long long v33 = CJKCompositionEngine::SubstituteGlyphsForCJKComposition(TRunGlue &,TCharStream const&)::$_0::__invoke;
            }
            else {
              long long v33 = 0;
            }
            OTL::GSUB::ApplyLookups(v103, (TRunGlue *)__dst, __dst[3], &v123, &v121, (uint64_t)v33, (uint64_t)&StringIndex);
            if ((_BYTE)v102) {
              TStorageRange::SetOriginalFinalAdvanceWidth((TStorageRange *)(__dst[19] + 192), Advance);
            }
            StringIndeCGFloat x = (uint64_t)&v123;
            std::vector<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,TInlineBufferAllocator<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&StringIndex);
          }
          int64_t v123 = (unsigned __int16 *)&v127;
          std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v123);
        }
      }
      if (!TRunGlue::NextRunRange((TRunGlue *)__dst, 1))
      {
        unsigned int v34 = v121;
        uint64_t v8 = (uint64_t)v95;
        CFIndex v13 = v90;
        CFIndex v12 = v91;
LABEL_87:
        v134.CFIndex location = v12;
        v134.CFIndex length = v13;
        TRunGlue::SetRunRange((TRunGlue *)__dst, v134);
        unsigned int v94 = v34;
        if (*(void *)(v8 + 24) == *(void *)(v8 + 16)) {
          long long v51 = 0;
        }
        else {
          long long v51 = (TAttributes *)(*(void *)(*(void *)(*(void *)(v8 + 16)
        }
                                                      + 8 * TLine::FindRunWithCharIndex((TLine *)v8, v10, 1))
                                          + 40)
                              + 40);
        TAttributes::GetCompositionLanguage(v51, v50);
        uint64_t v127 = v10;
        memset(&v125[18], 0, 24);
        long long v124 = 0u;
        memset(v125, 0, 144);
        uint64_t v53 = *((void *)v98 + 2);
        int64_t v123 = (unsigned __int16 *)v98;
        v125[18] = v53;
        if (v11 < 1)
        {
          UChar32 v54 = 0;
          unsigned int CharacterClass = 8;
          uint64_t v56 = v10;
        }
        else
        {
          UChar32 v54 = TCharStreamIterator::GetFullChar((TCharStreamIterator *)&v123, v100, 0);
          unsigned int CharacterClass = CJKCompositionRules::GetCharacterClass(v54, 0);
          uint64_t v56 = v100[0];
        }
        UChar32 v57 = 0;
        uint64_t v92 = v11 + v10;
        uint64_t v58 = v56 + 1;
        while (1)
        {
          v103[0] = v58;
          uint64_t v59 = *(void *)(__dst[19] + 8);
          uint64_t v60 = *(void *)(__dst[19] + 16) + v59;
          uint64_t v61 = TAttributes::GetCompositionLanguage((TAttributes *)(__dst[19] + 40), v52);
          uint64_t v62 = v61;
          if (v58 < v59 || v61 < 2)
          {
            uint64_t v127 = v60 - 1;
            UChar32 v54 = TCharStreamIterator::GetFullChar((TCharStreamIterator *)&v123, &v127, 0);
            uint64_t v64 = v58;
            uint64_t v58 = v60;
            goto LABEL_206;
          }
          uint64_t v97 = v60;
          if (v58 < v60) {
            break;
          }
          uint64_t v64 = v58;
          uint64_t v58 = v60;
LABEL_206:
          if (!TRunGlue::NextRunRange((TRunGlue *)__dst, 1))
          {
            LOBYTE(StringIndex) = -86;
            if (v57 && v64 == v92)
            {
              uint64_t v6 = v94;
              if (CJKCompositionRules::ShouldGlyphImageRightFlush(v62, 0, v57, (BOOL *)&StringIndex))
              {
                *(void *)&v109[8] = 0;
                *(void *)uint64_t v109 = 0;
                uint64_t v6 = 1;
                *(void *)&v109[16] = 0xAAAAAAAA00000001;
                CJKAddSpace((uint64_t)v95, v98, v127, -1, (uint64_t)v109, 1, StringIndex);
              }
            }
            else
            {
              uint64_t v6 = v94;
            }
            std::__function::__value_func<BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::~__value_func[abi:nn180100](&__dst[70]);
            int64_t v123 = (unsigned __int16 *)&__dst[46];
            std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v123);
            int64_t v123 = (unsigned __int16 *)&__dst[26];
            std::vector<unsigned char,TInlineBufferAllocator<unsigned char,128ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v123);
            int64_t v123 = (unsigned __int16 *)&__dst[7];
            std::vector<std::pair<UScriptCode,long>,TInlineBufferAllocator<std::pair<UScriptCode,long>,1ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v123);
            return v6;
          }
        }
        uint64_t v65 = v127;
        __CGFloat b = v61 - 2;
        uint64_t v58 = v97;
        while (2)
        {
          UChar32 v57 = TCharStreamIterator::GetFullChar((TCharStreamIterator *)&v123, v103, 0);
          int v66 = 1 << u_charType(v57);
          if (v57 != 8205 && (v66 & 0x10080) != 0)
          {
            uint64_t v67 = v103[0];
            goto LABEL_199;
          }
          *(void *)&v109[8] = 0;
          *(void *)uint64_t v109 = 0;
          *(void *)&v109[16] = 0xAAAAAAAA00000000;
          if (CharacterClass == 8) {
            unsigned int CharacterClass = CJKCompositionRules::GetCharacterClass(v54, 0);
          }
          unsigned int v68 = CJKCompositionRules::GetCharacterClass(v57, v66);
          BOOL v69 = CharacterClass != 4 || CJKCompositionEngine::GetCharacterClass(v54, 0) != 7;
          unsigned int v70 = CharacterClass & 0xFFFFFFFE;
          BOOL v71 = v62 != 4;
          BOOL v72 = (CharacterClass & 0xFFFFFFFE) == 2;
          if ((CharacterClass & 0xFFFFFFFE) != 2) {
            BOOL v71 = 1;
          }
          if (v68 == 7) {
            BOOL v72 = 0;
          }
          if ((v68 | CharacterClass) < 2) {
            BOOL v72 = 1;
          }
          int v73 = v68 & 6;
          if (CharacterClass == 4 && v73 == 2) {
            BOOL v72 = 1;
          }
          if (v68 != 4) {
            BOOL v71 = 1;
          }
          int v75 = v72 && v71;
          v109[16] = v72 && v71;
          if (v68 <= 1 && CharacterClass != 7) {
            goto LABEL_132;
          }
          BOOL v76 = v68 == 4;
          BOOL v77 = v70 == 2;
          if (v73 == 2) {
            BOOL v76 = 1;
          }
          else {
            BOOL v77 = 0;
          }
          if (CharacterClass != 4) {
            BOOL v76 = 0;
          }
          if (v77 || v76) {
LABEL_132:
          }
            LOBYTE(v76) = v62 != 4 || CharacterClass != 4 || v68 > 1;
          v109[17] = v76;
          BOOL v81 = v70 == 2 && CJKCompositionEngine::GetCharacterClass(v54, 0) == 4 && v73 == 2;
          v109[18] = v81;
          BOOL v83 = v68 <= 1 && CJKCompositionEngine::GetCharacterClass(v57, 0) == 1 && CharacterClass < 2;
          v109[19] = v83;
          if ((v54 - 48) <= 9)
          {
            uint64_t v84 = 0x3FA47AE147AE147BLL;
            if (v57 == 26085) {
              goto LABEL_196;
            }
            uint64_t v84 = 0x3FA47AE147AE147BLL;
            if (v57 == 26376) {
              goto LABEL_196;
            }
          }
          if (v54 == 26376 || v54 == 26085)
          {
            uint64_t v84 = 0x3FA47AE147AE147BLL;
            if ((v57 - 48) < 0xA) {
              goto LABEL_196;
            }
          }
          if (CharacterClass == 7 && v68 == 6)
          {
            if (v54 == 41)
            {
              unsigned int CharacterClass = 5;
              goto LABEL_173;
            }
            unsigned int CharacterClass = 7;
            unsigned int v85 = 6;
          }
          else
          {
            if (CharacterClass == 6 && v68 == 7)
            {
              unsigned int v85 = v57 == 40 ? 5 : 7;
              unsigned int CharacterClass = 6;
            }
            else
            {
LABEL_173:
              if (v57 == 8216)
              {
                unsigned int v85 = v68;
                if (CharacterClass == 5)
                {
                  v109[17] = 0;
                  unsigned int v85 = 5;
                  goto LABEL_181;
                }
              }
              else
              {
                unsigned int v85 = v68;
              }
            }
            if (v54 == 8217 && v85 == 5)
            {
              int v75 = 0;
              v109[16] = 0;
              unsigned int CharacterClass = 5;
            }
          }
LABEL_181:
          if (v62 == 4)
          {
            if ((v54 & 0xFFFFFFFB) == 0x2018 && v68 <= 1)
            {
              v109[17] = 0;
              BOOL v69 = 1;
            }
            else
            {
              BOOL v69 = 1;
              if ((v57 & 0xFFFFFFFB) == 0x2019 && v70 == 2)
              {
                int v75 = 0;
                v109[16] = 0;
              }
            }
          }
          uint64_t v86 = CJKCompositionRules::GetCharacterSpacing(CTCompositionLanguage,BOOL,unsigned int,CJKCompositionRules::CharacterClass,unsigned int,unsigned int,CJKCompositionRules::CharacterClass*)::kTable[64 * __b + 8 * CharacterClass + v85];
          long long v87 = CJKCompositionRules::GetCharacterSpacing(CTCompositionLanguage,BOOL,unsigned int,CJKCompositionRules::CharacterClass,unsigned int,unsigned int,CJKCompositionRules::CharacterClass*)::kSpacingValues[v86];
          *(_OWORD *)uint64_t v109 = v87;
          BOOL v88 = v68 < 2 || v85 == 5;
          BOOL v89 = v88;
          if (!v69)
          {
            uint64_t v84 = 0x3FD999999999999ALL;
            if (v89)
            {
LABEL_196:
              *(void *)uint64_t v109 = v84;
              *(void *)&v109[8] = 0;
              uint64_t v67 = v103[0];
              goto LABEL_197;
            }
          }
          uint64_t v67 = v103[0];
          if (*(double *)&v87 != 0.0 || ((0xDB9uLL >> v86) & 1) == 0 || v75)
          {
LABEL_197:
            CJKAddSpace((uint64_t)v95, v98, v65, v67, (uint64_t)v109, 0, 0);
            unsigned int v94 = 1;
          }
          uint64_t v65 = v67;
          unsigned int CharacterClass = v68;
          UChar32 v54 = v57;
          uint64_t v58 = v97;
LABEL_199:
          uint64_t v64 = v67 + 1;
          v103[0] = v67 + 1;
          if (v67 + 1 >= v58)
          {
            uint64_t v127 = v65;
            goto LABEL_206;
          }
          continue;
        }
      }
    }
  }
  long long v96 = (TLine *)v8;
  if (*(void *)(v8 + 24) == *(void *)(v8 + 16)) {
    long long v35 = 0;
  }
  else {
    long long v35 = (unsigned __int8 *)(*(void *)(*(void *)(*(void *)(v8 + 16)
  }
                                                    + 8 * TLine::FindRunWithCharIndex((TLine *)v8, v7, 1))
                                        + 40)
                            + 40);
  int v36 = TAttributes::GetCompositionLanguage((TAttributes *)v35, v5);
  *(_DWORD *)uint64_t v109 = 9;
  memset(&v125[18], 0, 24);
  long long v124 = 0u;
  memset(v125, 0, 144);
  uint64_t v37 = *((void *)v98 + 2);
  uint64_t v38 = v6 + v7;
  int64_t v123 = (unsigned __int16 *)v98;
  v125[18] = v37;
  if (v6 < 1)
  {
    UChar32 v39 = 0;
    uint64_t v40 = v7;
  }
  else
  {
    UChar32 v39 = TCharStreamIterator::GetFullChar((TCharStreamIterator *)&v123, v99, 0);
    *(_DWORD *)uint64_t v109 = ChineseCompositionRules::GetCharacterClass(v39, 0, v36);
    uint64_t v40 = v99[0];
  }
  int v41 = v35[50];
  __dst[0] = v40 + 1;
  if (v40 + 1 >= v38)
  {
    uint64_t v6 = 0;
  }
  else
  {
    uint64_t v6 = 0;
    do
    {
      UChar32 v42 = TCharStreamIterator::GetFullChar((TCharStreamIterator *)&v123, __dst, 0);
      int v43 = 1 << u_charType(v42);
      if (v42 == 8205 || (v43 & 0x10080) == 0)
      {
        switch(ChineseCompositionRules::GetCharacterSpacing(v36, v41 != 0, v39, *(int *)v109, v42, v43, (unsigned int *)v109))
        {
          case 1u:
            uint64_t v44 = __dst[0];
            double v45 = 0.25;
            goto LABEL_73;
          case 2u:
            uint64_t v44 = __dst[0];
            double v45 = 0.0;
            goto LABEL_71;
          case 3u:
            uint64_t v44 = __dst[0];
            double v45 = 0.125;
            goto LABEL_73;
          case 4u:
            uint64_t v44 = __dst[0];
            double v45 = 0.0;
            double v46 = 0.125;
            goto LABEL_77;
          case 5u:
            uint64_t v44 = __dst[0];
            double v46 = 0.0;
            uint64_t v47 = (uint64_t)v96;
            uint64_t v48 = v98;
            uint64_t v49 = v7;
            double v45 = 0.04;
            goto LABEL_78;
          case 6u:
            uint64_t v44 = __dst[0];
            double v45 = 0.5;
            goto LABEL_73;
          case 7u:
            uint64_t v44 = __dst[0];
            double v45 = 0.0;
            double v46 = 0.5;
            goto LABEL_77;
          case 8u:
            uint64_t v44 = __dst[0];
            double v45 = 0.25;
            goto LABEL_71;
          case 9u:
            uint64_t v44 = __dst[0];
            double v45 = 0.5;
LABEL_71:
            double v46 = 0.25;
            goto LABEL_77;
          case 0xAu:
            uint64_t v44 = __dst[0];
            double v45 = -0.25;
LABEL_73:
            double v46 = 0.0;
            goto LABEL_77;
          case 0xBu:
            uint64_t v44 = __dst[0];
            double v45 = 0.0;
            goto LABEL_76;
          case 0xCu:
            uint64_t v44 = __dst[0];
            double v45 = -0.25;
LABEL_76:
            double v46 = -0.25;
LABEL_77:
            uint64_t v47 = (uint64_t)v96;
            uint64_t v48 = v98;
            uint64_t v49 = v7;
LABEL_78:
            AddSpace(v47, v48, v49, v45, v44, v46);
            uint64_t v6 = 1;
            break;
          default:
            uint64_t v44 = __dst[0];
            break;
        }
        UChar32 v39 = v42;
        uint64_t v7 = v44;
      }
      else
      {
        uint64_t v44 = __dst[0];
      }
      __dst[0] = v44 + 1;
    }
    while (v44 + 1 < v38);
  }
  if (v38 > 1
    && ChineseCompositionRules::GetCharacterSpacing(v36, v41 != 0, v39, *(int *)v109, 0, 0, (unsigned int *)v109) == 10)
  {
    AddSpace((uint64_t)v96, v98, v7, -0.25, -1, 0.0);
    return 1;
  }
  return v6;
}

uint64_t TBaselineEngine::AlignBaselines(TBaselineEngine *this, TLine *a2, const TCharStream *a3)
{
  v107[4] = *(id *)MEMORY[0x1E4F143B8];
  __int16 v87 = *((_WORD *)this + 77);
  if ((v87 & 0x110) == 0)
  {
    char v78 = 0;
    return v78 & 1;
  }
  memset(v105, 170, sizeof(v105));
  __p = 0;
  long long v103 = 0;
  uint64_t v104 = 0;
  long long v106 = v105;
  uint64_t v99 = &unk_1ED05F868;
  TScriptRun::GetScriptRunsForLine(this, (uint64_t)a2, (uint64_t)&v99, &__p);
  uint64_t v5 = (char *)__p;
  uint64_t v86 = v103;
  if (__p == v103)
  {
    char v78 = 0;
    if (!__p) {
      return v78 & 1;
    }
    goto LABEL_192;
  }
  char v80 = 0;
  int v84 = 0;
  int v6 = 0;
  double v7 = NAN;
  int v91 = -1431655936;
  unsigned int v85 = a2;
  do
  {
    int v90 = v6;
    char v9 = *(TLine **)v5;
    uint64_t v8 = (TLine *)*((void *)v5 + 1);
    int v10 = *((_DWORD *)v5 + 4);
    BOOL v11 = 1;
    uint64_t v12 = *(void *)(*(void *)(*((void *)this + 2) + 8 * TLine::FindRunWithCharIndex(this, *(void *)v5, 1)) + 48);
    if ((v87 & 0x100) == 0)
    {
      uint64_t v13 = *(void *)(v12 + 184);
      if (v13)
      {
        if (*(unsigned char *)(v13 + 264)) {
          v13 += 136;
        }
        else {
          uint64_t v13 = 0;
        }
      }
      BOOL v11 = v13 != 0;
    }
    uint64_t v14 = *(void *)(*(void *)(atomic_load_explicit((atomic_ullong *volatile)(v12 + 56), memory_order_acquire) + 40)
                    + 400);
    int v15 = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 384))(v14);
    if (!v11 && (v15 & 1) == 0 && (*(_WORD *)(v12 + 178) & 0x2000) == 0)
    {
      int v6 = 0;
      int v84 = 0;
      goto LABEL_174;
    }
    int v88 = v15;
    memcpy(__dst, &unk_184BAB810, sizeof(__dst));
    __dst[0] = this;
    __dst[1] = v85;
    __dst[2] = v9;
    __dst[3] = v8;
    char v16 = 3;
    LODWORD(__dst[4]) = v10;
    if (v10 > 1818324576)
    {
      if (v10 <= 1936286819)
      {
        if (v10 > 1852143456)
        {
          if (v10 > 1935766897)
          {
            if (v10 == 1935766898) {
              goto LABEL_67;
            }
            int v17 = 1936224868;
          }
          else
          {
            if (v10 == 1852143457) {
              goto LABEL_67;
            }
            int v17 = 1869773153;
          }
        }
        else
        {
          if (v10 <= 1836016744)
          {
            if (v10 != 1818324577)
            {
              if (v10 != 1835103336) {
                goto LABEL_180;
              }
              char v16 = 4;
            }
            goto LABEL_67;
          }
          if (v10 == 1836016745) {
            goto LABEL_67;
          }
          int v17 = 1836344681;
        }
      }
      else if (v10 <= 1952541553)
      {
        if (v10 > 1936685422)
        {
          if (v10 == 1936685423) {
            goto LABEL_67;
          }
          int v17 = 1937337455;
        }
        else
        {
          if (v10 == 1936286820) {
            goto LABEL_67;
          }
          int v17 = 1936289380;
        }
      }
      else if (v10 <= 1953063539)
      {
        if (v10 == 1952541554) {
          goto LABEL_67;
        }
        int v17 = 1952541813;
      }
      else
      {
        if (v10 == 1953063540 || v10 == 1953067624) {
          goto LABEL_67;
        }
        int v17 = 2053205602;
      }
      goto LABEL_66;
    }
    if (v10 <= 1735750260)
    {
      if (v10 > 1667785068)
      {
        if (v10 > 1735549293)
        {
          if (v10 == 1735549294) {
            goto LABEL_67;
          }
          int v17 = 1735748210;
        }
        else
        {
          if (v10 == 1667785069) {
            goto LABEL_67;
          }
          int v17 = 1684371041;
        }
      }
      else if (v10 > 1650814566)
      {
        if (v10 == 1650814567) {
          goto LABEL_67;
        }
        int v17 = 1651663208;
      }
      else
      {
        if (!v10)
        {
          char v16 = -1;
          goto LABEL_67;
        }
        int v17 = 1650551913;
      }
      goto LABEL_66;
    }
    if (v10 <= 1784772192)
    {
      if (v10 > 1751215720)
      {
        if (v10 == 1751215721)
        {
LABEL_59:
          char v16 = 2;
          goto LABEL_67;
        }
        int v18 = 1784769903;
      }
      else
      {
        if (v10 == 1735750261) {
          goto LABEL_67;
        }
        int v18 = 1751215719;
      }
      if (v10 != v18) {
        goto LABEL_180;
      }
      goto LABEL_59;
    }
    if (v10 <= 1801547360)
    {
      if (v10 == 1784772193) {
        goto LABEL_67;
      }
      int v17 = 1801546857;
      goto LABEL_66;
    }
    if (v10 == 1801547361) {
      goto LABEL_59;
    }
    if (v10 != 1802002802)
    {
      int v17 = 1802791017;
LABEL_66:
      if (v10 != v17) {
LABEL_180:
      }
        char v16 = 0;
    }
LABEL_67:
    uint64_t v19 = 0;
    BOOL v83 = (TAttributes *)(v12 + 40);
    BYTE4(__dst[4]) = v16;
    do
    {
      long long v20 = &__dst[v19];
      *((unsigned char *)v20 + 80) = 0;
      *((unsigned char *)v20 + 88) = 0;
      v19 += 2;
    }
    while (v19 != 16);
    BOOL v89 = v11;
    uint64_t v92 = v8;
    for (uint64_t i = 0; i != 16; i += 2)
    {
      uint64_t v22 = &__dst[i];
      *((unsigned char *)v22 + 208) = 0;
      *((unsigned char *)v22 + 216) = 0;
    }
    __int16 v23 = *((_WORD *)this + 77);
    v93.CGFloat a = -3.72066208e-103;
    v93.CGFloat b = -3.72066208e-103;
    TLine::GetClusterRange(this, v85, (uint64_t)v9, 2, &v93, 0, 0);
    CGFloat a = v93.a;
    CGFloat b = v93.b;
    v93.CGFloat a = -3.72066208e-103;
    v93.CGFloat b = -3.72066208e-103;
    TLine::GetClusterRange(__dst[0], (void *)__dst[1], (uint64_t)v92 + (void)v9 - 1, 2, &v93, 0, 0);
    if (*(uint64_t *)&v93.a >= *(uint64_t *)&a) {
      CGFloat v26 = a;
    }
    else {
      CGFloat v26 = v93.a;
    }
    if (*(void *)&b + *(void *)&a <= *(void *)&v93.b + *(void *)&v93.a) {
      uint64_t v27 = *(void *)&v93.b + *(void *)&v93.a;
    }
    else {
      uint64_t v27 = *(void *)&b + *(void *)&a;
    }
    uint64_t v28 = *((void *)__dst[0] + 2);
    uint64_t v29 = *((void *)__dst[0] + 3);
    if (v28 == v29)
    {
      unsigned int v34 = *(TLine **)&v26;
      uint64_t v31 = *((void *)__dst[0] + 2);
      *(void *)&long long v32 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v32 + 1) = 0xAAAAAAAAAAAAAAAALL;
    }
    else
    {
      uint64_t v30 = 0;
      uint64_t v31 = *((void *)__dst[0] + 2);
      *(void *)&long long v32 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v32 + 1) = 0xAAAAAAAAAAAAAAAALL;
      while (1)
      {
        uint64_t v33 = *(void *)(*(void *)(*(void *)v31 + 40) + 208) + v30;
        if (v33 > *(uint64_t *)&v26) {
          break;
        }
        v31 += 8;
        uint64_t v30 = v33;
        if (v31 == v29)
        {
          unsigned int v34 = *(TLine **)&v26;
          uint64_t v31 = *((void *)__dst[0] + 3);
          goto LABEL_84;
        }
      }
      unsigned int v34 = (TLine *)(*(void *)&v26 - v30);
    }
LABEL_84:
    long long v35 = (TLine *)(v27 - *(void *)&v26);
    if (v31 != v29)
    {
      uint64_t v36 = 0;
      uint64_t v37 = v31;
      while (1)
      {
        v36 += *(void *)(*(void *)(*(void *)v37 + 40) + 208);
        if (v36 >= (uint64_t)v35 + (uint64_t)v34) {
          break;
        }
        v37 += 8;
        if (v37 == v29) {
          goto LABEL_90;
        }
      }
      uint64_t v29 = v37;
    }
LABEL_90:
    __dst[8] = v34;
    __dst[9] = v35;
    __dst[6] = (TLine *)((v31 - v28) >> 3);
    __dst[7] = (TLine *)(((v29 - v28) >> 3) - (unint64_t)__dst[6] + 1);
    uint64_t v38 = *(atomic_ullong **)(*(void *)(*((void *)this + 2) + 8 * (uint64_t)__dst[6]) + 40);
    __dst[5] = (TLine *)v38;
    atomic_ullong v39 = v38[23];
    if (v39)
    {
      int v40 = *(unsigned __int8 *)(v39 + 264);
      BOOL v41 = *(unsigned char *)(v39 + 264) == 0;
      if (*(unsigned char *)(v39 + 264)) {
        BOOL v42 = 0;
      }
      else {
        BOOL v42 = (v23 & 0x100) == 0;
      }
      if (v42) {
        goto LABEL_144;
      }
      atomic_ullong v43 = v39 + 136;
      if (*(unsigned char *)(v39 + 264)) {
        atomic_ullong v44 = v39 + 136;
      }
      else {
        atomic_ullong v44 = 0;
      }
      unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(v39 + 272), memory_order_acquire);
      double v46 = @"CTBaselineVerticalFont";
      if ((v23 & 0x100) == 0) {
        double v46 = 0;
      }
      if (explicit) {
        uint64_t v47 = (__CFString *)explicit;
      }
      else {
        uint64_t v47 = v46;
      }
      if (v47) {
        BOOL v48 = 0;
      }
      else {
        BOOL v48 = (v23 & 0x100) == 0;
      }
      if (v48)
      {
        if (v40) {
          goto LABEL_135;
        }
        goto LABEL_144;
      }
      char v81 = v41;
      atomic_ullong v82 = v44;
    }
    else
    {
      if ((v23 & 0x100) == 0) {
        goto LABEL_144;
      }
      atomic_ullong v82 = 0;
      char v81 = 1;
      uint64_t v47 = @"CTBaselineVerticalFont";
    }
    v107[0] = 0;
    if (CFEqual(v47, @"CTBaselineOriginalFont"))
    {
      TAttributes::OriginalFont(v38 + 5, (atomic_ullong *)&v93);
    }
    else
    {
      if (CFEqual(v47, @"CTBaselineVerticalFont"))
      {
        TAttributes::OriginalFont(v38 + 5, (atomic_ullong *)&v101);
        VerticalCopyOf((CTFontRef)atomic_load_explicit((atomic_ullong *volatile)&v101, memory_order_acquire), (CTFontRef *)&v93);

        CGFloat v49 = *(double *)&v101;
        goto LABEL_119;
      }
      *(void *)&v93.CGFloat a = (id)_CTFontEnsureFontRef(v47);
    }

    if ((v23 & 0x100) == 0)
    {
      int v50 = 0;
      goto LABEL_120;
    }
    VerticalCopyOf((CTFontRef)atomic_load_explicit((atomic_ullong *volatile)v107, memory_order_acquire), (CTFontRef *)&v93);

    CGFloat v49 = v93.a;
LABEL_119:

    int v50 = 1;
LABEL_120:
    uint64_t v51 = *(void *)(atomic_load_explicit((atomic_ullong *volatile)v107, memory_order_acquire) + 40);
    TBaselineEngine::GetBaselineInfo(v51, v10, (uint64_t)&__dst[26]);
    unint64_t v52 = (const __CTFont *)atomic_load_explicit(v38 + 7, memory_order_acquire);
    if (!v50
      || (uint64_t v53 = (const __CTFont *)atomic_load_explicit((atomic_ullong *volatile)v107, memory_order_acquire), v53 == v52)
      || (v52 ? (BOOL v54 = v53 == 0) : (BOOL v54 = 1), !v54 && CFEqual(v53, v52)))
    {
LABEL_133:
      TBaselineEngineImplementation::SynthesizeMissingBaselines(v51, (uint64_t)&__dst[26], 0.0);
    }
    else
    {
      uint64_t v55 = 0;
      while (LOBYTE(__dst[v55 + 27]))
      {
        v55 += 2;
        if (v55 == 16) {
          goto LABEL_133;
        }
      }
      BOOL v72 = CTFontCopyFontDescriptor(v52);
      int v73 = v72;
      uint64_t v74 = *(_OWORD **)(v51 + 40);
      if (!v74) {
        uint64_t v74 = (_OWORD *)MEMORY[0x1E4F1DAB8];
      }
      long long v76 = v74[1];
      long long v75 = v74[2];
      *(_OWORD *)&v93.CGFloat a = *v74;
      *(_OWORD *)&v93.c = v76;
      *(_OWORD *)&v93.tCGFloat x = v75;
      id v101 = CTFontCreateWithFontDescriptor(v72, *(CGFloat *)(v51 + 16), &v93);
      VerticalCopyOf((CTFontRef)atomic_load_explicit((atomic_ullong *volatile)&v101, memory_order_acquire), (CTFontRef *)&v100);

      uint64_t v77 = *(void *)(atomic_load_explicit((atomic_ullong *volatile)&v101, memory_order_acquire) + 40);
      TBaselineEngine::GetBaselineInfo(v77, v10, (uint64_t)&__dst[26]);
      TBaselineEngineImplementation::SynthesizeMissingBaselines(v77, (uint64_t)&__dst[26], 0.0);
    }
    *(void *)&long long v32 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v32 + 1) = 0xAAAAAAAAAAAAAAAALL;
    atomic_ullong v43 = v82;
    if ((v81 & 1) == 0)
    {
LABEL_135:
      uint64_t v56 = 0;
      UChar32 v57 = (unsigned char *)(v43 + 8);
      uint64_t v58 = &__dst[27];
      do
      {
        if (*v57)
        {
          *(v58 - 1) = (TLine *)*((void *)v57 - 1);
          *(unsigned char *)uint64_t v58 = 1;
          if (v56 != 5)
          {
            if (v56 != 2) {
              goto LABEL_143;
            }
            uint64_t v59 = &__dst[39];
            if (!LOBYTE(__dst[39])) {
              goto LABEL_143;
            }
LABEL_142:
            *(unsigned char *)uint64_t v59 = 0;
            goto LABEL_143;
          }
          uint64_t v59 = &__dst[41];
          if (LOBYTE(__dst[41])) {
            goto LABEL_142;
          }
        }
LABEL_143:
        ++v56;
        v58 += 2;
        v57 += 16;
      }
      while (v56 != 8);
    }
LABEL_144:
    unint64_t v97 = 0xAAAAAAAAAAAAAAAALL;
    long long v95 = v32;
    long long v96 = v32;
    *(_OWORD *)&v93.tCGFloat x = v32;
    long long v94 = v32;
    *(_OWORD *)&v93.CGFloat a = v32;
    *(_OWORD *)&v93.c = v32;
    TOpenTypeBaselineEngine::TOpenTypeBaselineEngine(&v93, (uint64_t)__dst);
    if ((*(uint64_t (**)(CGAffineTransform *))(*(void *)&v93.a + 24))(&v93))
    {
      if (v88)
      {
        v107[0] = &unk_1ED061280;
        v107[1] = &v93;
        v107[3] = v107;
        BOOL v60 = TBaselineEngineImplementation::ApplyToRuns((uint64_t)&v93, (uint64_t)v107);
        std::__function::__value_func<BOOL ()(TRun &)>::~__value_func[abi:nn180100](v107);
        v80 |= v60;
      }
      if (!v89)
      {
        *(void *)&v93.CGFloat a = &unk_1ED05F2F8;

        goto LABEL_161;
      }
      char v61 = TBaselineEngineImplementation::AlignBaselinesForRuns((TBaselineEngineImplementation *)&v93);
      *(void *)&v93.CGFloat a = &unk_1ED05F2F8;

      if (v61)
      {
LABEL_152:
        char v64 = 1;
        goto LABEL_154;
      }
    }
    else
    {
      *(void *)&v93.CGFloat a = &unk_1ED05F2F8;
    }
    *(void *)&long long v62 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v62 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&v93.c = v62;
    *(_OWORD *)&v93.tCGFloat x = v62;
    *(_OWORD *)&v93.CGFloat a = v62;
    TAATBslnEngine::TAATBslnEngine(&v93, (uint64_t)__dst);
    BOOL v63 = TAATBslnEngine::AlignBaselinesForRuns((TAATBslnEngine *)&v93);
    TAATBslnEngine::~TAATBslnEngine((TAATBslnEngine *)&v93);
    if (v63) {
      goto LABEL_152;
    }
    v93.tCGFloat x = -3.72066208e-103;
    *(void *)&long long v65 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v65 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&v93.CGFloat a = v65;
    *(_OWORD *)&v93.c = v65;
    TGenericBaselineEngine::TGenericBaselineEngine(&v93, (uint64_t)__dst);
    char v64 = TBaselineEngineImplementation::AlignBaselinesForRuns((TBaselineEngineImplementation *)&v93);
    *(void *)&v93.CGFloat a = &unk_1ED05F2F8;

LABEL_154:
    if ((*(_WORD *)(v12 + 178) & 0x2000) != 0)
    {
      if (v64)
      {
        uint64_t v66 = *(void *)(v12 + 160);
        double OriginalValueOf = 0.0;
        if (v66)
        {
          double v68 = *(double *)(v66 + 48);
          CFStringRef v69 = *(const __CFString **)(v66 + 40);
          if (v69) {
            double OriginalValueOf = TAttributes::GetOriginalValueOf((atomic_ullong *)v83, v69);
          }
        }
        else
        {
          double v68 = 0.0;
        }
        double v7 = v68 - OriginalValueOf;
        int v6 = 1;
LABEL_172:
        int v84 = 1;
        goto LABEL_173;
      }
      if (v84)
      {
        if (v91 == v10)
        {
          if (v90)
          {
            if (v9 != *(TLine **)(v12 + 8) || v92 != *(TLine **)(v12 + 16))
            {
              int v10 = v91;
              int v84 = 1;
              int v6 = 1;
              goto LABEL_173;
            }
            uint64_t v70 = *(void *)(v12 + 160);
            if (v70) {
              double v71 = *(double *)(v70 + 48);
            }
            else {
              double v71 = 0.0;
            }
            int v6 = 1;
            if (v71 != v7 + v71)
            {
              *(double *)(TAttributes::EnsureRareData(v83) + 48) = v7 + v71;
              *(unsigned char *)(v12 + 89) = 1;
            }
            int v10 = v91;
          }
          else
          {
            int v10 = v91;
            int v6 = 0;
          }
          goto LABEL_172;
        }
        int v10 = v91;
LABEL_162:
        int v6 = v90;
        goto LABEL_173;
      }
LABEL_161:
      int v10 = v91;
      goto LABEL_162;
    }
    int v6 = 0;
    int v84 = 0;
    int v10 = v91;
LABEL_173:
    int v91 = v10;
LABEL_174:
    v5 += 24;
  }
  while (v5 != v86);
  uint64_t v5 = (char *)__p;
  char v78 = v80;
  if (!__p) {
    return v78 & 1;
  }
LABEL_192:
  long long v103 = v5;
  if (v105 > v5 || &v106 <= (unsigned char **)v5) {
    operator delete(v5);
  }
  return v78 & 1;
}

void *TLine::LinkRuns(void *this)
{
  uint64_t v2 = this[2];
  uint64_t v1 = this[3];
  if (v2 != v1)
  {
    unint64_t v3 = *(void **)(*(void *)v2 + 48);
    this[11] = v3;
    if (v3)
    {
      v3[4] = 0;
      uint64_t v4 = v2 + 8;
      if (v4 == v1)
      {
LABEL_4:
        uint64_t v5 = v3;
LABEL_9:
        this[12] = v5;
        double v7 = v5 + 3;
        goto LABEL_10;
      }
    }
    else
    {
      uint64_t v4 = v2 + 8;
      if (v4 == v1)
      {
        double v7 = this + 12;
LABEL_10:
        *double v7 = 0;
        return this;
      }
    }
    uint64_t v6 = v3[1];
    while (1)
    {
      uint64_t v5 = *(void **)(*(void *)v4 + 48);
      v6 += v3[2];
      if (v6 != v5[1]) {
        goto LABEL_4;
      }
      v5[4] = v3;
      v3[3] = v5;
      v4 += 8;
      unint64_t v3 = v5;
      if (v4 == v1) {
        goto LABEL_9;
      }
    }
  }
  return this;
}

uint64_t TTypesetter::CanLayout(TTypesetter *this)
{
  if ((uint64_t)(*((void *)this + 3) - *((void *)this + 2)) >= 8)
  {
    CanLayoUText ut = TTypesetter::CanLayout((TTypesetter *)*((unsigned __int8 *)this + 256), *(void *)(*((void *)this + 27) + 16));
    uint64_t result = 1;
    if (CanLayout) {
      return result;
    }
    *((unsigned char *)this + 257) = 1;
  }
  return 0;
}

uint64_t TTypesetter::CanLayout(TTypesetter *this, uint64_t a2)
{
  char v3 = (char)this;
  if (qword_1EB2CDEC8 == -1)
  {
    if (this) {
      return 1;
    }
  }
  else
  {
    dispatch_once_f(&qword_1EB2CDEC8, 0, (dispatch_function_t)CheckForUnboundedLayout(BOOL)::$_0::__invoke);
    if (v3) {
      return 1;
    }
  }
  if (byte_1EB2CDEC1) {
    int v5 = 1;
  }
  else {
    int v5 = dyld_program_sdk_at_least();
  }
  uint64_t result = 1;
  if (a2 >= 10241 && v5)
  {
    if (_MergedGlobals_6)
    {
      return 0;
    }
    else
    {
      if (os_variant_has_internal_diagnostics()) {
        CFLog();
      }
      uint64_t result = 0;
      _MergedGlobals_6 = 1;
    }
  }
  return result;
}

uint64_t TTypesetter::FinishEncoding(uint64_t a1, TShapingEngine *this, const TCharStream *a3)
{
  char v3 = this;
  uint64_t v4 = a1;
  v89[12] = *MEMORY[0x1E4F143B8];
  unsigned int v5 = *(unsigned __int8 *)a3;
  uint64_t v6 = (v5 >> 4) & 1;
  double v7 = *(TLine **)this;
  if ((*(_WORD *)(*(void *)this + 154) & 0x100) != 0)
  {
    char v60 = *(unsigned char *)a3;
    char v80 = *(void ****)(a1 + 8);
    uint64_t v86 = 0;
    long long v85 = 0u;
    memset(v84, 0, sizeof(v84));
    long long v82 = 0u;
    long long v83 = 0u;
    long long v81 = 0u;
    *(void *)&long long v85 = v80[2];
    uint64_t v8 = *((void *)v7 + 3) - *((void *)v7 + 2);
    id v77 = 0;
    uint64_t v78 = 0;
    id v75 = 0;
    id v76 = 0;
    if (v8 >= 1)
    {
      int v56 = (v5 >> 4) & 1;
      char v9 = 0;
      int v10 = 0;
      uint64_t v11 = 0;
      int64_t v12 = (unint64_t)v8 >> 3;
      while (1)
      {
        uint64_t v74 = 0xAAAAAAAAAAAAAAAALL;
        uint64_t v74 = *(void *)(*((void *)v7 + 2) + 8 * v11);
        int v73 = *(TTypesetter **)(v74 + 48);
        uint64_t v13 = (atomic_ullong *)((char *)v73 + 40);
        if (atomic_load_explicit((atomic_ullong *volatile)v73 + 5, memory_order_acquire)
          && CFDictionaryContainsKey((CFDictionaryRef)atomic_load_explicit(v13, memory_order_acquire), @"CTVerticalForms"))
        {
          goto LABEL_52;
        }
        id v72 = (id)0xAAAAAAAAAAAAAAAALL;
        id v14 = (id)atomic_load_explicit((atomic_ullong *volatile)&v77, memory_order_acquire);
        id v71 = (id)0xAAAAAAAAAAAAAAAALL;
        id v72 = v14;
        id v15 = (id)atomic_load_explicit((atomic_ullong *volatile)&v76, memory_order_acquire);
        id v70 = (id)0xAAAAAAAAAAAAAAAALL;
        id v71 = v15;
        id v70 = (id)atomic_load_explicit((atomic_ullong *volatile)&v75, memory_order_acquire);
        unint64_t explicit = (const __CTFont *)atomic_load_explicit((atomic_ullong *volatile)v73 + 7, memory_order_acquire);
        if (v10 != explicit)
        {
          if (explicit) {
            GlyphCFIndex Count = TBaseFont::GetGlyphCount(*(TBaseFont **)(*((void *)explicit + 5) + 400));
          }
          else {
            GlyphCFIndex Count = 0;
          }
          uint64_t v78 = GlyphCount;
          VerticalCopyOf(explicit, (CTFontRef *)&CopyWithAttributes);

          TCFRef<__CTFont const*>::Retain((atomic_ullong *)&v77, (id)atomic_load_explicit((atomic_ullong *volatile)&v72, memory_order_acquire));
          uint64_t v18 = atomic_load_explicit((atomic_ullong *volatile)&v72, memory_order_acquire);
          if (qword_1EB2CDED8 != -1) {
            dispatch_once_f(&qword_1EB2CDED8, 0, (dispatch_function_t)VerticalFormsFeature(void)::$_0::__invoke);
          }
          CopyWithCFDictionaryRef Attributes = CTFontCopyGlyphCoverageForFeature(v18, (CFDictionaryRef)qword_1EB2CDED0);

          TCFRef<__CTFont const*>::Retain((atomic_ullong *)&v76, (id)atomic_load_explicit((atomic_ullong *volatile)&v71, memory_order_acquire));
          if (explicit
            && (uint64_t v19 = *(TBaseFont **)(*((void *)explicit + 5) + 400)) != 0
            && TBaseFont::HasFeature(v19, 4, 2))
          {
            if (qword_1EB2CDEE8 != -1) {
              dispatch_once_f(&qword_1EB2CDEE8, 0, (dispatch_function_t)RotationCopyOf(__CTFont const*)::$_0::__invoke);
            }
            CopyWithCFDictionaryRef Attributes = CTFontCreateCopyWithAttributes(explicit, 0.0, 0, (CTFontDescriptorRef)qword_1EB2CDEE0);

            TCFRef<__CTFont const*>::Retain((atomic_ullong *)&v75, (id)atomic_load_explicit((atomic_ullong *volatile)&v70, memory_order_acquire));
          }
          else
          {

            TCFRef<__CTFont const*>::Retain((atomic_ullong *)&v75, (id)atomic_load_explicit((atomic_ullong *volatile)&v70, memory_order_acquire));
          }
          int v10 = explicit;
        }
        CopyWithCFDictionaryRef Attributes = &v80;
        uint64_t v67 = (std::__shared_weak_count *)&v73;
        double v68 = &v78;
        CFStringRef v69 = &v71;
        long long v20 = v73;
        uint64_t v21 = *((void *)v73 + 2);
        if (v21 < 1) {
          goto LABEL_51;
        }
        char v61 = v10;
        uint64_t v22 = *((void *)v73 + 1);
        uint64_t v23 = v21 + v22;
        while (1)
        {
          GlyphIndexForuint64_t Char = TRun::GetGlyphIndexForCharIndex<false>((uint64_t)v20, v22);
          Nextuint64_t Char = v22;
          if (GlyphIndexForChar < *((void *)v20 + 26))
          {
            uint64_t v26 = *((void *)v20 + 27);
            uint64_t v27 = *((void *)v20 + 25);
            if (*(__int16 *)(*(void *)(v26 + 16) + 2 * v27 + 2 * GlyphIndexForChar) == -1
              || (Nextuint64_t Char = v22, (*(_DWORD *)(*(void *)(v26 + 40) + 4 * v27 + 4 * GlyphIndexForChar) & 0x20) != 0))
            {
              uint64_t v28 = v73;
              uint64_t v64 = TRun::GetGlyphIndexForCharIndex<false>((uint64_t)v73, v22);
              Nextuint64_t Char = TRun::GetNextChar(v28, v22, &v64);
              if (NextChar >= v23) {
                break;
              }
            }
          }
          uint64_t v64 = 0xAAAAAAAAAAAAAAAALL;
          unint64_t v65 = 0xAAAAAAAAAAAAAAAALL;
          unsigned int v29 = TTypesetter::ApplyVerticalLayout(TLine &,TCharStream const*,signed char *)::$_0::operator()((void **)&CopyWithAttributes, NextChar, &v64);
          uint64_t v30 = v64 + v65 - 1;
          uint64_t v31 = v73;
          uint64_t v79 = TRun::GetGlyphIndexForCharIndex<false>((uint64_t)v73, v30);
          long long v32 = v31;
          for (uint64_t i = v30; ; uint64_t i = v36)
          {
            uint64_t v35 = TRun::GetNextChar(v32, i, &v79);
            if (v35 >= v23
              || v29 < 2 == TTypesetter::ApplyVerticalLayout(TLine &,TCharStream const*,signed char *)::$_0::operator()((void **)&CopyWithAttributes, v35, &v64) > 1)
            {
              break;
            }
            uint64_t v36 = v64 + v65 - 1;
            uint64_t v37 = v73;
            uint64_t v79 = TRun::GetGlyphIndexForCharIndex<false>((uint64_t)v73, v36);
            long long v32 = v37;
          }
          if (v35 < v23)
          {
            ++v12;
            TLine::SplitRun((uint64_t)v7, v11, v35 - v22);
            uint64_t v74 = *(void *)(*((void *)v7 + 2) + 8 * v11);
            int v73 = *(TTypesetter **)(v74 + 48);
          }
          if (v29 - 2 < 2)
          {
            TTypesetter::SetVerticalFont((atomic_ullong *)v73, (TRun *)atomic_load_explicit((atomic_ullong *volatile)&v72, memory_order_acquire), v34);
          }
          else
          {
            if (v29 > 1) {
              goto LABEL_40;
            }
            unint64_t v38 = atomic_load_explicit((atomic_ullong *volatile)&v70, memory_order_acquire);
            atomic_ullong v39 = v73;
            if (v38)
            {
              uint64_t v79 = (uint64_t)(id)atomic_load_explicit((atomic_ullong *volatile)&v70, memory_order_acquire);
              if (atomic_load_explicit(&v79, memory_order_acquire))
              {

                *((unsigned char *)v39 + 88) = 1;
              }
              int v40 = (TTypesetter *)((char *)v39 + 40);

              BOOL v41 = (char *)v73 + 192;
              uint64_t v42 = *(void *)(atomic_load_explicit((atomic_ullong *volatile)v73 + 7, memory_order_acquire) + 40);
              uint64_t RenderingStyle = TAttributes::GetRenderingStyle(v40);
              TStorageRange::ResetAdvances((uint64_t)v41, v42, RenderingStyle);
            }
            else
            {
              uint64_t v45 = *((void *)v73 + 20);
              if (!v45 || !*(_WORD *)(v45 + 64)) {
                goto LABEL_40;
              }
              TTypesetter::SetVerticalFont((atomic_ullong *)v73, (TRun *)atomic_load_explicit((atomic_ullong *volatile)&v72, memory_order_acquire), v34);
              if ((*((_WORD *)v73 + 89) & 0x1000) != 0)
              {
                TCFBase_NEW<CTTateChuYokoRun,CTRun *&>(&v74, &v63);
                uint64_t v79 = atomic_exchange((atomic_ullong *volatile)&v63, 0);
                TLine::ReplaceRun(v7, v11, &v79);

                uint64_t v74 = *(void *)(*((void *)v7 + 2) + 8 * v11);
                int v73 = *(TTypesetter **)(v74 + 48);
              }
            }
          }
          char v9 = 1;
          if ((*((_WORD *)v73 + 89) & 0x800) != 0)
          {
            char v62 = 1;
            TCFBase_NEW<CTRubyRun,CTRun *&,BOOL>(&v63, &v74, &v62);
            uint64_t v79 = atomic_exchange((atomic_ullong *volatile)&v63, 0);
            TLine::ReplaceRun(v7, v11, &v79);
          }
LABEL_40:
          if (v35 >= v23) {
            goto LABEL_50;
          }
          if (++v11 >= v12)
          {
            long long v20 = v73;
          }
          else
          {
            uint64_t v44 = *(void *)(*((void *)v7 + 2) + 8 * v11);
            long long v20 = *(TTypesetter **)(v44 + 48);
            int v73 = v20;
            uint64_t v74 = v44;
          }
          uint64_t v22 = v35;
        }
        TAttributes::SetVerticalFont((TTypesetter *)((char *)v73 + 40), (const __CTFont *)atomic_load_explicit((atomic_ullong *volatile)&v72, memory_order_acquire));
LABEL_50:
        int v10 = v61;
LABEL_51:

LABEL_52:
        if (++v11 >= v12)
        {
          v60 |= v9 & 1;
          char v3 = this;
          LODWORD(v6) = v56;
          goto LABEL_56;
        }
      }
    }
    char v9 = 0;
LABEL_56:

    uint64_t v6 = v6 | v9 & 1;
    TRunGlue::TRunGlue((TRunGlue *)&v80, v7);
    TRunGlue::operator=((uint64_t)v3, (long long *)&v80);
    std::__function::__value_func<BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::~__value_func[abi:nn180100](v89);
    CopyWithCFDictionaryRef Attributes = v88;
    std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&CopyWithAttributes);
    CopyWithCFDictionaryRef Attributes = v87;
    std::vector<unsigned char,TInlineBufferAllocator<unsigned char,128ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&CopyWithAttributes);
    CopyWithCFDictionaryRef Attributes = v84;
    std::vector<std::pair<UScriptCode,long>,TInlineBufferAllocator<std::pair<UScriptCode,long>,1ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&CopyWithAttributes);
    uint64_t v4 = a1;
    LOBYTE(v5) = v60;
  }
  if (v5 & 2 | *(_DWORD *)(v4 + 40)) {
    BOOL v46 = (*(_DWORD *)(v4 + 40) & 1) == 0;
  }
  else {
    BOOL v46 = 0;
  }
  if (v46)
  {
    CopyWithCFDictionaryRef Attributes = (id)0xAAAAAAAAAAAAAAAALL;
    uint64_t v67 = (std::__shared_weak_count *)0xAAAAAAAAAAAAAAAALL;
    TTypesetter::GetLevelsProvider(v4, (uint64_t *)&CopyWithAttributes);
    unint64_t v47 = *(void *)(v4 + 8);
    uint64_t v64 = (uint64_t)CopyWithAttributes;
    unint64_t v65 = v47;
    TBidiEngine::ReorderGlyphs((uint64_t)&v64, v7);
    TRunGlue::TRunGlue((TRunGlue *)&v80, v7);
    TRunGlue::operator=((uint64_t)v3, (long long *)&v80);
    std::__function::__value_func<BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::~__value_func[abi:nn180100](v89);
    uint64_t v79 = (uint64_t)v88;
    std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v79);
    uint64_t v79 = (uint64_t)v87;
    std::vector<unsigned char,TInlineBufferAllocator<unsigned char,128ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v79);
    uint64_t v79 = (uint64_t)v84;
    std::vector<std::pair<UScriptCode,long>,TInlineBufferAllocator<std::pair<UScriptCode,long>,1ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v79);
    if (v67) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v67);
    }
  }
  if ((v5 & 4) != 0)
  {
    uint64_t v48 = *(void *)(v4 + 8);
    char v80 = (void ***)v3;
    *(void *)&long long v81 = v48;
    LOBYTE(CopyWithAttributes) = -86;
    LOBYTE(v64) = 0;
    uint64_t v6 = v6 | TCombiningEngine::ResolveCombiningMarks(&v80, 0, &CopyWithAttributes, (char *)&v64);
    if ((_BYTE)CopyWithAttributes) {
      *(unsigned char *)a3 &= ~4u;
    }
    LOBYTE(v5) = v64 | v5;
  }
  if (v5)
  {
    uint64_t v6 = TShapingEngine::ShapeGlyphs(v3, *(TRunGlue **)(v4 + 8), a3) | v6;
  }
  else
  {
    uint64_t v49 = *((void *)v7 + 2);
    uint64_t v50 = *((void *)v7 + 3);
    while (v49 != v50)
    {
      uint64_t v51 = *(void *)(*(void *)v49 + 48);
      int ShapingType = TBaseFont::GetShapingType(*(TBaseFont **)(*(void *)(atomic_load_explicit((atomic_ullong *volatile)(v51 + 56), memory_order_acquire)+ 40)+ 400));
      unsigned int v53 = *(_DWORD *)(v51 + 260) & 0xFFFFFFF9;
      *(_DWORD *)(v51 + 260) = v53;
      if (ShapingType)
      {
        if (ShapingType == 1) {
          int v54 = 4;
        }
        else {
          int v54 = 2;
        }
        *(_DWORD *)(v51 + 260) = v54 | v53;
      }
      v49 += 8;
    }
  }
  if (*((unsigned char *)v3 + 633)) {
    *((unsigned char *)v3 + 633) = 0;
  }
  return v6;
}

size_t TBaseFont::InitGlyphCount(TBaseFont *this, CGFontRef font)
{
  if (!font) {
    return 0;
  }
  size_t result = CGFontGetNumberOfGlyphs(font);
  atomic_store(result, (unint64_t *)this + 25);
  return result;
}

uint64_t TBaseFont::HasVariations(TBaseFont *this)
{
  return 0;
}

uint64_t TInstanceFont::HasVariations(TInstanceFont *this)
{
  return 1;
}

void TLine::SetRunArray(int64x2_t *this, CFArrayRef theArray)
{
  CFIndex Count = CFArrayGetCount(theArray);
  if (Count)
  {
    uint64_t v5 = Count;
    if (theArray)
    {
      CFIndex v6 = CFArrayGetCount(theArray);
      if (v6)
      {
        CFIndex v7 = v6;
        for (CFIndex i = 0; i != v7; ++i)
        {
          id v14 = (id)CFArrayGetValueAtIndex(theArray, i);
          id v15 = (id)atomic_exchange((atomic_ullong *volatile)&v14, 0);
          TLine::AppendRun(this, (atomic_ullong *)&v15);
        }
      }
    }
    uint64_t v9 = this[1].i64[0];
    uint64_t v10 = *(void *)(*(void *)v9 + 40);
    uint64_t v11 = *(void *)(v10 + 8);
    if (v5 <= 1)
    {
      uint64_t v13 = *(void *)(v10 + 16);
    }
    else
    {
      uint64_t v12 = *(void *)(*(void *)(v9 + 8 * v5 - 8) + 40);
      uint64_t v13 = *(void *)(v12 + 8) - v11 + *(void *)(v12 + 16);
    }
    this[4].i64[1] = v11;
    this[5].i64[0] = v13;
  }
}

uint64_t TTypesetter::DoAttachments(uint64_t a1, void ***a2, unsigned char *a3, unsigned char *a4)
{
  uint64_t v8 = *(void *)(*(void *)(a1 + 8) + 16);
  uint64_t v9 = (NSMutableIndexSet *)objc_opt_new();
  uint64_t v10 = *a2;
  uint64_t v11 = (unsigned char *)(*a2)[3] - (unsigned char *)(*a2)[2];
  if (v11 >= 8)
  {
    uint64_t v23 = a3;
    char v24 = a4;
    uint64_t v13 = 0;
    char v14 = 0;
    uint64_t v15 = v11 >> 3;
    if (v11 >> 3 <= 1) {
      uint64_t v16 = 1;
    }
    else {
      uint64_t v16 = v11 >> 3;
    }
    while (1)
    {
      int v17 = *(TRun **)(*((void *)v10[2] + v13) + 48);
      if (FixRunIfBroken(v17, v8, v9)) {
        break;
      }
      uint64_t v18 = *((void *)v17 + 20);
      if (v18) {
        LODWORD(v18) = (*(unsigned __int16 *)(v18 + 66) >> 3) & 1;
      }
      v14 |= v18;
      if (v16 == ++v13)
      {
        if (v14)
        {
          uint64_t v19 = *(void ****)(a1 + 8);
          v26[0] = a2;
          v26[1] = v19;
          char v25 = -86;
          int v20 = TCombiningEngine::ResolveCombiningMarks(v26, 0, &v25, 0);
          if (!v25) {
            *v23 |= 4u;
          }
          if (v20) {
            *char v24 = 1;
          }
        }
        goto LABEL_2;
      }
    }
    uint64_t v21 = v13 + 1;
    if (v13 + 1 < v15)
    {
      do
        FixRunIfBroken(*(TRun **)(*((void *)v10[2] + v21++) + 48), v8, v9);
      while (v15 != v21);
    }
    uint64_t v12 = 0;
  }
  else
  {
LABEL_2:
    uint64_t v12 = 1;
  }

  return v12;
}

void *DoGlyphFixupsCheck(void *result)
{
  uint64_t v1 = result[3] - result[2];
  if (v1 >= 1)
  {
    uint64_t v2 = result;
    uint64_t v3 = 0;
    uint64_t v4 = (unint64_t)v1 >> 3;
    if (v4 <= 1) {
      uint64_t v5 = 1;
    }
    else {
      uint64_t v5 = v4;
    }
    while (1)
    {
      uint64_t v6 = *(void *)(*(void *)(v2[2] + 8 * v3) + 48);
      uint64_t v7 = *(void *)(v6 + 208);
      size_t result = *(void **)(v6 + 216);
      uint64_t v8 = result[2];
      uint64_t v9 = *(void *)(v6 + 200);
      if ((*(unsigned char *)(v6 + 225) & 0x10) != 0)
      {
        size_t result = (void *)[result implementsOrigins];
        if (!result) {
          break;
        }
      }
      if (v7 >= 1)
      {
        uint64_t v10 = (__int16 *)(v8 + 2 * v9);
        do
        {
          int v11 = *v10++;
          if (v11 == -1) {
            goto LABEL_13;
          }
        }
        while (--v7);
      }
      if (++v3 == v5) {
        return result;
      }
    }
LABEL_13:
    *((_WORD *)v2 + 77) |= 0x20u;
  }
  return result;
}

uint64_t FixRunIfBroken(TRun *a1, uint64_t a2, NSMutableIndexSet *a3)
{
  int v3 = *((_DWORD *)a1 + 64);
  BOOL v4 = v3 != 2;
  if (v3) {
    BOOL v5 = v3 == 3;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5) {
    BOOL v4 = 0;
  }
  BOOL v41 = v4;
  BOOL v6 = v5 || v3 == 2;
  if (v3) {
    char v7 = v6;
  }
  else {
    char v7 = 0;
  }
  uint64_t v8 = *((void *)a1 + 26);
  if (v8 >= 1)
  {
    uint64_t v11 = *((void *)a1 + 1);
    uint64_t v37 = *((void *)a1 + 2);
    uint64_t v12 = (void *)*((void *)a1 + 27);
    uint64_t v13 = (uint64_t *)(v12[6] + 8 * *((void *)a1 + 25));
    uint64_t v14 = *v13;
    unint64_t v15 = objc_msgSend(v12, "attachmentCountAtIndex:") + v14;
    if (v8 != 1)
    {
      for (uint64_t i = 1; i != v8; ++i)
      {
        uint64_t v17 = v13[i];
        if (v17 < v14) {
          uint64_t v14 = v13[i];
        }
        uint64_t v18 = [*((id *)a1 + 27) attachmentCountAtIndex:i + *((void *)a1 + 25)];
        if ((uint64_t)v15 <= v18 + v17) {
          unint64_t v15 = v18 + v17;
        }
      }
    }
    if ((uint64_t)(v15 + 1) < a2) {
      unint64_t v19 = v15 + 1;
    }
    else {
      unint64_t v19 = a2;
    }
    if (v14 < 0 || v14 >= a2)
    {
      BOOL v20 = v15 < 0x7FFFFFFFFFFFFFFFLL && v14 < 1;
      uint64_t v14 = 0;
      if (!v20) {
        unint64_t v19 = 0;
      }
    }
    else
    {
      v19 -= v14;
    }
    atomic_ullong v39 = v13;
    if (v14 != v11 || v19 != v37)
    {
      *((void *)a1 + 1) = v14;
      *((void *)a1 + 2) = v19;
      char v7 = 1;
    }
    char v21 = v7;
    if (*((unsigned char *)a1 + 224)) {
      uint64_t v22 = v8 - 1;
    }
    else {
      uint64_t v22 = 0;
    }
    if (*((unsigned char *)a1 + 224)) {
      uint64_t v23 = -1;
    }
    else {
      uint64_t v23 = v8;
    }
    uint64_t v24 = 1;
    if (*((unsigned char *)a1 + 224)) {
      uint64_t v25 = -1;
    }
    else {
      uint64_t v25 = 1;
    }
    uint64_t v26 = v39[v22] - 1;
    uint64_t v38 = v14 + v19;
    while (1)
    {
      uint64_t v27 = v26;
      uint64_t v26 = v39[v22];
      uint64_t v28 = [*((id *)a1 + 27) attachmentCountAtIndex:v22 + *((void *)a1 + 25)];
      uint64_t v29 = v28;
      BOOL v30 = v41;
      if (v26 != v27) {
        BOOL v30 = 0;
      }
      BOOL v31 = v26 != v27 + v24 && !v30;
      uint64_t v32 = v28 + v26;
      if (!v31 && v14 <= v32)
      {
        BOOL v34 = v38 <= v32;
        char v35 = v38 <= v32 || v41;
        if (v35)
        {
          if (!v34) {
            goto LABEL_54;
          }
        }
        else if (([(NSMutableIndexSet *)a3 containsIndex:v26] & 1) == 0)
        {
          goto LABEL_54;
        }
      }
      [*((id *)a1 + 27) setProps:*(_DWORD *)(*(void *)(*((void *)a1 + 27) + 40) + 4 * *((void *)a1 + 25) + 4 * v22) | 0x20u atIndex:v22 + *((void *)a1 + 25)];
      [*((id *)a1 + 27) setStringIndex:v14 atIndex:v22 + *((void *)a1 + 25)];
      *((_DWORD *)a1 + 64) = 2;
      char v21 = 1;
LABEL_54:
      [(NSMutableIndexSet *)a3 addIndex:v26];
      uint64_t v24 = v29 + 1;
      v22 += v25;
      if (v23 == v22) {
        return v21 & 1;
      }
    }
  }
  char v21 = v7;
  return v21 & 1;
}

const __CFDictionary *TSplicedFont::HasVariations(atomic_ullong *this)
{
  return TSplicedFontDict::ComponentHasVariations(this + 75);
}

size_t TSplicedFont::InitGlyphCount(TSplicedFont *this, CGFontRef font)
{
  if (!*((unsigned char *)this + 632))
  {
    CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)this + 75, memory_order_acquire);
    if (explicit)
    {
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(explicit, @"FontMetrics");
      int valuePtr = 0;
      if (Value)
      {
        CFNumberRef v7 = (const __CFNumber *)CFDictionaryGetValue(Value, @"numGlyphs");
        if (v7)
        {
          CFNumberRef v8 = v7;
          CFTypeID v9 = CFGetTypeID(v7);
          if (v9 == CFNumberGetTypeID() || v9 == CFBooleanGetTypeID())
          {
            CFNumberGetValue(v8, kCFNumberIntType, &valuePtr);
            LODWORD(result) = valuePtr;
            return (int)result;
          }
          if (v9 == CFStringGetTypeID())
          {
            LODWORD(result) = CFStringGetIntValue((CFStringRef)v8);
            return (int)result;
          }
        }
      }
    }
  }
  if (!font) {
    return 0;
  }
  size_t result = CGFontGetNumberOfGlyphs(font);
  atomic_store(result, (unint64_t *)this + 25);
  return result;
}

unint64_t TFontFeatures::CopyNonDefault(atomic_ullong *this, const TBaseFont *a2, id a3)
{
  unint64_t v3 = 0;
  unint64_t explicit = atomic_load_explicit(this, memory_order_acquire);
  if (a3 && explicit)
  {
    BOOL v6 = this;
    long long v41 = xmmword_184B8A518;
    long long v63 = xmmword_184B8A518;
    memset(v64, 170, sizeof(v64));
    memset(v40, 170, sizeof(v40));
    unint64_t v39 = 0xAAAAAAAAFFFFFFFFLL;
    unint64_t v65 = 0xAAAAAAAAFFFFFFFFLL;
    memset(v62, 170, sizeof(v62));
    memset(v38, 170, sizeof(v38));
    TFontFeatureSettingList::TFontFeatureSettingList((TFontFeatureSettingList *)v62, a3);
    CFArrayRef v7 = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)v62, memory_order_acquire);
    if (v7) {
      CFIndex Count = CFArrayGetCount(v7);
    }
    else {
      CFIndex Count = 0;
    }
    CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t v10 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    CFMutableArrayRef v60 = CFArrayCreateMutable(v9, 0, v10);
    if (Count >= 1)
    {
      uint64_t v44 = 0;
      uint64_t v47 = (uint64_t)v54 + 8;
      uint64_t v48 = v55;
      BOOL v46 = &v52[1];
      uint64_t v37 = a2;
      while (1)
      {
        CFIndex v42 = Count - 1;
        uint64_t v43 = Count;
        int ValueAtIndex = (id *)CFArrayGetValueAtIndex((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)v62, memory_order_acquire), Count - 1);
        CFArrayRef v58 = (CFArrayRef)0xAAAAAAAAAAAAAAAALL;
        id v59 = 0;
        TFontFeatures::SettingsByNormalizing(v6, a2, (uint64_t)ValueAtIndex, (atomic_ullong *)&v59, &v58);
        if (atomic_load_explicit((atomic_ullong *volatile)&v58, memory_order_acquire))
        {
          *(_DWORD *)uint64_t v45 = TBaseFont::HasOTFontFeatureTable((atomic_ullong *)a2);
          CFArrayRef v12 = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v58, memory_order_acquire);
          if (v12)
          {
            CFIndex v13 = CFArrayGetCount(v12);
            if (v13) {
              break;
            }
          }
        }
LABEL_50:

        CFIndex Count = v42;
        a2 = v37;
        if (v43 <= 1) {
          goto LABEL_51;
        }
      }
      CFIndex v14 = v13;
      CFIndex v15 = 0;
      while (1)
      {
        uint64_t v16 = (void *)CFArrayGetValueAtIndex(v12, v15);
        if (ValueAtIndex) {
          CFStringRef v17 = (const __CFString *)[ValueAtIndex[1] objectForKey:@"CTFeatureOpenTypeTag"];
        }
        else {
          CFStringRef v17 = 0;
        }
        id v57 = v16;
        CFDictionaryRef v18 = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v57, memory_order_acquire);
        if (!v18 || (CFNumberRef v19 = (const __CFNumber *)CFDictionaryGetValue(v18, @"CTFeatureTypeIdentifier")) == 0)
        {
          TFontFeatureSettingList::TFontFeatureSettingList((TFontFeatureSettingList *)v52, (id)atomic_load_explicit((atomic_ullong *volatile)&v60, memory_order_acquire));
          CFIndex v23 = TFontFeatureSettingList::IndexOfOpenTypeSetting((atomic_ullong *)v52, v17);
          std::__hash_table<std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>>>::~__hash_table((uint64_t)v48);
          std::__hash_table<std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>>>::~__hash_table(v47);
          std::__tree<std::__value_type<long,TAATDeltaYListEntry>,std::__map_value_compare<long,std::__value_type<long,TAATDeltaYListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TAATDeltaYListEntry>>>::destroy((uint64_t)v46, (void *)v53);

          if (v23 != -1) {
            goto LABEL_47;
          }
          LODWORD(v52[0]) = -1431655766;
          CFDictionaryRef Value = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v57, memory_order_acquire);
          if (Value) {
            CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(Value, @"CTFeatureOpenTypeValue");
          }
          if (!GetValue<__CFNumber const*>((uint64_t)Value, v52)) {
            goto LABEL_47;
          }
          if (LODWORD(v52[0]))
          {
            CFIndex v25 = CFArrayGetCount((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire));
            id v26 = (id)atomic_load_explicit((atomic_ullong *volatile)&v57, memory_order_acquire);
            CFArrayInsertValueAtIndex((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), v25, v26);

            ++v44;
          }
          id v27 = (id)atomic_load_explicit((atomic_ullong *volatile)&v57, memory_order_acquire);
          CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v60, memory_order_acquire), v27);
          id v28 = v27;
          goto LABEL_46;
        }
        CFNumberRef v20 = v19;
        if ((TFontFeatures::HandleAlias(v6, (atomic_ullong *)&v57, *(int *)v45, (atomic_ullong *)&Mutable, (atomic_ullong *)&v60) & 1) == 0)break; {
LABEL_47:
        }

        if (v14 == ++v15) {
          goto LABEL_50;
        }
      }
      BOOL v51 = -86;
      id v50 = TFontFeatures::GetFeatureSelector(v6, (atomic_ullong *)&v57, &v51);
      if (!atomic_load_explicit((atomic_ullong *volatile)&v50, memory_order_acquire)) {
        goto LABEL_45;
      }
      CFDictionaryRef v21 = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v57, memory_order_acquire);
      CFNumberRef v22 = v21 ? (const __CFNumber *)CFDictionaryGetValue(v21, @"CTFeatureSelectorIdentifier") : 0;
      __int16 v49 = -21846;
      if (!GetSettingValue<__CFNumber const*,unsigned short>((uint64_t)v22, &v49)) {
        goto LABEL_45;
      }
      uint64_t v29 = v6;
      void v54[2] = v41;
      v55[0] = v40[1];
      v55[1] = v40[0];
      unint64_t v56 = v39;
      *(_OWORD *)unint64_t v52 = v38[3];
      long long v53 = v38[2];
      v54[0] = v38[1];
      v54[1] = v38[0];
      TFontFeatureSettingList::TFontFeatureSettingList((TFontFeatureSettingList *)v52, (id)atomic_load_explicit((atomic_ullong *volatile)&v60, memory_order_acquire));
      if (v17)
      {
        if (TFontFeatureSettingList::IndexOfOpenTypeSetting((atomic_ullong *)v52, v17) == -1)
        {
          BOOL v30 = v51;
          goto LABEL_33;
        }
LABEL_44:
        std::__hash_table<std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>>>::~__hash_table((uint64_t)v48);
        std::__hash_table<std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>>>::~__hash_table(v47);
        std::__tree<std::__value_type<long,TAATDeltaYListEntry>,std::__map_value_compare<long,std::__value_type<long,TAATDeltaYListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TAATDeltaYListEntry>>>::destroy((uint64_t)v46, (void *)v53);

        BOOL v6 = v29;
LABEL_45:
        id v28 = v50;
LABEL_46:

        goto LABEL_47;
      }
      BOOL v30 = v51;
      if (TFontFeatureSettingList::ContainsAATSetting((atomic_ullong *)v52, v20, v22, v51)) {
        goto LABEL_44;
      }
LABEL_33:
      if (v30)
      {
          goto LABEL_36;
      }
      else
      {
        char v34 = v49;
        {
LABEL_36:
          if (v17)
          {
            if (!atomic_load_explicit((atomic_ullong *volatile)&v59, memory_order_acquire))
            {
              CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v60, memory_order_acquire), ValueAtIndex);
              goto LABEL_44;
            }
            uint64_t v33 = (void *)atomic_load_explicit((atomic_ullong *volatile)&v59, memory_order_acquire);
          }
          else
          {
            uint64_t v33 = (void *)atomic_load_explicit((atomic_ullong *volatile)&v57, memory_order_acquire);
          }
          id v35 = v33;
          CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v60, memory_order_acquire), v35);

          goto LABEL_44;
        }
      }
      CFIndex v31 = CFArrayGetCount((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire))
          - v44;
      id v32 = (id)atomic_load_explicit((atomic_ullong *volatile)&v57, memory_order_acquire);
      CFArrayInsertValueAtIndex((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), v31, v32);

      goto LABEL_36;
    }
LABEL_51:
    if (CFArrayGetCount((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire)) <= 0) {
      unint64_t v3 = 0;
    }
    else {
      unint64_t v3 = atomic_exchange((atomic_ullong *volatile)&Mutable, 0);
    }

    std::__hash_table<std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>>>::~__hash_table((uint64_t)v64);
    std::__hash_table<std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>>>::~__hash_table((uint64_t)&v62[5]);
    std::__tree<std::__value_type<long,TAATDeltaYListEntry>,std::__map_value_compare<long,std::__value_type<long,TAATDeltaYListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TAATDeltaYListEntry>>>::destroy((uint64_t)&v62[1], (void *)v62[2]);
  }
  return v3;
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>>>::__deallocate_node(a1, *(char **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>>>::__deallocate_node(uint64_t a1, char *a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    do
    {
      unint64_t v3 = *(char **)v2;
      BOOL v4 = (void **)(v2 + 24);
      std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100](&v4);
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
}

void TAATKerxEngine::~TAATKerxEngine(id **this)
{
  std::unique_ptr<TAATAnkrTable>::reset[abi:nn180100](this + 50, 0);
  uint64_t v2 = this[49];
  this[49] = 0;
  if (v2) {
    std::default_delete<TAATControlPointAccess>::operator()[abi:nn180100]((uint64_t)(this + 49), v2);
  }
  BOOL v4 = (void **)(this + 14);
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](&v4);
  std::__tree<std::__value_type<long,TAATDeltaYListEntry>,std::__map_value_compare<long,std::__value_type<long,TAATDeltaYListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TAATDeltaYListEntry>>>::destroy((uint64_t)(this + 6), this[7]);
  unint64_t v3 = this[3];
  if (v3)
  {
    this[4] = v3;
    operator delete(v3);
  }
}

void std::__tree<std::__value_type<long,TAATDeltaYListEntry>,std::__map_value_compare<long,std::__value_type<long,TAATDeltaYListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TAATDeltaYListEntry>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<long,TAATDeltaYListEntry>,std::__map_value_compare<long,std::__value_type<long,TAATDeltaYListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TAATDeltaYListEntry>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<long,TAATDeltaYListEntry>,std::__map_value_compare<long,std::__value_type<long,TAATDeltaYListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TAATDeltaYListEntry>>>::destroy(a1, a2[1]);
    operator delete(a2);
  }
}

id **std::unique_ptr<TAATAnkrTable>::reset[abi:nn180100](id **result, id *a2)
{
  uint64_t v2 = *result;
  *size_t result = a2;
  if (v2)
  {

    JUMPOUT(0x1853275C0);
  }
  return result;
}

void TFontFeatureSettingList::TFontFeatureSettingList(TFontFeatureSettingList *this, id a2)
{
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *(void *)this = 0;
  *((void *)this + 1) = (char *)this + 16;
  *((_DWORD *)this + 8) = 0;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *((_DWORD *)this + 18) = 1065353216;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_DWORD *)this + 28) = 1065353216;
  id v3 = a2;
  TFontFeatureSettingList::Emplace((uint64_t)this, (atomic_ullong *)&v3);
}

uint64_t TFontFeatures::HandleAlias(atomic_ullong *this, atomic_ullong *a2, int a3, atomic_ullong *a4, atomic_ullong *a5)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  v44[0] = xmmword_184B8A430;
  v44[1] = xmmword_184B8A440;
  v44[2] = xmmword_184B8A450;
  double v44[3] = xmmword_184B8A460;
  v44[4] = xmmword_184B8A470;
  void v44[5] = xmmword_184B8A480;
  v44[6] = xmmword_184B8A490;
  v44[7] = xmmword_184B8A4A0;
  v44[8] = xmmword_184B8A4B0;
  v44[9] = xmmword_184B8A4C0;
  uint64_t v45 = 37;
  CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit(a2, memory_order_acquire);
  if (explicit) {
    CFDictionaryRef Value = CFDictionaryGetValue(explicit, @"CTFeatureTypeIdentifier");
  }
  else {
    CFDictionaryRef Value = 0;
  }
  CFDictionaryRef v12 = (const __CFDictionary *)atomic_load_explicit(a2, memory_order_acquire);
  if (v12) {
    CFNumberRef v13 = (const __CFNumber *)CFDictionaryGetValue(v12, @"CTFeatureSelectorIdentifier");
  }
  else {
    CFNumberRef v13 = 0;
  }
  unsigned __int16 v43 = -21846;
  unsigned __int16 v42 = -21846;
  if (!GetSettingValue<__CFNumber const*,unsigned short>((uint64_t)Value, &v43)
    || !GetSettingValue<__CFNumber const*,unsigned short>((uint64_t)v13, &v42))
  {
    return 0;
  }
  uint64_t v14 = 0;
  while (*(unsigned __int16 *)((char *)v44 + v14) != v43 || *(unsigned __int16 *)((char *)v44 + v14 + 2) != v42)
  {
    v14 += 12;
    if (v14 == 168) {
      return 0;
    }
  }
  uint64_t v16 = (unsigned __int16 *)((char *)v44 + v14);
  if (*(_WORD *)((char *)v44 + v14 + 8) && a3 == 0) {
    return 0;
  }
  int v18 = v16[2];
  id v41 = (id)0xAAAAAAAAAAAAAAAALL;
  TCFNumber::TCFNumber<int>(&v41, v18);
  int v19 = v16[3];
  id v40 = (id)0xAAAAAAAAAAAAAAAALL;
  char v32 = v19;
  TCFNumber::TCFNumber<int>(&v40, v19);
  BOOL v39 = -86;
  TFeatureSetting::TFeatureSetting((TFeatureSetting *)&v35, Value, v13);
  FeatureSelector = TFontFeatures::GetFeatureSelector(this, (atomic_ullong *)&v35, &v39);

  if (!FeatureSelector)
  {
    TFeatureSetting::TFeatureSetting((TFeatureSetting *)&v35, (CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)&v41, memory_order_acquire), (const __CFNumber *)atomic_load_explicit((atomic_ullong *volatile)&v40, memory_order_acquire));
    FeatureSelector = TFontFeatures::GetFeatureSelector(this, (atomic_ullong *)&v35, &v39);

    if (!FeatureSelector)
    {
      uint64_t v30 = 0;
      goto LABEL_33;
    }
  }
  TFontFeatureSettingList::TFontFeatureSettingList((TFontFeatureSettingList *)&v35, (id)atomic_load_explicit(a5, memory_order_acquire));
  char v21 = TFontFeatureSettingList::ContainsAATSetting((atomic_ullong *)&v35, (const __CFNumber *)Value, v13, v39);
  std::__hash_table<std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>>>::~__hash_table((uint64_t)&v38);
  std::__hash_table<std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>>>::~__hash_table((uint64_t)&v37);
  std::__tree<std::__value_type<long,TAATDeltaYListEntry>,std::__map_value_compare<long,std::__value_type<long,TAATDeltaYListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TAATDeltaYListEntry>>>::destroy((uint64_t)v36, v36[1]);

  if ((v21 & 1) == 0)
  {
    id v34 = (id)0xAAAAAAAAAAAAAAAALL;
    id v35 = FeatureSelector;
    TFeatureSetting::TFeatureSetting((TFeatureSetting *)&v34, (CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)&v41, memory_order_acquire), (const __CFNumber *)atomic_load_explicit((atomic_ullong *volatile)&v40, memory_order_acquire));
    BOOL v22 = v39;
    if (v22)
    {
      if (v23) {
        goto LABEL_26;
      }
    }
    else if (((((v32 & 1) == 0) ^ v23) & 1) == 0)
    {
LABEL_26:
      uint64_t v24 = [[CTFeatureSetting alloc] initWithDictionary:atomic_load_explicit(a2, memory_order_acquire)];
      CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit(a5, memory_order_acquire), v24);

      CFIndex v25 = [[CTFeatureSetting alloc] initWithDictionary:atomic_load_explicit((atomic_ullong *volatile)&v34, memory_order_acquire)];
      CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit(a5, memory_order_acquire), v25);

      if (!v16[4])
      {
LABEL_31:

        goto LABEL_32;
      }
      TCFNumber::TCFNumber<int>(&v33, v16[4]);

      unsigned __int16 v26 = *(_WORD *)((char *)v44 + v14 + 10);
      TCFNumber::TCFNumber<int>(&v33, v26);

      id v33 = (id)0xAAAAAAAAAAAAAAAALL;
      TFeatureSetting::TFeatureSetting((TFeatureSetting *)&v33, (CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)&v41, memory_order_acquire), (const __CFNumber *)atomic_load_explicit((atomic_ullong *volatile)&v40, memory_order_acquire));
      BOOL v27 = v39;
      if (v27)
      {
        if (v28)
        {
LABEL_30:
          uint64_t v29 = [[CTFeatureSetting alloc] initWithDictionary:atomic_load_explicit((atomic_ullong *volatile)&v33, memory_order_acquire)];
          CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit(a5, memory_order_acquire), v29);

          goto LABEL_31;
        }
      }
      else if (((((v26 & 1) == 0) ^ v28) & 1) == 0)
      {
        goto LABEL_30;
      }
      TFontFeatures::HandleAlias(TFeatureSetting const&,BOOL,TCFMutableArray &,TCFMutableArray &)const::$_1::operator()(a4, (atomic_ullong *)&v33);
      goto LABEL_30;
    }
    TFontFeatures::HandleAlias(TFeatureSetting const&,BOOL,TCFMutableArray &,TCFMutableArray &)const::$_1::operator()(a4, a2);
    TFontFeatures::HandleAlias(TFeatureSetting const&,BOOL,TCFMutableArray &,TCFMutableArray &)const::$_1::operator()(a4, (atomic_ullong *)&v34);
    goto LABEL_26;
  }
LABEL_32:
  uint64_t v30 = 1;
LABEL_33:

  return v30;
}

void *TFontFeatures::GetFeatureSelector(atomic_ullong *this, atomic_ullong *a2, BOOL *a3)
{
  CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit(a2, memory_order_acquire);
  if (explicit) {
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(explicit, @"CTFeatureTypeIdentifier");
  }
  else {
    CFNumberRef Value = 0;
  }
  CFDictionaryRef v8 = (const __CFDictionary *)atomic_load_explicit(a2, memory_order_acquire);
  if (v8) {
    CFNumberRef v9 = (const __CFNumber *)CFDictionaryGetValue(v8, @"CTFeatureSelectorIdentifier");
  }
  else {
    CFNumberRef v9 = 0;
  }
  id v12 = TFontFeatures::GetFeatureType(this, Value);

  return Selector;
}

const __CFDictionary *anonymous namespace'::TFeatureType::IsExclusive(atomic_ullong *this)
{
  CFDictionaryRef result = (const __CFDictionary *)atomic_load_explicit(this, memory_order_acquire);
  if (result)
  {
    CFDictionaryRef result = (const __CFDictionary *)CFDictionaryGetValue(result, @"CTFeatureTypeExclusive");
    if (result) {
      return (const __CFDictionary *)(CFBooleanGetValue(result) != 0);
    }
  }
  return result;
}

void TFontFeatureSettingList::Emplace(uint64_t a1, atomic_ullong *a2)
{
  CFArrayRef explicit = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)a1, memory_order_acquire);
  if (explicit)
  {
    CFIndex Count = CFArrayGetCount(explicit);
    if (Count >= 1)
    {
      CFIndex v5 = Count;
      CFIndex v6 = 0;
      CFArrayRef v7 = (const void *)*MEMORY[0x1E4F1D260];
      char v21 = (uint64_t ***)(a1 + 16);
      do
      {
        CFDictionaryRef v8 = (id)CFArrayGetValueAtIndex((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)a1, memory_order_acquire), v6);
        CFDictionaryRef v9 = v8;
        if (v8)
        {
          CFNumberRef Value = CFDictionaryGetValue(v8, @"CTFeatureTypeIdentifier");
          if (Value)
          {
            uint64_t v11 = (uint64_t)Value;
            if (CFDictionaryGetValue(v9, @"CTFeatureSelectorIdentifier") != v7)
            {
              unsigned __int16 v23 = -21846;
              unsigned __int16 v22 = -21846;
              if (GetSettingValue<__CFNumber const*,unsigned short>(v11, &v23))
              {
                id v12 = CFDictionaryGetValue(v9, @"CTFeatureSelectorIdentifier");
                if (GetSettingValue<__CFNumber const*,unsigned short>((uint64_t)v12, &v22))
                {
                  uint64_t v13 = v22;
                  unsigned int v14 = v23;
                  CFIndex v15 = (uint64_t *)operator new(0x38uLL);
                  uint64_t v16 = v15;
                  *((_WORD *)v15 + 16) = v14;
                  void v15[5] = v13 | 0xAAAAAAAAAAAA0000;
                  v15[6] = v6;
                  CFStringRef v17 = (uint64_t **)(a1 + 16);
                  int v18 = *v21;
                  int v19 = (uint64_t **)(a1 + 16);
                  if (*v21)
                  {
                    do
                    {
                      while (1)
                      {
                        int v19 = v18;
                        if (*((unsigned __int16 *)v18 + 16) <= v14) {
                          break;
                        }
                        int v18 = (uint64_t **)*v18;
                        CFStringRef v17 = v19;
                        if (!*v19) {
                          goto LABEL_15;
                        }
                      }
                      int v18 = (uint64_t **)v18[1];
                    }
                    while (v18);
                    CFStringRef v17 = v19 + 1;
                  }
LABEL_15:
                  uint64_t *v15 = 0;
                  v15[1] = 0;
                  v15[2] = (uint64_t)v19;
                  *CFStringRef v17 = v15;
                  uint64_t v20 = **(void **)(a1 + 8);
                  if (v20)
                  {
                    *(void *)(a1 + 8) = v20;
                    uint64_t v16 = *v17;
                  }
                  std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 16), v16);
                  ++*(void *)(a1 + 24);
                }
              }
            }
          }
        }

        ++v6;
      }
      while (v6 != v5);
    }
  }
}

uint64_t *std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  *((unsigned char *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      uint64_t v2 = (uint64_t *)a2[2];
      if (*((unsigned char *)v2 + 24)) {
        return result;
      }
      id v3 = (uint64_t *)v2[2];
      BOOL v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        uint64_t v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), CFIndex v5 = (unsigned char *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            CFDictionaryRef v9 = (uint64_t **)a2[2];
          }
          else
          {
            CFDictionaryRef v9 = (uint64_t **)v2[1];
            uint64_t v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              void v10[2] = (uint64_t)v2;
              id v3 = (uint64_t *)v2[2];
            }
            v9[2] = v3;
            *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = v9;
            *CFDictionaryRef v9 = v2;
            v2[2] = (uint64_t)v9;
            id v3 = v9[2];
            uint64_t v2 = (uint64_t *)*v3;
          }
          *((unsigned char *)v9 + 24) = 1;
          *((unsigned char *)v3 + 24) = 0;
          uint64_t v13 = v2[1];
          *id v3 = v13;
          if (v13) {
            *(void *)(v13 + 16) = v3;
          }
          v2[2] = v3[2];
          *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (v6 = *((unsigned __int8 *)v4 + 24), CFIndex v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          uint64_t v11 = a2[1];
          *uint64_t v2 = v11;
          if (v11)
          {
            *(void *)(v11 + 16) = v2;
            id v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          id v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((unsigned char *)a2 + 24) = 1;
        *((unsigned char *)v3 + 24) = 0;
        uint64_t v2 = (uint64_t *)v3[1];
        uint64_t v12 = *v2;
        v3[1] = *v2;
        if (v12) {
          *(void *)(v12 + 16) = v3;
        }
        v2[2] = v3[2];
        *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
        *uint64_t v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }
      *((unsigned char *)v2 + 24) = 1;
      a2 = v3;
      *((unsigned char *)v3 + 24) = v3 == result;
      *CFIndex v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

void *TFontFeatures::GetFeatureType(atomic_ullong *this, const __CFNumber *a2)
{
  __int16 v11 = -21846;
  if (!GetSettingValue<__CFNumber const*,unsigned short>((uint64_t)a2, &v11)) {
    return 0;
  }
  CFArrayRef explicit = (const __CFArray *)atomic_load_explicit(this, memory_order_acquire);
  if (!explicit) {
    return 0;
  }
  CFIndex Count = CFArrayGetCount(explicit);
  if (!Count) {
    return 0;
  }
  CFIndex v5 = Count;
  CFIndex v6 = 0;
  while (1)
  {
    CFNumberRef Value = (id)CFArrayGetValueAtIndex(explicit, v6);
    int v8 = Value;
    __int16 v10 = -21846;
    if (Value) {
      CFNumberRef Value = (void *)CFDictionaryGetValue((CFDictionaryRef)Value, @"CTFeatureTypeIdentifier");
    }
    if (GetSettingValue<__CFNumber const*,unsigned short>((uint64_t)Value, &v10) && v11 == v10) {
      break;
    }

    if (v5 == ++v6) {
      return 0;
    }
  }

  return v8;
}

uint64_t GetSettingValue<__CFNumber const*,unsigned short>(uint64_t result, void *a2)
{
  if (result)
  {
    CFNumberRef v3 = (const __CFNumber *)result;
    CFTypeID v4 = CFGetTypeID((CFTypeRef)result);
    if (v4 == CFNumberGetTypeID() || v4 == CFBooleanGetTypeID())
    {
      if (a2) {
        CFNumberGetValue(v3, kCFNumberShortType, a2);
      }
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void *anonymous namespace'::TFeatureType::GetSelector(atomic_ullong *this, const __CFNumber *a2)
{
  __int16 v13 = -21846;
  if (!GetSettingValue<__CFNumber const*,unsigned short>((uint64_t)a2, &v13)) {
    return 0;
  }
    v13 &= ~1u;
  CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit(this, memory_order_acquire);
  if (!explicit) {
    return 0;
  }
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(explicit, @"CTFeatureTypeSelectors");
  if (!Value) {
    return 0;
  }
  CFArrayRef v5 = Value;
  CFIndex Count = CFArrayGetCount(Value);
  if (!Count) {
    return 0;
  }
  CFIndex v7 = Count;
  CFIndex v8 = 0;
  while (1)
  {
    CFDictionaryRef v9 = (id)CFArrayGetValueAtIndex(v5, v8);
    __int16 v10 = v9;
    __int16 v12 = -21846;
    if (v9) {
      CFDictionaryRef v9 = (void *)CFDictionaryGetValue((CFDictionaryRef)v9, @"CTFeatureSelectorIdentifier");
    }
    if (GetSettingValue<__CFNumber const*,unsigned short>((uint64_t)v9, &v12) && v13 == v12) {
      break;
    }

    if (v7 == ++v8) {
      return 0;
    }
  }

  return v10;
}

void TBaseFont::CopyVariationAxes(atomic_ullong *this@<X0>, unint64_t *a2@<X8>)
{
  if ((*(unsigned int (**)(atomic_ullong *))(*this + 712))(this))
  {
    *a2 = 0;
    return;
  }
  id v9 = (id)0xAAAAAAAAAAAAAAAALL;
  TBaseFont::CopyAttributeInternal(this, @"NSCTFontVariationAxesAttribute", &v8);
  id v9 = (id)atomic_exchange((atomic_ullong *volatile)&v8, 0);

  if (!atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire))
  {
    if ((*(unsigned int (**)(atomic_ullong *))(*this + 704))(this))
    {
      CopyAttributeForSystemFont((const __CFString *)atomic_load_explicit(this + 12, memory_order_acquire), @"NSCTFontVariationAxesAttribute", (const __CFString **)&v8);
    }
    if (!atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire))
    {
      TBaseFont::GetInitializedGraphicsFont((TBaseFont *)this);
      id v8 = (id)0xAAAAAAAAAAAAAAAALL;
      CopyVariationAxes(&v8);
      if (atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire)) {
        TCFRef<__CTFont const*>::Retain((atomic_ullong *)&v9, (id)atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire));
      }
    }
    if (!atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire)
      || (CFTypeID v6 = CFGetTypeID((CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire)),
          v6 != CFArrayGetTypeID())
      || CFArrayGetCount((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire)) < 1)
    {
      TBaseFont::SetAttributeInternal<__CFDictionary const*>(this, (const void *)*MEMORY[0x1E4F1D260], @"NSCTFontVariationAxesAttribute");
      goto LABEL_17;
    }
    id v7 = (id)atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire);
    TBaseFont::SetAttributeInternal<TCFRef<__CFSet const*>>(this, (atomic_ullong *)&v7, @"NSCTFontVariationAxesAttribute");
  }
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire);
  if (*MEMORY[0x1E4F1D260] == explicit)
  {
LABEL_17:
    unint64_t v5 = 0;
    goto LABEL_18;
  }
  unint64_t v5 = atomic_exchange((atomic_ullong *volatile)&v9, 0);
LABEL_18:
  *a2 = v5;
}

void TBaseFont::CopyFeaturesInternal(TBaseFont *this@<X0>, atomic_ullong *a2@<X1>, int a3@<W2>, const __CFArray **a4@<X8>)
{
  int v8 = *((_DWORD *)this + 44);
  if (a3) {
    id v9 = @"NSCTFontFeaturesAttribute";
  }
  else {
    id v9 = @"NSCTFontFeaturesInternalAttribute";
  }
  id v17 = (id)0xAAAAAAAAAAAAAAAALL;
  TBaseFont::CopyAttributeInternal((atomic_ullong *)this, v9, &v16);
  id v17 = (id)atomic_exchange((atomic_ullong *volatile)&v16, 0);

  if (!atomic_load_explicit((atomic_ullong *volatile)&v17, memory_order_acquire) && (a3 & 1) == 0 && v8 != 208)
  {
    if ((*(unsigned int (**)(TBaseFont *))(*(void *)this + 704))(this))
    {
      CopyAttributeForSystemFont((const __CFString *)atomic_load_explicit(a2 + 12, memory_order_acquire), @"NSCTFontFeaturesAttribute", (const __CFString **)&v16);

      if (atomic_load_explicit((atomic_ullong *volatile)&v17, memory_order_acquire))
      {
        CFIndex Count = CFArrayGetCount((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v17, memory_order_acquire));
        unint64_t explicit = (void *)atomic_load_explicit((atomic_ullong *volatile)&v17, memory_order_acquire);
        if (!Count) {
          goto LABEL_15;
        }
        id v15 = explicit;
        TBaseFont::SetAttributeInternal<TCFRef<__CFSet const*>>((atomic_ullong *)this, (atomic_ullong *)&v15, v9);
      }
    }
  }
  if (!atomic_load_explicit((atomic_ullong *volatile)&v17, memory_order_acquire) && v8 != 208)
  {
    TFontFeatures::TFontFeatures((TFontFeatures *)&v16, (const TBaseFont *)a2, a3);

    if (atomic_load_explicit((atomic_ullong *volatile)&v17, memory_order_acquire))
    {
      id v14 = (id)atomic_load_explicit((atomic_ullong *volatile)&v17, memory_order_acquire);
      TBaseFont::SetAttributeInternal<TCFRef<__CFSet const*>>((atomic_ullong *)this, (atomic_ullong *)&v14, v9);
    }
  }
LABEL_15:
  CFArrayRef v12 = (const __CFArray *)(id)atomic_load_explicit((atomic_ullong *volatile)&v17, memory_order_acquire);
  CFArrayRef v13 = v12;
  if (v12)
  {
    if (CFArrayGetCount(v12) < 1) {
      CFArrayRef v12 = 0;
    }
    else {
      CFArrayRef v12 = (const __CFArray *)(id)atomic_load_explicit((atomic_ullong *volatile)&v17, memory_order_acquire);
    }
  }
  *a4 = v12;
}

BOOL TBaseFont::HasOTFontFeatureTable(atomic_ullong *this)
{
  id v9 = (id)0xAAAAAAAAAAAAAAAALL;
  TBaseFont::CopyAttributeInternal(this, @"CTFontHasOTFeatures", &v9);
  if (atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire)) {
    goto LABEL_9;
  }
  if (!(*(unsigned int (**)(atomic_ullong *))(*this + 704))(this)
    || (CopyAttributeForSystemFont((const __CFString *)atomic_load_explicit(this + 12, memory_order_acquire), @"CTFontHasOTFeatures", (const __CFString **)&v8), (id)atomic_exchange((atomic_ullong *volatile)&v9, atomic_exchange((atomic_ullong *volatile)&v8, 0)), v8, !atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire)))
  {
    (*(void (**)(id *__return_ptr, atomic_ullong *))(*this + 144))(&v8, this);
    CFTypeID v4 = (id *)MEMORY[0x1E4F1CFD0];
    if (!atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire)) {
      CFTypeID v4 = (id *)MEMORY[0x1E4F1CFC8];
    }
    TCFRef<__CTFont const*>::Retain((atomic_ullong *)&v9, *v4);

    id v6 = (id)atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire);
    TBaseFont::SetAttributeInternal<TCFRef<__CFSet const*>>(this, (atomic_ullong *)&v6, @"CTFontHasOTFeatures");

LABEL_9:
    CFBooleanRef explicit = (const __CFBoolean *)atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire);
    if (!explicit) {
      goto LABEL_5;
    }
LABEL_10:
    BOOL v3 = CFBooleanGetValue(explicit) != 0;
    goto LABEL_11;
  }
  id v7 = (id)atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire);
  TBaseFont::SetAttributeInternal<TCFRef<__CFSet const*>>(this, (atomic_ullong *)&v7, @"CTFontHasOTFeatures");

  CFBooleanRef explicit = (const __CFBoolean *)atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire);
  if (explicit) {
    goto LABEL_10;
  }
LABEL_5:
  BOOL v3 = 0;
LABEL_11:

  return v3;
}

void TBaseFont::CreateDescriptorAttributes(atomic_ullong *this@<X0>, CFDictionaryRef *a2@<X8>)
{
  uint64_t v71 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v69[14] = v4;
  v69[13] = v4;
  v69[12] = v4;
  v69[11] = v4;
  v69[10] = v4;
  v69[9] = v4;
  v69[8] = v4;
  v69[7] = v4;
  v69[6] = v4;
  v69[5] = v4;
  v69[4] = v4;
  v69[3] = v4;
  v69[2] = v4;
  v69[1] = v4;
  v69[0] = v4;
  int64x2_t v67 = 0uLL;
  double v68 = 0;
  id v70 = v69;
  v65[14] = v4;
  v65[13] = v4;
  v65[12] = v4;
  v65[11] = v4;
  v65[10] = v4;
  v65[9] = v4;
  v65[8] = v4;
  v65[7] = v4;
  v65[6] = v4;
  v65[5] = v4;
  v65[4] = v4;
  v65[3] = v4;
  v65[2] = v4;
  v65[1] = v4;
  v65[0] = v4;
  values[1] = 0;
  uint64_t v64 = 0;
  values[0] = 0;
  uint64_t v66 = v65;
  CFBooleanRef explicit = (void *)atomic_load_explicit(this + 12, memory_order_acquire);
  if (explicit)
  {
    uint64_t v6 = v67.i64[1];
    if (v67.i64[1] >= (unint64_t)v68)
    {
      uint64_t v8 = (v67.i64[1] - v67.i64[0]) >> 3;
      if ((unint64_t)(v8 + 1) >> 61) {
        goto LABEL_70;
      }
      unint64_t v9 = (uint64_t)&v68[-v67.i64[0]] >> 2;
      if (v9 <= v8 + 1) {
        unint64_t v9 = v8 + 1;
      }
      if ((unint64_t)&v68[-v67.i64[0]] >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v10 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v10 = v9;
      }
      char v62 = v69;
      if (v10) {
        __int16 v11 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v69, v10);
      }
      else {
        __int16 v11 = 0;
      }
      CFArrayRef v12 = &v11[8 * v8];
      CFArrayRef v13 = &v11[8 * v10];
      char v61 = (void **)v13;
      *(void *)CFArrayRef v12 = @"NSFontNameAttribute";
      id v7 = v12 + 8;
      v60.i64[1] = (uint64_t)(v12 + 8);
      uint64_t v14 = v67.i64[1];
      uint64_t v15 = v67.i64[0];
      if (v67.i64[1] == v67.i64[0])
      {
        int64x2_t v17 = vdupq_n_s64(v67.u64[1]);
      }
      else
      {
        do
        {
          uint64_t v16 = *(void *)(v14 - 8);
          v14 -= 8;
          *((void *)v12 - 1) = v16;
          v12 -= 8;
        }
        while (v14 != v15);
        int64x2_t v17 = v67;
        id v7 = (void *)v60.i64[1];
        CFArrayRef v13 = (char *)v61;
      }
      v67.i64[0] = (uint64_t)v12;
      v67.i64[1] = (uint64_t)v7;
      int64x2_t v60 = v17;
      int v18 = (void **)v68;
      double v68 = v13;
      char v61 = v18;
      id v59 = (id)v17.i64[0];
      std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v59);
    }
    else
    {
      *(void *)v67.i64[1] = @"NSFontNameAttribute";
      id v7 = (void *)(v6 + 8);
    }
    v67.i64[1] = (uint64_t)v7;
    int v19 = values[1];
    if (values[1] >= v64)
    {
      int64_t v21 = values[1] - values[0];
      if ((unint64_t)(v21 + 1) >> 61) {
        goto LABEL_70;
      }
      unint64_t v22 = ((char *)v64 - (char *)values[0]) >> 2;
      if (v22 <= v21 + 1) {
        unint64_t v22 = v21 + 1;
      }
      if ((unint64_t)((char *)v64 - (char *)values[0]) >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v23 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v23 = v22;
      }
      char v62 = v65;
      if (v23) {
        uint64_t v24 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v65, v23);
      }
      else {
        uint64_t v24 = 0;
      }
      CFIndex v25 = (void **)&v24[8 * v21];
      unsigned __int16 v26 = (void **)&v24[8 * v23];
      char v61 = v26;
      *CFIndex v25 = explicit;
      uint64_t v20 = v25 + 1;
      v60.i64[1] = (uint64_t)(v25 + 1);
      unsigned int v28 = values[0];
      BOOL v27 = values[1];
      if (values[1] == values[0])
      {
        int64x2_t v30 = vdupq_n_s64((unint64_t)values[1]);
      }
      else
      {
        do
        {
          uint64_t v29 = *--v27;
          *--CFIndex v25 = v29;
        }
        while (v27 != v28);
        int64x2_t v30 = *(int64x2_t *)values;
        uint64_t v20 = (void **)v60.i64[1];
        unsigned __int16 v26 = v61;
      }
      values[0] = v25;
      values[1] = v20;
      int64x2_t v60 = v30;
      CFIndex v31 = v64;
      uint64_t v64 = v26;
      char v61 = v31;
      id v59 = (id)v30.i64[0];
      std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v59);
    }
    else
    {
      *values[1] = explicit;
      uint64_t v20 = v19 + 1;
    }
    values[1] = v20;
  }
  TBaseFont::CopyAttributeInternal(this, @"NSCTFontMatrixAttribute", &v59);
  char v32 = (void *)atomic_exchange((atomic_ullong *volatile)&v59, 0);

  if (v32)
  {
    uint64_t v33 = v67.i64[1];
    if (v67.i64[1] >= (unint64_t)v68)
    {
      uint64_t v35 = (v67.i64[1] - v67.i64[0]) >> 3;
      if ((unint64_t)(v35 + 1) >> 61) {
        goto LABEL_70;
      }
      unint64_t v36 = (uint64_t)&v68[-v67.i64[0]] >> 2;
      if (v36 <= v35 + 1) {
        unint64_t v36 = v35 + 1;
      }
      if ((unint64_t)&v68[-v67.i64[0]] >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v37 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v37 = v36;
      }
      char v62 = v69;
      if (v37) {
        uint64_t v38 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v69, v37);
      }
      else {
        uint64_t v38 = 0;
      }
      BOOL v39 = &v38[8 * v35];
      id v40 = &v38[8 * v37];
      char v61 = (void **)v40;
      *(void *)BOOL v39 = @"NSCTFontMatrixAttribute";
      id v34 = v39 + 8;
      v60.i64[1] = (uint64_t)(v39 + 8);
      uint64_t v41 = v67.i64[1];
      uint64_t v42 = v67.i64[0];
      if (v67.i64[1] == v67.i64[0])
      {
        int64x2_t v44 = vdupq_n_s64(v67.u64[1]);
      }
      else
      {
        do
        {
          uint64_t v43 = *(void *)(v41 - 8);
          v41 -= 8;
          *((void *)v39 - 1) = v43;
          v39 -= 8;
        }
        while (v41 != v42);
        int64x2_t v44 = v67;
        id v34 = (void *)v60.i64[1];
        id v40 = (char *)v61;
      }
      v67.i64[0] = (uint64_t)v39;
      v67.i64[1] = (uint64_t)v34;
      int64x2_t v60 = v44;
      uint64_t v45 = (void **)v68;
      double v68 = v40;
      char v61 = v45;
      id v59 = (id)v44.i64[0];
      std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v59);
    }
    else
    {
      *(void *)v67.i64[1] = @"NSCTFontMatrixAttribute";
      id v34 = (void *)(v33 + 8);
    }
    v67.i64[1] = (uint64_t)v34;
    uint64_t v46 = values[1];
    if (values[1] < v64)
    {
      *values[1] = v32;
      uint64_t v47 = v46 + 1;
LABEL_68:
      values[1] = v47;
      goto LABEL_69;
    }
    int64_t v48 = values[1] - values[0];
    if (!((unint64_t)(v48 + 1) >> 61))
    {
      unint64_t v49 = ((char *)v64 - (char *)values[0]) >> 2;
      if (v49 <= v48 + 1) {
        unint64_t v49 = v48 + 1;
      }
      if ((unint64_t)((char *)v64 - (char *)values[0]) >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v50 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v50 = v49;
      }
      char v62 = v65;
      if (v50) {
        BOOL v51 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v65, v50);
      }
      else {
        BOOL v51 = 0;
      }
      unint64_t v52 = (void **)&v51[8 * v48];
      long long v53 = (void **)&v51[8 * v50];
      char v61 = v53;
      *unint64_t v52 = v32;
      uint64_t v47 = v52 + 1;
      v60.i64[1] = (uint64_t)(v52 + 1);
      uint64_t v55 = values[0];
      int v54 = values[1];
      if (values[1] == values[0])
      {
        int64x2_t v57 = vdupq_n_s64((unint64_t)values[1]);
      }
      else
      {
        do
        {
          unint64_t v56 = *--v54;
          *--unint64_t v52 = v56;
        }
        while (v54 != v55);
        int64x2_t v57 = *(int64x2_t *)values;
        uint64_t v47 = (void **)v60.i64[1];
        long long v53 = v61;
      }
      values[0] = v52;
      values[1] = v47;
      int64x2_t v60 = v57;
      CFArrayRef v58 = v64;
      uint64_t v64 = v53;
      char v61 = v58;
      id v59 = (id)v57.i64[0];
      std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v59);
      goto LABEL_68;
    }
LABEL_70:
    abort();
  }
LABEL_69:
  (*(void (**)(atomic_ullong *, int64x2_t *, void ***))(*this + 832))(this, &v67, values);
  *a2 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)v67.i64[0], (const void **)values[0], (v67.i64[1] - v67.i64[0]) >> 3, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);

  id v59 = values;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v59);
  values[0] = (void **)&v67;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](values);
}

void TBaseFont::CopyAttributeInternal(atomic_ullong *this@<X0>, const void *a2@<X1>, void *a3@<X8>)
{
  uint64_t v6 = (os_unfair_lock_s *)(this + 14);
  os_unfair_lock_lock_with_options();
  *a3 = 0xAAAAAAAAAAAAAAAALL;
  CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit(this + 15, memory_order_acquire);
  if (explicit) {
    CFDictionaryRef explicit = (const __CFDictionary *)CFDictionaryGetValue(explicit, a2);
  }
  *a3 = explicit;

  os_unfair_lock_unlock(v6);
}

uint64_t TTenuousComponentFont::AddDescriptorAttributes(uint64_t a1, int64x2_t *a2, int64x2_t *a3)
{
  uint64_t result = (uint64_t)TComponentFont::AddDescriptorAttributes((atomic_ullong *)a1, a2, a3);
  if (*(unsigned char *)(a1 + 793))
  {
    uint64_t v8 = (void *)a2->i64[1];
    unint64_t v7 = a2[1].u64[0];
    if ((unint64_t)v8 >= v7)
    {
      uint64_t v10 = ((uint64_t)v8 - a2->i64[0]) >> 3;
      if ((unint64_t)(v10 + 1) >> 61) {
        goto LABEL_36;
      }
      uint64_t v11 = v7 - a2->i64[0];
      uint64_t v12 = v11 >> 2;
      if (v11 >> 2 <= (unint64_t)(v10 + 1)) {
        uint64_t v12 = v10 + 1;
      }
      if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v13 = v12;
      }
      uint64_t v41 = &a2[1].i8[8];
      if (v13) {
        uint64_t v14 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&a2[1].i64[1], v13);
      }
      else {
        uint64_t v14 = 0;
      }
      uint64_t v15 = &v14[8 * v10];
      uint64_t v16 = &v14[8 * v13];
      id v40 = v16;
      *(void *)uint64_t v15 = @"NSCTFontVariationAttribute";
      unint64_t v9 = v15 + 8;
      v39.i64[1] = (uint64_t)(v15 + 8);
      uint64_t v18 = a2->i64[0];
      unint64_t v17 = a2->u64[1];
      if (v17 == a2->i64[0])
      {
        int64x2_t v20 = vdupq_n_s64(v17);
      }
      else
      {
        do
        {
          uint64_t v19 = *(void *)(v17 - 8);
          v17 -= 8;
          *((void *)v15 - 1) = v19;
          v15 -= 8;
        }
        while (v17 != v18);
        int64x2_t v20 = *a2;
        unint64_t v9 = (void *)v39.i64[1];
        uint64_t v16 = v40;
      }
      a2->i64[0] = (uint64_t)v15;
      a2->i64[1] = (uint64_t)v9;
      int64x2_t v39 = v20;
      uint64_t v21 = a2[1].i64[0];
      a2[1].i64[0] = (uint64_t)v16;
      id v40 = (char *)v21;
      uint64_t v38 = v20.i64[0];
      uint64_t result = std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v38);
    }
    else
    {
      *uint64_t v8 = @"NSCTFontVariationAttribute";
      unint64_t v9 = v8 + 1;
    }
    a2->i64[1] = (uint64_t)v9;
    unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(a1 + 768), memory_order_acquire);
    uint64_t v24 = (unint64_t *)a3->i64[1];
    unint64_t v23 = a3[1].u64[0];
    if ((unint64_t)v24 < v23)
    {
      *uint64_t v24 = explicit;
      CFIndex v25 = v24 + 1;
LABEL_34:
      a3->i64[1] = (uint64_t)v25;
      return result;
    }
    uint64_t v26 = ((uint64_t)v24 - a3->i64[0]) >> 3;
    if (!((unint64_t)(v26 + 1) >> 61))
    {
      uint64_t v27 = v23 - a3->i64[0];
      uint64_t v28 = v27 >> 2;
      if (v27 >> 2 <= (unint64_t)(v26 + 1)) {
        uint64_t v28 = v26 + 1;
      }
      if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v29 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v29 = v28;
      }
      uint64_t v41 = &a3[1].i8[8];
      if (v29) {
        int64x2_t v30 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&a3[1].i64[1], v29);
      }
      else {
        int64x2_t v30 = 0;
      }
      CFIndex v31 = (unint64_t *)&v30[8 * v26];
      char v32 = &v30[8 * v29];
      id v40 = v32;
      *CFIndex v31 = explicit;
      CFIndex v25 = v31 + 1;
      v39.i64[1] = (uint64_t)(v31 + 1);
      uint64_t v34 = a3->i64[0];
      unint64_t v33 = a3->u64[1];
      if (v33 == a3->i64[0])
      {
        int64x2_t v36 = vdupq_n_s64(v33);
      }
      else
      {
        do
        {
          unint64_t v35 = *(void *)(v33 - 8);
          v33 -= 8;
          *--CFIndex v31 = v35;
        }
        while (v33 != v34);
        int64x2_t v36 = *a3;
        CFIndex v25 = (void *)v39.i64[1];
        char v32 = v40;
      }
      a3->i64[0] = (uint64_t)v31;
      a3->i64[1] = (uint64_t)v25;
      int64x2_t v39 = v36;
      uint64_t v37 = a3[1].i64[0];
      a3[1].i64[0] = (uint64_t)v32;
      id v40 = (char *)v37;
      uint64_t v38 = v36.i64[0];
      uint64_t result = std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v38);
      goto LABEL_34;
    }
LABEL_36:
    abort();
  }
  return result;
}

const __CFDictionary *TComponentFont::AddDescriptorAttributes(atomic_ullong *a1, int64x2_t *a2, int64x2_t *a3)
{
  if ((*(unsigned int (**)(atomic_ullong *))(*a1 + 840))(a1))
  {
    CFArrayRef ComponentAttribute = TComponentFont::GetComponentAttribute(a1, @"NSCTFontUIUsageAttribute");
    if (ComponentAttribute)
    {
      unint64_t v7 = ComponentAttribute;
      unint64_t v9 = (void *)a2->i64[1];
      unint64_t v8 = a2[1].u64[0];
      if ((unint64_t)v9 >= v8)
      {
        uint64_t v11 = ((uint64_t)v9 - a2->i64[0]) >> 3;
        if ((unint64_t)(v11 + 1) >> 61) {
          goto LABEL_141;
        }
        uint64_t v12 = v8 - a2->i64[0];
        uint64_t v13 = v12 >> 2;
        if (v12 >> 2 <= (unint64_t)(v11 + 1)) {
          uint64_t v13 = v11 + 1;
        }
        if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v14 = v13;
        }
        unint64_t v136 = &a2[1].i64[1];
        if (v14) {
          uint64_t v15 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&a2[1].i64[1], v14);
        }
        else {
          uint64_t v15 = 0;
        }
        uint64_t v16 = &v15[8 * v11];
        unint64_t v17 = &v15[8 * v14];
        double v135 = v17;
        *(void *)uint64_t v16 = @"NSCTFontUIUsageAttribute";
        uint64_t v10 = v16 + 8;
        v134.i64[1] = (uint64_t)(v16 + 8);
        uint64_t v19 = a2->i64[0];
        unint64_t v18 = a2->u64[1];
        if (v18 == a2->i64[0])
        {
          int64x2_t v21 = vdupq_n_s64(v18);
        }
        else
        {
          do
          {
            uint64_t v20 = *(void *)(v18 - 8);
            v18 -= 8;
            *((void *)v16 - 1) = v20;
            v16 -= 8;
          }
          while (v18 != v19);
          int64x2_t v21 = *a2;
          uint64_t v10 = (void *)v134.i64[1];
          unint64_t v17 = v135;
        }
        a2->i64[0] = (uint64_t)v16;
        a2->i64[1] = (uint64_t)v10;
        int64x2_t v134 = v21;
        unint64_t v22 = (char *)a2[1].i64[0];
        a2[1].i64[0] = (uint64_t)v17;
        double v135 = v22;
        id v133 = (id)v21.i64[0];
        std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v133);
      }
      else
      {
        *unint64_t v9 = @"NSCTFontUIUsageAttribute";
        uint64_t v10 = v9 + 1;
      }
      a2->i64[1] = (uint64_t)v10;
      uint64_t v24 = (void *)a3->i64[1];
      unint64_t v23 = a3[1].u64[0];
      if ((unint64_t)v24 >= v23)
      {
        uint64_t v26 = ((uint64_t)v24 - a3->i64[0]) >> 3;
        if ((unint64_t)(v26 + 1) >> 61) {
          goto LABEL_141;
        }
        uint64_t v27 = v23 - a3->i64[0];
        uint64_t v28 = v27 >> 2;
        if (v27 >> 2 <= (unint64_t)(v26 + 1)) {
          uint64_t v28 = v26 + 1;
        }
        if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v29 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v29 = v28;
        }
        unint64_t v136 = &a3[1].i64[1];
        if (v29) {
          int64x2_t v30 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&a3[1].i64[1], v29);
        }
        else {
          int64x2_t v30 = 0;
        }
        CFIndex v31 = &v30[8 * v26];
        char v32 = &v30[8 * v29];
        double v135 = v32;
        *(void *)CFIndex v31 = v7;
        CFIndex v25 = v31 + 8;
        v134.i64[1] = (uint64_t)(v31 + 8);
        uint64_t v34 = a3->i64[0];
        unint64_t v33 = a3->u64[1];
        if (v33 == a3->i64[0])
        {
          int64x2_t v36 = vdupq_n_s64(v33);
        }
        else
        {
          do
          {
            uint64_t v35 = *(void *)(v33 - 8);
            v33 -= 8;
            *((void *)v31 - 1) = v35;
            v31 -= 8;
          }
          while (v33 != v34);
          int64x2_t v36 = *a3;
          CFIndex v25 = (void *)v134.i64[1];
          char v32 = v135;
        }
        a3->i64[0] = (uint64_t)v31;
        a3->i64[1] = (uint64_t)v25;
        int64x2_t v134 = v36;
        uint64_t v37 = (char *)a3[1].i64[0];
        a3[1].i64[0] = (uint64_t)v32;
        double v135 = v37;
        id v133 = (id)v36.i64[0];
        std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v133);
      }
      else
      {
        *uint64_t v24 = v7;
        CFIndex v25 = v24 + 1;
      }
      a3->i64[1] = (uint64_t)v25;
      if ((*(unsigned int (**)(atomic_ullong *))(*a1 + 856))(a1))
      {
        uint64_t v38 = TComponentFont::GetComponentAttribute(a1, @"sizeCategory");
        if (v38)
        {
          int64x2_t v39 = v38;
          uint64_t v41 = (void *)a2->i64[1];
          unint64_t v40 = a2[1].u64[0];
          if ((unint64_t)v41 >= v40)
          {
            uint64_t v43 = ((uint64_t)v41 - a2->i64[0]) >> 3;
            if ((unint64_t)(v43 + 1) >> 61) {
              goto LABEL_141;
            }
            uint64_t v44 = v40 - a2->i64[0];
            uint64_t v45 = v44 >> 2;
            if (v44 >> 2 <= (unint64_t)(v43 + 1)) {
              uint64_t v45 = v43 + 1;
            }
            if ((unint64_t)v44 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v46 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v46 = v45;
            }
            unint64_t v136 = &a2[1].i64[1];
            if (v46) {
              uint64_t v47 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&a2[1].i64[1], v46);
            }
            else {
              uint64_t v47 = 0;
            }
            int64_t v48 = &v47[8 * v43];
            unint64_t v49 = &v47[8 * v46];
            double v135 = v49;
            *(void *)int64_t v48 = @"NSCTFontSizeCategoryAttribute";
            uint64_t v42 = v48 + 8;
            v134.i64[1] = (uint64_t)(v48 + 8);
            uint64_t v51 = a2->i64[0];
            unint64_t v50 = a2->u64[1];
            if (v50 == a2->i64[0])
            {
              int64x2_t v53 = vdupq_n_s64(v50);
            }
            else
            {
              do
              {
                uint64_t v52 = *(void *)(v50 - 8);
                v50 -= 8;
                *((void *)v48 - 1) = v52;
                v48 -= 8;
              }
              while (v50 != v51);
              int64x2_t v53 = *a2;
              uint64_t v42 = (void *)v134.i64[1];
              unint64_t v49 = v135;
            }
            a2->i64[0] = (uint64_t)v48;
            a2->i64[1] = (uint64_t)v42;
            int64x2_t v134 = v53;
            int v54 = (char *)a2[1].i64[0];
            a2[1].i64[0] = (uint64_t)v49;
            double v135 = v54;
            id v133 = (id)v53.i64[0];
            std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v133);
          }
          else
          {
            *uint64_t v41 = @"NSCTFontSizeCategoryAttribute";
            uint64_t v42 = v41 + 1;
          }
          a2->i64[1] = (uint64_t)v42;
          unint64_t v56 = (void *)a3->i64[1];
          unint64_t v55 = a3[1].u64[0];
          if ((unint64_t)v56 >= v55)
          {
            uint64_t v58 = ((uint64_t)v56 - a3->i64[0]) >> 3;
            if ((unint64_t)(v58 + 1) >> 61) {
              goto LABEL_141;
            }
            uint64_t v59 = v55 - a3->i64[0];
            uint64_t v60 = v59 >> 2;
            if (v59 >> 2 <= (unint64_t)(v58 + 1)) {
              uint64_t v60 = v58 + 1;
            }
            if ((unint64_t)v59 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v61 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v61 = v60;
            }
            unint64_t v136 = &a3[1].i64[1];
            if (v61) {
              char v62 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&a3[1].i64[1], v61);
            }
            else {
              char v62 = 0;
            }
            long long v63 = &v62[8 * v58];
            uint64_t v64 = &v62[8 * v61];
            double v135 = v64;
            *(void *)long long v63 = v39;
            int64x2_t v57 = v63 + 8;
            v134.i64[1] = (uint64_t)(v63 + 8);
            uint64_t v66 = a3->i64[0];
            unint64_t v65 = a3->u64[1];
            if (v65 == a3->i64[0])
            {
              int64x2_t v68 = vdupq_n_s64(v65);
            }
            else
            {
              do
              {
                uint64_t v67 = *(void *)(v65 - 8);
                v65 -= 8;
                *((void *)v63 - 1) = v67;
                v63 -= 8;
              }
              while (v65 != v66);
              int64x2_t v68 = *a3;
              int64x2_t v57 = (void *)v134.i64[1];
              uint64_t v64 = v135;
            }
            a3->i64[0] = (uint64_t)v63;
            a3->i64[1] = (uint64_t)v57;
            int64x2_t v134 = v68;
            CFStringRef v69 = (char *)a3[1].i64[0];
            a3[1].i64[0] = (uint64_t)v64;
            double v135 = v69;
            id v133 = (id)v68.i64[0];
            std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v133);
          }
          else
          {
            *unint64_t v56 = v39;
            int64x2_t v57 = v56 + 1;
          }
          a3->i64[1] = (uint64_t)v57;
        }
      }
      (*(void (**)(id *__return_ptr, atomic_ullong *, uint64_t))(*a1 + 40))(&v133, a1, 57);
      id v70 = (void *)atomic_exchange((atomic_ullong *volatile)&v133, 0);

      if (v70)
      {
        id v72 = (void *)a2->i64[1];
        unint64_t v71 = a2[1].u64[0];
        if ((unint64_t)v72 >= v71)
        {
          uint64_t v74 = ((uint64_t)v72 - a2->i64[0]) >> 3;
          if ((unint64_t)(v74 + 1) >> 61) {
            goto LABEL_141;
          }
          uint64_t v75 = v71 - a2->i64[0];
          uint64_t v76 = v75 >> 2;
          if (v75 >> 2 <= (unint64_t)(v74 + 1)) {
            uint64_t v76 = v74 + 1;
          }
          if ((unint64_t)v75 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v77 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v77 = v76;
          }
          unint64_t v136 = &a2[1].i64[1];
          if (v77) {
            uint64_t v78 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&a2[1].i64[1], v77);
          }
          else {
            uint64_t v78 = 0;
          }
          uint64_t v79 = &v78[8 * v74];
          char v80 = &v78[8 * v77];
          double v135 = v80;
          *(void *)uint64_t v79 = @"NSCTFontTraitsAttribute";
          int v73 = v79 + 8;
          v134.i64[1] = (uint64_t)(v79 + 8);
          uint64_t v82 = a2->i64[0];
          unint64_t v81 = a2->u64[1];
          if (v81 == a2->i64[0])
          {
            int64x2_t v84 = vdupq_n_s64(v81);
          }
          else
          {
            do
            {
              uint64_t v83 = *(void *)(v81 - 8);
              v81 -= 8;
              *((void *)v79 - 1) = v83;
              v79 -= 8;
            }
            while (v81 != v82);
            int64x2_t v84 = *a2;
            int v73 = (void *)v134.i64[1];
            char v80 = v135;
          }
          a2->i64[0] = (uint64_t)v79;
          a2->i64[1] = (uint64_t)v73;
          int64x2_t v134 = v84;
          long long v85 = (char *)a2[1].i64[0];
          a2[1].i64[0] = (uint64_t)v80;
          double v135 = v85;
          id v133 = (id)v84.i64[0];
          std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v133);
        }
        else
        {
          *id v72 = @"NSCTFontTraitsAttribute";
          int v73 = v72 + 1;
        }
        a2->i64[1] = (uint64_t)v73;
        __int16 v87 = (void *)a3->i64[1];
        unint64_t v86 = a3[1].u64[0];
        if ((unint64_t)v87 >= v86)
        {
          uint64_t v89 = ((uint64_t)v87 - a3->i64[0]) >> 3;
          if ((unint64_t)(v89 + 1) >> 61) {
            goto LABEL_141;
          }
          uint64_t v90 = v86 - a3->i64[0];
          uint64_t v91 = v90 >> 2;
          if (v90 >> 2 <= (unint64_t)(v89 + 1)) {
            uint64_t v91 = v89 + 1;
          }
          if ((unint64_t)v90 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v92 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v92 = v91;
          }
          unint64_t v136 = &a3[1].i64[1];
          if (v92) {
            CGAffineTransform v93 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&a3[1].i64[1], v92);
          }
          else {
            CGAffineTransform v93 = 0;
          }
          long long v94 = &v93[8 * v89];
          long long v95 = &v93[8 * v92];
          double v135 = v95;
          *(void *)long long v94 = v70;
          int v88 = v94 + 8;
          v134.i64[1] = (uint64_t)(v94 + 8);
          uint64_t v97 = a3->i64[0];
          unint64_t v96 = a3->u64[1];
          if (v96 == a3->i64[0])
          {
            int64x2_t v99 = vdupq_n_s64(v96);
          }
          else
          {
            do
            {
              uint64_t v98 = *(void *)(v96 - 8);
              v96 -= 8;
              *((void *)v94 - 1) = v98;
              v94 -= 8;
            }
            while (v96 != v97);
            int64x2_t v99 = *a3;
            int v88 = (void *)v134.i64[1];
            long long v95 = v135;
          }
          a3->i64[0] = (uint64_t)v94;
          a3->i64[1] = (uint64_t)v88;
          int64x2_t v134 = v99;
          id v100 = (char *)a3[1].i64[0];
          a3[1].i64[0] = (uint64_t)v95;
          double v135 = v100;
          id v133 = (id)v99.i64[0];
          std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v133);
        }
        else
        {
          void *v87 = v70;
          int v88 = v87 + 1;
        }
        a3->i64[1] = (uint64_t)v88;
      }
    }
  }
  CFDictionaryRef result = (const __CFDictionary *)atomic_load_explicit(a1 + 90, memory_order_acquire);
  if (result)
  {
    CFDictionaryRef result = (const __CFDictionary *)CFDictionaryGetValue(result, @"ignoreLegibilityWeight");
    if (result)
    {
      long long v103 = (void *)a2->i64[1];
      unint64_t v102 = a2[1].u64[0];
      if ((unint64_t)v103 >= v102)
      {
        uint64_t v105 = ((uint64_t)v103 - a2->i64[0]) >> 3;
        if ((unint64_t)(v105 + 1) >> 61) {
          goto LABEL_141;
        }
        uint64_t v106 = v102 - a2->i64[0];
        uint64_t v107 = v106 >> 2;
        if (v106 >> 2 <= (unint64_t)(v105 + 1)) {
          uint64_t v107 = v105 + 1;
        }
        if ((unint64_t)v106 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v108 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v108 = v107;
        }
        unint64_t v136 = &a2[1].i64[1];
        if (v108) {
          uint64_t v109 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&a2[1].i64[1], v108);
        }
        else {
          uint64_t v109 = 0;
        }
        long long v110 = &v109[8 * v105];
        long long v111 = &v109[8 * v108];
        double v135 = v111;
        *(void *)long long v110 = @"CTFontIgnoreLegibilityWeightAttribute";
        uint64_t v104 = v110 + 8;
        v134.i64[1] = (uint64_t)(v110 + 8);
        uint64_t v113 = a2->i64[0];
        unint64_t v112 = a2->u64[1];
        if (v112 == a2->i64[0])
        {
          int64x2_t v115 = vdupq_n_s64(v112);
        }
        else
        {
          do
          {
            uint64_t v114 = *(void *)(v112 - 8);
            v112 -= 8;
            *((void *)v110 - 1) = v114;
            v110 -= 8;
          }
          while (v112 != v113);
          int64x2_t v115 = *a2;
          uint64_t v104 = (void *)v134.i64[1];
          long long v111 = v135;
        }
        a2->i64[0] = (uint64_t)v110;
        a2->i64[1] = (uint64_t)v104;
        int64x2_t v134 = v115;
        long long v116 = (char *)a2[1].i64[0];
        a2[1].i64[0] = (uint64_t)v111;
        double v135 = v116;
        id v133 = (id)v115.i64[0];
        CFDictionaryRef result = (const __CFDictionary *)std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v133);
      }
      else
      {
        void *v103 = @"CTFontIgnoreLegibilityWeightAttribute";
        uint64_t v104 = v103 + 1;
      }
      a2->i64[1] = (uint64_t)v104;
      uint64_t v117 = *MEMORY[0x1E4F1CFD0];
      long long v119 = (void *)a3->i64[1];
      unint64_t v118 = a3[1].u64[0];
      if ((unint64_t)v119 < v118)
      {
        void *v119 = v117;
        uint64_t v120 = v119 + 1;
LABEL_139:
        a3->i64[1] = (uint64_t)v120;
        return result;
      }
      uint64_t v121 = ((uint64_t)v119 - a3->i64[0]) >> 3;
      if (!((unint64_t)(v121 + 1) >> 61))
      {
        uint64_t v122 = v118 - a3->i64[0];
        uint64_t v123 = v122 >> 2;
        if (v122 >> 2 <= (unint64_t)(v121 + 1)) {
          uint64_t v123 = v121 + 1;
        }
        if ((unint64_t)v122 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v124 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v124 = v123;
        }
        unint64_t v136 = &a3[1].i64[1];
        if (v124) {
          uint64_t v125 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&a3[1].i64[1], v124);
        }
        else {
          uint64_t v125 = 0;
        }
        uint64_t v126 = &v125[8 * v121];
        uint64_t v127 = &v125[8 * v124];
        double v135 = v127;
        *(void *)uint64_t v126 = v117;
        uint64_t v120 = v126 + 8;
        v134.i64[1] = (uint64_t)(v126 + 8);
        uint64_t v129 = a3->i64[0];
        unint64_t v128 = a3->u64[1];
        if (v128 == a3->i64[0])
        {
          int64x2_t v131 = vdupq_n_s64(v128);
        }
        else
        {
          do
          {
            uint64_t v130 = *(void *)(v128 - 8);
            v128 -= 8;
            *((void *)v126 - 1) = v130;
            v126 -= 8;
          }
          while (v128 != v129);
          int64x2_t v131 = *a3;
          uint64_t v120 = (void *)v134.i64[1];
          uint64_t v127 = v135;
        }
        a3->i64[0] = (uint64_t)v126;
        a3->i64[1] = (uint64_t)v120;
        int64x2_t v134 = v131;
        char v132 = (char *)a3[1].i64[0];
        a3[1].i64[0] = (uint64_t)v127;
        double v135 = v132;
        id v133 = (id)v131.i64[0];
        CFDictionaryRef result = (const __CFDictionary *)std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v133);
        goto LABEL_139;
      }
LABEL_141:
      abort();
    }
  }
  return result;
}

const __CFArray *TSplicedFont::EvalComponents(atomic_ullong *this, const __CFArray *a2)
{
  double v34 = 0.0;
  double v35 = 0.0;
  double v33 = 0.0;
  unsigned int v32 = 0;
  *(_WORD *)CFIndex v31 = 0;
  BOOL v30 = 0;
  TSplicedFontDict::GetTraitsValuesFromMetrics(this + 75, &v31[1], v31, &v30, &v35, &v34, &v33, &v32);
  if (a2)
  {
    CFIndex v4 = CFArrayGetCount(a2);
    if (v4 >= 1)
    {
      CFIndex v5 = v4;
      CFIndex v6 = 0;
      size_t count = v4 + 1;
      uint64_t v7 = -56;
      do
      {
        int ValueAtIndex = CFArrayGetValueAtIndex(a2, v6);
        uint64_t v9 = *((void *)ValueAtIndex + 5);
        if ((*(_DWORD *)(v9 + 16) & 0x80000000) == 0) {
          TDescriptor::InitBaseFont(*((TDescriptor **)ValueAtIndex + 5), 0, 0.0);
        }
        unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(v9 + 32), memory_order_acquire);
        if (explicit)
        {
          int v11 = (*(uint64_t (**)(unint64_t))(*(void *)explicit + 16))(explicit);
          if (v11 == 1414809156 || v11 == 1413695044)
          {
            CFNumberRef ComponentAttribute = (const __CFNumber *)TComponentFont::GetComponentAttribute((atomic_ullong *)explicit, @"opticalSize");
            if (!ComponentAttribute) {
              return a2;
            }
            uint64_t valuePtr = 0;
            CFNumberGetValue(ComponentAttribute, kCFNumberDoubleType, &valuePtr);
            uint64_t v14 = valuePtr;
            uint64_t v15 = (char *)this[77];
            if (!v15)
            {
              uint64_t v15 = (char *)malloc_type_calloc(count, 0x38uLL, 0x100004021716A34uLL) + 56;
              this[77] = (atomic_ullong)v15;
            }
            *(void *)&v15[v7 + 56] = v14;
            uint64_t v16 = (uint64_t)&v15[v7 + 56];
            *(double *)(v16 + 32) = v35;
            *(double *)(v16 + 40) = v34;
            *(_DWORD *)(v16 + 52) = v32;
            CFNumberRef v17 = (const __CFNumber *)TComponentFont::GetComponentAttribute((atomic_ullong *)explicit, @"leadingOverride");
            if (v17) {
              CFNumberGetValue(v17, kCFNumberDoubleType, &v15[v7 + 64]);
            }
            CFNumberRef v18 = (const __CFNumber *)TComponentFont::GetComponentAttribute((atomic_ullong *)explicit, @"lineSpacingOverrideRatio");
            if (v18) {
              CFNumberGetValue(v18, kCFNumberDoubleType, &v15[v7 + 72]);
            }
            CFNumberRef v19 = (const __CFNumber *)TComponentFont::GetComponentAttribute((atomic_ullong *)explicit, @"capHeight");
            if (v19) {
              CFNumberGetValue(v19, kCFNumberIntType, &v15[v7 + 104]);
            }
            CFNumberRef v20 = (const __CFNumber *)TComponentFont::GetComponentAttribute((atomic_ullong *)explicit, @"trackingAmount");
            int64x2_t v21 = &v15[v7 + 80];
            if (v20) {
              CFNumberGetValue(v20, kCFNumberDoubleType, v21);
            }
            else {
              *(void *)int64x2_t v21 = 0;
            }
            long long v22 = *(_OWORD *)v16;
            long long v23 = *(_OWORD *)&v15[v7 + 72];
            long long v24 = *(_OWORD *)&v15[v7 + 88];
            *(void *)(explicit + 648) = *(void *)&v15[v7 + 104];
            *(_OWORD *)(explicit + 616) = v23;
            *(_OWORD *)(explicit + 632) = v24;
            *(_OWORD *)(explicit + 600) = v22;
            long long v25 = *(_OWORD *)&v15[v7];
            long long v26 = *(_OWORD *)&v15[v7 + 16];
            long long v27 = *(_OWORD *)&v15[v7 + 32];
            *(void *)(explicit + 704) = *(void *)&v15[v7 + 48];
            *(_OWORD *)(explicit + 672) = v26;
            *(_OWORD *)(explicit + 688) = v27;
            *(_OWORD *)(explicit + 656) = v25;
          }
        }
        ++v6;
        v7 += 56;
      }
      while (v5 != v6);
    }
  }
  return a2;
}

const void *TComponentFont::GetComponentAttribute(atomic_ullong *this, const __CFString *a2)
{
  CFDictionaryRef v3 = (const __CFDictionary *)(id)atomic_load_explicit(this + 93, memory_order_acquire);
  CFDictionaryRef v4 = v3;
  if (v3) {
    CFArrayRef Value = CFDictionaryGetValue(v3, a2);
  }
  else {
    CFArrayRef Value = 0;
  }

  return Value;
}

const __CFDictionary *TSplicedFontDict::GetTraitsValuesFromMetrics(atomic_ullong *this, BOOL *a2, BOOL *a3, BOOL *a4, double *a5, double *a6, double *a7, unsigned int *a8)
{
  CFDictionaryRef result = (const __CFDictionary *)atomic_load_explicit(this, memory_order_acquire);
  if (!result) {
    return result;
  }
  CFDictionaryRef result = (const __CFDictionary *)CFDictionaryGetValue(result, @"FontMetrics");
  if (!result) {
    return result;
  }
  CFDictionaryRef v16 = result;
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(result, @"isFixedPitch");
  if (Value && CFStringGetIntValue(Value)) {
    *a8 |= 0x400u;
  }
  if (!*a4)
  {
    CFStringRef v18 = (const __CFString *)CFDictionaryGetValue(v16, @"italicAngle");
    if (v18)
    {
      double v19 = CFStringGetDoubleValue(v18) * 0.00555555556;
      *a8 |= 1u;
    }
    else
    {
      double v19 = 0.0;
    }
    *a7 = v19;
    *a4 = 1;
  }
  if (!*a2)
  {
    CFStringRef v20 = (const __CFString *)CFDictionaryGetValue(v16, @"weightClass");
    if (v20)
    {
      CFStringRef v21 = v20;
      if ((unint64_t)CFStringGetCharacterAtIndex(v20, 1) - 54 <= 0xFFFFFFFFFFFFFFF9) {
        *a8 |= 2u;
      }
      CFIndex Length = CFStringGetLength(v21);
      if (Length >= 2 && (unint64_t v23 = Length, CFStringGetCharacterAtIndex(v21, 0) == 119))
      {
        double v24 = kCTFontDefaultWeights[CFStringGetCharacterAtIndex(v21, 1) - 49];
        if (v23 >= 4) {
          double v24 = v24 + (double)((unint64_t)CFStringGetCharacterAtIndex(v21, 3) - 48) * 0.02;
        }
        *a5 = v24;
        *a2 = 1;
      }
      else
      {
        *a2 = 0;
        *a5 = 2.0;
      }
    }
  }
  if (!*a3)
  {
    CFNumberRef v25 = (const __CFNumber *)CFDictionaryGetValue(v16, @"width");
    if (v25)
    {
      uint64_t valuePtr = -1;
      CFNumberGetValue(v25, kCFNumberDoubleType, &valuePtr);
      double v26 = *(double *)&valuePtr;
      *(void *)a6 = valuePtr;
      IntCFStringRef Value = ClassOfWidth(v26);
    }
    else
    {
      if (*a3) {
        goto LABEL_34;
      }
      CFStringRef v29 = (const __CFString *)CFDictionaryGetValue(v16, @"widthClass");
      if (!v29)
      {
        *a6 = 0.0;
        *a3 = 1;
        goto LABEL_34;
      }
      IntCFStringRef Value = (unsigned __int16)CFStringGetIntValue(v29);
      if (IntValue > 0xA) {
        double v30 = 0.0;
      }
      else {
        double v30 = kWidthScale[IntValue];
      }
      *a6 = v30;
    }
    *a3 = 1;
    if (IntValue < 6)
    {
      if (IntValue == 5) {
        goto LABEL_34;
      }
      unsigned int v28 = *a8 | 0x40;
    }
    else
    {
      unsigned int v28 = *a8 | 0x20;
    }
    *a8 = v28;
  }
LABEL_34:
  CFStringRef v31 = (const __CFString *)CFDictionaryGetValue(v16, @"familyClass");
  if (v31)
  {
    SInt32 v32 = CFStringGetIntValue(v31);
    if (v32 >= 1) {
      *a8 |= v32 >> 8 << 28;
    }
  }
  if (CFDictionaryGetValue(v16, @"shortTrait")) {
    *a8 |= 0x8000u;
  }
  CFDictionaryRef result = (const __CFDictionary *)CFDictionaryGetValue(v16, @"tallTrait");
  if (result) {
    *a8 |= 0x10000u;
  }
  return result;
}

void ConvertToMorxSync(atomic_uint *a1)
{
  if (qword_1EB2CDB20 != -1) {
    dispatch_once_f(&qword_1EB2CDB20, 0, (dispatch_function_t)ConvertToMorxSync(TBaseFont const*)::{lambda(void *)#1}::__invoke);
  }
  if (!_MergedGlobals_160 && (a1[44] & 0x4000000) == 0)
  {
    if ((*(unsigned int (**)(atomic_uint *))(*(void *)a1 + 704))(a1)
      || (*(unsigned int (**)(atomic_uint *, uint64_t))(*(void *)a1 + 472))(a1, 1836020344))
    {
      atomic_fetch_or_explicit(a1 + 44, 0x4000000u, memory_order_relaxed);
    }
    else
    {
      CFDataRef CommonTable = (const __CFData *)TBaseFont::GetCommonTable((TBaseFont *)a1, 0x47535542u, 0);
      if (CommonTable)
      {
        CFDataRef v3 = CommonTable;
        BytePtr = CFDataGetBytePtr(CommonTable);
        CFIndex v5 = CFDataGetBytePtr(v3);
        if (!v5) {
          goto LABEL_19;
        }
        unint64_t v6 = (unint64_t)&v5[CFDataGetLength(v3)];
        if ((unint64_t)(BytePtr + 10) > v6
          || bswap32(*(unsigned __int16 *)BytePtr) >> 16 > 1
          || *((_WORD *)BytePtr + 1) && (unint64_t)(BytePtr + 14) > v6)
        {
          goto LABEL_19;
        }
        LookupListTable = OTL::GCommon::GetLookupListTable((uint64_t)BytePtr, v6);
        if (!LookupListTable || *LookupListTable) {
          goto LABEL_19;
        }
      }
      uint64_t v10 = 0;
      int v11 = &v10;
      uint64_t v12 = 0x2020000000;
      char v13 = -86;
      if (GetMorxConversionQueue(void)::once != -1) {
        dispatch_once(&GetMorxConversionQueue(void)::once, &__block_literal_global_5);
      }
      v9[0] = MEMORY[0x1E4F143A8];
      v9[1] = 3221225472;
      v9[2] = ___Z17ConvertToMorxSyncPK9TBaseFont_block_invoke;
      id v9[3] = &unk_1E5290058;
      void v9[4] = &v10;
      void v9[5] = a1;
      dispatch_sync((dispatch_queue_t)GetMorxConversionQueue(void)::sQueue, v9);
      int v8 = *((unsigned __int8 *)v11 + 24);
      _Block_object_dispose(&v10, 8);
      if (!v8)
      {
LABEL_19:
        atomic_fetch_or_explicit(a1 + 44, 0x6000000u, memory_order_relaxed);
        TBaseFont::SetAttributeInternal<__CFDictionary const*>((atomic_ullong *)a1, (const void *)*MEMORY[0x1E4F1CFC8], @"CTFontMorxConversionResultAttribute");
      }
    }
  }
}

_DWORD *TBaseFont::InitFontMetrics(TBaseFont *this, double a2)
{
  uint64_t v2 = (_DWORD *)((char *)this + 248);
  if (*((_DWORD *)this + 62)) {
    return v2;
  }
  v20[1] = DWORD1(__const__ZL17StrikeMetricsFromPK14CGFontHMetricsj6CGRectd_result);
  memset(v23, 255, 40);
  *(_OWORD *)&v23[40] = unk_184BA8B38;
  v20[0] = 0;
  long long v22 = 0u;
  long long v21 = 0u;
  *(_OWORD *)unint64_t v23 = *MEMORY[0x1E4F1DAD8];
  long long v5 = *MEMORY[0x1E4F1DB28];
  *(_OWORD *)&v23[32] = *(_OWORD *)(MEMORY[0x1E4F1DB28] + 16);
  *(_OWORD *)&v23[16] = v5;
  v23[48] = 0;
  if (!(*(unsigned int (**)(void))(*(void *)this + 704))()
    || ((*(uint64_t (**)(TBaseFont *, void, _DWORD *, double))(*(void *)this + 792))(this, 0, v20, a2) & 1) == 0)
  {
    (*(void (**)(unsigned char *__return_ptr, TBaseFont *, void, double))(*(void *)this + 632))(bboxes, this, 0, a2);
    v20[0] = *(_DWORD *)bboxes;
    long long v21 = *(_OWORD *)&bboxes[8];
    long long v22 = *(_OWORD *)&bboxes[24];
    *(_OWORD *)unint64_t v23 = v17;
    *(CGRect *)&v23[16] = v18;
    v23[48] = v19;
    if (CGRectGetMaxY(v18) > *(double *)&v21)
    {
      double v6 = *(double *)&v22;
      goto LABEL_7;
    }
    CGFloat MinY = CGRectGetMinY(*(CGRect *)&v23[16]);
    double v6 = *(double *)&v22;
    if (MinY < -(*((double *)&v21 + 1) + *(double *)&v22))
    {
LABEL_7:
      if (v6 == 0.0
        && ((*(uint64_t (**)(TBaseFont *, uint64_t))(*(void *)this + 472))(this, 1398030676) & 1) == 0)
      {
        uint64_t InitializedGraphicsFont = (CGFont *)TBaseFont::GetInitializedGraphicsFont(this);
        __int16 v15 = 192;
        CGGlyph glyphs = -21846;
        if ((*(unsigned int (**)(TBaseFont *))(*(void *)this + 24))(this)) {
          (*(void (**)(TBaseFont *, __int16 *, CGGlyph *, uint64_t))(*(void *)this + 664))(this, &v15, &glyphs, 1);
        }
        else {
          CGFontGetGlyphsForUnichars();
        }
        if (glyphs)
        {
          *(void *)&long long v9 = -1;
          *((void *)&v9 + 1) = -1;
          *(_OWORD *)bboxes = v9;
          *(_OWORD *)&bboxes[16] = v9;
          if (CGFontGetGlyphBBoxes(InitializedGraphicsFont, &glyphs, 1uLL, (CGRect *)bboxes)
            && (CGRectGetMaxY(*(CGRect *)bboxes) > *(double *)&v21
             || CGRectGetMinY(*(CGRect *)bboxes) < -*((double *)&v21 + 1)))
          {
            v23[48] = 1;
          }
        }
      }
    }
  }
  if (!*v2 && v2 != v20)
  {
    long long v10 = v22;
    *((_OWORD *)this + 16) = v21;
    *((_OWORD *)this + 17) = v10;
    long long v11 = *(_OWORD *)&v23[16];
    long long v12 = *(_OWORD *)&v23[32];
    *((_OWORD *)this + 18) = *(_OWORD *)v23;
    *((_OWORD *)this + 19) = v11;
    *((_OWORD *)this + 20) = v12;
    *((unsigned char *)this + 336) = v23[48];
    __dmb(0xBu);
    *((_DWORD *)this + 62) = v20[0];
  }
  return v2;
}

uint64_t TTenuousComponentFont::IsAppleFont(TTenuousComponentFont *this)
{
  return 1;
}

BOOL TComponentFont::GetStrikeMetricsForSystemFont(atomic_ullong *this, int a2, StrikeMetrics *a3, double a4)
{
  BOOL StrikeMetricsForSystemFont = TBaseFont::GetStrikeMetricsForSystemFont(this, a2, a3, 0.0);
  if (StrikeMetricsForSystemFont)
  {
    v9.n128_f64[0] = a4;
    TComponentFont::AdjustLineMetrics(this, a2, a3, v9);
  }
  return StrikeMetricsForSystemFont;
}

void TComponentFont::AdjustLineMetrics(atomic_ullong *this, int a2, StrikeMetrics *a3, __n128 a4)
{
  if (!a2)
  {
    CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit(this + 90, memory_order_acquire);
    if (explicit)
    {
      double v8 = a4.n128_f64[0];
      CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(explicit, @"lineSpacingOverride");
      if (v8 != 0.0)
      {
        if (Value)
        {
          double valuePtr = NAN;
          CFNumberGetValue(Value, kCFNumberDoubleType, &valuePtr);
          double v10 = valuePtr;
          if (valuePtr > 0.0)
          {
            double v67 = NAN;
            double valuePtr = NAN;
            double v65 = NAN;
            double v66 = NAN;
            CFDictionaryRef v11 = (const __CFDictionary *)atomic_load_explicit(this + 90, memory_order_acquire);
            long long v12 = v11 ? (__CFString *)CFDictionaryGetValue(v11, @"language") : 0;
            if (TBaseFont::GetLanguageAwareOutsets(this, 0.0, &valuePtr, &v67, &v66, &v65, v12))
            {
              double v35 = *((double *)this + 76);
              if (v35 != 0.0 && *((double *)this + 75) != 0.0)
              {
                *(float64x2_t *)((char *)a3 + 8) = vmulq_n_f64(vdivq_f64(*(float64x2_t *)((char *)a3 + 8), (float64x2_t)vdupq_lane_s64(*(_OWORD *)&vaddq_f64(*(float64x2_t *)((char *)a3 + 8), (float64x2_t)vdupq_laneq_s64(*(int64x2_t *)((char *)a3 + 8), 1)), 0)), vaddvq_f64(*(float64x2_t *)((char *)a3 + 8))+ *((double *)a3 + 3)- v35);
                *((double *)a3 + 3) = v35;
              }
              double v36 = (double)*(unsigned int *)a3;
              double LanguageAwareAdjustRatio = GetLanguageAwareAdjustRatio();
              double v38 = *((double *)a3 + 1);
              double v39 = *((double *)a3 + 2);
              double v40 = v38 + LanguageAwareAdjustRatio * v67 * v36;
              double v41 = v39 + LanguageAwareAdjustRatio * v65 * v36;
              double v42 = *((double *)a3 + 3);
              double v43 = (v38 + v39 + v42) * v8 / v36;
              double v44 = v10 / v43;
              double v45 = (v10 - v42 * v8 / v36 * (v10 / v43)) / (v43 - v42 * v8 / v36);
              double v46 = v39 * v45 + v38 * v45;
              *((double *)a3 + 1) = v40 / (v40 + v41) * v46;
              *((double *)a3 + 2) = v41 / (v40 + v41) * v46;
              *((double *)a3 + 3) = v42 * v44;
            }
          }
          return;
        }
      }
    }
    if ((*(unsigned int (**)(atomic_ullong *, __n128))(*this + 784))(this, a4))
    {
      double v13 = *((double *)this + 77);
      CFDictionaryRef v14 = (const __CFDictionary *)atomic_load_explicit(this + 90, memory_order_acquire);
      if (v14)
      {
        CFNumberRef v15 = (const __CFNumber *)CFDictionaryGetValue(v14, @"languageAwareLineHeightRatio");
        if (v15)
        {
          double valuePtr = NAN;
          CFNumberGetValue(v15, kCFNumberDoubleType, &valuePtr);
          double v13 = valuePtr;
        }
      }
      if (v13 > 0.0)
      {
        double v67 = NAN;
        double valuePtr = NAN;
        double v65 = NAN;
        double v66 = NAN;
        CFDictionaryRef v16 = (const __CFDictionary *)atomic_load_explicit(this + 90, memory_order_acquire);
        long long v17 = v16 ? (__CFString *)CFDictionaryGetValue(v16, @"language") : 0;
        if (TBaseFont::GetLanguageAwareOutsets(this, 0.0, &valuePtr, &v67, &v66, &v65, v17))
        {
          double v26 = (double)*(unsigned int *)a3;
          double v27 = v13;
          if (v13 > 1.0) {
            double v27 = GetLanguageAwareAdjustRatio();
          }
          double v28 = *((double *)a3 + 1);
          double v29 = *((double *)a3 + 2);
          double v30 = v28 + v27 * v67 * v26;
          double v31 = v29 + v27 * v65 * v26;
          if (v13 > 1.0)
          {
            double v32 = (v13 * ((v28 + v29 + *((double *)this + 76)) * *((double *)this + 75) / v26)
                 - *((double *)this + 76) * *((double *)this + 75) / v26)
                / ((v28 + v29 + *((double *)this + 76)) * *((double *)this + 75) / v26
                 - *((double *)this + 76) * *((double *)this + 75) / v26);
            double v33 = v29 * v32 + v28 * v32;
            double v34 = v30 + v31;
            double v30 = v30 / (v30 + v31) * v33;
            double v31 = v31 / v34 * v33;
          }
          *((double *)a3 + 1) = v30;
          *((double *)a3 + 2) = v31;
        }
      }
      return;
    }
  }
  if ((*(uint64_t (**)(atomic_ullong *, __n128))(*this + 840))(this, a4)) {
    return;
  }
  CFDictionaryRef v18 = (const __CFDictionary *)atomic_load_explicit(this + 90, memory_order_acquire);
  if (!v18) {
    return;
  }
  CFDictionaryRef v19 = (const __CFDictionary *)CFDictionaryGetValue(v18, @"FontMetrics");
  if (!v19) {
    return;
  }
  CFDictionaryRef v20 = v19;
  if (CFDictionaryGetCount(v19) < 1) {
    return;
  }
  LODWORD(valuePtr) = -1431655766;
  LODWORD(valuePtr) = *(_DWORD *)a3;
  CFNumberRef v21 = (const __CFNumber *)CFDictionaryGetValue(v20, @"unitsPerEm");
  double v22 = 1.0;
  if (v21)
  {
    CFNumberRef v23 = v21;
    CFTypeID v24 = CFGetTypeID(v21);
    if (v24 == CFNumberGetTypeID() || v24 == CFBooleanGetTypeID())
    {
      CFNumberGetValue(v23, kCFNumberIntType, &valuePtr);
      IntCFNumberRef Value = LODWORD(valuePtr);
    }
    else
    {
      if (v24 != CFStringGetTypeID()) {
        goto LABEL_40;
      }
      IntCFNumberRef Value = CFStringGetIntValue((CFStringRef)v23);
      LODWORD(valuePtr) = IntValue;
    }
    if (IntValue != *(_DWORD *)a3) {
      double v22 = (double)*(unsigned int *)a3 / (double)IntValue;
    }
  }
LABEL_40:
  if (a2) {
    uint64_t v47 = @"vertTypoAscender";
  }
  else {
    uint64_t v47 = @"ascender";
  }
  CFNumberRef v48 = (const __CFNumber *)CFDictionaryGetValue(v20, v47);
  if (v48)
  {
    CFNumberRef v49 = v48;
    unint64_t v50 = (double *)((char *)a3 + 8);
    CFTypeID v51 = CFGetTypeID(v48);
    if (v51 == CFNumberGetTypeID() || v51 == CFBooleanGetTypeID())
    {
      CFNumberGetValue(v49, kCFNumberDoubleType, (char *)a3 + 8);
      DoubleCFNumberRef Value = *v50;
LABEL_47:
      double *v50 = v22 * DoubleValue;
      goto LABEL_48;
    }
    if (v51 == CFStringGetTypeID())
    {
      DoubleCFNumberRef Value = CFStringGetDoubleValue((CFStringRef)v49);
      goto LABEL_47;
    }
  }
LABEL_48:
  if (a2) {
    int64x2_t v53 = @"vertTypoDescender";
  }
  else {
    int64x2_t v53 = @"descender";
  }
  CFNumberRef v54 = (const __CFNumber *)CFDictionaryGetValue(v20, v53);
  if (v54)
  {
    CFNumberRef v55 = v54;
    unint64_t v56 = (double *)((char *)a3 + 16);
    CFTypeID v57 = CFGetTypeID(v54);
    if (v57 == CFNumberGetTypeID() || v57 == CFBooleanGetTypeID())
    {
      CFNumberGetValue(v55, kCFNumberDoubleType, (char *)a3 + 16);
      double v58 = *v56;
LABEL_55:
      *unint64_t v56 = v22 * v58;
      goto LABEL_56;
    }
    if (v57 == CFStringGetTypeID())
    {
      double v58 = CFStringGetDoubleValue((CFStringRef)v55);
      goto LABEL_55;
    }
  }
LABEL_56:
  if (a2) {
    uint64_t v59 = @"vertTypoLineGap";
  }
  else {
    uint64_t v59 = @"lineGap";
  }
  CFNumberRef v60 = (const __CFNumber *)CFDictionaryGetValue(v20, v59);
  if (v60)
  {
    CFNumberRef v61 = v60;
    char v62 = (double *)((char *)a3 + 24);
    CFTypeID v63 = CFGetTypeID(v60);
    if (v63 == CFNumberGetTypeID() || v63 == CFBooleanGetTypeID())
    {
      CFNumberGetValue(v61, kCFNumberDoubleType, v62);
      double v64 = *v62;
    }
    else
    {
      if (v63 != CFStringGetTypeID()) {
        return;
      }
      double v64 = CFStringGetDoubleValue((CFStringRef)v61);
    }
    double *v62 = v22 * v64;
  }
}

BOOL TTenuousComponentFont::HasExuberatedLineHeight(TTenuousComponentFont *this)
{
  if ((*((_DWORD *)this + 178) & 0x80008) == 8 && CurrentLocaleIsExuberated()) {
    return 1;
  }

  return TComponentFont::HasExuberatedLineHeight(this);
}

BOOL TComponentFont::HasExuberatedLineHeight(TComponentFont *this)
{
  if ((*(unsigned int (**)(TComponentFont *))(*(void *)this + 856))(this))
  {
    int v2 = *((_DWORD *)this + 178);
    if ((v2 & 0x80000) == 0)
    {
      if ((v2 & 0x40000) != 0)
      {
        CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)this + 90, memory_order_acquire);
        if (explicit)
        {
          CFStringRef Value = (const __CFString *)CFDictionaryGetValue(explicit, @"language");
          if (Value) {
            return GetExuberatedGroupForLanguage(Value, 0) != 0;
          }
        }
      }
      else if (CurrentLocaleIsExuberated())
      {
        return 1;
      }
    }
  }
  return 0;
}

uint64_t TBaseFont::IsAppleFont(TBaseFont *this)
{
  if ((*((_DWORD *)this + 46) & 0x10) == 0) {
    TBaseFont::DetermineFontFlags(this, 0x10u);
  }
  return (*((_DWORD *)this + 45) >> 4) & 1;
}

uint64_t TFontFeatureSettingList::ContainsAATSetting(atomic_ullong *this, const __CFNumber *a2, const __CFNumber *a3, char a4)
{
  uint64_t result = 0;
  if (a2)
  {
    if (a3)
    {
      unsigned __int16 v17 = -21846;
      unsigned __int16 v16 = -21846;
      uint64_t result = GetSettingValue<__CFNumber const*,unsigned short>((uint64_t)a2, &v17);
      if (result)
      {
        uint64_t result = GetSettingValue<__CFNumber const*,unsigned short>((uint64_t)a3, &v16);
        if (result)
        {
          double v8 = std::__tree<std::__value_type<unsigned short,AATFeaturePair>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,AATFeaturePair>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,AATFeaturePair>>>::__equal_range_multi<unsigned short>((uint64_t)(this + 1), &v17);
          if (v8 == v9) {
            return 0;
          }
          double v10 = v8;
          CFDictionaryRef v11 = v9;
          while (1)
          {
            if (a4)
            {
              int ValueAtIndex = (id *)CFArrayGetValueAtIndex((CFArrayRef)atomic_load_explicit(this, memory_order_acquire), v10[6]);
              if (!ValueAtIndex || ![ValueAtIndex[1] objectForKey:@"CTFeatureOpenTypeTag"]) {
                return 1;
              }
            }
            else if ((*((unsigned __int16 *)v10 + 20) ^ v16) < 2)
            {
              return 1;
            }
            double v13 = (uint64_t *)v10[1];
            if (v13)
            {
              do
              {
                CFDictionaryRef v14 = v13;
                double v13 = (uint64_t *)*v13;
              }
              while (v13);
            }
            else
            {
              do
              {
                CFDictionaryRef v14 = (uint64_t *)v10[2];
                BOOL v15 = *v14 == (void)v10;
                double v10 = v14;
              }
              while (!v15);
            }
            double v10 = v14;
            if (v14 == v11) {
              return 0;
            }
          }
        }
      }
    }
  }
  return result;
}

const __CFDictionary *anonymous namespace'::TFeatureSelector::IsDefault(atomic_ullong *this)
{
  CFDictionaryRef result = (const __CFDictionary *)atomic_load_explicit(this, memory_order_acquire);
  if (result)
  {
    CFDictionaryRef result = (const __CFDictionary *)CFDictionaryGetValue(result, @"CTFeatureSelectorDefault");
    if (result) {
      return (const __CFDictionary *)(CFBooleanGetValue(result) != 0);
    }
  }
  return result;
}

uint64_t TBaseFont::CalculateFontMetrics@<X0>(TBaseFont *this@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t InitializedGraphicsFont = (CGFont *)TBaseFont::GetInitializedGraphicsFont(this);
  FontBBoCGFloat x = CGFontGetFontBBox(InitializedGraphicsFont);
  double v8 = (*(double (**)(TBaseFont *, CGPoint, __n128, CGSize, __n128))(*(void *)this + 544))(this, FontBBox.origin, *(__n128 *)&FontBBox.origin.y, FontBBox.size, *(__n128 *)&FontBBox.size.height);
  uint64_t v10 = v9;
  uint64_t v12 = v11;
  uint64_t v14 = v13;
  int CapHeight = CGFontGetCapHeight(InitializedGraphicsFont);
  if (a2) {
    uint64_t VMetrics = CGFontGetVMetrics();
  }
  else {
    uint64_t VMetrics = CGFontGetHMetrics();
  }
  unsigned __int16 v17 = (int *)VMetrics;
  uint64_t result = CGFontGetUnitsPerEm(InitializedGraphicsFont);
  *(_OWORD *)a3 = __const__ZL17StrikeMetricsFromPK14CGFontHMetricsj6CGRectd_result;
  *(_OWORD *)(a3 + 16) = unk_184BA8AF8;
  *(_OWORD *)(a3 + 32) = xmmword_184BA8B08;
  *(_OWORD *)(a3 + 48) = unk_184BA8B18;
  *(_OWORD *)(a3 + 64) = xmmword_184BA8B28;
  *(_OWORD *)(a3 + 80) = unk_184BA8B38;
  *(_DWORD *)a3 = result;
  *(_OWORD *)(a3 + 24) = 0u;
  *(_OWORD *)(a3 + 8) = 0u;
  *(_OWORD *)(a3 + 40) = *MEMORY[0x1E4F1DAD8];
  *(unsigned char *)(a3 + 88) = 0;
  *(double *)(a3 + 56) = v8;
  *(void *)(a3 + 64) = v10;
  *(void *)(a3 + 72) = v12;
  *(void *)(a3 + 80) = v14;
  if (v17)
  {
    int v19 = v17[1];
    if (v19 >= 0) {
      int v20 = v17[1];
    }
    else {
      int v20 = -v19;
    }
    *(double *)(a3 + 8) = (double)*v17;
    *(double *)(a3 + 16) = (double)v20;
    *(double *)(a3 + 24) = (double)v17[2];
    *(double *)(a3 + 32) = (double)CapHeight;
  }
  return result;
}

uint64_t TSplicedFont::IsAppleFont(TSplicedFont *this)
{
  return *((unsigned __int8 *)this + 632);
}

double TSplicedFontDict::ModifyRawBoundingBox(atomic_ullong *this, CGRect a2)
{
  double x = a2.origin.x;
  CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit(this, memory_order_acquire);
  if (explicit)
  {
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(explicit, @"FontMetrics");
    if (Value)
    {
      CFDictionaryRef v5 = Value;
      if (CFDictionaryGetCount(Value) >= 1)
      {
        CFStringRef v6 = (const __CFString *)CFDictionaryGetValue(v5, @"xMin");
        if (v6)
        {
          DoubleCFDictionaryRef Value = CFStringGetDoubleValue(v6);
          CFStringRef v8 = (const __CFString *)CFDictionaryGetValue(v5, @"yMin");
          if (v8)
          {
            CFStringGetDoubleValue(v8);
            CFStringRef v9 = (const __CFString *)CFDictionaryGetValue(v5, @"xMax");
            if (v9)
            {
              CFStringGetDoubleValue(v9);
              CFStringRef v10 = (const __CFString *)CFDictionaryGetValue(v5, @"yMax");
              if (v10)
              {
                CFStringGetDoubleValue(v10);
                return DoubleValue;
              }
            }
          }
        }
      }
    }
  }
  return x;
}

double TSplicedFont::ModifyRawBoundingBox(atomic_ullong *this, CGRect a2)
{
  return TSplicedFontDict::ModifyRawBoundingBox(this + 75, a2);
}

void TSplicedFont::CalculateFontMetrics(TSplicedFont *this@<X0>, double a2@<D0>, int a3@<W1>, uint64_t a4@<X8>)
{
  *(_OWORD *)a4 = xmmword_184BA8B70;
  *(_OWORD *)(a4 + 16) = unk_184BA8B80;
  *(_OWORD *)(a4 + 32) = xmmword_184BA8B90;
  *(_OWORD *)(a4 + 48) = unk_184BA8BA0;
  *(_OWORD *)(a4 + 64) = xmmword_184BA8BB0;
  *(_OWORD *)(a4 + 80) = unk_184BA8BC0;
  *(_DWORD *)a4 = 0;
  *(_OWORD *)(a4 + 24) = 0u;
  *(_OWORD *)(a4 + 8) = 0u;
  CFStringRef v8 = (long long *)MEMORY[0x1E4F1DB28];
  *(_OWORD *)(a4 + 40) = *MEMORY[0x1E4F1DAD8];
  long long v9 = *v8;
  *(_OWORD *)(a4 + 72) = v8[1];
  *(_OWORD *)(a4 + 56) = v9;
  *(unsigned char *)(a4 + 88) = 0;
  if (!TBaseFont::GetStrikeMetricsForSystemFont((atomic_ullong *)this, a3, (StrikeMetrics *)a4, a2))
  {
    TBaseFont::CalculateFontMetrics(this, a3, (uint64_t)&v16);
    *(_DWORD *)a4 = v16;
    *(_OWORD *)(a4 + 8) = v17;
    *(_OWORD *)(a4 + 24) = v18;
    *(_OWORD *)(a4 + 40) = v19;
    long long v10 = v21;
    *(_OWORD *)(a4 + 56) = v20;
    *(_OWORD *)(a4 + 72) = v10;
    *(unsigned char *)(a4 + 88) = v22;
  }
  uint64_t v11 = *(void *)(*((void *)this + 76) + 40);
  if ((*(_DWORD *)(v11 + 16) & 0x80000000) == 0) {
    TDescriptor::InitBaseFont((TDescriptor *)v11, 0, 0.0);
  }
  CFDictionaryRef explicit = (atomic_ullong *)atomic_load_explicit((atomic_ullong *volatile)(v11 + 32), memory_order_acquire);
  if (explicit)
  {
    int v13 = (*(uint64_t (**)(atomic_ullong *))(*explicit + 16))(explicit);
    if (v13 == 1414809156 || v13 == 1413695044)
    {
      v14.n128_f64[0] = a2;
      TComponentFont::AdjustLineMetrics(explicit, a3, (StrikeMetrics *)a4, v14);
    }
  }
}

void TInstanceFont::AddDescriptorAttributes(atomic_ullong *a1, int64x2_t *a2, unint64_t **a3)
{
  if (((*(uint64_t (**)(atomic_ullong *))(*a1 + 456))(a1) & 1) == 0)
  {
    CFDictionaryRef v6 = (const __CFDictionary *)(id)atomic_load_explicit(a1 + 75, memory_order_acquire);
    if (v6)
    {
      CFDictionaryRef v7 = v6;
      CFIndex Count = CFDictionaryGetCount(v6);

      if (!Count) {
        return;
      }
      long long v10 = (void *)a2->i64[1];
      unint64_t v9 = a2[1].u64[0];
      if ((unint64_t)v10 >= v9)
      {
        uint64_t v12 = ((uint64_t)v10 - a2->i64[0]) >> 3;
        if ((unint64_t)(v12 + 1) >> 61) {
          goto LABEL_41;
        }
        uint64_t v13 = v9 - a2->i64[0];
        uint64_t v14 = v13 >> 2;
        if (v13 >> 2 <= (unint64_t)(v12 + 1)) {
          uint64_t v14 = v12 + 1;
        }
        if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v15 = v14;
        }
        double v43 = &a2[1].i64[1];
        if (v15) {
          int v16 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&a2[1].i64[1], v15);
        }
        else {
          int v16 = 0;
        }
        long long v17 = &v16[8 * v12];
        long long v18 = &v16[8 * v15];
        double v42 = v18;
        *(void *)long long v17 = @"NSCTFontVariationAttribute";
        uint64_t v11 = v17 + 8;
        v41.i64[1] = (uint64_t)(v17 + 8);
        uint64_t v20 = a2->i64[0];
        unint64_t v19 = a2->u64[1];
        if (v19 == a2->i64[0])
        {
          int64x2_t v22 = vdupq_n_s64(v19);
        }
        else
        {
          do
          {
            uint64_t v21 = *(void *)(v19 - 8);
            v19 -= 8;
            *((void *)v17 - 1) = v21;
            v17 -= 8;
          }
          while (v19 != v20);
          int64x2_t v22 = *a2;
          uint64_t v11 = (void *)v41.i64[1];
          long long v18 = v42;
        }
        a2->i64[0] = (uint64_t)v17;
        a2->i64[1] = (uint64_t)v11;
        int64x2_t v41 = v22;
        CFNumberRef v23 = (char *)a2[1].i64[0];
        a2[1].i64[0] = (uint64_t)v18;
        double v42 = v23;
        uint64_t v40 = v22.i64[0];
        std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v40);
      }
      else
      {
        void *v10 = @"NSCTFontVariationAttribute";
        uint64_t v11 = v10 + 1;
      }
      a2->i64[1] = (uint64_t)v11;
      unint64_t explicit = atomic_load_explicit(a1 + 75, memory_order_acquire);
      double v26 = a3[1];
      unint64_t v25 = (unint64_t)a3[2];
      if ((unint64_t)v26 < v25)
      {
        *double v26 = explicit;
        double v27 = v26 + 1;
LABEL_39:
        a3[1] = v27;
        return;
      }
      uint64_t v28 = v26 - *a3;
      if (!((unint64_t)(v28 + 1) >> 61))
      {
        uint64_t v29 = v25 - (void)*a3;
        uint64_t v30 = v29 >> 2;
        if (v29 >> 2 <= (unint64_t)(v28 + 1)) {
          uint64_t v30 = v28 + 1;
        }
        if ((unint64_t)v29 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v31 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v31 = v30;
        }
        double v43 = (uint64_t *)(a3 + 3);
        if (v31) {
          double v32 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)(a3 + 3), v31);
        }
        else {
          double v32 = 0;
        }
        double v33 = (unint64_t *)&v32[8 * v28];
        double v34 = &v32[8 * v31];
        double v42 = v34;
        *double v33 = explicit;
        double v27 = v33 + 1;
        v41.i64[1] = (uint64_t)(v33 + 1);
        double v36 = *a3;
        unint64_t v35 = (unint64_t)a3[1];
        if ((unint64_t *)v35 == *a3)
        {
          int64x2_t v38 = vdupq_n_s64(v35);
        }
        else
        {
          do
          {
            unint64_t v37 = *(void *)(v35 - 8);
            v35 -= 8;
            *--double v33 = v37;
          }
          while ((unint64_t *)v35 != v36);
          int64x2_t v38 = *(int64x2_t *)a3;
          double v27 = (unint64_t *)v41.i64[1];
          double v34 = v42;
        }
        *a3 = v33;
        a3[1] = v27;
        int64x2_t v41 = v38;
        double v39 = a3[2];
        a3[2] = (unint64_t *)v34;
        double v42 = (char *)v39;
        uint64_t v40 = v38.i64[0];
        std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v40);
        goto LABEL_39;
      }
LABEL_41:
      abort();
    }
  }
}

unsigned __int16 *OTL::GCommon::GetLookupListTable(uint64_t a1, unint64_t a2)
{
  if (!*(_WORD *)(a1 + 8)) {
    return 0;
  }
  int v2 = (unsigned __int16 *)(a1 + __rev16(*(unsigned __int16 *)(a1 + 8)));
  CFDataRef v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) > a2) {
    return 0;
  }
  uint64_t v5 = bswap32(*v2) >> 16;
  unint64_t v6 = (unint64_t)&v3[v5];
  if ((unint64_t)(v2 + 2) <= a2) {
    unint64_t v7 = (a2 - (unint64_t)v3) >> 1;
  }
  else {
    unint64_t v7 = 0;
  }
  if (v6 >= (unint64_t)v3 && v6 <= a2 || v7 == v5) {
    return v2;
  }
  else {
    return 0;
  }
}

CFIndex TFontFeatureSettingList::IndexOfOpenTypeSetting(atomic_ullong *this, const __CFString *a2)
{
  CFArrayRef v4 = (const __CFArray *)(id)atomic_load_explicit(this, memory_order_acquire);
  if (!v4)
  {

    return -1;
  }
  CFArrayRef v5 = v4;
  CFIndex Count = CFArrayGetCount(v4);

  if (Count < 1) {
    return -1;
  }
  CFIndex v7 = 0;
  while (1)
  {
    CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)atomic_load_explicit(this, memory_order_acquire), v7);
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, @"CTFeatureOpenTypeTag");
    if (Value == a2 || a2 && Value && CFEqual(Value, a2)) {
      break;
    }
    if (Count == ++v7) {
      return -1;
    }
  }
  return v7;
}

atomic_ullong *TRun::CopyPositions(atomic_ullong *this, CFRange a2, CGPoint *__dst)
{
  CFIndex length = a2.length;
  CFIndex location = a2.location;
  unint64_t explicit = atomic_load_explicit(this + 35, memory_order_acquire);
  if (explicit)
  {
LABEL_5:
    if (length)
    {
      return (atomic_ullong *)memmove(__dst, (const void *)(explicit + 16 * location), 16 * length);
    }
  }
  else
  {
    CFIndex v7 = this;
    while (1)
    {
      this = (atomic_ullong *)v7[34];
      if (!this) {
        break;
      }
      this = (atomic_ullong *)TLine::CachePositions((uint64_t)this);
      unint64_t explicit = atomic_load_explicit(v7 + 35, memory_order_acquire);
      if (explicit) {
        goto LABEL_5;
      }
    }
  }
  return this;
}

uint64_t TLine::GetNonDeletedGlyphCount(TLine *this)
{
  uint64_t v1 = *((void *)this + 18);
  if (v1 && (*((_WORD *)this + 77) & 8) != 0)
  {
    int v2 = (uint64_t *)*((void *)this + 2);
    CFDataRef v3 = (uint64_t *)*((void *)this + 3);
    if (v2 == v3)
    {
      return 0;
    }
    else
    {
      uint64_t v1 = 0;
      do
      {
        uint64_t v4 = *v2++;
        v1 += TRun::GetNonDeletedGlyphCount(*(TRun **)(v4 + 40));
      }
      while (v2 != v3);
    }
  }
  return v1;
}

uint64_t EnsureGSFontInitialized(void)::$_0::__invoke()
{
  return MEMORY[0x1F4119E48]();
}

void CTFontGetUnsummedAdvancesForGlyphsAndStyle(uint64_t a1, int a2, unsigned int a3, uint64_t a4, double *a5, uint64_t a6)
{
  if (a1 && a4 && a5 && a6 >= 1) {
    TFont::GetUnsummedAdvancesForGlyphs(*(void *)(a1 + 40), a4, a5, 2, a6, a2, a3 | 0x100000000);
  }
}

BOOL IsInMemoryFontURL(const __CFURL *a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  *(void *)&long long v1 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v1 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v7[11] = v1;
  v7[10] = v1;
  v7[9] = v1;
  v7[8] = v1;
  v7[7] = v1;
  v7[6] = v1;
  void v7[4] = v1;
  void v7[5] = v1;
  void v7[2] = v1;
  void v7[3] = v1;
  v7[0] = v1;
  v7[1] = v1;
  memset(v6, 0, sizeof(v6));
  CFStringRef v8 = v7;
  CFIndex BytesForComponent = GetBytesForComponent(a1, v6);
  BOOL v3 = BytesForComponent != -1 && strncmp((const char *)&v6[0][BytesForComponent], "iNmEmOrYcGfOnT_", 0xFuLL) == 0;
  CFArrayRef v5 = v6;
  std::vector<std::pair<OTL::LookupSubtable const*,OTL::Coverage>,TInlineBufferAllocator<std::pair<OTL::LookupSubtable const*,OTL::Coverage>,4ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v5);
  return v3;
}

CFIndex GetBytesForComponent(const __CFURL *a1, UInt8 **a2)
{
  CFIndex v4 = CFURLGetBytes(a1, 0, 0);
  if (v4 == -1) {
    return -1;
  }
  CFIndex v5 = v4;
  if (v4 > 383) {
    return -1;
  }
  unint64_t v6 = v4 + 1;
  CFIndex v7 = *a2;
  unint64_t v8 = a2[1] - *a2;
  if (v8 <= v4)
  {
    std::vector<unsigned char,TInlineBufferAllocator<unsigned char,192ul>>::__append(a2, v6 - v8);
    CFIndex v7 = *a2;
  }
  else if (v6 < v8)
  {
    a2[1] = &v7[v6];
  }
  (*a2)[CFURLGetBytes(a1, v7, v5)] = 0;

  return CFURLGetByteRangeForComponent(a1, kCFURLComponentNetLocation, 0).location;
}

void std::vector<unsigned char,TInlineBufferAllocator<unsigned char,192ul>>::__append(void *a1, size_t a2)
{
  unint64_t v6 = a1 + 1;
  CFIndex v4 = (char *)a1[1];
  uint64_t v5 = v6[1];
  if (v5 - (uint64_t)v4 >= a2)
  {
    if (a2)
    {
      uint64_t v12 = &v4[a2];
      bzero(v4, a2);
      CFIndex v4 = v12;
    }
    a1[1] = v4;
  }
  else
  {
    CFIndex v7 = &v4[-*a1];
    unint64_t v8 = (unint64_t)&v7[a2];
    if ((uint64_t)&v7[a2] < 0) {
      abort();
    }
    unint64_t v9 = v5 - *a1;
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v10 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v10 = v8;
    }
    if (v10)
    {
      uint64_t v11 = (void *)a1[27];
      if ((char *)v11 + v10 <= (char *)(a1 + 27)) {
        a1[27] = (char *)v11 + v10;
      }
      else {
        uint64_t v11 = operator new(v10);
      }
    }
    else
    {
      uint64_t v11 = 0;
    }
    uint64_t v13 = &v7[(void)v11];
    uint64_t v14 = (char *)v11 + v10;
    unint64_t v15 = &v13[a2];
    bzero(v13, a2);
    long long v17 = (char *)*a1;
    int v16 = (char *)a1[1];
    if (v16 != (char *)*a1)
    {
      do
      {
        char v18 = *--v16;
        *--uint64_t v13 = v18;
      }
      while (v16 != v17);
      int v16 = (char *)*a1;
    }
    *a1 = v13;
    a1[1] = v15;
    uint64_t v19 = a1[2];
    a1[2] = v14;
    if (v16)
    {
      uint64_t v20 = (char *)(a1 + 27);
      if (a1 + 3 <= (void *)v16 && v20 > v16)
      {
        if (v19 == *(void *)v20) {
          *(void *)uint64_t v20 = v16;
        }
      }
      else
      {
        operator delete(v16);
      }
    }
  }
}

void TGlyphEncoder::CreateSpecialRun(atomic_ullong *a1, uint64_t a2, uint64_t a3, __int16 a4)
{
  uint64_t v15 = a3;
  *a1 = 0;
  if ((a4 & 0x40) != 0)
  {
    uint64_t v6 = TCFBase<TRun>::Allocate();
    if (!v6) {
      goto LABEL_15;
    }
    CFIndex v7 = (void *)v6;
    uint64_t v8 = v6 + 72;
    void v7[2] = 0;
    void v7[3] = 0;
    void v7[4] = 0;
    void v7[5] = v8;
    v7[6] = v8;
    v7[7] = CTDelegateRun::CloneEntire;
    v7[8] = CTDelegateRun::CloneRange;
    TDelegateRun::TDelegateRun(v8, a3);
LABEL_14:
    id v16 = v7;
    id v14 = (id)atomic_exchange((atomic_ullong *volatile)&v16, 0);

LABEL_16:
    id v13 = v14;
    goto LABEL_17;
  }
  if ((a4 & 4) != 0)
  {
    uint64_t v9 = TCFBase<TRun>::Allocate();
    if (!v9) {
      goto LABEL_15;
    }
    CFIndex v7 = (void *)v9;
    uint64_t v10 = v9 + 72;
    void v7[2] = 0;
    void v7[3] = 0;
    void v7[4] = 0;
    void v7[5] = v10;
    v7[6] = v10;
    v7[7] = CTEmojiImageRun::CloneEntire;
    v7[8] = CTEmojiImageRun::CloneRange;
    TEmojiImageRun::TEmojiImageRun(v10, a3);
    goto LABEL_14;
  }
  if ((a4 & 2) != 0)
  {
    uint64_t v11 = TCFBase<TRun>::Allocate();
    if (v11)
    {
      CFIndex v7 = (void *)v11;
      uint64_t v12 = (TRun *)(v11 + 72);
      void v7[2] = 0;
      void v7[3] = 0;
      void v7[4] = 0;
      void v7[5] = v12;
      v7[6] = v12;
      v7[7] = CTMetricsDelegateRun::CloneEntire;
      v7[8] = CTMetricsDelegateRun::CloneRange;
      TRun::TRun(v12, *(const TRun **)(a3 + 40));
      v7[9] = &unk_1ED05E990;
      goto LABEL_14;
    }
LABEL_15:
    id v14 = 0;
    goto LABEL_16;
  }
  if ((a4 & 0x800) != 0)
  {
    LOBYTE(v14) = *(unsigned char *)(*(void *)(a2 + 200) + 155) & 1;
    TCFBase_NEW<CTRubyRun,CTRun *&,BOOL>(&v15, (char *)&v14, &v16);
  }
  else if ((a4 & 0x1000) != 0)
  {
    TCFBase_NEW<CTTateChuYokoRun,CTRun *&>(&v15, &v16);
  }
  else
  {
    if ((a4 & 0x8000) == 0) {
      return;
    }
    TCFBase_NEW<CTTextEncapsulationRun,CTRun *&>(&v16, &v15);
  }

  id v13 = v16;
LABEL_17:
}

uint64_t TDelegateRun::TDelegateRun(uint64_t a1, uint64_t a2)
{
  TRun::TRun((TRun *)a1, *(const TRun **)(a2 + 40));
  *BOOL v3 = &unk_1ED05D7A0;
  CFIndex v4 = v3 + 40;
  *(void *)(a1 + 320) = (id)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit(v3 + 5, memory_order_acquire), @"CTRunDelegate");
  TRunDelegate::TRunDelegate((TRunDelegate *)(a1 + 328), (CFTypeRef)atomic_load_explicit(v4, memory_order_acquire));
  uint64_t v5 = *(double (**)(void, double))(a1 + 344);
  double v6 = 0.0;
  double v7 = 0.0;
  if (v5) {
    double v7 = v5(*(void *)(a1 + 368), 0.0);
  }
  *(double *)(a1 + 376) = v7;
  uint64_t v8 = *(double (**)(void))(a1 + 352);
  if (v8) {
    double v6 = v8(*(void *)(a1 + 368));
  }
  *(double *)(a1 + 384) = v6;
  uint64_t v9 = *(void (**)(uint64_t, double))(a1 + 360);
  if (v9)
  {
    uint64_t v10 = *(void *)(a1 + 368);
    if (*(void *)(a1 + 328) == 2) {
      v9(v10, 0.0);
    }
    else {
      double v11 = ((double (*)(uint64_t))v9)(v10);
    }
  }
  else
  {
    double v11 = 0.0;
  }
  *(double *)(a1 + 392) = v11;
  uint64_t v12 = *(void *)(a1 + 208);
  if (v12 >= 1)
  {
    for (uint64_t i = 0; i != v12; ++i)
    {
      v15.double width = *(CGFloat *)(a1 + 392);
      v15.CGFloat height = 0.0;
      TStorageRange::SetAdvance((TStorageRange *)(a1 + 192), i, v15);
    }
  }
  return a1;
}

void TRunDelegate::TRunDelegate(TRunDelegate *this, CFTypeRef cf)
{
  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 == CTRunDelegateGetTypeID())
  {
    uint64_t v5 = (long long *)*((void *)cf + 5);
    long long v6 = *v5;
    long long v7 = v5[1];
    *((void *)this + 4) = *((void *)v5 + 4);
    *(_OWORD *)this = v6;
    *((_OWORD *)this + 1) = v7;
    uint64_t v8 = *((void *)v5 + 5);
  }
  else
  {
    uint64_t v8 = 0;
    *((void *)this + 4) = 0;
    *(_OWORD *)this = 0u;
    *((_OWORD *)this + 1) = 0u;
  }
  *((void *)this + 5) = v8;
}

CFTypeID CTRunDelegateGetTypeID(void)
{
  if (_MergedGlobals_30 != -1) {
    dispatch_once_f(&_MergedGlobals_30, 0, (dispatch_function_t)TCFBase<TRunDelegate>::GetTypeID(void)::{lambda(void *)#1}::__invoke);
  }
  return qword_1EB2CE788;
}

CTFontRef CTFontCreateCopyWithAttributes(CTFontRef font, CGFloat size, const CGAffineTransform *matrix, CTFontDescriptorRef attributes)
{
  if (!font) {
    return 0;
  }
  uint64_t v8 = (double *)*((void *)font + 5);
  if (attributes || matrix || v8[2] != size)
  {
    id v19 = (id)0xAAAAAAAAAAAAAAAALL;
    TFont::CopyDescriptor((TFont *)v8, 0, (atomic_ullong *)&v19);
    if (atomic_load_explicit((atomic_ullong *volatile)&v19, memory_order_acquire))
    {
      if (attributes)
      {
        uint64_t v10 = (atomic_ullong *)*((void *)attributes + 5);
        id v18 = (id)0xAAAAAAAAAAAAAAAALL;
        TDescriptor::CopyAttributes(v10, &v18);
        if (atomic_load_explicit((atomic_ullong *volatile)&v18, memory_order_acquire))
        {
          CFTypeID v11 = CFGetTypeID((CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)&v18, memory_order_acquire));
          if (v11 == CFDictionaryGetTypeID())
          {
            if (CFDictionaryGetCount((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v18, memory_order_acquire)))
            {
              unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&v19, memory_order_acquire);
              CFDictionaryRef v15 = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v18, memory_order_acquire);
              unint64_t v16 = explicit;
              TCFBase_NEW<CTFontDescriptor,CTFontDescriptor*,__CFDictionary const*&>((uint64_t *)&v16, &v15, &v17);
              id v13 = (void *)atomic_exchange((atomic_ullong *volatile)&v17, 0);

              if (v13) {
                TCFRef<__CTFont const*>::Retain((atomic_ullong *)&v19, v13);
              }
            }
          }
        }
      }
      id v14 = CTFontCreateWithFontDescriptor((CTFontDescriptorRef)atomic_load_explicit((atomic_ullong *volatile)&v19, memory_order_acquire), size, matrix);
    }
    else
    {
      id v14 = 0;
    }

    return v14;
  }

  return font;
}

CTFontDescriptorRef CTFontCopyFontDescriptor(CTFontRef font)
{
  if (!font) {
    return 0;
  }
  TFont::CopyDescriptor(*((TFont **)font + 5), 0, (atomic_ullong *)&v3);
  long long v1 = (const __CTFontDescriptor *)atomic_exchange((atomic_ullong *volatile)&v3, 0);

  return v1;
}

void TFont::CopyDescriptor(TFont *this@<X0>, int a2@<W1>, atomic_ullong *a3@<X8>)
{
  uint64_t v602 = *MEMORY[0x1E4F143B8];
  if (a2 && TFont::IsSystemUIFontAndForShaping((atomic_ullong *)this, (BOOL *)keys)) {
    long long v6 = (atomic_ullong *)((char *)this + 544);
  }
  else {
    long long v6 = (atomic_ullong *)((char *)this + 536);
  }
  *a3 = 0xAAAAAAAAAAAAAAAALL;
  *a3 = (atomic_ullong)(id)atomic_load_explicit(v6, memory_order_acquire);
  if (atomic_load_explicit(a3, memory_order_acquire)) {
    return;
  }
  v571 = v6;
  CFDictionaryRef v7 = CTFontDescriptorCopyAttributes((CTFontDescriptorRef)atomic_load_explicit((atomic_ullong *volatile)this + 1, memory_order_acquire));
  *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v600[14] = v8;
  v600[13] = v8;
  v600[12] = v8;
  v600[11] = v8;
  v600[10] = v8;
  v600[9] = v8;
  v600[8] = v8;
  v600[7] = v8;
  v600[6] = v8;
  v600[5] = v8;
  v600[4] = v8;
  v600[3] = v8;
  v600[2] = v8;
  v600[1] = v8;
  v600[0] = v8;
  keys[0] = 0;
  keys[1] = 0;
  v599 = 0;
  v601 = v600;
  v596[14] = v8;
  v596[13] = v8;
  v596[12] = v8;
  v596[11] = v8;
  v596[10] = v8;
  v596[9] = v8;
  v596[8] = v8;
  v596[7] = v8;
  v596[6] = v8;
  v596[5] = v8;
  v596[4] = v8;
  v596[3] = v8;
  v596[2] = v8;
  v596[1] = v8;
  v596[0] = v8;
  v594[0] = 0;
  v594[1] = 0;
  v595 = 0;
  v597 = v596;
  CFDictionaryRef v9 = v7;
  if (v9)
  {
    CFDictionaryRef v10 = v9;
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v9, @"NSFontSizeAttribute");

    if (Value)
    {
      *(void *)double valuePtr = -1;
      CFNumberGetValue(Value, kCFNumberDoubleType, valuePtr);
      if (*(double *)valuePtr == *((double *)this + 2)) {
        goto LABEL_44;
      }
    }
  }
  else
  {
  }
  uint64_t v12 = keys[1];
  if (keys[1] >= v599)
  {
    int64_t v14 = keys[1] - keys[0];
    if ((unint64_t)(v14 + 1) >> 61) {
      goto LABEL_693;
    }
    unint64_t v15 = ((char *)v599 - (char *)keys[0]) >> 2;
    if (v15 <= v14 + 1) {
      unint64_t v15 = v14 + 1;
    }
    if ((unint64_t)((char *)v599 - (char *)keys[0]) >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v16 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v16 = v15;
    }
    *(void *)&valuePtr[32] = v600;
    if (v16) {
      id v17 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v600, v16);
    }
    else {
      id v17 = 0;
    }
    id v18 = (void **)&v17[8 * v14];
    id v19 = (void **)&v17[8 * v16];
    *(void *)&valuePtr[24] = v19;
    *id v18 = @"NSFontSizeAttribute";
    id v13 = v18 + 1;
    *(void *)&valuePtr[16] = v18 + 1;
    uint64_t v20 = keys[1];
    uint64_t v21 = keys[0];
    if (keys[1] == keys[0])
    {
      int64x2_t v23 = vdupq_n_s64((unint64_t)keys[1]);
    }
    else
    {
      do
      {
        int64x2_t v22 = *--v20;
        *--id v18 = v22;
      }
      while (v20 != v21);
      int64x2_t v23 = *(int64x2_t *)keys;
      id v13 = *(void ***)&valuePtr[16];
      id v19 = *(void ***)&valuePtr[24];
    }
    keys[0] = v18;
    keys[1] = v13;
    *(int64x2_t *)&valuePtr[8] = v23;
    CFTypeID v24 = v599;
    v599 = v19;
    *(void *)&valuePtr[24] = v24;
    *(void *)double valuePtr = v23.i64[0];
    std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)valuePtr);
  }
  else
  {
    *keys[1] = @"NSFontSizeAttribute";
    id v13 = v12 + 1;
  }
  keys[1] = v13;
  unint64_t v25 = (void *)[NSNumber numberWithDouble:*((double *)this + 2)];
  double v26 = v25;
  double v27 = v594[1];
  if (v594[1] >= v595)
  {
    int64_t v29 = v594[1] - v594[0];
    if ((unint64_t)(v29 + 1) >> 61) {
      goto LABEL_693;
    }
    unint64_t v30 = ((char *)v595 - (char *)v594[0]) >> 2;
    if (v30 <= v29 + 1) {
      unint64_t v30 = v29 + 1;
    }
    if ((unint64_t)((char *)v595 - (char *)v594[0]) >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v31 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v31 = v30;
    }
    *(void *)&valuePtr[32] = v596;
    if (v31) {
      double v32 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v596, v31);
    }
    else {
      double v32 = 0;
    }
    double v33 = (void **)&v32[8 * v29];
    double v34 = (void **)&v32[8 * v31];
    *(void *)&valuePtr[24] = v34;
    *double v33 = v26;
    uint64_t v28 = v33 + 1;
    *(void *)&valuePtr[16] = v33 + 1;
    unint64_t v35 = v594[1];
    double v36 = v594[0];
    if (v594[1] == v594[0])
    {
      int64x2_t v38 = vdupq_n_s64((unint64_t)v594[1]);
    }
    else
    {
      do
      {
        unint64_t v37 = *--v35;
        *--double v33 = v37;
      }
      while (v35 != v36);
      int64x2_t v38 = *(int64x2_t *)v594;
      uint64_t v28 = *(void ***)&valuePtr[16];
      double v34 = *(void ***)&valuePtr[24];
    }
    v594[0] = v33;
    v594[1] = v28;
    *(int64x2_t *)&valuePtr[8] = v38;
    double v39 = v595;
    v595 = v34;
    *(void *)&valuePtr[24] = v39;
    *(void *)double valuePtr = v38.i64[0];
    std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)valuePtr);
  }
  else
  {
    *v594[1] = v25;
    uint64_t v28 = v27 + 1;
  }
  v594[1] = v28;
LABEL_44:
  id v572 = 0;
  if (!*((void *)this + 5)) {
    goto LABEL_84;
  }
  CFDictionaryRef v40 = v7;
  if (v40)
  {
    CFDictionaryRef v41 = v40;
    CFDataRef v42 = (const __CFData *)CFDictionaryGetValue(v40, @"NSCTFontMatrixAttribute");

    if (v42)
    {
      BytePtr = CFDataGetBytePtr(v42);
      if (BytePtr)
      {
        if (!memcmp(BytePtr, *((const void **)this + 5), 0x30uLL)) {
          goto LABEL_84;
        }
      }
    }
  }
  else
  {
  }
  double v44 = keys[1];
  if (keys[1] >= v599)
  {
    int64_t v46 = keys[1] - keys[0];
    if ((unint64_t)(v46 + 1) >> 61) {
      goto LABEL_693;
    }
    unint64_t v47 = ((char *)v599 - (char *)keys[0]) >> 2;
    if (v47 <= v46 + 1) {
      unint64_t v47 = v46 + 1;
    }
    if ((unint64_t)((char *)v599 - (char *)keys[0]) >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v48 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v48 = v47;
    }
    *(void *)&valuePtr[32] = v600;
    if (v48) {
      CFNumberRef v49 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v600, v48);
    }
    else {
      CFNumberRef v49 = 0;
    }
    unint64_t v50 = (void **)&v49[8 * v46];
    CFTypeID v51 = (void **)&v49[8 * v48];
    *(void *)&valuePtr[24] = v51;
    double *v50 = @"NSCTFontMatrixAttribute";
    double v45 = v50 + 1;
    *(void *)&valuePtr[16] = v50 + 1;
    uint64_t v52 = keys[1];
    int64x2_t v53 = keys[0];
    if (keys[1] == keys[0])
    {
      int64x2_t v55 = vdupq_n_s64((unint64_t)keys[1]);
    }
    else
    {
      do
      {
        CFNumberRef v54 = *--v52;
        *--unint64_t v50 = v54;
      }
      while (v52 != v53);
      int64x2_t v55 = *(int64x2_t *)keys;
      double v45 = *(void ***)&valuePtr[16];
      CFTypeID v51 = *(void ***)&valuePtr[24];
    }
    keys[0] = v50;
    keys[1] = v45;
    *(int64x2_t *)&valuePtr[8] = v55;
    unint64_t v56 = v599;
    v599 = v51;
    *(void *)&valuePtr[24] = v56;
    *(void *)double valuePtr = v55.i64[0];
    std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)valuePtr);
  }
  else
  {
    *keys[1] = @"NSCTFontMatrixAttribute";
    double v45 = v44 + 1;
  }
  keys[1] = v45;
  unint64_t explicit = (void *)atomic_load_explicit((atomic_ullong *volatile)&v572, memory_order_acquire);
  double v58 = v594[1];
  if (v594[1] >= v595)
  {
    int64_t v60 = v594[1] - v594[0];
    if ((unint64_t)(v60 + 1) >> 61) {
      goto LABEL_693;
    }
    unint64_t v61 = ((char *)v595 - (char *)v594[0]) >> 2;
    if (v61 <= v60 + 1) {
      unint64_t v61 = v60 + 1;
    }
    if ((unint64_t)((char *)v595 - (char *)v594[0]) >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v62 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v62 = v61;
    }
    *(void *)&valuePtr[32] = v596;
    if (v62) {
      CFTypeID v63 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v596, v62);
    }
    else {
      CFTypeID v63 = 0;
    }
    double v64 = (void **)&v63[8 * v60];
    double v65 = (void **)&v63[8 * v62];
    *(void *)&valuePtr[24] = v65;
    *double v64 = explicit;
    uint64_t v59 = v64 + 1;
    *(void *)&valuePtr[16] = v64 + 1;
    double v66 = v594[1];
    double v67 = v594[0];
    if (v594[1] == v594[0])
    {
      int64x2_t v69 = vdupq_n_s64((unint64_t)v594[1]);
    }
    else
    {
      do
      {
        int64x2_t v68 = *--v66;
        *--double v64 = v68;
      }
      while (v66 != v67);
      int64x2_t v69 = *(int64x2_t *)v594;
      uint64_t v59 = *(void ***)&valuePtr[16];
      double v65 = *(void ***)&valuePtr[24];
    }
    v594[0] = v64;
    v594[1] = v59;
    *(int64x2_t *)&valuePtr[8] = v69;
    id v70 = v595;
    v595 = v65;
    *(void *)&valuePtr[24] = v70;
    *(void *)double valuePtr = v69.i64[0];
    std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)valuePtr);
  }
  else
  {
    *v594[1] = explicit;
    uint64_t v59 = v58 + 1;
  }
  v594[1] = v59;
LABEL_84:
  if (!atomic_load_explicit((atomic_ullong *volatile)this + 20, memory_order_acquire)) {
    goto LABEL_555;
  }
  CFDictionaryRef v71 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)this + 20, memory_order_acquire);
  if (v71)
  {
    CFDictionaryRef v72 = v71;
    int v73 = (void *)CFDictionaryGetValue(v71, @"NSCTFontOpticalSizeAttribute");

    if (v73)
    {
      uint64_t v74 = keys[1];
      if (keys[1] >= v599)
      {
        int64_t v76 = keys[1] - keys[0];
        if ((unint64_t)(v76 + 1) >> 61) {
          goto LABEL_693;
        }
        unint64_t v77 = ((char *)v599 - (char *)keys[0]) >> 2;
        if (v77 <= v76 + 1) {
          unint64_t v77 = v76 + 1;
        }
        if ((unint64_t)((char *)v599 - (char *)keys[0]) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v78 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v78 = v77;
        }
        *(void *)&valuePtr[32] = v600;
        if (v78) {
          uint64_t v79 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v600, v78);
        }
        else {
          uint64_t v79 = 0;
        }
        char v80 = (void **)&v79[8 * v76];
        unint64_t v81 = (void **)&v79[8 * v78];
        *(void *)&valuePtr[24] = v81;
        *char v80 = @"NSCTFontOpticalSizeAttribute";
        uint64_t v75 = v80 + 1;
        *(void *)&valuePtr[16] = v80 + 1;
        uint64_t v82 = keys[1];
        uint64_t v83 = keys[0];
        if (keys[1] == keys[0])
        {
          int64x2_t v85 = vdupq_n_s64((unint64_t)keys[1]);
        }
        else
        {
          do
          {
            int64x2_t v84 = *--v82;
            *--char v80 = v84;
          }
          while (v82 != v83);
          int64x2_t v85 = *(int64x2_t *)keys;
          uint64_t v75 = *(void ***)&valuePtr[16];
          unint64_t v81 = *(void ***)&valuePtr[24];
        }
        keys[0] = v80;
        keys[1] = v75;
        *(int64x2_t *)&valuePtr[8] = v85;
        unint64_t v86 = v599;
        v599 = v81;
        *(void *)&valuePtr[24] = v86;
        *(void *)double valuePtr = v85.i64[0];
        std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)valuePtr);
      }
      else
      {
        *keys[1] = @"NSCTFontOpticalSizeAttribute";
        uint64_t v75 = v74 + 1;
      }
      keys[1] = v75;
      __int16 v87 = v594[1];
      if (v594[1] >= v595)
      {
        int64_t v89 = v594[1] - v594[0];
        if ((unint64_t)(v89 + 1) >> 61) {
          goto LABEL_693;
        }
        unint64_t v90 = ((char *)v595 - (char *)v594[0]) >> 2;
        if (v90 <= v89 + 1) {
          unint64_t v90 = v89 + 1;
        }
        if ((unint64_t)((char *)v595 - (char *)v594[0]) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v91 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v91 = v90;
        }
        *(void *)&valuePtr[32] = v596;
        if (v91) {
          unint64_t v92 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v596, v91);
        }
        else {
          unint64_t v92 = 0;
        }
        CGAffineTransform v93 = (void **)&v92[8 * v89];
        long long v94 = (void **)&v92[8 * v91];
        *(void *)&valuePtr[24] = v94;
        *CGAffineTransform v93 = v73;
        int v88 = v93 + 1;
        *(void *)&valuePtr[16] = v93 + 1;
        long long v95 = v594[1];
        unint64_t v96 = v594[0];
        if (v594[1] == v594[0])
        {
          int64x2_t v98 = vdupq_n_s64((unint64_t)v594[1]);
        }
        else
        {
          do
          {
            uint64_t v97 = *--v95;
            *--CGAffineTransform v93 = v97;
          }
          while (v95 != v96);
          int64x2_t v98 = *(int64x2_t *)v594;
          int v88 = *(void ***)&valuePtr[16];
          long long v94 = *(void ***)&valuePtr[24];
        }
        v594[0] = v93;
        v594[1] = v88;
        *(int64x2_t *)&valuePtr[8] = v98;
        int64x2_t v99 = v595;
        v595 = v94;
        *(void *)&valuePtr[24] = v99;
        *(void *)double valuePtr = v98.i64[0];
        std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)valuePtr);
      }
      else
      {
        *v594[1] = v73;
        int v88 = v87 + 1;
      }
      v594[1] = v88;
    }
  }
  else
  {
  }
  CFDictionaryRef v100 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)this + 20, memory_order_acquire);
  if (v100)
  {
    CFDictionaryRef v101 = v100;
    unint64_t v102 = (void *)CFDictionaryGetValue(v100, @"NSCTFontTrackAttribute");

    if (v102)
    {
      long long v103 = keys[1];
      if (keys[1] >= v599)
      {
        int64_t v105 = keys[1] - keys[0];
        if ((unint64_t)(v105 + 1) >> 61) {
          goto LABEL_693;
        }
        unint64_t v106 = ((char *)v599 - (char *)keys[0]) >> 2;
        if (v106 <= v105 + 1) {
          unint64_t v106 = v105 + 1;
        }
        if ((unint64_t)((char *)v599 - (char *)keys[0]) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v107 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v107 = v106;
        }
        *(void *)&valuePtr[32] = v600;
        if (v107) {
          unint64_t v108 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v600, v107);
        }
        else {
          unint64_t v108 = 0;
        }
        uint64_t v109 = (void **)&v108[8 * v105];
        long long v110 = (void **)&v108[8 * v107];
        *(void *)&valuePtr[24] = v110;
        *uint64_t v109 = @"NSCTFontTrackAttribute";
        uint64_t v104 = v109 + 1;
        *(void *)&valuePtr[16] = v109 + 1;
        long long v111 = keys[1];
        unint64_t v112 = keys[0];
        if (keys[1] == keys[0])
        {
          int64x2_t v114 = vdupq_n_s64((unint64_t)keys[1]);
        }
        else
        {
          do
          {
            uint64_t v113 = *--v111;
            *--uint64_t v109 = v113;
          }
          while (v111 != v112);
          int64x2_t v114 = *(int64x2_t *)keys;
          uint64_t v104 = *(void ***)&valuePtr[16];
          long long v110 = *(void ***)&valuePtr[24];
        }
        keys[0] = v109;
        keys[1] = v104;
        *(int64x2_t *)&valuePtr[8] = v114;
        int64x2_t v115 = v599;
        v599 = v110;
        *(void *)&valuePtr[24] = v115;
        *(void *)double valuePtr = v114.i64[0];
        std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)valuePtr);
      }
      else
      {
        *keys[1] = @"NSCTFontTrackAttribute";
        uint64_t v104 = v103 + 1;
      }
      keys[1] = v104;
      long long v116 = v594[1];
      if (v594[1] >= v595)
      {
        int64_t v118 = v594[1] - v594[0];
        if ((unint64_t)(v118 + 1) >> 61) {
          goto LABEL_693;
        }
        unint64_t v119 = ((char *)v595 - (char *)v594[0]) >> 2;
        if (v119 <= v118 + 1) {
          unint64_t v119 = v118 + 1;
        }
        if ((unint64_t)((char *)v595 - (char *)v594[0]) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v120 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v120 = v119;
        }
        *(void *)&valuePtr[32] = v596;
        if (v120) {
          uint64_t v121 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v596, v120);
        }
        else {
          uint64_t v121 = 0;
        }
        uint64_t v122 = (void **)&v121[8 * v118];
        uint64_t v123 = (void **)&v121[8 * v120];
        *(void *)&valuePtr[24] = v123;
        *uint64_t v122 = v102;
        uint64_t v117 = v122 + 1;
        *(void *)&valuePtr[16] = v122 + 1;
        unint64_t v124 = v594[1];
        uint64_t v125 = v594[0];
        if (v594[1] == v594[0])
        {
          int64x2_t v127 = vdupq_n_s64((unint64_t)v594[1]);
        }
        else
        {
          do
          {
            uint64_t v126 = *--v124;
            *--uint64_t v122 = v126;
          }
          while (v124 != v125);
          int64x2_t v127 = *(int64x2_t *)v594;
          uint64_t v117 = *(void ***)&valuePtr[16];
          uint64_t v123 = *(void ***)&valuePtr[24];
        }
        v594[0] = v122;
        v594[1] = v117;
        *(int64x2_t *)&valuePtr[8] = v127;
        unint64_t v128 = v595;
        v595 = v123;
        *(void *)&valuePtr[24] = v128;
        *(void *)double valuePtr = v127.i64[0];
        std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)valuePtr);
      }
      else
      {
        *v594[1] = v102;
        uint64_t v117 = v116 + 1;
      }
      v594[1] = v117;
    }
  }
  else
  {
  }
  CFDictionaryRef v129 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)this + 20, memory_order_acquire);
  if (v129)
  {
    CFDictionaryRef v130 = v129;
    int64x2_t v131 = (void *)CFDictionaryGetValue(v129, @"NSCTFontUnscaledTrackingAttribute");

    if (v131)
    {
      char v132 = keys[1];
      if (keys[1] >= v599)
      {
        int64_t v134 = keys[1] - keys[0];
        if ((unint64_t)(v134 + 1) >> 61) {
          goto LABEL_693;
        }
        unint64_t v135 = ((char *)v599 - (char *)keys[0]) >> 2;
        if (v135 <= v134 + 1) {
          unint64_t v135 = v134 + 1;
        }
        if ((unint64_t)((char *)v599 - (char *)keys[0]) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v136 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v136 = v135;
        }
        *(void *)&valuePtr[32] = v600;
        if (v136) {
          uint64_t v137 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v600, v136);
        }
        else {
          uint64_t v137 = 0;
        }
        double v138 = (void **)&v137[8 * v134];
        uint64_t v139 = (void **)&v137[8 * v136];
        *(void *)&valuePtr[24] = v139;
        char *v138 = @"NSCTFontUnscaledTrackingAttribute";
        id v133 = v138 + 1;
        *(void *)&valuePtr[16] = v138 + 1;
        __int16 v140 = keys[1];
        uint64_t v141 = keys[0];
        if (keys[1] == keys[0])
        {
          int64x2_t v143 = vdupq_n_s64((unint64_t)keys[1]);
        }
        else
        {
          do
          {
            BOOL v142 = *--v140;
            *--double v138 = v142;
          }
          while (v140 != v141);
          int64x2_t v143 = *(int64x2_t *)keys;
          id v133 = *(void ***)&valuePtr[16];
          uint64_t v139 = *(void ***)&valuePtr[24];
        }
        keys[0] = v138;
        keys[1] = v133;
        *(int64x2_t *)&valuePtr[8] = v143;
        BOOL v144 = v599;
        v599 = v139;
        *(void *)&valuePtr[24] = v144;
        *(void *)double valuePtr = v143.i64[0];
        std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)valuePtr);
      }
      else
      {
        *keys[1] = @"NSCTFontUnscaledTrackingAttribute";
        id v133 = v132 + 1;
      }
      keys[1] = v133;
      int v145 = v594[1];
      if (v594[1] >= v595)
      {
        int64_t v147 = v594[1] - v594[0];
        if ((unint64_t)(v147 + 1) >> 61) {
          goto LABEL_693;
        }
        unint64_t v148 = ((char *)v595 - (char *)v594[0]) >> 2;
        if (v148 <= v147 + 1) {
          unint64_t v148 = v147 + 1;
        }
        if ((unint64_t)((char *)v595 - (char *)v594[0]) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v149 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v149 = v148;
        }
        *(void *)&valuePtr[32] = v596;
        if (v149) {
          int v150 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v596, v149);
        }
        else {
          int v150 = 0;
        }
        int v151 = (void **)&v150[8 * v147];
        char v152 = (void **)&v150[8 * v149];
        *(void *)&valuePtr[24] = v152;
        *int v151 = v131;
        uint64_t v146 = v151 + 1;
        *(void *)&valuePtr[16] = v151 + 1;
        uint64_t v153 = v594[1];
        uint64_t v154 = v594[0];
        if (v594[1] == v594[0])
        {
          int64x2_t v156 = vdupq_n_s64((unint64_t)v594[1]);
        }
        else
        {
          do
          {
            uint64_t v155 = *--v153;
            *--int v151 = v155;
          }
          while (v153 != v154);
          int64x2_t v156 = *(int64x2_t *)v594;
          uint64_t v146 = *(void ***)&valuePtr[16];
          char v152 = *(void ***)&valuePtr[24];
        }
        v594[0] = v151;
        v594[1] = v146;
        *(int64x2_t *)&valuePtr[8] = v156;
        uint64_t v157 = v595;
        v595 = v152;
        *(void *)&valuePtr[24] = v157;
        *(void *)double valuePtr = v156.i64[0];
        std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)valuePtr);
      }
      else
      {
        *v594[1] = v131;
        uint64_t v146 = v145 + 1;
      }
      v594[1] = v146;
    }
  }
  else
  {
  }
  CFDictionaryRef v158 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)this + 20, memory_order_acquire);
  if (v158)
  {
    CFDictionaryRef v159 = v158;
    uint64_t v160 = (void *)CFDictionaryGetValue(v158, @"NSCTFontFeatureSettingsAttribute");

    if (v160)
    {
      uint64_t v161 = keys[1];
      if (keys[1] >= v599)
      {
        int64_t v163 = keys[1] - keys[0];
        if ((unint64_t)(v163 + 1) >> 61) {
          goto LABEL_693;
        }
        unint64_t v164 = ((char *)v599 - (char *)keys[0]) >> 2;
        if (v164 <= v163 + 1) {
          unint64_t v164 = v163 + 1;
        }
        if ((unint64_t)((char *)v599 - (char *)keys[0]) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v165 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v165 = v164;
        }
        *(void *)&valuePtr[32] = v600;
        if (v165) {
          BOOL v166 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v600, v165);
        }
        else {
          BOOL v166 = 0;
        }
        CFIndex v167 = (void **)&v166[8 * v163];
        uint64_t v168 = (void **)&v166[8 * v165];
        *(void *)&valuePtr[24] = v168;
        *CFIndex v167 = @"NSCTFontFeatureSettingsAttribute";
        uint64_t v162 = v167 + 1;
        *(void *)&valuePtr[16] = v167 + 1;
        id v169 = keys[1];
        __n128 v170 = keys[0];
        if (keys[1] == keys[0])
        {
          int64x2_t v172 = vdupq_n_s64((unint64_t)keys[1]);
        }
        else
        {
          do
          {
            CFIndex v171 = *--v169;
            *--CFIndex v167 = v171;
          }
          while (v169 != v170);
          int64x2_t v172 = *(int64x2_t *)keys;
          uint64_t v162 = *(void ***)&valuePtr[16];
          uint64_t v168 = *(void ***)&valuePtr[24];
        }
        keys[0] = v167;
        keys[1] = v162;
        *(int64x2_t *)&valuePtr[8] = v172;
        uint64_t v173 = v599;
        v599 = v168;
        *(void *)&valuePtr[24] = v173;
        *(void *)double valuePtr = v172.i64[0];
        std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)valuePtr);
      }
      else
      {
        *keys[1] = @"NSCTFontFeatureSettingsAttribute";
        uint64_t v162 = v161 + 1;
      }
      keys[1] = v162;
      uint64_t v174 = v594[1];
      if (v594[1] >= v595)
      {
        int64_t v176 = v594[1] - v594[0];
        if ((unint64_t)(v176 + 1) >> 61) {
          goto LABEL_693;
        }
        unint64_t v177 = ((char *)v595 - (char *)v594[0]) >> 2;
        if (v177 <= v176 + 1) {
          unint64_t v177 = v176 + 1;
        }
        if ((unint64_t)((char *)v595 - (char *)v594[0]) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v178 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v178 = v177;
        }
        *(void *)&valuePtr[32] = v596;
        if (v178) {
          long long v179 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v596, v178);
        }
        else {
          long long v179 = 0;
        }
        long long v180 = (void **)&v179[8 * v176];
        long long v181 = (void **)&v179[8 * v178];
        *(void *)&valuePtr[24] = v181;
        *long long v180 = v160;
        uint64_t v175 = v180 + 1;
        *(void *)&valuePtr[16] = v180 + 1;
        long long v182 = v594[1];
        long long v183 = v594[0];
        if (v594[1] == v594[0])
        {
          int64x2_t v185 = vdupq_n_s64((unint64_t)v594[1]);
        }
        else
        {
          do
          {
            long long v184 = *--v182;
            *--long long v180 = v184;
          }
          while (v182 != v183);
          int64x2_t v185 = *(int64x2_t *)v594;
          uint64_t v175 = *(void ***)&valuePtr[16];
          long long v181 = *(void ***)&valuePtr[24];
        }
        v594[0] = v180;
        v594[1] = v175;
        *(int64x2_t *)&valuePtr[8] = v185;
        long long v186 = v595;
        v595 = v181;
        *(void *)&valuePtr[24] = v186;
        *(void *)double valuePtr = v185.i64[0];
        std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)valuePtr);
      }
      else
      {
        *v594[1] = v160;
        uint64_t v175 = v174 + 1;
      }
      v594[1] = v175;
      if (!a2) {
        goto LABEL_267;
      }
      goto LABEL_231;
    }
  }
  else
  {
  }
  if (!a2) {
    goto LABEL_267;
  }
LABEL_231:
  CFDictionaryRef v187 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)this + 20, memory_order_acquire);
  if (v187)
  {
    CFDictionaryRef v188 = v187;
    BOOL v189 = (void *)CFDictionaryGetValue(v187, @"CTFontOriginalFeatureSettingsAttribute");

    if (v189)
    {
      unint64_t v190 = keys[1];
      if (keys[1] >= v599)
      {
        int64_t v192 = keys[1] - keys[0];
        if ((unint64_t)(v192 + 1) >> 61) {
          goto LABEL_693;
        }
        unint64_t v193 = ((char *)v599 - (char *)keys[0]) >> 2;
        if (v193 <= v192 + 1) {
          unint64_t v193 = v192 + 1;
        }
        if ((unint64_t)((char *)v599 - (char *)keys[0]) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v194 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v194 = v193;
        }
        *(void *)&valuePtr[32] = v600;
        if (v194) {
          int v195 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v600, v194);
        }
        else {
          int v195 = 0;
        }
        unint64_t v196 = (void **)&v195[8 * v192];
        uint64_t v197 = (void **)&v195[8 * v194];
        *(void *)&valuePtr[24] = v197;
        *unint64_t v196 = @"CTFontOriginalFeatureSettingsAttribute";
        char v191 = v196 + 1;
        *(void *)&valuePtr[16] = v196 + 1;
        uint64_t v198 = keys[1];
        BOOL v199 = keys[0];
        if (keys[1] == keys[0])
        {
          int64x2_t v201 = vdupq_n_s64((unint64_t)keys[1]);
        }
        else
        {
          do
          {
            uint64_t v200 = *--v198;
            *--unint64_t v196 = v200;
          }
          while (v198 != v199);
          int64x2_t v201 = *(int64x2_t *)keys;
          char v191 = *(void ***)&valuePtr[16];
          uint64_t v197 = *(void ***)&valuePtr[24];
        }
        keys[0] = v196;
        keys[1] = v191;
        *(int64x2_t *)&valuePtr[8] = v201;
        uint64_t v202 = v599;
        v599 = v197;
        *(void *)&valuePtr[24] = v202;
        *(void *)double valuePtr = v201.i64[0];
        std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)valuePtr);
      }
      else
      {
        *keys[1] = @"CTFontOriginalFeatureSettingsAttribute";
        char v191 = v190 + 1;
      }
      keys[1] = v191;
      int v203 = v594[1];
      if (v594[1] >= v595)
      {
        int64_t v205 = v594[1] - v594[0];
        if ((unint64_t)(v205 + 1) >> 61) {
          goto LABEL_693;
        }
        unint64_t v206 = ((char *)v595 - (char *)v594[0]) >> 2;
        if (v206 <= v205 + 1) {
          unint64_t v206 = v205 + 1;
        }
        if ((unint64_t)((char *)v595 - (char *)v594[0]) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v207 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v207 = v206;
        }
        *(void *)&valuePtr[32] = v596;
        if (v207) {
          int v208 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v596, v207);
        }
        else {
          int v208 = 0;
        }
        char v209 = (void **)&v208[8 * v205];
        uint64_t v210 = (void **)&v208[8 * v207];
        *(void *)&valuePtr[24] = v210;
        *char v209 = v189;
        unint64_t v204 = v209 + 1;
        *(void *)&valuePtr[16] = v209 + 1;
        uint64_t v211 = v594[1];
        long long v212 = v594[0];
        if (v594[1] == v594[0])
        {
          int64x2_t v214 = vdupq_n_s64((unint64_t)v594[1]);
        }
        else
        {
          do
          {
            double v213 = *--v211;
            *--char v209 = v213;
          }
          while (v211 != v212);
          int64x2_t v214 = *(int64x2_t *)v594;
          unint64_t v204 = *(void ***)&valuePtr[16];
          uint64_t v210 = *(void ***)&valuePtr[24];
        }
        v594[0] = v209;
        v594[1] = v204;
        *(int64x2_t *)&valuePtr[8] = v214;
        unint64_t v215 = v595;
        v595 = v210;
        *(void *)&valuePtr[24] = v215;
        *(void *)double valuePtr = v214.i64[0];
        std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)valuePtr);
      }
      else
      {
        *v594[1] = v189;
        unint64_t v204 = v203 + 1;
      }
      v594[1] = v204;
    }
  }
  else
  {
  }
LABEL_267:
  CFDictionaryRef v216 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)this + 20, memory_order_acquire);
  if (v216)
  {
    CFDictionaryRef v217 = v216;
    long long v218 = (void *)CFDictionaryGetValue(v216, @"NSCTFontCascadeListAttribute");

    if (v218)
    {
      long long v219 = keys[1];
      if (keys[1] >= v599)
      {
        int64_t v221 = keys[1] - keys[0];
        if ((unint64_t)(v221 + 1) >> 61) {
          goto LABEL_693;
        }
        unint64_t v222 = ((char *)v599 - (char *)keys[0]) >> 2;
        if (v222 <= v221 + 1) {
          unint64_t v222 = v221 + 1;
        }
        if ((unint64_t)((char *)v599 - (char *)keys[0]) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v223 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v223 = v222;
        }
        *(void *)&valuePtr[32] = v600;
        if (v223) {
          long long v224 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v600, v223);
        }
        else {
          long long v224 = 0;
        }
        long long v225 = (void **)&v224[8 * v221];
        long long v226 = (void **)&v224[8 * v223];
        *(void *)&valuePtr[24] = v226;
        *long long v225 = @"NSCTFontCascadeListAttribute";
        long long v220 = v225 + 1;
        *(void *)&valuePtr[16] = v225 + 1;
        long long v227 = keys[1];
        uint64_t v228 = keys[0];
        if (keys[1] == keys[0])
        {
          int64x2_t v230 = vdupq_n_s64((unint64_t)keys[1]);
        }
        else
        {
          do
          {
            uint64_t v229 = *--v227;
            *--long long v225 = v229;
          }
          while (v227 != v228);
          int64x2_t v230 = *(int64x2_t *)keys;
          long long v220 = *(void ***)&valuePtr[16];
          long long v226 = *(void ***)&valuePtr[24];
        }
        keys[0] = v225;
        keys[1] = v220;
        *(int64x2_t *)&valuePtr[8] = v230;
        v231 = v599;
        v599 = v226;
        *(void *)&valuePtr[24] = v231;
        *(void *)double valuePtr = v230.i64[0];
        std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)valuePtr);
      }
      else
      {
        *keys[1] = @"NSCTFontCascadeListAttribute";
        long long v220 = v219 + 1;
      }
      keys[1] = v220;
      v232 = v594[1];
      if (v594[1] >= v595)
      {
        int64_t v234 = v594[1] - v594[0];
        if ((unint64_t)(v234 + 1) >> 61) {
          goto LABEL_693;
        }
        unint64_t v235 = ((char *)v595 - (char *)v594[0]) >> 2;
        if (v235 <= v234 + 1) {
          unint64_t v235 = v234 + 1;
        }
        if ((unint64_t)((char *)v595 - (char *)v594[0]) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v236 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v236 = v235;
        }
        *(void *)&valuePtr[32] = v596;
        if (v236) {
          uint64_t v237 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v596, v236);
        }
        else {
          uint64_t v237 = 0;
        }
        v238 = (void **)&v237[8 * v234];
        v239 = (void **)&v237[8 * v236];
        *(void *)&valuePtr[24] = v239;
        *v238 = v218;
        v233 = v238 + 1;
        *(void *)&valuePtr[16] = v238 + 1;
        v240 = v594[1];
        v241 = v594[0];
        if (v594[1] == v594[0])
        {
          int64x2_t v243 = vdupq_n_s64((unint64_t)v594[1]);
        }
        else
        {
          do
          {
            v242 = *--v240;
            *--v238 = v242;
          }
          while (v240 != v241);
          int64x2_t v243 = *(int64x2_t *)v594;
          v233 = *(void ***)&valuePtr[16];
          v239 = *(void ***)&valuePtr[24];
        }
        v594[0] = v238;
        v594[1] = v233;
        *(int64x2_t *)&valuePtr[8] = v243;
        v244 = v595;
        v595 = v239;
        *(void *)&valuePtr[24] = v244;
        *(void *)double valuePtr = v243.i64[0];
        std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)valuePtr);
      }
      else
      {
        *v594[1] = v218;
        v233 = v232 + 1;
      }
      v594[1] = v233;
    }
  }
  else
  {
  }
  CFDictionaryRef v245 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)this + 20, memory_order_acquire);
  if (v245)
  {
    CFDictionaryRef v246 = v245;
    v247 = (void *)CFDictionaryGetValue(v245, @"CTFontDescriptorLanguageAttribute");

    if (v247)
    {
      v248 = keys[1];
      if (keys[1] >= v599)
      {
        int64_t v250 = keys[1] - keys[0];
        if ((unint64_t)(v250 + 1) >> 61) {
          goto LABEL_693;
        }
        unint64_t v251 = ((char *)v599 - (char *)keys[0]) >> 2;
        if (v251 <= v250 + 1) {
          unint64_t v251 = v250 + 1;
        }
        if ((unint64_t)((char *)v599 - (char *)keys[0]) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v252 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v252 = v251;
        }
        *(void *)&valuePtr[32] = v600;
        if (v252) {
          v253 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v600, v252);
        }
        else {
          v253 = 0;
        }
        v254 = (void **)&v253[8 * v250];
        v255 = (void **)&v253[8 * v252];
        *(void *)&valuePtr[24] = v255;
        *v254 = @"CTFontDescriptorLanguageAttribute";
        v249 = v254 + 1;
        *(void *)&valuePtr[16] = v254 + 1;
        v256 = keys[1];
        v257 = keys[0];
        if (keys[1] == keys[0])
        {
          int64x2_t v259 = vdupq_n_s64((unint64_t)keys[1]);
        }
        else
        {
          do
          {
            v258 = *--v256;
            *--v254 = v258;
          }
          while (v256 != v257);
          int64x2_t v259 = *(int64x2_t *)keys;
          v249 = *(void ***)&valuePtr[16];
          v255 = *(void ***)&valuePtr[24];
        }
        keys[0] = v254;
        keys[1] = v249;
        *(int64x2_t *)&valuePtr[8] = v259;
        v260 = v599;
        v599 = v255;
        *(void *)&valuePtr[24] = v260;
        *(void *)double valuePtr = v259.i64[0];
        std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)valuePtr);
      }
      else
      {
        *keys[1] = @"CTFontDescriptorLanguageAttribute";
        v249 = v248 + 1;
      }
      keys[1] = v249;
      v261 = v594[1];
      if (v594[1] >= v595)
      {
        int64_t v263 = v594[1] - v594[0];
        if ((unint64_t)(v263 + 1) >> 61) {
          goto LABEL_693;
        }
        unint64_t v264 = ((char *)v595 - (char *)v594[0]) >> 2;
        if (v264 <= v263 + 1) {
          unint64_t v264 = v263 + 1;
        }
        if ((unint64_t)((char *)v595 - (char *)v594[0]) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v265 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v265 = v264;
        }
        *(void *)&valuePtr[32] = v596;
        if (v265) {
          v266 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v596, v265);
        }
        else {
          v266 = 0;
        }
        v267 = (void **)&v266[8 * v263];
        v268 = (void **)&v266[8 * v265];
        *(void *)&valuePtr[24] = v268;
        *v267 = v247;
        v262 = v267 + 1;
        *(void *)&valuePtr[16] = v267 + 1;
        v269 = v594[1];
        v270 = v594[0];
        if (v594[1] == v594[0])
        {
          int64x2_t v272 = vdupq_n_s64((unint64_t)v594[1]);
        }
        else
        {
          do
          {
            v271 = *--v269;
            *--v267 = v271;
          }
          while (v269 != v270);
          int64x2_t v272 = *(int64x2_t *)v594;
          v262 = *(void ***)&valuePtr[16];
          v268 = *(void ***)&valuePtr[24];
        }
        v594[0] = v267;
        v594[1] = v262;
        *(int64x2_t *)&valuePtr[8] = v272;
        v273 = v595;
        v595 = v268;
        *(void *)&valuePtr[24] = v273;
        *(void *)double valuePtr = v272.i64[0];
        std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)valuePtr);
      }
      else
      {
        *v594[1] = v247;
        v262 = v261 + 1;
      }
      v594[1] = v262;
    }
  }
  else
  {
  }
  CFDictionaryRef v274 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)this + 20, memory_order_acquire);
  if (v274)
  {
    CFDictionaryRef v275 = v274;
    v276 = (void *)CFDictionaryGetValue(v274, @"NSCTFontBaselineAdjustAttribute");

    if (v276)
    {
      v277 = keys[1];
      if (keys[1] >= v599)
      {
        int64_t v279 = keys[1] - keys[0];
        if ((unint64_t)(v279 + 1) >> 61) {
          goto LABEL_693;
        }
        unint64_t v280 = ((char *)v599 - (char *)keys[0]) >> 2;
        if (v280 <= v279 + 1) {
          unint64_t v280 = v279 + 1;
        }
        if ((unint64_t)((char *)v599 - (char *)keys[0]) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v281 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v281 = v280;
        }
        *(void *)&valuePtr[32] = v600;
        if (v281) {
          v282 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v600, v281);
        }
        else {
          v282 = 0;
        }
        v283 = (void **)&v282[8 * v279];
        v284 = (void **)&v282[8 * v281];
        *(void *)&valuePtr[24] = v284;
        *v283 = @"NSCTFontBaselineAdjustAttribute";
        v278 = v283 + 1;
        *(void *)&valuePtr[16] = v283 + 1;
        v285 = keys[1];
        v286 = keys[0];
        if (keys[1] == keys[0])
        {
          int64x2_t v288 = vdupq_n_s64((unint64_t)keys[1]);
        }
        else
        {
          do
          {
            v287 = *--v285;
            *--v283 = v287;
          }
          while (v285 != v286);
          int64x2_t v288 = *(int64x2_t *)keys;
          v278 = *(void ***)&valuePtr[16];
          v284 = *(void ***)&valuePtr[24];
        }
        keys[0] = v283;
        keys[1] = v278;
        *(int64x2_t *)&valuePtr[8] = v288;
        v289 = v599;
        v599 = v284;
        *(void *)&valuePtr[24] = v289;
        *(void *)double valuePtr = v288.i64[0];
        std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)valuePtr);
      }
      else
      {
        *keys[1] = @"NSCTFontBaselineAdjustAttribute";
        v278 = v277 + 1;
      }
      keys[1] = v278;
      v290 = v594[1];
      if (v594[1] >= v595)
      {
        int64_t v292 = v594[1] - v594[0];
        if ((unint64_t)(v292 + 1) >> 61) {
          goto LABEL_693;
        }
        unint64_t v293 = ((char *)v595 - (char *)v594[0]) >> 2;
        if (v293 <= v292 + 1) {
          unint64_t v293 = v292 + 1;
        }
        if ((unint64_t)((char *)v595 - (char *)v594[0]) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v294 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v294 = v293;
        }
        *(void *)&valuePtr[32] = v596;
        if (v294) {
          v295 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v596, v294);
        }
        else {
          v295 = 0;
        }
        v296 = (void **)&v295[8 * v292];
        v297 = (void **)&v295[8 * v294];
        *(void *)&valuePtr[24] = v297;
        *v296 = v276;
        v291 = v296 + 1;
        *(void *)&valuePtr[16] = v296 + 1;
        v298 = v594[1];
        v299 = v594[0];
        if (v594[1] == v594[0])
        {
          int64x2_t v301 = vdupq_n_s64((unint64_t)v594[1]);
        }
        else
        {
          do
          {
            v300 = *--v298;
            *--v296 = v300;
          }
          while (v298 != v299);
          int64x2_t v301 = *(int64x2_t *)v594;
          v291 = *(void ***)&valuePtr[16];
          v297 = *(void ***)&valuePtr[24];
        }
        v594[0] = v296;
        v594[1] = v291;
        *(int64x2_t *)&valuePtr[8] = v301;
        v302 = v595;
        v595 = v297;
        *(void *)&valuePtr[24] = v302;
        *(void *)double valuePtr = v301.i64[0];
        std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)valuePtr);
      }
      else
      {
        *v594[1] = v276;
        v291 = v290 + 1;
      }
      v594[1] = v291;
    }
  }
  else
  {
  }
  CFDictionaryRef v303 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)this + 20, memory_order_acquire);
  if (v303)
  {
    CFDictionaryRef v304 = v303;
    v305 = (void *)CFDictionaryGetValue(v303, @"NSCTFontFixedAdvanceAttribute");

    if (v305)
    {
      v306 = keys[1];
      if (keys[1] >= v599)
      {
        int64_t v308 = keys[1] - keys[0];
        if ((unint64_t)(v308 + 1) >> 61) {
          goto LABEL_693;
        }
        unint64_t v309 = ((char *)v599 - (char *)keys[0]) >> 2;
        if (v309 <= v308 + 1) {
          unint64_t v309 = v308 + 1;
        }
        if ((unint64_t)((char *)v599 - (char *)keys[0]) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v310 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v310 = v309;
        }
        *(void *)&valuePtr[32] = v600;
        if (v310) {
          v311 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v600, v310);
        }
        else {
          v311 = 0;
        }
        v312 = (void **)&v311[8 * v308];
        v313 = (void **)&v311[8 * v310];
        *(void *)&valuePtr[24] = v313;
        *v312 = @"NSCTFontFixedAdvanceAttribute";
        v307 = v312 + 1;
        *(void *)&valuePtr[16] = v312 + 1;
        v314 = keys[1];
        v315 = keys[0];
        if (keys[1] == keys[0])
        {
          int64x2_t v317 = vdupq_n_s64((unint64_t)keys[1]);
        }
        else
        {
          do
          {
            v316 = *--v314;
            *--v312 = v316;
          }
          while (v314 != v315);
          int64x2_t v317 = *(int64x2_t *)keys;
          v307 = *(void ***)&valuePtr[16];
          v313 = *(void ***)&valuePtr[24];
        }
        keys[0] = v312;
        keys[1] = v307;
        *(int64x2_t *)&valuePtr[8] = v317;
        v318 = v599;
        v599 = v313;
        *(void *)&valuePtr[24] = v318;
        *(void *)double valuePtr = v317.i64[0];
        std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)valuePtr);
      }
      else
      {
        *keys[1] = @"NSCTFontFixedAdvanceAttribute";
        v307 = v306 + 1;
      }
      keys[1] = v307;
      v319 = v594[1];
      if (v594[1] >= v595)
      {
        int64_t v321 = v594[1] - v594[0];
        if ((unint64_t)(v321 + 1) >> 61) {
          goto LABEL_693;
        }
        unint64_t v322 = ((char *)v595 - (char *)v594[0]) >> 2;
        if (v322 <= v321 + 1) {
          unint64_t v322 = v321 + 1;
        }
        if ((unint64_t)((char *)v595 - (char *)v594[0]) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v323 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v323 = v322;
        }
        *(void *)&valuePtr[32] = v596;
        if (v323) {
          v324 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v596, v323);
        }
        else {
          v324 = 0;
        }
        v325 = (void **)&v324[8 * v321];
        v326 = (void **)&v324[8 * v323];
        *(void *)&valuePtr[24] = v326;
        *v325 = v305;
        v320 = v325 + 1;
        *(void *)&valuePtr[16] = v325 + 1;
        v327 = v594[1];
        v328 = v594[0];
        if (v594[1] == v594[0])
        {
          int64x2_t v330 = vdupq_n_s64((unint64_t)v594[1]);
        }
        else
        {
          do
          {
            v329 = *--v327;
            *--v325 = v329;
          }
          while (v327 != v328);
          int64x2_t v330 = *(int64x2_t *)v594;
          v320 = *(void ***)&valuePtr[16];
          v326 = *(void ***)&valuePtr[24];
        }
        v594[0] = v325;
        v594[1] = v320;
        *(int64x2_t *)&valuePtr[8] = v330;
        v331 = v595;
        v595 = v326;
        *(void *)&valuePtr[24] = v331;
        *(void *)double valuePtr = v330.i64[0];
        std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)valuePtr);
      }
      else
      {
        *v594[1] = v305;
        v320 = v319 + 1;
      }
      v594[1] = v320;
    }
  }
  else
  {
  }
  CFDictionaryRef v332 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)this + 20, memory_order_acquire);
  if (v332)
  {
    CFDictionaryRef v333 = v332;
    v334 = (void *)CFDictionaryGetValue(v332, @"CTFontPaletteAttribute");

    if (v334)
    {
      v335 = keys[1];
      if (keys[1] >= v599)
      {
        int64_t v337 = keys[1] - keys[0];
        if ((unint64_t)(v337 + 1) >> 61) {
          goto LABEL_693;
        }
        unint64_t v338 = ((char *)v599 - (char *)keys[0]) >> 2;
        if (v338 <= v337 + 1) {
          unint64_t v338 = v337 + 1;
        }
        if ((unint64_t)((char *)v599 - (char *)keys[0]) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v339 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v339 = v338;
        }
        *(void *)&valuePtr[32] = v600;
        if (v339) {
          v340 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v600, v339);
        }
        else {
          v340 = 0;
        }
        v341 = (void **)&v340[8 * v337];
        v342 = (void **)&v340[8 * v339];
        *(void *)&valuePtr[24] = v342;
        *v341 = @"CTFontPaletteAttribute";
        v336 = v341 + 1;
        *(void *)&valuePtr[16] = v341 + 1;
        v343 = keys[1];
        v344 = keys[0];
        if (keys[1] == keys[0])
        {
          int64x2_t v346 = vdupq_n_s64((unint64_t)keys[1]);
        }
        else
        {
          do
          {
            v345 = *--v343;
            *--v341 = v345;
          }
          while (v343 != v344);
          int64x2_t v346 = *(int64x2_t *)keys;
          v336 = *(void ***)&valuePtr[16];
          v342 = *(void ***)&valuePtr[24];
        }
        keys[0] = v341;
        keys[1] = v336;
        *(int64x2_t *)&valuePtr[8] = v346;
        v347 = v599;
        v599 = v342;
        *(void *)&valuePtr[24] = v347;
        *(void *)double valuePtr = v346.i64[0];
        std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)valuePtr);
      }
      else
      {
        *keys[1] = @"CTFontPaletteAttribute";
        v336 = v335 + 1;
      }
      keys[1] = v336;
      v348 = v594[1];
      if (v594[1] >= v595)
      {
        int64_t v350 = v594[1] - v594[0];
        if ((unint64_t)(v350 + 1) >> 61) {
          goto LABEL_693;
        }
        unint64_t v351 = ((char *)v595 - (char *)v594[0]) >> 2;
        if (v351 <= v350 + 1) {
          unint64_t v351 = v350 + 1;
        }
        if ((unint64_t)((char *)v595 - (char *)v594[0]) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v352 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v352 = v351;
        }
        *(void *)&valuePtr[32] = v596;
        if (v352) {
          v353 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v596, v352);
        }
        else {
          v353 = 0;
        }
        v354 = (void **)&v353[8 * v350];
        v355 = (void **)&v353[8 * v352];
        *(void *)&valuePtr[24] = v355;
        *v354 = v334;
        v349 = v354 + 1;
        *(void *)&valuePtr[16] = v354 + 1;
        v356 = v594[1];
        v357 = v594[0];
        if (v594[1] == v594[0])
        {
          int64x2_t v359 = vdupq_n_s64((unint64_t)v594[1]);
        }
        else
        {
          do
          {
            v358 = *--v356;
            *--v354 = v358;
          }
          while (v356 != v357);
          int64x2_t v359 = *(int64x2_t *)v594;
          v349 = *(void ***)&valuePtr[16];
          v355 = *(void ***)&valuePtr[24];
        }
        v594[0] = v354;
        v594[1] = v349;
        *(int64x2_t *)&valuePtr[8] = v359;
        v360 = v595;
        v595 = v355;
        *(void *)&valuePtr[24] = v360;
        *(void *)double valuePtr = v359.i64[0];
        std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)valuePtr);
      }
      else
      {
        *v594[1] = v334;
        v349 = v348 + 1;
      }
      v594[1] = v349;
    }
  }
  else
  {
  }
  CFDictionaryRef v361 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)this + 20, memory_order_acquire);
  if (v361)
  {
    CFDictionaryRef v362 = v361;
    v363 = (void *)CFDictionaryGetValue(v361, @"CTFontPaletteColorsAttribute");

    if (v363)
    {
      v364 = keys[1];
      if (keys[1] >= v599)
      {
        int64_t v366 = keys[1] - keys[0];
        if ((unint64_t)(v366 + 1) >> 61) {
          goto LABEL_693;
        }
        unint64_t v367 = ((char *)v599 - (char *)keys[0]) >> 2;
        if (v367 <= v366 + 1) {
          unint64_t v367 = v366 + 1;
        }
        if ((unint64_t)((char *)v599 - (char *)keys[0]) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v368 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v368 = v367;
        }
        *(void *)&valuePtr[32] = v600;
        if (v368) {
          v369 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v600, v368);
        }
        else {
          v369 = 0;
        }
        v370 = (void **)&v369[8 * v366];
        v371 = (void **)&v369[8 * v368];
        *(void *)&valuePtr[24] = v371;
        *v370 = @"CTFontPaletteColorsAttribute";
        v365 = v370 + 1;
        *(void *)&valuePtr[16] = v370 + 1;
        v372 = keys[1];
        v373 = keys[0];
        if (keys[1] == keys[0])
        {
          int64x2_t v375 = vdupq_n_s64((unint64_t)keys[1]);
        }
        else
        {
          do
          {
            v374 = *--v372;
            *--v370 = v374;
          }
          while (v372 != v373);
          int64x2_t v375 = *(int64x2_t *)keys;
          v365 = *(void ***)&valuePtr[16];
          v371 = *(void ***)&valuePtr[24];
        }
        keys[0] = v370;
        keys[1] = v365;
        *(int64x2_t *)&valuePtr[8] = v375;
        v376 = v599;
        v599 = v371;
        *(void *)&valuePtr[24] = v376;
        *(void *)double valuePtr = v375.i64[0];
        std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)valuePtr);
      }
      else
      {
        *keys[1] = @"CTFontPaletteColorsAttribute";
        v365 = v364 + 1;
      }
      keys[1] = v365;
      v377 = v594[1];
      if (v594[1] >= v595)
      {
        int64_t v379 = v594[1] - v594[0];
        if ((unint64_t)(v379 + 1) >> 61) {
          goto LABEL_693;
        }
        unint64_t v380 = ((char *)v595 - (char *)v594[0]) >> 2;
        if (v380 <= v379 + 1) {
          unint64_t v380 = v379 + 1;
        }
        if ((unint64_t)((char *)v595 - (char *)v594[0]) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v381 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v381 = v380;
        }
        *(void *)&valuePtr[32] = v596;
        if (v381) {
          v382 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v596, v381);
        }
        else {
          v382 = 0;
        }
        v383 = (void **)&v382[8 * v379];
        v384 = (void **)&v382[8 * v381];
        *(void *)&valuePtr[24] = v384;
        *v383 = v363;
        v378 = v383 + 1;
        *(void *)&valuePtr[16] = v383 + 1;
        v385 = v594[1];
        v386 = v594[0];
        if (v594[1] == v594[0])
        {
          int64x2_t v388 = vdupq_n_s64((unint64_t)v594[1]);
        }
        else
        {
          do
          {
            v387 = *--v385;
            *--v383 = v387;
          }
          while (v385 != v386);
          int64x2_t v388 = *(int64x2_t *)v594;
          v378 = *(void ***)&valuePtr[16];
          v384 = *(void ***)&valuePtr[24];
        }
        v594[0] = v383;
        v594[1] = v378;
        *(int64x2_t *)&valuePtr[8] = v388;
        v389 = v595;
        v595 = v384;
        *(void *)&valuePtr[24] = v389;
        *(void *)double valuePtr = v388.i64[0];
        std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)valuePtr);
      }
      else
      {
        *v594[1] = v363;
        v378 = v377 + 1;
      }
      v594[1] = v378;
    }
  }
  else
  {
  }
  CFDictionaryRef v390 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)this + 20, memory_order_acquire);
  if (v390)
  {
    CFDictionaryRef v391 = v390;
    v392 = (void *)CFDictionaryGetValue(v390, @"NSCTFontVariationAttribute");

    if (v392)
    {
      v393 = keys[1];
      if (keys[1] >= v599)
      {
        int64_t v395 = keys[1] - keys[0];
        if ((unint64_t)(v395 + 1) >> 61) {
          goto LABEL_693;
        }
        unint64_t v396 = ((char *)v599 - (char *)keys[0]) >> 2;
        if (v396 <= v395 + 1) {
          unint64_t v396 = v395 + 1;
        }
        if ((unint64_t)((char *)v599 - (char *)keys[0]) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v397 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v397 = v396;
        }
        *(void *)&valuePtr[32] = v600;
        if (v397) {
          v398 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v600, v397);
        }
        else {
          v398 = 0;
        }
        v399 = (void **)&v398[8 * v395];
        v400 = (void **)&v398[8 * v397];
        *(void *)&valuePtr[24] = v400;
        *v399 = @"NSCTFontVariationAttribute";
        v394 = v399 + 1;
        *(void *)&valuePtr[16] = v399 + 1;
        v401 = keys[1];
        v402 = keys[0];
        if (keys[1] == keys[0])
        {
          int64x2_t v404 = vdupq_n_s64((unint64_t)keys[1]);
        }
        else
        {
          do
          {
            v403 = *--v401;
            *--v399 = v403;
          }
          while (v401 != v402);
          int64x2_t v404 = *(int64x2_t *)keys;
          v394 = *(void ***)&valuePtr[16];
          v400 = *(void ***)&valuePtr[24];
        }
        keys[0] = v399;
        keys[1] = v394;
        *(int64x2_t *)&valuePtr[8] = v404;
        v405 = v599;
        v599 = v400;
        *(void *)&valuePtr[24] = v405;
        *(void *)double valuePtr = v404.i64[0];
        std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)valuePtr);
      }
      else
      {
        *keys[1] = @"NSCTFontVariationAttribute";
        v394 = v393 + 1;
      }
      keys[1] = v394;
      v406 = v594[1];
      if (v594[1] >= v595)
      {
        int64_t v408 = v594[1] - v594[0];
        if ((unint64_t)(v408 + 1) >> 61) {
          goto LABEL_693;
        }
        unint64_t v409 = ((char *)v595 - (char *)v594[0]) >> 2;
        if (v409 <= v408 + 1) {
          unint64_t v409 = v408 + 1;
        }
        if ((unint64_t)((char *)v595 - (char *)v594[0]) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v410 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v410 = v409;
        }
        *(void *)&valuePtr[32] = v596;
        if (v410) {
          v411 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v596, v410);
        }
        else {
          v411 = 0;
        }
        v412 = (void **)&v411[8 * v408];
        v413 = (void **)&v411[8 * v410];
        *(void *)&valuePtr[24] = v413;
        *v412 = v392;
        v407 = v412 + 1;
        *(void *)&valuePtr[16] = v412 + 1;
        v414 = v594[1];
        v415 = v594[0];
        if (v594[1] == v594[0])
        {
          int64x2_t v417 = vdupq_n_s64((unint64_t)v594[1]);
        }
        else
        {
          do
          {
            v416 = *--v414;
            *--v412 = v416;
          }
          while (v414 != v415);
          int64x2_t v417 = *(int64x2_t *)v594;
          v407 = *(void ***)&valuePtr[16];
          v413 = *(void ***)&valuePtr[24];
        }
        v594[0] = v412;
        v594[1] = v407;
        *(int64x2_t *)&valuePtr[8] = v417;
        v418 = v595;
        v595 = v413;
        *(void *)&valuePtr[24] = v418;
        *(void *)double valuePtr = v417.i64[0];
        std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)valuePtr);
      }
      else
      {
        *v594[1] = v392;
        v407 = v406 + 1;
      }
      v594[1] = v407;
    }
  }
  else
  {
  }
  CFDictionaryRef v419 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)this + 20, memory_order_acquire);
  if (v419)
  {
    CFDictionaryRef v420 = v419;
    v421 = (void *)CFDictionaryGetValue(v419, @"CTFontEmojiMLUpscalingTimeoutAttribute");

    if (v421)
    {
      v422 = keys[1];
      if (keys[1] >= v599)
      {
        int64_t v424 = keys[1] - keys[0];
        if ((unint64_t)(v424 + 1) >> 61) {
          goto LABEL_693;
        }
        unint64_t v425 = ((char *)v599 - (char *)keys[0]) >> 2;
        if (v425 <= v424 + 1) {
          unint64_t v425 = v424 + 1;
        }
        if ((unint64_t)((char *)v599 - (char *)keys[0]) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v426 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v426 = v425;
        }
        *(void *)&valuePtr[32] = v600;
        if (v426) {
          v427 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v600, v426);
        }
        else {
          v427 = 0;
        }
        v428 = (void **)&v427[8 * v424];
        v429 = (void **)&v427[8 * v426];
        *(void *)&valuePtr[24] = v429;
        *v428 = @"CTFontEmojiMLUpscalingTimeoutAttribute";
        v423 = v428 + 1;
        *(void *)&valuePtr[16] = v428 + 1;
        v430 = keys[1];
        v431 = keys[0];
        if (keys[1] == keys[0])
        {
          int64x2_t v433 = vdupq_n_s64((unint64_t)keys[1]);
        }
        else
        {
          do
          {
            v432 = *--v430;
            *--v428 = v432;
          }
          while (v430 != v431);
          int64x2_t v433 = *(int64x2_t *)keys;
          v423 = *(void ***)&valuePtr[16];
          v429 = *(void ***)&valuePtr[24];
        }
        keys[0] = v428;
        keys[1] = v423;
        *(int64x2_t *)&valuePtr[8] = v433;
        v434 = v599;
        v599 = v429;
        *(void *)&valuePtr[24] = v434;
        *(void *)double valuePtr = v433.i64[0];
        std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)valuePtr);
      }
      else
      {
        *keys[1] = @"CTFontEmojiMLUpscalingTimeoutAttribute";
        v423 = v422 + 1;
      }
      keys[1] = v423;
      v435 = v594[1];
      if (v594[1] >= v595)
      {
        int64_t v437 = v594[1] - v594[0];
        if ((unint64_t)(v437 + 1) >> 61) {
          goto LABEL_693;
        }
        unint64_t v438 = ((char *)v595 - (char *)v594[0]) >> 2;
        if (v438 <= v437 + 1) {
          unint64_t v438 = v437 + 1;
        }
        if ((unint64_t)((char *)v595 - (char *)v594[0]) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v439 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v439 = v438;
        }
        *(void *)&valuePtr[32] = v596;
        if (v439) {
          v440 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v596, v439);
        }
        else {
          v440 = 0;
        }
        v441 = (void **)&v440[8 * v437];
        v442 = (void **)&v440[8 * v439];
        *(void *)&valuePtr[24] = v442;
        *v441 = v421;
        v436 = v441 + 1;
        *(void *)&valuePtr[16] = v441 + 1;
        v443 = v594[1];
        v444 = v594[0];
        if (v594[1] == v594[0])
        {
          int64x2_t v446 = vdupq_n_s64((unint64_t)v594[1]);
        }
        else
        {
          do
          {
            v445 = *--v443;
            *--v441 = v445;
          }
          while (v443 != v444);
          int64x2_t v446 = *(int64x2_t *)v594;
          v436 = *(void ***)&valuePtr[16];
          v442 = *(void ***)&valuePtr[24];
        }
        v594[0] = v441;
        v594[1] = v436;
        *(int64x2_t *)&valuePtr[8] = v446;
        v447 = v595;
        v595 = v442;
        *(void *)&valuePtr[24] = v447;
        *(void *)double valuePtr = v446.i64[0];
        std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)valuePtr);
      }
      else
      {
        *v594[1] = v421;
        v436 = v435 + 1;
      }
      v594[1] = v436;
    }
  }
  else
  {
  }
LABEL_555:
  unsigned int v448 = *(_DWORD *)this;
  if (*(_DWORD *)this)
  {
    *(_DWORD *)double valuePtr = 2;
    CFNumberRef v449 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, valuePtr);
    v450 = keys[1];
    if (keys[1] >= v599)
    {
      int64_t v452 = keys[1] - keys[0];
      if ((unint64_t)(v452 + 1) >> 61) {
        goto LABEL_693;
      }
      unint64_t v453 = ((char *)v599 - (char *)keys[0]) >> 2;
      if (v453 <= v452 + 1) {
        unint64_t v453 = v452 + 1;
      }
      if ((unint64_t)((char *)v599 - (char *)keys[0]) >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v454 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v454 = v453;
      }
      *(void *)&valuePtr[32] = v600;
      if (v454) {
        v455 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v600, v454);
      }
      else {
        v455 = 0;
      }
      v456 = (void **)&v455[8 * v452];
      v457 = (void **)&v455[8 * v454];
      *(void *)&valuePtr[24] = v457;
      *v456 = @"NSCTFontOrientationAttribute";
      v451 = v456 + 1;
      *(void *)&valuePtr[16] = v456 + 1;
      v458 = keys[1];
      v459 = keys[0];
      if (keys[1] == keys[0])
      {
        int64x2_t v461 = vdupq_n_s64((unint64_t)keys[1]);
      }
      else
      {
        do
        {
          v460 = *--v458;
          *--v456 = v460;
        }
        while (v458 != v459);
        int64x2_t v461 = *(int64x2_t *)keys;
        v451 = *(void ***)&valuePtr[16];
        v457 = *(void ***)&valuePtr[24];
      }
      keys[0] = v456;
      keys[1] = v451;
      *(int64x2_t *)&valuePtr[8] = v461;
      v462 = v599;
      v599 = v457;
      *(void *)&valuePtr[24] = v462;
      *(void *)double valuePtr = v461.i64[0];
      std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)valuePtr);
    }
    else
    {
      *keys[1] = @"NSCTFontOrientationAttribute";
      v451 = v450 + 1;
    }
    keys[1] = v451;
    v463 = v594[1];
    if (v594[1] >= v595)
    {
      int64_t v465 = v594[1] - v594[0];
      if ((unint64_t)(v465 + 1) >> 61) {
        goto LABEL_693;
      }
      unint64_t v466 = ((char *)v595 - (char *)v594[0]) >> 2;
      if (v466 <= v465 + 1) {
        unint64_t v466 = v465 + 1;
      }
      if ((unint64_t)((char *)v595 - (char *)v594[0]) >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v467 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v467 = v466;
      }
      *(void *)&valuePtr[32] = v596;
      if (v467) {
        v468 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v596, v467);
      }
      else {
        v468 = 0;
      }
      v469 = (void **)&v468[8 * v465];
      v470 = (void **)&v468[8 * v467];
      *(void *)&valuePtr[24] = v470;
      *v469 = v449;
      v464 = v469 + 1;
      *(void *)&valuePtr[16] = v469 + 1;
      v471 = v594[1];
      v472 = v594[0];
      if (v594[1] == v594[0])
      {
        int64x2_t v474 = vdupq_n_s64((unint64_t)v594[1]);
      }
      else
      {
        do
        {
          v473 = *--v471;
          *--v469 = v473;
        }
        while (v471 != v472);
        int64x2_t v474 = *(int64x2_t *)v594;
        v464 = *(void ***)&valuePtr[16];
        v470 = *(void ***)&valuePtr[24];
      }
      v594[0] = v469;
      v594[1] = v464;
      *(int64x2_t *)&valuePtr[8] = v474;
      v475 = v595;
      v595 = v470;
      *(void *)&valuePtr[24] = v475;
      *(void *)double valuePtr = v474.i64[0];
      std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)valuePtr);
    }
    else
    {
      *v594[1] = v449;
      v464 = v463 + 1;
    }
    v594[1] = v464;

    unsigned int v448 = *(_DWORD *)this;
  }
  uint64_t v476 = (v448 >> 6) & 7;
  if (v476 != 3)
  {
    *(void *)double valuePtr = v476;
    CFNumberRef v477 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberLongType, valuePtr);
    v478 = keys[1];
    if (keys[1] >= v599)
    {
      int64_t v480 = keys[1] - keys[0];
      if ((unint64_t)(v480 + 1) >> 61) {
        goto LABEL_693;
      }
      unint64_t v481 = ((char *)v599 - (char *)keys[0]) >> 2;
      if (v481 <= v480 + 1) {
        unint64_t v481 = v480 + 1;
      }
      if ((unint64_t)((char *)v599 - (char *)keys[0]) >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v482 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v482 = v481;
      }
      *(void *)&valuePtr[32] = v600;
      if (v482) {
        v483 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v600, v482);
      }
      else {
        v483 = 0;
      }
      v484 = (void **)&v483[8 * v480];
      v485 = (void **)&v483[8 * v482];
      *(void *)&valuePtr[24] = v485;
      *v484 = @"NSCTFontFallbackOptionAttribute";
      v479 = v484 + 1;
      *(void *)&valuePtr[16] = v484 + 1;
      v486 = keys[1];
      v487 = keys[0];
      if (keys[1] == keys[0])
      {
        int64x2_t v489 = vdupq_n_s64((unint64_t)keys[1]);
      }
      else
      {
        do
        {
          v488 = *--v486;
          *--v484 = v488;
        }
        while (v486 != v487);
        int64x2_t v489 = *(int64x2_t *)keys;
        v479 = *(void ***)&valuePtr[16];
        v485 = *(void ***)&valuePtr[24];
      }
      keys[0] = v484;
      keys[1] = v479;
      *(int64x2_t *)&valuePtr[8] = v489;
      v490 = v599;
      v599 = v485;
      *(void *)&valuePtr[24] = v490;
      *(void *)double valuePtr = v489.i64[0];
      std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)valuePtr);
    }
    else
    {
      *keys[1] = @"NSCTFontFallbackOptionAttribute";
      v479 = v478 + 1;
    }
    keys[1] = v479;
    v491 = v594[1];
    if (v594[1] < v595)
    {
      *v594[1] = v477;
      v492 = v491 + 1;
LABEL_622:
      v594[1] = v492;

      goto LABEL_623;
    }
    int64_t v493 = v594[1] - v594[0];
    if (!((unint64_t)(v493 + 1) >> 61))
    {
      unint64_t v494 = ((char *)v595 - (char *)v594[0]) >> 2;
      if (v494 <= v493 + 1) {
        unint64_t v494 = v493 + 1;
      }
      if ((unint64_t)((char *)v595 - (char *)v594[0]) >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v495 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v495 = v494;
      }
      *(void *)&valuePtr[32] = v596;
      if (v495) {
        v496 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v596, v495);
      }
      else {
        v496 = 0;
      }
      v497 = (void **)&v496[8 * v493];
      v498 = (void **)&v496[8 * v495];
      *(void *)&valuePtr[24] = v498;
      *v497 = v477;
      v492 = v497 + 1;
      *(void *)&valuePtr[16] = v497 + 1;
      v499 = v594[1];
      v500 = v594[0];
      if (v594[1] == v594[0])
      {
        int64x2_t v502 = vdupq_n_s64((unint64_t)v594[1]);
      }
      else
      {
        do
        {
          v501 = *--v499;
          *--v497 = v501;
        }
        while (v499 != v500);
        int64x2_t v502 = *(int64x2_t *)v594;
        v492 = *(void ***)&valuePtr[16];
        v498 = *(void ***)&valuePtr[24];
      }
      v594[0] = v497;
      v594[1] = v492;
      *(int64x2_t *)&valuePtr[8] = v502;
      v503 = v595;
      v595 = v498;
      *(void *)&valuePtr[24] = v503;
      *(void *)double valuePtr = v502.i64[0];
      std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)valuePtr);
      goto LABEL_622;
    }
LABEL_693:
    abort();
  }
LABEL_623:
  if (keys[0] == keys[1])
  {
    TCFRef<__CTFont const*>::Retain(a3, (id)atomic_load_explicit((atomic_ullong *volatile)this + 1, memory_order_acquire));
  }
  else
  {
    if ((void **)((char *)keys[1] - (char *)keys[0]) == (void **)8)
    {
      v504 = (void *)atomic_load_explicit((atomic_ullong *volatile)this + 1, memory_order_acquire);
      if (dispatch_get_specific((const void *)TDescriptorSource::DoNotCacheKey))
      {
        v505 = 0;
      }
      else
      {
        v506 = *v594[0];
        v507 = *keys[0];
        *(void *)&long long v508 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v508 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)&valuePtr[16] = v508;
        *(_OWORD *)&valuePtr[32] = v508;
        *(_OWORD *)double valuePtr = v508;
        v509 = 0;
        v510 = values;
        v511 = values + 1;
        v512 = values + 3;
        v513 = values + 1;
        while (1)
        {
          v514 = *v513;
          v515 = &v512[6 * (void)*v513];
          v516 = (const void *)atomic_load_explicit((atomic_ullong *volatile)v515 + 2, memory_order_acquire);
          v517 = (const void *)atomic_load_explicit((atomic_ullong *volatile)&valuePtr[16], memory_order_acquire);
          if (v516 == v517 || (v516 ? (BOOL v518 = v517 == 0) : (BOOL v518 = 1), !v518 && CFEqual(v516, v517)))
          {
            v519 = (const void *)atomic_load_explicit((atomic_ullong *volatile)&v512[6 * (void)v514 + 3], memory_order_acquire);
            v520 = (const void *)atomic_load_explicit((atomic_ullong *volatile)&valuePtr[24], memory_order_acquire);
            if (v519 == v520 || (v519 ? (BOOL v521 = v520 == 0) : (BOOL v521 = 1), !v521 && CFEqual(v519, v520)))
            {
              v522 = (const void *)atomic_load_explicit((atomic_ullong *volatile)&v512[6 * (void)v514 + 4], memory_order_acquire);
              v523 = (const void *)atomic_load_explicit((atomic_ullong *volatile)&valuePtr[32], memory_order_acquire);
              if (v522 == v523) {
                break;
              }
              BOOL v524 = !v522 || v523 == 0;
              if (!v524 && CFEqual(v522, v523)) {
                break;
              }
            }
          }
          if (v514 == v510[2])
          {
            v505 = 0;
            goto LABEL_655;
          }
          v513 = v515 + 1;
          v509 = v514;
        }
        v525 = *v511;
        if (v514 != *v511)
        {
          v512[6 * (void)v509 + 1] = v515[1];
          v526 = v510[2];
          if (v514 == v526)
          {
            v510[2] = v509;
            v526 = v509;
          }
          v515[1] = v525;
          *v511 = v514;
          v512[6 * (void)v526 + 1] = v514;
        }
        v505 = (void *)atomic_load_explicit((atomic_ullong *volatile)&v512[6 * (void)v514 + 5], memory_order_acquire);
LABEL_655:
        *(void *)double valuePtr = &unk_1ED05F890;
      }
      TCFRef<__CTFont const*>::Retain(a3, v505);
    }
    if (!atomic_load_explicit(a3, memory_order_acquire))
    {
      CFDictionaryRef v527 = v7;
      if (v527)
      {
        CFDictionaryRef v528 = v527;
        CFIndex Count = CFDictionaryGetCount(v527);

        if (Count)
        {
          *(void *)&long long v530 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v530 + 1) = 0xAAAAAAAAAAAAAAAALL;
          long long v592 = v530;
          long long v591 = v530;
          long long v590 = v530;
          long long v589 = v530;
          long long v588 = v530;
          long long v587 = v530;
          long long v586 = v530;
          long long v585 = v530;
          long long v584 = v530;
          long long v583 = v530;
          long long v582 = v530;
          long long v581 = v530;
          long long v580 = v530;
          *(_OWORD *)&valuePtr[40] = v530;
          *(_OWORD *)&valuePtr[24] = v530;
          memset(valuePtr, 0, 24);
          v593 = &valuePtr[24];
          std::vector<long,TInlineBufferAllocator<long,30ul>>::__vallocate[abi:nn180100](valuePtr, Count);
          uint64_t v531 = *(void *)&valuePtr[8];
          bzero(*(void **)&valuePtr[8], 8 * Count);
          *(void *)&valuePtr[8] = v531 + 8 * Count;
          *(void *)&long long v532 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v532 + 1) = 0xAAAAAAAAAAAAAAAALL;
          v577[14] = v532;
          v577[13] = v532;
          v577[12] = v532;
          v577[11] = v532;
          v577[10] = v532;
          v577[9] = v532;
          v577[8] = v532;
          v577[7] = v532;
          v577[6] = v532;
          v577[5] = v532;
          v577[4] = v532;
          v577[3] = v532;
          v577[2] = v532;
          v577[1] = v532;
          v577[0] = v532;
          v575 = 0;
          uint64_t v576 = 0;
          id values = 0;
          v578 = v577;
          std::vector<long,TInlineBufferAllocator<long,30ul>>::__vallocate[abi:nn180100](&values, Count);
          v533 = (char *)v575;
          bzero(v575, 8 * Count);
          v575 = &v533[8 * Count];
          CFDictionaryGetKeysAndValues(v7, *(const void ***)valuePtr, (const void **)values);
          std::vector<void const*,TInlineBufferAllocator<void const*,30ul>>::__insert_with_size[abi:nn180100]<std::__wrap_iter<void const**>,std::__wrap_iter<void const**>>((char **)keys, (uint64_t)keys[1], *(char **)valuePtr, *(char **)&valuePtr[8], (uint64_t)(*(void *)&valuePtr[8] - *(void *)valuePtr) >> 3);
          std::vector<void const*,TInlineBufferAllocator<void const*,30ul>>::__insert_with_size[abi:nn180100]<std::__wrap_iter<void const**>,std::__wrap_iter<void const**>>((char **)v594, (uint64_t)v594[1], (char *)values, (char *)v575, ((unsigned char *)v575 - (unsigned char *)values) >> 3);
          p_id values = &values;
          std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&p_values);
          id values = (void **)valuePtr;
          std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](&values);
        }
      }
      else
      {
      }
      CFDictionaryRef v534 = v7;
      if (v534)
      {
        CFDictionaryRef v535 = v534;
        v536 = CFDictionaryGetValue(v534, @"NSCTFontUIUsageAttribute");

        if (v536)
        {
          v537 = keys[1];
          v538 = keys[0];
          if (keys[1] != keys[0])
          {
            unint64_t v539 = 0;
            unint64_t v540 = 1;
            while (1)
            {
              v541 = (__CFString *)v538[v540 - 1];
              if (v541 == @"NSFontNameAttribute") {
                break;
              }
              if (@"NSFontNameAttribute")
              {
                if (v541)
                {
                  int v542 = CFEqual(v541, @"NSFontNameAttribute");
                  v538 = keys[0];
                  v537 = keys[1];
                  if (v542) {
                    break;
                  }
                }
              }
              ++v539;
              ++v540;
              if (v539 >= v537 - v538) {
                goto LABEL_678;
              }
            }
            v543 = &v538[v540];
            unint64_t v544 = (char *)v537 - (char *)v538 - v540 * 8;
            if (&v538[v540] != v537) {
              memmove(v543 - 1, &v538[v540], (char *)v537 - (char *)v538 - v540 * 8);
            }
            keys[1] = (void **)((char *)v543 + (v544 & 0xFFFFFFFFFFFFFFF8) - 8);
            v545 = &v594[0][v540];
            unint64_t v546 = (char *)v594[1] - (char *)v594[0] - v540 * 8;
            if (&v594[0][v540] != v594[1]) {
              memmove(v545 - 1, &v594[0][v540], (char *)v594[1] - (char *)v594[0] - v540 * 8);
            }
            v594[1] = (void **)((char *)v545 + (v546 & 0xFFFFFFFFFFFFFFF8) - 8);
          }
        }
      }
      else
      {
      }
LABEL_678:
      CFDictionaryRef v547 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)keys[0], (const void **)v594[0], keys[1] - keys[0], MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      unint64_t v548 = atomic_load_explicit((atomic_ullong *volatile)this + 1, memory_order_acquire);
      v549 = (atomic_uint *)*((void *)this + 50);
      uint64_t v550 = TCFBase<TDescriptor>::Allocate();
      if (v550)
      {
        v551 = (void *)v550;
        v552 = (TDescriptor *)(v550 + 48);
        v551[2] = 0;
        v551[3] = TDescriptor::Hash;
        v551[4] = 0;
        v551[5] = v552;
        TDescriptor::TDescriptor(v552, *(const TDescriptor **)(v548 + 40), v549, v547);
        *(void *)double valuePtr = v551;
        id values = (void **)atomic_exchange((atomic_ullong *volatile)valuePtr, 0);
      }
      else
      {
        id values = 0;
      }

      if (atomic_load_explicit(a3, memory_order_acquire))
      {
        if ((void **)((char *)keys[1] - (char *)keys[0]) == (void **)8)
        {
          v553 = (void *)atomic_load_explicit((atomic_ullong *volatile)this + 1, memory_order_acquire);
          v554 = *keys[0];
          v555 = *v594[0];
          v556 = (const __CTFontDescriptor *)atomic_load_explicit(a3, memory_order_acquire);
          if (!dispatch_get_specific((const void *)TDescriptorSource::DoNotCacheKey))
          {
            *(void *)&long long v557 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v557 + 1) = 0xAAAAAAAAAAAAAAAALL;
            *(_OWORD *)&valuePtr[16] = v557;
            *(_OWORD *)&valuePtr[32] = v557;
            *(_OWORD *)double valuePtr = v557;
            v558 = values;
            v559 = values[2];
            v560 = values + 3;
            v562 = v558[1];
            do
            {
              v563 = v562;
              v564 = &v560[6 * (void)v562];
              v566 = v564[1];
              v565 = v564 + 1;
              v562 = v566;
            }
            while (v566 != v558[2]);
            v561[1] = (atomic_ullong)v558[1];
            v558[1] = v559;
            v558[2] = v563;
            void *v565 = v559;
            *(void *)double valuePtr = &unk_1ED05F890;
          }
        }
      }
    }
  }
  *(void *)double valuePtr = 0xAAAAAAAAAAAAAAAALL;
  id v567 = (id)atomic_load_explicit(a3, memory_order_acquire);
  uint64_t v568 = 0;
  *(void *)double valuePtr = v567;
  unint64_t v569 = atomic_exchange((atomic_ullong *volatile)valuePtr, 0);
  atomic_compare_exchange_strong(v571, (unint64_t *)&v568, v569);
  if (v568) {
    v570 = (void *)v569;
  }
  else {
    v570 = 0;
  }

  *(void *)double valuePtr = v594;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)valuePtr);
  v594[0] = (void **)keys;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](v594);
}

char **std::vector<void const*,TInlineBufferAllocator<void const*,30ul>>::__insert_with_size[abi:nn180100]<std::__wrap_iter<void const**>,std::__wrap_iter<void const**>>(char **result, uint64_t a2, char *__src, char *a4, uint64_t a5)
{
  if (a5 < 1) {
    return result;
  }
  long long v6 = __src;
  CFDictionaryRef v7 = result;
  long long v8 = *result;
  unint64_t v9 = (unint64_t)result[1];
  uint64_t v10 = a2 - (void)*result;
  CFTypeID v11 = &(*result)[v10 & 0xFFFFFFFFFFFFFFF8];
  uint64_t v12 = result[2];
  if (a5 > (uint64_t)&v12[-v9] >> 3)
  {
    CFDictionaryRef v40 = 0;
    CFDictionaryRef v41 = 0;
    unint64_t v13 = a5 + ((uint64_t)(v9 - (void)v8) >> 3);
    if (v13 >> 61) {
      abort();
    }
    uint64_t v14 = v10 >> 3;
    uint64_t v15 = (uint64_t)(result + 3);
    uint64_t v16 = v12 - v8;
    uint64_t v17 = v16 >> 2;
    if (v16 >> 2 <= v13) {
      uint64_t v17 = v13;
    }
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v18 = v17;
    }
    double v44 = v7 + 3;
    if (v18) {
      id v19 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate(v15, v18);
    }
    else {
      id v19 = 0;
    }
    uint64_t v28 = &v19[8 * v14];
    double v43 = &v19[8 * v18];
    uint64_t v29 = 8 * a5;
    unint64_t v30 = v28;
    unint64_t v31 = &v28[8 * a5];
    do
    {
      uint64_t v32 = *(void *)v6;
      v6 += 8;
      *(void *)unint64_t v30 = v32;
      v30 += 8;
      v29 -= 8;
    }
    while (v29);
    CFDataRef v42 = v31;
    double v33 = *v7;
    if (*v7 != v11)
    {
      double v34 = v11;
      do
      {
        uint64_t v35 = *((void *)v34 - 1);
        v34 -= 8;
        *((void *)v28 - 1) = v35;
        v28 -= 8;
      }
      while (v34 != v33);
      unint64_t v31 = v42;
    }
    double v36 = v7[1];
    uint64_t v37 = v36 - v11;
    if (v36 != v11)
    {
      memmove(v31, v11, v36 - v11);
      CFTypeID v11 = v7[1];
    }
    int64x2_t v38 = *v7;
    *CFDictionaryRef v7 = v28;
    v7[1] = &v31[v37];
    double v39 = v7[2];
    void v7[2] = v43;
    CFDataRef v42 = v11;
    double v43 = v39;
    CFDictionaryRef v40 = v38;
    CFDictionaryRef v41 = v38;
    return (char **)std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v40);
  }
  uint64_t v20 = (uint64_t)(v9 - (void)v11) >> 3;
  if (v20 >= a5)
  {
    uint64_t v21 = &__src[8 * a5];
    int64x2_t v23 = result[1];
LABEL_17:
    CFTypeID v24 = &v11[8 * a5];
    unint64_t v25 = (uint64_t *)&v23[-8 * a5];
    double v26 = v23;
    if ((unint64_t)v25 < v9)
    {
      double v26 = v23;
      do
      {
        uint64_t v27 = *v25++;
        *(void *)double v26 = v27;
        v26 += 8;
      }
      while ((unint64_t)v25 < v9);
    }
    v7[1] = v26;
    if (v23 != v24) {
      uint64_t result = (char **)memmove(&v23[-8 * ((v23 - v24) >> 3)], v11, v23 - v24);
    }
    if (v21 != v6)
    {
      return (char **)memmove(v11, v6, v21 - v6);
    }
    return result;
  }
  uint64_t v21 = &__src[8 * v20];
  int64_t v22 = a4 - v21;
  if (a4 != v21) {
    uint64_t result = (char **)memmove(result[1], &__src[8 * v20], a4 - v21);
  }
  int64x2_t v23 = (char *)(v9 + v22);
  v7[1] = (char *)(v9 + v22);
  if ((uint64_t)(v9 - (void)v11) >= 1) {
    goto LABEL_17;
  }
  return result;
}

CTFontDescriptorRef CTFontDescriptorCreateCopyWithAttributes(CTFontDescriptorRef original, CFDictionaryRef attributes)
{
  int v2 = original;
  CFDictionaryRef v7 = attributes;
  if (!original) {
    return v2;
  }
  if (attributes && CFDictionaryGetCount(attributes))
  {
    id v6 = (id)0xAAAAAAAAAAAAAAAALL;
    CFTypeID v4 = v2;
    TCFBase_NEW<CTFontDescriptor,CTFontDescriptor*,__CFDictionary const*&>((uint64_t *)&v4, &v7, &v5);
    id v6 = (id)atomic_exchange((atomic_ullong *volatile)&v5, 0);

    int v2 = (const __CTFontDescriptor *)atomic_exchange((atomic_ullong *volatile)&v6, 0);
    return v2;
  }

  return v2;
}

void TCFBase_NEW<CTFontDescriptor,CTFontDescriptor*,__CFDictionary const*&>(uint64_t *a1@<X0>, const __CFDictionary **a2@<X1>, void *a3@<X8>)
{
  uint64_t v6 = TCFBase<TDescriptor>::Allocate(96);
  if (v6)
  {
    CFDictionaryRef v7 = (void *)v6;
    uint64_t v8 = *a1;
    CFDictionaryRef v9 = *a2;
    uint64_t v10 = (TDescriptor *)(v6 + 48);
    void v7[2] = 0;
    void v7[3] = TDescriptor::Hash;
    void v7[4] = 0;
    void v7[5] = v10;
    TDescriptor::TDescriptor(v10, *(const TDescriptor **)(v8 + 40), v9);
    id v11 = v7;
    *a3 = atomic_exchange((atomic_ullong *volatile)&v11, 0);
  }
  else
  {
    *a3 = 0;
  }
}

void TDescriptor::TDescriptor(TDescriptor *this, const TDescriptor *a2, const __CFDictionary *a3)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  *(void *)this = &unk_1ED05D778;
  *((void *)this + 1) = 0;
  *((_DWORD *)this + 4) = *((_DWORD *)a2 + 4) & 0x7FFFFFFF;
  *((void *)this + 3) = 0;
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)a2 + 4, memory_order_acquire);
  if (explicit)
  {
    if ((*(_DWORD *)(explicit + 180) & 0x10000000) != 0)
    {
      unint64_t explicit = 0;
    }
    else
    {
      atomic_fetch_or_explicit((atomic_uint *volatile)this + 4, 0x80000000, memory_order_relaxed);
      atomic_fetch_add_explicit((atomic_uint *volatile)(explicit + 8), 1u, memory_order_relaxed);
    }
  }
  *((void *)this + 4) = explicit;
  *((void *)this + 5) = (id)atomic_load_explicit((atomic_ullong *volatile)a2 + 5, memory_order_acquire);
  id v46 = (id)0xAAAAAAAAAAAAAAAALL;
  TDescriptor::CopyAttributes((atomic_ullong *)a2, &v46);
  id v45 = (id)0xAAAAAAAAAAAAAAAALL;
  TCFMutableDictionary::TCFMutableDictionary((TCFMutableDictionary *)&v45, (CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v46, memory_order_acquire));
  int v7 = *((_DWORD *)a2 + 4);
  if (a3)
  {
    if (v7 < 0)
    {
      CFIndex Count = CFDictionaryGetCount(a3);
      *(void *)&long long v9 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v51[14] = v9;
      v51[13] = v9;
      v51[12] = v9;
      v51[11] = v9;
      v51[10] = v9;
      v51[9] = v9;
      v51[8] = v9;
      v51[7] = v9;
      v51[6] = v9;
      v51[5] = v9;
      v51[4] = v9;
      v51[3] = v9;
      void v51[2] = v9;
      v51[1] = v9;
      v51[0] = v9;
      CFNumberRef v49 = 0;
      uint64_t v50 = 0;
      keys = 0;
      uint64_t v52 = v51;
      if (Count)
      {
        std::vector<long,TInlineBufferAllocator<long,30ul>>::__vallocate[abi:nn180100](&keys, Count);
        uint64_t v10 = (char *)v49;
        bzero(v49, 8 * Count);
        CFNumberRef v49 = &v10[8 * Count];
        id v11 = keys;
      }
      else
      {
        id v11 = 0;
      }
      CFDictionaryGetKeysAndValues(a3, (const void **)v11, 0);
      if (qword_1EB2CE0C0 != -1) {
        dispatch_once_f(&qword_1EB2CE0C0, 0, (dispatch_function_t)TDescriptor::TDescriptor(TDescriptor const&,__CFDictionary const*)::$_0::__invoke);
      }
      if (Count < 1)
      {
LABEL_15:
        unint64_t v13 = atomic_load_explicit((atomic_ullong *volatile)a2 + 4, memory_order_acquire);
        if (v13) {
          atomic_fetch_add_explicit((atomic_uint *volatile)(v13 + 8), 1u, memory_order_relaxed);
        }
        __swp(v12, (unsigned int *)this + 8);
        atomic_fetch_or_explicit((atomic_uint *volatile)this + 4, 0x80000000, memory_order_relaxed);
        if (v12 && atomic_fetch_add_explicit(v12 + 2, 0xFFFFFFFF, memory_order_release) == 1)
        {
          __dmb(9u);
          (*(void (**)(atomic_uint *))(*(void *)v12 + 8))(v12);
        }
      }
      else
      {
        while (1)
        {
          uint64_t v12 = (atomic_uint *)CFSetContainsValue((CFSetRef)qword_1EB2CE0B8, *v11);
          if (!v12) {
            break;
          }
          ++v11;
          if (!--Count) {
            goto LABEL_15;
          }
        }
      }
      atomic_fetch_or_explicit((atomic_uint *volatile)this + 4, 0x10000u, memory_order_relaxed);
      p_keys = &keys;
      std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&p_keys);
    }
    if ((*((_DWORD *)this + 4) & 0x80000000) != 0)
    {
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(a3, @"NSCTFontTraitsAttribute");
      if (Value)
      {
        CFDictionaryRef v24 = Value;
        CFTypeID v25 = CFGetTypeID(Value);
        if (v25 == CFDictionaryGetTypeID())
        {
          double v26 = (atomic_uint *)CFDictionaryContainsKey(v24, @"NSCTFontGradeTrait");
          if (v26) {
            goto LABEL_47;
          }
          if (CFDictionaryContainsKey(v24, @"NSCTFontUIFontDesignTrait"))
          {
            uint64_t v28 = (atomic_uint *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v45, memory_order_acquire), @"NSCTFontUIFontDesignTrait");
            double v26 = (atomic_uint *)CFDictionaryGetValue(v24, @"NSCTFontUIFontDesignTrait");
            if (v28 != v26)
            {
              if (!v28) {
                goto LABEL_47;
              }
              uint64_t v27 = v26;
              if (!v26) {
                goto LABEL_47;
              }
              double v26 = (atomic_uint *)CFEqual(v28, v26);
              if (!v26) {
                goto LABEL_47;
              }
            }
          }
        }
      }
      double v26 = (atomic_uint *)CFDictionaryContainsKey(a3, @"CTFontLanguageAwareLineHeightRatioAttribute");
      if (v26) {
        goto LABEL_47;
      }
      double v26 = (atomic_uint *)CFDictionaryContainsKey(a3, @"CTFontLineSpacingOverrideAttribute");
      if (v26) {
        goto LABEL_47;
      }
      double v26 = (atomic_uint *)CFDictionaryContainsKey(a3, @"CTFontLegibilityWeightAttribute");
      if (v26) {
        goto LABEL_47;
      }
      double v26 = (atomic_uint *)CFDictionaryContainsKey(a3, @"CTFontIgnoreLegibilityWeightAttribute");
      if (v26) {
        goto LABEL_47;
      }
      if ((*((_DWORD *)a2 + 4) & 0x80000000) == 0) {
        TDescriptor::InitBaseFont(a2, 0, 0.0);
      }
      unint64_t v44 = atomic_load_explicit((atomic_ullong *volatile)a2 + 4, memory_order_acquire);
      if (v44)
      {
        if ((*(unsigned int (**)(unint64_t))(*(void *)v44 + 840))(v44))
        {
          double v26 = (atomic_uint *)CFDictionaryContainsKey(a3, @"NSFontSizeAttribute");
          if (v26
            || (double v26 = (atomic_uint *)CFDictionaryContainsKey(a3, @"NSCTFontOpticalSizeAttribute"), v26))
          {
LABEL_47:
            atomic_fetch_and_explicit((atomic_uint *volatile)this + 4, 0x7FFFFFFFu, memory_order_relaxed);
            __swp(v26, (unsigned int *)this + 8);
            if (v26 && atomic_fetch_add_explicit(v26 + 2, 0xFFFFFFFF, memory_order_release) == 1)
            {
              __dmb(9u);
              (*(void (**)(atomic_uint *, atomic_uint *))(*(void *)v26 + 8))(v26, v27);
            }
          }
        }
      }
    }
    TCFMutableDictionary::SetPairs((atomic_ullong *)&v45, a3);
    CFDictionaryRef v14 = (const __CFDictionary *)CFDictionaryGetValue(a3, @"NSCTFontVariationAttribute");
    if (!v14) {
      goto LABEL_54;
    }
    CFDictionaryRef v15 = v14;
    CFTypeID v16 = CFGetTypeID(v14);
    if (v16 != CFDictionaryGetTypeID()) {
      goto LABEL_54;
    }
    if ((*((_DWORD *)a2 + 4) & 0x80000000) == 0) {
      TDescriptor::InitBaseFont(a2, 0, 0.0);
    }
    uint64_t v17 = (const TBaseFont *)atomic_load_explicit((atomic_ullong *volatile)a2 + 4, memory_order_acquire);
    if (!v17) {
      goto LABEL_54;
    }
    if ((v7 & 0x80000000) == 0) {
      atomic_fetch_or((atomic_uint *volatile)this + 4, *((_DWORD *)a2 + 4) & 0x7FFFFFFF);
    }
    unint64_t v18 = CFDictionaryGetValue(v15, &unk_1ED080880);
    if (!v18)
    {
LABEL_53:
      TDescriptor::MergeVariationWithBase(this, v17, v15, (atomic_ullong *)&v45);
LABEL_54:
      CFArrayRef v29 = (const __CFArray *)CFDictionaryGetValue(a3, @"NSCTFontFeatureSettingsAttribute");
      if (v29)
      {
        CFArrayRef v30 = v29;
        CFTypeID v31 = CFGetTypeID(v29);
        if (v31 == CFArrayGetTypeID())
        {
          CFDictionaryRef v32 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)&v46, memory_order_acquire);
          CFDictionaryRef v33 = v32;
          if (v32) {
            CFArrayRef v34 = (const __CFArray *)CFDictionaryGetValue(v32, @"NSCTFontFeatureSettingsAttribute");
          }
          else {
            CFArrayRef v34 = 0;
          }

          keys = (void **)0xAAAAAAAAAAAAAAAALL;
          TCFMutableArray::TCFMutableArray((TCFMutableArray *)&keys, v34);
          uint64_t v35 = (__CFArray *)atomic_load_explicit((atomic_ullong *volatile)&keys, memory_order_acquire);
          v54.CFIndex length = CFArrayGetCount(v30);
          v54.CFIndex location = 0;
          CFArrayAppendArray(v35, v30, v54);
          CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v45, memory_order_acquire), @"NSCTFontFeatureSettingsAttribute", (const void *)atomic_load_explicit((atomic_ullong *volatile)&keys, memory_order_acquire));
        }
        else
        {
          CFDictionaryRemoveValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v45, memory_order_acquire), @"NSCTFontFeatureSettingsAttribute");
        }
      }
      CFDictionaryRef v36 = (const __CFDictionary *)CFDictionaryGetValue(a3, @"NSCTFontTraitsAttribute");
      if (v36)
      {
        CFDictionaryRef v37 = v36;
        CFTypeID v38 = CFGetTypeID(v36);
        if (v38 == CFDictionaryGetTypeID())
        {
          if ((*((_DWORD *)a2 + 4) & 0x80000000) == 0) {
            TDescriptor::InitBaseFont(a2, 0, 0.0);
          }
          double v39 = (TBaseFont *)atomic_load_explicit((atomic_ullong *volatile)a2 + 4, memory_order_acquire);
          if (v39)
          {
            CFDictionaryRef v40 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)&v46, memory_order_acquire);
            CFDictionaryRef v41 = v40;
            if (v40) {
              CFDictionaryRef v42 = (const __CFDictionary *)CFDictionaryGetValue(v40, @"NSCTFontTraitsAttribute");
            }
            else {
              CFDictionaryRef v42 = 0;
            }

            if ((((*(uint64_t (**)(TBaseFont *))(*(void *)v39 + 856))(v39) & 1) != 0
               || (*(uint64_t (**)(TBaseFont *))(*(void *)v39 + 536))(v39))
              && v42
              && CFDictionaryGetCount(v42))
            {
              keys = (void **)CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v42);
              TCFMutableDictionary::SetPairs((atomic_ullong *)&keys, v37);
              CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v45, memory_order_acquire), @"NSCTFontTraitsAttribute", (const void *)atomic_load_explicit((atomic_ullong *volatile)&keys, memory_order_acquire));
            }
            CFDictionaryRef SymbolicTraitsFromTraits = (uint64_t *)GetSymbolicTraitsFromTraits(v37);
            if (SymbolicTraitsFromTraits) {
              TBaseFont::SystemUIFontAttributesForSymbolicTraits(v39, (atomic_ullong *)&v45, SymbolicTraitsFromTraits, (int)SymbolicTraitsFromTraits, a2);
            }
          }
        }
        else
        {
          CFDictionaryRemoveValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v45, memory_order_acquire), @"NSCTFontTraitsAttribute");
        }
      }
      goto LABEL_77;
    }
    id v19 = v18;
    keys = (void **)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(void ***__return_ptr, const TBaseFont *))(*(void *)v17 + 112))(&keys, v17);
    CFDictionaryRef v20 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)&keys, memory_order_acquire);
    if (v20)
    {
      CFDictionaryRef v21 = v20;
      int64_t v22 = CFDictionaryGetValue(v20, &unk_1ED080880);

      if (v22 == v19 || v22 && CFEqual(v22, v19)) {
        goto LABEL_52;
      }
    }
    else
    {
    }
    atomic_fetch_and_explicit((atomic_uint *volatile)this + 4, 0xFFFF7FFF, memory_order_relaxed);
LABEL_52:

    goto LABEL_53;
  }
LABEL_77:
}

void SetValuesToDictionaryFromDictionary(__CFDictionary *,__CFDictionary const*)::$_0::__invoke(void *key, void *value, CFMutableDictionaryRef theDict)
{
  if (key)
  {
    if (value) {
      CFDictionarySetValue(theDict, key, value);
    }
  }
}

void TCFMutableArray::TCFMutableArray(TCFMutableArray *this, CFArrayRef theArray)
{
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (theArray) {
    MutableCFDictionaryRef Copy = CFArrayCreateMutableCopy(v3, 0, theArray);
  }
  else {
    MutableCFDictionaryRef Copy = CFArrayCreateMutable(v3, 0, MEMORY[0x1E4F1D510]);
  }
  *(void *)this = MutableCopy;
}

void CopyVariationAttributeForSystemFont(const __CFString *a1@<X0>, CFDictionaryRef *a2@<X8>)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  CopyAttributeForSystemFont(a1, @"NSCTFontVariationAttribute", (const __CFString **)&v27);
  id v15 = (id)atomic_exchange((atomic_ullong *volatile)&v27, 0);

  CFDictionaryRef v3 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire);
  if (!v3)
  {

    goto LABEL_8;
  }
  CFDictionaryRef v4 = v3;
  CFIndex Count = CFDictionaryGetCount(v3);

  if (!Count)
  {
LABEL_8:
    *a2 = (CFDictionaryRef)atomic_exchange((atomic_ullong *volatile)&v15, 0);
    goto LABEL_9;
  }
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v30[14] = v6;
  v30[13] = v6;
  v30[12] = v6;
  v30[11] = v6;
  v30[10] = v6;
  v30[9] = v6;
  v30[8] = v6;
  v30[7] = v6;
  v30[6] = v6;
  v30[5] = v6;
  v30[4] = v6;
  v30[3] = v6;
  _OWORD v30[2] = v6;
  v30[1] = v6;
  v30[0] = v6;
  id v27 = 0;
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  CFTypeID v31 = v30;
  std::vector<long,TInlineBufferAllocator<long,30ul>>::__vallocate[abi:nn180100](&v27, Count);
  int v7 = (char *)v28;
  bzero(v28, 8 * Count);
  uint64_t v28 = &v7[8 * Count];
  *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v25[14] = v8;
  v25[13] = v8;
  v25[12] = v8;
  v25[11] = v8;
  v25[10] = v8;
  v25[9] = v8;
  v25[8] = v8;
  v25[7] = v8;
  v25[6] = v8;
  void v25[5] = v8;
  v25[4] = v8;
  v25[3] = v8;
  v25[2] = v8;
  v25[1] = v8;
  v25[0] = v8;
  id values = 0;
  int64x2_t v23 = 0;
  uint64_t v24 = 0;
  double v26 = v25;
  std::vector<long,TInlineBufferAllocator<long,30ul>>::__vallocate[abi:nn180100](&values, Count);
  long long v9 = (char *)v23;
  bzero(v23, 8 * Count);
  int64x2_t v23 = &v9[8 * Count];
  CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire);
  CFDictionaryGetKeysAndValues(explicit, (const void **)v27, (const void **)values);
  *(void *)&long long v11 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v20[14] = v11;
  v20[13] = v11;
  v20[12] = v11;
  v20[11] = v11;
  v20[10] = v11;
  v20[9] = v11;
  unsigned char v20[8] = v11;
  v20[7] = v11;
  v20[6] = v11;
  v20[4] = v11;
  v20[5] = v11;
  _DWORD v20[2] = v11;
  v20[3] = v11;
  v20[0] = v11;
  v20[1] = v11;
  unint64_t v18 = 0;
  uint64_t v19 = 0;
  keys = 0;
  CFDictionaryRef v21 = v20;
  std::vector<long,TInlineBufferAllocator<long,30ul>>::__vallocate[abi:nn180100](&keys, Count);
  uint64_t v12 = (char *)v18;
  bzero(v18, 8 * Count);
  unint64_t v18 = &v12[8 * Count];
  if (Count >= 1)
  {
    for (uint64_t i = 0; i != Count; ++i)
    {
      CFDictionaryRef v14 = (void *)[NSNumber numberWithUnsignedInt:FourCharCodeFromString(*((const __CFString **)v27 + i))];
      keys[i] = v14;
    }
  }
  *a2 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)keys, (const void **)values, Count, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  p_keys = &keys;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&p_keys);
  keys = (void **)&values;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](&keys);
  id values = &v27;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](&values);
LABEL_9:
}

char *std::vector<long,TInlineBufferAllocator<long,30ul>>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >> 61) {
    abort();
  }
  uint64_t result = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)(a1 + 3), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * a2];
  return result;
}

CFStringRef FourCharCodeFromString(const __CFString *result)
{
  if (result)
  {
    CFStringRef v1 = result;
    CFIndex Length = CFStringGetLength(result);
    if ((unint64_t)(Length - 5) >= 0xFFFFFFFFFFFFFFFCLL)
    {
      v4.CFIndex length = Length;
      strcpy((char *)buffer, "    ");
      v4.CFIndex location = 0;
      CFStringGetBytes(v1, v4, 0x600u, 0, 0, buffer, 4, 0);
      return (const __CFString *)(((char)buffer[1] << 16) | (buffer[0] << 24) | ((char)buffer[2] << 8) | (char)buffer[3]);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void TDescriptor::TDescriptor(TDescriptor *this, const TDescriptor *a2, atomic_uint *a3, id a4)
{
  *(void *)this = &unk_1ED05D778;
  *((void *)this + 1) = a4;
  unsigned int v7 = atomic_load((unsigned int *)a2 + 4);
  *((_DWORD *)this + 4) = v7 | 0x80000000;
  *((void *)this + 3) = 0;
  if (a3) {
    atomic_fetch_add_explicit(a3 + 2, 1u, memory_order_relaxed);
  }
  *((void *)this + 4) = a3;
  *((void *)this + 5) = (id)atomic_load_explicit((atomic_ullong *volatile)a2 + 5, memory_order_acquire);
}

_anonymous_namespace_::TSingleAttrDescriptorCache *anonymous namespace'::TSingleAttrDescriptorCache::TSingleAttrDescriptorCache(_anonymous_namespace_::TSingleAttrDescriptorCache *this)
{
  *(void *)this = 0;
  Table = GetTable();
  if (!Table || (uint64_t v3 = Table[4]) == 0) {
    operator new();
  }
  if (*(_DWORD *)v3 != TGenerationSeed::sGeneration)
  {
    *(_DWORD *)uint64_t v3 = TGenerationSeed::sGeneration;
    v8[0] = (atomic_ullong)&unk_1ED05F890;
    v8[1] = 0;
    *(_OWORD *)long long v9 = 0u;
    *(_OWORD *)uint64_t v10 = 0u;
    for (uint64_t i = 24; i != 600; i += 48)
    v8[0] = (atomic_ullong)&unk_1ED05F890;

    *(_OWORD *)(v3 + 8) = xmmword_184B8A1D0;
    id v5 = (uint64_t *)(v3 + 32);
    for (uint64_t j = 1; j != 12; ++j)
    {
      *id v5 = j;
      v5 += 6;
    }
    *(void *)(v3 + 560) = 0;
  }
  *(void *)this = v3;
  return this;
}

_anonymous_namespace_::TSingleAttrDescriptor *anonymous namespace'::TSingleAttrDescriptor::TSingleAttrDescriptor(_anonymous_namespace_::TSingleAttrDescriptor *this, id a2, void *a3, void *a4, const __CTFontDescriptor *a5)
{
  *(void *)this = &unk_1ED05F890;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = a2;
  *((void *)this + 3) = a3;
  *((void *)this + 4) = a4;
  *((void *)this + 5) = a5;
  return this;
}

uint64_t TBaseFont::IsOpticalFont(TBaseFont *this)
{
  return 0;
}

uint64_t TPerThreadLRUCache<anonymous namespace'::TSingleAttrDescriptor,(ThreadSpecificKey)2,12ul>::DestroyCache(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    for (uint64_t i = 0; i != -576; i -= 48)
    {
      *(void *)(v1 + i + 552) = &unk_1ED05F890;
    }
    JUMPOUT(0x1853275C0);
  }
  return result;
}

uint64_t TBaseFont::IsTextStyleFont(TBaseFont *this)
{
  return 0;
}

uint64_t TBaseFont::GetDesignUITrait(TBaseFont *this)
{
  return 0;
}

uint64_t TAttributes::HandleUnderlineAttribute(uint64_t result, TAttributes **a2)
{
  if (result)
  {
    CFNumberRef v3 = (const __CFNumber *)result;
    int valuePtr = -1431655766;
    CFTypeID v4 = CFGetTypeID((CFTypeRef)result);
    if (v4 == CFNumberGetTypeID() || v4 == CFBooleanGetTypeID())
    {
      uint64_t result = CFNumberGetValue(v3, kCFNumberIntType, &valuePtr);
      int v5 = valuePtr;
    }
    else
    {
      uint64_t result = CFStringGetTypeID();
      if (v4 != result) {
        return result;
      }
      uint64_t result = CFStringGetIntValue((CFStringRef)v3);
      int v5 = result;
      int valuePtr = result;
    }
    if ((_BYTE)v5)
    {
      uint64_t result = TAttributes::EnsureRareData(*a2);
      *(_DWORD *)(result + 56) = v5;
      *((unsigned char *)*a2 + 137) |= 4u;
    }
  }
  return result;
}

void CTRunGetAdvances(CTRunRef run, CFRange range, CGSize *buffer)
{
  v31[4] = *MEMORY[0x1E4F143B8];
  if (run)
  {
    CFNumberRef v3 = buffer;
    if (buffer)
    {
      CFIndex length = range.length;
      CFIndex location = range.location;
      uint64_t v6 = *((void *)run + 5);
      if ((*(unsigned char *)(v6 + 225) & 0x18) != 0)
      {
        unsigned int v7 = *(void **)(v6 + 216);
        uint64_t v8 = v7[4];
        if (v8 || (uint64_t v17 = v7[3]) == 0)
        {
          uint64_t v9 = *(void *)(v6 + 200);
          uint64_t v10 = v8 + 16 * v9;
          uint64_t v11 = 2;
        }
        else
        {
          uint64_t v9 = *(void *)(v6 + 200);
          uint64_t v10 = v17 + 8 * v9;
          uint64_t v11 = 1;
        }
        uint64_t v18 = *(void *)(v6 + 264);
        uint64_t v19 = operator new(0x28uLL);
        *uint64_t v19 = &unk_1ED05FC48;
        v19[1] = v3;
        v19[2] = v11;
        v19[3] = v10;
        v19[4] = v6 + 192;
        v31[3] = v19;
        uint64_t v20 = *(void *)(v6 + 208);
        uint64_t v21 = v7[2] + 2 * v9;
        if (!length) {
          CFIndex length = v20;
        }
        uint64_t v22 = 0;
        if (v20 >= 1 && location >= 1)
        {
          CFIndex v24 = 0;
          do
          {
            if (v18 == v22 || *(__int16 *)(v21 + 2 * v22) != -1) {
              ++v24;
            }
            ++v22;
          }
          while (v22 < v20 && v24 < location);
        }
        if (v22 < v20 && length >= 1)
        {
          uint64_t v26 = 0;
          do
          {
            if (v18 == v22 || *(unsigned __int16 *)(v21 + 2 * v22) != 0xFFFF) {
              std::function<void ()(long,long)>::operator()((uint64_t)v19, v22, v26++);
            }
            ++v22;
          }
          while (v22 < v20 && v26 < length);
        }
        std::__function::__value_func<void ()(long,long)>::~__value_func[abi:nn180100](v31);
      }
      else if ((range.location & 0x8000000000000000) == 0)
      {
        CFIndex v12 = *(void *)(v6 + 208);
        if (range.location + range.length <= v12)
        {
          CFIndex v13 = v12 - range.location;
          if (range.length) {
            CFIndex v13 = range.length;
          }
          uint64_t v14 = *(void *)(v6 + 216);
          uint64_t v15 = *(void *)(v14 + 32);
          if (v15 || (uint64_t v27 = *(void *)(v14 + 24)) == 0)
          {
            if (v13)
            {
              CFTypeID v16 = (const void *)(v15 + 16 * *(void *)(v6 + 200) + 16 * range.location);
              memmove(buffer, v16, 16 * v13);
            }
          }
          else if (v13)
          {
            uint64_t v28 = (CGFloat *)(v27 + 8 * *(void *)(v6 + 200) + 8 * range.location);
            uint64_t v29 = 8 * v13;
            do
            {
              CGFloat v30 = *v28++;
              v3->double width = v30;
              v3->CGFloat height = 0.0;
              ++v3;
              v29 -= 8;
            }
            while (v29);
          }
        }
      }
    }
  }
}

void CTRunGetPositions(CTRunRef run, CFRange range, CGPoint *buffer)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (run && buffer)
  {
    CFIndex length = range.length;
    CFIndex location = range.location;
    uint64_t v6 = *((void *)run + 5);
    if ((*(unsigned char *)(v6 + 225) & 8) != 0)
    {
      TRun::GetPositions(*((__n128 **)run + 5), 0);
      uint64_t v10 = 0;
      uint64_t v11 = *(void *)(v6 + 264);
      v19[0] = &unk_1ED05FCD8;
      v19[1] = buffer;
      v19[2] = v12;
      uint64_t v20 = v19;
      uint64_t v13 = *(void *)(v6 + 208);
      uint64_t v14 = *(void *)(*(void *)(v6 + 216) + 16) + 2 * *(void *)(v6 + 200);
      if (!length) {
        CFIndex length = v13;
      }
      if (v13 >= 1 && location >= 1)
      {
        uint64_t v10 = 0;
        CFIndex v16 = 0;
        do
        {
          if (v11 == v10 || *(__int16 *)(v14 + 2 * v10) != -1) {
            ++v16;
          }
          ++v10;
        }
        while (v10 < v13 && v16 < location);
      }
      if (v10 < v13 && length >= 1)
      {
        uint64_t v18 = 0;
        do
        {
          if (v11 == v10 || *(unsigned __int16 *)(v14 + 2 * v10) != 0xFFFF) {
            std::function<void ()(long,long)>::operator()((uint64_t)v20, v10, v18++);
          }
          ++v10;
        }
        while (v10 < v13 && v18 < length);
      }
      std::__function::__value_func<void ()(long,long)>::~__value_func[abi:nn180100](v19);
    }
    else if ((range.location & 0x8000000000000000) == 0)
    {
      CFIndex v7 = *(void *)(v6 + 208);
      if (range.location + range.length <= v7)
      {
        CFIndex v8 = v7 - range.location;
        if (!range.length) {
          range.CFIndex length = v8;
        }
        uint64_t v9 = (atomic_ullong *)*((void *)run + 5);
        TRun::CopyPositions(v9, range, buffer);
      }
    }
  }
}

void CTRunGetStringIndices(CTRunRef run, CFRange range, CFIndex *buffer)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (run && buffer)
  {
    uint64_t v3 = *((void *)run + 5);
    if ((*(unsigned char *)(v3 + 225) & 8) != 0)
    {
      uint64_t v8 = *(void *)(v3 + 208);
      uint64_t v7 = *(void *)(v3 + 216);
      uint64_t v9 = *(void *)(v3 + 200);
      uint64_t v10 = *(void *)(v7 + 48) + 8 * v9;
      uint64_t v11 = *(void *)(v3 + 264);
      v19[0] = &unk_1ED05FDB0;
      v19[1] = buffer;
      v19[2] = v10;
      uint64_t v20 = v19;
      uint64_t v12 = *(void *)(v7 + 16) + 2 * v9;
      if (range.length) {
        CFIndex length = range.length;
      }
      else {
        CFIndex length = v8;
      }
      uint64_t v14 = 0;
      if (v8 >= 1 && range.location >= 1)
      {
        CFIndex v16 = 0;
        do
        {
          if (v11 == v14 || *(__int16 *)(v12 + 2 * v14) != -1) {
            ++v16;
          }
          ++v14;
        }
        while (v14 < v8 && v16 < range.location);
      }
      if (v14 < v8 && length >= 1)
      {
        uint64_t v18 = 0;
        do
        {
          if (v11 == v14 || *(unsigned __int16 *)(v12 + 2 * v14) != 0xFFFF) {
            std::function<void ()(long,long)>::operator()((uint64_t)v20, v14, v18++);
          }
          ++v14;
        }
        while (v14 < v8 && v18 < length);
      }
      std::__function::__value_func<void ()(long,long)>::~__value_func[abi:nn180100](v19);
    }
    else if ((range.location & 0x8000000000000000) == 0)
    {
      CFIndex v4 = *(void *)(v3 + 208);
      if (range.location + range.length <= v4)
      {
        CFIndex v5 = v4 - range.location;
        if (range.length) {
          CFIndex v5 = range.length;
        }
        if (v5)
        {
          uint64_t v6 = (const void *)(*(void *)(*(void *)(v3 + 216) + 48)
                            + 8 * *(void *)(v3 + 200)
                            + 8 * range.location);
          memmove(buffer, v6, 8 * v5);
        }
      }
    }
  }
}

uint64_t std::function<void ()(long,long)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = a3;
  uint64_t v8 = a2;
  if (a1) {
    return (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t *))(*(void *)a1 + 48))(a1, &v8, &v7);
  }
  uint64_t v4 = std::__throw_bad_function_call[abi:nn180100]();
  return std::__function::__func<CTRunGetStringIndices::$_0,std::allocator<CTRunGetStringIndices::$_0>,void ()(long,long)>::operator()(v4, v5, v6);
}

uint64_t std::__function::__func<CTRunGetStringIndices::$_0,std::allocator<CTRunGetStringIndices::$_0>,void ()(long,long)>::operator()(uint64_t result, void *a2, void *a3)
{
  *(void *)(*(void *)(result + 8) + 8 * *a3) = *(void *)(*(void *)(result + 16) + 8 * *a2);
  return result;
}

__n128 std::__function::__func<CTRunGetPositions::$_0,std::allocator<CTRunGetPositions::$_0>,void ()(long,long)>::operator()(uint64_t a1, void *a2, void *a3)
{
  __n128 result = *(__n128 *)(*(void *)(a1 + 16) + 16 * *a2);
  *(__n128 *)(*(void *)(a1 + 8) + 16 * *a3) = result;
  return result;
}

double std::__function::__func<CTRunGetAdvances::$_1,std::allocator<CTRunGetAdvances::$_1>,void ()(long,long)>::operator()(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *a3;
  uint64_t v6 = *(void *)(a1 + 24);
  if (*(_DWORD *)(a1 + 16) == 1)
  {
    uint64_t v7 = (uint64_t *)(v6 + 8 * v4);
    uint64_t v8 = 0;
  }
  else
  {
    uint64_t v7 = (uint64_t *)(v6 + 16 * v4);
    uint64_t v8 = v7[1];
  }
  uint64_t v9 = *v7;
  uint64_t v10 = (void *)(*(void *)(a1 + 8) + 16 * v5);
  void *v10 = v9;
  v10[1] = v8;
  uint64_t v11 = *(void *)(a1 + 32);
  if ((*(unsigned char *)(v11 + 33) & 0x10) != 0)
  {
    [*(id *)(v11 + 24) originAtIndex:*(void *)(v11 + 8) + v4];
    double v12 = *MEMORY[0x1E4F1DAD8];
    double v13 = *(double *)(MEMORY[0x1E4F1DAD8] + 8);
  }
  else
  {
    double v12 = *MEMORY[0x1E4F1DAD8];
    double v13 = *(double *)(MEMORY[0x1E4F1DAD8] + 8);
    double result = *MEMORY[0x1E4F1DAD8];
    double v15 = v13;
  }
  if (result != v12 || v15 != v13)
  {
    uint64_t v17 = *(void *)(a1 + 8);
    if (v5 >= 1)
    {
      uint64_t v18 = v17 + 16 * v5;
      double v19 = v15 + *(double *)(v18 - 8);
      *(double *)(v18 - 16) = result + *(double *)(v18 - 16);
      *(double *)(v18 - 8) = v19;
    }
    uint64_t v20 = (double *)(v17 + 16 * v5);
    double result = *v20 - result;
    double v21 = v20[1] - v15;
    double *v20 = result;
    v20[1] = v21;
  }
  return result;
}

void *std::__function::__value_func<void ()(long,long)>::~__value_func[abi:nn180100](void *a1)
{
  int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__function::__func<CTRunGetBaseAdvancesAndOrigins::$_2,std::allocator<CTRunGetBaseAdvancesAndOrigins::$_2>,void ()(long,long)>::operator()(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = result;
  uint64_t v4 = *a2;
  uint64_t v5 = *a3;
  uint64_t v6 = *(void *)(result + 8);
  if (v6)
  {
    uint64_t v7 = *(void *)(result + 24);
    if (*(_DWORD *)(result + 16) == 1)
    {
      uint64_t v8 = (void *)(v7 + 8 * v4);
      uint64_t v9 = 0;
    }
    else
    {
      uint64_t v8 = (void *)(v7 + 16 * v4);
      uint64_t v9 = v8[1];
    }
    uint64_t v10 = (void *)(v6 + 16 * v5);
    void *v10 = *v8;
    v10[1] = v9;
  }
  uint64_t v11 = *(void *)(result + 32);
  if (v11)
  {
    uint64_t v12 = *(void *)(result + 40);
    if ((*(unsigned char *)(v12 + 33) & 0x10) != 0)
    {
      double result = [*(id *)(v12 + 24) originAtIndex:*(void *)(v12 + 8) + v4];
      uint64_t v11 = *(void *)(v3 + 32);
    }
    else
    {
      uint64_t v13 = *MEMORY[0x1E4F1DAD8];
      uint64_t v14 = *(void *)(MEMORY[0x1E4F1DAD8] + 8);
    }
    double v15 = (void *)(v11 + 16 * v5);
    void *v15 = v13;
    v15[1] = v14;
  }
  return result;
}

void CTLineDrawWithAttributeOverrides(uint64_t a1, CGContext *a2)
{
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 + 40);
    uint64_t v4 = -1;
    v3[0] = xmmword_184B88AE8;
    memset(&v3[1], 255, 64);
    TLineDrawContext::TLineDrawContext((TLineDrawContext *)v3, a2);
    TLine::DrawGlyphsWithAttributeOverrides(v2, (uint64_t)v3);
  }
}

void TLineDrawContext::TLineDrawContext(TLineDrawContext *this, CGContextRef c)
{
  *(_DWORD *)this = 0;
  *((void *)this + 1) = c;
  *((_OWORD *)this + 1) = *MEMORY[0x1E4F1DAD8];
  long long v4 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
  long long v3 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 32);
  *((_OWORD *)this + 2) = *MEMORY[0x1E4F1DAB8];
  *((_OWORD *)this + 3) = v4;
  *((_OWORD *)this + 4) = v3;
  *((void *)this + 10) = 0x3FF0000000000000;
  *(void *)&long long v3 = -1;
  *((void *)&v3 + 1) = -1;
  *(_OWORD *)&v9.c = v3;
  *(_OWORD *)&v9.tdouble x = v3;
  *(_OWORD *)&v9.CGFloat a = v3;
  CGContextGetCTM(&v9, c);
  double v5 = fabs(v9.a * v9.d - v9.b * v9.c);
  double v6 = sqrt(v5);
  BOOL v7 = v5 <= 0.001;
  double v8 = 1.0;
  if (!v7) {
    double v8 = v6;
  }
  *((double *)this + 10) = v8;
}

uint64_t TRun::SetAttachmentsLeftToRight<true>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *((void *)&v48 + 1) = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *(void *)(*(void *)(a1 + 216) + 48) + 8 * *(void *)(a1 + 200);
  *(void *)&long long v9 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v47[16] = v9;
  *(_OWORD *)unint64_t v47 = v9;
  long long v46 = v9;
  *(_OWORD *)&v45[16] = v9;
  *(_OWORD *)id v45 = v9;
  long long v44 = v9;
  *(_OWORD *)&v43[16] = v9;
  *(_OWORD *)double v43 = v9;
  long long v42 = v9;
  long long v40 = v9;
  long long v41 = v9;
  long long v38 = v9;
  long long v39 = v9;
  long long v36 = v9;
  long long v37 = v9;
  uint64_t v34 = 0;
  uint64_t v35 = 0;
  uint64_t v33 = 0;
  *(void *)&long long v48 = &v36;
  if (a2 < 2)
  {
    uint64_t v15 = a2 - 1;
  }
  else
  {
    for (uint64_t i = a2; i > 1; --i)
    {
      uint64_t v11 = *(void *)(a3 - 8 + 8 * i);
      uint64_t v12 = [*(id *)(a1 + 216) attachmentCountAtIndex:*(void *)(a1 + 200) + v11];
      BOOL v13 = v11 < 1;
      uint64_t v14 = v11 - 1;
      if (!v13) {
        objc_msgSend(*(id *)(a1 + 216), "setAttachmentCount:atIndex:", v12 + objc_msgSend(*(id *)(a1 + 216), "attachmentCountAtIndex:", *(void *)(a1 + 200) + v14) + 1, *(void *)(a1 + 200) + v14);
      }
    }
    uint64_t v15 = 0;
  }
  CFIndex v16 = *(void ***)(a3 + 8 * v15);
  uint64_t v17 = *(void *)(v8 + 8 * (void)v16);
  uint64_t v18 = *(void *)(a1 + 8);
  if (v17 <= a4)
  {
    uint64_t v23 = *(void *)(a1 + 16) + v18;
    uint64_t v32 = v16;
    CFIndex v24 = v16;
    while (1)
    {
      if (*(int *)(a1 + 256) > 1)
      {
        uint64_t NextGlyphIndex = TRun::FindNextGlyphIndex((TRun *)a1, v17, (uint64_t *)&v32);
      }
      else
      {
        if (*(unsigned char *)(a1 + 224))
        {
          CFTypeID v25 = (char *)v24 - 1;
          uint64_t v32 = (void **)((char *)v24 - 1);
          if ((uint64_t)v24 <= 0)
          {
LABEL_15:
            uint64_t NextGlyphIndex = *(void *)(a1 + 16) + *(void *)(a1 + 8);
            goto LABEL_19;
          }
        }
        else
        {
          CFTypeID v25 = (char *)v24 + 1;
          uint64_t v32 = (void **)((char *)v24 + 1);
          if ((uint64_t)v24 + 1 >= *(void *)(a1 + 208)) {
            goto LABEL_15;
          }
        }
        uint64_t NextGlyphIndex = *(void *)(*(void *)(*(void *)(a1 + 216) + 48)
                                   + 8 * *(void *)(a1 + 200)
                                   + 8 * (void)v25);
      }
LABEL_19:
      if (NextGlyphIndex >= v23)
      {
        uint64_t v30 = [*(id *)(a1 + 216) attachmentCountAtIndex:(char *)v16 + *(void *)(a1 + 200)] + 1;
        goto LABEL_27;
      }
      CFIndex v24 = v32;
      uint64_t v27 = *(void **)(a1 + 216);
      uint64_t v28 = *(void *)(a1 + 200);
      if (a2 < 2
        || *(__int16 *)(v27[2] + 2 * v28 + 2 * (void)v32) != -1
        && (*(_DWORD *)(v27[5] + 4 * v28 + 4 * (void)v32) & 0x20) == 0)
      {
        objc_msgSend(v27, "setStringIndex:atIndex:", v17, (char *)v32 + v28, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, *(void *)v43, *(_OWORD *)&v43[8], *(void *)&v43[24], v44,
          *(void *)v45,
          *(_OWORD *)&v45[8],
          *(void *)&v45[24],
          v46,
          *(void *)v47,
          *(_OWORD *)&v47[8],
          *(void *)&v47[24],
          v48);
        uint64_t v29 = [*(id *)(a1 + 216) attachmentCountAtIndex:(char *)v16 + *(void *)(a1 + 200)];
        uint64_t v20 = v29 + [*(id *)(a1 + 216) attachmentCountAtIndex:(char *)v24 + *(void *)(a1 + 200)] + 1;
        double v21 = *(void **)(a1 + 216);
        uint64_t v22 = (uint64_t)v24 + *(void *)(a1 + 200);
        goto LABEL_24;
      }
    }
  }
  uint64_t v19 = [*(id *)(a1 + 216) attachmentCountAtIndex:(char *)v16 + *(void *)(a1 + 200)];
  if (v17 <= v18)
  {
    uint64_t v30 = v19 + 1;
  }
  else
  {
    uint64_t v20 = v19 + [*(id *)(a1 + 216) attachmentCountAtIndex:(char *)v16 + *(void *)(a1 + 200) - 1] + 1;
    double v21 = *(void **)(a1 + 216);
    uint64_t v22 = (uint64_t)v16 + *(void *)(a1 + 200) - 1;
LABEL_24:
    [v21 setAttachmentCount:v20 atIndex:v22];
    uint64_t v30 = 0;
  }
LABEL_27:
  uint64_t v32 = (void **)&v33;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](&v32);
  return v30;
}

void TLine::DrawGlyphsWithAttributeOverrides(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](a1, a2);
  double v74 = v4;
  uint64_t v6 = v5;
  uint64_t v7 = v3;
  int64_t v76 = (TLine *)v2;
  v102[1] = *MEMORY[0x1E4F143B8];
  *(void *)&long long v8 = -1;
  *((void *)&v8 + 1) = -1;
  *(_OWORD *)&v83.c = v8;
  *(_OWORD *)&v83.tdouble x = v8;
  *(_OWORD *)&v83.CGFloat a = v8;
  if (*(_DWORD *)v3)
  {
    long long v9 = *(_OWORD *)(v3 + 48);
    *(_OWORD *)&v83.CGFloat a = *(_OWORD *)(v3 + 32);
    *(_OWORD *)&v83.c = v9;
    *(_OWORD *)&v83.tdouble x = *(_OWORD *)(v3 + 64);
  }
  else
  {
    CGContextGetTextMatrix(&v83, *(CGContextRef *)(v3 + 8));
  }
  memset(v101, 170, sizeof(v101));
  __p = 0;
  int64x2_t v99 = 0;
  uint64_t v100 = 0;
  v102[0] = v101;
  memset(v96, 170, sizeof(v96));
  CGAffineTransform v93 = 0;
  long long v94 = 0;
  unint64_t v95 = 0;
  uint64_t v97 = v96;
  memset(v91, 170, sizeof(v91));
  int v88 = 0;
  int64_t v89 = 0;
  unint64_t v90 = 0;
  unint64_t v92 = v91;
  uint64_t v10 = *((void *)v76 + 3) - *((void *)v76 + 2);
  uint64_t v82 = 0;
  uint64_t v73 = v7;
  if (v10 < 1)
  {
    int v12 = 0;
  }
  else
  {
    uint64_t v11 = 0;
    int v12 = 0;
    uint64_t v75 = v10 >> 3;
    uint64_t v78 = v6;
    do
    {
      uint64_t v13 = *(void *)(*(void *)(*((void *)v76 + 2) + 8 * v11) + 40);
      uint64_t v14 = *(void *)(v13 + 208);
      if (v14 >= 1)
      {
        uint64_t v15 = *(void **)(v13 + 216);
        uint64_t v16 = *(void *)(v13 + 200);
        uint64_t v17 = (uint64_t *)(v15[6] + 8 * v16);
        uint64_t v18 = *v17;
        v86.CGFloat a = -3.72066208e-103;
        v86.CGFloat b = -3.72066208e-103;
        if (v6)
        {
          uint64_t v19 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, CGAffineTransform *))(v6 + 16))(v6, v18, &v86);
          uint64_t v15 = *(void **)(v13 + 216);
          uint64_t v16 = *(void *)(v13 + 200);
        }
        else
        {
          uint64_t v19 = 0;
        }
        int v79 = v12;
        unint64_t v81 = v19;
        long long v80 = xmmword_184B88D50;
        [v15 attachmentCountAtIndex:v16];
        if ((unint64_t)v14 < 2)
        {
          CGFloat v20 = 0.0;
          uint64_t v21 = 1;
        }
        else
        {
          uint64_t v77 = v11;
          CGFloat v20 = 0.0;
          uint64_t v21 = 1;
          for (uint64_t i = 1; i != v14; ++i)
          {
            uint64_t v23 = v17[i];
            if (*(uint64_t *)&v86.a > v23 || *(void *)&v86.b + *(void *)&v86.a <= v23)
            {
              t2.CGFloat a = v20;
              *(void *)&t2.CGFloat b = v21;
              uint64_t v85 = v13;
              TAttributes::TAttributes((TAttributes *)&t1, (const TAttributes *)(v13 + 40), (const __CFDictionary *)v19);
              uint64_t v25 = std::vector<std::tuple<TRun const*,CFRange,TAttributes>,TInlineBufferAllocator<std::tuple<TRun const*,CFRange,TAttributes>,30ul>>::emplace_back<TRun const*&,CFRange&,TAttributes>((char **)&__p, &v85, (long long *)&t2, (uint64_t)&t1);
              TAttributes::~TAttributes((TAttributes *)&t1);
              char v26 = *(unsigned char *)(v25 + 161);
              if (v19)
              {
                if (CFDictionaryGetValue((CFDictionaryRef)v19, @"NSUnderline")
                  || TAttributes::GetUnderlineColor((TAttributes *)v19, 0, v27))
                {
                  uint64_t v28 = v94;
                  if ((unint64_t)v94 >= v95)
                  {
                    uint64_t v29 = std::vector<DecorationOverride,TInlineBufferAllocator<DecorationOverride,30ul>>::__emplace_back_slow_path<long &,CFRange &,__CFDictionary const*&>(&v93, &v82, &v80, &v81);
                  }
                  else
                  {
                    *(void *)long long v94 = v77;
                    *((CGFloat *)v28 + 1) = v20;
                    *((void *)v28 + 2) = v21;
                    *((void *)v28 + 3) = v19;
                    uint64_t v29 = v28 + 32;
                  }
                  long long v94 = v29;
                  uint64_t v6 = v78;
                }
                if (CFDictionaryGetValue((CFDictionaryRef)v19, @"NSStrikethrough")
                  || TAttributes::GetStrikethroughColor((TAttributes *)v19, 0, v30))
                {
                  CFTypeID v31 = v89;
                  if ((unint64_t)v89 >= v90)
                  {
                    uint64_t v32 = std::vector<DecorationOverride,TInlineBufferAllocator<DecorationOverride,30ul>>::__emplace_back_slow_path<long &,CFRange &,__CFDictionary const*&>((char **)&v88, &v82, &v80, &v81);
                  }
                  else
                  {
                    *(void *)int64_t v89 = v77;
                    *((CGFloat *)v31 + 1) = v20;
                    *((void *)v31 + 2) = v21;
                    *((void *)v31 + 3) = v19;
                    uint64_t v32 = v31 + 32;
                  }
                  int64_t v89 = v32;
                  uint64_t v6 = v78;
                }
              }
              if (v6) {
                uint64_t v19 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, CGAffineTransform *))(v6 + 16))(v6, v23, &v86);
              }
              else {
                uint64_t v19 = 0;
              }
              v79 |= v26 & 1;
              unint64_t v81 = v19;
              *(void *)&long long v80 = i;
              CGFloat v20 = *(double *)&i;
              uint64_t v21 = 1;
            }
            else
            {
              ++v21;
            }
            *((void *)&v80 + 1) = v21;
            [*(id *)(v13 + 216) attachmentCountAtIndex:i + *(void *)(v13 + 200)];
          }
        }
        t2.CGFloat a = v20;
        *(void *)&t2.CGFloat b = v21;
        uint64_t v85 = v13;
        TAttributes::TAttributes((TAttributes *)&t1, (const TAttributes *)(v13 + 40), (const __CFDictionary *)v19);
        uint64_t v33 = std::vector<std::tuple<TRun const*,CFRange,TAttributes>,TInlineBufferAllocator<std::tuple<TRun const*,CFRange,TAttributes>,30ul>>::emplace_back<TRun const*&,CFRange&,TAttributes>((char **)&__p, &v85, (long long *)&t2, (uint64_t)&t1);
        TAttributes::~TAttributes((TAttributes *)&t1);
        char v34 = *(unsigned char *)(v33 + 161);
        if (v19)
        {
          if (CFDictionaryGetValue((CFDictionaryRef)v19, @"NSUnderline")
            || TAttributes::GetUnderlineColor((TAttributes *)v19, 0, v35))
          {
            long long v36 = v94;
            if ((unint64_t)v94 >= v95)
            {
              long long v37 = std::vector<DecorationOverride,TInlineBufferAllocator<DecorationOverride,30ul>>::__emplace_back_slow_path<long &,CFRange &,__CFDictionary const*&>(&v93, &v82, &v80, &v81);
            }
            else
            {
              *(void *)long long v94 = v82;
              *((CGFloat *)v36 + 1) = v20;
              *((void *)v36 + 2) = v21;
              *((void *)v36 + 3) = v19;
              long long v37 = v36 + 32;
            }
            long long v94 = v37;
          }
          if (CFDictionaryGetValue((CFDictionaryRef)v19, @"NSStrikethrough")
            || TAttributes::GetStrikethroughColor((TAttributes *)v19, 0, v38))
          {
            long long v39 = v89;
            if ((unint64_t)v89 >= v90)
            {
              long long v40 = std::vector<DecorationOverride,TInlineBufferAllocator<DecorationOverride,30ul>>::__emplace_back_slow_path<long &,CFRange &,__CFDictionary const*&>((char **)&v88, &v82, &v80, &v81);
            }
            else
            {
              *(void *)int64_t v89 = v82;
              *((CGFloat *)v39 + 1) = v20;
              *((void *)v39 + 2) = v21;
              *((void *)v39 + 3) = v19;
              long long v40 = v39 + 32;
            }
            int64_t v89 = v40;
          }
        }
        int v12 = v34 & 1 | v79;
        uint64_t v11 = v82;
      }
      uint64_t v82 = ++v11;
    }
    while (v11 < v75);
  }
  tdouble x = v83.tx;
  tCGFloat y = v83.ty;
  TLine::GetLeftHangersGlyphCountAndWidth(v76, 0);
  if (v43 == 0.0) {
    double v44 = 0.0;
  }
  else {
    double v44 = v43;
  }
  id v45 = (__n128 **)__p;
  if (v12)
  {
    long long v46 = v99;
    CGFloat v47 = v74;
    if (__p != v99)
    {
      do
      {
        if (v47 == 0.0)
        {
          CFIndex v49 = (CFIndex)v45[1];
          CFIndex v48 = (CFIndex)v45[2];
          uint64_t v50 = *v45;
          *(void *)&long long v51 = -1;
          *((void *)&v51 + 1) = -1;
          *(_OWORD *)&v86.c = v51;
          *(_OWORD *)&v86.tdouble x = v51;
          *(_OWORD *)&v86.CGFloat a = v51;
          uint64_t v52 = v50 + 6;
          if (!v50[9].n128_u8[0]) {
            uint64_t v52 = (__n128 *)MEMORY[0x1E4F1DAB8];
          }
          CGAffineTransform t1 = v83;
          __n128 v53 = v52[1];
          *(__n128 *)&t2.CGFloat a = *v52;
          *(__n128 *)&t2.c = v53;
          *(__n128 *)&t2.tdouble x = v52[2];
          CGAffineTransformConcat(&v86, &t1, &t2);
          CFRange v54 = *(CGContext **)(v73 + 8);
          *(_OWORD *)&t1.CGFloat a = *(_OWORD *)&v86.a;
          *(_OWORD *)&t1.c = *(_OWORD *)&v86.c;
          *(_OWORD *)&t1.tdouble x = *(_OWORD *)&v83.tx;
          CGContextSetTextMatrix(v54, &t1);
          v103.CFIndex location = v49;
          v103.CFIndex length = v48;
          TRun::DrawBackground((TRun *)v50, v54, v103, (const TAttributes *)(v45 + 3), 1);
          CGAffineTransform t2 = v83;
          CGContextSetTextMatrix(v54, &t2);
          CGFloat v47 = v74;
        }
        v45 += 22;
      }
      while (v45 != v46);
      id v45 = (__n128 **)__p;
    }
  }
  else
  {
    CGFloat v47 = v74;
  }
  int64x2_t v55 = v99;
  if (v45 != v99)
  {
    char v56 = 0;
    int v57 = 0;
    double v58 = tx - v44;
    do
    {
      if (v47 == 0.0)
      {
        int64_t v60 = v45[1];
        uint64_t v59 = v45[2];
        unint64_t v61 = *v45;
        *(void *)&long long v62 = -1;
        *((void *)&v62 + 1) = -1;
        *(_OWORD *)&v86.c = v62;
        *(_OWORD *)&v86.tdouble x = v62;
        *(_OWORD *)&v86.CGFloat a = v62;
        CFTypeID v63 = v61 + 6;
        if (!v61[9].n128_u8[0]) {
          CFTypeID v63 = (__n128 *)MEMORY[0x1E4F1DAB8];
        }
        CGAffineTransform t1 = v83;
        __n128 v64 = v63[1];
        *(__n128 *)&t2.CGFloat a = *v63;
        *(__n128 *)&t2.c = v64;
        *(__n128 *)&t2.tdouble x = v63[2];
        CGAffineTransformConcat(&v86, &t1, &t2);
        double v65 = *(CGContext **)(v73 + 8);
        *(_OWORD *)&t1.CGFloat a = *(_OWORD *)&v86.a;
        *(_OWORD *)&t1.c = *(_OWORD *)&v86.c;
        *(_OWORD *)&t1.tdouble x = *(_OWORD *)&v83.tx;
        CGContextSetTextMatrix(v65, &t1);
        __n128 Positions = TRun::GetPositions(v61, 0);
        t2.CGFloat a = -3.72066208e-103;
        *(void *)&t2.CGFloat b = v45 + 3;
        t2.c = -3.72066208e-103;
        (*(void (**)(__n128 *, CGContext *, __n128 *, __n128 *, uint64_t, CGAffineTransform *, __n128))(v61->n128_u64[0] + 40))(v61, v65, v60, v59, v67, &t2, Positions);
        CGAffineTransform t2 = v83;
        CGContextSetTextMatrix(v65, &t2);
        CGFloat v47 = v74;
      }
      if ((*((unsigned char *)v45 + 161) & 4) != 0) {
        int v57 = 1;
      }
      if ((*((unsigned char *)v45 + 161) & 0x10) != 0) {
        char v56 = 1;
      }
      v45 += 22;
    }
    while (v45 != v55);
    if (v57)
    {
      if (v47 == 0.0)
      {
        CGContextSetTextPosition(*(CGContextRef *)(v73 + 8), v58, ty);
        CGFloat v47 = v74;
      }
      t1.CGFloat a = -3.72066066e-103;
      t1.CGFloat b = v47;
      TDecorator::DrawDecoration((uint64_t)&t1, v73, v76, (uint64_t)&v93);
      CGFloat v47 = v74;
    }
    if (v56)
    {
      if (v47 == 0.0)
      {
        CGContextSetTextPosition(*(CGContextRef *)(v73 + 8), v58, ty);
        CGFloat v47 = v74;
      }
      t1.CGFloat a = -3.72066066e-103;
      t1.CGFloat b = v47;
      TDecorator::DrawDecoration((uint64_t)&t1, v73, v76, (uint64_t)&v88);
    }
  }
  *(void *)&t1.CGFloat a = &v88;
  std::vector<DecorationOverride,TInlineBufferAllocator<DecorationOverride,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&t1);
  int v88 = &v93;
  std::vector<DecorationOverride,TInlineBufferAllocator<DecorationOverride,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v88);
  int64x2_t v68 = (char *)__p;
  if (__p)
  {
    int64x2_t v69 = (char *)v99;
    id v70 = __p;
    if (v99 != __p)
    {
      do
      {
        CFDictionaryRef v71 = v69 - 176;
        TAttributes::~TAttributes((TAttributes *)(v69 - 152));
        int64x2_t v69 = v71;
      }
      while (v71 != v68);
      id v70 = __p;
    }
    int64x2_t v99 = (__n128 **)v68;
    if (v101 > v70 || v102 <= (void *)v70) {
      operator delete(v70);
    }
  }
}

void std::vector<DecorationOverride,TInlineBufferAllocator<DecorationOverride,30ul>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (id *)**a1;
  if (v2)
  {
    double v4 = (id *)v1[1];
    uint64_t v5 = (void **)**a1;
    uint64_t v6 = v1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = v4 - 4;

        double v4 = v7;
      }
      while (v7 != v2);
      uint64_t v6 = *a1;
      uint64_t v5 = (void **)**a1;
    }
    v1[1] = v2;
    long long v8 = v6 + 123;
    if (v6 + 3 <= v5 && v8 > v5)
    {
      if (v6[2] == v6[123]) {
        *long long v8 = v5;
      }
    }
    else
    {
      operator delete(v5);
    }
  }
}

void TAttributes::TAttributes(TAttributes *this, const TAttributes *a2, const __CFDictionary *a3)
{
  *(_WORD *)((char *)this + 49) = 0;
  *((unsigned char *)this + 51) = 0;
  *((unsigned char *)this + 56) = 0;
  *((unsigned char *)this + 104) = 0;
  *((void *)this + 18) = 0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((void *)this + 15) = 0;
  *((void *)this + 16) = 0;
  TAttributes::operator=((uint64_t)this, (uint64_t)a2);
  if (a3) {
    TAttributes::ApplyOverrides(this, a3, v5);
  }
}

__n128 TRun::GetPositions(__n128 *this, CGSize *a2)
{
  for (uint64_t i = &this[17].n128_i64[1]; !atomic_load_explicit(i, memory_order_acquire); uint64_t i = &this[17].n128_i64[1])
  {
    uint64_t v5 = this[17].n128_i64[0];
    if (!v5) {
      break;
    }
    TLine::CachePositions(v5);
  }
  if (a2)
  {
    __n128 result = this[18];
    *a2 = (CGSize)result;
  }
  return result;
}

void TAttributes::ApplyOverrides(TAttributes *this, const __CFDictionary *a2, const __CFString **a3)
{
  ForegroundColor = (void *)TAttributes::GetForegroundColor(a2, a2, a3);
  if (ForegroundColor)
  {
    uint64_t v6 = ForegroundColor;
    CFTypeID v7 = CFGetTypeID(ForegroundColor);
    CFTypeID TypeID = CFNullGetTypeID();
    long long v9 = (atomic_ullong *)((char *)this + 32);
    if (v7 == TypeID)
    {

      char v10 = *((unsigned char *)this + 136) & 0xFD;
    }
    else
    {
      TCFRef<__CTFont const*>::Retain(v9, v6);
      char v10 = *((unsigned char *)this + 136) | 2;
    }
    *((unsigned char *)this + 136) = v10;
  }
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a2, @"NSUnderline");
  if (Value)
  {
    CFStringRef v12 = Value;
    uint64_t v13 = TAttributes::EnsureRareData(this);
    CFTypeID v14 = CFGetTypeID(v12);
    uint64_t v15 = (SInt32 *)(v13 + 56);
    if (v14 == CFNullGetTypeID())
    {
      SInt32 *v15 = 0;
      char v16 = *((unsigned char *)this + 137) & 0xFB;
LABEL_14:
      *((unsigned char *)this + 137) = v16;
      goto LABEL_15;
    }
    CFTypeID v17 = CFGetTypeID(v12);
    if (v17 == CFNumberGetTypeID() || v17 == CFBooleanGetTypeID())
    {
      CFNumberGetValue((CFNumberRef)v12, kCFNumberIntType, v15);
      LOBYTE(IntValue) = *(unsigned char *)v15;
LABEL_12:
      if (!(_BYTE)IntValue) {
        goto LABEL_15;
      }
      char v16 = *((unsigned char *)this + 137) | 4;
      goto LABEL_14;
    }
    if (v17 == CFStringGetTypeID())
    {
      IntCFStringRef Value = CFStringGetIntValue(v12);
      SInt32 *v15 = IntValue;
      goto LABEL_12;
    }
  }
LABEL_15:
  CFStringRef v19 = (const __CFString *)CFDictionaryGetValue(a2, @"NSStrikethrough");
  if (!v19) {
    goto LABEL_24;
  }
  CFStringRef v20 = v19;
  uint64_t v21 = TAttributes::EnsureRareData(this);
  CFTypeID v22 = CFGetTypeID(v20);
  uint64_t v23 = (SInt32 *)(v21 + 60);
  if (v22 == CFNullGetTypeID())
  {
    SInt32 *v23 = 0;
    char v24 = *((unsigned char *)this + 137) & 0xEF;
LABEL_23:
    *((unsigned char *)this + 137) = v24;
    goto LABEL_24;
  }
  CFTypeID v25 = CFGetTypeID(v20);
  if (v25 == CFNumberGetTypeID() || v25 == CFBooleanGetTypeID())
  {
    CFNumberGetValue((CFNumberRef)v20, kCFNumberIntType, v23);
    LOBYTE(v26) = *(unsigned char *)v23;
LABEL_21:
    if (!(_BYTE)v26) {
      goto LABEL_24;
    }
    char v24 = *((unsigned char *)this + 137) | 0x10;
    goto LABEL_23;
  }
  if (v25 == CFStringGetTypeID())
  {
    SInt32 v26 = CFStringGetIntValue(v20);
    SInt32 *v23 = v26;
    goto LABEL_21;
  }
LABEL_24:
  uint64_t v27 = (void *)CFDictionaryGetValue(a2, @"NSShadow");
  if (v27)
  {
    uint64_t v29 = v27;
    CFTypeID v30 = CFGetTypeID(v27);
    CFTypeID v31 = CFNullGetTypeID();
    uint64_t v32 = (atomic_ullong *)((char *)this + 40);
    if (v30 == v31)
    {

      char v33 = *((unsigned char *)this + 136) & 0xF7;
    }
    else
    {
      TCFRef<__CTFont const*>::Retain(v32, v29);
      char v33 = *((unsigned char *)this + 136) | 8;
    }
    *((unsigned char *)this + 136) = v33;
  }
  keCGFloat y = (void *)0xAAAAAAAAAAAAAAAALL;
  id v72 = 0;
  BackgroundColor = TAttributes::GetBackgroundColor(a2, (const __CFDictionary *)&key, v28);
  if (BackgroundColor)
  {
    uint64_t v35 = BackgroundColor;
    CFTypeID v36 = CFGetTypeID(BackgroundColor);
    CFTypeID v37 = CFNullGetTypeID();
    long long v38 = key;
    unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&v72, memory_order_acquire);
    if (v36 == v37)
    {
      if (!explicit)
      {
        MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, (CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)this, memory_order_acquire));
      }
      CFDictionaryRemoveValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v72, memory_order_acquire), v38);
      char v40 = *((unsigned char *)this + 137) & 0xFE;
    }
    else
    {
      if (!explicit)
      {
        MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, (CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)this, memory_order_acquire));
      }
      CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v72, memory_order_acquire), v38, v35);
      char v40 = *((unsigned char *)this + 137) | 1;
    }
    *((unsigned char *)this + 137) = v40;
  }
  long long v41 = CFDictionaryGetValue(a2, @"NSStrokeWidth");
  if (v41)
  {
    double v43 = v41;
    CFTypeID v44 = CFGetTypeID(v41);
    CFTypeID v45 = CFNullGetTypeID();
    unint64_t v46 = atomic_load_explicit((atomic_ullong *volatile)&v72, memory_order_acquire);
    if (v44 == v45)
    {
      if (!v46)
      {
        MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, (CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)this, memory_order_acquire));
      }
      CFDictionaryRemoveValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v72, memory_order_acquire), @"NSStrokeWidth");
      char v47 = *((unsigned char *)this + 136) & 0xFB;
    }
    else
    {
      if (!v46)
      {
        MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, (CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)this, memory_order_acquire));
      }
      CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v72, memory_order_acquire), @"NSStrokeWidth", v43);
      char v47 = *((unsigned char *)this + 136) | 4;
    }
    *((unsigned char *)this + 136) = v47;
  }
  StrokeColor = TAttributes::GetStrokeColor(a2, (const __CFDictionary *)&key, v42);
  if (StrokeColor)
  {
    uint64_t v50 = StrokeColor;
    CFTypeID v51 = CFGetTypeID(StrokeColor);
    CFTypeID v52 = CFNullGetTypeID();
    __n128 v53 = key;
    unint64_t v54 = atomic_load_explicit((atomic_ullong *volatile)&v72, memory_order_acquire);
    if (v51 == v52)
    {
      if (!v54)
      {
        MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, (CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)this, memory_order_acquire));
      }
      CFDictionaryRemoveValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v72, memory_order_acquire), v53);
    }
    else
    {
      if (!v54)
      {
        MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, (CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)this, memory_order_acquire));
      }
      CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v72, memory_order_acquire), v53, v50);
    }
  }
  UnderlineColor = TAttributes::GetUnderlineColor(a2, (const __CFDictionary *)&key, v49);
  if (UnderlineColor)
  {
    int v57 = UnderlineColor;
    CFTypeID v58 = CFGetTypeID(UnderlineColor);
    CFTypeID v59 = CFNullGetTypeID();
    int64_t v60 = key;
    unint64_t v61 = atomic_load_explicit((atomic_ullong *volatile)&v72, memory_order_acquire);
    if (v58 == v59)
    {
      if (!v61)
      {
        MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, (CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)this, memory_order_acquire));
      }
      CFDictionaryRemoveValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v72, memory_order_acquire), v60);
    }
    else
    {
      if (!v61)
      {
        MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, (CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)this, memory_order_acquire));
      }
      CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v72, memory_order_acquire), v60, v57);
    }
  }
  StrikethroughColor = TAttributes::GetStrikethroughColor(a2, (const __CFDictionary *)&key, v56);
  if (StrikethroughColor)
  {
    CFTypeID v63 = StrikethroughColor;
    CFTypeID v64 = CFGetTypeID(StrikethroughColor);
    CFTypeID v65 = CFNullGetTypeID();
    double v66 = key;
    unint64_t v67 = atomic_load_explicit((atomic_ullong *volatile)&v72, memory_order_acquire);
    if (v64 == v65)
    {
      if (!v67)
      {
        MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, (CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)this, memory_order_acquire));
      }
      CFDictionaryRemoveValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v72, memory_order_acquire), v66);
    }
    else
    {
      if (!v67)
      {
        MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, (CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)this, memory_order_acquire));
      }
      CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v72, memory_order_acquire), v66, v63);
    }
  }
  int64x2_t v68 = CFDictionaryGetValue(a2, @"NSTextEffectsContext");
  if (v68)
  {
    int64x2_t v69 = v68;
    uint64_t v70 = TAttributes::EnsureRareData(this);
    if (!atomic_load_explicit((atomic_ullong *volatile)&v72, memory_order_acquire))
    {
      MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, (CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)this, memory_order_acquire));
    }
    CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v72, memory_order_acquire), @"NSTextEffectsContext", v69);
    *(void *)(v70 + 32) = v69;
  }
  if (atomic_load_explicit((atomic_ullong *volatile)&v72, memory_order_acquire)) {
}
  }

const void *TAttributes::GetUnderlineColor(TAttributes *this, const __CFDictionary *a2, const __CFString **a3)
{
  uint64_t v5 = @"CTUnderlineColor";
  __n128 result = CFDictionaryGetValue(this, @"CTUnderlineColor");
  if (a2 && result
    || !result
    && (uint64_t v5 = @"NSUnderlineColor", result = CFDictionaryGetValue(this, @"NSUnderlineColor"), a2)
    && result)
  {
    *(void *)a2 = v5;
  }
  return result;
}

const void *TAttributes::GetStrikethroughColor(TAttributes *this, const __CFDictionary *a2, const __CFString **a3)
{
  uint64_t v5 = @"CTStrikethroughColor";
  __n128 result = CFDictionaryGetValue(this, @"CTStrikethroughColor");
  if (a2 && result
    || !result
    && (uint64_t v5 = @"NSStrikethroughColor", result = CFDictionaryGetValue(this, @"NSStrikethroughColor"), a2)
    && result)
  {
    *(void *)a2 = v5;
  }
  return result;
}

const void *TAttributes::GetForegroundColor(TAttributes *this, const __CFDictionary *a2, const __CFString **a3)
{
  __n128 result = CFDictionaryGetValue(this, @"CTForegroundColor");
  if (!result)
  {
    return CFDictionaryGetValue(this, @"NSColor");
  }
  return result;
}

const void *TAttributes::GetStrokeColor(TAttributes *this, const __CFDictionary *a2, const __CFString **a3)
{
  uint64_t v5 = @"CTStrokeColor";
  __n128 result = CFDictionaryGetValue(this, @"CTStrokeColor");
  if (a2 && result
    || !result
    && (uint64_t v5 = @"NSStrokeColor", result = CFDictionaryGetValue(this, @"NSStrokeColor"), a2)
    && result)
  {
    *(void *)a2 = v5;
  }
  return result;
}

uint64_t std::vector<std::tuple<TRun const*,CFRange,TAttributes>,TInlineBufferAllocator<std::tuple<TRun const*,CFRange,TAttributes>,30ul>>::emplace_back<TRun const*&,CFRange&,TAttributes>(char **a1, void *a2, long long *a3, uint64_t a4)
{
  unint64_t v9 = (unint64_t)a1[1];
  unint64_t v8 = (unint64_t)a1[2];
  if (v9 < v8)
  {
    *(void *)unint64_t v9 = *a2;
    long long v10 = *a3;
    *(_OWORD *)(v9 + 24) = 0u;
    uint64_t v11 = v9 + 24;
    *(_OWORD *)(v11 - 16) = v10;
    *(_WORD *)(v11 + 49) = 0;
    *(unsigned char *)(v11 + 51) = 0;
    *(unsigned char *)(v11 + 56) = 0;
    *(unsigned char *)(v11 + 104) = 0;
    *(void *)(v11 + 144) = 0;
    *(_OWORD *)(v11 + 16) = 0u;
    *(_OWORD *)(v11 + 32) = 0u;
    *(void *)(v11 + 120) = 0;
    *(void *)(v11 + 128) = 0;
    TAttributes::operator=(v11, a4);
    uint64_t v12 = v11 + 152;
    goto LABEL_28;
  }
  uint64_t v13 = (char *)(a1 + 3);
  uint64_t v14 = 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(v9 - (void)*a1) >> 4);
  if ((unint64_t)(v14 + 1) > 0x1745D1745D1745DLL) {
    abort();
  }
  unint64_t v15 = 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(v8 - (void)*a1) >> 4);
  uint64_t v16 = 2 * v15;
  if (2 * v15 <= v14 + 1) {
    uint64_t v16 = v14 + 1;
  }
  if (v15 >= 0xBA2E8BA2E8BA2ELL) {
    unint64_t v17 = 0x1745D1745D1745DLL;
  }
  else {
    unint64_t v17 = v16;
  }
  if (v17)
  {
    uint64_t v18 = a1[663];
    unint64_t v19 = (unint64_t)&v18[176 * v17];
    if (v19 <= (unint64_t)(a1 + 663))
    {
      a1[663] = (char *)v19;
    }
    else
    {
      if (v17 > 0x1745D1745D1745DLL) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v18 = (char *)operator new(176 * v17);
    }
  }
  else
  {
    uint64_t v18 = 0;
  }
  CFStringRef v20 = &v18[176 * v14];
  *(void *)CFStringRef v20 = *a2;
  uint64_t v21 = &v18[176 * v17];
  *(_OWORD *)(v20 + 8) = *a3;
  *(_WORD *)(v20 + 73) = 0;
  v20[75] = 0;
  v20[80] = 0;
  v20[128] = 0;
  *((void *)v20 + 21) = 0;
  *(_OWORD *)(v20 + 40) = 0u;
  *(_OWORD *)(v20 + 56) = 0u;
  *(_OWORD *)(v20 + 24) = 0u;
  *((void *)v20 + 18) = 0;
  *((void *)v20 + 19) = 0;
  TAttributes::operator=((uint64_t)(v20 + 24), a4);
  uint64_t v12 = (uint64_t)(v20 + 176);
  uint64_t v23 = *a1;
  CFTypeID v22 = a1[1];
  if (v22 == *a1)
  {
    *a1 = v20;
    a1[1] = (char *)v12;
    uint64_t v29 = a1[2];
    a1[2] = v21;
    if (!v22) {
      goto LABEL_28;
    }
    goto LABEL_23;
  }
  uint64_t v24 = 0;
  do
  {
    CFTypeID v25 = &v20[v24];
    *((void *)v25 - 22) = *(void *)&v22[v24 - 176];
    long long v26 = *(_OWORD *)&v22[v24 - 168];
    *(_OWORD *)(v25 - 152) = 0u;
    uint64_t v27 = (uint64_t)&v20[v24 - 152];
    *(_OWORD *)(v27 - 16) = v26;
    *(_WORD *)(v27 + 49) = 0;
    *(unsigned char *)(v27 + 51) = 0;
    *(unsigned char *)(v27 + 56) = 0;
    *(unsigned char *)(v27 + 104) = 0;
    *(void *)(v27 + 144) = 0;
    *(_OWORD *)(v27 + 16) = 0u;
    *(_OWORD *)(v27 + 32) = 0u;
    *(void *)(v27 + 120) = 0;
    *(void *)(v27 + 128) = 0;
    TAttributes::operator=(v27, (uint64_t)&v22[v24 - 152]);
    v24 -= 176;
  }
  while (&v22[v24] != v23);
  CFTypeID v22 = *a1;
  uint64_t v28 = a1[1];
  *a1 = &v20[v24];
  a1[1] = (char *)v12;
  uint64_t v29 = a1[2];
  a1[2] = v21;
  if (v28 != v22)
  {
    do
    {
      CFTypeID v30 = v28 - 176;
      TAttributes::~TAttributes((TAttributes *)(v28 - 152));
      uint64_t v28 = v30;
    }
    while (v30 != v22);
  }
  if (v22)
  {
LABEL_23:
    if (v13 > v22 || (CFTypeID v31 = a1 + 663, a1 + 663 <= (char **)v22))
    {
      operator delete(v22);
    }
    else if (v29 == *v31)
    {
      *CFTypeID v31 = v22;
    }
  }
LABEL_28:
  a1[1] = (char *)v12;
  return v12 - 176;
}

void TRun::DrawGlyphsAtPositionsInternal(TRun *this, CGContextRef c, CFRange a3, const CGPoint *a4, int a5, const TAttributes *a6, char a7)
{
  CFIndex length = a3.length;
  CFIndex location = a3.location;
  uint64_t v11 = this;
  uint64_t v92 = *MEMORY[0x1E4F143B8];
  if (a6) {
    uint64_t v12 = a6;
  }
  else {
    uint64_t v12 = (TRun *)((char *)this + 40);
  }
  if (a5) {
    TRun::DrawBackground(this, c, a3, v12, 1);
  }
  uint64_t v13 = *(void *)(*((void *)v11 + 27) + 16);
  uint64_t v14 = *((void *)v11 + 25);
  font = (const __CTFont *)atomic_load_explicit((atomic_ullong *volatile)v11 + 7, memory_order_acquire);
  if (!font) {
    return;
  }
  BOOL v15 = TAttributes::SetContextAttributes((atomic_ullong *)v12, c, a7);
  BOOL v16 = v15;
  uint64_t v17 = *((void *)v12 + 15);
  if (v17) {
    uint64_t v53 = *(void *)(v17 + 32);
  }
  else {
    uint64_t v53 = 0;
  }
  uint64_t v52 = v13 + 2 * v14;
  uint64_t v18 = *((void *)v11 + 39);
  if (!v18 || *(void *)(v18 + 56) == *(void *)(v18 + 64))
  {
    CTFontDrawGlyphsAtPositionsInternal((uint64_t)font, (const CGGlyph *)(v52 + 2 * location), &a4[location], length, c, (uint64_t)v11, v53);
    if (!v16) {
      return;
    }
    goto LABEL_40;
  }
  BOOL v49 = v15;
  *(void *)&long long v19 = -1;
  *((void *)&v19 + 1) = -1;
  *(_OWORD *)&v60.c = v19;
  *(_OWORD *)&v60.tdouble x = v19;
  *(_OWORD *)&v60.CGFloat a = v19;
  CGContextGetTextMatrix(&v60, c);
  *(void *)&long long v20 = -1;
  *((void *)&v20 + 1) = -1;
  *(_OWORD *)&v59.c = v20;
  *(_OWORD *)&v59.tdouble x = v20;
  *(_OWORD *)&v59.CGFloat a = v20;
  uint64_t v21 = (_OWORD *)((char *)v11 + 96);
  if (!*((unsigned char *)v11 + 144)) {
    uint64_t v21 = (_OWORD *)MEMORY[0x1E4F1DAB8];
  }
  long long v22 = v21[1];
  *(_OWORD *)&t2.CGFloat a = *v21;
  *(_OWORD *)&t2.c = v22;
  *(_OWORD *)&t2.tdouble x = v21[2];
  *(CGAffineTransform *)CGAffineTransform t1 = v60;
  CGAffineTransformConcat(&v59, (CGAffineTransform *)t1, &t2);
  if (length)
  {
    uint64_t v23 = 0;
    uint64_t v24 = (double *)(*(void *)(*((void *)v11 + 39) + 56) + 16 * location);
    CFTypeID v25 = &v24[2 * length];
    uint64_t v50 = (uint64_t)v11;
    do
    {
      long long v26 = v24;
      double v27 = *v24;
      double v28 = v24[1];
      uint64_t v29 = v24 + 2;
      while (v29 != v25)
      {
        double v30 = *v29;
        double v31 = v29[1];
        v29 += 2;
        if (v30 != v27 || v31 != v28)
        {
          uint64_t v24 = v29 - 2;
          goto LABEL_24;
        }
      }
      uint64_t v24 = v25;
LABEL_24:
      location += v23;
      uint64_t v23 = ((char *)v24 - (char *)v26) >> 4;
      if (v27 == 1.0 && v28 == 1.0)
      {
        CTFontDrawGlyphsAtPositionsInternal((uint64_t)font, (const CGGlyph *)(v52 + 2 * location), &a4[location], ((char *)v24 - (char *)v26) >> 4, c, (uint64_t)v11, v53);
      }
      else
      {
        *(void *)&long long v34 = -1;
        *((void *)&v34 + 1) = -1;
        *(_OWORD *)&matrix.c = v34;
        *(_OWORD *)&matrix.tdouble x = v34;
        *(_OWORD *)&matrix.CGFloat a = v34;
        CGAffineTransformMakeScale(&matrix, *v26, v26[1]);
        CTFontRef v35 = CTFontCreateCopyWithAttributes(font, 0.0, &matrix, 0);
        CGFloat v36 = *v26;
        CGFloat v37 = v26[1];
        *(CGAffineTransform *)CGAffineTransform t1 = v59;
        CGAffineTransformScale(&t2, (CGAffineTransform *)t1, v36, v37);
        *(_OWORD *)&v57.CGFloat a = *(_OWORD *)&t2.a;
        *(_OWORD *)&v57.c = *(_OWORD *)&t2.c;
        *(_OWORD *)&v57.tdouble x = *(_OWORD *)&v60.tx;
        CGContextSetTextMatrix(c, &v57);
        *(void *)&long long v38 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v38 + 1) = 0xAAAAAAAAAAAAAAAALL;
        long long v89 = v38;
        long long v90 = v38;
        long long v87 = v38;
        long long v88 = v38;
        long long v85 = v38;
        long long v86 = v38;
        long long v83 = v38;
        long long v84 = v38;
        long long v81 = v38;
        long long v82 = v38;
        long long v79 = v38;
        long long v80 = v38;
        long long v77 = v38;
        long long v78 = v38;
        long long v75 = v38;
        long long v76 = v38;
        long long v73 = v38;
        long long v74 = v38;
        long long v71 = v38;
        long long v72 = v38;
        long long v69 = v38;
        long long v70 = v38;
        long long v67 = v38;
        long long v68 = v38;
        long long v65 = v38;
        long long v66 = v38;
        long long v63 = v38;
        long long v64 = v38;
        *(_OWORD *)&t1[24] = v38;
        *(_OWORD *)&t1[40] = v38;
        memset(t1, 0, 24);
        unint64_t v91 = &t1[24];
        if (v24 == v26)
        {
          char v40 = 0;
        }
        else
        {
          std::vector<CGPoint,TInlineBufferAllocator<CGPoint,30ul>>::__vallocate[abi:nn180100]((char **)t1, ((char *)v24 - (char *)v26) >> 4);
          uint64_t v39 = *(void *)&t1[8];
          bzero(*(void **)&t1[8], ((char *)v24 - (char *)v26) & 0xFFFFFFFFFFFFFFF0);
          *(void *)&t1[8] = v39 + 16 * v23;
          char v40 = *(float64x2_t **)t1;
        }
        CGAffineTransform t2 = matrix;
        CGAffineTransformInvert(&v56, &t2);
        if (v24 != v26)
        {
          float64x2_t v41 = *(float64x2_t *)&v56.a;
          float64x2_t v42 = *(float64x2_t *)&v56.c;
          float64x2_t v43 = *(float64x2_t *)&v56.tx;
          CFTypeID v44 = &a4[location];
          CFTypeID v45 = v40;
          do
          {
            double x = v44->x;
            double y = v44->y;
            ++v44;
            *v45++ = vaddq_f64(v43, vmlaq_n_f64(vmulq_n_f64(v42, y), v41, x));
          }
          while (v44 != &a4[v23 + location]);
        }
        CFIndex v48 = (const CGPoint *)v40;
        uint64_t v11 = (TRun *)v50;
        CTFontDrawGlyphsAtPositionsInternal((uint64_t)v35, (const CGGlyph *)(v52 + 2 * location), v48, ((char *)v24 - (char *)v26) >> 4, c, v50, v53);
        CGAffineTransform v55 = v60;
        CGContextSetTextMatrix(c, &v55);
        *(void *)&t2.CGFloat a = t1;
        std::vector<CGPoint,TInlineBufferAllocator<CGPoint,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&t2);
      }
    }
    while (v24 != v25);
  }
  if (v49) {
LABEL_40:
  }
    CGContextRestoreGState(c);
}

__n128 CTFontDrawGlyphsAtPositionsInternal(uint64_t a1, const CGGlyph *a2, const CGPoint *a3, uint64_t a4, CGContext *a5, uint64_t a6, uint64_t a7)
{
  if (a1 && a2 && a3 && a4)
  {
    if (a5)
    {
      long long v11 = xmmword_184B89B80;
      long long v8 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
      long long v7 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 32);
      v10[0] = *MEMORY[0x1E4F1DAB8];
      v10[1] = v8;
      id v10[2] = v7;
      void v10[3] = v10[0];
      void v10[4] = v8;
      void v10[5] = v7;
      *(void *)&long long v11 = a6;
      BYTE8(v11) = 0;
      HIDWORD(v11) = 13;
      uint64_t v12 = a7;
      DrawGlyphsAtPositions(*(TBaseFont ***)(a1 + 40), a2, a3, a4, a5, (uint64_t)v10);
    }
  }
  return result;
}

double CTFontGetAdvancesForGlyphs(CTFontRef font, CTFontOrientation orientation, const CGGlyph *glyphs, CGSize *advances, CFIndex count)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  double v5 = 0.0;
  if (font && glyphs)
  {
    *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v15[28] = v10;
    v15[29] = v10;
    v15[26] = v10;
    v15[27] = v10;
    v15[24] = v10;
    v15[25] = v10;
    v15[22] = v10;
    v15[23] = v10;
    v15[20] = v10;
    v15[21] = v10;
    v15[18] = v10;
    v15[19] = v10;
    v15[16] = v10;
    v15[17] = v10;
    v15[15] = v10;
    v15[14] = v10;
    v15[13] = v10;
    v15[12] = v10;
    v15[11] = v10;
    v15[10] = v10;
    v15[9] = v10;
    v15[8] = v10;
    v15[7] = v10;
    v15[6] = v10;
    v15[4] = v10;
    void v15[5] = v10;
    v15[2] = v10;
    void v15[3] = v10;
    v15[0] = v10;
    v15[1] = v10;
    memset(v14, 0, sizeof(v14));
    BOOL v16 = v15;
    if (!advances)
    {
      std::vector<CGSize,TInlineBufferAllocator<CGSize,30ul>>::resize((uint64_t)v14, count);
      advances = (CGSize *)v14[0];
    }
    TFont::GetAdvancesForGlyphs(*((void *)font + 5), (uint64_t)glyphs, &advances->width, 2, count, orientation, 0, 0);
    double v5 = v11;
    uint64_t v13 = (void **)v14;
    std::vector<CGPoint,TInlineBufferAllocator<CGPoint,30ul>>::__destroy_vector::operator()[abi:nn180100](&v13);
  }
  return v5;
}

void DrawGlyphsAtPositions(TBaseFont **a1, const CGGlyph *a2, const CGPoint *a3, uint64_t a4, CGContext *a5, uint64_t a6)
{
  uint64_t v6 = a6;
  uint64_t v194 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *(void *)(a6 + 96);
  if (!v10)
  {
    uint64_t v19 = 0;
    id v179 = 0;
    id v178 = 0;
    uint64_t v129 = -1;
    int64x2_t v131 = 0;
    int v133 = 1;
    goto LABEL_42;
  }
  if (*(unsigned char *)(v10 + 224)) {
    int v11 = -1;
  }
  else {
    int v11 = 1;
  }
  int v133 = v11;
  id v179 = 0;
  id v178 = 0;
  int Type = *(_DWORD *)(a6 + 108);
  if (Type == 13)
  {
    int Type = CGContextGetType();
    *(_DWORD *)(v6 + 108) = Type;
  }
  if (Type != 1 || (uint64_t v13 = *(TLine **)(v10 + 272)) == 0)
  {
    uint64_t v19 = 0;
    int64x2_t v131 = 0;
    uint64_t v129 = -1;
    goto LABEL_42;
  }
  uint64_t v14 = *(void **)v13;
  (*(void (**)(unsigned char *__return_ptr, void))(**(void **)v13 + 8))(keys, *(void *)v13);

  BOOL v15 = (uint64_t *)(*(void *)(*(void *)(v10 + 216) + 48) + 8 * *(void *)(v10 + 200));
  uint64_t v16 = *(void *)(v10 + 8);
  uint64_t v134 = *(void *)(v10 + 16);
  int64x2_t v131 = v15;
  uint64_t v129 = v16;
  if (*(unsigned char *)(v10 + 224))
  {
    long long v34 = (void *)*MEMORY[0x1E4F1CFD0];
    *(void *)keys = @"rightToLeft";
    values[0] = v34;
    *(void *)&v153.CGFloat a = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)keys, (const void **)values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);

    uint64_t v19 = v134;
    goto LABEL_42;
  }
  memset(keys, 170, 16);
  CFIndex ClusterRange = TLine::GetClusterRange(v13, v14, *v15, 2, keys, 0, 0);
  uint64_t v19 = v134;
  if (ClusterRange + v18 >= v134 + v16) {
    CFIndex v20 = v134 + v16;
  }
  else {
    CFIndex v20 = ClusterRange + v18;
  }
  CFIndex v21 = v20 - v16;
  BOOL v22 = ClusterRange <= v16 && v16 < ClusterRange + v18;
  if (v22) {
    CFIndex v23 = v16;
  }
  else {
    CFIndex v23 = 0;
  }
  if (!v22) {
    CFIndex v21 = 0;
  }
  CFIndex v24 = v20 - ClusterRange;
  BOOL v25 = v16 <= ClusterRange && ClusterRange < v134 + v16;
  if (v25) {
    CFIndex v23 = ClusterRange;
  }
  if (v25) {
    CFIndex v26 = v24;
  }
  else {
    CFIndex v26 = v21;
  }
  if (v23 != ClusterRange || v26 != v18)
  {
    uint64_t v28 = *((void *)v13 + 2);
    uint64_t v29 = *((void *)v13 + 3);
    if (v29 != v28)
    {
      uint64_t v30 = 0;
      uint64_t v31 = 0;
      uint64_t v32 = (v29 - v28) >> 3;
      while (1)
      {
        uint64_t v33 = *(void *)(*(void *)(*(void *)(v28 + v30) + 40) + 208) + v31;
        if (v33 > *(uint64_t *)keys) {
          break;
        }
        v30 += 8;
        uint64_t v31 = v33;
        if (v28 + v30 == v29) {
          goto LABEL_42;
        }
      }
      uint64_t v117 = v30 >> 3;
      if (v30 >> 3 < v32)
      {
        uint64_t v118 = v28 + 8 * v117;
        if (v10 == *(void *)(*(void *)v118 + 40))
        {
          uint64_t v122 = (CGFloat *)MEMORY[0x1E4F1CFD0];
          uint64_t v123 = @"begin";
LABEL_134:
          CGFloat v124 = *v122;
          values[0] = v123;
          v153.CGFloat a = v124;
          id v189 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)values, (const void **)&v153, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);

          goto LABEL_42;
        }
        if (v118 != v29)
        {
          uint64_t v119 = 0;
          uint64_t v120 = *(void *)keys - v31 + *(void *)&keys[8];
          uint64_t v121 = 8 * v117;
          while (1)
          {
            v119 += *(void *)(*(void *)(*(void *)(v28 + v121) + 40) + 208);
            if (v119 >= v120) {
              break;
            }
            v121 += 8;
            if (v28 + v121 == v29) {
              goto LABEL_42;
            }
          }
          if (v121 >> 3 < v32 && v10 == *(void *)(*(void *)(v28 + 8 * (v121 >> 3)) + 40))
          {
            uint64_t v122 = (CGFloat *)MEMORY[0x1E4F1CFD0];
            uint64_t v123 = @"finished";
            goto LABEL_134;
          }
        }
      }
    }
  }
LABEL_42:
  *(void *)&long long v35 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v35 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v192[3] = v35;
  v192[2] = v35;
  v192[1] = v35;
  v192[0] = v35;
  id v189 = 0;
  unint64_t v190 = 0;
  uint64_t v191 = 0;
  unint64_t v193 = v192;
  v187[28] = v35;
  v187[29] = v35;
  v187[26] = v35;
  v187[27] = v35;
  v187[24] = v35;
  v187[25] = v35;
  v187[22] = v35;
  v187[23] = v35;
  v187[20] = v35;
  v187[21] = v35;
  v187[18] = v35;
  v187[19] = v35;
  v187[16] = v35;
  v187[17] = v35;
  v187[15] = v35;
  v187[14] = v35;
  v187[13] = v35;
  v187[12] = v35;
  v187[11] = v35;
  v187[10] = v35;
  v187[9] = v35;
  v187[8] = v35;
  v187[7] = v35;
  v187[6] = v35;
  v187[5] = v35;
  v187[4] = v35;
  v187[3] = v35;
  v187[2] = v35;
  v187[1] = v35;
  v187[0] = v35;
  memset(values, 0, sizeof(values));
  CFDictionaryRef v188 = v187;
  *(void *)&v150.CGFloat a = TFont::ensureSVGTableObject((TFont *)a1);
  uint64_t v135 = v19;
  if (!*(void *)&v150.a)
  {
    CGFloat v36 = (CGGlyph *)a2;
    goto LABEL_57;
  }
  memset(&keys[24], 170, 0x3C0uLL);
  memset(keys, 0, 24);
  int64x2_t v185 = &keys[24];
  CGFloat v36 = (CGGlyph *)a2;
  if (a4)
  {
    std::vector<CGRect,TInlineBufferAllocator<CGRect,30ul>>::__vallocate[abi:nn180100]((char **)keys, a4);
    uint64_t v37 = *(void *)&keys[8];
    bzero(*(void **)&keys[8], 32 * a4);
    *(void *)&keys[8] = v37 + 32 * a4;
    long long v38 = *(CGRect **)keys;
  }
  else
  {
    long long v38 = 0;
  }
  uint64_t InitializedGraphicsFont = (CGFont *)TBaseFont::GetInitializedGraphicsFont(a1[50]);
  if (!InitializedGraphicsFont || !CGFontGetGlyphBBoxes(InitializedGraphicsFont, a2, a4, v38))
  {
LABEL_56:
    *(void *)&v153.CGFloat a = keys;
    std::vector<CGRect,TInlineBufferAllocator<CGRect,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v153);
LABEL_57:
    CGAffineTransform v55 = (_OWORD *)MEMORY[0x1E4F1DAD8];
    double ColorBitmapFontTranslate = *MEMORY[0x1E4F1DAD8];
    double v57 = *(double *)(MEMORY[0x1E4F1DAD8] + 8);
    id v172 = (id)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(id *__return_ptr))(*(void *)a1[50] + 480))(&v172);
    if (atomic_load_explicit((atomic_ullong *volatile)&v172, memory_order_acquire))
    {
      memset(v171, 170, sizeof(v171));
      unint64_t explicit = (void *)atomic_load_explicit((atomic_ullong *volatile)&v172, memory_order_acquire);
      TBaseFont::GetGlyphCount(a1[50]);
      TsbixContext::TsbixContext((TsbixContext *)v171, explicit);
      if (v171[1]) {
        int v59 = (*((unsigned __int16 *)v171[1] + 1) >> 9) & 1;
      }
      else {
        int v59 = 0;
      }
      memset(&keys[24], 170, 0x3C0uLL);
      memset(keys, 0, 24);
      int64x2_t v185 = &keys[24];
      if (a4)
      {
        std::vector<CGRect,TInlineBufferAllocator<CGRect,30ul>>::__vallocate[abi:nn180100]((char **)keys, a4);
        uint64_t v60 = *(void *)&keys[8];
        bzero(*(void **)&keys[8], 32 * a4);
        *(void *)&keys[8] = v60 + 32 * a4;
      }
      if (((*(uint64_t (**)(TBaseFont *))(*(void *)a1[50] + 712))(a1[50]) & 1) != 0
        || (unint64_t v61 = *(CGRect **)keys, (v62 = (CGFont *)TBaseFont::GetInitializedGraphicsFont(a1[50])) != 0)
        && CGFontGetGlyphBBoxes(v62, v36, a4, v61))
      {
        *(void *)&long long v63 = -1;
        *((void *)&v63 + 1) = -1;
        *(_OWORD *)&v181.tdouble x = v63;
        *(_OWORD *)&v181.c = v63;
        *(_OWORD *)&v181.CGFloat a = v63;
        GetFontScaleTransform(&v181, (CGContext *)a1);
        *(void *)&long long v64 = -1;
        *((void *)&v64 + 1) = -1;
        *(_OWORD *)&v180.tdouble x = v64;
        *(_OWORD *)&v180.c = v64;
        *(_OWORD *)&v180.CGFloat a = v64;
        CGContextGetTextMatrix(&v180, a5);
        *(void *)&long long v65 = -1;
        *((void *)&v65 + 1) = -1;
        *(_OWORD *)&v176.tdouble x = v65;
        *(_OWORD *)&v176.c = v65;
        *(_OWORD *)&v176.CGFloat a = v65;
        CGContextGetCTM(&v176, a5);
        FillColorAsColor = (CGColor *)CGContextGetFillColorAsColor();
        BOOL v67 = CGColorGetAlpha(FillColorAsColor) == 0.0;
        long double ContentsScale = GetContentsScale(a5);
        double ColorBitmapFontTranslate = TFont::GetColorBitmapFontTranslate((TFont *)a1);
        double v57 = v69;
        uint64_t v158 = unk_184B8A0D8;
        unint64_t v161 = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&v153.CGFloat a = keys;
        *(void *)&v153.CGFloat b = v171;
        *(void *)&v153.c = a4;
        *(void *)&v153.double d = __PAIR64__(unk_184B8A0A4, v133);
        *(void *)&v153.tdouble x = a3;
        *(void *)&v153.tdouble y = v36;
        uint64_t v154 = a1;
        unint64_t v155 = *(void *)&ContentsScale;
        double v156 = ColorBitmapFontTranslate;
        double v157 = v69;
        LOBYTE(v158) = v67;
        CGAffineTransform v159 = v181;
        uint64_t v160 = a5;
        LOBYTE(v161) = v59;
        long long v70 = *(_OWORD *)(v6 + 80);
        long long v166 = *(_OWORD *)(v6 + 64);
        long long v167 = v70;
        long long v168 = *(_OWORD *)(v6 + 96);
        uint64_t v169 = *(void *)(v6 + 112);
        long long v71 = *(_OWORD *)(v6 + 16);
        float64x2_t v162 = *(float64x2_t *)v6;
        long long v163 = v71;
        long long v72 = *(_OWORD *)(v6 + 48);
        long long v164 = *(_OWORD *)(v6 + 32);
        long long v165 = v72;
        CGAffineTransform v170 = v176;
        _V2.D[1] = v180.b;
        float64x2_t v74 = (float64x2_t)vdupq_n_s64(0x3CB0000000000000uLL);
        int64x2_t v75 = (int64x2_t)vandq_s8((int8x16_t)vcgeq_f64(v74, vabsq_f64(vaddq_f64(*(float64x2_t *)&v180.c, (float64x2_t)xmmword_184B88D40))), (int8x16_t)vcgeq_f64(v74, vabsq_f64(vaddq_f64(*(float64x2_t *)&v180.a, (float64x2_t)xmmword_184B88D30))));
        if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v75, 1), (int8x16_t)v75).u64[0] & 0x8000000000000000) != 0)
        {
          CGAffineTransform v152 = v176;
          CGAffineTransformMakeTranslation(&v151, v180.tx, v180.ty);
        }
        else
        {
          _D3 = 0;
          __asm { FMLA            D1, D3, V2.D[1]; __y }
          double v78 = hypot(vmlad_n_f64(v180.c, 0.0, v180.a), _D1);
          CGFloat v79 = 1.0;
          if (v78 > 1.0)
          {
            CGAffineTransform t1 = v180;
            CGAffineTransformScale(&t2, &t1, 1.0 / v78, 1.0 / v78);
            CGAffineTransform v180 = t2;
            CGFloat v79 = v78;
          }
          *(void *)&long long v80 = -1;
          *((void *)&v80 + 1) = -1;
          *(_OWORD *)&v175.tdouble x = v80;
          *(_OWORD *)&v175.c = v80;
          *(_OWORD *)&v175.CGFloat a = v80;
          CGAffineTransformMakeScale(&v175, v79, v79);
          *(void *)&long long v81 = -1;
          *((void *)&v81 + 1) = -1;
          *(_OWORD *)&v150.c = v81;
          *(_OWORD *)&v150.tdouble x = v81;
          *(_OWORD *)&v150.CGFloat a = v81;
          CGAffineTransform t1 = v180;
          CGAffineTransform t2 = v176;
          CGAffineTransformConcat(&v150, &t1, &t2);
          v149[1] = v150;
          CGContextSetCTM();
          v149[0] = v150;
          v148[0] = *(float64x2_t *)&v175.a;
          v148[1] = *(float64x2_t *)&v175.c;
          v148[2] = *(float64x2_t *)&v175.tx;
          CGAffineTransform v147 = v176;
          CGContextSetCTM();
        }
      }
      *(void *)&v153.CGFloat a = keys;
      std::vector<CGRect,TInlineBufferAllocator<CGRect,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v153);

      if (!v59) {
        goto LABEL_124;
      }
    }
    if (ColorBitmapFontTranslate != 0.0 || v57 != 0.0)
    {
      CGPoint TextPosition = CGContextGetTextPosition(a5);
      CGContextSetTextPosition(a5, ColorBitmapFontTranslate + TextPosition.x, v57 + TextPosition.y);
    }
    long long v83 = *(void **)(v6 + 112);
    if (v83)
    {
      DrawGlyphsWithTextEffects(v83, v36, a3, a4, a5);
LABEL_124:

      goto LABEL_125;
    }
    if (*(unsigned char *)(v6 + 104))
    {
      CGContextGetTextMatrix(&v146, a5);
      BOOL v84 = HandleFlippedTextMatrix(a5, &v146);
    }
    else
    {
      BOOL v84 = 0;
    }
    v175.CGFloat a = -3.72066208e-103;
    (*(void (**)(CGAffineTransform *__return_ptr))(*(void *)a1[50] + 480))(&v175);
    if (!atomic_load_explicit((atomic_ullong *volatile)&v175, memory_order_acquire)
      || (CFArrayRef theArray = (const __CFArray *)TFont::GetPaletteColors((atomic_ullong *)a1),
          CFIndex Count = CFArrayGetCount(theArray),
          Count < 1))
    {

      float64x2_t v98 = *(float64x2_t *)(v6 + 16);
      int64x2_t v99 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(*(float64x2_t *)v6, (float64x2_t)xmmword_184B895C0), (int8x16_t)vceqq_f64(v98, (float64x2_t)xmmword_184B87DE0)), (int8x16_t)vceqzq_f64(*(float64x2_t *)(v6 + 32)));
      if ((vandq_s8((int8x16_t)v99, (int8x16_t)vdupq_laneq_s64(v99, 1)).u64[0] & 0x8000000000000000) != 0)
      {
        v141[0] = MEMORY[0x1E4F143A8];
        v141[1] = 3321888768;
        v141[2] = ___ZL21DrawGlyphsAtPositionsPK5TFontPKtPK7CGPointmP9CGContextRKN12_GLOBAL__N_123DrawGlyphsConfigurationE_block_invoke;
        v141[3] = &__block_descriptor_96_8_64c27_ZTS6TCFRefIPK10__CFStringE88c31_ZTS6TCFRefIPK14__CFDictionaryE_e16_v28__0___qq_8B24l;
        v141[4] = a5;
        v141[5] = v36;
        v141[6] = a3;
        v141[7] = v131;
        id v142 = (id)atomic_load_explicit((atomic_ullong *volatile)&v179, memory_order_acquire);
        uint64_t v143 = v129;
        uint64_t v144 = v135;
        id v145 = (id)atomic_load_explicit((atomic_ullong *volatile)&v178, memory_order_acquire);
        EnumerateOverlappingGlyphs((atomic_ullong *)a1[50], v36, a4, v133, (uint64_t)v141);
      }
      else
      {
        *(_OWORD *)keys = *(_OWORD *)v6;
        *(float64x2_t *)&keys[16] = v98;
        *(_OWORD *)&keys[32] = *v55;
        if (a4)
        {
          p_double y = &a3->y;
          do
          {
            CGGlyph v101 = *v36++;
            DrawVisibleGlyph(a5, v101, *(CGPoint *)(p_y - 1), (const CGAffineTransform *)keys, (const CGAffineTransform *)(v6 + 48));
            p_y += 2;
            --a4;
          }
          while (a4);
        }
      }
LABEL_122:
      if (v84) {
        RestoreFlippedTextMatrix(a5);
      }
      goto LABEL_124;
    }
    id v85 = (id)CGContextGetFillColorAsColor();
    *(void *)&long long v86 = -1;
    *((void *)&v86 + 1) = -1;
    *(_OWORD *)&t1.tdouble x = v86;
    *(_OWORD *)&t1.c = v86;
    *(_OWORD *)&t1.CGFloat a = v86;
    CGContextGetTextMatrix(&t1, a5);
    *(void *)&long long v87 = -1;
    *((void *)&v87 + 1) = -1;
    *(_OWORD *)&t2.tdouble x = v87;
    *(_OWORD *)&t2.c = v87;
    *(_OWORD *)&t2.CGFloat a = v87;
    CGContextGetCTM(&t2, a5);
    _V2.D[1] = t1.b;
    float64x2_t v89 = (float64x2_t)vdupq_n_s64(0x3CB0000000000000uLL);
    int64x2_t v90 = (int64x2_t)vandq_s8((int8x16_t)vcgeq_f64(v89, vabsq_f64(vaddq_f64(*(float64x2_t *)&t1.c, (float64x2_t)xmmword_184B88D40))), (int8x16_t)vcgeq_f64(v89, vabsq_f64(vaddq_f64(*(float64x2_t *)&t1.a, (float64x2_t)xmmword_184B88D30))));
    BOOL v125 = v84;
    CFDictionaryRef v130 = (CGAffineTransform *)(v6 + 48);
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v90, 1), (int8x16_t)v90).u64[0] & 0x8000000000000000) != 0)
    {
      long long v128 = *(_OWORD *)&t2.tx;
      long long v127 = *(_OWORD *)&t2.c;
      CGFloat b = t2.b;
      CGFloat a = t2.a;
      CGAffineTransformMakeTranslation((CGAffineTransform *)keys, t1.tx, t1.ty);
    }
    else
    {
      _D3 = 0;
      __asm { FMLA            D1, D3, V2.D[1]; __y }
      double v93 = hypot(vmlad_n_f64(t1.c, 0.0, t1.a), _D1);
      CGFloat v94 = 1.0;
      if (v93 > 1.0)
      {
        double v95 = v93;
        *(CGAffineTransform *)keys = t1;
        CGAffineTransformScale(&v153, (CGAffineTransform *)keys, 1.0 / v93, 1.0 / v93);
        CGAffineTransform t1 = v153;
        CGFloat v94 = v95;
      }
      *(CGAffineTransform *)keys = t1;
      CGAffineTransform v153 = t2;
      CGAffineTransformConcat(&v181, (CGAffineTransform *)keys, &v153);
      CGFloat a = v181.a;
      CGFloat b = v181.b;
      long long v127 = *(_OWORD *)&v181.c;
      long long v128 = *(_OWORD *)&v181.tx;
      CGAffineTransformMakeScale((CGAffineTransform *)keys, v94, v94);
    }
    double v102 = *(double *)keys;
    double v103 = *(double *)&keys[8];
    long long v104 = *(_OWORD *)&keys[16];
    long long v105 = *(_OWORD *)&keys[32];
    uint64_t Style = CGContextGetStyle();
    if (v133 >= 0) {
      uint64_t v106 = 0;
    }
    else {
      uint64_t v106 = a4 - 1;
    }
    if (v133 < 0) {
      uint64_t v107 = -1;
    }
    else {
      uint64_t v107 = a4;
    }
    uint64_t v132 = v107;
    if (v106 == v107) {
      goto LABEL_121;
    }
    uint64_t v126 = v6;
LABEL_102:
    unsigned int v108 = v36[v106];
    memset(&v176, 170, 24);
    LayerRecordsForGlyph((const __CFData *)atomic_load_explicit((atomic_ullong *volatile)&v175, memory_order_acquire), v108, &v176);
    p_double x = &a3[v106].x;
    double v110 = *p_x;
    uint64_t v111 = *((void *)p_x + 1);
    if (*(void *)&v176.a == *(void *)&v176.b)
    {
      DrawVisibleGlyph(a5, v108, *(CGPoint *)&v110, (const CGAffineTransform *)v6, v130);
      goto LABEL_118;
    }
    DrawInvisibleGlyph(a5, v108, *(CGPoint *)&v110, (const CGAffineTransform *)v6, v130);
    CGContextSaveGState(a5);
    CGAffineTransformMakeTranslation(&v181, *(double *)&v105 + *(double *)&v104 * p_x[1] + v102 * *p_x, *((double *)&v105 + 1) + *((double *)&v104 + 1) * p_x[1] + v103 * *p_x);
    *(CGAffineTransform *)keys = v181;
    v153.CGFloat a = a;
    v153.CGFloat b = b;
    *(_OWORD *)&v153.c = v127;
    *(_OWORD *)&v153.tdouble x = v128;
    CGAffineTransformConcat(&v180, (CGAffineTransform *)keys, &v153);
    CGContextSetCTM();
    if (Style) {
      CGContextBeginTransparencyLayer(a5, 0);
    }
    CGFloat v112 = v176.a;
    CGFloat v113 = v176.b;
    while (1)
    {
      if (*(void *)&v112 == *(void *)&v113)
      {
        if (Style) {
          CGContextEndTransparencyLayer(a5);
        }
        CGContextRestoreGState(a5);
        uint64_t v6 = v126;
LABEL_118:
        if (*(void *)&v176.a)
        {
          v176.CGFloat b = v176.a;
          operator delete(*(void **)&v176.a);
        }
        v106 += v133;
        if (v106 == v132)
        {
LABEL_121:

          BOOL v84 = v125;
          goto LABEL_122;
        }
        goto LABEL_102;
      }
      unsigned int v114 = (unsigned __int16)**(_WORD **)&v112;
      CFIndex v115 = *(unsigned __int16 *)(*(void *)&v112 + 2);
      CFDictionaryRef ValueAtIndex = (CGColor *)v85;
      if (v115 != 0xFFFF)
      {
        if (Count <= v115) {
          goto LABEL_113;
        }
        CFDictionaryRef ValueAtIndex = (CGColor *)CFArrayGetValueAtIndex(theArray, v115);
      }
      CGContextSetFillColorWithColor(a5, ValueAtIndex);
      *(void *)keys = 0xAAAAAAAAAAAAAAAALL;
      TFont::CreatePathForGlyph((TFont *)a1, 0, v114, keys);
      if (atomic_load_explicit((atomic_ullong *volatile)keys, memory_order_acquire))
      {
        CGContextAddPath(a5, (CGPathRef)atomic_load_explicit((atomic_ullong *volatile)keys, memory_order_acquire));
        CGContextDrawPath(a5, kCGPathFill);
      }

LABEL_113:
      *(void *)&v112 += 4;
    }
  }
  *(void *)&long long v40 = -1;
  *((void *)&v40 + 1) = -1;
  *(_OWORD *)&v181.tdouble x = v40;
  *(_OWORD *)&v181.c = v40;
  *(_OWORD *)&v181.CGFloat a = v40;
  CGContextGetTextMatrix(&v181, a5);
  *(void *)&long long v41 = -1;
  *((void *)&v41 + 1) = -1;
  *(_OWORD *)&v180.tdouble x = v41;
  *(_OWORD *)&v180.c = v41;
  *(_OWORD *)&v180.CGFloat a = v41;
  CGContextGetCTM(&v180, a5);
  unint64_t PaletteColors = TFont::GetPaletteColors((atomic_ullong *)a1);
  *(void *)&v153.CGFloat a = &v150;
  *(void *)&v153.CGFloat b = &v189;
  *(void *)&v153.c = values;
  *(void *)&v153.double d = a4;
  *(void *)&v153.tdouble x = a2;
  *(void *)&v153.tdouble y = PaletteColors;
  uint64_t v154 = (void *)a3;
  unint64_t v155 = v133 | 0xAAAAAAAA00000000;
  double v156 = *(double *)&a5;
  _V2.D[1] = v181.b;
  float64x2_t v44 = (float64x2_t)vdupq_n_s64(0x3CB0000000000000uLL);
  int64x2_t v45 = (int64x2_t)vandq_s8((int8x16_t)vcgeq_f64(v44, vabsq_f64(vaddq_f64(*(float64x2_t *)&v181.c, (float64x2_t)xmmword_184B88D40))), (int8x16_t)vcgeq_f64(v44, vabsq_f64(vaddq_f64(*(float64x2_t *)&v181.a, (float64x2_t)xmmword_184B88D30))));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v45, 1), (int8x16_t)v45).u64[0] & 0x8000000000000000) != 0)
  {
    CGAffineTransformMakeTranslation(&v177, v181.tx, v181.ty);
  }
  else
  {
    _D3 = 0;
    __asm { FMLA            D1, D3, V2.D[1]; __y }
    double v51 = hypot(vmlad_n_f64(v181.c, 0.0, v181.a), _D1);
    CGFloat v52 = 1.0;
    if (v51 > 1.0)
    {
      CGAffineTransform t1 = v181;
      CGAffineTransformScale(&t2, &t1, 1.0 / v51, 1.0 / v51);
      CGAffineTransform v181 = t2;
      CGFloat v52 = v51;
    }
    *(void *)&long long v53 = -1;
    *((void *)&v53 + 1) = -1;
    *(_OWORD *)&v176.tdouble x = v53;
    *(_OWORD *)&v176.c = v53;
    *(_OWORD *)&v176.CGFloat a = v53;
    CGAffineTransformMakeScale(&v176, v52, v52);
    *(void *)&long long v54 = -1;
    *((void *)&v54 + 1) = -1;
    *(_OWORD *)&v175.tdouble x = v54;
    *(_OWORD *)&v175.c = v54;
    *(_OWORD *)&v175.CGFloat a = v54;
    CGAffineTransform t1 = v181;
    CGAffineTransform t2 = v180;
    CGAffineTransformConcat(&v175, &t1, &t2);
    v174[3] = *(float64x2_t *)&v175.a;
    v174[4] = *(float64x2_t *)&v175.c;
    v174[5] = *(float64x2_t *)&v175.tx;
    CGContextSetCTM();
    v174[0] = *(float64x2_t *)&v176.a;
    v174[1] = *(float64x2_t *)&v176.c;
    v174[2] = *(float64x2_t *)&v176.tx;
    CGAffineTransform v173 = v180;
    CGContextSetCTM();
  }
  CGFloat v36 = (CGGlyph *)v189;
  if (v190 != v189)
  {
    a4 = (v190 - (unsigned char *)v189) >> 1;
    a3 = (const CGPoint *)values[0];
    goto LABEL_56;
  }
  *(void *)&v153.CGFloat a = keys;
  std::vector<CGRect,TInlineBufferAllocator<CGRect,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v153);
LABEL_125:
  *(void *)keys = values;
  std::vector<CGPoint,TInlineBufferAllocator<CGPoint,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)keys);
  *(void *)keys = &v189;
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)keys);
}

void std::vector<CGPoint,TInlineBufferAllocator<CGPoint,30ul>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    v1[1] = v2;
    uint64_t v3 = v1 + 63;
    if (v1 + 3 <= v2)
    {
      BOOL v4 = v3 >= v2;
      BOOL v5 = v3 == v2;
    }
    else
    {
      BOOL v4 = 0;
      BOOL v5 = 0;
    }
    if (!v5 && v4)
    {
      if (v1[2] == v1[63]) {
        *uint64_t v3 = v2;
      }
    }
    else
    {
      operator delete(v2);
    }
  }
}

void std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    v1[1] = v2;
    uint64_t v3 = (void **)((char *)v1 + 84);
    if (v1 + 3 <= v2)
    {
      BOOL v4 = v3 >= v2;
      BOOL v5 = v3 == v2;
    }
    else
    {
      BOOL v4 = 0;
      BOOL v5 = 0;
    }
    if (!v5 && v4)
    {
      if (v1[2] == v1[11]) {
        v1[11] = v2;
      }
    }
    else
    {
      operator delete(v2);
    }
  }
}

void TRun::DrawGlyphsAtPositions(TRun *a1, CGContext *a2, CFRange a3, const CGPoint *a4, const TAttributes **a5)
{
}

CFTypeID TAttributes::HandleTrackingAttribute(CFTypeID result, TAttributes **a2)
{
  if (result)
  {
    CFNumberRef v3 = (const __CFNumber *)result;
    double valuePtr = NAN;
    CFTypeID v4 = CFGetTypeID((CFTypeRef)result);
    if (v4 == CFNumberGetTypeID() || v4 == CFBooleanGetTypeID())
    {
      CFNumberGetValue(v3, kCFNumberDoubleType, &valuePtr);
    }
    else
    {
      __n128 result = CFStringGetTypeID();
      if (v4 != result) {
        return result;
      }
      double valuePtr = CFStringGetDoubleValue((CFStringRef)v3);
    }
    __n128 result = TAttributes::EnsureRareData(*a2);
    double v5 = valuePtr;
    *(double *)(result + 16) = valuePtr;
    *(unsigned char *)(result + 24) = 1;
    if (v5 != 0.0) {
      *((_WORD *)*a2 + 69) |= 0x100u;
    }
  }
  return result;
}

const __CFNumber *TAttributes::HandleKernAttribute(const __CFNumber *result, TAttributes **a2)
{
  if (result)
  {
    CFNumberRef v3 = result;
    uint64_t valuePtr = -1;
    CFTypeID v4 = CFGetTypeID(result);
    if (v4 == CFNumberGetTypeID() || v4 == CFBooleanGetTypeID())
    {
      CFNumberGetValue(v3, kCFNumberDoubleType, &valuePtr);
      DoubleCFStringRef Value = *(double *)&valuePtr;
LABEL_5:
      __n128 result = (const __CFNumber *)TAttributes::EnsureRareData(*a2);
      *(double *)__n128 result = DoubleValue;
      *((unsigned char *)result + 8) = 1;
      return result;
    }
    __n128 result = (const __CFNumber *)CFStringGetTypeID();
    if ((const __CFNumber *)v4 == result)
    {
      DoubleCFStringRef Value = CFStringGetDoubleValue((CFStringRef)v3);
      uint64_t valuePtr = *(void *)&DoubleValue;
      goto LABEL_5;
    }
  }
  return result;
}

uint64_t TAttributes::EnsureRareData(TAttributes *this)
{
  uint64_t result = *((void *)this + 15);
  if (!result) {
    operator new();
  }
  return result;
}

void RestoreFlippedTextMatrix(CGContext *a1)
{
  *(void *)&long long v2 = -1;
  *((void *)&v2 + 1) = -1;
  *(_OWORD *)&v4.c = v2;
  *(_OWORD *)&v4.tdouble x = v2;
  *(_OWORD *)&v4.CGFloat a = v2;
  CGContextGetTextMatrix(&v4, a1);
  v4.double d = -v4.d;
  CGAffineTransform v3 = v4;
  CGContextSetTextMatrix(a1, &v3);
  CGContextRestoreGState(a1);
}

char *std::vector<DecorationOverride,TInlineBufferAllocator<DecorationOverride,30ul>>::__emplace_back_slow_path<long &,CFRange &,__CFDictionary const*&>(char **a1, void *a2, long long *a3, void **a4)
{
  CGAffineTransform v4 = *a1;
  uint64_t v5 = (a1[1] - *a1) >> 5;
  unint64_t v6 = v5 + 1;
  if ((unint64_t)(v5 + 1) >> 59) {
    abort();
  }
  uint64_t v11 = (uint64_t)(a1 + 3);
  uint64_t v12 = a1[2] - v4;
  if (v12 >> 4 > v6) {
    unint64_t v6 = v12 >> 4;
  }
  if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFE0) {
    unint64_t v13 = 0x7FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v13 = v6;
  }
  uint64_t v29 = v11;
  if (v13) {
    uint64_t v14 = TInlineBufferAllocator<DecorationOverride,30ul>::allocate(v11, v13);
  }
  else {
    uint64_t v14 = 0;
  }
  BOOL v15 = &v14[32 * v5];
  CFIndex v26 = v14;
  v27.i64[0] = (uint64_t)v15;
  uint64_t v16 = &v14[32 * v13];
  uint64_t v28 = v16;
  uint64_t v17 = *a4;
  long long v18 = *a3;
  *(void *)BOOL v15 = *a2;
  *(_OWORD *)(v15 + 8) = v18;
  *((void *)v15 + 3) = v17;
  uint64_t v19 = v15 + 32;
  v27.i64[1] = (uint64_t)(v15 + 32);
  CFIndex v21 = *a1;
  unint64_t v20 = (unint64_t)a1[1];
  if ((char *)v20 == *a1)
  {
    int64x2_t v23 = vdupq_n_s64(v20);
  }
  else
  {
    do
    {
      long long v22 = *(_OWORD *)(v20 - 32);
      *((void *)v15 - 2) = *(void *)(v20 - 16);
      *((_OWORD *)v15 - 2) = v22;
      *((void *)v15 - 1) = atomic_exchange((atomic_ullong *volatile)(v20 - 8), 0);
      v15 -= 32;
      v20 -= 32;
    }
    while ((char *)v20 != v21);
    int64x2_t v23 = *(int64x2_t *)a1;
    uint64_t v19 = (char *)v27.i64[1];
    uint64_t v16 = v28;
  }
  *a1 = v15;
  a1[1] = v19;
  int64x2_t v27 = v23;
  CFIndex v24 = a1[2];
  a1[2] = v16;
  uint64_t v28 = v24;
  CFIndex v26 = (char *)v23.i64[0];
  std::__split_buffer<DecorationOverride,TInlineBufferAllocator<DecorationOverride,30ul> &>::~__split_buffer((uint64_t)&v26);
  return v19;
}

void TDelegateRun::DrawGlyphsAtPositions(double *a1, CGContext *a2, CFRange a3, const CGPoint *a4, const TAttributes **a5)
{
  if (a1[49] != 0.0) {
    TRun::DrawGlyphsAtPositionsInternal((TRun *)a1, a2, a3, a4, *(unsigned __int8 *)a5, a5[1], *((unsigned char *)a5 + 16));
  }
}

CFArrayRef CTFontCopySupportedLanguages(CTFontRef font)
{
  if (!font) {
    return 0;
  }
  (*(void (**)(id *__return_ptr))(**(void **)(*((void *)font + 5) + 400) + 336))(&v3);
  CFArrayRef v1 = (const __CFArray *)atomic_exchange((atomic_ullong *volatile)&v3, 0);

  return v1;
}

void TComponentFont::CopyLocales(TComponentFont *this@<X0>, atomic_ullong *a2@<X8>)
{
  if ((*((unsigned char *)this + 713) & 7) != 0)
  {
    id v6 = (id)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(id *__return_ptr, TComponentFont *))(*(void *)this + 184))(&v6, this);
    if (atomic_load_explicit((atomic_ullong *volatile)&v6, memory_order_acquire))
    {
      TLocaleManager::TLocaleManager((TLocaleManager *)&v5);
      CFCharacterSetRef explicit = (const __CFCharacterSet *)atomic_load_explicit((atomic_ullong *volatile)&v6, memory_order_acquire);
      TLocaleManagerImp::CopyLanguagesFromCharacterSet((atomic_ullong *)v5, explicit, 0, 0, a2);
      os_unfair_lock_unlock((os_unfair_lock_t)v5 + 6);

      return;
    }
  }
  TBaseFont::CopyLocales(this, a2);
}

void TBaseFont::CopyLocales(TBaseFont *this@<X0>, atomic_ullong *a2@<X8>)
{
  *a2 = 0xAAAAAAAAAAAAAAAALL;
  TBaseFont::CopyAttributeInternal((atomic_ullong *)this, @"NSCTFontLanguagesAttribute", &v14);
  *a2 = atomic_exchange((atomic_ullong *volatile)&v14, 0);

  if ((*((_DWORD *)this + 46) & 0x100000) == 0)
  {
    atomic_load_explicit((atomic_ullong *volatile)this + 12, memory_order_acquire);
    atomic_fetch_or_explicit((atomic_uint *volatile)this + 45, 0, memory_order_relaxed);
    atomic_fetch_or_explicit((atomic_uint *volatile)this + 46, 0x100000u, memory_order_relaxed);
  }
  if ((*((_DWORD *)this + 45) & 0x100000) != 0)
  {
    if (!atomic_load_explicit(a2, memory_order_acquire))
    {
      id v14 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, MEMORY[0x1E4F1D510]);
    }
  }
  else
  {
    TBaseFont::CopySupportedLanguagesFromMetadata((atomic_ullong *)&v14, (atomic_ullong *)this);

    if (!atomic_load_explicit(a2, memory_order_acquire))
    {
      id v14 = (id)0xAAAAAAAAAAAAAAAALL;
      (*(void (**)(id *__return_ptr, TBaseFont *))(*(void *)this + 768))(&v14, this);
      if (atomic_load_explicit((atomic_ullong *volatile)&v14, memory_order_acquire))
      {
        TBaseFont::CopyAttributeInternal((atomic_ullong *)this, @"CTCheckedLanguages", &v13);
        CGAffineTransform v4 = (void *)atomic_exchange((atomic_ullong *volatile)&v13, 0);

        CFSetRef v5 = v4;
        CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        if (v5) {
          MutableCFDictionaryRef Copy = CFSetCreateMutableCopy(v6, 0, v5);
        }
        else {
          MutableCFDictionaryRef Copy = CFSetCreateMutable(v6, 0, MEMORY[0x1E4F1D548]);
        }
        CFMutableSetRef v8 = MutableCopy;

        TLocaleManager::TLocaleManager((TLocaleManager *)&v12);
        CFCharacterSetRef explicit = (const __CFCharacterSet *)atomic_load_explicit((atomic_ullong *volatile)&v14, memory_order_acquire);
        TLocaleManagerImp::CopyLanguagesFromCharacterSet((atomic_ullong *)v12, explicit, 0, v8, &v13);

        os_unfair_lock_unlock((os_unfair_lock_t)v12 + 6);
      }
    }
    if (!atomic_load_explicit(a2, memory_order_acquire))
    {
      id v14 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, MEMORY[0x1E4F1D510]);
    }
    id v11 = (id)atomic_load_explicit(a2, memory_order_acquire);
    TBaseFont::SetAttributeInternal<TCFRef<__CFSet const*>>((atomic_ullong *)this, (atomic_ullong *)&v11, @"NSCTFontLanguagesAttribute");

    os_unfair_lock_lock_with_options();
    if (!atomic_load_explicit((atomic_ullong *volatile)this + 15, memory_order_acquire)) {
      TBaseFont::InitAttributesDict((atomic_ullong *)this);
    }
    uint64_t v10 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)this + 15, memory_order_acquire);
    if (v10) {
      CFDictionaryRemoveValue(v10, @"CTCheckedLanguages");
    }
    os_unfair_lock_unlock((os_unfair_lock_t)this + 28);
    atomic_fetch_or_explicit((atomic_uint *volatile)this + 45, 0x100000u, memory_order_relaxed);
    atomic_fetch_or_explicit((atomic_uint *volatile)this + 46, 0x100000u, memory_order_relaxed);
  }
}

void TBaseFont::CopySupportedLanguagesFromMetadata(atomic_ullong *this, atomic_ullong *a2)
{
  if ((*(unsigned int (**)(atomic_ullong *))(*a2 + 704))(a2))
  {
    *this = 0xAAAAAAAAAAAAAAAALL;
    CopyAttributeForSystemFont((const __CFString *)atomic_load_explicit(a2 + 12, memory_order_acquire), @"NSCTFontLanguagesAttribute", (const __CFString **)&v6);
    *this = atomic_exchange((atomic_ullong *volatile)&v6, 0);

    if (atomic_load_explicit(this, memory_order_acquire)) {
      return;
    }
  }
  id v6 = (id)0xAAAAAAAAAAAAAAAALL;
  TBaseFont::CopyMetadata((TBaseFont *)a2, 0, &v5);
  if (atomic_load_explicit((atomic_ullong *volatile)&v5, memory_order_acquire)) {
    CFStringRef Value = (void *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v5, memory_order_acquire), @"MTD_Typeface_Repertoire_SupportedLanguages");
  }
  else {
    CFStringRef Value = 0;
  }
  id v6 = Value;

  if (atomic_load_explicit((atomic_ullong *volatile)&v6, memory_order_acquire))
  {
    *this = atomic_exchange((atomic_ullong *volatile)&v6, 0);
  }
  else
  {

    *this = 0;
  }
}

double CTFontDescriptorGetWeight(uint64_t a1)
{
  double v1 = 0.0;
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 + 40);
    if ((*(_DWORD *)(v2 + 16) & 0x80000000) == 0) {
      TDescriptor::InitBaseFont(*(TDescriptor **)(a1 + 40), 0, 0.0);
    }
    CFCharacterSetRef explicit = (atomic_ullong *)atomic_load_explicit((atomic_ullong *volatile)(v2 + 32), memory_order_acquire);
    if (explicit)
    {
      uint64_t TraitsValues = atomic_load_explicit(explicit + 30, memory_order_acquire);
      if (TraitsValues) {
        return *(double *)(TraitsValues + 8);
      }
      uint64_t TraitsValues = TBaseFont::CreateTraitsValues((TBaseFont *)explicit);
      if (TraitsValues) {
        return *(double *)(TraitsValues + 8);
      }
    }
  }
  return v1;
}

double CTFontGetWeight(uint64_t a1)
{
  double v1 = 0.0;
  if (a1)
  {
    uint64_t v2 = *(atomic_ullong **)(*(void *)(a1 + 40) + 400);
    if (v2)
    {
      uint64_t explicit = atomic_load_explicit(v2 + 30, memory_order_acquire);
      if (explicit) {
        return *(double *)(explicit + 8);
      }
      uint64_t explicit = TBaseFont::CreateTraitsValues((TBaseFont *)v2);
      if (explicit) {
        return *(double *)(explicit + 8);
      }
    }
  }
  return v1;
}

uint64_t TBaseFont::CreateTraitsValues(TBaseFont *this)
{
  id v4 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr))(*(void *)this + 152))(&v4);
  double v1 = (TBaseFont *)atomic_exchange((atomic_ullong *volatile)&v4, 0);

  if (v1) {
    TBaseFont::CreateTraitsValuesFromTraitsDictionary(v1, v2);
  }

  return 0;
}

void TBaseFont::CreateTraitsValuesFromTraitsDictionary(TBaseFont *this, const __CFDictionary *a2)
{
}

void TTenuousComponentFont::CopyTraitsInternal(atomic_ullong *this@<X0>, atomic_ullong *a2@<X8>)
{
  *a2 = 0xAAAAAAAAAAAAAAAALL;
  TBaseFont::CopyAttributeInternal(this, @"NSCTFontTraitsAttribute", &v6);
  *a2 = atomic_exchange((atomic_ullong *volatile)&v6, 0);

  if (!atomic_load_explicit(a2, memory_order_acquire))
  {
    int v5 = 0;
    id v6 = (id)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(id *__return_ptr, atomic_ullong *, int *))(*this + 656))(&v6, this, &v5);
    if (atomic_load_explicit((atomic_ullong *volatile)&v6, memory_order_acquire))
    {
      if (!atomic_load_explicit(a2, memory_order_acquire)) {

      }
      if (atomic_load_explicit(a2, memory_order_acquire))
      {
        id v4 = (id)atomic_load_explicit(a2, memory_order_acquire);
        TBaseFont::SetAttributeInternal<TCFRef<__CFSet const*>>(this, (atomic_ullong *)&v4, @"NSCTFontTraitsAttribute");
      }
    }
  }
}

void TBaseFont::SetAttributeInternal<TCFRef<__CFSet const*>>(atomic_ullong *a1, atomic_ullong *a2, const void *a3)
{
  id v6 = (os_unfair_lock_s *)(a1 + 14);
  os_unfair_lock_lock_with_options();
  if (atomic_load_explicit(a2, memory_order_acquire) && !atomic_load_explicit(a1 + 15, memory_order_acquire)) {
    TBaseFont::InitAttributesDict(a1);
  }
  uint64_t explicit = (__CFDictionary *)atomic_load_explicit(a1 + 15, memory_order_acquire);
  if (explicit)
  {
    if (atomic_load_explicit(a2, memory_order_acquire)) {
      CFDictionarySetValue(explicit, a3, (const void *)atomic_load_explicit(a2, memory_order_acquire));
    }
    else {
      CFDictionaryRemoveValue(explicit, a3);
    }
  }

  os_unfair_lock_unlock(v6);
}

void TComponentFont::CreateTraitsValuesPerFontInfo(uint64_t a1@<X0>, _DWORD *a2@<X1>, atomic_ullong *a3@<X8>)
{
  if (!(*(unsigned int (**)(uint64_t))(*(void *)a1 + 840))(a1) || (double v6 = *(double *)(a1 + 632), v6 == 2.0))
  {
    CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)(a1 + 720), memory_order_acquire);
    if (explicit && CFDictionaryGetValue(explicit, @"FontMetrics"))
    {
      TSplicedFontDict::CreateTraitsValuesPerFontInfo((atomic_ullong *)(a1 + 720), 2.0, COERCE__INT64(2.0), COERCE_CHAR_(2.0), 0, 0, 0, a3);
    }
    else
    {
      TBaseFont::CreateTraitsValuesPerFontInfo((atomic_ullong *)a1, a2, a3);
    }
  }
  else
  {
    if (*(_DWORD *)(a1 + 652)) {
      double v7 = 0.0694444444;
    }
    else {
      double v7 = 0.0;
    }
    double v8 = *(double *)(a1 + 640);
    *a2 = 1;
    int v9 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 160))(a1);
    CFStringRef v10 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 536))(a1);
    CreateTraitValues(v6, v8, v7, v10, 1, 1, 1, v9, a3);
  }
}

void InitShapingGlyphsOnQueue(__CTFont const*,NSObject  {objcproto17OS_dispatch_queue}*)::$_0::__invoke(void *cf)
{
  if (cf)
  {
    CFDictionaryRef v2 = (TFont *)cf[5];
    if (!*((void *)v2 + 40)) {
      TFont::InitShapingGlyphs(v2);
    }
  }

  CFRelease(cf);
}

uint64_t ForEachIndex(uint64_t result, int a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  if (a2)
  {
    uint64_t v6 = result;
    if (result >= 1)
    {
      uint64_t v7 = 0;
      do
        uint64_t result = std::function<void ()(long)>::operator()(a5, v7++);
      while (v6 != v7);
    }
  }
  else
  {
    while (a3 != a4)
    {
      uint64_t v10 = *a3++;
      uint64_t result = std::function<void ()(long)>::operator()(a5, v10);
    }
  }
  return result;
}

void TASCIIDataCache::InitProps(TASCIIDataCache *this)
{
  uint64_t v1 = *MEMORY[0x1E4F143B8];
  operator new();
}

void *std::__function::__value_func<void ()(long)>::~__value_func[abi:nn180100](void *a1)
{
  CFDictionaryRef v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t TFont::IterateShapingGlyphs(uint64_t result, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  uint64_t v7 = 320;
  if (a4) {
    uint64_t v7 = 312;
  }
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(result + v7), memory_order_acquire);
  if (explicit == -1)
  {
    if (a3 >= 1)
    {
      for (uint64_t i = 0; i != a3; ++i)
        uint64_t result = std::function<void ()(long)>::operator()(a5, i);
    }
  }
  else if (a3 >= 1)
  {
    for (uint64_t j = 0; j != a3; ++j)
    {
      if ((*(unsigned __int8 *)(explicit + ((unint64_t)*(unsigned __int16 *)(a2 + 2 * j) >> 3)) >> (*(_WORD *)(a2 + 2 * j) & 7))) {
        uint64_t result = std::function<void ()(long)>::operator()(a5, j);
      }
    }
  }
  return result;
}

uint64_t std::function<void ()(long)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2) {
    return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v2 + 48))(v2, &v6);
  }
  uint64_t v4 = std::__throw_bad_function_call[abi:nn180100]();
  return std::__function::__func<TASCIIDataCache::InitProps(void)::$_1,std::allocator<TASCIIDataCache::InitProps(void)::$_1>,void ()(long)>::operator()(v4, v5);
}

uint64_t std::__function::__func<TASCIIDataCache::InitProps(void)::$_1,std::allocator<TASCIIDataCache::InitProps(void)::$_1>,void ()(long)>::operator()(uint64_t result, void *a2)
{
  *(_WORD *)(*(void *)(result + 8) + 2 * *a2) |= 0x8000u;
  return result;
}

uint64_t std::__function::__func<TASCIIDataCache::InitProps(void)::$_0,std::allocator<TASCIIDataCache::InitProps(void)::$_0>,void ()(long)>::operator()(uint64_t result, void *a2)
{
  *(_WORD *)(*(void *)(result + 8) + 2 * *a2) |= 0x10u;
  return result;
}

void TFont::InitShapingGlyphs(TFont *this)
{
  v65[4] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (atomic_ullong *)*((void *)this + 50);
  id v50 = 0;
  if (*(_DWORD *)this) {
    id v3 = @"CTFontVerticalShapingGlyphsAttribute";
  }
  else {
    id v3 = @"CTFontShapingGlyphsAttribute";
  }
  uint64_t v4 = (atomic_ullong *)((char *)this + 168);
  if (atomic_load_explicit((atomic_ullong *volatile)this + 21, memory_order_acquire))
  {
    int v5 = &kCTFontVerticalShapingGlyphsForFeatureSettingsAttribute;
    if ((*(unsigned char *)this & 1) == 0) {
      int v5 = &kCTFontShapingGlyphsForFeatureSettingsAttribute;
    }
    id v3 = *v5;
  }
  int IsSystemUIFontAndForShaping = TFont::IsSystemUIFontAndForShaping((atomic_ullong *)this, v59);
  id v49 = 0;
  unint64_t explicit = atomic_load_explicit(v4, memory_order_acquire);
  double v8 = operator new(0x30uLL);
  *double v8 = &unk_1ED061AF0;
  v8[1] = v3;
  atomic_ullong v8[2] = explicit;
  void v8[3] = &v50;
  *((unsigned char *)v8 + 32) = IsSystemUIFontAndForShaping;
  void v8[5] = &v49;
  v65[3] = v8;
  TBaseFont::AccessAttributes(v2, (uint64_t)v65);
  std::__function::__value_func<void ()(__CFDictionary *)>::~__value_func[abi:nn180100](v65);
  if (atomic_load_explicit((atomic_ullong *volatile)&v50, memory_order_acquire)) {
    goto LABEL_20;
  }
  uint64_t v9 = *((void *)this + 50);
  if ((*(_DWORD *)(v9 + 184) & 0x100) == 0) {
    TBaseFont::DetermineFontFlags(*((TBaseFont **)this + 50), 0x100u);
  }
  if ((*(_DWORD *)(v9 + 180) & 0x100) == 0 || !(*(unsigned int (**)(atomic_ullong *))(*v2 + 696))(v2)) {
    goto LABEL_20;
  }
  if (v3 != @"CTFontShapingGlyphsAttribute")
  {
    int v10 = 0;
    int v11 = 0;
    if (!@"CTFontShapingGlyphsAttribute" || !v3) {
      goto LABEL_21;
    }
    if (!CFEqual(v3, @"CTFontShapingGlyphsAttribute"))
    {
LABEL_20:
      int v10 = 0;
      int v11 = 0;
      goto LABEL_21;
    }
  }
  id v12 = (id)atomic_load_explicit((atomic_ullong *volatile)(*((void *)this + 50) + 96), memory_order_acquire);
  os_unfair_lock_lock_with_options();
  if (!qword_1EB2CE050
    || ((CFStringRef v13 = (const __CFString *)v12, (v14 = (__CFString *)v13) == 0)
      ? (CFIndex location = -1)
      : (CFIndex location = CFStringFind(v13, (CFStringRef)qword_1EB2CE050, 0).location),
        v14,
        location == -1))
  {
    int v11 = 0;
  }
  else
  {
    TCFRef<__CTFont const*>::Retain((atomic_ullong *)&v50, (id)qword_1EB2CE058);
    TCFRef<__CTFont const*>::Retain((atomic_ullong *)&v49, (id)qword_1EB2CE060);
    int v11 = 1;
  }
  int v10 = v11 ^ 1;
  os_unfair_lock_unlock((os_unfair_lock_t)&_MergedGlobals_12);

LABEL_21:
  if (!atomic_load_explicit((atomic_ullong *volatile)&v50, memory_order_acquire)
    || IsSystemUIFontAndForShaping && !atomic_load_explicit((atomic_ullong *volatile)&v49, memory_order_acquire))
  {
    CFAllocatorRef v16 = (const __CFAllocator *)*MEMORY[0x1E4F1CF90];
    uint64_t v17 = (UInt8 *)CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E4F1CF90], 0x4000, 0);
    if (!v17)
    {
      atomic_store(0xFFFFFFFFFFFFFFFFLL, (unint64_t *)this + 40);
      atomic_store(0xFFFFFFFFFFFFFFFFLL, (unint64_t *)this + 39);
      goto LABEL_67;
    }
    long long v18 = v17;
    uint64_t v19 = (char *)(v17 + 0x2000);
    bzero(v17, 0x4000uLL);
    *(void *)&long long v20 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v62[6] = v20;
    v62[5] = v20;
    BOOL v62[4] = v20;
    v62[3] = v20;
    _OWORD v62[2] = v20;
    v62[1] = v20;
    v62[0] = v20;
    unint64_t v63 = 0xAAAAAAAAAAAAAAAALL;
    long long v64 = v62;
    uint64_t v60 = 0;
    uint64_t v61 = 0;
    v58[0] = &unk_1ED061B38;
    v58[1] = v18;
    v58[2] = v19;
    v58[3] = v58;
    *(void *)int v59 = 0;
    v57[0] = &unk_1ED061B80;
    v57[1] = v18;
    v57[3] = v57;
    unsigned __int8 v21 = TAATMorphTable::AddShapingGlyphs((char *)this, (uint64_t)v58, (uint64_t)v57);
    std::__function::__value_func<void ()(void)>::~__value_func[abi:nn180100](v57);
    std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100](v58);
    if ((v21 & 1) == 0)
    {
      v56[0] = &unk_1ED061B38;
      v56[1] = v18;
      v56[2] = v19;
      void v56[3] = v56;
      v55[0] = &unk_1ED061BC8;
      v55[1] = v19;
      v55[3] = v55;
      v54[0] = &unk_1ED061C10;
      v54[1] = v59;
      _OWORD v54[3] = v54;
      v53[0] = &unk_1ED061B80;
      v53[1] = v18;
      uint64_t v53[3] = v53;
      TOpenTypeMorph::AddShapingGlyphs((uint64_t)this, (uint64_t)v56, (uint64_t)v55, (uint64_t)v54, (uint64_t)v53);
      std::__function::__value_func<void ()(void)>::~__value_func[abi:nn180100](v53);
      std::__function::__value_func<void ()>::~__value_func[abi:nn180100](v54);
      std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100](v55);
      std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100](v56);
    }
    CFAllocatorRef v22 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];

    if (IsSystemUIFontAndForShaping && !atomic_load_explicit((atomic_ullong *volatile)&v49, memory_order_acquire))
    {
      int64x2_t v23 = *(const UInt8 **)v59;
      CFIndex v24 = v60;
      if (*(int **)v59 != v60)
      {
        BOOL v25 = (int *)(*(void *)v59 + 4);
        while (v25 != v60)
        {
          int v26 = *(v25 - 1);
          int v27 = *v25++;
          if (v26 == v27)
          {
            uint64_t v28 = v25 - 2;
            while (v25 != v24)
            {
              int v29 = v26;
              int v26 = *v25;
              if (v29 != *v25)
              {
                v28[1] = v26;
                ++v28;
              }
              ++v25;
            }
            uint64_t v30 = v28 + 1;
            goto LABEL_42;
          }
        }
      }
      uint64_t v30 = v60;
LABEL_42:
      if (v24 != v30) {
        uint64_t v60 = v30;
      }
    }
    double v51 = (void **)v59;
    std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100](&v51);
    goto LABEL_46;
  }
  if (v11)
  {
LABEL_46:
    unint64_t v31 = atomic_load_explicit((atomic_ullong *volatile)this + 21, memory_order_acquire);
    uint64_t v32 = operator new(0x28uLL);
    *uint64_t v32 = &unk_1ED061C58;
    v32[1] = v3;
    void v32[2] = v31;
    v32[3] = &v50;
    v32[4] = &v49;
    v52[3] = v32;
    TBaseFont::AccessAttributes(v2, (uint64_t)v52);
    std::__function::__value_func<void ()(__CFDictionary *)>::~__value_func[abi:nn180100](v52);
  }
  BytePtr = CFDataGetBytePtr((CFDataRef)atomic_load_explicit((atomic_ullong *volatile)&v50, memory_order_acquire));
  uint64_t v34 = 0;
  long long v35 = (void *)atomic_exchange((atomic_ullong *volatile)&v50, 0);
  atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)this + 37, (unint64_t *)&v34, (unint64_t)v35, memory_order_relaxed, memory_order_relaxed);
  if (v34)
  {

    BytePtr = CFDataGetBytePtr((CFDataRef)atomic_load_explicit((atomic_ullong *volatile)this + 37, memory_order_acquire));
  }
  else
  {
  }
  if (atomic_load_explicit((atomic_ullong *volatile)&v49, memory_order_acquire))
  {
    uint64_t v36 = 0;
    unint64_t v37 = atomic_exchange((atomic_ullong *volatile)&v49, 0);
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)this + 38, (unint64_t *)&v36, v37, memory_order_relaxed, memory_order_relaxed);
    if (v36) {
      long long v38 = (void *)v37;
    }
    else {
      long long v38 = 0;
    }
  }
  *((void *)this + 39) = BytePtr + 0x2000;
  __dmb(0xBu);
  *((void *)this + 40) = BytePtr;
  if (v10)
  {
    uint64_t v39 = (__CFString *)(id)atomic_load_explicit((atomic_ullong *volatile)(*((void *)this + 50) + 96), memory_order_acquire);
    long long v40 = v39;
    if (v40)
    {
      long long v41 = v40;
      CFIndex v42 = CFStringFind(v40, @"-", 0).location;

      if (v42 < 2)
      {
LABEL_66:

        goto LABEL_67;
      }
      v66.CFIndex length = 2;
      v66.CFIndex location = v42 - 2;
      float64x2_t v43 = (__CFString *)CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v39, v66);
      os_unfair_lock_lock_with_options();
      float64x2_t v44 = (void *)qword_1EB2CE050;
      if ((__CFString *)qword_1EB2CE050 != v43)
      {
        qword_1EB2CE050 = v43;
      }
      int64x2_t v45 = (void *)atomic_load_explicit((atomic_ullong *volatile)this + 37, memory_order_acquire);
      unint64_t v46 = (void *)qword_1EB2CE058;
      if ((void *)qword_1EB2CE058 != v45)
      {
        qword_1EB2CE058 = v45;
      }
      char v47 = (void *)atomic_load_explicit((atomic_ullong *volatile)this + 38, memory_order_acquire);
      CFIndex v48 = (void *)qword_1EB2CE060;
      if ((void *)qword_1EB2CE060 != v47)
      {
        qword_1EB2CE060 = v47;
      }
      os_unfair_lock_unlock((os_unfair_lock_t)&_MergedGlobals_12);
      long long v40 = v43;
    }

    goto LABEL_66;
  }
LABEL_67:
}

void *std::__function::__value_func<void ()(__CFDictionary *)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void TBaseFont::AccessAttributes(atomic_ullong *a1, uint64_t a2)
{
  uint64_t v4 = (os_unfair_lock_s *)(a1 + 14);
  os_unfair_lock_lock_with_options();
  if (!atomic_load_explicit(a1 + 15, memory_order_acquire)) {
    TBaseFont::InitAttributesDict(a1);
  }
  unint64_t explicit = atomic_load_explicit(a1 + 15, memory_order_acquire);
  uint64_t v6 = *(void *)(a2 + 24);
  unint64_t v8 = explicit;
  if (v6)
  {
    (*(void (**)(uint64_t, unint64_t *))(*(void *)v6 + 48))(v6, &v8);
    os_unfair_lock_unlock(v4);
  }
  else
  {
    uint64_t v7 = std::__throw_bad_function_call[abi:nn180100]();
    std::__function::__func<TFont::InitShapingGlyphs(void)::$_0,std::allocator<TFont::InitShapingGlyphs(void)::$_0>,void ()(__CFDictionary *)>::operator()(v7);
  }
}

void std::__function::__func<TFont::InitShapingGlyphs(void)::$_0,std::allocator<TFont::InitShapingGlyphs(void)::$_0>,void ()(__CFDictionary *)>::operator()(uint64_t a1, const __CFDictionary **a2)
{
  CFDictionaryRef v3 = *a2;
  if (*(void *)(a1 + 16))
  {
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v3, *(const void **)(a1 + 8));
    if (!Value) {
      goto LABEL_6;
    }
    int v5 = *(const void **)(a1 + 16);
    uint64_t v6 = *(atomic_ullong **)(a1 + 24);
  }
  else
  {
    uint64_t v6 = *(atomic_ullong **)(a1 + 24);
    int v5 = *(const void **)(a1 + 8);
    CFDictionaryRef Value = v3;
  }
  uint64_t v7 = (void *)CFDictionaryGetValue(Value, v5);
  TCFRef<__CTFont const*>::Retain(v6, v7);
LABEL_6:
  if (*(unsigned char *)(a1 + 32))
  {
    unint64_t v8 = *(atomic_ullong **)(a1 + 40);
    uint64_t v9 = (void *)CFDictionaryGetValue(v3, @"CTFontLangSysListAttribute");
    TCFRef<__CTFont const*>::Retain(v8, v9);
  }
}

void TBaseFont::InitAttributesDict(atomic_ullong *this)
{
  id Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  id v5 = (id)atomic_exchange((atomic_ullong *volatile)&Mutable, 0);

  unint64_t v2 = atomic_exchange((atomic_ullong *volatile)&v5, 0);
  uint64_t v3 = 0;
  atomic_compare_exchange_strong(this + 15, (unint64_t *)&v3, v2);
  if (v3) {
    uint64_t v4 = (void *)v2;
  }
  else {
    uint64_t v4 = 0;
  }
}

void std::__function::__func<TFont::GetBoundingBoxesForGlyphs(unsigned short const*,CGRect *,long,CTFontOrientation)::$_1,std::allocator<TFont::GetBoundingBoxesForGlyphs(unsigned short const*,CGRect *,long,CTFontOrientation)::$_1>,void ()(long)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *(long long **)(a1 + 16);
  id v5 = (CGRect *)(**(void **)(a1 + 8) + 32 * *a2);
  CGRect v9 = *v5;
  long long v6 = *v4;
  long long v7 = v4[2];
  *(_OWORD *)&v8.c = v4[1];
  *(_OWORD *)&v8.tdouble x = v7;
  *(_OWORD *)&v8.CGFloat a = v6;
  CGRect v10 = CGRectApplyAffineTransform(v9, &v8);
  *id v5 = v10;
  *(CGRect *)(**(void **)(a1 + 8) + 32 * v3) = CGRectOffset(v10, **(CGFloat **)(a1 + 24), *(CGFloat *)(*(void *)(a1 + 24) + 8));
}

void *TAATMorphTable::AddShapingGlyphs(char *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  CFDataRef CommonTable = (const __CFData *)TBaseFont::GetCommonTable(*((TBaseFont **)a1 + 50), 1634561906, 0);
  if (!CommonTable) {
    return 0;
  }
  CFDataRef v7 = CommonTable;
  BytePtr = (unsigned int *)CFDataGetBytePtr(CommonTable);
  CFIndex Length = CFDataGetLength(v7);
  CGRect v10 = (char *)BytePtr + Length;
  if (BytePtr + 2 > (unsigned int *)((char *)BytePtr + Length))
  {
    std::function<void ()(void)>::operator()(a3);
    return 0;
  }
  uint64_t v32 = a3;
  memset(v43, 170, sizeof(v43));
  char v11 = *a1;
  *(void *)&v43[4] = a1;
  BOOL v12 = 1;
  LOBYTE(v43[6]) = 1;
  v40[0] = &unk_1ED05E770;
  v40[1] = BytePtr;
  *(void *)&v43[14] = TAATLookupTable::BadTable;
  *(void *)&v43[16] = 0;
  *(void *)&v43[24] = 0;
  LOWORD(v43[26]) = -1;
  LOBYTE(v43[28]) = v11 & 1;
  *(void *)&v43[8] = &unk_1ED05EB58;
  memset(&v43[38], 0, 24);
  float64x2_t v44 = &v43[44];
  _OWORD v40[2] = v10;
  long long v41 = BytePtr + 2;
  CFIndex v42 = BytePtr + 2;
  unsigned int v13 = BytePtr[1];
  if (!v13)
  {
LABEL_29:
    v40[0] = &unk_1ED05E770;
    long long v38 = (void **)&v43[38];
    std::vector<unsigned char const*,TInlineBufferAllocator<unsigned char const*,48ul>>::__destroy_vector::operator()[abi:nn180100](&v38);
    return (void *)v12;
  }
  BOOL v12 = 0;
  int v14 = 0;
  unsigned int v15 = bswap32(*BytePtr);
  unsigned int v16 = bswap32(v13);
  uint64_t v36 = (__CFString *)*MEMORY[0x1E4F1D260];
  if (v16 <= 1) {
    int v17 = 1;
  }
  else {
    int v17 = v16;
  }
  int v33 = v17;
  unsigned int v34 = v16;
  unsigned int v37 = HIWORD(v15);
  while (1)
  {
    if ((TAATMorphChainMorx::NextChain((TAATMorphChainMorx *)v40, v37) & 1) == 0)
    {
      std::function<void ()(void)>::operator()(v32);
      goto LABEL_29;
    }
    BOOL v35 = v12;
    int v18 = TAATMorphChain::ResolveFlags((TAATMorphChain *)v40, v43[0], (atomic_ullong *)a1 + 21, 0, v36);
    unsigned int v19 = v41[3];
    if (v19) {
      break;
    }
LABEL_25:
    BOOL v12 = ++v14 >= v34;
    if (v14 == v33)
    {
      BOOL v12 = 1;
      goto LABEL_29;
    }
  }
  int v20 = v18;
  unint64_t v21 = 0;
  unsigned int v22 = bswap32(v19);
  if (v22 <= 1) {
    uint64_t v23 = 1;
  }
  else {
    uint64_t v23 = v22;
  }
  while (((*(uint64_t (**)(unsigned int *))(*(void *)&v43[8] + 16))(&v43[8]) & 1) != 0)
  {
    if ((v43[10] & v20) != 0)
    {
      if (v21 < (uint64_t)(*(void *)&v43[40] - *(void *)&v43[38]) >> 3
        && (uint64_t v24 = *(void *)(*(void *)&v43[38] + 8 * v21)) != 0)
      {
        GlyphCFIndex Count = TBaseFont::GetGlyphCount(*((TBaseFont **)a1 + 50));
        if (GlyphCount >= 1)
        {
          uint64_t v26 = GlyphCount;
          for (uint64_t i = 0; i != v26; ++i)
          {
            if ((*(unsigned __int8 *)(v24 + ((unsigned __int16)i >> 3)) >> (i & 7))) {
              std::function<void ()(unsigned short,unsigned short)>::operator()(a2, i, i);
            }
          }
        }
      }
      else
      {
        std::__function::__value_func<void ()(unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)v39, a2);
        char v28 = TAATMorphSubtableMorx::AddShapingGlyphs((uint64_t)&v43[8], (uint64_t)v39);
        std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100](v39);
        if ((v28 & 1) == 0) {
          break;
        }
      }
    }
    if (++v21 == v23) {
      goto LABEL_25;
    }
  }
  uint64_t v29 = *(void *)(v32 + 24);
  if (v29)
  {
    (*(void (**)(uint64_t))(*(void *)v29 + 48))(v29);
    BOOL v12 = v35;
    goto LABEL_29;
  }
  unint64_t v31 = (void *)std::__throw_bad_function_call[abi:nn180100]();
  return std::__function::__value_func<void ()>::~__value_func[abi:nn180100](v31);
}

void *std::__function::__value_func<void ()(unsigned int)>::~__value_func[abi:nn180100](void *a1)
{
  unint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<TFont::InitShapingGlyphs(void)::$_5,std::allocator<TFont::InitShapingGlyphs(void)::$_5>,void ()(__CFDictionary *)>::operator()(uint64_t a1, const __CFDictionary **a2)
{
  CFDictionaryRef v3 = *a2;
  if (*(void *)(a1 + 16))
  {
    id v5 = (id)0xAAAAAAAAAAAAAAAALL;
    id Mutable = (id)CFDictionaryGetValue(v3, *(const void **)(a1 + 8));
    id v5 = (id)atomic_exchange((atomic_ullong *volatile)&Mutable, 0);

    if (!atomic_load_explicit((atomic_ullong *volatile)&v5, memory_order_acquire))
    {
      id Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      id v4 = (id)atomic_exchange((atomic_ullong *volatile)&Mutable, 0);

      if (!atomic_load_explicit((atomic_ullong *volatile)&v5, memory_order_acquire))
      {

        return;
      }
      CFDictionarySetValue(v3, *(const void **)(a1 + 8), (const void *)atomic_load_explicit((atomic_ullong *volatile)&v5, memory_order_acquire));
    }
    CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v5, memory_order_acquire), *(const void **)(a1 + 16), (const void *)atomic_load_explicit(*(atomic_ullong *volatile *)(a1 + 24), memory_order_acquire));
  }
  else
  {
    CFDictionarySetValue(v3, *(const void **)(a1 + 8), (const void *)atomic_load_explicit(*(atomic_ullong *volatile *)(a1 + 24), memory_order_acquire));
  }
  if (atomic_load_explicit(*(atomic_ullong *volatile *)(a1 + 32), memory_order_acquire)) {
    CFDictionarySetValue(v3, @"CTFontLangSysListAttribute", (const void *)atomic_load_explicit(*(atomic_ullong *volatile *)(a1 + 32), memory_order_acquire));
  }
}

uint64_t TOpenTypeMorph::AddShapingGlyphs(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v24[4] = *MEMORY[0x1E4F143B8];
  uint64_t CommonTable = TBaseFont::GetCommonTable(*(TBaseFont **)(a1 + 400), 1196643650, 0);
  uint64_t v23 = CommonTable;
  if (!CommonTable) {
    return 1;
  }
  CFDataRef v11 = (const __CFData *)CommonTable;
  CFDataRef v12 = (const __CFData *)TBaseFont::GetCommonTable(*(TBaseFont **)(a1 + 400), 1195656518, 0);
  *(void *)&long long v13 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v22[3] = v13;
  v22[4] = v13;
  v22[1] = v13;
  v22[2] = v13;
  v22[0] = v13;
  OTL::GDEF::GDEF((OTL::GDEF *)v22, v12);
  BytePtr = CFDataGetBytePtr(v11);
  unint64_t v21 = BytePtr;
  unsigned int v15 = CFDataGetBytePtr(v11);
  if (v15) {
    unint64_t v16 = (unint64_t)&v15[CFDataGetLength(v11)];
  }
  else {
    unint64_t v16 = 0;
  }
  unint64_t v20 = v16;
  int v18 = operator new(0x50uLL);
  *int v18 = &unk_1ED060ED8;
  v18[1] = &v21;
  _OWORD v18[2] = &v20;
  void v18[3] = a1;
  v18[4] = &v23;
  void v18[5] = v22;
  v18[6] = a4;
  v18[7] = a3;
  v18[8] = a2;
  v18[9] = a5;
  v24[3] = v18;
  uint64_t v17 = OTL::GCommon::IterateScriptTables((uint64_t)BytePtr, v16, (uint64_t)v24);
  std::__function::__value_func<BOOL ()(unsigned int,OTL::ScriptTable const*,BOOL &)>::~__value_func[abi:nn180100](v24);
  return v17;
}

uint64_t OTL::GCommon::IterateScriptTables(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unsigned int v3 = *(unsigned __int16 *)(a1 + 4);
  if (*(_WORD *)(a1 + 4))
  {
    uint64_t v5 = __rev16(v3);
    long long v6 = (_WORD *)(a1 + v5);
    unint64_t v7 = a1 + v5 + 2;
    if (v7 > a2) {
      goto LABEL_21;
    }
    unint64_t v9 = __rev16((unsigned __int16)*v6);
    unint64_t v10 = v7 + 6 * v9;
    if (v10 >= v7 && v10 <= a2) {
      goto LABEL_26;
    }
    unint64_t v12 = (a2 - v7) / 6;
    if ((unint64_t)(v6 + 4) > a2) {
      unint64_t v12 = 0;
    }
    if (v12 != v9)
    {
LABEL_21:
      LOBYTE(v3) = 0;
    }
    else
    {
LABEL_26:
      if (*v6)
      {
        uint64_t v13 = 0;
        BOOL v14 = 0;
        if (v9 <= 1) {
          uint64_t v15 = 1;
        }
        else {
          uint64_t v15 = v9;
        }
        unint64_t v16 = (unsigned __int16 *)(v5 + a1 + 6);
        do
        {
          uint64_t v17 = (uint64_t)v6 + (bswap32(*v16) >> 16);
          if (v17 + 4 > a2) {
            break;
          }
          int v18 = std::function<BOOL ()(unsigned int,OTL::ScriptTable const*,BOOL &)>::operator()(a3, bswap32(*((_DWORD *)v16 - 1)), v17);
          if (!v18) {
            goto LABEL_20;
          }
          BOOL v14 = ++v13 >= v9;
          v16 += 3;
        }
        while (v15 != v13);
        LOBYTE(v18) = 0;
LABEL_20:
        LOBYTE(v3) = v14 | v18;
      }
      else
      {
        LOBYTE(v3) = 1;
      }
    }
  }
  return v3 & 1;
}

uint64_t std::function<BOOL ()(unsigned int,OTL::ScriptTable const*,BOOL &)>::operator()(uint64_t a1, int a2, uint64_t a3)
{
  int v7 = a2;
  uint64_t v6 = a3;
  uint64_t v3 = *(void *)(a1 + 24);
  if (v3) {
    return (*(uint64_t (**)(uint64_t, int *, uint64_t *))(*(void *)v3 + 48))(v3, &v7, &v6);
  }
  uint64_t v5 = std::__throw_bad_function_call[abi:nn180100]();
  return std::__function::__func<TOpenTypeMorph::AddShapingGlyphs(TFont const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()>,std::function<void ()(void)>)::$_0,std::allocator<TOpenTypeMorph::AddShapingGlyphs(TFont const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()>,std::function<void ()(void)>)::$_0>,BOOL ()(unsigned int,OTL::ScriptTable const*,BOOL &)>::operator()(v5);
}

uint64_t std::__function::__func<TOpenTypeMorph::AddShapingGlyphs(TFont const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(unsigned int)>,std::function<void ()(void)>)::$_0,std::allocator<TOpenTypeMorph::AddShapingGlyphs(TFont const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(unsigned int)>,std::function<void ()(void)>)::$_0>,BOOL ()(unsigned int,OTL::ScriptTable const*,BOOL &)>::operator()(uint64_t a1, int *a2, unsigned __int16 **a3)
{
  v13[4] = *MEMORY[0x1E4F143B8];
  int v4 = *a2;
  uint64_t v5 = *a3;
  unint64_t v6 = **(void **)(a1 + 8);
  unint64_t v7 = **(void **)(a1 + 16);
  uint64_t v8 = *(void *)(a1 + 72);
  unint64_t v9 = operator new(0x48uLL);
  *(void *)unint64_t v9 = &unk_1ED062168;
  id v9[2] = v4;
  long long v10 = *(_OWORD *)(a1 + 40);
  *((_OWORD *)v9 + 1) = *(_OWORD *)(a1 + 24);
  *((_OWORD *)v9 + 2) = v10;
  *((_OWORD *)v9 + 3) = *(_OWORD *)(a1 + 56);
  *((void *)v9 + 8) = v8;
  void v13[3] = v9;
  uint64_t v11 = OTL::GCommon::IterateLangSysTables(v6, v5, v7, (uint64_t)v13);
  std::__function::__value_func<BOOL ()(unsigned int,OTL::LangSysTable const*,BOOL &)>::~__value_func[abi:nn180100](v13);
  return v11;
}

uint64_t OTL::GCommon::IterateLangSysTables(unint64_t a1, unsigned __int16 *a2, unint64_t a3, uint64_t a4)
{
  uint64_t v8 = a2 + 2;
  if ((unint64_t)(a2 + 2) < a1
    || ((unsigned int v9 = a2[1],
         LODWORD(v10) = __rev16(v9),
         unint64_t v11 = (unint64_t)&v8[3 * v10],
         v11 >= (unint64_t)v8)
      ? (BOOL v12 = v11 > a3)
      : (BOOL v12 = 1),
        v12))
  {
    if ((unint64_t)v8 < a1)
    {
      LODWORD(v10) = 0;
    }
    else
    {
      unint64_t v13 = (a3 - (unint64_t)v8) / 6;
      if ((unint64_t)(a2 + 5) <= a3) {
        LODWORD(v10) = v13;
      }
      else {
        LODWORD(v10) = 0;
      }
    }
    unsigned int v9 = bswap32(v10) >> 16;
  }
  if (!*a2)
  {
    if (!v9)
    {
      if (std::function<BOOL ()(unsigned int,OTL::LangSysTable const*,BOOL &)>::operator()(*(void *)(a4 + 24), 0, 0))
      {
        BOOL v24 = 1;
        LOBYTE(v39) = 1;
        goto LABEL_56;
      }
      goto LABEL_60;
    }
    goto LABEL_32;
  }
  uint64_t v14 = (uint64_t)a2 + __rev16(*a2);
  unint64_t v15 = v14 + 6;
  BOOL v16 = v14 + 4 < a1 || v15 > a3;
  if (v16
    || ((v17 = bswap32(*(unsigned __int16 *)(v14 + 4)) >> 16, unint64_t v18 = v15 + 2 * v17, v14 + 8 <= a3)
      ? (unint64_t v19 = (a3 - v15) >> 1)
      : (unint64_t v19 = 0),
        v18 <= a3 ? (BOOL v20 = v18 >= v15) : (BOOL v20 = 0),
        !v20 ? (BOOL v21 = v19 == v17) : (BOOL v21 = 1),
        !v21))
  {
LABEL_60:
    char v23 = 0;
    return v23 & 1;
  }
  unsigned int v22 = std::function<BOOL ()(unsigned int,OTL::LangSysTable const*,BOOL &)>::operator()(*(void *)(a4 + 24), 0, v14);
  char v23 = v22;
  if (v22)
  {
    if (!v9)
    {
      BOOL v24 = 1;
LABEL_55:
      LOBYTE(v39) = 1;
LABEL_56:
      char v23 = v24 | v39;
      return v23 & 1;
    }
LABEL_32:
    uint64_t v25 = 0;
    BOOL v24 = 0;
    unint64_t v26 = (unsigned __int16)v10;
    if ((v10 & 0xFFFE) != 0) {
      uint64_t v10 = (unsigned __int16)v10;
    }
    else {
      uint64_t v10 = 1;
    }
    int v27 = a2 + 4;
    char v28 = a2 + 4;
    while (1)
    {
      unsigned int v30 = *v28;
      v28 += 3;
      unsigned int v29 = v30;
      if (v30)
      {
        uint64_t v31 = (uint64_t)a2 + __rev16(v29);
        unint64_t v32 = v31 + 6;
        BOOL v33 = v31 + 4 < a1 || v32 > a3;
        if (v33
          || ((uint64_t v34 = bswap32(*(unsigned __int16 *)(v31 + 4)) >> 16, v35 = v32 + 2 * v34, v31 + 8 <= a3)
            ? (unint64_t v36 = (a3 - v32) >> 1)
            : (unint64_t v36 = 0),
              v35 <= a3 ? (BOOL v37 = v35 >= v32) : (BOOL v37 = 0),
              !v37 ? (BOOL v38 = v36 == v34) : (BOOL v38 = 1),
              !v38))
        {
          LOBYTE(v39) = 0;
          goto LABEL_56;
        }
      }
      else
      {
        uint64_t v31 = 0;
      }
      unsigned int v39 = std::function<BOOL ()(unsigned int,OTL::LangSysTable const*,BOOL &)>::operator()(*(void *)(a4 + 24), bswap32(*((_DWORD *)v27 - 1)), v31);
      if (!v39) {
        goto LABEL_56;
      }
      BOOL v24 = ++v25 >= v26;
      int v27 = v28;
      if (v10 == v25) {
        goto LABEL_55;
      }
    }
  }
  return v23 & 1;
}

void *std::function<BOOL ()(unsigned int,OTL::LangSysTable const*,BOOL &)>::operator()(uint64_t a1, int a2, uint64_t a3)
{
  int v6 = a2;
  uint64_t v5 = a3;
  if (a1) {
    return (void *)(*(uint64_t (**)(uint64_t, int *, uint64_t *))(*(void *)a1 + 48))(a1, &v6, &v5);
  }
  int v4 = (void *)std::__throw_bad_function_call[abi:nn180100]();
  return std::__function::__value_func<BOOL ()(unsigned int,OTL::LangSysTable const*,BOOL &)>::~__value_func[abi:nn180100](v4);
}

void *std::__function::__value_func<BOOL ()(unsigned int,OTL::LangSysTable const*,BOOL &)>::~__value_func[abi:nn180100](void *a1)
{
  unint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::__function::__value_func<BOOL ()(unsigned int,OTL::ScriptTable const*,BOOL &)>::~__value_func[abi:nn180100](void *a1)
{
  unint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::vector<unsigned char const*,TInlineBufferAllocator<unsigned char const*,48ul>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = (void **)**a1;
  if (v2)
  {
    v1[1] = v2;
    uint64_t v3 = v1 + 51;
    if (v1 + 3 <= v2)
    {
      BOOL v4 = v3 >= v2;
      BOOL v5 = v3 == v2;
    }
    else
    {
      BOOL v4 = 0;
      BOOL v5 = 0;
    }
    if (!v5 && v4)
    {
      if (v1[2] == v1[51]) {
        *uint64_t v3 = v2;
      }
    }
    else
    {
      operator delete(v2);
    }
  }
}

uint64_t TAATMorphSubtableMorx::AddShapingGlyphs(uint64_t a1, uint64_t a2)
{
  uint64_t v157 = *MEMORY[0x1E4F143B8];
  unint64_t v4 = *(void *)(a1 + 104);
  unsigned int v5 = bswap32(*(_DWORD *)(v4 + 4));
  if ((v5 & 0x20000000) == 0 && *(unsigned char *)(a1 + 80) != v5 >> 31) {
    return 1;
  }
  uint64_t v6 = 0;
  switch((char)v5)
  {
    case 0:
      unint64_t v7 = *(SFNTLookupTable **)(a1 + 112);
      if (v4 + 28 > (unint64_t)v7) {
        goto LABEL_196;
      }
      unint64_t v8 = v4 + 12;
      unsigned int v9 = (const SFNTLookupTable *)(v4 + 12 + bswap32(*(_DWORD *)(v4 + 16)));
      if (&v9->fsHeader > (SFNTLookupFormatSpecificHeader *)v7) {
        goto LABEL_196;
      }
      uint64_t v6 = 0;
      switch(bswap32(v9->format) >> 16)
      {
        case 0u:
          goto LABEL_71;
        case 2u:
        case 4u:
        case 6u:
          if (v9->fsHeader.trimmedArray.valueArray > (SFNTLookupValue *)v7) {
            goto LABEL_196;
          }
          id values = (UInt8 *)&v9->fsHeader.vector + 10;
          unsigned int v11 = bswap32(v9->fsHeader.theArray.lookupValues[0]) >> 16;
          unsigned int nUnits = v9->fsHeader.segment.binSearch.nUnits;
          goto LABEL_67;
        case 8u:
          p_unsigned int searchRange = &v9->fsHeader.segment.binSearch.searchRange;
          if (v9->fsHeader.trimmedArray.valueArray > (SFNTLookupValue *)v7) {
            goto LABEL_196;
          }
          uint64_t v48 = bswap32(v9->fsHeader.segment.binSearch.nUnits) >> 16;
          unint64_t v49 = (unint64_t)&p_searchRange[v48];
          unint64_t v50 = v9->fsHeader.vector.values <= (UInt8 *)v7
              ? (unint64_t)((char *)v7 - (char *)p_searchRange) >> 1
              : 0;
          BOOL v51 = v49 <= (unint64_t)v7 && v49 >= (unint64_t)p_searchRange;
          if (!v51 && v50 != v48) {
            goto LABEL_196;
          }
          goto LABEL_71;
        case 0xAu:
          id values = v9->fsHeader.vector.values;
          if (v9->fsHeader.vector.values > (UInt8 *)v7) {
            goto LABEL_196;
          }
          unsigned int v11 = bswap32(v9->fsHeader.theArray.lookupValues[0]) >> 16;
          unsigned int nUnits = v9->fsHeader.segment.binSearch.searchRange;
LABEL_67:
          unint64_t v53 = (unint64_t)&values[(bswap32(nUnits) >> 16) * (unint64_t)v11];
          if (v53 < (unint64_t)values || v53 > (unint64_t)v7) {
            goto LABEL_196;
          }
LABEL_71:
          unsigned int v55 = bswap32(*(_DWORD *)(v4 + 12));
          unint64_t v56 = v8 + bswap32(*(_DWORD *)(v4 + 20));
          unint64_t v57 = v8 + bswap32(*(_DWORD *)(v4 + 24));
          if (v55 < 2
            || (v4 <= v56 + 2 ? (BOOL v59 = v56 + 4 > (unint64_t)v7) : (BOOL v59 = 1),
                v59
             || ((uint64_t v60 = (unsigned __int16 *)(v57 + 4 * (bswap32(*(unsigned __int16 *)(v56 + 2)) >> 16)),
                  v4 <= (unint64_t)v60)
               ? (BOOL v61 = v60 + 2 > (unsigned __int16 *)v7)
               : (BOOL v61 = 1),
                 v61)))
          {
            LOWORD(v58) = 0;
          }
          else
          {
            unsigned int v58 = bswap32(*v60) >> 16;
          }
          uint64_t v122 = TAATLookupTable::BadTable;
          uint64_t v123 = 0;
          uint64_t v124 = 0;
          __int16 v125 = -1;
          TAATLookupTable::SetTable((uint64_t)&v122, v9, v7);
          *(void *)&long long v150 = a1;
          DWORD2(v150) = v55;
          *(void *)&long long v151 = v56;
          *((void *)&v151 + 1) = v57;
          long long v62 = v152;
          std::__function::__value_func<void ()(unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)v152, a2);
          __int16 v154 = v58;
          unint64_t v63 = (char *)operator new(0x50uLL);
          long long v64 = v63;
          *(void *)unint64_t v63 = &unk_1ED0610D0;
          long long v65 = v151;
          *(_OWORD *)(v63 + 8) = v150;
          *(_OWORD *)(v63 + 24) = v65;
          if (v153)
          {
            if (v153 == v152)
            {
              *((void *)v63 + 8) = v63 + 40;
              (*(void (**)(void *))(v152[0] + 24))(v152);
              LOWORD(v58) = v154;
            }
            else
            {
              *((void *)v63 + 8) = v153;
              CGAffineTransform v153 = 0;
            }
          }
          else
          {
            *((void *)v63 + 8) = 0;
          }
          *((_WORD *)v64 + 36) = v58;
          double v156 = v64;
          uint64_t v6 = TAATLookupTable::Iterate((uint64_t)&v122, (uint64_t)v155);
          CFRange v66 = v155;
          break;
        default:
          return v6;
      }
      goto LABEL_193;
    case 1:
      unint64_t v19 = *(SFNTLookupTable **)(a1 + 112);
      if (v4 + 32 > (unint64_t)v19) {
        goto LABEL_196;
      }
      unint64_t v20 = v4 + 12;
      BOOL v21 = (const SFNTLookupTable *)(v4 + 12 + bswap32(*(_DWORD *)(v4 + 16)));
      if (&v21->fsHeader > (SFNTLookupFormatSpecificHeader *)v19) {
        goto LABEL_196;
      }
      uint64_t v6 = 0;
      switch(bswap32(v21->format) >> 16)
      {
        case 0u:
          goto LABEL_141;
        case 2u:
        case 4u:
        case 6u:
          if (v21->fsHeader.trimmedArray.valueArray > (SFNTLookupValue *)v19) {
            goto LABEL_196;
          }
          unsigned int v22 = (UInt8 *)&v21->fsHeader.vector + 10;
          unsigned int v23 = bswap32(v21->fsHeader.theArray.lookupValues[0]) >> 16;
          unsigned int searchRange = v21->fsHeader.segment.binSearch.nUnits;
          goto LABEL_137;
        case 8u:
          id v85 = &v21->fsHeader.segment.binSearch.searchRange;
          if (v21->fsHeader.trimmedArray.valueArray > (SFNTLookupValue *)v19) {
            goto LABEL_196;
          }
          uint64_t v86 = bswap32(v21->fsHeader.segment.binSearch.nUnits) >> 16;
          unint64_t v87 = (unint64_t)&v85[v86];
          unint64_t v88 = v21->fsHeader.vector.values <= (UInt8 *)v19 ? (unint64_t)((char *)v19 - (char *)v85) >> 1 : 0;
          BOOL v89 = v87 <= (unint64_t)v19 && v87 >= (unint64_t)v85;
          if (!v89 && v88 != v86) {
            goto LABEL_196;
          }
          goto LABEL_141;
        case 0xAu:
          unsigned int v22 = v21->fsHeader.vector.values;
          if (v21->fsHeader.vector.values > (UInt8 *)v19) {
            goto LABEL_196;
          }
          unsigned int v23 = bswap32(v21->fsHeader.theArray.lookupValues[0]) >> 16;
          unsigned int searchRange = v21->fsHeader.segment.binSearch.searchRange;
LABEL_137:
          unint64_t v91 = (unint64_t)&v22[(bswap32(searchRange) >> 16) * (unint64_t)v23];
          if (v91 < (unint64_t)v22 || v91 > (unint64_t)v19) {
            goto LABEL_196;
          }
LABEL_141:
          unsigned int v93 = bswap32(*(_DWORD *)(v4 + 12));
          unint64_t v94 = v20 + bswap32(*(_DWORD *)(v4 + 20));
          unint64_t v95 = v20 + bswap32(*(_DWORD *)(v4 + 24));
          if (v93 < 2
            || (v4 <= v94 + 2 ? (BOOL v97 = v94 + 4 > (unint64_t)v19) : (BOOL v97 = 1),
                v97
             || ((float64x2_t v98 = (unsigned __int16 *)(v95 + 8 * (bswap32(*(unsigned __int16 *)(v94 + 2)) >> 16)),
                  v4 <= (unint64_t)v98)
               ? (BOOL v99 = v98 + 4 > (unsigned __int16 *)v19)
               : (BOOL v99 = 1),
                 v99)))
          {
            LOWORD(v96) = 0;
          }
          else
          {
            unsigned int v96 = bswap32(*v98) >> 16;
          }
          uint64_t v122 = TAATLookupTable::BadTable;
          uint64_t v123 = 0;
          uint64_t v124 = 0;
          __int16 v125 = -1;
          TAATLookupTable::SetTable((uint64_t)&v122, v21, v19);
          *(void *)&long long v143 = a1;
          DWORD2(v143) = v93;
          *(void *)&long long v144 = v94;
          *((void *)&v144 + 1) = v95;
          long long v62 = v145;
          std::__function::__value_func<void ()(unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)v145, a2);
          __int16 v147 = v96;
          uint64_t v100 = (char *)operator new(0x50uLL);
          CGGlyph v101 = v100;
          *(void *)uint64_t v100 = &unk_1ED061118;
          long long v102 = v144;
          *(_OWORD *)(v100 + 8) = v143;
          *(_OWORD *)(v100 + 24) = v102;
          if (v146)
          {
            if (v146 == v145)
            {
              *((void *)v100 + 8) = v100 + 40;
              (*(void (**)(void *))(v145[0] + 24))(v145);
              LOWORD(v96) = v147;
            }
            else
            {
              *((void *)v100 + 8) = v146;
              CGAffineTransform v146 = 0;
            }
          }
          else
          {
            *((void *)v100 + 8) = 0;
          }
          *((_WORD *)v101 + 36) = v96;
          unint64_t v149 = v101;
          uint64_t v6 = TAATLookupTable::Iterate((uint64_t)&v122, (uint64_t)v148);
          CFRange v66 = v148;
          break;
        default:
          return v6;
      }
      goto LABEL_193;
    case 2:
      unint64_t v13 = *(SFNTLookupTable **)(a1 + 112);
      if (v4 + 40 > (unint64_t)v13) {
        goto LABEL_196;
      }
      unint64_t v14 = v4 + 12;
      unint64_t v15 = (const SFNTLookupTable *)(v4 + 12 + bswap32(*(_DWORD *)(v4 + 16)));
      if (&v15->fsHeader > (SFNTLookupFormatSpecificHeader *)v13) {
        goto LABEL_196;
      }
      uint64_t v6 = 0;
      switch(bswap32(v15->format) >> 16)
      {
        case 0u:
          goto LABEL_106;
        case 2u:
        case 4u:
        case 6u:
          if (v15->fsHeader.trimmedArray.valueArray > (SFNTLookupValue *)v13) {
            goto LABEL_196;
          }
          BOOL v16 = (UInt8 *)&v15->fsHeader.vector + 10;
          unsigned int v17 = bswap32(v15->fsHeader.theArray.lookupValues[0]) >> 16;
          unsigned int v18 = v15->fsHeader.segment.binSearch.nUnits;
          goto LABEL_102;
        case 8u:
          BOOL v67 = &v15->fsHeader.segment.binSearch.searchRange;
          if (v15->fsHeader.trimmedArray.valueArray > (SFNTLookupValue *)v13) {
            goto LABEL_196;
          }
          uint64_t v68 = bswap32(v15->fsHeader.segment.binSearch.nUnits) >> 16;
          unint64_t v69 = (unint64_t)&v67[v68];
          unint64_t v70 = v15->fsHeader.vector.values <= (UInt8 *)v13 ? (unint64_t)((char *)v13 - (char *)v67) >> 1 : 0;
          BOOL v71 = v69 <= (unint64_t)v13 && v69 >= (unint64_t)v67;
          if (!v71 && v70 != v68) {
            goto LABEL_196;
          }
          goto LABEL_106;
        case 0xAu:
          BOOL v16 = v15->fsHeader.vector.values;
          if (v15->fsHeader.vector.values > (UInt8 *)v13) {
            goto LABEL_196;
          }
          unsigned int v17 = bswap32(v15->fsHeader.theArray.lookupValues[0]) >> 16;
          unsigned int v18 = v15->fsHeader.segment.binSearch.searchRange;
LABEL_102:
          unint64_t v73 = (unint64_t)&v16[(bswap32(v18) >> 16) * (unint64_t)v17];
          if (v73 < (unint64_t)v16 || v73 > (unint64_t)v13) {
            goto LABEL_196;
          }
LABEL_106:
          unsigned int v75 = bswap32(*(_DWORD *)(v4 + 12));
          unint64_t v76 = v14 + bswap32(*(_DWORD *)(v4 + 20));
          unint64_t v77 = v14 + bswap32(*(_DWORD *)(v4 + 24));
          if (v75 < 2
            || (v4 <= v76 + 2 ? (BOOL v79 = v76 + 4 > (unint64_t)v13) : (BOOL v79 = 1),
                v79
             || ((long long v80 = (unsigned __int16 *)(v77 + 6 * (bswap32(*(unsigned __int16 *)(v76 + 2)) >> 16)),
                  v4 <= (unint64_t)v80)
               ? (BOOL v81 = v80 + 3 > (unsigned __int16 *)v13)
               : (BOOL v81 = 1),
                 v81)))
          {
            LOWORD(v78) = 0;
          }
          else
          {
            unsigned int v78 = bswap32(*v80) >> 16;
          }
          uint64_t v122 = TAATLookupTable::BadTable;
          uint64_t v123 = 0;
          uint64_t v124 = 0;
          __int16 v125 = -1;
          TAATLookupTable::SetTable((uint64_t)&v122, v15, v13);
          *(void *)&long long v136 = a1;
          DWORD2(v136) = v75;
          *(void *)&long long v137 = v76;
          *((void *)&v137 + 1) = v77;
          long long v62 = v138;
          std::__function::__value_func<void ()(unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)v138, a2);
          __int16 v140 = v78;
          long long v82 = (char *)operator new(0x50uLL);
          long long v83 = v82;
          *(void *)long long v82 = &unk_1ED061160;
          long long v84 = v137;
          *(_OWORD *)(v82 + 8) = v136;
          *(_OWORD *)(v82 + 24) = v84;
          if (v139)
          {
            if (v139 == v138)
            {
              *((void *)v82 + 8) = v82 + 40;
              (*(void (**)(void *))(v138[0] + 24))(v138);
              LOWORD(v78) = v140;
            }
            else
            {
              *((void *)v82 + 8) = v139;
              uint64_t v139 = 0;
            }
          }
          else
          {
            *((void *)v82 + 8) = 0;
          }
          *((_WORD *)v83 + 36) = v78;
          id v142 = v83;
          uint64_t v6 = TAATLookupTable::Iterate((uint64_t)&v122, (uint64_t)v141);
          CFRange v66 = v141;
          break;
        default:
          return v6;
      }
      goto LABEL_193;
    case 4:
      uint64_t v25 = *(SFNTLookupTable **)(a1 + 112);
      if (v4 + 14 > (unint64_t)v25) {
        goto LABEL_196;
      }
      uint64_t v6 = 0;
      unint64_t v26 = (const SFNTLookupTable *)(v4 + 12);
      switch(bswap32(*(unsigned __int16 *)(v4 + 12)) >> 16)
      {
        case 0u:
          goto LABEL_47;
        case 2u:
        case 4u:
        case 6u:
          if (v4 + 18 > (unint64_t)v25) {
            goto LABEL_196;
          }
          unint64_t v27 = v4 + 24;
          unsigned int v28 = bswap32(*(unsigned __int16 *)(v4 + 14)) >> 16;
          unsigned int v29 = *(unsigned __int16 *)(v4 + 16);
          goto LABEL_43;
        case 8u:
          unint64_t v36 = v4 + 18;
          if (v4 + 18 > (unint64_t)v25) {
            goto LABEL_196;
          }
          uint64_t v37 = bswap32(*(unsigned __int16 *)(v4 + 16)) >> 16;
          unint64_t v38 = v36 + 2 * v37;
          unint64_t v39 = v4 + 20 <= (unint64_t)v25 ? ((unint64_t)v25 - v36) >> 1 : 0;
          BOOL v40 = v38 <= (unint64_t)v25 && v38 >= v36;
          if (!v40 && v39 != v37) {
            goto LABEL_196;
          }
          goto LABEL_47;
        case 0xAu:
          unint64_t v27 = v4 + 20;
          if (v4 + 20 > (unint64_t)v25) {
            goto LABEL_196;
          }
          unsigned int v28 = bswap32(*(unsigned __int16 *)(v4 + 14)) >> 16;
          unsigned int v29 = *(unsigned __int16 *)(v4 + 18);
LABEL_43:
          unint64_t v42 = v27 + (bswap32(v29) >> 16) * (unint64_t)v28;
          if (v42 < v27 || v42 > (unint64_t)v25) {
            goto LABEL_196;
          }
LABEL_47:
          uint64_t v122 = TAATLookupTable::BadTable;
          uint64_t v123 = 0;
          uint64_t v124 = 0;
          __int16 v125 = -1;
          TAATLookupTable::SetTable((uint64_t)&v122, v26, v25);
          std::__function::__value_func<void ()(unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)v133, a2);
          float64x2_t v44 = operator new(0x28uLL);
          uint64_t v45 = v44;
          *float64x2_t v44 = &unk_1ED0611A8;
          if (v134)
          {
            if (v134 == v133)
            {
              v44[4] = v44 + 1;
              (*(void (**)(void *))(v133[0] + 24))(v133);
            }
            else
            {
              v44[4] = v134;
              uint64_t v134 = 0;
            }
          }
          else
          {
            v44[4] = 0;
          }
          v135[3] = v45;
          uint64_t v6 = TAATLookupTable::Iterate((uint64_t)&v122, (uint64_t)v135);
          std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100](v135);
          unint64_t v46 = v133;
          break;
        default:
          return v6;
      }
      goto LABEL_194;
    case 5:
      unsigned int v30 = *(SFNTLookupTable **)(a1 + 112);
      if (v4 + 32 > (unint64_t)v30
        || (unint64_t v31 = v4 + 12,
            unint64_t v32 = (const SFNTLookupTable *)(v4 + 12 + bswap32(*(_DWORD *)(v4 + 16))),
            &v32->fsHeader > (SFNTLookupFormatSpecificHeader *)v30))
      {
LABEL_196:
        uint64_t v6 = 0;
      }
      else
      {
        uint64_t v6 = 0;
        switch(bswap32(v32->format) >> 16)
        {
          case 0u:
            goto LABEL_176;
          case 2u:
          case 4u:
          case 6u:
            if (v32->fsHeader.trimmedArray.valueArray > (SFNTLookupValue *)v30) {
              goto LABEL_196;
            }
            BOOL v33 = (UInt8 *)&v32->fsHeader.vector + 10;
            unsigned int v34 = bswap32(v32->fsHeader.theArray.lookupValues[0]) >> 16;
            unsigned int v35 = v32->fsHeader.segment.binSearch.nUnits;
            goto LABEL_172;
          case 8u:
            double v103 = &v32->fsHeader.segment.binSearch.searchRange;
            if (v32->fsHeader.trimmedArray.valueArray > (SFNTLookupValue *)v30) {
              goto LABEL_196;
            }
            uint64_t v104 = bswap32(v32->fsHeader.segment.binSearch.nUnits) >> 16;
            unint64_t v105 = (unint64_t)&v103[v104];
            unint64_t v106 = v32->fsHeader.vector.values <= (UInt8 *)v30
                 ? (unint64_t)((char *)v30 - (char *)v103) >> 1
                 : 0;
            BOOL v107 = v105 <= (unint64_t)v30 && v105 >= (unint64_t)v103;
            if (!v107 && v106 != v104) {
              goto LABEL_196;
            }
            goto LABEL_176;
          case 0xAu:
            BOOL v33 = v32->fsHeader.vector.values;
            if (v32->fsHeader.vector.values > (UInt8 *)v30) {
              goto LABEL_196;
            }
            unsigned int v34 = bswap32(v32->fsHeader.theArray.lookupValues[0]) >> 16;
            unsigned int v35 = v32->fsHeader.segment.binSearch.searchRange;
LABEL_172:
            unint64_t v109 = (unint64_t)&v33[(bswap32(v35) >> 16) * (unint64_t)v34];
            if (v109 < (unint64_t)v33 || v109 > (unint64_t)v30) {
              goto LABEL_196;
            }
LABEL_176:
            unsigned int v111 = bswap32(*(_DWORD *)(v4 + 12));
            unint64_t v112 = v31 + bswap32(*(_DWORD *)(v4 + 20));
            unint64_t v113 = v31 + bswap32(*(_DWORD *)(v4 + 24));
            if (v111 < 2
              || (v4 <= v112 + 2 ? (BOOL v115 = v112 + 4 > (unint64_t)v30) : (BOOL v115 = 1),
                  v115
               || ((long long v116 = (unsigned __int16 *)(v113 + 8 * (bswap32(*(unsigned __int16 *)(v112 + 2)) >> 16)),
                    v4 <= (unint64_t)v116)
                 ? (BOOL v117 = v116 + 4 > (unsigned __int16 *)v30)
                 : (BOOL v117 = 1),
                   v117)))
            {
              LOWORD(v114) = 0;
            }
            else
            {
              unsigned int v114 = bswap32(*v116) >> 16;
            }
            uint64_t v122 = TAATLookupTable::BadTable;
            uint64_t v123 = 0;
            uint64_t v124 = 0;
            __int16 v125 = -1;
            TAATLookupTable::SetTable((uint64_t)&v122, v32, v30);
            *(void *)&long long v126 = a1;
            DWORD2(v126) = v111;
            *(void *)&long long v127 = v112;
            *((void *)&v127 + 1) = v113;
            long long v62 = v128;
            std::__function::__value_func<void ()(unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)v128, a2);
            __int16 v130 = v114;
            uint64_t v118 = (char *)operator new(0x50uLL);
            uint64_t v119 = v118;
            *(void *)uint64_t v118 = &unk_1ED0611F0;
            long long v120 = v127;
            *(_OWORD *)(v118 + 8) = v126;
            *(_OWORD *)(v118 + 24) = v120;
            if (v129)
            {
              if (v129 == v128)
              {
                *((void *)v118 + 8) = v118 + 40;
                (*(void (**)(void *))(v128[0] + 24))(v128);
                LOWORD(v114) = v130;
              }
              else
              {
                *((void *)v118 + 8) = v129;
                uint64_t v129 = 0;
              }
            }
            else
            {
              *((void *)v118 + 8) = 0;
            }
            *((_WORD *)v119 + 36) = v114;
            uint64_t v132 = v119;
            uint64_t v6 = TAATLookupTable::Iterate((uint64_t)&v122, (uint64_t)v131);
            CFRange v66 = v131;
            break;
          default:
            return v6;
        }
LABEL_193:
        std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100](v66);
        unint64_t v46 = v62;
LABEL_194:
        std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100](v46);
      }
      break;
    default:
      return v6;
  }
  return v6;
}

uint64_t TAATLookupTable::Iterate(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0;
  _OWORD v34[4] = *MEMORY[0x1E4F143B8];
  switch(*(_WORD *)(a1 + 48))
  {
    case 0:
      std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)v32, a2);
      unint64_t v4 = operator new(0x28uLL);
      unsigned int v5 = v4;
      void *v4 = &unk_1ED0615E0;
      if (v33)
      {
        if (v33 == v32)
        {
          v4[4] = v4 + 1;
          (*(void (**)(void *))(v32[0] + 24))(v32);
        }
        else
        {
          v4[4] = v33;
          BOOL v33 = 0;
        }
      }
      else
      {
        v4[4] = 0;
      }
      v34[3] = v5;
      if (*(void *)(a1 + 24))
      {
        uint64_t v15 = 0;
        unint64_t v16 = 0;
        do
        {
          std::function<void ()(unsigned short,unsigned short const*)>::operator()((uint64_t)v34, v16++, *(void *)(a1 + 16) + v15);
          v15 += 2;
        }
        while (v16 < *(void *)(a1 + 24));
      }
      std::__function::__value_func<void ()(unsigned short,unsigned short const*)>::~__value_func[abi:nn180100](v34);
      unsigned int v17 = v32;
      goto LABEL_35;
    case 2:
      std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)v29, a2);
      uint64_t v6 = operator new(0x28uLL);
      unint64_t v7 = v6;
      *uint64_t v6 = &unk_1ED061670;
      if (v30)
      {
        if (v30 == v29)
        {
          void v6[4] = v6 + 1;
          (*(void (**)(void *))(v29[0] + 24))(v29);
        }
        else
        {
          void v6[4] = v30;
          unsigned int v30 = 0;
        }
      }
      else
      {
        void v6[4] = 0;
      }
      v31[3] = v7;
      TAATLookupTable::IterateSegmentSingle(a1, (uint64_t)v31);
      std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short const*)>::~__value_func[abi:nn180100](v31);
      unsigned int v17 = v29;
      goto LABEL_35;
    case 4:
      v28[3] = 0;
      std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)v24, a2);
      uint64_t v8 = *(void *)(a1 + 40);
      *(void *)&long long v26 = *(void *)(a1 + 16);
      *((void *)&v26 + 1) = v8;
      unsigned int v9 = operator new(0x38uLL);
      uint64_t v10 = v9;
      *unsigned int v9 = &unk_1ED061628;
      if (v25)
      {
        if (v25 == v24)
        {
          void v9[4] = v9 + 1;
          (*(void (**)(void *))(v24[0] + 24))(v24);
        }
        else
        {
          void v9[4] = v25;
          uint64_t v25 = 0;
        }
      }
      else
      {
        void v9[4] = 0;
      }
      *(_OWORD *)(v10 + 5) = v26;
      uint64_t v27[3] = v10;
      TAATLookupTable::IterateSegmentArray(a1, (uint64_t)v28, (uint64_t)v27);
      std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short const*)>::~__value_func[abi:nn180100](v27);
      std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100](v24);
      std::__function::__value_func<void ()>::~__value_func[abi:nn180100](v28);
      goto LABEL_36;
    case 6:
      std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)v21, a2);
      unsigned int v11 = operator new(0x28uLL);
      BOOL v12 = v11;
      void *v11 = &unk_1ED061550;
      if (v22)
      {
        if (v22 == v21)
        {
          v11[4] = v11 + 1;
          (*(void (**)(void *))(v21[0] + 24))(v21);
        }
        else
        {
          v11[4] = v22;
          unsigned int v22 = 0;
        }
      }
      else
      {
        v11[4] = 0;
      }
      v23[3] = v12;
      TAATLookupTable::IterateSingleTable(a1, (uint64_t)v23);
      std::__function::__value_func<void ()(unsigned short,unsigned short const*)>::~__value_func[abi:nn180100](v23);
      unsigned int v17 = v21;
      goto LABEL_35;
    case 8:
      std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)v18, a2);
      unint64_t v13 = operator new(0x28uLL);
      unint64_t v14 = v13;
      *unint64_t v13 = &unk_1ED061598;
      if (v19)
      {
        if (v19 == v18)
        {
          v13[4] = v13 + 1;
          (*(void (**)(void *))(v18[0] + 24))(v18);
        }
        else
        {
          v13[4] = v19;
          unint64_t v19 = 0;
        }
      }
      else
      {
        v13[4] = 0;
      }
      v20[3] = v14;
      TAATLookupTable::IterateTrimmedArray(a1, (uint64_t)v20);
      std::__function::__value_func<void ()(unsigned short,unsigned short const*)>::~__value_func[abi:nn180100](v20);
      unsigned int v17 = v18;
LABEL_35:
      std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100](v17);
LABEL_36:
      uint64_t result = 1;
      break;
    default:
      return result;
  }
  return result;
}

void *std::__function::__value_func<void ()(unsigned short,unsigned short const*)>::~__value_func[abi:nn180100](void *a1)
{
  unint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#2},std::allocator<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#2}>,void ()(unsigned short,unsigned short const*)>::destroy_deallocate(void *a1)
{
  std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100](a1 + 1);

  operator delete(a1);
}

uint64_t TAATLookupTable::IterateSingleTable(uint64_t result, uint64_t a2)
{
  unint64_t v2 = *(unsigned __int16 **)(result + 16);
  if (v2[2])
  {
    uint64_t v4 = result;
    int v5 = 0;
    unint64_t v6 = (unint64_t)(v2 + 1);
    unsigned int v7 = __rev16(v2[2]);
    uint64_t v8 = bswap32(v2[1]) >> 16;
    unsigned int v9 = v2 + 6;
    do
    {
      if (v6 > (unint64_t)v9) {
        break;
      }
      if ((unint64_t)(v9 + 2) > *(void *)(v4 + 40)) {
        break;
      }
      uint64_t result = std::function<void ()(unsigned short,unsigned short const*)>::operator()(a2, bswap32(*v9) >> 16, (uint64_t)(v9 + 1));
      unsigned int v9 = (unsigned __int16 *)((char *)v9 + v8);
      ++v5;
    }
    while (v7 > (unsigned __int16)v5);
  }
  return result;
}

uint64_t std::function<void ()(unsigned short,unsigned short const*)>::operator()(uint64_t a1, __int16 a2, uint64_t a3)
{
  __int16 v7 = a2;
  uint64_t v6 = a3;
  uint64_t v3 = *(void *)(a1 + 24);
  if (v3) {
    return (*(uint64_t (**)(uint64_t, __int16 *, uint64_t *))(*(void *)v3 + 48))(v3, &v7, &v6);
  }
  uint64_t v5 = std::__throw_bad_function_call[abi:nn180100]();
  return std::__function::__func<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#2},std::allocator<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#2}>,void ()(unsigned short,unsigned short const*)>::operator()(v5);
}

uint64_t std::__function::__func<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#2},std::allocator<TAATLookupTable::Iterate(std::function<void ()(unsigned short,unsigned short,unsigned short)>)::{lambda(unsigned short,unsigned short const*)#2}>,void ()(unsigned short,unsigned short const*)>::operator()(uint64_t a1, __int16 *a2, unsigned __int16 **a3)
{
  return std::function<void ()(unsigned short,unsigned short,unsigned short)>::operator()(a1 + 8, *a2, *a2, bswap32(**a3) >> 16);
}

uint64_t TAATMorphChain::ResolveFlags(TAATMorphChain *this, uint64_t a2, atomic_ullong *a3, atomic_ullong *a4, __CFString *a5)
{
  unint64_t explicit = a5;
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  if (!a5 && *((unsigned char *)this + 64) && !atomic_load_explicit(a3, memory_order_acquire))
  {
    if (!a4 || !atomic_load_explicit(a4 + 3, memory_order_acquire)) {
      return *((unsigned int *)this + 10);
    }
    goto LABEL_5;
  }
  if (a4) {
LABEL_5:
  }
    unint64_t explicit = (__CFString *)atomic_load_explicit(a4 + 3, memory_order_acquire);
  unint64_t v36 = (__CFString *)*MEMORY[0x1E4F1D260];
  if (explicit == (__CFString *)*MEMORY[0x1E4F1D260])
  {
    int v12 = 0;
    int v13 = 43520;
    goto LABEL_46;
  }
  id v37 = 0;
  if (explicit) {
    goto LABEL_8;
  }
  unint64_t v14 = (atomic_ullong *)*((void *)this + 7);
  LOBYTE(valuePtr) = -86;
  int v12 = 0;
  int v13 = 43520;
  if (!TFont::IsSystemUIFontAndForShaping(v14, (BOOL *)&valuePtr) || !(_BYTE)valuePtr) {
    goto LABEL_45;
  }
  CopyPreferredLanguage((atomic_ullong *)&valuePtr);

  unint64_t explicit = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&v37, memory_order_acquire);
  if (explicit)
  {
LABEL_8:
    uint64_t v9 = *((void *)this + 7);
    uint64_t v10 = *(os_unfair_lock_s **)(v9 + 400);
    p_id valuePtr = (id)0xAAAAAAAAAAAAAAAALL;
    TBaseFont::RetainedObject(v10, 4, 0, &p_valuePtr);
    if (!atomic_load_explicit((atomic_ullong *volatile)&p_valuePtr, memory_order_acquire)
      && v36 != (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&p_valuePtr, memory_order_acquire))
    {
      TAATLtagTable::TAATLtagTable((TAATLtagTable *)&valuePtr, (const TBaseFont *)v10);
      TAATLtagTable::CopyLanguageTags((TAATLtagTable *)&valuePtr, &v38);

      if (!atomic_load_explicit((atomic_ullong *volatile)&p_valuePtr, memory_order_acquire)) {
        TCFRef<__CTFont const*>::Retain((atomic_ullong *)&p_valuePtr, v36);
      }
      TBaseFont::SetObject(*(os_unfair_lock_s **)(v9 + 400), 4, 0, (const void *)atomic_load_explicit((atomic_ullong *volatile)&p_valuePtr, memory_order_acquire));
    }
    if (v36 == (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&p_valuePtr, memory_order_acquire)) {
      id v11 = 0;
    }
    else {
      id v11 = (id)atomic_load_explicit((atomic_ullong *volatile)&p_valuePtr, memory_order_acquire);
    }
    id valuePtr = v11;
    CFDictionaryRef v15 = (const __CFDictionary *)atomic_exchange((atomic_ullong *volatile)&valuePtr, 0);

    if (v15)
    {
      CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v15, explicit);
      if (Value)
      {
LABEL_26:
        LOWORD(valuePtr) = -21846;
        CFNumberGetValue(Value, kCFNumberShortType, &valuePtr);
        int v13 = (unsigned __int16)valuePtr;
        int v12 = 1;
LABEL_44:

        goto LABEL_45;
      }
      *(void *)&long long v17 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v17 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v43[14] = v17;
      v43[13] = v17;
      v43[12] = v17;
      v43[11] = v17;
      v43[10] = v17;
      v43[9] = v17;
      v43[8] = v17;
      v43[7] = v17;
      v43[6] = v17;
      void v43[5] = v17;
      v43[4] = v17;
      v43[3] = v17;
      _OWORD v43[2] = v17;
      v43[1] = v17;
      v43[0] = v17;
      CFIndex Count = CFDictionaryGetCount(v15);
      id valuePtr = 0;
      long long v41 = 0;
      uint64_t v42 = 0;
      float64x2_t v44 = v43;
      if (Count)
      {
        CFIndex v19 = Count;
        std::vector<long,TInlineBufferAllocator<long,30ul>>::__vallocate[abi:nn180100](&valuePtr, Count);
        unint64_t v20 = (char *)v41;
        bzero(v41, 8 * v19);
        long long v41 = &v20[8 * v19];
        BOOL v21 = (const void **)valuePtr;
      }
      else
      {
        BOOL v21 = 0;
      }
      CFDictionaryGetKeysAndValues(v15, v21, 0);
      unsigned int v22 = (CFStringRef *)valuePtr;
      unsigned int v23 = (CFStringRef *)v41;
      if (valuePtr == v41) {
        goto LABEL_42;
      }
      CFDictionaryRef theDict = v15;
      BOOL v24 = 0;
      CFIndex v25 = 0;
      int v26 = -1;
      do
      {
        unint64_t v27 = (__CFString *)*v22;
        if (CanonicalLocaleIdentifiersMatch(*v22, explicit))
        {
          if (v26 == -1) {
            int v26 = ScriptAndLangSysFromCanonicalLanguage(explicit);
          }
          if (v26 == ScriptAndLangSysFromCanonicalLanguage(v27))
          {
            CFIndex Length = CFStringGetLength(v27);
            if (Length > v25)
            {
              CFIndex v25 = Length;
              BOOL v24 = v27;
            }
          }
        }
        ++v22;
      }
      while (v22 != v23);
      CFDictionaryRef v15 = theDict;
      if (!v24)
      {
LABEL_42:
        p_id valuePtr = &valuePtr;
        std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&p_valuePtr);
      }
      else
      {
        CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, v24);
        p_id valuePtr = &valuePtr;
        std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&p_valuePtr);
        if (Value) {
          goto LABEL_26;
        }
      }
    }
    int v12 = 0;
    int v13 = 43520;
    goto LABEL_44;
  }
  int v12 = 0;
  int v13 = 43520;
LABEL_45:

LABEL_46:
  uint64_t v29 = *((unsigned int *)this + 11);
  if (v29)
  {
    int v30 = v13 + 1;
    unint64_t v31 = (unsigned int *)(*((void *)this + 6) + 4);
    do
    {
      unsigned int v32 = bswap32(*((unsigned __int16 *)v31 - 2)) >> 16;
      unsigned int v33 = bswap32(*((unsigned __int16 *)v31 - 1)) >> 16;
      if (v32 == 27)
      {
        if (!*((unsigned char *)this + 64)
          && TBaseFont::GetShapingType(*(TBaseFont **)(*((void *)this + 7) + 400)) <= 3)
        {
          switch(v33)
          {
            case 0u:
            case 5u:
              goto LABEL_58;
            case 1u:
            case 4u:
              goto LABEL_57;
            case 2u:
            case 3u:
              break;
            default:
              JUMPOUT(0);
          }
        }
      }
      else if (v32 == 39)
      {
        if (v12 && v30 == v33)
        {
LABEL_57:
          a2 = (bswap32(*v31) | a2) & bswap32(v31[1]);
          goto LABEL_58;
        }
        if (explicit == v36)
        {
          a2 = bswap32(*v31) | a2;
          goto LABEL_58;
        }
      }
      if (TFontFeatureSettingList::IndexOfAATSetting((TFontFeatureSettingList *)a3, v32, v33) != -1) {
        goto LABEL_57;
      }
LABEL_58:
      v31 += 3;
      --v29;
    }
    while (v29);
  }
  return a2;
}

CTRunDelegateRef CTRunDelegateCreate(const CTRunDelegateCallbacks *callbacks, void *refCon)
{
  if (!callbacks || callbacks->version > 2uLL) {
    return 0;
  }
  id v10 = (id)0xAAAAAAAAAAAAAAAALL;
  if (_MergedGlobals_30 != -1) {
    dispatch_once_f(&_MergedGlobals_30, 0, (dispatch_function_t)TCFBase<TRunDelegate>::GetTypeID(void)::{lambda(void *)#1}::__invoke);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    *(void *)(Instance + 16) = CTRunDelegate::Destruct;
    *(void *)(Instance + 24) = 0;
    *(void *)(Instance + 32) = 0;
    *(void *)(Instance + 40) = Instance + 48;
    long long v5 = *(_OWORD *)&callbacks->getAscent;
    CTRunDelegateGetWidthCallback getWidth = callbacks->getWidth;
    *(_OWORD *)(Instance + 48) = *(_OWORD *)&callbacks->version;
    *(_OWORD *)(Instance + 64) = v5;
    *(void *)(Instance + 80) = getWidth;
    *(void *)(Instance + 88) = refCon;
    id v11 = (id)Instance;
    id v9 = (id)atomic_exchange((atomic_ullong *volatile)&v11, 0);
  }
  else
  {
    id v9 = 0;
  }
  id v10 = (id)atomic_exchange((atomic_ullong *volatile)&v9, 0);

  __int16 v7 = (const __CTRunDelegate *)atomic_exchange((atomic_ullong *volatile)&v10, 0);
  return v7;
}

void addPosingWithWeightAndSlant(TDescriptorSource *a1, int a2, int a3, int a4, __CFString *a5, const void *a6, atomic_ullong *a7, const void *a8, const void *a9)
{
  unint64_t v16 = (__CFString *)TDescriptorSource::UIFontNameForUIType(a1);
  id v17 = (id)0xAAAAAAAAAAAAAAAALL;
  makeStyleName((atomic_ullong *)&v17, a2, a3, 0);
  addNames(a5, (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&v17, memory_order_acquire), v16, a7);
  addMetrics(a2, a3, a4, a8, a9, a7);
  if (a6) {
    CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit(a7, memory_order_acquire), @"NSCTFontUIFontDesignTrait", a6);
  }
}

void addMetrics(int a1, int a2, int a3, const void *a4, const void *a5, atomic_ullong *a6)
{
  id Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v13 = Mutable;
  if ((a1 - 2) > 7) {
    unint64_t v14 = @"w1";
  }
  else {
    unint64_t v14 = off_1E528F480[a1 - 2];
  }
  CFDictionaryAddValue(Mutable, @"weightClass", v14);
  if (a2 == 1) {
    CFDictionaryAddValue(v13, @"italicAngle", @"12.5");
  }
  if (a3 == 1)
  {
    CFDictionaryRef v15 = @"shortTrait";
    goto LABEL_10;
  }
  if (a3 == -1)
  {
    CFDictionaryRef v15 = @"tallTrait";
LABEL_10:
    CFDictionaryAddValue(v13, v15, @"1");
  }
  if (a4 && a5) {
    CFDictionaryAddValue(v13, a4, a5);
  }
  CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit(a6, memory_order_acquire), @"FontMetrics", v13);
}

void makeStyleName(atomic_ullong *a1, int a2, int a3, __CFString *a4)
{
  if ((a2 - 1) > 8) {
    long long v5 = 0;
  }
  else {
    long long v5 = off_1E528F438[a2 - 1];
  }
  *a1 = 0;
  if (a3 && a4)
  {
    CFStringRef v6 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@ %@ %@", a4, v5, @"Italic");
LABEL_12:
    uint64_t v8 = (void *)atomic_exchange(a1, (unint64_t)v6);

    return;
  }
  if (a3)
  {
    CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    id v9 = v5;
    id v10 = @"Italic";
LABEL_11:
    CFStringRef v6 = CFStringCreateWithFormat(v7, 0, @"%@ %@", v9, v10);
    goto LABEL_12;
  }
  if (a4)
  {
    CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    id v9 = a4;
    id v10 = v5;
    goto LABEL_11;
  }

  TCFRef<__CTFont const*>::Retain(a1, v5);
}

void TAttributes::HandleForegroundCGColorAttribute(id a1, uint64_t *a2)
{
  if (a1)
  {
    uint64_t v2 = *a2;
    *(unsigned char *)(v2 + 136) = *(unsigned char *)(*a2 + 136) | 2;
    TCFRef<__CTFont const*>::Retain((atomic_ullong *)(v2 + 32), a1);
  }
}

CTRunStatus CTRunGetStatus(CTRunRef run)
{
  if (run)
  {
    uint64_t v1 = *((void *)run + 5);
    int v2 = *(unsigned char *)(v1 + 224) & 1 | (2 * (*(_DWORD *)(v1 + 256) == 2));
    if (*(unsigned char *)(v1 + 90) || *(unsigned char *)(v1 + 144)) {
      v2 |= 4u;
    }
    uint64_t v3 = *(void *)(v1 + 312);
    if (v3 && *(void *)(v3 + 56) != *(void *)(v3 + 64)) {
      v2 |= 8u;
    }
    LODWORD(run) = v2 | *(unsigned char *)(v1 + 225) & 0x10;
  }
  return run;
}

CFArrayRef CTFrameGetLines(CFArrayRef frame)
{
  if (frame) {
    return (CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)(*((void *)frame + 5) + 104), memory_order_acquire);
  }
  return frame;
}

unint64_t CTFontDescriptorCreateWithAttributesAndOptions(uint64_t a1, int a2)
{
  uint64_t v7 = a1;
  int v6 = a2;
  if (!a1) {
    return 0;
  }
  id v5 = (id)0xAAAAAAAAAAAAAAAALL;
  TCFBase_NEW<CTFontDescriptor,__CFDictionary const*&,unsigned int &>(&v4, &v7, &v6);
  id v5 = (id)atomic_exchange((atomic_ullong *volatile)&v4, 0);

  unint64_t v2 = atomic_exchange((atomic_ullong *volatile)&v5, 0);
  return v2;
}

const __CFDictionary *TSplicedFont::GetDesignUITrait(atomic_ullong *this)
{
  CFDictionaryRef result = (const __CFDictionary *)atomic_load_explicit(this + 75, memory_order_acquire);
  if (result) {
    return (const __CFDictionary *)CFDictionaryGetValue(result, @"NSCTFontUIFontDesignTrait");
  }
  return result;
}

void TSupplementaryDataCachePage::TSupplementaryDataCachePage(TSupplementaryDataCachePage *this, const TBaseFont *a2)
{
  unint64_t v2 = (void *)MEMORY[0x1F4188790](this, a2);
  unsigned int v4 = v3;
  uint64_t v6 = v5;
  uint64_t v7 = (uint64_t)v2;
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  v2[197] = 0;
  v2[196] = 0;
  v2[198] = 0;
  v2[207] = v2 + 199;
  (*(void (**)(uint64_t, void, uint64_t, void *))(*(void *)v6 + 672))(v6, v3 & 0xFFFFFF00, 256, v2);
  memset(__b, 170, sizeof(__b));
  uint64_t v8 = 0;
  int16x8_t v9 = (int16x8_t)vorrq_s8((int8x16_t)vdupq_n_s16(v4 & 0x300 | 0xFFFFDC00), (int8x16_t)xmmword_184BA9610);
  int16x8_t v10 = vdupq_n_s16((v4 >> 10) - 10304);
  v11.i64[0] = 0x8000800080008;
  v11.i64[1] = 0x8000800080008;
  do
  {
    int v12 = (__int16 *)&__b[v8];
    int16x8_t v13 = v9;
    vst2q_s16(v12, *(int16x8x2_t *)v10.i8);
    int16x8_t v9 = vaddq_s16(v9, v11);
    v8 += 8;
  }
  while (v8 != 256);
  bzero(v21, 0x400uLL);
  memset(v20, 255, sizeof(v20));
  if ((*(unsigned int (**)(uint64_t, uint64_t, unsigned char *, uint64_t, uint64_t))(*(void *)v6 + 512))(v6, v7, v20, 1, 256))
  {
    *(void *)&long long v14 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v25[14] = v14;
    v25[13] = v14;
    v25[12] = v14;
    v25[11] = v14;
    v25[10] = v14;
    v25[9] = v14;
    v25[8] = v14;
    v25[7] = v14;
    v25[6] = v14;
    void v25[5] = v14;
    v25[4] = v14;
    v25[3] = v14;
    v25[2] = v14;
    v25[1] = v14;
    v25[0] = v14;
    memset(v24, 0, sizeof(v24));
    int v26 = v25;
    unsigned int v23 = (void **)v24;
    uint64_t v19 = 0;
    CFDictionaryRef v15 = (float64x2_t *)v20;
    TUnicodeEncoder::EncodePortion((char ***)&v23, 0, (uint64_t)__b, 512, v6, 0, v7, (uint64_t)v20, 1, (uint64_t)v21, (double *)&v19, 1);
    for (uint64_t i = 0; i != 1024; i += 16)
    {
      float64x2_t v18 = *v15;
      float64x2_t v17 = v15[1];
      v15 += 2;
      *(float32x4_t *)(v7 + 512 + i) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v18), v17);
    }
    unsigned int v23 = (void **)v24;
    std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](&v23);
  }
  else
  {
    bzero((void *)(v7 + 512), 0x400uLL);
  }
  TCompactArray<unsigned short,8ul,3ul,30ul>::assign<unsigned int *>(v7 + 1536, v21, __b);
}

void TBMPDataCachePage::TBMPDataCachePage(TBMPDataCachePage *this, const TBaseFont *a2, int a3)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  *((void *)this + 197) = 0;
  *((void *)this + 196) = 0;
  *((void *)this + 198) = 0;
  *((void *)this + 207) = (char *)this + 1592;
  unsigned int v5 = a3 & 0xFFFFFF00;
  (*(void (**)(const TBaseFont *, void, uint64_t, TBMPDataCachePage *))(*(void *)a2 + 672))(a2, a3 & 0xFFFFFF00, 256, this);
  uint64_t v6 = 0;
  int16x8_t v7 = (int16x8_t)vorrq_s8((int8x16_t)vdupq_n_s16(v5), (int8x16_t)xmmword_184BA9610);
  *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v18[30] = v8;
  v18[31] = v8;
  v18[28] = v8;
  v18[29] = v8;
  v18[26] = v8;
  v18[27] = v8;
  v18[24] = v8;
  v18[25] = v8;
  v18[22] = v8;
  v18[23] = v8;
  v18[20] = v8;
  v18[21] = v8;
  v18[18] = v8;
  v18[19] = v8;
  v18[16] = v8;
  v18[17] = v8;
  v18[14] = v8;
  v18[15] = v8;
  v18[12] = v8;
  v18[13] = v8;
  v18[10] = v8;
  v18[11] = v8;
  v18[8] = v8;
  v18[9] = v8;
  v18[6] = v8;
  v18[7] = v8;
  v18[4] = v8;
  void v18[5] = v8;
  _OWORD v18[2] = v8;
  void v18[3] = v8;
  v18[0] = v8;
  v18[1] = v8;
  v9.i64[0] = 0x8000800080008;
  v9.i64[1] = 0x8000800080008;
  do
  {
    v18[v6] = v7;
    int16x8_t v7 = vaddq_s16(v7, v9);
    ++v6;
  }
  while (v6 != 32);
  bzero(v17, 0x400uLL);
  memset(__b, 255, sizeof(__b));
  if ((*(unsigned int (**)(const TBaseFont *, TBMPDataCachePage *, unsigned char *, uint64_t, uint64_t))(*(void *)a2 + 512))(a2, this, __b, 1, 256))
  {
    *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v21[14] = v10;
    v21[13] = v10;
    v21[12] = v10;
    v21[11] = v10;
    v21[10] = v10;
    v21[9] = v10;
    v21[8] = v10;
    v21[7] = v10;
    v21[6] = v10;
    v21[5] = v10;
    v21[4] = v10;
    void v21[3] = v10;
    v21[2] = v10;
    v21[1] = v10;
    v21[0] = v10;
    memset(v20, 0, sizeof(v20));
    unsigned int v22 = v21;
    uint64_t v19 = (void **)v20;
    uint64_t v15 = 0;
    int16x8_t v11 = (float64x2_t *)__b;
    TUnicodeEncoder::EncodePortion((char ***)&v19, 0, (uint64_t)v18, 256, (uint64_t)a2, 0, (uint64_t)this, (uint64_t)__b, 1, (uint64_t)v17, (double *)&v15, 1);
    for (uint64_t i = 0; i != 1024; i += 16)
    {
      float64x2_t v14 = *v11;
      float64x2_t v13 = v11[1];
      v11 += 2;
      *(float32x4_t *)((char *)this + i + 512) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v14), v13);
    }
    uint64_t v19 = (void **)v20;
    std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](&v19);
  }
  else
  {
    bzero((char *)this + 512, 0x400uLL);
  }
  TCompactArray<unsigned short,8ul,3ul,30ul>::assign<unsigned int *>((uint64_t)this + 1536, v17, (int *)v18);
}

uint64_t TBaseFont::GetUnscaledAdvances(TBaseFont *a1, uint64_t a2, void *a3, int a4, int64_t a5)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t InitializedGraphicsFont = TBaseFont::GetInitializedGraphicsFont(a1);
  if (a4 != 2)
  {
    if (a4 == 1)
    {
      if (InitializedGraphicsFont && CGFontGetParserFont())
      {
        FPFontGetGlyphIdealAdvanceWidths();
        return 1;
      }
      TBaseFont::GetInitializedGraphicsFont(a1);
    }
    *(void *)&long long v12 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v21[28] = v12;
    v21[29] = v12;
    v21[26] = v12;
    v21[27] = v12;
    v21[24] = v12;
    v21[25] = v12;
    v21[22] = v12;
    v21[23] = v12;
    v21[20] = v12;
    v21[21] = v12;
    v21[18] = v12;
    v21[19] = v12;
    v21[16] = v12;
    v21[17] = v12;
    _OWORD v21[15] = v12;
    v21[14] = v12;
    v21[13] = v12;
    v21[12] = v12;
    v21[11] = v12;
    v21[10] = v12;
    v21[9] = v12;
    v21[8] = v12;
    v21[7] = v12;
    v21[6] = v12;
    v21[4] = v12;
    v21[5] = v12;
    v21[2] = v12;
    void v21[3] = v12;
    v21[0] = v12;
    v21[1] = v12;
    float64x2_t v18 = 0;
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    unsigned int v22 = v21;
    if (a5)
    {
      std::vector<CGPoint,TInlineBufferAllocator<CGPoint,30ul>>::__vallocate[abi:nn180100](&v18, a5);
      float64x2_t v13 = (char *)v19;
      bzero(v19, 16 * a5);
      uint64_t v19 = &v13[16 * a5];
      GlyphAdvancesForuint64_t Style = CGFontGetGlyphAdvancesForStyle();
      uint64_t v10 = GlyphAdvancesForStyle;
      if (a5 >= 1 && GlyphAdvancesForStyle)
      {
        uint64_t v15 = v18;
        do
        {
          uint64_t v16 = *(void *)v15;
          v15 += 16;
          *a3 = v16;
          a3 += a4;
          --a5;
        }
        while (a5);
        uint64_t v10 = 1;
      }
    }
    else
    {
      uint64_t v10 = CGFontGetGlyphAdvancesForStyle();
    }
    float64x2_t v17 = &v18;
    std::vector<CGPoint,TInlineBufferAllocator<CGPoint,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v17);
    return v10;
  }

  return CGFontGetGlyphAdvancesForStyle();
}

uint64_t TUnicodeEncoder::EncodePortion(char ***a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, int a9, uint64_t a10, double *a11, char a12)
{
  uint64_t v15 = a2;
  uint64_t v16 = (double *)(a8 + 8 * a9 * a2);
  long long v83 = v16;
  uint64_t v84 = a2;
  int v81 = (*(uint64_t (**)(uint64_t))(*(void *)a5 + 688))(a5);
  int v76 = (*(uint64_t (**)(uint64_t))(*(void *)a5 + 712))(a5);
  if (a4 >= 1)
  {
    uint64_t v75 = a5;
    uint64_t v17 = 0;
    int v18 = 1;
    uint64_t v79 = a4;
    uint64_t v80 = a3;
    while (1)
    {
      uint64_t v19 = v17 + 1;
      uint64_t v20 = *(unsigned __int16 *)(a3 + 2 * v17);
      if ((v20 & 0xFC00) != 0xD800 || v19 == a4)
      {
        ++v17;
      }
      else
      {
        int v22 = *(unsigned __int16 *)(a3 + 2 * v19);
        BOOL v23 = (v22 & 0xFC00) == 56320;
        unsigned int v24 = v22 + (v20 << 10) - 56613888;
        if (v23) {
          v17 += 2;
        }
        else {
          ++v17;
        }
        if (v23) {
          uint64_t v20 = v24;
        }
        else {
          uint64_t v20 = v20;
        }
      }
      int v25 = MEMORY[0x185327F70](v20);
      if (v25 >= 1)
      {
        if (v25 > 0x15 || ((1 << v25) & 0x20E022) == 0)
        {
          int v27 = 0;
        }
        else
        {
          *(_DWORD *)(a10 + 4 * v15) |= 0x8000u;
          int v27 = 2;
        }
        v18 |= v27;
      }
      int v28 = u_charType(v20);
      int v29 = *(unsigned __int16 *)(a7 + 2 * v15);
      int v30 = v81;
      if ((unsigned __int16)(v29 + 1) < 2u) {
        int v30 = 1;
      }
      BOOL v31 = v30 == 1 && u_hasBinaryProperty(v20, UCHAR_DEFAULT_IGNORABLE_CODE_POINT) != 0;
      int v32 = 1 << v28;
      BOOL v33 = ((1 << v28) & 0x5F001) == 0 && !v31;
      if (v33 || IsVisibleFormatter(v20))
      {
        *a11 = *v16 + *a11;
        a3 = v80;
        if ((v32 & 0x37F80E1E) == 0)
        {
          if (v20 >> 5 == 1987 || (v32 & 0x1C0) != 0)
          {
            v18 |= 4u;
            *(_DWORD *)(a10 + 4 * v15) |= 0x40u;
          }
          else if ((v32 & 0xF000000) == 0)
          {
            IntPropertyCFNumberRef Value = u_getIntPropertyValue(v20, UCHAR_GRAPHEME_CLUSTER_BREAK);
            a4 = v79;
            if ((IntPropertyValue & 0xFFFFFFFE) == 8)
            {
              v18 |= 4u;
              *(_DWORD *)(a10 + 4 * v15) |= 0x10u;
            }
            else if (IntPropertyValue == 17)
            {
              v18 |= 4u;
            }
            goto LABEL_49;
          }
        }
        a4 = v79;
LABEL_49:
        if v20 < 0x10000 || (a12)
        {
          if (!v29) {
            v18 |= 8u;
          }
        }
        else
        {
          v18 |= TUnicodeEncoder::HandleSurrogateChar(a1, a7, &v83, a9, &v84);
        }
        goto LABEL_119;
      }
      if (!v31)
      {
        int v42 = *(unsigned __int16 *)(a7 + 2 * v15);
        if (*(_WORD *)(a7 + 2 * v15))
        {
          int v43 = 0;
          if (u_hasBinaryProperty(v20, UCHAR_DEFAULT_IGNORABLE_CODE_POINT)) {
            *uint64_t v16 = 0.0;
          }
        }
        else
        {
          int v43 = 8;
        }
        if ((v32 & 0x7000) == 0 && ((v32 & 0x8000) == 0 || !u_isUWhiteSpace(v20)))
        {
          double v44 = *v16 + *a11;
          *a11 = v44;
          if (v28 == 16)
          {
            a4 = v79;
            a3 = v80;
            if (IsVisibleFormatter(v20))
            {
              if (v42)
              {
                v43 |= 4u;
                *(_DWORD *)(a10 + 4 * v15) |= 0x40u;
              }
              if (v20 < 0x10000) {
                goto LABEL_118;
              }
LABEL_97:
              if ((a12 & 1) == 0) {
                v43 |= TUnicodeEncoder::HandleSurrogateChar(a1, a7, &v83, a9, &v84);
              }
LABEL_118:
              v18 |= v43;
              goto LABEL_119;
            }
            if (v20 >> 11 == 27) {
              goto LABEL_118;
            }
            double v44 = *a11;
LABEL_110:
            *a11 = v44 - *v16;
            *(_WORD *)(a7 + 2 * v15) = -1;
            *uint64_t v16 = 0.0;
            *(_DWORD *)(a10 + 4 * v15) |= 0x20u;
            int v43 = 16;
            if (v20 >= 0x10000)
            {
              a3 = v80;
              if ((a12 & 1) == 0)
              {
                unint64_t v57 = &v16[a9];
                uint64_t v58 = v15 + 1;
                long long v83 = v57;
                uint64_t v84 = v15 + 1;
                *(_WORD *)(a7 + 2 * (v15 + 1)) = -1;
                BOOL v59 = *a1;
                uint64_t v60 = (*a1)[1];
                BOOL v61 = (*a1)[2];
                if (v60 >= v61)
                {
                  unint64_t v63 = *v59;
                  uint64_t v64 = (v60 - *v59) >> 3;
                  unint64_t v65 = v64 + 1;
                  if ((unint64_t)(v64 + 1) >> 61) {
LABEL_139:
                  }
                    abort();
                  uint64_t v66 = v61 - v63;
                  if (v66 >> 2 > v65) {
                    unint64_t v65 = v66 >> 2;
                  }
                  if ((unint64_t)v66 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v67 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v67 = v65;
                  }
                  int64x2_t v90 = v59 + 3;
                  if (v67)
                  {
                    uint64_t v68 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)(v59 + 3), v67);
                    unint64_t v63 = *v59;
                    uint64_t v60 = v59[1];
                  }
                  else
                  {
                    uint64_t v68 = 0;
                  }
                  unint64_t v69 = &v68[8 * v64];
                  *(void *)unint64_t v69 = v58;
                  if (v60 == v63)
                  {
                    BOOL v71 = &v68[8 * v64];
                    a4 = v79;
                  }
                  else
                  {
                    unint64_t v70 = v60;
                    BOOL v71 = &v68[8 * v64];
                    a4 = v79;
                    do
                    {
                      uint64_t v72 = *((void *)v70 - 1);
                      v70 -= 8;
                      *((void *)v71 - 1) = v72;
                      v71 -= 8;
                    }
                    while (v70 != v63);
                  }
                  long long v62 = v69 + 8;
                  __n128 *v59 = v71;
                  uint64_t v86 = v63;
                  unint64_t v87 = v63;
                  v59[1] = v69 + 8;
                  unint64_t v88 = v60;
                  unint64_t v73 = v59[2];
                  v59[2] = &v68[8 * v67];
                  BOOL v89 = v73;
                  std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v86);
                  a3 = v80;
                }
                else
                {
                  *(void *)uint64_t v60 = v58;
                  long long v62 = v60 + 8;
                }
                v59[1] = v62;
                int v43 = 16;
              }
              goto LABEL_118;
            }
          }
          else
          {
            a4 = v79;
            if (v20 >> 11 != 27)
            {
              if (v28) {
                goto LABEL_110;
              }
              if (v20 >= 0x10000)
              {
                a3 = v80;
                goto LABEL_97;
              }
            }
          }
          a3 = v80;
          goto LABEL_118;
        }
        if (v28 == 15)
        {
          a4 = v79;
          a3 = v80;
          if ((v20 - 10) < 4) {
            goto LABEL_65;
          }
          if (v20 == 9)
          {
            *(_DWORD *)(a10 + 4 * v15) |= 4u;
          }
          else if (v20 == 133)
          {
LABEL_65:
            *(_DWORD *)(a10 + 4 * v15) |= 2u;
            if (!v42)
            {
              LOWORD(v86) = 32;
              __int16 v85 = -21846;
              if ((*(uint64_t (**)(uint64_t, char **, __int16 *, uint64_t))(*(void *)v75 + 664))(v75, &v86, &v85, 1) == 1)
              {
                int v43 = 0;
                *(_WORD *)(a7 + 2 * v15) = v85;
              }
            }
          }
          *uint64_t v16 = 0.0;
          double v45 = 0.0;
        }
        else
        {
          a3 = v80;
          if ((v32 & 0x6000) != 0)
          {
            *(_DWORD *)(a10 + 4 * v15) |= 2u;
            *uint64_t v16 = 0.0;
            double v45 = 0.0;
          }
          else
          {
            double v45 = *v16;
          }
          a4 = v79;
        }
        *a11 = v45 + *a11;
        *(_DWORD *)(a10 + 4 * v15) |= 1u;
        goto LABEL_118;
      }
      if (!a6) {
        break;
      }
      int v35 = v76 ^ (v20 == 65039) ^ 1;
      if (v20 >> 1 != 32519) {
        int v35 = 1;
      }
      if ((v35 | v81)) {
        break;
      }
      a4 = v79;
      a3 = v80;
      if (v29 == 0xFFFF) {
        goto LABEL_107;
      }
      v18 |= 8u;
LABEL_119:
      uint64_t v16 = &v83[a9];
      uint64_t v15 = v84 + 1;
      long long v83 = v16;
      ++v84;
      if (v17 >= a4) {
        return (char)v18;
      }
    }
    *(_WORD *)(a7 + 2 * v15) = -1;
    *uint64_t v16 = 0.0;
    *(_DWORD *)(a10 + 4 * v15) |= 0x20u;
    a4 = v79;
    a3 = v80;
    if (v20 >= 0x10000 && (a12 & 1) == 0)
    {
      unint64_t v36 = &v16[a9];
      uint64_t v37 = v15 + 1;
      long long v83 = v36;
      uint64_t v84 = v15 + 1;
      *(_WORD *)(a7 + 2 * (v15 + 1)) = -1;
      double *v36 = 0.0;
      *(_DWORD *)(a10 + 4 * (v15 + 1)) |= 0x20u;
      id v38 = *a1;
      unint64_t v39 = (*a1)[1];
      BOOL v40 = (*a1)[2];
      if (v39 >= v40)
      {
        unint64_t v46 = *v38;
        uint64_t v47 = (v39 - *v38) >> 3;
        unint64_t v48 = v47 + 1;
        if ((unint64_t)(v47 + 1) >> 61) {
          goto LABEL_139;
        }
        uint64_t v49 = v40 - v46;
        if (v49 >> 2 > v48) {
          unint64_t v48 = v49 >> 2;
        }
        if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v50 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v50 = v48;
        }
        int64x2_t v90 = v38 + 3;
        if (v50)
        {
          BOOL v51 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)(v38 + 3), v50);
          unint64_t v46 = *v38;
          unint64_t v39 = v38[1];
        }
        else
        {
          BOOL v51 = 0;
        }
        CGFloat v52 = &v51[8 * v47];
        *(void *)CGFloat v52 = v37;
        if (v39 == v46)
        {
          long long v54 = &v51[8 * v47];
          a4 = v79;
        }
        else
        {
          unint64_t v53 = v39;
          long long v54 = &v51[8 * v47];
          a4 = v79;
          do
          {
            uint64_t v55 = *((void *)v53 - 1);
            v53 -= 8;
            *((void *)v54 - 1) = v55;
            v54 -= 8;
          }
          while (v53 != v46);
        }
        long long v41 = v52 + 8;
        *id v38 = v54;
        uint64_t v86 = v46;
        unint64_t v87 = v46;
        v38[1] = v52 + 8;
        unint64_t v88 = v39;
        unint64_t v56 = v38[2];
        id v38[2] = &v51[8 * v50];
        BOOL v89 = v56;
        std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v86);
        a3 = v80;
      }
      else
      {
        *(void *)unint64_t v39 = v37;
        long long v41 = v39 + 8;
      }
      v38[1] = v41;
    }
LABEL_107:
    v18 |= 0x10u;
    goto LABEL_119;
  }
  LOBYTE(v18) = 1;
  return (char)v18;
}

BOOL IsVisibleFormatter(unsigned int a1)
{
  if (a1 - 78896 < 0x10 || a1 - 6155 < 5 || a1 - 8204 < 2) {
    return 1;
  }
  if (a1 < 0xE0030) {
    return u_hasBinaryProperty(a1, UCHAR_PREPENDED_CONCATENATION_MARK) != 0;
  }
  if (a1 < 0xE003A) {
    return 1;
  }
  if (a1 < 0xE0061) {
    return u_hasBinaryProperty(a1, UCHAR_PREPENDED_CONCATENATION_MARK) != 0;
  }
  uint64_t v3 = 1;
  if (a1 >= 0xE007B && a1 != 917631) {
    return u_hasBinaryProperty(a1, UCHAR_PREPENDED_CONCATENATION_MARK) != 0;
  }
  return v3;
}

uint64_t TBaseFont::IsLastResort(TBaseFont *this)
{
  if ((*((_DWORD *)this + 46) & 2) == 0) {
    TBaseFont::DetermineFontFlags(this, 2u);
  }
  return (*((_DWORD *)this + 45) >> 1) & 1;
}

uint64_t TInstanceFont::IsLastResort(TInstanceFont *this)
{
  return 0;
}

uint64_t TTenuousComponentFont::GetUnscaledAdvances(atomic_ullong *this, unsigned __int16 *a2, void *a3, uint64_t a4, int64_t a5)
{
  if ((this[89] & 0x20) != 0)
  {
    CFNumberRef ComponentAttribute = (atomic_ullong *)TComponentFont::GetComponentAttribute(this, @"hmtxPerAltFont");
    if (ComponentAttribute)
    {
      v17.unint64_t isa = (void *)0xAAAAAAAAAAAAAAAALL;
      CopyComponentFontDescriptorWithBaseSystemFallback(&v17, ComponentAttribute, 0, 1024);
      if (atomic_load_explicit((atomic_ullong *volatile)&v17, memory_order_acquire))
      {
        long long v12 = (TDescriptor **)(id)atomic_load_explicit((atomic_ullong *volatile)&v17, memory_order_acquire);
        float64x2_t v13 = v12;
        float64x2_t v14 = v12[5];
        if ((*((_DWORD *)v14 + 4) & 0x80000000) == 0) {
          TDescriptor::InitBaseFont(v12[5], 0, 0.0);
        }
        unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)v14 + 4, memory_order_acquire);

        if (explicit)
        {
          uint64_t v16 = (*(uint64_t (**)(unint64_t, unsigned __int16 *, void *, uint64_t, int64_t))(*(void *)explicit + 512))(explicit, a2, a3, a4, a5);

          return v16;
        }
      }
    }
    return TComponentFont::GetUnscaledAdvances((TComponentFont *)this, a2, a3, a4, a5);
  }

  return TBaseFont::GetUnscaledAdvances((TBaseFont *)this, (uint64_t)a2, a3, a4, a5);
}

uint64_t CTFontGetLatin1GlyphsAndAdvanceWidths(uint64_t a1, void *a2, void *a3)
{
  uint64_t result = 0;
  if (a1 && a2 && a3)
  {
    unsigned int v5 = *(atomic_ullong **)(a1 + 40);
    unint64_t explicit = atomic_load_explicit(v5 + 48, memory_order_acquire);
    if (!explicit) {
      TFont::InitASCIIDataCache((TFont *)v5);
    }
    *a2 = explicit + 8;
    *a3 = explicit + 392;
    return 1;
  }
  return result;
}

BOOL CTFontGetGlyphsForCharacters(CTFontRef font, const UniChar *characters, CGGlyph *glyphs, CFIndex count)
{
  BOOL result = 0;
  if (font && characters && glyphs)
  {
    uint64_t v6 = *(void *)(*((void *)font + 5) + 400);
    if (v6)
    {
      return (*(uint64_t (**)(uint64_t))(*(void *)v6 + 664))(v6) == count;
    }
    else
    {
      if (count >= 1) {
        bzero(glyphs, 2 * count);
      }
      return 0;
    }
  }
  return result;
}

uint64_t TComponentFont::GetGlyphsForCharacters(const __CFString **this, const unsigned __int16 *a2, unsigned __int16 *a3, uint64_t a4)
{
  id v28 = (id)0xAAAAAAAAAAAAAAAALL;
  int v29 = (__CFString *)0xAAAAAAAAAAAAAAAALL;
  TComponentFont::GetCharacterOverride((TComponentFont *)&v28, this, &v29);
  if (!atomic_load_explicit((atomic_ullong *volatile)&v28, memory_order_acquire)) {
    goto LABEL_4;
  }
  if (v29 == @"cmapOverride")
  {
    CFDataRef v9 = (const __CFData *)atomic_exchange((atomic_ullong *volatile)&v28, 0);
    if (v9) {
      BytePtr = (_anonymous_namespace_::TcmapOverrideContext *)CFDataGetBytePtr(v9);
    }
    else {
      BytePtr = 0;
    }
    if (a4 < 1)
    {
      uint64_t GlyphsForCharactersWithCMap = a4;
LABEL_42:

      goto LABEL_43;
    }
    uint64_t v19 = 0;
    uint64_t GlyphsForCharactersWithCMap = a4;
    while (1)
    {
      uint64_t v20 = v19 + 1;
      unsigned int v21 = a2[v19];
      BOOL v22 = (v21 & 0xFC00) != 0xD800 || v20 == a4;
      if (v22 || (int v23 = a2[v20], (v23 & 0xFC00) != 0xDC00))
      {
        *a3 = MappedGlyph;
        int v25 = a3 + 1;
        if (!MappedGlyph) {
LABEL_38:
        }
          --GlyphsForCharactersWithCMap;
      }
      else
      {
        uint64_t v20 = v19 + 2;
        *a3 = v24;
        int v25 = a3 + 2;
        a3[1] = 0;
        if (!v24) {
          goto LABEL_38;
        }
      }
      uint64_t v19 = v20;
      a3 = v25;
      if (v20 >= a4) {
        goto LABEL_42;
      }
    }
  }
  if (v29 != @"UnicodeCharSet")
  {
LABEL_4:
    int v30 = this;
    uint64_t GlyphsForCharactersWithCMap = TBaseFont::GetGlyphsForCharactersWithCMap((atomic_ullong *)this, (TBaseFont **)&v30, a2, a3, a4);
    goto LABEL_43;
  }
  int v30 = this;
  uint64_t GlyphsForCharactersWithCMap = TBaseFont::GetGlyphsForCharactersWithCMap((atomic_ullong *)this, (TBaseFont **)&v30, a2, a3, a4);
  if (a4 >= 1)
  {
    uint64_t v11 = 0;
    do
    {
      uint64_t v12 = v11++;
      UTF32Char v13 = a2[v12];
      if ((v13 & 0xFC00) == 0xD800 && v11 != a4)
      {
        int v15 = a2[v11];
        BOOL v16 = (v15 & 0xFC00) == 56320;
        UTF32Char v17 = (v13 << 10) - 56613888 + v15;
        uint64_t v11 = v16 ? v12 + 2 : v12 + 1;
        if (v16) {
          UTF32Char v13 = v17;
        }
      }
      if (a3[v12])
      {
        if (CFCharacterSetIsLongCharacterMember((CFCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v28, memory_order_acquire), v13))
        {
          BOOL v18 = 1;
        }
        else
        {
          BOOL v18 = v11 <= v12;
        }
        if (!v18)
        {
          bzero(&a3[v12], 2 * (v11 - v12));
          uint64_t GlyphsForCharactersWithCMap = GlyphsForCharactersWithCMap + v12 - v11;
        }
      }
    }
    while (v11 < a4);
  }
LABEL_43:

  return GlyphsForCharactersWithCMap;
}

void TFont::InitASCIIDataCache(TFont *this)
{
}

void TASCIIDataCache::TASCIIDataCache(TASCIIDataCache *this, const TFont *a2)
{
  *(void *)this = a2;
  unsigned int v4 = (char *)this + 8;
  *(_OWORD *)((char *)this + 1928) = 0u;
  (*(void (**)(void, uint64_t, uint64_t, char *))(**((void **)a2 + 50) + 672))(*((void *)a2 + 50), 32, 96, (char *)this + 8);
  (*(void (**)(void))(**((void **)a2 + 50) + 672))();
  TFont::GetUnsummedAdvancesForGlyphs((uint64_t)a2, (uint64_t)v4, (double *)this + 49, 1, 192, 0, 0);
  *((_WORD *)this + 113) = -1;
  *((void *)this + 158) = 0;
}

void TComponentFont::GetGlyphsForCharacterRange(const __CFString **this, CFRange a2, unsigned __int16 *a3)
{
  uint64_t length = a2.length;
  CFIndex location = a2.location;
  id v11 = (id)0xAAAAAAAAAAAAAAAALL;
  uint64_t v12 = (__CFString *)0xAAAAAAAAAAAAAAAALL;
  TComponentFont::GetCharacterOverride((TComponentFont *)&v11, this, &v12);
  int16x8_t v7 = v12;
  if (v12 == @"cmapOverride")
  {
    CFDataRef v9 = (const __CFData *)atomic_exchange((atomic_ullong *volatile)&v11, 0);
    if (v9) {
      BytePtr = (_anonymous_namespace_::TcmapOverrideContext *)CFDataGetBytePtr(v9);
    }
    else {
      BytePtr = 0;
    }
    if (length >= 1)
    {
      do
      {
        LODWORD(location) = location + 1;
        --length;
      }
      while (length);
    }
  }
  else
  {
    v13.CFIndex location = location;
    v13.uint64_t length = length;
    TBaseFont::GetGlyphsForCharacterRange((atomic_ullong *)this, v13, a3);
    if (v7 == @"UnicodeCharSet" && length >= 1)
    {
      do
      {
        if (*a3
          && !CFCharacterSetIsLongCharacterMember((CFCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v11, memory_order_acquire), location))
        {
          *a3 = 0;
        }
        LODWORD(location) = location + 1;
        ++a3;
        --length;
      }
      while (length);
    }
  }
}

void TComponentFont::GetCharacterOverride(TComponentFont *this, const __CFString **a2, void *a3)
{
  int v5 = *((_DWORD *)a2 + 178);
  if ((v5 & 0x700) != 0)
  {
    if ((v5 & 0x100) != 0)
    {
      CFNumberRef ComponentAttribute = (void *)TComponentFont::GetComponentAttribute((atomic_ullong *)a2, @"cmapOverride");
      if (ComponentAttribute)
      {
        *a3 = @"cmapOverride";
        *(void *)this = ComponentAttribute;
        return;
      }
    }
    ((void (*)(id *__return_ptr, const __CFString **))(*a2)[5].length)(&v10, a2);

    if ((v5 & 0x600) != 0)
    {
      id v9 = (id)TComponentFont::GetComponentAttribute((atomic_ullong *)a2, @"UnicodeCharSet");
      if (!atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire))
      {
        TBaseFont::CopyAttributeInternal((atomic_ullong *)a2, @"NSCTFontCharacterSetAttribute", &v8);
      }
      if (atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire))
      {
        *a3 = @"UnicodeCharSet";
        *(void *)this = atomic_exchange((atomic_ullong *volatile)&v9, 0);

        return;
      }
    }
  }
  *a3 = 0;
  *(void *)this = 0;
}

uint64_t TBaseFont::GetGlyphsForCharacterRange(atomic_ullong *this, CFRange a2, unsigned __int16 *a3)
{
  CFIndex length = a2.length;
  CFIndex location = a2.location;
  uint64_t v6 = this;
  uint64_t v90 = *MEMORY[0x1E4F143B8];
  unsigned int v78 = this;
  if (!TcmapTable::MapRange((TBaseFont **)&v78, a2, a3))
  {
    *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v88[3] = v8;
    v88[2] = v8;
    v88[1] = v8;
    v88[0] = v8;
    __int16 v85 = 0;
    uint64_t v86 = 0;
    unint64_t v87 = 0;
    BOOL v89 = v88;
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::reserve(&v85, 2 * length);
    uint64_t v7 = location + length;
    CFIndex v76 = length;
    unint64_t v77 = v6;
    if (location >= 0x10000 || length < 1)
    {
      CFIndex v23 = location;
      if (length > 0)
      {
LABEL_27:
        int v25 = (const unsigned __int16 *)v85;
        int v26 = v86;
        unint64_t v27 = (v86 - v85) >> 1;
        uint64_t v75 = v85;
        if (v23 >= v7)
        {
          unint64_t v56 = (v86 - v85) >> 1;
          id v28 = v86;
        }
        else
        {
          id v28 = v86;
          unint64_t v73 = v86;
          uint64_t v74 = (v86 - v85) >> 1;
          do
          {
            __int16 v29 = ((unint64_t)v23 >> 10) - 10304;
            unint64_t v30 = (unint64_t)v87;
            if (v28 >= v87)
            {
              int v32 = (void **)v85;
              uint64_t v33 = v28 - v85;
              if (v28 - v85 <= -3) {
                goto LABEL_106;
              }
              uint64_t v34 = v33 >> 1;
              if (v87 - v85 <= (unint64_t)((v33 >> 1) + 1)) {
                uint64_t v35 = v34 + 1;
              }
              else {
                uint64_t v35 = v87 - v85;
              }
              if ((unint64_t)(v87 - v85) >= 0x7FFFFFFFFFFFFFFELL) {
                uint64_t v36 = 0x7FFFFFFFFFFFFFFFLL;
              }
              else {
                uint64_t v36 = v35;
              }
              *((void *)&v83[0] + 1) = v88;
              if (v36)
              {
                uint64_t v37 = (char *)TInlineBufferAllocator<unsigned short,30ul>::allocate((uint64_t)v88, v36);
                int v32 = (void **)v85;
                id v28 = v86;
              }
              else
              {
                uint64_t v37 = 0;
              }
              id v38 = &v37[2 * v34];
              *(_WORD *)id v38 = v29;
              if (v28 == (char *)v32)
              {
                BOOL v40 = &v37[2 * v34];
              }
              else
              {
                unint64_t v39 = (void **)v28;
                BOOL v40 = &v37[2 * v34];
                do
                {
                  __int16 v41 = *((_WORD *)v39 - 1);
                  unint64_t v39 = (void **)((char *)v39 - 2);
                  *((_WORD *)v40 - 1) = v41;
                  v40 -= 2;
                }
                while (v39 != v32);
              }
              BOOL v31 = v38 + 2;
              __int16 v85 = v40;
              uint64_t v86 = v38 + 2;
              int v42 = v87;
              unint64_t v87 = &v37[2 * v36];
              long long v82 = v28;
              *(void *)&v83[0] = v42;
              uint64_t v80 = (char **)v32;
              int v81 = v32;
              std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,30ul> &>::~__split_buffer((uint64_t)&v80);
              unint64_t v30 = (unint64_t)v87;
            }
            else
            {
              *(_WORD *)id v28 = v29;
              BOOL v31 = v28 + 2;
            }
            uint64_t v86 = v31;
            __int16 v43 = v23 & 0x3FF | 0xDC00;
            if ((unint64_t)v31 >= v30)
            {
              double v44 = (void **)v85;
              uint64_t v45 = v31 - v85;
              if (v31 - v85 <= -3) {
                goto LABEL_106;
              }
              uint64_t v46 = v45 >> 1;
              unint64_t v47 = v30 - (void)v85;
              if (v47 <= (v45 >> 1) + 1) {
                unint64_t v48 = v46 + 1;
              }
              else {
                unint64_t v48 = v47;
              }
              if (v47 >= 0x7FFFFFFFFFFFFFFELL) {
                uint64_t v49 = 0x7FFFFFFFFFFFFFFFLL;
              }
              else {
                uint64_t v49 = v48;
              }
              *((void *)&v83[0] + 1) = v88;
              if (v49)
              {
                unint64_t v50 = (char *)TInlineBufferAllocator<unsigned short,30ul>::allocate((uint64_t)v88, v49);
                double v44 = (void **)v85;
                BOOL v31 = v86;
              }
              else
              {
                unint64_t v50 = 0;
              }
              BOOL v51 = &v50[2 * v46];
              *(_WORD *)BOOL v51 = v43;
              if (v31 == (char *)v44)
              {
                unint64_t v53 = &v50[2 * v46];
              }
              else
              {
                CGFloat v52 = (void **)v31;
                unint64_t v53 = &v50[2 * v46];
                do
                {
                  __int16 v54 = *((_WORD *)v52 - 1);
                  CGFloat v52 = (void **)((char *)v52 - 2);
                  *((_WORD *)v53 - 1) = v54;
                  v53 -= 2;
                }
                while (v52 != v44);
              }
              id v28 = v51 + 2;
              __int16 v85 = v53;
              uint64_t v86 = v51 + 2;
              uint64_t v55 = v87;
              unint64_t v87 = &v50[2 * v49];
              long long v82 = v31;
              *(void *)&v83[0] = v55;
              uint64_t v80 = (char **)v44;
              int v81 = v44;
              std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,30ul> &>::~__split_buffer((uint64_t)&v80);
            }
            else
            {
              *(_WORD *)BOOL v31 = v43;
              id v28 = v31 + 2;
            }
            uint64_t v86 = v28;
            ++v23;
          }
          while (v23 != v7);
          int v25 = (const unsigned __int16 *)v85;
          unint64_t v56 = (v28 - v85) >> 1;
          int v26 = v73;
          unint64_t v27 = v74;
        }
        *(void *)&long long v57 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v57 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v83[3] = v57;
        _OWORD v83[2] = v57;
        v83[1] = v57;
        v83[0] = v57;
        int v81 = 0;
        long long v82 = 0;
        uint64_t v80 = 0;
        uint64_t v84 = v83;
        if (v28 == (char *)v25)
        {
          BOOL v59 = 0;
        }
        else
        {
          std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__vallocate[abi:nn180100](&v80, v56);
          uint64_t v58 = (char *)v81;
          bzero(v81, 2 * v56);
          int v81 = &v58[2 * v56];
          int v25 = (const unsigned __int16 *)v85;
          BOOL v59 = (unsigned __int16 *)v80;
        }
        CFIndex length = v76;
        uint64_t v6 = v77;
        TcmapTable::Map((TBaseFont **)&v78, v25, v59, v56, 1);
        if (v26 == v75)
        {
          unint64_t v61 = 0;
        }
        else
        {
          uint64_t v60 = (void **)v80;
          if (v27 <= 1) {
            unint64_t v61 = 1;
          }
          else {
            unint64_t v61 = v27;
          }
          long long v62 = a3;
          unint64_t v63 = v61;
          do
          {
            unsigned __int16 v64 = *(_WORD *)v60;
            uint64_t v60 = (void **)((char *)v60 + 2);
            *v62++ = v64;
            --v63;
          }
          while (v63);
        }
        if (v61 < v56)
        {
          unint64_t v65 = (void **)v80;
          uint64_t v66 = &a3[v61];
          do
          {
            *v66++ = *((_WORD *)v65 + v61);
            v61 += 2;
          }
          while (v61 < v56);
        }
        uint64_t v79 = &v80;
        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v79);
        goto LABEL_85;
      }
    }
    else
    {
      id v9 = v86;
      uint64_t v10 = location;
      do
      {
        if (v9 >= v87)
        {
          id v11 = (void **)v85;
          uint64_t v12 = v9 - v85;
          if (v9 - v85 <= -3) {
LABEL_106:
          }
            abort();
          uint64_t v13 = v12 >> 1;
          if (v87 - v85 <= (unint64_t)((v12 >> 1) + 1)) {
            uint64_t v14 = v13 + 1;
          }
          else {
            uint64_t v14 = v87 - v85;
          }
          if ((unint64_t)(v87 - v85) >= 0x7FFFFFFFFFFFFFFELL) {
            uint64_t v15 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v15 = v14;
          }
          *((void *)&v83[0] + 1) = v88;
          if (v15)
          {
            BOOL v16 = (char *)TInlineBufferAllocator<unsigned short,30ul>::allocate((uint64_t)v88, v15);
            id v11 = (void **)v85;
            id v9 = v86;
          }
          else
          {
            BOOL v16 = 0;
          }
          UTF32Char v17 = &v16[2 * v13];
          *(_WORD *)UTF32Char v17 = v10;
          if (v9 == (char *)v11)
          {
            uint64_t v19 = &v16[2 * v13];
          }
          else
          {
            BOOL v18 = (void **)v9;
            uint64_t v19 = &v16[2 * v13];
            do
            {
              __int16 v20 = *((_WORD *)v18 - 1);
              BOOL v18 = (void **)((char *)v18 - 2);
              *((_WORD *)v19 - 1) = v20;
              v19 -= 2;
            }
            while (v18 != v11);
          }
          unsigned int v21 = v17 + 2;
          __int16 v85 = v19;
          uint64_t v86 = v17 + 2;
          BOOL v22 = v87;
          unint64_t v87 = &v16[2 * v15];
          long long v82 = v9;
          *(void *)&v83[0] = v22;
          uint64_t v80 = (char **)v11;
          int v81 = v11;
          std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,30ul> &>::~__split_buffer((uint64_t)&v80);
          id v9 = v21;
        }
        else
        {
          *(_WORD *)id v9 = v10;
          v9 += 2;
        }
        uint64_t v86 = v9;
        CFIndex v23 = v10 + 1;
        BOOL v24 = v10 + 1 < v7;
        if (v10 > 65534) {
          break;
        }
        ++v10;
      }
      while (v23 < v7);
      if (v24) {
        goto LABEL_27;
      }
    }
    TcmapTable::Map((TBaseFont **)&v78, (const unsigned __int16 *)v85, a3, (v86 - v85) >> 1, 1);
    uint64_t v6 = v77;
LABEL_85:
    uint64_t v80 = &v85;
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v80);
    goto LABEL_86;
  }
  uint64_t v7 = location + length;
LABEL_86:
  for (uint64_t i = 0; i != 36; i += 3)
  {
    WORD2(v85) = kSynthesizedCharacters[i + 2];
    LODWORD(v85) = *(_DWORD *)&kSynthesizedCharacters[i];
    CFIndex v68 = (unsigned __int16)v85 - location;
    BOOL v69 = (unsigned __int16)v85 < location || v7 <= (unsigned __int16)v85;
    if (!v69 && !a3[v68]) {
      a3[v68] = FirstMappedOf((TBaseFont **)&v78, (const unsigned __int16 (*)[2])((char *)&v85 + 2));
    }
  }
  uint64_t result = (*(uint64_t (**)(atomic_ullong *))(*v6 + 728))(v6);
  if (result)
  {
    if (location <= 9)
    {
      if (v7 <= 9) {
        return result;
      }
      goto LABEL_104;
    }
    if (location == 10)
    {
      if (length > 0 || v7 > 13)
      {
LABEL_104:
        uint64_t result = (uint64_t)TBaseFont::GetCachedSpaceAndJoinerGlyphs(v6, (TBaseFont **)&v78);
        unsigned __int16 v71 = *(_WORD *)result;
        uint64_t v72 = &a3[-location];
        v72[9] = *(_WORD *)result;
        v72[10] = v71;
        v72[13] = v71;
      }
    }
    else if ((unint64_t)location <= 0xD && v7 >= 14)
    {
      goto LABEL_104;
    }
  }
  return result;
}

uint64_t TTenuousComponentFont::IsMicrosoftKorean(TTenuousComponentFont *this)
{
  if ((*(uint64_t (**)(TTenuousComponentFont *))(*(void *)this + 848))(this)) {
    return 0;
  }
  if ((*((_DWORD *)this + 46) & 0x80) == 0) {
    TBaseFont::DetermineFontFlags(this, 0x80u);
  }
  return (*((_DWORD *)this + 45) >> 7) & 1;
}

uint64_t TcmapTable::MapRange(TBaseFont **this, CFRange a2, unsigned __int16 *a3)
{
  if (!TBaseFont::GetInitializedGraphicsFont(*this) || !CGFontGetParserFont()) {
    return 0;
  }

  return MEMORY[0x1F4119CD8]();
}

uint64_t TBaseFont::GetGlyphsForCharactersWithCMap(atomic_ullong *this, TBaseFont **a2, const unsigned __int16 *a3, unsigned __int16 *a4, uint64_t a5)
{
  uint64_t v5 = a5;
  uint64_t v6 = a4;
  uint64_t v7 = a3;
  uint64_t v10 = TcmapTable::Map(a2, a3, a4, a5, 0);
  uint64_t v11 = v5 - v10;
  uint64_t v23 = v10;
  if (v5 > v10)
  {
    unint64_t SynthesizedGlyphs = TBaseFont::GetSynthesizedGlyphs(this);
    if (SynthesizedGlyphs)
    {
      if (v5 >= 1)
      {
        uint64_t v13 = (void *)SynthesizedGlyphs;
        if (*(void *)(SynthesizedGlyphs + 24))
        {
          uint64_t v14 = v6;
          uint64_t v15 = (unsigned __int16 *)v7;
          uint64_t v16 = v5;
          do
          {
            if (!*v14)
            {
              UTF32Char v17 = std::__hash_table<std::__hash_value_type<unsigned short,OTL::FeatureTable const*>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,OTL::FeatureTable const*>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,OTL::FeatureTable const*>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,OTL::FeatureTable const*>>>::find<unsigned short>(v13, v15);
              if (v17)
              {
                *uint64_t v14 = *((_WORD *)v17 + 9);
                ++v23;
              }
              if (!--v11) {
                break;
              }
            }
            ++v15;
            ++v14;
            --v16;
          }
          while (v16);
        }
      }
    }
  }
  int v18 = (*(uint64_t (**)(atomic_ullong *))(*this + 728))(this);
  if (v5 >= 1 && v18)
  {
    do
    {
      unsigned int v19 = *v7++;
      int v20 = (1 << v19) & 0x2600;
      if (v19 <= 0xD && v20 != 0)
      {
        unsigned __int16 v24 = 32;
        TcmapTable::Map(a2, &v24, v6, 1, 1);
      }
      ++v6;
      --v5;
    }
    while (v5);
  }
  return v23;
}

uint64_t TcmapTable::Map(TBaseFont **this, const unsigned __int16 *a2, unsigned __int16 *a3, uint64_t a4, char a5)
{
  uint64_t v82 = *MEMORY[0x1E4F143B8];
  if (TBaseFont::GetInitializedGraphicsFont(*this) && CGFontGetParserFont())
  {
    return MEMORY[0x1F4119CE0]();
  }
  id v71 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr))(*(void *)*this + 496))(&v71);
  if (atomic_load_explicit((atomic_ullong *volatile)&v71, memory_order_acquire))
  {
    char v70 = a5;
    atomic_load_explicit((atomic_ullong *volatile)&v71, memory_order_acquire);
    CGFontGetGlyphsForUnichars();
    *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v80[3] = v10;
    v80[2] = v10;
    v80[1] = v10;
    v80[0] = v10;
    unsigned int v78 = 0;
    uint64_t v79 = 0;
    __src = 0;
    int v81 = v80;
    if (a4 < 1)
    {
      UTF32Char v17 = 0;
      uint64_t v18 = 0;
      uint64_t v19 = 0;
    }
    else
    {
      uint64_t v11 = 0;
      uint64_t v12 = a2;
      uint64_t v13 = a2;
      while (1)
      {
        __int16 v14 = *v13++;
        BOOL v15 = (v14 & 0xFC00) != 0xD800 || a4 - 1 == v11;
        if (!v15 && (v12[1] & 0xFC00) == 0xDC00) {
          break;
        }
        ++v11;
        uint64_t v12 = v13;
        if (a4 == v11) {
          goto LABEL_94;
        }
      }
      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::reserve((char **)&__src, ~v11 + a4);
      int v20 = v78;
      if (v78 >= v79)
      {
        unsigned int v21 = (void **)__src;
        uint64_t v22 = v78 - (unsigned char *)__src;
        if (v78 - (unsigned char *)__src <= -3) {
LABEL_122:
        }
          abort();
        uint64_t v23 = v22 >> 1;
        if (v79 - (unsigned char *)__src <= (unint64_t)((v22 >> 1) + 1)) {
          uint64_t v24 = v23 + 1;
        }
        else {
          uint64_t v24 = v79 - (unsigned char *)__src;
        }
        if ((unint64_t)(v79 - (unsigned char *)__src) >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v25 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v25 = v24;
        }
        CFIndex v76 = v80;
        if (v25)
        {
          int v26 = (char *)TInlineBufferAllocator<unsigned short,30ul>::allocate((uint64_t)v80, v25);
          unsigned int v21 = (void **)__src;
          int v20 = v78;
        }
        else
        {
          int v26 = 0;
        }
        unint64_t v27 = &v26[2 * v23];
        *(_WORD *)unint64_t v27 = 0;
        if (v20 == (char *)v21)
        {
          __int16 v29 = &v26[2 * v23];
        }
        else
        {
          id v28 = (void **)v20;
          __int16 v29 = &v26[2 * v23];
          do
          {
            __int16 v30 = *((_WORD *)v28 - 1);
            id v28 = (void **)((char *)v28 - 2);
            *((_WORD *)v29 - 1) = v30;
            v29 -= 2;
          }
          while (v28 != v21);
        }
        UTF32Char v17 = v27 + 2;
        __src = v29;
        unsigned int v78 = v27 + 2;
        BOOL v31 = v79;
        uint64_t v79 = &v26[2 * v25];
        uint64_t v74 = v20;
        uint64_t v75 = v31;
        p_src = v21;
        unint64_t v73 = v21;
        std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,30ul> &>::~__split_buffer((uint64_t)&p_src);
      }
      else
      {
        *(_WORD *)unsigned int v78 = 0;
        UTF32Char v17 = v20 + 2;
      }
      uint64_t v18 = v11 + 2;
      uint64_t v19 = v11 + 1;
      unsigned int v78 = v17;
    }
    if (v19 < a4)
    {
      for (uint64_t i = v19; v18 < a4; ++v19)
      {
        uint64_t v32 = v18 + 1;
        unsigned int v33 = a2[v18];
        if ((v33 & 0xFC00) != 0xD800 || v32 == a4)
        {
          ++v18;
        }
        else
        {
          int v35 = a2[v32];
          BOOL v36 = (v35 & 0xFC00) == 56320;
          unsigned int v37 = (v33 << 10) - 56613888 + v35;
          if (v36) {
            v18 += 2;
          }
          else {
            ++v18;
          }
          if (v36) {
            unsigned int v33 = v37;
          }
        }
        if (v17 >= v79)
        {
          id v38 = (void **)__src;
          uint64_t v39 = v17 - (unsigned char *)__src;
          if (v17 - (unsigned char *)__src <= -3) {
            goto LABEL_122;
          }
          uint64_t v40 = v39 >> 1;
          if (v79 - (unsigned char *)__src <= (unint64_t)((v39 >> 1) + 1)) {
            uint64_t v41 = v40 + 1;
          }
          else {
            uint64_t v41 = v79 - (unsigned char *)__src;
          }
          if ((unint64_t)(v79 - (unsigned char *)__src) >= 0x7FFFFFFFFFFFFFFELL) {
            uint64_t v42 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v42 = v41;
          }
          CFIndex v76 = v80;
          if (v42)
          {
            __int16 v43 = (char *)TInlineBufferAllocator<unsigned short,30ul>::allocate((uint64_t)v80, v42);
            id v38 = (void **)__src;
            UTF32Char v17 = v78;
          }
          else
          {
            __int16 v43 = 0;
          }
          double v44 = &v43[2 * v40];
          *(_WORD *)double v44 = a3[v19];
          if (v17 == (char *)v38)
          {
            uint64_t v46 = &v43[2 * v40];
          }
          else
          {
            uint64_t v45 = (void **)v17;
            uint64_t v46 = &v43[2 * v40];
            do
            {
              __int16 v47 = *((_WORD *)v45 - 1);
              uint64_t v45 = (void **)((char *)v45 - 2);
              *((_WORD *)v46 - 1) = v47;
              v46 -= 2;
            }
            while (v45 != v38);
          }
          unint64_t v48 = v44 + 2;
          __src = v46;
          unsigned int v78 = v44 + 2;
          uint64_t v49 = v79;
          uint64_t v79 = &v43[2 * v42];
          uint64_t v74 = v17;
          uint64_t v75 = v49;
          p_src = v38;
          unint64_t v73 = v38;
          std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,30ul> &>::~__split_buffer((uint64_t)&p_src);
          UTF32Char v17 = v48;
        }
        else
        {
          *(_WORD *)UTF32Char v17 = a3[v19];
          v17 += 2;
        }
        unsigned int v78 = v17;
        if (v33 >= 0x10000)
        {
          if (v17 >= v79)
          {
            BOOL v51 = (void **)__src;
            uint64_t v52 = v17 - (unsigned char *)__src;
            if (v17 - (unsigned char *)__src <= -3) {
              goto LABEL_122;
            }
            uint64_t v53 = v52 >> 1;
            if (v79 - (unsigned char *)__src <= (unint64_t)((v52 >> 1) + 1)) {
              uint64_t v54 = v53 + 1;
            }
            else {
              uint64_t v54 = v79 - (unsigned char *)__src;
            }
            if ((unint64_t)(v79 - (unsigned char *)__src) >= 0x7FFFFFFFFFFFFFFELL) {
              uint64_t v55 = 0x7FFFFFFFFFFFFFFFLL;
            }
            else {
              uint64_t v55 = v54;
            }
            CFIndex v76 = v80;
            if (v55)
            {
              unint64_t v56 = (char *)TInlineBufferAllocator<unsigned short,30ul>::allocate((uint64_t)v80, v55);
              BOOL v51 = (void **)__src;
              UTF32Char v17 = v78;
            }
            else
            {
              unint64_t v56 = 0;
            }
            long long v57 = &v56[2 * v53];
            *(_WORD *)long long v57 = 0;
            if (v17 == (char *)v51)
            {
              BOOL v59 = &v56[2 * v53];
            }
            else
            {
              uint64_t v58 = (void **)v17;
              BOOL v59 = &v56[2 * v53];
              do
              {
                __int16 v60 = *((_WORD *)v58 - 1);
                uint64_t v58 = (void **)((char *)v58 - 2);
                *((_WORD *)v59 - 1) = v60;
                v59 -= 2;
              }
              while (v58 != v51);
            }
            unint64_t v50 = v57 + 2;
            __src = v59;
            unsigned int v78 = v57 + 2;
            unint64_t v61 = v79;
            uint64_t v79 = &v56[2 * v55];
            uint64_t v74 = v17;
            uint64_t v75 = v61;
            p_src = v51;
            unint64_t v73 = v51;
            std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,30ul> &>::~__split_buffer((uint64_t)&p_src);
            UTF32Char v17 = v50;
          }
          else
          {
            *(_WORD *)UTF32Char v17 = 0;
            v17 += 2;
            unint64_t v50 = v17;
          }
          unsigned int v78 = v50;
        }
      }
      if (v17 != __src) {
        memmove(&a3[i], __src, v17 - (unsigned char *)__src);
      }
    }
LABEL_94:
    p_src = &__src;
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100](&p_src);
    if (a4 < 1 || (v70 & 1) != 0)
    {
      uint64_t v16 = a4;
      goto LABEL_121;
    }
    uint64_t v16 = a4;
LABEL_97:
    uint64_t v62 = a4;
    while (1)
    {
      a4 = v62 - 1;
      if (v62 != 1 && (a2[a4] & 0xFC00) == 0xDC00)
      {
        uint64_t v63 = v62 - 2;
        if ((a2[v63] & 0xFC00) == 0xD800) {
          a4 = v63;
        }
      }
      if (a3[a4])
      {
LABEL_118:
        if (a4 < 1) {
          goto LABEL_121;
        }
        goto LABEL_97;
      }
      unsigned int v64 = a2[a4];
      if ((v64 & 0xF800) == 0xD800)
      {
        if ((v64 & 0x400) != 0)
        {
          if (a4)
          {
            int v66 = a2[a4 - 1];
            BOOL v15 = (v66 & 0xFC00) == 55296;
            int v67 = v64 - 56613888 + (v66 << 10);
            if (v15) {
              unsigned int v64 = v67;
            }
          }
        }
        else if (a4 + 1 != v16)
        {
          int v65 = a2[a4 + 1];
          if ((v65 & 0xFC00) == 0xDC00)
          {
            unsigned int v64 = (v64 << 10) - 56613888 + v65;
LABEL_114:
            if (v64 - 917760 > 0xEF)
            {
LABEL_117:
              --v16;
              goto LABEL_118;
            }
            goto LABEL_115;
          }
        }
      }
      if (v64 >> 9 <= 0x7E) {
        goto LABEL_117;
      }
      if (v64 >> 4 >= 0xFE1) {
        goto LABEL_114;
      }
LABEL_115:
      uint64_t v62 = a4;
      if (a4 <= 0) {
        goto LABEL_121;
      }
    }
  }
  if (a4 >= 1) {
    bzero(a3, 2 * a4);
  }
  uint64_t v16 = 0;
LABEL_121:

  return v16;
}

uint64_t FirstMappedOf(TBaseFont **this, const unsigned __int16 (*a2)[2])
{
  char v4 = 0;
  for (uint64_t i = 0; ; uint64_t i = 1)
  {
    char v6 = v4;
    unsigned __int16 v9 = (*a2)[i];
    if (v9)
    {
      unsigned __int16 v8 = 0;
      TcmapTable::Map(this, &v9, &v8, 1, 1);
      uint64_t result = v8;
      if (v8) {
        break;
      }
    }
    char v4 = 1;
    if (v6) {
      return 0;
    }
  }
  return result;
}

uint64_t TBaseFont::IsMicrosoftKorean(TBaseFont *this)
{
  if ((*((_DWORD *)this + 46) & 0x80) == 0) {
    TBaseFont::DetermineFontFlags(this, 0x80u);
  }
  return (*((_DWORD *)this + 45) >> 7) & 1;
}

uint64_t TBaseFont::GetGlyphsForCharacters(TBaseFont *this, const unsigned __int16 *a2, unsigned __int16 *a3, uint64_t a4)
{
  uint64_t v5 = this;
  return TBaseFont::GetGlyphsForCharactersWithCMap((atomic_ullong *)this, &v5, a2, a3, a4);
}

unint64_t TBaseFont::GetSynthesizedGlyphs(atomic_ullong *this)
{
  unint64_t explicit = atomic_load_explicit(this + 27, memory_order_acquire);
  if (explicit) {
    return explicit;
  }
  char v4 = (char *)operator new(0x28uLL, MEMORY[0x1E4FBA2D0]);
  unint64_t explicit = (unint64_t)v4;
  if (!v4) {
    return explicit;
  }
  *(_OWORD *)char v4 = 0u;
  *((_OWORD *)v4 + 1) = 0u;
  uint64_t v5 = v4 + 16;
  *((_DWORD *)v4 + 8) = 1065353216;
  std::__hash_table<std::__hash_value_type<unsigned int,OTL::Lookup>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,OTL::Lookup>>>::__rehash<true>((uint64_t)v4, 0xCuLL);
  id v28 = this;
  BOOL v31 = this;
  char v6 = L"\t ";
  do
  {
    *(_DWORD *)__int16 v30 = *(_DWORD *)v6;
    *(_WORD *)&v30[4] = v6[2];
    unsigned __int16 v29 = 0;
    TcmapTable::Map((TBaseFont **)&v31, (const unsigned __int16 *)v30, &v29, 1, 1);
    if (!v29)
    {
      int MappedOf = FirstMappedOf((TBaseFont **)&v31, (const unsigned __int16 (*)[2])&v30[2]);
      if (MappedOf)
      {
        __int16 v8 = MappedOf;
        unint64_t v9 = *(unsigned __int16 *)v30;
        unint64_t v10 = *(void *)(explicit + 8);
        if (v10)
        {
          uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
          v11.i16[0] = vaddlv_u8(v11);
          if (v11.u32[0] > 1uLL)
          {
            unint64_t v12 = *(unsigned __int16 *)v30;
            if (v10 <= *(unsigned __int16 *)v30) {
              unint64_t v12 = *(unsigned __int16 *)v30 % v10;
            }
          }
          else
          {
            unint64_t v12 = (v10 - 1) & (unint64_t)*(unsigned __int16 *)v30;
          }
          uint64_t v13 = *(uint64_t ****)(*(void *)explicit + 8 * v12);
          if (v13)
          {
            for (uint64_t i = *v13; i; uint64_t i = (uint64_t **)*i)
            {
              unint64_t v15 = (unint64_t)i[1];
              if (v15 == *(unsigned __int16 *)v30)
              {
                if (*((unsigned __int16 *)i + 8) == *(unsigned __int16 *)v30) {
                  goto LABEL_46;
                }
              }
              else
              {
                if (v11.u32[0] > 1uLL)
                {
                  if (v15 >= v10) {
                    v15 %= v10;
                  }
                }
                else
                {
                  v15 &= v10 - 1;
                }
                if (v15 != v12) {
                  break;
                }
              }
            }
          }
        }
        else
        {
          unint64_t v12 = 0xAAAAAAAAAAAAAAAALL;
        }
        uint64_t v16 = operator new(0x18uLL);
        *uint64_t v16 = 0;
        v16[1] = v9;
        *((_WORD *)v16 + 8) = v9;
        *((_WORD *)v16 + 9) = v8;
        float v17 = (float)(unint64_t)(*(void *)(explicit + 24) + 1);
        float v18 = *(float *)(explicit + 32);
        if (!v10 || (float)(v18 * (float)v10) < v17)
        {
          BOOL v19 = (v10 & (v10 - 1)) != 0;
          if (v10 < 3) {
            BOOL v19 = 1;
          }
          unint64_t v20 = v19 | (2 * v10);
          unint64_t v21 = vcvtps_u32_f32(v17 / v18);
          if (v20 <= v21) {
            size_t v22 = v21;
          }
          else {
            size_t v22 = v20;
          }
          std::__hash_table<std::__hash_value_type<unsigned int,OTL::Lookup>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,OTL::Lookup>>>::__rehash<true>(explicit, v22);
          unint64_t v10 = *(void *)(explicit + 8);
          if ((v10 & (v10 - 1)) != 0)
          {
            if (v10 <= v9) {
              unint64_t v12 = v9 % v10;
            }
            else {
              unint64_t v12 = v9;
            }
          }
          else
          {
            unint64_t v12 = (v10 - 1) & v9;
          }
        }
        uint64_t v23 = *(void *)explicit;
        uint64_t v24 = *(void **)(*(void *)explicit + 8 * v12);
        if (v24)
        {
          *uint64_t v16 = *v24;
        }
        else
        {
          *uint64_t v16 = *v5;
          *uint64_t v5 = v16;
          *(void *)(v23 + 8 * v12) = v5;
          if (!*v16)
          {
LABEL_45:
            ++*(void *)(explicit + 24);
            goto LABEL_46;
          }
          unint64_t v25 = *(void *)(*v16 + 8);
          if ((v10 & (v10 - 1)) != 0)
          {
            if (v25 >= v10) {
              v25 %= v10;
            }
          }
          else
          {
            v25 &= v10 - 1;
          }
          uint64_t v24 = (void *)(*(void *)explicit + 8 * v25);
        }
        *uint64_t v24 = v16;
        goto LABEL_45;
      }
    }
LABEL_46:
    v6 += 3;
  }
  while (v6 != (const __int16 *)&xmmword_184BA8A68);
  uint64_t v26 = 0;
  atomic_compare_exchange_strong(v28 + 27, (unint64_t *)&v26, explicit);
  if (v26)
  {
    uint64_t v27 = std::__hash_table<EncoderAttempt,std::hash<EncoderAttempt>,std::equal_to<EncoderAttempt>,std::allocator<EncoderAttempt>>::~__hash_table(explicit);
    MEMORY[0x1853275C0](v27, 0x10A0C408EF24B1CLL);
    return v26;
  }
  return explicit;
}

uint64_t TSplicedFont::GetGlyphsForCharacterRange(TSplicedFont *this, CFRange a2, unsigned __int16 *a3)
{
  uint64_t v3 = *(void *)(*((void *)this + 76) + 40);
  if ((*(_DWORD *)(v3 + 16) & 0x80000000) == 0) {
    TDescriptor::InitBaseFont(*(TDescriptor **)(*((void *)this + 76) + 40), 0, 0.0);
  }
  char v4 = *(uint64_t (**)(void))(*(void *)atomic_load_explicit((atomic_ullong *volatile)(v3 + 32), memory_order_acquire)
                           + 672);

  return v4();
}

void TAATKernEngine::TAATKernEngine(TAATKernEngine *this, TRunGlue *a2)
{
  *(void *)this = a2;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 9) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = (char *)this + 64;
  *((unsigned char *)this + 80) = 0;
  CFDataRef CommonTable = (const __CFData *)TBaseFont::GetCommonTable(*(TBaseFont **)(*((void *)a2 + 77) + 400), 1801810542, 0);
  *((void *)this + 11) = CommonTable;
  if (!CommonTable)
  {
    *((void *)this + 12) = 0;
    *((unsigned char *)this + 112) = *(unsigned char *)(*(void *)this + 634);
    return;
  }
  BytePtr = CFDataGetBytePtr(CommonTable);
  *((void *)this + 12) = BytePtr;
  *((unsigned char *)this + 112) = *(unsigned char *)(*(void *)this + 634);
  if (BytePtr)
  {
    uint64_t v5 = BytePtr;
    CFIndex Length = CFDataGetLength(*((CFDataRef *)this + 11));
    *((void *)this + 13) = &v5[Length];
    uint64_t v7 = (int *)*((void *)this + 12);
    if (v7 + 2 <= (int *)&v5[Length])
    {
      int v8 = *v7;
      if (v8 == 256)
      {
        *((unsigned char *)this + 113) = 0;
        return;
      }
      if (!(_WORD)v8)
      {
        *((unsigned char *)this + 113) = 1;
        return;
      }
    }
    unint64_t v9 = (__CFString *)(id)atomic_load_explicit((atomic_ullong *volatile)(*(void *)(*(void *)(*(void *)this + 616)+ 400)+ 96), memory_order_acquire);
    if (v9 == @"Bauhaus93")
    {
      unint64_t v12 = @"Bauhaus93";
    }
    else
    {
      if (v9)
      {
        unint64_t v10 = v9;
        int v11 = CFEqual(v9, @"Bauhaus93");

        if (v11)
        {
LABEL_18:
          uint64_t v13 = *(void *)(*(void *)(*(void *)this + 616) + 400);
          (*(void (**)(uint64_t, uint64_t))(*(void *)v13 + 488))(v13, 1801810542);
          *((void *)this + 12) = 0;
          return;
        }
      }
      else
      {
      }
      __int16 v14 = TFont::DebugDescription(*(TFont **)(*(void *)this + 616));
      CFLog();
      unint64_t v12 = v14;
    }

    goto LABEL_18;
  }
}

CTFontSymbolicTraits CTFontGetSymbolicTraits(CTFontRef font)
{
  if (font)
  {
    uint64_t v1 = (int *)*((void *)font + 5);
    int v2 = *v1;
    LODWORD(font) = (*(uint64_t (**)(void))(**((void **)v1 + 50) + 160))(*((void *)v1 + 50)) | ((v2 & 1) << 11);
  }
  return font;
}

uint64_t TInstanceFont::GetSymbolicTraitsInternal(atomic_ullong *this)
{
  unsigned int valuePtr = 0;
  TBaseFont::CopyAttributeInternal(this, @"NSCTFontSymbolicTrait", &v12);
  id v10 = (id)atomic_exchange((atomic_ullong *volatile)&v12, 0);

  if (atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire))
  {
    CFNumberRef v2 = (const __CFNumber *)(id)atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire);
    CFNumberGetValue(v2, kCFNumberIntType, &valuePtr);
  }
  else
  {
    id v12 = (id)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(id *__return_ptr, atomic_ullong *))(*this + 152))(&v12, this);
    CFNumberRef v2 = (const __CFNumber *)atomic_exchange((atomic_ullong *volatile)&v12, 0);

    CFDictionaryRef v3 = v2;
    CFDictionaryRef v4 = v3;
    if (v3) {
      CFNumberRef Value = (void *)CFDictionaryGetValue(v3, @"NSCTFontSymbolicTrait");
    }
    else {
      CFNumberRef Value = 0;
    }
    TCFRef<__CTFont const*>::Retain((atomic_ullong *)&v10, Value);

    if (atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire))
    {
      id v9 = (id)atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire);
      TBaseFont::SetAttributeInternal<TCFRef<__CFSet const*>>(this, (atomic_ullong *)&v9, @"NSCTFontSymbolicTrait");

      CFNumberRef v6 = (const __CFNumber *)(id)atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire);
      CFNumberGetValue(v6, kCFNumberIntType, &valuePtr);
    }
  }

  uint64_t v7 = valuePtr;
  return v7;
}

void TBaseFont::CopyWeightAxisValue(atomic_ullong *this@<X0>, unint64_t *a2@<X8>)
{
  id v17 = (id)0xAAAAAAAAAAAAAAAALL;
  TBaseFont::CopyAttributeInternal(this, @"CTFontWeightAxisValueAttribute", &v17);
  if (!atomic_load_explicit((atomic_ullong *volatile)&v17, memory_order_acquire))
  {
    id v16 = (id)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(id *__return_ptr, atomic_ullong *))(*this + 112))(&v16, this);
    if (atomic_load_explicit((atomic_ullong *volatile)&v16, memory_order_acquire))
    {
      CFNumberRef Value = (void *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v16, memory_order_acquire), &unk_1ED082E00);
      if (Value)
      {
        TCFRef<__CTFont const*>::Retain((atomic_ullong *)&v17, Value);
      }
      else
      {
        id v15 = (id)0xAAAAAAAAAAAAAAAALL;
        (*(void (**)(id *__return_ptr, atomic_ullong *))(*this + 120))(&v15, this);
        CFArrayRef explicit = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire);
        if (explicit)
        {
          CFIndex Count = CFArrayGetCount(explicit);
          if (Count)
          {
            CFIndex v9 = Count;
            CFIndex v10 = 0;
            while (1)
            {
              CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(explicit, v10);
              id v12 = (void *)CFDictionaryGetValue(ValueAtIndex, @"NSCTVariationAxisIdentifier");
              if (v12 == &unk_1ED082E00 || v12 && CFEqual(v12, &unk_1ED082E00)) {
                break;
              }
              if (v9 == ++v10) {
                goto LABEL_16;
              }
            }
            uint64_t v13 = (void *)CFDictionaryGetValue(ValueAtIndex, @"NSCTVariationAxisDefaultValue");
            TCFRef<__CTFont const*>::Retain((atomic_ullong *)&v17, v13);
          }
        }
LABEL_16:
      }
    }

    if (atomic_load_explicit((atomic_ullong *volatile)&v17, memory_order_acquire))
    {
      id v14 = (id)atomic_load_explicit((atomic_ullong *volatile)&v17, memory_order_acquire);
      TBaseFont::SetAttributeInternal<TCFRef<__CFSet const*>>(this, (atomic_ullong *)&v14, @"CTFontWeightAxisValueAttribute");
    }
    else
    {
      TBaseFont::SetAttributeInternal<__CFDictionary const*>(this, (const void *)*MEMORY[0x1E4F1D260], @"CTFontWeightAxisValueAttribute");
    }
    goto LABEL_20;
  }
  unint64_t v4 = atomic_load_explicit((atomic_ullong *volatile)&v17, memory_order_acquire);
  if (*MEMORY[0x1E4F1D260] != v4)
  {
LABEL_20:
    unint64_t v5 = atomic_exchange((atomic_ullong *volatile)&v17, 0);
    goto LABEL_21;
  }
  unint64_t v5 = 0;
LABEL_21:
  *a2 = v5;
}

void TBaseFont::CopyVariation(atomic_ullong *this@<X0>, unint64_t *a2@<X8>)
{
  id v10 = (id)0xAAAAAAAAAAAAAAAALL;
  TBaseFont::CopyAttributeInternal(this, @"NSCTFontVariationAttribute", &v9);
  id v10 = (id)atomic_exchange((atomic_ullong *volatile)&v9, 0);

  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire);
  unint64_t v5 = (const void **)MEMORY[0x1E4F1D260];
  if (explicit) {
    goto LABEL_12;
  }
  id v9 = (id)0xAAAAAAAAAAAAAAAALL;
  CopyVariationAttributeForSystemFont((const __CFString *)atomic_load_explicit(this + 12, memory_order_acquire), (CFDictionaryRef *)&v9);
  if (atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire))
  {
    if (CFDictionaryGetCount((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire)))
    {
      TCFRef<__CTFont const*>::Retain((atomic_ullong *)&v10, (id)atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire));
      goto LABEL_9;
    }
    id v8 = (id)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(id *__return_ptr, atomic_ullong *))(*this + 120))(&v8, this);
    if (atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire)) {
      TCFRef<__CTFont const*>::Retain((atomic_ullong *)&v10, (id)atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire));
    }
  }
  else
  {
    TBaseFont::GetInitializedGraphicsFont((TBaseFont *)this);
    CreateVariationDictFromGraphicsFont(&v8);
  }
LABEL_9:

  if (atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire))
  {
    id v7 = (id)atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire);
    TBaseFont::SetAttributeInternal<TCFRef<__CFSet const*>>(this, (atomic_ullong *)&v7, @"NSCTFontVariationAttribute");
  }
  else
  {
    TBaseFont::SetAttributeInternal<__CFDictionary const*>(this, *v5, @"NSCTFontVariationAttribute");
  }
LABEL_12:
  if (*v5 == (const void *)atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire)) {
    unint64_t v6 = 0;
  }
  else {
    unint64_t v6 = atomic_exchange((atomic_ullong *volatile)&v10, 0);
  }
  *a2 = v6;
}

void TBaseFont::CreateTraitsValuesPerFontInfo(atomic_ullong *a1@<X0>, _DWORD *a2@<X1>, atomic_ullong *a3@<X8>)
{
  if ((TBaseFont::SkipMetadata(a1) & 1) == 0)
  {
    *a3 = 0;
    CopyAttributeForSystemFont((const __CFString *)atomic_load_explicit(a1 + 12, memory_order_acquire), @"NSCTFontTraitsAttribute", (const __CFString **)valuePtr);

    if (atomic_load_explicit(a3, memory_order_acquire))
    {
      *a2 = 1;
      return;
    }
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  double v75 = 2.0;
  id v76 = Mutable;
  double v73 = 2.0;
  double v74 = 2.0;
  id v72 = 0;
  if (a1
    && ((int v7 = (*(uint64_t (**)(atomic_ullong *))(*a1 + 16))(a1), v7 != 1414809156)
      ? (BOOL v8 = v7 == 1413695044)
      : (BOOL v8 = 1),
        v8))
  {
    TBaseFont::CopyNativeFont(a1, valuePtr);
  }
  else if ((*(unsigned int (**)(atomic_ullong *))(*a1 + 16))(a1) == 1414088260)
  {
    TCFRef<__CTFont const*>::Retain((atomic_ullong *)&v72, (id)atomic_load_explicit(a1 + 80, memory_order_acquire));
  }
  if (atomic_load_explicit((atomic_ullong *volatile)&v72, memory_order_acquire))
  {
    atomic_load_explicit((atomic_ullong *volatile)&v72, memory_order_acquire);
  }
  else if (!TBaseFont::GetInitializedGraphicsFont((TBaseFont *)a1))
  {
LABEL_23:
    LODWORD(v13) = 0;
    LODWORD(v14) = 0;
    LODWORD(v15) = 0;
    LODWORD(v16) = 0;
    int v68 = -1;
    int v69 = 0;
    int v17 = -1;
    goto LABEL_86;
  }
  if (!CGFontGetParserFont() || !FPFontIsNamedInstance()) {
    goto LABEL_23;
  }
  CFDictionaryRef v9 = (const __CFDictionary *)FPFontCopyMetadata();
  CFDictionaryRef v10 = v9;
  if (v9)
  {
    valuePtr[0] = (id)0x4000000000000000;
    CFNumberRef Value = (void *)CFDictionaryGetValue(v9, @"MTD_Typeface_Metrics_IsMonoDesign");
    if ((objc_opt_respondsToSelector() & 1) != 0
      || (CFNumberRef Value = (void *)CFDictionaryGetValue(v10, @"MTD_Typeface_Metrics_IsFixedPitchFlag"),
          (objc_opt_respondsToSelector() & 1) != 0))
    {
      int v12 = [Value BOOLValue];
    }
    else
    {
      int v12 = -1;
    }
    float v18 = (void *)CFDictionaryGetValue(v10, @"MTD_Typeface_Style_IsItalicDesign");
    if (objc_opt_respondsToSelector()) {
      int v67 = [v18 BOOLValue];
    }
    else {
      int v67 = -1;
    }
    CFNumberRef v19 = (const __CFNumber *)CFDictionaryGetValue(v10, @"MTD_Typeface_Style_ItalicAngle");
    CFNumberRef v15 = v19;
    if (v19)
    {
      CFTypeID v20 = CFGetTypeID(v19);
      if (v20 == CFNumberGetTypeID() || v20 == CFBooleanGetTypeID())
      {
        CFNumberGetValue(v15, kCFNumberDoubleType, valuePtr);
        DoubleCFNumberRef Value = *(double *)valuePtr;
LABEL_33:
        char v22 = 0;
        *(double *)unsigned int valuePtr = DoubleValue / 180.0;
        LODWORD(v15) = 1;
        goto LABEL_38;
      }
      if (v20 == CFStringGetTypeID())
      {
        DoubleCFNumberRef Value = CFStringGetDoubleValue((CFStringRef)v15);
        goto LABEL_33;
      }
      LODWORD(v15) = 0;
    }
    char v22 = 1;
LABEL_38:
    int v68 = v12;
    uint64_t v23 = CFDictionaryGetValue(v10, @"MTD_Typeface_Width_VisualDescriptor");
    id v14 = v23;
    double v24 = 2.0;
    if (v23)
    {
      CFTypeID v25 = CFGetTypeID(v23);
      if (v25 == CFStringGetTypeID())
      {
        uint64_t v26 = (void *)[&unk_1ED07E488 objectForKeyedSubscript:v14];
        if (v26)
        {
          [v26 floatValue];
          double v28 = v27;
          LODWORD(v14) = 1;
LABEL_44:
          unsigned __int16 v29 = (__CFString *)CFDictionaryGetValue(v10, @"MTD_Typeface_Weight_VisualDescriptor");
          uint64_t v13 = v29;
          if (!v29) {
            goto LABEL_70;
          }
          CFTypeID v30 = CFGetTypeID(v29);
          if (v30 != CFStringGetTypeID()) {
            goto LABEL_69;
          }
          if (v13 == @"reg" || CFEqual(v13, @"reg"))
          {
            LODWORD(v13) = 1;
            double v24 = 0.0;
            goto LABEL_70;
          }
          unint64_t v31 = 0x3FD3333333333333;
          if (v13 == @"semi"
            || CFEqual(v13, @"semi")
            || (unint64_t v31 = 0x3FD999999999999ALL, v13 == @"bold")
            || CFEqual(v13, @"bold")
            || (unint64_t v31 = 0xBFD999999999999ALL, v13 == @"light")
            || CFEqual(v13, @"light")
            || (unint64_t v31 = 0x3FCD70A3D70A3D71, v13 == @"med")
            || CFEqual(v13, @"med")
            || (unint64_t v31 = 0x3FE1EB851EB851ECLL, v13 == @"heavy")
            || CFEqual(v13, @"heavy")
            || (unint64_t v31 = 0x3FE3D70A3D70A3D7, v13 == @"black")
            || CFEqual(v13, @"black")
            || (unint64_t v31 = 0xBFE3333333333333, v13 == @"thin")
            || CFEqual(v13, @"thin")
            || (unint64_t v31 = 0xBFE999999999999ALL, v13 == @"ulight")
            || CFEqual(v13, @"ulight"))
          {
            LODWORD(v13) = 1;
            double v24 = *(double *)&v31;
            goto LABEL_70;
          }
          if (v13 == @"uthin" || CFEqual(v13, @"uthin"))
          {
            LODWORD(v13) = 1;
            double v24 = -0.9;
          }
          else
          {
LABEL_69:
            LODWORD(v13) = 0;
          }
LABEL_70:
          uint64_t v32 = (__CFString *)CFDictionaryGetValue(v10, @"MTD_Typeface_Style_ATS_Class");
          id v16 = v32;
          if (!v32)
          {
            int v69 = 0;
            char v35 = 1;
            goto LABEL_79;
          }
          char v33 = v22;
          CFTypeID v34 = CFGetTypeID(v32);
          if (v34 != CFStringGetTypeID())
          {
            LODWORD(v16) = 0;
            int v69 = 0;
            char v35 = 1;
LABEL_78:
            char v22 = v33;
            goto LABEL_79;
          }
          char v22 = v33;
          if (v16 == @"old-style-serifs" || CFEqual(v16, @"old-style-serifs"))
          {
            char v35 = 0;
            int v36 = 0x10000000;
LABEL_75:
            int v69 = v36;
            LODWORD(v16) = 1;
LABEL_79:
            double v74 = v28;
            double v75 = v24;
            double v73 = *(double *)valuePtr;
            char v37 = v22 ^ 1;
            if (v13 | v14) {
              char v37 = 1;
            }
            if ((v37 & 1) != 0 || (v35 & 1) == 0)
            {
              *a2 = 1;
            }
            else
            {
              LODWORD(v15) = 0;
              LODWORD(v16) = 0;
            }
            goto LABEL_85;
          }
          if (v16 == @"transitional-serifs" || CFEqual(v16, @"transitional-serifs"))
          {
            char v35 = 0;
            int v36 = 0x20000000;
            goto LABEL_75;
          }
          if (v16 == @"modern-serifs" || CFEqual(v16, @"modern-serifs"))
          {
            char v35 = 0;
            int v36 = 805306368;
            goto LABEL_75;
          }
          if (v16 == @"clarendon-serifs" || CFEqual(v16, @"clarendon-serifs"))
          {
            char v35 = 0;
            int v36 = 0x40000000;
            goto LABEL_75;
          }
          if (v16 == @"slab-serifs" || CFEqual(v16, @"slab-serifs"))
          {
            char v35 = 0;
            int v36 = 1342177280;
            goto LABEL_75;
          }
          if (v16 == @"freeform-serifs" || CFEqual(v16, @"freeform-serifs"))
          {
            char v35 = 0;
            unsigned int v65 = 1879048192;
          }
          else if (v16 == @"sans-serif" || CFEqual(v16, @"sans-serif"))
          {
            char v35 = 0;
            unsigned int v65 = 0x80000000;
          }
          else
          {
            int v69 = -1879048192;
            if (v16 == @"ornamentals"
              || CFEqual(v16, @"ornamentals")
              || (int v69 = -1610612736, v16 == @"scripts")
              || CFEqual(v16, @"scripts")
              || (int v69 = -1073741824, v16 == @"symbolic"))
            {
              char v35 = 0;
              goto LABEL_198;
            }
            int v66 = CFEqual(v16, @"symbolic");
            char v35 = 0;
            if (v66) {
              unsigned int v65 = -1073741824;
            }
            else {
              unsigned int v65 = 0;
            }
          }
          int v69 = v65;
LABEL_198:
          LODWORD(v16) = 1;
          goto LABEL_78;
        }
      }
      LODWORD(v14) = 0;
    }
    double v28 = 2.0;
    goto LABEL_44;
  }
  LODWORD(v13) = 0;
  LODWORD(v14) = 0;
  LODWORD(v15) = 0;
  LODWORD(v16) = 0;
  int v68 = -1;
  int v69 = 0;
  int v67 = -1;
LABEL_85:

  int v17 = v67;
LABEL_86:
  if ((*(unsigned int (**)(atomic_ullong *))(*a1 + 16))(a1) == 1414088260)
  {
    BOOL v38 = v13 == 0;
    BOOL v39 = v14 == 0;
    int v40 = 1;
    if (v13 && v14 && v16)
    {
      LODWORD(v16) = 1;
      LODWORD(v14) = 1;
      goto LABEL_155;
    }
    goto LABEL_129;
  }
  (*(void (**)(id *__return_ptr, atomic_ullong *))(*a1 + 120))(valuePtr, a1);
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)valuePtr, memory_order_acquire);
  LOBYTE(v40) = explicit != 0;

  if (v13 || explicit) {
    goto LABEL_98;
  }
  uint64_t v42 = (__CFString *)atomic_load_explicit(a1 + 12, memory_order_acquire);
  if (!v42) {
    goto LABEL_128;
  }
  if (v42 != @"LucidaGrande"
    && !CFEqual(v42, @"LucidaGrande")
    && v42 != @".LucidaGrandeUI"
    && !CFEqual(v42, @".LucidaGrandeUI"))
  {
    if (v42 == @"STHeiti" || CFEqual(v42, @"STHeiti"))
    {
      LOBYTE(v40) = 0;
      double v43 = 0.24;
LABEL_108:
      double v75 = v43;
      goto LABEL_97;
    }
    if (v42 == @"STXihei" || CFEqual(v42, @"STXihei"))
    {
      LOBYTE(v40) = 0;
      double v43 = -0.1;
      goto LABEL_108;
    }
    if (v42 != @"TimesNewRomanPSMT" && !CFEqual(v42, @"TimesNewRomanPSMT"))
    {
      if (!v16)
      {
        if (v42 != @"Times-Roman" && !CFEqual(v42, @"Times-Roman"))
        {
          LODWORD(v16) = 0;
          goto LABEL_128;
        }
        int v69 = 0x10000000;
      }
      LODWORD(v16) = 1;
LABEL_128:
      LOBYTE(v40) = 0;
      LODWORD(v13) = 0;
      BOOL v39 = v14 == 0;
      BOOL v38 = 1;
      goto LABEL_129;
    }
  }
  LOBYTE(v40) = 0;
  double v75 = 0.0;
LABEL_97:
  LODWORD(v13) = 1;
LABEL_98:
  BOOL v38 = v13 == 0;
  BOOL v39 = v14 == 0;
  if (v14 && v16 && v13)
  {
    LODWORD(v16) = 1;
    LODWORD(v14) = 1;
    LODWORD(v13) = 1;
    if (v40)
    {
      int v40 = 1;
      goto LABEL_155;
    }
    goto LABEL_150;
  }
LABEL_129:
  memset(valuePtr, 170, sizeof(valuePtr));
  (*(void (**)(id *__return_ptr, atomic_ullong *, uint64_t))(*a1 + 480))(&v70, a1, 1330851634);
  OS2::OS2((atomic_ullong *)valuePtr, (atomic_ullong *)&v70);

  if ((uint64_t)valuePtr[2] >= 78)
  {
    if (v38)
    {
      unsigned int v44 = bswap32(*((unsigned __int16 *)valuePtr[1] + 2)) >> 16;
      if (v44 < 0xB) {
        LOWORD(v44) = 100 * v44;
      }
      int v45 = (unsigned __int16)v44;
      if ((unsigned __int16)v44 >= 0x3E8u) {
        int v45 = 1000;
      }
      if ((_WORD)v44) {
        unsigned int v46 = v45;
      }
      else {
        unsigned int v46 = 1;
      }
      double v75 = WeightOfClass(v46);
      LODWORD(v13) = 1;
    }
    if (v39)
    {
      unsigned int v47 = bswap32(*((unsigned __int16 *)valuePtr[1] + 3)) >> 16;
      if (v47 > 0xA)
      {
        LODWORD(v14) = 0;
        double v48 = 0.0;
      }
      else
      {
        double v48 = kWidthScale[v47];
        LODWORD(v14) = 1;
      }
      double v74 = v48;
    }
    int v49 = *((unsigned __int16 *)valuePtr[1] + 15);
    int v50 = v49 << 28;
    BOOL v51 = v49 == 0;
    if (*((_WORD *)valuePtr[1] + 15)) {
      LODWORD(v16) = 1;
    }
    int v52 = v69;
    if (!v51) {
      int v52 = v50;
    }
    int v69 = v52;
  }

  if (v40)
  {
    int v40 = (int)v13;
    goto LABEL_155;
  }
LABEL_150:
  if (v15 && v14 && v13)
  {
    int v40 = 1;
    LODWORD(v14) = 1;
    LODWORD(v15) = 1;
  }
  else
  {
    uint64_t TraitsFromSubfamilyName = GetTraitsFromSubfamilyName((const TBaseFont *)a1, (int)v13, (int)v14, (int)v15, &v75, &v74, &v73);
    int v40 = TraitsFromSubfamilyName;
    LODWORD(v14) = BYTE1(TraitsFromSubfamilyName);
    LODWORD(v15) = BYTE2(TraitsFromSubfamilyName);
  }
LABEL_155:
  int IsFixedPitch = v68;
  if (v15 && (v68 & 0x80000000) == 0) {
    goto LABEL_160;
  }
  uint64_t InitializedGraphicsFont = (CGFont *)TBaseFont::GetInitializedGraphicsFont((TBaseFont *)a1);
  if (InitializedGraphicsFont)
  {
    if (v15)
    {
      if ((v68 & 0x80000000) == 0)
      {
LABEL_160:
        LODWORD(v15) = 1;
        goto LABEL_161;
      }
    }
    else
    {
      double v73 = CGFontGetItalicAngle(InitializedGraphicsFont) * -0.00555555556;
      if ((v68 & 0x80000000) == 0) {
        goto LABEL_160;
      }
    }
    int IsFixedPitch = CGFontIsFixedPitch();
    goto LABEL_160;
  }
LABEL_161:
  if (((*(uint64_t (**)(atomic_ullong *, uint64_t))(*a1 + 472))(a1, 1935829368) & 1) != 0
    || ((*(uint64_t (**)(atomic_ullong *, uint64_t))(*a1 + 472))(a1, 1129270354) & 1) != 0)
  {
    int v56 = 1;
    if (v40) {
      goto LABEL_164;
    }
  }
  else
  {
    int v56 = (*(uint64_t (**)(atomic_ullong *, uint64_t))(*a1 + 472))(a1, 1398163232);
    if (v40)
    {
LABEL_164:
      double v57 = v75;
      if (v75 > 0.239) {
        int v58 = 2;
      }
      else {
        int v58 = 0;
      }
      goto LABEL_169;
    }
  }
  int v58 = 0;
  double v75 = 0.0;
  double v57 = 0.0;
LABEL_169:
  TCFNumber::TCFNumber<double>(valuePtr, v57);
  CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v76, memory_order_acquire), @"NSCTFontWeightTrait", (const void *)atomic_load_explicit((atomic_ullong *volatile)valuePtr, memory_order_acquire));

  if (v14)
  {
    double v59 = v74;
    if (v74 <= 0.15)
    {
      if (v74 < -0.15) {
        v58 |= 0x40u;
      }
    }
    else
    {
      v58 |= 0x20u;
    }
  }
  else
  {
    double v74 = 0.0;
    double v59 = 0.0;
  }
  TCFNumber::TCFNumber<double>(valuePtr, v59);
  CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v76, memory_order_acquire), @"NSCTFontProportionTrait", (const void *)atomic_load_explicit((atomic_ullong *volatile)valuePtr, memory_order_acquire));

  if (v15 && (double v60 = v73, fabs(v73) > 0.000001))
  {
    if (v17 < 0) {
      int v17 = 1;
    }
  }
  else
  {
    double v73 = 0.0;
    double v60 = 0.0;
  }
  TCFNumber::TCFNumber<double>(valuePtr, v60);
  CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v76, memory_order_acquire), @"NSCTFontSlantTrait", (const void *)atomic_load_explicit((atomic_ullong *volatile)valuePtr, memory_order_acquire));

  int v61 = v58 | 0x400;
  if (IsFixedPitch <= 0) {
    int v61 = v58;
  }
  int v62 = v69;
  if (!v16) {
    int v62 = 0;
  }
  int v63 = v61 | v62 | (v17 > 0);
  if (v56) {
    unsigned int v64 = v63 | 0x2000;
  }
  else {
    unsigned int v64 = v63;
  }
  TCFNumber::TCFNumber<unsigned int>(valuePtr, v64);
  CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v76, memory_order_acquire), @"NSCTFontSymbolicTrait", (const void *)atomic_load_explicit((atomic_ullong *volatile)valuePtr, memory_order_acquire));

  *a3 = atomic_exchange((atomic_ullong *volatile)&v76, 0);
}

uint64_t TBaseFont::SkipMetadata(atomic_ullong *this)
{
  if ((*(unsigned int (**)(atomic_ullong *))(*this + 16))(this) == 1414088260
    && atomic_load_explicit(this + 13, memory_order_acquire))
  {
    return IsNamedInstance((CGFont *)atomic_load_explicit(this + 13, memory_order_acquire)) ^ 1;
  }
  else
  {
    return 0;
  }
}

CFComparisonResult CompareLocalizedDescriptorsByTraitsAndPrecedence(void *a1, void *a2, void *a3, int a4, char a5, int a6)
{
  CFComparisonResult v6 = kCFCompareEqualTo;
  if (!a2 || !a1 || a1 == a2) {
    return v6;
  }
  uint64_t v10 = a1[5];
  uint64_t v11 = a2[5];
  if ((*(_DWORD *)(v10 + 16) & 0x80000000) == 0) {
    TDescriptor::InitBaseFont((TDescriptor *)a1[5], 0, 0.0);
  }
  unint64_t explicit = (atomic_ullong *)atomic_load_explicit((atomic_ullong *volatile)(v10 + 32), memory_order_acquire);
  if ((*(_DWORD *)(v11 + 16) & 0x80000000) == 0) {
    TDescriptor::InitBaseFont((TDescriptor *)v11, 0, 0.0);
  }
  uint64_t v13 = (atomic_ullong *)atomic_load_explicit((atomic_ullong *volatile)(v11 + 32), memory_order_acquire);
  if (explicit) {
    BOOL v14 = v13 == 0;
  }
  else {
    BOOL v14 = 1;
  }
  if (v14)
  {
    id v55 = (id)0xAAAAAAAAAAAAAAAALL;
    if (a4) {
      TDescriptor::CopyAttribute((atomic_ullong *)v10, &v54);
    }
    else {
      id v54 = 0;
    }
    id v55 = (id)atomic_exchange((atomic_ullong *volatile)&v54, 0);

    if (!atomic_load_explicit((atomic_ullong *volatile)&v55, memory_order_acquire))
    {
      TDescriptor::CopyAttribute((atomic_ullong *)v10, @"NSFontVisibleNameAttribute", &v54);
    }
    id v54 = (id)0xAAAAAAAAAAAAAAAALL;
    if (a4) {
      TDescriptor::CopyAttribute((atomic_ullong *)v11, &v51);
    }
    else {
      id v51 = 0;
    }
    id v54 = (id)atomic_exchange((atomic_ullong *volatile)&v51, 0);

    if (!atomic_load_explicit((atomic_ullong *volatile)&v54, memory_order_acquire))
    {
      TDescriptor::CopyAttribute((atomic_ullong *)v11, @"NSFontVisibleNameAttribute", &v51);
    }
    CFStringRef v16 = (const __CFString *)atomic_load_explicit((atomic_ullong *volatile)&v55, memory_order_acquire);
    CFStringRef v17 = (const __CFString *)atomic_load_explicit((atomic_ullong *volatile)&v54, memory_order_acquire);
    if (v16 == v17)
    {
      CFComparisonResult v6 = kCFCompareEqualTo;
    }
    else if (v16 && v17)
    {
      CFComparisonResult v6 = CFStringCompare(v16, v17, 0x61uLL);
    }
    else if (v16 < v17)
    {
      CFComparisonResult v6 = kCFCompareLessThan;
    }
    else
    {
      CFComparisonResult v6 = kCFCompareGreaterThan;
    }
    goto LABEL_34;
  }
  if (a5)
  {
    if ((*(uint64_t (**)(atomic_ullong *))(*explicit + 848))(explicit)) {
      int v15 = -1;
    }
    else {
      int v15 = (*(uint64_t (**)(atomic_ullong *))(*explicit + 696))(explicit);
    }
    if ((*(uint64_t (**)(atomic_ullong *))(*v13 + 848))(v13)) {
      int v18 = 1;
    }
    else {
      int v18 = (int)((*(unsigned int (**)(atomic_ullong *))(*v13 + 696))(v13) << 31) >> 31;
    }
    int v19 = v18 + v15;
    if (v19 >= 1) {
      int v19 = 1;
    }
    if (v19 < 0) {
      int v19 = -1;
    }
    if (v19) {
      return (uint64_t)v19;
    }
    id v55 = (id)0xAAAAAAAAAAAAAAAALL;
    atomic_ullong v20 = *explicit;
    if (a4)
    {
      (*(void (**)(id *__return_ptr, atomic_ullong *, __CFString *, void, void))(v20 + 88))(&v55, explicit, @"CTFontFamilyName", 0, 0);
      id v54 = (id)0xAAAAAAAAAAAAAAAALL;
      (*(void (**)(id *__return_ptr, atomic_ullong *, __CFString *, void, void))(*v13 + 88))(&v54, v13, @"CTFontFamilyName", 0, 0);
    }
    else
    {
      (*(void (**)(id *__return_ptr, atomic_ullong *, __CFString *))(v20 + 72))(&v55, explicit, @"CTFontFamilyName");
      id v54 = (id)0xAAAAAAAAAAAAAAAALL;
      (*(void (**)(id *__return_ptr, atomic_ullong *, __CFString *))(*v13 + 72))(&v54, v13, @"CTFontFamilyName");
    }
    CFStringRef v21 = (const __CFString *)atomic_load_explicit((atomic_ullong *volatile)&v55, memory_order_acquire);
    CFStringRef v22 = (const __CFString *)atomic_load_explicit((atomic_ullong *volatile)&v54, memory_order_acquire);
    if (v21 == v22)
    {
      CFComparisonResult v6 = kCFCompareEqualTo;
    }
    else if (v21 && v22)
    {
      CFComparisonResult v6 = CFStringCompare(v21, v22, 0x61uLL);
    }
    else
    {
      CFComparisonResult v6 = v21 < v22 ? kCFCompareLessThan : kCFCompareGreaterThan;
    }

    if (v6) {
      return v6;
    }
  }
  int v23 = (*(uint64_t (**)(atomic_ullong *))(*explicit + 16))(explicit);
  int v24 = (*(uint64_t (**)(atomic_ullong *))(*v13 + 16))(v13);
  atomic_ullong v25 = *explicit;
  if (v23 != v24)
  {
    unsigned int v42 = (*(uint64_t (**)(atomic_ullong *))(v25 + 16))(explicit);
    BOOL v28 = v42 > (*(unsigned int (**)(atomic_ullong *))(*v13 + 16))(v13);
LABEL_75:
    if (v28) {
      return 1;
    }
    else {
      return -1;
    }
  }
  unsigned int v26 = (*(uint64_t (**)(atomic_ullong *))(v25 + 160))(explicit);
  unsigned int v27 = (*(uint64_t (**)(atomic_ullong *))(*v13 + 160))(v13);
  BOOL v28 = (v26 & 0xFFFFF9C) > (v27 & 0xFFFFF9C);
  if ((v26 & 0xFFFFF9C) != (v27 & 0xFFFFF9C)) {
    goto LABEL_75;
  }
  unsigned int v29 = v27;
  uint64_t TraitsValues = atomic_load_explicit(explicit + 30, memory_order_acquire);
  if (!TraitsValues) {
    uint64_t TraitsValues = TBaseFont::CreateTraitsValues((TBaseFont *)explicit);
  }
  uint64_t v31 = atomic_load_explicit(v13 + 30, memory_order_acquire);
  if (!v31) {
    uint64_t v31 = TBaseFont::CreateTraitsValues((TBaseFont *)v13);
  }
  double v32 = *(double *)(TraitsValues + 16);
  double v33 = *(double *)(v31 + 16);
  if (vabdd_f64(v32, v33) >= 0.001) {
    goto LABEL_78;
  }
  if (vabdd_f64(*(double *)(TraitsValues + 8), *(double *)(v31 + 8)) >= 0.001)
  {
    Predefinedouble d = CFCharacterSetGetPredefined(kCFCharacterSetDecimalDigit);
    if (Predefined
      && (CFCharacterSetRef v47 = Predefined,
          NameHasCharacterFromSet((const TBaseFont *)explicit, @"CTFontSubFamilyName", a4, Predefined))
      && NameHasCharacterFromSet((const TBaseFont *)v13, @"CTFontSubFamilyName", a4, v47))
    {
      double v43 = *(double *)(TraitsValues + 8);
      double v44 = *(double *)(v31 + 8);
    }
    else
    {
      double v43 = *(double *)(TraitsValues + 8);
      double v44 = *(double *)(v31 + 8);
      if (a6)
      {
        if (fabs(v43) >= 0.001) {
          double v43 = v43 + 10.0;
        }
        if (fabs(v44) >= 0.001) {
          double v44 = v44 + 10.0;
        }
      }
    }
    goto LABEL_79;
  }
  double v32 = *(double *)(TraitsValues + 24);
  double v33 = *(double *)(v31 + 24);
  if (vabdd_f64(v32, v33) >= 0.001)
  {
LABEL_78:
    double v43 = fabs(v32);
    double v44 = fabs(v33);
LABEL_79:
    BOOL v40 = v43 <= v44;
LABEL_80:
    if (v40) {
      return -1;
    }
    else {
      return 1;
    }
  }
  unsigned int v34 = v26 >> 28;
  if (v26 >> 28 > 0xC) {
    unsigned int v34 = 0;
  }
  int v35 = ClassifyReduceTraitsClass::order[v34];
  unsigned int v36 = v29 >> 28;
  if (v29 >> 28 > 0xC) {
    unsigned int v36 = 0;
  }
  int v37 = ClassifyReduceTraitsClass::order[v36];
  if (v35 == v37)
  {
    double OpticalSize = GetOpticalSize((const TBaseFont *)explicit);
    double v39 = GetOpticalSize((const TBaseFont *)v13);
    BOOL v40 = OpticalSize <= v39;
    if (OpticalSize == v39)
    {
      id v55 = (id)0xAAAAAAAAAAAAAAAALL;
      atomic_ullong v41 = *explicit;
      if (a4)
      {
        (*(void (**)(id *__return_ptr, atomic_ullong *, __CFString *, void, void))(v41 + 88))(&v55, explicit, @"CTFontFullName", 0, 0);
        id v54 = (id)0xAAAAAAAAAAAAAAAALL;
        (*(void (**)(id *__return_ptr, atomic_ullong *, __CFString *, void, void))(*v13 + 88))(&v54, v13, @"CTFontFullName", 0, 0);
      }
      else
      {
        (*(void (**)(id *__return_ptr, atomic_ullong *, __CFString *))(v41 + 72))(&v55, explicit, @"CTFontFullName");
        id v54 = (id)0xAAAAAAAAAAAAAAAALL;
        (*(void (**)(id *__return_ptr, atomic_ullong *, __CFString *))(*explicit + 72))(&v54, explicit, @"CTFontFullName");
      }
      id v53 = (id)atomic_load_explicit((atomic_ullong *volatile)&v55, memory_order_acquire);
      id v52 = (id)atomic_load_explicit((atomic_ullong *volatile)&v54, memory_order_acquire);
      CFComparisonResult v6 = StringCompare<TCFRef<__CFString const*>,TCFRef<__CFString const*>>((atomic_ullong *)&v53, (atomic_ullong *)&v52);

      if (v6 == kCFCompareEqualTo)
      {
        unsigned int v48 = (*(uint64_t (**)(atomic_ullong *))(*explicit + 256))(explicit);
        unsigned int v49 = (*(uint64_t (**)(atomic_ullong *))(*v13 + 256))(v13);
        uint64_t v50 = -1;
        if (v48 <= v49) {
          uint64_t v50 = 1;
        }
        if (v48 == v49) {
          CFComparisonResult v6 = kCFCompareEqualTo;
        }
        else {
          CFComparisonResult v6 = v50;
        }
      }
LABEL_34:

      return v6;
    }
    goto LABEL_80;
  }
  if (v35 > v37) {
    return 1;
  }
  else {
    return -1;
  }
}

uint64_t TBaseFont::GetType(TBaseFont *this)
{
  return 1413629508;
}

unsigned int *TBaseFont::GetSymbolicTraitsInternal(atomic_ullong *this)
{
  uint64_t result = (unsigned int *)atomic_load_explicit(this + 30, memory_order_acquire);
  if (result) {
    return (unsigned int *)*result;
  }
  uint64_t result = (unsigned int *)TBaseFont::CreateTraitsValues((TBaseFont *)this);
  if (result) {
    return (unsigned int *)*result;
  }
  return result;
}

BOOL NameHasCharacterFromSet(const TBaseFont *a1, const __CFString *a2, int a3, const __CFCharacterSet *a4)
{
  id v9 = (id)0xAAAAAAAAAAAAAAAALL;
  uint64_t v5 = *(void *)a1;
  if (a3) {
    (*(void (**)(id *__return_ptr))(v5 + 88))(&v9);
  }
  else {
    (*(void (**)(id *__return_ptr))(v5 + 72))(&v9);
  }
  if (atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire))
  {
    CFStringRef explicit = (const __CFString *)atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire);
    v10.CFIndex length = CFStringGetLength((CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire));
    v10.CFIndex location = 0;
    BOOL v7 = CFStringFindCharacterFromSet(explicit, a4, v10, 0, 0) != 0;
  }
  else
  {
    BOOL v7 = 0;
  }

  return v7;
}

void TBaseFont::CopyName(atomic_ullong *this@<X0>, const __CFString *a2@<X1>, atomic_ullong *a3@<X8>)
{
  TBaseFont::CopyAttributeInternal(this, @"CTFontNames", &v20);
  CFComparisonResult v6 = (void *)atomic_exchange((atomic_ullong *volatile)&v20, 0);

  CFDictionaryRef Value = v6;
  CFDictionaryRef v8 = Value;
  if (Value) {
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(Value, a2);
  }
  *a3 = (atomic_ullong)Value;

  if (!atomic_load_explicit(a3, memory_order_acquire))
  {
    if (@"CTFontSyntheticName" == a2
      || a2 && @"CTFontSyntheticName" && CFEqual(a2, @"CTFontSyntheticName"))
    {
      a2 = @"CTFontPostScriptName";
    }
    else if (@"CTFontSyntheticFamilyName" == a2 {
           || a2 && @"CTFontSyntheticFamilyName" && CFEqual(a2, @"CTFontSyntheticFamilyName"))
    }
    {
      a2 = @"CTFontFamilyName";
    }
    if (@"CTFontPostScriptName" == a2
      || (a2 ? (BOOL v9 = @"CTFontPostScriptName" == 0) : (BOOL v9 = 1), !v9 && CFEqual(@"CTFontPostScriptName", a2)))
    {
      id v20 = (id)atomic_load_explicit(this + 12, memory_order_acquire);

      id v10 = v20;
LABEL_37:

      goto LABEL_38;
    }
    if (TBaseFont::SkipMetadata(this))
    {
LABEL_38:
      if (!atomic_load_explicit(a3, memory_order_acquire))
      {
        CFStringRef v16 = (CGFont *)(*(uint64_t (**)(atomic_ullong *))(*this + 576))(this);
        int v17 = FontNameCodeForKey(a2);
        CopyFontNameInternal(v16, 0, v17, (atomic_ullong *)&v20);
      }
      if (atomic_load_explicit(a3, memory_order_acquire))
      {
        id v20 = (id)0xAAAAAAAAAAAAAAAALL;
        TCFMutableDictionary::TCFMutableDictionary((TCFMutableDictionary *)&v20, (CFDictionaryRef)v6);
        CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire), a2, (const void *)atomic_load_explicit(a3, memory_order_acquire));
        TBaseFont::SetAttributeInternal<__CFDictionary const*>(this, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire), @"CTFontNames");
      }
      goto LABEL_42;
    }
    if (@"CTFontMarketingName" == a2
      || a2 && @"CTFontMarketingName" && CFEqual(a2, @"CTFontMarketingName"))
    {
      id v20 = (id)0xAAAAAAAAAAAAAAAALL;
      TBaseFont::CopyMetadata((TBaseFont *)this, 0, &v20);
      CFDictionaryRef v11 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire);
      if (v11)
      {
        CFDictionaryRef v12 = v11;
        uint64_t v13 = (void *)CFDictionaryGetValue(v11, @"MTD_Typeface_ID_TypefaceMarketingName");

        if (v13)
        {
          CFTypeID v14 = CFGetTypeID(v13);
          if (v14 == CFStringGetTypeID())
          {
            id v19 = v13;
            id v18 = (id)atomic_exchange((atomic_ullong *volatile)&v19, 0);
            int v15 = v19;
LABEL_32:

LABEL_35:
            goto LABEL_36;
          }
        }
      }
      else
      {
      }
      id v18 = 0;
      goto LABEL_35;
    }
    id v18 = 0;
    if (!(*(unsigned int (**)(atomic_ullong *))(*this + 704))(this))
    {
LABEL_36:

      id v10 = v18;
      goto LABEL_37;
    }
    CopyAttributeForSystemFont((const __CFString *)atomic_load_explicit(this + 12, memory_order_acquire), a2, (const __CFString **)&v20);
    int v15 = (void *)atomic_exchange((atomic_ullong *volatile)&v18, atomic_exchange((atomic_ullong *volatile)&v20, 0));
    goto LABEL_32;
  }
LABEL_42:
}

void TBaseFont::SetAttributeInternal<__CFDictionary const*>(atomic_ullong *a1, const void *a2, const void *a3)
{
  CFComparisonResult v6 = (os_unfair_lock_s *)(a1 + 14);
  os_unfair_lock_lock_with_options();
  CFStringRef explicit = (__CFDictionary *)atomic_load_explicit(a1 + 15, memory_order_acquire);
  if (a2)
  {
    if (!explicit) {
      TBaseFont::InitAttributesDict(a1);
    }
    CFDictionaryRef v8 = (__CFDictionary *)atomic_load_explicit(a1 + 15, memory_order_acquire);
    if (v8) {
      CFDictionarySetValue(v8, a3, a2);
    }
  }
  else if (explicit)
  {
    CFDictionaryRemoveValue(explicit, a3);
  }

  os_unfair_lock_unlock(v6);
}

void CopySecondaryScaleRecipeInternal(atomic_ullong *a1, atomic_ullong ***a2, atomic_ullong **a3, uint64_t a4, unsigned __int8 a5, int a6)
{
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  int v12 = a5;
  if (a5) {
    BOOL v13 = 1;
  }
  else {
    BOOL v13 = a2 != (atomic_ullong ***)a3;
  }
  if (v13 || (CFArrayRef v14 = (const __CFArray *)atomic_exchange(&sPreviousSecondaryScaleFontsAndRecipe, 0)) == 0)
  {
LABEL_10:
    id v55 = (id)0xAAAAAAAAAAAAAAAALL;
    CopyPhysicalFamilyName((const __CTFont *)&v55, (const __CTFont *)a2);
    if (v12 || a2 == (atomic_ullong ***)a3)
    {
      id v54 = (id)0xAAAAAAAAAAAAAAAALL;
      CopyPhysicalFamilyName((const __CTFont *)&v54, (const __CTFont *)a3);
      if (!a3)
      {
        double v24 = 0.0;
LABEL_18:
        *(void *)&long long v25 = -1;
        *((void *)&v25 + 1) = -1;
        *(_OWORD *)id v51 = v25;
        long long v52 = v25;
        unint64_t v53 = 0xAAAAAAAAAAAAAAAALL;
        CFStringRef explicit = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&v55, memory_order_acquire);
        Roundeddouble Weight = GetRoundedWeight(a2[5]);
        SecondaryScaleRecipeForFont((uint64_t)v51, (uint64_t)a2, explicit, atomic_load_explicit((atomic_ullong *volatile)&v54, memory_order_acquire), a4, a5, RoundedWeight, v24);
        if ((_BYTE)v53)
        {
          double v28 = *((double *)&v52 + 1);
          double v29 = *(double *)v51 / 100.0;
          if (v12) {
            double v29 = *(double *)&a4;
          }
          double v30 = v24 * v29;
          if (!a6
            || ((*(void (**)(id *__return_ptr))(*a2[5][50] + 120))(values),
                unint64_t v31 = atomic_load_explicit((atomic_ullong *volatile)values, memory_order_acquire),
                values[0],
                v31))
          {
            int v56 = (void *)0xAAAAAAAAAAAAAAAALL;
            CreateCopyOfFontWithSizeAndWeightClass((const __CTFont *)&v56, v30, *(double *)&v51[1], a2, v28 != 0.0);
            CFAllocatorRef v32 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
            id Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"NSFont", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v56, memory_order_acquire));
            TCFNumber::TCFNumber<double>(values, *(double *)&v52);
            CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"CTBaselineOffset", (const void *)atomic_load_explicit((atomic_ullong *volatile)values, memory_order_acquire));

            TCFNumber::TCFNumber<double>(values, *((double *)&v52 + 1));
            CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"CTTracking", (const void *)atomic_load_explicit((atomic_ullong *volatile)values, memory_order_acquire));

            if (v13)
            {
              if (!v12)
              {
                double v33 = a3[5];
                unsigned int v34 = (const void *)atomic_load_explicit((atomic_ullong *volatile)&v55, memory_order_acquire);
                int v35 = (const void *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
                unsigned int v36 = (os_unfair_lock_s *)(v33 + 46);
                os_unfair_lock_lock_with_options();
                values[0] = (id)0xAAAAAAAAAAAAAAAALL;
                v33 += 47;
                TCFMutableDictionary::TCFMutableDictionary((TCFMutableDictionary *)values, (id)atomic_load_explicit(v33, memory_order_acquire));
                CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)values, memory_order_acquire), v34, v35);

                os_unfair_lock_unlock(v36);
              }
            }
            else
            {
              values[1] = a2;
              unint64_t v58 = 0xAAAAAAAAAAAAAAAALL;
              values[0] = a2;
              unint64_t v58 = atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
            }
            *a1 = atomic_exchange((atomic_ullong *volatile)&Mutable, 0);

            unsigned int v48 = v56;
            goto LABEL_39;
          }
          id Mutable = (id)0xAAAAAAAAAAAAAAAALL;
          double v46 = GetRoundedWeight(a2[5]);
          double v44 = a2;
          CGFloat v45 = v30;
          BOOL v47 = v28 != 0.0;
        }
        else
        {
          if (!TFont::IsSystemUIFontAndForShaping(a3[5], (BOOL *)v51)) {
            goto LABEL_34;
          }
          *(void *)&long long v37 = -1;
          *((void *)&v37 + 1) = -1;
          *(_OWORD *)id v51 = v37;
          long long v52 = v37;
          unint64_t v53 = 0xAAAAAAAAAAAAAAAALL;
          BOOL v38 = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&v54, memory_order_acquire);
          double v39 = GetRoundedWeight((atomic_ullong **)a3[5]);
          SecondaryScaleRecipeForFont((uint64_t)v51, (uint64_t)a3, v38, atomic_load_explicit((atomic_ullong *volatile)&v54, memory_order_acquire), a4, a5, v39, v24);
          if (!(_BYTE)v53)
          {
LABEL_34:
            *a1 = 0;
LABEL_40:

LABEL_41:
            id v17 = v55;
            goto LABEL_42;
          }
          double v40 = *(double *)&v51[1];
          double v41 = *(double *)v51 / 100.0;
          if (v12) {
            double v41 = *(double *)&a4;
          }
          double v42 = v24 * v41;
          if (a6)
          {
            (*(void (**)(id *__return_ptr))(*a2[5][50] + 120))(values);
            unint64_t v43 = atomic_load_explicit((atomic_ullong *volatile)values, memory_order_acquire);

            if (!v43) {
              double v40 = GetRoundedWeight(a2[5]);
            }
          }
          id Mutable = (id)0xAAAAAAAAAAAAAAAALL;
          double v44 = a2;
          CGFloat v45 = v42;
          double v46 = v40;
          BOOL v47 = 0;
        }
        CreateCopyOfFontWithSizeAndWeightClass((const __CTFont *)&Mutable, v45, v46, v44, v47);
        int v56 = (void *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
        values[0] = @"NSFont";
        *a1 = (atomic_ullong)CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)values, (const void **)&v56, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        unsigned int v48 = Mutable;
LABEL_39:

        goto LABEL_40;
      }
    }
    else
    {
      int v49 = a6;
      id v18 = a1;
      *a1 = 0xAAAAAAAAAAAAAAAALL;
      id v19 = a3[5];
      id v20 = (const void *)atomic_load_explicit((atomic_ullong *volatile)&v55, memory_order_acquire);
      CFStringRef v21 = (os_unfair_lock_s *)(v19 + 46);
      os_unfair_lock_lock_with_options();
      CFDictionaryRef Value = (const __CFDictionary *)(id)atomic_load_explicit(v19 + 47, memory_order_acquire);
      CFDictionaryRef v23 = Value;
      if (Value) {
        CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(Value, v20);
      }
      v51[0] = Value;
      a1 = v18;
      *id v18 = atomic_exchange((atomic_ullong *volatile)v51, 0);

      os_unfair_lock_unlock(v21);
      if (atomic_load_explicit(v18, memory_order_acquire)) {
        goto LABEL_41;
      }

      id v54 = (id)0xAAAAAAAAAAAAAAAALL;
      CopyPhysicalFamilyName((const __CTFont *)&v54, (const __CTFont *)a3);
      a6 = v49;
    }
    double v24 = *((double *)a3[5] + 2);
    goto LABEL_18;
  }
  CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v14, 0);
  if (!CFEqual(ValueAtIndex, a2) || (CFStringRef v16 = CFArrayGetValueAtIndex(v14, 1), !CFEqual(v16, a2)))
  {
    CFRelease(v14);
    goto LABEL_10;
  }
  *a1 = 0xAAAAAAAAAAAAAAAALL;
  v51[0] = (id)(id)CFArrayGetValueAtIndex(v14, 2);
  *a1 = atomic_exchange((atomic_ullong *volatile)v51, 0);

  id v17 = (id)atomic_exchange(&sPreviousSecondaryScaleFontsAndRecipe, (unint64_t)v14);
LABEL_42:
}

uint64_t TCFBase<TFont>::ClassEqual(uint64_t a1, uint64_t a2)
{
  return TFont::operator==(*(TFont **)(a1 + 40), *(TFont **)(a2 + 40));
}

uint64_t TFont::operator==(TFont *this, TFont *a2)
{
  if (this == a2) {
    return 1;
  }
  if (*((double *)this + 2) != *((double *)a2 + 2)
    || *(_DWORD *)this != *(_DWORD *)a2
    || TFont::CompareExtras((atomic_ullong *)this, (atomic_ullong *)a2) != 2)
  {
    return 0;
  }
  CFStringRef explicit = (const void *)atomic_load_explicit((atomic_ullong *volatile)this + 1, memory_order_acquire);
  uint64_t v5 = (const void *)atomic_load_explicit((atomic_ullong *volatile)a2 + 1, memory_order_acquire);
  if (explicit == v5 || (uint64_t result = 0, explicit) && v5 && (uint64_t result = CFEqual(explicit, v5), result))
  {
    uint64_t v7 = *((void *)this + 5);
    uint64_t v8 = *((void *)a2 + 5);
    if (v7 == v8)
    {
      return 1;
    }
    else
    {
      if (v7) {
        BOOL v9 = (const void *)*((void *)this + 5);
      }
      else {
        BOOL v9 = (const void *)MEMORY[0x1E4F1DAB8];
      }
      if (v8) {
        id v10 = (const void *)*((void *)a2 + 5);
      }
      else {
        id v10 = (const void *)MEMORY[0x1E4F1DAB8];
      }
      return memcmp(v9, v10, 0x30uLL) == 0;
    }
  }
  return result;
}

uint64_t TFont::CompareExtras(atomic_ullong *this, atomic_ullong *a2)
{
  CFStringRef explicit = (const void *)atomic_load_explicit(this + 20, memory_order_acquire);
  uint64_t v5 = (const void *)atomic_load_explicit(a2 + 20, memory_order_acquire);
  if (explicit != v5)
  {
    BOOL v6 = !explicit || v5 == 0;
    if (v6 || !CFEqual(explicit, v5))
    {
      id v18 = (id)0xAAAAAAAAAAAAAAAALL;
      TCFMutableDictionary::TCFMutableDictionary((TCFMutableDictionary *)&v18, (CFDictionaryRef)atomic_load_explicit(this + 20, memory_order_acquire));
      id v17 = (id)0xAAAAAAAAAAAAAAAALL;
      TCFMutableDictionary::TCFMutableDictionary((TCFMutableDictionary *)&v17, (CFDictionaryRef)atomic_load_explicit(a2 + 20, memory_order_acquire));
      CFDictionaryRemoveValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v18, memory_order_acquire), @"NSCTFontFeatureSettingsAttribute");
      CFDictionaryRemoveValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v17, memory_order_acquire), @"NSCTFontFeatureSettingsAttribute");
      uint64_t v8 = (const void *)atomic_load_explicit((atomic_ullong *volatile)&v18, memory_order_acquire);
      BOOL v9 = (const void *)atomic_load_explicit((atomic_ullong *volatile)&v17, memory_order_acquire);
      if (v8 == v9) {
        goto LABEL_28;
      }
      uint64_t v7 = 0;
      if (!v8 || !v9) {
        goto LABEL_24;
      }
      if (CFEqual(v8, v9))
      {
LABEL_28:
        if (!atomic_load_explicit(this + 21, memory_order_acquire)) {
          goto LABEL_23;
        }
        id v10 = a2 + 21;
        if (!atomic_load_explicit(v10, memory_order_acquire)) {
          goto LABEL_23;
        }
        id v16 = (id)0xAAAAAAAAAAAAAAAALL;
        CreateSetWithArray((const __CFArray *)atomic_load_explicit(this + 21, memory_order_acquire), &v16);
        id v15 = (id)0xAAAAAAAAAAAAAAAALL;
        CreateSetWithArray((const __CFArray *)atomic_load_explicit(v10, memory_order_acquire), &v15);
        CFDictionaryRef v11 = (const void *)atomic_load_explicit((atomic_ullong *volatile)&v16, memory_order_acquire);
        int v12 = (const void *)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire);
        if (v11 == v12)
        {
        }
        else
        {
          if (!v11 || !v12)
          {

LABEL_23:
            uint64_t v7 = 1;
            goto LABEL_24;
          }
          int v13 = CFEqual(v11, v12);

          if (!v13) {
            goto LABEL_23;
          }
        }
        uint64_t v7 = 2;
      }
      else
      {
        uint64_t v7 = 0;
      }
LABEL_24:

      return v7;
    }
  }
  return 2;
}

void TCFMutableDictionary::TCFMutableDictionary(TCFMutableDictionary *this, CFDictionaryRef theDict)
{
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (theDict) {
    MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(v3, 0, theDict);
  }
  else {
    MutableCFDictionaryRef Copy = CFDictionaryCreateMutable(v3, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  }
  *(void *)this = MutableCopy;
}

void CopyPhysicalFamilyName(const __CTFont *a1, const __CTFont *a2)
{
  unint64_t v4 = (const __CTFont *)CTFontCopyPhysicalFont((uint64_t)a2);
  if (v4)
  {
    uint64_t v5 = v4;
    CFStringRef v6 = CTFontCopyFamilyName(v4);
  }
  else
  {

    CFStringRef v6 = CTFontCopyFamilyName(a2);
  }
  *(void *)a1 = v6;
}

CFStringRef CTFontCopyFamilyName(CTFontRef font)
{
  if (!font) {
    return 0;
  }
  (*(void (**)(id *__return_ptr))(**(void **)(*((void *)font + 5) + 400) + 72))(&v3);
  CFStringRef v1 = (const __CFString *)atomic_exchange((atomic_ullong *volatile)&v3, 0);

  return v1;
}

CFStringRef CTFontCopyPostScriptName(CTFontRef font)
{
  if (!font) {
    return 0;
  }
  (*(void (**)(id *__return_ptr))(**(void **)(*((void *)font + 5) + 400) + 72))(&v3);
  CFStringRef v1 = (const __CFString *)atomic_exchange((atomic_ullong *volatile)&v3, 0);

  return v1;
}

void TTenuousComponentFont::CopyName(atomic_ullong *this@<X0>, __CFString *cf1@<X1>, const __CFDictionary **a3@<X8>)
{
  if (@"CTFontPostScriptName" == cf1
    || cf1 && @"CTFontPostScriptName" && CFEqual(cf1, @"CTFontPostScriptName"))
  {
    CFStringRef explicit = (void *)atomic_load_explicit(this + 12, memory_order_acquire);
LABEL_6:
    *a3 = (const __CFDictionary *)explicit;
    return;
  }
  if (@"CTFontSyntheticFamilyName" == cf1)
  {
    BOOL v7 = 1;
  }
  else
  {
    BOOL v7 = 0;
    if (cf1 && @"CTFontSyntheticFamilyName") {
      BOOL v7 = CFEqual(cf1, @"CTFontSyntheticFamilyName") != 0;
    }
    if (!v7 && (this[89] & 0x8000) == 0)
    {
      char v8 = 0;
      BOOL v9 = 0;
LABEL_30:
      id v10 = cf1;
      goto LABEL_31;
    }
  }
  if (@"CTFontFullName" == cf1 || cf1 && @"CTFontFullName" && CFEqual(cf1, @"CTFontFullName"))
  {
    BOOL v9 = 0;
    char v8 = 0;
    id v10 = cf1;
    if (!v7) {
      goto LABEL_31;
    }
  }
  else
  {
    if (@"CTFontMarketingName" == cf1)
    {
      BOOL v9 = 0;
    }
    else
    {
      BOOL v9 = 1;
      if (cf1 && @"CTFontMarketingName") {
        BOOL v9 = CFEqual(cf1, @"CTFontMarketingName") == 0;
      }
    }
    if (!v7)
    {
      char v8 = 0;
      goto LABEL_30;
    }
  }
  char v8 = 1;
  id v10 = @"familyName";
LABEL_31:
  if (v10 == @"CTFontSyntheticName"
    || v10 && @"CTFontSyntheticName" && CFEqual(v10, @"CTFontSyntheticName"))
  {
    if ((*(unsigned int (**)(atomic_ullong *))(*this + 856))(this))
    {
      CFStringRef explicit = TComponentFont::GetSyntheticName((TComponentFont *)this);
      if (explicit) {
        goto LABEL_6;
      }
    }
    goto LABEL_61;
  }
  if (!v9) {
    goto LABEL_63;
  }
  if ((v8 & 1) != 0
    || @"CTFontFamilyName" == cf1
    || cf1 && @"CTFontFamilyName" && CFEqual(cf1, @"CTFontFamilyName"))
  {
    if ((*(unsigned int (**)(atomic_ullong *))(*this + 840))(this))
    {
      CFDictionaryRef v11 = (const __CFDictionary *)atomic_load_explicit(this + 90, memory_order_acquire);
      if (v11)
      {
        CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(v11, @"Components");
        if (Value)
        {
          CFArrayRef v13 = Value;
          CFIndex Count = CFArrayGetCount(Value);
          if (Count)
          {
            CFIndex v15 = Count;
            CFIndex v16 = 0;
            while (1)
            {
              CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v13, v16);
              id v18 = (id)CFDictionaryGetValue(ValueAtIndex, @"name");
              id v19 = (id)atomic_load_explicit(this + 12, memory_order_acquire);
              if (v19 == v18) {
                break;
              }
              id v20 = v19;
              if (v18 && v19)
              {
                int v21 = CFEqual(v18, v19);

                if (v21) {
                  goto LABEL_55;
                }
              }
              else
              {
              }
LABEL_58:
              if (v15 == ++v16) {
                goto LABEL_59;
              }
            }

LABEL_55:
            CFStringRef explicit = (void *)CFDictionaryGetValue(ValueAtIndex, @"familyName");
            if (explicit) {
              goto LABEL_6;
            }
            goto LABEL_58;
          }
        }
      }
    }
LABEL_59:
    CFDictionaryRef v22 = (const __CFDictionary *)atomic_load_explicit(this + 90, memory_order_acquire);
    if (v22)
    {
      CFStringRef explicit = (void *)CFDictionaryGetValue(v22, @"familyName");
      if (explicit) {
        goto LABEL_6;
      }
    }
  }
LABEL_61:
  *a3 = (const __CFDictionary *)0xAAAAAAAAAAAAAAAALL;
  TSplicedFontDict::CopyName(this + 90, v10, a3);
  if (atomic_load_explicit((atomic_ullong *volatile)a3, memory_order_acquire)) {
    return;
  }

LABEL_63:
  if ((*(uint64_t (**)(atomic_ullong *))(*this + 896))(this))
  {
    TBaseFont::CopyName(this, v10, (atomic_ullong *)a3);
  }
  else
  {
    *a3 = 0;
  }
}

void TSplicedFont::CopyName(atomic_ullong *this@<X0>, __CFString *a2@<X1>, void *a3@<X8>)
{
  TBaseFont::CopyAttributeInternal(this, @"CTFontNames", &v15);
  CFStringRef v6 = (void *)atomic_exchange((atomic_ullong *volatile)&v15, 0);

  CFDictionaryRef Value = v6;
  CFDictionaryRef v8 = Value;
  if (Value) {
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(Value, a2);
  }
  id v15 = Value;

  if (atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire)) {
    goto LABEL_11;
  }
  if (@"CTFontSyntheticFamilyName" == a2
    || (CFStringRef v9 = a2) != 0
    && (CFStringRef v9 = a2, @"CTFontSyntheticFamilyName")
    && (v10 = CFEqual(a2, @"CTFontSyntheticFamilyName"), CFStringRef v9 = a2, v10))
  {
    CFStringRef v9 = @"CTFontFamilyName";
  }
  int v11 = FontNameCodeForKey(v9);
  id v14 = TSplicedFontDict::FindFontName(this + 75, v11, 0);

  if (atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire))
  {
    NamesWithUpdatedName((const __CFDictionary *)&v14, (CFDictionaryRef)v6, a2, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire));
    TBaseFont::SetAttributeInternal<__CFDictionary const*>(this, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v14, memory_order_acquire), @"CTFontNames");

LABEL_11:
    *a3 = atomic_exchange((atomic_ullong *volatile)&v15, 0);
    goto LABEL_12;
  }
  uint64_t v12 = *(void *)(this[76] + 40);
  if ((*(_DWORD *)(v12 + 16) & 0x80000000) == 0) {
    TDescriptor::InitBaseFont((TDescriptor *)v12, 0, 0.0);
  }
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(v12 + 32), memory_order_acquire);
  (*(void (**)(unint64_t, __CFString *))(*(void *)explicit + 72))(explicit, a2);
LABEL_12:
}

const __CFString *TSplicedFontDict::IsInvisibleSplice(atomic_ullong *this)
{
  CFStringRef result = (const __CFString *)TSplicedFontDict::FindFontName(this, 6, 0);
  if (result) {
    return (const __CFString *)(CFStringGetCharacterAtIndex(result, 0) == 46);
  }
  CFStringRef result = (const __CFString *)TSplicedFontDict::FindFontName(this, 4, 0);
  if (result) {
    return (const __CFString *)(CFStringGetCharacterAtIndex(result, 0) == 46);
  }
  CFStringRef result = (const __CFString *)TSplicedFontDict::FindFontName(this, 1, 0);
  if (result) {
    return (const __CFString *)(CFStringGetCharacterAtIndex(result, 0) == 46);
  }
  return result;
}

const __CFDictionary *TSplicedFontDict::FindFontName(atomic_ullong *this, int a2, const __CFString *a3)
{
  if (a2 > 5)
  {
    if (a2 != 255 && a2 != 6)
    {
LABEL_14:
      CFDictionaryRef result = (const __CFDictionary *)atomic_load_explicit(this, memory_order_acquire);
      if (!result) {
        return result;
      }
      CFDictionaryRef result = (const __CFDictionary *)CFDictionaryGetValue(result, @"FontNames");
      if (!result) {
        return result;
      }
      CFArrayRef v9 = result;
      CFDictionaryRef result = (const __CFDictionary *)CFArrayGetCount(result);
      if (!result) {
        return result;
      }
      CFIndex v10 = (CFIndex)result - 1;
      while (1)
      {
        CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v9, v10);
        if (ValueAtIndex)
        {
          CFDictionaryRef v12 = ValueAtIndex;
          CFStringRef Value = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, @"type");
          if (CFStringGetIntValue(Value) == a2)
          {
            if (!a3) {
              break;
            }
            CFStringRef v14 = (const __CFString *)CFDictionaryGetValue(v12, @"language");
            if (v14 == a3 || v14 && CFEqual(v14, a3)) {
              break;
            }
          }
        }
        if (--v10 == -1) {
          return 0;
        }
      }
      CFDictionaryRef v8 = @"string";
      CFDictionaryRef result = v12;
      goto LABEL_11;
    }
  }
  else if (a2 != -1)
  {
    if (a2 == 1)
    {
      CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit(this, memory_order_acquire);
      if (explicit)
      {
        CFDictionaryRef result = (const __CFDictionary *)CFDictionaryGetValue(explicit, @"familyName");
        if (result) {
          return result;
        }
      }
    }
    goto LABEL_14;
  }
  CFDictionaryRef result = (const __CFDictionary *)atomic_load_explicit(this, memory_order_acquire);
  if (!result) {
    return result;
  }
  CFDictionaryRef v8 = @"name";
LABEL_11:

  return (const __CFDictionary *)CFDictionaryGetValue(result, v8);
}

unint64_t CTFontCopyPhysicalFont(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)(v1 + 400);
  if (!v2) {
    return 0;
  }
  uint64_t v9 = *(void *)(v1 + 16);
  id v8 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr))(*(void *)v2 + 520))(&v8);
  if (!atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire))
  {

    return 0;
  }
  id v7 = (id)0xAAAAAAAAAAAAAAAALL;
  CFDictionaryRef explicit = (const __CTFontDescriptor *)atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire);
  TCFBase_NEW<CTFont,__CTFontDescriptor const*,double &,decltype(nullptr),decltype(nullptr)>(&explicit, (double *)&v9, &v6);
  id v7 = (id)atomic_exchange((atomic_ullong *volatile)&v6, 0);

  unint64_t v3 = atomic_exchange((atomic_ullong *volatile)&v7, 0);
  return v3;
}

void TComponentFont::CopyPhysicalFontDescriptor(TComponentFont *this@<X0>, double a2@<D0>, void *a3@<X8>)
{
  id v5 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr, double))(*(void *)this + 200))(&v5, a2);
  if (atomic_load_explicit((atomic_ullong *volatile)&v5, memory_order_acquire))
  {
    TDescriptorSource::TDescriptorSource((TDescriptorSource *)&v4);
    TDescriptorSource::CopyDescriptor(&v4, (const __CFURL *)atomic_load_explicit((atomic_ullong *volatile)&v5, memory_order_acquire), 0, 0, a3);
  }
  else
  {
    *a3 = 0;
  }
}

void TCFBase_NEW<CTFont,__CTFontDescriptor const*,double &,decltype(nullptr),decltype(nullptr)>(const __CTFontDescriptor **a1@<X0>, double *a2@<X1>, void *a3@<X8>)
{
  uint64_t v6 = TCFBase<TFont>::Allocate();
  if (v6)
  {
    id v7 = (void *)v6;
    id v8 = *a1;
    double v9 = *a2;
    CFIndex v10 = (TFont *)(v6 + 48);
    void v7[2] = 0;
    void v7[3] = TFont::Hash;
    void v7[4] = 0;
    void v7[5] = v10;
    TFont::TFont(v10, v8, v9, 0, 0);
    id v11 = v7;
    *a3 = atomic_exchange((atomic_ullong *volatile)&v11, 0);
  }
  else
  {
    *a3 = 0;
  }
}

void NamesWithUpdatedName(const __CFDictionary *a1, CFDictionaryRef theDict, __CFString *a3, const void *a4)
{
  if (theDict)
  {
    id keys = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, theDict);
    CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&keys, memory_order_acquire), a3, a4);
    *(void *)a1 = atomic_exchange((atomic_ullong *volatile)&keys, 0);
  }
  else
  {
    id v7 = a4;
    id keys = a3;
    *(void *)a1 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&keys, &v7, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  }
}

uint64_t FontNameCodeForKey(const __CFString *key)
{
  for (unint64_t i = 0; i != 160; i += 8)
  {
    if (FontNameCodeForKey(__CFString const*)::keys[i / 8] == key) {
      return FontNameCodeForKey(__CFString const*)::values[i / 4];
    }
  }
  value = (void *)0xFFFFFFFFLL;
  if (qword_1EB2CE148 != -1) {
    dispatch_once_f(&qword_1EB2CE148, 0, (dispatch_function_t)FontNameCodeForKey(__CFString const*)::$_0::__invoke);
  }
  if (CFDictionaryGetValueIfPresent((CFDictionaryRef)_MergedGlobals_15, key, (const void **)&value)) {
    return value;
  }
  IntCFStringRef Value = CFStringGetIntValue(key);
  uint64_t result = 0xFFFFFFFFLL;
  if (IntValue != 0x80000000 && IntValue && IntValue != 0x7FFFFFFF) {
    return IntValue;
  }
  return result;
}

void TInstanceFont::CopyName(atomic_ullong *this@<X0>, const __CFString *a2@<X1>, atomic_ullong *a3@<X8>)
{
  id v17 = 0;
  TBaseFont::CopyAttributeInternal(this, @"CTFontNames", &v16);
  uint64_t v6 = (void *)atomic_exchange((atomic_ullong *volatile)&v16, 0);

  if (@"CTFontSubFamilyName" == a2
    || a2 && @"CTFontSubFamilyName" && CFEqual(a2, @"CTFontSubFamilyName")
    || @"CTFontPreferredSubFamilyName" == a2
    || a2 && @"CTFontPreferredSubFamilyName" && CFEqual(a2, @"CTFontPreferredSubFamilyName"))
  {
    if (!atomic_load_explicit(this + 76, memory_order_acquire))
    {
      id v16 = (id)0xAAAAAAAAAAAAAAAALL;
      TBaseFont::CopyName(this, @"CTFontSubFamilyName", (atomic_ullong *)&v16);
      if (atomic_load_explicit((atomic_ullong *volatile)&v16, memory_order_acquire))
      {
        uint64_t v7 = 0;
        unint64_t v8 = atomic_exchange((atomic_ullong *volatile)&v16, 0);
        atomic_compare_exchange_strong(this + 76, (unint64_t *)&v7, v8);
        if (v7) {
          double v9 = (void *)v8;
        }
        else {
          double v9 = 0;
        }
      }
    }
    *a3 = (atomic_ullong)(id)atomic_load_explicit(this + 76, memory_order_acquire);
    goto LABEL_17;
  }
  if (@"CTFontFullName" != a2 && (!a2 || !@"CTFontFullName" || !CFEqual(a2, @"CTFontFullName"))
    || (IsNamedInstance((CGFont *)atomic_load_explicit(this + 13, memory_order_acquire)) & 1) != 0)
  {
LABEL_23:
    TBaseFont::CopyName(this, a2, a3);
    goto LABEL_17;
  }
  CFDictionaryRef v10 = v6;
  CFDictionaryRef v11 = v10;
  if (v10) {
    CFStringRef Value = (void *)CFDictionaryGetValue(v10, a2);
  }
  else {
    CFStringRef Value = 0;
  }
  TCFRef<__CTFont const*>::Retain((atomic_ullong *)&v17, Value);

  if (atomic_load_explicit((atomic_ullong *volatile)&v17, memory_order_acquire))
  {
    *a3 = atomic_exchange((atomic_ullong *volatile)&v17, 0);
    goto LABEL_17;
  }
  id v16 = (id)0xAAAAAAAAAAAAAAAALL;
  TBaseFont::CopyName(this, @"CTFontFamilyName", (atomic_ullong *)&v16);
  if (!atomic_load_explicit((atomic_ullong *volatile)&v16, memory_order_acquire))
  {
LABEL_35:

    goto LABEL_23;
  }
  MutableCFDictionaryRef Copy = (id)0xAAAAAAAAAAAAAAAALL;
  MutableCFDictionaryRef Copy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, (CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&v16, memory_order_acquire));
  if (!atomic_load_explicit((atomic_ullong *volatile)&MutableCopy, memory_order_acquire))
  {

    goto LABEL_35;
  }
  id v14 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr, atomic_ullong *, __CFString *))(*this + 72))(&v14, this, @"CTFontSubFamilyName");
  if (atomic_load_explicit((atomic_ullong *volatile)&v14, memory_order_acquire))
  {
    CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&MutableCopy, memory_order_acquire), 0, @" %@", atomic_load_explicit((atomic_ullong *volatile)&v14, memory_order_acquire));
    id v13 = (id)0xAAAAAAAAAAAAAAAALL;
    TCFMutableDictionary::TCFMutableDictionary((TCFMutableDictionary *)&v13, (CFDictionaryRef)v6);
    CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v13, memory_order_acquire), a2, (const void *)atomic_load_explicit((atomic_ullong *volatile)&MutableCopy, memory_order_acquire));
    TBaseFont::SetAttributeInternal<__CFDictionary const*>(this, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v13, memory_order_acquire), @"CTFontNames");
  }
  *a3 = atomic_exchange((atomic_ullong *volatile)&MutableCopy, 0);

LABEL_17:
}

void CreateCopyOfFontWithSizeAndWeightClass(const __CTFont *a1, CGFloat a2, double a3, void *a4, int a5)
{
  uint64_t v7 = a4;
  uint64_t v72 = *MEMORY[0x1E4F143B8];
  id v64 = 0;
  if (a5)
  {
    CreateFeatureSettingsForLigatureSetting(&keys, *(void *)(a4[5] + 400), 0);
  }
  double v9 = (TFont *)v7[5];
  (*(void (**)(id *__return_ptr))(**((void **)v9 + 50) + 120))(&keys);
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&keys, memory_order_acquire);

  if (!explicit)
  {
    id v63 = (id)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(id *__return_ptr))(**((void **)v9 + 50) + 72))(&v63);
    id v15 = (void *)atomic_load_explicit((atomic_ullong *volatile)&v63, memory_order_acquire);
    id keys = @"NSFontFamilyAttribute";
    values[0] = v15;
    CFAllocatorRef v16 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFDictionaryRef v17 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&keys, (const void **)values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CTFontDescriptorRef v18 = CTFontDescriptorCreateWithAttributes(v17);
    CFArrayRef MatchingFontDescriptorsWithOptions = (const __CFArray *)CTFontDescriptorCreateMatchingFontDescriptorsWithOptions((uint64_t)v18, 0, 1024);
    if (MatchingFontDescriptorsWithOptions)
    {
      double v60 = v18;
      CFDictionaryRef v61 = v17;
      unint64_t v58 = v7;
      *(void *)&long long v20 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v70[14] = v20;
      v70[13] = v20;
      v70[12] = v20;
      v70[11] = v20;
      v70[10] = v20;
      v70[9] = v20;
      v70[8] = v20;
      v70[7] = v20;
      v70[6] = v20;
      v70[5] = v20;
      v70[4] = v20;
      v70[3] = v20;
      v70[2] = v20;
      v70[1] = v20;
      v70[0] = v20;
      int v68 = 0;
      unint64_t v69 = 0;
      id keys = 0;
      int v62 = a1;
      id v71 = v70;
      CFAllocatorRef allocator = v16;
      id Mutable = CFDictionaryCreateMutable(v16, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      CFIndex Count = CFArrayGetCount(MatchingFontDescriptorsWithOptions);
      CFArrayRef v23 = MatchingFontDescriptorsWithOptions;
      if (Count)
      {
        CFIndex v24 = Count;
        for (CFIndex i = 0; i != v24; ++i)
        {
          CFDictionaryRef ValueAtIndex = (const __CTFontDescriptor *)CFArrayGetValueAtIndex(v23, i);
          unsigned int v27 = (void *)MEMORY[0x185327A40]();
          CFNumberRef v28 = (const __CFNumber *)CTFontDescriptorCopyAttribute(ValueAtIndex, @"CTFontCSSWeightAttribute");
          values[0] = (id)-1;
          CFNumberGetValue(v28, kCFNumberDoubleType, values);
          id v29 = values[0];
          double v30 = v68;
          if ((unint64_t)v68 >= v69)
          {
            CFAllocatorRef v32 = (double *)keys;
            int64_t v33 = ((char *)v68 - (unsigned char *)keys) >> 3;
            unint64_t v34 = v33 + 1;
            if ((unint64_t)(v33 + 1) >> 61) {
              abort();
            }
            int v35 = Mutable;
            CFArrayRef v36 = v23;
            uint64_t v37 = v69 - (void)keys;
            if ((uint64_t)(v69 - (void)keys) >> 2 > v34) {
              unint64_t v34 = v37 >> 2;
            }
            if ((unint64_t)v37 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v38 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v38 = v34;
            }
            values[4] = v70;
            if (v38)
            {
              double v39 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v70, v38);
              CFAllocatorRef v32 = (double *)keys;
              double v30 = v68;
            }
            else
            {
              double v39 = 0;
            }
            double v40 = &v39[8 * v33];
            *(void *)double v40 = v29;
            if (v30 == v32)
            {
              double v42 = &v39[8 * v33];
            }
            else
            {
              double v41 = v30;
              double v42 = &v39[8 * v33];
              do
              {
                uint64_t v43 = *((void *)v41-- - 1);
                *((void *)v42 - 1) = v43;
                v42 -= 8;
              }
              while (v41 != v32);
            }
            unint64_t v31 = (double *)(v40 + 8);
            id keys = v42;
            int v68 = (double *)(v40 + 8);
            double v44 = (void *)v69;
            unint64_t v69 = (unint64_t)&v39[8 * v38];
            id values[2] = v30;
            values[3] = v44;
            values[0] = v32;
            values[1] = v32;
            std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)values);
            CFArrayRef v23 = v36;
            id Mutable = v35;
          }
          else
          {
            *int v68 = *(double *)values;
            unint64_t v31 = v30 + 1;
          }
          int v68 = v31;
          CFDictionaryAddValue(Mutable, (const void *)objc_msgSend(NSNumber, "numberWithDouble:", *(double *)&v29, v58), ValueAtIndex);
        }
      }
      LOBYTE(values[0]) = -86;
      std::__sort<std::__less<double,double> &,double *>();
      CGFloat v45 = (double *)keys;
      unsigned int v46 = IndexesBracketing<std::__wrap_iter<double *>,double>((double *)keys, v68, a3);
      double v47 = v45[(unsigned __int16)v46];
      double v48 = v45[HIWORD(v46)];
      double v49 = 0.0;
      if (v47 != v48) {
        double v49 = (a3 - v47) / (v48 - v47);
      }
      double v50 = std::__lerp[abi:nn180100]<double>(v47, v48, round(v49));
      TCFNumber::TCFNumber<double>(values, v50);
      CFStringRef Value = (const __CTFontDescriptor *)CFDictionaryGetValue(Mutable, (const void *)atomic_load_explicit((atomic_ullong *volatile)values, memory_order_acquire));

      CFDictionaryRef v17 = v61;
      a1 = v62;
      if (Value)
      {
        if (atomic_load_explicit((atomic_ullong *volatile)&v64, memory_order_acquire))
        {
          long long v52 = (void *)atomic_load_explicit((atomic_ullong *volatile)&v64, memory_order_acquire);
          values[0] = @"NSCTFontFeatureSettingsAttribute";
          int v66 = v52;
          CFDictionaryRef v53 = CFDictionaryCreate(allocator, (const void **)values, (const void **)&v66, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          CFArrayRef v54 = v23;
          CopyWithCFDictionaryRef Attributes = CTFontDescriptorCreateCopyWithAttributes(Value, v53);
          CTFontRef v56 = CTFontCreateWithFontDescriptor(CopyWithAttributes, a2, 0);
          double v57 = CopyWithAttributes;
          CFArrayRef v23 = v54;
        }
        else
        {
          CTFontRef v56 = CTFontCreateWithFontDescriptor(Value, a2, 0);
        }
        *(void *)int v62 = v56;

        values[0] = &keys;
        std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)values);

        CTFontDescriptorRef v18 = v60;
        goto LABEL_39;
      }

      values[0] = &keys;
      std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)values);
      uint64_t v7 = v58;
      CFArrayRef MatchingFontDescriptorsWithOptions = v23;
      CTFontDescriptorRef v18 = v60;
    }

    *(void *)a1 = v7;
LABEL_39:

    id v14 = v63;
    goto LABEL_40;
  }
  id keys = (id)0xAAAAAAAAAAAAAAAALL;
  TFont::CopyAttribute(v9, @"NSCTFontVariationAttribute", 7, (atomic_ullong *)values);
  TCFMutableDictionary::TCFMutableDictionary((TCFMutableDictionary *)&keys, (CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)values, memory_order_acquire));

  (*(void (**)(id *__return_ptr))(**((void **)v9 + 50) + 128))(values);
  unint64_t v11 = atomic_load_explicit((atomic_ullong *volatile)values, memory_order_acquire);

  if (v11)
  {
    TCFNumber::TCFNumber<double>(values, a2);
    CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&keys, memory_order_acquire), &unk_1ED082D88, (const void *)atomic_load_explicit((atomic_ullong *volatile)values, memory_order_acquire));
  }
  TCFNumber::TCFNumber<double>(values, a3);
  CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&keys, memory_order_acquire), &unk_1ED082DA0, (const void *)atomic_load_explicit((atomic_ullong *volatile)values, memory_order_acquire));

  CFDictionaryRef v12 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionarySetValue(v12, @"NSCTFontVariationAttribute", (const void *)atomic_load_explicit((atomic_ullong *volatile)&keys, memory_order_acquire));
  if (atomic_load_explicit((atomic_ullong *volatile)&v64, memory_order_acquire)) {
    CFDictionarySetValue(v12, @"NSCTFontFeatureSettingsAttribute", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v64, memory_order_acquire));
  }
  values[0] = (id)0xAAAAAAAAAAAAAAAALL;
  TFont::CopyDescriptor(v9, 0, (atomic_ullong *)values);
  id v13 = CTFontDescriptorCreateCopyWithAttributes((CTFontDescriptorRef)atomic_load_explicit((atomic_ullong *volatile)values, memory_order_acquire), v12);
  *(void *)a1 = CTFontCreateWithFontDescriptor(v13, a2, 0);

  id v14 = keys;
LABEL_40:
}

void SecondaryScaleRecipeForFont(uint64_t a1, uint64_t a2, __CFString *theString, uint64_t a4, uint64_t a5, char a6, double a7, double a8)
{
  uint64_t v16 = 0;
  id v56 = 0;
  while (1)
  {
    CFStringRef v17 = SecondaryScaleArrayForFamilyName(__CFString const*)::kNameAliases[v16];
    if (v17 == theString) {
      break;
    }
    if (theString
      && v17
      && CFStringHasPrefix(theString, SecondaryScaleArrayForFamilyName(__CFString const*)::kNameAliases[v16]))
    {
      goto LABEL_9;
    }
    v16 += 3;
    if (v16 == 9) {
      goto LABEL_12;
    }
  }
  CFStringRef v17 = theString;
LABEL_9:
  CTFontDescriptorRef v18 = &SecondaryScaleArrayForFamilyName(__CFString const*)::kNameAliases[v16];
  if (*((unsigned char *)v18 + 16))
  {
    theCFStringRef String = v18[1];
  }
  else
  {

    unint64_t explicit = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&v56, memory_order_acquire);
    v59.CFIndex length = CFStringGetLength(v17);
    v59.CFIndex location = 0;
    CFStringReplace(explicit, v59, v18[1]);
    theCFStringRef String = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&v56, memory_order_acquire);
  }
LABEL_12:
  SecondaryScaleDatCGFloat a = (const void *)[&unk_1ED07E668 objectForKeyedSubscript:theString];

  if (!SecondaryScaleData)
  {
    SecondaryScaleDatCGFloat a = (const void *)TFont::GetSecondaryScaleData(*(atomic_ullong **)(a2 + 40));
    CFTypeID TypeID = CFArrayGetTypeID();
    if (!SecondaryScaleData
      || (CFTypeID v50 = TypeID, CFGetTypeID(SecondaryScaleData) != TypeID)
      || !CFArrayGetCount((CFArrayRef)SecondaryScaleData)
      || (CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)SecondaryScaleData, 0), CFGetTypeID(ValueAtIndex) != v50))
    {
      *(unsigned char *)a1 = 0;
      *(unsigned char *)(a1 + 32) = 0;
      return;
    }
  }
  uint64_t v21 = [&unk_1ED07E640 objectForKeyedSubscript:a4];
  if (v21) {
    CFDictionaryRef v22 = (__CFString *)v21;
  }
  else {
    CFDictionaryRef v22 = @"sfpro";
  }
  id v56 = (id)0xAAAAAAAAAAAAAAAALL;
  CFArrayRef theArray = (CFArrayRef)0xAAAAAAAAAAAAAAAALL;
  double v58 = NAN;
  tuplesBracketingValue((const __CFArray *)&v56, (CFArrayRef)SecondaryScaleData, a7, 0);
  CFArrayRef v23 = (const __CFArray *)v56;
  CFDictionaryRef v24 = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)v56, 1);
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v24, v22);
  if (!Value)
  {
    CFDictionaryRef v52 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)&unk_1ED07E618, v22);
    if (v52)
    {
      CFDictionaryRef v53 = v52;
      while (1)
      {
        CFArrayRef v54 = (__CFString *)CFDictionaryGetValue(v53, v22);
        if (!v54) {
          break;
        }
        CFDictionaryRef v22 = v54;
        CFDictionaryRef v55 = (const __CFDictionary *)CFArrayGetValueAtIndex(v23, 1);
        CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v55, v22);
        if (Value) {
          goto LABEL_17;
        }
      }
    }
LABEL_30:
    char v48 = 0;
    *(unsigned char *)a1 = 0;
    goto LABEL_32;
  }
LABEL_17:
  double v26 = TextScaleRecipeForSize(Value, a5, a6, a8);
  double v30 = v26;
  double v31 = v27;
  double v32 = v28;
  double v33 = v29;
  if (v23 == theArray)
  {
    *(double *)a1 = v26;
    *(double *)(a1 + 8) = v27;
    char v48 = 1;
    *(double *)(a1 + 16) = v28;
    *(double *)(a1 + 24) = v29;
    goto LABEL_32;
  }
  CFDictionaryRef v34 = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, 1);
  CFDictionaryRef v35 = (const __CFDictionary *)CFDictionaryGetValue(v34, v22);
  if (!v35) {
    goto LABEL_30;
  }
  double v36 = TextScaleRecipeForSize(v35, a5, a6, a8);
  double v38 = v37;
  double v40 = v39;
  double v42 = v41;
  double v43 = v58;
  double v44 = std::__lerp[abi:nn180100]<double>(v30, v36, v58);
  double v45 = std::__lerp[abi:nn180100]<double>(v31, v38, v43);
  double v46 = std::__lerp[abi:nn180100]<double>(v32, v40, v43);
  double v47 = std::__lerp[abi:nn180100]<double>(v33, v42, v43);
  *(double *)a1 = v44;
  *(double *)(a1 + 8) = v45;
  *(double *)(a1 + 16) = v46;
  *(double *)(a1 + 24) = v47;
  char v48 = 1;
LABEL_32:
  *(unsigned char *)(a1 + 32) = v48;
}

double GetRoundedWeight(atomic_ullong **a1)
{
  id v7 = (id)0xAAAAAAAAAAAAAAAALL;
  TBaseFont::CopyWeightAxisValue(a1[50], (unint64_t *)&v7);
  if (atomic_load_explicit((atomic_ullong *volatile)&v7, memory_order_acquire))
  {
    CFNumberRef v2 = (const __CFNumber *)(id)atomic_load_explicit((atomic_ullong *volatile)&v7, memory_order_acquire);
    double valuePtr = NAN;
    CFNumberGetValue(v2, kCFNumberDoubleType, &valuePtr);
    double v3 = round(valuePtr);

    id v4 = v7;
  }
  else
  {

    TFont::CopyAttribute((TFont *)a1, @"CTFontCSSWeightAttribute", 46, (atomic_ullong *)&valuePtr);
    CFNumberRef v5 = (const __CFNumber *)atomic_exchange((atomic_ullong *volatile)&valuePtr, 0);

    double valuePtr = NAN;
    CFNumberGetValue(v5, kCFNumberDoubleType, &valuePtr);
    double v3 = valuePtr;
    id v4 = v5;
  }

  return v3;
}

atomic_ullong *OS2::OS2(atomic_ullong *a1, atomic_ullong *a2)
{
  *a1 = atomic_exchange(a2, 0);
  unint64_t explicit = (const UInt8 *)atomic_load_explicit(a1, memory_order_acquire);
  if (explicit) {
    unint64_t explicit = CFDataGetBytePtr((CFDataRef)explicit);
  }
  a1[1] = (atomic_ullong)explicit;
  CFDataRef Length = (const __CFData *)atomic_load_explicit(a1, memory_order_acquire);
  if (Length) {
    CFDataRef Length = (const __CFData *)CFDataGetLength(Length);
  }
  a1[2] = (atomic_ullong)Length;
  return a1;
}

uint64_t OTL::GCommon::IterateFeatureTables(unint64_t a1, _WORD *a2, unint64_t a3, uint64_t a4)
{
  if (a2)
  {
    unsigned int v5 = *(unsigned __int16 *)(a1 + 8);
    if (*(_WORD *)(a1 + 8))
    {
      id v7 = (unsigned __int16 *)(a1 + __rev16(v5));
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) <= a3
        && ((uint64_t v9 = bswap32(*v7) >> 16, v10 = (unint64_t)&v8[v9], (unint64_t)(v7 + 2) <= a3)
          ? (unint64_t v11 = (a3 - (unint64_t)v8) >> 1)
          : (unint64_t v11 = 0),
            v10 <= a3 ? (BOOL v12 = v10 >= (unint64_t)v8) : (BOOL v12 = 0),
            !v12 ? (BOOL v13 = v11 == v9) : (BOOL v13 = 1),
            v13))
      {
        id v15 = a2 + 1;
        if (*a2)
        {
          CFStringRef v17 = &v15[3 * __rev16((unsigned __int16)*a2)];
          while (1)
          {
            uint64_t v18 = (uint64_t)a2 + (bswap32((unsigned __int16)v15[2]) >> 16);
            id v19 = (unsigned __int16 *)(v18 + 4);
            if (v18 + 2 < a1 || (unint64_t)v19 > a3) {
              break;
            }
            unint64_t v11 = __rev16(*(unsigned __int16 *)(v18 + 2));
            uint64_t v21 = &v19[v11];
            unint64_t v22 = v18 + 6 <= a3 ? (a3 - (unint64_t)v19) >> 1 : 0;
            BOOL v23 = (unint64_t)v21 <= a3 && v21 >= v19;
            if (!v23 && v22 != v11) {
              break;
            }
            if (*(_WORD *)(v18 + 2))
            {
              uint64_t v25 = 2 * v11;
              while (v9 > bswap32(*v19) >> 16)
              {
                ++v19;
                v25 -= 2;
                if (!v25)
                {
                  if ((std::function<BOOL ()(unsigned int,OTL::FeatureTable const*,BOOL &)>::operator()(a4, bswap32(*(_DWORD *)v15), v18) & 1) == 0)goto LABEL_40; {
                  goto LABEL_37;
                  }
                }
              }
              break;
            }
LABEL_37:
            v15 += 3;
            if (v15 == v17) {
              goto LABEL_38;
            }
          }
LABEL_40:
          char v26 = 0;
          LOBYTE(v11) = 0;
        }
        else
        {
LABEL_38:
          char v26 = 1;
        }
        LOBYTE(v5) = v26 | v11;
      }
      else
      {
        LOBYTE(v5) = 0;
      }
    }
  }
  else
  {
    LOBYTE(v5) = 0;
  }
  return v5 & 1;
}

uint64_t std::function<BOOL ()(unsigned int,OTL::FeatureTable const*,BOOL &)>::operator()(uint64_t a1, int a2, uint64_t a3)
{
  int v10 = a2;
  uint64_t v9 = a3;
  uint64_t v3 = *(void *)(a1 + 24);
  if (v3) {
    return (*(uint64_t (**)(uint64_t, int *, uint64_t *))(*(void *)v3 + 48))(v3, &v10, &v9);
  }
  uint64_t v5 = std::__throw_bad_function_call[abi:nn180100]();
  return std::__function::__func<TOpenTypePositioningEngine::PositionRuns(SyncState &,KerningStatus &)::$_1,std::allocator<TOpenTypePositioningEngine::PositionRuns(SyncState &,KerningStatus &)::$_1>,BOOL ()(unsigned int,OTL::FeatureTable const*,BOOL &)>::operator()(v5, v6, v7, v8);
}

uint64_t std::__function::__func<TOpenTypePositioningEngine::PositionRuns(SyncState &,KerningStatus &)::$_1,std::allocator<TOpenTypePositioningEngine::PositionRuns(SyncState &,KerningStatus &)::$_1>,BOOL ()(unsigned int,OTL::FeatureTable const*,BOOL &)>::operator()(uint64_t a1, _DWORD *a2, uint64_t a3, unsigned char *a4)
{
  if (*a2 == 1801810542)
  {
    **(_WORD **)(a1 + 8) = bswap32(*(unsigned __int16 *)(*(void *)a3 + 4)) >> 16;
    *a4 = 1;
  }
  return 1;
}

uint64_t TAttributes::HandleBackgroundNSColorAttribute(uint64_t result, uint64_t a2)
{
  if (result)
  {
    uint64_t result = dyld_program_sdk_at_least();
    if (result) {
      *(unsigned char *)(*(void *)a2 + 137) |= 1u;
    }
  }
  return result;
}

void std::__destroy_at[abi:nn180100]<TTypesetter,0>(TLine *this)
{
  CFNumberRef v2 = (std::__shared_weak_count *)*((void *)this + 31);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }

  TLine::~TLine(this);
}

void TCFBase<TTypesetter>::ClassDestruct(uint64_t a1)
{
  CFNumberRef v2 = *(void (**)(uint64_t))(a1 + 16);
  if (v2) {
    v2(a1);
  }
  uint64_t v3 = *(TLine **)(a1 + 40);

  std::__destroy_at[abi:nn180100]<TTypesetter,0>(v3);
}

const __CFDictionary *TSplicedFont::IsTextStyleFont(atomic_ullong *this)
{
  return TSplicedFontDict::IsTextStyle(this + 75);
}

void TCFBase<TFrame>::ClassDestruct(uint64_t a1)
{
  CFNumberRef v2 = *(void (**)(uint64_t))(a1 + 16);
  if (v2) {
    v2(a1);
  }
  uint64_t v3 = *(void *)(a1 + 40);

  std::__destroy_at[abi:nn180100]<TFrame,0>(v3);
}

uint64_t CTFontIsLastResort(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(**(void **)(*(void *)(result + 40) + 400) + 688))();
  }
  return result;
}

uint64_t CTLineSuggestClusterBreakWithOffset(uint64_t result, const TLine *a2, double a3, double a4, uint64_t a5, uint64_t *a6)
{
  if (result) {
    return TTypesetter::SuggestClusterBreak(*(TTypesetter **)(result + 40), a2, 0, a3, a4, a6);
  }
  return result;
}

TDescriptor *CTFontDescriptorIsSystemUIFont(TDescriptor *result)
{
  if (result)
  {
    int v1 = *(_DWORD *)(*((void *)result + 5) + 16);
    return (TDescriptor *)((TDescriptor::GetSystemUIFontOptions(result) & v1) != 0);
  }
  return result;
}

void TFont::~TFont(TFont *this)
{
  CFNumberRef v2 = (TASCIIDataCache *)*((void *)this + 48);
  if (v2)
  {
    TASCIIDataCache::~TASCIIDataCache(v2);
    MEMORY[0x1853275C0]();
  }
  if ((unint64_t)(*((void *)this + 42) + 1) >= 2) {
    MEMORY[0x1853275A0]();
  }
  for (uint64_t i = 344; i != 360; i += 8)
  {
    uint64_t v4 = *(void *)((char *)this + i);
    if ((unint64_t)(v4 + 1) >= 2)
    {
      uint64_t v5 = std::__hash_table<EncoderAttempt,std::hash<EncoderAttempt>,std::equal_to<EncoderAttempt>,std::allocator<EncoderAttempt>>::~__hash_table(v4);
      MEMORY[0x1853275C0](v5, 0x10A0C408EF24B1CLL);
    }
  }
  if (MEMORY[0x1E4F83A40]) {
    OTSVGTableRelease();
  }
  uint64_t v6 = (atomic_uint *)*((void *)this + 50);
  if (v6 && atomic_fetch_add_explicit(v6 + 2, 0xFFFFFFFF, memory_order_release) == 1)
  {
    __dmb(9u);
    (*(void (**)(atomic_uint *))(*(void *)v6 + 8))(v6);
  }

  uint64_t v7 = (void *)*((void *)this + 59);
  if (v7)
  {
    do
    {
      unint64_t v8 = (void *)*v7;
      operator delete(v7);
      uint64_t v7 = v8;
    }
    while (v8);
  }
  uint64_t v9 = (void *)*((void *)this + 57);
  *((void *)this + 57) = 0;
  if (v9) {
    operator delete(v9);
  }
  int v10 = (void *)*((void *)this + 53);
  if (v10)
  {
    *((void *)this + 54) = v10;
    operator delete(v10);
  }

  std::__hash_table<std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>>>::~__hash_table((uint64_t)this + 248);
  std::__hash_table<std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>>>::~__hash_table((uint64_t)this + 208);
  std::__tree<std::__value_type<long,TAATDeltaYListEntry>,std::__map_value_compare<long,std::__value_type<long,TAATDeltaYListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TAATDeltaYListEntry>>>::destroy((uint64_t)this + 176, *((void **)this + 23));

  uint64_t v11 = *((void *)this + 5);
  *((void *)this + 5) = 0;
  if (v11) {
    MEMORY[0x1853275C0](v11, 0x1000C40EED21634);
  }
}

void TASCIIDataCache::~TASCIIDataCache(TASCIIDataCache *this)
{
  uint64_t v2 = *((void *)this + 241);
  if (v2) {
    MEMORY[0x1853275C0](v2, 0x1000C400F47AF14);
  }
  uint64_t v3 = *((void *)this + 242);
  if (v3) {
    MEMORY[0x1853275A0](v3, 0x1000C80F7F8B94BLL);
  }
}

void addOpticalSizeComponents(unsigned int *a1, uint64_t a2, int a3, const void *a4, uint64_t a5, const __CFNumber *a6, atomic_ullong *a7)
{
  LODWORD(v11) = a3;
  id Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  unsigned int v14 = a1[4];
  if (a5 == 1 && v14 <= 0x10 && ((0x1FEFFu >> v14) & 1) != 0) {
    unsigned int v14 = dword_184BA17A4[v14];
  }
  unsigned int v15 = v14 % 9;
  if (v14 % 9 <= 2)
  {
    DetermineLanguageSpecificParameters();
    if (v15 < dword_1EB2CDB30) {
      unsigned int v14 = v14 - v15 + dword_1EB2CDB30;
    }
  }
  if (v14 == 8 || v11 == 0) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = v11;
  }
  CFStringRef v17 = (const __CFString **)(a2 + 40 * v14);
  if (a6) {
    uint64_t v18 = SFFontNameForWidth(v14, a6, 0);
  }
  else {
    uint64_t v18 = (__CFString *)*v17;
  }
  AddVariationInfoWithGrade(a7, v18, v11);
  for (uint64_t i = 6; i != 10; i += 2)
    insertOpticalSizeComponent(v17, v18, *a1, a1[3], v11, (atomic_ullong *)&Mutable, a4, 0, *(double *)&a1[i] * 0.5);
  CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit(a7, memory_order_acquire), @"Components", (const void *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire));
  id v20 = Mutable;
}

void AddVariationInfoWithGrade(atomic_ullong *a1, const __CFString *a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v4 = (__CFString *)CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@G%u", a2, a3);
    AddVariationInfo(a1, v4);
  }
  else
  {
    AddVariationInfo(a1, a2);
  }
}

void AddVariationInfo(atomic_ullong *a1, const __CFString *a2)
{
  CopyAttributeForSystemFont(a2, @"NSCTFontVariationAxesAttribute", (const __CFString **)&v7);
  unint64_t v4 = atomic_exchange((atomic_ullong *volatile)&v7, 0);

  if (v4) {
    CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit(a1, memory_order_acquire), @"variationAxes", (const void *)v4);
  }
  id v7 = (id)0xAAAAAAAAAAAAAAAALL;
  CopyVariationAttributeForSystemFont(a2, (CFDictionaryRef *)&v7);
  if (atomic_load_explicit((atomic_ullong *volatile)&v7, memory_order_acquire)
    && CFDictionaryGetCount((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v7, memory_order_acquire)) | v4)
  {
    CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit(a1, memory_order_acquire), @"variations", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v7, memory_order_acquire));
  }
  uint64_t v5 = (void *)GSFontCopyFontFilePath();
  if (v5)
  {
    CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit(a1, memory_order_acquire), @"path", v5);
    uint64_t v6 = (void *)CGFontURLCreate();
    if (v6) {
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit(a1, memory_order_acquire), @"fontURL", v6);
    }
  }
}

uint64_t DetermineLanguageSpecificParameters(void)
{
  int v0 = dword_1EB2CDB34;
  uint64_t result = GetLocaleChangedCount();
  if (v0 != result)
  {
    id v10 = (id)0xAAAAAAAAAAAAAAAALL;
    CopyPreferredLanguageCode(&v10);
    if (atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire))
    {
      uint64_t v2 = (__CFString *)(id)atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire);
      uint64_t v3 = v2;
      if (v2 == @"zh" || v2 && CFEqual(v2, @"zh"))
      {
        byte_1EB2CDB29 = 1;
      }
      else
      {
        unint64_t v4 = (__CFString *)(id)atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire);
        uint64_t v5 = v4;
        if (v4 == @"ja" || v4 && CFEqual(v4, @"ja"))
        {
          byte_1EB2CDB29 = 1;
        }
        else
        {
          uint64_t v6 = (__CFString *)(id)atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire);
          id v7 = v6;
          if (v6 == @"ko")
          {
            BOOL v8 = 1;
          }
          else if (v6)
          {
            BOOL v8 = CFEqual(v6, @"ko") != 0;
          }
          else
          {
            BOOL v8 = 0;
          }
          byte_1EB2CDB29 = v8;
        }
      }

      uint64_t v9 = objc_msgSend(&unk_1ED07E578, "objectForKeyedSubscript:", atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire));
      if (v9) {
        LODWORD(v9) = [v9 unsignedIntValue];
      }
      dword_1EB2CDB30 = (int)v9;
    }

    uint64_t result = GetLocaleChangedCount();
    dword_1EB2CDB34 = result;
  }
  return result;
}

void insertOpticalSizeComponent(const __CFString **a1, const __CFString *a2, uint64_t a3, int a4, uint64_t a5, atomic_ullong *a6, const void *a7, const void *a8, double a9)
{
  id Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (a2) {
    CFStringRef v18 = a2;
  }
  else {
    CFStringRef v18 = *a1;
  }
  setOpticalSizeComponent(v18, (uint64_t)a1, a3, a4, a5, a7, (atomic_ullong *)&Mutable, 0, a9, 0.0, 0.0, 0.0, a8);
  CFArrayInsertValueAtIndex((CFMutableArrayRef)atomic_load_explicit(a6, memory_order_acquire), 0, (const void *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire));
  id v19 = Mutable;
}

void CopyPreferredLanguageCode(void *a1@<X8>)
{
  id v6 = (id)0xAAAAAAAAAAAAAAAALL;
  CopyPreferredLanguage((atomic_ullong *)&v6);
  CFDictionaryRef ComponentsFromLocaleIdentifier = CFLocaleCreateComponentsFromLocaleIdentifier((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFLocaleIdentifier)atomic_load_explicit((atomic_ullong *volatile)&v6, memory_order_acquire));
  CFDictionaryRef v3 = ComponentsFromLocaleIdentifier;
  if (ComponentsFromLocaleIdentifier
    && (CFDictionaryRef Value = (void *)CFDictionaryGetValue(ComponentsFromLocaleIdentifier, (const void *)*MEMORY[0x1E4F1D218])) != 0)
  {
    id v5 = Value;
  }
  else
  {
    id v5 = (id)atomic_exchange((atomic_ullong *volatile)&v6, 0);
  }
  *a1 = v5;
}

double CTRunGetTypographicBounds(CTRunRef run, CFRange range, CGFloat *ascent, CGFloat *descent, CGFloat *leading)
{
  double v5 = 0.0;
  if (!run) {
    return v5;
  }
  CFIndex length = range.length;
  CFIndex location = range.location;
  uint64_t v10 = *((void *)run + 5);
  if ((*(unsigned char *)(v10 + 225) & 8) != 0)
  {
    uint64_t v11 = *(void *)(v10 + 264);
    uint64_t v12 = *(void *)(*(void *)(v10 + 216) + 16);
    uint64_t v14 = *(void *)(v10 + 200);
    uint64_t v13 = *(void *)(v10 + 208);
    if (v13 < 1 || range.location < 1)
    {
      CFIndex location = 0;
    }
    else
    {
      CFIndex v16 = range.location;
      CFIndex location = 0;
      do
      {
        uint64_t v18 = v11 == location || *(__int16 *)(v12 + 2 * v14 + 2 * location) != -1;
        if (++location >= v13) {
          break;
        }
        v16 -= v18;
      }
      while (v16);
    }
    if (range.length)
    {
      CFIndex v19 = 0;
      if (v13 > location && range.length >= 1)
      {
        CFIndex v19 = 0;
        CFIndex v20 = v11 - location;
        CFIndex v21 = v12 + 2 * location + 2 * v14;
        do
        {
          uint64_t v23 = v20 == v19 || *(__int16 *)(v21 + 2 * v19) != -1;
          uint64_t v24 = location + 1 + v19++;
          if (v24 >= v13) {
            break;
          }
          length -= v23;
        }
        while (length);
      }
    }
    else
    {
      CFIndex v19 = v13 - location;
    }
    CFIndex length = v19;
  }
  if (ascent) {
    *ascent = (*(double (**)(void))(*(void *)v10 + 56))(*((void *)run + 5));
  }
  if (descent) {
    *descent = (*(double (**)(uint64_t))(*(void *)v10 + 64))(v10);
  }
  if (leading) {
    *leading = (*(double (**)(uint64_t))(*(void *)v10 + 72))(v10);
  }
  if (location < 0) {
    return v5;
  }
  CFIndex v25 = *(void *)(v10 + 208);
  if (location + length > v25) {
    return v5;
  }
  if (length) {
    v26.CFIndex length = length;
  }
  else {
    v26.CFIndex length = v25 - location;
  }
  if (!location && v26.length == v25)
  {
    double v27 = *(double **)(v10 + 312);
    if (!v27) {
      double v27 = (double *)MEMORY[0x1E4F1DB30];
    }
    return *(double *)(v10 + 192) + *v27;
  }
  v26.CFIndex location = location;

  return TStorageRange::GetWidth((TStorageRange *)(v10 + 192), v26);
}

void GetDefaultFeatureList<false>(void)::{lambda(void *)#1}::__invoke()
{
  for (uint64_t i = 0; i != 1980; i += 12)
  {
    *(void *)int v1 = *(uint64_t *)((char *)&kMasterFeatureMap + i);
    *(_DWORD *)&v1[8] = *(_DWORD *)((char *)&kMasterFeatureMap + i + 8);
    if ((*(void *)&v1[4] & 0x1600000000) == 0x200000000) {
  }
    }
}

void std::vector<anonymous namespace'::FeatureMapEntry,TInlineBufferAllocator<anonymous namespace'::FeatureMapEntry,10ul>>::push_back[abi:nn180100](char **a1, uint64_t *a2)
{
  unint64_t v5 = (unint64_t)a1[1];
  unint64_t v4 = (unint64_t)a1[2];
  if (v5 >= v4)
  {
    BOOL v8 = (char *)(a1 + 3);
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - (void)*a1) >> 2);
    unint64_t v10 = v9 + 1;
    if (v9 + 1 > 0x1555555555555555) {
      abort();
    }
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v4 - (void)*a1) >> 2);
    if (2 * v11 > v10) {
      unint64_t v10 = 2 * v11;
    }
    if (v11 >= 0xAAAAAAAAAAAAAAALL) {
      unint64_t v12 = 0x1555555555555555;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      uint64_t v13 = a1[18];
      unint64_t v14 = (unint64_t)&v13[12 * v12];
      if (v14 <= (unint64_t)(a1 + 18))
      {
        a1[18] = (char *)v14;
      }
      else
      {
        if (v12 > 0x1555555555555555) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        uint64_t v13 = (char *)operator new(12 * v12);
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    unsigned int v15 = &v13[12 * v9];
    CFIndex v16 = &v13[12 * v12];
    uint64_t v17 = *a2;
    *((_DWORD *)v15 + 2) = *((_DWORD *)a2 + 2);
    *(void *)unsigned int v15 = v17;
    id v7 = v15 + 12;
    CFIndex v19 = *a1;
    uint64_t v18 = a1[1];
    if (v18 != *a1)
    {
      do
      {
        uint64_t v20 = *(void *)(v18 - 12);
        v18 -= 12;
        int v21 = *((_DWORD *)v18 + 2);
        *(void *)(v15 - 12) = v20;
        v15 -= 12;
        *((_DWORD *)v15 + 2) = v21;
      }
      while (v18 != v19);
      uint64_t v18 = *a1;
    }
    *a1 = v15;
    a1[1] = v7;
    unint64_t v22 = a1[2];
    a1[2] = v16;
    if (v18)
    {
      uint64_t v23 = a1 + 18;
      if (v8 <= v18 && v23 > (char **)v18)
      {
        if (v22 == *v23) {
          const void *v23 = v18;
        }
      }
      else
      {
        operator delete(v18);
      }
    }
  }
  else
  {
    uint64_t v6 = *a2;
    *(_DWORD *)(v5 + 8) = *((_DWORD *)a2 + 2);
    *(void *)unint64_t v5 = v6;
    id v7 = (char *)(v5 + 12);
  }
  a1[1] = v7;
}

void std::__destroy_at[abi:nn180100]<TFrame,0>(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 112);
  if (v2)
  {
    *(void *)(a1 + 120) = v2;
    operator delete(v2);
  }

  CFDictionaryRef v3 = *(void **)(a1 + 80);
}

uint64_t TRunGlue::ClearSafeToBreakAfter(uint64_t this, CFRange a2)
{
  if (a2.length >= 2)
  {
    uint64_t v2 = this;
    int v3 = 0;
    int v4 = *(_DWORD *)(this + 24);
    if (v4 <= 0) {
      CFIndex location = a2.location;
    }
    else {
      CFIndex location = a2.location + a2.length - 1;
    }
    if (v4 <= 0) {
      CFIndex v6 = a2.location + a2.length;
    }
    else {
      CFIndex v6 = a2.location - 1;
    }
    do
    {
      this = TRunGlue::FocusOnIndex((TRunGlue *)v2, location);
      CFIndex v7 = location - *(void *)(v2 + 160);
      int v8 = *(_DWORD *)(*(void *)(v2 + 520) + 4 * v7);
      if ((v8 & 0x20) == 0)
      {
        if (v3) {
          this = [*(id *)(*(void *)(v2 + 152) + 216) setProps:v8 | 8u atIndex:*(void *)(*(void *)(v2 + 152) + 200) + v7];
        }
        int v3 = 1;
      }
      location -= *(int *)(v2 + 24);
    }
    while (location != v6);
  }
  return this;
}

void TAATKerxEngine::TAATKerxEngine(TAATKerxEngine *this, TRunGlue *a2, CFDataRef theData)
{
  *(void *)this = a2;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = (char *)this + 56;
  *((unsigned char *)this + 72) = 0;
  *((void *)this + 10) = theData;
  if (theData)
  {
    BytePtr = CFDataGetBytePtr(theData);
    CFIndex v6 = *(TRunGlue **)this;
  }
  else
  {
    BytePtr = 0;
    CFIndex v6 = a2;
  }
  char v7 = *((unsigned char *)v6 + 634);
  *((void *)this + 14) = 0;
  int v8 = (int64x2_t *)((char *)this + 112);
  *((void *)this + 11) = BytePtr;
  *((unsigned char *)this + 104) = v7;
  *((void *)this + 15) = 0;
  *((void *)this + 16) = 0;
  *((void *)this + 49) = 0;
  *((void *)this + 50) = 0;
  *((void *)this + 47) = (char *)this + 136;
  *((void *)this + 48) = 0;
  if (!BytePtr) {
    return;
  }
  unint64_t v9 = (unint64_t)&BytePtr[CFDataGetLength(*((CFDataRef *)this + 10))];
  *((void *)this + 12) = v9;
  unint64_t v10 = (unsigned int *)*((void *)this + 11);
  unint64_t v11 = v10 + 2;
  if ((unint64_t)(v10 + 2) > v9 || (unsigned int v12 = bswap32(*v10) >> 16, v12 - 2 > 2))
  {
LABEL_84:
    id v64 = TFont::DebugDescription(*(TFont **)(*(void *)this + 616));
    CFLog();

    uint64_t v63 = *(void *)(*(void *)(*(void *)this + 616) + 400);
    (*(void (**)(uint64_t))(*(void *)v63 + 488))(v63);
    *((void *)this + 11) = 0;
    return;
  }
  if (v12 < 3) {
    return;
  }
  unsigned int v13 = v10[1];
  if (!v13) {
    return;
  }
  uint64_t v14 = bswap32(v13);
  if (v14 <= 1) {
    int v15 = 1;
  }
  else {
    int v15 = v14;
  }
  do
  {
    if ((unint64_t)(v11 + 1) > v9) {
      goto LABEL_84;
    }
    unint64_t v11 = (unsigned int *)((char *)v11 + bswap32(*v11));
    if ((unint64_t)v11 > v9) {
      goto LABEL_84;
    }
    --v15;
  }
  while (v15);
  CFIndex v16 = &v11[v14];
  if (v10 > v11 || v16 < v11 || (unint64_t)v16 > v9)
  {
    BOOL v19 = v10 > v11 || (unint64_t)(v11 + 1) > v9;
    if (v19 || (v9 - (unint64_t)v11) >> 2 != v14) {
      return;
    }
  }
  char v21 = 0;
  unint64_t v22 = *((void *)a2 + 78);
  if (v22 <= 0x10000) {
    unint64_t v23 = (v22 + 7) >> 3;
  }
  else {
    unint64_t v23 = 0x2000;
  }
  uint64_t v24 = &v11[v14];
  CFIndex v25 = v11;
  unint64_t v65 = v23;
  while (1)
  {
    unsigned int v26 = bswap32(*v25);
    if (v26 + 1 <= 1)
    {
      if (v13 == 0x1000000) {
        goto LABEL_87;
      }
      double v28 = (void *)*((void *)this + 15);
      unint64_t v27 = *((void *)this + 16);
      if ((unint64_t)v28 >= v27)
      {
        uint64_t v44 = ((uint64_t)v28 - v8->i64[0]) >> 3;
        if ((unint64_t)(v44 + 1) >> 61) {
LABEL_91:
        }
          abort();
        uint64_t v45 = v27 - v8->i64[0];
        uint64_t v46 = v45 >> 2;
        if (v45 >> 2 <= (unint64_t)(v44 + 1)) {
          uint64_t v46 = v44 + 1;
        }
        if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v47 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v47 = v46;
        }
        unint64_t v69 = (char *)this + 136;
        if (v47) {
          char v48 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)this + 136, v47);
        }
        else {
          char v48 = 0;
        }
        id v56 = &v48[8 * v44];
        double v57 = &v48[8 * v47];
        int v68 = v57;
        *(void *)id v56 = 0;
        double v29 = v56 + 8;
        v67.i64[1] = (uint64_t)(v56 + 8);
        uint64_t v59 = *((void *)this + 14);
        unint64_t v58 = *((void *)this + 15);
        if (v58 == v59)
        {
          int64x2_t v61 = vdupq_n_s64(v58);
        }
        else
        {
          do
          {
            uint64_t v60 = *(void *)(v58 - 8);
            v58 -= 8;
            *((void *)v56 - 1) = v60;
            v56 -= 8;
          }
          while (v58 != v59);
          int64x2_t v61 = *v8;
          double v29 = (void *)v67.i64[1];
          double v57 = v68;
        }
        *((void *)this + 14) = v56;
        *((void *)this + 15) = v29;
        int64x2_t v67 = v61;
        int v62 = (char *)*((void *)this + 16);
        *((void *)this + 16) = v57;
        int v68 = v62;
        uint64_t v66 = v61.i64[0];
        std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v66);
        goto LABEL_80;
      }
      *double v28 = 0;
      double v29 = v28 + 1;
      goto LABEL_81;
    }
    double v30 = (char *)v11 + v26;
    unint64_t v31 = *((void *)this + 12);
    BOOL v32 = &v30[v23] < v30 || (unint64_t)&v30[v23] > v31;
    BOOL v33 = !v32 && *((void *)this + 11) <= (unint64_t)v30;
    BOOL v34 = (unint64_t)(v30 + 1) <= v31;
    unint64_t v35 = v31 - (void)v30;
    unint64_t v36 = *((void *)this + 11) <= (unint64_t)v30 && v34 ? v35 : 0;
    if (!v33 && v36 != v23) {
      break;
    }
    double v38 = (char **)*((void *)this + 15);
    unint64_t v37 = *((void *)this + 16);
    if ((unint64_t)v38 >= v37)
    {
      uint64_t v39 = ((uint64_t)v38 - v8->i64[0]) >> 3;
      if ((unint64_t)(v39 + 1) >> 61) {
        goto LABEL_91;
      }
      uint64_t v40 = v37 - v8->i64[0];
      uint64_t v41 = v40 >> 2;
      if (v40 >> 2 <= (unint64_t)(v39 + 1)) {
        uint64_t v41 = v39 + 1;
      }
      if ((unint64_t)v40 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v42 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v42 = v41;
      }
      unint64_t v69 = (char *)this + 136;
      if (v42) {
        double v43 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)this + 136, v42);
      }
      else {
        double v43 = 0;
      }
      double v49 = &v43[8 * v39];
      CFTypeID v50 = &v43[8 * v42];
      int v68 = v50;
      *(void *)double v49 = v30;
      double v29 = v49 + 8;
      v67.i64[1] = (uint64_t)(v49 + 8);
      uint64_t v52 = *((void *)this + 14);
      unint64_t v51 = *((void *)this + 15);
      if (v51 == v52)
      {
        int64x2_t v54 = vdupq_n_s64(v51);
      }
      else
      {
        do
        {
          uint64_t v53 = *(void *)(v51 - 8);
          v51 -= 8;
          *((void *)v49 - 1) = v53;
          v49 -= 8;
        }
        while (v51 != v52);
        int64x2_t v54 = *v8;
        double v29 = (void *)v67.i64[1];
        CFTypeID v50 = v68;
      }
      *((void *)this + 14) = v49;
      *((void *)this + 15) = v29;
      int64x2_t v67 = v54;
      CFDictionaryRef v55 = (char *)*((void *)this + 16);
      *((void *)this + 16) = v50;
      int v68 = v55;
      uint64_t v66 = v54.i64[0];
      std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v66);
      char v21 = 1;
LABEL_80:
      unint64_t v23 = v65;
      goto LABEL_81;
    }
    *double v38 = v30;
    double v29 = v38 + 1;
    char v21 = 1;
LABEL_81:
    *((void *)this + 15) = v29;
    if (++v25 == v24)
    {
      if (v21) {
        return;
      }
      goto LABEL_89;
    }
  }
  *((void *)this + 15) = *((void *)this + 14);
LABEL_87:
  if ((v21 & 1) == 0)
  {
    double v29 = (void *)*((void *)this + 15);
LABEL_89:
    if ((void *)v8->i64[0] != v29) {
      *((void *)this + 15) = v8->i64[0];
    }
  }
}

CGFontRef CTFontCopyGraphicsFont(CTFontRef font, CTFontDescriptorRef *attributes)
{
  if (!font) {
    return 0;
  }
  if (attributes) {
    *attributes = 0;
  }
  (*(void (**)(id *__return_ptr))(**(void **)(*((void *)font + 5) + 400) + 496))(&v4);
  uint64_t v2 = (CGFont *)atomic_exchange((atomic_ullong *volatile)&v4, 0);

  return v2;
}

id TInstanceFont::CopyGraphicsFont@<X0>(atomic_ullong *this@<X0>, void *a2@<X8>)
{
  id result = (id)atomic_load_explicit(this + 79, memory_order_acquire);
  *a2 = result;
  return result;
}

uint64_t TSplicedFont::CopyGraphicsFont(TSplicedFont *this)
{
  uint64_t v1 = *(void *)(*((void *)this + 76) + 40);
  if ((*(_DWORD *)(v1 + 16) & 0x80000000) == 0) {
    TDescriptor::InitBaseFont(*(TDescriptor **)(*((void *)this + 76) + 40), 0, 0.0);
  }
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)atomic_load_explicit((atomic_ullong *volatile)(v1 + 32), memory_order_acquire)
                           + 496);

  return v2();
}

void TSplicedFont::~TSplicedFont(TSplicedFont *this)
{
  TSplicedFont::~TSplicedFont(this);

  JUMPOUT(0x1853275C0);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1ED05D850;
  uint64_t v2 = *((void *)this + 77);
  if (v2) {
    free((void *)(v2 - 56));
  }

  TBaseFont::~TBaseFont(this);
}

void TInstanceFont::~TInstanceFont(id *this)
{
  TInstanceFont::~TInstanceFont(this);

  JUMPOUT(0x1853275C0);
}

{
  uint64_t vars8;

  *this = &unk_1ED05DBE0;

  TBaseFont::~TBaseFont((TBaseFont *)this);
}

void CTFontRemoveFromCaches(uint64_t a1)
{
  if (a1)
  {
    uint64_t v1 = *(void *)(*(void *)(a1 + 40) + 400);
    if (v1)
    {
      id v6 = (id)0xAAAAAAAAAAAAAAAALL;
      (*(void (**)(id *__return_ptr, uint64_t))(*(void *)v1 + 200))(&v6, v1);
      if (atomic_load_explicit((atomic_ullong *volatile)&v6, memory_order_acquire))
      {
        TDescriptorSource::TDescriptorSource((TDescriptorSource *)&v5);
        TDescriptorSource::PurgeFromCaches((TDescriptorSource *)&v5, (const __CFURL *)atomic_load_explicit((atomic_ullong *volatile)&v6, memory_order_acquire));
        CFDictionaryRef v2 = (const __CFDictionary *)(*(uint64_t (**)(uint64_t))(*(void *)v1 + 880))(v1);
        if (v2)
        {
          CFDictionaryRef Value = CFDictionaryGetValue(v2, @"cacheKey");
          if (Value)
          {
            id v4 = Value;
            TDescriptorSource::TDescriptorSource((TDescriptorSource *)&v5);
            TDescriptorSource::PurgeFromSplicedFonts((TDescriptorSource *)&v5, v4);
          }
        }
      }
      if ((*(uint64_t (**)(uint64_t))(*(void *)v1 + 568))(v1))
      {
        CGFontDBGetLocal();
        CGFontDBPurgeFont();
      }
    }
  }
  else
  {
    TDescriptorSource::TDescriptorSource((TDescriptorSource *)&v6);
    TDescriptorSource::PurgeFromCaches((TDescriptorSource *)&v6, 0);
    CGFontDBGetLocal();
    CGFontDBPurgeFont();
    FPFontPurgeCaches();
  }
}

void TComponentFont::TComponentFont(TComponentFont *this, const TComponentFont *a2)
{
  TBaseFont::TBaseFont(this, 0);
  *(void *)uint64_t v4 = &unk_1ED05DFF8;
  *(_DWORD *)(v4 + 712) = *((_DWORD *)a2 + 178);
  *((void *)this + 90) = (id)(*(uint64_t (**)(const TComponentFont *))(*(void *)a2 + 880))(a2);
  *(_OWORD *)((char *)this + 728) = 0u;
  *((void *)this + 93) = (id)atomic_load_explicit((atomic_ullong *volatile)a2 + 93, memory_order_acquire);
  *((void *)this + 94) = *((void *)a2 + 94);
  long long v6 = *(_OWORD *)((char *)a2 + 616);
  long long v5 = *(_OWORD *)((char *)a2 + 632);
  long long v7 = *(_OWORD *)((char *)a2 + 600);
  *((void *)this + 81) = *((void *)a2 + 81);
  *(_OWORD *)((char *)this + 616) = v6;
  *(_OWORD *)((char *)this + 632) = v5;
  *(_OWORD *)((char *)this + 600) = v7;
  uint64_t v8 = *((void *)a2 + 88);
  long long v10 = *((_OWORD *)a2 + 42);
  long long v9 = *((_OWORD *)a2 + 43);
  *((_OWORD *)this + 41) = *((_OWORD *)a2 + 41);
  *((_OWORD *)this + 42) = v10;
  *((_OWORD *)this + 43) = v9;
  *((void *)this + 88) = v8;
  MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(0, 0, (CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)this + 93, memory_order_acquire));

  TCFRef<__CTFont const*>::Retain((atomic_ullong *)this + 11, (id)atomic_load_explicit((atomic_ullong *volatile)a2 + 11, memory_order_acquire));
  TCFRef<__CTFont const*>::Retain((atomic_ullong *)this + 12, (id)atomic_load_explicit((atomic_ullong *volatile)a2 + 12, memory_order_acquire));
}

unint64_t TComponentFont::GetSplicedDict(atomic_ullong *this)
{
  return atomic_load_explicit(this + 90, memory_order_acquire);
}

uint64_t TInstanceFont::TInstanceFont(uint64_t a1, uint64_t a2, uint64_t a3, const __CFDictionary *a4)
{
  TBaseFont::TBaseFont((TBaseFont *)a1, (atomic_ullong *)a2);
  *(void *)uint64_t v7 = &unk_1ED05DBE0;
  *(unsigned char *)(v7 + 624) = 0;
  uint64_t v8 = (atomic_ullong *)(v7 + 640);
  *(_OWORD *)(v7 + 600) = 0u;
  *(unsigned char *)(v7 + 616) = 0;
  *(_OWORD *)(v7 + 632) = 0u;
  id v12 = (id)0xAAAAAAAAAAAAAAAALL;
  GetBaseCGFont((atomic_ullong *)a2, a4, (atomic_ullong *)&v12);
  CFDictionaryRef v9 = CGFontCopyVariations((CGFontRef)atomic_load_explicit((atomic_ullong *volatile)&v12, memory_order_acquire));
  TInstanceFont::InitWithVariation((atomic_ullong *)a1, (CGFont *)atomic_load_explicit((atomic_ullong *volatile)&v12, memory_order_acquire), v9, a4);
  TCFRef<__CTFont const*>::Retain(v8, (id)atomic_load_explicit((atomic_ullong *volatile)&v12, memory_order_acquire));
  if (IsNamedInstance((CGFont *)atomic_load_explicit((atomic_ullong *volatile)&v12, memory_order_acquire))) {

  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)a2 + 16))(a2) == 1414088260)
  {
    uint64_t v10 = *(void *)(a2 + 616);
    *(unsigned char *)(a1 + 624) = *(unsigned char *)(a2 + 624);
    *(void *)(a1 + 616) = v10;
  }

  return a1;
}

void TInstanceFont::InitWithVariation(atomic_ullong *this, CGFont *a2, const __CFDictionary *a3, id a4)
{
  if (a3)
  {
    CFURLRef explicit = (const __CFURL *)atomic_load_explicit(this + 10, memory_order_acquire);
    id v18 = 0;
    if ((*((_DWORD *)this + 45) & 0x20000000) != 0)
    {
      CopyPathFromInMemoryFontURL(explicit, (CFStringRef *)&v19);

      id v9 = v19;
    }
    else
    {
      if (explicit)
      {
        id v19 = 0;
        if (CFURLGetBaseURL(explicit))
        {

          CFURLRef explicit = (const __CFURL *)atomic_load_explicit((atomic_ullong *volatile)&v19, memory_order_acquire);
        }
        id v17 = (id)CFURLCopyFileSystemPath(explicit, kCFURLPOSIXPathStyle);
      }
      else
      {
        id v17 = 0;
      }

      id v9 = v17;
    }

    id v19 = 0;
    if (IsNamedInstance(a2))
    {
      uint64_t v10 = (void *)CGFontCopyPostScriptName(a2);
      atomic_load_explicit((atomic_ullong *volatile)&v18, memory_order_acquire);
      id v17 = (id)CGFontURLCreate();
      unint64_t v11 = atomic_exchange((atomic_ullong *volatile)&v17, 0);
    }
    else
    {
      id v17 = (id)CGFontCopyPostScriptName(a2);

      if (!CGFontGetParserFont()) {
        goto LABEL_26;
      }
      FPFontGetDefaultInstance();
      uint64_t v10 = (void *)FPFontCopyPostScriptName();
      atomic_load_explicit((atomic_ullong *volatile)&v18, memory_order_acquire);
      id v17 = (id)CGFontURLCreate();
      unint64_t v11 = atomic_exchange((atomic_ullong *volatile)&v17, 0);
    }

    if (atomic_load_explicit((atomic_ullong *volatile)&v19, memory_order_acquire))
    {

      goto LABEL_16;
    }
LABEL_26:

    id v15 = v18;
    goto LABEL_24;
  }
LABEL_16:
  if (a4)
  {
    TCFRef<__CTFont const*>::Retain(this + 75, a4);
    id v19 = (id)0xAAAAAAAAAAAAAAAALL;
  }
  else
  {
    CreateVariationDictFromGraphicsFont(&v19);

    id v19 = (id)0xAAAAAAAAAAAAAAAALL;
    if (!a3)
    {
      id v19 = a2;
      goto LABEL_20;
    }
  }
  CreateFontWithVariation(a2, (const __CFDictionary *)a4, (atomic_ullong *)&v19);
LABEL_20:
  uint64_t v12 = 0;
  unint64_t v13 = atomic_exchange((atomic_ullong *volatile)&v19, 0);
  atomic_compare_exchange_strong(this + 79, (unint64_t *)&v12, v13);
  if (v12) {
    uint64_t v14 = (void *)v13;
  }
  else {
    uint64_t v14 = 0;
  }

  id v16 = (id)atomic_load_explicit(this + 75, memory_order_acquire);
  TBaseFont::SetAttributeInternal<TCFRef<__CFSet const*>>(this, (atomic_ullong *)&v16, @"NSCTFontVariationAttribute");

  id v15 = v19;
LABEL_24:
}

uint64_t IsNamedInstance(CGFont *a1)
{
  if (!a1 || !CGFontGetParserFont()) {
    return 1;
  }

  return FPFontIsNamedInstance();
}

void TBaseFont::TBaseFont(TBaseFont *this, atomic_ullong *a2)
{
  *((_DWORD *)this + 2) = 0;
  *(void *)this = &unk_1ED05F4D8;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  uint64_t v4 = (unsigned int *)a2 + 45;
  (*(void (**)(atomic_ullong *))(*a2 + 200))(a2);
  *((void *)this + 11) = (id)atomic_load_explicit(a2 + 11, memory_order_acquire);
  *((void *)this + 12) = (id)atomic_load_explicit(a2 + 12, memory_order_acquire);
  *((void *)this + 13) = (id)atomic_load_explicit(a2 + 13, memory_order_acquire);
  *((_DWORD *)this + 28) = 0;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 164) = 0u;
  unsigned int v5 = atomic_load(v4);
  long long v6 = *MEMORY[0x1E4F1DB28];
  long long v7 = *(_OWORD *)(MEMORY[0x1E4F1DB28] + 16);
  *((_OWORD *)this + 18) = *MEMORY[0x1E4F1DAD8];
  *((_OWORD *)this + 19) = v6;
  *((_DWORD *)this + 45) = v5 & 0xB0000000;
  *((_DWORD *)this + 46) = -1342177280;
  *((_OWORD *)this + 16) = 0u;
  *((_OWORD *)this + 17) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((void *)this + 29) = 0;
  *((void *)this + 30) = 0;
  *((_DWORD *)this + 62) = 0;
  *((_OWORD *)this + 20) = v7;
  *((unsigned char *)this + 336) = 0;
  *(_OWORD *)((char *)this + 360) = 0u;
  *(_OWORD *)((char *)this + 376) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  *((_DWORD *)this + 98) = 1065353216;
  *((_OWORD *)this + 25) = 0u;
  *((_OWORD *)this + 26) = 0u;
  *((_DWORD *)this + 108) = 1065353216;
  *((_WORD *)this + 220) = -1;
  *(void *)((char *)this + 460) = 0;
  *((_DWORD *)this + 117) = 0;
  *(void *)((char *)this + 444) = 0;
  *(void *)((char *)this + 452) = 0;
  *((void *)this + 60) = (char *)this + 472;
  *((void *)this + 61) = 0;
  *((void *)this + 62) = 0;
  *((void *)this + 63) = 0;
  *((void *)this + 68) = (char *)this + 512;
  *(_OWORD *)((char *)this + 552) = 0u;
  *(_OWORD *)((char *)this + 568) = 0u;
  *(_OWORD *)((char *)this + 584) = 0u;
  TBaseFont::Init((atomic_ullong *)this, 0);
}

void TDescriptorSource::AddCachedDescriptor(TDescriptorSource *this, __CFString *a2, uint64_t a3, const __CTFontDescriptor *a4)
{
  if (a3)
  {
    id v9 = 0;
    uint64_t v6 = *(void *)(a3 + 40);
    if ((*(_DWORD *)(v6 + 16) & 0x80000000) == 0) {
      TDescriptor::InitBaseFont(*(TDescriptor **)(a3 + 40), 0, 0.0);
    }
    unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(v6 + 32), memory_order_acquire);
    if (explicit)
    {
      (*(void (**)(id *__return_ptr))(*(void *)explicit + 200))(&v8);
    }
    TPerThreadLRUCache<TRequestCacheNode,(ThreadSpecificKey)3,16ul>::TPerThreadLRUCache(&v8);
    TRequestCache::AddResultForRequest((TRequestCache *)&v8, (void *)atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire), this, a2, 0);
  }
  else
  {
    TDescriptorSource::AddMissedRequest(this, a2, 0, (CFComparisonResult (*)(const void *, const void *, void *))a4);
  }
}

id TBaseFont::CopyFontURL@<X0>(atomic_ullong *this@<X0>, void *a2@<X8>)
{
  id result = (id)atomic_load_explicit(this + 10, memory_order_acquire);
  *a2 = result;
  return result;
}

void TDescriptorSource::CopyFontDescriptorPerPostScriptName(atomic_ullong **a1@<X0>, const __CFString *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, void *a6@<X8>)
{
  unint64_t v8 = a3;
  unint64_t explicit = (__CFString *)a2;
  id v40 = 0;
  uint64_t v11 = a4 & 4;
  if (!(a4 & 8 | a3 & 0x10400) && TDescriptorSource::ShouldSubstituteInvisibleFontName(a2, a2))
  {
    CTFontLogSystemFontNameRequest();
    unint64_t explicit = @"TimesNewRomanPSMT";
  }
  id v39 = 0;
  if (v11 | v8 & 0x400)
  {
    if ((v8 & 0x20) != 0) {
      goto LABEL_11;
    }
  }
  else
  {
    CopyNormalizedSystemFontPostScriptName(explicit, &v41);

    unint64_t explicit = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&v39, memory_order_acquire);
    if ((v8 & 0x20) != 0)
    {
LABEL_11:
      int v35 = 0;
      goto LABEL_12;
    }
  }
  if (dispatch_get_specific((const void *)TDescriptorSource::DoNotCacheKey))
  {
    int v35 = 0;
    v8 |= 0x20uLL;
    goto LABEL_12;
  }
  if (a5) {
    goto LABEL_11;
  }

  if (TDescriptorSource::HasMissedRequest((TDescriptorSource *)explicit, (void *)v8, 0, v16))
  {
LABEL_87:
    *a6 = atomic_exchange((atomic_ullong *volatile)&v40, 0);
    goto LABEL_81;
  }
  *(void *)&v41.var0 = 0;
  id v17 = TPerThreadLRUCache<TRequestCacheNode,(ThreadSpecificKey)3,16ul>::TPerThreadLRUCache(v42);
  if (TRequestCache::CopyResultForRequest(v17, explicit, (void *)v8, (atomic_ullong *)&v41, 0))
  {
    if (atomic_load_explicit((atomic_ullong *volatile)&v41, memory_order_acquire))
    {
      CFTypeID v18 = CFGetTypeID((CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)&v41, memory_order_acquire));
      if (v18 == CFURLGetTypeID()) {
        CFURLRef ValueAtIndex = (const __CFURL *)atomic_load_explicit((atomic_ullong *volatile)&v41, memory_order_acquire);
      }
      else {
        CFURLRef ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v41, memory_order_acquire), 0);
      }
      TDescriptorSource::CopyDescriptor(a1, ValueAtIndex, 0, 0, v42);

      TDescriptorSource::CopyFontDescriptorWithOptions((atomic_ullong *)&v40, v8, 0, v42);
    }

    goto LABEL_87;
  }

  int v35 = 1;
LABEL_12:
  if (v8 & 0x10 | v11)
  {
    uint64_t v12 = (v8 >> 4) & 1;
  }
  else
  {
    if ((a4 & 2) != 0) {
      goto LABEL_19;
    }
    if (explicit == @".") {
      goto LABEL_18;
    }
    if (!explicit) {
      goto LABEL_27;
    }
    if (CFStringHasPrefix(explicit, @".")) {
LABEL_18:
    }
      LOBYTE(v12) = IsSystemFontPostScriptName(explicit);
    else {
LABEL_19:
    }
      LOBYTE(v12) = 1;
  }
  if (explicit != @"LastResort"
    && explicit
    && !CFEqual(explicit, @"LastResort")
    && CFStringCompare(explicit, @"LastResort", 1uLL) == kCFCompareEqualTo)
  {
    TDescriptorSource::CopyLastResort(a6);
    goto LABEL_81;
  }
  if ((v12 & 1) != 0
    || (TDescriptorSource::CopySplicedDescriptorForName(&v41),
        (id)atomic_exchange((atomic_ullong *volatile)&v40, atomic_exchange((atomic_ullong *volatile)&v41, 0)), *(id *)&v41.var0, !atomic_load_explicit((atomic_ullong *volatile)&v40, memory_order_acquire)))
  {
LABEL_27:
    v42[0] = (id)0xAAAAAAAAAAAAAAAALL;
    v42[0] = (id)GSFontCopyFontFilePath();
    if (atomic_load_explicit((atomic_ullong *volatile)v42, memory_order_acquire))
    {
      if (qword_1EB2CE220 != -1) {
        dispatch_once(&qword_1EB2CE220, &__block_literal_global_620);
      }
      CFStringRef v13 = explicit;
      uint64_t v14 = a6;
      if (_MergedGlobals_16 == 1)
      {
        CFStringRef v13 = explicit;
        if (CFStringHasSuffix((CFStringRef)atomic_load_explicit((atomic_ullong *volatile)v42, memory_order_acquire), @"PingFangUI.ttc"))
        {
          if (qword_1EB2CE1F0 != -1) {
            dispatch_once(&qword_1EB2CE1F0, &__block_literal_global_0);
          }
          CFStringRef v13 = explicit;
          if (qword_1EB2CE1E8)
          {
            uint64_t v15 = 0;
            while (!CFEqual(sPingFangFacesMap[v15], explicit))
            {
              v15 += 2;
              if (v15 == 36)
              {
                CFStringRef v13 = explicit;
                goto LABEL_50;
              }
            }
            CFStringRef v13 = sPingFangFacesMap[v15 + 1];
            TCFRef<__CTFont const*>::Retain((atomic_ullong *)v42, (id)qword_1EB2CE1E8);
          }
        }
      }
LABEL_50:
      atomic_load_explicit((atomic_ullong *volatile)v42, memory_order_acquire);
      CFURLRef v20 = (const __CFURL *)CGFontURLCreate();
      if (v20)
      {
        CFURLRef v21 = v20;
        TDescriptorSource::CopyDescriptor(a1, v20, (const __CFString *)atomic_load_explicit((atomic_ullong *volatile)v42, memory_order_acquire), v13, &v41);

        TDescriptorSource::AddCachedDescriptor((TDescriptorSource *)explicit, (__CFString *)v8, atomic_load_explicit((atomic_ullong *volatile)&v40, memory_order_acquire), v22);
        TDescriptorSource::CopyFontDescriptorWithOptions((atomic_ullong *)&v40, v8, 0, a6);
        unint64_t v23 = v21;
LABEL_80:

        goto LABEL_81;
      }
    }
    else if (v11)
    {
      uint64_t v14 = a6;
    }
    else
    {

      uint64_t v14 = a6;
      if (atomic_load_explicit((atomic_ullong *volatile)&v39, memory_order_acquire)) {
        unint64_t explicit = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&v39, memory_order_acquire);
      }
    }
    uint64_t v24 = CGFontCreateWithFontName(explicit);
    CFIndex v25 = v24;
    if (v24)
    {
      if (a4)
      {
        CFStringRef v26 = CGFontCopyPostScriptName(v24);
        unint64_t v27 = (__CFString *)v26;
        if (!v26 || CFStringCompare(v26, explicit, 0) && ((v8 & 0x200) != 0 || !IsPostScriptNameAlias(explicit, v27)))
        {
          *uint64_t v14 = 0;
          BOOL v34 = v27;
          goto LABEL_78;
        }
      }
      TDescriptorSource::CopyDescriptor(a1, v25, 0, (atomic_ullong *)&v41);
    }
    if (atomic_load_explicit((atomic_ullong *volatile)&v40, memory_order_acquire)) {
      goto LABEL_62;
    }
    *(void *)&v41.var0 = 0xAAAAAAAAAAAAAAAALL;
    CopyLowercasedString(explicit, &v41);
    id v38 = (id)0xAAAAAAAAAAAAAAAALL;
    CopyPostScriptNameForAliasLowercased((const __CFString *)atomic_load_explicit((atomic_ullong *volatile)&v41, memory_order_acquire), &v38);
    if (!atomic_load_explicit((atomic_ullong *volatile)&v38, memory_order_acquire))
    {

LABEL_62:
      if (atomic_load_explicit((atomic_ullong *volatile)&v40, memory_order_acquire) | a4 & 0x11)
      {
LABEL_68:
        if (!atomic_load_explicit((atomic_ullong *volatile)&v40, memory_order_acquire))
        {
          TDescriptorSource::CopyFontDescriptorFromVariationPostScriptName(explicit, &v41);
        }
        TDescriptorSource::CopyFontDescriptorWithOptions((atomic_ullong *)&v40, v8, 0, &v41);

        if (v35)
        {
          unint64_t v33 = atomic_load_explicit((atomic_ullong *volatile)&v40, memory_order_acquire);
          if (!a4 || v33) {
            TDescriptorSource::AddCachedDescriptor((TDescriptorSource *)explicit, (__CFString *)v8, atomic_load_explicit((atomic_ullong *volatile)&v40, memory_order_acquire), v32);
          }
        }
        *uint64_t v14 = atomic_exchange((atomic_ullong *volatile)&v40, 0);
        goto LABEL_79;
      }
      id v38 = (id)0xAAAAAAAAAAAAAAAALL;
      TDescriptorSource::CopyDescriptorsForRequestWithFamilyName((TDescriptorSource *)&v38, (const __CFString *)a1, explicit, v8);
      CFArrayRef v28 = (const __CFArray *)(id)atomic_load_explicit((atomic_ullong *volatile)&v38, memory_order_acquire);
      if (v28)
      {
        CFArrayRef v29 = v28;
        CFIndex Count = CFArrayGetCount(v28);

        if (!Count)
        {
LABEL_67:

          goto LABEL_68;
        }
        CFArrayRef v31 = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v38, memory_order_acquire);
        memset(&v41.var1, 0, 24);
        *(void *)&v41.var0 = 0xAAAAAAAA00000000;
        TBaseFont::CreateVariantWithTraitsMatchingDescriptors(&v41, v31, &v37);

        CFArrayRef v28 = (const __CFArray *)v37;
      }

      goto LABEL_67;
    }
    atomic_load_explicit((atomic_ullong *volatile)&v38, memory_order_acquire);
    TDescriptorSource::CopyFontDescriptorPerPostScriptName(v14);

    BOOL v34 = *(__CFString **)&v41.var0;
LABEL_78:

LABEL_79:
    unint64_t v23 = v25;
    goto LABEL_80;
  }
  TDescriptorSource::CopyFontDescriptorWithOptions((atomic_ullong *)&v40, v8, 0, a6);
LABEL_81:
}

void *TPerThreadLRUCache<TRequestCacheNode,(ThreadSpecificKey)3,16ul>::TPerThreadLRUCache(void *a1)
{
  *a1 = 0;
  Table = GetTable();
  if (!Table || (int v3 = (_DWORD *)Table[6]) == 0) {
    operator new();
  }
  if (*v3 != TGenerationSeed::sGeneration) {
    TLRUCacheImp<TRequestCacheNode,16ul>::RemoveAll(Table[6]);
  }
  *a1 = v3;
  return a1;
}

BOOL TDescriptorSource::HasMissedRequest(TDescriptorSource *this, void *a2, void *a3, CFComparisonResult (*a4)(const void *, const void *, void *))
{
  if (!this) {
    return 0;
  }
  os_unfair_lock_lock_with_options();
  MissedRequests = GetMissedRequests();
  v10[0] = this;
  v10[1] = a2;
  id v10[2] = a3;

  os_unfair_lock_unlock((os_unfair_lock_t)&sMissedRequestCacheLock);
  return v8;
}

void *std::unordered_set<anonymous namespace'::TMissedRequest,anonymous namespace'::TMissedRequestHasher,std::equal_to<anonymous namespace'::TMissedRequest>,std::allocator<anonymous namespace'::TMissedRequest>>::find[abi:nn180100](void *a1, uint64_t a2)
{
  CFHashCode v4 = CFHash((CFTypeRef)atomic_load_explicit((atomic_ullong *volatile)a2, memory_order_acquire));
  unint64_t v5 = STL::hash_val<unsigned long,unsigned long,CFComparisonResult (*)(void const*,void const*,void *)>(v4, *(void *)(a2 + 8), *(void *)(a2 + 16));
  int8x8_t v6 = (int8x8_t)a1[1];
  if (!*(void *)&v6) {
    return 0;
  }
  unint64_t v7 = v5;
  uint8x8_t v8 = (uint8x8_t)vcnt_s8(v6);
  v8.i16[0] = vaddlv_u8(v8);
  unint64_t v9 = v8.u32[0];
  if (v8.u32[0] > 1uLL)
  {
    unint64_t v10 = v5;
    if (v5 >= *(void *)&v6) {
      unint64_t v10 = v5 % *(void *)&v6;
    }
  }
  else
  {
    unint64_t v10 = (*(void *)&v6 - 1) & v5;
  }
  uint64_t v11 = *(void **)(*a1 + 8 * v10);
  if (!v11) {
    return 0;
  }
  uint64_t v12 = (void *)*v11;
  if (*v11)
  {
    do
    {
      unint64_t v13 = v12[1];
      if (v13 == v7)
      {
        {
          return v12;
        }
      }
      else
      {
        if (v9 > 1)
        {
          if (v13 >= *(void *)&v6) {
            v13 %= *(void *)&v6;
          }
        }
        else
        {
          v13 &= *(void *)&v6 - 1;
        }
        if (v13 != v10) {
          return 0;
        }
      }
      uint64_t v12 = (void *)*v12;
    }
    while (v12);
  }
  return v12;
}

uint64_t STL::hash_val<unsigned long,unsigned long,CFComparisonResult (*)(void const*,void const*,void *)>(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v3 = (a2 + ((a1 + 2654435769) << 6) + ((unint64_t)(a1 + 2654435769) >> 2) + 2654435769u) ^ (a1 + 2654435769);
  unint64_t v4 = 0x9DDFEA08EB382D69 * (((8 * a3) + 8) ^ HIDWORD(a3));
  unint64_t v5 = 0x9DDFEA08EB382D69 * (HIDWORD(a3) ^ (v4 >> 47) ^ v4);
  return ((v3 << 6) + (v3 >> 2) - 0x622015F714C7D297 * (v5 ^ (v5 >> 47)) + 2654435769u) ^ v3;
}

void *GetMissedRequests(void)
{
  int v0 = (void *)qword_1EB2CE218;
  if (!qword_1EB2CE218)
  {
    uint64_t v1 = operator new(0x28uLL, MEMORY[0x1E4FBA2D0]);
    int v0 = v1;
    if (v1)
    {
      *(_OWORD *)uint64_t v1 = 0u;
      *((_OWORD *)v1 + 1) = 0u;
      *((_DWORD *)v1 + 8) = 1065353216;
    }
    qword_1EB2CE218 = (uint64_t)v1;
  }
  if (TGenerationSeed::sGeneration != dword_1EB2CE170)
  {
    if (v0[3])
    {
      CFDictionaryRef v2 = (id *)v0[2];
      if (v2)
      {
        do
        {
          unint64_t v3 = (id *)*v2;

          operator delete(v2);
          CFDictionaryRef v2 = v3;
        }
        while (v3);
      }
      v0[2] = 0;
      uint64_t v4 = v0[1];
      if (v4)
      {
        for (uint64_t i = 0; i != v4; ++i)
          *(void *)(*v0 + 8 * i) = 0;
      }
      v0[3] = 0;
      int v0 = (void *)qword_1EB2CE218;
    }
    dword_1EB2CE170 = TGenerationSeed::sGeneration;
  }
  return v0;
}

uint64_t TRequestCache::CopyResultForRequest(uint64_t *a1, id a2, void *a3, atomic_ullong *a4, void *a5)
{
  v23[0] = a2;
  v23[1] = a3;
  v24[0] = a5;
  uint64_t v9 = 0;
  v24[1] = 0;
  uint64_t v10 = *a1;
  uint64_t v11 = (uint64_t *)(v10 + 8);
  uint64_t v12 = v10 + 24;
  unint64_t v13 = (uint64_t *)(v10 + 8);
  while (1)
  {
    uint64_t v14 = *v13;
    uint64_t v15 = v12 + 48 * *v13;
    if (*(id *)(v15 + 24) == v23[1] && *(id *)(v12 + 48 * v14 + 32) == v24[0])
    {
      unint64_t explicit = (const void *)atomic_load_explicit((atomic_ullong *volatile)(v12 + 48 * v14 + 16), memory_order_acquire);
      id v17 = (const void *)atomic_load_explicit((atomic_ullong *volatile)v23, memory_order_acquire);
      if (explicit == v17) {
        break;
      }
      BOOL v18 = !explicit || v17 == 0;
      if (!v18 && CFEqual(explicit, v17)) {
        break;
      }
    }
    if (v14 == *(void *)(v10 + 16))
    {

      uint64_t v19 = 0;
      goto LABEL_18;
    }
    unint64_t v13 = (uint64_t *)(v15 + 8);
    uint64_t v9 = v14;
  }
  uint64_t v20 = *v11;
  if (v14 != *v11)
  {
    *(void *)(v12 + 48 * v9 + 8) = *(void *)(v15 + 8);
    uint64_t v21 = *(void *)(v10 + 16);
    if (v14 == v21)
    {
      *(void *)(v10 + 16) = v9;
      uint64_t v21 = v9;
    }
    *(void *)(v15 + 8) = v20;
    uint64_t *v11 = v14;
    *(void *)(v12 + 48 * v21 + 8) = v14;
  }
  TCFRef<__CTFont const*>::Retain(a4, (id)atomic_load_explicit((atomic_ullong *volatile)(v12 + 48 * v14 + 40), memory_order_acquire));
  uint64_t v19 = 1;
LABEL_18:

  return v19;
}

void TDescriptorSource::CopyFontDescriptorWithOptions(atomic_ullong *a1@<X0>, int a2@<W1>, const void *a3@<X2>, void *a4@<X8>)
{
  unint64_t explicit = atomic_load_explicit(a1, memory_order_acquire);
  if ((*(void *)&a2 & 0x10400) != 0 && explicit != 0)
  {
    int v25 = a2 & 0x10485;
    uint64_t v9 = (id)atomic_load_explicit(a1, memory_order_acquire);
    uint64_t v10 = v9[5];

    uint64_t v24 = (TBaseFont *)0xAAAAAAAAAAAAAAAALL;
    uint64_t v11 = (TDescriptor **)(id)atomic_load_explicit(a1, memory_order_acquire);
    uint64_t v12 = v11;
    unint64_t v13 = v11[5];
    if ((*((_DWORD *)v13 + 4) & 0x80000000) == 0) {
      TDescriptor::InitBaseFont(v11[5], 0, 0.0);
    }
    uint64_t v14 = (TBaseFont *)atomic_load_explicit((atomic_ullong *volatile)v13 + 4, memory_order_acquire);

    uint64_t v24 = v14;
    if (a3)
    {
      id v23 = (id)0xAAAAAAAAAAAAAAAALL;
      TDescriptor::CopyAttributes((atomic_ullong *)v10, &v26);
      TCFMutableDictionary::TCFMutableDictionary((TCFMutableDictionary *)&v23, (CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v26, memory_order_acquire));

      CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v23, memory_order_acquire), @"NSFontSizeAttribute", a3);
      unint64_t v15 = atomic_load_explicit(a1, memory_order_acquire);
      id v16 = (void *)atomic_load_explicit((atomic_ullong *volatile)&v23, memory_order_acquire);
      uint64_t v17 = TCFBase<TDescriptor>::Allocate(96);
      if (v17)
      {
        BOOL v18 = (void *)v17;
        uint64_t v19 = v24;
        uint64_t v20 = (TDescriptor *)(v17 + 48);
        _OWORD v18[2] = 0;
        void v18[3] = TDescriptor::Hash;
        v18[4] = 0;
        void v18[5] = v20;
        TDescriptor::TDescriptor(v20, *(const TDescriptor **)(v15 + 40), (atomic_uint *)v19, v16);
        id v26 = v18;
        id v22 = (id)atomic_exchange((atomic_ullong *volatile)&v26, 0);
      }
      else
      {
        id v22 = 0;
      }

      id v21 = v23;
      goto LABEL_14;
    }
    if ((v25 & ~*(_DWORD *)(v10 + 16)) != 0)
    {
      TCFBase_NEW<CTFontDescriptor,TBaseFont const*&,unsigned int &>((uint64_t *)&v24, &v25, &v26);

      id v21 = v26;
LABEL_14:
    }
  }
  *a4 = atomic_exchange(a1, 0);
}

uint64_t TDescriptorSource::ShouldSubstituteInvisibleFontName(const __CFString *this, const __CFString *a2)
{
  uint64_t result = dyld_program_sdk_at_least();
  if (result)
  {
    if (this != @".")
    {
      if (!this) {
        return 0;
      }
      uint64_t result = CFStringHasPrefix(this, @".");
      if (!result) {
        return result;
      }
    }
    if (this != @".AppleSystemUIFont")
    {
      uint64_t result = 1;
      if (this) {
        return CFStringHasPrefix(this, @".AppleSystemUIFont") == 0;
      }
      return result;
    }
    return 0;
  }
  return result;
}

void TRequestCache::AddResultForRequest(TRequestCache *this, void *a2, id a3, void *a4, CFComparisonResult (*a5)(const void *, const void *, void *))
{
  v18[0] = (atomic_ullong)&unk_1ED05E6A0;
  v18[1] = 0;
  v19[0] = a3;
  v19[1] = a4;
  v20[0] = a5;
  v20[1] = a2;
  uint64_t v9 = *(void *)this;
  uint64_t v10 = *(void *)(*(void *)this + 16);
  uint64_t v11 = *(void *)this + 24;
  uint64_t v12 = TRequestCacheNode::operator=((atomic_ullong *)(v11 + 48 * v10), v18);
  uint64_t v13 = *(void *)(v9 + 8);
  do
  {
    uint64_t v14 = v13;
    uint64_t v15 = v11 + 48 * v13;
    uint64_t v17 = *(void *)(v15 + 8);
    id v16 = (void *)(v15 + 8);
    uint64_t v13 = v17;
  }
  while (v17 != *(void *)(v9 + 16));
  v12[1] = *(void *)(v9 + 8);
  *(void *)(v9 + 8) = v10;
  *(void *)(v9 + 16) = v14;
  *id v16 = v10;
  v18[0] = (atomic_ullong)&unk_1ED05E6A0;
}

atomic_ullong *TRequestCacheNode::operator=(atomic_ullong *a1, atomic_ullong *a2)
{
  if (a1 != a2)
  {
    TCFRef<__CTFont const*>::Retain(a1 + 2, (id)atomic_load_explicit(a2 + 2, memory_order_acquire));
    a1[3] = a2[3];
    TCFRef<__CTFont const*>::Retain(a1 + 5, (id)atomic_load_explicit(a2 + 5, memory_order_acquire));
    a1[4] = a2[4];
  }
  return a1;
}

void CopyNormalizedSystemFontPostScriptName(__CFString *a1@<X0>, void *a2@<X8>)
{
  if (a1)
  {
    if (qword_1EB2CE8E8 != -1) {
      dispatch_once(&qword_1EB2CE8E8, &__block_literal_global_107);
    }
    if (qword_1EB2CE8E0) {
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)qword_1EB2CE8E0, @"PSNames");
    }
    else {
      CFDictionaryRef Value = 0;
    }
    id v10 = (id)0xAAAAAAAAAAAAAAAALL;
    CopyLowercasedString(a1, &v10);
    id v5 = (id)atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire);
    if (Value) {
      int8x8_t v6 = (void *)CFDictionaryGetValue(Value, v5);
    }
    else {
      int8x8_t v6 = 0;
    }
    id v9 = v6;
    unint64_t v7 = (__CFString *)atomic_exchange((atomic_ullong *volatile)&v9, 0);

    if (v7) {
      uint8x8_t v8 = v7;
    }
    else {
      uint8x8_t v8 = a1;
    }
    *a2 = v8;
  }
  else
  {
    *a2 = 0;
  }
}

void CopyLowercasedString(CFStringRef theString@<X0>, void *a2@<X8>)
{
  if (theString)
  {
    if (qword_1EB2CE758 != -1) {
      dispatch_once_f(&qword_1EB2CE758, 0, (dispatch_function_t)CopyLowercasedString(__CFString const*)::$_0::__invoke);
    }
    MutableCFDictionaryRef Copy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, theString);
    unint64_t explicit = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&MutableCopy, memory_order_acquire);
    CFStringFold(explicit, 1uLL, (CFLocaleRef)_MergedGlobals_28);
    *a2 = atomic_exchange((atomic_ullong *volatile)&MutableCopy, 0);
  }
  else
  {
    *a2 = 0;
  }
}

void TTenuousComponentFont::~TTenuousComponentFont(id *this)
{
  *this = &unk_1ED05EC18;

  TComponentFont::~TComponentFont(this);

  JUMPOUT(0x1853275C0);
}

{
  uint64_t vars8;

  *this = &unk_1ED05EC18;

  TComponentFont::~TComponentFont(this);
}

void TBaseFont::~TBaseFont(TBaseFont *this)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  *(void *)this = &unk_1ED05F4D8;
  if (atomic_load_explicit((atomic_ullong *volatile)this + 10, memory_order_acquire))
  {
    unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)this + 10, memory_order_acquire);
    if (explicit) {
      objc_msgSend((id)atomic_load_explicit((atomic_ullong *volatile)TCGFontCache::GetCache(this), memory_order_acquire), "removeObjectForKey:", explicit);
    }
  }
  if ((*((_DWORD *)this + 45) & 0x10000000) == 0)
  {
    memset(__b, 170, sizeof(__b));
    if (CFURLGetFileSystemRepresentation((CFURLRef)atomic_load_explicit((atomic_ullong *volatile)this + 10, memory_order_acquire), 1u, __b, 1025))
    {
      FPFontPurgeCaches();
    }
  }
  uint64_t v3 = *((void *)this + 26);
  if (v3)
  {
    std::__hash_table<std::__hash_value_type<unsigned int,std::unique_ptr<TUnicodeDataCachePage>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::unique_ptr<TUnicodeDataCachePage>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::unique_ptr<TUnicodeDataCachePage>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::unique_ptr<TUnicodeDataCachePage>>>>::~__hash_table(v3 + 16);
    MEMORY[0x1853275C0](v3, 0x10E0C4057E07A5FLL);
  }
  uint64_t v4 = *((void *)this + 27);
  if (v4)
  {
    uint64_t v5 = std::__hash_table<EncoderAttempt,std::hash<EncoderAttempt>,std::equal_to<EncoderAttempt>,std::allocator<EncoderAttempt>>::~__hash_table(v4);
    MEMORY[0x1853275C0](v5, 0x10A0C408EF24B1CLL);
  }
  uint64_t v6 = *((void *)this + 30);
  if (v6) {
    MEMORY[0x1853275C0](v6, 0x1000C4089CA3EB1);
  }
  unint64_t v7 = (id *)*((void *)this + 74);
  if ((unint64_t)v7 + 1 >= 2)
  {

    MEMORY[0x1853275C0](v7, 0xE0C40F3C7A20ELL);
  }
  for (uint64_t i = 584; i != 544; i -= 8)

  id v9 = (void *)*((void *)this + 61);
  if (v9)
  {
    std::vector<std::unique_ptr<unsigned short const[]>,TInlineBufferAllocator<std::unique_ptr<unsigned short const[]>,4ul>>::__base_destruct_at_end[abi:nn180100]((uint64_t)this + 488, v9);
    id v10 = (char *)*((void *)this + 61);
    uint64_t v11 = (char *)this + 544;
    if ((char *)this + 512 <= v10 && v11 > v10)
    {
      if (*((void *)this + 63) == *((void *)this + 68)) {
        *(void *)uint64_t v11 = v10;
      }
    }
    else
    {
      operator delete(v10);
    }
  }
  uint64_t v13 = (void *)*((void *)this + 56);
  if (v13)
  {
    std::vector<std::unique_ptr<unsigned short const[]>,TInlineBufferAllocator<std::unique_ptr<unsigned short const[]>,4ul>>::__base_destruct_at_end[abi:nn180100]((uint64_t)this + 448, v13);
    uint64_t v14 = (char *)*((void *)this + 56);
    if ((char *)this + 472 > v14 || (char *)this + 480 <= v14)
    {
      operator delete(v14);
    }
    else if (*((void *)this + 58) == *((void *)this + 60))
    {
      *((void *)this + 60) = v14;
    }
  }
  uint64_t v15 = (TBaseFont *)((char *)this + 440);
  do
  {
    id v16 = (void *)*((void *)v15 - 3);
    if (v16)
    {
      do
      {
        uint64_t v17 = (void *)*v16;
        OTL::Lookup::~Lookup((OTL::Lookup *)(v16 + 3));
        operator delete(v16);
        id v16 = v17;
      }
      while (v17);
    }
    uint64_t v19 = (void *)*((void *)v15 - 5);
    uint64_t v15 = (TBaseFont *)((char *)v15 - 40);
    BOOL v18 = v19;
    *(void *)uint64_t v15 = 0;
    if (v19) {
      operator delete(v18);
    }
  }
  while (v15 != (TBaseFont *)((char *)this + 360));

  for (uint64_t j = 168; j != 144; j -= 8)
  do
  {

    j -= 8;
  }
  while (j != 120);
}

{
  uint64_t vars8;

  TBaseFont::~TBaseFont(this);

  JUMPOUT(0x1853275C0);
}

void TDescriptorSource::CopyDescriptor(atomic_ullong **this@<X0>, const __CFURL *a2@<X1>, const __CFString *a3@<X2>, const __CFString *a4@<X3>, void *a5@<X8>)
{
  id v18 = (id)0xAAAAAAAAAAAAAAAALL;
  if (a3) {
    BOOL v8 = a4 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  char v9 = !v8;
  TDescriptorSource::CopyDescriptorUncached(this, a2, &v18);
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&v18, memory_order_acquire);
  if ((v9 & 1) == 0 && explicit)
  {
    id v17 = (id)0xAAAAAAAAAAAAAAAALL;
    uint64_t v11 = (TDescriptor **)(id)atomic_load_explicit((atomic_ullong *volatile)&v18, memory_order_acquire);
    uint64_t v12 = v11;
    uint64_t v13 = v11[5];
    if ((*((_DWORD *)v13 + 4) & 0x80000000) == 0) {
      TDescriptor::InitBaseFont(v11[5], 0, 0.0);
    }
    (*(void (**)(id *__return_ptr))(*(void *)atomic_load_explicit((atomic_ullong *volatile)v13 + 4, memory_order_acquire)+ 496))(&v17);

    if (!atomic_load_explicit((atomic_ullong *volatile)&v17, memory_order_acquire))
    {
      *a5 = 0;

      goto LABEL_17;
    }
  }
  uint64_t v14 = *this;
  unint64_t v15 = atomic_load_explicit((atomic_ullong *volatile)&v18, memory_order_acquire);
  id v16 = (void *)atomic_load_explicit(v14, memory_order_acquire);
  if (v15) {
    [v16 setObject:v15 forKey:a2];
  }
  else {
    [v16 removeObjectForKey:a2];
  }
  *a5 = atomic_exchange((atomic_ullong *volatile)&v18, 0);
LABEL_17:
}

CGPathRef CTFontCreatePathForGlyph(CTFontRef font, CGGlyph glyph, const CGAffineTransform *matrix)
{
  if (!font) {
    return 0;
  }
  TFont::CreatePathForGlyph(*((TFont **)font + 5), matrix, glyph, &v5);
  uint64_t v3 = (const CGPath *)atomic_exchange((atomic_ullong *volatile)&v5, 0);

  return v3;
}

void TFont::CreatePathForGlyph(TFont *this@<X0>, const CGAffineTransform *a2@<X2>, unsigned int a3@<W1>, void *a4@<X8>)
{
  id v12 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr))(**((void **)this + 50) + 480))(&v12);
  if (atomic_load_explicit((atomic_ullong *volatile)&v12, memory_order_acquire)
    && TFont::HasColorBitmapForGlyph((TBaseFont **)this, a3, (const __CFData *)atomic_load_explicit((atomic_ullong *volatile)&v12, memory_order_acquire)))
  {
    *a4 = 0;
  }
  else
  {
    *(void *)&long long v8 = -1;
    *((void *)&v8 + 1) = -1;
    *(_OWORD *)&v11.c = v8;
    *(_OWORD *)&v11.tdouble x = v8;
    *(_OWORD *)&v11.CGFloat a = v8;
    TFont::GetScaledMatrix(this, &v11);
    if (a2)
    {
      CGAffineTransform t1 = v11;
      long long v9 = *(_OWORD *)&a2->c;
      *(_OWORD *)&t2.CGFloat a = *(_OWORD *)&a2->a;
      *(_OWORD *)&t2.c = v9;
      *(_OWORD *)&t2.tdouble x = *(_OWORD *)&a2->tx;
      CGAffineTransformConcat(&v10, &t1, &t2);
      CGAffineTransform v11 = v10;
    }
    t1.CGFloat a = -3.72066208e-103;
    (*(void (**)(CGAffineTransform *__return_ptr))(**((void **)this + 50) + 496))(&t1);
    atomic_load_explicit((atomic_ullong *volatile)&t1, memory_order_acquire);
    *(void *)&t2.CGFloat a = CGFontCreateGlyphPath();
    *a4 = atomic_exchange((atomic_ullong *volatile)&t2, 0);
  }
}

void TDescriptorSource::CopyDescriptorUncached(atomic_ullong **this@<X0>, const __CFURL *a2@<X1>, void *a3@<X8>)
{
  if (a2)
  {
    id v6 = (id)0xAAAAAAAAAAAAAAAALL;
    TPurgeableCache::RetainedValueForKey(*this, a2, (atomic_ullong *)&v7);
    id v6 = (id)atomic_exchange((atomic_ullong *volatile)&v7, 0);

    if (!atomic_load_explicit((atomic_ullong *volatile)&v6, memory_order_acquire)) {
      operator new();
    }
    *a3 = atomic_exchange((atomic_ullong *volatile)&v6, 0);
  }
  else
  {
    *a3 = 0;
  }
}

void TCGFontCache::CopyFontWithOpticalSizeVariation(TCGFontCache *this@<X0>, CGFont *a2@<X1>, CFDictionaryRef theDict@<X2>, atomic_ullong *a4@<X8>)
{
  if (this
    && theDict
    && (CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, &unk_1ED082EA8)) != 0
    && (CFNumberRef v10 = Value, v11 = CFGetTypeID(Value), v11 == CFNumberGetTypeID()))
  {
    v21.id receiver = (id)-1;
    CFNumberGetValue(v10, kCFNumberDoubleType, &v21);
    id receiver = v21.receiver;
    unint64_t v13 = [_CGFontCacheKey alloc];
    if (v13)
    {
      v21.id receiver = (id)v13;
      v21.super_class = (Class)_CGFontCacheKey;
      unint64_t v13 = [(TCGFontCache *)&v21 init];
      unint64_t v14 = v13;
      if (v13)
      {
        *(void *)(v13 + 16) = a2;
        *(double *)(v14 + 24) = *(double *)&receiver;
        unint64_t v13 = [(CGFont *)a2 hash];
        uint64_t v15 = (uint64_t)receiver + 2654435769;
        if (*(double *)&receiver == 0.0) {
          uint64_t v15 = 2654435769;
        }
        *(void *)(v14 + 8) = v13 ^ v15;
      }
    }
    else
    {
      unint64_t v14 = 0;
    }
    *a4 = 0xAAAAAAAAAAAAAAAALL;
    Cache = (atomic_ullong *)TCGFontCache::GetCache((TCGFontCache *)v13);
    TPurgeableCache::RetainedValueForKey(Cache, (const void *)v14, (atomic_ullong *)&v21);
    *a4 = atomic_exchange((atomic_ullong *volatile)&v21, 0);

    if (!atomic_load_explicit(a4, memory_order_acquire))
    {
      CreateFontWithVariation(this, theDict, (atomic_ullong *)&v21);

      if (atomic_load_explicit(a4, memory_order_acquire))
      {
        id v18 = (atomic_ullong *)TCGFontCache::GetCache(v17);
        unint64_t explicit = atomic_load_explicit(a4, memory_order_acquire);
        uint64_t v20 = (void *)atomic_load_explicit(v18, memory_order_acquire);
        if (explicit) {
          [v20 setObject:explicit forKey:v14];
        }
        else {
          [v20 removeObjectForKey:v14];
        }
      }
    }
  }
  else
  {
    *a4 = 0;
  }
}

void TCGFontCache::CopyFont(TCGFontCache *this@<X0>, const __CFString *a2@<X1>, const __CFString *a3@<X2>, atomic_ullong *a4@<X8>)
{
  if (this)
  {
    *a4 = 0xAAAAAAAAAAAAAAAALL;
    Cache = (atomic_ullong *)TCGFontCache::GetCache(this);
    TPurgeableCache::RetainedValueForKey(Cache, this, (atomic_ullong *)&v14);
    *a4 = atomic_exchange((atomic_ullong *volatile)&v14, 0);

    if (!atomic_load_explicit(a4, memory_order_acquire))
    {
      CreateFontWithFontURL(this, a2, a3, (atomic_ullong *)&v14);

      if (atomic_load_explicit(a4, memory_order_acquire))
      {
        CFTypeID v11 = (atomic_ullong *)TCGFontCache::GetCache(v10);
        unint64_t explicit = atomic_load_explicit(a4, memory_order_acquire);
        unint64_t v13 = (void *)atomic_load_explicit(v11, memory_order_acquire);
        if (explicit) {
          [v13 setObject:explicit forKey:this];
        }
        else {
          [v13 removeObjectForKey:this];
        }
      }
    }
  }
  else
  {
    *a4 = 0;
  }
}

unint64_t TCGFontCache::GetCache(TCGFontCache *this)
{
  unint64_t explicit = atomic_load_explicit(&TCGFontCache::sSharedCache, memory_order_acquire);
  if (!explicit) {
    operator new();
  }
  return explicit;
}

void TPurgeableCache::RetainedValueForKey(atomic_ullong *this@<X0>, const void *a2@<X1>, atomic_ullong *a3@<X8>)
{
  *a3 = 0;
  id v6 = (void *)MEMORY[0x185327A40]();
  TCFRef<__CTFont const*>::Retain(a3, (id)objc_msgSend((id)atomic_load_explicit(this, memory_order_acquire), "objectForKey:", a2));
}

void CreateFontWithVariation(CGFont *a1@<X0>, const __CFDictionary *a2@<X1>, atomic_ullong *a3@<X8>)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  *a3 = (atomic_ullong)a1;
  if (a2)
  {
    unint64_t Count = CFDictionaryGetCount(a2);
    int64_t v6 = Count;
    unint64_t v24 = Count;
    if (Count >> 60) {
      size_t v7 = -1;
    }
    else {
      size_t v7 = 16 * Count;
    }
    long long v8 = (char *)operator new[](v7, MEMORY[0x1E4FBA2D0]);
    *(void *)&long long v9 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v48[14] = v9;
    v48[13] = v9;
    v48[12] = v9;
    v48[11] = v9;
    v48[10] = v9;
    v48[9] = v9;
    v48[8] = v9;
    v48[7] = v9;
    v48[6] = v9;
    void v48[5] = v9;
    void v48[4] = v9;
    v48[3] = v9;
    v48[2] = v9;
    v48[1] = v9;
    v48[0] = v9;
    id keys = 0;
    uint64_t v46 = 0;
    uint64_t v47 = 0;
    double v49 = v48;
    if (v6)
    {
      std::vector<long,TInlineBufferAllocator<long,30ul>>::__vallocate[abi:nn180100](&keys, v6);
      CFNumberRef v10 = (char *)v46;
      bzero(v46, 8 * v6);
      uint64_t v46 = &v10[8 * v6];
      *(void *)&long long v11 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long v43 = v11;
      long long v42 = v11;
      long long v41 = v11;
      long long v40 = v11;
      long long v39 = v11;
      long long v38 = v11;
      long long v37 = v11;
      long long v36 = v11;
      long long v35 = v11;
      long long v34 = v11;
      long long v33 = v11;
      long long v32 = v11;
      long long v31 = v11;
      long long v30 = v11;
      long long v29 = v11;
      unint64_t v27 = 0;
      uint64_t v28 = 0;
      id values = 0;
      uint64_t v44 = &v29;
      std::vector<long,TInlineBufferAllocator<long,30ul>>::__vallocate[abi:nn180100](&values, v6);
      id v12 = (char *)v27;
      bzero(v27, 8 * v6);
      unint64_t v27 = &v12[8 * v6];
      CFDictionaryGetKeysAndValues(a2, (const void **)keys, (const void **)values);
      if (v6 < 1) {
        goto LABEL_17;
      }
      uint64_t v13 = 0;
      id v14 = v8;
      while (1)
      {
        uint64_t v15 = keys[v13];
        id v16 = values[v13];
        CFTypeID v17 = CFGetTypeID(v15);
        if (v17 != CFNumberGetTypeID()) {
          break;
        }
        CFTypeID v18 = CFGetTypeID(v16);
        if (v18 != CFNumberGetTypeID()) {
          break;
        }
        CFNumberGetValue((CFNumberRef)v15, kCFNumberIntType, v14);
        CFNumberGetValue((CFNumberRef)v16, kCFNumberDoubleType, v14 + 8);
        ++v13;
        v14 += 16;
        if (v6 == v13) {
          goto LABEL_17;
        }
      }
      p_id values = 0;
      uint64_t VariationAxes = CGFontGetVariationAxes();
      CreateGraphicsVariationFromDict(a2, &v24, VariationAxes, 0, &v23);
      uint64_t v20 = v23;
      id v23 = 0;
      if (v8)
      {
        MEMORY[0x1853275A0](v8, 0x1000C80F7F8B94BLL);
        objc_super v21 = v23;
        id v23 = 0;
        if (v21) {
          MEMORY[0x1853275A0](v21, 0x1000C80F7F8B94BLL);
        }
      }
      long long v8 = v20;
      if (v24)
      {
LABEL_17:
        unint64_t v22 = CGFontCreateWithVariations();
        if (v22) {
      }
        }
    }
    else
    {
      long long v43 = v9;
      long long v42 = v9;
      long long v41 = v9;
      long long v40 = v9;
      long long v39 = v9;
      long long v38 = v9;
      long long v37 = v9;
      long long v36 = v9;
      long long v35 = v9;
      long long v34 = v9;
      long long v33 = v9;
      long long v32 = v9;
      long long v31 = v9;
      long long v30 = v9;
      long long v29 = v9;
      unint64_t v27 = 0;
      uint64_t v28 = 0;
      id values = 0;
      uint64_t v44 = &v29;
      CFDictionaryGetKeysAndValues(a2, 0, 0);
    }
    p_id values = &values;
    std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&p_values);
    id values = (void **)&keys;
    std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](&values);
    if (v8) {
      MEMORY[0x1853275A0](v8, 0x1000C80F7F8B94BLL);
    }
  }
}

void CreateFontWithFontURL(const __CFURL *a1@<X0>, const __CFString *a2@<X1>, const __CFString *a3@<X2>, atomic_ullong *a4@<X8>)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  *a4 = 0;
  if (!a2 || !a3)
  {
    id FontsWithURL = (id)CGFontCreateFontsWithURL();
    size_t v7 = (void *)atomic_exchange((atomic_ullong *volatile)&FontsWithURL, 0);

    CFArrayRef v8 = v7;
    CFArrayRef v9 = v8;
    if (v8)
    {
      CFIndex Count = CFArrayGetCount(v8);

      if (Count < 1)
      {
LABEL_11:
        int64_t v6 = v7;
        goto LABEL_12;
      }
      CFArrayRef v11 = v7;
      CFArrayRef v9 = v11;
      if (v11) {
        CFURLRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(v11, 0);
      }
      else {
        CFURLRef ValueAtIndex = 0;
      }
      TCFRef<__CTFont const*>::Retain(a4, ValueAtIndex);
    }

    goto LABEL_11;
  }
  int64_t v6 = (void *)atomic_exchange(a4, CGFontCreateWithPathAndName());
LABEL_12:

  unint64_t explicit = atomic_load_explicit(a4, memory_order_acquire);
  if (a1)
  {
    if (!explicit)
    {
      CFIndex v14 = CFURLGetBytes(a1, 0, 0);
      if (v14 != -1 && v14 <= 383)
      {
        *(void *)&long long v15 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v24[0] = v15;
        v24[1] = v15;
        int64_t v16 = (int64_t)v24;
        unint64_t v22 = 0;
        id v23 = 0;
        id FontsWithURL = 0;
        int v25 = (char *)v24;
        if (v14 <= -2) {
          abort();
        }
        size_t v17 = v14 + 1;
        if (v14 <= 29) {
          int v25 = (char *)&FontsWithURL + v14 + 25;
        }
        else {
          int64_t v16 = (int64_t)operator new(v14 + 1);
        }
        id FontsWithURL = (id)v16;
        id v23 = (char *)(v16 + v17);
        bzero((void *)v16, v17);
        unint64_t v22 = (char *)(v16 + v17);
        CFIndex v18 = CFURLGetBytes(a1, (UInt8 *)v16, v16 + v17 + ~v16);
        *((unsigned char *)FontsWithURL + v18) = 0;
        CFIndex location = CFURLGetByteRangeForComponent(a1, kCFURLComponentNetLocation, 0).location;
        id p_FontsWithURL = 0;
        if (location != -1 && sscanf((const char *)FontsWithURL + location, "iNmEmOrYcGfOnT_%p", &p_FontsWithURL) == 1) {
          TCFRef<__CTFont const*>::Retain(a4, p_FontsWithURL);
        }
        id p_FontsWithURL = &FontsWithURL;
        std::vector<char,TInlineBufferAllocator<char,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&p_FontsWithURL);
      }
    }
  }
}

void TBaseFont::TBaseFont(TBaseFont *this, id a2, __CFString *a3, __CFString *a4)
{
  *((_DWORD *)this + 2) = 0;
  *(void *)this = &unk_1ED05F4D8;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((void *)this + 10) = a2;
  *((void *)this + 11) = a3;
  *((void *)this + 12) = a4;
  *((void *)this + 13) = 0;
  *((_DWORD *)this + 28) = 0;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 164) = 0u;
  *(void *)((char *)this + 180) = 0x3000000010000000;
  *((_OWORD *)this + 16) = 0u;
  *((_OWORD *)this + 17) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((void *)this + 29) = 0;
  *((void *)this + 30) = 0;
  size_t v7 = (_OWORD *)MEMORY[0x1E4F1DAD8];
  CFArrayRef v8 = (_OWORD *)MEMORY[0x1E4F1DB28];
  *((_DWORD *)this + 62) = 0;
  long long v9 = v8[1];
  *((_OWORD *)this + 19) = *v8;
  *((_OWORD *)this + 20) = v9;
  *((_OWORD *)this + 18) = *v7;
  *((unsigned char *)this + 336) = 0;
  *(_OWORD *)((char *)this + 344) = 0u;
  *(_OWORD *)((char *)this + 360) = 0u;
  *(_OWORD *)((char *)this + 376) = 0u;
  *((_DWORD *)this + 98) = 1065353216;
  *((_OWORD *)this + 25) = 0u;
  *((_OWORD *)this + 26) = 0u;
  *((_DWORD *)this + 108) = 1065353216;
  *((_WORD *)this + 220) = -1;
  *(void *)((char *)this + 460) = 0;
  *((_DWORD *)this + 117) = 0;
  *(void *)((char *)this + 444) = 0;
  *(void *)((char *)this + 452) = 0;
  *((void *)this + 60) = (char *)this + 472;
  *((void *)this + 61) = 0;
  *((void *)this + 62) = 0;
  *((void *)this + 63) = 0;
  *((void *)this + 68) = (char *)this + 512;
  *(_OWORD *)((char *)this + 568) = 0u;
  *(_OWORD *)((char *)this + 584) = 0u;
  *(_OWORD *)((char *)this + 552) = 0u;
  TBaseFont::Init((atomic_ullong *)this, 0);
}

void TCFBase_NEW<CTFontDescriptor,TBaseFont const*>(void *a1, uint64_t *a2)
{
  uint64_t v4 = TCFBase<TDescriptor>::Allocate(96);
  if (v4)
  {
    uint64_t v5 = *a2;
    *(void *)(v4 + 16) = 0;
    *(void *)(v4 + 24) = TDescriptor::Hash;
    *(void *)(v4 + 32) = 0;
    *(void *)(v4 + 40) = v4 + 48;
    *(void *)(v4 + 48) = &unk_1ED05D778;
    *(void *)(v4 + 56) = 0;
    *(_DWORD *)(v4 + 64) = 0x80000000;
    *(void *)(v4 + 72) = 0;
    if (v5) {
      atomic_fetch_add_explicit((atomic_uint *volatile)(v5 + 8), 1u, memory_order_relaxed);
    }
    *(void *)(v4 + 80) = v5;
    *(void *)(v4 + 88) = 0;
    id v6 = (id)v4;
    *a1 = atomic_exchange((atomic_ullong *volatile)&v6, 0);
  }
  else
  {
    *a1 = 0;
  }
}

void TDescriptorSource::PurgeFromCaches(TDescriptorSource *this, const __CFURL *a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  TTypesetter::PurgeAttributesCache(this);
  if (a2)
  {
    memset(__b, 170, sizeof(__b));
    uint64_t v4 = CFURLGetFileSystemRepresentation(a2, 1u, __b, 1025);
    if (v4) {
      uint64_t v4 = FPFontPurgeCaches();
    }
    objc_msgSend((id)atomic_load_explicit((atomic_ullong *volatile)TCGFontCache::GetCache((TCGFontCache *)v4), memory_order_acquire), "removeObjectForKey:", a2);
    objc_msgSend((id)atomic_load_explicit(*(atomic_ullong *volatile *)this, memory_order_acquire), "removeObjectForKey:", a2);
  }
  else
  {
    FPFontPurgeCaches();
    unint64_t explicit = (atomic_ullong *)atomic_load_explicit(&TCGFontCache::sSharedCache, memory_order_acquire);
    if (explicit) {
      objc_msgSend((id)atomic_load_explicit(explicit, memory_order_acquire), "removeAllObjects");
    }
    TDescriptorSource::PurgeFontFallbacksCache((TDescriptorSource *)objc_msgSend((id)atomic_load_explicit(*(atomic_ullong *volatile *)this, memory_order_acquire), "removeAllObjects"));
    TDescriptorSource::PurgeSplicedFontStash(v6);
  }
}

void TTypesetter::PurgeAttributesCache(TTypesetter *this)
{
  uint64_t v1 = SetThreadSpecificData(0, 0, 0);
  TTypesetter::DestroyAttributesCache((id *)v1, v2);
  uint64_t v3 = (void *)atomic_exchange(&sPreviousSecondaryScaleFontsAndRecipe, 0);
}

id *TTypesetter::DestroyAttributesCache(id *this, void *a2)
{
  if (this)
  {
    CFDictionaryRef v2 = this;
    TAttributes::~TAttributes((TAttributes *)(this + 1));

    JUMPOUT(0x1853275C0);
  }
  return this;
}

void TComponentFont::~TComponentFont(void **this)
{
  *this = &unk_1ED05DFF8;
  free(this[91]);
  CFDictionaryRef v2 = this[92];
  if (v2) {
    MEMORY[0x1853275C0](v2, 0x1000C4089CA3EB1);
  }

  TBaseFont::~TBaseFont((TBaseFont *)this);
}

{
  uint64_t vars8;

  TComponentFont::~TComponentFont(this);

  JUMPOUT(0x1853275C0);
}

void GetBaseCGFont(atomic_ullong *a1@<X0>, const __CFDictionary *a2@<X1>, atomic_ullong *a3@<X8>)
{
  if ((*(unsigned int (**)(atomic_ullong *))(*a1 + 16))(a1) != 1414088260
    || !(*(unsigned int (**)(atomic_ullong *))(*a1 + 456))(a1))
  {
    uint64_t v8 = (CGFont *)(*(uint64_t (**)(atomic_ullong *))(*a1 + 568))(a1);
    goto LABEL_8;
  }
  unint64_t explicit = (CGFont *)atomic_load_explicit(a1 + 80, memory_order_acquire);
  if (!a2) {
    goto LABEL_13;
  }
  int v7 = CFDictionaryContainsKey(a2, &unk_1ED082E60);
  if (CFDictionaryGetCount(a2) <= 1 && v7)
  {
    uint64_t v8 = explicit;
LABEL_8:
    *a3 = (atomic_ullong)v8;
    return;
  }
  if (v7)
  {
    MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, a2);
    CFDictionaryRemoveValue(MutableCopy, &unk_1ED082E60);
    CreateFontWithVariation(explicit, MutableCopy, a3);
  }
  else
  {
LABEL_13:
    CreateFontWithVariation(explicit, a2, a3);
  }
}

const TBaseFont *GetTenuousComponentFont(const TBaseFont *a1)
{
  unint64_t explicit = a1;
  if (!a1 || (*(unsigned int (**)(const TBaseFont *))(*(void *)a1 + 16))(a1) != 1414809156)
  {
    if ((*(unsigned int (**)(const TBaseFont *))(*(void *)explicit + 16))(explicit) == 1414743620)
    {
      uint64_t v2 = *(void *)(*((void *)explicit + 76) + 40);
      if ((*(_DWORD *)(v2 + 16) & 0x80000000) == 0) {
        TDescriptor::InitBaseFont((TDescriptor *)v2, 0, 0.0);
      }
      unint64_t explicit = (const TBaseFont *)atomic_load_explicit((atomic_ullong *volatile)(v2 + 32), memory_order_acquire);
      if (explicit
        && (*(unsigned int (**)(const TBaseFont *))(*(void *)explicit + 16))(explicit) != 1414809156)
      {
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  return explicit;
}

uint64_t TInstanceFont::GetType(TInstanceFont *this)
{
  return 1414088260;
}

BOOL TInstanceFont::HasDerivedOpticalSize(atomic_ullong *this)
{
  return atomic_load_explicit(this + 80, memory_order_acquire) != 0;
}

uint64_t TBaseFont::GetSplicedDict(TBaseFont *this)
{
  return 0;
}

uint64_t TPerThreadLRUCache<TRequestCacheNode,(ThreadSpecificKey)3,16ul>::DestroyCache(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    for (uint64_t i = 0; i != -768; i -= 48)
    {
      *(void *)(v1 + i + 744) = &unk_1ED05E6A0;
    }
    JUMPOUT(0x1853275C0);
  }
  return result;
}

void TDescriptorSource::PurgeFromSplicedFonts(TDescriptorSource *this, const void *a2)
{
  os_unfair_lock_lock_with_options();
  if (TDescriptorSource::sSplicedFonts) {
    CFDictionaryRemoveValue((CFMutableDictionaryRef)TDescriptorSource::sSplicedFonts, a2);
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&TDescriptorSource::sSplicedFontsLock);
}

void TDescriptorSource::GetCache(void)::{lambda(void *)#1}::__invoke()
{
}

void CreateVariationDictFromGraphicsFont(void *a1@<X8>)
{
  *a1 = 0;
}

BOOL std::equal_to<anonymous namespace'::TMissedRequest>::operator()[abi:nn180100](atomic_ullong *a1, atomic_ullong *a2)
{
  if (a1[1] != a2[1] || a1[2] != a2[2]) {
    return 0;
  }
  unint64_t explicit = (const void *)atomic_load_explicit(a1, memory_order_acquire);
  uint64_t v4 = (const void *)atomic_load_explicit(a2, memory_order_acquire);
  if (explicit == v4) {
    return 1;
  }
  BOOL result = 0;
  if (explicit)
  {
    if (v4) {
      return CFEqual(explicit, v4) != 0;
    }
  }
  return result;
}

void CTFontDescriptor::CTFontDescriptor(CTFontDescriptor *this, CGFont *a2, const __CFDictionary *a3)
{
  *((void *)this + 2) = 0;
  *((void *)this + 3) = TDescriptor::Hash;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = (char *)this + 48;
  operator new();
}

void TInstanceFont::TInstanceFont(TInstanceFont *this, CGFont *a2, const __CFDictionary *a3)
{
  CreateCopyOfFontWithVariation(a2, a3, (CGFont **)&v5);
  TBaseFont::TBaseFont(this, (id)atomic_load_explicit((atomic_ullong *volatile)&v5, memory_order_acquire));

  *(void *)this = &unk_1ED05DBE0;
  *((unsigned char *)this + 624) = 0;
  *(_OWORD *)((char *)this + 600) = 0u;
  *((unsigned char *)this + 616) = 0;
  *(_OWORD *)((char *)this + 632) = 0u;
  TInstanceFont::InitWithVariation((atomic_ullong *)this, (CGFont *)atomic_load_explicit((atomic_ullong *volatile)this + 13, memory_order_acquire), a3, 0);
}

void CreateGraphicsVariationFromDict(const __CFDictionary *a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  if (a1)
  {
    unint64_t Count = CFDictionaryGetCount(a1);
    context[0] = a3;
    context[1] = a4;
    context[2] = 0;
    unint64_t v15 = Count;
    if (Count >> 60) {
      size_t v11 = -1;
    }
    else {
      size_t v11 = 16 * Count;
    }
    int64_t v16 = operator new[](v11, MEMORY[0x1E4FBA2D0]);
    CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)CGFontVariationFromDictCallback, context);
    unint64_t v12 = v15;
    uint64_t v13 = v16;
  }
  else
  {
    unint64_t v12 = 0;
    uint64_t v13 = 0;
  }
  *a2 = v12;
  *a5 = v13;
}

uint64_t std::vector<std::unique_ptr<unsigned short const[]>,TInlineBufferAllocator<std::unique_ptr<unsigned short const[]>,4ul>>::__base_destruct_at_end[abi:nn180100](uint64_t result, void *a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void **)(result + 8);
  while (v4 != a2)
  {
    uint64_t v5 = *--v4;
    BOOL result = v5;
    void *v4 = 0;
    if (v5) {
      BOOL result = MEMORY[0x1853275A0](result, 0x1000C80BDFB0063);
    }
  }
  *(void *)(v3 + 8) = a2;
  return result;
}

CGFloat TComponentFont::GetMaxAdvance(TComponentFont *this, const CGAffineTransform *a2, int a3)
{
  uint64_t v4 = (atomic_ullong *)((char *)this + 720);
  Maxdouble Advance = TBaseFont::GetMaxAdvance(this, a2, a3);

  return TSplicedFontDict::GetMaxAdvance(v4, MaxAdvance, a2);
}

CGFloat TBaseFont::GetMaxAdvance(TBaseFont *this, const CGAffineTransform *a2, int a3)
{
  TBaseFont::GetInitializedGraphicsFont(this);
  if (a3) {
    uint64_t VMetrics = CGFontGetVMetrics();
  }
  else {
    uint64_t VMetrics = CGFontGetHMetrics();
  }
  if (VMetrics) {
    return a2->tx + a2->c * 0.0 + a2->a * (double)*(int *)(VMetrics + 12);
  }
  else {
    return 0.0;
  }
}

CTFontDescriptorRef CTFontDescriptorCreateMatchingFontDescriptor(CTFontDescriptorRef descriptor, CFSetRef mandatoryAttributes)
{
  if (!descriptor) {
    return 0;
  }
  TDescriptor::CreateMatchingDescriptor(*((TDescriptor **)descriptor + 5), mandatoryAttributes, 0.0, 0, (atomic_ullong *)&v4);
  uint64_t v2 = (const __CTFontDescriptor *)atomic_exchange((atomic_ullong *volatile)&v4, 0);

  return v2;
}

void CTRunGetGlyphs(CTRunRef run, CFRange range, CGGlyph *buffer)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (run && buffer)
  {
    uint64_t v3 = *((void *)run + 5);
    if ((*(unsigned char *)(v3 + 225) & 8) != 0)
    {
      uint64_t v7 = *(void *)(v3 + 208);
      uint64_t v8 = *(void *)(*(void *)(v3 + 216) + 16) + 2 * *(void *)(v3 + 200);
      uint64_t v9 = *(void *)(v3 + 264);
      v16[0] = &unk_1ED05FC00;
      v16[1] = buffer;
      v16[2] = v8;
      size_t v17 = v16;
      if (range.length) {
        CFIndex length = range.length;
      }
      else {
        CFIndex length = v7;
      }
      uint64_t v11 = 0;
      if (v7 >= 1 && range.location >= 1)
      {
        CFIndex v13 = 0;
        do
        {
          if (v9 == v11 || *(__int16 *)(v8 + 2 * v11) != -1) {
            ++v13;
          }
          ++v11;
        }
        while (v11 < v7 && v13 < range.location);
      }
      if (v11 < v7 && length >= 1)
      {
        uint64_t v15 = 0;
        do
        {
          if (v9 == v11 || *(unsigned __int16 *)(v8 + 2 * v11) != 0xFFFF) {
            std::function<void ()(long,long)>::operator()((uint64_t)v17, v11, v15++);
          }
          ++v11;
        }
        while (v11 < v7 && v15 < length);
      }
      std::__function::__value_func<void ()(long,long)>::~__value_func[abi:nn180100](v16);
    }
    else if ((range.location & 0x8000000000000000) == 0)
    {
      CFIndex v4 = *(void *)(v3 + 208);
      if (range.location + range.length <= v4)
      {
        CFIndex v5 = v4 - range.location;
        if (range.length) {
          CFIndex v5 = range.length;
        }
        if (v5)
        {
          id v6 = (const void *)(*(void *)(*(void *)(v3 + 216) + 16)
                            + 2 * *(void *)(v3 + 200)
                            + 2 * range.location);
          memmove(buffer, v6, 2 * v5);
        }
      }
    }
  }
}

uint64_t GetInternalKey(void)::$_0::__invoke()
{
  return MEMORY[0x1F40CDA50](95, DestroyTable);
}

const __CTFont *CTFontCreateCopyOfSystemUIFontWithGrade(atomic_ullong **a1, uint64_t a2)
{
  CopyWithCFDictionaryRef Attributes = (const __CTFont *)a1;
  v10[1] = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (TFont::IsSystemUIFontAndForShaping(a1[5], &v6))
    {
      uint64_t v9 = @"NSCTFontTraitsAttribute";
      uint64_t v7 = @"NSCTFontGradeTrait";
      uint64_t v8 = [NSNumber numberWithInt:a2];
      v10[0] = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v8 forKeys:&v7 count:1];
      CFIndex v4 = CTFontDescriptorCreateWithAttributes((CFDictionaryRef)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v10 forKeys:&v9 count:1]);
      CopyWithCFDictionaryRef Attributes = CTFontCreateCopyWithAttributes(CopyWithAttributes, 0.0, 0, v4);
    }
    else
    {
      return 0;
    }
  }
  return CopyWithAttributes;
}

void MakeSpliceDescriptor(TDescriptorSource *a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X2>, __CFString *a4@<X3>, const __CFNumber *a5@<X4>, const __CFNumber *a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, void *a9@<X8>, int a10, const __CFNumber *a11, const __CFNumber *a12, uint64_t a13, const void *a14, void *a15, uint64_t a16)
{
  uint64_t v281 = *MEMORY[0x1E4F143B8];
  v280.unint64_t isa = (void *)0xAAAAAAAAAAAAAAAALL;
  if ((TDescriptorSource::StashIndexForFontName(a1, &v280, a3) & 1) == 0)
  {
    *a9 = 0;
    return;
  }
  unint64_t v270 = a2;
  CFNumberRef number = a6;
  uint64_t v24 = (uint64_t)a12;
  CFAllocatorRef v25 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  memcpy(__dst, &__const__ZN17TDescriptorSource16IsValidTextStyleEPK10__CFString_overrideSpec, sizeof(__dst));
  __dst[5] = 3;
  if (a12)
  {
    valuePtr.unint64_t isa = (void *)-1;
    CFNumberRef v26 = a12;
LABEL_7:
    CFNumberGetValue(v26, kCFNumberDoubleType, &valuePtr);
    int v264 = 0;
    double v27 = *(double *)&valuePtr.isa;
    goto LABEL_8;
  }
  if (a11)
  {
    valuePtr.unint64_t isa = (void *)-1;
    CFNumberRef v26 = a11;
    goto LABEL_7;
  }
  int v264 = 1;
  double v27 = NAN;
LABEL_8:
  v266 = a9;
  if (a7) {
    CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"grade", (const void *)[NSNumber numberWithUnsignedInt:a7]);
  }
  unint64_t isa = (unint64_t)v280.isa;
  Textuint64_t Style = FindTextStyle((unint64_t)v280.isa, (uint64_t)__dst, a8);
  v269 = (__CFString *)a3;
  if (!TextStyle)
  {
    unint64_t v34 = isa - 156;
    if (isa < 0x9C)
    {
      int v35 = 0;
      CFStringRef v36 = v269;
LABEL_153:
      uint64_t v50 = v266;
      goto LABEL_154;
    }
    if (v34 <= 0x15)
    {
      unsigned int v262 = a7;
      long long v42 = &kOtherSpec[10 * v34];
      long long v43 = (TDescriptorSource *)*v42;
      valuePtr.unint64_t isa = 0;
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"NSCTFontUIFontDesignTrait", @"NSCTFontUIFontDesignDefault");
      unsigned int v272 = v43;
      uint64_t v44 = (__CFString *)TDescriptorSource::UIFontNameForUIType(v43);
      *(void *)v277 = 0xAAAAAAAAAAAAAAAALL;
      int v45 = v42[1];
      int v46 = v42[2];
      makeStyleName((atomic_ullong *)v277, v45, v46, (__CFString *)valuePtr.isa);
      addNames(@".AppleSystemUIFont", (__CFString *)atomic_load_explicit((atomic_ullong *volatile)v277, memory_order_acquire), v44, (atomic_ullong *)&Mutable);
      addMetrics(v45, v46, 0, @"width", number, (atomic_ullong *)&Mutable);
      unsigned int v276 = 0;
      LocalizedTrimSetKedouble y = GetLocalizedTrimSetKey(v269, &v276);
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"legibilityWeight", (const void *)[NSNumber numberWithLong:a13]);
      char v48 = (const void *)*MEMORY[0x1E4F1CFD0];
      if ((const void *)*MEMORY[0x1E4F1CFD0] == a14) {
        CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"ignoreLegibilityWeight", a14);
      }
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"hasVariations", v48);
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"hasOpticalSizeAxis", v48);
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"languagePropertiesCacheKey", @".AppleSystemUIFont");
      if (@"NSCTFontUIFontDesignSoft" == a4
        || a4 && @"NSCTFontUIFontDesignSoft" && CFEqual(a4, @"NSCTFontUIFontDesignSoft"))
      {
        id v273 = CFDictionaryCreateMutable(v25, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        unsigned int v49 = kOtherSpec[10 * v34 + 4];
        if (a13 == 1)
        {
          uint64_t v50 = v266;
          CFStringRef v36 = v269;
          if (v49 <= 0x10 && ((0x1FEFFu >> v49) & 1) != 0) {
            unsigned int v49 = dword_184BA17A4[v49];
          }
        }
        else
        {
          uint64_t v50 = v266;
          CFStringRef v36 = v269;
        }
        if (v272 <= 0x8A)
        {
          unsigned int v110 = v49 % 9;
          if (v49 % 9 <= 2)
          {
            DetermineLanguageSpecificParameters();
            if (v110 < dword_1EB2CDB30) {
              unsigned int v49 = v49 - v110 + dword_1EB2CDB30;
            }
          }
        }
        setNameWithGrade(*(const __CFString **)(qword_1EB2CD650 + 8 * (v49 % 9)), v262, (atomic_ullong *)&v273);
        if (v276 == 64 || v276 == 32) {
          CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v273, memory_order_acquire), @"UnicodeCharSetTrim", LocalizedTrimSetKey);
        }
        v280.CFIndex length = atomic_load_explicit((atomic_ullong *volatile)&v273, memory_order_acquire);
        CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"Components", (const void *)[MEMORY[0x1E4F1C978] arrayWithObjects:&v280.length count:1]);
        CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"NSCTFontUIFontDesignTrait", a4);
      }
      else
      {
        unsigned int v102 = kOtherSpec[10 * v34 + 4];
        if (a13 == 1)
        {
          uint64_t v103 = v262;
          unsigned int v104 = v272;
          if (v102 <= 0x10 && ((0x1FEFFu >> v102) & 1) != 0) {
            unsigned int v102 = dword_184BA17A4[v102];
          }
        }
        else
        {
          uint64_t v103 = v262;
          unsigned int v104 = v272;
        }
        if (v104 <= 0x8A)
        {
          unsigned int v116 = v102 % 9;
          if (v102 % 9 <= 2)
          {
            DetermineLanguageSpecificParameters();
            if (v116 < dword_1EB2CDB30) {
              unsigned int v102 = v102 - v116 + dword_1EB2CDB30;
            }
          }
        }
        if (v103)
        {
          BOOL v117 = LocalizedTrimSetKey;
          if (v102 == 17 || v102 == 8) {
            uint64_t v103 = 0;
          }
        }
        else
        {
          BOOL v117 = LocalizedTrimSetKey;
        }
        unsigned int v118 = v102;
        uint64_t v119 = SFFontNameForWidth(v102, number, &valuePtr);
        AddVariationInfoWithGrade((atomic_ullong *)&Mutable, v119, v103);
        long long v120 = CFArrayCreateMutable(v25, 0, MEMORY[0x1E4F1D510]);
        uint64_t v121 = &kOtherSpec[10 * v34 + 6];
        if (v121 != v42 + 10)
        {
          for (uint64_t i = 0; i != 4; i += 2)
          {
            double v123 = *(double *)&v121[i];
            id v273 = CFDictionaryCreateMutable(v25, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            setOpticalSizeComponent(v119, (uint64_t)&kFont2X[5 * v118], v272, 0, v103, v117, (atomic_ullong *)&v273, 0, v123 * 0.5, 0.0, 0.0, 0.0, 0);
            CFArrayInsertValueAtIndex(v120, 0, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v273, memory_order_acquire));
          }
        }
        CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"Components", v120);

        uint64_t v50 = v266;
        uint64_t v24 = (uint64_t)a12;
        CFStringRef v36 = v269;
      }
      unsigned int v93 = *(void **)v277;
      goto LABEL_145;
    }
    unint64_t v81 = isa - 178;
    if (isa - 178 <= 0x13)
    {
      uint64_t v82 = (TDescriptorSource *)kOtherSpecCompact[v81];
      long long v83 = &kOtherSpec[10 * v81];
      long long v84 = *((_OWORD *)v83 + 1);
      *(_OWORD *)&valuePtr.unint64_t isa = *(_OWORD *)v83;
      *(_OWORD *)&valuePtr.datCGFloat a = v84;
      unint64_t v275 = *((void *)v83 + 4);
      LODWORD(valuePtr.isa) = v82;
      addPosingWithWeightAndSlant(v82, SHIDWORD(valuePtr.isa), valuePtr.info, SHIDWORD(valuePtr.info), @".AppleSystemUIFontCompact", @"NSCTFontUIFontDesignCompact", (atomic_ullong *)&Mutable, 0, 0);
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"legibilityWeight", (const void *)[NSNumber numberWithLong:a13]);
      __int16 v85 = (const void *)*MEMORY[0x1E4F1CFD0];
      CFStringRef v36 = v269;
      if ((const void *)*MEMORY[0x1E4F1CFD0] == a14) {
        CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"ignoreLegibilityWeight", a14);
      }
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"hasVariations", v85);
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"hasOpticalSizeAxis", v85);
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"languagePropertiesCacheKey", @".AppleSystemUIFontCompact");
      uint64_t v86 = &kFont2XCompact;
      p___CFString valuePtr = (unsigned int *)&valuePtr;
      int v88 = a7;
      BOOL v89 = 0;
      uint64_t v90 = a13;
      goto LABEL_137;
    }
    unint64_t v94 = isa - 198;
    CFStringRef v36 = v269;
    if (isa - 198 <= 0x13)
    {
      unint64_t v95 = (TDescriptorSource *)kOtherSpecCore[v94];
      unsigned int v96 = &kOtherSpec[10 * v94];
      long long v97 = *((_OWORD *)v96 + 1);
      *(_OWORD *)&valuePtr.unint64_t isa = *(_OWORD *)v96;
      *(_OWORD *)&valuePtr.datCGFloat a = v97;
      unint64_t v275 = *((void *)v96 + 4);
      LODWORD(valuePtr.isa) = v95;
      addPosingWithWeightAndSlant(v95, SHIDWORD(valuePtr.isa), valuePtr.info, SHIDWORD(valuePtr.info), @".AppleSystemUIFontCore", @"NSCTFontUIFontDesignCore", (atomic_ullong *)&Mutable, @"width", a6);
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"legibilityWeight", (const void *)[NSNumber numberWithLong:a13]);
      float64x2_t v98 = (const void *)*MEMORY[0x1E4F1CFD0];
      if ((const void *)*MEMORY[0x1E4F1CFD0] == a14) {
        CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"ignoreLegibilityWeight", a14);
      }
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"hasVariations", v98);
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"hasOpticalSizeAxis", v98);
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"languagePropertiesCacheKey", @".AppleSystemUIFontCore");
      BOOL v89 = GetLocalizedTrimSetKey(v269, v277);
      uint64_t v86 = &kFont2XPro;
      p___CFString valuePtr = (unsigned int *)&valuePtr;
      int v88 = a7;
      uint64_t v90 = a13;
      CFNumberRef v91 = number;
      goto LABEL_152;
    }
    allocatorCGFloat a = v25;
    unint64_t v105 = isa - 218;
    if (isa - 218 <= 8)
    {
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"NSCTFontUIFontDesignTrait", @"NSCTFontUIFontDesignRounded");
      unint64_t v106 = (TDescriptorSource *)kSystemUIFontRoundNames[v105];
      unint64_t v109 = (const void *)TDescriptorSource::TextStyleForUIFontName(v106, v107, v108);
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"NSCTFontUIUsageAttribute", v109);
      uint64_t v50 = v266;
      unsigned int v124 = isa - 217;
      addNames(@".AppleSystemUIFontRounded", off_1E528F438[v105], (__CFString *)v106, (atomic_ullong *)&Mutable);
      addMetrics(isa - 217, 0, 0, 0, 0, (atomic_ullong *)&Mutable);
      if (a13 == 1 && v105 <= 7)
      {
        if (((1 << (isa + 38)) & 0x78) != 0) {
          unsigned int v124 = isa - 216;
        }
      }
      else
      {
        unsigned int v124 = isa - 218;
      }
      if (v124 >= 9) {
        unsigned int v125 = v124 - 9;
      }
      else {
        unsigned int v125 = v124;
      }
      if (v125 <= 2)
      {
        DetermineLanguageSpecificParameters();
        if (v125 < dword_1EB2CDB30) {
          unsigned int v124 = v124 - v125 + dword_1EB2CDB30;
        }
      }
      uint64_t v126 = v124;
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"legibilityWeight", (const void *)[NSNumber numberWithLong:a13]);
      long long v127 = (const void *)*MEMORY[0x1E4F1CFD0];
      if ((const void *)*MEMORY[0x1E4F1CFD0] == a14) {
        CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"ignoreLegibilityWeight", a14);
      }
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"hasVariations", v127);
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"languagePropertiesCacheKey", @".AppleSystemUIFontRounded");
      LODWORD(valuePtr.isa) = 0;
      long long v128 = GetLocalizedTrimSetKey(v269, (unsigned int *)&valuePtr);
      uint64_t v129 = off_1EB2CD668[0];
LABEL_232:
      CFStringRef v143 = v129[v126];
      if (LODWORD(valuePtr.isa) == 64 || LODWORD(valuePtr.isa) == 32) {
        CFStringRef v145 = v128;
      }
      else {
        CFStringRef v145 = 0;
      }
      addComponentsWithNameAndTrimCharacterSet(v143, v145, (atomic_ullong *)&Mutable);
      goto LABEL_146;
    }
    unint64_t v111 = isa - 227;
    if (isa - 227 <= 8)
    {
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"NSCTFontUIFontDesignTrait", @"NSCTFontUIFontDesignCompactRounded");
      unint64_t v112 = (TDescriptorSource *)kSystemUIFontCompactRoundNames[v111];
      BOOL v115 = (const void *)TDescriptorSource::TextStyleForUIFontName(v112, v113, v114);
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"NSCTFontUIUsageAttribute", v115);
      uint64_t v50 = v266;
      unsigned int v140 = isa - 226;
      addNames(@".AppleSystemUIFontCompactRounded", off_1E528F438[v111], (__CFString *)v112, (atomic_ullong *)&Mutable);
      addMetrics(isa - 226, 0, 0, 0, 0, (atomic_ullong *)&Mutable);
      if (a13 == 1 && v111 <= 7)
      {
        if (((1 << (isa + 29)) & 0x78) != 0) {
          unsigned int v140 = isa - 225;
        }
      }
      else
      {
        unsigned int v140 = isa - 227;
      }
      if (v140 >= 9) {
        unsigned int v141 = v140 - 9;
      }
      else {
        unsigned int v141 = v140;
      }
      if (v141 <= 2)
      {
        DetermineLanguageSpecificParameters();
        if (v141 < dword_1EB2CDB30) {
          unsigned int v140 = v140 - v141 + dword_1EB2CDB30;
        }
      }
      uint64_t v126 = v140;
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"legibilityWeight", (const void *)[NSNumber numberWithLong:a13]);
      id v142 = (const void *)*MEMORY[0x1E4F1CFD0];
      if ((const void *)*MEMORY[0x1E4F1CFD0] == a14) {
        CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"ignoreLegibilityWeight", a14);
      }
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"hasVariations", v142);
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"languagePropertiesCacheKey", @".AppleSystemUIFontCompactRounded");
      LODWORD(valuePtr.isa) = 0;
      long long v128 = GetLocalizedTrimSetKey(v269, (unsigned int *)&valuePtr);
      uint64_t v129 = kFontCompactRounded;
      goto LABEL_232;
    }
    unint64_t v130 = isa - 236;
    if (isa - 236 <= 8)
    {
      uint64_t v131 = a13;
      int v132 = a7;
      int v133 = (char *)&kOtherCondensedSpec + 40 * v130;
      uint64_t v134 = (TDescriptorSource *)*(unsigned int *)v133;
      int v135 = *((_DWORD *)v133 + 1);
      makeStyleName((atomic_ullong *)&valuePtr, v135, 0, @"Condensed");
      unint64_t explicit = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&valuePtr, memory_order_acquire);
      long long v137 = (__CFString *)TDescriptorSource::UIFontNameForUIType(v134);
      addNames(@".AppleSystemUIFont", explicit, v137, (atomic_ullong *)&Mutable);

      double v138 = (const void *)[NSNumber numberWithDouble:-0.2];
      addMetrics(v135, 0, 0, @"width", v138, (atomic_ullong *)&Mutable);
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"NSCTFontProportionTrait", v138);
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"legibilityWeight", (const void *)[NSNumber numberWithLong:v131]);
      uint64_t v139 = (const void *)*MEMORY[0x1E4F1CFD0];
      if ((const void *)*MEMORY[0x1E4F1CFD0] == a14) {
        CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"ignoreLegibilityWeight", a14);
      }
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"hasVariations", v139);
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"hasOpticalSizeAxis", v139);
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"languagePropertiesCacheKey", @".AppleSystemUIFont");
      uint64_t v86 = &kFontInfoSemiCondensed;
LABEL_243:
      p___CFString valuePtr = (unsigned int *)v133;
      int v88 = v132;
      BOOL v89 = 0;
      uint64_t v90 = v131;
LABEL_137:
      CFNumberRef v91 = 0;
LABEL_152:
      addOpticalSizeComponents(p_valuePtr, (uint64_t)v86, v88, v89, v90, v91, (atomic_ullong *)&Mutable);
      int v35 = 0;
      goto LABEL_153;
    }
    unint64_t v146 = isa - 245;
    if (isa - 245 <= 8)
    {
      uint64_t v131 = a13;
      int v132 = a7;
      int v133 = (char *)&kOtherCoreCondensedSpec + 40 * v146;
      __int16 v147 = (TDescriptorSource *)*(unsigned int *)v133;
      int v148 = *((_DWORD *)v133 + 1);
      makeStyleName((atomic_ullong *)&valuePtr, v148, 0, @"Condensed");
      unint64_t v149 = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&valuePtr, memory_order_acquire);
      long long v150 = (__CFString *)TDescriptorSource::UIFontNameForUIType(v147);
      addNames(@".AppleSystemUIFontCore", v149, v150, (atomic_ullong *)&Mutable);

      long long v151 = (const void *)[NSNumber numberWithDouble:-0.2];
      addMetrics(v148, 0, 0, @"width", v151, (atomic_ullong *)&Mutable);
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"NSCTFontProportionTrait", v151);
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"legibilityWeight", (const void *)[NSNumber numberWithLong:v131]);
      CGAffineTransform v152 = (const void *)*MEMORY[0x1E4F1CFD0];
      if ((const void *)*MEMORY[0x1E4F1CFD0] == a14) {
        CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"ignoreLegibilityWeight", a14);
      }
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"hasVariations", v152);
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"hasOpticalSizeAxis", v152);
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"languagePropertiesCacheKey", @".AppleSystemUIFontCore");
      uint64_t v86 = &kFontInfoCoreSemiCondensed;
      goto LABEL_243;
    }
    unint64_t v153 = isa - 254;
    if (isa - 254 <= 0xB)
    {
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"NSCTFontUIFontDesignTrait", @"NSCTFontUIFontDesignSerif");
      __int16 v154 = (int *)((char *)&kOtherSerifSpec + 16 * v153);
      unint64_t v155 = kSystemUIFontSerifNames[v153];
      int v156 = *v154;
      int v157 = v154[1];
      makeStyleName((atomic_ullong *)&valuePtr, *v154, v157, 0);
      addNames(@".AppleSystemUIFontSerif", (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&valuePtr, memory_order_acquire), v155, (atomic_ullong *)&Mutable);
      addMetrics(v156, v157, 0, 0, 0, (atomic_ullong *)&Mutable);

      unsigned int v158 = v154[3];
      if (a13 == 1)
      {
        unint64_t v159 = 0x1E4F28000;
        uint64_t v50 = v266;
        if (isa != 265 && ((0x1FEFFu >> v158) & 1) != 0) {
          unsigned int v158 = dword_184BA17A4[v158];
        }
      }
      else
      {
        unint64_t v159 = 0x1E4F28000uLL;
        uint64_t v50 = v266;
      }
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"legibilityWeight", (const void *)objc_msgSend(*(id *)(v159 + 3792), "numberWithLong:"));
      uint64_t v169 = (const void *)*MEMORY[0x1E4F1CFD0];
      if ((const void *)*MEMORY[0x1E4F1CFD0] == a14) {
        CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"ignoreLegibilityWeight", a14);
      }
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"hasVariations", v169);
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"hasOpticalSizeAxis", v169);
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"languagePropertiesCacheKey", @".AppleSystemUIFontSerif");
      unsigned int v170 = v158 % 9;
      if (v158 % 9 <= 2)
      {
        DetermineLanguageSpecificParameters();
        if (v170 < dword_1EB2CDB30) {
          unsigned int v158 = v158 - v170 + dword_1EB2CDB30;
        }
      }
      if ((0x361Bu >> (v158 - 4))) {
        unsigned int v171 = 0;
      }
      else {
        unsigned int v171 = a7;
      }
      if (v158 - 4 <= 0xD) {
        unsigned int v172 = v171;
      }
      else {
        unsigned int v172 = a7;
      }
      if (a7) {
        uint64_t v173 = v172;
      }
      else {
        uint64_t v173 = 0;
      }
      uint64_t v174 = (const __CFString **)(&kFontSerif + 5 * v158);
      AddVariationInfoWithGrade((atomic_ullong *)&Mutable, *v174, v173);
      valuePtr.unint64_t isa = CFArrayCreateMutable(allocatora, 0, MEMORY[0x1E4F1D510]);
      insertOpticalSizeComponent(v174, 0, (isa - 13), 0, v173, (atomic_ullong *)&valuePtr, 0, 0, 12.0);
      CGAffineTransform v175 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      CGAffineTransform v176 = (const void *)atomic_load_explicit((atomic_ullong *volatile)&valuePtr, memory_order_acquire);
LABEL_296:
      CFDictionaryAddValue(v175, @"Components", v176);
      unsigned int v93 = valuePtr.isa;
      goto LABEL_145;
    }
    unint64_t v160 = isa - 266;
    if (isa - 266 <= 0xB)
    {
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"NSCTFontUIFontDesignTrait", @"NSCTFontUIFontDesignMonospaced");
      unint64_t v161 = (int *)((char *)&kOtherMonospacedSpec + 16 * v160);
      float64x2_t v162 = kSystemUIFontMonospacedNames[v160];
      int v163 = *v161;
      int v164 = v161[1];
      makeStyleName((atomic_ullong *)&valuePtr, *v161, v164, 0);
      addNames(@".AppleSystemUIFontMonospaced", (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&valuePtr, memory_order_acquire), v162, (atomic_ullong *)&Mutable);

      addMetrics(v163, v164, 0, @"isFixedPitch", @"1", (atomic_ullong *)&Mutable);
      CFMutableArrayRef v92 = CFArrayCreateMutable(allocatora, 0, MEMORY[0x1E4F1D510]);
      unsigned int v165 = v161[3];
      if (a13 == 1 && ((0x1FEFFu >> v165) & 1) != 0) {
        unsigned int v165 = dword_184BA17A4[v165];
      }
      unsigned int v166 = v165 % 9;
      if (v165 % 9 <= 2)
      {
        DetermineLanguageSpecificParameters();
        if (v166 < dword_1EB2CDB30) {
          unsigned int v165 = v165 - v166 + dword_1EB2CDB30;
        }
      }
      uint64_t v50 = v266;
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"legibilityWeight", (const void *)[NSNumber numberWithLong:a13]);
      long long v167 = (const void *)*MEMORY[0x1E4F1CFD0];
      if ((const void *)*MEMORY[0x1E4F1CFD0] == a14) {
        CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"ignoreLegibilityWeight", a14);
      }
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"hasVariations", v167);
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"languagePropertiesCacheKey", v162);
      AddVariationInfo((atomic_ullong *)&Mutable, *(&kFontMono + 5 * v165));
      addComponentsWithTrimCharacterSet((const void **)&kFontMono + 5 * v165, 0, (atomic_ullong *)&Mutable, 0);
      goto LABEL_144;
    }
    unint64_t v168 = isa - 278;
    if (isa - 278 <= 8)
    {
      uint64_t v50 = v266;
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"NSCTFontUIFontDesignTrait", @"NSCTFontUIFontDesignSoft");
      unsigned int v178 = isa - 277;
      addNames(@".AppleSystemUIFontSoft", off_1E528F438[v168], kSystemUIFontSoftNames[v168], (atomic_ullong *)&Mutable);
      addMetrics(isa - 277, 0, 0, 0, 0, (atomic_ullong *)&Mutable);
      if (a13 == 1 && v168 <= 7)
      {
        if (((1 << v168) & 0x78) != 0) {
          unsigned int v178 = isa - 276;
        }
      }
      else
      {
        unsigned int v178 = isa - 278;
      }
      if (v178 >= 9) {
        unsigned int v179 = v178 - 9;
      }
      else {
        unsigned int v179 = v178;
      }
      if (v179 <= 2)
      {
        DetermineLanguageSpecificParameters();
        if (v179 < dword_1EB2CDB30) {
          unsigned int v178 = v178 - v179 + dword_1EB2CDB30;
        }
      }
      uint64_t v180 = v178;
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"legibilityWeight", (const void *)[NSNumber numberWithLong:a13]);
      if ((const void *)*MEMORY[0x1E4F1CFD0] == a14) {
        CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"ignoreLegibilityWeight", a14);
      }
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"languagePropertiesCacheKey", @".AppleSystemUIFontSoft");
      v277[0] = 0;
      CFStringRef v36 = v269;
      CGAffineTransform v181 = GetLocalizedTrimSetKey(v269, v277);
      valuePtr.unint64_t isa = CFDictionaryCreateMutable(allocatora, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      setNameWithGrade(*(const __CFString **)(qword_1EB2CD650 + 8 * v180), a7, (atomic_ullong *)&valuePtr);
      if (v277[0] == 64 || v277[0] == 32) {
        CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&valuePtr, memory_order_acquire), @"UnicodeCharSetTrim", v181);
      }
      v280.datCGFloat a = (char *)atomic_load_explicit((atomic_ullong *volatile)&valuePtr, memory_order_acquire);
      CGAffineTransform v176 = (const void *)[MEMORY[0x1E4F1C978] arrayWithObjects:&v280.data count:1];
      CGAffineTransform v175 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      goto LABEL_296;
    }
    uint64_t v50 = v266;
    unint64_t v177 = isa - 287;
    if (isa - 287 <= 8)
    {
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"NSCTFontUIFontDesignTrait", @"NSCTFontUIFontDesignCompactSoft");
      unsigned int v192 = isa - 286;
      addNames(@".AppleSystemUIFontCompactSoft", off_1E528F438[v177], kSystemUIFontCompactSoftNames[v177], (atomic_ullong *)&Mutable);
      addMetrics(isa - 286, 0, 0, 0, 0, (atomic_ullong *)&Mutable);
      if (a13 == 1 && v177 <= 7)
      {
        if (((1 << v177) & 0x78) != 0) {
          unsigned int v192 = isa - 285;
        }
      }
      else
      {
        unsigned int v192 = isa - 287;
      }
      if (v192 >= 9) {
        unsigned int v193 = v192 - 9;
      }
      else {
        unsigned int v193 = v192;
      }
      if (v193 <= 2)
      {
        DetermineLanguageSpecificParameters();
        if (v193 < dword_1EB2CDB30) {
          unsigned int v192 = v192 - v193 + dword_1EB2CDB30;
        }
      }
      uint64_t v194 = v192;
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"legibilityWeight", (const void *)[NSNumber numberWithLong:a13]);
      if ((const void *)*MEMORY[0x1E4F1CFD0] == a14) {
        CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"ignoreLegibilityWeight", a14);
      }
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"languagePropertiesCacheKey", @".AppleSystemUIFontCompactSoft");
      v277[0] = 0;
      int v195 = GetLocalizedTrimSetKey(v269, v277);
      valuePtr.unint64_t isa = CFDictionaryCreateMutable(allocatora, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      setNameWithGrade(kFontSoftCompact[v194], a7, (atomic_ullong *)&valuePtr);
      if (v277[0] == 64 || v277[0] == 32) {
        CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&valuePtr, memory_order_acquire), @"UnicodeCharSetTrim", v195);
      }
      v280.uint64_t info = atomic_load_explicit((atomic_ullong *volatile)&valuePtr, memory_order_acquire);
      unint64_t v196 = (const void *)[MEMORY[0x1E4F1C978] arrayWithObjects:&v280.info count:1];
      uint64_t v197 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      goto LABEL_319;
    }
    unint64_t v182 = isa - 296;
    if (isa - 296 <= 0x1F)
    {
      if (qword_1EB2CDBD8 != -1) {
        dispatch_once(&qword_1EB2CDBD8, &__block_literal_global_3552);
      }
      long long v183 = kChineseNames[v182];
      long long v184 = (__CFString **)qword_1EB2CD688;
      int64x2_t v185 = off_1E528F3E0[isa & 7];
      CFIndex Length = CFStringGetLength(v183);
      v282.CFIndex length = Length + ~CFStringGetLength(v185);
      v282.CFIndex location = 0;
      CFDictionaryRef v187 = (__CFString *)CFStringCreateWithSubstring(allocatora, v183, v282);
      int v188 = (int)v184[5 * v182 + 2];
      addNames(v187, v185, v183, (atomic_ullong *)&Mutable);
      id v189 = CFDictionaryCreateMutable(allocatora, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      unint64_t v190 = v189;
      if ((v188 - 2) > 7) {
        uint64_t v191 = @"w1";
      }
      else {
        uint64_t v191 = off_1E528F480[v188 - 2];
      }
      CFDictionaryAddValue(v189, @"weightClass", v191);
      if (HIDWORD(v184[5 * v182 + 2]) == 1) {
        CFDictionaryAddValue(v190, @"italicAngle", @"12.5");
      }
      uint64_t v200 = &kFont2X[5 * (v188 - 1)];
      CFDictionaryAddValue(v190, @"ascender", (const void *)[NSNumber numberWithInt:*((unsigned int *)v200 + 6)]);
      CFDictionaryAddValue(v190, @"descender", (const void *)[NSNumber numberWithInt:-*((_DWORD *)v200 + 7)]);
      CFDictionaryAddValue(v190, @"unitsPerEm", (const void *)[NSNumber numberWithDouble:*((double *)v200 + 1)]);
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"FontMetrics", v190);
      addComponentsForChinese((atomic_ullong *)&Mutable, v184, v182, v187);

      uint64_t v198 = v187;
      goto LABEL_336;
    }
    unint64_t v199 = isa - 328;
    if (isa - 328 <= 8)
    {
      addNames(@".AppleJapaneseFont", off_1E528F438[v199], kJapaneseNames[v199], (atomic_ullong *)&Mutable);
      unint64_t v204 = CFDictionaryCreateMutable(allocatora, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      int64_t v205 = v204;
      int v206 = (int)off_1EB2CD658[0][5 * v199 + 2];
      if ((v206 - 2) > 7) {
        unint64_t v207 = @"w1";
      }
      else {
        unint64_t v207 = off_1E528F480[v206 - 2];
      }
      CFDictionaryAddValue(v204, @"weightClass", v207);
      if (HIDWORD(off_1EB2CD658[0][5 * v199 + 2]) == 1) {
        CFDictionaryAddValue(v205, @"italicAngle", @"12.5");
      }
      int v208 = &kFont2X[5 * (v206 - 1)];
      CFDictionaryAddValue(v205, @"ascender", (const void *)[NSNumber numberWithInt:*((unsigned int *)v208 + 6)]);
      CFDictionaryAddValue(v205, @"descender", (const void *)[NSNumber numberWithInt:-*((_DWORD *)v208 + 7)]);
      CFDictionaryAddValue(v205, @"unitsPerEm", (const void *)[NSNumber numberWithDouble:*((double *)v208 + 1)]);
      CFDictionaryAddValue(v205, @"lineGap", &unk_1ED080A78);
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"FontMetrics", v205);
      addComponentsWithTrimCharacterSet((const void **)&off_1EB2CD658[0][5 * v199], @"ja", (atomic_ullong *)&Mutable, (uint64_t)&__block_literal_global_631);
LABEL_335:
      uint64_t v198 = v205;
      goto LABEL_336;
    }
    unint64_t v201 = isa - 338;
    if (isa >= 0x152)
    {
      if (v201 <= 7)
      {
        uint64_t v202 = kKoreanNames[v201];
        int v203 = off_1E528F3E0[v201];
        uint64_t v210 = 5 * v201;
        uint64_t v211 = qword_1EB2CD660 + 40 * v201;
        int v212 = *(_DWORD *)(v211 + 16);
        int v213 = *(_DWORD *)(v211 + 20);
        addNames(@".AppleKoreanFont", v203, v202, (atomic_ullong *)&Mutable);
        addMetrics(v212, v213, 0, 0, 0, (atomic_ullong *)&Mutable);
        int64x2_t v214 = (const void **)(qword_1EB2CD660 + 8 * v210);
        unint64_t v215 = @"ko";
LABEL_342:
        addComponentsWithTrimCharacterSet(v214, v215, (atomic_ullong *)&Mutable, 0);
        goto LABEL_337;
      }
      unint64_t v209 = isa - 347;
      if (isa < 0x15B) {
        goto LABEL_337;
      }
      if (v209 <= 8)
      {
        long long v219 = &kFontSFArabic + 5 * v209;
        int v220 = *((_DWORD *)v219 + 4);
        addNames(@".AppleArabicFont", off_1E528F438[v209], kArabicNames[v209], (atomic_ullong *)&Mutable);
        addMetrics(v220, 0, 0, 0, 0, (atomic_ullong *)&Mutable);
        valuePtr.unint64_t isa = CFArrayCreateMutable(allocatora, 0, MEMORY[0x1E4F1D510]);
        AddVariationInfo((atomic_ullong *)&Mutable, *v219);
        insertOpticalSizeComponent((const __CFString **)v219, 0, 0xFFFFFFFFLL, 0, 0, (atomic_ullong *)&valuePtr, 0, 0, 17.0);
        int64_t v221 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
        unint64_t v222 = (const void *)*MEMORY[0x1E4F1CFD0];
        CFDictionaryAddValue(v221, @"hasVariations", (const void *)*MEMORY[0x1E4F1CFD0]);
        CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"hasOpticalSizeAxis", v222);
        CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"languagePropertiesCacheKey", @".AppleArabicFont");
        uint64_t v197 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
        unint64_t v196 = (const void *)atomic_load_explicit((atomic_ullong *volatile)&valuePtr, memory_order_acquire);
LABEL_319:
        CFDictionaryAddValue(v197, @"Components", v196);
        uint64_t v198 = valuePtr.isa;
LABEL_336:

        goto LABEL_337;
      }
      unint64_t v216 = isa - 357;
      if (isa < 0x165) {
        goto LABEL_337;
      }
      if (v216 <= 2)
      {
        if (qword_1EB2CDB58 != -1) {
          dispatch_once(&qword_1EB2CDB58, &__block_literal_global_633);
        }
        CFDictionaryRef v217 = kThaiNames[v216];
        long long v218 = off_1E528F420[v216];
        uint64_t v230 = 5 * v216;
        uint64_t v231 = qword_1EB2CD678 + 40 * v216;
        int v232 = *(_DWORD *)(v231 + 16);
        int v233 = *(_DWORD *)(v231 + 20);
        addNames(@".AppleThaiFont", v218, v217, (atomic_ullong *)&Mutable);
        addMetrics(v232, v233, 0, 0, 0, (atomic_ullong *)&Mutable);
        uint64_t v234 = qword_1EB2CD678;
LABEL_359:
        int64x2_t v214 = (const void **)(v234 + 8 * v230);
        unint64_t v215 = 0;
        goto LABEL_342;
      }
      unint64_t v223 = isa - 361;
      if (isa < 0x169) {
        goto LABEL_337;
      }
      if (v223 <= 1)
      {
        if (_os_feature_enabled_impl() && qword_1EB2CDB60 != -1) {
          dispatch_once(&qword_1EB2CDB60, &__block_literal_global_640);
        }
        long long v224 = kUrduNames[v223];
        long long v225 = @"Bold";
        if (isa != 362) {
          long long v225 = 0;
        }
        if (isa == 361) {
          long long v226 = @"Regular";
        }
        else {
          long long v226 = v225;
        }
        uint64_t v230 = 5 * v223;
        uint64_t v227 = qword_1EB2CD680 + 40 * v223;
        int v228 = *(_DWORD *)(v227 + 16);
        int v229 = *(_DWORD *)(v227 + 20);
        addNames(@".AppleUrduFont", v226, v224, (atomic_ullong *)&Mutable);
        addMetrics(v228, v229, 0, 0, 0, (atomic_ullong *)&Mutable);
        uint64_t v234 = qword_1EB2CD680;
        goto LABEL_359;
      }
      if (isa == 364)
      {
        uint64_t v198 = (void *)atomic_exchange((atomic_ullong *volatile)&Mutable, CreateSyntheticAppleSymbolsSplicedFont());
        goto LABEL_336;
      }
      unint64_t v235 = isa - 365;
      if (isa < 0x16D) {
        goto LABEL_337;
      }
      if (v235 > 3)
      {
        unint64_t v237 = isa - 369;
        if (isa - 369 > 8) {
          goto LABEL_337;
        }
        int v238 = (int)kFont2X[5 * v237 + 2];
        int v239 = HIDWORD(kFont2X[5 * v237 + 2]);
        addNames(@".AppleSystemFallback", off_1E528F438[v237], kSystemFallbackFontNames[v237], (atomic_ullong *)&Mutable);
        addMetrics(v238, v239, 0, 0, 0, (atomic_ullong *)&Mutable);
        int64_t v205 = CFArrayCreateMutable(allocatora, 0, MEMORY[0x1E4F1D510]);
        *(void *)&long long v240 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v240 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)&valuePtr.unint64_t isa = v240;
        *(_OWORD *)&valuePtr.datCGFloat a = v240;
        GetLocalizedTrimCharacterSet(&valuePtr, v269);
        v241 = (const void *)atomic_load_explicit((atomic_ullong *volatile)&valuePtr, memory_order_acquire);
        uint64_t info = valuePtr.info;
        datCGFloat a = valuePtr.data;
        AddVariationInfo((atomic_ullong *)&Mutable, *(const __CFString **)(qword_1EB2CD670 + 8 * v237));
        if (v241 && data)
        {
          CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"language", (const void *)atomic_load_explicit(&valuePtr.length, memory_order_acquire));
          v244 = CFDictionaryCreateMutable(allocatora, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          CFDictionaryAddValue(v244, @"UnicodeCharSet", v241);
          if (v237 >= (unint64_t)data) {
            unint64_t v245 = (unint64_t)(data - 1);
          }
          else {
            unint64_t v245 = v237;
          }
          CFDictionaryRef v246 = *(__CFString **)(info + 40 * v245);
          if (HasPingFangUIPrefix(v246))
          {
            v247 = (const void *)[NSString stringWithFormat:@".CJKSymbolsFallback%@-%@", RegionCodeFromPingFangUI(v246), off_1E528F1D0[v245 & 7]];
            CFDictionaryAddValue(v244, @"name", v247);
            v248 = @"languagePropertiesCacheKey";
            v249 = @".CJKSymbolsFallback";
            int64_t v250 = v244;
          }
          else
          {
            v248 = @"name";
            int64_t v250 = v244;
            v249 = v246;
          }
          CFDictionaryAddValue(v250, v248, v249);
          CFArrayAppendValue(v205, v244);

          v269 = 0;
        }
        unint64_t v251 = CFDictionaryCreateMutable(allocatora, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        CFDictionaryAddValue(v251, @"name", *(const void **)(qword_1EB2CD670 + 8 * v237));
        unint64_t v252 = (const void *)*MEMORY[0x1E4F1CFD0];
        CFDictionaryAddValue(v251, @"hasVariations", (const void *)*MEMORY[0x1E4F1CFD0]);
        CFDictionaryAddValue(v251, @"hasOpticalSizeAxis", v252);
        CFDictionaryAddValue(v251, @"languagePropertiesCacheKey", @".AppleSystemUIFont");
        CFArrayAppendValue(v205, v251);

        if (v237 <= 1)
        {
          v253 = CFDictionaryCreateMutable(allocatora, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          CFDictionaryAddValue(v253, @"name", kFallbacksAux[v237]);
          CFArrayAppendValue(v205, v253);
        }
        CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"Components", v205);
        goto LABEL_335;
      }
      unint64_t SyntheticAppleTimesSplicedFont = CreateSyntheticAppleTimesSplicedFont(v235);
      if (SyntheticAppleTimesSplicedFont)
      {

        int v35 = 1;
        goto LABEL_338;
      }
    }
LABEL_337:
    int v35 = 0;
LABEL_338:
    CFStringRef v36 = v269;
    goto LABEL_154;
  }
  uint64_t v30 = (uint64_t)TextStyle;
  unsigned int v261 = a7;
  long long v31 = (TDescriptorSource *)*(unsigned __int16 *)TextStyle;
  CFArrayRef theArray = CFArrayCreateMutable(v25, 0, MEMORY[0x1E4F1D510]);
  int v263 = *(_DWORD *)(v30 + 4);
  long long v32 = kFont2X;
  if (@"NSCTFontUIFontDesignRounded" == a4)
  {
    BOOL v33 = 1;
    goto LABEL_18;
  }
  BOOL v268 = 0;
  if (a4 && @"NSCTFontUIFontDesignRounded")
  {
    BOOL v33 = CFEqual(a4, @"NSCTFontUIFontDesignRounded") != 0;
LABEL_18:
    BOOL v268 = v33;
  }
  if (@"NSCTFontUIFontDesignCompactRounded" == a4)
  {
    BOOL v37 = 1;
  }
  else
  {
    BOOL v37 = 0;
    if (a4 && @"NSCTFontUIFontDesignCompactRounded") {
      BOOL v37 = CFEqual(a4, @"NSCTFontUIFontDesignCompactRounded") != 0;
    }
  }
  BOOL v254 = v37;
  *(void *)v277 = -1;
  if (a5) {
    CFNumberGetValue(a5, kCFNumberDoubleType, v277);
  }
  else {
    *(void *)v277 = 0;
  }
  v271 = (void *)*MEMORY[0x1E4F1CFD0];
  if (isa - 151 > 4)
  {
    unsigned int v39 = v31;
    long long v40 = v32;
    uint64_t v24 = (uint64_t)a12;
  }
  else
  {
    int v38 = isa - 151;
    unsigned int v39 = v31;
    long long v40 = v32;
    uint64_t v24 = (uint64_t)a12;
    if ((v38 & 0x80000000) == 0)
    {
      uint64_t v41 = 0;
      while (LODWORD(kCondensedMapping[v41 + 1]) != v31)
      {
        v41 += 44;
        if (v41 == 220)
        {
          int v263 = *(_DWORD *)(v30 + 4);
          goto LABEL_45;
        }
      }
      int v263 = HIDWORD(kCondensedMapping[v41 + 1]);
LABEL_45:
      uint64_t v51 = -5;
      uint64_t v52 = &dword_1E528D818;
      long long v40 = &kFontInfoSemiCondensed;
      while (*v52 != v31)
      {
        v52 += 88;
        if (__CFADD__(v51++, 1))
        {
          unsigned int v39 = v31;
          goto LABEL_52;
        }
      }
      unsigned int v39 = v51 + 182;
      long long v40 = &kFontInfoSemiCondensed;
    }
  }
LABEL_52:
  char v54 = v268;
  if (!a4) {
    char v54 = 1;
  }
  unsigned int v256 = v39;
  if (v54)
  {
    if (a8 == 4)
    {
      a4 = @"NSCTFontUIFontDesignCompact";
      long long v40 = &kFont2XCompact;
      CFDictionaryRef v55 = @".AppleSystemUIFontCompact";
LABEL_66:
      unint64_t v265 = v271;
      goto LABEL_67;
    }
LABEL_65:
    CFDictionaryRef v55 = @".AppleSystemUIFont";
    goto LABEL_66;
  }
  if (qword_1EB2CDB48 != -1) {
    dispatch_once(&qword_1EB2CDB48, &__block_literal_global_2);
  }
  CFNumberRef Value = (__CFString **)CFDictionaryGetValue((CFDictionaryRef)qword_1EB2CDB50, a4);
  if (!Value) {
    goto LABEL_65;
  }
  if (Value == &kFontMono)
  {
    unint64_t v265 = (const void *)*MEMORY[0x1E4F1CFC8];
    long long v40 = &kFontMono;
    CFDictionaryRef v55 = @".AppleSystemUIFontMonospaced";
  }
  else
  {
    if (Value == &kFontSerif) {
      CFDictionaryRef v55 = @".AppleSystemUIFontSerif";
    }
    else {
      CFDictionaryRef v55 = @".AppleSystemUIFontCompact";
    }
    unint64_t v265 = v271;
    long long v40 = Value;
  }
LABEL_67:
  unsigned int v276 = 0;
  CFAllocatorRef allocator = v25;
  v260 = v40;
  if (v40 == kFont2X) {
    v255 = GetLocalizedTrimSetKey((__CFString *)a3, &v276);
  }
  else {
    v255 = 0;
  }
  if (v270 >= 0xC) {
    uint64_t v57 = 3;
  }
  else {
    uint64_t v57 = v270;
  }
  unsigned int v58 = *(_DWORD *)(v30 + 20);
  if (a13 == 1 && v58 <= 0x10 && ((0x1FEFFu >> v58) & 1) != 0) {
    unsigned int v58 = dword_184BA17A4[v58];
  }
  unsigned int v59 = v58 % 9;
  if (v58 % 9 <= 2)
  {
    DetermineLanguageSpecificParameters();
    if (v59 < dword_1EB2CDB30)
    {
      unsigned int v58 = dword_1EB2CDB30 + v58 - v59;
      unsigned int v59 = v58 % 9;
    }
  }
  if (a5)
  {
    unsigned int v58 = __const__Z19LocalTraitForWeightdd_kWeightTraits[(unsigned __int16)IndexesBracketing<double const*,double>(kCTFontDefaultWeights, (double *)&kCTFontWeightRegular, *(double *)v277, 0.001)]+ v58- v59;
    if (a13 == 1 && v58 <= 0x10 && ((0x1FEFFu >> v58) & 1) != 0) {
      unsigned int v58 = dword_184BA17A4[v58];
    }
    unsigned int v59 = v58 % 9;
    CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"weight", a5);
  }
  if (a5) {
    int v60 = v59 + 1;
  }
  else {
    int v60 = v263;
  }
  if ((a10 & (v58 < 9)) != 0) {
    int v61 = 1;
  }
  else {
    int v61 = *(_DWORD *)(v30 + 8);
  }
  if ((a10 & (v58 < 9)) != 0) {
    unsigned int v62 = v58 + 9;
  }
  else {
    unsigned int v62 = v58;
  }
  if (a4) {
    uint64_t v63 = a4;
  }
  else {
    uint64_t v63 = @"NSCTFontUIFontDesignDefault";
  }
  addPosingWithWeightAndSlant(v31, v60, v61, *(_DWORD *)(v30 + 12), v55, v63, (atomic_ullong *)&Mutable, @"width", number);
  CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"isTextStyle", v271);
  CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"legibilityWeight", (const void *)[NSNumber numberWithLong:a13]);
  if (v271 == a14) {
    CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"ignoreLegibilityWeight", a14);
  }
  if (a8 != -1) {
    CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"platform", (const void *)[NSNumber numberWithUnsignedInt:a8]);
  }
  unint64_t v275 = 0xAAAAAAAAAAAAAAAALL;
  __CFString valuePtr = *(__CFString *)ymmword_184B94BE8;
  id v64 = &v260[5 * v62];
  unint64_t v65 = (unint64_t)v64[4];
  long long v66 = *((_OWORD *)v64 + 1);
  *(_OWORD *)&valuePtr.unint64_t isa = *(_OWORD *)v64;
  *(_OWORD *)&valuePtr.datCGFloat a = v66;
  unint64_t v275 = v65;
  if (v268)
  {
    valuePtr.unint64_t isa = off_1EB2CD668[0][v59];
    unint64_t v265 = (const void *)*MEMORY[0x1E4F1CFC8];
    CFDictionaryRef v55 = @".AppleSystemUIFontRounded";
  }
  else if (v254)
  {
    valuePtr.unint64_t isa = kFontCompactRounded[v59];
    valuePtr.CFIndex length = 0xFFFFFE120000079ELL;
    unint64_t v265 = (const void *)*MEMORY[0x1E4F1CFC8];
    CFDictionaryRef v55 = @".AppleSystemUIFontCompactRounded";
  }
  else if (number)
  {
    CFStringRef v36 = v269;
    if (v260 == kFont2X) {
      valuePtr.unint64_t isa = SFFontNameForWidth(v62, number, 0);
    }
    goto LABEL_107;
  }
  CFStringRef v36 = v269;
LABEL_107:
  uint64_t v67 = v30 + 24;
  CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"languagePropertiesCacheKey", v55);
  double v68 = 0.0;
  if ((*(unsigned char *)(v30 + 16) & 0x10) != 0) {
    double v68 = *(double *)(v67 + 24 * v57 + 16);
  }
  unint64_t v69 = (double *)(v67 + 24 * v57);
  id v273 = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  double v70 = v69[1] * 0.5;
  int v71 = *(_DWORD *)(v30 + 12);
  uint64_t v72 = (void **)(&off_1E528F3C8 + (int)a8 + 1);
  if ((a8 + 1) >= 3) {
    uint64_t v72 = (void **)&_MergedGlobals_2;
  }
  double v73 = 2.0;
  if (*v72 == &kTypeHierarchySpecWatch) {
    double v73 = 1.0;
  }
  if ((a10 & 0x10000) != 0) {
    int v71 = -1;
  }
  double v74 = -0.0;
  if ((a10 & 0x10000) != 0) {
    double v74 = v73;
  }
  double v75 = v70 + v74;
  double v76 = v70 - v73;
  if ((a10 & 0x8000) != 0) {
    int v77 = 1;
  }
  else {
    int v77 = v71;
  }
  if ((a10 & 0x8000) != 0) {
    double v78 = v76;
  }
  else {
    double v78 = v75;
  }
  uint64_t v50 = v266;
  uint64_t v79 = v261;
  if (!v261)
  {
    int v80 = *(_DWORD *)(v30 + 16);
    if ((v80 & 0xF) != 0)
    {
      if ((v80 & 8) != 0) {
        uint64_t v79 = 4;
      }
      else {
        uint64_t v79 = ((*(_DWORD *)(v30 + 16) & 0xFu) >> 1) + 1;
      }
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"grade", (const void *)objc_msgSend(NSNumber, "numberWithUnsignedInt:", v79, v76));
    }
    else
    {
      uint64_t v79 = 0;
    }
  }
  if (v264) {
    double v27 = LanguageAwareLineSpacingOverrideRatio(v30, v36);
  }
  setOpticalSizeComponent((const __CFString *)valuePtr.isa, (uint64_t)&valuePtr, v256, v77, v79, v255, (atomic_ullong *)&v273, a16, *v69 * 0.5, v78, v27, v68, 0);
  CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v273, memory_order_acquire), @"sizeCategory", (const void *)[NSNumber numberWithUnsignedLong:v270]);
  if (v265 == v271) {
    AddVariationInfoWithGrade((atomic_ullong *)&Mutable, (const __CFString *)valuePtr.isa, v79);
  }
  CFMutableArrayRef v92 = theArray;
  CFArrayInsertValueAtIndex(theArray, 0, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v273, memory_order_acquire));
  CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"hasVariations", v271);
  CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"hasOpticalSizeAxis", v265);
  CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"Components", theArray);

LABEL_144:
  unsigned int v93 = v92;
LABEL_145:

LABEL_146:
  int v35 = 0;
LABEL_154:
  if (atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire)
    && CFDictionaryGetCount((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire)))
  {
    if (v36) {
      CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"language", v36);
    }
    if (v24)
    {
      BOOL v99 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      uint64_t v100 = @"lineSpacingOverride";
      CGGlyph v101 = (const void *)v24;
    }
    else
    {
      CGGlyph v101 = a11;
      if (!a11)
      {
LABEL_164:
        if (a15) {
          CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"cacheKey", a15);
        }
        CreateSplicedFontFromStash((atomic_ullong *)&Mutable, 0, v35, v50);
        goto LABEL_167;
      }
      BOOL v99 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      uint64_t v100 = @"languageAwareLineHeightRatio";
    }
    CFDictionaryAddValue(v99, v100, v101);
    goto LABEL_164;
  }
  void *v50 = 0;
LABEL_167:
}