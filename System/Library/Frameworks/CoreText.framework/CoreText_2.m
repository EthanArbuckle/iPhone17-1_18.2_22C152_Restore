unsigned int ClassOfWeight(double a1)
{
  unsigned int v2;
  float v3;
  float v4;
  double v5;
  float v6;

  v2 = IndexesBracketing<float const*,double>(kWeightScale, kWidthScale, a1, 0.001);
  v3 = kWeightScale[(unsigned __int16)v2];
  v4 = kWeightScale[HIWORD(v2)];
  v5 = 0.0;
  if (v3 != v4)
  {
    v6 = (a1 - v3) / (v4 - v3);
    v5 = v6;
  }
  return llround(std::__lerp[abi:nn180100]<double>((double)(100 * (unsigned __int16)v2), (double)(int)(100 * HIWORD(v2)), v5));
}

double WidthPercentOfClass(unsigned int a1)
{
  if (a1 >= 9) {
    int v1 = 9;
  }
  else {
    int v1 = a1;
  }
  unsigned int v2 = v1 + 1;
  float v3 = 0.0;
  if ((double)a1 != (double)v2) {
    float v3 = ((double)a1 - (double)a1) / ((double)v2 - (double)a1);
  }
  return std::__lerp[abi:nn180100]<float>(kWidthPercentScale[a1], kWidthPercentScale[(unsigned __int16)v2], v3);
}

uint64_t CompareTraits(const __CFDictionary *a1, const TBaseFont *a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  id v25 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr, const TBaseFont *))(*(void *)a2 + 152))(&v25, a2);
  float v3 = (void *)atomic_exchange((atomic_ullong *volatile)&v25, 0);

  if (!a1 || (CFIndex Count = CFDictionaryGetCount(a1)) == 0)
  {
LABEL_35:
    uint64_t v16 = 1;
    goto LABEL_36;
  }
  unint64_t v5 = Count;
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v28[14] = v6;
  v28[13] = v6;
  v28[12] = v6;
  v28[11] = v6;
  v28[10] = v6;
  v28[9] = v6;
  v28[8] = v6;
  v28[7] = v6;
  v28[6] = v6;
  v28[5] = v6;
  v28[4] = v6;
  v28[3] = v6;
  v28[2] = v6;
  v28[1] = v6;
  v28[0] = v6;
  id v25 = 0;
  v26 = 0;
  uint64_t v27 = 0;
  v29 = v28;
  std::vector<long,TInlineBufferAllocator<long,30ul>>::__vallocate[abi:nn180100](&v25, Count);
  v7 = (char *)v26;
  bzero(v26, 8 * v5);
  v26 = &v7[8 * v5];
  *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v23[14] = v8;
  v23[13] = v8;
  v23[12] = v8;
  v23[11] = v8;
  v23[10] = v8;
  v23[9] = v8;
  v23[8] = v8;
  v23[7] = v8;
  v23[6] = v8;
  v23[5] = v8;
  v23[4] = v8;
  v23[3] = v8;
  v23[2] = v8;
  v23[1] = v8;
  v23[0] = v8;
  v21 = 0;
  uint64_t v22 = 0;
  values = 0;
  v24 = v23;
  std::vector<long,TInlineBufferAllocator<long,30ul>>::__vallocate[abi:nn180100](&values, v5);
  v9 = (char *)v21;
  bzero(v21, 8 * v5);
  v21 = &v9[8 * v5];
  CFDictionaryGetKeysAndValues(a1, (const void **)v25, (const void **)values);
  v10 = (__CFString **)v25;
  v11 = values;
  while (1)
  {
    v12 = *v10;
    CFDictionaryRef v13 = v3;
    if (!v13) {
      break;
    }
    CFDictionaryRef v14 = v13;
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v13, v12);

    if (!Value) {
      goto LABEL_13;
    }
    if (v12 == @"NSCTFontSymbolicTrait"
      || @"NSCTFontSymbolicTrait" && v12 && CFEqual(v12, @"NSCTFontSymbolicTrait"))
    {
      LODWORD(valuePtr) = -1431655766;
      LODWORD(v18) = -1431655766;
      CFNumberGetValue((CFNumberRef)*v11, kCFNumberIntType, &valuePtr);
      CFNumberGetValue(Value, kCFNumberIntType, &v18);
      if ((LODWORD(valuePtr) & ~LODWORD(v18)) != 0) {
        goto LABEL_34;
      }
    }
    else if (v12 == @"NSCTFontWeightTrait" {
           || @"NSCTFontWeightTrait" && v12 && CFEqual(v12, @"NSCTFontWeightTrait")
    }
           || v12 == @"NSCTFontProportionTrait"
           || @"NSCTFontProportionTrait" && v12 && CFEqual(v12, @"NSCTFontProportionTrait")
           || v12 == @"NSCTFontSlantTrait"
           || @"NSCTFontSlantTrait" && v12 && CFEqual(v12, @"NSCTFontSlantTrait"))
    {
      double v18 = NAN;
      double valuePtr = NAN;
      CFNumberGetValue((CFNumberRef)*v11, kCFNumberDoubleType, &valuePtr);
      CFNumberGetValue(Value, kCFNumberDoubleType, &v18);
      if (vabdd_f64(valuePtr, v18) >= 0.001) {
        goto LABEL_34;
      }
    }
    else if (!CFEqual(*v11, Value))
    {
      goto LABEL_34;
    }
LABEL_31:
    ++v10;
    ++v11;
    if (!--v5)
    {
      double valuePtr = COERCE_DOUBLE(&values);
      std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&valuePtr);
      values = &v25;
      std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](&values);
      goto LABEL_35;
    }
  }

LABEL_13:
  if (v12 != @"NSCTFontSymbolicTrait"
    && (!@"NSCTFontSymbolicTrait" || !v12 || !CFEqual(v12, @"NSCTFontSymbolicTrait")))
  {
    goto LABEL_31;
  }
LABEL_34:
  double valuePtr = COERCE_DOUBLE(&values);
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&valuePtr);
  values = &v25;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](&values);
  uint64_t v16 = 0;
LABEL_36:

  return v16;
}

BOOL CompareCharSet(const __CFCharacterSet *a1, atomic_ullong *this)
{
  CharacterSetInternal = TBaseFont::GetCharacterSetInternal(this);
  return atomic_load_explicit((atomic_ullong *volatile)CharacterSetInternal, memory_order_acquire)
      && CFCharacterSetIsSupersetOfSet((CFCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)CharacterSetInternal, memory_order_acquire), a1) != 0;
}

char *TBaseFont::GetCharacterSetInternal(atomic_ullong *this)
{
  int v1 = (char *)(this + 24);
  if (!atomic_load_explicit(this + 24, memory_order_acquire))
  {
    (*(void (**)(id *__return_ptr))(*this + 184))(&v3);
  }
  return v1;
}

uint64_t CompareDesignLanguages(const __CFArray *a1, const TBaseFont *a2)
{
  id v5 = (id)0xAAAAAAAAAAAAAAAALL;
  CreateCanonicalLanguages(a1, &v5);
  uint64_t v3 = (*(uint64_t (**)(const TBaseFont *, unint64_t))(*(void *)a2 + 352))(a2, atomic_load_explicit((atomic_ullong *volatile)&v5, memory_order_acquire));

  return v3;
}

uint64_t CompareSupportedLanguages(const __CFArray *a1, const TBaseFont *a2)
{
  id v5 = (id)0xAAAAAAAAAAAAAAAALL;
  CreateCanonicalLanguages(a1, &v5);
  uint64_t v3 = (*(uint64_t (**)(const TBaseFont *, unint64_t))(*(void *)a2 + 344))(a2, atomic_load_explicit((atomic_ullong *volatile)&v5, memory_order_acquire));

  return v3;
}

BOOL CompareOtherNamesExclusive(const __CFString *a1, const __CFString *a2, const __CFString *a3, const TBaseFont *a4, char a5)
{
  if (a2)
  {
    id v27 = (id)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(id *__return_ptr, const TBaseFont *, __CFString *))(*(void *)a4 + 72))(&v27, a4, @"CTFontFamilyName");
    CFStringRef v10 = (const __CFString *)(id)atomic_load_explicit((atomic_ullong *volatile)&v27, memory_order_acquire);
    v11 = (__CFString *)v10;
    if (v10 == a2)
    {
      BOOL v12 = 1;
    }
    else if (v10)
    {
      BOOL v12 = CFEqual(a2, v10) != 0;
    }
    else
    {
      BOOL v12 = 0;
    }

    if (!a1) {
      goto LABEL_17;
    }
  }
  else
  {
    BOOL v12 = 0;
    if (!a1) {
      goto LABEL_17;
    }
  }
  if (!v12)
  {
    id v27 = (id)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(id *__return_ptr, const TBaseFont *, __CFString *))(*(void *)a4 + 72))(&v27, a4, @"CTFontFullName");
    CFStringRef v13 = (const __CFString *)(id)atomic_load_explicit((atomic_ullong *volatile)&v27, memory_order_acquire);
    CFDictionaryRef v14 = (__CFString *)v13;
    if (v13 == a1)
    {
      BOOL v12 = 1;
    }
    else if (v13)
    {
      BOOL v12 = CFEqual(a1, v13) != 0;
    }
    else
    {
      BOOL v12 = 0;
    }
  }
LABEL_17:
  if (a3 && !v12)
  {
    id v27 = (id)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(id *__return_ptr, const TBaseFont *, __CFString *))(*(void *)a4 + 72))(&v27, a4, @"CTFontSubFamilyName");
    CFStringRef v15 = (const __CFString *)(id)atomic_load_explicit((atomic_ullong *volatile)&v27, memory_order_acquire);
    uint64_t v16 = (__CFString *)v15;
    if (v15 == a3)
    {
      BOOL v12 = 1;
    }
    else if (v15)
    {
      BOOL v12 = CFEqual(a3, v15) != 0;
    }
    else
    {
      BOOL v12 = 0;
    }
  }
  if (!v12 && (a5 & 1) == 0)
  {
    if (a2)
    {
      id v27 = (id)0xAAAAAAAAAAAAAAAALL;
      (*(void (**)(id *__return_ptr, const TBaseFont *, __CFString *, void, void))(*(void *)a4 + 88))(&v27, a4, @"CTFontFamilyName", 0, 0);
      id v17 = (id)atomic_load_explicit((atomic_ullong *volatile)&v27, memory_order_acquire);
      CFStringRef v18 = (const __CFString *)v17;
      v19 = (__CFString *)v18;
      if (v18 == a2)
      {
        BOOL v12 = 1;
      }
      else if (v18)
      {
        BOOL v12 = CFStringCompare(a2, v18, 0x20uLL) == kCFCompareEqualTo;
      }
      else
      {
        BOOL v12 = 0;
      }

      if (a1)
      {
LABEL_36:
        if (!v12)
        {
          id v27 = (id)0xAAAAAAAAAAAAAAAALL;
          (*(void (**)(id *__return_ptr, const TBaseFont *, __CFString *, void, void))(*(void *)a4 + 88))(&v27, a4, @"CTFontFullName", 0, 0);
          id v20 = (id)atomic_load_explicit((atomic_ullong *volatile)&v27, memory_order_acquire);
          CFStringRef v21 = (const __CFString *)v20;
          uint64_t v22 = (__CFString *)v21;
          if (v21 == a1)
          {
            BOOL v12 = 1;
          }
          else if (v21)
          {
            BOOL v12 = CFStringCompare(a1, v21, 0x20uLL) == kCFCompareEqualTo;
          }
          else
          {
            BOOL v12 = 0;
          }
        }
      }
    }
    else
    {
      BOOL v12 = 0;
      if (a1) {
        goto LABEL_36;
      }
    }
    if (a3 && !v12)
    {
      id v27 = (id)0xAAAAAAAAAAAAAAAALL;
      (*(void (**)(id *__return_ptr, const TBaseFont *, __CFString *, void, void))(*(void *)a4 + 88))(&v27, a4, @"CTFontSubFamilyName", 0, 0);
      id v23 = (id)atomic_load_explicit((atomic_ullong *volatile)&v27, memory_order_acquire);
      CFStringRef v24 = (const __CFString *)v23;
      id v25 = (__CFString *)v24;
      if (v24 == a3)
      {
        BOOL v12 = 1;
      }
      else if (v24)
      {
        BOOL v12 = CFStringCompare(a3, v24, 0x20uLL) == kCFCompareEqualTo;
      }
      else
      {
        BOOL v12 = 0;
      }
    }
  }
  return v12;
}

BOOL ComparePostScriptName(const __CFString *a1, atomic_ullong *a2)
{
  id v3 = (id)atomic_load_explicit(a2 + 12, memory_order_acquire);
  id v4 = v3;
  CFStringRef v5 = (const __CFString *)v4;
  long long v6 = (__CFString *)v5;
  if (v5 == a1)
  {
    BOOL v7 = 1;
  }
  else
  {
    BOOL v7 = 0;
    if (a1 && v5) {
      BOOL v7 = CFStringCompare(a1, v5, 1uLL) == kCFCompareEqualTo;
    }
  }

  return v7;
}

BOOL CompareOtherNamesInclusive(const __CFString *a1, const __CFString *a2, const __CFString *a3, const TBaseFont *a4, char a5)
{
  if (a2)
  {
    id v27 = (id)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(id *__return_ptr, const TBaseFont *, __CFString *))(*(void *)a4 + 72))(&v27, a4, @"CTFontFamilyName");
    CFStringRef v10 = (const __CFString *)(id)atomic_load_explicit((atomic_ullong *volatile)&v27, memory_order_acquire);
    v11 = (__CFString *)v10;
    if (v10 == a2)
    {
      BOOL v12 = 1;
    }
    else if (v10)
    {
      BOOL v12 = CFEqual(a2, v10) != 0;
    }
    else
    {
      BOOL v12 = 0;
    }

    if (!a1) {
      goto LABEL_17;
    }
  }
  else
  {
    BOOL v12 = 1;
    if (!a1) {
      goto LABEL_17;
    }
  }
  if (v12)
  {
    id v27 = (id)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(id *__return_ptr, const TBaseFont *, __CFString *))(*(void *)a4 + 72))(&v27, a4, @"CTFontFullName");
    CFStringRef v13 = (const __CFString *)(id)atomic_load_explicit((atomic_ullong *volatile)&v27, memory_order_acquire);
    CFDictionaryRef v14 = (__CFString *)v13;
    if (v13 == a1)
    {
      BOOL v12 = 1;
    }
    else if (v13)
    {
      BOOL v12 = CFEqual(a1, v13) != 0;
    }
    else
    {
      BOOL v12 = 0;
    }
  }
LABEL_17:
  if (a3 && v12)
  {
    id v27 = (id)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(id *__return_ptr, const TBaseFont *, __CFString *))(*(void *)a4 + 72))(&v27, a4, @"CTFontSubFamilyName");
    CFStringRef v15 = (const __CFString *)(id)atomic_load_explicit((atomic_ullong *volatile)&v27, memory_order_acquire);
    uint64_t v16 = (__CFString *)v15;
    if (v15 == a3)
    {
      BOOL v12 = 1;
    }
    else if (v15)
    {
      BOOL v12 = CFEqual(a3, v15) != 0;
    }
    else
    {
      BOOL v12 = 0;
    }
  }
  if (!v12 && (a5 & 1) == 0)
  {
    if (a2)
    {
      id v27 = (id)0xAAAAAAAAAAAAAAAALL;
      (*(void (**)(id *__return_ptr, const TBaseFont *, __CFString *, void, void))(*(void *)a4 + 88))(&v27, a4, @"CTFontFamilyName", 0, 0);
      id v17 = (id)atomic_load_explicit((atomic_ullong *volatile)&v27, memory_order_acquire);
      CFStringRef v18 = (const __CFString *)v17;
      v19 = (__CFString *)v18;
      if (v18 == a2)
      {
        BOOL v12 = 1;
      }
      else if (v18)
      {
        BOOL v12 = CFStringCompare(a2, v18, 0x20uLL) == kCFCompareEqualTo;
      }
      else
      {
        BOOL v12 = 0;
      }

      if (a1)
      {
LABEL_36:
        if (v12)
        {
          id v27 = (id)0xAAAAAAAAAAAAAAAALL;
          (*(void (**)(id *__return_ptr, const TBaseFont *, __CFString *, void, void))(*(void *)a4 + 88))(&v27, a4, @"CTFontFullName", 0, 0);
          id v20 = (id)atomic_load_explicit((atomic_ullong *volatile)&v27, memory_order_acquire);
          CFStringRef v21 = (const __CFString *)v20;
          uint64_t v22 = (__CFString *)v21;
          if (v21 == a1)
          {
            BOOL v12 = 1;
          }
          else if (v21)
          {
            BOOL v12 = CFStringCompare(a1, v21, 0x20uLL) == kCFCompareEqualTo;
          }
          else
          {
            BOOL v12 = 0;
          }
        }
      }
    }
    else
    {
      BOOL v12 = 1;
      if (a1) {
        goto LABEL_36;
      }
    }
    if (a3 && v12)
    {
      id v27 = (id)0xAAAAAAAAAAAAAAAALL;
      (*(void (**)(id *__return_ptr, const TBaseFont *, __CFString *, void, void))(*(void *)a4 + 88))(&v27, a4, @"CTFontSubFamilyName", 0, 0);
      id v23 = (id)atomic_load_explicit((atomic_ullong *volatile)&v27, memory_order_acquire);
      CFStringRef v24 = (const __CFString *)v23;
      id v25 = (__CFString *)v24;
      if (v24 == a3)
      {
        BOOL v12 = 1;
      }
      else if (v24)
      {
        BOOL v12 = CFStringCompare(a3, v24, 0x20uLL) == kCFCompareEqualTo;
      }
      else
      {
        BOOL v12 = 0;
      }
    }
  }
  return v12;
}

BOOL CompareFileURL(const __CFURL *a1, const TBaseFont *a2)
{
  (*(void (**)(id *__return_ptr, const TBaseFont *))(*(void *)a2 + 192))(&v6, a2);
  id v3 = (void *)atomic_exchange((atomic_ullong *volatile)&v6, 0);

  if (v3) {
    BOOL v4 = CFEqual(a1, v3) != 0;
  }
  else {
    BOOL v4 = 0;
  }

  return v4;
}

BOOL CompareFormat(const __CFNumber *a1, const TBaseFont *a2)
{
  (*(void (**)(id *__return_ptr, const TBaseFont *))(*(void *)a2 + 216))(&v6, a2);
  id v3 = (void *)atomic_exchange((atomic_ullong *volatile)&v6, 0);

  if (v3) {
    BOOL v4 = CFEqual(a1, v3) != 0;
  }
  else {
    BOOL v4 = 0;
  }

  return v4;
}

BOOL CompareScope(const __CFNumber *a1, const TBaseFont *a2)
{
  (*(void (**)(id *__return_ptr, const TBaseFont *))(*(void *)a2 + 248))(&v6, a2);
  id v3 = (void *)atomic_exchange((atomic_ullong *volatile)&v6, 0);

  if (v3) {
    BOOL v4 = CFEqual(a1, v3) != 0;
  }
  else {
    BOOL v4 = 0;
  }

  return v4;
}

uint64_t GetTraitsFromSubfamilyName(const TBaseFont *a1, int a2, int a3, int a4, double *a5, double *a6, double *a7)
{
  v17.info = 0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(uint64_t *__return_ptr))(*(void *)a1 + 72))(&v17.info);
  if (atomic_load_explicit(&v17.info, memory_order_acquire))
  {
    v17.isa = (void *)0xAAAAAAAAAAAAAAAALL;
    CreateTraitsByStyleGlossaryString(&v17, (const __CFString *)atomic_load_explicit(&v17.info, memory_order_acquire));
    if (!atomic_load_explicit((atomic_ullong *volatile)&v17, memory_order_acquire))
    {
LABEL_18:

      goto LABEL_19;
    }
    if ((a2 & 1) == 0)
    {
      CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v17, memory_order_acquire), @"NSCTFontWeightTrait");
      if (!Value)
      {
        a2 = 0;
        if (a3) {
          goto LABEL_11;
        }
LABEL_9:
        CFNumberRef v14 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v17, memory_order_acquire), @"NSCTFontProportionTrait");
        if (!v14)
        {
          a3 = 0;
          if (a4)
          {
LABEL_16:
            a4 = 1;
            goto LABEL_18;
          }
LABEL_14:
          CFNumberRef v15 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v17, memory_order_acquire), @"NSCTFontSlantTrait");
          if (!v15)
          {
            a4 = 0;
            goto LABEL_18;
          }
          CFNumberGetValue(v15, kCFNumberDoubleType, a7);
          goto LABEL_16;
        }
        CFNumberGetValue(v14, kCFNumberDoubleType, a6);
LABEL_11:
        a3 = 1;
        if (a4) {
          goto LABEL_16;
        }
        goto LABEL_14;
      }
      CFNumberGetValue(Value, kCFNumberDoubleType, a5);
    }
    a2 = 1;
    if (a3) {
      goto LABEL_11;
    }
    goto LABEL_9;
  }
LABEL_19:

  return a2 | (a3 << 8) | (a4 << 16);
}

void CreateTraitsByStyleGlossaryString(const __CFString *a1, const __CFString *a2)
{
  v30[1] = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFMutableStringRef MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, a2);
    CFStringFold(MutableCopy, 1uLL, 0);
    *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v29[7] = v5;
    v29[6] = v5;
    v29[5] = v5;
    v29[4] = v5;
    v29[3] = v5;
    v29[2] = v5;
    v29[1] = v5;
    v29[0] = v5;
    id v27 = 0;
    v28 = 0;
    __p = 0;
    v30[0] = v29;
    CStringPtr = (char *)CFStringGetCStringPtr(MutableCopy, 0x8000100u);
    if (CStringPtr) {
      goto LABEL_26;
    }
    CFIndex Length = CFStringGetLength(MutableCopy);
    CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
    unint64_t v9 = MaximumSizeForEncoding + 1;
    CFStringRef v10 = (char *)__p;
    size_t v11 = MaximumSizeForEncoding + 1 - (v27 - (unsigned char *)__p);
    if (MaximumSizeForEncoding + 1 <= (unint64_t)(v27 - (unsigned char *)__p))
    {
      if (v9 < v27 - (unsigned char *)__p) {
        id v27 = (char *)__p + v9;
      }
    }
    else
    {
      if (v28 - v27 >= v11)
      {
        bzero(v27, v9 - (v27 - (unsigned char *)__p));
        id v27 = (char *)__p + v9;
      }
      else
      {
        if (MaximumSizeForEncoding <= -2) {
          abort();
        }
        unint64_t v12 = 2 * (v28 - (unsigned char *)__p);
        if (v12 <= v9) {
          unint64_t v12 = MaximumSizeForEncoding + 1;
        }
        size_t v13 = (unint64_t)(v28 - (unsigned char *)__p) >= 0x3FFFFFFFFFFFFFFFLL ? 0x7FFFFFFFFFFFFFFFLL : v12;
        CFNumberRef v14 = (char *)v30[0];
        if (v30[0] + v13 <= (unint64_t)v30) {
          v30[0] += v13;
        }
        else {
          CFNumberRef v14 = (char *)operator new(v13);
        }
        CFNumberRef v15 = &v14[v27 - (unsigned char *)__p];
        uint64_t v16 = &v14[v13];
        __CFString v17 = &v14[v9];
        bzero(v15, v11);
        __p = v15;
        id v27 = v17;
        v28 = v16;
      }
      CFStringRef v10 = (char *)__p;
    }
    int CString = CFStringGetCString(MutableCopy, v10, v9, 0x8000100u);
    CStringPtr = (char *)__p;
    if (!CString || __p == 0)
    {
      a1->isa = 0;
      if (!CStringPtr)
      {
LABEL_38:

        return;
      }
    }
    else
    {
LABEL_26:
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v3, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      CFStringRef v21 = (__CFString **)CreateTraitsByStyleGlossaryString(__CFString const*)::kStyleGlossaryNameMaps;
      id v25 = Mutable;
      do
      {
        isa = (const char *)(*v21)->isa;
        if (isa)
        {
          uint64_t p_data = (uint64_t)&(*v21)->data;
          while (!strstr(CStringPtr, isa))
          {
            isa = *(const char **)(p_data + 8);
            p_data += 24;
            if (!isa) {
              goto LABEL_33;
            }
          }
          id v24 = (id)0xAAAAAAAAAAAAAAAALL;
          TCFNumber::TCFNumber<float>(&v24, *(float *)(p_data - 8));
          CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v25, memory_order_acquire), **(const void ***)p_data, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v24, memory_order_acquire));
        }
LABEL_33:
        ++v21;
      }
      while (v21 != kCTFontCSSFamilySystemUI);
      a1->isa = (void *)atomic_exchange((atomic_ullong *volatile)&v25, 0);

      CStringPtr = (char *)__p;
      if (!__p) {
        goto LABEL_38;
      }
    }
    id v27 = CStringPtr;
    if (v29 > (_OWORD *)CStringPtr || v30 <= (void *)CStringPtr) {
      operator delete(CStringPtr);
    }
    goto LABEL_38;
  }
  a1->isa = 0;
}

void CreateTraitsWithSymbolicTraits(CFDictionaryRef theDict@<X0>, unsigned int a2@<W1>, int a3@<W2>, CFDictionaryRef *a4@<X8>)
{
  if (theDict)
  {
    keys = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, theDict);
    unsigned int v8 = GetSymbolicTraitsFromTraits(theDict) & ~a3 | a3 & a2;
    if (v8)
    {
      TCFNumber::TCFNumber<unsigned int>(&values, v8);
      CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&keys, memory_order_acquire), @"NSCTFontSymbolicTrait", (const void *)atomic_load_explicit((atomic_ullong *volatile)&values, memory_order_acquire));
    }
    else
    {
      CFDictionaryRemoveValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&keys, memory_order_acquire), @"NSCTFontSymbolicTrait");
    }
    *a4 = (CFDictionaryRef)atomic_exchange((atomic_ullong *volatile)&keys, 0);
    unint64_t v9 = keys;
  }
  else
  {
    TCFNumber::TCFNumber<unsigned int>(&v10, a2);
    id values = (id)atomic_load_explicit(&v10, memory_order_acquire);
    keys = @"NSCTFontSymbolicTrait";
    *a4 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    unint64_t v9 = (void *)v10;
  }
}

void *TCFNumber::TCFNumber<float>(void *a1, float a2)
{
  float valuePtr = a2;
  id v4 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, &valuePtr);
  *a1 = atomic_exchange((atomic_ullong *volatile)&v4, 0);

  return a1;
}

__CFString *TStorageRange::DebugDescriptionWithInfoFromRun(TStorageRange *this, TFont **a2, CGSize a3, uint64_t a4)
{
  double width = a3.width;
  v58[1] = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringRef v10 = CFStringCreateWithFormat(v8, 0, @"width = %lg, glyphs = (\n"), width + *(double *)this;
  CFStringAppend(Mutable, v10);
  CFRelease(v10);
  size_t v11 = (void *)*((void *)this + 3);
  uint64_t v12 = v11[4];
  if (v12 || (uint64_t v14 = v11[3]) == 0)
  {
    int v52 = 0;
    uint64_t v13 = *((void *)this + 1);
    uint64_t v51 = v12 + 16 * v13;
  }
  else
  {
    uint64_t v13 = *((void *)this + 1);
    uint64_t v51 = v14 + 8 * v13;
    int v52 = 1;
  }
  if (*((uint64_t *)this + 2) >= 1)
  {
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    uint64_t v17 = v11[2] + 2 * v13;
    uint64_t v50 = v11[6] + 8 * v13;
    v47 = Mutable;
    uint64_t v48 = a4;
    v49 = (const __CTFont *)a2;
    do
    {
      v53 = (char *)0xAAAAAAAAAAAAAAAALL;
      if (a2
        && (TFont::CopyNameForGlyph(a2[5], *(_WORD *)(v17 + 2 * v16), (CFStringRef *)&__p),
            CFStringRef v18 = (__CFString *)atomic_exchange((atomic_ullong *volatile)&__p, 0),
            __p,
            v18))
      {
        *(void *)&long long v19 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v19 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v57[14] = v19;
        v57[15] = v19;
        v57[12] = v19;
        v57[13] = v19;
        v57[10] = v19;
        v57[11] = v19;
        v57[8] = v19;
        v57[9] = v19;
        v57[6] = v19;
        v57[7] = v19;
        v57[4] = v19;
        v57[5] = v19;
        v57[2] = v19;
        v57[3] = v19;
        v57[0] = v19;
        v57[1] = v19;
        id __p = 0;
        v55 = 0;
        v56 = 0;
        v58[0] = v57;
        int v20 = *(unsigned __int16 *)(v17 + 2 * v16);
        CStringPtr = CFStringGetCStringPtr(v18, 0x8000100u);
        if (!CStringPtr)
        {
          CFIndex Length = CFStringGetLength(v18);
          CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
          unint64_t v24 = MaximumSizeForEncoding + 1;
          id v25 = (char *)__p;
          int64_t v26 = v55 - (unsigned char *)__p;
          size_t v27 = MaximumSizeForEncoding + 1 - (v55 - (unsigned char *)__p);
          if (MaximumSizeForEncoding + 1 <= (unint64_t)(v55 - (unsigned char *)__p))
          {
            if (v24 < v55 - (unsigned char *)__p) {
              v55 = (char *)__p + v24;
            }
            CFMutableDictionaryRef Mutable = v47;
            a4 = v48;
          }
          else
          {
            if (v56 - v55 >= v27)
            {
              v37 = (char *)__p + v24;
              bzero(v55, v24 - (v55 - (unsigned char *)__p));
              v55 = v37;
              CFMutableDictionaryRef Mutable = v47;
              a4 = v48;
            }
            else
            {
              if (MaximumSizeForEncoding <= -2) {
                abort();
              }
              unint64_t v28 = 2 * (v56 - (unsigned char *)__p);
              if (v28 <= v24) {
                unint64_t v28 = MaximumSizeForEncoding + 1;
              }
              if ((unint64_t)(v56 - (unsigned char *)__p) >= 0x3FFFFFFFFFFFFFFFLL) {
                size_t v29 = 0x7FFFFFFFFFFFFFFFLL;
              }
              else {
                size_t v29 = v28;
              }
              uint64_t v30 = (char *)v58[0];
              size_t v46 = v29;
              if (v58[0] + v29 <= (unint64_t)v58) {
                v58[0] += v29;
              }
              else {
                uint64_t v30 = (char *)operator new(v29);
              }
              v45 = v30;
              v38 = &v30[v26];
              bzero(v38, v27);
              v40 = (char *)__p;
              v39 = v55;
              if (v55 == __p)
              {
                a4 = v48;
              }
              else
              {
                a4 = v48;
                do
                {
                  char v41 = *--v39;
                  *--v38 = v41;
                }
                while (v39 != v40);
                v39 = (char *)__p;
              }
              id __p = v38;
              v55 = &v45[v24];
              v42 = v56;
              v56 = &v45[v46];
              CFMutableDictionaryRef Mutable = v47;
              if (v39)
              {
                if (v57 <= (_OWORD *)v39 && v58 > (void *)v39)
                {
                  if (v42 == (char *)v58[0]) {
                    v58[0] = v39;
                  }
                }
                else
                {
                  operator delete(v39);
                }
              }
            }
            id v25 = (char *)__p;
          }
          if (CFStringGetCString(v18, v25, v24, 0x8000100u)) {
            CStringPtr = (const char *)__p;
          }
          else {
            CStringPtr = 0;
          }
          a2 = (TFont **)v49;
        }
        asprintf(&v53, "%d [%s]", v20, CStringPtr);
        if (__p)
        {
          v55 = (char *)__p;
          if (v57 > __p || v58 <= __p) {
            operator delete(__p);
          }
        }
      }
      else
      {
        asprintf(&v53, "%d", *(unsigned __int16 *)(v17 + 2 * v16));
        CFStringRef v18 = 0;
      }
      if ((*((unsigned char *)this + 33) & 0x10) != 0)
      {
        [*((id *)this + 3) originAtIndex:*((void *)this + 1) + v16];
      }
      else
      {
        uint64_t v31 = *MEMORY[0x1E4F1DAD8];
        uint64_t v32 = *(void *)(MEMORY[0x1E4F1DAD8] + 8);
      }
      if (v16 == a4 || *(unsigned __int16 *)(v17 + 2 * v16) != 0xFFFF || (*((unsigned char *)this + 33) & 2) == 0)
      {
        if (v52)
        {
          v33 = (void *)(v51 + 8 * v16);
          uint64_t v34 = 0;
        }
        else
        {
          v33 = (void *)(v51 + 16 * v16);
          uint64_t v34 = v33[1];
        }
        uint64_t v35 = v15 + 1;
        CFStringRef v36 = CFStringCreateWithFormat(v8, 0, @"\t{ %ld: glyph = %s, string index = %ld, origin = { %g, %g }, base advance = { %g, %g } },\n", v15, v53, *(void *)(v50 + 8 * v16), v31, v32, *v33, v34);
        CFStringAppend(Mutable, v36);
        CFRelease(v36);
        uint64_t v15 = v35;
      }
      free(v53);

      ++v16;
    }
    while (v16 < *((void *)this + 2));
  }
  CFStringAppend(Mutable, @""));
  return Mutable;
}

uint64_t TStorageRange::operator==(uint64_t a1, uint64_t a2)
{
  if (*(double *)a1 != *(double *)a2) {
    return 0;
  }
  uint64_t result = CFEqual(*(CFTypeRef *)(a1 + 24), *(CFTypeRef *)(a2 + 24));
  if (result)
  {
    if (*(void *)(a1 + 8) == *(void *)(a2 + 8) && *(void *)(a1 + 16) == *(void *)(a2 + 16)) {
      return *(unsigned __int8 *)(a1 + 32) == *(unsigned __int8 *)(a2 + 32);
    }
    return 0;
  }
  return result;
}

uint64_t TStorageRange::FindTabGlyph(TStorageRange *this, uint64_t a2, int a3, double *a4)
{
  uint64_t v4 = *((void *)this + 2);
  long long v5 = (void *)*((void *)this + 3);
  if (a3 < 0) {
    uint64_t v4 = -1;
  }
  uint64_t v6 = v5[4];
  if (v6 || (uint64_t v10 = v5[3]) == 0)
  {
    int v7 = 0;
    uint64_t v8 = *((void *)this + 1);
    uint64_t v9 = v6 + 16 * v8;
  }
  else
  {
    uint64_t v8 = *((void *)this + 1);
    uint64_t v9 = v10 + 8 * v8;
    int v7 = 1;
  }
  if (v4 != a2)
  {
    uint64_t v11 = v5[5] + 4 * v8;
    uint64_t v12 = (double *)(v9 + 16 * a2);
    uint64_t v13 = (double *)(v9 + 8 * a2);
    while ((*(_DWORD *)(v11 + 4 * a2) & 4) == 0)
    {
      if (a4)
      {
        if (v7) {
          uint64_t v14 = v13;
        }
        else {
          uint64_t v14 = v12;
        }
        *a4 = *v14 + *a4;
      }
      a2 += a3;
      v12 += 2 * a3;
      v13 += a3;
      if (v4 == a2) {
        return v4;
      }
    }
  }
  return a2;
}

uint64_t TStorageRange::InsertGlyphs(id *this, CFRange a2)
{
  CFIndex length = a2.length;
  CFIndex location = a2.location;
  objc_msgSend(this[3], "insertGlyphsAtRange:", a2.location, a2.length);
  this[2] = (char *)this[2] + length;
  if (length >= 1)
  {
    CFIndex v5 = location + length;
    uint64_t v6 = (double *)MEMORY[0x1E4F1DB30];
    do
      objc_msgSend(this[3], "setAdvance:atIndex:", location++, *v6, v6[1]);
    while (location < v5);
  }
  id v7 = this[3];

  return [v7 sync];
}

void TStorageRange::DetachStorage(id *this)
{
  uint64_t v2 = objc_msgSend(this[3], "copyWithRange:", this[1], this[2]);

  this[3] = (id)v2;
  this[1] = 0;
}

void TStorageRange::DetachStorageIfShared(TStorageRange *this)
{
  uint64_t v2 = *((void *)this + 1);
  CFAllocatorRef v3 = (void *)*((void *)this + 3);
  if (v2 || v3[1] != *((void *)this + 2))
  {
    uint64_t v4 = objc_msgSend(v3, "copyWithRange:");

    *((void *)this + 3) = v4;
    *((void *)this + 1) = 0;
  }
}

void TStorageRange::SetInterGlyphsExtraSpace(TStorageRange *this, uint64_t a2, double a3)
{
  uint64_t v6 = *((void *)this + 5);
  if (a3 == 0.0)
  {
    if (!v6) {
      return;
    }
  }
  else if (!v6)
  {
    unint64_t v13 = *((void *)this + 2);
    uint64_t v10 = operator new(0x30uLL);
    uint64_t v11 = std::__shared_ptr_emplace<std::vector<double>>::__shared_ptr_emplace[abi:nn180100]<long,std::allocator<std::vector<double>>,0>(v10, &v13)+ 3;
    uint64_t v12 = (std::__shared_weak_count *)*((void *)this + 6);
    *((void *)this + 5) = v11;
    *((void *)this + 6) = v10;
    if (v12) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v12);
    }
    uint64_t v8 = *((void *)this + 1);
    *((void *)this + 7) = v8;
    uint64_t v7 = v8;
    goto LABEL_6;
  }
  uint64_t v7 = *((void *)this + 1);
  uint64_t v8 = *((void *)this + 7);
LABEL_6:
  uint64_t v9 = a2 - v8 + v7;
  if (v9 < *((void *)this + 2)) {
    *(double *)(**((void **)this + 5) + 8 * v9) = a3;
  }
}

void TStorageRange::SetOriginalFinalAdvanceWidth(TStorageRange *this, double a2)
{
  uint64_t v4 = (void *)*((void *)this + 5);
  if (!v4)
  {
    uint64_t v12 = *((void *)this + 2) + 1;
    uint64_t v9 = operator new(0x30uLL);
    uint64_t v10 = std::__shared_ptr_emplace<std::vector<double>>::__shared_ptr_emplace[abi:nn180100]<long,std::allocator<std::vector<double>>,0>(v9, (unint64_t *)&v12)+ 3;
    uint64_t v11 = (std::__shared_weak_count *)*((void *)this + 6);
    *((void *)this + 5) = v10;
    *((void *)this + 6) = v9;
    if (v11) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v11);
    }
    *((void *)this + 7) = *((void *)this + 1);
    goto LABEL_9;
  }
  uint64_t v5 = (uint64_t)(v4[1] - *v4) >> 3;
  uint64_t v6 = *((void *)this + 1);
  uint64_t v7 = *((void *)this + 2);
  uint64_t v8 = *((void *)this + 7);
  if (v7 + v6 - v8 == v5)
  {
    std::vector<double>::resize((uint64_t)v4, v5 + 1);
    uint64_t v6 = *((void *)this + 1);
    uint64_t v7 = *((void *)this + 2);
    uint64_t v8 = *((void *)this + 7);
  }
  if (v7 - v8 + v6 + 1 == v5) {
LABEL_9:
  }
    *(double *)(*(void *)(*((void *)this + 5) + 8) - 8) = a2;
}

uint64_t TStorageRange::GetOriginalFinalAdvanceWidth(TStorageRange *this)
{
  int v1 = (void *)*((void *)this + 5);
  if (v1
    && (uint64_t v2 = v1[1], *((void *)this + 1) + *((void *)this + 2) - *((void *)this + 7) + 1 == (v2 - *v1) >> 3))
  {
    return *(void *)(v2 - 8);
  }
  else
  {
    return 0;
  }
}

void *std::__shared_ptr_emplace<std::vector<double>>::__shared_ptr_emplace[abi:nn180100]<long,std::allocator<std::vector<double>>,0>(void *a1, unint64_t *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1ED05D6E0;
  unint64_t v3 = *a2;
  a1[3] = 0;
  uint64_t v4 = a1 + 3;
  a1[4] = 0;
  a1[5] = 0;
  if (v3)
  {
    std::vector<double>::__vallocate[abi:nn180100](v4, v3);
    uint64_t v5 = (char *)a1[4];
    bzero(v5, 8 * v3);
    a1[4] = &v5[8 * v3];
  }
  return a1;
}

void std::__shared_ptr_emplace<std::vector<double>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ED05D6E0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::vector<double>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ED05D6E0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1853275C0);
}

void std::__shared_ptr_emplace<std::vector<double>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }
}

char *std::vector<double>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >> 61) {
    abort();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<long>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

uint64_t TBidiEngine::ReorderGlyphs(uint64_t this, TLine *a2)
{
  uint64_t v22 = (TBidiEngine *)this;
  uint64_t v2 = *((void *)a2 + 2);
  uint64_t v3 = *((void *)a2 + 3);
  uint64_t v4 = v3 - v2;
  if (v3 != v2)
  {
    uint64_t v6 = *(void **)(*(void *)v2 + 40);
    uint64_t v7 = v6[20];
    if (v7 && (*(_WORD *)(v7 + 66) & 4) != 0)
    {
      signed __int8 BaseWritingDirection = 1;
    }
    else
    {
      uint64_t v8 = (TParagraphStyle **)v6[21];
      if (v8) {
        signed __int8 BaseWritingDirection = TParagraphStyle::GetBaseWritingDirection(v8, a2);
      }
      else {
        signed __int8 BaseWritingDirection = -1;
      }
    }
    CFIndex v10 = v6[1];
    CFIndex v11 = v6[2];
    if (v4 < 9)
    {
      LOBYTE(v12) = 0;
    }
    else
    {
      int v12 = 0;
      uint64_t v13 = (unint64_t)v4 >> 3;
      uint64_t RunWithCharIndex = 1;
      CFIndex v15 = v6[2];
      do
      {
        uint64_t v16 = *(void **)(*(void *)(*((void *)a2 + 2) + 8 * RunWithCharIndex) + 40);
        uint64_t v17 = v16[20];
        if (v17 && (*(_WORD *)(v17 + 66) & 4) != 0)
        {
          unsigned __int8 v19 = 1;
        }
        else
        {
          CFStringRef v18 = (TParagraphStyle **)v16[21];
          if (v18) {
            unsigned __int8 v19 = TParagraphStyle::GetBaseWritingDirection(v18, a2);
          }
          else {
            unsigned __int8 v19 = -1;
          }
        }
        CFIndex v11 = v16[2];
        if (v19 == BaseWritingDirection)
        {
          v11 += v15;
        }
        else
        {
          CFIndex v20 = v16[1];
          v23.CFIndex location = v10;
          v23.CFIndex length = v15;
          v12 |= TBidiEngine::ReorderGlyphsInDirectionRange(v22, a2, v23, BaseWritingDirection);
          uint64_t v21 = *((void *)a2 + 3) - *((void *)a2 + 2);
          if (v13 != v21 >> 3)
          {
            uint64_t v13 = v21 >> 3;
            uint64_t RunWithCharIndex = TLine::FindRunWithCharIndex(a2, v20 + v11 - 1, 1);
          }
          CFIndex v10 = v20;
          signed __int8 BaseWritingDirection = v19;
        }
        ++RunWithCharIndex;
        CFIndex v15 = v11;
      }
      while (RunWithCharIndex < v13);
    }
    v24.CFIndex location = v10;
    v24.CFIndex length = v11;
    this = TBidiEngine::ReorderGlyphsInDirectionRange(v22, a2, v24, BaseWritingDirection);
    if (v12 & 1) != 0 || (this) {
      *((_WORD *)a2 + 76) |= 1u;
    }
  }
  return this;
}

uint64_t TBidiEngine::ReorderGlyphsInDirectionRange(TBidiEngine *this, TLine *a2, CFRange a3, uint64_t a4)
{
  CFIndex length = a3.length;
  CFIndex location = a3.location;
  uint64_t v8 = (unsigned __int8 *)(*(uint64_t (**)(void, CFIndex, CFIndex, uint64_t))(**(void **)this + 16))(*(void *)this, a3.location, a3.length, a4);
  uint64_t v9 = v8;
  if (v8) {
    int v10 = *v8;
  }
  else {
    int v10 = 0;
  }
  char v11 = v10 != 0;
  if (length < 2)
  {
    uint64_t v12 = 0;
  }
  else
  {
    uint64_t v12 = 0;
    for (uint64_t i = 1; i < length; ++i)
    {
      if (v9) {
        int v14 = v9[i];
      }
      else {
        int v14 = 0;
      }
      if (v14 != v10)
      {
        v17.CFIndex location = v12 + location;
        v17.CFIndex length = i - v12;
        uint64_t v15 = TBidiEngine::NewLevelRun(this, a2, v17, v10);
        if (v9) {
          int v10 = v9[i];
        }
        else {
          int v10 = 0;
        }
        v11 |= v10 != 0;
        i += v15;
        uint64_t v12 = i;
      }
    }
  }
  if (length > v12)
  {
    v18.CFIndex location = v12 + location;
    v18.CFIndex length = length - v12;
    TBidiEngine::NewLevelRun(this, a2, v18, v10);
  }
  return v11 & 1;
}

uint64_t TBidiEngine::NewLevelRun(TBidiEngine *this, TLine *a2, CFRange a3, int a4)
{
  if (!a4) {
    return 0;
  }
  char v4 = a4;
  CFIndex length = a3.length;
  CFIndex location = a3.location;
  uint64_t v7 = a2;
  if (a4)
  {
    uint64_t RunWithCharIndex = TLine::FindRunWithCharIndex(a2, a3.location, 1);
    uint64_t v10 = *((void *)v7 + 2);
    if (RunWithCharIndex < (*((void *)v7 + 3) - v10) >> 3)
    {
      v53 = v7;
      CFIndex v55 = length;
      char v54 = v4;
      uint64_t v64 = *((void *)this + 1);
      long long v65 = 0u;
      long long v66 = 0u;
      uint64_t v76 = 0;
      long long v75 = 0u;
      long long v74 = 0u;
      long long v73 = 0u;
      long long v72 = 0u;
      long long v71 = 0u;
      long long v70 = 0u;
      long long v69 = 0u;
      long long v68 = 0u;
      long long v67 = 0u;
      *(void *)&long long v75 = *(void *)(v64 + 16);
      uint64_t v11 = *(void *)(*(void *)(v10 + 8 * RunWithCharIndex) + 48);
      if (v11)
      {
        CFIndex v56 = location;
        CFIndex v57 = location + length;
        while (1)
        {
          CFIndex v12 = *(void *)(v11 + 8);
          CFIndex v13 = *(void *)(v11 + 16) + v12;
          if (v13 >= v57) {
            CFIndex v14 = v57;
          }
          else {
            CFIndex v14 = *(void *)(v11 + 16) + v12;
          }
          uint64_t v15 = v14 - location;
          BOOL v16 = v12 <= location && location < v13;
          if (v16) {
            CFRange v17 = (char *)location;
          }
          else {
            CFRange v17 = 0;
          }
          if (!v16) {
            uint64_t v15 = 0;
          }
          uint64_t v18 = v14 - v12;
          BOOL v19 = location <= v12 && v12 < v57;
          if (v19) {
            CFIndex v20 = *(char **)(v11 + 8);
          }
          else {
            CFIndex v20 = v17;
          }
          if (v19) {
            uint64_t v21 = v18;
          }
          else {
            uint64_t v21 = v15;
          }
          if (!v21) {
            goto LABEL_102;
          }
          explicit = (TRun **)atomic_load_explicit((atomic_ullong *volatile)(v11 + 56), memory_order_acquire);
          uint64_t v23 = (uint64_t)explicit[5];
          unint64_t v63 = 0xAAAAAAAAAAAAAAAALL;
          *(void *)&long long v24 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v24 + 1) = 0xAAAAAAAAAAAAAAAALL;
          *(_OWORD *)v61 = v24;
          long long v62 = v24;
          TAATPropTable::TAATPropTable((TAATPropTable *)v61, (const __CTFont *)explicit);
          if (v61[1])
          {
            v58 = explicit;
            uint64_t v25 = *(void *)(v11 + 216);
            uint64_t v26 = *(void *)(v25 + 48);
            uint64_t v27 = *(void *)(v11 + 200);
            uint64_t v28 = *(void *)(v25 + 16);
            uint64_t GlyphIndexForChar = TRun::GetGlyphIndexForCharIndex<false>(v11, (uint64_t)v20);
            uint64_t v30 = *(void *)(v11 + 208);
            if (GlyphIndexForChar < v30)
            {
              uint64_t v31 = GlyphIndexForChar;
              uint64_t v32 = &v20[v21];
              uint64_t v33 = v26 + 8 * v27;
              uint64_t v34 = v28 + 2 * v27;
              do
              {
                uint64_t v35 = *(void *)(v33 + 8 * v31);
                uint64_t v60 = v35;
                if ((uint64_t)v20 > v35 || (uint64_t)v32 <= v35) {
                  break;
                }
                unsigned __int16 v59 = *(_WORD *)(v34 + 2 * v31);
                if (TAATPropTable::MirrorGlyph((TAATPropTable *)v61, &v59))
                {
                  int v37 = v59;
                  [*(id *)(v11 + 216) setGlyph:v59 atIndex:v31 + *(void *)(v11 + 200)];
                  char v38 = *(unsigned char *)(v11 + 225);
                  if (v37 == 0xFFFF && (v38 & 2) != 0) {
                    *(unsigned char *)(v11 + 225) = v38 | 8;
                  }
                  uint64_t RenderingStyle = TAttributes::GetRenderingStyle((TAttributes *)(v11 + 40));
                  TStorageRange::ResetAdvance(v11 + 192, v31, v23, RenderingStyle);
                }
                else
                {
                  int FullChar = TCharStreamIterator::GetFullChar((TCharStreamIterator *)&v64, &v60, 0);
                  v42 = (const __CTFont *)MEMORY[0x185327F80]();
                  if (v42 != FullChar) {
                    TBidiEngine::ReplaceCharAtIndex((TBidiEngine *)v11, v58[5], v42, v35);
                  }
                }
                ++v31;
              }
              while (v30 != v31);
            }

            CFIndex location = v56;
            goto LABEL_101;
          }

          int ShapingType = TBaseFont::GetShapingType(*(TBaseFont **)(v23 + 400));
          v61[0] = v20;
          if (v21 >= 1) {
            break;
          }
LABEL_101:
          uint64_t v11 = *(void *)(v11 + 24);
          if (!v11) {
            goto LABEL_102;
          }
        }
        v44 = &v20[v21];
        unsigned int v45 = ShapingType & 0xFFFFFFFE;
        while (1)
        {
          uint64_t v46 = TCharStreamIterator::GetFullChar((TCharStreamIterator *)&v64, (uint64_t *)v61, 0);
          if (!MEMORY[0x185328000]()) {
            goto LABEL_100;
          }
          if (v45 != 2) {
            goto LABEL_98;
          }
          if ((int)v46 > 10626)
          {
            if ((int)v46 <= 11777)
            {
              if ((int)v46 > 10851)
              {
                switch((int)v46)
                {
                  case 10852:
                  case 10853:
                  case 10873:
                  case 10874:
                  case 10877:
                  case 10878:
                  case 10879:
                  case 10880:
                  case 10881:
                  case 10882:
                  case 10883:
                  case 10884:
                  case 10891:
                  case 10892:
                  case 10897:
                  case 10898:
                  case 10899:
                  case 10900:
                  case 10901:
                  case 10902:
                  case 10903:
                  case 10904:
                  case 10905:
                  case 10906:
                  case 10907:
                  case 10908:
                  case 10913:
                  case 10914:
                  case 10918:
                  case 10919:
                  case 10920:
                  case 10921:
                  case 10922:
                  case 10923:
                  case 10924:
                  case 10925:
                  case 10927:
                  case 10928:
                  case 10931:
                  case 10932:
                  case 10939:
                  case 10940:
                  case 10941:
                  case 10942:
                  case 10943:
                  case 10944:
                  case 10945:
                  case 10946:
                  case 10947:
                  case 10948:
                  case 10949:
                  case 10950:
                  case 10957:
                  case 10958:
                  case 10959:
                  case 10960:
                  case 10961:
                  case 10962:
                  case 10963:
                  case 10964:
                  case 10965:
                  case 10966:
                  case 10974:
                  case 10979:
                  case 10980:
                  case 10981:
                  case 10988:
                  case 10989:
                  case 10999:
                  case 11000:
                  case 11001:
                  case 11002:
                    goto LABEL_98;
                  default:
                    goto LABEL_100;
                }
                goto LABEL_100;
              }
              switch((int)v46)
              {
                case 10627:
                case 10628:
                case 10629:
                case 10630:
                case 10631:
                case 10632:
                case 10633:
                case 10634:
                case 10635:
                case 10636:
                case 10637:
                case 10638:
                case 10639:
                case 10640:
                case 10641:
                case 10642:
                case 10643:
                case 10644:
                case 10645:
                case 10646:
                case 10647:
                case 10648:
                case 10680:
                case 10688:
                case 10689:
                case 10692:
                case 10693:
                case 10703:
                case 10704:
                case 10705:
                case 10706:
                case 10708:
                case 10709:
                case 10712:
                case 10713:
                case 10714:
                case 10715:
                  goto LABEL_98;
                case 10649:
                case 10650:
                case 10651:
                case 10652:
                case 10653:
                case 10654:
                case 10655:
                case 10656:
                case 10657:
                case 10658:
                case 10659:
                case 10660:
                case 10661:
                case 10662:
                case 10663:
                case 10664:
                case 10665:
                case 10666:
                case 10667:
                case 10668:
                case 10669:
                case 10670:
                case 10671:
                case 10672:
                case 10673:
                case 10674:
                case 10675:
                case 10676:
                case 10677:
                case 10678:
                case 10679:
                case 10681:
                case 10682:
                case 10683:
                case 10684:
                case 10685:
                case 10686:
                case 10687:
                case 10690:
                case 10691:
                case 10694:
                case 10695:
                case 10696:
                case 10697:
                case 10698:
                case 10699:
                case 10700:
                case 10701:
                case 10702:
                case 10707:
                case 10710:
                case 10711:
                  goto LABEL_100;
                default:
                  if ((v46 - 10741) <= 0x39
                    && ((1 << (v46 + 11)) & 0x3C0000000000199) != 0)
                  {
                    goto LABEL_98;
                  }
                  if ((v46 - 10804) > 9) {
                    goto LABEL_100;
                  }
                  int v48 = 1 << (v46 - 52);
                  int v49 = 771;
                  break;
              }
LABEL_85:
              if ((v48 & v49) != 0) {
                goto LABEL_98;
              }
              goto LABEL_100;
            }
            if ((int)v46 <= 12295)
            {
              if ((v46 - 11778) <= 0x27 && ((1 << (v46 - 2)) & 0xFFCC000D8FLL) != 0) {
                goto LABEL_98;
              }
            }
            else
            {
              if ((int)v46 <= 65112)
              {
                if ((v46 - 12296) > 0x13) {
                  goto LABEL_100;
                }
                int v48 = 1 << (v46 - 8);
                int v49 = 1045503;
                goto LABEL_85;
              }
              if ((v46 - 65113) <= 0xC && ((1 << (v46 - 89)) & 0x183F) != 0
                || (v46 - 65288) <= 0x35
                && ((1 << (v46 - 8)) & 0x28000000500003) != 0)
              {
LABEL_98:
                uint64_t v50 = (const __CTFont *)MEMORY[0x185327F80](v46);
                if (v50 != v46) {
                  TBidiEngine::ReplaceCharAtIndex((TBidiEngine *)v11, explicit[5], v50, (uint64_t)v20);
                }
                goto LABEL_100;
              }
              if ((v46 - 65371) <= 8)
              {
                int v48 = 1 << (v46 - 91);
                int v49 = 437;
                goto LABEL_85;
              }
            }
          }
          else
          {
            if ((int)v46 > 8711)
            {
              switch((int)v46)
              {
                case 8712:
                case 8713:
                case 8714:
                case 8715:
                case 8716:
                case 8717:
                case 8725:
                case 8764:
                case 8765:
                case 8771:
                case 8786:
                case 8787:
                case 8788:
                case 8789:
                case 8804:
                case 8805:
                case 8806:
                case 8807:
                case 8808:
                case 8809:
                case 8810:
                case 8811:
                case 8814:
                case 8815:
                case 8816:
                case 8817:
                case 8818:
                case 8819:
                case 8820:
                case 8821:
                case 8822:
                case 8823:
                case 8824:
                case 8825:
                case 8826:
                case 8827:
                case 8828:
                case 8829:
                case 8830:
                case 8831:
                case 8832:
                case 8833:
                case 8834:
                case 8835:
                case 8836:
                case 8837:
                case 8838:
                case 8839:
                case 8840:
                case 8841:
                case 8842:
                case 8843:
                case 8847:
                case 8848:
                case 8849:
                case 8850:
                case 8856:
                case 8866:
                case 8867:
                case 8870:
                case 8872:
                case 8873:
                case 8875:
                case 8880:
                case 8881:
                case 8882:
                case 8883:
                case 8884:
                case 8885:
                case 8886:
                case 8887:
                case 8905:
                case 8906:
                case 8907:
                case 8908:
                case 8909:
                case 8912:
                case 8913:
                case 8918:
                case 8919:
                case 8920:
                case 8921:
                case 8922:
                case 8923:
                case 8924:
                case 8925:
                case 8926:
                case 8927:
                case 8928:
                case 8929:
                case 8930:
                case 8931:
                case 8932:
                case 8933:
                case 8934:
                case 8935:
                case 8936:
                case 8937:
                case 8938:
                case 8939:
                case 8940:
                case 8941:
                case 8944:
                case 8945:
                case 8946:
                case 8947:
                case 8948:
                case 8950:
                case 8951:
                case 8954:
                case 8955:
                case 8956:
                case 8957:
                case 8958:
                case 8968:
                case 8969:
                case 8970:
                case 8971:
                case 9001:
                case 9002:
                  goto LABEL_98;
                case 8718:
                case 8719:
                case 8720:
                case 8721:
                case 8722:
                case 8723:
                case 8724:
                case 8726:
                case 8727:
                case 8728:
                case 8729:
                case 8730:
                case 8731:
                case 8732:
                case 8733:
                case 8734:
                case 8735:
                case 8736:
                case 8737:
                case 8738:
                case 8739:
                case 8740:
                case 8741:
                case 8742:
                case 8743:
                case 8744:
                case 8745:
                case 8746:
                case 8747:
                case 8748:
                case 8749:
                case 8750:
                case 8751:
                case 8752:
                case 8753:
                case 8754:
                case 8755:
                case 8756:
                case 8757:
                case 8758:
                case 8759:
                case 8760:
                case 8761:
                case 8762:
                case 8763:
                case 8766:
                case 8767:
                case 8768:
                case 8769:
                case 8770:
                case 8772:
                case 8773:
                case 8774:
                case 8775:
                case 8776:
                case 8777:
                case 8778:
                case 8779:
                case 8780:
                case 8781:
                case 8782:
                case 8783:
                case 8784:
                case 8785:
                case 8790:
                case 8791:
                case 8792:
                case 8793:
                case 8794:
                case 8795:
                case 8796:
                case 8797:
                case 8798:
                case 8799:
                case 8800:
                case 8801:
                case 8802:
                case 8803:
                case 8812:
                case 8813:
                case 8844:
                case 8845:
                case 8846:
                case 8851:
                case 8852:
                case 8853:
                case 8854:
                case 8855:
                case 8857:
                case 8858:
                case 8859:
                case 8860:
                case 8861:
                case 8862:
                case 8863:
                case 8864:
                case 8865:
                case 8868:
                case 8869:
                case 8871:
                case 8874:
                case 8876:
                case 8877:
                case 8878:
                case 8879:
                case 8888:
                case 8889:
                case 8890:
                case 8891:
                case 8892:
                case 8893:
                case 8894:
                case 8895:
                case 8896:
                case 8897:
                case 8898:
                case 8899:
                case 8900:
                case 8901:
                case 8902:
                case 8903:
                case 8904:
                case 8910:
                case 8911:
                case 8914:
                case 8915:
                case 8916:
                case 8917:
                case 8942:
                case 8943:
                case 8949:
                case 8952:
                case 8953:
                case 8959:
                case 8960:
                case 8961:
                case 8962:
                case 8963:
                case 8964:
                case 8965:
                case 8966:
                case 8967:
                case 8972:
                case 8973:
                case 8974:
                case 8975:
                case 8976:
                case 8977:
                case 8978:
                case 8979:
                case 8980:
                case 8981:
                case 8982:
                case 8983:
                case 8984:
                case 8985:
                case 8986:
                case 8987:
                case 8988:
                case 8989:
                case 8990:
                case 8991:
                case 8992:
                case 8993:
                case 8994:
                case 8995:
                case 8996:
                case 8997:
                case 8998:
                case 8999:
                case 9000:
                  goto LABEL_100;
                default:
                  if ((v46 - 10179) <= 0x2C
                    && ((1 << (v46 + 61)) & 0x1FFF8C0C006FLL) != 0
                    || (v46 - 10088) < 0xE)
                  {
                    goto LABEL_98;
                  }
                  break;
              }
              goto LABEL_100;
            }
            if ((int)v46 <= 3897)
            {
              if ((v46 - 60) <= 0x3F
                && ((1 << (v46 - 60)) & 0x8000000280000005) != 0
                || (v46 - 125) <= 0x3E
                && ((1 << (v46 - 125)) & 0x4000400000000001) != 0)
              {
                goto LABEL_98;
              }
              unsigned int v47 = v46 - 40;
              goto LABEL_74;
            }
            if ((int)v46 <= 8248)
            {
              if ((v46 - 3898) < 4) {
                goto LABEL_98;
              }
              unsigned int v47 = v46 - 5787;
LABEL_74:
              if (v47 < 2) {
                goto LABEL_98;
              }
              goto LABEL_100;
            }
            if ((v46 - 8249) <= 0xD && ((1 << (v46 - 57)) & 0x3003) != 0
              || (v46 - 8317) <= 0x11 && ((1 << (v46 - 125)) & 0x30003) != 0)
            {
              goto LABEL_98;
            }
          }
LABEL_100:
          CFIndex v20 = (char *)v61[0] + 1;
          v61[0] = v20;
          if ((uint64_t)v20 >= (uint64_t)v44) {
            goto LABEL_101;
          }
        }
      }
LABEL_102:
      char v4 = v54;
      CFIndex length = v55;
      uint64_t v7 = v53;
    }
  }
  v51.CFIndex location = location;
  v51.CFIndex length = length;

  return TLine::SetLevelRange(v7, v51, v4, 0);
}

uint64_t TBidiEngine::ReplaceCharAtIndex(TBidiEngine *this, TRun *a2, const __CTFont *a3, uint64_t a4)
{
  unsigned int v16 = a3;
  unsigned __int16 v15 = 0;
  uint64_t result = GetGlyphsForLongCharacters(a2, &v16, &v15, 1);
  uint64_t v7 = v15;
  if (v15)
  {
    uint64_t GlyphIndexForChar = TRun::GetGlyphIndexForCharIndex<false>((uint64_t)this, a4);
    uint64_t v9 = (char *)this + 192;
    [*((id *)this + 27) setGlyph:v7 atIndex:*((void *)this + 25) + GlyphIndexForChar];
    char v10 = *((unsigned char *)this + 225);
    if (v7 == 0xFFFF && (v10 & 2) != 0) {
      *((unsigned char *)this + 225) = v10 | 8;
    }
    CFIndex v12 = (TBidiEngine *)((char *)this + 40);
    uint64_t v13 = *(void *)(atomic_load_explicit((atomic_ullong *volatile)this + 7, memory_order_acquire) + 40);
    uint64_t RenderingStyle = TAttributes::GetRenderingStyle(v12);
    return TStorageRange::ResetAdvance((uint64_t)v9, GlyphIndexForChar, v13, RenderingStyle);
  }
  return result;
}

void TDescriptorSource::PurgeFontFallbacksCache(TDescriptorSource *this)
{
  os_unfair_lock_lock_with_options();
  uint64_t v1 = TDescriptorSource::sFontFallbacksCache;
  if (TDescriptorSource::sFontFallbacksCache)
  {
    std::__hash_table<std::__hash_value_type<unsigned long,std::unique_ptr<CharRangeToDescriptorMap>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::unique_ptr<CharRangeToDescriptorMap>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::unique_ptr<CharRangeToDescriptorMap>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::unique_ptr<CharRangeToDescriptorMap>>>>::~__hash_table(TDescriptorSource::sFontFallbacksCache + 24);

    MEMORY[0x1853275C0](v1, 0x10E0C400A71E039);
    TDescriptorSource::sFontFallbacksCache = 0;
  }

  os_unfair_lock_unlock(&TDescriptorSource::sFontFallbacksLock);
}

void TDescriptorSource::PurgeSplicedFontStash(TDescriptorSource *this)
{
  os_unfair_lock_lock_with_options();
  uint64_t v1 = (void *)TDescriptorSource::sSplicedFonts;
  if (TDescriptorSource::sSplicedFonts)
  {
    TDescriptorSource::sSplicedFonts = (uint64_t)0;
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&TDescriptorSource::sSplicedFontsLock);
}

__CFString *CTFontDescriptorGetContentSizeCategoryFromIndex(unsigned int a1)
{
  if (a1 > 0xB) {
    uint64_t v1 = kCTFontContentSizeCategoryL;
  }
  else {
    uint64_t v1 = off_1E528B6F0[a1];
  }
  return *v1;
}

void TDescriptorSource::CreateVariantWithTraitsMatchingDescriptors(TDescriptorSource *this@<X0>, const __CFArray *a2@<X1>, void *a3@<X8>)
{
  TTraitsValues v15 = *(TTraitsValues *)__const__ZN17TDescriptorSource42CreateVariantWithTraitsMatchingDescriptorsEPK9__CFArrayPK14__CFDictionary_traitsValues;
  TTraitsValues::TTraitsValues(&v15, a2);
  if (a2)
  {
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a2, @"NSCTFontSymbolicTrait");
    if (Value)
    {
      CFNumberRef v8 = Value;
      BOOL v9 = CFDictionaryContainsKey(a2, @"NSCTFontWeightTrait") == 0;
      int v10 = (CFDictionaryContainsKey(a2, @"NSCTFontSlantTrait") == 0) | (2 * v9);
      unsigned int v11 = CFDictionaryContainsKey(a2, @"NSCTFontProportionTrait") ? v10 : v10 | 0x40;
      if (v11)
      {
        int valuePtr = -1431655766;
        CFNumberGetValue(v8, kCFNumberIntType, &valuePtr);
        double v12 = 0.06944444;
        double v13 = 0.0;
        if ((valuePtr & 1) == 0) {
          double v12 = 0.0;
        }
        double v14 = -0.2;
        if ((valuePtr & 0x40) == 0) {
          double v14 = 0.0;
        }
        if ((valuePtr & 0x20) != 0) {
          double v14 = 0.2;
        }
        if ((v11 & 2) != 0)
        {
          if ((valuePtr & 2) != 0) {
            double v13 = 0.400000006;
          }
          v15.var1 = v13;
        }
        if (v11) {
          v15.var3 = v12;
        }
        if (v11 >= 0x40) {
          v15.var2 = v14;
        }
      }
    }
  }
  TBaseFont::CreateVariantWithTraitsMatchingDescriptors(&v15, this, a3);
}

void TDescriptorSource::CreateDefaultDescriptor(int a1@<W1>, void *a2@<X8>)
{
  id v8 = (id)0xAAAAAAAAAAAAAAAALL;
  TDescriptorSource::CreateDescriptorForUIType((TDescriptorSource *)(2 * (a1 != 0)), 0.0, 0, &v8);
  char v4 = (TDescriptor **)(id)atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire);
  uint64_t v5 = v4;
  uint64_t v6 = v4[5];
  if ((*((_DWORD *)v6 + 4) & 0x80000000) == 0) {
    TDescriptor::InitBaseFont(v4[5], 16 * (a1 == 0), 0.0);
  }
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)v6 + 4, memory_order_acquire);

  if (explicit)
  {
    *a2 = atomic_exchange((atomic_ullong *volatile)&v8, 0);
  }
  else
  {
    CFLog();
    TDescriptorSource::CopyLastResort(a2);
  }
}

void TDescriptorSource::CopyLastResort(void *a1@<X8>)
{
  if (qword_1EB2CE1B0 != -1) {
    dispatch_once_f(&qword_1EB2CE1B0, 0, (dispatch_function_t)TDescriptorSource::CopyLastResort(void)const::$_0::__invoke);
  }
  id v3 = (id)qword_1EB2CE1A8;
  *a1 = atomic_exchange((atomic_ullong *volatile)&v3, 0);
}

CTFontDescriptor *TCFBase_NEW<CTFontDescriptor,CGFont *&,__CFDictionary const*>@<X0>(CGFont **a1@<X0>, const __CFDictionary **a2@<X1>, void *a3@<X8>)
{
  uint64_t result = (CTFontDescriptor *)TCFBase<TDescriptor>::Allocate(96);
  if (result) {
    CTFontDescriptor::CTFontDescriptor(result, *a1, *a2);
  }
  *a3 = 0;
  return result;
}

void TDescriptorSource::CopyAllDescriptorsInternal(atomic_ullong **this@<X0>, CFComparisonResult (__cdecl *a2)(const void *, const void *, void *)@<X2>, char a3@<W1>, void *a4@<X8>)
{
  CFArrayRef v8 = (const __CFArray *)XTCopyAvailableFontURLs();
  id Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  if ((a3 & 2) != 0)
  {
    if (!v8) {
      goto LABEL_23;
    }
    goto LABEL_18;
  }
  if (v8)
  {
    CFIndex Count = CFArrayGetCount(v8);
    if (Count)
    {
      CFIndex v10 = Count;
      for (CFIndex i = 0; i != v10; ++i)
      {
        CFURLRef ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex(v8, i);
        id v25 = (id)0xAAAAAAAAAAAAAAAALL;
        TDescriptorSource::CopyDescriptorUncached(this, ValueAtIndex, &v25);
        if (atomic_load_explicit((atomic_ullong *volatile)&v25, memory_order_acquire))
        {
          double v13 = (TDescriptor **)(id)atomic_load_explicit((atomic_ullong *volatile)&v25, memory_order_acquire);
          double v14 = v13;
          TTraitsValues v15 = v13[5];
          if ((*((_DWORD *)v15 + 4) & 0x80000000) == 0) {
            TDescriptor::InitBaseFont(v13[5], 0, 0.0);
          }
          unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)v15 + 4, memory_order_acquire);

          if (((*(uint64_t (**)(unint64_t))(*(void *)explicit + 696))(explicit) & 1) == 0)
          {
            id v17 = (id)atomic_load_explicit((atomic_ullong *volatile)&v25, memory_order_acquire);
            CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), v17);
          }
        }
      }
    }
  }
  if (CFArrayGetCount((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire))) {
    BOOL v18 = 1;
  }
  else {
    BOOL v18 = v8 == 0;
  }
  if (!v18)
  {
LABEL_18:
    CFIndex v19 = CFArrayGetCount(v8);
    if (v19)
    {
      CFIndex v20 = v19;
      for (CFIndex j = 0; j != v20; ++j)
      {
        CFURLRef v22 = (const __CFURL *)CFArrayGetValueAtIndex(v8, j);
        id v25 = (id)0xAAAAAAAAAAAAAAAALL;
        TDescriptorSource::CopyDescriptorUncached(this, v22, &v25);
        if (atomic_load_explicit((atomic_ullong *volatile)&v25, memory_order_acquire))
        {
          id v23 = (id)atomic_load_explicit((atomic_ullong *volatile)&v25, memory_order_acquire);
          CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), v23);
        }
      }
    }
  }
LABEL_23:
  if (a2)
  {
    long long v24 = (__CFArray *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
    v27.CFIndex length = CFArrayGetCount((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire));
    v27.CFIndex location = 0;
    CFArraySortValues(v24, v27, a2, 0);
  }
  *a4 = atomic_exchange((atomic_ullong *volatile)&Mutable, 0);
}

id TDescriptorSource::CopyAllDescriptorsSorted@<X0>(atomic_ullong **this@<X0>, char a2@<W1>, void *a3@<X8>)
{
  uint64_t v4 = 40;
  if ((a2 & 2) == 0) {
    uint64_t v4 = 32;
  }
  int v5 = TGenerationSeed::sGeneration;
  unint64_t explicit = (void *)atomic_load_explicit((atomic_ullong *volatile)&_MergedGlobals_16[v4], memory_order_acquire);
  if (explicit) {
    BOOL v7 = dword_1EB2CE164 == v5;
  }
  else {
    BOOL v7 = 0;
  }
  if (!v7)
  {
    TDescriptorSource::CopyAllDescriptorsInternal(this, (CFComparisonResult (__cdecl *)(const void *, const void *, void *))CompareDescriptorsByTraitsAndPrecedence, a2, &v14);
    unint64_t v9 = atomic_exchange((atomic_ullong *volatile)&v14, 0);

    if ((a2 & 2) != 0) {
      CFIndex v10 = (atomic_ullong *)&unk_1EB2CE188;
    }
    else {
      CFIndex v10 = (atomic_ullong *)&unk_1EB2CE180;
    }
    unsigned int v11 = explicit;
    atomic_compare_exchange_strong(v10, (unint64_t *)&v11, v9);
    if (v11 == explicit) {
      double v12 = explicit;
    }
    else {
      double v12 = (void *)v9;
    }
    if (v11 == explicit) {
      unint64_t explicit = (void *)v9;
    }
    else {
      unint64_t explicit = v11;
    }

    dword_1EB2CE164 = v5;
  }
  id result = explicit;
  *a3 = result;
  return result;
}

CFComparisonResult CompareDescriptorsByTraitsAndPrecedence(void *a1, void *a2, void *a3)
{
  return CompareLocalizedDescriptorsByTraitsAndPrecedence(a1, a2, a3, 0, 1, 1);
}

void TDescriptorSource::CopyAvailablePostScriptNames(atomic_ullong **this@<X0>, CFArrayRef *a2@<X8>)
{
  id v5 = (id)0xAAAAAAAAAAAAAAAALL;
  TDescriptorSource::CopyAllDescriptorsInternal(this, 0, 0, &v5);
  if (!atomic_load_explicit((atomic_ullong *volatile)&v5, memory_order_acquire)) {
    goto LABEL_5;
  }
  id Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D548]);
  CFArrayRef explicit = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v5, memory_order_acquire);
  v6.CFIndex length = CFArrayGetCount((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v5, memory_order_acquire));
  v6.CFIndex location = 0;
  CFArrayApplyFunction(explicit, v6, (CFArrayApplierFunction)AddPostScriptNameToSetForDescriptor, &Mutable);
  if (CFSetGetCount((CFSetRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire)) < 1)
  {

LABEL_5:
    *a2 = 0;
    goto LABEL_6;
  }
  CreateSortedArrayWithSet((CFSetRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), (CFComparisonResult (__cdecl *)(const void *, const void *, void *))TDescriptorSource::ComparePostScriptNames, 0, a2);

LABEL_6:
}

void AddPostScriptNameToSetForDescriptor(const void *a1, atomic_ullong *a2)
{
  uint64_t v3 = *((void *)a1 + 5);
  if ((*(_DWORD *)(v3 + 16) & 0x80000000) == 0) {
    TDescriptor::InitBaseFont(*((TDescriptor **)a1 + 5), 0, 0.0);
  }
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(v3 + 32), memory_order_acquire);
  if (explicit)
  {
    id v5 = (id)atomic_load_explicit((atomic_ullong *volatile)(explicit + 96), memory_order_acquire);
    if (v5) {
      CFSetAddValue((CFMutableSetRef)atomic_load_explicit(a2, memory_order_acquire), v5);
    }
  }
}

CFComparisonResult TDescriptorSource::ComparePostScriptNames(const __CFString *this, const __CFString *a2, const void *a3, void *a4)
{
  return CFStringCompare(this, a2, 0x40uLL);
}

void TDescriptorSource::CopyAvailableFamilyNames(void *a1@<X8>)
{
  CFArrayRef v4 = (const __CFArray *)GSFontCopyFamilyNames();
  if (v4)
  {
    CFArrayRef v5 = v4;
    id MutableCopy = CFArrayCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v4);
    CFRelease(v5);
    unint64_t explicit = (__CFArray *)atomic_load_explicit((atomic_ullong *volatile)&MutableCopy, memory_order_acquire);
    v8.CFIndex length = CFArrayGetCount((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&MutableCopy, memory_order_acquire));
    v8.CFIndex location = 0;
    CFArraySortValues(explicit, v8, (CFComparatorFunction)TDescriptorSource::CompareFamilyNames, 0);
    *a1 = atomic_exchange((atomic_ullong *volatile)&MutableCopy, 0);
  }
  else
  {
    *a1 = 0;
  }
}

CFComparisonResult TDescriptorSource::CompareFamilyNames(const __CFString *this, const __CFString *a2, const void *a3, void *a4)
{
  if (this == a2) {
    return 0;
  }
  if (this && a2) {
    return CFStringCompare(this, a2, 0x61uLL);
  }
  if (this < a2) {
    return -1;
  }
  return 1;
}

void TDescriptorSource::CopyEmojiFontDescriptor(CFArrayRef theArray@<X1>, atomic_ullong **a2@<X0>, int a3@<W2>, atomic_ullong *a4@<X8>)
{
  if (theArray)
  {
    CFIndex Count = CFArrayGetCount(theArray);
    if (Count)
    {
      CFIndex v9 = Count;
      for (CFIndex i = 0; v9 != i; ++i)
      {
        CFURLRef ValueAtIndex = (const __CTFontDescriptor *)CFArrayGetValueAtIndex(theArray, i);
        if ((CTFontDescriptorGetSymbolicTraits((uint64_t)ValueAtIndex) & 0x2000) != 0)
        {
          id v17 = (id)CTFontDescriptorCopyAttribute(ValueAtIndex, @"NSCTFontCharacterSetAttribute");
          CFCharacterSetRef v12 = (const __CFCharacterSet *)atomic_exchange((atomic_ullong *volatile)&v17, 0);

          if (CFCharacterSetIsCharacterMember(v12, 0xFE0Fu))
          {
            *a4 = (atomic_ullong)ValueAtIndex;
            id v16 = v12;
            goto LABEL_22;
          }
        }
      }
    }
  }
  double v13 = _CTGetEmojiFontName(a3 == 1);
  if (a3 == 1)
  {
    if ((dyld_program_sdk_at_least() & 1) == 0)
    {
      id v14 = _CTGetEmojiFontName(1);
      if (v14 == v13 || v13 && v14 && CFEqual(v13, v14)) {
        double v13 = _CTGetEmojiFontName(0);
      }
    }
    unint64_t explicit = (void *)atomic_load_explicit(&TDescriptorSource::CopyEmojiFontDescriptor(__CFArray const*,UIFontFlag)const::sEmojiUIFont, memory_order_acquire);
    if (!explicit)
    {
      id v17 = (id)0xAAAAAAAAAAAAAAAALL;
      TDescriptorSource::CopySystemFontDescriptorByName(a2, v13, 1, 0, (atomic_ullong *)&v17);
      atomic_compare_exchange_strong(&TDescriptorSource::CopyEmojiFontDescriptor(__CFArray const*,UIFontFlag)const::sEmojiUIFont, (unint64_t *)&explicit, atomic_load_explicit((atomic_ullong *volatile)&v17, memory_order_acquire));
      if (!explicit) {
        unint64_t explicit = (void *)atomic_exchange((atomic_ullong *volatile)&v17, 0);
      }
    }
    id v17 = explicit;
    *a4 = atomic_exchange((atomic_ullong *volatile)&v17, 0);
    id v16 = v17;
LABEL_22:
  }
  else
  {
    TDescriptorSource::CopySystemFontDescriptorByName(a2, v13, a3, 0, a4);
  }
}

void TDescriptorSource::CopySystemFontDescriptorByName(atomic_ullong **a1@<X0>, const __CFString *a2@<X1>, int a3@<W2>, uint64_t a4@<X3>, atomic_ullong *a5@<X8>)
{
  if (a3 == 1) {
    unint64_t v8 = 1031;
  }
  else {
    unint64_t v8 = 7;
  }
  *a5 = 0xAAAAAAAAAAAAAAAALL;
  TDescriptorSource::CopyFontDescriptorPerPostScriptName(a1, a2, v8, a4 | 7, 0, a5);
  if (!atomic_load_explicit(a5, memory_order_acquire))
  {
    TDescriptorSource::CopyFontDescriptorPerPostScriptName(a1, a2, v8 & 0xFFFFFFFFFFFFFC03, 0, 0, &v9);
  }
}

void TDescriptorSource::CopyEmojiFontDescriptor(TDescriptorSource *this@<X0>, const __CFArray *a2@<X1>, const __CTFontDescriptor *a3@<X2>, void *a4@<X8>)
{
  uint64_t v7 = *((void *)a3 + 5);
  int v8 = *(_DWORD *)(v7 + 16);
  BOOL v9 = (TDescriptor::GetSystemUIFontOptions(this) & v8) != 0;
  TDescriptorSource::CopyEmojiFontDescriptor(a2, (atomic_ullong **)this, v9, (atomic_ullong *)&keys);
  id v13 = (id)atomic_exchange((atomic_ullong *volatile)&keys, 0);

  TDescriptor::CopyAttribute((atomic_ullong *)v7, @"CTFontEmojiMLUpscalingTimeoutAttribute", &keys);
  CFIndex v10 = (void *)atomic_exchange((atomic_ullong *volatile)&keys, 0);

  if (v10)
  {
    id values = v10;
    id keys = @"CTFontEmojiMLUpscalingTimeoutAttribute";
    CFDictionaryRef v11 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    id values = (void *)atomic_load_explicit((atomic_ullong *volatile)&v13, memory_order_acquire);
    CFDictionaryRef v12 = v11;
    TCFBase_NEW<CTFontDescriptor,CTFontDescriptor*,__CFDictionary const*&>((uint64_t *)&values, &v12, &keys);
  }
  *a4 = atomic_exchange((atomic_ullong *volatile)&v13, 0);
}

void TDescriptorSource::CopySystemWideFallbackDescriptorForCharacters(atomic_ullong **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, int a5@<W4>, uint64_t a6@<X5>, atomic_ullong *a7@<X8>)
{
  uint64_t v7 = a7;
  v83[16] = *(id *)MEMORY[0x1E4F143B8];
  if (!a3 || (uint64_t v8 = a6) == 0 || (v9 = a4, a4 < 1))
  {
LABEL_123:
    atomic_ullong *v7 = 0;
    return;
  }
  uint64_t v10 = a3;
  uint64_t v11 = 0;
  CFStringRef v74 = (const __CFString *)*MEMORY[0x1E4F1CFC8];
  while (1)
  {
    uint64_t v12 = v11 + 1;
    UTF32Char v13 = *(unsigned __int16 *)(v10 + 2 * v11);
    BOOL v14 = (v13 & 0xFC00) != 0xD800 || v12 == v9;
    if (v14 || (int v15 = *(unsigned __int16 *)(v10 + 2 * v12), (v15 & 0xFC00) != 0xDC00))
    {
      if (v13 < 0xE000) {
        goto LABEL_20;
      }
      if (v13 >> 11 >= 0x1F) {
        goto LABEL_17;
      }
    }
    else
    {
      uint64_t v12 = v11 + 2;
      UTF32Char v16 = v15 + (v13 << 10);
      UTF32Char v13 = v16 - 56613888;
      if (v16 - 56613888 < 0xF0000 || v16 - 57727998 > 0xFFFFFC01) {
        break;
      }
    }
    if (v13 != 1051575 && v13 - 57345 > 0x536) {
      goto LABEL_116;
    }
LABEL_17:
    if (v13 < 0xFE0E) {
      goto LABEL_20;
    }
    if (v13 >> 4 >= 0xFE1) {
      break;
    }
LABEL_116:
    uint64_t v11 = v12;
    if (v12 >= v9) {
      goto LABEL_123;
    }
  }
  if (v13 - 127995 < 5) {
    goto LABEL_116;
  }
LABEL_20:
  uint64_t v73 = v10 + 2 * v11;
  if (v13 - 57345 < 0x537) {
    goto LABEL_21;
  }
  if (qword_1EB2CE210 != -1) {
    dispatch_once_f(&qword_1EB2CE210, 0, (dispatch_function_t)GetSystemFontsComboCharacterSet(void)::$_0::__invoke);
  }
  if (qword_1EB2CE208 && !CFCharacterSetIsLongCharacterMember((CFCharacterSetRef)qword_1EB2CE208, v13))
  {
LABEL_21:
    if (qword_1EB2CE1C0 != -1) {
      dispatch_once_f(&qword_1EB2CE1C0, 0, (dispatch_function_t)TDescriptorSource::GetAppleColorEmojiCharacterSet(void)const::$_0::__invoke);
    }
    if (qword_1EB2CE1B8 && CFCharacterSetIsLongCharacterMember((CFCharacterSetRef)qword_1EB2CE1B8, v13))
    {
      TDescriptorSource::CopyEmojiFontDescriptor(0, a1, a5, v7);
      return;
    }
    goto LABEL_116;
  }
  id v77 = 0;
  unint64_t v17 = 113;
  BOOL v18 = &TDescriptorSource::CopySystemWideFallbackDescriptorForCharacters(TBaseFont const&,unsigned short const*,long,UIFontFlag,unsigned long,CTEmojiPolicy,TCFRef<__CFArray const*> *)const::kNotoRanges;
  do
  {
    unint64_t v19 = v17 >> 1;
    CFIndex v20 = &v18[2 * (v17 >> 1)];
    signed int v21 = *((_DWORD *)v20 + 3);
    CFURLRef v22 = v20 + 2;
    v17 += ~(v17 >> 1);
    if (v21 >= (int)v13) {
      unint64_t v17 = v19;
    }
    else {
      BOOL v18 = v22;
    }
  }
  while (v17);
  if (v18 != sPingFangFacesMap && *((_DWORD *)v18 + 2) <= (signed int)v13 && *((_DWORD *)v18 + 3) >= (signed int)v13)
  {
    CFStringRef v23 = *v18;
    CFStringRef v66 = v74;
    TDescriptorSource::CopyFontDescriptorPerPostScriptName(a1, *v18, 0x10012uLL, 9, 0, v83);

    if (!atomic_load_explicit((atomic_ullong *volatile)&v77, memory_order_acquire)) {
      goto LABEL_44;
    }
    long long v24 = (TDescriptor **)(id)atomic_load_explicit((atomic_ullong *volatile)&v77, memory_order_acquire);
    id v25 = v24;
    uint64_t v26 = v24[5];
    if ((*((_DWORD *)v26 + 4) & 0x80000000) == 0) {
      TDescriptor::InitBaseFont(v24[5], 0, 0.0);
    }
    unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)v26 + 4, memory_order_acquire);

    uint64_t v10 = a3;
    if (!explicit)
    {
LABEL_44:
      CFStringRef v66 = v23;
      CFLog();
      goto LABEL_45;
    }
    if (!(*(uint64_t (**)(unint64_t, uint64_t, uint64_t, void))(*(void *)explicit + 808))(explicit, a3, v9, 0))LABEL_45:(id)atomic_exchange((atomic_ullong *volatile)&v77, 0); {
  }
    }
  if (atomic_load_explicit((atomic_ullong *volatile)&v77, memory_order_acquire)) {
    goto LABEL_110;
  }
  if (ShouldUseLastResort(v13)) {
    goto LABEL_124;
  }
  if (qword_1EB2CE198 != -1) {
    dispatch_once_f(&qword_1EB2CE198, 0, (dispatch_function_t)TDescriptorSource::CopySystemWideFallbackDescriptorconst::$_0::__invoke);
  }
  uint64_t v28 = (void *)qword_1EB2CE190;
  if (qword_1EB2CE190)
  {
    WORD1(v78) = -21846;
    if (v13 - 1114112 >= 0xFFF00000)
    {
      unsigned int v29 = ((v13 + 67043328) >> 10) - 10240;
      WORD1(v78) = v13 & 0x3FF | 0xDC00;
    }
    else
    {
      LOWORD(v29) = v13;
    }
    LOWORD(v78) = v29;
    *(_OWORD *)v79 = 0u;
    long long v80 = 0u;
    long long v81 = 0u;
    long long v82 = 0u;
    uint64_t v30 = objc_msgSend((id)qword_1EB2CE190, "countByEnumeratingWithState:objects:count:", v79, v83, 16, v66);
    if (v30)
    {
      uint64_t v31 = v30;
      uint64_t v32 = *(void *)v80;
      if (v13 - 1114112 < 0xFFF00000) {
        uint64_t v33 = 1;
      }
      else {
        uint64_t v33 = 2;
      }
      do
      {
        for (uint64_t i = 0; i != v31; ++i)
        {
          if (*(void *)v80 != v32) {
            objc_enumerationMutation(v28);
          }
          uint64_t v35 = (__CFString *)*((void *)v79[1] + i);
          objc_opt_class();
          if (objc_opt_isKindOfClass())
          {
            UTF32Char v36 = objc_msgSend((id)-[__CFString objectAtIndexedSubscript:](v35, "objectAtIndexedSubscript:", 0), "unsignedIntValue");
            UTF32Char v37 = objc_msgSend((id)-[__CFString objectAtIndexedSubscript:](v35, "objectAtIndexedSubscript:", 1), "unsignedIntValue");
            if (v36 > v13 || v37 < v13) {
              continue;
            }
            uint64_t v35 = (__CFString *)[(__CFString *)v35 objectAtIndexedSubscript:2];
          }
          else
          {
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) == 0) {
              continue;
            }
          }
          if (v35)
          {
            id v76 = (id)0xAAAAAAAAAAAAAAAALL;
            CFStringRef v66 = v74;
            TDescriptorSource::CopyFontDescriptorPerPostScriptName(a1, v35, 0x10000uLL, 8, 0, &v76);
            if (atomic_load_explicit((atomic_ullong *volatile)&v76, memory_order_acquire))
            {
              v39 = (TDescriptor **)(id)atomic_load_explicit((atomic_ullong *volatile)&v76, memory_order_acquire);
              v40 = v39;
              char v41 = v39[5];
              if ((*((_DWORD *)v41 + 4) & 0x80000000) == 0) {
                TDescriptor::InitBaseFont(v39[5], 0, 0.0);
              }
              unint64_t v42 = atomic_load_explicit((atomic_ullong *volatile)v41 + 4, memory_order_acquire);

              if ((*(uint64_t (**)(unint64_t, id *, uint64_t, void))(*(void *)v42 + 808))(v42, &v78, v33, 0))
              {
                uint64_t v8 = a6;
                uint64_t v7 = a7;
                uint64_t v9 = a4;
                uint64_t v10 = a3;
                goto LABEL_90;
              }
            }
          }
        }
        uint64_t v31 = [v28 countByEnumeratingWithState:v79 objects:v83 count:16];
      }
      while (v31);
    }
    uint64_t v8 = a6;
    uint64_t v7 = a7;
  }
  os_unfair_lock_lock_with_options();
  uint64_t v9 = a4;
  if (!qword_1EB2CE1A0 || (CFIndex Count = CFArrayGetCount((CFArrayRef)qword_1EB2CE1A0), Count < 1))
  {
LABEL_87:
    id v76 = 0;
    goto LABEL_88;
  }
  CFIndex v44 = Count;
  CFIndex v45 = 0;
  while (2)
  {
    CFURLRef ValueAtIndex = (TDescriptor **)CFArrayGetValueAtIndex((CFArrayRef)qword_1EB2CE1A0, v45);
    unsigned int v47 = ValueAtIndex;
    int v48 = ValueAtIndex[5];
    if ((*((_DWORD *)v48 + 4) & 0x80000000) == 0) {
      TDescriptor::InitBaseFont(ValueAtIndex[5], 0, 0.0);
    }
    unint64_t v49 = atomic_load_explicit((atomic_ullong *volatile)v48 + 4, memory_order_acquire);
    if (!v49)
    {
LABEL_86:
      if (v44 == ++v45) {
        goto LABEL_87;
      }
      continue;
    }
    break;
  }
  id v78 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr))(*(void *)v49 + 184))(&v78);
  if (!CFCharacterSetIsLongCharacterMember((CFCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v78, memory_order_acquire), v13))
  {

    goto LABEL_86;
  }
  id v76 = v47;

LABEL_88:
  os_unfair_lock_unlock(&stru_1EB2CE168);
  uint64_t v10 = a3;
LABEL_90:

  if (atomic_load_explicit((atomic_ullong *volatile)&v77, memory_order_acquire))
  {
LABEL_110:
    if (atomic_load_explicit((atomic_ullong *volatile)&v77, memory_order_acquire))
    {
      uint64_t v60 = (TDescriptor **)(id)atomic_load_explicit((atomic_ullong *volatile)&v77, memory_order_acquire);
      v61 = v60;
      long long v62 = v60[5];
      if ((*((_DWORD *)v62 + 4) & 0x80000000) == 0) {
        TDescriptor::InitBaseFont(v60[5], 0, 0.0);
      }
      unint64_t v63 = (atomic_uint *)atomic_load_explicit((atomic_ullong *volatile)v62 + 4, memory_order_acquire);

      uint64_t v10 = a3;
      if (v63)
      {
        if (((*(uint64_t (**)(atomic_uint *, uint64_t))(*(void *)v63 + 32))(v63, a2) & 1) == 0)
        {
          if (a5)
          {
            uint64_t v65 = TCFBase<TDescriptor>::Allocate();
            if (v65)
            {
              *(void *)(v65 + 16) = 0;
              *(void *)(v65 + 24) = TDescriptor::Hash;
              *(void *)(v65 + 32) = 0;
              *(void *)(v65 + 40) = v65 + 48;
              *(void *)(v65 + 48) = &unk_1ED05D778;
              *(void *)(v65 + 56) = 0;
              *(_DWORD *)(v65 + 64) = -2147482624;
              *(void *)(v65 + 72) = 0;
              atomic_fetch_add_explicit(v63 + 2, 1u, memory_order_relaxed);
              *(void *)(v65 + 80) = v63;
              *(void *)(v65 + 88) = 0;
              v83[0] = (id)v65;
              v79[0] = (id)atomic_exchange((atomic_ullong *volatile)v83, 0);
            }
            else
            {
              v79[0] = 0;
            }
            atomic_ullong *v7 = atomic_exchange((atomic_ullong *volatile)v79, 0);
          }
          else
          {
            atomic_ullong *v7 = atomic_exchange((atomic_ullong *volatile)&v77, 0);
          }
          goto LABEL_131;
        }
      }
    }

    goto LABEL_116;
  }
  Table = GetTable();
  if (!Table || !Table[16])
  {
    v83[0] = (id)0xAAAAAAAAAAAAAAAALL;
    if (getenv("CT_PRESET_FALLBACKS_AND_COMBO_CHARSETS_GENERATION")) {
      TDescriptorSource::CopyAllDescriptorsSorted(a1, 2, v83);
    }
    else {
      TDescriptorSource::CopyAllDescriptorsInternal(a1, 0, 2, v83);
    }
    CFArrayRef v51 = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)v83, memory_order_acquire);
    if (v51)
    {
      CFIndex v52 = CFArrayGetCount(v51);
      if (v52)
      {
        CFIndex v53 = v52;
        CFIndex v54 = 0;
        uint64_t v55 = v12 - v11;
        while (1)
        {
          CFIndex v56 = (TDescriptor **)CFArrayGetValueAtIndex(v51, v54);
          CFIndex v57 = v56;
          v58 = v56[5];
          if ((*((_DWORD *)v58 + 4) & 0x80000000) == 0) {
            TDescriptor::InitBaseFont(v56[5], 0, 0.0);
          }
          unsigned __int16 v59 = (TBaseFont *)atomic_load_explicit((atomic_ullong *volatile)v58 + 4, memory_order_acquire);
          if (v59
            && ((*(uint64_t (**)(TBaseFont *))(*(void *)v59 + 688))(v59) & 1) == 0
            && (v8 == 3 || !TBaseFont::IsUserInstalled(v59)))
          {
            if ((*(uint64_t (**)(TBaseFont *, uint64_t, uint64_t, void))(*(void *)v59 + 808))(v59, v73, v55, 0))
            {
              break;
            }
          }
          if (v53 == ++v54) {
            goto LABEL_107;
          }
        }
        TCFRef<__CTFont const*>::Retain((atomic_ullong *)&v77, v57);
        os_unfair_lock_lock_with_options();
        CFArrayRef v64 = (const __CFArray *)qword_1EB2CE1A0;
        if (qword_1EB2CE1A0)
        {
          v84.CFIndex length = CFArrayGetCount((CFArrayRef)qword_1EB2CE1A0);
          v84.CFIndex location = 0;
          if (!CFArrayContainsValue(v64, v84, v57)) {
            CFArrayAppendValue((CFMutableArrayRef)qword_1EB2CE1A0, v57);
          }
        }
        os_unfair_lock_unlock(&stru_1EB2CE168);
      }
    }
LABEL_107:
    if (!atomic_load_explicit((atomic_ullong *volatile)&v77, memory_order_acquire)) {
      AddToUseLastResort(v13);
    }

    uint64_t v9 = a4;
    uint64_t v10 = a3;
    goto LABEL_110;
  }
LABEL_124:
  atomic_ullong *v7 = 0;
LABEL_131:
}

uint64_t TDescriptorSource::GetMatchableAttributes(TDescriptorSource *this)
{
  if (qword_1EB2CE1D0 != -1) {
    dispatch_once_f(&qword_1EB2CE1D0, 0, (dispatch_function_t)TDescriptorSource::GetMatchableAttributes(void)::$_0::__invoke);
  }
  return qword_1EB2CE1C8;
}

uint64_t TDescriptorSource::GetMatchableNameAttributes(TDescriptorSource *this)
{
  if (qword_1EB2CE1E0 != -1) {
    dispatch_once_f(&qword_1EB2CE1E0, 0, (dispatch_function_t)TDescriptorSource::GetMatchableNameAttributes(void)::$_0::__invoke);
  }
  return qword_1EB2CE1D8;
}

void CreateDescriptorArrayFilteringDuplicates(CFArrayRef *a1, CFComparisonResult (*a2)(const void *, const void *, void *), CFComparisonResult (__cdecl *a3)(const void *, const void *, void *))
{
  id Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D548]);
  if (a2) {
    objc_msgSend((id)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), "addObjectsFromArray:", a2);
  }
  id v9 = (id)0xAAAAAAAAAAAAAAAALL;
  id v9 = (id)atomic_exchange((atomic_ullong *volatile)&Mutable, 0);
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v7 = v6;
  long long v8 = v6;
  TFontDescriptorDuplicateFilter::TFontDescriptorDuplicateFilter((TFontDescriptorDuplicateFilter *)&v7, (id)atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire), &TFontDescriptorDuplicateFilter::kCTFontDescriptorDuplicateFilterSetCallBacks);
  TFontDescriptorDuplicateFilter::PerformFilter((atomic_ullong *)&v7);
  if (CFSetGetCount((CFSetRef)atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire)) >= 1) {

  }
  CreateSortedArrayWithSet((CFSetRef)atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire), a3, 0, a1);
  TFontDescriptorDuplicateFilter::~TFontDescriptorDuplicateFilter((id *)&v7);
}

void TDescriptorSource::CopyFontDescriptorFromVariationPostScriptName(CFStringRef theString@<X1>, void *a2@<X8>)
{
  uint64_t v121 = *MEMORY[0x1E4F143B8];
  id v112 = 0;
  if (!theString) {
    goto LABEL_78;
  }
  CFIndex Length = CFStringGetLength(theString);
  if (!Length) {
    goto LABEL_78;
  }
  CFIndex v6 = Length;
  CFCharacterSetRef Predefined = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
  v122.CFIndex location = 0;
  v122.CFIndex length = v6;
  if (CFStringFindCharacterFromSet(theString, Predefined, v122, 0, 0)) {
    goto LABEL_78;
  }
  CFIndex location = CFStringFind(theString, @"_", 0).location;
  if (location == -1) {
    goto LABEL_78;
  }
  CFIndex v9 = location;
  CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  v123.CFIndex location = 0;
  v123.CFIndex length = location;
  uint64_t v11 = (__CFString *)CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E4F1CF80], theString, v123);
  id v111 = (id)0xAAAAAAAAAAAAAAAALL;
  TDescriptorSource::CopyFontDescriptorPerPostScriptName(&v111);
  if (!atomic_load_explicit((atomic_ullong *volatile)&v111, memory_order_acquire))
  {
LABEL_77:

LABEL_78:
    *a2 = 0;
    goto LABEL_79;
  }
  uint64_t v12 = (TDescriptor **)(id)atomic_load_explicit((atomic_ullong *volatile)&v111, memory_order_acquire);
  UTF32Char v13 = v12;
  BOOL v14 = v12[5];
  if ((*((_DWORD *)v14 + 4) & 0x80000000) == 0) {
    TDescriptor::InitBaseFont(v12[5], 0, 0.0);
  }
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)v14 + 4, memory_order_acquire);

  id v110 = 0;
  if (!explicit
    || ((*(void (**)(int64x2_t *__return_ptr, unint64_t))(*(void *)explicit + 120))(&v115, explicit), (id)atomic_exchange((atomic_ullong *volatile)&v110, atomic_exchange(v115.i64, 0)), unint64_t v16 = atomic_load_explicit((atomic_ullong *volatile)&v110, memory_order_acquire), (id)v115.i64[0], !v16))
  {
LABEL_76:

    goto LABEL_77;
  }
  *(void *)&long long v17 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v17 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v117[1] = v17;
  v117[0] = v17;
  uint64_t v116 = 0;
  int64x2_t v115 = 0uLL;
  v118 = v117;
  CStringPtr = (char *)CFStringGetCStringPtr(theString, 0x600u);
  if (!CStringPtr)
  {
    CFIndex v19 = CFStringGetLength(theString);
    CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(v19, 0x600u);
    CFIndex v21 = MaximumSizeForEncoding + 1;
    CFURLRef v22 = (char *)v115.i64[0];
    if ((unint64_t)(MaximumSizeForEncoding + 1) <= v115.i64[1] - v115.i64[0])
    {
      if ((unint64_t)(MaximumSizeForEncoding + 1) < v115.i64[1] - v115.i64[0]) {
        v115.i64[1] = v115.i64[0] + v21;
      }
    }
    else
    {
      std::vector<char,TInlineBufferAllocator<char,30ul>>::__append(&v115, MaximumSizeForEncoding + 1 - (v115.i64[1] - v115.i64[0]));
      CFURLRef v22 = (char *)v115.i64[0];
    }
    if (!CFStringGetCString(theString, v22, v21, 0x600u)) {
      goto LABEL_75;
    }
    CStringPtr = (char *)v115.i64[0];
    if (!v115.i64[0]) {
      goto LABEL_75;
    }
  }
  v107 = v11;
  CFStringRef v23 = &CStringPtr[v9];
  unint64_t v24 = strlen(CStringPtr) - v9;
  id v25 = strchr(CStringPtr, 95);
  if (v25)
  {
    uint64_t v26 = v25;
    CFRange v27 = strstr(CStringPtr, "MM");
    if (v27)
    {
      if (v27 <= v26 && v26[1] - 48 <= 9)
      {
        id v113 = (id)0xAAAAAAAAAAAAAAAALL;
        (*(void (**)(id *__return_ptr, unint64_t, uint64_t))(*(void *)explicit + 480))(&v113, explicit, 1296914002);
        unint64_t v28 = atomic_load_explicit((atomic_ullong *volatile)&v113, memory_order_acquire);
        unint64_t v29 = atomic_load_explicit((atomic_ullong *volatile)&v110, memory_order_acquire);
        if (v24 > 0x1F || (int v30 = v24 - 2, v24 < 2))
        {
          uint64_t v33 = 0;
        }
        else
        {
          unint64_t v104 = explicit;
          int v31 = v23[1];
          *(void *)&long long v32 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v32 + 1) = 0xAAAAAAAAAAAAAAAALL;
          long long v120 = v32;
          *(_OWORD *)v119 = v32;
          if (v31 == 46 || (v31 - 48) <= 9)
          {
            CFArrayRef theArray = (const __CFArray *)v29;
            CFDataRef theData = (const __CFData *)v28;
            uint64_t v33 = 0;
            long long v62 = 0;
            v105 = 0;
            unint64_t v63 = (unsigned __int8 *)(v23 + 2);
            do
            {
              id __p = v33;
              uint64_t v64 = 0;
              int v65 = v30;
              do
              {
                v119[v64] = v31;
                int v31 = v63[v64];
                BOOL v66 = (v31 - 48) <= 9 || v31 == 46;
                int v67 = v64++;
              }
              while (v66 && v65 != v67);
              v119[v64] = 0;
              LODWORD(v114) = -1;
              sscanf(v119, "%f", &v114);
              if (v62 >= v105)
              {
                long long v69 = __p;
                uint64_t v70 = (v62 - __p) >> 2;
                unint64_t v71 = v70 + 1;
                if ((unint64_t)(v70 + 1) >> 62) {
                  abort();
                }
                if ((v105 - __p) >> 1 > v71) {
                  unint64_t v71 = (v105 - __p) >> 1;
                }
                long long v72 = (char *)((unint64_t)(v105 - __p) >= 0x7FFFFFFFFFFFFFFCLL ? 0x3FFFFFFFFFFFFFFFLL : v71);
                if (v72)
                {
                  long long v72 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>((unint64_t)v72);
                  long long v69 = __p;
                }
                else
                {
                  uint64_t v73 = 0;
                }
                CFStringRef v74 = &v72[4 * v70];
                *(_DWORD *)CFStringRef v74 = v114;
                long long v75 = v74 + 4;
                while (v62 != v69)
                {
                  int v76 = *((_DWORD *)v62 - 1);
                  v62 -= 4;
                  *((_DWORD *)v74 - 1) = v76;
                  v74 -= 4;
                }
                v105 = &v72[4 * v73];
                if (v69)
                {
                  long long v62 = v75;
                  operator delete(v69);
                  uint64_t v33 = v74;
                }
                else
                {
                  uint64_t v33 = v74;
                  long long v62 = v75;
                }
              }
              else
              {
                *(_DWORD *)long long v62 = v114;
                v62 += 4;
                uint64_t v33 = __p;
              }
              v63 += v64;
              int v30 = v65 - v64;
              BOOL v78 = (v31 - 58) <= 0xFFFFFFF5 && v31 != 46 || v31 == 32;
              if (v78 && v30 + 1 > 0)
              {
                do
                {
                  int v79 = *v63++;
                  int v31 = v79;
                  BOOL v81 = v30-- != 0;
                  BOOL v83 = (v31 - 58) <= 0xFFFFFFF5 && v31 != 46 || v31 == 32;
                }
                while (v83 && v81);
              }
              unint64_t v84 = v62 - v33;
              if ((unint64_t)(v62 - v33) > 0x10) {
                break;
              }
              if (v30 < 0)
              {
                v86 = v33;
                if (v33 == v62)
                {
                  uint64_t v11 = v107;
                  goto LABEL_81;
                }
                if (CFArrayGetCount(theArray) >= v84 >> 2
                  && theData
                  && (BytePtr = CFDataGetBytePtr(theData)) != 0
                  && ((v88 = BytePtr, (v89 = CFDataGetBytePtr(theData)) == 0)
                    ? (unint64_t v90 = 0)
                    : (unint64_t v90 = (unint64_t)&v89[CFDataGetLength(theData)]),
                      (unint64_t v91 = (unint64_t)&v88[2 * v84 + 8], v91 >= (unint64_t)(v88 + 8)) && v91 <= v90
                   || ((unint64_t)(v88 + 16) <= v90
                     ? (unint64_t v92 = (v90 - (unint64_t)(v88 + 8)) >> 3)
                     : (unint64_t v92 = 0),
                       v92 == v84 >> 2)))
                {
                  *(void *)v119 = CFDictionaryCreateMutable(v10, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                  v93 = (float *)v86;
                  if (theArray)
                  {
                    CFIndex Count = CFArrayGetCount(theArray);
                    if (Count)
                    {
                      CFIndex v95 = Count;
                      CFIndex v96 = 0;
                      v97 = (unsigned __int16 *)(v88 + 14);
                      do
                      {
                        CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, v96);
                        unsigned int v99 = *v97;
                        v97 += 4;
                        float v100 = v93[v96] / (float)((int)bswap32(v99) >> 16);
                        CFNumberRef Value = CFDictionaryGetValue(ValueAtIndex, @"NSCTVariationAxisIdentifier");
                        TCFNumber::TCFNumber<float>(&v114, v100);
                        CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)v119, memory_order_acquire), Value, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v114, memory_order_acquire));

                        ++v96;
                      }
                      while (v95 != v96);
                    }
                  }
                  id v114 = (id)atomic_exchange((atomic_ullong *volatile)v119, 0);

                  uint64_t v11 = v107;
                  unint64_t explicit = v104;
                  uint64_t v33 = (char *)v93;
                }
                else
                {
                  id v114 = 0;
                  uint64_t v11 = v107;
                  unint64_t explicit = v104;
                  uint64_t v33 = v86;
                }
                goto LABEL_82;
              }
              *(void *)&long long v85 = 0xAAAAAAAAAAAAAAAALL;
              *((void *)&v85 + 1) = 0xAAAAAAAAAAAAAAAALL;
              long long v120 = v85;
              *(_OWORD *)v119 = v85;
            }
            while (v31 == 46 || (v31 - 48) <= 9);
          }
          else
          {
            uint64_t v33 = 0;
          }
          uint64_t v11 = v107;
          if (v33)
          {
            operator delete(v33);
            uint64_t v33 = 0;
          }
        }
LABEL_81:
        id v114 = 0;
LABEL_82:
        if (v33) {
          operator delete(v33);
        }

        id v60 = v114;
        goto LABEL_73;
      }
    }
  }
  CFArrayRef v34 = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v110, memory_order_acquire);
  uint64_t v35 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  UTF32Char v36 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  *(void *)v119 = CFDictionaryCreateMutable(v10, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFIndex v37 = CFArrayGetCount(v34);
  id Mutable = CFDictionaryCreateMutable(v10, v37, v35, v36);
  if (v34)
  {
    CFIndex v39 = CFArrayGetCount(v34);
    if (v39)
    {
      CFIndex v40 = v39;
      for (CFIndex i = 0; i != v40; ++i)
      {
        CFDictionaryRef v42 = (const __CFDictionary *)CFArrayGetValueAtIndex(v34, i);
        v43 = CFDictionaryGetValue(v42, @"NSCTVariationAxisIdentifier");
        if (v43) {
          CFDictionaryAddValue(Mutable, v43, v42);
        }
      }
    }
  }
  if (!v24) {
    goto LABEL_70;
  }
LABEL_33:
  if (*v23 == 95)
  {
    unsigned int v44 = 0;
    ++v23;
    --v24;
    uint64_t v45 = 4;
    do
    {
      if (!v24) {
        goto LABEL_71;
      }
      int v46 = *v23;
      if (v46 == 37)
      {
        if (v24 < 3) {
          goto LABEL_71;
        }
        int v47 = v23[1];
        if ((v47 - 48) >= 0xA)
        {
          if ((v47 - 97) >= 6)
          {
            if ((v47 - 65) > 5) {
              goto LABEL_71;
            }
            int v48 = -55;
          }
          else
          {
            int v48 = -87;
          }
        }
        else
        {
          int v48 = -48;
        }
        int v50 = v23[2];
        if ((v50 - 48) >= 0xA)
        {
          if ((v50 - 97) >= 6)
          {
            if ((v50 - 65) > 5) {
              goto LABEL_71;
            }
            int v51 = -55;
          }
          else
          {
            int v51 = -87;
          }
        }
        else
        {
          int v51 = -48;
        }
        unsigned int v44 = (16 * (v48 + v47)) | (v44 << 8) | (v51 + v50);
        v23 += 3;
        uint64_t v49 = -3;
      }
      else
      {
        ++v23;
        unsigned int v44 = v46 | (v44 << 8);
        uint64_t v49 = -1;
      }
      v24 += v49;
      --v45;
    }
    while (v45);
    if (!v24 || *v23 == 95)
    {
      id v114 = (id)0xAAAAAAAAAAAAAAAALL;
      TCFNumber::TCFNumber<unsigned int>(&v114, v44);
      CFDictionaryRef v52 = (const __CFDictionary *)CFDictionaryGetValue(Mutable, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v114, memory_order_acquire));
      if (v52)
      {
        CFIndex v53 = (const void *)atomic_load_explicit((atomic_ullong *volatile)&v114, memory_order_acquire);
        CFIndex v54 = CFDictionaryGetValue(v52, @"NSCTVariationAxisDefaultValue");
        CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)v119, memory_order_acquire), v53, v54);

        goto LABEL_69;
      }
LABEL_139:
      id v113 = 0;

      goto LABEL_72;
    }
    int v55 = 0;
    CFIndex v56 = &v23[v24];
    while (1)
    {
      int v57 = *v23;
      if ((v57 - 48) >= 0xA)
      {
        if ((v57 - 97) >= 6)
        {
          if ((v57 - 65) > 5)
          {
            CFIndex v56 = v23;
LABEL_67:
            id v114 = (id)0xAAAAAAAAAAAAAAAALL;
            TCFNumber::TCFNumber<unsigned int>(&v114, v44);
            if (!CFDictionaryContainsKey(Mutable, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v114, memory_order_acquire)))goto LABEL_139; {
            unsigned __int16 v59 = (const void *)atomic_load_explicit((atomic_ullong *volatile)&v114, memory_order_acquire);
            }
            TCFNumber::TCFNumber<float>(&v113, (float)v55 * 0.000015259);
            CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)v119, memory_order_acquire), v59, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v113, memory_order_acquire));

            CFStringRef v23 = v56;
LABEL_69:
            if (!v24)
            {
LABEL_70:
              id v113 = (id)atomic_exchange((atomic_ullong *volatile)v119, 0);
              goto LABEL_72;
            }
            goto LABEL_33;
          }
          int v58 = -55;
        }
        else
        {
          int v58 = -87;
        }
      }
      else
      {
        int v58 = -48;
      }
      int v55 = v57 + 16 * v55 + v58;
      ++v23;
      if (!--v24) {
        goto LABEL_67;
      }
    }
  }
LABEL_71:
  id v113 = 0;
LABEL_72:
  uint64_t v11 = v107;

  id v60 = (id)atomic_exchange((atomic_ullong *volatile)&v112, atomic_exchange((atomic_ullong *volatile)&v113, 0));
LABEL_73:

  if (!atomic_load_explicit((atomic_ullong *volatile)&v112, memory_order_acquire))
  {
LABEL_75:
    *(void *)v119 = &v115;
    std::vector<char,TInlineBufferAllocator<char,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v119);
    goto LABEL_76;
  }
  *(void *)v119 = 0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(char *__return_ptr, unint64_t))(*(void *)explicit + 496))(v119, explicit);
  id v114 = (id)0xAAAAAAAAAAAAAAAALL;
  atomic_load_explicit((atomic_ullong *volatile)v119, memory_order_acquire);
  atomic_load_explicit((atomic_ullong *volatile)&v112, memory_order_acquire);
  VariationsForGraphicsFontByAddingVariation(&v114);
  v61 = (CGFont *)atomic_load_explicit((atomic_ullong *volatile)v119, memory_order_acquire);
  CFDictionaryRef v108 = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v114, memory_order_acquire);
  v109 = v61;
  TCFBase_NEW<CTFontDescriptor,CGFont *,__CFDictionary const*>(&v113, &v109, &v108);
  *a2 = atomic_exchange((atomic_ullong *volatile)&v113, 0);

  *(void *)v119 = &v115;
  std::vector<char,TInlineBufferAllocator<char,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v119);

LABEL_79:
}

CTFontDescriptor *TCFBase_NEW<CTFontDescriptor,CGFont *,__CFDictionary const*>(void *a1, CGFont **a2, const __CFDictionary **a3)
{
  id result = (CTFontDescriptor *)TCFBase<TDescriptor>::Allocate(96);
  if (result) {
    CTFontDescriptor::CTFontDescriptor(result, *a2, *a3);
  }
  *a1 = 0;
  return result;
}

void TDescriptorSource::CopyPossibleSystemUIFontDescriptor(atomic_ullong *a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  unint64_t explicit = atomic_load_explicit(a1, memory_order_acquire);
  if (a2 == 1 && explicit)
  {
    unint64_t v5 = atomic_load_explicit(a1, memory_order_acquire);
    uint64_t v6 = TCFBase<TDescriptor>::Allocate();
    if (v6)
    {
      long long v7 = (void *)v6;
      long long v8 = (TDescriptor *)(v6 + 48);
      v7[2] = 0;
      v7[3] = TDescriptor::Hash;
      v7[4] = 0;
      v7[5] = v8;
      TDescriptor::TDescriptor(v8, *(atomic_ullong **)(v5 + 40), 1024);
      id v10 = v7;
      id v9 = (id)atomic_exchange((atomic_ullong *volatile)&v10, 0);
    }
    else
    {
      id v9 = 0;
    }
    *a3 = atomic_exchange((atomic_ullong *volatile)&v9, 0);
  }
  else
  {
    *a3 = atomic_exchange(a1, 0);
  }
}

void CTFontLogSystemFontNameRequest()
{
  CFLog();
  if (CTFontLogSystemFontNameRequest::once != -1)
  {
    dispatch_once_f(&CTFontLogSystemFontNameRequest::once, "CTFontLogSystemFontNameRequest", (dispatch_function_t)CTFontLogSystemFontNameRequest::$_0::__invoke);
  }
}

uint64_t ___ZN17TDescriptorSource20SubstituteForHVFFontEP6TCFRefIPK10__CFStringES3__block_invoke()
{
  uint64_t result = GSFontCopyFontFilePath();
  qword_1EB2CE1E8 = result;
  return result;
}

unint64_t CreateOrderedLanguages(const __CFArray *a1)
{
  v19[4] = *MEMORY[0x1E4F143B8];
  if (qword_1EB2CE230 != -1) {
    dispatch_once_f(&qword_1EB2CE230, 0, (dispatch_function_t)GetOrderedLanguages(void)::$_0::__invoke);
  }
  id v18 = (id)0xAAAAAAAAAAAAAAAALL;
  TCFMutableArray::TCFMutableArray((TCFMutableArray *)&v18, (CFArrayRef)qword_1EB2CE228);
  id Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  CFArrayRef v2 = CFLocaleCopyPreferredLanguages();
  id v16 = (id)0xAAAAAAAAAAAAAAAALL;
  v19[0] = &unk_1ED060110;
  v19[3] = v19;
  CreateOrderedArray(a1, v2, (uint64_t)v19, &v16);
  std::__function::__value_func<objc_object * ()(objc_object *)>::~__value_func[abi:nn180100](v19);
  CFArrayRef explicit = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v16, memory_order_acquire);
  if (explicit)
  {
    CFIndex Count = CFArrayGetCount(explicit);
    if (Count)
    {
      CFIndex v5 = Count;
      for (CFIndex i = 0; i != v5; ++i)
      {
        CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(explicit, i);
        CFArrayRef v8 = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v18, memory_order_acquire);
        v20.CFIndex length = CFArrayGetCount((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v18, memory_order_acquire));
        v20.CFIndex location = 0;
        if (CFArrayContainsValue(v8, v20, ValueAtIndex))
        {
          CFArrayRef v9 = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v18, memory_order_acquire);
          v21.CFIndex length = CFArrayGetCount((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v18, memory_order_acquire));
          v21.CFIndex location = 0;
          FirstIndexOfCFNumberRef Value = CFArrayGetFirstIndexOfValue(v9, v21, ValueAtIndex);
          CFArrayRemoveValueAtIndex((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v18, memory_order_acquire), FirstIndexOfValue);
          CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), ValueAtIndex);
        }
      }
    }
  }
  CFArrayRef v11 = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v18, memory_order_acquire);
  uint64_t v12 = (__CFArray *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
  if (v11) {
    v13.CFIndex length = CFArrayGetCount(v11);
  }
  else {
    v13.CFIndex length = 0;
  }
  v13.CFIndex location = 0;
  CFArrayAppendArray(v12, v11, v13);
  unint64_t v14 = atomic_exchange((atomic_ullong *volatile)&Mutable, 0);

  return v14;
}

void TDescriptorSource::AppendFontDescriptorFromName(atomic_ullong *this, TCFMutableArray *a2, const __CFString *a3)
{
  int v3 = (int)a3;
  id v11 = a2;
  id keys = @"NSFontNameAttribute";
  CFDictionaryRef v5 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&keys, (const void **)&v11, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t v6 = TCFBase<TDescriptor>::Allocate();
  if (v6)
  {
    long long v7 = (void *)v6;
    CFArrayRef v8 = (TDescriptor *)(v6 + 48);
    v7[2] = 0;
    v7[3] = TDescriptor::Hash;
    v7[4] = 0;
    v7[5] = v8;
    TDescriptor::TDescriptor(v8, v5, v3);
    id keys = v7;
    id v11 = (id)atomic_exchange((atomic_ullong *volatile)&keys, 0);
  }
  else
  {
    id v11 = 0;
  }
  CFArrayRef v9 = (void *)atomic_exchange((atomic_ullong *volatile)&v11, 0);

  if (v9)
  {
    id v10 = v9;
    CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit(this, memory_order_acquire), v10);
  }
}

void TDescriptorSource::CreatePresetFallbacks(const __CFString *a1@<X1>, const __CFCharacterSet **a2@<X2>, const __CFArray *a3@<X3>, char a4@<W4>, id *a5@<X8>)
{
  uint64_t CTPresetFallbacksDictionary = GetCTPresetFallbacksDictionary();
  if (!CTPresetFallbacksDictionary) {
    goto LABEL_39;
  }
  CFDictionaryRef v12 = (const __CFDictionary *)CTPresetFallbacksDictionary;
  OrderedLanguages = (void *)CreateOrderedLanguages(a3);
  if (!OrderedLanguages)
  {
LABEL_38:

LABEL_39:
    *a5 = 0;
    return;
  }
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(v12, a1);
  if (Value && (v15 = Value, CFTypeID v16 = CFGetTypeID(Value), v16 == CFArrayGetTypeID()))
  {
    id Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    CFIndex Count = CFArrayGetCount(v15);
    if (Count)
    {
      CFIndex v18 = Count;
      for (CFIndex i = 0; i != v18; ++i)
      {
        CFDictionaryRef ValueAtIndex = (__CFString *)CFArrayGetValueAtIndex(v15, i);
        CFTypeID v21 = CFGetTypeID(ValueAtIndex);
        if (v21 == CFDictionaryGetTypeID())
        {
          CFIndex v22 = CFArrayGetCount((CFArrayRef)OrderedLanguages);
          if (v22)
          {
            CFIndex v23 = v22;
            for (CFIndex j = 0; j != v23; ++j)
            {
              id v25 = CFArrayGetValueAtIndex((CFArrayRef)OrderedLanguages, j);
              if (ValueAtIndex)
              {
                uint64_t v26 = (TCFMutableArray *)CFDictionaryGetValue((CFDictionaryRef)ValueAtIndex, v25);
                if (v26) {
                  TDescriptorSource::AppendFontDescriptorFromName((atomic_ullong *)&Mutable, v26, (const __CFString *)0x400);
                }
              }
            }
          }
        }
        else
        {
          if ((dyld_program_sdk_at_least() & 1) == 0)
          {
            CFRange v27 = _CTGetEmojiFontName(1);
            if (v27 == ValueAtIndex || ValueAtIndex && v27 && CFEqual(ValueAtIndex, v27)) {
              CFDictionaryRef ValueAtIndex = _CTGetEmojiFontName(0);
            }
          }
          if ((a4 & 4) != 0
            && (ValueAtIndex == @".AppleThaiFont"
             || ValueAtIndex && CFStringHasPrefix(ValueAtIndex, @".AppleThaiFont")))
          {
            uint64_t v28 = [&unk_1ED07E4D8 objectForKeyedSubscript:ValueAtIndex];
            if (v28) {
              CFDictionaryRef ValueAtIndex = (__CFString *)v28;
            }
          }
          TDescriptorSource::AppendFontDescriptorFromName((atomic_ullong *)&Mutable, (TCFMutableArray *)ValueAtIndex, (const __CFString *)0x400);
        }
      }
    }
    unint64_t v29 = atomic_exchange((atomic_ullong *volatile)&Mutable, 0);
  }
  else
  {
    unint64_t v29 = 0;
  }
  *a5 = (id)v29;
  if (!atomic_load_explicit((atomic_ullong *volatile)a5, memory_order_acquire))
  {

    goto LABEL_38;
  }
  if (a2) {
    *a2 = TDescriptorSource::CopyPredefinedCharacterSet((TDescriptorSource *)@"CTFontDefaultFallbacksComboCharacterSet", 0);
  }
}

uint64_t GetCTPresetFallbacksDictionary(void)
{
  if (getenv("CT_PRESET_FALLBACKS_AND_COMBO_CHARSETS_GENERATION")) {
    return 0;
  }

  return CTFontGetPlistFromGSFontCache(@"CTPresetFallbacks.plist", 0);
}

void TFontDescriptorDuplicateFilter::TFontDescriptorDuplicateFilter(TFontDescriptorDuplicateFilter *this, id a2, const CFSetCallBacks *a3)
{
  *(void *)this = &unk_1ED05EBC8;
  *((void *)this + 1) = a2;
  if (!a3) {
    a3 = (const CFSetCallBacks *)MEMORY[0x1E4F1D548];
  }
  CFIndex Count = CFSetGetCount((CFSetRef)a2);
  *((void *)this + 2) = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], Count, a3);
  *(void *)this = &unk_1ED05F328;
  CreateSortedArrayWithSet((CFSetRef)atomic_load_explicit((atomic_ullong *volatile)this + 1, memory_order_acquire), (CFComparisonResult (__cdecl *)(const void *, const void *, void *))CompareDescriptorsByTraitsAndPrecedence, 0, (CFArrayRef *)&v8);
  unint64_t v7 = atomic_exchange((atomic_ullong *volatile)&v8, 0);

  *((void *)this + 3) = v7;
}

void TFontDescriptorDuplicateFilter::~TFontDescriptorDuplicateFilter(id *this)
{
  *this = &unk_1ED05F328;
  CFArrayRef v2 = this + 2;

  *this = &unk_1ED05EBC8;
}

{
  uint64_t vars8;

  TFontDescriptorDuplicateFilter::~TFontDescriptorDuplicateFilter(this);

  JUMPOUT(0x1853275C0);
}

CFTypeRef TFontDescriptorDuplicateFilter::CTFontDescriptorRetain(TFontDescriptorDuplicateFilter *this, CFTypeRef cf, const void *a3)
{
  return CFRetain(cf);
}

void TFontDescriptorDuplicateFilter::CTFontDescriptorRelease(TFontDescriptorDuplicateFilter *this, CFTypeRef cf, const void *a3)
{
}

CFHashCode TFontDescriptorDuplicateFilter::CTFontDescriptorDuplicateFilterHash(TFontDescriptorDuplicateFilter *this, const void *a2)
{
  uint64_t v2 = *((void *)this + 5);
  if ((*(_DWORD *)(v2 + 16) & 0x80000000) == 0) {
    TDescriptor::InitBaseFont(*((TDescriptor **)this + 5), 0, 0.0);
  }
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(v2 + 32), memory_order_acquire);
  if (explicit)
  {
    id v4 = (id)atomic_load_explicit((atomic_ullong *volatile)(explicit + 96), memory_order_acquire);
    if (v4)
    {
      CFDictionaryRef v5 = v4;
      CFHashCode v6 = CFHash(v4);

      return v6;
    }
  }
  return 0;
}

BOOL TFontDescriptorDuplicateFilter::CTFontDescriptorDuplicateFilterEqual(TFontDescriptorDuplicateFilter *this, void *a2, const void *a3)
{
  uint64_t v4 = *((void *)this + 5);
  if ((*(_DWORD *)(v4 + 16) & 0x80000000) == 0) {
    TDescriptor::InitBaseFont(*((TDescriptor **)this + 5), 0, 0.0);
  }
  unint64_t explicit = (atomic_ullong *)atomic_load_explicit((atomic_ullong *volatile)(v4 + 32), memory_order_acquire);
  uint64_t v6 = a2[5];
  if ((*(_DWORD *)(v6 + 16) & 0x80000000) == 0) {
    TDescriptor::InitBaseFont((TDescriptor *)v6, 0, 0.0);
  }
  unint64_t v7 = (atomic_ullong *)atomic_load_explicit((atomic_ullong *volatile)(v6 + 32), memory_order_acquire);
  if (explicit) {
    BOOL v8 = v7 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (v8) {
    return 0;
  }
  id v9 = (id)atomic_load_explicit(explicit + 12, memory_order_acquire);
  id v10 = (id)atomic_load_explicit(v7 + 12, memory_order_acquire);
  if (v9 != v10)
  {
    id v11 = v10;
    if (v9) {
      BOOL v12 = v10 == 0;
    }
    else {
      BOOL v12 = 1;
    }
    if (v12)
    {
    }
    else
    {
      int v13 = CFEqual(v9, v10);

      if (v13) {
        goto LABEL_18;
      }
    }
    return 0;
  }

LABEL_18:
  id v19 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr, atomic_ullong *))(*explicit + 112))(&v19, explicit);
  id v18 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr, atomic_ullong *))(*v7 + 112))(&v18, v7);
  unint64_t v14 = (const void *)atomic_load_explicit((atomic_ullong *volatile)&v19, memory_order_acquire);
  CFArrayRef v15 = (const void *)atomic_load_explicit((atomic_ullong *volatile)&v18, memory_order_acquire);
  if (v14 == v15)
  {
    BOOL v16 = 1;
  }
  else
  {
    BOOL v16 = 0;
    if (v14 && v15) {
      BOOL v16 = CFEqual(v14, v15) != 0;
    }
  }

  return v16;
}

double GetOpticalSize(const TBaseFont *a1)
{
  id v9 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr))(*(void *)a1 + 128))(&v9);
  if (!atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire)) {
    goto LABEL_10;
  }
  id v8 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr, const TBaseFont *))(*(void *)a1 + 112))(&v8, a1);
  CFDictionaryRef v2 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire);
  if (!v2)
  {

    goto LABEL_6;
  }
  CFDictionaryRef v3 = v2;
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v2, &unk_1ED080A00);

  if (!Value)
  {
LABEL_6:
    CFNumberRef v5 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire), @"NSCTVariationAxisDefaultValue");
    if (v5)
    {
      uint64_t valuePtr = -1;
      goto LABEL_8;
    }

LABEL_10:
    return 0.0;
  }
  uint64_t valuePtr = -1;
  CFNumberRef v5 = Value;
LABEL_8:
  CFNumberGetValue(v5, kCFNumberDoubleType, &valuePtr);
  double v6 = *(double *)&valuePtr;

  return v6;
}

CFComparisonResult StringCompare<TCFRef<__CFString const*>,TCFRef<__CFString const*>>(atomic_ullong *a1, atomic_ullong *a2)
{
  unint64_t explicit = atomic_load_explicit(a1, memory_order_acquire);
  if (explicit == atomic_load_explicit(a2, memory_order_acquire)) {
    return 0;
  }
  if (atomic_load_explicit(a1, memory_order_acquire) && atomic_load_explicit(a2, memory_order_acquire)) {
    return CFStringCompare((CFStringRef)atomic_load_explicit(a1, memory_order_acquire), (CFStringRef)atomic_load_explicit(a2, memory_order_acquire), 0x20uLL);
  }
  unint64_t v4 = atomic_load_explicit(a1, memory_order_acquire);
  if (v4 < atomic_load_explicit(a2, memory_order_acquire)) {
    return -1;
  }
  else {
    return 1;
  }
}

CFComparisonResult CTFontManagerCompareFontFamilyNames(const void *family1, const void *family2, void *context)
{
  if (family1 == family2) {
    return 0;
  }
  if (family1 && family2) {
    return CFStringCompare((CFStringRef)family1, (CFStringRef)family2, 0x61uLL);
  }
  if (family1 < family2) {
    return -1;
  }
  return 1;
}

CFComparisonResult CTFontManagerCompareFontDescriptors(void *a1, void *a2, void *a3)
{
  return CompareLocalizedDescriptorsByTraitsAndPrecedence(a1, a2, a3, 1, 1, 1);
}

CFComparisonResult CTFontManagerCompareFontDescriptors2(void *a1, void *a2, void *a3)
{
  return CompareLocalizedDescriptorsByTraitsAndPrecedence(a1, a2, a3, 1, 1, 0);
}

uint64_t TDescriptorSource::EnsureFontFallbacksCache(TDescriptorSource *this)
{
  uint64_t v1 = (_DWORD *)TDescriptorSource::sFontFallbacksCache;
  if (!TDescriptorSource::sFontFallbacksCache
    || (int v2 = *(_DWORD *)(TDescriptorSource::sFontFallbacksCache + 4),
        uint64_t result = GetLocaleChangedCount(),
        v2 != result)
    || *v1 != TGenerationSeed::sGeneration)
  {
    operator new();
  }
  return result;
}

void TDescriptorSource::CopyDefaultSubstitutionListForLanguages(__CFString *this@<X0>, const __CFString *a2@<X1>, TFontFallbacks *a3@<X8>)
{
  unint64_t v7 = (TDescriptorSource *)os_unfair_lock_lock_with_options();
  TDescriptorSource::EnsureFontFallbacksCache(v7);
  TFontFallbacks::CopyFontFallbacksForLanguages((__CFString *)TDescriptorSource::sFontFallbacksCache, this, (const __CFArray *)a2, a3);

  os_unfair_lock_unlock(&TDescriptorSource::sFontFallbacksLock);
}

void TFontFallbacks::CopyFontFallbacksForLanguages(__CFString *this@<X0>, __CFString *a2@<X1>, const __CFArray *a3@<X2>, TFontFallbacks *a4@<X8>)
{
  if (a3)
  {
    id Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    if (qword_1EB2CE230 != -1) {
      dispatch_once_f(&qword_1EB2CE230, 0, (dispatch_function_t)GetOrderedLanguages(void)::$_0::__invoke);
    }
    CFArrayRef v7 = (const __CFArray *)qword_1EB2CE228;
    if (qword_1EB2CE228) {
      CFIndex Count = CFArrayGetCount((CFArrayRef)qword_1EB2CE228);
    }
    else {
      CFIndex Count = 0;
    }
    CFIndex v9 = CFArrayGetCount(a3);
    if (v9)
    {
      CFIndex v10 = v9;
      for (CFIndex i = 0; i != v10; ++i)
      {
        CFDictionaryRef ValueAtIndex = (__CFString *)CFArrayGetValueAtIndex(a3, i);
        id v16 = (id)0xAAAAAAAAAAAAAAAALL;
        LanguageIdentifierByNormalizing(ValueAtIndex, 0, (atomic_ullong *)&v16);
        v18.CFIndex location = 0;
        v18.CFIndex length = Count;
        if (CFArrayContainsValue(v7, v18, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v16, memory_order_acquire)))
        {
          id v13 = (id)atomic_load_explicit((atomic_ullong *volatile)&v16, memory_order_acquire);
          CFArrayAppendValue(Mutable, v13);
        }
      }
    }
    if (CFArrayGetCount(Mutable))
    {
      CFArrayInsertValueAtIndex(Mutable, 0, a2);
      id v16 = (id)0xAAAAAAAAAAAAAAAALL;
      ArrayComponentsJoinedByString(Mutable, @",", (atomic_ullong *)&v16);
      CFArrayRemoveValueAtIndex(Mutable, 0);
      TFontFallbacks::CopyFontFallbacks(a4, this, (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&v16, memory_order_acquire), a2, Mutable);
    }
    else
    {
      TFontFallbacks::CopyFontFallbacks(a4, this, a2, 0, 0);
    }
  }
  else
  {
    TFontFallbacks::CopyFontFallbacks(a4, this, a2, 0, 0);
  }
}

uint64_t TFontFallbacks::GetCharRangeMapForKey(TFontFallbacks *this, unint64_t a2)
{
  unint64_t v3 = a2;
  unint64_t v4 = &v3;
  uint64_t result = std::__hash_table<std::__hash_value_type<unsigned long,std::unique_ptr<CharRangeToDescriptorMap>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::unique_ptr<CharRangeToDescriptorMap>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::unique_ptr<CharRangeToDescriptorMap>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::unique_ptr<CharRangeToDescriptorMap>>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>((uint64_t *)this + 3, &v3, (uint64_t)&std::piecewise_construct, &v4)[3];
  if (!result) {
    operator new();
  }
  return result;
}

unint64_t _CTCopyDefaultFontFallbacksDictionary()
{
  CopyDefaultFontFallbacks(&v2);
  unint64_t v0 = atomic_exchange((atomic_ullong *volatile)&v2, 0);

  return v0;
}

id CopyDefaultFontFallbacks(void *a1)
{
  if (qword_1EB2CE250 != -1) {
    dispatch_once_f(&qword_1EB2CE250, 0, (dispatch_function_t)CopyDefaultFontFallbacks(void)::$_0::__invoke);
  }
  id result = (id)qword_1EB2CE248;
  *a1 = result;
  return result;
}

void TDescriptorSource::CopyPreferredFontDescriptor(unint64_t *a1, atomic_ullong **a2, const __CFString *a3, const void *a4, const __CFString *a5, int a6)
{
  id v14 = (id)0xAAAAAAAAAAAAAAAALL;
  TDescriptorSource::CopySystemFontDescriptorByName(a2, a3, a6, 8, (atomic_ullong *)&v14);
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&v14, memory_order_acquire);
  if (explicit)
  {
    int SymbolicTraits = CTFontDescriptorGetSymbolicTraits(atomic_load_explicit((atomic_ullong *volatile)&v14, memory_order_acquire));
    if (HasRequiredSymbolicTraits(a4, SymbolicTraits)
      || (TDescriptorSource::CopySystemFontDescriptorByName(a2, a5, a6, 8, (atomic_ullong *)&v13),
          (id)atomic_exchange((atomic_ullong *volatile)&v14, atomic_exchange((atomic_ullong *volatile)&v13, 0)), v13, (unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&v14, memory_order_acquire)) != 0))
    {
      unint64_t explicit = atomic_exchange((atomic_ullong *volatile)&v14, 0);
    }
  }
  *a1 = explicit;
}

BOOL HasRequiredSymbolicTraits(CFTypeRef cf1, int a2)
{
  uint64_t v4 = 0;
  while (!CFEqual(cf1, *(__CFString **)((char *)&HasRequiredSymbolicTraits(__CFString const*,unsigned int)::sRequiredTraits + v4)))
  {
    v4 += 16;
    if (v4 == 48) {
      return 1;
    }
  }
  return (*(_DWORD *)((unsigned char *)&HasRequiredSymbolicTraits(__CFString const*,unsigned int)::sRequiredTraits + v4 + 8) & a2) != 0;
}

void TDescriptorSource::CreateDescriptorForCSSFamily(atomic_ullong **this@<X0>, __CFString *cf1@<X1>, __CFString *a3@<X2>, atomic_ullong *a4@<X8>)
{
  if (!cf1)
  {
    *a4 = 0;
    return;
  }
  double v6 = cf1;
  if (CFEqual(cf1, @"emoji"))
  {
    id v8 = _CTGetEmojiFontName(0);
LABEL_8:
    TDescriptorSource::CopySystemFontDescriptorByName(this, v8, 0, 0, a4);
    return;
  }
  if (CFEqual(v6, @"fangsong"))
  {
    id v8 = @"STFangsong";
    goto LABEL_8;
  }
  id v60 = (id)0xAAAAAAAAAAAAAAAALL;
  LanguageIdentifierByNormalizing(a3, 0, (atomic_ullong *)&v60);
  if (v6 == @"system-ui" || CFEqual(v6, @"system-ui"))
  {
    int v9 = 0;
    double v6 = @"default";
    int v10 = 2;
  }
  else if (v6 == @"ui-monospace")
  {
    int v9 = 0;
    int v10 = 254;
    double v6 = @"ui-monospace";
  }
  else if (CFEqual(v6, @"ui-monospace"))
  {
    int v9 = 0;
    int v10 = 254;
  }
  else if (v6 == @"ui-serif" || CFEqual(v6, @"ui-serif"))
  {
    int v9 = 0;
    int v10 = 241;
  }
  else
  {
    int v10 = -1;
    int v9 = 1;
  }
  id v59 = (id)0xAAAAAAAAAAAAAAAALL;
  CopyDefaultFontFallbacks(&v59);
  CFDictionaryRef v11 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)&v59, memory_order_acquire);
  if (!v11)
  {

    goto LABEL_47;
  }
  CFDictionaryRef v12 = v11;
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(v11, v6);

  if (!Value || !CFArrayGetCount(Value)) {
    goto LABEL_47;
  }
  CTFontUIFontType uiType = v10;
  char v50 = v9;
  int v54 = v9 ^ 1;
  if (!TDescriptorSource::CanLanguageAffectCascadeList(a3, v14)
    || (v53 = (const __CFString *)CFArrayGetValueAtIndex(Value, 0), (CFIndex Count = CFArrayGetCount(Value)) == 0))
  {
LABEL_43:
    if (v50)
    {
      if (CFEqual(v6, @"sans-serif"))
      {
        CTFontRef UIFontForLanguage = CTFontCreateWithName(@"Helvetica", 12.0, 0);
      }
      else
      {
        CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(Value, 0);
        CTFontRef UIFontForLanguage = CTFontCreateWithNameAndOptions(ValueAtIndex, 0.0, 0, 0x20000uLL);
      }
    }
    else
    {
      CTFontRef UIFontForLanguage = CTFontCreateUIFontForLanguage(uiType, 0.0, (CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&v60, memory_order_acquire));
    }
    CFIndex v37 = UIFontForLanguage;
    if (UIFontForLanguage)
    {
      id v57 = (id)0xAAAAAAAAAAAAAAAALL;
      id v58 = 0;
      if (atomic_load_explicit((atomic_ullong *volatile)&v60, memory_order_acquire))
      {
        TSampleManager::TSampleManager((TSampleManager *)&v56);
        unint64_t explicit = (void *)atomic_load_explicit((atomic_ullong *volatile)&v60, memory_order_acquire);
        TSampleManagerImp::CopySampleLettersForLanguage(explicit, (atomic_ullong *)v56, 2u, &v57);
      }
      else
      {
        id v57 = 0;
      }
      if (atomic_load_explicit((atomic_ullong *volatile)&v57, memory_order_acquire))
      {
        id v56 = (id)0xAAAAAAAAAAAAAAAALL;
        TSampleManager::CreateStringWithLetters((TSampleManager *)atomic_load_explicit((atomic_ullong *volatile)&v57, memory_order_acquire), v35, &v56);
        CFStringRef v39 = (const __CFString *)atomic_load_explicit((atomic_ullong *volatile)&v56, memory_order_acquire);
        v62.CFIndex length = CFStringGetLength((CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&v56, memory_order_acquire));
        v62.CFIndex location = 0;
        CFIndex v40 = CTFontCreateForStringWithLanguage(v37, v39, v62, (CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&v60, memory_order_acquire));
        char v41 = v40;
        if (v40)
        {
          id v55 = (id)CTFontCopyPostScriptName(v40);

          CFDictionaryRef v42 = (int *)*((void *)v41 + 5);
          int v43 = *v42;
          int v44 = (*(uint64_t (**)(void))(**((void **)v42 + 50) + 160))(*((void *)v42 + 50));
          if (!HasRequiredSymbolicTraits(v6, v44 | ((v43 & 1) << 11))) {
        }
          }
      }

      if (!atomic_load_explicit((atomic_ullong *volatile)&v58, memory_order_acquire))
      {
        id v57 = (id)CTFontCopyPostScriptName(v37);
      }
      CFRelease(v37);
      TDescriptorSource::CopySystemFontDescriptorByName(this, (const __CFString *)atomic_load_explicit((atomic_ullong *volatile)&v58, memory_order_acquire), v54, 8, a4);

      goto LABEL_48;
    }
    goto LABEL_47;
  }
  CFIndex v15 = 0;
  CFArrayRef v51 = Value;
  while (1)
  {
    id v16 = CFArrayGetValueAtIndex(Value, v15);
    CFTypeID v17 = CFGetTypeID(v16);
    if (v17 != CFDictionaryGetTypeID()) {
      break;
    }
    CFStringRef v18 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)v16, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v60, memory_order_acquire));
    if (v18)
    {
      CFStringRef v19 = v18;
      CFTypeID v20 = CFGetTypeID(v18);
      if (v20 == CFStringGetTypeID())
      {
        *a4 = 0xAAAAAAAAAAAAAAAALL;
        TDescriptorSource::CopyPreferredFontDescriptor((unint64_t *)a4, this, v19, v6, v53, v54);
        if (atomic_load_explicit(a4, memory_order_acquire)) {
          goto LABEL_48;
        }
      }
      else if (v20 == CFArrayGetTypeID())
      {
        CFIndex v30 = CFArrayGetCount((CFArrayRef)v19);
        if (v30)
        {
          CFIndex v31 = v30;
          CFIndex v32 = 0;
          do
          {
            CFStringRef v33 = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)v19, v32);
            *a4 = 0xAAAAAAAAAAAAAAAALL;
            TDescriptorSource::CopyPreferredFontDescriptor((unint64_t *)a4, this, v33, v6, v53, v54);
            if (atomic_load_explicit(a4, memory_order_acquire)) {
              goto LABEL_48;
            }
          }
          while (v31 != ++v32);
        }
      }
    }
LABEL_42:
    ++v15;
    CFArrayRef Value = v51;
    if (v15 == Count) {
      goto LABEL_43;
    }
  }
  CFTypeID TypeID = CFArrayGetTypeID();
  if (!v16) {
    goto LABEL_42;
  }
  if (v17 != TypeID) {
    goto LABEL_42;
  }
  CFIndex v22 = CFArrayGetCount((CFArrayRef)v16);
  if (!v22) {
    goto LABEL_42;
  }
  CFIndex v23 = v22;
  CFIndex v24 = 0;
  while (1)
  {
    CFArrayRef v25 = (const __CFArray *)CFArrayGetValueAtIndex((CFArrayRef)v16, v24);
    id v26 = (id)CFArrayGetValueAtIndex(v25, 0);
    id v27 = (id)atomic_load_explicit((atomic_ullong *volatile)&v60, memory_order_acquire);
    if (v27 == v26) {
      break;
    }
    uint64_t v28 = v27;
    if (v26 && v27)
    {
      int v29 = CFEqual(v26, v27);

      if (v29) {
        goto LABEL_71;
      }
    }
    else
    {
    }
    if (v23 == ++v24) {
      goto LABEL_42;
    }
  }

LABEL_71:
  CFIndex v45 = CFArrayGetCount(v25);
  if (v45 < 2)
  {
LABEL_47:
    *a4 = 0;
    goto LABEL_48;
  }
  CFIndex v46 = v45;
  CFIndex v47 = 1;
  while (1)
  {
    *a4 = 0xAAAAAAAAAAAAAAAALL;
    CFStringRef v48 = (const __CFString *)CFArrayGetValueAtIndex(v25, v47);
    TDescriptorSource::CopyPreferredFontDescriptor((unint64_t *)a4, this, v48, v6, v53, v54);
    if (atomic_load_explicit(a4, memory_order_acquire)) {
      break;
    }

    if (v46 == ++v47) {
      goto LABEL_47;
    }
  }
LABEL_48:
}

const __CFString *TDescriptorSource::CanLanguageAffectCascadeList(const __CFString *this, const __CFString *a2)
{
  if (this)
  {
    CFStringRef v2 = this;
    this = (const __CFString *)CFStringGetLength(this);
    if (this)
    {
      if (qword_1EB2CE230 != -1) {
        dispatch_once_f(&qword_1EB2CE230, 0, (dispatch_function_t)GetOrderedLanguages(void)::$_0::__invoke);
      }
      CFArrayRef v3 = (const __CFArray *)qword_1EB2CE228;
      if (qword_1EB2CE228)
      {
        v4.CFIndex length = CFArrayGetCount((CFArrayRef)qword_1EB2CE228);
        v4.CFIndex location = 0;
        return (const __CFString *)(CFArrayContainsValue(v3, v4, v2) != 0);
      }
      else
      {
        return 0;
      }
    }
  }
  return this;
}

void TDescriptorSource::ProcessFallbackComponent(atomic_ullong *a1, void *cf, CFIndex a3, int a4)
{
  CFTypeID v8 = CFGetTypeID(cf);
  if (a4 == 1) {
    uint64_t v9 = 1024;
  }
  else {
    uint64_t v9 = 65537;
  }
  if (v8 == CFStringGetTypeID())
  {
    TDescriptorSource::AppendFontDescriptorFromName(a1, (TCFMutableArray *)cf, (const __CFString *)v9);
  }
  else if (v8 == CFArrayGetTypeID())
  {
    CFIndex Count = CFArrayGetCount((CFArrayRef)cf);
    if (Count > a3)
    {
      CFIndex v11 = Count;
      do
      {
        CFStringRef ValueAtIndex = (TCFMutableArray *)CFArrayGetValueAtIndex((CFArrayRef)cf, a3);
        if (ValueAtIndex) {
          TDescriptorSource::AppendFontDescriptorFromName(a1, ValueAtIndex, (const __CFString *)v9);
        }
        ++a3;
      }
      while (v11 != a3);
    }
  }
}

void _CTClearFontFallbacksCache()
{
  TPerThreadLRUCache<TRequestCacheNode,(ThreadSpecificKey)3,16ul>::TPerThreadLRUCache(&v0);
  TLRUCacheImp<TRequestCacheNode,16ul>::RemoveAll(v0);
  atomic_fetch_add_explicit(&gLocaleChangedCount, 1u, memory_order_relaxed);
  atomic_fetch_add_explicit(&TGenerationSeed::sGeneration, 1u, memory_order_relaxed);
  atomic_fetch_add_explicit(&TGenerationSeed::sGeneration, 1u, memory_order_relaxed);
}

void _CTForceLocaleChange()
{
}

void TDescriptorSource::ProcessFallbackList(const __CFArray *a1, atomic_ullong *a2, int a3, const __CFArray *a4)
{
  CFArrayRef v7 = a1;
  CFIndex Count = CFArrayGetCount(a1);
  if (Count)
  {
    CFIndex v8 = 0;
    CFArrayRef v30 = v7;
    do
    {
      CFStringRef ValueAtIndex = (__CFString *)CFArrayGetValueAtIndex(v7, v8);
      CFTypeID v10 = CFGetTypeID(ValueAtIndex);
      if (v10 != CFStringGetTypeID())
      {
        if (v10 == CFDictionaryGetTypeID())
        {
          if (a4)
          {
            CFIndex v13 = CFArrayGetCount(a4);
            if (v13)
            {
              CFIndex v14 = v13;
              for (CFIndex i = 0; i != v14; ++i)
              {
                id v16 = CFArrayGetValueAtIndex(a4, i);
                if (ValueAtIndex)
                {
                  CFArrayRef Value = (void *)CFDictionaryGetValue((CFDictionaryRef)ValueAtIndex, v16);
                  if (Value) {
                    TDescriptorSource::ProcessFallbackComponent(a2, Value, 0, a3);
                  }
                }
              }
            }
          }
        }
        else if (v10 == CFArrayGetTypeID())
        {
          id v32 = (id)0xAAAAAAAAAAAAAAAALL;
          TCFMutableArray::TCFMutableArray((TCFMutableArray *)&v32, (CFArrayRef)ValueAtIndex);
          if (a4)
          {
            CFIndex v18 = CFArrayGetCount(a4);
            if (v18)
            {
              CFIndex v19 = v18;
              for (CFIndex j = 0; j != v19; ++j)
              {
                CFTypeID v21 = CFArrayGetValueAtIndex(a4, j);
                if (CFArrayGetCount((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v32, memory_order_acquire)) >= 1)
                {
                  CFIndex v22 = 0;
                  while (1)
                  {
                    CFArrayRef v23 = (const __CFArray *)CFArrayGetValueAtIndex((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v32, memory_order_acquire), v22);
                    CFIndex v24 = CFArrayGetValueAtIndex(v23, 0);
                    if (v24 == v21 || v21 && v24 && CFEqual(v24, v21)) {
                      break;
                    }
                    if (++v22 >= CFArrayGetCount((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v32, memory_order_acquire)))goto LABEL_38; {
                  }
                    }
                  TDescriptorSource::ProcessFallbackComponent(a2, v23, 1, a3);
                  CFArrayRemoveValueAtIndex((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v32, memory_order_acquire), v22);
                }
LABEL_38:
                ;
              }
            }
          }
          CFArrayRef explicit = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v32, memory_order_acquire);
          if (explicit)
          {
            CFIndex v26 = CFArrayGetCount(explicit);
            if (v26)
            {
              CFIndex v27 = v26;
              for (CFIndex k = 0; k != v27; ++k)
              {
                int v29 = (void *)CFArrayGetValueAtIndex(explicit, k);
                TDescriptorSource::ProcessFallbackComponent(a2, v29, 1, a3);
              }
            }
          }

          CFArrayRef v7 = v30;
        }
        goto LABEL_23;
      }
      if (a3 == 1)
      {
        if ((dyld_program_sdk_at_least() & 1) == 0)
        {
          CFIndex v11 = _CTGetEmojiFontName(1);
          if (v11 == ValueAtIndex) {
            goto LABEL_10;
          }
          uint64_t v12 = 1024;
          if (!ValueAtIndex || !v11) {
            goto LABEL_22;
          }
          if (CFEqual(ValueAtIndex, v11)) {
LABEL_10:
          }
            CFStringRef ValueAtIndex = _CTGetEmojiFontName(0);
        }
        uint64_t v12 = 1024;
      }
      else
      {
        uint64_t v12 = 65537;
      }
LABEL_22:
      TDescriptorSource::AppendFontDescriptorFromName(a2, (TCFMutableArray *)ValueAtIndex, (const __CFString *)v12);
LABEL_23:
      ++v8;
    }
    while (v8 != Count);
  }
}

void TFontFallbacks::TFontFallbacks(TFontFallbacks *this)
{
  v3[4] = *MEMORY[0x1E4F143B8];
  *(_DWORD *)this = TGenerationSeed::sGeneration;
  *((_DWORD *)this + 1) = GetLocaleChangedCount();
  *((void *)this + 1) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFArrayRef v2 = CFLocaleCopyPreferredLanguages();
  v3[0] = &unk_1ED060110;
  v3[3] = v3;
  CreateOrderedArray(0, v2, (uint64_t)v3, (void *)this + 2);
  std::__function::__value_func<objc_object * ()(objc_object *)>::~__value_func[abi:nn180100](v3);

  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *((_DWORD *)this + 14) = 1065353216;
}

void TFontFallbacks::CopyFontFallbacks(TFontFallbacks *this, const __CFString *a2, __CFString *a3, __CFString *a4, const __CFArray *explicit)
{
  id v27 = (id)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit(&a2->info, memory_order_acquire), a3);
  if (!atomic_load_explicit((atomic_ullong *volatile)&v27, memory_order_acquire))
  {
    id v25 = (id)0xAAAAAAAAAAAAAAAALL;
    id v26 = 0;
    if (!a4) {
      a4 = a3;
    }
    CopyDefaultFontFallbacks(&v25);
    CFDictionaryRef v10 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)&v25, memory_order_acquire);
    if (v10)
    {
      CFDictionaryRef v11 = v10;
      CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(v10, a4);

      if (Value && CFArrayGetCount(Value) >= 1)
      {
        if (!explicit) {
          CFArrayRef explicit = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&a2->data, memory_order_acquire);
        }
        CFDictionaryRef v13 = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v25, memory_order_acquire);
        CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
        unint64_t v28 = 0xAAAAAAAAAAAAAAAALL;
        id v29 = Mutable;
        TDescriptorSource::TDescriptorSource((TDescriptorSource *)&v28);
        CFArrayRef OrderedLanguages = (const __CFArray *)CreateOrderedLanguages(explicit);
        if (a4 == @"default")
        {
          BOOL v17 = 1;
        }
        else if (a4)
        {
          int v16 = CFEqual(a4, @"default");
          BOOL v17 = 1;
          if (a4 != @"ui-" && !v16) {
            BOOL v17 = CFStringHasPrefix(a4, @"ui-") != 0;
          }
        }
        else
        {
          BOOL v17 = 0;
        }
        TDescriptorSource::ProcessFallbackList(Value, (atomic_ullong *)&v29, v17, OrderedLanguages);
        CFArrayRef v19 = (const __CFArray *)CFDictionaryGetValue(v13, @"common");
        if (v19)
        {
          CFArrayRef v20 = v19;
          if (CFArrayGetCount(v19)) {
            TDescriptorSource::ProcessFallbackList(v20, (atomic_ullong *)&v29, v17, OrderedLanguages);
          }
        }
        id v24 = (id)atomic_exchange((atomic_ullong *volatile)&v29, 0);

        CFArrayRef v21 = (const __CFArray *)(id)atomic_load_explicit((atomic_ullong *volatile)&v26, memory_order_acquire);
        if (v21)
        {
          CFArrayRef v22 = v21;
          CFIndex Count = CFArrayGetCount(v21);

          if (Count >= 1) {
            CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit(&a2->info, memory_order_acquire), a3, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v26, memory_order_acquire));
          }
        }
        else
        {
        }
        goto LABEL_33;
      }
    }
    else
    {
    }
    if (a4 == @"ui-monospace") {
      goto LABEL_19;
    }
    if (a4)
    {
      if (CFEqual(a4, @"ui-monospace"))
      {
LABEL_19:
        CFStringRef v18 = @"monospace";
LABEL_20:
        TFontFallbacks::CopyFontFallbacks(this, a2, v18, 0);
LABEL_34:

        goto LABEL_35;
      }
      if (a4 == @"ui-serif" || CFEqual(a4, @"ui-serif"))
      {
        CFStringRef v18 = @"serif";
        goto LABEL_20;
      }
      if (a4 == @"ui-rounded" || CFEqual(a4, @"ui-rounded"))
      {
        CFStringRef v18 = @"default";
        goto LABEL_20;
      }
    }
LABEL_33:
    *(void *)this = atomic_exchange((atomic_ullong *volatile)&v26, 0);
    goto LABEL_34;
  }
  *(void *)this = atomic_exchange((atomic_ullong *volatile)&v27, 0);
LABEL_35:
}

void TRequestCacheNode::~TRequestCacheNode(id *this)
{
  *this = &unk_1ED05E6A0;
  uint64_t v1 = this + 2;
}

{
  id *v1;
  uint64_t vars8;

  *this = &unk_1ED05E6A0;
  uint64_t v1 = this + 2;

  JUMPOUT(0x1853275C0);
}

void CharRangeToDescriptorMap::CharRangeToDescriptorMap(CharRangeToDescriptorMap *this)
{
  *((void *)this + 68) = 0;
  *((_OWORD *)this + 32) = 0u;
  *((_OWORD *)this + 33) = 0u;
  *((_DWORD *)this + 138) = 1065353216;
  *((_DWORD *)this + 6) = -1613914163;
  CFNumberRef v5 = (char *)this + 24;
  CFArrayRef v2 = (char *)this + 40;
  *((void *)this + 63) = (char *)this + 40;
  *((void *)this + 4) = -1;
  *(void *)this = (char *)this + 24;
  *((void *)this + 1) = (char *)this + 40;
  *((void *)this + 2) = (char *)this + 40;
  memset(v4, 0, sizeof(v4));
  std::__split_buffer<std::tuple<unsigned short,unsigned short,long>,TInlineBufferAllocator<std::tuple<unsigned short,unsigned short,long>,30ul> &>::~__split_buffer((uint64_t)v4);
  uint64_t v3 = *(void *)this;
  *((void *)this + 1) = v2;
  *((void *)this + 64) = v3;
}

uint64_t CharRangeToDescriptorMap::AddRangesForDescriptorIndex(uint64_t this, const __CFCharacterSet *a2, unint64_t a3)
{
  if (!a2) {
    return this;
  }
  uint64_t v4 = this;
  unint64_t v5 = *(void *)(this + 528);
  if (v5)
  {
    uint8x8_t v6 = (uint8x8_t)vcnt_s8((int8x8_t)v5);
    v6.i16[0] = vaddlv_u8(v6);
    if (v6.u32[0] > 1uLL)
    {
      unint64_t v7 = a3;
      if (v5 <= a3) {
        unint64_t v7 = a3 % v5;
      }
    }
    else
    {
      unint64_t v7 = (v5 - 1) & a3;
    }
    uint64_t v9 = *(void *)(this + 520);
    CFDictionaryRef v10 = *(void **)(v9 + 8 * v7);
    if (v10)
    {
      for (CFIndex i = (void *)*v10; i; CFIndex i = (void *)*i)
      {
        unint64_t v12 = i[1];
        if (v12 == a3)
        {
          if (i[2] == a3) {
            return this;
          }
        }
        else
        {
          if (v6.u32[0] > 1uLL)
          {
            if (v12 >= v5) {
              v12 %= v5;
            }
          }
          else
          {
            v12 &= v5 - 1;
          }
          if (v12 != v7) {
            break;
          }
        }
      }
    }
    if (v6.u32[0] > 1uLL)
    {
      unint64_t v8 = a3;
      if (v5 <= a3) {
        unint64_t v8 = a3 % v5;
      }
    }
    else
    {
      unint64_t v8 = (v5 - 1) & a3;
    }
    CFDictionaryRef v13 = *(void **)(v9 + 8 * v8);
    if (v13)
    {
      for (CFIndex j = (void *)*v13; j; CFIndex j = (void *)*j)
      {
        unint64_t v15 = j[1];
        if (v15 == a3)
        {
          if (j[2] == a3) {
            goto LABEL_90;
          }
        }
        else
        {
          if (v6.u32[0] > 1uLL)
          {
            if (v15 >= v5) {
              v15 %= v5;
            }
          }
          else
          {
            v15 &= v5 - 1;
          }
          if (v15 != v8) {
            break;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAAALL;
  }
  int v16 = operator new(0x18uLL);
  *int v16 = 0;
  v16[1] = a3;
  v16[2] = a3;
  float v17 = (float)(unint64_t)(*(void *)(v4 + 544) + 1);
  float v18 = *(float *)(v4 + 552);
  if (!v5 || (float)(v18 * (float)v5) < v17)
  {
    BOOL v19 = 1;
    if (v5 >= 3) {
      BOOL v19 = (v5 & (v5 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v5);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      int8x8_t prime = (int8x8_t)v21;
    }
    else {
      int8x8_t prime = (int8x8_t)v20;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v5 = *(void *)(v4 + 528);
    }
    if (*(void *)&prime > v5) {
      goto LABEL_46;
    }
    if (*(void *)&prime < v5)
    {
      unint64_t v29 = vcvtps_u32_f32((float)*(unint64_t *)(v4 + 544) / *(float *)(v4 + 552));
      if (v5 < 3 || (uint8x8_t v30 = (uint8x8_t)vcnt_s8((int8x8_t)v5), v30.i16[0] = vaddlv_u8(v30), v30.u32[0] > 1uLL))
      {
        unint64_t v29 = std::__next_prime(v29);
      }
      else
      {
        uint64_t v31 = 1 << -(char)__clz(v29 - 1);
        if (v29 >= 2) {
          unint64_t v29 = v31;
        }
      }
      if (*(void *)&prime <= v29) {
        int8x8_t prime = (int8x8_t)v29;
      }
      if (*(void *)&prime >= v5)
      {
        unint64_t v5 = *(void *)(v4 + 528);
      }
      else
      {
        if (prime)
        {
LABEL_46:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          CFArrayRef v23 = operator new(8 * *(void *)&prime);
          id v24 = *(void **)(v4 + 520);
          *(void *)(v4 + 520) = v23;
          if (v24) {
            operator delete(v24);
          }
          uint64_t v25 = 0;
          *(int8x8_t *)(v4 + 528) = prime;
          do
            *(void *)(*(void *)(v4 + 520) + 8 * v25++) = 0;
          while (*(void *)&prime != v25);
          id v26 = *(void **)(v4 + 536);
          if (v26)
          {
            unint64_t v27 = v26[1];
            uint8x8_t v28 = (uint8x8_t)vcnt_s8(prime);
            v28.i16[0] = vaddlv_u8(v28);
            if (v28.u32[0] > 1uLL)
            {
              if (v27 >= *(void *)&prime) {
                v27 %= *(void *)&prime;
              }
            }
            else
            {
              v27 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)(v4 + 520) + 8 * v27) = v4 + 536;
            id v32 = (void *)*v26;
            if (*v26)
            {
              do
              {
                unint64_t v33 = v32[1];
                if (v28.u32[0] > 1uLL)
                {
                  if (v33 >= *(void *)&prime) {
                    v33 %= *(void *)&prime;
                  }
                }
                else
                {
                  v33 &= *(void *)&prime - 1;
                }
                if (v33 != v27)
                {
                  uint64_t v34 = *(void *)(v4 + 520);
                  if (!*(void *)(v34 + 8 * v33))
                  {
                    *(void *)(v34 + 8 * v33) = v26;
                    goto LABEL_71;
                  }
                  void *v26 = *v32;
                  *id v32 = **(void **)(*(void *)(v4 + 520) + 8 * v33);
                  **(void **)(*(void *)(v4 + 520) + 8 * v33) = v32;
                  id v32 = v26;
                }
                unint64_t v33 = v27;
LABEL_71:
                id v26 = v32;
                id v32 = (void *)*v32;
                unint64_t v27 = v33;
              }
              while (v32);
            }
          }
          unint64_t v5 = (unint64_t)prime;
          goto LABEL_75;
        }
        id v59 = *(void **)(v4 + 520);
        *(void *)(v4 + 520) = 0;
        if (v59) {
          operator delete(v59);
        }
        unint64_t v5 = 0;
        *(void *)(v4 + 528) = 0;
      }
    }
LABEL_75:
    if ((v5 & (v5 - 1)) != 0)
    {
      if (v5 <= a3) {
        unint64_t v8 = a3 % v5;
      }
      else {
        unint64_t v8 = a3;
      }
    }
    else
    {
      unint64_t v8 = (v5 - 1) & a3;
    }
  }
  uint64_t v35 = *(void *)(v4 + 520);
  UTF32Char v36 = *(void **)(v35 + 8 * v8);
  if (v36)
  {
    *int v16 = *v36;
  }
  else
  {
    *int v16 = *(void *)(v4 + 536);
    *(void *)(v4 + 536) = v16;
    *(void *)(v35 + 8 * v8) = v4 + 536;
    if (!*v16) {
      goto LABEL_89;
    }
    unint64_t v37 = *(void *)(*v16 + 8);
    if ((v5 & (v5 - 1)) != 0)
    {
      if (v37 >= v5) {
        v37 %= v5;
      }
    }
    else
    {
      v37 &= v5 - 1;
    }
    UTF32Char v36 = (void *)(*(void *)(v4 + 520) + 8 * v37);
  }
  *UTF32Char v36 = v16;
LABEL_89:
  ++*(void *)(v4 + 544);
LABEL_90:
  *(void *)&long long v38 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v38 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)theSet = v38;
  long long v63 = v38;
  this = CFCharacterSetInitInlineBuffer();
  CFStringRef v39 = *(char **)v4;
  uint64_t v40 = *(void *)(v4 + 16) - *(void *)v4;
  unsigned __int16 v41 = 12288;
LABEL_91:
  while (2)
  {
    unsigned int v42 = *(unsigned __int16 *)v39;
    if (v42 > v41)
    {
      unsigned __int16 v43 = 0;
      UTF32Char v44 = v41;
      unsigned __int16 v45 = v41;
      while (1)
      {
        unsigned int v46 = (uint64_t)theSet[1] & 4;
        if (HIDWORD(theSet[1]) <= v44 && v63 > v44)
        {
          if (((uint64_t)theSet[1] & 2) != 0)
          {
            this = CFCharacterSetIsLongCharacterMember(theSet[0], v44);
            if (this) {
              goto LABEL_108;
            }
          }
          else if (*((void *)&v63 + 1))
          {
            if ((uint64_t)theSet[1])
            {
              unsigned int v54 = v46 >> 2;
              uint64_t v55 = *(unsigned __int8 *)(*((void *)&v63 + 1) + ((unint64_t)v44 >> 8));
              if (*(unsigned char *)(*((void *)&v63 + 1) + ((unint64_t)v44 >> 8)))
              {
                if (v55 == 255)
                {
                  unsigned int v54 = v46 == 0;
                }
                else
                {
                  BOOL v56 = v46 == 0;
                  if ((((unint64_t)*(unsigned __int8 *)(*((void *)&v63 + 1)
                                                              + 32 * v55
                                                              + (v44 >> 3)
                                                              + 224) >> (v44 & 7)) & 1) != 0)
                    unsigned int v54 = v56;
                }
              }
              if (v54)
              {
LABEL_108:
                if (v43)
                {
                  ++v43;
                }
                else
                {
                  unsigned __int16 v45 = v44;
                  unsigned __int16 v43 = v44 + 1;
                }
                goto LABEL_112;
              }
            }
            else
            {
              BOOL v48 = v46 != 0;
              BOOL v49 = v46 == 0;
              if (((unint64_t)*(unsigned __int8 *)(*((void *)&v63 + 1) + ((unint64_t)v44 >> 3)) >> (v44 & 7))) {
                BOOL v48 = v49;
              }
              if (v48) {
                goto LABEL_108;
              }
            }
          }
          else
          {
            BOOL v50 = v46 == 0;
            BOOL v51 = v46 != 0;
            char v52 = v50;
            if ((uint64_t)theSet[1]) {
              char v53 = v51;
            }
            else {
              char v53 = v52;
            }
            if (v53) {
              goto LABEL_108;
            }
          }
        }
        else if (((uint64_t)theSet[1] & 4) != 0)
        {
          goto LABEL_108;
        }
        if (v43)
        {
          unint64_t v60 = v45 | ((unint64_t)v43 << 16);
          unint64_t v61 = a3;
          this = (uint64_t)std::vector<std::tuple<unsigned short,unsigned short,long>,TInlineBufferAllocator<std::tuple<unsigned short,unsigned short,long>,30ul>>::emplace<std::tuple<unsigned short,unsigned short,long>>((char **)v4, (uint64_t)v39, (__int16 *)&v60);
          unsigned __int16 v43 = 0;
          CFStringRef v39 = (char *)(this + 16);
        }
        else
        {
          unsigned __int16 v43 = 0;
        }
LABEL_112:
        if (v42 == ++v44)
        {
          unsigned __int16 v41 = v42;
          if (v43)
          {
            unint64_t v60 = v45 | ((unint64_t)v43 << 16);
            unint64_t v61 = a3;
            this = (uint64_t)std::vector<std::tuple<unsigned short,unsigned short,long>,TInlineBufferAllocator<std::tuple<unsigned short,unsigned short,long>,30ul>>::emplace<std::tuple<unsigned short,unsigned short,long>>((char **)v4, (uint64_t)v39, (__int16 *)&v60);
            CFStringRef v39 = (char *)(this + 16);
            unsigned __int16 v41 = v42;
          }
          goto LABEL_91;
        }
      }
    }
    unsigned __int16 v41 = *((_WORD *)v39 + 1);
    v39 += 16;
    if (v39 != *(char **)(v4 + 8)) {
      continue;
    }
    break;
  }
  uint64_t v57 = 30;
  if ((unint64_t)(v40 >> 4) <= 0x1E) {
    uint64_t v58 = 30;
  }
  else {
    uint64_t v58 = v40 >> 4;
  }
  if ((unint64_t)((uint64_t)(*(void *)(v4 + 16) - *(void *)v4) >> 4) > 0x1E) {
    uint64_t v57 = (uint64_t)(*(void *)(v4 + 16) - *(void *)v4) >> 4;
  }
  if (v57 != v58) {
    *(void *)(v4 + 512) = *(void *)v4;
  }
  return this;
}

char *std::vector<std::tuple<unsigned short,unsigned short,long>,TInlineBufferAllocator<std::tuple<unsigned short,unsigned short,long>,30ul>>::emplace<std::tuple<unsigned short,unsigned short,long>>(char **a1, uint64_t a2, __int16 *a3)
{
  unint64_t v5 = *a1;
  unint64_t v6 = (unint64_t)a1[1];
  uint64_t v7 = a2 - (void)*a1;
  unint64_t v8 = (unint64_t)&(*a1)[v7 & 0xFFFFFFFFFFFFFFF0];
  unint64_t v9 = (unint64_t)a1[2];
  if (v6 >= v9)
  {
    CFStringRef v39 = 0;
    uint64_t v40 = 0;
    unsigned __int16 v41 = 0;
    unint64_t v17 = ((uint64_t)(v6 - (void)v5) >> 4) + 1;
    if (v17 >> 60) {
      abort();
    }
    uint64_t v18 = v7 >> 4;
    uint64_t v19 = v9 - (void)v5;
    uint64_t v20 = v19 >> 3;
    if (v19 >> 3 <= v17) {
      uint64_t v20 = v17;
    }
    if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v21 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v21 = v20;
    }
    unsigned __int16 v43 = a1 + 3;
    if (v21) {
      CFArrayRef v22 = TInlineBufferAllocator<CGPoint,30ul>::allocate((uint64_t)(a1 + 3), v21);
    }
    else {
      CFArrayRef v22 = 0;
    }
    id v26 = &v22[16 * v18];
    unint64_t v27 = &v22[16 * v21];
    unsigned int v42 = v27;
    if (v18 == v21)
    {
      if ((uint64_t)(v7 & 0xFFFFFFFFFFFFFFF0) < 1)
      {
        if ((unint64_t)v7 < 0x10) {
          unint64_t v29 = 1;
        }
        else {
          unint64_t v29 = (v7 >> 3) & 0xFFFFFFFFFFFFFFFELL;
        }
        BOOL v48 = a1 + 3;
        UTF32Char v44 = v22;
        unsigned __int16 v45 = &v22[16 * v18];
        CFStringRef v39 = TInlineBufferAllocator<CGPoint,30ul>::allocate((uint64_t)(a1 + 3), v29);
        unsigned int v42 = &v39[16 * v29];
        unsigned int v46 = v45;
        CFIndex v47 = v27;
        std::__split_buffer<std::tuple<unsigned short,unsigned short,long>,TInlineBufferAllocator<std::tuple<unsigned short,unsigned short,long>,30ul> &>::~__split_buffer((uint64_t)&v44);
        id v26 = &v39[16 * (v29 >> 2)];
      }
      else
      {
        unint64_t v28 = v18 + 2;
        if (v18 >= -1) {
          unint64_t v28 = v18 + 1;
        }
        v26 -= 16 * (v28 >> 1);
      }
    }
    *(_OWORD *)id v26 = *(_OWORD *)a3;
    uint8x8_t v30 = v26 + 16;
    unsigned __int16 v41 = v26 + 16;
    uint64_t v31 = *a1;
    if (*a1 == (char *)v8)
    {
      unint64_t v33 = v26;
    }
    else
    {
      unint64_t v32 = v8;
      unint64_t v33 = v26;
      do
      {
        *((_OWORD *)v33 - 1) = *(_OWORD *)(v32 - 16);
        v33 -= 16;
        v32 -= 16;
      }
      while ((char *)v32 != v31);
      uint8x8_t v30 = v41;
    }
    uint64_t v40 = v33;
    uint64_t v34 = a1[1];
    if (v34 != (char *)v8)
    {
      do
      {
        long long v35 = *(_OWORD *)v8;
        v8 += 16;
        *(_OWORD *)uint8x8_t v30 = v35;
        v30 += 16;
      }
      while ((char *)v8 != v34);
      unint64_t v33 = v40;
      unint64_t v8 = (unint64_t)a1[1];
    }
    UTF32Char v36 = *a1;
    *a1 = v33;
    a1[1] = v30;
    unint64_t v37 = a1[2];
    a1[2] = v42;
    unsigned __int16 v41 = (char *)v8;
    unsigned int v42 = v37;
    CFStringRef v39 = v36;
    uint64_t v40 = v36;
    std::__split_buffer<std::tuple<unsigned short,unsigned short,long>,TInlineBufferAllocator<std::tuple<unsigned short,unsigned short,long>,30ul> &>::~__split_buffer((uint64_t)&v39);
    return v26;
  }
  else if (v8 == v6)
  {
    *(_OWORD *)unint64_t v8 = *(_OWORD *)a3;
    a1[1] = (char *)(v8 + 16);
  }
  else
  {
    __int16 v10 = *a3;
    __int16 v11 = a3[1];
    uint64_t v12 = *((void *)a3 + 1);
    unint64_t v13 = v8 + 16;
    CFIndex v14 = (long long *)(v6 - 16);
    unint64_t v15 = a1[1];
    while ((unint64_t)v14 < v6)
    {
      long long v16 = *v14++;
      *(_OWORD *)unint64_t v15 = v16;
      v15 += 16;
    }
    a1[1] = v15;
    if (v6 != v13)
    {
      uint64_t v23 = (uint64_t)(v6 - v13) >> 4;
      id v24 = (void *)(v6 - 8);
      uint64_t v25 = 16 * v23;
      do
      {
        *((_WORD *)v24 - 4) = *(_WORD *)(v8 + v25 - 16);
        *((_WORD *)v24 - 3) = *(_WORD *)(v8 + v25 - 14);
        void *v24 = *(void *)(v8 + v25 - 8);
        v24 -= 2;
        v25 -= 16;
      }
      while (v25);
    }
    *(_WORD *)unint64_t v8 = v10;
    *(_WORD *)(v8 + 2) = v11;
    *(void *)(v8 + 8) = v12;
  }
  return (char *)v8;
}

uint64_t CharRangeToDescriptorMap::GetDescriptorIndexForChar(CharRangeToDescriptorMap *this, unsigned int a2)
{
  CFArrayRef v2 = (unsigned __int16 *)*((void *)this + 64);
  if (*v2 <= a2 && v2[1] > a2) {
    return *((void *)v2 + 1);
  }
  CFArrayRef v2 = *(unsigned __int16 **)this;
  uint64_t v3 = (unsigned __int16 *)*((void *)this + 1);
  if (v3 == *(unsigned __int16 **)this) {
    return -1;
  }
  unint64_t v4 = ((uint64_t)v3 - *(void *)this) >> 4;
  while (1)
  {
    unint64_t v5 = v4 >> 1;
    unint64_t v6 = &v2[8 * (v4 >> 1)];
    if (v6[1] <= a2)
    {
      CFArrayRef v2 = v6 + 8;
      unint64_t v5 = v4 + ~v5;
      goto LABEL_9;
    }
    if (*v6 <= a2) {
      break;
    }
    uint64_t v3 = &v2[8 * (v4 >> 1)];
LABEL_9:
    unint64_t v4 = v5;
    if (!v5) {
      return -1;
    }
  }
  if (v4 >= 2)
  {
    do
    {
      unint64_t v8 = v5 >> 1;
      unint64_t v9 = &v2[8 * (v5 >> 1)];
      unsigned int v10 = v9[1];
      __int16 v11 = v9 + 8;
      v5 += ~(v5 >> 1);
      if (v10 <= a2) {
        CFArrayRef v2 = v11;
      }
      else {
        unint64_t v5 = v8;
      }
    }
    while (v5);
  }
  uint64_t v12 = v6 + 8;
  if (v3 != v6 + 8)
  {
    unint64_t v13 = ((char *)v3 - (char *)(v6 + 8)) >> 4;
    uint64_t v3 = v12;
    do
    {
      unint64_t v14 = v13 >> 1;
      unint64_t v15 = &v3[8 * (v13 >> 1)];
      unsigned int v17 = *v15;
      long long v16 = v15 + 8;
      v13 += ~(v13 >> 1);
      if (v17 > a2) {
        unint64_t v13 = v14;
      }
      else {
        uint64_t v3 = v16;
      }
    }
    while (v13);
  }
  if (v2 != v3)
  {
    *((void *)this + 64) = v2;
    return *((void *)v2 + 1);
  }
  return -1;
}

CFIndex TFontDescriptorFilter::GetResultCount(atomic_ullong *this)
{
  return CFSetGetCount((CFSetRef)atomic_load_explicit(this + 2, memory_order_acquire));
}

id TFontDescriptorFilter::CopyFilteredSet(atomic_ullong *this)
{
  return (id)atomic_load_explicit(this + 2, memory_order_acquire);
}

unint64_t TFontDescriptorFilter::CreateSortedArray(atomic_ullong *this, CFComparisonResult (__cdecl *a2)(const void *, const void *, void *), void *a3)
{
  CreateSortedArrayWithSet((CFSetRef)atomic_load_explicit(this + 1, memory_order_acquire), a2, a3, (CFArrayRef *)&v5);
  unint64_t v3 = atomic_exchange((atomic_ullong *volatile)&v5, 0);

  return v3;
}

unint64_t TFontDescriptorFilter::CreateFilteredArray(atomic_ullong *this, CFComparisonResult (__cdecl *a2)(const void *, const void *, void *), void *a3)
{
  CreateSortedArrayWithSet((CFSetRef)atomic_load_explicit(this + 2, memory_order_acquire), a2, a3, (CFArrayRef *)&v5);
  unint64_t v3 = atomic_exchange((atomic_ullong *volatile)&v5, 0);

  return v3;
}

void TFontDescriptorFilter::PerformFilter(atomic_ullong *context, int a2)
{
  if (atomic_load_explicit(context + 1, memory_order_acquire))
  {
    unint64_t v3 = (void (__cdecl *)(const void *, void *))TFontDescriptorFilter::FilterFunctionToAdd;
    if (a2 != 1)
    {

      unint64_t v3 = (void (__cdecl *)(const void *, void *))TFontDescriptorFilter::FilterFunctionToRemove;
    }
    CFSetRef explicit = (const __CFSet *)atomic_load_explicit(context + 1, memory_order_acquire);
    CFSetApplyFunction(explicit, v3, context);
  }
}

const __CFSet *TFontDescriptorDuplicateFilter::FilterShouldIncludeDescriptor(uint64_t a1, const void *a2)
{
  CFSetRef result = (const __CFSet *)atomic_load_explicit((atomic_ullong *volatile)(a1 + 8), memory_order_acquire);
  if (result) {
    return (const __CFSet *)(CFSetContainsValue(result, a2) != 0);
  }
  return result;
}

const __CFDictionary *TDescriptorSource::CopySystemWideFallbackDescriptor(unsigned int)const::$_0::__invoke()
{
  qword_1EB2CE1A0 = (uint64_t)CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  CFDictionaryRef result = (const __CFDictionary *)GetCTPresetFallbacksDictionary();
  if (result)
  {
    CFDictionaryRef result = (const __CFDictionary *)CFDictionaryGetValue(result, @"SystemWideFallbacks");
    qword_1EB2CE190 = (uint64_t)result;
  }
  return result;
}

CFCharacterSetRef GetSystemFontsComboCharacterSet(void)::$_0::__invoke()
{
  CFCharacterSetRef result = TDescriptorSource::CopyPredefinedCharacterSet((TDescriptorSource *)@"CTFontSystemComboCharacterSet", 0);
  qword_1EB2CE208 = (uint64_t)result;
  return result;
}

void TDescriptorSource::CopyLastResort(void)const::$_0::__invoke()
{
  TDescriptorSource::TDescriptorSource((TDescriptorSource *)v12);
  id v11 = (id)0xAAAAAAAAAAAAAAAALL;
  TDescriptorSource::CopyFontDescriptorPerPostScriptName(&v11);
  if (atomic_load_explicit((atomic_ullong *volatile)&v11, memory_order_acquire))
  {
    uint64_t v0 = (TDescriptor **)(id)atomic_load_explicit((atomic_ullong *volatile)&v11, memory_order_acquire);
    uint64_t v1 = v0;
    CFArrayRef v2 = v0[5];
    if ((*((_DWORD *)v2 + 4) & 0x80000000) == 0) {
      TDescriptor::InitBaseFont(v0[5], 0, 0.0);
    }
    unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)v2 + 4, memory_order_acquire);

    if (explicit)
    {
      id v10 = (id)0xAAAAAAAAAAAAAAAALL;
      (*(void (**)(id *__return_ptr, unint64_t))(*(void *)explicit + 200))(&v9, explicit);
      TCGFontCache::CopyFont((TCGFontCache *)atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire), 0, 0, (atomic_ullong *)&v10);

      if (atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire))
      {
        qword_1EB2CE1A8 = atomic_exchange((atomic_ullong *volatile)&v11, 0);
        id v4 = v10;
LABEL_14:

        goto LABEL_15;
      }
    }
  }
  CFLog();
  id v10 = (id)0xAAAAAAAAAAAAAAAALL;
  id v5 = getsectiondata((const mach_header_64 *)&dword_184A15000, "__FONT_DATA", "__LastResort", (unint64_t *)&v10);
  if (v5)
  {
    CFDataRef v6 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v5, (CFIndex)v10, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
    if (FPFontCreateWithData())
    {
      uint64_t v7 = (void *)CGFontCreateWithParserFont();
      if (v7)
      {
        id v9 = (id)0xAAAAAAAAAAAAAAAALL;
        TCFBase_NEW<CTFontDescriptor,CGFont *&,is_inmemory_t const&>(&v8);
        id v9 = (id)atomic_exchange((atomic_ullong *volatile)&v8, 0);

        qword_1EB2CE1A8 = atomic_exchange((atomic_ullong *volatile)&v9, 0);
      }

      FPFontRelease();
    }
    id v4 = v6;
    goto LABEL_14;
  }
LABEL_15:
}

CFCharacterSetRef TDescriptorSource::GetAppleColorEmojiCharacterSet(void)const::$_0::__invoke()
{
  uint64_t v0 = _CTGetEmojiFontName(0);
  CFCharacterSetRef result = CreateCharacterSetForFont(v0);
  qword_1EB2CE1B8 = (uint64_t)result;
  return result;
}

void TDescriptorSource::CopyDescriptorForRequest(__CFDictionary const*,__CFSet const*,__CFDictionary const*,unsigned long)const::$_0::__invoke(void *key, atomic_ullong *a2)
{
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<float>>(unint64_t a1)
{
  if (a1 >> 62) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(4 * a1);
}

uint64_t CTFontLogSystemFontNameRequest::$_0::__invoke(CTFontLogSystemFontNameRequest::$_0 *this, void *a2)
{
  return CFLog();
}

void TLRUCacheImp<TRequestCacheNode,16ul>::RemoveAll(uint64_t a1)
{
  *(_DWORD *)a1 = TGenerationSeed::sGeneration;
  v5[0] = (atomic_ullong)&unk_1ED05E6A0;
  v5[1] = 0;
  *(_OWORD *)CFDataRef v6 = 0u;
  *(_OWORD *)uint64_t v7 = 0u;
  for (uint64_t i = 24; i != 792; i += 48)
    TRequestCacheNode::operator=((atomic_ullong *)(a1 + i), v5);
  v5[0] = (atomic_ullong)&unk_1ED05E6A0;

  *(_OWORD *)(a1 + 8) = xmmword_184B8ABB0;
  unint64_t v3 = (uint64_t *)(a1 + 32);
  for (uint64_t j = 1; j != 16; ++j)
  {
    *unint64_t v3 = j;
    v3 += 6;
  }
  *(void *)(a1 + 752) = 0;
}

CFArrayRef GetOrderedLanguages(void)::$_0::__invoke()
{
  values[10] = *(void **)MEMORY[0x1E4F143B8];
  values[0] = @"zh-Hans";
  values[1] = @"zh-Hant";
  values[2] = @"zh-HK";
  values[3] = @"zh-MO";
  values[4] = @"ja";
  values[5] = @"ko";
  values[6] = @"ar";
  values[7] = @"ur";
  values[8] = @"my";
  values[9] = @"my-Qaag";
  CFArrayRef result = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)values, 10, MEMORY[0x1E4F1D510]);
  qword_1EB2CE228 = (uint64_t)result;
  return result;
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long,std::unique_ptr<CharRangeToDescriptorMap>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::unique_ptr<CharRangeToDescriptorMap>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::unique_ptr<CharRangeToDescriptorMap>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::unique_ptr<CharRangeToDescriptorMap>>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<unsigned long,std::unique_ptr<CharRangeToDescriptorMap>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::unique_ptr<CharRangeToDescriptorMap>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::unique_ptr<CharRangeToDescriptorMap>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::unique_ptr<CharRangeToDescriptorMap>>>>::__deallocate_node(a1, *(void **)(a1 + 16));
  CFArrayRef v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<unsigned long,std::unique_ptr<CharRangeToDescriptorMap>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::unique_ptr<CharRangeToDescriptorMap>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::unique_ptr<CharRangeToDescriptorMap>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::unique_ptr<CharRangeToDescriptorMap>>>>::__deallocate_node(int a1, void *__p)
{
  if (__p)
  {
    CFArrayRef v2 = __p;
    do
    {
      unint64_t v3 = (void *)*v2;
      id v4 = (void **)v2[3];
      v2[3] = 0;
      if (v4) {
        std::default_delete<CharRangeToDescriptorMap>::operator()[abi:nn180100]((uint64_t)(v2 + 3), v4);
      }
      operator delete(v2);
      CFArrayRef v2 = v3;
    }
    while (v3);
  }
}

uint64_t CopyDefaultFontFallbacks(void)::$_0::__invoke()
{
  uint64_t result = CTFontGetPlistFromGSFontCache(@"DefaultFontFallbacks.plist", 0);
  qword_1EB2CE248 = result;
  return result;
}

uint64_t std::__split_buffer<std::tuple<unsigned short,unsigned short,long>,TInlineBufferAllocator<std::tuple<unsigned short,unsigned short,long>,30ul> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3) {
    *(void *)(a1 + 16) = v2 + ((v3 - v2 + 15) & 0xFFFFFFFFFFFFFFF0);
  }
  id v4 = *(void **)a1;
  if (*(void *)a1)
  {
    unint64_t v5 = *(void *)(a1 + 32);
    CFDataRef v6 = (void *)(v5 + 480);
    if (v5 <= (unint64_t)v4 && v6 > v4)
    {
      if (*(void *)(a1 + 24) == *v6) {
        *CFDataRef v6 = v4;
      }
    }
    else
    {
      operator delete(v4);
    }
  }
  return a1;
}

void TFontDescriptorFilter::FilterFunctionToRemove(TFontDescriptorFilter *this, atomic_ullong *a2, void *a3)
{
  if (((*(uint64_t (**)(atomic_ullong *, TFontDescriptorFilter *, void *))(*a2 + 56))(a2, this, a3) & 1) == 0)
  {
    unint64_t explicit = (__CFSet *)atomic_load_explicit(a2 + 2, memory_order_acquire);
    CFSetRemoveValue(explicit, this);
  }
}

void *std::__hash_table<std::__hash_value_type<unsigned long,std::unique_ptr<CharRangeToDescriptorMap>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::unique_ptr<CharRangeToDescriptorMap>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::unique_ptr<CharRangeToDescriptorMap>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::unique_ptr<CharRangeToDescriptorMap>>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>(uint64_t *a1, unint64_t *a2, uint64_t a3, void **a4)
{
  unint64_t v6 = *a2;
  unint64_t v7 = a1[1];
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v9 = *a2;
      if (v6 >= v7) {
        unint64_t v9 = v6 % v7;
      }
    }
    else
    {
      unint64_t v9 = (v7 - 1) & v6;
    }
    id v10 = *(void ***)(*a1 + 8 * v9);
    if (v10)
    {
      for (uint64_t i = *v10; i; uint64_t i = (void *)*i)
      {
        unint64_t v12 = i[1];
        if (v12 == v6)
        {
          if (i[2] == v6) {
            return i;
          }
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v12 >= v7) {
              v12 %= v7;
            }
          }
          else
          {
            v12 &= v7 - 1;
          }
          if (v12 != v9) {
            break;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v9 = 0xAAAAAAAAAAAAAAAALL;
  }
  unint64_t v13 = a1 + 2;
  uint64_t i = operator new(0x20uLL);
  *uint64_t i = 0;
  i[1] = v6;
  i[2] = **a4;
  i[3] = 0;
  float v14 = (float)(unint64_t)(a1[3] + 1);
  float v15 = *((float *)a1 + 8);
  if (!v7 || (float)(v15 * (float)v7) < v14)
  {
    BOOL v16 = 1;
    if (v7 >= 3) {
      BOOL v16 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v7);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      int8x8_t prime = (int8x8_t)v18;
    }
    else {
      int8x8_t prime = (int8x8_t)v17;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v7 = a1[1];
    }
    if (*(void *)&prime > v7) {
      goto LABEL_30;
    }
    if (*(void *)&prime < v7)
    {
      unint64_t v26 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v7 < 3 || (uint8x8_t v27 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v27.i16[0] = vaddlv_u8(v27), v27.u32[0] > 1uLL))
      {
        unint64_t v26 = std::__next_prime(v26);
      }
      else
      {
        uint64_t v28 = 1 << -(char)__clz(v26 - 1);
        if (v26 >= 2) {
          unint64_t v26 = v28;
        }
      }
      if (*(void *)&prime <= v26) {
        int8x8_t prime = (int8x8_t)v26;
      }
      if (*(void *)&prime >= v7)
      {
        unint64_t v7 = a1[1];
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          uint64_t v20 = operator new(8 * *(void *)&prime);
          unint64_t v21 = (void *)*a1;
          *a1 = (uint64_t)v20;
          if (v21) {
            operator delete(v21);
          }
          uint64_t v22 = 0;
          a1[1] = (uint64_t)prime;
          do
            *(void *)(*a1 + 8 * v22++) = 0;
          while (*(void *)&prime != v22);
          uint64_t v23 = (void *)*v13;
          if (*v13)
          {
            unint64_t v24 = v23[1];
            uint8x8_t v25 = (uint8x8_t)vcnt_s8(prime);
            v25.i16[0] = vaddlv_u8(v25);
            if (v25.u32[0] > 1uLL)
            {
              if (v24 >= *(void *)&prime) {
                v24 %= *(void *)&prime;
              }
            }
            else
            {
              v24 &= *(void *)&prime - 1;
            }
            *(void *)(*a1 + 8 * v24) = v13;
            unint64_t v29 = (void *)*v23;
            if (*v23)
            {
              do
              {
                unint64_t v30 = v29[1];
                if (v25.u32[0] > 1uLL)
                {
                  if (v30 >= *(void *)&prime) {
                    v30 %= *(void *)&prime;
                  }
                }
                else
                {
                  v30 &= *(void *)&prime - 1;
                }
                if (v30 != v24)
                {
                  if (!*(void *)(*a1 + 8 * v30))
                  {
                    *(void *)(*a1 + 8 * v30) = v23;
                    goto LABEL_55;
                  }
                  *uint64_t v23 = *v29;
                  void *v29 = **(void **)(*a1 + 8 * v30);
                  **(void **)(*a1 + 8 * v30) = v29;
                  unint64_t v29 = v23;
                }
                unint64_t v30 = v24;
LABEL_55:
                uint64_t v23 = v29;
                unint64_t v29 = (void *)*v29;
                unint64_t v24 = v30;
              }
              while (v29);
            }
          }
          unint64_t v7 = (unint64_t)prime;
          goto LABEL_59;
        }
        long long v35 = (void *)*a1;
        *a1 = 0;
        if (v35) {
          operator delete(v35);
        }
        unint64_t v7 = 0;
        a1[1] = 0;
      }
    }
LABEL_59:
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v6 >= v7) {
        unint64_t v9 = v6 % v7;
      }
      else {
        unint64_t v9 = v6;
      }
    }
    else
    {
      unint64_t v9 = (v7 - 1) & v6;
    }
  }
  uint64_t v31 = *a1;
  unint64_t v32 = *(void **)(*a1 + 8 * v9);
  if (v32)
  {
    *uint64_t i = *v32;
LABEL_72:
    *unint64_t v32 = i;
    goto LABEL_73;
  }
  *uint64_t i = *v13;
  *unint64_t v13 = i;
  *(void *)(v31 + 8 * v9) = v13;
  if (*i)
  {
    unint64_t v33 = *(void *)(*i + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v33 >= v7) {
        v33 %= v7;
      }
    }
    else
    {
      v33 &= v7 - 1;
    }
    unint64_t v32 = (void *)(*a1 + 8 * v33);
    goto LABEL_72;
  }
LABEL_73:
  ++a1[3];
  return i;
}

uint64_t std::default_delete<CharRangeToDescriptorMap>::operator()[abi:nn180100](uint64_t a1, void **a2)
{
  if (a2)
  {
    std::__hash_table<EncoderAttempt,std::hash<EncoderAttempt>,std::equal_to<EncoderAttempt>,std::allocator<EncoderAttempt>>::~__hash_table((uint64_t)(a2 + 65));
    id v4 = a2;
    std::vector<CGPoint,TInlineBufferAllocator<CGPoint,30ul>>::__destroy_vector::operator()[abi:nn180100](&v4);
    return MEMORY[0x1853275C0](a2, 0x10E0C404E22EBADLL);
  }
  return result;
}

uint64_t TRunReorder::ReorderRuns(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 16);
  uint64_t v3 = *(void *)(a2 + 24);
  uint64_t v4 = v3 - v2;
  if (v3 != v2)
  {
    uint64_t v6 = result;
    uint64_t v7 = *(void *)(*(void *)v2 + 40);
    uint64_t v8 = *(void *)(v7 + 160);
    if (v8 && (*(_WORD *)(v8 + 66) & 4) != 0)
    {
      unsigned int BaseWritingDirection = 1;
    }
    else
    {
      unint64_t v9 = *(TParagraphStyle ***)(v7 + 168);
      if (!v9
        || (unsigned int BaseWritingDirection = TParagraphStyle::GetBaseWritingDirection(v9, (const void *)a2),
            (BaseWritingDirection & 0x80000000) != 0))
      {
        unsigned int BaseWritingDirection = (*(uint64_t (**)(uint64_t, void))(*(void *)v6 + 24))(v6, *(void *)(a2 + 72));
      }
    }
    uint64_t result = TLine::SetTrailingWhitespaceLevel((TLine *)a2, BaseWritingDirection == 1);
    __int16 v12 = *(_WORD *)(a2 + 154);
    if ((v12 & 0x80) == 0)
    {
      unsigned __int8 v24 = -86;
      uint64_t result = TRunReorder::GetLevelRange((TRunReorder *)a2, (TLine *)&v24, v11);
      unsigned int v14 = v24;
      if (v24 <= result)
      {
        unsigned __int8 v15 = result;
        uint64_t v16 = v4 >> 3;
        do
        {
          v13.CFIndex location = 0;
          uint64_t result = TRunReorder::FindRunRange((TRunReorder *)a2, (TLine *)v15, 0, v13);
          if (result < v16)
          {
            uint64_t v18 = result;
            v13.CFIndex location = v17;
            v12 |= 0x80u;
            do
            {
              CFIndex v19 = v13.location + v18 - 1;
              if (v19 > v18)
              {
                CFIndex v20 = v18;
                do
                {
                  uint64_t v21 = *(void *)(a2 + 16);
                  uint64_t v22 = *(void *)(v21 + 8 * v20);
                  *(void *)(v21 + 8 * v20) = *(void *)(v21 + 8 * v19);
                  *(void *)(v21 + 8 * v19) = v22;
                  ++v20;
                  --v19;
                }
                while (v19 > v20);
              }
              *(_WORD *)(a2 + 154) = v12;
              uint64_t result = TRunReorder::FindRunRange((TRunReorder *)a2, (TLine *)v15, v18, v13);
              uint64_t v18 = result;
              v13.CFIndex location = v23;
            }
            while (result < v16);
          }
          --v15;
        }
        while (v14 <= v15);
      }
    }
    if (BaseWritingDirection == 1) {
      *(_WORD *)(a2 + 152) |= 8u;
    }
  }
  return result;
}

uint64_t TRunReorder::GetLevelRange(TRunReorder *this, TLine *a2, unsigned __int8 *a3)
{
  uint64_t v3 = (uint64_t *)*((void *)this + 2);
  uint64_t v4 = *((void *)this + 3) - (void)v3;
  if (v4 < 1)
  {
    uint64_t result = 0;
    unsigned __int8 v8 = 63;
  }
  else
  {
    LOBYTE(result) = 0;
    uint64_t v6 = (unint64_t)v4 >> 3;
    if (v6 <= 1) {
      uint64_t v7 = 1;
    }
    else {
      uint64_t v7 = v6;
    }
    unsigned __int8 v8 = 63;
    do
    {
      uint64_t v9 = *v3++;
      unsigned int v10 = *(unsigned __int8 *)(*(void *)(v9 + 40) + 224);
      if (result <= v10) {
        uint64_t result = v10;
      }
      else {
        uint64_t result = result;
      }
      if ((v10 & (v10 < v8)) != 0) {
        unsigned __int8 v8 = v10;
      }
      --v7;
    }
    while (v7);
  }
  *(unsigned char *)a2 = v8;
  return result;
}

uint64_t TRunReorder::FindRunRange(TRunReorder *this, TLine *a2, uint64_t a3, CFRange a4)
{
  uint64_t v4 = *((void *)this + 2);
  uint64_t v5 = (*((void *)this + 3) - v4) >> 3;
  uint64_t result = a3 + a4.location;
  if (v5 > a3 + a4.location)
  {
    uint64_t v7 = (uint64_t *)(v4 + 8 * result + 8);
    while (*(unsigned __int8 *)(*(void *)(*(void *)(v4 + 8 * result) + 40) + 224) < a2)
    {
      ++result;
      ++v7;
      if (v5 <= result) {
        return v5;
      }
    }
    uint64_t v8 = 1;
    do
    {
      if (v5 <= result + v8) {
        break;
      }
      uint64_t v9 = *v7++;
      ++v8;
    }
    while (*(unsigned __int8 *)(*(void *)(v9 + 40) + 224) >= a2);
  }
  return result;
}

void *TRunReorder::ReorderRuns(void *this, TLine *a2, unsigned __int8 *a3)
{
  uint64_t v4 = this[2];
  uint64_t v3 = this[3];
  uint64_t v5 = v3 - v4;
  if (v3 != v4)
  {
    uint64_t v6 = this;
    unsigned __int8 v19 = -86;
    this = (void *)TRunReorder::GetLevelRange((TRunReorder *)this, (TLine *)&v19, a3);
    unsigned int v8 = v19;
    if (v19 <= this)
    {
      unsigned __int8 v9 = this;
      uint64_t v10 = v5 >> 3;
      __int16 v11 = *((_WORD *)v6 + 77);
      do
      {
        v7.CFIndex location = 0;
        this = (void *)TRunReorder::FindRunRange((TRunReorder *)v6, (TLine *)v9, 0, v7);
        if ((uint64_t)this < v10)
        {
          uint64_t v13 = (uint64_t)this;
          v7.CFIndex location = v12;
          v11 |= 0x80u;
          do
          {
            CFIndex v14 = v7.location + v13 - 1;
            if (v14 > v13)
            {
              CFIndex v15 = v13;
              do
              {
                uint64_t v16 = v6[2];
                uint64_t v17 = *(void *)(v16 + 8 * v15);
                *(void *)(v16 + 8 * v15) = *(void *)(v16 + 8 * v14);
                *(void *)(v16 + 8 * v14) = v17;
                ++v15;
                --v14;
              }
              while (v14 > v15);
            }
            *((_WORD *)v6 + 77) = v11;
            this = (void *)TRunReorder::FindRunRange((TRunReorder *)v6, (TLine *)v9, v13, v7);
            uint64_t v13 = (uint64_t)this;
            v7.CFIndex location = v18;
          }
          while ((uint64_t)this < v10);
        }
        --v9;
      }
      while (v8 <= v9);
    }
  }
  return this;
}

void TLocaleManager::TLocaleManager(TLocaleManager *this)
{
  if (qword_1EB2CE2A0 != -1) {
    dispatch_once_f(&qword_1EB2CE2A0, 0, (dispatch_function_t)GetTheLocaleManager(void)::$_0::__invoke);
  }
  *(void *)this = qword_1EB2CE298;
  os_unfair_lock_lock_with_options();
}

void TLocaleManagerImp::CopyLanguagesFromCharacterSet(atomic_ullong *this@<X0>, const __CFCharacterSet *a2@<X1>, const __CFArray *a3@<X2>, id a4@<X3>, void *a5@<X8>)
{
  id v21 = (id)0xAAAAAAAAAAAAAAAALL;
  TCFMutableSet::TCFMutableSet((TCFMutableSet *)&v21, a4);
  id v20 = (id)0xAAAAAAAAAAAAAAAALL;
  TCFMutableArray::TCFMutableArray((TCFMutableArray *)&v20, a3);
  CFArrayRef SupportedLanguages = (const __CFArray *)TLocaleManagerImp::GetSupportedLanguages(this, v8);
  if (SupportedLanguages)
  {
    CFArrayRef v10 = SupportedLanguages;
    CFIndex Count = CFArrayGetCount(SupportedLanguages);
    if (Count)
    {
      CFIndex v12 = Count;
      CFIndex v13 = 0;
      CFAllocatorRef v14 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      do
      {
        CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v10, v13);
        CanonicalLanguageIdentifierFromString = (__CFString *)CFLocaleCreateCanonicalLanguageIdentifierFromString(v14, ValueAtIndex);
        if (CanonicalLanguageIdentifierFromString
          && !CFSetContainsValue((CFSetRef)atomic_load_explicit((atomic_ullong *volatile)&v21, memory_order_acquire), CanonicalLanguageIdentifierFromString))
        {
          id v19 = (id)0xAAAAAAAAAAAAAAAALL;
          TLocaleManagerImp::CopyExamplarSetForLanguage(this, CanonicalLanguageIdentifierFromString, (atomic_ullong *)&v19);
          if (atomic_load_explicit((atomic_ullong *volatile)&v19, memory_order_acquire)
            && CFCharacterSetIsSupersetOfSet(a2, (CFCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v19, memory_order_acquire)))
          {
            uint64_t v17 = CanonicalLanguageIdentifierFromString;
            CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire), v17);
          }
          CFSetAddValue((CFMutableSetRef)atomic_load_explicit((atomic_ullong *volatile)&v21, memory_order_acquire), CanonicalLanguageIdentifierFromString);
        }
        ++v13;
      }
      while (v12 != v13);
    }
  }
  *a5 = atomic_exchange((atomic_ullong *volatile)&v20, 0);
}

BOOL TLocaleManagerImp::CharacterSetCoversLanguage(atomic_ullong *this, const __CFCharacterSet *a2, const __CFString *a3)
{
  id v6 = (id)0xAAAAAAAAAAAAAAAALL;
  TLocaleManagerImp::CopyExamplarSetForLanguage(this, a3, (atomic_ullong *)&v6);
  if (atomic_load_explicit((atomic_ullong *volatile)&v6, memory_order_acquire)) {
    BOOL v4 = CFCharacterSetIsSupersetOfSet(a2, (CFCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v6, memory_order_acquire)) != 0;
  }
  else {
    BOOL v4 = 0;
  }

  return v4;
}

void TLocaleManagerImp::CopyExamplarSetForLanguage(atomic_ullong *this@<X0>, const __CFString *a2@<X1>, atomic_ullong *a3@<X8>)
{
  if (!atomic_load_explicit(this + 1, memory_order_acquire)) {
    goto LABEL_6;
  }
  unint64_t explicit = atomic_load_explicit(this + 2, memory_order_acquire);
  if (!a2 || !explicit) {
    goto LABEL_6;
  }
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CanonicalLanguageIdentifierFromString = (__CFString *)CFLocaleCreateCanonicalLanguageIdentifierFromString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2);
  if (CFSetContainsValue((CFSetRef)atomic_load_explicit(this + 2, memory_order_acquire), CanonicalLanguageIdentifierFromString))
  {

LABEL_6:
    *a3 = 0;
    return;
  }
  *a3 = 0xAAAAAAAAAAAAAAAALL;
  *a3 = (atomic_ullong)(id)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit(this + 1, memory_order_acquire), CanonicalLanguageIdentifierFromString);
  if (!atomic_load_explicit(a3, memory_order_acquire))
  {
    CFLocaleRef v8 = CFLocaleCreate(v6, CanonicalLanguageIdentifierFromString);
    if (v8)
    {
      CFLocaleRef v9 = v8;
      CFArrayRef Value = (void *)CFLocaleGetValue(v8, (CFLocaleKey)*MEMORY[0x1E4F1D208]);
      TCFRef<__CTFont const*>::Retain(a3, Value);
      if (atomic_load_explicit(a3, memory_order_acquire)) {
        CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit(this + 1, memory_order_acquire), CanonicalLanguageIdentifierFromString, (const void *)atomic_load_explicit(a3, memory_order_acquire));
      }
      CFRelease(v9);
    }
    if (!atomic_load_explicit(a3, memory_order_acquire)) {
      CFSetAddValue((CFMutableSetRef)atomic_load_explicit(this + 2, memory_order_acquire), CanonicalLanguageIdentifierFromString);
    }
  }
}

unint64_t TLocaleManagerImp::GetSupportedLanguages(atomic_ullong *this, double a2)
{
  if (!atomic_load_explicit(this, memory_order_acquire))
  {
    double Helper_x8__InternationalSupportVersionNumber = gotLoadHelper_x8__InternationalSupportVersionNumber(a2);
    if (*(void *)(v4 + 4064))
    {
      uint64_t v5 = (void *)MEMORY[0x185327A40](Helper_x8__InternationalSupportVersionNumber);
      TCFRef<__CTFont const*>::Retain(this, (id)objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F1CA20], "supportedLanguages"), "allObjects"));
    }
    if (!atomic_load_explicit(this, memory_order_acquire))
    {
      CFArrayRef v6 = CFLocaleCopyAvailableLocaleIdentifiers();
      CFArrayRef v7 = CFLocaleCopyISOLanguageCodes();
      id v13 = (id)0xAAAAAAAAAAAAAAAALL;
      CFSetRef v8 = v6;
      TCFMutableSet::TCFMutableSet((TCFMutableSet *)&v13, v8);

      id v12 = (id)0xAAAAAAAAAAAAAAAALL;
      CFSetRef v9 = v7;
      TCFMutableSet::TCFMutableSet((TCFMutableSet *)&v12, v9);

      if (atomic_load_explicit((atomic_ullong *volatile)&v12, memory_order_acquire)) {
        objc_msgSend((id)atomic_load_explicit((atomic_ullong *volatile)&v13, memory_order_acquire), "intersectSet:");
      }
      CFSetAddValue((CFMutableSetRef)atomic_load_explicit((atomic_ullong *volatile)&v13, memory_order_acquire), @"zh-Hans");
      CFSetAddValue((CFMutableSetRef)atomic_load_explicit((atomic_ullong *volatile)&v13, memory_order_acquire), @"zh-Hant");
      CreateSortedArrayWithSet((CFSetRef)atomic_load_explicit((atomic_ullong *volatile)&v13, memory_order_acquire), 0, 0, (CFArrayRef *)&v11);

      if (!atomic_load_explicit(this, memory_order_acquire))
      {
        id v11 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, MEMORY[0x1E4F1D510]);

        CFLog();
      }
    }
  }
  return atomic_load_explicit(this, memory_order_acquire);
}

void *CreateCanonicalLanguages@<X0>(const __CFArray *a1@<X0>, void *a2@<X8>)
{
  v5[4] = *MEMORY[0x1E4F143B8];
  v5[0] = &unk_1ED05FED0;
  v5[1] = CFStringGetTypeID();
  v5[3] = v5;
  CreateCopyOfArrayByApplyingFunction(a1, (uint64_t)v5, a2);
  return std::__function::__value_func<TCFRef<void const*> ()(void const*)>::~__value_func[abi:nn180100](v5);
}

BOOL CanonicalLocaleIdentifiersMatch(CFStringRef theString, CFStringRef prefix)
{
  if (theString == prefix) {
    return 1;
  }
  if ((theString != 0) == (prefix == 0)) {
    return 0;
  }
  int HasPrefix = CFStringHasPrefix(theString, prefix);
  int v5 = CFStringHasPrefix(prefix, theString);
  if (HasPrefix && v5) {
    return 1;
  }
  if (!(HasPrefix | v5)) {
    return 0;
  }
  CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)*MEMORY[0x1E4F1CF80], theString, @"-");
  CFIndex Count = CFArrayGetCount(ArrayBySeparatingStrings);
  CFArrayRef v11 = CFStringCreateArrayBySeparatingStrings(v8, prefix, @"-");
  CFIndex v12 = CFArrayGetCount(v11);
  if (v12 >= Count) {
    uint64_t v13 = Count;
  }
  else {
    uint64_t v13 = v12;
  }
  if (v13 < 1)
  {
    BOOL v6 = 1;
  }
  else
  {
    BOOL v6 = 0;
    for (i = 0; i != v13; BOOL v6 = i >= v13)
    {
      CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(ArrayBySeparatingStrings, i);
      uint64_t v16 = CFArrayGetValueAtIndex(v11, i);
      if (ValueAtIndex != v16 && (!ValueAtIndex || !v16 || !CFEqual(ValueAtIndex, v16))) {
        break;
      }
      ++i;
    }
  }

  return v6;
}

uint64_t GetEmojiPolicyFromLocale(const __CFString *a1)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    *(void *)&long long v2 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v32[0] = v2;
    v32[1] = v2;
    uint64_t v31 = 0;
    int64x2_t v30 = 0uLL;
    unint64_t v33 = v32;
    if (!CFStringGetCStringPtr(a1, 0x600u))
    {
      CFIndex Length = CFStringGetLength(a1);
      CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x600u);
      CFIndex v5 = MaximumSizeForEncoding + 1;
      BOOL v6 = (char *)v30.i64[0];
      if ((unint64_t)(MaximumSizeForEncoding + 1) <= v30.i64[1] - v30.i64[0])
      {
        if ((unint64_t)(MaximumSizeForEncoding + 1) < v30.i64[1] - v30.i64[0]) {
          v30.i64[1] = v30.i64[0] + v5;
        }
      }
      else
      {
        std::vector<char,TInlineBufferAllocator<char,30ul>>::__append(&v30, MaximumSizeForEncoding + 1 - (v30.i64[1] - v30.i64[0]));
        BOOL v6 = (char *)v30.i64[0];
      }
      CFStringGetCString(a1, v6, v5, 0x600u);
    }
    *(_DWORD *)&bytes[3] = 0;
    v28[2] = 0;
    *(_DWORD *)bytes = 0;
    int Script = uloc_getScript();
    if (Script < 1)
    {
LABEL_26:
      *(_DWORD *)((char *)v28 + 3) = 0;
      v28[0] = 0;
      KeywordCFArrayRef Value = uloc_getKeywordValue();
      uint64_t v7 = 0;
      if (KeywordValue < 1)
      {
LABEL_44:
        *(void *)bytes = &v30;
        std::vector<char,TInlineBufferAllocator<char,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)bytes);
        return v7;
      }
      id v19 = (__CFString *)CFStringCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)v28, KeywordValue, 0x600u, 0, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
      id v20 = v19;
      if (!v19) {
        goto LABEL_43;
      }
      id v21 = v19;
      uint64_t v22 = v21;
      CFIndex v23 = @"emoji";
      if (v22 == @"emoji")
      {
        uint64_t v7 = 2;
      }
      else
      {
        if (v22)
        {
          CFComparisonResult v24 = CFStringCompare(v22, @"emoji", 1uLL);

          if (v24 == kCFCompareEqualTo)
          {
            uint64_t v7 = 2;
LABEL_40:
            uint64_t v17 = v20;
            goto LABEL_41;
          }
        }
        else
        {
        }
        id v21 = v20;
        uint8x8_t v25 = v21;
        CFIndex v23 = @"text";
        if (v25 != @"text")
        {
          if (v25)
          {
            CFComparisonResult v26 = CFStringCompare(v25, @"text", 1uLL);

            if (v26 == kCFCompareEqualTo)
            {
              uint64_t v7 = 1;
              goto LABEL_40;
            }
          }
          else
          {
          }
LABEL_43:

          uint64_t v7 = 0;
          goto LABEL_44;
        }
        uint64_t v7 = 1;
      }

      goto LABEL_40;
    }
    CFSetRef v9 = (__CFString *)CFStringCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], bytes, Script, 0x600u, 0, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
    CFArrayRef v10 = v9;
    if (v9)
    {
      CFArrayRef v11 = v9;
      CFIndex v12 = v11;
      uint64_t v13 = @"Zsye";
      if (v12 == @"Zsye")
      {
        uint64_t v7 = 2;
      }
      else
      {
        if (v12)
        {
          CFComparisonResult v14 = CFStringCompare(v12, @"Zsye", 1uLL);

          if (v14 == kCFCompareEqualTo)
          {
            uint64_t v7 = 2;
LABEL_23:
            uint64_t v17 = v10;
LABEL_41:

            goto LABEL_44;
          }
        }
        else
        {
        }
        CFArrayRef v11 = v10;
        CFIndex v15 = v11;
        uint64_t v13 = @"Zsym";
        if (v15 != @"Zsym")
        {
          if (v15)
          {
            uint64_t v7 = 1;
            CFComparisonResult v16 = CFStringCompare(v15, @"Zsym", 1uLL);

            if (v16 == kCFCompareEqualTo) {
              goto LABEL_23;
            }
          }
          else
          {
          }
          goto LABEL_25;
        }
        uint64_t v7 = 1;
      }

      goto LABEL_23;
    }
LABEL_25:

    goto LABEL_26;
  }
  return 0;
}

uint64_t CurrentLocaleIsChina(void)
{
  if (qword_1EB2CE278 != -1) {
    dispatch_once(&qword_1EB2CE278, &__block_literal_global_1);
  }
  return _MergedGlobals_17[0];
}

uint64_t ___Z20CurrentLocaleIsChinav_block_invoke()
{
  uint64_t v0 = (void *)[MEMORY[0x1E4F1CA20] currentLocale];
  uint64_t result = objc_msgSend((id)objc_msgSend(v0, "objectForKey:", *MEMORY[0x1E4F1C400]), "isEqualToString:", @"CN");
  _MergedGlobals_17[0] = result;
  return result;
}

void CopyPreferredNumberingSystem(uint64_t *a1@<X8>)
{
  uint64_t v2 = _CFLocaleCopyPreferred();
  uint64_t v3 = (void *)v2;
  if (v2)
  {
    MEMORY[0x185325F30](v2);
    uint64_t v2 = _CFLocaleCopyNumberingSystemForLocaleIdentifier();
  }
  *a1 = v2;
}

void HandleLocaleChanged(__CFNotificationCenter *a1, void *a2, const __CFString *a3, const void *a4, const __CFDictionary *a5)
{
}

uint64_t EnumerateKnownUrduSequencesInString(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = InternationalSupportLibraryCore(0);
  if (result)
  {
    uint64_t result = getISEnumerateKnownUrduSequencesInStringSymbolLoc();
    if (result)
    {
      ISEnumerateKnownUrduSequencesInStringSymbolLoc = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))getISEnumerateKnownUrduSequencesInStringSymbolLoc();
      if (ISEnumerateKnownUrduSequencesInStringSymbolLoc)
      {
        return ISEnumerateKnownUrduSequencesInStringSymbolLoc(a1, a2, a3, a4);
      }
      else
      {
        CFArrayRef v10 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
        uint64_t result = objc_msgSend(v10, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(NSString, "stringWithUTF8String:", "void SoftLinked__ISEnumerateKnownUrduSequencesInString(CFStringRef, CFRange, void (^)(CFRange, BOOL *))"), @"LocaleSupport.cpp", 1102, @"%s", dlerror());
        __break(1u);
      }
    }
  }
  return result;
}

uint64_t StringContainsKnownUrduSequences(const __CFString *a1, CFRange a2)
{
  uint64_t v5 = 0;
  BOOL v6 = &v5;
  uint64_t v7 = 0x2020000000;
  char v8 = 0;
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  _OWORD v4[2] = ___Z32StringContainsKnownUrduSequencesPK10__CFString7CFRange_block_invoke;
  v4[3] = &unk_1E528B7B0;
  v4[4] = &v5;
  EnumerateKnownUrduSequencesInString((uint64_t)a1, a2.location, a2.length, (uint64_t)v4);
  uint64_t v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t ___Z32StringContainsKnownUrduSequencesPK10__CFString7CFRange_block_invoke(uint64_t result, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  *a4 = 1;
  return result;
}

void GetTheLocaleManager(void)::$_0::__invoke()
{
}

void TCFMutableSet::TCFMutableSet(TCFMutableSet *this, id a2)
{
  if (a2) {
    CFMutableSetRef Mutable = (CFMutableSetRef)a2;
  }
  else {
    CFMutableSetRef Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D548]);
  }
  *(void *)this = Mutable;
}

uint64_t InternationalSupportLibraryCore(char **a1)
{
  if (!InternationalSupportLibraryCore(char **)::frameworkLibrary) {
    InternationalSupportLibraryCore(char **)::frameworkLibrary = _sl_dlopen();
  }
  return InternationalSupportLibraryCore(char **)::frameworkLibrary;
}

uint64_t getISEnumerateKnownUrduSequencesInStringSymbolLoc(void)
{
  uint64_t v3 = 0;
  uint64_t v4 = &v3;
  uint64_t v5 = 0x2020000000;
  uint64_t v0 = getISEnumerateKnownUrduSequencesInStringSymbolLoc(void)::ptr;
  uint64_t v6 = getISEnumerateKnownUrduSequencesInStringSymbolLoc(void)::ptr;
  if (!getISEnumerateKnownUrduSequencesInStringSymbolLoc(void)::ptr)
  {
    v2[0] = MEMORY[0x1E4F143A8];
    v2[1] = 3221225472;
    v2[2] = ___ZL49getISEnumerateKnownUrduSequencesInStringSymbolLocv_block_invoke;
    v2[3] = &unk_1E528A348;
    v2[4] = &v3;
    ___ZL49getISEnumerateKnownUrduSequencesInStringSymbolLocv_block_invoke(v2);
    uint64_t v0 = v4[3];
  }
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t ___ZL31InternationalSupportLibraryCorePPc_block_invoke()
{
  uint64_t result = _sl_dlopen();
  InternationalSupportLibraryCore(char **)::frameworkLibrary = result;
  return result;
}

void *___ZL49getISEnumerateKnownUrduSequencesInStringSymbolLocv_block_invoke(void *a1)
{
  uint64_t v7 = 0;
  uint64_t v3 = InternationalSupportLibraryCore(&v7);
  if (!v3)
  {
    a1 = (void *)[MEMORY[0x1E4F28B00] currentHandler];
    uint64_t v6 = [NSString stringWithUTF8String:"void *InternationalSupportLibrary()"];
    uint64_t v4 = (char *)objc_msgSend(a1, "handleFailureInFunction:file:lineNumber:description:", v6, @"LocaleSupport.cpp", 1101, @"%s", v7);
    __break(1u);
    goto LABEL_5;
  }
  uint64_t v1 = (void *)v3;
  uint64_t v4 = v7;
  if (v7) {
LABEL_5:
  }
    free(v4);
  uint64_t result = dlsym(v1, "ISEnumerateKnownUrduSequencesInString");
  *(void *)(*(void *)(a1[4] + 8) + 24) = result;
  getISEnumerateKnownUrduSequencesInStringSymbolLoc(void)::ptr = *(void *)(*(void *)(a1[4] + 8) + 24);
  return result;
}

void std::__function::__func<CreateNormalizedLanguages(__CFArray const*)::$_0,std::allocator<CreateNormalizedLanguages(__CFArray const*)::$_0>,TCFRef<void const*> ()(void const*)>::~__func()
{
}

void *std::__function::__func<CreateNormalizedLanguages(__CFArray const*)::$_0,std::allocator<CreateNormalizedLanguages(__CFArray const*)::$_0>,TCFRef<void const*> ()(void const*)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1ED05FFA8;
  return result;
}

void std::__function::__func<CreateNormalizedLanguages(__CFArray const*)::$_0,std::allocator<CreateNormalizedLanguages(__CFArray const*)::$_0>,TCFRef<void const*> ()(void const*)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1ED05FFA8;
}

void std::__function::__func<CreateCanonicalLanguages(__CFArray const*)::$_0,std::allocator<CreateCanonicalLanguages(__CFArray const*)::$_0>,TCFRef<void const*> ()(void const*)>::~__func()
{
}

void *std::__function::__func<CreateCanonicalLanguages(__CFArray const*)::$_0,std::allocator<CreateCanonicalLanguages(__CFArray const*)::$_0>,TCFRef<void const*> ()(void const*)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1ED05FED0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<CreateCanonicalLanguages(__CFArray const*)::$_0,std::allocator<CreateCanonicalLanguages(__CFArray const*)::$_0>,TCFRef<void const*> ()(void const*)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1ED05FED0;
  a2[1] = v2;
  return result;
}

void std::__function::__func<CreateCanonicalLanguages(__CFArray const*)::$_0,std::allocator<CreateCanonicalLanguages(__CFArray const*)::$_0>,TCFRef<void const*> ()(void const*)>::operator()(uint64_t a1@<X0>, CFTypeRef *a2@<X1>, void *a3@<X8>)
{
  CFStringRef v4 = (const __CFString *)*a2;
  if (CFGetTypeID(*a2) == *(void *)(a1 + 8))
  {
    id CanonicalLanguageIdentifierFromString = (id)CFLocaleCreateCanonicalLanguageIdentifierFromString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v4);
    *a3 = atomic_exchange((atomic_ullong *volatile)&CanonicalLanguageIdentifierFromString, 0);
  }
  else
  {
    *a3 = 0;
  }
}

void std::__function::__func<CreateArrayOfNormalizedLanguagesWithOrder(__CFArray const*,__CFArray const*,LanguageIdentifierNormalizationUsage)::$_0,std::allocator<CreateArrayOfNormalizedLanguagesWithOrder(__CFArray const*,__CFArray const*,LanguageIdentifierNormalizationUsage)::$_0>,objc_object * ()(objc_object *)>::~__func()
{
}

void *std::__function::__func<CreateArrayOfNormalizedLanguagesWithOrder(__CFArray const*,__CFArray const*,LanguageIdentifierNormalizationUsage)::$_0,std::allocator<CreateArrayOfNormalizedLanguagesWithOrder(__CFArray const*,__CFArray const*,LanguageIdentifierNormalizationUsage)::$_0>,objc_object * ()(objc_object *)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1ED060110;
  return result;
}

void std::__function::__func<CreateArrayOfNormalizedLanguagesWithOrder(__CFArray const*,__CFArray const*,LanguageIdentifierNormalizationUsage)::$_0,std::allocator<CreateArrayOfNormalizedLanguagesWithOrder(__CFArray const*,__CFArray const*,LanguageIdentifierNormalizationUsage)::$_0>,objc_object * ()(objc_object *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1ED060110;
}

id std::__function::__func<CreateArrayOfNormalizedLanguagesWithOrder(__CFArray const*,__CFArray const*,LanguageIdentifierNormalizationUsage)::$_0,std::allocator<CreateArrayOfNormalizedLanguagesWithOrder(__CFArray const*,__CFArray const*,LanguageIdentifierNormalizationUsage)::$_0>,objc_object * ()(objc_object *)>::operator()(uint64_t a1, __CFString **a2)
{
  return NormalizeLanguage(*a2, 0);
}

id NormalizeLanguage(__CFString *a1, unsigned int a2)
{
  id v4 = (id)0xAAAAAAAAAAAAAAAALL;
  LanguageIdentifierByNormalizing(a1, a2, (atomic_ullong *)&v4);
  id v2 = (id)atomic_exchange((atomic_ullong *volatile)&v4, 0);

  return v2;
}

void *std::__function::__value_func<objc_object * ()(objc_object *)>::~__value_func[abi:nn180100](void *a1)
{
  id v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

CGColorRef CopyCGColor(void *a1)
{
  if ((objc_opt_respondsToSelector() & 1) == 0) {
    return 0;
  }
  id v2 = (void *)MEMORY[0x185327A40]();
  CGColorRef v3 = CGColorRetain((CGColorRef)objc_msgSend(a1, sel_CGColor));
  return v3;
}

id DrawGlyphsWithTextEffects(void *a1, const unsigned __int16 *a2, const CGPoint *a3, uint64_t a4, CGContext *a5)
{
  return objc_msgSend(a1, sel_drawGlyphs_positions_count_context_, a2, a3, a4, a5);
}

CFTypeID CTRubyAnnotationGetTypeID(void)
{
  if (TCFBase<TRubyAnnotation>::GetTypeID(void)::once != -1) {
    dispatch_once_f(&TCFBase<TRubyAnnotation>::GetTypeID(void)::once, 0, (dispatch_function_t)TCFBase<TRubyAnnotation>::GetTypeID(void)::{lambda(void *)#1}::__invoke);
  }
  return TCFBase<TRubyAnnotation>::fTypeID;
}

CTRubyAnnotationRef CTRubyAnnotationCreate(CTRubyAlignment alignment, CTRubyOverhang overhang, CGFloat sizeFactor, CFStringRef *text)
{
  id v14 = (id)0xAAAAAAAAAAAAAAAALL;
  uint64_t v8 = TCFBase<TRubyAnnotation>::Allocate();
  if (v8)
  {
    CFSetRef v9 = (char *)v8;
    uint64_t v10 = 0;
    *(unsigned char *)(v8 + 48) = alignment;
    *(void *)(v8 + 16) = 0;
    *(void *)(v8 + 24) = TRubyAnnotation::Hash;
    *(void *)(v8 + 32) = 0;
    *(void *)(v8 + 40) = v8 + 48;
    *(unsigned char *)(v8 + 49) = overhang;
    *(CGFloat *)(v8 + 56) = sizeFactor;
    *(unsigned char *)(v8 + 96) = 0;
    *(void *)(v8 + 104) = 0;
    *(void *)(v8 + 112) = 0;
    *(_WORD *)(v8 + 120) = 256;
    do
    {
      *(void *)&v9[v10 * 8 + 64] = (id)text[v10];
      ++v10;
    }
    while (v10 != 4);
    id v15 = v9;
    id v13 = (id)atomic_exchange((atomic_ullong *volatile)&v15, 0);
  }
  else
  {
    id v13 = 0;
  }
  id v14 = (id)atomic_exchange((atomic_ullong *volatile)&v13, 0);

  CFArrayRef v11 = (const __CTRubyAnnotation *)atomic_exchange((atomic_ullong *volatile)&v14, 0);
  return v11;
}

CTRubyAnnotationRef CTRubyAnnotationCreateWithAttributes(CTRubyAlignment alignment, CTRubyOverhang overhang, CTRubyPosition position, CFStringRef string, CFDictionaryRef attributes)
{
  id v16 = (id)0xAAAAAAAAAAAAAAAALL;
  uint64_t v10 = TCFBase<TRubyAnnotation>::Allocate();
  if (v10)
  {
    CFArrayRef v11 = (void *)v10;
    CFIndex v12 = (TRubyAnnotation *)(v10 + 48);
    v11[2] = 0;
    v11[3] = TRubyAnnotation::Hash;
    v11[4] = 0;
    v11[5] = v12;
    TRubyAnnotation::TRubyAnnotation(v12, alignment, overhang, position, (__CFString *)string, attributes);
    id v17 = v11;
    id v15 = (id)atomic_exchange((atomic_ullong *volatile)&v17, 0);
  }
  else
  {
    id v15 = 0;
  }
  id v16 = (id)atomic_exchange((atomic_ullong *volatile)&v15, 0);

  id v13 = (const __CTRubyAnnotation *)atomic_exchange((atomic_ullong *volatile)&v16, 0);
  return v13;
}

unint64_t CTRubyAnnotationCreateWithAttributedString(CTRubyAlignment a1, CTRubyOverhang a2, CTRubyPosition a3, void *a4)
{
  id v14 = (id)0xAAAAAAAAAAAAAAAALL;
  uint64_t v8 = TCFBase<TRubyAnnotation>::Allocate();
  if (v8)
  {
    CFSetRef v9 = (void *)v8;
    uint64_t v10 = (TRubyAnnotation *)(v8 + 48);
    v9[2] = 0;
    v9[3] = TRubyAnnotation::Hash;
    v9[4] = 0;
    v9[5] = v10;
    TRubyAnnotation::TRubyAnnotation(v10, a1, a2, a3, a4);
    id v15 = v9;
    id v13 = (id)atomic_exchange((atomic_ullong *volatile)&v15, 0);
  }
  else
  {
    id v13 = 0;
  }
  id v14 = (id)atomic_exchange((atomic_ullong *volatile)&v13, 0);

  unint64_t v11 = atomic_exchange((atomic_ullong *volatile)&v14, 0);
  return v11;
}

CTRubyAnnotationRef CTRubyAnnotationCreateCopy(CTRubyAnnotationRef rubyAnnotation)
{
  if (!rubyAnnotation) {
    return 0;
  }
  id v4 = (id)0xAAAAAAAAAAAAAAAALL;
  TCFBase_NEW<CTRubyAnnotation,CTRubyAnnotation const&>((uint64_t)rubyAnnotation, &v3);
  id v4 = (id)atomic_exchange((atomic_ullong *volatile)&v3, 0);

  uint64_t v1 = (const __CTRubyAnnotation *)atomic_exchange((atomic_ullong *volatile)&v4, 0);
  return v1;
}

void TCFBase_NEW<CTRubyAnnotation,CTRubyAnnotation const&>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = TCFBase<TRubyAnnotation>::Allocate();
  if (v4)
  {
    uint64_t v5 = (void *)v4;
    uint64_t v6 = (TRubyAnnotation *)(v4 + 48);
    atomic_ullong v5[2] = 0;
    v5[3] = TRubyAnnotation::Hash;
    v5[4] = 0;
    void v5[5] = v6;
    TRubyAnnotation::TRubyAnnotation(v6, *(const TRubyAnnotation **)(a1 + 40));
    id v7 = v5;
    *a2 = atomic_exchange((atomic_ullong *volatile)&v7, 0);
  }
  else
  {
    *a2 = 0;
  }
}

CTRubyAlignment CTRubyAnnotationGetAlignment(CTRubyAnnotationRef rubyAnnotation)
{
  if (rubyAnnotation) {
    return **((unsigned char **)rubyAnnotation + 5);
  }
  else {
    return -1;
  }
}

CTRubyOverhang CTRubyAnnotationGetOverhang(CTRubyAnnotationRef rubyAnnotation)
{
  if (rubyAnnotation) {
    return *(unsigned char *)(*((void *)rubyAnnotation + 5) + 1);
  }
  else {
    return -1;
  }
}

CGFloat CTRubyAnnotationGetSizeFactor(CTRubyAnnotationRef rubyAnnotation)
{
  if (rubyAnnotation) {
    return *(double *)(*((void *)rubyAnnotation + 5) + 8);
  }
  else {
    return 0.0;
  }
}

CFStringRef CTRubyAnnotationGetTextForPosition(CTRubyAnnotationRef rubyAnnotation, CTRubyPosition position)
{
  CFStringRef result = 0;
  if (rubyAnnotation)
  {
    if (position <= kCTRubyPositionInline) {
      return *(CFStringRef *)(*((void *)rubyAnnotation + 5) + 8 * position + 16);
    }
  }
  return result;
}

uint64_t TCFBase<TRubyAnnotation>::GetTypeID(void)::{lambda(void *)#1}::__invoke()
{
  TCFBase<TRubyAnnotation>::CreateTypeID();
  uint64_t v0 = TCFBase<TRubyAnnotation>::fTypeID;

  return MEMORY[0x1F40D90C8](v0, "NSCTRubyAnnotation");
}

uint64_t TCFBase<TRubyAnnotation>::CreateTypeID()
{
  {
    TCFBase<TRubyAnnotation>::CreateTypeID(void)::runtimeClass = 0;
    *(void *)algn_1EB2CD6D8 = "CTRubyAnnotation";
    qword_1EB2CD6E0 = 0;
    unk_1EB2CD6E8 = 0;
    qword_1EB2CD6F0 = (uint64_t)TCFBase<TRubyAnnotation>::ClassDestruct;
    qword_1EB2CD6F8 = (uint64_t)TCFBase<TRubyAnnotation>::ClassEqual;
    qword_1EB2CD700 = (uint64_t)TCFBase<TRubyAnnotation>::ClassHash;
    unk_1EB2CD708 = 0;
    qword_1EB2CD710 = (uint64_t)TCFBase<TRubyAnnotation>::ClassDebug;
    unk_1EB2CD718 = 0;
    qword_1EB2CD720 = 0;
    unk_1EB2CD728 = 0;
  }
  uint64_t result = _CFRuntimeRegisterClass();
  TCFBase<TRubyAnnotation>::fCFTypeID TypeID = result;
  return result;
}

void TCFBase<TRubyAnnotation>::ClassDestruct(uint64_t a1)
{
  id v2 = *(void (**)(uint64_t))(a1 + 16);
  if (v2) {
    v2(a1);
  }
  id v3 = *(id **)(a1 + 40);

  TRubyAnnotation::~TRubyAnnotation(v3);
}

uint64_t TCFBase<TRubyAnnotation>::ClassEqual()
{
  return 0;
}

void *TCFBase<TRubyAnnotation>::ClassHash(void *result)
{
  unint64_t v1 = result[3];
  uint64_t v2 = result[4];
  if (v2) {
    BOOL v3 = (result[4] & 1 | v1) == 0;
  }
  else {
    BOOL v3 = 1;
  }
  int v4 = !v3;
  if (v1) {
    BOOL v5 = 0;
  }
  else {
    BOOL v5 = v4 == 0;
  }
  if (!v5)
  {
    uint64_t v6 = (void *)(result[5] + (v2 >> 1));
    if (v2) {
      return (void *)(*(uint64_t (**)(void))(*v6 + v1))();
    }
    else {
      return (void *)((uint64_t (*)(void *))v1)(v6);
    }
  }
  return result;
}

uint64_t TCFBase<TRubyAnnotation>::ClassDebug()
{
  return 0;
}

uint64_t TCFBase<TRubyAnnotation>::Allocate()
{
  if (TCFBase<TRubyAnnotation>::GetTypeID(void)::once != -1) {
    dispatch_once_f(&TCFBase<TRubyAnnotation>::GetTypeID(void)::once, 0, (dispatch_function_t)TCFBase<TRubyAnnotation>::GetTypeID(void)::{lambda(void *)#1}::__invoke);
  }

  return _CFRuntimeCreateInstance();
}

Class _CTFontCollectionEnableBridging(uint64_t a1)
{
  Class result = objc_lookUpClass("NSCTFontCollection");
  if (result)
  {
    return (Class)MEMORY[0x1F40D90C8](a1, "NSCTFontCollection");
  }
  return result;
}

Class _CTGlyphInfoEnableBridging(uint64_t a1)
{
  Class result = objc_lookUpClass("NSCTGlyphInfo");
  if (result)
  {
    return (Class)MEMORY[0x1F40D90C8](a1, "NSCTGlyphInfo");
  }
  return result;
}

const __CFDictionary *TSplicedFontDict::FindLocalizedName(atomic_ullong *this, int a2, const __CFString **a3)
{
  id v17 = (id)0xAAAAAAAAAAAAAAAALL;
  CopyPreferredAndSystemLanguages(&v17);
  CFArrayRef v6 = (const __CFArray *)(id)atomic_load_explicit((atomic_ullong *volatile)&v17, memory_order_acquire);
  if (!v6)
  {

    goto LABEL_10;
  }
  CFArrayRef v7 = v6;
  CFIndex Count = CFArrayGetCount(v6);

  if (!Count)
  {
LABEL_10:
    CFDictionaryRef v15 = 0;
    goto LABEL_11;
  }
  CFArrayRef explicit = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v17, memory_order_acquire);
  if (explicit && (CFIndex v10 = CFArrayGetCount(explicit)) != 0)
  {
    CFIndex v11 = v10;
    CFIndex v12 = 0;
    while (1)
    {
      CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(explicit, v12);
      CFDictionaryRef FontName = TSplicedFontDict::FindFontName(this, a2, ValueAtIndex);
      if (FontName) {
        break;
      }
      if (v11 == ++v12) {
        goto LABEL_8;
      }
    }
    CFDictionaryRef v15 = FontName;
    if (a3) {
      *a3 = ValueAtIndex;
    }
  }
  else
  {
LABEL_8:
    CFDictionaryRef v15 = TSplicedFontDict::FindFontName(this, a2, 0);
  }
LABEL_11:

  return v15;
}

const __CFDictionary *TSplicedFontDict::CopyName@<X0>(atomic_ullong *this@<X0>, const __CFString *key@<X1>, const __CFDictionary **a3@<X8>)
{
  int v5 = FontNameCodeForKey(key);
  CFDictionaryRef result = TSplicedFontDict::FindFontName(this, v5, 0);
  *a3 = result;
  return result;
}

double TSplicedFontDict::GetSlantAngle(atomic_ullong *this, double a2, const CGAffineTransform *a3)
{
  CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit(this, memory_order_acquire);
  if (!explicit) {
    return a2;
  }
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(explicit, @"FontMetrics");
  if (!Value) {
    return a2;
  }
  CFDictionaryRef v6 = Value;
  if (CFDictionaryGetCount(Value) < 1) {
    return a2;
  }
  CFStringRef v7 = (const __CFString *)CFDictionaryGetValue(v6, @"italicAngle");
  if (!v7) {
    return a2;
  }

  return CFStringGetDoubleValue(v7);
}

uint64_t CTFontDescriptorGetDefaultTextStylePlatform()
{
  return 0;
}

__CFString *FindSerifWithTraits(unint64_t a1, char a2, char a3)
{
  unint64_t v5 = a1 - 254;
  if (a1 < 0xFE || v5 > 0xB) {
    return 0;
  }
  unint64_t IndexWithTraits = FindIndexWithTraits((uint64_t)&kOtherSerifSpec, v5, a2, a3);
  if (IndexWithTraits <= 0xB) {
    return kSystemUIFontSerifNames[IndexWithTraits];
  }
  else {
    return 0;
  }
}

__CFString *FindMonospacedWithTraits(unint64_t a1, char a2, char a3)
{
  unint64_t v5 = a1 - 266;
  if (a1 < 0x10A || v5 > 0xB) {
    return 0;
  }
  unint64_t IndexWithTraits = FindIndexWithTraits((uint64_t)&kOtherMonospacedSpec, v5, a2, a3);
  if (IndexWithTraits <= 0xB) {
    return kSystemUIFontMonospacedNames[IndexWithTraits];
  }
  else {
    return 0;
  }
}

TDescriptorSource *TDescriptorSource::CreateVariableSizeTextStyle@<X0>(TDescriptorSource *this@<X0>, CFDictionaryRef theDict@<X1>, TDescriptorSource **a3@<X8>)
{
  if (theDict) {
    CFDictionaryRef Value = (void *)CFDictionaryGetValue(theDict, @"NSFontSizeAttribute");
  }
  else {
    CFDictionaryRef Value = 0;
  }
  [Value doubleValue];
  if (v7 <= 0.0) {
    CFDictionaryRef result = this;
  }
  else {
    CFDictionaryRef result = (TDescriptorSource *)CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@-%@", this, objc_msgSend((id)objc_msgSend(NSNumber, "numberWithDouble:"), "stringValue"));
  }
  *a3 = result;
  return result;
}

__CFString *CTFontDescriptorCopyNameForSystemFontOfWeight(__CFString *a1, double a2, uint64_t a3, uint64_t a4, uint64_t a5, const __CFString **a6)
{
  NameForSystemFontOfWeight = TDescriptorSource::GetNameForSystemFontOfWeight(@"NSCTFontUIFontDesignDefault", a1, a2, 0, 0, a6);

  return NameForSystemFontOfWeight;
}

uint64_t TDescriptorSource::UIFontNameForFullName(uint64_t this, const __CFString *a2)
{
  if (this) {
    return [&unk_1ED07E550 objectForKeyedSubscript:this];
  }
  return this;
}

void CTFontSetAltTextStyleSpec()
{
  kFont2X = &kFont2XCompact;
  _MergedGlobals_82 = 1;
  _MergedGlobals_2 = &kTypeHierarchySpecWatch;
  qword_1EB2CD650 = (uint64_t)kFontSoftCompact;
  off_1EB2CD658[0] = &kFontJapaneseWatch;
  qword_1EB2CD660 = (uint64_t)&kFontKoreanWatch;
  off_1EB2CD668[0] = kFontCompactRounded;
  qword_1EB2CD670 = (uint64_t)kFallbacksCompact;
  gDisableLooseFontNameMatchingOverride = 1;
}

double CTFontGetExuberatedLineHeightForLineHeight(double a1)
{
  if (CurrentLocaleIsExuberated())
  {
    CFStringRef v2 = kFont2X[15];
    double v10 = NAN;
    double v11 = NAN;
    double v8 = NAN;
    double v9 = NAN;
    if (GetLanguageAwareOutsetIndexForFontName(v2, &v11, &v10, &v9, &v8, 0))
    {
      double v3 = (double)*((int *)kFont2X + 6);
      double v4 = (double)-*((_DWORD *)kFont2X + 7);
      double v5 = *((double *)kFont2X + 1);
      double LanguageAwareAdjustRatio = GetLanguageAwareAdjustRatio();
      return (v3 + LanguageAwareAdjustRatio * v10 * v5 + v4 + LanguageAwareAdjustRatio * v8 * v5) / (v3 + v4) * a1;
    }
  }
  return a1;
}

void CreateTrimmedCharacterSetForKey(const __CFCharacterSet *a1@<X0>, const __CFString *a2@<X1>, CFCharacterSetRef *a3@<X8>)
{
  id v15 = (id)0xAAAAAAAAAAAAAAAALL;
  TCFMutableCharacterSet::TCFMutableCharacterSet((TCFMutableCharacterSet *)&v15, a1);
  if (a2 != @"system-ui")
  {
    if (!a2) {
      goto LABEL_23;
    }
    if (!CFEqual(a2, @"system-ui"))
    {
      if (a2 == @"zh" || CFEqual(a2, @"zh"))
      {
        v16.CFIndex location = 8853;
        v16.CFIndex length = 1;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v16);
        v17.CFIndex location = 9792;
        v17.CFIndex length = 1;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v17);
        v18.CFIndex location = 9794;
        v18.CFIndex length = 1;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v18);
        v19.CFIndex location = 12951;
        v19.CFIndex length = 1;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v19);
        v20.CFIndex location = 12953;
        v20.CFIndex length = 1;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v20);
        v21.CFIndex location = 127514;
        v21.CFIndex length = 1;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v21);
        v22.CFIndex location = 127535;
        v22.CFIndex length = 1;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v22);
        v23.CFIndex location = 127538;
        v23.CFIndex length = 9;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v23);
        CFDictionaryRef explicit = (__CFCharacterSet *)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire);
        v8.CFIndex location = 127568;
        v8.CFIndex length = 2;
      }
      else if (a2 == @"ja" || CFEqual(a2, @"ja"))
      {
        v24.CFIndex location = 8252;
        v24.CFIndex length = 1;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v24);
        v25.CFIndex location = 8265;
        v25.CFIndex length = 1;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v25);
        v26.CFIndex location = 9642;
        v26.CFIndex length = 2;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v26);
        v27.CFIndex location = 9728;
        v27.CFIndex length = 4;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v27);
        v28.CFIndex location = 9742;
        v28.CFIndex length = 1;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v28);
        v29.CFIndex location = 9757;
        v29.CFIndex length = 1;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v29);
        v30.CFIndex location = 9792;
        v30.CFIndex length = 1;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v30);
        v31.CFIndex location = 9794;
        v31.CFIndex length = 1;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v31);
        v32.CFIndex location = 9824;
        v32.CFIndex length = 1;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v32);
        v33.CFIndex location = 9827;
        v33.CFIndex length = 1;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v33);
        v34.CFIndex location = 9829;
        v34.CFIndex length = 2;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v34);
        v35.CFIndex location = 9832;
        v35.CFIndex length = 1;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v35);
        v36.CFIndex location = 9851;
        v36.CFIndex length = 1;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v36);
        v37.CFIndex location = 9918;
        v37.CFIndex length = 1;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v37);
        v38.CFIndex location = 9986;
        v38.CFIndex length = 1;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v38);
        v39.CFIndex location = 10145;
        v39.CFIndex length = 1;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v39);
        v40.CFIndex location = 11013;
        v40.CFIndex length = 3;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v40);
        v41.CFIndex location = 12336;
        v41.CFIndex length = 1;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v41);
        v42.CFIndex location = 12349;
        v42.CFIndex length = 1;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v42);
        v43.CFIndex location = 12951;
        v43.CFIndex length = 1;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v43);
        v44.CFIndex location = 12953;
        v44.CFIndex length = 1;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v44);
        v45.CFIndex location = 127490;
        v45.CFIndex length = 1;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v45);
        CFDictionaryRef explicit = (__CFCharacterSet *)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire);
        v8.CFIndex location = 127543;
        v8.CFIndex length = 1;
      }
      else
      {
        if (a2 != @"ko" && !CFEqual(a2, @"ko")) {
          goto LABEL_23;
        }
        v46.CFIndex location = 8252;
        v46.CFIndex length = 1;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v46);
        v47.CFIndex location = 8265;
        v47.CFIndex length = 1;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v47);
        v48.CFIndex location = 8597;
        v48.CFIndex length = 1;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v48);
        v49.CFIndex location = 9723;
        v49.CFIndex length = 2;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v49);
        v50.CFIndex location = 9742;
        v50.CFIndex length = 1;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v50);
        v51.CFIndex location = 9757;
        v51.CFIndex length = 1;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v51);
        v52.CFIndex location = 9775;
        v52.CFIndex length = 1;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v52);
        v53.CFIndex location = 9792;
        v53.CFIndex length = 1;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v53);
        v54.CFIndex location = 9794;
        v54.CFIndex length = 1;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v54);
        v55.CFIndex location = 9824;
        v55.CFIndex length = 1;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v55);
        v56.CFIndex location = 9827;
        v56.CFIndex length = 1;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v56);
        v57.CFIndex location = 9829;
        v57.CFIndex length = 2;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v57);
        v58.CFIndex location = 9832;
        v58.CFIndex length = 1;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v58);
        v59.CFIndex location = 10006;
        v59.CFIndex length = 1;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v59);
        v60.CFIndex location = 10055;
        v60.CFIndex length = 1;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v60);
        v61.CFIndex location = 10145;
        v61.CFIndex length = 1;
        CFCharacterSetRemoveCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), v61);
        CFDictionaryRef explicit = (__CFCharacterSet *)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire);
        v8.CFIndex location = 11013;
        v8.CFIndex length = 3;
      }
      CFCharacterSetRemoveCharactersInRange(explicit, v8);
      goto LABEL_23;
    }
  }
  unsigned int v14 = 0;
  if (GetLocalizedTrimSetKey(0, &v14) && v14)
  {
    if (v14 == 32)
    {
      CFCharacterSetRemoveCharactersInString((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), @"\"'()°‘’“”");
      TrimStringForNumberingSystem = GetTrimStringForNumberingSystem();
      if (TrimStringForNumberingSystem)
      {
        double v5 = TrimStringForNumberingSystem;
        CFDictionaryRef v6 = (__CFCharacterSet *)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire);
        goto LABEL_15;
      }
    }
    else
    {
      if (v14 == 64)
      {
        double v5 = GetTrimStringForNumberingSystem();
        CFDictionaryRef v6 = (__CFCharacterSet *)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire);
LABEL_15:
        CFCharacterSetRemoveCharactersInString(v6, v5);
        goto LABEL_23;
      }
      uint64_t v10 = 0;
      double v11 = &dword_184B94B7C;
      do
      {
        if ((v14 & *(v11 - 1)) != 0)
        {
          if ((0x4FuLL >> v10))
          {
            v12.CFIndex location = *v11;
            id v13 = (__CFCharacterSet *)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire);
            v12.CFIndex length = 1;
          }
          else
          {
            v12.CFIndex location = *v11;
            v12.CFIndex length = v11[1] - v12.location + 1;
            id v13 = (__CFCharacterSet *)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire);
          }
          CFCharacterSetRemoveCharactersInRange(v13, v12);
        }
        ++v10;
        v11 += 3;
      }
      while (v10 != 9);
    }
  }
LABEL_23:
  AddSynthesizedCharactersToCharacterSet((atomic_ullong *)&v15, 0);
  *a3 = CFCharacterSetCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire));
}

__CFString *GetTrimStringForNumberingSystem(void)
{
  id v7 = (id)0xAAAAAAAAAAAAAAAALL;
  CopyPreferredNumberingSystem((uint64_t *)&v7);
  CFStringRef v0 = (const __CFString *)(id)atomic_load_explicit((atomic_ullong *volatile)&v7, memory_order_acquire);
  unint64_t v1 = (__CFString *)v0;
  if (v0 == @"arab" || v0 && CFStringHasPrefix(v0, @"arab")) {
    goto LABEL_9;
  }
  CFStringRef v2 = (__CFString *)(id)atomic_load_explicit((atomic_ullong *volatile)&v7, memory_order_acquire);
  if (v2 == @"deva")
  {

LABEL_9:
    goto LABEL_10;
  }
  double v3 = v2;
  if (!v2)
  {

LABEL_13:
    double v5 = 0;
    goto LABEL_11;
  }
  int v4 = CFEqual(v2, @"deva");

  if (!v4) {
    goto LABEL_13;
  }
LABEL_10:
  double v5 = @":";
LABEL_11:

  return v5;
}

double CTFontGetAccessibilityBoldWeightOfWeight(double a1)
{
  unsigned int v1 = __const__Z19LocalTraitForWeightdd_kWeightTraits[(unsigned __int16)IndexesBracketing<double const*,double>(kCTFontDefaultWeights, (double *)&kCTFontWeightRegular, a1, 0.001)];
  if ((0x1FEFFu >> v1)) {
    unsigned int v1 = dword_184BA17A4[v1];
  }

  return GetWeightForLocalTrait(v1);
}

__CFString *TDescriptorSource::GetUIFontFamilyNameForDesign(CFTypeRef cf2, const __CFString *a2)
{
  uint64_t v3 = 0;
  v7[18] = *MEMORY[0x1E4F143B8];
  int v4 = @".AppleSystemUIFont";
  id v7[2] = @"NSCTFontUIFontDesignCompact";
  v7[3] = @".AppleSystemUIFontCompact";
  v7[4] = @"NSCTFontUIFontDesignCore";
  v7[5] = @".AppleSystemUIFontCore";
  v7[6] = @"NSCTFontUIFontDesignRounded";
  v7[7] = @".AppleSystemUIFontRounded";
  v7[8] = @"NSCTFontUIFontDesignCompactRounded";
  v7[9] = @".AppleSystemUIFontCompactRounded";
  v7[10] = @"NSCTFontUIFontDesignMonospaced";
  v7[11] = @".AppleSystemUIFontMonospaced";
  v7[12] = @"NSCTFontUIFontDesignSerif";
  v7[13] = @".AppleSystemUIFontSerif";
  v7[14] = @"NSCTFontUIFontDesignSoft";
  v7[15] = @".AppleSystemUIFontSoft";
  v7[16] = @"NSCTFontUIFontDesignCompactSoft";
  v7[17] = @".AppleSystemUIFontCompactSoft";
  v7[0] = @"NSCTFontUIFontDesignDefault";
  v7[1] = @".AppleSystemUIFont";
  while (1)
  {
    CFTypeRef v5 = (CFTypeRef)v7[v3];
    if (v5 == cf2 || cf2 && v5 && CFEqual(v5, cf2)) {
      break;
    }
    v3 += 2;
    if (v3 == 18) {
      return v4;
    }
  }
  return (__CFString *)v7[v3 + 1];
}

__CFString *FullNameForSynthetic(__CFString *cf1)
{
  if (cf1 == @".AppleSystemUIFont") {
    return @".AppleSystemUIFontRegular";
  }
  unsigned int v1 = cf1;
  if (cf1)
  {
    if (CFEqual(cf1, @".AppleSystemUIFont")) {
      return @".AppleSystemUIFontRegular";
    }
  }
  return v1;
}

uint64_t GetAltUrduUIFontNameForSymbolicTraits(unsigned int a1)
{
  if (RegisterAltUrduUIFont(void)::onceToken != -1) {
    dispatch_once(&RegisterAltUrduUIFont(void)::onceToken, &__block_literal_global_3062);
  }
  return (uint64_t)*(&kFontUrduDecoNastaleeq + 5 * ((a1 >> 1) & 1));
}

void addComponentsForChinese(atomic_ullong *a1, __CFString **a2, unint64_t a3, const void *a4)
{
  CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableSetRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  uint64_t v10 = *(uint64_t *)((char *)kChineseRegionCodes + (a3 & 0xFFFFFFFFFFFFFFF8));
  if (a2 == &kFontChineseUI)
  {
    id v22 = (id)0xAAAAAAAAAAAAAAAALL;
    CreateSyntheticPingFangOpticalSplicedFont(&v22, (uint64_t)(&kFontChineseUI + 5 * a3));
    id v13 = (id)atomic_load_explicit((atomic_ullong *volatile)&v22, memory_order_acquire);
    CFArrayAppendValue(Mutable, v13);

    id v12 = v22;
  }
  else
  {
    double v11 = CFDictionaryCreateMutable(v8, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFDictionaryAddValue(v11, @"name", a2[5 * a3]);
    CFDictionaryAddValue(v11, @"UnicodeCharSetTrim", @"zh");
    CFDictionaryAddValue(v11, @"languagePropertiesCacheKey", a4);
    CFArrayAppendValue(Mutable, v11);
    id v12 = v11;
  }

  unsigned int v14 = CFDictionaryCreateMutable(v8, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionaryAddValue(v14, @"languagePropertiesCacheKey", @".CJKSymbolsFallback");
  CFDictionaryAddValue(v14, @"name", (const void *)[NSString stringWithFormat:@".CJKSymbolsFallback%@-%@", v10, off_1E528F1D0[a3 & 7]]);
  CFArrayAppendValue(Mutable, v14);
  if (a2 == &kFontChineseUI)
  {
    id v22 = (id)0xAAAAAAAAAAAAAAAALL;
    if (a3 < 8) {
      CFRange v20 = &kFontChineseUI + 5 * a3 + 40;
    }
    else {
      CFRange v20 = &kFontChineseUI + 5 * (a3 & 7);
    }
    CreateSyntheticPingFangOpticalSplicedFont(&v22, (uint64_t)v20);
    id v21 = (id)atomic_load_explicit((atomic_ullong *volatile)&v22, memory_order_acquire);
    CFArrayAppendValue(Mutable, v21);

    id v19 = v22;
  }
  else
  {
    id v15 = CFDictionaryCreateMutable(v8, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFRange v16 = v15;
    if (a3 <= 7) {
      CFRange v17 = @".AppleTraditionalChineseFont";
    }
    else {
      CFRange v17 = @".AppleSimplifiedChineseFont";
    }
    if (a3 <= 7) {
      unint64_t v18 = a3 + 8;
    }
    else {
      unint64_t v18 = a3 & 7;
    }
    CFDictionaryAddValue(v15, @"languagePropertiesCacheKey", v17);
    CFDictionaryAddValue(v16, @"name", a2[5 * v18]);
    CFDictionaryAddValue(v16, @"UnicodeCharSetTrim", @"zh");
    CFArrayAppendValue(Mutable, v16);
    id v19 = v16;
  }

  CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit(a1, memory_order_acquire), @"Components", Mutable);
}

void ___Z20MakeSpliceDescriptorPK10__CFStringmS1_S1_PK10__CFNumberS4_j23CTFontTextStylePlatformjS4_S4_22CTFontLegibilityWeightPK11__CFBooleanPKvS1__block_invoke_2()
{
  MainBundle = CFBundleGetMainBundle();
  CFDictionaryRef InfoDictionary = CFBundleGetInfoDictionary(MainBundle);
  if (InfoDictionary
    && (CFBooleanRef v2 = (const __CFBoolean *)CFDictionaryGetValue(InfoDictionary, @"CTUseSukhumvitSetAsCompactThaiFallback")) != 0
    && CFBooleanGetValue(v2))
  {
    qword_1EB2CD678 = (uint64_t)&kFontThaiSukhumvit;
  }
  else
  {
    uint64_t v3 = (void *)CFPreferencesCopyAppValue(@"CTUseSukhumvitSetAsCompactThaiFallback", (CFStringRef)*MEMORY[0x1E4F1D3D8]);
    CFBooleanRef v4 = v3;
    if (v4)
    {
      CFBooleanRef v5 = v4;
      int Value = CFBooleanGetValue(v4);

      if (Value) {
        qword_1EB2CD678 = (uint64_t)&kFontThaiSukhumvit;
      }
    }
    else
    {
    }
  }
}

void ___Z20MakeSpliceDescriptorPK10__CFStringmS1_S1_PK10__CFNumberS4_j23CTFontTextStylePlatformjS4_S4_22CTFontLegibilityWeightPK11__CFBooleanPKvS1__block_invoke_3()
{
  if (RegisterAltUrduUIFont(void)::onceToken != -1) {
    dispatch_once(&RegisterAltUrduUIFont(void)::onceToken, &__block_literal_global_3062);
  }
  qword_1EB2CD680 = (uint64_t)&kFontUrduDecoNastaleeq;
}

unint64_t CreateSyntheticAppleSymbolsSplicedFont(void)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  unsigned int v1 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  CFBooleanRef v2 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  id Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"name", @".AppleSymbolsFB");
  CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"version", @"1.0");
  uint64_t v3 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
  CFBooleanRef v4 = CFArrayCreateMutable(v0, 0, MEMORY[0x1E4F1D510]);
  unint64_t v18 = @"type";
  id v19 = @"string";
  CFRange v20 = @"1";
  id v21 = @".Apple Symbols Fallback";
  CFArrayAppendValue(v4, (const void *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v20 forKeys:&v18 count:2]);
  unint64_t v18 = @"type";
  id v19 = @"string";
  CFRange v20 = @"16";
  id v21 = @".Apple Symbols Fallback";
  CFArrayAppendValue(v4, (const void *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v20 forKeys:&v18 count:2]);
  unint64_t v18 = @"type";
  id v19 = @"string";
  CFRange v20 = @"4";
  id v21 = @".Apple Symbols Fallback";
  CFArrayAppendValue(v4, (const void *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v20 forKeys:&v18 count:2]);
  unint64_t v18 = @"type";
  id v19 = @"string";
  CFRange v20 = @"18";
  id v21 = @".Apple Symbols Fallback";
  CFArrayAppendValue(v4, (const void *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v20 forKeys:&v18 count:2]);
  unint64_t v18 = @"type";
  id v19 = @"string";
  CFRange v20 = @"2";
  id v21 = @"Regular";
  CFArrayAppendValue(v4, (const void *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v20 forKeys:&v18 count:2]);
  unint64_t v18 = @"type";
  id v19 = @"string";
  CFRange v20 = @"7";
  id v21 = @"Apple Inc.";
  CFArrayAppendValue(v4, (const void *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v20 forKeys:&v18 count:2]);
  CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"familyName", @".Apple Symbols Fallback");
  CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"FontNames", v4);

  CFBooleanRef v5 = CFDictionaryCreateMutable(v0, 0, v1, v2);
  CFDictionaryAddValue(v5, @"weightClass", @"w4");
  CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"FontMetrics", v5);

  CFDictionaryRef v6 = CFArrayCreateMutable(v0, 0, v3);
  id v7 = CFDictionaryCreateMutable(v0, 0, v1, v2);
  CFDictionaryAddValue(v7, @"name", @"AppleSymbols");
  CFAllocatorRef v8 = CFCharacterSetCreateMutable(v0);
  v23.CFIndex location = 8505;
  v23.CFIndex length = 1;
  CFCharacterSetAddCharactersInRange(v8, v23);
  v24.CFIndex location = 8196;
  v24.CFIndex length = 7;
  CFCharacterSetAddCharactersInRange(v8, v24);
  v25.CFIndex location = 8704;
  v25.CFIndex length = 239;
  CFCharacterSetAddCharactersInRange(v8, v25);
  v26.CFIndex location = 8944;
  v26.CFIndex length = 16;
  CFCharacterSetAddCharactersInRange(v8, v26);
  v27.CFIndex location = 9744;
  v27.CFIndex length = 3;
  CFCharacterSetAddCharactersInRange(v8, v27);
  v28.CFIndex location = 10176;
  v28.CFIndex length = 5;
  CFCharacterSetAddCharactersInRange(v8, v28);
  v29.CFIndex location = 10183;
  v29.CFIndex length = 4;
  CFCharacterSetAddCharactersInRange(v8, v29);
  v30.CFIndex location = 10192;
  v30.CFIndex length = 28;
  CFCharacterSetAddCharactersInRange(v8, v30);
  v31.CFIndex location = 10240;
  v31.CFIndex length = 256;
  CFCharacterSetAddCharactersInRange(v8, v31);
  v32.CFIndex location = 10624;
  v32.CFIndex length = 144;
  CFCharacterSetAddCharactersInRange(v8, v32);
  v33.CFIndex location = 10769;
  v33.CFIndex length = 1;
  CFCharacterSetAddCharactersInRange(v8, v33);
  v34.CFIndex location = 10774;
  v34.CFIndex length = 234;
  CFCharacterSetAddCharactersInRange(v8, v34);
  v35.CFIndex location = 127760;
  v35.CFIndex length = 1;
  CFCharacterSetAddCharactersInRange(v8, v35);
  v36.CFIndex location = 127908;
  v36.CFIndex length = 1;
  CFCharacterSetAddCharactersInRange(v8, v36);
  CFCharacterSetRef Copy = CFCharacterSetCreateCopy(v0, v8);
  CFDictionaryAddValue(v7, @"UnicodeCharSet", Copy);

  CFArrayAppendValue(v6, v7);
  uint64_t v10 = CFDictionaryCreateMutable(v0, 0, v1, v2);
  CFDictionaryAddValue(v10, @"name", @"ZapfDingbatsITC");
  double v11 = CFCharacterSetCreateMutable(v0);
  v37.CFIndex location = 9985;
  v37.CFIndex length = 4;
  CFCharacterSetAddCharactersInRange(v11, v37);
  v38.CFIndex location = 9996;
  v38.CFIndex length = 28;
  CFCharacterSetAddCharactersInRange(v11, v38);
  v39.CFIndex location = 10025;
  v39.CFIndex length = 35;
  CFCharacterSetAddCharactersInRange(v11, v39);
  v40.CFIndex location = 10061;
  v40.CFIndex length = 1;
  CFCharacterSetAddCharactersInRange(v11, v40);
  v41.CFIndex location = 10063;
  v41.CFIndex length = 4;
  CFCharacterSetAddCharactersInRange(v11, v41);
  v42.CFIndex location = 10070;
  v42.CFIndex length = 1;
  CFCharacterSetAddCharactersInRange(v11, v42);
  v43.CFIndex location = 10072;
  v43.CFIndex length = 7;
  CFCharacterSetAddCharactersInRange(v11, v43);
  v44.CFIndex location = 10081;
  v44.CFIndex length = 52;
  CFCharacterSetAddCharactersInRange(v11, v44);
  v45.CFIndex location = 10136;
  v45.CFIndex length = 24;
  CFCharacterSetAddCharactersInRange(v11, v45);
  v46.CFIndex location = 10161;
  v46.CFIndex length = 14;
  CFCharacterSetAddCharactersInRange(v11, v46);
  CFCharacterSetRef v12 = CFCharacterSetCreateCopy(v0, v11);
  CFDictionaryAddValue(v10, @"UnicodeCharSet", v12);

  CFArrayAppendValue(v6, v10);
  id v13 = CFDictionaryCreateMutable(v0, 0, v1, v2);
  CFDictionaryAddValue(v13, @"name", @"Symbol");
  v47.CFIndex location = 63743;
  v47.CFIndex length = 1;
  CFCharacterSetRef v14 = CFCharacterSetCreateWithCharactersInRange(v0, v47);
  CFDictionaryAddValue(v13, @"UnicodeCharSet", v14);
  CFArrayAppendValue(v6, v13);

  CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"Components", v6);
  unint64_t v15 = atomic_exchange((atomic_ullong *volatile)&Mutable, 0);

  return v15;
}

unint64_t CreateSyntheticAppleTimesSplicedFont(uint64_t a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  id Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"name", kTimesFBNames[a1]);
  CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"version", @"1.0");
  uint64_t v3 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
  CFBooleanRef v4 = CFArrayCreateMutable(v2, 0, MEMORY[0x1E4F1D510]);
  unint64_t v18 = @"type";
  id v19 = @"string";
  CFRange v20 = @"1";
  id v21 = @".Times Fallback";
  CFArrayAppendValue(v4, (const void *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v20 forKeys:&v18 count:2]);
  unint64_t v18 = @"type";
  id v19 = @"string";
  CFRange v20 = @"16";
  id v21 = @".Times Fallback";
  CFArrayAppendValue(v4, (const void *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v20 forKeys:&v18 count:2]);
  CFBooleanRef v5 = &kTimesFBSpliceFontInfo[2 * a1];
  CFDictionaryRef v6 = v5[1];
  uint64_t v7 = [@".Times Fallback" stringByAppendingFormat:@" %@", v6];
  unint64_t v18 = @"type";
  id v19 = @"string";
  CFRange v20 = @"4";
  id v21 = (__CFString *)v7;
  CFArrayAppendValue(v4, (const void *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v20 forKeys:&v18 count:2]);
  unint64_t v18 = @"type";
  id v19 = @"string";
  CFRange v20 = @"18";
  id v21 = @".Times Fallback";
  CFArrayAppendValue(v4, (const void *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v20 forKeys:&v18 count:2]);
  unint64_t v18 = @"type";
  id v19 = @"string";
  CFRange v20 = @"2";
  id v21 = v6;
  CFArrayAppendValue(v4, (const void *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v20 forKeys:&v18 count:2]);
  unint64_t v18 = @"type";
  id v19 = @"string";
  CFRange v20 = @"7";
  id v21 = @"Apple Inc.";
  CFArrayAppendValue(v4, (const void *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v20 forKeys:&v18 count:2]);
  CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"familyName", @".Times Fallback");
  CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"FontNames", v4);

  CFAllocatorRef v8 = CFArrayCreateMutable(v2, 0, v3);
  double v9 = CFDictionaryCreateMutable(v2, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFStringRef v10 = *v5;
  CFDictionaryAddValue(v9, @"name", *v5);
  CFCharacterSetRef CharacterSetForFont = CreateCharacterSetForFont(v10);
  if (CharacterSetForFont)
  {
    CFCharacterSetRef v12 = CharacterSetForFont;
    id MutableCopy = CFCharacterSetCreateMutableCopy(v2, CharacterSetForFont);
    v23.CFIndex location = 1536;
    v23.CFIndex length = 256;
    CFCharacterSetRemoveCharactersInRange(MutableCopy, v23);
    v24.CFIndex location = 1872;
    v24.CFIndex length = 48;
    CFCharacterSetRemoveCharactersInRange(MutableCopy, v24);
    v25.CFIndex location = 8204;
    v25.CFIndex length = 2;
    CFCharacterSetRemoveCharactersInRange(MutableCopy, v25);
    v26.CFIndex location = 64336;
    v26.CFIndex length = 688;
    CFCharacterSetRemoveCharactersInRange(MutableCopy, v26);
    v27.CFIndex location = 65136;
    v27.CFIndex length = 144;
    CFCharacterSetRemoveCharactersInRange(MutableCopy, v27);
    CFCharacterSetRef Copy = CFCharacterSetCreateCopy(v2, MutableCopy);
    CFDictionaryAddValue(v9, @"UnicodeCharSet", Copy);

    CFArrayAppendValue(v8, v9);
    CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"Components", v8);

    unint64_t v15 = atomic_exchange((atomic_ullong *volatile)&Mutable, 0);
  }
  else
  {

    unint64_t v15 = 0;
  }

  return v15;
}

void GetLocalizedTrimCharacterSet(const __CFString *a1, __CFString *a2)
{
  id v17 = (id)0xAAAAAAAAAAAAAAAALL;
  LanguageNormalizedForPresetFallbacks(a2, (atomic_ullong *)&v17);
  if (a2)
  {
    memset(v16, 170, sizeof(v16));
    CreateLocalizedTrimCharacterSet((unint64_t *)v16, (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&v17, memory_order_acquire), &v16[2], &v16[1]);
    CFBooleanRef v4 = (void *)atomic_exchange(v16, 0);
    CFDictionaryRef v6 = (char *)v16[1];
    uint64_t v5 = v16[2];
    a1->isa = v4;
    a1->info = v5;
    uint64_t v7 = atomic_exchange((atomic_ullong *volatile)&v17, 0);
    a1->data = v6;
    a1->CFIndex length = v7;
    CFAllocatorRef v8 = (void *)v16[0];
  }
  else
  {
    int v9 = dword_1EB2CDB38;
    if (v9 != GetLocaleChangedCount())
    {
      v16[2] = 0xAAAAAAAAAAAAAAAALL;
      CreateLocalizedTrimCharacterSet((unint64_t *)&v16[2], (__CFString *)atomic_load_explicit((atomic_ullong *volatile)&v17, memory_order_acquire), &qword_1EB2CDBE8, &qword_1EB2CDBF0);
      unint64_t v10 = atomic_exchange(&v16[2], 0);
      double v11 = (void *)qword_1EB2CDBE0;
      qword_1EB2CDBE0 = v10;

      dword_1EB2CDB38 = GetLocaleChangedCount();
    }
    v16[2] = (atomic_ullong)(id)qword_1EB2CDBE0;
    CFCharacterSetRef v12 = (void *)atomic_exchange(&v16[2], 0);
    uint64_t v13 = qword_1EB2CDBE8;
    CFCharacterSetRef v14 = (char *)qword_1EB2CDBF0;
    a1->isa = v12;
    a1->info = v13;
    uint64_t v15 = atomic_exchange((atomic_ullong *volatile)&v17, 0);
    a1->data = v14;
    a1->CFIndex length = v15;
    CFAllocatorRef v8 = (void *)v16[2];
  }
}

BOOL HasPingFangUIPrefix(CFStringRef theString)
{
  if (qword_1EB2CDBD8 != -1) {
    dispatch_once(&qword_1EB2CDBD8, &__block_literal_global_3552);
  }
  if ((__CFString **)qword_1EB2CD688 == &kFontChineseUI) {
    CFStringRef v2 = @".PingFangUI";
  }
  else {
    CFStringRef v2 = @".PingFang";
  }
  return CFStringHasPrefix(theString, v2) != 0;
}

__CFString *RegionCodeFromPingFangUI(__CFString *a1)
{
  if (!HasPingFangUIPrefix(a1)) {
    return &stru_1ED0677F8;
  }
  uint64_t v2 = [(__CFString *)a1 rangeOfString:@"-"];
  if (!v3) {
    return &stru_1ED0677F8;
  }

  return (__CFString *)-[__CFString substringWithRange:](a1, "substringWithRange:", v2 - 2, 2);
}

id *std::tuple<TCFRef<__CFCharacterSet const*>,anonymous namespace'::TFontInfo const*,unsigned long,TCFRef<__CFString const*>>::~tuple(id *a1)
{
  return a1;
}

uint64_t FindIndexWithTraits(uint64_t a1, uint64_t a2, char a3, char a4)
{
  uint64_t result = 0;
  CFDictionaryRef v6 = (int *)(a1 + 16 * a2);
  int v7 = *v6;
  if (a4) {
    int v8 = a3 & 1;
  }
  else {
    int v8 = v6[1];
  }
  if (v7 >= 4) {
    int v9 = 4;
  }
  else {
    int v9 = v7;
  }
  if (v7 <= 6) {
    int v10 = 6;
  }
  else {
    int v10 = v7;
  }
  if ((a3 & 2) != 0) {
    int v9 = v10;
  }
  if ((a4 & 2) == 0) {
    int v9 = v7;
  }
  for (CFIndex i = (_DWORD *)(a1 + 4); *(i - 1) != v9 || *i != v8; i += 4)
  {
    if (++result == 12) {
      return -1;
    }
  }
  return result;
}

void TCFMutableCharacterSet::TCFMutableCharacterSet(TCFMutableCharacterSet *this, const __CFCharacterSet *a2)
{
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (a2) {
    CFMutableCharacterSetRef MutableCopy = CFCharacterSetCreateMutableCopy(v3, a2);
  }
  else {
    CFMutableCharacterSetRef MutableCopy = CFCharacterSetCreateMutable(v3);
  }
  *(void *)this = MutableCopy;
}

void ___ZL21RegisterAltUrduUIFontv_block_invoke()
{
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t AppleInternalFontsPath = GetAppleInternalFontsPath();
  uint64_t v2 = (__CFString *)CFStringCreateWithFormat(v0, 0, @"%@DecoTypeNastaleeqUrdu.ttc", AppleInternalFontsPath);
  CFURLRef v3 = CFURLCreateWithFileSystemPath(v0, v2, kCFURLPOSIXPathStyle, 0);
  CFURLRef v4 = v3;
  if (v3) {
    _CTFontManagerRegisterActionFontsForURL(v3, 1, 1, 0);
  }
}

uint64_t ___ZL20FontInfoForChineseUIv_block_invoke()
{
  uint64_t result = _os_feature_enabled_impl();
  if (!result
    || (uint64_t result = dyld_program_sdk_at_least(), (result & 1) == 0)
    && ((uint64_t result = _CFAppVersionCheckLessThan(), result)
     || (uint64_t result = _CFAppVersionCheckLessThan(), result)))
  {
    qword_1EB2CD688 = (uint64_t)&kFontChineseUIOld;
  }
  return result;
}

void CreateSyntheticPingFangOpticalSplicedFont(void *a1, uint64_t a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  id Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"name", *(const void **)a2);
  CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"version", @"1.0");
  CFIndex Length = CFStringGetLength(*(CFStringRef *)a2);
  CFIndex location = CFStringFind((CFStringRef)*(void *)a2, @"-", 0).location;
  id v20 = (id)0xAAAAAAAAAAAAAAAALL;
  TCFMutableString::TCFMutableString((TCFMutableString *)&v20, *(CFStringRef *)a2);
  v27.CFIndex length = CFStringGetLength((CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire))
             - location;
  v27.CFIndex location = location;
  CFStringReplace((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire), v27, &stru_1ED0677F8);
  v29.CFIndex length = CFStringGetLength((CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire));
  v29.CFIndex location = 0;
  CFStringFindAndReplace((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire), @"UIOptical", @" UI Optical ", v29, 0);
  CFDictionaryRef v6 = CFArrayCreateMutable(v3, 0, MEMORY[0x1E4F1D510]);
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire);
  id v22 = @"type";
  CFRange v23 = @"string";
  id v24 = @"1";
  CFRange v25 = (__CFString *)explicit;
  CFArrayAppendValue(v6, (const void *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v24 forKeys:&v22 count:2]);
  unint64_t v8 = atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire);
  id v22 = @"type";
  CFRange v23 = @"string";
  id v24 = @"16";
  CFRange v25 = (__CFString *)v8;
  CFArrayAppendValue(v6, (const void *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v24 forKeys:&v22 count:2]);
  v28.CFIndex location = location + 1;
  v28.CFIndex length = Length - (location + 1);
  int v9 = (__CFString *)CFStringCreateWithSubstring(v3, *(CFStringRef *)a2, v28);
  int v10 = (__CFString *)CFStringCreateWithFormat(v3, 0, @"%@ %@", atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire), v9);
  id v22 = @"type";
  CFRange v23 = @"string";
  id v24 = @"4";
  CFRange v25 = v10;
  CFArrayAppendValue(v6, (const void *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v24 forKeys:&v22 count:2]);
  id v22 = @"type";
  CFRange v23 = @"string";
  id v24 = @"18";
  CFRange v25 = v10;
  CFArrayAppendValue(v6, (const void *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v24 forKeys:&v22 count:2]);
  id v22 = @"type";
  CFRange v23 = @"string";
  id v24 = @"2";
  CFRange v25 = v9;
  CFArrayAppendValue(v6, (const void *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v24 forKeys:&v22 count:2]);
  id v22 = @"type";
  CFRange v23 = @"string";
  id v24 = @"7";
  CFRange v25 = @"Apple Inc.";
  CFArrayAppendValue(v6, (const void *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v24 forKeys:&v22 count:2]);
  CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"familyName", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire));
  CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"FontNames", v6);

  double v11 = CFDictionaryCreateMutable(v3, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFCharacterSetRef v12 = (__CFString *)CFStringCreateWithFormat(v3, 0, @"W%d", *(unsigned int *)(a2 + 16));
  CFDictionaryAddValue(v11, @"weightClass", v12);
  CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"FontMetrics", v11);

  id v24 = CFArrayCreateMutable(v3, 0, MEMORY[0x1E4F1D510]);
  id v22 = (id)0xAAAAAAAAAAAAAAAALL;
  TCFMutableString::TCFMutableString((TCFMutableString *)&v22, *(CFStringRef *)a2);
  v30.CFIndex length = CFStringGetLength((CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&v22, memory_order_acquire));
  v30.CFIndex location = 0;
  CFStringFindAndReplace((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&v22, memory_order_acquire), @"Optical", @"Text", v30, 0);
  id v19 = (id)0xAAAAAAAAAAAAAAAALL;
  TCFMutableString::TCFMutableString((TCFMutableString *)&v19, (CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire));
  v31.CFIndex length = CFStringGetLength((CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&v19, memory_order_acquire));
  v31.CFIndex location = 0;
  CFStringFindAndReplace((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&v19, memory_order_acquire), @"Optical", @"Text", v31, 0);
  insertOpticalSizeComponent((const __CFString **)a2, (const __CFString *)atomic_load_explicit((atomic_ullong *volatile)&v22, memory_order_acquire), 0xFFFFFFFFLL, 0, 0, (atomic_ullong *)&v24, @"zh", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v19, memory_order_acquire), 0.0);
  CFStringRef ValueAtIndex = (__CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v24, memory_order_acquire), 0);
  CFDictionaryAddValue(ValueAtIndex, @"languagePropertiesCacheKey", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire));
  id v18 = (id)0xAAAAAAAAAAAAAAAALL;
  TCFMutableString::TCFMutableString((TCFMutableString *)&v18, *(CFStringRef *)a2);
  v32.CFIndex length = CFStringGetLength((CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&v18, memory_order_acquire));
  v32.CFIndex location = 0;
  CFStringFindAndReplace((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&v18, memory_order_acquire), @"Optical", @"Display", v32, 0);
  id v17 = (id)0xAAAAAAAAAAAAAAAALL;
  TCFMutableString::TCFMutableString((TCFMutableString *)&v17, (CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire));
  v33.CFIndex length = CFStringGetLength((CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&v17, memory_order_acquire));
  v33.CFIndex location = 0;
  CFStringFindAndReplace((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&v17, memory_order_acquire), @"Optical", @"Display", v33, 0);
  insertOpticalSizeComponent((const __CFString **)a2, (const __CFString *)atomic_load_explicit((atomic_ullong *volatile)&v18, memory_order_acquire), 0xFFFFFFFFLL, 0, 0, (atomic_ullong *)&v24, @"zh", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v17, memory_order_acquire), 20.0);
  CFCharacterSetRef v14 = (__CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v24, memory_order_acquire), 0);
  CFDictionaryAddValue(v14, @"languagePropertiesCacheKey", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire));
  CFDictionaryAddValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"Components", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v24, memory_order_acquire));

  uint64_t v15 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
  CFDictionaryAddValue(v15, @"hasVariations", (const void *)*MEMORY[0x1E4F1CFD0]);
  *a1 = atomic_exchange((atomic_ullong *volatile)&Mutable, 0);
}

void TCFMutableString::TCFMutableString(TCFMutableString *this, CFStringRef theString)
{
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (theString) {
    CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(v3, 0, theString);
  }
  else {
    CFMutableStringRef MutableCopy = CFStringCreateMutable(v3, 0);
  }
  *(void *)this = MutableCopy;
}

void CreateLocalizedTrimCharacterSet(unint64_t *a1, __CFString *cf1, void *a3, void *a4)
{
  unsigned int v16 = 0;
  unint64_t SFTrimCharacterSetForChineseOrJapanese = 0;
  if (!GetLocalizedTrimSetKeyForNormalizedLanguage(cf1, &v16)) {
    goto LABEL_31;
  }
  unsigned int v8 = v16;
  if ((int)v16 <= 15)
  {
    if (v16 - 1 < 2 || v16 == 4 || v16 == 8)
    {
      unint64_t SFTrimCharacterSetForChineseOrJapanese = CreateSFTrimCharacterSetForChineseOrJapanese(kFont2X[15], v16);
      *a4 = 8;
      if (qword_1EB2CDBD8 != -1) {
        dispatch_once(&qword_1EB2CDBD8, &__block_literal_global_3552);
      }
      uint64_t v11 = qword_1EB2CD688;
      if (v8 == 4)
      {
        uint64_t v11 = qword_1EB2CD688 + 640;
      }
      else if (v8 == 2)
      {
        uint64_t v11 = qword_1EB2CD688 + 320;
      }
      else if (v8 != 1)
      {
        uint64_t v11 = qword_1EB2CD688 + 960;
      }
      *a3 = v11;
    }
    goto LABEL_31;
  }
  switch(v16)
  {
    case 0x40u:
      id Mutable = CFCharacterSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
      TrimStringForNumberingSystem = GetTrimStringForNumberingSystem();
      if (TrimStringForNumberingSystem) {
        CFCharacterSetAddCharactersInString((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), TrimStringForNumberingSystem);
      }
      unint64_t SFTrimCharacterSetForChineseOrJapanese = atomic_exchange((atomic_ullong *volatile)&Mutable, 0);
      _CFCharacterSetCompact();
      uint64_t v13 = &kFontHindi;
      goto LABEL_30;
    case 0x20u:
      id Mutable = CFCharacterSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
      CFCharacterSetAddCharactersInString((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), @"\"'()°‘’“”");
      CFCharacterSetRef v14 = GetTrimStringForNumberingSystem();
      if (v14) {
        CFCharacterSetAddCharactersInString((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), v14);
      }
      unint64_t SFTrimCharacterSetForChineseOrJapanese = atomic_exchange((atomic_ullong *volatile)&Mutable, 0);
      _CFCharacterSetCompact();
      uint64_t v13 = &kFontSFArabic;
LABEL_30:
      *a3 = v13;
      *a4 = 9;

      break;
    case 0x10u:
      unint64_t SFTrimCharacterSetForChineseOrJapanese = CreateSFTrimCharacterSetForChineseOrJapanese(kFont2X[15], 16);
      *a3 = off_1EB2CD658[0];
      *a4 = 9;
      break;
  }
LABEL_31:
  *a1 = SFTrimCharacterSetForChineseOrJapanese;
}

unint64_t CreateSFTrimCharacterSetForChineseOrJapanese(const __CFString *a1, int a2)
{
  uint64_t v4 = 0;
  id Mutable = CFCharacterSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
  uint64_t v5 = &dword_184B94B7C;
  do
  {
    if ((*(v5 - 1) & a2) != 0)
    {
      if ((0x4FuLL >> v4))
      {
        v6.CFIndex location = *v5;
        unint64_t explicit = (__CFCharacterSet *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
        v6.CFIndex length = 1;
      }
      else
      {
        v6.CFIndex location = *v5;
        v6.CFIndex length = v5[1] - v6.location + 1;
        unint64_t explicit = (__CFCharacterSet *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      }
      CFCharacterSetAddCharactersInRange(explicit, v6);
    }
    ++v4;
    v5 += 3;
  }
  while (v4 != 9);
  CFCharacterSetRef CharacterSetForFont = CreateCharacterSetForFont(a1);
  if (CharacterSetForFont)
  {
    CFCharacterSetRef v9 = CharacterSetForFont;
    CFCharacterSetIntersect((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), CharacterSetForFont);
    CFRelease(v9);
  }
  unint64_t v10 = atomic_exchange((atomic_ullong *volatile)&Mutable, 0);
  _CFCharacterSetCompact();

  return v10;
}

uint64_t TJustEngine::ApplyTrackingToRun(TJustEngine *this, TLine *a2, const TCharStream *a3, uint64_t a4, double a5)
{
  CFRange v6 = a3;
  uint64_t v102 = *MEMORY[0x1E4F143B8];
  int v96 = unk_184BA188C;
  long long v98 = unk_184BA18A0;
  memset(&v88[8], 170, 24);
  *(void *)v88 = 0;
  long long v87 = 0u;
  int64x2_t v86 = 0u;
  v89 = &v88[8];
  BYTE8(v98) = 0;
  uint64_t v93 = 0;
  long long v90 = 0u;
  long long v91 = 0u;
  long long v92 = 0u;
  memset(v95, 0, sizeof(v95));
  LOBYTE(v98) = 0;
  uint64_t v101 = 0;
  uint64_t v99 = 0;
  uint64_t v100 = 0;
  long long v97 = 0uLL;
  unint64_t v94 = 0xFFEFFFFFFFFFFFFFLL;
  (*(void (**)(id *__return_ptr))(*(void *)(*((void *)this + 2) + 8 * (void)a3) + 56))(&v76);
  v82[0] = (id)atomic_exchange((atomic_ullong *volatile)&v76, 0);
  TLine::AppendRun(&v86, (atomic_ullong *)v82);

  long long v90 = *(_OWORD *)((char *)this + 72);
  if (*((void *)&v87 + 1) - (void)v87 == 8 && (uint64_t v10 = *(void *)&v95[8], *(uint64_t *)&v95[8] >= 1))
  {
    memset(v84, 170, sizeof(v84));
    v82[0] = 0;
    v82[1] = 0;
    BOOL v83 = 0;
    long long v85 = v84;
    if (*(void *)&v95[8] > 0xAAAAAAAAAAAAAAAuLL) {
LABEL_54:
    }
      abort();
    v78[1] = v84;
    uint64_t v11 = TInlineBufferAllocator<std::pair<double,CFRange>,30ul>::allocate((uint64_t)v84, *(unint64_t *)&v95[8]);
    CFCharacterSetRef v12 = (char *)v82[1];
    uint64_t v13 = (char *)v82[0];
    uint64_t v57 = a4;
    CFRange v58 = this;
    if (v82[1] == v82[0])
    {
      int64x2_t v16 = vdupq_n_s64((unint64_t)v82[1]);
      CFCharacterSetRef v14 = v11;
    }
    else
    {
      CFCharacterSetRef v14 = v11;
      do
      {
        long long v15 = *(_OWORD *)(v12 - 24);
        *((void *)v14 - 1) = *((void *)v12 - 1);
        *(_OWORD *)(v14 - 24) = v15;
        v14 -= 24;
        v12 -= 24;
      }
      while (v12 != v13);
      int64x2_t v16 = *(int64x2_t *)v82;
    }
    v82[0] = v14;
    v82[1] = v11;
    int64x2_t v77 = v16;
    id v18 = v83;
    BOOL v83 = &v11[24 * v10];
    v78[0] = v18;
    id v76 = (id)v16.i64[0];
    std::__split_buffer<std::pair<double,CFRange>,TInlineBufferAllocator<std::pair<double,CFRange>,30ul> &>::~__split_buffer((uint64_t)&v76);
    CFRange v59 = v6;
    CFRange v62 = a2;
    while (1)
    {
      uint64_t v19 = *(void *)(*(void *)v87 + 48);
      uint64_t v20 = objc_msgSend(*(id *)(v19 + 216), "copyWithRange:", *(void *)(v19 + 200), *(void *)(v19 + 208));

      *(void *)(v19 + 216) = v20;
      *(void *)(v19 + 200) = 0;
      int64_t v21 = *(void *)(v19 + 208);
      if (v21 < 0) {
        break;
      }
      char v61 = 0;
      CFIndex v22 = 0;
      uint64_t v63 = v19;
      uint64_t v64 = 0;
      int64_t v23 = 0;
      CFRange v60 = (TStorageRange *)(v19 + 192);
      int v24 = **(unsigned char **)(v20 + 40) & 1;
      do
      {
        if (v23 >= v21
          || (v24 & 1) != (*(_DWORD *)(*(void *)(*(void *)(v19 + 216) + 40)
                                     + 4 * *(void *)(v19 + 200)
                                     + 4 * v23) & 1))
        {
          int v66 = v24;
          v103.CFIndex length = v23 - v22;
          v103.CFIndex location = v22;
          double Width = TStorageRange::GetWidth(v60, v103);
          uint64_t v65 = v23 - v22;
          uint64_t v26 = 0;
          if (v23 <= v22)
          {
            uint64_t v28 = v22;
          }
          else
          {
            uint64_t v67 = v64 - v57;
            CFIndex v27 = v22;
            uint64_t v28 = v22;
            do
            {
              v77.i64[0] = 0xAAAAAAAAAAAAAAAALL;
              id v76 = (id)0xAAAAAAAAAAAAAAAALL;
              TLine::GetClusterRange(v58, v62, (uint64_t)v6, v57, *(void *)(*(void *)(*(void *)(v63 + 216) + 48) + 8 * *(void *)(v63 + 200) + 8 * v27), 2, &v76, 0, 0);
              CFRange v29 = (char *)v76 + v67 + v77.i64[0];
              v26 += (v22 < (uint64_t)v29) & (v23 >= (uint64_t)v29);
              if ((uint64_t)v29 <= v27 + 1) {
                ++v27;
              }
              else {
                CFIndex v27 = (CFIndex)v76 + v67 + v77.i64[0];
              }
            }
            while (v27 < v23);
          }
          *(void *)&long long v30 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v30 + 1) = 0xAAAAAAAAAAAAAAAALL;
          v80[13] = v30;
          v80[14] = v30;
          v80[11] = v30;
          v80[12] = v30;
          v80[9] = v30;
          v80[10] = v30;
          v80[7] = v30;
          v80[8] = v30;
          v80[5] = v30;
          v80[6] = v30;
          v80[3] = v30;
          v80[4] = v30;
          v80[1] = v30;
          v80[2] = v30;
          v80[0] = v30;
          memset(v79, 0, sizeof(v79));
          BOOL v81 = v80;
          v69[0] = 0.0;
          v69[1] = 0.0;
          CFRange v31 = (char *)v82[1];
          unint64_t v32 = 0xAAAAAAAAAAAAAAABLL * (((char *)v82[1] - (char *)v82[0]) >> 3);
          long long v33 = v87;
          BOOL v34 = v23 >= v32;
          unint64_t v35 = v23 - v32;
          if (v23 <= v32)
          {
            CFRange v6 = v59;
            a2 = v62;
            if (!v34) {
              v82[1] = (char *)v82[0] + 24 * v23;
            }
          }
          else if (0xAAAAAAAAAAAAAAABLL * ((v83 - (char *)v82[1]) >> 3) >= v35)
          {
            size_t v47 = 24 * ((24 * v35 - 24) / 0x18) + 24;
            bzero(v82[1], v47);
            v82[1] = &v31[v47];
            CFRange v6 = v59;
            a2 = v62;
          }
          else
          {
            if ((unint64_t)v23 > 0xAAAAAAAAAAAAAAALL) {
              goto LABEL_54;
            }
            unint64_t v36 = 0x5555555555555556 * ((v83 - (char *)v82[0]) >> 3);
            if (v36 <= v23) {
              unint64_t v36 = v23;
            }
            if (0xAAAAAAAAAAAAAAABLL * ((v83 - (char *)v82[0]) >> 3) >= 0x555555555555555) {
              unint64_t v37 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              unint64_t v37 = v36;
            }
            v78[1] = v84;
            CFRange v38 = TInlineBufferAllocator<std::pair<double,CFRange>,30ul>::allocate((uint64_t)v84, v37);
            CFRange v39 = &v38[24 * v32];
            size_t v40 = 24 * ((24 * v35 - 24) / 0x18) + 24;
            bzero(v39, v40);
            CFRange v41 = (char *)v82[1];
            CFRange v42 = (char *)v82[0];
            if (v82[1] == v82[0])
            {
              int64x2_t v46 = vdupq_n_s64((unint64_t)v82[1]);
              CFRange v43 = &v38[24 * v32];
              CFRange v44 = v59;
              a2 = v62;
            }
            else
            {
              CFRange v43 = &v38[24 * v32];
              CFRange v44 = v59;
              a2 = v62;
              do
              {
                long long v45 = *(_OWORD *)(v41 - 24);
                *((void *)v43 - 1) = *((void *)v41 - 1);
                *(_OWORD *)(v43 - 24) = v45;
                v43 -= 24;
                v41 -= 24;
              }
              while (v41 != v42);
              int64x2_t v46 = *(int64x2_t *)v82;
            }
            v82[0] = v43;
            v82[1] = &v39[v40];
            int64x2_t v77 = v46;
            CFRange v48 = v83;
            BOOL v83 = &v38[24 * v37];
            v78[0] = v48;
            id v76 = (id)v46.i64[0];
            std::__split_buffer<std::pair<double,CFRange>,TInlineBufferAllocator<std::pair<double,CFRange>,30ul> &>::~__split_buffer((uint64_t)&v76);
            CFRange v6 = v44;
          }
          double v49 = Width + a5 * (double)v26 - Width;
          memset(v78, 170, 0x2D0uLL);
          id v76 = 0;
          int64x2_t v77 = 0uLL;
          v78[90] = v78;
          uint64_t v50 = v65;
          TJustEngine::GenerateMaximaList((TLine *)&v86, a2, v28, v65, 1, 0, (uint64_t *)v82, (uint64_t *)&v76, v49);
          std::vector<double,TInlineBufferAllocator<double,30ul>>::resize((uint64_t)v79, v23);
          TJustEngine::DistributeGap(v33, *((uint64_t *)&v33 + 1), v28, v65, 1, 0, (uint64_t)v82[0], v79[0], v49, v69);
          if (v76 == (id)v77.i64[0])
          {
            uint64_t v19 = v63;
            int v53 = v66;
          }
          else
          {
            uint64_t v68 = 0xAAAAAAAAAAAAAAAALL;
            *(void *)&long long v51 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v51 + 1) = 0xAAAAAAAAAAAAAAAALL;
            v74[28] = v51;
            v74[29] = v51;
            v74[26] = v51;
            v74[27] = v51;
            v74[24] = v51;
            v74[25] = v51;
            v74[22] = v51;
            v74[23] = v51;
            v74[20] = v51;
            v74[21] = v51;
            v74[18] = v51;
            v74[19] = v51;
            v74[16] = v51;
            v74[17] = v51;
            v74[14] = v51;
            v74[15] = v51;
            v74[12] = v51;
            v74[13] = v51;
            v74[10] = v51;
            v74[11] = v51;
            v74[8] = v51;
            v74[9] = v51;
            v74[6] = v51;
            v74[7] = v51;
            v74[4] = v51;
            v74[5] = v51;
            v74[2] = v51;
            v74[3] = v51;
            v74[0] = v51;
            v74[1] = v51;
            id v71 = 0;
            id v72 = 0;
            uint64_t v73 = 0;
            long long v75 = v74;
            char v52 = TPostcompEngine::DoActions(v33, *((uint64_t *)&v33 + 1), v28, v65, (uint64_t)&v76, v79[0], (unint64_t *)&v68, (char **)&v71);
            uint64_t v19 = v63;
            int v53 = v66;
            if (v68 >= 1)
            {
              *(void *)&v95[8] += v68;
              uint64_t v50 = v68 + v65;
              v64 += v68;
              v23 += v68;
            }
            if (v71 != v72)
            {
              CFIndex v54 = TAATPostcompEngine::ApplyKashidas(v33, *((uint64_t *)&v33 + 1), (uint64_t **)&v71, v79[0]);
              uint64_t v68 = v54;
              if (v54 >= 1)
              {
                *(void *)&v95[8] += v54;
                v50 += v54;
                v64 += v54;
                v23 += v54;
                ApplyArabicLowConnections<std::__wrap_iter<CTRun **>>(v33, *((uint64_t *)&v33 + 1));
              }
            }
            v61 |= v52;
            uint64_t v70 = &v71;
            std::vector<CGPoint,TInlineBufferAllocator<CGPoint,30ul>>::__destroy_vector::operator()[abi:nn180100](&v70);
          }
          id v71 = &v76;
          std::vector<std::tuple<long,std::unique_ptr<std::vector<unsigned short>>,TCFRef<__CFData const*>>,TInlineBufferAllocator<std::tuple<long,std::unique_ptr<std::vector<unsigned short>>,TCFRef<__CFData const*>>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v71);
          CFIndex v22 = v50 + v28;
          int v24 = v53 ^ 1;
          id v76 = v79;
          std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v76);
          int64_t v21 = *(void *)(v19 + 208);
        }
      }
      while (v23++ < v21);
      if ((v61 & 1) == 0) {
        break;
      }
      TLine::ResetLine((TLine *)&v86, a2);
    }
    id v71 = *(id *)v87;
    id v76 = (id)atomic_exchange((atomic_ullong *volatile)&v71, 0);
    TLine::ReplaceRun(v58, (uint64_t)v6, (atomic_ullong *)&v76);

    id v76 = v82;
    std::vector<JustLeftRightMaxima,TInlineBufferAllocator<JustLeftRightMaxima,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v76);
    uint64_t v17 = 1;
  }
  else
  {
    uint64_t v17 = 0;
  }
  TLine::~TLine((TLine *)&v86);
  return v17;
}

void ApplyArabicLowConnections<std::__wrap_iter<CTRun **>>(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](a1, a2);
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  if (v2 != v3)
  {
    uint64_t v4 = v3;
    uint64_t v5 = v2;
    unint64_t v6 = (unint64_t)&v26 + 4;
    do
    {
      uint64_t v7 = *(void *)(*(void *)v5 + 48);
      if (*(_DWORD *)(v7 + 304) == 2)
      {
        uint64_t v8 = *(void *)(atomic_load_explicit((atomic_ullong *volatile)(v7 + 56), memory_order_acquire) + 40);
        CFDataRef CommonTable = (const __CFData *)TBaseFont::GetCommonTable(*(TBaseFont **)(v8 + 400), 1196643650, 0);
        if (CommonTable)
        {
          unint64_t v23 = 0xAAAAAAAAAAAAAAAALL;
          *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
          v22[3] = v10;
          v22[4] = v10;
          v22[1] = v10;
          v22[2] = v10;
          v22[0] = v10;
          memset(&v34[8], 0, 48);
          uint64_t v33 = 0;
          CFRange v31 = 0;
          uint64_t v32 = 0;
          v34[0] = 0;
          OTL::GCommon::GCommon((uint64_t)v22, 0, (unsigned char *)v8, CommonTable, (uint64_t)&v31, 1634885986, 0);
          *(void *)&v22[0] = &unk_1ED05FB20;
          unint64_t v40 = 0xAAAAAAAAAAAAAAAALL;
          *(void *)&long long v11 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
          v39[5] = v11;
          v39[6] = v11;
          v39[3] = v11;
          v39[4] = v11;
          v39[1] = v11;
          v39[2] = v11;
          v39[0] = v11;
          unint64_t v36 = 0;
          unint64_t v37 = 0;
          uint64_t v38 = 0;
          CFRange v41 = v39;
          LODWORD(v26) = 1280268099;
          OTL::FeatureBuffer::FeatureBuffer<unsigned int const*>((char **)&v31, &v26, (_DWORD *)&v26 + 1);
          BOOL SingleSubstLookups = OTL::GSUB::GetSingleSubstLookups(v22, (uint64_t)&v31, (uint64_t)&v36);
          __dst[0] = (void **)&v31;
          std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](__dst);
          if (SingleSubstLookups)
          {
            unint64_t v13 = *(void *)(v7 + 208);
            memset(v34, 170, sizeof(v34));
            CFRange v31 = 0;
            uint64_t v32 = 0;
            uint64_t v33 = 0;
            unint64_t v35 = v34;
            CFCharacterSetRef v14 = v36;
            long long v15 = v37;
            while (v14 != v15)
            {
              unsigned int v16 = *v14++;
              unint64_t v6 = v6 & 0xFFFFFFFF00000000 | v16;
              OTL::GlyphLookups::SetLookupInRange<false>((uint64_t *)&v31, v6, 0, v13);
            }
            uint64_t v17 = *(void *)(v7 + 216);
            *(void *)&long long v18 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
            v29[28] = v18;
            v29[29] = v18;
            v29[26] = v18;
            v29[27] = v18;
            v29[24] = v18;
            v29[25] = v18;
            v29[22] = v18;
            v29[23] = v18;
            v29[20] = v18;
            v29[21] = v18;
            v29[18] = v18;
            v29[19] = v18;
            v29[16] = v18;
            v29[17] = v18;
            v29[14] = v18;
            v29[15] = v18;
            v29[12] = v18;
            v29[13] = v18;
            v29[10] = v18;
            v29[11] = v18;
            _OWORD v29[8] = v18;
            v29[9] = v18;
            v29[6] = v18;
            v29[7] = v18;
            v29[4] = v18;
            v29[5] = v18;
            v29[2] = v18;
            v29[3] = v18;
            v29[0] = v18;
            v29[1] = v18;
            CFIndex v27 = 0;
            uint64_t v26 = 0;
            uint64_t v28 = 0;
            long long v30 = v29;
            if (v13)
            {
              std::vector<CGPoint,TInlineBufferAllocator<CGPoint,30ul>>::__vallocate[abi:nn180100]((char **)&v26, v13);
              uint64_t v19 = (char *)v27;
              bzero(v27, 16 * v13);
              CFIndex v27 = &v19[16 * v13];
            }
            memcpy(__dst, &unk_184BA1910, sizeof(__dst));
            unint64_t explicit = (const __CTFont *)atomic_load_explicit((atomic_ullong *volatile)(v7 + 56), memory_order_acquire);
            TRunGlue::TRunGlue((TRunGlue *)__dst, explicit, *(unsigned __int16 **)(v17 + 16), v26, v13, 0, 0, 0);
            LOBYTE(v24) = 0;
            if (*(unsigned char *)(v7 + 224)) {
              int v21 = -1;
            }
            else {
              int v21 = 1;
            }
            OTL::GSUB::ApplyLookups(v22, (TRunGlue *)__dst, v21, (unsigned __int16 **)&v31, &v24, 0, 0);
            std::__function::__value_func<BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::~__value_func[abi:nn180100](&__dst[70]);
            int v24 = &__dst[46];
            std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v24);
            int v24 = &__dst[26];
            std::vector<unsigned char,TInlineBufferAllocator<unsigned char,128ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v24);
            int v24 = &__dst[7];
            std::vector<std::pair<UScriptCode,long>,TInlineBufferAllocator<std::pair<UScriptCode,long>,1ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v24);
            __dst[0] = (void **)&v26;
            std::vector<CGPoint,TInlineBufferAllocator<CGPoint,30ul>>::__destroy_vector::operator()[abi:nn180100](__dst);
            __dst[0] = (void **)&v31;
            std::vector<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,TInlineBufferAllocator<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,30ul>>::__destroy_vector::operator()[abi:nn180100](__dst);
            unint64_t v6 = (unint64_t)&v26 + 4;
          }
          CFRange v31 = &v36;
          std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v31);
        }
      }
      v5 += 8;
    }
    while (v5 != v4);
  }
}

uint64_t TJustEngine::ZeroRange(uint64_t this, TLine *a2, CFRange a3)
{
  uint64_t v3 = this;
  uint64_t v4 = *(void *)(this + 16);
  uint64_t v5 = *(void *)(this + 24);
  if (v4 == v5)
  {
    CFCharacterSetRef v9 = 0;
    uint64_t v7 = *(void *)(this + 16);
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v7 = *(void *)(this + 16);
    while (1)
    {
      uint64_t v8 = *(void *)(*(void *)(*(void *)v7 + 40) + 208) + v6;
      if (v8 > (uint64_t)a2) {
        break;
      }
      v7 += 8;
      uint64_t v6 = v8;
      if (v7 == v5)
      {
        CFCharacterSetRef v9 = 0;
        uint64_t v7 = *(void *)(this + 24);
        goto LABEL_8;
      }
    }
    CFCharacterSetRef v9 = (char *)a2 - v6;
  }
LABEL_8:
  uint64_t v10 = (v7 - v4) >> 3;
  if (v10 < (v5 - v4) >> 3 && a3.location >= 1)
  {
    CFCharacterSetRef v12 = *(void **)(*(void *)(v4 + 8 * v10) + 48);
    unint64_t v13 = (TStorageRange *)(v12 + 24);
    CFCharacterSetRef v14 = (char *)v12[26];
    CFIndex v15 = a3.location + 1;
    unsigned int v16 = (CGSize *)MEMORY[0x1E4F1DB30];
    while (v9 != v14)
    {
      if (!v9) {
        goto LABEL_17;
      }
LABEL_19:
      this = TStorageRange::SetAdvance(v13, (uint64_t)v9++, *v16);
      if (--v15 <= 1) {
        return this;
      }
    }
    ++v10;
    uint64_t v17 = *(void *)(v3 + 16);
    if (v10 >= (*(void *)(v3 + 24) - v17) >> 3) {
      return this;
    }
    CFCharacterSetRef v12 = *(void **)(*(void *)(v17 + 8 * v10) + 48);
    unint64_t v13 = (TStorageRange *)(v12 + 24);
    CFCharacterSetRef v14 = (char *)v12[26];
LABEL_17:
    long long v18 = (CGSize *)v12[39];
    CFCharacterSetRef v9 = 0;
    if (v18) {
      *long long v18 = *v16;
    }
    goto LABEL_19;
  }
  return this;
}

uint64_t TJustEngineImplementation::HasPostcompensation(TJustEngineImplementation *this)
{
  return 0;
}

void std::__destroy_at[abi:nn180100]<std::tuple<long,std::unique_ptr<std::vector<unsigned short>>,TCFRef<__CFData const*>>,0>(uint64_t a1)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = (void *)(a1 + 8);
  uint64_t v2 = v4;
  *uint64_t v3 = 0;
  if (v4)
  {
    std::default_delete<std::vector<unsigned short>>::operator()[abi:nn180100]((uint64_t)v3, v2);
  }
}

void std::default_delete<std::vector<unsigned short>>::operator()[abi:nn180100](uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(void **)a2;
    if (*(void *)a2)
    {
      *(void *)(a2 + 8) = v2;
      operator delete(v2);
    }
    JUMPOUT(0x1853275C0);
  }
}

uint64_t *std::vector<std::tuple<long,std::unique_ptr<std::vector<unsigned short>>,TCFRef<__CFData const*>>,TInlineBufferAllocator<std::tuple<long,std::unique_ptr<std::vector<unsigned short>>,TCFRef<__CFData const*>>,30ul>>::__swap_out_circular_buffer(uint64_t *result, void *a2)
{
  uint64_t v3 = *result;
  uint64_t v2 = result[1];
  uint64_t v4 = a2[1];
  while (v2 != v3)
  {
    uint64_t v5 = *(void *)(v2 - 24);
    v2 -= 24;
    *(void *)(v4 - 24) = v5;
    v4 -= 24;
    uint64_t v6 = *(void *)(v2 + 8);
    *(void *)(v2 + 8) = 0;
    *(void *)(v4 + 8) = v6;
    *(void *)(v4 + 16) = atomic_exchange((atomic_ullong *volatile)(v2 + 16), 0);
  }
  a2[1] = v4;
  uint64_t v7 = *result;
  *uint64_t result = v4;
  a2[1] = v7;
  uint64_t v8 = result[1];
  result[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = result[2];
  result[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<std::tuple<long,std::unique_ptr<std::vector<unsigned short>>,TCFRef<__CFData const*>>,TInlineBufferAllocator<std::tuple<long,std::unique_ptr<std::vector<unsigned short>>,TCFRef<__CFData const*>>,30ul> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 24;
    std::__destroy_at[abi:nn180100]<std::tuple<long,std::unique_ptr<std::vector<unsigned short>>,TCFRef<__CFData const*>>,0>(i - 24);
  }
  uint64_t v4 = *(void **)a1;
  if (*(void *)a1)
  {
    unint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = (void *)(v5 + 720);
    if (v5 <= (unint64_t)v4 && v6 > v4)
    {
      if (*(void *)(a1 + 24) == *v6) {
        *uint64_t v6 = v4;
      }
    }
    else
    {
      operator delete(v4);
    }
  }
  return a1;
}

void TAATJustEngine::PostcompTable(atomic_ullong *this@<X0>, void *a2@<X8>)
{
  id v3 = (id)objc_msgSend((id)atomic_load_explicit(this + 2, memory_order_acquire), "subdataWithRange:", this[6]- (void)CFDataGetBytePtr((CFDataRef)atomic_load_explicit(this + 2, memory_order_acquire)), this[4] - this[6]);
  *a2 = atomic_exchange((atomic_ullong *volatile)&v3, 0);
}

void std::vector<unsigned short>::resize(uint64_t a1, unint64_t a2, _WORD *a3)
{
  unint64_t v3 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 1;
  if (a2 <= v3)
  {
    if (a2 < v3) {
      *(void *)(a1 + 8) = *(void *)a1 + 2 * a2;
    }
  }
  else
  {
    std::vector<unsigned short>::__append((void **)a1, a2 - v3, a3);
  }
}

BOOL TAATJustEngine::HasPostcompensation(TAATJustEngine *this)
{
  return *((void *)this + 6) != 0;
}

void std::vector<unsigned short>::__append(void **a1, unint64_t a2, _WORD *a3)
{
  uint64_t v8 = a1[2];
  uint64_t v6 = (uint64_t)(a1 + 2);
  uint64_t v7 = v8;
  uint64_t v9 = *(_WORD **)(v6 - 8);
  if (a2 <= (v8 - (unsigned char *)v9) >> 1)
  {
    if (a2)
    {
      uint64_t v16 = 2 * a2;
      uint64_t v17 = &v9[a2];
      do
      {
        *v9++ = *a3;
        v16 -= 2;
      }
      while (v16);
      uint64_t v9 = v17;
    }
    a1[1] = v9;
  }
  else
  {
    uint64_t v10 = (char *)v9 - (unsigned char *)*a1;
    uint64_t v11 = a2 + (v10 >> 1);
    if (v11 < 0) {
      abort();
    }
    uint64_t v12 = v10 >> 1;
    unint64_t v13 = v7 - (unsigned char *)*a1;
    if (v13 > v11) {
      uint64_t v11 = v13;
    }
    if (v13 >= 0x7FFFFFFFFFFFFFFELL) {
      uint64_t v14 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v14 = v11;
    }
    if (v14) {
      CFIndex v15 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned short>>(v6, v14);
    }
    else {
      CFIndex v15 = 0;
    }
    long long v18 = &v15[2 * v12];
    uint64_t v19 = &v18[2 * a2];
    uint64_t v20 = 2 * a2;
    int v21 = v18;
    do
    {
      *(_WORD *)int v21 = *a3;
      v21 += 2;
      v20 -= 2;
    }
    while (v20);
    CFIndex v22 = &v15[2 * v14];
    unint64_t v23 = (char *)*a1;
    for (uint64_t i = (char *)a1[1]; i != v23; i -= 2)
    {
      __int16 v25 = *((_WORD *)i - 1);
      *((_WORD *)v18 - 1) = v25;
      v18 -= 2;
    }
    *a1 = v18;
    a1[1] = v19;
    a1[2] = v22;
    if (v23)
    {
      operator delete(v23);
    }
  }
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned short>>(uint64_t a1, uint64_t a2)
{
  if (a2 < 0) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(2 * a2);
}

void TGenericJustEngine::~TGenericJustEngine(TGenericJustEngine *this)
{
}

uint64_t TPostcompEngine::DoActions(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unint64_t *a7, char **a8)
{
  v61[129] = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *(void **)a5;
  long long v45 = *(void **)(a5 + 8);
  if (*(void **)a5 == v45) {
    return 0;
  }
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  uint64_t v14 = (uint64_t)(a8 + 3);
  while (1)
  {
    uint64_t v15 = *v8 - v12;
    if (*v8 > v12)
    {
      uint64_t v16 = (uint64_t *)(a1 + 8 * v12);
      do
      {
        uint64_t v17 = *v16++;
        uint64_t v18 = *(void *)(*(void *)(v17 + 40) + 208);
        a3 -= v18;
        v13 += v18;
        a6 += 8 * v18;
        --v15;
      }
      while (v15);
      uint64_t v12 = *v8;
    }
    uint64_t v50 = v8;
    uint64_t v19 = *(void *)(*(void *)(a1 + 8 * v12) + 48);
    uint64_t v20 = *(void *)(v19 + 208);
    uint64_t v21 = v20 >= a3 + a4 ? a3 + a4 : *(void *)(v19 + 208);
    uint64_t v49 = v12;
    if (a3 > 0 || a3 + a4 < 1)
    {
      uint64_t v22 = 0;
      uint64_t v23 = 0;
      if ((a3 & 0x8000000000000000) == 0 && a3 < v20)
      {
        uint64_t v23 = v21 - a3;
        uint64_t v22 = a3;
      }
    }
    else
    {
      uint64_t v22 = 0;
      uint64_t v23 = v21;
    }
    memset(v61, 170, 0x3E8uLL);
    memset(v60, 0, sizeof(v60));
    v61[60] = v61;
    LOWORD(v61[61]) = -1;
    memset(&v61[62], 0, 24);
    v61[125] = &v61[65];
    v61[126] = v19;
    v61[127] = v22;
    v61[128] = v23;
    *(void *)&long long v24 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v24 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v58[28] = v24;
    v58[29] = v24;
    v58[26] = v24;
    v58[27] = v24;
    v58[24] = v24;
    v58[25] = v24;
    v58[22] = v24;
    v58[23] = v24;
    v58[20] = v24;
    v58[21] = v24;
    v58[18] = v24;
    v58[19] = v24;
    v58[16] = v24;
    v58[17] = v24;
    v58[14] = v24;
    v58[15] = v24;
    v58[12] = v24;
    v58[13] = v24;
    v58[10] = v24;
    v58[11] = v24;
    v58[8] = v24;
    v58[9] = v24;
    v58[6] = v24;
    v58[7] = v24;
    v58[4] = v24;
    v58[5] = v24;
    v58[2] = v24;
    void v58[3] = v24;
    v58[0] = v24;
    v58[1] = v24;
    CFRange v55 = 0;
    CFRange v56 = 0;
    uint64_t v57 = 0;
    CFRange v59 = v58;
    CFDataRef explicit = (const __CFData *)atomic_load_explicit(v50 + 2, memory_order_acquire);
    if (explicit)
    {
      BytePtr = (SFNTLookupTable *)CFDataGetBytePtr(explicit);
      CFIndex v27 = CFDataGetBytePtr(explicit);
      if (v27)
      {
        uint64_t v28 = (SFNTLookupTable *)&v27[CFDataGetLength(explicit)];
        goto LABEL_21;
      }
    }
    else
    {
      BytePtr = 0;
    }
    uint64_t v28 = 0;
LABEL_21:
    if (TAATPostcompEngine::DoActions(v60, (void *)v50[1], BytePtr, v28, a6, a7, (void **)&v55)) {
      break;
    }
    CFRange v29 = v55;
    long long v30 = v56;
    if (v55 != v56)
    {
      CFRange v31 = a8[1];
      do
      {
        *v29 += v13;
        unint64_t v32 = (unint64_t)a8[2];
        if ((unint64_t)v31 >= v32)
        {
          uint64_t v33 = (v31 - *a8) >> 4;
          if ((unint64_t)(v33 + 1) >> 60) {
            abort();
          }
          uint64_t v34 = v32 - (void)*a8;
          uint64_t v35 = v34 >> 3;
          if (v34 >> 3 <= (unint64_t)(v33 + 1)) {
            uint64_t v35 = v33 + 1;
          }
          if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v36 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v36 = v35;
          }
          uint64_t v54 = v14;
          if (v36) {
            unint64_t v37 = TInlineBufferAllocator<CGPoint,30ul>::allocate(v14, v36);
          }
          else {
            unint64_t v37 = 0;
          }
          uint64_t v38 = &v37[16 * v33];
          *(_OWORD *)uint64_t v38 = *(_OWORD *)v29;
          CFRange v39 = *a8;
          unint64_t v40 = (unint64_t)a8[1];
          if ((char *)v40 == *a8)
          {
            int64x2_t v42 = vdupq_n_s64(v40);
            CFRange v41 = &v37[16 * v33];
          }
          else
          {
            CFRange v41 = &v37[16 * v33];
            do
            {
              *((_OWORD *)v41 - 1) = *(_OWORD *)(v40 - 16);
              v41 -= 16;
              v40 -= 16;
            }
            while ((char *)v40 != v39);
            int64x2_t v42 = *(int64x2_t *)a8;
          }
          CFRange v31 = v38 + 16;
          *a8 = v41;
          a8[1] = v38 + 16;
          int64x2_t v52 = v42;
          CFRange v43 = a8[2];
          a8[2] = &v37[16 * v36];
          int v53 = v43;
          long long v51 = (void **)v42.i64[0];
          std::__split_buffer<std::tuple<unsigned short,unsigned short,long>,TInlineBufferAllocator<std::tuple<unsigned short,unsigned short,long>,30ul> &>::~__split_buffer((uint64_t)&v51);
        }
        else
        {
          *(_OWORD *)CFRange v31 = *(_OWORD *)v29;
          v31 += 16;
        }
        a8[1] = v31;
        v29 += 2;
      }
      while (v29 != v30);
    }
    long long v51 = (void **)&v55;
    std::vector<CGPoint,TInlineBufferAllocator<CGPoint,30ul>>::__destroy_vector::operator()[abi:nn180100](&v51);
    CFRange v55 = &v61[62];
    std::vector<CGPoint,TInlineBufferAllocator<CGPoint,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v55);
    std::vector<TGlyphAuxDataListEntry,TInlineBufferAllocator<TGlyphAuxDataListEntry,30ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)v60);
    uint64_t v8 = v50 + 3;
    uint64_t v12 = v49;
    if (v50 + 3 == v45) {
      return 0;
    }
  }
  long long v51 = (void **)&v55;
  std::vector<CGPoint,TInlineBufferAllocator<CGPoint,30ul>>::__destroy_vector::operator()[abi:nn180100](&v51);
  CFRange v55 = &v61[62];
  std::vector<CGPoint,TInlineBufferAllocator<CGPoint,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v55);
  std::vector<TGlyphAuxDataListEntry,TInlineBufferAllocator<TGlyphAuxDataListEntry,30ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)v60);
  return 1;
}

uint64_t TAATPostcompEngine::DoActions(unint64_t **a1, void *a2, SFNTLookupTable *a3, SFNTLookupTable *a4, uint64_t a5, unint64_t *a6, void **a7)
{
  *a6 = 0;
  if (!a3) {
    return 0;
  }
  uint64_t v11 = a1;
  uint64_t v12 = a1[129];
  uint64_t v13 = *(void *)(v12[27] + 16);
  unint64_t v14 = v12[25];
  *(void *)&long long v15 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v181 = v15;
  long long v182 = 0xAAAAAAAAAAAAAAAALL;
  v179 = TAATLookupTable::BadTable;
  uint64_t v180 = 0;
  unint64_t v183 = 0xAAAAAAAAAAAAFFFFLL;
  TAATLookupTable::SetTable((uint64_t)&v179, a3, a4);
  uint64_t v16 = (uint64_t)v11[131];
  v178 = v11;
  if (v16 < 1)
  {
LABEL_127:
    uint64_t v108 = 0;
    goto LABEL_128;
  }
  v175 = (TStorageRange *)(v13 + 2 * v14);
  uint64_t v176 = a5;
  unint64_t v17 = (unint64_t)v11[130];
  v173 = a3;
  int64_t v174 = v16 + v17;
  uint64_t v171 = (uint64_t)(v11 + 68);
  v172 = (int64x2_t *)(v11 + 65);
  unint64_t v167 = (unint64_t)(v11 + 3);
  v170 = (unint64_t *)(v11 + 63);
  while (1)
  {
    uint64_t v18 = *((unsigned __int16 *)v175 + v17);
    *(double *)&uint64_t v185 = -3.72066208e-103;
    uint64_t v19 = v179;
    uint64_t v20 = (TAATLookupTable *)((char *)&v179 + (v180 >> 1));
    if (v180) {
      uint64_t v19 = *(uint64_t (**)(TAATLookupTable *, unsigned __int16, unint64_t *))(*(void *)v20
    }
                                                                                              + v179);
    uint64_t v21 = (unsigned __int16 *)v19(v20, v18, (unint64_t *)&v185);
    if (v21)
    {
      if (v21 < (unsigned __int16 *)v173 || v21 + 1 > (unsigned __int16 *)a4) {
        goto LABEL_127;
      }
      unsigned int v23 = bswap32(*v21) >> 16;
      if ((unsigned __int16)(v23 + 1) >= 2u)
      {
        long long v24 = (unsigned int *)((char *)&v173->format + v23);
        __int16 v25 = (unsigned __int16 *)(v24 + 1);
        if (v24 + 1 > (unsigned int *)a4) {
          goto LABEL_127;
        }
        if (*v24) {
          break;
        }
      }
    }
LABEL_126:
    if ((uint64_t)++v17 >= v174) {
      goto LABEL_127;
    }
  }
  unsigned int v26 = bswap32(*v24);
  while (2)
  {
    CFIndex v27 = (unsigned int *)(v25 + 4);
    if (v25 + 2 < (unsigned __int16 *)v24 || v27 > (unsigned int *)a4) {
      goto LABEL_126;
    }
    if (v17 >= (uint64_t)(a2[1] - *a2) >> 1) {
      int v29 = 0;
    }
    else {
      int v29 = *(unsigned __int16 *)(*a2 + 2 * v17);
    }
    unsigned int v30 = *((_DWORD *)v25 + 1);
    if (v29 != bswap32(*v25) >> 16) {
      goto LABEL_125;
    }
    double v31 = *(double *)(a5 + 8 * v17);
    switch(bswap32(v25[1]) >> 16)
    {
      case 0u:
        uint64_t v32 = (uint64_t)v11[129];
        uint64_t v33 = *(void *)(*(void *)(*(void *)(v32 + 216) + 48) + 8 * *(void *)(v32 + 200) + 8 * v17);
        *(double *)&uint64_t v185 = COERCE_DOUBLE(TRun::GetGlyphIndexForCharIndex<false>(v32, v33));
        uint64_t v34 = (TRun *)v32;
        a5 = v176;
        uint64_t v35 = TRun::GetNextChar(v34, v33, &v185) - v33;
        uint64_t v11 = v178;
        if (v35 < 2) {
          goto LABEL_125;
        }
        unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)v178[129] + 7, memory_order_acquire);
        if (v25 + 11 > (unsigned __int16 *)a4) {
          goto LABEL_125;
        }
        double v37 = *(double *)(*(void *)(explicit + 40) + 16);
        if (v37 * (float)((float)(int)bswap32(*v27) * 0.000015259) <= v31
          && v37 * (float)((float)(int)bswap32(*((_DWORD *)v25 + 3)) * 0.000015259) >= v31)
        {
          goto LABEL_125;
        }
        unsigned int v38 = bswap32(v25[8]) >> 16;
        unsigned int v39 = *((unsigned __int16 *)v178 + 256);
        if (v38 > v39) {
          goto LABEL_125;
        }
        if (v38 < v39) {
          *((_WORD *)v178 + 256) = v38;
        }
        CFRange v41 = v178[1];
        unint64_t v40 = (unint64_t)v178[2];
        if ((unint64_t)v41 >= v40)
        {
          uint64_t v95 = ((char *)v41 - (char *)*v178) >> 4;
          unint64_t v96 = v95 + 1;
          if ((unint64_t)(v95 + 1) >> 60) {
            goto LABEL_207;
          }
          uint64_t v97 = v40 - (void)*v178;
          if (v97 >> 3 > v96) {
            unint64_t v96 = v97 >> 3;
          }
          if ((unint64_t)v97 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v98 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v98 = v96;
          }
          uint64_t v99 = (char *)*v170;
          unint64_t v100 = *v170 + 16 * v98;
          if (v100 <= (unint64_t)v170)
          {
            unint64_t *v170 = v100;
          }
          else
          {
            if (v98 >> 60) {
              std::__throw_bad_array_new_length[abi:nn180100]();
            }
            uint64_t v99 = (char *)operator new(16 * v98);
          }
          uint64_t v102 = (unint64_t *)&v99[16 * v95];
          *uint64_t v102 = v17;
          v102[1] = (unint64_t)v27;
          uint64_t v11 = v178;
          unint64_t v104 = (char *)*v178;
          CFRange v103 = (char *)v178[1];
          v105 = v102;
          if (v103 != (char *)*v178)
          {
            do
            {
              *((_OWORD *)v105 - 1) = *((_OWORD *)v103 - 1);
              v105 -= 2;
              v103 -= 16;
            }
            while (v103 != v104);
            CFRange v103 = (char *)*v178;
          }
          int64x2_t v42 = v102 + 2;
          *v178 = v105;
          v178[1] = v102 + 2;
          v106 = (char *)v178[2];
          v178[2] = (unint64_t *)&v99[16 * v98];
          if (v103)
          {
            BOOL v107 = v167 <= (unint64_t)v103 && v170 > (unint64_t *)v103;
            a5 = v176;
            if (v107)
            {
              if (v106 == (char *)*v170) {
                unint64_t *v170 = (unint64_t)v103;
              }
            }
            else
            {
              operator delete(v103);
            }
          }
          else
          {
            a5 = v176;
          }
        }
        else
        {
          *CFRange v41 = v17;
          v41[1] = (unint64_t)v27;
          int64x2_t v42 = v41 + 2;
        }
        v11[1] = v42;
        goto LABEL_125;
      case 1u:
        if (v31 <= 0.0 || v25 + 5 > (unsigned __int16 *)a4) {
          goto LABEL_125;
        }
        unsigned int v44 = bswap32(*(unsigned __int16 *)v27) >> 16;
        unint64_t v45 = (unint64_t)v11[66];
        unint64_t v46 = (unint64_t)v11[67];
        if (v45 < v46)
        {
          *(void *)unint64_t v45 = v17;
          *(_WORD *)(v45 + 8) = v44;
          size_t v47 = (char *)(v45 + 16);
          *(_DWORD *)(v45 + 12) = 1;
          goto LABEL_97;
        }
        uint64_t v61 = (uint64_t)(v45 - v172->i64[0]) >> 4;
        unint64_t v62 = v61 + 1;
        if ((unint64_t)(v61 + 1) >> 60) {
          goto LABEL_207;
        }
        uint64_t v63 = v46 - v172->i64[0];
        if (v63 >> 3 > v62) {
          unint64_t v62 = v63 >> 3;
        }
        if ((unint64_t)v63 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v64 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v64 = v62;
        }
        uint64_t v188 = v171;
        uint64_t v65 = TInlineBufferAllocator<CGPoint,30ul>::allocate(v171, v64);
        int v66 = &v65[16 * v61];
        *(void *)int v66 = v17;
        *((_WORD *)v66 + 4) = v44;
        *((_DWORD *)v66 + 3) = 1;
        uint64_t v11 = v178;
        unint64_t v67 = (unint64_t)v178[66];
        uint64_t v68 = (char *)v178[65];
        if ((char *)v67 == v68) {
          goto LABEL_95;
        }
        long long v69 = v66;
        do
        {
          *((_OWORD *)v69 - 1) = *(_OWORD *)(v67 - 16);
          v69 -= 16;
          v67 -= 16;
        }
        while ((char *)v67 != v68);
        goto LABEL_94;
      case 2u:
        if (v31 <= 0.0 || v25 + 8 > (unsigned __int16 *)a4) {
          goto LABEL_125;
        }
        unsigned int v49 = v25[6];
        unsigned int v50 = v25[7];
        double v51 = *(double *)(*(void *)(atomic_load_explicit((atomic_ullong *volatile)v11[129] + 7, memory_order_acquire)
                                    + 40)
                        + 16)
            * (float)((float)(int)bswap32(*((_DWORD *)v25 + 2)) * 0.000015259);
        if (v51 > v31)
        {
          a5 = v176;
          if (v49 != 0xFFFF) {
            goto LABEL_70;
          }
LABEL_125:
          __int16 v25 = (unsigned __int16 *)((char *)v25 + bswap32(v30));
          if (!--v26) {
            goto LABEL_126;
          }
          continue;
        }
        int64x2_t v52 = v11[129];
        [(id)v52[27] setGlyph:__rev16(v50) atIndex:v52[25] + v17];
        if (v50 == 0xFFFF && (*((unsigned char *)v52 + 225) & 2) != 0) {
          *((unsigned char *)v52 + 225) |= 8u;
        }
        a5 = v176;
        uint64_t v11 = v178;
        if (v49 == 0xFFFF) {
          goto LABEL_184;
        }
LABEL_70:
        __int16 v70 = __rev16(v49);
        unint64_t v71 = (unint64_t)v11[66];
        unint64_t v72 = (unint64_t)v11[67];
        if (v71 >= v72)
        {
          uint64_t v74 = (uint64_t)(v71 - v172->i64[0]) >> 4;
          unint64_t v75 = v74 + 1;
          if ((unint64_t)(v74 + 1) >> 60) {
            goto LABEL_207;
          }
          uint64_t v76 = v72 - v172->i64[0];
          if (v76 >> 3 > v75) {
            unint64_t v75 = v76 >> 3;
          }
          if ((unint64_t)v76 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v77 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v77 = v75;
          }
          uint64_t v188 = v171;
          BOOL v78 = TInlineBufferAllocator<CGPoint,30ul>::allocate(v171, v77);
          int v79 = &v78[16 * v74];
          *(void *)int v79 = v17;
          *((_WORD *)v79 + 4) = v70;
          *((_DWORD *)v79 + 3) = 1;
          uint64_t v11 = v178;
          unint64_t v80 = (unint64_t)v178[66];
          BOOL v81 = (char *)v178[65];
          if ((char *)v80 == v81)
          {
            int64x2_t v83 = vdupq_n_s64(v80);
            long long v82 = v79;
          }
          else
          {
            long long v82 = v79;
            do
            {
              *((_OWORD *)v82 - 1) = *(_OWORD *)(v80 - 16);
              v82 -= 16;
              v80 -= 16;
            }
            while ((char *)v80 != v81);
            int64x2_t v83 = *v172;
          }
          uint64_t v73 = v79 + 16;
          v178[65] = (unint64_t *)v82;
          v178[66] = (unint64_t *)(v79 + 16);
          int64x2_t v186 = v83;
          uint64_t v101 = (char *)v178[67];
          v178[67] = (unint64_t *)&v78[16 * v77];
          v187 = v101;
          uint64_t v185 = v83.i64[0];
          std::__split_buffer<std::tuple<unsigned short,unsigned short,long>,TInlineBufferAllocator<std::tuple<unsigned short,unsigned short,long>,30ul> &>::~__split_buffer((uint64_t)&v185);
          a5 = v176;
        }
        else
        {
          *(void *)unint64_t v71 = v17;
          *(_WORD *)(v71 + 8) = v70;
          uint64_t v73 = (char *)(v71 + 16);
          *(_DWORD *)(v71 + 12) = 1;
        }
        v11[66] = (unint64_t *)v73;
        if (v51 > v31) {
          goto LABEL_125;
        }
LABEL_184:
        uint64_t v108 = 1;
LABEL_128:
        v109 = (char *)*v11;
        id v110 = v11[1];
        if (*v11 == v110)
        {
          v130 = (char *)v11[65];
          v131 = (char *)v11[66];
          if (v130 == v131) {
            return v108;
          }
          size_t v132 = v131 - v130;
          unint64_t v133 = (v131 - v130) >> 4;
          uint64_t v134 = (uint64_t)a7[2];
          v135 = (char *)*a7;
          unint64_t v136 = (v134 - (uint64_t)*a7) >> 4;
          if (v136 >= v133)
          {
            v159 = a7 + 1;
            v158 = (char *)a7[1];
            unint64_t v160 = (v158 - v135) >> 4;
            if (v160 >= v133)
            {
              v162 = (char *)*a7;
              v163 = (char *)v11[65];
            }
            else
            {
              v161 = &v130[16 * v160];
              if (v158 != v135)
              {
                memmove(*a7, v11[65], v158 - v135);
                v135 = (char *)*v159;
              }
              size_t v132 = v131 - v161;
              if (v131 == v161) {
                goto LABEL_204;
              }
              v162 = v135;
              v163 = v161;
            }
            memmove(v162, v163, v132);
          }
          else
          {
            if (v135)
            {
              v137 = a7;
              a7[1] = v135;
              if (a7 + 3 > (void **)v135 || (v138 = a7 + 63, a7 + 63 <= (void **)v135))
              {
                operator delete(v135);
              }
              else if (&v135[16 * v136] == *v138)
              {
                *v138 = v135;
              }
              uint64_t v134 = 0;
              *a7 = 0;
              a7[1] = 0;
              a7[2] = 0;
            }
            else
            {
              v137 = a7;
            }
            if ((v132 & 0x8000000000000000) != 0) {
              goto LABEL_207;
            }
            uint64_t v164 = v134 >> 3;
            if (v134 >> 3 <= v133) {
              uint64_t v164 = v133;
            }
            unint64_t v165 = (unint64_t)v134 >= 0x7FFFFFFFFFFFFFF0 ? 0xFFFFFFFFFFFFFFFLL : v164;
            if (v165 >> 60) {
LABEL_207:
            }
              abort();
            v135 = TInlineBufferAllocator<CGPoint,30ul>::allocate((uint64_t)(v137 + 3), v165);
            *v137 = v135;
            v137[1] = v135;
            v137[2] = &v135[16 * v165];
            memmove(v135, v130, v132);
            v159 = v137 + 1;
          }
LABEL_204:
          *v159 = &v135[v132];
          return v108;
        }
        id v111 = v11[129];
        unint64_t v112 = ((char *)v110 - v109) >> 4;
        unint64_t v177 = v111[26] % v112;
        id v113 = &v109[16 * v177];
        while (1)
        {
          uint64_t v114 = *(void *)v113;
          uint64_t v115 = *((void *)v113 + 1);
          uint64_t v116 = *(void *)(*(void *)(v111[27] + 48) + 8 * v111[25] + 8 * *(void *)v113);
          v117 = (TRun *)v178[129];
          *(double *)&uint64_t v185 = COERCE_DOUBLE(TRun::GetGlyphIndexForCharIndex<false>((uint64_t)v117, v116));
          uint64_t NextChar = TRun::GetNextChar(v117, v116, &v185);
          unsigned int v119 = bswap32(*(unsigned __int16 *)(v115 + 10)) >> 16;
          unint64_t v120 = v115 + 12 + 2 * v119;
          if (v115 + 14 <= (unint64_t)a4) {
            unsigned __int16 v121 = (a4 - (v115 + 12)) >> 1;
          }
          else {
            unsigned __int16 v121 = 0;
          }
          if (v120 <= (unint64_t)a4 && v120 >= v115 + 12) {
            unsigned __int16 v123 = v119;
          }
          else {
            unsigned __int16 v123 = v121;
          }
          if (NextChar - v116 < v123)
          {
            unint64_t v177 = (v177 + 1) % (((char *)v178[1] - (char *)*v178) >> 4);
            id v113 = (char *)&(*v178)[2 * v177];
            goto LABEL_145;
          }
          uint64_t v124 = NextChar;
          uint64_t v125 = v123;
          uint64_t v126 = [(id)v111[27] attachmentCountAtIndex:v111[25] + v114];
          uint64_t v127 = (uint64_t)v178[129];
          if (v126 >= 1)
          {
            char v139 = *(unsigned char *)(v127 + 224);
            unint64_t v112 = v125 - 1;
            if (v125 >= 2)
            {
              uint64_t v140 = 2 - v125;
              if ((*(unsigned char *)(v127 + 224) & 1) == 0) {
                uint64_t v140 = 1;
              }
              v189.CFIndex location = *(void *)v113 + v140;
              v189.CFIndex length = v125 - 1;
              TStorageRange::InsertGlyphs((id *)v111 + 24, v189);
              v114 += v112;
            }
            [(id)v111[27] setAttachmentCount:v126 - v112 atIndex:v111[25] + v114];
            if (v125)
            {
              uint64_t v141 = *(void *)(*(void *)(v111[27] + 48) + 8 * v111[25] + 8 * v114);
              if (v139) {
                uint64_t v142 = -1;
              }
              else {
                uint64_t v142 = 1;
              }
              v143 = (unsigned __int16 *)(v115 + 12);
              do
              {
                unsigned int v144 = *v143++;
                [(id)v111[27] setGlyph:__rev16(v144) atIndex:v114 + v111[25]];
                char v145 = *((unsigned char *)v111 + 225);
                if (v144 == 0xFFFF && (v145 & 2) != 0) {
                  *((unsigned char *)v111 + 225) = v145 | 8;
                }
                [(id)v111[27] setStringIndex:v141 atIndex:v114 + v111[25]];
                v114 += v142;
                ++v141;
                --v125;
              }
              while (v125);
            }
            goto LABEL_182;
          }
          uint64_t GlyphIndexForChar = TRun::GetGlyphIndexForCharIndex<false>(v127, v124);
          uint64_t v129 = GlyphIndexForChar - v114;
          if (GlyphIndexForChar - v114 < 0) {
            uint64_t v129 = v114 - GlyphIndexForChar;
          }
          if (v129 == v125) {
            break;
          }
LABEL_145:
          if (!--v112)
          {
            uint64_t v108 = 0;
            goto LABEL_183;
          }
        }
        uint64_t v108 = 1;
        if (v178[129][28]) {
          uint64_t v147 = -1;
        }
        else {
          uint64_t v147 = 1;
        }
        if (v125)
        {
          uint64_t v148 = 0;
          unint64_t v149 = v111[27];
          unint64_t v150 = v111[25];
          uint64_t v151 = *(void *)(*(void *)(v149 + 48) + 8 * v150 + 8 * v114);
          v152 = (unsigned __int16 *)(v115 + 12);
          uint64_t v153 = *(void *)(v149 + 40) + 4 * v150 + 4 * v114;
          do
          {
            unsigned int v154 = *v152++;
            uint64_t v155 = v114 + v148;
            [(id)v111[27] setGlyph:__rev16(v154) atIndex:v114 + v148 + v111[25]];
            char v156 = *((unsigned char *)v111 + 225);
            if (v154 == 0xFFFF && (v156 & 2) != 0) {
              *((unsigned char *)v111 + 225) = v156 | 8;
            }
            [(id)v111[27] setProps:*(_DWORD *)(v153 + 4 * v148) & 0xFFFFFFDF atIndex:v155 + v111[25]];
            [(id)v111[27] setStringIndex:v151 + v148 atIndex:v155 + v111[25]];
            v148 += v147;
            --v125;
          }
          while (v125);
          unint64_t v112 = 0;
LABEL_182:
          uint64_t v108 = 1;
          goto LABEL_183;
        }
        unint64_t v112 = 0;
LABEL_183:
        *a6 = v112;
        return v108;
      case 3u:
        if (v31 > 0.0)
        {
          int v53 = (atomic_ullong *)v11[129];
          atomic_ullong v54 = v53[27];
          uint64_t v55 = *(void *)(v54 + 32);
          if (v55 || (uint64_t v84 = *(void *)(v54 + 24)) == 0) {
            CFRange v56 = (double *)(v55 + 16 * v53[25] + 16 * v17);
          }
          else {
            CFRange v56 = (double *)(v84 + 8 * v53[25] + 8 * v17);
          }
          double v85 = *v56;
          uint64_t v86 = *(void *)(atomic_load_explicit(v53 + 7, memory_order_acquire) + 40);
          __int16 v184 = *(_WORD *)(*(void *)(v53[27] + 16) + 2 * v53[25] + 2 * v17);
          *(double *)&uint64_t v185 = NAN;
          TFont::GetUnsummedAdvancesForGlyphs(v86, (uint64_t)&v184, (double *)&v185, 1, 1, 0, 0);
          long long v87 = (TRun *)v11[129];
          double v88 = v85 / *(double *)&v185;
          TRun::InitStretchFactors(v87);
          *(double *)(*(void *)(*((void *)v87 + 39) + 56) + 16 * v17) = v88;
          a5 = v176;
        }
        goto LABEL_125;
      case 5u:
        if (v31 <= 0.0) {
          goto LABEL_125;
        }
        if (*((unsigned char *)v11[129] + 90) || v25 + 6 > (unsigned __int16 *)a4) {
          goto LABEL_125;
        }
        unsigned int v58 = bswap32(v25[5]) >> 16;
        unint64_t v59 = (unint64_t)v11[66];
        unint64_t v60 = (unint64_t)v11[67];
        if (v59 >= v60)
        {
          uint64_t v89 = (uint64_t)(v59 - v172->i64[0]) >> 4;
          unint64_t v90 = v89 + 1;
          if ((unint64_t)(v89 + 1) >> 60) {
            goto LABEL_207;
          }
          uint64_t v91 = v60 - v172->i64[0];
          if (v91 >> 3 > v90) {
            unint64_t v90 = v91 >> 3;
          }
          if ((unint64_t)v91 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v64 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v64 = v90;
          }
          uint64_t v188 = v171;
          uint64_t v65 = TInlineBufferAllocator<CGPoint,30ul>::allocate(v171, v64);
          int v66 = &v65[16 * v89];
          *(void *)int v66 = v17;
          *((_WORD *)v66 + 4) = v58;
          *((_DWORD *)v66 + 3) = 0;
          uint64_t v11 = v178;
          unint64_t v67 = (unint64_t)v178[66];
          long long v92 = (char *)v178[65];
          if ((char *)v67 == v92)
          {
LABEL_95:
            int64x2_t v93 = vdupq_n_s64(v67);
            long long v69 = v66;
          }
          else
          {
            long long v69 = v66;
            do
            {
              *((_OWORD *)v69 - 1) = *(_OWORD *)(v67 - 16);
              v69 -= 16;
              v67 -= 16;
            }
            while ((char *)v67 != v92);
LABEL_94:
            int64x2_t v93 = *v172;
          }
          size_t v47 = v66 + 16;
          v11[65] = (unint64_t *)v69;
          v11[66] = (unint64_t *)(v66 + 16);
          int64x2_t v186 = v93;
          unint64_t v94 = (char *)v11[67];
          v11[67] = (unint64_t *)&v65[16 * v64];
          v187 = v94;
          uint64_t v185 = v93.i64[0];
          std::__split_buffer<std::tuple<unsigned short,unsigned short,long>,TInlineBufferAllocator<std::tuple<unsigned short,unsigned short,long>,30ul> &>::~__split_buffer((uint64_t)&v185);
          a5 = v176;
        }
        else
        {
          *(void *)unint64_t v59 = v17;
          *(_WORD *)(v59 + 8) = v58;
          size_t v47 = (char *)(v59 + 16);
          *(_DWORD *)(v59 + 12) = 0;
        }
LABEL_97:
        v11[66] = (unint64_t *)v47;
        goto LABEL_125;
      default:
        goto LABEL_125;
    }
  }
}

CFIndex TAATPostcompEngine::ApplyKashidas(uint64_t a1, uint64_t a2, uint64_t **a3, uint64_t a4)
{
  unint64_t v5 = *a3;
  uint64_t v4 = a3[1];
  if (*a3 != v4)
  {
    uint64_t v6 = a4;
    uint64_t v8 = a1;
    CFIndex v9 = 0;
    CFRange v56 = a3[1];
    uint64_t v52 = a1;
    uint64_t v53 = a4;
    while (1)
    {
      if (v8 == a2) {
        goto LABEL_50;
      }
      uint64_t v10 = 0;
      uint64_t v11 = *v5;
      uint64_t v12 = *((unsigned __int16 *)v5 + 4);
      int v13 = *((_DWORD *)v5 + 3);
      uint64_t v14 = *v5 + v9;
      uint64_t v15 = v8;
      while (1)
      {
        uint64_t v16 = *(void *)(*(void *)(*(void *)v15 + 40) + 208) + v10;
        if (v16 > v14) {
          break;
        }
        v15 += 8;
        uint64_t v10 = v16;
        if (v15 == a2) {
          goto LABEL_50;
        }
      }
      if (v15 == a2) {
        goto LABEL_50;
      }
      uint64_t v17 = v14 - v10;
      uint64_t v18 = *(void *)(*(void *)v15 + 48);
      uint64_t v19 = *(void **)(v18 + 216);
      uint64_t v20 = *(void *)(v18 + 200);
      uint64_t v21 = v19[4];
      if (v21 || (uint64_t v24 = v19[3]) == 0)
      {
        uint64_t v22 = (double *)(v21 + 16 * v20 + 16 * v17);
        double v23 = v22[1];
      }
      else
      {
        uint64_t v22 = (double *)(v24 + 8 * v20 + 8 * v17);
        double v23 = 0.0;
      }
      uint64_t v25 = v19[5] + 4 * v20;
      uint64_t v58 = *(void *)(v19[6] + 8 * v20 + 8 * v17);
      unint64_t v59 = (TStorageRange *)(v18 + 192);
      double v26 = *v22;
      uint64_t v27 = *(void *)(atomic_load_explicit((atomic_ullong *volatile)(v18 + 56), memory_order_acquire) + 40);
      double v28 = *(double *)(v6 + 8 * v11);
      if (v13)
      {
        __int16 v61 = v12;
        double v60 = NAN;
        TFont::GetUnsummedAdvancesForGlyphs(v27, (uint64_t)&v61, &v60, 1, 1, 0, 0);
        if (v28 <= 0.0) {
          goto LABEL_49;
        }
        double v29 = v60;
        if (v60 <= 0.0) {
          goto LABEL_49;
        }
        v64.double width = v26 - *(double *)(v6 + 8 * v11);
        double v30 = v28 / v60;
        v64.height = 0.0;
        TStorageRange::SetAdvance(v59, v17, v64);
        [*(id *)(v18 + 216) setProps:*(_DWORD *)(v25 + 4 * v17) | 0x80u atIndex:*(void *)(v18 + 200) + v17];
        CFIndex v31 = v17 + 1;
        v62.CFIndex location = v31;
        v62.CFIndex length = 1;
        TStorageRange::InsertGlyphs((id *)v59, v62);
        TRun::InitStretchFactors((TRun *)v18);
        *(double *)(*(void *)(*(void *)(v18 + 312) + 56) + 16 * v31) = v30;
        [*(id *)(v18 + 216) setGlyph:v12 atIndex:*(void *)(v18 + 200) + v31];
        if (v12 == 0xFFFF && (*(unsigned char *)(v18 + 225) & 2) != 0) {
          *(unsigned char *)(v18 + 225) |= 8u;
        }
        v65.double width = v29 * v30;
        v65.height = v23;
        TStorageRange::SetAdvance(v59, v31, v65);
        [*(id *)(v18 + 216) setStringIndex:v58 atIndex:*(void *)(v18 + 200) + v31];
        [*(id *)(v18 + 216) setProps:256 atIndex:*(void *)(v18 + 200) + v31];
        [*(id *)(v18 + 216) setAttachmentCount:0 atIndex:*(void *)(v18 + 200) + v31];
        uint64_t v32 = (double *)MEMORY[0x1E4F1DAD8];
        double v34 = *MEMORY[0x1E4F1DAD8];
        double v33 = *(double *)(MEMORY[0x1E4F1DAD8] + 8);
        objc_msgSend(*(id *)(v18 + 216), "setOrigin:atIndex:", *(void *)(v18 + 200) + v31, *MEMORY[0x1E4F1DAD8], v33);
        if (v34 != *v32 || v33 != *(double *)(MEMORY[0x1E4F1DAD8] + 8)) {
          *(unsigned char *)(v18 + 225) |= 0x10u;
        }
        ++v9;
        uint64_t v4 = v56;
        if (*(int *)(v18 + 256) > 1) {
          goto LABEL_50;
        }
        uint64_t v35 = (_DWORD *)(v18 + 256);
      }
      else
      {
        __int16 v61 = v12;
        double v60 = NAN;
        TFont::GetUnsummedAdvancesForGlyphs(v27, (uint64_t)&v61, &v60, 1, 1, 0, 0);
        if (v28 < 0.0 || v60 <= 0.0) {
          goto LABEL_49;
        }
        double v36 = v28 / v60;
        if (v28 / v60 <= 1.0)
        {
          CFIndex v54 = v9;
          if (v60 < v28) {
            double v28 = v60;
          }
          CFIndex v39 = 1;
        }
        else
        {
          double v37 = ceil(v36);
          uint64_t v38 = llround(v37);
          if (v38 > 32766) {
            goto LABEL_49;
          }
          CFIndex v54 = v9;
          double v28 = v28 / v37;
          double v36 = v28 / v60;
          CFIndex v39 = v38;
        }
        v66.double width = v26 - *(double *)(v6 + 8 * v11);
        v66.height = 0.0;
        TStorageRange::SetAdvance(v59, v17, v66);
        [*(id *)(v18 + 216) setProps:*(_DWORD *)(v25 + 4 * v17) | 0x80u atIndex:*(void *)(v18 + 200) + v17];
        CFIndex v40 = v17 + 1;
        v63.CFIndex location = v40;
        v63.CFIndex length = v39;
        TStorageRange::InsertGlyphs((id *)v59, v63);
        CFIndex v55 = v39;
        CFIndex v57 = v39 - 1;
        if (v39 >= 1)
        {
          uint64_t v41 = 0;
          CFIndex v42 = v39 + v40;
          uint64_t v43 = 16 * v40;
          double v44 = 0.0;
          do
          {
            CFIndex v45 = v40 + v41;
            double v46 = -0.0;
            if (v57 == v41) {
              double v46 = v23;
            }
            double v44 = v44 + v46;
            TRun::InitStretchFactors((TRun *)v18);
            *(double *)(*(void *)(*(void *)(v18 + 312) + 56) + v43) = v36;
            v67.double width = v28;
            v67.height = v44;
            TStorageRange::SetAdvance(v59, v40 + v41, v67);
            [*(id *)(v18 + 216) setGlyph:v12 atIndex:v45 + *(void *)(v18 + 200)];
            if (v12 == 0xFFFF && (*(unsigned char *)(v18 + 225) & 2) != 0) {
              *(unsigned char *)(v18 + 225) |= 8u;
            }
            objc_msgSend(*(id *)(v18 + 216), "setStringIndex:atIndex:", v58, v45 + *(void *)(v18 + 200), v52, v53);
            [*(id *)(v18 + 216) setProps:256 atIndex:v45 + *(void *)(v18 + 200)];
            [*(id *)(v18 + 216) setAttachmentCount:0 atIndex:v45 + *(void *)(v18 + 200)];
            size_t v47 = (double *)MEMORY[0x1E4F1DAD8];
            double v48 = *MEMORY[0x1E4F1DAD8];
            double v49 = *(double *)(MEMORY[0x1E4F1DAD8] + 8);
            objc_msgSend(*(id *)(v18 + 216), "setOrigin:atIndex:", v45 + *(void *)(v18 + 200), *MEMORY[0x1E4F1DAD8], v49);
            if (v48 != *v47 || v49 != v47[1]) {
              *(unsigned char *)(v18 + 225) |= 0x10u;
            }
            ++v41;
            v43 += 16;
          }
          while (v40 + v41 < v42);
        }
        CFIndex v9 = v55 + v54;
        if (*(int *)(v18 + 256) >= 2)
        {
          uint64_t v8 = v52;
          uint64_t v6 = v53;
LABEL_49:
          uint64_t v4 = v56;
          goto LABEL_50;
        }
        uint64_t v35 = (_DWORD *)(v18 + 256);
        uint64_t v8 = v52;
        uint64_t v6 = v53;
        uint64_t v4 = v56;
      }
      *uint64_t v35 = 1;
LABEL_50:
      v5 += 2;
      if (v5 == v4) {
        return v9;
      }
    }
  }
  return 0;
}

uint64_t CollectChars(uint64_t result, uint64_t a2, uint64_t a3, void *a4, void *a5, char **a6)
{
  if (a4 != a5)
  {
    uint64_t v8 = a4;
    uint64_t v10 = result;
    uint64_t v11 = (uint64_t)(a6 + 3);
    uint64_t v12 = a6[1];
    do
    {
      uint64_t v13 = *v8 - v10;
      unint64_t v14 = (unint64_t)a6[2];
      if ((unint64_t)v12 >= v14)
      {
        uint64_t v15 = *a6;
        uint64_t v16 = v12 - *a6;
        if (v16 <= -3) {
          abort();
        }
        uint64_t v17 = v16 >> 1;
        unint64_t v18 = v14 - (void)v15;
        if (v18 <= (v16 >> 1) + 1) {
          unint64_t v19 = v17 + 1;
        }
        else {
          unint64_t v19 = v18;
        }
        if (v18 >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v20 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v20 = v19;
        }
        v28[4] = v11;
        if (v20)
        {
          uint64_t v21 = (char *)TInlineBufferAllocator<unsigned short,30ul>::allocate(v11, v20);
          uint64_t v15 = *a6;
          uint64_t v12 = a6[1];
        }
        else
        {
          uint64_t v21 = 0;
        }
        uint64_t v22 = &v21[2 * v17];
        *(_WORD *)uint64_t v22 = *(_WORD *)(a3 + 2 * v13);
        if (v12 == v15)
        {
          uint64_t v24 = &v21[2 * v17];
        }
        else
        {
          double v23 = v12;
          uint64_t v24 = &v21[2 * v17];
          do
          {
            __int16 v25 = *((_WORD *)v23 - 1);
            v23 -= 2;
            *((_WORD *)v24 - 1) = v25;
            v24 -= 2;
          }
          while (v23 != v15);
        }
        double v26 = v22 + 2;
        *a6 = v24;
        a6[1] = v22 + 2;
        uint64_t v27 = a6[2];
        a6[2] = &v21[2 * v20];
        v28[2] = v12;
        _DWORD v28[3] = v27;
        v28[0] = v15;
        v28[1] = v15;
        uint64_t result = std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,30ul> &>::~__split_buffer((uint64_t)v28);
        uint64_t v12 = v26;
      }
      else
      {
        *(_WORD *)uint64_t v12 = *(_WORD *)(a3 + 2 * v13);
        v12 += 2;
      }
      a6[1] = v12;
      ++v8;
    }
    while (v8 != a5);
  }
  return result;
}

BOOL DecomposeInitialChar(void *a1, uint64_t *a2, char **a3)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  unorm2_getNFDInstance();
  if (unorm2_isNormalized()) {
    return 0;
  }
  uint64_t v7 = (_WORD *)*a1;
  if ((*(_WORD *)*a1 & 0xFC00) == 0xD800 && a1[1] - (void)v7 != 2)
  {
    if ((v7[1] & 0xFC00) == 0xDC00) {
      uint64_t v8 = 2;
    }
    else {
      uint64_t v8 = 1;
    }
  }
  else
  {
    uint64_t v8 = 1;
  }
  int Decomposition = unorm2_getDecomposition();
  uint64_t v10 = 0;
  BOOL v6 = Decomposition >= (int)v8;
  if (Decomposition >= (int)v8)
  {
    *(void *)&long long v11 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v42[2] = v11;
    v42[3] = v11;
    v42[0] = v11;
    v42[1] = v11;
    unint64_t v12 = Decomposition;
    CFIndex v40 = 0;
    uint64_t v41 = 0;
    CFIndex v39 = 0;
    uint64_t v43 = v42;
    if (Decomposition)
    {
      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__vallocate[abi:nn180100](&v39, Decomposition);
      uint64_t v13 = (char *)v40;
      bzero(v40, 2 * v12);
      CFIndex v40 = &v13[2 * v12];
    }
    unorm2_getDecomposition();
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__insert_with_size[abi:nn180100]<std::__wrap_iter<unsigned short *>,std::__wrap_iter<unsigned short *>>((uint64_t)a3, (uint64_t)a3[1], v39, (char *)v40, ((unsigned char *)v40 - v39) >> 1);
    uint64_t v14 = *a2;
    uint64_t v15 = a2[1];
    uint64_t v16 = ((v15 - *a2) >> 3) - ((uint64_t)(a1[1] - *a1) >> 1);
    uint64_t v17 = *a2 + 8 * v16;
    uint64_t v18 = v15 - (v17 + 8);
    if (v15 != v17 + 8)
    {
      memmove((void *)(*a2 + 8 * v16), (const void *)(v17 + 8), v15 - (v17 + 8));
      uint64_t v14 = *a2;
    }
    a2[1] = v17 + v18;
    uint64_t v38 = 0;
    std::vector<long,TInlineBufferAllocator<long,30ul>>::insert((uint64_t)a2, (char *)(v14 + 8 * v16), v12, (char *)&v38);
    uint64_t v38 = &v39;
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v38);
    uint64_t v10 = v8;
  }
  uint64_t v19 = a1[1] - *a1;
  if (v10 != v19 >> 1)
  {
    uint64_t v20 = v19 >> 1;
    uint64_t v21 = a3[1];
    do
    {
      uint64_t v22 = (_WORD *)*a1;
      unint64_t v23 = (unint64_t)a3[2];
      if ((unint64_t)v21 >= v23)
      {
        uint64_t v24 = *a3;
        uint64_t v25 = v21 - *a3;
        if (v25 <= -3) {
          abort();
        }
        uint64_t v26 = v25 >> 1;
        unint64_t v27 = v23 - (void)v24;
        if (v27 <= (v25 >> 1) + 1) {
          unint64_t v28 = v26 + 1;
        }
        else {
          unint64_t v28 = v27;
        }
        if (v27 >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v29 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v29 = v28;
        }
        *((void *)&v42[0] + 1) = a3 + 3;
        if (v29)
        {
          double v30 = (char *)TInlineBufferAllocator<unsigned short,30ul>::allocate((uint64_t)(a3 + 3), v29);
          uint64_t v24 = *a3;
          uint64_t v21 = a3[1];
        }
        else
        {
          double v30 = 0;
        }
        CFIndex v31 = &v30[2 * v26];
        *(_WORD *)CFIndex v31 = v22[v10];
        if (v21 == v24)
        {
          double v33 = &v30[2 * v26];
        }
        else
        {
          uint64_t v32 = v21;
          double v33 = &v30[2 * v26];
          do
          {
            __int16 v34 = *((_WORD *)v32 - 1);
            v32 -= 2;
            *((_WORD *)v33 - 1) = v34;
            v33 -= 2;
          }
          while (v32 != v24);
        }
        uint64_t v35 = v31 + 2;
        *a3 = v33;
        a3[1] = v31 + 2;
        double v36 = a3[2];
        a3[2] = &v30[2 * v29];
        uint64_t v41 = v21;
        *(void *)&v42[0] = v36;
        CFIndex v39 = v24;
        CFIndex v40 = v24;
        std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,30ul> &>::~__split_buffer((uint64_t)&v39);
        uint64_t v21 = v35;
      }
      else
      {
        *(_WORD *)uint64_t v21 = v22[v10];
        v21 += 2;
      }
      a3[1] = v21;
      ++v10;
    }
    while (v10 != v20);
  }
  return v6;
}

uint64_t ComposeArabicDecompositions(uint64_t a1, void *a2, uint64_t a3)
{
  unorm2_getNFDInstance();
  unsigned int v6 = unorm2_composePair();
  if (HIWORD(v6)) {
    return 0;
  }
  __int16 v7 = v6;
  if (a1 != a3) {
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)a3, *(char **)a1, *(void *)(a1 + 8), (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 1);
  }
  uint64_t v8 = *(_WORD **)a3;
  CFIndex v9 = *(unsigned char **)(a3 + 8);
  uint64_t v10 = (char *)(*(void *)a3 + 2);
  *uint64_t v8 = v7;
  long long v11 = v8 + 2;
  int64_t v12 = v9 - v11;
  if (v9 != v11) {
    memmove(v10, v11, v9 - v11);
  }
  *(void *)(a3 + 8) = &v10[v12];
  uint64_t v13 = a2[1];
  uint64_t v14 = v13 - *a2;
  if (v13 != *a2)
  {
    uint64_t v15 = 0;
    uint64_t v16 = v14 >> 3;
    while (v15 == *(void *)(*a2 + 8 * v15))
    {
      if (v16 == ++v15) {
        return 1;
      }
    }
    AdjustIndexesForPairwiseComposition(a2);
  }
  return 1;
}

uint64_t FontCanPositionHebrewMarks(TBaseFont **a1)
{
  if (TBaseFont::GetCommonTable(a1[50], 1801810552, 0)) {
    return 1;
  }
  uint64_t result = TBaseFont::GetCommonTable(a1[50], 1196445523, 0);
  if (result)
  {
    CFDataRef v3 = (const __CFData *)result;
    *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v9[3] = v4;
    v9[4] = v4;
    v9[1] = v4;
    v9[2] = v4;
    v9[0] = v4;
    CFDataRef CommonTable = (const __CFData *)TBaseFont::GetCommonTable(a1[50], 1195656518, 0);
    OTL::GDEF::GDEF((OTL::GDEF *)v9, CommonTable);
    unint64_t v8 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v7[3] = v6;
    v7[4] = v6;
    v7[1] = v6;
    id v7[2] = v6;
    v7[0] = v6;
    OTL::GCommon::GCommon((uint64_t)v7, 1, a1, v3, (uint64_t)v9, 1751474802, 0);
    *(void *)&v7[0] = &unk_1ED05FAF8;
    return OTL::GCommon::HasFeature((OTL::GCommon *)v7, 0x6D61726Bu);
  }
  return result;
}

uint64_t TCombiningEngine::ComposeHebrewPresentationForms(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v91 = *MEMORY[0x1E4F143B8];
  CFDataRef v3 = *(char **)a1;
  if (*(void *)(a1 + 8) - *(void *)a1 < 4uLL) {
    return 0;
  }
  uint64_t v6 = 0;
  int v19 = 95684057;
  __int16 v20 = -1251;
  int v21 = 95880690;
  __int16 v22 = -1249;
  int v23 = 96536041;
  __int16 v24 = -1238;
  int v25 = 96601577;
  __int16 v26 = -1237;
  int v27 = 96598857;
  __int16 v28 = -1236;
  __int16 v30 = -1236;
  int v29 = 96271146;
  int v31 = 96664393;
  __int16 v32 = -1235;
  int v33 = 96271147;
  __int16 v34 = -1235;
  int v35 = 95880656;
  __int16 v36 = -1234;
  int v37 = 95946192;
  __int16 v38 = -1233;
  int v39 = 96208336;
  __int16 v40 = -1232;
  int v41 = 96208337;
  __int16 v42 = -1231;
  int v43 = 96208338;
  __int16 v44 = -1230;
  int v45 = 96208339;
  __int16 v46 = -1229;
  int v47 = 96208340;
  __int16 v48 = -1228;
  int v49 = 96208341;
  __int16 v50 = -1227;
  int v51 = 96208342;
  __int16 v52 = -1226;
  int v53 = 96208344;
  __int16 v54 = -1224;
  int v55 = 96208345;
  __int16 v56 = -1223;
  int v57 = 96208346;
  __int16 v58 = -1222;
  int v59 = 96208347;
  __int16 v60 = -1221;
  int v61 = 96208348;
  __int16 v62 = -1220;
  int v63 = 96208350;
  __int16 v64 = -1218;
  int v65 = 96208352;
  __int16 v66 = -1216;
  int v67 = 96208353;
  __int16 v68 = -1215;
  int v69 = 96208355;
  __int16 v70 = -1213;
  int v71 = 96208356;
  __int16 v72 = -1212;
  int v73 = 96208358;
  __int16 v74 = -1210;
  int v75 = 96208359;
  __int16 v76 = -1209;
  int v77 = 96208360;
  __int16 v78 = -1208;
  int v79 = 96208361;
  __int16 v80 = -1207;
  int v81 = 96208362;
  __int16 v82 = -1206;
  int v83 = 96011733;
  __int16 v84 = -1205;
  int v85 = 96404945;
  __int16 v86 = -1204;
  int v87 = 96404955;
  __int16 v88 = -1203;
  int v89 = 96404964;
  __int16 v90 = -1202;
  int v7 = *(unsigned __int16 *)v3;
  int v8 = *((unsigned __int16 *)v3 + 1);
  while (*(unsigned __int16 *)((char *)&v19 + v6) != v7 || *(unsigned __int16 *)((char *)&v19 + v6 + 2) != v8)
  {
    v6 += 6;
    if (v6 == 216) {
      return 0;
    }
  }
  UniChar v12 = *(_WORD *)((char *)&v19 + v6 + 4);
  id v18 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr, uint64_t))(*(void *)a3 + 184))(&v18, a3);
  if (atomic_load_explicit((atomic_ullong *volatile)&v18, memory_order_acquire)
    && CFCharacterSetIsCharacterMember((CFCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v18, memory_order_acquire), v12))
  {
    if (a1 != a2) {
      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)a2, *(char **)a1, *(void *)(a1 + 8), (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 1);
    }
    uint64_t v13 = *(UniChar **)a2;
    uint64_t v14 = (char *)(*(void *)a2 + 2);
    *uint64_t v13 = v12;
    uint64_t v15 = v13 + 2;
    uint64_t v16 = *(unsigned char **)(a2 + 8);
    int64_t v17 = v16 - v15;
    if (v16 != v15) {
      memmove(v14, v15, v16 - v15);
    }
    *(void *)(a2 + 8) = &v14[v17];
    uint64_t v10 = 1;
  }
  else
  {
    uint64_t v10 = 0;
  }

  return v10;
}

void *AdjustIndexesForPairwiseComposition(void *result)
{
  unsigned int v1 = result;
  uint64_t v3 = *result;
  uint64_t v2 = (uint64_t *)result[1];
  long long v4 = (uint64_t *)(*result + 8);
  uint64_t v5 = *v4;
  BOOL v6 = v4 == v2 || v5 == 0;
  uint64_t v7 = *result + 8;
  if (!v6)
  {
    int v8 = (uint64_t *)(v3 + 16);
    while (v8 != v2)
    {
      if (!*v8++)
      {
        uint64_t v7 = (uint64_t)(v8 - 1);
        goto LABEL_10;
      }
    }
    uint64_t v7 = result[1];
  }
LABEL_10:
  if ((uint64_t *)v7 == v2)
  {
    unint64_t v11 = (unint64_t)v2 - v3 - 16;
    if (v2 == (uint64_t *)(v3 + 16))
    {
      unint64_t v13 = (unint64_t)(v2 - 1);
      result[1] = v13;
    }
    else
    {
      uint64_t result = memmove((void *)(*result + 8), (const void *)(v3 + 16), (size_t)v2 - v3 - 16);
      unint64_t v12 = v11 & 0xFFFFFFFFFFFFFFF8;
      unint64_t v13 = (v11 & 0xFFFFFFFFFFFFFFF8) + v3 + 8;
      v1[1] = v13;
      while (*v4 != v5)
      {
        ++v4;
        v12 -= 8;
        if (!v12)
        {
          long long v4 = (uint64_t *)((v11 & 0xFFFFFFFFFFFFFFF8) + v3 + 8);
          break;
        }
      }
    }
    if (v4 == (uint64_t *)v13)
    {
      uint64_t v14 = (void *)*v1;
      while (++v14 != (void *)v13)
      {
        if (*v14 > v5) {
          --*v14;
        }
      }
    }
  }
  else
  {
    uint64_t v10 = (char *)v2 - v7 - 8;
    if (v2 != (uint64_t *)(v7 + 8)) {
      uint64_t result = memmove((void *)v7, (const void *)(v7 + 8), (size_t)v2 - v7 - 8);
    }
    v1[1] = &v10[v7];
  }
  return result;
}

char *std::vector<long,TInlineBufferAllocator<long,30ul>>::insert(uint64_t a1, char *__src, unint64_t a3, char *a4)
{
  long long v4 = __src;
  if (a3)
  {
    uint64_t v5 = a4;
    int v8 = *(char **)(a1 + 8);
    uint64_t v9 = *(void *)(a1 + 16);
    if (a3 <= (v9 - (uint64_t)v8) >> 3)
    {
      uint64_t v17 = v8 - __src;
      if (a3 <= (v8 - __src) >> 3)
      {
        __int16 v20 = *(char **)(a1 + 8);
        uint64_t v19 = a3;
      }
      else
      {
        uint64_t v18 = 0;
        uint64_t v19 = v17 >> 3;
        __int16 v20 = &v8[8 * (a3 - (v17 >> 3))];
        do
        {
          *(void *)&v8[v18] = *(void *)a4;
          v18 += 8;
        }
        while (8 * a3 - 8 * v19 != v18);
        *(void *)(a1 + 8) = v20;
        if (v8 == __src) {
          return v4;
        }
      }
      int v21 = &__src[8 * a3];
      __int16 v22 = &v20[-8 * a3];
      int v23 = v20;
      if (v22 < v8)
      {
        int v23 = v20;
        do
        {
          uint64_t v24 = *(void *)v22;
          v22 += 8;
          *(void *)int v23 = v24;
          v23 += 8;
        }
        while (v22 < v8);
      }
      *(void *)(a1 + 8) = v23;
      if (v20 != v21) {
        memmove(&v20[-8 * ((v20 - v21) >> 3)], __src, v20 - v21);
      }
      if (v4 <= v5)
      {
        if (*(void *)(a1 + 8) <= (unint64_t)v5) {
          unint64_t v25 = 0;
        }
        else {
          unint64_t v25 = a3;
        }
        v5 += 8 * v25;
      }
      __int16 v26 = v4;
      do
      {
        *(void *)__int16 v26 = *(void *)v5;
        v26 += 8;
        --v19;
      }
      while (v19);
    }
    else
    {
      uint64_t v10 = *(unsigned char **)a1;
      unint64_t v11 = a3 + ((uint64_t)&v8[-*(void *)a1] >> 3);
      if (v11 >> 61) {
        abort();
      }
      uint64_t v12 = (__src - v10) >> 3;
      uint64_t v13 = a1 + 24;
      uint64_t v14 = v9 - (void)v10;
      if (v14 >> 2 > v11) {
        unint64_t v11 = v14 >> 2;
      }
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v15 = v11;
      }
      v31[4] = a1 + 24;
      if (v15) {
        uint64_t v16 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate(v13, v15);
      }
      else {
        uint64_t v16 = 0;
      }
      int v27 = &v16[8 * v12];
      v31[0] = v16;
      v31[1] = v27;
      v31[3] = &v16[8 * v15];
      uint64_t v28 = 8 * a3;
      int v29 = &v27[8 * a3];
      do
      {
        *(void *)int v27 = *(void *)v5;
        v27 += 8;
        v28 -= 8;
      }
      while (v28);
      v31[2] = v29;
      long long v4 = std::vector<long,TInlineBufferAllocator<long,30ul>>::__swap_out_circular_buffer((void **)a1, (uint64_t)v31, v4);
      std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)v31);
    }
  }
  return v4;
}

TRunGlue *TRunGlue::InsertedGlyphsAtCharIndex(TRunGlue *this, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = this;
  *(void *)(*(void *)this + 144) += a2;
  uint64_t v4 = *((void *)this + 19);
  uint64_t v5 = *(void *)(v4 + 8);
  if (v5 <= a3)
  {
    if (*(void *)(v4 + 16) + v5 > a3)
    {
      this = (TRunGlue *)TRunGlue::UpdateForCurrentRealRun(this);
      *((void *)v3 + 21) += a2;
      uint64_t v9 = *((void *)v3 + 4);
      if (v9 != -1) {
        *((void *)v3 + 4) = v9 + a2;
      }
    }
  }
  else
  {
    uint64_t v6 = *((void *)this + 16);
    *((void *)this + 16) = 0;
    uint64_t v7 = *(void *)(*(void *)(*(void *)(*(void *)this + 16)
                               + 8 * TRunGlue::PhysicalRunIndexFromLogical(this, 0))
                   + 48);
    *((void *)v3 + 19) = v7;
    *((void *)v3 + 20) = 0;
    *((void *)v3 + 21) = *(void *)(v7 + 208);
    return (TRunGlue *)TRunGlue::SelectRun(v3, v6);
  }
  return this;
}

uint64_t ApplyModifiedCombiningClasses(char **a1, int a2, void *a3, char *a4)
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  int v8 = *a1;
  uint64_t v9 = a1[1];
  uint64_t v10 = v9 - *a1;
  if ((*(_WORD *)*a1 & 0xFC00) == 0xD800 && v10 != 2)
  {
    if ((*((_WORD *)v8 + 1) & 0xFC00) == 0xDC00) {
      uint64_t v11 = 2;
    }
    else {
      uint64_t v11 = 1;
    }
  }
  else
  {
    uint64_t v11 = 1;
  }
  unint64_t v12 = v10 >> 1;
  if (v10 >> 1 >= (unint64_t)(v11 + 2))
  {
    *(void *)&long long v14 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v62[0] = v14;
    v62[1] = v14;
    unint64_t v15 = v62;
    __int16 v60 = 0;
    int v61 = 0;
    int v59 = 0;
    int v63 = (char *)v62;
    if (v9 != v8)
    {
      if (v10 < 0) {
        abort();
      }
      if ((unint64_t)v10 <= 0x3C) {
        int v63 = (char *)&v59 + v12 + 24;
      }
      else {
        unint64_t v15 = operator new(v10 >> 1);
      }
      uint64_t v16 = (char *)v15 + v12;
      int v59 = v15;
      int v61 = (char *)v15 + v12;
      bzero(v15, v10 >> 1);
      __int16 v60 = v16;
    }
    if (v11 == v12)
    {
      uint64_t v17 = v10 >> 1;
      if ((a2 & 1) == 0) {
        goto LABEL_78;
      }
    }
    else
    {
      char v18 = 0;
      uint64_t v19 = v11;
      do
      {
        __int16 v20 = *a1;
        uint64_t v21 = v19 + 1;
        UChar32 v22 = *(unsigned __int16 *)&(*a1)[2 * v19];
        if ((v22 & 0xFC00) == 0xD800 && v21 != (a1[1] - v20) >> 1)
        {
          int v23 = *(unsigned __int16 *)&v20[2 * v21];
          BOOL v24 = (v23 & 0xFC00) == 56320;
          int v25 = v23 + (v22 << 10) - 56613888;
          uint64_t v21 = v24 ? v19 + 2 : v19 + 1;
          if (v24) {
            UChar32 v22 = v25;
          }
        }
        unsigned int CombiningClass = u_getCombiningClass(v22);
        if (CombiningClass > 0x21) {
          int v27 = 0;
        }
        else {
          int v27 = byte_184BA1BA8[CombiningClass];
        }
        BOOL v28 = v27 != 0;
        if (!v27) {
          LOBYTE(v27) = CombiningClass;
        }
        if (v19 != v21)
        {
          do
            *((unsigned char *)v59 + v19++) = v27;
          while (v21 != v19);
          uint64_t v19 = v21;
        }
        v18 |= v28;
      }
      while (v19 != v12);
      if (!a2)
      {
        if ((v18 & 1) == 0)
        {
LABEL_78:
          char v13 = 0;
LABEL_79:
          v55[0] = (void **)&v59;
          std::vector<char,TInlineBufferAllocator<char,30ul>>::__destroy_vector::operator()[abi:nn180100](v55);
          return v13 & 1;
        }
LABEL_39:
        if (a1 != (char **)a4) {
          std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>(a4, *a1, (uint64_t)a1[1], (a1[1] - *a1) >> 1);
        }
        int v29 = v59;
        __int16 v30 = v60;
        int v31 = (char *)v59 + v11;
        if ((char *)v59 + v11 == v60) {
          goto LABEL_64;
        }
        while (!*v31)
        {
          if (++v31 == v60)
          {
            int v31 = v60;
            break;
          }
        }
        if (v31 == v60)
        {
LABEL_64:
          char v13 = 0;
        }
        else
        {
          char v13 = 0;
          do
          {
            for (uint64_t i = v31 + 1; i != v30; ++i)
            {
              if (!*i) {
                goto LABEL_52;
              }
            }
            uint64_t i = v30;
LABEL_52:
            int v33 = (unsigned char *)(v31 - (unsigned char *)v29);
            __int16 v34 = (unsigned char *)(i - (unsigned char *)v29);
            if ((uint64_t)v33 < i - (unsigned char *)v29)
            {
              do
              {
                uint64_t v35 = 8 * (void)&i[-2 - (void)v29];
                __int16 v36 = (unsigned char *)(i - (unsigned char *)v29);
                if ((uint64_t)(v34 - 1) > (uint64_t)v33)
                {
                  do
                  {
                    int v37 = &v36[(void)v59];
                    unsigned int v38 = v36[(void)v59 - 1];
                    unsigned int v39 = v36[(void)v59 - 2];
                    if (v38 < v39)
                    {
                      *(v37 - 1) = v39;
                      *(v37 - 2) = v38;
                      __int16 v40 = (uint64_t *)(*a3 + v35);
                      uint64_t v41 = *v40;
                      uint64_t *v40 = v40[1];
                      v40[1] = v41;
                      uint64_t v42 = *(void *)a4 + 2 * (void)v36;
                      HIDWORD(v43) = *(_DWORD *)(v42 - 4);
                      LODWORD(v43) = HIDWORD(v43);
                      *(_DWORD *)(v42 - 4) = v43 >> 16;
                      char v13 = 1;
                    }
                    __int16 v44 = v36 - 2;
                    --v36;
                    v35 -= 8;
                  }
                  while ((uint64_t)v44 > (uint64_t)v33);
                }
                ++v33;
              }
              while (v33 != v34);
            }
            if (i == v30) {
              break;
            }
            while (!*i)
            {
              if (++i == v30)
              {
                uint64_t i = v30;
                break;
              }
            }
            int v31 = i;
          }
          while (i != v30);
        }
        if ((unint64_t)v10 >= 7 && (a2 & 1) == 0)
        {
          uint64_t v45 = 0;
          __int16 v46 = *a1;
          uint64_t v47 = 4;
          if (v12 > 4) {
            uint64_t v47 = v10 >> 1;
          }
          uint64_t v48 = v47 - 3;
          int v49 = (char *)v59 + 3;
          uint64_t v50 = 16;
          do
          {
            int v51 = &v46[2 * v45];
            if (*((unsigned __int16 *)v51 + 1) - 1463 <= 1
              && (*((_WORD *)v51 + 2) & 0xFFFB) == 0x5B0
              && (*(_WORD *)&v46[2 * v45 + 6] == 1469 || v49[v45] == 220))
            {
              *(int8x16_t *)(*a3 + v50) = vextq_s8(*(int8x16_t *)(*a3 + v50), *(int8x16_t *)(*a3 + v50), 8uLL);
              uint64_t v52 = *(void *)a4 + 2 * v45;
              HIDWORD(v53) = *(_DWORD *)(v52 + 4);
              LODWORD(v53) = HIDWORD(v53);
              *(_DWORD *)(v52 + 4) = v53 >> 16;
              char v13 = 1;
            }
            ++v45;
            v50 += 8;
          }
          while (v48 != v45);
        }
        goto LABEL_79;
      }
      uint64_t v17 = (a1[1] - *a1) >> 1;
    }
    char v58 = -86;
    char v57 = 0;
    uint64_t v56 = v17;
    v55[0] = (void **)&v56;
    v55[1] = (void **)&v59;
    v55[2] = (void **)&v58;
    v55[3] = (void **)a1;
    v55[4] = (void **)&v57;
    ModifyArabicCombiningClasses(TInlineVector<unsigned short,30ul> const&,TInlineVector&<unsigned char,30ul>)::$_0::operator()((uint64_t)v55, 230, 26);
    ModifyArabicCombiningClasses(TInlineVector<unsigned short,30ul> const&,TInlineVector&<unsigned char,30ul>)::$_0::operator()((uint64_t)v55, 220, 25);
    goto LABEL_39;
  }
  char v13 = 0;
  return v13 & 1;
}

uint64_t ModifyArabicCombiningClasses(TInlineVector<unsigned short,30ul> const&,TInlineVector&<unsigned char,30ul>)::$_0::operator()(uint64_t result, int a2, char a3)
{
  unint64_t v3 = **(void **)result;
  if (v3 >= 2)
  {
    uint64_t v4 = **(void **)(result + 8);
    uint64_t v5 = 1;
    while (*(unsigned __int8 *)(v4 + v5) != a2)
    {
      if (v3 == ++v5) {
        return result;
      }
    }
    int v6 = *(unsigned __int16 *)(**(void **)(result + 24) + 2 * v5);
    BOOL v7 = (v6 - 2250) > 0x29 || ((1 << (v6 + 54)) & 0x2000000023BLL) == 0;
    if (!v7
      || ((v6 - 1756) <= 0xC ? (BOOL v8 = ((1 << (v6 + 36)) & 0x1881) == 0) : (BOOL v8 = 1),
          !v8 || ((v9 = v6 - 1620, BOOL v10 = v9 > 4, v11 = (1 << v9) & 0x13, !v10) ? (v12 = v11 == 0) : (v12 = 1), !v12)))
    {
      *(unsigned char *)(v4 + v5) = a3;
      **(unsigned char **)(result + 32) = 1;
      for (unint64_t i = v5 + 1; i < **(void **)result; *(unsigned char *)(v14 + i++) = a3)
      {
        uint64_t v14 = **(void **)(result + 8);
        if (*(unsigned __int8 *)(v14 + i) != a2) {
          break;
        }
        int v15 = *(unsigned __int16 *)(**(void **)(result + 24) + 2 * i);
        if (((v15 - 2250) > 0x29 || ((1 << (v15 + 54)) & 0x2000000023BLL) == 0)
          && ((v15 - 1756) > 0xC || ((1 << (v15 + 36)) & 0x1881) == 0))
        {
          unsigned int v18 = v15 - 1620;
          BOOL v10 = v18 > 4;
          int v19 = (1 << v18) & 0x13;
          if (v10 || v19 == 0) {
            break;
          }
        }
      }
    }
  }
  return result;
}

BOOL OTL::GCommon::HasFeature(OTL::GCommon *this, unsigned int a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  __dst[0] = a2;
  __dst[1] = 0;
  *(void *)&long long v2 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v7[8] = v2;
  v7[7] = v2;
  v7[6] = v2;
  _OWORD v7[5] = v2;
  v7[4] = v2;
  v7[3] = v2;
  id v7[2] = v2;
  v7[1] = v2;
  v7[0] = v2;
  memset(v6, 0, sizeof(v6));
  BOOL v8 = v7;
  BOOL v3 = 0;
  if (OTL::GCommon::GetFeatures(this, (OTL::FeatureList *)v6)) {
    BOOL v3 = OTL::FeatureList::StripMissingFeaturesFrom(v6, __dst);
  }
  uint64_t v5 = v6;
  std::vector<unsigned int,TInlineBufferAllocator<unsigned int,36ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v5);
  return v3;
}

char *std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  BOOL v7 = result;
  unint64_t v8 = *((void *)result + 2);
  unsigned int v9 = *(char **)result;
  unint64_t v10 = (uint64_t)(v8 - *(void *)result) >> 1;
  if (v10 < a4)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      if (result + 24 <= v9 && result + 84 > v9)
      {
        if (&v9[2 * v10] == *((char **)result + 11)) {
          *((void *)result + 11) = v9;
        }
      }
      else
      {
        operator delete(v9);
      }
      unint64_t v8 = 0;
      void *v7 = 0;
      v7[1] = 0;
      id v7[2] = 0;
    }
    if ((a4 & 0x8000000000000000) != 0) {
      abort();
    }
    if (v8 <= a4) {
      unint64_t v19 = a4;
    }
    else {
      unint64_t v19 = v8;
    }
    if (v8 >= 0x7FFFFFFFFFFFFFFELL) {
      uint64_t v20 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v20 = v19;
    }
    uint64_t result = std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__vallocate[abi:nn180100](v7, v20);
    uint64_t v21 = (char *)v7[1];
    char v13 = (void **)(v7 + 1);
    unsigned int v9 = v21;
LABEL_24:
    size_t v16 = a3 - (void)__src;
    if (v16)
    {
      uint64_t v17 = v9;
      unsigned int v18 = __src;
      goto LABEL_26;
    }
    goto LABEL_27;
  }
  char v13 = (void **)(result + 8);
  BOOL v12 = (unsigned char *)*((void *)result + 1);
  unint64_t v14 = (v12 - v9) >> 1;
  if (v14 >= a4) {
    goto LABEL_24;
  }
  int v15 = &__src[2 * v14];
  if (v12 != v9)
  {
    uint64_t result = (char *)memmove(*(void **)result, __src, 2 * v14);
    unsigned int v9 = (char *)*v13;
  }
  size_t v16 = a3 - (void)v15;
  if (v16)
  {
    uint64_t v17 = v9;
    unsigned int v18 = v15;
LABEL_26:
    uint64_t result = (char *)memmove(v17, v18, v16);
  }
LABEL_27:
  *char v13 = &v9[v16];
  return result;
}

uint64_t TCharComposer::ComposeChars(uint64_t a1, unint64_t a2, uint64_t a3, int a4)
{
  if (a4) {
    unorm2_getNFDInstance();
  }
  else {
    unorm2_getNFCInstance();
  }
  if (unorm2_isNormalized()) {
    return 0;
  }
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::resize(a3, a2);
  int v7 = unorm2_normalize();
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::resize(a3, v7);
  return 1;
}

uint64_t TGlyphComposer::ComposeGlyphs(TLine **a1, uint64_t a2, uint64_t a3, char **a4)
{
  uint64_t v6 = a2;
  v228[2] = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *(void *)(*(void *)(*((void *)*a1 + 2) + 8 * TLine::FindRunWithCharIndex(*a1, a2, 1)) + 48);
  int v9 = *(unsigned __int8 *)(v8 + 224);
  uint64_t v10 = *(void *)(v8 + 8);
  uint64_t v11 = *(void *)(v8 + 16);
  uint64_t GlyphIndexForChar = TRun::GetGlyphIndexForCharIndex<false>(v8, v6);
  [*(id *)(v8 + 216) setProps:*(_DWORD *)(*(void *)(*(void *)(v8 + 216) + 40) + 4 * *(void *)(v8 + 200) + 4 * GlyphIndexForChar) & 0xFFFFFFF6 | 8 atIndex:*(void *)(v8 + 200) + GlyphIndexForChar];
  uint64_t v12 = *(void *)(atomic_load_explicit((atomic_ullong *volatile)(v8 + 56), memory_order_acquire) + 40);
  GlyphCFIndex Count = TBaseFont::GetGlyphCount(*(TBaseFont **)(v12 + 400));
  uint64_t v13 = *(void *)(a3 + 8);
  v219 = *(_WORD **)a3;
  if (((*(uint64_t (**)(void))(**(void **)(v12 + 400) + 712))() & 1) != 0
    || ((*(uint64_t (**)(void))(**(void **)(v12 + 400) + 688))(*(void *)(v12 + 400)) & 1) != 0)
  {
LABEL_3:
    char v14 = 0;
    return v14 & 1;
  }
  uint64_t v16 = v11 + v10;
  uint64_t v17 = v13 - (void)v219;
  unint64_t v18 = 1;
  if ((*v219 & 0xFC00) == 0xD800 && v17 != 2)
  {
    if ((v219[1] & 0xFC00) == 0xDC00) {
      unint64_t v18 = 2;
    }
    else {
      unint64_t v18 = 1;
    }
  }
  unint64_t __n = v17 >> 1;
  if (*(unsigned char *)(v8 + 90))
  {
    unint64_t v19 = *a4;
    uint64_t v20 = a4[1];
    uint64_t v21 = *a4;
    if (*a4 != v20)
    {
      while (*(void *)v21 != v6)
      {
        v21 += 8;
        if (v21 == v20)
        {
          uint64_t v21 = a4[1];
          break;
        }
      }
    }
    if (v21 == v20) {
      goto LABEL_3;
    }
    uint64_t v22 = TRun::GetGlyphIndexForCharIndex<false>(v8, v6);
    uint64_t v23 = *(void *)(v8 + 216);
    uint64_t v24 = *(void *)(v23 + 32);
    if (v24 || (uint64_t v36 = *(void *)(v23 + 24)) == 0) {
      int v25 = (double *)(v24 + 16 * *(void *)(v8 + 200) + 16 * v22);
    }
    else {
      int v25 = (double *)(v36 + 8 * *(void *)(v8 + 200) + 8 * v22);
    }
    char v14 = 0;
    double v37 = -*v25;
    unsigned int v38 = (CGSize *)MEMORY[0x1E4F1DB30];
    unsigned int v39 = (double *)MEMORY[0x1E4F1DAD8];
    while (1)
    {
      __p[0] = (void *)TRun::GetGlyphIndexForCharIndex<false>(v8, v6);
      uint64_t NextChar = TRun::GetNextChar((TRun *)v8, v6, (uint64_t *)__p);
      uint64_t v6 = NextChar;
      uint64_t v41 = v20;
      if (v21 != v20)
      {
        while (*(void *)v21 != NextChar)
        {
          v21 += 8;
          if (v21 == v20)
          {
            uint64_t v41 = v20;
            goto LABEL_48;
          }
        }
        uint64_t v41 = v21;
      }
LABEL_48:
      if (v41 == v20) {
        return v14 & 1;
      }
      UChar32 v42 = *(unsigned __int16 *)((char *)v219 + ((v41 - v19) >> 2));
      if ((v42 & 0xF800) == 0xD800)
      {
        uint64_t v43 = (v41 - v19) >> 3;
        if ((v42 & 0x400) != 0)
        {
          if (v41 == v19) {
            goto LABEL_58;
          }
          int v48 = (unsigned __int16)v219[v43 - 1];
          BOOL v46 = (v48 & 0xFC00) == 55296;
          int v47 = v42 + (v48 << 10);
        }
        else
        {
          uint64_t v44 = v43 + 1;
          if (v44 == __n) {
            goto LABEL_58;
          }
          int v45 = (unsigned __int16)v219[v44];
          BOOL v46 = (v45 & 0xFC00) == 56320;
          int v47 = v45 + (v42 << 10);
        }
        UChar32 v49 = v47 - 56613888;
        if (v46) {
          UChar32 v42 = v49;
        }
      }
LABEL_58:
      if (u_charType(v42) != 7) {
        return v14 & 1;
      }
      if (v16 <= v6)
      {
        while (1)
        {
          uint64_t v8 = *(void *)(v8 + 24);
          if (!v8) {
            return v14 & 1;
          }
          uint64_t v16 = *(void *)(v8 + 16) + *(void *)(v8 + 8);
          if (v16 > v6)
          {
            if (!*(unsigned char *)(v8 + 90)) {
              return v14 & 1;
            }
            break;
          }
        }
      }
      uint64_t v50 = TRun::GetGlyphIndexForCharIndex<false>(v8, v6);
      TStorageRange::SetAdvance((TStorageRange *)(v8 + 192), v50, *v38);
      objc_msgSend(*(id *)(v8 + 216), "setOrigin:atIndex:", *(void *)(v8 + 200) + v50, v37, 0.0);
      if (*v39 == v37)
      {
        char v14 = 1;
        uint64_t v21 = v41;
        if (v39[1] == 0.0) {
          continue;
        }
      }
      *(unsigned char *)(v8 + 225) |= 0x10u;
      char v14 = 1;
      uint64_t v21 = v41;
    }
  }
  *(_OWORD *)v221 = 0u;
  *(_OWORD *)v222 = 0u;
  unint64_t v223 = 0xAAAAAAAA3F800000;
  std::__hash_table<std::__hash_value_type<TRun const*,long>,std::__unordered_map_hasher<TRun const*,std::__hash_value_type<TRun const*,long>,std::hash<TRun const*>,std::equal_to<TRun const*>,true>,std::__unordered_map_equal<TRun const*,std::__hash_value_type<TRun const*,long>,std::equal_to<TRun const*>,std::hash<TRun const*>,true>,std::allocator<std::__hash_value_type<TRun const*,long>>>::__rehash<true>((uint64_t)v221, __n);
  size_t v26 = __n;
  int v210 = v9;
  if (v18 < __n)
  {
    while (1)
    {
      unint64_t v27 = v18++;
      unsigned int v28 = (unsigned __int16)v219[v27];
      if (v18 != v26 && (v28 & 0xFC00) == 0xD800)
      {
        int v29 = (unsigned __int16)v219[v18];
        BOOL v30 = (v29 & 0xFC00) == 56320;
        unsigned int v31 = (v28 << 10) - 56613888 + v29;
        unint64_t v18 = v30 ? v27 + 2 : v27 + 1;
        if (v30) {
          unsigned int v28 = v31;
        }
      }
      if (u_hasBinaryProperty(v28, UCHAR_DEFAULT_IGNORABLE_CODE_POINT)) {
        break;
      }
      if (v28 >= 0x590)
      {
        if (v28 < 0x700) {
          break;
        }
        int v32 = ScriptCodeForLongCharacter(v28);
        if (v32)
        {
          uint64_t v33 = 0;
          while (IsPossiblyAcceptable(UScriptCode)::kExcludedScripts[v33] != v32)
          {
            if (++v33 == 8)
            {
              __int16 v34 = (int *)&unk_184BA1C74;
              goto LABEL_36;
            }
          }
          __int16 v34 = &IsPossiblyAcceptable(UScriptCode)::kExcludedScripts[v33];
LABEL_36:
          if ((char *)v34 - (char *)IsPossiblyAcceptable(UScriptCode)::kExcludedScripts != 32) {
            break;
          }
          unsigned int v35 = ScriptTagForScriptCode(v32);
          FirstBlockForScript(0, v35, (uint64_t)__p);
          if (__p[0]) {
            break;
          }
        }
      }
      __p[0] = *(void **)&(*a4)[8 * v27];
      *(_OWORD *)(std::__hash_table<std::__hash_value_type<long,CGPoint>,std::__unordered_map_hasher<long,std::__hash_value_type<long,CGPoint>,std::hash<long>,std::equal_to<long>,true>,std::__unordered_map_equal<long,std::__hash_value_type<long,CGPoint>,std::equal_to<long>,std::hash<long>,true>,std::allocator<std::__hash_value_type<long,CGPoint>>>::__emplace_unique_key_args<long,std::piecewise_construct_t const&,std::tuple<long const&>,std::tuple<>>((uint64_t)v221, (unint64_t)__p[0], (uint64_t *)__p)+ 3) = *MEMORY[0x1E4F1DAD8];
      size_t v26 = __n;
      if (v18 >= __n) {
        goto LABEL_67;
      }
    }
    size_t v26 = v27;
  }
LABEL_67:
  if (!v222[1]
    || (size_t __na = v26,
        uint64_t v51 = TRun::GetGlyphIndexForCharIndex<false>(v8, v6),
        uint64_t v52 = *(void **)(v8 + 216),
        uint64_t v53 = *(void *)(v8 + 200),
        (*(_DWORD *)(v52[5] + 4 * v53 + 4 * v51) & 0x380) != 0))
  {
    char v14 = 0;
    goto LABEL_267;
  }
  int v54 = *(unsigned __int16 *)(v52[2] + 2 * v53 + 2 * v51);
  if ((*(unsigned char *)(v8 + 225) & 0x10) != 0)
  {
    [v52 originAtIndex:v53 + v51];
    double v56 = v57;
    double v55 = v58;
  }
  else
  {
    double v56 = *MEMORY[0x1E4F1DAD8];
    double v55 = *(double *)(MEMORY[0x1E4F1DAD8] + 8);
  }
  LOWORD(v225.a) = v54;
  *(void *)&long long v59 = -1;
  *((void *)&v59 + 1) = -1;
  *(_OWORD *)id __p = v59;
  *(_OWORD *)v227 = v59;
  double BoundingBoxesForGlyphs = TFont::GetBoundingBoxesForGlyphs((TFont *)v12, (const unsigned __int16 *)&v225, (CGRect *)__p, 1, kCTFontOrientationDefault);
  double v64 = v63;
  uint64_t v65 = *(void *)(v8 + 216);
  uint64_t v66 = *(void *)(v65 + 32);
  if (v66 || (uint64_t v69 = *(void *)(v65 + 24)) == 0)
  {
    int v67 = (double *)(v66 + 16 * *(void *)(v8 + 200) + 16 * v51);
    double v68 = v67[1];
  }
  else
  {
    int v67 = (double *)(v69 + 8 * *(void *)(v8 + 200) + 8 * v51);
    double v68 = 0.0;
  }
  double x = v56 + BoundingBoxesForGlyphs;
  double y = v55 + v61;
  double v71 = *MEMORY[0x1E4F1DAD8];
  double v70 = *(double *)(MEMORY[0x1E4F1DAD8] + 8);
  double v214 = *v67;
  if (v62 == 0.0) {
    double width = *v67;
  }
  else {
    double width = v62;
  }
  __p[0] = (void *)TRun::GetGlyphIndexForCharIndex<false>(v8, v6);
  uint64_t v220 = TRun::GetNextChar((TRun *)v8, v6, (uint64_t *)__p);
  uint64_t v73 = v18 + v6;
  double BoundingBoxForGlyph = NAN;
  *(double *)&uint64_t v75 = NAN;
  if ((int64_t)(v18 + v6) >= *((void *)*a1 + 10) + *((void *)*a1 + 9))
  {
    char v205 = 1;
    double v199 = NAN;
    CGFloat v200 = NAN;
  }
  else
  {
    uint64_t v76 = v8;
    size_t v77 = __na;
    while (1)
    {
      uint64_t v78 = *(void *)(v76 + 8);
      if (v78 <= v73 && *(void *)(v76 + 16) + v78 > v73) {
        break;
      }
      uint64_t v76 = *(void *)(v76 + 24);
      if (!v76) {
        goto LABEL_99;
      }
    }
    if (v8 != v76)
    {
      if (*(unsigned __int8 *)(v8 + 224) != *(unsigned __int8 *)(v76 + 224)
        || (*(unsigned char *)(v8 + 90) != 0) != (*(unsigned char *)(v76 + 90) != 0))
      {
        goto LABEL_99;
      }
      uint64_t v80 = *(void *)(v8 + 160);
      double v81 = 0.0;
      double v82 = 0.0;
      if (v80) {
        double v82 = *(double *)(v80 + 48);
      }
      uint64_t v83 = *(void *)(v76 + 160);
      if (v83) {
        double v81 = *(double *)(v83 + 48);
      }
      if (v82 != v81)
      {
LABEL_99:
        char v205 = 1;
        double v199 = NAN;
        CGFloat v200 = NAN;
        goto LABEL_100;
      }
    }
    uint64_t v192 = TRun::GetGlyphIndexForCharIndex<false>(v76, v73);
    v193 = *(TFont **)(atomic_load_explicit((atomic_ullong *volatile)(v76 + 56), memory_order_acquire) + 40);
    int v194 = *(unsigned __int16 *)(*(void *)(*(void *)(v76 + 216) + 16) + 2 * *(void *)(v76 + 200) + 2 * v192);
    if (v193 == (TFont *)v12 && v194 == v54)
    {
      char v205 = 0;
      *(double *)&uint64_t v75 = v64;
      double v199 = y;
      CGFloat v200 = width;
      double BoundingBoxForGlyph = x;
    }
    else
    {
      double BoundingBoxForGlyph = TFont::GetBoundingBoxForGlyph(v193, v194);
      double v199 = v196;
      CGFloat v200 = v197;
      char v205 = 0;
    }
  }
  size_t v77 = __na;
LABEL_100:
  unint64_t v84 = 1;
  CGFloat v201 = *(double *)&v75;
  CGFloat v202 = BoundingBoxForGlyph;
  double rect = v64;
  if (v77 != 1 && (*v219 & 0xFC00) == 0xD800)
  {
    if ((v219[1] & 0xFC00) == 0xDC00) {
      unint64_t v84 = 2;
    }
    else {
      unint64_t v84 = 1;
    }
  }
  *(void *)&long long v85 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v85 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v227[57] = v85;
  *(_OWORD *)&v227[59] = v85;
  *(_OWORD *)&v227[53] = v85;
  *(_OWORD *)&v227[55] = v85;
  *(_OWORD *)&v227[49] = v85;
  *(_OWORD *)&v227[51] = v85;
  *(_OWORD *)&v227[45] = v85;
  *(_OWORD *)&v227[47] = v85;
  *(_OWORD *)&v227[41] = v85;
  *(_OWORD *)&v227[43] = v85;
  *(_OWORD *)&v227[37] = v85;
  *(_OWORD *)&v227[39] = v85;
  *(_OWORD *)&v227[33] = v85;
  *(_OWORD *)&v227[35] = v85;
  *(_OWORD *)&v227[31] = v85;
  *(_OWORD *)&v227[29] = v85;
  *(_OWORD *)&v227[27] = v85;
  *(_OWORD *)&v227[25] = v85;
  *(_OWORD *)&v227[23] = v85;
  *(_OWORD *)&v227[21] = v85;
  *(_OWORD *)&v227[19] = v85;
  *(_OWORD *)&v227[17] = v85;
  *(_OWORD *)&v227[15] = v85;
  *(_OWORD *)&v227[13] = v85;
  *(_OWORD *)&v227[11] = v85;
  *(_OWORD *)&v227[9] = v85;
  *(_OWORD *)&v227[7] = v85;
  *(_OWORD *)&v227[5] = v85;
  *(_OWORD *)&v227[3] = v85;
  *(_OWORD *)&v227[1] = v85;
  __p[0] = 0;
  __p[1] = 0;
  double v86 = 0.0;
  v227[0] = 0;
  v228[0] = &v227[1];
  if (v84 >= v77) {
    goto LABEL_227;
  }
  uint64_t v87 = v8;
  double v198 = v56;
  double v203 = v55;
  while (1)
  {
    UChar32 v88 = (unsigned __int16)v219[v84];
    if (v84 + 1 == v77 || (v88 & 0xFC00) != 0xD800)
    {
      ++v84;
    }
    else
    {
      int v89 = (unsigned __int16)v219[v84 + 1];
      BOOL v90 = (v89 & 0xFC00) == 56320;
      int v91 = v89 + (v88 << 10) - 56613888;
      if (v90) {
        v84 += 2;
      }
      else {
        ++v84;
      }
      if (v90) {
        UChar32 v88 = v91;
      }
    }
    uint64_t v92 = v220;
    if (v16 <= v220) {
      break;
    }
LABEL_124:
    uint64_t v95 = TRun::GetGlyphIndexForCharIndex<false>(v87, v92);
    if (GlyphCount > *(unsigned __int16 *)(*(void *)(*(void *)(v87 + 216) + 16)
                                          + 2 * *(void *)(v87 + 200)
                                          + 2 * v95))
    {
      uint64_t v96 = v95;
      unsigned __int16 v224 = *(_WORD *)(*(void *)(*(void *)(v87 + 216) + 16) + 2 * *(void *)(v87 + 200) + 2 * v95);
      *(void *)&long long v97 = -1;
      *((void *)&v97 + 1) = -1;
      *(_OWORD *)&v225.a = v97;
      *(_OWORD *)&v225.c = v97;
      double v206 = TFont::GetBoundingBoxesForGlyphs((TFont *)v12, &v224, (CGRect *)&v225, 1, kCTFontOrientationDefault);
      double v99 = v98;
      double v101 = v100;
      CGFloat v209 = v102;
      unsigned int CombiningClass = u_getCombiningClass(v88);
      double v204 = v68;
      CGFloat r1 = v101;
      CGFloat v208 = width;
      if (CombiningClass)
      {
        if (CombiningClass >= 0x85)
        {
          if (CombiningClass == 240) {
            unsigned __int8 v106 = -36;
          }
          else {
            unsigned __int8 v106 = CombiningClass;
          }
        }
        else
        {
          unsigned __int8 v106 = TGlyphComposer::GetResolvedCombiningClass::kCombiningClassResolveTable[CombiningClass];
          if (!v106) {
            goto LABEL_128;
          }
        }
        if ((v106 + 23) <= 1u)
        {
          if ((v205 & 1) == 0)
          {
            v230.size.double width = width;
            v230.origin.double x = x;
            double v113 = y;
            v230.origin.double y = y;
            v230.size.height = rect;
            double MaxY = CGRectGetMaxY(v230);
            v231.size.height = v201;
            v231.origin.double x = v202;
            v231.size.double width = v200;
            v231.origin.double y = v199;
            double v115 = CGRectGetMaxY(v231);
            if (MaxY >= v115) {
              double v115 = MaxY;
            }
            if (v199 < y) {
              double v113 = v199;
            }
            double y = v113;
            double rect = v115 - v113;
          }
          v225.a = NAN;
          TAttributes::GetKernSetting((TAttributes *)(v8 + 40), &v225.a, 0);
          double v116 = v214;
          double v117 = v214 + v225.a * 0.5;
          int v112 = 1;
LABEL_149:
          double v214 = v116;
          if (v106 >= 0xDAu)
          {
            if (v106 == 224 || v106 == 226) {
              goto LABEL_157;
            }
            uint64_t v118 = *(void *)(v12 + 400);
            TFont::GetScaledMatrix((TFont *)v12, &v225);
            double v119 = (*(double (**)(uint64_t, CGAffineTransform *))(*(void *)v118 + 608))(v118, &v225);
            double v120 = v119;
            inited = (int *)(v12 + 48);
            if (!*(_DWORD *)(v12 + 48))
            {
              double v122 = v117;
              double v123 = v119;
              inited = TFont::InitStrikeMetrics((TFont *)v12);
              double v120 = v123;
              double v117 = v122;
            }
            double v124 = *((double *)inited + 4);
            if (v120 == 0.0
              || (v232.origin.double x = x,
                  v232.origin.double y = y,
                  v232.size.double width = v208,
                  v232.size.height = rect,
                  CGRectGetMaxY(v232) >= v124))
            {
              if (v124 == 0.0 && !*(_DWORD *)(v12 + 48)) {
                TFont::InitStrikeMetrics((TFont *)v12);
              }
            }
            if (v112)
            {
              if (v117 >= 0.0) {
                double v160 = v117;
              }
              else {
                double v160 = 0.0;
              }
              double v161 = v160 - v117;
              if (v106 == 234) {
                uint64_t v162 = 1;
              }
              else {
                uint64_t v162 = 2;
              }
              double v163 = y;
              double v164 = rect;
              double v134 = v206;
              v241.origin.double x = v206;
              v241.origin.double y = v99;
              v241.size.height = v209;
              v241.size.double width = v101 * 0.5;
              TGlyphComposer::PositionBaseOtherTopCenteringGap((TGlyphComposer *)4, *(CGRect *)(&v160 - 2), v241, v162, v104, v105);
              double v136 = v165;
              double v138 = v166;
              unsigned int v125 = 2;
              uint64_t v109 = v96;
              uint64_t v126 = (TStorageRange *)(v87 + 192);
LABEL_178:
              if (v86 < v136) {
                double v86 = v136;
              }
              char v139 = (double *)std::__hash_table<std::__hash_value_type<long,CGPoint>,std::__unordered_map_hasher<long,std::__hash_value_type<long,CGPoint>,std::hash<long>,std::equal_to<long>,true>,std::__unordered_map_equal<long,std::__hash_value_type<long,CGPoint>,std::equal_to<long>,std::hash<long>,true>,std::allocator<std::__hash_value_type<long,CGPoint>>>::__emplace_unique_key_args<long,std::piecewise_construct_t const&,std::tuple<long const&>,std::tuple<>>((uint64_t)v221, v220, &v220);
              v139[3] = v136;
              v139[4] = v138;
              TStorageRange::SetAdvance(v126, v109, *MEMORY[0x1E4F1DB30]);
              TRun::NoteCrossStreamPosition((TRun *)v87, v138);
              double v140 = v134 + v136;
              double v141 = v99 + v138;
              if (v125 == 1)
              {
                v233.origin.double x = v140;
                v233.origin.double y = v99 + v138;
                v233.size.double width = r1;
                v233.size.height = v209;
                double MaxX = CGRectGetMaxX(v233);
                v234.origin.double x = x;
                v234.origin.double y = y;
                v234.size.double width = v208;
                v234.size.height = rect;
                double v143 = MaxX - CGRectGetMaxX(v234);
                if (v143 < 0.0) {
                  double v143 = 0.0;
                }
                double v144 = v214 + v143;
                v235.origin.double x = v140;
                v235.origin.double y = v99 + v138;
                v235.size.double width = r1;
                v235.size.height = v209;
                double v145 = v71 + CGRectGetMinX(v235);
                double v56 = v198;
                if (v145 >= 0.0)
                {
                  double v214 = v144;
                }
                else
                {
                  double v214 = v144 - v145;
                  double v71 = v71 - v145;
                }
                double v68 = v204;
              }
              else
              {
                double v56 = v198;
                double v68 = v204;
              }
              goto LABEL_188;
            }
            if (v106 > 0xDFu) {
LABEL_157:
            }
              v106 -= 16;
            else {
              v106 -= 18;
            }
          }
          unsigned int v125 = v106;
          if (v106 == 1)
          {
            uint64_t v128 = 2;
            uint64_t v127 = 3;
            double v129 = x;
            double v130 = v208;
            uint64_t v109 = v96;
          }
          else
          {
            uint64_t v109 = v96;
            if (v125 != 210)
            {
              uint64_t v126 = (TStorageRange *)(v87 + 192);
              if (v125 == 208)
              {
                uint64_t v127 = 0;
                uint64_t v128 = 0;
                goto LABEL_176;
              }
              unsigned __int8 v131 = v125 - 12;
              if (v125 >= 0xD0) {
                uint64_t v127 = 1;
              }
              else {
                uint64_t v127 = 2;
              }
              if (v125 < 0xD0) {
                unsigned __int8 v131 = v125;
              }
              uint64_t v128 = v131 - 200;
              if (v131 == 202)
              {
                unsigned int v125 = 2;
                uint64_t v128 = 2;
                double v129 = x;
                if (v117 > 0.0) {
                  double v129 = 0.0;
                }
                double v130 = v208;
                if (v117 > 0.0) {
                  double v130 = v117;
                }
              }
              else
              {
LABEL_176:
                unsigned int v125 = 1;
                double v129 = x;
                double v130 = v208;
              }
LABEL_177:
              double v132 = y;
              double v133 = rect;
              double v134 = v206;
              v239.origin.double x = v206;
              v239.origin.double y = v99;
              v239.size.double width = v101;
              v239.size.height = v209;
              TGlyphComposer::PositionBaseOtherTopCenteringGap((TGlyphComposer *)v128, *(CGRect *)&v129, v239, v127, v104, v105);
              double v136 = v135;
              double v138 = v137;
              goto LABEL_178;
            }
            uint64_t v127 = 0;
            uint64_t v128 = 4;
            unsigned int v125 = 1;
            double v129 = x;
            double v130 = v208;
          }
          uint64_t v126 = (TStorageRange *)(v87 + 192);
          goto LABEL_177;
        }
        int v112 = 0;
      }
      else
      {
        if ((v88 - 8413) > 7 || v88 == 8417)
        {
LABEL_128:
          if (u_getIntPropertyValue(v88, UCHAR_GRAPHEME_CLUSTER_BREAK) != 10)
          {
            uint64_t v109 = v96;
            if (CFUniCharIsMemberOf())
            {
              unsigned int v125 = 1;
              double v136 = x;
              double v138 = y;
            }
            else
            {
              v238.origin.double x = x;
              v238.origin.double y = y;
              v238.size.double width = width;
              v238.size.height = rect;
              double v136 = CGRectGetMaxX(v238);
              double v138 = 0.0;
              unsigned int v125 = 1;
            }
            uint64_t v126 = (TStorageRange *)(v87 + 192);
            double v134 = v206;
            goto LABEL_178;
          }
          if (v86 < v214 + *MEMORY[0x1E4F1DAD8]) {
            double v86 = v214 + *MEMORY[0x1E4F1DAD8];
          }
          uint64_t v107 = *(void *)(v87 + 216);
          uint64_t v108 = *(void *)(v107 + 32);
          uint64_t v109 = v96;
          if (v108 || (uint64_t v167 = *(void *)(v107 + 24)) == 0)
          {
            id v110 = (double *)(v108 + 16 * *(void *)(v87 + 200) + 16 * v96);
            double v111 = v110[1];
          }
          else
          {
            id v110 = (double *)(v167 + 8 * *(void *)(v87 + 200) + 8 * v96);
            double v111 = 0.0;
          }
          uint64_t v126 = (TStorageRange *)(v87 + 192);
          double v140 = v214 + v206;
          double v141 = v68 + v99;
          double v214 = v214 + *v110;
          double v68 = v68 + v111;
LABEL_188:
          unint64_t v146 = v84;
          v236.origin.double x = v140;
          v236.origin.double y = v141;
          v236.size.double width = r1;
          v240.size.double width = v208;
          v236.size.height = v209;
          v240.origin.double x = x;
          v240.origin.double y = y;
          v240.size.height = rect;
          CGRect v237 = CGRectUnion(v236, v240);
          double x = v237.origin.x;
          double y = v237.origin.y;
          double width = v237.size.width;
          double rect = v237.size.height;
          uint64_t v147 = __p[1];
          if (__p[1] >= (void *)v227[0])
          {
            int64_t v149 = ((char *)__p[1] - (char *)__p[0]) >> 4;
            unint64_t v150 = v149 + 1;
            double v55 = v203;
            if ((unint64_t)(v149 + 1) >> 60) {
              abort();
            }
            int64_t v151 = v227[0] - (unint64_t)__p[0];
            if ((uint64_t)(v227[0] - (unint64_t)__p[0]) >> 3 > v150) {
              unint64_t v150 = v151 >> 3;
            }
            if ((unint64_t)v151 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v152 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v152 = v150;
            }
            *(void *)&v225.tdouble x = &v227[1];
            uint64_t v153 = TInlineBufferAllocator<CGPoint,30ul>::allocate((uint64_t)&v227[1], v152);
            unsigned int v154 = (TStorageRange **)&v153[16 * v149];
            *unsigned int v154 = v126;
            v154[1] = (TStorageRange *)v109;
            char v156 = (char *)__p[0];
            uint64_t v155 = (char *)__p[1];
            if (__p[1] == __p[0])
            {
              int64x2_t v158 = vdupq_n_s64((unint64_t)__p[1]);
              v157 = &v153[16 * v149];
            }
            else
            {
              v157 = &v153[16 * v149];
              do
              {
                *((_OWORD *)v157 - 1) = *((_OWORD *)v155 - 1);
                v157 -= 16;
                v155 -= 16;
              }
              while (v155 != v156);
              int64x2_t v158 = *(int64x2_t *)__p;
            }
            uint64_t v148 = v154 + 2;
            __p[0] = v157;
            __p[1] = v154 + 2;
            *(int64x2_t *)&v225.b = v158;
            CGFloat v159 = *(double *)v227;
            v227[0] = &v153[16 * v152];
            v225.d = v159;
            *(void *)&v225.a = v158.i64[0];
            std::__split_buffer<std::tuple<unsigned short,unsigned short,long>,TInlineBufferAllocator<std::tuple<unsigned short,unsigned short,long>,30ul> &>::~__split_buffer((uint64_t)&v225);
          }
          else
          {
            *(void *)__p[1] = v126;
            v147[1] = v109;
            uint64_t v148 = v147 + 2;
            double v55 = v203;
          }
          __p[1] = v148;
          unint64_t v84 = v146;
          goto LABEL_203;
        }
        int v112 = 0;
        unsigned __int8 v106 = 1;
      }
      double v116 = v214;
      double v117 = v214;
      goto LABEL_149;
    }
LABEL_203:
    uint64_t v6 = v220;
    *(void *)&v225.a = TRun::GetGlyphIndexForCharIndex<false>(v87, v220);
    uint64_t v220 = TRun::GetNextChar((TRun *)v87, v6, (uint64_t *)&v225);
    size_t v77 = __na;
    if (v84 >= __na) {
      goto LABEL_227;
    }
  }
  while (1)
  {
    uint64_t v87 = *(void *)(v87 + 24);
    if (!v87) {
      break;
    }
    uint64_t v16 = *(void *)(v87 + 16) + *(void *)(v87 + 8);
    uint64_t v12 = *(void *)(atomic_load_explicit((atomic_ullong *volatile)(v87 + 56), memory_order_acquire) + 40);
    uint64_t v93 = TBaseFont::GetGlyphCount(*(TBaseFont **)(v12 + 400));
    uint64_t v94 = v220;
    if (v16 > v220)
    {
      GlyphCFIndex Count = v93;
      if (((*(uint64_t (**)(void))(**(void **)(v12 + 400) + 712))(*(void *)(v12 + 400)) & 1) == 0
        && ((*(uint64_t (**)(void))(**(void **)(v12 + 400) + 688))(*(void *)(v12 + 400)) & 1) == 0
        && *(unsigned __int8 *)(v87 + 224) == v210
        && !*(unsigned char *)(v87 + 90))
      {
        uint64_t v92 = *(void *)(*(void *)(*(void *)(v87 + 216) + 48)
                        + 8 * *(void *)(v87 + 200)
                        + 8 * TRun::GetGlyphIndexForCharIndex<false>(v87, v94));
        uint64_t v220 = v92;
        goto LABEL_124;
      }
      break;
    }
  }
LABEL_227:
  v168 = __p[0];
  v169 = __p[1];
  v170 = (char *)__p[1] - 16;
  if (__p[0] != __p[1] && v170 > __p[0])
  {
    char v172 = v210;
    double v173 = v214;
    do
    {
      uint64_t v174 = *v168;
      void *v168 = *v170;
      void *v170 = v174;
      uint64_t v175 = v168[1];
      v168[1] = v170[1];
      v170[1] = v175;
      v168 += 2;
      v170 -= 2;
    }
    while (v168 < v170);
    v168 = __p[0];
    v169 = __p[1];
  }
  else
  {
    char v172 = v210;
    double v173 = v214;
  }
  if (v168 != v169)
  {
    char v176 = 1;
    do
    {
      if ((v176 & 1) == 0) {
        [*(id *)(*v168 + 24) setProps:*(_DWORD *)(*(void *)(*(void *)(*v168 + 24) + 40) + 4 * *(void *)(*v168 + 8) + 4 * v168[1]) | 8u atIndex:*(void *)(*v168 + 8) + v168[1]];
      }
      char v176 = 0;
      v168 += 2;
    }
    while (v168 != v169);
  }
  if (v173 >= v86 || v6 != *((void *)*a1 + 9) + *((void *)*a1 + 10) - 1) {
    double v86 = v173;
  }
  v229.double width = v86;
  v229.height = v68;
  TStorageRange::SetAdvance((TStorageRange *)(v8 + 192), GlyphIndexForChar, v229);
  double v178 = v55 + v70;
  objc_msgSend(*(id *)(v8 + 216), "setOrigin:atIndex:", *(void *)(v8 + 200) + GlyphIndexForChar, v56 + v71, v178);
  v179 = (double *)MEMORY[0x1E4F1DAD8];
  if (v56 + v71 != *MEMORY[0x1E4F1DAD8] || v178 != *(double *)(MEMORY[0x1E4F1DAD8] + 8)) {
    *(unsigned char *)(v8 + 225) |= 0x10u;
  }
  if (v172) {
    double v181 = *MEMORY[0x1E4F1DB30];
  }
  else {
    double v181 = v86;
  }
  if (v172) {
    double v68 = *(double *)(MEMORY[0x1E4F1DB30] + 8);
  }
  long long v182 = (double *)v222[0];
  if (v222[0])
  {
    do
    {
      uint64_t v183 = *((void *)v182 + 2);
      double v184 = v71 + v182[3] - v181;
      double v185 = v70 + v182[4] - v68;
      int64x2_t v186 = *a1;
      uint64_t v187 = *(void *)(*(void *)(*((void *)v186 + 2) + 8 * TLine::FindRunWithCharIndex(*a1, v183, 1)) + 48);
      objc_msgSend(*(id *)(v187 + 216), "setOrigin:atIndex:", *(void *)(v187 + 200) + TRun::GetGlyphIndexForCharIndex<false>(v187, v183), v184, v185);
      if (v184 != *v179 || v185 != v179[1]) {
        *(unsigned char *)(v187 + 225) |= 0x10u;
      }
      long long v182 = *(double **)v182;
    }
    while (v182);
  }
  if (__p[0])
  {
    __p[1] = __p[0];
    if (&v227[1] > __p[0] || v228 <= __p[0]) {
      operator delete(__p[0]);
    }
  }
  char v14 = 1;
LABEL_267:
  CFRange v189 = v222[0];
  if (v222[0])
  {
    do
    {
      v190 = (void *)*v189;
      operator delete(v189);
      CFRange v189 = v190;
    }
    while (v190);
  }
  v191 = v221[0];
  v221[0] = 0;
  if (v191) {
    operator delete(v191);
  }
  return v14 & 1;
}

double TFont::GetBoundingBoxForGlyph(TFont *this, unsigned __int16 a2)
{
  unsigned __int16 v5 = a2;
  v2.double width = NAN;
  v2.height = NAN;
  v4.origin = (CGPoint)v2;
  v4.size = v2;
  return TFont::GetBoundingBoxesForGlyphs(this, &v5, &v4, 1, kCTFontOrientationDefault);
}

void TGlyphComposer::PositionBaseOtherTopCenteringGap(TGlyphComposer *this, CGRect a2, CGRect a3, uint64_t a4, uint64_t a5, CGPoint a6)
{
}

void *std::__hash_table<std::__hash_value_type<long,CGPoint>,std::__unordered_map_hasher<long,std::__hash_value_type<long,CGPoint>,std::hash<long>,std::equal_to<long>,true>,std::__unordered_map_equal<long,std::__hash_value_type<long,CGPoint>,std::equal_to<long>,std::hash<long>,true>,std::allocator<std::__hash_value_type<long,CGPoint>>>::__emplace_unique_key_args<long,std::piecewise_construct_t const&,std::tuple<long const&>,std::tuple<>>(uint64_t a1, unint64_t a2, uint64_t *a3)
{
  unint64_t v6 = *(void *)(a1 + 8);
  if (v6)
  {
    uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0]  = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      unint64_t v8 = a2;
      if (v6 <= a2) {
        unint64_t v8 = a2 % v6;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & a2;
    }
    int v9 = *(void ***)(*(void *)a1 + 8 * v8);
    if (v9)
    {
      for (unint64_t i = *v9; i; unint64_t i = (void *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (i[2] == a2) {
            return i;
          }
        }
        else
        {
          if (v7.u32[0] > 1uLL)
          {
            if (v11 >= v6) {
              v11 %= v6;
            }
          }
          else
          {
            v11 &= v6 - 1;
          }
          if (v11 != v8) {
            break;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAAALL;
  }
  unint64_t i = operator new(0x28uLL);
  *unint64_t i = 0;
  i[1]  = a2;
  uint64_t v12 = *a3;
  i[3]  = 0;
  i[4]  = 0;
  i[2]  = v12;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v6 || (float)(v14 * (float)v6) < v13)
  {
    BOOL v15 = 1;
    if (v6 >= 3) {
      BOOL v15 = (v6 & (v6 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v6);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    std::__hash_table<std::__hash_value_type<TRun const*,long>,std::__unordered_map_hasher<TRun const*,std::__hash_value_type<TRun const*,long>,std::hash<TRun const*>,std::equal_to<TRun const*>,true>,std::__unordered_map_equal<TRun const*,std::__hash_value_type<TRun const*,long>,std::equal_to<TRun const*>,std::hash<TRun const*>,true>,std::allocator<std::__hash_value_type<TRun const*,long>>>::__rehash<true>(a1, v18);
    unint64_t v6 = *(void *)(a1 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v6 <= a2) {
        unint64_t v8 = a2 % v6;
      }
      else {
        unint64_t v8 = a2;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & a2;
    }
  }
  uint64_t v19 = *(void *)a1;
  uint64_t v20 = *(void **)(*(void *)a1 + 8 * v8);
  if (v20)
  {
    *unint64_t i = *v20;
LABEL_38:
    *uint64_t v20 = i;
    goto LABEL_39;
  }
  *unint64_t i = *(void *)(a1 + 16);
  *(void *)(a1 + 16)  = i;
  *(void *)(v19 + 8 * v8)  = a1 + 16;
  if (*i)
  {
    unint64_t v21 = *(void *)(*i + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v21 >= v6) {
        v21 %= v6;
      }
    }
    else
    {
      v21 &= v6 - 1;
    }
    uint64_t v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return i;
}

void ZapfTable::ZapfTable(ZapfTable *this, id a2, uint64_t a3)
{
  *(void *)this  = a2;
  *((void *)this + 1)  = 0;
  *((void *)this + 5)  = TAATLookupTable::BadTable;
  *((void *)this + 2)  = 0;
  *((void *)this + 3)  = 0;
  *((void *)this + 6)  = 0;
  *((void *)this + 10)  = 0;
  *((_WORD *)this + 44)  = -1;
  if (a2)
  {
    BytePtr  = CFDataGetBytePtr((CFDataRef)a2);
    uint8x8_t v7 = CFDataGetBytePtr((CFDataRef)a2);
    if (v7)
    {
      unint64_t v8 = (SFNTLookupTable *)&v7[CFDataGetLength((CFDataRef)a2)];
      int v9 = (const SFNTLookupTable *)(BytePtr + 8);
      if (BytePtr + 8 <= (const UInt8 *)v8)
      {
        uint64_t v10 = bswap32(*(unsigned __int16 *)BytePtr) >> 16;
        *((void *)this + 3)  = v10;
        if (v10 == 2)
        {
          TAATLookupTable::SetTable((uint64_t)this + 40, v9, v8);
        }
        else
        {
          if (v10 != 1
            || ((unint64_t v11 = (char *)v9 + 4 * a3, v11 < (char *)v9) || v11 > (char *)v8)
            && (BytePtr + 12 <= (const UInt8 *)v8
              ? (unint64_t v12 = (unint64_t)((char *)v8 - (char *)v9) >> 2)
              : (unint64_t v12 = 0),
                v12 != a3))
          {
            *((void *)this + 3)  = 0;
            return;
          }
          *((void *)this + 4)  = v9;
        }
        *((void *)this + 1)  = BytePtr;
        *((void *)this + 2)  = v8;
      }
    }
  }
}

unsigned __int8 *ZapfTable::GlyphInfoForGlyph(ZapfTable *this, uint64_t a2)
{
  uint64_t v3 = *((void *)this + 3);
  if (v3 == 1)
  {
    unsigned int v7 = bswap32(*(_DWORD *)(*((void *)this + 4) + 4 * a2));
    goto LABEL_14;
  }
  if (v3 != 2) {
    return 0;
  }
  unint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
  CGRect v4 = (uint64_t (*)(void *, uint64_t, unint64_t *))*((void *)this + 5);
  uint64_t v5 = *((void *)this + 6);
  unint64_t v6 = (void *)((char *)this + (v5 >> 1) + 40);
  if (v5) {
    CGRect v4 = *(uint64_t (**)(void *, uint64_t, unint64_t *))(*v6 + v4);
  }
  uint64_t result = (unsigned __int8 *)v4(v6, a2, &v14);
  if (result)
  {
    unint64_t v9 = v14;
    if (v14)
    {
      unsigned int v7 = 0;
      do
      {
        int v10 = *result++;
        unsigned int v7 = v10 | (v7 << 8);
        --v9;
      }
      while (v9);
    }
    else
    {
      unsigned int v7 = 0;
    }
LABEL_14:
    unint64_t v11 = *((void *)this + 1);
    unint64_t v12 = v11 + v7;
    if (v12 + 10 > *((void *)this + 2) || v11 > v12 + 9) {
      return 0;
    }
    else {
      return (unsigned __int8 *)v12;
    }
  }
  return result;
}

void ZapfTable::AppendVariants(uint64_t a1, unsigned __int16 *a2, atomic_ullong *a3)
{
  unsigned int v5 = bswap32(*a2);
  unsigned int v6 = HIWORD(v5) & 0x3FFF;
  if ((v5 & 0x80000000) != 0)
  {
    if (v6)
    {
      int v20 = 0;
      unint64_t v21 = a2 + 1;
      do
      {
        unint64_t v22 = *(void *)(a1 + 8);
        unint64_t v23 = *(void *)(a1 + 16);
        uint64_t v24 = v21 + 3;
        if (v22 > (unint64_t)v21 || (unint64_t)v21 > 0xFFFFFFFFFFFFFFF9 || (unint64_t)v24 > v23)
        {
          BOOL v27 = v22 > (unint64_t)v21 || (unint64_t)(v21 + 1) > v23;
          if (v27 || ((v23 - (void)v21) & 0xFFFFFFFFFFFFFFFELL) != 6) {
            break;
          }
        }
        __int16 v29 = *v21;
        unsigned int v30 = (unsigned __int16)v21[2];
        uint64_t v31 = __rev16(v30);
        int v32 = &v24[v31];
        BOOL v33 = v22 <= (unint64_t)v24 && v32 >= v24;
        if (!v33 || (unint64_t)v32 > v23)
        {
          BOOL v35 = (unint64_t)(v21 + 4) > v23 || v22 > (unint64_t)v24;
          unint64_t v36 = (v23 - (unint64_t)v24) >> 1;
          if (v35) {
            unint64_t v36 = 0;
          }
          if (v36 != v31) {
            break;
          }
        }
        if (v30)
        {
          int v37 = 0;
          do
          {
            unsigned int v38 = *v24;
            if (v38 != 0xFFFF)
            {
              TCFNumber::TCFNumber<int>(&v40, __rev16(v38));
              CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit(a3, memory_order_acquire), (const void *)atomic_load_explicit((atomic_ullong *volatile)&v40, memory_order_acquire));
            }
            ++v37;
            ++v24;
          }
          while (v31 > (unsigned __int16)v37);
        }
        unint64_t v21 = (_WORD *)(((unint64_t)v24 + 3) & 0xFFFFFFFFFFFFFFFCLL);
        if ((v24 & 3) == 0) {
          unint64_t v21 = v24;
        }
        if ((v29 & 0x80) == 0) {
          unint64_t v21 = v24;
        }
        ++v20;
      }
      while (v6 > (unsigned __int16)v20);
    }
  }
  else if (v6)
  {
    int v7 = 0;
    unint64_t v8 = a2 + 2;
    do
    {
      unint64_t v9 = *(void *)(a1 + 16);
      int v10 = v8 + 1;
      if (*(void *)(a1 + 8) > (unint64_t)v8 || (unint64_t)v10 > v9) {
        break;
      }
      unsigned int v12 = *v8;
      uint64_t v13 = __rev16(v12);
      unint64_t v14 = &v10[v13];
      unint64_t v15 = (unint64_t)(v8 + 2) <= v9 ? (v9 - (unint64_t)v10) >> 1 : 0;
      BOOL v16 = (unint64_t)v14 <= v9 && v14 >= v10;
      if (!v16 && v15 != v13) {
        break;
      }
      if (v12)
      {
        int v18 = 0;
        do
        {
          unsigned int v19 = *v10;
          if (v19 != 0xFFFF)
          {
            TCFNumber::TCFNumber<int>(&v39, __rev16(v19));
            CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit(a3, memory_order_acquire), (const void *)atomic_load_explicit((atomic_ullong *volatile)&v39, memory_order_acquire));
          }
          ++v18;
          ++v10;
        }
        while (v13 > (unsigned __int16)v18);
      }
      ++v7;
      unint64_t v8 = v10;
    }
    while (v6 > (unsigned __int16)v7);
  }
}

void ZapfTable::VariantsForGlyph(ZapfTable *this@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X8>)
{
  unsigned int v5 = (unsigned int *)ZapfTable::GlyphInfoForGlyph(this, a2);
  if (!v5
    || *v5 == -1
    || (uint64_t v6 = *((void *)this + 1),
        unsigned int v7 = bswap32(*(_DWORD *)(v6 + 4)),
        uint64_t v8 = v7 + bswap32(*v5),
        unint64_t v9 = (unsigned __int16 *)(v6 + v8),
        (unint64_t)(v6 + v8 + 2) > *((void *)this + 2)))
  {
    *a3  = 0;
    return;
  }
  id Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  unsigned int v10 = bswap32(*v9) >> 16;
  if ((v10 & 0x4000) != 0)
  {
    unint64_t v11 = v9 + 2;
    uint64_t v12 = v10 & 0x3FFF;
    unint64_t v13 = *((void *)this + 1);
    unint64_t v14 = *((void *)this + 2);
    unint64_t v15 = (unint64_t)&v9[2 * v12 + 2];
    if (v13 > (unint64_t)(v9 + 2) || v15 < (unint64_t)v11 || v15 > v14)
    {
      BOOL v18 = (unint64_t)(v9 + 4) > v14 || v13 > (unint64_t)v11;
      unint64_t v19 = (v14 - (unint64_t)v11) >> 2;
      if (v18) {
        unint64_t v19 = 0;
      }
      if (v19 != v12)
      {
LABEL_30:
        unint64_t v24 = 0;
        goto LABEL_29;
      }
    }
    if (v12)
    {
      int v20 = (unsigned int *)(v8 + v6 + 4);
      do
      {
        unsigned int v22 = *v20++;
        unsigned int v21 = v22;
        if (v22 != -1)
        {
          unint64_t v23 = (unsigned __int16 *)(*((void *)this + 1) + bswap32(v21) + v7);
          if ((unint64_t)(v23 + 1) > *((void *)this + 2)) {
            goto LABEL_30;
          }
          ZapfTable::AppendVariants((uint64_t)this, v23, (atomic_ullong *)&Mutable);
        }
        --v12;
      }
      while (v12);
    }
  }
  else
  {
    ZapfTable::AppendVariants((uint64_t)this, (unsigned __int16 *)(v6 + v8), (atomic_ullong *)&Mutable);
  }
  unint64_t v24 = atomic_exchange((atomic_ullong *volatile)&Mutable, 0);
LABEL_29:
  *a3  = v24;
}

CFTypeID CTTextTabGetTypeID(void)
{
  if (TCFBase<TNativeTextTab>::GetTypeID(void)::once != -1) {
    dispatch_once_f(&TCFBase<TNativeTextTab>::GetTypeID(void)::once, 0, (dispatch_function_t)TCFBase<TNativeTextTab>::GetTypeID(void)::{lambda(void *)#1}::__invoke);
  }
  return TCFBase<TNativeTextTab>::fTypeID;
}

CTTextTabRef CTTextTabCreate(CTTextAlignment alignment, double location, CFDictionaryRef options)
{
  if (alignment > kCTTextAlignmentNatural) {
    return 0;
  }
  id v11 = (id)0xAAAAAAAAAAAAAAAALL;
  uint64_t v6 = TCFBase<TNativeTextTab>::Allocate();
  if (v6)
  {
    unsigned int v7 = (void *)v6;
    *(double *)(v6 + 48)  = location;
    *(void *)(v6 + 16)  = 0;
    *(void *)(v6 + 24)  = 0;
    *(void *)(v6 + 32)  = 0;
    *(void *)(v6 + 40)  = v6 + 48;
    *(unsigned char *)(v6 + 56)  = alignment;
    *(void *)(v6 + 64)  = options;
    if (options) {
      CFRetain(options);
    }
    id v12 = v7;
    id v10 = (id)atomic_exchange((atomic_ullong *volatile)&v12, 0);
  }
  else
  {
    id v10 = 0;
  }
  id v11 = (id)atomic_exchange((atomic_ullong *volatile)&v10, 0);

  uint64_t v8 = (const __CTTextTab *)atomic_exchange((atomic_ullong *volatile)&v11, 0);
  return v8;
}

CTTextAlignment CTTextTabGetAlignment(CTTextTabRef tab)
{
  if (tab)
  {
    unint64_t v3 = 0xAAAAAAAAAAAAAAAALL;
    long long v2 = xmmword_184BA1C78;
    TTextTab::SetTabRef((TTextTab *)&v2, tab);
    LOBYTE(tab)  = BYTE8(v2);
  }
  return tab;
}

double CTTextTabGetLocation(CTTextTabRef tab)
{
  if (!tab) {
    return 0.0;
  }
  unint64_t v3 = 0xAAAAAAAAAAAAAAAALL;
  long long v2 = xmmword_184BA1C78;
  TTextTab::SetTabRef((TTextTab *)&v2, tab);
  return *(double *)&v2;
}

CFDictionaryRef CTTextTabGetOptions(CFDictionaryRef tab)
{
  if (tab)
  {
    CFDictionaryRef v2 = (const __CFDictionary *)0xAAAAAAAAAAAAAAAALL;
    long long v1 = xmmword_184BA1C78;
    TTextTab::SetTabRef((TTextTab *)&v1, tab);
    return v2;
  }
  return tab;
}

BOOL TCFBase<TNativeTextTab>::ClassEqual(uint64_t a1, uint64_t a2)
{
  return TNativeTextTab::operator==(*(void *)(a1 + 40), *(void *)(a2 + 40));
}

void *TCFBase<TNativeTextTab>::ClassHash(void *result)
{
  unint64_t v1 = result[3];
  uint64_t v2 = result[4];
  if (v2) {
    BOOL v3 = (result[4] & 1 | v1) == 0;
  }
  else {
    BOOL v3 = 1;
  }
  int v4 = !v3;
  if (v1) {
    BOOL v5 = 0;
  }
  else {
    BOOL v5 = v4 == 0;
  }
  if (!v5)
  {
    uint64_t v6 = (void *)(result[5] + (v2 >> 1));
    if (v2) {
      return (void *)(*(uint64_t (**)(void))(*v6 + v1))();
    }
    else {
      return (void *)((uint64_t (*)(void *))v1)(v6);
    }
  }
  return result;
}

CFStringRef TCFBase<TNativeTextTab>::ClassDebug(uint64_t a1)
{
  CFStringRef result = TNativeTextTab::DebugDescription(*(TNativeTextTab **)(a1 + 40));
  if (result)
  {
    CFStringRef v3 = result;
    CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<%s: %p>{%@}", "CTTextTab", a1, result);
    CFRelease(v3);
    return v4;
  }
  return result;
}

uint64_t TCallbackBidiLevelsProvider::GetLevels(TCallbackBidiLevelsProvider *this, CFRange a2, CTWritingDirection a3)
{
  uint64_t v3 = *((void *)this + 2);
  if (v3) {
    return v3 + a2.location - *((void *)this + 1);
  }
  else {
    return 0;
  }
}

uint64_t TCallbackBidiLevelsProvider::GetDefaultParagraphDirection(TCallbackBidiLevelsProvider *this)
{
  char v1 = *((unsigned char *)this + 25);
  if (v1) {
    return (char)*((unsigned char *)this + 24);
  }
  return v1;
}

void TCallbackBidiLevelsProvider::~TCallbackBidiLevelsProvider(TCallbackBidiLevelsProvider *this)
{
}

void TICUBidiLevelsProvider::~TICUBidiLevelsProvider(TICUBidiLevelsProvider *this)
{
  uint64_t v2 = 0;
  *(void *)this  = &unk_1ED05F0E8;
  atomic_compare_exchange_strong(&gBidiEngineRetired, (unint64_t *)&v2, *((void *)this + 2));
  if (v2) {
    ubidi_close();
  }
  uint64_t v3 = (void **)((char *)this + 40);
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100](&v3);
}

{
  uint64_t vars8;

  TICUBidiLevelsProvider::~TICUBidiLevelsProvider(this);

  JUMPOUT(0x1853275C0);
}

uint64_t TICUBidiLevelsProvider::GetLevels(TICUBidiLevelsProvider *this, CFRange a2, CTWritingDirection a3)
{
  int v4 = TICUBidiLevelsProvider::ConfigureBidiEngine(this, a2, a3);
  if (v4 > 0) {
    return 0;
  }
  uint64_t result = ubidi_getLevels();
  if (v4 >= 1) {
    return 0;
  }
  return result;
}

uint64_t TICUBidiLevelsProvider::ConfigureBidiEngine(TICUBidiLevelsProvider *this, CFRange a2, CTWritingDirection a3)
{
  if (a2.location != *((void *)this + 3) || a2.length != *((void *)this + 4))
  {
    CFIndex length = a2.length;
    CFIndex location = a2.location;
    TCharStream::LazyCopyChars(*((void **)this + 1), a2.location, a2.length);
    ubidi_setPara();
    *((void *)this + 3)  = location;
    *((void *)this + 4)  = length;
  }
  return 0;
}

uint64_t TICUBidiLevelsProvider::GetDefaultParagraphDirection(TICUBidiLevelsProvider *this)
{
  v2.CFIndex length = *(void *)(*((void *)this + 1) + 16);
  v2.CFIndex location = 0;
  TICUBidiLevelsProvider::ConfigureBidiEngine(this, v2, kCTWritingDirectionNatural);
  ubidi_getParagraph();
  return 0;
}

void TAttributes::TAttributes(TAttributes *this, const TAttributes *a2, const __CTFont *a3)
{
  *(void *)this  = (id)atomic_load_explicit((atomic_ullong *volatile)a2, memory_order_acquire);
  *((void *)this + 1)  = (id)atomic_load_explicit((atomic_ullong *volatile)a2 + 1, memory_order_acquire);
  *((void *)this + 2)  = a3;
  *((void *)this + 3)  = (id)atomic_load_explicit((atomic_ullong *volatile)a2 + 3, memory_order_acquire);
  *((void *)this + 4)  = (id)atomic_load_explicit((atomic_ullong *volatile)a2 + 4, memory_order_acquire);
  *((void *)this + 5)  = (id)atomic_load_explicit((atomic_ullong *volatile)a2 + 5, memory_order_acquire);
  *((_WORD *)this + 24)  = 1;
  *((_WORD *)this + 25)  = *((_WORD *)a2 + 25);
  long long v6 = *(_OWORD *)((char *)a2 + 72);
  long long v7 = *(_OWORD *)((char *)a2 + 88);
  uint64_t v8 = *((void *)a2 + 13);
  *(_OWORD *)((char *)this + 56)  = *(_OWORD *)((char *)a2 + 56);
  *((void *)this + 13)  = v8;
  *(_OWORD *)((char *)this + 88)  = v7;
  *(_OWORD *)((char *)this + 72)  = v6;
  *((unsigned char *)this + 112)  = *((unsigned char *)a2 + 112);
  if (*((void *)a2 + 15)) {
    operator new();
  }
  *((void *)this + 15)  = 0;
  if (*((void *)a2 + 16)) {
    operator new();
  }
  *((void *)this + 18)  = 0;
  *((void *)this + 16)  = 0;
  *((_WORD *)this + 68)  = *((_WORD *)a2 + 68);
  *((_WORD *)this + 69)  = *((_WORD *)a2 + 69) & 0xF9FF;
  if (*((void *)a2 + 18)) {
    operator new();
  }
  id v11 = 0;
  v12.CFIndex location = 0;
  v12.CFIndex length = 0;
  TAttributes::ApplyFont(this, (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)this, memory_order_acquire), (const __CTFont *)atomic_load_explicit((atomic_ullong *volatile)this + 2, memory_order_acquire), 0, v12, (const void **)&v11);
  CompositionLanguage  = TAttributes::GetCompositionLanguage(this, v9);
  *((unsigned char *)this + 112)  = CompositionLanguage;
  if (CompositionLanguage >= 2 && CJKCompositionEngine::IsEnabled(CompositionLanguage, (uint64_t)this)) {
    *((_WORD *)this + 69) |= 0x100u;
  }
  else {
    *((unsigned char *)this + 112)  = 1;
  }
  TAttributes::SetLayoutAttributesForFont((atomic_ullong *)this);
}

CFStringRef TAttributes::DebugDescription(atomic_ullong *this)
{
  Dictionardouble y = (const void *)TAttributes::GetDictionary(this);
  if (!Dictionary) {
    return @"NULL";
  }

  return CFCopyDescription(Dictionary);
}

void TAttributes::SetVerticalFont(TAttributes *this, const __CTFont *a2)
{
  int v4 = (TFont *)*((void *)a2 + 5);
  *(void *)&long long v5 = -1;
  *((void *)&v5 + 1)  = -1;
  *(_OWORD *)&t1.c  = v5;
  *(_OWORD *)&t1.tdouble x = v5;
  *(_OWORD *)&t1.a  = v5;
  TFont::GetEffectiveMatrix(v4, (uint64_t)&t1);
  float64x2_t v6 = (float64x2_t)vdupq_n_s64(0x3CB0000000000000uLL);
  int64x2_t v7 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f64(v6, (float64x2_t)vandq_s8(*(int8x16_t *)&t1.tx, (int8x16_t)vdupq_n_s64(0x7FFFFFFFFFFFFFFFuLL))), (int8x16_t)vcgeq_f64(v6, vabsq_f64(vaddq_f64(*(float64x2_t *)&t1.a, (float64x2_t)xmmword_184B88D30)))), (int8x16_t)vcgeq_f64(v6, vabsq_f64(vaddq_f64(*(float64x2_t *)&t1.c, (float64x2_t)xmmword_184B88D40))));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v7, 1), (int8x16_t)v7).u64[0] & 0x8000000000000000) != 0)
  {
    if (*((unsigned char *)this + 104)) {
      unint64_t v9 = (float64x2_t *)((char *)this + 56);
    }
    else {
      unint64_t v9 = (float64x2_t *)MEMORY[0x1E4F1DAB8];
    }
  }
  else
  {
    long long v8 = *(_OWORD *)&t1.c;
    *(_OWORD *)((char *)this + 56)  = *(_OWORD *)&t1.a;
    *(_OWORD *)((char *)this + 72)  = v8;
    *(_OWORD *)((char *)this + 88)  = *(_OWORD *)&t1.tx;
    *((unsigned char *)this + 104)  = 1;
    unint64_t v9 = (float64x2_t *)((char *)this + 56);
  }
  float64x2_t v10 = *v9;
  float64x2_t v11 = v9[1];
  float64x2_t v12 = v9[2];
  float64x2_t v13 = (float64x2_t)vdupq_n_s64(0x3CB0000000000000uLL);
  int64x2_t v14 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f64(v13, vabsq_f64(vaddq_f64(v11, (float64x2_t)xmmword_184B88D40))), (int8x16_t)vcgeq_f64(v13, vabsq_f64(vaddq_f64(*v9, (float64x2_t)xmmword_184B88D30)))), (int8x16_t)vcgeq_f64(v13, vabsq_f64(v12)));
  unint64_t v15 = vandq_s8((int8x16_t)vdupq_laneq_s64(v14, 1), (int8x16_t)v14).u64[0];
  CGFloat v16 = v10.f64[1];
  if ((v15 & 0x8000000000000000) != 0)
  {
    CGFloat v18 = v10.f64[0];
    v10.f64[0]  = v11.f64[1];
  }
  else
  {
    CGFloat v17 = -v11.f64[0];
    v11.f64[0]  = -v10.f64[1];
    CGFloat v18 = v11.f64[1];
    CGFloat v16 = v17;
  }
  t1.a  = v18;
  t1.b  = v16;
  t1.c  = v11.f64[0];
  t1.d  = v10.f64[0];
  *(float64x2_t *)&t1.tdouble x = v12;
  t2  = *(CGAffineTransform *)kRotateLeftTransform;
  CGAffineTransformConcat(&v20, &t1, &t2);
  long long v19 = *(_OWORD *)&v20.c;
  *(_OWORD *)((char *)this + 56)  = *(_OWORD *)&v20.a;
  *(_OWORD *)((char *)this + 72)  = v19;
  *(_OWORD *)((char *)this + 88)  = *(_OWORD *)&v20.tx;
  *((unsigned char *)this + 104)  = 1;
  *(void *)&t1.a  = a2;
  if (atomic_load_explicit((atomic_ullong *volatile)&t1, memory_order_acquire))
  {

    *((unsigned char *)this + 48)  = 1;
  }

  *((unsigned char *)this + 50)  = 1;
  TAttributes::ApplyTateChuYoko(this);
}

void TAttributes::ApplyTateChuYoko(TAttributes *this)
{
  uint64_t v1 = *((void *)this + 15);
  if (v1)
  {
    int v2 = *(unsigned __int16 *)(v1 + 64);
    if (*(_WORD *)(v1 + 64))
    {
      uint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)this + 2, memory_order_acquire);
      id v7 = (id)CTFontCopyFeaturesInternal(explicit);
      if (TFontFeatures::GetFeatureSelector((atomic_ullong *)&v7, 22, v2))
      {
        if (v2 != 1) {
          *((_WORD *)this + 69) |= 0x1000u;
        }
        CreateCopyOfFontWithFeature((const __CTFont *)&v6, explicit, 22, v2);
        if (atomic_load_explicit((atomic_ullong *volatile)&v6, memory_order_acquire))
        {

          *((unsigned char *)this + 48)  = 1;
        }

        uint64_t v5 = *((void *)this + 15);
        if (*(unsigned char *)(v5 + 24)) {
          *(unsigned char *)(v5 + 24)  = 0;
        }
      }
    }
  }
}

uint64_t TAttributes::HandleBackgroundCGColorAttribute(uint64_t result, uint64_t a2)
{
  if (result) {
    *(unsigned char *)(*(void *)a2 + 137) |= 1u;
  }
  return result;
}

const void *TAttributes::HandleStrokeWidthAttribute(const void *result, uint64_t a2)
{
  if (result)
  {
    CFTypeID v3 = CFGetTypeID(result);
    uint64_t result = (const void *)CFNumberGetTypeID();
    if ((const void *)v3 == result
      || (uint64_t result = (const void *)CFBooleanGetTypeID(), (const void *)v3 == result)
      || (uint64_t result = (const void *)CFStringGetTypeID(), (const void *)v3 == result))
    {
      *(unsigned char *)(*(void *)a2 + 136) |= 4u;
    }
  }
  return result;
}

uint64_t TAttributes::HandleStrikethroughAttribute(uint64_t result, TAttributes **a2)
{
  if (result)
  {
    CFNumberRef v3 = (const __CFNumber *)result;
    int valuePtr = -1431655766;
    CFTypeID v4 = CFGetTypeID((CFTypeRef)result);
    if (v4 == CFNumberGetTypeID() || v4 == CFBooleanGetTypeID())
    {
      uint64_t result = CFNumberGetValue(v3, kCFNumberIntType, &valuePtr);
      int v5 = valuePtr;
    }
    else
    {
      uint64_t result = CFStringGetTypeID();
      if (v4 != result) {
        return result;
      }
      uint64_t result = CFStringGetIntValue((CFStringRef)v3);
      int v5 = result;
      int valuePtr = result;
    }
    if ((_BYTE)v5)
    {
      uint64_t result = TAttributes::EnsureRareData(*a2);
      *(_DWORD *)(result + 60)  = v5;
      *((unsigned char *)*a2 + 137) |= 0x10u;
    }
  }
  return result;
}

CFTypeID TAttributes::HandleLigatureAttribute(CFTypeID result, uint64_t a2)
{
  if (result)
  {
    CFNumberRef v3 = (const __CFNumber *)result;
    CFTypeID v4 = CFGetTypeID((CFTypeRef)result);
    if (v4 == CFNumberGetTypeID() || v4 == CFBooleanGetTypeID())
    {
      unsigned int valuePtr = -1431655766;
      CFNumberGetValue(v3, kCFNumberIntType, &valuePtr);
      uint64_t result = valuePtr;
    }
    else
    {
      uint64_t result = CFStringGetTypeID();
      if (v4 != result) {
        return result;
      }
      uint64_t result = CFStringGetIntValue((CFStringRef)v3);
    }
    if ((int)result >= 2) {
      unsigned __int8 v5 = 2;
    }
    else {
      unsigned __int8 v5 = result;
    }
    *(_WORD *)(a2 + 56)  = v5 | 0x100;
  }
  return result;
}

const __CFNumber *TAttributes::HandleCTBaselineOffsetAttribute(const __CFNumber *result, TAttributes **a2)
{
  if (result)
  {
    CFNumberRef v3 = result;
    double valuePtr = NAN;
    CFTypeID v4 = CFGetTypeID(result);
    if (v4 == CFNumberGetTypeID() || v4 == CFBooleanGetTypeID())
    {
      CFNumberGetValue(v3, kCFNumberDoubleType, &valuePtr);
LABEL_5:
      uint64_t result = (const __CFNumber *)TAttributes::EnsureRareData(*a2);
      *((void *)result + 5)  = @"CTBaselineOffset";
      *((double *)result + 6)  = valuePtr;
      return result;
    }
    uint64_t result = (const __CFNumber *)CFStringGetTypeID();
    if ((const __CFNumber *)v4 == result)
    {
      double valuePtr = CFStringGetDoubleValue((CFStringRef)v3);
      goto LABEL_5;
    }
  }
  return result;
}

const __CFNumber *TAttributes::HandleSuperscriptAttribute(const __CFNumber *result, uint64_t a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (result)
  {
    CFNumberRef v3 = result;
    int valuePtr = -1431655766;
    CFTypeID v4 = CFGetTypeID(result);
    if (v4 == CFNumberGetTypeID() || v4 == CFBooleanGetTypeID())
    {
      CFNumberGetValue(v3, kCFNumberIntType, &valuePtr);
      Intint Value = valuePtr;
    }
    else
    {
      uint64_t result = (const __CFNumber *)CFStringGetTypeID();
      if ((const __CFNumber *)v4 != result) {
        return result;
      }
      Intint Value = CFStringGetIntValue((CFStringRef)v3);
      int valuePtr = IntValue;
    }
    __int16 v6 = IntValue != 0;
    if (IntValue < 0) {
      __int16 v6 = 2;
    }
    long long v19 = &unk_1ED0608A8;
    unint64_t v20 = 0xAAAAAAAAAAAAAAAALL;
    LOWORD(v20)  = v6;
    unint64_t v21 = 0xAAAAAAAAAAAAAAAALL;
    unsigned int v22 = &v19;
    id v7 = *(uint64_t **)(a2 + 48);
    unint64_t v9 = v7[1];
    unint64_t v8 = v7[2];
    if (v9 >= v8)
    {
      uint64_t v11 = (uint64_t)(v9 - *v7) >> 5;
      if ((unint64_t)(v11 + 1) >> 59) {
        abort();
      }
      uint64_t v12 = v8 - *v7;
      uint64_t v13 = v12 >> 4;
      if (v12 >> 4 <= (unint64_t)(v11 + 1)) {
        uint64_t v13 = v11 + 1;
      }
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFE0) {
        unint64_t v14 = 0x7FFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v13;
      }
      v18[4]  = v7 + 3;
      if (v14) {
        unint64_t v15 = TInlineBufferAllocator<DecorationOverride,30ul>::allocate((uint64_t)(v7 + 3), v14);
      }
      else {
        unint64_t v15 = 0;
      }
      uint64_t v16 = (uint64_t)&v15[32 * v11];
      v18[0]  = v15;
      v18[1]  = v16;
      v18[3]  = &v15[32 * v14];
      std::__function::__value_func<void ()(TAttributes &)>::__value_func[abi:nn180100](v16, (uint64_t)&v19);
      v18[2]  = v16 + 32;
      std::vector<std::function<void ()(TAttributes &)>,TInlineBufferAllocator<std::function<void ()(TAttributes &)>,30ul>>::__swap_out_circular_buffer(v7, v18);
      uint64_t v10 = v7[1];
      std::__split_buffer<std::function<void ()(TAttributes &)>,TInlineBufferAllocator<std::function<void ()(TAttributes &)>,30ul> &>::~__split_buffer((uint64_t)v18);
    }
    else
    {
      std::__function::__value_func<void ()(TAttributes &)>::__value_func[abi:nn180100](v7[1], (uint64_t)&v19);
      uint64_t v10 = v9 + 32;
    }
    v7[1]  = v10;
    return (const __CFNumber *)std::__function::__value_func<void ()(TAttributes &)>::~__value_func[abi:nn180100](&v19);
  }
  return result;
}

const __CFNumber *TAttributes::HandleCharacterShapeAttribute(const __CFNumber *result, uint64_t a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (result)
  {
    CFNumberRef v3 = result;
    int valuePtr = -1431655766;
    CFTypeID v4 = CFGetTypeID(result);
    if (v4 == CFNumberGetTypeID() || v4 == CFBooleanGetTypeID())
    {
      CFNumberGetValue(v3, kCFNumberIntType, &valuePtr);
      LOWORD(IntValue)  = valuePtr;
    }
    else
    {
      uint64_t result = (const __CFNumber *)CFStringGetTypeID();
      if ((const __CFNumber *)v4 != result) {
        return result;
      }
      Intint Value = CFStringGetIntValue((CFStringRef)v3);
      int valuePtr = IntValue;
    }
    CGFloat v18 = &unk_1ED0608F0;
    unint64_t v19 = 0xAAAAAAAAAAAAAAAALL;
    LOWORD(v19)  = IntValue - 1;
    unint64_t v20 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v21 = &v18;
    __int16 v6 = *(uint64_t **)(a2 + 48);
    unint64_t v8 = v6[1];
    unint64_t v7 = v6[2];
    if (v8 >= v7)
    {
      uint64_t v10 = (uint64_t)(v8 - *v6) >> 5;
      if ((unint64_t)(v10 + 1) >> 59) {
        abort();
      }
      uint64_t v11 = v7 - *v6;
      uint64_t v12 = v11 >> 4;
      if (v11 >> 4 <= (unint64_t)(v10 + 1)) {
        uint64_t v12 = v10 + 1;
      }
      if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFE0) {
        unint64_t v13 = 0x7FFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v13 = v12;
      }
      v17[4]  = v6 + 3;
      if (v13) {
        unint64_t v14 = TInlineBufferAllocator<DecorationOverride,30ul>::allocate((uint64_t)(v6 + 3), v13);
      }
      else {
        unint64_t v14 = 0;
      }
      uint64_t v15 = (uint64_t)&v14[32 * v10];
      v17[0]  = v14;
      v17[1]  = v15;
      v17[3]  = &v14[32 * v13];
      std::__function::__value_func<void ()(TAttributes &)>::__value_func[abi:nn180100](v15, (uint64_t)&v18);
      v17[2]  = v15 + 32;
      std::vector<std::function<void ()(TAttributes &)>,TInlineBufferAllocator<std::function<void ()(TAttributes &)>,30ul>>::__swap_out_circular_buffer(v6, v17);
      uint64_t v9 = v6[1];
      std::__split_buffer<std::function<void ()(TAttributes &)>,TInlineBufferAllocator<std::function<void ()(TAttributes &)>,30ul> &>::~__split_buffer((uint64_t)v17);
    }
    else
    {
      std::__function::__value_func<void ()(TAttributes &)>::__value_func[abi:nn180100](v6[1], (uint64_t)&v18);
      uint64_t v9 = v8 + 32;
    }
    v6[1]  = v9;
    return (const __CFNumber *)std::__function::__value_func<void ()(TAttributes &)>::~__value_func[abi:nn180100](&v18);
  }
  return result;
}

const __CFBoolean *TAttributes::HandleVerticalFormsAttribute(const __CFBoolean *result, uint64_t a2)
{
  if (result)
  {
    uint64_t result = (const __CFBoolean *)CFBooleanGetValue(result);
    BOOL v3 = result != 0;
  }
  else
  {
    BOOL v3 = 0;
  }
  *(unsigned char *)(*(void *)a2 + 50)  = v3;
  return result;
}

void CreateCopyOfFontWithFeature(const __CTFont *a1, uint64_t a2, int a3, int a4)
{
  if (a2)
  {
    TFont::CopyDescriptor(*(TFont **)(a2 + 40), 0, (atomic_ullong *)&v13);
    unint64_t v7 = (void *)atomic_exchange((atomic_ullong *volatile)&v13, 0);

    id v13 = v7;
    uint64_t explicit = (const __CTFontDescriptor *)atomic_load_explicit((atomic_ullong *volatile)&v13, memory_order_acquire);
    LODWORD(CopyWithFeature)  = a3;
    CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFNumberRef v10 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &CopyWithFeature);
    LODWORD(CopyWithFeature)  = a4;
    CFNumberRef v11 = CFNumberCreate(v9, kCFNumberIntType, &CopyWithFeature);
    CopyWithFeature  = CTFontDescriptorCreateCopyWithFeature(explicit, v10, v11);

    *(void *)a1  = CTFontCreateWithFontDescriptor((CTFontDescriptorRef)atomic_load_explicit((atomic_ullong *volatile)&v13, memory_order_acquire), 0.0, 0);
  }
  else
  {
    *(void *)a1  = 0;
  }
}

CFTypeID TAttributes::HandleHorizontalInVerticalFormsAttribute(CFTypeID result, uint64_t a2)
{
  v37[4]  = *MEMORY[0x1E4F143B8];
  if (result)
  {
    CFNumberRef v3 = (const __CFNumber *)result;
    int valuePtr = -1431655766;
    CFTypeID v4 = CFGetTypeID((CFTypeRef)result);
    if (v4 == CFNumberGetTypeID() || v4 == CFBooleanGetTypeID())
    {
      CFNumberGetValue(v3, kCFNumberIntType, &valuePtr);
      uint64_t result = valuePtr;
    }
    else
    {
      uint64_t result = CFStringGetTypeID();
      if (v4 != result) {
        return result;
      }
      uint64_t result = CFStringGetIntValue((CFStringRef)v3);
      int valuePtr = result;
    }
    if ((result - 5) >= 0xFFFFFFFC)
    {
      if (*(void *)(a2 + 32) < (uint64_t)result) {
        int valuePtr = *(void *)(a2 + 32);
      }
      uint64_t v5 = *(void *)(a2 + 16);
      if (v5)
      {
        uint64_t v23 = *(char **)(a2 + 16);
        long long v24 = 0u;
        long long v25 = 0u;
        long long v26 = 0u;
        long long v27 = 0u;
        long long v28 = 0u;
        long long v29 = 0u;
        long long v30 = 0u;
        long long v31 = 0u;
        long long v32 = 0u;
        long long v33 = 0u;
        uint64_t v35 = 0;
        long long v34 = 0u;
        *(void *)&long long v34 = *(void *)(v5 + 16);
        CFCharacterSetRef Predefined = CFCharacterSetGetPredefined(kCFCharacterSetDecimalDigit);
        uint64_t v7 = *(void *)(a2 + 24);
        v37[0]  = v7;
        int v8 = valuePtr;
        if (valuePtr >= 1)
        {
          CFCharacterSetRef v9 = Predefined;
          uint64_t v10 = v7 + valuePtr;
          while (1)
          {
            UTF32Char FullChar = TCharStreamIterator::GetFullChar((TCharStreamIterator *)&v23, v37, 0);
            if (!CFCharacterSetIsLongCharacterMember(v9, FullChar)) {
              break;
            }
            if (++v37[0] >= v10)
            {
              int v8 = valuePtr;
              goto LABEL_17;
            }
          }
          int v8 = 1;
          int valuePtr = 1;
        }
LABEL_17:
        __int16 v12 = word_184BA1C98[v8 - 1];
        *(_WORD *)(TAttributes::EnsureRareData(*(TAttributes **)a2) + 64)  = v12;
      }
      v37[0]  = (uint64_t)&unk_1ED0609C8;
      v37[1]  = 0xAAAAAAAAAAAAAAAALL;
      v37[2]  = 0xAAAAAAAAAAAAAAAALL;
      v37[3]  = (uint64_t)v37;
      id v13 = *(uint64_t **)(a2 + 48);
      unint64_t v15 = v13[1];
      unint64_t v14 = v13[2];
      if (v15 >= v14)
      {
        uint64_t v17 = (uint64_t)(v15 - *v13) >> 5;
        if ((unint64_t)(v17 + 1) >> 59) {
          abort();
        }
        uint64_t v18 = v14 - *v13;
        uint64_t v19 = v18 >> 4;
        if (v18 >> 4 <= (unint64_t)(v17 + 1)) {
          uint64_t v19 = v17 + 1;
        }
        if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v20 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v20 = v19;
        }
        *((void *)&v25 + 1)  = v13 + 3;
        if (v20) {
          unint64_t v21 = TInlineBufferAllocator<DecorationOverride,30ul>::allocate((uint64_t)(v13 + 3), v20);
        }
        else {
          unint64_t v21 = 0;
        }
        uint64_t v22 = (uint64_t)&v21[32 * v17];
        uint64_t v23 = v21;
        *(void *)&long long v24 = v22;
        *(void *)&long long v25 = &v21[32 * v20];
        std::__function::__value_func<void ()(TAttributes &)>::__value_func[abi:nn180100](v22, (uint64_t)v37);
        *((void *)&v24 + 1)  = v22 + 32;
        std::vector<std::function<void ()(TAttributes &)>,TInlineBufferAllocator<std::function<void ()(TAttributes &)>,30ul>>::__swap_out_circular_buffer(v13, &v23);
        uint64_t v16 = v13[1];
        std::__split_buffer<std::function<void ()(TAttributes &)>,TInlineBufferAllocator<std::function<void ()(TAttributes &)>,30ul> &>::~__split_buffer((uint64_t)&v23);
      }
      else
      {
        std::__function::__value_func<void ()(TAttributes &)>::__value_func[abi:nn180100](v13[1], (uint64_t)v37);
        uint64_t v16 = v15 + 32;
      }
      v13[1]  = v16;
      return (CFTypeID)std::__function::__value_func<void ()(TAttributes &)>::~__value_func[abi:nn180100](v37);
    }
  }
  return result;
}

uint64_t TAttributes::HandleGlyphInfoAttribute(uint64_t result, uint64_t a2)
{
  if (result) {
    *(_WORD *)(*(void *)a2 + 138) |= 0x20u;
  }
  return result;
}

void TAttributes::ApplyBaselineInfoValue(TAttributes *this, const __CFString *a2, TAttributes **a3, void *a4)
{
  uint64_t v6 = TAttributes::EnsureBaselineAttributes(*a3);
  uint64_t v8 = v6;
  if (!*(unsigned char *)(v6 + 128))
  {
    uint64_t v9 = 0;
    *(_OWORD *)(v6 + 96)  = 0u;
    *(_OWORD *)(v6 + 112)  = 0u;
    *(_OWORD *)(v6 + 64)  = 0u;
    *(_OWORD *)(v6 + 80)  = 0u;
    *(_OWORD *)(v6 + 32)  = 0u;
    *(_OWORD *)(v6 + 48)  = 0u;
    *(_OWORD *)uint64_t v6 = 0u;
    *(_OWORD *)(v6 + 16)  = 0u;
    do
    {
      uint64_t v10 = (unsigned char *)(v6 + v9);
      *uint64_t v10 = 0;
      v10[8]  = 0;
      v9 += 16;
    }
    while (v9 != 128);
    *(unsigned char *)(v6 + 128)  = 1;
  }
  unsigned __int16 v11 = TBaselineAttributes::BaselineClassFromName(this, v7);
  if (v11 >= 0x100u)
  {
    uint64_t valuePtr = -1;
    if (a2)
    {
      unsigned __int8 v12 = v11;
      CFTypeID v13 = CFGetTypeID(a2);
      if (v13 == CFNumberGetTypeID() || v13 == CFBooleanGetTypeID())
      {
        CFNumberGetValue((CFNumberRef)a2, kCFNumberDoubleType, &valuePtr);
        Doubleint Value = *(double *)&valuePtr;
LABEL_10:
        uint64_t v15 = v8 + 16 * v12;
        *(double *)uint64_t v15 = DoubleValue;
        *(unsigned char *)(v15 + 8)  = 1;
        return;
      }
      if (v13 == CFStringGetTypeID())
      {
        Doubleint Value = CFStringGetDoubleValue(a2);
        goto LABEL_10;
      }
    }
  }
}

uint64_t TAttributes::EnsureBaselineAttributes(TAttributes *this)
{
  uint64_t result = *((void *)this + 18);
  if (!result) {
    operator new();
  }
  return result;
}

void TAttributes::HandleBaselineInfoAttribute(const void *a1, void *a2)
{
  if (a1)
  {
    CFTypeID v4 = CFGetTypeID(a1);
    if (v4 == CFDictionaryGetTypeID())
    {
      CFDictionaryApplyFunction((CFDictionaryRef)a1, (CFDictionaryApplierFunction)TAttributes::ApplyBaselineInfoValue, a2);
    }
  }
}

void TAttributes::ApplyBaselineReferenceInfoValue(TAttributes *this, __CFString *a2, TAttributes **a3, void *a4)
{
  uint64_t v6 = TAttributes::EnsureBaselineAttributes(*a3);
  CFStringRef v7 = (TBaselineAttributes *)v6;
  uint64_t v8 = (_OWORD *)(v6 + 136);
  if (!*(unsigned char *)(v6 + 264))
  {
    uint64_t v9 = 0;
    *(_OWORD *)(v6 + 232)  = 0u;
    *(_OWORD *)(v6 + 248)  = 0u;
    *(_OWORD *)(v6 + 200)  = 0u;
    *(_OWORD *)(v6 + 216)  = 0u;
    *(_OWORD *)(v6 + 168)  = 0u;
    *(_OWORD *)(v6 + 184)  = 0u;
    *uint64_t v8 = 0u;
    *(_OWORD *)(v6 + 152)  = 0u;
    do
    {
      uint64_t v10 = v6 + v9;
      *(unsigned char *)(v10 + 136)  = 0;
      *(unsigned char *)(v10 + 144)  = 0;
      v9 += 16;
    }
    while (v9 != 128);
    *(unsigned char *)(v6 + 264)  = 1;
  }
  if (CFEqual(this, @"CTBaselineReferenceFont"))
  {
    TBaselineAttributes::SetReferenceFont(v7, a2);
  }
  else
  {
    unsigned __int16 v12 = TBaselineAttributes::BaselineClassFromName(this, v11);
    if (v12 >= 0x100u)
    {
      uint64_t valuePtr = -1;
      if (a2)
      {
        unsigned __int8 v13 = v12;
        CFTypeID v14 = CFGetTypeID(a2);
        if (v14 == CFNumberGetTypeID() || v14 == CFBooleanGetTypeID())
        {
          CFNumberGetValue((CFNumberRef)a2, kCFNumberDoubleType, &valuePtr);
          Doubleint Value = *(double *)&valuePtr;
        }
        else
        {
          if (v14 != CFStringGetTypeID()) {
            return;
          }
          Doubleint Value = CFStringGetDoubleValue(a2);
        }
        uint64_t v16 = &v8[v13];
        *(double *)uint64_t v16 = DoubleValue;
        *((unsigned char *)v16 + 8)  = 1;
      }
    }
  }
}

void TBaselineAttributes::SetReferenceFont(TBaselineAttributes *this, void *a2)
{
  if (!*((unsigned char *)this + 264))
  {
    uint64_t v2 = 0;
    *(_OWORD *)((char *)this + 232)  = 0u;
    *(_OWORD *)((char *)this + 248)  = 0u;
    *(_OWORD *)((char *)this + 200)  = 0u;
    *(_OWORD *)((char *)this + 216)  = 0u;
    *(_OWORD *)((char *)this + 168)  = 0u;
    *(_OWORD *)((char *)this + 184)  = 0u;
    *(_OWORD *)((char *)this + 136)  = 0u;
    *(_OWORD *)((char *)this + 152)  = 0u;
    do
    {
      CFNumberRef v3 = (char *)this + v2;
      v3[136]  = 0;
      v3[144]  = 0;
      v2 += 16;
    }
    while (v2 != 128);
    *((unsigned char *)this + 264)  = 1;
  }
  TCFRef<__CTFont const*>::Retain((atomic_ullong *)this + 34, a2);
}

void TAttributes::HandleBaselineReferenceInfoAttribute(const void *a1, void *a2)
{
  if (a1)
  {
    CFTypeID v4 = CFGetTypeID(a1);
    if (v4 == CFDictionaryGetTypeID())
    {
      CFDictionaryApplyFunction((CFDictionaryRef)a1, (CFDictionaryApplierFunction)TAttributes::ApplyBaselineReferenceInfoValue, a2);
    }
  }
}

unsigned char *TAttributes::HandleBaselineClassAttribute(unsigned char *result, const __CFString *a2)
{
  if (result)
  {
    uint64_t result = (unsigned char *)TBaselineAttributes::BaselineClassFromName(result, a2);
    if ((unsigned __int16)result >= 0x100u)
    {
      char v3 = (char)result;
      uint64_t result = (unsigned char *)TAttributes::EnsureBaselineAttributes((TAttributes *)a2->isa);
      result[280]  = v3;
    }
  }
  return result;
}

uint64_t TAttributes::HandleWritingDirectionAttribute(uint64_t result, uint64_t a2)
{
  if (result) {
    *(_WORD *)(*(void *)a2 + 138) |= 8u;
  }
  return result;
}

uint64_t TAttributes::HandleRenderingStyleAttribute(uint64_t result, uint64_t a2)
{
  if (result) {
    *(_WORD *)(*(void *)a2 + 138) |= 0x80u;
  }
  return result;
}

uint64_t TAttributes::HandleRubyAnnotationAttribute(uint64_t result, uint64_t a2)
{
  if (result) {
    *(_WORD *)(*(void *)a2 + 138) |= 0x800u;
  }
  return result;
}

const __CFDictionary *TAttributes::HandleTextEncapsulationAttribute(const __CFDictionary *result, TAttributes **a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  if (result)
  {
    CFDictionaryRef v3 = result;
    CFTypeID v4 = CFGetTypeID(result);
    uint64_t result = (const __CFDictionary *)CFDictionaryGetTypeID();
    if ((const __CFDictionary *)v4 == result)
    {
      uint64_t v5 = *a2;
      *((_WORD *)v5 + 69)  = *((_WORD *)*a2 + 69) | 0x8000;
      uint64_t v6 = (void *)TAttributes::EnsureRareData(v5);
      v6[9]  = v3;
      CFStringRef v7 = (unsigned __int8 *)v6[10];
      if (!v7)
      {
        uint64_t v8 = operator new(0x50uLL);
        v8[1]  = 0;
        v8[2]  = 0;
        *uint64_t v8 = &unk_1ED0622B0;
        TextEncapsulationData::TextEncapsulationData((TextEncapsulationData *)(v8 + 3), v3);
        uint64_t v9 = (std::__shared_weak_count *)v6[11];
        v6[10]  = v7;
        v6[11]  = v8;
        if (v9)
        {
          std::__shared_weak_count::__release_shared[abi:nn180100](v9);
          CFStringRef v7 = (unsigned __int8 *)v6[10];
        }
      }
      __int16 v10 = *v7 | (v7[3] << 8);
      long long v25 = &unk_1ED060938;
      unint64_t v26 = 0xAAAAAAAAAAAAAAAALL;
      LOWORD(v26)  = v10;
      unint64_t v27 = 0xAAAAAAAAAAAAAAAALL;
      long long v28 = &v25;
      CFStringRef v11 = (uint64_t *)a2[6];
      unint64_t v13 = v11[1];
      unint64_t v12 = v11[2];
      if (v13 >= v12)
      {
        uint64_t v15 = (uint64_t)(v13 - *v11) >> 5;
        if ((unint64_t)(v15 + 1) >> 59) {
          abort();
        }
        uint64_t v16 = v12 - *v11;
        uint64_t v17 = v16 >> 4;
        if (v16 >> 4 <= (unint64_t)(v15 + 1)) {
          uint64_t v17 = v15 + 1;
        }
        if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v18 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v18 = v17;
        }
        long long v24 = v11 + 3;
        if (v18) {
          uint64_t v19 = TInlineBufferAllocator<DecorationOverride,30ul>::allocate((uint64_t)(v11 + 3), v18);
        }
        else {
          uint64_t v19 = 0;
        }
        unint64_t v20 = v19;
        unint64_t v21 = &v19[32 * v15];
        uint64_t v23 = &v19[32 * v18];
        std::__function::__value_func<void ()(TAttributes &)>::__value_func[abi:nn180100]((uint64_t)v21, (uint64_t)&v25);
        uint64_t v22 = v21 + 32;
        std::vector<std::function<void ()(TAttributes &)>,TInlineBufferAllocator<std::function<void ()(TAttributes &)>,30ul>>::__swap_out_circular_buffer(v11, &v20);
        uint64_t v14 = v11[1];
        std::__split_buffer<std::function<void ()(TAttributes &)>,TInlineBufferAllocator<std::function<void ()(TAttributes &)>,30ul> &>::~__split_buffer((uint64_t)&v20);
      }
      else
      {
        std::__function::__value_func<void ()(TAttributes &)>::__value_func[abi:nn180100](v11[1], (uint64_t)&v25);
        uint64_t v14 = v13 + 32;
      }
      v11[1]  = v14;
      return (const __CFDictionary *)std::__function::__value_func<void ()(TAttributes &)>::~__value_func[abi:nn180100](&v25);
    }
  }
  return result;
}

uint64_t TAttributes::HandleTextEncapsulationAttributeNeue(NSTextEncapsulation *a1, TAttributes **a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  objc_opt_class();
  uint64_t result = objc_opt_isKindOfClass();
  if (result)
  {
    uint64_t v5 = *a2;
    *((_WORD *)v5 + 69)  = *((_WORD *)*a2 + 69) | 0x8000;
    uint64_t v6 = (void *)TAttributes::EnsureRareData(v5);
    v6[9]  = a1;
    CFStringRef v7 = (unsigned __int8 *)v6[10];
    if (!v7)
    {
      uint64_t v8 = operator new(0x50uLL);
      v8[1]  = 0;
      v8[2]  = 0;
      *uint64_t v8 = &unk_1ED0622B0;
      TextEncapsulationData::TextEncapsulationData((TextEncapsulationData *)(v8 + 3), a1);
      uint64_t v9 = (std::__shared_weak_count *)v6[11];
      v6[10]  = v7;
      v6[11]  = v8;
      if (v9)
      {
        std::__shared_weak_count::__release_shared[abi:nn180100](v9);
        CFStringRef v7 = (unsigned __int8 *)v6[10];
      }
    }
    __int16 v10 = *v7 | (v7[3] << 8);
    long long v25 = &unk_1ED060980;
    unint64_t v26 = 0xAAAAAAAAAAAAAAAALL;
    LOWORD(v26)  = v10;
    unint64_t v27 = 0xAAAAAAAAAAAAAAAALL;
    long long v28 = &v25;
    CFStringRef v11 = (uint64_t *)a2[6];
    unint64_t v13 = v11[1];
    unint64_t v12 = v11[2];
    if (v13 >= v12)
    {
      uint64_t v15 = (uint64_t)(v13 - *v11) >> 5;
      if ((unint64_t)(v15 + 1) >> 59) {
        abort();
      }
      uint64_t v16 = v12 - *v11;
      uint64_t v17 = v16 >> 4;
      if (v16 >> 4 <= (unint64_t)(v15 + 1)) {
        uint64_t v17 = v15 + 1;
      }
      if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFE0) {
        unint64_t v18 = 0x7FFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v18 = v17;
      }
      long long v24 = v11 + 3;
      if (v18) {
        uint64_t v19 = TInlineBufferAllocator<DecorationOverride,30ul>::allocate((uint64_t)(v11 + 3), v18);
      }
      else {
        uint64_t v19 = 0;
      }
      unint64_t v20 = v19;
      unint64_t v21 = &v19[32 * v15];
      uint64_t v23 = &v19[32 * v18];
      std::__function::__value_func<void ()(TAttributes &)>::__value_func[abi:nn180100]((uint64_t)v21, (uint64_t)&v25);
      uint64_t v22 = v21 + 32;
      std::vector<std::function<void ()(TAttributes &)>,TInlineBufferAllocator<std::function<void ()(TAttributes &)>,30ul>>::__swap_out_circular_buffer(v11, &v20);
      uint64_t v14 = v11[1];
      std::__split_buffer<std::function<void ()(TAttributes &)>,TInlineBufferAllocator<std::function<void ()(TAttributes &)>,30ul> &>::~__split_buffer((uint64_t)&v20);
    }
    else
    {
      std::__function::__value_func<void ()(TAttributes &)>::__value_func[abi:nn180100](v11[1], (uint64_t)&v25);
      uint64_t v14 = v13 + 32;
    }
    v11[1]  = v14;
    return (uint64_t)std::__function::__value_func<void ()(TAttributes &)>::~__value_func[abi:nn180100](&v25);
  }
  return result;
}

uint64_t TAttributes::HandleTrimWhitespaceBackgroundAttribute(uint64_t result, uint64_t a2)
{
  if (result) {
    *(unsigned char *)(*(void *)a2 + 137) |= 8u;
  }
  return result;
}

const void *TAttributes::HandleImposedGlyphAttribute(const void *result, uint64_t a2)
{
  if (result)
  {
    CFTypeID v3 = CFGetTypeID(result);
    uint64_t result = (const void *)CFNumberGetTypeID();
    if ((const void *)v3 == result) {
      *(_WORD *)(*(void *)a2 + 138) |= 0x10u;
    }
  }
  return result;
}

void *TAttributes::HandlePaletteAttribute(void *result, uint64_t a2)
{
  v16[4]  = *MEMORY[0x1E4F143B8];
  if (result)
  {
    v16[0]  = &unk_1ED060860;
    v16[1]  = result;
    v16[2]  = 0xAAAAAAAAAAAAAAAALL;
    atomic_ullong v16[3] = v16;
    uint64_t v2 = *(uint64_t **)(a2 + 48);
    unint64_t v4 = v2[1];
    unint64_t v3 = v2[2];
    if (v4 >= v3)
    {
      uint64_t v6 = (uint64_t)(v4 - *v2) >> 5;
      if ((unint64_t)(v6 + 1) >> 59) {
        abort();
      }
      uint64_t v7 = v3 - *v2;
      uint64_t v8 = v7 >> 4;
      if (v7 >> 4 <= (unint64_t)(v6 + 1)) {
        uint64_t v8 = v6 + 1;
      }
      if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFE0) {
        unint64_t v9 = 0x7FFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v9 = v8;
      }
      uint64_t v15 = v2 + 3;
      if (v9) {
        __int16 v10 = TInlineBufferAllocator<DecorationOverride,30ul>::allocate((uint64_t)(v2 + 3), v9);
      }
      else {
        __int16 v10 = 0;
      }
      CFStringRef v11 = v10;
      unint64_t v12 = &v10[32 * v6];
      uint64_t v14 = &v10[32 * v9];
      std::__function::__value_func<void ()(TAttributes &)>::__value_func[abi:nn180100]((uint64_t)v12, (uint64_t)v16);
      unint64_t v13 = v12 + 32;
      std::vector<std::function<void ()(TAttributes &)>,TInlineBufferAllocator<std::function<void ()(TAttributes &)>,30ul>>::__swap_out_circular_buffer(v2, &v11);
      uint64_t v5 = v2[1];
      std::__split_buffer<std::function<void ()(TAttributes &)>,TInlineBufferAllocator<std::function<void ()(TAttributes &)>,30ul> &>::~__split_buffer((uint64_t)&v11);
    }
    else
    {
      std::__function::__value_func<void ()(TAttributes &)>::__value_func[abi:nn180100](v2[1], (uint64_t)v16);
      uint64_t v5 = v4 + 32;
    }
    v2[1]  = v5;
    return std::__function::__value_func<void ()(TAttributes &)>::~__value_func[abi:nn180100](v16);
  }
  return result;
}

uint64_t TAttributes::HandleEmojiImageProviderAttribute(uint64_t result, uint64_t a2)
{
  if (result) {
    *(_WORD *)(*(void *)a2 + 138) |= 4u;
  }
  return result;
}

uint64_t TAttributes::HandleRunMetricsDelegateAttribute(uint64_t a1, uint64_t a2)
{
  objc_opt_class();
  uint64_t result = objc_opt_isKindOfClass();
  if (result) {
    *(_WORD *)(*(void *)a2 + 138) |= 2u;
  }
  return result;
}

unint64_t CTFontCopyTextScaleRecipeForStringAttributes(atomic_ullong ***a1, CFDictionaryRef theDict)
{
  int Value = (__CFString *)CFDictionaryGetValue(theDict, @"NSTextScale");
  if (Value != @"NSTextScaleSecondary" && (!Value || !CFEqual(Value, @"NSTextScaleSecondary"))) {
    return 0;
  }
  uint64_t v5 = (atomic_ullong **)CFDictionaryGetValue(theDict, @"NSFont");
  if (!v5) {
    return 0;
  }
  uint64_t v6 = v5;
  if (!CTFontGetTextStyle(v5)) {
    return 0;
  }
  CFNumberRef v7 = CustomRatioFromAttributes(theDict);
  unsigned __int8 v9 = v8;
  matched  = TextScaleWeightMatchVariableOnly(theDict);
  CopySecondaryScaleRecipeInternal((atomic_ullong *)&v13, a1, v6, (uint64_t)v7, v9, matched);
  unint64_t v11 = atomic_exchange((atomic_ullong *volatile)&v13, 0);

  return v11;
}

void TAttributes::PrimaryFont(atomic_ullong *this, uint64_t a2)
{
  *this  = 0;
  uint64_t v4 = *(void *)(a2 + 120);
  if (v4) {
    TCFRef<__CTFont const*>::Retain(this, (id)atomic_load_explicit((atomic_ullong *volatile)(v4 + 96), memory_order_acquire));
  }
  if (!atomic_load_explicit(this, memory_order_acquire))
  {
    uint64_t explicit = (void *)atomic_load_explicit((atomic_ullong *volatile)(a2 + 16), memory_order_acquire);
    TCFRef<__CTFont const*>::Retain(this, explicit);
  }
}

uint64_t (*TAttributes::ApplyFontAttributeHandlers(TAttributes *this, const void *a2, const void *a3, void *a4))(const void *, const void *)
{
  if (qword_1EB2CE308 != -1) {
    dispatch_once_f(&qword_1EB2CE308, 0, (dispatch_function_t)TAttributes::ApplyFontAttributeHandlers(void const*,void const*,void *)::$_0::__invoke);
  }
  uint64_t result = (uint64_t (*)(const void *, const void *))CFDictionaryGetValue((CFDictionaryRef)qword_1EB2CE300, this);
  if (result)
  {
    return (uint64_t (*)(const void *, const void *))result(a2, a3);
  }
  return result;
}

BOOL TAttributes::GetTabStopsPresent(TAttributes *this, const void *a2)
{
  uint64_t v3 = *((void *)this + 15);
  if (v3 && (*(_WORD *)(v3 + 66) & 2) != 0) {
    return 0;
  }
  uint64_t v4 = (TParagraphStyle **)*((void *)this + 16);
  if (!v4 || TParagraphStyle::GetTabStops(v4, a2)) {
    return 1;
  }
  TParagraphStyle::GetDefaultTabInterval(*((TParagraphStyle ***)this + 16), v5);
  return v7 != 0.0;
}

uint64_t TAttributes::GetTabStopForLocation(TAttributes *this, long double a2, TTextTab *a3)
{
  uint64_t v6 = *((void *)this + 15);
  if (v6 && (*(_WORD *)(v6 + 66) & 2) != 0) {
    return 0;
  }
  double v7 = (TParagraphStyle **)*((void *)this + 16);
  if (!v7)
  {
    if (a2 < 336.0)
    {
      long double v22 = fmod(a2, 28.0);
      char v21 = 0;
      double v20 = a2 + 28.0 - v22;
      goto LABEL_16;
    }
    return 0;
  }
  TabStops  = (const __CFArray *)TParagraphStyle::GetTabStops(v7, a3);
  double v10 = 0.0;
  if (!TabStops) {
    goto LABEL_12;
  }
  CFArrayRef v11 = TabStops;
  Table  = GetTable();
  double v13 = 0.0002;
  if (Table)
  {
    uint64_t v14 = (double *)*((void *)Table + 8);
    if (v14) {
      double v13 = *v14;
    }
  }
  CFIndex Count = CFArrayGetCount(v11);
  if (!Count)
  {
LABEL_12:
    TParagraphStyle::GetDefaultTabInterval(*((TParagraphStyle ***)this + 16), v9);
    if (v19 != 0.0)
    {
      double v20 = v10 + v19 * (floor((a2 + 0.00000011920929 - v10) / v19) + 1.0);
      char v21 = 4;
LABEL_16:
      *(double *)a3  = v20;
      *((unsigned char *)a3 + 8)  = v21;
      uint64_t result = 1;
      *((void *)a3 + 2)  = 0;
      return result;
    }
    return 0;
  }
  CFIndex v16 = Count;
  CFIndex v17 = 0;
  while (1)
  {
    CFStringRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(v11, v17);
    TTextTab::SetTabRef(a3, ValueAtIndex);
    double v10 = *(double *)a3;
    if (*(double *)a3 - a2 > v13) {
      return 1;
    }
    if (v16 == ++v17) {
      goto LABEL_12;
    }
  }
}

void TAttributes::CopyForegroundColorForContext(TAttributes *this@<X0>, CGContext *a2@<X1>, const __CFString **a3@<X2>, CGColorRef *a4@<X8>)
{
  if (*((unsigned char *)this + 136))
  {
    FillColorAsColor  = (void *)CGContextGetFillColorAsColor();
LABEL_11:
    CGColorRef v9 = FillColorAsColor;
    goto LABEL_13;
  }
  ForegroundColor  = (void *)TAttributes::GetForegroundColor((TAttributes *)atomic_load_explicit((atomic_ullong *volatile)this, memory_order_acquire), a2, a3);
  if (!ForegroundColor
    && ((*((unsigned char *)this + 136) & 2) == 0
     || (ForegroundColor  = (void *)atomic_load_explicit((atomic_ullong *volatile)this + 4, memory_order_acquire)) == 0))
  {
    if (qword_1EB2CE328 != -1) {
      dispatch_once_f(&qword_1EB2CE328, 0, (dispatch_function_t)GetBlackColor(void)::$_0::__invoke);
    }
    FillColorAsColor  = (void *)qword_1EB2CE320;
    goto LABEL_11;
  }
  CFTypeID v7 = CFGetTypeID(ForegroundColor);
  if (v7 == CGColorGetTypeID())
  {
    id v10 = ForegroundColor;
    *a4  = (CGColorRef)atomic_exchange((atomic_ullong *volatile)&v10, 0);

    return;
  }
  CGColorRef v9 = CopyCGColor(ForegroundColor);
LABEL_13:
  *a4  = v9;
}

const void *TAttributes::GetStrikethroughColor(TAttributes *this, uint64_t a2, const __CFString **a3)
{
  if (*((unsigned char *)this + 136)) {
    return (const void *)*MEMORY[0x1E4F1D260];
  }
  uint64_t result = TAttributes::GetStrikethroughColor((TAttributes *)atomic_load_explicit((atomic_ullong *volatile)this, memory_order_acquire), 0, a3);
  if (!result)
  {
    if ((*((unsigned char *)this + 136) & 2) != 0) {
      return (const void *)atomic_load_explicit((atomic_ullong *volatile)this + 4, memory_order_acquire);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t *std::vector<std::function<void ()(TAttributes &)>,TInlineBufferAllocator<std::function<void ()(TAttributes &)>,30ul>>::__swap_out_circular_buffer(uint64_t *result, void *a2)
{
  uint64_t v3 = result;
  uint64_t v5 = *result;
  uint64_t v4 = result[1];
  uint64_t v6 = a2[1];
  if (v4 == *result)
  {
    uint64_t v7 = a2[1];
  }
  else
  {
    do
    {
      uint64_t v7 = v6 - 32;
      uint64_t v8 = v4 - 32;
      uint64_t v9 = *(void *)(v4 - 8);
      if (v9)
      {
        if (v8 == v9)
        {
          *(void *)(v6 - 8)  = v7;
          uint64_t result = (uint64_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v4 - 8) + 24))(*(void *)(v4 - 8), v7);
        }
        else
        {
          *(void *)(v6 - 8)  = v9;
          *(void *)(v4 - 8)  = 0;
        }
      }
      else
      {
        *(void *)(v6 - 8)  = 0;
      }
      uint64_t v4 = v8;
      uint64_t v6 = v7;
    }
    while (v8 != v5);
  }
  a2[1]  = v7;
  uint64_t v10 = *v3;
  *uint64_t v3 = v7;
  a2[1]  = v10;
  uint64_t v11 = v3[1];
  v3[1]  = a2[2];
  a2[2]  = v11;
  uint64_t v12 = v3[2];
  v3[2]  = a2[3];
  a2[3]  = v12;
  *a2  = a2[1];
  return result;
}

uint64_t std::__split_buffer<std::function<void ()(TAttributes &)>,TInlineBufferAllocator<std::function<void ()(TAttributes &)>,30ul> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16)  = i - 32;
    std::__function::__value_func<void ()(TAttributes &)>::~__value_func[abi:nn180100]((void *)(i - 32));
  }
  uint64_t v4 = *(void **)a1;
  if (*(void *)a1)
  {
    unint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = (void *)(v5 + 960);
    if (v5 <= (unint64_t)v4 && v6 > v4)
    {
      if (*(void *)(a1 + 24) == *v6) {
        *uint64_t v6 = v4;
      }
    }
    else
    {
      operator delete(v4);
    }
  }
  return a1;
}

void TCFMutableDictionary::TCFMutableDictionary(TCFMutableDictionary *this, id a2)
{
  if (a2) {
    CFMutableDictionaryRef Mutable = (CFMutableDictionaryRef)a2;
  }
  else {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  }
  *(void *)this  = Mutable;
}

void TAttributes::ApplyFontAttributeHandlers(void const*,void const*,void *)::$_0::__invoke()
{
  keys[7]  = *(void **)MEMORY[0x1E4F143B8];
  keys[0]  = @"NSLigature";
  keys[1]  = @"CTSuperscript";
  keys[2]  = @"NSCharacterShape";
  keys[3]  = @"CTHorizontalInVerticalForms";
  keys[4]  = @"CTPalette";
  keys[5]  = @"CTTextEncapsulation";
  keys[6]  = @"NSTextEncapsulation";
  *(_OWORD *)id values = xmmword_1ED062880;
  long long v2 = *(_OWORD *)&off_1ED062890;
  long long v3 = xmmword_1ED0628A0;
  uint64_t v4 = off_1ED0628B0;
  id v0 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)keys, (const void **)values, 7, MEMORY[0x1E4F1D530], 0);
  qword_1EB2CE300  = atomic_exchange((atomic_ullong *volatile)&v0, 0);
}

CGColorRef GetBlackColor(void)::$_0::__invoke()
{
  CGColorRef result = CGColorGetConstantColor((CFStringRef)*MEMORY[0x1E4F1DB60]);
  qword_1EB2CE320  = (uint64_t)result;
  return result;
}

void *std::__function::__value_func<void ()(TAttributes &)>::~__value_func[abi:nn180100](void *a1)
{
  long long v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__function::__value_func<void ()(TAttributes &)>::__value_func[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24)  = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24)  = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24)  = 0;
  }
  return a1;
}

void std::__function::__func<TAttributes::HandleSuperscriptAttribute(void const*,TAttributes::AttributeHandlerContext *)::$_0,std::allocator<TAttributes::HandleSuperscriptAttribute(void const*,TAttributes::AttributeHandlerContext *)::$_0>,void ()(TAttributes&)>::~__func()
{
}

_WORD *std::__function::__func<TAttributes::HandleSuperscriptAttribute(void const*,TAttributes::AttributeHandlerContext *)::$_0,std::allocator<TAttributes::HandleSuperscriptAttribute(void const*,TAttributes::AttributeHandlerContext *)::$_0>,void ()(TAttributes&)>::__clone(uint64_t a1)
{
  CGColorRef result = operator new(0x10uLL);
  *(void *)CGColorRef result = &unk_1ED0608A8;
  result[4]  = *(_WORD *)(a1 + 8);
  return result;
}

uint64_t std::__function::__func<TAttributes::HandleSuperscriptAttribute(void const*,TAttributes::AttributeHandlerContext *)::$_0,std::allocator<TAttributes::HandleSuperscriptAttribute(void const*,TAttributes::AttributeHandlerContext *)::$_0>,void ()(TAttributes&)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2  = &unk_1ED0608A8;
  *(_WORD *)(a2 + 8)  = *(_WORD *)(result + 8);
  return result;
}

void std::__function::__func<TAttributes::HandleSuperscriptAttribute(void const*,TAttributes::AttributeHandlerContext *)::$_0,std::allocator<TAttributes::HandleSuperscriptAttribute(void const*,TAttributes::AttributeHandlerContext *)::$_0>,void ()(TAttributes&)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (atomic_ullong *)(a2 + 16);
  CreateCopyOfFontWithFeature((const __CTFont *)&v4, atomic_load_explicit((atomic_ullong *volatile)(a2 + 16), memory_order_acquire), 10, *(unsigned __int16 *)(a1 + 8));
  if (atomic_load_explicit((atomic_ullong *volatile)&v4, memory_order_acquire))
  {

    *(unsigned char *)(a2 + 48)  = 1;
  }
}

void std::__function::__func<TAttributes::HandleCharacterShapeAttribute(void const*,TAttributes::AttributeHandlerContext *)::$_0,std::allocator<TAttributes::HandleCharacterShapeAttribute(void const*,TAttributes::AttributeHandlerContext *)::$_0>,void ()(TAttributes&)>::~__func()
{
}

_WORD *std::__function::__func<TAttributes::HandleCharacterShapeAttribute(void const*,TAttributes::AttributeHandlerContext *)::$_0,std::allocator<TAttributes::HandleCharacterShapeAttribute(void const*,TAttributes::AttributeHandlerContext *)::$_0>,void ()(TAttributes&)>::__clone(uint64_t a1)
{
  CGColorRef result = operator new(0x10uLL);
  *(void *)CGColorRef result = &unk_1ED0608F0;
  result[4]  = *(_WORD *)(a1 + 8);
  return result;
}

uint64_t std::__function::__func<TAttributes::HandleCharacterShapeAttribute(void const*,TAttributes::AttributeHandlerContext *)::$_0,std::allocator<TAttributes::HandleCharacterShapeAttribute(void const*,TAttributes::AttributeHandlerContext *)::$_0>,void ()(TAttributes&)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2  = &unk_1ED0608F0;
  *(_WORD *)(a2 + 8)  = *(_WORD *)(result + 8);
  return result;
}

void std::__function::__func<TAttributes::HandleCharacterShapeAttribute(void const*,TAttributes::AttributeHandlerContext *)::$_0,std::allocator<TAttributes::HandleCharacterShapeAttribute(void const*,TAttributes::AttributeHandlerContext *)::$_0>,void ()(TAttributes&)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (atomic_ullong *)(a2 + 16);
  CreateCopyOfFontWithFeature((const __CTFont *)&v4, atomic_load_explicit((atomic_ullong *volatile)(a2 + 16), memory_order_acquire), 20, *(unsigned __int16 *)(a1 + 8));
  if (atomic_load_explicit((atomic_ullong *volatile)&v4, memory_order_acquire))
  {

    *(unsigned char *)(a2 + 48)  = 1;
  }
}

void std::__function::__func<TAttributes::HandleHorizontalInVerticalFormsAttribute(void const*,TAttributes::AttributeHandlerContext *)::$_0,std::allocator<TAttributes::HandleHorizontalInVerticalFormsAttribute(void const*,TAttributes::AttributeHandlerContext *)::$_0>,void ()(TAttributes&)>::~__func()
{
}

void *std::__function::__func<TAttributes::HandleHorizontalInVerticalFormsAttribute(void const*,TAttributes::AttributeHandlerContext *)::$_0,std::allocator<TAttributes::HandleHorizontalInVerticalFormsAttribute(void const*,TAttributes::AttributeHandlerContext *)::$_0>,void ()(TAttributes&)>::__clone()
{
  CGColorRef result = operator new(0x10uLL);
  *CGColorRef result = &unk_1ED0609C8;
  return result;
}

void std::__function::__func<TAttributes::HandleHorizontalInVerticalFormsAttribute(void const*,TAttributes::AttributeHandlerContext *)::$_0,std::allocator<TAttributes::HandleHorizontalInVerticalFormsAttribute(void const*,TAttributes::AttributeHandlerContext *)::$_0>,void ()(TAttributes&)>::__clone(uint64_t a1, void *a2)
{
  *a2  = &unk_1ED0609C8;
}

void std::__function::__func<TAttributes::HandleHorizontalInVerticalFormsAttribute(void const*,TAttributes::AttributeHandlerContext *)::$_0,std::allocator<TAttributes::HandleHorizontalInVerticalFormsAttribute(void const*,TAttributes::AttributeHandlerContext *)::$_0>,void ()(TAttributes&)>::operator()(int a1, TAttributes *this)
{
  if (*((unsigned char *)this + 50)) {
    TAttributes::ApplyTateChuYoko(this);
  }
}

void std::__shared_ptr_emplace<TextEncapsulationData>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable  = (std::__shared_weak_count_vtbl *)&unk_1ED0622B0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TextEncapsulationData>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable  = (std::__shared_weak_count_vtbl *)&unk_1ED0622B0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1853275C0);
}

void std::__function::__func<TAttributes::HandleTextEncapsulationAttribute(void const*,TAttributes::AttributeHandlerContext *)::$_0,std::allocator<TAttributes::HandleTextEncapsulationAttribute(void const*,TAttributes::AttributeHandlerContext *)::$_0>,void ()(TAttributes&)>::~__func()
{
}

_WORD *std::__function::__func<TAttributes::HandleTextEncapsulationAttribute(void const*,TAttributes::AttributeHandlerContext *)::$_0,std::allocator<TAttributes::HandleTextEncapsulationAttribute(void const*,TAttributes::AttributeHandlerContext *)::$_0>,void ()(TAttributes&)>::__clone(uint64_t a1)
{
  CGColorRef result = operator new(0x10uLL);
  *(void *)CGColorRef result = &unk_1ED060938;
  result[4]  = *(_WORD *)(a1 + 8);
  return result;
}

uint64_t std::__function::__func<TAttributes::HandleTextEncapsulationAttribute(void const*,TAttributes::AttributeHandlerContext *)::$_0,std::allocator<TAttributes::HandleTextEncapsulationAttribute(void const*,TAttributes::AttributeHandlerContext *)::$_0>,void ()(TAttributes&)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2  = &unk_1ED060938;
  *(_WORD *)(a2 + 8)  = *(_WORD *)(result + 8);
  return result;
}

void std::__function::__func<TAttributes::HandleTextEncapsulationAttribute(void const*,TAttributes::AttributeHandlerContext *)::$_0,std::allocator<TAttributes::HandleTextEncapsulationAttribute(void const*,TAttributes::AttributeHandlerContext *)::$_0>,void ()(TAttributes&)>::operator()(uint64_t a1, uint64_t a2)
{
  id v14 = (id)0xAAAAAAAAAAAAAAAALL;
  TAttributes::PrimaryFont((atomic_ullong *)&v14, a2);
  uint64_t explicit = (const __CTFont *)atomic_load_explicit((atomic_ullong *volatile)&v14, memory_order_acquire);
  if (explicit)
  {
    uint64_t v5 = *((void *)explicit + 5);
    uint64_t v6 = a2 + 120;
    uint64_t v7 = *(void *)(*(void *)(a2 + 120) + 80);
    *(void *)(v7 + 32)  = *(void *)(v5 + 16);
    if (*(_DWORD *)(v5 + 48))
    {
      inited  = (int *)(v5 + 48);
    }
    else
    {
      inited  = TFont::InitStrikeMetrics((TFont *)v5);
      uint64_t v7 = *(void *)(*(void *)v6 + 80);
    }
    uint64_t v9 = *((void *)inited + 4);
  }
  else
  {
    uint64_t v6 = a2 + 120;
    uint64_t v7 = *(void *)(*(void *)(a2 + 120) + 80);
    *(void *)(v7 + 32)  = 0;
    uint64_t v9 = 0;
  }
  *(void *)(v7 + 48)  = v9;
  Weight  = CTFontGetWeight((uint64_t)explicit);
  ClassOfWeight  = TTextEncapsulationRun::GetClassOfWeight(v11, Weight);
  *(_WORD *)(*(void *)(*(void *)v6 + 80) + 40)  = ClassOfWeight;
  TTextEncapsulationRun::CreateEncapsulationFont(explicit, ClassOfWeight, *(unsigned __int8 *)(a1 + 9), *(unsigned __int8 *)(a1 + 8), (CTFontRef *)&v13);
  if (atomic_load_explicit((atomic_ullong *volatile)&v13, memory_order_acquire))
  {

    *(unsigned char *)(a2 + 48)  = 1;
  }
}

void std::__function::__func<TAttributes::HandleTextEncapsulationAttributeNeue(void const*,TAttributes::AttributeHandlerContext *)::$_0,std::allocator<TAttributes::HandleTextEncapsulationAttributeNeue(void const*,TAttributes::AttributeHandlerContext *)::$_0>,void ()(TAttributes&)>::~__func()
{
}

_WORD *std::__function::__func<TAttributes::HandleTextEncapsulationAttributeNeue(void const*,TAttributes::AttributeHandlerContext *)::$_0,std::allocator<TAttributes::HandleTextEncapsulationAttributeNeue(void const*,TAttributes::AttributeHandlerContext *)::$_0>,void ()(TAttributes&)>::__clone(uint64_t a1)
{
  CGColorRef result = operator new(0x10uLL);
  *(void *)CGColorRef result = &unk_1ED060980;
  result[4]  = *(_WORD *)(a1 + 8);
  return result;
}

uint64_t std::__function::__func<TAttributes::HandleTextEncapsulationAttributeNeue(void const*,TAttributes::AttributeHandlerContext *)::$_0,std::allocator<TAttributes::HandleTextEncapsulationAttributeNeue(void const*,TAttributes::AttributeHandlerContext *)::$_0>,void ()(TAttributes&)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2  = &unk_1ED060980;
  *(_WORD *)(a2 + 8)  = *(_WORD *)(result + 8);
  return result;
}

void std::__function::__func<TAttributes::HandleTextEncapsulationAttributeNeue(void const*,TAttributes::AttributeHandlerContext *)::$_0,std::allocator<TAttributes::HandleTextEncapsulationAttributeNeue(void const*,TAttributes::AttributeHandlerContext *)::$_0>,void ()(TAttributes&)>::operator()(uint64_t a1, uint64_t a2)
{
  id v14 = (id)0xAAAAAAAAAAAAAAAALL;
  TAttributes::PrimaryFont((atomic_ullong *)&v14, a2);
  uint64_t explicit = (const __CTFont *)atomic_load_explicit((atomic_ullong *volatile)&v14, memory_order_acquire);
  if (explicit)
  {
    uint64_t v5 = *((void *)explicit + 5);
    uint64_t v6 = a2 + 120;
    uint64_t v7 = *(void *)(*(void *)(a2 + 120) + 80);
    *(void *)(v7 + 32)  = *(void *)(v5 + 16);
    if (*(_DWORD *)(v5 + 48))
    {
      inited  = (int *)(v5 + 48);
    }
    else
    {
      inited  = TFont::InitStrikeMetrics((TFont *)v5);
      uint64_t v7 = *(void *)(*(void *)v6 + 80);
    }
    uint64_t v9 = *((void *)inited + 4);
  }
  else
  {
    uint64_t v6 = a2 + 120;
    uint64_t v7 = *(void *)(*(void *)(a2 + 120) + 80);
    *(void *)(v7 + 32)  = 0;
    uint64_t v9 = 0;
  }
  *(void *)(v7 + 48)  = v9;
  Weight  = CTFontGetWeight((uint64_t)explicit);
  ClassOfWeight  = TTextEncapsulationRun::GetClassOfWeight(v11, Weight);
  *(_WORD *)(*(void *)(*(void *)v6 + 80) + 40)  = ClassOfWeight;
  TTextEncapsulationRun::CreateEncapsulationFont(explicit, ClassOfWeight, *(unsigned __int8 *)(a1 + 9), *(unsigned __int8 *)(a1 + 8), (CTFontRef *)&v13);
  if (atomic_load_explicit((atomic_ullong *volatile)&v13, memory_order_acquire))
  {

    *(unsigned char *)(a2 + 48)  = 1;
  }
}

void std::__function::__func<TAttributes::HandlePaletteAttribute(void const*,TAttributes::AttributeHandlerContext *)::$_0,std::allocator<TAttributes::HandlePaletteAttribute(void const*,TAttributes::AttributeHandlerContext *)::$_0>,void ()(TAttributes&)>::~__func()
{
}

void *std::__function::__func<TAttributes::HandlePaletteAttribute(void const*,TAttributes::AttributeHandlerContext *)::$_0,std::allocator<TAttributes::HandlePaletteAttribute(void const*,TAttributes::AttributeHandlerContext *)::$_0>,void ()(TAttributes&)>::__clone(uint64_t a1)
{
  CGColorRef result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *CGColorRef result = &unk_1ED060860;
  result[1]  = v3;
  return result;
}

uint64_t std::__function::__func<TAttributes::HandlePaletteAttribute(void const*,TAttributes::AttributeHandlerContext *)::$_0,std::allocator<TAttributes::HandlePaletteAttribute(void const*,TAttributes::AttributeHandlerContext *)::$_0>,void ()(TAttributes&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2  = &unk_1ED060860;
  a2[1]  = v2;
  return result;
}

void std::__function::__func<TAttributes::HandlePaletteAttribute(void const*,TAttributes::AttributeHandlerContext *)::$_0,std::allocator<TAttributes::HandlePaletteAttribute(void const*,TAttributes::AttributeHandlerContext *)::$_0>,void ()(TAttributes&)>::operator()(uint64_t a1, uint64_t a2)
{
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(a2 + 16), memory_order_acquire);
  if (explicit)
  {
    id v4 = *(void **)(a1 + 8);
    TFont::CopyDescriptor(*(TFont **)(explicit + 40), 0, (atomic_ullong *)&keys);
    uint64_t v5 = (void *)atomic_exchange((atomic_ullong *volatile)&keys, 0);

    id v8 = v5;
    uint64_t v6 = (const __CTFontDescriptor *)atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire);
    id values = v4;
    id keys = @"CTFontPaletteAttribute";
    CFDictionaryRef v7 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    id keys = CTFontDescriptorCreateCopyWithAttributes(v6, v7);

    id keys = CTFontCreateWithFontDescriptor((CTFontDescriptorRef)atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire), 0.0, 0);
  }
  else
  {
    id keys = 0;
  }
  if (atomic_load_explicit((atomic_ullong *volatile)&keys, memory_order_acquire))
  {

    *(unsigned char *)(a2 + 48)  = 1;
  }
}

uint64_t OTL::GPOS::ApplySinglePos(uint64_t a1, unsigned __int16 *a2, uint64_t a3, unsigned int a4)
{
  unint64_t v7 = *(void *)(a1 + 40);
  id v8 = ValueForSinglePos(a2, v7, a4);
  uint64_t v10 = v8;
  if (v8)
  {
    unsigned int v11 = a2[2];
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)a2[2]);
    v12.i16[0]  = vaddlv_u8(v12);
    id v13 = &v8[v12.u32[0]];
    if (v8 >= a2 && v13 >= v8 && (unint64_t)v13 <= v7) {
      goto LABEL_16;
    }
    BOOL v16 = (unint64_t)(v8 + 1) <= v7 && v8 >= a2;
    unint64_t v17 = (v7 - (unint64_t)v8) >> 1;
    if (!v16) {
      unint64_t v17 = 0;
    }
    if (v17 != v12.u32[0])
    {
      char v9 = 0;
    }
    else
    {
LABEL_16:
      uint64_t v18 = *(void *)(a1 + 16);
      double v20 = v8;
      unsigned int v21 = __rev16(v11);
      long double v22 = a2;
      uint64_t v23 = v18;
      uint64_t v24 = a1;
      ValueRecord::operator()(&v20, *(TRunGlue **)a3, *(void *)(a3 + 48));
      char v9 = 1;
    }
  }
  return (v10 != 0) & v9;
}

unsigned __int16 *ValueForSinglePos(unsigned __int16 *a1, unint64_t a2, unsigned int a3)
{
  unsigned int v3 = bswap32(*a1) >> 16;
  if (v3 != 2)
  {
    if (v3 == 1 && (unint64_t)(a1 + 4) <= a2) {
      return a1 + 3;
    }
    return 0;
  }
  uint64_t v5 = a1 + 4;
  if ((unint64_t)(a1 + 4) > a2) {
    return 0;
  }
  uint64_t v6 = bswap32(a1[3]) >> 16;
  unint64_t v7 = (unint64_t)&v5[v6];
  unint64_t v8 = (unint64_t)(a1 + 5) <= a2 ? (a2 - (unint64_t)v5) >> 1 : 0;
  BOOL v9 = v7 <= a2 && v7 >= (unint64_t)v5;
  BOOL v10 = v9 || v8 == v6;
  if (!v10 || v6 < a3) {
    return 0;
  }
  uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)a1[2]);
  v11.i16[0]  = vaddlv_u8(v11);
  return &v5[v11.u32[0] * (unint64_t)(a3 - 1)];
}

uint64_t OTL::GPOS::GetSinglePosAdjustmentsForLookup(OTL::GPOS *this, const OTL::Lookup *a2, uint64_t a3, double *a4, double *a5)
{
  if (*((_WORD *)a2 + 8) == 1)
  {
    *a4  = 0.0;
    *a5  = 0.0;
    if (-21845 * (unsigned __int16)((*((_DWORD *)a2 + 24) - *((_DWORD *)a2 + 22)) >> 4))
    {
      uint64_t v9 = 0;
      unint64_t v10 = 0;
      uint64_t v11 = 48 * (unsigned __int16)(-21845 * ((*((_DWORD *)a2 + 24) - *((_DWORD *)a2 + 22)) >> 4));
      do
      {
        uint64_t v12 = *((void *)a2 + 11);
        if (0xAAAAAAAAAAAAAAABLL * ((*((void *)a2 + 12) - v12) >> 4) <= v10) {
          break;
        }
        uint64_t v13 = v12 + v9;
        id v14 = *(uint64_t (**)(void *, uint64_t))(v12 + v9 + 24);
        uint64_t v15 = *(void *)(v13 + 32);
        BOOL v16 = (void *)(v13 + (v15 >> 1) + 8);
        if (v15) {
          id v14 = *(uint64_t (**)(void *, uint64_t))(*v16 + v14);
        }
        unsigned int v17 = v14(v16, a3);
        if (v17)
        {
          uint64_t v18 = *((void *)a2 + 11);
          double v19 = 0xAAAAAAAAAAAAAAABLL * ((*((void *)a2 + 12) - v18) >> 4) <= v10
              ? 0
              : *(unsigned __int16 **)(v18 + v9);
          double v20 = ValueForSinglePos(v19, *((void *)this + 5), v17);
          if (v20)
          {
            long double v22 = v20;
            unsigned int v23 = bswap32(v19[2]);
            unsigned int v24 = HIWORD(v23);
            long long v25 = (atomic_ullong *)*((void *)this + 2);
            if ((v23 & 0x10000) != 0 && *v22) {
              *a4  = *a4 + (double)((int)bswap32(*v22) >> 16);
            }
            if ((v23 & 0x40000) != 0)
            {
              unsigned int v26 = v22[(HIWORD(v23) & 1) + ((v23 >> 17) & 1)];
              if (v26) {
                *a5  = *a5 + (double)((int)bswap32(v26) >> 16);
              }
            }
            if ((v24 & 0xF0) != 0)
            {
              unint64_t v33 = 0xAAAAAAAAAAAAAAAALL;
              VariationValues  = (const __int16 *)TFont::GetVariationValues(v25, &v33);
              if (VariationValues)
              {
                long long v28 = VariationValues;
                if ((v24 & 0x10) != 0)
                {
                  int v29 = 1;
                  long long v30 = v22;
                  do
                  {
                    v30 += (v29 & v24) != 0;
                    v29 *= 2;
                  }
                  while (v29 != 16);
                  if (*v30) {
                    *a4  = OTL::GDEF::DeltaValue(*((OTL::GDEF **)this + 3), (char *)v19, *((void *)this + 5), __rev16(*v30), v33, VariationValues)+ *a4;
                  }
                }
                if ((v24 & 0x40) != 0)
                {
                  for (int i = 1; i != 64; i *= 2)
                    v22 += (i & v24) != 0;
                  if (*v22) {
                    *a5  = OTL::GDEF::DeltaValue(*((OTL::GDEF **)this + 3), (char *)v19, *((void *)this + 5), __rev16(*v22), v33, v28)+ *a5;
                  }
                }
              }
            }
            return 1;
          }
        }
        ++v10;
        v9 += 48;
      }
      while (v11 != v9);
    }
  }
  return 0;
}

uint64_t TRunGlue::TGlyph::clearSafeToBreakAfter(uint64_t this)
{
  uint64_t v1 = *(TRunGlue **)this;
  if (*(void *)(*(void *)this + 152))
  {
    uint64_t v2 = *(void *)(this + 8);
    TRunGlue::FocusOnIndex(*(TRunGlue **)this, v2);
    uint64_t v3 = *((void *)v1 + 19);
    uint64_t v4 = v2 - *((void *)v1 + 20);
    uint64_t v5 = *(_DWORD *)(*((void *)v1 + 65) + 4 * v4) | 8u;
    uint64_t v6 = *(void **)(v3 + 216);
    uint64_t v7 = *(void *)(v3 + 200) + v4;
    return [v6 setProps:v5 atIndex:v7];
  }
  return this;
}

uint64_t OTL::GPOS::ApplyCursivePos(void *a1, uint64_t a2, TGlyphIterator *this, uint64_t a4, int a5, int a6)
{
  unint64_t v6 = a1[5];
  uint64_t v7 = (unsigned __int16 *)(a2 + 4);
  unint64_t v8 = a2 + 6;
  if ((unint64_t)(a2 + 4) < a1[4] || v8 > v6) {
    return 0;
  }
  uint64_t v11 = bswap32(*(unsigned __int16 *)(a2 + 4)) >> 16;
  unint64_t v12 = v8 + 4 * v11;
  unint64_t v13 = a2 + 10 <= v6 ? (v6 - v8) >> 2 : 0;
  BOOL v14 = v12 <= v6 && v12 >= v8;
  if (!v14 && v13 != v11) {
    return 0;
  }
  uint64_t v21 = *((void *)this + 6);
  if ((TGlyphIterator::Prev(this) & 1) == 0)
  {
    uint64_t result = 0;
    *((void *)this + 6)  = v21;
    return result;
  }
  uint64_t v22 = *((void *)this + 6);
  GlyphID  = TRunGlue::GetGlyphID(*(TRunGlue **)this, v22);
  unsigned int v24 = *(uint64_t (**)(void *, uint64_t))(a4 + 16);
  uint64_t v25 = *(void *)(a4 + 24);
  unsigned int v26 = (void *)(a4 + (v25 >> 1));
  if (v25) {
    unsigned int v24 = *(uint64_t (**)(void *, uint64_t))(*v26 + v24);
  }
  uint64_t result = v24(v26, GlyphID);
  *((void *)this + 6)  = v21;
  if (result)
  {
    if (a6) {
      int v28 = -*((_DWORD *)this + 2);
    }
    else {
      int v28 = *((_DWORD *)this + 2);
    }
    if (a6) {
      uint64_t v29 = v22;
    }
    else {
      uint64_t v29 = v21;
    }
    if (a6) {
      uint64_t v30 = v21;
    }
    else {
      uint64_t v30 = v22;
    }
    if (a6) {
      int v31 = a5;
    }
    else {
      int v31 = result;
    }
    if (a6) {
      int v32 = result;
    }
    else {
      int v32 = a5;
    }
    unsigned int v33 = v31 - 1;
    unsigned int v34 = bswap32(*v7);
    if (v33 >= HIWORD(v34)) {
      return 0;
    }
    unsigned int v35 = *(unsigned __int16 *)(a2 + 4 * v33 + 8);
    if (!v35) {
      return 0;
    }
    uint64_t v36 = a2 + __rev16(v35);
    if (v36 + 6 > v6) {
      return 0;
    }
    unsigned int v37 = v32 - 1;
    if (v37 >= HIWORD(v34)) {
      return 0;
    }
    unsigned int v38 = *(unsigned __int16 *)(a2 + 4 * v37 + 6);
    if (!v38) {
      return 0;
    }
    uint64_t v39 = a2 + __rev16(v38);
    if (v39 + 6 > v6) {
      return 0;
    }
    double v68 = NAN;
    double v69 = NAN;
    double v66 = NAN;
    double v67 = NAN;
    id v40 = (atomic_ullong *)a1[2];
    uint64_t v41 = (uint64_t)a1;
    uint64_t v42 = v30;
    uint64_t v43 = v29;
    GetAnchors(v36, v39, v40, v41, &v68, &v66);
    BOOL v44 = v28 < 0;
    if (v28 >= 0) {
      double v45 = v68 - v66;
    }
    else {
      double v45 = v66 - v68;
    }
    uint64_t v46 = v42;
    if (v44) {
      uint64_t v42 = v43;
    }
    TRunGlue::GetUnscaledPosition(*(TRunGlue **)this, v42);
    double v48 = v45 + v47;
    TRunGlue::GetUnscaledAdvance(*(TRunGlue **)this, v42);
    double v50 = v48 - v49;
    uint64_t v51 = *(void **)this;
    int v52 = *(unsigned __int8 *)(*(void *)this + 634);
    Advance  = TRunGlue::GetAdvance(*(TRunGlue **)this, v42);
    uint64_t v55 = 81;
    if (!v52) {
      uint64_t v55 = 80;
    }
    double v56 = Advance + *(double *)&v51[v55] * v50;
    TRunGlue::SetAdvance(v51, v42, *(CGSize *)(&v54 - 1));
    if (a6) {
      double v57 = v67 - v69;
    }
    else {
      double v57 = v69 - v67;
    }
    TRunGlue::GetUnscaledPosition(*(TRunGlue **)this, v22);
    double v59 = v57 + v58;
    TRunGlue::GetUnscaledPosition(*(TRunGlue **)this, v21);
    double v61 = v59 - v60;
    uint64_t v62 = *((void *)this + 6);
    *((void *)this + 6)  = v21;
    do
    {
      uint64_t v63 = *((void *)this + 6);
      uint64_t v64 = *(void *)this;
      uint64_t v65 = v63;
      TRunGlue::TGlyph::AdjustYPositionBy((TRunGlue::TGlyph *)&v64, v61);
      TRunGlue::OrGlyphProps(*(TRunGlue **)this, *((void *)this + 6), 0x2000u);
    }
    while (TGlyphIterator::Next(this, 1)
         && (TRunGlue::GetGlyphProps(*(TRunGlue **)this, *((void *)this + 6)) & 0x2000) != 0);
    *((void *)this + 6)  = v62;
    uint64_t v64 = *(void *)this;
    uint64_t v65 = v46;
    TRunGlue::TGlyph::clearSafeToBreakAfter((uint64_t)&v64);
    return 1;
  }
  return result;
}

uint64_t TGlyphIterator::Prev(TGlyphIterator *this)
{
  if (*((void *)this + 6) == *((void *)this + 2)) {
    return 0;
  }
  do
  {
    uint64_t v3 = *((int *)this + 2);
    uint64_t v4 = *((void *)this + 6) - v3;
    *((void *)this + 6)  = v4;
    if ((int)v3 < 1)
    {
      if ((v3 & 0x80000000) != 0 && v4 >= *((void *)this + 2)) {
        return 0;
      }
    }
    else if (v4 <= *((void *)this + 2))
    {
      return 0;
    }
  }
  while ((TGlyphIterator::CurrentGlyphIsIgnored(this, 0) & 1) != 0);
  return 1;
}

void GetAnchors(uint64_t a1, uint64_t a2, atomic_ullong *this, uint64_t a4, double *a5, double *a6)
{
  double v11 = (double)((int)bswap32(*(unsigned __int16 *)(a1 + 2)) >> 16);
  double v12 = (double)((int)bswap32(*(unsigned __int16 *)(a1 + 4)) >> 16);
  double v13 = (double)((int)bswap32(*(unsigned __int16 *)(a2 + 2)) >> 16);
  double v14 = (double)((int)bswap32(*(unsigned __int16 *)(a2 + 4)) >> 16);
  if (*(_WORD *)a1 == 768 || *(_WORD *)a2 == 768)
  {
    unint64_t v19 = 0xAAAAAAAAAAAAAAAALL;
    VariationValues  = (const __int16 *)TFont::GetVariationValues(this, &v19);
    if (VariationValues)
    {
      BOOL v16 = VariationValues;
      if (*(_WORD *)a1 == 768)
      {
        unint64_t v17 = v19;
        double v11 = OTL::GDEF::DeltaValue(*(OTL::GDEF **)(a4 + 24), (char *)a1, *(void *)(a4 + 40), bswap32(*(unsigned __int16 *)(a1 + 6)) >> 16, v19, VariationValues)+ v11;
        double v12 = OTL::GDEF::DeltaValue(*(OTL::GDEF **)(a4 + 24), (char *)a1, *(void *)(a4 + 40), bswap32(*(unsigned __int16 *)(a1 + 8)) >> 16, v17, v16)+ v12;
      }
      if (*(_WORD *)a2 == 768)
      {
        unint64_t v18 = v19;
        double v13 = OTL::GDEF::DeltaValue(*(OTL::GDEF **)(a4 + 24), (char *)a2, *(void *)(a4 + 40), bswap32(*(unsigned __int16 *)(a2 + 6)) >> 16, v19, v16)+ v13;
        double v14 = OTL::GDEF::DeltaValue(*(OTL::GDEF **)(a4 + 24), (char *)a2, *(void *)(a4 + 40), bswap32(*(unsigned __int16 *)(a2 + 8)) >> 16, v18, v16)+ v14;
      }
    }
  }
  *a5  = v11;
  a5[1]  = v12;
  *a6  = v13;
  a6[1]  = v14;
}

uint64_t **TRunGlue::TGlyph::AdjustYPositionBy(TRunGlue::TGlyph *this, double a2)
{
  uint64_t v4 = *(void *)this;
  if ((*(void *)(v4 + 152) || *(void *)(v4 + 192)) && !*(unsigned char *)(v4 + 634))
  {
    Origin  = TRunGlue::GetOrigin((TRunGlue *)v4, *((void *)this + 1));
    unint64_t v10 = *(void **)this;
    uint64_t v11 = *((void *)this + 1);
    double v13 = v12 + *(double *)(*(void *)this + 648) * a2;
    return (uint64_t **)TRunGlue::SetOrigin(v10, v11, *(CGPoint *)&Origin);
  }
  else
  {
    uint64_t result = std::__tree<std::__value_type<long,TGlyphDeltaListEntry>,std::__map_value_compare<long,std::__value_type<long,TGlyphDeltaListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TGlyphDeltaListEntry>>>::__emplace_unique_key_args<long,std::piecewise_construct_t const&,std::tuple<long const&>,std::tuple<>>(*(uint64_t ***)(v4 + 112), *((void *)this + 1), (uint64_t **)this + 1);
    double v6 = -0.0;
    if (*(unsigned char *)(*(void *)this + 634)) {
      double v7 = a2;
    }
    else {
      double v7 = -0.0;
    }
    if (!*(unsigned char *)(*(void *)this + 634)) {
      double v6 = a2;
    }
    double v8 = *((double *)result + 6) + v6;
    *((double *)result + 5)  = *((double *)result + 5) + v7;
    *((double *)result + 6)  = v8;
  }
  return result;
}

uint64_t OTL::GPOS::ApplyMarkBasePos(uint64_t a1, unsigned __int16 *a2, uint64_t a3, int a4)
{
  unint64_t v4 = *(void *)(a1 + 40);
  if (*(void *)(a1 + 32) > (unint64_t)a2 || (unint64_t)(a2 + 6) > v4) {
    return 0;
  }
  uint64_t v10 = *(void *)(a3 + 48);
  unint64_t v44 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v11 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v11 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  long long v42 = v11;
  long long v43 = v11;
  OTL::Coverage::Coverage((OTL::Coverage *)&v42, (unsigned __int16 *)((char *)a2 + (bswap32(a2[2]) >> 16)), v4, 1);
  uint64_t v12 = *(void *)(a3 + 56);
  if (TGlyphIterator::Prev((TGlyphIterator *)a3))
  {
    while (1)
    {
      uint64_t v13 = *(void *)(a3 + 48);
      if (v13 == v12) {
        break;
      }
      GlyphID  = TRunGlue::GetGlyphID(*(TRunGlue **)a3, *(void *)(a3 + 48));
      uint64_t v15 = *(OTL::ClassDefTable **)(*(void *)(a1 + 24) + 16);
      if (!v15 || OTL::ClassDefTable::ClassOf(v15, GlyphID) != 3)
      {
        BOOL v16 = (uint64_t (*)(void *, uint64_t))v43;
        unint64_t v17 = (void *)((char *)&v42 + (*((uint64_t *)&v43 + 1) >> 1));
        if (BYTE8(v43)) {
          BOOL v16 = *(uint64_t (**)(void *, uint64_t))(*v17 + v43);
        }
        LODWORD(result)  = v16(v17, GlyphID);
        if (result)
        {
          *(void *)(a3 + 48)  = v10;
          *(void *)(a3 + 56)  = v10;
          *(void *)(a3 + 64)  = v13;
          goto LABEL_24;
        }
        GlyphProps  = TRunGlue::GetGlyphProps(*(TRunGlue **)a3, v13);
        if ((GlyphProps & 0x10000000) != 0 || (GlyphProps & 0xF000000) == 0) {
          goto LABEL_17;
        }
      }
      if ((TGlyphIterator::Prev((TGlyphIterator *)a3) & 1) == 0) {
        goto LABEL_17;
      }
    }
    uint64_t v13 = *(void *)(a3 + 64);
    uint64_t v20 = TRunGlue::GetGlyphID(*(TRunGlue **)a3, v13);
    uint64_t v21 = (uint64_t (*)(void *, uint64_t))v43;
    uint64_t v22 = (void *)((char *)&v42 + (*((uint64_t *)&v43 + 1) >> 1));
    if (BYTE8(v43)) {
      uint64_t v21 = *(uint64_t (**)(void *, uint64_t))(*v22 + v43);
    }
    uint64_t result = v21(v22, v20);
    *(void *)(a3 + 48)  = v10;
    *(void *)(a3 + 56)  = v10;
    *(void *)(a3 + 64)  = v13;
    if (!result) {
      return result;
    }
LABEL_24:
    unsigned int v23 = (unsigned __int16 *)((char *)a2 + (bswap32(a2[4]) >> 16));
    unsigned int v24 = v23 + 1;
    if ((unint64_t)(v23 + 1) <= v4)
    {
      uint64_t v25 = bswap32(*v23) >> 16;
      unint64_t v26 = (unint64_t)&v24[2 * v25];
      unint64_t v27 = (unint64_t)(v23 + 3) <= v4 ? (v4 - (unint64_t)v24) >> 2 : 0;
      BOOL v28 = v26 <= v4 && v26 >= (unint64_t)v24;
      if (v28 || v27 == v25)
      {
        uint64_t v30 = (a4 - 1);
        if ((unint64_t)&v24[2 * v30 + 2] <= v4)
        {
          int v31 = &v23[2 * v30];
          if (v31[2])
          {
            uint64_t v32 = (uint64_t)v23 + __rev16(v31[2]);
            if (v32 + 6 <= v4)
            {
              unsigned int v33 = (unsigned __int16 *)((char *)a2 + (bswap32(a2[5]) >> 16));
              unsigned int v34 = v33 + 1;
              if ((unint64_t)(v33 + 1) <= v4)
              {
                unsigned int v35 = v31[1];
                uint64_t v36 = bswap32(*v33) >> 16;
                unint64_t v37 = (unint64_t)&v34[v36];
                unint64_t v38 = (unint64_t)(v33 + 2) <= v4 ? (v4 - (unint64_t)v34) >> 1 : 0;
                BOOL v39 = v37 <= v4 && v37 >= (unint64_t)v34;
                if (v39 || v38 == v36)
                {
                  uint64_t v40 = (bswap32(v35) >> 16) + (result - 1) * (bswap32(a2[3]) >> 16);
                  if ((unint64_t)&v34[v40 + 1] <= v4)
                  {
                    if (v33[v40 + 1])
                    {
                      uint64_t v41 = (uint64_t)v33 + __rev16(v33[v40 + 1]);
                      if (v41 + 6 <= v4)
                      {
                        AlignMarkAnchor((TRunGlue **)a3, v13, v10, v41, v32, *(atomic_ullong **)(a1 + 16), a1);
                        return 1;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    return 0;
  }
  uint64_t v13 = 0;
LABEL_17:
  uint64_t result = 0;
  *(void *)(a3 + 48)  = v10;
  *(void *)(a3 + 56)  = v10;
  *(void *)(a3 + 64)  = v13;
  return result;
}

void AlignMarkAnchor(TRunGlue **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, atomic_ullong *this, uint64_t a7)
{
  double v38 = NAN;
  double v39 = NAN;
  double v36 = NAN;
  double v37 = NAN;
  GetAnchors(a4, a5, this, a7, &v38, &v36);
  double v10 = v38 - v36;
  double v11 = v39 - v37;
  uint64_t v12 = *a1;
  unsigned int v34 = v12;
  uint64_t v35 = a2;
  uint64_t v32 = v12;
  unsigned int v33 = (uint64_t *)a3;
  TRunGlue::GetUnscaledPosition(v12, a2);
  double v14 = v10 + v13;
  double v16 = v11 + v15;
  if (a2 >= a3)
  {
    do
    {
      TRunGlue::GetUnscaledAdvance(*a1, --a2);
      double v14 = v14 + v19;
      double v16 = v16 + v20;
    }
    while (a2 > a3);
  }
  else
  {
    do
    {
      TRunGlue::GetUnscaledAdvance(*a1, a2);
      double v14 = v14 - v17;
      double v16 = v16 - v18;
      ++a2;
    }
    while (a3 != a2);
  }
  TRunGlue::TGlyph::clearSafeToBreakAfter((uint64_t)&v34);
  if ((*((void *)v12 + 19) || *((void *)v12 + 24)) && !*((unsigned char *)v12 + 634))
  {
    v40.double x = v14 * *((double *)v12 + 80);
    v40.double y = v16 * *((double *)v12 + 81);
    TRunGlue::SetOrigin(v12, a3, v40);
  }
  else
  {
    uint64_t v21 = std::__tree<std::__value_type<long,TGlyphDeltaListEntry>,std::__map_value_compare<long,std::__value_type<long,TGlyphDeltaListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TGlyphDeltaListEntry>>>::__emplace_unique_key_args<long,std::piecewise_construct_t const&,std::tuple<long const&>,std::tuple<>>(*((uint64_t ***)v12 + 14), a3, &v33);
    double v22 = -v16;
    if (*((unsigned char *)v12 + 634)) {
      double v23 = v14;
    }
    else {
      double v23 = v16;
    }
    if (!*((unsigned char *)v12 + 634)) {
      double v22 = v14;
    }
    *((double *)v21 + 5)  = v22;
    *((double *)v21 + 6)  = v23;
  }
  if (*((void *)v12 + 19))
  {
    TRunGlue::FocusOnIndex(v12, a3);
    uint64_t v24 = *((void *)v12 + 19);
    uint64_t v25 = a3 - *((void *)v12 + 20);
    unint64_t v26 = *(void **)(v24 + 216);
    uint64_t v27 = *(void *)(v24 + 200);
    LODWORD(a3)  = *(_DWORD *)(v26[5] + 4 * v27 + 4 * v25);
    if ((a3 & 0x40) != 0)
    {
      a3  = a3 & 0xFFFFEFBF | 0x1000;
      objc_msgSend(v26, "setProps:atIndex:", a3, v27 + v25, v32, v33, v34, v35);
      unint64_t v26 = *(void **)(v24 + 216);
      uint64_t v27 = *(void *)(v24 + 200);
    }
    objc_msgSend(v26, "setProps:atIndex:", a3 | 0x4000, v27 + v25, v32);
  }
  else
  {
    uint64_t v28 = *((void *)v12 + 20) + a3;
    uint64_t v29 = *((void *)v12 + 65);
    if (!v29)
    {
      TRunGlue::InitPropertiesFromDeletedGlyphs(v12);
      uint64_t v29 = *((void *)v12 + 65);
    }
    int v30 = *(_DWORD *)(v29 + 4 * v28);
    if ((v30 & 0x40) != 0) {
      unsigned int v31 = v30 & 0xFFFFAFBF | 0x5000;
    }
    else {
      unsigned int v31 = v30 | 0x4000;
    }
    *(_DWORD *)(v29 + 4 * v28)  = v31;
  }
}

uint64_t OTL::GPOS::ApplyMarkLigPos(uint64_t a1, unsigned __int16 *a2, TGlyphIterator *this, int a4)
{
  unint64_t v4 = *(void *)(a1 + 40);
  if (*(void *)(a1 + 32) > (unint64_t)a2 || (unint64_t)(a2 + 6) > v4) {
    return 0;
  }
  uint64_t v10 = *((void *)this + 6);
  uint64_t v11 = *((void *)this + 7);
  uint64_t v12 = v10;
  if (!TGlyphIterator::Prev(this))
  {
LABEL_10:
    uint64_t result = 0;
    *((void *)this + 6)  = v10;
    *((void *)this + 7)  = v10;
    *((void *)this + 8)  = v12;
    return result;
  }
  while (1)
  {
    uint64_t v12 = *((void *)this + 6);
    if (v12 == v11) {
      break;
    }
    GlyphID  = TRunGlue::GetGlyphID(*(TRunGlue **)this, *((void *)this + 6));
    double v14 = *(OTL::ClassDefTable **)(*(void *)(a1 + 24) + 16);
    if (!v14 || OTL::ClassDefTable::ClassOf(v14, GlyphID) != 3) {
      goto LABEL_12;
    }
    if ((TGlyphIterator::Prev(this) & 1) == 0) {
      goto LABEL_10;
    }
  }
  uint64_t v12 = *((void *)this + 8);
  GlyphID  = TRunGlue::GetGlyphID(*(TRunGlue **)this, v12);
LABEL_12:
  unint64_t v61 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v16 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v16 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  long long v59 = v16;
  long long v60 = v16;
  OTL::Coverage::Coverage((OTL::Coverage *)&v59, (unsigned __int16 *)((char *)a2 + (bswap32(a2[2]) >> 16)), v4, 1);
  double v17 = (uint64_t (*)(void *, uint64_t))v60;
  double v18 = (void *)((char *)&v59 + (*((uint64_t *)&v60 + 1) >> 1));
  if (BYTE8(v60)) {
    double v17 = *(uint64_t (**)(void *, uint64_t))(*v18 + v60);
  }
  int v19 = v17(v18, GlyphID);
  *((void *)this + 6)  = v10;
  *((void *)this + 7)  = v10;
  *((void *)this + 8)  = v12;
  if (!v19) {
    return 0;
  }
  double v20 = (unsigned __int16 *)((char *)a2 + (bswap32(a2[4]) >> 16));
  uint64_t v21 = v20 + 1;
  if ((unint64_t)(v20 + 1) > v4) {
    return 0;
  }
  uint64_t v22 = bswap32(*v20) >> 16;
  unint64_t v23 = (unint64_t)&v21[2 * v22];
  unint64_t v24 = (unint64_t)(v20 + 3) <= v4 ? (v4 - (unint64_t)v21) >> 2 : 0;
  BOOL v25 = v23 <= v4 && v23 >= (unint64_t)v21;
  BOOL v26 = v25 || v24 == v22;
  if (!v26) {
    return 0;
  }
  uint64_t v27 = (a4 - 1);
  if ((unint64_t)&v21[2 * v27 + 2] > v4) {
    return 0;
  }
  uint64_t v28 = &v20[2 * v27];
  if (!v28[2]) {
    return 0;
  }
  uint64_t v29 = (char *)v20 + __rev16(v28[2]);
  if ((unint64_t)(v29 + 6) > v4) {
    return 0;
  }
  int v30 = (unsigned __int16 *)((char *)a2 + (bswap32(a2[5]) >> 16));
  unsigned int v31 = v30 + 1;
  if ((unint64_t)(v30 + 1) > v4) {
    return 0;
  }
  uint64_t result = 0;
  unsigned int v32 = v19 - 1;
  unsigned int v33 = bswap32(*v30);
  uint64_t v34 = HIWORD(v33);
  unint64_t v35 = (unint64_t)&v31[v34];
  unint64_t v36 = (v4 - (unint64_t)v31) >> 1;
  if ((unint64_t)(v30 + 2) > v4) {
    unint64_t v36 = 0;
  }
  BOOL v39 = v35 >= (unint64_t)v31 && v35 <= v4 || v36 == v34;
  if (v32 < HIWORD(v33) && v39)
  {
    uint64_t result = 0;
    unsigned int v40 = v30[v32 + 1];
    BOOL v26 = v40 == 0;
    uint64_t v41 = (char *)v30 + __rev16(v40);
    BOOL v42 = v26 || (unint64_t)(v41 + 2) > v4;
    BOOL v43 = v42;
    unint64_t v44 = v43 ? 0 : (unsigned __int16 *)v41;
    if (!v43)
    {
      double v45 = v44 + 1;
      if (v44 >= a2 && (unint64_t)v45 <= v4)
      {
        uint64_t v57 = (uint64_t)v29;
        if (*v44)
        {
          unsigned int v58 = bswap32(v28[1]) >> 16;
          unsigned int v47 = __rev16(*v44) - 1;
          GlyphProps  = TRunGlue::GetGlyphProps(*(TRunGlue **)this, v10);
          unsigned int v49 = TRunGlue::GetGlyphProps(*(TRunGlue **)this, v12);
          BOOL v50 = ((v49 ^ GlyphProps) & 0xE0000000) != 0 || v49 >> 29 == 0;
          int v51 = (GlyphProps >> 28) & 1;
          if (v50) {
            int v51 = 1;
          }
          if ((GlyphProps & 0xF000000) == 0) {
            int v51 = 1;
          }
          unsigned int v52 = (HIBYTE(GlyphProps) & 0xF) - 1;
          if (v52 >= v47) {
            unsigned int v52 = v47;
          }
          unsigned int v53 = v51 ? v47 : v52;
          uint64_t v54 = v58 + v53 * (bswap32(a2[3]) >> 16);
          if ((unint64_t)&v45[v54 + 1] <= v4)
          {
            unsigned int v55 = v44[v54 + 1];
            if (v55)
            {
              uint64_t v56 = (uint64_t)v44 + __rev16(v55);
              if (v56 + 6 <= v4)
              {
                AlignMarkAnchor((TRunGlue **)this, v12, v10, v56, v57, *(atomic_ullong **)(a1 + 16), a1);
                return 1;
              }
            }
          }
        }
        return 0;
      }
    }
  }
  return result;
}

uint64_t OTL::GPOS::ApplyMarkMarkPos(uint64_t a1, uint64_t a2, unsigned __int16 *a3, TGlyphIterator *this, int a5)
{
  unint64_t v5 = *(void *)(a1 + 40);
  if (*(void *)(a1 + 32) > (unint64_t)a3 || (unint64_t)(a3 + 6) > v5) {
    return 0;
  }
  uint64_t v54 = *((void *)this + 9);
  uint64_t v55 = *((void *)this + 6);
  *((void *)this + 9)  = 0;
  while (1)
  {
    if ((TGlyphIterator::Prev(this) & 1) == 0)
    {
LABEL_28:
      uint64_t result = 0;
      *((void *)this + 9)  = v54;
      *((void *)this + 6)  = v55;
      return result;
    }
    uint64_t v11 = *((void *)this + 6);
    GlyphID  = TRunGlue::GetGlyphID(*(TRunGlue **)this, v11);
    double v13 = *(uint64_t **)(a1 + 24);
    unsigned int v14 = bswap32(*(unsigned __int16 *)(*(void *)a2 + 2)) >> 16;
    if ((v14 & 0x10) != 0) {
      break;
    }
    if (v14 < 0x100) {
      goto LABEL_30;
    }
    uint64_t v15 = *v13;
    if (*v13)
    {
      if (*(_WORD *)(v15 + 10))
      {
        long long v16 = (unsigned __int16 *)(v15 + __rev16(*(unsigned __int16 *)(v15 + 10)));
        unint64_t v17 = v13[1];
        if ((unint64_t)(v16 + 1) <= v17)
        {
          unsigned int v18 = bswap32(*v16) >> 16;
          if (v18 == 2) {
            uint64_t v19 = 6 * (bswap32(v16[1]) >> 16) + 4;
          }
          else {
            uint64_t v19 = v18 == 1 ? 2 * (bswap32(v16[2]) >> 16) + 6 : 0;
          }
          uint64_t v22 = (char *)v16 + v19;
          BOOL v23 = v22 < (char *)v16 || (unint64_t)v22 > v17;
          if (!v23 && v14 >> 8 == OTL::ClassDefTable::ClassOf((OTL::ClassDefTable *)v16, GlyphID)) {
            goto LABEL_30;
          }
        }
      }
    }
LABEL_26:
    unint64_t v24 = (OTL::ClassDefTable *)v13[2];
    if (!v24 || OTL::ClassDefTable::ClassOf(v24, GlyphID) != 3) {
      goto LABEL_28;
    }
  }
  OTL::GDEF::MarkFilteringSet(*(OTL::Coverage **)(a1 + 24), bswap32(*(unsigned __int16 *)(*(void *)a2 + 2 * (bswap32(*(unsigned __int16 *)(*(void *)a2 + 4)) >> 16) + 6)) >> 16, (uint64_t)&v56);
  double v20 = (unsigned int (*)(void *, uint64_t))v57;
  uint64_t v21 = (void *)((char *)&v56 + (*((uint64_t *)&v57 + 1) >> 1));
  if (BYTE8(v57)) {
    double v20 = *(unsigned int (**)(void *, uint64_t))(*v21 + v57);
  }
  if (!v20(v21, GlyphID))
  {
    double v13 = *(uint64_t **)(a1 + 24);
    goto LABEL_26;
  }
LABEL_30:
  unint64_t v58 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v26 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v26 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  long long v56 = v26;
  long long v57 = v26;
  OTL::Coverage::Coverage((OTL::Coverage *)&v56, (unsigned __int16 *)((char *)a3 + (bswap32(a3[2]) >> 16)), v5, 1);
  uint64_t v27 = (uint64_t (*)(void *, uint64_t))v57;
  uint64_t v28 = (void *)((char *)&v56 + (*((uint64_t *)&v57 + 1) >> 1));
  if (BYTE8(v57)) {
    uint64_t v27 = *(uint64_t (**)(void *, uint64_t))(*v28 + v57);
  }
  uint64_t result = v27(v28, GlyphID);
  *((void *)this + 9)  = v54;
  *((void *)this + 6)  = v55;
  if (result)
  {
    int v29 = result;
    GlyphProps  = TRunGlue::GetGlyphProps(*(TRunGlue **)this, v55);
    unsigned int v31 = TRunGlue::GetGlyphProps(*(TRunGlue **)this, v11);
    unsigned int v32 = v31 >> 28;
    if ((v31 ^ GlyphProps) >> 29)
    {
      if (GlyphProps >> 29 && (GlyphProps & 0x10000000) != 0) {
        goto LABEL_45;
      }
      uint64_t result = 0;
      if (v31 >> 29)
      {
        if ((v31 & 0x10000000) != 0) {
          goto LABEL_45;
        }
      }
    }
    else
    {
      if (!(GlyphProps >> 29)) {
        goto LABEL_45;
      }
      uint64_t result = 0;
      int v33 = HIBYTE(GlyphProps) & 0xF;
      int v34 = HIBYTE(v31) & 0xF;
      if ((GlyphProps & 0x10000000) != 0) {
        int v33 = 0;
      }
      if (v32) {
        int v34 = 0;
      }
      if (v33 == v34)
      {
LABEL_45:
        unint64_t v35 = (unsigned __int16 *)((char *)a3 + (bswap32(a3[4]) >> 16));
        unint64_t v36 = v35 + 1;
        if ((unint64_t)(v35 + 1) > v5) {
          return 0;
        }
        uint64_t v37 = bswap32(*v35) >> 16;
        unint64_t v38 = (unint64_t)&v36[2 * v37];
        unint64_t v39 = (unint64_t)(v35 + 3) <= v5 ? (v5 - (unint64_t)v36) >> 2 : 0;
        BOOL v40 = v38 <= v5 && v38 >= (unint64_t)v36;
        if (!v40 && v39 != v37) {
          return 0;
        }
        uint64_t v42 = (a5 - 1);
        if ((unint64_t)&v36[2 * v42 + 2] > v5) {
          return 0;
        }
        BOOL v43 = &v35[2 * v42];
        if (!v43[2]) {
          return 0;
        }
        uint64_t result = 0;
        unint64_t v44 = (char *)v35 + __rev16(v43[2]);
        if ((unint64_t)(v44 + 6) <= v5) {
          unint64_t v45 = (unint64_t)v44;
        }
        else {
          unint64_t v45 = 0;
        }
        if ((unint64_t)(v44 + 6) <= v5 && v45 >= (unint64_t)a3 && v45 + 6 <= v5)
        {
          uint64_t v46 = (char *)a3 + (bswap32(a3[5]) >> 16);
          if ((unint64_t)(v46 + 2) <= v5)
          {
            uint64_t v47 = (bswap32(v43[1]) >> 16) + (v29 - 1) * (bswap32(a3[3]) >> 16);
            if ((unint64_t)&v46[2 * v47 + 4] <= v5)
            {
              unsigned int v48 = *(unsigned __int16 *)&v46[2 * v47 + 2];
              if (v48)
              {
                unsigned int v49 = &v46[__rev16(v48)];
                unint64_t v50 = (unint64_t)(v49 + 6) <= v5 ? (unint64_t)v49 : 0;
                BOOL v51 = (unint64_t)(v49 + 6) <= v5 && v50 >= (unint64_t)a3;
                if (v51 && v50 + 6 <= v5)
                {
                  AlignMarkAnchor((TRunGlue **)this, v11, v55, v50, v45, *(atomic_ullong **)(a1 + 16), a1);
                  return 1;
                }
              }
            }
          }
          return 0;
        }
      }
    }
  }
  return result;
}

uint64_t OTL::GPOS::ApplyPosLookupRecords(void *a1, unint64_t a2, unsigned __int16 *a3, int a4, uint64_t a5, uint64_t a6, unint64_t a7, unint64_t a8)
{
  uint64_t v35 = *(void *)(a5 + 72);
  if (a4)
  {
    unint64_t v9 = a8;
    unint64_t v10 = a7;
    uint64_t v11 = a6;
    int v12 = a4;
    double v13 = a3;
    unint64_t v14 = a2;
    char v36 = 0;
    uint64_t v15 = a3;
    do
    {
      if ((unint64_t)v13 < v14) {
        break;
      }
      long long v16 = v15 + 2;
      if ((unint64_t)(v15 + 2) > a1[5]) {
        break;
      }
      unint64_t v17 = bswap32(*v15) >> 16;
      if (v17 < v10)
      {
        *(void *)(a5 + 48)  = *(void *)(v11 + 8 * v17);
        unsigned int v18 = TBaseFont::NthLookup<OTL::GPOS>(*(void *)(a1[2] + 400), a1, bswap32(v15[1]) >> 16);
        if (v18)
        {
          uint64_t v19 = v18;
          *(void *)(a5 + 72)  = *((void *)v18 + 3);
          if (v9 <= 0x3E)
          {
            int v42 = *((unsigned __int16 *)v18 + 8);
            unsigned int v20 = -1431655765 * ((*((_DWORD *)v18 + 24) - *((_DWORD *)v18 + 22)) >> 4);
            uint64_t v21 = *(void *)(a5 + 48);
            GlyphID  = TRunGlue::GetGlyphID(*(TRunGlue **)a5, v21);
            if ((_WORD)v20)
            {
              uint64_t v23 = GlyphID;
              uint64_t v24 = 0;
              unint64_t v25 = 0;
              uint64_t v26 = 48 * (unsigned __int16)v20;
              do
              {
                *(void *)(a5 + 48)  = v21;
                uint64_t v27 = *((void *)v19 + 11);
                if (0xAAAAAAAAAAAAAAABLL * ((*((void *)v19 + 12) - v27) >> 4) <= v25) {
                  break;
                }
                uint64_t v28 = v27 + v24;
                int v29 = *(unsigned int (**)(void *, uint64_t))(v27 + v24 + 24);
                uint64_t v30 = *(void *)(v28 + 32);
                unsigned int v31 = (void *)(v28 + (v30 >> 1) + 8);
                if (v30) {
                  int v29 = *(unsigned int (**)(void *, uint64_t))(*v31 + v29);
                }
                if (v29(v31, v23))
                {
                  uint64_t v32 = *((void *)v19 + 11);
                  if (0xAAAAAAAAAAAAAAABLL * ((*((void *)v19 + 12) - v32) >> 4) <= v25) {
                    LODWORD(v33)  = 0;
                  }
                  else {
                    uint64_t v33 = *(void *)(v32 + v24);
                  }
                  if (OTL::GPOS::ApplyLookupSubtable((int)a1, (int)v19, v42, v33, (TGlyphIterator *)a5))
                  {
                    char v36 = 1;
                    break;
                  }
                }
                ++v25;
                v24 += 48;
              }
              while (v26 != v24);
              unint64_t v10 = a7;
              unint64_t v9 = a8;
              uint64_t v11 = a6;
            }
            unint64_t v14 = a2;
            double v13 = a3;
          }
        }
      }
      uint64_t v15 = v16;
      --v12;
    }
    while (v12);
  }
  else
  {
    char v36 = 0;
  }
  *(void *)(a5 + 72)  = v35;
  return v36 & 1;
}

uint64_t OTL::GPOS::ApplyContextPosFormat1(void *a1, unint64_t a2, TGlyphIterator *this, int a4, unint64_t a5)
{
  unint64_t v5 = a1[5];
  unint64_t v6 = a2 + 6;
  if (a2 + 4 < a1[4] || v6 > v5) {
    return 0;
  }
  uint64_t v9 = bswap32(*(unsigned __int16 *)(a2 + 4)) >> 16;
  unint64_t v10 = v6 + 2 * v9;
  unint64_t v11 = a2 + 8 <= v5 ? (v5 - v6) >> 1 : 0;
  BOOL v12 = v10 <= v5 && v10 >= v6;
  if (!v12 && v11 != v9) {
    return 0;
  }
  uint64_t v15 = *((void *)this + 6);
  *(void *)&long long v16 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v16 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  v54[29]  = v16;
  v54[30]  = v16;
  v54[27]  = v16;
  v54[28]  = v16;
  v54[25]  = v16;
  v54[26]  = v16;
  v54[23]  = v16;
  v54[24]  = v16;
  v54[21]  = v16;
  v54[22]  = v16;
  v54[19]  = v16;
  v54[20]  = v16;
  v54[17]  = v16;
  v54[18]  = v16;
  v54[16]  = v16;
  unint64_t v55 = 0xAAAAAAAAAAAAAAAALL;
  v54[15]  = v16;
  v54[14]  = v16;
  v54[13]  = v16;
  v54[12]  = v16;
  v54[11]  = v16;
  v54[10]  = v16;
  v54[9]  = v16;
  v54[8]  = v16;
  v54[6]  = v16;
  v54[7]  = v16;
  v54[4]  = v16;
  v54[5]  = v16;
  v54[2]  = v16;
  v54[3]  = v16;
  v54[0]  = v16;
  v54[1]  = v16;
  unsigned int v17 = a4 - 1;
  uint64_t v53 = v15;
  if (a4 - 1 >= v9) {
    return 0;
  }
  if (!*(_WORD *)(a2 + 2 * v17 + 6)) {
    return 0;
  }
  unsigned int v18 = (unsigned __int16 *)(a2 + __rev16(*(unsigned __int16 *)(a2 + 2 * v17 + 6)));
  uint64_t v19 = v18 + 1;
  if ((unint64_t)(v18 + 1) > v5) {
    return 0;
  }
  uint64_t v21 = v18 + 2;
  unsigned int v20 = *v18;
  uint64_t v22 = __rev16(v20);
  unint64_t v23 = (unint64_t)&v19[v22];
  BOOL v24 = v23 < (unint64_t)v19 || v23 > v5;
  BOOL v25 = !v24;
  unint64_t v26 = (v5 - (unint64_t)v19) >> 1;
  unint64_t v27 = (unint64_t)v21 <= v5 ? v26 : 0;
  int v28 = v27 == v22 || v25;
  if (v28 != 1) {
    return 0;
  }
  if ((unint64_t)v21 <= v5) {
    unsigned int v29 = v26;
  }
  else {
    unsigned int v29 = 0;
  }
  unsigned int v30 = bswap32(v29) >> 16;
  if (!v25) {
    unsigned int v20 = v30;
  }
  if (!v20) {
    return 0;
  }
  unint64_t v31 = 0;
  if (!v25) {
    LOWORD(v22)  = v29;
  }
  if ((v22 & 0xFFFE) != 0) {
    uint64_t v32 = (unsigned __int16)v22;
  }
  else {
    uint64_t v32 = 1;
  }
  uint64_t v49 = v32;
  while (1)
  {
    if (v31 < bswap32(*v18) >> 16)
    {
      uint64_t v33 = (unsigned __int16 *)((char *)v18 + __rev16(v18[v31 + 1]));
      int v34 = v33 + 2;
      if (v18[v31 + 1] && (unint64_t)v34 <= v5)
      {
        if (*v33)
        {
          unint64_t v36 = __rev16((unsigned __int16)*v33);
          if (v36 <= 0x40) {
            break;
          }
        }
      }
    }
LABEL_72:
    uint64_t result = 0;
    if (++v31 == v32) {
      return result;
    }
  }
  uint64_t v37 = (v36 - 1);
  unint64_t v38 = &v34[v37];
  if ((unint64_t)v34 < a2 || v38 < v34 || (unint64_t)v38 > v5)
  {
    BOOL v41 = (unint64_t)(v33 + 3) <= v5 && (unint64_t)v34 >= a2;
    unint64_t v42 = (v5 - (unint64_t)v34) >> 1;
    if (!v41) {
      unint64_t v42 = 0;
    }
    if (v42 != v37) {
      return 0;
    }
  }
  unint64_t v50 = v33;
  unint64_t v51 = v36;
  uint64_t v52 = (v36 - 1);
  if (v36 >= 2)
  {
    unint64_t v43 = v36 - 1;
    unint64_t v44 = (uint64_t *)v54;
    while (TGlyphIterator::Next(this, 1))
    {
      uint64_t v45 = *((void *)this + 6);
      if (TRunGlue::GetGlyphID(*(TRunGlue **)this, v45) != bswap32(*v34) >> 16) {
        break;
      }
      ++v34;
      *v44++  = v45;
      if (!--v43) {
        goto LABEL_75;
      }
    }
    *((void *)this + 6)  = v15;
    uint64_t v32 = v49;
    goto LABEL_72;
  }
LABEL_75:
  *((void *)this + 6)  = v15;
  if (OTL::GPOS::ApplyPosLookupRecords(a1, a2, v34, bswap32((unsigned __int16)v50[1]) >> 16, (uint64_t)this, (uint64_t)&v53, v51, a5))TGlyphIterator::ClearSafeToBreakAfter((CFIndex *)this, &v53, v51); {
  *((void *)this + 6)  = v15;
  }
  TGlyphIterator::Next(this, v52);
  return 1;
}

CFIndex *TGlyphIterator::ClearSafeToBreakAfter(CFIndex *this, uint64_t *a2, uint64_t a3)
{
  if (*(void *)(*this + 152))
  {
    uint64_t v3 = this;
    this  = std::__minmax_element_impl[abi:nn180100]<long const*,long const*,std::__identity,std::__less<void,void>>(a2, &a2[a3]);
    if (this != v4)
    {
      v5.CFIndex length = *v4 - *this + 1;
      v5.CFIndex location = *this;
      return (CFIndex *)TRunGlue::ClearSafeToBreakAfter(*v3, v5);
    }
  }
  return this;
}

uint64_t OTL::GPOS::ApplyContextPosFormat2(void *a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = *(void *)(a3 + 48);
  GlyphID  = TRunGlue::GetGlyphID(*(TRunGlue **)a3, v7);
  unint64_t v9 = a1[5];
  uint64_t v53 = a1;
  unint64_t v10 = a2 + 8;
  if (a2 + 6 < a1[4] || v10 > v9) {
    return 0;
  }
  unint64_t v12 = bswap32(*(unsigned __int16 *)(a2 + 6)) >> 16;
  unint64_t v13 = v10 + 2 * v12;
  unint64_t v14 = a2 + 10 <= v9 ? (v9 - v10) >> 1 : 0;
  BOOL v15 = v13 <= v9 && v13 >= v10;
  BOOL v16 = v15 || v14 == v12;
  if (!v16) {
    return 0;
  }
  unsigned int v17 = (unsigned __int16 *)(a2 + (bswap32(*(unsigned __int16 *)(a2 + 4)) >> 16));
  if ((unint64_t)(v17 + 1) > v9) {
    return 0;
  }
  unsigned int v18 = GlyphID;
  unsigned int v19 = bswap32(*v17) >> 16;
  if (v19 == 2)
  {
    uint64_t v20 = 6 * (bswap32(v17[1]) >> 16) + 4;
  }
  else if (v19 == 1)
  {
    uint64_t v20 = 2 * (bswap32(v17[2]) >> 16) + 6;
  }
  else
  {
    uint64_t v20 = 0;
  }
  uint64_t result = 0;
  uint64_t v22 = (char *)v17 + v20;
  if (v22 < (char *)v17 || (unint64_t)v22 > v9) {
    return result;
  }
  *(void *)&long long v23 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v23 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  long long v87 = v23;
  long long v88 = v23;
  long long v85 = v23;
  long long v86 = v23;
  long long v83 = v23;
  long long v84 = v23;
  long long v81 = v23;
  long long v82 = v23;
  long long v79 = v23;
  long long v80 = v23;
  long long v77 = v23;
  long long v78 = v23;
  long long v75 = v23;
  long long v76 = v23;
  long long v74 = v23;
  unint64_t v89 = 0xAAAAAAAAAAAAAAAALL;
  long long v73 = v23;
  long long v72 = v23;
  long long v71 = v23;
  long long v70 = v23;
  long long v69 = v23;
  long long v68 = v23;
  long long v67 = v23;
  long long v66 = v23;
  long long v64 = v23;
  long long v65 = v23;
  long long v62 = v23;
  long long v63 = v23;
  long long v60 = v23;
  long long v61 = v23;
  long long v58 = v23;
  long long v59 = v23;
  uint64_t v57 = v7;
  unsigned int v24 = OTL::ClassDefTable::ClassOf((OTL::ClassDefTable *)v17, v18);
  if (v12 <= v24) {
    return 0;
  }
  if (!*(_WORD *)(a2 + 2 * v24 + 8)) {
    return 0;
  }
  BOOL v25 = (unsigned __int16 *)(a2 + __rev16(*(unsigned __int16 *)(a2 + 2 * v24 + 8)));
  unint64_t v26 = v25 + 1;
  if ((unint64_t)(v25 + 1) > v9) {
    return 0;
  }
  int v28 = v25 + 2;
  unsigned int v27 = *v25;
  uint64_t v29 = __rev16(v27);
  unint64_t v30 = (unint64_t)&v26[v29];
  BOOL v31 = v30 < (unint64_t)v26 || v30 > v9;
  BOOL v32 = !v31;
  unint64_t v33 = (v9 - (unint64_t)v26) >> 1;
  unint64_t v34 = (unint64_t)v28 <= v9 ? v33 : 0;
  int v35 = v34 == v29 || v32;
  if (v35 != 1) {
    return 0;
  }
  if ((unint64_t)v28 <= v9) {
    unsigned int v36 = v33;
  }
  else {
    unsigned int v36 = 0;
  }
  unsigned int v37 = bswap32(v36) >> 16;
  if (!v32)
  {
    LOWORD(v29)  = v36;
    unsigned int v27 = v37;
  }
  if (!v27) {
    return 0;
  }
  unsigned int v38 = 0;
  char v52 = 0;
  unsigned int v56 = (unsigned __int16)v29;
  unint64_t v55 = v25;
  uint64_t v51 = v7;
  while (1)
  {
    if (v38 < bswap32(*v25) >> 16 && v25[v38 + 1])
    {
      unint64_t v39 = (char *)v25 + __rev16(v25[v38 + 1]);
      BOOL v40 = (unint64_t)(v39 + 4) <= v9 ? v39 : 0;
    }
    else
    {
      BOOL v40 = 0;
    }
    if ((unint64_t)v40 >= a2)
    {
      BOOL v41 = (unsigned __int16 *)(v40 + 4);
      if ((unint64_t)(v40 + 4) <= v9)
      {
        unint64_t v12 = __rev16(*(unsigned __int16 *)v40);
        if (*(_WORD *)v40)
        {
          if (v12 <= 0x40) {
            break;
          }
        }
      }
    }
LABEL_82:
    if (++v38 >= v56) {
      goto LABEL_83;
    }
  }
  uint64_t v42 = (v12 - 1);
  unint64_t v43 = &v41[v42];
  unint64_t v44 = (v9 - (unint64_t)v41) >> 1;
  if ((unint64_t)(v40 + 6) > v9) {
    unint64_t v44 = 0;
  }
  if ((unint64_t)v43 <= v9 && v43 >= v41 || v44 == v42)
  {
    unint64_t v47 = a2;
    if (v12 < 2)
    {
      LODWORD(v48)  = 1;
    }
    else
    {
      uint64_t v48 = 1;
      while (TGlyphIterator::Next((TGlyphIterator *)a3, 1))
      {
        uint64_t v49 = *(void *)(a3 + 48);
        unsigned int v50 = TRunGlue::GetGlyphID(*(TRunGlue **)a3, v49);
        if (OTL::ClassDefTable::ClassOf((OTL::ClassDefTable *)v17, v50) != bswap32(*v41) >> 16)
        {
          ++v41;
          break;
        }
        *(&v57 + v48++)  = v49;
        ++v41;
        if (v12 == v48)
        {
          BOOL v41 = (unsigned __int16 *)&v40[2 * (v12 - 2) + 6];
          a2  = v47;
          uint64_t v7 = v51;
          goto LABEL_78;
        }
      }
      uint64_t v7 = v51;
      BOOL v25 = v55;
    }
    BOOL v16 = v48 == v12;
    a2  = v47;
    if (v16)
    {
LABEL_78:
      if (OTL::GPOS::ApplyPosLookupRecords(v53, a2, v41, bswap32(*((unsigned __int16 *)v40 + 1)) >> 16, a3, (uint64_t)&v57, v12, a4))TGlyphIterator::ClearSafeToBreakAfter((CFIndex *)a3, &v57, v12); {
      char v52 = 1;
      }
      unsigned int v38 = v56;
      BOOL v25 = v55;
    }
    *(void *)(a3 + 48)  = v7;
    goto LABEL_82;
  }
LABEL_83:
  if ((v52 & 1) == 0) {
    return 0;
  }
  TGlyphIterator::Next((TGlyphIterator *)a3, (v12 - 1));
  return 1;
}

uint64_t OTL::GPOS::ApplyContextPosFormat3(void *a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4 = a1[5];
  unint64_t v5 = a2 + 6;
  BOOL v6 = a1[4] > a2 || v5 > v4;
  if (v6 || !*(_WORD *)(a2 + 2)) {
    return 0;
  }
  uint64_t v11 = *(void *)(a3 + 48);
  unsigned int v12 = __rev16(*(unsigned __int16 *)(a2 + 2));
  uint64_t v13 = v12 - 1;
  if (v12 != 1)
  {
    uint64_t v14 = *(void *)(a3 + 24);
    if (*(int *)(a3 + 8) < 1)
    {
      if (v11 - v13 <= v14) {
        return 0;
      }
    }
    else if (v11 + v13 >= v14)
    {
      return 0;
    }
  }
  *(void *)&long long v15 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v15 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  v19[29]  = v15;
  v19[30]  = v15;
  v19[27]  = v15;
  v19[28]  = v15;
  v19[25]  = v15;
  v19[26]  = v15;
  v19[23]  = v15;
  v19[24]  = v15;
  v19[21]  = v15;
  v19[22]  = v15;
  v19[19]  = v15;
  v19[20]  = v15;
  v19[17]  = v15;
  v19[18]  = v15;
  v19[16]  = v15;
  unint64_t v20 = 0xAAAAAAAAAAAAAAAALL;
  v19[15]  = v15;
  v19[14]  = v15;
  v19[13]  = v15;
  v19[12]  = v15;
  v19[11]  = v15;
  v19[10]  = v15;
  v19[9]  = v15;
  v19[8]  = v15;
  v19[7]  = v15;
  v19[6]  = v15;
  void v19[5] = v15;
  v19[4]  = v15;
  v19[3]  = v15;
  v19[2]  = v15;
  v19[1]  = v15;
  v19[0]  = v15;
  uint64_t v18 = v11;
  if (v12 >= 2)
  {
    if (v12 <= 0x40)
    {
      uint64_t result = TGlyphIterator::MatchCoverSequenceAndNote(a3, v13, a2 + 8, (uint64_t)v19, a2, v4);
      if (!result) {
        return result;
      }
      uint64_t v17 = result + 1;
      goto LABEL_16;
    }
    return 0;
  }
  uint64_t v17 = 1;
LABEL_16:
  if (OTL::GPOS::ApplyPosLookupRecords(a1, a2, (unsigned __int16 *)(v5 + 2 * v12), bswap32(*(unsigned __int16 *)(a2 + 4)) >> 16, a3, (uint64_t)&v18, v17, a4))TGlyphIterator::ClearSafeToBreakAfter((CFIndex *)a3, &v18, v17); {
  *(void *)(a3 + 48)  = v11;
  }
  TGlyphIterator::Next((TGlyphIterator *)a3, v17 - 1);
  return 1;
}

uint64_t TGlyphIterator::MatchCoverSequenceAndNote(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6)
{
  uint64_t v12 = *(void *)(a1 + 48);
  if (TGlyphIterator::Next((TGlyphIterator *)a1, 1))
  {
    uint64_t v20 = v12;
    uint64_t v13 = 0;
    while (1)
    {
      uint64_t v14 = *(void *)(a1 + 48);
      GlyphID  = TRunGlue::GetGlyphID(*(TRunGlue **)a1, v14);
      unint64_t v23 = 0xAAAAAAAAAAAAAAAALL;
      *(void *)&long long v16 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v16 + 1)  = 0xAAAAAAAAAAAAAAAALL;
      long long v21 = v16;
      long long v22 = v16;
      OTL::Coverage::Coverage((OTL::Coverage *)&v21, (unsigned __int16 *)(a5 + (bswap32(*(unsigned __int16 *)(a3 + 2 * v13)) >> 16)), a6, 1);
      uint64_t v17 = (unsigned int (*)(void *, uint64_t))v22;
      uint64_t v18 = (void *)((char *)&v21 + (*((uint64_t *)&v22 + 1) >> 1));
      if (BYTE8(v22)) {
        uint64_t v17 = *(unsigned int (**)(void *, uint64_t))(*v18 + v22);
      }
      if (!v17(v18, GlyphID))
      {
        a2 -= v13;
        uint64_t v12 = v20;
        goto LABEL_11;
      }
      *(void *)(a4 + 8 * v13)  = v14;
      if (a2 - 1 == v13) {
        break;
      }
      ++v13;
      if ((TGlyphIterator::Next((TGlyphIterator *)a1, 1) & 1) == 0)
      {
        uint64_t v13 = 0;
        *(void *)(a1 + 48)  = v20;
        return v13;
      }
    }
    *(void *)(a1 + 48)  = v20;
    return a2;
  }
  else
  {
    uint64_t v13 = 0;
LABEL_11:
    *(void *)(a1 + 48)  = v12;
    if (a2) {
      return 0;
    }
  }
  return v13;
}

uint64_t OTL::GPOS::ApplyChainContextPosFormat1(void *a1, unint64_t a2, TGlyphIterator *this, int a4, unint64_t a5)
{
  unint64_t v5 = a1[5];
  unint64_t v6 = a2 + 6;
  if (a2 + 4 < a1[4] || v6 > v5) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v11 = __rev16(*(unsigned __int16 *)(a2 + 4));
  BOOL v12 = __CFADD__(v6, 2 * v11);
  char v13 = v6 + 2 * v11 > v5 || v12;
  unint64_t v14 = (v5 - v6) >> 1;
  if (a2 + 8 > v5) {
    unint64_t v14 = 0;
  }
  if (v14 == v11) {
    char v15 = 0;
  }
  else {
    char v15 = v13;
  }
  if ((v15 & 1) == 0 && *(_WORD *)(a2 + 4))
  {
    CFIndex v17 = *((void *)this + 6);
    *(void *)&long long v18 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v18 + 1)  = 0xAAAAAAAAAAAAAAAALL;
    v71[29]  = v18;
    v71[30]  = v18;
    v71[27]  = v18;
    v71[28]  = v18;
    v71[25]  = v18;
    v71[26]  = v18;
    v71[23]  = v18;
    v71[24]  = v18;
    v71[21]  = v18;
    v71[22]  = v18;
    v71[19]  = v18;
    v71[20]  = v18;
    v71[17]  = v18;
    v71[18]  = v18;
    v71[16]  = v18;
    unint64_t v72 = 0xAAAAAAAAAAAAAAAALL;
    v71[15]  = v18;
    v71[14]  = v18;
    v71[13]  = v18;
    v71[12]  = v18;
    v71[11]  = v18;
    v71[10]  = v18;
    v71[9]  = v18;
    v71[8]  = v18;
    v71[6]  = v18;
    v71[7]  = v18;
    v71[4]  = v18;
    v71[5]  = v18;
    v71[2]  = v18;
    v71[3]  = v18;
    v71[0]  = v18;
    v71[1]  = v18;
    unsigned int v19 = a4 - 1;
    CFIndex v70 = v17;
    if (a4 - 1 < v11)
    {
      if (*(_WORD *)(a2 + 2 * v19 + 6))
      {
        uint64_t v20 = (unsigned __int16 *)(a2 + __rev16(*(unsigned __int16 *)(a2 + 2 * v19 + 6)));
        long long v21 = v20 + 1;
        if ((unint64_t)(v20 + 1) <= v5)
        {
          unint64_t v23 = v20 + 2;
          unsigned int v22 = *v20;
          uint64_t v24 = __rev16(v22);
          unint64_t v25 = (unint64_t)&v21[v24];
          BOOL v26 = v25 < (unint64_t)v21 || v25 > v5;
          BOOL v27 = !v26;
          unint64_t v28 = (v5 - (unint64_t)v21) >> 1;
          unint64_t v29 = (unint64_t)v23 <= v5 ? v28 : 0;
          int v30 = v29 == v24 || v27;
          if (v30 == 1)
          {
            if ((unint64_t)v23 <= v5) {
              unsigned int v31 = v28;
            }
            else {
              unsigned int v31 = 0;
            }
            unsigned int v32 = bswap32(v31) >> 16;
            if (!v27) {
              unsigned int v22 = v32;
            }
            if (v22)
            {
              long long v63 = a1;
              unint64_t v33 = 0;
              if (!v27) {
                LOWORD(v24)  = v31;
              }
              if ((v24 & 0xFFFE) != 0) {
                uint64_t v24 = (unsigned __int16)v24;
              }
              else {
                uint64_t v24 = 1;
              }
              uint64_t v68 = v24;
              CFIndex v69 = v17;
              while (1)
              {
                if (v33 >= bswap32(*v20) >> 16) {
                  return 0;
                }
                if (!v20[v33 + 1]) {
                  return 0;
                }
                unint64_t v34 = (unsigned __int16 *)((char *)v20 + __rev16(v20[v33 + 1]));
                if ((unint64_t)v34 > v5) {
                  return 0;
                }
                int v35 = v34 + 1;
                if ((unint64_t)v34 < a2 || (unint64_t)v35 > v5) {
                  return 0;
                }
                unsigned int v37 = *v34;
                if (v37) {
                  break;
                }
                uint64_t v42 = v35;
                CFIndex v43 = v17;
LABEL_65:
                unint64_t v44 = v42 + 1;
                if ((unint64_t)v42 < a2 || (unint64_t)v44 > v5) {
                  return 0;
                }
                if (*v42)
                {
                  unint64_t v46 = __rev16(*v42);
                  if (v46 <= 0x40)
                  {
                    CFIndex v66 = v43;
                    unint64_t v67 = v46;
                    CFIndex v47 = v17;
                    uint64_t v48 = v42 + 1;
                    if (v46 < 2)
                    {
LABEL_79:
                      uint64_t result = 0;
                      *((void *)this + 6)  = v17;
                      if ((unint64_t)v48 < a2) {
                        return result;
                      }
                      uint64_t v54 = v48 + 1;
                      if ((unint64_t)(v48 + 1) > v5) {
                        return result;
                      }
                      if (!*v48)
                      {
LABEL_97:
                        uint64_t result = 0;
                        if ((unint64_t)v54 >= a2 && (unint64_t)(v54 + 1) <= v5)
                        {
                          if (OTL::GPOS::ApplyPosLookupRecords(v63, a2, v54 + 1, bswap32(*v54) >> 16, (uint64_t)this, (uint64_t)&v70, v46, a5)&& *(void *)(*(void *)this + 152))
                          {
                            CFIndex v61 = v66 - v47;
                            if (v66 >= v47) {
                              v62.CFIndex location = v47;
                            }
                            else {
                              v62.CFIndex location = v66;
                            }
                            if (v66 - v47 < 0) {
                              CFIndex v61 = v47 - v66;
                            }
                            v62.CFIndex length = v61 + 1;
                            TRunGlue::ClearSafeToBreakAfter(*(void *)this, v62);
                          }
                          *((void *)this + 6)  = v17;
                          TGlyphIterator::Next(this, (v46 - 1));
                          return 1;
                        }
                        return result;
                      }
                      unsigned int v55 = __rev16((unsigned __int16)*v48);
                      *((void *)this + 6)  = *(&v70 + (v46 - 1));
                      if (v55 <= 1) {
                        int v56 = 1;
                      }
                      else {
                        int v56 = v55;
                      }
                      uint64_t v57 = v48;
                      long long v58 = v48 + 2;
                      int v59 = v56;
                      while (TGlyphIterator::NextContext(this, 1))
                      {
                        GlyphID  = TRunGlue::GetGlyphID(*(TRunGlue **)this, *((void *)this + 6));
                        if ((unint64_t)v54 < a2
                          || (unint64_t)v58 > v5
                          || GlyphID != bswap32((unsigned __int16)*(v58 - 1)) >> 16)
                        {
                          break;
                        }
                        ++v58;
                        if (!--v59)
                        {
                          uint64_t v54 = &v57[v56 - 1 + 2];
                          CFIndex v47 = *((void *)this + 6);
                          CFIndex v17 = v69;
                          *((void *)this + 6)  = v69;
                          unint64_t v46 = v67;
                          goto LABEL_97;
                        }
                      }
                    }
                    else
                    {
                      uint64_t v49 = v42 + 2;
                      uint64_t v65 = (uint64_t)&v42[(v46 - 2) + 2];
                      unint64_t v50 = v46 - 1;
                      uint64_t v51 = (uint64_t *)v71;
                      while (TGlyphIterator::Next(this, 1))
                      {
                        uint64_t v52 = *((void *)this + 6);
                        int v53 = TRunGlue::GetGlyphID(*(TRunGlue **)this, v52);
                        if ((unint64_t)v44 < a2
                          || (unint64_t)v49 > v5
                          || v53 != bswap32((unsigned __int16)*(v49 - 1)) >> 16)
                        {
                          break;
                        }
                        *v51++  = v52;
                        ++v49;
                        if (!--v50)
                        {
                          CFIndex v47 = *((void *)this + 6);
                          CFIndex v17 = v69;
                          unint64_t v46 = v67;
                          uint64_t v48 = (_WORD *)v65;
                          goto LABEL_79;
                        }
                      }
                    }
                    goto LABEL_92;
                  }
                }
LABEL_93:
                uint64_t result = 0;
                if (++v33 == v68) {
                  return result;
                }
              }
              unsigned int v38 = __rev16(v37);
              if (v38 <= 1) {
                int v39 = 1;
              }
              else {
                int v39 = v38;
              }
              BOOL v40 = v35;
              while (TGlyphIterator::PrevContext(this, 1))
              {
                int v41 = TRunGlue::GetGlyphID(*(TRunGlue **)this, *((void *)this + 6));
                if ((unint64_t)v35 < a2) {
                  break;
                }
                uint64_t v42 = v40 + 1;
                if ((unint64_t)(v40 + 1) > v5 || v41 != bswap32(*v40) >> 16) {
                  break;
                }
                ++v40;
                if (!--v39)
                {
                  CFIndex v43 = *((void *)this + 6);
                  CFIndex v17 = v69;
                  *((void *)this + 6)  = v69;
                  goto LABEL_65;
                }
              }
LABEL_92:
              CFIndex v17 = v69;
              *((void *)this + 6)  = v69;
              goto LABEL_93;
            }
          }
        }
      }
    }
    return 0;
  }
  return result;
}

uint64_t OTL::GPOS::ApplyChainContextPosFormat2(void *a1, unsigned __int16 *a2, uint64_t a3, unint64_t a4)
{
  uint64_t v8 = *(void *)(a3 + 48);
  GlyphID  = TRunGlue::GetGlyphID(*(TRunGlue **)a3, v8);
  unint64_t v10 = a1[5];
  uint64_t v11 = a2 + 6;
  if ((unint64_t)(a2 + 5) < a1[4] || (unint64_t)v11 > v10) {
    return 0;
  }
  uint64_t v13 = __rev16(a2[5]);
  unint64_t v14 = (unint64_t)&v11[v13];
  unint64_t v15 = (unint64_t)(a2 + 7) <= v10 ? (v10 - (unint64_t)v11) >> 1 : 0;
  BOOL v16 = v14 <= v10 && v14 >= (unint64_t)v11;
  if (!v16 && v15 != v13) {
    return 0;
  }
  long long v18 = (unsigned __int16 *)((char *)a2 + (bswap32(a2[3]) >> 16));
  if ((unint64_t)(v18 + 1) > v10) {
    return 0;
  }
  unsigned int v19 = GlyphID;
  unsigned int v20 = bswap32(*v18) >> 16;
  if (v20 == 2)
  {
    uint64_t v21 = 6 * (bswap32(v18[1]) >> 16) + 4;
  }
  else if (v20 == 1)
  {
    uint64_t v21 = 2 * (bswap32(v18[2]) >> 16) + 6;
  }
  else
  {
    uint64_t v21 = 0;
  }
  uint64_t result = 0;
  unint64_t v23 = (char *)v18 + v21;
  if (v23 >= (char *)v18 && (unint64_t)v23 <= v10)
  {
    if (a2[5])
    {
      unsigned int v24 = a2[2];
      unsigned int v25 = a2[4];
      *(void *)&long long v26 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v26 + 1)  = 0xAAAAAAAAAAAAAAAALL;
      v93[29]  = v26;
      v93[30]  = v26;
      v93[27]  = v26;
      v93[28]  = v26;
      v93[25]  = v26;
      v93[26]  = v26;
      v93[23]  = v26;
      v93[24]  = v26;
      v93[21]  = v26;
      v93[22]  = v26;
      v93[19]  = v26;
      v93[20]  = v26;
      v93[17]  = v26;
      v93[18]  = v26;
      v93[16]  = v26;
      unint64_t v94 = 0xAAAAAAAAAAAAAAAALL;
      v93[15]  = v26;
      v93[14]  = v26;
      v93[13]  = v26;
      v93[12]  = v26;
      v93[11]  = v26;
      v93[10]  = v26;
      v93[9]  = v26;
      v93[8]  = v26;
      v93[6]  = v26;
      v93[7]  = v26;
      v93[4]  = v26;
      v93[5]  = v26;
      v93[2]  = v26;
      v93[3]  = v26;
      v93[0]  = v26;
      v93[1]  = v26;
      uint64_t v92 = v8;
      unsigned int v27 = OTL::ClassDefTable::ClassOf((OTL::ClassDefTable *)v18, v19);
      if (v13 > v27)
      {
        if (a2[v27 + 6])
        {
          unint64_t v28 = (unsigned __int16 *)((char *)a2 + __rev16(a2[v27 + 6]));
          unint64_t v29 = v28 + 1;
          if ((unint64_t)(v28 + 1) <= v10)
          {
            unsigned int v31 = v28 + 2;
            unsigned int v30 = *v28;
            uint64_t v32 = __rev16(v30);
            unint64_t v33 = (unint64_t)&v29[v32];
            BOOL v34 = v33 < (unint64_t)v29 || v33 > v10;
            BOOL v35 = !v34;
            unint64_t v36 = (v10 - (unint64_t)v29) >> 1;
            unint64_t v37 = (unint64_t)v31 <= v10 ? v36 : 0;
            int v38 = v37 == v32 || v35;
            if (v38 == 1)
            {
              if ((unint64_t)v31 <= v10) {
                unsigned int v39 = v36;
              }
              else {
                unsigned int v39 = 0;
              }
              unsigned int v40 = bswap32(v39) >> 16;
              BOOL v41 = !v35;
              if (!v35) {
                unsigned int v30 = v40;
              }
              if (v30)
              {
                long long v80 = a1;
                unint64_t v81 = a4;
                unint64_t v42 = 0;
                CFIndex v43 = (unsigned __int16 *)((char *)a2 + (bswap32(v24) >> 16));
                unint64_t v44 = (unsigned __int16 *)((char *)a2 + (bswap32(v25) >> 16));
                if (v41) {
                  LOWORD(v32)  = v39;
                }
                long long v86 = v43 + 1;
                int v91 = v44;
                long long v84 = v44 + 1;
                if ((v32 & 0xFFFE) != 0) {
                  uint64_t v32 = (unsigned __int16)v32;
                }
                else {
                  uint64_t v32 = 1;
                }
                uint64_t v87 = v32;
                long long v88 = v28;
                uint64_t v89 = v8;
                while (1)
                {
                  if (v42 >= bswap32(*v28) >> 16) {
                    return 0;
                  }
                  if (!v28[v42 + 1]) {
                    return 0;
                  }
                  uint64_t v45 = (unsigned __int16 *)((char *)v28 + __rev16(v28[v42 + 1]));
                  if ((unint64_t)v45 > v10) {
                    return 0;
                  }
                  unint64_t v46 = v45 + 1;
                  if (v45 < a2 || (unint64_t)v46 > v10) {
                    return 0;
                  }
                  unsigned int v48 = *v45;
                  unint64_t v90 = v42;
                  if (v48) {
                    break;
                  }
                  uint64_t v51 = v46;
                  CFIndex v52 = v8;
LABEL_81:
                  long long v58 = v51 + 1;
                  if (v51 < a2 || (unint64_t)v58 > v10) {
                    return 0;
                  }
                  if (*v51)
                  {
                    unint64_t v60 = __rev16(*v51);
                    if (v60 <= 0x40)
                    {
                      CFIndex v83 = v52;
                      CFIndex v61 = v51 + 1;
                      unint64_t v85 = v60;
                      if (v60 < 2)
                      {
LABEL_95:
                        uint64_t result = 0;
                        CFIndex v67 = *(void *)(a3 + 48);
                        *(void *)(a3 + 48)  = v8;
                        if (v61 < a2) {
                          return result;
                        }
                        uint64_t v68 = v61 + 1;
                        if ((unint64_t)(v61 + 1) > v10) {
                          return result;
                        }
                        if (!*v61)
                        {
LABEL_121:
                          uint64_t result = 0;
                          if (v68 >= a2 && (unint64_t)(v68 + 1) <= v10)
                          {
                            if (OTL::GPOS::ApplyPosLookupRecords(v80, (unint64_t)a2, v68 + 1, bswap32(*v68) >> 16, a3, (uint64_t)&v92, v60, v81)&& *(void *)(*(void *)a3 + 152))
                            {
                              CFIndex v78 = v83 - v67;
                              if (v83 >= v67) {
                                v79.CFIndex location = v67;
                              }
                              else {
                                v79.CFIndex location = v83;
                              }
                              if (v83 - v67 < 0) {
                                CFIndex v78 = v67 - v83;
                              }
                              v79.CFIndex length = v78 + 1;
                              TRunGlue::ClearSafeToBreakAfter(*(void *)a3, v79);
                            }
                            *(void *)(a3 + 48)  = v8;
                            TGlyphIterator::Next((TGlyphIterator *)a3, (v60 - 1));
                            return 1;
                          }
                          return result;
                        }
                        if ((unint64_t)v84 > v10) {
                          return 0;
                        }
                        unsigned int v69 = bswap32(*v91) >> 16;
                        if (v69 == 2)
                        {
                          uint64_t v70 = 6 * (bswap32(*v84) >> 16) + 4;
                        }
                        else if (v69 == 1)
                        {
                          uint64_t v70 = 2 * (bswap32(v91[2]) >> 16) + 6;
                        }
                        else
                        {
                          uint64_t v70 = 0;
                        }
                        uint64_t result = 0;
                        long long v71 = (char *)v91 + v70;
                        if (v71 < (char *)v91 || (unint64_t)v71 > v10) {
                          return result;
                        }
                        unsigned int v72 = __rev16(*v61);
                        *(void *)(a3 + 48)  = *(&v92 + (v60 - 1));
                        if (v72 <= 1) {
                          int v73 = 1;
                        }
                        else {
                          int v73 = v72;
                        }
                        long long v74 = v61;
                        long long v75 = v61 + 2;
                        int v76 = v73;
                        while (TGlyphIterator::NextContext((TGlyphIterator *)a3, 1))
                        {
                          unsigned int v77 = TRunGlue::GetGlyphID(*(TRunGlue **)a3, *(void *)(a3 + 48));
                          if (v68 < a2
                            || (unint64_t)v75 > v10
                            || OTL::ClassDefTable::ClassOf((OTL::ClassDefTable *)v91, v77) != bswap32((unsigned __int16)*(v75 - 1)) >> 16)
                          {
                            break;
                          }
                          ++v75;
                          if (!--v76)
                          {
                            uint64_t v68 = &v74[v73 - 1 + 2];
                            CFIndex v67 = *(void *)(a3 + 48);
                            uint64_t v8 = v89;
                            *(void *)(a3 + 48)  = v89;
                            unint64_t v60 = v85;
                            goto LABEL_121;
                          }
                        }
                      }
                      else
                      {
                        CFRange v62 = v51 + 2;
                        long long v82 = &v62[(v60 - 2)];
                        unint64_t v63 = v60 - 1;
                        long long v64 = (uint64_t *)v93;
                        while (TGlyphIterator::Next((TGlyphIterator *)a3, 1))
                        {
                          uint64_t v65 = *(void *)(a3 + 48);
                          unsigned int v66 = TRunGlue::GetGlyphID(*(TRunGlue **)a3, v65);
                          if (v58 < a2
                            || (unint64_t)v62 > v10
                            || OTL::ClassDefTable::ClassOf((OTL::ClassDefTable *)v18, v66) != bswap32((unsigned __int16)*(v62 - 1)) >> 16)
                          {
                            break;
                          }
                          *v64++  = v65;
                          ++v62;
                          if (!--v63)
                          {
                            uint64_t v8 = v89;
                            unint64_t v60 = v85;
                            CFIndex v61 = v82;
                            goto LABEL_95;
                          }
                        }
                      }
                      goto LABEL_116;
                    }
                  }
LABEL_117:
                  uint64_t result = 0;
                  if (++v42 == v87) {
                    return result;
                  }
                }
                if ((unint64_t)v86 > v10) {
                  return 0;
                }
                unsigned int v49 = bswap32(*v43) >> 16;
                if (v49 == 2)
                {
                  uint64_t v50 = 6 * (bswap32(*v86) >> 16) + 4;
                }
                else if (v49 == 1)
                {
                  uint64_t v50 = 2 * (bswap32(v43[2]) >> 16) + 6;
                }
                else
                {
                  uint64_t v50 = 0;
                }
                uint64_t result = 0;
                int v53 = (char *)v43 + v50;
                if (v53 < (char *)v43 || (unint64_t)v53 > v10) {
                  return result;
                }
                unsigned int v54 = __rev16(v48);
                if (v54 <= 1) {
                  int v55 = 1;
                }
                else {
                  int v55 = v54;
                }
                int v56 = v46;
                while (TGlyphIterator::PrevContext((TGlyphIterator *)a3, 1))
                {
                  unsigned int v57 = TRunGlue::GetGlyphID(*(TRunGlue **)a3, *(void *)(a3 + 48));
                  if (v46 < a2) {
                    break;
                  }
                  uint64_t v51 = v56 + 1;
                  if ((unint64_t)(v56 + 1) > v10
                    || OTL::ClassDefTable::ClassOf((OTL::ClassDefTable *)v43, v57) != bswap32(*v56) >> 16)
                  {
                    break;
                  }
                  ++v56;
                  if (!--v55)
                  {
                    CFIndex v52 = *(void *)(a3 + 48);
                    unint64_t v28 = v88;
                    uint64_t v8 = v89;
                    *(void *)(a3 + 48)  = v89;
                    unint64_t v42 = v90;
                    goto LABEL_81;
                  }
                }
LABEL_116:
                unint64_t v28 = v88;
                uint64_t v8 = v89;
                *(void *)(a3 + 48)  = v89;
                unint64_t v42 = v90;
                goto LABEL_117;
              }
            }
          }
        }
      }
    }
    return 0;
  }
  return result;
}

uint64_t OTL::GPOS::ApplyChainContextPosFormat3(void *a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  unint64_t v4 = a1[5];
  unint64_t v5 = (_WORD *)(a2 + 2);
  unint64_t v6 = (unsigned __int16 *)(a2 + 4);
  if (a1[4] > a2 || (unint64_t)v5 > v4 || (unint64_t)v6 > v4) {
    return 0;
  }
  uint64_t v11 = *(void *)(a3 + 48);
  unsigned int v12 = (unsigned __int16)*v5;
  uint64_t v13 = __rev16(v12);
  if (*v5)
  {
    uint64_t v14 = *(void *)(a3 + 16);
    if (*(int *)(a3 + 8) < 1)
    {
      if (v11 + v13 >= v14) {
        return 0;
      }
    }
    else if (v11 - v13 <= v14)
    {
      return 0;
    }
  }
  unint64_t v15 = &v6[v13];
  if ((unint64_t)(v15 + 1) > v4 || !*v15) {
    return 0;
  }
  unint64_t v16 = __rev16(*v15);
  CFIndex v17 = &v15[v16 + 1];
  long long v18 = v17 + 1;
  if ((unint64_t)v17 < a2 || (unint64_t)v18 > v4) {
    return 0;
  }
  unsigned int v20 = *v17;
  uint64_t v21 = v16 - 1 + (bswap32(v20) >> 16);
  if (v21)
  {
    uint64_t v22 = *(void *)(a3 + 24);
    if (*(int *)(a3 + 8) >= 1)
    {
      if (v11 + v21 < v22) {
        goto LABEL_22;
      }
      return 0;
    }
    if (v11 - v21 <= v22) {
      return 0;
    }
  }
LABEL_22:
  unsigned int v37 = v20;
  int v36 = v13;
  int v38 = v18;
  *(void *)&long long v23 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v23 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  v43[14]  = v23;
  v43[13]  = v23;
  v43[12]  = v23;
  v43[11]  = v23;
  v43[10]  = v23;
  v43[9]  = v23;
  v43[8]  = v23;
  v43[7]  = v23;
  v43[6]  = v23;
  v43[5]  = v23;
  v43[4]  = v23;
  v43[3]  = v23;
  v43[2]  = v23;
  v43[1]  = v23;
  v43[0]  = v23;
  BOOL v41 = 0;
  uint64_t v42 = 0;
  unsigned int v40 = 0;
  unint64_t v44 = v43;
  std::vector<long,TInlineBufferAllocator<long,30ul>>::__vallocate[abi:nn180100](&v40, v16);
  unsigned int v24 = (char *)v41;
  bzero(v41, 8 * v16);
  BOOL v41 = &v24[8 * v16];
  unsigned int v25 = v40;
  uint64_t *v40 = v11;
  if (v16 < 2)
  {
    uint64_t v27 = 1;
  }
  else
  {
    matched  = TGlyphIterator::MatchCoverSequenceAndNote(a3, (int)v16 - 1, (uint64_t)(v15 + 2), (uint64_t)(v25 + 1), a2, v4);
    if (!matched) {
      goto LABEL_37;
    }
    uint64_t v27 = matched + 1;
  }
  if (!v12 || TGlyphIterator::MatchCoverSequence<(MatchDirection)1>(a3, v11, v36, v6, a2, v4, 0))
  {
    unsigned int v28 = __rev16(v37);
    if (!v37 || TGlyphIterator::MatchCoverSequence<(MatchDirection)0>(a3, v40[v27 - 1], v28, v38, a2, v4, 0))
    {
      unint64_t v29 = &v38[v28];
      unsigned int v30 = v29 + 1;
      if ((unint64_t)v29 >= a2 && (unint64_t)v30 <= v4)
      {
        if (OTL::GPOS::ApplyPosLookupRecords(a1, a2, v30, bswap32(*v29) >> 16, a3, (uint64_t)v40, v27, a4)) {
          TGlyphIterator::ClearSafeToBreakAfter((CFIndex *)a3, v40, v27);
        }
        *(void *)(a3 + 48)  = v11;
        TGlyphIterator::Next((TGlyphIterator *)a3, v27 - 1);
        uint64_t v32 = 1;
        goto LABEL_38;
      }
    }
  }
LABEL_37:
  uint64_t v32 = 0;
LABEL_38:
  unsigned int v39 = (void **)&v40;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](&v39);
  return v32;
}

void OTL::GPOS::~GPOS(OTL::GPOS *this)
{
}

uint64_t **TRunGlue::TGlyph::AdjustXPositionBy(TRunGlue::TGlyph *this, double a2)
{
  uint64_t v3 = *(void *)this;
  if ((*(void *)(v3 + 152) || *(void *)(v3 + 192)) && !*(unsigned char *)(v3 + 634))
  {
    Origin  = TRunGlue::GetOrigin((TRunGlue *)v3, *((void *)this + 1));
    uint64_t v11 = *(void **)this;
    uint64_t v12 = *((void *)this + 1);
    double v13 = Origin + *(double *)(*(void *)this + 640) * a2;
    return (uint64_t **)TRunGlue::SetOrigin(v11, v12, *(CGPoint *)&v13);
  }
  else
  {
    uint64_t result = std::__tree<std::__value_type<long,TGlyphDeltaListEntry>,std::__map_value_compare<long,std::__value_type<long,TGlyphDeltaListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TGlyphDeltaListEntry>>>::__emplace_unique_key_args<long,std::piecewise_construct_t const&,std::tuple<long const&>,std::tuple<>>(*(uint64_t ***)(v3 + 112), *((void *)this + 1), (uint64_t **)this + 1);
    int32x2_t v5 = vdup_n_s32(*(unsigned char *)(*(void *)this + 634) == 0);
    v6.i64[0]  = v5.u32[0];
    v6.i64[1]  = v5.u32[1];
    int8x16_t v7 = (int8x16_t)vdupq_lane_s64(0x8000000000000000, 0);
    v8.i64[1]  = v7.i64[1];
    *(double *)v8.i64  = a2;
    *(double *)&v7.i64[1]  = a2;
    *(float64x2_t *)(result + 5)  = vaddq_f64(*(float64x2_t *)(result + 5), (float64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v6, 0x3FuLL)), v8, v7));
  }
  return result;
}

uint64_t **std::__tree<std::__value_type<long,TGlyphDeltaListEntry>,std::__map_value_compare<long,std::__value_type<long,TGlyphDeltaListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TGlyphDeltaListEntry>>>::__emplace_unique_key_args<long,std::piecewise_construct_t const&,std::tuple<long const&>,std::tuple<>>(uint64_t **a1, uint64_t a2, uint64_t **a3)
{
  int64x2_t v6 = a1 + 1;
  int32x2_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        int8x16_t v7 = (uint64_t **)v5;
        uint64_t v8 = v5[4];
        if (v8 <= a2) {
          break;
        }
        int32x2_t v5 = *v7;
        int64x2_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      int32x2_t v5 = v7[1];
      if (!v5)
      {
        int64x2_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    int8x16_t v7 = a1 + 1;
LABEL_9:
    unint64_t v9 = (uint64_t *)v7;
    int8x16_t v7 = (uint64_t **)operator new(0x38uLL);
    unint64_t v10 = *a3;
    _OWORD v7[5] = 0;
    v7[6]  = 0;
    v7[4]  = v10;
    unsigned __int16 *v7 = 0;
    v7[1]  = 0;
    id v7[2] = v9;
    *int64x2_t v6 = (uint64_t *)v7;
    uint64_t v11 = (uint64_t *)**a1;
    uint64_t v12 = (uint64_t *)v7;
    if (v11)
    {
      *a1  = v11;
      uint64_t v12 = *v6;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a1[1], v12);
    a1[2]  = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

void TRunGlue::GetUnscaledPosition(TRunGlue *this, uint64_t a2)
{
  TRunGlue::FocusOnIndex(this, a2);
  TRunGlue::GetOrigin(this, a2);
  uint64_t v4 = *((void *)this + 14);
  if (v4)
  {
    int32x2_t v5 = *(void **)(v4 + 8);
    if (v5)
    {
      do
      {
        if (v5[4] >= a2) {
          int64x2_t v6 = v5;
        }
        else {
          int64x2_t v6 = v5 + 1;
        }
        int32x2_t v5 = (void *)*v6;
      }
      while (*v6);
    }
  }
}

void TRunGlue::GetUnscaledAdvance(TRunGlue *this, uint64_t a2)
{
}

OTL::Coverage *OTL::GDEF::MarkFilteringSet@<X0>(OTL::Coverage *this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  if (*((unsigned char *)this + 24))
  {
    unint64_t v3 = *((void *)this + 1);
    uint64_t v4 = *(void *)this + (bswap32(*(unsigned __int16 *)(*(void *)this + 12)) >> 16);
    unint64_t v5 = v4 + 4;
    if (v4 + 4 <= v3)
    {
      uint64_t v6 = bswap32(*(unsigned __int16 *)(v4 + 2)) >> 16;
      unint64_t v7 = v5 + 4 * v6;
      if (v7 >= v5 && v7 <= v3) {
        goto LABEL_11;
      }
      unint64_t v9 = (v3 - v5) >> 2;
      if (v4 + 8 > v3) {
        unint64_t v9 = 0;
      }
      if (v9 == v6)
      {
LABEL_11:
        if (v6 > a2) {
          return OTL::Coverage::Coverage((OTL::Coverage *)a3, (unsigned __int16 *)(v4 + bswap32(*(_DWORD *)(v4 + 4 * a2 + 4))), v3, 1);
        }
      }
    }
  }
  *(void *)a3  = 0;
  *(void *)(a3 + 8)  = 0;
  *(void *)(a3 + 16)  = OTL::Coverage::SearchUnknown;
  *(void *)(a3 + 24)  = 0;
  *(_DWORD *)(a3 + 32)  = 0xFFFF;
  return this;
}

void std::__function::__func<OTL::GPOS::ApplyPairPosAccelerated(OTL::Lookup const&,TGlyphIterator &)::$_0,std::allocator<OTL::GPOS::ApplyPairPosAccelerated(OTL::Lookup const&,TGlyphIterator &)::$_0>,void ()(unsigned short,unsigned short,unsigned short)>::~__func()
{
}

void *std::__function::__func<OTL::GPOS::ApplyPairPosAccelerated(OTL::Lookup const&,TGlyphIterator &)::$_0,std::allocator<OTL::GPOS::ApplyPairPosAccelerated(OTL::Lookup const&,TGlyphIterator &)::$_0>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1ED0618B0;
  result[1]  = v3;
  return result;
}

void std::__function::__func<OTL::GPOS::ApplyPairPosAccelerated(OTL::Lookup const&,TGlyphIterator &)::$_1,std::allocator<OTL::GPOS::ApplyPairPosAccelerated(OTL::Lookup const&,TGlyphIterator &)::$_1>,void ()(unsigned short,unsigned short,unsigned short)>::~__func()
{
}

void *std::__function::__func<OTL::GPOS::ApplyPairPosAccelerated(OTL::Lookup const&,TGlyphIterator &)::$_1,std::allocator<OTL::GPOS::ApplyPairPosAccelerated(OTL::Lookup const&,TGlyphIterator &)::$_1>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1ED0618F8;
  result[1]  = v3;
  return result;
}

void std::__function::__func<OTL::GPOS::ApplyPairPosAccelerated(OTL::Lookup const&,TGlyphIterator &)::$_2,std::allocator<OTL::GPOS::ApplyPairPosAccelerated(OTL::Lookup const&,TGlyphIterator &)::$_2>,void ()(unsigned short,unsigned short,unsigned short)>::~__func()
{
}

void *std::__function::__func<OTL::GPOS::ApplyPairPosAccelerated(OTL::Lookup const&,TGlyphIterator &)::$_2,std::allocator<OTL::GPOS::ApplyPairPosAccelerated(OTL::Lookup const&,TGlyphIterator &)::$_2>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1ED061940;
  result[1]  = v3;
  return result;
}

void std::__function::__func<OTL::GPOS::ApplyPairPosAccelerated(OTL::Lookup const&,TGlyphIterator &)::$_3,std::allocator<OTL::GPOS::ApplyPairPosAccelerated(OTL::Lookup const&,TGlyphIterator &)::$_3>,void ()(unsigned short,unsigned short,unsigned short)>::~__func()
{
}

void *std::__function::__func<OTL::GPOS::ApplyPairPosAccelerated(OTL::Lookup const&,TGlyphIterator &)::$_3,std::allocator<OTL::GPOS::ApplyPairPosAccelerated(OTL::Lookup const&,TGlyphIterator &)::$_3>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1ED061988;
  result[1]  = v3;
  return result;
}

uint64_t TRubyRun::TRubyRun(uint64_t a1, uint64_t a2, char a3)
{
  TRun::TRun((TRun *)a1, *(const TRun **)(a2 + 40));
  *unint64_t v5 = &unk_1ED05F428;
  uint64_t v6 = v5 + 40;
  *(void *)(a1 + 320)  = (id)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit(v5 + 5, memory_order_acquire), @"CTRubyAnnotation");
  TRubyAnnotation::TRubyAnnotation((TRubyAnnotation *)(a1 + 328), (CFTypeRef)atomic_load_explicit(v6, memory_order_acquire));
  for (uint64_t i = 408; i != 696; i += 72)
  {
    uint64_t v8 = a1 + i;
    *(_WORD *)(v8 + 64)  = 0;
    *(_OWORD *)(v8 + 32)  = 0uLL;
    *(_OWORD *)(v8 + 48)  = 0uLL;
    *(_OWORD *)uint64_t v8 = 0uLL;
    *(_OWORD *)(v8 + 16)  = 0uLL;
  }
  *(double *)(a1 + 696)  = TRun::GetAscent((TRun *)a1);
  *(double *)(a1 + 704)  = TRun::GetDescent((TRun *)a1);
  *(_OWORD *)(a1 + 712)  = 0u;
  *(_OWORD *)(a1 + 728)  = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(a1 + 744)  = *MEMORY[0x1E4F1DB30];
  *(unsigned char *)(a1 + 760)  = a3;
  *(unsigned char *)(a1 + 761)  = 0;
  *(void *)(a1 + 768)  = 0;
  TRubyRun::InitializeAnnotation((atomic_ullong *)a1);
  return a1;
}

void TRubyRun::InitializeAnnotation(atomic_ullong *this)
{
  double v2 = *(double *)(*(void *)(atomic_load_explicit(this + 7, memory_order_acquire) + 40) + 16);
  double v3 = v2 * *((double *)this + 42);
  CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit(this + 49, memory_order_acquire);
  unint64_t v5 = (const __CTFont *)atomic_load_explicit(this + 7, memory_order_acquire);
  if (explicit)
  {
    int Value = (const __CTFont *)CFDictionaryGetValue(explicit, @"NSFont");
    if (Value)
    {
      double v3 = *(double *)(*((void *)Value + 5) + 16);
      unint64_t v5 = Value;
    }
  }
  else
  {
    CFDictionaryRef explicit = (const __CFDictionary *)TAttributes::GetDictionary(this + 5);
  }
  uint64_t v7 = this[2];
  if (atomic_load_explicit(this + 49, memory_order_acquire)) {
    int v8 = *((unsigned __int8 *)this + 376);
  }
  else {
    int v8 = 1;
  }
  RubyFont  = CreateRubyFont(v5, v3, v8);
  id v19 = (id)0xAAAAAAAAAAAAAAAALL;
  if (qword_1EB2CE338 != -1) {
    dispatch_once_f(&qword_1EB2CE338, 0, (dispatch_function_t)GetValidRubyAttributes(void)::$_0::__invoke);
  }
  CreateCopyOfDictionaryFilteredByKeys(explicit, (CFSetRef)_MergedGlobals_19, &v19);
  id v18 = (id)0xAAAAAAAAAAAAAAAALL;
  TCFMutableDictionary::TCFMutableDictionary((TCFMutableDictionary *)&v18, (CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v19, memory_order_acquire));
  if (*((unsigned char *)this + 760)) {
    BOOL v10 = 1;
  }
  else {
    BOOL v10 = *((unsigned char *)this + 90) != 0;
  }
  CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v18, memory_order_acquire), @"NSFont", RubyFont);
  if (!CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v18, memory_order_acquire), @"CTForegroundColor"))
  {
    uint64_t v11 = (void *)atomic_load_explicit(this + 9, memory_order_acquire);
    if (v11) {
      CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v18, memory_order_acquire), @"CTForegroundColor", v11);
    }
  }
  BackgroundColor  = TAttributes::GetBackgroundColor((TAttributes *)atomic_load_explicit(this + 5, memory_order_acquire), 0, (const __CFString **)v11);
  RemoveIfValueEqual((atomic_ullong *)&v18, BackgroundColor, @"CTBackgroundColor");
  RemoveIfValueEqual((atomic_ullong *)&v18, BackgroundColor, @"NSBackgroundColor");
  if (atomic_load_explicit(this + 48, memory_order_acquire))
  {
    unsigned int v13 = *((unsigned __int8 *)this + 376);
    TRubyAnnotationLine::InitWithAnnotation((TRubyAnnotationLine *)&this[9 * *((unsigned __int8 *)this + 376) + 51], this + 41, v13, (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v18, memory_order_acquire), v2 * (double)v7, v10);
    TRubyRun::UpdateMetricsWithAnnotationLine((TRubyRun *)this, v13, v14);
  }
  else
  {
    uint64_t v15 = 0;
    unint64_t v16 = (TRubyAnnotationLine *)(this + 51);
    do
    {
      TRubyAnnotationLine::InitWithAnnotation(v16, this + 41, v15, (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v18, memory_order_acquire), v2 * (double)v7, v10);
      TRubyRun::UpdateMetricsWithAnnotationLine((TRubyRun *)this, v15++, v17);
      unint64_t v16 = (TRubyAnnotationLine *)((char *)v16 + 72);
    }
    while (v15 != 4);
  }
  *((unsigned char *)this + 761)  = (*((_WORD *)this + 89) & 0x1000) != 0;
}

void TRubyRun::TRubyRun(TRubyRun *this, const TRubyRun *a2)
{
  TRun::TRun(this, a2);
  *uint64_t v4 = &unk_1ED05F428;
  *((void *)this + 40)  = (id)atomic_load_explicit((atomic_ullong *volatile)a2 + 40, memory_order_acquire);
  TRubyAnnotation::TRubyAnnotation((TRubyRun *)((char *)this + 328), (const TRubyRun *)((char *)a2 + 328));
  for (uint64_t i = 408; i != 696; i += 72)
  {
    uint64_t v6 = (char *)this + i;
    *((_WORD *)v6 + 32)  = 0;
    *((_OWORD *)v6 + 2)  = 0uLL;
    *((_OWORD *)v6 + 3)  = 0uLL;
    *(_OWORD *)uint64_t v6 = 0uLL;
    *((_OWORD *)v6 + 1)  = 0uLL;
  }
  *((double *)this + 87)  = TRun::GetAscent(this);
  *((double *)this + 88)  = TRun::GetDescent(this);
  *((void *)this + 89)  = *((void *)a2 + 89);
  *((void *)this + 90)  = *((void *)a2 + 90);
  *(_OWORD *)((char *)this + 728)  = *(_OWORD *)((char *)a2 + 728);
  *(_OWORD *)((char *)this + 744)  = *MEMORY[0x1E4F1DB30];
  *((_WORD *)this + 380)  = *((_WORD *)a2 + 380);
  *((void *)this + 96)  = 0;
  TRubyRun::InitializeAnnotationFrom(this, a2);
}

void TRubyRun::InitializeAnnotationFrom(TRubyRun *this, const TRubyRun *a2)
{
  uint64_t v4 = 0;
  int v5 = 0;
  do
  {
    uint64_t v6 = (char *)this + v4;
    TCFRef<__CTFont const*>::Retain((atomic_ullong *)((char *)this + v4 + 408), (id)atomic_load_explicit((atomic_ullong *volatile)((char *)a2 + v4 + 408), memory_order_acquire));
    TCFRef<__CTFont const*>::Retain((atomic_ullong *)((char *)this + v4 + 416), (id)atomic_load_explicit((atomic_ullong *volatile)((char *)a2 + v4 + 416), memory_order_acquire));
    int8x16_t v7 = *(int8x16_t *)((char *)a2 + v4 + 424);
    long long v8 = *(_OWORD *)((char *)a2 + v4 + 440);
    long long v9 = *(_OWORD *)((char *)a2 + v4 + 456);
    *((_WORD *)v6 + 236)  = *(_WORD *)((char *)a2 + v4 + 472);
    *(_OWORD *)(v6 + 440)  = v8;
    *(_OWORD *)(v6 + 456)  = v9;
    *(int8x16_t *)(v6 + 424)  = v7;
    TRubyRun::UpdateMetricsWithAnnotationLine(this, v5++, v7);
    v4 += 72;
  }
  while (v4 != 288);
}

uint64_t TRubyRun::TRubyRun(uint64_t a1, uint64_t a2, uint64_t a3, CFIndex a4, int a5)
{
  *(void *)TRun::TRun(a1, a2, a3, a4, a5)  = &unk_1ED05F428;
  *(void *)(a1 + 320)  = (id)atomic_load_explicit((atomic_ullong *volatile)(a2 + 320), memory_order_acquire);
  TRubyAnnotation::TRubyAnnotation((TRubyAnnotation *)(a1 + 328), (const TRubyAnnotation *)(a2 + 328));
  for (uint64_t i = 408; i != 696; i += 72)
  {
    uint64_t v10 = a1 + i;
    *(_WORD *)(v10 + 64)  = 0;
    *(_OWORD *)(v10 + 32)  = 0uLL;
    *(_OWORD *)(v10 + 48)  = 0uLL;
    *(_OWORD *)uint64_t v10 = 0uLL;
    *(_OWORD *)(v10 + 16)  = 0uLL;
  }
  *(double *)(a1 + 696)  = TRun::GetAscent((TRun *)a1);
  *(double *)(a1 + 704)  = TRun::GetDescent((TRun *)a1);
  *(void *)(a1 + 712)  = *(void *)(a2 + 712);
  *(void *)(a1 + 720)  = *(void *)(a2 + 720);
  *(_OWORD *)(a1 + 728)  = *(_OWORD *)(a2 + 728);
  *(_OWORD *)(a1 + 744)  = *MEMORY[0x1E4F1DB30];
  *(_WORD *)(a1 + 760)  = *(_WORD *)(a2 + 760);
  *(void *)(a1 + 768)  = 0;
  if (a3 == *(void *)(a1 + 728) && a4 == *(void *)(a1 + 736)) {
    TRubyRun::InitializeAnnotationFrom((TRubyRun *)a1, (const TRubyRun *)a2);
  }
  return a1;
}

int8x16_t TRubyRun::UpdateMetricsWithAnnotationLine(TRubyRun *this, unsigned int a2, int8x16_t result)
{
  if (atomic_load_explicit((atomic_ullong *volatile)this + 9 * a2 + 51, memory_order_acquire))
  {
    float64x2_t v3 = *(float64x2_t *)((char *)this + 72 * a2 + 424);
    *(double *)result.i64  = vaddvq_f64(v3);
    switch(a2)
    {
      case 0u:
        goto LABEL_6;
      case 1u:
        *(double *)result.i64  = *(double *)result.i64 + *((double *)this + 88);
        *((void *)this + 88)  = result.i64[0];
        break;
      case 2u:
        if (*((unsigned char *)this + 72 * a2 + 472))
        {
          *((double *)this + 87)  = *(double *)result.i64 + *((double *)this + 87);
          if (atomic_load_explicit((atomic_ullong *volatile)this + 9 * a2 + 52, memory_order_acquire))
          {
LABEL_6:
            *(double *)result.i64  = *(double *)result.i64 + *((double *)this + 87);
            *((void *)this + 87)  = result.i64[0];
          }
        }
        break;
      case 3u:
        uint64_t result = vbslq_s8((int8x16_t)vcgtq_f64(v3, *(float64x2_t *)((char *)this + 696)), (int8x16_t)v3, *(int8x16_t *)((char *)this + 696));
        *(int8x16_t *)((char *)this + 696)  = result;
        break;
      default:
        return result;
    }
  }
  return result;
}

void TRubyRun::DrawAnnotationLine(TRubyRun *this, CGContextRef c, unsigned int a3)
{
  if (a3 == 2 && !*((unsigned char *)this + 90))
  {
    CGContextSaveGState(c);
    *(void *)&long long v7 = -1;
    *((void *)&v7 + 1)  = -1;
    *(_OWORD *)&v12.c  = v7;
    *(_OWORD *)&v12.tdouble x = v7;
    *(_OWORD *)&v12.a  = v7;
    *(_OWORD *)&v13.a  = xmmword_184B88D60;
    v13.c  = 1.0;
    memset(&v13.d, 0, 24);
    CGAffineTransformInvert(&v12, &v13);
    *(_OWORD *)&transform.a  = xmmword_184B88D60;
    transform.c  = 1.0;
    memset(&transform.d, 0, 24);
    CGContextConcatCTM(c, &transform);
    TextPosition  = CGContextGetTextPosition(c);
    CGContextSetTextPosition(c, v12.tx + TextPosition.y * v12.c + v12.a * TextPosition.x, v12.ty + TextPosition.y * v12.d + v12.b * TextPosition.x);
    int v6 = 1;
  }
  else
  {
    int v6 = 0;
  }
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)this + 9 * a3 + 51, memory_order_acquire);
  if (c && explicit) {
    TLine::DrawGlyphs(*(TLine **)(explicit + 40), c);
  }
  if (atomic_load_explicit((atomic_ullong *volatile)this + 9 * a3 + 52, memory_order_acquire))
  {
    unint64_t v10 = atomic_load_explicit((atomic_ullong *volatile)this + 9 * a3 + 52, memory_order_acquire);
    if (c)
    {
      if (v10) {
        TLine::DrawGlyphs(*(TLine **)(v10 + 40), c);
      }
    }
  }
  if (v6) {
    CGContextRestoreGState(c);
  }
}

void TRubyRun::DrawGlyphs(TRubyRun *this, CGContextRef c, CFRange a3)
{
  CFIndex length = a3.length;
  CFIndex location = a3.location;
  TextPosition  = CGContextGetTextPosition(c);
  CGFloat y = TextPosition.y;
  if (*((unsigned char *)this + 401))
  {
    v15.CFIndex location = location;
    v15.CFIndex length = length;
    TRun::DrawGlyphs(this, c, v15);
    CGPoint v9 = CGContextGetTextPosition(c);
    CGFloat y = v9.y;
    double x = v9.x;
  }
  else
  {
    double x = TextPosition.x + *((double *)this + 24);
  }
  CGFloat v11 = y;
  uint64_t v12 = 0;
  CGAffineTransform v13 = (atomic_ullong *)((char *)this + 408);
  do
  {
    if (atomic_load_explicit(v13, memory_order_acquire))
    {
      CGContextSetTextPosition(c, TextPosition.x, TextPosition.y);
      TRubyRun::DrawAnnotationLine(this, c, v12);
    }
    v13 += 9;
    ++v12;
  }
  while (v12 != 4);

  CGContextSetTextPosition(c, x, v11);
}

void TRubyRun::AdvanceRubyLinesInitialAdvance(TRubyRun *this, double a2)
{
  uint64_t v4 = 0;
  int v5 = *((unsigned __int8 *)this + 90);
  int v6 = (double *)((char *)this + 464);
  long long v7 = (double *)MEMORY[0x1E4F1DB30];
  do
  {
    unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)v6 - 7, memory_order_acquire);
    if (explicit)
    {
      unint64_t v10 = (uint64_t *)(*(void *)(explicit + 40) + 16);
      uint64_t v9 = *v10;
      if (v10[1] - *v10 >= 1)
      {
        CGFloat v11 = *(TRun **)(*(void *)v9 + 48);
        uint64_t v12 = (double *)*((void *)v11 + 39);
        if (!v12) {
          uint64_t v12 = v7;
        }
        double v13 = *v12;
        double v14 = v12[1];
        double v15 = *(v6 - 1) + a2;
        if (v4 == 2)
        {
          Ascent  = TRun::GetAscent(this);
          if (v5)
          {
            id v18 = (double *)((char *)this + 72 * v4 + 432);
          }
          else
          {
            double v15 = v15 - Ascent;
            Ascent  = *((double *)this + 90);
            id v18 = v6 - 5;
          }
          double v16 = Ascent + *v18;
          unint64_t v19 = atomic_load_explicit((atomic_ullong *volatile)v6 - 6, memory_order_acquire);
          if (v19)
          {
            uint64_t v21 = (uint64_t *)(*(void *)(v19 + 40) + 16);
            uint64_t v20 = *v21;
            if (v21[1] - *v21 >= 1)
            {
              uint64_t v22 = *(TRun **)(*(void *)v20 + 48);
              long long v23 = (double *)*((void *)v22 + 39);
              if (!v23) {
                long long v23 = v7;
              }
              v24.double width = v15 - *(v6 - 1) + *v6 - *v23;
              v24.height  = v16 + *(v6 - 5) + *(v6 - 4) - v23[1];
              TRun::AdvanceInitialAdvance(v22, v24);
            }
          }
        }
        else if (v4 == 1)
        {
          double v16 = -(TRun::GetDescent(this) + *(v6 - 5));
        }
        else
        {
          double v16 = 0.0;
          if (!(_BYTE)v4) {
            double v16 = TRun::GetAscent(this) + *(v6 - 4);
          }
        }
        v25.double width = v15 - v13;
        v25.height  = v16 - v14;
        TRun::AdvanceInitialAdvance(v11, v25);
      }
    }
    v6 += 9;
    ++v4;
  }
  while (v4 != 4);
}

void TRubyRun::CacheGlyphPositions(double **this, double *a2, double *a3)
{
  TRubyRun::AdvanceRubyLinesInitialAdvance((TRubyRun *)this, *a2 - *((double *)this + 93));
  double v6 = *a2;
  double v7 = *a3;
  TRun::CacheGlyphPositions((TRun *)this, a2, a3);
  if (*((unsigned char *)this + 761))
  {
    long long v8 = this[39];
    if (!v8) {
      long long v8 = (double *)MEMORY[0x1E4F1DB30];
    }
    double v9 = *((double *)this + 24) + *v8;
    double v10 = *((double *)this + 87) + *((double *)this + 88);
    if (v10 > v9 || vabdd_f64(v10, v9) < 0.001)
    {
      TRun::GetPositions((__n128 *)this, 0);
      *((double *)this + 96)  = *v11 - v6 - v7;
    }
  }
}

void TRubyRun::DrawGlyphsAtPositions(TRun *this, CGContextRef c, CFRange a3, CGPoint *a4, unsigned __int8 *a5)
{
  if (*((unsigned char *)this + 401)) {
    TRun::DrawRotatedGlyphsAtPositions(this, c, a3, a4, a5, *((double *)this + 96));
  }
  uint64_t v7 = 0;
  long long v8 = (atomic_ullong *)((char *)this + 408);
  double v9 = (_OWORD *)MEMORY[0x1E4F1DAB8];
  do
  {
    if (atomic_load_explicit(v8, memory_order_acquire))
    {
      *(void *)&long long v10 = -1;
      *((void *)&v10 + 1)  = -1;
      *(_OWORD *)&v16.c  = v10;
      *(_OWORD *)&v16.tdouble x = v10;
      *(_OWORD *)&v16.a  = v10;
      CGContextGetTextMatrix(&v16, c);
      if (*((unsigned char *)this + 144)) {
        CGFloat v11 = (_OWORD *)((char *)this + 96);
      }
      else {
        CGFloat v11 = v9;
      }
      long long v12 = v11[1];
      *(_OWORD *)&t1.a  = *v11;
      *(_OWORD *)&t1.c  = v12;
      *(_OWORD *)&t1.tdouble x = v11[2];
      CGAffineTransformInvert(&t2, &t1);
      t1  = t2;
      t2  = v16;
      CGAffineTransformConcat(&v15, &t1, &t2);
      CGAffineTransform v14 = v15;
      CGContextSetTextMatrix(c, &v14);
      TRubyRun::DrawAnnotationLine(this, c, v7);
      CGAffineTransform v13 = v16;
      CGContextSetTextMatrix(c, &v13);
    }
    v8 += 9;
    ++v7;
  }
  while (v7 != 4);
}

double TRubyRun::GetBackgroundRect(TRubyRun *this)
{
  BackgroundRect  = TRun::GetBackgroundRect(this);
  double v6 = -*((double *)this + 93);
  double v7 = -*((double *)this + 94);

  *(void *)&double result = (unint64_t)CGRectOffset(*(CGRect *)&BackgroundRect, v6, v7);
  return result;
}

CTFontRef CreateRubyFont(const __CTFont *a1, CGFloat a2, int a3)
{
  unint64_t explicit = (const __CTFontDescriptor *)atomic_load_explicit((atomic_ullong *volatile)(*((void *)a1 + 5) + 8), memory_order_acquire);
  if (a3 == 1)
  {
    return CTFontCreateWithFontDescriptor(explicit, a2, 0);
  }
  else
  {
    int valuePtr = 28;
    CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFNumberRef v7 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
    int v12 = 2;
    CFNumberRef v8 = CFNumberCreate(v6, kCFNumberIntType, &v12);
    CopyWithFeature  = CTFontDescriptorCreateCopyWithFeature(explicit, v7, v8);

    CTFontRef v10 = CTFontCreateWithFontDescriptor(CopyWithFeature, a2, 0);
    return v10;
  }
}

void RemoveIfValueEqual(atomic_ullong *a1, const void *a2, const __CFString *key)
{
  int Value = CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit(a1, memory_order_acquire), key);
  if (Value == a2 || a2 && Value && CFEqual(a2, Value))
  {
    unint64_t explicit = (__CFDictionary *)atomic_load_explicit(a1, memory_order_acquire);
    CFDictionaryRemoveValue(explicit, key);
  }
}

void TRubyAnnotationLine::InitWithAnnotation(TRubyAnnotationLine *this, atomic_ullong *a2, unsigned int a3, const __CFDictionary *a4, double a5, int a6)
{
  id v52 = 0;
  CFAttributedStringRef explicit = (const __CFAttributedString *)atomic_load_explicit(a2 + 7, memory_order_acquire);
  if (explicit && (CFIndex v13 = CFAttributedStringGetLength(explicit)) != 0)
  {
    CFIndex v14 = v13;
    CFAllocatorRef v15 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFMutableAttributedStringRef MutableCopy = CFAttributedStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, explicit);
    v49[0]  = MEMORY[0x1E4F143A8];
    v49[1]  = 3321888768;
    v49[2]  = ___ZN19TRubyAnnotationLine18InitWithAnnotationERK15TRubyAnnotation14CTRubyPositionPK14__CFDictionarydb_block_invoke;
    v49[3]  = &unk_1ED0624B8;
    v49[4]  = a4;
    id v50 = MutableCopy;
    char v51 = a3;
    -[__CFAttributedString enumerateAttributesInRange:options:usingBlock:](explicit, "enumerateAttributesInRange:options:usingBlock:", 0, v14, 0, v49);
    int Value = CFDictionaryGetValue(a4, @"NSFont");
    if (Value) {
      double v18 = *(double *)(Value[5] + 16);
    }
    else {
      double v18 = 0.0;
    }
    if (*((unsigned char *)a2 + 72))
    {
      double v19 = v18 * (double)v14;
      if (v19 > a5)
      {
        CTFontRef v20 = CTFontCreateWithFontDescriptor((CTFontDescriptorRef)atomic_load_explicit((atomic_ullong *volatile)(Value[5] + 8), memory_order_acquire), v18 * a5 / v19, 0);
        v53.CFIndex location = 0;
        v53.CFIndex length = v14;
        CFAttributedStringSetAttribute(MutableCopy, v53, @"NSFont", v20);
      }
    }
    if (a3 == 2)
    {
      String  = CFAttributedStringGetString(explicit);
      LOBYTE(v46)  = 0;
      if (HasToneString(String, (BOOL *)&v46))
      {
        CFIndex v22 = v14 - 1;
        v57.CFIndex location = v22;
        v57.CFIndex length = 1;
        CFAttributedStringRef v23 = CFAttributedStringCreateWithSubstring(v15, MutableCopy, v57);
        v54.CFIndex location = v22;
        v54.CFIndex length = 1;
        CFAttributedStringReplaceString(MutableCopy, v54, &stru_1ED0677F8);
        if ((_BYTE)v46)
        {
          v55.CFIndex location = 0;
          v55.CFIndex length = 0;
          CFAttributedStringReplaceAttributedString(MutableCopy, v55, v23);
          *((unsigned char *)this + 65)  = 1;
        }
        else
        {
          Line  = (id)CreateLine(v23, a6);
        }
      }
    }
    int v38 = MutableCopy;
    TCFRef<__CTFont const*>::Retain((atomic_ullong *)&v52, v38);

    id v39 = MutableCopy;
  }
  else
  {
    if (a3 > 3) {
      goto LABEL_34;
    }
    CGSize v24 = &a2[a3];
    CFStringRef v25 = (const __CFString *)v24[2];
    if (!v25) {
      goto LABEL_34;
    }
    CFIndex Length = CFStringGetLength((CFStringRef)v24[2]);
    if (!Length) {
      goto LABEL_34;
    }
    uint64_t v27 = Length;
    Line  = (id)0xAAAAAAAAAAAAAAAALL;
    TCFMutableDictionary::TCFMutableDictionary((TCFMutableDictionary *)&Line, a4);
    unsigned int v28 = (const __CTFont *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Line, memory_order_acquire), @"NSFont");
    if (v28) {
      double v29 = *(double *)(*((void *)v28 + 5) + 16);
    }
    else {
      double v29 = 0.0;
    }
    RubyFont  = CreateRubyFont(v28, v29, a3);
    CTFontRef v31 = RubyFont;
    if (*((unsigned char *)a2 + 72))
    {
      double v32 = v29 * (double)v27;
      if (v32 > a5)
      {
        CTFontRef v33 = CTFontCreateWithFontDescriptor((CTFontDescriptorRef)atomic_load_explicit((atomic_ullong *volatile)(*((void *)RubyFont + 5) + 8), memory_order_acquire), v29 * a5 / v32, 0);
        CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Line, memory_order_acquire), @"NSFont", v33);
      }
    }
    CFAllocatorRef v34 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFMutableStringRef v35 = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v25);
    if (a3 == 2)
    {
      int v36 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&Line, memory_order_acquire);
      CFDictionarySetValue(v36, @"CTVerticalForms", (const void *)*MEMORY[0x1E4F1CFD0]);
      BOOL v47 = 0;
      if (HasToneString(v25, &v47))
      {
        v56.CFIndex location = v27 - 1;
        v56.CFIndex length = 1;
        CFStringDelete(v35, v56);
        if (v47)
        {
          ToneString  = (const __CFString *)GetToneString(5);
          CFStringInsert(v35, 0, ToneString);
          *((unsigned char *)this + 65)  = 1;
        }
        else
        {
          v58.CFIndex location = v27 - 1;
          v58.CFIndex length = 1;
          unsigned int v40 = (__CFString *)CFStringCreateWithSubstring(v34, v25, v58);
          CFAttributedStringRef v41 = CFAttributedStringCreate(v34, v40, (CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Line, memory_order_acquire));
          id v46 = (id)CreateLine(v41, a6);
        }
      }
    }
    id v46 = CFAttributedStringCreate(v34, v35, (CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Line, memory_order_acquire));

    id v39 = Line;
  }

  Line  = (id)CreateLine((const __CFAttributedString *)atomic_load_explicit((atomic_ullong *volatile)&v52, memory_order_acquire), a6);
  unint64_t v42 = atomic_load_explicit((atomic_ullong *volatile)this, memory_order_acquire);
  if (v42)
  {
    uint64_t v43 = *(void *)(v42 + 40);
    *((void *)this + 2)  = *(void *)(v43 + 112);
    *((void *)this + 3)  = *(void *)(v43 + 120);
    double v44 = *(double *)(v43 + 128);
    if (v44 == -1.79769313e308) {
      double v44 = 0.0;
    }
    *((double *)this + 4)  = v44;
    uint64_t v45 = *(void *)(v43 + 104);
  }
  else
  {
    uint64_t v45 = 0;
  }
  *((void *)this + 5)  = v45;
  *((unsigned char *)this + 64)  = a6;
LABEL_34:
}

void TRubyRun::UpdateWidth(TRubyRun *this, TLine *a2, uint64_t a3, double a4)
{
  if (*((double *)this + 89) <= 0.0)
  {
    uint64_t v7 = 0;
    CFNumberRef v8 = (TRubyRun *)((char *)this + 192);
    double v9 = *((double *)this + 24);
    int v10 = *((unsigned __int8 *)this + 328);
    unsigned int v11 = *((unsigned __int8 *)this + 329);
    int v12 = (double *)*((void *)this + 39);
    if (!v12) {
      int v12 = (double *)MEMORY[0x1E4F1DB30];
    }
    double v13 = *v12;
    double v14 = *(double *)(*(void *)(atomic_load_explicit((atomic_ullong *volatile)this + 7, memory_order_acquire) + 40)
                    + 16);
    int v15 = *((unsigned __int8 *)this + 90);
    uint64_t v16 = 216;
    if (!*((unsigned char *)this + 90)) {
      uint64_t v16 = 144;
    }
    double v17 = v9 + v13;
    *((double *)this + 90)  = v9 + v13;
    double v18 = v9 + v13;
    do
    {
      if (v18 < *(double *)((char *)this + v7 + 448)) {
        double v18 = *(double *)((char *)this + v7 + 448);
      }
      v7 += 72;
    }
    while (v16 != v7);
    uint64_t v19 = *((void *)this + 27);
    uint64_t v20 = *(void *)(v19 + 32);
    if (v20 || (uint64_t v23 = *(void *)(v19 + 24)) == 0)
    {
      int v21 = 0;
      uint64_t v22 = v20 + 16 * *((void *)this + 25);
    }
    else
    {
      uint64_t v22 = v23 + 8 * *((void *)this + 25);
      int v21 = 1;
    }
    double v24 = v14 * 0.25;
    double v25 = 0.0;
    if (v18 <= v17)
    {
      uint64_t v83 = *((void *)this + 26);
      int v28 = 0;
      double v29 = 0.0;
    }
    else
    {
      if (!a2) {
        return;
      }
      uint64_t v83 = *((void *)this + 26);
      if (a3 < 1)
      {
        int v28 = 0;
      }
      else
      {
        uint64_t v26 = *(void *)(*(void *)(*((void *)a2 + 2) + 8 * a3 - 8) + 40);
        int v27 = (*(uint64_t (**)(uint64_t))(*(void *)v26 + 120))(v26);
        if (v11 < 2) {
          int v28 = v27;
        }
        else {
          int v28 = 0;
        }
      }
      uint64_t v30 = *((void *)a2 + 2);
      BOOL v32 = ((*((void *)a2 + 3) - v30) >> 3) - 1 > a3
         && (uint64_t v31 = *(void *)(*(void *)(v30 + 8 * a3 + 8) + 40),
             (*(unsigned int (**)(uint64_t))(*(void *)v31 + 120))(v31))
         && (v11 & 0xFD) == 0;
      double v33 = v18 - v17;
      uint64_t v34 = CountGraphemes(this);
      double v29 = 0.0;
      switch(v10)
      {
        case 0:
        case 4:
        case 5:
          double v35 = v33 * 0.5;
          if (v24 <= v33 * 0.5) {
            double v35 = v24;
          }
          if (v28) {
            double v36 = v35;
          }
          else {
            double v36 = 0.0;
          }
          if (v32) {
            double v37 = v35;
          }
          else {
            double v37 = 0.0;
          }
          double v38 = v18 - (v36 + v37);
          if (v10 == 4) {
            double v39 = 0.0;
          }
          else {
            double v39 = (v33 - (v36 + v37)) / (double)v34;
          }
          double v40 = v38 - v39;
          double v41 = v18 - v40;
          double v42 = v40 - v17;
          if (v34 >= 2) {
            double v43 = v42 / (double)(v34 - 1);
          }
          else {
            double v43 = 0.0;
          }
          if (v36 <= 0.0 || v37 <= 0.0)
          {
            BOOL v46 = v37 < 0.0;
            double v45 = v41 - v37;
            if (v46) {
              double v45 = 0.0;
            }
            double v47 = v41 - v36;
            if (v36 <= 0.0)
            {
              double v44 = 0.0;
            }
            else
            {
              double v45 = 0.0;
              double v44 = v47;
            }
          }
          else
          {
            double v44 = v41 * 0.5 - v36;
            double v45 = v41 * 0.5 - v37;
          }
          double v48 = v42 * 0.5;
          if (v34 >= 2) {
            double v48 = -0.0;
          }
          double v29 = v48 + v45;
          CGFloat v49 = v48 + v44;
          v85.height  = 0.0;
          v85.double width = v49;
          TRun::AdvanceInitialAdvance(this, v85);
          *((CGFloat *)this + 93)  = v49;
          *((void *)this + 94)  = 0;
          if (v83 < 2)
          {
            double v18 = v38;
          }
          else
          {
            uint64_t v50 = 0;
            uint64_t v82 = v22;
            do
            {
              uint64_t v51 = *((void *)this + 27);
              uint64_t v52 = *((void *)this + 25);
              int v53 = *(_DWORD *)(*(void *)(v51 + 40) + 4 * v52 + 4 * v50);
              if ((v53 & 0x1040) == 0
                && (v53 & 0x20) == 0
                && *(unsigned __int16 *)(*(void *)(v51 + 16) + 2 * v52 + 2 * v50) != 0xFFFF)
              {
                if (v21)
                {
                  CFRange v54 = (double *)(v82 + 8 * v50);
                  uint64_t v55 = 0;
                }
                else
                {
                  uint64_t v55 = *(void *)(v22 + 8);
                  CFRange v54 = (double *)v22;
                }
                double v56 = v43 + *v54;
                TStorageRange::SetAdvance(v8, v50, *(CGSize *)(&v55 - 1));
              }
              ++v50;
              v22 += 16;
            }
            while (v83 - 1 != v50);
            double v18 = v38;
            uint64_t v22 = v82;
          }
          break;
        case 1:
          goto LABEL_66;
        case 3:
          goto LABEL_65;
        case 6:
          break;
        default:
          double v33 = v33 * 0.5;
LABEL_65:
          double v29 = v33;
LABEL_66:
          if (v10 == 3) {
            double v57 = 0.0;
          }
          else {
            double v57 = v33;
          }
          if (v24 > v29) {
            double v58 = v29;
          }
          else {
            double v58 = v24;
          }
          if (v28) {
            double v59 = v58;
          }
          else {
            double v59 = 0.0;
          }
          if (v24 > v57) {
            double v60 = v57;
          }
          else {
            double v60 = v24;
          }
          if (v32) {
            double v61 = v60;
          }
          else {
            double v61 = 0.0;
          }
          CGFloat v62 = v29 - v59;
          double v29 = v57 - v61;
          v86.height  = 0.0;
          v86.double width = v62;
          TRun::AdvanceInitialAdvance(this, v86);
          *((CGFloat *)this + 93)  = v62;
          *((void *)this + 94)  = 0;
          double v18 = v18 - (v59 + v61);
          break;
      }
    }
    TRubyAnnotationLine::UpdateWidth((TRubyRun *)((char *)this + 408), v10, v28, v17, v24);
    TRubyAnnotationLine::UpdateWidth((TRubyRun *)((char *)this + 480), v10, v28, v17, v24);
    if (atomic_load_explicit((atomic_ullong *volatile)this + 69, memory_order_acquire))
    {
      double v63 = *((double *)this + 71) + *((double *)this + 72);
      if (v15) {
        double v25 = 0.0;
      }
      else {
        double v25 = v63 + 0.0;
      }
      if (v10 == 2)
      {
        double v64 = *((double *)this + 74);
        if (*((unsigned char *)this + 617))
        {
          uint64_t v65 = *(void *)(atomic_load_explicit((atomic_ullong *volatile)this + 69, memory_order_acquire) + 40);
          if (v65)
          {
            uint64_t v67 = v65 + 16;
            uint64_t v66 = *(void *)(v65 + 16);
            if (*(void *)(v67 + 8) - v66 >= 1)
            {
              uint64_t v68 = *(void *)(*(void *)v66 + 40);
              if (v68)
              {
                v84.CFIndex location = 0;
                v84.CFIndex length = 1;
                double Width = TStorageRange::GetWidth((TStorageRange *)(v68 + 192), v84);
                uint64_t v70 = *(double **)(v68 + 312);
                if (!v70) {
                  uint64_t v70 = (double *)MEMORY[0x1E4F1DB30];
                }
                double v71 = Width + *v70;
                if (!v15) {
                  double v71 = -v71;
                }
                double v64 = v64 + v71;
              }
            }
          }
        }
        Descent  = TRun::GetDescent(this);
        double v73 = Descent + TRun::GetAscent(this) - v64;
        if (v73 > 0.0) {
          *((double *)this + 75)  = v73 * 0.5;
        }
      }
      if (atomic_load_explicit((atomic_ullong *volatile)this + 70, memory_order_acquire))
      {
        double v74 = -0.0;
        if (!v15) {
          double v74 = v63;
        }
        unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)this + 70, memory_order_acquire);
        if (explicit) {
          double v76 = *(double *)(*(void *)(explicit + 40) + 104);
        }
        else {
          double v76 = 0.0;
        }
        double v25 = v74 + v25;
        *((double *)this + 76)  = *((double *)this + 75) + (*((double *)this + 74) - v76) * 0.5;
      }
    }
    if (atomic_load_explicit((atomic_ullong *volatile)this + 78, memory_order_acquire))
    {
      *((double *)this + 84)  = v17 + v25;
      double v25 = v25 + *((double *)this + 83);
    }
    if (v25 >= v29) {
      double v77 = v25;
    }
    else {
      double v77 = v29;
    }
    if (v77 > 0.0)
    {
      uint64_t v78 = v83 - 1;
      if (v21)
      {
        uint64_t v79 = v22 + 8 * v78;
        uint64_t v80 = 0;
      }
      else
      {
        uint64_t v79 = v22 + 16 * v78;
        uint64_t v80 = *(void *)(v79 + 8);
      }
      double v81 = v77 + *(double *)v79;
      TStorageRange::SetAdvance(v8, v78, *(CGSize *)(&v80 - 1));
    }
    TRubyRun::AdvanceRubyLinesInitialAdvance(this, 0.0);
    *((double *)this + 89)  = v18 + v25;
  }
}

uint64_t CountGraphemes(const TRun *a1)
{
  uint64_t v1 = *((void *)a1 + 26);
  if (v1 < 1) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v4 = *((void *)a1 + 27);
  uint64_t v5 = *((void *)a1 + 25);
  do
  {
    int v6 = *(_DWORD *)(*(void *)(v4 + 40) + 4 * v5);
    if ((v6 & 0x1040) == 0)
    {
      BOOL v8 = (v6 & 0x20) == 0 && *(__int16 *)(*(void *)(v4 + 16) + 2 * v5) != -1;
      result += v8;
    }
    ++v5;
    --v1;
  }
  while (v1);
  return result;
}

void TRubyAnnotationLine::UpdateWidth(TRubyAnnotationLine *this, int a2, int a3, double a4, double a5)
{
  if (atomic_load_explicit((atomic_ullong *volatile)this, memory_order_acquire))
  {
    double v8 = *((double *)this + 5);
    double v9 = a4 - v8;
    if (a4 - v8 <= 0.0)
    {
      if (a4 - v8 >= 0.0) {
        return;
      }
      if (a2 == 1)
      {
        double v10 = 0.0;
      }
      else
      {
        if (a2 == 3)
        {
          double v21 = -v9;
        }
        else
        {
          if (a2 == 6) {
            return;
          }
          double v21 = v9 * -0.5;
        }
        if (v21 >= a5) {
          double v21 = a5;
        }
        if (!a3) {
          double v21 = 0.0;
        }
        double v10 = -v21;
      }
LABEL_29:
      *((double *)this + 6)  = v10;
    }
    else
    {
      double v10 = 0.0;
      switch(a2)
      {
        case 0:
        case 4:
        case 5:
          uint64_t v11 = *(void *)(atomic_load_explicit((atomic_ullong *volatile)this, memory_order_acquire) + 40);
          double v13 = *(uint64_t **)(v11 + 16);
          uint64_t v12 = *(void *)(v11 + 24);
          if (v12 - (uint64_t)v13 >= 1)
          {
            uint64_t v14 = 0;
            uint64_t v15 = (unint64_t)(v12 - (void)v13) >> 3 <= 1 ? 1 : (unint64_t)(v12 - (void)v13) >> 3;
            do
            {
              uint64_t v16 = *v13++;
              v14 += CountGraphemes(*(const TRun **)(v16 + 40));
              --v15;
            }
            while (v15);
            if (v14 >= 2)
            {
              double v17 = 0.0;
              if (a2 != 4) {
                double v17 = v9 / (double)v14;
              }
              double v18 = a4 - v17;
              JustifiedLine  = CTLineCreateJustifiedLine((CTLineRef)atomic_load_explicit((atomic_ullong *volatile)this, memory_order_acquire), 1.0, a4 - v17);
              if (JustifiedLine)
              {
                CTLineRef v20 = JustifiedLine;
                TCFRef<__CTFont const*>::Retain((atomic_ullong *)this, JustifiedLine);
                CFRelease(v20);
                *((double *)this + 5)  = v18;
              }
            }
          }
          double v10 = (a4 - *((double *)this + 5)) * 0.5;
          goto LABEL_29;
        case 1:
          goto LABEL_29;
        case 3:
          double v10 = v9;
          goto LABEL_29;
        case 6:
          return;
        default:
          double v10 = v9 * 0.5;
          goto LABEL_29;
      }
    }
  }
}

double TRubyRun::GetImageBounds(atomic_ullong *this, CGContext *a2, CFRange a3, double *a4, double *a5)
{
  ImageBounds  = TRun::GetImageBounds((TRun *)this, a2, a3, a4, a5);
  CGFloat y = v7;
  CGFloat width = v9;
  height  = v11;
  unsigned int v13 = 0;
  do
  {
    unint64_t explicit = atomic_load_explicit(this + 51, memory_order_acquire);
    if (explicit)
    {
      uint64_t v15 = *(CFIndex **)(explicit + 40);
      v21.CFIndex length = v15[18];
      v21.CFIndex location = 0;
      v24.origin.double x = TLine::GetImageBounds((TLine *)v15, 0, v21);
      v24.origin.CGFloat y = v16;
      v24.size.CGFloat width = v17;
      v24.size.height  = v18;
      v22.origin.double x = ImageBounds;
      v22.origin.CGFloat y = y;
      v22.size.CGFloat width = width;
      v22.size.height  = height;
      CGRect v23 = CGRectUnion(v22, v24);
      ImageBounds  = v23.origin.x;
      CGFloat y = v23.origin.y;
      CGFloat width = v23.size.width;
      height  = v23.size.height;
    }
  }
  while (v13++ < 3);
  return ImageBounds;
}

void *TRubyRun::CopyDescriptionDictionary(TRubyRun *this, uint64_t a2)
{
  v21[6]  = *MEMORY[0x1E4F143B8];
  id v4 = TRun::CopyDescriptionDictionary(this, a2);
  uint64_t v15 = (void *)[(id)(id)CFMakeCollectable(v4) mutableCopy];
  uint64_t v5 = (void *)[MEMORY[0x1E4F1CA60] dictionary];
  uint64_t v6 = 0;
  uint64_t v14 = (double *)this;
  double v7 = (double *)((char *)this + 408);
  do
  {
    if (atomic_load_explicit((atomic_ullong *volatile)v7, memory_order_acquire))
    {
      v20[0]  = @"ascent";
      v21[0]  = [NSNumber numberWithDouble:v7[2]];
      v20[1]  = @"descent";
      v21[1]  = [NSNumber numberWithDouble:v7[3]];
      v20[2]  = @"leading";
      v21[2]  = [NSNumber numberWithDouble:v7[4]];
      v20[3]  = @"width";
      v21[3]  = [NSNumber numberWithDouble:v7[5]];
      v20[4]  = @"initialOffset";
      v21[4]  = [NSNumber numberWithDouble:v7[6]];
      v20[5]  = @"line";
      id v8 = CTCopyDescriptionDictionary((void *)atomic_load_explicit((atomic_ullong *volatile)v7, memory_order_acquire), a2);
      v21[5]  = (id)CFMakeCollectable(v8);
      uint64_t v9 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v21 forKeys:v20 count:6];
      if ((v6 & 0xFC) != 0) {
        uint64_t v10 = 0;
      }
      else {
        uint64_t v10 = *((void *)&off_1E528F638 + v6);
      }
      objc_msgSend(v5, "setObject:forKeyedSubscript:", v9, v10, v14);
    }
    ++v6;
    v7 += 9;
  }
  while (v6 != 4);
  objc_msgSend(v15, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithDouble:", TRun::GetAscent((TRun *)v14)), @"baseAscent");
  objc_msgSend(v15, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithDouble:", TRun::GetDescent((TRun *)v14)), @"baseDescent");
  v18[0]  = @"baseInitialAdvance";
  v16[0]  = @"width";
  uint64_t v11 = [NSNumber numberWithDouble:v14[93]];
  v16[1]  = @"height";
  v17[0]  = v11;
  v17[1]  = [NSNumber numberWithDouble:v14[94]];
  uint64_t v12 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v17 forKeys:v16 count:2];
  v18[1]  = @"lines";
  v19[0]  = v12;
  v19[1]  = v5;
  objc_msgSend(v15, "setObject:forKeyedSubscript:", objc_msgSend(MEMORY[0x1E4F1C9E8], "dictionaryWithObjects:forKeys:count:", v19, v18, 2), @"rubyAnnotations");
  return v15;
}

void TRubyRun::CopyRubyAnnotationLineForPosition(TRubyRun *this@<X0>, unsigned int a2@<W1>, void *a3@<X8>)
{
  if (a2 == 5) {
    unsigned int v4 = 2;
  }
  else {
    unsigned int v4 = a2;
  }
  if (v4 > 3)
  {
    *a3  = 0;
  }
  else
  {
    uint64_t v5 = (char *)this + 72 * v4;
    uint64_t v6 = (atomic_ullong *)(v5 + 408);
    double v7 = (atomic_ullong *)(v5 + 416);
    if (a2 != 5) {
      double v7 = v6;
    }
    id v8 = (id)atomic_load_explicit(v7, memory_order_acquire);
    *a3  = atomic_exchange((atomic_ullong *volatile)&v8, 0);
  }
}

uint64_t ___ZN19TRubyAnnotationLine18InitWithAnnotationERK15TRubyAnnotation14CTRubyPositionPK14__CFDictionarydb_block_invoke(uint64_t a1, uint64_t a2, CFIndex a3, CFIndex a4)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  long long v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  double v7 = *(void **)(a1 + 32);
  uint64_t result = [v7 countByEnumeratingWithState:&v18 objects:v22 count:16];
  if (result)
  {
    uint64_t v9 = result;
    uint64_t v10 = *(void *)v19;
    do
    {
      uint64_t v11 = 0;
      do
      {
        if (*(void *)v19 != v10) {
          objc_enumerationMutation(v7);
        }
        CFStringRef v12 = *(const __CFString **)(*((void *)&v18 + 1) + 8 * v11);
        int Value = (const __CTFont *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), v12);
        if (Value)
        {
          uint64_t v14 = Value;
          if (v12 == @"NSFont" || @"NSFont" && v12 && CFEqual(v12, @"NSFont"))
          {
            RubyFont  = CreateRubyFont(v14, *(CGFloat *)(*((void *)v14 + 5) + 16), *(unsigned __int8 *)(a1 + 48));
            v24.CFIndex location = a3;
            v24.CFIndex length = a4;
            CFAttributedStringSetAttribute((CFMutableAttributedStringRef)atomic_load_explicit((atomic_ullong *volatile)(a1 + 40), memory_order_acquire), v24, v12, RubyFont);
          }
        }
        else
        {
          unint64_t explicit = (__CFAttributedString *)atomic_load_explicit((atomic_ullong *volatile)(a1 + 40), memory_order_acquire);
          CGFloat v17 = (const void *)[*(id *)(a1 + 32) objectForKeyedSubscript:v12];
          v25.CFIndex location = a3;
          v25.CFIndex length = a4;
          CFAttributedStringSetAttribute(explicit, v25, v12, v17);
        }
        ++v11;
      }
      while (v9 != v11);
      uint64_t result = [v7 countByEnumeratingWithState:&v18 objects:v22 count:16];
      uint64_t v9 = result;
    }
    while (result);
  }
  return result;
}

id __copy_helper_block_8_40c36_ZTS6TCFRefIP20__CFAttributedStringE(uint64_t a1, uint64_t a2)
{
  id result = (id)atomic_load_explicit((atomic_ullong *volatile)(a2 + 40), memory_order_acquire);
  *(void *)(a1 + 40)  = result;
  return result;
}

void __destroy_helper_block_8_40c36_ZTS6TCFRefIP20__CFAttributedStringE(uint64_t a1)
{
}

BOOL HasToneString(const __CFString *a1, BOOL *a2)
{
  ToneString  = (const __CFString *)GetToneString(5);
  if (CFStringHasSuffix(a1, ToneString))
  {
    BOOL result = 1;
    *a2  = 1;
  }
  else
  {
    CFStringRef v6 = (const __CFString *)GetToneString(2);
    if (CFStringHasSuffix(a1, v6)) {
      return 1;
    }
    CFStringRef v7 = (const __CFString *)GetToneString(3);
    if (CFStringHasSuffix(a1, v7))
    {
      return 1;
    }
    else
    {
      CFStringRef v8 = (const __CFString *)GetToneString(4);
      return CFStringHasSuffix(a1, v8) != 0;
    }
  }
  return result;
}

unint64_t CreateLine(const __CFAttributedString *a1, int a2)
{
  keys[34]  = *(void **)MEMORY[0x1E4F143B8];
  id v21 = 0;
  if (a2)
  {
    id values = (void *)*MEMORY[0x1E4F1CFD0];
    keys[0]  = @"CTTypesetterOptionVerticalLayout";
    id v20 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  }
  memcpy(keys, &unk_184BA1CD0, 0x110uLL);
  TTypesetterAttrString::TTypesetterAttrString((TTypesetterAttrString *)keys, a1, (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v21, memory_order_acquire), 1);
  id values = (void *)0xAAAAAAAAAAAAAAAALL;
  TCFBase_NEW<CTLine,std::shared_ptr<TCharStream const> const&>((uint64_t *)keys, &values);
  if (!atomic_load_explicit((atomic_ullong *volatile)&values, memory_order_acquire))
  {
    unint64_t v12 = 0;
    goto LABEL_31;
  }
  TTypesetter::FillLine((TTypesetter *)keys, *(TLine **)(atomic_load_explicit((atomic_ullong *volatile)&values, memory_order_acquire) + 40), 1.79769313e308, 0.0);
  if (atomic_load_explicit((atomic_ullong *volatile)&values, memory_order_acquire))
  {
    uint64_t v3 = *(void *)(atomic_load_explicit((atomic_ullong *volatile)&values, memory_order_acquire) + 40);
    unsigned int v4 = *(uint64_t **)(v3 + 16);
    uint64_t v5 = *(void *)(v3 + 24) - (void)v4;
    if (v5 >= 1)
    {
      uint64_t v6 = (unint64_t)v5 >> 3;
      if ((unint64_t)v5 >> 3 <= 1) {
        uint64_t v6 = 1;
      }
      do
      {
        uint64_t v7 = *v4++;
        *(void *)(*(void *)(v7 + 48) + 272)  = v3;
        --v6;
      }
      while (v6);
    }
    if ((*(_WORD *)(v3 + 154) & 8) == 0) {
      goto LABEL_28;
    }
    uint64_t v8 = v5 >> 3;
    uint64_t v9 = *(void *)(v3 + 72);
    uint64_t v10 = *(void *)(v3 + 88);
    if (v10) {
      goto LABEL_11;
    }
    uint64_t RunWithCharIndex = TLine::FindRunWithCharIndex((TLine *)v3, *(void *)(v3 + 72), 1);
    if (RunWithCharIndex >= v8)
    {
      uint64_t v10 = 0;
    }
    else
    {
      uint64_t v10 = *(void *)(*(void *)(*(void *)(v3 + 16) + 8 * RunWithCharIndex) + 48);
      if (v10)
      {
LABEL_11:
        if (*(unsigned char *)(v10 + 224)) {
          uint64_t v11 = *(void *)(v10 + 208) - 1;
        }
        else {
          uint64_t v11 = 0;
        }
        uint64_t v14 = *(void *)(v10 + 216);
        uint64_t v15 = *(void *)(v10 + 200);
        if (*(__int16 *)(*(void *)(v14 + 16) + 2 * v15 + 2 * v11) == -1
          && *(void *)(*(void *)(v14 + 48) + 8 * v15 + 8 * v11) == v9)
        {
          *(void *)(v10 + 264)  = v11;
        }
      }
    }
    if (v5 >= 1)
    {
      uint64_t v16 = v8 - 1;
      do
      {
        CGFloat v17 = *(TRun **)(*(void *)(*(void *)(v3 + 16) + 8 * v16) + 48);
        if (v17 != (TRun *)v10 && !TRun::GetNonDeletedGlyphCount(v17)) {
          TLine::DeleteRun((TLine *)v3, v16);
        }
        uint64_t v18 = v16-- + 1;
      }
      while (v18 > 1);
    }
LABEL_28:
    if ((*(_WORD *)(v3 + 154) & 0x20) != 0) {
      TLine::DoGlyphFixups((TLine *)v3);
    }
  }
  unint64_t v12 = atomic_exchange((atomic_ullong *volatile)&values, 0);
LABEL_31:

  if (keys[31]) {
    std::__shared_weak_count::__release_shared[abi:nn180100]((std::__shared_weak_count *)keys[31]);
  }
  TLine::~TLine((TLine *)keys);

  return v12;
}

uint64_t GetToneString(int a1)
{
  uint64_t v8 = v1;
  uint64_t v9 = v2;
  switch(a1)
  {
    case 2:
      UniChar v7 = 714;
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB2CE348, memory_order_acquire) & 1) == 0)
      {
        if (__cxa_guard_acquire(&qword_1EB2CE348))
        {
          qword_1EB2CE340  = (uint64_t)CFStringCreateWithCharacters((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &v7, 1);
          __cxa_guard_release(&qword_1EB2CE348);
        }
      }
      uint64_t result = qword_1EB2CE340;
      break;
    case 3:
      UniChar v6 = 711;
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB2CE358, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EB2CE358))
      {
        qword_1EB2CE350  = (uint64_t)CFStringCreateWithCharacters((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &v6, 1);
        __cxa_guard_release(&qword_1EB2CE358);
      }
      uint64_t result = qword_1EB2CE350;
      break;
    case 4:
      UniChar v5 = 715;
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB2CE368, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EB2CE368))
      {
        qword_1EB2CE360  = (uint64_t)CFStringCreateWithCharacters((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &v5, 1);
        __cxa_guard_release(&qword_1EB2CE368);
      }
      uint64_t result = qword_1EB2CE360;
      break;
    case 5:
      chars  = 729;
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB2CE378, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EB2CE378))
      {
        qword_1EB2CE370  = (uint64_t)CFStringCreateWithCharacters((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &chars, 1);
        __cxa_guard_release(&qword_1EB2CE378);
      }
      uint64_t result = qword_1EB2CE370;
      break;
    default:
      uint64_t result = 0;
      break;
  }
  return result;
}

void TRubyRun::~TRubyRun(id *this)
{
  uint64_t v2 = 0;
  *this  = &unk_1ED05F428;
  do
  {

    v2 -= 9;
  }
  while (v2 != -36);
  TRubyAnnotation::~TRubyAnnotation(this + 41);

  TRun::~TRun(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  uint64_t v2 = 0;
  *this  = &unk_1ED05F428;
  do
  {

    v2 -= 9;
  }
  while (v2 != -36);
  TRubyAnnotation::~TRubyAnnotation(this + 41);

  TRun::~TRun(this);

  JUMPOUT(0x1853275C0);
}

uint64_t TRubyRun::FindBreak@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, const TCharStream *a3@<X2>, int a4@<W3>, uint64_t a5@<X8>, double a6@<D0>)
{
  uint64_t v6 = result;
  if (atomic_load_explicit((atomic_ullong *volatile)(result + 408), memory_order_acquire))
  {
LABEL_2:
    double v8 = *(double *)(result + 712);
    if (v8 > 0.0)
    {
      uint64_t v9 = *(void *)(result + 8) - a2 + *(void *)(result + 16);
      BOOL v10 = v8 <= a6;
      if (v8 > a6) {
        uint64_t v9 = 0;
      }
      double v11 = 0.0;
      *(unsigned char *)a5  = 0;
      if (v10) {
        double v11 = v8;
      }
      *(void *)(a5 + 8)  = v9;
      *(double *)(a5 + 16)  = v11;
      return result;
    }
  }
  else
  {
    unint64_t v12 = (atomic_ullong *)(result + 480);
    unint64_t v13 = -1;
    while (v13 != 2)
    {
      unint64_t explicit = atomic_load_explicit(v12, memory_order_acquire);
      ++v13;
      v12 += 9;
      if (explicit)
      {
        if (v13 <= 2) {
          goto LABEL_2;
        }
        break;
      }
    }
  }
  *(_OWORD *)a5  = xmmword_184BA1DE0;
  *(void *)(a5 + 16)  = -1;
  uint64_t result = TRun::FindBreak(result, a2, a3, a4, a5, a6);
  if (*(double *)(v6 + 712) <= 0.0) {
    *(unsigned char *)a5 |= 8u;
  }
  return result;
}

double TRubyRun::GetAscent(TRubyRun *this)
{
  return *((double *)this + 87);
}

double TRubyRun::GetDescent(TRubyRun *this)
{
  return *((double *)this + 88);
}

uint64_t TRubyRun::CanUpdateWidth(TRubyRun *this)
{
  return 1;
}

uint64_t TRubyRun::AcceptsOverhang(TRubyRun *this)
{
  return 0;
}

void TRubyRun::UpdateCachedMetrics(TRubyRun *this, double a2)
{
}

CFSetRef GetValidRubyAttributes(void)::$_0::__invoke()
{
  values[12]  = *(void **)MEMORY[0x1E4F143B8];
  values[0]  = @"CTBackgroundColor";
  values[1]  = @"CTBaselineOffset";
  values[2]  = @"NSFont";
  values[3]  = @"CTForegroundColor";
  values[4]  = @"NSKern";
  values[5]  = @"NSLanguage";
  values[6]  = @"NSLigature";
  values[7]  = @"CTRenderingStyle";
  values[8]  = @"NSStrokeWidth";
  values[9]  = @"CTStrokeColor";
  values[10]  = @"CTTracking";
  values[11]  = @"NSBackgroundColor";
  CFSetRef result = CFSetCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)values, 12, MEMORY[0x1E4F1D548]);
  _MergedGlobals_19  = (uint64_t)result;
  return result;
}

uint64_t OTL::GSUB::ApplyMultipleSubst(uint64_t a1, uint64_t a2, uint64_t *a3, unsigned int a4, _WORD *a5, uint64_t a6)
{
  v29[4]  = *MEMORY[0x1E4F143B8];
  unint64_t v6 = *(void *)(a1 + 40);
  unint64_t v7 = a2 + 6;
  if (a2 + 6 > v6) {
    return 0;
  }
  uint64_t v11 = bswap32(*(unsigned __int16 *)(a2 + 4)) >> 16;
  unint64_t v12 = v7 + 2 * v11;
  BOOL v14 = v12 >= v7 && v12 <= v6;
  unint64_t v15 = (v6 - v7) >> 1;
  if (a2 + 8 > v6) {
    unint64_t v15 = 0;
  }
  if (!v14 && v15 != v11 || v11 < a4) {
    return 0;
  }
  unsigned int v16 = a4 - 1;
  if (v14)
  {
    if (v16 >= v11) {
      return 0;
    }
  }
  else if (v15 != v11 || v16 >= v11)
  {
    return 0;
  }
  uint64_t v18 = (unsigned __int16 *)(a2 + (bswap32(*(unsigned __int16 *)(a2 + 2 * v16 + 6)) >> 16));
  long long v19 = v18 + 1;
  if ((unint64_t)(v18 + 1) <= v6)
  {
    unsigned int v20 = *v18;
    uint64_t v21 = __rev16(v20);
    CGRect v22 = &v19[v21];
    unint64_t v23 = (unint64_t)(v18 + 2) <= v6 ? (v6 - (unint64_t)v19) >> 1 : 0;
    BOOL v24 = (unint64_t)v22 <= v6 && v22 >= v19;
    if (v24 || v23 == v21)
    {
      if (v20)
      {
        std::__function::__value_func<void ()(CFRange,long)>::__value_func[abi:nn180100]((uint64_t)v29, a6);
        int v26 = TGlyphIterator::ReplaceWithGlyphs((uint64_t)a3, v21, v19, (uint64_t)v29);
        std::__function::__value_func<void ()(CFRange,long)>::~__value_func[abi:nn180100](v29);
        if (!v26)
        {
          uint64_t result = 1;
          **(unsigned char **)(a6 + 32)  = 1;
          return result;
        }
        uint64_t v27 = a3[9];
        a3[9]  = 0;
        TGlyphIterator::Next((TGlyphIterator *)a3, (v21 - 1));
        a3[9]  = v27;
      }
      else
      {
        TRunGlue::Delete((void *)*a3, a3[6], 0);
        ++*a5;
      }
      return 1;
    }
  }
  return 0;
}

uint64_t OTL::GSUB::ApplyAlternateSubst(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, unsigned int a5, uint64_t a6)
{
  uint64_t v12 = *(void *)(a3 + 48);
  GlyphID  = TRunGlue::GetGlyphID(*(TRunGlue **)a3, v12);
  unint64_t v14 = *(void *)(a1 + 40);
  unint64_t v15 = a2 + 6;
  if (a2 + 6 > v14) {
    return 0;
  }
  uint64_t v16 = GlyphID;
  uint64_t v17 = bswap32(*(unsigned __int16 *)(a2 + 4)) >> 16;
  unint64_t v18 = v15 + 2 * v17;
  BOOL v20 = v18 >= v15 && v18 <= v14;
  unint64_t v21 = (v14 - v15) >> 1;
  if (a2 + 8 > v14) {
    unint64_t v21 = 0;
  }
  if (!v20 && v21 != v17) {
    return 0;
  }
  if (v17 >= a4)
  {
    unsigned int v22 = a4 - 1;
    if (v20)
    {
      if (v22 >= v17) {
        goto LABEL_36;
      }
    }
    else if (v21 != v17 || v22 >= v17)
    {
      goto LABEL_36;
    }
    BOOL v24 = (unsigned __int16 *)(a2 + (bswap32(*(unsigned __int16 *)(a2 + 2 * v22 + 6)) >> 16));
    CFRange v25 = v24 + 1;
    if ((unint64_t)(v24 + 1) <= v14)
    {
      uint64_t v26 = bswap32(*v24) >> 16;
      unint64_t v27 = (unint64_t)&v25[v26];
      if ((unint64_t)(v24 + 2) <= v14) {
        unint64_t v28 = (v14 - (unint64_t)v25) >> 1;
      }
      else {
        unint64_t v28 = 0;
      }
      if ((v27 <= v14 && v27 >= (unint64_t)v25 || v28 == v26) && v26 > a5) {
        uint64_t v16 = bswap32(v24[a5 + 1]) >> 16;
      }
    }
  }
LABEL_36:
  TRunGlue::SetGlyphID<true>(*(TRunGlue **)a3, v12, v16);
  uint64_t v32 = 1;
  std::function<void ()(CFRange,long)>::operator()(a6, v12, 1, 1);
  return v32;
}

unsigned __int16 *EqualSequenceAndNote<BigEndianScalar<unsigned short>>(unsigned __int16 *a1, unsigned __int16 *a2, uint64_t *a3, void *a4)
{
  unsigned int v4 = a1;
  if (a1 != a2)
  {
    while (TRunGlue::GetGlyphID((TRunGlue *)*a3, a3[6]) == bswap32(*v4) >> 16)
    {
      *a4  = a3[6];
      if (++v4 == a2) {
        return a2;
      }
      ++a4;
      if ((TGlyphIterator::Next((TGlyphIterator *)a3, 1) & 1) == 0) {
        return v4;
      }
    }
  }
  return v4;
}

uint64_t OTL::GSUB::WouldSubstituteLigature(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, unsigned int a5)
{
  unint64_t v5 = *(void *)(a1 + 40);
  unint64_t v6 = a2 + 6;
  if ((unint64_t)(a2 + 4) < *(void *)(a1 + 32) || v6 > v5) {
    return 0;
  }
  uint64_t v8 = bswap32(*(unsigned __int16 *)(a2 + 4)) >> 16;
  unint64_t v9 = v6 + 2 * v8;
  BOOL v11 = v9 >= v6 && v9 <= v5;
  unint64_t v12 = (v5 - v6) >> 1;
  if (a2 + 8 > v5) {
    unint64_t v12 = 0;
  }
  if (!v11 && v12 != v8 || v8 < a3) {
    return 0;
  }
  unsigned int v13 = a3 - 1;
  if (v11)
  {
    if (v13 >= v8) {
      return 0;
    }
  }
  else if (v12 != v8 || v13 >= v8)
  {
    return 0;
  }
  unint64_t v15 = (unsigned __int16 *)(a2 + (bswap32(*(unsigned __int16 *)(a2 + 2 * v13 + 6)) >> 16));
  uint64_t v16 = v15 + 1;
  if ((unint64_t)(v15 + 1) <= v5)
  {
    unsigned int v17 = *v15;
    unint64_t v18 = __rev16(v17);
    unint64_t v19 = (unint64_t)&v16[v18];
    BOOL v21 = v19 >= (unint64_t)v16 && v19 <= v5;
    unint64_t v22 = (v5 - (unint64_t)v16) >> 1;
    if ((unint64_t)(v15 + 2) > v5) {
      unint64_t v22 = 0;
    }
    int v23 = v22 == v18 || v21;
    if (v23 == 1 && v17 != 0)
    {
      unint64_t v26 = 0;
      while (1)
      {
        if (v21)
        {
          if (v26 >= v18) {
            return 0;
          }
        }
        else
        {
          uint64_t result = 0;
          if (v22 != v18 || v26 >= v18) {
            return result;
          }
        }
        unint64_t v27 = (char *)v15 + (bswap32(v15[v26 + 1]) >> 16);
        unint64_t v28 = (unsigned __int16 *)(v27 + 4);
        if ((unint64_t)(v27 + 4) > v5) {
          break;
        }
        unsigned int v29 = *((unsigned __int16 *)v27 + 1);
        uint64_t v30 = __rev16(v29);
        uint64_t v31 = &v28[v30 - 1];
        unint64_t v32 = (unint64_t)(v27 + 6) <= v5 ? (v5 - (unint64_t)v28) >> 1 : 0;
        BOOL v33 = (unint64_t)v31 <= v5 && v31 >= v28;
        if (!v33 && v32 != v30 - 1) {
          break;
        }
        if (v29) {
          BOOL v35 = v30 > a5;
        }
        else {
          BOOL v35 = 1;
        }
        if (!v35)
        {
          uint64_t v36 = (v30 - 1);
          double v37 = (unsigned __int16 *)(a4 + 2);
          while (v36)
          {
            int v39 = *v37++;
            int v38 = v39;
            unsigned int v40 = *v28++;
            --v36;
            if (v38 != bswap32(v40) >> 16) {
              goto LABEL_65;
            }
          }
          return 1;
        }
LABEL_65:
        uint64_t result = 0;
        if (++v26 == v18) {
          return result;
        }
      }
    }
  }
  return 0;
}

unsigned __int16 *ContextSubstFormat1::NthSubRuleSet(ContextSubstFormat1 *this, unsigned int a2, unint64_t a3)
{
  if (a2 >= bswap32(*((unsigned __int16 *)this + 2)) >> 16) {
    return 0;
  }
  uint64_t v3 = (unsigned __int16 *)((char *)this + (bswap32(*((unsigned __int16 *)this + a2 + 3)) >> 16));
  unsigned int v4 = v3 + 1;
  if ((unint64_t)(v3 + 1) > a3) {
    return 0;
  }
  uint64_t v6 = bswap32(*v3) >> 16;
  unint64_t v7 = (unint64_t)&v4[v6];
  if ((unint64_t)(v3 + 2) <= a3) {
    unint64_t v8 = (a3 - (unint64_t)v4) >> 1;
  }
  else {
    unint64_t v8 = 0;
  }
  if (v7 >= (unint64_t)v4 && v7 <= a3 || v8 == v6) {
    return v3;
  }
  else {
    return 0;
  }
}

uint64_t OTL::GSUB::ApplyContextSubstFormat1(void *a1, ContextSubstFormat1 *this, uint64_t a3, int a4, _WORD *a5, uint64_t a6, unint64_t a7)
{
  unint64_t v7 = a1[5];
  unint64_t v8 = (char *)this + 6;
  if ((unint64_t)this + 4 < a1[4] || (unint64_t)v8 > v7) {
    return 0;
  }
  uint64_t v11 = bswap32(*((unsigned __int16 *)this + 2)) >> 16;
  unint64_t v12 = &v8[2 * v11];
  unint64_t v13 = (unint64_t)this + 8 <= v7 ? (v7 - (unint64_t)v8) >> 1 : 0;
  BOOL v14 = (unint64_t)v12 <= v7 && v12 >= v8;
  if (!v14 && v13 != v11) {
    return 0;
  }
  uint64_t v21 = *(void *)(a3 + 48);
  *(void *)&long long v22 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v22 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  v55[29]  = v22;
  v55[30]  = v22;
  v55[27]  = v22;
  v55[28]  = v22;
  v55[25]  = v22;
  v55[26]  = v22;
  v55[23]  = v22;
  v55[24]  = v22;
  v55[21]  = v22;
  v55[22]  = v22;
  v55[19]  = v22;
  v55[20]  = v22;
  v55[17]  = v22;
  v55[18]  = v22;
  v55[16]  = v22;
  unint64_t v56 = 0xAAAAAAAAAAAAAAAALL;
  v55[15]  = v22;
  v55[14]  = v22;
  v55[13]  = v22;
  v55[12]  = v22;
  v55[11]  = v22;
  v55[10]  = v22;
  v55[9]  = v22;
  v55[8]  = v22;
  v55[6]  = v22;
  v55[7]  = v22;
  v55[4]  = v22;
  v55[5]  = v22;
  v55[2]  = v22;
  v55[3]  = v22;
  v55[0]  = v22;
  v55[1]  = v22;
  uint64_t v54 = v21;
  uint64_t result = (uint64_t)ContextSubstFormat1::NthSubRuleSet(this, a4 - 1, v7);
  if (result)
  {
    BOOL v24 = (_WORD *)result;
    if (TGlyphIterator::Next((TGlyphIterator *)a3, 1))
    {
      uint64_t v25 = *(void *)(a3 + 48);
      GlyphID  = TRunGlue::GetGlyphID(*(TRunGlue **)a3, v25);
      uint64_t v27 = v25;
    }
    else
    {
      GlyphID  = 0xFFFF;
      uint64_t v27 = v21;
    }
    unint64_t v28 = (unint64_t)(v24 + 1);
    int v53 = (uint64_t *)a3;
    double v48 = a5;
    uint64_t v49 = a6;
    unint64_t v46 = a7;
    double v47 = a1;
    if (v24 + 1 < (_WORD *)this
      || (v29 = __rev16((unsigned __int16)*v24), unint64_t v30 = v28 + 2 * v29, v30 < v28)
      || v30 > v7)
    {
      BOOL v31 = (unint64_t)(v24 + 2) <= v7 && v28 >= (unint64_t)this;
      unsigned int v29 = (v7 - v28) >> 1;
      if (!v31) {
        unsigned int v29 = 0;
      }
      if (!(bswap32(v29) >> 16)) {
        goto LABEL_65;
      }
    }
    else if (!*v24)
    {
LABEL_65:
      uint64_t result = 0;
      v53[6]  = v21;
      return result;
    }
    unint64_t v32 = 0;
    if ((v29 & 0xFFFE) != 0) {
      uint64_t v33 = (unsigned __int16)v29;
    }
    else {
      uint64_t v33 = 1;
    }
    uint64_t v52 = v21;
    int v51 = GlyphID;
    uint64_t v50 = v33;
    while (1)
    {
      if (v32 < bswap32((unsigned __int16)*v24) >> 16)
      {
        uint64_t v34 = (_WORD *)((char *)v24 + (bswap32((unsigned __int16)v24[v32 + 1]) >> 16));
        BOOL v35 = v34 + 2;
        if ((unint64_t)(v34 + 2) <= v7)
        {
          if (*v34)
          {
            unint64_t v36 = __rev16(*v34);
            if (v36 <= 0x40)
            {
              uint64_t v37 = (v36 - 1);
              int v38 = &v35[v37];
              if (v35 < (unsigned __int16 *)this || v38 < v35 || (unint64_t)v38 > v7)
              {
                BOOL v41 = (unint64_t)(v34 + 3) <= v7 && v35 >= (unsigned __int16 *)this;
                unint64_t v42 = (v7 - (unint64_t)v35) >> 1;
                if (!v41) {
                  unint64_t v42 = 0;
                }
                if (v42 != v37) {
                  goto LABEL_65;
                }
              }
              double v43 = &v35[v36 - 1];
              if (v35 != v43 && v27 != v21 && GlyphID == bswap32(*v35) >> 16)
              {
                *(void *)&v55[0]  = v27;
                BOOL v35 = v34 + 3;
                if (v34 + 3 != v43)
                {
                  uint64_t v45 = v27;
                  if (TGlyphIterator::Next((TGlyphIterator *)v53, 1))
                  {
                    BOOL v35 = EqualSequenceAndNote<BigEndianScalar<unsigned short>>(v34 + 3, v43, v53, (void *)v55 + 1);
                    uint64_t v27 = v45;
                    v53[6]  = v45;
                    uint64_t v21 = v52;
                  }
                  else
                  {
                    uint64_t v21 = v52;
                    uint64_t v27 = v45;
                  }
                  GlyphID  = v51;
                  uint64_t v33 = v50;
                }
              }
              if (v35 == v43) {
                break;
              }
            }
          }
        }
      }
      if (v33 == ++v32) {
        goto LABEL_65;
      }
    }
    if (OTL::GSUB::ApplySubstLookupRecords(v47, (unint64_t)this, v43, bswap32(v34[1]) >> 16, (uint64_t)v53, v21, &v54, v36, v48, v49, v46))TGlyphIterator::ClearSafeToBreakAfter(v53, &v54, v36); {
    return 1;
    }
  }
  return result;
}

uint64_t OTL::GSUB::WouldSubstituteContext1(void *a1, ContextSubstFormat1 *this, int a3, uint64_t a4, unsigned int a5)
{
  unint64_t v5 = a1[5];
  uint64_t v6 = (char *)this + 6;
  if ((unint64_t)this + 4 < a1[4] || (unint64_t)v6 > v5) {
    return 0;
  }
  uint64_t v9 = bswap32(*((unsigned __int16 *)this + 2)) >> 16;
  BOOL v10 = &v6[2 * v9];
  unint64_t v11 = (unint64_t)this + 8 <= v5 ? (v5 - (unint64_t)v6) >> 1 : 0;
  BOOL v12 = (unint64_t)v10 <= v5 && v10 >= v6;
  if (!v12 && v11 != v9) {
    return 0;
  }
  uint64_t result = (uint64_t)ContextSubstFormat1::NthSubRuleSet(this, a3 - 1, v5);
  if (!result) {
    return result;
  }
  unint64_t v18 = (unsigned __int16 *)result;
  unint64_t v19 = result + 2;
  if (result + 2 < (unint64_t)this
    || ((v20 = __rev16(*(unsigned __int16 *)result), v21 = v19 + 2 * v20, v21 >= v19) ? (BOOL v22 = v21 > v5) : (BOOL v22 = 1),
        v22))
  {
    BOOL v23 = result + 4 <= v5 && v19 >= (unint64_t)this;
    unsigned int v20 = (v5 - v19) >> 1;
    if (!v23) {
      unsigned int v20 = 0;
    }
    if (!(bswap32(v20) >> 16)) {
      return 0;
    }
LABEL_30:
    unint64_t v24 = 0;
    if ((v20 & 0xFFFE) != 0) {
      uint64_t v25 = (unsigned __int16)v20;
    }
    else {
      uint64_t v25 = 1;
    }
    while (1)
    {
      if (v24 < bswap32(*v18) >> 16)
      {
        uint64_t v26 = bswap32(v18[v24 + 1]) >> 16;
        uint64_t v27 = (unsigned __int16 *)((char *)v18 + v26);
        unint64_t v28 = (unsigned __int16 *)((char *)v18 + v26 + 4);
        if ((unint64_t)v28 <= v5)
        {
          uint64_t v29 = __rev16(*v27);
          if (*v27 && v29 <= a5)
          {
            uint64_t v31 = (v29 - 1);
            unint64_t v32 = &v28[v31];
            if (v28 < (unsigned __int16 *)this || v32 < v28 || (unint64_t)v32 > v5)
            {
              BOOL v35 = (unint64_t)(v27 + 3) <= v5 && v28 >= (unsigned __int16 *)this;
              unint64_t v36 = (v5 - (unint64_t)v28) >> 1;
              if (!v35) {
                unint64_t v36 = 0;
              }
              if (v36 != v31) {
                return 0;
              }
            }
            if (v29 < 2)
            {
LABEL_58:
              if (OTL::GSUB::WouldSubstituteLookupRecords(a1, (unint64_t)this, v28, bswap32(v27[1]) >> 16, a4, a5))return 1; {
            }
              }
            else
            {
              uint64_t v37 = (unsigned __int16 *)(v19 + v26 + 2 * v29);
              uint64_t v38 = v29 - 1;
              int v39 = (unsigned __int16 *)(a4 + 2);
              while (1)
              {
                int v40 = *v39++;
                if (v40 != bswap32(*v28) >> 16) {
                  break;
                }
                ++v28;
                if (!--v38)
                {
                  unint64_t v28 = v37;
                  goto LABEL_58;
                }
              }
            }
          }
        }
      }
      if (++v24 == v25) {
        return 0;
      }
    }
  }
  if (*(_WORD *)result) {
    goto LABEL_30;
  }
  return 0;
}

uint64_t OTL::GSUB::WouldSubstituteLookupRecords(void *a1, unint64_t a2, unsigned __int16 *a3, int a4, uint64_t a5, unsigned int a6)
{
  if (!a4 || (unint64_t)a3 < a2) {
    return 0;
  }
  int v8 = a4;
  do
  {
    BOOL v10 = a3 + 2;
    if ((unint64_t)(a3 + 2) > a1[5]) {
      break;
    }
    unsigned int v11 = bswap32(*a3);
    if (a6 > HIWORD(v11))
    {
      BOOL v12 = TBaseFont::NthLookup<OTL::GSUB>(*(void *)(a1[2] + 400), a1, bswap32(a3[1]) >> 16);
      if (v12)
      {
        unint64_t v13 = v12;
        uint64_t v29 = (unsigned __int16)(-21845 * ((*((_DWORD *)v12 + 24) - *((_DWORD *)v12 + 22)) >> 4));
        if (-21845 * (unsigned __int16)((*((_DWORD *)v12 + 24) - *((_DWORD *)v12 + 22)) >> 4))
        {
          unint64_t v14 = 0;
          uint64_t v30 = a6 - HIWORD(v11);
          uint64_t v31 = (unsigned __int16 *)(a5 + 2 * HIWORD(v11));
          unsigned int v28 = a6;
          while (2)
          {
            uint64_t v15 = *((void *)v13 + 11);
            unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((*((void *)v13 + 12) - v15) >> 4);
            uint64_t v17 = v16 <= v14 ? 0 : v15 + 48 * v14 + 8;
            if (v16 > v14)
            {
              uint64_t v18 = v15 + 48 * v14;
              unint64_t v19 = (unsigned int (**)(void *, void))(v18 + 24);
              unsigned int v20 = (uint64_t *)(v18 + 32);
              uint64_t v22 = v30;
              unint64_t v21 = v31;
              do
              {
                BOOL v23 = *v19;
                unint64_t v24 = (void *)(v17 + (*v20 >> 1));
                if (*v20) {
                  BOOL v23 = *(unsigned int (**)(void *, void))(*v24 + v23);
                }
                if (v23(v24, *v21))
                {
                  uint64_t v25 = *((void *)v13 + 11);
                  uint64_t v26 = 0xAAAAAAAAAAAAAAABLL * ((*((void *)v13 + 12) - v25) >> 4) <= v14
                      ? 0
                      : *(ChainContextSubstFormat1 **)(v25 + 48 * v14);
                  if (OTL::GSUB::WouldSubstituteSubtable((int)a1, (int)v13, *((unsigned __int16 *)v13 + 8), v26)) {
                    return 1;
                  }
                }
                ++v21;
                --v22;
              }
              while (v22);
              ++v14;
              a6  = v28;
              if (v14 != v29) {
                continue;
              }
            }
            break;
          }
        }
      }
    }
    a3  = v10;
    --v8;
  }
  while (v8);
  return 0;
}

unsigned __int16 *ContextSubstFormat2::NthSubClassSet(ContextSubstFormat2 *this, unsigned int a2, unint64_t a3)
{
  if (a2 >= bswap32(*((unsigned __int16 *)this + 3)) >> 16) {
    return 0;
  }
  if (!*((_WORD *)this + a2 + 4)) {
    return 0;
  }
  uint64_t v3 = (unsigned __int16 *)((char *)this + __rev16(*((unsigned __int16 *)this + a2 + 4)));
  unsigned int v4 = v3 + 1;
  if ((unint64_t)(v3 + 1) > a3) {
    return 0;
  }
  uint64_t v6 = bswap32(*v3) >> 16;
  unint64_t v7 = (unint64_t)&v4[v6];
  if ((unint64_t)(v3 + 2) <= a3) {
    unint64_t v8 = (a3 - (unint64_t)v4) >> 1;
  }
  else {
    unint64_t v8 = 0;
  }
  if (v7 >= (unint64_t)v4 && v7 <= a3 || v8 == v6) {
    return v3;
  }
  else {
    return 0;
  }
}

unsigned __int16 *OTL::GSUB::ApplyContextSubstFormat2(void *a1, unsigned __int16 *a2, uint64_t a3, _WORD *a4, uint64_t a5, unint64_t a6)
{
  uint64_t v12 = *(void *)(a3 + 48);
  GlyphID  = TRunGlue::GetGlyphID(*(TRunGlue **)a3, v12);
  unint64_t v14 = a1[5];
  uint64_t v15 = a2 + 4;
  if ((unint64_t)(a2 + 3) < a1[4] || (unint64_t)v15 > v14) {
    return 0;
  }
  uint64_t v17 = bswap32(a2[3]) >> 16;
  unint64_t v18 = (unint64_t)&v15[v17];
  unint64_t v19 = (unint64_t)(a2 + 5) <= v14 ? (v14 - (unint64_t)v15) >> 1 : 0;
  BOOL v20 = v18 <= v14 && v18 >= (unint64_t)v15;
  if (!v20 && v19 != v17) {
    return 0;
  }
  uint64_t v22 = (unsigned __int16 *)((char *)a2 + (bswap32(a2[2]) >> 16));
  if ((unint64_t)(v22 + 1) > v14) {
    return 0;
  }
  unsigned int v23 = GlyphID;
  unsigned int v24 = bswap32(*v22) >> 16;
  if (v24 == 2)
  {
    uint64_t v25 = 6 * (bswap32(v22[1]) >> 16) + 4;
  }
  else if (v24 == 1)
  {
    uint64_t v25 = 2 * (bswap32(v22[2]) >> 16) + 6;
  }
  else
  {
    uint64_t v25 = 0;
  }
  uint64_t result = 0;
  uint64_t v27 = (char *)v22 + v25;
  if (v27 >= (char *)v22 && (unint64_t)v27 <= v14)
  {
    *(void *)&long long v28 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v28 + 1)  = 0xAAAAAAAAAAAAAAAALL;
    v64[29]  = v28;
    v64[30]  = v28;
    v64[27]  = v28;
    v64[28]  = v28;
    v64[25]  = v28;
    v64[26]  = v28;
    v64[23]  = v28;
    v64[24]  = v28;
    v64[21]  = v28;
    v64[22]  = v28;
    v64[19]  = v28;
    v64[20]  = v28;
    v64[17]  = v28;
    v64[18]  = v28;
    v64[16]  = v28;
    unint64_t v65 = 0xAAAAAAAAAAAAAAAALL;
    v64[15]  = v28;
    v64[14]  = v28;
    v64[13]  = v28;
    v64[12]  = v28;
    v64[11]  = v28;
    v64[10]  = v28;
    v64[9]  = v28;
    v64[8]  = v28;
    v64[6]  = v28;
    v64[7]  = v28;
    v64[4]  = v28;
    v64[5]  = v28;
    v64[2]  = v28;
    v64[3]  = v28;
    v64[0]  = v28;
    v64[1]  = v28;
    uint64_t v63 = v12;
    unsigned int v29 = OTL::ClassDefTable::ClassOf((OTL::ClassDefTable *)v22, v23);
    uint64_t result = ContextSubstFormat2::NthSubClassSet((ContextSubstFormat2 *)a2, v29, v14);
    if (result)
    {
      uint64_t v30 = result;
      int v31 = TGlyphIterator::Next((TGlyphIterator *)a3, 1);
      unint64_t v56 = a4;
      if (v31)
      {
        uint64_t v32 = a5;
        unint64_t v33 = a6;
        uint64_t v34 = *(void *)(a3 + 48);
        unsigned int v35 = TRunGlue::GetGlyphID(*(TRunGlue **)a3, v34);
        int v31 = OTL::ClassDefTable::ClassOf((OTL::ClassDefTable *)v22, v35);
        uint64_t v36 = v34;
        a6  = v33;
        a5  = v32;
      }
      else
      {
        uint64_t v36 = v12;
      }
      uint64_t v37 = v30 + 1;
      CGFloat v62 = (TGlyphIterator *)a3;
      uint64_t v57 = a5;
      double v58 = (OTL::ClassDefTable *)v22;
      unint64_t v54 = a6;
      uint64_t v55 = a1;
      if (v30 + 1 < a2
        || (unsigned int v38 = __rev16((unsigned __int16)*v30), v39 = (unint64_t)&v37[v38], v39 < (unint64_t)v37)
        || v39 > v14)
      {
        BOOL v40 = (unint64_t)(v30 + 2) <= v14 && v37 >= a2;
        unsigned int v38 = (v14 - v37) >> 1;
        if (!v40) {
          unsigned int v38 = 0;
        }
        if (!(bswap32(v38) >> 16)) {
          goto LABEL_74;
        }
      }
      else if (!*v30)
      {
LABEL_74:
        uint64_t result = 0;
        *((void *)v62 + 6)  = v12;
        return result;
      }
      unint64_t v41 = 0;
      if ((v38 & 0xFFFE) != 0) {
        uint64_t v42 = (unsigned __int16)v38;
      }
      else {
        uint64_t v42 = 1;
      }
      uint64_t v60 = v36;
      uint64_t v61 = v12;
      int v59 = v31;
      while (1)
      {
        if (v41 < bswap32((unsigned __int16)*v30) >> 16)
        {
          double v43 = (_WORD *)((char *)v30 + __rev16((unsigned __int16)v30[v41 + 1]));
          double v44 = v43 + 2;
          if (v30[v41 + 1] && (unint64_t)v44 <= v14)
          {
            if (*v43)
            {
              unint64_t v46 = __rev16(*v43);
              if (v46 <= 0x40)
              {
                uint64_t v47 = (v46 - 1);
                double v48 = &v44[v47];
                if (v44 < a2 || v48 < v44 || (unint64_t)v48 > v14)
                {
                  BOOL v51 = (unint64_t)(v43 + 3) <= v14 && v44 >= a2;
                  unint64_t v52 = (v14 - (unint64_t)v44) >> 1;
                  if (!v51) {
                    unint64_t v52 = 0;
                  }
                  if (v52 != v47) {
                    goto LABEL_74;
                  }
                }
                int v53 = &v44[v46 - 1];
                if (v36 != v12 && v44 != v53 && v31 == bswap32(*v44) >> 16)
                {
                  *(void *)&v64[0]  = v36;
                  double v44 = v43 + 3;
                  if (v43 + 3 != v53)
                  {
                    if (TGlyphIterator::Next(v62, 1))
                    {
                      double v44 = EqualClassSequenceAndNote<BigEndianScalar<unsigned short>>(v58, v43 + 3, v53, (uint64_t)v62, (void *)v64 + 1);
                      uint64_t v36 = v60;
                      *((void *)v62 + 6)  = v60;
                    }
                    else
                    {
                      uint64_t v36 = v60;
                    }
                    uint64_t v12 = v61;
                    int v31 = v59;
                  }
                }
                if (v44 == v53) {
                  break;
                }
              }
            }
          }
        }
        if (v42 == ++v41) {
          goto LABEL_74;
        }
      }
      if (OTL::GSUB::ApplySubstLookupRecords(v55, (unint64_t)a2, v53, bswap32(v43[1]) >> 16, (uint64_t)v62, v12, &v63, v46, v56, v57, v54))TGlyphIterator::ClearSafeToBreakAfter((CFIndex *)v62, &v63, v46); {
      return (unsigned __int16 *)1;
      }
    }
  }
  return result;
}

unsigned __int16 *EqualClassSequenceAndNote<BigEndianScalar<unsigned short>>(OTL::ClassDefTable *a1, unsigned __int16 *a2, unsigned __int16 *a3, uint64_t a4, void *a5)
{
  unint64_t v5 = a2;
  if (a2 != a3)
  {
    do
    {
      GlyphID  = TRunGlue::GetGlyphID(*(TRunGlue **)a4, *(void *)(a4 + 48));
      if (OTL::ClassDefTable::ClassOf(a1, GlyphID) != bswap32(*v5) >> 16) {
        break;
      }
      *a5  = *(void *)(a4 + 48);
      if (++v5 == a3) {
        return a3;
      }
      ++a5;
    }
    while ((TGlyphIterator::Next((TGlyphIterator *)a4, 1) & 1) != 0);
  }
  return v5;
}

uint64_t OTL::GSUB::WouldSubstituteContext2(void *a1, unsigned __int16 *a2, unsigned __int16 *a3, unsigned int a4)
{
  unint64_t v4 = a1[5];
  unint64_t v5 = a2 + 4;
  if ((unint64_t)(a2 + 3) < a1[4] || (unint64_t)v5 > v4) {
    return 0;
  }
  uint64_t v8 = bswap32(a2[3]) >> 16;
  unint64_t v9 = (unint64_t)&v5[v8];
  unint64_t v10 = (unint64_t)(a2 + 5) <= v4 ? (v4 - (unint64_t)v5) >> 1 : 0;
  BOOL v11 = v9 <= v4 && v9 >= (unint64_t)v5;
  BOOL v12 = v11 || v10 == v8;
  if (!v12) {
    return 0;
  }
  unint64_t v13 = (unsigned __int16 *)((char *)a2 + (bswap32(a2[2]) >> 16));
  if ((unint64_t)(v13 + 1) > v4) {
    return 0;
  }
  unsigned int v14 = bswap32(*v13) >> 16;
  if (v14 == 2)
  {
    uint64_t v15 = 6 * (bswap32(v13[1]) >> 16) + 4;
  }
  else if (v14 == 1)
  {
    uint64_t v15 = 2 * (bswap32(v13[2]) >> 16) + 6;
  }
  else
  {
    uint64_t v15 = 0;
  }
  uint64_t result = 0;
  uint64_t v17 = (char *)v13 + v15;
  if (v17 >= (char *)v13 && (unint64_t)v17 <= v4)
  {
    unsigned int v18 = OTL::ClassDefTable::ClassOf((OTL::ClassDefTable *)v13, *a3);
    uint64_t result = (uint64_t)ContextSubstFormat2::NthSubClassSet((ContextSubstFormat2 *)a2, v18, v4);
    if (result)
    {
      unint64_t v19 = (unsigned __int16 *)result;
      BOOL v20 = (unsigned __int16 *)(result + 2);
      if (result + 2 < (unint64_t)a2
        || ((v21 = __rev16(*(unsigned __int16 *)result), unint64_t v22 = (unint64_t)&v20[v21], v22 >= (unint64_t)v20)
          ? (BOOL v23 = v22 > v4)
          : (BOOL v23 = 1),
            v23))
      {
        BOOL v24 = result + 4 <= v4 && v20 >= a2;
        unsigned int v21 = (v4 - v20) >> 1;
        if (!v24) {
          unsigned int v21 = 0;
        }
        if (!(bswap32(v21) >> 16)) {
          return 0;
        }
      }
      else if (!*(_WORD *)result)
      {
        return 0;
      }
      unint64_t v25 = 0;
      if ((v21 & 0xFFFE) != 0) {
        uint64_t v26 = (unsigned __int16)v21;
      }
      else {
        uint64_t v26 = 1;
      }
      double v43 = (unsigned __int16 *)(result + 2);
      while (1)
      {
        if (v25 < bswap32(*v19) >> 16)
        {
          unsigned int v27 = v19[v25 + 1];
          BOOL v12 = v27 == 0;
          uint64_t v28 = __rev16(v27);
          unsigned int v29 = (unsigned __int16 *)((char *)v19 + v28);
          uint64_t v30 = (unsigned __int16 *)((char *)v19 + v28 + 4);
          if (!v12 && (unint64_t)v30 <= v4)
          {
            uint64_t v32 = __rev16(*v29);
            if (*v29 && v32 <= a4)
            {
              uint64_t v34 = (v32 - 1);
              unsigned int v35 = &v30[v34];
              if (v30 < a2 || v35 < v30 || (unint64_t)v35 > v4)
              {
                BOOL v38 = (unint64_t)(v29 + 3) <= v4 && v30 >= a2;
                unint64_t v39 = (v4 - (unint64_t)v30) >> 1;
                if (!v38) {
                  unint64_t v39 = 0;
                }
                if (v39 != v34) {
                  return 0;
                }
              }
              if (v32 < 2)
              {
LABEL_70:
                if (OTL::GSUB::WouldSubstituteLookupRecords(a1, (unint64_t)a2, v30, bswap32(v29[1]) >> 16, (uint64_t)a3, a4))return 1; {
              }
                }
              else
              {
                BOOL v40 = a3 + 1;
                double v44 = (unsigned __int16 *)((char *)&v43[v32] + v28);
                uint64_t v41 = v32 - 1;
                while (1)
                {
                  unsigned int v42 = *v40++;
                  if (OTL::ClassDefTable::ClassOf((OTL::ClassDefTable *)v13, v42) != bswap32(*v30) >> 16) {
                    break;
                  }
                  ++v30;
                  if (!--v41)
                  {
                    uint64_t v30 = v44;
                    goto LABEL_70;
                  }
                }
              }
            }
          }
        }
        if (++v25 == v26) {
          return 0;
        }
      }
    }
  }
  return result;
}

uint64_t OTL::GSUB::ApplyContextSubstFormat3(void *a1, unint64_t a2, uint64_t a3, _WORD *a4, uint64_t a5, unint64_t a6)
{
  unint64_t v7 = a1[5];
  unint64_t v8 = a2 + 6;
  BOOL v9 = a1[4] > a2 || v8 > v7;
  if (v9 || !*(_WORD *)(a2 + 2)) {
    return 0;
  }
  uint64_t v15 = *(void *)(a3 + 48);
  unsigned int v16 = __rev16(*(unsigned __int16 *)(a2 + 2));
  uint64_t v17 = v16 - 1;
  if (v16 != 1)
  {
    uint64_t v18 = *(void *)(a3 + 24);
    if (*(int *)(a3 + 8) < 1)
    {
      if (v15 - v17 <= v18) {
        return 0;
      }
    }
    else if (v15 + v17 >= v18)
    {
      return 0;
    }
  }
  *(void *)&long long v19 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v19 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  v23[29]  = v19;
  v23[30]  = v19;
  v23[27]  = v19;
  v23[28]  = v19;
  v23[25]  = v19;
  v23[26]  = v19;
  v23[23]  = v19;
  v23[24]  = v19;
  v23[21]  = v19;
  v23[22]  = v19;
  v23[19]  = v19;
  v23[20]  = v19;
  v23[17]  = v19;
  v23[18]  = v19;
  v23[16]  = v19;
  unint64_t v24 = 0xAAAAAAAAAAAAAAAALL;
  _OWORD v23[15] = v19;
  v23[14]  = v19;
  v23[13]  = v19;
  v23[12]  = v19;
  v23[11]  = v19;
  v23[10]  = v19;
  v23[9]  = v19;
  v23[8]  = v19;
  v23[6]  = v19;
  v23[7]  = v19;
  v23[4]  = v19;
  v23[5]  = v19;
  v23[2]  = v19;
  v23[3]  = v19;
  v23[0]  = v19;
  v23[1]  = v19;
  uint64_t v22 = v15;
  if (v16 >= 2)
  {
    if (v16 <= 0x40)
    {
      uint64_t result = TGlyphIterator::MatchCoverSequenceAndNote(a3, v17, a2 + 8, (uint64_t)v23, a2, v7);
      if (!result) {
        return result;
      }
      uint64_t v21 = result + 1;
      goto LABEL_16;
    }
    return 0;
  }
  uint64_t v21 = 1;
LABEL_16:
  if (OTL::GSUB::ApplySubstLookupRecords(a1, a2, (unsigned __int16 *)(v8 + 2 * v16), bswap32(*(unsigned __int16 *)(a2 + 4)) >> 16, a3, v15, &v22, v21, a4, a5, a6))TGlyphIterator::ClearSafeToBreakAfter((CFIndex *)a3, &v22, v21); {
  return 1;
  }
}

uint64_t OTL::GSUB::WouldSubstituteContext3(void *a1, unint64_t a2, uint64_t a3, unsigned int a4)
{
  unint64_t v4 = a1[5];
  if (a1[4] > a2 || a2 + 6 > v4) {
    return 0;
  }
  uint64_t v8 = __rev16(*(unsigned __int16 *)(a2 + 2));
  if (!*(_WORD *)(a2 + 2) || v8 > a4) {
    return 0;
  }
  unint64_t v13 = (unsigned __int16 *)(a2 + 8);
  if (v8 < 2) {
    return OTL::GSUB::WouldSubstituteLookupRecords(a1, a2, v13, bswap32(*(unsigned __int16 *)(a2 + 4)) >> 16, a3, a4);
  }
  uint64_t v14 = (v8 - 1);
  uint64_t v15 = &v13[v14];
  if (a2 + 10 <= v4) {
    unint64_t v16 = (v4 - (unint64_t)v13) >> 1;
  }
  else {
    unint64_t v16 = 0;
  }
  if (((unint64_t)v15 > v4 || v15 < v13) && v16 != v14) {
    return 0;
  }
  long long v19 = (unsigned __int16 *)(a3 + 2);
  uint64_t v20 = v8 - 1;
  while (1)
  {
    unsigned int v21 = *v13++;
    unint64_t v28 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v22 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v22 + 1)  = 0xAAAAAAAAAAAAAAAALL;
    long long v26 = v22;
    long long v27 = v22;
    OTL::Coverage::Coverage((OTL::Coverage *)&v26, (unsigned __int16 *)(a2 + (bswap32(v21) >> 16)), v4, 1);
    BOOL v23 = (uint64_t (*)(void *, void))v27;
    unint64_t v24 = (void *)((char *)&v26 + (*((uint64_t *)&v27 + 1) >> 1));
    if (BYTE8(v27)) {
      BOOL v23 = *(uint64_t (**)(void *, void))(*v24 + v27);
    }
    unsigned int v25 = *v19++;
    uint64_t result = v23(v24, v25);
    if (!result) {
      break;
    }
    if (!--v20) {
      return OTL::GSUB::WouldSubstituteLookupRecords(a1, a2, v13, bswap32(*(unsigned __int16 *)(a2 + 4)) >> 16, a3, a4);
    }
  }
  return result;
}

unsigned __int16 *ChainContextSubstFormat1::NthChainSubRuleSet(ChainContextSubstFormat1 *this, unsigned int a2, unint64_t a3)
{
  if (a2 >= bswap32(*((unsigned __int16 *)this + 2)) >> 16) {
    return 0;
  }
  if (!*((_WORD *)this + a2 + 3)) {
    return 0;
  }
  uint64_t v3 = (unsigned __int16 *)((char *)this + __rev16(*((unsigned __int16 *)this + a2 + 3)));
  unint64_t v4 = v3 + 1;
  if ((unint64_t)(v3 + 1) > a3) {
    return 0;
  }
  uint64_t v6 = bswap32(*v3) >> 16;
  unint64_t v7 = (unint64_t)&v4[v6];
  if ((unint64_t)(v3 + 2) <= a3) {
    unint64_t v8 = (a3 - (unint64_t)v4) >> 1;
  }
  else {
    unint64_t v8 = 0;
  }
  if (v7 >= (unint64_t)v4 && v7 <= a3 || v8 == v6) {
    return v3;
  }
  else {
    return 0;
  }
}

uint64_t OTL::GSUB::ApplyChainContextSubstFormat1(void *a1, ChainContextSubstFormat1 *this, uint64_t a3, int a4, _WORD *a5, uint64_t a6, unint64_t a7)
{
  unint64_t v7 = a1[5];
  unint64_t v8 = (char *)this + 6;
  if ((unint64_t)this + 4 < a1[4] || (unint64_t)v8 > v7) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v12 = __rev16(*((unsigned __int16 *)this + 2));
  BOOL v13 = __CFADD__(v8, 2 * v12);
  char v14 = (unint64_t)&v8[2 * v12] > v7 || v13;
  unint64_t v15 = (v7 - (unint64_t)v8) >> 1;
  if ((unint64_t)this + 8 > v7) {
    unint64_t v15 = 0;
  }
  if (v15 == v12) {
    char v16 = 0;
  }
  else {
    char v16 = v14;
  }
  if ((v16 & 1) == 0)
  {
    if (*((_WORD *)this + 2))
    {
      uint64_t v21 = *(void *)(a3 + 48);
      *(void *)&long long v22 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v22 + 1)  = 0xAAAAAAAAAAAAAAAALL;
      v74[29]  = v22;
      _OWORD v74[30] = v22;
      v74[27]  = v22;
      v74[28]  = v22;
      v74[25]  = v22;
      v74[26]  = v22;
      v74[23]  = v22;
      v74[24]  = v22;
      v74[21]  = v22;
      v74[22]  = v22;
      v74[19]  = v22;
      v74[20]  = v22;
      v74[17]  = v22;
      v74[18]  = v22;
      v74[16]  = v22;
      unint64_t v75 = 0xAAAAAAAAAAAAAAAALL;
      v74[15]  = v22;
      v74[14]  = v22;
      v74[13]  = v22;
      v74[12]  = v22;
      v74[11]  = v22;
      v74[10]  = v22;
      v74[9]  = v22;
      v74[8]  = v22;
      v74[6]  = v22;
      v74[7]  = v22;
      v74[4]  = v22;
      v74[5]  = v22;
      v74[2]  = v22;
      v74[3]  = v22;
      v74[0]  = v22;
      v74[1]  = v22;
      uint64_t v70 = v21;
      uint64_t v73 = v21;
      uint64_t result = (uint64_t)ChainContextSubstFormat1::NthChainSubRuleSet(this, a4 - 1, v7);
      if (result)
      {
        BOOL v23 = (_WORD *)result;
        if (TGlyphIterator::Next((TGlyphIterator *)a3, 1))
        {
          uint64_t v24 = *(void *)(a3 + 48);
          GlyphID  = TRunGlue::GetGlyphID(*(TRunGlue **)a3, v24);
          CFIndex v26 = v24;
          int v68 = GlyphID;
          uint64_t v28 = v70;
          long long v27 = this;
        }
        else
        {
          int v68 = 0xFFFF;
          uint64_t v28 = v70;
          long long v27 = this;
          CFIndex v26 = v70;
        }
        unint64_t v64 = a7;
        unint64_t v65 = a1;
        uint64_t v66 = a5;
        uint64_t v67 = a6;
        unsigned int v29 = (ChainContextSubstFormat1 *)(v23 + 1);
        if (v23 + 1 < (_WORD *)v27
          || (LODWORD(v30)  = __rev16((unsigned __int16)*v23),
              unint64_t v31 = (unint64_t)v29 + 2 * v30,
              v31 < (unint64_t)v29)
          || v31 > v7)
        {
          BOOL v32 = (unint64_t)(v23 + 2) <= v7 && v29 >= v27;
          LODWORD(v30)  = (v7 - v29) >> 1;
          if (!v32) {
            LODWORD(v30)  = 0;
          }
          if (!(bswap32(v30) >> 16)) {
            goto LABEL_107;
          }
        }
        else if (!*v23)
        {
          goto LABEL_107;
        }
        unint64_t v33 = 0;
        if ((v30 & 0xFFFE) != 0) {
          uint64_t v30 = (unsigned __int16)v30;
        }
        else {
          uint64_t v30 = 1;
        }
        uint64_t v72 = v30;
        CFIndex v69 = v26;
        while (1)
        {
          if (v33 >= bswap32((unsigned __int16)*v23) >> 16) {
            goto LABEL_106;
          }
          unsigned int v34 = (unsigned __int16)v23[v33 + 1];
          BOOL v42 = v34 == 0;
          unsigned int v35 = (ChainContextSubstFormat1 *)((char *)v23 + __rev16(v34));
          if (v42 || (unint64_t)v35 > v7) {
            goto LABEL_106;
          }
          uint64_t v37 = (ChainContextSubstFormat1 *)((char *)v35 + 2);
          if (v35 < v27 || (unint64_t)v37 > v7) {
            goto LABEL_107;
          }
          if (*(_WORD *)v35) {
            break;
          }
          CFIndex v44 = v28;
LABEL_65:
          if (v37 < v27) {
            goto LABEL_107;
          }
          uint64_t v45 = (unsigned __int16 *)((char *)v37 + 2);
          if ((unint64_t)v37 + 2 > v7) {
            goto LABEL_107;
          }
          unsigned int v46 = *(unsigned __int16 *)v37;
          if (*(_WORD *)v37)
          {
            unint64_t v47 = __rev16(v46);
            if (v47 <= 0x40)
            {
              unint64_t v48 = v47 - 1;
              uint64_t v49 = &v45[v47 - 1];
              if (v49 < v45 || (unint64_t)v49 > v7)
              {
                unint64_t v51 = (unint64_t)v37 + 4 <= v7 ? (v7 - (unint64_t)v45) >> 1 : 0;
                if (v51 != v48) {
                  goto LABEL_107;
                }
              }
              unint64_t v52 = (unsigned __int16 *)((char *)v37 + 2 * v47);
              if (v46 == 256 || v26 == v28)
              {
                CFIndex v53 = v28;
              }
              else
              {
                CFIndex v53 = v28;
                if (v68 == bswap32(*v45) >> 16)
                {
                  *(void *)&v74[0]  = v26;
                  uint64_t v45 = (unsigned __int16 *)((char *)v37 + 4);
                  if (v46 == 512)
                  {
                    CFIndex v53 = v26;
                  }
                  else
                  {
                    CFIndex v54 = v44;
                    if (TGlyphIterator::Next((TGlyphIterator *)a3, 1))
                    {
                      uint64_t v45 = EqualSequenceAndNote<BigEndianScalar<unsigned short>>(v45, v52, (uint64_t *)a3, (void *)v74 + 1);
                      CFIndex v53 = *(void *)(a3 + 48);
                      CFIndex v26 = v69;
                      *(void *)(a3 + 48)  = v69;
                    }
                    else
                    {
                      CFIndex v26 = v69;
                      CFIndex v53 = v69;
                    }
                    uint64_t v28 = v70;
                    long long v27 = this;
                    CFIndex v44 = v54;
                  }
                }
              }
              if (v45 == v52)
              {
                uint64_t v55 = v52 + 1;
                if ((unint64_t)(v52 + 1) > v7) {
                  goto LABEL_107;
                }
                if (!*v52)
                {
LABEL_108:
                  if (v55 >= (unsigned __int16 *)v27 && (unint64_t)(v55 + 1) <= v7)
                  {
                    CFIndex v61 = v44;
                    if (OTL::GSUB::ApplySubstLookupRecords(v65, (unint64_t)v27, v55 + 1, bswap32(*v55) >> 16, a3, v28, &v73, v47, v66, v67, v64)&& *(void *)(*(void *)a3 + 152))
                    {
                      CFIndex v62 = v61 - v53;
                      if (v61 >= v53) {
                        v63.CFIndex location = v53;
                      }
                      else {
                        v63.CFIndex location = v61;
                      }
                      if (v61 - v53 < 0) {
                        CFIndex v62 = v53 - v61;
                      }
                      v63.CFIndex length = v62 + 1;
                      TRunGlue::ClearSafeToBreakAfter(*(void *)a3, v63);
                    }
                    return 1;
                  }
LABEL_107:
                  uint64_t result = 0;
                  *(void *)(a3 + 48)  = v28;
                  return result;
                }
                uint64_t v56 = __rev16(*v52);
                uint64_t v57 = &v55[v56];
                BOOL v58 = v57 < v55 || (unint64_t)v57 > v7;
                if (v58 && ((unint64_t)(v52 + 2) > v7 || (v7 - (unint64_t)v55) >> 1 != v56)) {
                  goto LABEL_107;
                }
                CFIndex v59 = v44;
                *(void *)(a3 + 48)  = *(&v73 + v48);
                if (v56 <= 1) {
                  int v60 = 1;
                }
                else {
                  int v60 = v56;
                }
                while (TGlyphIterator::NextContext((TGlyphIterator *)a3, 1)
                     && TRunGlue::GetGlyphID(*(TRunGlue **)a3, *(void *)(a3 + 48)) == bswap32(*v55) >> 16)
                {
                  ++v55;
                  if (!--v60)
                  {
                    CFIndex v53 = *(void *)(a3 + 48);
                    uint64_t v28 = v70;
                    *(void *)(a3 + 48)  = v69;
                    long long v27 = this;
                    CFIndex v44 = v59;
                    goto LABEL_108;
                  }
                }
                goto LABEL_105;
              }
            }
          }
LABEL_106:
          if (++v33 == v72) {
            goto LABEL_107;
          }
        }
        uint64_t v39 = __rev16(*(unsigned __int16 *)v35);
        BOOL v40 = (ChainContextSubstFormat1 *)((char *)v37 + 2 * v39);
        if (v40 < v37 || (unint64_t)v40 > v7)
        {
          BOOL v42 = (unint64_t)v35 + 4 <= v7 && (v7 - (unint64_t)v37) >> 1 == v39;
          if (!v42) {
            goto LABEL_107;
          }
        }
        *(void *)(a3 + 48)  = v28;
        if (v39 <= 1) {
          int v43 = 1;
        }
        else {
          int v43 = v39;
        }
        while (TGlyphIterator::PrevContext((TGlyphIterator *)a3, 1)
             && TRunGlue::GetGlyphID(*(TRunGlue **)a3, *(void *)(a3 + 48)) == bswap32(*(unsigned __int16 *)v37) >> 16)
        {
          uint64_t v37 = (ChainContextSubstFormat1 *)((char *)v37 + 2);
          if (!--v43)
          {
            CFIndex v44 = *(void *)(a3 + 48);
            CFIndex v26 = v69;
            uint64_t v28 = v70;
            *(void *)(a3 + 48)  = v69;
            long long v27 = this;
            goto LABEL_65;
          }
        }
LABEL_105:
        CFIndex v26 = v69;
        uint64_t v28 = v70;
        *(void *)(a3 + 48)  = v69;
        long long v27 = this;
        goto LABEL_106;
      }
    }
  }
  return result;
}

uint64_t OTL::GSUB::WouldSubstituteChainContext1(void *a1, ChainContextSubstFormat1 *this, int a3, uint64_t a4, unsigned int a5)
{
  unint64_t v5 = a1[5];
  uint64_t v6 = (char *)this + 6;
  if ((unint64_t)this + 4 < a1[4] || (unint64_t)v6 > v5) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v11 = __rev16(*((unsigned __int16 *)this + 2));
  BOOL v12 = __CFADD__(v6, 2 * v11);
  char v13 = (unint64_t)&v6[2 * v11] > v5 || v12;
  unint64_t v14 = (v5 - (unint64_t)v6) >> 1;
  if ((unint64_t)this + 8 > v5) {
    unint64_t v14 = 0;
  }
  if (v14 == v11) {
    char v15 = 0;
  }
  else {
    char v15 = v13;
  }
  if ((v15 & 1) == 0)
  {
    if (*((_WORD *)this + 2))
    {
      uint64_t result = (uint64_t)ChainContextSubstFormat1::NthChainSubRuleSet(this, a3 - 1, v5);
      if (result)
      {
        uint64_t v18 = (unsigned __int16 *)result;
        unint64_t v19 = result + 2;
        if (result + 2 < (unint64_t)this
          || ((unsigned int v20 = __rev16(*(unsigned __int16 *)result), v21 = v19 + 2 * v20, v21 >= v19)
            ? (BOOL v22 = v21 > v5)
            : (BOOL v22 = 1),
              v22))
        {
          BOOL v23 = result + 4 <= v5 && v19 >= (unint64_t)this;
          unsigned int v20 = (v5 - v19) >> 1;
          if (!v23) {
            unsigned int v20 = 0;
          }
          if (!(bswap32(v20) >> 16)) {
            return 0;
          }
        }
        else if (!*(_WORD *)result)
        {
          return 0;
        }
        unint64_t v24 = 0;
        if ((v20 & 0xFFFE) != 0) {
          uint64_t v25 = (unsigned __int16)v20;
        }
        else {
          uint64_t v25 = 1;
        }
        while (1)
        {
          if (v24 < bswap32(*v18) >> 16)
          {
            unsigned int v26 = v18[v24 + 1];
            BOOL v27 = v26 == 0;
            uint64_t v28 = __rev16(v26);
            unsigned int v29 = (unsigned __int16 *)((char *)v18 + v28);
            if (!v27 && (unint64_t)v29 <= v5)
            {
              uint64_t v31 = bswap32(*v29) >> 16;
              BOOL v32 = &v29[v31];
              unint64_t v33 = v32 + 1;
              unsigned int v34 = v32 + 2;
              if (v33 < (unsigned __int16 *)this || (unint64_t)v34 > v5) {
                return 0;
              }
              unsigned int v36 = bswap32(*v33) >> 16;
              if (v36 <= a5)
              {
                if (v36 >= 2)
                {
                  uint64_t v37 = 0;
                  uint64_t v38 = 2 * v36 - 2;
                  uint64_t v39 = (char *)&v18[v31] + v28;
                  do
                  {
                    if (v34 < (unsigned __int16 *)this || (unint64_t)&v39[v37 + 6] > v5) {
                      break;
                    }
                    if (*(unsigned __int16 *)(a4 + 2 + v37) != bswap32(*(unsigned __int16 *)&v39[v37 + 4]) >> 16) {
                      goto LABEL_58;
                    }
                    v37 += 2;
                  }
                  while (v38 != v37);
                  unsigned int v34 = (unsigned __int16 *)((char *)&v18[v31 + 2] + v28 + v37);
                }
                if (v34 < (unsigned __int16 *)this || (unint64_t)(v34 + 1) > v5) {
                  return 0;
                }
                uint64_t v41 = &v34[bswap32(*v34) >> 16];
                if ((unint64_t)(v41 + 2) > v5) {
                  return 0;
                }
                if (OTL::GSUB::WouldSubstituteLookupRecords(a1, (unint64_t)this, v41 + 2, bswap32(v41[1]) >> 16, a4, a5))return 1; {
              }
                }
            }
          }
LABEL_58:
          if (++v24 == v25) {
            return 0;
          }
        }
      }
    }
  }
  return result;
}

unsigned __int16 *OTL::GSUB::WouldSubstituteChainContext2(void *a1, unsigned __int16 *a2, unsigned __int16 *a3, unsigned int a4)
{
  unint64_t v4 = a1[5];
  unint64_t v5 = a2 + 6;
  if ((unint64_t)(a2 + 5) < a1[4] || (unint64_t)v5 > v4) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v9 = __rev16(a2[5]);
  BOOL v10 = __CFADD__(v5, 2 * v9);
  char v11 = (unint64_t)&v5[v9] > v4 || v10;
  unint64_t v12 = (v4 - (unint64_t)v5) >> 1;
  if ((unint64_t)(a2 + 7) > v4) {
    unint64_t v12 = 0;
  }
  if (v12 == v9) {
    char v13 = 0;
  }
  else {
    char v13 = v11;
  }
  if ((v13 & 1) == 0 && a2[5])
  {
    unint64_t v14 = (unsigned __int16 *)((char *)a2 + (bswap32(a2[3]) >> 16));
    if ((unint64_t)(v14 + 1) > v4) {
      return 0;
    }
    unsigned int v15 = bswap32(*v14) >> 16;
    if (v15 == 2)
    {
      uint64_t v16 = 6 * (bswap32(v14[1]) >> 16) + 4;
    }
    else if (v15 == 1)
    {
      uint64_t v16 = 2 * (bswap32(v14[2]) >> 16) + 6;
    }
    else
    {
      uint64_t v16 = 0;
    }
    uint64_t result = 0;
    uint64_t v17 = (char *)v14 + v16;
    if (v17 >= (char *)v14 && (unint64_t)v17 <= v4)
    {
      unsigned int v18 = OTL::ClassDefTable::ClassOf((OTL::ClassDefTable *)v14, *a3);
      unint64_t v49 = v4;
      uint64_t result = ChainContextSubstFormat2::NthChainSubClassSet((ChainContextSubstFormat2 *)a2, v18, v4);
      if (result)
      {
        unint64_t v19 = result + 1;
        unint64_t v20 = v4;
        if (result + 1 < a2
          || ((LODWORD(v21)  = __rev16(*result),
               unint64_t v22 = (unint64_t)&v19[v21],
               v22 >= (unint64_t)v19)
            ? (BOOL v23 = v22 > v4)
            : (BOOL v23 = 1),
              v23))
        {
          BOOL v24 = (unint64_t)(result + 2) <= v4 && v19 >= a2;
          LODWORD(v21)  = (v4 - v19) >> 1;
          if (!v24) {
            LODWORD(v21)  = 0;
          }
          if (!(bswap32(v21) >> 16)) {
            return 0;
          }
        }
        else if (!*result)
        {
          return 0;
        }
        unint64_t v25 = 0;
        if ((v21 & 0xFFFE) != 0) {
          uint64_t v21 = (unsigned __int16)v21;
        }
        else {
          uint64_t v21 = 1;
        }
        uint64_t v47 = v21;
        unint64_t v48 = (OTL::ClassDefTable *)v14;
        while (1)
        {
          unsigned int v26 = result;
          if (v25 < bswap32(*result) >> 16)
          {
            unsigned int v27 = result[v25 + 1];
            BOOL v28 = v27 == 0;
            uint64_t v29 = __rev16(v27);
            uint64_t v30 = (unsigned __int16 *)((char *)result + v29);
            if (!v28 && (unint64_t)v30 <= v20)
            {
              uint64_t v32 = bswap32(*v30) >> 16;
              unint64_t v33 = &v30[v32];
              unsigned int v34 = v33 + 2;
              if (v33 + 1 < a2 || (unint64_t)v34 > v20) {
                return 0;
              }
              unsigned int v36 = bswap32(v33[1]) >> 16;
              if (v36 <= a4)
              {
                if (v36 >= 2)
                {
                  unint64_t v37 = 0;
                  uint64_t v38 = 2 * v36 - 2;
                  uint64_t v39 = (char *)&result[v32] + v29;
                  while (v34 >= a2 && (unint64_t)&v39[v37 + 6] <= v20)
                  {
                    int v40 = OTL::ClassDefTable::ClassOf(v48, a3[v37 / 2 + 1]);
                    unint64_t v20 = v49;
                    if (v40 != bswap32(*(unsigned __int16 *)&v39[v37 + 4]) >> 16) {
                      goto LABEL_67;
                    }
                    v37 += 2;
                    if (v38 == v37)
                    {
                      unsigned int v34 = (unsigned __int16 *)((char *)&v26[v32 + 2] + v29 + v37);
                      goto LABEL_61;
                    }
                  }
                  unsigned int v34 = (unsigned __int16 *)((char *)&v26[v32 + 2] + v29 + v37);
                }
LABEL_61:
                if (v34 < a2 || (unint64_t)(v34 + 1) > v20) {
                  return 0;
                }
                BOOL v42 = &v34[bswap32(*v34) >> 16];
                if ((unint64_t)(v42 + 2) > v20) {
                  return 0;
                }
                WouldSubstituteLookupRecords  = OTL::GSUB::WouldSubstituteLookupRecords(a1, (unint64_t)a2, v42 + 2, bswap32(v42[1]) >> 16, (uint64_t)a3, a4);
                unint64_t v20 = v49;
                if (WouldSubstituteLookupRecords) {
                  return (unsigned __int16 *)1;
                }
              }
            }
          }
LABEL_67:
          ++v25;
          uint64_t result = v26;
          if (v25 == v47) {
            return 0;
          }
        }
      }
    }
  }
  return result;
}

uint64_t OTL::GSUB::WouldSubstituteChainContext3(void *a1, unint64_t a2, uint64_t a3, unsigned int a4)
{
  unint64_t v4 = a1[5];
  uint64_t v5 = bswap32(*(unsigned __int16 *)(a2 + 2)) >> 16;
  unint64_t v6 = a2 + 2 * v5;
  if (v6 + 6 > v4) {
    return 0;
  }
  unsigned int v7 = a4;
  unint64_t v8 = v6 + 4;
  uint64_t v9 = bswap32(*(unsigned __int16 *)(v6 + 4)) >> 16;
  if (v9 > a4) {
    return 0;
  }
  uint64_t v10 = a3;
  unint64_t v12 = (unsigned __int16 *)(v6 + 8);
  if (v9 < 2)
  {
    LODWORD(v21)  = 1;
  }
  else
  {
    BOOL v28 = a1;
    uint64_t v13 = (v9 - 1);
    unint64_t v14 = &v12[v13];
    if ((unint64_t)v12 < a2 || v14 < v12 || (unint64_t)v14 > v4)
    {
      BOOL v17 = v8 + 6 <= v4 && (unint64_t)v12 >= a2;
      unint64_t v18 = (v4 - (unint64_t)v12) >> 1;
      if (!v17) {
        unint64_t v18 = 0;
      }
      if (v18 != v13) {
        return 0;
      }
    }
    uint64_t v19 = 0;
    uint64_t v20 = a3 + 2;
    uint64_t v21 = 1;
    while (1)
    {
      unint64_t v33 = 0xAAAAAAAAAAAAAAAALL;
      *(void *)&long long v22 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v22 + 1)  = 0xAAAAAAAAAAAAAAAALL;
      long long v31 = v22;
      long long v32 = v22;
      OTL::Coverage::Coverage((OTL::Coverage *)&v31, (unsigned __int16 *)(a2 + (bswap32(*(unsigned __int16 *)(a2 + 2 * v5 + v19 + 8)) >> 16)), v4, 1);
      BOOL v23 = (unsigned int (*)(void *, void))v32;
      BOOL v24 = (void *)((char *)&v31 + (*((uint64_t *)&v32 + 1) >> 1));
      if (BYTE8(v32)) {
        BOOL v23 = *(unsigned int (**)(void *, void))(*v24 + v32);
      }
      if (!v23(v24, *(unsigned __int16 *)(v20 + v19))) {
        break;
      }
      ++v21;
      v19 += 2;
      if (v9 == v21)
      {
        unint64_t v12 = (unsigned __int16 *)(a2 + 2 * v5 + v19 + 8);
        unsigned int v7 = a4;
        a1  = v28;
        uint64_t v10 = a3;
        goto LABEL_27;
      }
    }
    unint64_t v12 = (unsigned __int16 *)(a2 + 2 * v5 + v19 + 10);
    unsigned int v7 = a4;
    a1  = v28;
    uint64_t v10 = a3;
  }
  if (v21 != v9) {
    return 0;
  }
LABEL_27:
  if ((unint64_t)v12 < a2 || (unint64_t)(v12 + 1) > v4) {
    return 0;
  }
  unsigned int v26 = &v12[bswap32(*v12) >> 16];
  if ((unint64_t)(v26 + 2) > v4) {
    return 0;
  }
  uint64_t result = OTL::GSUB::WouldSubstituteLookupRecords(a1, a2, v26 + 2, bswap32(v26[1]) >> 16, v10, v7);
  if (result) {
    return 1;
  }
  return result;
}

uint64_t OTL::GSUB::ApplyReverseChainSingleSubst(uint64_t a1, unint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5)
{
  uint64_t v10 = *(void *)(a3 + 48);
  TRunGlue::GetGlyphID(*(TRunGlue **)a3, v10);
  unint64_t v11 = *(void *)(a1 + 40);
  unint64_t v12 = (unsigned __int16 *)(a2 + 6);
  if (a2 + 6 > v11) {
    return 0;
  }
  unsigned int v13 = *(unsigned __int16 *)(a2 + 4);
  uint64_t v14 = __rev16(v13);
  if (*(_WORD *)(a2 + 4))
  {
    uint64_t v15 = *(void *)(a3 + 40);
    uint64_t v16 = *(void *)(a3 + 48);
    if (*(int *)(a3 + 8) < 1)
    {
      if (v16 - v14 <= v15) {
        return 0;
      }
    }
    else if (v16 + v14 >= v15)
    {
      return 0;
    }
  }
  BOOL v17 = &v12[v14];
  unint64_t v18 = v17 + 1;
  if ((unint64_t)(v17 + 1) > v11) {
    return 0;
  }
  unsigned int v19 = *v17;
  uint64_t v20 = __rev16(v19);
  if (!*v17) {
    goto LABEL_13;
  }
  uint64_t v21 = *(void *)(a3 + 48);
  uint64_t v22 = *(void *)(a3 + 32);
  if (*(int *)(a3 + 8) < 1)
  {
    if (v21 + v20 < v22) {
      goto LABEL_13;
    }
    return 0;
  }
  if (v21 - v20 <= v22) {
    return 0;
  }
LABEL_13:
  CFIndex v37 = v10;
  if (v13 && !TGlyphIterator::MatchCoverSequence<(MatchDirection)0>(a3, v10, v14, v12, a2, v11, &v37)) {
    return 0;
  }
  CFIndex v36 = v10;
  if (v19)
  {
    if (!TGlyphIterator::MatchCoverSequence<(MatchDirection)1>(a3, v10, v20, v18, a2, v11, &v36)) {
      return 0;
    }
  }
  BOOL v23 = &v18[v20];
  BOOL v24 = v23 + 1;
  if ((unint64_t)v23 < a2 || (unint64_t)v24 > v11) {
    return 0;
  }
  uint64_t v26 = bswap32(*v23) >> 16;
  if (v26 < a4) {
    return 0;
  }
  unint64_t v27 = (unint64_t)&v24[v26];
  BOOL v28 = (unint64_t)v24 >= a2 && v27 >= (unint64_t)v24;
  if (!v28 || v27 > v11)
  {
    BOOL v30 = (unint64_t)(v23 + 2) <= v11 && (unint64_t)v24 >= a2;
    unint64_t v31 = (v11 - (unint64_t)v24) >> 1;
    if (!v30) {
      unint64_t v31 = 0;
    }
    if (v31 != v26) {
      return 0;
    }
  }
  TRunGlue::SetGlyphID<true>(*(TRunGlue **)a3, *(void *)(a3 + 48), bswap32(v24[a4 - 1]) >> 16);
  uint64_t v32 = 1;
  std::function<void ()(CFRange,long)>::operator()(a5, v10, 1, 1);
  if (*(void *)(*(void *)a3 + 152))
  {
    if (v37 >= v36) {
      v33.CFIndex location = v36;
    }
    else {
      v33.CFIndex location = v37;
    }
    if (v37 - v36 >= 0) {
      CFIndex v34 = v37 - v36;
    }
    else {
      CFIndex v34 = v36 - v37;
    }
    v33.CFIndex length = v34 + 1;
    TRunGlue::ClearSafeToBreakAfter(*(void *)a3, v33);
    return 1;
  }
  return v32;
}

void OTL::GSUB::~GSUB(OTL::GSUB *this)
{
}

unsigned __int16 *OTL::GSUB::WouldSubstituteSubtable(void *a1, int a2, int a3, ChainContextSubstFormat1 *this, unsigned int a5, unsigned __int16 *a6, unsigned int a7)
{
  switch(a3)
  {
    case 6:
      unsigned int v8 = bswap32(*(unsigned __int16 *)this) >> 16;
      switch(v8)
      {
        case 3u:
          return (unsigned __int16 *)OTL::GSUB::WouldSubstituteChainContext3(a1, (unint64_t)this, (uint64_t)a6, a7);
        case 2u:
          return OTL::GSUB::WouldSubstituteChainContext2(a1, (unsigned __int16 *)this, a6, a7);
        case 1u:
          return (unsigned __int16 *)OTL::GSUB::WouldSubstituteChainContext1(a1, this, a5, (uint64_t)a6, a7);
        default:
          return 0;
      }
    case 5:
      unsigned int v9 = bswap32(*(unsigned __int16 *)this) >> 16;
      switch(v9)
      {
        case 3u:
          return (unsigned __int16 *)OTL::GSUB::WouldSubstituteContext3(a1, (unint64_t)this, (uint64_t)a6, a7);
        case 2u:
          return (unsigned __int16 *)OTL::GSUB::WouldSubstituteContext2(a1, (unsigned __int16 *)this, a6, a7);
        case 1u:
          return (unsigned __int16 *)OTL::GSUB::WouldSubstituteContext1(a1, this, a5, (uint64_t)a6, a7);
        default:
          return 0;
      }
    case 4:
      return (unsigned __int16 *)OTL::GSUB::WouldSubstituteLigature((uint64_t)a1, (uint64_t)this, a5, (uint64_t)a6, a7);
    default:
      return 0;
  }
}

void *std::__function::__func<OTL::GSUB::AddShapingGlyphsForLookup(OTL::Lookup const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0,std::allocator<OTL::GSUB::AddShapingGlyphsForLookup(OTL::Lookup const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0>,BOOL ()(unsigned short,unsigned short,unsigned short)>::~__func(void *a1)
{
  *a1  = &unk_1ED061A60;
  std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100](a1 + 1);
  return a1;
}

void std::__function::__func<OTL::GSUB::AddShapingGlyphsForLookup(OTL::Lookup const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0,std::allocator<OTL::GSUB::AddShapingGlyphsForLookup(OTL::Lookup const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0>,BOOL ()(unsigned short,unsigned short,unsigned short)>::~__func(void *a1)
{
  *a1  = &unk_1ED061A60;
  std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100](a1 + 1);

  JUMPOUT(0x1853275C0);
}

uint64_t std::__function::__func<OTL::GSUB::AddShapingGlyphsForLookup(OTL::Lookup const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0,std::allocator<OTL::GSUB::AddShapingGlyphsForLookup(OTL::Lookup const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0>,BOOL ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1, void *a2)
{
  *a2  = &unk_1ED061A60;
  return std::__function::__value_func<void ()(unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)(a2 + 1), a1 + 8);
}

void *std::__function::__func<OTL::GSUB::AddShapingGlyphsForLookup(OTL::Lookup const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0,std::allocator<OTL::GSUB::AddShapingGlyphsForLookup(OTL::Lookup const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0>,BOOL ()(unsigned short,unsigned short,unsigned short)>::destroy(uint64_t a1)
{
  return std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100]((void *)(a1 + 8));
}

uint64_t std::__function::__value_func<void ()(CFRange,long)>::__value_func[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24)  = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24)  = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24)  = 0;
  }
  return a1;
}

void std::__function::__func<OTL::GSUB::ApplySubstLookupRecords(OTL::LookupSubtable const*,OTL::SubstLookupRecord const*,unsigned int,TGlyphIterator &,long,long *,unsigned long,unsigned short *,OTL::SubstitutionState *,unsigned long)::$_1,std::allocator<OTL::GSUB::ApplySubstLookupRecords(OTL::LookupSubtable const*,OTL::SubstLookupRecord const*,unsigned int,TGlyphIterator &,long,long *,unsigned long,unsigned short *,OTL::SubstitutionState *,unsigned long)::$_1>,void ()(CFRange,long)>::~__func()
{
}

void *std::__function::__func<OTL::GSUB::ApplySubstLookupRecords(OTL::LookupSubtable const*,OTL::SubstLookupRecord const*,unsigned int,TGlyphIterator &,long,long *,unsigned long,unsigned short *,OTL::SubstitutionState *,unsigned long)::$_1,std::allocator<OTL::GSUB::ApplySubstLookupRecords(OTL::LookupSubtable const*,OTL::SubstLookupRecord const*,unsigned int,TGlyphIterator &,long,long *,unsigned long,unsigned short *,OTL::SubstitutionState *,unsigned long)::$_1>,void ()(CFRange,long)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1ED05D3B8;
  result[1]  = v3;
  return result;
}

void *std::__function::__func<OTL::GSUB::AddCoveredGlyphs(TInlineVector<std::pair<unsigned short,unsigned short>,30ul> const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0,std::allocator<OTL::GSUB::AddCoveredGlyphs(TInlineVector<std::pair<unsigned short,unsigned short>,30ul> const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0>,BOOL ()(unsigned short,unsigned short,unsigned short)>::~__func(void *a1)
{
  *a1  = &unk_1ED061A18;
  std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100](a1 + 1);
  return a1;
}

void std::__function::__func<OTL::GSUB::AddCoveredGlyphs(TInlineVector<std::pair<unsigned short,unsigned short>,30ul> const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0,std::allocator<OTL::GSUB::AddCoveredGlyphs(TInlineVector<std::pair<unsigned short,unsigned short>,30ul> const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0>,BOOL ()(unsigned short,unsigned short,unsigned short)>::~__func(void *a1)
{
  *a1  = &unk_1ED061A18;
  std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100](a1 + 1);

  JUMPOUT(0x1853275C0);
}

void *std::__function::__func<OTL::GSUB::AddCoveredGlyphs(TInlineVector<std::pair<unsigned short,unsigned short>,30ul> const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0,std::allocator<OTL::GSUB::AddCoveredGlyphs(TInlineVector<std::pair<unsigned short,unsigned short>,30ul> const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0>,BOOL ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x28uLL);
  *uint64_t v2 = &unk_1ED061A18;
  std::__function::__value_func<void ()(unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)(v2 + 1), v1);
  return v2;
}

uint64_t std::__function::__func<OTL::GSUB::AddCoveredGlyphs(TInlineVector<std::pair<unsigned short,unsigned short>,30ul> const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0,std::allocator<OTL::GSUB::AddCoveredGlyphs(TInlineVector<std::pair<unsigned short,unsigned short>,30ul> const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0>,BOOL ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1, void *a2)
{
  *a2  = &unk_1ED061A18;
  return std::__function::__value_func<void ()(unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)(a2 + 1), a1 + 8);
}

void *std::__function::__func<OTL::GSUB::AddCoveredGlyphs(TInlineVector<std::pair<unsigned short,unsigned short>,30ul> const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0,std::allocator<OTL::GSUB::AddCoveredGlyphs(TInlineVector<std::pair<unsigned short,unsigned short>,30ul> const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0>,BOOL ()(unsigned short,unsigned short,unsigned short)>::destroy(uint64_t a1)
{
  return std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100]((void *)(a1 + 8));
}

void std::__function::__func<OTL::GSUB::AddCoveredGlyphs(TInlineVector<std::pair<unsigned short,unsigned short>,30ul> const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0,std::allocator<OTL::GSUB::AddCoveredGlyphs(TInlineVector<std::pair<unsigned short,unsigned short>,30ul> const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0>,BOOL ()(unsigned short,unsigned short,unsigned short)>::destroy_deallocate(void *a1)
{
  std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100](a1 + 1);

  operator delete(a1);
}

uint64_t std::__function::__func<OTL::GSUB::AddCoveredGlyphs(TInlineVector<std::pair<unsigned short,unsigned short>,30ul> const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0,std::allocator<OTL::GSUB::AddCoveredGlyphs(TInlineVector<std::pair<unsigned short,unsigned short>,30ul> const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0>,BOOL ()(unsigned short,unsigned short,unsigned short)>::operator()(uint64_t a1, __int16 *a2, __int16 *a3)
{
  return 1;
}

unsigned __int16 *OTL::ClassDefTable::PopulateGlyphClassBitmap(unsigned __int16 *this, int a2, unsigned __int8 *a3, uint64_t a4)
{
  unsigned int v4 = bswap32(*this) >> 16;
  if (v4 == 2)
  {
    if (this[1])
    {
      uint64_t v10 = this + 2;
      uint64_t v11 = (uint64_t)&this[3 * __rev16(this[1]) + 2];
      do
      {
        if (a2 == bswap32(v10[2]) >> 16)
        {
          unsigned int v12 = bswap32(*v10) >> 16;
          unsigned int v13 = bswap32(v10[1]);
          if (v12 <= HIWORD(v13))
          {
            unsigned int v14 = HIWORD(v13);
            if (v12 != (unsigned __int16)(v14 + 1))
            {
              do
              {
                if (a4 <= (unsigned __int16)v12) {
                  break;
                }
                BOOL v15 = v14 == (unsigned __int16)v12;
                a3[(unsigned __int16)v12 >> 3] |= 1 << (v12 & 7);
                LOWORD(v12)  = v12 + 1;
              }
              while (!v15);
            }
          }
        }
        v10 += 3;
      }
      while (v10 != (unsigned __int16 *)v11);
    }
  }
  else if (v4 == 1 && this[2])
  {
    uint64_t v5 = 0;
    uint64_t v6 = bswap32(this[1]) >> 16;
    LODWORD(v7)  = __rev16(this[2]);
    if (a4 <= v6) {
      uint64_t v8 = v6;
    }
    else {
      uint64_t v8 = a4;
    }
    uint64_t v9 = v8 - v6;
    if (v7 <= 1) {
      uint64_t v7 = 1;
    }
    else {
      uint64_t v7 = v7;
    }
    do
    {
      if (v9 == v5) {
        break;
      }
      if (a2 == bswap32(this[v5 + 3]) >> 16) {
        a3[(unsigned __int16)(v6 + v5) >> 3] |= 1 << ((v6 + v5) & 7);
      }
      ++v5;
    }
    while (v7 != v5);
  }
  return this;
}

BOOL OTL::ClassDefTable::operator==(unsigned __int16 *a1, unsigned __int16 *a2)
{
  unsigned int v2 = *a1;
  unsigned int v3 = *a2;
  if (v2 == v3
    && ((v4 = __rev16(v3), unsigned int v5 = __rev16(v2), v5 == 2)
      ? (size_t v6 = 6 * (bswap32(a1[1]) >> 16) + 4)
      : v5 != 1
      ? (size_t v6 = 0)
      : (size_t v6 = 2 * (bswap32(a1[2]) >> 16) + 6),
        v4 == 2
      ? (uint64_t v7 = 6 * (bswap32(a2[1]) >> 16) + 4)
      : v4 != 1
      ? (uint64_t v7 = 0)
      : (uint64_t v7 = 2 * (bswap32(a2[2]) >> 16) + 6),
        v6 == v7))
  {
    return memcmp(a1, a2, v6) == 0;
  }
  else
  {
    return 0;
  }
}

uint64_t OTL::GCommon::IterateFeatureTables(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  if (!a2) {
    return 0;
  }
  if (*(_WORD *)(a1 + 6))
  {
    size_t v6 = (unsigned __int16 *)(a1 + __rev16(*(unsigned __int16 *)(a1 + 6)));
    uint64_t v7 = v6 + 1;
    if ((unint64_t)(v6 + 1) <= a3)
    {
      uint64_t v10 = bswap32(*v6) >> 16;
      unint64_t v11 = (unint64_t)&v7[3 * v10];
      BOOL v12 = v11 < (unint64_t)v7 || v11 > a3;
      if (!v12
        || ((unint64_t)(v6 + 4) <= a3 ? (unint64_t v13 = (a3 - (unint64_t)v7) / 6) : (unint64_t v13 = 0), v13 == v10))
      {
        if (!*(_WORD *)(a2 + 4)) {
          return 1;
        }
        unsigned int v14 = (unsigned __int16 *)(a2 + 6);
        uint64_t v15 = 2 * __rev16(*(unsigned __int16 *)(a2 + 4)) - 2;
        while (1)
        {
          unsigned int v16 = bswap32(*v14) >> 16;
          BOOL v17 = &v7[3 * v16];
          if ((unint64_t)v17 < a1 || (unint64_t)(v17 + 3) > a3) {
            break;
          }
          uint64_t v19 = (uint64_t)v6 + (bswap32(v6[3 * v16 + 3]) >> 16);
          unint64_t v20 = v19 + 4;
          if (v19 + 2 < (unint64_t)v6 || v20 > a3) {
            break;
          }
          uint64_t v22 = bswap32(*(unsigned __int16 *)(v19 + 2)) >> 16;
          unint64_t v23 = v20 + 2 * v22;
          unint64_t v24 = v19 + 6 <= a3 ? (a3 - v20) >> 1 : 0;
          BOOL v25 = v23 <= a3 && v23 >= v20;
          if (!v25 && v24 != v22) {
            break;
          }
          uint64_t result = std::function<BOOL ()(unsigned int,OTL::FeatureTable const*,BOOL &)>::operator()(a4, bswap32(*(_DWORD *)&v6[3 * v16 + 1]), v19);
          if (result)
          {
            uint64_t result = 1;
            ++v14;
            uint64_t v27 = v15;
            v15 -= 2;
            if (v27) {
              continue;
            }
          }
          return result;
        }
      }
    }
  }
  return 0;
}

uint64_t OTL::GCommon::IterateLookupIndexes(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  if (*(_WORD *)(a1 + 8))
  {
    unsigned int v4 = (unsigned __int16 *)(a1 + __rev16(*(unsigned __int16 *)(a1 + 8)));
    unsigned int v5 = v4 + 1;
    if ((unint64_t)(v4 + 1) <= a3)
    {
      uint64_t v6 = bswap32(*v4) >> 16;
      unint64_t v7 = (unint64_t)&v5[v6];
      unint64_t v8 = (unint64_t)(v4 + 2) <= a3 ? (a3 - (unint64_t)v5) >> 1 : 0;
      BOOL v9 = v7 <= a3 && v7 >= (unint64_t)v5;
      if (v9 || v8 == v6)
      {
        if (!*(_WORD *)(a2 + 2)) {
          return 1;
        }
        BOOL v12 = (unsigned __int16 *)(a2 + 4);
        uint64_t v13 = 2 * __rev16(*(unsigned __int16 *)(a2 + 2)) - 2;
        while (1)
        {
          unsigned int v14 = bswap32(*v12) >> 16;
          if (v14 >= v6) {
            break;
          }
          uint64_t result = std::function<BOOL ()(unsigned short,BOOL &)>::operator()(a4, v14);
          if (result)
          {
            uint64_t result = 1;
            ++v12;
            uint64_t v16 = v13;
            v13 -= 2;
            if (v16) {
              continue;
            }
          }
          return result;
        }
      }
    }
  }
  return 0;
}

uint64_t std::function<BOOL ()(unsigned short,BOOL &)>::operator()(uint64_t a1, __int16 a2)
{
  __int16 v8 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2) {
    return (*(uint64_t (**)(uint64_t, __int16 *))(*(void *)v2 + 48))(v2, &v8);
  }
  uint64_t v4 = std::__throw_bad_function_call[abi:nn180100]();
  return OTL::GCommon::IterateConditionSetTables(v4, v5, v6, v7);
}

uint64_t OTL::GCommon::IterateConditionSetTables(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  if (!a2) {
    return 0;
  }
  unsigned int v5 = *(_DWORD *)(a2 + 4);
  if (!v5) {
    return 1;
  }
  uint64_t v7 = bswap32(*(_DWORD *)(a2 + 8));
  __int16 v8 = (unsigned __int16 *)(a2 + v7);
  unint64_t v9 = a2 + v7 + 2;
  if (v9 <= a3)
  {
    unint64_t v11 = (unsigned int *)(a2 + 8);
    uint64_t v12 = a2 + 8 + 8 * bswap32(v5);
    do
    {
      uint64_t v13 = bswap32(*v8) >> 16;
      unint64_t v14 = v9 + 4 * v13;
      unint64_t v15 = (unint64_t)(v8 + 3) <= a3 ? (a3 - v9) >> 2 : 0;
      BOOL v16 = v14 <= a3 && v14 >= v9;
      if (!v16 && v15 != v13) {
        break;
      }
      unint64_t v18 = (_WORD *)(a2 + bswap32(v11[1]));
      uint64_t v19 = v18 + 3;
      if ((unint64_t)(v18 + 3) > a3) {
        break;
      }
      uint64_t v20 = bswap32((unsigned __int16)v18[2]) >> 16;
      unint64_t v21 = (unint64_t)&v19[3 * v20];
      if (v21 < (unint64_t)v19 || v21 > a3)
      {
        unint64_t v23 = (a3 - (unint64_t)v19) / 6;
        if ((unint64_t)(v18 + 6) > a3) {
          unint64_t v23 = 0;
        }
        if (v23 != v20) {
          break;
        }
      }
      if (*v18 == 256)
      {
        uint64_t result = (uint64_t)std::function<BOOL ()(OTL::ConditionSetTable const*,OTL::FeatureTableSubstitutionTable const*,BOOL &)>::operator()(a4, (uint64_t)v8, (uint64_t)v18);
        if (!result) {
          return result;
        }
        uint64_t result = 1;
        v11 += 2;
        if (v11 == (unsigned int *)v12) {
          return result;
        }
      }
      else
      {
        v11 += 2;
        if (v11 == (unsigned int *)v12) {
          return 1;
        }
      }
      __int16 v8 = (unsigned __int16 *)(a2 + bswap32(*v11));
      unint64_t v9 = (unint64_t)(v8 + 1);
    }
    while ((unint64_t)(v8 + 1) <= a3);
  }
  return 0;
}

OTL::Coverage *std::function<BOOL ()(OTL::ConditionSetTable const*,OTL::FeatureTableSubstitutionTable const*,BOOL &)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v8 = a3;
  uint64_t v9 = a2;
  uint64_t v3 = *(void *)(a1 + 24);
  if (v3) {
    return (OTL::Coverage *)(*(uint64_t (**)(uint64_t, uint64_t *, uint64_t *))(*(void *)v3 + 48))(v3, &v9, &v8);
  }
  unsigned int v5 = (OTL::Coverage *)std::__throw_bad_function_call[abi:nn180100]();
  return OTL::GDEF::IterateMarkGlyphsNotInSet(v5, v6, v7);
}

OTL::Coverage *OTL::GDEF::IterateMarkGlyphsNotInSet(OTL::Coverage *result, unsigned int a2, uint64_t a3)
{
  v15[4]  = *MEMORY[0x1E4F143B8];
  if (*((unsigned char *)result + 24))
  {
    uint64_t v3 = (void *)*((void *)result + 2);
    if (v3)
    {
      unint64_t v11 = 0xAAAAAAAAAAAAAAAALL;
      *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v5 + 1)  = 0xAAAAAAAAAAAAAAAALL;
      v10[0]  = v5;
      v10[1]  = v5;
      OTL::GDEF::MarkFilteringSet(result, a2, (uint64_t)v10);
      uint64_t v12 = v10;
      std::__function::__value_func<void ()(unsigned short)>::__value_func[abi:nn180100]((uint64_t)v13, a3);
      unsigned int v6 = operator new(0x30uLL);
      uint64_t v7 = v6;
      uint64_t v8 = v12;
      uint64_t v9 = v14;
      *unsigned int v6 = &unk_1ED061700;
      v6[1]  = v8;
      if (v9)
      {
        if (v9 == v13)
        {
          v6[5]  = v6 + 2;
          (*(void (**)(void *))(v13[0] + 24))(v13);
        }
        else
        {
          v6[5]  = v9;
          unint64_t v14 = 0;
        }
      }
      else
      {
        v6[5]  = 0;
      }
      v15[3]  = v7;
      OTL::ClassDefTable::Iterate(v3, (uint64_t)v15);
      std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100](v15);
      return (OTL::Coverage *)std::__function::__value_func<void ()(unsigned short)>::~__value_func[abi:nn180100](v13);
    }
  }
  return result;
}

void *OTL::GDEF::IterateMarkGlyphsNotOfAttachmentType(void *result, __int16 a2, uint64_t a3)
{
  v15[4]  = *MEMORY[0x1E4F143B8];
  __int16 v14 = a2;
  uint64_t v3 = *result;
  if (*result)
  {
    if (*(_WORD *)(v3 + 10))
    {
      uint64_t v4 = result;
      long long v5 = (char *)(v3 + __rev16(*(unsigned __int16 *)(v3 + 10)));
      uint64_t v13 = v5;
      unint64_t v6 = result[1];
      if ((unint64_t)(v5 + 2) <= v6)
      {
        unsigned int v8 = bswap32(*(unsigned __int16 *)v5) >> 16;
        if (v8 == 2)
        {
          uint64_t v9 = 6 * (bswap32(*((unsigned __int16 *)v5 + 1)) >> 16) + 4;
        }
        else if (v8 == 1)
        {
          uint64_t v9 = 2 * (bswap32(*((unsigned __int16 *)v5 + 2)) >> 16) + 6;
        }
        else
        {
          uint64_t v9 = 0;
        }
        uint64_t v10 = &v5[v9];
        if (v10 >= v5 && (unint64_t)v10 <= v6)
        {
          uint64_t v12 = operator new(0x20uLL);
          void *v12 = &unk_1ED061868;
          v12[1]  = &v13;
          v12[2]  = &v14;
          v12[3]  = a3;
          v15[3]  = v12;
          OTL::GDEF::IterateGlyphsWithClassMask(v4, 8, (uint64_t)v15);
          return std::__function::__value_func<void ()(unsigned short)>::~__value_func[abi:nn180100](v15);
        }
      }
    }
  }
  return result;
}

uint64_t std::__function::__value_func<void ()(unsigned short)>::__value_func[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24)  = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24)  = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24)  = 0;
  }
  return a1;
}

void *std::__function::__func<OTL::GDEF::IterateGlyphsWithClassMask(unsigned int,std::function<void ()(unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short)#1},std::allocator<OTL::GDEF::IterateGlyphsWithClassMask(unsigned int,std::function<void ()(unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short)#1}>,void ()(unsigned short,unsigned short,unsigned short)>::~__func(void *a1)
{
  *a1  = &unk_1ED061748;
  std::__function::__value_func<void ()(unsigned short)>::~__value_func[abi:nn180100](a1 + 2);
  return a1;
}

void std::__function::__func<OTL::GDEF::IterateGlyphsWithClassMask(unsigned int,std::function<void ()(unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short)#1},std::allocator<OTL::GDEF::IterateGlyphsWithClassMask(unsigned int,std::function<void ()(unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short)#1}>,void ()(unsigned short,unsigned short,unsigned short)>::~__func(void *a1)
{
  *a1  = &unk_1ED061748;
  std::__function::__value_func<void ()(unsigned short)>::~__value_func[abi:nn180100](a1 + 2);

  JUMPOUT(0x1853275C0);
}

_DWORD *std::__function::__func<OTL::GDEF::IterateGlyphsWithClassMask(unsigned int,std::function<void ()(unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short)#1},std::allocator<OTL::GDEF::IterateGlyphsWithClassMask(unsigned int,std::function<void ()(unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short)#1}>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  uint64_t v2 = operator new(0x30uLL);
  *(void *)uint64_t v2 = &unk_1ED061748;
  v2[2]  = *(_DWORD *)(a1 + 8);
  std::__function::__value_func<void ()(unsigned short)>::__value_func[abi:nn180100]((uint64_t)(v2 + 4), a1 + 16);
  return v2;
}

uint64_t std::__function::__func<OTL::GDEF::IterateGlyphsWithClassMask(unsigned int,std::function<void ()(unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short)#1},std::allocator<OTL::GDEF::IterateGlyphsWithClassMask(unsigned int,std::function<void ()(unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short)#1}>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2  = &unk_1ED061748;
  *(_DWORD *)(a2 + 8)  = *(_DWORD *)(a1 + 8);
  return std::__function::__value_func<void ()(unsigned short)>::__value_func[abi:nn180100](a2 + 16, a1 + 16);
}

void *std::__function::__func<OTL::GDEF::IterateGlyphsWithClassMask(unsigned int,std::function<void ()(unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short)#1},std::allocator<OTL::GDEF::IterateGlyphsWithClassMask(unsigned int,std::function<void ()(unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short)#1}>,void ()(unsigned short,unsigned short,unsigned short)>::destroy(uint64_t a1)
{
  return std::__function::__value_func<void ()(unsigned short)>::~__value_func[abi:nn180100]((void *)(a1 + 16));
}

void std::__function::__func<OTL::GDEF::IterateGlyphsWithClassMask(unsigned int,std::function<void ()(unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short)#1},std::allocator<OTL::GDEF::IterateGlyphsWithClassMask(unsigned int,std::function<void ()(unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short)#1}>,void ()(unsigned short,unsigned short,unsigned short)>::destroy_deallocate(void *a1)
{
  std::__function::__value_func<void ()(unsigned short)>::~__value_func[abi:nn180100](a1 + 2);

  operator delete(a1);
}

_DWORD *std::__function::__func<OTL::GDEF::IterateGlyphsWithClassMask(unsigned int,std::function<void ()(unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short)#1},std::allocator<OTL::GDEF::IterateGlyphsWithClassMask(unsigned int,std::function<void ()(unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short)#1}>,void ()(unsigned short,unsigned short,unsigned short)>::operator()(uint64_t a1, unsigned __int16 *a2, unsigned __int16 *a3, unsigned __int16 *a4)
{
  return std::__invoke_void_return_wrapper<void,true>::__call[abi:nn180100]<OTL::GDEF::IterateGlyphsWithClassMask(unsigned int,std::function<void ()(unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short)#1} &,unsigned short,unsigned short,unsigned short>((_DWORD *)(a1 + 8), a2, a3, a4);
}

_DWORD *std::__invoke_void_return_wrapper<void,true>::__call[abi:nn180100]<OTL::GDEF::IterateGlyphsWithClassMask(unsigned int,std::function<void ()(unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short)#1} &,unsigned short,unsigned short,unsigned short>(_DWORD *result, unsigned __int16 *a2, unsigned __int16 *a3, unsigned __int16 *a4)
{
  unsigned int v4 = *a4;
  if (v4 <= 0x1F && ((*result >> v4) & 1) != 0)
  {
    unsigned int v5 = *a2;
    unsigned int v6 = *a3;
    if (v5 <= v6 && v5 != (unsigned __int16)(v6 + 1))
    {
      uint64_t v7 = (uint64_t)(result + 2);
      do
      {
        int v8 = (unsigned __int16)v5;
        uint64_t result = (_DWORD *)std::function<void ()(unsigned short)>::operator()(v7, v5++);
      }
      while (v8 != v6);
    }
  }
  return result;
}

uint64_t std::function<void ()(unsigned short)>::operator()(uint64_t a1, __int16 a2)
{
  __int16 v4 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2)
  {
    std::__throw_bad_function_call[abi:nn180100]();
    JUMPOUT(0x184B150A4);
  }
  return (*(uint64_t (**)(uint64_t, __int16 *))(*(void *)v2 + 48))(v2, &v4);
}

void std::__function::__func<OTL::GDEF::IterateGlyphsIgnoredByLookupTable(OTL::LookupTable const*,std::function<void ()(unsigned short)>)::{lambda(unsigned short)#1},std::allocator<OTL::GDEF::IterateGlyphsIgnoredByLookupTable(OTL::LookupTable const*,std::function<void ()(unsigned short)>)::{lambda(unsigned short)#1}>,void ()(unsigned short)>::~__func()
{
}

void *std::__function::__func<OTL::GDEF::IterateGlyphsIgnoredByLookupTable(OTL::LookupTable const*,std::function<void ()(unsigned short)>)::{lambda(unsigned short)#1},std::allocator<OTL::GDEF::IterateGlyphsIgnoredByLookupTable(OTL::LookupTable const*,std::function<void ()(unsigned short)>)::{lambda(unsigned short)#1}>,void ()(unsigned short)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1ED061820;
  result[1]  = v3;
  return result;
}

uint64_t std::__function::__func<OTL::GDEF::IterateGlyphsIgnoredByLookupTable(OTL::LookupTable const*,std::function<void ()(unsigned short)>)::{lambda(unsigned short)#1},std::allocator<OTL::GDEF::IterateGlyphsIgnoredByLookupTable(OTL::LookupTable const*,std::function<void ()(unsigned short)>)::{lambda(unsigned short)#1}>,void ()(unsigned short)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2  = &unk_1ED061820;
  a2[1]  = v2;
  return result;
}

uint64_t std::__function::__func<OTL::GDEF::IterateGlyphsIgnoredByLookupTable(OTL::LookupTable const*,std::function<void ()(unsigned short)>)::{lambda(unsigned short)#1},std::allocator<OTL::GDEF::IterateGlyphsIgnoredByLookupTable(OTL::LookupTable const*,std::function<void ()(unsigned short)>)::{lambda(unsigned short)#1}>,void ()(unsigned short)>::operator()(uint64_t a1, __int16 *a2)
{
  return std::function<void ()(unsigned short)>::operator()(*(void *)(a1 + 8), *a2);
}

void *std::__function::__func<OTL::GDEF::IterateMarkGlyphsNotInSet(unsigned short,std::function<void ()(unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short)#1},std::allocator<OTL::GDEF::IterateMarkGlyphsNotInSet(unsigned short,std::function<void ()(unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short)#1}>,void ()(unsigned short,unsigned short,unsigned short)>::~__func(void *a1)
{
  *a1  = &unk_1ED061700;
  std::__function::__value_func<void ()(unsigned short)>::~__value_func[abi:nn180100](a1 + 2);
  return a1;
}

void std::__function::__func<OTL::GDEF::IterateMarkGlyphsNotInSet(unsigned short,std::function<void ()(unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short)#1},std::allocator<OTL::GDEF::IterateMarkGlyphsNotInSet(unsigned short,std::function<void ()(unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short)#1}>,void ()(unsigned short,unsigned short,unsigned short)>::~__func(void *a1)
{
  *a1  = &unk_1ED061700;
  std::__function::__value_func<void ()(unsigned short)>::~__value_func[abi:nn180100](a1 + 2);

  JUMPOUT(0x1853275C0);
}

void *std::__function::__func<OTL::GDEF::IterateMarkGlyphsNotInSet(unsigned short,std::function<void ()(unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short)#1},std::allocator<OTL::GDEF::IterateMarkGlyphsNotInSet(unsigned short,std::function<void ()(unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short)#1}>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  uint64_t v2 = operator new(0x30uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t v2 = &unk_1ED061700;
  v2[1]  = v3;
  std::__function::__value_func<void ()(unsigned short)>::__value_func[abi:nn180100]((uint64_t)(v2 + 2), a1 + 16);
  return v2;
}

uint64_t std::__function::__func<OTL::GDEF::IterateMarkGlyphsNotInSet(unsigned short,std::function<void ()(unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short)#1},std::allocator<OTL::GDEF::IterateMarkGlyphsNotInSet(unsigned short,std::function<void ()(unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short)#1}>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2  = &unk_1ED061700;
  a2[1]  = v2;
  return std::__function::__value_func<void ()(unsigned short)>::__value_func[abi:nn180100]((uint64_t)(a2 + 2), a1 + 16);
}

void *std::__function::__func<OTL::GDEF::IterateMarkGlyphsNotInSet(unsigned short,std::function<void ()(unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short)#1},std::allocator<OTL::GDEF::IterateMarkGlyphsNotInSet(unsigned short,std::function<void ()(unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short)#1}>,void ()(unsigned short,unsigned short,unsigned short)>::destroy(uint64_t a1)
{
  return std::__function::__value_func<void ()(unsigned short)>::~__value_func[abi:nn180100]((void *)(a1 + 16));
}

void std::__function::__func<OTL::GDEF::IterateMarkGlyphsNotInSet(unsigned short,std::function<void ()(unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short)#1},std::allocator<OTL::GDEF::IterateMarkGlyphsNotInSet(unsigned short,std::function<void ()(unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short)#1}>,void ()(unsigned short,unsigned short,unsigned short)>::destroy_deallocate(void *a1)
{
  std::__function::__value_func<void ()(unsigned short)>::~__value_func[abi:nn180100](a1 + 2);

  operator delete(a1);
}

uint64_t std::__function::__func<OTL::GDEF::IterateMarkGlyphsNotInSet(unsigned short,std::function<void ()(unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short)#1},std::allocator<OTL::GDEF::IterateMarkGlyphsNotInSet(unsigned short,std::function<void ()(unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short)#1}>,void ()(unsigned short,unsigned short,unsigned short)>::operator()(uint64_t a1, unsigned __int16 *a2, unsigned __int16 *a3, _WORD *a4)
{
  return std::__invoke_void_return_wrapper<void,true>::__call[abi:nn180100]<OTL::GDEF::IterateMarkGlyphsNotInSet(unsigned short,std::function<void ()(unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short)#1} &,unsigned short,unsigned short,unsigned short>(a1 + 8, a2, a3, a4);
}

uint64_t std::__invoke_void_return_wrapper<void,true>::__call[abi:nn180100]<OTL::GDEF::IterateMarkGlyphsNotInSet(unsigned short,std::function<void ()(unsigned short)>)::{lambda(unsigned short,unsigned short,unsigned short)#1} &,unsigned short,unsigned short,unsigned short>(uint64_t result, unsigned __int16 *a2, unsigned __int16 *a3, _WORD *a4)
{
  unsigned int v4 = *a2;
  unsigned int v5 = *a3;
  BOOL v6 = *a4 != 3 || v4 > v5;
  if (!v6 && v4 != (unsigned __int16)(v5 + 1))
  {
    uint64_t v7 = result;
    uint64_t v8 = result + 8;
    do
    {
      uint64_t v9 = *(uint64_t (**)(void *, void))(*(void *)v7 + 16);
      uint64_t v10 = *(void *)(*(void *)v7 + 24);
      unint64_t v11 = (void *)(*(void *)v7 + (v10 >> 1));
      if (v10) {
        uint64_t v9 = *(uint64_t (**)(void *, void))(*v11 + v9);
      }
      uint64_t result = v9(v11, (unsigned __int16)v4);
      if (!result) {
        uint64_t result = std::function<void ()(unsigned short)>::operator()(v8, v4);
      }
      BOOL v12 = v5 == (unsigned __int16)v4;
      LOWORD(v4)  = v4 + 1;
    }
    while (!v12);
  }
  return result;
}

void std::__function::__func<OTL::GDEF::IterateGlyphsIgnoredByLookupTable(OTL::LookupTable const*,std::function<void ()(unsigned short)>)::{lambda(unsigned short)#2},std::allocator<OTL::GDEF::IterateGlyphsIgnoredByLookupTable(OTL::LookupTable const*,std::function<void ()(unsigned short)>)::{lambda(unsigned short)#2}>,void ()(unsigned short)>::~__func()
{
}

void *std::__function::__func<OTL::GDEF::IterateGlyphsIgnoredByLookupTable(OTL::LookupTable const*,std::function<void ()(unsigned short)>)::{lambda(unsigned short)#2},std::allocator<OTL::GDEF::IterateGlyphsIgnoredByLookupTable(OTL::LookupTable const*,std::function<void ()(unsigned short)>)::{lambda(unsigned short)#2}>,void ()(unsigned short)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1ED061790;
  result[1]  = v3;
  return result;
}

uint64_t std::__function::__func<OTL::GDEF::IterateGlyphsIgnoredByLookupTable(OTL::LookupTable const*,std::function<void ()(unsigned short)>)::{lambda(unsigned short)#2},std::allocator<OTL::GDEF::IterateGlyphsIgnoredByLookupTable(OTL::LookupTable const*,std::function<void ()(unsigned short)>)::{lambda(unsigned short)#2}>,void ()(unsigned short)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2  = &unk_1ED061790;
  a2[1]  = v2;
  return result;
}

uint64_t std::__function::__func<OTL::GDEF::IterateGlyphsIgnoredByLookupTable(OTL::LookupTable const*,std::function<void ()(unsigned short)>)::{lambda(unsigned short)#2},std::allocator<OTL::GDEF::IterateGlyphsIgnoredByLookupTable(OTL::LookupTable const*,std::function<void ()(unsigned short)>)::{lambda(unsigned short)#2}>,void ()(unsigned short)>::operator()(uint64_t a1, __int16 *a2)
{
  return std::function<void ()(unsigned short)>::operator()(*(void *)(a1 + 8), *a2);
}

void std::__function::__func<OTL::GDEF::IterateMarkGlyphsNotOfAttachmentType(unsigned short,std::function<void ()(unsigned short)>)::{lambda(unsigned short)#1},std::allocator<OTL::GDEF::IterateMarkGlyphsNotOfAttachmentType(unsigned short,std::function<void ()(unsigned short)>)::{lambda(unsigned short)#1}>,void ()(unsigned short)>::~__func()
{
}

__n128 std::__function::__func<OTL::GDEF::IterateMarkGlyphsNotOfAttachmentType(unsigned short,std::function<void ()(unsigned short)>)::{lambda(unsigned short)#1},std::allocator<OTL::GDEF::IterateMarkGlyphsNotOfAttachmentType(unsigned short,std::function<void ()(unsigned short)>)::{lambda(unsigned short)#1}>,void ()(unsigned short)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1ED061868;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8)  = result;
  *((void *)v2 + 3)  = *(void *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<OTL::GDEF::IterateMarkGlyphsNotOfAttachmentType(unsigned short,std::function<void ()(unsigned short)>)::{lambda(unsigned short)#1},std::allocator<OTL::GDEF::IterateMarkGlyphsNotOfAttachmentType(unsigned short,std::function<void ()(unsigned short)>)::{lambda(unsigned short)#1}>,void ()(unsigned short)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2  = &unk_1ED061868;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24)  = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8)  = result;
  return result;
}

uint64_t std::__function::__func<OTL::GDEF::IterateMarkGlyphsNotOfAttachmentType(unsigned short,std::function<void ()(unsigned short)>)::{lambda(unsigned short)#1},std::allocator<OTL::GDEF::IterateMarkGlyphsNotOfAttachmentType(unsigned short,std::function<void ()(unsigned short)>)::{lambda(unsigned short)#1}>,void ()(unsigned short)>::operator()(uint64_t a1, __int16 *a2)
{
  return std::__invoke_void_return_wrapper<void,true>::__call[abi:nn180100]<OTL::GDEF::IterateMarkGlyphsNotOfAttachmentType(unsigned short,std::function<void ()(unsigned short)>)::{lambda(unsigned short)#1} &,unsigned short>(a1 + 8, a2);
}

uint64_t std::__invoke_void_return_wrapper<void,true>::__call[abi:nn180100]<OTL::GDEF::IterateMarkGlyphsNotOfAttachmentType(unsigned short,std::function<void ()(unsigned short)>)::{lambda(unsigned short)#1} &,unsigned short>(uint64_t a1, __int16 *a2)
{
  __int16 v3 = *a2;
  uint64_t result = OTL::ClassDefTable::ClassOf(**(OTL::ClassDefTable ***)a1, (unsigned __int16)*a2);
  if (result != **(unsigned __int16 **)(a1 + 8))
  {
    uint64_t v5 = *(void *)(a1 + 16);
    return std::function<void ()(unsigned short)>::operator()(v5, v3);
  }
  return result;
}

void std::__function::__func<OTL::GDEF::IterateGlyphsIgnoredByLookupTable(OTL::LookupTable const*,std::function<void ()(unsigned short)>)::{lambda(unsigned short)#3},std::allocator<OTL::GDEF::IterateGlyphsIgnoredByLookupTable(OTL::LookupTable const*,std::function<void ()(unsigned short)>)::{lambda(unsigned short)#3}>,void ()(unsigned short)>::~__func()
{
}

void *std::__function::__func<OTL::GDEF::IterateGlyphsIgnoredByLookupTable(OTL::LookupTable const*,std::function<void ()(unsigned short)>)::{lambda(unsigned short)#3},std::allocator<OTL::GDEF::IterateGlyphsIgnoredByLookupTable(OTL::LookupTable const*,std::function<void ()(unsigned short)>)::{lambda(unsigned short)#3}>,void ()(unsigned short)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1ED0617D8;
  result[1]  = v3;
  return result;
}

uint64_t std::__function::__func<OTL::GDEF::IterateGlyphsIgnoredByLookupTable(OTL::LookupTable const*,std::function<void ()(unsigned short)>)::{lambda(unsigned short)#3},std::allocator<OTL::GDEF::IterateGlyphsIgnoredByLookupTable(OTL::LookupTable const*,std::function<void ()(unsigned short)>)::{lambda(unsigned short)#3}>,void ()(unsigned short)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2  = &unk_1ED0617D8;
  a2[1]  = v2;
  return result;
}

uint64_t std::__function::__func<OTL::GDEF::IterateGlyphsIgnoredByLookupTable(OTL::LookupTable const*,std::function<void ()(unsigned short)>)::{lambda(unsigned short)#3},std::allocator<OTL::GDEF::IterateGlyphsIgnoredByLookupTable(OTL::LookupTable const*,std::function<void ()(unsigned short)>)::{lambda(unsigned short)#3}>,void ()(unsigned short)>::operator()(uint64_t a1, __int16 *a2)
{
  return std::function<void ()(unsigned short)>::operator()(*(void *)(a1 + 8), *a2);
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned short,unsigned short> *>(unsigned __int16 *a1, unsigned __int16 *a2)
{
  uint64_t v4 = ((char *)a2 - (char *)a1) >> 2;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      unsigned int v6 = *(a2 - 2);
      unsigned int v7 = *a1;
      char v8 = -1;
      if (v6 >= v7) {
        char v8 = 1;
      }
      if (v6 == v7)
      {
        unsigned int v9 = *(a2 - 1);
        unsigned int v10 = a1[1];
        BOOL v11 = v9 >= v10;
        BOOL v12 = v9 == v10;
        char v8 = -1;
        if (v11) {
          char v8 = 1;
        }
        if (v12) {
          char v8 = 0;
        }
      }
      if (v8 < 0)
      {
        *a1  = v6;
        *(a2 - 2)  = v7;
        unsigned __int16 v13 = a1[1];
        a1[1]  = *(a2 - 1);
        *(a2 - 1)  = v13;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned short,unsigned short> *>(a1, a1 + 2, a2 - 2);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned short,unsigned short> *>(a1, a1 + 2, a1 + 4, a2 - 2);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned short,unsigned short> *>(a1, a1 + 2, a1 + 4, a1 + 6, a2 - 2);
      return 1;
    default:
      __int16 v14 = a1 + 4;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned short,unsigned short> *>(a1, a1 + 2, a1 + 4);
      unint64_t v15 = a1 + 6;
      if (a1 + 6 == a2) {
        return 1;
      }
      uint64_t v16 = 0;
      int v17 = 0;
      break;
  }
  while (1)
  {
    unsigned int v18 = *v15;
    unsigned int v19 = *v14;
    BOOL v20 = v18 == v19;
    if (v18 >= v19) {
      char v21 = 1;
    }
    else {
      char v21 = -1;
    }
    if (v20)
    {
      unsigned int v22 = v15[1];
      unsigned int v23 = v14[1];
      BOOL v24 = v22 == v23;
      char v21 = v22 >= v23 ? 1 : -1;
      if (v24) {
        char v21 = 0;
      }
    }
    if (v21 < 0)
    {
      unsigned int v25 = (unsigned __int16)*(_DWORD *)v15;
      unsigned int v26 = HIWORD(*(_DWORD *)v15);
      uint64_t v27 = v16;
      while (1)
      {
        BOOL v28 = (unsigned __int16 *)((char *)a1 + v27);
        v28[6]  = v19;
        v28[7]  = *(unsigned __int16 *)((char *)a1 + v27 + 10);
        if (v27 == -8) {
          break;
        }
        unsigned int v19 = v28[2];
        if (v19 <= v25) {
          char v29 = 1;
        }
        else {
          char v29 = -1;
        }
        if (v19 == v25)
        {
          unsigned int v30 = *(unsigned __int16 *)((char *)a1 + v27 + 6);
          BOOL v31 = v30 == v26;
          char v29 = v30 <= v26 ? 1 : -1;
          if (v31) {
            char v29 = 0;
          }
        }
        v27 -= 4;
        if ((v29 & 0x80) == 0)
        {
          uint64_t v32 = (unsigned __int16 *)((char *)a1 + v27 + 12);
          goto LABEL_39;
        }
      }
      uint64_t v32 = a1;
LABEL_39:
      *uint64_t v32 = v25;
      v32[1]  = v26;
      if (++v17 == 8) {
        return v15 + 2 == a2;
      }
    }
    __int16 v14 = v15;
    v16 += 4;
    v15 += 2;
    if (v15 == a2) {
      return 1;
    }
  }
}

void std::__function::__func<OTL::GCommon::GCommon(OTL::GCommon::Table,TFont const&,__CFData const*,OTL::GDEF const&,unsigned int,unsigned int)::$_0,std::allocator<OTL::GCommon::GCommon(OTL::GCommon::Table,TFont const&,__CFData const*,OTL::GDEF const&,unsigned int,unsigned int)::$_0>,BOOL ()(unsigned int,OTL::FeatureTable const*,BOOL &)>::~__func()
{
}

void *std::__function::__func<OTL::GCommon::GCommon(OTL::GCommon::Table,TFont const&,__CFData const*,OTL::GDEF const&,unsigned int,unsigned int)::$_0,std::allocator<OTL::GCommon::GCommon(OTL::GCommon::Table,TFont const&,__CFData const*,OTL::GDEF const&,unsigned int,unsigned int)::$_0>,BOOL ()(unsigned int,OTL::FeatureTable const*,BOOL &)>::__clone(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *BOOL result = &unk_1ED0613E8;
  result[1]  = v3;
  return result;
}

uint64_t std::__function::__func<OTL::GCommon::GCommon(OTL::GCommon::Table,TFont const&,__CFData const*,OTL::GDEF const&,unsigned int,unsigned int)::$_0,std::allocator<OTL::GCommon::GCommon(OTL::GCommon::Table,TFont const&,__CFData const*,OTL::GDEF const&,unsigned int,unsigned int)::$_0>,BOOL ()(unsigned int,OTL::FeatureTable const*,BOOL &)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2  = &unk_1ED0613E8;
  a2[1]  = v2;
  return result;
}

uint64_t std::__function::__func<OTL::GCommon::GCommon(OTL::GCommon::Table,TFont const&,__CFData const*,OTL::GDEF const&,unsigned int,unsigned int)::$_0,std::allocator<OTL::GCommon::GCommon(OTL::GCommon::Table,TFont const&,__CFData const*,OTL::GDEF const&,unsigned int,unsigned int)::$_0>,BOOL ()(unsigned int,OTL::FeatureTable const*,BOOL &)>::operator()(uint64_t a1, _DWORD *a2, uint64_t a3, unsigned char *a4)
{
  if (*a2 == 1987212338 || *a2 == 1986359924)
  {
    **(unsigned char **)(a1 + 8)  = 1;
    *a4  = 1;
  }
  return 1;
}

void std::__function::__func<OTL::Lookup::PopulateIgnoreSet(OTL::GDEF const&)::$_0,std::allocator<OTL::Lookup::PopulateIgnoreSet(OTL::GDEF const&)::$_0>,void ()(unsigned short)>::~__func()
{
}

void *std::__function::__func<OTL::Lookup::PopulateIgnoreSet(OTL::GDEF const&)::$_0,std::allocator<OTL::Lookup::PopulateIgnoreSet(OTL::GDEF const&)::$_0>,void ()(unsigned short)>::__clone(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *BOOL result = &unk_1ED061358;
  result[1]  = v3;
  return result;
}

uint64_t std::__function::__func<OTL::Lookup::PopulateIgnoreSet(OTL::GDEF const&)::$_0,std::allocator<OTL::Lookup::PopulateIgnoreSet(OTL::GDEF const&)::$_0>,void ()(unsigned short)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2  = &unk_1ED061358;
  a2[1]  = v2;
  return result;
}

uint64_t std::__function::__func<OTL::Lookup::PopulateIgnoreSet(OTL::GDEF const&)::$_0,std::allocator<OTL::Lookup::PopulateIgnoreSet(OTL::GDEF const&)::$_0>,void ()(unsigned short)>::operator()(uint64_t result, _WORD *a2)
{
  *(unsigned char *)(*(void *)(result + 8) + ((unint64_t)(unsigned __int16)*a2 >> 3)) |= 1 << (*a2 & 7);
  return result;
}

void std::__function::__func<OTL::GCommon::FeatureTableSubstitutionsForFont(OTL::GCommon::Header const*,void const*,TFont const&)::$_0,std::allocator<OTL::GCommon::FeatureTableSubstitutionsForFont(OTL::GCommon::Header const*,void const*,TFont const&)::$_0>,BOOL ()(OTL::ConditionSetTable const*,OTL::FeatureTableSubstitutionTable const*,BOOL &)>::~__func()
{
}

__n128 std::__function::__func<OTL::GCommon::FeatureTableSubstitutionsForFont(OTL::GCommon::Header const*,void const*,TFont const&)::$_0,std::allocator<OTL::GCommon::FeatureTableSubstitutionsForFont(OTL::GCommon::Header const*,void const*,TFont const&)::$_0>,BOOL ()(OTL::ConditionSetTable const*,OTL::FeatureTableSubstitutionTable const*,BOOL &)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v2 = &unk_1ED0613A0;
  *(_OWORD *)(v2 + 8)  = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24)  = result;
  *((void *)v2 + 5)  = *(void *)(a1 + 40);
  return result;
}

__n128 std::__function::__func<OTL::GCommon::FeatureTableSubstitutionsForFont(OTL::GCommon::Header const*,void const*,TFont const&)::$_0,std::allocator<OTL::GCommon::FeatureTableSubstitutionsForFont(OTL::GCommon::Header const*,void const*,TFont const&)::$_0>,BOOL ()(OTL::ConditionSetTable const*,OTL::FeatureTableSubstitutionTable const*,BOOL &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2  = &unk_1ED0613A0;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 40)  = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24)  = v3;
  *(__n128 *)(a2 + 8)  = result;
  return result;
}

uint64_t std::__function::__func<OTL::GCommon::FeatureTableSubstitutionsForFont(OTL::GCommon::Header const*,void const*,TFont const&)::$_0,std::allocator<OTL::GCommon::FeatureTableSubstitutionsForFont(OTL::GCommon::Header const*,void const*,TFont const&)::$_0>,BOOL ()(OTL::ConditionSetTable const*,OTL::FeatureTableSubstitutionTable const*,BOOL &)>::operator()(uint64_t a1, void *a2, uint64_t *a3)
{
  uint64_t v4 = *a3;
  uint64_t v5 = (unsigned int *)(*a2 + 2);
  if (!*(_WORD *)*a2)
  {
LABEL_13:
    if (!*(_WORD *)(v4 + 4)) {
      return 1;
    }
    BOOL v12 = (unsigned __int16 *)(v4 + 6);
    uint64_t v13 = v4 + 6 + 6 * __rev16(*(unsigned __int16 *)(v4 + 4));
    while (1)
    {
      unint64_t v14 = bswap32(*v12) >> 16;
      uint64_t v15 = *(void *)(a1 + 40);
      unint64_t v16 = *(void *)(v15 + 8);
      if (v16)
      {
        uint8x8_t v17 = (uint8x8_t)vcnt_s8((int8x8_t)v16);
        v17.i16[0]  = vaddlv_u8(v17);
        if (v17.u32[0] > 1uLL)
        {
          unint64_t v18 = v14;
          if (v16 <= v14) {
            unint64_t v18 = v14 % v16;
          }
        }
        else
        {
          unint64_t v18 = (v16 - 1) & v14;
        }
        unsigned int v19 = *(uint64_t ****)(*(void *)v15 + 8 * v18);
        if (v19)
        {
          for (uint64_t i = *v19; i; uint64_t i = (uint64_t **)*i)
          {
            unint64_t v21 = (unint64_t)i[1];
            if (v21 == v14)
            {
              if (*((unsigned __int16 *)i + 8) == v14) {
                goto LABEL_82;
              }
            }
            else
            {
              if (v17.u32[0] > 1uLL)
              {
                if (v21 >= v16) {
                  v21 %= v16;
                }
              }
              else
              {
                v21 &= v16 - 1;
              }
              if (v21 != v18) {
                break;
              }
            }
          }
        }
      }
      uint64_t v22 = v4 + bswap32(*(_DWORD *)(v12 + 1));
      unint64_t v23 = **(void **)(a1 + 8);
      unint64_t v24 = v22 + 4;
      if (v22 + 4 > v23) {
        goto LABEL_82;
      }
      uint64_t v25 = bswap32(*(unsigned __int16 *)(v22 + 2)) >> 16;
      unint64_t v26 = v24 + 2 * v25;
      unint64_t v27 = v22 + 6 <= v23 ? (v23 - v24) >> 1 : 0;
      BOOL v28 = v26 <= v23 && v26 >= v24;
      if (!v28 && v27 != v25) {
        goto LABEL_82;
      }
      if (v16)
      {
        uint8x8_t v30 = (uint8x8_t)vcnt_s8((int8x8_t)v16);
        v30.i16[0]  = vaddlv_u8(v30);
        if (v30.u32[0] > 1uLL)
        {
          unint64_t v31 = v14;
          if (v16 <= v14) {
            unint64_t v31 = v14 % v16;
          }
        }
        else
        {
          unint64_t v31 = (v16 - 1) & v14;
        }
        uint64_t v32 = *(uint64_t ****)(*(void *)v15 + 8 * v31);
        if (v32)
        {
          for (uint64_t j = *v32; j; uint64_t j = (uint64_t **)*j)
          {
            unint64_t v34 = (unint64_t)j[1];
            if (v34 == v14)
            {
              if (*((unsigned __int16 *)j + 8) == v14) {
                goto LABEL_82;
              }
            }
            else
            {
              if (v30.u32[0] > 1uLL)
              {
                if (v34 >= v16) {
                  v34 %= v16;
                }
              }
              else
              {
                v34 &= v16 - 1;
              }
              if (v34 != v31) {
                break;
              }
            }
          }
        }
      }
      else
      {
        unint64_t v31 = 0xAAAAAAAAAAAAAAAALL;
      }
      unsigned int v35 = operator new(0x20uLL);
      *unsigned int v35 = 0;
      v35[1]  = v14;
      *((_WORD *)v35 + 8)  = v14;
      v35[3]  = v22;
      float v36 = (float)(unint64_t)(*(void *)(v15 + 24) + 1);
      float v37 = *(float *)(v15 + 32);
      if (!v16 || (float)(v37 * (float)v16) < v36)
      {
        BOOL v38 = (v16 & (v16 - 1)) != 0;
        if (v16 < 3) {
          BOOL v38 = 1;
        }
        unint64_t v39 = v38 | (2 * v16);
        unint64_t v40 = vcvtps_u32_f32(v36 / v37);
        if (v39 <= v40) {
          size_t v41 = v40;
        }
        else {
          size_t v41 = v39;
        }
        std::__hash_table<std::__hash_value_type<unsigned int,OTL::Lookup>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,OTL::Lookup>>>::__rehash<true>(v15, v41);
        unint64_t v16 = *(void *)(v15 + 8);
        if ((v16 & (v16 - 1)) != 0)
        {
          if (v16 <= v14) {
            unint64_t v31 = v14 % v16;
          }
          else {
            unint64_t v31 = v14;
          }
        }
        else
        {
          unint64_t v31 = (v16 - 1) & v14;
        }
      }
      uint64_t v42 = *(void *)v15;
      int v43 = *(void **)(*(void *)v15 + 8 * v31);
      if (v43) {
        break;
      }
      *unsigned int v35 = *(void *)(v15 + 16);
      *(void *)(v15 + 16)  = v35;
      *(void *)(v42 + 8 * v31)  = v15 + 16;
      if (*v35)
      {
        unint64_t v44 = *(void *)(*v35 + 8);
        if ((v16 & (v16 - 1)) != 0)
        {
          if (v44 >= v16) {
            v44 %= v16;
          }
        }
        else
        {
          v44 &= v16 - 1;
        }
        int v43 = (void *)(*(void *)v15 + 8 * v44);
        goto LABEL_80;
      }
LABEL_81:
      ++*(void *)(v15 + 24);
LABEL_82:
      v12 += 3;
      if (v12 == (unsigned __int16 *)v13) {
        return 1;
      }
    }
    *unsigned int v35 = *v43;
LABEL_80:
    void *v43 = v35;
    goto LABEL_81;
  }
  unint64_t v6 = **(void **)(a1 + 8);
  uint64_t v7 = 4 * __rev16(*(unsigned __int16 *)*a2);
  while (1)
  {
    char v8 = (_WORD *)(*a2 + bswap32(*v5));
    if ((unint64_t)(v8 + 1) > v6) {
      return 0;
    }
    if (*v8 == 256)
    {
      if (**(void **)(a1 + 16) > (unint64_t)v8 || (unint64_t)(v8 + 4) > v6) {
        return 0;
      }
      unint64_t v10 = bswap32((unsigned __int16)v8[1]) >> 16;
      if (**(void **)(a1 + 24) <= v10) {
        return 0;
      }
      int v11 = *(__int16 *)(**(void **)(a1 + 32) + 2 * v10);
      if (v11 < (int)bswap32((unsigned __int16)v8[2]) >> 16 || v11 > (int)bswap32((unsigned __int16)v8[3]) >> 16) {
        return 1;
      }
    }
    ++v5;
    v7 -= 4;
    if (!v7) {
      goto LABEL_13;
    }
  }
}

void *std::__function::__value_func<BOOL ()(OTL::ConditionSetTable const*,OTL::FeatureTableSubstitutionTable const*,BOOL &)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t TRunGlue::ReorderGlyphs(uint64_t this)
{
  unint64_t v1 = *(void *)(this + 176);
  uint64_t v2 = *(void *)(this + 32);
  long long v3 = (_WORD *)(v1 + 2 * v2 - 2);
  if (v2) {
    BOOL v4 = (unint64_t)v3 > v1;
  }
  else {
    BOOL v4 = 0;
  }
  if (v4)
  {
    unint64_t v5 = v1 + 2;
    do
    {
      __int16 v6 = *(_WORD *)(v5 - 2);
      *(_WORD *)(v5 - 2)  = *v3;
      *v3--  = v6;
      BOOL v7 = v5 >= (unint64_t)v3;
      v5 += 2;
    }
    while (!v7);
  }
  char v8 = *(uint64_t **)(this + 184);
  unint64_t v9 = (unint64_t)&v8[2 * v2 - 2];
  if (v2) {
    BOOL v10 = v9 > (unint64_t)v8;
  }
  else {
    BOOL v10 = 0;
  }
  if (v10)
  {
    do
    {
      uint64_t v11 = *v8;
      uint64_t v12 = v8[1];
      *(_OWORD *)char v8 = *(_OWORD *)v9;
      v8 += 2;
      *(void *)unint64_t v9 = v11;
      *(void *)(v9 + 8)  = v12;
      v9 -= 16;
    }
    while ((unint64_t)v8 < v9);
    uint64_t v2 = *(void *)(this + 32);
  }
  if (v2)
  {
    uint64_t v13 = *(uint64_t **)(this + 192);
    unint64_t v14 = (unint64_t)&v13[2 * v2 - 2];
    if (v14 > (unint64_t)v13)
    {
      do
      {
        uint64_t v15 = *v13;
        uint64_t v16 = v13[1];
        *(_OWORD *)uint64_t v13 = *(_OWORD *)v14;
        v13 += 2;
        *(void *)unint64_t v14 = v15;
        *(void *)(v14 + 8)  = v16;
        v14 -= 16;
      }
      while ((unint64_t)v13 < v14);
      uint64_t v2 = *(void *)(this + 32);
    }
  }
  unint64_t v17 = *(void *)(this + 520);
  unint64_t v18 = (_DWORD *)(v17 + 4 * v2 - 4);
  if (v2) {
    BOOL v19 = (unint64_t)v18 > v17;
  }
  else {
    BOOL v19 = 0;
  }
  if (v19)
  {
    unint64_t v20 = v17 + 4;
    do
    {
      int v21 = *(_DWORD *)(v20 - 4);
      *(_DWORD *)(v20 - 4)  = *v18;
      *v18--  = v21;
      BOOL v7 = v20 >= (unint64_t)v18;
      v20 += 4;
    }
    while (!v7);
  }
  if (v2)
  {
    unint64_t v22 = *(void *)(this + 528);
    unint64_t v23 = (void *)(v22 + 8 * v2 - 8);
    if ((unint64_t)v23 > v22)
    {
      unint64_t v24 = v22 + 8;
      do
      {
        uint64_t v25 = *(void *)(v24 - 8);
        *(void *)(v24 - 8)  = *v23;
        *v23--  = v25;
        BOOL v7 = v24 >= (unint64_t)v23;
        v24 += 8;
      }
      while (!v7);
    }
  }
  *(_DWORD *)(this + 24)  = -*(_DWORD *)(this + 24);
  return this;
}

void TRunGlue::InitPropertiesForCombining(TRunGlue *this, const TCharStream *a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  *((unsigned char *)this + 593)  = 1;
  TRunGlue::InitPropertiesFromDeletedGlyphs(this);
  uint64_t v8 = 0xAAAAAAAAAAAAAAAALL;
  Chars  = TCharStream::GetChars(a2, *((void *)this + 5), &v8);
  if (Chars)
  {
    *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v5 + 1)  = 0xAAAAAAAAAAAAAAAALL;
    v13[14]  = v5;
    v13[13]  = v5;
    v13[12]  = v5;
    v13[11]  = v5;
    v13[10]  = v5;
    v13[9]  = v5;
    v13[8]  = v5;
    v13[7]  = v5;
    v13[6]  = v5;
    v13[5]  = v5;
    v13[3]  = v5;
    v13[4]  = v5;
    v13[1]  = v5;
    v13[2]  = v5;
    v13[0]  = v5;
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    unint64_t v9 = (void **)&v10;
    BOOL v10 = 0;
    unint64_t v14 = v13;
    uint64_t v6 = -1;
    uint64_t v7 = -1;
    TUnicodeEncoder::EncodePortion((char ***)&v9, 0, Chars, v8, *(void *)(*((void *)this + 77) + 400), 0, *((void *)this + 22), *((void *)this + 23), 2, *((void *)this + 65), (double *)&v7, 0);
    if (v10 != v11)
    {
      TRunGlue::FilterSurrogates(this, (uint64_t)a2, &v10);
      uint64_t v6 = 1;
    }
    *((void *)this + 75)  = v6;
    unint64_t v9 = (void **)&v10;
    std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](&v9);
  }
}

uint64_t TCharStream::GetChars(TCharStream *this, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = *((void *)this + 1);
  uint64_t v3 = *((void *)this + 2);
  uint64_t v5 = v3 + v4;
  BOOL v9 = __OFSUB__(a2, v4);
  uint64_t v6 = a2 - v4;
  if (v6 < 0 != v9)
  {
    BOOL v9 = 0;
    BOOL v7 = 1;
    BOOL v8 = 0;
  }
  else
  {
    BOOL v9 = __OFSUB__(v5, a2);
    BOOL v7 = v5 == a2;
    BOOL v8 = v5 - a2 < 0;
  }
  if (v8 ^ v9 | v7) {
    return 0;
  }
  uint64_t v10 = *((void *)this + 3);
  if (!v10) {
    return (*(uint64_t (**)(void))(*(void *)this + 64))();
  }
  *a3  = v3 - v6;
  return v10 + 2 * v6;
}

BOOL TRunGlue::FilterSurrogates(TRunGlue *this, uint64_t a2, const uint64_t **a3)
{
  uint64_t v65 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *((void *)this + 75);
  if (!v3)
  {
    uint64_t v5 = a3;
    *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v7 + 1)  = 0xAAAAAAAAAAAAAAAALL;
    v63[14]  = v7;
    v63[13]  = v7;
    v63[12]  = v7;
    v63[11]  = v7;
    v63[10]  = v7;
    v63[9]  = v7;
    v63[8]  = v7;
    v63[7]  = v7;
    v63[6]  = v7;
    v63[5]  = v7;
    v63[4]  = v7;
    v63[3]  = v7;
    v63[2]  = v7;
    v63[1]  = v7;
    v63[0]  = v7;
    int v60 = 0;
    CFIndex v61 = 0;
    CFIndex v62 = 0;
    unint64_t v64 = v63;
    if (a3)
    {
      if (*a3 == a3[1]) {
        goto LABEL_38;
      }
    }
    else
    {
      long long v53 = 0u;
      long long v50 = 0u;
      *(_OWORD *)unint64_t v51 = 0u;
      memset(v52, 0, sizeof(v52));
      uint64_t v8 = *(void *)(a2 + 16);
      uint64_t v54 = 0;
      *(void *)&long long v53 = v8;
      uint64_t v9 = *((void *)this + 5);
      uint64_t v10 = *((void *)this + 6);
      uint64_t v48 = v9;
      unint64_t v49 = (TRunGlue **)a2;
      if (v10 < 1)
      {
LABEL_38:
        uint64_t v4 = 0;
LABEL_59:
        unint64_t v49 = &v60;
        std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v49);
        return v4;
      }
      char v11 = 0;
      uint64_t v12 = v10 + v9;
      do
      {
        while (1)
        {
          int FullChar = TCharStreamIterator::GetFullChar((TCharStreamIterator *)&v49, &v48, 0);
          uint64_t v14 = v48;
          if ((FullChar - 0x10000) >> 20 || v48 >= v12) {
            break;
          }
          uint64_t v16 = v61;
          if (v61 >= v62)
          {
            unint64_t v18 = v60;
            uint64_t v19 = ((char *)v61 - (char *)v60) >> 3;
            unint64_t v20 = v19 + 1;
            if ((unint64_t)(v19 + 1) >> 61) {
              abort();
            }
            uint64_t v21 = (char *)v62 - (char *)v60;
            if (((char *)v62 - (char *)v60) >> 2 > v20) {
              unint64_t v20 = v21 >> 2;
            }
            if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v22 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v22 = v20;
            }
            CFIndex v59 = v63;
            if (v22)
            {
              unint64_t v23 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v63, v22);
              unint64_t v18 = v60;
              uint64_t v16 = v61;
            }
            else
            {
              unint64_t v23 = 0;
            }
            unint64_t v24 = (uint64_t *)&v23[8 * v19];
            uint64_t *v24 = v14;
            if (v16 == (uint64_t *)v18)
            {
              unint64_t v26 = &v23[8 * v19];
            }
            else
            {
              uint64_t v25 = (TRunGlue *)v16;
              unint64_t v26 = &v23[8 * v19];
              do
              {
                uint64_t v27 = *((void *)v25 - 1);
                uint64_t v25 = (TRunGlue *)((char *)v25 - 8);
                *((void *)v26 - 1)  = v27;
                v26 -= 8;
              }
              while (v25 != v18);
              uint64_t v14 = v48;
            }
            unint64_t v17 = v24 + 1;
            int v60 = (TRunGlue *)v26;
            CFIndex v61 = v24 + 1;
            BOOL v28 = v62;
            CFIndex v62 = (uint64_t *)&v23[8 * v22];
            uint64_t v57 = (uint64_t)v16;
            uint64_t v58 = (uint64_t)v28;
            uint64_t v55 = v18;
            uint64_t v56 = (uint64_t)v18;
            std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v55);
          }
          else
          {
            uint64_t *v61 = v48;
            unint64_t v17 = v16 + 1;
          }
          CFIndex v61 = v17;
          uint64_t v48 = v14 + 1;
          char v11 = 1;
          if (v14 + 1 >= v12) {
            goto LABEL_34;
          }
        }
        ++v48;
      }
      while (v14 + 1 < v12);
      if ((v11 & 1) == 0) {
        goto LABEL_38;
      }
LABEL_34:
      uint64_t v5 = (const uint64_t **)&v60;
    }
    if (*((void *)this + 19))
    {
      uint64_t v29 = (uint64_t)(*(void *)(*(void *)this + 24) - *(void *)(*(void *)this + 16)) >> 3;
      TLine::DeleteChars(*(void *)this, v5[1] - *v5, *v5);
      uint64_t v30 = *(void *)(*(void *)this + 24) - *(void *)(*(void *)this + 16);
      if (v29 == v30 >> 3)
      {
        *((void *)this + 21)  = *(void *)(*((void *)this + 19) + 208) + *((void *)this + 20);
        TRunGlue::ComputeEndIndex(this);
      }
      else
      {
        uint64_t v36 = v29 - (v30 >> 3);
        v66.CFIndex location = *((void *)this + 1);
        v66.CFIndex length = *((void *)this + 2) - v36;
        *((void *)this + 18) -= v36;
        TRunGlue::SetRunRange(this, v66);
      }
    }
    else
    {
      uint64_t v31 = *((void *)this + 66);
      uint64_t v32 = *v5;
      uint64_t v33 = *((void *)this + 4);
      if (v33)
      {
        uint64_t v34 = 8 * v33;
        unsigned int v35 = (void *)*((void *)this + 66);
        while (*v35 != *v32)
        {
          ++v35;
          v34 -= 8;
          if (!v34)
          {
            unsigned int v35 = (void *)(v31 + 8 * v33);
            break;
          }
        }
      }
      else
      {
        unsigned int v35 = (void *)*((void *)this + 66);
      }
      uint64_t v37 = ((uint64_t)v35 - v31) >> 3;
      if (v37 < v33)
      {
        BOOL v38 = v5[1];
        uint64_t v47 = v31 + 8 * *((void *)this + 20);
        uint64_t v39 = v37;
        uint64_t v40 = ((uint64_t)v35 - v31) >> 3;
        do
        {
          if (v32 == v38)
          {
            uint64_t v32 = v38;
          }
          else if (*(void *)(v47 + 8 * v40) == *v32)
          {
            if (++v40 >= v33) {
              break;
            }
            ++v32;
          }
          uint64_t v55 = this;
          uint64_t v56 = v40;
          uint64_t v41 = *((void *)this + 20);
          uint64_t v43 = *((void *)this + 23) + 16 * v41;
          uint64_t v57 = *((void *)this + 22) + 2 * v41;
          uint64_t v42 = v57;
          uint64_t v58 = v43;
          CFIndex v59 = (_OWORD *)(*((void *)this + 24) + 16 * v41);
          unint64_t v44 = v59;
          TRunGlue::TGlyphInVector::operator TStorageRange::GlyphEntry((uint64_t)&v49, (uint64_t)&v55);
          *(_WORD *)(v42 + 2 * v37)  = (_WORD)v49;
          *(_OWORD *)(v43 + v39 * 16)  = v50;
          TRunGlue::SetGlyphProps(this, v37, v51[0]);
          TRunGlue::SetStringIndex(this, v37, *(uint64_t *)&v51[2]);
          v44[v39]  = *(_OWORD *)((char *)v52 + 8);
          ++v40;
          ++v37;
          uint64_t v33 = *((void *)this + 4);
          ++v39;
        }
        while (v40 < v33);
      }
      while (v37 < v33)
      {
        TRunGlue::SetStringIndex(this, v37, -1);
        TRunGlue::Delete(this, v37++, 0);
        uint64_t v33 = *((void *)this + 4);
      }
      uint64_t v45 = (char *)v5[1] - (char *)*v5;
      std::function<BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::operator()(*((void *)this + 73), *((void *)this + 20) + v33, -(v45 >> 3), (uint64_t)this + 176, (uint64_t)this + 184, (uint64_t)this + 192, (uint64_t)this + 528);
      *((void *)this + 4) -= v45 >> 3;
      *((void *)this + 21) -= v45 >> 3;
    }
    uint64_t v4 = 1;
    goto LABEL_59;
  }
  return v3 > 0;
}

TLine *TRunGlue::GetMappedCharsInRange(uint64_t a1, uint64_t a2, uint64_t a3, char **a4)
{
  __n128 result = *(TLine **)a1;
  if (result)
  {
    return (TLine *)TLine::GetMappedCharsInRange(result, a2, a3, a4);
  }
  else
  {
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8 >= 1)
    {
      uint64_t v9 = 0;
      uint64_t v10 = *(void *)(a1 + 160);
      uint64_t v11 = *(void *)(a1 + 528) + 8 * v10;
      uint64_t v12 = *(void *)(a1 + 520) + 4 * v10;
      uint64_t v13 = a2 + a3;
      while (1)
      {
        uint64_t v14 = *(void *)(v11 + 8 * v9);
        if (v14 >= a2) {
          break;
        }
        if (v8 == ++v9) {
          return result;
        }
      }
      if (v14 < v13)
      {
        __n128 result = (TLine *)(a4 + 3);
        uint64_t v29 = (TLine *)(a4 + 3);
        do
        {
          if ((*(_DWORD *)(v12 + 4 * v9) & 0x20) == 0 && a2 <= v14)
          {
            uint64_t v16 = (uint64_t *)*a4;
            uint64_t v15 = (uint64_t *)a4[1];
            if (*a4 == (char *)v15 || v14 != *(v15 - 1))
            {
              unint64_t v17 = (unint64_t)a4[2];
              if ((unint64_t)v15 >= v17)
              {
                uint64_t v19 = v15 - v16;
                unint64_t v20 = v19 + 1;
                if ((unint64_t)(v19 + 1) >> 61) {
                  abort();
                }
                uint64_t v21 = v17 - (void)v16;
                if (v21 >> 2 > v20) {
                  unint64_t v20 = v21 >> 2;
                }
                if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v22 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v22 = v20;
                }
                v30[4]  = result;
                if (v22)
                {
                  unint64_t v23 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)result, v22);
                  uint64_t v16 = (uint64_t *)*a4;
                  uint64_t v15 = (uint64_t *)a4[1];
                }
                else
                {
                  unint64_t v23 = 0;
                }
                unint64_t v24 = (uint64_t *)&v23[8 * v19];
                uint64_t *v24 = v14;
                if (v15 == v16)
                {
                  unint64_t v26 = &v23[8 * v19];
                }
                else
                {
                  uint64_t v25 = v15;
                  unint64_t v26 = &v23[8 * v19];
                  do
                  {
                    uint64_t v27 = *--v25;
                    *((void *)v26 - 1)  = v27;
                    v26 -= 8;
                  }
                  while (v25 != v16);
                }
                unint64_t v18 = (char *)(v24 + 1);
                *a4  = v26;
                a4[1]  = (char *)(v24 + 1);
                BOOL v28 = a4[2];
                a4[2]  = &v23[8 * v22];
                v30[2]  = v15;
                void v30[3] = v28;
                v30[0]  = v16;
                v30[1]  = v16;
                std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)v30);
                __n128 result = v29;
              }
              else
              {
                *uint64_t v15 = v14;
                unint64_t v18 = (char *)(v15 + 1);
              }
              a4[1]  = v18;
              uint64_t v8 = *(void *)(a1 + 32);
            }
          }
          if (++v9 >= v8) {
            break;
          }
          uint64_t v14 = *(void *)(v11 + 8 * v9);
        }
        while (v14 < v13);
      }
    }
  }
  return result;
}

uint64_t TRunGlue::GetFontForCharIndex(TLine **this, uint64_t a2)
{
  uint64_t v2 = *this;
  if (!*this)
  {
    uint64_t v3 = (char *)(this + 77);
    return *(void *)v3;
  }
  if (*((void *)v2 + 3) != *((void *)v2 + 2))
  {
    uint64_t v3 = (char *)(atomic_load_explicit((atomic_ullong *volatile)(*(void *)(*(void *)(*((void *)v2 + 2)+ 8 * TLine::FindRunWithCharIndex(*this, a2, 1))+ 40)+ 56), memory_order_acquire)+ 40);
    return *(void *)v3;
  }
  return 0;
}

uint64_t TRunGlue::GetGlyphIDForCharIndex(TRunGlue *this, uint64_t a2)
{
  uint64_t v4 = *(TLine **)this;
  if (v4)
  {
    uint64_t RunWithCharIndex = TLine::FindRunWithCharIndex(v4, a2, 1);
    uint64_t v6 = *(void *)(*(void *)this + 16);
    if (RunWithCharIndex < (*(void *)(*(void *)this + 24) - v6) >> 3)
    {
      uint64_t v7 = *(void *)(*(void *)(v6 + 8 * RunWithCharIndex) + 40);
      uint64_t i = (unsigned __int16 *)(*(void *)(*(void *)(v7 + 216) + 16)
                             + 2 * *(void *)(v7 + 200)
                             + 2 * TRun::GetGlyphIndexForCharIndex<false>(v7, a2));
      return *i;
    }
  }
  else
  {
    uint64_t v10 = *((void *)this + 4);
    if (v10 >= 1)
    {
      uint64_t v11 = *((void *)this + 20);
      uint64_t v12 = (uint64_t *)(*((void *)this + 66) + 8 * v11);
      for (uint64_t i = (unsigned __int16 *)(*((void *)this + 22) + 2 * v11); ; ++i)
      {
        uint64_t v13 = *v12++;
        if (v13 >= a2) {
          break;
        }
        if (!--v10) {
          return 0;
        }
      }
      return *i;
    }
  }
  return 0;
}

uint64_t TRunGlue::ReplaceCharRangeWithGlyphs(TRunGlue *this, uint64_t a2, uint64_t a3, void *a4, _WORD **a5, uint64_t a6)
{
  if (*(void *)this) {
    return 0;
  }
  uint64_t v7 = this;
  uint64_t v8 = *((void *)this + 4);
  if (v8 < 1) {
    return 0;
  }
  uint64_t v9 = a2;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  uint64_t v14 = *((void *)this + 20);
  uint64_t v15 = *((void *)this + 22) + 2 * v14;
  uint64_t v16 = *((void *)this + 65) + 4 * v14;
  uint64_t v17 = *((void *)this + 66);
  uint64_t v18 = v17 + 8 * v14;
  uint64_t v19 = 1 - a3;
  uint64_t v20 = 8;
  uint64_t v21 = 4;
  uint64_t v22 = 2;
  while (*(void *)(v18 + 8 * v13) < a2)
  {
    ++v13;
    ++v19;
    v12 += 8;
    v11 += 4;
    v10 += 2;
    v20 += 8;
    v21 += 4;
    v22 += 2;
    if (v13 == v8) {
      return 0;
    }
  }
  unint64_t v23 = (uint64_t *)(v17 + 8 * v13);
  if (v13 == v8)
  {
    unint64_t v24 = (void *)(v17 + 8 * v13);
LABEL_13:
    if (v24 != (void *)(v17 + 8 * v8)) {
      return 0;
    }
  }
  else
  {
    uint64_t v25 = 8 * v8;
    while (v20 != v25)
    {
      unint64_t v24 = v23 + 1;
      uint64_t v27 = *v23;
      uint64_t v26 = v23[1];
      v25 -= 8;
      ++v23;
      if (v26 < v27) {
        goto LABEL_13;
      }
    }
  }
  uint64_t v28 = a4[1] - *a4;
  uint64_t v29 = a3 - (v28 >> 1);
  if (v29 >= 1)
  {
    uint64_t v30 = 0;
    uint64_t v31 = 1;
    if ((*(_WORD *)*a4 & 0xF800) == 0xD800) {
      uint64_t v31 = 2;
    }
    uint64_t v32 = v31 + a2;
    uint64_t v33 = v13;
    do
    {
      uint64_t v34 = *((void *)v7 + 4);
      if (v33 >= v34) {
        return 0;
      }
      uint64_t v35 = v32 + v30;
      while (*(void *)(v18 + 8 * v33) < v35)
      {
        if (v34 == ++v33) {
          return 0;
        }
      }
      uint64_t v84 = v32;
      uint64_t v85 = v30;
      uint64_t v103 = v29;
      uint64_t v106 = v28;
      uint64_t v86 = v15;
      uint64_t v92 = v16;
      uint64_t v101 = a3;
      double v111 = a5;
      uint64_t v95 = v7;
      uint64_t v99 = a6;
      uint64_t v108 = v9;
      uint64_t v90 = v18;
      TRunGlue::Delete(v7, v33, 0);
      uint64_t v18 = v90;
      a6  = v99;
      uint64_t v9 = v108;
      if (v99) {
        *(void *)(v90 + 8 * v13)  = *(void *)(v99 + 8 * (v35 - v108)) + v108;
      }
      uint64_t v15 = v86;
      uint64_t v30 = v85 + 1;
      a3  = v101;
      uint64_t v29 = v103;
      uint64_t v16 = v92;
      uint64_t v7 = v95;
      a5  = v111;
      uint64_t v28 = v106;
      uint64_t v32 = v84;
    }
    while (v85 + 1 != v103);
  }
  uint64_t v36 = v28 >> 1;
  if (v28 >> 1 <= a3)
  {
    uint64_t v51 = 0;
    uint64_t v52 = v9;
    uint64_t v50 = v13;
  }
  else
  {
    uint64_t v104 = v29;
    uint64_t v107 = v28;
    uint64_t v87 = v28 >> 1;
    uint64_t v102 = a3;
    int v96 = *(_DWORD *)(v16 + 4 * v13);
    int v112 = a5;
    uint64_t v37 = *a5 + 1;
    *(_WORD *)(v15 + 2 * v13)  = **a5;
    uint64_t v109 = v9;
    uint64_t v93 = (v28 >> 1) - a3;
    BOOL v38 = v7;
    uint64_t v39 = a6;
    TRunGlue::DoGlyphInsertion(v7, v37, (unsigned __int16)((v28 >> 1) - a3), 0, 1, v13, v13, 0, 0);
    a6  = v39;
    uint64_t v9 = v109;
    uint64_t v7 = v38;
    uint64_t v40 = *((void *)v38 + 22);
    uint64_t v41 = *((void *)v38 + 20);
    uint64_t v42 = *((void *)v38 + 65);
    uint64_t v16 = v42 + 4 * v41;
    uint64_t v43 = *((void *)v38 + 66);
    uint64_t v18 = v43 + 8 * v41;
    *(_DWORD *)(v16 + 4 * v13) |= 0x80u;
    *(void *)(v18 + 8 * v13)  = v109;
    if (v39)
    {
      if (v107 < 3)
      {
        uint64_t v50 = v13 + 1;
      }
      else
      {
        uint64_t v44 = 0;
        uint64_t v45 = v43 + 8 * v41 + v20;
        uint64_t v46 = v42 + 4 * v41 + v21;
        uint64_t v47 = v40 + 2 * v41 + v22;
        uint64_t v48 = *v112 + 2;
        do
        {
          *(_WORD *)(v47 + 2 * v44)  = *(_WORD *)(v48 + 2 * v44);
          uint64_t v49 = *(void *)(v39 + 8 + 8 * v44);
          *(_DWORD *)(v46 + 4 * v44)  = v96 | ((v49 == 0) << 9) | 0x40;
          *(void *)(v45 + 8 * v44++)  = v49 + v109;
          uint64_t v50 = v13 + v44 + 1;
        }
        while (v50 < v87 + v13);
      }
      goto LABEL_71;
    }
    uint64_t v15 = v40 + 2 * v41;
    uint64_t v50 = v13 + 1;
    uint64_t v36 = v87;
    if (v13 + 1 >= v93 + v13 + 1)
    {
      uint64_t v51 = 1;
      a5  = (_WORD **)v112;
      a3  = v102;
    }
    else
    {
      a5  = (_WORD **)v112;
      long long v53 = (_WORD *)*v112;
      uint64_t v50 = v87 + v19;
      uint64_t v54 = v43 + 8 * v41 + v12;
      uint64_t v55 = v42 + 4 * v41 + v11;
      uint64_t v56 = v40 + 2 * v41 + v10;
      uint64_t v51 = 1;
      a3  = v102;
      do
      {
        *(_WORD *)(v56 + 2 * v51)  = v53[v51];
        *(_DWORD *)(v55 + 4 * v51)  = v96 | 0x240;
        *(void *)(v54 + 8 * v51++)  = v109;
      }
      while (v104 + v51 != 1);
    }
    uint64_t v29 = 0;
    uint64_t v52 = v109 + 1;
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB2CE388, memory_order_acquire) & 1) == 0)
  {
    double v98 = v7;
    uint64_t v110 = v9;
    uint64_t v76 = a6;
    double v77 = a5;
    uint64_t v78 = a3;
    uint64_t v79 = v16;
    uint64_t v80 = v15;
    uint64_t v81 = v18;
    uint64_t v105 = v29;
    uint64_t v89 = v36;
    int v82 = __cxa_guard_acquire(&qword_1EB2CE388);
    uint64_t v36 = v89;
    uint64_t v29 = v105;
    uint64_t v18 = v81;
    uint64_t v15 = v80;
    uint64_t v16 = v79;
    a3  = v78;
    a5  = v77;
    a6  = v76;
    uint64_t v9 = v110;
    uint64_t v7 = v98;
    if (v82)
    {
      _MergedGlobals_20  = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetNonBase);
      __cxa_guard_release(&qword_1EB2CE388);
      uint64_t v36 = v89;
      uint64_t v29 = v105;
      uint64_t v18 = v81;
      uint64_t v15 = v80;
      uint64_t v16 = v79;
      a3  = v78;
      a5  = v77;
      a6  = v76;
      uint64_t v9 = v110;
      uint64_t v7 = v98;
    }
  }
  uint64_t v57 = v9 + a3;
  if (v52 < v9 + a3)
  {
    uint64_t v58 = &qword_1EB2CE000;
    do
    {
      uint64_t v59 = *((void *)v7 + 4);
      if (v50 >= v59) {
        return 0;
      }
      uint64_t v60 = v51;
      while (*(void *)(v18 + 8 * v50) < v52)
      {
        uint64_t result = 0;
        if (v59 == ++v50) {
          return result;
        }
      }
      *(_WORD *)(v15 + 2 * v50)  = (*a5)[v51++];
      UTF32Char v61 = *(unsigned __int16 *)(*a4 + 2 * v60);
      BOOL v62 = (v61 & 0xFC00) != 0xD800 || v51 == v36;
      uint64_t v100 = a6;
      if (!v62)
      {
        int v63 = *(unsigned __int16 *)(*a4 + 2 * v51);
        BOOL v64 = (v63 & 0xFC00) == 56320;
        int v65 = v63 + (v61 << 10) - 56613888;
        uint64_t v51 = v64 ? v60 + 2 : v60 + 1;
        if (v64) {
          UTF32Char v61 = v65;
        }
      }
      CFCharacterSetRef v66 = (const __CFCharacterSet *)v58[112];
      if (!v66) {
        goto LABEL_61;
      }
      long long v97 = v7;
      uint64_t v67 = v9;
      double v113 = a5;
      uint64_t v68 = a3;
      uint64_t v91 = v18;
      uint64_t v94 = v16;
      uint64_t v69 = v15;
      uint64_t v70 = v29;
      uint64_t v88 = v36;
      IsLongCharacterMember  = CFCharacterSetIsLongCharacterMember(v66, v61);
      uint64_t v58 = &qword_1EB2CE000;
      uint64_t v36 = v88;
      uint64_t v18 = v91;
      uint64_t v29 = v70;
      uint64_t v15 = v69;
      uint64_t v16 = v94;
      uint64_t v7 = v97;
      a3  = v68;
      a5  = v113;
      uint64_t v9 = v67;
      if (IsLongCharacterMember)
      {
        unsigned int v72 = *(_DWORD *)(v94 + 4 * v50) | 0x40;
      }
      else
      {
LABEL_61:
        int v73 = *(_DWORD *)(v16 + 4 * v50);
        if ((v73 & 0x40) == 0) {
          goto LABEL_64;
        }
        unsigned int v72 = v73 & 0xFFFFFFBF;
      }
      *(_DWORD *)(v16 + 4 * v50)  = v72;
LABEL_64:
      a6  = v100;
      if (v100)
      {
        uint64_t v74 = *(void *)(v100 + 8 * (v52 - v9));
        if (a3 > v74 && (v74 & 0x8000000000000000) == 0)
        {
          uint64_t v75 = v74 + v9;
          if (v75 != v52) {
            *(void *)(v18 + 8 * v50)  = v75;
          }
        }
      }
      ++v50;
      uint64_t v52 = v52 - v60 + v29 + v51;
      uint64_t v29 = 0;
    }
    while (v52 < v57);
  }
  uint64_t v40 = *((void *)v7 + 22);
LABEL_71:
  TFont::GetUnsummedAdvancesForGlyphs(*((void *)v7 + 77), v40 + 2 * v13, (double *)(*((void *)v7 + 23) + 16 * v13), 2, v50 - v13, 0, 0);
  return 1;
}

uint64_t TRunGlue::DoGlyphInsertion(TRunGlue *this, const unsigned __int16 *a2, unsigned int a3, int a4, int a5, uint64_t a6, uint64_t a7, char a8, BOOL *a9)
{
  uint64_t v72 = *MEMORY[0x1E4F143B8];
  if (*((void *)this + 19))
  {
    if (a7 < 0) {
      return 0;
    }
LABEL_6:
    TRunGlue::FocusOnIndex(this, a7);
    uint64_t v16 = TRunGlue::length(this);
    if (v16 - 1 >= a7) {
      uint64_t v17 = a7;
    }
    else {
      uint64_t v17 = v16 - 1;
    }
    StringIndedouble x = TRunGlue::GetStringIndex(this, v17);
    GlyphProps  = TRunGlue::GetGlyphProps(this, v17);
    unsigned int v20 = GlyphProps & 0xFFFFEF37;
    if ((GlyphProps & 0x300) == 0) {
      TRunGlue::SetGlyphProps(this, v17, v20 | 0x80);
    }
    if (a5) {
      int v21 = 256;
    }
    else {
      int v21 = 512;
    }
    TRunGlue::FocusOnIndex(this, a6);
    uint64_t v62 = a6;
    uint64_t v22 = (a4 ^ 1u) + a6;
    if (v22 < 0 || *((void *)this + 21) < v22)
    {
      if (a9)
      {
        uint64_t result = 0;
        *a9  = 1;
        return result;
      }
      return 0;
    }
    uint64_t v23 = *((void *)this + 19);
    if (v23)
    {
      if (v23 != *((void *)this + 67))
      {
        TStorageRange::DetachStorageIfShared((TStorageRange *)(v23 + 192));
        uint64_t v23 = *((void *)this + 19);
        *((void *)this + 67)  = v23;
      }
      if (v22 - *((void *)this + 20) < 0) {
        v24.CFIndex location = 0;
      }
      else {
        v24.CFIndex location = v22 - *((void *)this + 20);
      }
      v24.CFIndex length = a3;
      TStorageRange::InsertGlyphs((id *)(v23 + 192), v24);
    }
    else
    {
      uint64_t result = std::function<BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::operator()(*((void *)this + 73), *((void *)this + 20) + v22, a3, (uint64_t)this + 176, (uint64_t)this + 184, (uint64_t)this + 192, (uint64_t)this + 528);
      if (!result) {
        return result;
      }
      if (*((void *)this + 65))
      {
        uint64_t v33 = *((void *)this + 46);
        if (v33 != *((void *)this + 47))
        {
          LODWORD(v66)  = 0;
          std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::insert((uint64_t *)this + 46, (char *)(v33 + 4 * v22), a3, (char *)&v66);
          *((void *)this + 65)  = *((void *)this + 46);
        }
      }
      else
      {
        uint64_t v47 = TRunGlue::length(this);
        uint64_t v48 = a3 + v47 + 14;
        if (a3 + v47 + 7 >= 0) {
          uint64_t v48 = a3 + v47 + 7;
        }
        std::vector<unsigned char,TInlineBufferAllocator<unsigned char,128ul>>::resize((void *)this + 26, v48 >> 3);
        uint64_t v49 = TRunGlue::length(this);
        uint64_t v50 = v22 + a3;
        if (v49 >= v50)
        {
          do
          {
            uint64_t v51 = v49 + *((void *)this + 20);
            uint64_t v52 = v51 + 1;
            uint64_t v53 = v51 + 7;
            if (v51 >= 0) {
              uint64_t v53 = v49 + *((void *)this + 20);
            }
            uint64_t v54 = v53 >> 3;
            uint64_t v55 = *((void *)this + 26);
            char v56 = v51 & 7;
            int v57 = 1 << (v52 & 7);
            uint64_t v58 = v52 / 8;
            if ((*(unsigned __int8 *)(v55 + v54) >> v56)) {
              char v59 = *(unsigned char *)(v55 + v58) | v57;
            }
            else {
              char v59 = *(unsigned char *)(v55 + v58) & ~(_BYTE)v57;
            }
            *(unsigned char *)(v55 + v58)  = v59;
          }
          while (v49-- > v50);
        }
        if (a3)
        {
          uint64_t v61 = v22;
          do
          {
            *(unsigned char *)(*((void *)this + 26) + (v61 + *((void *)this + 20)) / 8) &= ~(1 << ((v61
                                                                                              + *((unsigned char *)this + 160)) & 7));
            ++v61;
          }
          while (v61 < v50);
        }
      }
    }
    TRunGlue::InsertedGlyphs(this, a3);
    uint64_t v25 = *((void *)this + 13);
    if (v25)
    {
      uint64_t v26 = *(char **)v25;
      uint64_t v27 = *(void *)(v25 + 8);
      if (*(void *)v25 != v27 && v22 <= (v27 - (uint64_t)v26) >> 4) {
        std::vector<TGlyphAuxDataListEntry,TInlineBufferAllocator<TGlyphAuxDataListEntry,30ul>>::insert((char **)v25, (uint64_t)&v26[16 * v22], a3, &v26[16 * v17]);
      }
    }
    *(void *)&long long v28 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v28 + 1)  = 0xAAAAAAAAAAAAAAAALL;
    v69[5]  = v28;
    v69[6]  = v28;
    v69[3]  = v28;
    v69[4]  = v28;
    v69[1]  = v28;
    double v69[2] = v28;
    v69[0]  = v28;
    uint64_t v67 = 0;
    uint64_t v68 = 0;
    unint64_t v66 = 0;
    unint64_t v70 = 0xAAAAAAAAAAAAAAAALL;
    double v71 = v69;
    if (a3)
    {
      int v29 = v20 | v21;
      std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__vallocate[abi:nn180100](&v66, a3);
      uint64_t v30 = v67;
      uint64_t v31 = &v67[a3];
      uint64_t v32 = 4 * a3;
      do
      {
        *v30++  = v29;
        v32 -= 4;
      }
      while (v32);
      uint64_t v67 = v31;
    }
    else
    {
      uint64_t v31 = 0;
    }
    if (!(GlyphProps >> 29) && (a8 & 1) == 0)
    {
      unint64_t v34 = v66;
      if ((int *)v66 != v31)
      {
        int v35 = 0x1000000;
        unint64_t v36 = v66;
        do
        {
          *(unsigned char *)(v36 + 3)  = HIBYTE(v35) & 0xF;
          v36 += 4;
          v35 += 0x1000000;
        }
        while ((int *)v36 != v31);
      }
      if ((*((_DWORD *)this + 6) & 0x80000000) != 0 && (int *)v34 != v31)
      {
        uint64_t v37 = v31 - 1;
        if ((unint64_t)v37 > v34)
        {
          unint64_t v38 = v34 + 4;
          do
          {
            int v39 = *(_DWORD *)(v38 - 4);
            *(_DWORD *)(v38 - 4)  = *v37;
            *v37--  = v39;
            BOOL v40 = v38 >= (unint64_t)v37;
            v38 += 4;
          }
          while (!v40);
        }
      }
    }
    if (a3)
    {
      uint64_t v41 = 0;
      uint64_t v42 = (CGPoint *)MEMORY[0x1E4F1DAD8];
      do
      {
        TRunGlue::SetGlyphProps(this, v22 + v41, *(unsigned int *)(v66 + 4 * v41));
        TRunGlue::SetOrigin(this, v22 + v41, *v42);
        TRunGlue::SetStringIndex(this, v22 + v41, StringIndex);
        TRunGlue::SetAttachmentCount(this, v22 + v41, 0);
        uint64_t v43 = a2[v41];
        TRunGlue::SetGlyphID<true>(this, v22 + v41, v43);
        uint64_t v44 = *((void *)this + 25);
        if (v44)
        {
          if (*((void *)this + 78) > v43) {
            *(unsigned char *)(v44 + ((unint64_t)v43 >> 3)) |= 1 << (v43 & 7);
          }
        }
        ++v41;
      }
      while (a3 != v41);
    }
    uint64_t v45 = *((void *)this + 19);
    if (!v45) {
      goto LABEL_62;
    }
    if (a7 == v62)
    {
      if (*(int *)(v45 + 256) > 1)
      {
LABEL_62:
        int v65 = (void **)&v66;
        std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100](&v65);
        return 1;
      }
      int v46 = 1;
    }
    else
    {
      int v46 = 2;
    }
    *(_DWORD *)(v45 + 256)  = v46;
    goto LABEL_62;
  }
  uint64_t result = 0;
  if ((a7 & 0x8000000000000000) == 0 && *((void *)this + 73)) {
    goto LABEL_6;
  }
  return result;
}

void TRunGlue::Rotate(TRunGlue *this, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  v182[2]  = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a3 - a2;
  if (a3 < a2) {
    return;
  }
  uint64_t v6 = a3;
  uint64_t v7 = a4 - a3;
  if (a4 <= a3) {
    return;
  }
  uint64_t v8 = a2;
  uint64_t v10 = a4;
  if (a5 && a3 != a2 && a4 != a3)
  {
    uint64_t v11 = (char *)(*a5 + 16 * a2);
    uint64_t v12 = (char *)(*a5 + 16 * a3);
    uint64_t v13 = *a5 + 16 * a4;
    if (v11 + 16 == v12)
    {
      uint64_t v20 = *(void *)v11;
      uint64_t v21 = *((void *)v11 + 1);
      uint64_t v22 = v13 - (void)v12;
      memmove((void *)(*a5 + 16 * v8), v12, v13 - (void)v12);
      v11 += v22;
    }
    else
    {
      if (v12 + 16 != (char *)v13)
      {
        uint64_t v14 = (v12 - v11) >> 4;
        if (v14 == (v13 - (uint64_t)v12) >> 4)
        {
          uint64_t v15 = 0;
          do
          {
            uint64_t v16 = &v12[v15];
            uint64_t v17 = *(void *)&v11[v15];
            uint64_t v18 = *(void *)&v11[v15 + 8];
            *(_OWORD *)&v11[v15]  = *(_OWORD *)&v12[v15];
            *(void *)uint64_t v16 = v17;
            *((void *)v16 + 1)  = v18;
            if (16 * a3 - 16 * v8 - 16 == v15) {
              break;
            }
            BOOL v19 = 16 * a4 - 16 * a3 - 16 == v15;
            v15 += 16;
          }
          while (!v19);
        }
        else
        {
          uint64_t v82 = (v13 - (uint64_t)v12) >> 4;
          uint64_t v83 = (v12 - v11) >> 4;
          do
          {
            uint64_t v84 = v83;
            uint64_t v83 = v82;
            uint64_t v82 = v84 % v82;
          }
          while (v82);
          if (v83)
          {
            uint64_t v85 = &v11[16 * v83];
            do
            {
              uint64_t v87 = *((void *)v85 - 2);
              v85 -= 16;
              uint64_t v86 = v87;
              uint64_t v88 = *((void *)v85 + 1);
              uint64_t v89 = &v85[16 * v14];
              uint64_t v90 = v85;
              do
              {
                uint64_t v91 = v89;
                *(_OWORD *)uint64_t v90 = *(_OWORD *)v89;
                uint64_t v92 = &v89[16 * v14];
                BOOL v93 = __OFSUB__(v14, (v13 - (uint64_t)v89) >> 4);
                uint64_t v94 = v14 - ((v13 - (uint64_t)v89) >> 4);
                char v66 = (v94 < 0) ^ v93;
                uint64_t v89 = &v11[16 * v94];
                if (v66) {
                  uint64_t v89 = v92;
                }
                uint64_t v90 = v91;
              }
              while (v89 != v85);
              *(void *)uint64_t v91 = v86;
              *((void *)v91 + 1)  = v88;
            }
            while (v85 != v11);
          }
        }
        goto LABEL_18;
      }
      uint64_t v20 = *(void *)(v13 - 16);
      uint64_t v21 = *(void *)(v13 - 8);
      if ((char *)(v13 - 16) != v11) {
        memmove(v11 + 16, (const void *)(*a5 + 16 * v8), v13 - 16 - (void)v11);
      }
    }
    *(void *)uint64_t v11 = v20;
    *((void *)v11 + 1)  = v21;
  }
LABEL_18:
  TRunGlue::FocusOnIndex(this, v6);
  uint64_t v23 = *((void *)this + 19);
  if (!v23)
  {
LABEL_119:
    if (v6 != v8)
    {
      uint64_t v108 = 16 * v8;
      uint64_t v109 = v6;
      do
      {
        if (*((void *)this + 19))
        {
          *(_OWORD *)id __p = xmmword_184BA1E20;
          *(_OWORD *)&__p[16]  = unk_184BA1E30;
          *(_OWORD *)&__p[32]  = xmmword_184BA1E40;
          *(_OWORD *)&__p[48]  = unk_184BA1E50;
          CopyFromStorage((TRunGlue *)__p, this, v8);
          CopyFromStorage((TRunGlue *)&v148, this, v6);
          CopyToStorage(this, v8, (uint64_t)&v148);
          CopyToStorage(this, v6, (uint64_t)__p);
        }
        else
        {
          *(_OWORD *)id __p = xmmword_184BA1E20;
          *(_OWORD *)&__p[16]  = unk_184BA1E30;
          *(_OWORD *)&__p[32]  = xmmword_184BA1E40;
          *(_OWORD *)&__p[48]  = unk_184BA1E50;
          uint64_t v148 = (uint64_t)this;
          *(void *)&long long v149 = v8;
          uint64_t v110 = *((void *)this + 20);
          uint64_t v111 = *((void *)this + 23) + 16 * v110;
          *((void *)&v149 + 1)  = *((void *)this + 22) + 2 * v110;
          *(void *)unint64_t v150 = v111;
          uint64_t v151 = *((void *)this + 24) + 16 * v110;
          TRunGlue::TGlyphInVector::operator TStorageRange::GlyphEntry((uint64_t)__p, (uint64_t)&v148);
          v153[0]  = (uint64_t)this;
          v153[1]  = v6;
          uint64_t v112 = *((void *)this + 20);
          uint64_t v113 = *((void *)this + 23) + 16 * v112;
          v153[2]  = *((void *)this + 22) + 2 * v112;
          v153[3]  = v113;
          v153[4]  = *((void *)this + 24) + 16 * v112;
          TRunGlue::TGlyphInVector::operator TStorageRange::GlyphEntry((uint64_t)&v148, (uint64_t)v153);
          uint64_t v114 = *((void *)this + 20);
          uint64_t v115 = *((void *)this + 23) + 16 * v114;
          uint64_t v116 = *((void *)this + 24) + 16 * v114;
          *(_WORD *)(*((void *)this + 22) + 2 * v114 + 2 * v8)  = v148;
          *(_OWORD *)(v115 + v108)  = v149;
          TRunGlue::SetGlyphProps(this, v8, v150[0]);
          TRunGlue::SetStringIndex(this, v8, v151);
          *(_OWORD *)(v116 + v108)  = v152;
          uint64_t v117 = *((void *)this + 20);
          uint64_t v118 = *((void *)this + 23) + 16 * v117;
          uint64_t v119 = *((void *)this + 24) + 16 * v117;
          *(_WORD *)(*((void *)this + 22) + 2 * v117 + 2 * v6)  = *(_WORD *)__p;
          *(_OWORD *)(v118 + 16 * v6)  = *(_OWORD *)&__p[8];
          TRunGlue::SetGlyphProps(this, v6, *(unsigned int *)&__p[24]);
          TRunGlue::SetStringIndex(this, v6, *(uint64_t *)&__p[32]);
          *(_OWORD *)(v119 + 16 * v6)  = *(_OWORD *)&__p[48];
        }
        uint64_t v120 = v6 + 1;
        if (++v8 == v109) {
          uint64_t v121 = v6 + 1;
        }
        else {
          uint64_t v121 = v109;
        }
        if (v120 == a4) {
          uint64_t v6 = v109;
        }
        else {
          ++v6;
        }
        if (v120 != a4) {
          uint64_t v109 = v121;
        }
        v108 += 16;
      }
      while (v8 != v6);
    }
    return;
  }
  uint64_t v24 = a4 - v8;
  uint64_t v25 = *((void *)this + 20);
  uint64_t v26 = v8 - v25;
  if (v8 < v25 || *((void *)this + 21) < a4)
  {
    uint64_t v27 = (uint64_t *)*((void *)this + 13);
    if (v27
      && (uint64_t v28 = *v27, v8 < (*(void *)(*((void *)this + 13) + 8) - v28) >> 4)
      && (int v29 = *(_DWORD *)(v28 + 16 * v8 + 12)) != 0)
    {
      if (v8 < 1)
      {
        uint64_t v31 = v8;
      }
      else
      {
        uint64_t v30 = (int *)(v28 + 16 * v8 - 4);
        uint64_t v31 = v8;
        while (1)
        {
          int v32 = *v30;
          v30 -= 4;
          if (v32 != v29) {
            break;
          }
          --v31;
          ++v24;
          if ((unint64_t)(v31 + 1) <= 1)
          {
            uint64_t v31 = 0;
            uint64_t v24 = a4;
            break;
          }
        }
      }
      uint64_t v137 = v31;
      uint64_t v138 = v24 + v31;
      uint64_t v139 = TRunGlue::length(this);
      if (v138 >= v139)
      {
        uint64_t v33 = v137;
      }
      else
      {
        double v140 = (int *)(**((void **)this + 13) + 16 * v138 + 12);
        uint64_t v33 = v137;
        while (1)
        {
          int v141 = *v140;
          v140 += 4;
          if (v141 != v29) {
            break;
          }
          ++v24;
          if (v137 + v24 >= v139)
          {
            uint64_t v24 = v139 - v137;
            break;
          }
        }
      }
    }
    else
    {
      uint64_t v33 = v8;
    }
    *(void *)&long long v34 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v34 + 1)  = 0xAAAAAAAAAAAAAAAALL;
    long long v180 = v34;
    long long v181 = v34;
    long long v178 = v34;
    v179  = v34;
    long long v176 = v34;
    long long v177 = v34;
    long long v174 = v34;
    long long v175 = v34;
    long long v172 = v34;
    long long v173 = v34;
    v170  = v34;
    long long v171 = v34;
    v168  = v34;
    v169  = v34;
    long long v167 = v34;
    long long v166 = v34;
    long long v165 = v34;
    long long v164 = v34;
    long long v163 = v34;
    long long v162 = v34;
    long long v161 = v34;
    long long v160 = v34;
    long long v159 = v34;
    long long v158 = v34;
    v157  = v34;
    long long v156 = v34;
    long long v155 = v34;
    *(_OWORD *)&__p[56]  = v34;
    *(_OWORD *)&__p[40]  = v34;
    *(_OWORD *)&__p[24]  = v34;
    memset(__p, 0, 24);
    v182[0]  = &__p[24];
    if (v24 < 1)
    {
      unint64_t v38 = 0;
      int v39 = 0;
    }
    else
    {
      GlyphProps  = TRunGlue::GetGlyphProps(this, v33);
      StringIndedouble x = TRunGlue::GetStringIndex(this, v33);
      if ((GlyphProps & 0x380) != 0)
      {
        BOOL v37 = 0;
        goto LABEL_112;
      }
      uint64_t v54 = StringIndex;
      uint64_t v55 = 0;
      uint64_t v56 = v33;
      uint64_t v143 = v24;
      uint64_t v144 = v33;
      while (1)
      {
        uint64_t v58 = *(void **)&__p[8];
        uint64_t v57 = *(void *)&__p[16];
        if (*(void *)&__p[8] >= *(void *)&__p[16])
        {
          char v59 = *(void **)__p;
          uint64_t v60 = (uint64_t)(*(void *)&__p[8] - *(void *)__p) >> 4;
          unint64_t v61 = v60 + 1;
          if ((unint64_t)(v60 + 1) >> 60) {
            abort();
          }
          if ((uint64_t)(*(void *)&__p[16] - *(void *)__p) >> 3 > v61) {
            unint64_t v61 = (uint64_t)(*(void *)&__p[16] - *(void *)__p) >> 3;
          }
          unint64_t v62 = *(void *)&__p[16] - *(void *)__p >= 0x7FFFFFFFFFFFFFF0uLL ? 0xFFFFFFFFFFFFFFFLL : v61;
          int v63 = (char *)v182[0];
          if (v182[0] + 16 * v62 <= (unint64_t)v182)
          {
            v182[0] += 16 * v62;
          }
          else
          {
            if (v62 >> 60) {
              std::__throw_bad_array_new_length[abi:nn180100]();
            }
            unint64_t v142 = v62;
            int v63 = (char *)operator new(16 * v62);
            unint64_t v62 = v142;
          }
          BOOL v64 = (uint64_t *)&v63[16 * v60];
          *BOOL v64 = v56;
          v64[1]  = v54;
          if (v58 == v59)
          {
            unint64_t v38 = v64 + 2;
            *(void *)id __p = &v63[16 * v60];
            *(void *)&__p[8]  = v64 + 2;
            uint64_t v33 = v144;
          }
          else
          {
            int v65 = &v63[16 * v60];
            uint64_t v33 = v144;
            do
            {
              *((_OWORD *)v65 - 1)  = *((_OWORD *)v58 - 1);
              v65 -= 16;
              v58 -= 2;
            }
            while (v58 != v59);
            unint64_t v38 = v64 + 2;
            uint64_t v58 = *(void **)__p;
            uint64_t v57 = *(void *)&__p[16];
            *(void *)id __p = v65;
            *(void *)&__p[8]  = v64 + 2;
          }
          *(void *)&__p[16]  = &v63[16 * v62];
          uint64_t v24 = v143;
          if (v58)
          {
            char v66 = &__p[24] <= (unsigned char *)v58 && v182 > v58;
            if (v66)
            {
              if (v57 == v182[0]) {
                v182[0]  = v58;
              }
            }
            else
            {
              operator delete(v58);
            }
          }
        }
        else
        {
          **(void **)&__p[8]  = v56;
          v58[1]  = v54;
          unint64_t v38 = v58 + 2;
        }
        *(void *)&__p[8]  = v38;
        if (++v55 == v24) {
          break;
        }
        uint64_t v56 = v55 + v33;
        __int16 v67 = TRunGlue::GetGlyphProps(this, v55 + v33);
        uint64_t v54 = TRunGlue::GetStringIndex(this, v55 + v33);
        if ((v67 & 0x380) != 0)
        {
          BOOL v37 = v55 >= v24;
          uint64_t v10 = a4;
          goto LABEL_112;
        }
      }
      int v39 = *(uint64_t **)__p;
      uint64_t v10 = a4;
    }
    unint64_t v95 = 126 - 2 * __clz(((char *)v38 - (char *)v39) >> 4);
    if (v38 == v39) {
      uint64_t v96 = 0;
    }
    else {
      uint64_t v96 = v95;
    }
    std::__introsort<std::_ClassicAlgPolicy,TRunGlue::SeparateCharactersInGlyphRange(CFRange)::$_0 &,std::pair<long,long> *,false>(v39, v38, v96, 1);
    long long v97 = *(uint64_t **)__p;
    for (uint64_t i = *(uint64_t **)&__p[8]; v97 != i; v97 += 2)
    {
      uint64_t v99 = *v97;
      uint64_t v101 = *(void *)(*(void *)this + 16);
      uint64_t v100 = *(void *)(*(void *)this + 24);
      uint64_t v148 = 0;
      v153[0]  = 0xAAAAAAAAAAAAAAAALL;
      v153[0]  = TRunGlue::PhysicalRunIndexWithGlyphIndex(this, v99, &v148);
      if (TLine::SeparateCharWithGlyphIndex(*(TLine **)this, v153, v148))
      {
        uint64_t v102 = *(void *)this;
        *(_WORD *)(v102 + 152)  = *(_WORD *)(*(void *)this + 152) | 1;
        uint64_t v103 = ((uint64_t)(*(void *)(v102 + 24) - *(void *)(v102 + 16)) >> 3) - ((v100 - v101) >> 3);
        if (v103 >= 1) {
          TRunGlue::UpdateForSplitRun(this, v103);
        }
      }
    }
    *((void *)this + 21)  = *((void *)this + 20);
    BOOL v37 = 1;
LABEL_112:
    if (*(void *)__p
      && ((*(void *)&__p[8]  = *(void *)__p, (unint64_t)&__p[24] > *(void *)__p)
       || (unint64_t)v182 <= *(void *)__p))
    {
      operator delete(*(void **)__p);
      if (v37) {
        goto LABEL_116;
      }
    }
    else if (v37)
    {
LABEL_116:
      uint64_t v104 = TRunGlue::PhysicalRunIndexWithGlyphIndex(this, v8, (uint64_t *)__p);
      uint64_t v105 = TRunGlue::PhysicalRunIndexWithGlyphIndex(this, v6, (uint64_t *)__p);
      if (TRunGlue::length(this) <= v10)
      {
        int v107 = *((_DWORD *)this + 6);
        uint64_t v122 = *((void *)this + 1);
        if (v107 < 1) {
          uint64_t v106 = v122 - 1;
        }
        else {
          uint64_t v106 = *((void *)this + 2) + v122;
        }
      }
      else
      {
        uint64_t v106 = TRunGlue::PhysicalRunIndexWithGlyphIndex(this, v10, (uint64_t *)__p);
        int v107 = *((_DWORD *)this + 6);
      }
      if (v107 < 0) {
        uint64_t v123 = v106 + 1;
      }
      else {
        uint64_t v123 = v104;
      }
      if (v107 < 0) {
        uint64_t v124 = v104 + 1;
      }
      else {
        uint64_t v124 = v106;
      }
      uint64_t v125 = v105 + (v107 >> 31);
      uint64_t v126 = *(void *)this;
      if (v123 != v125)
      {
        uint64_t v127 = v125 - 1;
        uint64_t v128 = v123;
        do
        {
          if (v128 == v127) {
            break;
          }
          uint64_t v129 = *(void *)(v126 + 16);
          uint64_t v130 = *(void *)(v129 + 8 * v128);
          *(void *)(v129 + 8 * v128)  = *(void *)(v129 + 8 * v127);
          *(void *)(v129 + 8 * v127)  = v130;
          *(_WORD *)(v126 + 154) |= 0x40u;
          BOOL v19 = v128++ == --v127;
        }
        while (!v19);
        uint64_t v126 = *(void *)this;
      }
      if (v125 != v124)
      {
        uint64_t v131 = v124 - 1;
        do
        {
          if (v125 == v131) {
            break;
          }
          uint64_t v132 = *(void *)(v126 + 16);
          uint64_t v133 = *(void *)(v132 + 8 * v125);
          *(void *)(v132 + 8 * v125)  = *(void *)(v132 + 8 * v131);
          *(void *)(v132 + 8 * v131)  = v133;
          *(_WORD *)(v126 + 154) |= 0x40u;
          BOOL v19 = v125++ == --v131;
        }
        while (!v19);
        uint64_t v126 = *(void *)this;
      }
      if (v123 != v124)
      {
        uint64_t v134 = v124 - 1;
        do
        {
          if (v123 == v134) {
            break;
          }
          uint64_t v135 = *(void *)(v126 + 16);
          uint64_t v136 = *(void *)(v135 + 8 * v123);
          *(void *)(v135 + 8 * v123)  = *(void *)(v135 + 8 * v134);
          *(void *)(v135 + 8 * v134)  = v136;
          *(_WORD *)(v126 + 154) |= 0x40u;
          BOOL v19 = v123++ == --v134;
        }
        while (!v19);
      }
      return;
    }
    goto LABEL_119;
  }
  if (v5 <= v7)
  {
    uint64_t v68 = v6 - v25;
    uint64_t v145 = a4 - v6;
    uint64_t v69 = v8 - v25;
    uint64_t v70 = v68 - v26;
    [*(id *)(v23 + 216) initGlyphStackWithCapacity:v68 - v26];
    if (v70 >= 1)
    {
      uint64_t v71 = v69;
      uint64_t v72 = v5;
      do
      {
        [*(id *)(v23 + 216) pushGlyphAtIndex:v71 + *(void *)(v23 + 200)];
        ++v71;
        --v72;
      }
      while (v72);
    }
    if (v145 >= 1)
    {
      uint64_t v73 = v68;
      do
      {
        uint64_t v74 = *(void **)(v23 + 216);
        uint64_t v75 = *(void *)(v23 + 200);
        int v76 = *(_DWORD *)(v74[5] + 4 * v75 + 4 * v73);
        if ((v76 & 0x40) != 0) {
          [v74 setProps:v76 & 0xFFFFEFBF | 0x1000 atIndex:v73 + v75];
        }
        ++v73;
        --v7;
      }
      while (v7);
    }
    objc_msgSend(*(id *)(v23 + 216), "moveGlyphsFromRange:toIndex:", *(void *)(v23 + 200) + v68, v145, *(void *)(v23 + 200) + v69);
    if (v70 >= 1)
    {
      unint64_t v77 = v5 + 1;
      uint64_t v78 = ~v25 + a4;
      do
      {
        [*(id *)(v23 + 216) popGlyphAtIndex:v78 + *(void *)(v23 + 200)];
        uint64_t v79 = *(void **)(v23 + 216);
        uint64_t v80 = *(void *)(v23 + 200);
        int v81 = *(_DWORD *)(v79[5] + 4 * v80 + 4 * v78);
        if ((v81 & 0x40) != 0) {
          [v79 setProps:v81 & 0xFFFFEFBF | 0x1000 atIndex:v78 + v80];
        }
        --v77;
        --v78;
      }
      while (v77 > 1);
    }
  }
  else
  {
    uint64_t v147 = v8 - v25;
    uint64_t v40 = ~v8 + v6;
    uint64_t v41 = v24 - v5;
    [*(id *)(v23 + 216) initGlyphStackWithCapacity:v24 - v5];
    if (v24 - v5 >= 1)
    {
      uint64_t v42 = v147 + v5;
      uint64_t v43 = v24 - v5;
      do
      {
        [*(id *)(v23 + 216) pushGlyphAtIndex:v42 + *(void *)(v23 + 200)];
        ++v42;
        --v43;
      }
      while (v43);
    }
    if ((v40 & 0x8000000000000000) == 0)
    {
      uint64_t v44 = v8 - v25;
      uint64_t v45 = v5;
      do
      {
        int v46 = *(void **)(v23 + 216);
        uint64_t v47 = *(void *)(v23 + 200);
        int v48 = *(_DWORD *)(v46[5] + 4 * v47 + 4 * v44);
        if ((v48 & 0x40) != 0) {
          [v46 setProps:v48 & 0xFFFFEFBF | 0x1000 atIndex:v44 + v47];
        }
        ++v44;
        --v45;
      }
      while (v45);
    }
    objc_msgSend(*(id *)(v23 + 216), "moveGlyphsFromRange:toIndex:", *(void *)(v23 + 200) + v147, v5, v147 + v41 + *(void *)(v23 + 200));
    if (v41 >= 1)
    {
      uint64_t v49 = ~v25 + v8;
      uint64_t v50 = 4 * v8 - 4 * v25 - 4;
      do
      {
        [*(id *)(v23 + 216) popGlyphAtIndex:v49 + v41 + *(void *)(v23 + 200)];
        uint64_t v51 = *(void **)(v23 + 216);
        uint64_t v52 = *(void *)(v23 + 200);
        int v53 = *(_DWORD *)(v51[5] + 4 * v52 + v50 + 4 * v41);
        if ((v53 & 0x40) != 0) {
          [v51 setProps:v53 & 0xFFFFEFBF | 0x1000 atIndex:v49 + v41 + v52];
        }
        --v41;
      }
      while ((unint64_t)(v41 + 1) > 1);
    }
  }
  [*(id *)(v23 + 216) disposeGlyphStack];
  *(_DWORD *)(*((void *)this + 19) + 256)  = 2;
}

uint64_t TRunGlue::PhysicalRunIndexWithGlyphIndex(TRunGlue *this, uint64_t a2, uint64_t *a3)
{
  if (a2 < 0) {
    return -1;
  }
  uint64_t v4 = a2;
  if (*((int *)this + 6) >= 1)
  {
    uint64_t v6 = *((void *)this + 1);
    uint64_t v7 = *(void *)(*(void *)this + 16);
    uint64_t v8 = *(void *)(*(void *)this + 24);
    uint64_t v9 = v7 + 8 * v6;
    if (v9 != v8)
    {
      uint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *(void *)(*(void *)(*(void *)v9 + 40) + 208) + v10;
        if (v11 > a2) {
          break;
        }
        v9 += 8;
        uint64_t v10 = v11;
        if (v9 == v8)
        {
          uint64_t v9 = *(void *)(*(void *)this + 24);
          goto LABEL_12;
        }
      }
      uint64_t v4 = a2 - v10;
    }
LABEL_12:
    uint64_t result = (v9 - v7) >> 3;
    if (v6 <= result && *((void *)this + 2) + v6 > result)
    {
      *a3  = v4;
      return result;
    }
    return -1;
  }
  TRunGlue::FocusOnIndex(this, a2);
  *a3  = v4 - *((void *)this + 20);
  uint64_t v12 = *((void *)this + 16);

  return TRunGlue::PhysicalRunIndexFromLogical(this, v12);
}

void *TRunGlue::UpdateForSplitRun(TRunGlue *this, uint64_t a2)
{
  *((void *)this + 2) += a2;
  *((void *)this + 18) += a2;
  uint64_t v3 = *(void *)this;
  uint64_t v4 = *(void *)(*(void *)(*(void *)(v3 + 16)
                             + 8 * TRunGlue::PhysicalRunIndexFromLogical(this, *((void *)this + 16)))
                 + 48);
  *((void *)this + 19)  = v4;
  *((void *)this + 21)  = *(void *)(v4 + 208) + *((void *)this + 20);

  return TRunGlue::UpdateForCurrentRealRun(this);
}

char **TRunGlue::InsertGlyphs(TRunGlue *this, CFRange a2)
{
  CFIndex length = a2.length;
  CFIndex location = a2.location;
  uint64_t v5 = TRunGlue::length(this);
  if (v5 - 1 >= location) {
    uint64_t v6 = location;
  }
  else {
    uint64_t v6 = v5 - 1;
  }
  TRunGlue::FocusOnIndex(this, v6);
  uint64_t v7 = *((void *)this + 19);
  if (v7)
  {
    if (v7 != *((void *)this + 67))
    {
      uint64_t v8 = objc_msgSend(*(id *)(v7 + 216), "copyWithRange:", *(void *)(v7 + 200), *(void *)(v7 + 208));

      *(void *)(v7 + 216)  = v8;
      *(void *)(v7 + 200)  = 0;
      uint64_t v7 = *((void *)this + 19);
      *((void *)this + 67)  = v7;
    }
    v31.CFIndex location = location - *((void *)this + 20);
    v31.CFIndex length = length;
    TStorageRange::InsertGlyphs((id *)(v7 + 192), v31);
  }
  else
  {
    uint64_t result = (char **)std::function<BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::operator()(*((void *)this + 73), *((void *)this + 20) + location, length, (uint64_t)this + 176, (uint64_t)this + 184, (uint64_t)this + 192, (uint64_t)this + 528);
    if (!result) {
      return result;
    }
    if (*((void *)this + 65))
    {
      uint64_t v10 = *((void *)this + 46);
      if (v10 != *((void *)this + 47))
      {
        uint64_t v11 = (char *)(v10 + 4 * *((void *)this + 20) + 4 * location);
        LODWORD(v30[0])  = 0;
        std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::insert((uint64_t *)this + 46, v11, length, (char *)v30);
        *((void *)this + 65)  = *((void *)this + 46);
      }
    }
    else
    {
      uint64_t v12 = TRunGlue::length(this);
      uint64_t v13 = length + v12 + 14;
      if (length + v12 + 7 >= 0) {
        uint64_t v13 = length + v12 + 7;
      }
      unint64_t v14 = v13 >> 3;
      uint64_t v15 = *((void *)this + 26);
      unint64_t v16 = *((void *)this + 27) - v15;
      if (v14 <= v16)
      {
        if (v14 < v16) {
          *((void *)this + 27)  = v15 + v14;
        }
      }
      else
      {
        std::vector<unsigned char,TInlineBufferAllocator<unsigned char,128ul>>::__append((void *)this + 26, v14 - v16);
      }
      uint64_t v17 = TRunGlue::length(this);
      CFIndex v18 = location + length;
      if (v17 >= location + length)
      {
        do
        {
          uint64_t v19 = v17 + *((void *)this + 20);
          uint64_t v20 = v19 + 1;
          uint64_t v21 = v19 + 7;
          if (v19 >= 0) {
            uint64_t v21 = v17 + *((void *)this + 20);
          }
          uint64_t v22 = v21 >> 3;
          uint64_t v23 = *((void *)this + 26);
          char v24 = v19 & 7;
          int v25 = 1 << (v20 & 7);
          uint64_t v26 = v20 / 8;
          if ((*(unsigned __int8 *)(v23 + v22) >> v24)) {
            char v27 = *(unsigned char *)(v23 + v26) | v25;
          }
          else {
            char v27 = *(unsigned char *)(v23 + v26) & ~(_BYTE)v25;
          }
          *(unsigned char *)(v23 + v26)  = v27;
        }
        while (v17-- > v18);
      }
      if (length >= 1)
      {
        CFIndex v29 = location;
        do
        {
          *(unsigned char *)(*((void *)this + 26) + (v29 + *((void *)this + 20)) / 8) &= ~(1 << ((v29
                                                                                            + *((unsigned char *)this + 160)) & 7));
          ++v29;
        }
        while (v29 < v18);
      }
    }
  }
  TRunGlue::InsertedGlyphs(this, length);
  uint64_t result = (char **)*((void *)this + 13);
  v30[0]  = 0;
  v30[1]  = 0;
  if (location <= (result[1] - *result) >> 4) {
    return std::vector<TGlyphAuxDataListEntry,TInlineBufferAllocator<TGlyphAuxDataListEntry,30ul>>::insert(result, (uint64_t)&(*result)[16 * location], length, (char *)v30);
  }
  return result;
}

uint64_t std::function<BOOL ()(CFRange,unsigned short **,CGSize **,CGPoint **,long **)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v13[0]  = a2;
  v13[1]  = a3;
  uint64_t v11 = a5;
  uint64_t v12 = a4;
  uint64_t v9 = a7;
  uint64_t v10 = a6;
  if (a1) {
    return (*(uint64_t (**)(uint64_t, void *, uint64_t *, uint64_t *, uint64_t *, uint64_t *))(*(void *)a1 + 48))(a1, v13, &v12, &v11, &v10, &v9);
  }
  uint64_t v8 = std::__throw_bad_function_call[abi:nn180100]();
  return std::vector<unsigned char,TInlineBufferAllocator<unsigned char,128ul>>::resize(v8);
}

void std::vector<unsigned char,TInlineBufferAllocator<unsigned char,128ul>>::resize(void *a1, unint64_t a2)
{
  unint64_t v2 = a1[1] - *a1;
  BOOL v3 = a2 >= v2;
  size_t v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    std::vector<unsigned char,TInlineBufferAllocator<unsigned char,128ul>>::__append(a1, v4);
  }
  else if (!v3)
  {
    a1[1]  = *a1 + a2;
  }
}

uint64_t *std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::insert(uint64_t *result, char *__src, unint64_t a3, char *a4)
{
  if (a3)
  {
    size_t v4 = a4;
    uint64_t v6 = __src;
    uint64_t v7 = (uint64_t)result;
    uint64_t v8 = (char *)result[1];
    uint64_t v9 = result[2];
    if (a3 <= (v9 - (uint64_t)v8) >> 2)
    {
      uint64_t v17 = v8 - __src;
      if (a3 <= (v8 - __src) >> 2)
      {
        uint64_t v20 = (char *)result[1];
        uint64_t v19 = a3;
      }
      else
      {
        uint64_t v18 = 0;
        uint64_t v19 = v17 >> 2;
        uint64_t v20 = &v8[4 * (a3 - (v17 >> 2))];
        do
        {
          *(_DWORD *)&v8[v18]  = *(_DWORD *)a4;
          v18 += 4;
        }
        while (4 * a3 - 4 * v19 != v18);
        result[1]  = (uint64_t)v20;
        if (v8 == __src) {
          return result;
        }
      }
      uint64_t v21 = &__src[4 * a3];
      uint64_t v22 = &v20[-4 * a3];
      uint64_t v23 = v20;
      if (v22 < v8)
      {
        uint64_t v23 = v20;
        do
        {
          int v24 = *(_DWORD *)v22;
          v22 += 4;
          *(_DWORD *)uint64_t v23 = v24;
          v23 += 4;
        }
        while (v22 < v8);
      }
      result[1]  = (uint64_t)v23;
      if (v20 != v21) {
        uint64_t result = (uint64_t *)memmove(&v20[-4 * ((v20 - v21) >> 2)], __src, v20 - v21);
      }
      if (v6 <= v4)
      {
        if (*(void *)(v7 + 8) <= (unint64_t)v4) {
          unint64_t v25 = 0;
        }
        else {
          unint64_t v25 = a3;
        }
        v4 += 4 * v25;
      }
      do
      {
        *(_DWORD *)uint64_t v6 = *(_DWORD *)v4;
        v6 += 4;
        --v19;
      }
      while (v19);
    }
    else
    {
      uint64_t v10 = *result;
      unint64_t v11 = a3 + ((uint64_t)&v8[-*result] >> 2);
      if (v11 >> 62) {
        abort();
      }
      uint64_t v12 = (uint64_t)&__src[-v10] >> 2;
      uint64_t v13 = (uint64_t)(result + 3);
      uint64_t v14 = v9 - v10;
      if (v14 >> 1 > v11) {
        unint64_t v11 = v14 >> 1;
      }
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v15 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v15 = v11;
      }
      v29[4]  = v7 + 24;
      if (v15) {
        unint64_t v16 = (char *)TInlineBufferAllocator<unsigned int,30ul>::allocate(v13, v15);
      }
      else {
        unint64_t v16 = 0;
      }
      uint64_t v26 = &v16[4 * v12];
      v29[0]  = v16;
      v29[1]  = v26;
      v29[3]  = &v16[4 * v15];
      uint64_t v27 = 4 * a3;
      uint64_t v28 = &v26[4 * a3];
      do
      {
        *(_DWORD *)uint64_t v26 = *(_DWORD *)v4;
        v26 += 4;
        v27 -= 4;
      }
      while (v27);
      v29[2]  = v28;
      std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__swap_out_circular_buffer((void **)v7, (uint64_t)v29, v6);
      return (uint64_t *)std::__split_buffer<unsigned int,TInlineBufferAllocator<unsigned int,30ul> &>::~__split_buffer((uint64_t)v29);
    }
  }
  return result;
}

void *TRunGlue::InsertedGlyphs(void *this, uint64_t a2)
{
  BOOL v3 = this;
  if (this[19])
  {
    *(void *)(*this + 144) += a2;
    this  = TRunGlue::UpdateForCurrentRealRun(this);
  }
  v3[21] += a2;
  uint64_t v4 = v3[4];
  if (v4 != -1) {
    v3[4]  = v4 + a2;
  }
  return this;
}

void TRunGlue::TGlyphInVector::operator TStorageRange::GlyphEntry(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v5 = *(void *)(a2 + 24);
  uint64_t v6 = *(void *)(a2 + 8);
  uint64_t v7 = *(TRunGlue **)a2;
  *(_WORD *)a1  = *(_WORD *)(v4 + 2 * v6);
  *(_OWORD *)(a1 + 8)  = *(_OWORD *)(v5 + 16 * v6);
  *(_DWORD *)(a1 + 24)  = TRunGlue::GetGlyphProps(v7, v6);
  *(void *)(a1 + 32)  = TRunGlue::GetStringIndex(*(TRunGlue **)a2, *(void *)(a2 + 8));
  *(void *)(a1 + 40)  = 0;
  *(double *)(a1 + 48)  = TRunGlue::GetOrigin(*(TRunGlue **)a2, *(void *)(a2 + 8));
  *(void *)(a1 + 56)  = v8;
}

void TRunGlue::FilterJoiner(TRunGlue *this, TRunGlue::TGlyph *a2, unsigned __int16 *a3)
{
  uint64_t v6 = *a3;
  if (v6
    || ((*(void (**)(void, uint64_t, uint64_t, unsigned __int16 *))(**(void **)(*((void *)this + 77)
                                                                                           + 400)
                                                                             + 672))(*(void *)(*((void *)this + 77) + 400), 32, 1, a3), (uint64_t v6 = *a3) != 0))
  {
    if (v6 != 0xFFFF)
    {
      TRunGlue::SetGlyphID<true>(*(TRunGlue **)a2, *((void *)a2 + 1), v6);
      TRunGlue::SetAdvance(*(void **)a2, *((void *)a2 + 1), *MEMORY[0x1E4F1DB30]);
      uint64_t v7 = *(TRunGlue **)a2;
      uint64_t v8 = *((void *)a2 + 1);
      TRunGlue::OrGlyphProps(v7, v8, 0x20u);
      return;
    }
  }
  else
  {
    *a3  = -1;
  }
  uint64_t v9 = *((void *)a2 + 1);

  TRunGlue::Delete(this, v9, 0);
}

void *TRunGlue::SelectRun(TRunGlue *this, uint64_t a2)
{
  uint64_t v4 = *((void *)this + 16);
  uint64_t v5 = *((void *)this + 1);
  if (v4 <= a2)
  {
    uint64_t v6 = *((void *)this + 16);
    uint64_t v4 = *((void *)this + 2) + v5;
  }
  else
  {
    uint64_t v6 = v5 - 1;
    *((void *)this + 21)  = 0;
  }
  do
  {
    *((void *)this + 16)  = v6 + 1;
    if (v6 + 1 >= v4) {
      break;
    }
    uint64_t v7 = *(void *)this;
    uint64_t v8 = *(void *)(*(void *)(*(void *)(v7 + 16) + 8 * TRunGlue::PhysicalRunIndexFromLogical(this, v6 + 1)) + 48);
    uint64_t v9 = *((void *)this + 21);
    *((void *)this + 19)  = v8;
    *((void *)this + 20)  = v9;
    *((void *)this + 21)  = *(void *)(v8 + 208) + v9;
    uint64_t v6 = *((void *)this + 16);
  }
  while (v6 != a2);

  return TRunGlue::UpdateForCurrentRealRun(this);
}

uint64_t TRunGlue::GlyphRangeForGlyphIndex(TRun **this, uint64_t a2)
{
  uint64_t v2 = a2;
  if (this[19])
  {
    TRunGlue::FocusOnIndex((TRunGlue *)this, a2);
    return (uint64_t)this[20] + TRun::GetGlyphRangeForGlyphIndex(this[19], v2 - (void)this[20]);
  }
  else if ((a2 & 0x8000000000000000) == 0 && TRunGlue::length((TRunGlue *)this) > a2)
  {
    uint64_t v4 = v2;
    while (1)
    {
      uint64_t v5 = *((int *)this + 6);
      v4 += v5;
      if (v4 < 0 || (uint64_t)this[4] <= v4) {
        break;
      }
      if (!TRunGlue::IsDeleted((TRunGlue *)this, v4))
      {
        uint64_t v5 = *((int *)this + 6);
        break;
      }
    }
    uint64_t v6 = v4 - v5;
    if (v6 < v2) {
      return v6;
    }
  }
  return v2;
}

uint64_t TRun::GetGlyphRangeForGlyphIndex(TRun *this, uint64_t a2)
{
  uint64_t v2 = 1;
  if (*((unsigned char *)this + 224)) {
    uint64_t v2 = -1;
  }
  uint64_t v3 = a2;
  if (v2 + a2 >= 0)
  {
    uint64_t v4 = *((void *)this + 26);
    uint64_t v3 = a2;
    if (v4 > v2 + a2)
    {
      uint64_t v5 = *((void *)this + 27);
      uint64_t v6 = *((void *)this + 25);
      uint64_t v7 = 2 * v2;
      uint64_t v8 = 4 * v2 + 4 * v6;
      uint64_t v9 = *(void *)(v5 + 16) + 2 * v2 + 2 * v6;
      uint64_t v3 = a2;
      do
      {
        if (*(__int16 *)(v9 + 2 * v3) != -1 && (*(_DWORD *)(*(void *)(v5 + 40) + v8 + 4 * v3) & 0x20) == 0) {
          break;
        }
        uint64_t v11 = v7 + v3;
        BOOL v10 = v7 + v3 < 0;
        v3 += v2;
        if (v10) {
          break;
        }
      }
      while (v4 > v11);
    }
  }
  if (v3 >= a2) {
    return a2;
  }
  else {
    return v3;
  }
}

uint64_t CopyFromStorage(TRunGlue *a1, TRunGlue *this, uint64_t a3)
{
  uint64_t v9 = a3;
  uint64_t v5 = TRunGlue::PhysicalRunIndexWithGlyphIndex(this, a3, &v9);
  if (v5 == -1) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = *(void *)(*(void *)(*(void *)(*(void *)this + 16) + 8 * v5) + 48);
  }
  uint64_t v7 = v9;

  return TStorageRange::GetGlyphEntry((TStorageRange *)(v6 + 192), v7, (uint64_t)a1);
}

uint64_t CopyToStorage(TRunGlue *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v13 = a2;
  uint64_t v5 = TRunGlue::PhysicalRunIndexWithGlyphIndex(a1, a2, &v13);
  if (v5 == -1) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = *(void *)(*(void *)(*(void *)(*(void *)a1 + 16) + 8 * v5) + 48);
  }
  uint64_t result = TStorageRange::SetGlyphEntry(v6 + 192, v13, (unsigned __int16 *)a3);
  *(_DWORD *)(v6 + 256)  = 2;
  uint64_t v9 = *(void *)(v6 + 8);
  uint64_t v10 = *(void *)(a3 + 32);
  if (v9 > v10 || *(void *)(v6 + 16) + v9 <= v10)
  {
    uint64_t result = TRunGlue::ActualCharRangeForStorage((TRunGlue *)(v6 + 192), v8);
    *(void *)(v6 + 8)  = result;
    *(void *)(v6 + 16)  = v12;
  }
  return result;
}

uint64_t *std::__introsort<std::_ClassicAlgPolicy,TRunGlue::SeparateCharactersInGlyphRange(CFRange)::$_0 &,std::pair<long,long> *,false>(uint64_t *result, uint64_t *a2, uint64_t a3, char a4)
{
  uint64_t v9 = result;
  while (2)
  {
    uint64_t v10 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v9 = v10;
          uint64_t v11 = (char *)a2 - (char *)v10;
          unint64_t v12 = ((char *)a2 - (char *)v10) >> 4;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                if (*(a2 - 1) < v10[1])
                {
                  uint64_t v44 = *v10;
                  *uint64_t v10 = *(a2 - 2);
                  *(a2 - 2)  = v44;
                  uint64_t v45 = v10[1];
                  v10[1]  = *(a2 - 1);
                  *(a2 - 1)  = v45;
                }
                break;
              case 3uLL:
                uint64_t result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TRunGlue::SeparateCharactersInGlyphRange(CFRange)::$_0 &,std::pair<long,long> *>(v10, v10 + 2, a2 - 2);
                break;
              case 4uLL:
                uint64_t result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,TRunGlue::SeparateCharactersInGlyphRange(CFRange)::$_0 &,std::pair<long,long> *>(v10, v10 + 2, v10 + 4, a2 - 2);
                break;
              case 5uLL:
                uint64_t result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,TRunGlue::SeparateCharactersInGlyphRange(CFRange)::$_0 &,std::pair<long,long> *>(v10, v10 + 2, v10 + 4, v10 + 6);
                if (*(a2 - 1) < v10[7])
                {
                  uint64_t v46 = v10[6];
                  v10[6]  = *(a2 - 2);
                  *(a2 - 2)  = v46;
                  uint64_t v47 = v10[7];
                  v10[7]  = *(a2 - 1);
                  *(a2 - 1)  = v47;
                  uint64_t v48 = v10[7];
                  uint64_t v49 = v10[5];
                  if (v48 < v49)
                  {
                    uint64_t v50 = v10[6];
                    uint64_t v51 = v10[3];
                    uint64_t v52 = v10[4];
                    v10[4]  = v50;
                    v10[5]  = v48;
                    v10[6]  = v52;
                    v10[7]  = v49;
                    if (v48 < v51)
                    {
                      uint64_t v53 = v10[1];
                      uint64_t v54 = v10[2];
                      v10[2]  = v50;
                      v10[3]  = v48;
                      v10[4]  = v54;
                      v10[5]  = v51;
                      if (v48 < v53)
                      {
                        uint64_t v55 = *v10;
                        *uint64_t v10 = v50;
                        v10[1]  = v48;
                        v10[2]  = v55;
                        v10[3]  = v53;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v11 <= 383)
          {
            uint64_t v56 = v10 + 2;
            BOOL v58 = v10 == a2 || v56 == a2;
            if (a4)
            {
              if (!v58)
              {
                uint64_t v59 = 0;
                uint64_t v60 = v10;
                do
                {
                  uint64_t v61 = v60[3];
                  uint64_t v62 = v60[1];
                  uint64_t v60 = v56;
                  if (v61 < v62)
                  {
                    uint64_t v63 = *v56;
                    uint64_t v64 = v59;
                    while (1)
                    {
                      int v65 = (char *)v10 + v64;
                      uint64_t v66 = *(uint64_t *)((char *)v10 + v64 + 8);
                      *((void *)v65 + 2)  = *(uint64_t *)((char *)v10 + v64);
                      *((void *)v65 + 3)  = v66;
                      if (!v64) {
                        break;
                      }
                      v64 -= 16;
                      if (v61 >= *((void *)v65 - 1))
                      {
                        __int16 v67 = (uint64_t *)((char *)v10 + v64 + 16);
                        goto LABEL_87;
                      }
                    }
                    __int16 v67 = v10;
LABEL_87:
                    *__int16 v67 = v63;
                    v67[1]  = v61;
                  }
                  uint64_t v56 = v60 + 2;
                  v59 += 16;
                }
                while (v60 + 2 != a2);
              }
            }
            else if (!v58)
            {
              uint64_t v94 = v10 + 3;
              do
              {
                uint64_t v95 = v9[3];
                uint64_t v96 = v9[1];
                uint64_t v9 = v56;
                if (v95 < v96)
                {
                  uint64_t v97 = *v56;
                  double v98 = v94;
                  do
                  {
                    uint64_t v99 = v98;
                    uint64_t v100 = *(v98 - 4);
                    *(v98 - 1)  = *(v98 - 3);
                    uint64_t v101 = *(v98 - 2);
                    v98 -= 2;
                    *uint64_t v99 = v101;
                  }
                  while (v95 < v100);
                  *(v98 - 1)  = v97;
                  *double v98 = v95;
                }
                uint64_t v56 = v9 + 2;
                v94 += 2;
              }
              while (v9 + 2 != a2);
            }
            return result;
          }
          if (!a3)
          {
            if (v10 != a2)
            {
              int64_t v68 = (v12 - 2) >> 1;
              int64_t v69 = v68;
              do
              {
                int64_t v70 = v69;
                if (v68 >= v69)
                {
                  uint64_t v71 = (2 * v69) | 1;
                  uint64_t v72 = &v10[2 * v71];
                  if (2 * v70 + 2 < (uint64_t)v12)
                  {
                    BOOL v73 = v72[1] < v72[3];
                    v72 += 2 * v73;
                    if (v73) {
                      uint64_t v71 = 2 * v70 + 2;
                    }
                  }
                  uint64_t v74 = v10[2 * v70 + 1];
                  if (v72[1] >= v74)
                  {
                    uint64_t result = &v10[2 * v70];
                    uint64_t v75 = *result;
                    do
                    {
                      int v76 = v72;
                      *uint64_t result = *v72;
                      result[1]  = v72[1];
                      if (v68 < v71) {
                        break;
                      }
                      uint64_t v77 = (2 * v71) | 1;
                      uint64_t v72 = &v10[2 * v77];
                      uint64_t v78 = 2 * v71 + 2;
                      if (v78 < (uint64_t)v12)
                      {
                        BOOL v73 = v72[1] < v72[3];
                        v72 += 2 * v73;
                        if (v73) {
                          uint64_t v77 = v78;
                        }
                      }
                      uint64_t result = v76;
                      uint64_t v71 = v77;
                    }
                    while (v72[1] >= v74);
                    *int v76 = v75;
                    v76[1]  = v74;
                  }
                }
                int64_t v69 = v70 - 1;
              }
              while (v70);
              uint64_t v79 = (unint64_t)v11 >> 4;
              do
              {
                uint64_t v80 = 0;
                uint64_t v81 = *v10;
                uint64_t v82 = v10[1];
                uint64_t v83 = v10;
                do
                {
                  uint64_t v84 = &v83[2 * v80 + 2];
                  uint64_t v85 = (2 * v80) | 1;
                  uint64_t v86 = 2 * v80 + 2;
                  if (v86 < v79)
                  {
                    uint64_t v87 = v84[1];
                    uint64_t v88 = v84[3];
                    v84 += 2 * (v87 < v88);
                    if (v87 < v88) {
                      uint64_t v85 = v86;
                    }
                  }
                  *uint64_t v83 = *v84;
                  v83[1]  = v84[1];
                  uint64_t v83 = v84;
                  uint64_t v80 = v85;
                }
                while (v85 <= (uint64_t)((unint64_t)(v79 - 2) >> 1));
                if (v84 == a2 - 2)
                {
                  *uint64_t v84 = v81;
                  v84[1]  = v82;
                }
                else
                {
                  *uint64_t v84 = *(a2 - 2);
                  v84[1]  = *(a2 - 1);
                  *(a2 - 2)  = v81;
                  *(a2 - 1)  = v82;
                  uint64_t v89 = (char *)v84 - (char *)v10 + 16;
                  if (v89 >= 17)
                  {
                    unint64_t v90 = (((unint64_t)v89 >> 4) - 2) >> 1;
                    uint64_t v91 = v84[1];
                    if (v10[2 * v90 + 1] < v91)
                    {
                      uint64_t v92 = *v84;
                      do
                      {
                        BOOL v93 = v84;
                        uint64_t v84 = &v10[2 * v90];
                        uint64_t *v93 = *v84;
                        v93[1]  = v84[1];
                        if (!v90) {
                          break;
                        }
                        unint64_t v90 = (v90 - 1) >> 1;
                      }
                      while (v10[2 * v90 + 1] < v91);
                      *uint64_t v84 = v92;
                      v84[1]  = v91;
                    }
                  }
                }
                a2 -= 2;
                BOOL v73 = v79-- <= 2;
              }
              while (!v73);
            }
            return result;
          }
          unint64_t v13 = v12 >> 1;
          uint64_t v14 = &v10[2 * (v12 >> 1)];
          if ((unint64_t)v11 >= 0x801)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TRunGlue::SeparateCharactersInGlyphRange(CFRange)::$_0 &,std::pair<long,long> *>(v9, &v9[2 * (v12 >> 1)], a2 - 2);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TRunGlue::SeparateCharactersInGlyphRange(CFRange)::$_0 &,std::pair<long,long> *>(v9 + 2, v14 - 2, a2 - 4);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TRunGlue::SeparateCharactersInGlyphRange(CFRange)::$_0 &,std::pair<long,long> *>(v9 + 4, &v9[2 * v13 + 2], a2 - 6);
            uint64_t result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TRunGlue::SeparateCharactersInGlyphRange(CFRange)::$_0 &,std::pair<long,long> *>(v14 - 2, v14, &v9[2 * v13 + 2]);
            long long v15 = *(_OWORD *)v9;
            *(_OWORD *)uint64_t v9 = *(_OWORD *)v14;
            *(_OWORD *)uint64_t v14 = v15;
          }
          else
          {
            uint64_t result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TRunGlue::SeparateCharactersInGlyphRange(CFRange)::$_0 &,std::pair<long,long> *>(&v9[2 * (v12 >> 1)], v9, a2 - 2);
          }
          --a3;
          if (a4) {
            break;
          }
          uint64_t v16 = v9[1];
          if (*(v9 - 1) < v16) {
            goto LABEL_13;
          }
          if (v16 >= *(a2 - 1))
          {
            long long v34 = v9 + 2;
            do
            {
              uint64_t v10 = v34;
              if (v34 >= a2) {
                break;
              }
              uint64_t v35 = v34[1];
              v34 += 2;
            }
            while (v16 >= v35);
          }
          else
          {
            int v32 = v9;
            do
            {
              uint64_t v10 = v32 + 2;
              uint64_t v33 = v32[3];
              v32 += 2;
            }
            while (v16 >= v33);
          }
          unint64_t v36 = a2;
          if (v10 < a2)
          {
            BOOL v37 = a2;
            do
            {
              unint64_t v36 = v37 - 2;
              uint64_t v38 = *(v37 - 1);
              v37 -= 2;
            }
            while (v16 < v38);
          }
          uint64_t v39 = *v9;
          while (v10 < v36)
          {
            uint64_t v40 = *v10;
            *uint64_t v10 = *v36;
            *unint64_t v36 = v40;
            uint64_t v41 = v10[1];
            v10[1]  = v36[1];
            v36[1]  = v41;
            do
            {
              uint64_t v42 = v10[3];
              v10 += 2;
            }
            while (v16 >= v42);
            do
            {
              uint64_t v43 = *(v36 - 1);
              v36 -= 2;
            }
            while (v16 < v43);
          }
          BOOL v4 = v10 - 2 >= v9;
          BOOL v5 = v10 - 2 == v9;
          if (v10 - 2 != v9)
          {
            uint64_t *v9 = *(v10 - 2);
            v9[1]  = *(v10 - 1);
          }
          a4  = 0;
          *(v10 - 2)  = v39;
          *(v10 - 1)  = v16;
        }
        uint64_t v16 = v9[1];
LABEL_13:
        uint64_t v17 = 0;
        uint64_t v18 = *v9;
        do
        {
          uint64_t v19 = v9[v17 + 3];
          v17 += 2;
        }
        while (v19 < v16);
        uint64_t v20 = &v9[v17];
        uint64_t v21 = a2;
        if (v17 == 2)
        {
          int v24 = a2;
          while (v20 < v24)
          {
            uint64_t v22 = v24 - 2;
            uint64_t v25 = *(v24 - 1);
            v24 -= 2;
            if (v25 < v16) {
              goto LABEL_23;
            }
          }
          uint64_t v22 = v24;
        }
        else
        {
          do
          {
            uint64_t v22 = v21 - 2;
            uint64_t v23 = *(v21 - 1);
            v21 -= 2;
          }
          while (v23 >= v16);
        }
LABEL_23:
        if (v20 >= v22)
        {
          uint64_t v10 = v20;
        }
        else
        {
          uint64_t v26 = v22;
          uint64_t v10 = v20;
          do
          {
            uint64_t v27 = *v10;
            *uint64_t v10 = *v26;
            uint64_t *v26 = v27;
            uint64_t v28 = v10[1];
            v10[1]  = v26[1];
            v26[1]  = v28;
            do
            {
              uint64_t v29 = v10[3];
              v10 += 2;
            }
            while (v29 < v16);
            do
            {
              uint64_t v30 = *(v26 - 1);
              v26 -= 2;
            }
            while (v30 >= v16);
          }
          while (v10 < v26);
        }
        if (v10 - 2 != v9)
        {
          uint64_t *v9 = *(v10 - 2);
          v9[1]  = *(v10 - 1);
        }
        *(v10 - 2)  = v18;
        *(v10 - 1)  = v16;
        if (v20 >= v22) {
          break;
        }
LABEL_36:
        uint64_t result = (uint64_t *)std::__introsort<std::_ClassicAlgPolicy,TRunGlue::SeparateCharactersInGlyphRange(CFRange)::$_0 &,std::pair<long,long> *,false>(v9, v10 - 2, a3, a4 & 1);
        a4  = 0;
      }
      BOOL v31 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,TRunGlue::SeparateCharactersInGlyphRange(CFRange)::$_0 &,std::pair<long,long> *>(v9, v10 - 2);
      uint64_t result = (uint64_t *)std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,TRunGlue::SeparateCharactersInGlyphRange(CFRange)::$_0 &,std::pair<long,long> *>(v10, a2);
      if (result) {
        break;
      }
      if (!v31) {
        goto LABEL_36;
      }
    }
    a2  = v10 - 2;
    if (!v31) {
      continue;
    }
    return result;
  }
}

uint64_t *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TRunGlue::SeparateCharactersInGlyphRange(CFRange)::$_0 &,std::pair<long,long> *>(uint64_t *result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = a2 + 1;
  uint64_t v4 = a2[1];
  BOOL v5 = result + 1;
  uint64_t v6 = a3[1];
  if (v4 < result[1])
  {
    uint64_t v7 = *result;
    if (v6 >= v4)
    {
      *uint64_t result = *a2;
      *a2  = v7;
      uint64_t v11 = result[1];
      result[1]  = a2[1];
      a2[1]  = v11;
      if (a3[1] >= v11) {
        return result;
      }
      uint64_t v12 = *a2;
      *a2  = *a3;
      *a3  = v12;
      BOOL v5 = a2 + 1;
    }
    else
    {
      *uint64_t result = *a3;
      *a3  = v7;
    }
    uint64_t v3 = a3 + 1;
    goto LABEL_10;
  }
  if (v6 < v4)
  {
    uint64_t v8 = *a2;
    *a2  = *a3;
    *a3  = v8;
    uint64_t v9 = a2[1];
    a2[1]  = a3[1];
    a3[1]  = v9;
    if (a2[1] < *v5)
    {
      uint64_t v10 = *result;
      *uint64_t result = *a2;
      *a2  = v10;
LABEL_10:
      uint64_t v13 = *v5;
      *BOOL v5 = *v3;
      *uint64_t v3 = v13;
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,TRunGlue::SeparateCharactersInGlyphRange(CFRange)::$_0 &,std::pair<long,long> *>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = ((char *)a2 - (char *)a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (*(a2 - 1) < a1[1])
      {
        uint64_t v6 = *a1;
        *a1  = *(a2 - 2);
        *(a2 - 2)  = v6;
        uint64_t v7 = a1[1];
        a1[1]  = *(a2 - 1);
        *(a2 - 1)  = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TRunGlue::SeparateCharactersInGlyphRange(CFRange)::$_0 &,std::pair<long,long> *>(a1, a1 + 2, a2 - 2);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,TRunGlue::SeparateCharactersInGlyphRange(CFRange)::$_0 &,std::pair<long,long> *>(a1, a1 + 2, a1 + 4, a2 - 2);
      return 1;
    case 5:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,TRunGlue::SeparateCharactersInGlyphRange(CFRange)::$_0 &,std::pair<long,long> *>(a1, a1 + 2, a1 + 4, a1 + 6);
      if (*(a2 - 1) < a1[7])
      {
        uint64_t v18 = a1[6];
        a1[6]  = *(a2 - 2);
        *(a2 - 2)  = v18;
        uint64_t v19 = a1[7];
        a1[7]  = *(a2 - 1);
        *(a2 - 1)  = v19;
        uint64_t v20 = a1[7];
        uint64_t v21 = a1[5];
        if (v20 < v21)
        {
          uint64_t v22 = a1[6];
          uint64_t v23 = a1[3];
          uint64_t v24 = a1[4];
          a1[4]  = v22;
          a1[5]  = v20;
          a1[6]  = v24;
          a1[7]  = v21;
          if (v20 < v23)
          {
            uint64_t v25 = a1[1];
            uint64_t v26 = a1[2];
            a1[2]  = v22;
            a1[3]  = v20;
            a1[4]  = v26;
            a1[5]  = v23;
            if (v20 < v25)
            {
              uint64_t v27 = *a1;
              *a1  = v22;
              a1[1]  = v20;
              a1[2]  = v27;
              a1[3]  = v25;
            }
          }
        }
      }
      return 1;
    default:
      uint64_t v8 = a1 + 4;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TRunGlue::SeparateCharactersInGlyphRange(CFRange)::$_0 &,std::pair<long,long> *>(a1, a1 + 2, a1 + 4);
      uint64_t v9 = a1 + 6;
      if (a1 + 6 == a2) {
        return 1;
      }
      uint64_t v10 = 0;
      int v11 = 0;
      break;
  }
  while (1)
  {
    uint64_t v12 = v9[1];
    if (v12 < v8[1])
    {
      uint64_t v13 = *v9;
      uint64_t v14 = v10;
      while (1)
      {
        long long v15 = (uint64_t *)((char *)a1 + v14);
        uint64_t v16 = *(uint64_t *)((char *)a1 + v14 + 40);
        v15[6]  = *(uint64_t *)((char *)a1 + v14 + 32);
        v15[7]  = v16;
        if (v14 == -32) {
          break;
        }
        v14 -= 16;
        if (v12 >= v15[3])
        {
          uint64_t v17 = (uint64_t *)((char *)a1 + v14 + 48);
          goto LABEL_13;
        }
      }
      uint64_t v17 = a1;
LABEL_13:
      *uint64_t v17 = v13;
      v17[1]  = v12;
      if (++v11 == 8) {
        return v9 + 2 == a2;
      }
    }
    uint64_t v8 = v9;
    v10 += 16;
    v9 += 2;
    if (v9 == a2) {
      return 1;
    }
  }
}

uint64_t *std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,TRunGlue::SeparateCharactersInGlyphRange(CFRange)::$_0 &,std::pair<long,long> *>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  BOOL result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TRunGlue::SeparateCharactersInGlyphRange(CFRange)::$_0 &,std::pair<long,long> *>(a1, a2, a3);
  if (a4[1] < a3[1])
  {
    uint64_t v9 = *a3;
    *a3  = *a4;
    *a4  = v9;
    uint64_t v10 = a3[1];
    a3[1]  = a4[1];
    a4[1]  = v10;
    if (a3[1] < a2[1])
    {
      uint64_t v11 = *a2;
      *a2  = *a3;
      *a3  = v11;
      uint64_t v12 = a2[1];
      a2[1]  = a3[1];
      a3[1]  = v12;
      if (a2[1] < a1[1])
      {
        uint64_t v13 = *a1;
        *a1  = *a2;
        *a2  = v13;
        uint64_t v14 = a1[1];
        a1[1]  = a2[1];
        a2[1]  = v14;
      }
    }
  }
  return result;
}

void std::vector<unsigned char,TInlineBufferAllocator<unsigned char,128ul>>::__append(void *a1, size_t a2)
{
  uint64_t v6 = a1 + 1;
  uint64_t v4 = (char *)a1[1];
  uint64_t v5 = v6[1];
  if (v5 - (uint64_t)v4 >= a2)
  {
    if (a2)
    {
      uint64_t v12 = &v4[a2];
      bzero(v4, a2);
      uint64_t v4 = v12;
    }
    a1[1]  = v4;
  }
  else
  {
    uint64_t v7 = &v4[-*a1];
    unint64_t v8 = (unint64_t)&v7[a2];
    if ((uint64_t)&v7[a2] < 0) {
      abort();
    }
    unint64_t v9 = v5 - *a1;
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v10 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v10 = v8;
    }
    if (v10)
    {
      uint64_t v11 = (void *)a1[19];
      if ((char *)v11 + v10 <= (char *)(a1 + 19)) {
        a1[19]  = (char *)v11 + v10;
      }
      else {
        uint64_t v11 = operator new(v10);
      }
    }
    else
    {
      uint64_t v11 = 0;
    }
    uint64_t v13 = &v7[(void)v11];
    uint64_t v14 = (char *)v11 + v10;
    long long v15 = &v13[a2];
    bzero(v13, a2);
    uint64_t v17 = (char *)*a1;
    uint64_t v16 = (char *)a1[1];
    if (v16 != (char *)*a1)
    {
      do
      {
        char v18 = *--v16;
        *--uint64_t v13 = v18;
      }
      while (v16 != v17);
      uint64_t v16 = (char *)*a1;
    }
    *a1  = v13;
    a1[1]  = v15;
    uint64_t v19 = a1[2];
    a1[2]  = v14;
    if (v16)
    {
      uint64_t v20 = (char *)(a1 + 19);
      if (a1 + 3 <= (void *)v16 && v20 > v16)
      {
        if (v19 == *(void *)v20) {
          *(void *)uint64_t v20 = v16;
        }
      }
      else
      {
        operator delete(v16);
      }
    }
  }
}

char **std::vector<TGlyphAuxDataListEntry,TInlineBufferAllocator<TGlyphAuxDataListEntry,30ul>>::insert(char **result, uint64_t a2, unint64_t a3, char *a4)
{
  if (a3)
  {
    uint64_t v4 = a4;
    uint64_t v6 = result;
    unint64_t v8 = *result;
    uint64_t v7 = result[1];
    uint64_t v9 = a2 - (void)*result;
    size_t v10 = &(*result)[v9 & 0xFFFFFFFFFFFFFFF0];
    uint64_t v11 = result[2];
    if (a3 <= (v11 - v7) >> 4)
    {
      uint64_t v18 = v7 - v10;
      if (a3 <= (v7 - v10) >> 4)
      {
        uint64_t v21 = result[1];
        uint64_t v20 = a3;
      }
      else
      {
        uint64_t v19 = 0;
        uint64_t v20 = v18 >> 4;
        uint64_t v21 = &v7[16 * (a3 - (v18 >> 4))];
        do
        {
          *(_OWORD *)&v7[v19]  = *(_OWORD *)a4;
          v19 += 16;
        }
        while (16 * a3 - 16 * v20 != v19);
        result[1]  = v21;
        if (v7 == v10) {
          return result;
        }
      }
      uint64_t v22 = &v10[16 * a3];
      uint64_t v23 = &v21[-16 * a3];
      uint64_t v24 = v21;
      if (v23 < v7)
      {
        uint64_t v24 = v21;
        do
        {
          long long v25 = *(_OWORD *)v23;
          v23 += 16;
          *(_OWORD *)uint64_t v24 = v25;
          v24 += 16;
        }
        while (v23 < v7);
      }
      result[1]  = v24;
      if (v21 != v22) {
        BOOL result = (char **)memmove(&v21[-16 * ((v21 - v22) >> 4)], v10, v21 - v22);
      }
      if (v10 <= v4)
      {
        if (v6[1] <= v4) {
          unint64_t v26 = 0;
        }
        else {
          unint64_t v26 = a3;
        }
        v4 += 16 * v26;
      }
      do
      {
        *(_OWORD *)size_t v10 = *(_OWORD *)v4;
        v10 += 16;
        --v20;
      }
      while (v20);
    }
    else
    {
      unint64_t v12 = a3 + ((v7 - v8) >> 4);
      if (v12 >> 60) {
        abort();
      }
      uint64_t v13 = v9 >> 4;
      uint64_t v14 = (uint64_t)(result + 3);
      uint64_t v15 = v11 - v8;
      if (v15 >> 3 > v12) {
        unint64_t v12 = v15 >> 3;
      }
      if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v16 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v16 = v12;
      }
      v39[4]  = v6 + 3;
      if (v16) {
        uint64_t v17 = TInlineBufferAllocator<CGPoint,30ul>::allocate(v14, v16);
      }
      else {
        uint64_t v17 = 0;
      }
      uint64_t v27 = &v17[16 * v13];
      uint64_t v28 = &v17[16 * v16];
      uint64_t v29 = 16 * a3;
      uint64_t v30 = v27;
      BOOL v31 = &v27[16 * a3];
      do
      {
        *(_OWORD *)uint64_t v30 = *(_OWORD *)v4;
        v30 += 16;
        v29 -= 16;
      }
      while (v29);
      int v32 = *v6;
      if (*v6 == v10)
      {
        long long v34 = &v17[16 * v13];
      }
      else
      {
        uint64_t v33 = v10;
        do
        {
          long long v34 = v27 - 16;
          *((_OWORD *)v27 - 1)  = *((_OWORD *)v33 - 1);
          v33 -= 16;
          v27 -= 16;
        }
        while (v33 != v32);
      }
      uint64_t v35 = v6[1];
      int64_t v36 = v35 - v10;
      if (v35 != v10)
      {
        memmove(v31, v10, v35 - v10);
        size_t v10 = v6[1];
      }
      BOOL v37 = *v6;
      *uint64_t v6 = v34;
      v6[1]  = &v31[v36];
      uint64_t v38 = v6[2];
      id v6[2] = v28;
      v39[2]  = v10;
      v39[3]  = v38;
      v39[0]  = v37;
      v39[1]  = v37;
      return (char **)std::__split_buffer<std::tuple<unsigned short,unsigned short,long>,TInlineBufferAllocator<std::tuple<unsigned short,unsigned short,long>,30ul> &>::~__split_buffer((uint64_t)v39);
    }
  }
  return result;
}

uint64_t TRunGlue::SetAttachmentCount(TRunGlue *this, uint64_t a2, uint64_t a3)
{
  uint64_t result = TRunGlue::FocusOnIndex(this, a2);
  uint64_t v7 = *((void *)this + 19);
  if (v7)
  {
    unint64_t v8 = *(void **)(v7 + 216);
    uint64_t v9 = a2 - *((void *)this + 20) + *(void *)(v7 + 200);
    return [v8 setAttachmentCount:a3 atIndex:v9];
  }
  return result;
}

BOOL IsRightAssociative(uint64_t a1)
{
  if (qword_1EB2CE398 != -1) {
    dispatch_once_f(&qword_1EB2CE398, 0, (dispatch_function_t)IsRightAssociative::$_0::__invoke);
  }
  return MEMORY[0x185328270](_MergedGlobals_21, a1) != 0;
}

void TOpenTypeMorph::SetLookups(TOpenTypeMorph *this, unsigned int *a2, OTL::GlyphLookups *a3)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *((void *)this + 4);
  uint64_t v27 = *((void *)this + 5) - v4;
  if (v27) {
    BOOL v5 = v4 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5)
  {
    unsigned int v6 = *a2;
    if (*a2)
    {
      uint64_t v8 = 0;
      uint64_t v9 = v27 >> 4;
      uint64_t v30 = (char *)this + 640;
      do
      {
        uint64_t v29 = v8;
        unint64_t v39 = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v10 + 1)  = 0xAAAAAAAAAAAAAAAALL;
        v38[5]  = v10;
        v38[6]  = v10;
        v38[3]  = v10;
        v38[4]  = v10;
        v38[1]  = v10;
        v38[2]  = v10;
        v38[0]  = v10;
        int64_t v36 = 0;
        uint64_t v37 = 0;
        uint64_t v35 = 0;
        uint64_t v40 = v38;
        if (v27 >= 1)
        {
          uint64_t v11 = 0;
          uint64_t v31 = 0;
          char v12 = 1;
          do
          {
            if (v9 <= v11 + 1) {
              uint64_t v13 = v11 + 1;
            }
            else {
              uint64_t v13 = v27 >> 4;
            }
            uint64_t v14 = v11;
            while (1)
            {
              uint64_t v15 = *(int **)(v4 + 16 * v14);
              if (v15)
              {
                int v16 = *v15;
                if (*v15) {
                  break;
                }
              }
LABEL_18:
              if (++v14 >= v9)
              {
                uint64_t v14 = v13;
                goto LABEL_21;
              }
            }
            uint64_t v17 = v15 + 1;
            while (v16 != v6)
            {
              int v18 = *v17++;
              int v16 = v18;
              if (!v18) {
                goto LABEL_18;
              }
            }
            uint64_t v31 = *(unsigned int *)(v4 + 16 * v14 + 12);
LABEL_21:
            if (v14 == v9) {
              break;
            }
            uint64_t v11 = v14 + 1;
            if (v14 + 1 < v9)
            {
              while (1)
              {
                uint64_t v19 = *(int **)(v4 + 16 * v11);
                if (!v19) {
                  break;
                }
                if (v31 != *(_DWORD *)(v4 + 16 * v11 + 12)) {
                  break;
                }
                int v20 = *v19;
                if (!*v19) {
                  break;
                }
                uint64_t v21 = v19 + 1;
                while (v20 != v6)
                {
                  int v22 = *v21++;
                  int v20 = v22;
                  if (!v22) {
                    goto LABEL_32;
                  }
                }
                if (++v11 == v9)
                {
                  uint64_t v11 = v27 >> 4;
                  break;
                }
              }
            }
LABEL_32:
            if (v12)
            {
              unsigned int v32 = v6;
              OTL::FeatureBuffer::FeatureBuffer<unsigned int const*>(v34, &v32, &v33);
              Lookups  = OTL::GCommon::GetLookups((uint64_t)v30, (uint64_t)v34, (uint64_t)&v35, 0);
              uint64_t v33 = v34;
              std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v33);
              if (!Lookups) {
                break;
              }
            }
            uint64_t v24 = v35;
            long long v25 = v36;
            while (v24 != v25)
            {
              unsigned int v26 = *v24++;
              unint64_t v3 = v3 & 0xFFFFFFFF00000000 | v26;
              OTL::GlyphLookups::SetLookupInRange<false>((uint64_t *)a3, v3, v14, v11 - v14);
            }
            char v12 = 0;
          }
          while (v11 < v9);
        }
        v34[0]  = (char *)&v35;
        std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v34);
        uint64_t v8 = v29 + 1;
        unsigned int v6 = a2[v29 + 1];
      }
      while (v6);
    }
  }
}

void TOpenTypeMorph::SetPresentationLookups(TOpenTypeMorph *this, const unsigned int *a2, OTL::GlyphLookups *a3)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *((void *)this + 4);
  uint64_t v3 = *((void *)this + 5);
  if (v3 != v4 && v4 != 0)
  {
    uint64_t v8 = 0;
    *(void *)&long long v9 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v9 + 1)  = 0xAAAAAAAAAAAAAAAALL;
    v43[6]  = v9;
    v43[5]  = v9;
    uint64_t v35 = v3 - v4;
    uint64_t v10 = (v3 - v4) >> 4;
    v43[4]  = v9;
    v43[2]  = v9;
    v43[3]  = v9;
    v43[0]  = v9;
    v43[1]  = v9;
    uint64_t v41 = 0;
    uint64_t v42 = 0;
    uint64_t v40 = 0;
    unint64_t v44 = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v45 = v43;
    long long v34 = (char *)this + 640;
    unint64_t v11 = (unint64_t)v48;
    v48[14]  = v9;
    v48[13]  = v9;
    v48[12]  = v9;
    v48[11]  = v9;
    v48[10]  = v9;
    v48[9]  = v9;
    v48[8]  = v9;
    v48[7]  = v9;
    v48[6]  = v9;
    v48[5]  = v9;
    v48[4]  = v9;
    v48[3]  = v9;
    v48[2]  = v9;
    v48[1]  = v9;
    v48[0]  = v9;
    int64x2_t v46 = 0uLL;
    uint64_t v47 = 0;
    uint64_t v49 = v48;
    do
    {
      if (v8 >= v47)
      {
        uint64_t v12 = (uint64_t)&v8[-v46.i64[0]] >> 3;
        if ((unint64_t)(v12 + 1) >> 61) {
          abort();
        }
        unint64_t v13 = (uint64_t)&v47[-v46.i64[0]] >> 2;
        if (v13 <= v12 + 1) {
          unint64_t v13 = v12 + 1;
        }
        if ((unint64_t)&v47[-v46.i64[0]] >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v14 = v13;
        }
        unint64_t v39 = v48;
        uint64_t v15 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)v48, v14);
        int v16 = &v15[8 * v12];
        *(_DWORD *)int v16 = *a2;
        *((_DWORD *)v16 + 1)  = 1;
        uint64_t v17 = v46.i64[1];
        uint64_t v18 = v46.i64[0];
        if (v46.i64[1] == v46.i64[0])
        {
          int64x2_t v21 = vdupq_n_s64(v46.u64[1]);
          uint64_t v19 = &v15[8 * v12];
        }
        else
        {
          uint64_t v19 = &v15[8 * v12];
          do
          {
            uint64_t v20 = *(void *)(v17 - 8);
            v17 -= 8;
            *((void *)v19 - 1)  = v20;
            v19 -= 8;
          }
          while (v17 != v18);
          int64x2_t v21 = v46;
        }
        uint64_t v8 = v16 + 8;
        v46.i64[0]  = (uint64_t)v19;
        v46.i64[1]  = (uint64_t)(v16 + 8);
        int64x2_t v37 = v21;
        int v22 = v47;
        uint64_t v47 = &v15[8 * v14];
        uint64_t v38 = v22;
        int64_t v36 = (int64x2_t *)v21.i64[0];
        std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)&v36);
      }
      else
      {
        *(_DWORD *)uint64_t v8 = *a2;
        *((_DWORD *)v8 + 1)  = 1;
        v8 += 8;
      }
      v46.i64[1]  = (uint64_t)v8;
    }
    while (*a2++);
    Lookups  = OTL::GCommon::GetLookups((uint64_t)v34, (uint64_t)&v46, (uint64_t)&v40, 0);
    int64_t v36 = &v46;
    std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v36);
    if (v35 >= 1 && Lookups)
    {
      uint64_t v25 = 0;
      do
      {
        uint64_t v26 = v25;
        int v27 = *(_DWORD *)(v4 + 16 * v25 + 12);
        if (v10 <= v25 + 1) {
          uint64_t v28 = v25 + 1;
        }
        else {
          uint64_t v28 = v10;
        }
        uint64_t v29 = (int *)(v4 + 28 + 16 * v25);
        while (v28 - 1 != v25)
        {
          ++v25;
          int v30 = *v29;
          v29 += 4;
          if (v30 != v27) {
            goto LABEL_32;
          }
        }
        uint64_t v25 = v28;
LABEL_32:
        unsigned int v32 = v40;
        uint64_t v31 = v41;
        while (v32 != v31)
        {
          unsigned int v33 = *v32++;
          unint64_t v11 = v11 & 0xFFFFFFFF00000000 | v33;
          OTL::GlyphLookups::SetLookupInRange<false>((uint64_t *)a3, v11, v26, v25 - v26);
        }
      }
      while (v25 < v10);
    }
    v46.i64[0]  = (uint64_t)&v40;
    std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v46);
  }
}

void TOpenTypeMorph::SetInitLookups(TOpenTypeMorph *this, OTL::GlyphLookups *a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)this + 4);
  if (v2)
  {
    unint64_t v4 = *((void *)this + 5);
    *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v5 + 1)  = 0xAAAAAAAAAAAAAAAALL;
    v21[6]  = v5;
    v21[5]  = v5;
    v21[4]  = v5;
    v21[3]  = v5;
    v21[2]  = v5;
    v21[1]  = v5;
    v21[0]  = v5;
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    uint64_t v18 = 0;
    unsigned int v6 = (char *)this + 640;
    unint64_t v22 = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v23 = v21;
    int v15 = 1768843636;
    OTL::FeatureBuffer::FeatureBuffer<unsigned int const*>(v17, &v15, &v16);
    LODWORD(v6)  = OTL::GCommon::GetLookups((uint64_t)v6, (uint64_t)v17, (uint64_t)&v18, 0);
    int v16 = v17;
    std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v16);
    if (v6 && (uint64_t)(v4 - v2) >= 1)
    {
      uint64_t v7 = 0;
      if ((uint64_t)(v4 - v2) >> 4 <= 1) {
        uint64_t v8 = 1;
      }
      else {
        uint64_t v8 = (uint64_t)(v4 - v2) >> 4;
      }
      uint64_t v9 = -1;
      do
      {
        uint64_t v10 = v2 + 16 * v7;
        uint64_t v11 = *(unsigned int *)(v10 + 12);
        if (v9 != v11)
        {
          if ((*(_DWORD *)(v10 + 8) & 0x70FFFF) != 0x400006
            || v7 && *(_WORD *)(v2 + 16 * v7 - 8)
            || (unint64_t v13 = v18, v12 = v19, v18 == v19))
          {
            uint64_t v9 = *(unsigned int *)(v10 + 12);
          }
          else
          {
            do
            {
              unsigned int v14 = *v13++;
              unint64_t v4 = v4 & 0xFFFFFFFF00000000 | v14;
              OTL::GlyphLookups::SetLookupInRange<false>((uint64_t *)a2, v4, v7, 1);
            }
            while (v13 != v12);
            uint64_t v9 = v11;
          }
        }
        ++v7;
      }
      while (v7 != v8);
    }
    v17[0]  = (char *)&v18;
    std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v17);
  }
}

void TOpenTypeMorph::ApplyVerticalGlyphs(TOpenTypeMorph *this)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  HasAvailable  = StackHasAvailable(0x4000uLL);
  if (HasAvailable)
  {
    uint64_t v3 = *(void *)(*(void *)this + 104);
    *(void *)(*(void *)this + 104)  = (char *)this + 32;
    uint64_t v4 = *(void *)this;
    unint64_t v5 = *(void *)(*(void *)this + 624);
    if (v5 <= 0x10000) {
      unint64_t v6 = (v5 + 7) >> 3;
    }
    else {
      unint64_t v6 = 0x2000;
    }
    MEMORY[0x1F4188790](HasAvailable, v6);
    uint64_t v8 = &v19[-v7];
    bzero(&v19[-v7], v9);
    TRunGlue::DetermineCoverage(v4, v8);
    uint64_t v21 = *(void *)"2trvtrev";
    int v22 = 0;
    *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v10 + 1)  = 0xAAAAAAAAAAAAAAAALL;
    v34[8]  = v10;
    v34[7]  = v10;
    v34[6]  = v10;
    v34[5]  = v10;
    v34[4]  = v10;
    v34[3]  = v10;
    v34[2]  = v10;
    v34[1]  = v10;
    v34[0]  = v10;
    uint64_t v35 = v34;
    memset(v33, 0, sizeof(v33));
    if (OTL::GCommon::GetFeatures((TOpenTypeMorph *)((char *)this + 640), (OTL::FeatureList *)v33)
      && OTL::FeatureList::StripMissingFeaturesFrom(v33, (unsigned int *)&v21))
    {
      unint64_t v31 = 0xAAAAAAAAAAAAAAAALL;
      unint64_t v11 = (unint64_t)&v27;
      *(void *)&long long v12 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v12 + 1)  = 0xAAAAAAAAAAAAAAAALL;
      v30[6]  = v12;
      v30[5]  = v12;
      v30[4]  = v12;
      void v30[3] = v12;
      v30[2]  = v12;
      v30[1]  = v12;
      v30[0]  = v12;
      uint64_t v28 = 0;
      uint64_t v29 = 0;
      int v27 = 0;
      unsigned int v32 = v30;
      int v20 = v21;
      OTL::FeatureBuffer::FeatureBuffer<unsigned int const*>((char **)v24, &v20, &v21);
      BOOL SingleSubstLookups = OTL::GSUB::GetSingleSubstLookups((void *)this + 80, (uint64_t)v24, (uint64_t)&v27);
      uint64_t v23 = v24;
      std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v23);
      if (SingleSubstLookups)
      {
        memset(v25, 170, sizeof(v25));
        memset(v24, 0, sizeof(v24));
        uint64_t v26 = v25;
        uint64_t v14 = TRunGlue::length(*(TRunGlue **)this);
        int v15 = v27;
        int v16 = v28;
        if (v27 != v28)
        {
          uint64_t v17 = v14;
          do
          {
            unsigned int v18 = *v15++;
            unint64_t v11 = v11 & 0xFFFFFFFF00000000 | v18;
            OTL::GlyphLookups::SetLookupInRange<false>((uint64_t *)v24, v11, 0, v17);
          }
          while (v15 != v16);
        }
        LOBYTE(v23)  = 0;
        OTL::GSUB::ApplyLookups((void *)this + 80, *(TRunGlue **)this, *((_DWORD *)this + 4), (unsigned __int16 **)v24, &v23, 0, 0);
        uint64_t v23 = v24;
        std::vector<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,TInlineBufferAllocator<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v23);
      }
      v24[0]  = (void **)&v27;
      std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100](v24);
    }
    *(void *)(*(void *)this + 104)  = v3;
    v24[0]  = (void **)v33;
    std::vector<unsigned int,TInlineBufferAllocator<unsigned int,36ul>>::__destroy_vector::operator()[abi:nn180100](v24);
  }
}

uint64_t TOpenTypeMorph::AddVariantsOfGlyph(uint64_t a1, __int16 a2, uint64_t a3)
{
  v30[4]  = *MEMORY[0x1E4F143B8];
  __int16 v29 = a2;
  CFDataRef CommonTable = (const __CFData *)TBaseFont::GetCommonTable(*(TBaseFont **)(a1 + 400), 1196643650, 0);
  if (!CommonTable) {
    return 1;
  }
  CFDataRef v6 = CommonTable;
  BytePtr  = CFDataGetBytePtr(CommonTable);
  uint64_t v28 = BytePtr;
  uint64_t v8 = CFDataGetBytePtr(v6);
  if (v8) {
    unint64_t v9 = (unint64_t)&v8[CFDataGetLength(v6)];
  }
  else {
    unint64_t v9 = 0;
  }
  unint64_t v27 = v9;
  if (!*((_WORD *)BytePtr + 3)) {
    return 0;
  }
  unint64_t v11 = (UInt8 *)&BytePtr[__rev16(*((unsigned __int16 *)BytePtr + 3))];
  long long v12 = v11 + 2;
  if ((unint64_t)(v11 + 2) > v9) {
    return 0;
  }
  uint64_t v13 = bswap32(*(unsigned __int16 *)v11) >> 16;
  unint64_t v14 = (unint64_t)&v12[3 * v13];
  if (v14 < (unint64_t)v12 || v14 > v9)
  {
    unint64_t v16 = (v9 - (unint64_t)v12) / 6;
    if ((unint64_t)(v11 + 8) > v9) {
      unint64_t v16 = 0;
    }
    if (v16 != v13) {
      return 0;
    }
  }
  if (!*((_WORD *)BytePtr + 4)) {
    return 0;
  }
  uint64_t v17 = &BytePtr[__rev16(*((unsigned __int16 *)BytePtr + 4))];
  unsigned int v18 = (unsigned __int16 *)(v17 + 2);
  if ((unint64_t)(v17 + 2) > v9) {
    return 0;
  }
  uint64_t v19 = bswap32(*(unsigned __int16 *)v17) >> 16;
  unint64_t v20 = (unint64_t)&v18[v19];
  unint64_t v21 = (unint64_t)(v17 + 4) <= v9 ? (v9 - (unint64_t)v18) >> 1 : 0;
  BOOL v22 = v20 <= v9 && v20 >= (unint64_t)v18;
  if (!v22 && v21 != v19) {
    return 0;
  }
  uint64_t v26 = v17;
  uint64_t v24 = operator new(0x38uLL);
  void *v24 = &unk_1ED060F20;
  v24[1]  = a1;
  v24[2]  = &v28;
  v24[3]  = &v27;
  v24[4]  = &v26;
  v24[5]  = &v29;
  v24[6]  = a3;
  void v30[3] = v24;
  uint64_t v10 = OTL::GCommon::IterateFeatureTables((unint64_t)BytePtr, v11, v9, (uint64_t)v30);
  std::__function::__value_func<BOOL ()(unsigned int,OTL::FeatureTable const*,BOOL &)>::~__value_func[abi:nn180100](v30);
  return v10;
}

uint64_t TOpenTypeMorph::AddCoveredGlyphs(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v22[4]  = *MEMORY[0x1E4F143B8];
  uint64_t v21 = a2;
  uint64_t CommonTable = TBaseFont::GetCommonTable(*(TBaseFont **)(a1 + 400), 1196643650, 0);
  uint64_t v20 = CommonTable;
  if (!CommonTable) {
    return 1;
  }
  CFDataRef v8 = (const __CFData *)CommonTable;
  CFDataRef v9 = (const __CFData *)TBaseFont::GetCommonTable(*(TBaseFont **)(a1 + 400), 1195656518, 0);
  *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v10 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  v19[3]  = v10;
  v19[4]  = v10;
  v19[1]  = v10;
  v19[2]  = v10;
  v19[0]  = v10;
  OTL::GDEF::GDEF((OTL::GDEF *)v19, v9);
  BytePtr  = CFDataGetBytePtr(v8);
  unsigned int v18 = BytePtr;
  long long v12 = CFDataGetBytePtr(v8);
  if (v12) {
    unint64_t v13 = (unint64_t)&v12[CFDataGetLength(v8)];
  }
  else {
    unint64_t v13 = 0;
  }
  unint64_t v17 = v13;
  int v15 = operator new(0x48uLL);
  *int v15 = &unk_1ED060E90;
  v15[1]  = &v18;
  v15[2]  = &v17;
  v15[3]  = a1;
  v15[4]  = &v20;
  v15[5]  = v19;
  v15[6]  = &v21;
  v15[7]  = a3;
  v15[8]  = a4;
  v22[3]  = v15;
  uint64_t v14 = OTL::GCommon::IterateScriptTables((uint64_t)BytePtr, v13, (uint64_t)v22);
  std::__function::__value_func<BOOL ()(unsigned int,OTL::ScriptTable const*,BOOL &)>::~__value_func[abi:nn180100](v22);
  return v14;
}

uint64_t TOpenTypeMorph::AddShapingLanguages(TBaseFont *a1, uint64_t a2)
{
  v17[4]  = *MEMORY[0x1E4F143B8];
  uint64_t CommonTable = TBaseFont::GetCommonTable(a1, 1196643650, 0);
  if (!CommonTable) {
    return 1;
  }
  CFDataRef v5 = (const __CFData *)CommonTable;
  CFDataRef v6 = (const __CFData *)TBaseFont::GetCommonTable(a1, 1195656518, 0);
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  atomic_ullong v16[3] = v7;
  v16[4]  = v7;
  v16[1]  = v7;
  v16[2]  = v7;
  v16[0]  = v7;
  OTL::GDEF::GDEF((OTL::GDEF *)v16, v6);
  BytePtr  = CFDataGetBytePtr(v5);
  int v15 = BytePtr;
  CFDataRef v9 = CFDataGetBytePtr(v5);
  if (!v9) {
    return 0;
  }
  unint64_t v10 = (unint64_t)&v9[CFDataGetLength(v5)];
  unint64_t v14 = v10;
  if ((unint64_t)(BytePtr + 10) > v10
    || bswap32(*(unsigned __int16 *)BytePtr) >> 16 > 1
    || *((_WORD *)BytePtr + 1) && (unint64_t)(BytePtr + 14) > v10)
  {
    return 0;
  }
  unint64_t v11 = operator new(0x20uLL);
  void *v11 = &unk_1ED060F68;
  v11[1]  = &v15;
  v11[2]  = &v14;
  v11[3]  = a2;
  v17[3]  = v11;
  uint64_t v12 = OTL::GCommon::IterateScriptTables((uint64_t)BytePtr, v10, (uint64_t)v17);
  std::__function::__value_func<BOOL ()(unsigned int,OTL::ScriptTable const*,BOOL &)>::~__value_func[abi:nn180100](v17);
  return v12;
}

void *TOpenTypeMorph::EnumerateScriptRanges(uint64_t a1)
{
  v9[4]  = *MEMORY[0x1E4F143B8];
  std::__function::__value_func<void ()(unsigned int,CFRange)>::__value_func[abi:nn180100]((uint64_t)v9, a1);
  EnumeratePatternScriptRanges((uint64_t)L"[:script=Arab:]", 1634885986, (uint64_t)v9);
  std::__function::__value_func<void ()(unsigned int,CFRange)>::~__value_func[abi:nn180100](v9);
  std::__function::__value_func<void ()(unsigned int,CFRange)>::__value_func[abi:nn180100]((uint64_t)v8, a1);
  EnumeratePatternScriptRanges((uint64_t)L"[:block=Syriac:]", 1937338979, (uint64_t)v8);
  std::__function::__value_func<void ()(unsigned int,CFRange)>::~__value_func[abi:nn180100](v8);
  ThaiClassTable  = GetThaiClassTable();
  std::function<void ()(unsigned int,CFRange)>::operator()(a1, 1952997737, *((unsigned __int16 *)ThaiClassTable + 4), *((unsigned __int16 *)ThaiClassTable + 5) - (unint64_t)*((unsigned __int16 *)ThaiClassTable + 4) + 1);
  LaoClassTable  = GetLaoClassTable();
  std::function<void ()(unsigned int,CFRange)>::operator()(a1, 1818324768, *((unsigned __int16 *)LaoClassTable + 4), *((unsigned __int16 *)LaoClassTable + 5) - (unint64_t)*((unsigned __int16 *)LaoClassTable + 4) + 1);
  KhmerClassTable  = GetKhmerClassTable();
  std::function<void ()(unsigned int,CFRange)>::operator()(a1, 1802005874, *((unsigned __int16 *)KhmerClassTable + 4), *((unsigned __int16 *)KhmerClassTable + 5) - (unint64_t)*((unsigned __int16 *)KhmerClassTable + 4) + 1);
  std::__function::__value_func<void ()(unsigned int,CFRange)>::__value_func[abi:nn180100]((uint64_t)v7, a1);
  EnumeratePatternScriptRanges((uint64_t)"[", 1751215719, (uint64_t)v7);
  std::__function::__value_func<void ()(unsigned int,CFRange)>::~__value_func[abi:nn180100](v7);
  std::__function::__value_func<void ()(unsigned int,CFRange)>::__value_func[abi:nn180100]((uint64_t)v6, a1);
  UniversalClassTable::EnumerateScriptRanges((uint64_t)v6);
  return std::__function::__value_func<void ()(unsigned int,CFRange)>::~__value_func[abi:nn180100](v6);
}

uint64_t EnumeratePatternScriptRanges(uint64_t a1, int a2, uint64_t a3)
{
  v13[4]  = *MEMORY[0x1E4F143B8];
  int v9 = 0;
  uint64_t result = uset_openPattern();
  if (result)
  {
    uint64_t v6 = result;
    int v10 = a2;
    std::__function::__value_func<void ()(unsigned int,CFRange)>::__value_func[abi:nn180100]((uint64_t)v11, a3);
    long long v7 = operator new(0x30uLL);
    CFDataRef v8 = v7;
    *(void *)long long v7 = &unk_1ED060668;
    id v7[2] = v10;
    if (v12)
    {
      if (v12 == v11)
      {
        *((void *)v7 + 5)  = v7 + 4;
        (*(void (**)(void *))(v11[0] + 24))(v11);
      }
      else
      {
        *((void *)v7 + 5)  = v12;
        uint64_t v12 = 0;
      }
    }
    else
    {
      *((void *)v7 + 5)  = 0;
    }
    v13[3]  = v8;
    IterateItemRanges(v6, &v9, (uint64_t)v13);
    std::__function::__value_func<void ()(unsigned int,unsigned int)>::~__value_func[abi:nn180100](v13);
    std::__function::__value_func<void ()(unsigned int,CFRange)>::~__value_func[abi:nn180100](v11);
    return uset_close();
  }
  return result;
}

uint64_t std::function<void ()(unsigned int,CFRange)>::operator()(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  v8[0]  = a3;
  v8[1]  = a4;
  int v7 = a2;
  uint64_t v4 = *(void *)(a1 + 24);
  if (v4) {
    return (*(uint64_t (**)(uint64_t, int *, void *))(*(void *)v4 + 48))(v4, &v7, v8);
  }
  uint64_t v6 = (TOpenTypeMorph *)std::__throw_bad_function_call[abi:nn180100]();
  return TOpenTypeMorph::GetCharacterClass(v6);
}

uint64_t TOpenTypeMorph::GetCharacterClass(TOpenTypeMorph *this)
{
  unsigned int v1 = this;
  int v2 = ScriptCodeForLongCharacter(this);
  uint64_t v3 = (BengaliShapingEngine *)ScriptTagForScriptCode(v2);
  if ((int)v3 <= 1818324767)
  {
    if ((int)v3 <= 1735750260)
    {
      if ((int)v3 <= 1684371040)
      {
        if (v3 != 1634885986)
        {
          if (v3 == 1650814567)
          {
            StaticClassTable  = BengaliShapingEngine::GetStaticClassTable(v3);
LABEL_49:
            return IndicClassTable::getCharClass((IndicClassTable *)StaticClassTable, v1);
          }
          goto LABEL_52;
        }
        goto LABEL_33;
      }
      if (v3 == 1684371041)
      {
        StaticClassTable  = DevanagariShapingEngine::GetStaticClassTable(v3);
        goto LABEL_49;
      }
      if (v3 == 1735748210)
      {
        StaticClassTable  = GujaratiShapingEngine::GetStaticClassTable(v3);
        goto LABEL_49;
      }
      goto LABEL_52;
    }
    if ((int)v3 <= 1802005873)
    {
      if (v3 == 1735750261)
      {
        StaticClassTable  = GurmukhiShapingEngine::GetStaticClassTable(v3);
        goto LABEL_49;
      }
      if (v3 == 1751215719)
      {
        if (v1 >> 1 == 6167) {
          return 0xFFFFFFFFLL;
        }
        UChar32 v7 = (unsigned __int16)v1;
        UProperty v8 = UCHAR_HANGUL_SYLLABLE_TYPE;
        goto LABEL_34;
      }
      goto LABEL_52;
    }
    if (v3 != 1802005874)
    {
      if (v3 == 1802396769)
      {
        StaticClassTable  = KannadaShapingEngine::GetStaticClassTable(v3);
        goto LABEL_49;
      }
      goto LABEL_52;
    }
    KhmerClassTable  = GetKhmerClassTable();
    goto LABEL_44;
  }
  if ((int)v3 > 1937338978)
  {
    if ((int)v3 <= 1952803956)
    {
      if (v3 == 1937338979)
      {
LABEL_33:
        UChar32 v7 = v1;
        UProperty v8 = UCHAR_JOINING_TYPE;
LABEL_34:
        return u_getIntPropertyValue(v7, v8);
      }
      if (v3 == 1952542060)
      {
        StaticClassTable  = TamilShapingEngine::GetStaticClassTable(v3);
        goto LABEL_49;
      }
LABEL_52:
      unint64_t v14 = (UniversalClassTable *)0xAAAAAAAAAAAAAAAALL;
      UniversalClassTable::ClassTableForScript((uint64_t)v3, &v14);
      unint64_t v13 = v14;
      if (!v14) {
        return 0;
      }
      CharClass  = UniversalClassTable::getCharClass(v14, v1);
      MEMORY[0x1853275C0](v13, 0x1050C409ECFBC67);
      return CharClass;
    }
    if (v3 == 1952803957)
    {
      StaticClassTable  = TeluguShapingEngine::GetStaticClassTable(v3);
      goto LABEL_49;
    }
    if (v3 != 1952997737) {
      goto LABEL_52;
    }
    KhmerClassTable  = GetThaiClassTable();
LABEL_44:
    CharClass  = 0;
    unsigned int v10 = *((unsigned __int16 *)KhmerClassTable + 4);
    BOOL v11 = v1 >= v10;
    unsigned int v12 = v1 - v10;
    if (v11 && *((unsigned __int16 *)KhmerClassTable + 5) >= v1) {
      return *(unsigned int *)(KhmerClassTable[2] + 4 * v12);
    }
    return CharClass;
  }
  if ((int)v3 <= 1836674417)
  {
    if (v3 != 1818324768)
    {
      if (v3 == 1835825517)
      {
        StaticClassTable  = MalayalamShapingEngine::GetStaticClassTable(v3);
        goto LABEL_49;
      }
      goto LABEL_52;
    }
    KhmerClassTable  = GetLaoClassTable();
    goto LABEL_44;
  }
  if (v3 != 1836674418)
  {
    if (v3 == 1869773153)
    {
      StaticClassTable  = OriyaShapingEngine::GetStaticClassTable(v3);
      goto LABEL_49;
    }
    goto LABEL_52;
  }

  return GetCharClass((unsigned __int16)v1);
}

uint64_t IsRightAssociative(unsigned int)::$_0::__invoke()
{
  pErrorCode  = U_ZERO_ERROR;
  uint64_t v0 = uset_openEmpty();
  MEMORY[0x185328250](v0, 4117, 1, &pErrorCode);
  MEMORY[0x185328230](v0, 9676);
  BinaryPropertySet  = u_getBinaryPropertySet(UCHAR_BINARY_LIMIT, &pErrorCode);
  MEMORY[0x185328240](v0, BinaryPropertySet);
  int v2 = u_getBinaryPropertySet(UCHAR_IDS_BINARY_OPERATOR, &pErrorCode);
  MEMORY[0x185328240](v0, v2);
  uint64_t v3 = u_getBinaryPropertySet(UCHAR_IDS_TRINARY_OPERATOR, &pErrorCode);
  MEMORY[0x185328240](v0, v3);
  uint64_t result = MEMORY[0x185328280](v0);
  _MergedGlobals_21  = v0;
  return result;
}

uint64_t std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,OTL::GlyphLookups::SortLookups(void)::{lambda(std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&)#1} &,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>*>(__int16 *a1, unsigned __int16 *a2)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  BOOL v4 = 1;
  switch(0x4EC4EC4EC4EC4EC5 * (((char *)a2 - (char *)a1) >> 3))
  {
    case 0:
    case 1:
      return v4;
    case 2:
      CFDataRef v5 = (__int16 *)(a2 - 52);
      unsigned int v6 = *(a2 - 52);
      unsigned int v7 = (unsigned __int16)*a1;
      BOOL v8 = v6 == v7;
      if (v6 >= v7) {
        char v9 = 1;
      }
      else {
        char v9 = -1;
      }
      if (v8)
      {
        unsigned int v10 = *(a2 - 51);
        unsigned int v11 = (unsigned __int16)a1[1];
        BOOL v12 = v10 >= v11;
        BOOL v13 = v10 == v11;
        char v9 = -1;
        if (v12) {
          char v9 = 1;
        }
        if (v13) {
          char v9 = 0;
        }
      }
      if (v9 < 0) {
        std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>::swap[abi:nn180100](a1, v5);
      }
      return v4;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,OTL::GlyphLookups::SortLookups(void)::{lambda(std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&)#1} &,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>*>(a1, a1 + 52, (__int16 *)a2 - 52);
      return v4;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,OTL::GlyphLookups::SortLookups(void)::{lambda(std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&)#1} &,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>*>(a1, a1 + 52, a1 + 104, (__int16 *)a2 - 52);
      return v4;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,OTL::GlyphLookups::SortLookups(void)::{lambda(std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&)#1} &,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>*>(a1, a1 + 52, a1 + 104, a1 + 156, (__int16 *)a2 - 52);
      return v4;
    default:
      unint64_t v14 = (unsigned __int16 *)(a1 + 104);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,OTL::GlyphLookups::SortLookups(void)::{lambda(std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&)#1} &,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>*>(a1, a1 + 52, a1 + 104);
      int v15 = (unsigned __int16 *)(a1 + 156);
      if (a1 + 156 == (__int16 *)a2) {
        return 1;
      }
      uint64_t v16 = 0;
      int v17 = 0;
      break;
  }
  while (1)
  {
    unsigned int v18 = *v15;
    unsigned int v19 = *v14;
    BOOL v20 = v18 == v19;
    if (v18 >= v19) {
      char v21 = 1;
    }
    else {
      char v21 = -1;
    }
    if (v20)
    {
      unsigned int v22 = v15[1];
      unsigned int v23 = v14[1];
      BOOL v24 = v22 == v23;
      char v21 = v22 >= v23 ? 1 : -1;
      if (v24) {
        char v21 = 0;
      }
    }
    if ((v21 & 0x80) == 0) {
      goto LABEL_43;
    }
    unint64_t v41 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v25 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v25 + 1)  = 0xAAAAAAAAAAAAAAAALL;
    long long v39 = v25;
    long long v40 = v25;
    long long v37 = v25;
    long long v38 = v25;
    long long v35 = v25;
    long long v36 = v25;
    LODWORD(v35)  = *(_DWORD *)v15;
    std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::vector<std::__wrap_iter<CFRange const*>,0>((uint64_t)&v35 + 8, *((unsigned char **)v15 + 1), *((unsigned char **)v15 + 2));
    LOWORD(v26)  = *v14;
    uint64_t v27 = v16;
    while (1)
    {
      uint64_t v28 = (unsigned __int16 *)((char *)a1 + v27);
      v28[156]  = v26;
      v28[157]  = *(__int16 *)((char *)a1 + v27 + 210);
      std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<CFRange const*>,std::__wrap_iter<CFRange const*>>((char *)a1 + v27 + 320, *(char **)((char *)a1 + v27 + 216), *(void *)((char *)a1 + v27 + 224), (uint64_t)(*(void *)((char *)a1 + v27 + 224) - *(void *)((char *)a1 + v27 + 216)) >> 4);
      if (v27 == -208) {
        break;
      }
      unsigned int v26 = v28[52];
      if ((unsigned __int16)v35 >= v26) {
        char v29 = 1;
      }
      else {
        char v29 = -1;
      }
      if ((unsigned __int16)v35 == v26)
      {
        unsigned int v30 = *(unsigned __int16 *)((char *)a1 + v27 + 106);
        BOOL v31 = WORD1(v35) == v30;
        char v29 = WORD1(v35) >= v30 ? 1 : -1;
        if (v31) {
          char v29 = 0;
        }
      }
      v27 -= 104;
      if ((v29 & 0x80) == 0)
      {
        uint64_t v32 = (uint64_t)a1 + v27 + 312;
        goto LABEL_41;
      }
    }
    uint64_t v32 = (uint64_t)a1;
LABEL_41:
    *(_DWORD *)uint64_t v32 = v35;
    std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<CFRange const*>,std::__wrap_iter<CFRange const*>>((char *)(v32 + 8), *((char **)&v35 + 1), v36, (uint64_t)(v36 - *((void *)&v35 + 1)) >> 4);
    if (++v17 == 8) {
      break;
    }
    long long v34 = (void **)&v35 + 1;
    std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__destroy_vector::operator()[abi:nn180100](&v34);
LABEL_43:
    unint64_t v14 = v15;
    v16 += 104;
    v15 += 52;
    if (v15 == a2) {
      return 1;
    }
  }
  BOOL v4 = v15 + 52 == a2;
  long long v34 = (void **)&v35 + 1;
  std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__destroy_vector::operator()[abi:nn180100](&v34);
  return v4;
}

void std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>::swap[abi:nn180100](__int16 *a1, __int16 *a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  __int16 v3 = *a1;
  *a1  = *a2;
  *a2  = v3;
  __int16 v4 = a1[1];
  a1[1]  = a2[1];
  a2[1]  = v4;
  *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  v8[4]  = v5;
  v8[5]  = v5;
  v8[2]  = v5;
  v8[3]  = v5;
  v8[0]  = v5;
  v8[1]  = v5;
  unsigned int v6 = (char *)(a1 + 4);
  std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::vector<std::__wrap_iter<CFRange const*>,0>((uint64_t)v8, *((unsigned char **)a1 + 1), *((unsigned char **)a1 + 2));
  std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<CFRange const*>,std::__wrap_iter<CFRange const*>>(v6, *((char **)a2 + 1), *((void *)a2 + 2), (uint64_t)(*((void *)a2 + 2) - *((void *)a2 + 1)) >> 4);
  std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<CFRange const*>,std::__wrap_iter<CFRange const*>>((char *)a2 + 8, *(char **)&v8[0], *((uint64_t *)&v8[0] + 1), (uint64_t)(*((void *)&v8[0] + 1) - *(void *)&v8[0]) >> 4);
  unsigned int v7 = (void **)v8;
  std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__destroy_vector::operator()[abi:nn180100](&v7);
}

char *std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<CFRange const*>,std::__wrap_iter<CFRange const*>>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  unsigned int v7 = result;
  uint64_t v8 = *((void *)result + 2);
  uint64_t v9 = *(char **)result;
  unint64_t v10 = (v8 - *(void *)result) >> 4;
  if (v10 < a4)
  {
    if (v9)
    {
      *((void *)result + 1)  = v9;
      unsigned int v11 = (void **)(result + 88);
      if (result + 24 <= v9 && v11 > (void **)v9)
      {
        if (&v9[16 * v10] == *v11) {
          void *v11 = v9;
        }
      }
      else
      {
        operator delete(v9);
      }
      uint64_t v8 = 0;
      void *v7 = 0;
      v7[1]  = 0;
      id v7[2] = 0;
    }
    if (a4 >> 60) {
      abort();
    }
    uint64_t v20 = v8 >> 3;
    if (v8 >> 3 <= a4) {
      uint64_t v20 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v21 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v21 = v20;
    }
    uint64_t result = std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__vallocate[abi:nn180100](v7, v21);
    unsigned int v22 = (char *)v7[1];
    unint64_t v14 = (void **)(v7 + 1);
    uint64_t v9 = v22;
LABEL_23:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      unsigned int v18 = v9;
      unsigned int v19 = __src;
      goto LABEL_25;
    }
    goto LABEL_26;
  }
  unint64_t v14 = (void **)(result + 8);
  BOOL v13 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v13 - v9) >> 4;
  if (v15 >= a4) {
    goto LABEL_23;
  }
  uint64_t v16 = &__src[16 * v15];
  if (v13 != v9)
  {
    uint64_t result = (char *)memmove(*(void **)result, __src, 16 * v15);
    uint64_t v9 = (char *)*v14;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    unsigned int v18 = v9;
    unsigned int v19 = v16;
LABEL_25:
    uint64_t result = (char *)memmove(v18, v19, v17);
  }
LABEL_26:
  *unint64_t v14 = &v9[v17];
  return result;
}

void std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,OTL::GlyphLookups::SortLookups(void)::{lambda(std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&)#1} &,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>*>(__int16 *a1, __int16 *a2, __int16 *a3, __int16 *a4, __int16 *a5)
{
  std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,OTL::GlyphLookups::SortLookups(void)::{lambda(std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>> const&)#1} &,std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>*>(a1, a2, a3, a4);
  unsigned int v10 = (unsigned __int16)*a5;
  unsigned int v11 = (unsigned __int16)*a4;
  BOOL v12 = v10 == v11;
  if (v10 >= v11) {
    char v13 = 1;
  }
  else {
    char v13 = -1;
  }
  if (v12)
  {
    unsigned int v14 = (unsigned __int16)a5[1];
    unsigned int v15 = (unsigned __int16)a4[1];
    BOOL v16 = v14 >= v15;
    BOOL v17 = v14 == v15;
    char v13 = -1;
    if (v16) {
      char v13 = 1;
    }
    if (v17) {
      char v13 = 0;
    }
  }
  if (v13 < 0)
  {
    std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>::swap[abi:nn180100](a4, a5);
    unsigned int v18 = (unsigned __int16)*a4;
    unsigned int v19 = (unsigned __int16)*a3;
    BOOL v20 = v18 == v19;
    if (v18 >= v19) {
      char v21 = 1;
    }
    else {
      char v21 = -1;
    }
    if (v20)
    {
      unsigned int v22 = (unsigned __int16)a4[1];
      unsigned int v23 = (unsigned __int16)a3[1];
      BOOL v16 = v22 >= v23;
      BOOL v24 = v22 == v23;
      char v21 = -1;
      if (v16) {
        char v21 = 1;
      }
      if (v24) {
        char v21 = 0;
      }
    }
    if (v21 < 0)
    {
      std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>::swap[abi:nn180100](a3, a4);
      unsigned int v25 = (unsigned __int16)*a3;
      unsigned int v26 = (unsigned __int16)*a2;
      BOOL v27 = v25 == v26;
      if (v25 >= v26) {
        char v28 = 1;
      }
      else {
        char v28 = -1;
      }
      if (v27)
      {
        unsigned int v29 = (unsigned __int16)a3[1];
        unsigned int v30 = (unsigned __int16)a2[1];
        BOOL v16 = v29 >= v30;
        BOOL v31 = v29 == v30;
        char v28 = -1;
        if (v16) {
          char v28 = 1;
        }
        if (v31) {
          char v28 = 0;
        }
      }
      if (v28 < 0)
      {
        std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>::swap[abi:nn180100](a2, a3);
        unsigned int v32 = (unsigned __int16)*a2;
        unsigned int v33 = (unsigned __int16)*a1;
        BOOL v34 = v32 == v33;
        if (v32 >= v33) {
          char v35 = 1;
        }
        else {
          char v35 = -1;
        }
        if (v34)
        {
          unsigned int v36 = (unsigned __int16)a2[1];
          unsigned int v37 = (unsigned __int16)a1[1];
          BOOL v16 = v36 >= v37;
          BOOL v38 = v36 == v37;
          char v35 = -1;
          if (v16) {
            char v35 = 1;
          }
          if (v38) {
            char v35 = 0;
          }
        }
        if (v35 < 0)
        {
          std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>::swap[abi:nn180100](a1, a2);
        }
      }
    }
  }
}

void *std::__function::__func<EnumeratePatternScriptRanges(char16_t const*,unsigned int,std::function<void ()(unsigned int,CFRange)>)::$_0,std::allocator<EnumeratePatternScriptRanges(char16_t const*,unsigned int,std::function<void ()(unsigned int,CFRange)>)::$_0>,void ()(unsigned int,unsigned int)>::~__func(void *a1)
{
  *a1  = &unk_1ED060668;
  std::__function::__value_func<void ()(unsigned int,CFRange)>::~__value_func[abi:nn180100](a1 + 2);
  return a1;
}

void std::__function::__func<EnumeratePatternScriptRanges(char16_t const*,unsigned int,std::function<void ()(unsigned int,CFRange)>)::$_0,std::allocator<EnumeratePatternScriptRanges(char16_t const*,unsigned int,std::function<void ()(unsigned int,CFRange)>)::$_0>,void ()(unsigned int,unsigned int)>::~__func(void *a1)
{
  *a1  = &unk_1ED060668;
  std::__function::__value_func<void ()(unsigned int,CFRange)>::~__value_func[abi:nn180100](a1 + 2);

  JUMPOUT(0x1853275C0);
}

_DWORD *std::__function::__func<EnumeratePatternScriptRanges(char16_t const*,unsigned int,std::function<void ()(unsigned int,CFRange)>)::$_0,std::allocator<EnumeratePatternScriptRanges(char16_t const*,unsigned int,std::function<void ()(unsigned int,CFRange)>)::$_0>,void ()(unsigned int,unsigned int)>::__clone(uint64_t a1)
{
  int v2 = operator new(0x30uLL);
  *(void *)int v2 = &unk_1ED060668;
  v2[2]  = *(_DWORD *)(a1 + 8);
  std::__function::__value_func<void ()(unsigned int,CFRange)>::__value_func[abi:nn180100]((uint64_t)(v2 + 4), a1 + 16);
  return v2;
}

uint64_t std::__function::__func<EnumeratePatternScriptRanges(char16_t const*,unsigned int,std::function<void ()(unsigned int,CFRange)>)::$_0,std::allocator<EnumeratePatternScriptRanges(char16_t const*,unsigned int,std::function<void ()(unsigned int,CFRange)>)::$_0>,void ()(unsigned int,unsigned int)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2  = &unk_1ED060668;
  *(_DWORD *)(a2 + 8)  = *(_DWORD *)(a1 + 8);
  return std::__function::__value_func<void ()(unsigned int,CFRange)>::__value_func[abi:nn180100](a2 + 16, a1 + 16);
}

void *std::__function::__func<EnumeratePatternScriptRanges(char16_t const*,unsigned int,std::function<void ()(unsigned int,CFRange)>)::$_0,std::allocator<EnumeratePatternScriptRanges(char16_t const*,unsigned int,std::function<void ()(unsigned int,CFRange)>)::$_0>,void ()(unsigned int,unsigned int)>::destroy(uint64_t a1)
{
  return std::__function::__value_func<void ()(unsigned int,CFRange)>::~__value_func[abi:nn180100]((void *)(a1 + 16));
}

void std::__function::__func<EnumeratePatternScriptRanges(char16_t const*,unsigned int,std::function<void ()(unsigned int,CFRange)>)::$_0,std::allocator<EnumeratePatternScriptRanges(char16_t const*,unsigned int,std::function<void ()(unsigned int,CFRange)>)::$_0>,void ()(unsigned int,unsigned int)>::destroy_deallocate(void *a1)
{
  std::__function::__value_func<void ()(unsigned int,CFRange)>::~__value_func[abi:nn180100](a1 + 2);

  operator delete(a1);
}

uint64_t std::__function::__func<EnumeratePatternScriptRanges(char16_t const*,unsigned int,std::function<void ()(unsigned int,CFRange)>)::$_0,std::allocator<EnumeratePatternScriptRanges(char16_t const*,unsigned int,std::function<void ()(unsigned int,CFRange)>)::$_0>,void ()(unsigned int,unsigned int)>::operator()(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  return std::function<void ()(unsigned int,CFRange)>::operator()(a1 + 16, *(_DWORD *)(a1 + 8), *a2, (*a3 - *a2));
}

void std::__function::__func<TOpenTypeMorph::ShapeGlyphs(SyncState &)::$_1,std::allocator<TOpenTypeMorph::ShapeGlyphs(SyncState &)::$_1>,BOOL ()(TRunGlue::TGlyph)>::~__func()
{
}

void *std::__function::__func<TOpenTypeMorph::ShapeGlyphs(SyncState &)::$_1,std::allocator<TOpenTypeMorph::ShapeGlyphs(SyncState &)::$_1>,BOOL ()(TRunGlue::TGlyph)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1ED060E48;
  return result;
}

void std::__function::__func<TOpenTypeMorph::ShapeGlyphs(SyncState &)::$_1,std::allocator<TOpenTypeMorph::ShapeGlyphs(SyncState &)::$_1>,BOOL ()(TRunGlue::TGlyph)>::__clone(uint64_t a1, void *a2)
{
  *a2  = &unk_1ED060E48;
}

void BengaliShapingEngine::BengaliShapingEngine(BengaliShapingEngine *this, const TCharStream *a2, TRunGlue *a3, OTL::GSUB *a4)
{
  StaticClassTable  = BengaliShapingEngine::GetStaticClassTable(this);
  IndicShapingEngine::IndicShapingEngine(this, a2, a3, (const IndicClassTable *)StaticClassTable, a4);
}

uint64_t IndicShapingEngine::ApplyLookups(IndicShapingEngine *this, unsigned __int16 **a2)
{
  unsigned __int8 v9 = 0;
  OTL::GSUB::ApplyLookups(*((void **)this + 64), *((TRunGlue **)this + 1), 1, a2, &v9, (uint64_t)IndicShapingEngine::ApplyLookups(OTL::GlyphLookups &)::{lambda(void *,CFRange,long)#1}::__invoke, (uint64_t)this + 520);
  if (*((unsigned char *)this + 888) || (*(unsigned char *)(*((void *)this + 62) + 15) & 8) != 0)
  {
    unsigned __int16 v11 = 0;
    __int16 v3 = (const IndicClassTable *)*((void *)this + 63);
    __int16 v4 = v3;
    if (!v3) {
      __int16 v4 = (const IndicClassTable *)*((void *)this + 62);
    }
    int v5 = *((unsigned __int16 *)v4 + 12);
    __int16 v10 = v5;
    if (v5)
    {
      uint64_t v6 = *(void *)(*(void *)(*((void *)this + 1) + 616) + 400);
      (*(void (**)(uint64_t, __int16 *, unsigned __int16 *, uint64_t))(*(void *)v6 + 664))(v6, &v10, &v11, 1);
      int v7 = v11;
      __int16 v3 = (const IndicClassTable *)*((void *)this + 63);
    }
    else
    {
      int v7 = 0;
    }
    if (!v3) {
      __int16 v3 = (const IndicClassTable *)*((void *)this + 62);
    }
    PostGSUBFixups::apply((IndicShapingEngine *)((char *)this + 520), *((TRunGlue **)this + 1), v7, v3, *(_DWORD *)(*((void *)this + 64) + 72));
  }
  OpenTypeShapingEngine::SetSafeToBreakAfterEachSyllable((uint64_t)this);
  return v9;
}

void DevanagariShapingEngine::DevanagariShapingEngine(DevanagariShapingEngine *this, const TCharStream *a2, TRunGlue *a3, OTL::GSUB *a4)
{
  StaticClassTable  = DevanagariShapingEngine::GetStaticClassTable(this);
  IndicShapingEngine::IndicShapingEngine(this, a2, a3, (const IndicClassTable *)StaticClassTable, a4);
}

void GujaratiShapingEngine::GujaratiShapingEngine(GujaratiShapingEngine *this, const TCharStream *a2, TRunGlue *a3, OTL::GSUB *a4)
{
  StaticClassTable  = GujaratiShapingEngine::GetStaticClassTable(this);
  IndicShapingEngine::IndicShapingEngine(this, a2, a3, (const IndicClassTable *)StaticClassTable, a4);
}

void GurmukhiShapingEngine::GurmukhiShapingEngine(GurmukhiShapingEngine *this, const TCharStream *a2, TRunGlue *a3, OTL::GSUB *a4)
{
  StaticClassTable  = GurmukhiShapingEngine::GetStaticClassTable(this);
  IndicShapingEngine::IndicShapingEngine(this, a2, a3, (const IndicClassTable *)StaticClassTable, a4);
}

void KannadaShapingEngine::KannadaShapingEngine(KannadaShapingEngine *this, const TCharStream *a2, TRunGlue *a3, OTL::GSUB *a4)
{
  StaticClassTable  = KannadaShapingEngine::GetStaticClassTable(this);
  IndicShapingEngine::IndicShapingEngine(this, a2, a3, (const IndicClassTable *)StaticClassTable, a4);
}

void MalayalamShapingEngine::MalayalamShapingEngine(MalayalamShapingEngine *this, const TCharStream *a2, TRunGlue *a3, OTL::GSUB *a4)
{
  StaticClassTable  = MalayalamShapingEngine::GetStaticClassTable(this);
  IndicShapingEngine::IndicShapingEngine(this, a2, a3, (const IndicClassTable *)StaticClassTable, a4);
}

void OriyaShapingEngine::OriyaShapingEngine(OriyaShapingEngine *this, const TCharStream *a2, TRunGlue *a3, OTL::GSUB *a4)
{
  StaticClassTable  = OriyaShapingEngine::GetStaticClassTable(this);
  IndicShapingEngine::IndicShapingEngine(this, a2, a3, (const IndicClassTable *)StaticClassTable, a4);
}

void TamilShapingEngine::TamilShapingEngine(TamilShapingEngine *this, const TCharStream *a2, TRunGlue *a3, OTL::GSUB *a4)
{
  StaticClassTable  = TamilShapingEngine::GetStaticClassTable(this);
  IndicShapingEngine::IndicShapingEngine(this, a2, a3, (const IndicClassTable *)StaticClassTable, a4);
}

void TeluguShapingEngine::TeluguShapingEngine(TeluguShapingEngine *this, const TCharStream *a2, TRunGlue *a3, OTL::GSUB *a4)
{
  StaticClassTable  = TeluguShapingEngine::GetStaticClassTable(this);
  IndicShapingEngine::IndicShapingEngine(this, a2, a3, (const IndicClassTable *)StaticClassTable, a4);
}

uint64_t TOpenTypeMorph::ApplyShapingEngine<TInlineVector<unsigned int,1ul>>(OTL::GlyphLookups &,unsigned int *,BOOL (**)(unsigned int),TInlineVector<unsigned int,1ul> &,SyncState &,BOOL *)::{lambda(unsigned int)#1}::__invoke()
{
  return 1;
}

void IndicShapingEngine::IndicShapingEngine(IndicShapingEngine *this, const TCharStream *a2, TRunGlue *a3, const IndicClassTable *a4, OTL::GSUB *a5)
{
  OpenTypeShapingEngine::OpenTypeShapingEngine(this, a2, a3);
  *(void *)uint64_t v7 = &unk_1ED05E6F0;
  *(void *)(v7 + 496)  = a4;
  *(void *)(v7 + 504)  = 0;
  *(void *)(v7 + 512)  = a5;
  *(void *)(v7 + 536)  = 0;
  *(void *)(v7 + 528)  = 0;
  *(void *)(v7 + 520)  = 0;
  *(void *)(v7 + 800)  = v7 + 544;
  *(void *)(v7 + 808)  = 0;
  *(void *)(v7 + 824)  = 0;
  *(void *)(v7 + 816)  = 0;
  *(void *)(v7 + 880)  = v7 + 832;
  if (*((_DWORD *)a5 + 19)) {
    BOOL v8 = 1;
  }
  else {
    BOOL v8 = *((unsigned char *)a4 + 80) == 0;
  }
  char v9 = v8;
  *(unsigned char *)(v7 + 888)  = v9;
  operator new();
}

uint64_t IndicShapingEngine::ApplyLookups(OTL::GlyphLookups &)::{lambda(void *,CFRange,long)#1}::__invoke(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4 - a3;
  if (a4 - a3 >= 1)
  {
    int v5 = *(void **)result;
    uint64_t v6 = *(void **)(result + 8);
    while (v5 != v6)
    {
      if (*v5 > a2) {
        *v5 += v4;
      }
      uint64_t v7 = v5[1];
      if (v7 > a2) {
        v5[1]  = v7 + v4;
      }
      v5 += 4;
    }
  }
  return result;
}

void *TInlineBufferAllocator<unsigned int,1ul>::allocate(uint64_t a1, unint64_t a2)
{
  uint64_t result = *(void **)(a1 + 8);
  unint64_t v4 = (unint64_t)result + 4 * a2;
  if (v4 <= a1 + 4)
  {
    *(void *)(a1 + 8)  = v4;
  }
  else
  {
    if (a2 >> 62) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    return operator new(4 * a2);
  }
  return result;
}

uint64_t std::__split_buffer<unsigned int,TInlineBufferAllocator<unsigned int,1ul> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3) {
    *(void *)(a1 + 16)  = v2 + ((v3 - v2 + 3) & 0xFFFFFFFFFFFFFFFCLL);
  }
  unint64_t v4 = *(void **)a1;
  if (*(void *)a1)
  {
    unint64_t v5 = *(void *)(a1 + 32);
    if (v5 <= (unint64_t)v4 && v5 + 4 > (unint64_t)v4)
    {
      if (*(void *)(a1 + 24) == *(void *)(v5 + 8)) {
        *(void *)(v5 + 8)  = v4;
      }
    }
    else
    {
      operator delete(v4);
    }
  }
  return a1;
}

uint64_t TOpenTypeMorph::ApplyShapingEngine<TInlineVector<unsigned int,1ul>>(OTL::GlyphLookups &,unsigned int *,BOOL (**)(unsigned int),TInlineVector<unsigned int,1ul> &,SyncState &,BOOL *)::{lambda(unsigned int)#2}::__invoke()
{
  return 1;
}

void std::__function::__func<TOpenTypeMorph::AddVariantsOfGlyph(TFont const&,unsigned short,std::function<void ()(unsigned short,__CFDictionary const*)>)::$_0,std::allocator<TOpenTypeMorph::AddVariantsOfGlyph(TFont const&,unsigned short,std::function<void ()(unsigned short,__CFDictionary const*)>)::$_0>,BOOL ()(unsigned int,OTL::FeatureTable const*,BOOL &)>::~__func()
{
}

__n128 std::__function::__func<TOpenTypeMorph::AddVariantsOfGlyph(TFont const&,unsigned short,std::function<void ()(unsigned short,__CFDictionary const*)>)::$_0,std::allocator<TOpenTypeMorph::AddVariantsOfGlyph(TFont const&,unsigned short,std::function<void ()(unsigned short,__CFDictionary const*)>)::$_0>,BOOL ()(unsigned int,OTL::FeatureTable const*,BOOL &)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x38uLL);
  *(void *)uint64_t v2 = &unk_1ED060F20;
  *(_OWORD *)(v2 + 8)  = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24)  = *(_OWORD *)(a1 + 24);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40)  = result;
  return result;
}

__n128 std::__function::__func<TOpenTypeMorph::AddVariantsOfGlyph(TFont const&,unsigned short,std::function<void ()(unsigned short,__CFDictionary const*)>)::$_0,std::allocator<TOpenTypeMorph::AddVariantsOfGlyph(TFont const&,unsigned short,std::function<void ()(unsigned short,__CFDictionary const*)>)::$_0>,BOOL ()(unsigned int,OTL::FeatureTable const*,BOOL &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2  = &unk_1ED060F20;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 40)  = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 24)  = v3;
  *(__n128 *)(a2 + 8)  = result;
  return result;
}

uint64_t std::__function::__func<TOpenTypeMorph::AddVariantsOfGlyph(TFont const&,unsigned short,std::function<void ()(unsigned short,__CFDictionary const*)>)::$_0,std::allocator<TOpenTypeMorph::AddVariantsOfGlyph(TFont const&,unsigned short,std::function<void ()(unsigned short,__CFDictionary const*)>)::$_0>,BOOL ()(unsigned int,OTL::FeatureTable const*,BOOL &)>::operator()(uint64_t a1, unsigned int *a2, uint64_t *a3)
{
  v22[4]  = *MEMORY[0x1E4F143B8];
  unsigned int v3 = *a2;
  uint64_t v4 = *a3;
  unsigned int v21 = v3;
  unint64_t v20 = 0xAAAAAAAAAAAAAAAALL;
  if (v3 == 1667460464) {
    return 1;
  }
  int v6 = ConvertOTFeatureToAATFeature(v3, (uint64_t)&v20);
  if (v3 != 1819239276 && v6 == 2) {
    return 1;
  }
  int v8 = (**(unsigned char **)(a1 + 8) & 1) != 0 ? 32 : 16;
  if ((v8 & HIDWORD(v20)) != 0) {
    return 1;
  }
  char v19 = -86;
  unsigned __int16 v11 = *(uint64_t **)(a1 + 16);
  BOOL v12 = *(unint64_t **)(a1 + 24);
  uint64_t v13 = *v11;
  unint64_t v14 = *v12;
  uint64_t v15 = *(void *)(a1 + 32);
  uint64_t v16 = *(void *)(a1 + 40);
  uint64_t v17 = *(void *)(a1 + 48);
  unsigned int v18 = operator new(0x40uLL);
  *unsigned int v18 = &unk_1ED0621B0;
  v18[1]  = v15;
  v18[2]  = v11;
  v18[3]  = v12;
  v18[4]  = v16;
  v18[5]  = &v21;
  v18[6]  = &v19;
  v18[7]  = v17;
  v22[3]  = v18;
  uint64_t v9 = OTL::GCommon::IterateLookupIndexes(v13, v4, v14, (uint64_t)v22);
  std::__function::__value_func<BOOL ()(unsigned short,BOOL &)>::~__value_func[abi:nn180100](v22);
  return v9;
}

void std::__function::__func<TOpenTypeMorph::AddVariantsOfGlyph(TFont const&,unsigned short,std::function<void ()(unsigned short,__CFDictionary const*)>)::$_0::operator() const(unsigned int,OTL::FeatureTable const*,BOOL &)::{lambda(unsigned short,BOOL &)#1},std::allocator<TOpenTypeMorph::AddVariantsOfGlyph(TFont const&,unsigned short,std::function<void ()(unsigned short,__CFDictionary const*)>)::$_0::operator() const(unsigned int,OTL::FeatureTable const*,BOOL &)::{lambda(unsigned short,BOOL &)#1}>,BOOL ()(unsigned short,BOOL &)>::~__func()
{
}

__n128 std::__function::__func<TOpenTypeMorph::AddVariantsOfGlyph(TFont const&,unsigned short,std::function<void ()(unsigned short,__CFDictionary const*)>)::$_0::operator() const(unsigned int,OTL::FeatureTable const*,BOOL &)::{lambda(unsigned short,BOOL &)#1},std::allocator<TOpenTypeMorph::AddVariantsOfGlyph(TFont const&,unsigned short,std::function<void ()(unsigned short,__CFDictionary const*)>)::$_0::operator() const(unsigned int,OTL::FeatureTable const*,BOOL &)::{lambda(unsigned short,BOOL &)#1}>,BOOL ()(unsigned short,BOOL &)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x40uLL);
  *(void *)uint64_t v2 = &unk_1ED0621B0;
  *(_OWORD *)(v2 + 8)  = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24)  = *(_OWORD *)(a1 + 24);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40)  = result;
  *((void *)v2 + 7)  = *(void *)(a1 + 56);
  return result;
}

__n128 std::__function::__func<TOpenTypeMorph::AddVariantsOfGlyph(TFont const&,unsigned short,std::function<void ()(unsigned short,__CFDictionary const*)>)::$_0::operator() const(unsigned int,OTL::FeatureTable const*,BOOL &)::{lambda(unsigned short,BOOL &)#1},std::allocator<TOpenTypeMorph::AddVariantsOfGlyph(TFont const&,unsigned short,std::function<void ()(unsigned short,__CFDictionary const*)>)::$_0::operator() const(unsigned int,OTL::FeatureTable const*,BOOL &)::{lambda(unsigned short,BOOL &)#1}>,BOOL ()(unsigned short,BOOL &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2  = &unk_1ED0621B0;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  long long v4 = *(_OWORD *)(a1 + 40);
  *(void *)(a2 + 56)  = *(void *)(a1 + 56);
  *(_OWORD *)(a2 + 40)  = v4;
  *(_OWORD *)(a2 + 24)  = v3;
  *(__n128 *)(a2 + 8)  = result;
  return result;
}

uint64_t std::__function::__func<TOpenTypeMorph::AddVariantsOfGlyph(TFont const&,unsigned short,std::function<void ()(unsigned short,__CFDictionary const*)>)::$_0::operator() const(unsigned int,OTL::FeatureTable const*,BOOL &)::{lambda(unsigned short,BOOL &)#1},std::allocator<TOpenTypeMorph::AddVariantsOfGlyph(TFont const&,unsigned short,std::function<void ()(unsigned short,__CFDictionary const*)>)::$_0::operator() const(unsigned int,OTL::FeatureTable const*,BOOL &)::{lambda(unsigned short,BOOL &)#1}>,BOOL ()(unsigned short,BOOL &)>::operator()(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t v2 = (unsigned __int16 *)(**(void **)(a1 + 8)
                          + (bswap32(*(unsigned __int16 *)(**(void **)(a1 + 8) + 2 * *a2 + 2)) >> 16));
  unint64_t v3 = **(void **)(a1 + 16);
  unint64_t v4 = **(void **)(a1 + 24);
  unint64_t v5 = v2 + 3;
  BOOL v6 = (unint64_t)(v2 + 2) < v3 || (unint64_t)v5 > v4;
  if (v6
    || ((unsigned int v7 = __rev16(v2[2]),
         unint64_t v8 = (unint64_t)&v2[v7 + 3] + (((unint64_t)v2[1] >> 11) & 2),
         v3 <= (unint64_t)v2)
      ? (BOOL v9 = v8 >= (unint64_t)v2)
      : (BOOL v9 = 0),
        v9 ? (BOOL v10 = v8 > v4) : (BOOL v10 = 1),
        v10))
  {
    char v64 = 0;
    return v64 & 1;
  }
  unint64_t v11 = (unint64_t)&v5[v7];
  if ((unint64_t)(v2 + 4) <= v4) {
    unsigned int v12 = (v4 - v5) >> 1;
  }
  else {
    unsigned int v12 = 0;
  }
  unsigned int v13 = bswap32(v12) >> 16;
  BOOL v14 = v11 < (unint64_t)v5 || v11 > v4;
  if (v14) {
    unsigned __int16 v15 = v12;
  }
  else {
    unsigned __int16 v15 = v7;
  }
  if (v14) {
    unsigned int v16 = v13;
  }
  else {
    unsigned int v16 = v2[2];
  }
  if (!v16)
  {
    BOOL v19 = 1;
    goto LABEL_117;
  }
  uint64_t v18 = 0;
  BOOL v19 = 0;
  unint64_t v20 = v15;
  if ((v15 & 0xFFFE) != 0) {
    uint64_t v21 = v15;
  }
  else {
    uint64_t v21 = 1;
  }
  alloc  = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  while (1)
  {
    unsigned int v22 = (unsigned __int16 *)((char *)v2 + (bswap32(v2[v18 + 3]) >> 16));
    unint64_t v23 = **(void **)(a1 + 24);
    if ((unint64_t)(v22 + 1) > v23) {
      break;
    }
    unsigned int v24 = *v2;
    if (v24 == 1792)
    {
      if (*v22 != 256 || (unint64_t)(v22 + 4) > v23) {
        break;
      }
      unsigned int v26 = v22[1];
      if (v26 == 1792
        || (unsigned int v22 = (unsigned __int16 *)((char *)v22 + bswap32(*((_DWORD *)v22 + 1))), (unint64_t)(v22 + 1) > v23))
      {
LABEL_116:
        LOBYTE(v15)  = 1;
        goto LABEL_117;
      }
      unsigned int v27 = __rev16(v26);
    }
    else
    {
      unsigned int v27 = __rev16(v24);
    }
    if ((v27 & 0xFFFFFFFD) != 1) {
      goto LABEL_116;
    }
    OTL::LookupWithCoverage::GetCoverage((OTL::Coverage *)v22, v23, (uint64_t)v68);
    char v28 = v69;
    unsigned int v29 = (id *)((char *)v68 + (v70 >> 1));
    if (v70) {
      char v28 = *(uint64_t (**)(void *, void))(*v29 + v69);
    }
    unsigned int v30 = v28(v29, **(unsigned __int16 **)(a1 + 32));
    if (v30)
    {
      unsigned int v31 = v30;
      v68[0]  = 0;
      unsigned int v32 = **(_DWORD **)(a1 + 40);
      if (v32 != 1633774708 && v32 != 1819239276)
      {
        *(_DWORD *)cStr  = bswap32(v32);
        char v72 = 0;
        id v67 = (id)CFStringCreateWithCString(alloc, cStr, 0);
      }
      if (v27 == 3)
      {
        if (*v22 == 256)
        {
          unint64_t v34 = **(void **)(a1 + 24);
          char v35 = v22 + 3;
          if ((unint64_t)(v22 + 3) > v34) {
            goto LABEL_121;
          }
          uint64_t v36 = bswap32(v22[2]) >> 16;
          unint64_t v37 = (unint64_t)&v35[v36];
          BOOL v39 = v37 >= (unint64_t)v35 && v37 <= v34;
          unint64_t v40 = (v34 - (unint64_t)v35) >> 1;
          if ((unint64_t)(v22 + 4) > v34) {
            unint64_t v40 = 0;
          }
          if (!v39 && v40 != v36) {
            goto LABEL_121;
          }
          if (v31 <= v36)
          {
            unsigned int v41 = v31 - 1;
            if (v39)
            {
              if (v41 >= v36) {
                goto LABEL_121;
              }
            }
            else if (v40 != v36 || v41 >= v36)
            {
              goto LABEL_121;
            }
            uint64_t v53 = (unsigned __int16 *)((char *)v22 + (bswap32(v22[v41 + 3]) >> 16));
            uint64_t v54 = v53 + 1;
            if ((unint64_t)(v53 + 1) > v34) {
              goto LABEL_121;
            }
            unsigned int v55 = *v53;
            uint64_t v56 = __rev16(v55);
            unint64_t v57 = (unint64_t)&v54[v56];
            unint64_t v58 = (unint64_t)(v53 + 2) <= v34 ? (v34 - (unint64_t)v54) >> 1 : 0;
            BOOL v59 = v57 <= v34 && v57 >= (unint64_t)v54;
            if (!v59 && v58 != v56) {
              goto LABEL_121;
            }
            if (v55)
            {
              uint64_t v61 = 0;
              if (v56 <= 1) {
                uint64_t v62 = 1;
              }
              else {
                uint64_t v62 = v56;
              }
              do
              {
                id v67 = (id)0xAAAAAAAAAAAAAAAALL;
                CFStringRef explicit = (const __CFString *)atomic_load_explicit((atomic_ullong *volatile)v68, memory_order_acquire);
                if (explicit)
                {
                  id v67 = (id)0xAAAAAAAAAAAAAAAALL;
                  CopyFeatureSettingForTag(explicit, 0, 0, 0, (v61 + 1), &v67);
                }
                else
                {
                  id v67 = 0;
                }
                std::function<void ()(unsigned short,__CFDictionary const*)>::operator()(*(void *)(*(void *)(a1 + 56) + 24), bswap32(v54[v61]) >> 16, atomic_load_explicit((atomic_ullong *volatile)&v67, memory_order_acquire));

                ++v61;
              }
              while (v62 != v61);
            }
          }
        }
      }
      else if (v27 == 1)
      {
        id v67 = (id)0xAAAAAAAAAAAAAAAALL;
        CFStringRef v33 = (const __CFString *)atomic_load_explicit((atomic_ullong *volatile)v68, memory_order_acquire);
        if (v33)
        {
          id v67 = (id)0xAAAAAAAAAAAAAAAALL;
          CopyFeatureSettingForTag(v33, 0, 0, 0, 1, &v67);
        }
        else
        {
          id v67 = 0;
        }
        unsigned int v42 = bswap32(*v22) >> 16;
        if (v42 == 2)
        {
          unint64_t v45 = **(void **)(a1 + 24);
          int64x2_t v46 = v22 + 3;
          if ((unint64_t)(v22 + 3) > v45
            || ((uint64_t v47 = bswap32(v22[2]) >> 16,
                 unint64_t v48 = (unint64_t)&v46[v47],
                 (unint64_t)(v22 + 4) <= v45)
              ? (unint64_t v49 = (v45 - (unint64_t)v46) >> 1)
              : (unint64_t v49 = 0),
                v48 <= v45 ? (BOOL v50 = v48 >= (unint64_t)v46) : (BOOL v50 = 0),
                !v50 ? (BOOL v51 = v49 == v47) : (BOOL v51 = 1),
                !v51))
          {
LABEL_120:

LABEL_121:
            break;
          }
          if (v31 <= v47)
          {
            uint64_t v43 = *(void *)(a1 + 56);
            unsigned int v44 = bswap32(v22[v31 + 2]) >> 16;
            goto LABEL_85;
          }
        }
        else if (v42 == 1)
        {
          if ((unint64_t)(v22 + 3) > **(void **)(a1 + 24)) {
            goto LABEL_120;
          }
          uint64_t v43 = *(void *)(a1 + 56);
          unsigned int v44 = **(unsigned __int16 **)(a1 + 32) + (bswap32(v22[2]) >> 16);
LABEL_85:
          std::function<void ()(unsigned short,__CFDictionary const*)>::operator()(*(void *)(v43 + 24), v44, atomic_load_explicit((atomic_ullong *volatile)&v67, memory_order_acquire));
        }
      }
    }
    BOOL v19 = ++v18 >= v20;
    if (v18 == v21) {
      goto LABEL_117;
    }
  }
  LOBYTE(v15)  = 0;
LABEL_117:
  char v64 = v19 | v15;
  return v64 & 1;
}

void *std::function<void ()(unsigned short,__CFDictionary const*)>::operator()(uint64_t a1, __int16 a2, uint64_t a3)
{
  __int16 v6 = a2;
  uint64_t v5 = a3;
  if (a1) {
    return (void *)(*(uint64_t (**)(uint64_t, __int16 *, uint64_t *))(*(void *)a1 + 48))(a1, &v6, &v5);
  }
  unint64_t v4 = (void *)std::__throw_bad_function_call[abi:nn180100]();
  return std::__function::__value_func<BOOL ()(unsigned short,BOOL &)>::~__value_func[abi:nn180100](v4);
}

void *std::__function::__value_func<BOOL ()(unsigned short,BOOL &)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<TOpenTypeMorph::AddShapingGlyphs(TFont const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(unsigned int)>,std::function<void ()(void)>)::$_0,std::allocator<TOpenTypeMorph::AddShapingGlyphs(TFont const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(unsigned int)>,std::function<void ()(void)>)::$_0>,BOOL ()(unsigned int,OTL::ScriptTable const*,BOOL &)>::~__func()
{
}

__n128 std::__function::__func<TOpenTypeMorph::AddShapingGlyphs(TFont const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(unsigned int)>,std::function<void ()(void)>)::$_0,std::allocator<TOpenTypeMorph::AddShapingGlyphs(TFont const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(unsigned int)>,std::function<void ()(void)>)::$_0>,BOOL ()(unsigned int,OTL::ScriptTable const*,BOOL &)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x50uLL);
  *(void *)uint64_t v2 = &unk_1ED060ED8;
  *(_OWORD *)(v2 + 24)  = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(v2 + 40)  = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(v2 + 56)  = *(_OWORD *)(a1 + 56);
  *((void *)v2 + 9)  = *(void *)(a1 + 72);
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8)  = result;
  return result;
}

__n128 std::__function::__func<TOpenTypeMorph::AddShapingGlyphs(TFont const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(unsigned int)>,std::function<void ()(void)>)::$_0,std::allocator<TOpenTypeMorph::AddShapingGlyphs(TFont const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(unsigned int)>,std::function<void ()(void)>)::$_0>,BOOL ()(unsigned int,OTL::ScriptTable const*,BOOL &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2  = &unk_1ED060ED8;
  *(_OWORD *)(a2 + 8)  = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  long long v3 = *(_OWORD *)(a1 + 40);
  long long v4 = *(_OWORD *)(a1 + 56);
  *(void *)(a2 + 72)  = *(void *)(a1 + 72);
  *(_OWORD *)(a2 + 56)  = v4;
  *(_OWORD *)(a2 + 40)  = v3;
  *(__n128 *)(a2 + 24)  = result;
  return result;
}

void std::__function::__func<TOpenTypeMorph::AddShapingGlyphs(TFont const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(unsigned int)>,std::function<void ()(void)>)::$_0::operator() const(unsigned int,OTL::ScriptTable const*,BOOL &)::{lambda(unsigned int,OTL::LangSysTable const*,BOOL &)#1},std::allocator<TOpenTypeMorph::AddShapingGlyphs(TFont const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(unsigned int)>,std::function<void ()(void)>)::$_0::operator() const(unsigned int,OTL::ScriptTable const*,BOOL &)::{lambda(unsigned int,OTL::LangSysTable const*,BOOL &)#1}>,BOOL ()(unsigned int,OTL::LangSysTable const*,BOOL &)>::~__func()
{
}

__n128 std::__function::__func<TOpenTypeMorph::AddShapingGlyphs(TFont const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(unsigned int)>,std::function<void ()(void)>)::$_0::operator() const(unsigned int,OTL::ScriptTable const*,BOOL &)::{lambda(unsigned int,OTL::LangSysTable const*,BOOL &)#1},std::allocator<TOpenTypeMorph::AddShapingGlyphs(TFont const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(unsigned int)>,std::function<void ()(void)>)::$_0::operator() const(unsigned int,OTL::ScriptTable const*,BOOL &)::{lambda(unsigned int,OTL::LangSysTable const*,BOOL &)#1}>,BOOL ()(unsigned int,OTL::LangSysTable const*,BOOL &)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x48uLL);
  *(void *)uint64_t v2 = &unk_1ED062168;
  *(_OWORD *)(v2 + 8)  = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24)  = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(v2 + 40)  = *(_OWORD *)(a1 + 40);
  __n128 result = *(__n128 *)(a1 + 56);
  *(__n128 *)(v2 + 56)  = result;
  return result;
}

__n128 std::__function::__func<TOpenTypeMorph::AddShapingGlyphs(TFont const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(unsigned int)>,std::function<void ()(void)>)::$_0::operator() const(unsigned int,OTL::ScriptTable const*,BOOL &)::{lambda(unsigned int,OTL::LangSysTable const*,BOOL &)#1},std::allocator<TOpenTypeMorph::AddShapingGlyphs(TFont const&,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(unsigned int)>,std::function<void ()(void)>)::$_0::operator() const(unsigned int,OTL::ScriptTable const*,BOOL &)::{lambda(unsigned int,OTL::LangSysTable const*,BOOL &)#1}>,BOOL ()(unsigned int,OTL::LangSysTable const*,BOOL &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2  = &unk_1ED062168;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  long long v4 = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 56)  = *(_OWORD *)(a1 + 56);
  *(_OWORD *)(a2 + 40)  = v4;
  *(_OWORD *)(a2 + 24)  = v3;
  *(__n128 *)(a2 + 8)  = result;
  return result;
}

void std::__function::__func<TOpenTypeMorph::AddCoveredGlyphs(TFont const&,CTFeatureSetting *,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0,std::allocator<TOpenTypeMorph::AddCoveredGlyphs(TFont const&,CTFeatureSetting *,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0>,BOOL ()(unsigned int,OTL::ScriptTable const*,BOOL &)>::~__func()
{
}

__n128 std::__function::__func<TOpenTypeMorph::AddCoveredGlyphs(TFont const&,CTFeatureSetting *,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0,std::allocator<TOpenTypeMorph::AddCoveredGlyphs(TFont const&,CTFeatureSetting *,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0>,BOOL ()(unsigned int,OTL::ScriptTable const*,BOOL &)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x48uLL);
  *(void *)uint64_t v2 = &unk_1ED060E90;
  *(_OWORD *)(v2 + 8)  = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24)  = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(v2 + 40)  = *(_OWORD *)(a1 + 40);
  __n128 result = *(__n128 *)(a1 + 56);
  *(__n128 *)(v2 + 56)  = result;
  return result;
}

__n128 std::__function::__func<TOpenTypeMorph::AddCoveredGlyphs(TFont const&,CTFeatureSetting *,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0,std::allocator<TOpenTypeMorph::AddCoveredGlyphs(TFont const&,CTFeatureSetting *,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0>,BOOL ()(unsigned int,OTL::ScriptTable const*,BOOL &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2  = &unk_1ED060E90;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  long long v4 = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 56)  = *(_OWORD *)(a1 + 56);
  *(_OWORD *)(a2 + 40)  = v4;
  *(_OWORD *)(a2 + 24)  = v3;
  *(__n128 *)(a2 + 8)  = result;
  return result;
}

uint64_t std::__function::__func<TOpenTypeMorph::AddCoveredGlyphs(TFont const&,CTFeatureSetting *,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0,std::allocator<TOpenTypeMorph::AddCoveredGlyphs(TFont const&,CTFeatureSetting *,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0>,BOOL ()(unsigned int,OTL::ScriptTable const*,BOOL &)>::operator()(uint64_t a1, int *a2, unsigned __int16 **a3)
{
  v12[4]  = *MEMORY[0x1E4F143B8];
  int v4 = *a2;
  uint64_t v5 = *a3;
  unint64_t v6 = **(void **)(a1 + 8);
  unint64_t v7 = **(void **)(a1 + 16);
  unint64_t v8 = operator new(0x40uLL);
  *(void *)unint64_t v8 = &unk_1ED062120;
  v8[2]  = v4;
  long long v9 = *(_OWORD *)(a1 + 40);
  *((_OWORD *)v8 + 1)  = *(_OWORD *)(a1 + 24);
  *((_OWORD *)v8 + 2)  = v9;
  *((_OWORD *)v8 + 3)  = *(_OWORD *)(a1 + 56);
  v12[3]  = v8;
  uint64_t v10 = OTL::GCommon::IterateLangSysTables(v6, v5, v7, (uint64_t)v12);
  std::__function::__value_func<BOOL ()(unsigned int,OTL::LangSysTable const*,BOOL &)>::~__value_func[abi:nn180100](v12);
  return v10;
}

void std::__function::__func<TOpenTypeMorph::AddCoveredGlyphs(TFont const&,CTFeatureSetting *,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0::operator() const(unsigned int,OTL::ScriptTable const*,BOOL &)::{lambda(unsigned int,OTL::LangSysTable const*,BOOL &)#1},std::allocator<TOpenTypeMorph::AddCoveredGlyphs(TFont const&,CTFeatureSetting *,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0::operator() const(unsigned int,OTL::ScriptTable const*,BOOL &)::{lambda(unsigned int,OTL::LangSysTable const*,BOOL &)#1}>,BOOL ()(unsigned int,OTL::LangSysTable const*,BOOL &)>::~__func()
{
}

__n128 std::__function::__func<TOpenTypeMorph::AddCoveredGlyphs(TFont const&,CTFeatureSetting *,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0::operator() const(unsigned int,OTL::ScriptTable const*,BOOL &)::{lambda(unsigned int,OTL::LangSysTable const*,BOOL &)#1},std::allocator<TOpenTypeMorph::AddCoveredGlyphs(TFont const&,CTFeatureSetting *,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0::operator() const(unsigned int,OTL::ScriptTable const*,BOOL &)::{lambda(unsigned int,OTL::LangSysTable const*,BOOL &)#1}>,BOOL ()(unsigned int,OTL::LangSysTable const*,BOOL &)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x40uLL);
  *(void *)uint64_t v2 = &unk_1ED062120;
  *(_OWORD *)(v2 + 8)  = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24)  = *(_OWORD *)(a1 + 24);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40)  = result;
  *((void *)v2 + 7)  = *(void *)(a1 + 56);
  return result;
}

__n128 std::__function::__func<TOpenTypeMorph::AddCoveredGlyphs(TFont const&,CTFeatureSetting *,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0::operator() const(unsigned int,OTL::ScriptTable const*,BOOL &)::{lambda(unsigned int,OTL::LangSysTable const*,BOOL &)#1},std::allocator<TOpenTypeMorph::AddCoveredGlyphs(TFont const&,CTFeatureSetting *,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0::operator() const(unsigned int,OTL::ScriptTable const*,BOOL &)::{lambda(unsigned int,OTL::LangSysTable const*,BOOL &)#1}>,BOOL ()(unsigned int,OTL::LangSysTable const*,BOOL &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2  = &unk_1ED062120;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  long long v4 = *(_OWORD *)(a1 + 40);
  *(void *)(a2 + 56)  = *(void *)(a1 + 56);
  *(_OWORD *)(a2 + 40)  = v4;
  *(_OWORD *)(a2 + 24)  = v3;
  *(__n128 *)(a2 + 8)  = result;
  return result;
}

uint64_t std::__function::__func<TOpenTypeMorph::AddCoveredGlyphs(TFont const&,CTFeatureSetting *,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0::operator() const(unsigned int,OTL::ScriptTable const*,BOOL &)::{lambda(unsigned int,OTL::LangSysTable const*,BOOL &)#1},std::allocator<TOpenTypeMorph::AddCoveredGlyphs(TFont const&,CTFeatureSetting *,std::function<void ()(unsigned short,unsigned short)>,std::function<void ()(void)>)::$_0::operator() const(unsigned int,OTL::ScriptTable const*,BOOL &)::{lambda(unsigned int,OTL::LangSysTable const*,BOOL &)#1}>,BOOL ()(unsigned int,OTL::LangSysTable const*,BOOL &)>::operator()(uint64_t a1, unsigned int *a2)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  unsigned int v3 = *a2;
  unint64_t v16 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  v15[3]  = v4;
  v15[4]  = v4;
  v15[1]  = v4;
  v15[2]  = v4;
  v15[0]  = v4;
  OTL::GCommon::GCommon((uint64_t)v15, 0, *(unsigned char **)(a1 + 16), **(CFDataRef **)(a1 + 24), *(void *)(a1 + 32), *(_DWORD *)(a1 + 8), v3);
  *(void *)&v15[0]  = &unk_1ED05FB20;
  *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  _OWORD v29[8] = v5;
  v29[7]  = v5;
  v29[6]  = v5;
  v29[5]  = v5;
  v29[4]  = v5;
  v29[3]  = v5;
  v29[2]  = v5;
  v29[1]  = v5;
  v29[0]  = v5;
  memset(v28, 0, sizeof(v28));
  unsigned int v30 = v29;
  if (OTL::GCommon::GetFeatures((OTL::GCommon *)v15, (OTL::FeatureList *)v28))
  {
    *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v6 + 1)  = 0xAAAAAAAAAAAAAAAALL;
    v26[14]  = v6;
    v26[13]  = v6;
    v26[12]  = v6;
    v26[11]  = v6;
    v26[10]  = v6;
    v26[9]  = v6;
    v26[8]  = v6;
    v26[7]  = v6;
    v26[6]  = v6;
    v26[5]  = v6;
    v26[4]  = v6;
    v26[3]  = v6;
    v26[2]  = v6;
    v26[1]  = v6;
    v26[0]  = v6;
    int64x2_t v24 = 0uLL;
    uint64_t v25 = 0;
    unsigned int v27 = v26;
    values[0]  = **(void ***)(a1 + 40);
    uint64_t v7 = 1;
    CFArrayRef v8 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)values, 1, MEMORY[0x1E4F1D510]);
    long long v12 = xmmword_184BA1F58;
    memset(v13, 170, sizeof(v13));
    unint64_t v14 = 0xAAAAAAAAFFFFFFFFLL;
    memset(v11, 170, sizeof(v11));
    TFontFeatureSettingList::TFontFeatureSettingList((TFontFeatureSettingList *)v11, v8);
    ConvertSettingsToOTFeatures(v28, (atomic_ullong *)v11, **(_DWORD **)(a1 + 16) & 1, &v24, 0, 0, 0);
    if (v24.i64[0] != v24.i64[1])
    {
      *(void *)&long long v9 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v9 + 1)  = 0xAAAAAAAAAAAAAAAALL;
      v21[6]  = v9;
      v21[5]  = v9;
      v21[4]  = v9;
      v21[3]  = v9;
      v21[2]  = v9;
      v21[1]  = v9;
      v21[0]  = v9;
      unint64_t v22 = 0xAAAAAAAAAAAAAAAALL;
      unint64_t v23 = v21;
      memset(values, 0, sizeof(values));
      OTL::GCommon::GetLookups((uint64_t)v15, (uint64_t)&v24, (uint64_t)values, 0);
      std::__function::__value_func<void ()(unsigned short,unsigned short)>::__value_func[abi:nn180100]((uint64_t)v19, *(void *)(a1 + 48));
      std::__function::__value_func<void ()(void)>::__value_func[abi:nn180100]((uint64_t)v18, *(void *)(a1 + 56));
      uint64_t v7 = ((uint64_t (*)(_OWORD *, void **, void *, void *))OTL::GSUB::AddCoveredGlyphs)(v15, values, v19, v18);
      std::__function::__value_func<void ()(void)>::~__value_func[abi:nn180100](v18);
      std::__function::__value_func<void ()(unsigned short,unsigned short)>::~__value_func[abi:nn180100](v19);
      uint64_t v17 = values;
      std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100](&v17);
    }
    std::__hash_table<std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>>>::~__hash_table((uint64_t)v13);
    std::__hash_table<std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::pair<TInlineVector<std::pair<unsigned short,unsigned short>,30ul>,KerningStatus>>>>::~__hash_table((uint64_t)&v11[5]);
    std::__tree<std::__value_type<long,TAATDeltaYListEntry>,std::__map_value_compare<long,std::__value_type<long,TAATDeltaYListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TAATDeltaYListEntry>>>::destroy((uint64_t)&v11[1], (void *)v11[2]);

    values[0]  = &v24;
    std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)values);
  }
  else
  {
    uint64_t v7 = 1;
  }
  v24.i64[0]  = (uint64_t)v28;
  std::vector<unsigned int,TInlineBufferAllocator<unsigned int,36ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v24);
  return v7;
}

void std::__function::__func<TOpenTypeMorph::AddShapingLanguages(TBaseFont const&,std::function<void ()(__CFString const*)>,std::function<void ()(void)>)::$_0,std::allocator<TOpenTypeMorph::AddShapingLanguages(TBaseFont const&,std::function<void ()(__CFString const*)>,std::function<void ()(void)>)::$_0>,BOOL ()(unsigned int,OTL::ScriptTable const*,BOOL &)>::~__func()
{
}

__n128 std::__function::__func<TOpenTypeMorph::AddShapingLanguages(TBaseFont const&,std::function<void ()(__CFString const*)>,std::function<void ()(void)>)::$_0,std::allocator<TOpenTypeMorph::AddShapingLanguages(TBaseFont const&,std::function<void ()(__CFString const*)>,std::function<void ()(void)>)::$_0>,BOOL ()(unsigned int,OTL::ScriptTable const*,BOOL &)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1ED060F68;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8)  = result;
  *((void *)v2 + 3)  = *(void *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<TOpenTypeMorph::AddShapingLanguages(TBaseFont const&,std::function<void ()(__CFString const*)>,std::function<void ()(void)>)::$_0,std::allocator<TOpenTypeMorph::AddShapingLanguages(TBaseFont const&,std::function<void ()(__CFString const*)>,std::function<void ()(void)>)::$_0>,BOOL ()(unsigned int,OTL::ScriptTable const*,BOOL &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2  = &unk_1ED060F68;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24)  = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8)  = result;
  return result;
}

uint64_t std::__function::__func<TOpenTypeMorph::AddShapingLanguages(TBaseFont const&,std::function<void ()(__CFString const*)>,std::function<void ()(void)>)::$_0,std::allocator<TOpenTypeMorph::AddShapingLanguages(TBaseFont const&,std::function<void ()(__CFString const*)>,std::function<void ()(void)>)::$_0>,BOOL ()(unsigned int,OTL::ScriptTable const*,BOOL &)>::operator()(uint64_t a1, unsigned int *a2, unsigned __int16 **a3)
{
  v10[4]  = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *a2;
  long long v4 = *a3;
  unint64_t v5 = **(void **)(a1 + 8);
  unint64_t v6 = **(void **)(a1 + 16);
  uint64_t v7 = *(void *)(a1 + 24);
  v10[0]  = &unk_1ED0621F8;
  v10[1]  = v3;
  v10[2]  = v7;
  v10[3]  = v10;
  uint64_t v8 = OTL::GCommon::IterateLangSysTables(v5, v4, v6, (uint64_t)v10);
  std::__function::__value_func<BOOL ()(unsigned int,OTL::LangSysTable const*,BOOL &)>::~__value_func[abi:nn180100](v10);
  return v8;
}

void std::__function::__func<TOpenTypeMorph::AddShapingLanguages(TBaseFont const&,std::function<void ()(__CFString const*)>,std::function<void ()(void)>)::$_0::operator() const(unsigned int,OTL::ScriptTable const*,BOOL &)::{lambda(unsigned int,OTL::LangSysTable const*,BOOL &)#1},std::allocator<TOpenTypeMorph::AddShapingLanguages(TBaseFont const&,std::function<void ()(__CFString const*)>,std::function<void ()(void)>)::$_0::operator() const(unsigned int,OTL::ScriptTable const*,BOOL &)::{lambda(unsigned int,OTL::LangSysTable const*,BOOL &)#1}>,BOOL ()(unsigned int,OTL::LangSysTable const*,BOOL &)>::~__func()
{
}

__n128 std::__function::__func<TOpenTypeMorph::AddShapingLanguages(TBaseFont const&,std::function<void ()(__CFString const*)>,std::function<void ()(void)>)::$_0::operator() const(unsigned int,OTL::ScriptTable const*,BOOL &)::{lambda(unsigned int,OTL::LangSysTable const*,BOOL &)#1},std::allocator<TOpenTypeMorph::AddShapingLanguages(TBaseFont const&,std::function<void ()(__CFString const*)>,std::function<void ()(void)>)::$_0::operator() const(unsigned int,OTL::ScriptTable const*,BOOL &)::{lambda(unsigned int,OTL::LangSysTable const*,BOOL &)#1}>,BOOL ()(unsigned int,OTL::LangSysTable const*,BOOL &)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1ED0621F8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8)  = result;
  return result;
}

__n128 std::__function::__func<TOpenTypeMorph::AddShapingLanguages(TBaseFont const&,std::function<void ()(__CFString const*)>,std::function<void ()(void)>)::$_0::operator() const(unsigned int,OTL::ScriptTable const*,BOOL &)::{lambda(unsigned int,OTL::LangSysTable const*,BOOL &)#1},std::allocator<TOpenTypeMorph::AddShapingLanguages(TBaseFont const&,std::function<void ()(__CFString const*)>,std::function<void ()(void)>)::$_0::operator() const(unsigned int,OTL::ScriptTable const*,BOOL &)::{lambda(unsigned int,OTL::LangSysTable const*,BOOL &)#1}>,BOOL ()(unsigned int,OTL::LangSysTable const*,BOOL &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2  = &unk_1ED0621F8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8)  = result;
  return result;
}

uint64_t std::__function::__func<TOpenTypeMorph::AddShapingLanguages(TBaseFont const&,std::function<void ()(__CFString const*)>,std::function<void ()(void)>)::$_0::operator() const(unsigned int,OTL::ScriptTable const*,BOOL &)::{lambda(unsigned int,OTL::LangSysTable const*,BOOL &)#1},std::allocator<TOpenTypeMorph::AddShapingLanguages(TBaseFont const&,std::function<void ()(__CFString const*)>,std::function<void ()(void)>)::$_0::operator() const(unsigned int,OTL::ScriptTable const*,BOOL &)::{lambda(unsigned int,OTL::LangSysTable const*,BOOL &)#1}>,BOOL ()(unsigned int,OTL::LangSysTable const*,BOOL &)>::operator()(uint64_t a1, unsigned int *a2)
{
  unsigned int v3 = *a2;
  if (*a2)
  {
    id v13 = (id)0xAAAAAAAAAAAAAAAALL;
    LanguagesWithLangSysTag(v3, (CFArrayRef *)&v13);
    CFArrayRef explicit = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v13, memory_order_acquire);
    if (explicit)
    {
      CFIndex Count = CFArrayGetCount(explicit);
      if (Count)
      {
        CFIndex v6 = Count;
        for (CFIndex i = 0; i != v6; ++i)
        {
          CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(explicit, i);
          std::function<void ()(__CFString const*)>::operator()(*(void *)(a1 + 16), (uint64_t)ValueAtIndex);
        }
      }
    }
  }
  else
  {
    ScriptCodeForScriptTag(*(_DWORD *)(a1 + 8));
    ShortName  = (const char *)uscript_getShortName();
    if (ShortName)
    {
      CFStringRef v10 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], ShortName, 0x600u);
      if (v10)
      {
        CFStringRef v11 = v10;
        std::function<void ()(__CFString const*)>::operator()(*(void *)(a1 + 16), (uint64_t)v10);
        CFRelease(v11);
      }
    }
  }
  return 1;
}

uint64_t std::__function::__value_func<void ()(unsigned int,CFRange)>::__value_func[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24)  = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24)  = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24)  = 0;
  }
  return a1;
}

void *std::__function::__value_func<void ()(unsigned int,CFRange)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t UniversalClassTable::EnumerateScriptRanges(uint64_t a1)
{
  for (uint64_t i = 0; i != 1600; i += 16)
    uint64_t result = std::function<void ()(unsigned int,CFRange)>::operator()(a1, *(_DWORD *)&kClassDataDirectory[i], *(unsigned int *)&kClassDataDirectory[i + 4], *(unsigned __int16 *)&kClassDataDirectory[i + 10]+ (unint64_t)*(unsigned __int16 *)&kClassDataDirectory[i + 8]);
  return result;
}

uint64_t UniversalClassTable::determineCharClass(unsigned int c)
{
  if (c == 32) {
    return 14;
  }
  if (c == 847) {
    return 21;
  }
  if (c >> 9 < 0x7F || (uint64_t result = 22, c >> 4 >= 0xFE1) && c - 917760 >= 0xF0)
  {
    int v3 = u_charType(c);
    if (v3 > 24)
    {
      if (v3 == 27 || v3 == 25) {
        return 16;
      }
    }
    else
    {
      if (v3 == 12) {
        return 14;
      }
      if (v3 == 23) {
        return 2;
      }
    }
    IntPropertyint Value = u_getIntPropertyValue(c, UCHAR_SCRIPT);
    if (IntPropertyValue == 71) {
      unsigned int v5 = 23;
    }
    else {
      unsigned int v5 = 0;
    }
    if (IntPropertyValue) {
      return v5;
    }
    else {
      return 14;
    }
  }
  return result;
}

uint64_t UniversalClassTable::ClassTableForScript@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  if (this)
  {
    BOOL v4 = 0;
    memset(v3, 170, sizeof(v3));
    FirstBlockForScript(&v4, this, (uint64_t)v3);
    if (v3[0]) {
      operator new();
    }
    this  = 0;
    *a2  = 0;
  }
  else
  {
    *a2  = 0;
  }
  return this;
}

uint64_t *FirstBlockForScript@<X0>(BOOL *a1@<X1>, unsigned int a2@<W0>, uint64_t a3@<X8>)
{
  if (FirstBlockForScript(unsigned int,BOOL *)::once != -1) {
    dispatch_once_f(&FirstBlockForScript(unsigned int,BOOL *)::once, 0, (dispatch_function_t)FirstBlockForScript(unsigned int,BOOL *)::$_0::__invoke);
  }
  if (result)
  {
    uint64_t v7 = result[3];
    int v8 = *(unsigned __int16 *)(v7 + 14);
    if (a1) {
      *a1  = v8 != 0;
    }
    *(void *)a3  = (char *)&kClassDataTable + 2 * *(unsigned __int16 *)(v7 + 12);
    int v9 = *(_DWORD *)(v7 + 4);
    int v10 = v9 + *(unsigned __int16 *)(v7 + 8);
    *(_DWORD *)(a3 + 8)  = v9;
    *(_DWORD *)(a3 + 12)  = v10 - 1;
    *(_DWORD *)(a3 + 16)  = v10 + *(unsigned __int16 *)(v7 + 10);
    *(unsigned char *)(a3 + 20)  = v8 != 0;
  }
  else
  {
    *(void *)a3  = 0;
    *(void *)(a3 + 8)  = 0;
    *(void *)(a3 + 16)  = 0;
  }
  return result;
}

uint64_t UniversalClassTable::getCharClass(UniversalClassTable *this, unsigned int c)
{
  if (c >= *(_DWORD *)this && *((_DWORD *)this + 1) >= c) {
    return *(unsigned __int16 *)(*((void *)this + 2) + 2 * (c - *(_DWORD *)this));
  }
  uint64_t v2 = 0;
  while (1)
  {
    unsigned int v3 = *(_DWORD *)&kClassDataDirectory[v2 + 4];
    if (c >= v3 && v3 + *(unsigned __int16 *)&kClassDataDirectory[v2 + 8] - 1 >= c) {
      break;
    }
    v2 += 16;
    if (v2 == 1600) {
      return UniversalClassTable::determineCharClass(c);
    }
  }
  return kClassDataTable[*(unsigned __int16 *)&kClassDataDirectory[v2 + 12] + c - v3];
}

uint64_t UniversalClassTable::getSplitMatra(UniversalClassTable *this)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = 0;
  int v10 = 0;
  *(void *)&long long v1 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v1 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  v14[2]  = v1;
  v14[0]  = v1;
  v14[1]  = v1;
  unint64_t v15 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v16 = (char *)v14 + 4;
  v12[2]  = (char *)v14 + 4;
  uint64_t v13 = 0;
  LODWORD(v14[0])  = 0;
  v12[0]  = &v13;
  v12[1]  = (char *)v14 + 4;
  LODWORD(v11)  = 0;
  unorm2_getNFDInstance();
  int Decomposition = unorm2_getDecomposition();
  if (Decomposition < 1)
  {
    uint64_t v7 = 0;
  }
  else
  {
    uint64_t v3 = 0;
    BOOL v4 = (int *)&v9;
    uint64_t v5 = v12[0];
    do
    {
      int v6 = *(unsigned __int16 *)(v5 + 2 * v3);
      if ((v6 & 0xFC00) == 0xD800)
      {
        ++v3;
        int v6 = *(unsigned __int16 *)(v5 + 2 * v3) + (v6 << 10) - 56613888;
      }
      *v4++  = v6;
      ++v3;
    }
    while (v3 < Decomposition);
    uint64_t v7 = v9;
  }
  CFStringRef v11 = (void **)v12;
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100](&v11);
  return v7;
}

void *TInlineBufferAllocator<unsigned short,48ul>::allocate(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 96);
  uint64_t v2 = (unint64_t *)(a1 + 96);
  uint64_t v3 = v4;
  unint64_t v5 = v4 + 2 * a2;
  if (v5 <= (unint64_t)v2)
  {
    *uint64_t v2 = v5;
    return (void *)v3;
  }
  else
  {
    if (a2 < 0) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    return operator new(2 * a2);
  }
}

uint64_t std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,48ul> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3) {
    *(void *)(a1 + 16)  = v2 + ((v3 - v2 + 1) & 0xFFFFFFFFFFFFFFFELL);
  }
  uint64_t v4 = *(void **)a1;
  if (*(void *)a1)
  {
    unint64_t v5 = *(void *)(a1 + 32);
    int v6 = (void *)(v5 + 96);
    if (v5 <= (unint64_t)v4 && v6 > v4)
    {
      if (*(void *)(a1 + 24) == *v6) {
        *int v6 = v4;
      }
    }
    else
    {
      operator delete(v4);
    }
  }
  return a1;
}

void std::vector<unsigned short,TInlineBufferAllocator<unsigned short,48ul>>::__destroy_vector::operator()[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  if (v2)
  {
    *(void *)(a1 + 8)  = v2;
    uint64_t v3 = (void *)(a1 + 120);
    if (a1 + 24 <= (unint64_t)v2)
    {
      BOOL v4 = v3 >= v2;
      BOOL v5 = v3 == v2;
    }
    else
    {
      BOOL v4 = 0;
      BOOL v5 = 0;
    }
    if (!v5 && v4)
    {
      if (*(void *)(a1 + 16) == *(void *)(a1 + 120)) {
        *uint64_t v3 = v2;
      }
    }
    else
    {
      operator delete(v2);
    }
  }
}

uint64_t *std::unordered_map<unsigned int,anonymous namespace'::DirectoryEntry const&>::find[abi:nn180100](unsigned int a1)
{
  if (!*((void *)&FirstBlockForScript(unsigned int,BOOL *)::sFirstEntries + 1)) {
    return 0;
  }
  uint8x8_t v1 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&FirstBlockForScript(unsigned int,BOOL *)::sFirstEntries + 8));
  v1.i16[0]  = vaddlv_u8(v1);
  if (v1.u32[0] > 1uLL)
  {
    unint64_t v2 = a1;
    if (*((void *)&FirstBlockForScript(unsigned int,BOOL *)::sFirstEntries + 1) <= (unint64_t)a1) {
      unint64_t v2 = (unint64_t)a1 % *((void *)&FirstBlockForScript(unsigned int,BOOL *)::sFirstEntries + 1);
    }
  }
  else
  {
    unint64_t v2 = (DWORD2(FirstBlockForScript(unsigned int,BOOL *)::sFirstEntries) - 1) & a1;
  }
  uint64_t i = *(uint64_t **)(FirstBlockForScript(unsigned int,BOOL *)::sFirstEntries + 8 * v2);
  if (i)
  {
    for (uint64_t i = (uint64_t *)*i; i; uint64_t i = (uint64_t *)*i)
    {
      unint64_t v4 = i[1];
      if (v4 == a1)
      {
        if (*((_DWORD *)i + 4) == a1) {
          return i;
        }
      }
      else
      {
        if (v1.u32[0] > 1uLL)
        {
          if (v4 >= *((void *)&FirstBlockForScript(unsigned int,BOOL *)::sFirstEntries + 1)) {
            v4 %= *((void *)&FirstBlockForScript(unsigned int,BOOL *)::sFirstEntries + 1);
          }
        }
        else
        {
          v4 &= *((void *)&FirstBlockForScript(unsigned int,BOOL *)::sFirstEntries + 1) - 1;
        }
        if (v4 != v2) {
          return 0;
        }
      }
    }
  }
  return i;
}

void FirstBlockForScript(unsigned int,BOOL *)::$_0::__invoke()
{
  uint64_t v0 = 0;
  unint64_t v1 = 0;
  FirstBlockForScript(unsigned int,BOOL *)::sFirstEntries  = 0u;
  *(_OWORD *)&qword_1EB2CDE48  = 0u;
  unint64_t v2 = (unsigned int *)"****-";
  dword_1EB2CDE58  = 1065353216;
  do
  {
    unint64_t v3 = *v2;
      goto LABEL_76;
    if (v1)
    {
      uint8x8_t v4 = (uint8x8_t)vcnt_s8((int8x8_t)v1);
      v4.i16[0]  = vaddlv_u8(v4);
      if (v4.u32[0] > 1uLL)
      {
        unint64_t v5 = v3;
        if (v1 <= v3) {
          unint64_t v5 = v3 % v1;
        }
      }
      else
      {
        unint64_t v5 = (v1 - 1) & v3;
      }
      int v6 = *(uint64_t ***)(FirstBlockForScript(unsigned int,BOOL *)::sFirstEntries + 8 * v5);
      if (v6)
      {
        for (uint64_t i = *v6; i; uint64_t i = (uint64_t *)*i)
        {
          unint64_t v8 = i[1];
          if (v8 == v3)
          {
            if (*((_DWORD *)i + 4) == v3) {
              goto LABEL_76;
            }
          }
          else
          {
            if (v4.u32[0] > 1uLL)
            {
              if (v8 >= v1) {
                v8 %= v1;
              }
            }
            else
            {
              v8 &= v1 - 1;
            }
            if (v8 != v5) {
              break;
            }
          }
        }
      }
    }
    else
    {
      unint64_t v5 = 0xAAAAAAAAAAAAAAAALL;
    }
    uint64_t v9 = operator new(0x20uLL);
    void *v9 = 0;
    v9[1]  = v3;
    *((_DWORD *)v9 + 4)  = v3;
    v9[3]  = v2;
    float v10 = (float)(unint64_t)(v0 + 1);
    if (!v1 || (float)(*(float *)&dword_1EB2CDE58 * (float)v1) < v10)
    {
      BOOL v11 = (v1 & (v1 - 1)) == 0;
      if (v1 < 3) {
        BOOL v11 = 0;
      }
      unint64_t v12 = (2 * v1) | !v11;
      unint64_t v13 = vcvtps_u32_f32(v10 / *(float *)&dword_1EB2CDE58);
      if (v12 <= v13) {
        int8x8_t prime = (int8x8_t)v13;
      }
      else {
        int8x8_t prime = (int8x8_t)v12;
      }
      if (*(void *)&prime == 1)
      {
        int8x8_t prime = (int8x8_t)2;
      }
      else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
      {
        int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
        unint64_t v1 = *((void *)&FirstBlockForScript(unsigned int,BOOL *)::sFirstEntries + 1);
      }
      if (*(void *)&prime > v1) {
        goto LABEL_32;
      }
      if (*(void *)&prime < v1)
      {
        unint64_t v21 = vcvtps_u32_f32((float)(unint64_t)qword_1EB2CDE50 / *(float *)&dword_1EB2CDE58);
        if (v1 < 3 || (uint8x8_t v22 = (uint8x8_t)vcnt_s8((int8x8_t)v1), v22.i16[0] = vaddlv_u8(v22), v22.u32[0] > 1uLL))
        {
          unint64_t v21 = std::__next_prime(v21);
        }
        else
        {
          uint64_t v23 = 1 << -(char)__clz(v21 - 1);
          if (v21 >= 2) {
            unint64_t v21 = v23;
          }
        }
        if (*(void *)&prime <= v21) {
          int8x8_t prime = (int8x8_t)v21;
        }
        if (*(void *)&prime >= v1)
        {
          unint64_t v1 = *((void *)&FirstBlockForScript(unsigned int,BOOL *)::sFirstEntries + 1);
        }
        else
        {
          if (prime)
          {
LABEL_32:
            if (*(void *)&prime >> 61) {
              std::__throw_bad_array_new_length[abi:nn180100]();
            }
            unint64_t v15 = operator new(8 * *(void *)&prime);
            unint64_t v16 = (void *)FirstBlockForScript(unsigned int,BOOL *)::sFirstEntries;
            *(void *)&FirstBlockForScript(unsigned int,BOOL *)::sFirstEntries  = v15;
            if (v16) {
              operator delete(v16);
            }
            uint64_t v17 = 0;
            *((int8x8_t *)&FirstBlockForScript(unsigned int,BOOL *)::sFirstEntries + 1)  = prime;
            do
              *(void *)(FirstBlockForScript(unsigned int,BOOL *)::sFirstEntries + 8 * v17++)  = 0;
            while (*(void *)&prime != v17);
            uint64_t v18 = (void **)qword_1EB2CDE48;
            if (qword_1EB2CDE48)
            {
              unint64_t v19 = *(void *)(qword_1EB2CDE48 + 8);
              uint8x8_t v20 = (uint8x8_t)vcnt_s8(prime);
              v20.i16[0]  = vaddlv_u8(v20);
              if (v20.u32[0] > 1uLL)
              {
                if (v19 >= *(void *)&prime) {
                  v19 %= *(void *)&prime;
                }
              }
              else
              {
                v19 &= *(void *)&prime - 1;
              }
              *(void *)(FirstBlockForScript(unsigned int,BOOL *)::sFirstEntries + 8 * v19)  = &qword_1EB2CDE48;
              for (j = *v18; j; unint64_t v19 = v25)
              {
                unint64_t v25 = j[1];
                if (v20.u32[0] > 1uLL)
                {
                  if (v25 >= *(void *)&prime) {
                    v25 %= *(void *)&prime;
                  }
                }
                else
                {
                  v25 &= *(void *)&prime - 1;
                }
                if (v25 != v19)
                {
                  if (!*(void *)(FirstBlockForScript(unsigned int,BOOL *)::sFirstEntries + 8 * v25))
                  {
                    *(void *)(FirstBlockForScript(unsigned int,BOOL *)::sFirstEntries + 8 * v25)  = v18;
                    goto LABEL_57;
                  }
                  *uint64_t v18 = (void *)*j;
                  *uint64_t j = **(void **)(FirstBlockForScript(unsigned int,BOOL *)::sFirstEntries + 8 * v25);
                  **(void **)(FirstBlockForScript(unsigned int,BOOL *)::sFirstEntries + 8 * v25)  = j;
                  uint64_t j = v18;
                }
                unint64_t v25 = v19;
LABEL_57:
                uint64_t v18 = (void **)j;
                uint64_t j = (void *)*j;
              }
            }
            unint64_t v1 = (unint64_t)prime;
            goto LABEL_61;
          }
          unsigned int v29 = (void *)FirstBlockForScript(unsigned int,BOOL *)::sFirstEntries;
          *(void *)&FirstBlockForScript(unsigned int,BOOL *)::sFirstEntries  = 0;
          if (v29) {
            operator delete(v29);
          }
          unint64_t v1 = 0;
          *((void *)&FirstBlockForScript(unsigned int,BOOL *)::sFirstEntries + 1)  = 0;
        }
      }
LABEL_61:
      if ((v1 & (v1 - 1)) != 0)
      {
        if (v1 <= v3) {
          unint64_t v5 = v3 % v1;
        }
        else {
          unint64_t v5 = v3;
        }
      }
      else
      {
        unint64_t v5 = (v1 - 1) & v3;
      }
    }
    uint64_t v26 = FirstBlockForScript(unsigned int,BOOL *)::sFirstEntries;
    unsigned int v27 = *(void **)(FirstBlockForScript(unsigned int,BOOL *)::sFirstEntries + 8 * v5);
    if (v27)
    {
      void *v9 = *v27;
LABEL_74:
      *unsigned int v27 = v9;
      goto LABEL_75;
    }
    void *v9 = qword_1EB2CDE48;
    qword_1EB2CDE48  = (uint64_t)v9;
    *(void *)(v26 + 8 * v5)  = &qword_1EB2CDE48;
    if (*v9)
    {
      unint64_t v28 = *(void *)(*v9 + 8);
      if ((v1 & (v1 - 1)) != 0)
      {
        if (v28 >= v1) {
          v28 %= v1;
        }
      }
      else
      {
        v28 &= v1 - 1;
      }
      unsigned int v27 = (void *)(FirstBlockForScript(unsigned int,BOOL *)::sFirstEntries + 8 * v28);
      goto LABEL_74;
    }
LABEL_75:
    uint64_t v0 = ++qword_1EB2CDE50;
LABEL_76:
    v2 += 4;
  }
  while (v2 != (unsigned int *)&kClassDataTable);
}

void std::__function::__func<TOpenTypePositioningEngine::PositionRuns(SyncState &,KerningStatus &)::$_1,std::allocator<TOpenTypePositioningEngine::PositionRuns(SyncState &,KerningStatus &)::$_1>,BOOL ()(unsigned int,OTL::FeatureTable const*,BOOL &)>::~__func()
{
}

void *std::__function::__func<TOpenTypePositioningEngine::PositionRuns(SyncState &,KerningStatus &)::$_1,std::allocator<TOpenTypePositioningEngine::PositionRuns(SyncState &,KerningStatus &)::$_1>,BOOL ()(unsigned int,OTL::FeatureTable const*,BOOL &)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1ED0612C8;
  result[1]  = v3;
  return result;
}

uint64_t std::__function::__func<TOpenTypePositioningEngine::PositionRuns(SyncState &,KerningStatus &)::$_1,std::allocator<TOpenTypePositioningEngine::PositionRuns(SyncState &,KerningStatus &)::$_1>,BOOL ()(unsigned int,OTL::FeatureTable const*,BOOL &)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2  = &unk_1ED0612C8;
  a2[1]  = v2;
  return result;
}

CTParagraphStyleRef CTParagraphStyleCreateCopy(CTParagraphStyleRef paragraphStyle)
{
  if (!paragraphStyle) {
    return 0;
  }
  v8[0]  = 0;
  v8[1]  = (TParagraphStyle *)0xAAAAAAAAAAAAAA00;
  if (!TParagraphStyle::SetStyle((TParagraphStyle *)v8, paragraphStyle)) {
    return 0;
  }
  id v7 = (id)0xAAAAAAAAAAAAAAAALL;
  uint64_t v1 = TCFBase<TNativeParagraphStyle>::Allocate();
  if (v1)
  {
    uint64_t v2 = (void *)v1;
    uint64_t v3 = (TNativeParagraphStyle *)(v1 + 48);
    v2[2]  = 0;
    v2[3]  = TNativeParagraphStyle::Hash;
    v2[4]  = 0;
    void v2[5] = v3;
    TNativeParagraphStyle::TNativeParagraphStyle(v3, v8);
    id v9 = v2;
    id v6 = (id)atomic_exchange((atomic_ullong *volatile)&v9, 0);
  }
  else
  {
    id v6 = 0;
  }
  id v7 = (id)atomic_exchange((atomic_ullong *volatile)&v6, 0);

  uint8x8_t v4 = (const __CTParagraphStyle *)atomic_exchange((atomic_ullong *volatile)&v7, 0);
  return v4;
}

BOOL CTParagraphStyleGetValueForSpecifier(CTParagraphStyleRef paragraphStyle, CTParagraphStyleSpecifier spec, size_t valueBufferSize, void *valueBuffer)
{
  CTParagraphStyleRef v5 = paragraphStyle;
  LOBYTE(paragraphStyle)  = 0;
  if (v5)
  {
    if (valueBuffer)
    {
      unint64_t v16 = 0;
      unint64_t v17 = 0xAAAAAAAAAAAAAA00;
      LODWORD(paragraphStyle)  = TParagraphStyle::SetStyle((TParagraphStyle *)&v16, v5);
      if (paragraphStyle)
      {
        switch(spec)
        {
          case kCTParagraphStyleSpecifierAlignment:
            if (!valueBufferSize) {
              goto LABEL_48;
            }
            Alignment  = TParagraphStyle::GetAlignment(&v16, v8);
            goto LABEL_35;
          case kCTParagraphStyleSpecifierFirstLineHeadIndent:
            if (valueBufferSize < 8) {
              goto LABEL_48;
            }
            FirstLineHeadIndent  = TParagraphStyle::GetFirstLineHeadIndent(&v16, v8);
            goto LABEL_43;
          case kCTParagraphStyleSpecifierHeadIndent:
            if (valueBufferSize < 8) {
              goto LABEL_48;
            }
            FirstLineHeadIndent  = TParagraphStyle::GetHeadIndent(&v16, v8);
            goto LABEL_43;
          case kCTParagraphStyleSpecifierTailIndent:
            if (valueBufferSize < 8) {
              goto LABEL_48;
            }
            FirstLineHeadIndent  = TParagraphStyle::GetTailIndent(&v16, v8);
            goto LABEL_43;
          case kCTParagraphStyleSpecifierTabStops:
            if (valueBufferSize < 8) {
              goto LABEL_48;
            }
            TabStops  = TParagraphStyle::GetTabStops(&v16, v8);
            goto LABEL_47;
          case kCTParagraphStyleSpecifierDefaultTabInterval:
            if (valueBufferSize < 8) {
              goto LABEL_48;
            }
            TParagraphStyle::GetDefaultTabInterval(&v16, v8);
            goto LABEL_43;
          case kCTParagraphStyleSpecifierLineBreakMode:
            if (!valueBufferSize) {
              goto LABEL_48;
            }
            Alignment  = TParagraphStyle::GetLineBreakMode(&v16, v8);
            goto LABEL_35;
          case kCTParagraphStyleSpecifierLineHeightMultiple:
            if (valueBufferSize < 8) {
              goto LABEL_48;
            }
            FirstLineHeadIndent  = TParagraphStyle::GetLineHeightMultiple(&v16, v8);
            goto LABEL_43;
          case kCTParagraphStyleSpecifierMaximumLineHeight:
            if (valueBufferSize < 8) {
              goto LABEL_48;
            }
            FirstLineHeadIndent  = TParagraphStyle::GetMaximumLineHeight(&v16, v8);
            goto LABEL_43;
          case kCTParagraphStyleSpecifierMinimumLineHeight:
            if (valueBufferSize < 8) {
              goto LABEL_48;
            }
            FirstLineHeadIndent  = TParagraphStyle::GetMinimumLineHeight(&v16, v8);
            goto LABEL_43;
          case kCTParagraphStyleSpecifierLineSpacing:
          case kCTParagraphStyleSpecifierMinimumLineSpacing:
            if (valueBufferSize < 8) {
              goto LABEL_48;
            }
            uint64_t v9 = 0;
            if ((_BYTE)v17)
            {
              uint64_t v10 = TParagraphStyle::GetNative(v16, v8)[1];
              if (v10) {
                uint64_t v9 = *(void *)(v10 + 40);
              }
            }
            goto LABEL_40;
          case kCTParagraphStyleSpecifierParagraphSpacing:
            if (valueBufferSize < 8) {
              goto LABEL_48;
            }
            FirstLineHeadIndent  = TParagraphStyle::GetParagraphSpacing(&v16, v8);
            goto LABEL_43;
          case kCTParagraphStyleSpecifierParagraphSpacingBefore:
            if (valueBufferSize < 8) {
              goto LABEL_48;
            }
            FirstLineHeadIndent  = TParagraphStyle::GetParagraphSpacingBefore(&v16, v8);
            goto LABEL_43;
          case kCTParagraphStyleSpecifierBaseWritingDirection:
            if (!valueBufferSize) {
              goto LABEL_48;
            }
            Alignment  = TParagraphStyle::GetBaseWritingDirection(&v16, v8);
LABEL_35:
            *(unsigned char *)valueBuffer  = Alignment;
            goto LABEL_44;
          case kCTParagraphStyleSpecifierMaximumLineSpacing:
            if (valueBufferSize < 8) {
              goto LABEL_48;
            }
            uint64_t v9 = 0x416312D000000000;
            if ((_BYTE)v17)
            {
              uint64_t v14 = TParagraphStyle::GetNative(v16, v8)[1];
              if (v14) {
                uint64_t v9 = *(void *)(v14 + 32);
              }
            }
LABEL_40:
            *(void *)valueBuffer  = v9;
            goto LABEL_44;
          case kCTParagraphStyleSpecifierLineSpacingAdjustment:
            if (valueBufferSize < 8) {
              goto LABEL_48;
            }
            FirstLineHeadIndent  = TParagraphStyle::GetLineSpacingAdjustment(&v16, v8);
LABEL_43:
            *(double *)valueBuffer  = FirstLineHeadIndent;
            goto LABEL_44;
          case kCTParagraphStyleSpecifierLineBoundsOptions:
            if (valueBufferSize < 8) {
              goto LABEL_48;
            }
            TabStops  = TParagraphStyle::GetLineBoundsOptions(&v16, v8);
LABEL_47:
            *(void *)valueBuffer  = TabStops;
LABEL_44:
            LOBYTE(paragraphStyle)  = 1;
            break;
          default:
LABEL_48:
            LOBYTE(paragraphStyle)  = 0;
            break;
        }
      }
    }
  }
  return (char)paragraphStyle;
}

uint64_t CTParagraphStyleGetCompositionLanguage(CFTypeRef cf)
{
  if (!cf) {
    return 1;
  }
  v3[0]  = 0;
  v3[1]  = (TParagraphStyle *)0xAAAAAAAAAAAAAA00;
  if (TParagraphStyle::SetStyle((TParagraphStyle *)v3, cf)) {
    return (uint64_t)TParagraphStyle::GetCompositionLanguage(v3, v1);
  }
  else {
    return 1;
  }
}

const void *CTParagraphStyleSetCompositionLanguage(const void *cf, uint64_t a2)
{
  if (cf)
  {
    v3[0]  = 0;
    v3[1]  = 0xAAAAAAAAAAAAAA00;
    cf  = (const void *)TParagraphStyle::SetStyle((TParagraphStyle *)v3, cf);
    if (cf) {
      return (const void *)TParagraphStyle::SetCompositionLanguage((uint64_t)v3, a2);
    }
  }
  return cf;
}

BOOL TCFBase<TNativeParagraphStyle>::ClassEqual(uint64_t a1, uint64_t a2)
{
  return TNativeParagraphStyle::operator==(*(void *)(a1 + 40), *(void *)(a2 + 40));
}

void *TCFBase<TNativeParagraphStyle>::ClassHash(void *result)
{
  unint64_t v1 = result[3];
  uint64_t v2 = result[4];
  if (v2) {
    BOOL v3 = (result[4] & 1 | v1) == 0;
  }
  else {
    BOOL v3 = 1;
  }
  int v4 = !v3;
  if (v1) {
    BOOL v5 = 0;
  }
  else {
    BOOL v5 = v4 == 0;
  }
  if (!v5)
  {
    id v6 = (void *)(result[5] + (v2 >> 1));
    if (v2) {
      return (void *)(*(uint64_t (**)(void))(*v6 + v1))();
    }
    else {
      return (void *)((uint64_t (*)(void *))v1)(v6);
    }
  }
  return result;
}

__CFString *TCFBase<TNativeParagraphStyle>::ClassDebug(uint64_t a1)
{
  uint64_t result = TNativeParagraphStyle::DebugDescription(*(TNativeParagraphStyle **)(a1 + 40));
  if (result)
  {
    BOOL v3 = result;
    CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<%s: %p>{%@}", "CTParagraphStyle", a1, result);
    CFRelease(v3);
    return (__CFString *)v4;
  }
  return result;
}

void TNativeParagraphStyle::TNativeParagraphStyle(TNativeParagraphStyle *this, TParagraphStyle **a2)
{
  *(void *)this  = 0;
  *((void *)this + 1)  = 0;
  *((void *)this + 3)  = TParagraphStyle::GetTabStops(a2, a2);
  *((unsigned char *)this + 32)  = TParagraphStyle::GetLineBreakMode(a2, v4);
  *((unsigned char *)this + 33)  = TParagraphStyle::GetAlignment(a2, v5);
  *((unsigned char *)this + 34)  = TParagraphStyle::GetBaseWritingDirection(a2, v6);
  *((void *)this + 5)  = TParagraphStyle::GetLineBoundsOptions(a2, v7);
  *((unsigned char *)this + 48)  = TParagraphStyle::GetCompositionLanguage(a2, v8);
  FirstLineHeadIndent  = TParagraphStyle::GetFirstLineHeadIndent(a2, v9);
  if (FirstLineHeadIndent != 0.0)
  {
    if (!*(void *)this) {
      TNativeParagraphStyle::CreateIndentPack(this);
    }
    **(double **)this  = FirstLineHeadIndent;
  }
  HeadIndent  = TParagraphStyle::GetHeadIndent(a2, v10);
  if (HeadIndent != 0.0)
  {
    if (!*(void *)this) {
      TNativeParagraphStyle::CreateIndentPack(this);
    }
    *(double *)(*(void *)this + 8)  = HeadIndent;
  }
  TailIndent  = TParagraphStyle::GetTailIndent(a2, v12);
  if (TailIndent != 0.0)
  {
    if (!*(void *)this) {
      TNativeParagraphStyle::CreateIndentPack(this);
    }
    *(double *)(*(void *)this + 16)  = TailIndent;
  }
  LineHeightMultiple  = TParagraphStyle::GetLineHeightMultiple(a2, v14);
  if (LineHeightMultiple != 0.0)
  {
    uint64_t v18 = (double *)*((void *)this + 1);
    if (!v18) {
      TNativeParagraphStyle::CreateSpacePack(this);
    }
    *uint64_t v18 = LineHeightMultiple;
  }
  LineSpacingAdjustment  = TParagraphStyle::GetLineSpacingAdjustment(a2, v16);
  if (LineSpacingAdjustment != 0.0)
  {
    uint64_t v21 = *((void *)this + 1);
    if (!v21) {
      TNativeParagraphStyle::CreateSpacePack(this);
    }
    *(double *)(v21 + 24)  = LineSpacingAdjustment;
  }
  if (*((unsigned char *)a2 + 8))
  {
    uint64_t v22 = TParagraphStyle::GetNative(*a2, v19)[1];
    if (v22)
    {
      double v23 = *(double *)(v22 + 32);
      if (v23 != 10000000.0)
      {
        uint64_t v24 = *((void *)this + 1);
        if (!v24) {
          TNativeParagraphStyle::CreateSpacePack(this);
        }
        *(double *)(v24 + 32)  = v23;
      }
    }
    if (*((unsigned char *)a2 + 8))
    {
      uint64_t v25 = TParagraphStyle::GetNative(*a2, v19)[1];
      if (v25)
      {
        double v26 = *(double *)(v25 + 40);
        if (v26 != 0.0)
        {
          uint64_t v27 = *((void *)this + 1);
          if (!v27) {
            TNativeParagraphStyle::CreateSpacePack(this);
          }
          *(double *)(v27 + 40)  = v26;
        }
      }
    }
  }
  ParagraphSpacing  = TParagraphStyle::GetParagraphSpacing(a2, v19);
  if (ParagraphSpacing != 0.0)
  {
    uint64_t v30 = *((void *)this + 1);
    if (!v30) {
      TNativeParagraphStyle::CreateSpacePack(this);
    }
    *(double *)(v30 + 48)  = ParagraphSpacing;
  }
  ParagraphSpacingBefore  = TParagraphStyle::GetParagraphSpacingBefore(a2, v28);
  if (ParagraphSpacingBefore != 0.0)
  {
    uint64_t v32 = *((void *)this + 1);
    if (!v32) {
      TNativeParagraphStyle::CreateSpacePack(this);
    }
    *(double *)(v32 + 56)  = ParagraphSpacingBefore;
  }
}

uint64_t TNativeParagraphStyle::Hash(atomic_ullong *this)
{
  unint64_t v1 = (unint64_t)*((unsigned __int8 *)this + 33) << 24;
  uint64_t v2 = (double *)*this;
  if (*this)
  {
    v1 += (uint64_t)v2[1] << 16;
    uint64_t v3 = (uint64_t)*v2 << 8;
  }
  else
  {
    uint64_t v3 = 0;
  }
  CFArrayRef explicit = (const __CFArray *)atomic_load_explicit(this + 3, memory_order_acquire);
  if (explicit) {
    CFArrayRef explicit = (const __CFArray *)CFArrayGetCount(explicit);
  }
  return (uint64_t)explicit + v3 + v1;
}

BOOL TNativeParagraphStyle::operator==(uint64_t a1, uint64_t a2)
{
  if (*(double *)(a1 + 16) != *(double *)(a2 + 16)
    || *(unsigned __int8 *)(a1 + 32) != *(unsigned __int8 *)(a2 + 32)
    || *(unsigned __int8 *)(a1 + 33) != *(unsigned __int8 *)(a2 + 33)
    || *(unsigned __int8 *)(a1 + 34) != *(unsigned __int8 *)(a2 + 34)
    || *(void *)(a1 + 40) != *(void *)(a2 + 40)
    || *(unsigned __int8 *)(a1 + 48) != *(unsigned __int8 *)(a2 + 48)
    || operator!=((atomic_ullong *)(a1 + 24), (atomic_ullong *)(a2 + 24)))
  {
    return 0;
  }
  BOOL v5 = *(uint64_t **)a1;
  id v6 = *(uint64_t **)a2;
  if (*(void *)a1)
  {
    if (!v6) {
      return 0;
    }
    uint64_t v7 = *v5;
    uint64_t v8 = v5[1];
    uint64_t v9 = *v6;
    uint64_t v10 = v6[1];
    uint64_t v11 = v5[2];
    uint64_t v12 = v6[2];
    BOOL v13 = v7 == v9 && v8 == v10;
    if (!v13 || v11 != v12) {
      return 0;
    }
  }
  else if (v6)
  {
    return 0;
  }
  unint64_t v15 = *(const void **)(a1 + 8);
  unint64_t v16 = *(const void **)(a2 + 8);
  if (v15) {
    return v16 && !memcmp(v15, v16, 0x40uLL);
  }
  return !v16;
}

__CFString *TNativeParagraphStyle::DebugDescription(TNativeParagraphStyle *this)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  int v4 = *((char *)this + 34);
  if (v4 == 1)
  {
    BOOL v5 = @"right to left";
    goto LABEL_7;
  }
  if (!*((unsigned char *)this + 34))
  {
    BOOL v5 = @"left to right";
    goto LABEL_7;
  }
  if (v4 == -1)
  {
    BOOL v5 = @"natural";
LABEL_7:
    CFStringRef v6 = v5;
    goto LABEL_9;
  }
  CFStringRef v6 = CFStringCreateWithFormat(v2, 0, @"%d", *((char *)this + 34));
LABEL_9:
  uint64_t v7 = (__CFString *)v6;
  switch(*((unsigned char *)this + 33))
  {
    case 0:
      uint64_t v8 = @"left";
      goto LABEL_16;
    case 1:
      uint64_t v8 = @"right";
      goto LABEL_16;
    case 2:
      uint64_t v8 = @"center";
      goto LABEL_16;
    case 3:
      uint64_t v8 = @"justified";
      goto LABEL_16;
    case 4:
      uint64_t v8 = @"natural";
LABEL_16:
      CFStringRef v9 = v8;
      break;
    default:
      CFStringRef v9 = CFStringCreateWithFormat(v2, 0, @"%d", *((unsigned __int8 *)this + 33));
      break;
  }
  uint64_t v10 = (__CFString *)v9;
  switch(*((unsigned char *)this + 32))
  {
    case 0:
      uint64_t v11 = @"word wrapping";
      goto LABEL_25;
    case 1:
      uint64_t v11 = @"char wrapping";
      goto LABEL_25;
    case 2:
      uint64_t v11 = @"clipping";
      goto LABEL_25;
    case 3:
      uint64_t v11 = @"truncating head";
      goto LABEL_25;
    case 4:
      uint64_t v11 = @"truncating tail";
      goto LABEL_25;
    case 5:
      uint64_t v11 = @"truncating middle";
LABEL_25:
      CFStringRef v12 = v11;
      break;
    default:
      CFStringRef v12 = CFStringCreateWithFormat(v2, 0, @"%d", *((unsigned __int8 *)this + 32));
      break;
  }
  BOOL v13 = (__CFString *)v12;
  CFStringAppendFormat(Mutable, 0, @"base writing direction  = %@, alignment  = %@, line break mode  = %@, default tab interval  = %g\n", v7, v10, v12, *((void *)this + 2));

  uint64_t v14 = *(uint64_t **)this;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  if (*(void *)this)
  {
    uint64_t v17 = *v14;
    uint64_t v16 = v14[1];
    uint64_t v18 = v14[2];
  }
  CFStringAppendFormat(Mutable, 0, @"first line head indent  = %g, head indent  = %g, tail indent  = %g\n", v17, v16, v18);
  unint64_t v19 = (uint64_t *)*((void *)this + 1);
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  if (v19)
  {
    uint64_t v20 = *v19;
    uint64_t v15 = v19[1];
    uint64_t v21 = v19[2];
  }
  CFStringAppendFormat(Mutable, 0, @"line height multiple  = %g, maximum line height  = %g, minimum line height  = %g\n", v20, v15, v21);
  uint64_t v22 = (void *)*((void *)this + 1);
  if (v22)
  {
    uint64_t v23 = v22[3];
    uint64_t v24 = v22[6];
    uint64_t v25 = v22[7];
  }
  else
  {
    uint64_t v24 = 0;
    uint64_t v23 = 0;
    uint64_t v25 = 0;
  }
  CFStringAppendFormat(Mutable, 0, @"line spacing adjustment  = %g, paragraph spacing  = %g, paragraph spacing before  = %g\n", v23, v24, v25);
  uint64_t v26 = *((void *)this + 1);
  uint64_t v27 = (void *)(v26 + 32);
  if (!v26) {
    uint64_t v27 = &TParagraphStyle::kLargeNumber;
  }
  if (*(double *)v27 != 10000000.0)
  {
    CFStringAppendFormat(Mutable, 0, @"maximum line spacing  = %g\n", *v27);
    uint64_t v26 = *((void *)this + 1);
  }
  if (v26 && *(double *)(v26 + 40) != 0.0) {
    CFStringAppendFormat(Mutable, 0, @"minimum line spacing  = %g\n", *(void *)(v26 + 40));
  }
  CFArrayRef explicit = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)this + 3, memory_order_acquire);
  if (explicit)
  {
    id v29 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
    CFIndex Count = CFArrayGetCount(explicit);
    if (Count)
    {
      CFIndex v31 = Count;
      for (CFIndex i = 0; i != v31; ++i)
      {
        CFStringRef ValueAtIndex = (TNativeTextTab **)CFArrayGetValueAtIndex(explicit, i);
        unint64_t v34 = (void *)MEMORY[0x185327A40]();
        CFTypeID v35 = CFGetTypeID(ValueAtIndex);
        if (TCFBase<TNativeTextTab>::GetTypeID(void)::once != -1) {
          dispatch_once_f(&TCFBase<TNativeTextTab>::GetTypeID(void)::once, 0, (dispatch_function_t)TCFBase<TNativeTextTab>::GetTypeID(void)::{lambda(void *)#1}::__invoke);
        }
        if (v35 == TCFBase<TNativeTextTab>::fTypeID)
        {
          CFStringRef v36 = TNativeTextTab::DebugDescription(ValueAtIndex[5]);
          CFTypeRef v37 = (id)CFMakeCollectable(v36);
        }
        else
        {
          CFTypeRef v37 = (CFTypeRef)[ValueAtIndex description];
        }
        [v29 addObject:v37];
      }
    }
    CFStringAppendFormat(Mutable, 0, @"tabs  = %@", v29);
  }
  BOOL v38 = @"none";
  switch(*((unsigned char *)this + 48))
  {
    case 0:
      return Mutable;
    case 2:
      BOOL v38 = @"Japanese";
      goto LABEL_54;
    case 3:
      BOOL v38 = @"Simplified Chinese";
      goto LABEL_54;
    case 4:
      BOOL v38 = @"Traditional Chinese";
      goto LABEL_54;
    default:
LABEL_54:
      CFStringAppendFormat(Mutable, 0, @"composition language  = %@", v38);
      return Mutable;
  }
}

void TNativeParagraphStyle::CreateIndentPack(TNativeParagraphStyle *this)
{
}

double TParagraphStyle::GetHeadIndent(TParagraphStyle **this, const void *a2)
{
  int v2 = *((unsigned __int8 *)this + 8);
  uint64_t v3 = *this;
  if (v2)
  {
    Native  = TParagraphStyle::GetNative(v3, a2);
    if (*Native) {
      return *(double *)(*Native + 8);
    }
    else {
      return 0.0;
    }
  }
  else
  {
    [(TParagraphStyle *)v3 headIndent];
  }
  return result;
}

id TParagraphStyle::GetTabStops(TParagraphStyle **this, const void *a2)
{
  int v2 = *((unsigned __int8 *)this + 8);
  uint64_t v3 = *this;
  if (v2) {
    return (id)atomic_load_explicit(TParagraphStyle::GetNative(v3, a2) + 3, memory_order_acquire);
  }

  return [(TParagraphStyle *)v3 tabStops];
}

uint64_t *TParagraphStyle::GetDefaultTabInterval(TParagraphStyle **this, const void *a2)
{
  int v2 = *((unsigned __int8 *)this + 8);
  uint64_t v3 = *this;
  if (v2) {
    return TParagraphStyle::GetNative(v3, a2);
  }

  return (uint64_t *)[(TParagraphStyle *)v3 defaultTabInterval];
}

TNativeParagraphStyle **TParagraphStyle::SetFirstLineHeadIndent(TNativeParagraphStyle ***this, double a2)
{
  int v2 = *((unsigned __int8 *)this + 8);
  double result = *this;
  if (v2)
  {
    int v4 = *(double **)result[5];
    if (!v4) {
      TNativeParagraphStyle::CreateIndentPack(result[5]);
    }
    *int v4 = a2;
  }
  else
  {
    return (TNativeParagraphStyle **)objc_msgSend(result, sel_setFirstLineHeadIndent_);
  }
  return result;
}

TNativeParagraphStyle **TParagraphStyle::SetHeadIndent(TNativeParagraphStyle ***this, double a2)
{
  int v2 = *((unsigned __int8 *)this + 8);
  double result = *this;
  if (v2)
  {
    uint64_t v4 = *(void *)result[5];
    if (!v4) {
      TNativeParagraphStyle::CreateIndentPack(result[5]);
    }
    *(double *)(v4 + 8)  = a2;
  }
  else
  {
    return (TNativeParagraphStyle **)objc_msgSend(result, sel_setHeadIndent_);
  }
  return result;
}

TNativeParagraphStyle **TParagraphStyle::SetTailIndent(TNativeParagraphStyle ***this, double a2)
{
  int v2 = *((unsigned __int8 *)this + 8);
  double result = *this;
  if (v2)
  {
    uint64_t v4 = *(void *)result[5];
    if (!v4) {
      TNativeParagraphStyle::CreateIndentPack(result[5]);
    }
    *(double *)(v4 + 16)  = a2;
  }
  else
  {
    return (TNativeParagraphStyle **)objc_msgSend(result, sel_setTailIndent_);
  }
  return result;
}

void *TParagraphStyle::SetLineBreakMode(TParagraphStyle *this, uint64_t a2)
{
  int v2 = *((unsigned __int8 *)this + 8);
  double result = *(void **)this;
  if (!v2) {
    return objc_msgSend(result, sel_setLineBreakMode_, a2);
  }
  *(unsigned char *)(result[5] + 32)  = a2;
  return result;
}

TNativeParagraphStyle **TParagraphStyle::SetLineHeightMultiple(TNativeParagraphStyle ***this, double a2)
{
  int v2 = *((unsigned __int8 *)this + 8);
  double result = *this;
  if (v2)
  {
    uint64_t v4 = (double *)*((void *)result[5] + 1);
    if (!v4) {
      TNativeParagraphStyle::CreateSpacePack(result[5]);
    }
    *uint64_t v4 = a2;
  }
  else
  {
    return (TNativeParagraphStyle **)objc_msgSend(result, sel_setLineHeightMultiple_);
  }
  return result;
}

TNativeParagraphStyle **TParagraphStyle::SetMaximumLineHeight(TNativeParagraphStyle ***this, double a2)
{
  int v2 = *((unsigned __int8 *)this + 8);
  double result = *this;
  if (v2)
  {
    uint64_t v4 = *((void *)result[5] + 1);
    if (!v4) {
      TNativeParagraphStyle::CreateSpacePack(result[5]);
    }
    *(double *)(v4 + 8)  = a2;
  }
  else
  {
    return (TNativeParagraphStyle **)objc_msgSend(result, sel_setMaximumLineHeight_);
  }
  return result;
}

TNativeParagraphStyle **TParagraphStyle::SetMinimumLineHeight(TNativeParagraphStyle ***this, double a2)
{
  int v2 = *((unsigned __int8 *)this + 8);
  double result = *this;
  if (v2)
  {
    uint64_t v4 = *((void *)result[5] + 1);
    if (!v4) {
      TNativeParagraphStyle::CreateSpacePack(result[5]);
    }
    *(double *)(v4 + 16)  = a2;
  }
  else
  {
    return (TNativeParagraphStyle **)objc_msgSend(result, sel_setMinimumLineHeight_);
  }
  return result;
}

TNativeParagraphStyle **TParagraphStyle::SetLineSpacingAdjustment(TNativeParagraphStyle ***this, double a2)
{
  int v2 = *((unsigned __int8 *)this + 8);
  double result = *this;
  if (v2)
  {
    uint64_t v4 = *((void *)result[5] + 1);
    if (!v4) {
      TNativeParagraphStyle::CreateSpacePack(result[5]);
    }
    *(double *)(v4 + 24)  = a2;
  }
  else
  {
    return (TNativeParagraphStyle **)objc_msgSend(result, sel_setLineSpacing_);
  }
  return result;
}

TNativeParagraphStyle **TParagraphStyle::SetParagraphSpacing(TNativeParagraphStyle ***this, double a2)
{
  int v2 = *((unsigned __int8 *)this + 8);
  double result = *this;
  if (v2)
  {
    uint64_t v4 = *((void *)result[5] + 1);
    if (!v4) {
      TNativeParagraphStyle::CreateSpacePack(result[5]);
    }
    *(double *)(v4 + 48)  = a2;
  }
  else
  {
    return (TNativeParagraphStyle **)objc_msgSend(result, sel_setParagraphSpacing_);
  }
  return result;
}

TNativeParagraphStyle **TParagraphStyle::SetParagraphSpacingBefore(TNativeParagraphStyle ***this, double a2)
{
  int v2 = *((unsigned __int8 *)this + 8);
  double result = *this;
  if (v2)
  {
    uint64_t v4 = *((void *)result[5] + 1);
    if (!v4) {
      TNativeParagraphStyle::CreateSpacePack(result[5]);
    }
    *(double *)(v4 + 56)  = a2;
  }
  else
  {
    return (TNativeParagraphStyle **)objc_msgSend(result, sel_setParagraphSpacingBefore_);
  }
  return result;
}

uint64_t TParagraphStyle::SetCompositionLanguage(uint64_t a1, uint64_t a2)
{
  int v4 = *(unsigned __int8 *)(a1 + 8);
  uint64_t result = *(void *)a1;
  if (v4)
  {
    *(unsigned char *)(*(void *)(result + 40) + 48)  = a2;
  }
  else
  {
    uint64_t result = objc_opt_respondsToSelector();
    if (result)
    {
      CFStringRef v6 = *(void **)a1;
      return (uint64_t)objc_msgSend(v6, sel_setCompositionLanguage_, a2);
    }
  }
  return result;
}

BOOL IsProhibitedSequence(int a1, int a2, BOOL *a3)
{
  if (a1 > 3336)
  {
    if (a1 <= 70143)
    {
      if (a1 <= 3466)
      {
        if (a1 <= 3345)
        {
          if (a1 != 3337) {
            return a1 == 3342 && a2 == 3398;
          }
          return a2 == 3415;
        }
        if (a1 == 3346)
        {
          BOOL v7 = a2 == 3390;
          int v8 = 3415;
          return v7 || a2 == v8;
        }
        if (a1 != 3461) {
          return 0;
        }
        unsigned int v9 = a2 - 3535;
        return v9 < 3;
      }
      if (a1 <= 69636)
      {
        switch(a1)
        {
          case 3467:
          case 3471:
          case 3476:
            return a2 == 3551;
          case 3469:
            return a2 == 3544;
          case 3473:
            char v4 = a2 + 54;
            if ((a2 - 3530) >= 0x15) {
              return 0;
            }
            unsigned int v5 = 1933313;
            break;
          default:
            return 0;
        }
        return (v5 >> v4) & 1;
      }
      switch(a1)
      {
        case 69637:
          int v6 = 69688;
          break;
        case 69643:
          int v6 = 69694;
          break;
        case 69647:
          int v6 = 69698;
          break;
        default:
          return 0;
      }
    }
    else if (a1 <= 70794)
    {
      if (a1 > 70207)
      {
        switch(a1)
        {
          case 70208:
            int v6 = 70190;
            break;
          case 70320:
            char v4 = a2 + 32;
            if ((a2 - 70368) >= 9) {
              return 0;
            }
            unsigned int v5 = 481;
            return (v5 >> v4) & 1;
          case 70785:
            int v6 = 70832;
            break;
          default:
            return 0;
        }
      }
      else
      {
        if (a1 == 70144)
        {
          char v4 = a2 - 44;
          if ((a2 - 70188) >= 8) {
            return 0;
          }
          unsigned int v5 = 161;
          return (v5 >> v4) & 1;
        }
        if (a1 != 70150) {
          return a1 == 70188 && (a2 & 0xFFFFFFFE) == 0x11230;
        }
        int v6 = 70188;
      }
    }
    else if (a1 <= 71167)
    {
      if (a1 != 70795 && a1 != 70797)
      {
        if (a1 != 70826) {
          return 0;
        }
        unsigned int v3 = a2 - 70837;
        return v3 < 2;
      }
      int v6 = 70842;
    }
    else
    {
      if (a1 <= 71295)
      {
        if (a1 != 71168 && a1 != 71169) {
          return 0;
        }
        unsigned int v3 = a2 - 71225;
        return v3 < 2;
      }
      if (a1 == 71296)
      {
        char v4 = a2 + 83;
        if ((a2 - 71341) >= 9) {
          return 0;
        }
        unsigned int v5 = 385;
        return (v5 >> v4) & 1;
      }
      if (a1 != 71302) {
        return 0;
      }
      int v6 = 71346;
    }
    return a2 == v6;
  }
  if (a1 <= 2756)
  {
    if (a1 > 2442)
    {
      if (a1 > 2673)
      {
        switch(a1)
        {
          case 2674:
            char v4 = a2 - 63;
            if ((a2 - 2623) >= 9) {
              return 0;
            }
            unsigned int v5 = 259;
            break;
          case 2675:
            char v4 = a2 - 65;
            if ((a2 - 2625) >= 0xB) {
              return 0;
            }
            unsigned int v5 = 1027;
            break;
          case 2693:
            char v4 = a2 + 66;
            if ((a2 - 2750) >= 0xF) {
              return 0;
            }
            unsigned int v5 = 28289;
            break;
          default:
            return 0;
        }
      }
      else
      {
        if (a1 == 2443) {
          return a2 == 2499;
        }
        if (a1 == 2444) {
          return a2 == 2530;
        }
        if (a1 != 2565) {
          return 0;
        }
        char v4 = a2 - 62;
        if ((a2 - 2622) >= 0xF) {
          return 0;
        }
        unsigned int v5 = 17409;
      }
      return (v5 >> v4) & 1;
    }
    if (a1 <= 2318)
    {
      if (a1 == 2309)
      {
        char v4 = a2 - 58;
        if ((a2 - 2362) >= 0x1E) {
          return 0;
        }
        unsigned int v5 = 807899155;
      }
      else
      {
        if (a1 != 2310) {
          return a1 == 2313 && a2 == 2369;
        }
        char v4 = a2 - 58;
        if ((a2 - 2362) >= 0xF) {
          return 0;
        }
        unsigned int v5 = 30721;
      }
      return (v5 >> v4) & 1;
    }
    if (a1 != 2319)
    {
      if (a1 == 2352)
      {
        if (a2 == 2381 && a3)
        {
          BOOL result = 0;
          *a3  = 1;
          return result;
        }
        return 0;
      }
      return a1 == 2437 && a2 == 2494;
    }
    unsigned int v9 = a2 - 2373;
    return v9 < 3;
  }
  if (a1 > 3134)
  {
    if (a1 <= 3208) {
      return (a1 == 3135 || a1 == 3142 || a1 == 3146) && a2 == 3157;
    }
    if (a1 <= 3217) {
      return (a1 == 3209 || a1 == 3211) && a2 == 3262;
    }
    if (a1 == 3218) {
      return a2 == 3276;
    }
    if (a1 != 3335) {
      return 0;
    }
    return a2 == 3415;
  }
  if (a1 <= 2834)
  {
    if (a1 == 2757) {
      return a2 == 2750;
    }
    if (a1 == 2821) {
      return a2 == 2878;
    }
    if (a1 != 2831) {
      return 0;
    }
    return a2 == 2903;
  }
  if (a1 == 2835) {
    return a2 == 2903;
  }
  if (a1 == 2949) {
    return a2 == 3010;
  }
  if (a1 != 3090) {
    return 0;
  }
  BOOL v7 = a2 == 3148;
  int v8 = 3157;
  return v7 || a2 == v8;
}

id TTextTab::SetTabRef(TTextTab *this, void *cf)
{
  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 == CTTextTabGetTypeID())
  {
    uint64_t v5 = *((void *)cf + 5);
    *(void *)this  = *(void *)v5;
    *((unsigned char *)this + 8)  = *(unsigned char *)(v5 + 8);
    id result = *(id *)(v5 + 16);
  }
  else
  {
    objc_msgSend(cf, sel_location);
    *(void *)this  = v7;
    unsigned int v8 = objc_msgSend(cf, sel_alignment);
    if ((dyld_program_sdk_at_least() & (v8 < 5)) != 0) {
      char v9 = 0x403010200uLL >> (8 * v8);
    }
    else {
      char v9 = v8;
    }
    *((unsigned char *)this + 8)  = v9;
    id result = objc_msgSend(cf, sel_options);
  }
  *((void *)this + 2)  = result;
  return result;
}

void std::vector<unsigned short>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 1;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8)  = *(void *)a1 + 2 * a2;
    }
  }
  else
  {
    std::vector<unsigned short>::__append((char **)a1, a2 - v2);
  }
}

void std::vector<unsigned short>::__append(char **a1, unint64_t a2)
{
  int v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 1)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 2 * a2);
      v7 += 2 * a2;
    }
    a1[1]  = v7;
  }
  else
  {
    unsigned int v8 = *a1;
    uint64_t v9 = v7 - *a1;
    uint64_t v10 = a2 + (v9 >> 1);
    if (v10 < 0) {
      abort();
    }
    uint64_t v11 = v9 >> 1;
    unint64_t v12 = v5 - v8;
    if (v12 > v10) {
      uint64_t v10 = v12;
    }
    if (v12 >= 0x7FFFFFFFFFFFFFFELL) {
      uint64_t v13 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v13 = v10;
    }
    if (v13)
    {
      uint64_t v14 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned short>>(v4, v13);
      unsigned int v8 = *a1;
      uint64_t v7 = a1[1];
    }
    else
    {
      uint64_t v14 = 0;
    }
    uint64_t v15 = &v14[2 * v11];
    uint64_t v16 = &v14[2 * v13];
    bzero(v15, 2 * a2);
    uint64_t v17 = &v15[2 * a2];
    while (v7 != v8)
    {
      __int16 v18 = *((_WORD *)v7 - 1);
      v7 -= 2;
      *((_WORD *)v15 - 1)  = v18;
      v15 -= 2;
    }
    *a1  = v15;
    a1[1]  = v17;
    a1[2]  = v16;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

void *std::__function::__func<ForEachVisibleFormatter(std::function<void ()(unsigned int)>)::$_0,std::allocator<ForEachVisibleFormatter(std::function<void ()(unsigned int)>)::$_0>,void ()(unsigned int,unsigned int)>::~__func(void *a1)
{
  *a1  = &unk_1ED05FE88;
  std::__function::__value_func<void ()>::~__value_func[abi:nn180100](a1 + 1);
  return a1;
}

void std::__function::__func<ForEachVisibleFormatter(std::function<void ()(unsigned int)>)::$_0,std::allocator<ForEachVisibleFormatter(std::function<void ()(unsigned int)>)::$_0>,void ()(unsigned int,unsigned int)>::~__func(void *a1)
{
  *a1  = &unk_1ED05FE88;
  std::__function::__value_func<void ()>::~__value_func[abi:nn180100](a1 + 1);

  JUMPOUT(0x1853275C0);
}

uint64_t std::__function::__func<ForEachVisibleFormatter(std::function<void ()(unsigned int)>)::$_0,std::allocator<ForEachVisibleFormatter(std::function<void ()(unsigned int)>)::$_0>,void ()(unsigned int,unsigned int)>::__clone(uint64_t a1, void *a2)
{
  *a2  = &unk_1ED05FE88;
  return std::__function::__value_func<void ()>::__value_func[abi:nn180100]((uint64_t)(a2 + 1), a1 + 8);
}

void *std::__function::__func<ForEachVisibleFormatter(std::function<void ()(unsigned int)>)::$_0,std::allocator<ForEachVisibleFormatter(std::function<void ()(unsigned int)>)::$_0>,void ()(unsigned int,unsigned int)>::destroy(uint64_t a1)
{
  return std::__function::__value_func<void ()>::~__value_func[abi:nn180100]((void *)(a1 + 8));
}

void std::__function::__func<IterateItemRanges(USet const*,UErrorCode *,std::function<void ()(unsigned int,unsigned int)>)::$_0,std::allocator<IterateItemRanges(USet const*,UErrorCode *,std::function<void ()(unsigned int,unsigned int)>)::$_0>,void ()(__CFString const*)>::~__func()
{
}

void *std::__function::__func<IterateItemRanges(USet const*,UErrorCode *,std::function<void ()(unsigned int,unsigned int)>)::$_0,std::allocator<IterateItemRanges(USet const*,UErrorCode *,std::function<void ()(unsigned int,unsigned int)>)::$_0>,void ()(__CFString const*)>::__clone()
{
  id result = operator new(0x10uLL);
  *id result = &unk_1ED05FD20;
  return result;
}

void std::__function::__func<IterateItemRanges(USet const*,UErrorCode *,std::function<void ()(unsigned int,unsigned int)>)::$_0,std::allocator<IterateItemRanges(USet const*,UErrorCode *,std::function<void ()(unsigned int,unsigned int)>)::$_0>,void ()(__CFString const*)>::__clone(uint64_t a1, void *a2)
{
  *a2  = &unk_1ED05FD20;
}

BOOL TNativeTextTab::operator==(uint64_t a1, uint64_t a2)
{
  if (*(double *)a1 != *(double *)a2 || *(unsigned __int8 *)(a1 + 8) != *(unsigned __int8 *)(a2 + 8)) {
    return 0;
  }
  unint64_t v2 = *(const void **)(a1 + 16);
  unsigned int v3 = *(const void **)(a2 + 16);
  if (v2 == v3) {
    return 1;
  }
  BOOL result = 0;
  if (v2)
  {
    if (v3) {
      return CFEqual(v2, v3) != 0;
    }
  }
  return result;
}

CFStringRef TNativeTextTab::DebugDescription(TNativeTextTab *this)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v3 = *(void *)this;
  unint64_t v4 = *((char *)this + 8);
  if (v4 >= 5)
  {
    CFDictionaryRef v6 = (const __CFDictionary *)*((void *)this + 2);
    uint64_t v5 = "?";
    if (v6 && CFDictionaryGetValue(v6, @"NSTabColumnTerminatorsAttributeName")) {
      uint64_t v5 = "D";
    }
  }
  else
  {
    uint64_t v5 = off_1E528F660[v4];
  }
  CFStringRef v7 = CFStringCreateWithFormat(v2, 0, @"%g%s", v3, v5);
  if (v7)
  {
    CFDictionaryRef v8 = (const __CFDictionary *)*((void *)this + 2);
    if (v8)
    {
      if (CFDictionaryGetCount(v8))
      {
        CFStringRef v9 = CFStringCreateWithFormat(v2, 0, @"%@%@", v7, *((void *)this + 2));
        if (v9)
        {
          CFStringRef v10 = v9;
          CFRelease(v7);
          return v10;
        }
      }
    }
  }
  return v7;
}

void TTabEngine::ApplyTabs(TLine **this@<X0>, double a2@<D0>, double a3@<D1>, const void *a4@<X1>, uint64_t a5@<X8>)
{
  uint64_t v6 = *((void *)*this + 2);
  if (*((void *)*this + 3) - v6 <= 7
    || !TAttributes::GetTabStopsPresent((TAttributes *)(*(void *)(*(void *)v6 + 40) + 40), a4))
  {
    *(unsigned char *)a5  = 0;
    *(unsigned char *)(a5 + 16)  = 0;
    return;
  }
  CFStringRef v10 = *this;
  __int16 v11 = *((_WORD *)*this + 76);
  if ((v11 & 8) != 0) {
    uint64_t v12 = ((uint64_t)(*((void *)*this + 3) - *((void *)*this + 2)) >> 3) - 1;
  }
  else {
    uint64_t v12 = 0;
  }
  if ((v11 & 8) != 0) {
    uint64_t v13 = -1;
  }
  else {
    uint64_t v13 = (uint64_t)(*((void *)*this + 3) - *((void *)*this + 2)) >> 3;
  }
  if ((v11 & 8) != 0) {
    int v14 = -1;
  }
  else {
    int v14 = 1;
  }
  *(void *)a5  = 0xAAAAAAAAAAAAAA00;
  *(void *)(a5 + 8)  = -1;
  *(void *)(a5 + 16)  = 0xAAAAAAAAAAAAAA00;
  if (v12 == v13) {
    goto LABEL_62;
  }
  uint64_t v40 = a5;
  double v15 = a2 + a3;
  uint64_t v16 = (double *)MEMORY[0x1E4F1DB30];
  uint64_t v41 = v13;
  while (1)
  {
    uint64_t v17 = *(void *)(*(void *)(*((void *)v10 + 2) + 8 * v12) + 40);
    if ((v11 & 8) == 0)
    {
      __int16 v18 = *(double **)(v17 + 312);
      if (!v18) {
        __int16 v18 = v16;
      }
      a2  = a2 + *v18;
    }
    if ((*(unsigned char *)(v17 + 225) & 1) == 0) {
      goto LABEL_53;
    }
    TLine::DetachRun(v10, v12);
    theDict  = (CFDictionaryRef)0xAAAAAAAAAAAAAAAALL;
    long long v43 = xmmword_184BA5FA8;
    CFStringRef v10 = *this;
    unint64_t v19 = *(void **)(*(void *)(*((void *)*this + 2) + 8 * v12) + 48);
    uint64_t v20 = (v11 & 8) != 0 ? -1 : v19[26];
    uint64_t v21 = (v11 & 8) != 0 ? v19[26] - 1 : 0;
    double v42 = 0.0;
    TabGlyph  = TStorageRange::FindTabGlyph((TStorageRange *)(v19 + 24), v21, v14, &v42);
    if (TabGlyph != v20) {
      break;
    }
LABEL_52:
    uint64_t v17 = *(void *)(*(void *)(*((void *)v10 + 2) + 8 * v12) + 40);
    uint64_t v16 = (double *)MEMORY[0x1E4F1DB30];
LABEL_53:
    double v36 = *(double *)(v17 + 192);
    CFTypeRef v37 = *(double **)(v17 + 312);
    if (!v37) {
      CFTypeRef v37 = v16;
    }
    double v38 = *v37;
    double v39 = a2 + v36 + *v37;
    v12 += v14;
    if ((v11 & 8) == 0) {
      double v38 = -0.0;
    }
    a2  = v38 + v39;
    if (v12 == v13) {
      goto LABEL_62;
    }
  }
  uint64_t v23 = TabGlyph;
  double v24 = a2;
  while (1)
  {
    double v25 = v24 + v42;
    if ((TAttributes::GetTabStopForLocation((TAttributes *)(v19 + 5), v25, (TTextTab *)&v43) & 1) == 0) {
      break;
    }
    double v26 = *(double *)&v43 - v25;
    if (theDict
      && (CFCharacterSetRef Value = (const __CFCharacterSet *)CFDictionaryGetValue(theDict, @"NSTabColumnTerminatorsAttributeName")) != 0)
    {
      TTabEngine::CalculateCylinderWidth((uint64_t)this, v12, v14, v23, v26, Value);
LABEL_39:
      double v26 = v26 - v28;
    }
    else if ((v11 & 8) != 0)
    {
      switch(BYTE8(v43))
      {
        case 0:
LABEL_34:
          TTabEngine::CalculateCylinderWidth((uint64_t)this, v12, v14, v23, v26, 0);
          BOOL v29 = v28 < v26 || (v11 & 8) == 0;
          uint64_t v13 = v41;
          if (!v29) {
            double v28 = 0.0;
          }
          goto LABEL_39;
        case 1:
        case 3:
        case 4:
          break;
        case 2:
LABEL_47:
          double v34 = v15 - *(double *)&v43;
          if (v26 <= v15 - *(double *)&v43) {
            double v34 = v26;
          }
          TTabEngine::CalculateCylinderWidth((uint64_t)this, v12, v14, v23, v34 + v34, 0);
          if (v35 == v26) {
            double v26 = 0.0;
          }
          else {
            double v26 = v26 + v35 * -0.5;
          }
          break;
        default:
LABEL_46:
          double v26 = 0.0;
          break;
      }
    }
    else
    {
      switch(BYTE8(v43))
      {
        case 0:
        case 3:
        case 4:
          break;
        case 1:
          goto LABEL_34;
        case 2:
          goto LABEL_47;
        default:
          goto LABEL_46;
      }
    }
    uint64_t v30 = v19[27];
    uint64_t v31 = *(void *)(v30 + 32);
    if (v31 || (uint64_t v32 = 0, !*(void *)(v30 + 24))) {
      uint64_t v32 = *(void *)(v31 + 16 * v19[25] + 16 * v23 + 8);
    }
    double v33 = v26;
    TStorageRange::SetAdvance((TStorageRange *)(v19 + 24), v23, *(CGSize *)(&v32 - 1));
    double v24 = v25 + v26;
    if (v24 > v15) {
      goto LABEL_61;
    }
    double v42 = 0.0;
    uint64_t v23 = TStorageRange::FindTabGlyph((TStorageRange *)(v19 + 24), v23 + v14, v14, &v42);
    if (v23 == v20)
    {
      CFStringRef v10 = *this;
      goto LABEL_52;
    }
  }
  *(void *)uint64_t v40 = *(void *)(*(void *)(v19[27] + 48) + 8 * v19[25] + 8 * v23);
  *(double *)(v40 + 8)  = v25;
  *(unsigned char *)(v40 + 16)  = 1;
LABEL_61:
  CFStringRef v10 = *this;
LABEL_62:

  TLine::SyncWithRuns(v10);
}

uint64_t TTabEngine::CalculateCylinderWidth(uint64_t this, uint64_t a2, int a3, uint64_t a4, double a5, const __CFCharacterSet *a6)
{
  double v33 = (void *)this;
  uint64_t v7 = (uint64_t)(*(void *)(*(void *)this + 24) - *(void *)(*(void *)this + 16)) >> 3;
  if (a3 < 0) {
    uint64_t v7 = -1;
  }
  double v8 = 0.0;
  uint64_t v29 = v7;
  if (v7 != a2)
  {
    uint64_t v10 = a2;
    uint64_t v11 = a3 + a4;
    uint64_t v34 = 16 * a3;
    uint64_t v12 = 8 * a3;
    while (1)
    {
      uint64_t v13 = *(void **)(*(void *)(*(void *)(*v33 + 16) + 8 * v10) + 40);
      int v14 = (void *)v13[27];
      uint64_t v15 = v13[26] - 1;
      if (a3 < 0)
      {
        uint64_t v16 = -1;
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = v13[26];
      }
      if (v10 != a2) {
        uint64_t v11 = v15;
      }
      uint64_t v17 = v14[4];
      if (v17 || (uint64_t v20 = v14[3]) == 0)
      {
        int v32 = 0;
        uint64_t v18 = v13[25];
        uint64_t v19 = v17 + 16 * v18;
      }
      else
      {
        uint64_t v18 = v13[25];
        uint64_t v19 = v20 + 8 * v18;
        int v32 = 1;
      }
      if (v11 != v16) {
        break;
      }
LABEL_27:
      v10 += a3;
      if (v10 == v29) {
        return this;
      }
    }
    uint64_t v21 = v14[5];
    uint64_t v22 = v19 + 16 * v11;
    uint64_t v23 = v19 + 8 * v11;
    while (1)
    {
      int v24 = *(_DWORD *)(v21 + 4 * v18 + 4 * v11);
      if ((v24 & 4) != 0) {
        break;
      }
      if (a6)
      {
        uint64_t v25 = v33[1];
        uint64_t v48 = *(void *)(v14[6] + 8 * v18 + 8 * v11);
        long long v36 = 0u;
        long long v37 = 0u;
        long long v38 = 0u;
        long long v39 = 0u;
        long long v40 = 0u;
        long long v41 = 0u;
        long long v42 = 0u;
        long long v43 = 0u;
        long long v44 = 0u;
        long long v45 = 0u;
        uint64_t v47 = 0;
        long long v46 = 0u;
        uint64_t v26 = *(void *)(v25 + 16);
        uint64_t v35 = v25;
        *(void *)&long long v46 = v26;
        UTF32Char FullChar = TCharStreamIterator::GetFullChar((TCharStreamIterator *)&v35, &v48, 0);
        this  = CFCharacterSetIsLongCharacterMember(a6, FullChar);
        if (this) {
          return this;
        }
        int v14 = (void *)v13[27];
        uint64_t v18 = v13[25];
        uint64_t v21 = v14[5];
        int v24 = *(_DWORD *)(v21 + 4 * v18 + 4 * v11);
      }
      if ((v24 & 2) == 0)
      {
        double v28 = (double *)(v32 ? v23 : v22);
        double v8 = v8 + *v28;
        if (v8 >= a5) {
          break;
        }
      }
      v11 += a3;
      v22 += v34;
      v23 += v12;
      if (v16 == v11)
      {
        uint64_t v11 = v16;
        goto LABEL_27;
      }
    }
  }
  return this;
}

atomic_ullong *ColorPaletteTable::ColorPaletteTable(atomic_ullong *a1, atomic_ullong *a2)
{
  *a1  = 0;
  a1[1]  = 0;
  a1[2]  = 0;
  if (!atomic_load_explicit(a2, memory_order_acquire)) {
    return a1;
  }
  CFDataRef v4 = (const __CFData *)(id)atomic_load_explicit(a2, memory_order_acquire);
  CFDataRef v5 = v4;
  if (v4) {
    BytePtr  = CFDataGetBytePtr(v4);
  }
  else {
    BytePtr  = 0;
  }

  id v7 = (id)atomic_load_explicit(a2, memory_order_acquire);
  CFDataRef v8 = (const __CFData *)v7;
  if (!v8)
  {

    goto LABEL_12;
  }
  CFDataRef v9 = v8;
  uint64_t v10 = CFDataGetBytePtr(v8);

  if (!v10)
  {
LABEL_12:

    return a1;
  }
  unint64_t v11 = (unint64_t)&v10[CFDataGetLength((CFDataRef)v7)];

  if ((unint64_t)(BytePtr + 12) <= v11)
  {
    atomic_ullong v12 = bswap32(*(unsigned __int16 *)BytePtr) >> 16;
    if (v12 <= 1)
    {
      if (*((_WORD *)BytePtr + 2))
      {
        atomic_ullong v13 = __rev16(*((unsigned __int16 *)BytePtr + 2));

        a1[1]  = v12;
        a1[2]  = v13;
      }
    }
  }
  return a1;
}

const UInt8 *ColorPaletteTable::PaletteTypeArray(ColorPaletteTable *this)
{
  if (!*((void *)this + 1)) {
    return 0;
  }
  CFDataRef v2 = (const __CFData *)(id)atomic_load_explicit((atomic_ullong *volatile)this, memory_order_acquire);
  CFDataRef v3 = v2;
  if (v2) {
    BytePtr  = CFDataGetBytePtr(v2);
  }
  else {
    BytePtr  = 0;
  }

  id v5 = (id)atomic_load_explicit((atomic_ullong *volatile)this, memory_order_acquire);
  CFDataRef v6 = (const __CFData *)v5;
  if (v6)
  {
    CFDataRef v7 = v6;
    CFDataRef v8 = CFDataGetBytePtr(v6);

    if (v8) {
      v8 += CFDataGetLength((CFDataRef)v5);
    }
  }
  else
  {

    CFDataRef v8 = 0;
  }

  BOOL result = 0;
  uint64_t v10 = *((void *)this + 2);
  unint64_t v11 = &BytePtr[2 * v10];
  if (BytePtr <= v11 + 12 && v11 + 16 <= v8)
  {
    unsigned int v12 = *((_DWORD *)v11 + 3);
    if (v12)
    {
      atomic_ullong v13 = &BytePtr[bswap32(v12)];
      unint64_t v14 = (unint64_t)&v13[4 * v10];
      if (v13 + 4 <= v8) {
        unint64_t v15 = (unint64_t)(v8 - v13) >> 2;
      }
      else {
        unint64_t v15 = 0;
      }
      if (v14 <= (unint64_t)v8 && v14 >= (unint64_t)v13 || v15 == v10) {
        return v13;
      }
      else {
        return 0;
      }
    }
    return 0;
  }
  return result;
}

const UInt8 *ColorPaletteTable::IndexOfFirstPaletteWithFlags(const UInt8 **this, int a2, int a3)
{
  BOOL result = ColorPaletteTable::PaletteTypeArray((ColorPaletteTable *)this);
  if (result)
  {
    CFDataRef v7 = this[2];
    if (v7)
    {
      CFDataRef v8 = result;
      BOOL result = 0;
      while ((bswap32(*(_DWORD *)&v8[4 * (void)result]) & a3) != a2)
      {
        if (v7 == ++result) {
          return 0;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

atomic_ullong *ColorPaletteTable::Palette::Palette(atomic_ullong *this, CFDataRef theData, unint64_t a3)
{
  *this  = 0;
  if (theData)
  {
    BytePtr  = CFDataGetBytePtr(theData);
    CFDataRef v7 = CFDataGetBytePtr(theData);
    unint64_t v8 = v7 ? (unint64_t)&v7[CFDataGetLength(theData)] : 0;
    if (*((_WORD *)BytePtr + 2))
    {
      unint64_t v9 = __rev16(*((unsigned __int16 *)BytePtr + 2)) <= a3 ? 0 : a3;
      uint64_t v10 = &BytePtr[2 * v9];
      if (BytePtr <= v10 + 12 && (unint64_t)(v10 + 14) <= v8)
      {
        unint64_t v12 = (unint64_t)&BytePtr[4 * (bswap32(*((unsigned __int16 *)v10 + 6)) >> 16)
                                       + bswap32(*((_DWORD *)BytePtr + 2))];
        atomic_ullong v13 = bswap32(*((unsigned __int16 *)BytePtr + 1)) >> 16;
        unint64_t v14 = v12 + 4 * v13;
        BOOL v15 = (unint64_t)BytePtr <= v12 && v14 >= v12;
        if (v15 && v14 <= v8) {
          goto LABEL_28;
        }
        BOOL v17 = v12 + 4 > v8 || (unint64_t)BytePtr > v12;
        unint64_t v18 = (v8 - v12) >> 2;
        if (v17) {
          unint64_t v18 = 0;
        }
        if (v18 == v13)
        {
LABEL_28:
          TCFRef<__CTFont const*>::Retain(this, theData);
          this[1]  = v12;
          this[2]  = v13;
        }
      }
    }
  }
  return this;
}

atomic_ullong *ColorPaletteTable::Palette::ColorForPaletteEntry@<X0>(atomic_ullong *this@<X0>, unint64_t a2@<X1>, atomic_ullong **a3@<X8>, unint64_t a4@<D0>)
{
  components[4]  = *(CGFloat *)MEMORY[0x1E4F143B8];
  if (atomic_load_explicit(this, memory_order_acquire) && this[2] > a2)
  {
    id v5 = (unsigned char *)(this[1] + 4 * a2);
    LOBYTE(a4)  = v5[2];
    double v6 = (double)a4 / 255.0;
    components[0]  = v6;
    LOBYTE(v6)  = v5[1];
    double v7 = (double)*(unint64_t *)&v6 / 255.0;
    components[1]  = v7;
    LOBYTE(v7)  = *v5;
    double v8 = (double)*(unint64_t *)&v7 / 255.0;
    components[2]  = v8;
    LOBYTE(v8)  = v5[3];
    components[3]  = (double)*(unint64_t *)&v8 / 255.0;
    if (qword_1EB2CE440 != -1) {
      dispatch_once_f(&qword_1EB2CE440, 0, (dispatch_function_t)sRGBColorSpace(void)::$_0::__invoke);
    }
    this  = (atomic_ullong *)CGColorCreate((CGColorSpaceRef)_MergedGlobals_24, components);
    *a3  = this;
  }
  else
  {
    *a3  = 0;
  }
  return this;
}

CGColorSpaceRef sRGBColorSpace(void)::$_0::__invoke()
{
  CGColorSpaceRef result = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
  _MergedGlobals_24  = (uint64_t)result;
  return result;
}

char **PostGSUBFixups::add(char **this, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  unint64_t v9 = this;
  uint64_t v10 = *this;
  unint64_t v11 = (unint64_t)this[1];
  if (*this != (char *)v11
    && *(void *)(v11 - 32) == a2
    && (uint64_t v12 = *(void *)(v11 - 16), *(void *)(v11 - 24) + v12 == a3))
  {
    *(void *)(v11 - 16)  = v12 + a4;
  }
  else
  {
    unint64_t v13 = (unint64_t)this[2];
    if (v11 >= v13)
    {
      uint64_t v15 = (uint64_t)(v11 - (void)v10) >> 5;
      unint64_t v16 = v15 + 1;
      if ((unint64_t)(v15 + 1) >> 59) {
        abort();
      }
      uint64_t v17 = (uint64_t)(this + 3);
      uint64_t v18 = v13 - (void)v10;
      if (v18 >> 4 > v16) {
        unint64_t v16 = v18 >> 4;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFE0) {
        unint64_t v19 = 0x7FFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v16;
      }
      uint64_t v31 = v9 + 3;
      uint64_t v20 = TInlineBufferAllocator<PostGSUBFixups::FixupData,8ul>::allocate(v17, v19);
      uint64_t v21 = &v20[32 * v15];
      *(void *)uint64_t v21 = a2;
      *((void *)v21 + 1)  = a3;
      *((void *)v21 + 2)  = a4;
      *((_DWORD *)v21 + 6)  = a5;
      uint64_t v22 = *v9;
      unint64_t v23 = (unint64_t)v9[1];
      if ((char *)v23 == *v9)
      {
        int64x2_t v26 = vdupq_n_s64(v23);
        int v24 = &v20[32 * v15];
      }
      else
      {
        int v24 = &v20[32 * v15];
        do
        {
          long long v25 = *(_OWORD *)(v23 - 32);
          *(_OWORD *)(v24 - 20)  = *(_OWORD *)(v23 - 20);
          *((_OWORD *)v24 - 2)  = v25;
          v24 -= 32;
          v23 -= 32;
        }
        while ((char *)v23 != v22);
        int64x2_t v26 = *(int64x2_t *)v9;
      }
      unint64_t v14 = v21 + 32;
      const void *v9 = v24;
      v9[1]  = v21 + 32;
      int64x2_t v29 = v26;
      uint64_t v27 = v9[2];
      v9[2]  = &v20[32 * v19];
      uint64_t v30 = v27;
      uint64_t v28 = v26.i64[0];
      this  = (char **)std::__split_buffer<PostGSUBFixups::FixupData,TInlineBufferAllocator<PostGSUBFixups::FixupData,8ul> &>::~__split_buffer((uint64_t)&v28);
    }
    else
    {
      *(void *)unint64_t v11 = a2;
      *(void *)(v11 + 8)  = a3;
      *(void *)(v11 + 16)  = a4;
      unint64_t v14 = (char *)(v11 + 32);
      *(_DWORD *)(v11 + 24)  = a5;
    }
    v9[1]  = v14;
  }
  return this;
}

uint64_t PostGSUBFixups::apply(PostGSUBFixups *this, TRunGlue *a2, int a3, const IndicClassTable *a4, int a5)
{
  if (*(void *)this != *((void *)this + 1))
  {
    double v7 = this;
    uint64_t v109 = (void *)*((void *)a2 + 13);
    uint64_t v8 = TRunGlue::length(a2);
    uint64_t v9 = *(void *)v7;
    uint64_t v115 = *((void *)v7 + 1);
    if (*(void *)v7 != v115)
    {
      uint64_t v10 = v8;
      uint64_t v11 = 0;
      char v111 = 0;
      uint64_t v108 = (uint64_t)v7 + 312;
      uint64_t v12 = -1;
      int v118 = a3;
      uint64_t v113 = v7;
      uint64_t v114 = v8;
      while (1)
      {
        unint64_t v14 = (void *)*((void *)v7 + 36);
        unint64_t v13 = (void *)*((void *)v7 + 37);
        uint64_t v16 = *(void *)v9;
        uint64_t v15 = *(void *)(v9 + 8);
        if (v14 != v13)
        {
          uint64_t v17 = v14 + 2;
          do
          {
            uint64_t v19 = *(v17 - 2);
            uint64_t v18 = v17 - 2;
            uint64_t v20 = *(v17 - 1) + v19;
            if (v19 <= v16 && v20 > v16) {
              v16 += *v17;
            }
            if (v19 <= v15 && v20 > v15) {
              v15 += *v17;
            }
            v17 += 3;
          }
          while (v18 + 3 != v13);
        }
        uint64_t v116 = *(void *)(v9 + 16);
        uint64_t v119 = v9;
        int v23 = *(_DWORD *)(v9 + 24);
        int v24 = v23 & 0x30000000;
        if ((v23 & 0x30000000) == 0) {
          break;
        }
        uint64_t v120 = a2;
        v121.i64[0]  = v15;
        if (!TRunGlue::TGlyph::IsDeleted((TRunGlue::TGlyph *)&v120))
        {
          if ((v23 & 0x10000000) == 0) {
            break;
          }
          uint64_t v120 = a2;
          v121.i64[0]  = v15 + 1;
          if (TRunGlue::TGlyph::IsDeleted((TRunGlue::TGlyph *)&v120)) {
            break;
          }
        }
        uint64_t v25 = v119;
LABEL_197:
        uint64_t v9 = v25 + 32;
        if (v9 == v115) {
          return v111 & 1;
        }
      }
      uint64_t v26 = **((void **)a2 + 13);
      if (v12 > v15 || v12 + v11 <= v15)
      {
        int v28 = *(_DWORD *)(v26 + 16 * v15 + 12);
        if (v15 < 1)
        {
          uint64_t v12 = v15;
          uint64_t v11 = 1;
        }
        else
        {
          uint64_t v11 = v15 + 1;
          int64x2_t v29 = (int *)(v26 + 16 * v15 - 4);
          uint64_t v30 = 1;
          uint64_t v12 = v15;
          while (1)
          {
            int v31 = *v29;
            v29 -= 4;
            if (v31 != v28) {
              break;
            }
            ++v30;
            --v12;
            if (v30 - v15 == 1)
            {
              uint64_t v12 = 0;
              goto LABEL_34;
            }
          }
          uint64_t v11 = v30;
        }
LABEL_34:
        if (v11 + v12 < v10)
        {
          int v32 = (int *)(v26 + 16 * (v11 + v12) + 12);
          while (1)
          {
            int v33 = *v32;
            v32 += 4;
            if (v33 != v28) {
              break;
            }
            ++v11;
            if (v12 + v11 >= v10)
            {
              uint64_t v11 = v10 - v12;
              break;
            }
          }
        }
        *((void *)v7 + 37)  = *((void *)v7 + 36);
      }
      if (v23 < 0)
      {
        if (a3 && (v23 & 0x40000000) != 0 && TRunGlue::GetGlyphID(a2, v16) == a3) {
          ++v16;
        }
        if (v16 < v10)
        {
          while (1)
          {
            uint64_t v120 = a2;
            v121.i64[0]  = v16;
            if (!TRunGlue::TGlyph::IsDeleted((TRunGlue::TGlyph *)&v120))
            {
              if ((TRunGlue::GetGlyphProps(a2, v16) & 0x200) == 0) {
                break;
              }
              StringIndedouble x = TRunGlue::GetStringIndex(a2, v16);
              if (StringIndex != TRunGlue::GetStringIndex(a2, v15)) {
                break;
              }
            }
            if (v10 == ++v16)
            {
              uint64_t v16 = v10;
              break;
            }
          }
        }
LABEL_134:
        uint64_t v48 = v16;
        goto LABEL_135;
      }
      uint64_t v34 = v11 + v12;
      if (v16 > v11 + v12) {
        goto LABEL_134;
      }
      int v35 = *(_DWORD *)(v26 + 16 * v15 + 8);
      if ((v35 & 0x40000000) == 0)
      {
        if ((v23 & 0x10000000) == 0 && (v35 & 0x70FFFF) != 0x400006) {
          goto LABEL_134;
        }
        uint64_t v36 = v16 + 2;
        uint64_t v37 = v16;
        if (v16 + 2 >= v34) {
          goto LABEL_93;
        }
        uint64_t v38 = v26 + 16 * v16;
        if ((*(_DWORD *)(v38 + 8) & 0x80000000) != 0)
        {
          uint64_t v39 = v16;
          if ((unsigned __int16)*(_DWORD *)(v38 + 8) != 8) {
            goto LABEL_53;
          }
        }
        long long v40 = (int *)(v38 + 24);
        uint64_t v39 = v16;
        while (v39 + 3 < v34)
        {
          ++v39;
          int v42 = *v40;
          v40 += 4;
          __int16 v41 = v42;
          if (v42 < 0 && v41 != 8)
          {
            uint64_t v36 = v39 + 2;
LABEL_53:
            uint64_t v37 = v16;
            if (v118)
            {
              if (TRunGlue::GetGlyphID(a2, v39 + 1) == v118) {
                uint64_t v37 = v36;
              }
              else {
                uint64_t v37 = v16;
              }
            }
LABEL_93:
            if (a5 == 1952542060) {
              goto LABEL_127;
            }
            if (a5 == 1835825517)
            {
              uint64_t v52 = v37 + 1;
              if (v37 + 1 >= v34)
              {
                uint64_t v16 = v37;
              }
              else
              {
                uint64_t v53 = 16 * v37 + 24;
                uint64_t v16 = v37;
                do
                {
                  uint64_t v120 = a2;
                  v121.i64[0]  = v52;
                  if (!TRunGlue::TGlyph::IsDeleted((TRunGlue::TGlyph *)&v120)
                    && (!v118 || TRunGlue::GetGlyphID(v120, v121.i64[0]) != v118)
                    && (*(unsigned char *)(**((void **)a2 + 13) + v53 + 3) & 0x10) != 0)
                  {
                    uint64_t v16 = v52;
                  }
                  ++v52;
                  v53 += 16;
                }
                while (v34 != v52);
              }
              goto LABEL_127;
            }
            uint64_t v54 = v37 - 1;
            uint64_t v55 = v15;
            if (v37 - 1 <= v15) {
              goto LABEL_120;
            }
            uint64_t v56 = v37;
            uint64_t v57 = 16 * v37;
            while (1)
            {
              if (v118 && TRunGlue::GetGlyphID(a2, v54) == v118)
              {
                uint64_t v58 = **((void **)a2 + 13);
                if (*(_DWORD *)(v58 + v57 - 24) != 9 && (unsigned __int16)*(_DWORD *)(v58 + v57 - 24) != 8)
                {
                  if ((unsigned __int16)*(_DWORD *)(v58 + v57 + 8) != 8)
                  {
                    if (*(_DWORD *)(v58 + v57 + 8) == 9) {
                      uint64_t v105 = v54 + 1;
                    }
                    else {
                      uint64_t v105 = v54;
                    }
                    uint64_t v55 = v105 + 1;
LABEL_119:
                    uint64_t v37 = v56;
LABEL_120:
                    if (v55 != v15 || v24 == 0) {
                      uint64_t v16 = v55;
                    }
                    else {
                      uint64_t v16 = v37;
                    }
LABEL_127:
                    if (v16 > v12)
                    {
                      while (1)
                      {
                        uint64_t v120 = a2;
                        v121.i64[0]  = v16;
                        if (!TRunGlue::TGlyph::IsDeleted((TRunGlue::TGlyph *)&v120)) {
                          break;
                        }
                        if (--v16 <= v12)
                        {
                          uint64_t v16 = v12;
                          goto LABEL_134;
                        }
                      }
                    }
                    goto LABEL_134;
                  }
                  if (v54 + 3 < v34)
                  {
                    uint64_t v60 = v58 + v57;
                    if ((*(unsigned char *)(v60 + 27) & 2) != 0
                      && *(_WORD *)(v60 + 40) == 7
                      && TRunGlue::GetGlyphID(a2, v54 + 3) != v118)
                    {
                      uint64_t v55 = v54 + 2;
                      goto LABEL_119;
                    }
                  }
                }
              }
              --v54;
              v57 -= 16;
              if (v54 <= v15)
              {
                uint64_t v55 = v15;
                goto LABEL_119;
              }
            }
          }
        }
        uint64_t v37 = v16;
        goto LABEL_93;
      }
      if ((*((unsigned char *)a4 + 15) & 3) == 0) {
        goto LABEL_133;
      }
      uint64_t v44 = v15 + 1;
      if (v15 + 1 < v16)
      {
        uint64_t v45 = 16 * v15 + 40;
        uint64_t v46 = v15 + 1;
        while (!v118 || TRunGlue::GetGlyphID(a2, v46) != v118)
        {
          ++v46;
          v45 += 16;
          if (v16 == v46) {
            goto LABEL_73;
          }
        }
        uint64_t v48 = v46 + 1;
        if (v46 + 1 < v16
          && ((unsigned __int16)*(_DWORD *)(**((void **)a2 + 13) + v45) == 8
           || *(_DWORD *)(**((void **)a2 + 13) + v45) == 9))
        {
          uint64_t v48 = v46 + 2;
        }
        if (v48 != -1)
        {
LABEL_135:
          uint64_t v62 = v15 + v116;
          uint64_t v10 = v114;
          if (v15 + v116 >= v114)
          {
            uint64_t v25 = v119;
          }
          else
          {
            uint64_t v25 = v119;
            while (1)
            {
              uint64_t v120 = a2;
              v121.i64[0]  = v62;
              if (!TRunGlue::TGlyph::IsDeleted((TRunGlue::TGlyph *)&v120)) {
                break;
              }
              if (++v62 >= v114)
              {
                uint64_t v62 = v114;
                break;
              }
            }
          }
          if (v48 == v62)
          {
            a3  = v118;
            double v7 = v113;
          }
          else
          {
            if (v48 == v15)
            {
              double v7 = v113;
              unint64_t v64 = *((void *)v113 + 37);
              unint64_t v63 = *((void *)v113 + 38);
              if (v64 >= v63)
              {
                uint64_t v73 = *((void *)v113 + 36);
                unint64_t v74 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v64 - v73) >> 3);
                unint64_t v75 = v74 + 1;
                a3  = v118;
                if (v74 + 1 > 0xAAAAAAAAAAAAAAALL) {
                  goto LABEL_206;
                }
                unint64_t v76 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v63 - v73) >> 3);
                if (2 * v76 > v75) {
                  unint64_t v75 = 2 * v76;
                }
                if (v76 >= 0x555555555555555) {
                  unint64_t v77 = 0xAAAAAAAAAAAAAAALL;
                }
                else {
                  unint64_t v77 = v75;
                }
                uint64_t v123 = v108;
                uint64_t v78 = (char *)TInlineBufferAllocator<PostGSUBFixups::Adjustment,2ul>::allocate(v108, v77);
                uint64_t v79 = &v78[24 * v74];
                *(void *)uint64_t v79 = v15;
                *(int64x2_t *)(v79 + 8)  = vdupq_n_s64(1uLL);
                uint64_t v80 = *((void *)v113 + 36);
                unint64_t v81 = *((void *)v113 + 37);
                if (v81 == v80)
                {
                  int64x2_t v84 = vdupq_n_s64(v81);
                  uint64_t v82 = &v78[24 * v74];
                }
                else
                {
                  uint64_t v82 = &v78[24 * v74];
                  do
                  {
                    long long v83 = *(_OWORD *)(v81 - 24);
                    *((void *)v82 - 1)  = *(void *)(v81 - 8);
                    *(_OWORD *)(v82 - 24)  = v83;
                    v82 -= 24;
                    v81 -= 24;
                  }
                  while (v81 != v80);
                  int64x2_t v84 = *((int64x2_t *)v113 + 18);
                }
                int v65 = v79 + 24;
                *((void *)v113 + 36)  = v82;
                *((void *)v113 + 37)  = v79 + 24;
                int64x2_t v121 = v84;
                uint64_t v100 = *((void *)v113 + 38);
                *((void *)v113 + 38)  = &v78[24 * v77];
                uint64_t v122 = v100;
                uint64_t v120 = (TRunGlue *)v84.i64[0];
                std::__split_buffer<PostGSUBFixups::Adjustment,TInlineBufferAllocator<PostGSUBFixups::Adjustment,2ul> &>::~__split_buffer((uint64_t)&v120);
              }
              else
              {
                *(void *)unint64_t v64 = v15;
                *(int64x2_t *)(v64 + 8)  = vdupq_n_s64(1uLL);
                int v65 = (char *)(v64 + 24);
                a3  = v118;
              }
              *((void *)v113 + 37)  = v65;
            }
            else
            {
              if (v15 > v48) {
                uint64_t v66 = v15 - v48 + 1;
              }
              else {
                uint64_t v66 = v48 - v62;
              }
              if (v48 >= v15) {
                uint64_t v67 = v62;
              }
              else {
                uint64_t v67 = v48;
              }
              if (v48 >= v15) {
                uint64_t v68 = v15 - v62;
              }
              else {
                uint64_t v68 = v62 - v15;
              }
              int64_t v69 = v113;
              uint64_t v71 = (uint64_t *)*((void *)v113 + 37);
              unint64_t v70 = *((void *)v113 + 38);
              if ((unint64_t)v71 >= v70)
              {
                uint64_t v117 = v67;
                uint64_t v85 = *((void *)v113 + 36);
                unint64_t v86 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v71 - v85) >> 3);
                unint64_t v87 = v86 + 1;
                if (v86 + 1 > 0xAAAAAAAAAAAAAAALL) {
LABEL_206:
                }
                  abort();
                unint64_t v88 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v70 - v85) >> 3);
                if (2 * v88 > v87) {
                  unint64_t v87 = 2 * v88;
                }
                if (v88 >= 0x555555555555555) {
                  unint64_t v89 = 0xAAAAAAAAAAAAAAALL;
                }
                else {
                  unint64_t v89 = v87;
                }
                uint64_t v123 = v108;
                unint64_t v112 = v89;
                unint64_t v90 = (char *)TInlineBufferAllocator<PostGSUBFixups::Adjustment,2ul>::allocate(v108, v89);
                uint64_t v91 = &v90[24 * v86];
                *(void *)uint64_t v91 = v117;
                *((void *)v91 + 1)  = v66;
                *((void *)v91 + 2)  = v68;
                uint64_t v92 = *((void *)v113 + 36);
                unint64_t v93 = *((void *)v113 + 37);
                if (v93 == v92)
                {
                  int64x2_t v96 = vdupq_n_s64(v93);
                  uint64_t v94 = &v90[24 * v86];
                  int64_t v69 = v113;
                  uint64_t v25 = v119;
                }
                else
                {
                  uint64_t v94 = &v90[24 * v86];
                  uint64_t v25 = v119;
                  do
                  {
                    long long v95 = *(_OWORD *)(v93 - 24);
                    *((void *)v94 - 1)  = *(void *)(v93 - 8);
                    *(_OWORD *)(v94 - 24)  = v95;
                    v94 -= 24;
                    v93 -= 24;
                  }
                  while (v93 != v92);
                  int64_t v69 = v113;
                  int64x2_t v96 = *((int64x2_t *)v113 + 18);
                }
                char v72 = v91 + 24;
                *((void *)v69 + 36)  = v94;
                *((void *)v69 + 37)  = v91 + 24;
                int64x2_t v121 = v96;
                uint64_t v101 = *((void *)v69 + 38);
                *((void *)v69 + 38)  = &v90[24 * v112];
                uint64_t v122 = v101;
                uint64_t v120 = (TRunGlue *)v96.i64[0];
                std::__split_buffer<PostGSUBFixups::Adjustment,TInlineBufferAllocator<PostGSUBFixups::Adjustment,2ul> &>::~__split_buffer((uint64_t)&v120);
              }
              else
              {
                *uint64_t v71 = v67;
                v71[1]  = v66;
                char v72 = v71 + 3;
                v71[2]  = v68;
              }
              *((void *)v69 + 37)  = v72;
              if (v15 >= v48)
              {
                uint64_t v102 = v48;
                uint64_t v103 = v15;
                uint64_t v104 = v62;
              }
              else
              {
                uint64_t v102 = v15;
                uint64_t v103 = v62;
                uint64_t v104 = v48;
              }
              TRunGlue::Rotate(a2, v102, v103, v104, v109);
              char v111 = 1;
              a3  = v118;
              double v7 = v113;
            }
            uint64_t v10 = v114;
          }
          goto LABEL_197;
        }
      }
LABEL_73:
      int v47 = *((_DWORD *)a4 + 3) & 0x3000000;
      uint64_t v48 = v16;
      if (v47 != 50331648)
      {
        if (v47 != 0x1000000 || v44 >= v16)
        {
LABEL_133:
          if ((*((_DWORD *)a4 + 3) & 0x3000000) == 0x2000000) {
            goto LABEL_134;
          }
          if (v34 >= v12) {
            uint64_t v97 = v12;
          }
          else {
            uint64_t v97 = v11 + v12;
          }
          uint64_t v98 = 16 * v34 - 8;
          while (v34 > v12)
          {
            --v34;
            int v99 = *(_DWORD *)(**((void **)a2 + 13) + v98) & 0xFFFE;
            v98 -= 16;
            if (v99 != 12)
            {
              uint64_t v97 = v34 + 1;
              break;
            }
          }
          if (v97 == -1) {
            uint64_t v48 = v16;
          }
          else {
            uint64_t v48 = v97;
          }
          goto LABEL_135;
        }
        uint64_t v50 = 16 * v15 + 24;
        while (1)
        {
          uint64_t v120 = a2;
          v121.i64[0]  = v44;
          if (!TRunGlue::TGlyph::IsDeleted((TRunGlue::TGlyph *)&v120)
            && (~*(_DWORD *)(**((void **)a2 + 13) + v50) & 0x88000000) == 0)
          {
            break;
          }
          ++v44;
          v50 += 16;
          if (v16 == v44) {
            goto LABEL_133;
          }
        }
        uint64_t v48 = v44;
      }
      if (v48 != -1) {
        goto LABEL_135;
      }
      goto LABEL_133;
    }
  }
  char v111 = 0;
  return v111 & 1;
}

char *TInlineBufferAllocator<PostGSUBFixups::FixupData,8ul>::allocate(uint64_t a1, unint64_t a2)
{
  CFDataRef v2 = (char *)(a1 + 256);
  CGColorSpaceRef result = *(char **)(a1 + 256);
  CFDataRef v4 = &result[32 * a2];
  if (v4 <= v2)
  {
    *(void *)CFDataRef v2 = v4;
  }
  else
  {
    if (a2 >> 59) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    return (char *)operator new(32 * a2);
  }
  return result;
}

uint64_t std::__split_buffer<PostGSUBFixups::FixupData,TInlineBufferAllocator<PostGSUBFixups::FixupData,8ul> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3) {
    *(void *)(a1 + 16)  = v2 + ((v3 - v2 + 31) & 0xFFFFFFFFFFFFFFE0);
  }
  CFDataRef v4 = *(void **)a1;
  if (*(void *)a1)
  {
    unint64_t v5 = *(void *)(a1 + 32);
    double v6 = (void *)(v5 + 256);
    if (v5 <= (unint64_t)v4 && v6 > v4)
    {
      if (*(void *)(a1 + 24) == *v6) {
        *double v6 = v4;
      }
    }
    else
    {
      operator delete(v4);
    }
  }
  return a1;
}

void *TInlineBufferAllocator<PostGSUBFixups::Adjustment,2ul>::allocate(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 48);
  uint64_t v2 = (unint64_t *)(a1 + 48);
  uint64_t v3 = v4;
  unint64_t v5 = v4 + 24 * a2;
  if (v5 <= (unint64_t)v2)
  {
    *uint64_t v2 = v5;
    return (void *)v3;
  }
  else
  {
    if (a2 >= 0xAAAAAAAAAAAAAABLL) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    return operator new(24 * a2);
  }
}

uint64_t std::__split_buffer<PostGSUBFixups::Adjustment,TInlineBufferAllocator<PostGSUBFixups::Adjustment,2ul> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != *(void *)(a1 + 8)) {
    *(void *)(a1 + 16)  = (v2 - *(void *)(a1 + 8) - 24) % 0x18uLL + *(void *)(a1 + 8);
  }
  uint64_t v3 = *(void **)a1;
  if (*(void *)a1)
  {
    unint64_t v4 = *(void *)(a1 + 32);
    unint64_t v5 = (void *)(v4 + 48);
    if (v4 <= (unint64_t)v3 && v5 > v3)
    {
      if (*(void *)(a1 + 24) == *v5) {
        *unint64_t v5 = v3;
      }
    }
    else
    {
      operator delete(v3);
    }
  }
  return a1;
}

uint64_t TTextEncapsulationRun::TTextEncapsulationRun(uint64_t a1, uint64_t a2)
{
  TRun::TRun((TRun *)a1, *(const TRun **)(a2 + 40));
  *uint64_t v3 = &unk_1ED05EFB0;
  v3[40]  = 0;
  v3[41]  = 0;
  uint64_t v4 = v3[20];
  if (v4) {
    uint64_t v4 = *(void *)(v4 + 80);
  }
  *(void *)(a1 + 336)  = v4;
  *(double *)(a1 + 344)  = TRun::GetAscent((TRun *)a1);
  *(double *)(a1 + 352)  = TRun::GetDescent((TRun *)a1);
  *(void *)(a1 + 376)  = 0;
  *(_WORD *)(a1 + 388)  = 1;
  *(unsigned char *)(a1 + 390)  = 0;
  unint64_t v5 = *(double **)(a1 + 336);
  unsigned int v6 = *(unsigned __int8 *)v5;
  int v7 = *((unsigned __int8 *)v5 + 3);
  double v8 = v5[4];
  if (!*((unsigned char *)v5 + 3))
  {
    double v9 = v5[1];
    if (v9 <= 0.0)
    {
      *(double *)(a1 + 368)  = TTextEncapsulationRun::GetParameter(5u, *((unsigned __int16 *)v5 + 20), *(unsigned __int8 *)v5, v5[4]);
      unint64_t v5 = *(double **)(a1 + 336);
    }
    else
    {
      *(double *)(a1 + 368)  = v9;
    }
  }
  if (*((unsigned char *)v5 + 1)) {
    unsigned int v10 = 4;
  }
  else {
    unsigned int v10 = 3;
  }
  *(double *)(a1 + 360)  = TTextEncapsulationRun::GetParameter(v10, *((unsigned __int16 *)v5 + 20), v6, v8);
  *(_DWORD *)(a1 + 384)  = 0;
  if (v7 == 1)
  {
    CFArrayRef explicit = (const void *)atomic_load_explicit((atomic_ullong *volatile)(a1 + 72), memory_order_acquire);
    if (!explicit || (uint64_t v12 = *(const void **)(*(void *)(a1 + 336) + 24)) == 0 || CFEqual(explicit, v12)) {
      *(_DWORD *)(a1 + 384)  = 16;
    }
  }
  return a1;
}

double TTextEncapsulationRun::GetParameter(unsigned int a1, unsigned int a2, unsigned int a3, double a4)
{
  if (a3 == 1
    && TTextEncapsulationRun::GetParameter(TTextEncapsulationRun::Parameter,unsigned short,CTTextEncapsulationScale,double)::onceToken != -1)
  {
    dispatch_once(&TTextEncapsulationRun::GetParameter(TTextEncapsulationRun::Parameter,unsigned short,CTTextEncapsulationScale,double)::onceToken, &__block_literal_global_3);
  }
  double v8 = &kEnclosureParameters[18 * a3];
  if (a2 > 0x190)
  {
    double v11 = v8[a1 + 12];
    double v10 = ((double)a2 + -400.0) / 600.0;
    double v9 = kEnclosureParameters[18 * a3 + 6 + a1];
  }
  else
  {
    double v9 = v8[a1];
    double v10 = (double)a2 / 400.0;
    double v11 = kEnclosureParameters[18 * a3 + 6 + a1];
  }
  double v12 = std::__lerp[abi:nn180100]<double>(v9, v11, v10);
  double v13 = 1.0;
  if (a1) {
    double v13 = a4;
  }
  return v13 * v12;
}

void TTextEncapsulationRun::TTextEncapsulationRun(TTextEncapsulationRun *this, atomic_ullong *a2)
{
  TRun::TRun(this, (const TRun *)a2);
  *uint64_t v4 = &unk_1ED05EFB0;
  atomic_ullong v5 = a2[41];
  v4[40]  = a2[40];
  v4[41]  = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  *((void *)this + 42)  = a2[42];
  *((double *)this + 43)  = TRun::GetAscent(this);
  Descent  = TRun::GetDescent(this);
  atomic_ullong v7 = a2[45];
  atomic_ullong v8 = a2[46];
  *((double *)this + 44)  = Descent;
  *((void *)this + 45)  = v7;
  *((void *)this + 46)  = v8;
  *((void *)this + 47)  = (id)atomic_load_explicit(a2 + 47, memory_order_acquire);
  *((_DWORD *)this + 96)  = *((_DWORD *)a2 + 96);
  *((unsigned char *)this + 388)  = *((unsigned char *)a2 + 388);
  *((unsigned char *)this + 389)  = 0;
  *((unsigned char *)this + 390)  = *((unsigned char *)a2 + 390);
}

uint64_t TTextEncapsulationRun::TTextEncapsulationRun(uint64_t a1, uint64_t a2, uint64_t a3, CFIndex a4, int a5)
{
  atomic_ullong v7 = (TRun *)TRun::TRun(a1, a2, a3, a4, a5);
  *(void *)atomic_ullong v7 = &unk_1ED05EFB0;
  *((void *)v7 + 40)  = 0;
  *((void *)v7 + 41)  = 0;
  *((void *)v7 + 42)  = *(void *)(a2 + 336);
  *(double *)(a1 + 344)  = TRun::GetAscent(v7);
  Descent  = TRun::GetDescent((TRun *)a1);
  uint64_t v9 = *(void *)(a2 + 360);
  uint64_t v10 = *(void *)(a2 + 368);
  *(double *)(a1 + 352)  = Descent;
  *(void *)(a1 + 360)  = v9;
  *(void *)(a1 + 368)  = v10;
  *(void *)(a1 + 376)  = 0;
  *(_DWORD *)(a1 + 384)  = *(_DWORD *)(a2 + 384);
  *(_WORD *)(a1 + 388)  = 1;
  *(unsigned char *)(a1 + 390)  = *(unsigned char *)(a2 + 390);
  *(_DWORD *)(a1 + 256)  = 3;
  double v11 = *(_OWORD **)(a1 + 312);
  if (v11)
  {
    _OWORD *v11 = *MEMORY[0x1E4F1DB30];
    uint64_t v12 = *(void *)(a1 + 312);
    if (v12)
    {
      uint64_t v13 = *(void *)(v12 + 56);
      if (v13 != *(void *)(v12 + 64)) {
        *(void *)(v12 + 64)  = v13;
      }
    }
  }
  return a1;
}

unsigned int TTextEncapsulationRun::GetClassOfWeight(TTextEncapsulationRun *this, double a2)
{
  unsigned int v3 = IndexesBracketing<double const*,double>(kSFWeightScale, (double *)&xmmword_184BA6030, a2, 0.001);
  double v4 = kSFWeightScale[(unsigned __int16)v3];
  double v5 = kSFWeightScale[HIWORD(v3)];
  double v6 = 0.0;
  if (v4 != v5) {
    double v6 = (a2 - v4) / (v5 - v4);
  }
  return llround(std::__lerp[abi:nn180100]<double>((double)(100 * (unsigned __int16)v3), (double)(int)(100 * HIWORD(v3)), v6));
}

void TTextEncapsulationRun::CreateEncapsulationFont(const __CTFont *a1@<X0>, unsigned int a2@<W1>, int a3@<W2>, unsigned int a4@<W3>, CTFontRef *a5@<X8>)
{
  if (a1) {
    double v9 = *(double *)(*((void *)a1 + 5) + 16);
  }
  else {
    double v9 = 0.0;
  }
  if (a3) {
    unsigned int v10 = 2;
  }
  else {
    unsigned int v10 = 1;
  }
  Parameter  = TTextEncapsulationRun::GetParameter(v10, a2, a4, v9);
  id v20 = 0;
  if (a1)
  {
    uint64_t v12 = *(__CFString **)(*((void *)a1 + 5) + 400);
    if (v12) {
      uint64_t v12 = (__CFString *)(*((uint64_t (**)(__CFString *))v12->isa + 67))(v12);
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  if (v12 == @"NSCTFontUIFontDesignDefault"
    || v12 && @"NSCTFontUIFontDesignDefault" && CFEqual(v12, @"NSCTFontUIFontDesignDefault"))
  {
    id values = objc_msgSend(NSNumber, "numberWithDouble:", TTextEncapsulationRun::GetParameter(0, a2, a4, v9));
    id keys = &unk_1ED082DB8;
    CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    unint64_t v14 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
    uint64_t v15 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
    CFDictionaryRef v16 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    id values = v16;
    id keys = @"NSCTFontVariationAttribute";
    CFDictionaryRef v17 = CFDictionaryCreate(v13, (const void **)&keys, (const void **)&values, 1, v14, v15);
    uint64_t v18 = TCFBase<TDescriptor>::Allocate();
    if (v18)
    {
      uint64_t v19 = (void *)v18;
      *(void *)(v18 + 16)  = 0;
      *(void *)(v18 + 24)  = TDescriptor::Hash;
      *(void *)(v18 + 32)  = 0;
      *(void *)(v18 + 40)  = v18 + 48;
      *(void *)(v18 + 48)  = &unk_1ED05D778;
      *(void *)(v18 + 56)  = 0;
      *(_DWORD *)(v18 + 64)  = 0;
      *(void *)(v18 + 80)  = 0;
      *(void *)(v18 + 88)  = 0;
      *(void *)(v18 + 72)  = 0;
      TCFRef<__CTFont const*>::Retain((atomic_ullong *)(v18 + 56), v17);
      id keys = v19;
      id values = (void *)atomic_exchange((atomic_ullong *volatile)&keys, 0);
    }
    else
    {
      id values = 0;
    }
  }
  *a5  = CTFontCreateCopyWithAttributes(a1, Parameter, 0, (CTFontDescriptorRef)atomic_load_explicit((atomic_ullong *volatile)&v20, memory_order_acquire));
}

void ___ZN21TTextEncapsulationRun12GetParameterENS_9ParameterEt24CTTextEncapsulationScaled_block_invoke()
{
  uint64_t v0 = 0;
  unint64_t v1 = kEnclosureParameters;
  do
  {
    for (uint64_t i = 0; i != 6; ++i)
      v1[i + 18]  = std::__lerp[abi:nn180100]<double>(v1[i], v1[i + 36], 0.43);
    ++v0;
    v1 += 6;
  }
  while (v0 != 3);
}

void TTextEncapsulationRun::CopyPlatterPath(atomic_ullong *this, __n128 *a2)
{
  *(void *)&v34.size.height  = a2[22].n128_u64[1];
  v34.origin.CGFloat y = (*(double *)(a2[21].n128_u64[0] + 48) - v34.size.height) * 0.5;
  v34.size.CGFloat width = *(CGFloat *)(a2[20].n128_u64[0] + 32);
  v34.origin.CGFloat x = 0.0;
  CGRect v35 = CGRectInset(v34, a2[23].n128_f64[0], 0.0);
  *this  = 0;
  int v4 = *(unsigned __int8 *)(a2[21].n128_u64[0] + 2);
  if (v4 == 2 || v4 == 1)
  {
    uint64_t v5 = CGPathCreateWithContinuousRoundedRect();
  }
  else
  {
    if (*(unsigned char *)(a2[21].n128_u64[0] + 2)) {
      goto LABEL_7;
    }
    uint64_t v5 = (uint64_t)CGPathCreateWithRect(v35, 0);
  }
  *(void *)&v32.a  = v5;

LABEL_7:
  if (!*(unsigned char *)(a2[21].n128_u64[0] + 3))
  {
    *(void *)&v32.a  = CGPathCreateCopyByStrokingPath((CGPathRef)atomic_load_explicit(this, memory_order_acquire), 0, a2[23].n128_f64[0], kCGLineCapButt, kCGLineJoinMiter, 10.0);

    CFArrayRef explicit = (void *)atomic_load_explicit(this, memory_order_acquire);
    if (*(unsigned char *)(a2[21].n128_u64[0] + 3) || a2[5].n128_u8[10])
    {
      id v31 = explicit;
    }
    else
    {
      BoundingBoCGFloat x = CGPathGetBoundingBox((CGPathRef)explicit);
      CGFloat x = BoundingBox.origin.x;
      CGFloat y = BoundingBox.origin.y;
      CGFloat width = BoundingBox.size.width;
      height  = BoundingBox.size.height;
      *(void *)&v32.a  = CGPathCreateMutable();
      double v11 = (const CGPath *)a2[17].n128_u64[0];
      if (v11)
      {
        uint64_t v12 = *((void *)v11 + 3) - *((void *)v11 + 2);
        uint64_t v13 = v12 >> 3;
        unint64_t v14 = (uint64_t *)a2[20].n128_u64[0];
        uint64_t v15 = *v14;
        uint64_t v16 = v14[1] + *v14;
        if (v16 >= v12 >> 3) {
          uint64_t v17 = v12 >> 3;
        }
        else {
          uint64_t v17 = v16;
        }
        if (v15 < 0 || v15 >= v13)
        {
          BOOL v18 = v16 > 0 && v15 < 1;
          uint64_t v15 = 0;
          if (!v18) {
            uint64_t v17 = 0;
          }
        }
        else
        {
          v17 -= v15;
        }
        if (v17 >= 1)
        {
          uint64_t v19 = v15 + v17;
          uint64_t v20 = v15;
          do
          {
            uint64_t v21 = *(atomic_ullong **)(*(void *)(*((void *)v11 + 2) + 8 * v20) + 40);
            v33.CGFloat width = -3.72066208e-103;
            TRun::CopyPath(v21, &v33);
            CGPathAddPath((CGMutablePathRef)atomic_load_explicit((atomic_ullong *volatile)&v32, memory_order_acquire), 0, (CGPathRef)atomic_load_explicit((atomic_ullong *volatile)&v33, memory_order_acquire));

            ++v20;
          }
          while (v15 <= v20 && v19 > v20);
        }
        double v11 = (const CGPath *)atomic_exchange((atomic_ullong *volatile)&v32, 0);
      }

      v33.CGFloat width = NAN;
      v33.height  = NAN;
      TRun::GetPositions(a2, &v33);
      CGRect v37 = CGPathGetBoundingBox(v11);
      CGFloat v22 = v37.origin.x;
      CGFloat v23 = v37.origin.y;
      CGFloat v24 = v37.size.width;
      CGFloat v25 = v37.size.height;
      if (CGRectIsNull(v37)) {
        goto LABEL_33;
      }
      v38.origin.CGFloat x = v22;
      v38.origin.CGFloat y = v23;
      v38.size.CGFloat width = v24;
      v38.size.height  = v25;
      CGRect v39 = CGRectOffset(v38, -v33.width, -v33.height);
      CGRect v40 = CGRectInset(v39, a2[23].n128_f64[0] * -0.5, a2[23].n128_f64[0] * -0.5);
      CGFloat v26 = v40.origin.x;
      CGFloat v27 = v40.origin.y;
      CGFloat v28 = v40.size.width;
      CGFloat v29 = v40.size.height;
      v40.origin.CGFloat x = x;
      v40.origin.CGFloat y = y;
      v40.size.CGFloat width = width;
      v40.size.height  = height;
      CGRect v41 = CGRectInset(v40, a2[23].n128_f64[0], a2[23].n128_f64[0]);
      v42.origin.CGFloat x = v26;
      v42.origin.CGFloat y = v27;
      v42.size.CGFloat width = v28;
      v42.size.height  = v29;
      if (!CGRectContainsRect(v41, v42))
      {
LABEL_33:
        *(void *)&long long v30 = -1;
        *((void *)&v30 + 1)  = -1;
        *(_OWORD *)&v32.c  = v30;
        *(_OWORD *)&v32.tCGFloat x = v30;
        *(_OWORD *)&v32.a  = v30;
        CGAffineTransformMakeTranslation(&v32, -v33.width, -v33.height);
        CreateMaskedPath((const CGPath *)explicit, v11, a2[23].n128_f64[0], &v32, 1, &v31);
      }
      else
      {
        id v31 = explicit;
      }
    }
  }
}

void TTextEncapsulationRun::DrawGlyphs(__n128 *this, CGContextRef c, CFRange a3)
{
  CFIndex length = a3.length;
  CFIndex location = a3.location;
  TextPosition  = CGContextGetTextPosition(c);
  v24.CGFloat width = NAN;
  v24.height  = NAN;
  TRun::GetPositions(this, &v24);
  double v9 = v8;
  CGContextSetTextPosition(c, TextPosition.x - v24.width, TextPosition.y - v24.height);
  v23[1]  = 0;
  v23[2]  = 0xAAAAAAAAAAAAAA00;
  v23[0]  = 0xAAAAAAAAAAAAAA01;
  TTextEncapsulationRun::DrawGlyphsAtPositions(this, c, location, length, v9, (uint64_t)v23);
  unsigned int v10 = (double *)this[19].n128_u64[1];
  if (!v10) {
    unsigned int v10 = (double *)MEMORY[0x1E4F1DB30];
  }
  double v11 = TextPosition.x + *v10;
  double v12 = TextPosition.y + v10[1];
  uint64_t v13 = this[13].n128_i64[0];
  if (v13)
  {
    unint64_t v14 = this[13].n128_u64[1];
    uint64_t v15 = *(void *)(v14 + 32);
    if (v15 || (uint64_t v18 = *(void *)(v14 + 24)) == 0)
    {
      int v16 = 0;
      uint64_t v17 = (double *)(v15 + 16 * this[12].n128_u64[1]);
    }
    else
    {
      uint64_t v17 = (double *)(v18 + 8 * this[12].n128_u64[1]);
      int v16 = 1;
    }
    if (v13 >= 1)
    {
      uint64_t v19 = 0;
      uint64_t v20 = v17;
      do
      {
        if (v16)
        {
          uint64_t v21 = &v17[v19];
          double v22 = 0.0;
        }
        else
        {
          double v22 = v20[1];
          uint64_t v21 = v20;
        }
        double v11 = v11 + *v21;
        double v12 = v12 + v22;
        ++v19;
        v20 += 2;
        --v13;
      }
      while (v13);
    }
  }
  CGContextSetTextPosition(c, v11, v12);
}

void TTextEncapsulationRun::DrawGlyphsAtPositions(__n128 *a1, CGContextRef c, CFIndex a3, CFIndex a4, const CGPoint *a5, uint64_t a6)
{
  if (a4 >= 1)
  {
    uint64_t v28 = v9;
    uint64_t v29 = v8;
    uint64_t v30 = v6;
    uint64_t v31 = v7;
    if (a1[24].n128_u8[5])
    {
      TextPosition  = CGContextGetTextPosition(c);
      v27.CGFloat width = NAN;
      v27.height  = NAN;
      TRun::GetPositions(a1, &v27);
      CGFloat v17 = TextPosition.x + v27.width;
      CGFloat v18 = TextPosition.y + v27.height;
      CGContextSaveGState(c);
      CGAffineTransformMakeTranslation(&transform, v17, v18);
      CGContextConcatCTM(c, &transform);
      id v25 = (id)atomic_load_explicit(&a1[23].n128_i64[1], memory_order_acquire);
      if (!atomic_load_explicit((atomic_ullong *volatile)&v25, memory_order_acquire))
      {
        TTextEncapsulationRun::CopyPlatterPath((atomic_ullong *)&v24, a1);

        id v20 = (id)atomic_load_explicit((atomic_ullong *volatile)&v25, memory_order_acquire);
        uint64_t v21 = 0;
        atomic_compare_exchange_strong(&a1[23].n128_i64[1], (unint64_t *)&v21, (unint64_t)v20);
        if (!v21) {
          id v20 = 0;
        }
      }
      if (atomic_load_explicit((atomic_ullong *volatile)&v25, memory_order_acquire))
      {
        CFArrayRef explicit = *(void **)(a1[21].n128_u64[0] + 24);
        if (!explicit) {
          CFArrayRef explicit = (void *)atomic_load_explicit(&a1[4].n128_i64[1], memory_order_acquire);
        }
        TAttributes::SetFillColor(c, explicit, v19);
        CGContextAddPath(c, (CGPathRef)atomic_load_explicit((atomic_ullong *volatile)&v25, memory_order_acquire));
        CGContextFillPath(c);
      }

      CGContextRestoreGState(c);
    }
    CGContextSaveGState(c);
    CGContextSetShouldSubpixelQuantizeFonts(c, 0);
    CGBlendMode v23 = a1[24].n128_u32[0];
    if (v23) {
      CGContextSetBlendMode(c, v23);
    }
    v32.CFIndex location = a3;
    v32.CFIndex length = a4;
    TRun::DrawGlyphsAtPositionsInternal((TRun *)a1, c, v32, a5, *(unsigned char *)a6 != 0, *(const TAttributes **)(a6 + 8), 1);
    CGContextRestoreGState(c);
  }
}

void TTextEncapsulationRun::CopyEncapsulationPath(__n128 *this@<X0>, uint64_t *a2@<X8>)
{
  if (this[24].n128_u8[5])
  {
    id v8 = (id)0xAAAAAAAAAAAAAAAALL;
    TTextEncapsulationRun::CopyPlatterPath((atomic_ullong *)&v8, this);
    if (atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire))
    {
      v7.CGFloat width = NAN;
      v7.height  = NAN;
      TRun::GetPositions(this, &v7);
      *(void *)&long long v4 = -1;
      *((void *)&v4 + 1)  = -1;
      *(_OWORD *)&v6.c  = v4;
      *(_OWORD *)&v6.tCGFloat x = v4;
      *(_OWORD *)&v6.a  = v4;
      CGAffineTransformMakeTranslation(&v6, v7.width, v7.height);
      uint64_t v5 = MEMORY[0x185326E30](atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire), &v6);
    }
    else
    {
      uint64_t v5 = 0;
    }
    *a2  = v5;
  }
  else
  {
    *a2  = 0;
  }
}

uint64_t TTextEncapsulationRun::GetLeftWhitespaceGlyphCountAndWidth(TTextEncapsulationRun *this)
{
  if (*((unsigned char *)this + 389)) {
    return TRun::GetLeftWhitespaceGlyphCountAndWidth(this);
  }
  else {
    return 0;
  }
}

double TTextEncapsulationRun::UpdateWidth(atomic_ullong *this, TLine *a2, uint64_t a3, double a4)
{
  uint64_t v4 = a3;
  CGSize v7 = this + 5;
  unint64_t explicit = atomic_load_explicit(this + 7, memory_order_acquire);
  if (explicit) {
    double v9 = *(double *)(*(void *)(explicit + 40) + 16);
  }
  else {
    double v9 = 0.0;
  }
  double v10 = *(double *)(this[42] + 32);
  double v11 = (uint64_t *)this[40];
  if (!v11
    || ((v12 = *v11, uint64_t v13 = v11[1] + *v11, v12 <= a3) ? (v14 = v13 <= a3) : (v14 = 1),
        v14
     && ((uint64_t v15 = (std::__shared_weak_count *)this[41], this[40] = 0, this[41] = 0, !v15)
      || (std::__shared_weak_count::__release_shared[abi:nn180100](v15), !this[40]))))
  {
    int v16 = (char *)operator new(0x60uLL);
    *((void *)v16 + 1)  = 0;
    *((void *)v16 + 2)  = 0;
    *(void *)int v16 = &unk_1ED062358;
    *(_OWORD *)(v16 + 40)  = 0u;
    *(_OWORD *)(v16 + 56)  = 0u;
    *(_OWORD *)(v16 + 72)  = 0u;
    *((void *)v16 + 11)  = 0;
    CGFloat v17 = (std::__shared_weak_count *)this[41];
    this[41]  = (atomic_ullong)v16;
    *(_OWORD *)(v16 + 24)  = 0u;
    this[40]  = (atomic_ullong)(v16 + 24);
    if (v17) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v17);
    }
    int v99 = (TAttributes *)v7;
    CGFloat v18 = (double *)this[39];
    uint64_t v19 = (double *)MEMORY[0x1E4F1DB30];
    if (!v18) {
      CGFloat v18 = (double *)MEMORY[0x1E4F1DB30];
    }
    double v20 = *v18;
    atomic_ullong v21 = this[20];
    if (v21) {
      uint64_t v22 = *(void *)(v21 + 72);
    }
    else {
      uint64_t v22 = 0;
    }
    double v23 = *((double *)this + 24) + v20;
    uint64_t v24 = v4 + 1;
    if (v4 <= 0)
    {
      uint64_t v26 = 1;
      uint64_t v25 = v4;
    }
    else
    {
      uint64_t v25 = v4;
      uint64_t v26 = 1;
      while (1)
      {
        uint64_t v27 = *(void *)(*(void *)(*((void *)a2 + 2) + 8 * v25 - 8) + 40);
        uint64_t v28 = *(void *)(v27 + 160);
        if (v28) {
          uint64_t v28 = *(void *)(v28 + 72);
        }
        if (v28 != v22) {
          break;
        }
        atomic_ullong v30 = this[40];
        atomic_ullong v29 = this[41];
        if (v29) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v29 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v31 = *(std::__shared_weak_count **)(v27 + 328);
        *(void *)(v27 + 320)  = v30;
        *(void *)(v27 + 328)  = v29;
        if (v31) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v31);
        }
        ++v26;
        CFRange v32 = *(double **)(v27 + 312);
        if (!v32) {
          CFRange v32 = v19;
        }
        double v23 = v23 + *(double *)(v27 + 192) + *v32;
        if (!--v25)
        {
          uint64_t v26 = v4 + 1;
          break;
        }
      }
    }
    uint64_t v33 = *((void *)a2 + 3) - *((void *)a2 + 2);
    int v34 = *((unsigned __int8 *)this + 390);
    uint64_t v98 = v4;
    if (v24 < v33 >> 3)
    {
      uint64_t v35 = v33 >> 3;
      uint64_t v100 = v26 + ~v4 + (v33 >> 3);
      while (1)
      {
        uint64_t v36 = *(void *)(*(void *)(*((void *)a2 + 2) + 8 * v24) + 40);
        uint64_t v37 = *(void *)(v36 + 160);
        if (v37) {
          uint64_t v37 = *(void *)(v37 + 72);
        }
        if (v37 != v22) {
          break;
        }
        atomic_ullong v39 = this[40];
        atomic_ullong v38 = this[41];
        if (v38) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v38 + 8), 1uLL, memory_order_relaxed);
        }
        CGRect v40 = *(std::__shared_weak_count **)(v36 + 328);
        *(void *)(v36 + 320)  = v39;
        *(void *)(v36 + 328)  = v38;
        if (v40) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v40);
        }
        ++v26;
        CGRect v41 = *(double **)(v36 + 312);
        if (!v41) {
          CGRect v41 = v19;
        }
        double v23 = v23 + *(double *)(v36 + 192) + *v41;
        int v34 = *(unsigned __int8 *)(v36 + 390);
        if (v35 == ++v24)
        {
          int v96 = *(unsigned __int8 *)(v36 + 390);
          uint64_t v26 = v100;
          goto LABEL_46;
        }
      }
    }
    int v96 = v34;
LABEL_46:
    double v101 = v9 / v10;
    TAttributes::OriginalFont((atomic_ullong *)v99, (atomic_ullong *)&valuePtr);
    unint64_t v42 = atomic_load_explicit((atomic_ullong *volatile)&valuePtr, memory_order_acquire);

    CGFloat x = *MEMORY[0x1E4F1DB28];
    double y = *(double *)(MEMORY[0x1E4F1DB28] + 8);
    CGFloat width = *(double *)(MEMORY[0x1E4F1DB28] + 16);
    height  = *(double *)(MEMORY[0x1E4F1DB28] + 24);
    if (v26 < 1)
    {
      double v50 = 1.79769313e308;
      double v49 = 2.22507386e-308;
    }
    else
    {
      int v47 = *(TFont **)(v42 + 40);
      uint64_t v48 = (_DWORD *)((char *)v47 + 48);
      double v49 = 2.22507386e-308;
      double v50 = 1.79769313e308;
      uint64_t v51 = v25;
      do
      {
        uint64_t v52 = *(TRun **)(*(void *)(*((void *)a2 + 2) + 8 * v51) + 40);
        CFIndex v53 = *((void *)v52 + 26);
        inited  = (int *)((char *)v47 + 48);
        if (!*v48) {
          inited  = TFont::InitStrikeMetrics(v47);
        }
        double v55 = *((double *)inited + 1);
        uint64_t v56 = (int *)((char *)v47 + 48);
        if (!*v48) {
          uint64_t v56 = TFont::InitStrikeMetrics(v47);
        }
        if (v101 * v55 >= v49) {
          double v49 = v101 * v55;
        }
        if (v101 * *((double *)v56 + 2) >= v50) {
          double v50 = v101 * *((double *)v56 + 2);
        }
        *(double *)&id valuePtr = 0.0;
        uint64_t v57 = *((void *)v52 + 20);
        if (v57) {
          double v58 = *(double *)(v57 + 48);
        }
        else {
          double v58 = 0.0;
        }
        double v103 = -v58;
        v105.CFIndex location = 0;
        v105.CFIndex length = v53;
        v111.origin.CGFloat x = TRun::GetImageBounds(v52, 0, v105, (double *)&valuePtr, &v103);
        v111.origin.double y = v59;
        v111.size.CGFloat width = v60;
        v111.size.height  = v61;
        v107.origin.CGFloat x = x;
        v107.origin.double y = y;
        v107.size.CGFloat width = width;
        v107.size.height  = height;
        CGRect v108 = CGRectUnion(v107, v111);
        CGFloat x = v108.origin.x;
        double y = v108.origin.y;
        CGFloat width = v108.size.width;
        height  = v108.size.height;
        ++v51;
      }
      while (v25 <= v51 && v26 + v25 > v51);
    }
    atomic_ullong v62 = this[42];
    double v95 = *(double *)(v62 + 48);
    double v63 = v101 * v95;
    double v102 = (*((double *)this + 45) - v101 * v95) * 0.5;
    int v64 = *(unsigned __int8 *)(v62 + 2);
    double v65 = 0.0;
    if (v64 == 1) {
      double v65 = 0.25;
    }
    if (v64 == 2) {
      double v65 = 1.0;
    }
    double v97 = v65;
    v109.origin.CGFloat x = x;
    v109.origin.double y = y;
    v109.size.CGFloat width = width;
    v109.size.height  = height;
    uint64_t v4 = v98;
    if (CGRectGetMinY(v109) >= -v50
      && (v110.origin.CGFloat x = x,
          v110.origin.double y = y,
          v110.size.CGFloat width = width,
          v110.size.height  = height,
          CGRectGetMaxY(v110) <= v49))
    {
      double v67 = (v95 - v63) * 0.5;
      atomic_ullong v66 = this[42];
    }
    else
    {
      atomic_ullong v66 = this[42];
      double v67 = (*(double *)(v66 + 48) - height) * 0.5 - y;
    }
    CGSize v7 = (atomic_ullong *)v99;
    double v68 = v102 + v63 * v97 * 0.25;
    double v69 = *((double *)this + 46);
    if ((*(double *)(v66 + 16) - v23 - v69) * 0.5 > v68) {
      double v68 = (*(double *)(v66 + 16) - v23 - v69) * 0.5;
    }
    atomic_ullong v70 = this[40];
    *(void *)atomic_ullong v70 = v25;
    *(void *)(v70 + 8)  = v26;
    *(double *)(v70 + 16)  = v67;
    *(double *)(v70 + 24)  = v68;
    double v71 = v69 + v68;
    double v72 = 1.0;
    if (!v96) {
      double v72 = 2.0;
    }
    *(double *)(v70 + 32)  = v23 + v71 * v72;
    *(CGFloat *)(v70 + 40)  = x;
    *(double *)(v70 + 48)  = y;
    *(CGFloat *)(v70 + 56)  = width;
    *(double *)(v70 + 64)  = height;
  }
  *(double *)&id valuePtr = 0.0;
  Dictionardouble y = (const __CFDictionary *)TAttributes::GetDictionary(v7);
  double v74 = 0.0;
  DoubleCFNumberRef Value = 0.0;
  if (Dictionary)
  {
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(Dictionary, @"CTBaselineOffset");
    DoubleCFNumberRef Value = 0.0;
    if (Value)
    {
      CFNumberRef v77 = Value;
      CFTypeID v78 = CFGetTypeID(Value);
      if (v78 == CFNumberGetTypeID() || v78 == CFBooleanGetTypeID())
      {
        CFNumberGetValue(v77, kCFNumberDoubleType, &valuePtr);
        DoubleCFNumberRef Value = *(double *)&valuePtr;
      }
      else
      {
        CFTypeID TypeID = CFStringGetTypeID();
        DoubleCFNumberRef Value = 0.0;
        if (v78 == TypeID)
        {
          DoubleCFNumberRef Value = CFStringGetDoubleValue((CFStringRef)v77);
          *(double *)&id valuePtr = DoubleValue;
        }
      }
    }
  }
  atomic_ullong v79 = this[40];
  double v80 = DoubleValue + *(double *)(v79 + 16);
  atomic_ullong v81 = this[20];
  if (v81) {
    double v74 = *(double *)(v81 + 48);
  }
  if (v74 != v80)
  {
    *(double *)(TAttributes::EnsureRareData((TAttributes *)v7) + 48)  = v80;
    *((unsigned char *)this + 89)  = 1;
    atomic_ullong v79 = this[40];
  }
  double v82 = *(double *)(v79 + 24) + *((double *)this + 46);
  uint64_t v83 = *(void *)v79;
  double v84 = 0.0;
  if (*(void *)v79 == v4)
  {
    uint64_t v83 = v4;
    if (!*((unsigned char *)this + 389))
    {
      v106.height  = 0.0;
      v106.CGFloat width = *(double *)(v79 + 24) + *((double *)this + 46);
      TRun::AdvanceInitialAdvance((TRun *)this, v106);
      *((unsigned char *)this + 389)  = 1;
      double v84 = v82 + 0.0;
      atomic_ullong v79 = this[40];
      uint64_t v83 = *(void *)v79;
    }
  }
  if (v83 + *(void *)(v79 + 8) - 1 == v4 && !*((unsigned char *)this + 390))
  {
    atomic_ullong v85 = this[26];
    atomic_ullong v86 = this[27];
    uint64_t v87 = *(void *)(v86 + 32);
    if (v87 || (uint64_t v92 = *(void *)(v86 + 24)) == 0)
    {
      uint64_t v88 = v85 - 1;
      uint64_t v89 = v87 + 16 * this[25] + 16 * (v85 - 1);
      uint64_t v90 = *(void *)(v89 + 8);
    }
    else
    {
      uint64_t v88 = v85 - 1;
      uint64_t v89 = v92 + 8 * this[25] + 8 * (v85 - 1);
      uint64_t v90 = 0;
    }
    double v93 = v82 + *(double *)v89;
    TStorageRange::SetAdvance((TStorageRange *)(this + 24), v88, *(CGSize *)(&v90 - 1));
    *((unsigned char *)this + 390)  = 1;
    double v84 = v82 + v84;
  }
  *((unsigned char *)this + 388)  = 0;
  return v84;
}

double TTextEncapsulationRun::GetImageBounds(TTextEncapsulationRun *this, CGContext *a2, CFRange a3, double *a4, double *a5)
{
  ImageBounds  = TRun::GetImageBounds(this, a2, a3, a4, a5);
  CGFloat v8 = v7;
  CGFloat v10 = v9;
  CGFloat v12 = v11;
  if (!*((unsigned char *)this + 388))
  {
    id v14 = (id)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(id *__return_ptr, TTextEncapsulationRun *))(*(void *)this + 128))(&v14, this);
    if (atomic_load_explicit((atomic_ullong *volatile)&v14, memory_order_acquire))
    {
      BoundingBoCGFloat x = CGPathGetBoundingBox((CGPathRef)atomic_load_explicit((atomic_ullong *volatile)&v14, memory_order_acquire));
      v15.origin.CGFloat x = ImageBounds;
      v15.origin.double y = v8;
      v15.size.CGFloat width = v10;
      v15.size.height  = v12;
      *(void *)&ImageBounds  = (unint64_t)CGRectUnion(v15, BoundingBox);
    }
  }
  return ImageBounds;
}

void TTextEncapsulationRun::~TTextEncapsulationRun(id *this)
{
  *this  = &unk_1ED05EFB0;

  uint64_t v2 = (std::__shared_weak_count *)this[41];
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }

  TRun::~TRun(this);
}

{
  std::__shared_weak_count *v2;
  uint64_t vars8;

  *this  = &unk_1ED05EFB0;

  uint64_t v2 = (std::__shared_weak_count *)this[41];
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  TRun::~TRun(this);

  JUMPOUT(0x1853275C0);
}

uint64_t TTextEncapsulationRun::FindBreak@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, const TCharStream *a3@<X2>, int a4@<W3>, uint64_t a5@<X8>, double a6@<D0>)
{
  *(_OWORD *)a5  = xmmword_184BA6030;
  *(void *)(a5 + 16)  = -1;
  uint64_t result = TRun::FindBreak(a1, a2, a3, a4, a5, a6);
  *(unsigned char *)a5 |= 8u;
  return result;
}

double TTextEncapsulationRun::GetAscent(TTextEncapsulationRun *this)
{
  return *((double *)this + 43);
}

double TTextEncapsulationRun::GetDescent(TTextEncapsulationRun *this)
{
  return *((double *)this + 44);
}

double TTextEncapsulationRun::GetLeading(TTextEncapsulationRun *this)
{
  return 0.0;
}

uint64_t TTextEncapsulationRun::CanUpdateWidth(TTextEncapsulationRun *this)
{
  return *((unsigned __int8 *)this + 388);
}

void std::__shared_ptr_emplace<TTextEncapsulationRun::RunGroup>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable  = (std::__shared_weak_count_vtbl *)&unk_1ED062358;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TTextEncapsulationRun::RunGroup>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable  = (std::__shared_weak_count_vtbl *)&unk_1ED062358;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1853275C0);
}

uint64_t IsWAPIComplianceRequired(void)
{
  return MGGetBoolAnswer();
}

uint64_t GetAppleInternalFontsPath(void)
{
  if (qword_1EB2CE460 != -1) {
    dispatch_once_f(&qword_1EB2CE460, 0, (dispatch_function_t)GetAppleInternalFontsPath(void)::$_0::__invoke);
  }
  return qword_1EB2CE468;
}

CFStringRef GetAppleInternalFontsPath(void)::$_0::__invoke()
{
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (qword_1EB2CE458 != -1) {
    dispatch_once_f(&qword_1EB2CE458, 0, (dispatch_function_t)GetSystemRootPath(void)::$_0::__invoke);
  }
  CFStringRef result = CFStringCreateWithFormat(v0, 0, @"%@%@", GetSystemRootPath(void)::_sysPath, @"AppleInternal/Fonts/");
  qword_1EB2CE468  = (uint64_t)result;
  return result;
}

__CFString *TCharStream::DebugDescriptionForRange(TCharStream *this, CFRange a2)
{
  uint64_t length = a2.length;
  CFIndex location = a2.location;
  v40[0]  = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr))(*(void *)this + 8))(v40);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], length);
  int64_t v39 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  int64_t v38 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v35 = 0xAAAAAAAAAAAAAAAALL;
  long long v31 = v5;
  long long v32 = v5;
  long long v29 = v5;
  long long v30 = v5;
  long long v27 = v5;
  long long v28 = v5;
  *(_OWORD *)buffer  = v5;
  long long v26 = v5;
  CFStringRef explicit = (const __CFString *)atomic_load_explicit((atomic_ullong *volatile)v40, memory_order_acquire);
  CFStringRef v33 = explicit;
  CFIndex v36 = location;
  int64_t v37 = length;
  CharactersPtr  = CFStringGetCharactersPtr(explicit);
  if (CharactersPtr) {
    CStringPtr  = 0;
  }
  else {
    CStringPtr  = CFStringGetCStringPtr(explicit, 0x600u);
  }
  unint64_t v35 = (unint64_t)CStringPtr;
  int64_t v38 = 0;
  int64_t v39 = 0;
  if (length >= 1)
  {
    for (int64_t i = 0; i < length; ++i)
    {
      if (i < 0 || (int64_t v9 = v37, v37 <= i))
      {
        uint64_t v11 = 0;
LABEL_11:
        CFStringAppendFormat(Mutable, 0, @"\\x%02X", v11);
      }
      else
      {
        if (CharactersPtr)
        {
          UniChar v10 = CharactersPtr[v36 + i];
        }
        else if (v35)
        {
          UniChar v10 = *(char *)(v35 + v36 + i);
        }
        else
        {
          if (v39 <= i || (int64_t v12 = v38, v38 > i))
          {
            int64_t v13 = i - 4;
            if ((unint64_t)i < 4) {
              int64_t v13 = 0;
            }
            if (v13 + 64 < v37) {
              int64_t v9 = v13 + 64;
            }
            int64_t v38 = v13;
            int64_t v39 = v9;
            v41.CFIndex location = v36 + v13;
            v41.uint64_t length = v9 - v13;
            CFStringGetCharacters(v33, v41, buffer);
            int64_t v12 = v38;
          }
          UniChar v10 = buffer[i - v12];
        }
        if ((unsigned __int16)(v10 - 32) > 0x5Eu)
        {
          uint64_t v11 = v10;
          int64_t v16 = i + 1;
          if (v10 >> 10 != 54 || v16 >= length)
          {
            switch(v10)
            {
              case 7u:
                *(_DWORD *)chars  = 6357084;
                goto LABEL_44;
              case 8u:
                int v20 = 6422620;
                goto LABEL_43;
              case 9u:
                int v20 = 7602268;
                goto LABEL_43;
              case 0xAu:
                int v20 = 7209052;
                goto LABEL_43;
              case 0xBu:
                int v20 = 7733340;
                goto LABEL_43;
              case 0xCu:
                int v20 = 6684764;
                goto LABEL_43;
              case 0xDu:
                int v20 = 7471196;
LABEL_43:
                *(_DWORD *)chars  = v20;
LABEL_44:
                id v14 = Mutable;
                CFIndex v15 = 2;
                goto LABEL_45;
              default:
                if (v10 < 0x20u || v10 == 127) {
                  goto LABEL_11;
                }
                CFStringAppendFormat(Mutable, 0, @"\\u%04X", v10);
                continue;
            }
          }
          int64_t v18 = v37;
          if (v37 > v16)
          {
            if (CharactersPtr)
            {
              UniChar v19 = CharactersPtr[v36 + v16];
            }
            else if (v35)
            {
              UniChar v19 = *(char *)(v35 + v36 + v16);
            }
            else
            {
              if (v39 <= v16 || (int64_t v21 = v38, v38 > v16))
              {
                int64_t v22 = i - 3;
                if ((unint64_t)v16 < 4) {
                  int64_t v22 = 0;
                }
                if (v22 + 64 < v37) {
                  int64_t v18 = v22 + 64;
                }
                int64_t v38 = v22;
                int64_t v39 = v18;
                v42.CFIndex location = v36 + v22;
                v42.uint64_t length = v18 - v22;
                CFStringGetCharacters(v33, v42, buffer);
                int64_t v21 = v38;
              }
              UniChar v19 = buffer[v16 - v21];
            }
            if (v19 >> 10 == 55)
            {
              CFStringAppendFormat(Mutable, 0, @"\\U%08X", (v11 << 10) + v19 - 56613888);
              ++i;
            }
          }
        }
        else
        {
          chars[0]  = v10;
          id v14 = Mutable;
          CFIndex v15 = 1;
LABEL_45:
          CFStringAppendCharacters(v14, chars, v15);
        }
      }
    }
  }

  return Mutable;
}

int64_t TCharStream::GetRangeOfParagraphSeparatorAtIndex(TCharStream *this, int64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  memset(&v11, 0, sizeof(v11));
  v11.magic  = 878368812;
  v11.sizeOfStruct  = 144;
  if ((**(uint64_t (***)(TCharStream *, UText *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))this)(this, &v11, a3, a4, a5, a6, a7, a8))
  {
    UChar32 v9 = utext_char32At(&v11, a2);
    if (v9 != 8233)
    {
      if (v9 == 13)
      {
        utext_next32(&v11);
      }
      else if (v9 == 10)
      {
        a2 -= utext_previous32(&v11) == 13;
      }
    }
    utext_close(&v11);
  }
  return a2;
}

BOOL TCharStream::IsParagraphSeparator(TCharStream *this, uint64_t a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v2 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v2 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  v11[2]  = v2;
  v11[3]  = v2;
  v11[0]  = v2;
  v11[1]  = v2;
  memset(v10, 0, sizeof(v10));
  int64_t v12 = v11;
  unsigned int v3 = (unsigned __int16 *)(*(uint64_t (**)(TCharStream *, uint64_t, uint64_t, void *))(*(void *)this + 72))(this, a2, 1, v10);
  BOOL v7 = 0;
  if (v3)
  {
    int v4 = *v3;
    BOOL v5 = v4 == 10 || v4 == 13;
    if (v5 || v4 == 8233) {
      BOOL v7 = 1;
    }
  }
  UChar32 v9 = (void **)v10;
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100](&v9);
  return v7;
}

uint64_t TCharStream::LazyCopy(uint64_t a1, uint64_t a2, unint64_t a3, void *a4)
{
  return *a4;
}

void TCharStreamUTF16::~TCharStreamUTF16(TCharStreamUTF16 *this)
{
}

UText *TCharStreamUTF16::OpenUText(TCharStreamUTF16 *this, UText *ut)
{
  status  = U_ZERO_ERROR;
  CFStringRef result = utext_openUChars(ut, *((const UChar **)this + 3), *((void *)this + 2), &status);
  if (status > U_ZERO_ERROR) {
    return 0;
  }
  return result;
}

CFStringRef TCharStreamUTF16::CopyChars@<X0>(TCharStreamUTF16 *this@<X0>, CFStringRef *a2@<X8>)
{
  CFStringRef result = CFStringCreateWithCharactersNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *((const UniChar **)this + 3), *((void *)this + 2), (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
  *a2  = result;
  return result;
}

CFStringRef TCharStreamUTF16::CopyChars@<X0>(TCharStreamUTF16 *this@<X0>, CFRange a2@<0:X1, 8:X2>, CFStringRef *a3@<X8>)
{
  CFStringRef result = CFStringCreateWithCharactersNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UniChar *)(*((void *)this + 3) + 2 * a2.location), a2.length, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
  *a3  = result;
  return result;
}

void *TCharStreamUTF16::CopyChars(void *this, CFRange a2, unsigned __int16 *__dst)
{
  if (a2.length) {
    return memmove(__dst, (const void *)(this[3] + 2 * a2.location), 2 * a2.length);
  }
  return this;
}

uint64_t TCharStreamUTF16::GetClusterRangeAtIndex(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v7 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr))(*(void *)a1 + 8))(&v7);
  RangeOfCharacterClusterAtIndeCGFloat x = TCharStream::GetRangeOfCharacterClusterAtIndex((const __CFString *)atomic_load_explicit((atomic_ullong *volatile)&v7, memory_order_acquire), a2, a3);

  return RangeOfCharacterClusterAtIndex;
}

uint64_t TCharStreamUTF16::GetSegment(TCharStreamUTF16 *this, uint64_t a2, uint64_t *a3)
{
  return 0;
}

uint64_t TCharStream::GetCharacterAtIndex(const UniChar *this, CFStringInlineBuffer *a2, CFIndex a3)
{
  if (a2->bufferedRangeStart > a3 || a2->bufferedRangeEnd <= a3) {
    TCharStream::SetIndex(this, a2, a3);
  }
  directUniCharBuffer  = a2->directUniCharBuffer;
  if (directUniCharBuffer) {
    return directUniCharBuffer[a3 - a2->bufferedRangeStart];
  }
  else {
    return 0;
  }
}

const UniChar *TCharStream::SetIndex(const UniChar *this, CFStringInlineBuffer *a2, CFIndex a3)
{
  BOOL v5 = this;
  a2->bufferedRangeStart  = a3;
  uint64_t v6 = *((void *)this + 3);
  if (v6)
  {
    uint64_t v7 = *((void *)this + 1);
    uint64_t v8 = *((void *)this + 2);
    a2->directUniCharBuffer  = (const UniChar *)(v6 + 2 * a3);
    CFIndex v9 = v8 + v7;
LABEL_5:
    a2->bufferedRangeEnd  = v9;
    return this;
  }
  unint64_t v13 = 0xAAAAAAAAAAAAAAAALL;
  this  = (const UniChar *)(*(uint64_t (**)(const UniChar *, CFIndex, unint64_t *))(*(void *)this
                                                                                                  + 64))(this, a3, &v13);
  a2->directUniCharBuffer  = this;
  if (this)
  {
    CFIndex v9 = v13 + a3;
    goto LABEL_5;
  }
  uint64_t v10 = *((void *)v5 + 1) - a3 + *((void *)v5 + 2);
  if (v10 >= 64) {
    uint64_t v11 = 64;
  }
  else {
    uint64_t v11 = *((void *)v5 + 1) - a3 + *((void *)v5 + 2);
  }
  unint64_t v13 = v11;
  if (v10 < 1)
  {
    int64_t v12 = 0;
  }
  else
  {
    this  = (const UniChar *)(*(uint64_t (**)(const UniChar *, CFIndex))(*(void *)v5 + 24))(v5, a3);
    int64_t v12 = a2;
  }
  a2->directUniCharBuffer  = (const UniChar *)v12;
  return this;
}

void TCharStream::CopyAttributedString(void *a1@<X8>)
{
  *a1  = 0;
}

CFStringRef TCharStreamCFString::CopyChars@<X0>(atomic_ullong *this@<X0>, CFStringRef *a2@<X8>)
{
  CFStringRef explicit = (const __CFString *)atomic_load_explicit(this + 4, memory_order_acquire);
  CFStringRef result = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], explicit);
  *a2  = result;
  return result;
}

void TCharStreamCFString::CopyChars(atomic_ullong *this, CFRange a2, unsigned __int16 *a3)
{
}

CFAttributedStringRef TCharStreamCFString::CopyAttributedString@<X0>(atomic_ullong *this@<X0>, CFAttributedStringRef *a2@<X8>)
{
  CFAttributedStringRef result = CFAttributedStringCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFStringRef)atomic_load_explicit(this + 4, memory_order_acquire), (CFDictionaryRef)atomic_load_explicit(this + 5, memory_order_acquire));
  *a2  = result;
  return result;
}

uint64_t TCharStreamCFString::GetSegment(TCharStreamCFString *this, uint64_t a2, uint64_t *a3)
{
  uint64_t result = *((void *)this + 3);
  if (result) {
    *a3  = *((void *)this + 2) - a2;
  }
  return result;
}

id TCharStreamCFAttrString::CopyAttributedString@<X0>(atomic_ullong *this@<X0>, void *a2@<X8>)
{
  id result = (id)atomic_load_explicit(this + 6, memory_order_acquire);
  *a2  = result;
  return result;
}

uint64_t TCharStreamCopyCallback::OpenUText(TCharStreamCopyCallback *this, UText *a2)
{
  return 0;
}

CFStringRef TCharStreamCopyCallback::CopyChars@<X0>(atomic_ullong *this@<X0>, CFRange a2@<0:X1, 8:X2>, CFStringRef *a3@<X8>)
{
  CFIndex length = a2.length;
  CFIndex location = a2.location;
  uint64_t v7 = this + 4;
  if (!atomic_load_explicit(this + 4, memory_order_acquire)) {
    TCharStreamCopyCallback::FetchString((TCharStreamCopyCallback *)this);
  }
  v9.CFIndex location = location - this[1];
  v9.CFIndex length = length;
  CFStringRef result = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFStringRef)atomic_load_explicit(v7, memory_order_acquire), v9);
  *a3  = result;
  return result;
}

CFStringRef TCharStreamCopyCallback::CopyChars@<X0>(atomic_ullong *this@<X0>, CFStringRef *a2@<X8>)
{
  CFStringRef explicit = (const __CFString *)atomic_load_explicit(this + 4, memory_order_acquire);
  CFStringRef result = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], explicit);
  *a2  = result;
  return result;
}

void TCharStreamCopyCallback::CopyChars(atomic_ullong *this, CFRange a2, UniChar *buffer)
{
  CFIndex length = a2.length;
  CFIndex location = a2.location;
  uint64_t v7 = this + 4;
  if (!atomic_load_explicit(this + 4, memory_order_acquire)) {
    TCharStreamCopyCallback::FetchString((TCharStreamCopyCallback *)this);
  }
  v9.CFIndex location = location - this[1];
  CFStringRef explicit = (const __CFString *)atomic_load_explicit(v7, memory_order_acquire);
  v9.CFIndex length = length;

  CFStringGetCharacters(explicit, v9, buffer);
}

uint64_t TCharStreamCopyCallback::GetClusterRangeAtIndex(atomic_ullong *this, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = this + 4;
  if (!atomic_load_explicit(this + 4, memory_order_acquire)) {
    TCharStreamCopyCallback::FetchString((TCharStreamCopyCallback *)this);
  }
  uint64_t v7 = a2 - this[1];
  CFStringRef explicit = (const __CFString *)atomic_load_explicit(v6, memory_order_acquire);

  return TCharStream::GetRangeOfCharacterClusterAtIndex(explicit, v7, a3);
}

atomic_ullong TCharStreamCopyCallback::GetSegment(atomic_ullong *this, uint64_t a2, uint64_t *a3)
{
  if (!atomic_load_explicit(this + 4, memory_order_acquire)) {
    TCharStreamCopyCallback::FetchString((TCharStreamCopyCallback *)this);
  }
  atomic_ullong v6 = a2 - this[1];
  atomic_ullong v7 = this[7];
  if (v7)
  {
    *a3  = this[2] - v6;
    return v7 + 2 * v6;
  }
  else
  {
    atomic_ullong result = this[3];
    if (result) {
      *a3  = this[2] - v6;
    }
  }
  return result;
}

atomic_ullong TCharStreamCopyCallback::LazyCopy(atomic_ullong *this, uint64_t a2, unint64_t a3, void *a4)
{
  if (!atomic_load_explicit(this + 4, memory_order_acquire)) {
    TCharStreamCopyCallback::FetchString((TCharStreamCopyCallback *)this);
  }
  atomic_ullong v8 = a2 - this[1];
  atomic_ullong v9 = this[7];
  if (v9) {
    return v9 + 2 * v8;
  }
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::resize((uint64_t)a4, a3);
  (*(void (**)(atomic_ullong *, atomic_ullong, unint64_t, void))(*this + 24))(this, v8, a3, *a4);
  return *a4;
}

void TCharStreamCopyCallback::FetchString(TCharStreamCopyCallback *this)
{
  id v3 = (id)(*((uint64_t (**)(void, void, void))this + 6))(*((void *)this + 1), *((void *)this + 2), *((void *)this + 8));
  TCharStreamCFString::SetString(this, (atomic_ullong *)&v3);
  *((void *)this + 7)  = *((void *)this + 3);
  *((void *)this + 3)  = 0;
  id v2 = v3;
}

void TCharStreamCopyCallback::~TCharStreamCopyCallback(id *this)
{
  *this  = &unk_1ED05E8F8;
  unint64_t v1 = this + 4;
}

{
  id *v1;
  uint64_t vars8;

  *this  = &unk_1ED05E8F8;
  unint64_t v1 = this + 4;

  JUMPOUT(0x1853275C0);
}

void TCharStreamUniChar::TCharStreamUniChar(TCharStreamUniChar *this, const unsigned __int16 *(*a2)(uint64_t, uint64_t *, const __CFDictionary **, void *), void (*a3)(const unsigned __int16 *, void *), void *a4)
{
  *((void *)this + 6)  = 0;
  atomic_ullong v6 = (char **)((char *)this + 48);
  *(void *)this  = &unk_1ED05E7D8;
  *((void *)this + 1)  = 0;
  long long v32 = (char *)this + 72;
  *((void *)this + 18)  = (char *)this + 72;
  atomic_ullong v7 = (unint64_t *)((char *)this + 144);
  *((void *)this + 4)  = a4;
  *((void *)this + 5)  = a3;
  *((void *)this + 7)  = 0;
  *((void *)this + 8)  = 0;
  unint64_t v33 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v34 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v8 = ((uint64_t (*)(void, unint64_t *, unint64_t *))a2)(0, &v34, &v33);
  if (v8)
  {
    uint64_t v9 = v8;
    uint64_t v10 = 0;
    uint64_t v11 = v8;
    while (1)
    {
      int64_t v12 = (unint64_t *)*((void *)this + 7);
      unint64_t v13 = *((void *)this + 8);
      if ((unint64_t)v12 >= v13)
      {
        unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * (((char *)v12 - *v6) >> 3);
        unint64_t v17 = v16 + 1;
        if (v16 + 1 > 0xAAAAAAAAAAAAAAALL) {
          abort();
        }
        unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - (void)*v6) >> 3);
        if (2 * v18 > v17) {
          unint64_t v17 = 2 * v18;
        }
        unint64_t v19 = v18 >= 0x555555555555555 ? 0xAAAAAAAAAAAAAAALL : v17;
        int v20 = (char *)*v7;
        unint64_t v21 = *v7 + 24 * v19;
        if (v21 <= (unint64_t)v7)
        {
          unint64_t *v7 = v21;
        }
        else
        {
          if (v19 > 0xAAAAAAAAAAAAAAALL) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          int v20 = (char *)operator new(24 * v19);
        }
        int64_t v22 = (unint64_t *)&v20[24 * v16];
        unint64_t v23 = v33;
        *int64_t v22 = v34;
        v22[1]  = v9;
        v22[2]  = v23;
        uint64_t v25 = (char *)*((void *)this + 6);
        uint64_t v24 = (char *)*((void *)this + 7);
        long long v26 = v22;
        if (v24 != v25)
        {
          do
          {
            long long v27 = *(_OWORD *)(v24 - 24);
            *(v26 - 1)  = *((void *)v24 - 1);
            *(_OWORD *)(v26 - 3)  = v27;
            v26 -= 3;
            v24 -= 24;
          }
          while (v24 != v25);
          uint64_t v24 = *v6;
        }
        CFIndex v15 = v22 + 3;
        *((void *)this + 6)  = v26;
        *((void *)this + 7)  = v22 + 3;
        uint64_t v28 = *((void *)this + 8);
        *((void *)this + 8)  = &v20[24 * v19];
        if (v24)
        {
          if (v32 <= v24 && v7 > (unint64_t *)v24)
          {
            if (v28 == *v7) {
              unint64_t *v7 = (unint64_t)v24;
            }
          }
          else
          {
            operator delete(v24);
          }
        }
      }
      else
      {
        unint64_t v14 = v33;
        unint64_t *v12 = v34;
        v12[1]  = v9;
        v12[2]  = v14;
        CFIndex v15 = v12 + 3;
      }
      *((void *)this + 7)  = v15;
      v10 += v34;
      long long v30 = a2(v10, (uint64_t *)&v34, (const __CFDictionary **)&v33, *((void **)this + 4));
      if (!v30) {
        break;
      }
      uint64_t v9 = (uint64_t)v30;
      if ((const unsigned __int16 *)(v11 + 2 * v10) == v30) {
        uint64_t v31 = v11;
      }
      else {
        uint64_t v31 = 0;
      }
      if (v11) {
        uint64_t v11 = v31;
      }
      else {
        uint64_t v11 = 0;
      }
    }
    *((void *)this + 2)  = v10;
    *((void *)this + 3)  = v11;
  }
  else
  {
    *((void *)this + 2)  = 0;
    *((void *)this + 3)  = 0;
  }
}

void TCharStreamUniChar::~TCharStreamUniChar(TCharStreamUniChar *this)
{
  *(void *)this  = &unk_1ED05E7D8;
  if (*((void *)this + 5))
  {
    uint64_t v2 = *((void *)this + 7) - *((void *)this + 6);
    if (v2)
    {
      unint64_t v3 = v2 / 24;
      if (v3 <= 1) {
        uint64_t v4 = 1;
      }
      else {
        uint64_t v4 = v3;
      }
      uint64_t v5 = 8;
      do
      {
        (*((void (**)(void, void))this + 5))(*(void *)(*((void *)this + 6) + v5), *((void *)this + 4));
        v5 += 24;
        --v4;
      }
      while (v4);
    }
  }
  atomic_ullong v6 = (char *)*((void *)this + 6);
  if (v6)
  {
    *((void *)this + 7)  = v6;
    atomic_ullong v7 = (char *)this + 144;
    if ((char *)this + 72 <= v6 && v7 > v6)
    {
      if (*((void *)this + 8) == *((void *)this + 18)) {
        *(void *)atomic_ullong v7 = v6;
      }
    }
    else
    {
      operator delete(v6);
    }
  }
}

{
  uint64_t vars8;

  TCharStreamUniChar::~TCharStreamUniChar(this);

  JUMPOUT(0x1853275C0);
}

UText *TCharStreamUniChar::OpenUText(TCharStreamUniChar *this, UText *ut)
{
  status  = U_ZERO_ERROR;
  atomic_ullong result = utext_setup(ut, 0, &status);
  if (status > U_ZERO_ERROR) {
    return 0;
  }
  result->providerProperties  = 0;
  result->context  = this;
  result->pFuncs  = (const UTextFuncs *)&TCharStreamUniChar::GetUTextFuncs(void)::funcs;
  return result;
}

UText *TCharStreamUniChar::UTextClone(UText *this, UText *a2, const UText *a3, UErrorCode *status, UErrorCode *a5)
{
  if (*(int *)status > 0) {
    return 0;
  }
  if (a3)
  {
    atomic_ullong result = 0;
    *status  = U_UNSUPPORTED_ERROR;
  }
  else
  {
    atomic_ullong result = utext_setup(this, 0, status);
    if (*(int *)status <= 0)
    {
      result->chunkNativeStart  = a2->chunkNativeStart;
      chunkNativeStart  = a2->chunkNativeStart;
      result->chunkNativeLimit  = chunkNativeStart;
      result->nativeIndexingLimit  = chunkNativeStart;
      result->chunkOffset  = 0;
      result->providerProperties  = a2->providerProperties;
      result->context  = a2->context;
      result->pFuncs  = (const UTextFuncs *)&TCharStreamUniChar::GetUTextFuncs(void)::funcs;
    }
  }
  return result;
}

uint64_t TCharStreamUniChar::UTextLength(TCharStreamUniChar *this, UText *a2)
{
  return *(void *)(*((void *)this + 9) + 16);
}

uint64_t TCharStreamUniChar::UTextAccess(TCharStreamUniChar *this, UText *a2, int a3)
{
  uint64_t v5 = (TCharStreamUniChar *)*((void *)this + 9);
  uint64_t v6 = *((void *)v5 + 2);
  if (v6 >= (uint64_t)a2) {
    atomic_ullong v7 = a2;
  }
  else {
    atomic_ullong v7 = (UText *)*((void *)v5 + 2);
  }
  if ((uint64_t)a2 >= 0) {
    uint64_t v8 = (uint64_t)v7;
  }
  else {
    uint64_t v8 = 0;
  }
  uint64_t v9 = *((void *)this + 2);
  if (a3)
  {
    if (v8 >= v9 || (uint64_t v10 = *((void *)this + 4), v8 < v10))
    {
      if (v9 == v6 && v8 >= v6)
      {
        uint64_t result = 0;
        *((_DWORD *)this + 10)  = *((_DWORD *)this + 11);
        return result;
      }
      goto LABEL_20;
    }
    int v14 = v8 - v10;
LABEL_26:
    *((_DWORD *)this + 10)  = v14;
    return 1;
  }
  if (v8 <= v9)
  {
    uint64_t v13 = *((void *)this + 4);
    if (v8 > v13)
    {
      int v14 = v8 - v13;
      goto LABEL_26;
    }
  }
  if (!v8 && !*((void *)this + 4))
  {
    uint64_t result = 0;
    *((_DWORD *)this + 10)  = 0;
    return result;
  }
LABEL_20:
  uint64_t result = *((void *)this + 10);
  if (result
    || (uint64_t result = (uint64_t)malloc_type_malloc(0x40uLL, 0x1000040BDFB0063uLL), (*((void *)this + 10) = result) != 0))
  {
    *((void *)this + 6)  = result;
    if (a3)
    {
      *((void *)this + 4)  = v8;
      *((void *)this + 2)  = v8 + 32;
      if (v8 + 32 <= v6)
      {
        if (v8 + 32 < v6)
        {
          uint64_t v6 = TCharStreamUniChar::PinUTextIndex(v5, v8 + 32, v6, a3);
          *((void *)this + 2)  = v6;
          uint64_t v8 = *((void *)this + 4);
        }
        else
        {
          LODWORD(v6)  = v8 + 32;
        }
      }
      else
      {
        *((void *)this + 2)  = v6;
      }
      int v16 = 0;
      int v17 = v6 - v8;
      int v18 = v6 - v8;
    }
    else
    {
      if (v8 >= v6) {
        uint64_t v15 = v6;
      }
      else {
        uint64_t v15 = v8;
      }
      *((void *)this + 2)  = v15;
      *((void *)this + 4)  = v15 - 32;
      if (v15 - 32 < 0)
      {
        uint64_t v8 = 0;
        *((void *)this + 4)  = 0;
      }
      else if (v15 == 32)
      {
        uint64_t v8 = 0;
        LODWORD(v15)  = 32;
      }
      else
      {
        uint64_t v8 = TCharStreamUniChar::PinUTextIndex(v5, v15 - 32, v6, 0);
        *((void *)this + 4)  = v8;
        uint64_t v15 = *((void *)this + 2);
      }
      int v16 = v15 - v8;
      int v17 = v16;
      int v18 = v16;
    }
    *((_DWORD *)this + 10)  = v16;
    *((_DWORD *)this + 11)  = v17;
    (*(void (**)(TCharStreamUniChar *, uint64_t, void, void))(*(void *)v5 + 24))(v5, v8, v18, *((void *)this + 6));
    *((_DWORD *)this + 7)  = *((_DWORD *)this + 11);
    return 1;
  }
  return result;
}

uint64_t TCharStreamUniChar::UTextExtract(TCharStreamUniChar *this, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int16 *a5, int *a6, UErrorCode *a7)
{
  if (*a6 > 0) {
    return 0;
  }
  unsigned int v9 = a5;
  if ((a5 & 0x80000000) != 0 || (v12 = (uint64_t *)*((void *)this + 9), uint64_t v13 = v12[2], !a4) && a5)
  {
    uint64_t v7 = 0;
    int v14 = 1;
LABEL_7:
    *a6  = v14;
    return v7;
  }
  if (a2 < 0 || a3 < a2 || a3 - a2 >= 0x80000000)
  {
    uint64_t v7 = 0;
    int v14 = 8;
    goto LABEL_7;
  }
  uint64_t v16 = TCharStreamUniChar::PinUTextIndex(*((TCharStreamUniChar **)this + 9), a2, v12[2], 1);
  uint64_t v7 = TCharStreamUniChar::PinUTextIndex((TCharStreamUniChar *)v12, a3, v13, 1) - v16;
  if (a4 && v9)
  {
    if ((int)v7 >= (int)v9) {
      int v17 = v9;
    }
    else {
      int v17 = v7;
    }
    (*(void (**)(uint64_t *, uint64_t, void, uint64_t))(*v12 + 24))(v12, v16, v17, a4);
    uint64_t v18 = v9;
    if (v7 < v9) {
      *(_WORD *)(a4 + 2 * v7)  = 0;
    }
  }
  else
  {
    uint64_t v18 = v9;
  }
  if (v7 >= v18)
  {
    if (v7 == v18) {
      int v14 = -124;
    }
    else {
      int v14 = 15;
    }
    goto LABEL_7;
  }
  return v7;
}

void TCharStreamUniChar::UTextClose(void **this, UText *a2)
{
  this[10]  = 0;
}

uint64_t TCharStreamUniChar::PinUTextIndex(TCharStreamUniChar *this, uint64_t a2, uint64_t a3, int a4)
{
  if (a2 < 0) {
    return 0;
  }
  uint64_t v4 = a2;
  if (a2 <= a3)
  {
    if (a2)
    {
      if (a2 < a3)
      {
        unint64_t v8 = 0xAAAAAAAAAAAAAAAALL;
        if ((*(_WORD *)(*(uint64_t (**)(TCharStreamUniChar *, uint64_t, unint64_t *))(*(void *)this + 64))(this, a2, &v8) & 0xFC00) == 0xDC00&& (*(_WORD *)(*(uint64_t (**)(TCharStreamUniChar *, uint64_t, unint64_t *))(*(void *)this + 64))(this, v4 - 1, &v8) & 0xFC00) == 0xD800)
        {
          if (a4) {
            --v4;
          }
          else {
            ++v4;
          }
        }
      }
    }
    return v4;
  }
  return a3;
}

uint64_t TCharStreamUniChar::GetSegment(TCharStreamUniChar *this, uint64_t a2, uint64_t *a3)
{
  uint64_t v3 = *((void *)this + 6);
  uint64_t v4 = *((void *)this + 7);
  uint64_t v5 = 0;
  uint64_t v6 = v4 - v3;
  if (v4 == v3)
  {
    uint64_t v7 = 0;
  }
  else
  {
    uint64_t v7 = 0;
    uint64_t v8 = v6 / 24;
    unsigned int v9 = (uint64_t *)*((void *)this + 6);
    while (1)
    {
      uint64_t v10 = *v9;
      v9 += 3;
      v7 += v10;
      if (v7 > a2) {
        break;
      }
      if (v8 == ++v5)
      {
        uint64_t v5 = v8;
        break;
      }
    }
  }
  *a3  = v7 - a2;
  return *(void *)(v3 + 24 * v5 + 8) + 2 * (a2 - v7 + *(void *)(v3 + 24 * v5));
}

uint64_t TCharStreamUniChar::CopyChars(TCharStreamUniChar *this)
{
  return (*(uint64_t (**)(TCharStreamUniChar *, void, void))(*(void *)this + 16))(this, 0, *((void *)this + 2));
}

CFStringRef TCharStreamUniChar::CopyChars@<X0>(TCharStreamUniChar *this@<X0>, CFRange a2@<0:X1, 8:X2>, CFStringRef *a3@<X8>)
{
  CFIndex length = a2.length;
  CFIndex location = a2.location;
  uint64_t v6 = *((void *)this + 3);
  if (v6)
  {
    CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    a2.CFIndex location = v6 + 2 * a2.location;
    CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CFA0];
  }
  else
  {
    CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF90];
    uint64_t v11 = CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E4F1CF90], 2 * a2.length, 0);
    (*(void (**)(TCharStreamUniChar *, CFIndex, CFIndex, void *))(*(void *)this + 24))(this, location, length, v11);
    CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    a2.CFIndex location = (CFIndex)v11;
    a2.CFIndex length = length;
    CFAllocatorRef v8 = v10;
  }
  CFStringRef result = CFStringCreateWithCharactersNoCopy(v7, (const UniChar *)a2.location, a2.length, v8);
  *a3  = result;
  return result;
}

void *TCharStreamUniChar::CopyChars(void *this, CFRange a2, unsigned __int16 *__dst)
{
  CFIndex length = a2.length;
  uint64_t v5 = this[3];
  if (v5)
  {
    if (a2.length)
    {
      a2.CFIndex location = v5 + 2 * a2.location;
      a2.length *= 2;
      return memmove(__dst, (const void *)a2.location, a2.length);
    }
  }
  else
  {
    CFAllocatorRef v7 = this;
    uint64_t v8 = this[6];
    uint64_t v9 = this[7];
    uint64_t v10 = 0;
    uint64_t v11 = v9 - v8;
    if (v9 == v8)
    {
      CFIndex v12 = 0;
    }
    else
    {
      CFIndex v12 = 0;
      uint64_t v13 = v11 / 24;
      int v14 = (uint64_t *)this[6];
      while (1)
      {
        uint64_t v15 = *v14;
        v14 += 3;
        v12 += v15;
        if (v12 > a2.location) {
          break;
        }
        if (v13 == ++v10)
        {
          uint64_t v10 = v13;
          break;
        }
      }
    }
    if (v12 - a2.location >= a2.length) {
      CFIndex v16 = a2.length;
    }
    else {
      CFIndex v16 = v12 - a2.location;
    }
    if (v16) {
      this  = memmove(__dst, (const void *)(*(void *)(v8 + 24 * v10 + 8) + 2 * (a2.location - v12 + *(void *)(v8 + 24 * v10))), 2 * v16);
    }
    uint64_t v17 = length - v16;
    if (v17 >= 1)
    {
      uint64_t v18 = &__dst[v16];
      uint64_t v19 = 24 * v10;
      do
      {
        uint64_t v20 = v7[6] + v19;
        if (*(void *)(v20 + 24) >= v17) {
          uint64_t v21 = v17;
        }
        else {
          uint64_t v21 = *(void *)(v20 + 24);
        }
        if (v21) {
          this  = memmove(v18, *(const void **)(v20 + 32), 2 * v21);
        }
        v18 += v21;
        v19 += 24;
        BOOL v22 = v17 <= v21;
        v17 -= v21;
      }
      while (!v22);
    }
  }
  return this;
}

uint64_t TCharStreamUniChar::GetClusterRangeAtIndex(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v7 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr))(*(void *)a1 + 8))(&v7);
  RangeOfCharacterClusterAtIndeCGFloat x = TCharStream::GetRangeOfCharacterClusterAtIndex((const __CFString *)atomic_load_explicit((atomic_ullong *volatile)&v7, memory_order_acquire), a2, a3);

  return RangeOfCharacterClusterAtIndex;
}

void TDecorator::DrawDecoration(TDecorator *this, const TLineDrawContext *a2, __n128 *a3, CFRange a4, CGPoint a5)
{
  CFIndex location = a4.location;
  uint64_t v65 = *MEMORY[0x1E4F143B8];
  double v9 = *((double *)a2 + 10);
  int v62 = 0;
  double v60 = 0.0;
  id v61 = 0;
  CGFloat v58 = 0.0;
  double v59 = 0.0;
  CGFloat v57 = 0.0;
  BOOL v56 = 0;
  if (GetDecorationAttributes((atomic_ullong *)a3, a4.location, (const __CFString **)a4.length, (TAttributes *)&a3[2].n128_i8[8], *(_DWORD *)this, &v62, &v61, &v60, v9, a5.y, &v59, &v58, &v57, &v56))
  {
    TRun::GetPositions(a3, 0);
    double v11 = *(double *)(v10 + 16 * location);
    v47[0]  = (id)0xAAAAAAAAAAAAAAAALL;
    uint64_t v48 = unk_184BA6280;
    width[1]  = NAN;
    v47[1]  = 0;
    LOBYTE(v48)  = 0;
    v51[1]  = -1431655766;
    v51[0]  = 0;
    double v49 = 0.0;
    width[0]  = 0.0;
    double v52 = v11;
    double v53 = v59;
    uint64_t v54 = 0;
    uint64_t v55 = 0;
    LODWORD(v47[0])  = *(_DWORD *)this;
    TCFRef<__CTFont const*>::Retain((atomic_ullong *)&v47[1], v61);
    v51[0]  = v62;
    width[0]  = v58;
    width[1]  = v57;
    LOBYTE(v48)  = v56;
    double v49 = v60;
    if (*(_DWORD *)a2)
    {
LABEL_13:

      return;
    }
    CFIndex v12 = (CGContext *)*((void *)a2 + 1);
    CGContextSaveGState(v12);
    TAttributes::SetStrokeColor(v12, (void *)atomic_load_explicit((atomic_ullong *volatile)&v47[1], memory_order_acquire), v13);
    char v14 = v51[0];
    *(void *)&long long v15 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v15 + 1)  = 0xAAAAAAAAAAAAAAAALL;
    v64[3]  = v15;
    v64[4]  = v15;
    v64[1]  = v15;
    v64[2]  = v15;
    v64[0]  = v15;
    TDecorator::dashes((TDecorator *)v64, v51[0], width[0] / (double)(v51[0] & 7));
    CGContextSetLineWidth(v12, width[0]);
    *(void *)&long long v16 = -1;
    *((void *)&v16 + 1)  = -1;
    *(_OWORD *)&v63.c  = v16;
    *(_OWORD *)&v63.tCGFloat x = v16;
    *(_OWORD *)&v63.a  = v16;
    CGContextGetTextMatrix(&v63, v12);
    tCGFloat x = v63.tx;
    tdouble y = v63.ty;
    _V0.D[1]  = v63.b;
    double v20 = *MEMORY[0x1E4F1DAD8];
    double v21 = *(double *)(MEMORY[0x1E4F1DAD8] + 8);
    v63.tCGFloat x = *(CGFloat *)MEMORY[0x1E4F1DAD8];
    v63.tdouble y = v21;
    float64x2_t v22 = (float64x2_t)vdupq_n_s64(0x3CB0000000000000uLL);
    int64x2_t v23 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f64(v22, (float64x2_t)vandq_s8(*(int8x16_t *)&v63.tx, (int8x16_t)vdupq_n_s64(0x7FFFFFFFFFFFFFFFuLL))), (int8x16_t)vcgeq_f64(v22, vabsq_f64(vaddq_f64(*(float64x2_t *)&v63.a, (float64x2_t)xmmword_184B88D30)))), (int8x16_t)vcgeq_f64(v22, vabsq_f64(vaddq_f64(*(float64x2_t *)&v63.c, (float64x2_t)xmmword_184B88D40))));
    unint64_t v24 = vandq_s8((int8x16_t)vdupq_laneq_s64(v23, 1), (int8x16_t)v23).u64[0];
    _D2  = v52;
    double v26 = v53;
    double v27 = ceil(v49);
    if ((v14 & 8) != 0)
    {
      double v36 = v53 - width[1];
      _D4  = v27 + v52;
      if ((v24 & 0x8000000000000000) != 0)
      {
        double v39 = v53 - width[1];
      }
      else
      {
        __asm { FMLA            D3, D2, V0.D[1] }
        _D2  = v20 + vmlad_n_f64(v63.c * v36, v52, v63.a);
        double v39 = v21 + _D3;
        double v40 = vmlad_n_f64(v63.c * v36, _D4, v63.a);
        __asm { FMLA            D5, D4, V0.D[1] }
        _D4  = v20 + v40;
        double v36 = v21 + _D5;
      }
      TDecorationRun::DrawLine<TRun const*>((uint64_t)v47, v12, a3, a3 + 20, *(const CGFloat **)&v64[0], (const double *)((uint64_t)(*((void *)&v64[0] + 1) - *(void *)&v64[0]) >> 3), tx, ty, _D2, v39, _D4, v36);
      _D2  = v52;
      double v26 = v53 + width[1];
      _D4  = v27 + v52;
      if ((v24 & 0x8000000000000000) == 0)
      {
        double v42 = v26 * v63.c;
        double v43 = v26 * v63.c + v63.a * v52;
        double v44 = v26 * v63.d;
        CGFloat v45 = v63.tx + v43;
        double v34 = v63.ty + v44 + v63.b * v52;
        double v46 = v44 + v63.b * _D4;
        _D4  = v63.tx + v42 + v63.a * _D4;
        double v26 = v63.ty + v46;
        _D2  = v45;
        goto LABEL_12;
      }
    }
    else
    {
      _D4  = v27 + v52;
      if ((v24 & 0x8000000000000000) == 0)
      {
        __asm { FMLA            D3, D2, V0.D[1] }
        _D2  = v20 + vmlad_n_f64(v63.c * v53, v52, v63.a);
        double v34 = v21 + _D3;
        __asm { FMLA            D5, D4, V0.D[1] }
        _D4  = v20 + vmlad_n_f64(v63.c * v53, _D4, v63.a);
        double v26 = v21 + _D5;
LABEL_12:
        TDecorationRun::DrawLine<TRun const*>((uint64_t)v47, v12, a3, a3 + 20, *(const CGFloat **)&v64[0], (const double *)((uint64_t)(*((void *)&v64[0] + 1) - *(void *)&v64[0]) >> 3), tx, ty, _D2, v34, _D4, v26);
        std::vector<double,TInlineBufferAllocator<double,6ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)v64);
        CGContextRestoreGState(v12);
        goto LABEL_13;
      }
    }
    double v34 = v26;
    goto LABEL_12;
  }
}

unsigned int *CTLineDecorationGetType(unsigned int *result)
{
  if (result) {
    return (unsigned int *)*result;
  }
  return result;
}

int *CTLineDecorationGetSegment(int *result)
{
  if (result)
  {
    int v1 = *result;
    result += 2;
    if (v1) {
      return 0;
    }
  }
  return result;
}

uint64_t CTLineDecorationGetSegmentColor(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result) {
      return 0;
    }
    else {
      return *(void *)(result + 96);
    }
  }
  return result;
}

int *CTLineDecorationGetFragment(int *result)
{
  if (result)
  {
    int v1 = *result;
    result += 2;
    if (v1 != 1) {
      return 0;
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,anonymous namespace'::PathObserver::Intersection *>(uint64_t a1, long long *a2)
{
  uint64_t v4 = ((uint64_t)a2 - a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v6 = a2 - 1;
      {
        uint64_t v7 = *(void *)a1;
        uint64_t v8 = *(void *)(a1 + 8);
        *(_OWORD *)a1  = *v6;
        *((void *)a2 - 2)  = v7;
        *((void *)a2 - 1)  = v8;
      }
      return 1;
    case 3:
      return 1;
    case 4:
      return 1;
    case 5:
      long long v16 = (long long *)(a1 + 16);
      uint64_t v17 = (long long *)(a1 + 32);
      uint64_t v18 = (long long *)(a1 + 48);
      uint64_t v19 = a2 - 1;
      {
        uint64_t v20 = *(void *)(a1 + 48);
        uint64_t v21 = *(void *)(a1 + 56);
        *uint64_t v18 = *v19;
        *((void *)a2 - 2)  = v20;
        *((void *)a2 - 1)  = v21;
        {
          uint64_t v22 = *(void *)(a1 + 32);
          uint64_t v23 = *(void *)(a1 + 40);
          *uint64_t v17 = *v18;
          *(void *)(a1 + 48)  = v22;
          *(void *)(a1 + 56)  = v23;
          {
            uint64_t v24 = *(void *)(a1 + 16);
            uint64_t v25 = *(void *)(a1 + 24);
            *long long v16 = *v17;
            *(void *)(a1 + 32)  = v24;
            *(void *)(a1 + 40)  = v25;
            {
              uint64_t v26 = *(void *)a1;
              uint64_t v27 = *(void *)(a1 + 8);
              *(_OWORD *)a1  = *v16;
              *(void *)(a1 + 16)  = v26;
              *(void *)(a1 + 24)  = v27;
            }
          }
        }
      }
      return 1;
    default:
      uint64_t v9 = a1 + 32;
      uint64_t v10 = (long long *)(a1 + 48);
      if ((long long *)(a1 + 48) == a2) {
        return 1;
      }
      uint64_t v11 = 0;
      int v12 = 0;
      break;
  }
  while (1)
  {
    {
      long long v28 = *v10;
      uint64_t v13 = v11;
      while (1)
      {
        uint64_t v14 = a1 + v13;
        *(_OWORD *)(a1 + v13 + 48)  = *(_OWORD *)(a1 + v13 + 32);
        if (v13 == -32) {
          break;
        }
        v13 -= 16;
        {
          long long v15 = (_OWORD *)(a1 + v13 + 48);
          goto LABEL_13;
        }
      }
      long long v15 = (_OWORD *)a1;
LABEL_13:
      *long long v15 = v28;
      if (++v12 == 8) {
        return v10 + 1 == a2;
      }
    }
    uint64_t v9 = (uint64_t)v10;
    v11 += 16;
    if (++v10 == a2) {
      return 1;
    }
  }
}

char *std::vector<DecorationOverride,TInlineBufferAllocator<DecorationOverride,30ul>>::__emplace_back_slow_path<long &,CFRange>(char **a1, void *a2, long long *a3)
{
  uint64_t v3 = *a1;
  uint64_t v4 = (a1[1] - *a1) >> 5;
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 59) {
    abort();
  }
  uint64_t v9 = (uint64_t)(a1 + 3);
  uint64_t v10 = a1[2] - v3;
  if (v10 >> 4 > v5) {
    unint64_t v5 = v10 >> 4;
  }
  if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFE0) {
    unint64_t v11 = 0x7FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v11 = v5;
  }
  uint64_t v26 = v9;
  if (v11) {
    int v12 = TInlineBufferAllocator<DecorationOverride,30ul>::allocate(v9, v11);
  }
  else {
    int v12 = 0;
  }
  uint64_t v13 = &v12[32 * v4];
  uint64_t v23 = v12;
  v24.i64[0]  = (uint64_t)v13;
  uint64_t v14 = &v12[32 * v11];
  uint64_t v25 = v14;
  long long v15 = *a3;
  *(void *)uint64_t v13 = *a2;
  *(_OWORD *)(v13 + 8)  = v15;
  *((void *)v13 + 3)  = 0;
  long long v16 = v13 + 32;
  v24.i64[1]  = (uint64_t)(v13 + 32);
  uint64_t v18 = *a1;
  unint64_t v17 = (unint64_t)a1[1];
  if ((char *)v17 == *a1)
  {
    int64x2_t v20 = vdupq_n_s64(v17);
  }
  else
  {
    do
    {
      long long v19 = *(_OWORD *)(v17 - 32);
      *((void *)v13 - 2)  = *(void *)(v17 - 16);
      *((_OWORD *)v13 - 2)  = v19;
      *((void *)v13 - 1)  = atomic_exchange((atomic_ullong *volatile)(v17 - 8), 0);
      v13 -= 32;
      v17 -= 32;
    }
    while ((char *)v17 != v18);
    int64x2_t v20 = *(int64x2_t *)a1;
    long long v16 = (char *)v24.i64[1];
    uint64_t v14 = v25;
  }
  *a1  = v13;
  a1[1]  = v16;
  int64x2_t v24 = v20;
  uint64_t v21 = a1[2];
  a1[2]  = v14;
  uint64_t v25 = v21;
  uint64_t v23 = (char *)v20.i64[0];
  std::__split_buffer<DecorationOverride,TInlineBufferAllocator<DecorationOverride,30ul> &>::~__split_buffer((uint64_t)&v23);
  return v16;
}

void std::vector<double,TInlineBufferAllocator<double,6ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<double const*>,std::__wrap_iter<double const*>>(void **a1, char *__src, char *a3, unint64_t a4)
{
  uint64_t v6 = __src;
  uint64_t v8 = (uint64_t)a1[2];
  uint64_t v9 = (char *)*a1;
  unint64_t v10 = (v8 - (uint64_t)*a1) >> 3;
  if (v10 < a4)
  {
    if (v9)
    {
      a1[1]  = v9;
      unint64_t v11 = a1 + 9;
      if (a1 + 3 <= (void **)v9 && v11 > (void **)v9)
      {
        if (&v9[8 * v10] == *v11) {
          void *v11 = v9;
        }
      }
      else
      {
        operator delete(v9);
      }
      uint64_t v8 = 0;
      *a1  = 0;
      a1[1]  = 0;
      a1[2]  = 0;
    }
    uint64_t v19 = v8 >> 2;
    if (v8 >> 2 <= a4) {
      uint64_t v19 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v20 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v20 = v19;
    }
    if (v20 >> 61) {
      abort();
    }
    uint64_t v9 = (char *)a1[9];
    unint64_t v21 = (unint64_t)&v9[8 * v20];
    if (v21 <= (unint64_t)(a1 + 9)) {
      a1[9]  = (void *)v21;
    }
    else {
      uint64_t v9 = (char *)operator new(8 * v20);
    }
    *a1  = v9;
    a1[1]  = v9;
    a1[2]  = &v9[8 * v20];
    size_t v17 = a3 - v6;
    if (v17) {
      memmove(v9, v6, v17);
    }
    uint64_t v14 = a1 + 1;
    goto LABEL_31;
  }
  uint64_t v14 = a1 + 1;
  uint64_t v13 = (char *)a1[1];
  unint64_t v15 = (v13 - v9) >> 3;
  if (v15 >= a4)
  {
    size_t v17 = a3 - __src;
    if (a3 == __src) {
      goto LABEL_31;
    }
    uint64_t v18 = (char *)*a1;
LABEL_15:
    memmove(v18, __src, v17);
    goto LABEL_31;
  }
  long long v16 = &__src[8 * v15];
  if (v13 != v9)
  {
    memmove(*a1, __src, 8 * v15);
    uint64_t v9 = (char *)*v14;
  }
  size_t v17 = a3 - v16;
  if (v17)
  {
    uint64_t v18 = v9;
    __src  = v16;
    goto LABEL_15;
  }
LABEL_31:
  *uint64_t v14 = &v9[v17];
}

void std::__function::__func<TDecorationRun::CalculateGlyphIntersections(CGAffineTransform,TRun const&,double,double,std::function<void ()(double,double)> const&)::$_1,std::allocator<TDecorationRun::CalculateGlyphIntersections(CGAffineTransform,TRun const&,double,double,std::function<void ()(double,double)> const&)::$_1>,void ()(double,double)>::~__func()
{
}

__n128 std::__function::__func<TDecorationRun::CalculateGlyphIntersections(CGAffineTransform,TRun const&,double,double,std::function<void ()(double,double)> const&)::$_1,std::allocator<TDecorationRun::CalculateGlyphIntersections(CGAffineTransform,TRun const&,double,double,std::function<void ()(double,double)> const&)::$_1>,void ()(double,double)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1ED05D370;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8)  = result;
  return result;
}

__n128 std::__function::__func<TDecorationRun::CalculateGlyphIntersections(CGAffineTransform,TRun const&,double,double,std::function<void ()(double,double)> const&)::$_1,std::allocator<TDecorationRun::CalculateGlyphIntersections(CGAffineTransform,TRun const&,double,double,std::function<void ()(double,double)> const&)::$_1>,void ()(double,double)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2  = &unk_1ED05D370;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8)  = result;
  return result;
}

void std::__function::__func<void TDecorationRun::DrawLine<anonymous namespace'::TRunAdapter>(CGContext *,CGPoint,anonymous namespace'::TRunAdapter,anonymous namespace'::TRunAdapter,CGPoint,CGPoint,double const*,unsigned long)::{lambda(double,double)#1},std::allocator<void TDecorationRun::DrawLine<anonymous namespace'::TRunAdapter>(CGContext *,CGPoint,anonymous namespace'::TRunAdapter,anonymous namespace'::TRunAdapter,CGPoint,CGPoint,double const*,unsigned long)::{lambda(double,double)#1}>,void ()(double,double)>::~__func()
{
}

__n128 std::__function::__func<void TDecorationRun::DrawLine<anonymous namespace'::TRunAdapter>(CGContext *,CGPoint,anonymous namespace'::TRunAdapter,anonymous namespace'::TRunAdapter,CGPoint,CGPoint,double const*,unsigned long)::{lambda(double,double)#1},std::allocator<void TDecorationRun::DrawLine<anonymous namespace'::TRunAdapter>(CGContext *,CGPoint,anonymous namespace'::TRunAdapter,anonymous namespace'::TRunAdapter,CGPoint,CGPoint,double const*,unsigned long)::{lambda(double,double)#1}>,void ()(double,double)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_1ED0614C0;
  *(_OWORD *)(v2 + 8)  = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24)  = result;
  return result;
}

__n128 std::__function::__func<void TDecorationRun::DrawLine<anonymous namespace'::TRunAdapter>(CGContext *,CGPoint,anonymous namespace'::TRunAdapter,anonymous namespace'::TRunAdapter,CGPoint,CGPoint,double const*,unsigned long)::{lambda(double,double)#1},std::allocator<void TDecorationRun::DrawLine<anonymous namespace'::TRunAdapter>(CGContext *,CGPoint,anonymous namespace'::TRunAdapter,anonymous namespace'::TRunAdapter,CGPoint,CGPoint,double const*,unsigned long)::{lambda(double,double)#1}>,void ()(double,double)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2  = &unk_1ED0614C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24)  = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8)  = result;
  return result;
}

void std::__function::__func<void TDecorationRun::EnumerateLine<anonymous namespace'::TRunAdapter>(TLineDrawContext const&,CGPoint,anonymous namespace'::TRunAdapter,anonymous namespace'::TRunAdapter,CGPoint,CGPoint,void({block_pointer})(CGPoint,CGPoint))::{lambda(double,double)#1},std::allocator<void TDecorationRun::EnumerateLine<anonymous namespace'::TRunAdapter>(TLineDrawContext const&,CGPoint,anonymous namespace'::TRunAdapter,anonymous namespace'::TRunAdapter,CGPoint,CGPoint,void({block_pointer})(CGPoint,CGPoint))::{lambda(double,double)#1}>,void ()(double,double)>::~__func()
{
}

__n128 std::__function::__func<void TDecorationRun::EnumerateLine<anonymous namespace'::TRunAdapter>(TLineDrawContext const&,CGPoint,anonymous namespace'::TRunAdapter,anonymous namespace'::TRunAdapter,CGPoint,CGPoint,void({block_pointer})(CGPoint,CGPoint))::{lambda(double,double)#1},std::allocator<void TDecorationRun::EnumerateLine<anonymous namespace'::TRunAdapter>(TLineDrawContext const&,CGPoint,anonymous namespace'::TRunAdapter,anonymous namespace'::TRunAdapter,CGPoint,CGPoint,void({block_pointer})(CGPoint,CGPoint))::{lambda(double,double)#1}>,void ()(double,double)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_1ED05D328;
  *(_OWORD *)(v2 + 8)  = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24)  = result;
  return result;
}

__n128 std::__function::__func<void TDecorationRun::EnumerateLine<anonymous namespace'::TRunAdapter>(TLineDrawContext const&,CGPoint,anonymous namespace'::TRunAdapter,anonymous namespace'::TRunAdapter,CGPoint,CGPoint,void({block_pointer})(CGPoint,CGPoint))::{lambda(double,double)#1},std::allocator<void TDecorationRun::EnumerateLine<anonymous namespace'::TRunAdapter>(TLineDrawContext const&,CGPoint,anonymous namespace'::TRunAdapter,anonymous namespace'::TRunAdapter,CGPoint,CGPoint,void({block_pointer})(CGPoint,CGPoint))::{lambda(double,double)#1}>,void ()(double,double)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2  = &unk_1ED05D328;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24)  = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8)  = result;
  return result;
}

double std::__function::__func<void TDecorationRun::EnumerateLine<anonymous namespace'::TRunAdapter>(TLineDrawContext const&,CGPoint,anonymous namespace'::TRunAdapter,anonymous namespace'::TRunAdapter,CGPoint,CGPoint,void({block_pointer})(CGPoint,CGPoint))::{lambda(double,double)#1},std::allocator<void TDecorationRun::EnumerateLine<anonymous namespace'::TRunAdapter>(TLineDrawContext const&,CGPoint,anonymous namespace'::TRunAdapter,anonymous namespace'::TRunAdapter,CGPoint,CGPoint,void({block_pointer})(CGPoint,CGPoint))::{lambda(double,double)#1}>,void ()(double,double)>::operator()(uint64_t a1, double *a2, double *a3)
{
  double v3 = *a3;
  double v4 = **(double **)(a1 + 8);
  double v5 = *a2 - v4;
  uint64_t v7 = *(void *)(a1 + 24);
  uint64_t v6 = *(double **)(a1 + 32);
  if (v5 - *v6 > **(double **)v7)
  {
    (*(void (**)(double, double, double, double))(**(void **)(v7 + 16) + 16))(*v6 + **(double **)(v7 + 8), v6[1] + *(double *)(*(void *)(v7 + 8) + 8), v5 + **(double **)(v7 + 8), *(double *)(*(void *)(a1 + 16) + 8) + *(double *)(*(void *)(v7 + 8) + 8));
    double v4 = **(double **)(a1 + 8);
    uint64_t v6 = *(double **)(a1 + 32);
  }
  double result = v3 + v4;
  *uint64_t v6 = result;
  return result;
}

uint64_t ___ZZN14TDecorationRun22EnumerateDecorationRunIN12_GLOBAL__N_111TRunAdapterEEEvRK16TLineDrawContextT_S6_7CFRangeP18TDecoratorObserverdENKUl7CGPointSA_E_cvU13block_pointerFvSA_SA_EEv_block_invoke(uint64_t result, double a2, double a3, double a4, double a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v12 = **(void **)(result + 32);
  if (*(_DWORD *)v12 == 1)
  {
    memset(v15, 170, 40);
    v13[5]  = -1;
    long long v14 = unk_184BA6348;
    v13[0]  = 0xAAAAAAAA00000001;
    *(double *)&v13[1]  = a2;
    *(double *)&v13[2]  = a3;
    *(double *)&v13[3]  = a4;
    *(double *)&v13[4]  = a5;
    return (*(uint64_t (**)(void, uint64_t, void *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v12 + 8) + 16))(*(void *)(v12 + 8), 1, v13, a8, a9, a10, a11, a12);
  }
  return result;
}

uint64_t __copy_helper_block_8_32c151_ZTSKZN14TDecorationRun22EnumerateDecorationRunIN12_GLOBAL__N_111TRunAdapterEEEvRK16TLineDrawContextT_S6_7CFRangeP18TDecoratorObserverdEUl7CGPointSA_E_(uint64_t result, uint64_t a2)
{
  *(void *)(result + 32)  = *(void *)(a2 + 32);
  return result;
}

void TDecorationRun::DrawLine<TRun const*>(uint64_t a1, CGContextRef c, __n128 *a3, __n128 *a4, const CGFloat *a5, const double *a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  double v14 = a12;
  v50[4]  = *MEMORY[0x1E4F143B8];
  *(double *)double v49 = a7;
  *(double *)&v49[1]  = a8;
  *(double *)&long long v48 = a9;
  *((double *)&v48 + 1)  = a10;
  double v46 = a5;
  CGContextRef v47 = c;
  CGFloat v45 = a6;
  double v17 = *(double *)(a1 + 32) * 0.75;
  uint64_t v43 = *(void *)(a1 + 32);
  double v44 = v17;
  if (*(unsigned char *)(a1 + 16))
  {
    double v14 = a12 - a10 * 2.0;
    a10  = a10 - a10 * 2.0;
    *((double *)&v48 + 1)  = a10;
  }
  int64_t v37 = &v44;
  int64_t v38 = (double *)v49;
  uint64_t v39 = a1;
  double v40 = &v47;
  CFRange v41 = &v46;
  double v42 = &v45;
  if (*(_DWORD *)a1)
  {
    if (a11 - a9 <= v17) {
      return;
    }
    double v18 = a7 + a9;
    double v19 = a8 + a10;
    double v20 = a7 + a11;
    double v21 = a8 + v14;
    uint64_t v22 = c;
    double v23 = v18;
    double v24 = v19;
    uint64_t v25 = a5;
    uint64_t v26 = a6;
    goto LABEL_12;
  }
  *(void *)&long long v27 = -1;
  *((void *)&v27 + 1)  = -1;
  *(_OWORD *)&v36.c  = v27;
  *(_OWORD *)&v36.tCGFloat x = v27;
  *(_OWORD *)&v36.a  = v27;
  CGContextGetTextMatrix(&v36, c);
  long long v35 = v48;
  if (a3 == a4)
  {
    long long v32 = &v44;
  }
  else
  {
    do
    {
      CGAffineTransform v34 = v36;
      double v28 = *(double *)(a1 + 32) * 0.5;
      CGFloat v29 = *((double *)&v48 + 1) - v28;
      double v30 = *((double *)&v48 + 1) + v28;
      uint64_t v31 = operator new(0x28uLL);
      *uint64_t v31 = &unk_1ED061508;
      v31[1]  = &v43;
      v31[2]  = &v48;
      v31[3]  = &v37;
      v31[4]  = &v35;
      v50[3]  = v31;
      TDecorationRun::CalculateGlyphIntersections(a1, &v34.a, a3, (uint64_t)v50, v29, v30);
      std::__function::__value_func<void ()(double,double)>::~__value_func[abi:nn180100](v50);
      a3 += 20;
    }
    while (a3 != a4);
    long long v32 = v37;
  }
  if (a11 - *(double *)&v35 > *v32)
  {
    double v33 = v38[1];
    double v23 = *(double *)&v35 + *v38;
    double v24 = *((double *)&v35 + 1) + v33;
    double v20 = a11 + *v38;
    double v21 = v14 + v33;
    uint64_t v22 = *v40;
    uint64_t v25 = *v41;
    uint64_t v26 = *v42;
LABEL_12:
    TDecorationRun::DrawLineSegment(v22, v25, *(CGPoint *)&v23, *(CGPoint *)&v20, v26);
  }
}

void std::__function::__func<void TDecorationRun::DrawLine<TRun const*>(CGContext *,CGPoint,TRun const*,TRun const*,CGPoint,CGPoint,double const*,unsigned long)::{lambda(double,double)#1},std::allocator<void TDecorationRun::DrawLine<TRun const*>(CGContext *,CGPoint,TRun const*,TRun const*,CGPoint,CGPoint,double const*,unsigned long)::{lambda(double,double)#1}>,void ()(double,double)>::~__func()
{
}

__n128 std::__function::__func<void TDecorationRun::DrawLine<TRun const*>(CGContext *,CGPoint,TRun const*,TRun const*,CGPoint,CGPoint,double const*,unsigned long)::{lambda(double,double)#1},std::allocator<void TDecorationRun::DrawLine<TRun const*>(CGContext *,CGPoint,TRun const*,TRun const*,CGPoint,CGPoint,double const*,unsigned long)::{lambda(double,double)#1}>,void ()(double,double)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_1ED061508;
  *(_OWORD *)(v2 + 8)  = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24)  = result;
  return result;
}

__n128 std::__function::__func<void TDecorationRun::DrawLine<TRun const*>(CGContext *,CGPoint,TRun const*,TRun const*,CGPoint,CGPoint,double const*,unsigned long)::{lambda(double,double)#1},std::allocator<void TDecorationRun::DrawLine<TRun const*>(CGContext *,CGPoint,TRun const*,TRun const*,CGPoint,CGPoint,double const*,unsigned long)::{lambda(double,double)#1}>,void ()(double,double)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2  = &unk_1ED061508;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24)  = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8)  = result;
  return result;
}

double std::__function::__func<void TDecorationRun::DrawLine<TRun const*>(CGContext *,CGPoint,TRun const*,TRun const*,CGPoint,CGPoint,double const*,unsigned long)::{lambda(double,double)#1},std::allocator<void TDecorationRun::DrawLine<TRun const*>(CGContext *,CGPoint,TRun const*,TRun const*,CGPoint,CGPoint,double const*,unsigned long)::{lambda(double,double)#1}>,void ()(double,double)>::operator()(uint64_t a1, double *a2, double *a3)
{
  double v3 = *a3;
  double v4 = **(double **)(a1 + 8);
  double v5 = *a2 - v4;
  uint64_t v6 = *(void *)(a1 + 24);
  uint64_t v7 = *(double **)(a1 + 32);
  double v8 = *v7;
  if (v5 - *v7 > **(double **)v6)
  {
    double v10 = v7[1];
    unint64_t v11 = *(double **)(v6 + 8);
    double v12 = v11[1];
    v14.CGFloat x = v8 + *v11;
    v14.double y = v10 + v12;
    v15.CGFloat x = v5 + *v11;
    v15.double y = *(double *)(*(void *)(a1 + 16) + 8) + v12;
    TDecorationRun::DrawLineSegment(**(TDecorationRun ***)(v6 + 24), **(const CGFloat ***)(v6 + 32), v14, v15, **(const double ***)(v6 + 40));
    double v4 = **(double **)(a1 + 8);
    uint64_t v7 = *(double **)(a1 + 32);
  }
  double result = v3 + v4;
  double *v7 = result;
  return result;
}

void std::__function::__func<TDecorator::NextDecorationRun(double,TLine const&,TInlineVector<DecorationOverride,30ul> *,TDecorationRun &)::$_0,std::allocator<TDecorator::NextDecorationRun(double,TLine const&,TInlineVector<DecorationOverride,30ul> *,TDecorationRun &)::$_0>,void ()(CFRange,__CFDictionary const*,BOOL *,BOOL *)>::~__func()
{
}

__n128 std::__function::__func<TDecorator::NextDecorationRun(double,TLine const&,TInlineVector<DecorationOverride,30ul> *,TDecorationRun &)::$_0,std::allocator<TDecorator::NextDecorationRun(double,TLine const&,TInlineVector<DecorationOverride,30ul> *,TDecorationRun &)::$_0>,void ()(CFRange,__CFDictionary const*,BOOL *,BOOL *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x38uLL);
  *(void *)uint64_t v2 = &unk_1ED0607D0;
  *(_OWORD *)(v2 + 8)  = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24)  = *(_OWORD *)(a1 + 24);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40)  = result;
  return result;
}

__n128 std::__function::__func<TDecorator::NextDecorationRun(double,TLine const&,TInlineVector<DecorationOverride,30ul> *,TDecorationRun &)::$_0,std::allocator<TDecorator::NextDecorationRun(double,TLine const&,TInlineVector<DecorationOverride,30ul> *,TDecorationRun &)::$_0>,void ()(CFRange,__CFDictionary const*,BOOL *,BOOL *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2  = &unk_1ED0607D0;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 40)  = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 24)  = v3;
  *(__n128 *)(a2 + 8)  = result;
  return result;
}

void std::__function::__func<TDecorator::NextDecorationRun(double,TLine const&,TInlineVector<DecorationOverride,30ul> *,TDecorationRun &)::$_1,std::allocator<TDecorator::NextDecorationRun(double,TLine const&,TInlineVector<DecorationOverride,30ul> *,TDecorationRun &)::$_1>,void ()(CFRange,__CFDictionary const*,BOOL *,BOOL *)>::~__func()
{
}

__n128 std::__function::__func<TDecorator::NextDecorationRun(double,TLine const&,TInlineVector<DecorationOverride,30ul> *,TDecorationRun &)::$_1,std::allocator<TDecorator::NextDecorationRun(double,TLine const&,TInlineVector<DecorationOverride,30ul> *,TDecorationRun &)::$_1>,void ()(CFRange,__CFDictionary const*,BOOL *,BOOL *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x88uLL);
  *(void *)uint64_t v2 = &unk_1ED060818;
  *(_OWORD *)(v2 + 72)  = *(_OWORD *)(a1 + 72);
  *(_OWORD *)(v2 + 88)  = *(_OWORD *)(a1 + 88);
  *(_OWORD *)(v2 + 104)  = *(_OWORD *)(a1 + 104);
  *(_OWORD *)(v2 + 120)  = *(_OWORD *)(a1 + 120);
  *(_OWORD *)(v2 + 8)  = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24)  = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(v2 + 40)  = *(_OWORD *)(a1 + 40);
  __n128 result = *(__n128 *)(a1 + 56);
  *(__n128 *)(v2 + 56)  = result;
  return result;
}

__n128 std::__function::__func<TDecorator::NextDecorationRun(double,TLine const&,TInlineVector<DecorationOverride,30ul> *,TDecorationRun &)::$_1,std::allocator<TDecorator::NextDecorationRun(double,TLine const&,TInlineVector<DecorationOverride,30ul> *,TDecorationRun &)::$_1>,void ()(CFRange,__CFDictionary const*,BOOL *,BOOL *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2  = &unk_1ED060818;
  long long v2 = *(_OWORD *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  long long v4 = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 56)  = *(_OWORD *)(a1 + 56);
  *(_OWORD *)(a2 + 40)  = v4;
  *(_OWORD *)(a2 + 24)  = v3;
  *(_OWORD *)(a2 + 8)  = v2;
  __n128 result = *(__n128 *)(a1 + 72);
  long long v6 = *(_OWORD *)(a1 + 88);
  long long v7 = *(_OWORD *)(a1 + 104);
  *(_OWORD *)(a2 + 120)  = *(_OWORD *)(a1 + 120);
  *(_OWORD *)(a2 + 104)  = v7;
  *(_OWORD *)(a2 + 88)  = v6;
  *(__n128 *)(a2 + 72)  = result;
  return result;
}

void LanguagesWithLangSysTag(unsigned int a1@<W0>, CFArrayRef *a2@<X8>)
{
  uint64_t v4 = 6352;
  double v5 = &kLanguageToLangSysMappings[8];
  do
  {
    if (*((_DWORD *)v5 - 1) == a1)
    {
      CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      id values = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
      int v7 = *((_DWORD *)v5 - 2);
      cStr  = HIBYTE(v7);
      char v15 = BYTE2(v7);
      char v16 = BYTE1(v7);
      char v17 = 0;
      double v8 = (__CFString *)CFStringCreateWithCString(v6, &cStr, 0x600u);
      CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&values, memory_order_acquire), v8);

      if (v4 != 8)
      {
        do
        {
          if (*((_DWORD *)v5 + 1) == a1)
          {
            int v9 = *(_DWORD *)v5;
            v5 += 8;
            cStr  = HIBYTE(v9);
            char v15 = BYTE2(v9);
            char v16 = BYTE1(v9);
            char v17 = 0;
            double v10 = (__CFString *)CFStringCreateWithCString(v6, &cStr, 0x600u);
            CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&values, memory_order_acquire), v10);
          }
          else
          {
            v5 += 8;
          }
        }
        while (v5 != (char *)&kMasterFeatureMap);
      }
      *a2  = (CFArrayRef)atomic_exchange((atomic_ullong *volatile)&values, 0);
      unint64_t v11 = values;
      goto LABEL_13;
    }
    v5 += 8;
    v4 -= 8;
  }
  while (v4);
  if (a1 == 32)
  {
    cStr  = __tolower(HIBYTE(a1));
    char v15 = __tolower(BYTE2(a1));
    char v16 = __tolower(BYTE1(a1));
    char v17 = 0;
    CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t v13 = (__CFString *)CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &cStr, 0x600u);
    id values = v13;
    *a2  = CFArrayCreate(v12, (const void **)&values, 1, MEMORY[0x1E4F1D510]);
    unint64_t v11 = v13;
LABEL_13:

    return;
  }
  *a2  = 0;
}

uint64_t ScriptCodeForScriptTag(unsigned int a1)
{
  unsigned int v12 = a1;
  {
    ScriptCodeForScriptTag::sMap  = 0u;
    *(_OWORD *)algn_1E8F8AE90  = 0u;
    dword_1E8F8AEA0  = 1065353216;
  }
  os_unfair_lock_lock_with_options();
  int v1 = std::__hash_table<std::__hash_value_type<unsigned int,OTL::Lookup>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,OTL::Lookup>>>::find<unsigned int>(&ScriptCodeForScriptTag::sMap, &v12);
  if (v1)
  {
    uint64_t v2 = *((unsigned int *)v1 + 5);
  }
  else
  {
    unsigned int v3 = v12;
    if (v12 == 1145457748)
    {
      int v4 = -1;
    }
    else
    {
      int v4 = 2;
      while ((v4 & 0x7FFFFFFD) == 0x14 || ScriptTagForScriptCode(v4) != v3)
      {
        if (++v4 == 200)
        {
          char v5 = 0;
          int v6 = 201;
          do
          {
            int v4 = v6;
            int v7 = ScriptTagForScriptCode(v6);
            if (v5) {
              break;
            }
            int v6 = 202;
            char v5 = 1;
          }
          while (v7 != v3);
          if (v7 != v3) {
            int v4 = -1;
          }
          break;
        }
      }
    }
    unsigned int v11 = v4;
    double v8 = std::__hash_table<std::__hash_value_type<unsigned int,UScriptCode>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,UScriptCode>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,UScriptCode>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,UScriptCode>>>::__emplace_unique_key_args<unsigned int,unsigned int const&,UScriptCode&>((float *)&ScriptCodeForScriptTag::sMap, &v12, &v12, (int *)&v11);
    uint64_t v2 = v11;
    if (!v9) {
      *((_DWORD *)v8 + 5)  = v11;
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&ScriptCodeForScriptTag::sLock);
  return v2;
}

unint64_t NumberOfGlyphVariants(const TBaseFont *a1, int a2)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  int v58 = a2;
  CFDataRef CommonTable = (const __CFData *)TBaseFont::GetCommonTable(a1, 1196643650, 0);
  if (!CommonTable) {
    return 0;
  }
  CFDataRef v3 = CommonTable;
  BytePtr  = (unint64_t)CFDataGetBytePtr(CommonTable);
  if (BytePtr)
  {
    char v5 = CFDataGetBytePtr(v3);
    if (v5) {
      int v6 = (unsigned __int16 *)&v5[CFDataGetLength(v3)];
    }
    else {
      int v6 = 0;
    }
    CGFloat v57 = v6;
    if (!*(_WORD *)(BytePtr + 6)) {
      return 0;
    }
    int v7 = (_WORD *)(BytePtr + __rev16(*(unsigned __int16 *)(BytePtr + 6)));
    double v8 = (char *)(v7 + 1);
    if (v7 + 1 > v6) {
      return 0;
    }
    uint64_t v9 = bswap32((unsigned __int16)*v7) >> 16;
    unint64_t v10 = (unint64_t)&v8[6 * v9];
    if (v10 < (unint64_t)v8 || v10 > (unint64_t)v6)
    {
      unint64_t v12 = ((char *)v6 - v8) / 6uLL;
      if (v7 + 4 > v6) {
        unint64_t v12 = 0;
      }
      if (v12 != v9) {
        return 0;
      }
    }
    if (!*(_WORD *)(BytePtr + 8)) {
      return 0;
    }
    uint64_t v13 = (unsigned __int16 *)(BytePtr + __rev16(*(unsigned __int16 *)(BytePtr + 8)));
    CGPoint v14 = v13 + 1;
    if (v13 + 1 > v6) {
      return 0;
    }
    uint64_t v15 = bswap32(*v13) >> 16;
    unint64_t v16 = (unint64_t)&v14[v15];
    unint64_t v17 = v13 + 2 <= v6 ? (unint64_t)((char *)v6 - (char *)v14) >> 1 : 0;
    BOOL v18 = v16 <= (unint64_t)v6 && v16 >= (unint64_t)v14;
    if (!v18 && v17 != v15) {
      return 0;
    }
    *(void *)&long long v20 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v20 + 1)  = 0xAAAAAAAAAAAAAAAALL;
    v64[3]  = v20;
    v64[2]  = v20;
    v64[1]  = v20;
    v64[0]  = v20;
    id v61 = 0;
    int v62 = 0;
    uint64_t v63 = 0;
    uint64_t v65 = v64;
    v60[0]  = &unk_1ED05FDF8;
    v60[1]  = &v58;
    v60[2]  = &v61;
    v60[3]  = v60;
    OTL::GCommon::IterateFeatureTables(BytePtr, v7, (unint64_t)v6, (uint64_t)v60);
    std::__function::__value_func<BOOL ()(unsigned int,OTL::FeatureTable const*,BOOL &)>::~__value_func[abi:nn180100](v60);
    double v21 = std::__unique[abi:nn180100]<std::_ClassicAlgPolicy,std::__wrap_iter<unsigned short *>,std::__wrap_iter<unsigned short *>,std::__equal_to &>(v61, v62);
    uint64_t v22 = v61;
    if (v62 != v21) {
      int v62 = v21;
    }
    unsigned int v23 = *v13;
    unsigned __int16 v56 = 0;
    if (v61 != v21)
    {
      unsigned int v53 = bswap32(v23) >> 16;
      while (1)
      {
        uint64_t v24 = *v22;
        if (v24 >= v53)
        {
LABEL_89:
          BytePtr  = v56;
          goto LABEL_93;
        }
        uint64_t v25 = (unsigned __int16 *)((char *)v13 + (bswap32(v13[v24 + 1]) >> 16));
        uint64_t v26 = v25 + 3;
        if ((unint64_t)(v25 + 2) < BytePtr || v26 > v57) {
          goto LABEL_92;
        }
        unsigned int v28 = v25[2];
        uint64_t v29 = __rev16(v28);
        unint64_t v30 = (unint64_t)&v25[v29 + 3] + (((unint64_t)v25[1] >> 11) & 2);
        BOOL v31 = BytePtr <= (unint64_t)v25 && v30 >= (unint64_t)v25;
        if (!v31 || v30 > (unint64_t)v57) {
          goto LABEL_92;
        }
        unint64_t v33 = (unint64_t)&v26[v29];
        if (v25 + 4 <= v57) {
          unsigned int v34 = (v57 - v26) >> 1;
        }
        else {
          unsigned int v34 = 0;
        }
        unsigned int v35 = bswap32(v34) >> 16;
        BOOL v36 = v33 < (unint64_t)v26 || v33 > (unint64_t)v57;
        if (v36) {
          uint64_t v37 = (unsigned __int16)v34;
        }
        else {
          uint64_t v37 = v29;
        }
        if (v36) {
          unsigned int v28 = v35;
        }
        if (v28) {
          break;
        }
LABEL_88:
        if (++v22 == v21) {
          goto LABEL_89;
        }
      }
      uint64_t v38 = 2 * v37;
      while (1)
      {
        uint64_t v39 = (char *)v25 + (bswap32(*v26) >> 16);
        if (v39 + 2 > v57) {
          break;
        }
        unsigned int v40 = *v25;
        if (v40 == 1792)
        {
          if (*(_WORD *)v39 != 256 || v39 + 8 > v57) {
            break;
          }
          unsigned int v42 = *((unsigned __int16 *)v39 + 1);
          if (v42 == 1792) {
            break;
          }
          v39 += bswap32(*((_DWORD *)v39 + 1));
          if (v39 + 2 > v57) {
            break;
          }
          unsigned int v43 = __rev16(v42);
        }
        else
        {
          unsigned int v43 = __rev16(v40);
        }
        if (v43 == 3)
        {
          uint64_t v55 = v39;
          unint64_t v45 = (unint64_t)(v39 + 6);
          if (v39 + 6 > v57) {
            break;
          }
          uint64_t v46 = bswap32(*((unsigned __int16 *)v39 + 2)) >> 16;
          unint64_t v47 = v45 + 2 * v46;
          unint64_t v48 = v39 + 8 <= v57 ? ((unint64_t)v57 - v45) >> 1 : 0;
          BOOL v49 = v47 <= (unint64_t)v57 && v47 >= v45;
          if (!v49 && v48 != v46) {
            break;
          }
          OTL::LookupWithCoverage::GetCoverage((OTL::Coverage *)v39, (unint64_t)v57, (uint64_t)v54);
          uint64_t v51 = operator new(0x20uLL);
          *uint64_t v51 = &unk_1ED05FE40;
          v51[1]  = &v55;
          v51[2]  = &v57;
          v51[3]  = &v56;
          v59[3]  = v51;
          OTL::Coverage::Iterate(v54, (uint64_t)v59);
          std::__function::__value_func<BOOL ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100](v59);
        }
        else
        {
          if (v43 == 7) {
            break;
          }
          __int16 v44 = v56;
          if (v56 <= 1u) {
            __int16 v44 = 1;
          }
          unsigned __int16 v56 = v44;
        }
        ++v26;
        v38 -= 2;
        if (!v38) {
          goto LABEL_88;
        }
      }
    }
LABEL_92:
    BytePtr  = 0;
LABEL_93:
    v54[0]  = (void **)&v61;
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100](v54);
  }
  return BytePtr;
}

uint64_t NameIDForCharacterVariant(TBaseFont *a1, int a2, uint64_t a3, uint64_t a4, void *a5)
{
  unsigned int v9 = (((a2 - 10 * ((205 * a2) >> 11)) | ((205 * a2) >> 11 << 8)) + 12288) | 0x63760030;
  CFDataRef CommonTable = (const __CFData *)TBaseFont::GetCommonTable(a1, 1196643650, 0);
  if (CommonTable
    && (unsigned int v11 = (unsigned __int16 *)FeatureParamsForTag<OTL::CharacterVariantFeatureParams>(CommonTable, v9)) != 0
    || (CFDataRef v12 = (const __CFData *)TBaseFont::GetCommonTable(a1, 1196445523, 0)) != 0
    && (unsigned int v11 = (unsigned __int16 *)FeatureParamsForTag<OTL::CharacterVariantFeatureParams>(v12, v9)) != 0)
  {
    unsigned int v13 = v11[3];
    if (!*(unsigned char *)(a3 + 2)) {
      *(unsigned char *)(a3 + 2)  = 1;
    }
    *(_WORD *)a3  = __rev16(v13);
    unsigned int v14 = v11[2];
    if (!*(unsigned char *)(a4 + 2)) {
      *(unsigned char *)(a4 + 2)  = 1;
    }
    *(_WORD *)a4  = __rev16(v14);
    std::vector<int,TInlineBufferAllocator<int,30ul>>::resize((uint64_t)a5, bswap32(v11[4]) >> 16);
    uint64_t v15 = (_DWORD *)*a5;
    unint64_t v16 = (_DWORD *)a5[1];
    if ((_DWORD *)*a5 != v16)
    {
      unsigned int v17 = bswap32(v11[5]) >> 16;
      do
        *v15++  = (unsigned __int16)v17++;
      while (v15 != v16);
    }
    unsigned int v18 = bswap32(v11[1]);
    int v19 = HIWORD(v18) & 0xFF00;
    int v20 = BYTE2(v18);
    int v21 = 0x10000;
  }
  else
  {
    int v20 = 0;
    int v19 = 0;
    int v21 = 0;
  }
  return v19 | v20 | v21;
}

void std::vector<int,TInlineBufferAllocator<int,30ul>>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 2;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8)  = *(void *)a1 + 4 * a2;
    }
  }
  else
  {
    std::vector<int,TInlineBufferAllocator<int,30ul>>::__append((char **)a1, a2 - v2);
  }
}

CFDataRef NameIDForStylisticSet(const TBaseFont *a1, int a2)
{
  CFDataRef result = FeatureParamsForTag<OTL::StylisticSetFeatureParams>(a1, (((a2 - 10 * ((205 * a2) >> 11)) | ((205 * a2) >> 11 << 8))+ 12288) | 0x73730030);
  if (result) {
    return (const __CFData *)((bswap32(*((unsigned __int16 *)result + 1)) >> 16) | 0x10000);
  }
  return result;
}

uint64_t GetCharacterVariantOrStylisticSet(__int16 a1)
{
  unsigned __int8 v1 = a1 + 10 * HIBYTE(a1) - 16;
  int v2 = a1 + 10 * HIBYTE(a1) != 528;
  if (a1 - 48 > 9 || HIBYTE(a1) - 48 > 9)
  {
    unsigned __int8 v1 = 0;
    int v2 = 0;
  }
  return v1 | (v2 << 8);
}

void CopyStaticOTFeatureName(unsigned int *a1@<X1>, int a2@<W0>, void *a3@<X8>)
{
  if ((a2 & 0x80000000) == 0) {
    goto LABEL_2;
  }
  if (v7 != v6 && (double v8 = v6, CFStringFind((CFStringRef)*((void *)v6 + 1), @"%d", 0xCuLL).location == -1))
  {
    if (a1) {
      *a1  = (unint64_t)(v8 - (char *)&CopyStaticOTFeatureName(int,unsigned int *)::kMasterFeatureNameStrings) >> 4;
    }
    CFStringRef v14 = (const __CFString *)*((void *)v8 + 1);
    CTCopyLocalizedString(v14, @"OpenType", a3);
  }
  else
  {
    unsigned int v9 = -a2;
    unsigned int v10 = v9 / 0xC8;
    if (v11 == v12)
    {
LABEL_2:
      *a3  = 0;
      return;
    }
    if (a1) {
      *a1  = (unint64_t)(v11 - (char *)&CopyStaticOTFeatureName(int,unsigned int *)::kMasterFeatureNameStrings) >> 4;
    }
    if (v9 / 0xC8 == 36) {
      uint64_t v13 = (unsigned __int16)((__int16)(~(200 * v10) + v9 + (((~(200 * v10) + v9) & 0x8000) >> 15)) >> 1);
    }
    else {
      uint64_t v13 = ~(200 * v10) + v9;
    }
    CTCopyLocalizedString(*((CFStringRef *)v11 + 1), @"OpenType", &v15);
    CreateLocalizedStringWithFormat((const __CFString *)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire), a3, v13);
  }
}

char *std::equal_range[abi:nn180100]<anonymous namespace'::NameString const*,int,std::greater<int>>(int a1)
{
  unsigned __int8 v1 = (char *)&CopyStaticOTFeatureName(int,unsigned int *)::kMasterFeatureNameStrings;
  int v2 = "mond";
  unint64_t v3 = 91;
  while (1)
  {
    unint64_t v4 = v3 >> 1;
    char v5 = &v1[16 * (v3 >> 1)];
    if (*(_DWORD *)v5 <= a1) {
      break;
    }
    unsigned __int8 v1 = v5 + 16;
    unint64_t v4 = v3 + ~v4;
LABEL_6:
    unint64_t v3 = v4;
    if (!v4) {
      return v1;
    }
  }
  if (*(_DWORD *)v5 < a1)
  {
    int v2 = &v1[16 * (v3 >> 1)];
    goto LABEL_6;
  }
  int v6 = &v1[16 * (v3 >> 1)];
  if (v3 >= 2)
  {
    int v6 = v1;
    do
    {
      unint64_t v7 = v4 >> 1;
      double v8 = &v6[16 * (v4 >> 1)];
      int v10 = *(_DWORD *)v8;
      unsigned int v9 = v8 + 16;
      v4 += ~(v4 >> 1);
      if (v10 <= a1) {
        unint64_t v4 = v7;
      }
      else {
        int v6 = v9;
      }
    }
    while (v4);
  }
  unsigned int v11 = v5 + 16;
  if (v2 == v5 + 16) {
    return v6;
  }
  unint64_t v12 = (v2 - (v5 + 16)) >> 4;
  do
  {
    unint64_t v13 = v12 >> 1;
    CFStringRef v14 = &v11[4 * (v12 >> 1)];
    int v16 = *v14;
    id v15 = v14 + 4;
    v12 += ~(v12 >> 1);
    if (v16 < a1) {
      unint64_t v12 = v13;
    }
    else {
      unsigned int v11 = v15;
    }
  }
  while (v12);
  return v6;
}

void CopyLocalizedOTFeatureName(const __CFString *a1@<X0>, void *a2@<X8>)
{
  if (a1)
  {
    unsigned int v3 = FourCharCodeFromString(a1);
    uint64_t v4 = 0;
    while (*(_DWORD *)&CopyLocalizedOTFeatureName(__CFString const*)::kOTFeatureNames[v4] != v3)
    {
      v4 += 16;
      if (v4 == 128) {
        goto LABEL_9;
      }
    }
    CFStringRef v5 = *(const __CFString **)&CopyLocalizedOTFeatureName(__CFString const*)::kOTFeatureNames[v4 + 8];
    CTCopyLocalizedString(v5, @"OpenType", a2);
  }
  else
  {
LABEL_9:
    *a2  = 0;
  }
}

uint64_t LangSysForChineseLocale(__CFString *a1)
{
  id v12 = (id)0xAAAAAAAAAAAAAAAALL;
  LanguageIdentifierByNormalizing(a1, 3u, (atomic_ullong *)&v12);
  unsigned __int8 v1 = (__CFString *)(id)atomic_load_explicit((atomic_ullong *volatile)&v12, memory_order_acquire);
  int v2 = v1;
  uint64_t v3 = 1514686496;
  if (v1 == @"zh-HK")
  {

    goto LABEL_22;
  }
  if (v1)
  {
    int v4 = CFEqual(v1, @"zh-HK");

    if (v4) {
      goto LABEL_22;
    }
  }
  else
  {
  }
  CFStringRef v5 = (__CFString *)(id)atomic_load_explicit((atomic_ullong *volatile)&v12, memory_order_acquire);
  int v6 = v5;
  if (v5 == @"zh-MO")
  {

    goto LABEL_12;
  }
  if (v5)
  {
    int v7 = CFEqual(v5, @"zh-MO");

    if (!v7) {
      goto LABEL_14;
    }
LABEL_12:
    uint64_t v3 = 1514689613;
    goto LABEL_22;
  }

LABEL_14:
  double v8 = (__CFString *)(id)atomic_load_explicit((atomic_ullong *volatile)&v12, memory_order_acquire);
  unsigned int v9 = v8;
  if (v8 == @"zh-Hans")
  {
  }
  else
  {
    if (!v8)
    {

LABEL_21:
      uint64_t v3 = 1514689568;
      goto LABEL_22;
    }
    int v10 = CFEqual(v8, @"zh-Hans");

    if (!v10) {
      goto LABEL_21;
    }
  }
  uint64_t v3 = 1514689312;
LABEL_22:

  return v3;
}

uint64_t FindFirstLangSysTagForISO3LanguageTag(unsigned int a1)
{
  unsigned __int8 v1 = kLanguageToLangSysMappings;
  int v2 = &kLanguageToLangSysMappings[6352];
  unint64_t v3 = 794;
  while (1)
  {
    unint64_t v4 = v3 >> 1;
    CFStringRef v5 = &v1[8 * (v3 >> 1)];
    if (*(_DWORD *)v5 >= a1) {
      break;
    }
    unsigned __int8 v1 = v5 + 8;
    unint64_t v4 = v3 + ~v4;
LABEL_6:
    unint64_t v3 = v4;
    if (!v4) {
      return 0;
    }
  }
  if (*(_DWORD *)v5 > a1)
  {
    int v2 = (char *)&v1[8 * (v3 >> 1)];
    goto LABEL_6;
  }
  int v7 = &v1[8 * (v3 >> 1)];
  if (v3 >= 2)
  {
    int v7 = v1;
    do
    {
      unint64_t v8 = v4 >> 1;
      unsigned int v9 = &v7[8 * (v4 >> 1)];
      unsigned int v11 = *(_DWORD *)v9;
      int v10 = v9 + 8;
      v4 += ~(v4 >> 1);
      if (v11 >= a1) {
        unint64_t v4 = v8;
      }
      else {
        int v7 = v10;
      }
    }
    while (v4);
  }
  id v12 = (char *)(v5 + 8);
  if (v2 != v12)
  {
    unint64_t v13 = (v2 - v12) >> 3;
    int v2 = v12;
    do
    {
      unint64_t v14 = v13 >> 1;
      id v15 = &v2[8 * (v13 >> 1)];
      unsigned int v17 = *(_DWORD *)v15;
      int v16 = v15 + 8;
      v13 += ~(v13 >> 1);
      if (v17 > a1) {
        unint64_t v13 = v14;
      }
      else {
        int v2 = v16;
      }
    }
    while (v13);
  }
  if (v7 == v2) {
    return 0;
  }
  return *((unsigned int *)v7 + 1);
}

uint64_t TagByUppercasing(unsigned int a1)
{
  if (HIBYTE(a1) - 97 >= 0x1Au) {
    unsigned int v1 = a1 & 0xFF000000;
  }
  else {
    unsigned int v1 = (a1 & 0xFF000000) - 0x20000000;
  }
  int v2 = BYTE2(a1) << 16;
  if (BYTE2(a1) - 97 < 0x1A) {
    v2 -= 0x200000;
  }
  int v3 = BYTE1(a1) << 8;
  if (BYTE1(a1) - 97 < 0x1A) {
    v3 -= 0x2000;
  }
  return v1 | v2 | v3 | 0x20;
}

void ScriptAndLangSysFromScriptCode(UScriptCode,__CFString const*)::$_1::__invoke()
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], 0);
  CFDictionaryAddValue(Mutable, @"ay", (const void *)0x19);
  CFDictionaryAddValue(Mutable, @"gd", (const void *)0x19);
  CFDictionaryAddValue(Mutable, @"gn", (const void *)0x19);
  CFDictionaryAddValue(Mutable, @"grc", (const void *)0xE);
  CFDictionaryAddValue(Mutable, @"jv", (const void *)0x19);
  CFDictionaryAddValue(Mutable, @"ku", (const void *)2);
  CFDictionaryAddValue(Mutable, @"la", (const void *)0x19);
  CFDictionaryAddValue(Mutable, @"ny", (const void *)0x19);
  CFDictionaryAddValue(Mutable, @"qu", (const void *)0x19);
  CFDictionaryAddValue(Mutable, @"sa", (const void *)0xA);
  CFDictionaryAddValue(Mutable, @"sd", (const void *)2);
  CFDictionaryAddValue(Mutable, @"se", (const void *)0x19);
  CFDictionaryAddValue(Mutable, @"su", (const void *)0x19);
  CFDictionaryAddValue(Mutable, @"tt", (const void *)8);
  CFDictionaryAddValue(Mutable, @"tt-Cyrl", (const void *)8);
  CFDictionaryAddValue(Mutable, @"mo", (const void *)0x19);
  CFDictionaryAddValue(Mutable, @"mo-Cyrl", (const void *)8);
  qword_1EB2CE4F0  = (uint64_t)Mutable;
}

void std::vector<int,TInlineBufferAllocator<int,30ul>>::__append(char **a1, unint64_t a2)
{
  CFStringRef v5 = a1[1];
  unint64_t v4 = a1[2];
  if (a2 <= (v4 - v5) >> 2)
  {
    if (a2)
    {
      bzero(a1[1], 4 * a2);
      v5 += 4 * a2;
    }
    a1[1]  = v5;
  }
  else
  {
    unint64_t v7 = (unint64_t)(a1 + 3);
    int v6 = *a1;
    uint64_t v8 = v5 - *a1;
    unint64_t v9 = a2 + (v8 >> 2);
    if (v9 >> 62) {
      abort();
    }
    uint64_t v10 = v8 >> 2;
    uint64_t v11 = v4 - v6;
    if (v11 >> 1 > v9) {
      unint64_t v9 = v11 >> 1;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v9;
    }
    if (v12)
    {
      unint64_t v13 = (char *)TInlineBufferAllocator<unsigned int,30ul>::allocate((uint64_t)(a1 + 3), v12);
      int v6 = *a1;
      CFStringRef v5 = a1[1];
    }
    else
    {
      unint64_t v13 = 0;
    }
    unint64_t v14 = &v13[4 * v10];
    id v15 = &v13[4 * v12];
    bzero(v14, 4 * a2);
    int v16 = &v14[4 * a2];
    while (v5 != v6)
    {
      int v17 = *((_DWORD *)v5 - 1);
      v5 -= 4;
      *((_DWORD *)v14 - 1)  = v17;
      v14 -= 4;
    }
    *a1  = v14;
    a1[1]  = v16;
    unsigned int v18 = a1[2];
    a1[2]  = v15;
    if (v6)
    {
      if (v7 > (unint64_t)v6 || (int v19 = a1 + 18, a1 + 18 <= (char **)v6))
      {
        operator delete(v6);
      }
      else if (v18 == *v19)
      {
        long long *v19 = v6;
      }
    }
  }
}

unsigned __int16 *std::__unique[abi:nn180100]<std::_ClassicAlgPolicy,std::__wrap_iter<unsigned short *>,std::__wrap_iter<unsigned short *>,std::__equal_to &>(unsigned __int16 *a1, unsigned __int16 *a2)
{
  CFDataRef result = a2;
  if (a1 != a2)
  {
    unint64_t v4 = a1 + 1;
    do
    {
      if (v4 == a2) {
        return a2;
      }
      int v5 = *(v4 - 1);
      int v6 = *v4++;
    }
    while (v5 != v6);
    unint64_t v7 = v4 - 2;
    while (v4 != a2)
    {
      int v8 = v5;
      int v5 = *v4;
      if (v8 != v5)
      {
        v7[1]  = v5;
        ++v7;
      }
      ++v4;
    }
    return v7 + 1;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,PseudoFeature *>(unsigned __int16 *a1, unsigned __int16 *a2)
{
  uint64_t v4 = ((char *)a2 - (char *)a1) >> 3;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      unsigned int v6 = *(a2 - 4);
      unsigned int v7 = *a1;
      unsigned int v8 = a1[1];
      BOOL v9 = v6 == v7;
      BOOL v10 = v6 < v7;
      if (v9) {
        BOOL v10 = *(a2 - 3) < v8;
      }
      if (v10)
      {
        int v11 = *((_DWORD *)a1 + 1);
        *(void *)a1  = *((void *)a2 - 1);
        *(a2 - 4)  = v7;
        *(a2 - 3)  = v8;
        *((_DWORD *)a2 - 1)  = v11;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,PseudoFeature *>(a1, a1 + 4, a2 - 4);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,PseudoFeature *>(a1, a1 + 4, a1 + 8, a2 - 4);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,PseudoFeature *>(a1, a1 + 4, a1 + 8, a1 + 12, a2 - 4);
      return 1;
    default:
      unint64_t v12 = a1 + 8;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,PseudoFeature *>(a1, a1 + 4, a1 + 8);
      unint64_t v13 = a1 + 12;
      if (a1 + 12 == a2) {
        return 1;
      }
      uint64_t v14 = 0;
      int v15 = 0;
      break;
  }
  while (1)
  {
    unsigned int v16 = *v13;
    unsigned int v17 = *v12;
    BOOL v9 = v16 == v17;
    BOOL v18 = v16 < v17;
    if (v9) {
      BOOL v18 = v13[1] < v12[1];
    }
    if (v18)
    {
      uint64_t v19 = *(void *)v13;
      unsigned int v20 = (unsigned __int16)*(void *)v13;
      uint64_t v21 = v14;
      while (1)
      {
        uint64_t v22 = (char *)a1 + v21;
        *(void *)((char *)a1 + v21 + 24)  = *(void *)((char *)a1 + v21 + 16);
        if (v21 == -16) {
          break;
        }
        unsigned int v23 = *((unsigned __int16 *)v22 + 4);
        BOOL v24 = *((unsigned __int16 *)v22 + 5) > WORD1(v19);
        BOOL v9 = v23 == v20;
        BOOL v25 = v23 > v20;
        if (!v9) {
          BOOL v24 = v25;
        }
        v21 -= 8;
        if (!v24)
        {
          uint64_t v26 = (void *)((char *)a1 + v21 + 24);
          goto LABEL_18;
        }
      }
      uint64_t v26 = a1;
LABEL_18:
      void *v26 = v19;
      if (++v15 == 8) {
        return v13 + 4 == a2;
      }
    }
    unint64_t v12 = v13;
    v14 += 8;
    v13 += 4;
    if (v13 == a2) {
      return 1;
    }
  }
}

unsigned __int16 *std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,PseudoFeature *>(unsigned __int16 *a1, unsigned __int16 *a2, unsigned __int16 *a3, unsigned __int16 *a4, unsigned __int16 *a5)
{
  BOOL result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,PseudoFeature *>(a1, a2, a3, a4);
  unsigned int v11 = *a5;
  unsigned int v12 = *a4;
  unsigned int v13 = a4[1];
  BOOL v14 = v11 == v12;
  BOOL v15 = v11 < v12;
  if (v14) {
    BOOL v15 = a5[1] < v13;
  }
  if (v15)
  {
    int v16 = *((_DWORD *)a4 + 1);
    *(void *)a4  = *(void *)a5;
    *a5  = v12;
    a5[1]  = v13;
    *((_DWORD *)a5 + 1)  = v16;
    unsigned int v17 = *a4;
    unsigned int v18 = *a3;
    unsigned int v19 = a3[1];
    BOOL v14 = v17 == v18;
    BOOL v20 = v17 < v18;
    if (v14) {
      BOOL v20 = a4[1] < v19;
    }
    if (v20)
    {
      int v21 = *((_DWORD *)a3 + 1);
      *(void *)a3  = *(void *)a4;
      *a4  = v18;
      a4[1]  = v19;
      *((_DWORD *)a4 + 1)  = v21;
      unsigned int v22 = *a3;
      unsigned int v23 = *a2;
      unsigned int v24 = a2[1];
      BOOL v14 = v22 == v23;
      BOOL v25 = v22 < v23;
      if (v14) {
        BOOL v25 = a3[1] < v24;
      }
      if (v25)
      {
        int v26 = *((_DWORD *)a2 + 1);
        *(void *)a2  = *(void *)a3;
        *a3  = v23;
        a3[1]  = v24;
        *((_DWORD *)a3 + 1)  = v26;
        unsigned int v27 = *a2;
        unsigned int v28 = *a1;
        unsigned int v29 = a1[1];
        BOOL v14 = v27 == v28;
        BOOL v30 = v27 < v28;
        if (v14) {
          BOOL v30 = a2[1] < v29;
        }
        if (v30)
        {
          int v31 = *((_DWORD *)a1 + 1);
          *(void *)a1  = *(void *)a2;
          *a2  = v28;
          a2[1]  = v29;
          *((_DWORD *)a2 + 1)  = v31;
        }
      }
    }
  }
  return result;
}

void GetDefaultFeatureList<true>(void)::{lambda(void *)#1}::__invoke()
{
  for (uint64_t i = 0; i != 1980; i += 12)
  {
    *(void *)unsigned int v1 = *(uint64_t *)((char *)&kMasterFeatureMap + i);
    *(_DWORD *)&v1[8]  = *(_DWORD *)((char *)&kMasterFeatureMap + i + 8);
    if ((*(void *)&v1[4] & 0x2600000000) == 0x200000000) {
  }
    }
}

uint64_t *std::__hash_table<std::__hash_value_type<UScriptCode,unsigned int>,std::__unordered_map_hasher<UScriptCode,std::__hash_value_type<UScriptCode,unsigned int>,std::hash<UScriptCode>,std::equal_to<UScriptCode>,true>,std::__unordered_map_equal<UScriptCode,std::__hash_value_type<UScriptCode,unsigned int>,std::equal_to<UScriptCode>,std::hash<UScriptCode>,true>,std::allocator<std::__hash_value_type<UScriptCode,unsigned int>>>::find<UScriptCode>(void *a1, int a2)
{
  unint64_t v2 = a1[1];
  if (!v2) {
    return 0;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
  v3.i16[0]  = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a2;
    if (v2 <= a2) {
      unint64_t v4 = a2 % v2;
    }
  }
  else
  {
    unint64_t v4 = (v2 - 1) & a2;
  }
  int v5 = *(uint64_t ***)(*a1 + 8 * v4);
  if (!v5) {
    return 0;
  }
  for (BOOL result = *v5; result; BOOL result = (uint64_t *)*result)
  {
    unint64_t v7 = result[1];
    if (v7 == a2)
    {
      if (*((_DWORD *)result + 4) == a2) {
        return result;
      }
    }
    else
    {
      if (v3.u32[0] > 1uLL)
      {
        if (v7 >= v2) {
          v7 %= v2;
        }
      }
      else
      {
        v7 &= v2 - 1;
      }
      if (v7 != v4) {
        return 0;
      }
    }
  }
  return result;
}

void std::__hash_table<std::__hash_value_type<UScriptCode,unsigned int>,std::__unordered_map_hasher<UScriptCode,std::__hash_value_type<UScriptCode,unsigned int>,std::hash<UScriptCode>,std::equal_to<UScriptCode>,true>,std::__unordered_map_equal<UScriptCode,std::__hash_value_type<UScriptCode,unsigned int>,std::equal_to<UScriptCode>,std::hash<UScriptCode>,true>,std::allocator<std::__hash_value_type<UScriptCode,unsigned int>>>::__emplace_unique_key_args<UScriptCode,std::pair<UScriptCode,unsigned int>>(float *a1, int a2, int a3, int a4)
{
  unint64_t v7 = a2;
  unint64_t v8 = *((void *)a1 + 1);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0]  = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v10 = a2;
      if (v8 <= a2) {
        unint64_t v10 = a2 % v8;
      }
    }
    else
    {
      unint64_t v10 = (v8 - 1) & a2;
    }
    unsigned int v11 = *(uint64_t ***)(*(void *)a1 + 8 * v10);
    if (v11)
    {
      for (uint64_t i = *v11; i; uint64_t i = (uint64_t *)*i)
      {
        unint64_t v13 = i[1];
        if (v13 == a2)
        {
          if (*((_DWORD *)i + 4) == a2) {
            return;
          }
        }
        else
        {
          if (v9.u32[0] > 1uLL)
          {
            if (v13 >= v8) {
              v13 %= v8;
            }
          }
          else
          {
            v13 &= v8 - 1;
          }
          if (v13 != v10) {
            break;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v10 = 0xAAAAAAAAAAAAAAAALL;
  }
  BOOL v14 = operator new(0x18uLL);
  *BOOL v14 = 0;
  v14[1]  = v7;
  *((_DWORD *)v14 + 4)  = a3;
  *((_DWORD *)v14 + 5)  = a4;
  float v15 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v16 = a1[8];
  if (!v8 || (float)(v16 * (float)v8) < v15)
  {
    BOOL v17 = 1;
    if (v8 >= 3) {
      BOOL v17 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v18 = v17 | (2 * v8);
    unint64_t v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19) {
      int8x8_t prime = (int8x8_t)v19;
    }
    else {
      int8x8_t prime = (int8x8_t)v18;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v8 = *((void *)a1 + 1);
    }
    if (*(void *)&prime > v8) {
      goto LABEL_30;
    }
    if (*(void *)&prime < v8)
    {
      unint64_t v27 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v8 < 3 || (uint8x8_t v28 = (uint8x8_t)vcnt_s8((int8x8_t)v8), v28.i16[0] = vaddlv_u8(v28), v28.u32[0] > 1uLL))
      {
        unint64_t v27 = std::__next_prime(v27);
      }
      else
      {
        uint64_t v29 = 1 << -(char)__clz(v27 - 1);
        if (v27 >= 2) {
          unint64_t v27 = v29;
        }
      }
      if (*(void *)&prime <= v27) {
        int8x8_t prime = (int8x8_t)v27;
      }
      if (*(void *)&prime >= v8)
      {
        unint64_t v8 = *((void *)a1 + 1);
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          int v21 = operator new(8 * *(void *)&prime);
          unsigned int v22 = *(void **)a1;
          *(void *)a1  = v21;
          if (v22) {
            operator delete(v22);
          }
          uint64_t v23 = 0;
          *((int8x8_t *)a1 + 1)  = prime;
          do
            *(void *)(*(void *)a1 + 8 * v23++)  = 0;
          while (*(void *)&prime != v23);
          unsigned int v24 = (void *)*((void *)a1 + 2);
          if (v24)
          {
            unint64_t v25 = v24[1];
            uint8x8_t v26 = (uint8x8_t)vcnt_s8(prime);
            v26.i16[0]  = vaddlv_u8(v26);
            if (v26.u32[0] > 1uLL)
            {
              if (v25 >= *(void *)&prime) {
                v25 %= *(void *)&prime;
              }
            }
            else
            {
              v25 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)a1 + 8 * v25)  = a1 + 4;
            BOOL v30 = (void *)*v24;
            if (*v24)
            {
              do
              {
                unint64_t v31 = v30[1];
                if (v26.u32[0] > 1uLL)
                {
                  if (v31 >= *(void *)&prime) {
                    v31 %= *(void *)&prime;
                  }
                }
                else
                {
                  v31 &= *(void *)&prime - 1;
                }
                if (v31 != v25)
                {
                  if (!*(void *)(*(void *)a1 + 8 * v31))
                  {
                    *(void *)(*(void *)a1 + 8 * v31)  = v24;
                    goto LABEL_55;
                  }
                  void *v24 = *v30;
                  *BOOL v30 = **(void **)(*(void *)a1 + 8 * v31);
                  **(void **)(*(void *)a1 + 8 * v31)  = v30;
                  BOOL v30 = v24;
                }
                unint64_t v31 = v25;
LABEL_55:
                unsigned int v24 = v30;
                BOOL v30 = (void *)*v30;
                unint64_t v25 = v31;
              }
              while (v30);
            }
          }
          unint64_t v8 = (unint64_t)prime;
          goto LABEL_59;
        }
        unsigned int v35 = *(void **)a1;
        *(void *)a1  = 0;
        if (v35) {
          operator delete(v35);
        }
        unint64_t v8 = 0;
        *((void *)a1 + 1)  = 0;
      }
    }
LABEL_59:
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v8 <= v7) {
        unint64_t v10 = v7 % v8;
      }
      else {
        unint64_t v10 = v7;
      }
    }
    else
    {
      unint64_t v10 = (v8 - 1) & v7;
    }
  }
  long long v32 = *(void **)a1;
  unint64_t v33 = *(void **)(*(void *)a1 + 8 * v10);
  if (v33)
  {
    *BOOL v14 = *v33;
LABEL_72:
    void *v33 = v14;
    goto LABEL_73;
  }
  *BOOL v14 = *((void *)a1 + 2);
  *((void *)a1 + 2)  = v14;
  v32[v10]  = a1 + 4;
  if (*v14)
  {
    unint64_t v34 = *(void *)(*v14 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v34 >= v8) {
        v34 %= v8;
      }
    }
    else
    {
      v34 &= v8 - 1;
    }
    unint64_t v33 = (void *)(*(void *)a1 + 8 * v34);
    goto LABEL_72;
  }
LABEL_73:
  ++*((void *)a1 + 3);
}

void *std::__hash_table<std::__hash_value_type<unsigned int,UScriptCode>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,UScriptCode>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,UScriptCode>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,UScriptCode>>>::__emplace_unique_key_args<unsigned int,unsigned int const&,UScriptCode&>(float *a1, unsigned int *a2, _DWORD *a3, int *a4)
{
  unint64_t v7 = *a2;
  unint64_t v8 = *((void *)a1 + 1);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0]  = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v10 = *a2;
      if (v8 <= v7) {
        unint64_t v10 = v7 % v8;
      }
    }
    else
    {
      unint64_t v10 = (v8 - 1) & v7;
    }
    unsigned int v11 = *(void ***)(*(void *)a1 + 8 * v10);
    if (v11)
    {
      unsigned int v12 = *v11;
      if (*v11)
      {
        do
        {
          unint64_t v13 = v12[1];
          if (v13 == v7)
          {
            if (*((_DWORD *)v12 + 4) == v7) {
              return v12;
            }
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v13 >= v8) {
                v13 %= v8;
              }
            }
            else
            {
              v13 &= v8 - 1;
            }
            if (v13 != v10) {
              break;
            }
          }
          unsigned int v12 = (void *)*v12;
        }
        while (v12);
      }
    }
  }
  else
  {
    unint64_t v10 = 0xAAAAAAAAAAAAAAAALL;
  }
  unsigned int v12 = operator new(0x18uLL);
  void *v12 = 0;
  v12[1]  = v7;
  int v14 = *a4;
  *((_DWORD *)v12 + 4)  = *a3;
  *((_DWORD *)v12 + 5)  = v14;
  float v15 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v16 = a1[8];
  if (!v8 || (float)(v16 * (float)v8) < v15)
  {
    BOOL v17 = 1;
    if (v8 >= 3) {
      BOOL v17 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v18 = v17 | (2 * v8);
    unint64_t v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19) {
      int8x8_t prime = (int8x8_t)v19;
    }
    else {
      int8x8_t prime = (int8x8_t)v18;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v8 = *((void *)a1 + 1);
    }
    if (*(void *)&prime > v8) {
      goto LABEL_30;
    }
    if (*(void *)&prime < v8)
    {
      unint64_t v27 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v8 < 3 || (uint8x8_t v28 = (uint8x8_t)vcnt_s8((int8x8_t)v8), v28.i16[0] = vaddlv_u8(v28), v28.u32[0] > 1uLL))
      {
        unint64_t v27 = std::__next_prime(v27);
      }
      else
      {
        uint64_t v29 = 1 << -(char)__clz(v27 - 1);
        if (v27 >= 2) {
          unint64_t v27 = v29;
        }
      }
      if (*(void *)&prime <= v27) {
        int8x8_t prime = (int8x8_t)v27;
      }
      if (*(void *)&prime >= v8)
      {
        unint64_t v8 = *((void *)a1 + 1);
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          int v21 = operator new(8 * *(void *)&prime);
          unsigned int v22 = *(void **)a1;
          *(void *)a1  = v21;
          if (v22) {
            operator delete(v22);
          }
          uint64_t v23 = 0;
          *((int8x8_t *)a1 + 1)  = prime;
          do
            *(void *)(*(void *)a1 + 8 * v23++)  = 0;
          while (*(void *)&prime != v23);
          unsigned int v24 = (void *)*((void *)a1 + 2);
          if (v24)
          {
            unint64_t v25 = v24[1];
            uint8x8_t v26 = (uint8x8_t)vcnt_s8(prime);
            v26.i16[0]  = vaddlv_u8(v26);
            if (v26.u32[0] > 1uLL)
            {
              if (v25 >= *(void *)&prime) {
                v25 %= *(void *)&prime;
              }
            }
            else
            {
              v25 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)a1 + 8 * v25)  = a1 + 4;
            BOOL v30 = (void *)*v24;
            if (*v24)
            {
              do
              {
                unint64_t v31 = v30[1];
                if (v26.u32[0] > 1uLL)
                {
                  if (v31 >= *(void *)&prime) {
                    v31 %= *(void *)&prime;
                  }
                }
                else
                {
                  v31 &= *(void *)&prime - 1;
                }
                if (v31 != v25)
                {
                  if (!*(void *)(*(void *)a1 + 8 * v31))
                  {
                    *(void *)(*(void *)a1 + 8 * v31)  = v24;
                    goto LABEL_55;
                  }
                  void *v24 = *v30;
                  *BOOL v30 = **(void **)(*(void *)a1 + 8 * v31);
                  **(void **)(*(void *)a1 + 8 * v31)  = v30;
                  BOOL v30 = v24;
                }
                unint64_t v31 = v25;
LABEL_55:
                unsigned int v24 = v30;
                BOOL v30 = (void *)*v30;
                unint64_t v25 = v31;
              }
              while (v30);
            }
          }
          unint64_t v8 = (unint64_t)prime;
          goto LABEL_59;
        }
        BOOL v36 = *(void **)a1;
        *(void *)a1  = 0;
        if (v36) {
          operator delete(v36);
        }
        unint64_t v8 = 0;
        *((void *)a1 + 1)  = 0;
      }
    }
LABEL_59:
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v8 <= v7) {
        unint64_t v10 = v7 % v8;
      }
      else {
        unint64_t v10 = v7;
      }
    }
    else
    {
      unint64_t v10 = (v8 - 1) & v7;
    }
  }
  long long v32 = *(void **)a1;
  unint64_t v33 = *(void **)(*(void *)a1 + 8 * v10);
  if (v33)
  {
    void *v12 = *v33;
LABEL_72:
    void *v33 = v12;
    goto LABEL_73;
  }
  void *v12 = *((void *)a1 + 2);
  *((void *)a1 + 2)  = v12;
  v32[v10]  = a1 + 4;
  if (*v12)
  {
    unint64_t v34 = *(void *)(*v12 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v34 >= v8) {
        v34 %= v8;
      }
    }
    else
    {
      v34 &= v8 - 1;
    }
    unint64_t v33 = (void *)(*(void *)a1 + 8 * v34);
    goto LABEL_72;
  }
LABEL_73:
  ++*((void *)a1 + 3);
  return v12;
}

const __CFData *FeatureParamsForTag<OTL::CharacterVariantFeatureParams>(CFDataRef theData, int a2)
{
  CFDataRef v2 = theData;
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  if (theData)
  {
    BytePtr  = CFDataGetBytePtr(theData);
    if (!BytePtr) {
      return 0;
    }
    unint64_t v5 = (unint64_t)BytePtr;
    unsigned int v6 = CFDataGetBytePtr(v2);
    unint64_t v7 = v6 ? (unint64_t)&v6[CFDataGetLength(v2)] : 0;
    if (!*(_WORD *)(v5 + 6)) {
      return 0;
    }
    uint64_t v8 = __rev16(*(unsigned __int16 *)(v5 + 6));
    uint8x8_t v9 = (unsigned __int16 *)(v5 + v8);
    unint64_t v10 = v5 + v8 + 2;
    if (v10 > v7) {
      return 0;
    }
    unsigned int v11 = *v9;
    uint64_t v12 = __rev16(v11);
    unint64_t v13 = v10 + 6 * v12;
    if (v13 < v10 || v13 > v7)
    {
      unint64_t v15 = (v7 - v10) / 6;
      if ((unint64_t)(v9 + 4) > v7) {
        unint64_t v15 = 0;
      }
      if (v15 != v12) {
        return 0;
      }
    }
    if (*(_WORD *)(v5 + 8)
      && (float v16 = (unsigned __int16 *)(v5 + __rev16(*(unsigned __int16 *)(v5 + 8))),
          BOOL v17 = v16 + 1,
          (unint64_t)(v16 + 1) <= v7))
    {
      CFDataRef v2 = 0;
      uint64_t v19 = bswap32(*v16) >> 16;
      unint64_t v20 = (unint64_t)&v17[v19];
      if ((unint64_t)(v16 + 2) <= v7) {
        unint64_t v21 = (v7 - (unint64_t)v17) >> 1;
      }
      else {
        unint64_t v21 = 0;
      }
      if (v20 <= v7 && v20 >= (unint64_t)v17 || v21 == v19)
      {
        *(void *)&long long v24 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v24 + 1)  = 0xAAAAAAAAAAAAAAAALL;
        v40[2]  = v24;
        v40[3]  = v24;
        v40[0]  = v24;
        v40[1]  = v24;
        memset(v39, 0, sizeof(v39));
        CFRange v41 = v40;
        if (!v11) {
          goto LABEL_35;
        }
        unint64_t v25 = (unsigned __int16 *)(v8 + v5 + 6);
        uint64_t v26 = 6 * v12;
        while (bswap32(*((_DWORD *)v25 - 1)) != a2)
        {
          v25 += 3;
          v26 -= 6;
          if (!v26) {
            goto LABEL_35;
          }
        }
        unint64_t v27 = (unsigned __int16 *)((char *)v9 + (bswap32(*v25) >> 16));
        uint8x8_t v28 = v27 + 2;
        BOOL v29 = (unint64_t)(v27 + 1) < v5 || (unint64_t)v28 > v7;
        if (!v29
          && ((uint64_t v30 = bswap32(v27[1]) >> 16,
               unint64_t v31 = (unint64_t)&v28[v30],
               (unint64_t)(v27 + 3) <= v7)
            ? (unint64_t v32 = (v7 - (unint64_t)v28) >> 1)
            : (unint64_t v32 = 0),
              v31 <= v7 ? (BOOL v33 = v31 >= (unint64_t)v28) : (BOOL v33 = 0),
              !v33 ? (BOOL v34 = v32 == v30) : (BOOL v34 = 1),
              v34))
        {
          unsigned int v35 = *v27;
          CFDataRef v36 = (const __CFData *)((char *)v27 + __rev16(v35));
          if ((unint64_t)v36 + 14 > v7 || v35 == 0) {
            CFDataRef v2 = 0;
          }
          else {
            CFDataRef v2 = v36;
          }
        }
        else
        {
LABEL_35:
          CFDataRef v2 = 0;
        }
        uint64_t v38 = (void **)v39;
        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100](&v38);
      }
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

void std::__function::__func<NumberOfGlyphVariants(TBaseFont const&,unsigned int)::$_0,std::allocator<NumberOfGlyphVariants(TBaseFont const&,unsigned int)::$_0>,BOOL ()(unsigned int,OTL::FeatureTable const*,BOOL &)>::~__func()
{
}

__n128 std::__function::__func<NumberOfGlyphVariants(TBaseFont const&,unsigned int)::$_0,std::allocator<NumberOfGlyphVariants(TBaseFont const&,unsigned int)::$_0>,BOOL ()(unsigned int,OTL::FeatureTable const*,BOOL &)>::__clone(uint64_t a1)
{
  CFDataRef v2 = (char *)operator new(0x18uLL);
  *(void *)CFDataRef v2 = &unk_1ED05FDF8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8)  = result;
  return result;
}

__n128 std::__function::__func<NumberOfGlyphVariants(TBaseFont const&,unsigned int)::$_0,std::allocator<NumberOfGlyphVariants(TBaseFont const&,unsigned int)::$_0>,BOOL ()(unsigned int,OTL::FeatureTable const*,BOOL &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2  = &unk_1ED05FDF8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8)  = result;
  return result;
}

uint64_t std::__function::__func<NumberOfGlyphVariants(TBaseFont const&,unsigned int)::$_0,std::allocator<NumberOfGlyphVariants(TBaseFont const&,unsigned int)::$_0>,BOOL ()(unsigned int,OTL::FeatureTable const*,BOOL &)>::operator()(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  if (**(_DWORD **)(a1 + 8) == *a2 && *(_WORD *)(*(void *)a3 + 2))
  {
    unint64_t v4 = (unsigned __int16 *)(*(void *)a3 + 4);
    uint64_t v5 = 2 * __rev16(*(unsigned __int16 *)(*(void *)a3 + 2));
    do
    {
      unsigned int v6 = *v4++;
      __int16 v8 = bswap32(v6) >> 16;
      STL::insert_sorted<TInlineVector<unsigned short,30ul>>(*(void **)(a1 + 16), (char *)&v8);
      v5 -= 2;
    }
    while (v5);
  }
  return 1;
}

char *STL::insert_sorted<TInlineVector<unsigned short,30ul>>(void *a1, char *a2)
{
  unint64_t v4 = (char *)*a1;
  uint8x8_t v3 = (char *)a1[1];
  if (v3 != (char *)*a1)
  {
    unint64_t v5 = (uint64_t)&v3[-*a1] >> 1;
    do
    {
      unint64_t v6 = v5 >> 1;
      unint64_t v7 = &v4[2 * (v5 >> 1)];
      unsigned int v9 = *(unsigned __int16 *)v7;
      __int16 v8 = (unsigned __int16 *)(v7 + 2);
      v5 += ~(v5 >> 1);
      if (v9 < *(unsigned __int16 *)a2) {
        unint64_t v4 = (char *)v8;
      }
      else {
        unint64_t v5 = v6;
      }
    }
    while (v5);
    uint8x8_t v3 = v4;
  }
  return std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::insert((uint64_t)a1, v3, a2);
}

char *std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::insert(uint64_t a1, char *__src, char *a3)
{
  uint8x8_t v3 = a3;
  unint64_t v4 = __src;
  unint64_t v6 = *(char **)(a1 + 8);
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    uint64_t v12 = *(char **)a1;
    uint64_t v13 = (uint64_t)&v6[-*(void *)a1];
    unint64_t v31 = 0xAAAAAAAAAAAAAAAALL;
    if (v13 <= -3) {
      abort();
    }
    uint64_t v14 = __src - v12;
    uint64_t v15 = (__src - v12) >> 1;
    uint64_t v16 = v13 >> 1;
    unint64_t v17 = v7 - (void)v12;
    if (v17 <= v16 + 1) {
      unint64_t v18 = v16 + 1;
    }
    else {
      unint64_t v18 = v17;
    }
    if (v17 >= 0x7FFFFFFFFFFFFFFELL) {
      uint64_t v19 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v19 = v18;
    }
    uint64_t v33 = a1 + 24;
    if (v19) {
      unint64_t v20 = (char *)TInlineBufferAllocator<unsigned short,30ul>::allocate(a1 + 24, v19);
    }
    else {
      unint64_t v20 = 0;
    }
    unint64_t v21 = &v20[2 * v15];
    BOOL v29 = v20;
    uint64_t v30 = v21;
    unsigned int v22 = &v20[2 * v19];
    unint64_t v32 = v22;
    if (v15 == v19)
    {
      if (v14 < 1)
      {
        if (v12 == v4) {
          unint64_t v24 = 1;
        }
        else {
          unint64_t v24 = v4 - v12;
        }
        uint64_t v38 = a1 + 24;
        unint64_t v25 = (char *)TInlineBufferAllocator<unsigned short,30ul>::allocate(a1 + 24, v24);
        uint64_t v26 = &v25[2 * (v24 >> 2)];
        BOOL v29 = v25;
        uint64_t v30 = v26;
        BOOL v34 = v20;
        unsigned int v35 = &v20[2 * v15];
        unint64_t v32 = &v25[2 * v24];
        CFDataRef v36 = v35;
        uint64_t v37 = v22;
        std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,30ul> &>::~__split_buffer((uint64_t)&v34);
        unint64_t v21 = v26;
      }
      else
      {
        uint64_t v23 = v15 + 2;
        if (v15 >= -1) {
          uint64_t v23 = v15 + 1;
        }
        v21 -= v23 & 0xFFFFFFFFFFFFFFFELL;
        uint64_t v30 = v21;
      }
    }
    *(_WORD *)unint64_t v21 = *(_WORD *)a3;
    unint64_t v31 = (unint64_t)(v21 + 2);
    unint64_t v4 = std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__swap_out_circular_buffer((void **)a1, (uint64_t)&v29, v4);
    std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,30ul> &>::~__split_buffer((uint64_t)&v29);
  }
  else if (__src == v6)
  {
    *(_WORD *)__src  = *(_WORD *)a3;
    *(void *)(a1 + 8)  = __src + 2;
  }
  else
  {
    __int16 v8 = __src + 2;
    unsigned int v9 = v6 - 2;
    unint64_t v10 = *(_WORD **)(a1 + 8);
    while (v9 < v6)
    {
      __int16 v11 = *(_WORD *)v9;
      v9 += 2;
      *v10++  = v11;
    }
    *(void *)(a1 + 8)  = v10;
    if (v6 != v8) {
      memmove(&v6[-2 * ((v6 - v8) >> 1)], __src, v6 - v8);
    }
    if (v4 <= v3) {
      v3 += 2 * (*(void *)(a1 + 8) > (unint64_t)v3);
    }
    *(_WORD *)unint64_t v4 = *(_WORD *)v3;
  }
  return v4;
}

void std::__function::__func<NumberOfGlyphVariants(TBaseFont const&,unsigned int)::$_1,std::allocator<NumberOfGlyphVariants(TBaseFont const&,unsigned int)::$_1>,BOOL ()(unsigned short,unsigned short,unsigned short)>::~__func()
{
}

__n128 std::__function::__func<NumberOfGlyphVariants(TBaseFont const&,unsigned int)::$_1,std::allocator<NumberOfGlyphVariants(TBaseFont const&,unsigned int)::$_1>,BOOL ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  CFDataRef v2 = (char *)operator new(0x20uLL);
  *(void *)CFDataRef v2 = &unk_1ED05FE40;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8)  = result;
  *((void *)v2 + 3)  = *(void *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<NumberOfGlyphVariants(TBaseFont const&,unsigned int)::$_1,std::allocator<NumberOfGlyphVariants(TBaseFont const&,unsigned int)::$_1>,BOOL ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2  = &unk_1ED05FE40;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24)  = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8)  = result;
  return result;
}

uint64_t std::__function::__func<NumberOfGlyphVariants(TBaseFont const&,unsigned int)::$_1,std::allocator<NumberOfGlyphVariants(TBaseFont const&,unsigned int)::$_1>,BOOL ()(unsigned short,unsigned short,unsigned short)>::operator()(uint64_t a1, unsigned __int16 *a2, unsigned __int16 *a3, __int16 *a4)
{
  unsigned int v4 = *a2;
  unsigned int v5 = *a3;
  uint64_t v6 = 1;
  if (v4 <= v5 && v4 != (unsigned __int16)(v5 + 1))
  {
    uint64_t v7 = **(void **)(a1 + 8);
    unint64_t v8 = **(void **)(a1 + 16);
    unint64_t v9 = v7 + 6;
    if (v7 + 8 <= v8) {
      unint64_t v10 = (v8 - (v7 + 6)) >> 1;
    }
    else {
      unint64_t v10 = 0;
    }
    if (v8 < v9)
    {
      return 0;
    }
    else
    {
      __int16 v11 = *a4;
      uint64_t v12 = *(_WORD **)(a1 + 24);
      unsigned __int16 v13 = *a2;
      do
      {
        unsigned __int16 v14 = v13 - v4 + v11;
        uint64_t v15 = bswap32(*(unsigned __int16 *)(v7 + 4)) >> 16;
        unint64_t v16 = v9 + 2 * v15;
        if (v16 < v9 || v16 > v8)
        {
          BOOL v18 = v15 > v14 && v10 == v15;
          if (!v18) {
            return 0;
          }
        }
        else if (v15 <= v14)
        {
          return 0;
        }
        uint64_t v19 = (unsigned __int16 *)(v7 + (bswap32(*(unsigned __int16 *)(v7 + 2 * v14 + 6)) >> 16));
        unint64_t v20 = v19 + 1;
        if ((unint64_t)(v19 + 1) > v8) {
          return 0;
        }
        uint64_t v21 = bswap32(*v19) >> 16;
        unint64_t v22 = (unint64_t)&v20[v21];
        unint64_t v23 = (unint64_t)(v19 + 2) <= v8 ? (v8 - (unint64_t)v20) >> 1 : 0;
        BOOL v24 = v22 <= v8 && v22 >= (unint64_t)v20;
        if (!v24 && v23 != v21) {
          return 0;
        }
        unsigned int v26 = (unsigned __int16)*v12;
        if (v26 <= v21) {
          LOWORD(v26)  = v21;
        }
        _WORD *v12 = v26;
        BOOL v18 = v5 == v13++;
      }
      while (!v18);
      return 1;
    }
  }
  return v6;
}

void *TTruncator::TruncateEndWhitespace(TTruncator *this, double a2)
{
  uint64_t v4 = *((void *)this + 3);
  uint64_t v3 = *((void *)this + 4);
  *(_OWORD *)(v3 + 72)  = *(_OWORD *)(v4 + 72);
  TTruncator::TruncateEndChars(this, *(void *)(v4 + 80) + *(void *)(v4 + 72), a2, (TLine *)v3, (BOOL *)&v8);

  return TTruncator::HandleLeveledRuns(this, v5, v6);
}

unint64_t TTruncator::TruncateWithToken(TTruncator *this, double a2, int64x2_t *a3, CTLineTruncationType a4, const __CTLine *a5)
{
  uint64_t v9 = *((void *)this + 3);
  unsigned __int8 v8 = (TLine *)*((void *)this + 4);
  CFIndex v11 = *(void *)(v9 + 72);
  uint64_t v10 = *(void *)(v9 + 80);
  uint64_t v12 = v10 + v11;
  unsigned __int8 v50 = -86;
  uint64_t v13 = *((void *)a5 + 5);
  double v14 = *(double *)this + a2 - *(double *)(v13 + 104);
  *((void *)v8 + 9)  = v11;
  *((void *)v8 + 10)  = v10;
  if (a4 == kCTLineTruncationMiddle)
  {
    double v20 = v14 * 0.5;
    unsigned __int8 v49 = -86;
    CFIndex v21 = TTruncator::TruncateEndChars(this, v12, v14 * 0.5, v8, (BOOL *)&v49);
    uint64_t v23 = v22;
    double v24 = v20 + *(double *)this;
    unsigned __int8 v48 = -86;
    started  = TTruncator::TruncateStartChars(this, v11, v24, a3, (BOOL *)&v48);
    if (v21 + v23 >= started + v26) {
      CFIndex v27 = started + v26;
    }
    else {
      CFIndex v27 = v21 + v23;
    }
    if (started <= v21 && v21 < started + v26)
    {
      uint64_t v46 = v27 - v21;
      unint64_t v47 = v21;
    }
    else if (v21 <= started && started < v21 + v23)
    {
      uint64_t v46 = v27 - started;
      unint64_t v47 = started;
    }
    else
    {
      uint64_t v46 = 0;
      unint64_t v47 = 0;
    }
    unsigned __int8 v30 = v49;
    if (v49 <= v48) {
      unsigned __int8 v30 = v48;
    }
    unsigned __int8 v50 = ((v30 ^ (*(unsigned char *)(v13 + 152) >> 3)) & 1) + v30;
    goto LABEL_24;
  }
  if (a4 == kCTLineTruncationEnd)
  {
    CFIndex v18 = TTruncator::TruncateEndChars(this, v12, v14, v8, (BOOL *)&v50);
    uint64_t v46 = v19;
    unint64_t v47 = v18;
LABEL_24:
    unint64_t v17 = (uint64_t)(*(void *)(*((void *)this + 4) + 24) - *(void *)(*((void *)this + 4) + 16)) >> 3;
    goto LABEL_25;
  }
  if (a4)
  {
    uint64_t v46 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v47 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v17 = 0xAAAAAAAAAAAAAAABLL;
  }
  else
  {
    CFIndex v15 = TTruncator::TruncateStartChars(this, v11, v14, (int64x2_t *)v8, (BOOL *)&v50);
    uint64_t v46 = v16;
    unint64_t v47 = v15;
    unint64_t v17 = 0;
  }
LABEL_25:
  uint64_t v44 = *(void *)(v13 + 80);
  uint64_t v45 = *(void *)(v13 + 24) - *(void *)(v13 + 16);
  if (v45 >= 1)
  {
    int v31 = v50;
    unint64_t v32 = v47 - *(void *)(v13 + 72);
    uint64_t v33 = ((unint64_t)v45 >> 3) - 1;
    do
    {
      id v51 = (id)0xAAAAAAAAAAAAAAAALL;
      (*(void (**)(id *__return_ptr))(*(void *)(*(void *)(v13 + 16) + 8 * v33) + 56))(&v51);
      uint64_t v34 = *(void *)(atomic_load_explicit((atomic_ullong *volatile)&v51, memory_order_acquire) + 48);
      unsigned int v35 = objc_msgSend(*(id *)(v34 + 216), "copyWithRange:", *(void *)(v34 + 200), *(void *)(v34 + 208));

      *(void *)(v34 + 216)  = v35;
      *(void *)(v34 + 200)  = 0;
      *(void *)(v34 + 8) += v32;
      objc_msgSend(v35, "puntStringIndicesInRange:by:", 0, *(void *)(v34 + 208), v32);
      if (*(unsigned __int8 *)(v34 + 224) != v31) {
        *(unsigned char *)(v34 + 224)  = v31;
      }
      TLine::InsertRun(*((TLine **)this + 4), v17, (const TRun **)atomic_load_explicit((atomic_ullong *volatile)&v51, memory_order_acquire));

      unint64_t v36 = v33-- + 1;
    }
    while (v36 > 1);
  }
  if (v46 > 0)
  {
    uint64_t v37 = (TLine *)*((void *)this + 4);
    if ((uint64_t)(*((void *)v37 + 3) - *((void *)v37 + 2)) >= 1 && (uint64_t)(v47 + v44 - 1) >= 0)
    {
      uint64_t v38 = *(void *)(*(void *)(*(void *)(*((void *)this + 4) + 16)
                                  + 8 * TLine::FindRunWithCharIndex(v37, v47 + v44 - 1, 1))
                      + 48);
      if (v45 <= 0)
      {
        uint64_t v39 = objc_msgSend(*(id *)(v38 + 216), "copyWithRange:", *(void *)(v38 + 200), *(void *)(v38 + 208));

        *(void *)(v38 + 216)  = v39;
        *(void *)(v38 + 200)  = 0;
      }
      uint64_t v40 = *(void *)(v38 + 8);
      uint64_t v41 = *(void *)(v38 + 16);
      uint64_t GlyphIndexForChar = TRun::GetGlyphIndexForCharIndex<false>(v38, v47 + v44 - 1);
      objc_msgSend(*(id *)(v38 + 216), "setAttachmentCount:atIndex:", objc_msgSend(*(id *)(v38 + 216), "attachmentCountAtIndex:", *(void *)(v38 + 200) + GlyphIndexForChar)+ v46- v44, *(void *)(v38 + 200) + GlyphIndexForChar);
      *(void *)(v38 + 8)  = v40;
      *(void *)(v38 + 16)  = v41 + v46 - v44;
    }
  }
  return v47;
}

unint64_t TTruncator::AppendLine(unint64_t this, const TLine *a2)
{
  uint64_t v2 = *((void *)a2 + 3) - *((void *)a2 + 2);
  if (v2 >= 1)
  {
    uint64_t v4 = this;
    uint64_t v5 = 0;
    uint64_t v6 = (unint64_t)v2 >> 3;
    if (v6 <= 1) {
      uint64_t v7 = 1;
    }
    else {
      uint64_t v7 = v6;
    }
    do
    {
      uint64_t v8 = *(void *)(*((void *)a2 + 2) + 8 * v5);
      this  = TLine::InsertPartialRun(*(TLine **)(v4 + 32), (uint64_t)(*(void *)(*(void *)(v4 + 32) + 24) - *(void *)(*(void *)(v4 + 32) + 16)) >> 3, v8, *(void *)(*(void *)(v8 + 40) + 8), *(void *)(*(void *)(v8 + 40) + 16));
      ++v5;
    }
    while (v7 != v5);
  }
  return this;
}

CFIndex TTruncator::TruncateStartChars(TTruncator *this, CFIndex a2, double a3, int64x2_t *a4, BOOL *a5)
{
  uint64_t v5 = *((void *)this + 3);
  uint64_t v6 = *(void *)(v5 + 72);
  uint64_t v7 = *(void *)(v5 + 80) + v6;
  *a5  = (*(unsigned char *)(v5 + 152) & 8) != 0;
  v58.CFIndex location = a2;
  uint64_t v8 = v7 - a2;
  if (v7 != a2)
  {
    uint64_t v56 = v7;
    uint64_t v57 = v6;
    uint64_t v12 = v7 - 1;
    if (v8 < 1)
    {
      uint64_t v13 = 0;
      uint64_t RunWithCharIndex = 0;
      uint64_t v16 = 0;
    }
    else
    {
      uint64_t v13 = 0;
      double v14 = (double *)MEMORY[0x1E4F1DB30];
      do
      {
        uint64_t RunWithCharIndex = TLine::FindRunWithCharIndex(*((TLine **)this + 3), v12, 1);
        uint64_t v16 = *(void *)(*(void *)(*(void *)(*((void *)this + 3) + 16) + 8 * RunWithCharIndex) + 40);
        CFIndex v17 = *(void *)(v16 + 8);
        if (v17 < v58.location) {
          break;
        }
        uint64_t v18 = *(void *)(v16 + 16);
        double v19 = *(double *)(v16 + 192);
        double v20 = *(double **)(v16 + 312);
        if (!v20) {
          double v20 = v14;
        }
        double v21 = *v20;
        Table  = GetTable();
        double v23 = 0.0002;
        if (Table)
        {
          double v24 = (double *)*((void *)Table + 8);
          double v23 = 0.0002;
          if (v24) {
            double v23 = *v24;
          }
        }
        if (v19 + v21 - a3 > v23)
        {
          *a5  = *(unsigned char *)(v16 + 224);
          break;
        }
        v13 += v18;
        unint64_t v25 = *(double **)(v16 + 312);
        if (!v25) {
          unint64_t v25 = v14;
        }
        a3  = a3 - (*(double *)(v16 + 192) + *v25);
        uint64_t v12 = v17 - 1;
      }
      while (v13 < v8);
    }
    uint64_t v26 = v8 - v13;
    if (v8 - v13 >= 1)
    {
      uint64_t v27 = *(void *)(*(void *)(*((void *)this + 3) + 16) + 8 * RunWithCharIndex);
      uint64_t v16 = *(void *)(v27 + 40);
      v59.CFIndex location = v58.location;
      v59.CFIndex length = v8 - v13;
      uint64_t v28 = TRun::CountCharsInWidth((TRun *)v16, v59, a3, -1);
      if (v28 >= 1)
      {
        uint64_t v29 = v28;
        TTruncator::AppendTruncatedRun((uint64_t)this, a4, v27, v12 - v28 + 1, v28, 0);
        v26 -= v29;
        uint64_t v30 = a4[1].i64[0];
        if (a4[1].i64[1] - v30 >= 1)
        {
          int v31 = *(void **)v30;
          unint64_t v32 = *(uint64_t **)(*(void *)v30 + 40);
          TRun::GetLeadingWhitespace(v32, (double *)&v58.length);
          CFIndex length = v58.length;
          if (v58.length >= 1)
          {
            id v34 = v31;
            uint64_t v35 = v32[1];
            uint64_t v36 = v32[2];
            TLine::ClearLine((TLine *)a4);
            if (v36 > length) {
              TTruncator::AppendTruncatedRun((uint64_t)this, a4, (uint64_t)v31, v35 + length, v36 - length, 0);
            }
            v26 += length;
            TLine::SyncWithRuns((TLine *)a4);
          }
        }
      }
    }
    uint64_t v37 = *(void *)(v16 + 16) + *(void *)(v16 + 8);
    if (a4[1].i64[1] == a4[1].i64[0])
    {
      uint64_t v44 = *(void *)(*((void *)this + 3) + 80) + *(void *)(*((void *)this + 3) + 72);
      while (v37 < v44)
      {
        uint64_t v45 = *(void *)(*(void *)(*((void *)this + 3) + 16)
                        + 8 * TLine::FindRunWithCharIndex(*((TLine **)this + 3), v37, 1));
        uint64_t v46 = *(uint64_t **)(v45 + 40);
        TRun::GetLeadingWhitespace(v46, (double *)&v58.length);
        if (!v58.length) {
          break;
        }
        v26 += v58.length;
        uint64_t v47 = v46[2];
        if (v47 > v58.length)
        {
          uint64_t v53 = v46[1];
          TTruncator::AppendTruncatedRun((uint64_t)this, a4, v45, v53 + v58.length, v47 - v58.length, 0);
          uint64_t v37 = v53 + v47;
          TLine::SyncWithRuns((TLine *)a4);
          break;
        }
        v37 += v47;
      }
    }
    uint64_t v38 = (*(uint64_t (**)(void, uint64_t, uint64_t))(***((void ***)this + 3) + 40))(**((void **)this + 3), v26 + v58.location - 1, 2);
    if (v38 + v39 >= v56) {
      uint64_t v40 = v56;
    }
    else {
      uint64_t v40 = v38 + v39;
    }
    if (v57 <= v38 && v38 < v56)
    {
      uint64_t v43 = v40 - v38;
    }
    else if (v38 <= v57 && v57 < v38 + v39)
    {
      uint64_t v43 = v40 - v57;
      uint64_t v38 = v57;
    }
    else
    {
      uint64_t v38 = 0;
      uint64_t v43 = 0;
    }
    uint64_t v48 = v38 + v43;
    if (v26 + v58.location < v38 + v43)
    {
      if (a4[1].i64[1] - a4[1].i64[0] >= 1) {
        TLine::ClearLine((TLine *)a4);
      }
      uint64_t v49 = *(void *)(*(void *)(*((void *)this + 3) + 16)
                      + 8 * TLine::FindRunWithCharIndex(*((TLine **)this + 3), v48, 1));
      uint64_t v37 = *(void *)(*(void *)(v49 + 40) + 16) + *(void *)(*(void *)(v49 + 40) + 8);
      if (v37 <= v48) {
        uint64_t v37 = v48;
      }
      else {
        TTruncator::AppendTruncatedRun((uint64_t)this, a4, v49, v48, v37 - v48, 0);
      }
    }
    uint64_t v50 = *(void *)(*((void *)this + 3) + 80) + *(void *)(*((void *)this + 3) + 72);
    while (v37 < v50)
    {
      uint64_t v51 = *(void *)(*(void *)(*((void *)this + 3) + 16)
                      + 8 * TLine::FindRunWithCharIndex(*((TLine **)this + 3), v37, 1));
      uint64_t v52 = *(void *)(v51 + 40);
      TLine::InsertPartialRun((TLine *)a4, (a4[1].i64[1] - a4[1].i64[0]) >> 3, v51, *(void *)(v52 + 8), *(void *)(v52 + 16));
      v37 += *(void *)(v52 + 16);
    }
  }
  return v58.location;
}

uint64_t TTruncator::AppendToken(TLine **this, CFRange a2, double a3)
{
  CFIndex length = a2.length;
  CFIndex location = a2.location;
  TTruncator::TruncateEndChars((TTruncator *)this, a2.location, a3, this[4], (BOOL *)&v10);
  uint64_t result = TTruncator::NoRunAdded((uint64_t)this, 0, 0, -1, a3);
  if ((result & 1) == 0)
  {
    uint64_t result = TTruncator::CreateAndAppendToken((uint64_t)this, location, length, 1.79769313e308, 0, 0);
    if (result)
    {
      return (uint64_t)TTruncator::HandleLeveledRuns((TTruncator *)this, v8, v9);
    }
  }
  return result;
}

void TAATPropTable::TAATPropTable(TAATPropTable *this, const __CTFont *a2)
{
  (*(void (**)(void, uint64_t))(**(void **)(*((void *)a2 + 5) + 400) + 480))(*(void *)(*((void *)a2 + 5) + 400), 1886547824);
  CFDataRef v4 = (const __CFData *)(id)atomic_load_explicit((atomic_ullong *volatile)this, memory_order_acquire);
  CFDataRef v5 = v4;
  if (v4) {
    BytePtr  = CFDataGetBytePtr(v4);
  }
  else {
    BytePtr  = 0;
  }

  *((void *)this + 1)  = BytePtr;
  CFDataRef Length = (const __CFData *)(id)atomic_load_explicit((atomic_ullong *volatile)this, memory_order_acquire);
  CFDataRef v8 = Length;
  if (Length) {
    CFDataRef Length = (const __CFData *)CFDataGetLength(Length);
  }
  unint64_t v9 = (unint64_t)Length + (void)BytePtr;

  *((void *)this + 2)  = v9;
  *((void *)this + 3)  = TAATPropTable::GetNullPropertiesForGlyph;
  *((void *)this + 4)  = 0;
  uint64_t v10 = *((void *)this + 1);
  if (v10)
  {
    if (v10 + 8 <= v9 && (int)bswap32(*(_DWORD *)v10) <= 196608)
    {
      unsigned int v11 = bswap32(*(unsigned __int16 *)(v10 + 4)) >> 16;
      if (v11 == 1)
      {
        if (v10 + 10 <= v9)
        {
          switch(bswap32(*(unsigned __int16 *)(v10 + 8)) >> 16)
          {
            case 0u:
              goto LABEL_35;
            case 2u:
            case 4u:
            case 6u:
              if (v10 + 14 > v9) {
                goto LABEL_14;
              }
              unint64_t v13 = v10 + 20;
              unsigned int v14 = bswap32(*(unsigned __int16 *)(v10 + 10)) >> 16;
              unsigned int v15 = *(unsigned __int16 *)(v10 + 12);
              goto LABEL_31;
            case 8u:
              unint64_t v16 = v10 + 14;
              if (v10 + 14 > v9) {
                goto LABEL_14;
              }
              uint64_t v17 = bswap32(*(unsigned __int16 *)(v10 + 12)) >> 16;
              unint64_t v18 = v16 + 2 * v17;
              unint64_t v19 = v10 + 16 <= v9 ? (v9 - v16) >> 1 : 0;
              BOOL v20 = v18 <= v9 && v18 >= v16;
              if (!v20 && v19 != v17) {
                goto LABEL_14;
              }
              goto LABEL_35;
            case 0xAu:
              unint64_t v13 = v10 + 16;
              if (v10 + 16 > v9) {
                goto LABEL_14;
              }
              unsigned int v14 = bswap32(*(unsigned __int16 *)(v10 + 10)) >> 16;
              unsigned int v15 = *(unsigned __int16 *)(v10 + 14);
LABEL_31:
              unint64_t v21 = v13 + (bswap32(v15) >> 16) * (unint64_t)v14;
              if (v21 < v13 || v21 > v9) {
                goto LABEL_14;
              }
LABEL_35:
              uint64_t v12 = TAATPropTable::GetPropertiesForGlyph;
              break;
            default:
              goto LABEL_14;
          }
          goto LABEL_12;
        }
      }
      else if (!v11)
      {
        uint64_t v12 = TAATPropTable::GetDefaultPropertiesForGlyph;
LABEL_12:
        *((void *)this + 3)  = v12;
        *((void *)this + 4)  = 0;
        return;
      }
    }
LABEL_14:
    CFLog();
    (*(void (**)(void))(**(void **)(*((void *)a2 + 5) + 400) + 488))(*(void *)(*((void *)a2 + 5) + 400));
    *((void *)this + 1)  = 0;
  }
}

uint64_t TAATPropTable::GetNullPropertiesForGlyph(TAATPropTable *this)
{
  return 0;
}

uint64_t TAATPropTable::GetDefaultPropertiesForGlyph(TAATPropTable *this)
{
  return bswap32(*(unsigned __int16 *)(*((void *)this + 1) + 6)) >> 16;
}

uint64_t TAATPropTable::GetPropertiesForGlyph(TAATPropTable *this, uint64_t a2)
{
  *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  long long v15 = v4;
  long long v16 = v4;
  CFDataRef v5 = (SFNTLookupTable *)*((void *)this + 2);
  uint64_t v6 = (const SFNTLookupTable *)(*((void *)this + 1) + 8);
  unint64_t v13 = TAATLookupTable::BadTable;
  uint64_t v14 = 0;
  *((void *)&v16 + 1)  = 0;
  unint64_t v17 = 0xAAAAAAAAAAAAFFFFLL;
  TAATLookupTable::SetTable((uint64_t)&v13, v6, v5);
  unint64_t v18 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v7 = v13;
  CFDataRef v8 = (TAATLookupTable *)((char *)&v13 + (v14 >> 1));
  if (v14) {
    uint64_t v7 = *(uint64_t (**)(TAATLookupTable *, unsigned __int16, unint64_t *))(*(void *)v8
  }
                                                                                           + v13);
  unint64_t v9 = (unsigned __int16 *)v7(v8, a2, &v18);
  unint64_t v10 = *((void *)this + 1);
  if (!v9
    || (v10 <= (unint64_t)v9 ? (BOOL v11 = (unint64_t)(v9 + 1) > *((void *)this + 2)) : (BOOL v11 = 1), v11))
  {
    unint64_t v9 = (unsigned __int16 *)(v10 + 6);
  }
  return bswap32(*v9) >> 16;
}

uint64_t TAATPropTable::MirrorGlyph(TAATPropTable *this, unsigned __int16 *a2)
{
  uint64_t v3 = *a2;
  long long v4 = (uint64_t (*)(void *, uint64_t))*((void *)this + 3);
  uint64_t v5 = *((void *)this + 4);
  uint64_t v6 = (void *)((char *)this + (v5 >> 1));
  if (v5) {
    long long v4 = *(uint64_t (**)(void *, uint64_t))(*v6 + v4);
  }
  unsigned int v7 = v4(v6, v3);
  if ((v7 & 0x1000) != 0)
  {
    int v8 = (v7 >> 8) | 0xF8;
    if (((v7 >> 8) & 8) == 0) {
      LOBYTE(v8)  = BYTE1(v7) & 0xF;
    }
    *a2 += (char)v8;
  }
  return (v7 >> 12) & 1;
}

CFTypeID CTGlyphInfoGetTypeID(void)
{
  if (TCFBase<TNativeGlyphInfo>::GetTypeID(void)::once != -1) {
    dispatch_once_f(&TCFBase<TNativeGlyphInfo>::GetTypeID(void)::once, 0, (dispatch_function_t)TCFBase<TNativeGlyphInfo>::GetTypeID(void)::{lambda(void *)#1}::__invoke);
  }
  return TCFBase<TNativeGlyphInfo>::fTypeID;
}

CTGlyphInfoRef CTGlyphInfoCreateWithGlyphName(CFStringRef glyphName, CTFontRef font, CFStringRef baseString)
{
  v6[3]  = (id)glyphName;
  v6[1]  = (id)baseString;
  id v6[2] = font;
  if (!glyphName) {
    return 0;
  }
  uint64_t v3 = 0;
  if (font && baseString)
  {
    if (TFont::GetGlyphWithName(*((TFont **)font + 5), glyphName))
    {
      v6[0]  = (id)0xAAAAAAAAAAAAAAAALL;
      TCFBase_NEW<CTGlyphInfo,__CFString const*&,__CTFont const*&,__CFString const*&>(&v5);
      v6[0]  = (id)atomic_exchange((atomic_ullong *volatile)&v5, 0);

      uint64_t v3 = (const __CTGlyphInfo *)atomic_exchange((atomic_ullong *volatile)v6, 0);
      return v3;
    }
    return 0;
  }
  return v3;
}

void *TCFBase_NEW<CTGlyphInfo,__CFString const*&,__CTFont const*&,__CFString const*&>@<X0>(void *a1@<X8>)
{
  uint64_t result = (void *)TCFBase<TNativeGlyphInfo>::Allocate();
  if (result)
  {
    result[2]  = 0;
    result[3]  = 0;
    result[4]  = 0;
    result[5]  = result + 6;
    operator new();
  }
  *a1  = 0;
  return result;
}

CTGlyphInfoRef CTGlyphInfoCreateWithGlyph(CGGlyph glyph, CTFontRef font, CFStringRef baseString)
{
  uint64_t v3 = 0;
  CGGlyph v9 = glyph;
  CFStringRef v7 = baseString;
  CTFontRef v8 = font;
  if (font && baseString)
  {
    if (TBaseFont::GetGlyphCount(*(TBaseFont **)(*((void *)font + 5) + 400)) <= glyph)
    {
      return 0;
    }
    else
    {
      id v6 = (id)0xAAAAAAAAAAAAAAAALL;
      TCFBase_NEW<CTGlyphInfo,unsigned short &,__CTFont const*&,__CFString const*&>(&v9, &v8, &v7, &v5);
      id v6 = (id)atomic_exchange((atomic_ullong *volatile)&v5, 0);

      uint64_t v3 = (const __CTGlyphInfo *)atomic_exchange((atomic_ullong *volatile)&v6, 0);
    }
  }
  return v3;
}

uint64_t TCFBase_NEW<CTGlyphInfo,unsigned short &,__CTFont const*&,__CFString const*&>@<X0>(unsigned __int16 *a1@<X0>, const __CTFont **a2@<X1>, const __CFString **a3@<X2>, void *a4@<X8>)
{
  uint64_t result = TCFBase<TNativeGlyphInfo>::Allocate();
  if (result)
  {
    CGGlyph v9 = (void *)result;
    unsigned __int16 v10 = *a1;
    BOOL v11 = *a2;
    CFStringRef v12 = *a3;
    unint64_t v13 = (TNativeGlyphInfo *)(result + 48);
    v9[2]  = 0;
    v9[3]  = 0;
    v9[4]  = 0;
    void v9[5] = v13;
    TNativeGlyphInfo::TNativeGlyphInfo(v13, v10, v11, v12);
  }
  *a4  = 0;
  return result;
}

CTGlyphInfoRef CTGlyphInfoCreateWithCharacterIdentifier(CGFontIndex cid, CTCharacterCollection collection, CFStringRef baseString)
{
  uint64_t v3 = 0;
  CGFontIndex v8 = cid;
  CTCharacterCollection v7 = collection;
  v6[1]  = (id)baseString;
  if (collection <= kCTCharacterCollectionAdobeKorea1 && cid != 0xFFFF && baseString)
  {
    v6[0]  = (id)0xAAAAAAAAAAAAAAAALL;
    TCFBase_NEW<CTGlyphInfo,unsigned short &,CTCharacterCollection &,__CFString const*&>(&v5);
    v6[0]  = (id)atomic_exchange((atomic_ullong *volatile)&v5, 0);

    uint64_t v3 = (const __CTGlyphInfo *)atomic_exchange((atomic_ullong *volatile)v6, 0);
  }
  return v3;
}

void *TCFBase_NEW<CTGlyphInfo,unsigned short &,CTCharacterCollection &,__CFString const*&>@<X0>(void *a1@<X8>)
{
  uint64_t result = (void *)TCFBase<TNativeGlyphInfo>::Allocate();
  if (result)
  {
    result[2]  = 0;
    result[3]  = 0;
    result[4]  = 0;
    result[5]  = result + 6;
    operator new();
  }
  *a1  = 0;
  return result;
}

CFStringRef CTGlyphInfoGetGlyphName(CTGlyphInfoRef glyphInfo)
{
  if (!glyphInfo) {
    return 0;
  }
  v4[0]  = (id)0xAAAAAAAAAAAAAAAALL;
  v4[1]  = (id)0xAAAAAAAAAAAAAAAALL;
  TGlyphInfo::TGlyphInfo((TGlyphInfo *)v4, glyphInfo);
  uint64_t v1 = **(void **)(atomic_load_explicit((atomic_ullong *volatile)v4, memory_order_acquire) + 40);
  CFStringRef v2 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(void *)v1 + 32))(v1);

  return v2;
}

CGFontIndex CTGlyphInfoGetCharacterIdentifier(CTGlyphInfoRef glyphInfo)
{
  if (!glyphInfo) {
    return -1;
  }
  v4[0]  = (id)0xAAAAAAAAAAAAAAAALL;
  v4[1]  = (id)0xAAAAAAAAAAAAAAAALL;
  TGlyphInfo::TGlyphInfo((TGlyphInfo *)v4, glyphInfo);
  uint64_t v1 = **(void **)(atomic_load_explicit((atomic_ullong *volatile)v4, memory_order_acquire) + 40);
  CGFontIndex v2 = (*(uint64_t (**)(uint64_t))(*(void *)v1 + 40))(v1);

  return v2;
}

CTCharacterCollection CTGlyphInfoGetCharacterCollection(CTGlyphInfoRef glyphInfo)
{
  if (!glyphInfo) {
    return 0;
  }
  v4[0]  = (id)0xAAAAAAAAAAAAAAAALL;
  v4[1]  = (id)0xAAAAAAAAAAAAAAAALL;
  TGlyphInfo::TGlyphInfo((TGlyphInfo *)v4, glyphInfo);
  uint64_t v1 = **(void **)(atomic_load_explicit((atomic_ullong *volatile)v4, memory_order_acquire) + 40);
  CTCharacterCollection v2 = (*(unsigned __int16 (**)(uint64_t))(*(void *)v1 + 48))(v1);

  return v2;
}

unint64_t _CTGlyphInfoGetBaseString(id a1)
{
  if (!a1) {
    return 0;
  }
  v3[0]  = (id)0xAAAAAAAAAAAAAAAALL;
  v3[1]  = (id)0xAAAAAAAAAAAAAAAALL;
  TGlyphInfo::TGlyphInfo((TGlyphInfo *)v3, a1);
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(**(void **)(atomic_load_explicit((atomic_ullong *volatile)v3, memory_order_acquire)+ 40)+ 8), memory_order_acquire);

  return explicit;
}

const void *_CTGlyphInfoGetFont(id a1)
{
  if (!a1) {
    return 0;
  }
  v5[0]  = (id)0xAAAAAAAAAAAAAAAALL;
  v5[1]  = (id)0xAAAAAAAAAAAAAAAALL;
  TGlyphInfo::TGlyphInfo((TGlyphInfo *)v5, a1);
  uint64_t v1 = **(void **)(atomic_load_explicit((atomic_ullong *volatile)v5, memory_order_acquire) + 40);
  CTCharacterCollection v2 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)v1 + 24))(v1);
  uint64_t v3 = _CTFontEnsureFontRef(v2);

  return v3;
}

CGGlyph CTGlyphInfoGetGlyph(CTGlyphInfoRef glyphInfo)
{
  if (!glyphInfo) {
    return 0;
  }
  v4[0]  = (id)0xAAAAAAAAAAAAAAAALL;
  v4[1]  = (id)0xAAAAAAAAAAAAAAAALL;
  TGlyphInfo::TGlyphInfo((TGlyphInfo *)v4, glyphInfo);
  uint64_t v1 = **(void **)(atomic_load_explicit((atomic_ullong *volatile)v4, memory_order_acquire) + 40);
  CGGlyph v2 = (*(uint64_t (**)(uint64_t))(*(void *)v1 + 16))(v1);

  return v2;
}

Class TCFBase<TNativeGlyphInfo>::GetTypeID(void)::{lambda(void *)#1}::__invoke()
{
  TCFBase<TNativeGlyphInfo>::CreateTypeID();
  uint64_t v0 = TCFBase<TNativeGlyphInfo>::fTypeID;

  return _CTGlyphInfoEnableBridging(v0);
}

uint64_t TCFBase<TNativeGlyphInfo>::CreateTypeID()
{
  {
    TCFBase<TNativeGlyphInfo>::CreateTypeID(void)::runtimeClass  = 0;
    *(void *)algn_1EB2CD738  = "CTGlyphInfo";
    qword_1EB2CD740  = 0;
    unk_1EB2CD748  = 0;
    qword_1EB2CD750  = (uint64_t)TCFBase<TNativeGlyphInfo>::ClassDestruct;
    qword_1EB2CD758  = (uint64_t)TCFBase<TNativeGlyphInfo>::ClassEqual;
    qword_1EB2CD760  = (uint64_t)TCFBase<TNativeGlyphInfo>::ClassHash;
    unk_1EB2CD768  = 0;
    qword_1EB2CD770  = (uint64_t)TCFBase<TNativeGlyphInfo>::ClassDebug;
    unk_1EB2CD778  = 0;
    qword_1EB2CD780  = 0;
    unk_1EB2CD788  = 0;
  }
  uint64_t result = _CFRuntimeRegisterClass();
  TCFBase<TNativeGlyphInfo>::fCFTypeID TypeID = result;
  return result;
}

uint64_t TCFBase<TNativeGlyphInfo>::ClassDestruct(uint64_t a1)
{
  CGGlyph v2 = *(void (**)(uint64_t))(a1 + 16);
  if (v2) {
    v2(a1);
  }
  uint64_t v3 = *(uint64_t **)(a1 + 40);
  uint64_t result = *v3;
  *uint64_t v3 = 0;
  if (result)
  {
    id v5 = *(uint64_t (**)(void))(*(void *)result + 8);
    return v5();
  }
  return result;
}

uint64_t TCFBase<TNativeGlyphInfo>::ClassEqual(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, void))(***(void ***)(a1 + 40) + 64))(**(void **)(a1 + 40), **(void **)(a2 + 40));
}

void *TCFBase<TNativeGlyphInfo>::ClassHash(void *result)
{
  unint64_t v1 = result[3];
  uint64_t v2 = result[4];
  if (v2) {
    BOOL v3 = (result[4] & 1 | v1) == 0;
  }
  else {
    BOOL v3 = 1;
  }
  int v4 = !v3;
  if (v1) {
    BOOL v5 = 0;
  }
  else {
    BOOL v5 = v4 == 0;
  }
  if (!v5)
  {
    id v6 = (void *)(result[5] + (v2 >> 1));
    if (v2) {
      return (void *)(*(uint64_t (**)(void))(*v6 + v1))();
    }
    else {
      return (void *)((uint64_t (*)(void *))v1)(v6);
    }
  }
  return result;
}

uint64_t TCFBase<TNativeGlyphInfo>::ClassDebug(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(***(void ***)(a1 + 40) + 72))(**(void **)(a1 + 40));
  if (result)
  {
    BOOL v3 = (const void *)result;
    CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<%s: %p>{%@}", "CTGlyphInfo", a1, result);
    CFRelease(v3);
    return (uint64_t)v4;
  }
  return result;
}

uint64_t TCFBase<TNativeGlyphInfo>::Allocate()
{
  if (TCFBase<TNativeGlyphInfo>::GetTypeID(void)::once != -1) {
    dispatch_once_f(&TCFBase<TNativeGlyphInfo>::GetTypeID(void)::once, 0, (dispatch_function_t)TCFBase<TNativeGlyphInfo>::GetTypeID(void)::{lambda(void *)#1}::__invoke);
  }

  return _CFRuntimeCreateInstance();
}

void TNativeGlyphInfo::TNativeGlyphInfo(TNativeGlyphInfo *this, unsigned __int16 a2, const __CTFont *a3, const __CFString *a4)
{
}

BOOL TNativeGlyphInfo::GlyphInfo::operator==(uint64_t a1, uint64_t a2)
{
  unint64_t explicit = (const void *)atomic_load_explicit((atomic_ullong *volatile)(a1 + 8), memory_order_acquire);
  BOOL v3 = (const void *)atomic_load_explicit((atomic_ullong *volatile)(a2 + 8), memory_order_acquire);
  if (explicit == v3) {
    return 1;
  }
  if (explicit) {
    BOOL v4 = v3 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  return !v4 && CFEqual(explicit, v3) != 0;
}

uint64_t TNativeGlyphInfo::IdentityGlyphInfo::GetGlyphForFont(atomic_ullong *this, TFont **a2, CFTypeRef cf1)
{
  CFTypeRef explicit = (CFTypeRef)atomic_load_explicit(this + 1, memory_order_acquire);
  if (explicit == cf1)
  {
    if (!a2) {
      goto LABEL_12;
    }
    goto LABEL_8;
  }
  int v6 = 0;
  if (!cf1)
  {
LABEL_11:
    LODWORD(v7)  = 0;
    int v8 = 0;
    return v7 | v6 | v8;
  }
  LODWORD(v7)  = 0;
  int v8 = 0;
  if (explicit)
  {
    int v9 = CFEqual(cf1, explicit);
    int v6 = 0;
    if (a2)
    {
      LODWORD(v7)  = 0;
      int v8 = 0;
      if (!v9) {
        return v7 | v6 | v8;
      }
LABEL_8:
      unint64_t v7 = atomic_load_explicit(this + 3, memory_order_acquire);
      if (!v7)
      {
        int v6 = 0;
        goto LABEL_14;
      }
      if (TFont::Compare(a2[5], *(const TFont **)(atomic_load_explicit(this + 3, memory_order_acquire) + 40), 1))
      {
        LODWORD(v7)  = this[2] & 0xFF00;
        int v6 = *((_WORD *)this + 8);
        int v8 = 0x10000;
        return v7 | v6 | v8;
      }
LABEL_12:
      int v6 = 0;
      LODWORD(v7)  = 0;
LABEL_14:
      int v8 = 0;
      return v7 | v6 | v8;
    }
    goto LABEL_11;
  }
  return v7 | v6 | v8;
}

uint64_t TNativeGlyphInfo::IdentityGlyphInfo::operator==(atomic_ullong *a1, atomic_ullong *a2)
{
  CFTypeRef explicit = (const void *)atomic_load_explicit(a1 + 1, memory_order_acquire);
  BOOL v5 = (const void *)atomic_load_explicit(a2 + 1, memory_order_acquire);
  if (explicit == v5)
  {
LABEL_7:
    int v8 = (*(uint64_t (**)(atomic_ullong *))(*a1 + 16))(a1);
    if (v8 == (*(unsigned int (**)(atomic_ullong *))(*a2 + 16))(a2))
    {
      int v9 = (const void *)(*(uint64_t (**)(atomic_ullong *))(*a1 + 24))(a1);
      unsigned __int16 v10 = (const void *)(*(uint64_t (**)(atomic_ullong *))(*a2 + 24))(a2);
      if (v9 == v10) {
        return 1;
      }
      if (v9) {
        BOOL v11 = v10 == 0;
      }
      else {
        BOOL v11 = 1;
      }
      if (!v11) {
        return CFEqual(v9, v10) != 0;
      }
    }
    return 0;
  }
  if (explicit) {
    BOOL v6 = v5 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    uint64_t result = CFEqual(explicit, v5);
    if (!result) {
      return result;
    }
    goto LABEL_7;
  }
  return 0;
}

TNativeGlyphInfo::NamedGlyphInfo *TNativeGlyphInfo::NamedGlyphInfo::NamedGlyphInfo(TNativeGlyphInfo::NamedGlyphInfo *this, __CFString *a2, TFont **a3, id a4)
{
  GlyphWithName  = 0;
  if (a2 && a3) {
    GlyphWithName  = TFont::GetGlyphWithName(a3[5], a2);
  }
  *(void *)this  = &unk_1ED05FA98;
  id v9 = a4;
  *(void *)this  = &unk_1ED05FA38;
  *((void *)this + 1)  = v9;
  *((_WORD *)this + 8)  = GlyphWithName;
  *((void *)this + 3)  = a3;
  *(void *)this  = &unk_1ED05F9D8;
  *((void *)this + 4)  = a2;
  return this;
}

uint64_t TNativeGlyphInfo::NamedGlyphInfo::operator==(atomic_ullong *a1, atomic_ullong *a2)
{
  uint64_t result = TNativeGlyphInfo::IdentityGlyphInfo::operator==(a1, a2);
  if (result)
  {
    BOOL v5 = (const void *)(*(uint64_t (**)(atomic_ullong *))(*a1 + 32))(a1);
    BOOL v6 = (const void *)(*(uint64_t (**)(atomic_ullong *))(*a2 + 32))(a2);
    if (v5 == v6)
    {
      return 1;
    }
    else
    {
      if (v5) {
        BOOL v7 = v6 == 0;
      }
      else {
        BOOL v7 = 1;
      }
      return !v7 && CFEqual(v5, v6) != 0;
    }
  }
  return result;
}

uint64_t TNativeGlyphInfo::CIDGlyphInfo::GetGlyphForFont(atomic_ullong *this, const __CTFont *a2, CFTypeRef cf1)
{
  CFTypeRef explicit = (CFTypeRef)atomic_load_explicit(this + 1, memory_order_acquire);
  if (explicit == cf1)
  {
LABEL_5:
    if (*((_WORD *)this + 9))
    {
      id v12 = (id)0xAAAAAAAAAAAAAAAALL;
      (*(void (**)(id *__return_ptr))(**(void **)(*((void *)a2 + 5) + 400) + 496))(&v12);
      if (atomic_load_explicit((atomic_ullong *volatile)&v12, memory_order_acquire))
      {
        atomic_load_explicit((atomic_ullong *volatile)&v12, memory_order_acquire);
        if (CGFontGetRegistryOrderingSupplement())
        {
          id v9 = TNativeGlyphInfo::CIDGlyphInfo::GetGlyphForFont(__CTFont const*,__CFString const*)const::kOrderingTable[*((unsigned __int16 *)this + 9) - 1];
          if (CFEqual((CFTypeRef)0xAAAAAAAAAAAAAAAALL, @"Adobe"))
          {
            if (CFEqual((CFTypeRef)0xAAAAAAAAAAAAAAAALL, v9))
            {
              atomic_load_explicit((atomic_ullong *volatile)&v12, memory_order_acquire);
              if (CGFontGetGlyphsForCIDs())
              {
                LOBYTE(v6)  = -86;
                int v7 = 43520;

LABEL_16:
                int v8 = 0x10000;
                return v8 | v7 | v6;
              }
            }
          }
        }
      }
    }
    else if (a2)
    {
      uint64_t v10 = *((unsigned __int16 *)this + 8);
      if (TBaseFont::GetGlyphCount(*(TBaseFont **)(*((void *)a2 + 5) + 400)) > v10)
      {
        __int16 v6 = *((_WORD *)this + 8);
        int v7 = v6 & 0xFF00;
        goto LABEL_16;
      }
    }
LABEL_17:
    LOBYTE(v6)  = 0;
    int v7 = 0;
    int v8 = 0;
    return v8 | v7 | v6;
  }
  LOBYTE(v6)  = 0;
  int v7 = 0;
  int v8 = 0;
  if (cf1 && explicit)
  {
    if (!CFEqual(cf1, explicit)) {
      goto LABEL_17;
    }
    goto LABEL_5;
  }
  return v8 | v7 | v6;
}

uint64_t TNativeGlyphInfo::CIDGlyphInfo::operator==(atomic_ullong *a1, atomic_ullong *a2)
{
  CFTypeRef explicit = (const void *)atomic_load_explicit(a1 + 1, memory_order_acquire);
  BOOL v5 = (const void *)atomic_load_explicit(a2 + 1, memory_order_acquire);
  if (explicit != v5)
  {
    if (explicit) {
      BOOL v6 = v5 == 0;
    }
    else {
      BOOL v6 = 1;
    }
    if (v6) {
      return 0;
    }
    uint64_t result = CFEqual(explicit, v5);
    if (!result) {
      return result;
    }
  }
  int v8 = (*(uint64_t (**)(atomic_ullong *))(*a1 + 40))(a1);
  if (v8 == (*(unsigned int (**)(atomic_ullong *))(*a2 + 40))(a2))
  {
    int v9 = (*(uint64_t (**)(atomic_ullong *))(*a1 + 48))(a1);
    return v9 == (*(unsigned int (**)(atomic_ullong *))(*a2 + 48))(a2);
  }
  return 0;
}

void TNativeGlyphInfo::GlyphInfo::~GlyphInfo(id *this)
{
  *this  = &unk_1ED05FA98;
}

{
  uint64_t vars8;

  *this  = &unk_1ED05FA98;

  JUMPOUT(0x1853275C0);
}

uint64_t TNativeGlyphInfo::GlyphInfo::GetGlyph(TNativeGlyphInfo::GlyphInfo *this)
{
  return 0;
}

uint64_t TNativeGlyphInfo::GlyphInfo::GetFont(TNativeGlyphInfo::GlyphInfo *this)
{
  return 0;
}

uint64_t TNativeGlyphInfo::GlyphInfo::GetGlyphName(TNativeGlyphInfo::GlyphInfo *this)
{
  return 0;
}

uint64_t TNativeGlyphInfo::GlyphInfo::GetCID(TNativeGlyphInfo::GlyphInfo *this)
{
  return 0;
}

uint64_t TNativeGlyphInfo::GlyphInfo::GetCollection(TNativeGlyphInfo::GlyphInfo *this)
{
  return 0;
}

uint64_t TNativeGlyphInfo::GlyphInfo::GetGlyphForFont(TNativeGlyphInfo::GlyphInfo *this, const __CTFont *a2, const __CFString *a3)
{
  return 0;
}

uint64_t TNativeGlyphInfo::GlyphInfo::DebugDescription(TNativeGlyphInfo::GlyphInfo *this)
{
  return 0;
}

void TNativeGlyphInfo::IdentityGlyphInfo::~IdentityGlyphInfo(id *this)
{
  *this  = &unk_1ED05FA38;

  *this  = &unk_1ED05FA98;
}

{
  uint64_t vars8;

  *this  = &unk_1ED05FA38;

  *this  = &unk_1ED05FA98;

  JUMPOUT(0x1853275C0);
}

uint64_t TNativeGlyphInfo::IdentityGlyphInfo::GetGlyph(TNativeGlyphInfo::IdentityGlyphInfo *this)
{
  return *((unsigned __int16 *)this + 8);
}

unint64_t TNativeGlyphInfo::IdentityGlyphInfo::GetFont(atomic_ullong *this)
{
  return atomic_load_explicit(this + 3, memory_order_acquire);
}

void TNativeGlyphInfo::NamedGlyphInfo::~NamedGlyphInfo(id *this)
{
  TNativeGlyphInfo::NamedGlyphInfo::~NamedGlyphInfo(this);

  JUMPOUT(0x1853275C0);
}

{
  *this  = &unk_1ED05F9D8;

  *this  = &unk_1ED05FA38;
  *this  = &unk_1ED05FA98;
}

uint64_t TNativeGlyphInfo::NamedGlyphInfo::GetGlyph(TNativeGlyphInfo::NamedGlyphInfo *this)
{
  return 0;
}

unint64_t TNativeGlyphInfo::NamedGlyphInfo::GetGlyphName(atomic_ullong *this)
{
  return atomic_load_explicit(this + 4, memory_order_acquire);
}

void TNativeGlyphInfo::CIDGlyphInfo::~CIDGlyphInfo(id *this)
{
  *this  = &unk_1ED05FA98;
}

{
  uint64_t vars8;

  *this  = &unk_1ED05FA98;

  JUMPOUT(0x1853275C0);
}

uint64_t TNativeGlyphInfo::CIDGlyphInfo::GetCID(TNativeGlyphInfo::CIDGlyphInfo *this)
{
  return *((unsigned __int16 *)this + 8);
}

uint64_t TNativeGlyphInfo::CIDGlyphInfo::GetCollection(TNativeGlyphInfo::CIDGlyphInfo *this)
{
  return *((unsigned __int16 *)this + 9);
}

void TGlyphInfo::TGlyphInfo(TGlyphInfo *this, id a2)
{
  *(void *)this  = a2;
  CFTypeID v4 = CFGetTypeID(a2);
  CFTypeID TypeID = CTGlyphInfoGetTypeID();
  *((unsigned char *)this + 8)  = v4 == TypeID;
  if (v4 != TypeID)
  {
    CFTypeRef explicit = (void *)atomic_load_explicit((atomic_ullong *volatile)this, memory_order_acquire);
    CFStringRef v11 = (const __CFString *)objc_msgSend(explicit, sel__baseString);
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB2CE728, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB2CE728))
    {
      _MergedGlobals_27  = (uint64_t)objc_lookUpClass("NSCIDGlyphInfo");
      __cxa_guard_release(&qword_1EB2CE728);
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB2CE738, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB2CE738))
    {
      qword_1EB2CE730  = (uint64_t)objc_lookUpClass("NSGlyphNameGlyphInfo");
      __cxa_guard_release(&qword_1EB2CE738);
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB2CE748, memory_order_acquire) & 1) == 0)
    {
      if (__cxa_guard_acquire(&qword_1EB2CE748))
      {
        qword_1EB2CE740  = (uint64_t)objc_lookUpClass("NSIdentityGlyphInfo");
        __cxa_guard_release(&qword_1EB2CE748);
      }
    }
    if (objc_msgSend(explicit, sel_isKindOfClass_, _MergedGlobals_27))
    {
      LOWORD(v9)  = (unsigned __int16)objc_msgSend(explicit, sel_characterIdentifier);
      LOWORD(v8)  = (unsigned __int16)objc_msgSend(explicit, sel_characterCollection);
      TCFBase_NEW<CTGlyphInfo,unsigned short &,CTCharacterCollection &,__CFString const*&>(&v10);

      int v7 = v10;
    }
    else if (objc_msgSend(explicit, sel_isKindOfClass_, qword_1EB2CE730))
    {
      uint64_t v10 = (const __CTFont *)objc_msgSend(explicit, sel_glyphName);
      id v9 = (id)_CTFontEnsureFontRef(objc_msgSend(explicit, sel__font));
      TCFBase_NEW<CTGlyphInfo,__CFString const*&,__CTFont const*&,__CFString const*&>(&v8);

      int v7 = v8;
    }
    else
    {
      if (!objc_msgSend(explicit, sel_isKindOfClass_, qword_1EB2CE740)) {
        return;
      }
      LOWORD(v8)  = (unsigned __int16)objc_msgSend(explicit, sel__glyph);
      uint64_t v10 = (const __CTFont *)_CTFontEnsureFontRef(objc_msgSend(explicit, sel__font, v8));
      TCFBase_NEW<CTGlyphInfo,unsigned short &,__CTFont const*&,__CFString const*&>((unsigned __int16 *)&v8, &v10, &v11, &v9);

      int v7 = (const __CTFont *)v9;
    }
  }
}

uint64_t TGlyphInfo::GetGlyphForFont(TGlyphInfo *this, const __CTFont *a2, const __CFString *a3)
{
  if (!*((unsigned char *)this + 8)) {
    _CTFontEnsureFontRef(a2);
  }
  CFTypeID v4 = *(uint64_t (**)(void))(***(void ***)(atomic_load_explicit((atomic_ullong *volatile)this, memory_order_acquire)
                                           + 40)
                           + 56);

  return v4();
}

void CreateSetWithArray(const __CFArray *a1@<X0>, void *a2@<X8>)
{
  *a2  = 0xAAAAAAAAAAAAAAAALL;
  id v3 = (id)[objc_alloc(MEMORY[0x1E4F1CAD0]) initWithArray:a1];
  *a2  = atomic_exchange((atomic_ullong *volatile)&v3, 0);
}

void SetValuesToDictionaryFromDictionary(__CFDictionary *context, CFDictionaryRef theDict)
{
  if (theDict) {
    CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)SetValuesToDictionaryFromDictionary(__CFDictionary *,__CFDictionary const*)::$_0::__invoke, context);
  }
}

void ArrayComponentsJoinedByString(const __CFArray *a1@<X0>, const __CFString *a2@<X1>, atomic_ullong *a3@<X8>)
{
  *a3  = 0;
  BOOL v6 = (void *)MEMORY[0x185327A40]();
  id v7 = (id)[(__CFArray *)a1 componentsJoinedByString:a2];
}

atomic_ullong *TCFUniqueRemappingArray::TCFUniqueRemappingArray(atomic_ullong *a1, void *a2, uint64_t a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  *a1  = (atomic_ullong)CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  std::__function::__value_func<objc_object * ()(objc_object *)>::__value_func[abi:nn180100]((uint64_t)(a1 + 1), a3);
  if (a2)
  {
    long long v13 = 0u;
    long long v14 = 0u;
    long long v11 = 0u;
    long long v12 = 0u;
    uint64_t v6 = [a2 countByEnumeratingWithState:&v11 objects:v15 count:16];
    if (v6)
    {
      uint64_t v7 = v6;
      uint64_t v8 = *(void *)v12;
      do
      {
        uint64_t v9 = 0;
        do
        {
          if (*(void *)v12 != v8) {
            objc_enumerationMutation(a2);
          }
          TCFUniqueRemappingArray::AppendUnique(a1, *(objc_object **)(*((void *)&v11 + 1) + 8 * v9++));
        }
        while (v7 != v9);
        uint64_t v7 = [a2 countByEnumeratingWithState:&v11 objects:v15 count:16];
      }
      while (v7);
    }
  }
  return a1;
}

BOOL TCFUniqueRemappingArray::AppendUnique(atomic_ullong *this, objc_object *a2)
{
  id v3 = (const void *)std::function<objc_object * ()(objc_object *)>::operator()((uint64_t)(this + 1), (uint64_t)a2);
  CFArrayRef explicit = (const __CFArray *)atomic_load_explicit(this, memory_order_acquire);
  v7.CFIndex length = CFArrayGetCount((CFArrayRef)atomic_load_explicit(this, memory_order_acquire));
  v7.CFIndex location = 0;
  int v5 = CFArrayContainsValue(explicit, v7, v3);
  if (!v5) {
    CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit(this, memory_order_acquire), v3);
  }
  return v5 == 0;
}

void EnumerateCharactersInRange(const __CFString *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFStringRef v39 = a1;
  uint64_t v42 = a2;
  int64_t v43 = a3;
  CharactersPtr  = CFStringGetCharactersPtr(a1);
  if (CharactersPtr) {
    CStringPtr  = 0;
  }
  else {
    CStringPtr  = CFStringGetCStringPtr(a1, 0x600u);
  }
  *(void *)&long long v9 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v9 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  long long v37 = v9;
  long long v38 = v9;
  long long v35 = v9;
  long long v36 = v9;
  long long v33 = v9;
  long long v34 = v9;
  *(_OWORD *)buffer  = v9;
  long long v32 = v9;
  uint64_t v41 = CStringPtr;
  int64_t v44 = 0;
  int64_t v45 = 0;
  if (a3 < 1)
  {
LABEL_52:

    return;
  }
  int64_t v10 = 0;
  while (1)
  {
    if (v10 < 0 || (int64_t v11 = v43, v43 <= v10))
    {
      int v13 = 0;
LABEL_11:
      uint64_t v14 = 1;
      uint64_t v15 = v10;
      goto LABEL_12;
    }
    if (CharactersPtr)
    {
      UniChar v12 = CharactersPtr[v42 + v10];
    }
    else if (v41)
    {
      UniChar v12 = v41[v42 + v10];
    }
    else
    {
      if (v45 <= v10 || (int64_t v18 = v44, v44 > v10))
      {
        int64_t v19 = v10 - 4;
        if ((unint64_t)v10 < 4) {
          int64_t v19 = 0;
        }
        if (v19 + 64 < v43) {
          int64_t v11 = v19 + 64;
        }
        int64_t v44 = v19;
        int64_t v45 = v11;
        v49.CFIndex location = v42 + v19;
        v49.CFIndex length = v11 - v19;
        CFStringGetCharacters(v39, v49, buffer);
        int64_t v18 = v44;
      }
      UniChar v12 = buffer[v10 - v18];
    }
    int v13 = v12;
    if (v12 >> 10 != 54) {
      goto LABEL_11;
    }
    int64_t v20 = v10 + 1;
    if (v10 + 1 >= a3) {
      goto LABEL_11;
    }
    int64_t v21 = v43;
    if (v43 <= v20) {
      goto LABEL_11;
    }
    if (CharactersPtr)
    {
      UniChar v22 = CharactersPtr[v42 + v20];
    }
    else if (v41)
    {
      UniChar v22 = v41[v42 + v20];
    }
    else
    {
      if (v45 <= v20 || (int64_t v23 = v44, v44 > v20))
      {
        int64_t v24 = v10 - 3;
        if ((unint64_t)v20 < 4) {
          int64_t v24 = 0;
        }
        if (v24 + 64 < v43) {
          int64_t v21 = v24 + 64;
        }
        int64_t v44 = v24;
        int64_t v45 = v21;
        v50.CFIndex location = v42 + v24;
        v50.CFIndex length = v21 - v24;
        CFStringGetCharacters(v39, v50, buffer);
        int64_t v23 = v44;
      }
      UniChar v22 = buffer[v20 - v23];
    }
    BOOL v25 = v22 >> 10 == 55;
    int v26 = (v13 << 10) + v22 - 56613888;
    if (v25) {
      int v13 = v26;
    }
    uint64_t v14 = 1;
    if (v25) {
      uint64_t v14 = 2;
    }
    uint64_t v15 = v25 ? v10 + 1 : v10;
LABEL_12:
    char v30 = 0;
    uint64_t v16 = *(void *)(a4 + 24);
    v48[0]  = v10 + a2;
    v48[1]  = v14;
    int v47 = v13;
    uint64_t v46 = &v30;
    if (!v16) {
      break;
    }
    (*(void (**)(uint64_t, void *, int *, char **))(*(void *)v16 + 48))(v16, v48, &v47, &v46);
    int64_t v10 = v15 + 1;
    if (v30) {
      BOOL v17 = 0;
    }
    else {
      BOOL v17 = v10 < a3;
    }
    if (!v17) {
      goto LABEL_52;
    }
  }
  CFStringRef v27 = (const __CFString *)std::__throw_bad_function_call[abi:nn180100]();
  RangeOfCharactersFromSet(v27, v28, v51, v29);
}

CFIndex RangeOfCharactersFromSet(const __CFString *a1, const __CFCharacterSet *a2, CFRange a3, CFStringCompareFlags a4)
{
  CFIndex length = a3.length;
  CFIndex location = a3.location;
  v10[4]  = *MEMORY[0x1E4F143B8];
  CFCharacterSetRef v8 = a2;
  CFRange result = (CFRange)xmmword_184BA8680;
  if (CFStringFindCharacterFromSet(a1, a2, a3, a4, &result))
  {
    v10[0]  = &unk_1ED05FF18;
    v10[1]  = &v8;
    v10[2]  = &result;
    v10[3]  = v10;
    EnumerateCharactersInRange(a1, result.length + result.location, location + length - (result.length + result.location), (uint64_t)v10);
    std::__function::__value_func<void ()(CFRange,unsigned int,BOOL *)>::~__value_func[abi:nn180100](v10);
  }
  return result.location;
}

void CreateStringByDeletingLongCharactersPassingTest(__CFString *a1@<X0>, uint64_t a2@<X1>, __CFString **a3@<X8>)
{
  if (!a1)
  {
    *a3  = 0;
    return;
  }
  uint64_t Length = CFStringGetLength(a1);
  id v51 = 0;
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  long long v42 = v6;
  long long v43 = v6;
  long long v40 = v6;
  long long v41 = v6;
  long long v38 = v6;
  long long v39 = v6;
  *(_OWORD *)buffer  = v6;
  long long v37 = v6;
  theString  = a1;
  uint64_t v47 = 0;
  CFIndex v48 = Length;
  CharactersPtr  = CFStringGetCharactersPtr(a1);
  CStringPtr  = 0;
  int64_t v45 = (UniChar *)CharactersPtr;
  if (!CharactersPtr) {
    CStringPtr  = CFStringGetCStringPtr(a1, 0x600u);
  }
  CFIndex v49 = 0;
  CFIndex v50 = 0;
  uint64_t v46 = CStringPtr;
  if (Length >= 1)
  {
    CFIndex v9 = 0;
    CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    do
    {
      if (v9 < 0 || (CFIndex v11 = v48, v48 <= v9))
      {
        int v15 = 0;
LABEL_12:
        CFIndex v16 = 1;
        CFIndex v17 = v9;
        goto LABEL_13;
      }
      UniChar v12 = v45;
      if (v45)
      {
        CFIndex v13 = v47 + v9;
      }
      else
      {
        if (v46)
        {
          UniChar v14 = v46[v47 + v9];
          goto LABEL_24;
        }
        if (v50 <= v9 || (CFIndex v27 = v49, v49 > v9))
        {
          CFIndex v28 = v9 - 4;
          if ((unint64_t)v9 < 4) {
            CFIndex v28 = 0;
          }
          if (v28 + 64 < v48) {
            CFIndex v11 = v28 + 64;
          }
          CFIndex v49 = v28;
          CFIndex v50 = v11;
          v55.CFIndex location = v47 + v28;
          v55.CFIndex length = v11 - v28;
          CFStringGetCharacters(theString, v55, buffer);
          CFIndex v27 = v49;
        }
        CFIndex v13 = v9 - v27;
        UniChar v12 = buffer;
      }
      UniChar v14 = v12[v13];
LABEL_24:
      int v15 = v14;
      if (v14 >> 10 != 54) {
        goto LABEL_12;
      }
      int64_t v22 = v9 + 1;
      if (v9 + 1 >= Length) {
        goto LABEL_12;
      }
      CFIndex v23 = v48;
      if (v48 <= v22) {
        goto LABEL_12;
      }
      int64_t v24 = v45;
      if (v45)
      {
        int64_t v25 = v47 + v22;
      }
      else
      {
        if (v46)
        {
          UniChar v26 = v46[v47 + v22];
          goto LABEL_40;
        }
        if (v50 <= v22 || (CFIndex v31 = v49, v49 > v22))
        {
          CFIndex v32 = v9 - 3;
          if ((unint64_t)v22 < 4) {
            CFIndex v32 = 0;
          }
          if (v32 + 64 < v48) {
            CFIndex v23 = v32 + 64;
          }
          CFIndex v49 = v32;
          CFIndex v50 = v23;
          v56.CFIndex location = v47 + v32;
          v56.CFIndex length = v23 - v32;
          CFStringGetCharacters(theString, v56, buffer);
          CFIndex v31 = v49;
        }
        int64_t v25 = v22 - v31;
        int64_t v24 = buffer;
      }
      UniChar v26 = v24[v25];
LABEL_40:
      BOOL v29 = v26 >> 10 == 55;
      int v30 = (v15 << 10) + v26 - 56613888;
      if (v29) {
        CFIndex v16 = 2;
      }
      else {
        CFIndex v16 = 1;
      }
      if (v29) {
        int v15 = v30;
      }
      if (v29) {
        CFIndex v17 = v9 + 1;
      }
      else {
        CFIndex v17 = v9;
      }
LABEL_13:
      uint64_t v18 = *(void *)(a2 + 24);
      v53[0]  = v9;
      v53[1]  = v16;
      int v52 = v15;
      if (!v18)
      {
        CFStringRef v34 = (const __CFString *)std::__throw_bad_function_call[abi:nn180100]();
        CreateLocalizedStringWithFormat(v34);
        return;
      }
      if ((*(unsigned int (**)(uint64_t, void *, int *))(*(void *)v18 + 48))(v18, v53, &v52))
      {
        if (!atomic_load_explicit((atomic_ullong *volatile)&v51, memory_order_acquire)) {

        }
        v54.CFIndex location = v9;
        v54.CFIndex length = v16;
        CFStringDelete((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&v51, memory_order_acquire), v54);
        Length -= v16;
        CFStringRef explicit = (const __CFString *)atomic_load_explicit((atomic_ullong *volatile)&v51, memory_order_acquire);
        theString  = explicit;
        uint64_t v47 = 0;
        CFIndex v48 = Length;
        int64_t v20 = CFStringGetCharactersPtr(explicit);
        int64_t v21 = 0;
        int64_t v45 = (UniChar *)v20;
        if (!v20) {
          int64_t v21 = CFStringGetCStringPtr(explicit, 0x600u);
        }
        uint64_t v46 = v21;
        v17 -= v16;
        CFIndex v49 = 0;
        CFIndex v50 = 0;
      }
      CFIndex v9 = v17 + 1;
    }
    while (v17 + 1 < Length);
  }
  if (atomic_load_explicit((atomic_ullong *volatile)&v51, memory_order_acquire)) {
    long long v33 = (__CFString *)atomic_exchange((atomic_ullong *volatile)&v51, 0);
  }
  else {
    long long v33 = a1;
  }
  *a3  = v33;
}

void CreateLocalizedStringWithFormat(const __CFString *a1@<X0>, void *a2@<X8>, ...)
{
  va_start(va, a2);
  va_copy(v6, va);
  *a2  = 0xAAAAAAAAAAAAAAAALL;
  id v4 = [NSString alloc];
  id v5 = (id)objc_msgSend(v4, "initWithFormat:locale:arguments:", a1, objc_msgSend(MEMORY[0x1E4F1CA20], "currentLocale"), v6);
  *a2  = atomic_exchange((atomic_ullong *volatile)&v5, 0);
}

void CreateOrderedArray(void *a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  unint64_t v19 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  v18[0]  = v7;
  v18[1]  = v7;
  std::__function::__value_func<objc_object * ()(objc_object *)>::__value_func[abi:nn180100]((uint64_t)v17, a3);
  TCFUniqueRemappingArray::TCFUniqueRemappingArray((atomic_ullong *)v18, a1, (uint64_t)v17);
  std::__function::__value_func<objc_object * ()(objc_object *)>::~__value_func[abi:nn180100](v17);
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  uint64_t v8 = [a2 countByEnumeratingWithState:&v12 objects:v16 count:16];
  if (v8)
  {
    uint64_t v9 = v8;
    uint64_t v10 = *(void *)v13;
    do
    {
      for (uint64_t i = 0; i != v9; ++i)
      {
        if (*(void *)v13 != v10) {
          objc_enumerationMutation(a2);
        }
        TCFUniqueRemappingArray::AppendUnique((atomic_ullong *)v18, *(objc_object **)(*((void *)&v12 + 1) + 8 * i));
      }
      uint64_t v9 = [a2 countByEnumeratingWithState:&v12 objects:v16 count:16];
    }
    while (v9);
  }
  *a4  = atomic_exchange((atomic_ullong *volatile)v18, 0);
  std::__function::__value_func<objc_object * ()(objc_object *)>::~__value_func[abi:nn180100]((void *)v18 + 1);
}

void CopyPreferredAndSystemLanguages(void *a1@<X8>)
{
  v3[4]  = *MEMORY[0x1E4F143B8];
  CFArrayRef v2 = CFLocaleCopyPreferredLanguages();
  v3[0]  = &unk_1ED05FB70;
  v3[3]  = v3;
  CreateOrderedArray(v2, (void *)[MEMORY[0x1E4F1CA20] systemLanguages], (uint64_t)v3, a1);
  std::__function::__value_func<objc_object * ()(objc_object *)>::~__value_func[abi:nn180100](v3);
}

void CopyValueForCurrentUser(const __CFDictionary *a1@<X0>, const __CFString **a2@<X1>, atomic_ullong *a3@<X8>)
{
  if (a1)
  {
    CFArrayRef v6 = (const __CFArray *)[(__CFDictionary *)a1 allKeys];
    long long v7 = (void *)[MEMORY[0x1E4F1CA20] preferredLanguages];
    if (([v7 containsObject:@"en"] & 1) == 0) {
      long long v7 = (void *)[v7 arrayByAddingObject:@"en"];
    }
    CFArrayRef v8 = CFBundleCopyLocalizationsForPreferences(v6, (CFArrayRef)v7);
    *a3  = 0;
    CFArrayRef v9 = v8;
    if (v9)
    {
      CFArrayRef v10 = v9;
      CFIndex Count = CFArrayGetCount(v9);

      if (Count)
      {
        CFStringRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(v8, 0);
        long long v13 = ValueAtIndex;
        if (a2) {
          *a2  = (const __CFString *)ValueAtIndex;
        }
        CFNumberRef Value = (void *)CFDictionaryGetValue(a1, v13);
        TCFRef<__CTFont const*>::Retain(a3, Value);
      }
    }
    else
    {
    }
  }
  else
  {
    *a3  = 0;
  }
}

uint64_t std::function<objc_object * ()(objc_object *)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2) {
    return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v2 + 48))(v2, &v6);
  }
  uint64_t v4 = std::__throw_bad_function_call[abi:nn180100]();
  return std::__function::__value_func<objc_object * ()(objc_object *)>::__value_func[abi:nn180100](v4, v5);
}

uint64_t std::__function::__value_func<objc_object * ()(objc_object *)>::__value_func[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24)  = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24)  = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24)  = 0;
  }
  return a1;
}

void std::__function::__func<RangeOfCharactersFromSet(__CFString const*,__CFCharacterSet const*,CFRange,unsigned long)::$_0,std::allocator<RangeOfCharactersFromSet(__CFString const*,__CFCharacterSet const*,CFRange,unsigned long)::$_0>,void ()(CFRange,unsigned int,BOOL *)>::~__func()
{
}

__n128 std::__function::__func<RangeOfCharactersFromSet(__CFString const*,__CFCharacterSet const*,CFRange,unsigned long)::$_0,std::allocator<RangeOfCharactersFromSet(__CFString const*,__CFCharacterSet const*,CFRange,unsigned long)::$_0>,void ()(CFRange,unsigned int,BOOL *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1ED05FF18;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8)  = result;
  return result;
}

__n128 std::__function::__func<RangeOfCharactersFromSet(__CFString const*,__CFCharacterSet const*,CFRange,unsigned long)::$_0,std::allocator<RangeOfCharactersFromSet(__CFString const*,__CFCharacterSet const*,CFRange,unsigned long)::$_0>,void ()(CFRange,unsigned int,BOOL *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2  = &unk_1ED05FF18;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8)  = result;
  return result;
}

uint64_t std::__function::__func<RangeOfCharactersFromSet(__CFString const*,__CFCharacterSet const*,CFRange,unsigned long)::$_0,std::allocator<RangeOfCharactersFromSet(__CFString const*,__CFCharacterSet const*,CFRange,unsigned long)::$_0>,void ()(CFRange,unsigned int,BOOL *)>::operator()(uint64_t a1, uint64_t a2, UTF32Char *a3, unsigned char **a4)
{
  uint64_t v5 = *(void *)(a2 + 8);
  uint64_t v6 = *a4;
  uint64_t result = CFCharacterSetIsLongCharacterMember(**(CFCharacterSetRef **)(a1 + 8), *a3);
  if (result) {
    *(void *)(*(void *)(a1 + 16) + 8) += v5;
  }
  else {
    *uint64_t v6 = 1;
  }
  return result;
}

void std::__function::__func<$_3,std::allocator<$_3>,objc_object * ()(objc_object *)>::~__func()
{
}

void *std::__function::__func<$_3,std::allocator<$_3>,objc_object * ()(objc_object *)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1ED05FB70;
  return result;
}

void std::__function::__func<$_3,std::allocator<$_3>,objc_object * ()(objc_object *)>::__clone(uint64_t a1, void *a2)
{
  *a2  = &unk_1ED05FB70;
}

uint64_t std::__function::__func<$_3,std::allocator<$_3>,objc_object * ()(objc_object *)>::operator()(uint64_t a1, uint64_t a2)
{
  return *(void *)a2;
}

void ArabicShapingEngine::~ArabicShapingEngine(ArabicShapingEngine *this)
{
}

uint64_t ArabicShapingEngine::ApplyScriptShaping(ArabicShapingEngine *this, const OTL::GSUB *a2, OTL::GlyphLookups *a3, unsigned int *a4, BOOL *a5)
{
  unint64_t v7 = (unint64_t)a2;
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  if (a4) {
    *a4  = 0;
  }
  JoiningScriptShapingEngine::ApplyScriptShaping(this, a2, a3, a5);
  *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v8 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  long long v30 = v8;
  long long v29 = v8;
  long long v28 = v8;
  long long v27 = v8;
  long long v26 = v8;
  long long v25 = v8;
  long long v24 = v8;
  int64_t v22 = 0;
  uint64_t v23 = 0;
  int64_t v21 = 0;
  unint64_t v31 = 0xAAAAAAAAAAAAAAAALL;
  CFIndex v32 = &v24;
  int v18 = 1919707495;
  unint64_t v9 = (unint64_t)v20;
  OTL::FeatureBuffer::FeatureBuffer<unsigned int const*>(v20, &v18, &v19);
  OTL::GCommon::GetLookups(v7, (uint64_t)v20, (uint64_t)&v21, 0);
  unint64_t v19 = v20;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v19);
  CFArrayRef v10 = v21;
  CFIndex v11 = v22;
  while (v10 != v11)
  {
    unsigned int v12 = *v10++;
    unint64_t v9 = v9 & 0xFFFFFFFF00000000 | v12;
    OTL::GlyphLookups::SetLookupInRange<true>((uint64_t *)a3, v9, 0, -1);
  }
  v20[0]  = (char *)&v21;
  std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v20);
  if (OTL::GCommon::HasFeature((OTL::GCommon *)v7, 0x72636C74u))
  {
    *(_OWORD *)a4  = xmmword_184BA86A0;
  }
  else
  {
    *(void *)&long long v13 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v13 + 1)  = 0xAAAAAAAAAAAAAAAALL;
    long long v30 = v13;
    long long v29 = v13;
    long long v28 = v13;
    long long v27 = v13;
    long long v26 = v13;
    long long v25 = v13;
    long long v24 = v13;
    int64_t v22 = 0;
    uint64_t v23 = 0;
    int64_t v21 = 0;
    unint64_t v31 = 0xAAAAAAAAAAAAAAAALL;
    CFIndex v32 = &v24;
    int v18 = 1667329140;
    OTL::FeatureBuffer::FeatureBuffer<unsigned int const*>(v20, &v18, &v19);
    OTL::GCommon::GetLookups(v7, (uint64_t)v20, (uint64_t)&v21, 0);
    unint64_t v19 = v20;
    std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v19);
    long long v14 = v21;
    long long v15 = v22;
    while (v14 != v15)
    {
      unsigned int v16 = *v14++;
      unint64_t v7 = v7 & 0xFFFFFFFF00000000 | v16;
      OTL::GlyphLookups::SetLookupInRange<true>((uint64_t *)a3, v7, 0, -1);
    }
    *(void *)a4  = 1836279156;
    v20[0]  = (char *)&v21;
    std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v20);
  }
  return 1;
}

uint32_t CTGetCoreTextVersion(void)
{
  return 851968;
}

id CTCopyDescriptionDictionary(void *a1, uint64_t a2)
{
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 == CTFrameGetTypeID())
  {
    uint64_t v5 = (atomic_ullong *)a1[5];
    return TFrame::CopyDescriptionDictionary(v5, a2);
  }
  else
  {
    CFTypeID v7 = CFGetTypeID(a1);
    if (v7 == CTLineGetTypeID())
    {
      long long v8 = (TLine *)a1[5];
      return TLine::CopyDescriptionDictionary(v8, a2);
    }
    else
    {
      CFTypeID v9 = CFGetTypeID(a1);
      if (v9 == CTRunGetTypeID())
      {
        CFArrayRef v10 = *(uint64_t (**)(void))(*(void *)a1[5] + 16);
        return (id)v10();
      }
      else
      {
        return 0;
      }
    }
  }
}

void CTWriteDescriptionDictionaryToFile(void *a1, uint64_t a2, const char *a3)
{
  id v4 = CTCopyDescriptionDictionary(a1, a2);
  if (v4)
  {
    uint64_t v5 = v4;
    CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    size_t v7 = strlen(a3);
    CFURLRef v8 = CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)a3, v7, 0);
    if (v8)
    {
      CFURLRef v9 = v8;
      CFArrayRef v10 = CFWriteStreamCreateWithFile(v6, v8);
      if (v10)
      {
        CFIndex v11 = v10;
        if (CFWriteStreamOpen(v10))
        {
          CFPropertyListWrite(v5, v11, kCFPropertyListXMLFormat_v1_0, 0, 0);
          CFWriteStreamClose(v11);
        }
        CFRelease(v11);
      }
      CFRelease(v9);
    }
    CFRelease(v5);
  }
}

uint64_t PointerToEpsilonDestructor(uint64_t result)
{
  if (result) {
    JUMPOUT(0x1853275C0);
  }
  return result;
}

BOOL _CTSwapAllDescriptorsFallbackDisabled(unsigned int a1)
{
  return SetThreadSpecificData(8, a1, (uint64_t (*)(void *))ThreadSpecificNullDestructor<BOOL>) != 0;
}

double CTGetDefaultLanguageAwareLineHeightRatio()
{
  return 0.33;
}

uint64_t CTStringIsSuitableForArabicJustification(const __CFString *a1)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    CFIndex Length = CFStringGetLength(a1);
    if (Length >= 1)
    {
      CFIndex v3 = Length;
      id v28 = 0;
      id keys = &v28;
      v31[0]  = 0;
      int v4 = _ExuberatedGroupForPreferredLanguages(0, (const __CFString **)v31);

      if (v4)
      {
        uint64_t v5 = (const __CTFont *)(id)atomic_load_explicit((atomic_ullong *volatile)&v28, memory_order_acquire);
        CTFontRef v6 = v5;
        if (v5 == (const __CTFont *)@"ur") {
          goto LABEL_15;
        }
        if (v5)
        {
          int v7 = CFEqual(v5, @"ur");

          if (v7)
          {
            char v8 = 0;
LABEL_37:

            return v8 & 1;
          }
        }
        else
        {
        }
      }
      CTFontRef v6 = CTFontCreateWithNameAndOptions(@".SFArabic-Regular", 0.0, 0, 0x400uLL);
      if (v6)
      {
        if (qword_1EB2CE768 != -1) {
          dispatch_once_f(&qword_1EB2CE768, v6, (dispatch_function_t)CTStringIsSuitableForArabicJustification::$_0::__invoke);
        }
        if (_MergedGlobals_29)
        {
          result.CFIndex location = 0xAAAAAAAAAAAAAAAALL;
          result.CFIndex length = 0xAAAAAAAAAAAAAAAALL;
          v42.CFIndex location = 0;
          v42.CFIndex length = v3;
          if (!CFStringFindCharacterFromSet(a1, (CFCharacterSetRef)_MergedGlobals_29, v42, 0, &result))
          {
            CFURLRef v9 = (std::__shared_weak_count *)operator new(0x48uLL);
            v9->__shared_weak_owners_  = 0;
            v9->__shared_owners_  = 0;
            v9->__vftable  = (std::__shared_weak_count_vtbl *)&unk_1ED062278;
            uint64_t v10 = (uint64_t)&v9[1];
            TCharStreamCFString::TCharStreamCFString((TCharStreamCFString *)&v9[1], a1, 0);
            shared_weak_owners  = v9[1].__shared_weak_owners_;
            result.CFIndex location = 0;
            result.CFIndex length = shared_weak_owners;
            *(_OWORD *)long long v36 = xmmword_184BA8738;
            memset(&v36[16], 170, 32);
            long long v37 = unk_184BA8768;
            *(_OWORD *)&v35[96]  = xmmword_184BA8718;
            *(_OWORD *)&v35[112]  = unk_184BA8728;
            memset(v35, 170, 96);
            atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
            *(void *)long long v35 = v9 + 1;
            int64_t v21 = v9;
            *(void *)&v35[8]  = v9;
            memset(&v35[16], 0, 24);
            *(void *)&v35[64]  = &v35[40];
            BYTE8(v37)  = 0;
            memset(&v35[72], 0, 56);
            memset(&v36[8], 0, 21);
            LOBYTE(v37)  = 0;
            uint64_t v40 = 0;
            uint64_t v38 = 0;
            uint64_t v39 = 0;
            *(_OWORD *)&v36[32]  = 0uLL;
            *(void *)long long v36 = 0xFFEFFFFFFFFFFFFFLL;
            id keys = @"NSFont";
            int64_t v22 = v6;
            values[0]  = v6;
            CFDictionaryRef v12 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&keys, (const void **)values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            memcpy(values, &unk_184BA8790, sizeof(values));
            TTypesetterString::TTypesetterString((TTypesetterString *)values, a1, v12);
            TTypesetter::FillLine((TTypesetter *)values, (TLine *)v35, 1.79769313e308, 0.0);
            char v26 = 0;
            uint64_t v13 = *(void *)&v35[24];
            uint64_t v14 = *(void *)&v35[16];
            if (*(void *)&v35[16] == *(void *)&v35[24])
            {
              char v8 = 0;
            }
            else
            {
              char v8 = 0;
              memset(v23, 170, sizeof(v23));
              do
              {
                long long v15 = *(atomic_ullong **)(*(void *)v14 + 40);
                unint64_t v16 = v15[26];
                v24[2]  = v23[3];
                v24[3]  = v23[2];
                unint64_t v25 = 0xAAAAAAAAFFFFFFFFLL;
                v24[0]  = v23[0];
                v24[1]  = v23[1];
                TArabicJustEngine::TArabicJustEngine((TArabicJustEngine *)v24, v15);
                memset(v32, 170, sizeof(v32));
                id keys = 0;
                v31[0]  = 0;
                v31[1]  = 0;
                uint64_t v33 = v32;
                if (v16)
                {
                  std::vector<JustLeftRightMaxima,TInlineBufferAllocator<JustLeftRightMaxima,30ul>>::__vallocate[abi:nn180100]((char **)&keys, v16);
                  CFIndex v17 = (char *)v31[0];
                  bzero(v31[0], 24 * ((24 * v16 - 24) / 0x18) + 24);
                  v31[0]  = &v17[24 * v16];
                }
                if (TArabicJustEngine::GenerateMaximas((uint64_t)v24, (uint64_t)v35, v10))
                {
                  for (uint64_t i = (unsigned __int16 *)keys; i != v31[0]; i += 12)
                  {
                    if (i[8] < 2u)
                    {
                      if (i != v31[0])
                      {
                        char v8 = 1;
                        char v19 = 1;
                        goto LABEL_29;
                      }
                      break;
                    }
                  }
                  char v8 = 0;
                }
                char v19 = 0;
LABEL_29:
                p_id keys = &keys;
                std::vector<JustLeftRightMaxima,TInlineBufferAllocator<JustLeftRightMaxima,30ul>>::__destroy_vector::operator()[abi:nn180100](&p_keys);
                TArabicJustEngine::~TArabicJustEngine((TArabicJustEngine *)v24);
                if (v19) {
                  break;
                }
                v14 += 8;
              }
              while (v14 != v13);
            }
            if (values[31]) {
              std::__shared_weak_count::__release_shared[abi:nn180100]((std::__shared_weak_count *)values[31]);
            }
            TLine::~TLine((TLine *)values);

            TLine::~TLine((TLine *)v35);
            std::__shared_weak_count::__release_shared[abi:nn180100](v21);
            CTFontRef v6 = v22;
            goto LABEL_36;
          }
        }
      }
LABEL_15:
      char v8 = 0;
LABEL_36:

      goto LABEL_37;
    }
  }
  char v8 = 0;
  return v8 & 1;
}

CFStringRef CTIsExuberatedLanguage(const __CFString *result)
{
  if (result)
  {
    CFStringRef v1 = result;
    CFRange result = (const __CFString *)CFStringGetLength(result);
    if (result) {
      return (const __CFString *)(GetExuberatedGroupForLanguage(v1, 0) != 0);
    }
  }
  return result;
}

unint64_t CTCopyLanguageIdentifierNormalizedForLocalizedNames(__CFString *a1)
{
  LanguageIdentifierByNormalizing(a1, 1u, (atomic_ullong *)&v3);
  unint64_t v1 = atomic_exchange((atomic_ullong *volatile)&v3, 0);

  return v1;
}

void *_CTEnumerateScriptRanges(void *result)
{
  v1[4]  = *MEMORY[0x1E4F143B8];
  if (result)
  {
    v1[0]  = &unk_1ED05FF60;
    v1[1]  = result;
    v1[3]  = v1;
    TOpenTypeMorph::EnumerateScriptRanges((uint64_t)v1);
    return std::__function::__value_func<void ()(unsigned int,CFRange)>::~__value_func[abi:nn180100](v1);
  }
  return result;
}

void CTStringIsSuitableForArabicJustification::$_0::__invoke(CTStringIsSuitableForArabicJustification::$_0 *this, void *a2)
{
  CFCharacterSetRef v2 = CTFontCopyCharacterSet(this);
  id v6 = (id)0xAAAAAAAAAAAAAAAALL;
  TCFMutableCharacterSet::TCFMutableCharacterSet((TCFMutableCharacterSet *)&v6, v2);
  CFCharacterSetRef Predefined = CFCharacterSetGetPredefined(kCFCharacterSetPunctuation);
  if (Predefined) {
    CFCharacterSetUnion((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v6, memory_order_acquire), Predefined);
  }
  v7.CFIndex location = 48;
  v7.CFIndex length = 10;
  CFCharacterSetAddCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v6, memory_order_acquire), v7);
  CFCharacterSetInvert((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v6, memory_order_acquire));
  CFCharacterSetRef v4 = CFCharacterSetGetPredefined(kCFCharacterSetNewline);
  if (v4) {
    CFCharacterSetUnion((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&v6, memory_order_acquire), v4);
  }
  unint64_t v5 = atomic_exchange((atomic_ullong *volatile)&v6, 0);
  _CFCharacterSetCompact();
  _MergedGlobals_29  = v5;
}

void std::__function::__func<_CTGetVisibleFormatterCharacterSet::$_0::operator() const(void *)::{lambda(unsigned int)#1},std::allocator<_CTGetVisibleFormatterCharacterSet::$_0::operator() const(void *)::{lambda(unsigned int)#1}>,void ()(unsigned int)>::~__func()
{
}

void *std::__function::__func<_CTGetVisibleFormatterCharacterSet::$_0::operator() const(void *)::{lambda(unsigned int)#1},std::allocator<_CTGetVisibleFormatterCharacterSet::$_0::operator() const(void *)::{lambda(unsigned int)#1}>,void ()(unsigned int)>::__clone(uint64_t a1)
{
  CFRange result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *CFRange result = &unk_1ED061FB8;
  result[1]  = v3;
  return result;
}

void std::__function::__func<_CTEnumerateScriptRanges::$_0,std::allocator<_CTEnumerateScriptRanges::$_0>,void ()(unsigned int,CFRange)>::~__func()
{
}

void *std::__function::__func<_CTEnumerateScriptRanges::$_0,std::allocator<_CTEnumerateScriptRanges::$_0>,void ()(unsigned int,CFRange)>::__clone(uint64_t a1)
{
  CFRange result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *CFRange result = &unk_1ED05FF60;
  result[1]  = v3;
  return result;
}

uint64_t std::__function::__func<_CTEnumerateScriptRanges::$_0,std::allocator<_CTEnumerateScriptRanges::$_0>,void ()(unsigned int,CFRange)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2  = &unk_1ED05FF60;
  a2[1]  = v2;
  return result;
}

uint64_t std::__function::__func<_CTEnumerateScriptRanges::$_0,std::allocator<_CTEnumerateScriptRanges::$_0>,void ()(unsigned int,CFRange)>::operator()(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 16))();
}

uint64_t TBaseFont::CopyMetadata@<X0>(TBaseFont *this@<X0>, int a2@<W1>, void *a3@<X8>)
{
  uint64_t result = TBaseFont::GetInitializedGraphicsFont(this);
  if (result)
  {
    uint64_t result = CGFontGetParserFont();
    if (result)
    {
      if (a2) {
        FPFontGetDefaultInstance();
      }
      uint64_t result = FPFontCopyMetadata();
    }
  }
  *a3  = result;
  return result;
}

void TBaseFont::CopyOTName(unsigned int *a1@<X2>, int a2@<W1>, void *a3@<X8>)
{
}

void TBaseFont::CopyLocalizedName(atomic_ullong *this@<X0>, const __CFString *a2@<X1>, CFArrayRef theArray@<X2>, const __CFString **a4@<X3>, atomic_ullong *a5@<X8>)
{
  v36[3]  = *MEMORY[0x1E4F143B8];
  if (!theArray || (CFArrayRef v9 = theArray, !CFArrayGetCount(theArray))) {
    CFArrayRef v9 = 0;
  }
  TBaseFont::CopyAttributeInternal(this, @"CTFontLocalizedNames", &v35);
  uint64_t v10 = (void *)atomic_exchange((atomic_ullong *volatile)&v35, 0);

  CFDictionaryRef Value = v10;
  CFDictionaryRef v12 = Value;
  if (Value) {
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(Value, a2);
  }
  *a5  = (atomic_ullong)Value;

  unint64_t explicit = atomic_load_explicit(a5, memory_order_acquire);
  if (!v9 && explicit)
  {
    CFDictionaryRef v14 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)v10, @"language map");
    if (v14) {
      id v15 = (id)CFDictionaryGetValue(v14, a2);
    }
    else {
      id v15 = 0;
    }
    id v35 = (id)0xAAAAAAAAAAAAAAAALL;
    CopyPreferredLanguage((atomic_ullong *)&v35);
    id v16 = (id)atomic_load_explicit((atomic_ullong *volatile)&v35, memory_order_acquire);
    if (v16 == v15)
    {

      if (!a4)
      {
LABEL_21:
        id v20 = v35;
        goto LABEL_42;
      }
LABEL_18:
      CFDictionaryRef v19 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)v10, @"actual language");
      if (v19) {
        CFDictionaryRef v19 = (const __CFDictionary *)CFDictionaryGetValue(v19, a2);
      }
      *a4  = (const __CFString *)v19;
      goto LABEL_21;
    }
    CFIndex v17 = v16;
    if (v15 && v16)
    {
      int v18 = CFEqual(v15, v16);

      if (v18)
      {
        if (!a4) {
          goto LABEL_21;
        }
        goto LABEL_18;
      }
    }
    else
    {
    }
  }
  id v34 = (id)0xAAAAAAAAAAAAAAAALL;
  id v35 = &unk_1ED05FFA8;
  v36[2]  = (unint64_t)&v35;
  CreateCopyOfArrayByApplyingFunction(v9, (uint64_t)&v35, &v34);
  std::__function::__value_func<TCFRef<void const*> ()(void const*)>::~__value_func[abi:nn180100](&v35);
  if (!atomic_load_explicit((atomic_ullong *volatile)&v34, memory_order_acquire))
  {
    CreateNormalizedPreferredLanguages(&v35);
  }
  id v33 = 0;
  int64_t v21 = (CGFont *)(*(uint64_t (**)(atomic_ullong *))(*this + 576))(this);
  int v22 = FontNameCodeForKey(a2);
  CFArrayRef v23 = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v34, memory_order_acquire);
  id v35 = &v33;
  v36[0]  = 0;
  CopyLocalizedFontNameInternal(v23, v21, 0, v22, v36, 0, (atomic_ullong *)&v32);

  unint64_t v24 = atomic_load_explicit(a5, memory_order_acquire);
  if (!v9 && v24)
  {
    id v35 = (id)0xAAAAAAAAAAAAAAAALL;
    TCFMutableDictionary::TCFMutableDictionary((TCFMutableDictionary *)&v35, (CFDictionaryRef)v10);
    CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v35, memory_order_acquire), a2, (const void *)atomic_load_explicit(a5, memory_order_acquire));
    if (atomic_load_explicit((atomic_ullong *volatile)&v33, memory_order_acquire))
    {
      id v32 = (id)0xAAAAAAAAAAAAAAAALL;
      CopyPreferredLanguage((atomic_ullong *)&v32);
      if (atomic_load_explicit((atomic_ullong *volatile)&v32, memory_order_acquire))
      {
        id v31 = (id)0xAAAAAAAAAAAAAAAALL;
        CFDictionaryRef v25 = v10;
        CFDictionaryRef v26 = v25;
        if (v25) {
          long long v27 = (void *)CFDictionaryGetValue(v25, @"language map");
        }
        else {
          long long v27 = 0;
        }
        TCFMutableDictionary::TCFMutableDictionary((TCFMutableDictionary *)&v31, v27);

        CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v31, memory_order_acquire), a2, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v32, memory_order_acquire));
        CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v35, memory_order_acquire), @"language map", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v31, memory_order_acquire));
      }
      id v32 = (id)0xAAAAAAAAAAAAAAAALL;
      CFDictionaryRef v28 = v10;
      CFDictionaryRef v29 = v28;
      if (v28) {
        long long v30 = (void *)CFDictionaryGetValue(v28, @"actual language");
      }
      else {
        long long v30 = 0;
      }
      TCFMutableDictionary::TCFMutableDictionary((TCFMutableDictionary *)&v32, v30);

      CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v32, memory_order_acquire), a2, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v33, memory_order_acquire));
      CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v35, memory_order_acquire), @"actual language", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v32, memory_order_acquire));
    }
    TBaseFont::SetAttributeInternal<__CFDictionary const*>(this, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v35, memory_order_acquire), @"CTFontLocalizedNames");
  }
  if (a4) {
    *a4  = (const __CFString *)atomic_exchange((atomic_ullong *volatile)&v33, 0);
  }

  id v20 = v34;
LABEL_42:
}

void TBaseFont::CopyLocalizedNameID(TBaseFont *this@<X0>, CFArrayRef theArray@<X2>, const __CFString **a3@<X3>, int a4@<W1>, atomic_ullong *a5@<X8>)
{
  v15[3]  = *MEMORY[0x1E4F143B8];
  id v13 = 0;
  if (theArray && CFArrayGetCount(theArray))
  {
    CFDictionaryRef v14 = (atomic_ullong *)&unk_1ED05FFA8;
    v15[2]  = (unint64_t)&v14;
    CreateCopyOfArrayByApplyingFunction(theArray, (uint64_t)&v14, &v12);
    std::__function::__value_func<TCFRef<void const*> ()(void const*)>::~__value_func[abi:nn180100](&v14);
  }
  uint64_t v10 = (CGFont *)(*(uint64_t (**)(TBaseFont *))(*(void *)this + 576))(this);
  id v12 = 0;
  *a5  = 0xAAAAAAAAAAAAAAAALL;
  CFArrayRef explicit = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v13, memory_order_acquire);
  CFDictionaryRef v14 = (atomic_ullong *)&v12;
  v15[0]  = 0;
  CopyLocalizedFontNameInternal(explicit, v10, 0, a4, v15, 0, a5);

  if (a3) {
    *a3  = (const __CFString *)atomic_exchange((atomic_ullong *volatile)&v12, 0);
  }
}

BOOL TBaseFont::HasPostScriptNameAlias(atomic_ullong *this, __CFString *theString)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  if (!theString || !CFStringGetLength(theString)) {
    return 0;
  }
  CFArrayRef explicit = (__CFString *)atomic_load_explicit(this + 12, memory_order_acquire);
  if (explicit != theString
    && (!explicit || !CFEqual(explicit, theString))
    && !IsPostScriptNameAlias(theString, explicit))
  {
    id v24 = (id)0xAAAAAAAAAAAAAAAALL;
    TDescriptorSource::TDescriptorSource((TDescriptorSource *)&v23);
    TDescriptorSource::CopyFontDescriptorFromVariationPostScriptName(theString, &v24);
    if (!atomic_load_explicit((atomic_ullong *volatile)&v24, memory_order_acquire)) {
      goto LABEL_19;
    }
    id v23 = (id)CTFontDescriptorCopyAttribute((CTFontDescriptorRef)atomic_load_explicit((atomic_ullong *volatile)&v24, memory_order_acquire), @"NSCTFontPostScriptNameAttribute");
    unint64_t v5 = (void *)atomic_exchange((atomic_ullong *volatile)&v23, 0);

    id v6 = v5;
    if (v6 == explicit)
    {
    }
    else
    {
      CFRange v7 = v6;
      if (!explicit || !v6)
      {

        goto LABEL_19;
      }
      int v8 = CFEqual(v6, explicit);

      if (!v8)
      {
LABEL_19:

        id v22 = 0;
        if (!atomic_load_explicit((atomic_ullong *volatile)&v22, memory_order_acquire))
        {
          id v24 = (id)0xAAAAAAAAAAAAAAAALL;
          TBaseFont::CopyMetadata((TBaseFont *)this, 0, &v24);
          CFDictionaryRef v11 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)&v24, memory_order_acquire);
          CFDictionaryRef v12 = v11;
          if (v11) {
            CFDictionaryRef Value = (void *)CFDictionaryGetValue(v11, @"MTD_Typeface_ID_ATS_PostscriptName_Aliases");
          }
          else {
            CFDictionaryRef Value = 0;
          }
          TCFRef<__CTFont const*>::Retain((atomic_ullong *)&v22, Value);
        }
        CFArrayRef v14 = (const __CFArray *)(id)atomic_load_explicit((atomic_ullong *volatile)&v22, memory_order_acquire);
        if (v14)
        {
          CFArrayRef v15 = v14;
          CFIndex Count = CFArrayGetCount(v14);

          if (Count >= 1)
          {
            *(void *)&long long v17 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v17 + 1)  = 0xAAAAAAAAAAAAAAAALL;
            v27[14]  = v17;
            v27[13]  = v17;
            v27[12]  = v17;
            v27[11]  = v17;
            v27[10]  = v17;
            v27[9]  = v17;
            v27[8]  = v17;
            v27[7]  = v17;
            v27[6]  = v17;
            v27[5]  = v17;
            v27[3]  = v17;
            v27[4]  = v17;
            v27[1]  = v17;
            v27[2]  = v17;
            v27[0]  = v17;
            CFDictionaryRef v25 = 0;
            uint64_t v26 = 0;
            id v24 = 0;
            CFDictionaryRef v28 = v27;
            std::vector<long,TInlineBufferAllocator<long,30ul>>::__vallocate[abi:nn180100](&v24, Count);
            int v18 = (char *)v25;
            bzero(v25, 8 * Count);
            CFDictionaryRef v25 = &v18[8 * Count];
            CFArrayRef v19 = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v22, memory_order_acquire);
            v30.CFIndex location = 0;
            v30.CFIndex length = Count;
            CFArrayGetValues(v19, v30, (const void **)v24);
            CFSetRef v20 = CFSetCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)v24, Count, MEMORY[0x1E4F1D050]);
            id v21 = v20;
            TBaseFont::SetAttributeInternal<TCFRef<__CFSet const*>>(this, (atomic_ullong *)&v21, @"CTFontPostScriptNameAliases");

            BOOL v9 = CFSetContainsValue(v20, theString) != 0;
            id v23 = &v24;
            std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v23);
LABEL_29:

            return v9;
          }
        }
        else
        {
        }
        TBaseFont::SetAttributeInternal<__CFDictionary const*>(this, (const void *)*MEMORY[0x1E4F1D260], @"CTFontPostScriptNameAliases");
        BOOL v9 = 0;
        goto LABEL_29;
      }
    }
  }
  return 1;
}

uint64_t TBaseFont::IsBaseVariation(TBaseFont *this, CFDictionaryRef theDict)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  if (!theDict) {
    return 1;
  }
  CFIndex Count = CFDictionaryGetCount(theDict);
  if (!Count) {
    return 1;
  }
  unint64_t v5 = Count;
  id v32 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr, TBaseFont *))(*(void *)this + 112))(&v32, this);
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)&v32, memory_order_acquire);

  if (explicit)
  {
    id v25 = (id)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(id *__return_ptr, TBaseFont *))(*(void *)this + 120))(&v25, this);
    CFArrayRef v7 = (const __CFArray *)(id)atomic_load_explicit((atomic_ullong *volatile)&v25, memory_order_acquire);
    if (v7)
    {
      CFArrayRef v8 = v7;
      CFIndex v9 = CFArrayGetCount(v7);

      if (v9)
      {
        *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v10 + 1)  = 0xAAAAAAAAAAAAAAAALL;
        v35[14]  = v10;
        v35[13]  = v10;
        v35[12]  = v10;
        v35[11]  = v10;
        v35[10]  = v10;
        v35[9]  = v10;
        v35[8]  = v10;
        v35[7]  = v10;
        v35[6]  = v10;
        v35[5]  = v10;
        v35[4]  = v10;
        v35[3]  = v10;
        v35[2]  = v10;
        v35[1]  = v10;
        v35[0]  = v10;
        id v32 = 0;
        id v33 = 0;
        uint64_t v34 = 0;
        long long v36 = v35;
        std::vector<long,TInlineBufferAllocator<long,30ul>>::__vallocate[abi:nn180100](&v32, v5);
        CFDictionaryRef v11 = (char *)v33;
        bzero(v33, 8 * v5);
        id v33 = &v11[8 * v5];
        *(void *)&long long v12 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v12 + 1)  = 0xAAAAAAAAAAAAAAAALL;
        v30[14]  = v12;
        v30[13]  = v12;
        v30[12]  = v12;
        v30[11]  = v12;
        v30[10]  = v12;
        v30[9]  = v12;
        v30[8]  = v12;
        v30[7]  = v12;
        v30[6]  = v12;
        v30[5]  = v12;
        v30[4]  = v12;
        void v30[3] = v12;
        v30[2]  = v12;
        v30[1]  = v12;
        v30[0]  = v12;
        CFDictionaryRef v28 = 0;
        uint64_t v29 = 0;
        id values = 0;
        id v31 = v30;
        std::vector<long,TInlineBufferAllocator<long,30ul>>::__vallocate[abi:nn180100](&values, v5);
        id v13 = (char *)v28;
        bzero(v28, 8 * v5);
        CFDictionaryRef v28 = &v13[8 * v5];
        CFDictionaryGetKeysAndValues(theDict, (const void **)v32, (const void **)values);
        CFArrayRef v14 = (CFTypeRef *)v32;
        CFArrayRef v15 = values;
        while (1)
        {
          CFTypeID v16 = CFGetTypeID(*v15);
          if (v16 != CFNumberGetTypeID()) {
            break;
          }
          CFArrayRef v17 = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v25, memory_order_acquire);
          if (!v17) {
            break;
          }
          CFIndex v18 = CFArrayGetCount(v17);
          if (!v18) {
            break;
          }
          CFIndex v19 = v18;
          CFIndex v20 = 0;
          --v5;
          while (1)
          {
            CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v17, v20);
            CFDictionaryRef Value = CFDictionaryGetValue(ValueAtIndex, @"NSCTVariationAxisIdentifier");
            if (CFEqual(Value, *v14))
            {
              double valuePtr = NAN;
              CFNumberGetValue((CFNumberRef)*v15, kCFNumberDoubleType, &valuePtr);
              if (IsValueInRangeOfAxis(valuePtr, ValueAtIndex)) {
                break;
              }
            }
            if (v19 == ++v20) {
              goto LABEL_19;
            }
          }
          ++v14;
          ++v15;
          if (!v5)
          {
            uint64_t v23 = 1;
            goto LABEL_20;
          }
        }
LABEL_19:
        uint64_t v23 = 0;
LABEL_20:
        double valuePtr = COERCE_DOUBLE(&values);
        std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&valuePtr);
        id values = &v32;
        std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](&values);
        goto LABEL_23;
      }
    }
    else
    {
    }
    uint64_t v23 = 0;
LABEL_23:

    return v23;
  }
  return 0;
}

BOOL TBaseFont::HasFeature(TBaseFont *this, int a2, int a3)
{
  id v8 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr))(*(void *)this + 136))(&v7);
  id v8 = (id)atomic_exchange((atomic_ullong *volatile)&v7, 0);

  BOOL v5 = TFontFeatures::GetFeatureSelector((atomic_ullong *)&v8, a2, a3) != 0;
  return v5;
}

void AddSynthesizedCharactersToCharacterSet(atomic_ullong *a1, const TBaseFont *a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v3 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v3 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  v11[2]  = v3;
  v11[3]  = v3;
  v11[0]  = v3;
  v11[1]  = v3;
  CFIndex v9 = 0;
  uint64_t v10 = 0;
  id v8 = 0;
  long long v12 = v11;
  AddSynthesizableCharacters(atomic_load_explicit(a1, memory_order_acquire), &v8);
  CFCharacterSetRef v4 = v8;
  BOOL v5 = v9;
  while (v4 != v5)
  {
    unsigned int v6 = *(unsigned __int16 *)v4;
    v4 += 2;
    v14.CFIndex location = v6;
    v14.CFIndex length = 1;
    CFCharacterSetAddCharactersInRange((CFMutableCharacterSetRef)atomic_load_explicit(a1, memory_order_acquire), v14);
  }
  id v7 = &v8;
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v7);
}

void TBaseFont::CopyRepertoireRange(void *a1@<X8>)
{
  id v2 = 0;
  *a1  = atomic_exchange((atomic_ullong *volatile)&v2, 0);
}

void OS2::OS2(OS2 *this, id a2)
{
  id v3 = a2;
  OS2::OS2((atomic_ullong *)this, (atomic_ullong *)&v3);
}

BOOL TBaseFont::SupportsLanguages(TBaseFont *this, const __CFArray *a2)
{
  TBaseFont::CopyAttributeInternal((atomic_ullong *)this, @"NSCTFontLanguagesAttribute", &v26);
  CFArrayRef v4 = (const __CFArray *)atomic_exchange((atomic_ullong *volatile)&v26, 0);

  if (!v4 || !ArrayContainsAllValues(v4, a2))
  {
    if ((*((_DWORD *)this + 46) & 0x100000) == 0)
    {
      atomic_load_explicit((atomic_ullong *volatile)this + 12, memory_order_acquire);
      atomic_fetch_or_explicit((atomic_uint *volatile)this + 45, 0, memory_order_relaxed);
      atomic_fetch_or_explicit((atomic_uint *volatile)this + 46, 0x100000u, memory_order_relaxed);
    }
    if ((*((_DWORD *)this + 45) & 0x100000) != 0)
    {
      BOOL v5 = 0;
      goto LABEL_38;
    }
    id v26 = (id)0xAAAAAAAAAAAAAAAALL;
    TBaseFont::CopySupportedLanguagesFromMetadata((atomic_ullong *)&v26, (atomic_ullong *)this);
    if (atomic_load_explicit((atomic_ullong *volatile)&v26, memory_order_acquire))
    {
      BOOL v5 = ArrayContainsAllValues((const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v26, memory_order_acquire), a2);
      id v6 = v26;
LABEL_37:

      goto LABEL_38;
    }

    TBaseFont::CopyAttributeInternal((atomic_ullong *)this, @"CTCheckedLanguages", &v26);
    id v7 = (void *)atomic_exchange((atomic_ullong *volatile)&v26, 0);

    if (a2)
    {
      CFIndex Count = CFArrayGetCount(a2);
      if (Count)
      {
        CFIndex v9 = Count;
        for (CFIndex i = 0; v9 != i; ++i)
        {
          CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(a2, i);
          CFSetRef v12 = v7;
          if (v12)
          {
            CFSetRef v13 = v12;
            int v14 = CFSetContainsValue(v12, ValueAtIndex);

            if (v14)
            {
              BOOL v5 = 0;
              goto LABEL_36;
            }
          }
          else
          {
          }
        }
      }
    }
    id v26 = (id)0xAAAAAAAAAAAAAAAALL;
    TCFMutableSet::TCFMutableSet((TCFMutableSet *)&v26, (CFSetRef)v7);
    id v25 = (id)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(id *__return_ptr, TBaseFont *))(*(void *)this + 768))(&v25, this);
    if (atomic_load_explicit((atomic_ullong *volatile)&v25, memory_order_acquire))
    {
      if (!a2 || (CFIndex v15 = CFArrayGetCount(a2)) == 0)
      {
LABEL_24:
        id v24 = (id)0xAAAAAAAAAAAAAAAALL;
        TCFMutableArray::TCFMutableArray((TCFMutableArray *)&v24, v4);
        TCFMutableArray::AppendArray<__CFArray const*>((atomic_ullong *)&v24, a2);
        unint64_t explicit = (const void *)atomic_load_explicit((atomic_ullong *volatile)&v24, memory_order_acquire);
        os_unfair_lock_lock_with_options();
        id v21 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)this + 15, memory_order_acquire);
        if (explicit)
        {
          if (!v21) {
            TBaseFont::InitAttributesDict((atomic_ullong *)this);
          }
          id v22 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)this + 15, memory_order_acquire);
          if (v22) {
            CFDictionarySetValue(v22, @"NSCTFontLanguagesAttribute", explicit);
          }
        }
        else if (v21)
        {
          CFDictionaryRemoveValue(v21, @"NSCTFontLanguagesAttribute");
        }
        os_unfair_lock_unlock((os_unfair_lock_t)this + 28);
        TBaseFont::SetAttributeInternal<__CFSet const*>((atomic_ullong *)this, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v26, memory_order_acquire));

        BOOL v5 = 1;
LABEL_35:

LABEL_36:
        id v6 = v7;
        goto LABEL_37;
      }
      CFIndex v16 = v15;
      CFIndex v17 = 0;
      while (1)
      {
        CFStringRef v18 = (const __CFString *)CFArrayGetValueAtIndex(a2, v17);
        CFSetAddValue((CFMutableSetRef)atomic_load_explicit((atomic_ullong *volatile)&v26, memory_order_acquire), v18);
        TLocaleManager::TLocaleManager((TLocaleManager *)&v24);
        CFCharacterSetRef v19 = (const __CFCharacterSet *)atomic_load_explicit((atomic_ullong *volatile)&v25, memory_order_acquire);
        LOBYTE(v18)  = TLocaleManagerImp::CharacterSetCoversLanguage((atomic_ullong *)v24, v19, v18);
        os_unfair_lock_unlock((os_unfair_lock_t)v24 + 6);
        if ((v18 & 1) == 0) {
          break;
        }
        if (v16 == ++v17) {
          goto LABEL_24;
        }
      }
    }
    else if (a2)
    {
      objc_msgSend((id)atomic_load_explicit((atomic_ullong *volatile)&v26, memory_order_acquire), "addObjectsFromArray:", a2);
    }

    TBaseFont::SetAttributeInternal<__CFSet const*>((atomic_ullong *)this, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v26, memory_order_acquire));
    BOOL v5 = 0;
    goto LABEL_35;
  }
  BOOL v5 = 1;
LABEL_38:

  return v5;
}

BOOL ArrayContainsAllValues(const __CFArray *a1, const __CFArray *a2)
{
  CFIndex Count = CFArrayGetCount(a1);
  if (!a2) {
    return 1;
  }
  CFIndex v5 = Count;
  CFIndex v6 = CFArrayGetCount(a2);
  if (!v6) {
    return 1;
  }
  CFIndex v7 = 0;
  CFIndex v8 = v6 - 1;
  do
  {
    CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(a2, v7);
    v13.CFIndex location = 0;
    v13.CFIndex length = v5;
    int v10 = CFArrayContainsValue(a1, v13, ValueAtIndex);
    BOOL result = v10 != 0;
    if (!v10) {
      break;
    }
  }
  while (v8 != v7++);
  return result;
}

void TCFMutableArray::AppendArray<__CFArray const*>(atomic_ullong *a1, CFArrayRef theArray)
{
  unint64_t explicit = (__CFArray *)atomic_load_explicit(a1, memory_order_acquire);
  if (theArray) {
    v4.CFIndex length = CFArrayGetCount(theArray);
  }
  else {
    v4.CFIndex length = 0;
  }
  v4.CFIndex location = 0;

  CFArrayAppendArray(explicit, theArray, v4);
}

void TBaseFont::SetAttributeInternal<__CFSet const*>(atomic_ullong *a1, const void *a2)
{
  CFRange v4 = (os_unfair_lock_s *)(a1 + 14);
  os_unfair_lock_lock_with_options();
  unint64_t explicit = (__CFDictionary *)atomic_load_explicit(a1 + 15, memory_order_acquire);
  if (a2)
  {
    if (!explicit) {
      TBaseFont::InitAttributesDict(a1);
    }
    CFIndex v6 = (__CFDictionary *)atomic_load_explicit(a1 + 15, memory_order_acquire);
    if (v6) {
      CFDictionarySetValue(v6, @"CTCheckedLanguages", a2);
    }
  }
  else if (explicit)
  {
    CFDictionaryRemoveValue(explicit, @"CTCheckedLanguages");
  }

  os_unfair_lock_unlock(v4);
}

void TBaseFont::CopyMacintoshEncodings(atomic_ullong *this@<X0>, atomic_ullong *a2@<X8>)
{
  *a2  = 0xAAAAAAAAAAAAAAAALL;
  TBaseFont::CopyAttributeInternal(this, @"NSCTFontMacintoshEncodingsAttribute", &valuePtr);
  *a2  = atomic_exchange((atomic_ullong *volatile)&valuePtr, 0);

  if (!atomic_load_explicit(a2, memory_order_acquire))
  {
    id v23 = (id)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(id *__return_ptr, atomic_ullong *, uint64_t))(*this + 480))(&v23, this, 1668112752);
    CFDataRef v4 = (const __CFData *)(id)atomic_load_explicit((atomic_ullong *volatile)&v23, memory_order_acquire);
    CFDataRef v5 = v4;
    if (v4) {
      BytePtr  = CFDataGetBytePtr(v4);
    }
    else {
      BytePtr  = 0;
    }

    id v7 = (id)atomic_load_explicit((atomic_ullong *volatile)&v23, memory_order_acquire);
    CFDataRef v8 = (const __CFData *)v7;
    if (v8)
    {
      CFDataRef v9 = v8;
      int v10 = CFDataGetBytePtr(v8);

      if (v10) {
        v10 += CFDataGetLength((CFDataRef)v7);
      }
    }
    else
    {

      int v10 = 0;
    }

    unsigned int v11 = 0;
    if (BytePtr)
    {
      CFSetRef v12 = BytePtr + 4;
      if (BytePtr + 4 <= v10)
      {
        unsigned int v13 = bswap32(*((unsigned __int16 *)BytePtr + 1)) >> 16;
        unint64_t v14 = (unint64_t)&v12[8 * v13];
        if (BytePtr + 12 <= v10) {
          unsigned int v15 = (v10 - v12) >> 3;
        }
        else {
          LOWORD(v15)  = 0;
        }
        if (v14 <= (unint64_t)v10 && v14 >= (unint64_t)v12) {
          LOWORD(v17)  = v13;
        }
        else {
          LOWORD(v17)  = v15;
        }
        if ((_WORD)v17)
        {
          unsigned int v11 = 0;
          uint64_t v17 = (unsigned __int16)v17;
          CFStringRef v18 = (unsigned __int16 *)(BytePtr + 6);
          do
          {
            if (*(v18 - 1) == 256)
            {
              unsigned int v19 = bswap32(*v18) >> 16;
              if (v19 >= 0x20) {
                int v20 = 0;
              }
              else {
                int v20 = 1 << v19;
              }
              v11 |= v20;
            }
            v18 += 4;
            --v17;
          }
          while (v17);
        }
        else
        {
          unsigned int v11 = 0;
        }
      }
    }
    id valuePtr = (id)v11;
    id v22 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberLongType, &valuePtr);

    if (atomic_load_explicit(a2, memory_order_acquire))
    {
      id v21 = (id)atomic_load_explicit(a2, memory_order_acquire);
      TBaseFont::SetAttributeInternal<TCFRef<__CFSet const*>>(this, (atomic_ullong *)&v21, @"NSCTFontMacintoshEncodingsAttribute");
    }
  }
}

void TBaseFont::CopyDesignLanguagesFromMetadata(TBaseFont *this, TBaseFont *a2)
{
  id v5 = (id)0xAAAAAAAAAAAAAAAALL;
  TBaseFont::CopyMetadata(a2, 0, &v4);
  if (atomic_load_explicit((atomic_ullong *volatile)&v4, memory_order_acquire)) {
    CFDictionaryRef Value = (void *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v4, memory_order_acquire), @"MTD_Typeface_Repertoire_PrimaryScriptLanguages");
  }
  else {
    CFDictionaryRef Value = 0;
  }
  id v5 = Value;

  if (atomic_load_explicit((atomic_ullong *volatile)&v5, memory_order_acquire))
  {
    *(void *)this  = atomic_exchange((atomic_ullong *volatile)&v5, 0);
  }
  else
  {

    *(void *)this  = 0;
  }
}

void TBaseFont::CopyDesignLanguages(TBaseFont *this@<X0>, atomic_ullong *a2@<X8>)
{
  *a2  = 0xAAAAAAAAAAAAAAAALL;
  TBaseFont::CopyAttributeInternal((atomic_ullong *)this, @"NSCTFontDesignLanguagesAttribute", &v5);
  *a2  = atomic_exchange((atomic_ullong *volatile)&v5, 0);

  if ((*((_DWORD *)this + 46) & 0x200000) == 0)
  {
    atomic_load_explicit((atomic_ullong *volatile)this + 12, memory_order_acquire);
    atomic_fetch_or_explicit((atomic_uint *volatile)this + 45, 0, memory_order_relaxed);
    atomic_fetch_or_explicit((atomic_uint *volatile)this + 46, 0x200000u, memory_order_relaxed);
  }
  if ((*((_DWORD *)this + 45) & 0x200000) == 0)
  {
    TBaseFont::CopyDesignLanguagesFromMetadata((TBaseFont *)&v5, this);

    if (!atomic_load_explicit(a2, memory_order_acquire))
    {
      (*(void (**)(id *__return_ptr, TBaseFont *))(*(void *)this + 336))(&v5, this);
    }
    id v4 = (id)atomic_load_explicit(a2, memory_order_acquire);
    TBaseFont::SetAttributeInternal<TCFRef<__CFSet const*>>((atomic_ullong *)this, (atomic_ullong *)&v4, @"NSCTFontDesignLanguagesAttribute");

    atomic_fetch_or_explicit((atomic_uint *volatile)this + 45, 0x200000u, memory_order_relaxed);
    atomic_fetch_or_explicit((atomic_uint *volatile)this + 46, 0x200000u, memory_order_relaxed);
  }
  if (!atomic_load_explicit(a2, memory_order_acquire))
  {
    id v5 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, MEMORY[0x1E4F1D510]);
  }
}

BOOL TBaseFont::HasDesignLanguages(TBaseFont *this, const __CFArray *a2)
{
  TBaseFont::CopyAttributeInternal((atomic_ullong *)this, @"NSCTFontDesignLanguagesAttribute", &v8);
  CFArrayRef v4 = (const __CFArray *)atomic_exchange((atomic_ullong *volatile)&v8, 0);

  if ((*((_DWORD *)this + 46) & 0x200000) == 0)
  {
    atomic_load_explicit((atomic_ullong *volatile)this + 12, memory_order_acquire);
    atomic_fetch_or_explicit((atomic_uint *volatile)this + 45, 0, memory_order_relaxed);
    atomic_fetch_or_explicit((atomic_uint *volatile)this + 46, 0x200000u, memory_order_relaxed);
  }
  if ((*((_DWORD *)this + 45) & 0x200000) != 0)
  {
    if (!v4)
    {
      BOOL v5 = 0;
      goto LABEL_11;
    }
    uint64_t v6 = ArrayContainsAllValues(v4, a2);
    goto LABEL_9;
  }
  id v8 = (id)0xAAAAAAAAAAAAAAAALL;
  TBaseFont::CopyDesignLanguagesFromMetadata((TBaseFont *)&v8, this);
  if (!atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire))
  {

    uint64_t v6 = (*(uint64_t (**)(TBaseFont *, const __CFArray *))(*(void *)this + 344))(this, a2);
LABEL_9:
    BOOL v5 = v6;
    goto LABEL_11;
  }
  BOOL v5 = ArrayContainsAllValues((const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire), a2);

LABEL_11:
  return v5;
}

uint64_t TBaseFont::GetUnicodeEncoding(TBaseFont *this)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *((unsigned int *)this + 86);
  if (!v1)
  {
    id v31 = (id)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(id *__return_ptr))(*(void *)this + 480))(&v31);
    CFDataRef v3 = (const __CFData *)(id)atomic_load_explicit((atomic_ullong *volatile)&v31, memory_order_acquire);
    CFDataRef v4 = v3;
    if (v3) {
      BytePtr  = CFDataGetBytePtr(v3);
    }
    else {
      BytePtr  = 0;
    }

    id v6 = (id)atomic_load_explicit((atomic_ullong *volatile)&v31, memory_order_acquire);
    CFDataRef v7 = (const __CFData *)v6;
    if (v7)
    {
      CFDataRef v8 = v7;
      CFDataRef v9 = CFDataGetBytePtr(v7);

      if (v9) {
        v9 += CFDataGetLength((CFDataRef)v6);
      }
    }
    else
    {

      CFDataRef v9 = 0;
    }

    uint64_t v1 = 0;
    if (BytePtr)
    {
      int v10 = BytePtr + 4;
      if (BytePtr + 4 <= v9)
      {
        unint64_t v34 = 0;
        unint64_t v33 = 0;
        int v35 = 0;
        unsigned int v11 = bswap32(*((unsigned __int16 *)BytePtr + 1)) >> 16;
        unint64_t v12 = (unint64_t)&v10[8 * v11];
        if (BytePtr + 12 <= v9) {
          unsigned int v13 = (v9 - v10) >> 3;
        }
        else {
          LOWORD(v13)  = 0;
        }
        if (v12 <= (unint64_t)v9 && v12 >= (unint64_t)v10) {
          unsigned __int16 v15 = v11;
        }
        else {
          unsigned __int16 v15 = v13;
        }
        if (v15)
        {
          uint64_t v16 = 0;
          unsigned int v17 = 0;
          int v18 = 0;
          unsigned int v19 = 0;
          unsigned int v20 = 0;
          unsigned int v21 = 0;
          int v22 = 0;
          unint64_t v23 = 0;
          id v24 = (unsigned __int16 *)(BytePtr + 6);
          do
          {
            unsigned int v25 = bswap32(*(v24 - 1)) >> 16;
            unsigned int v26 = bswap32(*v24) >> 16;
            if (v25 == 3)
            {
              uint64_t v27 = v23 | 1;
              if (v26 == 1) {
                unsigned int v28 = v16;
              }
              else {
                unsigned int v28 = v21;
              }
              if (v26 == 1) {
                v23 |= 4uLL;
              }
              if (v26 == 10)
              {
                unint64_t v23 = v27;
                int v22 = v16;
              }
              else
              {
                unsigned int v21 = v28;
              }
            }
            else if (!v25)
            {
              switch(v26)
              {
                case 0u:
                  v23 |= 0x20uLL;
                  int v18 = v16;
                  break;
                case 1u:
                  v23 |= 0x10uLL;
                  unsigned int v19 = v16;
                  break;
                case 2u:
                  v23 |= 8uLL;
                  unsigned int v20 = v16;
                  break;
                case 5u:
                case 6u:
                  break;
                default:
                  v23 |= 2uLL;
                  unsigned int v17 = v16;
                  break;
              }
            }
            v24 += 4;
            ++v16;
          }
          while (v15 != v16);
          unint64_t v34 = __PAIR64__(v19, v20);
          int v35 = v18;
          unint64_t v33 = __PAIR64__(v21, v17);
        }
        else
        {
          unint64_t v23 = 0;
          int v22 = 0;
        }
        uint64_t v29 = 0;
        int v32 = v22;
        while (((v23 >> v29) & 1) == 0)
        {
          if (++v29 == 6)
          {
            uint64_t v1 = 0;
            goto LABEL_45;
          }
        }
        uint64_t v1 = (*(&v32 + v29) + 1);
        *((_DWORD *)this + 86)  = v1;
      }
    }
LABEL_45:
  }
  return v1;
}

uint64_t TBaseFont::GetStringEncoding(atomic_ullong *this)
{
  v33[2]  = *MEMORY[0x1E4F143B8];
  unsigned int valuePtr = -1;
  TBaseFont::CopyAttributeInternal(this, @"NSCTFontStringEncodingAttribute", v30);
  id v2 = (void *)atomic_exchange((atomic_ullong *volatile)v30, 0);

  if (v2)
  {
    CFNumberRef v3 = v2;
    CFNumberGetValue(v3, kCFNumberIntType, &valuePtr);
  }
  else
  {
    unsigned int v4 = valuePtr;
    if (valuePtr == -1)
    {
      GetStringEncodingSpecialCase(atomic_load_explicit(this + 12, memory_order_acquire), &valuePtr);
      unsigned int v4 = valuePtr;
      if (valuePtr == -1)
      {
        v30[0]  = (id)0xAAAAAAAAAAAAAAAALL;
        TBaseFont::CopyMetadata((TBaseFont *)this, 0, v30);
        CFDictionaryRef v5 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)v30, memory_order_acquire);
        if (v5)
        {
          CFDictionaryRef v6 = v5;
          CFDictionaryRef Value = CFDictionaryGetValue(v5, @"MTD_Typeface_Repertoire_PrimaryScript");

          if (Value)
          {
            CFTypeID v8 = CFGetTypeID(Value);
            if (v8 == CFStringGetTypeID())
            {
              uint64_t v9 = 0;
              while (1)
              {
                int v10 = *(const void **)&dword_1E528FE60[v9 + 2];
                if (v10 == Value || v10 && CFEqual(Value, v10)) {
                  break;
                }
                v9 += 4;
                if (v9 == 124)
                {
                  int v11 = -1;
                  goto LABEL_16;
                }
              }
              int v11 = dword_1E528FE60[v9];
LABEL_16:
              unsigned int valuePtr = v11;
            }
          }
        }
        else
        {
        }
        unsigned int v4 = valuePtr;
        if (valuePtr == -1)
        {
          id v31 = (id)0xAAAAAAAAAAAAAAAALL;
          (*(void (**)(id *__return_ptr, atomic_ullong *, uint64_t))(*this + 480))(&v31, this, 1330851634);
          memset(v30, 170, sizeof(v30));
          OS2::OS2((OS2 *)v30, (id)atomic_load_explicit((atomic_ullong *volatile)&v31, memory_order_acquire));
          if ((uint64_t)v30[2] < 78)
          {
LABEL_28:
            int v17 = 32;
          }
          else
          {
            for (uint64_t i = 0; i != 15; ++i)
            {
              if (v30[2] >= (id)0x56)
              {
                if (*(_WORD *)v30[1])
                {
                  unint64_t v13 = gCodePageOrderList[i];
                  if (((bswap32(*(_DWORD *)((char *)v30[1] + ((v13 >> 3) & 0x1C) + 78)) >> v13) & 1) != 0
                    && ((0xF4000000003F006BLL >> v13) & 1) != 0)
                  {
                    int v17 = gCodePageToScript[v13];
                    goto LABEL_31;
                  }
                }
              }
            }
            v33[0]  = 0xAAAAAAAAAAAAAAAALL;
            v33[1]  = 0xAAAAAAAAAAAAAAAALL;
            TBaseFont::GetOS2UnicodeRanges((TBaseFont *)this, v33, (atomic_ullong *)&v31);
            char v14 = 0;
            uint64_t v15 = 0;
            while (1)
            {
              char v16 = v14;
              if (((*(_DWORD *)((char *)v33
                               + (((unint64_t)dword_184BA8B50[2 * v15] >> 3) & 0x1FFFFFFC)) >> dword_184BA8B50[2 * v15]) & 1) != 0)
                break;
              char v14 = 1;
              uint64_t v15 = 1;
              if (v16) {
                goto LABEL_28;
              }
            }
            int v17 = dword_184BA8B50[2 * v15 + 1];
          }
LABEL_31:

          v30[0]  = (id)0xAAAAAAAAAAAAAAAALL;
          (*(void (**)(id *__return_ptr, atomic_ullong *))(*this + 360))(v30, this);
          if (atomic_load_explicit((atomic_ullong *volatile)v30, memory_order_acquire))
          {
            CFNumberRef v18 = (const __CFNumber *)(id)atomic_load_explicit((atomic_ullong *volatile)v30, memory_order_acquire);
            LODWORD(v33[0])  = -1431655766;
            CFNumberGetValue(v18, kCFNumberIntType, v33);
            int v19 = v33[0];
          }
          else
          {
            int v19 = 0;
          }
          unsigned int v20 = 0;
          int v21 = 0;
          unsigned int v22 = 32;
          do
          {
            if (((1 << v20) & v19) != 0)
            {
              if (v17 == v20)
              {
                unsigned int v22 = v17;
                goto LABEL_62;
              }
              v21 |= 1 << v20;
              if (v22 > v20 || v22 == 32) {
                unsigned int v24 = v20;
              }
              else {
                unsigned int v24 = v22;
              }
              if (v20) {
                unsigned int v22 = v24;
              }
            }
            ++v20;
          }
          while (v20 != 32);
          if (v22 == 32)
          {
            unsigned int v22 = (32 * (v19 & 1)) ^ 0x20;
            if (v19) {
              v21 &= ~1u;
            }
            if (v21)
            {
              unsigned int v25 = 0;
              while (((1 << v25) & v21) == 0)
              {
                if (v25 <= 0x1E)
                {
                  v21 &= ~(1 << v25++);
                  if (v21) {
                    continue;
                  }
                }
                goto LABEL_57;
              }
              unsigned int v22 = v25;
            }
LABEL_57:
            if (v17 != 32 && v22 == 32) {
              unsigned int v22 = v17;
            }
          }
LABEL_62:
          if (v22 <= 0x1F) {
            unsigned int valuePtr = v22;
          }

          unsigned int v4 = valuePtr;
          if (valuePtr == -1)
          {
            unsigned int v4 = 256;
            unsigned int valuePtr = 256;
          }
        }
      }
    }
    TCFNumber::TCFNumber<unsigned int>(&v29, v4);
    TBaseFont::SetAttributeInternal<TCFRef<__CFSet const*>>(this, (atomic_ullong *)&v29, @"NSCTFontStringEncodingAttribute");
    CFNumberRef v3 = v29;
  }

  uint64_t v27 = valuePtr;
  return v27;
}

BOOL TBaseFont::GetOpticalPointSizes(TBaseFont *this, double *a2, double *a3)
{
  int valuePtr = -65536;
  id v9 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr))(*(void *)this + 432))(&v9);
  if (atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire))
  {
    CFNumberRef v5 = (const __CFNumber *)(id)atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire);
    CFNumberGetValue(v5, kCFNumberIntType, &valuePtr);
  }
  unsigned int v6 = valuePtr;
  if (valuePtr != -65536)
  {
    *a2  = (double)(unsigned __int16)valuePtr / 20.0;
    *a3  = (double)HIWORD(v6) / 20.0;
  }
  BOOL v7 = v6 != -65536;

  return v7;
}

void TBaseFont::CopyOpticalPointSizes(atomic_ullong *this@<X0>, atomic_ullong *a2@<X8>)
{
  *a2  = 0xAAAAAAAAAAAAAAAALL;
  TBaseFont::CopyAttributeInternal(this, @"CTFontOpticalPointSizesAttribute", valuePtr);
  *a2  = atomic_exchange((atomic_ullong *volatile)valuePtr, 0);

  if (!atomic_load_explicit(a2, memory_order_acquire))
  {
    memset(valuePtr, 170, sizeof(valuePtr));
    (*(void (**)(id *__return_ptr, atomic_ullong *, uint64_t))(*this + 480))(&v7, this, 1330851634);
    OS2::OS2((atomic_ullong *)valuePtr, (atomic_ullong *)&v7);

    if ((uint64_t)valuePtr[2] >= 100
      && bswap32(*(unsigned __int16 *)valuePtr[1]) >> 16 >= 5
      && ((unsigned int v4 = *((unsigned __int16 *)valuePtr[1] + 49), *((_WORD *)valuePtr[1] + 48)) || v4 != 0xFFFF))
    {
      uint64_t v5 = (__PAIR64__(__rev16(v4), bswap32(*((unsigned __int16 *)valuePtr[1] + 48))) >> 16);
    }
    else
    {
      uint64_t v5 = 4294901760;
    }

    valuePtr[0]  = (id)v5;
    id v7 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberLongType, valuePtr);

    id v6 = (id)atomic_load_explicit(a2, memory_order_acquire);
    TBaseFont::SetAttributeInternal<TCFRef<__CFSet const*>>(this, (atomic_ullong *)&v6, @"CTFontOpticalPointSizesAttribute");
  }
}

void TBaseFont::CopyTraits(TBaseFont *this@<X0>, int a2@<W1>, void *a3@<X8>)
{
  id v8 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr))(*(void *)this + 152))(&v8);
  if (a2)
  {
    CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire);
    if (explicit)
    {
      CFMutableAttributedStringRef MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, explicit);
      SymbolicTraitsFromTraits  = GetSymbolicTraitsFromTraits(explicit);
      TCFNumber::TCFNumber<unsigned int>(&v9, SymbolicTraitsFromTraits | 0x800);
      CFDictionarySetValue(MutableCopy, @"NSCTFontSymbolicTrait", (const void *)atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire));

      id v9 = MutableCopy;
      *a3  = atomic_exchange((atomic_ullong *volatile)&v9, 0);
    }
    else
    {
      *a3  = 0;
    }
  }
  else
  {
    *a3  = atomic_exchange((atomic_ullong *volatile)&v8, 0);
  }
}

uint64_t TBaseFont::GetFormat(atomic_ullong *this)
{
  uint64_t v1 = (atomic_uint *)this;
  if ((this[22] & 0x80000000) == 0)
  {
    FontFormat  = GetFontFormat((const __CFString *)atomic_load_explicit(this + 12, memory_order_acquire));
    if (FontFormat)
    {
      uint64_t v3 = FontFormat;
LABEL_4:
      int v4 = 0;
LABEL_96:
      v1[88]  = v3;
      atomic_fetch_or_explicit(v1 + 44, v4 & 0x7FFFFFEF | 0x80000000, memory_order_relaxed);
      return v3;
    }
    if (TBaseFont::GetInitializedGraphicsFont((TBaseFont *)v1) && CGFontGetParserFont())
    {
      IsSuitcase  = FPFontIsSuitcase();
      int v4 = 0;
      uint64_t v6 = 3;
      uint64_t v3 = 5;
      switch(FPFontGetFormat())
      {
        case 1u:
        case 5u:
        case 0x1Fu:
          goto LABEL_96;
        case 2u:
        case 3u:
        case 4u:
        case 6u:
        case 7u:
        case 9u:
        case 0xBu:
        case 0xCu:
        case 0xDu:
          goto LABEL_20;
        case 8u:
          int v4 = 0;
          uint64_t v3 = 3;
          break;
        case 0xEu:
        case 0xFu:
        case 0x12u:
        case 0x13u:
        case 0x19u:
        case 0x1Au:
        case 0x1Bu:
        case 0x1Cu:
        case 0x21u:
          uint64_t v6 = 1;
          goto LABEL_20;
        case 0x10u:
        case 0x11u:
        case 0x16u:
        case 0x17u:
        case 0x18u:
        case 0x1Du:
          int v4 = 0;
          uint64_t v3 = 4;
          break;
        default:
          goto LABEL_11;
      }
      goto LABEL_96;
    }
    IsSuitcase  = 0;
LABEL_11:
    id v37 = (id)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(id *__return_ptr, atomic_uint *))(*(void *)v1 + 192))(&v37, v1);
    if (atomic_load_explicit((atomic_ullong *volatile)&v37, memory_order_acquire)
      && (id v36 = (id)0xAAAAAAAAAAAAAAAALL,
          CFDictionaryRef explicit = (void *)atomic_load_explicit((atomic_ullong *volatile)&v37, memory_order_acquire),
          [explicit getResourceValue:&v36 forKey:*MEMORY[0x1E4F1C538] error:0]))
    {
      if (qword_1EB2CDAC8 != -1) {
        dispatch_once(&qword_1EB2CDAC8, &__block_literal_global_4);
      }
      if ([v36 conformsToType:qword_1EB2CDAD0])
      {
        uint64_t v3 = 3;
      }
      else if ([v36 conformsToType:qword_1EB2CDAD8])
      {
        uint64_t v3 = 3;
        IsSuitcase  = 1;
      }
      else if ([v36 conformsToType:qword_1EB2CDAE0])
      {
        uint64_t v3 = 1;
      }
      else if ([v36 conformsToType:qword_1EB2CDAE8])
      {
        uint64_t v3 = 4;
      }
      else
      {
        uint64_t v3 = 0;
      }
    }
    else
    {
      uint64_t v3 = 0;
    }

    if ((v3 & 0xFFFFFFFD) != 1) {
      goto LABEL_4;
    }
    uint64_t v6 = v3;
LABEL_20:
    InitializedGraphicsFont  = (CGFont *)TBaseFont::GetInitializedGraphicsFont((TBaseFont *)v1);
    CFArrayRef v9 = CGFontCopyTableTags(InitializedGraphicsFont);
    CFArrayRef v10 = v9;
    if (v9 && (CFIndex Count = CFArrayGetCount(v9)) != 0)
    {
      CFIndex v12 = Count;
      int v32 = IsSuitcase;
      unint64_t v33 = v1;
      char v34 = 0;
      int v13 = 0;
      int v14 = 0;
      int v15 = 0;
      int v16 = 0;
      unint64_t v35 = 0;
      CFIndex v17 = 0;
      int v4 = 0x7FFFFF;
      do
      {
        int ValueAtIndex = CFArrayGetValueAtIndex(v10, v17);
        if (ValueAtIndex <= 1415139376)
        {
          if (ValueAtIndex > 1196445522)
          {
            if (ValueAtIndex == 1196445523 || ValueAtIndex == 1196643650) {
              char v34 = 1;
            }
          }
          else
          {
            unsigned int v25 = v35;
            if (ValueAtIndex == 1146308935) {
              int v26 = 1;
            }
            else {
              int v26 = v35;
            }
            if (ValueAtIndex == 1128678944) {
              uint64_t v6 = 4;
            }
            else {
              uint64_t v6 = v6;
            }
            if (ValueAtIndex != 1128678944) {
              unsigned int v25 = v26;
            }
            int v27 = HIDWORD(v35);
            if (ValueAtIndex == 1128678944) {
              int v27 = 1;
            }
            unint64_t v35 = __PAIR64__(v27, v25);
          }
        }
        else
        {
          if (ValueAtIndex == 1819239265) {
            int v19 = 1;
          }
          else {
            int v19 = v15;
          }
          if (ValueAtIndex == 1735162214) {
            unsigned int v20 = 3;
          }
          else {
            unsigned int v20 = v6;
          }
          if (ValueAtIndex == 1735162214) {
            int v21 = 1;
          }
          else {
            int v21 = v16;
          }
          if (ValueAtIndex == 1735162214) {
            int v19 = v15;
          }
          if (ValueAtIndex == 1651273571)
          {
            unsigned int v20 = v6;
            int v21 = v16;
            int v19 = v15;
            int v22 = 1;
          }
          else
          {
            int v22 = v13;
          }
          if (ValueAtIndex == 1650745716) {
            int v23 = 1;
          }
          else {
            int v23 = v14;
          }
          if (ValueAtIndex == 1415139377) {
            unsigned int v24 = 4;
          }
          else {
            unsigned int v24 = v6;
          }
          if (ValueAtIndex == 1415139377) {
            int v23 = v14;
          }
          if (ValueAtIndex <= 1651273570) {
            uint64_t v6 = v24;
          }
          else {
            uint64_t v6 = v20;
          }
          if (ValueAtIndex <= 1651273570)
          {
            int v14 = v23;
          }
          else
          {
            int v16 = v21;
            int v15 = v19;
            int v13 = v22;
          }
        }
        v4 &= ~TableFlagForIdentifier(ValueAtIndex);
        ++v17;
      }
      while (v12 != v17);
      if ((v35 & 0x100000000) != 0) {
        uint64_t v28 = 1;
      }
      else {
        uint64_t v28 = 2;
      }
      if ((v35 | v34))
      {
        uint64_t v6 = v28;
LABEL_85:
        uint64_t v1 = v33;
        goto LABEL_95;
      }
      if (v6 != 3) {
        goto LABEL_85;
      }
      if (v16)
      {
        if (v14 & v13) {
          unsigned int v30 = 5;
        }
        else {
          unsigned int v30 = 0;
        }
        if (v15) {
          uint64_t v6 = 3;
        }
        else {
          uint64_t v6 = v30;
        }
        goto LABEL_85;
      }
      uint64_t v1 = v33;
      if (!v32) {
        goto LABEL_91;
      }
    }
    else
    {
      int v4 = 0x7FFFFF;
      if (v6 != 3)
      {
LABEL_95:

        uint64_t v3 = v6;
        goto LABEL_96;
      }
      int v14 = 0;
      int v13 = 0;
      if (!IsSuitcase)
      {
LABEL_91:
        BOOL v29 = (v14 & v13 & 1) == 0;
LABEL_92:
        if (v29) {
          uint64_t v6 = 4;
        }
        else {
          uint64_t v6 = 5;
        }
        goto LABEL_95;
      }
    }
    BOOL v29 = CGFontIsBitmapOnly() == 0;
    goto LABEL_92;
  }
  return *((unsigned int *)this + 88);
}

id ___ZNK9TBaseFont9GetFormatEv_block_invoke()
{
  qword_1EB2CDAD0  = (uint64_t)(id)[MEMORY[0x1E4F442D8] typeWithIdentifier:@"public.truetype-font"];
  qword_1EB2CDAD8  = (uint64_t)(id)[MEMORY[0x1E4F442D8] typeWithIdentifier:@"com.apple.font-suitcase"];
  qword_1EB2CDAE0  = (uint64_t)(id)[MEMORY[0x1E4F442D8] typeWithIdentifier:@"public.opentype-font"];
  id result = (id)[MEMORY[0x1E4F442D8] typeWithIdentifier:@"com.adobe.postscript-font"];
  qword_1EB2CDAE8  = (uint64_t)result;
  return result;
}

uint64_t TBaseFont::GetScope(TBaseFont *this)
{
  if ((*((_DWORD *)this + 46) & 0x3FFF) != 0x3FFF) {
    TBaseFont::DetermineFontFlags(this, *((_DWORD *)this + 46) & 0x3FFF ^ 0x3FFF);
  }
  return (*((_DWORD *)this + 45) >> 12) & 3;
}

uint64_t TBaseFont::GetSearchDomain(TBaseFont *this)
{
  return 0;
}

uint64_t TBaseFont::GetPriority(TBaseFont *this)
{
  return 60000;
}

CFIndex TBaseFont::CopyStringForGlyph@<X0>(TBaseFont *this@<X0>, CFIndex *a2@<X8>)
{
  v7[1]  = *MEMORY[0x1E4F143B8];
  TBaseFont::GetInitializedGraphicsFont(this);
  CFIndex result = CGFontGetMaxUnichars();
  if (result
    && (MEMORY[0x1F4188790](result, v4),
        uint64_t v6 = (UniChar *)((char *)v7 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0)),
        memset(v6, 170, v5),
        (CFIndex result = CGFontGetUnicharsForGlyph()) != 0))
  {
    CFIndex result = (CFIndex)CFStringCreateWithCharacters((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v6, result);
    *a2  = result;
  }
  else
  {
    *a2  = 0;
  }
  return result;
}

uint64_t TBaseFont::IsCJK(TBaseFont *this)
{
  unsigned int v1 = (*(uint64_t (**)(TBaseFont *))(*(void *)this + 416))(this);
  return (v1 < 0x1A) & (0x200000Eu >> v1);
}

BOOL TBaseFont::IsEnabled(TBaseFont *this)
{
  if ((*((_DWORD *)this + 46) & 0x3FFF) != 0x3FFF) {
    TBaseFont::DetermineFontFlags(this, *((_DWORD *)this + 46) & 0x3FFF ^ 0x3FFF);
  }
  return (*((_DWORD *)this + 45) & 1) == 0;
}

BOOL TBaseFont::IsValid(TBaseFont *this)
{
  if ((*((_DWORD *)this + 45) & 0x10000000) == 0) {
    return 1;
  }
  if ((*((_DWORD *)this + 46) & 0x80000000) == 0)
  {
    atomic_load_explicit((atomic_ullong *volatile)this + 12, memory_order_acquire);
    atomic_fetch_or_explicit((atomic_uint *volatile)this + 45, 0, memory_order_relaxed);
    atomic_fetch_or_explicit((atomic_uint *volatile)this + 46, 0x80000000, memory_order_relaxed);
  }
  return *((_DWORD *)this + 45) >= 0;
}

BOOL TBaseFont::IsDownloadable(TBaseFont *this)
{
  id v6 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr))(*(void *)this + 200))(&v6);
  CFURLRef explicit = (const __CFURL *)atomic_load_explicit((atomic_ullong *volatile)&v6, memory_order_acquire);
  if (explicit)
  {
    id v7 = 0;
    if (CFURLGetBaseURL(explicit))
    {

      CFURLRef explicit = (const __CFURL *)atomic_load_explicit((atomic_ullong *volatile)&v7, memory_order_acquire);
    }
    CFURLRef explicit = (const __CFURL *)CFURLCopyFileSystemPath(explicit, kCFURLPOSIXPathStyle);
  }
  id v2 = explicit;
  uint64_t v3 = v2;
  if (v2 == @"/private/var/MobileAsset/AssetsV2/com_apple_MobileAsset_Font")
  {
    BOOL v4 = 1;
  }
  else if (v2)
  {
    BOOL v4 = CFStringHasPrefix(v2, @"/private/var/MobileAsset/AssetsV2/com_apple_MobileAsset_Font") != 0;
  }
  else
  {
    BOOL v4 = 0;
  }

  return v4;
}

uint64_t TBaseFont::HasBeenDownloaded(TBaseFont *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 304))();
}

__CFString *TBaseFont::GetCSSFamily(atomic_ullong *this, int a2)
{
  BOOL v4 = @"sans-serif";
  if (a2 == 1)
  {
    size_t v5 = (__CFString *)(*(uint64_t (**)(atomic_ullong *))(*this + 536))(this);
    if (v5)
    {
      id v6 = v5;
      if (v5 == @"NSCTFontUIFontDesignSerif"
        || @"NSCTFontUIFontDesignSerif" && CFEqual(v5, @"NSCTFontUIFontDesignSerif"))
      {
        id v7 = kCTFontCSSFamilySerifUI;
      }
      else if (v6 == @"NSCTFontUIFontDesignMonospaced" {
             || @"NSCTFontUIFontDesignMonospaced" && CFEqual(v6, @"NSCTFontUIFontDesignMonospaced"))
      }
      {
        id v7 = kCTFontCSSFamilyMonospaceUI;
      }
      else if (v6 == @"NSCTFontUIFontDesignRounded" {
             || @"NSCTFontUIFontDesignRounded" && CFEqual(v6, @"NSCTFontUIFontDesignRounded")
      }
             || v6 == @"NSCTFontUIFontDesignCompactRounded"
             || @"NSCTFontUIFontDesignCompactRounded" && CFEqual(v6, @"NSCTFontUIFontDesignCompactRounded"))
      {
        id v7 = kCTFontCSSFamilyRoundedUI;
      }
      else
      {
        id v7 = kCTFontDescriptorDefaultKey;
      }
      return *v7;
    }
    BOOL v4 = @"default";
  }
  CFURLRef explicit = (_DWORD *)atomic_load_explicit(this + 30, memory_order_acquire);
  if (!explicit) {
    CFURLRef explicit = (_DWORD *)TBaseFont::CreateTraitsValues((TBaseFont *)this);
  }
  if (explicit)
  {
    if ((*explicit & 0x400) != 0)
    {
      id v7 = kCTFontCSSFamilyMonospaceUI;
      CFArrayRef v9 = kCTFontCSSFamilyMonospace;
LABEL_15:
      if (a2 != 1) {
        id v7 = v9;
      }
      return *v7;
    }
    switch((*explicit >> 28) ^ 8)
    {
      case 0:
        BOOL v4 = @"sans-serif";
        if (a2 == 1)
        {
          CFStringRef v11 = (const __CFString *)(id)atomic_load_explicit(this + 12, memory_order_acquire);
          CFIndex v12 = (__CFString *)v11;
          if (v11 == @".SFUIRounded"
            || v11
            && (CFStringHasPrefix(v11, @".SFUIRounded")
             || v12 == @".SFCompactRounded"
             || CFStringHasPrefix(v12, @".SFCompactRounded")))
          {
            int v13 = kCTFontCSSFamilyRoundedUI;
          }
          else
          {
            int v13 = kCTFontDescriptorDefaultKey;
          }
          BOOL v4 = *v13;
        }
        break;
      case 1:
        id v7 = &kCTFontCSSFamilyFantasy;
        return *v7;
      case 2:
        id v7 = kCTFontCSSFamilyCursive;
        return *v7;
      case 9:
      case 0xA:
      case 0xB:
      case 0xC:
      case 0xD:
      case 0xF:
        id v7 = kCTFontCSSFamilySerifUI;
        CFArrayRef v9 = kCTFontCSSFamilySerif;
        goto LABEL_15;
      default:
        return v4;
    }
  }
  return v4;
}

void TCFBase_NEW<CTFontDescriptor,TBaseFont const*&>(uint64_t *a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = TCFBase<TDescriptor>::Allocate();
  if (v4)
  {
    uint64_t v5 = *a1;
    *(void *)(v4 + 16)  = 0;
    *(void *)(v4 + 24)  = TDescriptor::Hash;
    *(void *)(v4 + 32)  = 0;
    *(void *)(v4 + 40)  = v4 + 48;
    *(void *)(v4 + 48)  = &unk_1ED05D778;
    *(void *)(v4 + 56)  = 0;
    *(_DWORD *)(v4 + 64)  = 0x80000000;
    *(void *)(v4 + 72)  = 0;
    if (v5) {
      atomic_fetch_add_explicit((atomic_uint *volatile)(v5 + 8), 1u, memory_order_relaxed);
    }
    *(void *)(v4 + 80)  = v5;
    *(void *)(v4 + 88)  = 0;
    id v6 = (id)v4;
    *a2  = atomic_exchange((atomic_ullong *volatile)&v6, 0);
  }
  else
  {
    *a2  = 0;
  }
}

void TBaseFont::CreateSystemDefaultFallbacks(uint64_t a1@<X0>, __CFString *a2@<X1>, const __CFString *a3@<X2>, int a4@<W3>, const __CFArray **a5@<X8>)
{
  v44[16]  = *(id *)MEMORY[0x1E4F143B8];
  CFURLRef explicit = (__CFString *)atomic_load_explicit((atomic_ullong *volatile)(a1 + 96), memory_order_acquire);
  if (explicit == @".TimesFB" || explicit && CFEqual(explicit, @".TimesFB")) {
    a2  = @"serif";
  }
  id v37 = (id)0xAAAAAAAAAAAAAAAALL;
  TDescriptorSource::TDescriptorSource((TDescriptorSource *)v44);
  TDescriptorSource::CopyDefaultSubstitutionListForLanguages(a2, a3, (TFontFallbacks *)&v37);
  CFArrayRef v11 = (const __CFArray *)(id)atomic_load_explicit((atomic_ullong *volatile)&v37, memory_order_acquire);
  CFArrayRef v12 = v11;
  if (v11)
  {
    CFIndex Count = CFArrayGetCount(v11);

    if (Count >= 1
      && (*a5  = (const __CFArray *)0xAAAAAAAAAAAAAAAALL,
          int v14 = [_CTFontFallbacksArray alloc],
          obuint64_t j = (id)atomic_load_explicit((atomic_ullong *volatile)&v37, memory_order_acquire),
          v14)
      && (v43.receiver  = v14,
          v43.super_class  = (Class)_CTFontFallbacksArray,
          (int v15 = objc_msgSendSuper2(&v43, sel_init)) != 0))
    {
      int v16 = v15;
      v15[2]  = a1;
      uint64_t v17 = [obj count];
      v16[5]  = [objc_alloc(MEMORY[0x1E4F1CA48]) initWithCapacity:v17];
      v16[6]  = [objc_alloc(MEMORY[0x1E4F1CA48]) initWithCapacity:v17];
      *((_DWORD *)v16 + 16)  = a4;
      CFNumberRef v18 = (atomic_ullong *)v16[2];
      v44[0]  = (id)0xAAAAAAAAAAAAAAAALL;
      (*(void (**)(id *__return_ptr, atomic_ullong *))(*v18 + 200))(v44, v18);
      CFArrayRef v34 = (const __CFArray *)v16;
      if (atomic_load_explicit((atomic_ullong *volatile)v44, memory_order_acquire))
      {
        CFStringRef v19 = CFURLGetString((CFURLRef)atomic_load_explicit((atomic_ullong *volatile)v44, memory_order_acquire));
        CFHashCode v20 = CFHash(v19);
      }
      else
      {
        id v21 = (id)atomic_load_explicit(v18 + 12, memory_order_acquire);
        CFHashCode v20 = CFHash(v21);
      }
      CFHashCode v22 = v20 + 2654435769u;
      uint64_t v33 = [MEMORY[0x1E4F1CA98] null];
      id v36 = (id)atomic_load_explicit((atomic_ullong *volatile)(a1 + 96), memory_order_acquire);
      long long v39 = 0u;
      long long v40 = 0u;
      long long v41 = 0u;
      long long v42 = 0u;
      uint64_t v23 = [obj countByEnumeratingWithState:&v39 objects:v44 count:16];
      if (v23)
      {
        uint64_t v24 = v23;
        uint64_t v25 = *(void *)v40;
        do
        {
          for (uint64_t i = 0; i != v24; ++i)
          {
            if (*(void *)v40 != v25) {
              objc_enumerationMutation(obj);
            }
            uint64_t v27 = *(void *)(*((void *)&v39 + 1) + 8 * i);
            TDescriptor::CopyAttribute(*(atomic_ullong **)(v27 + 40), @"NSFontNameAttribute", &v38);
            uint64_t v28 = (void *)atomic_exchange((atomic_ullong *volatile)&v38, 0);

            id v29 = v36;
            id v30 = v28;
            if (v29 == v30)
            {
            }
            else
            {
              id v31 = v30;
              if (v29 && v30)
              {
                int v32 = CFEqual(v29, v30);

                if (v32) {
                  goto LABEL_27;
                }
              }
              else
              {
              }
              v22 ^= (v22 << 6) + 2654435769u + (v22 >> 2) + CFHash(v28);
              [*((id *)v34 + 5) addObject:v27];
              [*((id *)v34 + 6) addObject:v33];
              ++*((void *)v34 + 4);
            }
LABEL_27:
          }
          uint64_t v24 = [obj countByEnumeratingWithState:&v39 objects:v44 count:16];
        }
        while (v24);
      }
      CFArrayRef v12 = v34;
      *((void *)v34 + 7)  = v22;
      *((void *)v34 + 3)  = (*(uint64_t (**)(void))(**((void **)v34 + 2) + 800))(*((void *)v34 + 2));
    }
    else
    {
      CFArrayRef v12 = 0;
    }
  }
  else
  {
  }
  *a5  = v12;
}

void TBaseFont::CreateFallbacks(atomic_ullong *a1@<X0>, int a2@<W1>, char a3@<W2>, const __CFCharacterSet **a4@<X3>, const __CFArray *a5@<X4>, atomic_ullong *a6@<X8>)
{
  *a6  = 0;
  if (a3)
  {
    if (a2)
    {
      uint64_t v12 = (*(uint64_t (**)(atomic_ullong *))(*a1 + 560))(a1);
      if (v12)
      {
        CFStringRef v13 = (const __CFString *)v12;
        TDescriptorSource::TDescriptorSource((TDescriptorSource *)&v18);
        TDescriptorSource::CreatePresetFallbacks(v13, a4, a5, a3, &v19);
      }
    }
    CFArrayRef v14 = (const __CFArray *)(id)atomic_load_explicit(a6, memory_order_acquire);
    if (v14)
    {
      CFArrayRef v15 = v14;
      CFIndex Count = CFArrayGetCount(v14);

      if (Count) {
        return;
      }
    }
    else
    {
    }
    CSSFamildouble y = TBaseFont::GetCSSFamily(a1, a2);
    TBaseFont::CreateSystemDefaultFallbacks((uint64_t)a1, CSSFamily, (const __CFString *)a5, a2, (const __CFArray **)&v19);
  }
}

unint64_t TBaseFont::GetDefaultFallbacks(atomic_ullong *a1, int a2, char a3)
{
  if ((a3 & 1) == 0) {
    return 0;
  }
  uint64_t v5 = 1;
  if ((a3 & 4) != 0) {
    uint64_t v5 = 2;
  }
  if (a2 == 1) {
    uint64_t v6 = v5;
  }
  else {
    uint64_t v6 = 0;
  }
  id v7 = &a1[v6 + 16];
  if (atomic_load_explicit(v7, memory_order_acquire)) {
    return atomic_load_explicit(v7, memory_order_acquire);
  }
  id v16 = (id)0xAAAAAAAAAAAAAAAALL;
  id v17 = 0;
  CFCharacterSetRef v15 = 0;
  TBaseFont::CreateFallbacks(a1, a2, a3, &v15, 0, (atomic_ullong *)&v16);

  if (atomic_load_explicit((atomic_ullong *volatile)&v17, memory_order_acquire))
  {
    uint64_t v8 = 0;
    unint64_t v9 = atomic_exchange((atomic_ullong *volatile)&v17, 0);
    atomic_compare_exchange_strong(&a1[v6 + 19], (unint64_t *)&v8, v9);
    if (v8) {
      CFArrayRef v10 = (void *)v9;
    }
    else {
      CFArrayRef v10 = 0;
    }
  }
  uint64_t v11 = 0;
  unint64_t v12 = atomic_exchange((atomic_ullong *volatile)&v16, 0);
  atomic_compare_exchange_strong(v7, (unint64_t *)&v11, v12);
  if (v11) {
    CFStringRef v13 = (void *)v12;
  }
  else {
    CFStringRef v13 = 0;
  }

  unint64_t explicit = atomic_load_explicit(v7, memory_order_acquire);
  return explicit;
}

unint64_t TBaseFont::GetDefaultComposite(atomic_ullong *a1, int a2, char a3)
{
  if ((a3 & 1) == 0) {
    return 0;
  }
  uint64_t v4 = 1;
  if ((a3 & 4) != 0) {
    uint64_t v4 = 2;
  }
  if (a2 != 1) {
    uint64_t v4 = 0;
  }
  uint64_t v5 = &a1[v4 + 19];
  if (atomic_load_explicit(v5, memory_order_acquire)) {
    return atomic_load_explicit(v5, memory_order_acquire);
  }
  DefaultFallbacks  = (const __CFArray *)TBaseFont::GetDefaultFallbacks(a1, a2, a3);
  if (DefaultFallbacks)
  {
    id Mutable = CFCharacterSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
    CFIndex Count = CFArrayGetCount(DefaultFallbacks);
    if (Count)
    {
      CFIndex v7 = Count;
      for (CFIndex i = 0; i != v7; ++i)
      {
        int ValueAtIndex = CFArrayGetValueAtIndex(DefaultFallbacks, i);
        uint64_t v10 = *((void *)ValueAtIndex + 5);
        if ((*(_DWORD *)(v10 + 16) & 0x80000000) == 0) {
          TDescriptor::InitBaseFont(*((TDescriptor **)ValueAtIndex + 5), 0, 0.0);
        }
        unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(v10 + 32), memory_order_acquire);
        if (explicit)
        {
          id v19 = (id)0xAAAAAAAAAAAAAAAALL;
          (*(void (**)(id *__return_ptr, unint64_t))(*(void *)explicit + 176))(&v19, explicit);
          if (!atomic_load_explicit((atomic_ullong *volatile)&v19, memory_order_acquire))
          {
            (*(void (**)(id *__return_ptr, unint64_t))(*(void *)explicit + 768))(&v18, explicit);
          }
          CFCharacterSetRef v12 = (const __CFCharacterSet *)(id)atomic_load_explicit((atomic_ullong *volatile)&v19, memory_order_acquire);
          if (v12) {
            CFCharacterSetUnion((CFMutableCharacterSetRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), v12);
          }
        }
      }
    }
    unint64_t v13 = atomic_exchange((atomic_ullong *volatile)&Mutable, 0);
    _CFCharacterSetCompact();
    uint64_t v14 = 0;
    atomic_compare_exchange_strong(v5, (unint64_t *)&v14, v13);
    if (v14) {
      CFCharacterSetRef v15 = (void *)v13;
    }
    else {
      CFCharacterSetRef v15 = 0;
    }

    DefaultFallbacks  = (const __CFArray *)atomic_load_explicit(v5, memory_order_acquire);
  }
  return (unint64_t)DefaultFallbacks;
}

double TBaseFont::TraitsDistance(atomic_ullong *this, const TTraitsValues *a2)
{
  uint64_t explicit = atomic_load_explicit(this + 30, memory_order_acquire);
  if (!explicit)
  {
    uint64_t explicit = TBaseFont::CreateTraitsValues((TBaseFont *)this);
    if (!explicit) {
      return INFINITY;
    }
  }
  float64x2_t v5 = vsubq_f64(*(float64x2_t *)(explicit + 8), *(float64x2_t *)&a2->var1);
  return vaddvq_f64(vmulq_f64(v5, v5))
       + (*(double *)(explicit + 24) - a2->var3) * (*(double *)(explicit + 24) - a2->var3);
}

void TBaseFont::CreateVariantWithTraitsMatchingDescriptors(const TTraitsValues *this@<X0>, CFArrayRef theArray@<X1>, void *a3@<X8>)
{
  if (!theArray) {
    goto LABEL_20;
  }
  CFIndex Count = CFArrayGetCount(theArray);
  if (Count <= 0) {
    goto LABEL_20;
  }
  CFIndex v8 = Count;
  CFIndex v9 = CFArrayGetCount(theArray);
  if (v8 == 1)
  {
    int ValueAtIndex = (void *)CFArrayGetValueAtIndex(theArray, 0);
    goto LABEL_19;
  }
  CFIndex v11 = v9;
  CFCharacterSetRef v12 = (TDescriptor **)CFArrayGetValueAtIndex(theArray, 0);
  unint64_t v13 = v12;
  uint64_t v14 = v12[5];
  if ((*((_DWORD *)v14 + 4) & 0x80000000) == 0) {
    TDescriptor::InitBaseFont(v12[5], 0, 0.0);
  }
  uint64_t explicit = (atomic_ullong *)atomic_load_explicit((atomic_ullong *volatile)v14 + 4, memory_order_acquire);
  if (!explicit)
  {
LABEL_20:
    *a3  = 0;
    return;
  }
  double v16 = TBaseFont::TraitsDistance(explicit, this);
  if (v11 == 1)
  {
LABEL_18:
    int ValueAtIndex = v13;
    goto LABEL_19;
  }
  double v17 = v16;
  CFIndex v18 = 1;
  while (1)
  {
    id v19 = (TDescriptor **)CFArrayGetValueAtIndex(theArray, v18);
    CFHashCode v20 = v19;
    id v21 = v19[5];
    if ((*((_DWORD *)v21 + 4) & 0x80000000) == 0) {
      TDescriptor::InitBaseFont(v19[5], 0, 0.0);
    }
    CFHashCode v22 = (atomic_ullong *)atomic_load_explicit((atomic_ullong *volatile)v21 + 4, memory_order_acquire);
    if (!v22) {
      goto LABEL_17;
    }
    double v23 = TBaseFont::TraitsDistance(v22, this);
    if (v23 != 0.0)
    {
      if (v17 > v23)
      {
        unint64_t v13 = v20;
        double v17 = v23;
      }
      goto LABEL_17;
    }
    if (v23 < v17) {
      break;
    }
LABEL_17:
    if (v11 == ++v18) {
      goto LABEL_18;
    }
  }
  int ValueAtIndex = v20;
LABEL_19:
  id v24 = ValueAtIndex;
  *a3  = atomic_exchange((atomic_ullong *volatile)&v24, 0);
}

void TBaseFont::CreateVariantMatchingFamily(atomic_ullong *this@<X0>, const __CFString *a2@<X1>, void *a3@<X8>)
{
  if (a2)
  {
    id v8 = (id)0xAAAAAAAAAAAAAAAALL;
    TDescriptorSource::TDescriptorSource((TDescriptorSource *)&v7);
    TDescriptorSource::CopyMatchingDescriptorsForFamily((TDescriptorSource *)&v7, a2, &v8);
    uint64_t explicit = (const TTraitsValues *)atomic_load_explicit(this + 30, memory_order_acquire);
    if (!explicit) {
      uint64_t explicit = (const TTraitsValues *)TBaseFont::CreateTraitsValues((TBaseFont *)this);
    }
    if (explicit) {
      TBaseFont::CreateVariantWithTraitsMatchingDescriptors(explicit, (CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire), a3);
    }
    else {
      *a3  = 0;
    }
  }
  else
  {
    *a3  = 0;
  }
}

void *TCFBase_NEW<CTFontDescriptor,TBaseFont const*,__CFDictionary const*,unsigned int>(void *a1)
{
  CFIndex result = (void *)TCFBase<TDescriptor>::Allocate();
  if (result)
  {
    result[2]  = 0;
    result[3]  = TDescriptor::Hash;
    result[4]  = 0;
    result[5]  = result + 6;
    operator new();
  }
  *a1  = 0;
  return result;
}

void TBaseFont::DefaultFallbackDescriptor(CFArrayRef theArray@<X1>, int a2@<W2>, void *a3@<X8>)
{
  id v13 = (id)CFArrayGetValueAtIndex(theArray, 0);
  float64x2_t v5 = (TDescriptor **)(id)atomic_load_explicit((atomic_ullong *volatile)&v13, memory_order_acquire);
  uint64_t v6 = v5;
  uint64_t v7 = v5[5];
  if ((*((_DWORD *)v7 + 4) & 0x80000000) == 0) {
    TDescriptor::InitBaseFont(v5[5], 0, 0.0);
  }
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)v7 + 4, memory_order_acquire);

  if (explicit
    && (*(unsigned int (**)(unint64_t))(*(void *)explicit + 16))(explicit) == 1414743620)
  {
    id v12 = (id)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(id *__return_ptr, unint64_t))(*(void *)explicit + 504))(&v12, explicit);
    CFArrayRef v9 = (const __CFArray *)(id)atomic_load_explicit((atomic_ullong *volatile)&v12, memory_order_acquire);
    CFArrayRef v10 = v9;
    if (v9) {
      int ValueAtIndex = (void *)CFArrayGetValueAtIndex(v9, 0);
    }
    else {
      int ValueAtIndex = 0;
    }
    TCFRef<__CTFont const*>::Retain((atomic_ullong *)&v13, ValueAtIndex);
  }
  TDescriptorSource::CopyPossibleSystemUIFontDescriptor((atomic_ullong *)&v13, a2, a3);
}

void TBaseFont::FindFallbackDescriptorForCharacters(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned __int16 *a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X4>, int a6@<W5>, unsigned int a7@<W6>, unsigned int a8@<W7>, atomic_ullong *a9@<X8>, char a10)
{
  id v72 = 0;
  CFIndex Count = CFArrayGetCount((CFArrayRef)a2);
  unsigned int v64 = a8;
  if (a8 == 1) {
    CFArrayRef v15 = (const __CFArray *)a2;
  }
  else {
    CFArrayRef v15 = 0;
  }
  CFArrayRef v70 = v15;
  CFArrayRef theArray = (CFArrayRef)a2;
  if ((a6 + 1) <= 1)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB2CDAF8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EB2CDAF8))
    {
      qword_1EB2CDAF0  = objc_opt_class();
      __cxa_guard_release(&qword_1EB2CDAF8);
    }
    if (objc_opt_isKindOfClass())
    {
      if (a2)
      {
        unsigned int v16 = *a3;
        if ((unsigned __int16)(v16 + 24627) >= 0x9033u)
        {
          double v17 = (TDescriptorSource *)os_unfair_lock_lock_with_options();
          unint64_t v18 = *(void *)(a2 + 56);
          TDescriptorSource::EnsureFontFallbacksCache(v17);
          CharRangeMapForKedouble y = (CharRangeToDescriptorMap *)TFontFallbacks::GetCharRangeMapForKey((TFontFallbacks *)TDescriptorSource::sFontFallbacksCache, v18);
          os_unfair_lock_lock_with_options();
          DescriptorIndexForChar  = CharRangeToDescriptorMap::GetDescriptorIndexForChar(CharRangeMapForKey, v16);
          os_unfair_lock_unlock((os_unfair_lock_t)(a2 + 8));
          os_unfair_lock_unlock(&TDescriptorSource::sFontFallbacksLock);
          if (DescriptorIndexForChar != -1)
          {
            unint64_t v21 = *(void *)(a2 + 32);
            if (DescriptorIndexForChar >= v21)
            {
              if (DescriptorIndexForChar / 0x64 < v21)
              {
                uint64_t v26 = [*(id *)(a2 + 48) objectAtIndex:DescriptorIndexForChar / 0x64];
                if (v26 != [MEMORY[0x1E4F1CA98] null])
                {
                  uint64_t v27 = *(void *)(v26 + 40);
                  if ((*(_DWORD *)(v27 + 16) & 0x80000000) == 0) {
                    TDescriptor::InitBaseFont((TDescriptor *)v27, 0, 0.0);
                  }
                  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(v27 + 32), memory_order_acquire);
                  if (explicit
                    && (*(unsigned int (**)(unint64_t))(*(void *)explicit + 16))(explicit) == 1414743620
                    && ((*(uint64_t (**)(unint64_t))(*(void *)explicit + 840))(explicit) & 1) == 0)
                  {
                    unint64_t v29 = DescriptorIndexForChar % 0x64;
                    double v74 = (TDescriptor **)0xAAAAAAAAAAAAAAAALL;
                    (*(void (**)(TDescriptor ***__return_ptr, unint64_t))(*(void *)explicit + 504))(&v74, explicit);
                    id v30 = (void *)atomic_load_explicit((atomic_ullong *volatile)&v74, memory_order_acquire);
                    CFHashCode v22 = v29 >= [v30 count]
                        ? 0
                        : (TDescriptor **)[v30 objectAtIndex:v29];

                    if (v22)
                    {
LABEL_13:
                      double v23 = v22[5];
                      if ((*((_DWORD *)v23 + 4) & 0x80000000) == 0) {
                        TDescriptor::InitBaseFont(v22[5], 0x8000, 0.0);
                      }
                      unint64_t v24 = atomic_load_explicit((atomic_ullong *volatile)v23 + 4, memory_order_acquire);
                      if (v24)
                      {
                        LOBYTE(v73)  = 0;
                        uint64_t v25 = (*(uint64_t (**)(unint64_t, unsigned __int16 *, uint64_t, atomic_ullong **))(*(void *)v24 + 808))(v24, a3, a4, &v73);
                        if (v25 == a4 || a10 != 1 && (_BYTE)v73)
                        {
                          *a5  = v25;
                          double v74 = v22;
                          *a9  = atomic_exchange((atomic_ullong *volatile)&v74, 0);

                          goto LABEL_103;
                        }
                      }
                    }
                  }
                }
              }
            }
            else
            {
              CFHashCode v22 = (TDescriptor **)[*(id *)(a2 + 48) objectAtIndex:DescriptorIndexForChar];
              if (v22 != (TDescriptor **)[MEMORY[0x1E4F1CA98] null] && v22) {
                goto LABEL_13;
              }
            }
          }
        }
      }
    }
  }
  CFIndex v31 = 0;
  CFArrayRef v32 = (const __CFArray *)a2;
  uint64_t v63 = a9;
  while (1)
  {
    if (v31 >= Count)
    {
      int v33 = a7;
      if (a6) {
        goto LABEL_102;
      }
      goto LABEL_50;
    }
    int v33 = a7;
    while (1)
    {
      int ValueAtIndex = (TDescriptor **)CFArrayGetValueAtIndex(v32, v31);
      unint64_t v35 = ValueAtIndex;
      if (a6 == 2 && !v31)
      {
        TDescriptorSource::TDescriptorSource((TDescriptorSource *)&v73);
        TDescriptorSource::CopyEmojiFontDescriptor(v70, &v73, a7, (atomic_ullong *)&v74);

        if (atomic_load_explicit((atomic_ullong *volatile)&v72, memory_order_acquire))
        {
          id v36 = (TDescriptor **)(id)atomic_load_explicit((atomic_ullong *volatile)&v72, memory_order_acquire);
          id v37 = v36;
          id v38 = v36[5];
          if ((*((_DWORD *)v38 + 4) & 0x80000000) == 0) {
            TDescriptor::InitBaseFont(v36[5], 0x8000, 0.0);
          }
          unint64_t v39 = atomic_load_explicit((atomic_ullong *volatile)v38 + 4, memory_order_acquire);

          CFArrayRef v32 = theArray;
          if (v39)
          {
            CFIndex v31 = 1;
LABEL_55:
            unint64_t v35 = (TDescriptor **)atomic_load_explicit((atomic_ullong *volatile)&v72, memory_order_acquire);
            if (v35) {
              goto LABEL_56;
            }
LABEL_102:
            *a9  = 0;
            goto LABEL_103;
          }
        }
        goto LABEL_46;
      }
      long long v40 = ValueAtIndex[5];
      if ((*((_DWORD *)v40 + 4) & 0x80000000) == 0) {
        TDescriptor::InitBaseFont(ValueAtIndex[5], 0x8000, 0.0);
      }
      unint64_t v41 = atomic_load_explicit((atomic_ullong *volatile)v40 + 4, memory_order_acquire);
      CFArrayRef v32 = theArray;
      if (v41)
      {
        if (a6 != 1 || !(*(unsigned int (**)(unint64_t))(*(void *)v41 + 712))(v41)) {
          break;
        }
      }
LABEL_46:
      if (Count == ++v31)
      {
        CFIndex v31 = Count;
        if (a6) {
          goto LABEL_102;
        }
LABEL_50:
        if (atomic_load_explicit((atomic_ullong *volatile)&v72, memory_order_acquire)) {
          goto LABEL_102;
        }
        TDescriptorSource::TDescriptorSource((TDescriptorSource *)&v73);
        TDescriptorSource::CopyEmojiFontDescriptor(v70, &v73, v33, (atomic_ullong *)&v74);

        if (!atomic_load_explicit((atomic_ullong *volatile)&v72, memory_order_acquire)) {
          goto LABEL_102;
        }
        long long v42 = (TDescriptor **)(id)atomic_load_explicit((atomic_ullong *volatile)&v72, memory_order_acquire);
        objc_super v43 = v42;
        int64_t v44 = v42[5];
        if ((*((_DWORD *)v44 + 4) & 0x80000000) == 0) {
          TDescriptor::InitBaseFont(v42[5], 0x8000, 0.0);
        }
        unint64_t v45 = atomic_load_explicit((atomic_ullong *volatile)v44 + 4, memory_order_acquire);

        if (!v45) {
          goto LABEL_102;
        }
        goto LABEL_55;
      }
    }
    ++v31;
LABEL_56:
    uint64_t v46 = v35[5];
    if ((*((_DWORD *)v46 + 4) & 0x80000000) == 0) {
      TDescriptor::InitBaseFont(v35[5], 0x8000, 0.0);
    }
    unint64_t v47 = atomic_load_explicit((atomic_ullong *volatile)v46 + 4, memory_order_acquire);
    if ((*(unsigned int (**)(unint64_t))(*(void *)v47 + 16))(v47) == 1414743620
      && ((*(uint64_t (**)(unint64_t))(*(void *)v47 + 840))(v47) & 1) == 0)
    {
      double v74 = (TDescriptor **)0xAAAAAAAAAAAAAAAALL;
      (*(void (**)(TDescriptor ***__return_ptr, unint64_t))(*(void *)v47 + 504))(&v74, v47);
      CFArrayRef v32 = theArray;
      if (atomic_load_explicit((atomic_ullong *volatile)&v74, memory_order_acquire))
      {
        *a9  = 0xAAAAAAAAAAAAAAAALL;
        LOBYTE(v62)  = a10;
        TBaseFont::FindFallbackDescriptorForCharacters(a1, atomic_load_explicit((atomic_ullong *volatile)&v74, memory_order_acquire), a3, a4, a5, 0xFFFFFFFFLL, a7, v64, v62);
        if (atomic_load_explicit(a9, memory_order_acquire))
        {
          int v52 = 1;
LABEL_98:

          goto LABEL_99;
        }
      }
      int v52 = 2;
      goto LABEL_98;
    }
    char v48 = (*(uint64_t (**)(unint64_t, uint64_t))(*(void *)v47 + 32))(v47, a1);
    CFArrayRef v32 = theArray;
    if (a6 || (v48 & 1) == 0)
    {
      LOBYTE(v73)  = 0;
      uint64_t v49 = (*(uint64_t (**)(unint64_t, unsigned __int16 *, uint64_t, atomic_ullong **))(*(void *)v47 + 808))(v47, a3, a4, &v73);
      uint64_t v50 = a4;
      uint64_t v51 = v49;
      if (v49 != a4)
      {
        int v52 = 0;
        if (a10 == 1 || !(_BYTE)v73) {
          goto LABEL_70;
        }
      }
      if ((v64 & 0xFFFFFFFD) != 0) {
        goto LABEL_66;
      }
      uint64_t v53 = 0;
      CFRange v54 = a3;
      while (2)
      {
        uint64_t v55 = v53 + 1;
        int v56 = v54[v53];
        BOOL v57 = (v56 & 0xFC00) != 0xD800 || v55 == v50;
        if (v57 || (int v58 = v54[v55], (v58 & 0xFC00) != 0xDC00))
        {
          if ((unsigned __int16)((unsigned __int16)(v56 + 0x2000) >> 11) >= 3u) {
            goto LABEL_92;
          }
        }
        else
        {
          uint64_t v55 = v53 + 2;
          int v59 = v58 + (v56 << 10);
          int v56 = v59 - 56613888;
          if ((v59 - 56613888) < 0xF0000 || (v59 - 57727998) > 0xFFFFFC01) {
            goto LABEL_92;
          }
        }
        unsigned int v60 = v56 - 57345;
        if (v56 == 1051575 || v60 <= 0x536)
        {
          if (v60 > 0x536) {
            goto LABEL_92;
          }
          char v61 = (*(uint64_t (**)(unint64_t))(*(void *)v47 + 712))(v47);
          CFRange v54 = a3;
          uint64_t v50 = a4;
          if (v61) {
            goto LABEL_92;
          }
        }
        --v51;
        if (a10 == 1) {
          goto LABEL_66;
        }
        if (v53 || !(_BYTE)v73)
        {
LABEL_92:
          uint64_t v53 = v55;
          if (v55 >= v50 || v51 <= 0) {
            goto LABEL_66;
          }
          continue;
        }
        break;
      }
      LOBYTE(v73)  = 0;
LABEL_66:
      a9  = v63;
      if (v51 == v50 || (int v52 = 0, a10 != 1) && (_BYTE)v73)
      {
        *a5  = v51;
        double v74 = v35;
        *uint64_t v63 = atomic_exchange((atomic_ullong *volatile)&v74, 0);

        int v52 = 1;
      }
LABEL_70:
      CFArrayRef v32 = theArray;
LABEL_99:
      if ((v52 | 2) != 2) {
        break;
      }
    }
  }
LABEL_103:
}

void TBaseFont::FindFallbackDescriptorForCharacterRange(TBaseFont *this@<X0>, const __CFArray *a2@<X1>, const unsigned __int16 *a3@<X2>, CFRange *a4@<X4>, uint64_t a5@<X3>, atomic_ullong *a6@<X8>)
{
  if (!a2 || (CFIndex Count = CFArrayGetCount(a2)) == 0)
  {
LABEL_17:
    *a6  = 0;
    return;
  }
  CFIndex v12 = Count;
  CFIndex v13 = 0;
  while (1)
  {
    int ValueAtIndex = (TDescriptor **)CFArrayGetValueAtIndex(a2, v13);
    CFArrayRef v15 = ValueAtIndex;
    unsigned int v16 = ValueAtIndex[5];
    if ((*((_DWORD *)v16 + 4) & 0x80000000) == 0) {
      TDescriptor::InitBaseFont(ValueAtIndex[5], 0x8000, 0.0);
    }
    unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)v16 + 4, memory_order_acquire);
    if (!explicit) {
      goto LABEL_16;
    }
    if ((*(unsigned int (**)(unint64_t))(*(void *)explicit + 16))(explicit) != 1414743620
      || ((*(uint64_t (**)(unint64_t))(*(void *)explicit + 840))(explicit) & 1) != 0)
    {
      break;
    }
    id v21 = (id)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(id *__return_ptr, unint64_t))(*(void *)explicit + 504))(&v21, explicit);
    if (atomic_load_explicit((atomic_ullong *volatile)&v21, memory_order_acquire))
    {
      *a6  = 0xAAAAAAAAAAAAAAAALL;
      TBaseFont::FindFallbackDescriptorForCharacterRange(this, (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v21, memory_order_acquire), a3, a5, a4);
      if (atomic_load_explicit(a6, memory_order_acquire)) {
        goto LABEL_19;
      }
    }
LABEL_16:
    if (v12 == ++v13) {
      goto LABEL_17;
    }
  }
  if ((*(uint64_t (**)(unint64_t, TBaseFont *))(*(void *)explicit + 32))(explicit, this)) {
    goto LABEL_16;
  }
  CFIndex v18 = (*(uint64_t (**)(unint64_t, const unsigned __int16 *, uint64_t))(*(void *)explicit + 816))(explicit, a3, a5);
  if (v19 < 1) {
    goto LABEL_16;
  }
  a4->CFIndex location = v18;
  a4->CFIndex length = v19;
  id v21 = v15;
  *a6  = atomic_exchange((atomic_ullong *volatile)&v21, 0);
LABEL_19:
}

const __CFArray *TBaseFont::GetCascadeListForFallbackStage(atomic_ullong *a1, int a2, const __CFArray *DefaultFallbacks, int a4, char a5, const unsigned __int16 *a6, uint64_t a7)
{
  if (a2 == 2)
  {
    DefaultFallbacks  = (const __CFArray *)TBaseFont::GetDefaultFallbacks(a1, a4, a5);
  }
  else if (a2 != 1)
  {
    if (a2)
    {
      DefaultFallbacks  = 0;
    }
    else
    {
      (*(void (**)(id *__return_ptr, atomic_ullong *))(*a1 + 504))(&v15, a1);
      DefaultFallbacks  = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v15, memory_order_acquire);
    }
  }
  if (TBaseFont::ShouldSkipCascadeList(a1, a2, DefaultFallbacks, a4, a5, a6, a7)) {
    return 0;
  }
  else {
    return DefaultFallbacks;
  }
}

uint64_t TBaseFont::ShouldSkipCascadeList(atomic_ullong *a1, int a2, CFArrayRef theArray, int a4, char a5, const unsigned __int16 *a6, uint64_t a7)
{
  if (!theArray) {
    return 1;
  }
  if (CFArrayGetCount(theArray))
  {
    if (a2 != 2) {
      return 0;
    }
    DefaultComposite  = (const __CFCharacterSet *)TBaseFont::GetDefaultComposite(a1, a4, a5);
    uint64_t v16 = 0;
    do
      BOOL v14 = IsCharCovered(DefaultComposite, a6, a7, &v16);
    while (!v14 && v16 < a7);
    if (v14) {
      return 0;
    }
  }
  return 1;
}

void TBaseFont::ShapingLanguages(TBaseFont *this@<X0>, char a2@<W1>, void *a3@<X8>)
{
  v10[4]  = *MEMORY[0x1E4F143B8];
  id Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  if ((a2 & 1) == 0)
  {
    v10[0]  = &unk_1ED061F28;
    v10[1]  = &Mutable;
    v10[3]  = v10;
    v9[0]  = &unk_1ED061F70;
    v9[1]  = &Mutable;
    v9[3]  = v9;
    if (TAATMorphTable::AddShapingLanguages(this, (uint64_t)v10)) {
      goto LABEL_4;
    }
  }
  v8[0]  = &unk_1ED061F28;
  v8[1]  = &Mutable;
  v8[3]  = v8;
  v7[0]  = &unk_1ED061F70;
  v7[1]  = &Mutable;
  v7[3]  = v7;
  TOpenTypeMorph::AddShapingLanguages(this, (uint64_t)v8);
  std::__function::__value_func<void ()(void)>::~__value_func[abi:nn180100](v7);
  std::__function::__value_func<void ()(__CFString const*)>::~__value_func[abi:nn180100](v8);
  if ((a2 & 1) == 0)
  {
LABEL_4:
    std::__function::__value_func<void ()(void)>::~__value_func[abi:nn180100](v9);
    std::__function::__value_func<void ()(__CFString const*)>::~__value_func[abi:nn180100](v10);
  }
  *a3  = atomic_exchange((atomic_ullong *volatile)&Mutable, 0);
}

uint64_t TBaseFont::InvalidateTable(atomic_uint *this, int a2)
{
  uint64_t result = TableFlagForIdentifier(a2);
  atomic_fetch_or_explicit(this + 44, result, memory_order_relaxed);
  return result;
}

void TBaseFont::SetConvertedTables(TBaseFont *this, CFTypeRef cf, CFTypeRef a3)
{
  if (cf)
  {
    unsigned int v5 = 100663296;
    if (a3)
    {
      uint64_t v6 = (void *)CFRetain(a3);
      uint64_t v7 = 0;
      atomic_compare_exchange_strong((atomic_ullong *volatile)this + 7, (unint64_t *)&v7, (unint64_t)v6);
      if (v7)
      {
        unsigned int v5 = 100663296;
      }
      else
      {
        uint64_t v6 = 0;
        unsigned int v5 = 369098752;
      }
    }
    id v8 = (void *)CFRetain(cf);
    uint64_t v9 = 0;
    atomic_compare_exchange_strong((atomic_ullong *volatile)this + 8, (unint64_t *)&v9, (unint64_t)v8);
    if (v9)
    {
    }
    else
    {

      v5 |= 0x20000000u;
    }
    atomic_fetch_or_explicit((atomic_uint *volatile)this + 44, v5, memory_order_relaxed);
    atomic_fetch_or_explicit((atomic_uint *volatile)this + 45, 0xF0000u, memory_order_relaxed);
    atomic_fetch_or_explicit((atomic_uint *volatile)this + 46, 0xF0000u, memory_order_relaxed);
    CFArrayRef v10 = (const void **)MEMORY[0x1E4F1CFD0];
  }
  else
  {
    atomic_fetch_or_explicit((atomic_uint *volatile)this + 44, 0x6000000u, memory_order_relaxed);
    CFArrayRef v10 = (const void **)MEMORY[0x1E4F1CFC8];
  }
  CFIndex v11 = *v10;

  TBaseFont::SetAttributeInternal<__CFDictionary const*>((atomic_ullong *)this, v11, @"CTFontMorxConversionResultAttribute");
}

uint64_t TBaseFont::IsStandaloneEmojiModifier(uint64_t a1, uint64_t a2, int a3, int a4)
{
  if (a2 > 0) {
    return (a4 != 2) ^ (*(unsigned int (**)(uint64_t))(*(void *)a1 + 712))(a1);
  }
  if ((a3 - 127995) < 5 || a3 == 8205) {
    return (a4 != 2) ^ (*(unsigned int (**)(uint64_t))(*(void *)a1 + 712))(a1);
  }
  else {
    return 0;
  }
}

uint64_t TBaseFont::CharacterSetCoversCharacters(TBaseFont *this, CFCharacterSetRef theSet, const unsigned __int16 *a3, uint64_t a4)
{
  uint64_t v8 = 0;
  while (1)
  {
    uint64_t v9 = v8 + 1;
    unsigned int v10 = a3[v8];
    if ((v10 & 0xFC00) == 0xD800 && v9 != a4)
    {
      int v12 = a3[v9];
      if ((v12 & 0xFC00) == 0xDC00)
      {
        uint64_t v9 = v8 + 2;
        unsigned int v10 = v12 + (v10 << 10) - 56613888;
LABEL_14:
        BOOL v13 = v10 - 127995 < 5;
        goto LABEL_15;
      }
    }
    if (v10 >= 0xFE0E) {
      break;
    }
    BOOL v13 = 0;
LABEL_15:
    int v14 = 2;
    if (v10 == 8205 || v13) {
      goto LABEL_19;
    }
    if (CFCharacterSetIsLongCharacterMember(theSet, v10)) {
      return 1;
    }
LABEL_20:
    uint64_t v8 = v9;
    if (v9 >= a4) {
      return 0;
    }
  }
  if (v10 >> 4 > 0xFE0) {
    goto LABEL_14;
  }
  if (v10 == 65038) {
    int v14 = 1;
  }
  else {
    int v14 = 2;
  }
LABEL_19:
  if ((TBaseFont::IsStandaloneEmojiModifier((uint64_t)this, 0, v10, v14) & 1) == 0) {
    goto LABEL_20;
  }
  return 1;
}

BOOL IsCharCovered(const __CFCharacterSet *a1, const unsigned __int16 *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v5 = *a4;
  uint64_t v6 = *a4 + 1;
  *a4  = v6;
  UTF32Char v7 = a2[v5];
  if ((v7 & 0xFC00) == 0xD800 && v6 != a3)
  {
    int v9 = a2[v6];
    if ((v9 & 0xFC00) == 0xDC00)
    {
      *a4  = v5 + 2;
      UTF32Char v7 = v9 + (v7 << 10) - 56613888;
    }
  }
  return CFCharacterSetIsLongCharacterMember(a1, v7) != 0;
}

uint64_t TBaseFont::CharactersCovered(atomic_ullong *this, const unsigned __int16 *a2, uint64_t a3, BOOL *a4)
{
  if (a3 >= 1)
  {
    CharacterSetInternal  = TBaseFont::GetCharacterSetInternal(this);
    if (atomic_load_explicit((atomic_ullong *volatile)CharacterSetInternal, memory_order_acquire))
    {
      int v9 = (atomic_ullong *)CharacterSetInternal;
      uint64_t v10 = 0;
      uint64_t v11 = 0;
      while (1)
      {
        uint64_t v12 = v11++;
        unsigned int v13 = a2[v12];
        if ((v13 & 0xFC00) == 0xD800 && v11 != a3)
        {
          int v15 = a2[v11];
          if ((v15 & 0xFC00) == 0xDC00) {
            break;
          }
        }
        if (v13 >= 0xFE0E)
        {
          if (v13 >> 4 <= 0xFE0)
          {
            if (v13 == 65038) {
              int v17 = 1;
            }
            else {
              int v17 = 2;
            }
LABEL_20:
            IsStandaloneEmojiModifier  = TBaseFont::IsStandaloneEmojiModifier((uint64_t)this, v10, v13, v17);
            goto LABEL_21;
          }
          goto LABEL_16;
        }
        BOOL v16 = 0;
LABEL_17:
        int v17 = 2;
        if (v13 == 8205 || v16) {
          goto LABEL_20;
        }
        IsStandaloneEmojiModifier  = CFCharacterSetIsLongCharacterMember((CFCharacterSetRef)atomic_load_explicit(v9, memory_order_acquire), v13);
LABEL_21:
        if (IsStandaloneEmojiModifier) {
          uint64_t v10 = v10 - v12 + v11;
        }
        if (a4 && !v12) {
          *a4  = v10 > 0;
        }
        if (v11 >= a3) {
          return v10;
        }
      }
      uint64_t v11 = v12 + 2;
      unsigned int v13 = v15 + (v13 << 10) - 56613888;
LABEL_16:
      BOOL v16 = v13 - 127995 < 5;
      goto LABEL_17;
    }
  }
  return 0;
}

uint64_t TBaseFont::CharacterRangeCovered(atomic_ullong *this, const unsigned __int16 *a2, uint64_t a3)
{
  if (a3 < 1) {
    return 0;
  }
  CharacterSetInternal  = TBaseFont::GetCharacterSetInternal(this);
  if (!atomic_load_explicit((atomic_ullong *volatile)CharacterSetInternal, memory_order_acquire)) {
    return 0;
  }
  uint64_t v6 = (atomic_ullong *)CharacterSetInternal;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  uint64_t v12 = 0;
  do
  {
    if (IsCharCovered((const __CFCharacterSet *)atomic_load_explicit(v6, memory_order_acquire), a2, a3, &v12))
    {
      if (!v9) {
        uint64_t v8 = v7;
      }
      uint64_t v10 = v9 - v7;
      uint64_t v7 = v12;
      uint64_t v9 = v10 + v12;
    }
    else
    {
      if (v9) {
        return v8;
      }
      uint64_t v7 = v12;
    }
  }
  while (v7 < a3);
  return v8;
}

void TBaseFont::CopyNativeFontForDescriptor(atomic_ullong *this, atomic_uint *a2, uint64_t a3)
{
  if (!a3) {
    goto LABEL_9;
  }
  uint64_t v5 = *(void *)(a3 + 40);
  if ((*(_DWORD *)(v5 + 16) & 0x80000000) == 0) {
    TDescriptor::InitBaseFont(*(TDescriptor **)(a3 + 40), 0, 0.0);
  }
  unint64_t explicit = (atomic_ullong *)atomic_load_explicit((atomic_ullong *volatile)(v5 + 32), memory_order_acquire);
  if (!explicit) {
    goto LABEL_9;
  }
  *this  = 0xAAAAAAAAAAAAAAAALL;
  TCGFontCache::CopyFont((TCGFontCache *)atomic_load_explicit(explicit + 10, memory_order_acquire), 0, 0, this);
  if (!atomic_load_explicit(this, memory_order_acquire))
  {

LABEL_9:
    *this  = 0;
    return;
  }
  if ((*(unsigned int (**)(atomic_ullong *))(*explicit + 688))(explicit))
  {
    atomic_fetch_or_explicit(a2 + 45, 2u, memory_order_relaxed);
    atomic_fetch_or_explicit(a2 + 46, 2u, memory_order_relaxed);
  }
}

void *TBaseFont::CreateStrikeMetricsDictionaryRepresentation(TBaseFont *this)
{
  long long v7 = xmmword_184BA8B08;
  long long v8 = unk_184BA8B18;
  long long v9 = xmmword_184BA8B28;
  long long v10 = unk_184BA8B38;
  long long v5 = __const__ZL17StrikeMetricsFromPK14CGFontHMetricsj6CGRectd_result;
  long long v6 = unk_184BA8AF8;
  if (*((_DWORD *)this + 62)) {
    inited  = (_DWORD *)((char *)this + 248);
  }
  else {
    inited  = TBaseFont::InitFontMetrics(this, 0.0);
  }
  StrikeMetrics::StrikeMetrics((uint64_t)&v5, (uint64_t)inited);
  id v2 = objc_opt_new();
  objc_msgSend(v2, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedInt:", v5), @"unitsPerEm");
  objc_msgSend(v2, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithDouble:", *((double *)&v5 + 1)), @"ascent");
  objc_msgSend(v2, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithDouble:", *(double *)&v6), @"descent");
  objc_msgSend(v2, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithDouble:", *((double *)&v6 + 1)), @"leading");
  objc_msgSend(v2, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithDouble:", *(double *)&v7), @"capHeight");
  v11.origin.CGFloat x = *((CGFloat *)&v8 + 1);
  *(_OWORD *)&v11.origin.double y = v9;
  *(void *)&v11.size.height  = v10;
  DictionaryRepresentation  = CGRectCreateDictionaryRepresentation(v11);
  [v2 setObject:DictionaryRepresentation forKeyedSubscript:@"bbox"];
  CFRelease(DictionaryRepresentation);
  if (BYTE8(v10)) {
    [v2 setObject:MEMORY[0x1E4F1CC38] forKeyedSubscript:@"forceAscenderDelta"];
  }
  return v2;
}

CFStringRef TBaseFont::DebugDescription(TBaseFont *this)
{
  (*(void (**)(id *__return_ptr))(*(void *)this + 200))(&v4);
  unsigned int v1 = (void *)atomic_exchange((atomic_ullong *volatile)&v4, 0);

  CFStringRef v2 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"BaseFont <url: %@>\n", v1);
  return v2;
}

uint64_t TBaseFont::MayHaveOverrides(TBaseFont *this)
{
  return 0;
}

uint64_t TBaseFont::CopyAttribute(TBaseFont *this, const __CFString *key, const __CFString **a3)
{
  FontAttributeID  = GetFontAttributeID(key);
  long long v6 = *(uint64_t (**)(TBaseFont *, const void *, const __CFString **))(*(void *)this + 48);

  return v6(this, FontAttributeID, a3);
}

CFNumberRef TBaseFont::CopyFormat@<X0>(TBaseFont *this@<X0>, CFNumberRef *a2@<X8>)
{
  int valuePtr = (*(uint64_t (**)(TBaseFont *))(*(void *)this + 208))(this);
  CFNumberRef result = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
  *a2  = result;
  return result;
}

CFNumberRef TBaseFont::CopyStringEncoding@<X0>(TBaseFont *this@<X0>, CFNumberRef *a2@<X8>)
{
  uint64_t valuePtr = (*(unsigned int (**)(TBaseFont *))(*(void *)this + 416))(this);
  CFNumberRef result = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberLongType, &valuePtr);
  *a2  = result;
  return result;
}

void TBaseFont::CopyIgnoreScriptAnalysis(TBaseFont *this@<X0>, void *a2@<X8>)
{
  int v3 = (*(uint64_t (**)(TBaseFont *))(*(void *)this + 760))(this);
  if (v3)
  {
    id v4 = (id *)MEMORY[0x1E4F1CFD0];
    if (v3 != 2) {
      id v4 = (id *)MEMORY[0x1E4F1CFC8];
    }
    id v5 = *v4;
    *a2  = atomic_exchange((atomic_ullong *volatile)&v5, 0);
  }
  else
  {
    *a2  = 0;
  }
}

CFNumberRef TBaseFont::CopyScope@<X0>(TBaseFont *this@<X0>, CFNumberRef *a2@<X8>)
{
  int valuePtr = (*(uint64_t (**)(TBaseFont *))(*(void *)this + 240))(this);
  CFNumberRef result = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
  *a2  = result;
  return result;
}

CFNumberRef TBaseFont::CopyPriority@<X0>(TBaseFont *this@<X0>, CFNumberRef *a2@<X8>)
{
  uint64_t valuePtr = (*(unsigned int (**)(TBaseFont *))(*(void *)this + 256))(this);
  CFNumberRef result = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberLongType, &valuePtr);
  *a2  = result;
  return result;
}

CFNumberRef TBaseFont::CopySearchDomain@<X0>(TBaseFont *this@<X0>, CFNumberRef *a2@<X8>)
{
  uint64_t valuePtr = (*(unsigned int (**)(TBaseFont *))(*(void *)this + 272))(this);
  CFNumberRef result = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberLongType, &valuePtr);
  *a2  = result;
  return result;
}

CFNumberRef TBaseFont::CopyIsEnabled@<X0>(TBaseFont *this@<X0>, CFNumberRef *a2@<X8>)
{
  int valuePtr = (*(uint64_t (**)(TBaseFont *))(*(void *)this + 288))(this);
  CFNumberRef result = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
  *a2  = result;
  return result;
}

CFNumberRef TBaseFont::CopyIsDownloadable@<X0>(TBaseFont *this@<X0>, CFNumberRef *a2@<X8>)
{
  int valuePtr = (*(uint64_t (**)(TBaseFont *))(*(void *)this + 304))(this);
  CFNumberRef result = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
  *a2  = result;
  return result;
}

CFNumberRef TBaseFont::CopyHasBeenDownloaded@<X0>(TBaseFont *this@<X0>, CFNumberRef *a2@<X8>)
{
  int valuePtr = (*(uint64_t (**)(TBaseFont *))(*(void *)this + 320))(this);
  CFNumberRef result = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
  *a2  = result;
  return result;
}

uint64_t TBaseFont::HasDerivedOpticalSize(TBaseFont *this)
{
  return 0;
}

void TBaseFont::CopyCascadeList(void *a1@<X8>)
{
  *a1  = 0;
}

void TBaseFont::CopyPhysicalFontDescriptor(void *a1@<X8>)
{
  *a1  = 0;
}

uint64_t TBaseFont::GetPhysicalSymbolicTraits(TBaseFont *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 160))();
}

unint64_t TBaseFont::GetPresetFallbacksKey(atomic_ullong *this)
{
  return atomic_load_explicit(this + 12, memory_order_acquire);
}

CGFloat TBaseFont::GetCapHeight(TBaseFont *this, const CGAffineTransform *a2)
{
  InitializedGraphicsFont  = (CGFont *)TBaseFont::GetInitializedGraphicsFont(this);
  return a2->ty + a2->d * (double)CGFontGetCapHeight(InitializedGraphicsFont) + a2->b * 0.0;
}

CGFloat TBaseFont::GetSlantAngle(TBaseFont *this, const CGAffineTransform *a2)
{
  InitializedGraphicsFont  = (CGFont *)TBaseFont::GetInitializedGraphicsFont(this);

  return CGFontGetItalicAngle(InitializedGraphicsFont);
}

uint64_t TBaseFont::IsInvisible(TBaseFont *this)
{
  if ((*((_DWORD *)this + 46) & 8) == 0) {
    TBaseFont::DetermineFontFlags(this, 8u);
  }
  return (*((_DWORD *)this + 45) >> 3) & 1;
}

uint64_t TBaseFont::CopyLogicalCharacterSet(TBaseFont *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 184))();
}

uint64_t TBaseFont::GetTextStyle(TBaseFont *this)
{
  return 0;
}

uint64_t TBaseFont::HasExuberatedLineHeight(TBaseFont *this)
{
  return 0;
}

unint64_t TBaseFont::GetPhysicalTraitsValues(atomic_ullong *this)
{
  unint64_t explicit = atomic_load_explicit(this + 30, memory_order_acquire);
  if (explicit) {
    return explicit;
  }
  else {
    return TBaseFont::CreateTraitsValues((TBaseFont *)this);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned int,std::unique_ptr<TUnicodeDataCachePage>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::unique_ptr<TUnicodeDataCachePage>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::unique_ptr<TUnicodeDataCachePage>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::unique_ptr<TUnicodeDataCachePage>>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<unsigned int,std::unique_ptr<TUnicodeDataCachePage>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::unique_ptr<TUnicodeDataCachePage>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::unique_ptr<TUnicodeDataCachePage>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::unique_ptr<TUnicodeDataCachePage>>>>::__deallocate_node(a1, *(void **)(a1 + 16));
  CFStringRef v2 = *(void **)a1;
  *(void *)a1  = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<unsigned int,std::unique_ptr<TUnicodeDataCachePage>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::unique_ptr<TUnicodeDataCachePage>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::unique_ptr<TUnicodeDataCachePage>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::unique_ptr<TUnicodeDataCachePage>>>>::__deallocate_node(uint64_t a1, void *a2)
{
  if (a2)
  {
    CFStringRef v2 = a2;
    do
    {
      int v3 = (void *)*v2;
      std::unique_ptr<TUnicodeDataCachePage>::reset[abi:nn180100](v2 + 3, 0);
      operator delete(v2);
      CFStringRef v2 = v3;
    }
    while (v3);
  }
}

void TFallbacksSource::GetCache(void)::{lambda(void *)#1}::__invoke()
{
}

void std::__function::__func<TBaseFont::ShapingLanguages(BOOL)::$_0,std::allocator<TBaseFont::ShapingLanguages(BOOL)::$_0>,void ()(__CFString const*)>::~__func()
{
}

void *std::__function::__func<TBaseFont::ShapingLanguages(BOOL)::$_0,std::allocator<TBaseFont::ShapingLanguages(BOOL)::$_0>,void ()(__CFString const*)>::__clone(uint64_t a1)
{
  CFNumberRef result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *CFNumberRef result = &unk_1ED061F28;
  result[1]  = v3;
  return result;
}

uint64_t std::__function::__func<TBaseFont::ShapingLanguages(BOOL)::$_0,std::allocator<TBaseFont::ShapingLanguages(BOOL)::$_0>,void ()(__CFString const*)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2  = &unk_1ED061F28;
  a2[1]  = v2;
  return result;
}

void std::__function::__func<TBaseFont::ShapingLanguages(BOOL)::$_0,std::allocator<TBaseFont::ShapingLanguages(BOOL)::$_0>,void ()(__CFString const*)>::operator()(uint64_t a1, const void **a2)
{
}

void std::__function::__func<TBaseFont::ShapingLanguages(BOOL)::$_1,std::allocator<TBaseFont::ShapingLanguages(BOOL)::$_1>,void ()(void)>::~__func()
{
}

void *std::__function::__func<TBaseFont::ShapingLanguages(BOOL)::$_1,std::allocator<TBaseFont::ShapingLanguages(BOOL)::$_1>,void ()(void)>::__clone(uint64_t a1)
{
  CFNumberRef result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *CFNumberRef result = &unk_1ED061F70;
  result[1]  = v3;
  return result;
}

uint64_t std::__function::__func<TBaseFont::ShapingLanguages(BOOL)::$_1,std::allocator<TBaseFont::ShapingLanguages(BOOL)::$_1>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2  = &unk_1ED061F70;
  a2[1]  = v2;
  return result;
}

void std::__function::__func<TBaseFont::ShapingLanguages(BOOL)::$_1,std::allocator<TBaseFont::ShapingLanguages(BOOL)::$_1>,void ()(void)>::operator()(uint64_t a1)
{
}

BOOL TSplicedFont::IsInvisible(atomic_ullong *this)
{
  if ((TSplicedFontDict::IsInvisibleSplice(this + 75) & 1) == 0)
  {
    id v11 = (id)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(id *__return_ptr, atomic_ullong *, __CFString *))(*this + 72))(&v11, this, @"CTFontFullName");
    CFStringRef v3 = (const __CFString *)(id)atomic_load_explicit((atomic_ullong *volatile)&v11, memory_order_acquire);
    if (v3)
    {
      id v4 = (__CFString *)v3;
      CFIndex Length = CFStringGetLength(v3);

      if (Length
        && CFStringGetCharacterAtIndex((CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&v11, memory_order_acquire), 0) != 46)
      {
        id v10 = (id)0xAAAAAAAAAAAAAAAALL;
        (*(void (**)(id *__return_ptr, atomic_ullong *, __CFString *))(*this + 72))(&v10, this, @"CTFontFamilyName");
        CFStringRef v6 = (const __CFString *)(id)atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire);
        if (v6)
        {
          long long v7 = (__CFString *)v6;
          CFIndex v8 = CFStringGetLength(v6);

          if (v8)
          {
            BOOL v2 = CFStringGetCharacterAtIndex((CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire), 0) == 46;
LABEL_15:

            goto LABEL_11;
          }
        }
        else
        {
        }
        BOOL v2 = 1;
        goto LABEL_15;
      }
    }
    else
    {
    }
    BOOL v2 = 1;
LABEL_11:

    return v2;
  }
  return 1;
}

void CopyComponentFontDescriptorWithBaseSystemFallback(__CFString *a1, atomic_ullong *a2, atomic_ullong *a3, uint64_t a4)
{
  v10[2]  = *(atomic_ullong **)MEMORY[0x1E4F143B8];
  a1->isa  = (void *)0xAAAAAAAAAAAAAAAALL;
  unint64_t v6 = a4 | 0x12;
  if (a3)
  {
    v9[0]  = @"NSFontNameAttribute";
    v9[1]  = @"NSCTFontFileURLAttribute";
    v10[0]  = a2;
    v10[1]  = a3;
    CFDictionaryRef v7 = (const __CFDictionary *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v10 forKeys:v9 count:2];
    TDescriptorSource::TDescriptorSource((TDescriptorSource *)&v8);
    TDescriptorSource::CopyDescriptorForRequest(&v8, v7, 0, 0, v6, a1);
  }
  else
  {
    TDescriptorSource::TDescriptorSource((TDescriptorSource *)v10);
    TDescriptorSource::CopyFontDescriptorPerPostScriptName(v10, (const __CFString *)a2, v6, 5, 0, a1);
  }
}

void TSplicedFont::CopyLocalizedName(atomic_ullong *this@<X0>, __CFString *a2@<X1>, const __CFArray *a3@<X2>, const __CFString **a4@<X3>, void *a5@<X8>)
{
  TBaseFont::CopyAttributeInternal(this, @"CTFontNames", &v20.info);
  id v10 = (void *)atomic_exchange(&v20.info, 0);

  CFDictionaryRef Value = v10;
  CFDictionaryRef v12 = Value;
  if (Value) {
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(Value, a2);
  }
  v20.info  = (uint64_t)Value;

  int v13 = FontNameCodeForKey(a2);
  int v14 = (*(uint64_t (**)(atomic_ullong *))(*this + 848))(this);
  int v15 = v14;
  if (atomic_load_explicit(&v20.info, memory_order_acquire))
  {
    if (!v14)
    {
LABEL_6:
      *a5  = atomic_exchange(&v20.info, 0);
      goto LABEL_7;
    }
LABEL_5:
    CopyLocalizedFontNameFromResources((__CFString *)atomic_load_explicit(&v20.info, memory_order_acquire), a3, a4, v13, &v20);

    goto LABEL_6;
  }
  v20.isa  = 0;
  if (*((unsigned char *)this + 632)) {
    int v16 = v14;
  }
  else {
    int v16 = 1;
  }
  if (v16 == 1)
  {
    id v19 = TSplicedFontDict::FindLocalizedName(this + 75, v13, (const __CFString **)&v20);
  }
  if (atomic_load_explicit(&v20.info, memory_order_acquire))
  {
    if (a4) {
      *a4  = (const __CFString *)v20.isa;
    }
    NamesWithUpdatedName((const __CFDictionary *)&v19, (CFDictionaryRef)v10, a2, (const void *)atomic_load_explicit(&v20.info, memory_order_acquire));
    TBaseFont::SetAttributeInternal<__CFDictionary const*>(this, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v19, memory_order_acquire), @"CTFontNames");

    if (!v15) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  uint64_t v17 = *(void *)(this[76] + 40);
  if ((*(_DWORD *)(v17 + 16) & 0x80000000) == 0) {
    TDescriptor::InitBaseFont((TDescriptor *)v17, 0, 0.0);
  }
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(v17 + 32), memory_order_acquire);
  (*(void (**)(unint64_t, __CFString *, const __CFArray *, const __CFString **))(*(void *)explicit
                                                                                                 + 88))(explicit, a2, a3, a4);
LABEL_7:
}

uint64_t TSplicedFont::CharactersCovered(TSplicedFont *this, const unsigned __int16 *a2, uint64_t a3, BOOL *a4)
{
  if ((*(unsigned int (**)(TSplicedFont *))(*(void *)this + 840))(this))
  {
    uint64_t v8 = *(void *)(*((void *)this + 76) + 40);
    if ((*(_DWORD *)(v8 + 16) & 0x80000000) == 0) {
      TDescriptor::InitBaseFont((TDescriptor *)v8, 0, 0.0);
    }
    long long v9 = *(uint64_t (**)(void))(*(void *)atomic_load_explicit((atomic_ullong *volatile)(v8 + 32), memory_order_acquire)
                             + 808);
    return v9();
  }
  else
  {
    return TBaseFont::CharactersCovered((atomic_ullong *)this, a2, a3, a4);
  }
}

id TSplicedFont::CopyLogicalCharacterSet@<X0>(atomic_ullong *this@<X0>, void *a2@<X8>)
{
  CFStringRef v3 = this + 24;
  if (!atomic_load_explicit(this + 24, memory_order_acquire))
  {
    id v7 = (id)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(id *__return_ptr))(*this + 176))(&v7);
    if (atomic_load_explicit((atomic_ullong *volatile)&v7, memory_order_acquire))
    {
      uint64_t v5 = 0;
      atomic_compare_exchange_strong(this + 24, (unint64_t *)&v5, atomic_load_explicit((atomic_ullong *volatile)&v7, memory_order_acquire));
      if (!v5) {
        TBaseFont::SetAttributeInternal<__CFDictionary const*>(this, (const void *)atomic_exchange((atomic_ullong *volatile)&v7, 0), @"NSCTFontCharacterSetAttribute");
      }
    }
  }
  id result = (id)atomic_load_explicit(v3, memory_order_acquire);
  *a2  = result;
  return result;
}

void TSplicedFont::CopyRepertoireRange(TSplicedFont *this@<X0>, atomic_ullong *a2@<X8>)
{
  *a2  = 0xAAAAAAAAAAAAAAAALL;
  TBaseFont::CopyAttributeInternal((atomic_ullong *)this, @"UnicodeRange", &v19);
  *a2  = atomic_exchange((atomic_ullong *volatile)&v19, 0);

  if (!atomic_load_explicit(a2, memory_order_acquire))
  {
    CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    id Mutable = CFCharacterSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
    if (Mutable)
    {
      id v19 = (id)0xAAAAAAAAAAAAAAAALL;
      (*(void (**)(id *__return_ptr, TSplicedFont *))(*(void *)this + 504))(&v19, this);
      CFArrayRef v6 = (const __CFArray *)(id)atomic_load_explicit((atomic_ullong *volatile)&v19, memory_order_acquire);
      if (v6)
      {
        CFArrayRef v7 = v6;
        CFIndex Count = CFArrayGetCount(v6);

        if (Count)
        {
          CFIndex v9 = Count - 1;
          do
          {
            int ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v19, memory_order_acquire), v9);
            uint64_t v11 = *((void *)ValueAtIndex + 5);
            if ((*(_DWORD *)(v11 + 16) & 0x80000000) == 0) {
              TDescriptor::InitBaseFont(*((TDescriptor **)ValueAtIndex + 5), 0, 0.0);
            }
            unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(v11 + 32), memory_order_acquire);
            id Copy = (id)0xAAAAAAAAAAAAAAAALL;
            (*(void (**)(id *__return_ptr, unint64_t))(*(void *)explicit + 176))(&Copy, explicit);
            if (!atomic_load_explicit((atomic_ullong *volatile)&Copy, memory_order_acquire))
            {
              (*(void (**)(id *__return_ptr, unint64_t))(*(void *)explicit + 184))(&v17, explicit);
            }
            CFCharacterSetRef v13 = (const __CFCharacterSet *)(id)atomic_load_explicit((atomic_ullong *volatile)&Copy, memory_order_acquire);
            if (v13) {
              CFCharacterSetUnion(Mutable, v13);
            }

            --v9;
          }
          while (v9 != -1);
        }
      }
      else
      {
      }
      id Copy = CFCharacterSetCreateCopy(v4, Mutable);

      id v14 = (id)atomic_load_explicit(a2, memory_order_acquire);
      os_unfair_lock_lock_with_options();
      int v15 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)this + 15, memory_order_acquire);
      if (v14)
      {
        if (!v15) {
          TBaseFont::InitAttributesDict((atomic_ullong *)this);
        }
        int v16 = (__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)this + 15, memory_order_acquire);
        if (v16) {
          CFDictionarySetValue(v16, @"UnicodeRange", v14);
        }
      }
      else if (v15)
      {
        CFDictionaryRemoveValue(v15, @"UnicodeRange");
      }
      os_unfair_lock_unlock((os_unfair_lock_t)this + 28);
    }
  }
}

void TSplicedFont::CopyCharacterSet(TSplicedFont *this@<X0>, void *a2@<X8>)
{
  if (*((void *)this + 77))
  {
    id v7 = (id)0xAAAAAAAAAAAAAAAALL;
    uint64_t v4 = *(void *)(*((void *)this + 76) + 40);
    if ((*(_DWORD *)(v4 + 16) & 0x80000000) == 0) {
      TDescriptor::InitBaseFont(*(TDescriptor **)(*((void *)this + 76) + 40), 0, 0.0);
    }
    (*(void (**)(id *__return_ptr))(*(void *)atomic_load_explicit((atomic_ullong *volatile)(v4 + 32), memory_order_acquire)+ 184))(&v7);
    if (atomic_load_explicit((atomic_ullong *volatile)&v7, memory_order_acquire))
    {
      uint64_t v5 = 0;
      atomic_compare_exchange_strong((atomic_ullong *volatile)this + 24, (unint64_t *)&v5, atomic_load_explicit((atomic_ullong *volatile)&v7, memory_order_acquire));
      if (!v5) {
        TBaseFont::SetAttributeInternal<__CFDictionary const*>((atomic_ullong *)this, (const void *)atomic_exchange((atomic_ullong *volatile)&v7, 0), @"NSCTFontCharacterSetAttribute");
      }
    }
    *a2  = (id)atomic_load_explicit((atomic_ullong *volatile)this + 24, memory_order_acquire);
  }
  else
  {
    CFArrayRef v6 = *(void (**)(void))(*(void *)this + 768);
    v6();
  }
}

CGFloat TSplicedFont::GetUnderlinePosition(TSplicedFont *this, const CGAffineTransform *a2)
{
  CFStringRef v3 = (atomic_ullong *)((char *)this + 600);
  TBaseFont::GetInitializedGraphicsFont(this);
  CGFontGetUnderlinePosition();
  double v5 = a2->ty + v4 * a2->d + a2->b * 0.0;

  return TSplicedFontDict::GetUnderlinePosition(v3, v5, a2);
}

CGFloat TSplicedFont::GetUnderlineThickness(TSplicedFont *this, const CGAffineTransform *a2)
{
  CFStringRef v3 = (atomic_ullong *)((char *)this + 600);
  TBaseFont::GetInitializedGraphicsFont(this);
  CGFontGetUnderlineThickness();
  double v5 = a2->ty + v4 * a2->d + a2->b * 0.0;

  return TSplicedFontDict::GetUnderlineThickness(v3, v5, a2);
}

double TSplicedFont::GetSlantAngle(TSplicedFont *this, const CGAffineTransform *a2)
{
  CFStringRef v3 = (atomic_ullong *)((char *)this + 600);
  InitializedGraphicsFont  = (CGFont *)TBaseFont::GetInitializedGraphicsFont(this);
  ItalicAngle  = CGFontGetItalicAngle(InitializedGraphicsFont);

  return TSplicedFontDict::GetSlantAngle(v3, ItalicAngle, a2);
}

CGFloat TSplicedFont::GetMaxAdvance(TSplicedFont *this, const CGAffineTransform *a2, int a3)
{
  double v4 = (atomic_ullong *)((char *)this + 600);
  MaxAdvance  = TBaseFont::GetMaxAdvance(this, a2, a3);

  return TSplicedFontDict::GetMaxAdvance(v4, MaxAdvance, a2);
}

CFStringRef TSplicedFont::DebugDescription(atomic_ullong *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"SplicedFont <name: %@, cascade list: %@>\n", atomic_load_explicit(this + 12, memory_order_acquire), atomic_load_explicit(this + 78, memory_order_acquire));
}

uint64_t TSplicedFont::CopyPhysicalFontDescriptor(TSplicedFont *this, double a2)
{
  if ((*(unsigned int (**)(TSplicedFont *))(*(void *)this + 16))(this) == 1414743620
    && (*(unsigned int (**)(TSplicedFont *))(*(void *)this + 840))(this))
  {
    double v5 = 12.0;
    if (a2 != 0.0) {
      double v5 = a2;
    }
    OpticalSizeComponent  = TSplicedFont::GetOpticalSizeComponent(this, v5);
  }
  else
  {
    uint64_t v7 = *(void *)(*((void *)this + 76) + 40);
    if ((*(_DWORD *)(v7 + 16) & 0x80000000) == 0) {
      TDescriptor::InitBaseFont((TDescriptor *)v7, 0, 0.0);
    }
    OpticalSizeComponent  = atomic_load_explicit((atomic_ullong *volatile)(v7 + 32), memory_order_acquire);
  }
  uint64_t v8 = *(uint64_t (**)(__n128))(*(void *)OpticalSizeComponent + 520);
  v4.n128_f64[0]  = a2;

  return v8(v4);
}

uint64_t TSplicedFont::GetLanguageAwareOutsets(TSplicedFont *this, __n128 a2, double *a3, double *a4, double *a5, double *a6, const __CFString *a7)
{
  unint64_t v7 = a2.n128_u64[0];
  uint64_t v8 = *(void *)(*((void *)this + 76) + 40);
  if ((*(_DWORD *)(v8 + 16) & 0x80000000) == 0) {
    TDescriptor::InitBaseFont(*(TDescriptor **)(*((void *)this + 76) + 40), 0, 0.0);
  }
  CFIndex v9 = *(uint64_t (**)(__n128))(*(void *)atomic_load_explicit((atomic_ullong *volatile)(v8 + 32), memory_order_acquire)+ 888);
  a2.n128_u64[0]  = v7;

  return v9(a2);
}

BOOL TSplicedFont::GetOpticalPointSizes(TSplicedFont *this, double *a2, double *a3)
{
  CFStringRef v3 = (double *)*((void *)this + 77);
  if (v3)
  {
    *a2  = 0.0;
    *a3  = *v3;
  }
  return v3 != 0;
}

void TComponentFont::TComponentFont(TComponentFont *this, atomic_ullong *a2, const __CFDictionary *a3, atomic_ullong *a4)
{
  TBaseFont::TBaseFont(this, a2);
  *(void *)uint64_t v8 = &unk_1ED05DFF8;
  *(_DWORD *)(v8 + 712)  = 0;
  if (a4) {
    unint64_t explicit = (void *)atomic_load_explicit(a4, memory_order_acquire);
  }
  else {
    unint64_t explicit = (void *)(*(uint64_t (**)(atomic_ullong *))(*a2 + 880))(a2);
  }
  *((void *)this + 90)  = explicit;
  *(_OWORD *)((char *)this + 728)  = 0u;
  *((void *)this + 93)  = a3;
  *((void *)this + 94)  = 0;
  if (!atomic_load_explicit((atomic_ullong *volatile)this + 12, memory_order_acquire))
  {
    ComponentAttribute  = (void *)TComponentFont::GetComponentAttribute((atomic_ullong *)this, @"name");
    TCFRef<__CTFont const*>::Retain((atomic_ullong *)this + 12, ComponentAttribute);
  }
  if (!atomic_load_explicit((atomic_ullong *volatile)this + 15, memory_order_acquire)) {
    TBaseFont::InitAttributesDict((atomic_ullong *)this);
  }
  SetValuesToDictionaryFromDictionary((__CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)this + 15, memory_order_acquire), a3);
  if (CFDictionaryGetValue(a3, @"hmtxOverride")) {
    *((_DWORD *)this + 178) |= 0x20u;
  }
  if (CFDictionaryGetValue(a3, @"Matrix")) {
    *((_DWORD *)this + 178) |= 0x40u;
  }
  if (CFDictionaryGetValue(a3, @"cmapOverride")) {
    *((_DWORD *)this + 178) |= 0x100u;
  }
  if (CFDictionaryGetValue(a3, @"UnicodeCharSet")
    || CFDictionaryGetValue(a3, @"NSCTFontCharacterSetAttribute"))
  {
    *((_DWORD *)this + 178) |= 0x200u;
  }
  if (CFDictionaryGetValue(a3, @"UnicodeCharSetTrim")) {
    *((_DWORD *)this + 178) |= 0x400u;
  }
}

unsigned int *TComponentFont::GetPhysicalSymbolicTraits(TComponentFont *this)
{
  id result = (unsigned int *)(*(uint64_t (**)(TComponentFont *))(*(void *)this + 800))(this);
  if (result) {
    return (unsigned int *)*result;
  }
  return result;
}

unint64_t TComponentFont::GetPhysicalTraitsValues(atomic_ullong *this)
{
  unint64_t explicit = atomic_load_explicit(this + 92, memory_order_acquire);
  if (!explicit)
  {
    int v9 = 0;
    id v8 = (id)0xAAAAAAAAAAAAAAAALL;
    TBaseFont::CreateTraitsValuesPerFontInfo(this, &v9, (atomic_ullong *)&v8);
    if (!v9 && (this[89] & 4) != 0)
    {
      id v7 = (id)0xAAAAAAAAAAAAAAAALL;
      (*(void (**)(id *__return_ptr, atomic_ullong *))(*this + 112))(&v7, this);
      id v6 = (id)0xAAAAAAAAAAAAAAAALL;
      (*(void (**)(id *__return_ptr, atomic_ullong *))(*this + 120))(&v6, this);
      CreateTraitsWithVariation((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire), (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v7, memory_order_acquire), (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v6, memory_order_acquire), 0, 0, 0, &v5);
    }
    if (atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire)) {
      TBaseFont::CreateTraitsValuesFromTraitsDictionary((TBaseFont *)atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire), v3);
    }
    unint64_t explicit = 0;
  }
  return explicit;
}

double TComponentFont::GetSlantAngle(TComponentFont *this, const CGAffineTransform *a2)
{
  CFDictionaryRef v3 = (atomic_ullong *)((char *)this + 720);
  InitializedGraphicsFont  = (CGFont *)TBaseFont::GetInitializedGraphicsFont(this);
  ItalicAngle  = CGFontGetItalicAngle(InitializedGraphicsFont);

  return TSplicedFontDict::GetSlantAngle(v3, ItalicAngle, a2);
}

double TComponentFont::ModifyRawBoundingBox(atomic_ullong *this, CGRect a2)
{
  return TSplicedFontDict::ModifyRawBoundingBox(this + 90, a2);
}

void TComponentFont::CalculateFontMetrics(TComponentFont *this@<X0>, double a2@<D0>, int a3@<W1>, StrikeMetrics *a4@<X8>)
{
  *((_OWORD *)a4 + 2)  = xmmword_184BA8B90;
  *((_OWORD *)a4 + 3)  = unk_184BA8BA0;
  *((_OWORD *)a4 + 4)  = xmmword_184BA8BB0;
  *((_OWORD *)a4 + 5)  = unk_184BA8BC0;
  *(_OWORD *)a4  = xmmword_184BA8B70;
  *((_OWORD *)a4 + 1)  = unk_184BA8B80;
  TBaseFont::CalculateFontMetrics(this, a3, (uint64_t)a4);
  v8.n128_f64[0]  = a2;

  TComponentFont::AdjustLineMetrics((atomic_ullong *)this, a3, a4, v8);
}

__CFString *TComponentFont::GetSyntheticName(TComponentFont *this)
{
  BOOL v2 = (double *)(*(uint64_t (**)(TComponentFont *))(*(void *)this + 800))(this);
  CFDictionaryRef v3 = v2;
  if (v2) {
    int v4 = *(unsigned char *)v2 & 1;
  }
  else {
    int v4 = 0;
  }
  id v5 = (__CFString *)(*(uint64_t (**)(TComponentFont *))(*(void *)this + 536))(this);
  if (v3) {
    double v7 = v3[1];
  }
  else {
    double v7 = 0.0;
  }

  return TDescriptorSource::GetNameForSystemFontOfWeight(v5, 0, v7, v4, 0, v6);
}

void TComponentFont::CopyLocalizedName(atomic_ullong *this@<X0>, const __CFString *a2@<X1>, const __CFArray *a3@<X2>, const __CFString **a4@<X3>, __CFString *a5@<X8>)
{
  if ((*(unsigned int (**)(atomic_ullong *))(*this + 848))(this))
  {
    int v10 = FontNameCodeForKey(a2);
    if ((*(unsigned int (**)(atomic_ullong *))(*this + 856))(this)) {
      BOOL v11 = v10 == 4;
    }
    else {
      BOOL v11 = 0;
    }
    if (v11)
    {
      SyntheticName  = TComponentFont::GetSyntheticName((TComponentFont *)this);
      CFDictionaryRef FontName = FullNameForSynthetic(SyntheticName);
    }
    else
    {
      CFDictionaryRef FontName = (__CFString *)TSplicedFontDict::FindFontName(this + 90, v10, 0);
    }
    CopyLocalizedFontNameFromResources(FontName, a3, a4, v10, a5);
  }
  else
  {
    TBaseFont::CopyLocalizedName(this, a2, a3, a4, (atomic_ullong *)a5);
  }
}

BOOL TComponentFont::SupportsLanguages(TComponentFont *this, const __CFArray *a2)
{
  if ((*((unsigned char *)this + 713) & 7) != 0)
  {
    id v13 = (id)0xAAAAAAAAAAAAAAAALL;
    (*(void (**)(id *__return_ptr))(*(void *)this + 336))(&v13);
    if (a2 && (CFIndex Count = CFArrayGetCount(a2)) != 0)
    {
      CFIndex v4 = 0;
      CFIndex v5 = Count - 1;
      while (1)
      {
        int ValueAtIndex = CFArrayGetValueAtIndex(a2, v4);
        CFArrayRef v7 = (const __CFArray *)(id)atomic_load_explicit((atomic_ullong *volatile)&v13, memory_order_acquire);
        if (!v7) {
          break;
        }
        CFArrayRef v8 = v7;
        v15.CFIndex length = CFArrayGetCount(v7);
        v15.CFIndex location = 0;
        int v9 = CFArrayContainsValue(v8, v15, ValueAtIndex);
        BOOL v10 = v9 != 0;

        if (v9) {
          BOOL v11 = v5 == v4;
        }
        else {
          BOOL v11 = 1;
        }
        ++v4;
        if (v11) {
          goto LABEL_17;
        }
      }

      BOOL v10 = 0;
    }
    else
    {
      BOOL v10 = 1;
    }
LABEL_17:

    return v10;
  }
  else
  {
    return TBaseFont::SupportsLanguages(this, a2);
  }
}

uint64_t anonymous namespace'::TcmapOverrideContext::GetMappedGlyph(_anonymous_namespace_::TcmapOverrideContext *this, unsigned int a2)
{
  if (!this) {
    goto LABEL_9;
  }
  unint64_t v2 = *(void *)this;
  if (!*(void *)this) {
    goto LABEL_9;
  }
  CFDictionaryRef v3 = (char *)this + 8;
  CFIndex v4 = (char *)this + 8 * v2 + 8;
  while (1)
  {
    unint64_t v5 = v2 >> 1;
    id v6 = &v3[8 * (v2 >> 1)];
    if (*(_DWORD *)v6 >= a2) {
      break;
    }
    CFDictionaryRef v3 = v6 + 8;
    unint64_t v5 = v2 + ~v5;
LABEL_8:
    unint64_t v2 = v5;
    if (!v5) {
      goto LABEL_9;
    }
  }
  if (*(_DWORD *)v6 > a2)
  {
    CFIndex v4 = &v3[8 * (v2 >> 1)];
    goto LABEL_8;
  }
  int v9 = &v3[8 * (v2 >> 1)];
  if (v2 >= 2)
  {
    int v9 = v3;
    do
    {
      unint64_t v10 = v5 >> 1;
      BOOL v11 = &v9[8 * (v5 >> 1)];
      unsigned int v13 = *(_DWORD *)v11;
      CFDictionaryRef v12 = v11 + 8;
      v5 += ~(v5 >> 1);
      if (v13 >= a2) {
        unint64_t v5 = v10;
      }
      else {
        int v9 = v12;
      }
    }
    while (v5);
  }
  id v14 = v6 + 8;
  if (v4 != v14)
  {
    unint64_t v15 = (v4 - v14) >> 3;
    CFIndex v4 = v14;
    do
    {
      unint64_t v16 = v15 >> 1;
      id v17 = &v4[8 * (v15 >> 1)];
      unsigned int v19 = *(_DWORD *)v17;
      CFIndex v18 = v17 + 8;
      v15 += ~(v15 >> 1);
      if (v19 > a2) {
        unint64_t v15 = v16;
      }
      else {
        CFIndex v4 = v18;
      }
    }
    while (v15);
  }
  if (v9 != v4) {
    return (unsigned __int16)*((_DWORD *)v9 + 1);
  }
LABEL_9:
  LOWORD(v7)  = 0;
  return (unsigned __int16)v7;
}

uint64_t TComponentFont::CharactersCovered(atomic_ullong *this, const unsigned __int16 *a2, uint64_t a3, BOOL *a4)
{
  if (*((unsigned char *)this + 713))
  {
    ComponentAttribute  = (void *)TComponentFont::GetComponentAttribute(this, @"cmapOverride");
    id v19 = ComponentAttribute;
    if (ComponentAttribute) {
      ComponentAttribute  = (void *)CFDataGetBytePtr((CFDataRef)ComponentAttribute);
    }
    if (a3 < 1)
    {
      uint64_t v10 = 0;
    }
    else
    {
      uint64_t v9 = 0;
      uint64_t v10 = 0;
      do
      {
        uint64_t v11 = v9++;
        unsigned int v12 = a2[v11];
        if ((v12 & 0xFC00) == 0xD800 && v9 != a3)
        {
          int v14 = a2[v9];
          BOOL v15 = (v14 & 0xFC00) == 56320;
          int v16 = v14 + (v12 << 10) - 56613888;
          uint64_t v9 = v15 ? v11 + 2 : v11 + 1;
          if (v15) {
            unsigned int v12 = v16;
          }
        }
        uint64_t v18 = v9 - v11;
        if (!MappedGlyph) {
          uint64_t v18 = 0;
        }
        v10 += v18;
        if (a4 && !v11) {
          *a4  = v10 > 0;
        }
      }
      while (v9 < a3);
    }

    return v10;
  }
  else
  {
    return TBaseFont::CharactersCovered(this, a2, a3, a4);
  }
}

uint64_t TComponentFont::CharacterRangeCovered(atomic_ullong *this, const unsigned __int16 *a2, uint64_t a3)
{
  if ((*((unsigned char *)this + 713) & 1) == 0) {
    return TBaseFont::CharacterRangeCovered(this, a2, a3);
  }
  ComponentAttribute  = (void *)TComponentFont::GetComponentAttribute(this, @"cmapOverride");
  id v17 = ComponentAttribute;
  if (ComponentAttribute) {
    BytePtr  = (_anonymous_namespace_::TcmapOverrideContext *)CFDataGetBytePtr((CFDataRef)ComponentAttribute);
  }
  else {
    BytePtr  = 0;
  }
  if (a3 < 1)
  {
    uint64_t v5 = 0;
  }
  else
  {
    uint64_t v8 = 0;
    uint64_t v5 = 0;
    uint64_t v9 = 0;
    do
    {
      uint64_t v10 = v8 + 1;
      unsigned int v11 = a2[v8];
      if ((v11 & 0xFC00) == 0xD800 && v10 != a3)
      {
        int v13 = a2[v10];
        BOOL v14 = (v13 & 0xFC00) == 56320;
        int v15 = v13 + (v11 << 10) - 56613888;
        uint64_t v10 = v14 ? v8 + 2 : v8 + 1;
        if (v14) {
          unsigned int v11 = v15;
        }
      }
      {
        if (!v9) {
          uint64_t v5 = v10;
        }
        uint64_t v9 = v9 - v8 + v10;
      }
      else if (v9)
      {
        break;
      }
      uint64_t v8 = v10;
    }
    while (v10 < a3);
  }

  return v5;
}

uint64_t TComponentFont::GetUnscaledAdvances(TComponentFont *this, unsigned __int16 *a2, void *a3, int a4, int64_t a5)
{
  if ((*((unsigned char *)this + 712) & 0x20) != 0
    && (ComponentAttribute  = (const __CFDictionary *)TComponentFont::GetComponentAttribute((atomic_ullong *)this, @"hmtxOverride")) != 0)
  {
    if (a5 >= 1)
    {
      CFDictionaryRef v11 = ComponentAttribute;
      unsigned int v12 = (double *)(a3 + 1);
      do
      {
        unsigned int v13 = *a2++;
        *(v12 - 1)  = (double)(uint64_t)CFDictionaryGetValue(v11, (const void *)v13);
        if (a4 >= 2) {
          bzero(v12, 8 * (a4 - (unint64_t)(((a4 - 1) & 0x1FFFFFFFFFFFFFFFLL) != 0)));
        }
        v12 += a4;
        --a5;
      }
      while (a5);
    }
    return 1;
  }
  else
  {
    return TBaseFont::GetUnscaledAdvances(this, (uint64_t)a2, a3, a4, a5);
  }
}

CFStringRef TComponentFont::DebugDescription(atomic_ullong *this)
{
  (*(void (**)(id *__return_ptr))(*this + 200))(&v6);
  unint64_t v2 = (void *)atomic_exchange((atomic_ullong *volatile)&v6, 0);

  TBaseFont::CreateDescriptorAttributes(this, (CFDictionaryRef *)&v6);
  CFDictionaryRef v3 = (void *)atomic_exchange((atomic_ullong *volatile)&v6, 0);

  CFStringRef v4 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"ComponentFont <url: %@, attributes: %@>\n", v2, v3);
  return v4;
}

void TTenuousComponentFont::TTenuousComponentFont(TTenuousComponentFont *this, atomic_ullong *a2, const __CFDictionary *a3)
{
  TComponentFont::TComponentFont(this, (const TComponentFont *)a2);
  *id v6 = &unk_1ED05EC18;
  *((void *)this + 95)  = (id)atomic_load_explicit(a2 + 95, memory_order_acquire);
  *((void *)this + 96)  = 0;
  *((void *)this + 98)  = 0;
  *((void *)this + 97)  = 0;
  *((_WORD *)this + 396)  = 256;
  *((_DWORD *)this + 199)  = 0;
  *((unsigned char *)this + 800)  = 0;
  TCFRef<__CTFont const*>::Retain((atomic_ullong *)this + 96, a3);
}

CGFloat TTenuousComponentFont::GetCapHeight(TTenuousComponentFont *this, const CGAffineTransform *a2)
{
  if ((*((unsigned char *)this + 713) & 0x20) != 0)
  {
    CapHeight  = *((_DWORD *)this + 162);
  }
  else
  {
    InitializedGraphicsFont  = (CGFont *)TBaseFont::GetInitializedGraphicsFont(this);
    CapHeight  = CGFontGetCapHeight(InitializedGraphicsFont);
  }
  return a2->ty + a2->d * (double)CapHeight + a2->b * 0.0;
}

id TTenuousComponentFont::CopyRepertoireRange@<X0>(atomic_ullong *this@<X0>, void *a2@<X8>)
{
  id result = (id)atomic_load_explicit(this + 95, memory_order_acquire);
  *a2  = result;
  return result;
}

uint64_t TTenuousComponentFont::CharactersCovered(atomic_ullong *this, const unsigned __int16 *a2, uint64_t a3, BOOL *a4)
{
  CFCharacterSetRef explicit = (const __CFCharacterSet *)atomic_load_explicit(this + 95, memory_order_acquire);
  if (explicit && !TBaseFont::CharacterSetCoversCharacters((TBaseFont *)this, explicit, a2, a3)) {
    return 0;
  }

  return TComponentFont::CharactersCovered(this, a2, a3, a4);
}

uint64_t TTenuousComponentFont::CharacterRangeCovered(atomic_ullong *this, const unsigned __int16 *a2, uint64_t a3)
{
  CFCharacterSetRef explicit = (const __CFCharacterSet *)atomic_load_explicit(this + 95, memory_order_acquire);
  if (explicit)
  {
    uint64_t v9 = 0;
    do
      BOOL v7 = IsCharCovered(explicit, a2, a3, &v9);
    while (!v7 && v9 < a3);
    if (!v7) {
      return 0;
    }
  }

  return TComponentFont::CharacterRangeCovered(this, a2, a3);
}

uint64_t TTenuousComponentFont::GetUnicodeEncoding(TTenuousComponentFont *this)
{
  uint64_t result = (*(uint64_t (**)(TTenuousComponentFont *))(*(void *)this + 896))(this);
  if (result)
  {
    return TBaseFont::GetUnicodeEncoding(this);
  }
  return result;
}

BOOL TTenuousComponentFont::GetOpticalPointSizes(TTenuousComponentFont *this, double *a2, double *a3)
{
  if ((*(unsigned int (**)(TTenuousComponentFont *))(*(void *)this + 840))(this))
  {
    *a2  = *((double *)this + 75);
    *a3  = *((double *)this + 82);
    return 1;
  }
  else if ((*((unsigned char *)this + 712) & 0x80) != 0)
  {
    return 0;
  }
  else
  {
    return TBaseFont::GetOpticalPointSizes(this, a2, a3);
  }
}

uint64_t TSplicedFont::GetSymbolicTraitsInternal(TSplicedFont *this)
{
  uint64_t v1 = *(void *)(*((void *)this + 76) + 40);
  if ((*(_DWORD *)(v1 + 16) & 0x80000000) == 0) {
    TDescriptor::InitBaseFont(*(TDescriptor **)(*((void *)this + 76) + 40), 0, 0.0);
  }
  unint64_t v2 = *(uint64_t (**)(void))(*(void *)atomic_load_explicit((atomic_ullong *volatile)(v1 + 32), memory_order_acquire)
                           + 160);

  return v2();
}

uint64_t TSplicedFont::CopyDesignLanguages(TSplicedFont *this)
{
  uint64_t v1 = *(void *)(*((void *)this + 76) + 40);
  if ((*(_DWORD *)(v1 + 16) & 0x80000000) == 0) {
    TDescriptor::InitBaseFont(*(TDescriptor **)(*((void *)this + 76) + 40), 0, 0.0);
  }
  unint64_t v2 = *(uint64_t (**)(void))(*(void *)atomic_load_explicit((atomic_ullong *volatile)(v1 + 32), memory_order_acquire)
                           + 368);

  return v2();
}

uint64_t TSplicedFont::GetUnicodeEncoding(TSplicedFont *this)
{
  return 0;
}

uint64_t TSplicedFont::InvalidateTable(TSplicedFont *this)
{
  uint64_t v1 = *(void *)(*((void *)this + 76) + 40);
  if ((*(_DWORD *)(v1 + 16) & 0x80000000) == 0) {
    TDescriptor::InitBaseFont(*(TDescriptor **)(*((void *)this + 76) + 40), 0, 0.0);
  }
  unint64_t v2 = *(uint64_t (**)(void))(*(void *)atomic_load_explicit((atomic_ullong *volatile)(v1 + 32), memory_order_acquire)
                           + 488);

  return v2();
}

id TSplicedFont::CopyCascadeList@<X0>(atomic_ullong *this@<X0>, void *a2@<X8>)
{
  id result = (id)atomic_load_explicit(this + 78, memory_order_acquire);
  *a2  = result;
  return result;
}

uint64_t TSplicedFont::GetPhysicalSymbolicTraits(TSplicedFont *this)
{
  uint64_t v1 = *(void *)(*((void *)this + 76) + 40);
  if ((*(_DWORD *)(v1 + 16) & 0x80000000) == 0) {
    TDescriptor::InitBaseFont(*(TDescriptor **)(*((void *)this + 76) + 40), 0, 0.0);
  }
  unint64_t v2 = *(uint64_t (**)(void))(*(void *)atomic_load_explicit((atomic_ullong *volatile)(v1 + 32), memory_order_acquire)
                           + 528);

  return v2();
}

unint64_t TSplicedFont::GetPresetFallbacksKey(TSplicedFont *this)
{
  uint64_t v1 = *(void *)(*((void *)this + 76) + 40);
  if ((*(_DWORD *)(v1 + 16) & 0x80000000) == 0) {
    TDescriptor::InitBaseFont(*(TDescriptor **)(*((void *)this + 76) + 40), 0, 0.0);
  }
  return atomic_load_explicit((atomic_ullong *volatile)(atomic_load_explicit((atomic_ullong *volatile)(v1 + 32), memory_order_acquire) + 96), memory_order_acquire);
}

uint64_t TSplicedFont::IsBaseVariation(TSplicedFont *this, const __CFDictionary *a2)
{
  return 0;
}

uint64_t TSplicedFont::GetGlyphsForCharacters(TSplicedFont *this, const unsigned __int16 *a2, unsigned __int16 *a3)
{
  uint64_t v3 = *(void *)(*((void *)this + 76) + 40);
  if ((*(_DWORD *)(v3 + 16) & 0x80000000) == 0) {
    TDescriptor::InitBaseFont(*(TDescriptor **)(*((void *)this + 76) + 40), 0, 0.0);
  }
  CFStringRef v4 = *(uint64_t (**)(void))(*(void *)atomic_load_explicit((atomic_ullong *volatile)(v3 + 32), memory_order_acquire)
                           + 664);

  return v4();
}

BOOL TSplicedFont::IsValid(TSplicedFont *this)
{
  return *((void *)this + 76) != 0;
}

const __CFDictionary *TSplicedFont::GetTextStyle(atomic_ullong *this)
{
  CFDictionaryRef result = (const __CFDictionary *)atomic_load_explicit(this + 75, memory_order_acquire);
  if (result) {
    return (const __CFDictionary *)CFDictionaryGetValue(result, @"NSCTFontUIUsageAttribute");
  }
  return result;
}

uint64_t TSplicedFont::HasExuberatedLineHeight(TSplicedFont *this)
{
  uint64_t v1 = *(void *)(*((void *)this + 76) + 40);
  if ((*(_DWORD *)(v1 + 16) & 0x80000000) == 0) {
    TDescriptor::InitBaseFont(*(TDescriptor **)(*((void *)this + 76) + 40), 0, 0.0);
  }
  unint64_t v2 = *(uint64_t (**)(void))(*(void *)atomic_load_explicit((atomic_ullong *volatile)(v1 + 32), memory_order_acquire)
                           + 784);

  return v2();
}

uint64_t TSplicedFont::GetPhysicalTraitsValues(TSplicedFont *this)
{
  uint64_t v1 = *(void *)(*((void *)this + 76) + 40);
  if ((*(_DWORD *)(v1 + 16) & 0x80000000) == 0) {
    TDescriptor::InitBaseFont(*(TDescriptor **)(*((void *)this + 76) + 40), 0, 0.0);
  }
  unint64_t v2 = *(uint64_t (**)(void))(*(void *)atomic_load_explicit((atomic_ullong *volatile)(v1 + 32), memory_order_acquire)
                           + 800);

  return v2();
}

BOOL TSplicedFont::IsSystemUI(atomic_ullong *this)
{
  return TSplicedFontDict::IsSystemUISplice(this + 75);
}

unint64_t TSplicedFont::GetSplicedDict(atomic_ullong *this)
{
  return atomic_load_explicit(this + 75, memory_order_acquire);
}

uint64_t TComponentFont::GetType(TComponentFont *this)
{
  return 1413695044;
}

uint64_t TComponentFont::MayHaveOverrides(TComponentFont *this)
{
  return 1;
}

uint64_t TComponentFont::Substantiate(TComponentFont *this)
{
  return 1;
}

void *__cdecl CTRunDelegateGetRefCon(void *runDelegate)
{
  if (runDelegate)
  {
    *(void *)&long long v1 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v1 + 1)  = 0xAAAAAAAAAAAAAAAALL;
    v2[1]  = v1;
    long long v3 = v1;
    v2[0]  = v1;
    TRunDelegate::TRunDelegate((TRunDelegate *)v2, runDelegate);
    return (void *)*((void *)&v3 + 1);
  }
  return runDelegate;
}

uint64_t TCFBase<TRunDelegate>::ClassDebug()
{
  return 0;
}

double TMetricsDelegateRun::UpdateWidth(TMetricsDelegateRun *this, TLine *a2, uint64_t a3, double a4)
{
  v144[1]  = *MEMORY[0x1E4F143B8];
  double v4 = 0.0;
  if (a2)
  {
    uint64_t v8 = (double *)*((void *)this + 39);
    uint64_t v9 = (double *)MEMORY[0x1E4F1DB30];
    if (!v8) {
      uint64_t v8 = (double *)MEMORY[0x1E4F1DB30];
    }
    double v10 = *((double *)this + 24) + *v8;
    CFDictionaryRef Value = (void *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)this + 5, memory_order_acquire), @"CTRunMetricsDelegate");
    uint64_t v11 = a3 + 1;
    uint64_t v12 = 1;
    uint64_t v13 = a3;
    if (a3 > 0)
    {
      while (1)
      {
        uint64_t v14 = *(void *)(*(void *)(*((void *)a2 + 2) + 8 * v13 - 8) + 40);
        if (!objc_msgSend(Value, "isEqual:", CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)(v14 + 40), memory_order_acquire), @"CTRunMetricsDelegate")))break; {
        if ((*((_WORD *)a2 + 76) & 8) != 0)
        }
          return v4;
        ++v12;
        int v15 = *(double **)(v14 + 312);
        if (!v15) {
          int v15 = v9;
        }
        double v16 = *(double *)(v14 + 192) + *v15;
        double v10 = v10 + v16;
        a4  = a4 - v16;
        if (!--v13)
        {
          uint64_t v12 = a3 + 1;
          break;
        }
      }
    }
    uint64_t v17 = *((void *)a2 + 2);
    uint64_t v18 = *((void *)a2 + 3) - v17;
    if (v11 < v18 >> 3)
    {
      uint64_t v19 = v18 >> 3;
      uint64_t v20 = v12 + ~a3 + (v18 >> 3);
      while (1)
      {
        uint64_t v21 = *(void *)(*(void *)(*((void *)a2 + 2) + 8 * v11) + 40);
        if (!objc_msgSend(Value, "isEqual:", CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)(v21 + 40), memory_order_acquire), @"CTRunMetricsDelegate")))break; {
        if ((*((_WORD *)a2 + 76) & 8) == 0)
        }
          return v4;
        ++v12;
        CFHashCode v22 = *(double **)(v21 + 312);
        if (!v22) {
          CFHashCode v22 = v9;
        }
        double v23 = *(double *)(v21 + 192) + *v22;
        double v10 = v10 + v23;
        a4  = a4 - v23;
        if (v19 == ++v11)
        {
          uint64_t v12 = v20;
          break;
        }
      }
      uint64_t v17 = *((void *)a2 + 2);
    }
    unint64_t v24 = *(void **)(*(void *)(v17 + 8 * v13) + 40);
    uint64_t v26 = v24[1];
    uint64_t v25 = v24[2];
    double v27 = (*(double (**)(void *))(*v24 + 56))(v24);
    double v139 = v27;
    double v28 = (*(double (**)(void *))(*v24 + 64))(v24);
    if (v12 >= 2)
    {
      uint64_t v29 = v12 + v13;
      uint64_t v30 = v13 + 1;
      do
      {
        CFIndex v31 = *(void **)(*(void *)(*((void *)a2 + 2) + 8 * v30) + 40);
        uint64_t v32 = v31[1];
        uint64_t v33 = v26 + v25;
        if (v32 < v26) {
          uint64_t v26 = v31[1];
        }
        uint64_t v34 = v31[2] + v32;
        if (v33 > v34) {
          uint64_t v34 = v33;
        }
        uint64_t v25 = v34 - v26;
        double v35 = (*(double (**)(void))(*v31 + 56))(*(void *)(*(void *)(*((void *)a2 + 2) + 8 * v30)
                                                                         + 40));
        if (v27 < v35) {
          double v27 = v35;
        }
        double v36 = (*(double (**)(void *))(*v31 + 64))(v31);
        if (v28 < v36) {
          double v28 = v36;
        }
        ++v30;
      }
      while (v13 <= v30 && v29 > v30);
      double v139 = v27;
    }
    double v138 = v28;
    uint64_t v37 = [Value beginClusterModificationHandler];
    if (v37)
    {
      uint64_t v38 = v37;
      long long v40 = *(void **)a2;
      unint64_t v39 = (std::__shared_weak_count *)*((void *)a2 + 1);
      if (v39) {
        atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v25 < 1)
      {
        uint64_t v41 = 0;
      }
      else
      {
        uint64_t v41 = 0;
        uint64_t v42 = v26;
        do
        {
          ClusterRange  = TLine::GetClusterRange(a2, v40, v42, 2, 0, 0, 0);
          ++v41;
          uint64_t v42 = ClusterRange + v44;
          BOOL v45 = v26 > ClusterRange + v44 || v25 + v26 <= v42;
        }
        while (!v45);
      }
      uint64_t v134 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, double, double, double, double))(v38 + 16))(v38, v41, v26, v25, v10, a4, v27, v28);
      if (v39) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v39);
      }
    }
    else
    {
      uint64_t v134 = 0;
    }
    uint64_t v46 = [Value clusterModificationHandler];
    if (v46)
    {
      uint64_t v47 = v46;
      char v48 = (std::__shared_weak_count *)*((void *)a2 + 1);
      uint64_t v133 = *(void **)a2;
      if (v48) {
        atomic_fetch_add_explicit(&v48->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v131 = v48;
      memset(v143, 170, sizeof(v143));
      int v141 = 0;
      unint64_t v142 = 0;
      double v140 = 0;
      v144[0]  = v143;
      if (v25 < 1)
      {
        double v4 = 0.0;
      }
      else
      {
        uint64_t v132 = v25 + v26;
        double v4 = 0.0;
        uint64_t v49 = v26;
        do
        {
          double v137 = 0.0;
          memset(v136, 170, sizeof(v136));
          CFIndex v50 = TLine::GetClusterRange(a2, v133, v49, 2, &v136[1], &v137, v136);
          uint64_t v52 = v51;
          if (v136[0] <= 0) {
            uint64_t v53 = *(void *)&v136[1] + *(void *)&v136[3] - 1;
          }
          else {
            uint64_t v53 = *(void *)&v136[1];
          }
          uint64_t v54 = *((void *)a2 + 2);
          uint64_t v55 = *((void *)a2 + 3);
          if (v54 == v55)
          {
            uint64_t v57 = *((void *)a2 + 2);
          }
          else
          {
            uint64_t v56 = 0;
            uint64_t v57 = *((void *)a2 + 2);
            while (1)
            {
              uint64_t v58 = *(void *)(*(void *)(*(void *)v57 + 40) + 208) + v56;
              if (v58 > v53) {
                break;
              }
              v57 += 8;
              uint64_t v56 = v58;
              if (v57 == v55)
              {
                uint64_t v57 = *((void *)a2 + 3);
                goto LABEL_63;
              }
            }
            v53 -= v56;
          }
LABEL_63:
          uint64_t v59 = (v57 - v54) >> 3;
          if (v59 >= (v55 - v54) >> 3) {
            break;
          }
          unsigned int v60 = *(TRun **)(*(void *)(v54 + 8 * v59) + 48);
          double v61 = (*(double (**)(TRun *))(*(void *)v60 + 56))(v60);
          double v62 = (*(double (**)(TRun *))(*(void *)v60 + 64))(v60);
          uint64_t v63 = *(void *)&v136[3];
          if (v136[0] < 0)
          {
            if (v53 - *(void *)&v136[3] + 1 >= v53) {
              uint64_t v63 = 2 - *(void *)&v136[3];
            }
            else {
              uint64_t v53 = v53 - *(void *)&v136[3] + 1;
            }
          }
          uint64_t v64 = *((void *)v60 + 26);
          uint64_t v65 = v63 + v53;
          if (v63 + v53 >= v64) {
            uint64_t v66 = *((void *)v60 + 26);
          }
          else {
            uint64_t v66 = v63 + v53;
          }
          if (v53 < 0 || v53 >= v64)
          {
            BOOL v68 = v65 > 0 && v53 < 1;
            uint64_t v53 = 0;
            if (v68) {
              uint64_t v67 = v66;
            }
            else {
              uint64_t v67 = 0;
            }
          }
          else
          {
            uint64_t v67 = v66 - v53;
          }
          if (v67 >= 1)
          {
            uint64_t v69 = v53;
            uint64_t v70 = *(void *)(*((void *)v60 + 27) + 16);
            uint64_t v71 = *((void *)v60 + 25);
            if (v64 >= v53) {
              uint64_t v72 = v53;
            }
            else {
              uint64_t v72 = *((void *)v60 + 26);
            }
            if (v72 < 1)
            {
              uint64_t v72 = 0;
            }
            else
            {
              uint64_t v73 = (__int16 *)(v70 + 2 * v71);
              uint64_t v74 = *((void *)v60 + 33);
              uint64_t v75 = v72;
              do
              {
                int v77 = *v73++;
                int v76 = v77;
                BOOL v78 = v74-- != 0;
                unsigned int v79 = v78;
                if (v76 == -1) {
                  uint64_t v80 = v79;
                }
                else {
                  uint64_t v80 = 0;
                }
                v69 -= v80;
                --v75;
              }
              while (v75);
            }
            if (v64 >= v53 + v67) {
              uint64_t v64 = v53 + v67;
            }
            BOOL v45 = v64 <= v72;
            uint64_t v81 = v64 - v72;
            if (!v45)
            {
              uint64_t v82 = *((void *)v60 + 33) - v72;
              uint64_t v83 = (__int16 *)(v70 + 2 * v71 + 2 * v72);
              do
              {
                int v85 = *v83++;
                int v84 = v85;
                BOOL v78 = v82-- != 0;
                unsigned int v86 = v78;
                if (v84 == -1) {
                  uint64_t v87 = v86;
                }
                else {
                  uint64_t v87 = 0;
                }
                v67 -= v87;
                --v81;
              }
              while (v81);
            }
            double v88 = (*(double (**)(uint64_t, uint64_t, CFIndex, uint64_t, void, uint64_t, uint64_t, double *, double, double *))(v47 + 16))(v47, v134, v50, v52, *(void *)(*((void *)a2 + 2) + 8 * v59), v69, v67, &v139, v137, &v138);
            if (v88 != 0.0)
            {
              double v89 = v88;
              uint64_t v90 = v141;
              if (v141 >= v142)
              {
                unint64_t v92 = 0xAAAAAAAAAAAAAAABLL * ((v141 - v140) >> 3);
                unint64_t v93 = v92 + 1;
                if (v92 + 1 > 0xAAAAAAAAAAAAAAALL) {
                  abort();
                }
                if (0x5555555555555556 * ((v142 - v140) >> 3) > v93) {
                  unint64_t v93 = 0x5555555555555556 * ((v142 - v140) >> 3);
                }
                if (0xAAAAAAAAAAAAAAABLL * ((v142 - v140) >> 3) >= 0x555555555555555) {
                  unint64_t v94 = 0xAAAAAAAAAAAAAAALL;
                }
                else {
                  unint64_t v94 = v93;
                }
                if (v94)
                {
                  double v95 = (char *)v144[0];
                  if (v144[0] + 24 * v94 <= (unint64_t)v144)
                  {
                    v144[0] += 24 * v94;
                  }
                  else
                  {
                    if (v94 > 0xAAAAAAAAAAAAAAALL) {
                      std::__throw_bad_array_new_length[abi:nn180100]();
                    }
                    double v95 = (char *)operator new(24 * v94);
                  }
                }
                else
                {
                  double v95 = 0;
                }
                int v96 = &v95[24 * v92];
                *(_OWORD *)int v96 = *(_OWORD *)&v136[1];
                *((double *)v96 + 2)  = v89;
                uint64_t v98 = v140;
                double v97 = v141;
                int v99 = v96;
                if (v141 != v140)
                {
                  do
                  {
                    long long v100 = *(_OWORD *)(v97 - 24);
                    *((void *)v99 - 1)  = *((void *)v97 - 1);
                    *(_OWORD *)(v99 - 24)  = v100;
                    v99 -= 24;
                    v97 -= 24;
                  }
                  while (v97 != v98);
                  double v97 = v140;
                }
                uint64_t v91 = v96 + 24;
                double v140 = v99;
                int v141 = v96 + 24;
                double v101 = v142;
                unint64_t v142 = &v95[24 * v94];
                if (v97)
                {
                  if (v143 <= v97 && v144 > (void *)v97)
                  {
                    if (v101 == (char *)v144[0]) {
                      v144[0]  = v97;
                    }
                  }
                  else
                  {
                    operator delete(v97);
                  }
                }
              }
              else
              {
                *(_OWORD *)int v141 = *(_OWORD *)&v136[1];
                *((double *)v90 + 2)  = v88;
                uint64_t v91 = (char *)v90 + 24;
              }
              double v4 = v4 + v89;
              int v141 = v91;
            }
            double v103 = v139;
            if (v139 != v61 && v139 > 0.0) {
              *(double *)(TRun::EnsureRareData(v60) + 32)  = v103;
            }
            double v104 = v138;
            if (v138 != v62 && v138 > 0.0) {
              *(double *)(TRun::EnsureRareData(v60) + 40)  = v104;
            }
            uint64_t v49 = v50 + v52;
          }
        }
        while (v26 <= v49 && v132 > v49);
      }
      CGSize v106 = v140;
      CFRange v105 = v141;
      if (v140 != v141)
      {
        do
        {
          uint64_t v107 = *(void *)v106;
          __int16 v108 = *((_WORD *)a2 + 76);
          if ((v108 & 8) == 0) {
            uint64_t v107 = v107 + *((void *)v106 + 1) - 1;
          }
          uint64_t v109 = *((void *)a2 + 2);
          uint64_t v110 = *((void *)a2 + 3);
          if (v109 == v110)
          {
            uint64_t v114 = 0xAAAAAAAAAAAAAAAALL;
            uint64_t v112 = *((void *)a2 + 2);
          }
          else
          {
            uint64_t v111 = 0;
            uint64_t v112 = *((void *)a2 + 2);
            while (1)
            {
              uint64_t v113 = *(void *)(*(void *)(*(void *)v112 + 40) + 208) + v111;
              if (v113 > v107) {
                break;
              }
              v112 += 8;
              uint64_t v111 = v113;
              if (v112 == v110)
              {
                uint64_t v114 = 0xAAAAAAAAAAAAAAAALL;
                uint64_t v112 = *((void *)a2 + 3);
                goto LABEL_155;
              }
            }
            uint64_t v114 = v107 - v111;
          }
LABEL_155:
          uint64_t v115 = (v112 - v109) >> 3;
          if (v115 < (v110 - v109) >> 3)
          {
            double v116 = *((double *)v106 + 2);
            uint64_t v117 = *(void **)(*(void *)(v109 + 8 * v115) + 48);
            if ((v108 & 8) != 0)
            {
              while (1)
              {
                uint64_t v121 = v114 - 1;
                if (v114 < 1) {
                  break;
                }
                int v118 = (void *)v117[27];
                uint64_t v119 = v117[25];
                char v122 = *(unsigned char *)(v118[5] + 4 * v119 + 4 * v114-- - 4);
                if ((v122 & 0x20) == 0)
                {
LABEL_162:
                  uint64_t v123 = v118[4];
                  if (v123 || (uint64_t v126 = v118[3]) == 0)
                  {
                    uint64_t v124 = v123 + 16 * v119 + 16 * v121;
                    uint64_t v125 = *(void *)(v124 + 8);
                  }
                  else
                  {
                    uint64_t v124 = v126 + 8 * v119 + 8 * v121;
                    uint64_t v125 = 0;
                  }
                  uint64_t v127 = (TStorageRange *)(v117 + 24);
                  double v128 = v116 + *(double *)v124;
                  TStorageRange::SetAdvance((TStorageRange *)(v117 + 24), v121, *(CGSize *)(&v125 - 1));
                  TStorageRange::SetInterGlyphsExtraSpace(v127, v121, v116);
                  goto LABEL_168;
                }
              }
            }
            else
            {
              while (v114 + 1 >= 1)
              {
                int v118 = (void *)v117[27];
                uint64_t v119 = v117[25];
                int v120 = *(_DWORD *)(v118[5] + 4 * v119 + 4 * v114--);
                if ((v120 & 0x20) == 0)
                {
                  uint64_t v121 = v114 + 1;
                  goto LABEL_162;
                }
              }
            }
            v145.height  = 0.0;
            v145.CGFloat width = *((CGFloat *)v106 + 2);
            TRun::AdvanceInitialAdvance((TRun *)v117, v145);
          }
LABEL_168:
          v106 += 24;
        }
        while (v106 != v105);
        CGSize v106 = v140;
      }
      if (v106)
      {
        int v141 = v106;
        if (v143 > v106 || v144 <= (void *)v106) {
          operator delete(v106);
        }
      }
      if (v131) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v131);
      }
    }
    else
    {
      double v4 = 0.0;
    }
    uint64_t v129 = [Value endClusterModificationHandler];
    if (v129) {
      (*(void (**)(uint64_t, uint64_t))(v129 + 16))(v129, v134);
    }
  }
  return v4;
}

void TMetricsDelegateRun::~TMetricsDelegateRun(void **this)
{
  TRun::~TRun(this);

  JUMPOUT(0x1853275C0);
}

uint64_t TMetricsDelegateRun::FindBreak@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, const TCharStream *a3@<X2>, int a4@<W3>, uint64_t a5@<X8>, double a6@<D0>)
{
  *(_OWORD *)a5  = xmmword_184BA8BD0;
  *(void *)(a5 + 16)  = -1;
  uint64_t result = TRun::FindBreak(a1, a2, a3, a4, a5, a6);
  *(unsigned char *)a5 |= 8u;
  return result;
}

uint64_t TMetricsDelegateRun::CanUpdateWidth(TMetricsDelegateRun *this)
{
  return 1;
}

unint64_t TInstanceFont::GetPresetFallbacksKey(atomic_ullong *this)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  atomic_load_explicit(this + 79, memory_order_acquire);
  ParserFont  = CGFontGetParserFont();
  if (!ParserFont || !atomic_load_explicit(this + 75, memory_order_acquire)) {
    return atomic_load_explicit(this + 12, memory_order_acquire);
  }
  uint64_t v3 = ParserFont;
  id keys = &unk_1ED082E48;
  id values = (void *)CFDictionaryGetValue((CFDictionaryRef)atomic_load_explicit(this + 75, memory_order_acquire), &unk_1ED082E48);
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFDictionaryRef v5 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  id keys = v5;
  CFArrayRef v6 = CFArrayCreate(v4, (const void **)&keys, 1, MEMORY[0x1E4F1D510]);
  id v28 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr, atomic_ullong *))(*this + 120))(&v28, this);
  id v27 = (id)0xAAAAAAAAAAAAAAAALL;
  CreateClosestInstanceVariation(v6, (id)atomic_load_explicit((atomic_ullong *volatile)&v28, memory_order_acquire), &v27);
  CFDictionaryRef v7 = (const __CFDictionary *)(id)atomic_load_explicit((atomic_ullong *volatile)&v27, memory_order_acquire);
  if (!v7)
  {

LABEL_9:
    int v18 = 1;
    goto LABEL_21;
  }
  CFDictionaryRef v8 = v7;
  unint64_t Count = CFDictionaryGetCount(v7);

  if (!Count) {
    goto LABEL_9;
  }
  *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v10 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  v43[14]  = v10;
  v43[13]  = v10;
  v43[12]  = v10;
  v43[11]  = v10;
  v43[10]  = v10;
  v43[9]  = v10;
  v43[8]  = v10;
  v43[7]  = v10;
  v43[6]  = v10;
  v43[5]  = v10;
  v43[4]  = v10;
  v43[3]  = v10;
  v43[2]  = v10;
  v43[1]  = v10;
  v43[0]  = v10;
  id values = 0;
  uint64_t v41 = 0;
  uint64_t v42 = 0;
  uint64_t v44 = v43;
  std::vector<long,TInlineBufferAllocator<long,30ul>>::__vallocate[abi:nn180100](&values, Count);
  uint64_t v11 = (char *)v41;
  bzero(v41, 8 * Count);
  uint64_t v41 = &v11[8 * Count];
  *(void *)&long long v12 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v12 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  v38[14]  = v12;
  v38[13]  = v12;
  v38[12]  = v12;
  v38[11]  = v12;
  v38[10]  = v12;
  v38[9]  = v12;
  v38[8]  = v12;
  v38[7]  = v12;
  v38[6]  = v12;
  v38[5]  = v12;
  v38[4]  = v12;
  v38[3]  = v12;
  v38[2]  = v12;
  v38[1]  = v12;
  v38[0]  = v12;
  double v35 = 0;
  double v36 = 0;
  uint64_t v37 = 0;
  unint64_t v39 = v38;
  std::vector<long,TInlineBufferAllocator<long,30ul>>::__vallocate[abi:nn180100](&v35, Count);
  uint64_t v13 = (char *)v36;
  bzero(v36, 8 * Count);
  double v36 = &v13[8 * Count];
  CFDictionaryRef explicit = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v27, memory_order_acquire);
  CFDictionaryGetKeysAndValues(explicit, (const void **)values, (const void **)v35);
  *(void *)&long long v15 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v15 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  v33[28]  = v15;
  v33[29]  = v15;
  v33[26]  = v15;
  v33[27]  = v15;
  v33[24]  = v15;
  v33[25]  = v15;
  v33[22]  = v15;
  v33[23]  = v15;
  v33[20]  = v15;
  v33[21]  = v15;
  v33[18]  = v15;
  v33[19]  = v15;
  v33[16]  = v15;
  v33[17]  = v15;
  v33[15]  = v15;
  v33[14]  = v15;
  v33[13]  = v15;
  v33[12]  = v15;
  v33[11]  = v15;
  v33[10]  = v15;
  v33[9]  = v15;
  v33[8]  = v15;
  v33[7]  = v15;
  v33[6]  = v15;
  v33[5]  = v15;
  v33[4]  = v15;
  v33[3]  = v15;
  v33[2]  = v15;
  v33[1]  = v15;
  v33[0]  = v15;
  id keys = 0;
  CFIndex v31 = 0;
  uint64_t v32 = 0;
  uint64_t v34 = v33;
  if (Count >> 60) {
    abort();
  }
  if (&v33[Count] <= (_OWORD *)&v34)
  {
    uint64_t v34 = &v33[Count];
    size_t v16 = 16 * Count;
    uint64_t v17 = v33;
  }
  else
  {
    size_t v16 = 16 * Count;
    uint64_t v17 = operator new(16 * Count);
  }
  uint64_t v19 = &v17[Count];
  id keys = v17;
  uint64_t v32 = v19;
  bzero(v17, v16);
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  CFIndex v31 = v19;
  do
  {
    CFNumberRef v22 = (const __CFNumber *)*((void *)values + v21);
    LODWORD(valuePtr)  = -1431655766;
    CFNumberGetValue(v22, kCFNumberIntType, &valuePtr);
    *(_DWORD *)((char *)keys + v20)  = valuePtr;
    CFNumberRef v23 = (const __CFNumber *)v35[v21];
    uint64_t valuePtr = -1;
    CFNumberGetValue(v23, kCFNumberDoubleType, &valuePtr);
    *(void *)((char *)keys + v20 + 8)  = valuePtr;
    ++v21;
    v20 += 16;
  }
  while (Count != v21);
  CopyWithVariation  = FPFontCreateCopyWithVariation();
  if (CopyWithVariation)
  {
    uint64_t v25 = (const void *)FPFontCopyPostScriptName();
    FPFontRelease();
    uint64_t v3 = (uint64_t)CFAutorelease(v25);
  }
  if (keys)
  {
    CFIndex v31 = keys;
    if (v33 > keys || &v34 <= keys) {
      operator delete(keys);
    }
  }
  id keys = &v35;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&keys);
  id keys = &values;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&keys);
  if (!CopyWithVariation) {
    goto LABEL_9;
  }
  int v18 = 0;
LABEL_21:

  if (v18) {
    return atomic_load_explicit(this + 12, memory_order_acquire);
  }
  return v3;
}

void TInstanceFont::TInstanceFont(TInstanceFont *this, atomic_ullong *a2, const __CFDictionary *a3)
{
  TBaseFont::TBaseFont(this, a2);
  *(void *)uint64_t v6 = &unk_1ED05DBE0;
  *(unsigned char *)(v6 + 624)  = 0;
  *(_OWORD *)(v6 + 600)  = 0u;
  *(unsigned char *)(v6 + 616)  = 0;
  *(_OWORD *)(v6 + 632)  = 0u;
  id v12 = (id)0xAAAAAAAAAAAAAAAALL;
  GetBaseCGFont(a2, a3, (atomic_ullong *)&v12);
  CFDictionaryRef v7 = CGFontCopyVariations((CGFontRef)atomic_load_explicit((atomic_ullong *volatile)&v12, memory_order_acquire));
  CFDictionaryRef explicit = (CGFont *)atomic_load_explicit((atomic_ullong *volatile)&v12, memory_order_acquire);
  (*(void (**)(id *__return_ptr, atomic_ullong *))(*a2 + 120))(&v10, a2);
  CreateValidVariation((const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire), a3, (CFDictionaryRef *)&v11);
  TInstanceFont::InitWithVariation((atomic_ullong *)this, explicit, v7, (id)atomic_load_explicit((atomic_ullong *volatile)&v11, memory_order_acquire));

  if ((*(unsigned int (**)(atomic_ullong *))(*a2 + 16))(a2) == 1414088260)
  {
    atomic_ullong v9 = a2[77];
    *((unsigned char *)this + 624)  = *((unsigned char *)a2 + 624);
    *((void *)this + 77)  = v9;
  }
}

void TInstanceFont::TInstanceFont(TInstanceFont *this, const TInstanceFont *a2)
{
  TBaseFont::TBaseFont(this, (atomic_ullong *)a2);
  *CFAllocatorRef v4 = &unk_1ED05DBE0;
  CFDictionaryRef v5 = v4 + 75;
  *((void *)this + 75)  = (id)atomic_load_explicit((atomic_ullong *volatile)a2 + 75, memory_order_acquire);
  *((void *)this + 76)  = (id)atomic_load_explicit((atomic_ullong *volatile)a2 + 76, memory_order_acquire);
  *(_OWORD *)((char *)this + 616)  = *(_OWORD *)((char *)a2 + 616);
  *((void *)this + 79)  = (id)atomic_load_explicit((atomic_ullong *volatile)a2 + 79, memory_order_acquire);
  *((void *)this + 80)  = (id)atomic_load_explicit((atomic_ullong *volatile)a2 + 80, memory_order_acquire);
  TCFRef<__CTFont const*>::Retain((atomic_ullong *)this + 12, (id)atomic_load_explicit((atomic_ullong *volatile)a2 + 12, memory_order_acquire));
  id v6 = (id)atomic_load_explicit(v5, memory_order_acquire);
  TBaseFont::SetAttributeInternal<TCFRef<__CFSet const*>>((atomic_ullong *)this, (atomic_ullong *)&v6, @"NSCTFontVariationAttribute");
}

void TInstanceFont::CopyLocalizedName(atomic_ullong *this@<X0>, const __CFString *a2@<X1>, CFArrayRef theArray@<X2>, const __CFString **a4@<X3>, atomic_ullong *a5@<X8>)
{
  if (@"CTFontFullName" != a2 && (!a2 || !@"CTFontFullName" || !CFEqual(a2, @"CTFontFullName"))) {
    goto LABEL_12;
  }
  id v12 = (id)0xAAAAAAAAAAAAAAAALL;
  TBaseFont::CopyLocalizedName(this, @"CTFontFamilyName", theArray, 0, (atomic_ullong *)&v12);
  if (!atomic_load_explicit((atomic_ullong *volatile)&v12, memory_order_acquire))
  {
LABEL_11:

LABEL_12:
    TBaseFont::CopyLocalizedName(this, a2, theArray, a4, a5);
    return;
  }
  id MutableCopy = (id)0xAAAAAAAAAAAAAAAALL;
  id MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, (CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&v12, memory_order_acquire));
  if (!atomic_load_explicit((atomic_ullong *volatile)&MutableCopy, memory_order_acquire))
  {

    goto LABEL_11;
  }
  id v10 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr, atomic_ullong *, __CFString *, CFArrayRef, void))(*this + 88))(&v10, this, @"CTFontSubFamilyName", theArray, 0);
  if (atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire)) {
    CFStringAppendFormat((CFMutableStringRef)atomic_load_explicit((atomic_ullong *volatile)&MutableCopy, memory_order_acquire), 0, @" %@", atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire));
  }
  *a5  = atomic_exchange((atomic_ullong *volatile)&MutableCopy, 0);
}

void TInstanceFont::CopyAttribute(atomic_ullong *this@<X0>, uint64_t a2@<X1>, atomic_ullong *a3@<X8>)
{
  if (a2 == 62)
  {
    if (atomic_load_explicit(this + 80, memory_order_acquire))
    {
      id v6 = (id)0xAAAAAAAAAAAAAAAALL;
      atomic_load_explicit(this + 80, memory_order_acquire);
      CreateVariationDictFromGraphicsFont(&v6);
      CreateCodableVariationFromDefaultVariation((const __CFDictionary *)atomic_load_explicit(this + 75, memory_order_acquire), (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v6, memory_order_acquire), (unint64_t *)&v5);
      *a3  = atomic_exchange((atomic_ullong *volatile)&v5, 0);
    }
    else
    {
      *a3  = (atomic_ullong)(id)atomic_load_explicit(this + 75, memory_order_acquire);
    }
  }
  else
  {
    TBaseFont::CopyAttribute((TBaseFont *)this, a2, a3);
  }
}

CFStringRef TInstanceFont::DebugDescription(TInstanceFont *this)
{
  (*(void (**)(id *__return_ptr))(*(void *)this + 200))(&v4);
  long long v1 = (void *)atomic_exchange((atomic_ullong *volatile)&v4, 0);

  CFStringRef v2 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"InstanceFont <url: %@>", v1);
  return v2;
}

unint64_t TInstanceFont::GetGraphicsFontForNames(atomic_ullong *this)
{
  unint64_t result = atomic_load_explicit(this + 80, memory_order_acquire);
  if (!result) {
    return atomic_load_explicit(this + 79, memory_order_acquire);
  }
  return result;
}

CFDictionaryRef IsValueInRangeOfAxis(double a1, const __CFDictionary *result)
{
  if (result)
  {
    CFDictionaryRef v2 = result;
    double v3 = trunc(a1 * 10000.0) / 10000.0;
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(result, @"NSCTVariationAxisMinimumValue");
    if (CFNumberCompare((CFNumberRef)[NSNumber numberWithDouble:v3], Value, 0) == kCFCompareLessThan)
    {
      return 0;
    }
    else
    {
      CFNumberRef v5 = (const __CFNumber *)CFDictionaryGetValue(v2, @"NSCTVariationAxisMaximumValue");
      return (const __CFDictionary *)(CFNumberCompare((CFNumberRef)[NSNumber numberWithDouble:v3], v5, 0) != kCFCompareGreaterThan);
    }
  }
  return result;
}

void CreateClosestInstanceVariation(const __CFArray *a1@<X1>, id a2@<X2>, void *a3@<X8>)
{
  uint64_t v159 = *MEMORY[0x1E4F143B8];
  id v129 = (id)0xAAAAAAAAAAAAAAAALL;
  if (a2) {
    id v129 = a2;
  }
  else {
    CopyVariationAxes(&v129);
  }
  if (!atomic_load_explicit((atomic_ullong *volatile)&v129, memory_order_acquire))
  {
    *a3  = 0;
    goto LABEL_159;
  }
  CFArrayRef explicit = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v129, memory_order_acquire);
  id v133 = 0;
  CFIndex Count = CFArrayGetCount(explicit);
  CFIndex v8 = CFArrayGetCount(a1);
  BOOL v9 = v8 > Count || v8 == 0;
  if (v9)
  {
    *a3  = 0;
    goto LABEL_158;
  }
  uint64_t v131 = 0;
  uint64_t v132 = 0;
  uint64_t v130 = (uint64_t *)&v131;
  uint64_t v124 = a3;
  CFArrayRef theArray = explicit;
  capacitdouble y = Count;
  if (a1 && (CFIndex v126 = CFArrayGetCount(a1)) != 0)
  {
    CFIndex v10 = 0;
    uint64_t v11 = 1;
    do
    {
      CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(a1, v10);
      CFIndex v13 = CFDictionaryGetCount(ValueAtIndex);
      *(void *)&long long v14 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v14 + 1)  = 0xAAAAAAAAAAAAAAAALL;
      v157[13]  = v14;
      v157[14]  = v14;
      v157[11]  = v14;
      v157[12]  = v14;
      v157[9]  = v14;
      v157[10]  = v14;
      v157[7]  = v14;
      v157[8]  = v14;
      v157[5]  = v14;
      v157[6]  = v14;
      v157[3]  = v14;
      v157[4]  = v14;
      v157[1]  = v14;
      v157[2]  = v14;
      v157[0]  = v14;
      *(double *)&id v154 = 0.0;
      long long v155 = 0;
      uint64_t v156 = 0;
      long long v158 = v157;
      if (v13)
      {
        unint64_t v15 = v13;
        std::vector<long,TInlineBufferAllocator<long,30ul>>::__vallocate[abi:nn180100](&v154, v13);
        size_t v16 = (char *)v155;
        bzero(v155, 8 * v15);
        long long v155 = &v16[8 * v15];
        *(void *)&long long v17 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v17 + 1)  = 0xAAAAAAAAAAAAAAAALL;
        long long v151 = v17;
        long long v152 = v17;
        long long v149 = v17;
        long long v150 = v17;
        long long v147 = v17;
        long long v148 = v17;
        long long v145 = v17;
        long long v146 = v17;
        long long v143 = v17;
        long long v144 = v17;
        long long v141 = v17;
        long long v142 = v17;
        long long v139 = v17;
        long long v140 = v17;
        long long v138 = v17;
        id v135 = 0;
        uint64_t v136 = 0;
        uint64_t v137 = 0;
        uint64_t v153 = &v138;
        std::vector<long,TInlineBufferAllocator<long,30ul>>::__vallocate[abi:nn180100](&v135, v15);
        int v18 = (char *)v136;
        bzero(v136, 8 * v15);
        uint64_t v136 = &v18[8 * v15];
        uint64_t v19 = (const void **)v154;
        uint64_t v20 = (const void **)v135;
      }
      else
      {
        uint64_t v20 = 0;
        uint64_t v19 = 0;
        long long v151 = v14;
        long long v152 = v14;
        long long v149 = v14;
        long long v150 = v14;
        long long v147 = v14;
        long long v148 = v14;
        long long v145 = v14;
        long long v146 = v14;
        long long v143 = v14;
        long long v144 = v14;
        long long v141 = v14;
        long long v142 = v14;
        long long v139 = v14;
        long long v140 = v14;
        long long v138 = v14;
        id v135 = 0;
        uint64_t v136 = 0;
        uint64_t v137 = 0;
        uint64_t v153 = &v138;
      }
      CFDictionaryGetKeysAndValues(ValueAtIndex, v19, v20);
      double v21 = __exp10((double)v11);
      double v22 = v21;
      CFNumberRef v23 = *(const __CFNumber **)v135;
      if (*(void *)v135)
      {
        unint64_t valuePtr = -1;
        CFNumberGetValue(v23, kCFNumberDoubleType, &valuePtr);
        unint64_t v24 = valuePtr;
      }
      else
      {
        double v22 = -v21;
        unint64_t v24 = 0;
      }
      CFNumberRef v25 = *(const __CFNumber **)v154;
      LODWORD(valuePtr)  = -1431655766;
      CFNumberGetValue(v25, kCFNumberIntType, &valuePtr);
      int v26 = valuePtr;
      id v27 = v131;
      id v28 = &v131;
      uint64_t v29 = &v131;
      if (v131)
      {
        while (1)
        {
          while (1)
          {
            uint64_t v29 = (uint64_t **)v27;
            unsigned int v30 = *((_DWORD *)v27 + 8);
            if (v30 <= valuePtr) {
              break;
            }
            id v27 = *v29;
            id v28 = v29;
            if (!*v29) {
              goto LABEL_28;
            }
          }
          if (v30 >= valuePtr) {
            break;
          }
          id v27 = v29[1];
          if (!v27)
          {
            id v28 = v29 + 1;
            goto LABEL_28;
          }
        }
      }
      else
      {
LABEL_28:
        CFIndex v31 = operator new(0x40uLL);
        v31[8]  = v26;
        *((void *)v31 + 5)  = v24;
        *((void *)v31 + 6)  = 0;
        *((double *)v31 + 7)  = v22;
        *(void *)CFIndex v31 = 0;
        *((void *)v31 + 1)  = 0;
        *((void *)v31 + 2)  = v29;
        void *v28 = (uint64_t *)v31;
        if (*v130)
        {
          uint64_t v130 = (uint64_t *)*v130;
          uint64_t v32 = *v28;
        }
        else
        {
          uint64_t v32 = (uint64_t *)v31;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v131, v32);
        ++v132;
      }
      ++v11;
      unint64_t valuePtr = (unint64_t)&v135;
      std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&valuePtr);
      id v135 = &v154;
      std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v135);
      ++v10;
    }
    while (v10 != v126);
  }
  else
  {
    uint64_t v11 = 1;
  }
  uint64_t v33 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
  CFArrayRef v34 = theArray;
  if (!theArray || (CFIndex v35 = CFArrayGetCount(theArray)) == 0)
  {
LABEL_118:
    id Mutable = CFDictionaryCreateMutable(*v33, capacity, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    int v85 = v130;
    if (v130 != (uint64_t *)&v131)
    {
      do
      {
        unsigned int v86 = *((_DWORD *)v85 + 8);
        double v87 = *((double *)v85 + 6);
        *(double *)&id v154 = -3.72066208e-103;
        TCFNumber::TCFNumber<unsigned int>(&v154, v86);
        id v135 = (id)0xAAAAAAAAAAAAAAAALL;
        TCFNumber::TCFNumber<double>(&v135, v87);
        CFDictionaryAddValue(Mutable, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v154, memory_order_acquire), (const void *)atomic_load_explicit((atomic_ullong *volatile)&v135, memory_order_acquire));

        double v88 = (uint64_t *)v85[1];
        if (v88)
        {
          do
          {
            double v89 = (uint64_t **)v88;
            double v88 = (uint64_t *)*v88;
          }
          while (v88);
        }
        else
        {
          do
          {
            double v89 = (uint64_t **)v85[2];
            BOOL v9 = *v89 == v85;
            int v85 = (uint64_t *)v89;
          }
          while (!v9);
        }
        int v85 = (uint64_t *)v89;
      }
      while (v89 != &v131);
    }
    TCFRef<__CTFont const*>::Retain((atomic_ullong *)&v133, Mutable);
    *uint64_t v124 = atomic_exchange((atomic_ullong *volatile)&v133, 0);
    goto LABEL_157;
  }
  CFIndex v36 = v35;
  int v127 = 0;
  CFIndex v37 = 0;
  double v38 = 0.0;
  do
  {
    CFDictionaryRef v39 = (const __CFDictionary *)CFArrayGetValueAtIndex(v34, v37);
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v39, @"NSCTVariationAxisIdentifier");
    LODWORD(v154)  = -1431655766;
    CFNumberGetValue(Value, kCFNumberIntType, &v154);
    unsigned int v41 = v154;
    CFNumberRef v42 = (const __CFNumber *)CFDictionaryGetValue(v39, @"NSCTVariationAxisDefaultValue");
    *(double *)&id v154 = NAN;
    CFNumberGetValue(v42, kCFNumberDoubleType, &v154);
    id v43 = v154;
    CFNumberRef v44 = (const __CFNumber *)CFDictionaryGetValue(v39, @"NSCTVariationAxisMinimumValue");
    *(double *)&id v154 = NAN;
    CFNumberGetValue(v44, kCFNumberDoubleType, &v154);
    double v45 = *(double *)&v154;
    CFNumberRef v46 = (const __CFNumber *)CFDictionaryGetValue(v39, @"NSCTVariationAxisMaximumValue");
    *(double *)&id v154 = NAN;
    CFNumberGetValue(v46, kCFNumberDoubleType, &v154);
    uint64_t v47 = v131;
    if (!v131)
    {
LABEL_44:
      double v51 = __exp10((double)v11++);
LABEL_45:
      double v45 = *(double *)&v43;
      goto LABEL_46;
    }
    id v48 = v154;
    uint64_t v49 = v131;
    while (1)
    {
      unsigned int v50 = *((_DWORD *)v49 + 8);
      if (v41 >= v50) {
        break;
      }
LABEL_43:
      uint64_t v49 = (uint64_t *)*v49;
      if (!v49) {
        goto LABEL_44;
      }
    }
    if (v50 < v41)
    {
      ++v49;
      goto LABEL_43;
    }
    do
    {
      while (1)
      {
        uint64_t v64 = v47;
        unsigned int v65 = *((_DWORD *)v47 + 8);
        if (v65 <= v41) {
          break;
        }
        uint64_t v47 = (uint64_t *)*v64;
        if (!*v64)
        {
          uint64_t v66 = (uint64_t **)v64;
          goto LABEL_99;
        }
      }
      if (v65 >= v41)
      {
        uint64_t v74 = v64;
        goto LABEL_102;
      }
      uint64_t v47 = (uint64_t *)v64[1];
    }
    while (v47);
    uint64_t v66 = (uint64_t **)(v64 + 1);
LABEL_99:
    uint64_t v74 = operator new(0x40uLL);
    *((_DWORD *)v74 + 8)  = v41;
    *((void *)v74 + 6)  = 0;
    *((void *)v74 + 7)  = 0;
    *((void *)v74 + 5)  = 0;
    *(void *)uint64_t v74 = 0;
    *((void *)v74 + 1)  = 0;
    *((void *)v74 + 2)  = v64;
    *uint64_t v66 = (uint64_t *)v74;
    uint64_t v75 = (uint64_t *)v74;
    if (*v130)
    {
      uint64_t v130 = (uint64_t *)*v130;
      uint64_t v75 = *v66;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v131, v75);
    ++v132;
    CFArrayRef v34 = theArray;
LABEL_102:
    double v51 = *((double *)v74 + 7);
    if (v51 <= 0.0)
    {
      double v51 = -v51;
      goto LABEL_45;
    }
    double v76 = *((double *)v74 + 5);
    if (*(double *)&v48 >= v76) {
      double v77 = *((double *)v74 + 5);
    }
    else {
      double v77 = *(double *)&v48;
    }
    if (v76 >= v45) {
      double v45 = v77;
    }
    int v78 = v127;
    if (v127) {
      BOOL v79 = 1;
    }
    else {
      BOOL v79 = v45 == *(double *)&v43;
    }
    if (!v79) {
      int v78 = 1;
    }
    int v127 = v78;
LABEL_46:
    uint64_t v52 = v131;
    if (!v131)
    {
      unsigned int v60 = &v131;
      if (v130 == (uint64_t *)&v131)
      {
        uint64_t v59 = 0;
        unsigned int v60 = &v131;
        uint64_t v63 = &v131;
        goto LABEL_84;
      }
      goto LABEL_67;
    }
    uint64_t v53 = &v131;
    uint64_t v54 = v131;
    do
    {
      uint64_t v55 = v54;
      uint64_t v56 = (double *)v53;
      unsigned int v57 = *((_DWORD *)v54 + 8);
      uint64_t v58 = (uint64_t **)(v54 + 1);
      if (v57 >= v41)
      {
        uint64_t v58 = (uint64_t **)v55;
        uint64_t v53 = (uint64_t **)v55;
      }
      uint64_t v54 = *v58;
    }
    while (v54);
    uint64_t v59 = v131;
    unsigned int v60 = &v131;
    if (v53 == &v131)
    {
LABEL_57:
      if (v130 == (uint64_t *)v60)
      {
        uint64_t v63 = v60;
        goto LABEL_84;
      }
      double v62 = v59;
      if (v59)
      {
        do
        {
          uint64_t v63 = (uint64_t **)v62;
          double v62 = (uint64_t *)v62[1];
        }
        while (v62);
        goto LABEL_70;
      }
LABEL_67:
      uint64_t v63 = v60;
      do
      {
        uint64_t v67 = (uint64_t *)v63;
        uint64_t v63 = (uint64_t **)v63[2];
      }
      while (*v63 == v67);
      uint64_t v59 = 0;
LABEL_70:
      if (*((_DWORD *)v63 + 8) >= v41)
      {
        BOOL v68 = &v131;
        uint64_t v69 = &v131;
        if (v131)
        {
          while (1)
          {
            while (1)
            {
              uint64_t v69 = (uint64_t **)v52;
              unsigned int v70 = *((_DWORD *)v52 + 8);
              if (v70 <= v41) {
                break;
              }
              uint64_t v52 = *v69;
              BOOL v68 = v69;
              if (!*v69) {
                goto LABEL_91;
              }
            }
            if (v70 >= v41) {
              goto LABEL_95;
            }
            uint64_t v52 = v69[1];
            if (!v52)
            {
              BOOL v68 = v69 + 1;
              break;
            }
          }
        }
LABEL_91:
        uint64_t v72 = (double *)operator new(0x40uLL);
        *((_DWORD *)v72 + 8)  = v41;
        v72[5]  = v45;
        v72[6]  = *(double *)&v43;
        v72[7]  = v51;
        *uint64_t v72 = 0.0;
        v72[1]  = 0.0;
        *((void *)v72 + 2)  = v69;
        *BOOL v68 = (uint64_t *)v72;
        if (*v130)
        {
          uint64_t v130 = (uint64_t *)*v130;
          uint64_t v73 = *v68;
        }
        else
        {
          uint64_t v73 = (uint64_t *)v72;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v131, v73);
        ++v132;
        goto LABEL_95;
      }
LABEL_84:
      if (v59) {
        uint64_t v69 = v63;
      }
      else {
        uint64_t v69 = v60;
      }
      if (v59) {
        BOOL v68 = v63 + 1;
      }
      else {
        BOOL v68 = v60;
      }
      if (*v68) {
        goto LABEL_95;
      }
      goto LABEL_91;
    }
    if (v57 >= v41) {
      double v61 = v55;
    }
    else {
      double v61 = v56;
    }
    if (v61[8] > v41)
    {
      uint64_t v59 = *v53;
      unsigned int v60 = v53;
      goto LABEL_57;
    }
    if (v57 >= v41) {
      uint64_t v71 = (double *)v55;
    }
    else {
      uint64_t v71 = v56;
    }
    v71[5]  = v45;
    v71[6]  = *(double *)&v43;
    v71[7]  = v51;
LABEL_95:
    double v38 = v38 + v51 * v45 * (v51 * v45);
    ++v37;
  }
  while (v37 != v36);
  uint64_t v33 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
  if (!v127) {
    goto LABEL_118;
  }
  CGFontGetParserFont();
  id Mutable = (__CFDictionary *)FPFontCopyFamilyName();
  uint64_t v81 = (__CFString *)FPFontCopyPath();
  CFAllocatorRef v82 = *v33;
  if (v81)
  {
    CFURLRef v83 = CFURLCreateWithFileSystemPath(*v33, v81, kCFURLPOSIXPathStyle, 0);
    CFIndex v84 = 2;
  }
  else
  {
    CFURLRef v83 = 0;
    CFIndex v84 = 1;
  }
  uint64_t v90 = (const void **)operator new(0x10uLL);
  *uint64_t v90 = @"NSFontFamilyAttribute";
  v90[1]  = @"NSCTFontFileURLAttribute";
  uint64_t v91 = (const void **)operator new(0x10uLL);
  *uint64_t v91 = Mutable;
  v91[1]  = v83;
  CFDictionaryRef v92 = CFDictionaryCreate(v82, v90, v91, v84, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CTFontDescriptorRef v93 = CTFontDescriptorCreateWithAttributes(v92);
  MatchingFontDescriptorsWithOptions  = (const __CFArray *)CTFontDescriptorCreateMatchingFontDescriptorsWithOptions((uint64_t)v93, 0, 1024);
  CFArrayRef v95 = MatchingFontDescriptorsWithOptions;
  if (MatchingFontDescriptorsWithOptions)
  {
    uint64_t v119 = v93;
    CFDictionaryRef v120 = v92;
    uint64_t v121 = v91;
    char v122 = v90;
    id v135 = 0;
    CFIndex v128 = CFArrayGetCount(MatchingFontDescriptorsWithOptions);
    if (v128)
    {
      CFIndex v96 = 0;
      while (1)
      {
        CFArrayRef v97 = v95;
        uint64_t v98 = (const __CTFontDescriptor *)CFArrayGetValueAtIndex(v95, v96);
        int v99 = (void *)MEMORY[0x185327A40](v98);
        *(double *)&id v154 = COERCE_DOUBLE(CTFontDescriptorCopyAttribute(v98, @"NSCTFontVariationAttribute"));
        CFDictionaryRef v100 = (const __CFDictionary *)atomic_exchange((atomic_ullong *volatile)&v154, 0);

        double v101 = v130;
        double v102 = 0.0;
        if (v130 != (uint64_t *)&v131)
        {
          do
          {
            unsigned int v103 = *((_DWORD *)v101 + 8);
            double v104 = *((double *)v101 + 5);
            double v105 = *((double *)v101 + 6);
            double v106 = *((double *)v101 + 7);
            unint64_t valuePtr = 0xAAAAAAAAAAAAAAAALL;
            TCFNumber::TCFNumber<unsigned int>(&valuePtr, v103);
            CFNumberRef v107 = (const __CFNumber *)CFDictionaryGetValue(v100, (const void *)atomic_load_explicit((atomic_ullong *volatile)&valuePtr, memory_order_acquire));
            if (v107)
            {
              *(double *)&id v154 = NAN;
              CFNumberGetValue(v107, kCFNumberDoubleType, &v154);
              double v105 = *(double *)&v154;
            }

            __int16 v108 = (uint64_t *)v101[1];
            if (v108)
            {
              do
              {
                uint64_t v109 = (uint64_t **)v108;
                __int16 v108 = (uint64_t *)*v108;
              }
              while (v108);
            }
            else
            {
              do
              {
                uint64_t v109 = (uint64_t **)v101[2];
                BOOL v9 = *v109 == v101;
                double v101 = (uint64_t *)v109;
              }
              while (!v9);
            }
            double v102 = v102 + v106 * (v104 - v105) * (v106 * (v104 - v105));
            double v101 = (uint64_t *)v109;
          }
          while (v109 != &v131);
        }
        double v110 = sqrt(v102);
        if (v110 < v38)
        {
          *(double *)&id v154 = COERCE_DOUBLE(v100);

          double v38 = v110;
          if (v110 == 0.0) {
            break;
          }
        }

        ++v96;
        CFArrayRef v95 = v97;
        if (v96 == v128) {
          goto LABEL_144;
        }
      }

      CFArrayRef v95 = v97;
    }
LABEL_144:
    CFDictionaryRef v111 = (const __CFDictionary *)atomic_load_explicit((atomic_ullong *volatile)&v135, memory_order_acquire);
    if (v111)
    {
      id MutableCopy = CFDictionaryCreateMutableCopy(v82, 0, v111);
      uint64_t v113 = v130;
      if (v130 != (uint64_t *)&v131)
      {
        do
        {
          unsigned int v114 = *((_DWORD *)v113 + 8);
          double v115 = *((double *)v113 + 6);
          *(double *)&id v154 = -3.72066208e-103;
          TCFNumber::TCFNumber<unsigned int>(&v154, v114);
          unint64_t valuePtr = 0xAAAAAAAAAAAAAAAALL;
          TCFNumber::TCFNumber<double>(&valuePtr, v115);
          double v116 = (void *)CFDictionaryGetValue(v111, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v154, memory_order_acquire));
          if (v116) {
            TCFRef<__CTFont const*>::Retain((atomic_ullong *)&valuePtr, v116);
          }
          CFDictionaryAddValue(MutableCopy, (const void *)atomic_load_explicit((atomic_ullong *volatile)&v154, memory_order_acquire), (const void *)atomic_load_explicit((atomic_ullong *volatile)&valuePtr, memory_order_acquire));

          uint64_t v117 = (uint64_t *)v113[1];
          if (v117)
          {
            do
            {
              int v118 = (uint64_t **)v117;
              uint64_t v117 = (uint64_t *)*v117;
            }
            while (v117);
          }
          else
          {
            do
            {
              int v118 = (uint64_t **)v113[2];
              BOOL v9 = *v118 == v113;
              uint64_t v113 = (uint64_t *)v118;
            }
            while (!v9);
          }
          uint64_t v113 = (uint64_t *)v118;
        }
        while (v118 != &v131);
      }
      TCFRef<__CTFont const*>::Retain((atomic_ullong *)&v133, MutableCopy);
    }
    uint64_t v91 = v121;
    uint64_t v90 = v122;
    CTFontDescriptorRef v93 = v119;
    CFDictionaryRef v92 = v120;
  }

  *uint64_t v124 = atomic_exchange((atomic_ullong *volatile)&v133, 0);
  operator delete(v91);
  operator delete(v90);

LABEL_157:
  std::__tree<std::__value_type<long,TGlyphDeltaListEntry>,std::__map_value_compare<long,std::__value_type<long,TGlyphDeltaListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TGlyphDeltaListEntry>>>::destroy(v131);
LABEL_158:

LABEL_159:
}

void CreateCodableVariationFromDefaultVariation(const __CFDictionary *a1@<X0>, const __CFDictionary *a2@<X1>, unint64_t *a3@<X8>)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a2)
    {
      id Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      CFIndex Count = CFDictionaryGetCount(a1);
      *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v7 + 1)  = 0xAAAAAAAAAAAAAAAALL;
      v42[14]  = v7;
      v42[13]  = v7;
      v42[12]  = v7;
      v42[11]  = v7;
      v42[10]  = v7;
      v42[9]  = v7;
      v42[8]  = v7;
      v42[7]  = v7;
      v42[6]  = v7;
      v42[5]  = v7;
      _OWORD v42[4] = v7;
      v42[3]  = v7;
      v42[2]  = v7;
      v42[1]  = v7;
      v42[0]  = v7;
      id keys = 0;
      long long v40 = 0;
      uint64_t v41 = 0;
      id v43 = v42;
      if (Count)
      {
        unint64_t v8 = Count;
        std::vector<long,TInlineBufferAllocator<long,30ul>>::__vallocate[abi:nn180100](&keys, Count);
        BOOL v9 = (char *)v40;
        bzero(v40, 8 * v8);
        long long v40 = &v9[8 * v8];
        *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v10 + 1)  = 0xAAAAAAAAAAAAAAAALL;
        long long v37 = v10;
        long long v36 = v10;
        long long v35 = v10;
        long long v34 = v10;
        long long v33 = v10;
        long long v32 = v10;
        long long v31 = v10;
        long long v30 = v10;
        long long v29 = v10;
        long long v27 = v10;
        long long v28 = v10;
        long long v25 = v10;
        long long v26 = v10;
        long long v23 = v10;
        long long v24 = v10;
        double v21 = 0;
        uint64_t v22 = 0;
        id values = 0;
        double v38 = &v23;
        std::vector<long,TInlineBufferAllocator<long,30ul>>::__vallocate[abi:nn180100](&values, v8);
        uint64_t v11 = (char *)v21;
        bzero(v21, 8 * v8);
        double v21 = &v11[8 * v8];
        CFDictionaryGetKeysAndValues(a1, (const void **)keys, (const void **)values);
        uint64_t v12 = 0;
        while (1)
        {
          if (CFEqual(keys[v12], &unk_1ED082E78)) {
            goto LABEL_14;
          }
          CFNumberRef Value = CFDictionaryGetValue(a2, keys[v12]);
          long long v14 = values;
          unint64_t v15 = values[v12];
          if (Value == v15) {
            goto LABEL_14;
          }
          if (Value) {
            BOOL v16 = v15 == 0;
          }
          else {
            BOOL v16 = 1;
          }
          if (v16) {
            goto LABEL_13;
          }
          if (!CFEqual(Value, v15)) {
            break;
          }
LABEL_14:
          if (v8 == ++v12) {
            goto LABEL_19;
          }
        }
        long long v14 = values;
LABEL_13:
        CFDictionarySetValue((CFMutableDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), keys[v12], v14[v12]);
        goto LABEL_14;
      }
      long long v37 = v7;
      long long v36 = v7;
      long long v35 = v7;
      long long v34 = v7;
      long long v33 = v7;
      long long v32 = v7;
      long long v31 = v7;
      long long v30 = v7;
      long long v29 = v7;
      long long v27 = v7;
      long long v28 = v7;
      long long v25 = v7;
      long long v26 = v7;
      long long v23 = v7;
      long long v24 = v7;
      double v21 = 0;
      uint64_t v22 = 0;
      id values = 0;
      double v38 = &v23;
      CFDictionaryGetKeysAndValues(a1, 0, 0);
LABEL_19:
      if (CFDictionaryGetCount((CFDictionaryRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire)))unint64_t v17 = atomic_exchange((atomic_ullong *volatile)&Mutable, 0); {
      else
      }
        unint64_t v17 = 0;
      *a3  = v17;
      p_id values = &values;
      std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&p_values);
      id values = (void **)&keys;
      std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](&values);
    }
    else
    {
      *a3  = (unint64_t)a1;
    }
  }
  else
  {
    *a3  = 0;
  }
}

uint64_t TGlyphIterator::DoGlyphInsertion(_DWORD *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (!*(void *)(*(void *)a1 + 152) && !*(void *)(*(void *)a1 + 584)) {
    return 0;
  }
  *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  v23[2]  = v5;
  v23[3]  = v5;
  v23[0]  = v5;
  v23[1]  = v5;
  uint64_t v6 = a2;
  double v21 = 0;
  uint64_t v22 = 0;
  uint64_t v20 = 0;
  long long v24 = v23;
  if (a2)
  {
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__vallocate[abi:nn180100](&v20, a2);
    uint64_t v7 = 0;
    unint64_t v8 = v21;
    do
    {
      v8[v7]  = bswap32(*(unsigned __int16 *)(a3 + v7 * 2)) >> 16;
      ++v7;
    }
    while (v6 != v7);
    BOOL v9 = &v8[v7];
    double v21 = v9;
    long long v10 = v20;
  }
  else
  {
    BOOL v9 = 0;
    long long v10 = 0;
  }
  unsigned int v11 = a1[2];
  if ((v11 & 0x80000000) != 0 && v10 != v9)
  {
    uint64_t v12 = (unsigned __int16 *)(v9 - 1);
    if (v9 - 1 > v10)
    {
      CFIndex v13 = v10 + 1;
      do
      {
        unsigned __int16 v14 = *(v13 - 1);
        *((_WORD *)v13 - 1)  = *v12;
        *v12--  = v14;
      }
      while (v13++ < v12);
    }
  }
  BOOL v16 = a1 + 12;
  uint64_t v17 = TRunGlue::DoGlyphInsertion(*(TRunGlue **)a1, v10, (unsigned __int16)((v9 - v10) >> 1), v11 >> 31, 0, *((void *)a1 + 6), *((void *)a1 + 6), 0, 0);
  if (v17)
  {
    if ((a1[2] & 0x80000000) != 0)
    {
      *((void *)a1 + 2) += v6;
      *((void *)a1 + 4) += v6;
    }
    else
    {
      *((void *)a1 + 3) += v6;
      BOOL v16 = a1 + 10;
    }
    *v16 += v6;
  }
  uint64_t v19 = &v20;
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v19);
  return v17;
}

uint64_t TGlyphIterator::ReplaceWithGlyphs(uint64_t a1, uint64_t a2, unsigned __int16 *a3, uint64_t a4)
{
  uint64_t v4 = a2;
  if (a2)
  {
    unint64_t v8 = *(TRunGlue **)(a1 + 48);
    v25[0]  = *(TRunGlue **)a1;
    v25[1]  = v8;
    TRunGlue::SetGlyphID<true>(v25[0], (uint64_t)v8, bswap32(*a3) >> 16);
    if (v4 != 1)
    {
      BOOL v9 = a3 + 1;
      uint64_t v10 = *(void *)(a1 + 48);
      uint64_t v11 = *(void *)(a1 + 72);
      *(void *)(a1 + 72)  = 0;
      if (!TGlyphIterator::Next((TGlyphIterator *)a1, 1)) {
        goto LABEL_7;
      }
      uint64_t v12 = *(void *)(a1 + 48);
      uint64_t v13 = v12 + ~v10;
      uint64_t v14 = v10 + ~v12;
      if (*(int *)(a1 + 8) >= 0) {
        uint64_t v14 = v13;
      }
      if (v14 < (v4 - 1))
      {
LABEL_7:
        *(void *)(a1 + 72)  = v11;
        *(void *)(a1 + 48)  = v10;
        if (!TGlyphIterator::DoGlyphInsertion((_DWORD *)a1, (int)v4 - 1, (uint64_t)v9)) {
          return 0;
        }
        uint64_t v15 = v4;
        uint64_t v4 = 1;
        std::function<void ()(CFRange,long)>::operator()(a4, v10, 1, v15);
        return v4;
      }
      uint64_t v24 = v11;
      TRunGlue::TGlyph::clearSafeToBreakAfter((uint64_t)v25);
      BOOL v16 = *(TRunGlue **)a1;
      uint64_t v17 = v10 + *(int *)(a1 + 8);
      uint64_t v18 = (v4 - 1);
      do
      {
        unsigned int v19 = *v9++;
        TRunGlue::SetGlyphID<true>(v16, v17, bswap32(v19) >> 16);
        GlyphProps  = TRunGlue::GetGlyphProps(v16, v17);
        TRunGlue::SetGlyphProps(v16, v17, GlyphProps & 0xFFFFEFDF);
        uint64_t v21 = *(int *)(a1 + 8);
        v17 += v21;
        --v18;
      }
      while (v18);
      *(void *)(a1 + 72)  = v24;
      *(void *)(a1 + 48)  = v10;
      if ((int)v21 >= 0) {
        uint64_t v22 = 0;
      }
      else {
        uint64_t v22 = (v4 - 1);
      }
      std::function<void ()(CFRange,long)>::operator()(a4, v10 - v22, v4, v4);
    }
    return 1;
  }
  return v4;
}

uint64_t TLCARTable::GetLigatureCaretPositions(TLCARTable *this, uint64_t a2, __int16 *a3, uint64_t a4, unsigned __int16 *a5)
{
  long long v5 = *(_DWORD **)this;
  if (**(_DWORD **)this != 256) {
    return 0;
  }
  unsigned int v6 = bswap32(*((unsigned __int16 *)v5 + 2)) >> 16;
  if (v6 > 1) {
    return 0;
  }
  if (a5) {
    *a5  = v6;
  }
  *(void *)&long long v12 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v12 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  long long v26 = v12;
  long long v27 = v12;
  uint64_t v13 = (SFNTLookupTable *)*((void *)this + 1);
  uint64_t v24 = TAATLookupTable::BadTable;
  uint64_t v25 = 0;
  *((void *)&v27 + 1)  = 0;
  unint64_t v28 = 0xAAAAAAAAAAAAFFFFLL;
  TAATLookupTable::SetTable((uint64_t)&v24, (const SFNTLookupTable *)((char *)v5 + 6), v13);
  unint64_t v29 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v14 = v24;
  uint64_t v15 = (TAATLookupTable *)((char *)&v24 + (v25 >> 1));
  if (v25) {
    uint64_t v14 = *(uint64_t (**)(TAATLookupTable *, unsigned __int16, unint64_t *))(*(void *)v15
  }
                                                                                            + v24);
  uint64_t result = v14(v15, a2, &v29);
  if (result)
  {
    unint64_t v16 = *((void *)this + 1);
    uint64_t v17 = (unsigned __int16 *)(*(void *)this + (bswap32(*(unsigned __int16 *)result) >> 16));
    uint64_t v18 = v17 + 1;
    if ((unint64_t)(v17 + 1) > v16) {
      return 0;
    }
    uint64_t result = bswap32(*v17) >> 16;
    unsigned int v19 = &v18[result];
    if (v19 < v18 || (unint64_t)v19 > v16)
    {
      unint64_t v21 = (unint64_t)(v17 + 2) <= v16 ? (v16 - (unint64_t)v18) >> 1 : 0;
      if (v21 != result) {
        return 0;
      }
    }
    if (result >= a4) {
      uint64_t v22 = a4;
    }
    else {
      uint64_t v22 = result;
    }
    if (v22 >= 1)
    {
      do
      {
        unsigned int v23 = *v18++;
        *a3++  = bswap32(v23) >> 16;
        --v22;
      }
      while (v22);
      return bswap32(*v17) >> 16;
    }
  }
  return result;
}

uint64_t TLCARTable::GetLigatureCaretCount(TLCARTable *this, uint64_t a2)
{
  CFDictionaryRef v2 = *(_DWORD **)this;
  if (**(_DWORD **)this != 256 || bswap32(*((unsigned __int16 *)v2 + 2)) >> 16 > 1) {
    return 0;
  }
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  long long v19 = v6;
  long long v20 = v6;
  uint64_t v7 = (SFNTLookupTable *)*((void *)this + 1);
  uint64_t v17 = TAATLookupTable::BadTable;
  uint64_t v18 = 0;
  *((void *)&v20 + 1)  = 0;
  unint64_t v21 = 0xAAAAAAAAAAAAFFFFLL;
  TAATLookupTable::SetTable((uint64_t)&v17, (const SFNTLookupTable *)((char *)v2 + 6), v7);
  unint64_t v22 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v8 = v17;
  BOOL v9 = (TAATLookupTable *)((char *)&v17 + (v18 >> 1));
  if (v18) {
    unint64_t v8 = *(uint64_t (**)(TAATLookupTable *, unsigned __int16, unint64_t *))(*(void *)v9
  }
                                                                                           + v17);
  uint64_t result = v8(v9, a2, &v22);
  if (result)
  {
    unint64_t v10 = *((void *)this + 1);
    uint64_t v11 = (unsigned __int16 *)(*(void *)this + (bswap32(*(unsigned __int16 *)result) >> 16));
    long long v12 = v11 + 1;
    if ((unint64_t)(v11 + 1) > v10) {
      return 0;
    }
    uint64_t result = bswap32(*v11) >> 16;
    unint64_t v13 = (unint64_t)&v12[result];
    if (v13 < (unint64_t)v12 || v13 > v10)
    {
      unint64_t v15 = (v10 - (unint64_t)v12) >> 1;
      unint64_t v16 = (unint64_t)(v11 + 2) <= v10 ? v15 : 0;
      if (v16 != result) {
        return 0;
      }
    }
  }
  return result;
}

void LayerRecordsForGlyph(const __CFData *a1@<X0>, unsigned int a2@<W1>, void *a3@<X8>)
{
  *a3  = 0;
  a3[1]  = 0;
  a3[2]  = 0;
  if (!a1) {
    return;
  }
  BytePtr  = CFDataGetBytePtr(a1);
  uint64_t v7 = CFDataGetBytePtr(a1);
  if (!v7) {
    return;
  }
  unint64_t v8 = (unint64_t)&v7[CFDataGetLength(a1)];
  if ((unint64_t)(BytePtr + 14) > v8) {
    return;
  }
  BOOL v9 = (unsigned __int16 *)&BytePtr[bswap32(*((_DWORD *)BytePtr + 1))];
  unsigned int v10 = *((unsigned __int16 *)BytePtr + 1);
  unint64_t v11 = __rev16(v10);
  unint64_t v12 = (unint64_t)&v9[3 * v11];
  if (v12 < (unint64_t)v9 || v12 > v8)
  {
    if ((unint64_t)(v9 + 3) > v8) {
      unint64_t v14 = 0;
    }
    else {
      unint64_t v14 = (v8 - (unint64_t)v9) / 6;
    }
    if (v14 != v11 || v10 == 0) {
      return;
    }
  }
  else if (!*((_WORD *)BytePtr + 1))
  {
    return;
  }
  unint64_t v16 = &v9[3 * v11];
  while (1)
  {
    unint64_t v17 = v11 >> 1;
    uint64_t v18 = &v9[3 * (v11 >> 1)];
    unsigned int v19 = bswap32(*v18) >> 16;
    if (v19 >= a2) {
      break;
    }
    BOOL v9 = v18 + 3;
    unint64_t v17 = v11 + ~v17;
LABEL_22:
    unint64_t v11 = v17;
    if (!v17) {
      return;
    }
  }
  if (v19 > a2)
  {
    unint64_t v16 = &v9[3 * (v11 >> 1)];
    goto LABEL_22;
  }
  long long v20 = &v9[3 * (v11 >> 1)];
  if (v11 >= 2)
  {
    long long v20 = v9;
    do
    {
      unint64_t v21 = v17 >> 1;
      unint64_t v22 = &v20[3 * (v17 >> 1)];
      unsigned int v24 = *v22;
      unsigned int v23 = v22 + 3;
      v17 += ~(v17 >> 1);
      if (bswap32(v24) >> 16 >= a2) {
        unint64_t v17 = v21;
      }
      else {
        long long v20 = v23;
      }
    }
    while (v17);
  }
  if (v16 != v18 + 3)
  {
    unint64_t v25 = 0xAAAAAAAAAAAAAAABLL * (v16 - (v18 + 3));
    unint64_t v16 = v18 + 3;
    do
    {
      unint64_t v26 = v25 >> 1;
      long long v27 = &v16[3 * (v25 >> 1)];
      unsigned int v29 = *v27;
      unint64_t v28 = v27 + 3;
      v25 += ~(v25 >> 1);
      if (bswap32(v29) >> 16 > a2) {
        unint64_t v25 = v26;
      }
      else {
        unint64_t v16 = v28;
      }
    }
    while (v25);
  }
  if (v20 != v16 && v20[2])
  {
    long long v30 = &BytePtr[bswap32(*((_DWORD *)BytePtr + 2))];
    unint64_t v31 = __rev16(v20[2]);
    long long v32 = std::__allocate_at_least[abi:nn180100]<std::allocator<float>>(v31);
    *a3  = v32;
    a3[1]  = v32;
    a3[2]  = &v32[v33];
    unint64_t v34 = bswap32(v20[1]) >> 16;
    unint64_t v35 = v34 + v31;
    uint64_t v52 = BytePtr;
    do
    {
      long long v36 = &v30[4 * v34];
      if (BytePtr > v36 || (unint64_t)(v36 + 4) > v8) {
        break;
      }
      int v38 = *(unsigned __int16 *)v36;
      int v39 = *((unsigned __int16 *)v36 + 1);
      unint64_t v40 = a3[2];
      if ((unint64_t)v32 >= v40)
      {
        unint64_t v42 = v8;
        id v43 = v30;
        uint64_t v44 = (_DWORD *)*a3;
        uint64_t v45 = ((uint64_t)v32 - *a3) >> 2;
        unint64_t v46 = v45 + 1;
        if ((unint64_t)(v45 + 1) >> 62) {
          abort();
        }
        uint64_t v47 = v40 - (void)v44;
        if (v47 >> 1 > v46) {
          unint64_t v46 = v47 >> 1;
        }
        if ((unint64_t)v47 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v48 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v48 = v46;
        }
        if (v48) {
          unint64_t v48 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>(v48);
        }
        else {
          uint64_t v49 = 0;
        }
        unsigned int v50 = (_DWORD *)(v48 + 4 * v45);
        *unsigned int v50 = bswap32(v39 | (v38 << 16));
        uint64_t v41 = v50 + 1;
        long long v30 = v43;
        if (v32 != v44)
        {
          do
          {
            int v51 = *--v32;
            *--unsigned int v50 = v51;
          }
          while (v32 != v44);
          long long v32 = (_DWORD *)*a3;
        }
        *a3  = v50;
        a3[1]  = v41;
        a3[2]  = v48 + 4 * v49;
        unint64_t v8 = v42;
        if (v32) {
          operator delete(v32);
        }
        BytePtr  = v52;
      }
      else
      {
        *long long v32 = bswap32(v39 | (v38 << 16));
        uint64_t v41 = v32 + 1;
      }
      a3[1]  = v41;
      ++v34;
      long long v32 = v41;
    }
    while (v34 < v35);
  }
}

CFDataRef EnumerateGlyphsWithLayerRecords(const __CFData *result, uint64_t a2)
{
  if (result)
  {
    if (a2)
    {
      CFDataRef v3 = result;
      BytePtr  = CFDataGetBytePtr(result);
      uint64_t result = (const __CFData *)CFDataGetBytePtr(v3);
      if (result)
      {
        CFDataRef v5 = result;
        uint64_t result = (const __CFData *)CFDataGetLength(v3);
        unint64_t v6 = (unint64_t)result + (void)v5;
        if (BytePtr + 14 <= (const UInt8 *)result + (unint64_t)v5)
        {
          uint64_t v7 = bswap32(*((_DWORD *)BytePtr + 1));
          unint64_t v8 = &BytePtr[v7];
          uint64_t v9 = __rev16(*((unsigned __int16 *)BytePtr + 1));
          unint64_t v10 = (unint64_t)&BytePtr[6 * v9 + v7];
          if (v10 < (unint64_t)&BytePtr[v7] || v10 > v6)
          {
            if ((unint64_t)(v8 + 6) > v6)
            {
              unint64_t v12 = 0;
              if (!*((_WORD *)BytePtr + 1)) {
                return result;
              }
            }
            else
            {
              unint64_t v12 = (v6 - (unint64_t)v8) / 6;
              if (!*((_WORD *)BytePtr + 1)) {
                return result;
              }
            }
            if (v12 != v9) {
              return result;
            }
          }
          else if (!*((_WORD *)BytePtr + 1))
          {
            return result;
          }
          unint64_t v13 = &BytePtr[v7 + 4];
          do
          {
            if (*(_WORD *)v13) {
              uint64_t result = (const __CFData *)(*(uint64_t (**)(uint64_t, void, uint64_t))(a2 + 16))(a2, bswap32(*((unsigned __int16 *)v13 - 2)) >> 16, 1);
            }
            v13 += 6;
            --v9;
          }
          while (v9);
        }
      }
    }
  }
  return result;
}

void TSampleManagerImp::CopySampleLettersSpanningCharacterSet(const __CFArray *a1, atomic_ullong *a2, unsigned int a3, uint64_t a4, void *key)
{
  id v8 = (id)0xAAAAAAAAAAAAAAAALL;
  TSampleManagerImp::CopySampleLettersForLanguage(key, a2, a3, &v8);
  SampleLettersSpanningCharacterSet(a1, (const __CFCharacterSet *)atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire), a4);
  id v7 = v8;
}

void TSampleManagerImp::CopySampleLettersForLanguage(void *key@<X2>, atomic_ullong *a2@<X0>, unsigned int a3@<W1>, void *a4@<X8>)
{
  CFDictionaryRef ValueAtIndex = key;
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  v26[1]  = -1431655766;
  long long v27 = key;
  v26[0]  = a3;
  if (!key)
  {
    CFArrayRef v7 = (const __CFArray *)(id)atomic_load_explicit(a2, memory_order_acquire);
    CFArrayRef v8 = v7;
    if (v7) {
      CFDictionaryRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(v7, 0);
    }
    else {
      CFDictionaryRef ValueAtIndex = 0;
    }
  }
  if (a3 > 2 || (CFDictionaryRef v9 = (const __CFDictionary *)*off_1E5290130[a3]) == 0)
  {
    *a4  = 0;
    return;
  }
  if (_MergedGlobals_31
    && !CFDictionaryContainsKey(v9, ValueAtIndex)
    && CFDictionaryContainsKey((CFDictionaryRef)_MergedGlobals_31, ValueAtIndex))
  {
    CFNumberRef Value = CFDictionaryGetValue((CFDictionaryRef)_MergedGlobals_31, ValueAtIndex);
    unint64_t v25 = (void *)CFDictionaryGetValue(v9, Value);
    TSampleManagerImp::CopySampleLettersForLanguage(CTFontSampleString,__CFString const*)const::$_0::operator()((unint64_t *)&v29, (uint64_t)v26, v25);
    *a4  = atomic_exchange((atomic_ullong *volatile)&v29, 0);

    return;
  }
  *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v10 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  v32[14]  = v10;
  v32[13]  = v10;
  v32[12]  = v10;
  v32[11]  = v10;
  v32[10]  = v10;
  v32[9]  = v10;
  v32[8]  = v10;
  v32[7]  = v10;
  v32[6]  = v10;
  v32[5]  = v10;
  v32[3]  = v10;
  v32[4]  = v10;
  v32[1]  = v10;
  _OWORD v32[2] = v10;
  v32[0]  = v10;
  CFIndex Count = CFDictionaryGetCount(v9);
  id v29 = 0;
  long long v30 = 0;
  uint64_t v31 = 0;
  uint64_t v33 = v32;
  std::vector<long,TInlineBufferAllocator<long,30ul>>::__vallocate[abi:nn180100](&v29, Count + 1);
  unint64_t v12 = (char *)v30;
  bzero(v30, 8 * Count + 8);
  long long v30 = &v12[8 * Count + 8];
  *(void *)id v29 = @"zxx";
  CFDictionaryGetKeysAndValues(v9, (const void **)v29 + 1, 0);
  CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  unint64_t v14 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
  CFArrayRef v15 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)v29, ((unsigned char *)v30 - (unsigned char *)v29) >> 3, MEMORY[0x1E4F1D510]);
  id values = ValueAtIndex;
  CFArrayRef v16 = CFArrayCreate(v13, (const void **)&values, 1, v14);
  CFArrayRef v17 = CFBundleCopyLocalizationsForPreferences(v15, v16);
  CFArrayRef v18 = v17;
  if (!v18)
  {

LABEL_18:
    *a4  = 0;
    goto LABEL_19;
  }
  CFArrayRef v19 = v18;
  CFIndex v20 = CFArrayGetCount(v18);

  if (!v20) {
    goto LABEL_18;
  }
  unint64_t v21 = (__CFString *)CFArrayGetValueAtIndex(v17, 0);
  if (v21 == @"zxx") {
    goto LABEL_18;
  }
  unint64_t v22 = v21;
  if (v21)
  {
    if (CFEqual(v21, @"zxx")) {
      goto LABEL_18;
    }
  }
  unsigned int v23 = (void *)CFDictionaryGetValue(v9, v22);
  TSampleManagerImp::CopySampleLettersForLanguage(CTFontSampleString,__CFString const*)const::$_0::operator()((unint64_t *)&values, (uint64_t)v26, v23);
  *a4  = atomic_exchange((atomic_ullong *volatile)&values, 0);

LABEL_19:
  id values = &v29;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&values);
}

void SampleLettersSpanningCharacterSet(const __CFArray *a1, const __CFCharacterSet *a2, uint64_t a3)
{
  id v10 = (id)0xAAAAAAAAAAAAAAAALL;
  LettersSpanningCharacterSet((const __CFArray *)&v10, a2, a3);
  CountOfLetters  = GetCountOfLetters((const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire));
  if (CountOfLetters
    && ((uint64_t v6 = CountOfLetters, v7 = GetCountOfLetters(a2), v7 >= 0) ? (v8 = v7) : (v8 = v7 + 1), v6 > v8 >> 1))
  {
    unint64_t v9 = atomic_exchange((atomic_ullong *volatile)&v10, 0);
  }
  else
  {
    unint64_t v9 = 0;
  }
  *(void *)a1  = v9;
}

void TSampleManagerImp::CopyPreferredSampleLetters(const __CFArray *a1, atomic_ullong *a2, int a3, unsigned int a4, CFArrayRef theArray, uint64_t a6, const __CFArray *a7, void **a8)
{
  if (!theArray || CFArrayGetCount(theArray) < 1) {
    goto LABEL_12;
  }
  unsigned int v24 = a8;
  CFArrayRef v16 = CFBundleCopyLocalizationsForPreferences(theArray, a7);
  CFArrayRef v17 = v16;
  if (!v16 || (CFIndex Count = CFArrayGetCount(v16)) == 0)
  {
LABEL_11:

LABEL_12:
    *(void *)a1  = 0;
    return;
  }
  CFIndex v19 = Count;
  CFIndex v20 = 0;
  while (1)
  {
    CFDictionaryRef ValueAtIndex = (__CFString *)CFArrayGetValueAtIndex(v17, v20);
    *(void *)a1  = 0xAAAAAAAAAAAAAAAALL;
    TSampleManagerImp::CopySampleLettersSpanningCharacterSet(a1, a2, a4, a6, ValueAtIndex);
    if (atomic_load_explicit((atomic_ullong *volatile)a1, memory_order_acquire)) {
      break;
    }

    SampleLettersForLanguage((atomic_ullong *)&v25, a3, a4, a6, ValueAtIndex);
    CFCharacterSetRef v22 = (const __CFCharacterSet *)atomic_exchange((atomic_ullong *volatile)&v25, 0);

    if (v22)
    {
      *(void *)a1  = 0xAAAAAAAAAAAAAAAALL;
      SampleLettersSpanningCharacterSet(a1, v22, a6);
      if (atomic_load_explicit((atomic_ullong *volatile)a1, memory_order_acquire))
      {
        if (v24)
        {
          unsigned int v23 = *v24;
          if (*v24 != ValueAtIndex)
          {
            _OWORD *v24 = ValueAtIndex;
          }
        }
        goto LABEL_20;
      }
    }
    if (v19 == ++v20) {
      goto LABEL_11;
    }
  }
  if (v24)
  {
    CFCharacterSetRef v22 = (const __CFCharacterSet *)*v24;
    if (*v24 != ValueAtIndex)
    {
      _OWORD *v24 = ValueAtIndex;
LABEL_20:
    }
  }
}

void SampleLettersForLanguage(atomic_ullong *a1, int a2, int a3, uint64_t a4, CFStringRef theString)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v10 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  v35[1]  = v10;
  v35[0]  = v10;
  uint64_t v34 = 0;
  int64x2_t v33 = 0uLL;
  long long v36 = v35;
  if (!CFStringGetCStringPtr(theString, 0x600u))
  {
    CFIndex Length = CFStringGetLength(theString);
    CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x600u);
    CFIndex v13 = MaximumSizeForEncoding + 1;
    unint64_t v14 = (char *)v33.i64[0];
    if ((unint64_t)(MaximumSizeForEncoding + 1) <= v33.i64[1] - v33.i64[0])
    {
      if ((unint64_t)(MaximumSizeForEncoding + 1) < v33.i64[1] - v33.i64[0]) {
        v33.i64[1]  = v33.i64[0] + v13;
      }
    }
    else
    {
      std::vector<char,TInlineBufferAllocator<char,30ul>>::__append(&v33, MaximumSizeForEncoding + 1 - (v33.i64[1] - v33.i64[0]));
      unint64_t v14 = (char *)v33.i64[0];
    }
    if (!CFStringGetCString(theString, v14, v13, 0x600u) || !v33.i64[0]) {
      goto LABEL_30;
    }
  }
  HIDWORD(__s.data)  = 0;
  if ((a3 - 1) <= 1)
  {
    LODWORD(__s.data)  = -1431655766;
    uscript_getCode();
    HIDWORD(__s.info)  = -1431655766;
    SampleString  = uscript_getSampleString();
    CFAllocatorRef v20 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    id Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    CFStringRef v22 = CFStringCreateWithCharacters(v20, (const UniChar *)&__s.info + 2, SampleString);
    if (v22)
    {
      CFStringRef v23 = v22;
      CFArrayAppendValue(Mutable, v22);
      if (a3 == 1)
      {
        if (uscript_isCased())
        {
          id MutableCopy = CFStringCreateMutableCopy(v20, 0, v23);
          if (MutableCopy)
          {
            id v25 = MutableCopy;
            CFStringLowercase(MutableCopy, 0);
            if (!CFEqual(v25, v23)) {
              CFArrayAppendValue(Mutable, v25);
            }
            CFRelease(v25);
          }
        }
      }
      CFRelease(v23);
    }
    id v28 = CFArrayCreateMutable(v20, 0, MEMORY[0x1E4F1D510]);
    CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v28, memory_order_acquire), Mutable);
    __s.isa  = (void *)atomic_exchange((atomic_ullong *volatile)&v28, 0);
    *a1  = atomic_exchange((atomic_ullong *volatile)&__s, 0);

    goto LABEL_31;
  }
  uint64_t v15 = ulocdata_open();
  id v29 = (void (*)(void))MEMORY[0x1E4FBA6B8];
  ExemplarSet  = (void *)ulocdata_getExemplarSet();
  id v28 = ExemplarSet;
  if (!a3)
  {
    __s.isa  = (void *)0xAAAAAAAAAAAAAAAALL;
    DigitsStringForLanguage(&__s, theString);
    if (atomic_load_explicit((atomic_ullong *volatile)&__s, memory_order_acquire))
    {
      CFStringRef explicit = (const __CFString *)atomic_load_explicit((atomic_ullong *volatile)&__s, memory_order_acquire);
      CFIndex v18 = CFStringGetLength((CFStringRef)atomic_load_explicit((atomic_ullong *volatile)&__s, memory_order_acquire));
      __s.CFIndex length = (uint64_t)&unk_1ED060590;
      uint64_t v31 = &v28;
      p_CFIndex length = &__s.length;
      EnumerateCharactersInRange(explicit, 0, v18, (uint64_t)&__s.length);
      std::__function::__value_func<void ()(CFRange,unsigned int,BOOL *)>::~__value_func[abi:nn180100](&__s.length);
    }

    ExemplarSet  = v28;
  }
  *a1  = 0xAAAAAAAAAAAAAAAALL;
  SampleLettersFromUSet(a1, a2, a3, a4, (uint64_t)ExemplarSet, (int *)&__s.data + 1, theString);
  unint64_t v26 = atomic_load_explicit(a1, memory_order_acquire);
  if (!v26) {

  }
  id v27 = v28;
  id v28 = 0;
  if (v27) {
    v29();
  }
  if (v15) {
    ulocdata_close();
  }
  if (!v26) {
LABEL_30:
  }
    *a1  = 0;
LABEL_31:
  id v28 = &v33;
  std::vector<char,TInlineBufferAllocator<char,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v28);
}

void TSampleManagerImp::Copy(atomic_ullong *a1@<X0>, int a2@<W1>, atomic_ullong *a3@<X2>, unsigned int a4@<W3>, const __CFArray *a5@<X4>, void **a6@<X5>, unint64_t *a7@<X8>)
{
  uint64_t v103 = *MEMORY[0x1E4F143B8];
  if (a6) {
    *a6  = &stru_1ED0677F8;
  }
  id v96 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(uint64_t *__return_ptr, atomic_ullong *))(*a3 + 184))(&v98.info, a3);
  TCFMutableCharacterSet::TCFMutableCharacterSet((TCFMutableCharacterSet *)&v96, (const __CFCharacterSet *)atomic_load_explicit(&v98.info, memory_order_acquire));

  if (!atomic_load_explicit((atomic_ullong *volatile)&v96, memory_order_acquire))
  {
    *a7  = 0;
    goto LABEL_84;
  }
  id v14 = (id)atomic_load_explicit(a3 + 12, memory_order_acquire);
  uint64_t v15 = v14;
  if (v14)
  {
    CFArrayRef v16 = a7;
    CFDictionaryRef v17 = (const __CFDictionary *)qword_1EB2CE808;
    id v18 = v14;
    CFIndex v19 = v18;
    if (v17)
    {
      CFNumberRef Value = (void *)CFDictionaryGetValue(v17, v18);

      a7  = v16;
      if (Value)
      {
        TSampleManagerImp::CopySampleLettersSpanningCharacterSet((const __CFArray *)&v98.info, a1, a4, atomic_load_explicit((atomic_ullong *volatile)&v96, memory_order_acquire), Value);
        *CFArrayRef v16 = atomic_exchange(&v98.info, 0);

        id v21 = v15;
        goto LABEL_83;
      }
    }
    else
    {

      a7  = v16;
    }
  }
  int v85 = a2;

  id v95 = (id)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(id *__return_ptr, atomic_ullong *))(*a3 + 368))(&v95, a3);
  if (!a5 || !CFArrayGetCount(a5)) {
    goto LABEL_17;
  }
  CFArrayRef v22 = CFLocaleCopyPreferredLanguages();
  if (v22 == a5)
  {

    goto LABEL_17;
  }
  CFArrayRef v23 = v22;
  if (!v22)
  {
    unint64_t v26 = 0;
LABEL_21:

    goto LABEL_22;
  }
  int v24 = CFEqual(a5, v22);

  if (v24)
  {
LABEL_17:
    v98.info  = 0xAAAAAAAAAAAAAAAALL;
    TSampleManagerImp::CopyPreferredSampleLetters((const __CFArray *)&v98.info, a1, a2, a4, (CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v95, memory_order_acquire), atomic_load_explicit((atomic_ullong *volatile)&v96, memory_order_acquire), (const __CFArray *)atomic_load_explicit(a1, memory_order_acquire), a6);
    if (atomic_load_explicit(&v98.info, memory_order_acquire))
    {
      *a7  = atomic_exchange(&v98.info, 0);
      info  = (void *)v98.info;
      goto LABEL_82;
    }
    unint64_t v26 = (void *)v98.info;
    goto LABEL_21;
  }
LABEL_22:
  id v94 = (id)0xAAAAAAAAAAAAAAAALL;
  TCFMutableArray::TCFMutableArray((TCFMutableArray *)&v94, (CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v95, memory_order_acquire));
  (*(void (**)(id *__return_ptr, atomic_ullong *))(*a3 + 336))(&v93, a3);
  TCFMutableArray::AppendArray<TCFRef<__CFArray const*>>((atomic_ullong *)&v94, (atomic_ullong *)&v93);

  v98.info  = 0xAAAAAAAAAAAAAAAALL;
  TBaseFont::ShapingLanguages((TBaseFont *)a3, 1, &v98.info);
  id v27 = (id)atomic_load_explicit(&v98.info, memory_order_acquire);
  if (!v27)
  {
LABEL_25:

    goto LABEL_26;
  }
  id v28 = v27;
  CFIndex Count = CFArrayGetCount((CFArrayRef)v27);

  if (Count)
  {
    id v92 = (id)atomic_load_explicit(&v98.info, memory_order_acquire);
    TCFMutableArray::AppendArray<TCFRef<__CFArray const*>>((atomic_ullong *)&v94, (atomic_ullong *)&v92);
    id v27 = v92;
    goto LABEL_25;
  }
LABEL_26:

  id v91 = (id)0xAAAAAAAAAAAAAAAALL;
  TCFMutableArray::TCFMutableArray((TCFMutableArray *)&v91, a5);
  id v90 = (id)atomic_load_explicit((atomic_ullong *volatile)&v95, memory_order_acquire);
  TCFMutableArray::AppendArray<TCFRef<__CFArray const*>>((atomic_ullong *)&v91, (atomic_ullong *)&v90);

  id v89 = (id)atomic_load_explicit(a1, memory_order_acquire);
  TCFMutableArray::AppendArray<TCFRef<__CFArray const*>>((atomic_ullong *)&v91, (atomic_ullong *)&v89);

  v98.info  = 0xAAAAAAAAAAAAAAAALL;
  TSampleManagerImp::CopyPreferredSampleLetters((const __CFArray *)v87, a1, a2, a4, (CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v94, memory_order_acquire), atomic_load_explicit((atomic_ullong *volatile)&v96, memory_order_acquire), (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v91, memory_order_acquire), a6);
  v98.info  = atomic_exchange((atomic_ullong *volatile)v87, 0);

  if (atomic_load_explicit(&v98.info, memory_order_acquire))
  {
    unint64_t v30 = atomic_exchange(&v98.info, 0);
LABEL_79:
    *a7  = v30;
    unsigned int v60 = (void *)v98.info;
LABEL_80:

    goto LABEL_81;
  }

  unint64_t v101 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v102 = 0xAAAAAAAAAAAAAAAALL;
  if (TBaseFont::GetOS2UnicodeRanges((TBaseFont *)a3, &v101, 0) && (v102 & 0x40000) != 0)
  {
    TSampleManagerImp::CopySampleLettersForLanguage(@"braille", a1, a4, &v98.info);
    goto LABEL_78;
  }
  CFIndex v84 = a7;
  if (a5)
  {
    CFIndex v31 = CFArrayGetCount(a5);
    if (v31)
    {
      CFIndex v32 = v31;
      for (CFIndex i = 0; i != v32; ++i)
      {
        CFDictionaryRef ValueAtIndex = (__CFString *)CFArrayGetValueAtIndex(a5, i);
        SampleLettersForLanguage(&v98.info, a2, a4, atomic_load_explicit((atomic_ullong *volatile)&v96, memory_order_acquire), ValueAtIndex);
        CFCharacterSetRef v35 = (const __CFCharacterSet *)atomic_exchange(&v98.info, 0);

        if (v35)
        {
          v98.info  = 0xAAAAAAAAAAAAAAAALL;
          SampleLettersSpanningCharacterSet((const __CFArray *)&v98.info, v35, atomic_load_explicit((atomic_ullong *volatile)&v96, memory_order_acquire));
          if (atomic_load_explicit(&v98.info, memory_order_acquire))
          {
            if (a6)
            {
              uint64_t v59 = *a6;
              if (*a6 != ValueAtIndex)
              {
                *a6  = ValueAtIndex;
              }
            }
            *CFIndex v84 = atomic_exchange(&v98.info, 0);

            unsigned int v60 = v35;
            goto LABEL_80;
          }
        }
      }
    }
  }
  *(void *)&long long v36 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v36 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)double v87 = v36;
  long long v88 = v36;
  atomic_load_explicit((atomic_ullong *volatile)&v96, memory_order_acquire);
  CFCharacterSetInitInlineBuffer();
  a7  = v84;
  if (a4 <= 2)
  {
    uint64_t v37 = (CFDictionaryRef *)off_1E5290130[a4];
    CFDictionaryRef v38 = *v37;
    if (*v37)
    {
      CFIndex v39 = CFDictionaryGetCount(*v37);
      if (v39)
      {
        CFIndex v40 = v39;
        *(void *)&long long v41 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v41 + 1)  = 0xAAAAAAAAAAAAAAAALL;
        v99[14]  = v41;
        v99[13]  = v41;
        v99[12]  = v41;
        v99[11]  = v41;
        v99[10]  = v41;
        v99[9]  = v41;
        v99[8]  = v41;
        v99[7]  = v41;
        v99[6]  = v41;
        v99[5]  = v41;
        v99[4]  = v41;
        v99[3]  = v41;
        v99[2]  = v41;
        v99[1]  = v41;
        v99[0]  = v41;
        memset(&v98.info, 0, 24);
        CFDictionaryRef v100 = v99;
        std::vector<long,TInlineBufferAllocator<long,30ul>>::__vallocate[abi:nn180100](&v98.info, v39);
        data  = v98.data;
        bzero(v98.data, 8 * v40);
        v98.data  = &data[8 * v40];
        CFDictionaryGetKeysAndValues(v38, 0, (const void **)v98.info);
        id v43 = CFDictionaryGetValue(v38, @"emoji");
        if (v43)
        {
          uint64_t v44 = (char *)v98.info;
          if ((char *)v98.info != v98.data)
          {
            while (*(const void **)v44 != v43)
            {
              v44 += 8;
              if (v44 == v98.data)
              {
                uint64_t v44 = v98.data;
                break;
              }
            }
          }
          std::__rotate[abi:nn180100]<std::_ClassicAlgPolicy,std::__wrap_iter<void const**>,std::__wrap_iter<void const**>>((char *)v98.info, v44, v98.data);
        }
        uint64_t v45 = (void **)v98.info;
        unint64_t v46 = v98.data;
        if ((char *)v98.info != v98.data)
        {
          allocator  = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          do
          {
            uint64_t v47 = *v45;
            id v86 = 0;
            CFTypeID v48 = CFGetTypeID(v47);
            if (v48 == CFStringGetTypeID())
            {
              CreateLettersFromString(&v98, v47);

              goto LABEL_66;
            }
            if (v85 == 1) {
              LinesByWrapping((const __CFArray *)&v98, (const __CFArray *)v47);
            }
            else {
              v98.isa  = v47;
            }

            CFCharacterSetRef explicit = (const __CFCharacterSet *)atomic_load_explicit((atomic_ullong *volatile)&v96, memory_order_acquire);
            v98.isa  = (void *)0xAAAAAAAAAAAAAAAALL;
            DigitsForLanguage(&v98, 0);
            if (atomic_load_explicit((atomic_ullong *volatile)&v98, memory_order_acquire))
            {
              unsigned int v50 = v46;
              id Mutable = CFArrayCreateMutable(allocator, 0, MEMORY[0x1E4F1D510]);
              CFArrayRef v51 = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v98, memory_order_acquire);
              if (v51)
              {
                CFIndex v52 = CFArrayGetCount(v51);
                if (v52)
                {
                  CFIndex v53 = v52;
                  for (CFIndex j = 0; j != v53; ++j)
                  {
                    CFStringRef v55 = (const __CFString *)CFArrayGetValueAtIndex(v51, j);
                    v104.CFIndex length = CFStringGetLength(v55);
                    v104.CFIndex location = 0;
                    if (!RangeOfCharactersFromSet(v55, explicit, v104, 8uLL)) {
                      CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), v55);
                    }
                  }
                }
              }
              if (CFArrayGetCount((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire)))
              {
                uint64_t v56 = (void *)atomic_exchange((atomic_ullong *volatile)&Mutable, 0);

                a7  = v84;
                unint64_t v46 = v50;
                if (v56)
                {
                  v98.isa  = (void *)0xAAAAAAAAAAAAAAAALL;
                  TCFMutableArray::TCFMutableArray((TCFMutableArray *)&v98, (CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v86, memory_order_acquire));
                  id v57 = v56;
                  CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v98, memory_order_acquire), v57);
                }
                goto LABEL_65;
              }

              a7  = v84;
              unint64_t v46 = v50;
            }

            uint64_t v56 = 0;
LABEL_65:

LABEL_66:
            v98.isa  = (void *)0xAAAAAAAAAAAAAAAALL;
            LettersSpanningCharacterSet((const __CFArray *)&v98, (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v86, memory_order_acquire), atomic_load_explicit((atomic_ullong *volatile)&v96, memory_order_acquire));
            CountOfLetters  = GetCountOfLetters((const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v98, memory_order_acquire));
            if (CountOfLetters
              && CountOfLetters == GetCountOfLetters((const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v86, memory_order_acquire)))
            {
              *a7  = atomic_exchange((atomic_ullong *volatile)&v98, 0);

              v98.isa  = &v98.info;
              std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v98);
              goto LABEL_81;
            }

            ++v45;
          }
          while (v45 != (void **)v46);
        }
        v98.isa  = &v98.info;
        std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v98);
      }
    }
  }
  v98.info  = 0xAAAAAAAAAAAAAAAALL;
  TSampleManagerImp::CopySampleLettersSpanningCharacterSet((const __CFArray *)&v98.info, a1, a4, atomic_load_explicit((atomic_ullong *volatile)&v96, memory_order_acquire), 0);
  if (atomic_load_explicit(&v98.info, memory_order_acquire))
  {
LABEL_78:
    unint64_t v30 = atomic_exchange(&v98.info, 0);
    goto LABEL_79;
  }

  CFArrayRef v61 = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v94, memory_order_acquire);
  if (v61)
  {
    CFIndex v62 = CFArrayGetCount(v61);
    if (v62)
    {
      CFIndex v63 = v62;
      for (CFIndex k = 0; v63 != k; ++k)
      {
        unsigned int v65 = (__CFString *)CFArrayGetValueAtIndex(v61, k);
        SampleLettersForLanguage(&v98.info, v85, a4, atomic_load_explicit((atomic_ullong *volatile)&v96, memory_order_acquire), v65);
        CFCharacterSetRef v66 = (const __CFCharacterSet *)atomic_exchange(&v98.info, 0);

        if (v66)
        {
          v98.info  = 0xAAAAAAAAAAAAAAAALL;
          SampleLettersSpanningCharacterSet((const __CFArray *)&v98.info, v66, atomic_load_explicit((atomic_ullong *volatile)&v96, memory_order_acquire));
          if (atomic_load_explicit(&v98.info, memory_order_acquire))
          {
            if (a6)
            {
              CFAllocatorRef v82 = *a6;
              if (*a6 != v65)
              {
                *a6  = v65;
              }
            }
            *CFIndex v84 = atomic_exchange(&v98.info, 0);

            unsigned int v60 = v66;
            goto LABEL_80;
          }
        }
      }
    }
  }
  uint64_t v67 = uset_openEmpty();
  if (!v67) {
    goto LABEL_138;
  }
  uint64_t v68 = v67;
  int v69 = -1114112;
  do
  {
    unint64_t v70 = (v69 + 1114112);
    if (v70 < 0xE000
      || v70 >> 11 >= 0x1F && (v70 < 0xF0000 || (v69 + 2) >= 0xFFFFFC02))
    {
      unsigned int v71 = (uint64_t)v87[1] & 4;
      if (HIDWORD(v87[1]) <= v70 && v88 > v70)
      {
        if (WORD1(v70) || ((uint64_t)v87[1] & 2) != 0)
        {
          if (!CFCharacterSetIsLongCharacterMember((CFCharacterSetRef)v87[0], v69 + 1114112)) {
            continue;
          }
LABEL_117:
          MEMORY[0x185328230](v68, (v69 + 1114112));
          continue;
        }
        if (*((void *)&v88 + 1))
        {
          if ((uint64_t)v87[1])
          {
            unsigned int v79 = v71 >> 2;
            uint64_t v80 = *(unsigned __int8 *)(*((void *)&v88 + 1) + (v70 >> 8));
            if (*(unsigned char *)(*((void *)&v88 + 1) + (v70 >> 8)))
            {
              if (v80 == 255)
              {
                unsigned int v79 = v71 == 0;
              }
              else
              {
                BOOL v81 = v71 == 0;
                if ((((unint64_t)*(unsigned __int8 *)(*((void *)&v88 + 1)
                                                            + 32 * v80
                                                            + (v69 >> 3)
                                                            + 224) >> (v69 & 7)) & 1) != 0)
                  unsigned int v79 = v81;
              }
            }
            if (v79) {
              goto LABEL_117;
            }
          }
          else
          {
            BOOL v73 = v71 == 0;
            BOOL v74 = v71 != 0;
            char v75 = v73;
            if ((((unint64_t)*(unsigned __int8 *)(*((void *)&v88 + 1)
                                                        + ((unint64_t)(v69 + 1114112) >> 3)) >> (v69 & 7)) & 1) != 0)
              BOOL v74 = v75;
            if (v74) {
              goto LABEL_117;
            }
          }
        }
        else
        {
          BOOL v73 = v71 == 0;
          BOOL v77 = v71 != 0;
          char v78 = v73;
          if (((uint64_t)v87[1] & 1) == 0) {
            BOOL v77 = v78;
          }
          if (v77) {
            goto LABEL_117;
          }
        }
      }
      else if (((uint64_t)v87[1] & 4) != 0)
      {
        goto LABEL_117;
      }
    }
  }
  while (!__CFADD__(v69++, 1));
  LODWORD(Mutable)  = 0;
  v98.info  = 0xAAAAAAAAAAAAAAAALL;
  SampleLettersFromUSet(&v98, v85, a4, atomic_load_explicit((atomic_ullong *volatile)&v96, memory_order_acquire), v68, (int *)&Mutable, 0);
  v98.info  = atomic_exchange((atomic_ullong *volatile)&v98, 0);

  if (atomic_load_explicit(&v98.info, memory_order_acquire))
  {
    *CFIndex v84 = atomic_exchange(&v98.info, 0);

    uset_close();
    goto LABEL_81;
  }

  uset_close();
LABEL_138:
  *CFIndex v84 = 0;
LABEL_81:

  info  = v94;
LABEL_82:

  id v21 = v95;
LABEL_83:

LABEL_84:
}

void CreateLettersFromString(const __CFString *a1, void *a2)
{
  uint64_t v4 = (void *)MEMORY[0x185327A40]();
  uint64_t v7 = 0;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x3052000000;
  long long v10 = __Block_byref_object_copy__1;
  unint64_t v11 = __Block_byref_object_dispose__1;
  uint64_t v12 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v12 = [MEMORY[0x1E4F1CA48] array];
  v6[0]  = MEMORY[0x1E4F143A8];
  v6[1]  = 3221225472;
  id v6[2] = ___ZL23CreateLettersFromStringPK10__CFString_block_invoke;
  v6[3]  = &unk_1E5290110;
  v6[4]  = &v7;
  [a2 enumerateLinesUsingBlock:v6];
  id v5 = (id)v8[5];
  a1->isa  = (void *)atomic_exchange((atomic_ullong *volatile)&v5, 0);

  _Block_object_dispose(&v7, 8);
}

void LinesByWrapping(const __CFArray *a1, const __CFArray *a2)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  id Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  if (a2)
  {
    CFIndex Count = CFArrayGetCount(a2);
    if (Count)
    {
      CFIndex v3 = 0;
      uint64_t v4 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
      do
      {
        CFArrayRef ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(a2, v3);
        CFIndex v6 = CFArrayGetCount(ValueAtIndex);
        if (v6 >= 0) {
          uint64_t v7 = v6;
        }
        else {
          uint64_t v7 = v6 + 1;
        }
        uint64_t v8 = v7 >> 1;
        uint64_t v9 = v6 - (v7 >> 1);
        if (v9 >= 0) {
          uint64_t v10 = v9;
        }
        else {
          uint64_t v10 = v9 + 1;
        }
        uint64_t v11 = v10 >> 1;
        CFIndex v12 = v9 - (v10 >> 1);
        if (v6 >= 41) {
          CFIndex v13 = v11;
        }
        else {
          CFIndex v13 = v8;
        }
        if (v6 >= 41) {
          CFIndex v14 = v8 - ((unint64_t)v6 >> 2);
        }
        else {
          CFIndex v14 = 0;
        }
        if (v6 >= 41) {
          CFIndex v15 = v12;
        }
        else {
          CFIndex v15 = v9;
        }
        if (v6 >= 41) {
          CFIndex v16 = (unint64_t)v6 >> 2;
        }
        else {
          CFIndex v16 = 0;
        }
        CFDictionaryRef v17 = CFArrayCreateMutable(v2, v15, v4);
        v25.CFIndex location = 0;
        v25.CFIndex length = v15;
        CFArrayAppendArray(v17, ValueAtIndex, v25);
        CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), v17);
        if (v13)
        {
          id v18 = CFArrayCreateMutable(v2, v13, v4);
          v26.CFIndex location = v15;
          v26.CFIndex length = v13;
          CFArrayAppendArray(v18, ValueAtIndex, v26);
          CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), v18);
        }
        if (v14)
        {
          CFIndex v19 = CFArrayCreateMutable(v2, v14, v4);
          v27.CFIndex location = v15 + v13;
          v27.CFIndex length = v14;
          CFArrayAppendArray(v19, ValueAtIndex, v27);
          CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), v19);
        }
        if (v16)
        {
          CFAllocatorRef v20 = CFArrayCreateMutable(v2, v16, v4);
          v28.CFIndex location = v15 + v13 + v14;
          v28.CFIndex length = v16;
          CFArrayAppendArray(v20, ValueAtIndex, v28);
          CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), v20);
        }
        ++v3;
      }
      while (Count != v3);
    }
  }
  *(void *)a1  = atomic_exchange((atomic_ullong *volatile)&Mutable, 0);
}

void LettersSpanningCharacterSet(const __CFArray *a1, const __CFArray *a2, uint64_t a3)
{
  CFArrayRef explicit = a2;
  v32[4]  = *MEMORY[0x1E4F143B8];
  if (a2 && a3)
  {
    *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v4 + 1)  = 0xAAAAAAAAAAAAAAAALL;
    v30[0]  = v4;
    v30[1]  = v4;
    CFCharacterSetInitInlineBuffer();
    id v29 = 0;
    CFIndex Count = CFArrayGetCount(explicit);
    if (Count >= 1)
    {
      CFIndex v5 = 0;
      CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      do
      {
        CFArrayRef ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(explicit, v5);
        CFIndex v8 = CFArrayGetCount(ValueAtIndex);
        if (v8 >= 1)
        {
          CFIndex v9 = v8;
          for (CFIndex i = 0; i < v9; ++i)
          {
            uint64_t v11 = (__CFString *)CFArrayGetValueAtIndex(ValueAtIndex, i);
            id v28 = (id)0xAAAAAAAAAAAAAAAALL;
            v32[0]  = &unk_1ED060620;
            v32[1]  = v30;
            v32[3]  = v32;
            CreateStringByDeletingLongCharactersPassingTest(v11, (uint64_t)v32, (__CFString **)&v28);
            std::__function::__value_func<BOOL ()(CFRange,unsigned int)>::~__value_func[abi:nn180100](v32);
            CFStringRef v12 = (const __CFString *)(id)atomic_load_explicit((atomic_ullong *volatile)&v28, memory_order_acquire);
            CFIndex v13 = (__CFString *)v12;
            if (v12) {
              CFIndex Length = CFStringGetLength(v12);
            }
            else {
              CFIndex Length = 0;
            }
            CFIndex v15 = CFStringGetLength(v11);

            if (Length < v15)
            {
              if (!atomic_load_explicit((atomic_ullong *volatile)&v29, memory_order_acquire))
              {
                id Mutable = CFArrayCreateMutable(v6, 0, MEMORY[0x1E4F1D510]);
                if (explicit)
                {
                  CFIndex v16 = CFArrayGetCount(explicit);
                  if (v16)
                  {
                    CFIndex v17 = v16;
                    for (CFIndex j = 0; j != v17; ++j)
                    {
                      CFArrayRef v19 = (const __CFArray *)CFArrayGetValueAtIndex(explicit, j);
                      CFMutableArrayRef MutableCopy = CFArrayCreateMutableCopy(v6, 0, v19);
                      if (MutableCopy)
                      {
                        CFMutableArrayRef v21 = MutableCopy;
                        CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), MutableCopy);
                        CFRelease(v21);
                      }
                    }
                  }
                }
                id v27 = (id)atomic_exchange((atomic_ullong *volatile)&Mutable, 0);

                if (!atomic_load_explicit((atomic_ullong *volatile)&v29, memory_order_acquire))
                {
                  *(void *)a1  = 0;

                  goto LABEL_31;
                }
              }
              CFArrayRef explicit = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v29, memory_order_acquire);
              CFArrayRef ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(explicit, v5);
              CFArrayRemoveValueAtIndex(ValueAtIndex, i);
              --v9;
              --i;
            }
          }
        }
        ++v5;
      }
      while (v5 != Count);
    }
    if (atomic_load_explicit((atomic_ullong *volatile)&v29, memory_order_acquire))
    {
      CFIndex v22 = CFArrayGetCount((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v29, memory_order_acquire));
      if (v22 >= 1)
      {
        unint64_t v23 = v22 + 1;
        do
        {
          CFArrayRef v24 = (const __CFArray *)CFArrayGetValueAtIndex((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v29, memory_order_acquire), v23 - 2);
          if (!CFArrayGetCount(v24)) {
            CFArrayRemoveValueAtIndex((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v29, memory_order_acquire), v23 - 2);
          }
          --v23;
        }
        while (v23 > 1);
      }
      *(void *)a1  = atomic_exchange((atomic_ullong *volatile)&v29, 0);
    }
    else
    {
      *(void *)a1  = explicit;
    }
LABEL_31:
  }
  else
  {
    *(void *)a1  = a2;
  }
}

uint64_t GetCountOfLetters(const __CFArray *a1)
{
  if (!a1) {
    return 0;
  }
  CFIndex Count = CFArrayGetCount(a1);
  if (!Count) {
    return 0;
  }
  CFIndex v3 = Count;
  uint64_t v4 = 0;
  for (CFIndex i = 0; i != v3; ++i)
  {
    CFArrayRef ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(a1, i);
    v4 += CFArrayGetCount(ValueAtIndex);
  }
  return v4;
}

void SampleLettersFromUSet(void *a1, int a2, int a3, uint64_t a4, uint64_t a5, int *a6, const __CFString *a7)
{
  uint64_t v77 = *MEMORY[0x1E4F143B8];
  uint64_t v68 = a4;
  if (*a6 >= 1)
  {
    *a1  = 0;
    return;
  }
  CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v14 = MEMORY[0x1E4F1D548];
  id Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D548]);
  id v66 = CFSetCreateMutable(v13, 0, (const CFSetCallBacks *)v14);
  long long v15 = *(_OWORD *)(v14 + 16);
  *(_OWORD *)&callBacks.version  = *(_OWORD *)v14;
  *(_OWORD *)&callBacks.release  = v15;
  callBacks.equal  = (CFSetEqualCallBack)SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_7::__invoke;
  callBacks.hash  = (CFSetHashCallBack)SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_8::__invoke;
  id v64 = CFSetCreateMutable(v13, 0, &callBacks);
  char v63 = 0;
  *(void *)&long long v60 = &v63;
  *((void *)&v60 + 1)  = &v64;
  *(void *)&long long v61 = &v68;
  *((void *)&v61 + 1)  = &Mutable;
  CFIndex v62 = &v66;
  v74[0]  = &unk_1ED060350;
  v74[1]  = &v60;
  v74[3]  = v74;
  CFIndex v16 = (char *)operator new(0x30uLL);
  *(void *)CFIndex v16 = &unk_1ED060398;
  long long v17 = v61;
  *(_OWORD *)(v16 + 8)  = v60;
  *(_OWORD *)(v16 + 24)  = v17;
  *((void *)v16 + 5)  = v62;
  v73[3]  = v16;
  IterateItems(a5, a6, (uint64_t)v74, (uint64_t)v73);
  std::__function::__value_func<void ()(__CFString const*)>::~__value_func[abi:nn180100](v73);
  std::__function::__value_func<void ()(unsigned int,unsigned int)>::~__value_func[abi:nn180100](v74);
  if (!CFSetGetCount((CFSetRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire)))
  {
    id v59 = CFArrayCreateMutable(v13, 0, MEMORY[0x1E4F1D510]);
    v72[0]  = &unk_1ED0603E0;
    v72[3]  = v72;
    if (a3 == 2) {
      int v19 = 1;
    }
    else {
      int v19 = 2;
    }
    LODWORD(v58)  = v19;
    LODWORD(v57)  = 0;
    CFAllocatorRef v20 = operator new(0x28uLL);
    *CFAllocatorRef v20 = &unk_1ED062090;
    v20[1]  = &v58;
    v20[2]  = v72;
    v20[3]  = &v59;
    v20[4]  = &v57;
    double v76 = v20;
    IterateItemRanges(a5, a6, (uint64_t)values);
    std::__function::__value_func<void ()(unsigned int,unsigned int)>::~__value_func[abi:nn180100](values);
    int v21 = v19 - v57;
    std::__function::__value_func<BOOL ()>::~__value_func[abi:nn180100](v72);
    v71[0]  = &unk_1ED060428;
    v71[3]  = v71;
    LODWORD(v58)  = v21;
    if (v21 < 1)
    {
      int v23 = 0;
    }
    else
    {
      LODWORD(v57)  = 0;
      CFIndex v22 = operator new(0x28uLL);
      *CFIndex v22 = &unk_1ED062090;
      v22[1]  = &v58;
      v22[2]  = v71;
      v22[3]  = &v59;
      v22[4]  = &v57;
      double v76 = v22;
      IterateItemRanges(a5, a6, (uint64_t)values);
      std::__function::__value_func<void ()(unsigned int,unsigned int)>::~__value_func[abi:nn180100](values);
      int v23 = (int)v57;
    }
    int v36 = v21 - v23;
    std::__function::__value_func<BOOL ()>::~__value_func[abi:nn180100](v71);
    v70[0]  = &unk_1ED060470;
    v70[3]  = v70;
    LODWORD(v58)  = v36;
    if (v36 < 1)
    {
      int v38 = 0;
    }
    else
    {
      LODWORD(v57)  = 0;
      uint64_t v37 = operator new(0x28uLL);
      void *v37 = &unk_1ED062090;
      v37[1]  = &v58;
      v37[2]  = v70;
      v37[3]  = &v59;
      v37[4]  = &v57;
      double v76 = v37;
      IterateItemRanges(a5, a6, (uint64_t)values);
      std::__function::__value_func<void ()(unsigned int,unsigned int)>::~__value_func[abi:nn180100](values);
      int v38 = (int)v57;
    }
    int v39 = v36 - v38;
    std::__function::__value_func<BOOL ()>::~__value_func[abi:nn180100](v70);
    v69[0]  = &unk_1ED0604B8;
    v69[3]  = v69;
    LODWORD(v58)  = v39;
    if (v39 >= 1)
    {
      LODWORD(v57)  = 0;
      CFIndex v40 = operator new(0x28uLL);
      void *v40 = &unk_1ED062090;
      v40[1]  = &v58;
      v40[2]  = v69;
      v40[3]  = &v59;
      v40[4]  = &v57;
      double v76 = v40;
      IterateItemRanges(a5, a6, (uint64_t)values);
      std::__function::__value_func<void ()(unsigned int,unsigned int)>::~__value_func[abi:nn180100](values);
    }
    std::__function::__value_func<BOOL ()>::~__value_func[abi:nn180100](v69);
    if (CFArrayGetCount((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v59, memory_order_acquire)))
    {
      values[0]  = CFArrayCreateMutable(v13, 0, MEMORY[0x1E4F1D510]);
      CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)values, memory_order_acquire), (const void *)atomic_load_explicit((atomic_ullong *volatile)&v59, memory_order_acquire));
      id v58 = (id)atomic_exchange((atomic_ullong *volatile)values, 0);
      *a1  = atomic_exchange((atomic_ullong *volatile)&v58, 0);
    }
    else
    {
      *a1  = 0;
    }
    id v41 = v59;
    goto LABEL_57;
  }
  if (a7) {
    CFLocaleRef v18 = CFLocaleCreate(v13, a7);
  }
  else {
    CFLocaleRef v18 = CFLocaleCopyCurrent();
  }
  CFLocaleRef v24 = v18;
  id v59 = (id)0xAAAAAAAAAAAAAAAALL;
  CreateSortedArrayWithSet((CFSetRef)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire), (CFComparisonResult (__cdecl *)(const void *, const void *, void *))SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_9::__invoke, v18, (CFArrayRef *)values);
  TCFMutableArray::TCFMutableArray((TCFMutableArray *)&v59, (CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)values, memory_order_acquire));

  id v58 = (id)0xAAAAAAAAAAAAAAAALL;
  CreateSortedArrayWithSet((CFSetRef)atomic_load_explicit((atomic_ullong *volatile)&v66, memory_order_acquire), (CFComparisonResult (__cdecl *)(const void *, const void *, void *))SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_9::__invoke, v24, (CFArrayRef *)&v58);
  if (!a3)
  {
    values[0]  = CFArrayCreateMutable(v13, 0, MEMORY[0x1E4F1D510]);
    CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)values, memory_order_acquire), (const void *)atomic_load_explicit((atomic_ullong *volatile)&v59, memory_order_acquire));
    CFArrayRef v33 = (const __CFArray *)(id)atomic_load_explicit((atomic_ullong *volatile)&v58, memory_order_acquire);
    CFArrayRef v34 = v33;
    if (v33)
    {
      CFIndex Count = CFArrayGetCount(v33);

      if (!Count)
      {
LABEL_33:
        if (a2 == 1)
        {
          LinesByWrapping((const __CFArray *)&v57, (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)values, memory_order_acquire));
        }
        if (CFSetGetCount((CFSetRef)atomic_load_explicit((atomic_ullong *volatile)&v64, memory_order_acquire)))
        {
          id v57 = (id)0xAAAAAAAAAAAAAAAALL;
          CreateSortedArrayWithSet((CFSetRef)atomic_load_explicit((atomic_ullong *volatile)&v64, memory_order_acquire), (CFComparisonResult (__cdecl *)(const void *, const void *, void *))SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_9::__invoke, v24, (CFArrayRef *)&v56);
          TCFMutableArray::TCFMutableArray((TCFMutableArray *)&v57, (CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v56, memory_order_acquire));

          CFIndex v42 = CFArrayGetCount((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v57, memory_order_acquire));
          if (v42 >= 1)
          {
            CFIndex v43 = v42;
            CFIndex v44 = 0;
            while (1)
            {
              CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v57, memory_order_acquire), v44);
              FirstCharacter  = GetFirstCharacter(ValueAtIndex);
              if (u_getNumericValue(FirstCharacter) > 0.0) {
                break;
              }
              if (v43 == ++v44) {
                goto LABEL_54;
              }
            }
            for (CFIndex i = CFArrayCreateMutable(v13, 0, MEMORY[0x1E4F1D510]); v44; --v44)
            {
              CFStringRef v55 = CFArrayGetValueAtIndex((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v57, memory_order_acquire), 0);
              CFArrayAppendValue(i, v55);
              CFArrayRemoveValueAtIndex((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v57, memory_order_acquire), 0);
            }
            TCFMutableArray::AppendArray<__CFArray const*>((atomic_ullong *)&v57, i);
          }
LABEL_54:
          CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)values, memory_order_acquire), (const void *)atomic_load_explicit((atomic_ullong *volatile)&v57, memory_order_acquire));
        }
        else
        {
          id v57 = (id)0xAAAAAAAAAAAAAAAALL;
          DigitsForLanguage((const __CFString *)&v57, a7);
          if (atomic_load_explicit((atomic_ullong *volatile)&v57, memory_order_acquire))
          {
            uint64_t v47 = CFArrayCreateMutable(v13, 0, MEMORY[0x1E4F1D510]);
            CFArrayRef explicit = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)&v57, memory_order_acquire);
            if (explicit)
            {
              CFIndex v49 = CFArrayGetCount(explicit);
              if (v49)
              {
                CFIndex v50 = v49;
                for (CFIndex j = 0; j != v50; ++j)
                {
                  CFStringRef v52 = (const __CFString *)CFArrayGetValueAtIndex(explicit, j);
                  uint64_t v53 = GetFirstCharacter(v52);
                  if (MEMORY[0x185328270](a5, v53)) {
                    CFArrayAppendValue(v47, v52);
                  }
                }
              }
            }
            if (CFArrayGetCount(v47)) {
              CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)values, memory_order_acquire), v47);
            }
          }
        }

        id v57 = (id)atomic_exchange((atomic_ullong *volatile)values, 0);
        *a1  = atomic_exchange((atomic_ullong *volatile)&v57, 0);

        id v32 = values[0];
        goto LABEL_56;
      }
      CFArrayRef v34 = (const __CFArray *)(id)atomic_load_explicit((atomic_ullong *volatile)&v58, memory_order_acquire);
      CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)values, memory_order_acquire), v34);
    }

    goto LABEL_33;
  }
  CFRange v25 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
  id v57 = CFArrayCreateMutable(v13, 0, MEMORY[0x1E4F1D510]);
  values[0]  = (void *)CFArrayGetValueAtIndex((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v59, memory_order_acquire), 0);
  CFArrayRef v26 = CFArrayCreate(v13, (const void **)values, 1, v25);
  CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v57, memory_order_acquire), v26);

  if (a3 == 1)
  {
    id v27 = (id)atomic_load_explicit((atomic_ullong *volatile)&v58, memory_order_acquire);
    if (!v27)
    {
LABEL_17:

      goto LABEL_18;
    }
    id v28 = v27;
    CFIndex v29 = CFArrayGetCount((CFArrayRef)v27);

    if (v29)
    {
      values[0]  = CFArrayCreateMutable(v13, 0, MEMORY[0x1E4F1D510]);
      CFArrayRef v30 = (const __CFArray *)CFArrayGetValueAtIndex((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v57, memory_order_acquire), 0);
      TCFMutableArray::AppendArray<__CFArray const*>((atomic_ullong *)values, v30);
      CFIndex v31 = CFArrayGetValueAtIndex((CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v58, memory_order_acquire), 0);
      CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)values, memory_order_acquire), v31);
      CFArraySetValueAtIndex((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v57, memory_order_acquire), 0, (const void *)atomic_load_explicit((atomic_ullong *volatile)values, memory_order_acquire));
      id v27 = values[0];
      goto LABEL_17;
    }
  }
LABEL_18:
  values[0]  = (void *)atomic_exchange((atomic_ullong *volatile)&v57, 0);
  *a1  = atomic_exchange((atomic_ullong *volatile)values, 0);

  id v32 = v57;
LABEL_56:

  id v41 = v24;
LABEL_57:
}

void TSampleManagerImp::CopySampleLettersForLanguage(CTFontSampleString,__CFString const*)const::$_0::operator()(unint64_t *a1, uint64_t a2, void *cf)
{
  CFTypeID v6 = CFGetTypeID(cf);
  if (v6 == CFArrayGetTypeID())
  {
    if (!*(_DWORD *)a2)
    {
      v10.isa  = (void *)0xAAAAAAAAAAAAAAAALL;
      DigitsForLanguage(&v10, *(const void **)(a2 + 8));
      if (atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire))
      {
        id v9 = (id)0xAAAAAAAAAAAAAAAALL;
        TCFMutableArray::TCFMutableArray((TCFMutableArray *)&v9, (CFArrayRef)cf);
        CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit((atomic_ullong *volatile)&v9, memory_order_acquire), (const void *)atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire));
        id v8 = (id)atomic_exchange((atomic_ullong *volatile)&v9, 0);
        *a1  = atomic_exchange((atomic_ullong *volatile)&v8, 0);

        goto LABEL_6;
      }
    }
    v10.isa  = cf;
    unint64_t v7 = atomic_exchange((atomic_ullong *volatile)&v10, 0);
  }
  else
  {
    CreateLettersFromString(&v10, cf);
    unint64_t v7 = atomic_exchange((atomic_ullong *volatile)&v10, 0);
  }
  *a1  = v7;
LABEL_6:
}

void TSampleManager::TSampleManager(TSampleManager *this)
{
  if (qword_1EB2CE830 != -1) {
    dispatch_once_f(&qword_1EB2CE830, 0, (dispatch_function_t)GetTheSampleManager(void)::$_0::__invoke);
  }
  *(void *)this  = qword_1EB2CE828;
}

void TSampleManager::CopySampleString(atomic_ullong **a1@<X0>, atomic_ullong *a2@<X1>, unsigned int a3@<W2>, const __CFArray *a4@<X3>, void **a5@<X4>, void *a6@<X8>)
{
  TSampleManagerImp::Copy(*a1, 1, a2, a3, a4, a5, (unint64_t *)&v9);
  unint64_t v7 = (TSampleManager *)atomic_exchange((atomic_ullong *volatile)&v9, 0);

  TSampleManager::CreateStringWithLetters(v7, v8, a6);
}

void TSampleManager::CreateStringWithLetters(TSampleManager *this@<X0>, const __CFArray *a2@<X1>, void *a3@<X8>)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (this)
  {
    CFIndex v5 = (void *)MEMORY[0x185327A40](this, a2);
    CFTypeID v6 = (void *)[MEMORY[0x1E4F1CA48] array];
    long long v12 = 0u;
    long long v13 = 0u;
    long long v14 = 0u;
    long long v15 = 0u;
    uint64_t v7 = [(TSampleManager *)this countByEnumeratingWithState:&v12 objects:v16 count:16];
    if (v7)
    {
      uint64_t v8 = v7;
      uint64_t v9 = *(void *)v13;
      do
      {
        for (uint64_t i = 0; i != v8; ++i)
        {
          if (*(void *)v13 != v9) {
            objc_enumerationMutation(this);
          }
          objc_msgSend(v6, "addObject:", objc_msgSend(*(id *)(*((void *)&v12 + 1) + 8 * i), "componentsJoinedByString:", &stru_1ED0677F8));
        }
        uint64_t v8 = [(TSampleManager *)this countByEnumeratingWithState:&v12 objects:v16 count:16];
      }
      while (v8);
    }
    id v11 = (id)[v6 componentsJoinedByString:@"\n"];
    *a3  = atomic_exchange((atomic_ullong *volatile)&v11, 0);
  }
  else
  {
    *a3  = 0;
  }
}

void DigitsStringForLanguage(const __CFString *a1, const void *a2)
{
  if (qword_1EB2CE800 && (CFNumberRef Value = (void *)CFDictionaryGetValue((CFDictionaryRef)qword_1EB2CE800, a2)) != 0)
  {
    id v10 = Value;
    CFIndex v5 = (void *)atomic_exchange((atomic_ullong *volatile)&v10, 0);
  }
  else
  {
    id v10 = (id)_CFLocaleCopyNumberingSystemForLocaleIdentifier();
    if (atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire)
      || (CopyPreferredNumberingSystem((uint64_t *)&v9),
          (id)atomic_exchange((atomic_ullong *volatile)&v10, atomic_exchange((atomic_ullong *volatile)&v9, 0)), v9, atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire)))
    {
      CFIndex v5 = (void *)atomic_exchange((atomic_ullong *volatile)&v10, 0);
    }
    else
    {
      CFIndex v5 = 0;
    }
  }

  if (v5)
  {
    CFTypeID v6 = (void *)MEMORY[0x185327A40]();
    id v7 = (id)objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F1CA20], "componentsFromLocaleIdentifier:", a2), "mutableCopy");
    [v7 setObject:v5 forKeyedSubscript:@"numbers"];
    id v8 = (id)objc_opt_new();
    objc_msgSend(v8, "setLocale:", objc_msgSend(MEMORY[0x1E4F1CA20], "localeWithLocaleIdentifier:", objc_msgSend(MEMORY[0x1E4F1CA20], "localeIdentifierFromComponents:", v7)));
    id v10 = (id)[v8 stringFromNumber:&unk_1ED082E90];
    a1->isa  = (void *)atomic_exchange((atomic_ullong *volatile)&v10, 0);
  }
  else
  {

    a1->isa  = 0;
  }
}

void std::__function::__func<SampleLettersForLanguage(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,__CFString const*)::$_0,std::allocator<SampleLettersForLanguage(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,__CFString const*)::$_0>,void ()(CFRange,unsigned int,BOOL *)>::~__func()
{
}

void *std::__function::__func<SampleLettersForLanguage(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,__CFString const*)::$_0,std::allocator<SampleLettersForLanguage(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,__CFString const*)::$_0>,void ()(CFRange,unsigned int,BOOL *)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1ED060590;
  result[1]  = v3;
  return result;
}

uint64_t std::__function::__func<SampleLettersForLanguage(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,__CFString const*)::$_0,std::allocator<SampleLettersForLanguage(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,__CFString const*)::$_0>,void ()(CFRange,unsigned int,BOOL *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2  = &unk_1ED060590;
  a2[1]  = v2;
  return result;
}

void std::__function::__func<SampleLettersForLanguage(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,__CFString const*)::$_0,std::allocator<SampleLettersForLanguage(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,__CFString const*)::$_0>,void ()(CFRange,unsigned int,BOOL *)>::operator()()
{
}

char *std::__rotate[abi:nn180100]<std::_ClassicAlgPolicy,std::__wrap_iter<void const**>,std::__wrap_iter<void const**>>(char *__src, char *a2, char *a3)
{
  if (__src != a2 && a2 != a3)
  {
    uint64_t v3 = __src;
    if (__src + 8 == a2)
    {
      uint64_t v9 = *(void *)__src;
      int64_t v10 = a3 - a2;
      __src  = (char *)memmove(__src, a2, a3 - a2);
      *(void *)((char *)v3 + v10)  = v9;
    }
    else if (a2 + 8 == a3)
    {
      uint64_t v11 = *((void *)a3 - 1);
      if (a3 - 8 != __src) {
        __src  = (char *)memmove(__src + 8, __src, a3 - 8 - __src);
      }
      *uint64_t v3 = v11;
    }
    else
    {
      uint64_t v4 = (a2 - __src) >> 3;
      if (v4 == (a3 - a2) >> 3)
      {
        CFIndex v5 = __src + 8;
        CFTypeID v6 = a2 + 8;
        do
        {
          uint64_t v7 = *((void *)v5 - 1);
          *((void *)v5 - 1)  = *((void *)v6 - 1);
          *((void *)v6 - 1)  = v7;
          if (v5 == a2) {
            break;
          }
          v5 += 8;
          BOOL v8 = v6 == a3;
          v6 += 8;
        }
        while (!v8);
      }
      else
      {
        uint64_t v12 = (a3 - a2) >> 3;
        uint64_t v13 = (a2 - __src) >> 3;
        do
        {
          uint64_t v14 = v13;
          uint64_t v13 = v12;
          uint64_t v12 = v14 % v12;
        }
        while (v12);
        if (v13)
        {
          long long v15 = &__src[8 * v13];
          do
          {
            uint64_t v17 = *((void *)v15 - 1);
            v15 -= 8;
            uint64_t v16 = v17;
            CFLocaleRef v18 = &v15[8 * v4];
            int v19 = v15;
            do
            {
              CFAllocatorRef v20 = v18;
              *(void *)int v19 = *(void *)v18;
              int v21 = &v18[8 * v4];
              BOOL v22 = __OFSUB__(v4, (a3 - v18) >> 3);
              uint64_t v24 = v4 - ((a3 - v18) >> 3);
              char v23 = (v24 < 0) ^ v22;
              CFLocaleRef v18 = &__src[8 * v24];
              if (v23) {
                CFLocaleRef v18 = v21;
              }
              int v19 = v20;
            }
            while (v18 != v15);
            *(void *)CFAllocatorRef v20 = v16;
          }
          while (v15 != __src);
        }
      }
    }
  }
  return __src;
}

void __Block_byref_object_copy__1(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__1(uint64_t a1)
{
}

uint64_t ___ZL23CreateLettersFromStringPK10__CFString_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v4 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v5 = [a2 length];
  v7[0]  = MEMORY[0x1E4F143A8];
  v7[1]  = 3221225472;
  void v7[2] = ___ZL23CreateLettersFromStringPK10__CFString_block_invoke_2;
  v7[3]  = &unk_1E52900E8;
  v7[4]  = v4;
  objc_msgSend(a2, "enumerateSubstringsInRange:options:usingBlock:", 0, v5, 2, v7);
  return [*(id *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) addObject:v4];
}

uint64_t ___ZL23CreateLettersFromStringPK10__CFString_block_invoke_2(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) addObject:a2];
}

void DigitsForLanguage(const __CFString *a1, const void *a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  v10.isa  = (void *)0xAAAAAAAAAAAAAAAALL;
  v10.info  = (uint64_t)Mutable;
  DigitsStringForLanguage(&v10, a2);
  if (!atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire)) {
    goto LABEL_4;
  }
  CFStringRef explicit = (const __CFString *)atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire);
  v10.CFIndex length = (uint64_t)explicit;
  HIBYTE(v10.data)  = 0;
  CFIndex Length = CFStringGetLength(explicit);
  uint64_t v7 = operator new(0x20uLL);
  void *v7 = &unk_1ED062048;
  v7[1]  = &v10.length;
  void v7[2] = (char *)&v10.data + 7;
  v7[3]  = &v10.info;
  uint64_t v12 = v7;
  EnumerateCharactersInRange(explicit, 0, Length, (uint64_t)v11);
  std::__function::__value_func<void ()(CFRange,unsigned int,BOOL *)>::~__value_func[abi:nn180100](v11);
  if (HIBYTE(v10.data))
  {
    a1->isa  = (void *)atomic_exchange(&v10.info, 0);
  }
  else
  {
LABEL_4:

    v10.CFIndex length = @"1234567890";
    LOBYTE(v10.isa)  = 0;
    CFIndex v8 = CFStringGetLength(@"1234567890");
    uint64_t v9 = operator new(0x20uLL);
    void *v9 = &unk_1ED062048;
    v9[1]  = &v10.length;
    v9[2]  = &v10;
    v9[3]  = &v10.info;
    uint64_t v12 = v9;
    EnumerateCharactersInRange(@"1234567890", 0, v8, (uint64_t)v11);
    std::__function::__value_func<void ()(CFRange,unsigned int,BOOL *)>::~__value_func[abi:nn180100](v11);
    if (LOBYTE(v10.isa)) {
      a1->isa  = (void *)atomic_exchange(&v10.info, 0);
    }
    else {
      a1->isa  = 0;
    }
  }
}

void std::__function::__func<DigitsForLanguage(__CFString const*)::$_0::operator() const(__CFString const*)::{lambda(CFRange,unsigned int,BOOL *)#1},std::allocator<DigitsForLanguage(__CFString const*)::$_0::operator() const(__CFString const*)::{lambda(CFRange,unsigned int,BOOL *)#1}>,void ()(CFRange,unsigned int,BOOL *)>::~__func()
{
}

__n128 std::__function::__func<DigitsForLanguage(__CFString const*)::$_0::operator() const(__CFString const*)::{lambda(CFRange,unsigned int,BOOL *)#1},std::allocator<DigitsForLanguage(__CFString const*)::$_0::operator() const(__CFString const*)::{lambda(CFRange,unsigned int,BOOL *)#1}>,void ()(CFRange,unsigned int,BOOL *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1ED062048;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8)  = result;
  *((void *)v2 + 3)  = *(void *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<DigitsForLanguage(__CFString const*)::$_0::operator() const(__CFString const*)::{lambda(CFRange,unsigned int,BOOL *)#1},std::allocator<DigitsForLanguage(__CFString const*)::$_0::operator() const(__CFString const*)::{lambda(CFRange,unsigned int,BOOL *)#1}>,void ()(CFRange,unsigned int,BOOL *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2  = &unk_1ED062048;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24)  = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8)  = result;
  return result;
}

void std::__function::__func<DigitsForLanguage(__CFString const*)::$_0::operator() const(__CFString const*)::{lambda(CFRange,unsigned int,BOOL *)#1},std::allocator<DigitsForLanguage(__CFString const*)::$_0::operator() const(__CFString const*)::{lambda(CFRange,unsigned int,BOOL *)#1}>,void ()(CFRange,unsigned int,BOOL *)>::operator()(uint64_t a1, CFRange *a2)
{
  CFStringRef v3 = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E4F1CF80], **(CFStringRef **)(a1 + 8), *a2);
  if (v3)
  {
    CFStringRef v4 = v3;
    uint64_t v5 = *(atomic_ullong **)(a1 + 24);
    **(unsigned char **)(a1 + 16)  = 1;
    CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit(v5, memory_order_acquire), v3);
    CFRelease(v4);
  }
}

void std::__function::__func<LettersSpanningCharacterSet(__CFArray const*,__CFCharacterSet const*)::$_0,std::allocator<LettersSpanningCharacterSet(__CFArray const*,__CFCharacterSet const*)::$_0>,BOOL ()(CFRange,unsigned int)>::~__func()
{
}

void *std::__function::__func<LettersSpanningCharacterSet(__CFArray const*,__CFCharacterSet const*)::$_0,std::allocator<LettersSpanningCharacterSet(__CFArray const*,__CFCharacterSet const*)::$_0>,BOOL ()(CFRange,unsigned int)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1ED060620;
  result[1]  = v3;
  return result;
}

uint64_t std::__function::__func<LettersSpanningCharacterSet(__CFArray const*,__CFCharacterSet const*)::$_0,std::allocator<LettersSpanningCharacterSet(__CFArray const*,__CFCharacterSet const*)::$_0>,BOOL ()(CFRange,unsigned int)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2  = &unk_1ED060620;
  a2[1]  = v2;
  return result;
}

uint64_t std::__function::__func<LettersSpanningCharacterSet(__CFArray const*,__CFCharacterSet const*)::$_0,std::allocator<LettersSpanningCharacterSet(__CFArray const*,__CFCharacterSet const*)::$_0>,BOOL ()(CFRange,unsigned int)>::operator()(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  unint64_t v3 = *a3;
  uint64_t v4 = *(void *)(a1 + 8);
  unsigned int v5 = *(_DWORD *)(v4 + 8);
  int v6 = (v5 >> 2) & 1;
  if (*(_DWORD *)(v4 + 12) <= v3 && *(_DWORD *)(v4 + 16) > v3)
  {
    if (WORD1(v3)) {
      BOOL v7 = 0;
    }
    else {
      BOOL v7 = (*(_DWORD *)(v4 + 8) & 2) == 0;
    }
    if (!v7)
    {
      BOOL v8 = CFCharacterSetIsLongCharacterMember(*(CFCharacterSetRef *)v4, v3) == 0;
LABEL_22:
      int v6 = !v8;
      return v6 ^ 1u;
    }
    unsigned int v9 = *(_DWORD *)(v4 + 8) & 4;
    uint64_t v10 = *(void *)(v4 + 24);
    if (v10)
    {
      if (v5)
      {
        unsigned int v11 = v9 >> 2;
        uint64_t v12 = *(unsigned __int8 *)(v10 + (v3 >> 8));
        if (*(unsigned char *)(v10 + (v3 >> 8)))
        {
          if (v12 == 255)
          {
            unsigned int v11 = v9 == 0;
          }
          else
          {
            BOOL v13 = v9 == 0;
            if ((*(unsigned __int8 *)(v10 + 32 * v12 + (v3 >> 3) + 224) >> (v3 & 7))) {
              unsigned int v11 = v13;
            }
          }
        }
        BOOL v8 = v11 == 0;
        goto LABEL_22;
      }
      if ((*(unsigned __int8 *)(v10 + (v3 >> 3)) >> (v3 & 7))) {
        int v6 = v9 == 0;
      }
      else {
        int v6 = v9 != 0;
      }
    }
    else
    {
      int v6 = v9 != 0;
      if ((v5 & 1) == 0) {
        int v6 = v9 == 0;
      }
    }
  }
  return v6 ^ 1u;
}

uint64_t GetFirstCharacter(const __CFString *a1)
{
  v5[4]  = *MEMORY[0x1E4F143B8];
  unsigned int v4 = -1;
  CFIndex Length = CFStringGetLength(a1);
  v5[0]  = &unk_1ED0602C0;
  v5[1]  = &v4;
  v5[3]  = v5;
  EnumerateCharactersInRange(a1, 0, Length, (uint64_t)v5);
  std::__function::__value_func<void ()(CFRange,unsigned int,BOOL *)>::~__value_func[abi:nn180100](v5);
  return v4;
}

BOOL SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_7::__invoke(const __CFString *a1, const __CFString *a2)
{
  FirstCharacter  = GetFirstCharacter(a1);
  NumericCFNumberRef Value = u_getNumericValue(FirstCharacter);
  UChar32 v5 = GetFirstCharacter(a2);
  return NumericValue == u_getNumericValue(v5);
}

uint64_t SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_8::__invoke(const __CFString *a1)
{
  uint64_t v2 = (void *)MEMORY[0x185327A40]();
  unint64_t v3 = NSNumber;
  FirstCharacter  = GetFirstCharacter(a1);
  uint64_t v5 = objc_msgSend((id)objc_msgSend(v3, "numberWithDouble:", u_getNumericValue(FirstCharacter)), "hash");
  return v5;
}

void std::__function::__func<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_0,std::allocator<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_0>,void ()(unsigned int,unsigned int)>::~__func()
{
}

void *std::__function::__func<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_0,std::allocator<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_0>,void ()(unsigned int,unsigned int)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1ED060350;
  result[1]  = v3;
  return result;
}

uint64_t std::__function::__func<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_0,std::allocator<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_0>,void ()(unsigned int,unsigned int)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2  = &unk_1ED060350;
  a2[1]  = v2;
  return result;
}

void std::__function::__func<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_0,std::allocator<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_0>,void ()(unsigned int,unsigned int)>::operator()(uint64_t a1, unsigned int *a2, int *a3)
{
  unsigned int v3 = *a2;
  for (int i = *a3; i != v3; ++v3)
  {
    StringWithLongCharacter  = CreateStringWithLongCharacter(v3);
    if (StringWithLongCharacter)
    {
      CFStringRef v7 = StringWithLongCharacter;
      SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_1::operator()(*(void *)(a1 + 8), StringWithLongCharacter);
      CFRelease(v7);
    }
  }
}

CFStringRef CreateStringWithLongCharacter(unsigned int a1)
{
  __int16 v5 = -21846;
  if (HIWORD(a1))
  {
    __int16 v2 = a1 & 0x3FF | 0xDC00;
    a1  = (a1 >> 10) - 10304;
    __int16 v5 = v2;
    CFIndex v1 = 2;
  }
  else
  {
    CFIndex v1 = 1;
  }
  chars  = a1;
  return CFStringCreateWithCharacters((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &chars, v1);
}

void SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_1::operator()(uint64_t a1, CFStringRef theString)
{
  if (!**(unsigned char **)a1)
  {
    if (CFStringGetLength(theString))
    {
      FirstCharacter  = GetFirstCharacter(theString);
      int v5 = 1 << u_charType(FirstCharacter);
      if ((v5 & 0x226) != 0)
      {
        if ((v5 & 0x200) != 0)
        {
          CFStringRef explicit = (__CFSet *)atomic_load_explicit(*(atomic_ullong *volatile *)(a1 + 8), memory_order_acquire);
          CFSetAddValue(explicit, theString);
        }
        else
        {
          if ((v5 & 6) != 0)
          {
            CFCharacterSetRef v6 = **(const __CFCharacterSet ***)(a1 + 16);
            CFCharacterSetRef v15 = v6;
            CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
            CFMutableArrayRef MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, theString);
            if (MutableCopy)
            {
              CFStringRef v9 = MutableCopy;
              CFStringCapitalize(MutableCopy, 0);
              CFIndex Length = CFStringGetLength(v9);
              v17.CFIndex location = 0;
              v17.CFIndex length = Length;
              RangeOfCharactersFromSet(v9, v6, v17, 0);
              if (v11 == Length) {
                CFSetAddValue((CFMutableSetRef)atomic_load_explicit(*(atomic_ullong *volatile *)(a1 + 24), memory_order_acquire), v9);
              }
              CFRelease(v9);
            }
            uint64_t v12 = CFStringCreateMutableCopy(v7, 0, theString);
            if (v12)
            {
              CFStringRef v13 = v12;
              CFStringLowercase(v12, 0);
              if (!CFSetContainsValue((CFSetRef)atomic_load_explicit(*(atomic_ullong *volatile *)(a1 + 24), memory_order_acquire), v13)
                && SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_1::operator() const(__CFString const*)::{lambda(__CFString const*)#1}::operator()(&v15, v13))
              {
                CFSetAddValue((CFMutableSetRef)atomic_load_explicit(*(atomic_ullong *volatile *)(a1 + 32), memory_order_acquire), v13);
              }
              CFRelease(v13);
            }
          }
          else
          {
            CFSetAddValue((CFMutableSetRef)atomic_load_explicit(*(atomic_ullong *volatile *)(a1 + 24), memory_order_acquire), theString);
          }
          if (CFSetGetCount((CFSetRef)atomic_load_explicit(*(atomic_ullong *volatile *)(a1 + 24), memory_order_acquire)) == 80
            && !CFSetGetCount((CFSetRef)atomic_load_explicit(*(atomic_ullong *volatile *)(a1 + 32), memory_order_acquire)))
          {
            **(unsigned char **)a1  = 1;
          }
        }
      }
    }
  }
}

BOOL SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_1::operator() const(__CFString const*)::{lambda(__CFString const*)#1}::operator()(const __CFCharacterSet **a1, CFStringRef theString)
{
  CFIndex Length = CFStringGetLength(theString);
  v7.CFIndex location = 0;
  v7.CFIndex length = Length;
  RangeOfCharactersFromSet(theString, *a1, v7, 0);
  return v5 == Length;
}

void std::__function::__func<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_1,std::allocator<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_1>,void ()(__CFString const*)>::~__func()
{
}

__n128 std::__function::__func<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_1,std::allocator<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_1>,void ()(__CFString const*)>::__clone(uint64_t a1)
{
  __int16 v2 = (char *)operator new(0x30uLL);
  *(void *)__int16 v2 = &unk_1ED060398;
  *(_OWORD *)(v2 + 8)  = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24)  = result;
  *((void *)v2 + 5)  = *(void *)(a1 + 40);
  return result;
}

__n128 std::__function::__func<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_1,std::allocator<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_1>,void ()(__CFString const*)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2  = &unk_1ED060398;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 40)  = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24)  = v3;
  *(__n128 *)(a2 + 8)  = result;
  return result;
}

void std::__function::__func<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_1,std::allocator<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_1>,void ()(__CFString const*)>::operator()(uint64_t a1, CFStringRef *a2)
{
}

CFComparisonResult SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_9::__invoke(const __CFString *a1, const __CFString *a2, const __CFLocale *a3)
{
  v6.CFIndex length = CFStringGetLength(a1);
  v6.CFIndex location = 0;

  return CFStringCompareWithOptionsAndLocale(a1, a2, v6, 0x20uLL, a3);
}

void std::__function::__func<GetFirstCharacter(__CFString const*)::$_0,std::allocator<GetFirstCharacter(__CFString const*)::$_0>,void ()(CFRange,unsigned int,BOOL *)>::~__func()
{
}

void *std::__function::__func<GetFirstCharacter(__CFString const*)::$_0,std::allocator<GetFirstCharacter(__CFString const*)::$_0>,void ()(CFRange,unsigned int,BOOL *)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1ED0602C0;
  result[1]  = v3;
  return result;
}

uint64_t std::__function::__func<GetFirstCharacter(__CFString const*)::$_0,std::allocator<GetFirstCharacter(__CFString const*)::$_0>,void ()(CFRange,unsigned int,BOOL *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2  = &unk_1ED0602C0;
  a2[1]  = v2;
  return result;
}

uint64_t std::__function::__func<GetFirstCharacter(__CFString const*)::$_0,std::allocator<GetFirstCharacter(__CFString const*)::$_0>,void ()(CFRange,unsigned int,BOOL *)>::operator()(uint64_t result, uint64_t a2, _DWORD *a3, unsigned char **a4)
{
  unsigned int v4 = *a4;
  **(_DWORD **)(result + 8)  = *a3;
  *unsigned int v4 = 1;
  return result;
}

void std::__function::__func<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_2::operator() const(int,std::function<BOOL ()(unsigned int)>)::{lambda(unsigned int,unsigned int)#1},std::allocator<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_2::operator() const(int,std::function<BOOL ()(unsigned int)>)::{lambda(unsigned int,unsigned int)#1}>,void ()(unsigned int,unsigned int)>::~__func()
{
}

__n128 std::__function::__func<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_2::operator() const(int,std::function<BOOL ()(unsigned int)>)::{lambda(unsigned int,unsigned int)#1},std::allocator<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_2::operator() const(int,std::function<BOOL ()(unsigned int)>)::{lambda(unsigned int,unsigned int)#1}>,void ()(unsigned int,unsigned int)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_1ED062090;
  *(_OWORD *)(v2 + 8)  = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24)  = result;
  return result;
}

__n128 std::__function::__func<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_2::operator() const(int,std::function<BOOL ()(unsigned int)>)::{lambda(unsigned int,unsigned int)#1},std::allocator<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_2::operator() const(int,std::function<BOOL ()(unsigned int)>)::{lambda(unsigned int,unsigned int)#1}>,void ()(unsigned int,unsigned int)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2  = &unk_1ED062090;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24)  = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8)  = result;
  return result;
}

void std::__function::__func<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_2::operator() const(int,std::function<BOOL ()(unsigned int)>)::{lambda(unsigned int,unsigned int)#1},std::allocator<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_2::operator() const(int,std::function<BOOL ()(unsigned int)>)::{lambda(unsigned int,unsigned int)#1}>,void ()(unsigned int,unsigned int)>::operator()(uint64_t a1, unsigned int *a2, int *a3)
{
  unsigned int v3 = *a2;
  int v4 = *a3;
  if (*a2 == *a3 || **(_DWORD **)(a1 + 8) < 1) {
    return;
  }
  while (1)
  {
    uint64_t v7 = *(void *)(*(void *)(a1 + 16) + 24);
    unsigned int v11 = v3;
    if (!v7)
    {
      std::__throw_bad_function_call[abi:nn180100]();
      JUMPOUT(0x184B3C790);
    }
    if (!(*(unsigned int (**)(uint64_t, unsigned int *))(*(void *)v7 + 48))(v7, &v11)) {
      goto LABEL_10;
    }
    StringWithLongCharacter  = (__CFString *)CreateStringWithLongCharacter(v3);
    if (StringWithLongCharacter)
    {
      CFArrayAppendValue((CFMutableArrayRef)atomic_load_explicit(*(atomic_ullong *volatile *)(a1 + 24), memory_order_acquire), StringWithLongCharacter);
      ++**(_DWORD **)(a1 + 32);
      CFStringRef v9 = *(_DWORD **)(a1 + 8);
      if ((*v9)-- == 1) {
        break;
      }
    }

LABEL_10:
    if (v4 == ++v3) {
      return;
    }
  }
}

void std::__function::__func<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_3,std::allocator<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_3>,BOOL ()(unsigned int)>::~__func()
{
}

void *std::__function::__func<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_3,std::allocator<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_3>,BOOL ()(unsigned int)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1ED0603E0;
  return result;
}

void std::__function::__func<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_3,std::allocator<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_3>,BOOL ()(unsigned int)>::__clone(uint64_t a1, void *a2)
{
  *a2  = &unk_1ED0603E0;
}

BOOL std::__function::__func<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_3,std::allocator<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_3>,BOOL ()(unsigned int)>::operator()(uint64_t a1, UChar32 *a2)
{
  UChar32 v2 = *a2;
  return ((1 << u_charType(*a2)) & 0xE00) != 0 && u_getNumericValue(v2) != 0.0;
}

void *std::__function::__value_func<BOOL ()(unsigned int)>::~__value_func[abi:nn180100](void *a1)
{
  UChar32 v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_4,std::allocator<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_4>,BOOL ()(unsigned int)>::~__func()
{
}

void *std::__function::__func<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_4,std::allocator<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_4>,BOOL ()(unsigned int)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1ED060428;
  return result;
}

void std::__function::__func<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_4,std::allocator<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_4>,BOOL ()(unsigned int)>::__clone(uint64_t a1, void *a2)
{
  *a2  = &unk_1ED060428;
}

BOOL std::__function::__func<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_4,std::allocator<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_4>,BOOL ()(unsigned int)>::operator()(uint64_t a1, UChar32 *a2)
{
  return ((1 << u_charType(*a2)) & 0xE00) != 0;
}

void std::__function::__func<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_5,std::allocator<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_5>,BOOL ()(unsigned int)>::~__func()
{
}

void *std::__function::__func<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_5,std::allocator<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_5>,BOOL ()(unsigned int)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1ED060470;
  return result;
}

void std::__function::__func<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_5,std::allocator<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_5>,BOOL ()(unsigned int)>::__clone(uint64_t a1, void *a2)
{
  *a2  = &unk_1ED060470;
}

uint64_t std::__function::__func<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_5,std::allocator<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_5>,BOOL ()(unsigned int)>::operator()(uint64_t a1, UChar32 *a2)
{
  unsigned int v2 = *a2;
  int v3 = 1 << u_charType(*a2);
  BOOL v4 = v2 < 0xF0000 || v2 - 1113088 < 0x3FE;
  unsigned int v5 = v2 >> 11 >= 0x1F && v4;
  if (v2 >= 0xE000) {
    unsigned int v6 = v5;
  }
  else {
    unsigned int v6 = 1;
  }
  if ((v3 & 0xF000000) != 0) {
    return v6;
  }
  else {
    return 0;
  }
}

void std::__function::__func<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_6,std::allocator<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_6>,BOOL ()(unsigned int)>::~__func()
{
}

void *std::__function::__func<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_6,std::allocator<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_6>,BOOL ()(unsigned int)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1ED0604B8;
  return result;
}

void std::__function::__func<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_6,std::allocator<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_6>,BOOL ()(unsigned int)>::__clone(uint64_t a1, void *a2)
{
  *a2  = &unk_1ED0604B8;
}

uint64_t std::__function::__func<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_6,std::allocator<SampleLettersFromUSet(TSampleManager::Sample,CTFontSampleString,__CFCharacterSet const*,USet const*,UErrorCode *,__CFString const*)::$_6>,BOOL ()(unsigned int)>::operator()(uint64_t a1, UChar32 *a2)
{
  unsigned int v2 = *a2;
  int8_t v3 = u_charType(*a2);
  uint64_t result = 1;
  if (((1 << v3) & 0x7FE01) != 0)
  {
    if (v2 >= 0xE000)
    {
      BOOL v5 = v2 - 1114110 < 0xFFFFFC02;
      if (v2 < 0xF0000) {
        BOOL v5 = 0;
      }
      return v2 >> 11 < 0x1F || v5;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void GetTheSampleManager(void)::$_0::__invoke()
{
}

void CopyConvertedMorxFromGSUB(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](a1, a2);
  BOOL v4 = v3;
  CFDataRef v6 = v5;
  uint64_t v7 = (TBaseFont *)v2;
  CFStringRef v9 = v8;
  uint64_t v142 = *MEMORY[0x1E4F143B8];
  BytePtr  = CFDataGetBytePtr(v5);
  CFIndex Length = CFDataGetLength(v6);
  unint64_t v12 = (unint64_t)&BytePtr[Length];
  if (BytePtr + 10 > &BytePtr[Length]
    || bswap32(*(unsigned __int16 *)BytePtr) >> 16 > 1
    || *((_WORD *)BytePtr + 1) && (unint64_t)(BytePtr + 14) > v12)
  {
    void *v9 = 0;
    return;
  }
  memcpy(v135, &unk_184BA8F90, sizeof(v135));
  memset(v135, 0, 32);
  LODWORD(v135[4])  = 1065353216;
  memset(&v135[5], 0, 32);
  LODWORD(v135[9])  = 1065353216;
  v135[11]  = 0;
  v135[10]  = &v135[11];
  v135[15]  = 0;
  v135[14]  = 0;
  v135[12]  = 0;
  v135[13]  = &v135[14];
  memset(&v135[17], 0, 40);
  v135[16]  = &v135[17];
  uint64_t v136 = &v135[22];
  unint64_t v115 = v12;
  double v116 = BytePtr;
  qmemcpy(v141, "TLFDrehclryckerginahanakntalrbehbara", sizeof(v141));
  char v114 = -86;
  unsigned __int8 v113 = 1;
  *(void *)&long long v13 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v13 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  v133[28]  = v13;
  v133[29]  = v13;
  v133[26]  = v13;
  v133[27]  = v13;
  v133[24]  = v13;
  v133[25]  = v13;
  v133[22]  = v13;
  v133[23]  = v13;
  v133[20]  = v13;
  v133[21]  = v13;
  v133[18]  = v13;
  v133[19]  = v13;
  v133[16]  = v13;
  v133[17]  = v13;
  v133[15]  = v13;
  v133[14]  = v13;
  v133[13]  = v13;
  v133[12]  = v13;
  v133[11]  = v13;
  v133[10]  = v13;
  v133[9]  = v13;
  v133[8]  = v13;
  v133[7]  = v13;
  v133[6]  = v13;
  v133[5]  = v13;
  v133[4]  = v13;
  v133[3]  = v13;
  v133[2]  = v13;
  v133[1]  = v13;
  v133[0]  = v13;
  uint64_t v131 = 0;
  uint64_t v130 = 0;
  uint64_t v132 = 0;
  *(void *)&v133[30]  = v133;
  uint64_t v14 = operator new(0x20uLL);
  *uint64_t v14 = &unk_1ED0601A0;
  v14[1]  = v141;
  v14[2]  = &v113;
  v14[3]  = &v130;
  v140[3]  = v14;
  int v15 = OTL::GCommon::IterateScriptTables((uint64_t)BytePtr, v12, (uint64_t)v140);
  std::__function::__value_func<BOOL ()(unsigned int,OTL::ScriptTable const*,BOOL &)>::~__value_func[abi:nn180100](v140);
  if (v15
    && v113
    && ((FeatureVariationsTable  = OTL::GCommon::GetFeatureVariationsTable((uint64_t)BytePtr, v12)) == 0
     || (v139[0]  = &unk_1ED0601E8,
         v139[1]  = &v113,
         v139[3]  = v139,
         int v17 = OTL::GCommon::IterateConditionSetTables((uint64_t)BytePtr, FeatureVariationsTable, v12, (uint64_t)v139),
         std::__function::__value_func<BOOL ()(OTL::ConditionSetTable const*,OTL::FeatureTableSubstitutionTable const*,BOOL &)>::~__value_func[abi:nn180100](v139),
         v17)
     && v113))
  {
    unint64_t v102 = v4;
    uint64_t v103 = v7;
    CFRange v104 = v9;
    *(void *)&long long v18 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v18 + 1)  = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&__b[59]  = v18;
    *(_OWORD *)&__b[61]  = v18;
    *(_OWORD *)&__b[55]  = v18;
    *(_OWORD *)&__b[57]  = v18;
    *(_OWORD *)&__b[51]  = v18;
    *(_OWORD *)&__b[53]  = v18;
    *(_OWORD *)&__b[47]  = v18;
    *(_OWORD *)&__b[49]  = v18;
    *(_OWORD *)&__b[43]  = v18;
    *(_OWORD *)&__b[45]  = v18;
    *(_OWORD *)&__b[39]  = v18;
    *(_OWORD *)&__b[41]  = v18;
    *(_OWORD *)&__b[35]  = v18;
    *(_OWORD *)&__b[37]  = v18;
    *(_OWORD *)&__b[33]  = v18;
    *(_OWORD *)&__b[31]  = v18;
    *(_OWORD *)&__b[29]  = v18;
    *(_OWORD *)&__b[27]  = v18;
    *(_OWORD *)&__b[25]  = v18;
    *(_OWORD *)&__b[23]  = v18;
    *(_OWORD *)&__b[21]  = v18;
    *(_OWORD *)&__b[19]  = v18;
    *(_OWORD *)&__b[17]  = v18;
    *(_OWORD *)&__b[15]  = v18;
    *(_OWORD *)&__b[13]  = v18;
    *(_OWORD *)&__b[11]  = v18;
    *(_OWORD *)&__b[9]  = v18;
    *(_OWORD *)&__b[7]  = v18;
    *(_OWORD *)&__b[5]  = v18;
    *(_OWORD *)&__b[3]  = v18;
    memset(__b, 0, 24);
    __b[63]  = &__b[3];
    *(_OWORD *)CFDictionaryRef v120 = 0u;
    *(_OWORD *)uint64_t v121 = 0u;
    *(void *)&v121[16]  = 0xAAAAAAAA3F800000;
    *(_OWORD *)double v110 = 0u;
    *(_OWORD *)CFDictionaryRef v111 = 0u;
    unint64_t v112 = 0xAAAAAAAA3F800000;
    int v19 = (void **)v130;
    CFAllocatorRef v20 = v131;
    if (v130 == v131)
    {
      *(_OWORD *)double v106 = 0uLL;
      *(_OWORD *)id __p = 0uLL;
      int v108 = 1065353216;
      int v109 = -1431655766;
LABEL_23:
      int v29 = 1;
      char v30 = 1;
    }
    else
    {
      do
      {
        *(_OWORD *)double v106 = *(_OWORD *)v19;
        int v21 = (unsigned __int16 *)v106[1];
        BOOL v22 = operator new(0x30uLL);
        *BOOL v22 = &unk_1ED060230;
        v22[1]  = &v113;
        v22[2]  = __b;
        v22[3]  = v120;
        v22[4]  = v106;
        void v22[5] = v110;
        v138[3]  = v22;
        LODWORD(v21)  = OTL::GCommon::IterateLangSysTables((unint64_t)BytePtr, v21, v12, (uint64_t)v138);
        std::__function::__value_func<BOOL ()(unsigned int,OTL::LangSysTable const*,BOOL &)>::~__value_func[abi:nn180100](v138);
        if (!v21 || !v113)
        {
          char v32 = 0;
          goto LABEL_37;
        }
        v19 += 2;
      }
      while (v19 != v20);
      char v23 = (char *)__b[1];
      *(_OWORD *)double v106 = 0u;
      *(_OWORD *)id __p = 0u;
      int v108 = 1065353216;
      int v109 = -1431655766;
      if (__b[0] == __b[1]) {
        goto LABEL_23;
      }
      uint64_t v24 = (char *)__b[0] + 16;
      while (1)
      {
        long long v105 = *((_OWORD *)v24 - 1);
        unint64_t v26 = v115;
        unint64_t v25 = (unint64_t)v116;
        uint64_t v27 = *((void *)&v105 + 1);
        id v28 = operator new(0x50uLL);
        void *v28 = &unk_1ED060278;
        v28[1]  = &v105;
        v28[2]  = &v113;
        _DWORD v28[3] = v110;
        v28[4]  = v120;
        void v28[5] = v106;
        v28[6]  = &v116;
        v28[7]  = &v115;
        v28[8]  = v135;
        v28[9]  = &v114;
        v137[3]  = v28;
        LOBYTE(v25)  = OTL::GCommon::IterateFeatureTables(v25, v27, v26, (uint64_t)v137);
        std::__function::__value_func<BOOL ()(unsigned int,OTL::FeatureTable const*,BOOL &)>::~__value_func[abi:nn180100](v137);
        if ((v25 & 1) == 0) {
          break;
        }
        int v29 = v113;
        char v30 = 1;
        if (v113)
        {
          BOOL v31 = v24 == v23;
          v24 += 16;
          if (!v31) {
            continue;
          }
        }
        goto LABEL_24;
      }
      char v30 = 0;
      int v29 = v113;
    }
LABEL_24:
    if (v29) {
      char v32 = v30;
    }
    else {
      char v32 = 0;
    }
    CFArrayRef v33 = __p[0];
    CFStringRef v9 = v104;
    if (__p[0])
    {
      do
      {
        CFArrayRef v34 = (void *)*v33;
        CFCharacterSetRef v35 = (void *)v33[5];
        if (v35)
        {
          do
          {
            int v36 = (void *)*v35;
            operator delete(v35);
            CFCharacterSetRef v35 = v36;
          }
          while (v36);
        }
        uint64_t v37 = (void *)v33[3];
        v33[3]  = 0;
        if (v37) {
          operator delete(v37);
        }
        operator delete(v33);
        CFArrayRef v33 = v34;
      }
      while (v34);
    }
    id v38 = v106[0];
    v106[0]  = 0;
    if (v38) {
      operator delete(v38);
    }
LABEL_37:
    int v39 = v111[0];
    if (v111[0])
    {
      do
      {
        CFIndex v40 = (void *)*v39;
        operator delete(v39);
        int v39 = v40;
      }
      while (v40);
    }
    id v41 = v110[0];
    v110[0]  = 0;
    if (v41) {
      operator delete(v41);
    }
    CFIndex v42 = *(void **)v121;
    if (*(void *)v121)
    {
      do
      {
        CFIndex v43 = (void *)*v42;
        operator delete(v42);
        CFIndex v42 = v43;
      }
      while (v43);
    }
    CFIndex v44 = v120[0];
    v120[0]  = 0;
    if (v44) {
      operator delete(v44);
    }
    if (__b[0])
    {
      __b[1]  = __b[0];
      if (&__b[3] > __b[0] || &__b[63] <= __b[0]) {
        operator delete(__b[0]);
      }
    }
    std::vector<TGlyphAuxDataListEntry,TInlineBufferAllocator<TGlyphAuxDataListEntry,30ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v130);
    if (v32)
    {
      memset(v133, 170, sizeof(v133));
      uint64_t v130 = 0;
      uint64_t v131 = 0;
      uint64_t v132 = 0;
      uint64_t v134 = v133;
      {
        v110[0]  = 0;
        if (v135[19] == v135[20]) {
          goto LABEL_125;
        }
        *(void *)&long long v45 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v45 + 1)  = 0xAAAAAAAAAAAAAAAALL;
        long long v127 = v45;
        long long v126 = v45;
        long long v125 = v45;
        long long v124 = v45;
        long long v123 = v45;
        long long v122 = v45;
        *(_OWORD *)&v121[8]  = v45;
        unint64_t v128 = 0xAAAAAAAAAAAAAAAALL;
        *(void *)uint64_t v121 = 0;
        v120[0]  = 0;
        v120[1]  = 0;
        v129[0]  = &v121[8];
        memset(__b, 170, sizeof(__b));
        CFAllocatorRef v46 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        numChars  = 0;
        alloc  = v46;
        CFMutableArrayRef Mutable = CFStringCreateMutable(v46, 0);
        theString  = Mutable;
        CFTypeID v48 = (atomic_ullong *)v135[19];
        CFIndex v49 = (atomic_ullong *)v135[20];
        if (v135[19] != v135[20])
        {
          uint64_t v50 = 0;
          while (1)
          {
            CFArrayRef v51 = (__CFString *)(id)atomic_load_explicit(v48, memory_order_acquire);
            CFStringRef v52 = v51;
            if (!v52) {
              break;
            }
            uint64_t v53 = (__CFString *)v52;
            CFIndex v54 = CFStringGetLength(v52);

            if (!v54) {
              goto LABEL_61;
            }
            if (v50 >= 0x10000 || (CFIndex v55 = v54 + v50, v54 + v50 >= 0x10000))
            {
              *CFRange v104 = 0;

              std::vector<LtagStringRange,TInlineBufferAllocator<LtagStringRange,30ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)v120);
              goto LABEL_126;
            }
            id v56 = (char *)v120[1];
            if (v120[1] >= (void *)*(void *)v121)
            {
              int64_t v58 = ((char *)v120[1] - (char *)v120[0]) >> 2;
              if ((unint64_t)(v58 + 1) >> 62) {
                abort();
              }
              unint64_t v59 = (uint64_t)(*(void *)v121 - (unint64_t)v120[0]) >> 1;
              if (v59 <= v58 + 1) {
                unint64_t v59 = v58 + 1;
              }
              if (*(void *)v121 - (unint64_t)v120[0] >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v60 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v60 = v59;
              }
              if (v60)
              {
                long long v61 = (char *)v129[0];
                if (v129[0] + 4 * v60 <= (unint64_t)v129)
                {
                  v129[0] += 4 * v60;
                }
                else
                {
                  if (v60 >> 62) {
                    std::__throw_bad_array_new_length[abi:nn180100]();
                  }
                  long long v61 = (char *)operator new(4 * v60);
                }
              }
              else
              {
                long long v61 = 0;
              }
              CFIndex v62 = (int *)&v61[4 * v58];
              *CFIndex v62 = (unsigned __int16)v50 | ((unsigned __int16)v54 << 16);
              id v57 = v62 + 1;
              char v63 = (char *)v120[1];
              id v64 = (char *)v120[0];
              if (v120[1] != v120[0])
              {
                do
                {
                  int v65 = *((_DWORD *)v63 - 1);
                  v63 -= 4;
                  *--CFIndex v62 = v65;
                }
                while (v63 != v64);
                char v63 = (char *)v120[0];
              }
              v120[0]  = v62;
              v120[1]  = v57;
              uint64_t v66 = *(void *)v121;
              *(void *)uint64_t v121 = &v61[4 * v60];
              if (v63)
              {
                if (&v121[8] <= v63 && v129 > (void *)v63)
                {
                  if (v66 == v129[0]) {
                    v129[0]  = v63;
                  }
                }
                else
                {
                  operator delete(v63);
                }
              }
            }
            else
            {
              *(_DWORD *)v120[1]  = (unsigned __int16)v50 | ((unsigned __int16)v54 << 16);
              id v57 = v56 + 4;
            }
            v120[1]  = v57;
            CFIndex v68 = CFStringGetLength(v51);
            CFIndex v69 = numChars;
            if (v68 < 1025)
            {
              CFIndex v70 = v68;
              if (numChars + v68 >= 1025)
              {
                CFStringAppendCharacters(theString, (const UniChar *)__b, numChars);
                CFIndex v69 = 0;
                numChars  = 0;
              }
              unsigned int v71 = (UniChar *)__b + v69;
              v143.CFIndex location = 0;
              v143.CFIndex length = v70;
              CFStringGetCharacters(v51, v143, v71);
              numChars += v70;
            }
            else
            {
              if (numChars)
              {
                CFStringAppendCharacters(theString, (const UniChar *)__b, numChars);
                numChars  = 0;
              }
              CFStringAppend(theString, v51);
            }
LABEL_92:

            ++v48;
            uint64_t v50 = v55;
            if (v48 == v49)
            {
              CFMutableStringRef v72 = theString;
              CFStringRef v9 = v104;
              goto LABEL_117;
            }
          }

LABEL_61:
          CFIndex v55 = v50;
          goto LABEL_92;
        }
        CFMutableStringRef v72 = Mutable;
LABEL_117:
        if (numChars)
        {
          CFStringAppendCharacters(v72, (const UniChar *)__b, numChars);
          numChars  = 0;
          CFMutableStringRef v72 = theString;
        }
        theString  = 0;
        ExternalRepresentation  = CFStringCreateExternalRepresentation(alloc, v72, 0x600u, 0);
        CFDataRef v85 = ExternalRepresentation;
        if (ExternalRepresentation)
        {
          int64_t v86 = (char *)v120[1] - (char *)v120[0] + 12;
          CFIndex v87 = CFDataGetLength(ExternalRepresentation);
          v106[0]  = CFDataCreateMutable(alloc, v86 + v87);

          CFStringRef explicit = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)v110, memory_order_acquire);
          LODWORD(v106[0])  = 0x1000000;
          CFDataAppendBytes(explicit, (const UInt8 *)v106, 4);
          id v89 = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)v110, memory_order_acquire);
          LODWORD(v106[0])  = 0;
          CFDataAppendBytes(v89, (const UInt8 *)v106, 4);
          id v90 = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)v110, memory_order_acquire);
          LODWORD(v106[0])  = bswap32((unint64_t)((char *)v120[1] - (char *)v120[0]) >> 2);
          CFDataAppendBytes(v90, (const UInt8 *)v106, 4);
          id v92 = (unsigned __int16 *)v120[0];
          id v93 = (unsigned __int16 *)v120[1];
          while (v92 != v93)
          {
            id v94 = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)v110, memory_order_acquire);
            LOWORD(v106[0])  = bswap32(*v92 + v86) >> 16;
            CFDataAppendBytes(v94, (const UInt8 *)v106, 2);
            id v95 = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)v110, memory_order_acquire);
            LOWORD(v106[0])  = bswap32(v92[1]) >> 16;
            CFDataAppendBytes(v95, (const UInt8 *)v106, 2);
            v92 += 2;
          }
        }
        else
        {
          void *v9 = 0;
        }

        std::vector<LtagStringRange,TInlineBufferAllocator<LtagStringRange,30ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)v120);
        if (v85)
        {
LABEL_125:
          GlyphCFIndex Count = TBaseFont::GetGlyphCount(v103);
        }
LABEL_126:
      }
      else
      {
        void *v9 = 0;
      }
      CFArrayRef v97 = (void **)v130;
      if (v130)
      {
        __CFString v98 = v131;
        int v99 = v130;
        if (v131 != v130)
        {
          do
          {
            v98 -= 118;
          }
          while (v98 != v97);
          int v99 = v130;
        }
        uint64_t v131 = v97;
        if (v133 > v99 || &v134 <= (_OWORD **)v99) {
          operator delete(v99);
        }
      }
      goto LABEL_95;
    }
  }
  else
  {
    std::vector<TGlyphAuxDataListEntry,TInlineBufferAllocator<TGlyphAuxDataListEntry,30ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v130);
  }
  void *v9 = 0;
LABEL_95:
  BOOL v73 = (id *)v135[19];
  if (v135[19])
  {
    BOOL v74 = (id *)v135[20];
    char v75 = (void **)v135[19];
    if (v135[20] != v135[19])
    {
      do
      {
        double v76 = v74 - 1;

        BOOL v74 = v76;
      }
      while (v76 != v73);
      char v75 = (void **)v135[19];
    }
    v135[20]  = v73;
    if (&v135[22] <= v75 && &v136 > (void ***)v75)
    {
      if (v135[21] == v136) {
        uint64_t v136 = v75;
      }
    }
    else
    {
      operator delete(v75);
    }
  }
  std::__tree<std::__value_type<unsigned int,std::unordered_set<unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::unordered_set<unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::unordered_set<unsigned int>>>>::destroy((void *)v135[17]);
  std::__tree<std::__value_type<unsigned int,std::set<unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::set<unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::set<unsigned int>>>>::destroy((void *)v135[14]);
  std::__tree<std::__value_type<unsigned int,std::set<unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::set<unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::set<unsigned int>>>>::destroy((void *)v135[11]);
  char v78 = v135[7];
  if (v135[7])
  {
    do
    {
      unsigned int v79 = (void *)*v78;
      operator delete(v78);
      char v78 = v79;
    }
    while (v79);
  }
  uint64_t v80 = v135[5];
  v135[5]  = 0;
  if (v80) {
    operator delete(v80);
  }
  BOOL v81 = v135[2];
  if (v135[2])
  {
    do
    {
      CFAllocatorRef v82 = (void *)*v81;
      std::__hash_table<EncoderAttempt,std::hash<EncoderAttempt>,std::equal_to<EncoderAttempt>,std::allocator<EncoderAttempt>>::~__hash_table((uint64_t)(v81 + 3));
      operator delete(v81);
      BOOL v81 = v82;
    }
    while (v82);
  }
  CFURLRef v83 = v135[0];
  v135[0]  = 0;
  if (v83) {
    operator delete(v83);
  }
}

uint64_t anonymous namespace'::MorxTableBuilder::From(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](a1, a2);
  v937  = *MEMORY[0x1E4F143B8];
  v843  = v5;
  v903  = 0;
  v902  = 0;
  v904  = 0;
  v906  = v905;
  if (!*(_WORD *)(v4 + 8)) {
    return 0;
  }
  uint64_t v7 = (unsigned __int16 *)(v4 + __rev16(*(unsigned __int16 *)(v4 + 8)));
  BOOL v8 = v7 + 1;
  if (v7 + 1 > v5) {
    return 0;
  }
  uint64_t v9 = bswap32(*v7) >> 16;
  unint64_t v10 = (unint64_t)&v8[v9];
  unint64_t v11 = v7 + 2 <= v5 ? (unint64_t)((char *)v5 - (char *)v8) >> 1 : 0;
  BOOL v12 = v10 <= (unint64_t)v5 && v10 >= (unint64_t)v8;
  BOOL v13 = v12 || v11 == v9;
  if (!v13) {
    return 0;
  }
  uint64_t v14 = v6;
  int v15 = v3;
  v804  = v9;
  v805  = v4;
  v806  = v7;
  v814  = (uint64_t *)v2;
  memset(v905, 170, sizeof(v905));
  *(void *)v842  = 0;
  v813  = v15;
  if (!*(void *)(v14 + 96)) {
    goto LABEL_294;
  }
  int v16 = 0;
  int v17 = (void *)(v14 + 80);
  long long v18 = &v852[32];
  int v19 = (uint64_t **)(v14 + 128);
  unint64_t v20 = v14 + 176;
  int v21 = (void *)(v14 + 40);
  v831  = (atomic_ullong **)(v14 + 416);
  BOOL v22 = (void *)(v14 + 56);
  long long v23 = 0uLL;
  do
  {
    uint64_t v24 = *(void *)(v14 + 80);
    uint64_t v26 = *(void *)(v24 + 40);
    unint64_t v25 = (uint64_t **)(v24 + 40);
    unint64_t v27 = *(unsigned int *)(v26 + 28);
    LODWORD(v891[0])  = *(_DWORD *)(v26 + 28);
    int8x8_t v28 = *(int8x8_t *)(v14 + 8);
    if (!*(void *)&v28) {
      goto LABEL_282;
    }
    uint8x8_t v29 = (uint8x8_t)vcnt_s8(v28);
    v29.i16[0]  = vaddlv_u8(v29);
    if (v29.u32[0] > 1uLL)
    {
      unint64_t v30 = v27;
      if (*(void *)&v28 <= v27) {
        unint64_t v30 = v27 % *(void *)&v28;
      }
    }
    else
    {
      unint64_t v30 = (v28.i32[0] - 1) & v27;
    }
    BOOL v31 = *(uint64_t ***)(*(void *)v14 + 8 * v30);
    if (!v31) {
      goto LABEL_282;
    }
    char v32 = *v31;
    if (!v32) {
      goto LABEL_282;
    }
    while (1)
    {
      unint64_t v33 = v32[1];
      if (v33 == v27) {
        break;
      }
      if (v29.u32[0] > 1uLL)
      {
        if (v33 >= *(void *)&v28) {
          v33 %= *(void *)&v28;
        }
      }
      else
      {
        v33 &= *(void *)&v28 - 1;
      }
      if (v33 != v30) {
        goto LABEL_282;
      }
LABEL_31:
      char v32 = (uint64_t *)*v32;
      if (!v32) {
        goto LABEL_282;
      }
    }
    if (*((_DWORD *)v32 + 4) != v27) {
      goto LABEL_31;
    }
    v826  = v16;
    unint64_t v34 = *(unsigned int *)(v24 + 32);
    *(_DWORD *)v852  = v27;
    *(_OWORD *)&v852[4]  = v23;
    *(_OWORD *)&v852[20]  = v23;
    *(_OWORD *)&v852[36]  = v23;
    *(_OWORD *)&v852[52]  = v23;
    *(_DWORD *)&v852[68]  = 0;
    v828  = v18;
    v827  = v22;
    if (v27 != 32)
    {
      if (*(void *)(v24 + 56) == 1)
      {
        std::__tree<std::__value_type<unsigned int,std::set<unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::set<unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::set<unsigned int>>>>::erase(v17, v24);
      }
      else
      {
        CFIndex v40 = v19;
        id v41 = v17;
        CFIndex v42 = v21;
        unint64_t v43 = v20;
        CFIndex v44 = *v25;
        std::__tree<unsigned int>::__remove_node_pointer(v25, *v25);
        long long v45 = v44;
        unint64_t v20 = v43;
        int v21 = v42;
        int v17 = v41;
        int v19 = v40;
        operator delete(v45);
      }
      if ((int)v27 > 1769172843)
      {
        if (v27 == 1835361385) {
          goto LABEL_51;
        }
        int v46 = 1769172844;
      }
      else
      {
        if (v27 == 1718185569) {
          goto LABEL_51;
        }
        int v46 = 1768843636;
      }
      if (v27 != v46)
      {
        int v60 = ConvertOTFeatureToAATFeature(v27, (uint64_t)&v852[4]);
        if (v60)
        {
          long long v23 = 0uLL;
          if (v60 != 2)
          {
            v825  = v21;
            v826 |= *(_DWORD *)&v852[8] & 0xFFFFFE00;
            CFIndex v68 = v827;
            goto LABEL_122;
          }
          int v59 = 1;
          int v16 = v826;
          goto LABEL_225;
        }
        int v59 = 2;
        goto LABEL_88;
      }
LABEL_51:
      uint64_t v47 = std::__tree<std::__value_type<unsigned int,std::unordered_set<unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::unordered_set<unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::unordered_set<unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(v19, v27, v891);
      *(_DWORD *)v893  = 1634885986;
      if (std::__hash_table<std::__hash_value_type<unsigned int,OTL::Lookup>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,OTL::Lookup>>>::find<unsigned int>(v47 + 5, (unsigned int *)v893))
      {
        *(_DWORD *)&v852[8]  = 35;
        uint64_t v48 = *(void *)v842;
        if (*(void *)v842) {
          goto LABEL_56;
        }
        CFIndex v49 = operator new(0x660uLL, MEMORY[0x1E4FBA2D0]);
        if (v49)
        {
          void *v49 = 0;
          v49[1]  = 0;
          v49[2]  = 0;
          v49[183]  = v49 + 3;
          v49[184]  = 0;
          v49[186]  = 0;
          v49[185]  = 0;
          v49[195]  = v49 + 187;
          *((_DWORD *)v49 + 392)  = 0;
          v49[197]  = 0;
          *((_DWORD *)v49 + 396)  = 0;
          v49[199]  = 0;
          *((_DWORD *)v49 + 400)  = 0;
          v49[201]  = 0;
          *((_DWORD *)v49 + 404)  = 0;
          v49[203]  = 0;
        }
        uint64_t v48 = *(void *)v842;
        if (*(void *)v842)
        {
LABEL_56:
          if (v27 == 1835361385)
          {
            uint64_t v50 = v48 + 1584;
          }
          else if (v27 == 1768843636)
          {
            uint64_t v50 = v48 + 1568;
          }
          else
          {
            uint64_t v61 = v48 + 1600;
            uint64_t v62 = v48 + 1616;
            uint64_t v50 = v27 == 1718185569 ? v61 : v62;
          }
          char v63 = (unsigned __int16 *)((char *)v806 + (bswap32(v806[v34 + 1]) >> 16));
          if (v63 + 3 <= v843)
          {
            unint64_t v64 = (unint64_t)&v63[(bswap32(v63[2]) >> 16) + 3] + (((unint64_t)v63[1] >> 11) & 2);
            BOOL v65 = v64 < (unint64_t)v63 || v64 > (unint64_t)v843;
            int v16 = v826;
            if (!v65)
            {
              *(void *)v893  = 0xAAAAAAAAAAAAAAAALL;
              int v66 = (unsigned __int16)ResolveLookupSubtable(v63, (unint64_t)v843, v893);
              *(_DWORD *)uint64_t v50 = v66;
              *(void *)(v50 + 8)  = v67;
              if (*(void *)v893 < 2uLL)
              {
                if (v66)
                {
                  *(_WORD *)&v852[22]  = 1000;
                  int v59 = 2;
                  goto LABEL_224;
                }
              }
              else
              {
                *(_DWORD *)uint64_t v50 = 0;
              }
            }
            int v59 = 1;
LABEL_224:
            long long v23 = 0uLL;
            goto LABEL_225;
          }
        }
      }
      int v59 = 1;
LABEL_88:
      int v16 = v826;
      goto LABEL_224;
    }
    v825  = v21;
    unint64_t v35 = v20;
    int v36 = *v25;
    uint64_t v37 = (uint64_t *)(*v25)[1];
    id v38 = *v25;
    if (v37)
    {
      do
      {
        int v39 = v37;
        uint64_t v37 = (uint64_t *)*v37;
      }
      while (v37);
    }
    else
    {
      do
      {
        int v39 = (uint64_t *)v38[2];
        BOOL v13 = *v39 == (void)v38;
        id v38 = v39;
      }
      while (!v13);
    }
    if (v39 == (uint64_t *)(v24 + 48))
    {
      std::__tree<std::__value_type<unsigned int,std::set<unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::set<unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::set<unsigned int>>>>::erase(v17, v24);
      goto LABEL_60;
    }
    if (*((unsigned char *)v39 + 28) == 32)
    {
      std::__tree<unsigned int>::__remove_node_pointer(v25, *v25);
      operator delete(v36);
LABEL_60:
      *(void *)v893  = 0xAAAAAAAAAAAAAAAALL;
      LanguagesWithLangSysTag(v27, (CFArrayRef *)v893);
      CFArrayRef explicit = (const __CFArray *)atomic_load_explicit((atomic_ullong *volatile)v893, memory_order_acquire);
      unint64_t v20 = v35;
      if (!explicit || (CFStringRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(explicit, 0)) == 0)
      {

        int v59 = 1;
        int v16 = v826;
        goto LABEL_223;
      }
      id v53 = ValueAtIndex;
      v823  = v19;
      CFIndex v55 = *(atomic_ullong **)(v14 + 152);
      CFIndex v54 = *(atomic_ullong **)(v14 + 160);
      if (v55 != v54)
      {
        while (1)
        {
          id v56 = (id)atomic_load_explicit(v55, memory_order_acquire);
          if (v56 == v53) {
            break;
          }
          id v57 = v56;
          if (v56)
          {
            int v58 = CFEqual(v56, v53);

            if (v58) {
              goto LABEL_95;
            }
          }
          else
          {
          }
          if (++v55 == v54)
          {
            CFIndex v55 = v54;
            goto LABEL_95;
          }
        }

LABEL_95:
        unint64_t v20 = v35;
      }
      if (v55 == *(atomic_ullong **)(v14 + 160))
      {
        v900[0]  = v53;
        CFIndex v70 = *(void **)(v14 + 160);
        unint64_t v69 = *(void *)(v14 + 168);
        if ((unint64_t)v70 >= v69)
        {
          uint64_t v72 = *(void *)(v14 + 152);
          uint64_t v73 = ((uint64_t)v70 - v72) >> 3;
          if ((unint64_t)(v73 + 1) >> 61) {
LABEL_1145:
          }
            abort();
          uint64_t v74 = v69 - v72;
          uint64_t v75 = v74 >> 2;
          if (v74 >> 2 <= (unint64_t)(v73 + 1)) {
            uint64_t v75 = v73 + 1;
          }
          if ((unint64_t)v74 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v76 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v76 = v75;
          }
          if (v76) {
            uint64_t v77 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate(v35, v76);
          }
          else {
            uint64_t v77 = 0;
          }
          char v78 = &v77[8 * v73];
          unsigned int v79 = &v77[8 * v76];
          *(void *)char v78 = atomic_exchange((atomic_ullong *volatile)v900, 0);
          unsigned int v71 = v78 + 8;
          uint64_t v80 = *(atomic_ullong **)(v14 + 152);
          BOOL v81 = *(atomic_ullong **)(v14 + 160);
          if (v81 == v80)
          {
            *(void *)(v14 + 152)  = v78;
            *(void *)(v14 + 160)  = v71;
            CFURLRef v83 = *(atomic_ullong **)(v14 + 168);
            *(void *)(v14 + 168)  = v79;
          }
          else
          {
            do
            {
              *((void *)v78 - 1)  = atomic_exchange(--v81, 0);
              v78 -= 8;
            }
            while (v81 != v80);
            BOOL v81 = *(atomic_ullong **)(v14 + 152);
            CFAllocatorRef v82 = *(atomic_ullong **)(v14 + 160);
            *(void *)(v14 + 152)  = v78;
            *(void *)(v14 + 160)  = v71;
            CFURLRef v83 = *(atomic_ullong **)(v14 + 168);
            *(void *)(v14 + 168)  = v79;
            if (v82 != v81)
            {
              do
              {
                CFIndex v84 = v82 - 1;

                CFAllocatorRef v82 = v84;
              }
              while (v84 != v81);
            }
          }
          if (v81)
          {
            if (v35 > (unint64_t)v81 || v831 <= (atomic_ullong **)v81)
            {
              operator delete(v81);
            }
            else if (v83 == *v831)
            {
              *v831  = v81;
            }
          }
        }
        else
        {
          *CFIndex v70 = atomic_exchange((atomic_ullong *volatile)v900, 0);
          unsigned int v71 = v70 + 1;
        }
        *(void *)(v14 + 160)  = v71;

        CFIndex v55 = (atomic_ullong *)(*(void *)(v14 + 160) - 8);
        unint64_t v20 = v35;
      }
      strcpy(&v852[4], "'");
      *(_WORD *)&v852[6]  = ((v55 - *(_DWORD *)(v14 + 152)) >> 3) + 1;
      *(_DWORD *)&v852[8]  = 1;

      int v19 = v823;
      CFIndex v68 = v827;
      long long v23 = 0uLL;
LABEL_122:
      unint64_t v85 = (unint64_t)v806 + (bswap32(v806[v34 + 1]) >> 16);
      *(void *)&v852[24]  = v85;
      if (v85 + 4 < v805 || v85 + 6 > (unint64_t)v843)
      {
        int v59 = 1;
        int v16 = v826;
      }
      else
      {
        v824  = v20;
        unint64_t v87 = v85
            + 2 * (bswap32(*(unsigned __int16 *)(v85 + 4)) >> 16)
            + (((unint64_t)*(unsigned __int16 *)(v85 + 2) >> 11) & 2)
            + 6;
        if (v85 < v805 || v87 < v85 || v87 > (unint64_t)v843)
        {
          int v59 = 1;
          int v16 = v826;
        }
        else
        {
          unint64_t v90 = *(void *)(v14 + 48);
          if (v90)
          {
            uint8x8_t v91 = (uint8x8_t)vcnt_s8((int8x8_t)v90);
            v91.i16[0]  = vaddlv_u8(v91);
            if (v91.u32[0] > 1uLL)
            {
              unint64_t v92 = v34;
              if (v90 <= v34) {
                unint64_t v92 = v34 % v90;
              }
            }
            else
            {
              unint64_t v92 = (v90 - 1) & v34;
            }
            id v93 = *(void ***)(*v825 + 8 * v92);
            if (v93)
            {
              id v94 = *v93;
              if (*v93)
              {
                id v95 = v828;
                do
                {
                  unint64_t v96 = v94[1];
                  if (v96 == v34)
                  {
                    if (*((_DWORD *)v94 + 4) == v34)
                    {
                      int v16 = v826;
                      goto LABEL_173;
                    }
                  }
                  else
                  {
                    if (v91.u32[0] > 1uLL)
                    {
                      if (v96 >= v90) {
                        v96 %= v90;
                      }
                    }
                    else
                    {
                      v96 &= v90 - 1;
                    }
                    if (v96 != v92) {
                      break;
                    }
                  }
                  id v94 = (void *)*v94;
                }
                while (v94);
              }
            }
          }
          else
          {
            unint64_t v92 = 0xAAAAAAAAAAAAAAAALL;
          }
          id v94 = operator new(0x18uLL);
          *id v94 = 0;
          v94[1]  = v34;
          *((_DWORD *)v94 + 4)  = v34;
          *((_DWORD *)v94 + 5)  = 0;
          float v97 = (float)(unint64_t)(*(void *)(v14 + 64) + 1);
          float v98 = *(float *)(v14 + 72);
          if (!v90 || (float)(v98 * (float)v90) < v97)
          {
            BOOL v99 = (v90 & (v90 - 1)) != 0;
            if (v90 < 3) {
              BOOL v99 = 1;
            }
            unint64_t v100 = v99 | (2 * v90);
            unint64_t v101 = vcvtps_u32_f32(v97 / v98);
            if (v100 <= v101) {
              size_t v102 = v101;
            }
            else {
              size_t v102 = v100;
            }
            std::__hash_table<std::__hash_value_type<TRun const*,long>,std::__unordered_map_hasher<TRun const*,std::__hash_value_type<TRun const*,long>,std::hash<TRun const*>,std::equal_to<TRun const*>,true>,std::__unordered_map_equal<TRun const*,std::__hash_value_type<TRun const*,long>,std::equal_to<TRun const*>,std::hash<TRun const*>,true>,std::allocator<std::__hash_value_type<TRun const*,long>>>::__rehash<true>((uint64_t)v825, v102);
            unint64_t v90 = *(void *)(v14 + 48);
            if ((v90 & (v90 - 1)) != 0)
            {
              if (v90 <= v34) {
                unint64_t v92 = v34 % v90;
              }
              else {
                unint64_t v92 = v34;
              }
            }
            else
            {
              unint64_t v92 = (v90 - 1) & v34;
            }
          }
          uint64_t v103 = *v825;
          CFRange v104 = *(void **)(*v825 + 8 * v92);
          id v95 = v828;
          if (v104)
          {
            *id v94 = *v104;
            int v16 = v826;
            goto LABEL_171;
          }
          *id v94 = *v68;
          *CFIndex v68 = v94;
          *(void *)(v103 + 8 * v92)  = v68;
          int v16 = v826;
          if (*v94)
          {
            unint64_t v105 = *(void *)(*v94 + 8);
            if ((v90 & (v90 - 1)) != 0)
            {
              if (v105 >= v90) {
                v105 %= v90;
              }
            }
            else
            {
              v105 &= v90 - 1;
            }
            CFRange v104 = (void *)(*v825 + 8 * v105);
LABEL_171:
            *CFRange v104 = v94;
          }
          ++*(void *)(v14 + 64);
LABEL_173:
          unint64_t v20 = v824;
          if ((*((_DWORD *)v94 + 5) & 0x80000000) != 0) {
            *(_WORD *)&v852[20]  = 1;
          }
          *(_WORD *)&v852[22]  = ResolveLookupSubtable(*(unsigned __int16 **)&v852[24], (unint64_t)v843, v95);
          *(void *)&v852[40]  = v106;
          if (!*(_WORD *)&v852[22])
          {
            int v59 = 1;
            goto LABEL_223;
          }
          long long v23 = 0uLL;
          if (*(void *)&v852[32])
          {
            if (*(void *)&v852[32] == 1)
            {
              uint64_t v107 = *(void *)&v852[24];
              memset(__dst, 0, 24);
              if ((*(_WORD *)(*(void *)&v852[24] + 2) & 0x1EFF) != 0)
              {
                CFDataRef CommonTable = (const __CFData *)TBaseFont::GetCommonTable(v15, 1195656518, 0);
                if (CommonTable)
                {
                  *(void *)&long long v109 = 0xAAAAAAAAAAAAAAAALL;
                  *((void *)&v109 + 1)  = 0xAAAAAAAAAAAAAAAALL;
                  *(_OWORD *)&v893[64]  = v109;
                  *(_OWORD *)&v893[48]  = v109;
                  *(_OWORD *)&v893[32]  = v109;
                  *(_OWORD *)&v893[16]  = v109;
                  *(_OWORD *)v893  = v109;
                  OTL::GDEF::GDEF((OTL::GDEF *)v893, CommonTable);
                  v900[0]  = &unk_1ED060308;
                  v900[1]  = __dst;
                  v900[3]  = v900;
                  OTL::GDEF::IterateGlyphsIgnoredByLookupTable((OTL::Coverage *)v893, v107, (uint64_t)v900);
                  std::__function::__value_func<void ()(unsigned short)>::~__value_func[abi:nn180100](v900);
                  LOBYTE(v854)  = -86;
                  std::__sort<std::__less<unsigned short,unsigned short> &,unsigned short *>();
                  double v110 = (unsigned __int16 *)__dst[1];
                  if (__dst[0] != __dst[1])
                  {
                    CFDictionaryRef v111 = (unsigned __int16 *)((char *)__dst[0] + 2);
                    while (v111 != __dst[1])
                    {
                      int v112 = *(v111 - 1);
                      int v113 = *v111++;
                      if (v112 == v113)
                      {
                        char v114 = v111 - 2;
                        while (v111 != v110)
                        {
                          int v115 = v112;
                          int v112 = *v111;
                          if (v115 != v112)
                          {
                            v114[1]  = v112;
                            ++v114;
                          }
                          ++v111;
                        }
                        double v116 = v114 + 1;
                        goto LABEL_194;
                      }
                    }
                  }
                  double v116 = (unsigned __int16 *)__dst[1];
LABEL_194:
                  if (v110 != v116) {
                    __dst[1]  = v116;
                  }
                  unint64_t v20 = v824;
                }
              }
              if (*(void *)&v852[48])
              {
                *(void *)&v852[56]  = *(void *)&v852[48];
                operator delete(*(void **)&v852[48]);
              }
              *(_OWORD *)&v852[48]  = *(_OWORD *)__dst;
              *(void **)&v852[64]  = __dst[2];
              if (*(unsigned __int16 *)&v852[22] == 3)
              {
                LOWORD(__dst[0])  = 0;
                if (*(void *)&v852[32])
                {
                  unint64_t v117 = 0;
                  do
                  {
                    int v118 = (unsigned __int16 *)v843;
                    if ((ResolveLookupSubtableWithIndex(*(unsigned __int16 **)&v852[24], v117, (unint64_t)v843) & 0xFFFD) != 1) {
                      goto LABEL_222;
                    }
                    v900[0]  = v119;
                    CFDictionaryRef v120 = v119 + 3;
                    if (v119 + 3 > v118) {
                      goto LABEL_222;
                    }
                    uint64_t v121 = bswap32(v119[2]) >> 16;
                    unint64_t v122 = (unint64_t)&v120[v121];
                    unint64_t v123 = v119 + 4 <= v118 ? (unint64_t)((char *)v118 - (char *)v120) >> 1 : 0;
                    BOOL v124 = v122 <= (unint64_t)v118 && v122 >= (unint64_t)v120;
                    if (!v124 && v123 != v121) {
                      goto LABEL_222;
                    }
                    OTL::LookupWithCoverage::GetCoverage((OTL::Coverage *)v119, (unint64_t)v118, (uint64_t)v893);
                    long long v126 = operator new(0x20uLL);
                    *long long v126 = &unk_1ED060A10;
                    v126[1]  = v900;
                    v126[2]  = &v843;
                    v126[3]  = __dst;
                    v901[3]  = v126;
                    char v127 = OTL::Coverage::Iterate(v893, (uint64_t)v901);
                    std::__function::__value_func<BOOL ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100](v901);
                    if ((v127 & 1) == 0)
                    {
LABEL_222:
                      int v59 = 1;
                      unint64_t v20 = v824;
                      goto LABEL_223;
                    }
                    ++v117;
                  }
                  while (v117 < *(void *)&v852[32]);
                  unint64_t v20 = v824;
                  if ((v852[8] & 0x40) != 0 && LOWORD(__dst[0]) >= 2u)
                  {
                    unsigned int v128 = 1;
                    do
                    {
                      *(_WORD *)&v852[6]  = ++v128;
                    }
                    while (v128 < LOWORD(__dst[0]));
                  }
                }
              }
              int v59 = 0;
LABEL_223:
              int v21 = v825;
              goto LABEL_224;
            }
            int v59 = 1;
          }
          else
          {
            int v59 = 2;
          }
        }
      }
    }
    else
    {
      int v59 = 1;
      int v16 = v826;
      unint64_t v20 = v35;
    }
    int v21 = v825;
LABEL_225:
    if (*(void *)&v852[48])
    {
      *(void *)&v852[56]  = *(void *)&v852[48];
      operator delete(*(void **)&v852[48]);
      long long v23 = 0uLL;
    }
    if ((v59 | 2) != 2) {
      goto LABEL_282;
    }
    long long v18 = v828;
    BOOL v22 = v827;
  }
  while (*(void *)(v14 + 96));
  if ((v16 & 0x1000) != 0)
  {
    uint64_t v131 = (__n128 *)v902;
    uint64_t v132 = v903;
    if (v902 != v903)
    {
      while (v131->n128_u32[0] != 1986359924)
      {
        uint64_t v131 = (__n128 *)((char *)v131 + 72);
        if (v131 == v903) {
          goto LABEL_252;
        }
      }
      if (v131 != v903)
      {
        id v133 = (__n128 *)((char *)v131 + 72);
        if (&v131[4].n128_i8[8] != (__int8 *)v903)
        {
          do
          {
            if (v133->n128_u32[0] != 1986359924)
            {
              __n128 v134 = *v133;
              __n128 v135 = v133[2];
              v131[1]  = v133[1];
              v131[2]  = v135;
              __n128 *v131 = v134;
              std::vector<unsigned short>::__move_assign((uint64_t)&v131[3], v133 + 3);
              uint64_t v131 = (__n128 *)((char *)v131 + 72);
            }
            id v133 = (__n128 *)((char *)v133 + 72);
          }
          while (v133 != v132);
          uint64_t v132 = v903;
        }
      }
      if (v131 != v132)
      {
        while (v132 != v131)
        {
          uint64_t v136 = (void *)v132[-2].n128_u64[1];
          if (v136)
          {
            v132[-1].n128_u64[0]  = (unint64_t)v136;
            operator delete(v136);
          }
          uint64_t v132 = (__n128 *)((char *)v132 - 72);
        }
        v903  = v131;
      }
    }
  }
LABEL_252:
  if (!*(void *)v842) {
    goto LABEL_294;
  }
  if (!*(void *)(*(void *)v842 + 1576)
    || !*(void *)(*(void *)v842 + 1592)
    || !*(void *)(*(void *)v842 + 1608))
  {
LABEL_282:
    uint64_t v129 = 0;
    goto LABEL_1133;
  }
  uint64_t v137 = (__n128 *)v902;
  long long v138 = v903;
  if (v902 == v903)
  {
    uint64_t v140 = -1;
  }
  else
  {
    uint64_t v139 = 0;
    do
    {
      if (v137[1].n128_u16[3] == 1000) {
        ++v139;
      }
      uint64_t v137 = (__n128 *)((char *)v137 + 72);
    }
    while (v137 != v903);
    uint64_t v140 = v139 - 1;
    if (v139 == 1) {
      goto LABEL_276;
    }
  }
  do
  {
    long long v141 = (__n128 *)v902;
    uint64_t v142 = v138;
    while (v142 != v902)
    {
      CFRange v143 = &v142[-5].n128_i8[8];
      int v144 = v142[-4].n128_u16[7];
      uint64_t v142 = (__n128 *)((char *)v142 - 72);
      if (v144 == 1000)
      {
        long long v141 = (__n128 *)(v143 + 72);
        break;
      }
    }
    long long v145 = (__n128 *)((char *)v141 - 72);
    if (v141 != v138)
    {
      do
      {
        long long v146 = &v145[4].n128_i8[8];
        __n128 v147 = *(__n128 *)((char *)v145 + 88);
        *long long v145 = *(__n128 *)((char *)v145 + 72);
        v145[1]  = v147;
        v145[2]  = *(__n128 *)((char *)v145 + 104);
        std::vector<unsigned short>::__move_assign((uint64_t)&v145[3], (__n128 *)((char *)v145 + 120));
        long long v148 = v145 + 9;
        long long v145 = (__n128 *)((char *)v145 + 72);
      }
      while (v148 != v138);
      long long v138 = v903;
      long long v145 = (__n128 *)v146;
    }
    while (v138 != v145)
    {
      long long v149 = (void *)v138[-2].n128_u64[1];
      if (v149)
      {
        v138[-1].n128_u64[0]  = (unint64_t)v149;
        operator delete(v149);
      }
      long long v138 = (__n128 *)((char *)v138 - 72);
    }
    v903  = v145;
    long long v138 = v145;
    --v140;
  }
  while (v140);
LABEL_276:
  *(_DWORD *)v893  = 1919707495;
  long long v150 = std::__tree<std::__value_type<unsigned int,std::unordered_set<unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::unordered_set<unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::unordered_set<unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(v19, 0x726C6967u, v893);
  *(_DWORD *)v893  = 1919118452;
  long long v151 = std::__tree<std::__value_type<unsigned int,std::unordered_set<unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::unordered_set<unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::unordered_set<unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(v19, 0x72636C74u, v893);
  *(_DWORD *)v893  = 1667329140;
  long long v152 = std::__tree<std::__value_type<unsigned int,std::unordered_set<unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::unordered_set<unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::unordered_set<unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(v19, 0x63616C74u, v893);
  *(_DWORD *)v893  = 1634885986;
  if (std::__hash_table<std::__hash_value_type<unsigned int,OTL::Lookup>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,OTL::Lookup>>>::find<unsigned int>(v150 + 5, (unsigned int *)v893))
  {
    *(_DWORD *)v852  = 1634885986;
    if (std::__hash_table<std::__hash_value_type<unsigned int,OTL::Lookup>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,OTL::Lookup>>>::find<unsigned int>(v151 + 5, (unsigned int *)v852)|| (LODWORD(v900[0])  = 1634885986, std::__hash_table<std::__hash_value_type<unsigned int,OTL::Lookup>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,OTL::Lookup>>>::find<unsigned int>(v152 + 5, (unsigned int *)v900)))
    {
      if ((unint64_t)v150[8] > 1 || (unint64_t)v151[8] > 1 || (unint64_t)v152[8] > 1) {
        goto LABEL_282;
      }
      uint64_t v153 = (__n128 *)v902;
      if (v902 != v903)
      {
        while (1)
        {
          unsigned __int32 v154 = v153->n128_u32[0];
          BOOL v155 = v153->n128_u32[0] == 1667329140 || v154 == 1919118452;
          if (v155 || v154 == 1919707495) {
            break;
          }
          uint64_t v153 = (__n128 *)((char *)v153 + 72);
          if (v153 == v903)
          {
            uint64_t v153 = v903;
            break;
          }
        }
      }
    }
  }
LABEL_294:
  memset(v900, 170, 0x3A8uLL);
  LODWORD(v900[0])  = 0;
  memset(&v900[1], 0, 24);
  v900[49]  = &v900[4];
  memset(&v900[50], 0, 24);
  v900[83]  = &v900[53];
  memset(&v900[84], 0, 24);
  v900[117]  = &v900[87];
  *(void *)&long long v158 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v158 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  v898[3]  = v158;
  v898[2]  = v158;
  v898[1]  = v158;
  v898[0]  = v158;
  v895  = 0;
  v896  = 0;
  v897  = 0;
  v899  = v898;
  GlyphCFIndex Count = TBaseFont::GetGlyphCount(v15);
  uint64_t v159 = (__n128 *)v902;
  long long v160 = v903;
  if (v902 != v903)
  {
    v832  = 0;
    allocator  = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    unint64_t v161 = (GlyphCount + 7) >> 3;
    if (GlyphCount > 0x10000) {
      unint64_t v161 = 0x2000;
    }
    CFIndex length = v161;
    v821  = v903;
    while (2)
    {
      long long v162 = v159;
      long long v164 = &v159->n128_u16[2];
      unint64_t v163 = *(unint64_t *)((char *)v159->n128_u64 + 4);
      long long v165 = (unsigned __int16 *)v900[1];
      unint64_t v166 = HIDWORD(v163);
      v829  = v159;
      if (v900[1] != v900[2])
      {
        while (*v165 != (unsigned __int16)v163 || v165[1] != WORD1(v163))
        {
          v165 += 6;
          if (v165 == v900[2]) {
            goto LABEL_306;
          }
        }
      }
      if (v165 != v900[2])
      {
        *(unint64_t *)((char *)&v159->n128_u64[1] + 4)  = *(void *)(v165 + 2);
        uint64_t v159 = (__n128 *)((char *)v159 + 72);
        if ((v163 & 0x200000000) == 0) {
          goto LABEL_376;
        }
LABEL_375:
        LODWORD(v900[0]) |= v162->n128_u32[3];
        goto LABEL_376;
      }
LABEL_306:
      long long v167 = (__n128 *)((char *)v159 + 72);
      do
      {
        v168  = v167;
        if (v167 == v160 || (v163 & 0x4000000000) != 0) {
          break;
        }
        v169  = v167[1].n128_u64[1];
        v170  = v167->n128_u16[2];
        long long v167 = (__n128 *)((char *)v167 + 72);
      }
      while (v169 == v159[1].n128_u64[1] && v170 == (unsigned __int16)v163);
      if (v832)
      {
        int v172 = 2 * v832;
        if (!(2 * v832))
        {
          LODWORD(v900[0])  = 0;
          long long v173 = (id *)v900[50];
          v900[2]  = v900[1];
          long long v174 = (id *)v900[51];
          if (v900[51] != v900[50])
          {
            do
            {
              long long v175 = v174 - 1;

              long long v174 = v175;
            }
            while (v175 != v173);
          }
          v900[51]  = v173;
          long long v176 = (id *)v900[85];
          long long v177 = (id *)v900[84];
          if (v900[85] != v900[84])
          {
            do
            {
              long long v178 = v176 - 1;

              long long v176 = v178;
            }
            while (v178 != v177);
          }
          v900[85]  = v177;
          v896  = v895;
          long long v162 = v159;
          LODWORD(v166)  = v159->n128_u32[2];
          int v172 = 1;
        }
      }
      else
      {
        int v172 = 1;
      }
      v162->n128_u32[3]  = v172;
      v162[1].n128_u32[0]  = -1;
      if (v166)
      {
        v179  = (unsigned __int16 *)v900[1];
        long long v180 = (unsigned __int16 *)v900[2];
        if (v900[1] == v900[2])
        {
          int v181 = 0;
        }
        else
        {
          int v181 = 0;
          int v182 = *v164;
          do
          {
            if (*v179 == v182)
            {
              int v183 = *((_DWORD *)v179 + 1);
              *((_DWORD *)v179 + 2) &= ~v172;
              v181 |= v183;
            }
            v179 += 6;
          }
          while (v179 != v180);
        }
        v162[1].n128_u32[0]  = ~v181;
        double v184 = v895;
        if (v895 != v896)
        {
          while (*v184 != *v164)
          {
            if (++v184 == v896)
            {
              double v184 = v896;
              break;
            }
          }
        }
        if (v184 == v896)
        {
          STL::insert_sorted<TInlineVector<unsigned short,30ul>>(&v895, &v159->n128_i8[4]);
          long long v162 = v159;
        }
      }
      double v185 = (__n128 *)((char *)v168 - 72);
      v832  = v172;
      int v186 = ~v172;
      uint64_t v187 = (char *)v900[2];
      uint64_t v188 = v162;
      do
      {
        unsigned __int16 v189 = v162->n128_u16[2];
        v190  = v188->n128_i16[3];
        v191  = v162[1].n128_u32[0];
        if (v187 >= v900[3])
        {
          uint64_t v192 = (char *)v900[1];
          v193  = 0xAAAAAAAAAAAAAAABLL * ((v187 - (char *)v900[1]) >> 2);
          unint64_t v194 = v193 + 1;
          if (v193 + 1 > 0x1555555555555555) {
            goto LABEL_1145;
          }
          if (0x5555555555555556 * (((char *)v900[3] - (char *)v900[1]) >> 2) > v194) {
            unint64_t v194 = 0x5555555555555556 * (((char *)v900[3] - (char *)v900[1]) >> 2);
          }
          if (0xAAAAAAAAAAAAAAABLL * (((char *)v900[3] - (char *)v900[1]) >> 2) >= 0xAAAAAAAAAAAAAAALL) {
            v195  = 0x1555555555555555;
          }
          else {
            v195  = v194;
          }
          *(void *)&v893[32]  = &v900[4];
          if (v195)
          {
            double v196 = TInlineBufferAllocator<MortFeatureEntry,30ul>::allocate((uint64_t)&v900[4], v195);
            uint64_t v187 = (char *)v900[2];
            uint64_t v192 = (char *)v900[1];
          }
          else
          {
            double v196 = 0;
          }
          double v197 = &v196[12 * v193];
          *(_WORD *)double v197 = v189;
          *((_WORD *)v197 + 1)  = v190;
          *((_DWORD *)v197 + 1)  = v832;
          *((_DWORD *)v197 + 2)  = v191;
          if (v187 == v192)
          {
            int64x2_t v201 = vdupq_n_s64((unint64_t)v192);
            double v198 = &v196[12 * v193];
          }
          else
          {
            double v198 = &v196[12 * v193];
            do
            {
              uint64_t v199 = *(void *)(v187 - 12);
              v187 -= 12;
              int v200 = *((_DWORD *)v187 + 2);
              *(void *)(v198 - 12)  = v199;
              v198 -= 12;
              *((_DWORD *)v198 + 2)  = v200;
            }
            while (v187 != v192);
            int64x2_t v201 = *(int64x2_t *)&v900[1];
          }
          uint64_t v187 = v197 + 12;
          v900[1]  = v198;
          v900[2]  = v197 + 12;
          *(int64x2_t *)&v893[8]  = v201;
          id v202 = v900[3];
          v900[3]  = &v196[12 * v195];
          *(void *)&v893[24]  = v202;
          *(void *)v893  = v201.i64[0];
          std::__split_buffer<MortFeatureEntry,TInlineBufferAllocator<MortFeatureEntry,30ul> &>::~__split_buffer((uint64_t)v893);
          long long v162 = v829;
        }
        else
        {
          *(_WORD *)uint64_t v187 = v189;
          *((_WORD *)v187 + 1)  = v190;
          *((_DWORD *)v187 + 1)  = v832;
          *((_DWORD *)v187 + 2)  = v191;
          v187 += 12;
        }
        v900[2]  = v187;
        if ((v162->n128_u8[8] & 1) == 0)
        {
          unsigned __int16 v203 = *v164;
          __int16 v204 = v188->n128_u16[3] + 1;
          if (v187 >= v900[3])
          {
            char v205 = (char *)v900[1];
            unint64_t v206 = 0xAAAAAAAAAAAAAAABLL * ((v187 - (char *)v900[1]) >> 2);
            v207  = v206 + 1;
            if (v206 + 1 > 0x1555555555555555) {
              goto LABEL_1145;
            }
            if (0x5555555555555556 * (((char *)v900[3] - (char *)v900[1]) >> 2) > v207) {
              v207  = 0x5555555555555556 * (((char *)v900[3] - (char *)v900[1]) >> 2);
            }
            if (0xAAAAAAAAAAAAAAABLL * (((char *)v900[3] - (char *)v900[1]) >> 2) >= 0xAAAAAAAAAAAAAAALL) {
              unint64_t v208 = 0x1555555555555555;
            }
            else {
              unint64_t v208 = v207;
            }
            *(void *)&v893[32]  = &v900[4];
            if (v208)
            {
              CGFloat v209 = TInlineBufferAllocator<MortFeatureEntry,30ul>::allocate((uint64_t)&v900[4], v208);
              uint64_t v187 = (char *)v900[2];
              char v205 = (char *)v900[1];
            }
            else
            {
              CGFloat v209 = 0;
            }
            int v210 = &v209[12 * v206];
            *(_WORD *)int v210 = v203;
            *((_WORD *)v210 + 1)  = v204;
            *((_DWORD *)v210 + 1)  = 0;
            *((_DWORD *)v210 + 2)  = v186;
            if (v187 == v205)
            {
              int64x2_t v214 = vdupq_n_s64((unint64_t)v205);
              v211  = &v209[12 * v206];
            }
            else
            {
              v211  = &v209[12 * v206];
              do
              {
                v212  = *(void *)(v187 - 12);
                v187 -= 12;
                v213  = *((_DWORD *)v187 + 2);
                *(void *)(v211 - 12)  = v212;
                v211 -= 12;
                *((_DWORD *)v211 + 2)  = v213;
              }
              while (v187 != v205);
              int64x2_t v214 = *(int64x2_t *)&v900[1];
            }
            uint64_t v187 = v210 + 12;
            v900[1]  = v211;
            v900[2]  = v210 + 12;
            *(int64x2_t *)&v893[8]  = v214;
            v215  = v900[3];
            v900[3]  = &v209[12 * v208];
            *(void *)&v893[24]  = v215;
            *(void *)v893  = v214.i64[0];
            std::__split_buffer<MortFeatureEntry,TInlineBufferAllocator<MortFeatureEntry,30ul> &>::~__split_buffer((uint64_t)v893);
            long long v162 = v829;
          }
          else
          {
            *(_WORD *)uint64_t v187 = v203;
            *((_WORD *)v187 + 1)  = v204;
            *((_DWORD *)v187 + 1)  = 0;
            *((_DWORD *)v187 + 2)  = v186;
            v187 += 12;
          }
          v900[2]  = v187;
        }
        uint64_t v159 = (__n128 *)((char *)v188 + 72);
        BOOL v13 = v185 == v188;
        uint64_t v188 = (__n128 *)((char *)v188 + 72);
      }
      while (!v13);
      LODWORD(v166)  = v162->n128_u32[2];
      long long v160 = v821;
      if ((v166 & 2) != 0) {
        goto LABEL_375;
      }
LABEL_376:
      uint64_t v129 = 0;
      v216  = ~(v166 << 26) & 0x80000000;
      if ((v166 & 0x30) == 0) {
        v216  = 0x20000000;
      }
      if (v162[1].n128_u16[2]) {
        v217  = v216 | 0x40000000;
      }
      else {
        v217  = v216;
      }
      switch(v162[1].n128_u16[3])
      {
        case 1u:
          *(void *)v852  = 0xAAAAAAAAAAAAAAAALL;
          *(void *)&v852[8]  = 0;
          *(void *)&v852[16]  = 0;
          LOBYTE(v219)  = v218;
          if (!v218) {
            goto LABEL_442;
          }
          uint64_t v220 = v900[51];
          if (v900[51] >= v900[52])
          {
            v316  = ((char *)v900[51] - (char *)v900[50]) >> 3;
            if ((unint64_t)(v316 + 1) >> 61) {
              goto LABEL_1145;
            }
            v317  = ((char *)v900[52] - (char *)v900[50]) >> 2;
            if (v317 <= v316 + 1) {
              v317  = v316 + 1;
            }
            if ((id)((char *)v900[52] - (char *)v900[50]) >= (id)0x7FFFFFFFFFFFFFF8) {
              v318  = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              v318  = v317;
            }
            *(void *)&v893[32]  = &v900[53];
            if (v318) {
              v319  = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&v900[53], v318);
            }
            else {
              v319  = 0;
            }
            *(void *)v893  = v319;
            *(void *)&v893[8]  = &v319[8 * v316];
            *(void *)&v893[16]  = *(void *)&v893[8];
            *(void *)&v893[24]  = &v319[8 * v318];
            **(void **)&v893[8]  = atomic_exchange((atomic_ullong *volatile)__dst, 0);
            v365  = *(char **)&v893[8];
            v221  = (void *)(*(void *)&v893[16] + 8);
            *(void *)&v893[16] += 8;
            v366  = (atomic_ullong *)v900[51];
            v367  = (atomic_ullong *)v900[50];
            if (v900[51] == v900[50])
            {
              v368  = vdupq_n_s64((unint64_t)v900[51]);
            }
            else
            {
              do
              {
                *((void *)v365 - 1)  = atomic_exchange(--v366, 0);
                v365 -= 8;
              }
              while (v366 != v367);
              v368  = *(int64x2_t *)&v900[50];
              v221  = *(void **)&v893[16];
            }
            v900[50]  = v365;
            v900[51]  = v221;
            *(int64x2_t *)&v893[8]  = v368;
            v373  = v900[52];
            v900[52]  = *(id *)&v893[24];
            *(void *)&v893[24]  = v373;
            *(void *)v893  = v368.i64[0];
            std::__split_buffer<TCFRef<__CFData *>,TInlineBufferAllocator<TCFRef<__CFData *>,30ul> &>::~__split_buffer((uint64_t)v893);
          }
          else
          {
            *uint64_t v220 = atomic_exchange((atomic_ullong *volatile)__dst, 0);
            v221  = v220 + 1;
          }
          v900[51]  = v221;

          __dst[0]  = (id)atomic_load_explicit((atomic_ullong *volatile)&v852[8], memory_order_acquire);
          v374  = v900[85];
          if (v900[85] < v900[86]) {
            goto LABEL_586;
          }
          v375  = ((char *)v900[85] - (char *)v900[84]) >> 3;
          if ((unint64_t)(v375 + 1) >> 61) {
            goto LABEL_1145;
          }
          v376  = ((char *)v900[86] - (char *)v900[84]) >> 2;
          if (v376 <= v375 + 1) {
            v376  = v375 + 1;
          }
          if ((id)((char *)v900[86] - (char *)v900[84]) >= (id)0x7FFFFFFFFFFFFFF8) {
            v377  = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            v377  = v376;
          }
          *(void *)&v893[32]  = &v900[87];
          if (v377) {
            v378  = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&v900[87], v377);
          }
          else {
            v378  = 0;
          }
          *(void *)v893  = v378;
          *(void *)&v893[8]  = &v378[8 * v375];
          *(void *)&v893[16]  = *(void *)&v893[8];
          *(void *)&v893[24]  = &v378[8 * v377];
          **(void **)&v893[8]  = atomic_exchange((atomic_ullong *volatile)__dst, 0);
          v385  = *(char **)&v893[8];
          v380  = (void *)(*(void *)&v893[16] + 8);
          *(void *)&v893[16] += 8;
          v386  = (atomic_ullong *)v900[85];
          v387  = (atomic_ullong *)v900[84];
          if (v900[85] == v900[84]) {
            goto LABEL_603;
          }
          do
          {
            *((void *)v385 - 1)  = atomic_exchange(--v386, 0);
            v385 -= 8;
          }
          while (v386 != v387);
          goto LABEL_602;
        case 2u:
          memset(&v893[24], 170, 0x690uLL);
          memset(v893, 0, 24);
          *(void *)&v893[1704]  = &v893[24];
          CGRect v232 = (unsigned __int16 *)v829[2].n128_u64[1];
          LOBYTE(v911[0])  = v829[1].n128_u16[2] != 0;
          v891[0]  = v843;
          if (*v232 != 256) {
            goto LABEL_774;
          }
          v854  = v232;
          CGRect v233 = v232 + 3;
          if (v232 + 3 > v843) {
            goto LABEL_774;
          }
          uint64_t v234 = bswap32(v232[2]) >> 16;
          unint64_t v235 = (unint64_t)&v233[v234];
          unint64_t v236 = v232 + 4 <= v843 ? (unint64_t)((unsigned char *)v843 - (unsigned char *)v233) >> 1 : 0;
          BOOL v237 = v235 <= (unint64_t)v843 && v235 >= (unint64_t)v233;
          if (!v237 && v236 != v234) {
            goto LABEL_774;
          }
          OTL::LookupWithCoverage::GetCoverage((OTL::Coverage *)v232, (unint64_t)v843, (uint64_t)v852);
          CGRect v238 = operator new(0x28uLL);
          *CGRect v238 = &unk_1ED0606F8;
          v238[1]  = &v854;
          v238[2]  = v891;
          v238[3]  = v911;
          v238[4]  = v893;
          __dst[3]  = v238;
          LODWORD(v219)  = OTL::Coverage::Iterate(v852, (uint64_t)__dst);
          std::__function::__value_func<BOOL ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100](__dst);
          if (!v219) {
            goto LABEL_775;
          }
          *(void *)&v852[488]  = 0xAAAAAAAAAAAAAAAALL;
          *(void *)&long long v239 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v239 + 1)  = 0xAAAAAAAAAAAAAAAALL;
          *(_OWORD *)&v852[456]  = v239;
          *(_OWORD *)&v852[472]  = v239;
          *(void *)&v852[432]  = 0xAAAAAAAAAAAAAAAALL;
          *(_OWORD *)&v852[440]  = v239;
          *(void *)&v852[392]  = 0xAAAAAAAAAAAAAAAALL;
          *(_OWORD *)&v852[360]  = v239;
          *(_OWORD *)&v852[376]  = v239;
          *(_OWORD *)&v852[328]  = v239;
          *(_OWORD *)&v852[344]  = v239;
          *(_OWORD *)&v852[296]  = v239;
          *(_OWORD *)&v852[312]  = v239;
          *(_OWORD *)&v852[264]  = v239;
          *(_OWORD *)&v852[280]  = v239;
          *(_OWORD *)&v852[232]  = v239;
          *(_OWORD *)&v852[248]  = v239;
          *(_OWORD *)&v852[200]  = v239;
          *(_OWORD *)&v852[216]  = v239;
          *(_OWORD *)&v852[168]  = v239;
          *(_OWORD *)&v852[184]  = v239;
          *(void *)&v852[160]  = 0xAAAAAAAAAAAAAAAALL;
          *(_OWORD *)&v852[104]  = v239;
          *(void *)&v852[120]  = 0xAAAAAAAAAAAAAAAALL;
          *(_OWORD *)&v852[72]  = v239;
          *(_OWORD *)&v852[88]  = v239;
          *(void *)&v852[64]  = 0xAAAAAAAAAAAAAAAALL;
          *(void *)&v852[8]  = 0xAAAAAAAAAAAAAAAALL;
          *(void *)&v852[24]  = 0xAAAAAAAAAAAAAAAALL;
          memset(&v852[32], 0, 32);
          *(void *)&v852[16]  = 0;
          *(void *)&v852[128]  = &v852[64];
          memset(&v852[136], 0, 24);
          *(void *)&v852[400]  = &v852[160];
          memset(&v852[408], 0, 24);
          *(void *)v852  = &unk_1ED05F8D8;
          *(void *)&v852[496]  = &v852[432];
          v819  = v217;
          v815  = NewLKTHandle(GlyphCount, 1);
          *(void *)&long long v240 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v240 + 1)  = 0xAAAAAAAAAAAAAAAALL;
          *(_OWORD *)&__dst[7]  = v240;
          *(_OWORD *)&__dst[9]  = v240;
          *(_OWORD *)&__dst[3]  = v240;
          *(_OWORD *)&__dst[5]  = v240;
          memset(__dst, 0, 24);
          __dst[11]  = &__dst[3];
          ActionIndeCGFloat x = GetActionIndex((unint64_t **)&v852[136], 0, 0, 0xFFFFu, 0xFFFFFFFFLL);
          v242  = __dst[1];
          v243  = (char *)__dst[1] - (char *)__dst[0];
          if ((void *)((char *)__dst[1] - (char *)__dst[0]) > (void *)7)
          {
            v251  = v815;
            if (v243 != 8) {
              __dst[1]  = (char *)__dst[0] + 8;
            }
          }
          else
          {
            v244  = ActionIndex;
            v245  = v243 >> 1;
            v246  = 4 - (v243 >> 1);
            if (v246 <= ((char *)__dst[2] - (char *)__dst[1]) >> 1)
            {
              v413  = (char *)__dst[1] + 2 * v246;
              v414  = 8 - 2 * v245;
              v251  = v815;
              do
              {
                *v242++  = ActionIndex;
                v414 -= 2;
              }
              while (v414);
              __dst[1]  = v413;
            }
            else
            {
              if ((void *)((char *)__dst[2] - (char *)__dst[0]) <= (void *)4) {
                v247  = 4;
              }
              else {
                v247  = (char *)__dst[2] - (char *)__dst[0];
              }
              if ((void *)((char *)__dst[2] - (char *)__dst[0]) >= (void *)0x7FFFFFFFFFFFFFFELL) {
                v248  = 0x7FFFFFFFFFFFFFFFLL;
              }
              else {
                v248  = v247;
              }
              v891[4]  = &__dst[3];
              v249  = TInlineBufferAllocator<unsigned short,30ul>::allocate((uint64_t)&__dst[3], v248);
              v250  = v245;
              v251  = v815;
              do
                v249[v250++]  = v244;
              while (v250 != 4);
              v252  = (char *)&v249[v245];
              v253  = __dst[1];
              v254  = (char *)__dst[0];
              if (__dst[1] != __dst[0])
              {
                v255  = (char *)__dst[1];
                do
                {
                  v256  = *((_WORD *)v255 - 1);
                  v255 -= 2;
                  *((_WORD *)v252 - 1)  = v256;
                  v252 -= 2;
                }
                while (v255 != v254);
              }
              __dst[0]  = v252;
              __dst[1]  = v249 + 4;
              v257  = __dst[2];
              unsigned int __dst[2] = &v249[v248];
              v891[2]  = v253;
              v891[3]  = v257;
              v891[1]  = v254;
              v891[0]  = v254;
              std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,30ul> &>::~__split_buffer((uint64_t)v891);
            }
          }
          MutableBytePtr  = CFDataGetMutableBytePtr((CFMutableDataRef)atomic_load_explicit((atomic_ullong *volatile)&v852[16], memory_order_acquire));
          v415  = *(unsigned __int16 **)v893;
          v416  = *(unsigned __int16 **)&v893[8];
          if (*(void *)v893 == *(void *)&v893[8])
          {
            LOWORD(v422)  = 4;
          }
          else
          {
            v417  = 4;
            v807  = *(unsigned __int16 **)&v893[8];
            do
            {
              v419  = *((void *)v415 + 1);
              v418  = *((void *)v415 + 2);
              v420  = v418 - v419;
              if (v418 == v419)
              {
                v422  = v417;
              }
              else
              {
                v421  = *v415;
                v422  = (v417 + 1);
                if (LKTAddRange(v251, *v415, *v415, v417))
                {
                  v423  = 0;
                  MutableBytePtr[v421 >> 3] |= 1 << (v421 & 7);
                  v424  = *(_WORD **)&v852[416];
                  v425  = *(void *)&v852[416] - *(void *)&v852[408];
                  if ((unint64_t)(v420 >> 1) <= 1) {
                    v426  = 1;
                  }
                  else {
                    v426  = v420 >> 1;
                  }
                  do
                  {
                    v427  = *((void *)v415 + 1);
                    if ((unint64_t)v424 >= *(void *)&v852[424])
                    {
                      v428  = *(_WORD **)&v852[408];
                      v429  = (uint64_t)v424 - *(void *)&v852[408];
                      if ((uint64_t)v424 - *(void *)&v852[408] <= -3) {
                        goto LABEL_1145;
                      }
                      v430  = v429 >> 1;
                      if (*(void *)&v852[424] - *(void *)&v852[408] <= (unint64_t)((v429 >> 1) + 1)) {
                        v431  = v430 + 1;
                      }
                      else {
                        v431  = *(void *)&v852[424] - *(void *)&v852[408];
                      }
                      if (*(void *)&v852[424] - *(void *)&v852[408] >= 0x7FFFFFFFFFFFFFFEuLL) {
                        v432  = 0x7FFFFFFFFFFFFFFFLL;
                      }
                      else {
                        v432  = v431;
                      }
                      v891[4]  = &v852[432];
                      if (v432)
                      {
                        v433  = (char *)TInlineBufferAllocator<unsigned short,30ul>::allocate((uint64_t)&v852[432], v432);
                        v424  = *(_WORD **)&v852[416];
                        v428  = *(_WORD **)&v852[408];
                      }
                      else
                      {
                        v433  = 0;
                      }
                      v434  = &v433[2 * v430];
                      *(_WORD *)v434  = *(_WORD *)(v427 + 2 * v423);
                      if (v424 == v428)
                      {
                        v436  = &v433[2 * v430];
                      }
                      else
                      {
                        v435  = v424;
                        v436  = &v433[2 * v430];
                        do
                        {
                          v437  = *--v435;
                          *((_WORD *)v436 - 1)  = v437;
                          v436 -= 2;
                        }
                        while (v435 != v428);
                      }
                      v438  = v434 + 2;
                      *(void *)&v852[408]  = v436;
                      *(void *)&v852[416]  = v434 + 2;
                      v439  = *(void **)&v852[424];
                      *(void *)&v852[424]  = &v433[2 * v432];
                      v891[2]  = v424;
                      v891[3]  = v439;
                      v891[1]  = v428;
                      v891[0]  = v428;
                      std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,30ul> &>::~__split_buffer((uint64_t)v891);
                      v424  = v438;
                    }
                    else
                    {
                      *v424++  = *(_WORD *)(v427 + 2 * v423);
                    }
                    *(void *)&v852[416]  = v424;
                    ++v423;
                  }
                  while (v423 != v426);
                  v440  = GetActionIndex((unint64_t **)&v852[136], 0, (16 * v420) & 0xD7E0 | 0x2800, v425 >> 1, 0xFFFFFFFFLL);
                  v441  = v440;
                  v442  = (char *)__dst[1];
                  if (__dst[1] >= __dst[2])
                  {
                    v444  = (char *)__dst[0];
                    v445  = (char *)__dst[1] - (char *)__dst[0];
                    long long v160 = v821;
                    v416  = v807;
                    if ((char *)__dst[1] - (char *)__dst[0] <= -3) {
                      goto LABEL_1145;
                    }
                    v446  = v445 >> 1;
                    if ((void *)((char *)__dst[2] - (char *)__dst[0]) <= (void *)((v445 >> 1) + 1)) {
                      v447  = v446 + 1;
                    }
                    else {
                      v447  = (char *)__dst[2] - (char *)__dst[0];
                    }
                    if ((void *)((char *)__dst[2] - (char *)__dst[0]) >= (void *)0x7FFFFFFFFFFFFFFELL) {
                      v448  = 0x7FFFFFFFFFFFFFFFLL;
                    }
                    else {
                      v448  = v447;
                    }
                    v891[4]  = &__dst[3];
                    if (v448)
                    {
                      v449  = (char *)TInlineBufferAllocator<unsigned short,30ul>::allocate((uint64_t)&__dst[3], v448);
                      v442  = (char *)__dst[1];
                      v444  = (char *)__dst[0];
                    }
                    else
                    {
                      v449  = 0;
                    }
                    v450  = &v449[2 * v446];
                    *(_WORD *)v450  = v441;
                    if (v442 == v444)
                    {
                      v452  = &v449[2 * v446];
                    }
                    else
                    {
                      v451  = v442;
                      v452  = &v449[2 * v446];
                      do
                      {
                        v453  = *((_WORD *)v451 - 1);
                        v451 -= 2;
                        *((_WORD *)v452 - 1)  = v453;
                        v452 -= 2;
                      }
                      while (v451 != v444);
                    }
                    v443  = v450 + 2;
                    __dst[0]  = v452;
                    __dst[1]  = v450 + 2;
                    v454  = __dst[2];
                    unsigned int __dst[2] = &v449[2 * v448];
                    v891[2]  = v442;
                    v891[3]  = v454;
                    v891[1]  = v444;
                    v891[0]  = v444;
                    std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,30ul> &>::~__split_buffer((uint64_t)v891);
                  }
                  else
                  {
                    *(_WORD *)__dst[1]  = v440;
                    v443  = v442 + 2;
                    long long v160 = v821;
                    v416  = v807;
                  }
                  __dst[1]  = v443;
                  v251  = v815;
                }
              }
              v415 += 28;
              v417  = v422;
            }
            while (v415 != v416);
          }
          *(_DWORD *)&v852[24]  = (unsigned __int16)v422;
          LKTCreateLookupTable(v251, (atomic_ullong *)v891);

          DisposeLKTHandle(v251);
          std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::__wrap_iter<unsigned short *>,std::__wrap_iter<unsigned short *>,std::back_insert_iterator<TInlineVector<unsigned short,30ul>>,0>((uint64_t)__dst[0], (_WORD *)__dst[0] + *(unsigned int *)&v852[24], (char **)&v852[40]);
          std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::__wrap_iter<unsigned short *>,std::__wrap_iter<unsigned short *>,std::back_insert_iterator<TInlineVector<unsigned short,30ul>>,0>((uint64_t)__dst[0], (_WORD *)__dst[0] + *(unsigned int *)&v852[24], (char **)&v852[40]);
          v891[0]  = __dst;
          std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v891);
          if (*(void *)&v852[416] - *(void *)&v852[408] > 0xFFFFFFFEuLL)
          {
            v891[0]  = 0;
          }
          else
          {
            __dst[0]  = (void *)0xAAAAAAAAAAAAAAAALL;
            v455  = (const __CFData *)atomic_load_explicit((atomic_ullong *volatile)__dst, memory_order_acquire);
            v456  = CFDataGetLength(v455);
            CFDataIncreaseLength(v455, 4);
            v458  = bswap32(CFDataGetLength((CFDataRef)atomic_load_explicit((atomic_ullong *volatile)__dst, memory_order_acquire))- 12);
            *(_DWORD *)&CFDataGetMutableBytePtr(v455)[v456]  = v458;
            v459  = *(unsigned __int16 **)&v852[408];
            v460  = *(unsigned __int16 **)&v852[416];
            while (v459 != v460)
            {
              v461  = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)__dst, memory_order_acquire);
              v462  = *v459++;
              LOWORD(v891[0])  = bswap32(v462) >> 16;
              CFDataAppendBytes(v461, (const UInt8 *)v891, 2);
            }
            v891[0]  = (id)atomic_exchange((atomic_ullong *volatile)__dst, 0);
          }
          v463  = v900[51];
          if (v900[51] >= v900[52])
          {
            v466  = ((char *)v900[51] - (char *)v900[50]) >> 3;
            if ((unint64_t)(v466 + 1) >> 61) {
              goto LABEL_1145;
            }
            v467  = ((char *)v900[52] - (char *)v900[50]) >> 2;
            if (v467 <= v466 + 1) {
              v467  = v466 + 1;
            }
            if ((id)((char *)v900[52] - (char *)v900[50]) >= (id)0x7FFFFFFFFFFFFFF8) {
              v468  = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              v468  = v467;
            }
            __dst[4]  = &v900[53];
            if (v468) {
              v469  = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&v900[53], v468);
            }
            else {
              v469  = 0;
            }
            __dst[0]  = v469;
            __dst[1]  = &v469[8 * v466];
            unsigned int __dst[2] = __dst[1];
            __dst[3]  = &v469[8 * v468];
            *(void *)__dst[1]  = atomic_exchange((atomic_ullong *volatile)v891, 0);
            v492  = (char *)__dst[1];
            v464  = (char *)__dst[2] + 8;
            unsigned int __dst[2] = (char *)__dst[2] + 8;
            v493  = (atomic_ullong *)v900[51];
            v494  = (atomic_ullong *)v900[50];
            if (v900[51] == v900[50])
            {
              v495  = vdupq_n_s64((unint64_t)v900[51]);
              v465  = v819;
            }
            else
            {
              v465  = v819;
              do
              {
                *((void *)v492 - 1)  = atomic_exchange(--v493, 0);
                v492 -= 8;
              }
              while (v493 != v494);
              v495  = *(int64x2_t *)&v900[50];
              v464  = (char *)__dst[2];
            }
            v900[50]  = v492;
            v900[51]  = v464;
            *(int64x2_t *)&__dst[1]  = v495;
            v496  = v900[52];
            v900[52]  = __dst[3];
            __dst[3]  = v496;
            __dst[0]  = (void *)v495.i64[0];
            std::__split_buffer<TCFRef<__CFData *>,TInlineBufferAllocator<TCFRef<__CFData *>,30ul> &>::~__split_buffer((uint64_t)__dst);
          }
          else
          {
            *v463  = atomic_exchange((atomic_ullong *volatile)v891, 0);
            v464  = (char *)(v463 + 1);
            v465  = v819;
          }
          v900[51]  = v464;

          v891[0]  = (id)atomic_load_explicit((atomic_ullong *volatile)&v852[16], memory_order_acquire);
          v497  = v900[85];
          if (v900[85] >= v900[86])
          {
            v499  = ((char *)v900[85] - (char *)v900[84]) >> 3;
            if ((unint64_t)(v499 + 1) >> 61) {
              goto LABEL_1145;
            }
            v500  = ((char *)v900[86] - (char *)v900[84]) >> 2;
            if (v500 <= v499 + 1) {
              v500  = v499 + 1;
            }
            if ((id)((char *)v900[86] - (char *)v900[84]) >= (id)0x7FFFFFFFFFFFFFF8) {
              v501  = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              v501  = v500;
            }
            __dst[4]  = &v900[87];
            if (v501) {
              v502  = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&v900[87], v501);
            }
            else {
              v502  = 0;
            }
            __dst[0]  = v502;
            __dst[1]  = &v502[8 * v499];
            unsigned int __dst[2] = __dst[1];
            __dst[3]  = &v502[8 * v501];
            *(void *)__dst[1]  = atomic_exchange((atomic_ullong *volatile)v891, 0);
            v503  = (char *)__dst[1];
            v498  = (char *)__dst[2] + 8;
            unsigned int __dst[2] = (char *)__dst[2] + 8;
            v504  = (atomic_ullong *)v900[85];
            v505  = (atomic_ullong *)v900[84];
            if (v900[85] == v900[84])
            {
              v506  = vdupq_n_s64((unint64_t)v900[85]);
              v465  = v819;
            }
            else
            {
              v465  = v819;
              do
              {
                *((void *)v503 - 1)  = atomic_exchange(--v504, 0);
                v503 -= 8;
              }
              while (v504 != v505);
              v506  = *(int64x2_t *)&v900[84];
              v498  = (char *)__dst[2];
            }
            v900[84]  = v503;
            v900[85]  = v498;
            *(int64x2_t *)&__dst[1]  = v506;
            v507  = v900[86];
            v900[86]  = __dst[3];
            __dst[3]  = v507;
            __dst[0]  = (void *)v506.i64[0];
            std::__split_buffer<TCFRef<__CFData *>,TInlineBufferAllocator<TCFRef<__CFData *>,30ul> &>::~__split_buffer((uint64_t)__dst);
          }
          else
          {
            *v497  = atomic_exchange((atomic_ullong *volatile)v891, 0);
            v498  = (char *)(v497 + 1);
          }
          v900[85]  = v498;

          *(void *)v852  = &unk_1ED05F8D8;
          __dst[0]  = &v852[408];
          std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)__dst);
          __dst[0]  = (void *)0xAAAAAAAAAAAAAAAALL;
          __dst[1]  = 0;
          unsigned int __dst[2] = 0;
          v508  = CFDataGetMutableBytePtr((CFMutableDataRef)atomic_load_explicit((atomic_ullong *volatile)&__dst[1], memory_order_acquire));
          v509  = NewLKTHandle(GlyphCount, 0);
          v510  = *(unsigned __int16 **)v893;
          v511  = *(unsigned __int16 **)&v893[8];
          while (v510 != v511)
          {
            v512  = *v510;
            if (LKTAddRange(v509, *v510, *v510, v510[24])) {
              v508[v512 >> 3] |= 1 << (v512 & 7);
            }
            v510 += 28;
          }
          LKTCreateLookupTable(v509, (atomic_ullong *)v852);

          DisposeLKTHandle(v509);
          if (!atomic_load_explicit((atomic_ullong *volatile)&__dst[2], memory_order_acquire))
          {

LABEL_774:
            LOBYTE(v219)  = 0;
LABEL_775:
            v281  = 1;
LABEL_776:
            v515  = *(_WORD **)v893;
            if (!*(void *)v893) {
              goto LABEL_817;
            }
            goto LABEL_777;
          }
          v513  = v900[51];
          if (v900[51] >= v900[52])
          {
            v520  = ((char *)v900[51] - (char *)v900[50]) >> 3;
            if ((unint64_t)(v520 + 1) >> 61) {
              goto LABEL_1145;
            }
            v521  = ((char *)v900[52] - (char *)v900[50]) >> 2;
            if (v521 <= v520 + 1) {
              v521  = v520 + 1;
            }
            if ((id)((char *)v900[52] - (char *)v900[50]) >= (id)0x7FFFFFFFFFFFFFF8) {
              v522  = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              v522  = v521;
            }
            *(void *)&v852[32]  = &v900[53];
            if (v522) {
              v523  = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&v900[53], v522);
            }
            else {
              v523  = 0;
            }
            *(void *)v852  = v523;
            *(void *)&v852[8]  = &v523[8 * v520];
            *(void *)&v852[16]  = *(void *)&v852[8];
            *(void *)&v852[24]  = &v523[8 * v522];
            **(void **)&v852[8]  = atomic_exchange((atomic_ullong *volatile)v891, 0);
            v539  = *(char **)&v852[8];
            v514  = (void *)(*(void *)&v852[16] + 8);
            *(void *)&v852[16] += 8;
            v540  = (atomic_ullong *)v900[51];
            v541  = (atomic_ullong *)v900[50];
            if (v900[51] == v900[50])
            {
              v542  = vdupq_n_s64((unint64_t)v900[51]);
            }
            else
            {
              do
              {
                *((void *)v539 - 1)  = atomic_exchange(--v540, 0);
                v539 -= 8;
              }
              while (v540 != v541);
              v542  = *(int64x2_t *)&v900[50];
              v514  = *(void **)&v852[16];
            }
            v900[50]  = v539;
            v900[51]  = v514;
            *(int64x2_t *)&v852[8]  = v542;
            v543  = v900[52];
            v900[52]  = *(id *)&v852[24];
            *(void *)&v852[24]  = v543;
            *(void *)v852  = v542.i64[0];
            std::__split_buffer<TCFRef<__CFData *>,TInlineBufferAllocator<TCFRef<__CFData *>,30ul> &>::~__split_buffer((uint64_t)v852);
          }
          else
          {
            *v513  = atomic_exchange((atomic_ullong *volatile)v891, 0);
            v514  = v513 + 1;
          }
          v900[51]  = v514;

          v891[0]  = (id)atomic_load_explicit((atomic_ullong *volatile)&__dst[1], memory_order_acquire);
          v544  = v900[85];
          if (v900[85] >= v900[86])
          {
            v546  = ((char *)v900[85] - (char *)v900[84]) >> 3;
            if ((unint64_t)(v546 + 1) >> 61) {
              goto LABEL_1145;
            }
            v547  = ((char *)v900[86] - (char *)v900[84]) >> 2;
            if (v547 <= v546 + 1) {
              v547  = v546 + 1;
            }
            if ((id)((char *)v900[86] - (char *)v900[84]) >= (id)0x7FFFFFFFFFFFFFF8) {
              v548  = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              v548  = v547;
            }
            *(void *)&v852[32]  = &v900[87];
            if (v548) {
              v549  = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&v900[87], v548);
            }
            else {
              v549  = 0;
            }
            *(void *)v852  = v549;
            *(void *)&v852[8]  = &v549[8 * v546];
            *(void *)&v852[16]  = *(void *)&v852[8];
            *(void *)&v852[24]  = &v549[8 * v548];
            **(void **)&v852[8]  = atomic_exchange((atomic_ullong *volatile)v891, 0);
            v550  = *(char **)&v852[8];
            v545  = (void *)(*(void *)&v852[16] + 8);
            *(void *)&v852[16] += 8;
            v551  = (atomic_ullong *)v900[85];
            v552  = (atomic_ullong *)v900[84];
            if (v900[85] == v900[84])
            {
              v553  = vdupq_n_s64((unint64_t)v900[85]);
            }
            else
            {
              do
              {
                *((void *)v550 - 1)  = atomic_exchange(--v551, 0);
                v550 -= 8;
              }
              while (v551 != v552);
              v553  = *(int64x2_t *)&v900[84];
              v545  = *(void **)&v852[16];
            }
            v900[84]  = v550;
            v900[85]  = v545;
            *(int64x2_t *)&v852[8]  = v553;
            v554  = v900[86];
            v900[86]  = *(id *)&v852[24];
            *(void *)&v852[24]  = v554;
            *(void *)v852  = v553.i64[0];
            std::__split_buffer<TCFRef<__CFData *>,TInlineBufferAllocator<TCFRef<__CFData *>,30ul> &>::~__split_buffer((uint64_t)v852);
          }
          else
          {
            *v544  = atomic_exchange((atomic_ullong *volatile)v891, 0);
            v545  = v544 + 1;
          }
          v900[85]  = v545;

          v555  = *(uint64_t **)v842;
          if (!*(void *)v842) {
            goto LABEL_867;
          }
          v515  = *(_WORD **)v893;
          v556  = *(_WORD **)&v893[8];
          if (*(void *)v893 != *(void *)&v893[8])
          {
            do
            {
              if (*((void *)v515 + 1) == *((void *)v515 + 2))
              {
                memset(&v852[24], 170, 24);
                *(_OWORD *)&v852[8]  = 0u;
                __dst[4]  = &v852[24];
                *(void *)v852  = 0;
                *(void *)&v852[32]  = &v852[26];
                *(_WORD *)&v852[24]  = *v515;
                *(void *)v852  = &v852[24];
                *(void *)&v852[8]  = &v852[26];
                *(void *)&v852[16]  = &v852[26];
                memset(__dst, 0, 32);
                std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,3ul> &>::~__split_buffer((uint64_t)__dst);
                *(void *)&v852[8]  = &v852[26];
                *(_WORD *)&v852[40]  = v515[24];
                std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)v852);
              }
              else
              {
                v557  = (char *)v555[185];
                v558  = v555[186];
                if ((unint64_t)v557 >= v558)
                {
                  v560  = (char *)v555[184];
                  v561  = v557 - v560;
                  if (v557 - v560 <= -3) {
                    goto LABEL_1145;
                  }
                  v562  = v561 >> 1;
                  v563  = v558 - (void)v560;
                  if (v563 <= (v561 >> 1) + 1) {
                    v564  = v562 + 1;
                  }
                  else {
                    v564  = v563;
                  }
                  if (v563 >= 0x7FFFFFFFFFFFFFFELL) {
                    v565  = 0x7FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    v565  = v564;
                  }
                  *(void *)&v852[32]  = v555 + 187;
                  if (v565)
                  {
                    v566  = (char *)TInlineBufferAllocator<unsigned short,30ul>::allocate((uint64_t)(v555 + 187), v565);
                    v557  = (char *)v555[185];
                    v560  = (char *)v555[184];
                  }
                  else
                  {
                    v566  = 0;
                  }
                  v567  = &v566[2 * v562];
                  *(_WORD *)v567  = *v515;
                  if (v557 == v560)
                  {
                    v569  = &v566[2 * v562];
                  }
                  else
                  {
                    v568  = v557;
                    v569  = &v566[2 * v562];
                    do
                    {
                      v570  = *((_WORD *)v568 - 1);
                      v568 -= 2;
                      *((_WORD *)v569 - 1)  = v570;
                      v569 -= 2;
                    }
                    while (v568 != v560);
                  }
                  v559  = v567 + 2;
                  v555[184]  = (uint64_t)v569;
                  v555[185]  = (uint64_t)(v567 + 2);
                  v571  = v555[186];
                  v555[186]  = (uint64_t)&v566[2 * v565];
                  *(void *)&v852[16]  = v557;
                  *(void *)&v852[24]  = v571;
                  *(void *)&v852[8]  = v560;
                  *(void *)v852  = v560;
                  std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,30ul> &>::~__split_buffer((uint64_t)v852);
                }
                else
                {
                  *(_WORD *)v557  = *v515;
                  v559  = v557 + 2;
                }
                v555[185]  = (uint64_t)v559;
              }
              v515 += 28;
            }
            while (v515 != v556);
LABEL_867:
            v281  = 28;
            LOBYTE(v219)  = 1;
            goto LABEL_776;
          }
          v281  = 28;
          LOBYTE(v219)  = 1;
          if (!*(void *)v893) {
            goto LABEL_817;
          }
LABEL_777:
          v516  = *(_WORD **)&v893[8];
          v517  = v515;
          if (*(_WORD **)&v893[8] != v515)
          {
            do
            {
              v518  = v516 - 28;
              std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)(v516 - 24));
              v516  = v518;
            }
            while (v518 != v515);
            v517  = *(unsigned char **)v893;
          }
          *(void *)&v893[8]  = v515;
          if (&v893[24] > v517 || &v893[1704] <= v517) {
            operator delete(v517);
          }
          goto LABEL_817;
        case 3u:
          v258  = v162->n128_u16[3] + ((int)(v166 << 25) >> 31);
          *(void *)v852  = 0xAAAAAAAAAAAAAAAALL;
          *(void *)&v852[8]  = 0;
          *(void *)&v852[16]  = 0;
          LOBYTE(v219)  = v259;
          if (v259)
          {
            v260  = v900[51];
            if (v900[51] >= v900[52])
            {
              v320  = ((char *)v900[51] - (char *)v900[50]) >> 3;
              if ((unint64_t)(v320 + 1) >> 61) {
                goto LABEL_1145;
              }
              v321  = ((char *)v900[52] - (char *)v900[50]) >> 2;
              if (v321 <= v320 + 1) {
                v321  = v320 + 1;
              }
              if ((id)((char *)v900[52] - (char *)v900[50]) >= (id)0x7FFFFFFFFFFFFFF8) {
                v322  = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                v322  = v321;
              }
              *(void *)&v893[32]  = &v900[53];
              if (v322) {
                v323  = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&v900[53], v322);
              }
              else {
                v323  = 0;
              }
              *(void *)v893  = v323;
              *(void *)&v893[8]  = &v323[8 * v320];
              *(void *)&v893[16]  = *(void *)&v893[8];
              *(void *)&v893[24]  = &v323[8 * v322];
              **(void **)&v893[8]  = atomic_exchange((atomic_ullong *volatile)__dst, 0);
              v369  = *(char **)&v893[8];
              v261  = (void *)(*(void *)&v893[16] + 8);
              *(void *)&v893[16] += 8;
              v370  = (atomic_ullong *)v900[51];
              v371  = (atomic_ullong *)v900[50];
              if (v900[51] == v900[50])
              {
                v372  = vdupq_n_s64((unint64_t)v900[51]);
              }
              else
              {
                do
                {
                  *((void *)v369 - 1)  = atomic_exchange(--v370, 0);
                  v369 -= 8;
                }
                while (v370 != v371);
                v372  = *(int64x2_t *)&v900[50];
                v261  = *(void **)&v893[16];
              }
              v900[50]  = v369;
              v900[51]  = v261;
              *(int64x2_t *)&v893[8]  = v372;
              v379  = v900[52];
              v900[52]  = *(id *)&v893[24];
              *(void *)&v893[24]  = v379;
              *(void *)v893  = v372.i64[0];
              std::__split_buffer<TCFRef<__CFData *>,TInlineBufferAllocator<TCFRef<__CFData *>,30ul> &>::~__split_buffer((uint64_t)v893);
            }
            else
            {
              *v260  = atomic_exchange((atomic_ullong *volatile)__dst, 0);
              v261  = v260 + 1;
            }
            v900[51]  = v261;

            __dst[0]  = (id)atomic_load_explicit((atomic_ullong *volatile)&v852[8], memory_order_acquire);
            v374  = v900[85];
            if (v900[85] >= v900[86])
            {
              v381  = ((char *)v900[85] - (char *)v900[84]) >> 3;
              if ((unint64_t)(v381 + 1) >> 61) {
                goto LABEL_1145;
              }
              v382  = ((char *)v900[86] - (char *)v900[84]) >> 2;
              if (v382 <= v381 + 1) {
                v382  = v381 + 1;
              }
              if ((id)((char *)v900[86] - (char *)v900[84]) >= (id)0x7FFFFFFFFFFFFFF8) {
                v383  = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                v383  = v382;
              }
              *(void *)&v893[32]  = &v900[87];
              if (v383) {
                v384  = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&v900[87], v383);
              }
              else {
                v384  = 0;
              }
              *(void *)v893  = v384;
              *(void *)&v893[8]  = &v384[8 * v381];
              *(void *)&v893[16]  = *(void *)&v893[8];
              *(void *)&v893[24]  = &v384[8 * v383];
              **(void **)&v893[8]  = atomic_exchange((atomic_ullong *volatile)__dst, 0);
              v385  = *(char **)&v893[8];
              v380  = (void *)(*(void *)&v893[16] + 8);
              *(void *)&v893[16] += 8;
              v386  = (atomic_ullong *)v900[85];
              v388  = (atomic_ullong *)v900[84];
              if (v900[85] == v900[84])
              {
LABEL_603:
                v389  = vdupq_n_s64((unint64_t)v386);
              }
              else
              {
                do
                {
                  *((void *)v385 - 1)  = atomic_exchange(--v386, 0);
                  v385 -= 8;
                }
                while (v386 != v388);
LABEL_602:
                v389  = *(int64x2_t *)&v900[84];
                v380  = *(void **)&v893[16];
              }
              v900[84]  = v385;
              v900[85]  = v380;
              *(int64x2_t *)&v893[8]  = v389;
              v390  = v900[86];
              v900[86]  = *(id *)&v893[24];
              *(void *)&v893[24]  = v390;
              *(void *)v893  = v389.i64[0];
              std::__split_buffer<TCFRef<__CFData *>,TInlineBufferAllocator<TCFRef<__CFData *>,30ul> &>::~__split_buffer((uint64_t)v893);
            }
            else
            {
LABEL_586:
              *v374  = atomic_exchange((atomic_ullong *volatile)__dst, 0);
              v380  = v374 + 1;
            }
            v900[85]  = v380;

            if (*(void *)v842) {
              AddPrevLigaturesFromSingleSubstitutionLookupTable(*(uint64_t *)v842, (CFDataRef)atomic_load_explicit((atomic_ullong *volatile)&v852[16], memory_order_acquire));
            }
            v281  = 28;
          }
          else
          {
LABEL_442:
            v281  = 1;
          }

          goto LABEL_817;
        case 4u:
          v262  = v162;
          memset(&v893[24], 170, 0x5A0uLL);
          memset(v893, 0, 24);
          *(void *)&v893[1464]  = &v893[24];
          if (!LigInputsForLigatureSubst(GlyphCount, (OTL::LookupWithCoverage *)v262[2].n128_u64[1], (char *)v843, (__n128 *)v262[3].n128_u64, (unsigned __int16 ***)v893))
          {
            v281  = 1;
            goto LABEL_550;
          }
          *(void *)&v263  = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v263 + 1)  = 0xAAAAAAAAAAAAAAAALL;
          *(_OWORD *)&v891[29]  = v263;
          *(_OWORD *)&v891[31]  = v263;
          *(_OWORD *)&v891[25]  = v263;
          *(_OWORD *)&v891[27]  = v263;
          *(_OWORD *)&v891[21]  = v263;
          *(_OWORD *)&v891[23]  = v263;
          *(_OWORD *)&v891[17]  = v263;
          *(_OWORD *)&v891[19]  = v263;
          *(_OWORD *)&v891[13]  = v263;
          *(_OWORD *)&v891[15]  = v263;
          *(_OWORD *)&v891[9]  = v263;
          *(_OWORD *)&v891[11]  = v263;
          *(_OWORD *)&v891[5]  = v263;
          *(_OWORD *)&v891[7]  = v263;
          *(_OWORD *)&v891[3]  = v263;
          memset(v891, 0, 24);
          v891[33]  = &v891[3];
          v264  = *(void *)&v893[8];
          v265  = *(void *)v893;
          if (*(void *)v893 == *(void *)&v893[8]) {
            goto LABEL_444;
          }
          v266  = *(void *)v893;
          while (2)
          {
            v267  = 0;
            while (v266 == v265)
            {
LABEL_432:
              v266 += 48;
              v267 += 48;
              if (v266 == v264)
              {
LABEL_444:
                *(void *)v852  = v264;
                goto LABEL_445;
              }
            }
            v268  = *(const void **)v266;
            v269  = *(void *)(v266 + 8) - *(void *)v266;
            v270  = (void *)(v265 + 8);
            v271  = v267;
            while (1)
            {
              v272  = (const void *)*(v270 - 1);
              if (v269 < *v270 - (void)v272 && !memcmp(v268, v272, v269)) {
                break;
              }
              v270 += 6;
              v271 -= 48;
              if (!v271) {
                goto LABEL_432;
              }
            }
            *(void *)v852  = v266;
            if (v266 != v264)
            {
              v265  = v266;
              continue;
            }
            break;
          }
LABEL_445:
          v282  = (char *)v891[0];
          v283  = (char *)v891[1];
          if (v891[0] == v891[1])
          {
LABEL_482:
            long long v160 = v821;
            if (*(void *)v842) {
              AddPrevLigaturesFromLigInputs(*(char ***)v842, *(char ***)v893, *(uint64_t *)&v893[8]);
            }
            v281  = 28;
          }
          else
          {
            while (1)
            {
              memset(&__dst[1], 170, 0x2A8uLL);
              memset(&__dst[4], 0, 32);
              memset(&__dst[17], 0, 24);
              __dst[16]  = &__dst[8];
              __dst[43]  = &__dst[20];
              unsigned int __dst[2] = 0;
              __dst[0]  = &unk_1ED05F8B0;
              memset(&__dst[44], 0, 24);
              memset(&__dst[63], 0, 24);
              __dst[62]  = &__dst[47];
              __dst[74]  = &__dst[66];
              memset(&__dst[75], 0, 24);
              __dst[86]  = &__dst[78];
              memset(&v852[24], 170, 0x2D0uLL);
              memset(v852, 0, 24);
              *(void *)&v852[744]  = &v852[24];
              v285  = v284;
              if (v284)
              {
                v286  = v900[51];
                if (v900[51] >= v900[52])
                {
                  v288  = ((char *)v900[51] - (char *)v900[50]) >> 3;
                  if ((unint64_t)(v288 + 1) >> 61) {
                    goto LABEL_1145;
                  }
                  v289  = ((char *)v900[52] - (char *)v900[50]) >> 2;
                  if (v289 <= v288 + 1) {
                    v289  = v288 + 1;
                  }
                  if ((id)((char *)v900[52] - (char *)v900[50]) >= (id)0x7FFFFFFFFFFFFFF8) {
                    v290  = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    v290  = v289;
                  }
                  *(void *)&v857  = &v900[53];
                  if (v290) {
                    v291  = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&v900[53], v290);
                  }
                  else {
                    v291  = 0;
                  }
                  v854  = v291;
                  v855.i64[0]  = (uint64_t)&v291[8 * v288];
                  v855.i64[1]  = v855.i64[0];
                  v856  = &v291[8 * v290];
                  *(void *)v855.i64[0]  = atomic_exchange((atomic_ullong *volatile)v911, 0);
                  v292  = (char *)v855.i64[0];
                  v287  = (void *)(v855.i64[1] + 8);
                  v855.i64[1] += 8;
                  v293  = (atomic_ullong *)v900[51];
                  v294  = (atomic_ullong *)v900[50];
                  if (v900[51] == v900[50])
                  {
                    v295  = vdupq_n_s64((unint64_t)v900[51]);
                  }
                  else
                  {
                    do
                    {
                      *((void *)v292 - 1)  = atomic_exchange(--v293, 0);
                      v292 -= 8;
                    }
                    while (v293 != v294);
                    v295  = *(int64x2_t *)&v900[50];
                    v287  = (void *)v855.i64[1];
                  }
                  v900[50]  = v292;
                  v900[51]  = v287;
                  v855  = v295;
                  v296  = (char *)v900[52];
                  v900[52]  = v856;
                  v856  = v296;
                  v854  = (id)v295.i64[0];
                  std::__split_buffer<TCFRef<__CFData *>,TInlineBufferAllocator<TCFRef<__CFData *>,30ul> &>::~__split_buffer((uint64_t)&v854);
                }
                else
                {
                  *v286  = atomic_exchange((atomic_ullong *volatile)v911, 0);
                  v287  = v286 + 1;
                }
                v900[51]  = v287;

                v911[0]  = (id)atomic_load_explicit((atomic_ullong *volatile)&__dst[2], memory_order_acquire);
                v297  = v900[85];
                if (v900[85] >= v900[86])
                {
                  v299  = ((char *)v900[85] - (char *)v900[84]) >> 3;
                  if ((unint64_t)(v299 + 1) >> 61) {
                    goto LABEL_1145;
                  }
                  v300  = ((char *)v900[86] - (char *)v900[84]) >> 2;
                  if (v300 <= v299 + 1) {
                    v300  = v299 + 1;
                  }
                  if ((id)((char *)v900[86] - (char *)v900[84]) >= (id)0x7FFFFFFFFFFFFFF8) {
                    v301  = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    v301  = v300;
                  }
                  *(void *)&v857  = &v900[87];
                  if (v301) {
                    v302  = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&v900[87], v301);
                  }
                  else {
                    v302  = 0;
                  }
                  v854  = v302;
                  v855.i64[0]  = (uint64_t)&v302[8 * v299];
                  v855.i64[1]  = v855.i64[0];
                  v856  = &v302[8 * v301];
                  *(void *)v855.i64[0]  = atomic_exchange((atomic_ullong *volatile)v911, 0);
                  v303  = (char *)v855.i64[0];
                  v298  = (void *)(v855.i64[1] + 8);
                  v855.i64[1] += 8;
                  v304  = (atomic_ullong *)v900[85];
                  v305  = (atomic_ullong *)v900[84];
                  if (v900[85] == v900[84])
                  {
                    v306  = vdupq_n_s64((unint64_t)v900[85]);
                  }
                  else
                  {
                    do
                    {
                      *((void *)v303 - 1)  = atomic_exchange(--v304, 0);
                      v303 -= 8;
                    }
                    while (v304 != v305);
                    v306  = *(int64x2_t *)&v900[84];
                    v298  = (void *)v855.i64[1];
                  }
                  v900[84]  = v303;
                  v900[85]  = v298;
                  v855  = v306;
                  v307  = (char *)v900[86];
                  v900[86]  = v856;
                  v856  = v307;
                  v854  = (id)v306.i64[0];
                  std::__split_buffer<TCFRef<__CFData *>,TInlineBufferAllocator<TCFRef<__CFData *>,30ul> &>::~__split_buffer((uint64_t)&v854);
                }
                else
                {
                  *v297  = atomic_exchange((atomic_ullong *volatile)v911, 0);
                  v298  = v297 + 1;
                }
                v900[85]  = v298;
              }
              v854  = v852;
              std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v854);
              __dst[0]  = &unk_1ED05F8B0;
              *(void *)v852  = &__dst[75];
              std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v852);
              *(void *)v852  = &__dst[63];
              std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v852);
              *(void *)v852  = &__dst[44];
              std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v852);
              __dst[0]  = &unk_1ED05F928;
              std::vector<STXEntryOne,TInlineBufferAllocator<STXEntryOne,30ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&__dst[17]);
              *(void *)v852  = &__dst[5];
              std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v852);

              if ((v285 & 1) == 0) {
                break;
              }
              v282 += 8;
              if (v282 == v283) {
                goto LABEL_482;
              }
            }
            v281  = 1;
            long long v160 = v821;
          }
          if (v891[0])
          {
            v891[1]  = v891[0];
            if (&v891[3] > v891[0] || &v891[33] <= v891[0]) {
              operator delete(v891[0]);
            }
          }
LABEL_550:
          v362  = *(void *)v893;
          if (!*(void *)v893) {
            goto LABEL_560;
          }
          v363  = *(void *)&v893[8];
          v359  = *(unsigned char **)v893;
          if (*(void *)&v893[8] != *(void *)v893)
          {
            do
            {
              v363 -= 48;
              std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100](v363);
            }
            while (v363 != v362);
            v359  = *(unsigned char **)v893;
          }
          *(void *)&v893[8]  = v362;
          v360  = &v893[24] > v359;
          v361  = &v893[1464];
          goto LABEL_555;
        case 5u:
          goto LABEL_1132;
        case 6u:
          if (*(_WORD *)v162[2].n128_u64[1] != 768) {
            goto LABEL_1144;
          }
          memset(&v893[64], 170, 0x3098uLL);
          *(void *)&v852[400]  = 0;
          memset(v852, 0, 136);
          *(void *)&v852[136]  = &v852[40];
          memset(&v852[144], 0, 120);
          *(void *)&v852[264]  = &v852[168];
          memset(&v852[272], 0, 120);
          *(void *)&v852[392]  = &v852[296];
          *(void *)&v852[408]  = 0;
          *(void *)v893  = &v893[24];
          *(void *)&v893[8]  = &v893[24];
          memset(&v893[24], 0, 40);
          *(void *)&v893[16]  = &v893[440];
          *(void *)&v893[160]  = &v893[64];
          memset(&v893[168], 0, 24);
          v894  = &v893[440];
          *(void *)&v893[288]  = &v893[192];
          std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,4ul>>::__init_with_size[abi:nn180100]<std::__wrap_iter<std::vector<unsigned short> const*>,std::__wrap_iter<std::vector<unsigned short> const*>>(&v893[168], 0, 0, 0);
          memset(&v893[296], 0, 24);
          *(void *)&v893[416]  = &v893[320];
          std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,4ul>>::__init_with_size[abi:nn180100]<std::__wrap_iter<std::vector<unsigned short> const*>,std::__wrap_iter<std::vector<unsigned short> const*>>(&v893[296], *(uint64_t *)&v852[272], *(uint64_t *)&v852[280], 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&v852[280] - *(void *)&v852[272]) >> 3));
          *(_OWORD *)&v893[424]  = *(_OWORD *)&v852[400];
          *(void *)&v893[8]  = &v893[440];
          __dst[0]  = &v852[272];
          std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,4ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)__dst);
          __dst[0]  = &v852[144];
          std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,4ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)__dst);
          __dst[0]  = &v852[16];
          std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,4ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)__dst);
          v273  = v829;
          v274  = v829[2].n128_u64[0];
          v275  = *(void *)v893;
          if (0x4EC4EC4EC4EC4EC5 * ((uint64_t)(*(void *)&v893[16] - *(void *)v893) >> 5) >= v274) {
            goto LABEL_532;
          }
          if (v274 >= 0x9D89D89D89D89ELL) {
            goto LABEL_1145;
          }
          *(void *)&v852[32]  = 0xAAAAAAAAAAAAAAAALL;
          *(void *)&v276  = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v276 + 1)  = 0xAAAAAAAAAAAAAAAALL;
          *(_OWORD *)v852  = v276;
          *(_OWORD *)&v852[16]  = v276;
          v277  = *(__n128 **)&v893[8];
          v278  = *(__n128 **)v893;
          v279  = *(__n128 **)&v852[8];
          if (*(void *)&v893[8] == *(void *)v893)
          {
            v280  = vdupq_n_s64(*(unint64_t *)&v893[8]);
          }
          else
          {
            do
            {
              v279 -= 26;
              v277 -= 26;
            }
            while (v277 != v278);
            v280  = *(int64x2_t *)v893;
          }
          *(void *)v893  = v279;
          v352  = *(void *)&v893[16];
          v353  = *(_OWORD *)&v852[16];
          *(int64x2_t *)&v852[8]  = v280;
          *(_OWORD *)&v893[8]  = v353;
          *(void *)&v852[24]  = v352;
          *(void *)v852  = v280.i64[0];
          v275  = *(void *)v893;
          v273  = v829;
LABEL_532:
          v354  = v273 + 3;
          v355  = *(_DWORD *)(v275 + 400);
          if (v355 != 1)
          {
            if (!v355)
            {
              if (v829[2].n128_u64[0] > 1) {
                v281  = 1;
              }
              else {
                v281  = 20;
              }
              goto LABEL_540;
            }
            goto LABEL_539;
          }
          v356  = *(_WORD **)(v275 + 408);
          if (*v356) {
            goto LABEL_539;
          }
          v808  = v275;
          v470  = bswap32((unsigned __int16)v356[1]) >> 16;
          if (v470 >= v804) {
            goto LABEL_539;
          }
          v471  = (unsigned __int16 *)((char *)v806 + (bswap32(v806[v470 + 1]) >> 16));
          if ((unint64_t)(v471 + 2) < v805 || v471 + 3 > v843) {
            goto LABEL_539;
          }
          v473  = (unint64_t)&v471[(bswap32(v471[2]) >> 16) + 3] + (((unint64_t)v471[1] >> 11) & 2);
          if ((unint64_t)v471 < v805 || v473 < (unint64_t)v471 || v473 > (unint64_t)v843) {
            goto LABEL_1106;
          }
          v476  = v217;
          v477  = ResolveLookupSubtable(v471, (unint64_t)v843, 0);
          v797  = v478;
          v479  = v477;
          if (v477 != 1
            && *(void *)(v275 + 16) != *(void *)(v275 + 24)
            && *(void *)(v275 + 272) != *(void *)(v275 + 280))
          {
            goto LABEL_1106;
          }
          v480  = v829;
          v481  = v829[2].n128_u64[0];
          if (v481 >= 2)
          {
            for (unint64_t i = 1; i < v481; ++i)
            {
              v483  = v843;
              if ((unsigned __int16)ResolveLookupSubtableWithIndex((unsigned __int16 *)v480[1].n128_u64[1], i, (unint64_t)v843) != 6)goto LABEL_1106; {
              *(void *)&v485  = 0xAAAAAAAAAAAAAAAALL;
              }
              *((void *)&v485 + 1)  = 0xAAAAAAAAAAAAAAAALL;
              *(_OWORD *)&v852[376]  = v485;
              *(_OWORD *)&v852[344]  = v485;
              *(_OWORD *)&v852[360]  = v485;
              *(_OWORD *)&v852[312]  = v485;
              *(_OWORD *)&v852[328]  = v485;
              *(_OWORD *)&v852[296]  = v485;
              *(_OWORD *)&v852[248]  = v485;
              *(_OWORD *)&v852[216]  = v485;
              *(_OWORD *)&v852[232]  = v485;
              *(_OWORD *)&v852[184]  = v485;
              *(_OWORD *)&v852[200]  = v485;
              *(_OWORD *)&v852[168]  = v485;
              *(_OWORD *)&v852[120]  = v485;
              *(_OWORD *)&v852[88]  = v485;
              *(_OWORD *)&v852[104]  = v485;
              *(_OWORD *)&v852[56]  = v485;
              *(_OWORD *)&v852[72]  = v485;
              *(_OWORD *)&v852[40]  = v485;
              memset(v852, 0, 40);
              *(void *)&v852[136]  = &v852[40];
              memset(&v852[144], 0, 24);
              memset(&v852[272], 0, 24);
              *(void *)&v852[264]  = &v852[168];
              *(void *)&v852[392]  = &v852[296];
              *(void *)&v852[400]  = 0xAAAAAAAA00000000;
              *(void *)&v852[408]  = 0;
              v486  = 0;
              {
                if (*(void *)&v852[24] - *(void *)&v852[16] == *(void *)(v808 + 24) - *(void *)(v808 + 16)
                  && *(void *)&v852[280] - *(void *)&v852[272] == *(void *)(v808 + 280) - *(void *)(v808 + 272)
                  && *(_DWORD *)&v852[400] == *(_DWORD *)(v808 + 400)
                  && !**(_WORD **)&v852[408]
                  && ((v487  = *(unsigned __int16 *)(*(void *)&v852[408] + 2), v487 == (unsigned __int16)v356[1])
                   || (v488  = __rev16(v487), v488 < v804)
                   && (v489  = (unsigned __int16 *)((char *)v806 + (bswap32(v806[v488 + 1]) >> 16)),
                       v490  = v843,
                       IsAccessWithinRange<OTL::LookupTable>((unint64_t)v489, v805, (unint64_t)v843))
                   && (unsigned __int16)ResolveLookupSubtable(v489, (unint64_t)v490, 0) == 1
                   && SingleSubstIsEqualTo(v491, (uint64_t)v797, (unint64_t)v843)))
                {
                  v486  = 1;
                }
                else
                {
                  v486  = 0;
                }
              }
              __dst[0]  = &v852[272];
              std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,4ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)__dst);
              __dst[0]  = &v852[144];
              std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,4ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)__dst);
              __dst[0]  = &v852[16];
              std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,4ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)__dst);
              if ((v486 & 1) == 0) {
                goto LABEL_1106;
              }
              v480  = v829;
              v481  = v829[2].n128_u64[0];
            }
            v476  = v217;
          }
          if (v479 == 4)
          {
            if (v481 <= 1)
            {
              memset(&v852[24], 170, 0x5A0uLL);
              memset(v852, 0, 24);
              v853  = &v852[24];
              long long v160 = v821;
              if ((LigInputsForLigatureSubst(GlyphCount, v797, (char *)v843, v354, (unsigned __int16 ***)v852) & 1) == 0)
              {
LABEL_539:
                v281  = 1;
LABEL_540:
                v357  = *(void ***)v893;
                if (*(void *)v893)
                {
                  v358  = *(void ***)&v893[8];
                  v359  = *(unsigned char **)v893;
                  if (*(void *)&v893[8] != *(void *)v893)
                  {
                    do
                    {
                      v358 -= 52;
                    }
                    while (v358 != v357);
                    v359  = *(unsigned char **)v893;
                  }
                  *(void *)&v893[8]  = v357;
                  v360  = &v893[24] > v359;
                  v361  = &v894;
LABEL_555:
                  if (v360 || v361 <= v359) {
                    operator delete(v359);
                  }
                }
LABEL_560:
                if (v281 == 28) {
                  goto LABEL_819;
                }
LABEL_818:
                if (v281 == 20) {
                  goto LABEL_819;
                }
LABEL_1144:
                uint64_t v129 = 0;
                goto LABEL_1132;
              }
              memset(&__dst[3], 170, 0x2D0uLL);
              memset(__dst, 0, 24);
              __dst[93]  = &__dst[3];
              v779  = *(void *)(v808 + 272);
              v778  = *(void *)(v808 + 280);
              if (v779 == v778)
              {
                std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::__assign_with_size[abi:nn180100]<std::reverse_iterator<std::__wrap_iter<std::vector<unsigned short> const*>>,std::reverse_iterator<std::__wrap_iter<std::vector<unsigned short> const*>>>((uint64_t *)__dst, *(void *)(v808 + 24), *(void *)(v808 + 24), *(void *)(v808 + 16), *(void *)(v808 + 16), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v808 + 24) - *(void *)(v808 + 16)) >> 3));
              }
              else
              {
                std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::__assign_with_size[abi:nn180100]<std::reverse_iterator<std::__wrap_iter<std::vector<unsigned short> const*>>,std::reverse_iterator<std::__wrap_iter<std::vector<unsigned short> const*>>>((uint64_t *)__dst, v778, *(void *)(v808 + 280), v779, *(void *)(v808 + 272), 0xAAAAAAAAAAAAAAABLL * ((v778 - v779) >> 3));
                v780  = *(unint64_t **)&v852[8];
                if (*(void *)v852 != *(void *)&v852[8])
                {
                  v781  = *(unint64_t **)v852;
                  do
                  {
                    v782  = *v781;
                    v783  = v781[1];
                    v784  = (_WORD *)(v783 - 2);
                    if (*v781 != v783 && (unint64_t)v784 > v782)
                    {
                      v786  = v782 + 2;
                      do
                      {
                        v787  = *(_WORD *)(v786 - 2);
                        *(_WORD *)(v786 - 2)  = *v784;
                        *v784--  = v787;
                        BOOL v12 = v786 >= (unint64_t)v784;
                        v786 += 2;
                      }
                      while (!v12);
                    }
                    v781 += 6;
                  }
                  while (v781 != v780);
                }
              }
              memset(&v891[1], 170, 0x2A8uLL);
              memset(&v891[4], 0, 32);
              v891[2]  = 0;
              v891[16]  = &v891[8];
              memset(&v891[17], 0, 24);
              v891[43]  = &v891[20];
              memset(&v891[44], 0, 24);
              v891[0]  = &unk_1ED05F8B0;
              v891[62]  = &v891[47];
              memset(&v891[63], 0, 24);
              v891[74]  = &v891[66];
              memset(&v891[75], 0, 24);
              v891[86]  = &v891[78];
              if (v788)
              {
                std::vector<TCFRef<__CFData *>,TInlineBufferAllocator<TCFRef<__CFData *>,30ul>>::emplace_back<TCFRef<__CFData const*>>((uint64_t)&v900[50], (atomic_ullong *)&v854);

                v854  = (id)atomic_load_explicit((atomic_ullong *volatile)&v891[2], memory_order_acquire);
                std::vector<TCFRef<__CFData *>,TInlineBufferAllocator<TCFRef<__CFData *>,30ul>>::emplace_back<TCFRef<__CFData const*>>((uint64_t)&v900[84], (atomic_ullong *)&v854);

                if (*(void *)v842) {
                  AddPrevLigaturesFromLigInputs(*(char ***)v842, *(char ***)v852, *(uint64_t *)&v852[8]);
                }
                v281  = 46;
              }
              else
              {
                v281  = 1;
              }
              v891[0]  = __dst;
              std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v891);
              if (!v788) {
                goto LABEL_540;
              }
              goto LABEL_1129;
            }
          }
          else if (v479 == 1)
          {
            v572  = *(void **)v893;
            v794  = *(void **)&v893[8];
            v795  = (uint64_t)v354;
            long long v160 = v821;
            if (*(void *)v893 != *(void *)&v893[8])
            {
              while (1)
              {
                v820  = v476;
                memset(__dst, 170, sizeof(__dst));
                v574  = v572[2];
                v573  = v572[3];
                memset(__dst, 0, 24);
                __dst[93]  = &__dst[3];
                std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::__init_with_size[abi:nn180100]<std::reverse_iterator<std::__wrap_iter<std::vector<unsigned short> const*>>,std::reverse_iterator<std::__wrap_iter<std::vector<unsigned short> const*>>>((char **)__dst, v573, v573, v574, v574, 0xAAAAAAAAAAAAAAABLL * ((v573 - v574) >> 3));
                memset(&v891[3], 170, 0x2D0uLL);
                memset(v891, 0, 24);
                v891[93]  = &v891[3];
                if (__dst[0] == __dst[1])
                {
                  v820  = v476 ^ 0x40000000;
                  std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::__assign_with_size[abi:nn180100]<std::reverse_iterator<std::__wrap_iter<std::vector<unsigned short> const*>>,std::reverse_iterator<std::__wrap_iter<std::vector<unsigned short> const*>>>((uint64_t *)__dst, v572[35], v572[35], v572[34], v572[34], 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v572[35] - v572[34]) >> 3));
                }
                else
                {
                  std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<std::vector<unsigned short> const*>,std::__wrap_iter<std::vector<unsigned short> const*>>((uint64_t *)v891, v572[34], v572[35], 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v572[35] - v572[34]) >> 3));
                }
                CFMutableArrayRef Mutable = CFDataCreateMutable(allocator, 0);
                CFDataSetLength(Mutable, length);
                v816  = CFDataGetMutableBytePtr(Mutable);
                v576  = *(void *)(v808 + 144);
                *(void *)&v577  = 0xAAAAAAAAAAAAAAAALL;
                *((void *)&v577 + 1)  = 0xAAAAAAAAAAAAAAAALL;
                v890  = v577;
                *(_OWORD *)&v889[48]  = v577;
                *(_OWORD *)&v889[32]  = v577;
                *(_OWORD *)&v889[16]  = v577;
                *(_OWORD *)v889  = v577;
                *(_OWORD *)v888  = v577;
                std::vector<unsigned short>::vector(v888, v576);
                v578  = *v829;
                v579  = v829[2];
                *(__n128 *)&v889[24]  = v829[1];
                *(__n128 *)&v889[40]  = v579;
                *(__n128 *)&v889[8]  = v578;
                std::vector<unsigned short>::vector(&v889[56], v795);
                v851  = (id)0xAAAAAAAAAAAAAAAALL;
                v810  = v843;
                v835  = 0;
                v833  = 0;
                v834  = 0;
                v580  = v888[0];
                v581  = (char *)v888[1] - (char *)v888[0];
                if (v888[1] == v888[0])
                {
                  v583  = 0;
                }
                else
                {
                  std::vector<unsigned short>::__vallocate[abi:nn180100](&v833, v581 >> 1);
                  v582  = (char *)v834;
                  memmove(v834, v580, v581);
                  v583  = &v582[v581];
                  v834  = &v582[v581];
                }
                v836  = *(_OWORD *)&v889[8];
                v837  = *(_OWORD *)&v889[24];
                v838  = *(_OWORD *)&v889[40];
                v840  = 0;
                v841  = 0;
                v839  = 0;
                v584  = *(const void **)&v889[56];
                v585  = v890 - *(void *)&v889[56];
                if ((void)v890 == *(void *)&v889[56])
                {
                  v587  = 0;
                }
                else
                {
                  std::vector<unsigned short>::__vallocate[abi:nn180100](&v839, v585 >> 1);
                  v586  = (char *)v840;
                  memmove(v840, v584, v585);
                  v587  = &v586[v585];
                  v840  = &v586[v585];
                  v583  = (char *)v834;
                }
                v887  = 0;
                v588  = operator new(0x68uLL);
                *v588  = &unk_1ED060A58;
                v588[1]  = 0;
                v588[2]  = 0;
                v588[3]  = 0;
                v589  = v833;
                v590  = v583 - (unsigned char *)v833;
                if (v583 != v833)
                {
                  std::vector<unsigned short>::__vallocate[abi:nn180100](v588 + 1, v590 >> 1);
                  v591  = (char *)v588[2];
                  memmove(v591, v589, v590);
                  v588[2]  = &v591[v590];
                  v587  = (char *)v840;
                }
                v592  = v837;
                *((_OWORD *)v588 + 2)  = v836;
                *((_OWORD *)v588 + 3)  = v592;
                *((_OWORD *)v588 + 4)  = v838;
                v593  = v841;
                v588[10]  = v839;
                v588[11]  = v587;
                v588[12]  = v593;
                v840  = 0;
                v841  = 0;
                v839  = 0;
                v887  = v588;
                CreateSingleSubstitutionLookupTable((atomic_ullong *)&v851, GlyphCount, 1, (unsigned __int16 *)v797, (unint64_t)v810, (uint64_t)v816, (uint64_t)v886, 0);
                std::__function::__value_func<BOOL ()(unsigned short)>::~__value_func[abi:nn180100](v886);
                v476  = v820;
                if (v839)
                {
                  v840  = v839;
                  operator delete(v839);
                }
                if (v833)
                {
                  v834  = v833;
                  operator delete(v833);
                }
                if (!atomic_load_explicit((atomic_ullong *volatile)&v851, memory_order_acquire))
                {
                  v757  = 1;
                  goto LABEL_1097;
                }
                v883  = 0xAAAAAAAAAAAAAAAALL;
                *(void *)&v594  = 0xAAAAAAAAAAAAAAAALL;
                *((void *)&v594 + 1)  = 0xAAAAAAAAAAAAAAAALL;
                v881  = v594;
                v882  = v594;
                v879  = v594;
                v880  = v594;
                v877  = v594;
                v878  = v594;
                v875  = v594;
                v876  = v594;
                v873  = v594;
                v874  = v594;
                v871  = v594;
                v872  = v594;
                v869  = v594;
                v870  = v594;
                v868  = 0xAAAAAAAAAAAAAAAALL;
                v862  = v594;
                v863  = 0xAAAAAAAAAAAAAAAALL;
                v860  = v594;
                v861  = v594;
                v859  = 0xAAAAAAAAAAAAAAAALL;
                v855  = (int64x2_t)0xAAAAAAAAAAAAAAAALL;
                v856  = (char *)0xAAAAAAAAAAAAAAAALL;
                v857  = 0u;
                v858  = 0u;
                v864  = &v859;
                v866  = 0;
                v867  = 0;
                v865  = 0;
                v884  = &v868;
                v854  = &unk_1ED05F900;
                v885  = 0;
                v595  = v829->n128_i32[3];
                v596  = (const __CFData *)atomic_load_explicit((atomic_ullong *volatile)&v851, memory_order_acquire);
                memset(v844, 0, 32);
                v844[4]  = (void *)0xAAAAAAAA3F800000;
                LODWORD(v911[0])  = 1;
                v597  = (unsigned __int16 **)__dst[0];
                v598  = (unsigned __int16 **)__dst[1];
                if (__dst[0] != __dst[1])
                {
                  v599  = 1;
                  do
                  {
                    v600  = *v597;
                    v601  = v597[1];
                    if (*v597 != v601)
                    {
                      do
                      {
                        v602  = *v600++;
                        *(_WORD *)v852  = v602;
                        v603  = (int)v911[0];
                        v604  = std::__hash_table<std::__hash_value_type<unsigned short,unsigned int>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,unsigned int>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,unsigned int>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,unsigned int>>>::__emplace_unique_key_args<unsigned short,std::piecewise_construct_t const&,std::tuple<unsigned short const&>,std::tuple<>>((float *)v844, v602, v852);
                        *((_DWORD *)v604 + 5) |= v603;
                      }
                      while (v600 != v601);
                      v599  = (int)v911[0];
                    }
                    v599 *= 2;
                    LODWORD(v911[0])  = v599;
                    v597 += 3;
                  }
                  while (v597 != v598);
                }
                *(void *)&v852[48]  = 0xAAAAAAAAAAAAAAAALL;
                *(void *)&v605  = 0xAAAAAAAAAAAAAAAALL;
                *((void *)&v605 + 1)  = 0xAAAAAAAAAAAAAAAALL;
                *(_OWORD *)&v852[16]  = v605;
                *(_OWORD *)&v852[32]  = v605;
                *(_OWORD *)v852  = v605;
                if (!v596) {
                  break;
                }
                BytePtr  = (const SFNTLookupTable *)CFDataGetBytePtr(v596);
                v607  = CFDataGetBytePtr(v596);
                if (!v607) {
                  goto LABEL_899;
                }
                v608  = (SFNTLookupTable *)&v607[CFDataGetLength(v596)];
LABEL_900:
                *(void *)v852  = TAATLookupTable::BadTable;
                *(void *)&v852[8]  = 0;
                *(void *)&v852[40]  = 0;
                *(_WORD *)&v852[48]  = -1;
                TAATLookupTable::SetTable((uint64_t)v852, BytePtr, v608);
                v929  = &unk_1ED060B30;
                v930  = v844;
                v931  = v911;
                v932  = (void **)&v929;
                TAATLookupTable::Iterate((uint64_t)v852, (uint64_t)&v929);
                std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100](&v929);
                v609  = (unsigned __int16 **)v891[0];
                v610  = (unsigned __int16 **)v891[1];
                while (v609 != v610)
                {
                  LODWORD(v911[0]) *= 2;
                  v611  = *v609;
                  v612  = v609[1];
                  while (v611 != v612)
                  {
                    v613  = *v611++;
                    *(_WORD *)bytes  = v613;
                    v614  = (int)v911[0];
                    v615  = std::__hash_table<std::__hash_value_type<unsigned short,unsigned int>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,unsigned int>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,unsigned int>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,unsigned int>>>::__emplace_unique_key_args<unsigned short,std::piecewise_construct_t const&,std::tuple<unsigned short const&>,std::tuple<>>((float *)v844, v613, bytes);
                    *((_DWORD *)v615 + 5) |= v614;
                  }
                  v609 += 3;
                }
                CFDataRef theData = v596;
                v799  = Mutable;
                v800  = v572;
                v616  = NewLKTHandle(GlyphCount, 1);
                memset(&v852[24], 170, 0x2D0uLL);
                memset(v852, 0, 24);
                *(void *)&v852[744]  = &v852[24];
                v617  = __dst[0];
                v811  = __dst[1];
                v817  = v616;
                v618  = 4;
                if (__dst[0] == __dst[1])
                {
                  v476  = v820;
                }
                else
                {
                  do
                  {
                    *(void *)&v619  = 0xAAAAAAAAAAAAAAAALL;
                    *((void *)&v619 + 1)  = 0xAAAAAAAAAAAAAAAALL;
                    v926  = v619;
                    v927  = v619;
                    v924  = v619;
                    v925  = v619;
                    v922  = v619;
                    v923  = v619;
                    v920  = v619;
                    v921  = v619;
                    v918  = v619;
                    v919  = v619;
                    v916  = v619;
                    v917  = v619;
                    v914  = v619;
                    v915  = v619;
                    v913  = v619;
                    v911[0]  = 0;
                    v911[1]  = 0;
                    v912  = 0;
                    v928  = &v913;
                    v620  = (_WORD *)*v617;
                    v621  = (_WORD *)v617[1];
                    if ((_WORD *)*v617 == v621)
                    {
                      v626  = 0;
                      v639  = 0;
                    }
                    else
                    {
                      do
                      {
                        LOWORD(v933[0])  = *v620;
                        v622  = (__int16)v933[0];
                        v623  = std::__hash_table<std::__hash_value_type<unsigned short,unsigned int>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,unsigned int>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,unsigned int>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,unsigned int>>>::__emplace_unique_key_args<unsigned short,std::piecewise_construct_t const&,std::tuple<unsigned short const&>,std::tuple<>>((float *)v844, (unsigned __int16)v933[0], v933);
                        v624  = v623;
                        v625  = v911[1];
                        if (v911[1] >= v912)
                        {
                          v627  = ((char *)v911[1] - (char *)v911[0]) >> 3;
                          v628  = v627 + 1;
                          if ((unint64_t)(v627 + 1) >> 61) {
                            goto LABEL_1145;
                          }
                          v629  = v912 - (char *)v911[0];
                          if ((v912 - (char *)v911[0]) >> 2 > v628) {
                            v628  = v629 >> 2;
                          }
                          if ((unint64_t)v629 >= 0x7FFFFFFFFFFFFFF8) {
                            v630  = 0x1FFFFFFFFFFFFFFFLL;
                          }
                          else {
                            v630  = v628;
                          }
                          *(void *)&v935  = &v913;
                          v631  = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&v913, v630);
                          v632  = &v631[8 * v627];
                          *(_WORD *)v632  = v622;
                          *((_DWORD *)v632 + 1)  = *((_DWORD *)v624 + 5);
                          v633  = (char *)v911[1];
                          v634  = (char *)v911[0];
                          if (v911[1] == v911[0])
                          {
                            v637  = vdupq_n_s64((unint64_t)v911[1]);
                            v635  = &v631[8 * v627];
                          }
                          else
                          {
                            v635  = &v631[8 * v627];
                            do
                            {
                              v636  = *((void *)v633 - 1);
                              v633 -= 8;
                              *((void *)v635 - 1)  = v636;
                              v635 -= 8;
                            }
                            while (v633 != v634);
                            v637  = *(int64x2_t *)v911;
                          }
                          v626  = v632 + 8;
                          v911[0]  = v635;
                          v911[1]  = v632 + 8;
                          *(int64x2_t *)&UInt8 bytes[8] = v637;
                          v638  = v912;
                          v912  = &v631[8 * v630];
                          *(void *)&bytes[24]  = v638;
                          *(void *)bytes  = v637.i64[0];
                          std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)bytes);
                        }
                        else
                        {
                          *(_WORD *)v911[1]  = v622;
                          v625[1]  = *((_DWORD *)v623 + 5);
                          v626  = v625 + 2;
                        }
                        v911[1]  = v626;
                        ++v620;
                      }
                      while (v620 != v621);
                      v639  = v911[0];
                    }
                    v640  = 126 - 2 * __clz(((char *)v626 - v639) >> 3);
                    if (v626 == (_DWORD *)v639) {
                      v641  = 0;
                    }
                    else {
                      v641  = v640;
                    }
                    memset(bytes, 170, 24);
                    v616  = v817;
                    AddGlyphClassesByAppearance((unsigned __int16 **)bytes, v817, v618, (unsigned __int16 *)v911[0], (unsigned __int16 *)v911[1]);
                    std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::push_back[abi:nn180100](v852, (uint64_t)bytes);
                    v642  = *(_WORD *)(*(void *)&bytes[8] - 2);
                    v476  = v820;
                    if (*(void *)bytes)
                    {
                      *(void *)&UInt8 bytes[8] = *(void *)bytes;
                      operator delete(*(void **)bytes);
                    }
                    v618  = v642 + 1;
                    std::vector<std::pair<unsigned short,unsigned int>,TInlineBufferAllocator<std::pair<unsigned short,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)v911);
                    v617 += 3;
                  }
                  while (v617 != v811);
                }
                *(void *)&v643  = 0xAAAAAAAAAAAAAAAALL;
                *((void *)&v643 + 1)  = 0xAAAAAAAAAAAAAAAALL;
                v926  = v643;
                v927  = v643;
                v924  = v643;
                v925  = v643;
                v922  = v643;
                v923  = v643;
                v920  = v643;
                v921  = v643;
                v918  = v643;
                v919  = v643;
                v916  = v643;
                v917  = v643;
                v914  = v643;
                v915  = v643;
                v913  = v643;
                v911[0]  = 0;
                v911[1]  = 0;
                v912  = 0;
                v928  = &v913;
                v936  = 0xAAAAAAAAAAAAAAAALL;
                *(_OWORD *)&bytes[16]  = v643;
                v935  = v643;
                *(_OWORD *)bytes  = v643;
                if (theData)
                {
                  v644  = (const SFNTLookupTable *)CFDataGetBytePtr(theData);
                  v645  = CFDataGetBytePtr(theData);
                  long long v160 = v821;
                  if (v645) {
                    v646  = (SFNTLookupTable *)&v645[CFDataGetLength(theData)];
                  }
                  else {
                    v646  = 0;
                  }
                }
                else
                {
                  v644  = 0;
                  v646  = 0;
                  long long v160 = v821;
                }
                *(void *)bytes  = TAATLookupTable::BadTable;
                *(void *)&UInt8 bytes[8] = 0;
                *((void *)&v935 + 1)  = 0;
                LOWORD(v936)  = -1;
                TAATLookupTable::SetTable((uint64_t)bytes, v644, v646);
                v907  = &unk_1ED060B78;
                v908  = v911;
                v909  = v844;
                v910  = &v907;
                TAATLookupTable::Iterate((uint64_t)bytes, (uint64_t)&v907);
                std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100](&v907);
                v647  = 126 - 2 * __clz(((char *)v911[1] - (char *)v911[0]) >> 3);
                if (v911[1] == v911[0]) {
                  v648  = 0;
                }
                else {
                  v648  = v647;
                }
                memset(v933, 170, 24);
                AddGlyphClassesByAppearance(v933, v616, v618, (unsigned __int16 *)v911[0], (unsigned __int16 *)v911[1]);
                v649  = v933[0];
                v798  = v933[1];
                if (v933[0] == v933[1])
                {
                  if (v933[0])
                  {
                    v933[1]  = v933[0];
                    operator delete(v933[0]);
                  }
                  std::vector<std::pair<unsigned short,unsigned int>,TInlineBufferAllocator<std::pair<unsigned short,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)v911);
                  goto LABEL_1057;
                }
                v796  = v933[0];
                std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::push_back[abi:nn180100](v852, (uint64_t)v933);
                v650  = v933[0];
                if (v933[0] != v933[1])
                {
                  v651  = v933[0] + 1;
                  v650  = v933[0];
                  if (v933[0] + 1 != v933[1])
                  {
                    v652  = *v933[0];
                    v650  = v933[0];
                    v653  = v933[0] + 1;
                    do
                    {
                      v655  = *v653++;
                      v654  = v655;
                      v656  = v652 >= v655;
                      if (v652 <= v655) {
                        v652  = v654;
                      }
                      if (!v656) {
                        v650  = v651;
                      }
                      v651  = v653;
                    }
                    while (v653 != v933[1]);
                  }
                }
                if (v618 <= *v650) {
                  v657  = *v650;
                }
                else {
                  v657  = v618;
                }
                if (v933[0])
                {
                  v933[1]  = v933[0];
                  operator delete(v933[0]);
                }
                std::vector<std::pair<unsigned short,unsigned int>,TInlineBufferAllocator<std::pair<unsigned short,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)v911);
                v658  = v891[0];
                v659  = v891[1];
                v660  = v657 + 1;
                v812  = v891[1];
                while (v658 != v659)
                {
                  *(void *)&v661  = 0xAAAAAAAAAAAAAAAALL;
                  *((void *)&v661 + 1)  = 0xAAAAAAAAAAAAAAAALL;
                  v926  = v661;
                  v927  = v661;
                  v924  = v661;
                  v925  = v661;
                  v922  = v661;
                  v923  = v661;
                  v920  = v661;
                  v921  = v661;
                  v918  = v661;
                  v919  = v661;
                  v916  = v661;
                  v917  = v661;
                  v914  = v661;
                  v915  = v661;
                  v913  = v661;
                  v911[0]  = 0;
                  v911[1]  = 0;
                  v912  = 0;
                  v928  = &v913;
                  v662  = (_WORD *)*v658;
                  v663  = (_WORD *)v658[1];
                  if ((_WORD *)*v658 == v663)
                  {
                    v668  = 0;
                    v681  = 0;
                  }
                  else
                  {
                    do
                    {
                      LOWORD(v933[0])  = *v662;
                      v664  = (__int16)v933[0];
                      v665  = std::__hash_table<std::__hash_value_type<unsigned short,unsigned int>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,unsigned int>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,unsigned int>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,unsigned int>>>::__emplace_unique_key_args<unsigned short,std::piecewise_construct_t const&,std::tuple<unsigned short const&>,std::tuple<>>((float *)v844, (unsigned __int16)v933[0], v933);
                      v666  = v665;
                      v667  = v911[1];
                      if (v911[1] >= v912)
                      {
                        v669  = ((char *)v911[1] - (char *)v911[0]) >> 3;
                        v670  = v669 + 1;
                        if ((unint64_t)(v669 + 1) >> 61) {
                          goto LABEL_1145;
                        }
                        v671  = v912 - (char *)v911[0];
                        if ((v912 - (char *)v911[0]) >> 2 > v670) {
                          v670  = v671 >> 2;
                        }
                        if ((unint64_t)v671 >= 0x7FFFFFFFFFFFFFF8) {
                          v672  = 0x1FFFFFFFFFFFFFFFLL;
                        }
                        else {
                          v672  = v670;
                        }
                        *(void *)&v935  = &v913;
                        v673  = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&v913, v672);
                        v674  = &v673[8 * v669];
                        *(_WORD *)v674  = v664;
                        *((_DWORD *)v674 + 1)  = *((_DWORD *)v666 + 5);
                        v675  = (char *)v911[1];
                        v676  = (char *)v911[0];
                        if (v911[1] == v911[0])
                        {
                          v679  = vdupq_n_s64((unint64_t)v911[1]);
                          v677  = &v673[8 * v669];
                        }
                        else
                        {
                          v677  = &v673[8 * v669];
                          do
                          {
                            v678  = *((void *)v675 - 1);
                            v675 -= 8;
                            *((void *)v677 - 1)  = v678;
                            v677 -= 8;
                          }
                          while (v675 != v676);
                          v679  = *(int64x2_t *)v911;
                        }
                        v668  = v674 + 8;
                        v911[0]  = v677;
                        v911[1]  = v674 + 8;
                        *(int64x2_t *)&UInt8 bytes[8] = v679;
                        v680  = v912;
                        v912  = &v673[8 * v672];
                        *(void *)&bytes[24]  = v680;
                        *(void *)bytes  = v679.i64[0];
                        std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)bytes);
                      }
                      else
                      {
                        *(_WORD *)v911[1]  = v664;
                        v667[1]  = *((_DWORD *)v665 + 5);
                        v668  = v667 + 2;
                      }
                      v911[1]  = v668;
                      ++v662;
                    }
                    while (v662 != v663);
                    v681  = v911[0];
                  }
                  v682  = 126 - 2 * __clz(((char *)v668 - v681) >> 3);
                  if (v668 == (_DWORD *)v681) {
                    v683  = 0;
                  }
                  else {
                    v683  = v682;
                  }
                  memset(bytes, 170, 24);
                  v657  = v660;
                  v616  = v817;
                  AddGlyphClassesByAppearance((unsigned __int16 **)bytes, v817, v660, (unsigned __int16 *)v911[0], (unsigned __int16 *)v911[1]);
                  std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::push_back[abi:nn180100](v852, (uint64_t)bytes);
                  v684  = *(unsigned __int16 **)bytes;
                  if (*(void *)bytes != *(void *)&bytes[8])
                  {
                    v685  = *(void *)bytes + 2;
                    v684  = *(unsigned __int16 **)bytes;
                    if (*(void *)bytes + 2 != *(void *)&bytes[8])
                    {
                      v686  = **(_WORD **)bytes;
                      v684  = *(unsigned __int16 **)bytes;
                      v687  = (unsigned __int16 *)(*(void *)bytes + 2);
                      do
                      {
                        v689  = *v687++;
                        v688  = v689;
                        v690  = v686 >= v689;
                        if (v686 <= v689) {
                          v686  = v688;
                        }
                        if (!v690) {
                          v684  = (unsigned __int16 *)v685;
                        }
                        v685  = (uint64_t)v687;
                      }
                      while (v687 != *(unsigned __int16 **)&bytes[8]);
                    }
                  }
                  if (v660 <= *v684) {
                    v657  = *v684;
                  }
                  if (*(void *)bytes)
                  {
                    *(void *)&UInt8 bytes[8] = *(void *)bytes;
                    operator delete(*(void **)bytes);
                  }
                  std::vector<std::pair<unsigned short,unsigned int>,TInlineBufferAllocator<std::pair<unsigned short,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)v911);
                  v658 += 3;
                  v660  = v657 + 1;
                  v659  = v812;
                }
                v691  = (unsigned __int16 *)v829[3].n128_u64[0];
                v692  = (unsigned __int16 *)v829[3].n128_u64[1];
                if (v691 != v692)
                {
                  do
                  {
                    v693  = *v691++;
                    LKTAddRange(v616, v693, v693, v660);
                  }
                  while (v691 != v692);
                  v660  = v657 + 2;
                }
                LODWORD(v856)  = v660;
                LKTCreateLookupTable(v616, (atomic_ullong *)v911);

                DisposeLKTHandle(v616);
                *(void *)&v694  = 0xAAAAAAAAAAAAAAAALL;
                *((void *)&v694 + 1)  = 0xAAAAAAAAAAAAAAAALL;
                v915  = v694;
                v916  = v694;
                v913  = v694;
                v914  = v694;
                v695  = v856;
                v911[0]  = 0;
                v911[1]  = 0;
                v912  = 0;
                *(void *)&v917  = &v913;
                if (v856)
                {
                  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__vallocate[abi:nn180100](v911, v856);
                  v696  = (char *)v911[1];
                  bzero(v911[1], 2 * v695);
                  v911[1]  = &v696[2 * v695];
                }
                v697  = GetActionIndex(&v865, 0, 0, 0xFFFFu, 0xFFFFFFFFLL);
                v698  = (int)v856;
                if (v856)
                {
                  v699  = v911[0];
                  do
                  {
                    *v699++  = v697;
                    --v698;
                  }
                  while (v698);
                }
                v700  = GetActionIndex(&v865, 0, 0x4000u, 0xFFFFu, 0xFFFFFFFFLL);
                v701  = GetActionIndex(&v865, 2u, 0, 0xFFFFu, 0xFFFFFFFFLL);
                v702  = **(unsigned __int16 ***)v852;
                v703  = *(unsigned __int16 **)(*(void *)v852 + 8);
                v704  = v911[0];
                while (v702 != v703)
                {
                  v705  = *v702++;
                  v704[v705]  = v701;
                }
                std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::__wrap_iter<unsigned short *>,std::__wrap_iter<unsigned short *>,std::back_insert_iterator<TInlineVector<unsigned short,30ul>>,0>((uint64_t)v704, &v704[v856], (char **)&v857 + 1);
                std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::__wrap_iter<unsigned short *>,std::__wrap_iter<unsigned short *>,std::back_insert_iterator<TInlineVector<unsigned short,30ul>>,0>((uint64_t)v911[0], (_WORD *)v911[0] + v856, (char **)&v857 + 1);
                v706  = v891[0];
                v707  = v891[1];
                if (__dst[1] != __dst[0])
                {
                  v708  = 0;
                  v709  = ((char *)__dst[1] - (char *)__dst[0]) / 24;
                  if (v709 <= 1) {
                    v710  = 1;
                  }
                  else {
                    v710  = ((char *)__dst[1] - (char *)__dst[0]) / 24;
                  }
                  while (1)
                  {
                    v711  = (int)v856;
                    if (v856)
                    {
                      v712  = v911[0];
                      do
                      {
                        *v712++  = v700;
                        --v711;
                      }
                      while (v711);
                    }
                    v713  = GetActionIndex(&v865, (unsigned __int16)(v708 + 2), 0, 0xFFFFu, 0xFFFFFFFFLL);
                    v714  = v911[0];
                    *((_WORD *)v911[0] + 2)  = v713;
                    if (v829[3].n128_u64[0] != v829[3].n128_u64[1]) {
                      v714[v856 - 1]  = v713;
                    }
                    if (v709 > (unsigned __int16)++v708) {
                      break;
                    }
                    if (v706 != v707)
                    {
                      v715  = (unsigned __int16)(v708 + 2);
                      v716  = 0x8000;
                      goto LABEL_1015;
                    }
                    v715  = 0;
                    v716  = 0;
                    v717  = 0;
LABEL_1016:
                    v718  = GetActionIndex(&v865, v715, v716, 0xFFFFu, v717);
                    v719  = *(void *)v852 + 24 * v708;
                    v720  = *(unsigned __int16 **)v719;
                    v721  = *(unsigned __int16 **)(v719 + 8);
                    v722  = v911[0];
                    while (v720 != v721)
                    {
                      v723  = *v720++;
                      v722[v723]  = v718;
                    }
                    std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::__wrap_iter<unsigned short *>,std::__wrap_iter<unsigned short *>,std::back_insert_iterator<TInlineVector<unsigned short,30ul>>,0>((uint64_t)v722, &v722[v856], (char **)&v857 + 1);
                    if (v708 == v710) {
                      goto LABEL_1022;
                    }
                  }
                  v715  = (unsigned __int16)(v708 + 2);
                  v716  = 0;
LABEL_1015:
                  v717  = 0xFFFFFFFFLL;
                  goto LABEL_1016;
                }
LABEL_1022:
                if (v706 != v707 && v891[1] != v891[0])
                {
                  v724  = 0;
                  v725  = 0xAAAAAAAAAAAAAAABLL * (((char *)__dst[1] - (char *)__dst[0]) >> 3);
                  v726  = ((char *)v891[1] - (char *)v891[0]) / 24;
                  if (v726 <= 1) {
                    v727  = 1;
                  }
                  else {
                    v727  = ((char *)v891[1] - (char *)v891[0]) / 24;
                  }
                  do
                  {
                    v728  = (int)v856;
                    if (v856)
                    {
                      v729  = v911[0];
                      do
                      {
                        *v729++  = v700;
                        --v728;
                      }
                      while (v728);
                    }
                    v730  = v724 + v725;
                    v731  = GetActionIndex(&v865, (unsigned __int16)(v724 + v725 + 2), 0, 0xFFFFu, 0xFFFFFFFFLL);
                    v732  = v911[0];
                    *((_WORD *)v911[0] + 2)  = v731;
                    if (v829[3].n128_u64[0] != v829[3].n128_u64[1]) {
                      v732[v856 - 1]  = v731;
                    }
                    if (v726 <= (unsigned __int16)++v724)
                    {
                      v733  = 0;
                      v734  = 0;
                    }
                    else
                    {
                      v733  = (unsigned __int16)(v724 + v725 + 2);
                      v734  = -1;
                    }
                    v735  = GetActionIndex(&v865, v733, 0, v734, 0xFFFFFFFFLL);
                    v736  = *(void *)v852 + 24 * v730;
                    v737  = *(unsigned __int16 **)(v736 + 24);
                    v738  = *(unsigned __int16 **)(v736 + 32);
                    v739  = v911[0];
                    while (v737 != v738)
                    {
                      v740  = *v737++;
                      v739[v740]  = v735;
                    }
                    std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::__wrap_iter<unsigned short *>,std::__wrap_iter<unsigned short *>,std::back_insert_iterator<TInlineVector<unsigned short,30ul>>,0>((uint64_t)v739, &v739[v856], (char **)&v857 + 1);
                  }
                  while (v724 != v727);
                }
                v845  = CFDataCreateMutable(allocator, 0);
                v741  = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)&v845, memory_order_acquire);
                *(_DWORD *)bytes  = 0x4000000;
                CFDataAppendBytes(v741, bytes, 4);

                if (v856 >= 2)
                {
                  long long v160 = v821;
                  if ((void)v858 - *((void *)&v857 + 1) < 3uLL
                    || (v744  = *(unsigned __int16 *)(*((void *)&v857 + 1) + 2), v744 >= (v866 - (uint64_t)v865) >> 3))
                  {
                    v743  = 0;
                  }
                  else
                  {
                    v743  = v865[v744];
                  }
                }
                else
                {
                  v743  = 0;
                  long long v160 = v821;
                }
                v745  = CFDataGetMutableBytePtr((CFMutableDataRef)atomic_load_explicit(&v855.i64[1], memory_order_acquire));
                v746  = (const __CFData *)(id)atomic_load_explicit((atomic_ullong *volatile)&v857, memory_order_acquire);
                v747  = v746;
                if (v746) {
                  v748  = (const SFNTLookupTable *)CFDataGetBytePtr(v746);
                }
                else {
                  v748  = 0;
                }
                v749  = (id)atomic_load_explicit((atomic_ullong *volatile)&v857, memory_order_acquire);
                v750  = (const __CFData *)v749;
                if (!v750)
                {

LABEL_1055:
                  v753  = 0;
                  goto LABEL_1056;
                }
                v751  = v750;
                v752  = CFDataGetBytePtr(v750);

                if (!v752) {
                  goto LABEL_1055;
                }
                v753  = (SFNTLookupTable *)&v752[CFDataGetLength((CFDataRef)v749)];
LABEL_1056:
                *(void *)bytes  = TAATLookupTable::BadTable;
                *(void *)&UInt8 bytes[8] = 0;
                *((void *)&v935 + 1)  = 0;
                LOWORD(v936)  = -1;
                TAATLookupTable::SetTable((uint64_t)bytes, v748, v753);
                v754  = operator new(0x28uLL);
                *v754  = &unk_1ED060C98;
                v754[1]  = &v854;
                v754[2]  = GlyphCount;
                v754[3]  = v745;
                *((_WORD *)v754 + 16)  = v743;
                v933[3]  = (unsigned __int16 *)v754;
                TAATLookupTable::Iterate((uint64_t)bytes, (uint64_t)v933);
                std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100](v933);

                *(void *)bytes  = v911;
                std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)bytes);
                v476  = v820;
                v649  = v796;
LABEL_1057:
                CFMutableArrayRef Mutable = v799;
                v572  = v800;
                v911[0]  = v852;
                std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v911);
                std::__hash_table<EncoderAttempt,std::hash<EncoderAttempt>,std::equal_to<EncoderAttempt>,std::allocator<EncoderAttempt>>::~__hash_table((uint64_t)v844);
                if (v649 == v798)
                {
                  v757  = 1;
                }
                else
                {
                  v755  = v900[51];
                  if (v900[51] >= v900[52])
                  {
                    v758  = ((char *)v900[51] - (char *)v900[50]) >> 3;
                    if ((unint64_t)(v758 + 1) >> 61) {
                      goto LABEL_1145;
                    }
                    v759  = ((char *)v900[52] - (char *)v900[50]) >> 2;
                    if (v759 <= v758 + 1) {
                      v759  = v758 + 1;
                    }
                    if ((id)((char *)v900[52] - (char *)v900[50]) >= (id)0x7FFFFFFFFFFFFFF8) {
                      v760  = 0x1FFFFFFFFFFFFFFFLL;
                    }
                    else {
                      v760  = v759;
                    }
                    *(void *)&v852[32]  = &v900[53];
                    if (v760) {
                      v761  = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&v900[53], v760);
                    }
                    else {
                      v761  = 0;
                    }
                    *(void *)v852  = v761;
                    *(void *)&v852[8]  = &v761[8 * v758];
                    *(void *)&v852[16]  = *(void *)&v852[8];
                    *(void *)&v852[24]  = &v761[8 * v760];
                    **(void **)&v852[8]  = atomic_exchange((atomic_ullong *volatile)v911, 0);
                    v762  = *(char **)&v852[8];
                    v756  = (void *)(*(void *)&v852[16] + 8);
                    *(void *)&v852[16] += 8;
                    v763  = (atomic_ullong *)v900[51];
                    v764  = (atomic_ullong *)v900[50];
                    if (v900[51] == v900[50])
                    {
                      v765  = vdupq_n_s64((unint64_t)v900[51]);
                      v476  = v820;
                    }
                    else
                    {
                      v476  = v820;
                      do
                      {
                        *((void *)v762 - 1)  = atomic_exchange(--v763, 0);
                        v762 -= 8;
                      }
                      while (v763 != v764);
                      v765  = *(int64x2_t *)&v900[50];
                      v756  = *(void **)&v852[16];
                    }
                    v900[50]  = v762;
                    v900[51]  = v756;
                    *(int64x2_t *)&v852[8]  = v765;
                    v766  = v900[52];
                    v900[52]  = *(id *)&v852[24];
                    *(void *)&v852[24]  = v766;
                    *(void *)v852  = v765.i64[0];
                    std::__split_buffer<TCFRef<__CFData *>,TInlineBufferAllocator<TCFRef<__CFData *>,30ul> &>::~__split_buffer((uint64_t)v852);
                  }
                  else
                  {
                    *v755  = atomic_exchange((atomic_ullong *volatile)v911, 0);
                    v756  = v755 + 1;
                  }
                  v900[51]  = v756;

                  v911[0]  = (id)atomic_load_explicit(&v855.i64[1], memory_order_acquire);
                  v767  = v900[85];
                  if (v900[85] >= v900[86])
                  {
                    v769  = ((char *)v900[85] - (char *)v900[84]) >> 3;
                    if ((unint64_t)(v769 + 1) >> 61) {
                      goto LABEL_1145;
                    }
                    v770  = ((char *)v900[86] - (char *)v900[84]) >> 2;
                    if (v770 <= v769 + 1) {
                      v770  = v769 + 1;
                    }
                    if ((id)((char *)v900[86] - (char *)v900[84]) >= (id)0x7FFFFFFFFFFFFFF8) {
                      v771  = 0x1FFFFFFFFFFFFFFFLL;
                    }
                    else {
                      v771  = v770;
                    }
                    *(void *)&v852[32]  = &v900[87];
                    if (v771) {
                      v772  = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&v900[87], v771);
                    }
                    else {
                      v772  = 0;
                    }
                    *(void *)v852  = v772;
                    *(void *)&v852[8]  = &v772[8 * v769];
                    *(void *)&v852[16]  = *(void *)&v852[8];
                    *(void *)&v852[24]  = &v772[8 * v771];
                    **(void **)&v852[8]  = atomic_exchange((atomic_ullong *volatile)v911, 0);
                    v773  = *(char **)&v852[8];
                    v768  = (void *)(*(void *)&v852[16] + 8);
                    *(void *)&v852[16] += 8;
                    v774  = (atomic_ullong *)v900[85];
                    v775  = (atomic_ullong *)v900[84];
                    if (v900[85] == v900[84])
                    {
                      v776  = vdupq_n_s64((unint64_t)v900[85]);
                      v476  = v820;
                    }
                    else
                    {
                      v476  = v820;
                      do
                      {
                        *((void *)v773 - 1)  = atomic_exchange(--v774, 0);
                        v773 -= 8;
                      }
                      while (v774 != v775);
                      v776  = *(int64x2_t *)&v900[84];
                      v768  = *(void **)&v852[16];
                    }
                    v900[84]  = v773;
                    v900[85]  = v768;
                    *(int64x2_t *)&v852[8]  = v776;
                    v777  = v900[86];
                    v900[86]  = *(id *)&v852[24];
                    *(void *)&v852[24]  = v777;
                    *(void *)v852  = v776.i64[0];
                    std::__split_buffer<TCFRef<__CFData *>,TInlineBufferAllocator<TCFRef<__CFData *>,30ul> &>::~__split_buffer((uint64_t)v852);
                  }
                  else
                  {
                    *v767  = atomic_exchange((atomic_ullong *volatile)v911, 0);
                    v768  = v767 + 1;
                  }
                  v900[85]  = v768;

                  if (*(void *)v842) {
                    AddPrevLigaturesFromSingleSubstitutionLookupTable(*(uint64_t *)v842, (CFDataRef)atomic_load_explicit((atomic_ullong *volatile)&v851, memory_order_acquire));
                  }
                  v757  = 0;
                }
                v854  = &unk_1ED05F900;

LABEL_1097:

                if (*(void *)&v889[56])
                {
                  *(void *)&v890  = *(void *)&v889[56];
                  operator delete(*(void **)&v889[56]);
                }
                if (v888[0])
                {
                  v888[1]  = v888[0];
                  operator delete(v888[0]);
                }

                *(void *)v852  = v891;
                std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v852);
                *(void *)v852  = __dst;
                std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v852);
                if (v757) {
                  goto LABEL_539;
                }
                v572 += 52;
                if (v572 == v794) {
                  goto LABEL_1129;
                }
              }
              BytePtr  = 0;
LABEL_899:
              v608  = 0;
              goto LABEL_900;
            }
LABEL_1129:
            v281  = 28;
            goto LABEL_540;
          }
LABEL_1106:
          v281  = 1;
          long long v160 = v821;
          goto LABEL_540;
        default:
          if (v162[1].n128_u16[3] != 1000) {
            goto LABEL_1132;
          }
          *(void *)&v852[392]  = 0xAAAAAAAAAAAAAAAALL;
          *(void *)&v222  = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v222 + 1)  = 0xAAAAAAAAAAAAAAAALL;
          *(_OWORD *)&v852[360]  = v222;
          *(_OWORD *)&v852[376]  = v222;
          *(_OWORD *)&v852[328]  = v222;
          *(_OWORD *)&v852[344]  = v222;
          *(_OWORD *)&v852[296]  = v222;
          *(_OWORD *)&v852[312]  = v222;
          *(_OWORD *)&v852[264]  = v222;
          *(_OWORD *)&v852[280]  = v222;
          *(_OWORD *)&v852[232]  = v222;
          *(_OWORD *)&v852[248]  = v222;
          *(_OWORD *)&v852[200]  = v222;
          *(_OWORD *)&v852[216]  = v222;
          *(_OWORD *)&v852[168]  = v222;
          *(_OWORD *)&v852[184]  = v222;
          *(void *)&v852[160]  = 0xAAAAAAAAAAAAAAAALL;
          *(_OWORD *)&v852[104]  = v222;
          *(void *)&v852[120]  = 0xAAAAAAAAAAAAAAAALL;
          *(_OWORD *)&v852[72]  = v222;
          *(_OWORD *)&v852[88]  = v222;
          *(void *)&v852[64]  = 0xAAAAAAAAAAAAAAAALL;
          *(void *)&v852[8]  = 0xAAAAAAAAAAAAAAAALL;
          *(void *)&v852[24]  = 0xAAAAAAAAAAAAAAAALL;
          memset(&v852[32], 0, 32);
          *(void *)&v852[16]  = 0;
          *(void *)&v852[128]  = &v852[64];
          memset(&v852[136], 0, 24);
          *(void *)&v852[400]  = &v852[160];
          *(void *)v852  = &unk_1ED05F900;
          *(void *)&v852[408]  = 0;
          int v223 = v162->n128_i32[3];
          uint64_t v224 = *(void *)v842;
          v818  = v843;
          uint64_t v225 = TBaseFont::GetGlyphCount(v813);
          v226  = v225;
          v228  = *(void *)v893;
          if (*(void *)v893)
          {
            uint64_t v229 = *(void *)&v893[8];
            CGRect v230 = *(unsigned char **)v893;
            if (*(void *)&v893[8] != *(void *)v893)
            {
              do
              {
                v229 -= 48;
                std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100](v229);
              }
              while (v229 != v228);
              CGRect v230 = *(unsigned char **)v893;
            }
            *(void *)&v893[8]  = v228;
            if (&v893[24] <= v230 && &v893[1464] > v230)
            {
              if (*(void *)&v893[16] == *(void *)&v893[1464]) {
                *(void *)&v893[1464]  = v230;
              }
            }
            else
            {
              operator delete(v230);
            }
          }
          if ((v227 & 1) == 0)
          {
            LOBYTE(v219)  = 0;
LABEL_632:
            v281  = 1;
            goto LABEL_816;
          }
          v308  = (uint64_t)&v829[3];
          v830  = CFDataGetMutableBytePtr((CFMutableDataRef)atomic_load_explicit((atomic_ullong *volatile)&v852[16], memory_order_acquire));
          memset(v844, 170, 24);
          std::vector<unsigned short>::vector(v844, v308);
          v851  = (id)0xAAAAAAAAAAAAAAAALL;
          v309  = *(void *)(v224 + 1568);
          v310  = *(unsigned __int16 **)(v224 + 1576);
          memset(v933, 0, 24);
          v311  = v844[0];
          v312  = (char *)v844[1] - (char *)v844[0];
          if (v844[1] == v844[0])
          {
            v314  = 0;
            v315  = 0;
          }
          else
          {
            std::vector<unsigned short>::__vallocate[abi:nn180100](v933, v312 >> 1);
            v313  = v933[1];
            memmove(v933[1], v311, v312);
            v314  = (unsigned __int16 *)((char *)v313 + v312);
            v933[1]  = (unsigned __int16 *)((char *)v313 + v312);
            v315  = v933[0];
          }
          v891[3]  = 0;
          v324  = operator new(0x20uLL);
          *v324  = &unk_1ED060BC0;
          v324[1]  = 0;
          v324[2]  = 0;
          v324[3]  = 0;
          v325  = (char *)v314 - (char *)v315;
          if (v314 != v315)
          {
            std::vector<unsigned short>::__vallocate[abi:nn180100](v324 + 1, v325 >> 1);
            v326  = (char *)v324[2];
            memmove(v326, v315, (char *)v314 - (char *)v315);
            v324[2]  = &v326[v325];
          }
          v891[3]  = v324;
          CreateSingleSubstitutionLookupTable((atomic_ullong *)&v851, v226, v309, v310, (unint64_t)v818, (uint64_t)v830, (uint64_t)v891, 0);
          std::__function::__value_func<BOOL ()(unsigned short)>::~__value_func[abi:nn180100](v891);
          if (v933[0])
          {
            v933[1]  = v933[0];
            operator delete(v933[0]);
          }
          v850  = (id)0xAAAAAAAAAAAAAAAALL;
          v327  = *(void *)(v224 + 1600);
          v328  = *(unsigned __int16 **)(v224 + 1608);
          v930  = 0;
          v931  = 0;
          v929  = 0;
          v329  = v844[0];
          v330  = (char *)v844[1] - (char *)v844[0];
          if (v844[1] == v844[0])
          {
            v332  = 0;
            v333  = 0;
          }
          else
          {
            std::vector<unsigned short>::__vallocate[abi:nn180100](&v929, v330 >> 1);
            v331  = v930;
            memmove(v930, v329, v330);
            v332  = (char *)v331 + v330;
            v930  = (void **)((char *)v331 + v330);
            v333  = v929;
          }
          v334  = (char *)operator new(0x20uLL);
          *(void *)v334  = &unk_1ED060BC0;
          *((void *)v334 + 1)  = 0;
          *((void *)v334 + 2)  = 0;
          *((void *)v334 + 3)  = 0;
          v335  = v332 - v333;
          if (v332 != v333)
          {
            std::vector<unsigned short>::__vallocate[abi:nn180100]((void *)v334 + 1, v335 >> 1);
            v336  = (char *)*((void *)v334 + 2);
            memmove(v336, v333, v332 - v333);
            *((void *)v334 + 2)  = &v336[v335];
          }
          v856  = v334;
          CreateSingleSubstitutionLookupTable((atomic_ullong *)&v850, v226, v327, v328, (unint64_t)v818, (uint64_t)v830, (uint64_t)&v854, 0);
          std::__function::__value_func<BOOL ()(unsigned short)>::~__value_func[abi:nn180100](&v854);
          if (v929)
          {
            v930  = (void **)v929;
            operator delete(v929);
          }
          v849  = 0;
          v337  = *(void *)(v224 + 1584);
          v338  = *(unsigned __int16 **)(v224 + 1592);
          v909  = 0;
          v907  = 0;
          v908  = 0;
          v339  = v844[0];
          v340  = (char *)v844[1] - (char *)v844[0];
          if (v844[1] == v844[0])
          {
            v342  = 0;
            v343  = 0;
          }
          else
          {
            std::vector<unsigned short>::__vallocate[abi:nn180100](&v907, v340 >> 1);
            v341  = (char *)v908;
            memmove(v908, v339, v340);
            v342  = &v341[v340];
            v908  = &v341[v340];
            v343  = v907;
          }
          v344  = operator new(0x20uLL);
          *v344  = &unk_1ED060BC0;
          v344[1]  = 0;
          v344[2]  = 0;
          v344[3]  = 0;
          v345  = v342 - v343;
          if (v342 != v343)
          {
            std::vector<unsigned short>::__vallocate[abi:nn180100](v344 + 1, v345 >> 1);
            v346  = (char *)v344[2];
            memmove(v346, v343, v342 - v343);
            v344[2]  = &v346[v345];
          }
          *(void *)&v913  = v344;
          SingleSubstitutionLKTHandle  = CreateSingleSubstitutionLKTHandle(v226, v337, v338, (unint64_t)v818, (uint64_t)v830, (uint64_t)v911, 0);
          std::__function::__value_func<BOOL ()(unsigned short)>::~__value_func[abi:nn180100](v911);
          if (v907)
          {
            v908  = v907;
            operator delete(v907);
          }
          if (!SingleSubstitutionLKTHandle) {
            goto LABEL_617;
          }
          if (!atomic_load_explicit((atomic_ullong *volatile)&v850, memory_order_acquire)) {
            goto LABEL_616;
          }
          __dst[6]  = (void *)0xAAAAAAAAAAAAAAAALL;
          *(void *)&v348  = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v348 + 1)  = 0xAAAAAAAAAAAAAAAALL;
          *(_OWORD *)&__dst[4]  = v348;
          *(_OWORD *)&unsigned int __dst[2] = v348;
          *(_OWORD *)__dst  = v348;
          v349  = (const __CFData *)(id)atomic_load_explicit((atomic_ullong *volatile)&v850, memory_order_acquire);
          v350  = v349;
          if (v349) {
            v351  = (const SFNTLookupTable *)CFDataGetBytePtr(v349);
          }
          else {
            v351  = 0;
          }
          v391  = (id)atomic_load_explicit((atomic_ullong *volatile)&v850, memory_order_acquire);
          v392  = (const __CFData *)v391;
          if (v392)
          {
            v393  = v392;
            v394  = CFDataGetBytePtr(v392);

            if (v394)
            {
              v395  = (SFNTLookupTable *)&v394[CFDataGetLength((CFDataRef)v391)];
              goto LABEL_615;
            }
          }
          else
          {
          }
          v395  = 0;
LABEL_615:
          __dst[0]  = TAATLookupTable::BadTable;
          __dst[1]  = 0;
          __dst[5]  = 0;
          LOWORD(__dst[6])  = -1;
          TAATLookupTable::SetTable((uint64_t)__dst, v351, v395);

          v888[0]  = &unk_1ED060C08;
          v888[1]  = SingleSubstitutionLKTHandle;
          *(void *)&v889[8]  = v888;
          TAATLookupTable::Iterate((uint64_t)__dst, (uint64_t)v888);
          std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100](v888);
LABEL_616:
          LKTCreateLookupTable(SingleSubstitutionLKTHandle, (atomic_ullong *)__dst);

          DisposeLKTHandle(SingleSubstitutionLKTHandle);
LABEL_617:
          __dst[0]  = 0;
          v396  = *(unsigned __int16 **)(v224 + 1624);
          if (v396)
          {
            v397  = *(void *)(v224 + 1616);
            v847  = 0;
            v845  = 0;
            v846  = 0;
            v398  = v844[0];
            v399  = (char *)v844[1] - (char *)v844[0];
            if (v844[1] == v844[0])
            {
              v401  = 0;
              v402  = 0;
            }
            else
            {
              std::vector<unsigned short>::__vallocate[abi:nn180100](&v845, v399 >> 1);
              v400  = (char *)v846;
              memmove(v846, v398, v399);
              v401  = &v400[v399];
              v846  = &v400[v399];
              v402  = v845;
            }
            v404  = operator new(0x20uLL);
            *v404  = &unk_1ED060BC0;
            v404[1]  = 0;
            v404[2]  = 0;
            v404[3]  = 0;
            v405  = v401 - v402;
            if (v401 != v402)
            {
              std::vector<unsigned short>::__vallocate[abi:nn180100](v404 + 1, v405 >> 1);
              v406  = (char *)v404[2];
              memmove(v406, v402, v401 - v402);
              v404[2]  = &v406[v405];
            }
            *(void *)&bytes[24]  = v404;
            CreateSingleSubstitutionLookupTable((atomic_ullong *)&v848, v226, v397, v396, (unint64_t)v818, (uint64_t)v830, (uint64_t)bytes, 0);

            std::__function::__value_func<BOOL ()(unsigned short)>::~__value_func[abi:nn180100](bytes);
            if (v845)
            {
              v846  = v845;
              operator delete(v845);
            }
            long long v160 = v821;
          }
          else
          {
            v403  = NewLKTHandle(v226, 0);
            LKTCreateLookupTable(v403, (atomic_ullong *)&v848);

            DisposeLKTHandle(v403);
            long long v160 = v821;
          }

          if (v844[0])
          {
            v844[1]  = v844[0];
            operator delete(v844[0]);
          }
          if (!v219) {
            goto LABEL_632;
          }
          v407  = v900[51];
          if (v900[51] >= v900[52])
          {
            v409  = ((char *)v900[51] - (char *)v900[50]) >> 3;
            if ((unint64_t)(v409 + 1) >> 61) {
              goto LABEL_1145;
            }
            v410  = ((char *)v900[52] - (char *)v900[50]) >> 2;
            if (v410 <= v409 + 1) {
              v410  = v409 + 1;
            }
            if ((id)((char *)v900[52] - (char *)v900[50]) >= (id)0x7FFFFFFFFFFFFFF8) {
              v411  = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              v411  = v410;
            }
            *(void *)&v893[32]  = &v900[53];
            if (v411) {
              v412  = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&v900[53], v411);
            }
            else {
              v412  = 0;
            }
            *(void *)v893  = v412;
            *(void *)&v893[8]  = &v412[8 * v409];
            *(void *)&v893[16]  = *(void *)&v893[8];
            *(void *)&v893[24]  = &v412[8 * v411];
            **(void **)&v893[8]  = atomic_exchange((atomic_ullong *volatile)__dst, 0);
            v524  = *(char **)&v893[8];
            v408  = (void *)(*(void *)&v893[16] + 8);
            *(void *)&v893[16] += 8;
            v525  = (atomic_ullong *)v900[51];
            v526  = (atomic_ullong *)v900[50];
            if (v900[51] == v900[50])
            {
              v527  = vdupq_n_s64((unint64_t)v900[51]);
            }
            else
            {
              do
              {
                *((void *)v524 - 1)  = atomic_exchange(--v525, 0);
                v524 -= 8;
              }
              while (v525 != v526);
              v527  = *(int64x2_t *)&v900[50];
              v408  = *(void **)&v893[16];
            }
            v900[50]  = v524;
            v900[51]  = v408;
            *(int64x2_t *)&v893[8]  = v527;
            v528  = v900[52];
            v900[52]  = *(id *)&v893[24];
            *(void *)&v893[24]  = v528;
            *(void *)v893  = v527.i64[0];
            std::__split_buffer<TCFRef<__CFData *>,TInlineBufferAllocator<TCFRef<__CFData *>,30ul> &>::~__split_buffer((uint64_t)v893);
          }
          else
          {
            *v407  = atomic_exchange((atomic_ullong *volatile)__dst, 0);
            v408  = v407 + 1;
          }
          v900[51]  = v408;

          __dst[0]  = (id)atomic_load_explicit((atomic_ullong *volatile)&v852[16], memory_order_acquire);
          v529  = v900[85];
          if (v900[85] >= v900[86])
          {
            v530  = ((char *)v900[85] - (char *)v900[84]) >> 3;
            if ((unint64_t)(v530 + 1) >> 61) {
              goto LABEL_1145;
            }
            v531  = ((char *)v900[86] - (char *)v900[84]) >> 2;
            if (v531 <= v530 + 1) {
              v531  = v530 + 1;
            }
            if ((id)((char *)v900[86] - (char *)v900[84]) >= (id)0x7FFFFFFFFFFFFFF8) {
              v532  = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              v532  = v531;
            }
            *(void *)&v893[32]  = &v900[87];
            if (v532) {
              v533  = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&v900[87], v532);
            }
            else {
              v533  = 0;
            }
            *(void *)v893  = v533;
            *(void *)&v893[8]  = &v533[8 * v530];
            *(void *)&v893[16]  = *(void *)&v893[8];
            *(void *)&v893[24]  = &v533[8 * v532];
            **(void **)&v893[8]  = atomic_exchange((atomic_ullong *volatile)__dst, 0);
            v534  = *(char **)&v893[8];
            v219  = *(void *)&v893[16] + 8;
            *(void *)&v893[16] += 8;
            v535  = (atomic_ullong *)v900[85];
            v536  = (atomic_ullong *)v900[84];
            if (v900[85] == v900[84])
            {
              v537  = vdupq_n_s64((unint64_t)v900[85]);
            }
            else
            {
              do
              {
                *((void *)v534 - 1)  = atomic_exchange(--v535, 0);
                v534 -= 8;
              }
              while (v535 != v536);
              v537  = *(int64x2_t *)&v900[84];
              v219  = *(void *)&v893[16];
            }
            v900[84]  = v534;
            v900[85]  = (id)v219;
            *(int64x2_t *)&v893[8]  = v537;
            v538  = v900[86];
            v900[86]  = *(id *)&v893[24];
            *(void *)&v893[24]  = v538;
            *(void *)v893  = v537.i64[0];
            std::__split_buffer<TCFRef<__CFData *>,TInlineBufferAllocator<TCFRef<__CFData *>,30ul> &>::~__split_buffer((uint64_t)v893);
          }
          else
          {
            *v529  = atomic_exchange((atomic_ullong *volatile)__dst, 0);
            v219  = (uint64_t)(v529 + 1);
          }
          v900[85]  = (id)v219;

          v281  = 28;
          LOBYTE(v219)  = 1;
LABEL_816:
          *(void *)v852  = &unk_1ED05F900;

LABEL_817:
          if ((v219 & 1) == 0) {
            goto LABEL_818;
          }
LABEL_819:
          if (v159 == v160) {
            break;
          }
          continue;
      }
      break;
    }
  }
  uint64_t v129 = 1;
LABEL_1132:
  *(void *)v893  = &v895;
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v893);
  *(void *)v893  = &v900[84];
  std::vector<TCFRef<__CFData const*>,TInlineBufferAllocator<TCFRef<__CFData const*>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v893);
  *(void *)v893  = &v900[50];
  std::vector<TCFRef<__CFData const*>,TInlineBufferAllocator<TCFRef<__CFData const*>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v893);
  *(void *)v893  = &v900[1];
  std::vector<MortFeatureEntry,TInlineBufferAllocator<MortFeatureEntry,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v893);
LABEL_1133:
  v789  = (__n128 *)v902;
  if (v902)
  {
    v790  = v903;
    v791  = v902;
    if (v903 != v902)
    {
      do
      {
        v792  = (void *)v790[-2].n128_u64[1];
        if (v792)
        {
          v790[-1].n128_u64[0]  = (unint64_t)v792;
          operator delete(v792);
        }
        v790  = (__n128 *)((char *)v790 - 72);
      }
      while (v790 != v789);
      v791  = v902;
    }
    v903  = v789;
    if (v905 > v791 || &v906 <= (unsigned char **)v791) {
      operator delete(v791);
    }
  }
  return v129;
}

void anonymous namespace'::AppendData(_anonymous_namespace_ *this, CFDataRef theData, const __CFData *a3)
{
  BytePtr  = CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(theData);

  CFDataAppendBytes(this, BytePtr, Length);
}

void anonymous namespace'::MorxTableBuilder::CreateTableData(_anonymous_namespace_::MorxChainBuilder **this@<X0>, unint64_t a2@<X1>, void *i@<X8>)
{
  uint64_t v7 = *this;
  uint64_t v6 = this[1];
  unint64_t v8 = 8;
  if (*this == v6) {
    goto LABEL_4;
  }
  do
  {
    uint64_t v7 = (_anonymous_namespace_::MorxChainBuilder *)((char *)v7 + 944);
  }
  while (v7 != v6);
  if (v8 < 0xFFFFFFFF)
  {
LABEL_4:
    CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    id Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v8);
    CFArrayRef explicit = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
    *(_DWORD *)bytes  = 768;
    CFDataAppendBytes(explicit, bytes, 4);
    unint64_t v11 = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
    *(_DWORD *)bytes  = bswap32(-1601513229 * ((unint64_t)(this[1] - *this) >> 4));
    CFDataAppendBytes(v11, bytes, 4);
    BOOL v12 = *this;
    int v46 = this[1];
    if (*this != v46)
    {
      uint64_t v13 = 1;
      while (2)
      {
        *(void *)bytes  = CFDataCreateMutable(v9, v14);
        int v15 = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)bytes, memory_order_acquire);
        *(_DWORD *)CFIndex v49 = bswap32(*(_DWORD *)v12);
        CFDataAppendBytes(v15, v49, 4);
        int v16 = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)bytes, memory_order_acquire);
        *(_DWORD *)CFIndex v49 = bswap32(v14);
        CFDataAppendBytes(v16, v49, 4);
        int v17 = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)bytes, memory_order_acquire);
        uint64_t v18 = v13;
        *(_DWORD *)CFIndex v49 = bswap32(v13 - 1431655765 * ((*((void *)v12 + 2) - *((void *)v12 + 1)) >> 2));
        CFDataAppendBytes(v17, v49, 4);
        int v19 = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)bytes, memory_order_acquire);
        *(_DWORD *)CFIndex v49 = bswap32((*((void *)v12 + 51) - *((void *)v12 + 50)) >> 3);
        CFDataAppendBytes(v19, v49, 4);
        int v21 = (unsigned __int16 *)*((void *)v12 + 1);
        unint64_t v20 = (unsigned __int16 *)*((void *)v12 + 2);
        while (v21 != v20)
        {
          BOOL v22 = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)bytes, memory_order_acquire);
          *(_WORD *)CFIndex v49 = bswap32(*v21) >> 16;
          CFDataAppendBytes(v22, v49, 2);
          long long v23 = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)bytes, memory_order_acquire);
          *(_WORD *)CFIndex v49 = bswap32(v21[1]) >> 16;
          CFDataAppendBytes(v23, v49, 2);
          uint64_t v24 = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)bytes, memory_order_acquire);
          *(_DWORD *)CFIndex v49 = bswap32(*((_DWORD *)v21 + 1));
          CFDataAppendBytes(v24, v49, 4);
          unint64_t v25 = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)bytes, memory_order_acquire);
          *(_DWORD *)CFIndex v49 = bswap32(*((_DWORD *)v21 + 2));
          CFDataAppendBytes(v25, v49, 4);
          v21 += 6;
        }
        uint64_t v26 = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)bytes, memory_order_acquire);
        *(_WORD *)CFIndex v49 = 0;
        CFDataAppendBytes(v26, v49, 2);
        unint64_t v27 = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)bytes, memory_order_acquire);
        *(_WORD *)CFIndex v49 = 256;
        CFDataAppendBytes(v27, v49, 2);
        int8x8_t v28 = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)bytes, memory_order_acquire);
        *(_DWORD *)CFIndex v49 = 0;
        CFDataAppendBytes(v28, v49, 4);
        uint8x8_t v29 = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)bytes, memory_order_acquire);
        *(_DWORD *)CFIndex v49 = 0;
        CFDataAppendBytes(v29, v49, 4);
        BOOL v31 = (atomic_ullong *)*((void *)v12 + 50);
        char v32 = (atomic_ullong *)*((void *)v12 + 51);
        while (v31 != v32)
        {
          if (!atomic_load_explicit(v31, memory_order_acquire))
          {

LABEL_25:
            *unint64_t i = 0;

            goto LABEL_26;
          }
        }
        unint64_t v33 = (atomic_ullong *)*((void *)v12 + 84);
        if (v33 != *((atomic_ullong **)v12 + 85))
        {
          int Length = CFDataGetLength((CFDataRef)atomic_load_explicit(v33, memory_order_acquire));
          uint64_t v35 = *((void *)v12 + 85) - *((void *)v12 + 84);
          if (v35)
          {
            int v36 = Length;
            uint64_t v37 = i;
            unint64_t v38 = (unint64_t)v35 >> 1;
            uint64_t v39 = v35 >> 3;
            do
            {
              --v39;
              CFIndex v40 = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)bytes, memory_order_acquire);
              *(_DWORD *)CFIndex v49 = bswap32(v38);
              CFDataAppendBytes(v40, v49, 4);
              LODWORD(v38)  = v38 + v36;
            }
            while (v39);
            CFIndex v42 = (atomic_ullong *)*((void *)v12 + 84);
            unint64_t v43 = (atomic_ullong *)*((void *)v12 + 85);
            for (unint64_t i = v37; v42 != v43; ++v42)
          }
        }
        if (HIDWORD(v14)) {
          CFDataIncreaseLength((CFMutableDataRef)atomic_load_explicit((atomic_ullong *volatile)bytes, memory_order_acquire), HIDWORD(v14));
        }
        CFDataRef v44 = (const __CFData *)atomic_exchange((atomic_ullong *volatile)bytes, 0);

        if (!v44) {
          goto LABEL_25;
        }
        uint64_t v13 = v18;

        BOOL v12 = (_anonymous_namespace_::MorxChainBuilder *)((char *)v12 + 944);
        if (v12 != v46) {
          continue;
        }
        break;
      }
    }
    *unint64_t i = atomic_exchange((atomic_ullong *volatile)&Mutable, 0);
LABEL_26:
  }
  else
  {
    *unint64_t i = 0;
  }
}

uint64_t anonymous namespace'::MorxTableBuilder::FromArabicPresentationForms(_anonymous_namespace_::MorxTableBuilder *this, const TBaseFont *a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](this, a2);
  unint64_t v4 = v3;
  uint64_t v119 = (uint64_t *)v2;
  v157[2]  = *MEMORY[0x1E4F143B8];
  TBaseFont::GetGlyphCount(v3);
  memset(__b, 170, sizeof(__b));
  *(void *)&__b[664]  = &__b[424];
  memset(&__b[672], 0, 24);
  uint64_t v130 = &__b[696];
  *(_DWORD *)__b  = 1;
  *(void *)&v156[32]  = &__b[32];
  memset(&__b[400], 0, 24);
  *(void *)&__b[392]  = &__b[44];
  *(_DWORD *)&__b[32]  = 1000;
  *(void *)&__b[36]  = 0xFFFFFFFF00000001;
  *(void *)&__b[8]  = &__b[32];
  *(void *)&__b[16]  = &__b[44];
  *(void *)&__b[24]  = &__b[44];
  memset(v156, 0, 32);
  std::__split_buffer<MortFeatureEntry,TInlineBufferAllocator<MortFeatureEntry,30ul> &>::~__split_buffer((uint64_t)v156);
  *(void *)&__b[16]  = &__b[44];
  *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v127[44]  = v5;
  *(_OWORD *)&v127[46]  = v5;
  *(_OWORD *)&v127[40]  = v5;
  *(_OWORD *)&v127[42]  = v5;
  *(_OWORD *)&v127[36]  = v5;
  *(_OWORD *)&v127[38]  = v5;
  *(_OWORD *)&v127[32]  = v5;
  *(_OWORD *)&v127[34]  = v5;
  *(_OWORD *)&v127[30]  = v5;
  *(_OWORD *)&v127[28]  = v5;
  *(_OWORD *)&v127[26]  = v5;
  *(_OWORD *)&v127[24]  = v5;
  *(_OWORD *)&v127[22]  = v5;
  *(_OWORD *)&v127[20]  = v5;
  v127[19]  = (id)0xAAAAAAAAAAAAAAAALL;
  v127[14]  = (id)0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v127[12]  = v5;
  *(_OWORD *)&v127[10]  = v5;
  v127[7]  = (id)0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v127[8]  = v5;
  v127[2]  = (id)0xAAAAAAAAAAAAAAAALL;
  v127[0]  = (id)0xAAAAAAAAAAAAAAAALL;
  v127[1]  = 0;
  memset(&v127[3], 0, 32);
  v127[15]  = &v127[7];
  memset(&v127[16], 0, 24);
  v127[48]  = (id)0xAAAAAAAAAAAAAAAALL;
  v127[49]  = &v127[19];
  atomic_ullong v126 = (atomic_ullong)&unk_1ED05F900;
  v127[50]  = 0;
  GlyphCFIndex Count = TBaseFont::GetGlyphCount(v4);
  memset(&v156[24], 170, 0x5A0uLL);
  memset(v156, 0, 24);
  v157[0]  = &v156[24];
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  v154[3]  = v7;
  v154[2]  = v7;
  v154[1]  = v7;
  v154[0]  = v7;
  memset(v153, 0, sizeof(v153));
  BOOL v155 = v154;
  uint64_t v9 = __p;
  if ((void)__p)
  {
    uint64_t v10 = *((void *)&__p + 1);
    unint64_t v11 = (unsigned char *)__p;
    if (*((void *)&__p + 1) != (void)__p)
    {
      do
      {
        v10 -= 48;
        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100](v10);
      }
      while (v10 != v9);
      unint64_t v11 = (unsigned char *)__p;
    }
    *((void *)&__p + 1)  = v9;
    if (&v150[8] <= v11 && &v152 > (unsigned char **)v11)
    {
      if (*(unsigned char **)v150 == v152) {
        long long v152 = v11;
      }
    }
    else
    {
      operator delete(v11);
    }
  }
  if (v8)
  {
    MutableBytePtr  = CFDataGetMutableBytePtr((CFMutableDataRef)atomic_load_explicit((atomic_ullong *volatile)&v127[1], memory_order_acquire));
    id v120 = 0;
    *(_OWORD *)uint64_t v131 = xmmword_184BA8C40;
    *(_OWORD *)&v131[16]  = xmmword_184BA8C50;
    long long v132 = xmmword_184BA8C60;
    long long v133 = xmmword_184BA8C70;
    long long v134 = xmmword_184BA8C80;
    long long v135 = xmmword_184BA8C90;
    long long v136 = xmmword_184BA8CA0;
    long long v137 = xmmword_184BA8CB0;
    long long v138 = xmmword_184BA8CC0;
    long long v139 = xmmword_184BA8CD0;
    long long v140 = xmmword_184BA8CE0;
    *(void *)&long long v141 = 0xFBE606D0FBFE06CCLL;
    CreateLookupTableFromCharacterSwashes<std::pair<unsigned short,unsigned short> const*>((atomic_ullong *)&v125, (uint64_t)v4, GlyphCount, (int *)v131, (int *)&v141 + 2, (uint64_t)MutableBytePtr);

    id v125 = 0;
    *(_OWORD *)uint64_t v131 = xmmword_184BA8CF0;
    *(_OWORD *)&v131[16]  = xmmword_184BA8D00;
    long long v132 = xmmword_184BA8D10;
    long long v133 = xmmword_184BA8D20;
    long long v134 = xmmword_184BA8D30;
    long long v135 = xmmword_184BA8D40;
    long long v136 = xmmword_184BA8D50;
    long long v137 = xmmword_184BA8D60;
    long long v138 = xmmword_184BA8D70;
    long long v139 = xmmword_184BA8D80;
    long long v140 = xmmword_184BA8D90;
    long long v141 = xmmword_184BA8DA0;
    long long v142 = xmmword_184BA8DB0;
    long long v143 = xmmword_184BA8DC0;
    long long v144 = xmmword_184BA8DD0;
    long long v145 = xmmword_184BA8DE0;
    long long v146 = xmmword_184BA8DF0;
    long long v147 = xmmword_184BA8E00;
    v148[0]  = xmmword_184BA8E10;
    v148[1]  = xmmword_184BA8E20;
    v148[2]  = xmmword_184BA8E30;
    v148[3]  = xmmword_184BA8E40;
    v148[4]  = xmmword_184BA8E50;
    CreateLookupTableFromCharacterSwashes<std::pair<unsigned short,unsigned short> const*>((atomic_ullong *)&v124, (uint64_t)v4, GlyphCount, (int *)v131, (int *)&__p, (uint64_t)MutableBytePtr);

    id v124 = 0;
    *(_OWORD *)uint64_t v131 = xmmword_184BA8E60;
    *(_OWORD *)&v131[16]  = xmmword_184BA8E70;
    long long v132 = xmmword_184BA8E80;
    long long v133 = xmmword_184BA8E90;
    long long v134 = xmmword_184BA8EA0;
    long long v135 = xmmword_184BA8EB0;
    long long v136 = xmmword_184BA8EC0;
    long long v137 = xmmword_184BA8ED0;
    long long v138 = xmmword_184BA8EE0;
    long long v139 = xmmword_184BA8EF0;
    long long v140 = xmmword_184BA8F00;
    long long v141 = xmmword_184BA8F10;
    long long v142 = xmmword_184BA8F20;
    long long v143 = xmmword_184BA8F30;
    long long v144 = xmmword_184BA8F40;
    long long v145 = xmmword_184BA8F50;
    long long v146 = xmmword_184BA8F60;
    long long v147 = xmmword_184BA8F70;
    *(void *)&v148[0]  = 0xFBB106D3FBAF06D2;
    CreateLookupTableFromCharacterSwashes<std::pair<unsigned short,unsigned short> const*>((atomic_ullong *)&v123, (uint64_t)v4, GlyphCount, (int *)v131, (int *)v148 + 2, (uint64_t)MutableBytePtr);

    *(void *)uint64_t v131 = 0;
    unint64_t v14 = NewLKTHandle(GlyphCount, 0);
    LKTCreateLookupTable(v14, (atomic_ullong *)&v123);

    DisposeLKTHandle(v14);
  }
  *(void *)uint64_t v131 = v153;
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v131);
  uint64_t v15 = *(void *)v156;
  if (*(void *)v156)
  {
    uint64_t v16 = *(void *)&v156[8];
    int v17 = *(unsigned char **)v156;
    if (*(void *)&v156[8] != *(void *)v156)
    {
      do
      {
        v16 -= 48;
        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100](v16);
      }
      while (v16 != v15);
      int v17 = *(unsigned char **)v156;
    }
    *(void *)&v156[8]  = v15;
    if (&v156[24] > v17 || v157 <= (void *)v17) {
      operator delete(v17);
    }
  }
  if (!v8)
  {
    atomic_ullong v126 = (atomic_ullong)&unk_1ED05F900;

LABEL_27:
    uint64_t v21 = 0;
    goto LABEL_192;
  }
  int v19 = *(void **)&__b[408];
  if (*(void *)&__b[408] >= *(void *)&__b[416])
  {
    uint64_t v22 = (uint64_t)(*(void *)&__b[408] - *(void *)&__b[400]) >> 3;
    if ((unint64_t)(v22 + 1) >> 61) {
      goto LABEL_197;
    }
    unint64_t v23 = (uint64_t)(*(void *)&__b[416] - *(void *)&__b[400]) >> 2;
    if (v23 <= v22 + 1) {
      unint64_t v23 = v22 + 1;
    }
    if (*(void *)&__b[416] - *(void *)&__b[400] >= 0x7FFFFFFFFFFFFFF8uLL) {
      unint64_t v24 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v24 = v23;
    }
    *(void *)&v156[32]  = &__b[424];
    if (v24) {
      unint64_t v25 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&__b[424], v24);
    }
    else {
      unint64_t v25 = 0;
    }
    *(void *)uint64_t v156 = v25;
    *(void *)&v156[8]  = &v25[8 * v22];
    *(void *)&v156[16]  = *(void *)&v156[8];
    *(void *)&v156[24]  = &v25[8 * v24];
    **(void **)&v156[8]  = atomic_exchange((atomic_ullong *volatile)&__p, 0);
    uint64_t v26 = *(void *)&v156[8];
    uint64_t v20 = *(void *)&v156[16] + 8;
    *(void *)&v156[16] += 8;
    unint64_t v27 = *(atomic_ullong **)&__b[408];
    int8x8_t v28 = *(atomic_ullong **)&__b[400];
    if (*(void *)&__b[408] == *(void *)&__b[400])
    {
      int64x2_t v29 = vdupq_n_s64(*(unint64_t *)&__b[408]);
    }
    else
    {
      do
      {
        *(void *)(v26 - 8)  = atomic_exchange(--v27, 0);
        v26 -= 8;
      }
      while (v27 != v28);
      int64x2_t v29 = *(int64x2_t *)&__b[400];
      uint64_t v20 = *(void *)&v156[16];
    }
    *(void *)&__b[400]  = v26;
    *(void *)&__b[408]  = v20;
    *(int64x2_t *)&v156[8]  = v29;
    uint64_t v30 = *(void *)&__b[416];
    *(void *)&__b[416]  = *(void *)&v156[24];
    *(void *)&v156[24]  = v30;
    *(void *)uint64_t v156 = v29.i64[0];
    std::__split_buffer<TCFRef<__CFData *>,TInlineBufferAllocator<TCFRef<__CFData *>,30ul> &>::~__split_buffer((uint64_t)v156);
  }
  else
  {
    void *v19 = atomic_exchange((atomic_ullong *volatile)&__p, 0);
    uint64_t v20 = (uint64_t)(v19 + 1);
  }
  *(void *)&__b[408]  = v20;

  *(void *)&long long __p = (id)atomic_load_explicit((atomic_ullong *volatile)&v127[1], memory_order_acquire);
  BOOL v31 = *(void **)&__b[680];
  if (*(void *)&__b[680] >= *(void *)&__b[688])
  {
    uint64_t v33 = (uint64_t)(*(void *)&__b[680] - *(void *)&__b[672]) >> 3;
    if ((unint64_t)(v33 + 1) >> 61) {
      goto LABEL_197;
    }
    unint64_t v34 = (uint64_t)(*(void *)&__b[688] - *(void *)&__b[672]) >> 2;
    if (v34 <= v33 + 1) {
      unint64_t v34 = v33 + 1;
    }
    if (*(void *)&__b[688] - *(void *)&__b[672] >= 0x7FFFFFFFFFFFFFF8uLL) {
      unint64_t v35 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v35 = v34;
    }
    *(void *)&v156[32]  = &__b[696];
    if (v35) {
      int v36 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&__b[696], v35);
    }
    else {
      int v36 = 0;
    }
    *(void *)uint64_t v156 = v36;
    *(void *)&v156[8]  = &v36[8 * v33];
    *(void *)&v156[16]  = *(void *)&v156[8];
    *(void *)&v156[24]  = &v36[8 * v35];
    **(void **)&v156[8]  = atomic_exchange((atomic_ullong *volatile)&__p, 0);
    uint64_t v37 = *(void *)&v156[8];
    uint64_t v32 = *(void *)&v156[16] + 8;
    *(void *)&v156[16] += 8;
    unint64_t v38 = *(atomic_ullong **)&__b[680];
    uint64_t v39 = *(atomic_ullong **)&__b[672];
    if (*(void *)&__b[680] == *(void *)&__b[672])
    {
      int64x2_t v40 = vdupq_n_s64(*(unint64_t *)&__b[680]);
    }
    else
    {
      do
      {
        *(void *)(v37 - 8)  = atomic_exchange(--v38, 0);
        v37 -= 8;
      }
      while (v38 != v39);
      int64x2_t v40 = *(int64x2_t *)&__b[672];
      uint64_t v32 = *(void *)&v156[16];
    }
    *(void *)&__b[672]  = v37;
    *(void *)&__b[680]  = v32;
    *(int64x2_t *)&v156[8]  = v40;
    uint64_t v41 = *(void *)&__b[688];
    *(void *)&__b[688]  = *(void *)&v156[24];
    *(void *)&v156[24]  = v41;
    *(void *)uint64_t v156 = v40.i64[0];
    std::__split_buffer<TCFRef<__CFData *>,TInlineBufferAllocator<TCFRef<__CFData *>,30ul> &>::~__split_buffer((uint64_t)v156);
  }
  else
  {
    *BOOL v31 = atomic_exchange((atomic_ullong *volatile)&__p, 0);
    uint64_t v32 = (uint64_t)(v31 + 1);
  }
  *(void *)&__b[680]  = v32;

  atomic_ullong v126 = (atomic_ullong)&unk_1ED05F900;
  memset(&v156[24], 170, 0x5A0uLL);
  memset(v156, 0, 24);
  v157[0]  = &v156[24];
  LODWORD(__p)  = -24183157;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64490, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -24183156;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64491, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = 114687627;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64492, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = 114687628;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64493, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17891701;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64494, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17891700;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64495, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -69665141;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64496, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -69665140;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64497, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -69534069;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64498, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -69534068;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64499, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -69402997;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64500, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -69402996;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64501, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -68813173;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64502, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -68813172;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64503, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -68682101;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64504, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760629;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64505, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760628;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64506, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -68551029;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64507, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -23134581;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64512, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22872437;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64513, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18678133;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64514, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760629;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64515, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17629557;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64516, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -23134575;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64517, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22872431;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64518, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22610287;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64519, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18678127;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64520, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760623;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64521, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17629551;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64522, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -23134569;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64523, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22872425;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64524, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22610281;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64525, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18678121;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64526, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760617;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64527, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17629545;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64528, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -23134565;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64529, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18678117;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64530, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760613;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64531, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17629541;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64532, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22872417;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64533, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18678113;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64534, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -23134557;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64535, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18678109;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64536, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -23134553;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64537, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22872409;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64538, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18678105;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64539, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -23134541;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64540, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22872397;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64541, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22610253;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64542, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18678093;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64543, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22872389;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64544, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18678085;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64545, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -23134529;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64546, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22872385;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64547, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22610241;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64548, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18678081;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64549, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22872381;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64550, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18678077;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64551, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18678073;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64552, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -23134517;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64553, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18678069;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64554, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -23134513;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64555, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18678065;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64556, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -23134509;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64557, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22872365;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64558, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22610221;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64559, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18678061;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64560, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760557;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64561, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17629485;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64562, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22872361;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64563, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18678057;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64564, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760553;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64565, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17629481;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64566, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -24183077;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64567, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -23134501;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64568, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22872357;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64569, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22610213;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64570, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18940197;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64571, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18678053;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64572, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760549;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64573, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17629477;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64574, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -23134497;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64575, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22872353;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64576, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22610209;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64577, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18678049;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64578, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760545;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64579, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17629473;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64580, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -23134493;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64581, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22872349;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64582, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22610205;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64583, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18678045;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64584, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760541;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64585, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17629469;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64586, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -23134489;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64587, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22872345;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64588, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22610201;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64589, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18678041;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64590, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760537;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64591, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17629465;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64592, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -23134485;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64593, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18678037;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64594, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760533;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64595, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17629461;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64596, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -23134477;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64597, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22872333;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64598, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22610189;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64599, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18678029;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64600, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760525;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64601, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17629453;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64602, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22086004;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64612, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -21954932;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64613, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18678132;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64614, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18415988;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64615, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760628;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64616, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17629556;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64617, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22085998;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64618, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -21954926;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64619, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18678126;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64620, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18415982;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64621, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760622;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64622, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17629550;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64623, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22085992;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64624, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -21954920;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64625, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18678120;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64626, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18415976;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64627, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760616;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64628, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17629544;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64629, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22085988;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64630, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -21954916;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64631, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18678116;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64632, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18415972;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64633, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760612;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64634, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17629540;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64635, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760556;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64636, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17629484;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64637, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760552;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64638, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17629480;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64639, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -24183076;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64640, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18940196;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64641, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18678052;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64642, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760548;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64643, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17629476;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64644, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18678048;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64645, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760544;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64646, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17629472;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64647, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -24183068;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64648, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18678044;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64649, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22085912;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64650, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -21954840;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64651, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18678040;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64652, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18415896;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64653, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760536;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64654, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17629464;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64655, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22085900;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64657, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -21954828;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64658, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18678028;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64659, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18415884;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64660, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760524;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64661, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17629452;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64662, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -23003509;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64663, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22741365;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64664, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22479221;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64665, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18547061;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64666, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18022773;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64667, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -23003503;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64668, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22741359;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64669, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22479215;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64670, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18547055;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64671, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18022767;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64672, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -23003497;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64673, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22741353;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64674, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22479209;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64675, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18547049;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64676, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18022761;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64677, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18547045;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64678, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22741345;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64679, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18547041;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64680, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -23003485;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64681, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18547037;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64682, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -23003481;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64683, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18547033;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64684, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -23003469;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64685, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22741325;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64686, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22479181;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64687, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18547021;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64688, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22741317;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64689, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22479173;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64690, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18547013;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64691, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -23003457;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64692, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22741313;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64693, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22479169;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64694, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18547009;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64695, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22741309;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64696, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18547001;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64697, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -23003445;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64698, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18546997;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64699, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -23003441;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64700, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18546993;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64701, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -23003437;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64702, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22741293;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64703, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22479149;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64704, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18546989;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64705, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22741289;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64706, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18546985;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64707, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -23003429;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64708, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22741285;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64709, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22479141;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64710, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18809125;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64711, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18546981;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64712, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -23003425;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64713, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22741281;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64714, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22479137;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64715, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18546977;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64716, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18022689;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64717, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -23003421;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64718, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22741277;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64719, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22479133;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64720, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18546973;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64721, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -23003417;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64722, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22741273;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64723, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22479129;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64724, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18546969;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64725, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18022681;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64726, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -23003413;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64727, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18546965;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64728, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -23003405;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64730, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22741261;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64731, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22479117;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64732, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18546957;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64733, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18022669;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64734, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18547060;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64735, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18022772;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64736, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18547054;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64737, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18022766;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64738, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18547048;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64739, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18022760;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64740, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18547044;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64741, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18022756;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64742, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18547020;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64743, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18022732;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64744, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18547016;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64745, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18022728;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64746, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18809124;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64747, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18546980;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64748, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18546976;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64749, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18546968;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64750, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18022680;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64751, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18546956;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64752, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18022668;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64753, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760573;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64757, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17629501;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64758, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760565;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64759, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17629493;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64760, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760561;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64761, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17629489;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64762, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760589;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64763, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17629517;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64764, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760585;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64765, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17629513;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64766, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760605;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64767, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17629533;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64768, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760609;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64769, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17629537;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64770, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760601;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64771, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17629529;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64772, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760581;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64773, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17629509;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64774, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760577;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64775, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17629505;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64776, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -23134537;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64777, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22872393;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64778, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22610249;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64779, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18678089;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64780, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22085961;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64781, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22085965;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64782, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22085957;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64783, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22085953;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64784, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760572;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64785, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17629500;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64786, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760564;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64787, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17629492;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64788, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760560;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64789, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17629488;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64790, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760588;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64791, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17629516;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64792, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760584;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64793, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17629512;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64794, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760604;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64795, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17629532;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64796, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760608;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64797, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17629536;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64798, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760600;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64799, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17629528;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64800, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760580;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64801, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17629508;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64802, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17760576;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64803, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -17629504;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64804, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -23134536;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64805, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22872392;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64806, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22610248;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64807, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18678088;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64808, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22085960;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64809, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22085964;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64810, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22085956;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64811, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22085952;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64812, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -23003465;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64813, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22741321;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64814, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22479177;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64815, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18547017;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64816, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18022733;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64817, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18022729;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64818, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18547005;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64819, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -23003468;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64820, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22741324;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64821, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22479180;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64822, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -23003464;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64823, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22741320;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64824, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -22479176;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64825, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18547004;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64826, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -18547000;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64827, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -23003497;
  WORD2(__p)  = -284;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64848, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -22741352;
  WORD2(__p)  = -354;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64849, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -22741353;
  WORD2(__p)  = -352;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64850, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -22741353;
  WORD2(__p)  = -284;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64851, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -22479209;
  WORD2(__p)  = -284;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64852, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18547049;
  WORD2(__p)  = -352;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64853, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18547049;
  WORD2(__p)  = -348;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64854, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18547049;
  WORD2(__p)  = -344;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64855, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18547040;
  WORD2(__p)  = -350;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64856, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18547041;
  WORD2(__p)  = -348;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64857, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18547036;
  WORD2(__p)  = -270;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64858, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18547036;
  WORD2(__p)  = -272;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64859, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -22741325;
  WORD2(__p)  = -352;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64860, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -23003469;
  WORD2(__p)  = -348;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64861, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -23003468;
  WORD2(__p)  = -272;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64862, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18547020;
  WORD2(__p)  = -350;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64863, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18547021;
  WORD2(__p)  = -348;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64864, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18547021;
  WORD2(__p)  = -352;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64865, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18547020;
  WORD2(__p)  = -286;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64866, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18547021;
  WORD2(__p)  = -284;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64867, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -22741316;
  WORD2(__p)  = -350;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64868, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -22741317;
  WORD2(__p)  = -348;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64869, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18547012;
  WORD2(__p)  = -286;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64870, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -22741320;
  WORD2(__p)  = -286;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64871, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -22741321;
  WORD2(__p)  = -284;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64872, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -23003464;
  WORD2(__p)  = -270;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64873, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18547016;
  WORD2(__p)  = -346;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64874, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18547017;
  WORD2(__p)  = -344;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64875, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18547016;
  WORD2(__p)  = -286;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64876, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18547017;
  WORD2(__p)  = -284;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64877, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -22741312;
  WORD2(__p)  = -272;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64878, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -22479168;
  WORD2(__p)  = -286;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64879, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -22479169;
  WORD2(__p)  = -284;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64880, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18547004;
  WORD2(__p)  = -350;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64881, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18547005;
  WORD2(__p)  = -348;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64882, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18547005;
  WORD2(__p)  = -284;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64883, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18547004;
  WORD2(__p)  = -270;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64884, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -23003444;
  WORD2(__p)  = -286;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64885, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18546996;
  WORD2(__p)  = -286;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64886, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18546997;
  WORD2(__p)  = -284;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64887, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18546996;
  WORD2(__p)  = -272;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64888, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18546992;
  WORD2(__p)  = -286;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64889, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18546992;
  WORD2(__p)  = -270;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64890, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18546992;
  WORD2(__p)  = -272;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64891, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -22479148;
  WORD2(__p)  = -286;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64892, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -22479149;
  WORD2(__p)  = -284;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64893, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18546984;
  WORD2(__p)  = -350;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64894, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18546984;
  WORD2(__p)  = -286;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64895, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -22741280;
  WORD2(__p)  = -286;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64896, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -22741280;
  WORD2(__p)  = -270;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64897, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -22741280;
  WORD2(__p)  = -272;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64898, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -23003425;
  WORD2(__p)  = -352;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64899, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -23003424;
  WORD2(__p)  = -354;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64900, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -22479136;
  WORD2(__p)  = -286;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64901, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -22479137;
  WORD2(__p)  = -284;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64902, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18546976;
  WORD2(__p)  = -350;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64903, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18546977;
  WORD2(__p)  = -348;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64904, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -22741277;
  WORD2(__p)  = -352;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64905, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -22741277;
  WORD2(__p)  = -284;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64906, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -22741276;
  WORD2(__p)  = -270;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64907, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -23003421;
  WORD2(__p)  = -348;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64908, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -23003421;
  WORD2(__p)  = -284;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64909, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -22479133;
  WORD2(__p)  = -352;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64910, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -22479133;
  WORD2(__p)  = -284;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64911, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -23003421;
  WORD2(__p)  = -344;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64914, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18546965;
  WORD2(__p)  = -352;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64915, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18546965;
  WORD2(__p)  = -284;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64916, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -22741273;
  WORD2(__p)  = -284;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64917, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -22741272;
  WORD2(__p)  = -272;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64918, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -23003416;
  WORD2(__p)  = -286;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64919, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -23003417;
  WORD2(__p)  = -284;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64920, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -23003416;
  WORD2(__p)  = -272;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64921, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18546968;
  WORD2(__p)  = -270;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64922, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18546968;
  WORD2(__p)  = -272;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64923, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18546956;
  WORD2(__p)  = -286;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64924, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18546957;
  WORD2(__p)  = -284;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64925, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -22479214;
  WORD2(__p)  = -270;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64926, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -23003496;
  WORD2(__p)  = -270;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64927, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -23003496;
  WORD2(__p)  = -272;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64928, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -22479208;
  WORD2(__p)  = -270;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64929, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -22479208;
  WORD2(__p)  = -272;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64930, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18547048;
  WORD2(__p)  = -270;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64931, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18547048;
  WORD2(__p)  = -272;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64932, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18547040;
  WORD2(__p)  = -270;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64933, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -22741344;
  WORD2(__p)  = -272;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64934, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18547040;
  WORD2(__p)  = -272;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64935, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -22479180;
  WORD2(__p)  = -272;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64936, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -22741316;
  WORD2(__p)  = -270;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64937, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -22741320;
  WORD2(__p)  = -270;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64938, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -22741312;
  WORD2(__p)  = -270;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64939, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -23003424;
  WORD2(__p)  = -270;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64940, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18546976;
  WORD2(__p)  = -270;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64941, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -22741260;
  WORD2(__p)  = -270;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64942, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -23003404;
  WORD2(__p)  = -270;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64943, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18546956;
  WORD2(__p)  = -270;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64944, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18546972;
  WORD2(__p)  = -270;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64945, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18546984;
  WORD2(__p)  = -270;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64946, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -22741272;
  WORD2(__p)  = -270;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64947, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18546985;
  WORD2(__p)  = -348;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64948, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -22741281;
  WORD2(__p)  = -284;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64949, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18546996;
  WORD2(__p)  = -270;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64950, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18546980;
  WORD2(__p)  = -270;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64951, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -23003417;
  WORD2(__p)  = -348;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64952, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -22479132;
  WORD2(__p)  = -270;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64953, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -23003425;
  WORD2(__p)  = -284;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64954, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18546980;
  WORD2(__p)  = -286;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64955, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -23003424;
  WORD2(__p)  = -286;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64956, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -23003416;
  WORD2(__p)  = -350;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64957, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -22741344;
  WORD2(__p)  = -270;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64958, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -23003484;
  WORD2(__p)  = -270;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64959, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -23003420;
  WORD2(__p)  = -270;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64960, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18546988;
  WORD2(__p)  = -270;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64961, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -22741358;
  WORD2(__p)  = -270;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64962, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18546981;
  WORD2(__p)  = -284;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64963, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -23003445;
  WORD2(__p)  = -284;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64964, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18547013;
  WORD2(__p)  = -284;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64965, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -22479180;
  WORD2(__p)  = -270;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64966, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -23003416;
  WORD2(__p)  = -270;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64967, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18809157;
  WORD2(__p)  = -1105;
  AddLigInputForCharacters((uint64_t *)v156, v4, 65008, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = -18809129;
  WORD2(__p)  = -1105;
  AddLigInputForCharacters((uint64_t *)v156, v4, 65009, (__int16 *)&__p, 3uLL);
  *(void *)&long long __p = 0xFEEAFEE0FEDF0627;
  AddLigInputForCharacters((uint64_t *)v156, v4, 65010, (__int16 *)&__p, 4uLL);
  *(void *)&long long __p = 0xFEAEFE92FEDB0627;
  AddLigInputForCharacters((uint64_t *)v156, v4, 65011, (__int16 *)&__p, 4uLL);
  *(void *)&long long __p = 0xFEAAFEE4FEA4FEE3;
  AddLigInputForCharacters((uint64_t *)v156, v4, 65012, (__int16 *)&__p, 4uLL);
  *(void *)&long long __p = 0xFEE2FECCFEE0FEBBLL;
  AddLigInputForCharacters((uint64_t *)v156, v4, 65013, (__int16 *)&__p, 4uLL);
  *(void *)&long long __p = 0x644FEEEFEB30631;
  AddLigInputForCharacters((uint64_t *)v156, v4, 65014, (__int16 *)&__p, 4uLL);
  *(void *)&long long __p = 0xFEEAFEF4FEE0FECBLL;
  AddLigInputForCharacters((uint64_t *)v156, v4, 65015, (__int16 *)&__p, 4uLL);
  *(void *)&long long __p = 0xFEE2FEE0FEB30648;
  AddLigInputForCharacters((uint64_t *)v156, v4, 65016, (__int16 *)&__p, 4uLL);
  LODWORD(__p)  = -18809157;
  WORD2(__p)  = -272;
  AddLigInputForCharacters((uint64_t *)v156, v4, 65017, (__int16 *)&__p, 3uLL);
  long long __p = xmmword_184BA9234;
  *(_OWORD *)long long v150 = unk_184BA9244;
  *(_DWORD *)&v150[16]  = -18678048;
  AddLigInputForCharacters((uint64_t *)v156, v4, 65018, (__int16 *)&__p, 0x12uLL);
  long long __p = xmmword_184BA8F80;
  AddLigInputForCharacters((uint64_t *)v156, v4, 65019, (__int16 *)&__p, 8uLL);
  LODWORD(__p)  = -24969505;
  AddLigInputForCharacters((uint64_t *)v156, v4, 65269, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -24969504;
  AddLigInputForCharacters((uint64_t *)v156, v4, 65270, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -24838433;
  AddLigInputForCharacters((uint64_t *)v156, v4, 65271, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -24838432;
  AddLigInputForCharacters((uint64_t *)v156, v4, 65272, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -24576289;
  AddLigInputForCharacters((uint64_t *)v156, v4, 65273, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -24576288;
  AddLigInputForCharacters((uint64_t *)v156, v4, 65274, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -24183073;
  AddLigInputForCharacters((uint64_t *)v156, v4, 65275, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = -24183072;
  AddLigInputForCharacters((uint64_t *)v156, v4, 65276, (__int16 *)&__p, 2uLL);
  *(_OWORD *)uint64_t v153 = xmmword_184BA9258;
  v153[2]  = (void *)0x670065506540653;
  CFIndex v42 = (char *)operator new(0x18uLL);
  unint64_t v43 = v42 + 24;
  uint64_t v121 = v42 + 24;
  unint64_t v122 = v42 + 24;
  *(void *)CFIndex v42 = 0;
  *((void *)v42 + 1)  = 0;
  *((void *)v42 + 2)  = 0;
  id v120 = v42;
  (*(void (**)(TBaseFont *, void **, char *, uint64_t))(*(void *)v4 + 664))(v4, v153, v42, 12);
  uint64_t v44 = 0;
  while (*(_WORD *)&v42[v44])
  {
    v44 += 2;
    if (v44 == 24) {
      goto LABEL_63;
    }
  }
  unint64_t v43 = &v42[v44];
LABEL_63:
  if (v43 - v42 != 24)
  {
    uint64_t v45 = (v43 - v42) >> 1;
    if (v45 == 11)
    {
      uint64_t v46 = 11;
LABEL_71:
      CFIndex v49 = &v42[2 * v45];
      uint64_t v50 = v46 + ((24 - 2 * v46) >> 1);
      uint64_t v51 = 24 - 2 * v50;
      if (v50 != 12) {
        memmove(v49, &v42[2 * v50], 24 - 2 * v50);
      }
      uint64_t v121 = &v49[v51];
      goto LABEL_74;
    }
    uint64_t v47 = v42 + 2;
    uint64_t v48 = (v43 - v42) >> 1;
    do
    {
      if (*(_WORD *)&v47[2 * v48]) {
        *(_WORD *)&v42[2 * v45++]  = *(_WORD *)&v47[2 * v48];
      }
      ++v48;
    }
    while (v48 != 11);
    uint64_t v46 = v45;
    if (v45 != 12) {
      goto LABEL_71;
    }
  }
LABEL_74:
  memset(v127, 170, sizeof(v127));
  v127[1]  = 0;
  memset(&v127[3], 0, 32);
  v127[15]  = &v127[7];
  memset(&v127[16], 0, 24);
  v127[42]  = &v127[19];
  memset(&v127[43], 0, 24);
  atomic_ullong v126 = (atomic_ullong)&unk_1ED05F8B0;
  v127[61]  = &v127[46];
  memset(&v127[62], 0, 24);
  v127[73]  = &v127[65];
  memset(&v127[74], 0, 24);
  unsigned int v128 = &v127[77];
  memset(&v150[8], 170, 0x2D0uLL);
  long long __p = 0uLL;
  *(void *)long long v150 = 0;
  long long v151 = &v150[8];
  {
    *(void *)uint64_t v131 = &__p;
    std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v131);
    atomic_ullong v126 = (atomic_ullong)&unk_1ED05F8B0;
    *(void *)&long long __p = &v127[74];
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&__p);
    *(void *)&long long __p = &v127[62];
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&__p);
    *(void *)&long long __p = &v127[43];
    std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&__p);
    atomic_ullong v126 = (atomic_ullong)&unk_1ED05F928;
    std::vector<STXEntryOne,TInlineBufferAllocator<STXEntryOne,30ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v127[16]);
    *(void *)&long long __p = &v127[4];
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&__p);

    operator delete(v42);
    uint64_t v54 = *(void *)v156;
    if (*(void *)v156)
    {
      uint64_t v55 = *(void *)&v156[8];
      id v56 = *(unsigned char **)v156;
      if (*(void *)&v156[8] != *(void *)v156)
      {
        do
        {
          v55 -= 48;
          std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100](v55);
        }
        while (v55 != v54);
        id v56 = *(unsigned char **)v156;
      }
      *(void *)&v156[8]  = v54;
      if (&v156[24] > v56 || v157 <= (void *)v56) {
        operator delete(v56);
      }
    }
    uint64_t v21 = 0;
    goto LABEL_192;
  }
  CFStringRef v52 = *(void **)&__b[408];
  if (*(void *)&__b[408] >= *(void *)&__b[416])
  {
    uint64_t v58 = (uint64_t)(*(void *)&__b[408] - *(void *)&__b[400]) >> 3;
    if ((unint64_t)(v58 + 1) >> 61) {
      goto LABEL_197;
    }
    unint64_t v59 = (uint64_t)(*(void *)&__b[416] - *(void *)&__b[400]) >> 2;
    if (v59 <= v58 + 1) {
      unint64_t v59 = v58 + 1;
    }
    if (*(void *)&__b[416] - *(void *)&__b[400] >= 0x7FFFFFFFFFFFFFF8uLL) {
      unint64_t v60 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v60 = v59;
    }
    *(void *)&long long v132 = &__b[424];
    if (v60) {
      uint64_t v61 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&__b[424], v60);
    }
    else {
      uint64_t v61 = 0;
    }
    *(void *)uint64_t v131 = v61;
    *(void *)&v131[8]  = &v61[8 * v58];
    *(void *)&v131[16]  = *(void *)&v131[8];
    *(void *)&v131[24]  = &v61[8 * v60];
    **(void **)&v131[8]  = atomic_exchange((atomic_ullong *volatile)&v125, 0);
    uint64_t v62 = *(void *)&v131[8];
    uint64_t v53 = *(void *)&v131[16] + 8;
    *(void *)&v131[16] += 8;
    char v63 = *(atomic_ullong **)&__b[408];
    unint64_t v64 = *(atomic_ullong **)&__b[400];
    if (*(void *)&__b[408] == *(void *)&__b[400])
    {
      int64x2_t v65 = vdupq_n_s64(*(unint64_t *)&__b[408]);
    }
    else
    {
      do
      {
        *(void *)(v62 - 8)  = atomic_exchange(--v63, 0);
        v62 -= 8;
      }
      while (v63 != v64);
      int64x2_t v65 = *(int64x2_t *)&__b[400];
      uint64_t v53 = *(void *)&v131[16];
    }
    *(void *)&__b[400]  = v62;
    *(void *)&__b[408]  = v53;
    *(int64x2_t *)&v131[8]  = v65;
    uint64_t v66 = *(void *)&__b[416];
    *(void *)&__b[416]  = *(void *)&v131[24];
    *(void *)&v131[24]  = v66;
    *(void *)uint64_t v131 = v65.i64[0];
    std::__split_buffer<TCFRef<__CFData *>,TInlineBufferAllocator<TCFRef<__CFData *>,30ul> &>::~__split_buffer((uint64_t)v131);
  }
  else
  {
    *CFStringRef v52 = atomic_exchange((atomic_ullong *volatile)&v125, 0);
    uint64_t v53 = (uint64_t)(v52 + 1);
  }
  *(void *)&__b[408]  = v53;

  id v125 = (id)atomic_load_explicit((atomic_ullong *volatile)&v127[1], memory_order_acquire);
  uint64_t v67 = *(void **)&__b[680];
  if (*(void *)&__b[680] >= *(void *)&__b[688])
  {
    uint64_t v69 = (uint64_t)(*(void *)&__b[680] - *(void *)&__b[672]) >> 3;
    if ((unint64_t)(v69 + 1) >> 61) {
      goto LABEL_197;
    }
    unint64_t v70 = (uint64_t)(*(void *)&__b[688] - *(void *)&__b[672]) >> 2;
    if (v70 <= v69 + 1) {
      unint64_t v70 = v69 + 1;
    }
    if (*(void *)&__b[688] - *(void *)&__b[672] >= 0x7FFFFFFFFFFFFFF8uLL) {
      unint64_t v71 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v71 = v70;
    }
    *(void *)&long long v132 = &__b[696];
    if (v71) {
      uint64_t v72 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&__b[696], v71);
    }
    else {
      uint64_t v72 = 0;
    }
    *(void *)uint64_t v131 = v72;
    *(void *)&v131[8]  = &v72[8 * v69];
    *(void *)&v131[16]  = *(void *)&v131[8];
    *(void *)&v131[24]  = &v72[8 * v71];
    **(void **)&v131[8]  = atomic_exchange((atomic_ullong *volatile)&v125, 0);
    uint64_t v73 = *(void *)&v131[8];
    uint64_t v68 = *(void *)&v131[16] + 8;
    *(void *)&v131[16] += 8;
    uint64_t v74 = *(atomic_ullong **)&__b[680];
    uint64_t v75 = *(atomic_ullong **)&__b[672];
    if (*(void *)&__b[680] == *(void *)&__b[672])
    {
      int64x2_t v76 = vdupq_n_s64(*(unint64_t *)&__b[680]);
    }
    else
    {
      do
      {
        *(void *)(v73 - 8)  = atomic_exchange(--v74, 0);
        v73 -= 8;
      }
      while (v74 != v75);
      int64x2_t v76 = *(int64x2_t *)&__b[672];
      uint64_t v68 = *(void *)&v131[16];
    }
    *(void *)&__b[672]  = v73;
    *(void *)&__b[680]  = v68;
    *(int64x2_t *)&v131[8]  = v76;
    uint64_t v77 = *(void *)&__b[688];
    *(void *)&__b[688]  = *(void *)&v131[24];
    *(void *)&v131[24]  = v77;
    *(void *)uint64_t v131 = v76.i64[0];
    std::__split_buffer<TCFRef<__CFData *>,TInlineBufferAllocator<TCFRef<__CFData *>,30ul> &>::~__split_buffer((uint64_t)v131);
  }
  else
  {
    *uint64_t v67 = atomic_exchange((atomic_ullong *volatile)&v125, 0);
    uint64_t v68 = (uint64_t)(v67 + 1);
  }
  *(void *)&__b[680]  = v68;

  *(void *)uint64_t v131 = &__p;
  std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v131);
  atomic_ullong v126 = (atomic_ullong)&unk_1ED05F8B0;
  *(void *)&long long __p = &v127[74];
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&__p);
  *(void *)&long long __p = &v127[62];
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&__p);
  *(void *)&long long __p = &v127[43];
  std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&__p);
  atomic_ullong v126 = (atomic_ullong)&unk_1ED05F928;
  std::vector<STXEntryOne,TInlineBufferAllocator<STXEntryOne,30ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v127[16]);
  *(void *)&long long __p = &v127[4];
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&__p);

  if (v120) {
    operator delete(v120);
  }
  uint64_t v78 = *(void *)v156;
  if (*(void *)v156)
  {
    uint64_t v79 = *(void *)&v156[8];
    uint64_t v80 = *(unsigned char **)v156;
    if (*(void *)&v156[8] != *(void *)v156)
    {
      do
      {
        v79 -= 48;
        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100](v79);
      }
      while (v79 != v78);
      uint64_t v80 = *(unsigned char **)v156;
    }
    *(void *)&v156[8]  = v78;
    if (&v156[24] > v80 || v157 <= (void *)v80) {
      operator delete(v80);
    }
  }
  memset(&v156[24], 170, 0x5A0uLL);
  memset(v156, 0, 24);
  v157[0]  = &v156[24];
  LODWORD(__p)  = 108004912;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64603, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = 108004913;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64604, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = 108004937;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64605, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = 105644064;
  WORD2(__p)  = 1617;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64606, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = 105971744;
  WORD2(__p)  = 1612;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64606, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = 105709600;
  WORD2(__p)  = 1617;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64607, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = 105971744;
  WORD2(__p)  = 1613;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64607, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = 105775136;
  WORD2(__p)  = 1617;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64608, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = 105971744;
  WORD2(__p)  = 1614;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64608, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = 105840672;
  WORD2(__p)  = 1617;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64609, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = 105971744;
  WORD2(__p)  = 1615;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64609, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = 105906208;
  WORD2(__p)  = 1617;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64610, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = 105971744;
  WORD2(__p)  = 1616;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64610, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = 105971744;
  WORD2(__p)  = 1648;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64611, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = 108003360;
  WORD2(__p)  = 1617;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64611, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = 108068592;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64656, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = 108068587;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64729, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = 105776704;
  WORD2(__p)  = 1617;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64754, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = 105973312;
  WORD2(__p)  = 1614;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64754, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = 105842240;
  WORD2(__p)  = 1617;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64755, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = 105973312;
  WORD2(__p)  = 1615;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64755, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = 105907776;
  WORD2(__p)  = 1617;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64756, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = 105973312;
  WORD2(__p)  = 1616;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64756, (__int16 *)&__p, 3uLL);
  LODWORD(__p)  = 105643662;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64828, (__int16 *)&__p, 2uLL);
  LODWORD(__p)  = 105580071;
  AddLigInputForCharacters((uint64_t *)v156, v4, 64829, (__int16 *)&__p, 2uLL);
  memset(v127, 170, sizeof(v127));
  v127[1]  = 0;
  memset(&v127[3], 0, 32);
  v127[15]  = &v127[7];
  memset(&v127[16], 0, 24);
  v127[42]  = &v127[19];
  memset(&v127[43], 0, 24);
  atomic_ullong v126 = (atomic_ullong)&unk_1ED05F8B0;
  v127[61]  = &v127[46];
  memset(&v127[62], 0, 24);
  v127[73]  = &v127[65];
  memset(&v127[74], 0, 24);
  unsigned int v128 = &v127[77];
  memset(&v150[8], 170, 0x2D0uLL);
  long long __p = 0uLL;
  *(void *)long long v150 = 0;
  long long v151 = &v150[8];
  memset(v153, 0, sizeof(v153));
  {
    *(void *)uint64_t v131 = &__p;
    std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v131);
    atomic_ullong v126 = (atomic_ullong)&unk_1ED05F8B0;
    *(void *)&long long __p = &v127[74];
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&__p);
    *(void *)&long long __p = &v127[62];
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&__p);
    *(void *)&long long __p = &v127[43];
    std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&__p);
    atomic_ullong v126 = (atomic_ullong)&unk_1ED05F928;
    std::vector<STXEntryOne,TInlineBufferAllocator<STXEntryOne,30ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v127[16]);
    *(void *)&long long __p = &v127[4];
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&__p);

    uint64_t v84 = *(void *)v156;
    if (*(void *)v156)
    {
      uint64_t v85 = *(void *)&v156[8];
      int64_t v86 = *(unsigned char **)v156;
      if (*(void *)&v156[8] != *(void *)v156)
      {
        do
        {
          v85 -= 48;
          std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100](v85);
        }
        while (v85 != v84);
        int64_t v86 = *(unsigned char **)v156;
      }
      *(void *)&v156[8]  = v84;
      if (&v156[24] > v86 || v157 <= (void *)v86) {
        operator delete(v86);
      }
    }
    goto LABEL_27;
  }
  CFAllocatorRef v82 = *(void **)&__b[408];
  if (*(void *)&__b[408] >= *(void *)&__b[416])
  {
    uint64_t v88 = (uint64_t)(*(void *)&__b[408] - *(void *)&__b[400]) >> 3;
    if ((unint64_t)(v88 + 1) >> 61) {
      goto LABEL_197;
    }
    unint64_t v89 = (uint64_t)(*(void *)&__b[416] - *(void *)&__b[400]) >> 2;
    if (v89 <= v88 + 1) {
      unint64_t v89 = v88 + 1;
    }
    if (*(void *)&__b[416] - *(void *)&__b[400] >= 0x7FFFFFFFFFFFFFF8uLL) {
      unint64_t v90 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v90 = v89;
    }
    *(void *)&long long v132 = &__b[424];
    if (v90) {
      uint8x8_t v91 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&__b[424], v90);
    }
    else {
      uint8x8_t v91 = 0;
    }
    *(void *)uint64_t v131 = v91;
    *(void *)&v131[8]  = &v91[8 * v88];
    *(void *)&v131[16]  = *(void *)&v131[8];
    *(void *)&v131[24]  = &v91[8 * v90];
    **(void **)&v131[8]  = atomic_exchange((atomic_ullong *volatile)&v120, 0);
    uint64_t v92 = *(void *)&v131[8];
    uint64_t v83 = *(void *)&v131[16] + 8;
    *(void *)&v131[16] += 8;
    id v93 = *(atomic_ullong **)&__b[408];
    id v94 = *(atomic_ullong **)&__b[400];
    if (*(void *)&__b[408] == *(void *)&__b[400])
    {
      int64x2_t v95 = vdupq_n_s64(*(unint64_t *)&__b[408]);
    }
    else
    {
      do
      {
        *(void *)(v92 - 8)  = atomic_exchange(--v93, 0);
        v92 -= 8;
      }
      while (v93 != v94);
      int64x2_t v95 = *(int64x2_t *)&__b[400];
      uint64_t v83 = *(void *)&v131[16];
    }
    *(void *)&__b[400]  = v92;
    *(void *)&__b[408]  = v83;
    *(int64x2_t *)&v131[8]  = v95;
    uint64_t v96 = *(void *)&__b[416];
    *(void *)&__b[416]  = *(void *)&v131[24];
    *(void *)&v131[24]  = v96;
    *(void *)uint64_t v131 = v95.i64[0];
    std::__split_buffer<TCFRef<__CFData *>,TInlineBufferAllocator<TCFRef<__CFData *>,30ul> &>::~__split_buffer((uint64_t)v131);
  }
  else
  {
    *CFAllocatorRef v82 = atomic_exchange((atomic_ullong *volatile)&v120, 0);
    uint64_t v83 = (uint64_t)(v82 + 1);
  }
  *(void *)&__b[408]  = v83;

  id v120 = (id)atomic_load_explicit((atomic_ullong *volatile)&v127[1], memory_order_acquire);
  float v97 = *(void **)&__b[680];
  if (*(void *)&__b[680] >= *(void *)&__b[688])
  {
    uint64_t v99 = (uint64_t)(*(void *)&__b[680] - *(void *)&__b[672]) >> 3;
    if (!((unint64_t)(v99 + 1) >> 61))
    {
      unint64_t v100 = (uint64_t)(*(void *)&__b[688] - *(void *)&__b[672]) >> 2;
      if (v100 <= v99 + 1) {
        unint64_t v100 = v99 + 1;
      }
      if (*(void *)&__b[688] - *(void *)&__b[672] >= 0x7FFFFFFFFFFFFFF8uLL) {
        unint64_t v101 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v101 = v100;
      }
      *(void *)&long long v132 = &__b[696];
      if (v101) {
        size_t v102 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)&__b[696], v101);
      }
      else {
        size_t v102 = 0;
      }
      *(void *)uint64_t v131 = v102;
      *(void *)&v131[8]  = &v102[8 * v99];
      *(void *)&v131[16]  = *(void *)&v131[8];
      *(void *)&v131[24]  = &v102[8 * v101];
      **(void **)&v131[8]  = atomic_exchange((atomic_ullong *volatile)&v120, 0);
      uint64_t v103 = *(void *)&v131[8];
      uint64_t v98 = *(void *)&v131[16] + 8;
      *(void *)&v131[16] += 8;
      CFRange v104 = *(atomic_ullong **)&__b[680];
      unint64_t v105 = *(atomic_ullong **)&__b[672];
      if (*(void *)&__b[680] == *(void *)&__b[672])
      {
        int64x2_t v106 = vdupq_n_s64(*(unint64_t *)&__b[680]);
      }
      else
      {
        do
        {
          *(void *)(v103 - 8)  = atomic_exchange(--v104, 0);
          v103 -= 8;
        }
        while (v104 != v105);
        int64x2_t v106 = *(int64x2_t *)&__b[672];
        uint64_t v98 = *(void *)&v131[16];
      }
      *(void *)&__b[672]  = v103;
      *(void *)&__b[680]  = v98;
      *(int64x2_t *)&v131[8]  = v106;
      uint64_t v107 = *(void *)&__b[688];
      *(void *)&__b[688]  = *(void *)&v131[24];
      *(void *)&v131[24]  = v107;
      *(void *)uint64_t v131 = v106.i64[0];
      std::__split_buffer<TCFRef<__CFData *>,TInlineBufferAllocator<TCFRef<__CFData *>,30ul> &>::~__split_buffer((uint64_t)v131);
      goto LABEL_170;
    }
LABEL_197:
    abort();
  }
  void *v97 = atomic_exchange((atomic_ullong *volatile)&v120, 0);
  uint64_t v98 = (uint64_t)(v97 + 1);
LABEL_170:
  *(void *)&__b[680]  = v98;

  if (v153[0]) {
    operator delete(v153[0]);
  }
  *(void *)uint64_t v131 = &__p;
  std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v131);
  atomic_ullong v126 = (atomic_ullong)&unk_1ED05F8B0;
  *(void *)&long long __p = &v127[74];
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&__p);
  *(void *)&long long __p = &v127[62];
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&__p);
  *(void *)&long long __p = &v127[43];
  std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&__p);
  atomic_ullong v126 = (atomic_ullong)&unk_1ED05F928;
  std::vector<STXEntryOne,TInlineBufferAllocator<STXEntryOne,30ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v127[16]);
  *(void *)&long long __p = &v127[4];
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&__p);

  uint64_t v108 = *(void *)v156;
  if (*(void *)v156)
  {
    uint64_t v109 = *(void *)&v156[8];
    double v110 = *(unsigned char **)v156;
    if (*(void *)&v156[8] != *(void *)v156)
    {
      do
      {
        v109 -= 48;
        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100](v109);
      }
      while (v109 != v108);
      double v110 = *(unsigned char **)v156;
    }
    *(void *)&v156[8]  = v108;
    if (&v156[24] > v110 || v157 <= (void *)v110) {
      operator delete(v110);
    }
  }
  int v112 = *(unsigned __int16 **)&__b[8];
  if (*(void *)&__b[8] == *(void *)&__b[16])
  {
    int v113 = v119;
  }
  else
  {
    int v113 = v119;
    while (*v112 != 1000)
    {
      v112 += 6;
      if (v112 == *(unsigned __int16 **)&__b[16])
      {
        int v112 = *(unsigned __int16 **)&__b[16];
        break;
      }
    }
  }
  uint64_t v114 = 0;
  *(_WORD *)uint64_t v156 = *v112;
  int v115 = *v112;
  while (*(unsigned __int16 *)((char *)&kMasterFeatureMap + v114 + 4) != v115)
  {
    v114 += 12;
    if (v114 == 1980)
    {
LABEL_190:
      __int16 v116 = 0;
      goto LABEL_191;
    }
  }
  while ((*((unsigned char *)&kMasterFeatureMap + v114 + 8) & 2) == 0)
  {
    if (v114 != 1968)
    {
      int v118 = *(unsigned __int16 *)((char *)&kMasterFeatureMap + v114 + 16);
      v114 += 12;
      if (v118 == v115) {
        continue;
      }
    }
    goto LABEL_190;
  }
  __int16 v116 = *(_WORD *)((char *)&kMasterFeatureMap + v114 + 6);
LABEL_191:
  *(_WORD *)&v156[2]  = v116;
  *(_DWORD *)&v156[4]  = 0;
  *(_DWORD *)&v156[8]  = *((_DWORD *)v112 + 2) ^ *((_DWORD *)v112 + 1);
  std::vector<MortFeatureEntry,TInlineBufferAllocator<MortFeatureEntry,30ul>>::emplace<MortFeatureEntry>(&__b[8], (char *)v112, (uint64_t *)v156);
  uint64_t v21 = 1;
LABEL_192:
  *(void *)uint64_t v156 = &__b[672];
  std::vector<TCFRef<__CFData const*>,TInlineBufferAllocator<TCFRef<__CFData const*>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v156);
  *(void *)uint64_t v156 = &__b[400];
  std::vector<TCFRef<__CFData const*>,TInlineBufferAllocator<TCFRef<__CFData const*>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v156);
  *(void *)uint64_t v156 = &__b[8];
  std::vector<MortFeatureEntry,TInlineBufferAllocator<MortFeatureEntry,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v156);
  return v21;
}

void std::__function::__func<BuildFeaturesMap(OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_0,std::allocator<BuildFeaturesMap(OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_0>,BOOL ()(unsigned int,OTL::ScriptTable const*,BOOL &)>::~__func()
{
}

__n128 std::__function::__func<BuildFeaturesMap(OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_0,std::allocator<BuildFeaturesMap(OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_0>,BOOL ()(unsigned int,OTL::ScriptTable const*,BOOL &)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1ED0601A0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8)  = result;
  *((void *)v2 + 3)  = *(void *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<BuildFeaturesMap(OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_0,std::allocator<BuildFeaturesMap(OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_0>,BOOL ()(unsigned int,OTL::ScriptTable const*,BOOL &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2  = &unk_1ED0601A0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24)  = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8)  = result;
  return result;
}

uint64_t std::__function::__func<BuildFeaturesMap(OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_0,std::allocator<BuildFeaturesMap(OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_0>,BOOL ()(unsigned int,OTL::ScriptTable const*,BOOL &)>::operator()(uint64_t a1, __int32 *a2, uint64_t *a3, unsigned char *a4)
{
  __int32 v6 = *a2;
  uint64_t v7 = *a3;
  int v8 = *(__int32 **)(a1 + 8);
  uint64_t v9 = v8 + 9;
  uint64_t v10 = wmemchr(v8, *a2, 9uLL);
  if (v10) {
    unint64_t v11 = v10;
  }
  else {
    unint64_t v11 = v9;
  }
  if (v11 == (__int32 *)(*(void *)(a1 + 8) + 36))
  {
    **(unsigned char **)(a1 + 16)  = 0;
    *a4  = 1;
  }
  else
  {
    BOOL v12 = *(char ***)(a1 + 24);
    unint64_t v14 = (unint64_t)v12[1];
    unint64_t v13 = (unint64_t)v12[2];
    if (v14 >= v13)
    {
      uint64_t v16 = (uint64_t)(v14 - (void)*v12) >> 4;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 60) {
        abort();
      }
      uint64_t v18 = v13 - (void)*v12;
      if (v18 >> 3 > v17) {
        unint64_t v17 = v18 >> 3;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v19 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      uint64_t v20 = (unint64_t *)(v12 + 63);
      uint64_t v21 = v12[63];
      unint64_t v22 = (unint64_t)&v21[16 * v19];
      if (v22 <= (unint64_t)(v12 + 63))
      {
        *uint64_t v20 = v22;
      }
      else
      {
        if (v19 >> 60) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        uint64_t v21 = (char *)operator new(16 * v19);
      }
      unint64_t v23 = &v21[16 * v16];
      *(_DWORD *)unint64_t v23 = v6;
      *((void *)v23 + 1)  = v7;
      unint64_t v25 = (unint64_t *)*v12;
      unint64_t v24 = (unint64_t *)v12[1];
      uint64_t v26 = v23;
      if (v24 != (unint64_t *)*v12)
      {
        do
        {
          *((_OWORD *)v26 - 1)  = *((_OWORD *)v24 - 1);
          v26 -= 16;
          v24 -= 2;
        }
        while (v24 != v25);
        unint64_t v24 = (unint64_t *)*v12;
      }
      uint64_t v15 = v23 + 16;
      _anonymous_namespace_::MorxChainBuilder *v12 = v26;
      v12[1]  = v23 + 16;
      unint64_t v27 = v12[2];
      v12[2]  = &v21[16 * v19];
      if (v24)
      {
        if (v12 + 3 <= (char **)v24 && v20 > v24)
        {
          if (v27 == (char *)*v20) {
            *uint64_t v20 = (unint64_t)v24;
          }
        }
        else
        {
          operator delete(v24);
        }
      }
    }
    else
    {
      *(_DWORD *)unint64_t v14 = v6;
      *(void *)(v14 + 8)  = v7;
      uint64_t v15 = (char *)(v14 + 16);
    }
    v12[1]  = v15;
  }
  return 1;
}

void std::__function::__func<BuildFeaturesMap(OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_1,std::allocator<BuildFeaturesMap(OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_1>,BOOL ()(OTL::ConditionSetTable const*,OTL::FeatureTableSubstitutionTable const*,BOOL &)>::~__func()
{
}

void *std::__function::__func<BuildFeaturesMap(OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_1,std::allocator<BuildFeaturesMap(OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_1>,BOOL ()(OTL::ConditionSetTable const*,OTL::FeatureTableSubstitutionTable const*,BOOL &)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1ED0601E8;
  result[1]  = v3;
  return result;
}

uint64_t std::__function::__func<BuildFeaturesMap(OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_1,std::allocator<BuildFeaturesMap(OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_1>,BOOL ()(OTL::ConditionSetTable const*,OTL::FeatureTableSubstitutionTable const*,BOOL &)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2  = &unk_1ED0601E8;
  a2[1]  = v2;
  return result;
}

uint64_t std::__function::__func<BuildFeaturesMap(OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_1,std::allocator<BuildFeaturesMap(OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_1>,BOOL ()(OTL::ConditionSetTable const*,OTL::FeatureTableSubstitutionTable const*,BOOL &)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  **(unsigned char **)(a1 + 8)  = 0;
  *a4  = 1;
  return 1;
}

void std::__function::__func<BuildFeaturesMap(OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_2,std::allocator<BuildFeaturesMap(OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_2>,BOOL ()(unsigned int,OTL::LangSysTable const*,BOOL &)>::~__func()
{
}

__n128 std::__function::__func<BuildFeaturesMap(OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_2,std::allocator<BuildFeaturesMap(OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_2>,BOOL ()(unsigned int,OTL::LangSysTable const*,BOOL &)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v2 = &unk_1ED060230;
  *(_OWORD *)(v2 + 8)  = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24)  = result;
  *((void *)v2 + 5)  = *(void *)(a1 + 40);
  return result;
}

__n128 std::__function::__func<BuildFeaturesMap(OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_2,std::allocator<BuildFeaturesMap(OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_2>,BOOL ()(unsigned int,OTL::LangSysTable const*,BOOL &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2  = &unk_1ED060230;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 40)  = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24)  = v3;
  *(__n128 *)(a2 + 8)  = result;
  return result;
}

BOOL std::__function::__func<BuildFeaturesMap(OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_2,std::allocator<BuildFeaturesMap(OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_2>,BOOL ()(unsigned int,OTL::LangSysTable const*,BOOL &)>::operator()(uint64_t a1, unsigned int *a2, unint64_t *a3, unsigned char *a4)
{
  unint64_t v4 = *a3;
  if (!*a3) {
    return v4 != 0;
  }
  if (*(__int16 *)(v4 + 2) != -1)
  {
    **(unsigned char **)(a1 + 8)  = 0;
    *a4  = 1;
    return v4 != 0;
  }
  unint64_t v6 = *a2;
  uint64_t v7 = *(char ***)(a1 + 16);
  unint64_t v9 = (unint64_t)v7[1];
  unint64_t v8 = (unint64_t)v7[2];
  if (v9 >= v8)
  {
    uint64_t v11 = (uint64_t)(v9 - (void)*v7) >> 4;
    unint64_t v12 = v11 + 1;
    if ((unint64_t)(v11 + 1) >> 60) {
      abort();
    }
    uint64_t v13 = v8 - (void)*v7;
    if (v13 >> 3 > v12) {
      unint64_t v12 = v13 >> 3;
    }
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v14 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v12;
    }
    uint64_t v15 = (unint64_t *)(v7 + 63);
    uint64_t v16 = v7[63];
    unint64_t v17 = (unint64_t)&v16[16 * v14];
    if (v17 <= (unint64_t)(v7 + 63))
    {
      *uint64_t v15 = v17;
    }
    else
    {
      if (v14 >> 60) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v16 = (char *)operator new(16 * v14);
    }
    uint64_t v18 = &v16[16 * v11];
    *(_DWORD *)uint64_t v18 = v6;
    *((void *)v18 + 1)  = v4;
    uint64_t v20 = (unint64_t *)*v7;
    unint64_t v19 = (unint64_t *)v7[1];
    uint64_t v21 = v18;
    if (v19 != (unint64_t *)*v7)
    {
      do
      {
        *((_OWORD *)v21 - 1)  = *((_OWORD *)v19 - 1);
        v21 -= 16;
        v19 -= 2;
      }
      while (v19 != v20);
      unint64_t v19 = (unint64_t *)*v7;
    }
    uint64_t v10 = v18 + 16;
    _anonymous_namespace_::MorxChainBuilder *v7 = v21;
    v7[1]  = v18 + 16;
    unint64_t v22 = v7[2];
    void v7[2] = &v16[16 * v14];
    if (v19)
    {
      if (v7 + 3 <= (char **)v19 && v15 > v19)
      {
        if (v22 == (char *)*v15) {
          *uint64_t v15 = (unint64_t)v19;
        }
      }
      else
      {
        operator delete(v19);
      }
    }
  }
  else
  {
    *(_DWORD *)unint64_t v9 = v6;
    *(void *)(v9 + 8)  = v4;
    uint64_t v10 = (char *)(v9 + 16);
  }
  v7[1]  = v10;
  uint64_t v24 = *(void *)(a1 + 24);
  int v25 = **(_DWORD **)(a1 + 32);
  unint64_t v26 = 0x9DDFEA08EB382D69 * (((8 * v4) + 8) ^ HIDWORD(v4));
  unint64_t v27 = 0x9DDFEA08EB382D69 * (HIDWORD(v4) ^ (v26 >> 47) ^ v26);
  unint64_t v28 = 0x9DDFEA08EB382D69 * (v27 ^ (v27 >> 47));
  unint64_t v29 = *(void *)(v24 + 8);
  if (v29)
  {
    uint8x8_t v30 = (uint8x8_t)vcnt_s8((int8x8_t)v29);
    v30.i16[0]  = vaddlv_u8(v30);
    if (v30.u32[0] > 1uLL)
    {
      unint64_t v31 = 0x9DDFEA08EB382D69 * (v27 ^ (v27 >> 47));
      if (v28 >= v29) {
        unint64_t v31 = v28 % v29;
      }
    }
    else
    {
      unint64_t v31 = (v29 - 1) & v28;
    }
    uint64_t v32 = *(void **)(*(void *)v24 + 8 * v31);
    if (v32)
    {
      for (unint64_t i = (void *)*v32; i; unint64_t i = (void *)*i)
      {
        unint64_t v34 = i[1];
        if (v34 == v28)
        {
          if (i[2] == v4) {
            goto LABEL_66;
          }
        }
        else
        {
          if (v30.u32[0] > 1uLL)
          {
            if (v34 >= v29) {
              v34 %= v29;
            }
          }
          else
          {
            v34 &= v29 - 1;
          }
          if (v34 != v31) {
            break;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v31 = 0xAAAAAAAAAAAAAAAALL;
  }
  unint64_t v35 = operator new(0x20uLL);
  *unint64_t v35 = 0;
  v35[1]  = v28;
  v35[2]  = v4;
  *((_DWORD *)v35 + 6)  = v25;
  float v36 = (float)(unint64_t)(*(void *)(v24 + 24) + 1);
  float v37 = *(float *)(v24 + 32);
  if (!v29 || (float)(v37 * (float)v29) < v36)
  {
    BOOL v38 = 1;
    if (v29 >= 3) {
      BOOL v38 = (v29 & (v29 - 1)) != 0;
    }
    unint64_t v39 = v38 | (2 * v29);
    unint64_t v40 = vcvtps_u32_f32(v36 / v37);
    if (v39 <= v40) {
      size_t v41 = v40;
    }
    else {
      size_t v41 = v39;
    }
    std::__hash_table<std::__hash_value_type<TRun const*,long>,std::__unordered_map_hasher<TRun const*,std::__hash_value_type<TRun const*,long>,std::hash<TRun const*>,std::equal_to<TRun const*>,true>,std::__unordered_map_equal<TRun const*,std::__hash_value_type<TRun const*,long>,std::equal_to<TRun const*>,std::hash<TRun const*>,true>,std::allocator<std::__hash_value_type<TRun const*,long>>>::__rehash<true>(v24, v41);
    unint64_t v29 = *(void *)(v24 + 8);
    if ((v29 & (v29 - 1)) != 0)
    {
      if (v28 >= v29) {
        unint64_t v31 = v28 % v29;
      }
      else {
        unint64_t v31 = v28;
      }
    }
    else
    {
      unint64_t v31 = (v29 - 1) & v28;
    }
  }
  uint64_t v42 = *(void *)v24;
  unint64_t v43 = *(void **)(*(void *)v24 + 8 * v31);
  if (v43)
  {
    *unint64_t v35 = *v43;
LABEL_64:
    void *v43 = v35;
    goto LABEL_65;
  }
  *unint64_t v35 = *(void *)(v24 + 16);
  *(void *)(v24 + 16)  = v35;
  *(void *)(v42 + 8 * v31)  = v24 + 16;
  if (*v35)
  {
    unint64_t v44 = *(void *)(*v35 + 8);
    if ((v29 & (v29 - 1)) != 0)
    {
      if (v44 >= v29) {
        v44 %= v29;
      }
    }
    else
    {
      v44 &= v29 - 1;
    }
    unint64_t v43 = (void *)(*(void *)v24 + 8 * v44);
    goto LABEL_64;
  }
LABEL_65:
  ++*(void *)(v24 + 24);
LABEL_66:
  if (v6)
  {
    uint64_t v45 = *(void *)(a1 + 40);
    int v46 = **(_DWORD **)(a1 + 32);
    unint64_t v47 = *(void *)(v45 + 8);
    if (v47)
    {
      uint8x8_t v48 = (uint8x8_t)vcnt_s8((int8x8_t)v47);
      v48.i16[0]  = vaddlv_u8(v48);
      if (v48.u32[0] > 1uLL)
      {
        unint64_t v49 = v6;
        if (v47 <= v6) {
          unint64_t v49 = v6 % v47;
        }
      }
      else
      {
        unint64_t v49 = (v47 - 1) & v6;
      }
      uint64_t v50 = *(uint64_t ***)(*(void *)v45 + 8 * v49);
      if (v50)
      {
        for (CFIndex j = *v50; j; CFIndex j = (uint64_t *)*j)
        {
          unint64_t v52 = j[1];
          if (v52 == v6)
          {
            if (*((_DWORD *)j + 4) == v6) {
              return v4 != 0;
            }
          }
          else
          {
            if (v48.u32[0] > 1uLL)
            {
              if (v52 >= v47) {
                v52 %= v47;
              }
            }
            else
            {
              v52 &= v47 - 1;
            }
            if (v52 != v49) {
              break;
            }
          }
        }
      }
    }
    else
    {
      unint64_t v49 = 0xAAAAAAAAAAAAAAAALL;
    }
    uint64_t v53 = operator new(0x18uLL);
    v53[1]  = v6;
    *((_DWORD *)v53 + 4)  = v6;
    *((_DWORD *)v53 + 5)  = v46;
    float v54 = (float)(unint64_t)(*(void *)(v45 + 24) + 1);
    float v55 = *(float *)(v45 + 32);
    if (!v47 || (float)(v55 * (float)v47) < v54)
    {
      BOOL v56 = 1;
      if (v47 >= 3) {
        BOOL v56 = (v47 & (v47 - 1)) != 0;
      }
      unint64_t v57 = v56 | (2 * v47);
      unint64_t v58 = vcvtps_u32_f32(v54 / v55);
      if (v57 <= v58) {
        size_t v59 = v58;
      }
      else {
        size_t v59 = v57;
      }
      std::__hash_table<std::__hash_value_type<unsigned int,OTL::Lookup>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,OTL::Lookup>>>::__rehash<true>(v45, v59);
      unint64_t v47 = *(void *)(v45 + 8);
      if ((v47 & (v47 - 1)) != 0)
      {
        if (v47 <= v6) {
          unint64_t v49 = v6 % v47;
        }
        else {
          unint64_t v49 = v6;
        }
      }
      else
      {
        unint64_t v49 = (v47 - 1) & v6;
      }
    }
    uint64_t v60 = *(void *)v45;
    uint64_t v61 = *(void **)(*(void *)v45 + 8 * v49);
    if (v61)
    {
      void *v53 = *v61;
    }
    else
    {
      uint64_t v62 = *(void *)(v45 + 16);
      void *v53 = v62;
      *(void *)(v45 + 16)  = v53;
      *(void *)(v60 + 8 * v49)  = v45 + 16;
      if (!v62)
      {
LABEL_105:
        ++*(void *)(v45 + 24);
        return v4 != 0;
      }
      unint64_t v63 = *(void *)(v62 + 8);
      if ((v47 & (v47 - 1)) != 0)
      {
        if (v63 >= v47) {
          v63 %= v47;
        }
      }
      else
      {
        v63 &= v47 - 1;
      }
      uint64_t v61 = (void *)(*(void *)v45 + 8 * v63);
    }
    void *v61 = v53;
    goto LABEL_105;
  }
  return v4 != 0;
}

void std::__function::__func<BuildFeaturesMap(OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_3,std::allocator<BuildFeaturesMap(OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_3>,BOOL ()(unsigned int,OTL::FeatureTable const*,BOOL &)>::~__func()
{
}

__n128 std::__function::__func<BuildFeaturesMap(OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_3,std::allocator<BuildFeaturesMap(OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_3>,BOOL ()(unsigned int,OTL::FeatureTable const*,BOOL &)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x50uLL);
  *(void *)uint64_t v2 = &unk_1ED060278;
  *(_OWORD *)(v2 + 24)  = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(v2 + 40)  = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(v2 + 56)  = *(_OWORD *)(a1 + 56);
  *((void *)v2 + 9)  = *(void *)(a1 + 72);
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8)  = result;
  return result;
}

__n128 std::__function::__func<BuildFeaturesMap(OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_3,std::allocator<BuildFeaturesMap(OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_3>,BOOL ()(unsigned int,OTL::FeatureTable const*,BOOL &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2  = &unk_1ED060278;
  *(_OWORD *)(a2 + 8)  = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  long long v3 = *(_OWORD *)(a1 + 40);
  long long v4 = *(_OWORD *)(a1 + 56);
  *(void *)(a2 + 72)  = *(void *)(a1 + 72);
  *(_OWORD *)(a2 + 56)  = v4;
  *(_OWORD *)(a2 + 40)  = v3;
  *(__n128 *)(a2 + 24)  = result;
  return result;
}

uint64_t std::__function::__func<BuildFeaturesMap(OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_3,std::allocator<BuildFeaturesMap(OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_3>,BOOL ()(unsigned int,OTL::FeatureTable const*,BOOL &)>::operator()(uint64_t a1, unsigned int *a2, uint64_t *a3, unsigned char *a4)
{
  v108[4]  = *MEMORY[0x1E4F143B8];
  unint64_t v6 = *a2;
  uint64_t v7 = *a3;
  int v107 = v6;
  if (v6 == 1920365166) {
    goto LABEL_217;
  }
  if (v6 == 1819239276)
  {
    unint64_t v8 = *(int **)(a1 + 8);
    int v107 = *v8;
LABEL_209:
    uint64_t v90 = **(void **)(a1 + 48);
    unint64_t v91 = **(void **)(a1 + 56);
    uint64_t v92 = *(void *)(a1 + 32);
    uint64_t v93 = *(void *)(a1 + 64);
    uint64_t v94 = *(void *)(a1 + 72);
    uint64_t v95 = *(void *)(a1 + 16);
    uint64_t v96 = operator new(0x40uLL);
    *uint64_t v96 = &unk_1ED062000;
    v96[1]  = v92;
    v96[2]  = v8;
    v96[3]  = v93;
    v96[4]  = &v107;
    v96[5]  = v94;
    v96[6]  = v95;
    v96[7]  = a4;
    v108[3]  = v96;
    uint64_t v97 = OTL::GCommon::IterateLookupIndexes(v90, v7, v91, (uint64_t)v108);
    std::__function::__value_func<BOOL ()(unsigned short,BOOL &)>::~__value_func[abi:nn180100](v108);
    return v97;
  }
  unint64_t v9 = *(unsigned int **)(a1 + 8);
  unint64_t v10 = *v9;
  if (!v10)
  {
    uint64_t v15 = (unsigned int *)(std::__hash_table<std::__hash_value_type<OTL::LangSysTable const*,unsigned int>,std::__unordered_map_hasher<OTL::LangSysTable const*,std::__hash_value_type<OTL::LangSysTable const*,unsigned int>,std::hash<OTL::LangSysTable const*>,std::equal_to<OTL::LangSysTable const*>,true>,std::__unordered_map_equal<OTL::LangSysTable const*,std::__hash_value_type<OTL::LangSysTable const*,unsigned int>,std::equal_to<OTL::LangSysTable const*>,std::hash<OTL::LangSysTable const*>,true>,std::allocator<std::__hash_value_type<OTL::LangSysTable const*,unsigned int>>>::__emplace_unique_key_args<OTL::LangSysTable const*,std::piecewise_construct_t const&,std::tuple<OTL::LangSysTable const* const&>,std::tuple<>>(*(void *)(a1 + 32), *((void *)v9 + 1), (void *)v9 + 1)+ 3);
    goto LABEL_47;
  }
  uint64_t v11 = *(void *)(a1 + 24);
  unint64_t v12 = *(void *)(v11 + 8);
  if (v12)
  {
    uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0]  = vaddlv_u8(v13);
    if (v13.u32[0] > 1uLL)
    {
      unint64_t v14 = *v9;
      if (v12 <= v10) {
        unint64_t v14 = v10 % v12;
      }
    }
    else
    {
      unint64_t v14 = (v12 - 1) & v10;
    }
    uint64_t v16 = *(void ***)(*(void *)v11 + 8 * v14);
    if (v16)
    {
      unint64_t v17 = (char *)*v16;
      if (*v16)
      {
        do
        {
          unint64_t v18 = *((void *)v17 + 1);
          if (v18 == v10)
          {
            if (*((_DWORD *)v17 + 4) == v10) {
              goto LABEL_46;
            }
          }
          else
          {
            if (v13.u32[0] > 1uLL)
            {
              if (v18 >= v12) {
                v18 %= v12;
              }
            }
            else
            {
              v18 &= v12 - 1;
            }
            if (v18 != v14) {
              break;
            }
          }
          unint64_t v17 = *(char **)v17;
        }
        while (v17);
      }
    }
  }
  else
  {
    unint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
  }
  unint64_t v17 = (char *)operator new(0x18uLL);
  *(void *)unint64_t v17 = 0;
  *((void *)v17 + 1)  = v10;
  *((_DWORD *)v17 + 4)  = *v9;
  *((_DWORD *)v17 + 5)  = 0;
  float v19 = (float)(unint64_t)(*(void *)(v11 + 24) + 1);
  float v20 = *(float *)(v11 + 32);
  if (!v12 || (float)(v20 * (float)v12) < v19)
  {
    BOOL v21 = v12 < 3 || (v12 & (v12 - 1)) != 0;
    unint64_t v22 = v21 | (2 * v12);
    unint64_t v23 = vcvtps_u32_f32(v19 / v20);
    if (v22 <= v23) {
      size_t v24 = v23;
    }
    else {
      size_t v24 = v22;
    }
    std::__hash_table<std::__hash_value_type<unsigned int,OTL::Lookup>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,OTL::Lookup>>>::__rehash<true>(v11, v24);
    unint64_t v12 = *(void *)(v11 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v12 <= v10) {
        unint64_t v14 = v10 % v12;
      }
      else {
        unint64_t v14 = v10;
      }
    }
    else
    {
      unint64_t v14 = (v12 - 1) & v10;
    }
  }
  uint64_t v25 = *(void *)v11;
  unint64_t v26 = *(void **)(*(void *)v11 + 8 * v14);
  if (v26)
  {
    *(void *)unint64_t v17 = *v26;
  }
  else
  {
    *(void *)unint64_t v17 = *(void *)(v11 + 16);
    *(void *)(v11 + 16)  = v17;
    *(void *)(v25 + 8 * v14)  = v11 + 16;
    if (!*(void *)v17) {
      goto LABEL_45;
    }
    unint64_t v27 = *(void *)(*(void *)v17 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v27 >= v12) {
        v27 %= v12;
      }
    }
    else
    {
      v27 &= v12 - 1;
    }
    unint64_t v26 = (void *)(*(void *)v11 + 8 * v27);
  }
  void *v26 = v17;
LABEL_45:
  ++*(void *)(v11 + 24);
LABEL_46:
  uint64_t v15 = (unsigned int *)(v17 + 20);
LABEL_47:
  unint64_t v28 = *v15;
  unint64_t v29 = *(uint64_t **)(a1 + 40);
  unint64_t v30 = v29[1];
  if (v30)
  {
    uint8x8_t v31 = (uint8x8_t)vcnt_s8((int8x8_t)v30);
    v31.i16[0]  = vaddlv_u8(v31);
    if (v31.u32[0] > 1uLL)
    {
      unint64_t v32 = *v15;
      if (v30 <= v28) {
        unint64_t v32 = v28 % v30;
      }
    }
    else
    {
      unint64_t v32 = (v30 - 1) & v28;
    }
    uint64_t v33 = *(void ***)(*v29 + 8 * v32);
    if (v33)
    {
      unint64_t v34 = (char *)*v33;
      if (*v33)
      {
        do
        {
          unint64_t v35 = *((void *)v34 + 1);
          if (v35 == v28)
          {
            if (*((_DWORD *)v34 + 4) == v28) {
              goto LABEL_120;
            }
          }
          else
          {
            if (v31.u32[0] > 1uLL)
            {
              if (v35 >= v30) {
                v35 %= v30;
              }
            }
            else
            {
              v35 &= v30 - 1;
            }
            if (v35 != v32) {
              break;
            }
          }
          unint64_t v34 = *(char **)v34;
        }
        while (v34);
      }
    }
  }
  else
  {
    unint64_t v32 = 0xAAAAAAAAAAAAAAAALL;
  }
  float v36 = v29 + 2;
  unint64_t v34 = (char *)operator new(0x40uLL);
  *(void *)unint64_t v34 = 0;
  *((void *)v34 + 1)  = v28;
  *((_DWORD *)v34 + 4)  = v28;
  *(_OWORD *)(v34 + 24)  = 0u;
  *(_OWORD *)(v34 + 40)  = 0u;
  *((_DWORD *)v34 + 14)  = 1065353216;
  float v37 = (float)(unint64_t)(v29[3] + 1);
  float v38 = *((float *)v29 + 8);
  if (!v30 || (float)(v38 * (float)v30) < v37)
  {
    BOOL v39 = 1;
    if (v30 >= 3) {
      BOOL v39 = (v30 & (v30 - 1)) != 0;
    }
    unint64_t v40 = v39 | (2 * v30);
    unint64_t v41 = vcvtps_u32_f32(v37 / v38);
    if (v40 <= v41) {
      int8x8_t prime = (int8x8_t)v41;
    }
    else {
      int8x8_t prime = (int8x8_t)v40;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v30 = v29[1];
    }
    if (*(void *)&prime > v30) {
      goto LABEL_76;
    }
    if (*(void *)&prime < v30)
    {
      unint64_t v49 = vcvtps_u32_f32((float)(unint64_t)v29[3] / *((float *)v29 + 8));
      if (v30 < 3 || (uint8x8_t v50 = (uint8x8_t)vcnt_s8((int8x8_t)v30), v50.i16[0] = vaddlv_u8(v50), v50.u32[0] > 1uLL))
      {
        unint64_t v49 = std::__next_prime(v49);
      }
      else
      {
        uint64_t v51 = 1 << -(char)__clz(v49 - 1);
        if (v49 >= 2) {
          unint64_t v49 = v51;
        }
      }
      if (*(void *)&prime <= v49) {
        int8x8_t prime = (int8x8_t)v49;
      }
      if (*(void *)&prime >= v30)
      {
        unint64_t v30 = v29[1];
      }
      else
      {
        if (prime)
        {
LABEL_76:
          if (*(void *)&prime >> 61) {
            goto LABEL_238;
          }
          unint64_t v43 = operator new(8 * *(void *)&prime);
          unint64_t v44 = (void *)*v29;
          uint64_t *v29 = (uint64_t)v43;
          if (v44) {
            operator delete(v44);
          }
          uint64_t v45 = 0;
          v29[1]  = (uint64_t)prime;
          do
            *(void *)(*v29 + 8 * v45++)  = 0;
          while (*(void *)&prime != v45);
          int v46 = (void *)*v36;
          if (*v36)
          {
            unint64_t v47 = v46[1];
            uint8x8_t v48 = (uint8x8_t)vcnt_s8(prime);
            v48.i16[0]  = vaddlv_u8(v48);
            if (v48.u32[0] > 1uLL)
            {
              if (v47 >= *(void *)&prime) {
                v47 %= *(void *)&prime;
              }
            }
            else
            {
              v47 &= *(void *)&prime - 1;
            }
            *(void *)(*v29 + 8 * v47)  = v36;
            unint64_t v52 = (void *)*v46;
            if (*v46)
            {
              do
              {
                unint64_t v53 = v52[1];
                if (v48.u32[0] > 1uLL)
                {
                  if (v53 >= *(void *)&prime) {
                    v53 %= *(void *)&prime;
                  }
                }
                else
                {
                  v53 &= *(void *)&prime - 1;
                }
                if (v53 != v47)
                {
                  if (!*(void *)(*v29 + 8 * v53))
                  {
                    *(void *)(*v29 + 8 * v53)  = v46;
                    goto LABEL_101;
                  }
                  *int v46 = *v52;
                  *unint64_t v52 = **(void **)(*v29 + 8 * v53);
                  **(void **)(*v29 + 8 * v53)  = v52;
                  unint64_t v52 = v46;
                }
                unint64_t v53 = v47;
LABEL_101:
                int v46 = v52;
                unint64_t v52 = (void *)*v52;
                unint64_t v47 = v53;
              }
              while (v52);
            }
          }
          unint64_t v30 = (unint64_t)prime;
          goto LABEL_105;
        }
        unint64_t v105 = (void *)*v29;
        uint64_t *v29 = 0;
        if (v105) {
          operator delete(v105);
        }
        unint64_t v30 = 0;
        v29[1]  = 0;
      }
    }
LABEL_105:
    if ((v30 & (v30 - 1)) != 0)
    {
      if (v30 <= v28) {
        unint64_t v32 = v28 % v30;
      }
      else {
        unint64_t v32 = v28;
      }
    }
    else
    {
      unint64_t v32 = (v30 - 1) & v28;
    }
  }
  uint64_t v54 = *v29;
  float v55 = *(void **)(*v29 + 8 * v32);
  if (v55)
  {
    *(void *)unint64_t v34 = *v55;
LABEL_118:
    void *v55 = v34;
    goto LABEL_119;
  }
  *(void *)unint64_t v34 = *v36;
  *float v36 = v34;
  *(void *)(v54 + 8 * v32)  = v36;
  if (*(void *)v34)
  {
    unint64_t v56 = *(void *)(*(void *)v34 + 8);
    if ((v30 & (v30 - 1)) != 0)
    {
      if (v56 >= v30) {
        v56 %= v30;
      }
    }
    else
    {
      v56 &= v30 - 1;
    }
    float v55 = (void *)(*v29 + 8 * v56);
    goto LABEL_118;
  }
LABEL_119:
  ++v29[3];
LABEL_120:
  unint64_t v57 = *((void *)v34 + 4);
  if (!v57)
  {
    unint64_t v60 = 0xAAAAAAAAAAAAAAAALL;
    goto LABEL_152;
  }
  uint8x8_t v58 = (uint8x8_t)vcnt_s8((int8x8_t)v57);
  v58.i16[0]  = vaddlv_u8(v58);
  if (v58.u32[0] > 1uLL)
  {
    unint64_t v59 = v6;
    if (v57 <= v6) {
      unint64_t v59 = v6 % v57;
    }
  }
  else
  {
    unint64_t v59 = (v57 - 1) & v6;
  }
  uint64_t v61 = *((void *)v34 + 3);
  uint64_t v62 = *(uint64_t ***)(v61 + 8 * v59);
  if (!v62 || (unint64_t v63 = *v62) == 0)
  {
LABEL_137:
    if (v58.u32[0] > 1uLL)
    {
      unint64_t v60 = v6;
      if (v57 <= v6) {
        unint64_t v60 = v6 % v57;
      }
    }
    else
    {
      unint64_t v60 = (v57 - 1) & v6;
    }
    int64x2_t v65 = *(uint64_t ***)(v61 + 8 * v60);
    if (v65)
    {
      for (unint64_t i = *v65; i; unint64_t i = (uint64_t *)*i)
      {
        unint64_t v67 = i[1];
        if (v67 == v6)
        {
          if (*((_DWORD *)i + 4) == v6) {
            goto LABEL_208;
          }
        }
        else
        {
          if (v58.u32[0] > 1uLL)
          {
            if (v67 >= v57) {
              v67 %= v57;
            }
          }
          else
          {
            v67 &= v57 - 1;
          }
          if (v67 != v60) {
            break;
          }
        }
      }
    }
LABEL_152:
    uint64_t v68 = operator new(0x20uLL);
    *uint64_t v68 = 0;
    v68[1]  = v6;
    *((_DWORD *)v68 + 4)  = v6;
    v68[3]  = v7;
    float v69 = (float)(unint64_t)(*((void *)v34 + 6) + 1);
    float v70 = *((float *)v34 + 14);
    if (v57 && (float)(v70 * (float)v57) >= v69)
    {
LABEL_198:
      uint64_t v87 = *((void *)v34 + 3);
      uint64_t v88 = *(void **)(v87 + 8 * v60);
      if (v88)
      {
        *uint64_t v68 = *v88;
      }
      else
      {
        *uint64_t v68 = *((void *)v34 + 5);
        *((void *)v34 + 5)  = v68;
        *(void *)(v87 + 8 * v60)  = v34 + 40;
        if (!*v68) {
          goto LABEL_207;
        }
        unint64_t v89 = *(void *)(*v68 + 8);
        if ((v57 & (v57 - 1)) != 0)
        {
          if (v89 >= v57) {
            v89 %= v57;
          }
        }
        else
        {
          v89 &= v57 - 1;
        }
        uint64_t v88 = (void *)(*((void *)v34 + 3) + 8 * v89);
      }
      void *v88 = v68;
LABEL_207:
      ++*((void *)v34 + 6);
LABEL_208:
      unint64_t v8 = *(int **)(a1 + 8);
      goto LABEL_209;
    }
    BOOL v71 = 1;
    if (v57 >= 3) {
      BOOL v71 = (v57 & (v57 - 1)) != 0;
    }
    unint64_t v72 = v71 | (2 * v57);
    unint64_t v73 = vcvtps_u32_f32(v69 / v70);
    if (v72 <= v73) {
      int8x8_t v74 = (int8x8_t)v73;
    }
    else {
      int8x8_t v74 = (int8x8_t)v72;
    }
    if (*(void *)&v74 == 1)
    {
      int8x8_t v74 = (int8x8_t)2;
    }
    else if ((*(void *)&v74 & (*(void *)&v74 - 1)) != 0)
    {
      int8x8_t v74 = (int8x8_t)std::__next_prime(*(void *)&v74);
      unint64_t v57 = *((void *)v34 + 4);
    }
    if (*(void *)&v74 > v57)
    {
LABEL_164:
      if (!(*(void *)&v74 >> 61))
      {
        uint64_t v75 = operator new(8 * *(void *)&v74);
        int64x2_t v76 = (void *)*((void *)v34 + 3);
        *((void *)v34 + 3)  = v75;
        if (v76) {
          operator delete(v76);
        }
        uint64_t v77 = 0;
        *((int8x8_t *)v34 + 4)  = v74;
        do
          *(void *)(*((void *)v34 + 3) + 8 * v77++)  = 0;
        while (*(void *)&v74 != v77);
        uint64_t v78 = (void *)*((void *)v34 + 5);
        if (v78)
        {
          unint64_t v79 = v78[1];
          uint8x8_t v80 = (uint8x8_t)vcnt_s8(v74);
          v80.i16[0]  = vaddlv_u8(v80);
          if (v80.u32[0] > 1uLL)
          {
            if (v79 >= *(void *)&v74) {
              v79 %= *(void *)&v74;
            }
          }
          else
          {
            v79 &= *(void *)&v74 - 1;
          }
          *(void *)(*((void *)v34 + 3) + 8 * v79)  = v34 + 40;
          uint64_t v84 = (void *)*v78;
          if (*v78)
          {
            do
            {
              unint64_t v85 = v84[1];
              if (v80.u32[0] > 1uLL)
              {
                if (v85 >= *(void *)&v74) {
                  v85 %= *(void *)&v74;
                }
              }
              else
              {
                v85 &= *(void *)&v74 - 1;
              }
              if (v85 != v79)
              {
                uint64_t v86 = *((void *)v34 + 3);
                if (!*(void *)(v86 + 8 * v85))
                {
                  *(void *)(v86 + 8 * v85)  = v78;
                  goto LABEL_189;
                }
                *uint64_t v78 = *v84;
                *uint64_t v84 = **(void **)(*((void *)v34 + 3) + 8 * v85);
                **(void **)(*((void *)v34 + 3) + 8 * v85)  = v84;
                uint64_t v84 = v78;
              }
              unint64_t v85 = v79;
LABEL_189:
              uint64_t v78 = v84;
              uint64_t v84 = (void *)*v84;
              unint64_t v79 = v85;
            }
            while (v84);
          }
        }
        unint64_t v57 = (unint64_t)v74;
        goto LABEL_193;
      }
LABEL_238:
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    if (*(void *)&v74 < v57)
    {
      unint64_t v81 = vcvtps_u32_f32((float)*((unint64_t *)v34 + 6) / *((float *)v34 + 14));
      if (v57 < 3 || (uint8x8_t v82 = (uint8x8_t)vcnt_s8((int8x8_t)v57), v82.i16[0] = vaddlv_u8(v82), v82.u32[0] > 1uLL))
      {
        unint64_t v81 = std::__next_prime(v81);
      }
      else
      {
        uint64_t v83 = 1 << -(char)__clz(v81 - 1);
        if (v81 >= 2) {
          unint64_t v81 = v83;
        }
      }
      if (*(void *)&v74 <= v81) {
        int8x8_t v74 = (int8x8_t)v81;
      }
      if (*(void *)&v74 >= v57)
      {
        unint64_t v57 = *((void *)v34 + 4);
      }
      else
      {
        if (v74) {
          goto LABEL_164;
        }
        int64x2_t v106 = (void *)*((void *)v34 + 3);
        *((void *)v34 + 3)  = 0;
        if (v106) {
          operator delete(v106);
        }
        unint64_t v57 = 0;
        *((void *)v34 + 4)  = 0;
      }
    }
LABEL_193:
    if ((v57 & (v57 - 1)) != 0)
    {
      if (v57 <= v6) {
        unint64_t v60 = v6 % v57;
      }
      else {
        unint64_t v60 = v6;
      }
    }
    else
    {
      unint64_t v60 = (v57 - 1) & v6;
    }
    goto LABEL_198;
  }
  while (1)
  {
    unint64_t v64 = v63[1];
    if (v64 == v6) {
      break;
    }
    if (v58.u32[0] > 1uLL)
    {
      if (v64 >= v57) {
        v64 %= v57;
      }
    }
    else
    {
      v64 &= v57 - 1;
    }
    if (v64 != v59) {
      goto LABEL_137;
    }
LABEL_136:
    unint64_t v63 = (uint64_t *)*v63;
    if (!v63) {
      goto LABEL_137;
    }
  }
  if (*((_DWORD *)v63 + 4) != v6) {
    goto LABEL_136;
  }
  uint64_t v98 = v63[3];
  if (v98 == v7) {
    return 1;
  }
  unsigned int v99 = *(unsigned __int16 *)(v98 + 2);
  if (v99 != *(unsigned __int16 *)(v7 + 2)) {
    goto LABEL_217;
  }
  if (!*(_WORD *)(v98 + 2)) {
    return 1;
  }
  unint64_t v100 = (unsigned __int16 *)(v98 + 4);
  uint64_t v101 = __rev16(v99);
  size_t v102 = (unsigned __int16 *)(v7 + 4);
  uint64_t v103 = 2 * v101;
  uint64_t v97 = 1;
  while (*v100 == *v102)
  {
    ++v100;
    ++v102;
    v103 -= 2;
    if (!v103) {
      return v97;
    }
  }
LABEL_217:
  **(unsigned char **)(a1 + 16)  = 0;
  uint64_t v97 = 1;
  *a4  = 1;
  return v97;
}

void *std::__hash_table<std::__hash_value_type<OTL::LangSysTable const*,unsigned int>,std::__unordered_map_hasher<OTL::LangSysTable const*,std::__hash_value_type<OTL::LangSysTable const*,unsigned int>,std::hash<OTL::LangSysTable const*>,std::equal_to<OTL::LangSysTable const*>,true>,std::__unordered_map_equal<OTL::LangSysTable const*,std::__hash_value_type<OTL::LangSysTable const*,unsigned int>,std::equal_to<OTL::LangSysTable const*>,std::hash<OTL::LangSysTable const*>,true>,std::allocator<std::__hash_value_type<OTL::LangSysTable const*,unsigned int>>>::__emplace_unique_key_args<OTL::LangSysTable const*,std::piecewise_construct_t const&,std::tuple<OTL::LangSysTable const* const&>,std::tuple<>>(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v5 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  unint64_t v6 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v5 >> 47) ^ v5);
  unint64_t v7 = 0x9DDFEA08EB382D69 * (v6 ^ (v6 >> 47));
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0]  = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v10 = 0x9DDFEA08EB382D69 * (v6 ^ (v6 >> 47));
      if (v7 >= v8) {
        unint64_t v10 = v7 % v8;
      }
    }
    else
    {
      unint64_t v10 = (v8 - 1) & v7;
    }
    uint64_t v11 = *(void ***)(*(void *)a1 + 8 * v10);
    if (v11)
    {
      unint64_t v12 = *v11;
      if (*v11)
      {
        do
        {
          unint64_t v13 = v12[1];
          if (v13 == v7)
          {
            if (v12[2] == a2) {
              return v12;
            }
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v13 >= v8) {
                v13 %= v8;
              }
            }
            else
            {
              v13 &= v8 - 1;
            }
            if (v13 != v10) {
              break;
            }
          }
          unint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
    }
  }
  else
  {
    unint64_t v10 = 0xAAAAAAAAAAAAAAAALL;
  }
  unint64_t v12 = operator new(0x20uLL);
  void *v12 = 0;
  v12[1]  = v7;
  v12[2]  = *a3;
  *((_DWORD *)v12 + 6)  = 0;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (!v8 || (float)(v15 * (float)v8) < v14)
  {
    BOOL v16 = 1;
    if (v8 >= 3) {
      BOOL v16 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v8);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t v19 = v18;
    }
    else {
      size_t v19 = v17;
    }
    std::__hash_table<std::__hash_value_type<TRun const*,long>,std::__unordered_map_hasher<TRun const*,std::__hash_value_type<TRun const*,long>,std::hash<TRun const*>,std::equal_to<TRun const*>,true>,std::__unordered_map_equal<TRun const*,std::__hash_value_type<TRun const*,long>,std::equal_to<TRun const*>,std::hash<TRun const*>,true>,std::allocator<std::__hash_value_type<TRun const*,long>>>::__rehash<true>(a1, v19);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        unint64_t v10 = v7 % v8;
      }
      else {
        unint64_t v10 = v7;
      }
    }
    else
    {
      unint64_t v10 = (v8 - 1) & v7;
    }
  }
  uint64_t v20 = *(void *)a1;
  BOOL v21 = *(void **)(*(void *)a1 + 8 * v10);
  if (v21)
  {
    void *v12 = *v21;
LABEL_38:
    void *v21 = v12;
    goto LABEL_39;
  }
  void *v12 = *(void *)(a1 + 16);
  *(void *)(a1 + 16)  = v12;
  *(void *)(v20 + 8 * v10)  = a1 + 16;
  if (*v12)
  {
    unint64_t v22 = *(void *)(*v12 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v22 >= v8) {
        v22 %= v8;
      }
    }
    else
    {
      v22 &= v8 - 1;
    }
    BOOL v21 = (void *)(*(void *)a1 + 8 * v22);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v12;
}

void std::__function::__func<BuildFeaturesMap(OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_3::operator() const(unsigned int,OTL::FeatureTable const*,BOOL &)::{lambda(unsigned short,BOOL &)#1},std::allocator<BuildFeaturesMap(OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_3::operator() const(unsigned int,OTL::FeatureTable const*,BOOL &)::{lambda(unsigned short,BOOL &)#1}>,BOOL ()(unsigned short,BOOL &)>::~__func()
{
}

__n128 std::__function::__func<BuildFeaturesMap(OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_3::operator() const(unsigned int,OTL::FeatureTable const*,BOOL &)::{lambda(unsigned short,BOOL &)#1},std::allocator<BuildFeaturesMap(OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_3::operator() const(unsigned int,OTL::FeatureTable const*,BOOL &)::{lambda(unsigned short,BOOL &)#1}>,BOOL ()(unsigned short,BOOL &)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x40uLL);
  *(void *)uint64_t v2 = &unk_1ED062000;
  *(_OWORD *)(v2 + 8)  = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24)  = *(_OWORD *)(a1 + 24);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40)  = result;
  *((void *)v2 + 7)  = *(void *)(a1 + 56);
  return result;
}

__n128 std::__function::__func<BuildFeaturesMap(OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_3::operator() const(unsigned int,OTL::FeatureTable const*,BOOL &)::{lambda(unsigned short,BOOL &)#1},std::allocator<BuildFeaturesMap(OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_3::operator() const(unsigned int,OTL::FeatureTable const*,BOOL &)::{lambda(unsigned short,BOOL &)#1}>,BOOL ()(unsigned short,BOOL &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2  = &unk_1ED062000;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  long long v4 = *(_OWORD *)(a1 + 40);
  *(void *)(a2 + 56)  = *(void *)(a1 + 56);
  *(_OWORD *)(a2 + 40)  = v4;
  *(_OWORD *)(a2 + 24)  = v3;
  *(__n128 *)(a2 + 8)  = result;
  return result;
}

uint64_t std::__function::__func<BuildFeaturesMap(OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_3::operator() const(unsigned int,OTL::FeatureTable const*,BOOL &)::{lambda(unsigned short,BOOL &)#1},std::allocator<BuildFeaturesMap(OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_3::operator() const(unsigned int,OTL::FeatureTable const*,BOOL &)::{lambda(unsigned short,BOOL &)#1}>,BOOL ()(unsigned short,BOOL &)>::operator()(uint64_t a1, unsigned __int16 *a2)
{
  unsigned int v3 = *a2;
  int v4 = *((_DWORD *)std::__hash_table<std::__hash_value_type<OTL::LangSysTable const*,unsigned int>,std::__unordered_map_hasher<OTL::LangSysTable const*,std::__hash_value_type<OTL::LangSysTable const*,unsigned int>,std::hash<OTL::LangSysTable const*>,std::equal_to<OTL::LangSysTable const*>,true>,std::__unordered_map_equal<OTL::LangSysTable const*,std::__hash_value_type<OTL::LangSysTable const*,unsigned int>,std::equal_to<OTL::LangSysTable const*>,std::hash<OTL::LangSysTable const*>,true>,std::allocator<std::__hash_value_type<OTL::LangSysTable const*,unsigned int>>>::__emplace_unique_key_args<OTL::LangSysTable const*,std::piecewise_construct_t const&,std::tuple<OTL::LangSysTable const* const&>,std::tuple<>>(*(void *)(a1 + 8), *(void *)(*(void *)(a1 + 16) + 8), (void *)(*(void *)(a1 + 16) + 8))+ 6);
  int v77 = v4;
  uint64_t v5 = *(void *)(a1 + 24);
  uint64_t v8 = *(void *)(v5 + 88);
  uint64_t v6 = v5 + 88;
  uint64_t v7 = v8;
  if (!v8) {
    goto LABEL_12;
  }
  uint64_t v9 = v6;
  do
  {
    unsigned int v10 = *(_DWORD *)(v7 + 32);
    BOOL v11 = v10 >= v3;
    if (v10 >= v3) {
      unint64_t v12 = (uint64_t *)v7;
    }
    else {
      unint64_t v12 = (uint64_t *)(v7 + 8);
    }
    if (v11) {
      uint64_t v9 = v7;
    }
    uint64_t v7 = *v12;
  }
  while (*v12);
  if (v9 != v6 && *(_DWORD *)(v9 + 32) <= v3)
  {
    std::__tree<unsigned int>::__emplace_unique_key_args<unsigned int,unsigned int const&>((uint64_t *)(v9 + 40), **(_DWORD **)(a1 + 32), **(_DWORD **)(a1 + 32));
  }
  else
  {
LABEL_12:
    unint64_t v13 = (uint64_t *)(v6 - 8);
    unsigned int v14 = **(_DWORD **)(a1 + 32);
    __n[1]  = 0;
    *(void *)&long long v71 = 0;
    __n[0]  = (size_t)&__n[1];
    std::__tree<unsigned int>::__emplace_hint_unique_key_args<unsigned int,unsigned int const&>((uint64_t *)__n, (uint64_t *)&__n[1], v14, v14);
    unsigned int v73 = v3;
    *((void *)&v74 + 1)  = 0;
    *(void *)&long long v75 = 0;
    *(void *)&long long v74 = (char *)&v74 + 8;
    std::set<unsigned int>::insert[abi:nn180100]<std::__tree_const_iterator<unsigned int,std::__tree_node<unsigned int,void *> *,long>>((uint64_t *)&v74, (void *)__n[0], &__n[1]);
    std::__tree<std::__value_type<unsigned int,std::set<unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::set<unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::set<unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int const,std::set<unsigned int>>>(v13, v73, (uint64_t)&v73);
    std::__tree<std::__value_type<long,TGlyphDeltaListEntry>,std::__map_value_compare<long,std::__value_type<long,TGlyphDeltaListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TGlyphDeltaListEntry>>>::destroy(*((void **)&v74 + 1));
    std::__tree<std::__value_type<long,TGlyphDeltaListEntry>,std::__map_value_compare<long,std::__value_type<long,TGlyphDeltaListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TGlyphDeltaListEntry>>>::destroy((void *)__n[1]);
  }
  uint64_t v15 = *(void *)(a1 + 24);
  uint64_t v16 = *(void *)(v15 + 112);
  if (!v16) {
    goto LABEL_24;
  }
  uint64_t v17 = v15 + 112;
  do
  {
    unsigned int v18 = *(_DWORD *)(v16 + 32);
    BOOL v19 = v18 >= v3;
    if (v18 >= v3) {
      uint64_t v20 = (uint64_t *)v16;
    }
    else {
      uint64_t v20 = (uint64_t *)(v16 + 8);
    }
    if (v19) {
      uint64_t v17 = v16;
    }
    uint64_t v16 = *v20;
  }
  while (*v20);
  if (v17 == v15 + 112 || *(_DWORD *)(v17 + 32) > v3)
  {
LABEL_24:
    int v21 = 0;
    if (v4 > 1751215720)
    {
      if (v4 > 1801547360)
      {
        if (v4 != 1818326126)
        {
          int v22 = 1801547361;
LABEL_36:
          if (v4 == v22) {
            goto LABEL_37;
          }
LABEL_38:
          unsigned int v73 = v3;
          *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>(v15 + 40, v3, &v73)+ 5)  = v21;
          uint64_t v23 = *(void *)(a1 + 24);
          __n[1]  = 0;
          *(void *)&long long v71 = 0;
          __n[0]  = (size_t)&__n[1];
          std::__tree<unsigned int>::__emplace_hint_unique_key_args<unsigned int,unsigned int const&>((uint64_t *)__n, (uint64_t *)&__n[1], v4, v4);
          unsigned int v73 = v3;
          *(void *)&long long v75 = 0;
          long long v74 = (unint64_t)&v74 + 8;
          std::set<unsigned int>::insert[abi:nn180100]<std::__tree_const_iterator<unsigned int,std::__tree_node<unsigned int,void *> *,long>>((uint64_t *)&v74, (void *)__n[0], &__n[1]);
          std::__tree<std::__value_type<unsigned int,std::set<unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::set<unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::set<unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int const,std::set<unsigned int>>>((uint64_t *)(v23 + 104), v73, (uint64_t)&v73);
          std::__tree<std::__value_type<long,TGlyphDeltaListEntry>,std::__map_value_compare<long,std::__value_type<long,TGlyphDeltaListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TGlyphDeltaListEntry>>>::destroy(*((void **)&v74 + 1));
          std::__tree<std::__value_type<long,TGlyphDeltaListEntry>,std::__map_value_compare<long,std::__value_type<long,TGlyphDeltaListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TGlyphDeltaListEntry>>>::destroy((void *)__n[1]);
          goto LABEL_39;
        }
      }
      else if (v4 != 1751215721)
      {
        if (v4 != 1751474802) {
          goto LABEL_38;
        }
        goto LABEL_31;
      }
    }
    else
    {
      if (v4 <= 1668903531)
      {
        if (v4 != 1634885986)
        {
          int v22 = 1667786098;
          goto LABEL_36;
        }
LABEL_31:
        int v21 = -1;
        goto LABEL_38;
      }
      if (v4 != 1668903532)
      {
        int v22 = 1735550315;
        goto LABEL_36;
      }
    }
LABEL_37:
    int v21 = 1;
    goto LABEL_38;
  }
  int v55 = 0;
  char v56 = 1;
  if (v4 <= 1751215720)
  {
    if (v4 <= 1668903531)
    {
      if (v4 != 1634885986)
      {
        int v57 = 1667786098;
        goto LABEL_144;
      }
LABEL_98:
      char v56 = 0;
      int v55 = -1;
      goto LABEL_146;
    }
    if (v4 != 1668903532)
    {
      int v57 = 1735550315;
      goto LABEL_144;
    }
LABEL_145:
    char v56 = 0;
    int v55 = 1;
    goto LABEL_146;
  }
  if (v4 <= 1801547360)
  {
    if (v4 != 1751215721)
    {
      if (v4 != 1751474802) {
        goto LABEL_146;
      }
      goto LABEL_98;
    }
    goto LABEL_145;
  }
  if (v4 == 1818326126) {
    goto LABEL_145;
  }
  int v57 = 1801547361;
LABEL_144:
  if (v4 == v57) {
    goto LABEL_145;
  }
LABEL_146:
  unsigned int v73 = v3;
  int v66 = *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>(v15 + 40, v3, &v73)+ 5);
  if (v66)
  {
    if (v55 == v66) {
      char v67 = 1;
    }
    else {
      char v67 = v56;
    }
    if ((v67 & 1) == 0)
    {
      **(unsigned char **)(a1 + 48)  = 0;
      **(unsigned char **)(a1 + 56)  = 1;
      return 1;
    }
  }
  else
  {
    uint64_t v68 = *(void *)(a1 + 24) + 40;
    unsigned int v73 = v3;
    *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>(v68, v3, &v73)+ 5)  = v55;
  }
  std::__tree<unsigned int>::__emplace_unique_key_args<unsigned int,unsigned int const&>((uint64_t *)(v17 + 40), v4, v4);
LABEL_39:
  uint64_t v25 = *(uint64_t **)(a1 + 24);
  size_t v24 = *(unsigned int **)(a1 + 32);
  unsigned int v69 = v3;
  *(_OWORD *)unint64_t __n = 0u;
  long long v71 = 0u;
  int v72 = 1065353216;
  std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>((uint64_t)__n, &v69, &v69);
  unsigned int v73 = *v24;
  long long v74 = 0u;
  long long v75 = 0u;
  int v76 = v72;
  std::__hash_table<std::__hash_value_type<unsigned int,OTL::Lookup>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,OTL::Lookup>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,OTL::Lookup>>>::__rehash<true>((uint64_t)&v74, __n[1]);
  for (unint64_t i = (unsigned int *)v71; i; unint64_t i = *(unsigned int **)i)
    std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>((uint64_t)&v74, i + 4, i + 4);
  unint64_t v27 = v73;
  unint64_t v28 = v25[1];
  if (v28)
  {
    uint8x8_t v29 = (uint8x8_t)vcnt_s8((int8x8_t)v28);
    v29.i16[0]  = vaddlv_u8(v29);
    if (v29.u32[0] > 1uLL)
    {
      unint64_t v30 = v73;
      if (v28 <= v73) {
        unint64_t v30 = v73 % v28;
      }
    }
    else
    {
      unint64_t v30 = (v28 - 1) & v73;
    }
    uint8x8_t v31 = *(uint64_t ***)(*v25 + 8 * v30);
    if (v31)
    {
      for (CFIndex j = *v31; j; CFIndex j = (uint64_t *)*j)
      {
        unint64_t v33 = j[1];
        if (v33 == v73)
        {
          if (*((_DWORD *)j + 4) == v73) {
            goto LABEL_129;
          }
        }
        else
        {
          if (v29.u32[0] > 1uLL)
          {
            if (v33 >= v28) {
              v33 %= v28;
            }
          }
          else
          {
            v33 &= v28 - 1;
          }
          if (v33 != v30) {
            break;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v30 = 0xAAAAAAAAAAAAAAAALL;
  }
  unint64_t v34 = v25 + 2;
  unint64_t v35 = (char *)operator new(0x40uLL);
  float v36 = v35;
  *(void *)unint64_t v35 = 0;
  *((void *)v35 + 1)  = v27;
  *((_DWORD *)v35 + 4)  = v27;
  long long v37 = v74;
  long long v74 = 0uLL;
  *(_OWORD *)(v35 + 24)  = v37;
  long long v38 = v75;
  *(_OWORD *)(v35 + 40)  = v75;
  *((_DWORD *)v35 + 14)  = v76;
  if (*((void *)&v38 + 1))
  {
    unint64_t v39 = *(void *)(v38 + 8);
    if ((*((void *)&v37 + 1) & (*((void *)&v37 + 1) - 1)) != 0)
    {
      if (v39 >= *((void *)&v37 + 1)) {
        v39 %= *((void *)&v37 + 1);
      }
    }
    else
    {
      v39 &= *((void *)&v37 + 1) - 1;
    }
    *(void *)(v37 + 8 * v39)  = v35 + 40;
    long long v75 = 0uLL;
  }
  float v40 = (float)(unint64_t)(v25[3] + 1);
  float v41 = *((float *)v25 + 8);
  if (!v28 || (float)(v41 * (float)v28) < v40)
  {
    BOOL v42 = 1;
    if (v28 >= 3) {
      BOOL v42 = (v28 & (v28 - 1)) != 0;
    }
    unint64_t v43 = v42 | (2 * v28);
    unint64_t v44 = vcvtps_u32_f32(v40 / v41);
    if (v43 <= v44) {
      int8x8_t prime = (int8x8_t)v44;
    }
    else {
      int8x8_t prime = (int8x8_t)v43;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    }
    unint64_t v28 = v25[1];
    if (*(void *)&prime > v28) {
      goto LABEL_76;
    }
    if (*(void *)&prime < v28)
    {
      unint64_t v52 = vcvtps_u32_f32((float)(unint64_t)v25[3] / *((float *)v25 + 8));
      if (v28 < 3 || (uint8x8_t v53 = (uint8x8_t)vcnt_s8((int8x8_t)v28), v53.i16[0] = vaddlv_u8(v53), v53.u32[0] > 1uLL))
      {
        unint64_t v52 = std::__next_prime(v52);
      }
      else
      {
        uint64_t v54 = 1 << -(char)__clz(v52 - 1);
        if (v52 >= 2) {
          unint64_t v52 = v54;
        }
      }
      if (*(void *)&prime <= v52) {
        int8x8_t prime = (int8x8_t)v52;
      }
      if (*(void *)&prime >= v28)
      {
        unint64_t v28 = v25[1];
      }
      else
      {
        if (prime)
        {
LABEL_76:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          int v46 = operator new(8 * *(void *)&prime);
          unint64_t v47 = (void *)*v25;
          *uint64_t v25 = (uint64_t)v46;
          if (v47) {
            operator delete(v47);
          }
          uint64_t v48 = 0;
          v25[1]  = (uint64_t)prime;
          do
            *(void *)(*v25 + 8 * v48++)  = 0;
          while (*(void *)&prime != v48);
          unint64_t v49 = (void *)*v34;
          if (*v34)
          {
            unint64_t v50 = v49[1];
            uint8x8_t v51 = (uint8x8_t)vcnt_s8(prime);
            v51.i16[0]  = vaddlv_u8(v51);
            if (v51.u32[0] > 1uLL)
            {
              if (v50 >= *(void *)&prime) {
                v50 %= *(void *)&prime;
              }
            }
            else
            {
              v50 &= *(void *)&prime - 1;
            }
            *(void *)(*v25 + 8 * v50)  = v34;
            uint8x8_t v58 = (void *)*v49;
            if (*v49)
            {
              do
              {
                unint64_t v59 = v58[1];
                if (v51.u32[0] > 1uLL)
                {
                  if (v59 >= *(void *)&prime) {
                    v59 %= *(void *)&prime;
                  }
                }
                else
                {
                  v59 &= *(void *)&prime - 1;
                }
                if (v59 != v50)
                {
                  if (!*(void *)(*v25 + 8 * v59))
                  {
                    *(void *)(*v25 + 8 * v59)  = v49;
                    goto LABEL_110;
                  }
                  void *v49 = *v58;
                  void *v58 = **(void **)(*v25 + 8 * v59);
                  **(void **)(*v25 + 8 * v59)  = v58;
                  uint8x8_t v58 = v49;
                }
                unint64_t v59 = v50;
LABEL_110:
                unint64_t v49 = v58;
                uint8x8_t v58 = (void *)*v58;
                unint64_t v50 = v59;
              }
              while (v58);
            }
          }
          unint64_t v28 = (unint64_t)prime;
          goto LABEL_114;
        }
        int64x2_t v65 = (void *)*v25;
        *uint64_t v25 = 0;
        if (v65) {
          operator delete(v65);
        }
        unint64_t v28 = 0;
        v25[1]  = 0;
      }
    }
LABEL_114:
    if ((v28 & (v28 - 1)) != 0)
    {
      if (v28 <= v27) {
        unint64_t v30 = v27 % v28;
      }
      else {
        unint64_t v30 = v27;
      }
    }
    else
    {
      unint64_t v30 = (v28 - 1) & v27;
    }
  }
  uint64_t v60 = *v25;
  uint64_t v61 = *(void **)(*v25 + 8 * v30);
  if (v61)
  {
    *(void *)float v36 = *v61;
  }
  else
  {
    *(void *)float v36 = *v34;
    *unint64_t v34 = v36;
    *(void *)(v60 + 8 * v30)  = v34;
    if (!*(void *)v36) {
      goto LABEL_128;
    }
    unint64_t v62 = *(void *)(*(void *)v36 + 8);
    if ((v28 & (v28 - 1)) != 0)
    {
      if (v62 >= v28) {
        v62 %= v28;
      }
    }
    else
    {
      v62 &= v28 - 1;
    }
    uint64_t v61 = (void *)(*v25 + 8 * v62);
  }
  void *v61 = v36;
LABEL_128:
  ++v25[3];
LABEL_129:
  std::__hash_table<EncoderAttempt,std::hash<EncoderAttempt>,std::equal_to<EncoderAttempt>,std::allocator<EncoderAttempt>>::~__hash_table((uint64_t)&v74);
  std::__hash_table<EncoderAttempt,std::hash<EncoderAttempt>,std::equal_to<EncoderAttempt>,std::allocator<EncoderAttempt>>::~__hash_table((uint64_t)__n);
  unint64_t v63 = std::__tree<std::__value_type<unsigned int,std::unordered_set<unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::unordered_set<unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::unordered_set<unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t **)(*(void *)(a1 + 24) + 128), **(_DWORD **)(a1 + 32), *(_DWORD **)(a1 + 32));
  std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>((uint64_t)(v63 + 5), (unsigned int *)&v77, &v77);
  return 1;
}

uint64_t *std::__tree<std::__value_type<unsigned int,std::set<unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::set<unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::set<unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int const,std::set<unsigned int>>>(uint64_t *result, unsigned int a2, uint64_t a3)
{
  int v4 = result;
  uint64_t v6 = (uint64_t **)(result + 1);
  uint64_t v5 = result[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (void *)v5;
        unsigned int v8 = *(_DWORD *)(v5 + 32);
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        uint64_t v6 = (uint64_t **)v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        uint64_t v6 = (uint64_t **)(v7 + 1);
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = result + 1;
LABEL_9:
    uint64_t v9 = (uint64_t *)operator new(0x40uLL);
    unsigned int v10 = v9;
    *((_DWORD *)v9 + 8)  = *(_DWORD *)a3;
    BOOL v11 = (void *)(a3 + 16);
    uint64_t v12 = *(void *)(a3 + 16);
    void v9[5] = *(void *)(a3 + 8);
    v9[6]  = v12;
    unint64_t v13 = (char *)(v9 + 6);
    uint64_t v14 = *(void *)(a3 + 24);
    v9[7]  = v14;
    if (v14)
    {
      *(void *)(v12 + 16)  = v13;
      *(void *)(a3 + 8)  = v11;
      void *v11 = 0;
      *(void *)(a3 + 24)  = 0;
    }
    else
    {
      void v9[5] = (uint64_t)v13;
    }
    uint64_t *v9 = 0;
    v9[1]  = 0;
    v9[2]  = (uint64_t)v7;
    *uint64_t v6 = v9;
    uint64_t v15 = *(void *)*v4;
    if (v15)
    {
      *int v4 = v15;
      unsigned int v10 = *v6;
    }
    __n128 result = std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>((uint64_t *)v4[1], v10);
    ++v4[2];
  }
  return result;
}

uint64_t *std::__tree<unsigned int>::__emplace_hint_unique_key_args<unsigned int,unsigned int const&>(uint64_t *result, uint64_t *a2, unsigned int a3, int a4)
{
  uint64_t v5 = (uint64_t **)a2;
  uint64_t v6 = (uint64_t **)result;
  uint64_t v7 = (uint64_t **)(result + 1);
  if (result + 1 == a2 || (unsigned int v8 = *((_DWORD *)a2 + 7), v8 > a3))
  {
    uint64_t v9 = (uint64_t *)*a2;
    if ((uint64_t *)*result == a2)
    {
      BOOL v11 = a2;
LABEL_16:
      if (v9) {
        uint64_t v17 = (uint64_t **)v11;
      }
      else {
        uint64_t v17 = (uint64_t **)a2;
      }
      if (v9) {
        unint64_t v13 = (uint64_t **)(v11 + 1);
      }
      else {
        unint64_t v13 = (uint64_t **)a2;
      }
      if (*v13) {
        return result;
      }
      uint64_t v5 = v17;
LABEL_43:
      uint64_t v23 = (uint64_t *)operator new(0x20uLL);
      *((_DWORD *)v23 + 7)  = a4;
      return std::__tree<std::__value_type<long,TAATDeltaYListEntry>,std::__map_value_compare<long,std::__value_type<long,TAATDeltaYListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TAATDeltaYListEntry>>>::__insert_node_at(v6, (uint64_t)v5, v13, v23);
    }
    if (v9)
    {
      unsigned int v10 = (uint64_t *)*a2;
      do
      {
        BOOL v11 = v10;
        unsigned int v10 = (uint64_t *)v10[1];
      }
      while (v10);
    }
    else
    {
      uint64_t v15 = a2;
      do
      {
        BOOL v11 = (uint64_t *)v15[2];
        BOOL v16 = *v11 == (void)v15;
        uint64_t v15 = v11;
      }
      while (v16);
    }
    if (*((_DWORD *)v11 + 7) < a3) {
      goto LABEL_16;
    }
    unsigned int v18 = *v7;
    unint64_t v13 = (uint64_t **)(result + 1);
    uint64_t v5 = (uint64_t **)(result + 1);
    if (!*v7) {
      goto LABEL_43;
    }
    while (1)
    {
      while (1)
      {
        uint64_t v5 = (uint64_t **)v18;
        unsigned int v19 = *((_DWORD *)v18 + 7);
        if (v19 <= a3) {
          break;
        }
        unsigned int v18 = (uint64_t *)*v18;
        unint64_t v13 = v5;
        if (!*v5) {
          goto LABEL_43;
        }
      }
      if (v19 >= a3) {
        break;
      }
      unsigned int v18 = (uint64_t *)v18[1];
      if (!v18) {
        goto LABEL_30;
      }
    }
  }
  else
  {
    if (v8 >= a3) {
      return result;
    }
    unint64_t v13 = (uint64_t **)(a2 + 1);
    uint64_t v12 = (uint64_t *)a2[1];
    if (v12)
    {
      do
      {
        unint64_t v13 = (uint64_t **)v12;
        uint64_t v12 = (uint64_t *)*v12;
        uint64_t v5 = v13;
        uint64_t v14 = v13;
      }
      while (v12);
    }
    else
    {
      uint64_t v14 = (uint64_t **)a2;
      do
      {
        uint64_t v20 = (uint64_t *)v14;
        uint64_t v14 = (uint64_t **)v14[2];
      }
      while (*v14 != v20);
    }
    if (v14 == v7) {
      goto LABEL_43;
    }
    if (*((_DWORD *)v14 + 7) > a3) {
      goto LABEL_43;
    }
    int v21 = *v7;
    unint64_t v13 = (uint64_t **)(result + 1);
    uint64_t v5 = (uint64_t **)(result + 1);
    if (!*v7) {
      goto LABEL_43;
    }
    while (1)
    {
      while (1)
      {
        uint64_t v5 = (uint64_t **)v21;
        unsigned int v22 = *((_DWORD *)v21 + 7);
        if (v22 <= a3) {
          break;
        }
        int v21 = (uint64_t *)*v21;
        unint64_t v13 = v5;
        if (!*v5) {
          goto LABEL_43;
        }
      }
      if (v22 >= a3) {
        break;
      }
      int v21 = (uint64_t *)v21[1];
      if (!v21)
      {
LABEL_30:
        unint64_t v13 = v5 + 1;
        goto LABEL_43;
      }
    }
  }
  return result;
}

uint64_t *std::set<unsigned int>::insert[abi:nn180100]<std::__tree_const_iterator<unsigned int,std::__tree_node<unsigned int,void *> *,long>>(uint64_t *result, void *a2, void *a3)
{
  if (a2 != a3)
  {
    int v4 = a2;
    uint64_t v5 = result;
    uint64_t v6 = result + 1;
    do
    {
      __n128 result = std::__tree<unsigned int>::__emplace_hint_unique_key_args<unsigned int,unsigned int const&>(v5, v6, *((_DWORD *)v4 + 7), *((_DWORD *)v4 + 7));
      uint64_t v7 = (void *)v4[1];
      if (v7)
      {
        do
        {
          unsigned int v8 = v7;
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          unsigned int v8 = (void *)v4[2];
          BOOL v9 = *v8 == (void)v4;
          int v4 = v8;
        }
        while (!v9);
      }
      int v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *std::__tree<unsigned int>::__emplace_unique_key_args<unsigned int,unsigned int const&>(uint64_t *result, unsigned int a2, int a3)
{
  int v4 = (uint64_t **)result;
  uint64_t v6 = (uint64_t **)(result + 1);
  uint64_t v5 = (uint64_t *)result[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (uint64_t **)v5;
        unsigned int v8 = *((_DWORD *)v5 + 7);
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        uint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        uint64_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = (uint64_t **)(result + 1);
LABEL_9:
    BOOL v9 = (uint64_t *)operator new(0x20uLL);
    *((_DWORD *)v9 + 7)  = a3;
    return std::__tree<std::__value_type<long,TAATDeltaYListEntry>,std::__map_value_compare<long,std::__value_type<long,TAATDeltaYListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TAATDeltaYListEntry>>>::__insert_node_at(v4, (uint64_t)v7, v6, v9);
  }
  return result;
}

void *std::__hash_table<std::__hash_value_type<unsigned int,int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v5 = a2;
  unint64_t v6 = *(void *)(a1 + 8);
  if (v6)
  {
    uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0]  = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      unint64_t v8 = a2;
      if (v6 <= a2) {
        unint64_t v8 = a2 % v6;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & a2;
    }
    BOOL v9 = *(void ***)(*(void *)a1 + 8 * v8);
    if (v9)
    {
      unsigned int v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v7.u32[0] > 1uLL)
            {
              if (v11 >= v6) {
                v11 %= v6;
              }
            }
            else
            {
              v11 &= v6 - 1;
            }
            if (v11 != v8) {
              break;
            }
          }
          unsigned int v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  else
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAAALL;
  }
  unsigned int v10 = operator new(0x18uLL);
  *unsigned int v10 = 0;
  v10[1]  = v5;
  *((_DWORD *)v10 + 4)  = *a3;
  *((_DWORD *)v10 + 5)  = 0;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v13 = *(float *)(a1 + 32);
  if (!v6 || (float)(v13 * (float)v6) < v12)
  {
    BOOL v14 = 1;
    if (v6 >= 3) {
      BOOL v14 = (v6 & (v6 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v6);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<std::__hash_value_type<TRun const*,long>,std::__unordered_map_hasher<TRun const*,std::__hash_value_type<TRun const*,long>,std::hash<TRun const*>,std::equal_to<TRun const*>,true>,std::__unordered_map_equal<TRun const*,std::__hash_value_type<TRun const*,long>,std::equal_to<TRun const*>,std::hash<TRun const*>,true>,std::allocator<std::__hash_value_type<TRun const*,long>>>::__rehash<true>(a1, v17);
    unint64_t v6 = *(void *)(a1 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v6 <= v5) {
        unint64_t v8 = v5 % v6;
      }
      else {
        unint64_t v8 = v5;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & v5;
    }
  }
  uint64_t v18 = *(void *)a1;
  unsigned int v19 = *(void **)(*(void *)a1 + 8 * v8);
  if (v19)
  {
    *unsigned int v10 = *v19;
LABEL_38:
    void *v19 = v10;
    goto LABEL_39;
  }
  *unsigned int v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16)  = v10;
  *(void *)(v18 + 8 * v8)  = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v20 >= v6) {
        v20 %= v6;
      }
    }
    else
    {
      v20 &= v6 - 1;
    }
    unsigned int v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v10;
}

uint64_t **std::__tree<std::__value_type<unsigned int,std::unordered_set<unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::unordered_set<unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::unordered_set<unsigned int>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(uint64_t **a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v6 = a1 + 1;
  unint64_t v5 = a1[1];
  uint8x8_t v7 = a1 + 1;
  unint64_t v8 = a1 + 1;
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v8 = (uint64_t **)v5;
        unsigned int v9 = *((_DWORD *)v5 + 8);
        if (v9 <= a2) {
          break;
        }
        unint64_t v5 = *v8;
        uint8x8_t v7 = v8;
        if (!*v8) {
          goto LABEL_8;
        }
      }
      if (v9 >= a2) {
        break;
      }
      unint64_t v5 = v8[1];
      if (!v5)
      {
        uint8x8_t v7 = v8 + 1;
        goto LABEL_8;
      }
    }
  }
  else
  {
LABEL_8:
    v12[2]  = 0xAAAAAAAAAAAAAA01;
    unsigned int v10 = (char *)operator new(0x50uLL);
    v12[1]  = v6;
    *((_DWORD *)v10 + 8)  = *a3;
    *(_OWORD *)(v10 + 40)  = 0u;
    *(_OWORD *)(v10 + 56)  = 0u;
    *((_DWORD *)v10 + 18)  = 1065353216;
    std::__tree<std::__value_type<long,TAATDeltaYListEntry>,std::__map_value_compare<long,std::__value_type<long,TAATDeltaYListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TAATDeltaYListEntry>>>::__insert_node_at(a1, (uint64_t)v8, v7, (uint64_t *)v10);
    v12[0]  = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<unsigned int,std::unordered_set<unsigned int>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<unsigned int,std::unordered_set<unsigned int>>,void *>>>>::reset[abi:nn180100]((uint64_t)v12);
    return (uint64_t **)v10;
  }
  return v8;
}

void std::unique_ptr<std::__tree_node<std::__value_type<unsigned int,std::unordered_set<unsigned int>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<unsigned int,std::unordered_set<unsigned int>>,void *>>>>::reset[abi:nn180100](uint64_t a1)
{
  CFIndex v1 = *(void **)a1;
  *(void *)a1  = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__hash_table<EncoderAttempt,std::hash<EncoderAttempt>,std::equal_to<EncoderAttempt>,std::allocator<EncoderAttempt>>::~__hash_table((uint64_t)v1 + 40);
    }
    operator delete(v1);
  }
}

uint64_t *std::unique_ptr<anonymous namespace'::ArabicLookups>::reset[abi:nn180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  *__n128 result = a2;
  if (v2)
  {
    unsigned int v9 = (void **)(v2 + 1472);
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100](&v9);
    unsigned int v3 = *(void **)v2;
    if (*(void *)v2)
    {
      uint64_t v4 = *(void *)(v2 + 8);
      unint64_t v5 = *(void **)v2;
      if ((void *)v4 != v3)
      {
        do
        {
          v4 -= 48;
          std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100](v4);
        }
        while ((void *)v4 != v3);
        unint64_t v5 = *(void **)v2;
      }
      *(void *)(v2 + 8)  = v3;
      unint64_t v6 = (void *)(v2 + 1464);
      if (v2 + 24 <= (unint64_t)v5)
      {
        BOOL v7 = v6 >= v5;
        BOOL v8 = v6 == v5;
      }
      else
      {
        BOOL v7 = 0;
        BOOL v8 = 0;
      }
      if (!v8 && v7)
      {
        if (*(void *)(v2 + 16) == *(void *)(v2 + 1464)) {
          *unint64_t v6 = v5;
        }
      }
      else
      {
        operator delete(v5);
      }
    }
    return (uint64_t *)MEMORY[0x1853275C0](v2, 0x1070C40A52D4504);
  }
  return result;
}

void std::vector<anonymous namespace'::LookupInfo,TInlineBufferAllocator<anonymous namespace'::LookupInfo,30ul>>::push_back[abi:nn180100](char **a1, long long *a2)
{
  unint64_t v5 = (unint64_t)a1[1];
  unint64_t v4 = (unint64_t)a1[2];
  if (v5 >= v4)
  {
    unsigned int v9 = (char *)(a1 + 3);
    unint64_t v10 = 0x8E38E38E38E38E39 * ((uint64_t)(v5 - (void)*a1) >> 3);
    if (v10 + 1 > 0x38E38E38E38E38ELL) {
      abort();
    }
    unint64_t v11 = 0x8E38E38E38E38E39 * ((uint64_t)(v4 - (void)*a1) >> 3);
    uint64_t v12 = 2 * v11;
    if (2 * v11 <= v10 + 1) {
      uint64_t v12 = v10 + 1;
    }
    if (v11 >= 0x1C71C71C71C71C7) {
      unint64_t v13 = 0x38E38E38E38E38ELL;
    }
    else {
      unint64_t v13 = v12;
    }
    if (v13)
    {
      BOOL v14 = a1[273];
      unint64_t v15 = (unint64_t)&v14[72 * v13];
      if (v15 <= (unint64_t)(a1 + 273))
      {
        a1[273]  = (char *)v15;
      }
      else
      {
        if (v13 > 0x38E38E38E38E38ELL) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        BOOL v14 = (char *)operator new(72 * v13);
      }
    }
    else
    {
      BOOL v14 = 0;
    }
    unint64_t v16 = &v14[72 * v10];
    long long v17 = *a2;
    long long v18 = a2[2];
    *((_OWORD *)v16 + 1)  = a2[1];
    *((_OWORD *)v16 + 2)  = v18;
    unsigned int v19 = &v14[72 * v13];
    *(_OWORD *)unint64_t v16 = v17;
    std::vector<unsigned short>::vector((void *)v16 + 6, (uint64_t)(a2 + 3));
    BOOL v8 = v16 + 72;
    unint64_t v20 = *a1;
    int v21 = a1[1];
    if (v21 == *a1)
    {
      *a1  = v16;
      a1[1]  = v8;
      uint64_t v25 = a1[2];
      a1[2]  = v19;
    }
    else
    {
      do
      {
        long long v22 = *(_OWORD *)(v21 - 72);
        long long v23 = *(_OWORD *)(v21 - 56);
        *(_OWORD *)(v16 - 40)  = *(_OWORD *)(v21 - 40);
        *(_OWORD *)(v16 - 56)  = v23;
        *(_OWORD *)(v16 - 72)  = v22;
        *((void *)v16 - 2)  = 0;
        *((void *)v16 - 1)  = 0;
        *((void *)v16 - 3)  = 0;
        *(_OWORD *)(v16 - 24)  = *(_OWORD *)(v21 - 24);
        *((void *)v16 - 1)  = *((void *)v21 - 1);
        v16 -= 72;
        *((void *)v21 - 3)  = 0;
        *((void *)v21 - 2)  = 0;
        *((void *)v21 - 1)  = 0;
        v21 -= 72;
      }
      while (v21 != v20);
      int v21 = *a1;
      size_t v24 = a1[1];
      *a1  = v16;
      a1[1]  = v8;
      uint64_t v25 = a1[2];
      a1[2]  = v19;
      while (v24 != v21)
      {
        unint64_t v26 = (void *)*((void *)v24 - 3);
        if (v26)
        {
          *((void *)v24 - 2)  = v26;
          operator delete(v26);
        }
        v24 -= 72;
      }
    }
    if (v21)
    {
      if (v9 > v21 || (unint64_t v27 = a1 + 273, a1 + 273 <= (char **)v21))
      {
        operator delete(v21);
      }
      else if (v25 == *v27)
      {
        *unint64_t v27 = v21;
      }
    }
  }
  else
  {
    long long v6 = *a2;
    long long v7 = a2[2];
    *(_OWORD *)(v5 + 16)  = a2[1];
    *(_OWORD *)(v5 + 32)  = v7;
    *(_OWORD *)unint64_t v5 = v6;
    std::vector<unsigned short>::vector((void *)(v5 + 48), (uint64_t)(a2 + 3));
    BOOL v8 = (char *)(v5 + 72);
  }
  a1[1]  = v8;
}

BOOL IsAccessWithinRange<OTL::LookupTable>(unint64_t a1, unint64_t a2, unint64_t a3)
{
  if (a1 + 4 < a2 || a1 + 6 > a3) {
    return 0;
  }
  BOOL result = 0;
  if (a2 <= a1)
  {
    unint64_t v6 = a1
       + 2 * (bswap32(*(unsigned __int16 *)(a1 + 4)) >> 16)
       + (((unint64_t)*(unsigned __int16 *)(a1 + 2) >> 11) & 2)
       + 6;
    if (v6 >= a1) {
      return v6 <= a3;
    }
  }
  return result;
}

uint64_t ResolveLookupSubtable(unsigned __int16 *a1, unint64_t a2, void *a3)
{
  unint64_t v3 = (unint64_t)&a1[__rev16(a1[2]) + 3];
  if ((unint64_t)(a1 + 4) <= a2) {
    unsigned int v4 = (a2 - (a1 + 6)) >> 1;
  }
  else {
    unsigned int v4 = 0;
  }
  unsigned int v5 = bswap32(v4) >> 16;
  if (v3 < (unint64_t)(a1 + 3) || v3 > a2) {
    unsigned int v7 = v5;
  }
  else {
    unsigned int v7 = a1[2];
  }
  if (a3) {
    *a3  = __rev16(v7);
  }
  return ResolveLookupSubtableWithIndex(a1, 0, a2);
}

uint64_t ResolveLookupSubtableWithIndex(unsigned __int16 *a1, unint64_t a2, unint64_t a3)
{
  unint64_t v3 = bswap32(a1[2]) >> 16;
  unint64_t v4 = (unint64_t)&a1[v3 + 3];
  if ((unint64_t)(a1 + 4) <= a3) {
    unint64_t v5 = (unsigned __int16)((unint64_t)(a3 - (a1 + 6)) >> 1);
  }
  else {
    unint64_t v5 = 0;
  }
  if (v4 < (unint64_t)(a1 + 3) || v4 > a3) {
    unint64_t v7 = v5;
  }
  else {
    unint64_t v7 = v3;
  }
  if (v7 <= a2) {
    return 0;
  }
  BOOL v8 = (char *)a1 + (bswap32(a1[a2 + 3]) >> 16);
  if ((unint64_t)(v8 + 2) > a3) {
    return 0;
  }
  unsigned int v9 = *a1;
  if (v9 != 1792) {
    return __rev16(v9);
  }
  if (*(_WORD *)v8 != 256 || (unint64_t)(v8 + 8) > a3) {
    return 0;
  }
  unsigned int v11 = *((unsigned __int16 *)v8 + 1);
  unsigned int v12 = 7;
  if (v11 != 1792)
  {
    unsigned int v13 = __rev16(v11);
    if ((unint64_t)&v8[bswap32(*((_DWORD *)v8 + 1)) + 2] <= a3) {
      return v13;
    }
    else {
      return 7;
    }
  }
  return v12;
}

__n128 *std::stable_partition[abi:nn180100]<std::__wrap_iter<anonymous namespace'::LookupInfo *>,anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_3>(__n128 *a1, __n128 *a2)
{
  uint64_t v2 = a1;
  if (a1 != a2)
  {
    uint64_t v3 = (uint64_t)a2;
    for (uint64_t i = (uint64_t)a1; ; i += 72)
    {
      unsigned __int32 v5 = v2->n128_u32[0];
      BOOL v6 = v2->n128_u32[0] == 1667329140 || v5 == 1919118452;
      if (!v6 && v5 != 1919707495) {
        break;
      }
      uint64_t v2 = (__n128 *)((char *)v2 + 72);
      if (v2 == a2) {
        return a2;
      }
    }
    unsigned int v9 = (__n128 *)((char *)a2 - 72);
    uint64_t v10 = (uint64_t)a2 - i;
    while (v2 != v9)
    {
      unsigned __int32 v12 = v9->n128_u32[0];
      unsigned int v9 = (__n128 *)((char *)v9 - 72);
      unsigned __int32 v11 = v12;
      v3 -= 72;
      v10 -= 72;
      if (v12 == 1667329140 || v11 == 1919707495 || v11 == 1919118452)
      {
        uint64_t v15 = 0x8E38E38E38E38E39 * (v10 >> 3) + 1;
        if (v10 < 145)
        {
          unint64_t v16 = 0;
          uint64_t v18 = 0;
        }
        else
        {
                                                                                         * (v10 >> 3) + 1);
          uint64_t v18 = v17;
        }
        if (v16) {
          operator delete(v16);
        }
        return v2;
      }
    }
  }
  return v2;
}

void std::stable_partition[abi:nn180100]<std::__wrap_iter<anonymous namespace'::LookupInfo *>,anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_6>(int *a1, int *a2)
{
  if (a1 != a2)
  {
    uint64_t v2 = (uint64_t)a2;
    uint64_t v3 = (uint64_t)a1;
    unint64_t v4 = a1;
    while (*v4 == 1919707495)
    {
      v4 += 18;
      v3 += 72;
      if (v4 == a2) {
        return;
      }
    }
    unsigned __int32 v5 = a2 - 18;
    uint64_t v6 = (uint64_t)a2 - v3;
    while (v4 != v5)
    {
      int v7 = *v5;
      v5 -= 18;
      v2 -= 72;
      v6 -= 72;
      if (v7 == 1919707495)
      {
        uint64_t v8 = 0x8E38E38E38E38E39 * (v6 >> 3) + 1;
        if (v6 < 145)
        {
          unsigned int v9 = 0;
          uint64_t v11 = 0;
        }
        else
        {
                                                                                        * (v6 >> 3) + 1);
          uint64_t v11 = v10;
        }
        if (v9)
        {
          operator delete(v9);
        }
        return;
      }
    }
  }
}

BOOL anonymous namespace'::MorxSwashSubtableBuilder::FromLookupSubtable(atomic_ullong *a1, unint64_t a2, int a3, int a4, int a5, unsigned __int16 *a6, unint64_t a7, uint64_t a8, __int16 a9)
{
  v31[4]  = *MEMORY[0x1E4F143B8];
  MutableBytePtr  = CFDataGetMutableBytePtr((CFMutableDataRef)atomic_load_explicit(a1 + 1, memory_order_acquire));
  memset(v30, 170, sizeof(v30));
  std::vector<unsigned short>::vector(v30, a8);
  int v15 = a5;
  __dst  = 0;
  uint64_t v28 = 0;
  long long __p = 0;
  unint64_t v16 = v30[0];
  int64_t v17 = (char *)v30[1] - (char *)v30[0];
  if (v30[1] == v30[0])
  {
    unsigned int v19 = 0;
  }
  else
  {
    std::vector<unsigned short>::__vallocate[abi:nn180100](&__p, v17 >> 1);
    uint64_t v18 = (char *)__dst;
    memmove(__dst, v16, v17);
    unsigned int v19 = &v18[v17];
    __dst  = &v18[v17];
    int64_t v17 = (int64_t)__p;
  }
  unint64_t v20 = operator new(0x20uLL);
  *unint64_t v20 = &unk_1ED060AE8;
  v20[1]  = 0;
  v20[2]  = 0;
  v20[3]  = 0;
  int64_t v21 = (int64_t)&v19[-v17];
  if (v19 != (char *)v17)
  {
    std::vector<unsigned short>::__vallocate[abi:nn180100](v20 + 1, v21 >> 1);
    long long v22 = (char *)v20[2];
    memmove(v22, (const void *)v17, v21);
    v20[2]  = &v22[v21];
  }
  v31[3]  = v20;
  CreateSingleSubstitutionLookupTable((atomic_ullong *)&v29, a2, v15, a6, a7, (uint64_t)MutableBytePtr, (uint64_t)v31, a9);

  std::__function::__value_func<BOOL ()(unsigned short)>::~__value_func[abi:nn180100](v31);
  if (__p)
  {
    __dst  = __p;
    operator delete(__p);
  }
  unint64_t explicit = atomic_load_explicit(a1 + 2, memory_order_acquire);
  if (v30[0])
  {
    v30[1]  = v30[0];
    operator delete(v30[0]);
  }
  return explicit != 0;
}

uint64_t std::vector<TCFRef<__CFData *>,TInlineBufferAllocator<TCFRef<__CFData *>,30ul>>::emplace_back<TCFRef<__CFData const*>>(uint64_t result, atomic_ullong *a2)
{
  uint64_t v3 = (atomic_ullong **)result;
  unsigned __int32 v5 = *(void **)(result + 8);
  unint64_t v4 = *(void *)(result + 16);
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = result + 24;
    uint64_t v8 = v5 - *v3;
    if ((unint64_t)(v8 + 1) >> 61) {
      abort();
    }
    uint64_t v9 = v4 - (void)*v3;
    uint64_t v10 = v9 >> 2;
    if (v9 >> 2 <= (unint64_t)(v8 + 1)) {
      uint64_t v10 = v8 + 1;
    }
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    int64_t v21 = v3 + 3;
    if (v11) {
      unsigned __int32 v12 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate(v7, v11);
    }
    else {
      unsigned __int32 v12 = 0;
    }
    uint64_t v18 = v12;
    v19.i64[0]  = (uint64_t)&v12[8 * v8];
    v19.i64[1]  = v19.i64[0];
    unint64_t v20 = (atomic_ullong *)&v12[8 * v11];
    *(void *)v19.i64[0]  = atomic_exchange(a2, 0);
    unsigned int v13 = (atomic_ullong *)v19.i64[0];
    uint64_t v6 = v19.i64[1] + 8;
    v19.i64[1] += 8;
    int v15 = *v3;
    BOOL v14 = v3[1];
    if (v14 == *v3)
    {
      int64x2_t v16 = vdupq_n_s64((unint64_t)v14);
    }
    else
    {
      do
        *--unsigned int v13 = atomic_exchange(--v14, 0);
      while (v14 != v15);
      int64x2_t v16 = *(int64x2_t *)v3;
      uint64_t v6 = v19.i64[1];
    }
    *uint64_t v3 = v13;
    v3[1]  = (atomic_ullong *)v6;
    int64x2_t v19 = v16;
    int64_t v17 = v3[2];
    v3[2]  = v20;
    unint64_t v20 = v17;
    uint64_t v18 = (char *)v16.i64[0];
    BOOL result = std::__split_buffer<TCFRef<__CFData *>,TInlineBufferAllocator<TCFRef<__CFData *>,30ul> &>::~__split_buffer((uint64_t)&v18);
  }
  else
  {
    *unsigned __int32 v5 = atomic_exchange(a2, 0);
    uint64_t v6 = (uint64_t)(v5 + 1);
  }
  v3[1]  = (atomic_ullong *)v6;
  return result;
}

void anonymous namespace'::MorxSwashSubtableBuilder::CreateSubtableData(_anonymous_namespace_::MorxSwashSubtableBuilder *this, uint64_t a2)
{
  id v7 = (id)0xAAAAAAAAAAAAAAAALL;
  unint64_t v4 = (atomic_ullong *)(a2 + 16);
  int Length = CFDataGetLength((CFDataRef)atomic_load_explicit((atomic_ullong *volatile)(a2 + 16), memory_order_acquire));
  *(void *)this  = atomic_exchange((atomic_ullong *volatile)&v7, 0);
}

void *AddPrevLigaturesFromSingleSubstitutionLookupTable(uint64_t a1, CFDataRef theData)
{
  v13[4]  = *MEMORY[0x1E4F143B8];
  if (!theData)
  {
    BytePtr  = 0;
    goto LABEL_5;
  }
  BytePtr  = (const SFNTLookupTable *)CFDataGetBytePtr(theData);
  unsigned __int32 v5 = CFDataGetBytePtr(theData);
  if (!v5)
  {
LABEL_5:
    CFDataRef v6 = 0;
    goto LABEL_6;
  }
  CFDataRef v6 = (SFNTLookupTable *)&v5[CFDataGetLength(theData)];
LABEL_6:
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  long long v10 = v7;
  long long v11 = 0xAAAAAAAAAAAAAAAALL;
  v9[0]  = TAATLookupTable::BadTable;
  v9[1]  = 0;
  unint64_t v12 = 0xAAAAAAAAAAAAFFFFLL;
  TAATLookupTable::SetTable((uint64_t)v9, BytePtr, v6);
  v13[0]  = &unk_1ED060788;
  v13[1]  = a1;
  v13[3]  = v13;
  TAATLookupTable::Iterate((uint64_t)v9, (uint64_t)v13);
  return std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100](v13);
}

void anonymous namespace'::MorxInsertionSubtableBuilder::~MorxInsertionSubtableBuilder(_anonymous_namespace_::MorxInsertionSubtableBuilder *this)
{
  *(void *)this  = &unk_1ED05F8D8;
  uint64_t v2 = (void **)((char *)this + 408);
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100](&v2);
}

{
  uint64_t v2;
  void **v3;

  *(void *)this  = &unk_1ED05F8D8;
  uint64_t v3 = (void **)((char *)this + 408);
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100](&v3);
  MEMORY[0x1853275C0](v2, 0x10F1C40126EF00FLL);
}

uint64_t std::vector<anonymous namespace'::LigInput,TInlineBufferAllocator<anonymous namespace'::LigInput,30ul>>::push_back[abi:nn180100](uint64_t *a1, uint64_t a2)
{
  unint64_t v5 = a1[1];
  unint64_t v4 = a1[2];
  if (v5 >= v4)
  {
    uint64_t v8 = (uint64_t)(a1 + 3);
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 4);
    if (v9 + 1 > 0x555555555555555) {
      abort();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v4 - *a1) >> 4);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= v9 + 1) {
      uint64_t v11 = v9 + 1;
    }
    if (v10 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v12 = 0x555555555555555;
    }
    else {
      unint64_t v12 = v11;
    }
    uint64_t v28 = a1 + 3;
    if (v12)
    {
      uint64_t v15 = v14;
    }
    else
    {
      unsigned int v13 = 0;
      uint64_t v15 = 0;
    }
    uint64_t v16 = (uint64_t)&v13[48 * v9];
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>(v16, *(unsigned char **)a2, *(unsigned char **)(a2 + 8));
    *(_WORD *)(v16 + 40)  = *(_WORD *)(a2 + 40);
    uint64_t v18 = *a1;
    unint64_t v17 = a1[1];
    if (v17 == *a1)
    {
      int64x2_t v23 = vdupq_n_s64(v17);
      uint64_t v19 = v16;
    }
    else
    {
      uint64_t v19 = v16;
      do
      {
        uint64_t v20 = v19;
        int64_t v21 = *(unsigned char **)(v17 - 48);
        long long v22 = *(unsigned char **)(v17 - 40);
        v17 -= 48;
        uint64_t v19 = std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>(v19 - 48, v21, v22);
        *(_WORD *)(v20 - 8)  = *(_WORD *)(v17 + 40);
      }
      while (v17 != v18);
      int64x2_t v23 = *(int64x2_t *)a1;
    }
    uint64_t v7 = v16 + 48;
    *a1  = v19;
    a1[1]  = v16 + 48;
    int64x2_t v26 = v23;
    uint64_t v24 = a1[2];
    a1[2]  = (uint64_t)&v13[48 * v15];
    uint64_t v27 = v24;
    uint64_t v25 = v23.i64[0];
  }
  else
  {
    uint64_t result = std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>(a1[1], *(unsigned char **)a2, *(unsigned char **)(a2 + 8));
    *(_WORD *)(v5 + 40)  = *(_WORD *)(a2 + 40);
    uint64_t v7 = v5 + 48;
  }
  a1[1]  = v7;
  return result;
}

uint64_t LigInputsForLigatureSubst(uint64_t a1, OTL::LookupWithCoverage *this, char *a3, void *a4, unsigned __int16 ***a5)
{
  v56[4]  = *MEMORY[0x1E4F143B8];
  uint64_t v54 = a3;
  uint64_t v55 = a1;
  uint8x8_t v53 = this;
  unint64_t v5 = (char *)this + 6;
  if ((char *)this + 6 > a3) {
    return 0;
  }
  uint64_t v6 = bswap32(*((unsigned __int16 *)this + 2)) >> 16;
  unint64_t v7 = (unint64_t)&v5[2 * v6];
  unint64_t v8 = (char *)this + 8 <= a3 ? (unint64_t)(a3 - v5) >> 1 : 0;
  BOOL v9 = v7 <= (unint64_t)a3 && v7 >= (unint64_t)v5;
  if (!v9 && v8 != v6) {
    return 0;
  }
  OTL::LookupWithCoverage::GetCoverage(this, (unint64_t)a3, (uint64_t)v52);
  unsigned int v13 = operator new(0x28uLL);
  *unsigned int v13 = &unk_1ED0605D8;
  v13[1]  = &v53;
  v13[2]  = &v54;
  v13[3]  = &v55;
  v13[4]  = a5;
  v56[3]  = v13;
  int v14 = OTL::Coverage::Iterate(v52, (uint64_t)v56);
  std::__function::__value_func<BOOL ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100](v56);
  if (!v14) {
    return 0;
  }
  if (*a4 != a4[1])
  {
    memset(v52, 170, 24);
    std::vector<unsigned short>::vector(v52, (uint64_t)a4);
    uint64_t v16 = *a5;
    uint64_t v15 = a5[1];
    __dst  = 0;
    uint64_t v51 = 0;
    long long __p = 0;
    unint64_t v17 = v52[0];
    int64_t v18 = (char *)v52[1] - (char *)v52[0];
    if (v52[1] == v52[0])
    {
      uint64_t v20 = 0;
    }
    else
    {
      std::vector<unsigned short>::__vallocate[abi:nn180100](&__p, v18 >> 1);
      uint64_t v19 = (char *)__dst;
      memmove(__dst, v17, v18);
      uint64_t v20 = &v19[v18];
      __dst  = &v19[v18];
    }
    if (v16 != v15)
    {
      long long v22 = v15;
LABEL_21:
      for (uint64_t i = *v16; ; ++i)
      {
        if (i == v16[1])
        {
          v16 += 6;
          if (v16 != v15) {
            goto LABEL_21;
          }
          goto LABEL_52;
        }
        if (v20 != __p)
        {
          unsigned int v24 = *i;
          uint64_t v25 = (char *)__p;
          unint64_t v26 = (v20 - (unsigned char *)__p) >> 1;
          do
          {
            unint64_t v27 = v26 >> 1;
            uint64_t v28 = (unsigned __int16 *)&v25[2 * (v26 >> 1)];
            unsigned int v30 = *v28;
            id v29 = v28 + 1;
            v26 += ~(v26 >> 1);
            if (v30 < v24) {
              uint64_t v25 = (char *)v29;
            }
            else {
              unint64_t v26 = v27;
            }
          }
          while (v26);
          if (v25 != v20 && v24 >= *(unsigned __int16 *)v25) {
            break;
          }
        }
      }
      if (v16 == v15) {
        goto LABEL_52;
      }
      uint8x8_t v31 = v16 + 6;
      if (v16 + 6 != v15)
      {
        long long v22 = v16;
        do
        {
          unint64_t v32 = v31;
          unint64_t v33 = (char *)v16[6];
          uint64_t v34 = (uint64_t)v16[7];
          if (v33 == (char *)v34)
          {
LABEL_48:
            std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)v22, v33, v34, (v34 - (uint64_t)v33) >> 1);
            *((_WORD *)v22 + 20)  = *((_WORD *)v16 + 44);
            v22 += 6;
          }
          else
          {
            unint64_t v35 = v16[6];
            while (1)
            {
              if (__dst != __p)
              {
                unsigned int v36 = *v35;
                long long v37 = (unsigned __int16 *)__p;
                unint64_t v38 = ((unsigned char *)__dst - (unsigned char *)__p) >> 1;
                do
                {
                  unint64_t v39 = v38 >> 1;
                  float v40 = &v37[v38 >> 1];
                  unsigned int v42 = *v40;
                  float v41 = v40 + 1;
                  v38 += ~(v38 >> 1);
                  if (v42 < v36) {
                    long long v37 = v41;
                  }
                  else {
                    unint64_t v38 = v39;
                  }
                }
                while (v38);
                if (v37 != __dst && v36 >= *v37) {
                  break;
                }
              }
              if (++v35 == (unsigned __int16 *)v34) {
                goto LABEL_48;
              }
            }
          }
          uint8x8_t v31 = v32 + 6;
          uint64_t v16 = v32;
        }
        while (v32 + 6 != v15);
        goto LABEL_52;
      }
    }
    long long v22 = v16;
LABEL_52:
    uint64_t v43 = (uint64_t)a5[1];
    if (v22 != (unsigned __int16 **)v43)
    {
      while ((unsigned __int16 **)v43 != v22)
      {
        v43 -= 48;
        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100](v43);
      }
      a5[1]  = v22;
    }
    if (__p)
    {
      __dst  = __p;
      operator delete(__p);
    }
    if (v52[0])
    {
      v52[1]  = v52[0];
      operator delete(v52[0]);
    }
  }
  unint64_t v44 = *a5;
  uint64_t v45 = a5[1];
  unint64_t v46 = 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * (((char *)v45 - (char *)*a5) >> 4));
  if (v45 == *a5) {
    uint64_t v47 = 0;
  }
  else {
    uint64_t v47 = v46;
  }
  uint64_t v21 = 1;
  return v21;
}

void std::vector<std::__wrap_iter<anonymous namespace'::LigInput *>,TInlineBufferAllocator<std::__wrap_iter<anonymous namespace'::LigInput *>,30ul>>::push_back[abi:nn180100](char **a1, void *a2)
{
  unint64_t v5 = a1[1];
  unint64_t v4 = (unint64_t)a1[2];
  if ((unint64_t)v5 >= v4)
  {
    unint64_t v7 = (char *)(a1 + 3);
    uint64_t v8 = (v5 - *a1) >> 3;
    if ((unint64_t)(v8 + 1) >> 61) {
      abort();
    }
    uint64_t v9 = v4 - (void)*a1;
    uint64_t v10 = v9 >> 2;
    if (v9 >> 2 <= (unint64_t)(v8 + 1)) {
      uint64_t v10 = v8 + 1;
    }
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    if (v11)
    {
      unint64_t v12 = a1[33];
      unint64_t v13 = (unint64_t)&v12[8 * v11];
      if (v13 <= (unint64_t)(a1 + 33))
      {
        a1[33]  = (char *)v13;
      }
      else
      {
        if (v11 >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        unint64_t v12 = (char *)operator new(8 * v11);
      }
    }
    else
    {
      unint64_t v12 = 0;
    }
    int v14 = &v12[8 * v8];
    uint64_t v15 = &v12[8 * v11];
    *(void *)int v14 = *a2;
    uint64_t v6 = v14 + 8;
    unint64_t v17 = *a1;
    uint64_t v16 = a1[1];
    if (v16 != *a1)
    {
      do
      {
        uint64_t v18 = *((void *)v16 - 1);
        v16 -= 8;
        *((void *)v14 - 1)  = v18;
        v14 -= 8;
      }
      while (v16 != v17);
      uint64_t v16 = *a1;
    }
    *a1  = v14;
    a1[1]  = v6;
    uint64_t v19 = a1[2];
    a1[2]  = v15;
    if (v16)
    {
      uint64_t v20 = a1 + 33;
      if (v7 <= v16 && v20 > (char **)v16)
      {
        if (v19 == *v20) {
          *uint64_t v20 = v16;
        }
      }
      else
      {
        operator delete(v16);
      }
    }
  }
  else
  {
    *(void *)unint64_t v5 = *a2;
    uint64_t v6 = v5 + 8;
  }
  a1[1]  = v6;
}

uint64_t anonymous namespace'::MorxLigatureSubtableBuilder::FromLigInputs()
{
  uint64_t v0 = MEMORY[0x1F4188790]();
  v421  = v1;
  v422  = v2;
  unint64_t v4 = v3;
  uint64_t v6 = v5;
  int64_t v8 = v7;
  uint64_t v9 = v0;
  v487  = *MEMORY[0x1E4F143B8];
  v415  = v8;
  unint64_t v12 = NewLKTHandle(v8, 1);
  MutableBytePtr  = CFDataGetMutableBytePtr((CFMutableDataRef)atomic_load_explicit((atomic_ullong *volatile)(v9 + 16), memory_order_acquire));
  v420  = v6;
  int v14 = (unsigned __int16 **)*v6;
  uint64_t v15 = (unsigned __int16 **)v6[1];
  unsigned __int16 v16 = 4;
  while (v14 != v15)
  {
    unint64_t v17 = *v14;
    uint64_t v18 = v14[1];
    while (v17 != v18)
    {
      unsigned int v19 = *v17++;
      LKTAddRange(v12, v19, v19, v16++);
    }
    v14 += 3;
  }
  uint64_t v20 = v421;
  for (uint64_t i = v12; v20 != v4; v20 += 6)
  {
    uint64_t v21 = *v20;
    long long v22 = v20[1];
    uint64_t v23 = (uint64_t)(*v20 + 1);
    if (*v20 != v22 && v23 != (void)v22)
    {
      unsigned __int16 v25 = *v21;
      unint64_t v26 = *v20 + 1;
      do
      {
        unsigned int v28 = *v26++;
        unsigned __int16 v27 = v28;
        BOOL v29 = v25 >= v28;
        if (v25 <= v28) {
          unsigned __int16 v25 = v27;
        }
        if (!v29) {
          uint64_t v21 = (unsigned __int16 *)v23;
        }
        uint64_t v23 = (uint64_t)v26;
      }
      while (v26 != v22);
    }
    MutableBytePtr[(unint64_t)*v21 >> 3] |= 1 << (*v21 & 7);
    unsigned int v30 = *v20;
    uint8x8_t v31 = v20[1];
    while (v30 != v31)
    {
      unsigned int v32 = *v30;
      if ((LKTGetValue(v12, v32) & 0xFF0000) == 0)
      {
        LKTAddRange(i, v32, v32, v16++);
        unint64_t v12 = i;
      }
      ++v30;
    }
  }
  unint64_t v33 = *v422;
  uint64_t v34 = v422[1];
  if (*v422 != v34)
  {
    do
    {
      unsigned int v35 = *v33++;
      LKTAddRange(v12, v35, v35, v16);
    }
    while (v33 != v34);
    ++v16;
  }
  *(_DWORD *)(v9 + 24)  = v16;
  LKTCreateLookupTable(v12, (atomic_ullong *)&v476);

  memset(v479, 170, sizeof(v479));
  v478  = 0;
  v476  = 0;
  v477  = 0;
  v480  = v479;
  memset(v475, 170, sizeof(v475));
  long long __p = 0;
  v473  = 0;
  v474  = 0;
  v475[210]  = v475;
  LODWORD(v475[211])  = 0;
  unsigned int v36 = v421;
  if (v4 == v421) {
    goto LABEL_216;
  }
  BOOL v37 = 0;
  uint64_t v38 = 0;
  if ((unint64_t)(((char *)v4 - (char *)v421) / 48) <= 1) {
    uint64_t v39 = 1;
  }
  else {
    uint64_t v39 = ((char *)v4 - (char *)v421) / 48;
  }
  v418  = v39;
  v419  = ((char *)v4 - (char *)v421) / 48;
  while (1)
  {
    v417  = v37;
    v423  = v38;
    v424  = (char **)&v36[6 * v38];
    uint64_t v40 = (v424[1] - *v424) >> 1;
    uint64_t v41 = v40 - 1;
    if (v40 != 1) {
      break;
    }
LABEL_207:
    uint64_t v38 = v423 + 1;
    BOOL v37 = v423 + 1 >= v419;
    unsigned int v36 = v421;
    if (v423 + 1 == v418)
    {
      if (v477 != v476)
      {
        v169  = 0;
        if ((unint64_t)(((char *)v477 - (unsigned char *)v476) / 1760) <= 1) {
          v170  = 1;
        }
        else {
          v170  = ((char *)v477 - (unsigned char *)v476) / 1760;
        }
        do
        {
          long long v171 = (char *)v476 + 1760 * v169;
          uint64_t v172 = *((void *)v171 + 5);
          uint64_t v173 = *((void *)v171 + 6);
          while (v172 != v173)
          {
            *(_WORD *)(v172 + 52)  = GetActionLookupIndex((char **)&__p, v169, *(__int16 *)(v172 + 50), v172 + 8);
            v172 += 56;
          }
          ++v169;
        }
        while (v169 != v170);
      }
      goto LABEL_216;
    }
  }
  uint64_t v42 = 0;
  v428  = &v421[6 * v423 + 5];
  while (1)
  {
    v431  = v42;
    v449  = v40;
    unint64_t v43 = v41;
    unint64_t v44 = *v424;
    uint64_t v45 = (uint64_t)v424[1];
    v458  = *(unsigned __int16 *)&(*v424)[2 * v41];
    unint64_t v46 = (v45 - (uint64_t)*v424) >> 1;
    v469  = 0;
    v470  = 0xAAAAAAAAAAAAAAAALL;
    v467  = 0;
    v468  = 0;
    v471  = &v470;
    v460  = v46;
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)&v467, v44, v45, v46);
    unint64_t v47 = v43;
    uint64_t v48 = v467;
    unint64_t v49 = v468;
    unint64_t v50 = (v468 - v467) >> 1;
    v444  = v47;
    if (v47 <= v50)
    {
      if (v47 < v50)
      {
        unint64_t v49 = &v467[2 * v47];
        v468  = v49;
      }
    }
    else
    {
      unint64_t v51 = v47 - v50;
      if (v47 - v50 <= (v469 - v468) >> 1)
      {
        bzero(v468, 2 * v51);
        v49 += 2 * v51;
        v468  = v49;
      }
      else
      {
        if ((v47 & 0x8000000000000000) != 0) {
          goto LABEL_500;
        }
        if (v469 - v467 <= v47) {
          uint64_t v52 = v47;
        }
        else {
          uint64_t v52 = v469 - v467;
        }
        if ((unint64_t)(v469 - v467) >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v53 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v53 = v52;
        }
        *(void *)&v486[1]  = &v470;
        uint64_t v54 = (char *)TInlineBufferAllocator<unsigned short,3ul>::allocate((uint64_t)&v470, v53);
        char v56 = v467;
        uint64_t v55 = v468;
        bzero(&v54[2 * v50], 2 * v51);
        if (v55 == v56)
        {
          uint8x8_t v58 = &v54[2 * v50];
        }
        else
        {
          int v57 = v55;
          uint8x8_t v58 = &v54[2 * v50];
          do
          {
            __int16 v59 = *((_WORD *)v57 - 1);
            v57 -= 2;
            *((_WORD *)v58 - 1)  = v59;
            v58 -= 2;
          }
          while (v57 != v56);
        }
        v467  = v58;
        v468  = &v54[2 * v50 + 2 * v51];
        uint64_t v60 = v469;
        v469  = &v54[2 * v53];
        *(void *)&v486[0]  = v55;
        *((void *)&v486[0] + 1)  = v60;
        *(void *)&v485  = v56;
        *((void *)&v485 + 1)  = v56;
        std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,3ul> &>::~__split_buffer((uint64_t)&v485);
        uint64_t v48 = v467;
        unint64_t v49 = v468;
      }
    }
    uint64_t v61 = (char *)v476;
    v440  = ((char *)v477 - (unsigned char *)v476) / 1760;
    if (v477 == v476)
    {
      uint64_t v63 = v49 - v48;
LABEL_63:
      memset((char *)v486 + 8, 170, 0x6C8uLL);
      *(void *)&v486[0]  = 0;
      v485  = 0uLL;
      *(void *)&v486[1]  = (char *)v486 + 8;
      v486[2]  = 0uLL;
      *((void *)&v486[1] + 1)  = 0;
      *(void *)&v486[108]  = &v486[3];
      BYTE8(v486[108])  = 0;
      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)&v485, v48, (uint64_t)v49, v63 >> 1);
      v483[0]  = 0xAAAAAAAAAAAAAAAALL;
      v484  = 0xAAAAAAAAAAAAAAAALL;
      v481  = 0xAAAAAAAAAAAAAAAALL;
      v482  = 0uLL;
      v483[1]  = v483;
      LOWORD(v481)  = v458;
      uint64_t v66 = v449;
      if (v449 == v460)
      {
        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)&v481 + 8, v467, (uint64_t)v468, (v468 - v467) >> 1);
        __int16 v67 = *(_WORD *)v428;
        __int16 v68 = -1;
      }
      else
      {
        __int16 v67 = 0;
        __int16 v68 = v431;
      }
      LOWORD(v484)  = v67;
      WORD1(v484)  = v68;
      unsigned int v69 = v477;
      if ((unint64_t)v477 < v478)
      {
        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>((uint64_t)v477, (unsigned char *)v485, *((unsigned char **)&v485 + 1));
        *((unsigned char *)v69 + 1752)  = BYTE8(v486[108]);
        float v70 = v69 + 220;
LABEL_102:
        v477  = v70;
        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v481 + 8);
        uint64_t v91 = *((void *)&v486[1] + 1);
        if (*((void *)&v486[1] + 1))
        {
          uint64_t v92 = *(void *)&v486[2];
          uint64_t v93 = (_OWORD *)*((void *)&v486[1] + 1);
          if (*(void *)&v486[2] != *((void *)&v486[1] + 1))
          {
            do
            {
              uint64_t v94 = v92 - 56;
              std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100](v92 - 48);
              uint64_t v92 = v94;
            }
            while (v94 != v91);
            uint64_t v93 = (_OWORD *)*((void *)&v486[1] + 1);
          }
          *(void *)&v486[2]  = v91;
          if (&v486[3] <= v93 && &v486[108] > v93)
          {
            if (*((void *)&v486[2] + 1) == *(void *)&v486[108]) {
              *(void *)&v486[108]  = v93;
            }
          }
          else
          {
            operator delete(v93);
          }
        }
        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v485);
        uint64_t v42 = v440;
        goto LABEL_114;
      }
      uint64_t v71 = 0x6FB586FB586FB587 * (((char *)v477 - (unsigned char *)v476) >> 5);
      unint64_t v72 = v71 + 1;
      if ((unint64_t)(v71 + 1) > 0x253C8253C8253CLL) {
        goto LABEL_500;
      }
      if (0xDF6B0DF6B0DF6B0ELL * ((uint64_t)(v478 - (void)v476) >> 5) > v72) {
        unint64_t v72 = 0xDF6B0DF6B0DF6B0ELL * ((uint64_t)(v478 - (void)v476) >> 5);
      }
      if ((unint64_t)(0x6FB586FB586FB587 * ((uint64_t)(v478 - (void)v476) >> 5)) >= 0x129E4129E4129ELL) {
        unint64_t v73 = 0x253C8253C8253CLL;
      }
      else {
        unint64_t v73 = v72;
      }
      if (v73)
      {
        long long v74 = v480;
        if (&v480[1760 * v73] <= (char *)&v480)
        {
          v480 += 1760 * v73;
        }
        else
        {
          if (v73 > 0x253C8253C8253CLL) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          long long v74 = (char *)operator new(1760 * v73);
        }
      }
      else
      {
        long long v74 = 0;
      }
      uint64_t v75 = (uint64_t)&v74[1760 * v71];
      int v76 = &v74[1760 * v73];
      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>(v75, (unsigned char *)v485, *((unsigned char **)&v485 + 1));
      *(unsigned char *)(v75 + 1752)  = BYTE8(v486[108]);
      float v70 = (char **)(v75 + 1760);
      int v77 = v477;
      uint64_t v78 = (char *)v476;
      if (v477 == v476)
      {
        v476  = (id)v75;
        v477  = (char **)(v75 + 1760);
        unint64_t v81 = (char *)v478;
        v478  = (unint64_t)v76;
      }
      else
      {
        uint64_t v79 = 0;
        do
        {
          std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>(v75 + v79 * 8 - 1760, v77[v79 - 220], v77[v79 - 219]);
          *(unsigned char *)(v75 + v79 * 8 - 8)  = v77[v79 - 1];
          v79 -= 220;
        }
        while (&v77[v79] != (char **)v78);
        int v77 = (char **)v476;
        uint8x8_t v80 = v477;
        v476  = (id)(v75 + v79 * 8);
        v477  = (char **)(v75 + 1760);
        unint64_t v81 = (char *)v478;
        v478  = (unint64_t)v76;
        if (v80 != v77)
        {
          uint64_t v66 = v449;
          do
          {
            v80 -= 220;
          }
          while (v80 != v77);
LABEL_96:
          if (v77)
          {
            if (v479 > (unsigned char *)v77 || &v480 <= v77)
            {
              operator delete(v77);
            }
            else if (v81 == v480)
            {
              v480  = (char *)v77;
            }
          }
          goto LABEL_102;
        }
      }
      uint64_t v66 = v449;
      goto LABEL_96;
    }
    uint64_t v42 = 0;
    if ((unint64_t)(((char *)v477 - (unsigned char *)v476) / 1760) <= 1) {
      uint64_t v62 = 1;
    }
    else {
      uint64_t v62 = ((char *)v477 - (unsigned char *)v476) / 1760;
    }
    uint64_t v63 = v49 - v48;
    unint64_t v64 = (char *)v476 + 8;
    while (1)
    {
      int64x2_t v65 = (const void *)*(v64 - 1);
      if (*v64 - (void)v65 == v63 && !memcmp(v65, v48, v49 - v48)) {
        break;
      }
      ++v42;
      v64 += 220;
      if (v62 == v42) {
        goto LABEL_63;
      }
    }
    if ((unsigned __int16)v42 == 0xFFFFLL) {
      goto LABEL_63;
    }
    uint64_t v42 = (unsigned __int16)v42;
    uint8x8_t v82 = &v61[1760 * (unsigned __int16)v42];
    uint64_t v84 = (char **)(v82 + 40);
    uint64_t v83 = *((void *)v82 + 5);
    uint64_t v85 = *((void *)v82 + 6);
    uint64_t v86 = v85 - v83;
    if (v85 == v83) {
      goto LABEL_179;
    }
    uint64_t v87 = 0;
    unint64_t v88 = v86 / 56;
    if (v88 <= 1) {
      unint64_t v88 = 1;
    }
    unint64_t v89 = (unsigned __int16 *)*((void *)v82 + 5);
    while (1)
    {
      int v90 = *v89;
      v89 += 28;
      if (v90 == v458) {
        break;
      }
      if (v88 == ++v87) {
        goto LABEL_179;
      }
    }
    if ((unsigned __int16)v87 == 0xFFFFLL)
    {
LABEL_179:
      *(void *)&v486[1]  = 0xAAAAAAAAAAAAAAAALL;
      *(void *)&v486[2]  = 0xAAAAAAAAAAAAAAAALL;
      v485  = 0xAAAAAAAAAAAAAAAALL;
      v486[0]  = 0uLL;
      *((void *)&v486[1] + 1)  = &v486[1];
      LOWORD(v485)  = v458;
      if (v449 == v460)
      {
        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)&v485 + 8, v48, (uint64_t)v49, v63 >> 1);
        __int16 v147 = *(_WORD *)v428;
        __int16 v148 = -1;
      }
      else
      {
        __int16 v147 = 0;
        __int16 v148 = v431;
      }
      LOWORD(v486[2])  = v147;
      WORD1(v486[2])  = v148;
      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v485 + 8);
      uint64_t v66 = v449;
      goto LABEL_114;
    }
    uint64_t v149 = v83 + 56 * (unsigned __int16)v87;
    if (*(void *)(v149 + 8) != *(void *)(v149 + 16))
    {
      v441  = *((void *)v82 + 5);
      v416  = (unsigned __int16)v87;
      uint64_t v150 = v431;
      *(_WORD *)(v83 + 56 * (unsigned __int16)v87 + 50)  = v431;
      v483[0]  = 0xAAAAAAAAAAAAAAAALL;
      *(void *)&long long v151 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v151 + 1)  = 0xAAAAAAAAAAAAAAAALL;
      v482  = v151;
      v481  = v151;
      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>((uint64_t)&v481, *(unsigned char **)v82, *((unsigned char **)v82 + 1));
      uint64_t v152 = *((void *)&v481 + 1);
      if (*((void *)&v481 + 1) < (unint64_t)v482)
      {
        **((_WORD **)&v481 + 1)  = *(_WORD *)v149;
        uint64_t v153 = (_WORD *)(v152 + 2);
        uint64_t v66 = v449;
LABEL_206:
        *((void *)&v481 + 1)  = v153;
        DoSubgroupSubstitutions(&v476, (uint64_t)&v61[1760 * v150], (unsigned __int16 **)&v481, *(unsigned __int16 *)(v441 + 56 * v416 + 48));
        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v481);
LABEL_114:
        if (v66 != v460) {
          goto LABEL_176;
        }
LABEL_115:
        if (v476 == v477) {
          goto LABEL_176;
        }
        v461  = v42;
        uint64_t v96 = 0x6FB586FB586FB587 * (((char *)v477 - (unsigned char *)v476) >> 5);
        uint64_t v97 = v477 - 220;
        while (2)
        {
          uint64_t v98 = v468;
          unint64_t v99 = (v468 - v467) >> 1;
          if (v99 < (v97[1] - *v97) >> 1)
          {
            *(void *)&v482  = 0;
            *((void *)&v482 + 1)  = 0xAAAAAAAAAAAAAAAALL;
            v481  = 0uLL;
            v483[0]  = (char *)&v482 + 8;
            if (v468 == v467)
            {
              __int16 v116 = 0;
              unint64_t v100 = 0;
              int v115 = v468;
            }
            else
            {
              unint64_t v100 = 0;
              uint64_t v101 = v97[1];
              size_t v102 = &v101[-2 * v99];
              do
              {
                if ((unint64_t)v100 >= (unint64_t)v482)
                {
                  uint64_t v103 = (char *)v481;
                  uint64_t v104 = (uint64_t)&v100[-v481];
                  if ((uint64_t)&v100[-v481] <= -3) {
                    goto LABEL_500;
                  }
                  uint64_t v105 = v104 >> 1;
                  if ((void)v482 - (void)v481 <= (unint64_t)((v104 >> 1) + 1)) {
                    uint64_t v106 = v105 + 1;
                  }
                  else {
                    uint64_t v106 = v482 - v481;
                  }
                  if ((void)v482 - (void)v481 >= 0x7FFFFFFFFFFFFFFEuLL) {
                    uint64_t v107 = 0x7FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    uint64_t v107 = v106;
                  }
                  *(void *)&v486[1]  = (char *)&v482 + 8;
                  if (v107)
                  {
                    uint64_t v108 = (char *)TInlineBufferAllocator<unsigned short,3ul>::allocate((uint64_t)&v482 + 8, v107);
                    unint64_t v100 = (char *)*((void *)&v481 + 1);
                    uint64_t v103 = (char *)v481;
                  }
                  else
                  {
                    uint64_t v108 = 0;
                  }
                  uint64_t v109 = &v108[2 * v105];
                  *(_WORD *)uint64_t v109 = *(_WORD *)v102;
                  if (v100 == v103)
                  {
                    CFDictionaryRef v111 = &v108[2 * v105];
                  }
                  else
                  {
                    double v110 = v100;
                    CFDictionaryRef v111 = &v108[2 * v105];
                    do
                    {
                      __int16 v112 = *((_WORD *)v110 - 1);
                      v110 -= 2;
                      *((_WORD *)v111 - 1)  = v112;
                      v111 -= 2;
                    }
                    while (v110 != v103);
                  }
                  int v113 = v109 + 2;
                  *(void *)&v481  = v111;
                  *((void *)&v481 + 1)  = v109 + 2;
                  uint64_t v114 = v482;
                  *(void *)&v482  = &v108[2 * v107];
                  *(void *)&v486[0]  = v100;
                  *((void *)&v486[0] + 1)  = v114;
                  *(void *)&v485  = v103;
                  *((void *)&v485 + 1)  = v103;
                  std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,3ul> &>::~__split_buffer((uint64_t)&v485);
                  unint64_t v100 = v113;
                }
                else
                {
                  *(_WORD *)unint64_t v100 = *(_WORD *)v102;
                  v100 += 2;
                }
                *((void *)&v481 + 1)  = v100;
                v102 += 2;
              }
              while (v102 != v101);
              uint64_t v98 = v467;
              int v115 = v468;
              __int16 v116 = (unsigned char *)v481;
            }
            uint64_t v117 = v115 - v98;
            if (v115 - v98 == v100 - v116 && !memcmp(v98, v116, v115 - v98))
            {
              uint64_t v119 = v97[5];
              int v118 = v97[6];
              uint64_t v120 = v118 - v119;
              if (v118 == v119) {
                goto LABEL_151;
              }
              uint64_t v121 = 0;
              unint64_t v122 = v120 / 56;
              if (v122 <= 1) {
                unint64_t v122 = 1;
              }
              id v123 = v97[5];
              while (1)
              {
                int v124 = *(unsigned __int16 *)v123;
                v123 += 56;
                if (v124 == v458) {
                  break;
                }
                if (v122 == ++v121) {
                  goto LABEL_151;
                }
              }
              if ((unsigned __int16)v121 == 0xFFFFLL)
              {
LABEL_151:
                *(void *)&v486[1]  = 0xAAAAAAAAAAAAAAAALL;
                *(void *)&v486[2]  = 0xAAAAAAAAAAAAAAAALL;
                v485  = 0xAAAAAAAAAAAAAAAALL;
                v486[0]  = 0uLL;
                *((void *)&v486[1] + 1)  = &v486[1];
                LOWORD(v485)  = v458;
                std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)&v485 + 8, v98, (uint64_t)v115, v117 >> 1);
                LOWORD(v486[2])  = *(_WORD *)v428;
                WORD1(v486[2])  = -1;
                id v125 = (char *)&v485 + 8;
                goto LABEL_152;
              }
              atomic_ullong v126 = &v119[56 * (unsigned __int16)v121];
              if (*((void *)v126 + 1) == *((void *)v126 + 2))
              {
                char v127 = v98;
                unsigned int v128 = (unsigned __int16)v121;
                std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>(v126 + 8, v127, (uint64_t)v115, v117 >> 1);
                uint64_t v129 = &v119[56 * v128];
                *((_WORD *)v129 + 24)  = *(_WORD *)v428;
                uint64_t v130 = (unsigned __int16 *)(v129 + 48);
                int v131 = (__int16)v130[1];
                id v132 = v476;
                v466  = (char *)0xAAAAAAAAAAAAAAAALL;
                *(void *)&long long v133 = 0xAAAAAAAAAAAAAAAALL;
                *((void *)&v133 + 1)  = 0xAAAAAAAAAAAAAAAALL;
                v464  = v133;
                v465  = v133;
                std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>((uint64_t)&v464, v467, v468);
                uint64_t v134 = *((void *)&v464 + 1);
                if (*((void *)&v464 + 1) >= (unint64_t)v465)
                {
                  v450  = v132;
                  uint64_t v136 = v464;
                  uint64_t v137 = *((void *)&v464 + 1) - v464;
                  if ((uint64_t)(*((void *)&v464 + 1) - v464) <= -3) {
                    goto LABEL_500;
                  }
                  uint64_t v138 = v137 >> 1;
                  if ((void)v465 - (void)v464 <= (unint64_t)((v137 >> 1) + 1)) {
                    uint64_t v139 = v138 + 1;
                  }
                  else {
                    uint64_t v139 = v465 - v464;
                  }
                  if ((void)v465 - (void)v464 >= 0x7FFFFFFFFFFFFFFEuLL) {
                    uint64_t v140 = 0x7FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    uint64_t v140 = v139;
                  }
                  *(void *)&v486[1]  = (char *)&v465 + 8;
                  if (v140)
                  {
                    long long v141 = (char *)TInlineBufferAllocator<unsigned short,3ul>::allocate((uint64_t)&v465 + 8, v140);
                    uint64_t v134 = *((void *)&v464 + 1);
                    uint64_t v136 = v464;
                  }
                  else
                  {
                    long long v141 = 0;
                  }
                  long long v142 = &v141[2 * v138];
                  *(_WORD *)long long v142 = *(_WORD *)v126;
                  if (v134 == v136)
                  {
                    long long v144 = &v141[2 * v138];
                  }
                  else
                  {
                    uint64_t v143 = v134;
                    long long v144 = &v141[2 * v138];
                    do
                    {
                      __int16 v145 = *(_WORD *)(v143 - 2);
                      v143 -= 2;
                      *((_WORD *)v144 - 1)  = v145;
                      v144 -= 2;
                    }
                    while (v143 != v136);
                  }
                  long long v135 = v142 + 2;
                  *(void *)&v464  = v144;
                  *((void *)&v464 + 1)  = v142 + 2;
                  uint64_t v146 = v465;
                  *(void *)&v465  = &v141[2 * v140];
                  *(void *)&v486[0]  = v134;
                  *((void *)&v486[0] + 1)  = v146;
                  *(void *)&v485  = v136;
                  *((void *)&v485 + 1)  = v136;
                  std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,3ul> &>::~__split_buffer((uint64_t)&v485);
                  id v132 = v450;
                }
                else
                {
                  **((_WORD **)&v464 + 1)  = *(_WORD *)v126;
                  long long v135 = (_WORD *)(v134 + 2);
                }
                *((void *)&v464 + 1)  = v135;
                DoSubgroupSubstitutions(&v476, (uint64_t)v132 + 1760 * v131, (unsigned __int16 **)&v464, *v130);
                id v125 = (char *)&v464;
LABEL_152:
                std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)v125);
              }
            }
            std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v481);
          }
          v97 -= 220;
          if (!--v96)
          {
            uint64_t v42 = v461;
            goto LABEL_176;
          }
          continue;
        }
      }
      uint64_t v158 = v481;
      uint64_t v159 = *((void *)&v481 + 1) - v481;
      uint64_t v66 = v449;
      if ((uint64_t)(*((void *)&v481 + 1) - v481) > -3)
      {
        uint64_t v160 = v159 >> 1;
        if ((void)v482 - (void)v481 <= (unint64_t)((v159 >> 1) + 1)) {
          uint64_t v161 = v160 + 1;
        }
        else {
          uint64_t v161 = v482 - v481;
        }
        if ((void)v482 - (void)v481 >= 0x7FFFFFFFFFFFFFFEuLL) {
          uint64_t v162 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v162 = v161;
        }
        *(void *)&v486[1]  = (char *)&v482 + 8;
        if (v162)
        {
          unint64_t v163 = (char *)TInlineBufferAllocator<unsigned short,3ul>::allocate((uint64_t)&v482 + 8, v162);
          uint64_t v152 = *((void *)&v481 + 1);
          uint64_t v158 = v481;
        }
        else
        {
          unint64_t v163 = 0;
        }
        long long v164 = &v163[2 * v160];
        *(_WORD *)long long v164 = *(_WORD *)v149;
        if (v152 == v158)
        {
          unint64_t v166 = &v163[2 * v160];
          uint64_t v150 = v431;
        }
        else
        {
          uint64_t v165 = v152;
          unint64_t v166 = &v163[2 * v160];
          uint64_t v150 = v431;
          do
          {
            __int16 v167 = *(_WORD *)(v165 - 2);
            v165 -= 2;
            *((_WORD *)v166 - 1)  = v167;
            v166 -= 2;
          }
          while (v165 != v158);
        }
        uint64_t v153 = v164 + 2;
        *(void *)&v481  = v166;
        *((void *)&v481 + 1)  = v164 + 2;
        v168  = v482;
        *(void *)&v482  = &v163[2 * v162];
        *(void *)&v486[0]  = v152;
        *((void *)&v486[0] + 1)  = v168;
        *(void *)&v485  = v158;
        *((void *)&v485 + 1)  = v158;
        std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,3ul> &>::~__split_buffer((uint64_t)&v485);
        goto LABEL_206;
      }
LABEL_500:
      abort();
    }
    if (v449 == v460) {
      break;
    }
LABEL_176:
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v467);
    uint64_t v40 = v444;
    uint64_t v41 = v444 - 1;
    if (v444 == 1) {
      goto LABEL_207;
    }
  }
  uint64_t v154 = v83 + 56 * (unsigned __int16)v87;
  *(_WORD *)(v154 + 48)  = *(_WORD *)v428;
  BOOL v155 = (unsigned __int16 *)(v154 + 48);
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)(v149 + 8), v48, (uint64_t)v49, v63 >> 1);
  if ((__int16)v155[1] != -1)
  {
    uint64_t v156 = (char *)v476 + 1760 * v431;
    *(void *)&v486[1]  = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&v157  = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v157 + 1)  = 0xAAAAAAAAAAAAAAAALL;
    v486[0]  = v157;
    v485  = v157;
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>((uint64_t)&v485, *v424, v424[1]);
    DoSubgroupSubstitutions(&v476, (uint64_t)v156, (unsigned __int16 **)&v485, *v155);
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v485);
    goto LABEL_115;
  }
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v467);
  v404  = i;
  if (v417)
  {
LABEL_216:
    uint64_t v174 = *(unsigned int *)(v9 + 24);
    long long v175 = (char **)(v9 + 136);
    *(void *)&long long v176 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v176 + 1)  = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)((char *)&v486[3] + 8)  = v176;
    *(_OWORD *)((char *)&v486[2] + 8)  = v176;
    *(_OWORD *)((char *)&v486[1] + 8)  = v176;
    *(_OWORD *)((char *)v486 + 8)  = v176;
    *(void *)&v486[0]  = 0;
    v485  = 0uLL;
    *((void *)&v486[4] + 1)  = (char *)v486 + 8;
    v462  = (char **)(v9 + 136);
    if (v174)
    {
      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__vallocate[abi:nn180100](&v485, v174);
      uint64_t v177 = *((void *)&v485 + 1);
      bzero(*((void **)&v485 + 1), 2 * v174);
      uint64_t v178 = v177 + 2 * v174;
      long long v175 = (char **)(v9 + 136);
      *((void *)&v485 + 1)  = v178;
      ActionIndeCGFloat x = GetActionIndex(v462, 0, 0, -1);
      long long v180 = (_WORD *)v485;
      uint64_t v181 = v174;
      do
      {
        *v180++  = ActionIndex;
        --v181;
      }
      while (v181);
    }
    else
    {
      GetActionIndex((char **)(v9 + 136), 0, 0, -1);
    }
    __int16 v182 = GetActionIndex(v175, 0, 0x4000, -1);
    uint64_t v183 = *v420;
    v451  = v420[1];
    v442  = (v451 - *v420) / 24;
    v459  = (char **)(v9 + 40);
    if (v451 != *v420)
    {
      uint64_t v184 = 0;
      uint64_t v185 = (v451 - *v420) / 24;
      if (v442 <= 1) {
        uint64_t v185 = 1;
      }
      v445  = v185;
      while (1)
      {
        uint64_t v186 = *v420;
        if (v184)
        {
          __int16 v187 = GetActionIndex(v175, (unsigned __int16)(v184 + 1), 0, -1);
          uint64_t v188 = v485;
          *(_WORD *)(v485 + 4)  = v187;
          if (*v422 != v422[1]) {
            *(_WORD *)(v188 + 2 * (v174 - 1))  = v187;
          }
          __int16 v189 = v184;
        }
        else
        {
          __int16 v189 = 0;
        }
        v190  = GetActionIndex(v175, (unsigned __int16)(v189 + 2), 0, -1);
        v191  = *(unsigned __int16 **)(v186 + 24 * v184);
        uint64_t v192 = *(unsigned __int16 **)(v186 + 24 * v184 + 8);
        if (v191 != v192) {
          break;
        }
LABEL_234:
        v195  = 1;
        do
        {
          char v196 = v195;
          std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::__wrap_iter<unsigned short *>,std::__wrap_iter<unsigned short *>,std::back_insert_iterator<TInlineVector<unsigned short,30ul>>,0>(v485, (_WORD *)(v485 + 2 * v174), v459);
          if (v184) {
            break;
          }
          v195  = 0;
        }
        while ((v196 & 1) != 0);
        long long v175 = (char **)(v9 + 136);
        if (v174)
        {
          double v197 = (_WORD *)v485;
          uint64_t v198 = v174;
          do
          {
            *v197++  = v182;
            --v198;
          }
          while (v198);
        }
        if (++v184 == v445) {
          goto LABEL_241;
        }
      }
      v193  = v190;
      while (1)
      {
        uint64_t v194 = LKTGetValue(i, *v191);
        if ((v194 & 0xFF0000) == 0) {
          break;
        }
        *(_WORD *)(v485 + 2 * (unsigned __int16)v194)  = v193;
        if (++v191 == v192) {
          goto LABEL_234;
        }
      }
LABEL_477:
      *(void *)&v481  = &v485;
      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v481);
      goto LABEL_479;
    }
LABEL_241:
    if (v477 != v476)
    {
      if ((unint64_t)(((char *)v477 - (unsigned char *)v476) / 1760) <= 1) {
        uint64_t v199 = 1;
      }
      else {
        uint64_t v199 = ((char *)v477 - (unsigned char *)v476) / 1760;
      }
      uint64_t v200 = 1752;
      __int16 v201 = v442;
      do
      {
        id v202 = (char *)v476;
        if (v451 != v183)
        {
          __int16 v203 = GetActionIndex(v175, (unsigned __int16)(v201 + 1), 0, -1);
          uint64_t v204 = v485;
          *(_WORD *)(v485 + 4)  = v203;
          if (*v422 != v422[1]) {
            *(_WORD *)(v204 + 2 * (v174 - 1))  = v203;
          }
        }
        char v205 = &v202[v200];
        unint64_t v206 = &v202[v200 - 1752];
        v207  = *((void *)v205 - 218) - *(void *)v206;
        int v208 = *v205;
        if (v207 == 2 && v208 == 0)
        {
          __int16 v210 = GetActionIndex(v175, (unsigned __int16)(v201 + 2), 0x8000, -1);
          v211  = LKTGetValue(i, **(unsigned __int16 **)v206);
          if ((v211 & 0xFF0000) == 0) {
            goto LABEL_477;
          }
          *(_WORD *)(v485 + 2 * (unsigned __int16)v211)  = v210;
          long long v175 = (char **)(v9 + 136);
        }
        ++v201;
        v200 += 1760;
        --v199;
      }
      while (v199);
    }
    v212  = 1;
    do
    {
      v213  = v212;
      std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::__wrap_iter<unsigned short *>,std::__wrap_iter<unsigned short *>,std::back_insert_iterator<TInlineVector<unsigned short,30ul>>,0>(v485, (_WORD *)(v485 + 2 * v174), v459);
      if (v451 != v183) {
        break;
      }
      v212  = 0;
    }
    while ((v213 & 1) != 0);
    if (v477 == v476)
    {
LABEL_284:
      *(void *)&v481  = &v485;
      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v481);
    }
    else
    {
      BOOL v214 = 0;
      v215  = 0;
      v432  = v174;
      __src  = v174 - 1;
      if ((unint64_t)(((char *)v477 - (unsigned char *)v476) / 1760) <= 1) {
        v216  = 1;
      }
      else {
        v216  = ((char *)v477 - (unsigned char *)v476) / 1760;
      }
      v446  = v216;
      v452  = ((char *)v477 - (unsigned char *)v476) / 1760;
      while (1)
      {
        if (v174)
        {
          v217  = (_WORD *)v485;
          v218  = v174;
          do
          {
            *v217++  = v182;
            --v218;
          }
          while (v218);
        }
        v219  = (char *)v476;
        __int16 v220 = GetActionIndex(v175, (unsigned __int16)(v215 + v442 + 2), 0, -1);
        v221  = v485;
        *(_WORD *)(v485 + 4)  = v220;
        if (*v422 != v422[1]) {
          *(_WORD *)(v221 + 2 * __src)  = v220;
        }
        v222  = &v219[1760 * v215];
        uint64_t v223 = *((void *)v222 + 5);
        uint64_t v224 = *((void *)v222 + 6);
        uint64_t v225 = (uint64_t *)(v222 + 40);
        v226  = v224 - v223;
        if (v226) {
          break;
        }
LABEL_283:
        std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::__wrap_iter<unsigned short *>,std::__wrap_iter<unsigned short *>,std::back_insert_iterator<TInlineVector<unsigned short,30ul>>,0>(v221, (_WORD *)(v221 + 2 * v174), v459);
        BOOL v214 = ++v215 >= v452;
        if (v215 == v446) {
          goto LABEL_284;
        }
      }
      v430  = v214;
      v227  = 0;
      v228  = v226 / 56;
      if (v228 <= 1) {
        uint64_t v229 = 1;
      }
      else {
        uint64_t v229 = v228;
      }
      while (1)
      {
        uint64_t v230 = *v225;
        uint64_t v231 = *v225 + v227;
        int v232 = *(__int16 *)(v231 + 50);
        unsigned __int16 v233 = v232 == -1 ? 0 : v442 + 2 + v232;
        ActionLookupIndeCGFloat x = GetActionLookupIndex((char **)&__p, v215, v232, v231 + 8);
        int v235 = *((__int16 *)__p + 28 * ActionLookupIndex + 24) == -1
             ? -1
             : *((unsigned __int16 *)__p + 28 * ActionLookupIndex + 25);
        __int16 v236 = GetActionIndex(v462, v233, 0x8000, v235);
        uint64_t v237 = LKTGetValue(i, *(unsigned __int16 *)(v230 + v227));
        if ((v237 & 0xFF0000) == 0) {
          break;
        }
        unsigned int v238 = (unsigned __int16)v237;
        v221  = v485;
        *(_WORD *)(v485 + 2 * v238)  = v236;
        v227 += 56;
        if (!--v229)
        {
          uint64_t v174 = v432;
          long long v175 = (char **)(v9 + 136);
          goto LABEL_283;
        }
      }
      *(void *)&v481  = &v485;
      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v481);
      if (!v430)
      {
LABEL_479:
        v404  = i;
        goto LABEL_480;
      }
    }
    DisposeLKTHandle(i);
    if (LOWORD(v475[211]))
    {
      uint64_t v239 = 0;
      v425  = __p;
      *(void *)v426  = v473;
      v443  = v9 + 376;
      v463  = v9 + 528;
      if ((unint64_t)((v473 - (unsigned char *)__p) / 56) <= 1) {
        uint64_t v240 = 1;
      }
      else {
        uint64_t v240 = (v473 - (unsigned char *)__p) / 56;
      }
      v429  = v240;
      while (1)
      {
        *(void *)&v465  = 0;
        *((void *)&v465 + 1)  = 0xAAAAAAAAAAAAAAAALL;
        v464  = 0uLL;
        v466  = (char *)&v465 + 8;
        *((void *)&v486[7] + 1)  = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&long long v241 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v241 + 1)  = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)((char *)&v486[5] + 8)  = v241;
        *(_OWORD *)((char *)&v486[6] + 8)  = v241;
        *(_OWORD *)((char *)&v486[3] + 8)  = v241;
        *(_OWORD *)((char *)&v486[4] + 8)  = v241;
        *(_OWORD *)((char *)&v486[1] + 8)  = v241;
        *(_OWORD *)((char *)&v486[2] + 8)  = v241;
        *(_OWORD *)((char *)v486 + 8)  = v241;
        *(void *)&v486[0]  = 0;
        v485  = 0uLL;
        *(void *)&v486[8]  = (char *)v486 + 8;
        v427  = v239;
        if (*(void **)v426 != v425) {
          break;
        }
        v297  = 0;
        v298  = 0;
        v296  = 0;
        v295  = 0;
LABEL_352:
        v299  = 0;
        v435  = v296;
        __srca  = v295;
        v300  = ((char *)v295 - (char *)v296) >> 2;
        v301  = (uint64_t)(*(void *)(v9 + 512) - *(void *)(v9 + 504)) >> 1;
        v454  = *(void *)(v9 + 608) - *(void *)(v9 + 600);
        v457  = *v296;
        v302  = (v298 - v297) >> 1;
        v448  = v300 - 1;
        if (v300 <= 1) {
          v303  = 1;
        }
        else {
          v303  = v300;
        }
        do
        {
          if (v299)
          {
            v301  = (uint64_t)(*(void *)(v9 + 512) - *(void *)(v9 + 504)) >> 1;
            if (v302 == v299) {
              v304  = (v301 - *(unsigned __int16 *)(v297 + 2 * (v302 - v299))) & 0x3FFFFFFF | 0x80000000;
            }
            else {
              v304  = (v301 - *(unsigned __int16 *)(v297 + 2 * (v302 - v299))) & 0x3FFFFFFF;
            }
            v305  = *(_DWORD **)(v9 + 360);
            v306  = *(void *)(v9 + 368);
            if ((unint64_t)v305 >= v306)
            {
              v312  = *(_DWORD **)(v9 + 352);
              v313  = v305 - v312;
              v314  = v313 + 1;
              if ((unint64_t)(v313 + 1) >> 62) {
                goto LABEL_500;
              }
              v315  = v306 - (void)v312;
              if (v315 >> 1 > v314) {
                v314  = v315 >> 1;
              }
              if ((unint64_t)v315 >= 0x7FFFFFFFFFFFFFFCLL) {
                v316  = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                v316  = v314;
              }
              v483[0]  = v9 + 376;
              if (v316)
              {
                v317  = (char *)TInlineBufferAllocator<unsigned int,30ul>::allocate(v443, v316);
                v312  = *(_DWORD **)(v9 + 352);
                v305  = *(_DWORD **)(v9 + 360);
              }
              else
              {
                v317  = 0;
              }
              v324  = &v317[4 * v313];
              *(_DWORD *)v324  = v304;
              if (v305 == v312)
              {
                v326  = &v317[4 * v313];
              }
              else
              {
                v325  = v305;
                v326  = &v317[4 * v313];
                do
                {
                  v327  = *--v325;
                  *((_DWORD *)v326 - 1)  = v327;
                  v326 -= 4;
                }
                while (v325 != v312);
              }
              v307  = v324 + 4;
              *(void *)(v9 + 352)  = v326;
              *(void *)(v9 + 360)  = v324 + 4;
              v328  = *(void *)(v9 + 368);
              *(void *)(v9 + 368)  = &v317[4 * v316];
              *(void *)&v482  = v305;
              *((void *)&v482 + 1)  = v328;
              *(void *)&v481  = v312;
              *((void *)&v481 + 1)  = v312;
              std::__split_buffer<unsigned int,TInlineBufferAllocator<unsigned int,30ul> &>::~__split_buffer((uint64_t)&v481);
            }
            else
            {
              *v305  = v304;
              v307  = v305 + 1;
            }
            *(void *)(v9 + 360)  = v307;
            if (v302 == v299) {
              v329  = v454 >> 1;
            }
            else {
              v329  = 0;
            }
            v330  = *(char **)(v9 + 512);
            v331  = *(void *)(v9 + 520);
            if ((unint64_t)v330 >= v331)
            {
              v333  = *(char **)(v9 + 504);
              v334  = v330 - v333;
              if (v330 - v333 <= -3) {
                goto LABEL_500;
              }
              v335  = v334 >> 1;
              v336  = v331 - (void)v333;
              if (v336 <= (v334 >> 1) + 1) {
                v337  = v335 + 1;
              }
              else {
                v337  = v336;
              }
              if (v336 >= 0x7FFFFFFFFFFFFFFELL) {
                v338  = 0x7FFFFFFFFFFFFFFFLL;
              }
              else {
                v338  = v337;
              }
              v483[0]  = v9 + 528;
              if (v338)
              {
                v339  = (char *)TInlineBufferAllocator<unsigned short,30ul>::allocate(v463, v338);
                v333  = *(char **)(v9 + 504);
                v330  = *(char **)(v9 + 512);
              }
              else
              {
                v339  = 0;
              }
              v340  = &v339[2 * v335];
              *(_WORD *)v340  = v329;
              if (v330 == v333)
              {
                v342  = &v339[2 * v335];
              }
              else
              {
                v341  = v330;
                v342  = &v339[2 * v335];
                do
                {
                  v343  = *((_WORD *)v341 - 1);
                  v341 -= 2;
                  *((_WORD *)v342 - 1)  = v343;
                  v342 -= 2;
                }
                while (v341 != v333);
              }
              v332  = v340 + 2;
              *(void *)(v9 + 504)  = v342;
              *(void *)(v9 + 512)  = v340 + 2;
              v344  = *(void *)(v9 + 520);
              *(void *)(v9 + 520)  = &v339[2 * v338];
              *(void *)&v482  = v330;
              *((void *)&v482 + 1)  = v344;
              *(void *)&v481  = v333;
              *((void *)&v481 + 1)  = v333;
              std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,30ul> &>::~__split_buffer((uint64_t)&v481);
            }
            else
            {
              *(_WORD *)v330  = v329;
              v332  = v330 + 2;
            }
            *(void *)(v9 + 512)  = v332;
          }
          else
          {
            v308  = (v301 - v457) & 0x3FFFFFFF;
            v309  = *(_DWORD **)(v9 + 360);
            v310  = *(void *)(v9 + 368);
            if ((unint64_t)v309 >= v310)
            {
              v318  = *(_DWORD **)(v9 + 352);
              v319  = v309 - v318;
              v320  = v319 + 1;
              if ((unint64_t)(v319 + 1) >> 62) {
                goto LABEL_500;
              }
              v321  = v310 - (void)v318;
              if (v321 >> 1 > v320) {
                v320  = v321 >> 1;
              }
              if ((unint64_t)v321 >= 0x7FFFFFFFFFFFFFFCLL) {
                v322  = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                v322  = v320;
              }
              v483[0]  = v9 + 376;
              if (v322)
              {
                v323  = (char *)TInlineBufferAllocator<unsigned int,30ul>::allocate(v443, v322);
                v318  = *(_DWORD **)(v9 + 352);
                v309  = *(_DWORD **)(v9 + 360);
              }
              else
              {
                v323  = 0;
              }
              v345  = &v323[4 * v319];
              *(_DWORD *)v345  = v308;
              if (v309 == v318)
              {
                v347  = &v323[4 * v319];
              }
              else
              {
                v346  = v309;
                v347  = &v323[4 * v319];
                do
                {
                  v348  = *--v346;
                  *((_DWORD *)v347 - 1)  = v348;
                  v347 -= 4;
                }
                while (v346 != v318);
              }
              v311  = v345 + 4;
              *(void *)(v9 + 352)  = v347;
              *(void *)(v9 + 360)  = v345 + 4;
              v349  = *(void *)(v9 + 368);
              *(void *)(v9 + 368)  = &v323[4 * v322];
              *(void *)&v482  = v309;
              *((void *)&v482 + 1)  = v349;
              *(void *)&v481  = v318;
              *((void *)&v481 + 1)  = v318;
              std::__split_buffer<unsigned int,TInlineBufferAllocator<unsigned int,30ul> &>::~__split_buffer((uint64_t)&v481);
            }
            else
            {
              *v309  = v308;
              v311  = v309 + 1;
            }
            *(void *)(v9 + 360)  = v311;
            v351  = *(void *)(v9 + 504);
            v350  = *(void *)(v9 + 512);
            v352  = *(unsigned __int16 *)(v485 + 4 * v448) - v457;
            if (v352 >= 0)
            {
              v353  = v352 + 1;
              v354  = *(char **)(v9 + 512);
              do
              {
                v355  = *(void *)(v9 + 520);
                if ((unint64_t)v354 >= v355)
                {
                  v356  = *(char **)(v9 + 504);
                  v357  = v354 - v356;
                  if (v354 - v356 <= -3) {
                    goto LABEL_500;
                  }
                  v358  = v357 >> 1;
                  v359  = v355 - (void)v356;
                  if (v359 <= (v357 >> 1) + 1) {
                    v360  = v358 + 1;
                  }
                  else {
                    v360  = v359;
                  }
                  if (v359 >= 0x7FFFFFFFFFFFFFFELL) {
                    v361  = 0x7FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    v361  = v360;
                  }
                  v483[0]  = v9 + 528;
                  if (v361)
                  {
                    v362  = (char *)TInlineBufferAllocator<unsigned short,30ul>::allocate(v463, v361);
                    v356  = *(char **)(v9 + 504);
                    v354  = *(char **)(v9 + 512);
                  }
                  else
                  {
                    v362  = 0;
                  }
                  v363  = &v362[2 * v358];
                  *(_WORD *)v363  = 0;
                  if (v354 == v356)
                  {
                    v365  = &v362[2 * v358];
                  }
                  else
                  {
                    v364  = v354;
                    v365  = &v362[2 * v358];
                    do
                    {
                      v366  = *((_WORD *)v364 - 1);
                      v364 -= 2;
                      *((_WORD *)v365 - 1)  = v366;
                      v365 -= 2;
                    }
                    while (v364 != v356);
                  }
                  v367  = v363 + 2;
                  *(void *)(v9 + 504)  = v365;
                  *(void *)(v9 + 512)  = v363 + 2;
                  v368  = *(void *)(v9 + 520);
                  *(void *)(v9 + 520)  = &v362[2 * v361];
                  *(void *)&v482  = v354;
                  *((void *)&v482 + 1)  = v368;
                  *(void *)&v481  = v356;
                  *((void *)&v481 + 1)  = v356;
                  std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,30ul> &>::~__split_buffer((uint64_t)&v481);
                  v354  = v367;
                }
                else
                {
                  *(_WORD *)v354  = 0;
                  v354 += 2;
                }
                *(void *)(v9 + 512)  = v354;
                BOOL v29 = v353-- != 0;
              }
              while (v353 != 0 && v29);
            }
            if (__srca != v435)
            {
              v369  = 0;
              v370  = ((v350 - v351) >> 1) - v457;
              v371  = *(char **)(v9 + 608);
              do
              {
                v372  = (unsigned __int16 *)(v485 + 4 * v369);
                v374  = *v372;
                v373  = v372 + 1;
                *(_WORD *)(*(void *)(v9 + 504) + 2 * (v370 + v374))  = v369;
                v375  = *(void *)(v9 + 616);
                if ((unint64_t)v371 >= v375)
                {
                  v376  = *(char **)(v9 + 600);
                  v377  = v371 - v376;
                  if (v371 - v376 <= -3) {
                    goto LABEL_500;
                  }
                  v378  = v377 >> 1;
                  v379  = v375 - (void)v376;
                  if (v379 <= (v377 >> 1) + 1) {
                    v380  = v378 + 1;
                  }
                  else {
                    v380  = v379;
                  }
                  if (v379 >= 0x7FFFFFFFFFFFFFFELL) {
                    v381  = 0x7FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    v381  = v380;
                  }
                  v483[0]  = v9 + 624;
                  if (v381)
                  {
                    v382  = (char *)TInlineBufferAllocator<unsigned short,30ul>::allocate(v9 + 624, v381);
                    v371  = *(char **)(v9 + 608);
                    v376  = *(char **)(v9 + 600);
                  }
                  else
                  {
                    v382  = 0;
                  }
                  v383  = &v382[2 * v378];
                  *(_WORD *)v383  = *v373;
                  if (v371 == v376)
                  {
                    v385  = &v382[2 * v378];
                  }
                  else
                  {
                    v384  = v371;
                    v385  = &v382[2 * v378];
                    do
                    {
                      v386  = *((_WORD *)v384 - 1);
                      v384 -= 2;
                      *((_WORD *)v385 - 1)  = v386;
                      v385 -= 2;
                    }
                    while (v384 != v376);
                  }
                  v387  = v383 + 2;
                  *(void *)(v9 + 600)  = v385;
                  *(void *)(v9 + 608)  = v383 + 2;
                  v388  = *(void *)(v9 + 616);
                  *(void *)(v9 + 616)  = &v382[2 * v381];
                  *(void *)&v482  = v371;
                  *((void *)&v482 + 1)  = v388;
                  *(void *)&v481  = v376;
                  *((void *)&v481 + 1)  = v376;
                  std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,30ul> &>::~__split_buffer((uint64_t)&v481);
                  v371  = v387;
                }
                else
                {
                  *(_WORD *)v371  = *v373;
                  v371 += 2;
                }
                *(void *)(v9 + 608)  = v371;
                ++v369;
              }
              while (v369 != v303);
            }
          }
          ++v299;
          v297  = v464;
          v302  = (uint64_t)(*((void *)&v464 + 1) - v464) >> 1;
        }
        while (v299 <= v302);
        uint64_t v240 = v429;
        if ((void)v485)
        {
          *((void *)&v485 + 1)  = v485;
          if ((unint64_t)v486 + 8 > (unint64_t)v485
            || (unint64_t)&v486[8] <= (unint64_t)v485)
          {
            operator delete((void *)v485);
          }
        }
        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v464);
        uint64_t v239 = v427 + 1;
        if (v427 + 1 >= (unint64_t)SLOWORD(v475[211])) {
          goto LABEL_463;
        }
      }
      v242  = 0;
      v447  = (unsigned __int16)v239;
      while (1)
      {
        v243  = (char *)__p;
        v453  = v242;
        if (v447 == *((__int16 *)__p + 28 * v242 + 24))
        {
          v244  = (unsigned __int16 *)((char *)__p + 56 * v242);
          v245  = v244 + 4;
          std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)&v464, *((char **)v244 + 1), *((void *)v244 + 2), (uint64_t)(*((void *)v244 + 2) - *((void *)v244 + 1)) >> 1);
          v246  = (char *)v476 + 1760 * *v244;
          v248  = (unsigned __int16 *)*((void *)v246 + 5);
          v247  = (unsigned __int16 *)*((void *)v246 + 6);
          if (v248 != v247) {
            break;
          }
        }
LABEL_349:
        v242  = v453 + 1;
        if (v453 + 1 == v240)
        {
          v295  = (unsigned __int16 *)*((void *)&v485 + 1);
          v296  = (unsigned __int16 *)v485;
          v298  = *((void *)&v464 + 1);
          v297  = v464;
          goto LABEL_352;
        }
      }
      v249  = &v243[56 * v453 + 2];
      v456  = v249;
      while (1)
      {
        if (v248[25] != *(unsigned __int16 *)v249) {
          goto LABEL_348;
        }
        v250  = (const void *)*((void *)v248 + 1);
        v251  = *((void *)v248 + 2) - (void)v250;
        if (v251 != *((void *)v245 + 1) - *(void *)v245) {
          goto LABEL_348;
        }
        v252  = memcmp(v250, *(const void **)v245, v251);
        v249  = v456;
        if (v252) {
          goto LABEL_348;
        }
        v253  = *v248;
        v254  = v248[24];
        v255  = v485;
        if (*((void *)&v485 + 1) == (void)v485)
        {
          v268  = v485;
          v256  = (unsigned __int16 *)v485;
        }
        else
        {
          v256  = (unsigned __int16 *)v485;
          v257  = (uint64_t)(*((void *)&v485 + 1) - v485) >> 2;
          v258  = (unsigned __int16 *)v485;
          v259  = v257;
          do
          {
            v260  = v259 >> 1;
            v261  = &v258[2 * (v259 >> 1)];
            v263  = *v261;
            v262  = v261 + 2;
            v259 += ~(v259 >> 1);
            if (v263 < v253) {
              v258  = v262;
            }
            else {
              v259  = v260;
            }
          }
          while (v259);
          if (v258 != *((unsigned __int16 **)&v485 + 1) && v253 >= *v258) {
            goto LABEL_348;
          }
          do
          {
            v264  = v257 >> 1;
            v265  = &v256[2 * (v257 >> 1)];
            v267  = *v265;
            v266  = v265 + 2;
            v257 += ~(v257 >> 1);
            if (v267 < v253) {
              v256  = v266;
            }
            else {
              v257  = v264;
            }
          }
          while (v257);
          v268  = *((void *)&v485 + 1);
        }
        v269  = (uint64_t)v256 - v485;
        v270  = (unsigned int *)(v485 + (((unint64_t)v256 - v485) & 0xFFFFFFFFFFFFFFFCLL));
        if (*((void *)&v485 + 1) >= *(void *)&v486[0]) {
          break;
        }
        if (v270 != *((unsigned int **)&v485 + 1))
        {
          v271  = (int *)(v268 - 4);
          v272  = (_DWORD *)*((void *)&v485 + 1);
          while ((unint64_t)v271 < *((void *)&v255 + 1))
          {
            v273  = *v271++;
            *v272++  = v273;
          }
          *((void *)&v485 + 1)  = v272;
          if (*((unsigned int **)&v255 + 1) != v270 + 1)
          {
            v277  = (unsigned int *)(v255 + (((unint64_t)v256 - v255) & 0xFFFFFFFFFFFFFFFCLL));
            v278  = v254;
            memmove((void *)(*((void *)&v255 + 1) - 4 * ((v268 - (uint64_t)(v270 + 1)) >> 2)), v270, v268 - (void)(v270 + 1));
            v270  = v277;
            v254  = v278;
          }
          *v270  = v253 | (v254 << 16);
LABEL_347:
          v249  = v456;
          goto LABEL_348;
        }
        **((_DWORD **)&v485 + 1)  = v253 | (v254 << 16);
        *((void *)&v485 + 1)  = *((void *)&v255 + 1) + 4;
LABEL_348:
        v248 += 28;
        if (v248 == v247) {
          goto LABEL_349;
        }
      }
      v274  = ((v268 - (uint64_t)v485) >> 2) + 1;
      if (v274 >> 62) {
        goto LABEL_500;
      }
      if ((uint64_t)(*(void *)&v486[0] - v485) >> 1 > v274) {
        v274  = (uint64_t)(*(void *)&v486[0] - v485) >> 1;
      }
      if (*(void *)&v486[0] - (void)v485 >= 0x7FFFFFFFFFFFFFFCuLL) {
        v275  = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        v275  = v274;
      }
      v471  = (unint64_t *)v486 + 1;
      if (v275)
      {
        __srcb  = (unsigned int *)(v485 + (((unint64_t)v256 - v485) & 0xFFFFFFFFFFFFFFFCLL));
        v433  = v254;
        v276  = (char *)TInlineBufferAllocator<unsigned int,30ul>::allocate((uint64_t)v486 + 8, v275);
        v269  = (uint64_t)v256 - v255;
        v270  = __srcb;
        v254  = v433;
      }
      else
      {
        v276  = 0;
      }
      v279  = v269 >> 2;
      v280  = &v276[4 * (v269 >> 2)];
      v281  = &v276[4 * v275];
      v470  = (unint64_t)v281;
      if (v269 >> 2 == v275)
      {
        if (v269 < 1)
        {
          if (v256 == (unsigned __int16 *)v255) {
            v283  = 1;
          }
          else {
            v283  = v269 >> 1;
          }
          v284  = v276;
          v483[0]  = (char *)v486 + 8;
          __srcc  = v270;
          v434  = v254;
          v285  = v281;
          v286  = (char *)TInlineBufferAllocator<unsigned int,30ul>::allocate((uint64_t)v486 + 8, v283);
          *(void *)&v481  = v284;
          *((void *)&v481 + 1)  = v280;
          v287  = &v286[v283 & 0xFFFFFFFFFFFFFFFCLL];
          v467  = v286;
          v470  = (unint64_t)&v286[4 * v283];
          *(void *)&v482  = v280;
          *((void *)&v482 + 1)  = v285;
          std::__split_buffer<unsigned int,TInlineBufferAllocator<unsigned int,30ul> &>::~__split_buffer((uint64_t)&v481);
          v270  = __srcc;
          v254  = v434;
          v280  = v287;
        }
        else
        {
          if (v279 >= -1) {
            v282  = v279 + 1;
          }
          else {
            v282  = v279 + 2;
          }
          v280 -= 4 * (v282 >> 1);
        }
      }
      *(_DWORD *)v280  = v253 | (v254 << 16);
      v288  = v280 + 4;
      v469  = v280 + 4;
      v289  = (unsigned int *)v485;
      if ((unsigned int *)v485 != v270)
      {
        v290  = v270;
        do
        {
          v291  = *--v290;
          *((_DWORD *)v280 - 1)  = v291;
          v280 -= 4;
        }
        while (v290 != v289);
        v288  = v469;
      }
      v468  = v280;
      v292  = *((void *)&v485 + 1) - (void)v270;
      if (*((unsigned int **)&v485 + 1) != v270)
      {
        memmove(v288, v270, *((void *)&v485 + 1) - (void)v270);
        v280  = v468;
        v270  = (unsigned int *)*((void *)&v485 + 1);
      }
      v293  = (char *)v485;
      *(void *)&v485  = v280;
      *((void *)&v485 + 1)  = &v288[v292];
      v294  = *(void *)&v486[0];
      *(void *)&v486[0]  = v470;
      v469  = (char *)v270;
      v470  = v294;
      v467  = v293;
      v468  = v293;
      std::__split_buffer<unsigned int,TInlineBufferAllocator<unsigned int,30ul> &>::~__split_buffer((uint64_t)&v467);
      uint64_t v240 = v429;
      goto LABEL_347;
    }
LABEL_463:
    if (*(_DWORD *)(v9 + 24) < 2u
      || (v389  = *(void *)(v9 + 40), (unint64_t)(*(void *)(v9 + 48) - v389) < 3)
      || (v390  = *(unsigned __int16 *)(v389 + 2),
          v391  = *(void *)(v9 + 136),
          0xAAAAAAAAAAAAAAABLL * ((*(void *)(v9 + 144) - v391) >> 1) <= v390))
    {
      v392  = 0;
    }
    else
    {
      v392  = *(_WORD *)(v391 + 6 * v390);
    }
    v393  = CFDataGetMutableBytePtr((CFMutableDataRef)atomic_load_explicit((atomic_ullong *volatile)(v9 + 16), memory_order_acquire));
    v394  = (const __CFData *)(id)atomic_load_explicit((atomic_ullong *volatile)(v9 + 32), memory_order_acquire);
    v395  = v394;
    if (v394) {
      BytePtr  = (const SFNTLookupTable *)CFDataGetBytePtr(v394);
    }
    else {
      BytePtr  = 0;
    }
    v397  = (id)atomic_load_explicit((atomic_ullong *volatile)(v9 + 32), memory_order_acquire);
    v398  = (const __CFData *)v397;
    if (v398)
    {
      v399  = v398;
      v400  = CFDataGetBytePtr(v398);

      if (v400)
      {
        v401  = (SFNTLookupTable *)&v400[CFDataGetLength((CFDataRef)v397)];
LABEL_476:
        *(void *)&v485  = TAATLookupTable::BadTable;
        *((void *)&v485 + 1)  = 0;
        *((void *)&v486[1] + 1)  = 0;
        LOWORD(v486[2])  = -1;
        TAATLookupTable::SetTable((uint64_t)&v485, BytePtr, v401);
        v402  = operator new(0x28uLL);
        *v402  = &unk_1ED060C50;
        v402[1]  = v9;
        v402[2]  = v415;
        v402[3]  = v393;
        *((_WORD *)v402 + 16)  = v392;
        *((void *)&v482 + 1)  = v402;
        TAATLookupTable::Iterate((uint64_t)&v485, (uint64_t)&v481);
        std::__function::__value_func<void ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100](&v481);

        v403  = 1;
        goto LABEL_481;
      }
    }
    else
    {
    }
    v401  = 0;
    goto LABEL_476;
  }
LABEL_480:
  DisposeLKTHandle(v404);
  v403  = 0;
LABEL_481:
  v405  = __p;
  if (__p)
  {
    v406  = v473;
    v407  = __p;
    if (v473 != __p)
    {
      do
      {
        v408  = v406 - 56;
        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)(v406 - 48));
        v406  = v408;
      }
      while (v408 != v405);
      v407  = __p;
    }
    v473  = v405;
    if (v475 > v407 || &v475[210] <= v407) {
      operator delete(v407);
    }
  }
  v410  = (char **)v476;
  if (v476)
  {
    v411  = v477;
    v412  = v476;
    if (v477 != v476)
    {
      do
      {
        v411 -= 220;
      }
      while (v411 != v410);
      v412  = v476;
    }
    v477  = v410;
    if (v479 > v412 || &v480 <= (char **)v412) {
      operator delete(v412);
    }
  }
  return v403;
}

void anonymous namespace'::MorxLigatureSubtableBuilder::CreateSubtableData(_anonymous_namespace_::MorxLigatureSubtableBuilder *this, uint64_t a2)
{
  unint64_t v2 = *(void *)(a2 + 360)
     + *(void *)(a2 + 512)
     - (*(void *)(a2 + 352)
      + *(void *)(a2 + 504))
     + *(void *)(a2 + 608)
     - *(void *)(a2 + 600);
  if (v2 >= 0xFFFFFFFF)
  {
    *(void *)this  = 0;
  }
  else
  {
    id v42 = (id)0xAAAAAAAAAAAAAAAALL;
    CFIndex Length = CFDataGetLength((CFDataRef)atomic_load_explicit((atomic_ullong *volatile)(a2 + 32), memory_order_acquire));
    CFIndex v5 = Length + 28;
    if ((unint64_t)(Length + 28) >= 0xFFFFFFFF
      || (uint64_t v6 = *(void *)(a2 + 48) - *(void *)(a2 + 40), v7 = v6 + v5, (unint64_t)(v6 + v5) >= 0xFFFFFFFF)
      || (unint64_t v8 = v2 + Length + v6 + *(void *)(a2 + 144) - *(void *)(a2 + 136) + 28, v8 >= 0xFFFFFFFF))
    {
      id v42 = 0;
    }
    else
    {
      id v42 = (id)0xAAAAAAAAAAAAAAAALL;
      unint64_t explicit = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)&v42, memory_order_acquire);
      *(_DWORD *)bytes  = bswap32(*(_DWORD *)(a2 + 24));
      CFDataAppendBytes(explicit, bytes, 4);
      int v10 = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)&v42, memory_order_acquire);
      *(_DWORD *)bytes  = 469762048;
      CFDataAppendBytes(v10, bytes, 4);
      int v11 = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)&v42, memory_order_acquire);
      *(_DWORD *)bytes  = bswap32(v5);
      CFDataAppendBytes(v11, bytes, 4);
      unint64_t v12 = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)&v42, memory_order_acquire);
      *(_DWORD *)bytes  = bswap32(v7);
      CFDataAppendBytes(v12, bytes, 4);
    }
    CFDataRef v13 = (const __CFData *)atomic_load_explicit((atomic_ullong *volatile)&v42, memory_order_acquire);
    int v14 = CFDataGetLength(v13);
    CFDataIncreaseLength(v13, 4);
    CFDataRef v15 = (const __CFData *)atomic_load_explicit((atomic_ullong *volatile)&v42, memory_order_acquire);
    int v16 = CFDataGetLength(v15);
    CFDataIncreaseLength(v15, 4);
    CFDataRef v17 = (const __CFData *)atomic_load_explicit((atomic_ullong *volatile)&v42, memory_order_acquire);
    int v18 = CFDataGetLength(v17);
    CFDataIncreaseLength(v17, 4);
    unsigned int v19 = (_anonymous_namespace_ *)atomic_load_explicit((atomic_ullong *volatile)&v42, memory_order_acquire);
    uint64_t v21 = *(unsigned __int16 **)(a2 + 40);
    long long v22 = *(unsigned __int16 **)(a2 + 48);
    while (v21 != v22)
    {
      unsigned int v23 = *v21++;
      *(_WORD *)bytes  = bswap32(v23) >> 16;
      CFDataAppendBytes(v19, bytes, 2);
    }
    unsigned __int16 v25 = *(unsigned __int16 **)(a2 + 136);
    unsigned int v24 = *(unsigned __int16 **)(a2 + 144);
    while (v25 != v24)
    {
      *(_WORD *)bytes  = bswap32(*v25) >> 16;
      CFDataAppendBytes(v19, bytes, 2);
      *(_WORD *)bytes  = bswap32(v25[1]) >> 16;
      CFDataAppendBytes(v19, bytes, 2);
      *(_WORD *)bytes  = bswap32(v25[2]) >> 16;
      CFDataAppendBytes(v19, bytes, 2);
      v25 += 3;
    }
    unsigned int v26 = bswap32(CFDataGetLength((CFDataRef)atomic_load_explicit((atomic_ullong *volatile)&v42, memory_order_acquire)) - 12);
    *(_DWORD *)&CFDataGetMutableBytePtr(v13)[v14]  = v26;
    unsigned __int16 v27 = *(unsigned int **)(a2 + 352);
    unsigned int v28 = *(unsigned int **)(a2 + 360);
    while (v27 != v28)
    {
      BOOL v29 = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)&v42, memory_order_acquire);
      unsigned int v30 = *v27++;
      *(_DWORD *)bytes  = bswap32(v30);
      CFDataAppendBytes(v29, bytes, 4);
    }
    unsigned int v31 = bswap32(CFDataGetLength((CFDataRef)atomic_load_explicit((atomic_ullong *volatile)&v42, memory_order_acquire)) - 12);
    *(_DWORD *)&CFDataGetMutableBytePtr(v15)[v16]  = v31;
    unsigned int v32 = *(unsigned __int16 **)(a2 + 504);
    unint64_t v33 = *(unsigned __int16 **)(a2 + 512);
    while (v32 != v33)
    {
      uint64_t v34 = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)&v42, memory_order_acquire);
      unsigned int v35 = *v32++;
      *(_WORD *)bytes  = bswap32(v35) >> 16;
      CFDataAppendBytes(v34, bytes, 2);
    }
    unsigned int v36 = bswap32(CFDataGetLength((CFDataRef)atomic_load_explicit((atomic_ullong *volatile)&v42, memory_order_acquire)) - 12);
    *(_DWORD *)&CFDataGetMutableBytePtr(v17)[v18]  = v36;
    BOOL v37 = *(unsigned __int16 **)(a2 + 600);
    uint64_t v38 = *(unsigned __int16 **)(a2 + 608);
    while (v37 != v38)
    {
      uint64_t v39 = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)&v42, memory_order_acquire);
      unsigned int v40 = *v37++;
      *(_WORD *)bytes  = bswap32(v40) >> 16;
      CFDataAppendBytes(v39, bytes, 2);
    }
    *(void *)this  = atomic_exchange((atomic_ullong *volatile)&v42, 0);
  }
}

void anonymous namespace'::MorxLigatureSubtableBuilder::~MorxLigatureSubtableBuilder(id *this)
{
  *this  = &unk_1ED05F8B0;
  unint64_t v2 = this + 4;
  uint64_t v3 = this + 75;
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100](&v3);
  uint64_t v3 = this + 63;
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100](&v3);
  uint64_t v3 = this + 44;
  std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100](&v3);
  *this  = &unk_1ED05F928;
  std::vector<STXEntryOne,TInlineBufferAllocator<STXEntryOne,30ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)(this + 17));
  uint64_t v3 = this + 5;
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100](&v3);
}

{
  id *v2;
  void **v3;

  *this  = &unk_1ED05F8B0;
  unint64_t v2 = this + 4;
  uint64_t v3 = this + 75;
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100](&v3);
  uint64_t v3 = this + 63;
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100](&v3);
  uint64_t v3 = this + 44;
  std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100](&v3);
  *this  = &unk_1ED05F928;
  std::vector<STXEntryOne,TInlineBufferAllocator<STXEntryOne,30ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)(this + 17));
  uint64_t v3 = this + 5;
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100](&v3);

  MEMORY[0x1853275C0](this, 0x10F1C40AC1E5FC9);
}

char **AddPrevLigaturesFromLigInputs(char **result, char **a2, uint64_t a3)
{
  if (a3 - (uint64_t)a2 >= 1)
  {
    uint64_t v3 = a2;
    unint64_t v4 = result;
    uint64_t v5 = (a3 - (uint64_t)a2) / 48;
    unsigned int v7 = *result;
    unint64_t v6 = (unint64_t)result[1];
    uint64_t v8 = (uint64_t)(v6 - (void)*result) / 48;
    uint64_t v9 = &(*result)[48 * v8];
    int v10 = result[2];
    if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v10[-v6] >> 4)) >= v5)
    {
      if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v6 - (void)v9) >> 4)) >= v5)
      {
        uint64_t v18 = (uint64_t)&a2[6 * v5];
        unsigned int v19 = result[1];
      }
      else
      {
        uint64_t v18 = (uint64_t)&a2[2 * ((uint64_t)(v6 - (void)v9) >> 4)];
        if ((uint64_t)(v6 - (void)v9) < 1) {
          return result;
        }
        unsigned int v19 = v4[1];
      }
      CFDataRef v20 = &v9[48 * v5];
      uint64_t v21 = &v19[-48 * v5];
      uint64_t result = (char **)v19;
      if ((unint64_t)v21 < v6)
      {
        uint64_t result = (char **)v19;
        do
        {
          uint64_t v22 = std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>((uint64_t)result, *(unsigned char **)v21, *((unsigned char **)v21 + 1));
          *(_WORD *)(v22 + 40)  = *((_WORD *)v21 + 20);
          uint64_t result = (char **)(v22 + 48);
          v21 += 48;
        }
        while ((unint64_t)v21 < v6);
      }
      v4[1]  = (char *)result;
      if (v19 != v20)
      {
        unsigned int v23 = v19 - 48;
        uint64_t v24 = 16 * ((v19 - v20) >> 4);
        do
        {
          uint64_t result = (char **)std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>(v23, *(char **)&v9[v24 - 48], *(void *)&v9[v24 - 40], (uint64_t)(*(void *)&v9[v24 - 40] - *(void *)&v9[v24 - 48]) >> 1);
          *((_WORD *)v23 + 20)  = *(_WORD *)&v9[v24 - 8];
          v23 -= 48;
          v24 -= 48;
        }
        while (v24);
      }
      if ((char **)v18 != v3)
      {
        do
        {
          uint64_t result = (char **)std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>(v9, *v3, (uint64_t)v3[1], (v3[1] - *v3) >> 1);
          *((_WORD *)v9 + 20)  = *((_WORD *)v3 + 20);
          v3 += 6;
          v9 += 48;
        }
        while (v3 != (char **)v18);
      }
    }
    else
    {
      unint64_t v11 = v8 + v5;
      if ((unint64_t)(v8 + v5) > 0x555555555555555) {
        abort();
      }
      uint64_t v12 = (uint64_t)(result + 3);
      unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((v10 - v7) >> 4);
      if (2 * v13 > v11) {
        unint64_t v11 = 2 * v13;
      }
      if (v13 >= 0x2AAAAAAAAAAAAAALL) {
        unint64_t v14 = 0x555555555555555;
      }
      else {
        unint64_t v14 = v11;
      }
      v37[4]  = v4 + 3;
      if (v14)
      {
        uint64_t v17 = v16;
      }
      else
      {
        CFDataRef v15 = 0;
        uint64_t v17 = 0;
      }
      unsigned __int16 v25 = &v15[48 * v8];
      uint64_t v26 = (uint64_t)&v25[48 * v5];
      uint64_t v27 = 48 * v5;
      uint64_t v28 = (uint64_t)v25;
      do
      {
        uint64_t v29 = std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>(v28, *v3, v3[1]);
        *(_WORD *)(v29 + 40)  = *((_WORD *)v3 + 20);
        uint64_t v28 = v29 + 48;
        v3 += 6;
        v27 -= 48;
      }
      while (v27);
      unsigned int v30 = *v4;
      if (*v4 != v9)
      {
        uint64_t v31 = 48 * v8;
        unsigned int v32 = v15;
        do
        {
          std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>((uint64_t)&v32[v31 - 48], *(unsigned char **)&v7[v31 - 48], *(unsigned char **)&v7[v31 - 40]);
          *(_WORD *)&v32[v31 - 8]  = *(_WORD *)&v7[v31 - 8];
          v7 -= 48;
          v32 -= 48;
        }
        while (&v7[v31] != v30);
        unsigned __int16 v25 = &v32[48 * v8];
      }
      unint64_t v33 = &v15[48 * v17];
      uint64_t v34 = v4[1];
      if (v34 != v9)
      {
        do
        {
          std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>(v26, *(unsigned char **)v9, *((unsigned char **)v9 + 1));
          *(_WORD *)(v26 + 40)  = *((_WORD *)v9 + 20);
          v26 += 48;
          v9 += 48;
        }
        while (v9 != v34);
        uint64_t v9 = v4[1];
      }
      unsigned int v35 = *v4;
      *unint64_t v4 = v25;
      v4[1]  = (char *)v26;
      unsigned int v36 = v4[2];
      id v4[2] = v33;
      v37[2]  = v9;
      v37[3]  = v36;
      v37[0]  = v35;
      v37[1]  = v35;
    }
  }
  return result;
}

void *TInlineVector<anonymous namespace'::LigInput,30ul>::~TInlineVector(void *a1)
{
  unint64_t v2 = (void *)*a1;
  if (*a1)
  {
    uint64_t v3 = a1[1];
    unint64_t v4 = (void *)*a1;
    if ((void *)v3 != v2)
    {
      do
      {
        v3 -= 48;
        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100](v3);
      }
      while ((void *)v3 != v2);
      unint64_t v4 = (void *)*a1;
    }
    a1[1]  = v2;
    uint64_t v5 = a1 + 183;
    if (a1 + 3 <= v4 && v5 > v4)
    {
      if (a1[2] == a1[183]) {
        *uint64_t v5 = v4;
      }
    }
    else
    {
      operator delete(v4);
    }
  }
  return a1;
}

uint64_t anonymous namespace'::ParseSubstFormat3(unint64_t a1, unint64_t a2, uint64_t a3, unint64_t *a4)
{
  uint64_t v5 = a3;
  unint64_t v6 = a1;
  uint64_t v7 = 0;
  v56[3]  = *MEMORY[0x1E4F143B8];
  *a4  = a1;
  a4[1]  = a2;
  uint64_t v8 = (_WORD *)(a1 + 2);
  v56[0]  = a4 + 2;
  v56[1]  = a4 + 18;
  unint64_t v46 = (uint64_t *)(a4 + 18);
  v56[2]  = a4 + 34;
  while (1)
  {
    uint64_t result = 0;
    if ((unint64_t)v8 < v6) {
      return result;
    }
    int v10 = v8 + 1;
    if ((unint64_t)(v8 + 1) > a4[1]) {
      return result;
    }
    uint64_t v48 = v7;
    if (*v8)
    {
      int v11 = 0;
      uint64_t v12 = (char **)v56[v7];
      unsigned int v13 = __rev16((unsigned __int16)*v8);
      if (v13 <= 1) {
        int v14 = 1;
      }
      else {
        int v14 = v13;
      }
      unint64_t v49 = v12 + 15;
      unint64_t v50 = (unint64_t)(v12 + 3);
      do
      {
        CFDataRef v15 = v8 + 2;
        uint64_t v8 = v10;
        __p[0]  = 0;
        __p[1]  = 0;
        uint64_t v54 = 0;
        unint64_t v17 = *a4;
        unint64_t v16 = a4[1];
        if (*a4 > (unint64_t)v8 || (unint64_t)v15 > v16)
        {
          std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::__clear[abi:nn180100](v46);
LABEL_17:
          int v24 = 1;
        }
        else
        {
          unint64_t v52 = 0xAAAAAAAAAAAAAAAALL;
          *(void *)&long long v19 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v19 + 1)  = 0xAAAAAAAAAAAAAAAALL;
          v51[0]  = v19;
          v51[1]  = v19;
          OTL::Coverage::Coverage((OTL::Coverage *)v51, (unsigned __int16 *)(v17 + (bswap32((unsigned __int16)*v8) >> 16)), v16, 0);
          v55[0]  = &unk_1ED060AA0;
          v55[1]  = v5;
          v55[2]  = __p;
          v55[3]  = v55;
          OTL::Coverage::Iterate(v51, (uint64_t)v55);
          std::__function::__value_func<BOOL ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100](v55);
          if (__p[0] == __p[1])
          {
            int v24 = 0;
          }
          else
          {
            CFDataRef v20 = (unsigned __int16 *)((char *)__p[0] + 2);
            uint64_t v21 = (unsigned __int16 *)((char *)__p[0] + 2);
            while (v21 != __p[1])
            {
              unsigned int v22 = *v21;
              unsigned int v23 = *(v21++ - 1);
              if (v22 < v23) {
                goto LABEL_17;
              }
            }
            while (v20 != __p[1])
            {
              int v25 = *(v20 - 1);
              int v26 = *v20++;
              if (v25 == v26)
              {
                if (v20 - 2 != __p[1]) {
                  goto LABEL_17;
                }
                break;
              }
            }
            uint64_t v27 = v12[1];
            unint64_t v28 = (unint64_t)v12[2];
            if ((unint64_t)v27 >= v28)
            {
              unint64_t v30 = 0xAAAAAAAAAAAAAAABLL * ((v27 - *v12) >> 3);
              unint64_t v31 = v30 + 1;
              if (v30 + 1 > 0xAAAAAAAAAAAAAAALL) {
                abort();
              }
              unint64_t v32 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v28 - (void)*v12) >> 3);
              if (2 * v32 > v31) {
                unint64_t v31 = 2 * v32;
              }
              unint64_t v33 = v32 >= 0x555555555555555 ? 0xAAAAAAAAAAAAAAALL : v31;
              uint64_t v34 = (char *)TInlineBufferAllocator<std::vector<unsigned short>,4ul>::allocate(v50, v33);
              unsigned int v35 = &v34[24 * v30];
              unsigned int v36 = &v34[24 * v33];
              *((void *)v35 + 1)  = 0;
              *((void *)v35 + 2)  = 0;
              *(void *)unsigned int v35 = 0;
              *(_OWORD *)unsigned int v35 = *(_OWORD *)__p;
              *((void *)v35 + 2)  = v54;
              __p[1]  = 0;
              uint64_t v54 = 0;
              __p[0]  = 0;
              uint64_t v29 = v35 + 24;
              BOOL v37 = *v12;
              uint64_t v38 = v12[1];
              if (v38 == *v12)
              {
                __CFData *v12 = v35;
                v12[1]  = v29;
                uint64_t v41 = v12[2];
                v12[2]  = v36;
              }
              else
              {
                do
                {
                  *((void *)v35 - 3)  = 0;
                  *((void *)v35 - 2)  = 0;
                  v35 -= 24;
                  *((void *)v35 + 2)  = 0;
                  long long v39 = *(_OWORD *)(v38 - 24);
                  v38 -= 24;
                  *(_OWORD *)unsigned int v35 = v39;
                  *((void *)v35 + 2)  = *((void *)v38 + 2);
                  *(void *)uint64_t v38 = 0;
                  *((void *)v38 + 1)  = 0;
                  *((void *)v38 + 2)  = 0;
                }
                while (v38 != v37);
                uint64_t v38 = *v12;
                unsigned int v40 = v12[1];
                __CFData *v12 = v35;
                v12[1]  = v29;
                uint64_t v41 = v12[2];
                v12[2]  = v36;
                if (v40 != v38)
                {
                  unint64_t v42 = v6;
                  unint64_t v43 = v40;
                  do
                  {
                    uint64_t v45 = (void *)*((void *)v43 - 3);
                    v43 -= 24;
                    unint64_t v44 = v45;
                    if (v45)
                    {
                      *((void *)v40 - 2)  = v44;
                      operator delete(v44);
                    }
                    unsigned int v40 = v43;
                  }
                  while (v43 != v38);
                  unint64_t v6 = v42;
                  uint64_t v5 = a3;
                }
              }
              if (v38)
              {
                if (v50 > (unint64_t)v38 || v49 <= (char **)v38)
                {
                  operator delete(v38);
                }
                else if (v41 == *v49)
                {
                  char *v49 = v38;
                }
              }
            }
            else
            {
              *(void *)uint64_t v27 = 0;
              *((void *)v27 + 1)  = 0;
              *((void *)v27 + 2)  = 0;
              *(_OWORD *)uint64_t v27 = *(_OWORD *)__p;
              *((void *)v27 + 2)  = v54;
              __p[0]  = 0;
              __p[1]  = 0;
              uint64_t v54 = 0;
              uint64_t v29 = v27 + 24;
            }
            int v24 = 0;
            v12[1]  = v29;
          }
        }
        if (__p[0])
        {
          __p[1]  = __p[0];
          operator delete(__p[0]);
        }
        if (v24) {
          return 0;
        }
        ++v11;
        int v10 = v8 + 1;
      }
      while (v11 != v14);
    }
    uint64_t v7 = v48 + 1;
    uint64_t v8 = v10;
    if (v48 == 2)
    {
      if (a4[18] != a4[19])
      {
        if ((unint64_t)v10 >= v6 && (unint64_t)(v10 + 1) <= a4[1])
        {
          *((_DWORD *)a4 + 100)  = bswap32(*v10) >> 16;
          a4[51]  = (unint64_t)(v10 + 1);
          return 1;
        }
        std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::__clear[abi:nn180100](v46);
      }
      return 0;
    }
  }
}

uint64_t SingleSubstIsEqualTo(unsigned __int16 *a1, uint64_t a2, unint64_t a3)
{
  unsigned int v4 = bswap32(*a1) >> 16;
  if (v4 != 2)
  {
    if (v4 == 1)
    {
      uint64_t result = 0;
      if ((unint64_t)(a1 + 3) <= a3 && a2 + 6 <= a3) {
        return a1[2] == *(unsigned __int16 *)(a2 + 4);
      }
      return result;
    }
    return 0;
  }
  unint64_t v6 = a1 + 3;
  if ((unint64_t)(a1 + 3) > a3) {
    return 0;
  }
  unsigned int v7 = a1[2];
  uint64_t v8 = __rev16(v7);
  uint64_t v9 = &v6[v8];
  unint64_t v10 = (unint64_t)(a1 + 4) <= a3 ? (a3 - (unint64_t)v6) >> 1 : 0;
  BOOL v11 = (unint64_t)v9 <= a3 && v9 >= v6;
  if (!v11 && v10 != v8) {
    return 0;
  }
  unsigned int v13 = (unsigned __int16 *)(a2 + 6);
  if (a2 + 6 > a3) {
    return 0;
  }
  uint64_t result = 0;
  unsigned int v14 = *(unsigned __int16 *)(a2 + 4);
  uint64_t v15 = __rev16(v14);
  unint64_t v16 = &v13[v15];
  if (a2 + 8 <= a3) {
    unint64_t v17 = (a3 - (unint64_t)v13) >> 1;
  }
  else {
    unint64_t v17 = 0;
  }
  BOOL v19 = (unint64_t)v16 <= a3 && v16 >= v13 || v17 == v15;
  if (v19 && v7 == v14)
  {
    if (v7)
    {
      uint64_t v20 = 2 * v8 - 2;
      do
      {
        int v22 = *v6++;
        int v21 = v22;
        int v23 = *v13++;
        uint64_t result = v21 == v23;
        BOOL v24 = v21 != v23 || v20 == 0;
        v20 -= 2;
      }
      while (!v24);
    }
    else
    {
      return 1;
    }
  }
  return result;
}

void std::vector<anonymous namespace'::SubstFormat3,TInlineBufferAllocator<anonymous namespace'::SubstFormat3,30ul>>::emplace_back<anonymous namespace'::SubstFormat3>(uint64_t a1, __n128 *a2)
{
  unint64_t v5 = *(void *)(a1 + 8);
  unint64_t v4 = *(void *)(a1 + 16);
  if (v5 >= v4)
  {
    unint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v7 + 1)  = 0xAAAAAAAAAAAAAAAALL;
    long long v12 = v7;
    long long v13 = v7;
    uint64_t v8 = 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(v5 - *(void *)a1) >> 5);
    if ((unint64_t)(v8 + 1) > 0x9D89D89D89D89DLL) {
      abort();
    }
    unint64_t v9 = 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(v4 - *(void *)a1) >> 5);
    uint64_t v10 = 2 * v9;
    if (2 * v9 <= v8 + 1) {
      uint64_t v10 = v8 + 1;
    }
    if (v9 >= 0x4EC4EC4EC4EC4ELL) {
      unint64_t v11 = 0x9D89D89D89D89DLL;
    }
    else {
      unint64_t v11 = v10;
    }
    *(void *)&long long v13 = v13 + 416;
    unint64_t v6 = *(void *)(a1 + 8);
  }
  else
  {
    unint64_t v6 = v5 + 416;
  }
  *(void *)(a1 + 8)  = v6;
}

void CreateSingleSubstitutionLookupTable(atomic_ullong *a1, int64_t a2, int a3, unsigned __int16 *a4, unint64_t a5, uint64_t a6, uint64_t a7, __int16 a8)
{
  v16[4]  = *MEMORY[0x1E4F143B8];
  std::__function::__value_func<BOOL ()(unsigned short)>::__value_func[abi:nn180100]((uint64_t)v16, a7);
  SingleSubstitutionLKTHandle  = CreateSingleSubstitutionLKTHandle(a2, a3, a4, a5, a6, (uint64_t)v16, a8);
  std::__function::__value_func<BOOL ()(unsigned short)>::~__value_func[abi:nn180100](v16);
  if (SingleSubstitutionLKTHandle)
  {
    *a1  = 0xAAAAAAAAAAAAAAAALL;
    LKTCreateLookupTable(SingleSubstitutionLKTHandle, a1);
    DisposeLKTHandle(SingleSubstitutionLKTHandle);
  }
  else
  {
    *a1  = 0;
  }
}

void anonymous namespace'::MorxContextualSubtableBuilder::CreateSubtableData(_anonymous_namespace_::MorxContextualSubtableBuilder *this, atomic_ullong *a2)
{
  unint64_t v2 = a2;
  id v10 = (id)0xAAAAAAAAAAAAAAAALL;
  unint64_t v4 = a2 + 51;
  unsigned int Length = CFDataGetLength((CFDataRef)atomic_load_explicit(a2 + 51, memory_order_acquire));
  CFDataRef explicit = (const __CFData *)atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire);
  int v7 = CFDataGetLength(explicit);
  CFDataIncreaseLength(explicit, 4);
  LODWORD(v2)  = bswap32(CFDataGetLength((CFDataRef)atomic_load_explicit((atomic_ullong *volatile)&v10, memory_order_acquire))- 12);
  *(_DWORD *)&CFDataGetMutableBytePtr(explicit)[v7]  = v2;
  *(void *)this  = atomic_exchange((atomic_ullong *volatile)&v10, 0);
}

void anonymous namespace'::MorxContextualSubtableBuilder::~MorxContextualSubtableBuilder(id *this)
{
  *this  = &unk_1ED05F900;
}

{
  uint64_t vars8;

  *this  = &unk_1ED05F900;

  JUMPOUT(0x1853275C0);
}

void *anonymous namespace'::MorxChainBuilder::AddNoEffectExclusiveFeatures<std::__wrap_iter<unsigned short *>>(void *result, unsigned __int16 *a2, unsigned __int16 *a3)
{
  if (a2 != a3)
  {
    uint64_t v17 = v3;
    uint64_t v18 = v4;
    unint64_t v6 = a2;
    int v7 = result;
    CFDataRef v8 = result + 1;
    do
    {
      CFDataRef v9 = (unsigned __int16 *)v7[1];
      id v10 = (unsigned __int16 *)v7[2];
      if (v9 != v10)
      {
        while (*v9 != *v6)
        {
          v9 += 6;
          if (v9 == v10)
          {
            CFDataRef v9 = (unsigned __int16 *)v7[2];
            break;
          }
        }
      }
      uint64_t v11 = 0;
      LOWORD(v15)  = *v9;
      int v12 = *v9;
      while (*(unsigned __int16 *)((char *)&kMasterFeatureMap + v11 + 4) != v12)
      {
        v11 += 12;
        if (v11 == 1980)
        {
LABEL_14:
          __int16 v14 = 0;
          goto LABEL_15;
        }
      }
      while ((*((unsigned char *)&kMasterFeatureMap + v11 + 8) & 2) == 0)
      {
        if (v11 != 1968)
        {
          int v13 = *(unsigned __int16 *)((char *)&kMasterFeatureMap + v11 + 16);
          v11 += 12;
          if (v13 == v12) {
            continue;
          }
        }
        goto LABEL_14;
      }
      __int16 v14 = *(_WORD *)((char *)&kMasterFeatureMap + v11 + 6);
LABEL_15:
      WORD1(v15)  = v14;
      HIDWORD(v15)  = 0;
      int v16 = *((_DWORD *)v9 + 2) ^ *((_DWORD *)v9 + 1);
      uint64_t result = std::vector<MortFeatureEntry,TInlineBufferAllocator<MortFeatureEntry,30ul>>::emplace<MortFeatureEntry>(v8, (char *)v9, &v15);
      ++v6;
    }
    while (v6 != a3);
  }
  return result;
}

void std::vector<anonymous namespace'::MorxChainBuilder,TInlineBufferAllocator<anonymous namespace'::MorxChainBuilder,30ul>>::push_back[abi:nn180100](uint64_t *a1, uint64_t a2)
{
  unint64_t v5 = a1[1];
  unint64_t v4 = a1[2];
  if (v5 >= v4)
  {
    unint64_t v7 = 0xCBEEA4E1A08AD8F3 * ((uint64_t)(v5 - *a1) >> 4);
    if (v7 + 1 > 0x456C797DD49C34) {
      abort();
    }
    unint64_t v8 = 0xCBEEA4E1A08AD8F3 * ((uint64_t)(v4 - *a1) >> 4);
    uint64_t v9 = 2 * v8;
    if (2 * v8 <= v7 + 1) {
      uint64_t v9 = v7 + 1;
    }
    if (v8 >= 0x22B63CBEEA4E1ALL) {
      unint64_t v10 = 0x456C797DD49C34;
    }
    else {
      unint64_t v10 = v9;
    }
    if (v10)
    {
      uint64_t v11 = (char *)a1[3543];
      unint64_t v12 = (unint64_t)&v11[944 * v10];
      if (v12 <= (unint64_t)(a1 + 3543))
      {
        a1[3543]  = v12;
      }
      else
      {
        if (v10 > 0x456C797DD49C34) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        uint64_t v11 = (char *)operator new(944 * v10);
      }
    }
    else
    {
      uint64_t v11 = 0;
    }
    uint64_t v13 = (uint64_t)&v11[944 * v7];
    __int16 v14 = &v11[944 * v10];
    uint64_t v6 = v13 + 944;
    int v16 = (void **)*a1;
    uint64_t v15 = (void **)a1[1];
    if (v15 == (void **)*a1)
    {
      *a1  = v13;
      a1[1]  = v6;
      uint64_t v25 = a1[2];
      a1[2]  = (uint64_t)v14;
    }
    else
    {
      uint64_t v17 = 0;
      do
      {
        uint64_t v18 = v13 + v17 * 8;
        *(_DWORD *)(v13 + v17 * 8 - 944)  = v15[v17 - 118];
        std::vector<MortFeatureEntry,TInlineBufferAllocator<MortFeatureEntry,30ul>>::vector<std::__wrap_iter<MortFeatureEntry const*>,0>((char **)(v13 + v17 * 8 - 936), v15[v17 - 117], v15[v17 - 116]);
        BOOL v19 = (void *)(v13 + v17 * 8 - 544);
        uint64_t v20 = (atomic_ullong *)v15[v17 - 68];
        int v21 = (atomic_ullong *)v15[v17 - 67];
        v19[2]  = 0;
        *(_OWORD *)BOOL v19 = 0u;
        *(void *)(v18 - 280)  = v18 - 520;
        std::vector<TCFRef<__CFData *>,TInlineBufferAllocator<TCFRef<__CFData *>,30ul>>::__init_with_size[abi:nn180100]<std::__wrap_iter<TCFRef<__CFData *> const*>,std::__wrap_iter<TCFRef<__CFData *> const*>>(v19, v20, v21, v21 - v20);
        int v22 = (atomic_ullong *)v15[v17 - 34];
        int v23 = (atomic_ullong *)v15[v17 - 33];
        *(void *)(v18 - 264)  = 0;
        *(void *)(v18 - 272)  = 0;
        *(void *)(v18 - 256)  = 0;
        *(void *)(v18 - 8)  = v18 - 248;
        std::vector<TCFRef<__CFData *>,TInlineBufferAllocator<TCFRef<__CFData *>,30ul>>::__init_with_size[abi:nn180100]<std::__wrap_iter<TCFRef<__CFData *> const*>,std::__wrap_iter<TCFRef<__CFData *> const*>>((void *)(v13 + v17 * 8 - 272), v22, v23, v23 - v22);
        v17 -= 118;
      }
      while (&v15[v17] != v16);
      uint64_t v15 = (void **)*a1;
      BOOL v24 = (void **)a1[1];
      *a1  = v13 + v17 * 8;
      a1[1]  = v6;
      uint64_t v25 = a1[2];
      a1[2]  = (uint64_t)v14;
      while (v24 != v15)
      {
        v24 -= 118;
      }
    }
    if (v15)
    {
      if (a1 + 3 > (uint64_t *)v15 || (int v26 = (void ***)(a1 + 3543), a1 + 3543 <= (uint64_t *)v15))
      {
        operator delete(v15);
      }
      else if ((void **)v25 == *v26)
      {
        unsigned __int16 *v26 = v15;
      }
    }
  }
  else
  {
    uint64_t v6 = v5 + 944;
  }
  a1[1]  = v6;
}

uint64_t *std::__tree<unsigned int>::__remove_node_pointer(uint64_t **a1, uint64_t *a2)
{
  unint64_t v2 = (uint64_t *)a2[1];
  if (v2)
  {
    do
    {
      uint64_t v3 = v2;
      unint64_t v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
  else
  {
    unint64_t v4 = a2;
    do
    {
      uint64_t v3 = (uint64_t *)v4[2];
      BOOL v5 = *v3 == (void)v4;
      unint64_t v4 = v3;
    }
    while (!v5);
  }
  if (*a1 == a2) {
    *a1  = v3;
  }
  uint64_t v6 = a1[1];
  a1[2]  = (uint64_t *)((char *)a1[2] - 1);
  return std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v6, a2);
}

uint64_t *std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = a2;
  if (*a2)
  {
    unint64_t v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      uint64_t v3 = a2;
      goto LABEL_7;
    }
    do
    {
      uint64_t v3 = v4;
      unint64_t v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  uint64_t v2 = v3[1];
  if (v2)
  {
LABEL_7:
    int v5 = 0;
    *(void *)(v2 + 16)  = v3[2];
    goto LABEL_8;
  }
  int v5 = 1;
LABEL_8:
  uint64_t v6 = (uint64_t **)v3[2];
  unint64_t v7 = *v6;
  if (*v6 == v3)
  {
    *uint64_t v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      unint64_t v7 = 0;
      uint64_t result = (uint64_t *)v2;
    }
    else
    {
      unint64_t v7 = v6[1];
    }
  }
  else
  {
    v6[1]  = (uint64_t *)v2;
  }
  int v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    uint64_t v9 = a2[2];
    v3[2]  = v9;
    *(void *)(v9 + 8 * (*(void *)a2[2] != (void)a2))  = v3;
    uint64_t v11 = *a2;
    uint64_t v10 = a2[1];
    *(void *)(v11 + 16)  = v3;
    *uint64_t v3 = v11;
    v3[1]  = v10;
    if (v10) {
      *(void *)(v10 + 16)  = v3;
    }
    *((unsigned char *)v3 + 24)  = *((unsigned char *)a2 + 24);
    if (result == a2) {
      uint64_t result = v3;
    }
  }
  if (!v8 || !result) {
    return result;
  }
  if (!v5)
  {
    *(unsigned char *)(v2 + 24)  = 1;
    return result;
  }
  while (1)
  {
    uint64_t v12 = v7[2];
    if (*(uint64_t **)v12 != v7) {
      break;
    }
    if (!*((unsigned char *)v7 + 24))
    {
      *((unsigned char *)v7 + 24)  = 1;
      *(unsigned char *)(v12 + 24)  = 0;
      uint64_t v18 = v7[1];
      *(void *)uint64_t v12 = v18;
      if (v18) {
        *(void *)(v18 + 16)  = v12;
      }
      void v7[2] = *(void *)(v12 + 16);
      *(void *)(*(void *)(v12 + 16) + 8 * (**(void **)(v12 + 16) != v12))  = v7;
      v7[1]  = v12;
      *(void *)(v12 + 16)  = v7;
      if (result == (uint64_t *)v12) {
        uint64_t result = v7;
      }
      unint64_t v7 = *(uint64_t **)v12;
    }
    BOOL v19 = (void *)*v7;
    if (*v7 && !*((unsigned char *)v19 + 24)) {
      goto LABEL_68;
    }
    uint64_t v20 = (uint64_t *)v7[1];
    if (v20 && !*((unsigned char *)v20 + 24))
    {
      if (v19 && !*((unsigned char *)v19 + 24))
      {
LABEL_68:
        uint64_t v20 = v7;
      }
      else
      {
        *((unsigned char *)v20 + 24)  = 1;
        *((unsigned char *)v7 + 24)  = 0;
        uint64_t v26 = *v20;
        v7[1]  = *v20;
        if (v26) {
          *(void *)(v26 + 16)  = v7;
        }
        v20[2]  = v7[2];
        *(void *)(v7[2] + 8 * (*(void *)v7[2] != (void)v7))  = v20;
        *uint64_t v20 = (uint64_t)v7;
        void v7[2] = (uint64_t)v20;
        BOOL v19 = v7;
      }
      uint64_t v23 = v20[2];
      *((unsigned char *)v20 + 24)  = *(unsigned char *)(v23 + 24);
      *(unsigned char *)(v23 + 24)  = 1;
      *((unsigned char *)v19 + 24)  = 1;
      BOOL v24 = *(uint64_t **)v23;
      uint64_t v27 = *(void *)(*(void *)v23 + 8);
      *(void *)uint64_t v23 = v27;
      if (v27) {
        *(void *)(v27 + 16)  = v23;
      }
      v24[2]  = *(void *)(v23 + 16);
      *(void *)(*(void *)(v23 + 16) + 8 * (**(void **)(v23 + 16) != v23))  = v24;
      v24[1]  = v23;
      goto LABEL_72;
    }
    *((unsigned char *)v7 + 24)  = 0;
    uint64_t v17 = (uint64_t *)v7[2];
    if (*((unsigned char *)v17 + 24)) {
      BOOL v21 = v17 == result;
    }
    else {
      BOOL v21 = 1;
    }
    if (v21) {
      goto LABEL_53;
    }
LABEL_49:
    unint64_t v7 = *(uint64_t **)(v17[2] + 8 * (*(void *)v17[2] == (void)v17));
  }
  if (!*((unsigned char *)v7 + 24))
  {
    *((unsigned char *)v7 + 24)  = 1;
    *(unsigned char *)(v12 + 24)  = 0;
    uint64_t v13 = *(uint64_t **)(v12 + 8);
    uint64_t v14 = *v13;
    *(void *)(v12 + 8)  = *v13;
    if (v14) {
      *(void *)(v14 + 16)  = v12;
    }
    v13[2]  = *(void *)(v12 + 16);
    *(void *)(*(void *)(v12 + 16) + 8 * (**(void **)(v12 + 16) != v12))  = v13;
    *uint64_t v13 = v12;
    *(void *)(v12 + 16)  = v13;
    if (result == (uint64_t *)*v7) {
      uint64_t result = v7;
    }
    unint64_t v7 = *(uint64_t **)(*v7 + 8);
  }
  uint64_t v15 = (void *)*v7;
  if (!*v7 || *((unsigned char *)v15 + 24))
  {
    int v16 = (uint64_t *)v7[1];
    if (v16 && !*((unsigned char *)v16 + 24)) {
      goto LABEL_59;
    }
    *((unsigned char *)v7 + 24)  = 0;
    uint64_t v17 = (uint64_t *)v7[2];
    if (v17 == result)
    {
      uint64_t v17 = result;
LABEL_53:
      *((unsigned char *)v17 + 24)  = 1;
      return result;
    }
    if (!*((unsigned char *)v17 + 24)) {
      goto LABEL_53;
    }
    goto LABEL_49;
  }
  int v16 = (uint64_t *)v7[1];
  if (v16 && !*((unsigned char *)v16 + 24))
  {
LABEL_59:
    uint64_t v15 = v7;
  }
  else
  {
    *((unsigned char *)v15 + 24)  = 1;
    *((unsigned char *)v7 + 24)  = 0;
    uint64_t v22 = v15[1];
    uint64_t *v7 = v22;
    if (v22) {
      *(void *)(v22 + 16)  = v7;
    }
    v15[2]  = v7[2];
    *(void *)(v7[2] + 8 * (*(void *)v7[2] != (void)v7))  = v15;
    v15[1]  = v7;
    void v7[2] = (uint64_t)v15;
    int v16 = v7;
  }
  uint64_t v23 = v15[2];
  *((unsigned char *)v15 + 24)  = *(unsigned char *)(v23 + 24);
  *(unsigned char *)(v23 + 24)  = 1;
  *((unsigned char *)v16 + 24)  = 1;
  BOOL v24 = *(uint64_t **)(v23 + 8);
  uint64_t v25 = *v24;
  *(void *)(v23 + 8)  = *v24;
  if (v25) {
    *(void *)(v25 + 16)  = v23;
  }
  v24[2]  = *(void *)(v23 + 16);
  *(void *)(*(void *)(v23 + 16) + 8 * (**(void **)(v23 + 16) != v23))  = v24;
  uint64_t *v24 = v23;
LABEL_72:
  *(void *)(v23 + 16)  = v24;
  return result;
}

void std::__tree<std::__value_type<unsigned int,std::set<unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::set<unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::set<unsigned int>>>>::erase(void *a1, uint64_t a2)
{
  uint64_t v3 = *(void **)(a2 + 8);
  if (v3)
  {
    do
    {
      unint64_t v4 = v3;
      uint64_t v3 = (void *)*v3;
    }
    while (v3);
  }
  else
  {
    int v5 = (void *)a2;
    do
    {
      unint64_t v4 = (void *)v5[2];
      BOOL v6 = *v4 == (void)v5;
      int v5 = v4;
    }
    while (!v6);
  }
  if (*a1 == a2) {
    *a1  = v4;
  }
  unint64_t v7 = (uint64_t *)a1[1];
  --a1[2];
  std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v7, (uint64_t *)a2);
  std::__tree<std::__value_type<long,TGlyphDeltaListEntry>,std::__map_value_compare<long,std::__value_type<long,TGlyphDeltaListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TGlyphDeltaListEntry>>>::destroy(*(void **)(a2 + 48));

  operator delete((void *)a2);
}

void std::__function::__func<IgnoresForLookupTable(TBaseFont const&,OTL::LookupTable const*)::$_0,std::allocator<IgnoresForLookupTable(TBaseFont const&,OTL::LookupTable const*)::$_0>,void ()(unsigned short)>::~__func()
{
}

void *std::__function::__func<IgnoresForLookupTable(TBaseFont const&,OTL::LookupTable const*)::$_0,std::allocator<IgnoresForLookupTable(TBaseFont const&,OTL::LookupTable const*)::$_0>,void ()(unsigned short)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1ED060308;
  result[1]  = v3;
  return result;
}

uint64_t std::__function::__func<IgnoresForLookupTable(TBaseFont const&,OTL::LookupTable const*)::$_0,std::allocator<IgnoresForLookupTable(TBaseFont const&,OTL::LookupTable const*)::$_0>,void ()(unsigned short)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2  = &unk_1ED060308;
  a2[1]  = v2;
  return result;
}

void std::__function::__func<IgnoresForLookupTable(TBaseFont const&,OTL::LookupTable const*)::$_0,std::allocator<IgnoresForLookupTable(TBaseFont const&,OTL::LookupTable const*)::$_0>,void ()(unsigned short)>::operator()(uint64_t a1, __int16 *a2)
{
  __int16 v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 8);
  unint64_t v4 = *(_WORD **)(v3 + 8);
  unint64_t v5 = *(void *)(v3 + 16);
  if ((unint64_t)v4 >= v5)
  {
    unint64_t v7 = *(_WORD **)v3;
    uint64_t v8 = (uint64_t)v4 - *(void *)v3;
    if (v8 <= -3) {
      abort();
    }
    uint64_t v9 = v8 >> 1;
    unint64_t v10 = v5 - (void)v7;
    if (v10 <= (v8 >> 1) + 1) {
      unint64_t v11 = v9 + 1;
    }
    else {
      unint64_t v11 = v10;
    }
    if (v10 >= 0x7FFFFFFFFFFFFFFELL) {
      uint64_t v12 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v12 = v11;
    }
    if (v12)
    {
      uint64_t v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned short>>(v3 + 16, v12);
      unint64_t v7 = *(_WORD **)v3;
      unint64_t v4 = *(_WORD **)(v3 + 8);
    }
    else
    {
      uint64_t v13 = 0;
    }
    uint64_t v14 = &v13[2 * v9];
    uint64_t v15 = &v13[2 * v12];
    *(_WORD *)uint64_t v14 = v2;
    BOOL v6 = v14 + 2;
    while (v4 != v7)
    {
      __int16 v16 = *--v4;
      *((_WORD *)v14 - 1)  = v16;
      v14 -= 2;
    }
    *(void *)uint64_t v3 = v14;
    *(void *)(v3 + 8)  = v6;
    *(void *)(v3 + 16)  = v15;
    if (v7) {
      operator delete(v7);
    }
  }
  else
  {
    *unint64_t v4 = v2;
    BOOL v6 = v4 + 1;
  }
  *(void *)(v3 + 8)  = v6;
}

__n128 std::vector<unsigned short>::__move_assign(uint64_t a1, __n128 *a2)
{
  unint64_t v4 = *(void **)a1;
  if (v4)
  {
    *(void *)(a1 + 8)  = v4;
    operator delete(v4);
    *(void *)a1  = 0;
    *(void *)(a1 + 8)  = 0;
    *(void *)(a1 + 16)  = 0;
  }
  __n128 result = *a2;
  *(__n128 *)a1  = *a2;
  *(void *)(a1 + 16)  = a2[1].n128_u64[0];
  a2->n128_u64[0]  = 0;
  a2->n128_u64[1]  = 0;
  a2[1].n128_u64[0]  = 0;
  return result;
}

void std::__function::__func<anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_5,std::allocator<anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_5>,BOOL ()(unsigned short,unsigned short,unsigned short)>::~__func()
{
}

__n128 std::__function::__func<anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_5,std::allocator<anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_5>,BOOL ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  __int16 v2 = (char *)operator new(0x20uLL);
  *(void *)__int16 v2 = &unk_1ED060A10;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8)  = result;
  *((void *)v2 + 3)  = *(void *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_5,std::allocator<anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_5>,BOOL ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2  = &unk_1ED060A10;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24)  = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8)  = result;
  return result;
}

uint64_t std::__function::__func<anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_5,std::allocator<anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_5>,BOOL ()(unsigned short,unsigned short,unsigned short)>::operator()(uint64_t a1, unsigned __int16 *a2, unsigned __int16 *a3, __int16 *a4)
{
  unsigned int v4 = *a2;
  unsigned int v5 = *a3;
  uint64_t v6 = 1;
  if (v4 <= v5 && v4 != (unsigned __int16)(v5 + 1))
  {
    uint64_t v7 = **(void **)(a1 + 8);
    unint64_t v8 = **(void **)(a1 + 16);
    unint64_t v9 = v7 + 6;
    if (v7 + 8 <= v8) {
      unint64_t v10 = (v8 - (v7 + 6)) >> 1;
    }
    else {
      unint64_t v10 = 0;
    }
    if (v8 < v9)
    {
      return 0;
    }
    else
    {
      __int16 v11 = *a4;
      uint64_t v12 = *(_WORD **)(a1 + 24);
      unsigned __int16 v13 = *a2;
      do
      {
        unsigned __int16 v14 = v13 - v4 + v11;
        uint64_t v15 = bswap32(*(unsigned __int16 *)(v7 + 4)) >> 16;
        unint64_t v16 = v9 + 2 * v15;
        if (v16 < v9 || v16 > v8)
        {
          BOOL v18 = v15 > v14 && v10 == v15;
          if (!v18) {
            return 0;
          }
        }
        else if (v15 <= v14)
        {
          return 0;
        }
        BOOL v19 = (unsigned __int16 *)(v7 + (bswap32(*(unsigned __int16 *)(v7 + 2 * v14 + 6)) >> 16));
        uint64_t v20 = v19 + 1;
        if ((unint64_t)(v19 + 1) > v8) {
          return 0;
        }
        uint64_t v21 = bswap32(*v19) >> 16;
        unint64_t v22 = (unint64_t)&v20[v21];
        unint64_t v23 = (unint64_t)(v19 + 2) <= v8 ? (v8 - (unint64_t)v20) >> 1 : 0;
        BOOL v24 = v22 <= v8 && v22 >= (unint64_t)v20;
        if (!v24 && v23 != v21) {
          return 0;
        }
        unsigned int v26 = (unsigned __int16)*v12;
        if (v26 <= v21) {
          LOWORD(v26)  = v21;
        }
        _WORD *v12 = v26;
        BOOL v18 = v5 == v13++;
      }
      while (!v18);
      return 1;
    }
  }
  return v6;
}

void *std::get_temporary_buffer[abi:nn180100]<anonymous namespace'::LookupInfo>(uint64_t a1)
{
  if (a1 < 1) {
    return 0;
  }
  if (a1 >= 0x1C71C71C71C71C7) {
    unint64_t v1 = 0x1C71C71C71C71C7;
  }
  else {
    unint64_t v1 = a1;
  }
  __int16 v2 = (const std::nothrow_t *)MEMORY[0x1E4FBA2D0];
  while (1)
  {
    __n128 result = operator new(72 * v1, v2);
    if (result) {
      break;
    }
    BOOL v4 = v1 > 1;
    v1 >>= 1;
    if (!v4) {
      return 0;
    }
  }
  return result;
}

__n128 *std::__stable_partition_impl<std::_ClassicAlgPolicy,anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_3 &,std::__wrap_iter<anonymous namespace'::LookupInfo *>,long,std::pair<anonymous namespace'::LookupInfo *,long>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = a1;
  if (a3 == 3)
  {
    uint64_t v9 = a1 + 72;
    int v8 = *(_DWORD *)(a1 + 72);
    if (v8 == 1667329140 || v8 == 1919707495 || v8 == 1919118452)
    {
      a1  = v6 + 72;
LABEL_13:
      return (__n128 *)a2;
    }
  }
  else
  {
    if (a3 == 2) {
      goto LABEL_13;
    }
    unint64_t v13 = a4;
    if (a5 >= a3)
    {
      v47[0]  = a4;
      v47[1]  = (uint64_t)&v48;
      __n128 v23 = *(__n128 *)a1;
      long long v24 = *(_OWORD *)(a1 + 32);
      *(_OWORD *)(a4 + 16)  = *(_OWORD *)(a1 + 16);
      *(_OWORD *)(a4 + 32)  = v24;
      *(__n128 *)a4  = v23;
      *(void *)(a4 + 56)  = 0;
      *(void *)(a4 + 64)  = 0;
      *(void *)(a4 + 48)  = 0;
      *(_OWORD *)(a4 + 48)  = *(_OWORD *)(a1 + 48);
      *(void *)(a4 + 64)  = *(void *)(a1 + 64);
      *(void *)(a1 + 48)  = 0;
      *(void *)(a1 + 56)  = 0;
      *(void *)(a1 + 64)  = 0;
      uint64_t v48 = 1;
      unint64_t v25 = a4 + 72;
      unsigned int v26 = (int *)(a1 + 72);
      if (a1 + 72 == a2)
      {
        unint64_t v32 = (int *)a1;
      }
      else
      {
        do
        {
          int v27 = *v26;
          BOOL v29 = *v26 == 1667329140 || v27 == 1919707495 || v27 == 1919118452;
          long long v30 = *(_OWORD *)v26;
          long long v31 = *((_OWORD *)v26 + 2);
          if (v29)
          {
            *(_OWORD *)(v6 + 16)  = *((_OWORD *)v26 + 1);
            *(_OWORD *)(v6 + 32)  = v31;
            *(_OWORD *)uint64_t v6 = v30;
            std::vector<unsigned short>::__move_assign(v6 + 48, (__n128 *)v26 + 3);
            v6 += 72;
          }
          else
          {
            *(_OWORD *)(v25 + 16)  = *((_OWORD *)v26 + 1);
            *(_OWORD *)(v25 + 32)  = v31;
            *(_OWORD *)unint64_t v25 = v30;
            *(void *)(v25 + 56)  = 0;
            *(void *)(v25 + 64)  = 0;
            *(void *)(v25 + 48)  = 0;
            *(_OWORD *)(v25 + 48)  = *((_OWORD *)v26 + 3);
            *(void *)(v25 + 64)  = *((void *)v26 + 8);
            *((void *)v26 + 6)  = 0;
            *((void *)v26 + 7)  = 0;
            *((void *)v26 + 8)  = 0;
            ++v48;
            v25 += 72;
          }
          v26 += 18;
        }
        while (v26 != (int *)a2);
        unint64_t v32 = v26 - 18;
      }
      __n128 v34 = *(__n128 *)a2;
      long long v35 = *(_OWORD *)(a2 + 32);
      *(_OWORD *)(v6 + 16)  = *(_OWORD *)(a2 + 16);
      *(_OWORD *)(v6 + 32)  = v35;
      *(__n128 *)uint64_t v6 = v34;
      std::vector<unsigned short>::__move_assign(v6 + 48, (__n128 *)(v32 + 30));
      uint64_t v9 = v6 + 72;
      if (v25 > v13)
      {
        unsigned int v36 = (_OWORD *)(v6 + 72);
        do
        {
          long long v37 = *(_OWORD *)v13;
          long long v38 = *(_OWORD *)(v13 + 32);
          v36[1]  = *(_OWORD *)(v13 + 16);
          v36[2]  = v38;
          *unsigned int v36 = v37;
          std::vector<unsigned short>::__move_assign((uint64_t)(v36 + 3), (__n128 *)(v13 + 48));
          v13 += 72;
          unsigned int v36 = (_OWORD *)((char *)v36 + 72);
        }
        while (v13 < v25);
      }
    }
    else
    {
      if (a3 >= 0) {
        uint64_t v14 = a3;
      }
      else {
        uint64_t v14 = a3 + 1;
      }
      uint64_t v15 = v14 >> 1;
      uint64_t v16 = 9 * (v14 >> 1);
      uint64_t v17 = (__n128 *)(a1 + 8 * v16);
      uint64_t v18 = 8 * v16 - 72;
      for (uint64_t i = v15; ; --i)
      {
        int v20 = *(_DWORD *)(a1 + v18);
        if (v20 == 1667329140 || v20 == 1919118452 || v20 == 1919707495)
        {
          goto LABEL_47;
        }
        if (!v18) {
          break;
        }
        v18 -= 72;
      }
      unint64_t v33 = (__n128 *)a1;
LABEL_47:
      long long v39 = (__n128 *)(a2 + 72);
      uint64_t v40 = a3 - v15;
      uint64_t v41 = v6 + 72 * v15;
      for (uint64_t j = v41 + 72; ; j += 72)
      {
        int v43 = *(_DWORD *)(j - 72);
        BOOL v44 = v43 == 1667329140 || v43 == 1919707495;
        if (!v44 && v43 != 1919118452) {
          break;
        }
        if (j == a2) {
        --v40;
        }
        v41 += 72;
      }
    }
  }
  return (__n128 *)v9;
}

__n128 std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<std::__wrap_iter<anonymous namespace'::LookupInfo *> &,std::__wrap_iter<anonymous namespace'::LookupInfo *> &>(__n128 *a1, __n128 *a2)
{
  __n128 v9 = *a1;
  __n128 v10 = a1[1];
  __n128 v8 = a1[3];
  __n128 v11 = a1[2];
  unint64_t v3 = a1[4].n128_u64[0];
  a1[3].n128_u64[0]  = 0;
  a1[3].n128_u64[1]  = 0;
  a1[4].n128_u64[0]  = 0;
  __n128 v4 = *a2;
  __n128 v5 = a2[2];
  a1[1]  = a2[1];
  a1[2]  = v5;
  *a1  = v4;
  std::vector<unsigned short>::__move_assign((uint64_t)&a1[3], a2 + 3);
  *a2  = v9;
  a2[1]  = v10;
  a2[2]  = v11;
  uint64_t v6 = (void *)a2[3].n128_u64[0];
  if (v6)
  {
    a2[3].n128_u64[1]  = (unint64_t)v6;
    operator delete(v6);
  }
  __n128 result = v8;
  a2[3]  = v8;
  a2[4].n128_u64[0]  = v3;
  return result;
}

uint64_t *std::unique_ptr<anonymous namespace'::LookupInfo,std::__destruct_n &>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1  = 0;
  if (v2)
  {
    unint64_t v3 = (unint64_t *)a1[1];
    unint64_t v4 = *v3;
    if (*v3)
    {
      unint64_t v5 = 0;
      uint64_t v6 = (void *)(v2 + 56);
      do
      {
        uint64_t v7 = (void *)*(v6 - 1);
        if (v7)
        {
          *uint64_t v6 = v7;
          operator delete(v7);
          unint64_t v4 = *v3;
        }
        ++v5;
        v6 += 9;
      }
      while (v5 < v4);
    }
  }
  return a1;
}

__n128 *std::__rotate[abi:nn180100]<std::_ClassicAlgPolicy,std::__wrap_iter<anonymous namespace'::LookupInfo *>,std::__wrap_iter<anonymous namespace'::LookupInfo *>>(__n128 *a1, __n128 *a2, __n128 *a3)
{
  unint64_t v3 = a3;
  if (a1 != a2)
  {
    unint64_t v4 = a2;
    unint64_t v5 = a1;
    if (a2 != a3)
    {
      unint64_t v5 = (__n128 *)((char *)v5 + 72);
      for (uint64_t i = (__n128 *)((char *)v4 + 72); i != v3; uint64_t i = (__n128 *)((char *)i + 72))
      {
        if (v5 == v4) {
          unint64_t v4 = i;
        }
        unint64_t v5 = (__n128 *)((char *)v5 + 72);
      }
      if (v5 != v4)
      {
        uint64_t v7 = v5;
        __n128 v8 = v4;
        do
        {
          while (1)
          {
            uint64_t v7 = (__n128 *)((char *)v7 + 72);
            unint64_t v4 = (__n128 *)((char *)v4 + 72);
            if (v4 == v3) {
              break;
            }
            if (v7 == v8) {
              __n128 v8 = v4;
            }
          }
          unint64_t v4 = v8;
        }
        while (v7 != v8);
      }
    }
    return v5;
  }
  return v3;
}

__n128 *std::__stable_partition_impl<std::_ClassicAlgPolicy,anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_6 &,std::__wrap_iter<anonymous namespace'::LookupInfo *>,long,std::pair<anonymous namespace'::LookupInfo *,long>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = a1;
  if (a3 == 3)
  {
    uint64_t v8 = a1 + 72;
    if (*(_DWORD *)(a1 + 72) != 1919707495)
    {
      return (__n128 *)v8;
    }
    a1  = v6 + 72;
    goto LABEL_6;
  }
  if (a3 == 2)
  {
LABEL_6:
    return (__n128 *)a2;
  }
  unint64_t v10 = a4;
  if (a5 >= a3)
  {
    v39[0]  = a4;
    v39[1]  = (uint64_t)&v40;
    __n128 v16 = *(__n128 *)a1;
    long long v17 = *(_OWORD *)(a1 + 32);
    *(_OWORD *)(a4 + 16)  = *(_OWORD *)(a1 + 16);
    *(_OWORD *)(a4 + 32)  = v17;
    *(__n128 *)a4  = v16;
    *(void *)(a4 + 56)  = 0;
    *(void *)(a4 + 64)  = 0;
    *(void *)(a4 + 48)  = 0;
    *(_OWORD *)(a4 + 48)  = *(_OWORD *)(a1 + 48);
    *(void *)(a4 + 64)  = *(void *)(a1 + 64);
    *(void *)(a1 + 48)  = 0;
    *(void *)(a1 + 56)  = 0;
    *(void *)(a1 + 64)  = 0;
    uint64_t v40 = 1;
    unint64_t v18 = a4 + 72;
    BOOL v19 = (long long *)(a1 + 72);
    if (a1 + 72 == a2)
    {
      uint64_t v23 = a1;
    }
    else
    {
      do
      {
        int v20 = (__n128 *)(v19 + 3);
        long long v21 = *v19;
        long long v22 = v19[2];
        if (*(_DWORD *)v19 == 1919707495)
        {
          *(_OWORD *)(v6 + 16)  = v19[1];
          *(_OWORD *)(v6 + 32)  = v22;
          *(_OWORD *)uint64_t v6 = v21;
          std::vector<unsigned short>::__move_assign(v6 + 48, v20);
          v6 += 72;
        }
        else
        {
          *(_OWORD *)(v18 + 16)  = v19[1];
          *(_OWORD *)(v18 + 32)  = v22;
          *(_OWORD *)unint64_t v18 = v21;
          *(void *)(v18 + 56)  = 0;
          *(void *)(v18 + 64)  = 0;
          *(void *)(v18 + 48)  = 0;
          *(_OWORD *)(v18 + 48)  = v19[3];
          *(void *)(v18 + 64)  = *((void *)v19 + 8);
          v20->n128_u64[0]  = 0;
          *((void *)v19 + 7)  = 0;
          *((void *)v19 + 8)  = 0;
          ++v40;
          v18 += 72;
        }
        BOOL v19 = (long long *)((char *)v19 + 72);
      }
      while (v19 != (long long *)a2);
      uint64_t v23 = (uint64_t)v19 - 72;
    }
    __n128 v28 = *(__n128 *)a2;
    long long v29 = *(_OWORD *)(a2 + 32);
    *(_OWORD *)(v6 + 16)  = *(_OWORD *)(a2 + 16);
    *(_OWORD *)(v6 + 32)  = v29;
    *(__n128 *)uint64_t v6 = v28;
    std::vector<unsigned short>::__move_assign(v6 + 48, (__n128 *)(v23 + 120));
    uint64_t v8 = v6 + 72;
    if (v18 > v10)
    {
      long long v30 = (_OWORD *)(v6 + 72);
      do
      {
        long long v31 = *(_OWORD *)v10;
        long long v32 = *(_OWORD *)(v10 + 32);
        v30[1]  = *(_OWORD *)(v10 + 16);
        v30[2]  = v32;
        *long long v30 = v31;
        std::vector<unsigned short>::__move_assign((uint64_t)(v30 + 3), (__n128 *)(v10 + 48));
        v10 += 72;
        long long v30 = (_OWORD *)((char *)v30 + 72);
      }
      while (v10 < v18);
    }
  }
  else
  {
    if (a3 >= 0) {
      uint64_t v11 = a3;
    }
    else {
      uint64_t v11 = a3 + 1;
    }
    uint64_t v12 = v11 >> 1;
    unint64_t v13 = (__n128 *)(a1 + 72 * (v11 >> 1));
    uint64_t v14 = (uint64_t)&v13[-5].n128_i64[1];
    if (v13[-5].n128_u32[2] == 1919707495)
    {
      uint64_t v15 = v11 >> 1;
LABEL_24:
    }
    else
    {
      uint64_t v24 = 72 * v12;
      uint64_t v15 = v12;
      while (1)
      {
        uint64_t v25 = v24 - 72;
        if (v24 == 72) {
          break;
        }
        --v15;
        int v26 = *(_DWORD *)(a1 + v24 - 144);
        v24 -= 72;
        if (v26 == 1919707495)
        {
          uint64_t v14 = a1 + v25 - 72;
          goto LABEL_24;
        }
      }
      int v27 = (__n128 *)a1;
    }
    uint64_t v33 = a3 - v12;
    if (v13->n128_u32[0] == 1919707495)
    {
      __n128 v34 = (__n128 *)(a2 + 72);
      long long v35 = (__n128 *)(v6 + 72 * v12);
      unsigned int v36 = &v35[4].n128_u32[2];
      while (v36 != (unsigned __int32 *)a2)
      {
        --v33;
        unsigned __int32 v37 = *v36;
        v36 += 18;
        long long v35 = (__n128 *)((char *)v35 + 72);
        if (v37 != 1919707495) {
          goto LABEL_37;
        }
      }
    }
    else
    {
      long long v35 = v13;
LABEL_37:
    }
  }
  return (__n128 *)v8;
}

char *TInlineBufferAllocator<MortFeatureEntry,30ul>::allocate(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = (char *)(a1 + 360);
  __n128 result = *(char **)(a1 + 360);
  unint64_t v4 = &result[12 * a2];
  if (v4 <= v2)
  {
    *(void *)uint64_t v2 = v4;
  }
  else
  {
    if (a2 >= 0x1555555555555556) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    return (char *)operator new(12 * a2);
  }
  return result;
}

uint64_t std::__split_buffer<MortFeatureEntry,TInlineBufferAllocator<MortFeatureEntry,30ul> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != *(void *)(a1 + 8)) {
    *(void *)(a1 + 16)  = (v2 - *(void *)(a1 + 8) - 12) % 0xCuLL + *(void *)(a1 + 8);
  }
  unint64_t v3 = *(void **)a1;
  if (*(void *)a1)
  {
    unint64_t v4 = *(void *)(a1 + 32);
    unint64_t v5 = (void *)(v4 + 360);
    if (v4 <= (unint64_t)v3 && v5 > v3)
    {
      if (*(void *)(a1 + 24) == *v5) {
        *unint64_t v5 = v3;
      }
    }
    else
    {
      operator delete(v3);
    }
  }
  return a1;
}

void anonymous namespace'::MorxSubtableBuilder::From(atomic_ullong *this, unint64_t a2, int a3, int a4)
{
  unint64_t v5 = this;
  *(_DWORD *)this  = a3;
  *((_DWORD *)this + 1)  = a4;
  id Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);

  CFDataRef explicit = (__CFData *)atomic_load_explicit(v5, memory_order_acquire);
  if (a2 <= 0x10000) {
    CFIndex v7 = (a2 + 7) >> 3;
  }
  else {
    CFIndex v7 = 0x2000;
  }
  CFDataSetLength(explicit, v7);
}

void *std::__function::__func<anonymous namespace'::MorxSwashSubtableBuilder::FromLookupSubtable(long,unsigned int,unsigned int,unsigned int,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,unsigned short)::$_0,std::allocator<anonymous namespace'::MorxSwashSubtableBuilder::FromLookupSubtable(long,unsigned int,unsigned int,unsigned int,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,unsigned short)::$_0>,BOOL ()(unsigned short)>::~__func(void *a1)
{
  *a1  = &unk_1ED060AE8;
  uint64_t v2 = (void *)a1[1];
  if (v2)
  {
    a1[2]  = v2;
    operator delete(v2);
  }
  return a1;
}

void std::__function::__func<anonymous namespace'::MorxSwashSubtableBuilder::FromLookupSubtable(long,unsigned int,unsigned int,unsigned int,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,unsigned short)::$_0,std::allocator<anonymous namespace'::MorxSwashSubtableBuilder::FromLookupSubtable(long,unsigned int,unsigned int,unsigned int,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,unsigned short)::$_0>,BOOL ()(unsigned short)>::~__func(void *a1)
{
  *a1  = &unk_1ED060AE8;
  uint64_t v2 = (void *)a1[1];
  if (v2)
  {
    a1[2]  = v2;
    operator delete(v2);
  }

  JUMPOUT(0x1853275C0);
}

void *std::__function::__func<anonymous namespace'::MorxSwashSubtableBuilder::FromLookupSubtable(long,unsigned int,unsigned int,unsigned int,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,unsigned short)::$_0,std::allocator<anonymous namespace'::MorxSwashSubtableBuilder::FromLookupSubtable(long,unsigned int,unsigned int,unsigned int,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,unsigned short)::$_0>,BOOL ()(unsigned short)>::__clone(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x20uLL);
  *uint64_t v2 = &unk_1ED060AE8;
  std::vector<unsigned short>::vector(v2 + 1, v1);
  return v2;
}

void *std::__function::__func<anonymous namespace'::MorxSwashSubtableBuilder::FromLookupSubtable(long,unsigned int,unsigned int,unsigned int,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,unsigned short)::$_0,std::allocator<anonymous namespace'::MorxSwashSubtableBuilder::FromLookupSubtable(long,unsigned int,unsigned int,unsigned int,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,unsigned short)::$_0>,BOOL ()(unsigned short)>::__clone(uint64_t a1, void *a2)
{
  *a2  = &unk_1ED060AE8;
  return std::vector<unsigned short>::vector(a2 + 1, a1 + 8);
}

void std::__function::__func<anonymous namespace'::MorxSwashSubtableBuilder::FromLookupSubtable(long,unsigned int,unsigned int,unsigned int,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,unsigned short)::$_0,std::allocator<anonymous namespace'::MorxSwashSubtableBuilder::FromLookupSubtable(long,unsigned int,unsigned int,unsigned int,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,unsigned short)::$_0>,BOOL ()(unsigned short)>::destroy(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16)  = v2;
    operator delete(v2);
  }
}

void std::__function::__func<anonymous namespace'::MorxSwashSubtableBuilder::FromLookupSubtable(long,unsigned int,unsigned int,unsigned int,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,unsigned short)::$_0,std::allocator<anonymous namespace'::MorxSwashSubtableBuilder::FromLookupSubtable(long,unsigned int,unsigned int,unsigned int,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,unsigned short)::$_0>,BOOL ()(unsigned short)>::destroy_deallocate(void *__p)
{
  uint64_t v2 = (void *)__p[1];
  if (v2)
  {
    __p[2]  = v2;
    operator delete(v2);
  }

  operator delete(__p);
}

BOOL std::__function::__func<anonymous namespace'::MorxSwashSubtableBuilder::FromLookupSubtable(long,unsigned int,unsigned int,unsigned int,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,unsigned short)::$_0,std::allocator<anonymous namespace'::MorxSwashSubtableBuilder::FromLookupSubtable(long,unsigned int,unsigned int,unsigned int,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,unsigned short)::$_0>,BOOL ()(unsigned short)>::operator()(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t v2 = *(unsigned __int16 **)(a1 + 8);
  unint64_t v3 = *(unsigned __int16 **)(a1 + 16);
  if (v3 == v2) {
    return 1;
  }
  unsigned int v4 = *a2;
  unint64_t v5 = v3 - v2;
  do
  {
    unint64_t v6 = v5 >> 1;
    CFIndex v7 = &v2[v5 >> 1];
    unsigned int v9 = *v7;
    uint64_t v8 = v7 + 1;
    v5 += ~(v5 >> 1);
    if (v9 < v4) {
      uint64_t v2 = v8;
    }
    else {
      unint64_t v5 = v6;
    }
  }
  while (v5);
  return v2 == v3 || *v2 > v4;
}

uint64_t std::__split_buffer<TCFRef<__CFData *>,TInlineBufferAllocator<TCFRef<__CFData *>,30ul> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16)  = i - 8;
  }
  unsigned int v4 = *(void **)a1;
  if (*(void *)a1)
  {
    unint64_t v5 = *(void *)(a1 + 32);
    unint64_t v6 = (void *)(v5 + 240);
    if (v5 <= (unint64_t)v4 && v6 > v4)
    {
      if (*(void *)(a1 + 24) == *v6) {
        *unint64_t v6 = v4;
      }
    }
    else
    {
      operator delete(v4);
    }
  }
  return a1;
}

void anonymous namespace'::MorxSubtableBuilder::CreateSubtableDataInternal(_anonymous_namespace_::MorxSubtableBuilder *this, unsigned int *a2, int a3)
{
  unsigned int v5 = a3 + 12;
  id Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (a3 + 12));
  *(_DWORD *)bytes  = bswap32(v5);
  CFDataAppendBytes(Mutable, bytes, 4);
  *(_DWORD *)uint64_t v8 = bswap32(*a2);
  CFDataAppendBytes(Mutable, v8, 4);
  *(_DWORD *)unsigned int v9 = bswap32(a2[1]);
  CFDataAppendBytes(Mutable, v9, 4);
  *(void *)this  = Mutable;
}

void std::__function::__func<AddPrevLigaturesFromSingleSubstitutionLookupTable(anonymous namespace'::ArabicLookups &,__CFData const*)::$_0,std::allocator<AddPrevLigaturesFromSingleSubstitutionLookupTable(anonymous namespace'::ArabicLookups &,__CFData const*)::$_0>,void ()(unsigned short,unsigned short,unsigned short)>::~__func()
{
}

void *std::__function::__func<AddPrevLigaturesFromSingleSubstitutionLookupTable(anonymous namespace'::ArabicLookups &,__CFData const*)::$_0,std::allocator<AddPrevLigaturesFromSingleSubstitutionLookupTable(anonymous namespace'::ArabicLookups &,__CFData const*)::$_0>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1ED060788;
  result[1]  = v3;
  return result;
}

uint64_t std::__function::__func<AddPrevLigaturesFromSingleSubstitutionLookupTable(anonymous namespace'::ArabicLookups &,__CFData const*)::$_0,std::allocator<AddPrevLigaturesFromSingleSubstitutionLookupTable(anonymous namespace'::ArabicLookups &,__CFData const*)::$_0>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2  = &unk_1ED060788;
  a2[1]  = v2;
  return result;
}

void std::__function::__func<AddPrevLigaturesFromSingleSubstitutionLookupTable(anonymous namespace'::ArabicLookups &,__CFData const*)::$_0,std::allocator<AddPrevLigaturesFromSingleSubstitutionLookupTable(anonymous namespace'::ArabicLookups &,__CFData const*)::$_0>,void ()(unsigned short,unsigned short,unsigned short)>::operator()(uint64_t a1, unsigned __int16 *a2, unsigned __int16 *a3, __int16 *a4)
{
  unsigned int v4 = *a2;
  unsigned int v5 = *a3;
  if (v4 <= v5 && v4 != (unsigned __int16)(v5 + 1))
  {
    __int16 v7 = *a4;
    do
    {
      unint64_t v13 = 0xAAAAAAAAAAAAAAAALL;
      v12[0]  = 0xAAAAAAAAAAAAAAAALL;
      uint64_t v15 = v12;
      v12[1]  = (char *)v12 + 2;
      LOWORD(v12[0])  = v4;
      unsigned int v9 = v12;
      unint64_t v10 = (char *)v12 + 2;
      uint64_t v11 = (char *)v12 + 2;
      memset(v14, 0, sizeof(v14));
      std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,3ul> &>::~__split_buffer((uint64_t)v14);
      unint64_t v10 = (char *)v12 + 2;
      LOWORD(v13)  = v7;
      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v9);
    }
    while (v5 != (unsigned __int16)v4++);
  }
}

void std::__function::__func<InsertionInputsForMultipleSubst(long,OTL::LookupSubtable const*,BOOL,void const*,TInlineVector<anonymous namespace'::InsertionInput,30ul> &)::$_0,std::allocator<InsertionInputsForMultipleSubst(long,OTL::LookupSubtable const*,BOOL,void const*,TInlineVector<anonymous namespace'::InsertionInput,30ul> &)::$_0>,BOOL ()(unsigned short,unsigned short,unsigned short)>::~__func()
{
}

__n128 std::__function::__func<InsertionInputsForMultipleSubst(long,OTL::LookupSubtable const*,BOOL,void const*,TInlineVector<anonymous namespace'::InsertionInput,30ul> &)::$_0,std::allocator<InsertionInputsForMultipleSubst(long,OTL::LookupSubtable const*,BOOL,void const*,TInlineVector<anonymous namespace'::InsertionInput,30ul> &)::$_0>,BOOL ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_1ED0606F8;
  *(_OWORD *)(v2 + 8)  = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24)  = result;
  return result;
}

__n128 std::__function::__func<InsertionInputsForMultipleSubst(long,OTL::LookupSubtable const*,BOOL,void const*,TInlineVector<anonymous namespace'::InsertionInput,30ul> &)::$_0,std::allocator<InsertionInputsForMultipleSubst(long,OTL::LookupSubtable const*,BOOL,void const*,TInlineVector<anonymous namespace'::InsertionInput,30ul> &)::$_0>,BOOL ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2  = &unk_1ED0606F8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24)  = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8)  = result;
  return result;
}

uint64_t std::__function::__func<InsertionInputsForMultipleSubst(long,OTL::LookupSubtable const*,BOOL,void const*,TInlineVector<anonymous namespace'::InsertionInput,30ul> &)::$_0,std::allocator<InsertionInputsForMultipleSubst(long,OTL::LookupSubtable const*,BOOL,void const*,TInlineVector<anonymous namespace'::InsertionInput,30ul> &)::$_0>,BOOL ()(unsigned short,unsigned short,unsigned short)>::operator()(uint64_t a1, unsigned __int16 *a2, unsigned __int16 *a3, __int16 *a4)
{
  unsigned int v5 = *a2;
  unsigned int v6 = *a3;
  uint64_t result = 1;
  if (v5 <= v6 && v5 != (unsigned __int16)(v6 + 1))
  {
    __int16 v79 = *a4;
    unsigned __int16 v8 = *a2;
    uint64_t v78 = a1;
    unsigned int v76 = *a3;
    unsigned __int16 v77 = *a2;
    while (1)
    {
      uint64_t v9 = **(void **)(a1 + 8);
      unint64_t v10 = **(void **)(a1 + 16);
      unint64_t v11 = v9 + 6;
      if (v9 + 6 > v10) {
        return 0;
      }
      unsigned __int16 v12 = v8 - v5 + v79;
      uint64_t v13 = bswap32(*(unsigned __int16 *)(v9 + 4)) >> 16;
      unint64_t v14 = v11 + 2 * v13;
      if (v14 < v11 || v14 > v10)
      {
        unint64_t v16 = (v10 - v11) >> 1;
        if (v9 + 8 > v10) {
          unint64_t v16 = 0;
        }
        BOOL v17 = v13 > v12 && v16 == v13;
        if (!v17) {
          return 0;
        }
      }
      else if (v13 <= v12)
      {
        return 0;
      }
      unint64_t v18 = (_WORD *)(v9 + (bswap32(*(unsigned __int16 *)(v9 + 2 * v12 + 6)) >> 16));
      BOOL v19 = v18 + 1;
      if ((unint64_t)(v18 + 1) > v10) {
        return 0;
      }
      uint64_t v20 = __rev16((unsigned __int16)*v18);
      long long v21 = &v19[v20];
      unint64_t v22 = (unint64_t)(v18 + 2) <= v10 ? (v10 - (unint64_t)v19) >> 1 : 0;
      BOOL v23 = (unint64_t)v21 <= v10 && v21 >= v19;
      if (!v23 && v22 != v20) {
        return 0;
      }
      if (*v18) {
        break;
      }
LABEL_107:
      BOOL v17 = v6 == v8++;
      if (v17) {
        return 1;
      }
    }
    v82[0]  = 0xAAAAAAAAAAAAAAAALL;
    v82[1]  = v82;
    unint64_t v83 = 0xAAAAAAAAAAAAAAAALL;
    long long v80 = 0xAAAAAAAAAAAAAAAALL;
    long long v81 = 0uLL;
    if (**(unsigned char **)(a1 + 24))
    {
      LOWORD(v83)  = bswap32(*v19) >> 16;
      uint64_t v25 = 0;
      uint64_t v26 = (v20 - 1);
      if (v20 != 1)
      {
        do
        {
          unsigned int v27 = bswap32((unsigned __int16)v18[v26 + 1]) >> 16;
          if ((unint64_t)v25 >= *((void *)&v81 + 1))
          {
            __n128 v28 = (unsigned char *)*((void *)&v80 + 1);
            uint64_t v29 = (uint64_t)&v25[-*((void *)&v80 + 1)];
            if ((uint64_t)&v25[-*((void *)&v80 + 1)] <= -3) {
              goto LABEL_112;
            }
            uint64_t v30 = v29 >> 1;
            if (*((void *)&v81 + 1) - *((void *)&v80 + 1) <= (unint64_t)((v29 >> 1) + 1)) {
              uint64_t v31 = v30 + 1;
            }
            else {
              uint64_t v31 = *((void *)&v81 + 1) - *((void *)&v80 + 1);
            }
            if (*((void *)&v81 + 1) - *((void *)&v80 + 1) >= 0x7FFFFFFFFFFFFFFEuLL) {
              uint64_t v32 = 0x7FFFFFFFFFFFFFFFLL;
            }
            else {
              uint64_t v32 = v31;
            }
            unint64_t v88 = v82;
            if (v32)
            {
              uint64_t v33 = (char *)TInlineBufferAllocator<unsigned short,3ul>::allocate((uint64_t)v82, v32);
              __n128 v28 = (unsigned char *)*((void *)&v80 + 1);
              uint64_t v25 = (unsigned char *)v81;
            }
            else
            {
              uint64_t v33 = 0;
            }
            __n128 v34 = &v33[2 * v30];
            *(_WORD *)__n128 v34 = v27;
            if (v25 == v28)
            {
              unsigned int v36 = &v33[2 * v30];
            }
            else
            {
              long long v35 = v25;
              unsigned int v36 = &v33[2 * v30];
              do
              {
                __int16 v37 = *((_WORD *)v35 - 1);
                v35 -= 2;
                *((_WORD *)v36 - 1)  = v37;
                v36 -= 2;
              }
              while (v35 != v28);
            }
            long long v38 = v34 + 2;
            *((void *)&v80 + 1)  = v36;
            *(void *)&long long v81 = v34 + 2;
            uint64_t v39 = *((void *)&v81 + 1);
            *((void *)&v81 + 1)  = &v33[2 * v32];
            uint64_t v86 = v25;
            uint64_t v87 = v39;
            uint64_t v84 = v28;
            uint64_t v85 = v28;
            std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,3ul> &>::~__split_buffer((uint64_t)&v84);
            uint64_t v25 = v38;
          }
          else
          {
            *(_WORD *)uint64_t v25 = v27;
            v25 += 2;
          }
          *(void *)&long long v81 = v25;
          --v26;
        }
        while (v26);
      }
    }
    else
    {
      uint64_t v40 = (v20 - 1);
      if (v20 == 1)
      {
        uint64_t v40 = 0;
        uint64_t v25 = 0;
      }
      else
      {
        uint64_t v25 = 0;
        uint64_t v41 = 0;
        do
        {
          unsigned int v42 = bswap32((unsigned __int16)v18[v41 + 1]) >> 16;
          if ((unint64_t)v25 >= *((void *)&v81 + 1))
          {
            int v43 = (unsigned char *)*((void *)&v80 + 1);
            uint64_t v44 = (uint64_t)&v25[-*((void *)&v80 + 1)];
            if ((uint64_t)&v25[-*((void *)&v80 + 1)] <= -3) {
              goto LABEL_112;
            }
            uint64_t v45 = v44 >> 1;
            if (*((void *)&v81 + 1) - *((void *)&v80 + 1) <= (unint64_t)((v44 >> 1) + 1)) {
              uint64_t v46 = v45 + 1;
            }
            else {
              uint64_t v46 = *((void *)&v81 + 1) - *((void *)&v80 + 1);
            }
            if (*((void *)&v81 + 1) - *((void *)&v80 + 1) >= 0x7FFFFFFFFFFFFFFEuLL) {
              uint64_t v47 = 0x7FFFFFFFFFFFFFFFLL;
            }
            else {
              uint64_t v47 = v46;
            }
            unint64_t v88 = v82;
            if (v47)
            {
              uint64_t v48 = (char *)TInlineBufferAllocator<unsigned short,3ul>::allocate((uint64_t)v82, v47);
              int v43 = (unsigned char *)*((void *)&v80 + 1);
              uint64_t v25 = (unsigned char *)v81;
            }
            else
            {
              uint64_t v48 = 0;
            }
            unint64_t v49 = &v48[2 * v45];
            *(_WORD *)unint64_t v49 = v42;
            if (v25 == v43)
            {
              unint64_t v51 = &v48[2 * v45];
            }
            else
            {
              unint64_t v50 = v25;
              unint64_t v51 = &v48[2 * v45];
              do
              {
                __int16 v52 = *((_WORD *)v50 - 1);
                v50 -= 2;
                *((_WORD *)v51 - 1)  = v52;
                v51 -= 2;
              }
              while (v50 != v43);
            }
            uint64_t v53 = v49 + 2;
            *((void *)&v80 + 1)  = v51;
            *(void *)&long long v81 = v49 + 2;
            uint64_t v54 = *((void *)&v81 + 1);
            *((void *)&v81 + 1)  = &v48[2 * v47];
            uint64_t v86 = v25;
            uint64_t v87 = v54;
            uint64_t v84 = v43;
            uint64_t v85 = v43;
            std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,3ul> &>::~__split_buffer((uint64_t)&v84);
            uint64_t v25 = v53;
          }
          else
          {
            *(_WORD *)uint64_t v25 = v42;
            v25 += 2;
          }
          *(void *)&long long v81 = v25;
          ++v41;
        }
        while (v41 != v40);
      }
      LOWORD(v83)  = bswap32((unsigned __int16)v18[v40 + 1]) >> 16;
    }
    a1  = v78;
    uint64_t v55 = *(char ***)(v78 + 32);
    int v57 = (unsigned __int16 *)v55[1];
    unint64_t v56 = (unint64_t)v55[2];
    if ((unint64_t)v57 < v56)
    {
      *int v57 = v8;
      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>((uint64_t)(v57 + 4), *((unsigned char **)&v80 + 1), v25);
      v57[24]  = v83;
      uint8x8_t v58 = (char *)(v57 + 28);
      unsigned int v6 = v76;
      LOWORD(v5)  = v77;
LABEL_106:
      v55[1]  = v58;
      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v80 + 8);
      goto LABEL_107;
    }
    uint64_t v59 = 0x6DB6DB6DB6DB6DB7 * (((char *)v57 - *v55) >> 3);
    unint64_t v60 = v59 + 1;
    if ((unint64_t)(v59 + 1) > 0x492492492492492) {
LABEL_112:
    }
      abort();
    unint64_t v61 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v56 - (void)*v55) >> 3);
    if (2 * v61 > v60) {
      unint64_t v60 = 2 * v61;
    }
    if (v61 >= 0x249249249249249) {
      unint64_t v62 = 0x492492492492492;
    }
    else {
      unint64_t v62 = v60;
    }
    if (v62)
    {
      uint64_t v63 = v55[213];
      unint64_t v64 = (unint64_t)&v63[56 * v62];
      if (v64 <= (unint64_t)(v55 + 213))
      {
        v55[213]  = (char *)v64;
      }
      else
      {
        if (v62 > 0x492492492492492) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        uint64_t v63 = (char *)operator new(56 * v62);
      }
    }
    else
    {
      uint64_t v63 = 0;
    }
    int64x2_t v65 = &v63[56 * v59];
    uint64_t v66 = &v63[56 * v62];
    *(_WORD *)int64x2_t v65 = v8;
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>((uint64_t)(v65 + 8), *((unsigned char **)&v80 + 1), v25);
    *((_WORD *)v65 + 24)  = v83;
    uint8x8_t v58 = v65 + 56;
    __int16 v68 = *v55;
    __int16 v67 = v55[1];
    if (v67 == *v55)
    {
      char *v55 = v65;
      v55[1]  = v58;
      unint64_t v72 = v55[2];
      v55[2]  = v66;
    }
    else
    {
      uint64_t v75 = v65 + 56;
      uint64_t v69 = 0;
      do
      {
        *(_WORD *)&v65[v69 - 56]  = *(_WORD *)&v67[v69 - 56];
        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>((uint64_t)&v65[v69 - 48], *(unsigned char **)&v67[v69 - 48], *(unsigned char **)&v67[v69 - 40]);
        *(_WORD *)&v65[v69 - 8]  = *(_WORD *)&v67[v69 - 8];
        v69 -= 56;
      }
      while (&v67[v69] != v68);
      __int16 v67 = *v55;
      float v70 = v55[1];
      uint64_t v71 = &v65[v69];
      uint8x8_t v58 = v65 + 56;
      char *v55 = v71;
      v55[1]  = v75;
      unint64_t v72 = v55[2];
      v55[2]  = v66;
      if (v70 != v67)
      {
        a1  = v78;
        unsigned int v6 = v76;
        LOWORD(v5)  = v77;
        do
        {
          unint64_t v73 = v70 - 56;
          std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)(v70 - 48));
          float v70 = v73;
        }
        while (v73 != v67);
        uint8x8_t v58 = v75;
        if (!v67) {
          goto LABEL_106;
        }
        goto LABEL_101;
      }
    }
    a1  = v78;
    unsigned int v6 = v76;
    LOWORD(v5)  = v77;
    if (!v67) {
      goto LABEL_106;
    }
LABEL_101:
    if (v55 + 3 > (char **)v67 || (long long v74 = v55 + 213, v55 + 213 <= (char **)v67))
    {
      operator delete(v67);
    }
    else if (v72 == *v74)
    {
      *long long v74 = v67;
    }
    goto LABEL_106;
  }
  return result;
}

void *TInlineBufferAllocator<unsigned short,3ul>::allocate(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void **)(a1 + 8);
  unint64_t v4 = (unint64_t)result + 2 * a2;
  if (v4 <= a1 + 6)
  {
    *(void *)(a1 + 8)  = v4;
  }
  else
  {
    if (a2 < 0) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    return operator new(2 * a2);
  }
  return result;
}

uint64_t std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,3ul> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3) {
    *(void *)(a1 + 16)  = v2 + ((v3 - v2 + 1) & 0xFFFFFFFFFFFFFFFELL);
  }
  unint64_t v4 = *(void **)a1;
  if (*(void *)a1)
  {
    unint64_t v5 = *(void *)(a1 + 32);
    if (v5 <= (unint64_t)v4 && v5 + 6 > (unint64_t)v4)
    {
      if (*(void *)(a1 + 24) == *(void *)(v5 + 8)) {
        *(void *)(v5 + 8)  = v4;
      }
    }
    else
    {
      operator delete(v4);
    }
  }
  return a1;
}

uint64_t std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>(uint64_t a1, unsigned char *a2, unsigned char *a3)
{
  *(void *)a1  = 0;
  *(void *)(a1 + 8)  = 0;
  *(void *)(a1 + 16)  = 0;
  *(void *)(a1 + 32)  = a1 + 24;
  int64_t v4 = a3 - a2;
  if (a3 != a2)
  {
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__vallocate[abi:nn180100]((void *)a1, v4 >> 1);
    uint64_t v7 = *(void *)(a1 + 8);
    if (a3 != a2) {
      memmove(*(void **)(a1 + 8), a2, v4);
    }
    *(void *)(a1 + 8)  = v7 + 2 * (v4 >> 1);
  }
  return a1;
}

char *std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__vallocate[abi:nn180100](void *a1, uint64_t a2)
{
  if (a2 < 0) {
    abort();
  }
  uint64_t result = (char *)TInlineBufferAllocator<unsigned short,3ul>::allocate((uint64_t)(a1 + 3), a2);
  *a1  = result;
  a1[1]  = result;
  a1[2]  = &result[2 * a2];
  return result;
}

void std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  if (v2)
  {
    *(void *)(a1 + 8)  = v2;
    uint64_t v3 = (void *)(a1 + 30);
    if (a1 + 24 <= (unint64_t)v2)
    {
      BOOL v4 = v3 >= v2;
      BOOL v5 = v3 == v2;
    }
    else
    {
      BOOL v4 = 0;
      BOOL v5 = 0;
    }
    if (!v5 && v4)
    {
      if (*(void *)(a1 + 16) == *(void *)(a1 + 32)) {
        *(void *)(a1 + 32)  = v2;
      }
    }
    else
    {
      operator delete(v2);
    }
  }
}

BOOL anonymous namespace'::MorxInsertionSubtableBuilder::StateNeedsAction(_anonymous_namespace_::MorxInsertionSubtableBuilder *this, int a2, int a3)
{
  uint64_t v4 = 0;
}

BOOL anonymous namespace'::MorxStateTableSubtableBuilder<STXEntryTwo>::ProcessMorxEntryTableForState(uint64_t a1, int a2, int a3, void *a4)
{
  unint64_t v4 = (a3 + *(_DWORD *)(a1 + 24) * a2);
  uint64_t v5 = *(void *)(a1 + 40);
  if (v4 >= (*(void *)(a1 + 48) - v5) >> 1) {
    return 0;
  }
  unint64_t v6 = *(unsigned __int16 *)(v5 + 2 * v4);
  uint64_t v7 = *(void *)(a1 + 136);
  if (v6 >= (*(void *)(a1 + 144) - v7) >> 3) {
    return 0;
  }
  unsigned __int16 v8 = (unsigned __int16 *)(v7 + 8 * v6);
  *a4  = v8;
  unsigned __int16 v9 = v8[1];
  unsigned int v10 = bswap32(*v8) >> 16;
  return (v9 & 0xE0) != 0 || v10 > 1;
}

uint64_t GetActionIndex(unint64_t **a1, unsigned int a2, unsigned int a3, unsigned __int16 a4, uint64_t a5)
{
  unsigned int v10 = *a1;
  unint64_t v11 = a1[1];
  unint64_t v12 = v11 - *a1;
  if (v11 == *a1)
  {
LABEL_11:
    unint64_t v16 = (unint64_t)a1[2];
    if ((unint64_t)v11 >= v16)
    {
      if ((v12 + 1) >> 61) {
        abort();
      }
      uint64_t v18 = v16 - (void)v10;
      uint64_t v19 = v18 >> 2;
      if (v18 >> 2 <= v12 + 1) {
        uint64_t v19 = v12 + 1;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v20 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v20 = v19;
      }
      if (v20) {
        long long v21 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)(a1 + 3), v20);
      }
      else {
        long long v21 = 0;
      }
      unint64_t v22 = (unint64_t *)&v21[8 * v12];
      BOOL v23 = &v21[8 * v20];
      *unint64_t v22 = ((unint64_t)a4 << 32) | (a5 << 48) | ((unint64_t)a3 << 16) | a2;
      BOOL v17 = v22 + 1;
      uint64_t v25 = *a1;
      uint64_t v24 = a1[1];
      if (v24 != *a1)
      {
        do
        {
          unint64_t v26 = *--v24;
          *--unint64_t v22 = v26;
        }
        while (v24 != v25);
        uint64_t v24 = *a1;
      }
      *a1  = v22;
      a1[1]  = v17;
      unsigned int v27 = a1[2];
      a1[2]  = (unint64_t *)v23;
      if (v24)
      {
        __n128 v28 = a1 + 33;
        if (a1 + 3 <= (unint64_t **)v24 && v28 > (unint64_t **)v24)
        {
          if (v27 == *v28) {
            unsigned char *v28 = v24;
          }
        }
        else
        {
          operator delete(v24);
        }
      }
    }
    else
    {
      unint64_t *v11 = ((unint64_t)a4 << 32) | (a5 << 48) | ((unint64_t)a3 << 16) | a2;
      BOOL v17 = v11 + 1;
    }
    a1[1]  = v17;
    return v17 - *a1 - 1;
  }
  else
  {
    uint64_t result = 0;
    if (v12 <= 1) {
      uint64_t v14 = 1;
    }
    else {
      uint64_t v14 = v12;
    }
    uint64_t v15 = (unsigned __int16 *)v10 + 2;
    while (*(v15 - 2) != a2 || *(v15 - 1) != a3 || *v15 != a4 || v15[1] != (unsigned __int16)a5)
    {
      ++result;
      v15 += 4;
      if (v14 == result) {
        goto LABEL_11;
      }
    }
  }
  return result;
}

uint64_t std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::__wrap_iter<unsigned short *>,std::__wrap_iter<unsigned short *>,std::back_insert_iterator<TInlineVector<unsigned short,30ul>>,0>(uint64_t result, _WORD *a2, char **a3)
{
  if ((_WORD *)result != a2)
  {
    uint64_t v5 = (_WORD *)result;
    uint64_t v6 = (uint64_t)(a3 + 3);
    uint64_t v7 = a3[1];
    do
    {
      unint64_t v8 = (unint64_t)a3[2];
      if ((unint64_t)v7 >= v8)
      {
        unsigned __int16 v9 = *a3;
        uint64_t v10 = v7 - *a3;
        if (v10 <= -3) {
          abort();
        }
        uint64_t v11 = v10 >> 1;
        unint64_t v12 = v8 - (void)v9;
        if (v12 <= (v10 >> 1) + 1) {
          unint64_t v13 = v11 + 1;
        }
        else {
          unint64_t v13 = v12;
        }
        if (v12 >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v14 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v14 = v13;
        }
        v22[4]  = v6;
        if (v14)
        {
          uint64_t v15 = (char *)TInlineBufferAllocator<unsigned short,30ul>::allocate(v6, v14);
          unsigned __int16 v9 = *a3;
          uint64_t v7 = a3[1];
        }
        else
        {
          uint64_t v15 = 0;
        }
        unint64_t v16 = &v15[2 * v11];
        *(_WORD *)unint64_t v16 = *v5;
        if (v7 == v9)
        {
          uint64_t v18 = &v15[2 * v11];
        }
        else
        {
          BOOL v17 = v7;
          uint64_t v18 = &v15[2 * v11];
          do
          {
            __int16 v19 = *((_WORD *)v17 - 1);
            v17 -= 2;
            *((_WORD *)v18 - 1)  = v19;
            v18 -= 2;
          }
          while (v17 != v9);
        }
        unint64_t v20 = v16 + 2;
        *a3  = v18;
        v22[0]  = v9;
        v22[1]  = v9;
        a3[1]  = v16 + 2;
        v22[2]  = v7;
        long long v21 = a3[2];
        a3[2]  = &v15[2 * v14];
        v22[3]  = v21;
        uint64_t result = std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,30ul> &>::~__split_buffer((uint64_t)v22);
        uint64_t v7 = v20;
      }
      else
      {
        *(_WORD *)uint64_t v7 = *v5;
        v7 += 2;
      }
      a3[1]  = v7;
      ++v5;
    }
    while (v5 != a2);
  }
  return result;
}

void anonymous namespace'::MorxStateTableSubtableBuilder<STXEntryTwo>::CreateSubtableDataInternal(_anonymous_namespace_::MorxSubtableBuilder *a1, uint64_t a2, unsigned int a3)
{
  CFIndex Length = CFDataGetLength((CFDataRef)atomic_load_explicit((atomic_ullong *volatile)(a2 + 32), memory_order_acquire));
  CFIndex v7 = Length + 20;
  if ((unint64_t)(Length + 20) >= 0xFFFFFFFF
    || (uint64_t v8 = *(void *)(a2 + 48) - *(void *)(a2 + 40), v9 = v8 + v7, (unint64_t)(v8 + v7) >= 0xFFFFFFFF)
    || (unint64_t v10 = Length + a3 + v8 + *(void *)(a2 + 144) - *(void *)(a2 + 136) + 20, v10 >= 0xFFFFFFFF))
  {
    *(void *)a1  = 0;
  }
  else
  {
    *(void *)a1  = 0xAAAAAAAAAAAAAAAALL;
    CFDataRef explicit = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)a1, memory_order_acquire);
    *(_DWORD *)bytes  = bswap32(*(_DWORD *)(a2 + 24));
    CFDataAppendBytes(explicit, bytes, 4);
    unint64_t v12 = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)a1, memory_order_acquire);
    *(_DWORD *)bytes  = 335544320;
    CFDataAppendBytes(v12, bytes, 4);
    unint64_t v13 = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)a1, memory_order_acquire);
    *(_DWORD *)bytes  = bswap32(v7);
    CFDataAppendBytes(v13, bytes, 4);
    uint64_t v14 = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)a1, memory_order_acquire);
    *(_DWORD *)bytes  = bswap32(v9);
    CFDataAppendBytes(v14, bytes, 4);
  }
}

void anonymous namespace'::MorxStateTableSubtableBuilder<STXEntryTwo>::AppendStateTablePieces(atomic_ullong *a1, _anonymous_namespace_ *this, const __CFData *a3)
{
  uint64_t v5 = (unsigned __int16 *)a1[5];
  uint64_t v6 = (unsigned __int16 *)a1[6];
  while (v5 != v6)
  {
    unsigned int v7 = *v5++;
    *(_WORD *)bytes  = bswap32(v7) >> 16;
    CFDataAppendBytes(this, bytes, 2);
  }
  unsigned int v9 = (unsigned __int16 *)a1[17];
  uint64_t v8 = (unsigned __int16 *)a1[18];
  while (v9 != v8)
  {
    *(_WORD *)uint64_t v11 = bswap32(*v9) >> 16;
    CFDataAppendBytes(this, v11, 2);
    *(_WORD *)unint64_t v12 = bswap32(v9[1]) >> 16;
    CFDataAppendBytes(this, v12, 2);
    *(_WORD *)unint64_t v13 = bswap32(v9[2]) >> 16;
    CFDataAppendBytes(this, v13, 2);
    *(_WORD *)uint64_t v14 = bswap32(v9[3]) >> 16;
    CFDataAppendBytes(this, v14, 2);
    v9 += 4;
  }
}

uint64_t anonymous namespace'::MorxStateTableSubtableBuilder<STXEntryTwo>::~MorxStateTableSubtableBuilder(uint64_t a1)
{
  *(void *)a1  = &unk_1ED05F950;
  uint64_t v2 = *(void **)(a1 + 136);
  if (v2)
  {
    *(void *)(a1 + 144)  = v2;
    uint64_t v3 = (void *)(a1 + 400);
    if (a1 + 160 <= (unint64_t)v2)
    {
      BOOL v4 = v3 >= v2;
      BOOL v5 = v3 == v2;
    }
    else
    {
      BOOL v4 = 0;
      BOOL v5 = 0;
    }
    if (!v5 && v4)
    {
      if (*(void *)(a1 + 152) == *(void *)(a1 + 400)) {
        *uint64_t v3 = v2;
      }
    }
    else
    {
      operator delete(v2);
    }
  }
  unsigned int v7 = (void **)(a1 + 40);
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100](&v7);

  return a1;
}

uint64_t std::__split_buffer<anonymous namespace'::LigInput,TInlineBufferAllocator<anonymous namespace'::LigInput,30ul> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16)  = i - 48;
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100](i - 48);
  }
  BOOL v4 = *(void **)a1;
  if (*(void *)a1)
  {
    unint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = (void *)(v5 + 1440);
    if (v5 <= (unint64_t)v4 && v6 > v4)
    {
      if (*(void *)(a1 + 24) == *v6) {
        *uint64_t v6 = v4;
      }
    }
    else
    {
      operator delete(v4);
    }
  }
  return a1;
}

char *std::__allocate_at_least[abi:nn180100]<TInlineBufferAllocator<anonymous namespace'::LigInput,30ul>>(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = (char *)(a1 + 1440);
  uint64_t result = *(char **)(a1 + 1440);
  BOOL v4 = &result[48 * a2];
  if (v4 <= v2)
  {
    *(void *)uint64_t v2 = v4;
  }
  else
  {
    if (a2 >= 0x555555555555556) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    return (char *)operator new(48 * a2);
  }
  return result;
}

void std::__function::__func<LigInputsForLigatureSubst(long,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,TInlineVector<anonymous namespace'::LigInput,30ul> &)::$_1,std::allocator<LigInputsForLigatureSubst(long,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,TInlineVector<anonymous namespace'::LigInput,30ul> &)::$_1>,BOOL ()(unsigned short,unsigned short,unsigned short)>::~__func()
{
}

__n128 std::__function::__func<LigInputsForLigatureSubst(long,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,TInlineVector<anonymous namespace'::LigInput,30ul> &)::$_1,std::allocator<LigInputsForLigatureSubst(long,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,TInlineVector<anonymous namespace'::LigInput,30ul> &)::$_1>,BOOL ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_1ED0605D8;
  *(_OWORD *)(v2 + 8)  = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24)  = result;
  return result;
}

__n128 std::__function::__func<LigInputsForLigatureSubst(long,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,TInlineVector<anonymous namespace'::LigInput,30ul> &)::$_1,std::allocator<LigInputsForLigatureSubst(long,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,TInlineVector<anonymous namespace'::LigInput,30ul> &)::$_1>,BOOL ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2  = &unk_1ED0605D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24)  = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8)  = result;
  return result;
}

uint64_t std::__function::__func<LigInputsForLigatureSubst(long,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,TInlineVector<anonymous namespace'::LigInput,30ul> &)::$_1,std::allocator<LigInputsForLigatureSubst(long,OTL::LookupSubtable const*,void const*,std::vector<unsigned short> const&,TInlineVector<anonymous namespace'::LigInput,30ul> &)::$_1>,BOOL ()(unsigned short,unsigned short,unsigned short)>::operator()(void **a1, unsigned __int16 *a2, unsigned __int16 *a3, __int16 *a4)
{
  unsigned int v5 = *a2;
  unsigned int v6 = *a3;
  uint64_t result = 1;
  if (v5 <= v6 && v5 != (unsigned __int16)(v6 + 1))
  {
    __int16 v8 = *a4;
    unsigned __int16 v73 = *a2;
    int v68 = *a3;
    unsigned __int16 v69 = *a2;
    __int16 v67 = *a4;
    while (1)
    {
      uint64_t v9 = *a1[1];
      unint64_t v10 = *a1[2];
      unint64_t v11 = v9 + 6;
      if (v9 + 6 > v10) {
        return 0;
      }
      unsigned __int16 v12 = v73 - v5 + v8;
      uint64_t v13 = bswap32(*(unsigned __int16 *)(v9 + 4)) >> 16;
      unint64_t v14 = v11 + 2 * v13;
      if (v14 < v11 || v14 > v10)
      {
        unint64_t v16 = (v10 - v11) >> 1;
        if (v9 + 8 > v10) {
          unint64_t v16 = 0;
        }
        BOOL v17 = v13 > v12 && v16 == v13;
        if (!v17) {
          return 0;
        }
      }
      else if (v13 <= v12)
      {
        return 0;
      }
      uint64_t v18 = (_WORD *)(v9 + (bswap32(*(unsigned __int16 *)(v9 + 2 * v12 + 6)) >> 16));
      __int16 v19 = v18 + 1;
      if ((unint64_t)(v18 + 1) > v10) {
        return 0;
      }
      uint64_t v20 = __rev16((unsigned __int16)*v18);
      unint64_t v21 = (unint64_t)&v19[v20];
      unint64_t v22 = (v10 - (unint64_t)v19) >> 1;
      float v70 = v18 + 2;
      if ((unint64_t)(v18 + 2) > v10) {
        unint64_t v22 = 0;
      }
      BOOL v23 = v21 <= v10 && v21 >= (unint64_t)v19;
      if (!v23 && v22 != v20) {
        return 0;
      }
      if (*v18)
      {
        unint64_t v25 = 0;
        if (v20 <= 1) {
          uint64_t v26 = 1;
        }
        else {
          uint64_t v26 = v20;
        }
        uint64_t v72 = v26;
        uint64_t v71 = v18;
        do
        {
          unint64_t v27 = *a1[2];
          if ((unint64_t)v19 > v27) {
            return 0;
          }
          unint64_t v28 = bswap32((unsigned __int16)*v18) >> 16;
          unint64_t v29 = (unint64_t)&v19[v28];
          if (v29 < (unint64_t)v19 || v29 > v27)
          {
            unint64_t v31 = (v27 - (unint64_t)v19) >> 1;
            if ((unint64_t)v70 > v27) {
              unint64_t v31 = 0;
            }
            if (v31 != v28 || v25 >= v28) {
              return 0;
            }
          }
          else if (v25 >= v28)
          {
            return 0;
          }
          uint64_t v33 = (_WORD *)((char *)v18 + (bswap32((unsigned __int16)v18[v25 + 1]) >> 16));
          __n128 v34 = v33 + 2;
          if ((unint64_t)(v33 + 2) > v27) {
            return 0;
          }
          unint64_t v35 = __rev16(v33[1]);
          unsigned int v36 = &v34[v35 - 1];
          unint64_t v37 = (unint64_t)(v33 + 3) <= v27 ? (v27 - (unint64_t)v34) >> 1 : 0;
          BOOL v38 = (unint64_t)v36 <= v27 && v36 >= v34;
          if (!v38 && v37 != v35 - 1) {
            return 0;
          }
          if (v33[1])
          {
            unint64_t v78 = 0xAAAAAAAAAAAAAAAALL;
            v77[0]  = 0xAAAAAAAAAAAAAAAALL;
            long long v74 = 0;
            uint64_t v75 = 0;
            unsigned int v76 = 0;
            v77[1]  = v77;
            LOWORD(v78)  = bswap32(*v33) >> 16;
            std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::reserve(&v74, v35);
            uint64_t v40 = v75;
            if (v75 >= v76)
            {
              unsigned int v42 = v74;
              uint64_t v43 = v75 - v74;
              if (v75 - v74 <= -3) {
LABEL_111:
              }
                abort();
              uint64_t v44 = v43 >> 1;
              if (v76 - v74 <= (unint64_t)((v43 >> 1) + 1)) {
                uint64_t v45 = v44 + 1;
              }
              else {
                uint64_t v45 = v76 - v74;
              }
              if ((unint64_t)(v76 - v74) >= 0x7FFFFFFFFFFFFFFELL) {
                uint64_t v46 = 0x7FFFFFFFFFFFFFFFLL;
              }
              else {
                uint64_t v46 = v45;
              }
              unint64_t v83 = v77;
              if (v46)
              {
                uint64_t v47 = (char *)TInlineBufferAllocator<unsigned short,3ul>::allocate((uint64_t)v77, v46);
                unsigned int v42 = v74;
                uint64_t v40 = v75;
              }
              else
              {
                uint64_t v47 = 0;
              }
              uint64_t v48 = &v47[2 * v44];
              *(_WORD *)uint64_t v48 = v73;
              if (v40 == v42)
              {
                unint64_t v50 = &v47[2 * v44];
              }
              else
              {
                unint64_t v49 = v40;
                unint64_t v50 = &v47[2 * v44];
                do
                {
                  __int16 v51 = *((_WORD *)v49 - 1);
                  v49 -= 2;
                  *((_WORD *)v50 - 1)  = v51;
                  v50 -= 2;
                }
                while (v49 != v42);
              }
              uint64_t v41 = v48 + 2;
              long long v74 = v50;
              uint64_t v75 = v48 + 2;
              __int16 v52 = v76;
              unsigned int v76 = &v47[2 * v46];
              long long v81 = v40;
              uint8x8_t v82 = v52;
              __int16 v79 = v42;
              long long v80 = v42;
              std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,3ul> &>::~__split_buffer((uint64_t)&v79);
            }
            else
            {
              *(_WORD *)uint64_t v75 = v73;
              uint64_t v41 = v40 + 2;
            }
            uint64_t v75 = v41;
            if (*a1[3] <= (uint64_t)v73) {
              goto LABEL_108;
            }
            if (v35 != 1)
            {
              uint64_t v53 = &v34[(v35 - 1)];
              while (1)
              {
                uint64_t v54 = bswap32(*v34) >> 16;
                if (*a1[3] <= v54) {
                  break;
                }
                if (v41 >= v76)
                {
                  uint64_t v55 = v74;
                  uint64_t v56 = v41 - v74;
                  if (v41 - v74 <= -3) {
                    goto LABEL_111;
                  }
                  uint64_t v57 = v56 >> 1;
                  if (v76 - v74 <= (unint64_t)((v56 >> 1) + 1)) {
                    uint64_t v58 = v57 + 1;
                  }
                  else {
                    uint64_t v58 = v76 - v74;
                  }
                  if ((unint64_t)(v76 - v74) >= 0x7FFFFFFFFFFFFFFELL) {
                    uint64_t v59 = 0x7FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    uint64_t v59 = v58;
                  }
                  unint64_t v83 = v77;
                  if (v59)
                  {
                    unint64_t v60 = (char *)TInlineBufferAllocator<unsigned short,3ul>::allocate((uint64_t)v77, v59);
                    uint64_t v55 = v74;
                    uint64_t v41 = v75;
                  }
                  else
                  {
                    unint64_t v60 = 0;
                  }
                  unint64_t v61 = &v60[2 * v57];
                  *(_WORD *)unint64_t v61 = v54;
                  if (v41 == v55)
                  {
                    uint64_t v63 = &v60[2 * v57];
                  }
                  else
                  {
                    unint64_t v62 = v41;
                    uint64_t v63 = &v60[2 * v57];
                    do
                    {
                      __int16 v64 = *((_WORD *)v62 - 1);
                      v62 -= 2;
                      *((_WORD *)v63 - 1)  = v64;
                      v63 -= 2;
                    }
                    while (v62 != v55);
                  }
                  int64x2_t v65 = v61 + 2;
                  long long v74 = v63;
                  uint64_t v75 = v61 + 2;
                  uint64_t v66 = v76;
                  unsigned int v76 = &v60[2 * v59];
                  long long v81 = v41;
                  uint8x8_t v82 = v66;
                  __int16 v79 = v55;
                  long long v80 = v55;
                  std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,3ul> &>::~__split_buffer((uint64_t)&v79);
                  uint64_t v41 = v65;
                }
                else
                {
                  *(_WORD *)uint64_t v41 = v54;
                  v41 += 2;
                }
                uint64_t v75 = v41;
                if (++v34 == v53) {
                  goto LABEL_103;
                }
              }
LABEL_108:
              std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v74);
              return 0;
            }
LABEL_103:
            std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v74);
            uint64_t v18 = v71;
          }
        }
        while (++v25 != v72);
      }
      LOWORD(v5)  = v69;
      BOOL v17 = v68 == v73++;
      __int16 v8 = v67;
      if (v17) {
        return 1;
      }
    }
  }
  return result;
}

char **std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::reserve(char **result, unint64_t a2)
{
  if (a2 > (result[2] - *result) >> 1)
  {
    if ((a2 & 0x8000000000000000) != 0) {
      abort();
    }
    uint64_t v3 = result;
    uint64_t v4 = result[1] - *result;
    v12[4]  = result + 3;
    unsigned int v5 = (char *)TInlineBufferAllocator<unsigned short,3ul>::allocate((uint64_t)(result + 3), a2);
    unsigned int v7 = *v3;
    unsigned int v6 = v3[1];
    __int16 v8 = &v5[v4 & 0xFFFFFFFFFFFFFFFELL];
    if (v6 != *v3)
    {
      uint64_t v9 = v3[1];
      __int16 v8 = &v5[v4 & 0xFFFFFFFFFFFFFFFELL];
      do
      {
        __int16 v10 = *((_WORD *)v9 - 1);
        v9 -= 2;
        *((_WORD *)v8 - 1)  = v10;
        v8 -= 2;
      }
      while (v9 != v7);
    }
    *uint64_t v3 = v8;
    v3[1]  = &v5[v4 & 0xFFFFFFFFFFFFFFFELL];
    unint64_t v11 = v3[2];
    v3[2]  = &v5[2 * a2];
    v12[2]  = v6;
    v12[3]  = v11;
    v12[0]  = v7;
    v12[1]  = v7;
    return (char **)std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,3ul> &>::~__split_buffer((uint64_t)v12);
  }
  return result;
}

char *std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  unsigned int v7 = result;
  unint64_t v8 = *((void *)result + 2);
  uint64_t v9 = *(char **)result;
  unint64_t v10 = (uint64_t)(v8 - *(void *)result) >> 1;
  if (v10 < a4)
  {
    if (v9)
    {
      *((void *)result + 1)  = v9;
      if (result + 24 <= v9 && result + 30 > v9)
      {
        if (&v9[2 * v10] == *((char **)result + 4)) {
          *((void *)result + 4)  = v9;
        }
      }
      else
      {
        operator delete(v9);
      }
      unint64_t v8 = 0;
      void *v7 = 0;
      v7[1]  = 0;
      void v7[2] = 0;
    }
    if ((a4 & 0x8000000000000000) != 0) {
      abort();
    }
    if (v8 <= a4) {
      unint64_t v19 = a4;
    }
    else {
      unint64_t v19 = v8;
    }
    if (v8 >= 0x7FFFFFFFFFFFFFFELL) {
      uint64_t v20 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v20 = v19;
    }
    uint64_t result = std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__vallocate[abi:nn180100](v7, v20);
    unint64_t v21 = (char *)v7[1];
    uint64_t v13 = (void **)(v7 + 1);
    uint64_t v9 = v21;
LABEL_24:
    size_t v16 = a3 - (void)__src;
    if (v16)
    {
      BOOL v17 = v9;
      uint64_t v18 = __src;
      goto LABEL_26;
    }
    goto LABEL_27;
  }
  uint64_t v13 = (void **)(result + 8);
  unsigned __int16 v12 = (unsigned char *)*((void *)result + 1);
  unint64_t v14 = (v12 - v9) >> 1;
  if (v14 >= a4) {
    goto LABEL_24;
  }
  uint64_t v15 = &__src[2 * v14];
  if (v12 != v9)
  {
    uint64_t result = (char *)memmove(*(void **)result, __src, 2 * v14);
    uint64_t v9 = (char *)*v13;
  }
  size_t v16 = a3 - (void)v15;
  if (v16)
  {
    BOOL v17 = v9;
    uint64_t v18 = v15;
LABEL_26:
    uint64_t result = (char *)memmove(v17, v18, v16);
  }
LABEL_27:
  *uint64_t v13 = &v9[v16];
  return result;
}

void std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,anonymous namespace'::LigInput *,false>(unsigned __int16 **a1, unsigned __int16 **a2, uint64_t a3, char a4)
{
  while (2)
  {
    unint64_t v10 = (unint64_t)a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1  = (unsigned __int16 **)v10;
          uint64_t v11 = (uint64_t)a2 - v10;
          uint64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)a2 - v10) >> 4);
          if (!(!v5 & v4))
          {
            switch(v12)
            {
              case 0:
              case 1:
                return;
              case 2:
                unint64_t v122 = *(a2 - 6);
                id v123 = *(a2 - 5);
                uint64_t v124 = (uint64_t)(a2 - 6);
                id v125 = *a1;
                unint64_t v126 = v123 - v122;
                uint64_t v127 = (char *)a1[1] - (char *)*a1;
                if (v126 > v127 >> 1) {
                  goto LABEL_153;
                }
                v245  = v127 >> 1;
                if (v123 == v122 || v126 < v245) {
                  return;
                }
                break;
              case 3:
                return;
              case 4:
                return;
              case 5:
                return;
              default:
                JUMPOUT(0);
            }
            while (1)
            {
              v247  = *v122;
              v248  = *v125;
              if (v247 != v248) {
                break;
              }
              ++v122;
              ++v125;
              if (!--v126) {
                return;
              }
            }
            if (v247 <= v248) {
LABEL_153:
            }
            return;
          }
          if (v11 <= 1151)
          {
            if (a4)
            {
              if (a1 != a2)
              {
                unsigned int v128 = a1 + 6;
                if (a1 + 6 != a2)
                {
                  uint64_t v129 = a1;
                  do
                  {
                    uint64_t v130 = v129;
                    uint64_t v129 = v128;
                    int v131 = v130[6];
                    id v132 = v129[1];
                    long long v133 = (char *)*v130;
                    unint64_t v134 = v132 - v131;
                    uint64_t v135 = (char *)v130[1] - (char *)*v130;
                    if (v134 > v135 >> 1) {
                      goto LABEL_162;
                    }
                    unint64_t v148 = v135 >> 1;
                    if (v132 != v131 && v134 >= v148)
                    {
                      while (1)
                      {
                        unsigned int v150 = *v131;
                        unsigned int v151 = *(unsigned __int16 *)v133;
                        if (v150 != v151) {
                          break;
                        }
                        ++v131;
                        v133 += 2;
                        if (!--v134) {
                          goto LABEL_187;
                        }
                      }
                      if (v150 <= v151)
                      {
LABEL_162:
                        *(void *)&long long v136 = 0xAAAAAAAAAAAAAAAALL;
                        *((void *)&v136 + 1)  = 0xAAAAAAAAAAAAAAAALL;
                        v276  = v136;
                        v277  = v136;
                        v275  = v136;
                        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>((uint64_t)&v275, v130[6], v130[7]);
                        WORD4(v277)  = *((_WORD *)v130 + 44);
                        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)v129, (char *)*v130, (uint64_t)v130[1], v130[1] - *v130);
                        *((_WORD *)v129 + 20)  = *((_WORD *)v130 + 20);
                        uint64_t v137 = a1;
                        if (v130 != a1)
                        {
                          uint64_t v138 = v130;
                          while (1)
                          {
                            uint64_t v139 = (char *)*(v138 - 6);
                            uint64_t v140 = (uint64_t)*(v138 - 5);
                            v138 -= 6;
                            long long v141 = (unsigned __int16 *)v275;
                            unint64_t v142 = (uint64_t)(*((void *)&v275 + 1) - v275) >> 1;
                            unint64_t v143 = (v140 - (uint64_t)v139) >> 1;
                            if (v142 <= v143)
                            {
                              if (*((void *)&v275 + 1) == (void)v275 || v142 < v143) {
                                break;
                              }
                              __int16 v145 = v139;
                              while (1)
                              {
                                unsigned int v146 = *v141;
                                unsigned int v147 = *(unsigned __int16 *)v145;
                                if (v146 != v147) {
                                  break;
                                }
                                ++v141;
                                v145 += 2;
                                if (!--v142) {
                                  goto LABEL_185;
                                }
                              }
                              if (v146 > v147) {
                                break;
                              }
                            }
                            std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)v130, v139, v140, v143);
                            *((_WORD *)v130 + 20)  = *((_WORD *)v130 - 4);
                            uint64_t v130 = v138;
                            if (v138 == a1)
                            {
                              uint64_t v137 = a1;
                              goto LABEL_186;
                            }
                          }
LABEL_185:
                          uint64_t v137 = v130;
                        }
LABEL_186:
                        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)v137, (char *)v275, *((uint64_t *)&v275 + 1), (uint64_t)(*((void *)&v275 + 1) - v275) >> 1);
                        *((_WORD *)v137 + 20)  = WORD4(v277);
                        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v275);
                      }
                    }
LABEL_187:
                    unsigned int v128 = v129 + 6;
                  }
                  while (v129 + 6 != a2);
                }
              }
            }
            else if (a1 != a2)
            {
LABEL_327:
              while (a1 + 6 != a2)
              {
                v249  = a1;
                a1 += 6;
                v250  = v249[6];
                v251  = a1[1];
                v252  = *v249;
                v253  = v251 - v250;
                v254  = (char *)v249[1] - (char *)*v249;
                if (v253 <= v254 >> 1)
                {
                  v269  = v254 >> 1;
                  if (v251 == v250 || v253 < v269) {
                    continue;
                  }
                  while (1)
                  {
                    v271  = *v250;
                    v272  = *v252;
                    if (v271 != v272) {
                      break;
                    }
                    ++v250;
                    ++v252;
                    if (!--v253) {
                      goto LABEL_327;
                    }
                  }
                  if (v271 > v272) {
                    continue;
                  }
                }
                *(void *)&v255  = 0xAAAAAAAAAAAAAAAALL;
                *((void *)&v255 + 1)  = 0xAAAAAAAAAAAAAAAALL;
                v276  = v255;
                v277  = v255;
                v275  = v255;
                std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>((uint64_t)&v275, *a1, v249[7]);
                WORD4(v277)  = *((_WORD *)v249 + 44);
                v256  = (char *)*v249;
                v257  = a1;
                do
                {
                  do
                  {
                    v258  = v257;
                    v257  = v249;
                    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)v258, v256, (uint64_t)v249[1], ((char *)v249[1] - v256) >> 1);
                    v259  = (char *)*(v249 - 6);
                    v249 -= 6;
                    v256  = v259;
                    *((_WORD *)v258 + 20)  = *((_WORD *)v249 + 44);
                    v260  = (uint64_t)(*((void *)&v275 + 1) - v275) >> 1;
                    v261  = (char *)v249[1] - v259;
                  }
                  while (v260 > v261 >> 1);
                  v262  = v261 >> 1;
                  if (*((void *)&v275 + 1) == (void)v275 || v260 < v262) {
                    break;
                  }
                  v264  = (uint64_t)(*((void *)&v275 + 1) - v275) >> 1;
                  v265  = v256;
                  v266  = (unsigned __int16 *)v275;
                  while (1)
                  {
                    v267  = *v266;
                    v268  = *(unsigned __int16 *)v265;
                    if (v267 != v268) {
                      break;
                    }
                    ++v266;
                    v265 += 2;
                    if (!--v264) {
                      goto LABEL_317;
                    }
                  }
                }
                while (v267 <= v268);
LABEL_317:
                std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)v257, (char *)v275, *((uint64_t *)&v275 + 1), v260);
                *((_WORD *)v257 + 20)  = WORD4(v277);
                std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v275);
              }
            }
            return;
          }
          if (!a3)
          {
            if (a1 != a2)
            {
              int64_t v152 = (unint64_t)(v12 - 2) >> 1;
              int64_t v153 = v152;
              do
              {
                int64_t v154 = v153;
                if (v152 >= v153)
                {
                  uint64_t v155 = (2 * v153) | 1;
                  uint64_t v156 = (char **)&a1[6 * v155];
                  if (2 * v153 + 2 < v12)
                  {
                    v157  = v156[6];
                    uint64_t v158 = *v156;
                    uint64_t v159 = v156[1];
                    unint64_t v160 = (v159 - *v156) >> 1;
                    uint64_t v161 = v156[7] - v157;
                    if (v160 > v161 >> 1) {
                      goto LABEL_196;
                    }
                    unint64_t v162 = v161 >> 1;
                    if (v159 != v158 && v160 >= v162)
                    {
                      while (1)
                      {
                        unsigned int v164 = *(unsigned __int16 *)v158;
                        unsigned int v165 = *(unsigned __int16 *)v157;
                        if (v164 != v165) {
                          break;
                        }
                        v158 += 2;
                        v157 += 2;
                        if (!--v160) {
                          goto LABEL_206;
                        }
                      }
                      if (v164 <= v165)
                      {
LABEL_196:
                        v156 += 6;
                        uint64_t v155 = 2 * v153 + 2;
                      }
                    }
                  }
LABEL_206:
                  unint64_t v166 = &a1[6 * v153];
                  __int16 v167 = (unsigned __int16 *)*v156;
                  v168  = (unsigned __int16 *)v156[1];
                  v169  = *v166;
                  v170  = ((char *)v168 - *v156) >> 1;
                  uint64_t v171 = (char *)v166[1] - (char *)*v166;
                  if (v170 <= v171 >> 1)
                  {
                    unint64_t v172 = v171 >> 1;
                    if (v168 == v167 || v170 < v172) {
                      goto LABEL_216;
                    }
                    while (1)
                    {
                      unsigned int v174 = *v167;
                      unsigned int v175 = *v169;
                      if (v174 != v175) {
                        break;
                      }
                      ++v167;
                      ++v169;
                      if (!--v170) {
                        goto LABEL_216;
                      }
                    }
                    if (v174 > v175)
                    {
LABEL_216:
                      *(void *)&long long v176 = 0xAAAAAAAAAAAAAAAALL;
                      *((void *)&v176 + 1)  = 0xAAAAAAAAAAAAAAAALL;
                      v276  = v176;
                      v277  = v176;
                      v275  = v176;
                      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>((uint64_t)&v275, *v166, v166[1]);
                      uint64_t v177 = &a1[6 * v154];
                      WORD4(v277)  = *((_WORD *)v177 + 20);
                      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)v177, *v156, (uint64_t)v156[1], (v156[1] - *v156) >> 1);
                      *((_WORD *)v177 + 20)  = *((_WORD *)v156 + 20);
                      while (v152 >= v155)
                      {
                        uint64_t v178 = v156;
                        v179  = 2 * v155;
                        uint64_t v155 = (2 * v155) | 1;
                        uint64_t v156 = (char **)&a1[6 * v155];
                        uint64_t v180 = v179 + 2;
                        if (v180 < v12)
                        {
                          uint64_t v181 = v156[6];
                          __int16 v182 = *v156;
                          uint64_t v183 = v156[1];
                          unint64_t v184 = (v183 - *v156) >> 1;
                          uint64_t v185 = v156[7] - v181;
                          if (v184 > v185 >> 1) {
                            goto LABEL_220;
                          }
                          unint64_t v186 = v185 >> 1;
                          if (v183 != v182 && v184 >= v186)
                          {
                            while (1)
                            {
                              unsigned int v188 = *(unsigned __int16 *)v182;
                              unsigned int v189 = *(unsigned __int16 *)v181;
                              if (v188 != v189) {
                                break;
                              }
                              v182 += 2;
                              v181 += 2;
                              if (!--v184) {
                                goto LABEL_230;
                              }
                            }
                            if (v188 <= v189)
                            {
LABEL_220:
                              v156 += 6;
                              uint64_t v155 = v180;
                            }
                          }
                        }
LABEL_230:
                        v190  = *v156;
                        v191  = (uint64_t)v156[1];
                        uint64_t v192 = (unsigned __int16 *)v275;
                        v193  = v191 - (void)*v156;
                        unint64_t v194 = v193 >> 1;
                        if (v193 >> 1 > (unint64_t)((uint64_t)(*((void *)&v275 + 1) - v275) >> 1)) {
                          goto LABEL_242;
                        }
                        if ((char *)v191 != v190 && v194 >= (uint64_t)(*((void *)&v275 + 1) - v275) >> 1)
                        {
                          uint64_t v196 = v193 >> 1;
                          double v197 = *v156;
                          while (1)
                          {
                            unsigned int v198 = *(unsigned __int16 *)v197;
                            unsigned int v199 = *v192;
                            if (v198 != v199) {
                              break;
                            }
                            v197 += 2;
                            ++v192;
                            if (!--v196) {
                              goto LABEL_241;
                            }
                          }
                          if (v198 <= v199)
                          {
LABEL_242:
                            uint64_t v156 = v178;
                            break;
                          }
                        }
LABEL_241:
                        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)v178, v190, v191, v194);
                        *((_WORD *)v178 + 20)  = *((_WORD *)v156 + 20);
                      }
                      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)v156, (char *)v275, *((uint64_t *)&v275 + 1), (uint64_t)(*((void *)&v275 + 1) - v275) >> 1);
                      *((_WORD *)v156 + 20)  = WORD4(v277);
                      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v275);
                    }
                  }
                }
                int64_t v153 = v154 - 1;
              }
              while (v154);
              int64_t v200 = v11 / 0x30uLL;
              do
              {
                __int16 v201 = a2;
                *(void *)&long long v202 = 0xAAAAAAAAAAAAAAAALL;
                *((void *)&v202 + 1)  = 0xAAAAAAAAAAAAAAAALL;
                v273[1]  = v202;
                v274  = v202;
                v273[0]  = v202;
                std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>((uint64_t)v273, *a1, a1[1]);
                uint64_t v203 = 0;
                WORD4(v274)  = *((_WORD *)a1 + 20);
                uint64_t v204 = (char **)a1;
                do
                {
                  char v205 = (char *)v204;
                  v204 += 6 * v203 + 6;
                  uint64_t v206 = 2 * v203;
                  uint64_t v203 = (2 * v203) | 1;
                  v207  = v206 + 2;
                  if (v207 < v200)
                  {
                    int v208 = v204[6];
                    CGFloat v209 = *v204;
                    __int16 v210 = v204[1];
                    v211  = (v210 - *v204) >> 1;
                    v212  = v204[7] - v208;
                    if (v211 > v212 >> 1) {
                      goto LABEL_249;
                    }
                    v213  = v212 >> 1;
                    if (v210 != v209 && v211 >= v213)
                    {
                      while (1)
                      {
                        v215  = *(unsigned __int16 *)v209;
                        v216  = *(unsigned __int16 *)v208;
                        if (v215 != v216) {
                          break;
                        }
                        v209 += 2;
                        v208 += 2;
                        if (!--v211) {
                          goto LABEL_259;
                        }
                      }
                      if (v215 <= v216)
                      {
LABEL_249:
                        v204 += 6;
                        uint64_t v203 = v207;
                      }
                    }
                  }
LABEL_259:
                  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>(v205, *v204, (uint64_t)v204[1], (v204[1] - *v204) >> 1);
                  *((_WORD *)v205 + 20)  = *((_WORD *)v204 + 20);
                }
                while (v203 <= (uint64_t)((unint64_t)(v200 - 2) >> 1));
                a2  = v201 - 6;
                if (v204 == (char **)(v201 - 6))
                {
                  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)v204, *(char **)&v273[0], *((uint64_t *)&v273[0] + 1), (uint64_t)(*((void *)&v273[0] + 1) - *(void *)&v273[0]) >> 1);
                  *((_WORD *)v204 + 20)  = WORD4(v274);
                }
                else
                {
                  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)v204, (char *)*(v201 - 6), (uint64_t)*(v201 - 5), *(v201 - 5) - *(v201 - 6));
                  *((_WORD *)v204 + 20)  = *((_WORD *)v201 - 4);
                  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)v201 - 48, *(char **)&v273[0], *((uint64_t *)&v273[0] + 1), (uint64_t)(*((void *)&v273[0] + 1) - *(void *)&v273[0]) >> 1);
                  *((_WORD *)v201 - 4)  = WORD4(v274);
                  v217  = (char *)v204 - (char *)a1 + 48;
                  if (v217 >= 49)
                  {
                    v218  = v217 / 0x30uLL - 2;
                    v219  = v218 >> 1;
                    __int16 v220 = &a1[6 * (v218 >> 1)];
                    v221  = (char *)*v220;
                    v222  = (char *)v220[1];
                    uint64_t v223 = *v204;
                    unint64_t v224 = (v222 - (char *)*v220) >> 1;
                    uint64_t v225 = v204[1] - *v204;
                    if (v224 > v225 >> 1) {
                      goto LABEL_263;
                    }
                    unint64_t v241 = v225 >> 1;
                    if (v222 != v221 && v224 >= v241)
                    {
                      while (1)
                      {
                        v243  = *(unsigned __int16 *)v221;
                        v244  = *(unsigned __int16 *)v223;
                        if (v243 != v244) {
                          break;
                        }
                        v221 += 2;
                        v223 += 2;
                        if (!--v224) {
                          goto LABEL_268;
                        }
                      }
                      if (v243 <= v244)
                      {
LABEL_263:
                        *(void *)&v226  = 0xAAAAAAAAAAAAAAAALL;
                        *((void *)&v226 + 1)  = 0xAAAAAAAAAAAAAAAALL;
                        v276  = v226;
                        v277  = v226;
                        v275  = v226;
                        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>((uint64_t)&v275, *v204, v204[1]);
                        WORD4(v277)  = *((_WORD *)v204 + 20);
                        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)v204, (char *)*v220, (uint64_t)v220[1], v220[1] - *v220);
                        *((_WORD *)v204 + 20)  = a1[6 * v219 + 5];
                        if (v218 >= 2)
                        {
                          while (1)
                          {
                            unint64_t v232 = v219 - 1;
                            v219  = (v219 - 1) >> 1;
                            v227  = &a1[6 * v219];
                            unsigned __int16 v233 = v227[1];
                            uint64_t v229 = *((void *)&v275 + 1);
                            v228  = (char *)v275;
                            unint64_t v234 = v233 - *v227;
                            if (v234 <= (uint64_t)(*((void *)&v275 + 1) - v275) >> 1)
                            {
                              unint64_t v230 = (uint64_t)(*((void *)&v275 + 1) - v275) >> 1;
                              if (v233 == *v227 || v234 < v230) {
                                break;
                              }
                              uint64_t v236 = v233 - *v227;
                              uint64_t v237 = (unsigned __int16 *)v275;
                              unsigned int v238 = *v227;
                              while (1)
                              {
                                unsigned int v239 = *v238;
                                unsigned int v240 = *v237;
                                if (v239 != v240) {
                                  break;
                                }
                                ++v238;
                                ++v237;
                                if (!--v236) {
                                  goto LABEL_266;
                                }
                              }
                              if (v239 > v240) {
                                break;
                              }
                            }
                            std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)v220, (char *)*v227, (uint64_t)v227[1], v233 - *v227);
                            *((_WORD *)v220 + 20)  = a1[6 * v219 + 5];
                            __int16 v220 = &a1[6 * v219];
                            if (v232 < 2) {
                              goto LABEL_265;
                            }
                          }
                        }
                        v227  = v220;
LABEL_265:
                        uint64_t v229 = *((void *)&v275 + 1);
                        v228  = (char *)v275;
                        unint64_t v230 = (uint64_t)(*((void *)&v275 + 1) - v275) >> 1;
                        __int16 v220 = v227;
LABEL_266:
                        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)v220, v228, v229, v230);
                        *((_WORD *)v220 + 20)  = WORD4(v277);
                        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v275);
                      }
                    }
                  }
                }
LABEL_268:
                std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)v273);
              }
              while (v200-- > 2);
            }
            return;
          }
          unint64_t v13 = (unint64_t)v12 >> 1;
          unint64_t v14 = &a1[6 * ((unint64_t)v12 >> 1)];
          if ((unint64_t)v11 < 0x1801)
          {
          }
          else
          {
            uint64_t v15 = 3 * v13;
            size_t v16 = &a1[6 * v13];
            BOOL v17 = &a1[2 * v15 + 6];
            *(void *)&long long v18 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v18 + 1)  = 0xAAAAAAAAAAAAAAAALL;
            v276  = v18;
            v277  = v18;
            v275  = v18;
            std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>((uint64_t)&v275, *a1, a1[1]);
            WORD4(v277)  = *((_WORD *)a1 + 20);
            std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)a1, (char *)*v14, (uint64_t)v14[1], v14[1] - *v14);
            *((_WORD *)a1 + 20)  = *((_WORD *)v16 + 20);
            std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)v14, (char *)v275, *((uint64_t *)&v275 + 1), (uint64_t)(*((void *)&v275 + 1) - v275) >> 1);
            *((_WORD *)v16 + 20)  = WORD4(v277);
            std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v275);
          }
          --a3;
          if (a4) {
            break;
          }
          unint64_t v19 = *(a1 - 6);
          uint64_t v20 = *(a1 - 5);
          unint64_t v21 = *a1;
          unint64_t v22 = v20 - v19;
          uint64_t v23 = (char *)a1[1] - (char *)*a1;
          if (v22 > v23 >> 1) {
            break;
          }
          if (v20 != v19 && v22 >= v23 >> 1)
          {
            while (1)
            {
              unsigned int v24 = *v19;
              unsigned int v25 = *v21;
              if (v24 != v25) {
                break;
              }
              ++v19;
              ++v21;
              if (!--v22) {
                goto LABEL_15;
              }
            }
            if (v24 <= v25) {
              break;
            }
          }
LABEL_15:
          *(void *)&long long v26 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v26 + 1)  = 0xAAAAAAAAAAAAAAAALL;
          v276  = v26;
          v277  = v26;
          v275  = v26;
          std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>((uint64_t)&v275, *a1, a1[1]);
          WORD4(v277)  = *((_WORD *)a1 + 20);
          uint64_t v28 = *((void *)&v275 + 1);
          unint64_t v27 = (char *)v275;
          unint64_t v29 = *(a2 - 6);
          uint64_t v30 = (uint64_t)*(a2 - 5);
          unint64_t v31 = (uint64_t)(*((void *)&v275 + 1) - v275) >> 1;
          if (v31 > (v30 - (uint64_t)v29) >> 1) {
            goto LABEL_16;
          }
          if (*((void *)&v275 + 1) == (void)v275 || v31 < (v30 - (uint64_t)v29) >> 1) {
            goto LABEL_105;
          }
          uint64_t v84 = (uint64_t)(*((void *)&v275 + 1) - v275) >> 1;
          uint64_t v85 = *(a2 - 6);
          uint64_t v86 = (unsigned __int16 *)v275;
          while (1)
          {
            unsigned int v87 = *v86;
            unsigned int v88 = *v85;
            if (v87 != v88) {
              break;
            }
            ++v86;
            ++v85;
            if (!--v84) {
              goto LABEL_105;
            }
          }
          if (v87 > v88)
          {
LABEL_105:
            unint64_t v10 = (unint64_t)(a1 + 6);
            unint64_t v89 = a1;
            while (v10 < (unint64_t)a2)
            {
              int v90 = v89[6];
              uint64_t v91 = v89[7];
              unint64_t v89 = (unsigned __int16 **)v10;
              uint64_t v92 = (char *)v91 - (char *)v90;
              if (v31 > v92 >> 1) {
                break;
              }
              if (*((void *)&v275 + 1) != (void)v275 && v31 >= v92 >> 1)
              {
                uint64_t v93 = (uint64_t)(*((void *)&v275 + 1) - v275) >> 1;
                uint64_t v94 = (unsigned __int16 *)v275;
                while (1)
                {
                  unsigned int v95 = *v94;
                  unsigned int v96 = *v90;
                  if (v95 != v96) {
                    break;
                  }
                  ++v94;
                  ++v90;
                  if (!--v93) {
                    goto LABEL_115;
                  }
                }
                if (v95 <= v96) {
                  break;
                }
              }
LABEL_115:
              v10 += 48;
            }
          }
          else
          {
LABEL_16:
            uint64_t v32 = (char *)a1[6];
            unint64_t v10 = (unint64_t)(a1 + 6);
            uint64_t v33 = (char *)a1[7] - v32;
            if (v31 <= v33 >> 1)
            {
              unint64_t v34 = v33 >> 1;
              do
              {
                if (*((void *)&v275 + 1) != (void)v275 && v31 >= v34)
                {
                  uint64_t v35 = (uint64_t)(*((void *)&v275 + 1) - v275) >> 1;
                  unsigned int v36 = (unsigned __int16 *)v275;
                  while (1)
                  {
                    unsigned int v37 = *v36;
                    unsigned int v38 = *(unsigned __int16 *)v32;
                    if (v37 != v38) {
                      break;
                    }
                    ++v36;
                    v32 += 2;
                    if (!--v35) {
                      goto LABEL_25;
                    }
                  }
                  if (v37 <= v38) {
                    break;
                  }
                }
LABEL_25:
                uint64_t v32 = *(char **)(v10 + 48);
                uint64_t v39 = *(void *)(v10 + 56);
                v10 += 48;
                uint64_t v40 = v39 - (void)v32;
                unint64_t v34 = (v39 - (uint64_t)v32) >> 1;
              }
              while (v31 <= v40 >> 1);
            }
          }
          unint64_t v97 = (unint64_t)a2;
          if (v10 < (unint64_t)a2)
          {
            for (uint64_t i = a2; ; i -= 6)
            {
              unint64_t v97 = (unint64_t)(i - 6);
              uint64_t v99 = v30 - (void)v29;
              if (v31 <= v99 >> 1)
              {
                if (*((void *)&v275 + 1) == (void)v275 || v31 < v99 >> 1) {
                  break;
                }
                uint64_t v100 = (uint64_t)(*((void *)&v275 + 1) - v275) >> 1;
                uint64_t v101 = (unsigned __int16 *)v275;
                while (1)
                {
                  unsigned int v102 = *v101;
                  unsigned int v103 = *v29;
                  if (v102 != v103) {
                    break;
                  }
                  ++v101;
                  ++v29;
                  if (!--v100) {
                    goto LABEL_145;
                  }
                }
                if (v102 > v103) {
                  break;
                }
              }
              unint64_t v29 = *(i - 12);
              uint64_t v30 = (uint64_t)*(i - 11);
            }
          }
LABEL_145:
          while (v10 < v97)
          {
            uint64_t v28 = *((void *)&v275 + 1);
            unint64_t v27 = (char *)v275;
            unint64_t v104 = (uint64_t)(*((void *)&v275 + 1) - v275) >> 1;
            uint64_t v105 = *(unsigned __int16 **)(v10 + 48);
            uint64_t v106 = *(void *)(v10 + 56);
            v10 += 48;
            uint64_t v107 = v106 - (void)v105;
            if (v104 <= v107 >> 1)
            {
              unint64_t v108 = v107 >> 1;
              while (1)
              {
                if (*((void *)&v275 + 1) != (void)v275 && v104 >= v108)
                {
                  uint64_t v109 = (uint64_t)(*((void *)&v275 + 1) - v275) >> 1;
                  double v110 = (unsigned __int16 *)v275;
                  while (1)
                  {
                    unsigned int v111 = *v110;
                    unsigned int v112 = *v105;
                    if (v111 != v112) {
                      break;
                    }
                    ++v110;
                    ++v105;
                    if (!--v109) {
                      goto LABEL_136;
                    }
                  }
                  if (v111 <= v112) {
                    break;
                  }
                }
LABEL_136:
                uint64_t v105 = *(unsigned __int16 **)(v10 + 48);
                uint64_t v113 = *(void *)(v10 + 56);
                v10 += 48;
                uint64_t v114 = v113 - (void)v105;
                unint64_t v108 = (v113 - (uint64_t)v105) >> 1;
                if (v104 > v114 >> 1) {
                  goto LABEL_137;
                }
              }
            }
            do
            {
              do
              {
LABEL_137:
                int v115 = *(unsigned __int16 **)(v97 - 48);
                uint64_t v116 = *(void *)(v97 - 40);
                v97 -= 48;
                uint64_t v117 = v116 - (void)v115;
              }
              while (v104 > v117 >> 1);
              if (*((void *)&v275 + 1) == (void)v275 || v104 < v117 >> 1) {
                break;
              }
              uint64_t v118 = (uint64_t)(*((void *)&v275 + 1) - v275) >> 1;
              uint64_t v119 = (unsigned __int16 *)v275;
              while (1)
              {
                unsigned int v120 = *v119;
                unsigned int v121 = *v115;
                if (v120 != v121) {
                  break;
                }
                ++v119;
                ++v115;
                if (!--v118) {
                  goto LABEL_145;
                }
              }
            }
            while (v120 <= v121);
          }
          if ((unsigned __int16 **)(v10 - 48) != a1)
          {
            std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)a1, *(char **)(v10 - 48), *(void *)(v10 - 40), (uint64_t)(*(void *)(v10 - 40) - *(void *)(v10 - 48)) >> 1);
            *((_WORD *)a1 + 20)  = *(_WORD *)(v10 - 8);
            uint64_t v28 = *((void *)&v275 + 1);
            unint64_t v27 = (char *)v275;
          }
          std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)(v10 - 48), v27, v28, (v28 - (uint64_t)v27) >> 1);
          *(_WORD *)(v10 - 8)  = WORD4(v277);
          std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v275);
          a4  = 0;
        }
        *(void *)&long long v41 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v41 + 1)  = 0xAAAAAAAAAAAAAAAALL;
        v276  = v41;
        v277  = v41;
        v275  = v41;
        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>((uint64_t)&v275, *a1, a1[1]);
        WORD4(v277)  = *((_WORD *)a1 + 20);
        uint64_t v43 = *((void *)&v275 + 1);
        unsigned int v42 = (char *)v275;
        unint64_t v44 = (uint64_t)(*((void *)&v275 + 1) - v275) >> 1;
        uint64_t v45 = a1;
        do
        {
          do
          {
            uint64_t v46 = v45;
            uint64_t v47 = v45[6];
            uint64_t v48 = v45[7];
            v45 += 6;
            unint64_t v49 = v48 - v47;
          }
          while (v49 > v44);
          if (v48 == v47 || v49 < v44) {
            break;
          }
          __int16 v51 = (unsigned __int16 *)v275;
          while (1)
          {
            unsigned int v52 = *v47;
            unsigned int v53 = *v51;
            if (v52 != v53) {
              break;
            }
            ++v47;
            ++v51;
            if (!--v49) {
              goto LABEL_40;
            }
          }
        }
        while (v52 <= v53);
LABEL_40:
        if (v46 == a1)
        {
          uint64_t v57 = a2;
          if (v45 < a2)
          {
            unint64_t v61 = *(a2 - 6);
            unint64_t v62 = *(a2 - 5);
            unint64_t v63 = v62 - v61;
            uint64_t v57 = a2 - 6;
            if (v63 <= v44)
            {
              uint64_t v57 = a2 - 6;
              do
              {
                if (v62 == v61 || v63 < v44)
                {
LABEL_60:
                  if (v45 >= v57) {
                    break;
                  }
                }
                else
                {
                  __int16 v64 = (unsigned __int16 *)v275;
                  while (1)
                  {
                    unsigned int v65 = *v61;
                    unsigned int v66 = *v64;
                    if (v65 != v66) {
                      break;
                    }
                    ++v61;
                    ++v64;
                    if (!--v63) {
                      goto LABEL_60;
                    }
                  }
                  if (v65 <= v66 || v45 >= v57) {
                    break;
                  }
                }
                unint64_t v61 = *(v57 - 6);
                unint64_t v62 = *(v57 - 5);
                v57 -= 6;
                unint64_t v63 = v62 - v61;
              }
              while (v63 <= v44);
            }
          }
        }
        else
        {
          uint64_t v54 = *(a2 - 6);
          uint64_t v55 = *(a2 - 5);
          unint64_t v56 = v55 - v54;
          uint64_t v57 = a2 - 6;
          if (v56 <= v44)
          {
            uint64_t v57 = a2 - 6;
            do
            {
              if (v55 != v54 && v56 >= v44)
              {
                uint64_t v58 = (unsigned __int16 *)v275;
                while (1)
                {
                  unsigned int v59 = *v54;
                  unsigned int v60 = *v58;
                  if (v59 != v60) {
                    break;
                  }
                  ++v54;
                  ++v58;
                  if (!--v56) {
                    goto LABEL_50;
                  }
                }
                if (v59 <= v60) {
                  break;
                }
              }
LABEL_50:
              uint64_t v54 = *(v57 - 6);
              uint64_t v55 = *(v57 - 5);
              v57 -= 6;
              unint64_t v56 = v55 - v54;
            }
            while (v56 <= v44);
          }
        }
        if (v45 >= v57)
        {
          unint64_t v10 = (unint64_t)v45;
        }
        else
        {
          unint64_t v68 = (unint64_t)v57;
          unint64_t v10 = (unint64_t)v45;
          do
          {
            uint64_t v43 = *((void *)&v275 + 1);
            unsigned int v42 = (char *)v275;
            unint64_t v69 = (uint64_t)(*((void *)&v275 + 1) - v275) >> 1;
            do
            {
              do
              {
                float v70 = *(unsigned __int16 **)(v10 + 48);
                uint64_t v71 = *(unsigned __int16 **)(v10 + 56);
                v10 += 48;
                unint64_t v72 = v71 - v70;
              }
              while (v72 > v69);
              if (v71 == v70 || v72 < v69) {
                break;
              }
              long long v74 = (unsigned __int16 *)v275;
              while (1)
              {
                unsigned int v75 = *v70;
                unsigned int v76 = *v74;
                if (v75 != v76) {
                  break;
                }
                ++v70;
                ++v74;
                if (!--v72) {
                  goto LABEL_81;
                }
              }
            }
            while (v75 <= v76);
            while (1)
            {
LABEL_81:
              unsigned __int16 v77 = *(unsigned __int16 **)(v68 - 48);
              unint64_t v78 = *(unsigned __int16 **)(v68 - 40);
              v68 -= 48;
              unint64_t v79 = v78 - v77;
              if (v79 > v69) {
                break;
              }
              if (v78 != v77 && v79 >= v69)
              {
                long long v80 = (unsigned __int16 *)v275;
                while (1)
                {
                  unsigned int v81 = *v77;
                  unsigned int v82 = *v80;
                  if (v81 != v82) {
                    break;
                  }
                  ++v77;
                  ++v80;
                  if (!--v79) {
                    goto LABEL_81;
                  }
                }
                if (v81 <= v82) {
                  break;
                }
              }
            }
          }
          while (v10 < v68);
        }
        if ((unsigned __int16 **)(v10 - 48) != a1)
        {
          std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)a1, *(char **)(v10 - 48), *(void *)(v10 - 40), (uint64_t)(*(void *)(v10 - 40) - *(void *)(v10 - 48)) >> 1);
          *((_WORD *)a1 + 20)  = *(_WORD *)(v10 - 8);
          uint64_t v43 = *((void *)&v275 + 1);
          unsigned int v42 = (char *)v275;
        }
        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)(v10 - 48), v42, v43, (v43 - (uint64_t)v42) >> 1);
        *(_WORD *)(v10 - 8)  = WORD4(v277);
        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v275);
        if (v45 >= v57) {
          break;
        }
LABEL_97:
        a4  = 0;
      }
      if ((v83 & 1) == 0) {
        goto LABEL_97;
      }
    }
    a2  = (unsigned __int16 **)(v10 - 48);
    if ((v83 & 1) == 0) {
      continue;
    }
    break;
  }
}

void std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<anonymous namespace'::LigInput *&,anonymous namespace'::LigInput *&>(uint64_t a1, uint64_t a2)
{
  *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  v5[1]  = v4;
  long long v6 = v4;
  v5[0]  = v4;
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>((uint64_t)v5, *(unsigned char **)a1, *(unsigned char **)(a1 + 8));
  WORD4(v6)  = *(_WORD *)(a1 + 40);
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)a1, *(char **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 1);
  *(_WORD *)(a1 + 40)  = *(_WORD *)(a2 + 40);
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)a2, *(char **)&v5[0], *((uint64_t *)&v5[0] + 1), (uint64_t)(*((void *)&v5[0] + 1) - *(void *)&v5[0]) >> 1);
  *(_WORD *)(a2 + 40)  = WORD4(v6);
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)v5);
}

void std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,anonymous namespace'::LigInput *,0>(unsigned __int16 **a1, unsigned __int16 **a2, unsigned __int16 **a3, uint64_t a4, unsigned __int16 **a5)
{
  unint64_t v10 = *a5;
  uint64_t v11 = a5[1];
  uint64_t v12 = *(unsigned __int16 **)a4;
  unint64_t v13 = v11 - *a5;
  uint64_t v14 = *(void *)(a4 + 8) - *(void *)a4;
  if (v13 > v14 >> 1) {
    goto LABEL_2;
  }
  unint64_t v30 = v14 >> 1;
  if (v11 != v10 && v13 >= v30)
  {
    while (1)
    {
      unsigned int v32 = *v10;
      unsigned int v33 = *v12;
      if (v32 != v33) {
        break;
      }
      ++v10;
      ++v12;
      if (!--v13) {
        return;
      }
    }
    if (v32 <= v33)
    {
LABEL_2:
      uint64_t v15 = *(unsigned __int16 **)a4;
      size_t v16 = *(unsigned __int16 **)(a4 + 8);
      BOOL v17 = *a3;
      unint64_t v18 = ((uint64_t)v16 - *(void *)a4) >> 1;
      uint64_t v19 = (char *)a3[1] - (char *)*a3;
      if (v18 > v19 >> 1) {
        goto LABEL_3;
      }
      if (v16 != v15 && v18 >= v19 >> 1)
      {
        while (1)
        {
          unsigned int v34 = *v15;
          unsigned int v35 = *v17;
          if (v34 != v35) {
            break;
          }
          ++v15;
          ++v17;
          if (!--v18) {
            return;
          }
        }
        if (v34 <= v35)
        {
LABEL_3:
          uint64_t v20 = *a3;
          unint64_t v21 = a3[1];
          unint64_t v22 = *a2;
          unint64_t v23 = v21 - *a3;
          uint64_t v24 = (char *)a2[1] - (char *)*a2;
          if (v23 > v24 >> 1) {
            goto LABEL_4;
          }
          if (v21 != v20 && v23 >= v24 >> 1)
          {
            while (1)
            {
              unsigned int v36 = *v20;
              unsigned int v37 = *v22;
              if (v36 != v37) {
                break;
              }
              ++v20;
              ++v22;
              if (!--v23) {
                return;
              }
            }
            if (v36 <= v37)
            {
LABEL_4:
              unsigned int v25 = *a2;
              long long v26 = a2[1];
              unint64_t v27 = *a1;
              unint64_t v28 = v26 - *a2;
              uint64_t v29 = (char *)a1[1] - (char *)*a1;
              if (v28 > v29 >> 1) {
                goto LABEL_5;
              }
              if (v26 != v25 && v28 >= v29 >> 1)
              {
                while (1)
                {
                  unsigned int v38 = *v25;
                  unsigned int v39 = *v27;
                  if (v38 != v39) {
                    break;
                  }
                  ++v25;
                  ++v27;
                  if (!--v28) {
                    return;
                  }
                }
                if (v38 <= v39)
                {
LABEL_5:
                }
              }
            }
          }
        }
      }
    }
  }
}

void std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,anonymous namespace'::LigInput *>(unsigned __int16 **a1, unsigned __int16 **a2, unsigned __int16 **a3)
{
  char v5 = a1;
  long long v6 = *a2;
  unsigned int v7 = a2[1];
  unint64_t v8 = *a1;
  unint64_t v9 = v7 - *a2;
  uint64_t v10 = (char *)a1[1] - (char *)*a1;
  if (v9 > v10 >> 1)
  {
    uint64_t v11 = *a3;
    uint64_t v12 = a3[1];
    unint64_t v13 = v12 - *a3;
    if (v13 <= v9)
    {
      BOOL v14 = 1;
      goto LABEL_17;
    }
LABEL_25:
    uint64_t v25 = (uint64_t)a3;
LABEL_26:
    return;
  }
  unint64_t v15 = v10 >> 1;
  if (v7 != v6 && v9 >= v15)
  {
    uint64_t v17 = v7 - *a2;
    unint64_t v18 = *a2;
    while (1)
    {
      unsigned int v19 = *v18;
      unsigned int v20 = *v8;
      if (v19 != v20) {
        break;
      }
      ++v18;
      ++v8;
      if (!--v17) {
        goto LABEL_12;
      }
    }
    BOOL v14 = v19 <= v20;
  }
  else
  {
LABEL_12:
    BOOL v14 = 0;
  }
  uint64_t v11 = *a3;
  uint64_t v12 = a3[1];
  unint64_t v13 = v12 - *a3;
  if (v13 > v9)
  {
    if (!v14) {
      goto LABEL_31;
    }
    goto LABEL_25;
  }
LABEL_17:
  if (v13 < v9 || v12 == v11)
  {
LABEL_23:
    BOOL v24 = 0;
    if (!v14) {
      goto LABEL_30;
    }
    goto LABEL_24;
  }
  while (1)
  {
    unsigned int v22 = *v11;
    unsigned int v23 = *v6;
    if (v22 != v23) {
      break;
    }
    ++v11;
    ++v6;
    if (!--v13) {
      goto LABEL_23;
    }
  }
  BOOL v24 = v22 <= v23;
  if (v14)
  {
LABEL_24:
    if (!v24)
    {
      unint64_t v31 = *a3;
      unsigned int v32 = a3[1];
      unsigned int v33 = *a2;
      unint64_t v34 = v32 - *a3;
      uint64_t v35 = (char *)a2[1] - (char *)*a2;
      if (v34 <= v35 >> 1)
      {
        if (v32 == v31 || v34 < v35 >> 1) {
          return;
        }
        while (1)
        {
          unsigned int v38 = *v31;
          unsigned int v39 = *v33;
          if (v38 != v39) {
            break;
          }
          ++v31;
          ++v33;
          if (!--v34) {
            return;
          }
        }
        if (v38 > v39) {
          return;
        }
      }
      a1  = a2;
    }
    goto LABEL_25;
  }
LABEL_30:
  if (!v24) {
    return;
  }
LABEL_31:
  long long v26 = *a2;
  unint64_t v27 = a2[1];
  unint64_t v28 = (char *)*v5;
  unint64_t v29 = v27 - *a2;
  uint64_t v30 = (char *)v5[1] - (char *)*v5;
  if (v29 > v30 >> 1) {
    goto LABEL_32;
  }
  if (v27 != v26 && v29 >= v30 >> 1)
  {
    while (1)
    {
      unsigned int v36 = *v26;
      unsigned int v37 = *(unsigned __int16 *)v28;
      if (v36 != v37) {
        break;
      }
      ++v26;
      v28 += 2;
      if (!--v29) {
        return;
      }
    }
    if (v36 <= v37)
    {
LABEL_32:
      a1  = v5;
      uint64_t v25 = (uint64_t)a2;
      goto LABEL_26;
    }
  }
}

uint64_t std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,anonymous namespace'::LigInput *>(uint64_t a1, unsigned __int16 **a2)
{
  BOOL v4 = 1;
  switch(0xAAAAAAAAAAAAAAABLL * (((uint64_t)a2 - a1) >> 4))
  {
    case 0uLL:
    case 1uLL:
      return v4;
    case 2uLL:
      char v5 = *(a2 - 6);
      long long v6 = *(a2 - 5);
      unsigned int v7 = *(unsigned __int16 **)a1;
      unint64_t v8 = v6 - v5;
      uint64_t v9 = *(void *)(a1 + 8) - *(void *)a1;
      if (v8 > v9 >> 1) {
        goto LABEL_3;
      }
      unint64_t v36 = v9 >> 1;
      if (v6 == v5 || v8 < v36) {
        return v4;
      }
      while (1)
      {
        unsigned int v38 = *v5;
        unsigned int v39 = *v7;
        if (v38 != v39) {
          break;
        }
        ++v5;
        ++v7;
        if (!--v8) {
          return v4;
        }
      }
      if (v38 <= v39)
      {
LABEL_3:
        return 1;
      }
      return 1;
    case 3uLL:
      return v4;
    case 4uLL:
      return v4;
    case 5uLL:
      return v4;
    default:
      uint64_t v10 = a1 + 96;
      uint64_t v11 = (unsigned __int16 **)(a1 + 144);
      if ((unsigned __int16 **)(a1 + 144) == a2) {
        return 1;
      }
      int v12 = 0;
      break;
  }
  while (1)
  {
    unint64_t v13 = *v11;
    BOOL v14 = v11[1];
    unint64_t v15 = *(char **)v10;
    unint64_t v16 = v14 - *v11;
    uint64_t v17 = *(void *)(v10 + 8) - *(void *)v10;
    if (v16 <= v17 >> 1)
    {
      unint64_t v30 = v17 >> 1;
      if (v14 == v13 || v16 < v30) {
        goto LABEL_38;
      }
      unsigned int v32 = *v11;
      while (1)
      {
        unsigned int v33 = *v32;
        unsigned int v34 = *(unsigned __int16 *)v15;
        if (v33 != v34) {
          break;
        }
        ++v32;
        v15 += 2;
        if (!--v16) {
          goto LABEL_38;
        }
      }
      if (v33 > v34) {
        goto LABEL_38;
      }
    }
    *(void *)&long long v18 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v18 + 1)  = 0xAAAAAAAAAAAAAAAALL;
    v40[1]  = v18;
    long long v41 = v18;
    v40[0]  = v18;
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>((uint64_t)v40, v13, v14);
    WORD4(v41)  = *((_WORD *)v11 + 20);
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)v11, *(char **)v10, *(void *)(v10 + 8), (uint64_t)(*(void *)(v10 + 8) - *(void *)v10) >> 1);
    *((_WORD *)v11 + 20)  = *(_WORD *)(v10 + 40);
    uint64_t v19 = a1;
    if (v10 != a1)
    {
      uint64_t v20 = v10;
      while (1)
      {
        unint64_t v21 = *(char **)(v20 - 48);
        uint64_t v22 = *(void *)(v20 - 40);
        v20 -= 48;
        uint64_t v24 = *((void *)&v40[0] + 1);
        unsigned int v23 = *(char **)&v40[0];
        unint64_t v25 = (uint64_t)(*((void *)&v40[0] + 1) - *(void *)&v40[0]) >> 1;
        if (v25 <= (v22 - (uint64_t)v21) >> 1)
        {
          if (*((void *)&v40[0] + 1) == *(void *)&v40[0] || v25 < (v22 - (uint64_t)v21) >> 1) {
            break;
          }
          uint64_t v27 = 0;
          while (1)
          {
            unsigned int v28 = *(unsigned __int16 *)(*(void *)&v40[0] + 2 * v27);
            unsigned int v29 = *(unsigned __int16 *)&v21[2 * v27];
            if (v28 != v29) {
              break;
            }
            if (v25 == ++v27) {
              goto LABEL_36;
            }
          }
          if (v28 > v29) {
            break;
          }
        }
        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)v10, v21, v22, (v22 - (uint64_t)v21) >> 1);
        *(_WORD *)(v10 + 40)  = *(_WORD *)(v10 - 8);
        uint64_t v10 = v20;
        if (v20 == a1)
        {
          uint64_t v19 = a1;
          goto LABEL_35;
        }
      }
      uint64_t v19 = v10;
    }
LABEL_35:
    uint64_t v24 = *((void *)&v40[0] + 1);
    unsigned int v23 = *(char **)&v40[0];
    unint64_t v25 = (uint64_t)(*((void *)&v40[0] + 1) - *(void *)&v40[0]) >> 1;
    uint64_t v10 = v19;
LABEL_36:
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)v10, v23, v24, v25);
    *(_WORD *)(v10 + 40)  = WORD4(v41);
    if (++v12 == 8) {
      break;
    }
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)v40);
LABEL_38:
    uint64_t v10 = (uint64_t)v11;
    v11 += 6;
    if (v11 == a2) {
      return 1;
    }
  }
  BOOL v4 = v11 + 6 == a2;
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)v40);
  return v4;
}

void std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,anonymous namespace'::LigInput *>(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int16 **a4)
{
  unint64_t v8 = *a4;
  uint64_t v9 = a4[1];
  uint64_t v10 = *(unsigned __int16 **)a3;
  unint64_t v11 = v9 - *a4;
  uint64_t v12 = *(void *)(a3 + 8) - *(void *)a3;
  if (v11 > v12 >> 1) {
    goto LABEL_2;
  }
  unint64_t v23 = v12 >> 1;
  if (v9 != v8 && v11 >= v23)
  {
    while (1)
    {
      unsigned int v25 = *v8;
      unsigned int v26 = *v10;
      if (v25 != v26) {
        break;
      }
      ++v8;
      ++v10;
      if (!--v11) {
        return;
      }
    }
    if (v25 <= v26)
    {
LABEL_2:
      unint64_t v13 = *(unsigned __int16 **)a3;
      BOOL v14 = *(unsigned __int16 **)(a3 + 8);
      unint64_t v15 = *(unsigned __int16 **)a2;
      unint64_t v16 = ((uint64_t)v14 - *(void *)a3) >> 1;
      uint64_t v17 = *(void *)(a2 + 8) - *(void *)a2;
      if (v16 > v17 >> 1) {
        goto LABEL_3;
      }
      if (v14 != v13 && v16 >= v17 >> 1)
      {
        while (1)
        {
          unsigned int v27 = *v13;
          unsigned int v28 = *v15;
          if (v27 != v28) {
            break;
          }
          ++v13;
          ++v15;
          if (!--v16) {
            return;
          }
        }
        if (v27 <= v28)
        {
LABEL_3:
          long long v18 = *(unsigned __int16 **)a2;
          uint64_t v19 = *(unsigned __int16 **)(a2 + 8);
          uint64_t v20 = *(unsigned __int16 **)a1;
          unint64_t v21 = ((uint64_t)v19 - *(void *)a2) >> 1;
          uint64_t v22 = *(void *)(a1 + 8) - *(void *)a1;
          if (v21 > v22 >> 1) {
            goto LABEL_4;
          }
          if (v19 != v18 && v21 >= v22 >> 1)
          {
            while (1)
            {
              unsigned int v29 = *v18;
              unsigned int v30 = *v20;
              if (v29 != v30) {
                break;
              }
              ++v18;
              ++v20;
              if (!--v21) {
                return;
              }
            }
            if (v29 <= v30)
            {
LABEL_4:
            }
          }
        }
      }
    }
  }
}

BOOL anonymous namespace'::MorxLigatureSubtableBuilder::StateNeedsAction(_anonymous_namespace_::MorxLigatureSubtableBuilder *this, int a2, int a3)
{
  unint64_t v3 = (a3 + *((_DWORD *)this + 6) * a2);
  uint64_t v4 = *((void *)this + 5);
  BOOL result = 0;
  if (v3 < (*((void *)this + 6) - v4) >> 1)
  {
    unint64_t v5 = *(unsigned __int16 *)(v4 + 2 * v3);
    uint64_t v6 = *((void *)this + 17);
    if (0xAAAAAAAAAAAAAAABLL * ((*((void *)this + 18) - v6) >> 1) > v5)
    {
      unsigned int v7 = (unsigned __int16 *)(v6 + 6 * v5);
      char v8 = v7[1];
      unsigned int v9 = bswap32(*v7) >> 16;
      if ((v8 & 0xE0) != 0 || v9 > 1) {
        return 1;
      }
    }
  }
  return result;
}

void std::vector<anonymous namespace'::StateMemberInfo,TInlineBufferAllocator<anonymous namespace'::StateMemberInfo,30ul>>::push_back[abi:nn180100](char **a1, uint64_t a2)
{
  unint64_t v5 = a1[1];
  uint64_t v4 = a1[2];
  if (v5 < v4)
  {
    *(_WORD *)unint64_t v5 = *(_WORD *)a2;
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>((uint64_t)(v5 + 8), *(unsigned char **)(a2 + 8), *(unsigned char **)(a2 + 16));
    int v6 = *(_DWORD *)(a2 + 48);
    *((_WORD *)v5 + 26)  = *(_WORD *)(a2 + 52);
    *((_DWORD *)v5 + 12)  = v6;
    unsigned int v7 = v5 + 56;
    goto LABEL_25;
  }
  char v8 = (char *)(a1 + 3);
  uint64_t v9 = 0x6DB6DB6DB6DB6DB7 * ((v5 - *a1) >> 3);
  if ((unint64_t)(v9 + 1) > 0x492492492492492) {
    abort();
  }
  unint64_t v10 = 0x6DB6DB6DB6DB6DB7 * ((v4 - *a1) >> 3);
  uint64_t v11 = 2 * v10;
  if (2 * v10 <= v9 + 1) {
    uint64_t v11 = v9 + 1;
  }
  if (v10 >= 0x249249249249249) {
    unint64_t v12 = 0x492492492492492;
  }
  else {
    unint64_t v12 = v11;
  }
  if (v12) {
  else
  }
    unint64_t v13 = 0;
  BOOL v14 = &v13[56 * v9];
  unint64_t v15 = &v13[56 * v12];
  *(_WORD *)BOOL v14 = *(_WORD *)a2;
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>((uint64_t)(v14 + 8), *(unsigned char **)(a2 + 8), *(unsigned char **)(a2 + 16));
  int v16 = *(_DWORD *)(a2 + 48);
  *((_WORD *)v14 + 26)  = *(_WORD *)(a2 + 52);
  *((_DWORD *)v14 + 12)  = v16;
  unsigned int v7 = v14 + 56;
  long long v18 = *a1;
  uint64_t v17 = a1[1];
  if (v17 == *a1)
  {
    *a1  = v14;
    a1[1]  = v7;
    unint64_t v23 = a1[2];
    a1[2]  = v15;
    if (!v17) {
      goto LABEL_25;
    }
    goto LABEL_20;
  }
  uint64_t v19 = 0;
  do
  {
    uint64_t v20 = &v14[v19];
    *(_WORD *)&v14[v19 - 56]  = *(_WORD *)&v17[v19 - 56];
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>((uint64_t)&v14[v19 - 48], *(unsigned char **)&v17[v19 - 48], *(unsigned char **)&v17[v19 - 40]);
    int v21 = *(_DWORD *)&v17[v19 - 8];
    *((_WORD *)v20 - 2)  = *(_WORD *)&v17[v19 - 4];
    *((_DWORD *)v20 - 2)  = v21;
    v19 -= 56;
  }
  while (&v17[v19] != v18);
  uint64_t v17 = *a1;
  uint64_t v22 = a1[1];
  *a1  = &v14[v19];
  a1[1]  = v7;
  unint64_t v23 = a1[2];
  a1[2]  = v15;
  if (v22 != v17)
  {
    do
    {
      uint64_t v24 = v22 - 56;
      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)(v22 - 48));
      uint64_t v22 = v24;
    }
    while (v24 != v17);
  }
  if (v17)
  {
LABEL_20:
    if (v8 > v17 || (unsigned int v25 = a1 + 213, a1 + 213 <= (char **)v17))
    {
      operator delete(v17);
    }
    else if (v23 == *v25)
    {
      *unsigned int v25 = v17;
    }
  }
LABEL_25:
  a1[1]  = v7;
}

void DoSubgroupSubstitutions(void *a1, uint64_t a2, unsigned __int16 **a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a2 + 48) - *(void *)(a2 + 40);
  if (v4)
  {
    uint64_t v8 = 0;
    unint64_t v9 = v4 / 56;
    unint64_t v22 = v9;
    if (v9 <= 1) {
      uint64_t v10 = 1;
    }
    else {
      uint64_t v10 = v9;
    }
    do
    {
      uint64_t v11 = *(void *)(a2 + 40);
      uint64_t v12 = v11 + 56 * v8;
      uint64_t v13 = *(void *)(v12 + 8);
      uint64_t v14 = *(void *)(v12 + 16);
      unint64_t v15 = (unsigned __int16 **)(v12 + 8);
      if (v13 == v14)
      {
        if (*(__int16 *)(v11 + 56 * v8 + 50) >= 1) {
          DoSubgroupSubstitutions();
        }
      }
      else if (ReplaceSubgroupWithSingle(v15, a3, a4))
      {
        unint64_t v25 = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&long long v16 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v16 + 1)  = 0xAAAAAAAAAAAAAAAALL;
        v24[0]  = v16;
        v24[1]  = v16;
        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>((uint64_t)v24, *v15, v15[1]);
        uint64_t v17 = 0;
        long long v18 = *(const void **)&v24[0];
        size_t v19 = *((void *)&v24[0] + 1) - *(void *)&v24[0];
        uint64_t v20 = (void *)(*(void *)(a2 + 40) + 16);
        while (1)
        {
          int v21 = (const void *)*(v20 - 1);
          if (*v20 - (void)v21 != v19 || memcmp(v21, v18, v19)) {
            break;
          }
          ++v17;
          v20 += 7;
          if (v10 == v17)
          {
            uint64_t v17 = v10;
            break;
          }
        }
        if (v17 == v22) {
          ChangeIdentityForward(a1, a2, a3, a4);
        }
        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)v24);
      }
      ++v8;
    }
    while (v8 != v10);
  }
}

uint64_t GetActionLookupIndex(char **a1, uint64_t a2, int a3, uint64_t a4)
{
  long long v44 = 0xAAAAAAAAAAAAAAAALL;
  v46[0]  = 0xAAAAAAAAAAAAAAAALL;
  long long v45 = 0uLL;
  v46[1]  = v46;
  unint64_t v47 = 0xAAAAAAAAAAAAAAAALL;
  WORD1(v47)  = *((_WORD *)a1 + 857);
  int v6 = *(void **)a4;
  uint64_t v5 = *(void *)(a4 + 8);
  __int16 v7 = *((_WORD *)a1 + 856);
  if (*(void *)a4 == v5) {
    __int16 v7 = -1;
  }
  LOWORD(v47)  = v7;
  uint64_t v8 = *a1;
  uint64_t v42 = v5;
  int v9 = -1227133513 * ((unint64_t)(a1[1] - *a1) >> 3);
  unsigned int v10 = 0;
  if (v9 >= 1)
  {
    char v11 = 0;
    size_t v12 = v5 - (void)v6;
    do
    {
      uint64_t v13 = &v8[56 * v10];
      uint64_t v14 = *(unsigned __int16 *)v13;
      unint64_t v15 = (const void *)*((void *)v13 + 1);
      BOOL v16 = v12 == *((void *)v13 + 2) - (void)v15 && memcmp(v6, v15, v12) == 0;
      if (v14 == a2)
      {
        if (*(__int16 *)&v8[56 * v10 + 2] == a3)
        {
          if (v16) {
            break;
          }
        }
        else
        {
          char v17 = !v16;
          if (v6 == (void *)v42) {
            char v17 = 1;
          }
          if ((v17 & 1) == 0) {
            LODWORD(v47)  = *(_DWORD *)&v8[56 * v10 + 48];
          }
        }
        char v11 = 1;
      }
      else if (v11)
      {
        unsigned int v10 = v9 - 1;
      }
      ++v10;
    }
    while ((int)v10 < v9);
  }
  long long v18 = a1;
  if (v10 == v9)
  {
    LOWORD(v44)  = a2;
    WORD1(v44)  = a3;
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<unsigned short const*>,std::__wrap_iter<unsigned short const*>>((char *)&v44 + 8, (char *)v6, v42, (v42 - (uint64_t)v6) >> 1);
    uint64_t v20 = a1[1];
    unint64_t v19 = (unint64_t)a1[2];
    if ((unint64_t)v20 < v19)
    {
      *(_DWORD *)uint64_t v20 = v44;
      std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>((uint64_t)(v20 + 8), *((unsigned char **)&v44 + 1), (unsigned char *)v45);
      *((_DWORD *)v20 + 12)  = v47;
      int v21 = v20 + 56;
      goto LABEL_50;
    }
    uint64_t v22 = 0x6DB6DB6DB6DB6DB7 * ((v20 - *a1) >> 3);
    if ((unint64_t)(v22 + 1) > 0x492492492492492) {
      abort();
    }
    unint64_t v23 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v19 - (void)*a1) >> 3);
    uint64_t v24 = 2 * v23;
    if (2 * v23 <= v22 + 1) {
      uint64_t v24 = v22 + 1;
    }
    if (v23 >= 0x249249249249249) {
      unint64_t v25 = 0x492492492492492;
    }
    else {
      unint64_t v25 = v24;
    }
    if (v25)
    {
      unsigned int v26 = a1[213];
      unint64_t v27 = (unint64_t)&v26[56 * v25];
      if (v27 <= (unint64_t)(a1 + 213))
      {
        a1[213]  = (char *)v27;
      }
      else
      {
        if (v25 > 0x492492492492492) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        unsigned int v26 = (char *)operator new(56 * v25);
      }
    }
    else
    {
      unsigned int v26 = 0;
    }
    unsigned int v28 = &v26[56 * v22];
    unsigned int v29 = &v26[56 * v25];
    *(_DWORD *)unsigned int v28 = v44;
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>((uint64_t)(v28 + 8), *((unsigned char **)&v44 + 1), (unsigned char *)v45);
    *((_DWORD *)v28 + 12)  = v47;
    int v21 = v28 + 56;
    unsigned int v30 = *a1;
    unint64_t v31 = a1[1];
    if (v31 == *a1)
    {
      *a1  = v28;
      a1[1]  = v21;
      unsigned int v34 = a1[2];
      a1[2]  = v29;
    }
    else
    {
      uint64_t v32 = 0;
      do
      {
        *(_DWORD *)&v28[v32 - 56]  = *(_DWORD *)&v31[v32 - 56];
        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>((uint64_t)&v28[v32 - 48], *(unsigned char **)&v31[v32 - 48], *(unsigned char **)&v31[v32 - 40]);
        *(_DWORD *)&v28[v32 - 8]  = *(_DWORD *)&v31[v32 - 8];
        v32 -= 56;
      }
      while (&v31[v32] != v30);
      long long v18 = a1;
      unint64_t v31 = *a1;
      unsigned int v33 = a1[1];
      *a1  = &v28[v32];
      a1[1]  = v21;
      unsigned int v34 = a1[2];
      a1[2]  = v29;
      if (v33 == v31)
      {
        if (v31) {
          goto LABEL_44;
        }
        goto LABEL_50;
      }
      do
      {
        uint64_t v35 = v33 - 56;
        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)(v33 - 48));
        unsigned int v33 = v35;
      }
      while (v35 != v31);
    }
    if (v31)
    {
LABEL_44:
      if (a1 + 3 > (char **)v31 || (unint64_t v36 = v18 + 213, v18 + 213 <= (char **)v31))
      {
        operator delete(v31);
      }
      else if (v34 == *v36)
      {
        *unint64_t v36 = v31;
      }
    }
LABEL_50:
    v18[1]  = v21;
    unsigned int v37 = *(void **)a4;
    uint64_t v38 = *(void *)(a4 + 8);
    if (*(void *)a4 != v38)
    {
      if ((unsigned __int16)v47 == *((unsigned __int16 *)v18 + 856)) {
        *((_WORD *)v18 + 856)  = v47 + 1;
      }
      if (WORD1(v47) == *((unsigned __int16 *)v18 + 857)) {
        *((_WORD *)v18 + 857)  = WORD1(v47) + ((v38 - v37) >> 1) + 1;
      }
    }
  }
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v44 + 8);
  return (unsigned __int16)v10;
}

char *std::__allocate_at_least[abi:nn180100]<TInlineBufferAllocator<anonymous namespace'::StateMemberInfo,30ul>>(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = (char *)(a1 + 1680);
  BOOL result = *(char **)(a1 + 1680);
  uint64_t v4 = &result[56 * a2];
  if (v4 <= v2)
  {
    *(void *)uint64_t v2 = v4;
  }
  else
  {
    if (a2 >= 0x492492492492493) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    return (char *)operator new(56 * a2);
  }
  return result;
}

char **TInlineVector<anonymous namespace'::StateMemberInfo,30ul>::TInlineVector(char **a1, uint64_t a2, uint64_t a3)
{
  *a1  = 0;
  a1[1]  = 0;
  uint64_t v4 = (uint64_t)(a1 + 3);
  a1[2]  = 0;
  a1[213]  = (char *)v4;
  if (a3 != a2)
  {
    uint64_t v5 = a2;
    unint64_t v6 = 0x6DB6DB6DB6DB6DB7 * ((a3 - a2) >> 3);
    if (v6 >= 0x492492492492493) {
      abort();
    }
    uint64_t v9 = 0;
    *a1  = v8;
    a1[1]  = v8;
    a1[2]  = &v8[56 * v10];
    uint64_t v11 = (uint64_t)(v8 + 8);
    do
    {
      *(_WORD *)(v11 - 8)  = *(_WORD *)v5;
      uint64_t v12 = std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>(v11, *(unsigned char **)(v5 + 8), *(unsigned char **)(v5 + 16));
      int v13 = *(_DWORD *)(v5 + 48);
      *(_WORD *)(v12 + 44)  = *(_WORD *)(v5 + 52);
      *(_DWORD *)(v12 + 40)  = v13;
      v9 += 56;
      uint64_t v11 = v12 + 56;
      v5 += 56;
    }
    while (v5 != a3);
    a1[1]  = &v8[v9];
  }
  return a1;
}

void std::allocator_traits<TInlineBufferAllocator<anonymous namespace'::StateInfo,30ul>>::destroy[abi:nn180100]<anonymous namespace'::StateInfo,void,void>(void *a1)
{
  uint64_t v2 = a1[5];
  if (v2)
  {
    uint64_t v3 = a1[6];
    uint64_t v4 = (void *)a1[5];
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = v3 - 56;
        std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100](v3 - 48);
        uint64_t v3 = v5;
      }
      while (v5 != v2);
      uint64_t v4 = (void *)a1[5];
    }
    a1[6]  = v2;
    unint64_t v6 = a1 + 218;
    if (a1 + 8 <= v4 && v6 > v4)
    {
      if (a1[7] == a1[218]) {
        *unint64_t v6 = v4;
      }
    }
    else
    {
      operator delete(v4);
    }
  }

  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)a1);
}

uint64_t ReplaceSubgroupWithSingle(unsigned __int16 **a1, unsigned __int16 **a2, unsigned __int16 a3)
{
  uint64_t v4 = *a1;
  uint64_t v3 = a1[1];
  uint64_t v5 = *a2;
  unint64_t v6 = a2[1];
  if ((char *)v3 - (char *)*a1 >= (unint64_t)((char *)v6 - (char *)*a2))
  {
    for (char i = 0; ; char i = 1)
    {
      int64_t v12 = (char *)v6 - (char *)v5;
      int v13 = v4;
      do
      {
        if (v6 == v5) {
          goto LABEL_15;
        }
        uint64_t v14 = v3 - v13;
        unint64_t v15 = v3;
        if (v14 >= v6 - v5)
        {
          uint64_t v16 = (uint64_t)&v13[v14 + 1 - (v6 - v5)];
          unint64_t v15 = v3;
          if ((unsigned __int16 *)v16 != v13)
          {
            while (*v13 != *v5)
            {
LABEL_13:
              if (++v13 == (unsigned __int16 *)v16)
              {
                unint64_t v15 = v3;
                goto LABEL_16;
              }
            }
            uint64_t v17 = 1;
            while (&v5[v17] != v6)
            {
              int v18 = v13[v17];
              int v19 = v5[v17++];
              if (v18 != v19) {
                goto LABEL_13;
              }
            }
LABEL_15:
            unint64_t v15 = v13;
          }
        }
LABEL_16:
        if (v3 == v15) {
          return i & 1;
        }
        *unint64_t v15 = a3;
        uint64_t v4 = v15 + 1;
        char i = 1;
        int v13 = v4;
      }
      while (v12 == 2);
      uint64_t v20 = (char *)v4 + v12 - 2;
      uint64_t v21 = (char *)v3 - v20;
      if (v3 != (unsigned __int16 *)v20)
      {
        memmove(v4, v20, (char *)v3 - v20);
        uint64_t v5 = *a2;
      }
      uint64_t v3 = (unsigned __int16 *)((char *)v4 + v21);
      a1[1]  = (unsigned __int16 *)((char *)v4 + v21);
      unint64_t v6 = a2[1];
    }
  }
  char i = 0;
  return i & 1;
}

uint64_t ChangeIdentityForward(void *a1, uint64_t a2, unsigned __int16 **a3, uint64_t a4)
{
  uint64_t result = ReplaceSubgroupWithSingle((unsigned __int16 **)a2, a3, a4);
  if (result)
  {
    uint64_t v9 = *(void *)(a2 + 48) - *(void *)(a2 + 40);
    if (v9)
    {
      unint64_t v10 = v9 / 56;
      *(unsigned char *)(a2 + 1752)  = 1;
      if (v10 <= 1) {
        uint64_t v11 = 1;
      }
      else {
        uint64_t v11 = v10;
      }
      uint64_t v12 = 50;
      do
      {
        if (*(__int16 *)(*(void *)(a2 + 40) + v12) != -1) {
          uint64_t result = ChangeIdentityForward(a1, *a1 + 1760 * *(__int16 *)(*(void *)(a2 + 40) + v12), a3, a4);
        }
        v12 += 56;
        --v11;
      }
      while (v11);
    }
  }
  return result;
}

unint64_t GetActionIndex(char **a1, int a2, int a3, int a4)
{
  __int16 v4 = a2;
  if (a4 == -1) {
    int v6 = a3;
  }
  else {
    int v6 = a3 | 0x2000;
  }
  if (a4 == -1) {
    unsigned __int16 v7 = 0;
  }
  else {
    unsigned __int16 v7 = a4;
  }
  uint64_t v9 = *a1;
  uint64_t v8 = a1[1];
  uint64_t v10 = v8 - *a1;
  unint64_t v11 = v10 / 6;
  if (v8 == *a1)
  {
LABEL_16:
    unint64_t v15 = (unint64_t)a1[2];
    if ((unint64_t)v8 >= v15)
    {
      unint64_t v17 = v11 + 1;
      if (v11 + 1 > 0x2AAAAAAAAAAAAAAALL) {
        abort();
      }
      if (0x5555555555555556 * ((uint64_t)(v15 - (void)v9) >> 1) > v17) {
        unint64_t v17 = 0x5555555555555556 * ((uint64_t)(v15 - (void)v9) >> 1);
      }
      if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v15 - (void)v9) >> 1) >= 0x1555555555555555) {
        unint64_t v18 = 0x2AAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v18 = v17;
      }
      if (v18)
      {
        int v19 = a1[26];
        unint64_t v20 = (unint64_t)&v19[6 * v18];
        if (v20 <= (unint64_t)a1 + 204)
        {
          a1[26]  = (char *)v20;
        }
        else
        {
          if (v18 > 0x2AAAAAAAAAAAAAAALL) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          int v19 = (char *)operator new(6 * v18);
        }
      }
      else
      {
        int v19 = 0;
      }
      uint64_t v21 = &v19[6 * v11];
      *(_WORD *)uint64_t v21 = v4;
      *((_WORD *)v21 + 1)  = v6;
      *((_WORD *)v21 + 2)  = v7;
      uint64_t v22 = v21;
      if (v8 != v9)
      {
        do
        {
          int v23 = *(_DWORD *)(v8 - 6);
          v8 -= 6;
          __int16 v24 = *((_WORD *)v8 + 2);
          *(_DWORD *)(v22 - 6)  = v23;
          v22 -= 6;
          *((_WORD *)v22 + 2)  = v24;
        }
        while (v8 != v9);
        uint64_t v8 = *a1;
        unint64_t v15 = (unint64_t)a1[2];
      }
      uint64_t v16 = v21 + 6;
      *a1  = v22;
      a1[1]  = v21 + 6;
      a1[2]  = &v19[6 * v18];
      if (v8)
      {
        if (a1 + 3 <= (char **)v8 && (char *)a1 + 204 > v8)
        {
          if ((char *)v15 == a1[26]) {
            a1[26]  = v8;
          }
        }
        else
        {
          operator delete(v8);
        }
      }
    }
    else
    {
      *(_WORD *)uint64_t v8 = a2;
      *((_WORD *)v8 + 1)  = v6;
      uint64_t v16 = v8 + 6;
      *((_WORD *)v8 + 2)  = v7;
    }
    a1[1]  = v16;
    return 0xAAAAAAAAAAAAAAABLL * ((v16 - *a1) >> 1) - 1;
  }
  else
  {
    unint64_t result = 0;
    if (v11 <= 1) {
      uint64_t v13 = 1;
    }
    else {
      uint64_t v13 = v10 / 6;
    }
    uint64_t v14 = (unsigned __int16 *)(v9 + 4);
    while (*(v14 - 2) != a2 || *(v14 - 1) != v6 || *v14 != v7)
    {
      ++result;
      v14 += 3;
      if (v13 == result) {
        goto LABEL_16;
      }
    }
  }
  return result;
}

void std::__function::__func<anonymous namespace'::MorxStateTableSubtableBuilder<STXEntryOne>::PopulateBitmap(long)::{lambda(unsigned short,unsigned short,unsigned short)#1},std::allocator<anonymous namespace'::MorxStateTableSubtableBuilder<STXEntryOne>::PopulateBitmap(long)::{lambda(unsigned short,unsigned short,unsigned short)#1}>,void ()(unsigned short,unsigned short,unsigned short)>::~__func()
{
}

__n128 std::__function::__func<anonymous namespace'::MorxStateTableSubtableBuilder<STXEntryOne>::PopulateBitmap(long)::{lambda(unsigned short,unsigned short,unsigned short)#1},std::allocator<anonymous namespace'::MorxStateTableSubtableBuilder<STXEntryOne>::PopulateBitmap(long)::{lambda(unsigned short,unsigned short,unsigned short)#1}>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_1ED060C50;
  *(_OWORD *)(v2 + 8)  = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24)  = result;
  return result;
}

__n128 std::__function::__func<anonymous namespace'::MorxStateTableSubtableBuilder<STXEntryOne>::PopulateBitmap(long)::{lambda(unsigned short,unsigned short,unsigned short)#1},std::allocator<anonymous namespace'::MorxStateTableSubtableBuilder<STXEntryOne>::PopulateBitmap(long)::{lambda(unsigned short,unsigned short,unsigned short)#1}>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2  = &unk_1ED060C50;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24)  = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8)  = result;
  return result;
}

uint64_t std::__function::__func<anonymous namespace'::MorxStateTableSubtableBuilder<STXEntryOne>::PopulateBitmap(long)::{lambda(unsigned short,unsigned short,unsigned short)#1},std::allocator<anonymous namespace'::MorxStateTableSubtableBuilder<STXEntryOne>::PopulateBitmap(long)::{lambda(unsigned short,unsigned short,unsigned short)#1}>,void ()(unsigned short,unsigned short,unsigned short)>::operator()(uint64_t result, unsigned __int16 *a2, unsigned __int16 *a3, unsigned __int16 *a4)
{
  __int16 v4 = *(_DWORD **)(result + 8);
  if (v4[6] > *a4)
  {
    uint64_t v5 = result;
    unsigned int v6 = *a2;
    unsigned int v7 = *a3;
    __n128 result = (*(uint64_t (**)(void, void, void))(*(void *)v4 + 16))(*(void *)(result + 8), 0, *a4);
    if (result)
    {
      if (v6 <= v7 && v6 != (unsigned __int16)(v7 + 1))
      {
        do
        {
          if (*(_DWORD *)(v5 + 16) > (unsigned __int16)v6) {
            *(unsigned char *)(*(void *)(v5 + 24) + ((unsigned __int16)v6 >> 3)) |= 1 << (v6 & 7);
          }
          BOOL v8 = v7 == (unsigned __int16)v6;
          LOWORD(v6)  = v6 + 1;
        }
        while (!v8);
      }
    }
    else if (*(_WORD *)(v5 + 32))
    {
      __n128 result = (*(uint64_t (**)(_DWORD *))(*(void *)v4 + 16))(v4);
      BOOL v9 = !result || v6 > v7;
      if (!v9 && v6 != (unsigned __int16)(v7 + 1))
      {
        do
        {
          if (*(_DWORD *)(v5 + 16) > (unsigned __int16)v6) {
            *(unsigned char *)(*(void *)(v5 + 24) + ((unsigned __int16)v6 >> 3)) |= 1 << (v6 & 7);
          }
          BOOL v8 = v7 == (unsigned __int16)v6;
          LOWORD(v6)  = v6 + 1;
        }
        while (!v8);
      }
    }
  }
  return result;
}

void std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::__clear[abi:nn180100]((uint64_t *)v2);
    uint64_t v3 = (void **)**a1;
    __int16 v4 = *a1 + 93;
    if (*a1 + 3 <= v3 && v4 > v3)
    {
      if ((*a1)[2] == (*a1)[93]) {
        *__int16 v4 = v3;
      }
    }
    else
    {
      operator delete(v3);
    }
  }
}

void std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::__clear[abi:nn180100](uint64_t *a1)
{
  uint64_t v3 = *a1;
  uint64_t v2 = a1[1];
  if (v2 != *a1)
  {
    uint64_t v4 = a1[1];
    do
    {
      unsigned int v6 = *(void **)(v4 - 24);
      v4 -= 24;
      uint64_t v5 = v6;
      if (v6)
      {
        *(void *)(v2 - 16)  = v5;
        operator delete(v5);
      }
      uint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  a1[1]  = v3;
}

void std::vector<STXEntryOne,TInlineBufferAllocator<STXEntryOne,30ul>>::__destroy_vector::operator()[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  if (v2)
  {
    *(void *)(a1 + 8)  = v2;
    uint64_t v3 = (void *)(a1 + 204);
    if (a1 + 24 <= (unint64_t)v2)
    {
      BOOL v4 = v3 >= v2;
      BOOL v5 = v3 == v2;
    }
    else
    {
      BOOL v4 = 0;
      BOOL v5 = 0;
    }
    if (!v5 && v4)
    {
      if (*(void *)(a1 + 16) == *(void *)(a1 + 208)) {
        *(void *)(a1 + 208)  = v2;
      }
    }
    else
    {
      operator delete(v2);
    }
  }
}

uint64_t std::vector<anonymous namespace'::LigInput,TInlineBufferAllocator<anonymous namespace'::LigInput,30ul>>::__construct_at_end<std::__wrap_iter<anonymous namespace'::LigInput const*>,std::__wrap_iter<anonymous namespace'::LigInput const*>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = *(void *)(a1 + 8);
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      uint64_t v7 = std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::vector<std::__wrap_iter<unsigned short const*>,0>(result, *(unsigned char **)v6, *(unsigned char **)(v6 + 8));
      *(_WORD *)(v7 + 40)  = *(_WORD *)(v6 + 40);
      uint64_t result = v7 + 48;
      v6 += 48;
    }
    while (v6 != a3);
  }
  *(void *)(a1 + 8)  = result;
  return result;
}

void *std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,4ul>>::__init_with_size[abi:nn180100]<std::__wrap_iter<std::vector<unsigned short> const*>,std::__wrap_iter<std::vector<unsigned short> const*>>(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >= 0xAAAAAAAAAAAAAABLL) {
      abort();
    }
    uint64_t v7 = result;
    uint64_t result = TInlineBufferAllocator<std::vector<unsigned short>,4ul>::allocate((uint64_t)(result + 3), a4);
    void *v7 = result;
    v7[1]  = result;
    void v7[2] = &result[3 * a4];
    while (a2 != a3)
    {
      BOOL v8 = std::vector<unsigned short>::vector(result, a2);
      a2 += 24;
      uint64_t result = v8 + 3;
    }
    v7[1]  = result;
  }
  return result;
}

void *TInlineBufferAllocator<std::vector<unsigned short>,4ul>::allocate(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 96);
  uint64_t v2 = (unint64_t *)(a1 + 96);
  uint64_t v3 = v4;
  unint64_t v5 = v4 + 24 * a2;
  if (v5 <= (unint64_t)v2)
  {
    *uint64_t v2 = v5;
    return (void *)v3;
  }
  else
  {
    if (a2 >= 0xAAAAAAAAAAAAAABLL) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    return operator new(24 * a2);
  }
}

void std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,4ul>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::__clear[abi:nn180100]((uint64_t *)v2);
    uint64_t v3 = (void **)**a1;
    uint64_t v4 = *a1 + 15;
    if (*a1 + 3 <= v3 && v4 > v3)
    {
      if ((*a1)[2] == (*a1)[15]) {
        *uint64_t v4 = v3;
      }
    }
    else
    {
      operator delete(v3);
    }
  }
}

void *std::__split_buffer<anonymous namespace'::SubstFormat3,TInlineBufferAllocator<anonymous namespace'::SubstFormat3,30ul> &>::__split_buffer(void *a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  a1[3]  = 0;
  a1[4]  = a4;
  if (a2)
  {
    uint64_t v7 = *(char **)(a4 + 12480);
    unint64_t v8 = (unint64_t)&v7[416 * a2];
    if (v8 <= a4 + 12480)
    {
      *(void *)(a4 + 12480)  = v8;
    }
    else
    {
      if (a2 >= 0x9D89D89D89D89ELL) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v7 = (char *)operator new(416 * a2);
    }
  }
  else
  {
    uint64_t v7 = 0;
  }
  BOOL v9 = &v7[416 * a3];
  *a1  = v7;
  a1[1]  = v9;
  a1[2]  = v9;
  a1[3]  = &v7[416 * a2];
  return a1;
}

void std::vector<anonymous namespace'::SubstFormat3,TInlineBufferAllocator<anonymous namespace'::SubstFormat3,30ul>>::__swap_out_circular_buffer(__n128 **a1, void *a2)
{
  unint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  uint64_t v6 = (__n128 *)a2[1];
  while (v4 != v5)
  {
    v6 -= 26;
    v4 -= 26;
  }
  a2[1]  = v6;
  uint64_t v7 = *a1;
  *a1  = v6;
  a2[1]  = v7;
  unint64_t v8 = a1[1];
  a1[1]  = (__n128 *)a2[2];
  a2[2]  = v8;
  BOOL v9 = a1[2];
  a1[2]  = (__n128 *)a2[3];
  a2[3]  = v9;
  *a2  = a2[1];
}

uint64_t std::__split_buffer<anonymous namespace'::SubstFormat3,TInlineBufferAllocator<anonymous namespace'::SubstFormat3,30ul> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16)  = i - 416;
  }
  uint64_t v4 = *(void **)a1;
  if (*(void *)a1)
  {
    unint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = (void *)(v5 + 12480);
    if (v5 <= (unint64_t)v4 && v6 > v4)
    {
      if (*(void *)(a1 + 24) == *v6) {
        *uint64_t v6 = v4;
      }
    }
    else
    {
      operator delete(v4);
    }
  }
  return a1;
}

__n128 std::allocator_traits<TInlineBufferAllocator<anonymous namespace'::SubstFormat3,30ul>>::construct[abi:nn180100]<anonymous namespace'::SubstFormat3,anonymous namespace'::SubstFormat3,void,void>(__n128 *a1, __n128 *a2)
{
  uint64_t v3 = a1;
  *a1  = *a2;
  uint64_t v4 = a2[1].n128_i64[0];
  uint64_t v5 = a2[1].n128_i64[1];
  a1[1].n128_u64[0]  = 0;
  a1[1].n128_u64[1]  = 0;
  a1[2].n128_u64[0]  = 0;
  a1[8].n128_u64[1]  = (unint64_t)&a1[2].n128_u64[1];
  std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,4ul>>::__init_with_size[abi:nn180100]<std::__wrap_iter<std::vector<unsigned short> const*>,std::__wrap_iter<std::vector<unsigned short> const*>>((__n128 *)a1[1].n128_u64, v4, v5, 0xAAAAAAAAAAAAAAABLL * ((v5 - v4) >> 3));
  uint64_t v6 = a2[9].n128_i64[0];
  uint64_t v7 = a2[9].n128_i64[1];
  v3[9].n128_u64[0]  = 0;
  v3 += 9;
  v3->n128_u64[1]  = 0;
  v3[1].n128_u64[0]  = 0;
  v3[7].n128_u64[1]  = (unint64_t)&v3[1].n128_u64[1];
  std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,4ul>>::__init_with_size[abi:nn180100]<std::__wrap_iter<std::vector<unsigned short> const*>,std::__wrap_iter<std::vector<unsigned short> const*>>(v3, v6, v7, 0xAAAAAAAAAAAAAAABLL * ((v7 - v6) >> 3));
  uint64_t v8 = a2[17].n128_i64[0];
  uint64_t v9 = a2[17].n128_i64[1];
  v3[8].n128_u64[0]  = 0;
  v3[8].n128_u64[1]  = 0;
  v3[9].n128_u64[0]  = 0;
  v3[15].n128_u64[1]  = (unint64_t)&v3[9].n128_u64[1];
  std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,4ul>>::__init_with_size[abi:nn180100]<std::__wrap_iter<std::vector<unsigned short> const*>,std::__wrap_iter<std::vector<unsigned short> const*>>((__n128 *)v3[8].n128_u64, v8, v9, 0xAAAAAAAAAAAAAAABLL * ((v9 - v8) >> 3));
  __n128 result = a2[25];
  v3[16]  = result;
  return result;
}

void std::allocator_traits<TInlineBufferAllocator<anonymous namespace'::SubstFormat3,30ul>>::destroy[abi:nn180100]<anonymous namespace'::SubstFormat3,void,void>(void **a1)
{
  uint64_t v2 = a1 + 34;
  std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,4ul>>::__destroy_vector::operator()[abi:nn180100](&v2);
  uint64_t v2 = a1 + 18;
  std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,4ul>>::__destroy_vector::operator()[abi:nn180100](&v2);
  uint64_t v2 = a1 + 2;
  std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,4ul>>::__destroy_vector::operator()[abi:nn180100](&v2);
}

void std::__function::__func<anonymous namespace'::ParseSubstFormat3(OTL::ChainContextSubstFormat3 const*,void const*,std::vector<unsigned short> const&,anonymous namespace'::SubstFormat3 *)::{lambda(unsigned short,unsigned short,unsigned short)#1},std::allocator<anonymous namespace'::ParseSubstFormat3(OTL::ChainContextSubstFormat3 const*,void const*,std::vector<unsigned short> const&,anonymous namespace'::SubstFormat3 *)::{lambda(unsigned short,unsigned short,unsigned short)#1}>,BOOL ()(unsigned short,unsigned short,unsigned short)>::~__func()
{
}

__n128 std::__function::__func<anonymous namespace'::ParseSubstFormat3(OTL::ChainContextSubstFormat3 const*,void const*,std::vector<unsigned short> const&,anonymous namespace'::SubstFormat3 *)::{lambda(unsigned short,unsigned short,unsigned short)#1},std::allocator<anonymous namespace'::ParseSubstFormat3(OTL::ChainContextSubstFormat3 const*,void const*,std::vector<unsigned short> const&,anonymous namespace'::SubstFormat3 *)::{lambda(unsigned short,unsigned short,unsigned short)#1}>,BOOL ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1ED060AA0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8)  = result;
  return result;
}

__n128 std::__function::__func<anonymous namespace'::ParseSubstFormat3(OTL::ChainContextSubstFormat3 const*,void const*,std::vector<unsigned short> const&,anonymous namespace'::SubstFormat3 *)::{lambda(unsigned short,unsigned short,unsigned short)#1},std::allocator<anonymous namespace'::ParseSubstFormat3(OTL::ChainContextSubstFormat3 const*,void const*,std::vector<unsigned short> const&,anonymous namespace'::SubstFormat3 *)::{lambda(unsigned short,unsigned short,unsigned short)#1}>,BOOL ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2  = &unk_1ED060AA0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8)  = result;
  return result;
}

uint64_t std::__function::__func<anonymous namespace'::ParseSubstFormat3(OTL::ChainContextSubstFormat3 const*,void const*,std::vector<unsigned short> const&,anonymous namespace'::SubstFormat3 *)::{lambda(unsigned short,unsigned short,unsigned short)#1},std::allocator<anonymous namespace'::ParseSubstFormat3(OTL::ChainContextSubstFormat3 const*,void const*,std::vector<unsigned short> const&,anonymous namespace'::SubstFormat3 *)::{lambda(unsigned short,unsigned short,unsigned short)#1}>,BOOL ()(unsigned short,unsigned short,unsigned short)>::operator()(uint64_t a1, unsigned __int16 *a2, unsigned __int16 *a3)
{
  unsigned int v3 = *a2;
  unsigned int v4 = *a3;
  if (v3 <= v4 && v3 != (unsigned __int16)(v4 + 1))
  {
    do
    {
      uint64_t v6 = *(unsigned __int16 ***)(a1 + 8);
      uint64_t v7 = *v6;
      uint64_t v8 = v6[1];
      if (v8 == v7) {
        goto LABEL_11;
      }
      unint64_t v9 = v8 - v7;
      do
      {
        unint64_t v10 = v9 >> 1;
        unint64_t v11 = &v7[v9 >> 1];
        unsigned int v13 = *v11;
        uint64_t v12 = v11 + 1;
        v9 += ~(v9 >> 1);
        if (v13 < (unsigned __int16)v3) {
          uint64_t v7 = v12;
        }
        else {
          unint64_t v9 = v10;
        }
      }
      while (v9);
      if (v7 == v8 || *v7 > (unsigned __int16)v3)
      {
LABEL_11:
        uint64_t v14 = *(void *)(a1 + 16);
        unint64_t v15 = *(_WORD **)(v14 + 8);
        unint64_t v16 = *(void *)(v14 + 16);
        if ((unint64_t)v15 >= v16)
        {
          unint64_t v18 = *(_WORD **)v14;
          uint64_t v19 = (uint64_t)v15 - *(void *)v14;
          if (v19 <= -3) {
            abort();
          }
          uint64_t v20 = v19 >> 1;
          unint64_t v21 = v16 - (void)v18;
          if (v21 <= (v19 >> 1) + 1) {
            unint64_t v22 = v20 + 1;
          }
          else {
            unint64_t v22 = v21;
          }
          if (v21 >= 0x7FFFFFFFFFFFFFFELL) {
            uint64_t v23 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v23 = v22;
          }
          if (v23)
          {
            __int16 v24 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned short>>(v14 + 16, v23);
            unint64_t v18 = *(_WORD **)v14;
            unint64_t v15 = *(_WORD **)(v14 + 8);
          }
          else
          {
            __int16 v24 = 0;
          }
          unint64_t v25 = &v24[2 * v20];
          *(_WORD *)unint64_t v25 = v3;
          unint64_t v17 = v25 + 2;
          while (v15 != v18)
          {
            __int16 v26 = *--v15;
            *((_WORD *)v25 - 1)  = v26;
            v25 -= 2;
          }
          *(void *)uint64_t v14 = v25;
          *(void *)(v14 + 8)  = v17;
          *(void *)(v14 + 16)  = &v24[2 * v23];
          if (v18) {
            operator delete(v18);
          }
        }
        else
        {
          *unint64_t v15 = v3;
          unint64_t v17 = v15 + 1;
        }
        *(void *)(v14 + 8)  = v17;
      }
      BOOL v27 = v4 == (unsigned __int16)v3;
      LOWORD(v3)  = v3 + 1;
    }
    while (!v27);
  }
  return 1;
}

char **std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::__init_with_size[abi:nn180100]<std::reverse_iterator<std::__wrap_iter<std::vector<unsigned short> const*>>,std::reverse_iterator<std::__wrap_iter<std::vector<unsigned short> const*>>>(char **result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6)
{
  if (a6)
  {
    uint64_t v8 = result;
    std::vector<JustLeftRightMaxima,TInlineBufferAllocator<JustLeftRightMaxima,30ul>>::__vallocate[abi:nn180100](result, a6);
    __n128 result = (char **)v8[1];
    while (a3 != a5)
    {
      a3 -= 24;
      __n128 result = (char **)(std::vector<unsigned short>::vector(result, a3) + 3);
    }
    v8[1]  = (char *)result;
  }
  return result;
}

void std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::__assign_with_size[abi:nn180100]<std::reverse_iterator<std::__wrap_iter<std::vector<unsigned short> const*>>,std::reverse_iterator<std::__wrap_iter<std::vector<unsigned short> const*>>>(uint64_t *a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, unint64_t a6)
{
  uint64_t v8 = a3;
  unint64_t v10 = (char *)*a1;
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 3) >= a6)
  {
    if (0xAAAAAAAAAAAAAAABLL * ((a1[1] - (uint64_t)v10) >> 3) >= a6)
    {
      std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::reverse_iterator<std::__wrap_iter<std::vector<unsigned short> const*>>,std::reverse_iterator<std::__wrap_iter<std::vector<unsigned short> const*>>,std::vector<unsigned short>*,0>(v22, a2, a3, a4, a5, v10);
      uint64_t v17 = v23;
      uint64_t v18 = a1[1];
      if (v18 != v23)
      {
        uint64_t v19 = a1[1];
        do
        {
          unint64_t v21 = *(void **)(v19 - 24);
          v19 -= 24;
          uint64_t v20 = v21;
          if (v21)
          {
            *(void *)(v18 - 16)  = v20;
            operator delete(v20);
          }
          uint64_t v18 = v19;
        }
        while (v19 != v17);
      }
      a1[1]  = v17;
    }
    else
    {
      uint64_t v14 = a3 - 8 * ((a1[1] - (uint64_t)v10) >> 3);
      std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::reverse_iterator<std::__wrap_iter<std::vector<unsigned short> const*>>,std::reverse_iterator<std::__wrap_iter<std::vector<unsigned short> const*>>,std::vector<unsigned short>*,0>(v22, a2, a3, a2, v14, v10);
      uint64_t v15 = a1[1];
      if (v14 != a5)
      {
        unint64_t v16 = (void *)a1[1];
        do
        {
          v14 -= 24;
          unint64_t v16 = std::vector<unsigned short>::vector(v16, v14) + 3;
          v15 += 24;
        }
        while (v14 != a5);
      }
      a1[1]  = v15;
    }
  }
  else
  {
    std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::__vdeallocate(a1);
    if (a6 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    unint64_t v11 = 0x5555555555555556 * ((a1[2] - *a1) >> 3);
    if (v11 <= a6) {
      unint64_t v11 = a6;
    }
    if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 3) >= 0x555555555555555) {
      unint64_t v12 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v12 = v11;
    }
    std::vector<JustLeftRightMaxima,TInlineBufferAllocator<JustLeftRightMaxima,30ul>>::__vallocate[abi:nn180100]((char **)a1, v12);
    unsigned int v13 = (void *)a1[1];
    while (v8 != a5)
    {
      v8 -= 24;
      unsigned int v13 = std::vector<unsigned short>::vector(v13, v8) + 3;
    }
    a1[1]  = (uint64_t)v13;
  }
}

void std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::__vdeallocate(uint64_t *a1)
{
  if (*a1)
  {
    std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::__clear[abi:nn180100](a1);
    uint64_t v2 = (void *)*a1;
    unsigned int v3 = a1 + 93;
    if ((unint64_t)(a1 + 3) <= *a1 && v3 > v2)
    {
      if (a1[2] == a1[93]) {
        *unsigned int v3 = v2;
      }
    }
    else
    {
      operator delete(v2);
    }
    *a1  = 0;
    a1[1]  = 0;
    a1[2]  = 0;
  }
}

char *std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::reverse_iterator<std::__wrap_iter<std::vector<unsigned short> const*>>,std::reverse_iterator<std::__wrap_iter<std::vector<unsigned short> const*>>,std::vector<unsigned short>*,0>(char *result, uint64_t a2, uint64_t a3, int a4, uint64_t a5, char *a6)
{
  uint64_t v8 = result;
  if (a3 == a5)
  {
    uint64_t v9 = a3;
  }
  else
  {
    uint64_t v9 = a5;
    uint64_t v10 = a3 - 24;
    do
    {
      if ((char *)v10 != a6) {
        __n128 result = std::vector<unsigned short>::__assign_with_size[abi:nn180100]<unsigned short *,unsigned short *>(a6, *(char **)v10, *(void *)(v10 + 8), (uint64_t)(*(void *)(v10 + 8) - *(void *)v10) >> 1);
      }
      a6 += 24;
      BOOL v11 = v10 == v9;
      v10 -= 24;
    }
    while (!v11);
  }
  *(void *)uint64_t v8 = a2;
  *((void *)v8 + 1)  = v9;
  *((void *)v8 + 2)  = a6;
  return result;
}

char *std::vector<unsigned short>::__assign_with_size[abi:nn180100]<unsigned short *,unsigned short *>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = result;
  unint64_t v8 = *((void *)result + 2);
  uint64_t v9 = *(char **)result;
  if (a4 > (uint64_t)(v8 - *(void *)result) >> 1)
  {
    if (v9)
    {
      *((void *)result + 1)  = v9;
      operator delete(v9);
      unint64_t v8 = 0;
      void *v7 = 0;
      v7[1]  = 0;
      void v7[2] = 0;
    }
    if ((a4 & 0x8000000000000000) != 0) {
      abort();
    }
    if (v8 <= a4) {
      unint64_t v10 = a4;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v8 >= 0x7FFFFFFFFFFFFFFELL) {
      uint64_t v11 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v11 = v10;
    }
    __n128 result = std::vector<unsigned short>::__vallocate[abi:nn180100](v7, v11);
    unsigned int v13 = (char *)v7[1];
    unint64_t v12 = (void **)(v7 + 1);
    uint64_t v9 = v13;
LABEL_17:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      uint64_t v18 = v9;
      uint64_t v19 = __src;
      goto LABEL_19;
    }
    goto LABEL_20;
  }
  unint64_t v12 = (void **)(result + 8);
  uint64_t v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 1;
  if (v15 >= a4) {
    goto LABEL_17;
  }
  unint64_t v16 = &__src[2 * v15];
  if (v14 != v9)
  {
    __n128 result = (char *)memmove(*(void **)result, __src, v14 - v9);
    uint64_t v9 = (char *)*v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    uint64_t v18 = v9;
    uint64_t v19 = v16;
LABEL_19:
    __n128 result = (char *)memmove(v18, v19, v17);
  }
LABEL_20:
  unsigned __int16 *v12 = &v9[v17];
  return result;
}

char *std::vector<unsigned short>::__vallocate[abi:nn180100](void *a1, uint64_t a2)
{
  if (a2 < 0) {
    abort();
  }
  __n128 result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned short>>((uint64_t)(a1 + 2), a2);
  *a1  = result;
  a1[1]  = result;
  a1[2]  = &result[2 * v4];
  return result;
}

void std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::__assign_with_size[abi:nn180100]<std::__wrap_iter<std::vector<unsigned short> const*>,std::__wrap_iter<std::vector<unsigned short> const*>>(uint64_t *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v6 = a2;
  unint64_t v8 = (char *)*a1;
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 3) >= a4)
  {
    if (0xAAAAAAAAAAAAAAABLL * ((a1[1] - (uint64_t)v8) >> 3) >= a4)
    {
      size_t v17 = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::vector<unsigned short> const*,std::vector<unsigned short> const*,std::vector<unsigned short>*>(a2, a3, v8);
      uint64_t v18 = (char *)a1[1];
      if (v18 != v17)
      {
        uint64_t v19 = (char *)a1[1];
        do
        {
          unint64_t v21 = (void *)*((void *)v19 - 3);
          v19 -= 24;
          uint64_t v20 = v21;
          if (v21)
          {
            *((void *)v18 - 2)  = v20;
            operator delete(v20);
          }
          uint64_t v18 = v19;
        }
        while (v19 != v17);
      }
      a1[1]  = (uint64_t)v17;
    }
    else
    {
      uint64_t v13 = a2 + 8 * ((a1[1] - (uint64_t)v8) >> 3);
      std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::vector<unsigned short> const*,std::vector<unsigned short> const*,std::vector<unsigned short>*>(a2, v13, v8);
      uint64_t v14 = a1[1];
      if (v13 != a3)
      {
        unint64_t v15 = (void *)a1[1];
        do
        {
          unint64_t v16 = std::vector<unsigned short>::vector(v15, v13);
          v13 += 24;
          unint64_t v15 = v16 + 3;
          v14 += 24;
        }
        while (v13 != a3);
      }
      a1[1]  = v14;
    }
  }
  else
  {
    std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::__vdeallocate(a1);
    if (a4 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    unint64_t v9 = 0x5555555555555556 * ((a1[2] - *a1) >> 3);
    if (v9 <= a4) {
      unint64_t v9 = a4;
    }
    if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 3) >= 0x555555555555555) {
      unint64_t v10 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v10 = v9;
    }
    std::vector<JustLeftRightMaxima,TInlineBufferAllocator<JustLeftRightMaxima,30ul>>::__vallocate[abi:nn180100]((char **)a1, v10);
    uint64_t v11 = (void *)a1[1];
    while (v6 != a3)
    {
      unint64_t v12 = std::vector<unsigned short>::vector(v11, v6);
      v6 += 24;
      uint64_t v11 = v12 + 3;
    }
    a1[1]  = (uint64_t)v11;
  }
}

char *std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::vector<unsigned short> const*,std::vector<unsigned short> const*,std::vector<unsigned short>*>(uint64_t a1, uint64_t a2, char *a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      if ((char *)v5 != a3) {
        std::vector<unsigned short>::__assign_with_size[abi:nn180100]<unsigned short *,unsigned short *>(a3, *(char **)v5, *(void *)(v5 + 8), (uint64_t)(*(void *)(v5 + 8) - *(void *)v5) >> 1);
      }
      v5 += 24;
      a3 += 24;
    }
    while (v5 != a2);
  }
  return a3;
}

void *std::vector<unsigned short>::vector(void *a1, uint64_t a2)
{
  *a1  = 0;
  a1[1]  = 0;
  a1[2]  = 0;
  uint64_t v4 = *(const void **)a2;
  uint64_t v3 = *(void *)(a2 + 8);
  int64_t v5 = v3 - *(void *)a2;
  if (v3 != *(void *)a2)
  {
    std::vector<unsigned short>::__vallocate[abi:nn180100](a1, v5 >> 1);
    uint64_t v6 = (char *)a1[1];
    memmove(v6, v4, v5);
    a1[1]  = &v6[v5];
  }
  return a1;
}

__CFData *CreateSingleSubstitutionLKTHandle(int64_t a1, int a2, unsigned __int16 *a3, unint64_t a4, uint64_t a5, uint64_t a6, __int16 a7)
{
  v46[4]  = *MEMORY[0x1E4F143B8];
  uint64_t v36 = a5;
  unint64_t v37 = a4;
  __int16 v35 = a7;
  unint64_t v12 = NewLKTHandle(a1, 0);
  unsigned int v34 = v12;
  if (a2 != 3)
  {
    if (a2 == 1)
    {
      std::__function::__value_func<BOOL ()(unsigned short)>::__value_func[abi:nn180100]((uint64_t)v45, a6);
      uint64_t v42 = a5;
      uint64_t v43 = v12;
      unsigned int v13 = bswap32(*a3) >> 16;
      if (v13 == 2)
      {
        long long v41 = a3;
        uint64_t v23 = a3 + 3;
        if ((unint64_t)(a3 + 3) > a4) {
          goto LABEL_39;
        }
        uint64_t v24 = bswap32(a3[2]) >> 16;
        unint64_t v25 = (unint64_t)&v23[v24];
        BOOL v27 = v25 >= (unint64_t)v23 && v25 <= a4;
        unint64_t v28 = a4 - (void)v23;
        unint64_t v29 = v28 >> 1;
        if ((unint64_t)(a3 + 4) > a4) {
          unint64_t v29 = 0;
        }
        if (!v27 && v29 != v24) {
          goto LABEL_39;
        }
        unsigned int v30 = v28 >> 1;
        if ((unint64_t)(a3 + 4) <= a4) {
          __int16 v31 = v30;
        }
        else {
          __int16 v31 = 0;
        }
        if (!v27) {
          LOWORD(v24)  = v31;
        }
        int v38 = (unsigned __int16)v24;
        unint64_t v40 = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&long long v32 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v32 + 1)  = 0xAAAAAAAAAAAAAAAALL;
        v39[0]  = v32;
        v39[1]  = v32;
        OTL::LookupWithCoverage::GetCoverage((OTL::Coverage *)a3, a4, (uint64_t)v39);
        uint64_t v14 = operator new(0x30uLL);
        *uint64_t v14 = &unk_1ED060548;
        v14[1]  = v45;
        v14[2]  = &v38;
        v14[3]  = &v43;
        v14[4]  = &v41;
        v14[5]  = &v42;
      }
      else
      {
        if (v13 != 1) {
          goto LABEL_39;
        }
        long long v41 = a3;
        if ((unint64_t)(a3 + 3) > a4) {
          goto LABEL_39;
        }
        OTL::LookupWithCoverage::GetCoverage((OTL::Coverage *)a3, a4, (uint64_t)v39);
        uint64_t v14 = operator new(0x28uLL);
        *uint64_t v14 = &unk_1ED060500;
        v14[1]  = v45;
        v14[2]  = &v43;
        v14[3]  = &v41;
        v14[4]  = &v42;
      }
      v46[3]  = v14;
      OTL::Coverage::Iterate(v39, (uint64_t)v46);
      std::__function::__value_func<BOOL ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100](v46);
LABEL_39:
      std::__function::__value_func<BOOL ()(unsigned short)>::~__value_func[abi:nn180100](v45);
      return v12;
    }
    goto LABEL_20;
  }
  v46[0]  = a3;
  unint64_t v15 = a3 + 3;
  if ((unint64_t)(a3 + 3) > a4) {
    goto LABEL_20;
  }
  uint64_t v16 = bswap32(a3[2]) >> 16;
  unint64_t v17 = (unint64_t)&v15[v16];
  unint64_t v18 = (unint64_t)(a3 + 4) <= a4 ? (a4 - (unint64_t)v15) >> 1 : 0;
  BOOL v19 = v17 <= a4 && v17 >= (unint64_t)v15;
  if (!v19 && v18 != v16) {
    goto LABEL_20;
  }
  OTL::LookupWithCoverage::GetCoverage((OTL::Coverage *)a3, a4, (uint64_t)v39);
  unint64_t v21 = operator new(0x38uLL);
  void *v21 = &unk_1ED060740;
  v21[1]  = a6;
  v21[2]  = v46;
  v21[3]  = &v37;
  v21[4]  = &v35;
  v21[5]  = &v34;
  v21[6]  = &v36;
  v44[3]  = v21;
  char v22 = OTL::Coverage::Iterate(v39, (uint64_t)v44);
  std::__function::__value_func<BOOL ()(unsigned short,unsigned short,unsigned short)>::~__value_func[abi:nn180100](v44);
  unint64_t v12 = v34;
  if ((v22 & 1) == 0)
  {
LABEL_20:
    DisposeLKTHandle(v12);
    return 0;
  }
  return v12;
}

void std::__function::__func<AddSingleSubstitutions(LKTHandle,OTL::LookupSubtable const*,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>)::$_0,std::allocator<AddSingleSubstitutions(LKTHandle,OTL::LookupSubtable const*,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>)::$_0>,BOOL ()(unsigned short,unsigned short,unsigned short)>::~__func()
{
}

__n128 std::__function::__func<AddSingleSubstitutions(LKTHandle,OTL::LookupSubtable const*,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>)::$_0,std::allocator<AddSingleSubstitutions(LKTHandle,OTL::LookupSubtable const*,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>)::$_0>,BOOL ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_1ED060500;
  *(_OWORD *)(v2 + 8)  = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24)  = result;
  return result;
}

__n128 std::__function::__func<AddSingleSubstitutions(LKTHandle,OTL::LookupSubtable const*,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>)::$_0,std::allocator<AddSingleSubstitutions(LKTHandle,OTL::LookupSubtable const*,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>)::$_0>,BOOL ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2  = &unk_1ED060500;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24)  = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8)  = result;
  return result;
}

uint64_t std::__function::__func<AddSingleSubstitutions(LKTHandle,OTL::LookupSubtable const*,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>)::$_0,std::allocator<AddSingleSubstitutions(LKTHandle,OTL::LookupSubtable const*,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>)::$_0>,BOOL ()(unsigned short,unsigned short,unsigned short)>::operator()(uint64_t a1, unsigned __int16 *a2, unsigned __int16 *a3)
{
  unsigned int v3 = *a2;
  unsigned int v4 = *a3;
  if (v3 <= v4 && v3 != (unsigned __int16)(v4 + 1))
  {
    do
    {
      if (std::function<BOOL ()(unsigned short)>::operator()(*(void *)(*(void *)(a1 + 8) + 24), v3)
        && LKTAddRange(**(__CFData ***)(a1 + 16), (unsigned __int16)v3, (unsigned __int16)v3, v3 + (bswap32(*(unsigned __int16 *)(**(void **)(a1 + 24) + 4)) >> 16)))
      {
        *(unsigned char *)(**(void **)(a1 + 32) + ((unsigned __int16)v3 >> 3)) |= 1 << (v3 & 7);
      }
      BOOL v6 = v4 == (unsigned __int16)v3;
      LOWORD(v3)  = v3 + 1;
    }
    while (!v6);
  }
  return 1;
}

uint64_t std::function<BOOL ()(unsigned short)>::operator()(uint64_t a1, __int16 a2)
{
  __int16 v3 = a2;
  if (!a1)
  {
    std::__throw_bad_function_call[abi:nn180100]();
    JUMPOUT(0x184B56EBCLL);
  }
  return (*(uint64_t (**)(uint64_t, __int16 *))(*(void *)a1 + 48))(a1, &v3);
}

void std::__function::__func<AddSingleSubstitutions(LKTHandle,OTL::LookupSubtable const*,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>)::$_1,std::allocator<AddSingleSubstitutions(LKTHandle,OTL::LookupSubtable const*,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>)::$_1>,BOOL ()(unsigned short,unsigned short,unsigned short)>::~__func()
{
}

__n128 std::__function::__func<AddSingleSubstitutions(LKTHandle,OTL::LookupSubtable const*,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>)::$_1,std::allocator<AddSingleSubstitutions(LKTHandle,OTL::LookupSubtable const*,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>)::$_1>,BOOL ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v2 = &unk_1ED060548;
  *(_OWORD *)(v2 + 8)  = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24)  = result;
  *((void *)v2 + 5)  = *(void *)(a1 + 40);
  return result;
}

__n128 std::__function::__func<AddSingleSubstitutions(LKTHandle,OTL::LookupSubtable const*,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>)::$_1,std::allocator<AddSingleSubstitutions(LKTHandle,OTL::LookupSubtable const*,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>)::$_1>,BOOL ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2  = &unk_1ED060548;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 40)  = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24)  = v3;
  *(__n128 *)(a2 + 8)  = result;
  return result;
}

uint64_t std::__function::__func<AddSingleSubstitutions(LKTHandle,OTL::LookupSubtable const*,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>)::$_1,std::allocator<AddSingleSubstitutions(LKTHandle,OTL::LookupSubtable const*,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>)::$_1>,BOOL ()(unsigned short,unsigned short,unsigned short)>::operator()(uint64_t a1, unsigned __int16 *a2, unsigned __int16 *a3, __int16 *a4)
{
  unsigned int v4 = *a2;
  unsigned int v5 = *a3;
  if (v4 <= v5 && v4 != (unsigned __int16)(v5 + 1))
  {
    __int16 v7 = *a4;
    unsigned __int16 v8 = *a2;
    do
    {
      if (std::function<BOOL ()(unsigned short)>::operator()(*(void *)(*(void *)(a1 + 8) + 24), v8)
        && **(_DWORD **)(a1 + 16) > (unsigned __int16)(v8 - v4 + v7)
        && LKTAddRange(**(__CFData ***)(a1 + 24), v8, v8, bswap32(*(unsigned __int16 *)(**(void **)(a1 + 32)+ 2 * (unsigned __int16)(v8 - v4 + v7)+ 6)) >> 16))
      {
        *(unsigned char *)(**(void **)(a1 + 40) + (v8 >> 3)) |= 1 << (v8 & 7);
      }
    }
    while (v5 != v8++);
  }
  return 1;
}

void std::__function::__func<CreateSingleSubstitutionLKTHandle(long,std::pair<unsigned int,OTL::LookupSubtable const*>,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>,unsigned short)::$_0,std::allocator<CreateSingleSubstitutionLKTHandle(long,std::pair<unsigned int,OTL::LookupSubtable const*>,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>,unsigned short)::$_0>,BOOL ()(unsigned short,unsigned short,unsigned short)>::~__func()
{
}

__n128 std::__function::__func<CreateSingleSubstitutionLKTHandle(long,std::pair<unsigned int,OTL::LookupSubtable const*>,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>,unsigned short)::$_0,std::allocator<CreateSingleSubstitutionLKTHandle(long,std::pair<unsigned int,OTL::LookupSubtable const*>,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>,unsigned short)::$_0>,BOOL ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x38uLL);
  *(void *)uint64_t v2 = &unk_1ED060740;
  *(_OWORD *)(v2 + 8)  = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24)  = *(_OWORD *)(a1 + 24);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40)  = result;
  return result;
}

__n128 std::__function::__func<CreateSingleSubstitutionLKTHandle(long,std::pair<unsigned int,OTL::LookupSubtable const*>,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>,unsigned short)::$_0,std::allocator<CreateSingleSubstitutionLKTHandle(long,std::pair<unsigned int,OTL::LookupSubtable const*>,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>,unsigned short)::$_0>,BOOL ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2  = &unk_1ED060740;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 40)  = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 24)  = v3;
  *(__n128 *)(a2 + 8)  = result;
  return result;
}

uint64_t std::__function::__func<CreateSingleSubstitutionLKTHandle(long,std::pair<unsigned int,OTL::LookupSubtable const*>,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>,unsigned short)::$_0,std::allocator<CreateSingleSubstitutionLKTHandle(long,std::pair<unsigned int,OTL::LookupSubtable const*>,void const*,unsigned char *,std::function<BOOL ()(unsigned short)>,unsigned short)::$_0>,BOOL ()(unsigned short,unsigned short,unsigned short)>::operator()(uint64_t a1, unsigned __int16 *a2, unsigned __int16 *a3, __int16 *a4)
{
  unsigned int v5 = *a2;
  unsigned int v6 = *a3;
  uint64_t result = 1;
  if (v5 <= v6 && v5 != (unsigned __int16)(v6 + 1))
  {
    __int16 v8 = *a4;
    unsigned __int16 v9 = *a2;
    while (1)
    {
      if (std::function<BOOL ()(unsigned short)>::operator()(*(void *)(*(void *)(a1 + 8) + 24), v9))
      {
        uint64_t v10 = **(void **)(a1 + 16);
        unint64_t v11 = **(void **)(a1 + 24);
        unint64_t v12 = v10 + 6;
        if (v10 + 6 > v11) {
          return 0;
        }
        unsigned __int16 v13 = v9 - v5 + v8;
        uint64_t v14 = bswap32(*(unsigned __int16 *)(v10 + 4)) >> 16;
        unint64_t v15 = v12 + 2 * v14;
        if (v15 < v12 || v15 > v11)
        {
          unint64_t v17 = (v11 - v12) >> 1;
          if (v10 + 8 > v11) {
            unint64_t v17 = 0;
          }
          BOOL v18 = v14 > v13 && v17 == v14;
          if (!v18) {
            return 0;
          }
        }
        else if (v14 <= v13)
        {
          return 0;
        }
        BOOL v19 = (unsigned __int16 *)(v10 + (bswap32(*(unsigned __int16 *)(v10 + 2 * v13 + 6)) >> 16));
        uint64_t v20 = v19 + 1;
        if ((unint64_t)(v19 + 1) > v11) {
          return 0;
        }
        uint64_t v21 = bswap32(*v19) >> 16;
        unint64_t v22 = (unint64_t)&v20[v21];
        unint64_t v23 = (unint64_t)(v19 + 2) <= v11 ? (v11 - (unint64_t)v20) >> 1 : 0;
        BOOL v24 = v22 <= v11 && v22 >= (unint64_t)v20;
        if (!v24 && v23 != v21) {
          return 0;
        }
        uint64_t v26 = **(unsigned __int16 **)(a1 + 32);
        if (v26 < v21)
        {
          if (LKTAddRange(**(__CFData ***)(a1 + 40), v9, v9, bswap32(v19[v26 + 1]) >> 16)) {
            *(unsigned char *)(**(void **)(a1 + 48) + (v9 >> 3)) |= 1 << (v9 & 7);
          }
        }
      }
      BOOL v18 = v6 == v9++;
      if (v18) {
        return 1;
      }
    }
  }
  return result;
}

uint64_t std::__function::__value_func<BOOL ()(unsigned short)>::__value_func[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24)  = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24)  = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24)  = 0;
  }
  return a1;
}

void *std::__function::__func<anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_7,std::allocator<anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_7>,BOOL ()(unsigned short)>::~__func(void *a1)
{
  *a1  = &unk_1ED060A58;
  uint64_t v2 = (void *)a1[10];
  if (v2)
  {
    a1[11]  = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[1];
  if (v3)
  {
    a1[2]  = v3;
    operator delete(v3);
  }
  return a1;
}

void std::__function::__func<anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_7,std::allocator<anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_7>,BOOL ()(unsigned short)>::~__func(void *a1)
{
  *a1  = &unk_1ED060A58;
  uint64_t v2 = (void *)a1[10];
  if (v2)
  {
    a1[11]  = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[1];
  if (v3)
  {
    a1[2]  = v3;
    operator delete(v3);
  }

  JUMPOUT(0x1853275C0);
}

void *std::__function::__func<anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_7,std::allocator<anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_7>,BOOL ()(unsigned short)>::__clone(_OWORD *a1)
{
  uint64_t v2 = (uint64_t)a1 + 8;
  uint64_t v3 = operator new(0x68uLL);
  *uint64_t v3 = &unk_1ED060A58;
  std::vector<unsigned short>::vector(v3 + 1, v2);
  long long v4 = a1[3];
  *((_OWORD *)v3 + 2)  = a1[2];
  *((_OWORD *)v3 + 3)  = v4;
  *((_OWORD *)v3 + 4)  = a1[4];
  std::vector<unsigned short>::vector(v3 + 10, (uint64_t)(a1 + 5));
  return v3;
}

void *std::__function::__func<anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_7,std::allocator<anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_7>,BOOL ()(unsigned short)>::__clone(_OWORD *a1, uint64_t a2)
{
  *(void *)a2  = &unk_1ED060A58;
  std::vector<unsigned short>::vector((void *)(a2 + 8), (uint64_t)a1 + 8);
  long long v4 = a1[2];
  long long v5 = a1[4];
  *(_OWORD *)(a2 + 48)  = a1[3];
  *(_OWORD *)(a2 + 64)  = v5;
  *(_OWORD *)(a2 + 32)  = v4;

  return std::vector<unsigned short>::vector((void *)(a2 + 80), (uint64_t)(a1 + 5));
}

void std::__function::__func<anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_7,std::allocator<anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_7>,BOOL ()(unsigned short)>::destroy(uint64_t a1)
{
}

void std::__function::__func<anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_7,std::allocator<anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_7>,BOOL ()(unsigned short)>::destroy_deallocate(void *a1)
{
  operator delete(a1);
}

BOOL std::__function::__func<anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_7,std::allocator<anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_7>,BOOL ()(unsigned short)>::operator()(void *a1, unsigned __int16 *a2)
{
  uint64_t v2 = (unsigned __int16 *)a1[1];
  uint64_t v3 = (unsigned __int16 *)a1[2];
  if (v3 == v2) {
    return 0;
  }
  unsigned int v4 = *a2;
  unint64_t v5 = v3 - v2;
  do
  {
    unint64_t v6 = v5 >> 1;
    __int16 v7 = &v2[v5 >> 1];
    unsigned int v9 = *v7;
    __int16 v8 = v7 + 1;
    v5 += ~(v5 >> 1);
    if (v9 < v4) {
      uint64_t v2 = v8;
    }
    else {
      unint64_t v5 = v6;
    }
  }
  while (v5);
  if (v2 == v3 || *v2 > v4) {
    return 0;
  }
  unint64_t v11 = (unsigned __int16 *)a1[10];
  unint64_t v12 = (unsigned __int16 *)a1[11];
  if (v12 == v11) {
    return 1;
  }
  unint64_t v13 = v12 - v11;
  do
  {
    unint64_t v14 = v13 >> 1;
    unint64_t v15 = &v11[v13 >> 1];
    unsigned int v17 = *v15;
    uint64_t v16 = v15 + 1;
    v13 += ~(v13 >> 1);
    if (v17 < v4) {
      unint64_t v11 = v16;
    }
    else {
      unint64_t v13 = v14;
    }
  }
  while (v13);
  return v11 == v12 || *v11 > v4;
}

void std::__function::__alloc_func<anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_7,std::allocator<anonymous namespace'::MorxTableBuilder::From(TBaseFont const&,OTL::GCommon::Header const*,void const*,anonymous namespace'::OTFeaturesMap &)::$_7>,BOOL ()(unsigned short)>::destroy[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80)  = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8)  = v3;
    operator delete(v3);
  }
}

void *std::__function::__value_func<BOOL ()(unsigned short)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

BOOL anonymous namespace'::MorxContextualSubtableBuilder::StateNeedsAction(_anonymous_namespace_::MorxContextualSubtableBuilder *this, int a2, int a3)
{
  uint64_t v4 = 0;
}

void AddGlyphClassesByAppearance(unsigned __int16 **a1, __CFData *a2, unsigned __int16 a3, unsigned __int16 *a4, unsigned __int16 *a5)
{
  unint64_t v5 = a1;
  *a1  = 0;
  a1[1]  = 0;
  a1[2]  = 0;
  if (a4 != a5)
  {
    __int16 v7 = a4;
    uint64_t v10 = a1 + 2;
    uint64_t v65 = (uint64_t)(a1 + 2);
    while (1)
    {
      char v11 = 0;
      int v12 = *((_DWORD *)v7 + 1);
      unint64_t v13 = v7;
      while (1)
      {
        unsigned int v14 = *v13;
        int v15 = LKTGetValue(a2, v14);
        if ((v15 & 0xFF0000) != 0)
        {
          char v11 = 1;
          a3  = v15;
        }
        else
        {
          LKTAddRange(a2, v14, v14, a3);
        }
        __int16 v7 = v13 + 4;
        if (v13 + 4 == a5) {
          break;
        }
        int v16 = *((_DWORD *)v13 + 3);
        v13 += 4;
        if (v16 != v12) {
          goto LABEL_11;
        }
      }
      __int16 v7 = a5;
LABEL_11:
      BOOL v18 = *v5;
      unsigned int v17 = v5[1];
      uint64_t v19 = (char *)v17 - (char *)*v5;
      if (v17 == *v5)
      {
        uint64_t v21 = v5[1];
      }
      else
      {
        unint64_t v20 = v19 >> 1;
        uint64_t v21 = *v5;
        do
        {
          unint64_t v22 = v20 >> 1;
          unint64_t v23 = &v21[v20 >> 1];
          unsigned int v25 = *v23;
          BOOL v24 = v23 + 1;
          v20 += ~(v20 >> 1);
          if (v25 < a3) {
            uint64_t v21 = v24;
          }
          else {
            unint64_t v20 = v22;
          }
        }
        while (v20);
      }
      uint64_t v26 = (char *)v21 - (char *)v18;
      BOOL v27 = (unsigned __int16 *)((char *)v18 + (((char *)v21 - (char *)v18) & 0xFFFFFFFFFFFFFFFELL));
      if ((unint64_t)v17 >= *v10) {
        break;
      }
      if (v27 == v17)
      {
        *unsigned int v17 = a3;
        unint64_t v5 = a1;
        a1[1]  = v17 + 1;
      }
      else
      {
        unint64_t v28 = v17 - 1;
        unint64_t v29 = v17;
        unint64_t v5 = a1;
        if ((unint64_t)v17 >= 2)
        {
          do
          {
            unsigned __int16 v30 = *v28++;
            *v29++  = v30;
          }
          while (v28 < v17);
        }
        a1[1]  = v29;
        if (v17 != v27 + 1)
        {
          __int16 v31 = v27;
          memmove(&v17[-(v17 - (v27 + 1))], v27, (char *)v17 - (char *)(v27 + 1));
          BOOL v27 = v31;
        }
        *BOOL v27 = a3;
      }
LABEL_51:
      a3 += (v11 & 1) == 0;
      if (v7 == a5)
      {
        uint64_t v57 = *v5;
        unint64_t v56 = v5[1];
        goto LABEL_60;
      }
    }
    if (v19 <= -3) {
      abort();
    }
    unint64_t v32 = *v10 - (void)v18;
    if (v32 <= (v19 >> 1) + 1) {
      uint64_t v33 = (v19 >> 1) + 1;
    }
    else {
      uint64_t v33 = *v10 - (void)v18;
    }
    if (v32 >= 0x7FFFFFFFFFFFFFFELL) {
      uint64_t v34 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v34 = v33;
    }
    if (v34)
    {
      __int16 v35 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned short>>((uint64_t)v10, v34);
      BOOL v27 = (unsigned __int16 *)((char *)v18 + (((char *)v21 - (char *)v18) & 0xFFFFFFFFFFFFFFFELL));
    }
    else
    {
      __int16 v35 = 0;
    }
    uint64_t v36 = v26 >> 1;
    unint64_t v37 = (unsigned __int16 *)&v35[2 * (v26 >> 1)];
    int v38 = &v35[2 * v34];
    if (v26 >> 1 == v34)
    {
      if (v26 < 1)
      {
        __int16 v64 = v27;
        if (v21 == v18) {
          unint64_t v50 = 1;
        }
        else {
          unint64_t v50 = (char *)v21 - (char *)v18;
        }
        __int16 v51 = v35;
        unsigned int v52 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned short>>(v65, v50);
        unint64_t v37 = (unsigned __int16 *)&v52[2 * (v50 >> 2)];
        int v38 = &v52[2 * v53];
        if (v51)
        {
          uint64_t v54 = v51;
          uint64_t v55 = v38;
          operator delete(v54);
          int v38 = v55;
        }
        unint64_t v40 = a1;
        BOOL v27 = v64;
        goto LABEL_44;
      }
      if (v36 >= -1) {
        uint64_t v39 = v36 + 1;
      }
      else {
        uint64_t v39 = v36 + 2;
      }
      unint64_t v37 = (unsigned __int16 *)((char *)v37 - (v39 & 0xFFFFFFFFFFFFFFFELL));
    }
    unint64_t v40 = a1;
LABEL_44:
    unsigned __int16 *v37 = a3;
    long long v41 = (char *)(v37 + 1);
    uint64_t v42 = *v40;
    if (*v40 != v27)
    {
      uint64_t v43 = v27;
      do
      {
        unsigned __int16 v44 = *--v43;
        *--unint64_t v37 = v44;
      }
      while (v43 != v42);
    }
    long long v45 = v40[1];
    int64_t v46 = (char *)v45 - (char *)v27;
    if (v45 != v27)
    {
      unint64_t v47 = v38;
      memmove(v41, v27, (char *)v45 - (char *)v27);
      int v38 = v47;
    }
    uint64_t v48 = &v41[v46];
    unint64_t v5 = a1;
    unint64_t v49 = *a1;
    *a1  = v37;
    a1[1]  = (unsigned __int16 *)v48;
    a1[2]  = (unsigned __int16 *)v38;
    uint64_t v10 = (void *)v65;
    if (v49) {
      operator delete(v49);
    }
    goto LABEL_51;
  }
  unint64_t v56 = 0;
  uint64_t v57 = 0;
LABEL_60:
  if (v57 != v56)
  {
    uint64_t v58 = v57 + 1;
    while (v58 != v56)
    {
      int v59 = *(v58 - 1);
      int v60 = *v58++;
      if (v59 == v60)
      {
        unint64_t v61 = v58 - 2;
        while (v58 != v56)
        {
          int v62 = v59;
          int v59 = *v58;
          if (v62 != v59)
          {
            v61[1]  = v59;
            ++v61;
          }
          ++v58;
        }
        unint64_t v63 = v61 + 1;
        goto LABEL_71;
      }
    }
  }
  unint64_t v63 = v56;
LABEL_71:
  if (v56 != v63) {
    v5[1]  = v63;
  }
}

void std::vector<std::vector<unsigned short>,TInlineBufferAllocator<std::vector<unsigned short>,30ul>>::push_back[abi:nn180100](void *a1, uint64_t a2)
{
  uint64_t v4 = (void *)a1[1];
  unint64_t v5 = a1[2];
  if ((unint64_t)v4 < v5)
  {
    unint64_t v6 = std::vector<unsigned short>::vector(v4, a2) + 3;
    goto LABEL_27;
  }
  unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v4 - *a1) >> 3);
  if (v7 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 3);
  uint64_t v9 = 2 * v8;
  if (2 * v8 <= v7 + 1) {
    uint64_t v9 = v7 + 1;
  }
  if (v8 >= 0x555555555555555) {
    unint64_t v10 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v10 = v9;
  }
  if (v10) {
    char v11 = TInlineBufferAllocator<std::pair<double,CFRange>,30ul>::allocate((uint64_t)(a1 + 3), v10);
  }
  else {
    char v11 = 0;
  }
  int v12 = &v11[24 * v10];
  unint64_t v13 = std::vector<unsigned short>::vector(&v11[24 * v7], a2);
  unint64_t v6 = v13 + 3;
  unsigned int v14 = (void *)*a1;
  int v15 = (void *)a1[1];
  if (v15 == (void *)*a1)
  {
    *a1  = v13;
    a1[1]  = v6;
    uint64_t v18 = a1[2];
    a1[2]  = v12;
    if (!v15) {
      goto LABEL_27;
    }
    goto LABEL_22;
  }
  do
  {
    *(v13 - 3)  = 0;
    *(v13 - 2)  = 0;
    v13 -= 3;
    v13[2]  = 0;
    long long v16 = *(_OWORD *)(v15 - 3);
    v15 -= 3;
    *(_OWORD *)unint64_t v13 = v16;
    v13[2]  = v15[2];
    *int v15 = 0;
    v15[1]  = 0;
    v15[2]  = 0;
  }
  while (v15 != v14);
  int v15 = (void *)*a1;
  unsigned int v17 = (void *)a1[1];
  *a1  = v13;
  a1[1]  = v6;
  uint64_t v18 = a1[2];
  a1[2]  = v12;
  if (v17 != v15)
  {
    uint64_t v19 = v17;
    do
    {
      uint64_t v21 = (void *)*(v19 - 3);
      v19 -= 3;
      unint64_t v20 = v21;
      if (v21)
      {
        *(v17 - 2)  = v20;
        operator delete(v20);
      }
      unsigned int v17 = v19;
    }
    while (v19 != v15);
  }
  if (v15)
  {
LABEL_22:
    if (a1 + 3 > v15 || (unint64_t v22 = a1 + 93, a1 + 93 <= v15))
    {
      operator delete(v15);
    }
    else if (v18 == *v22)
    {
      *unint64_t v22 = v15;
    }
  }
LABEL_27:
  a1[1]  = v6;
}

void *std::__hash_table<std::__hash_value_type<unsigned short,unsigned int>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,unsigned int>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,unsigned int>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,unsigned int>>>::__emplace_unique_key_args<unsigned short,std::piecewise_construct_t const&,std::tuple<unsigned short const&>,std::tuple<>>(float *a1, unsigned __int16 a2, _WORD *a3)
{
  unint64_t v5 = a2;
  unint64_t v6 = *((void *)a1 + 1);
  if (v6)
  {
    uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0]  = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      unint64_t v8 = a2;
      if (v6 <= a2) {
        unint64_t v8 = a2 % v6;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v8);
    if (v9)
    {
      unint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((unsigned __int16 *)v10 + 8) == a2) {
              return v10;
            }
          }
          else
          {
            if (v7.u32[0] > 1uLL)
            {
              if (v11 >= v6) {
                v11 %= v6;
              }
            }
            else
            {
              v11 &= v6 - 1;
            }
            if (v11 != v8) {
              break;
            }
          }
          unint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  else
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAAALL;
  }
  unint64_t v10 = operator new(0x18uLL);
  *unint64_t v10 = 0;
  v10[1]  = v5;
  *((_WORD *)v10 + 8)  = *a3;
  *((_DWORD *)v10 + 5)  = 0;
  float v12 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v13 = a1[8];
  if (!v6 || (float)(v13 * (float)v6) < v12)
  {
    BOOL v14 = 1;
    if (v6 >= 3) {
      BOOL v14 = (v6 & (v6 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v6);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      int8x8_t prime = (int8x8_t)v16;
    }
    else {
      int8x8_t prime = (int8x8_t)v15;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v6 = *((void *)a1 + 1);
    }
    if (*(void *)&prime > v6) {
      goto LABEL_30;
    }
    if (*(void *)&prime < v6)
    {
      unint64_t v24 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v6 < 3 || (uint8x8_t v25 = (uint8x8_t)vcnt_s8((int8x8_t)v6), v25.i16[0] = vaddlv_u8(v25), v25.u32[0] > 1uLL))
      {
        unint64_t v24 = std::__next_prime(v24);
      }
      else
      {
        uint64_t v26 = 1 << -(char)__clz(v24 - 1);
        if (v24 >= 2) {
          unint64_t v24 = v26;
        }
      }
      if (*(void *)&prime <= v24) {
        int8x8_t prime = (int8x8_t)v24;
      }
      if (*(void *)&prime >= v6)
      {
        unint64_t v6 = *((void *)a1 + 1);
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          uint64_t v18 = operator new(8 * *(void *)&prime);
          uint64_t v19 = *(void **)a1;
          *(void *)a1  = v18;
          if (v19) {
            operator delete(v19);
          }
          uint64_t v20 = 0;
          *((int8x8_t *)a1 + 1)  = prime;
          do
            *(void *)(*(void *)a1 + 8 * v20++)  = 0;
          while (*(void *)&prime != v20);
          uint64_t v21 = (void *)*((void *)a1 + 2);
          if (v21)
          {
            unint64_t v22 = v21[1];
            uint8x8_t v23 = (uint8x8_t)vcnt_s8(prime);
            v23.i16[0]  = vaddlv_u8(v23);
            if (v23.u32[0] > 1uLL)
            {
              if (v22 >= *(void *)&prime) {
                v22 %= *(void *)&prime;
              }
            }
            else
            {
              v22 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)a1 + 8 * v22)  = a1 + 4;
            BOOL v27 = (void *)*v21;
            if (*v21)
            {
              do
              {
                unint64_t v28 = v27[1];
                if (v23.u32[0] > 1uLL)
                {
                  if (v28 >= *(void *)&prime) {
                    v28 %= *(void *)&prime;
                  }
                }
                else
                {
                  v28 &= *(void *)&prime - 1;
                }
                if (v28 != v22)
                {
                  if (!*(void *)(*(void *)a1 + 8 * v28))
                  {
                    *(void *)(*(void *)a1 + 8 * v28)  = v21;
                    goto LABEL_55;
                  }
                  void *v21 = *v27;
                  *BOOL v27 = **(void **)(*(void *)a1 + 8 * v28);
                  **(void **)(*(void *)a1 + 8 * v28)  = v27;
                  BOOL v27 = v21;
                }
                unint64_t v28 = v22;
LABEL_55:
                uint64_t v21 = v27;
                BOOL v27 = (void *)*v27;
                unint64_t v22 = v28;
              }
              while (v27);
            }
          }
          unint64_t v6 = (unint64_t)prime;
          goto LABEL_59;
        }
        uint64_t v33 = *(void **)a1;
        *(void *)a1  = 0;
        if (v33) {
          operator delete(v33);
        }
        unint64_t v6 = 0;
        *((void *)a1 + 1)  = 0;
      }
    }
LABEL_59:
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v6 <= v5) {
        unint64_t v8 = v5 % v6;
      }
      else {
        unint64_t v8 = v5;
      }
    }
    else
    {
      unint64_t v8 = (v6 - 1) & v5;
    }
  }
  unint64_t v29 = *(void **)a1;
  unsigned __int16 v30 = *(void **)(*(void *)a1 + 8 * v8);
  if (v30)
  {
    *unint64_t v10 = *v30;
LABEL_72:
    *unsigned __int16 v30 = v10;
    goto LABEL_73;
  }
  *unint64_t v10 = *((void *)a1 + 2);
  *((void *)a1 + 2)  = v10;
  v29[v8]  = a1 + 4;
  if (*v10)
  {
    unint64_t v31 = *(void *)(*v10 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v31 >= v6) {
        v31 %= v6;
      }
    }
    else
    {
      v31 &= v6 - 1;
    }
    unsigned __int16 v30 = (void *)(*(void *)a1 + 8 * v31);
    goto LABEL_72;
  }
LABEL_73:
  ++*((void *)a1 + 3);
  return v10;
}

void std::__function::__func<anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_3,std::allocator<anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_3>,void ()(unsigned short,unsigned short,unsigned short)>::~__func()
{
}

__n128 std::__function::__func<anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_3,std::allocator<anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_3>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1ED060B30;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8)  = result;
  return result;
}

__n128 std::__function::__func<anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_3,std::allocator<anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_3>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2  = &unk_1ED060B30;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8)  = result;
  return result;
}

void *std::__function::__func<anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_3,std::allocator<anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_3>,void ()(unsigned short,unsigned short,unsigned short)>::operator()(void *result, unsigned __int16 *a2, unsigned __int16 *a3)
{
  unsigned int v3 = *a2;
  unsigned int v4 = *a3;
  if (v3 <= v4 && v3 != (unsigned __int16)(v4 + 1))
  {
    unint64_t v5 = result;
    do
    {
      __int16 v8 = v3;
      int v6 = *(_DWORD *)v5[2];
      __n128 result = std::__hash_table<std::__hash_value_type<unsigned short,unsigned int>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,unsigned int>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,unsigned int>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,unsigned int>>>::__emplace_unique_key_args<unsigned short,std::piecewise_construct_t const&,std::tuple<unsigned short const&>,std::tuple<>>((float *)v5[1], v3, &v8);
      *((_DWORD *)result + 5) |= v6;
    }
    while (v4 != (unsigned __int16)v3++);
  }
  return result;
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_0 &,std::pair<unsigned short,unsigned int> *,false>(uint64_t result, _DWORD *a2, uint64_t a3, char a4)
{
  unint64_t v9 = result;
  while (2)
  {
    unint64_t v10 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          unint64_t v9 = v10;
          uint64_t v11 = (uint64_t)a2 - v10;
          unint64_t v12 = (uint64_t)((uint64_t)a2 - v10) >> 3;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                unsigned int v46 = *(a2 - 1);
                unsigned int v47 = *(_DWORD *)(v10 + 4);
                if (v46 < v47)
                {
                  __int16 v48 = *(_WORD *)v10;
                  *(_WORD *)unint64_t v10 = *((_WORD *)a2 - 4);
                  *((_WORD *)a2 - 4)  = v48;
                  *(_DWORD *)(v10 + 4)  = v46;
                  *(a2 - 1)  = v47;
                }
                break;
              case 3uLL:
                break;
              case 4uLL:
                break;
              case 5uLL:
                unsigned int v49 = *(a2 - 1);
                unsigned int v50 = *(_DWORD *)(v10 + 28);
                if (v49 < v50)
                {
                  __int16 v51 = *(_WORD *)(v10 + 24);
                  *(_WORD *)(v10 + 24)  = *((_WORD *)a2 - 4);
                  *((_WORD *)a2 - 4)  = v51;
                  *(_DWORD *)(v10 + 28)  = v49;
                  *(a2 - 1)  = v50;
                  unsigned int v52 = *(_DWORD *)(v10 + 28);
                  unsigned int v53 = *(_DWORD *)(v10 + 20);
                  if (v52 < v53)
                  {
                    __int16 v54 = *(_WORD *)(v10 + 16);
                    __int16 v55 = *(_WORD *)(v10 + 24);
                    *(_WORD *)(v10 + 16)  = v55;
                    *(_WORD *)(v10 + 24)  = v54;
                    *(_DWORD *)(v10 + 20)  = v52;
                    *(_DWORD *)(v10 + 28)  = v53;
                    unsigned int v56 = *(_DWORD *)(v10 + 12);
                    if (v52 < v56)
                    {
                      __int16 v57 = *(_WORD *)(v10 + 8);
                      *(_WORD *)(v10 + 8)  = v55;
                      *(_WORD *)(v10 + 16)  = v57;
                      *(_DWORD *)(v10 + 12)  = v52;
                      *(_DWORD *)(v10 + 20)  = v56;
                      unsigned int v58 = *(_DWORD *)(v10 + 4);
                      if (v52 < v58)
                      {
                        __int16 v59 = *(_WORD *)v10;
                        *(_WORD *)unint64_t v10 = v55;
                        *(_WORD *)(v10 + 8)  = v59;
                        *(_DWORD *)(v10 + 4)  = v52;
                        *(_DWORD *)(v10 + 12)  = v58;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v11 <= 191)
          {
            int v60 = (_DWORD *)(v10 + 8);
            BOOL v62 = (_DWORD *)v10 == a2 || v60 == a2;
            if (a4)
            {
              if (!v62)
              {
                uint64_t v63 = 0;
                __int16 v64 = (_DWORD *)v10;
                do
                {
                  unsigned int v65 = v64[3];
                  unsigned int v66 = v64[1];
                  __int16 v64 = v60;
                  if (v65 < v66)
                  {
                    int v67 = *v60;
                    unsigned int v68 = v64[1];
                    uint64_t v69 = v63;
                    while (1)
                    {
                      uint64_t v70 = v10 + v69;
                      *(_WORD *)(v70 + 8)  = *(_WORD *)(v10 + v69);
                      *(_DWORD *)(v70 + 12)  = *(_DWORD *)(v10 + v69 + 4);
                      if (!v69) {
                        break;
                      }
                      v69 -= 8;
                      if (*(_DWORD *)(v70 - 4) <= v68)
                      {
                        uint64_t v71 = v10 + v69 + 8;
                        goto LABEL_83;
                      }
                    }
                    uint64_t v71 = v10;
LABEL_83:
                    *(_WORD *)uint64_t v71 = v67;
                    *(_DWORD *)(v71 + 4)  = v68;
                  }
                  int v60 = v64 + 2;
                  v63 += 8;
                }
                while (v64 + 2 != a2);
              }
            }
            else if (!v62)
            {
              unsigned int v102 = (_DWORD *)(v10 + 12);
              do
              {
                unsigned int v103 = *(_DWORD *)(v9 + 12);
                unsigned int v104 = *(_DWORD *)(v9 + 4);
                unint64_t v9 = (unint64_t)v60;
                if (v103 < v104)
                {
                  uint64_t v105 = *(void *)v60;
                  uint64_t v106 = HIDWORD(*(void *)v9);
                  uint64_t v107 = v102;
                  do
                  {
                    unint64_t v108 = v107;
                    *((_WORD *)v107 - 2)  = *((_WORD *)v107 - 6);
                    int v109 = *(v107 - 2);
                    v107 -= 2;
                    *unint64_t v108 = v109;
                  }
                  while (*(v108 - 4) > v106);
                  *((_WORD *)v107 - 2)  = v105;
                  _DWORD *v107 = v106;
                }
                int v60 = (_DWORD *)(v9 + 8);
                v102 += 2;
              }
              while ((_DWORD *)(v9 + 8) != a2);
            }
            return result;
          }
          if (!a3)
          {
            if ((_DWORD *)v10 != a2)
            {
              int64_t v72 = (v12 - 2) >> 1;
              int64_t v73 = v72;
              do
              {
                int64_t v74 = v73;
                if (v72 >= v73)
                {
                  uint64_t v75 = (2 * v73) | 1;
                  unsigned int v76 = (int *)(v10 + 8 * v75);
                  if (2 * v74 + 2 < (uint64_t)v12)
                  {
                    unsigned int v77 = v76[1];
                    unsigned int v78 = v76[3];
                    v76 += 2 * (v77 < v78);
                    if (v77 < v78) {
                      uint64_t v75 = 2 * v74 + 2;
                    }
                  }
                  unsigned int v79 = v76[1];
                  if (v79 >= *(_DWORD *)(v10 + 8 * v74 + 4))
                  {
                    long long v80 = (int *)(v10 + 8 * v74);
                    int v81 = *v80;
                    unsigned int v82 = v80[1];
                    do
                    {
                      __n128 result = (uint64_t)v80;
                      long long v80 = v76;
                      *(_WORD *)__n128 result = *(_WORD *)v76;
                      *(_DWORD *)(result + 4)  = v79;
                      if (v72 < v75) {
                        break;
                      }
                      __n128 result = (2 * v75) | 1;
                      unsigned int v76 = (int *)(v10 + 8 * result);
                      uint64_t v83 = 2 * v75 + 2;
                      if (v83 < (uint64_t)v12)
                      {
                        unsigned int v84 = v76[1];
                        unsigned int v85 = v76[3];
                        v76 += 2 * (v84 < v85);
                        if (v84 < v85) {
                          __n128 result = v83;
                        }
                      }
                      unsigned int v79 = v76[1];
                      uint64_t v75 = result;
                    }
                    while (v79 >= v82);
                    *(_WORD *)long long v80 = v81;
                    v80[1]  = v82;
                  }
                }
                int64_t v73 = v74 - 1;
              }
              while (v74);
              uint64_t v86 = (unint64_t)v11 >> 3;
              do
              {
                uint64_t v87 = 0;
                uint64_t v88 = *(void *)v10;
                unint64_t v89 = v10;
                do
                {
                  int v90 = (_DWORD *)(v89 + 8 * (v87 + 1));
                  uint64_t v91 = (2 * v87) | 1;
                  uint64_t v92 = 2 * v87 + 2;
                  if (v92 < v86)
                  {
                    unsigned int v93 = v90[1];
                    unsigned int v94 = v90[3];
                    v90 += 2 * (v93 < v94);
                    if (v93 < v94) {
                      uint64_t v91 = v92;
                    }
                  }
                  *(_WORD *)unint64_t v89 = *(_WORD *)v90;
                  *(_DWORD *)(v89 + 4)  = v90[1];
                  unint64_t v89 = (unint64_t)v90;
                  uint64_t v87 = v91;
                }
                while (v91 <= (uint64_t)((unint64_t)(v86 - 2) >> 1));
                if (v90 == a2 - 2)
                {
                  *(_WORD *)int v90 = v88;
                  v90[1]  = HIDWORD(v88);
                }
                else
                {
                  *(_WORD *)int v90 = *((_WORD *)a2 - 4);
                  v90[1]  = *(a2 - 1);
                  *((_WORD *)a2 - 4)  = v88;
                  *(a2 - 1)  = HIDWORD(v88);
                  uint64_t v95 = (uint64_t)v90 - v10 + 8;
                  if (v95 >= 9)
                  {
                    unint64_t v96 = (((unint64_t)v95 >> 3) - 2) >> 1;
                    unsigned int v97 = *(_DWORD *)(v10 + 8 * v96 + 4);
                    if (v97 < v90[1])
                    {
                      int v98 = *v90;
                      unsigned int v99 = v90[1];
                      do
                      {
                        uint64_t v100 = v90;
                        int v90 = (_DWORD *)(v10 + 8 * v96);
                        *(_WORD *)uint64_t v100 = *(_WORD *)v90;
                        v100[1]  = v97;
                        if (!v96) {
                          break;
                        }
                        unint64_t v96 = (v96 - 1) >> 1;
                        unsigned int v97 = *(_DWORD *)(v10 + 8 * v96 + 4);
                      }
                      while (v97 < v99);
                      *(_WORD *)int v90 = v98;
                      v90[1]  = v99;
                    }
                  }
                }
                a2 -= 2;
              }
              while (v86-- > 2);
            }
            return result;
          }
          unint64_t v13 = v12 >> 1;
          unint64_t v14 = v10 + 8 * (v12 >> 1);
          if ((unint64_t)v11 >= 0x401)
          {
            __int16 v15 = *(_WORD *)v9;
            *(_WORD *)unint64_t v9 = *(_WORD *)v14;
            *(_WORD *)unint64_t v14 = v15;
            int v16 = *(_DWORD *)(v9 + 4);
            *(_DWORD *)(v9 + 4)  = *(_DWORD *)(v14 + 4);
            *(_DWORD *)(v14 + 4)  = v16;
          }
          else
          {
          }
          --a3;
          if ((a4 & 1) != 0 || *(_DWORD *)(v9 - 4) < *(_DWORD *)(v9 + 4)) {
            break;
          }
          uint64_t v33 = *(void *)v9;
          uint64_t v34 = HIDWORD(*(void *)v9);
          if (*(a2 - 1) <= v34)
          {
            unint64_t v37 = v9 + 8;
            do
            {
              unint64_t v10 = v37;
              if (v37 >= (unint64_t)a2) {
                break;
              }
              unsigned int v38 = *(_DWORD *)(v37 + 4);
              v37 += 8;
            }
            while (v38 <= v34);
          }
          else
          {
            unint64_t v35 = v9;
            do
            {
              unint64_t v10 = v35 + 8;
              unsigned int v36 = *(_DWORD *)(v35 + 12);
              v35 += 8;
            }
            while (v36 <= v34);
          }
          uint64_t v39 = a2;
          if (v10 < (unint64_t)a2)
          {
            unint64_t v40 = a2;
            do
            {
              uint64_t v39 = v40 - 2;
              unsigned int v41 = *(v40 - 1);
              v40 -= 2;
            }
            while (v41 > v34);
          }
          while (v10 < (unint64_t)v39)
          {
            __int16 v42 = *(_WORD *)v10;
            *(_WORD *)unint64_t v10 = *(_WORD *)v39;
            *(_WORD *)uint64_t v39 = v42;
            int v43 = *(_DWORD *)(v10 + 4);
            *(_DWORD *)(v10 + 4)  = v39[1];
            v39[1]  = v43;
            do
            {
              unsigned int v44 = *(_DWORD *)(v10 + 12);
              v10 += 8;
            }
            while (v44 <= v34);
            do
            {
              unsigned int v45 = *(v39 - 1);
              v39 -= 2;
            }
            while (v45 > v34);
          }
          BOOL v4 = v10 - 8 >= v9;
          BOOL v5 = v10 - 8 == v9;
          if (v10 - 8 != v9)
          {
            *(_WORD *)unint64_t v9 = *(_WORD *)(v10 - 8);
            *(_DWORD *)(v9 + 4)  = *(_DWORD *)(v10 - 4);
          }
          a4  = 0;
          *(_WORD *)(v10 - 8)  = v33;
          *(_DWORD *)(v10 - 4)  = v34;
        }
        uint64_t v17 = 0;
        uint64_t v18 = *(void *)v9;
        uint64_t v19 = HIDWORD(*(void *)v9);
        do
        {
          unsigned int v20 = *(_DWORD *)(v9 + v17 + 12);
          v17 += 8;
        }
        while (v20 < v19);
        unint64_t v21 = v9 + v17;
        unint64_t v22 = a2;
        if (v17 == 8)
        {
          uint8x8_t v25 = a2;
          while (v21 < (unint64_t)v25)
          {
            uint8x8_t v23 = v25 - 2;
            unsigned int v26 = *(v25 - 1);
            v25 -= 2;
            if (v26 < v19) {
              goto LABEL_22;
            }
          }
          uint8x8_t v23 = v25;
        }
        else
        {
          do
          {
            uint8x8_t v23 = v22 - 2;
            unsigned int v24 = *(v22 - 1);
            v22 -= 2;
          }
          while (v24 >= v19);
        }
LABEL_22:
        unint64_t v10 = v21;
        if (v21 < (unint64_t)v23)
        {
          unint64_t v27 = (unint64_t)v23;
          do
          {
            __int16 v28 = *(_WORD *)v10;
            *(_WORD *)unint64_t v10 = *(_WORD *)v27;
            *(_WORD *)unint64_t v27 = v28;
            int v29 = *(_DWORD *)(v10 + 4);
            *(_DWORD *)(v10 + 4)  = *(_DWORD *)(v27 + 4);
            *(_DWORD *)(v27 + 4)  = v29;
            do
            {
              unsigned int v30 = *(_DWORD *)(v10 + 12);
              v10 += 8;
            }
            while (v30 < v19);
            do
            {
              unsigned int v31 = *(_DWORD *)(v27 - 4);
              v27 -= 8;
            }
            while (v31 >= v19);
          }
          while (v10 < v27);
        }
        if (v10 - 8 != v9)
        {
          *(_WORD *)unint64_t v9 = *(_WORD *)(v10 - 8);
          *(_DWORD *)(v9 + 4)  = *(_DWORD *)(v10 - 4);
        }
        *(_WORD *)(v10 - 8)  = v18;
        *(_DWORD *)(v10 - 4)  = v19;
        if (v21 >= (unint64_t)v23) {
          break;
        }
LABEL_33:
        a4  = 0;
      }
      if (result) {
        break;
      }
      if (!v32) {
        goto LABEL_33;
      }
    }
    a2  = (_DWORD *)(v10 - 8);
    if (!v32) {
      continue;
    }
    return result;
  }
}

__int16 *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_0 &,std::pair<unsigned short,unsigned int> *>(__int16 *result, __int16 *a2, __int16 *a3)
{
  unsigned int v3 = *((_DWORD *)a2 + 1);
  unsigned int v4 = *((_DWORD *)result + 1);
  unsigned int v5 = *((_DWORD *)a3 + 1);
  if (v3 >= v4)
  {
    if (v5 < v3)
    {
      __int16 v7 = *a2;
      *a2  = *a3;
      *a3  = v7;
      *((_DWORD *)a2 + 1)  = v5;
      *((_DWORD *)a3 + 1)  = v3;
      unsigned int v8 = *((_DWORD *)a2 + 1);
      unsigned int v9 = *((_DWORD *)result + 1);
      if (v8 < v9)
      {
        __int16 v10 = *result;
        *__n128 result = *a2;
        *a2  = v10;
        *((_DWORD *)result + 1)  = v8;
        *((_DWORD *)a2 + 1)  = v9;
      }
    }
  }
  else
  {
    __int16 v6 = *result;
    if (v5 >= v3)
    {
      *__n128 result = *a2;
      *a2  = v6;
      *((_DWORD *)result + 1)  = v3;
      *((_DWORD *)a2 + 1)  = v4;
      unsigned int v11 = *((_DWORD *)a3 + 1);
      if (v11 >= v4) {
        return result;
      }
      *a2  = *a3;
      *a3  = v6;
      *((_DWORD *)a2 + 1)  = v11;
    }
    else
    {
      *__n128 result = *a3;
      *a3  = v6;
      *((_DWORD *)result + 1)  = v5;
    }
    *((_DWORD *)a3 + 1)  = v4;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_0 &,std::pair<unsigned short,unsigned int> *>(uint64_t a1, _DWORD *a2)
{
  uint64_t v4 = ((uint64_t)a2 - a1) >> 3;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      unsigned int v6 = *(a2 - 1);
      unsigned int v7 = *(_DWORD *)(a1 + 4);
      if (v6 < v7)
      {
        __int16 v8 = *(_WORD *)a1;
        *(_WORD *)a1  = *((_WORD *)a2 - 4);
        *((_WORD *)a2 - 4)  = v8;
        *(_DWORD *)(a1 + 4)  = v6;
        *(a2 - 1)  = v7;
      }
      return result;
    case 3:
      return 1;
    case 4:
      return 1;
    case 5:
      unsigned int v18 = *(a2 - 1);
      unsigned int v19 = *(_DWORD *)(a1 + 28);
      if (v18 < v19)
      {
        __int16 v20 = *(_WORD *)(a1 + 24);
        *(_WORD *)(a1 + 24)  = *((_WORD *)a2 - 4);
        *((_WORD *)a2 - 4)  = v20;
        *(_DWORD *)(a1 + 28)  = v18;
        *(a2 - 1)  = v19;
        unsigned int v21 = *(_DWORD *)(a1 + 28);
        unsigned int v22 = *(_DWORD *)(a1 + 20);
        if (v21 < v22)
        {
          __int16 v23 = *(_WORD *)(a1 + 16);
          __int16 v24 = *(_WORD *)(a1 + 24);
          *(_WORD *)(a1 + 16)  = v24;
          *(_WORD *)(a1 + 24)  = v23;
          *(_DWORD *)(a1 + 20)  = v21;
          *(_DWORD *)(a1 + 28)  = v22;
          unsigned int v25 = *(_DWORD *)(a1 + 12);
          if (v21 < v25)
          {
            __int16 v26 = *(_WORD *)(a1 + 8);
            *(_WORD *)(a1 + 8)  = v24;
            *(_WORD *)(a1 + 16)  = v26;
            *(_DWORD *)(a1 + 12)  = v21;
            *(_DWORD *)(a1 + 20)  = v25;
            unsigned int v27 = *(_DWORD *)(a1 + 4);
            if (v21 < v27)
            {
              __int16 v28 = *(_WORD *)a1;
              *(_WORD *)a1  = v24;
              *(_WORD *)(a1 + 8)  = v28;
              *(_DWORD *)(a1 + 4)  = v21;
              *(_DWORD *)(a1 + 12)  = v27;
            }
          }
        }
      }
      return 1;
    default:
      unsigned int v9 = (_DWORD *)(a1 + 16);
      __int16 v10 = (_DWORD *)(a1 + 24);
      if ((_DWORD *)(a1 + 24) == a2) {
        return 1;
      }
      uint64_t v11 = 0;
      int v12 = 0;
      break;
  }
  while (1)
  {
    if (v10[1] < v9[1])
    {
      int v13 = *v10;
      unsigned int v14 = v10[1];
      uint64_t v15 = v11;
      while (1)
      {
        uint64_t v16 = a1 + v15;
        *(_WORD *)(v16 + 24)  = *(_WORD *)(a1 + v15 + 16);
        *(_DWORD *)(v16 + 28)  = *(_DWORD *)(a1 + v15 + 20);
        if (v15 == -16) {
          break;
        }
        v15 -= 8;
        if (*(_DWORD *)(v16 + 12) <= v14)
        {
          uint64_t v17 = a1 + v15 + 24;
          goto LABEL_13;
        }
      }
      uint64_t v17 = a1;
LABEL_13:
      *(_WORD *)uint64_t v17 = v13;
      *(_DWORD *)(v17 + 4)  = v14;
      if (++v12 == 8) {
        return v10 + 2 == a2;
      }
    }
    unsigned int v9 = v10;
    v11 += 8;
    v10 += 2;
    if (v10 == a2) {
      return 1;
    }
  }
}

__int16 *std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_0 &,std::pair<unsigned short,unsigned int> *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned int v9 = *(_DWORD *)(a4 + 4);
  unsigned int v10 = *(_DWORD *)(a3 + 4);
  if (v9 < v10)
  {
    __int16 v11 = *(_WORD *)a3;
    *(_WORD *)a3  = *(_WORD *)a4;
    *(_WORD *)a4  = v11;
    *(_DWORD *)(a3 + 4)  = v9;
    *(_DWORD *)(a4 + 4)  = v10;
    unsigned int v12 = *(_DWORD *)(a3 + 4);
    unsigned int v13 = *(_DWORD *)(a2 + 4);
    if (v12 < v13)
    {
      __int16 v14 = *(_WORD *)a2;
      *(_WORD *)a2  = *(_WORD *)a3;
      *(_WORD *)a3  = v14;
      *(_DWORD *)(a2 + 4)  = v12;
      *(_DWORD *)(a3 + 4)  = v13;
      unsigned int v15 = *(_DWORD *)(a2 + 4);
      unsigned int v16 = *(_DWORD *)(a1 + 4);
      if (v15 < v16)
      {
        __int16 v17 = *(_WORD *)a1;
        *(_WORD *)a1  = *(_WORD *)a2;
        *(_WORD *)a2  = v17;
        *(_DWORD *)(a1 + 4)  = v15;
        *(_DWORD *)(a2 + 4)  = v16;
      }
    }
  }
  return result;
}

void std::vector<std::pair<unsigned short,unsigned int>,TInlineBufferAllocator<std::pair<unsigned short,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  if (v2)
  {
    *(void *)(a1 + 8)  = v2;
    unsigned int v3 = (void *)(a1 + 264);
    if (a1 + 24 <= (unint64_t)v2)
    {
      BOOL v4 = v3 >= v2;
      BOOL v5 = v3 == v2;
    }
    else
    {
      BOOL v4 = 0;
      BOOL v5 = 0;
    }
    if (!v5 && v4)
    {
      if (*(void *)(a1 + 16) == *(void *)(a1 + 264)) {
        *unsigned int v3 = v2;
      }
    }
    else
    {
      operator delete(v2);
    }
  }
}

void std::__function::__func<anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_4,std::allocator<anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_4>,void ()(unsigned short,unsigned short,unsigned short)>::~__func()
{
}

__n128 std::__function::__func<anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_4,std::allocator<anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_4>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1ED060B78;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8)  = result;
  return result;
}

__n128 std::__function::__func<anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_4,std::allocator<anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_4>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2  = &unk_1ED060B78;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8)  = result;
  return result;
}

uint64_t std::__function::__func<anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_4,std::allocator<anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_4>,void ()(unsigned short,unsigned short,unsigned short)>::operator()(uint64_t result, unsigned __int16 *a2, unsigned __int16 *a3)
{
  unsigned int v3 = *a2;
  unsigned int v4 = *a3;
  if (v3 <= v4 && v3 != (unsigned __int16)(v4 + 1))
  {
    uint64_t v5 = result;
    do
    {
      __int16 v24 = v3;
      unsigned int v6 = *(char ***)(v5 + 8);
      __n128 result = (uint64_t)std::__hash_table<std::__hash_value_type<unsigned short,unsigned int>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,unsigned int>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,unsigned int>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,unsigned int>>>::__emplace_unique_key_args<unsigned short,std::piecewise_construct_t const&,std::tuple<unsigned short const&>,std::tuple<>>(*(float **)(v5 + 16), v3, &v24);
      uint64_t v7 = result;
      unint64_t v9 = (unint64_t)v6[1];
      unint64_t v8 = (unint64_t)v6[2];
      if (v9 >= v8)
      {
        uint64_t v11 = (uint64_t)(v9 - (void)*v6) >> 3;
        unint64_t v12 = v11 + 1;
        if ((unint64_t)(v11 + 1) >> 61) {
          abort();
        }
        uint64_t v13 = v8 - (void)*v6;
        if (v13 >> 2 > v12) {
          unint64_t v12 = v13 >> 2;
        }
        if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v14 = v12;
        }
        v25[4]  = v6 + 3;
        unsigned int v15 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)(v6 + 3), v14);
        unsigned int v16 = &v15[8 * v11];
        *(_WORD *)unsigned int v16 = v3;
        *((_DWORD *)v16 + 1)  = *(_DWORD *)(v7 + 20);
        unsigned int v18 = *v6;
        __int16 v17 = v6[1];
        if (v17 == *v6)
        {
          unsigned int v21 = v6[1];
          unsigned int v19 = &v15[8 * v11];
        }
        else
        {
          unsigned int v19 = &v15[8 * v11];
          do
          {
            uint64_t v20 = *((void *)v17 - 1);
            v17 -= 8;
            *((void *)v19 - 1)  = v20;
            v19 -= 8;
          }
          while (v17 != v18);
          unsigned int v21 = *v6;
          __int16 v17 = v6[1];
        }
        unsigned int v10 = v16 + 8;
        *unsigned int v6 = v19;
        v25[0]  = v21;
        v25[1]  = v21;
        v6[1]  = v16 + 8;
        v25[2]  = v17;
        unsigned int v22 = v6[2];
        id v6[2] = &v15[8 * v14];
        v25[3]  = v22;
        __n128 result = std::__split_buffer<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul> &>::~__split_buffer((uint64_t)v25);
      }
      else
      {
        *(_WORD *)unint64_t v9 = v3;
        *(_DWORD *)(v9 + 4)  = *(_DWORD *)(result + 20);
        unsigned int v10 = (char *)(v9 + 8);
      }
      v6[1]  = v10;
      BOOL v23 = v4 == (unsigned __int16)v3;
      LOWORD(v3)  = v3 + 1;
    }
    while (!v23);
  }
  return result;
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_1 &,std::pair<unsigned short,unsigned int> *,false>(uint64_t result, _DWORD *a2, uint64_t a3, char a4)
{
  unint64_t v9 = result;
  while (2)
  {
    unint64_t v10 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          unint64_t v9 = v10;
          uint64_t v11 = (uint64_t)a2 - v10;
          unint64_t v12 = (uint64_t)((uint64_t)a2 - v10) >> 3;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                unsigned int v46 = *(a2 - 1);
                unsigned int v47 = *(_DWORD *)(v10 + 4);
                if (v46 < v47)
                {
                  __int16 v48 = *(_WORD *)v10;
                  *(_WORD *)unint64_t v10 = *((_WORD *)a2 - 4);
                  *((_WORD *)a2 - 4)  = v48;
                  *(_DWORD *)(v10 + 4)  = v46;
                  *(a2 - 1)  = v47;
                }
                break;
              case 3uLL:
                break;
              case 4uLL:
                break;
              case 5uLL:
                unsigned int v49 = *(a2 - 1);
                unsigned int v50 = *(_DWORD *)(v10 + 28);
                if (v49 < v50)
                {
                  __int16 v51 = *(_WORD *)(v10 + 24);
                  *(_WORD *)(v10 + 24)  = *((_WORD *)a2 - 4);
                  *((_WORD *)a2 - 4)  = v51;
                  *(_DWORD *)(v10 + 28)  = v49;
                  *(a2 - 1)  = v50;
                  unsigned int v52 = *(_DWORD *)(v10 + 28);
                  unsigned int v53 = *(_DWORD *)(v10 + 20);
                  if (v52 < v53)
                  {
                    __int16 v54 = *(_WORD *)(v10 + 16);
                    __int16 v55 = *(_WORD *)(v10 + 24);
                    *(_WORD *)(v10 + 16)  = v55;
                    *(_WORD *)(v10 + 24)  = v54;
                    *(_DWORD *)(v10 + 20)  = v52;
                    *(_DWORD *)(v10 + 28)  = v53;
                    unsigned int v56 = *(_DWORD *)(v10 + 12);
                    if (v52 < v56)
                    {
                      __int16 v57 = *(_WORD *)(v10 + 8);
                      *(_WORD *)(v10 + 8)  = v55;
                      *(_WORD *)(v10 + 16)  = v57;
                      *(_DWORD *)(v10 + 12)  = v52;
                      *(_DWORD *)(v10 + 20)  = v56;
                      unsigned int v58 = *(_DWORD *)(v10 + 4);
                      if (v52 < v58)
                      {
                        __int16 v59 = *(_WORD *)v10;
                        *(_WORD *)unint64_t v10 = v55;
                        *(_WORD *)(v10 + 8)  = v59;
                        *(_DWORD *)(v10 + 4)  = v52;
                        *(_DWORD *)(v10 + 12)  = v58;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v11 <= 191)
          {
            int v60 = (_DWORD *)(v10 + 8);
            BOOL v62 = (_DWORD *)v10 == a2 || v60 == a2;
            if (a4)
            {
              if (!v62)
              {
                uint64_t v63 = 0;
                __int16 v64 = (_DWORD *)v10;
                do
                {
                  unsigned int v65 = v64[3];
                  unsigned int v66 = v64[1];
                  __int16 v64 = v60;
                  if (v65 < v66)
                  {
                    int v67 = *v60;
                    unsigned int v68 = v64[1];
                    uint64_t v69 = v63;
                    while (1)
                    {
                      uint64_t v70 = v10 + v69;
                      *(_WORD *)(v70 + 8)  = *(_WORD *)(v10 + v69);
                      *(_DWORD *)(v70 + 12)  = *(_DWORD *)(v10 + v69 + 4);
                      if (!v69) {
                        break;
                      }
                      v69 -= 8;
                      if (*(_DWORD *)(v70 - 4) <= v68)
                      {
                        uint64_t v71 = v10 + v69 + 8;
                        goto LABEL_83;
                      }
                    }
                    uint64_t v71 = v10;
LABEL_83:
                    *(_WORD *)uint64_t v71 = v67;
                    *(_DWORD *)(v71 + 4)  = v68;
                  }
                  int v60 = v64 + 2;
                  v63 += 8;
                }
                while (v64 + 2 != a2);
              }
            }
            else if (!v62)
            {
              unsigned int v102 = (_DWORD *)(v10 + 12);
              do
              {
                unsigned int v103 = *(_DWORD *)(v9 + 12);
                unsigned int v104 = *(_DWORD *)(v9 + 4);
                unint64_t v9 = (unint64_t)v60;
                if (v103 < v104)
                {
                  uint64_t v105 = *(void *)v60;
                  uint64_t v106 = HIDWORD(*(void *)v9);
                  uint64_t v107 = v102;
                  do
                  {
                    unint64_t v108 = v107;
                    *((_WORD *)v107 - 2)  = *((_WORD *)v107 - 6);
                    int v109 = *(v107 - 2);
                    v107 -= 2;
                    *unint64_t v108 = v109;
                  }
                  while (*(v108 - 4) > v106);
                  *((_WORD *)v107 - 2)  = v105;
                  _DWORD *v107 = v106;
                }
                int v60 = (_DWORD *)(v9 + 8);
                v102 += 2;
              }
              while ((_DWORD *)(v9 + 8) != a2);
            }
            return result;
          }
          if (!a3)
          {
            if ((_DWORD *)v10 != a2)
            {
              int64_t v72 = (v12 - 2) >> 1;
              int64_t v73 = v72;
              do
              {
                int64_t v74 = v73;
                if (v72 >= v73)
                {
                  uint64_t v75 = (2 * v73) | 1;
                  unsigned int v76 = (int *)(v10 + 8 * v75);
                  if (2 * v74 + 2 < (uint64_t)v12)
                  {
                    unsigned int v77 = v76[1];
                    unsigned int v78 = v76[3];
                    v76 += 2 * (v77 < v78);
                    if (v77 < v78) {
                      uint64_t v75 = 2 * v74 + 2;
                    }
                  }
                  unsigned int v79 = v76[1];
                  if (v79 >= *(_DWORD *)(v10 + 8 * v74 + 4))
                  {
                    long long v80 = (int *)(v10 + 8 * v74);
                    int v81 = *v80;
                    unsigned int v82 = v80[1];
                    do
                    {
                      __n128 result = (uint64_t)v80;
                      long long v80 = v76;
                      *(_WORD *)__n128 result = *(_WORD *)v76;
                      *(_DWORD *)(result + 4)  = v79;
                      if (v72 < v75) {
                        break;
                      }
                      __n128 result = (2 * v75) | 1;
                      unsigned int v76 = (int *)(v10 + 8 * result);
                      uint64_t v83 = 2 * v75 + 2;
                      if (v83 < (uint64_t)v12)
                      {
                        unsigned int v84 = v76[1];
                        unsigned int v85 = v76[3];
                        v76 += 2 * (v84 < v85);
                        if (v84 < v85) {
                          __n128 result = v83;
                        }
                      }
                      unsigned int v79 = v76[1];
                      uint64_t v75 = result;
                    }
                    while (v79 >= v82);
                    *(_WORD *)long long v80 = v81;
                    v80[1]  = v82;
                  }
                }
                int64_t v73 = v74 - 1;
              }
              while (v74);
              uint64_t v86 = (unint64_t)v11 >> 3;
              do
              {
                uint64_t v87 = 0;
                uint64_t v88 = *(void *)v10;
                unint64_t v89 = v10;
                do
                {
                  int v90 = (_DWORD *)(v89 + 8 * (v87 + 1));
                  uint64_t v91 = (2 * v87) | 1;
                  uint64_t v92 = 2 * v87 + 2;
                  if (v92 < v86)
                  {
                    unsigned int v93 = v90[1];
                    unsigned int v94 = v90[3];
                    v90 += 2 * (v93 < v94);
                    if (v93 < v94) {
                      uint64_t v91 = v92;
                    }
                  }
                  *(_WORD *)unint64_t v89 = *(_WORD *)v90;
                  *(_DWORD *)(v89 + 4)  = v90[1];
                  unint64_t v89 = (unint64_t)v90;
                  uint64_t v87 = v91;
                }
                while (v91 <= (uint64_t)((unint64_t)(v86 - 2) >> 1));
                if (v90 == a2 - 2)
                {
                  *(_WORD *)int v90 = v88;
                  v90[1]  = HIDWORD(v88);
                }
                else
                {
                  *(_WORD *)int v90 = *((_WORD *)a2 - 4);
                  v90[1]  = *(a2 - 1);
                  *((_WORD *)a2 - 4)  = v88;
                  *(a2 - 1)  = HIDWORD(v88);
                  uint64_t v95 = (uint64_t)v90 - v10 + 8;
                  if (v95 >= 9)
                  {
                    unint64_t v96 = (((unint64_t)v95 >> 3) - 2) >> 1;
                    unsigned int v97 = *(_DWORD *)(v10 + 8 * v96 + 4);
                    if (v97 < v90[1])
                    {
                      int v98 = *v90;
                      unsigned int v99 = v90[1];
                      do
                      {
                        uint64_t v100 = v90;
                        int v90 = (_DWORD *)(v10 + 8 * v96);
                        *(_WORD *)uint64_t v100 = *(_WORD *)v90;
                        v100[1]  = v97;
                        if (!v96) {
                          break;
                        }
                        unint64_t v96 = (v96 - 1) >> 1;
                        unsigned int v97 = *(_DWORD *)(v10 + 8 * v96 + 4);
                      }
                      while (v97 < v99);
                      *(_WORD *)int v90 = v98;
                      v90[1]  = v99;
                    }
                  }
                }
                a2 -= 2;
              }
              while (v86-- > 2);
            }
            return result;
          }
          unint64_t v13 = v12 >> 1;
          unint64_t v14 = v10 + 8 * (v12 >> 1);
          if ((unint64_t)v11 >= 0x401)
          {
            __int16 v15 = *(_WORD *)v9;
            *(_WORD *)unint64_t v9 = *(_WORD *)v14;
            *(_WORD *)unint64_t v14 = v15;
            int v16 = *(_DWORD *)(v9 + 4);
            *(_DWORD *)(v9 + 4)  = *(_DWORD *)(v14 + 4);
            *(_DWORD *)(v14 + 4)  = v16;
          }
          else
          {
          }
          --a3;
          if ((a4 & 1) != 0 || *(_DWORD *)(v9 - 4) < *(_DWORD *)(v9 + 4)) {
            break;
          }
          uint64_t v33 = *(void *)v9;
          uint64_t v34 = HIDWORD(*(void *)v9);
          if (*(a2 - 1) <= v34)
          {
            unint64_t v37 = v9 + 8;
            do
            {
              unint64_t v10 = v37;
              if (v37 >= (unint64_t)a2) {
                break;
              }
              unsigned int v38 = *(_DWORD *)(v37 + 4);
              v37 += 8;
            }
            while (v38 <= v34);
          }
          else
          {
            unint64_t v35 = v9;
            do
            {
              unint64_t v10 = v35 + 8;
              unsigned int v36 = *(_DWORD *)(v35 + 12);
              v35 += 8;
            }
            while (v36 <= v34);
          }
          uint64_t v39 = a2;
          if (v10 < (unint64_t)a2)
          {
            unint64_t v40 = a2;
            do
            {
              uint64_t v39 = v40 - 2;
              unsigned int v41 = *(v40 - 1);
              v40 -= 2;
            }
            while (v41 > v34);
          }
          while (v10 < (unint64_t)v39)
          {
            __int16 v42 = *(_WORD *)v10;
            *(_WORD *)unint64_t v10 = *(_WORD *)v39;
            *(_WORD *)uint64_t v39 = v42;
            int v43 = *(_DWORD *)(v10 + 4);
            *(_DWORD *)(v10 + 4)  = v39[1];
            v39[1]  = v43;
            do
            {
              unsigned int v44 = *(_DWORD *)(v10 + 12);
              v10 += 8;
            }
            while (v44 <= v34);
            do
            {
              unsigned int v45 = *(v39 - 1);
              v39 -= 2;
            }
            while (v45 > v34);
          }
          BOOL v4 = v10 - 8 >= v9;
          BOOL v5 = v10 - 8 == v9;
          if (v10 - 8 != v9)
          {
            *(_WORD *)unint64_t v9 = *(_WORD *)(v10 - 8);
            *(_DWORD *)(v9 + 4)  = *(_DWORD *)(v10 - 4);
          }
          a4  = 0;
          *(_WORD *)(v10 - 8)  = v33;
          *(_DWORD *)(v10 - 4)  = v34;
        }
        uint64_t v17 = 0;
        uint64_t v18 = *(void *)v9;
        uint64_t v19 = HIDWORD(*(void *)v9);
        do
        {
          unsigned int v20 = *(_DWORD *)(v9 + v17 + 12);
          v17 += 8;
        }
        while (v20 < v19);
        unint64_t v21 = v9 + v17;
        unsigned int v22 = a2;
        if (v17 == 8)
        {
          unsigned int v25 = a2;
          while (v21 < (unint64_t)v25)
          {
            BOOL v23 = v25 - 2;
            unsigned int v26 = *(v25 - 1);
            v25 -= 2;
            if (v26 < v19) {
              goto LABEL_22;
            }
          }
          BOOL v23 = v25;
        }
        else
        {
          do
          {
            BOOL v23 = v22 - 2;
            unsigned int v24 = *(v22 - 1);
            v22 -= 2;
          }
          while (v24 >= v19);
        }
LABEL_22:
        unint64_t v10 = v21;
        if (v21 < (unint64_t)v23)
        {
          unint64_t v27 = (unint64_t)v23;
          do
          {
            __int16 v28 = *(_WORD *)v10;
            *(_WORD *)unint64_t v10 = *(_WORD *)v27;
            *(_WORD *)unint64_t v27 = v28;
            int v29 = *(_DWORD *)(v10 + 4);
            *(_DWORD *)(v10 + 4)  = *(_DWORD *)(v27 + 4);
            *(_DWORD *)(v27 + 4)  = v29;
            do
            {
              unsigned int v30 = *(_DWORD *)(v10 + 12);
              v10 += 8;
            }
            while (v30 < v19);
            do
            {
              unsigned int v31 = *(_DWORD *)(v27 - 4);
              v27 -= 8;
            }
            while (v31 >= v19);
          }
          while (v10 < v27);
        }
        if (v10 - 8 != v9)
        {
          *(_WORD *)unint64_t v9 = *(_WORD *)(v10 - 8);
          *(_DWORD *)(v9 + 4)  = *(_DWORD *)(v10 - 4);
        }
        *(_WORD *)(v10 - 8)  = v18;
        *(_DWORD *)(v10 - 4)  = v19;
        if (v21 >= (unint64_t)v23) {
          break;
        }
LABEL_33:
        a4  = 0;
      }
      if (result) {
        break;
      }
      if (!v32) {
        goto LABEL_33;
      }
    }
    a2  = (_DWORD *)(v10 - 8);
    if (!v32) {
      continue;
    }
    return result;
  }
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_1 &,std::pair<unsigned short,unsigned int> *>(uint64_t a1, _DWORD *a2)
{
  uint64_t v4 = ((uint64_t)a2 - a1) >> 3;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      unsigned int v6 = *(a2 - 1);
      unsigned int v7 = *(_DWORD *)(a1 + 4);
      if (v6 < v7)
      {
        __int16 v8 = *(_WORD *)a1;
        *(_WORD *)a1  = *((_WORD *)a2 - 4);
        *((_WORD *)a2 - 4)  = v8;
        *(_DWORD *)(a1 + 4)  = v6;
        *(a2 - 1)  = v7;
      }
      return result;
    case 3:
      return 1;
    case 4:
      return 1;
    case 5:
      unsigned int v18 = *(a2 - 1);
      unsigned int v19 = *(_DWORD *)(a1 + 28);
      if (v18 < v19)
      {
        __int16 v20 = *(_WORD *)(a1 + 24);
        *(_WORD *)(a1 + 24)  = *((_WORD *)a2 - 4);
        *((_WORD *)a2 - 4)  = v20;
        *(_DWORD *)(a1 + 28)  = v18;
        *(a2 - 1)  = v19;
        unsigned int v21 = *(_DWORD *)(a1 + 28);
        unsigned int v22 = *(_DWORD *)(a1 + 20);
        if (v21 < v22)
        {
          __int16 v23 = *(_WORD *)(a1 + 16);
          __int16 v24 = *(_WORD *)(a1 + 24);
          *(_WORD *)(a1 + 16)  = v24;
          *(_WORD *)(a1 + 24)  = v23;
          *(_DWORD *)(a1 + 20)  = v21;
          *(_DWORD *)(a1 + 28)  = v22;
          unsigned int v25 = *(_DWORD *)(a1 + 12);
          if (v21 < v25)
          {
            __int16 v26 = *(_WORD *)(a1 + 8);
            *(_WORD *)(a1 + 8)  = v24;
            *(_WORD *)(a1 + 16)  = v26;
            *(_DWORD *)(a1 + 12)  = v21;
            *(_DWORD *)(a1 + 20)  = v25;
            unsigned int v27 = *(_DWORD *)(a1 + 4);
            if (v21 < v27)
            {
              __int16 v28 = *(_WORD *)a1;
              *(_WORD *)a1  = v24;
              *(_WORD *)(a1 + 8)  = v28;
              *(_DWORD *)(a1 + 4)  = v21;
              *(_DWORD *)(a1 + 12)  = v27;
            }
          }
        }
      }
      return 1;
    default:
      unint64_t v9 = (_DWORD *)(a1 + 16);
      unint64_t v10 = (_DWORD *)(a1 + 24);
      if ((_DWORD *)(a1 + 24) == a2) {
        return 1;
      }
      uint64_t v11 = 0;
      int v12 = 0;
      break;
  }
  while (1)
  {
    if (v10[1] < v9[1])
    {
      int v13 = *v10;
      unsigned int v14 = v10[1];
      uint64_t v15 = v11;
      while (1)
      {
        uint64_t v16 = a1 + v15;
        *(_WORD *)(v16 + 24)  = *(_WORD *)(a1 + v15 + 16);
        *(_DWORD *)(v16 + 28)  = *(_DWORD *)(a1 + v15 + 20);
        if (v15 == -16) {
          break;
        }
        v15 -= 8;
        if (*(_DWORD *)(v16 + 12) <= v14)
        {
          uint64_t v17 = a1 + v15 + 24;
          goto LABEL_13;
        }
      }
      uint64_t v17 = a1;
LABEL_13:
      *(_WORD *)uint64_t v17 = v13;
      *(_DWORD *)(v17 + 4)  = v14;
      if (++v12 == 8) {
        return v10 + 2 == a2;
      }
    }
    unint64_t v9 = v10;
    v11 += 8;
    v10 += 2;
    if (v10 == a2) {
      return 1;
    }
  }
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_2 &,std::pair<unsigned short,unsigned int> *,false>(uint64_t result, _DWORD *a2, uint64_t a3, char a4)
{
  unint64_t v9 = result;
  while (2)
  {
    unint64_t v10 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          unint64_t v9 = v10;
          uint64_t v11 = (uint64_t)a2 - v10;
          unint64_t v12 = (uint64_t)((uint64_t)a2 - v10) >> 3;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                unsigned int v46 = *(a2 - 1);
                unsigned int v47 = *(_DWORD *)(v10 + 4);
                if (v46 < v47)
                {
                  __int16 v48 = *(_WORD *)v10;
                  *(_WORD *)unint64_t v10 = *((_WORD *)a2 - 4);
                  *((_WORD *)a2 - 4)  = v48;
                  *(_DWORD *)(v10 + 4)  = v46;
                  *(a2 - 1)  = v47;
                }
                break;
              case 3uLL:
                break;
              case 4uLL:
                break;
              case 5uLL:
                unsigned int v49 = *(a2 - 1);
                unsigned int v50 = *(_DWORD *)(v10 + 28);
                if (v49 < v50)
                {
                  __int16 v51 = *(_WORD *)(v10 + 24);
                  *(_WORD *)(v10 + 24)  = *((_WORD *)a2 - 4);
                  *((_WORD *)a2 - 4)  = v51;
                  *(_DWORD *)(v10 + 28)  = v49;
                  *(a2 - 1)  = v50;
                  unsigned int v52 = *(_DWORD *)(v10 + 28);
                  unsigned int v53 = *(_DWORD *)(v10 + 20);
                  if (v52 < v53)
                  {
                    __int16 v54 = *(_WORD *)(v10 + 16);
                    __int16 v55 = *(_WORD *)(v10 + 24);
                    *(_WORD *)(v10 + 16)  = v55;
                    *(_WORD *)(v10 + 24)  = v54;
                    *(_DWORD *)(v10 + 20)  = v52;
                    *(_DWORD *)(v10 + 28)  = v53;
                    unsigned int v56 = *(_DWORD *)(v10 + 12);
                    if (v52 < v56)
                    {
                      __int16 v57 = *(_WORD *)(v10 + 8);
                      *(_WORD *)(v10 + 8)  = v55;
                      *(_WORD *)(v10 + 16)  = v57;
                      *(_DWORD *)(v10 + 12)  = v52;
                      *(_DWORD *)(v10 + 20)  = v56;
                      unsigned int v58 = *(_DWORD *)(v10 + 4);
                      if (v52 < v58)
                      {
                        __int16 v59 = *(_WORD *)v10;
                        *(_WORD *)unint64_t v10 = v55;
                        *(_WORD *)(v10 + 8)  = v59;
                        *(_DWORD *)(v10 + 4)  = v52;
                        *(_DWORD *)(v10 + 12)  = v58;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v11 <= 191)
          {
            int v60 = (_DWORD *)(v10 + 8);
            BOOL v62 = (_DWORD *)v10 == a2 || v60 == a2;
            if (a4)
            {
              if (!v62)
              {
                uint64_t v63 = 0;
                __int16 v64 = (_DWORD *)v10;
                do
                {
                  unsigned int v65 = v64[3];
                  unsigned int v66 = v64[1];
                  __int16 v64 = v60;
                  if (v65 < v66)
                  {
                    int v67 = *v60;
                    unsigned int v68 = v64[1];
                    uint64_t v69 = v63;
                    while (1)
                    {
                      uint64_t v70 = v10 + v69;
                      *(_WORD *)(v70 + 8)  = *(_WORD *)(v10 + v69);
                      *(_DWORD *)(v70 + 12)  = *(_DWORD *)(v10 + v69 + 4);
                      if (!v69) {
                        break;
                      }
                      v69 -= 8;
                      if (*(_DWORD *)(v70 - 4) <= v68)
                      {
                        uint64_t v71 = v10 + v69 + 8;
                        goto LABEL_83;
                      }
                    }
                    uint64_t v71 = v10;
LABEL_83:
                    *(_WORD *)uint64_t v71 = v67;
                    *(_DWORD *)(v71 + 4)  = v68;
                  }
                  int v60 = v64 + 2;
                  v63 += 8;
                }
                while (v64 + 2 != a2);
              }
            }
            else if (!v62)
            {
              unsigned int v102 = (_DWORD *)(v10 + 12);
              do
              {
                unsigned int v103 = *(_DWORD *)(v9 + 12);
                unsigned int v104 = *(_DWORD *)(v9 + 4);
                unint64_t v9 = (unint64_t)v60;
                if (v103 < v104)
                {
                  uint64_t v105 = *(void *)v60;
                  uint64_t v106 = HIDWORD(*(void *)v9);
                  uint64_t v107 = v102;
                  do
                  {
                    unint64_t v108 = v107;
                    *((_WORD *)v107 - 2)  = *((_WORD *)v107 - 6);
                    int v109 = *(v107 - 2);
                    v107 -= 2;
                    *unint64_t v108 = v109;
                  }
                  while (*(v108 - 4) > v106);
                  *((_WORD *)v107 - 2)  = v105;
                  _DWORD *v107 = v106;
                }
                int v60 = (_DWORD *)(v9 + 8);
                v102 += 2;
              }
              while ((_DWORD *)(v9 + 8) != a2);
            }
            return result;
          }
          if (!a3)
          {
            if ((_DWORD *)v10 != a2)
            {
              int64_t v72 = (v12 - 2) >> 1;
              int64_t v73 = v72;
              do
              {
                int64_t v74 = v73;
                if (v72 >= v73)
                {
                  uint64_t v75 = (2 * v73) | 1;
                  unsigned int v76 = (int *)(v10 + 8 * v75);
                  if (2 * v74 + 2 < (uint64_t)v12)
                  {
                    unsigned int v77 = v76[1];
                    unsigned int v78 = v76[3];
                    v76 += 2 * (v77 < v78);
                    if (v77 < v78) {
                      uint64_t v75 = 2 * v74 + 2;
                    }
                  }
                  unsigned int v79 = v76[1];
                  if (v79 >= *(_DWORD *)(v10 + 8 * v74 + 4))
                  {
                    long long v80 = (int *)(v10 + 8 * v74);
                    int v81 = *v80;
                    unsigned int v82 = v80[1];
                    do
                    {
                      BOOL result = (uint64_t)v80;
                      long long v80 = v76;
                      *(_WORD *)BOOL result = *(_WORD *)v76;
                      *(_DWORD *)(result + 4)  = v79;
                      if (v72 < v75) {
                        break;
                      }
                      BOOL result = (2 * v75) | 1;
                      unsigned int v76 = (int *)(v10 + 8 * result);
                      uint64_t v83 = 2 * v75 + 2;
                      if (v83 < (uint64_t)v12)
                      {
                        unsigned int v84 = v76[1];
                        unsigned int v85 = v76[3];
                        v76 += 2 * (v84 < v85);
                        if (v84 < v85) {
                          BOOL result = v83;
                        }
                      }
                      unsigned int v79 = v76[1];
                      uint64_t v75 = result;
                    }
                    while (v79 >= v82);
                    *(_WORD *)long long v80 = v81;
                    v80[1]  = v82;
                  }
                }
                int64_t v73 = v74 - 1;
              }
              while (v74);
              uint64_t v86 = (unint64_t)v11 >> 3;
              do
              {
                uint64_t v87 = 0;
                uint64_t v88 = *(void *)v10;
                unint64_t v89 = v10;
                do
                {
                  int v90 = (_DWORD *)(v89 + 8 * (v87 + 1));
                  uint64_t v91 = (2 * v87) | 1;
                  uint64_t v92 = 2 * v87 + 2;
                  if (v92 < v86)
                  {
                    unsigned int v93 = v90[1];
                    unsigned int v94 = v90[3];
                    v90 += 2 * (v93 < v94);
                    if (v93 < v94) {
                      uint64_t v91 = v92;
                    }
                  }
                  *(_WORD *)unint64_t v89 = *(_WORD *)v90;
                  *(_DWORD *)(v89 + 4)  = v90[1];
                  unint64_t v89 = (unint64_t)v90;
                  uint64_t v87 = v91;
                }
                while (v91 <= (uint64_t)((unint64_t)(v86 - 2) >> 1));
                if (v90 == a2 - 2)
                {
                  *(_WORD *)int v90 = v88;
                  v90[1]  = HIDWORD(v88);
                }
                else
                {
                  *(_WORD *)int v90 = *((_WORD *)a2 - 4);
                  v90[1]  = *(a2 - 1);
                  *((_WORD *)a2 - 4)  = v88;
                  *(a2 - 1)  = HIDWORD(v88);
                  uint64_t v95 = (uint64_t)v90 - v10 + 8;
                  if (v95 >= 9)
                  {
                    unint64_t v96 = (((unint64_t)v95 >> 3) - 2) >> 1;
                    unsigned int v97 = *(_DWORD *)(v10 + 8 * v96 + 4);
                    if (v97 < v90[1])
                    {
                      int v98 = *v90;
                      unsigned int v99 = v90[1];
                      do
                      {
                        uint64_t v100 = v90;
                        int v90 = (_DWORD *)(v10 + 8 * v96);
                        *(_WORD *)uint64_t v100 = *(_WORD *)v90;
                        v100[1]  = v97;
                        if (!v96) {
                          break;
                        }
                        unint64_t v96 = (v96 - 1) >> 1;
                        unsigned int v97 = *(_DWORD *)(v10 + 8 * v96 + 4);
                      }
                      while (v97 < v99);
                      *(_WORD *)int v90 = v98;
                      v90[1]  = v99;
                    }
                  }
                }
                a2 -= 2;
              }
              while (v86-- > 2);
            }
            return result;
          }
          unint64_t v13 = v12 >> 1;
          unint64_t v14 = v10 + 8 * (v12 >> 1);
          if ((unint64_t)v11 >= 0x401)
          {
            __int16 v15 = *(_WORD *)v9;
            *(_WORD *)unint64_t v9 = *(_WORD *)v14;
            *(_WORD *)unint64_t v14 = v15;
            int v16 = *(_DWORD *)(v9 + 4);
            *(_DWORD *)(v9 + 4)  = *(_DWORD *)(v14 + 4);
            *(_DWORD *)(v14 + 4)  = v16;
          }
          else
          {
          }
          --a3;
          if ((a4 & 1) != 0 || *(_DWORD *)(v9 - 4) < *(_DWORD *)(v9 + 4)) {
            break;
          }
          uint64_t v33 = *(void *)v9;
          uint64_t v34 = HIDWORD(*(void *)v9);
          if (*(a2 - 1) <= v34)
          {
            unint64_t v37 = v9 + 8;
            do
            {
              unint64_t v10 = v37;
              if (v37 >= (unint64_t)a2) {
                break;
              }
              unsigned int v38 = *(_DWORD *)(v37 + 4);
              v37 += 8;
            }
            while (v38 <= v34);
          }
          else
          {
            unint64_t v35 = v9;
            do
            {
              unint64_t v10 = v35 + 8;
              unsigned int v36 = *(_DWORD *)(v35 + 12);
              v35 += 8;
            }
            while (v36 <= v34);
          }
          uint64_t v39 = a2;
          if (v10 < (unint64_t)a2)
          {
            unint64_t v40 = a2;
            do
            {
              uint64_t v39 = v40 - 2;
              unsigned int v41 = *(v40 - 1);
              v40 -= 2;
            }
            while (v41 > v34);
          }
          while (v10 < (unint64_t)v39)
          {
            __int16 v42 = *(_WORD *)v10;
            *(_WORD *)unint64_t v10 = *(_WORD *)v39;
            *(_WORD *)uint64_t v39 = v42;
            int v43 = *(_DWORD *)(v10 + 4);
            *(_DWORD *)(v10 + 4)  = v39[1];
            v39[1]  = v43;
            do
            {
              unsigned int v44 = *(_DWORD *)(v10 + 12);
              v10 += 8;
            }
            while (v44 <= v34);
            do
            {
              unsigned int v45 = *(v39 - 1);
              v39 -= 2;
            }
            while (v45 > v34);
          }
          BOOL v4 = v10 - 8 >= v9;
          BOOL v5 = v10 - 8 == v9;
          if (v10 - 8 != v9)
          {
            *(_WORD *)unint64_t v9 = *(_WORD *)(v10 - 8);
            *(_DWORD *)(v9 + 4)  = *(_DWORD *)(v10 - 4);
          }
          a4  = 0;
          *(_WORD *)(v10 - 8)  = v33;
          *(_DWORD *)(v10 - 4)  = v34;
        }
        uint64_t v17 = 0;
        uint64_t v18 = *(void *)v9;
        uint64_t v19 = HIDWORD(*(void *)v9);
        do
        {
          unsigned int v20 = *(_DWORD *)(v9 + v17 + 12);
          v17 += 8;
        }
        while (v20 < v19);
        unint64_t v21 = v9 + v17;
        unsigned int v22 = a2;
        if (v17 == 8)
        {
          unsigned int v25 = a2;
          while (v21 < (unint64_t)v25)
          {
            __int16 v23 = v25 - 2;
            unsigned int v26 = *(v25 - 1);
            v25 -= 2;
            if (v26 < v19) {
              goto LABEL_22;
            }
          }
          __int16 v23 = v25;
        }
        else
        {
          do
          {
            __int16 v23 = v22 - 2;
            unsigned int v24 = *(v22 - 1);
            v22 -= 2;
          }
          while (v24 >= v19);
        }
LABEL_22:
        unint64_t v10 = v21;
        if (v21 < (unint64_t)v23)
        {
          unint64_t v27 = (unint64_t)v23;
          do
          {
            __int16 v28 = *(_WORD *)v10;
            *(_WORD *)unint64_t v10 = *(_WORD *)v27;
            *(_WORD *)unint64_t v27 = v28;
            int v29 = *(_DWORD *)(v10 + 4);
            *(_DWORD *)(v10 + 4)  = *(_DWORD *)(v27 + 4);
            *(_DWORD *)(v27 + 4)  = v29;
            do
            {
              unsigned int v30 = *(_DWORD *)(v10 + 12);
              v10 += 8;
            }
            while (v30 < v19);
            do
            {
              unsigned int v31 = *(_DWORD *)(v27 - 4);
              v27 -= 8;
            }
            while (v31 >= v19);
          }
          while (v10 < v27);
        }
        if (v10 - 8 != v9)
        {
          *(_WORD *)unint64_t v9 = *(_WORD *)(v10 - 8);
          *(_DWORD *)(v9 + 4)  = *(_DWORD *)(v10 - 4);
        }
        *(_WORD *)(v10 - 8)  = v18;
        *(_DWORD *)(v10 - 4)  = v19;
        if (v21 >= (unint64_t)v23) {
          break;
        }
LABEL_33:
        a4  = 0;
      }
      if (result) {
        break;
      }
      if (!v32) {
        goto LABEL_33;
      }
    }
    a2  = (_DWORD *)(v10 - 8);
    if (!v32) {
      continue;
    }
    return result;
  }
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,anonymous namespace'::MorxContextualSubtableBuilder::FromSubstitution(long,unsigned int,unsigned int,TInlineVector<std::vector<unsigned short>,30ul> const&,TInlineVector<std::vector<unsigned short>,30ul> const&,__CFData const*,std::vector<unsigned short> const&)::$_2 &,std::pair<unsigned short,unsigned int> *>(uint64_t a1, _DWORD *a2)
{
  uint64_t v4 = ((uint64_t)a2 - a1) >> 3;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      unsigned int v6 = *(a2 - 1);
      unsigned int v7 = *(_DWORD *)(a1 + 4);
      if (v6 < v7)
      {
        __int16 v8 = *(_WORD *)a1;
        *(_WORD *)a1  = *((_WORD *)a2 - 4);
        *((_WORD *)a2 - 4)  = v8;
        *(_DWORD *)(a1 + 4)  = v6;
        *(a2 - 1)  = v7;
      }
      return result;
    case 3:
      return 1;
    case 4:
      return 1;
    case 5:
      unsigned int v18 = *(a2 - 1);
      unsigned int v19 = *(_DWORD *)(a1 + 28);
      if (v18 < v19)
      {
        __int16 v20 = *(_WORD *)(a1 + 24);
        *(_WORD *)(a1 + 24)  = *((_WORD *)a2 - 4);
        *((_WORD *)a2 - 4)  = v20;
        *(_DWORD *)(a1 + 28)  = v18;
        *(a2 - 1)  = v19;
        unsigned int v21 = *(_DWORD *)(a1 + 28);
        unsigned int v22 = *(_DWORD *)(a1 + 20);
        if (v21 < v22)
        {
          __int16 v23 = *(_WORD *)(a1 + 16);
          __int16 v24 = *(_WORD *)(a1 + 24);
          *(_WORD *)(a1 + 16)  = v24;
          *(_WORD *)(a1 + 24)  = v23;
          *(_DWORD *)(a1 + 20)  = v21;
          *(_DWORD *)(a1 + 28)  = v22;
          unsigned int v25 = *(_DWORD *)(a1 + 12);
          if (v21 < v25)
          {
            __int16 v26 = *(_WORD *)(a1 + 8);
            *(_WORD *)(a1 + 8)  = v24;
            *(_WORD *)(a1 + 16)  = v26;
            *(_DWORD *)(a1 + 12)  = v21;
            *(_DWORD *)(a1 + 20)  = v25;
            unsigned int v27 = *(_DWORD *)(a1 + 4);
            if (v21 < v27)
            {
              __int16 v28 = *(_WORD *)a1;
              *(_WORD *)a1  = v24;
              *(_WORD *)(a1 + 8)  = v28;
              *(_DWORD *)(a1 + 4)  = v21;
              *(_DWORD *)(a1 + 12)  = v27;
            }
          }
        }
      }
      return 1;
    default:
      unint64_t v9 = (_DWORD *)(a1 + 16);
      unint64_t v10 = (_DWORD *)(a1 + 24);
      if ((_DWORD *)(a1 + 24) == a2) {
        return 1;
      }
      uint64_t v11 = 0;
      int v12 = 0;
      break;
  }
  while (1)
  {
    if (v10[1] < v9[1])
    {
      int v13 = *v10;
      unsigned int v14 = v10[1];
      uint64_t v15 = v11;
      while (1)
      {
        uint64_t v16 = a1 + v15;
        *(_WORD *)(v16 + 24)  = *(_WORD *)(a1 + v15 + 16);
        *(_DWORD *)(v16 + 28)  = *(_DWORD *)(a1 + v15 + 20);
        if (v15 == -16) {
          break;
        }
        v15 -= 8;
        if (*(_DWORD *)(v16 + 12) <= v14)
        {
          uint64_t v17 = a1 + v15 + 24;
          goto LABEL_13;
        }
      }
      uint64_t v17 = a1;
LABEL_13:
      *(_WORD *)uint64_t v17 = v13;
      *(_DWORD *)(v17 + 4)  = v14;
      if (++v12 == 8) {
        return v10 + 2 == a2;
      }
    }
    unint64_t v9 = v10;
    v11 += 8;
    v10 += 2;
    if (v10 == a2) {
      return 1;
    }
  }
}

void std::__function::__func<anonymous namespace'::MorxStateTableSubtableBuilder<STXEntryTwo>::PopulateBitmap(long)::{lambda(unsigned short,unsigned short,unsigned short)#1},std::allocator<anonymous namespace'::MorxStateTableSubtableBuilder<STXEntryTwo>::PopulateBitmap(long)::{lambda(unsigned short,unsigned short,unsigned short)#1}>,void ()(unsigned short,unsigned short,unsigned short)>::~__func()
{
}

__n128 std::__function::__func<anonymous namespace'::MorxStateTableSubtableBuilder<STXEntryTwo>::PopulateBitmap(long)::{lambda(unsigned short,unsigned short,unsigned short)#1},std::allocator<anonymous namespace'::MorxStateTableSubtableBuilder<STXEntryTwo>::PopulateBitmap(long)::{lambda(unsigned short,unsigned short,unsigned short)#1}>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_1ED060C98;
  *(_OWORD *)(v2 + 8)  = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24)  = result;
  return result;
}

__n128 std::__function::__func<anonymous namespace'::MorxStateTableSubtableBuilder<STXEntryTwo>::PopulateBitmap(long)::{lambda(unsigned short,unsigned short,unsigned short)#1},std::allocator<anonymous namespace'::MorxStateTableSubtableBuilder<STXEntryTwo>::PopulateBitmap(long)::{lambda(unsigned short,unsigned short,unsigned short)#1}>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2  = &unk_1ED060C98;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24)  = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8)  = result;
  return result;
}

uint64_t std::__function::__func<anonymous namespace'::MorxStateTableSubtableBuilder<STXEntryTwo>::PopulateBitmap(long)::{lambda(unsigned short,unsigned short,unsigned short)#1},std::allocator<anonymous namespace'::MorxStateTableSubtableBuilder<STXEntryTwo>::PopulateBitmap(long)::{lambda(unsigned short,unsigned short,unsigned short)#1}>,void ()(unsigned short,unsigned short,unsigned short)>::operator()(uint64_t result, unsigned __int16 *a2, unsigned __int16 *a3, unsigned __int16 *a4)
{
  uint64_t v4 = *(_DWORD **)(result + 8);
  if (v4[6] > *a4)
  {
    uint64_t v5 = result;
    unsigned int v6 = *a2;
    unsigned int v7 = *a3;
    __n128 result = (*(uint64_t (**)(void, void, void))(*(void *)v4 + 16))(*(void *)(result + 8), 0, *a4);
    if (result)
    {
      if (v6 <= v7 && v6 != (unsigned __int16)(v7 + 1))
      {
        do
        {
          if (*(_DWORD *)(v5 + 16) > (unsigned __int16)v6) {
            *(unsigned char *)(*(void *)(v5 + 24) + ((unsigned __int16)v6 >> 3)) |= 1 << (v6 & 7);
          }
          BOOL v8 = v7 == (unsigned __int16)v6;
          LOWORD(v6)  = v6 + 1;
        }
        while (!v8);
      }
    }
    else if (*(_WORD *)(v5 + 32))
    {
      __n128 result = (*(uint64_t (**)(_DWORD *))(*(void *)v4 + 16))(v4);
      BOOL v9 = !result || v6 > v7;
      if (!v9 && v6 != (unsigned __int16)(v7 + 1))
      {
        do
        {
          if (*(_DWORD *)(v5 + 16) > (unsigned __int16)v6) {
            *(unsigned char *)(*(void *)(v5 + 24) + ((unsigned __int16)v6 >> 3)) |= 1 << (v6 & 7);
          }
          BOOL v8 = v7 == (unsigned __int16)v6;
          LOWORD(v6)  = v6 + 1;
        }
        while (!v8);
      }
    }
  }
  return result;
}

uint64_t anonymous namespace'::MorxContextualSubtableBuilder::PrepareArabicStateTable(uint64_t a1, uint64_t a2, int64_t a3, unsigned __int16 ***a4, unsigned __int16 **a5)
{
  BOOL v9 = NewLKTHandle(a3, 1);
  if (qword_1EB2CE888 != -1) {
  long long __p = 0;
  }
  unsigned int v65 = 0;
  uint64_t v66 = 0;
  std::vector<unsigned short>::reserve(&__p, qword_1EB2CE880);
  unint64_t v10 = (uint64_t)(*((void *)&_MergedGlobals_32 + 1) - _MergedGlobals_32) >> 1;
  std::vector<unsigned short>::resize((uint64_t)&__p, v10);
  (*(void (**)(uint64_t, void, void *, unint64_t))(*(void *)a2 + 664))(a2, _MergedGlobals_32, __p, v10);
  uint64_t v11 = __p;
  int v12 = v65;
  while (v11 != v12)
  {
    if (*v11) {
      LKTAddRange(v9, (unsigned __int16)*v11, (unsigned __int16)*v11, 4);
    }
    ++v11;
  }
  unint64_t v13 = (unk_1EB2CE858 - qword_1EB2CE850) >> 1;
  std::vector<unsigned short>::resize((uint64_t)&__p, v13);
  (*(void (**)(uint64_t, uint64_t, void *, unint64_t))(*(void *)a2 + 664))(a2, qword_1EB2CE850, __p, v13);
  unsigned int v14 = __p;
  uint64_t v15 = v65;
  while (v14 != v15)
  {
    if (*v14) {
      LKTAddRange(v9, (unsigned __int16)*v14, (unsigned __int16)*v14, 5);
    }
    ++v14;
  }
  unint64_t v16 = (unk_1EB2CE870 - qword_1EB2CE868) >> 1;
  std::vector<unsigned short>::resize((uint64_t)&__p, v16);
  (*(void (**)(uint64_t, uint64_t, void *, unint64_t))(*(void *)a2 + 664))(a2, qword_1EB2CE868, __p, v16);
  uint64_t v17 = __p;
  unsigned int v18 = v65;
  while (v17 != v18)
  {
    if (*v17) {
      LKTAddRange(v9, (unsigned __int16)*v17, (unsigned __int16)*v17, 6);
    }
    ++v17;
  }
  LODWORD(v67[0])  = 537724480;
  std::vector<unsigned short>::resize((uint64_t)&__p, 2uLL);
  (*(void (**)(uint64_t, id *, void *, uint64_t))(*(void *)a2 + 664))(a2, v67, __p, 2);
  unsigned int v19 = __p;
  __int16 v20 = v65;
  while (v19 != v20)
  {
    if (*v19) {
      LKTAddRange(v9, (unsigned __int16)*v19, (unsigned __int16)*v19, 7);
    }
    ++v19;
  }
  unsigned int v21 = *a4;
  unsigned int v22 = a4[1];
  while (v21 != v22)
  {
    unsigned __int16 v23 = LKTGetValue(v9, **v21);
    __int16 v24 = *v21;
    unsigned int v25 = v21[1];
    if (*v21 != v25)
    {
      unsigned __int16 v26 = v23;
      char v27 = 0;
      do
      {
        while (1)
        {
          uint64_t v28 = LKTGetValue(v9, *v24);
          if ((v27 & ((v28 & 0xFF0000) == 0)) != 0) {
            goto LABEL_45;
          }
          if ((v28 & 0xFF0000) == 0) {
            break;
          }
          if ((unsigned __int16)v28 != v26 && (unsigned __int16)v28 != 6) {
            goto LABEL_45;
          }
          ++v24;
          char v27 = 1;
          if (v24 == v25) {
            goto LABEL_39;
          }
        }
        ++v24;
      }
      while (v24 != v25);
      if (v27) {
LABEL_39:
      }
        LKTAddRange(v9, *((unsigned __int16 *)v21 + 20), *((unsigned __int16 *)v21 + 20), v26);
    }
    v21 += 6;
  }
  unsigned int v31 = *a5;
  unsigned int v30 = a5[1];
  while (v31 != v30)
  {
    if ((LKTGetValue(v9, *v31) & 0x10000) != 0)
    {
LABEL_45:
      uint64_t v32 = 0;
      goto LABEL_87;
    }
    ++v31;
  }
  *(_DWORD *)(a1 + 24)  = 8;
  LKTCreateLookupTable(v9, (atomic_ullong *)v67);

  DisposeLKTHandle(v9);
  uint64_t v33 = 0;
  uint64_t v34 = *(char **)(a1 + 48);
  do
  {
    __int16 v35 = word_184BA915C[v33] - 1;
    unint64_t v36 = *(void *)(a1 + 56);
    if ((unint64_t)v34 >= v36)
    {
      unint64_t v37 = *(char **)(a1 + 40);
      uint64_t v38 = v34 - v37;
      if (v34 - v37 <= -3) {
        goto LABEL_90;
      }
      uint64_t v39 = v38 >> 1;
      unint64_t v40 = v36 - (void)v37;
      if (v40 <= (v38 >> 1) + 1) {
        unint64_t v41 = v39 + 1;
      }
      else {
        unint64_t v41 = v40;
      }
      if (v40 >= 0x7FFFFFFFFFFFFFFELL) {
        uint64_t v42 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v42 = v41;
      }
      v67[4]  = (id)(a1 + 64);
      if (v42)
      {
        int v43 = (char *)TInlineBufferAllocator<unsigned short,30ul>::allocate(a1 + 64, v42);
        unint64_t v37 = *(char **)(a1 + 40);
        uint64_t v34 = *(char **)(a1 + 48);
      }
      else
      {
        int v43 = 0;
      }
      unsigned int v44 = &v43[2 * v39];
      *(_WORD *)unsigned int v44 = v35;
      if (v34 == v37)
      {
        unsigned int v46 = &v43[2 * v39];
      }
      else
      {
        unsigned int v45 = v34;
        unsigned int v46 = &v43[2 * v39];
        do
        {
          __int16 v47 = *((_WORD *)v45 - 1);
          v45 -= 2;
          *((_WORD *)v46 - 1)  = v47;
          v46 -= 2;
        }
        while (v45 != v37);
      }
      __int16 v48 = v44 + 2;
      *(void *)(a1 + 40)  = v46;
      *(void *)(a1 + 48)  = v44 + 2;
      unsigned int v49 = *(void **)(a1 + 56);
      *(void *)(a1 + 56)  = &v43[2 * v42];
      v67[2]  = v34;
      v67[3]  = v49;
      v67[0]  = v37;
      v67[1]  = v37;
      std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,30ul> &>::~__split_buffer((uint64_t)v67);
      uint64_t v34 = v48;
    }
    else
    {
      *(_WORD *)uint64_t v34 = v35;
      v34 += 2;
    }
    *(void *)(a1 + 48)  = v34;
    ++v33;
  }
  while (v33 != 48);
  unsigned int v50 = *(char **)(a1 + 136);
  uint64_t v51 = *(void *)(a1 + 152);
  uint64_t v52 = v51 - (void)v50;
  if ((unint64_t)(v51 - (void)v50) >= 0x78)
  {
    unsigned int v56 = *(char **)(a1 + 144);
    __int16 v55 = (void **)(a1 + 144);
    __int16 v54 = v56;
    size_t v57 = v56 - v50;
    if ((unint64_t)(v56 - v50) > 0x77)
    {
      *((void *)v50 + 14)  = 0xFFFF000300000000;
      *((_OWORD *)v50 + 4)  = xmmword_184BA91FC;
      *((_OWORD *)v50 + 5)  = unk_184BA920C;
      *((_OWORD *)v50 + 6)  = xmmword_184BA921C;
      *(_OWORD *)unsigned int v50 = xmmword_184BA91BC;
      *((_OWORD *)v50 + 1)  = unk_184BA91CC;
      uint64_t v60 = 15;
      *((_OWORD *)v50 + 2)  = xmmword_184BA91DC;
      *((_OWORD *)v50 + 3)  = unk_184BA91EC;
    }
    else
    {
      unsigned int v58 = (char *)&xmmword_184BA91BC + v57;
      if (v54 != v50)
      {
        memcpy(v50, &xmmword_184BA91BC, v57);
        unsigned int v50 = (char *)*v55;
      }
      size_t v59 = 120 - v57;
      memcpy(v50, v58, v59);
      uint64_t v60 = v59 >> 3;
    }
  }
  else
  {
    if (v50)
    {
      *(void *)(a1 + 144)  = v50;
      if (a1 + 160 > (unint64_t)v50 || (unsigned int v53 = (void **)(a1 + 400), a1 + 400 <= (unint64_t)v50))
      {
        operator delete(v50);
      }
      else if (&v50[v52] == *v53)
      {
        unsigned __int16 *v53 = v50;
      }
      uint64_t v51 = 0;
      *(void *)(a1 + 136)  = 0;
      *(void *)(a1 + 144)  = 0;
      *(void *)(a1 + 152)  = 0;
    }
    uint64_t v61 = v51 >> 2;
    if ((unint64_t)(v51 >> 2) <= 0xF) {
      uint64_t v61 = 15;
    }
    if ((unint64_t)v51 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v62 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v62 = v61;
    }
    if (v62 >> 61) {
LABEL_90:
    }
      abort();
    unsigned int v50 = (char *)TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate(a1 + 160, v62);
    *(void *)(a1 + 136)  = v50;
    *(void *)(a1 + 152)  = &v50[8 * v62];
    __int16 v55 = (void **)(a1 + 144);
    *((void *)v50 + 14)  = 0xFFFF000300000000;
    *(_OWORD *)unsigned int v50 = xmmword_184BA91BC;
    *((_OWORD *)v50 + 1)  = unk_184BA91CC;
    *((_OWORD *)v50 + 6)  = xmmword_184BA921C;
    *((_OWORD *)v50 + 4)  = xmmword_184BA91FC;
    *((_OWORD *)v50 + 5)  = unk_184BA920C;
    uint64_t v60 = 15;
    *((_OWORD *)v50 + 2)  = xmmword_184BA91DC;
    *((_OWORD *)v50 + 3)  = unk_184BA91EC;
  }
  char *v55 = &v50[8 * v60];
  uint64_t v32 = 1;
LABEL_87:
  if (__p)
  {
    unsigned int v65 = __p;
    operator delete(__p);
  }
  return v32;
}

char **TInlineVector<anonymous namespace'::LigInput,30ul>::TInlineVector(char **a1, uint64_t a2, uint64_t a3)
{
  *a1  = 0;
  a1[1]  = 0;
  uint64_t v4 = (uint64_t)(a1 + 3);
  a1[2]  = 0;
  a1[183]  = (char *)v4;
  if (a3 != a2)
  {
    unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((a3 - a2) >> 4);
    if (v6 >= 0x555555555555556) {
      abort();
    }
    *a1  = v8;
    a1[1]  = v8;
    a1[2]  = &v8[48 * v9];
  }
  return a1;
}

uint64_t anonymous namespace'::MorxContextualSubtableBuilder::BuildArabicSubtableData(atomic_ullong *this, const __CFData *a2, const __CFData *a3, const __CFData *a4, const __CFData *a5)
{
  if (a2) {
    BOOL v5 = a3 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  BOOL v7 = v5 || a4 == 0 || a5 == 0;
  int v8 = v7;
  if (!v7)
  {
    id Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
    CFDataRef explicit = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
    *(_DWORD *)bytes  = 0x10000000;
    CFDataAppendBytes(explicit, bytes, 4);
    unsigned int v15 = CFDataGetLength(a2) + 16;
    unint64_t v16 = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
    *(_DWORD *)bytes  = bswap32(v15);
    CFDataAppendBytes(v16, bytes, 4);
    unsigned int v17 = v15 + CFDataGetLength(a3);
    unsigned int v18 = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
    *(_DWORD *)bytes  = bswap32(v17);
    CFDataAppendBytes(v18, bytes, 4);
    unsigned int v19 = v17 + CFDataGetLength(a4);
    __int16 v20 = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
    *(_DWORD *)bytes  = bswap32(v19);
    CFDataAppendBytes(v20, bytes, 4);
  }
  return v8 ^ 1u;
}

void std::vector<unsigned short>::reserve(void **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 1)
  {
    if ((a2 & 0x8000000000000000) != 0) {
      abort();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    unint64_t v6 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned short>>(v3, a2);
    BOOL v7 = &v6[v5 & 0xFFFFFFFFFFFFFFFELL];
    uint64_t v9 = &v6[2 * v8];
    unint64_t v10 = (char *)*a1;
    uint64_t v11 = (char *)a1[1];
    int v12 = v7;
    if (v11 != *a1)
    {
      int v12 = v7;
      do
      {
        __int16 v13 = *((_WORD *)v11 - 1);
        v11 -= 2;
        *((_WORD *)v12 - 1)  = v13;
        v12 -= 2;
      }
      while (v11 != v10);
    }
    *a1  = v12;
    a1[1]  = v7;
    a1[2]  = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

void anonymous namespace'::MorxContextualSubtableBuilder::PrepareArabicStateTable(TBaseFont const&,long,TInlineVector<anonymous namespace'::LigInput,30ul>,TInlineVector const&<unsigned short,30ul>)::$_0::__invoke()
{
  ArabicCharactersWithJoiningType(v0, "Dual_Joining");
}

void ArabicCharactersWithJoiningType(const char *a1, const char *a2)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  int v3 = 0;
  __s  = (char *)0xAAAAAAAAAAAAAAAALL;
  asprintf(&__s, "[[[:block=Arabic:][:block=Arabic_Supplement:][:block=Arabic_Extended_A:][:Bidi_Control:]]&[:Joining_Type=%s:]]", a2);
  strlen(__s);
  operator new[]();
}

void std::__function::__func<ArabicCharactersWithJoiningType(char const*)::$_0,std::allocator<ArabicCharactersWithJoiningType(char const*)::$_0>,void ()(unsigned int,unsigned int)>::~__func()
{
}

void *std::__function::__func<ArabicCharactersWithJoiningType(char const*)::$_0,std::allocator<ArabicCharactersWithJoiningType(char const*)::$_0>,void ()(unsigned int,unsigned int)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1ED0606B0;
  result[1]  = v3;
  return result;
}

uint64_t std::__function::__func<ArabicCharactersWithJoiningType(char const*)::$_0,std::allocator<ArabicCharactersWithJoiningType(char const*)::$_0>,void ()(unsigned int,unsigned int)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2  = &unk_1ED0606B0;
  a2[1]  = v2;
  return result;
}

void std::__function::__func<ArabicCharactersWithJoiningType(char const*)::$_0,std::allocator<ArabicCharactersWithJoiningType(char const*)::$_0>,void ()(unsigned int,unsigned int)>::operator()(uint64_t a1, int *a2, int *a3)
{
  int v3 = *a2;
  int v4 = *a3;
  if (HIWORD(*a2)) {
    BOOL v5 = 1;
  }
  else {
    BOOL v5 = v3 == v4;
  }
  if (!v5)
  {
    do
    {
      uint64_t v7 = *(void *)(a1 + 8);
      uint64_t v8 = *(_WORD **)(v7 + 8);
      unint64_t v9 = *(void *)(v7 + 16);
      if ((unint64_t)v8 >= v9)
      {
        uint64_t v11 = *(_WORD **)v7;
        uint64_t v12 = (uint64_t)v8 - *(void *)v7;
        if (v12 <= -3) {
          abort();
        }
        uint64_t v13 = v12 >> 1;
        unint64_t v14 = v9 - (void)v11;
        if (v14 <= (v12 >> 1) + 1) {
          unint64_t v15 = v13 + 1;
        }
        else {
          unint64_t v15 = v14;
        }
        if (v14 >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v16 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v16 = v15;
        }
        if (v16)
        {
          unsigned int v17 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned short>>(v7 + 16, v16);
          uint64_t v11 = *(_WORD **)v7;
          uint64_t v8 = *(_WORD **)(v7 + 8);
        }
        else
        {
          unsigned int v17 = 0;
        }
        unsigned int v18 = &v17[2 * v13];
        *(_WORD *)unsigned int v18 = v3;
        unint64_t v10 = v18 + 2;
        while (v8 != v11)
        {
          __int16 v19 = *--v8;
          *((_WORD *)v18 - 1)  = v19;
          v18 -= 2;
        }
        *(void *)uint64_t v7 = v18;
        *(void *)(v7 + 8)  = v10;
        *(void *)(v7 + 16)  = &v17[2 * v16];
        if (v11) {
          operator delete(v11);
        }
      }
      else
      {
        *uint64_t v8 = v3;
        unint64_t v10 = v8 + 1;
      }
      *(void *)(v7 + 8)  = v10;
      ++v3;
    }
    while (v3 != v4);
  }
}

void *std::__function::__func<anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_0,std::allocator<anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_0>,BOOL ()(unsigned short)>::~__func(void *a1)
{
  *a1  = &unk_1ED060BC0;
  uint64_t v2 = (void *)a1[1];
  if (v2)
  {
    a1[2]  = v2;
    operator delete(v2);
  }
  return a1;
}

void std::__function::__func<anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_0,std::allocator<anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_0>,BOOL ()(unsigned short)>::~__func(void *a1)
{
  *a1  = &unk_1ED060BC0;
  uint64_t v2 = (void *)a1[1];
  if (v2)
  {
    a1[2]  = v2;
    operator delete(v2);
  }

  JUMPOUT(0x1853275C0);
}

void *std::__function::__func<anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_0,std::allocator<anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_0>,BOOL ()(unsigned short)>::__clone(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x20uLL);
  *uint64_t v2 = &unk_1ED060BC0;
  std::vector<unsigned short>::vector(v2 + 1, v1);
  return v2;
}

void *std::__function::__func<anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_0,std::allocator<anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_0>,BOOL ()(unsigned short)>::__clone(uint64_t a1, void *a2)
{
  *a2  = &unk_1ED060BC0;
  return std::vector<unsigned short>::vector(a2 + 1, a1 + 8);
}

void std::__function::__func<anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_0,std::allocator<anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_0>,BOOL ()(unsigned short)>::destroy(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16)  = v2;
    operator delete(v2);
  }
}

void std::__function::__func<anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_0,std::allocator<anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_0>,BOOL ()(unsigned short)>::destroy_deallocate(void *__p)
{
  uint64_t v2 = (void *)__p[1];
  if (v2)
  {
    __p[2]  = v2;
    operator delete(v2);
  }

  operator delete(__p);
}

BOOL std::__function::__func<anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_0,std::allocator<anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_0>,BOOL ()(unsigned short)>::operator()(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t v2 = *(unsigned __int16 **)(a1 + 8);
  int v3 = *(unsigned __int16 **)(a1 + 16);
  if (v3 == v2) {
    return 1;
  }
  unsigned int v4 = *a2;
  unint64_t v5 = v3 - v2;
  do
  {
    unint64_t v6 = v5 >> 1;
    uint64_t v7 = &v2[v5 >> 1];
    unsigned int v9 = *v7;
    uint64_t v8 = v7 + 1;
    v5 += ~(v5 >> 1);
    if (v9 < v4) {
      uint64_t v2 = v8;
    }
    else {
      unint64_t v5 = v6;
    }
  }
  while (v5);
  return v2 == v3 || *v2 > v4;
}

void std::__function::__func<anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_1,std::allocator<anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_1>,void ()(unsigned short,unsigned short,unsigned short)>::~__func()
{
}

void *std::__function::__func<anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_1,std::allocator<anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_1>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1ED060C08;
  result[1]  = v3;
  return result;
}

uint64_t std::__function::__func<anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_1,std::allocator<anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_1>,void ()(unsigned short,unsigned short,unsigned short)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2  = &unk_1ED060C08;
  a2[1]  = v2;
  return result;
}

uint64_t std::__function::__func<anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_1,std::allocator<anonymous namespace'::MorxContextualSubtableBuilder::FromArabicLookups(TBaseFont const&,unsigned int,unsigned int,anonymous namespace'::ArabicLookups const&,void const*,std::vector<unsigned short> const&)::$_1>,void ()(unsigned short,unsigned short,unsigned short)>::operator()(uint64_t result, unsigned __int16 *a2, unsigned __int16 *a3, unsigned __int16 *a4)
{
  unsigned int v4 = *a2;
  unsigned int v5 = *a3;
  if (v4 <= v5 && v4 != (unsigned __int16)(v5 + 1))
  {
    uint64_t v6 = result;
    unsigned int v7 = *a4;
    do
    {
      __n128 result = LKTGetValue(*(__CFData **)(v6 + 8), (unsigned __int16)v4);
      if ((result & 0xFF0000) != 0) {
        __n128 result = (uint64_t)LKTAddRange(*(__CFData **)(v6 + 8), v7, v7, result);
      }
      BOOL v8 = v5 == (unsigned __int16)v4;
      LOWORD(v4)  = v4 + 1;
    }
    while (!v8);
  }
  return result;
}

void *std::vector<MortFeatureEntry,TInlineBufferAllocator<MortFeatureEntry,30ul>>::emplace<MortFeatureEntry>(void *result, char *a2, uint64_t *a3)
{
  uint64_t v3 = (char **)result;
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  unsigned int v5 = (char *)*result;
  unsigned int v4 = (char *)result[1];
  uint64_t v6 = (uint64_t)&a2[-*result];
  uint64_t v7 = v6 / 12;
  BOOL v8 = (char *)(*result + 12 * (v6 / 12));
  unint64_t v9 = result[2];
  if ((unint64_t)v4 >= v9)
  {
    unint64_t v37 = 0;
    uint64_t v38 = 0;
    uint64_t v39 = 0;
    unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((v4 - v5) >> 2) + 1;
    if (v14 > 0x1555555555555555) {
      abort();
    }
    unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v9 - (void)v5) >> 2);
    if (2 * v16 > v14) {
      unint64_t v14 = 2 * v16;
    }
    if (v16 >= 0xAAAAAAAAAAAAAAALL) {
      unint64_t v17 = 0x1555555555555555;
    }
    else {
      unint64_t v17 = v14;
    }
    unint64_t v41 = result + 3;
    if (v17)
    {
      unsigned int v18 = a3;
      __int16 v19 = TInlineBufferAllocator<MortFeatureEntry,30ul>::allocate((uint64_t)(result + 3), v17);
      a3  = v18;
      __int16 v20 = v19;
    }
    else
    {
      __int16 v20 = 0;
    }
    CFDataRef v22 = &v20[12 * v7];
    unint64_t v40 = &v20[12 * v17];
    if (v7 == v17)
    {
      if (v6 < 1)
      {
        CFDataRef v24 = &v20[12 * v17];
        if (v5 == a2) {
          unint64_t v25 = 1;
        }
        else {
          unint64_t v25 = 2 * v7;
        }
        unsigned int v46 = v3 + 3;
        unsigned __int16 v26 = a3;
        uint64_t v42 = v20;
        int v43 = &v20[12 * v7];
        unint64_t v37 = TInlineBufferAllocator<MortFeatureEntry,30ul>::allocate((uint64_t)(v3 + 3), v25);
        unint64_t v40 = &v37[12 * v25];
        unsigned int v44 = v43;
        unsigned int v45 = v24;
        std::__split_buffer<MortFeatureEntry,TInlineBufferAllocator<MortFeatureEntry,30ul> &>::~__split_buffer((uint64_t)&v42);
        a3  = v26;
        CFDataRef v22 = &v37[12 * (v25 >> 2)];
      }
      else
      {
        uint64_t v23 = v7 + 2;
        if (v7 >= -1) {
          uint64_t v23 = v7 + 1;
        }
        v22 -= 12 * (v23 >> 1);
      }
    }
    uint64_t v27 = *a3;
    *((_DWORD *)v22 + 2)  = *((_DWORD *)a3 + 2);
    *(void *)CFDataRef v22 = v27;
    uint64_t v28 = v22 + 12;
    uint64_t v39 = v22 + 12;
    int v29 = *v3;
    if (*v3 != v8)
    {
      unsigned int v30 = v8;
      do
      {
        uint64_t v31 = *(void *)(v30 - 12);
        v30 -= 12;
        int v32 = *((_DWORD *)v30 + 2);
        *(void *)(v22 - 12)  = v31;
        v22 -= 12;
        *((_DWORD *)v22 + 2)  = v32;
      }
      while (v30 != v29);
      uint64_t v28 = v39;
    }
    uint64_t v38 = v22;
    uint64_t v33 = v3[1];
    int64_t v34 = v33 - v8;
    if (v33 != v8)
    {
      memmove(v28, v8, v33 - v8);
      CFDataRef v22 = v38;
      BOOL v8 = v3[1];
    }
    __int16 v35 = *v3;
    *uint64_t v3 = v22;
    v3[1]  = &v28[v34];
    unint64_t v36 = v3[2];
    v3[2]  = v40;
    uint64_t v39 = v8;
    unint64_t v40 = v36;
    unint64_t v37 = v35;
    uint64_t v38 = v35;
    return (void *)std::__split_buffer<MortFeatureEntry,TInlineBufferAllocator<MortFeatureEntry,30ul> &>::~__split_buffer((uint64_t)&v37);
  }
  else if (v8 == v4)
  {
    uint64_t v21 = *a3;
    *((_DWORD *)v8 + 2)  = *((_DWORD *)a3 + 2);
    *(void *)BOOL v8 = v21;
    result[1]  = v8 + 12;
  }
  else
  {
    uint64_t v42 = (char *)*a3;
    LODWORD(v43)  = *((_DWORD *)a3 + 2);
    unint64_t v10 = v8 + 12;
    uint64_t v11 = v4 - 12;
    uint64_t v12 = v4;
    while (v11 < v4)
    {
      uint64_t v13 = *(void *)v11;
      *((_DWORD *)v12 + 2)  = *((_DWORD *)v11 + 2);
      *(void *)uint64_t v12 = v13;
      v12 += 12;
      v11 += 12;
    }
    result[1]  = v12;
    if (v4 != v10) {
      __n128 result = memmove(v8 + 12, v8, v4 - v10);
    }
    *(void *)BOOL v8 = v42;
    *((_DWORD *)v8 + 2)  = v43;
  }
  return result;
}

void *std::allocator_traits<TInlineBufferAllocator<anonymous namespace'::MorxChainBuilder,30ul>>::construct[abi:nn180100]<anonymous namespace'::MorxChainBuilder,anonymous namespace'::MorxChainBuilder const&,void,void>(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1  = *(_DWORD *)a2;
  std::vector<MortFeatureEntry,TInlineBufferAllocator<MortFeatureEntry,30ul>>::vector<std::__wrap_iter<MortFeatureEntry const*>,0>((char **)(a1 + 8), *(unsigned char **)(a2 + 8), *(unsigned char **)(a2 + 16));
  unsigned int v4 = *(atomic_ullong **)(a2 + 400);
  unsigned int v5 = *(atomic_ullong **)(a2 + 408);
  *(void *)(a1 + 416)  = 0;
  *(_OWORD *)(a1 + 400)  = 0u;
  *(void *)(a1 + 664)  = a1 + 424;
  std::vector<TCFRef<__CFData *>,TInlineBufferAllocator<TCFRef<__CFData *>,30ul>>::__init_with_size[abi:nn180100]<std::__wrap_iter<TCFRef<__CFData *> const*>,std::__wrap_iter<TCFRef<__CFData *> const*>>((void *)(a1 + 400), v4, v5, v5 - v4);
  uint64_t v6 = *(atomic_ullong **)(a2 + 672);
  uint64_t v7 = *(atomic_ullong **)(a2 + 680);
  *(void *)(a1 + 688)  = 0;
  *(_OWORD *)(a1 + 672)  = 0u;
  *(void *)(a1 + 936)  = a1 + 696;

  return std::vector<TCFRef<__CFData *>,TInlineBufferAllocator<TCFRef<__CFData *>,30ul>>::__init_with_size[abi:nn180100]<std::__wrap_iter<TCFRef<__CFData *> const*>,std::__wrap_iter<TCFRef<__CFData *> const*>>((void *)(a1 + 672), v6, v7, v7 - v6);
}

char **std::vector<MortFeatureEntry,TInlineBufferAllocator<MortFeatureEntry,30ul>>::vector<std::__wrap_iter<MortFeatureEntry const*>,0>(char **a1, unsigned char *a2, unsigned char *a3)
{
  *a1  = 0;
  a1[1]  = 0;
  uint64_t v4 = (uint64_t)(a1 + 3);
  a1[2]  = 0;
  a1[48]  = (char *)v4;
  int64_t v5 = a3 - a2;
  if (a3 != a2)
  {
    if (0xAAAAAAAAAAAAAAABLL * (v5 >> 2) >= 0x1555555555555556) {
      abort();
    }
    BOOL v8 = TInlineBufferAllocator<MortFeatureEntry,30ul>::allocate(v4, 0xAAAAAAAAAAAAAAABLL * (v5 >> 2));
    *a1  = v8;
    a1[1]  = v8;
    unint64_t v9 = &v8[4 * (v5 >> 2)];
    a1[2]  = v9;
    if (a3 != a2) {
      memmove(v8, a2, v5);
    }
    a1[1]  = v9;
  }
  return a1;
}

void *std::vector<TCFRef<__CFData *>,TInlineBufferAllocator<TCFRef<__CFData *>,30ul>>::__init_with_size[abi:nn180100]<std::__wrap_iter<TCFRef<__CFData *> const*>,std::__wrap_iter<TCFRef<__CFData *> const*>>(void *result, atomic_ullong *a2, atomic_ullong *a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >> 61) {
      abort();
    }
    uint64_t v7 = result;
    __n128 result = TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>::allocate((uint64_t)(result + 3), a4);
    BOOL v8 = result;
    void *v7 = result;
    v7[1]  = result;
    void v7[2] = &result[a4];
    while (a2 != a3)
    {
      __n128 result = (id)atomic_load_explicit(a2, memory_order_acquire);
      *v8++  = result;
      ++a2;
    }
    v7[1]  = v8;
  }
  return result;
}

void std::allocator_traits<TInlineBufferAllocator<anonymous namespace'::MorxChainBuilder,30ul>>::destroy[abi:nn180100]<anonymous namespace'::MorxChainBuilder,void,void>(void **a1)
{
  uint64_t v2 = a1 + 84;
  std::vector<TCFRef<__CFData const*>,TInlineBufferAllocator<TCFRef<__CFData const*>,30ul>>::__destroy_vector::operator()[abi:nn180100](&v2);
  uint64_t v2 = a1 + 50;
  std::vector<TCFRef<__CFData const*>,TInlineBufferAllocator<TCFRef<__CFData const*>,30ul>>::__destroy_vector::operator()[abi:nn180100](&v2);
  uint64_t v2 = a1 + 1;
  std::vector<MortFeatureEntry,TInlineBufferAllocator<MortFeatureEntry,30ul>>::__destroy_vector::operator()[abi:nn180100](&v2);
}

void std::vector<TCFRef<__CFData const*>,TInlineBufferAllocator<TCFRef<__CFData const*>,30ul>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (id *)**a1;
  if (v2)
  {
    uint64_t v4 = (id *)v1[1];
    int64_t v5 = (void **)**a1;
    uint64_t v6 = v1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = v4 - 1;

        uint64_t v4 = v7;
      }
      while (v7 != v2);
      uint64_t v6 = *a1;
      int64_t v5 = (void **)**a1;
    }
    v1[1]  = v2;
    BOOL v8 = v6 + 33;
    if (v6 + 3 <= v5 && v8 > v5)
    {
      if (v6[2] == v6[33]) {
        *BOOL v8 = v5;
      }
    }
    else
    {
      operator delete(v5);
    }
  }
}

void std::vector<MortFeatureEntry,TInlineBufferAllocator<MortFeatureEntry,30ul>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    v1[1]  = v2;
    uint64_t v3 = v1 + 48;
    if (v1 + 3 <= v2)
    {
      BOOL v4 = v3 >= v2;
      BOOL v5 = v3 == v2;
    }
    else
    {
      BOOL v4 = 0;
      BOOL v5 = 0;
    }
    if (!v5 && v4)
    {
      if (v1[2] == v1[48]) {
        *uint64_t v3 = v2;
      }
    }
    else
    {
      operator delete(v2);
    }
  }
}

void std::vector<LtagStringRange,TInlineBufferAllocator<LtagStringRange,30ul>>::__destroy_vector::operator()[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  if (v2)
  {
    *(void *)(a1 + 8)  = v2;
    uint64_t v3 = (void *)(a1 + 144);
    if (a1 + 24 <= (unint64_t)v2)
    {
      BOOL v4 = v3 >= v2;
      BOOL v5 = v3 == v2;
    }
    else
    {
      BOOL v4 = 0;
      BOOL v5 = 0;
    }
    if (!v5 && v4)
    {
      if (*(void *)(a1 + 16) == *(void *)(a1 + 144)) {
        *uint64_t v3 = v2;
      }
    }
    else
    {
      operator delete(v2);
    }
  }
}

unint64_t anonymous namespace'::MorxChainBuilder::TotalSize(_anonymous_namespace_::MorxChainBuilder *this, unint64_t a2)
{
  uint64_t v3 = (atomic_ullong *)*((void *)this + 50);
  uint64_t v2 = (atomic_ullong *)*((void *)this + 51);
  unint64_t v4 = ((a2 + 7) >> 3) + 4;
  if (a2 > 0x10000) {
    unint64_t v4 = 8196;
  }
  for (uint64_t i = *((void *)this + 2) - *((void *)this + 1) + (v2 - v3) * v4 + 28; v3 != v2; ++v3)
    LODWORD(i)  = CFDataGetLength((CFDataRef)atomic_load_explicit(v3, memory_order_acquire)) + i;
  return (i + 3) & 0xFFFFFFFC | ((unint64_t)(((i + 3) & 0xFFFFFFFC) - i) << 32);
}

void std::__tree<std::__value_type<unsigned int,std::unordered_set<unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::unordered_set<unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::unordered_set<unsigned int>>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<unsigned int,std::unordered_set<unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::unordered_set<unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::unordered_set<unsigned int>>>>::destroy(*a1);
    std::__tree<std::__value_type<unsigned int,std::unordered_set<unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::unordered_set<unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::unordered_set<unsigned int>>>>::destroy(a1[1]);
    std::__hash_table<EncoderAttempt,std::hash<EncoderAttempt>,std::equal_to<EncoderAttempt>,std::allocator<EncoderAttempt>>::~__hash_table((uint64_t)(a1 + 5));
    operator delete(a1);
  }
}

void std::__tree<std::__value_type<unsigned int,std::set<unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::set<unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::set<unsigned int>>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<unsigned int,std::set<unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::set<unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::set<unsigned int>>>>::destroy(*a1);
    std::__tree<std::__value_type<unsigned int,std::set<unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::set<unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::set<unsigned int>>>>::destroy(a1[1]);
    std::__tree<std::__value_type<long,TGlyphDeltaListEntry>,std::__map_value_compare<long,std::__value_type<long,TGlyphDeltaListEntry>,std::less<long>,true>,std::allocator<std::__value_type<long,TGlyphDeltaListEntry>>>::destroy((void *)a1[6]);
    operator delete(a1);
  }
}

void AddLigInputForCharacters(uint64_t *a1, TBaseFont *a2, __int16 a3, __int16 *a4, unint64_t a5)
{
  unint64_t v5 = a5;
  uint64_t v68 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v8 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  v66[2]  = v8;
  v66[3]  = v8;
  uint64_t v9 = a5 + 1;
  v66[0]  = v8;
  v66[1]  = v8;
  *(void *)&v58[16]  = v66;
  unint64_t v10 = (char *)v66 + 2;
  int v67 = (char *)v66 + 2;
  LOWORD(v66[0])  = a3;
  uint64_t v63 = (char *)v66;
  __int16 v64 = (char *)v66 + 2;
  unsigned int v65 = (char *)v66 + 2;
  *(_OWORD *)size_t v57 = 0u;
  *(_OWORD *)unsigned int v58 = 0u;
  std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,30ul> &>::~__split_buffer((uint64_t)v57);
  __int16 v64 = (char *)v66 + 2;
  if (v5)
  {
    unint64_t v49 = v5;
    uint64_t v11 = &a4[v5];
    do
    {
      __int16 v12 = *a4;
      if (v10 >= v65)
      {
        uint64_t v13 = v63;
        uint64_t v14 = v10 - v63;
        if (v10 - v63 <= -3) {
LABEL_56:
        }
          abort();
        uint64_t v15 = v14 >> 1;
        if (v65 - v63 <= (unint64_t)((v14 >> 1) + 1)) {
          uint64_t v16 = v15 + 1;
        }
        else {
          uint64_t v16 = v65 - v63;
        }
        if ((unint64_t)(v65 - v63) >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v17 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v17 = v16;
        }
        *(void *)&v58[16]  = v66;
        if (v17)
        {
          unsigned int v18 = (char *)TInlineBufferAllocator<unsigned short,30ul>::allocate((uint64_t)v66, v17);
          uint64_t v13 = v63;
          unint64_t v10 = v64;
        }
        else
        {
          unsigned int v18 = 0;
        }
        __int16 v19 = &v18[2 * v15];
        *(_WORD *)__int16 v19 = v12;
        if (v10 == v13)
        {
          uint64_t v21 = &v18[2 * v15];
        }
        else
        {
          __int16 v20 = v10;
          uint64_t v21 = &v18[2 * v15];
          do
          {
            __int16 v22 = *((_WORD *)v20 - 1);
            v20 -= 2;
            *((_WORD *)v21 - 1)  = v22;
            v21 -= 2;
          }
          while (v20 != v13);
        }
        uint64_t v23 = v19 + 2;
        uint64_t v63 = v21;
        __int16 v64 = v19 + 2;
        CFDataRef v24 = v65;
        unsigned int v65 = &v18[2 * v17];
        *(void *)unsigned int v58 = v10;
        *(void *)&v58[8]  = v24;
        v57[0]  = v13;
        v57[1]  = v13;
        std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,30ul> &>::~__split_buffer((uint64_t)v57);
        unint64_t v10 = v23;
      }
      else
      {
        *(_WORD *)unint64_t v10 = v12;
        v10 += 2;
      }
      __int16 v64 = v10;
      ++a4;
    }
    while (a4 != v11);
    *(void *)&long long v25 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v25 + 1)  = 0xAAAAAAAAAAAAAAAALL;
    long long v61 = v25;
    long long v60 = v25;
    long long v59 = v25;
    *(_OWORD *)&v58[8]  = v25;
    v57[1]  = 0;
    *(void *)unsigned int v58 = 0;
    v57[0]  = 0;
    unint64_t v62 = &v58[8];
    unint64_t v5 = v49;
    if (!v9)
    {
      unsigned __int16 v26 = 0;
      goto LABEL_26;
    }
  }
  else
  {
    *(void *)&long long v27 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v27 + 1)  = 0xAAAAAAAAAAAAAAAALL;
    long long v61 = v27;
    long long v60 = v27;
    long long v59 = v27;
    *(_OWORD *)&v58[8]  = v27;
    v57[1]  = 0;
    *(void *)unsigned int v58 = 0;
    v57[0]  = 0;
    unint64_t v62 = &v58[8];
  }
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__vallocate[abi:nn180100](v57, v9);
  uint64_t v28 = (char *)v57[1];
  bzero(v57[1], 2 * v5 + 2);
  v57[1]  = &v28[2 * v9];
  unsigned __int16 v26 = v57[0];
LABEL_26:
  if ((*(uint64_t (**)(TBaseFont *, char *, void *, uint64_t))(*(void *)a2 + 664))(a2, v63, v26, v9) >= v9)
  {
    unint64_t v55 = 0xAAAAAAAAAAAAAAAALL;
    unsigned int v53 = 0;
    v54[0]  = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v51 = 0;
    uint64_t v52 = 0;
    v54[1]  = v54;
    LOWORD(v55)  = *(_WORD *)v57[0];
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::reserve((char **)&v51, v5);
    GlyphCFIndex Count = TBaseFont::GetGlyphCount(a2);
    if (v9 < 2)
    {
LABEL_53:
    }
    else
    {
      uint64_t v30 = GlyphCount;
      uint64_t v31 = 1;
      while (1)
      {
        int v32 = v57[0];
        uint64_t v33 = *((unsigned __int16 *)v57[0] + v31);
        if (v33 == (unsigned __int16)v55 || v30 <= v33) {
          break;
        }
        __int16 v35 = (void **)v52;
        if (v52 >= v53)
        {
          unint64_t v37 = v51;
          uint64_t v38 = v52 - (char *)v51;
          if (v52 - (char *)v51 <= -3) {
            goto LABEL_56;
          }
          uint64_t v39 = v38 >> 1;
          if (v53 - (char *)v51 <= (unint64_t)((v38 >> 1) + 1)) {
            uint64_t v40 = v39 + 1;
          }
          else {
            uint64_t v40 = v53 - (char *)v51;
          }
          if ((unint64_t)(v53 - (char *)v51) >= 0x7FFFFFFFFFFFFFFELL) {
            uint64_t v41 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v41 = v40;
          }
          v56[4]  = v54;
          if (v41)
          {
            uint64_t v42 = (char *)TInlineBufferAllocator<unsigned short,3ul>::allocate((uint64_t)v54, v41);
            unint64_t v37 = v51;
            __int16 v35 = (void **)v52;
            LOWORD(v33)  = v32[v31];
          }
          else
          {
            uint64_t v42 = 0;
          }
          int v43 = &v42[2 * v39];
          *(_WORD *)int v43 = v33;
          if (v35 == v37)
          {
            unsigned int v45 = &v42[2 * v39];
          }
          else
          {
            unsigned int v44 = v35;
            unsigned int v45 = &v42[2 * v39];
            do
            {
              __int16 v46 = *((_WORD *)v44 - 1);
              unsigned int v44 = (void **)((char *)v44 - 2);
              *((_WORD *)v45 - 1)  = v46;
              v45 -= 2;
            }
            while (v44 != v37);
          }
          unint64_t v36 = v43 + 2;
          uint64_t v51 = (void **)v45;
          uint64_t v52 = v43 + 2;
          uint64_t v47 = v53;
          unsigned int v53 = &v42[2 * v41];
          v56[2]  = v35;
          v56[3]  = v47;
          v56[0]  = v37;
          v56[1]  = v37;
          std::__split_buffer<unsigned short,TInlineBufferAllocator<unsigned short,3ul> &>::~__split_buffer((uint64_t)v56);
        }
        else
        {
          *(_WORD *)uint64_t v52 = v33;
          unint64_t v36 = (char *)v35 + 2;
        }
        uint64_t v52 = v36;
        if (v31++ == v5) {
          goto LABEL_53;
        }
      }
    }
    std::vector<unsigned short,TInlineBufferAllocator<unsigned short,3ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v51);
  }
  uint64_t v51 = v57;
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100](&v51);
  v57[0]  = &v63;
  std::vector<unsigned short,TInlineBufferAllocator<unsigned short,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)v57);
}

void CreateLookupTableFromCharacterSwashes<std::pair<unsigned short,unsigned short> const*>(atomic_ullong *a1, uint64_t a2, int64_t a3, int *a4, int *a5, uint64_t a6)
{
  for (uint64_t i = NewLKTHandle(a3, 0); a4 != a5; ++a4)
  {
    int v12 = *a4;
    int v13 = -1431655766;
    int v14 = v12;
    if ((*(uint64_t (**)(uint64_t, int *, int *, uint64_t))(*(void *)a2 + 664))(a2, &v14, &v13, 2) == 2
      && LKTAddRange(i, (unsigned __int16)v13, (unsigned __int16)v13, SHIWORD(v13)))
    {
      *(unsigned char *)(a6 + ((unint64_t)(unsigned __int16)v13 >> 3)) |= 1 << (v13 & 7);
    }
  }
  *a1  = 0xAAAAAAAAAAAAAAAALL;
  LKTCreateLookupTable(i, a1);
  DisposeLKTHandle(i);
}

uint64_t TForcedBidiLevelsProvider::GetLevels(int64x2_t *this, CFRange a2, CTWritingDirection a3)
{
  CFIndex length = a2.length;
  uint64_t v7 = this + 1;
  uint64_t result = this[1].i64[0];
  uint64_t v6 = (unsigned char *)v7->i64[1];
  long long v8 = &v6[-result];
  unint64_t v9 = a2.length - (void)&v6[-result];
  if (a2.length <= (unint64_t)&v6[-result])
  {
    if (a2.length < (unint64_t)&v6[-result]) {
      this[1].i64[1]  = result + a2.length;
    }
  }
  else
  {
    uint64_t v10 = this[2].i64[0];
    if (v10 - (uint64_t)v6 >= v9)
    {
      do
      {
        *v6++  = this->i8[8];
        --v9;
      }
      while (v9);
      this[1].i64[1]  = a2.length + result;
    }
    else
    {
      if (a2.length < 0) {
        abort();
      }
      unint64_t v11 = v10 - result;
      CFIndex v12 = 2 * v11;
      if (2 * v11 <= a2.length) {
        CFIndex v12 = a2.length;
      }
      if (v11 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v13 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v13 = v12;
      }
      long long v27 = &this[2].i8[8];
      uint64_t v14 = this[4].i64[1];
      if (v14 + v13 <= (unint64_t)this[4].u64 + 6) {
        this[4].i64[1]  = v14 + v13;
      }
      else {
        uint64_t v14 = (uint64_t)operator new(v13);
      }
      uint64_t v15 = &v8[v14];
      uint64_t v16 = (char *)(v14 + v13);
      unsigned __int16 v26 = (char *)(v14 + v13);
      uint64_t v17 = (char *)(v14 + length);
      unsigned int v18 = &v8[v14];
      do
      {
        *v18++  = this->i8[8];
        --v9;
      }
      while (v9);
      v25.i64[1]  = v14 + length;
      uint64_t v20 = this[1].i64[0];
      unint64_t v19 = this[1].u64[1];
      if (v19 == v20)
      {
        int64x2_t v22 = vdupq_n_s64(v19);
      }
      else
      {
        do
        {
          char v21 = *(unsigned char *)--v19;
          *--uint64_t v15 = v21;
        }
        while (v19 != v20);
        int64x2_t v22 = this[1];
        uint64_t v17 = (char *)v25.i64[1];
        uint64_t v16 = v26;
      }
      this[1].i64[0]  = (uint64_t)v15;
      this[1].i64[1]  = (uint64_t)v17;
      int64x2_t v25 = v22;
      uint64_t v23 = (char *)this[2].i64[0];
      this[2].i64[0]  = (uint64_t)v16;
      unsigned __int16 v26 = v23;
      uint64_t v24 = v22.i64[0];
      std::__split_buffer<char,TInlineBufferAllocator<char,30ul> &>::~__split_buffer((uint64_t)&v24);
    }
    return this[1].i64[0];
  }
  return result;
}

uint64_t TForcedBidiLevelsProvider::GetDefaultParagraphDirection(TForcedBidiLevelsProvider *this)
{
  return *((unsigned char *)this + 8) & 1;
}

void TForcedBidiLevelsProvider::~TForcedBidiLevelsProvider(TForcedBidiLevelsProvider *this)
{
  *(void *)this  = &unk_1ED05F268;
  uint64_t v1 = (void **)((char *)this + 16);
  std::vector<char,TInlineBufferAllocator<char,30ul>>::__destroy_vector::operator()[abi:nn180100](&v1);
}

{
  void **v2;

  *(void *)this  = &unk_1ED05F268;
  uint64_t v2 = (void **)((char *)this + 16);
  std::vector<char,TInlineBufferAllocator<char,30ul>>::__destroy_vector::operator()[abi:nn180100](&v2);
  MEMORY[0x1853275C0](this, 0x1091C406A714F82);
}

uint64_t GetCharClass(UChar32 a1)
{
  if (a1 > 8287)
  {
    switch(a1)
    {
      case 43488:
      case 43489:
      case 43490:
      case 43491:
      case 43492:
      case 43495:
      case 43496:
      case 43497:
      case 43498:
      case 43499:
      case 43500:
      case 43501:
      case 43502:
      case 43503:
      case 43514:
      case 43515:
      case 43516:
      case 43517:
      case 43518:
LABEL_6:
        uint64_t result = 0;
        break;
      case 43493:
LABEL_9:
        uint64_t result = 19;
        break;
      case 43494:
LABEL_10:
        uint64_t result = 8;
        break;
      case 43504:
      case 43505:
      case 43506:
      case 43507:
      case 43508:
      case 43509:
      case 43510:
      case 43511:
      case 43512:
      case 43513:
LABEL_5:
        uint64_t result = 2;
        break;
      default:
        if (a1 == 8288)
        {
          uint64_t result = 10;
        }
        else
        {
LABEL_29:
          if (IsGenericBase(a1))
          {
            uint64_t result = 3;
          }
          else if ((a1 & 0xFFF0) == 0xFE00)
          {
            uint64_t result = 9;
          }
          else if ((u_charType(a1) - 12) >= 3)
          {
            uint64_t result = 6;
          }
          else
          {
            uint64_t result = 11;
          }
        }
        break;
    }
  }
  else
  {
    int v2 = a1 - 4096;
    uint64_t result = 21;
    switch(v2)
    {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 14:
      case 15:
      case 16:
      case 17:
      case 18:
      case 19:
      case 20:
      case 21:
      case 22:
      case 23:
      case 24:
      case 25:
      case 26:
      case 27:
      case 28:
      case 29:
      case 30:
      case 31:
      case 32:
      case 63:
      case 78:
      case 80:
      case 81:
      case 90:
      case 91:
      case 92:
      case 93:
      case 97:
      case 101:
      case 102:
      case 110:
      case 111:
      case 112:
      case 117:
      case 118:
      case 119:
      case 120:
      case 121:
      case 122:
      case 123:
      case 124:
      case 125:
      case 126:
      case 127:
      case 128:
      case 129:
      case 142:
        goto LABEL_6;
      case 33:
      case 34:
      case 35:
      case 36:
      case 37:
      case 38:
      case 39:
      case 40:
      case 41:
      case 42:
      case 82:
      case 83:
      case 84:
      case 85:
        uint64_t result = 5;
        break;
      case 43:
      case 44:
      case 86:
      case 87:
      case 98:
      case 103:
      case 104:
      case 131:
        uint64_t result = 23;
        break;
      case 45:
      case 46:
      case 51:
      case 52:
      case 53:
      case 113:
      case 114:
      case 115:
      case 116:
      case 133:
      case 134:
      case 157:
        goto LABEL_9;
      case 47:
      case 48:
      case 88:
      case 89:
        uint64_t result = 20;
        break;
      case 49:
      case 132:
        uint64_t result = 18;
        break;
      case 50:
      case 54:
        return result;
      case 55:
        uint64_t result = 22;
        break;
      case 56:
      case 135:
      case 136:
      case 137:
      case 138:
      case 139:
      case 140:
      case 141:
      case 143:
      case 154:
      case 155:
      case 156:
        uint64_t result = 25;
        break;
      case 57:
        uint64_t result = 4;
        break;
      case 58:
        uint64_t result = 12;
        break;
      case 59:
      case 94:
      case 95:
        uint64_t result = 13;
        break;
      case 60:
        uint64_t result = 14;
        break;
      case 61:
      case 130:
        uint64_t result = 15;
        break;
      case 62:
        uint64_t result = 16;
        break;
      case 64:
        uint64_t result = 1;
        break;
      case 65:
      case 66:
      case 67:
      case 68:
      case 69:
      case 70:
      case 71:
      case 72:
      case 73:
      case 144:
      case 145:
      case 146:
      case 147:
      case 148:
      case 149:
      case 150:
      case 151:
      case 152:
      case 153:
        goto LABEL_5;
      case 74:
      case 75:
        uint64_t result = 7;
        break;
      case 76:
      case 77:
      case 79:
      case 158:
      case 159:
        goto LABEL_10;
      case 96:
        uint64_t result = 17;
        break;
      case 99:
      case 100:
      case 105:
      case 106:
      case 107:
      case 108:
      case 109:
        uint64_t result = 24;
        break;
      default:
        if ((a1 - 8204) >= 2) {
          goto LABEL_29;
        }
        uint64_t result = 26;
        break;
    }
  }
  return result;
}

uint64_t HasAnusvara(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a1[1];
  if (v3 >= a3) {
    return 0;
  }
  unint64_t v4 = (_DWORD *)(**(void **)(*a1 + 104) + 16 * v3 + 24);
  uint64_t v5 = a1[1];
  while (1)
  {
    int v6 = *(v4 - 4);
    if (v6 != 21) {
      break;
    }
    ++v5;
    v4 += 4;
    if (a3 == v5) {
      goto LABEL_13;
    }
  }
  if (v6 == 22)
  {
    uint64_t v7 = v5 + 1;
    BOOL v8 = v5 + 1 < a3;
    a3  = v5 + 1;
    if (v8)
    {
      uint64_t v9 = v5 + 2;
      if (*v4 == 12) {
        a3  = v9;
      }
      else {
        a3  = v7;
      }
    }
  }
  else
  {
    a3  = v5;
  }
LABEL_13:
  if (a3 == v3) {
    return 0;
  }
  a1[1]  = a3;
  return 1;
}

uint64_t MyanmarShapingEngine::ApplyScriptShaping(MyanmarShapingEngine *this, const OTL::GSUB *a2, OTL::GlyphLookups *a3)
{
  uint64_t v4 = MEMORY[0x1F4188790](this, a2);
  unint64_t v166 = v6;
  uint64_t v7 = v4;
  uint64_t v229 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *(void *)(v4 + 8);
  if ((*(_DWORD *)(v8 + 24) & 0x80000000) != 0) {
    return 0;
  }
  uint64_t v9 = v5;
  uint64_t v10 = (uint64_t)&StringIndex;
  v169  = 0;
  uint64_t v12 = *v5;
  uint64_t v11 = v5[1];
  uint64_t v167 = v7;
  if (v11 != *v5)
  {
    do
    {
      uint64_t v13 = v11 - 104;
      p_StringIndeCGFloat x = (unsigned __int16 *)(v11 - 96);
      std::vector<CFRange,TInlineBufferAllocator<CFRange,4ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&p_StringIndex);
      uint64_t v11 = v13;
    }
    while (v13 != v12);
    uint64_t v7 = v167;
    uint64_t v8 = *(void *)(v167 + 8);
  }
  v9[1]  = v12;
  uint64_t v14 = *(void *)(v8 + 104);
  unint64_t v15 = TRunGlue::length((TRunGlue *)v8);
  v168  = (void *)v14;
  std::vector<TGlyphAuxDataListEntry,TInlineBufferAllocator<TGlyphAuxDataListEntry,30ul>>::resize(v14, v15);
  *(void *)&long long v16 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v16 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  v214[28]  = v16;
  v214[29]  = v16;
  v214[26]  = v16;
  v214[27]  = v16;
  v214[24]  = v16;
  v214[25]  = v16;
  v214[22]  = v16;
  v214[23]  = v16;
  v214[20]  = v16;
  v214[21]  = v16;
  v214[18]  = v16;
  v214[19]  = v16;
  v214[16]  = v16;
  v214[17]  = v16;
  v214[15]  = v16;
  v214[14]  = v16;
  v214[13]  = v16;
  v214[12]  = v16;
  v214[11]  = v16;
  v214[10]  = v16;
  v214[9]  = v16;
  v214[8]  = v16;
  v214[7]  = v16;
  v214[6]  = v16;
  v214[5]  = v16;
  v214[4]  = v16;
  v214[3]  = v16;
  v214[2]  = v16;
  v214[1]  = v16;
  v214[0]  = v16;
  v213  = 0;
  v215  = v214;
  uint64_t v17 = *(TRunGlue **)(v7 + 8);
  p_StringIndeCGFloat x = *(unsigned __int16 **)v7;
  long long v208 = 0u;
  memset(v209, 0, 168);
  v209[18]  = *((void *)p_StringIndex + 2);
  v211  = 0;
  v212  = 0;
  uint64_t v18 = TRunGlue::length(v17);
  if (v18)
  {
    uint64_t v10 = v18;
    uint64_t v19 = 0;
    for (uint64_t i = 0; i != v10; ++i)
    {
      StringIndeCGFloat x = TRunGlue::GetStringIndex(v17, i);
      unsigned __int16 FullChar = TCharStreamIterator::GetFullChar((TCharStreamIterator *)&p_StringIndex, &StringIndex, 0);
      CharClass  = GetCharClass(FullChar);
      uint64_t v23 = **((void **)v17 + 13) + v19;
      *(_DWORD *)(v23 + 8)  = CharClass;
      *(_DWORD *)(v23 + 12)  = 0;
      v19 += 16;
    }
  }
  StringIndeCGFloat x = (uint64_t)&unk_1ED0616B8;
  p_p_StringIndeCGFloat x = (unsigned __int16 **)&v211;
  *(void *)&long long v175 = &StringIndex;
  uint64_t v24 = TRunGlue::length(*(TRunGlue **)(v7 + 8));
  if (!v24) {
    goto LABEL_178;
  }
  int64_t v3 = v24;
  uint64_t v25 = 0;
  do
  {
    unsigned __int16 v26 = *(TRunGlue **)(v7 + 8);
    if (v25 + 31 >= v3) {
      uint64_t v10 = v3;
    }
    else {
      uint64_t v10 = v25 + 31;
    }
    *((void *)&v218 + 1)  = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&v218  = 0xAAAAAAAAAAAAAAAALL;
    if (v25 >= v10)
    {
      int v28 = 0;
      int v29 = 3;
      uint64_t v10 = v25;
      goto LABEL_35;
    }
    int64_t v27 = v3;
    int v28 = 0;
    int v29 = 3;
    char v30 = 1;
    uint64_t v31 = v25;
    while (1)
    {
      uint64_t v32 = 16 * v31;
      while (1)
      {
        int v33 = v30 & (v28 == 0);
        BOOL v34 = v31 < v10;
        if (v31 >= v10 || (v30 & (v28 == 0)) == 0) {
          break;
        }
        *(void *)&v216  = TRunGlue::GetStringIndex(v26, v31);
        int v35 = TCharStreamIterator::GetFullChar((TCharStreamIterator *)&p_StringIndex, (uint64_t *)&v216, 0);
        if (v35 != 4100 && v35 != 4186 && v35 != 4123
          || v31 + 1 >= v10
          || (*(void *)&v216  = TRunGlue::GetStringIndex(v26, v31 + 1),
              TCharStreamIterator::GetFullChar((TCharStreamIterator *)&p_StringIndex, (uint64_t *)&v216, 0) != 4154)|| v31 + 2 >= v10|| (*(void *)&v216  = TRunGlue::GetStringIndex(v26, v31 + 2), TCharStreamIterator::GetFullChar((TCharStreamIterator *)&p_StringIndex, (uint64_t *)&v216, 0) != 4153))
        {
          int v28 = 0;
          BOOL v34 = 1;
          char v30 = 1;
          int v33 = 1;
          break;
        }
        v31 += 3;
        v32 += 48;
        char v30 = 1;
        int v28 = 1;
        if (v31 >= v10) {
          goto LABEL_32;
        }
      }
      uint64_t v36 = **((void **)v26 + 13);
      unsigned int v37 = *(_DWORD *)(v36 + v32 + 8);
      if (v37 > 0xB) {
        goto LABEL_48;
      }
      if (((1 << v37) & 0x2D) == 0)
      {
        if (((1 << v37) & 0xDC2) != 0)
        {
          *(void *)&v218  = v26;
          if (v33)
          {
            uint64_t v38 = v31 + 1;
            if (v31 + 1 < v10)
            {
              int v29 = 0;
              goto LABEL_42;
            }
            int v29 = 0;
            goto LABEL_47;
          }
        }
        else
        {
LABEL_48:
          *(void *)&v218  = v26;
          if (v37 == 4 && (v30 & 1) != 0)
          {
            uint64_t v38 = v31 + 1;
            if (v31 + 1 < v10)
            {
LABEL_42:
              if (*(_DWORD *)(v36 + v32 + 24) == 9) {
                uint64_t v10 = v31 + 2;
              }
              else {
                uint64_t v10 = v38;
              }
              goto LABEL_33;
            }
LABEL_47:
            uint64_t v10 = v38;
            goto LABEL_33;
          }
        }
        uint64_t v39 = v37 == 9 && v34;
        v31 += v39;
        goto LABEL_55;
      }
      if ((v30 & 1) == 0) {
        break;
      }
      char v30 = 0;
      ++v31;
      int v29 = 2;
      if (v31 >= v10)
      {
LABEL_32:
        uint64_t v10 = v31;
LABEL_33:
        int64_t v3 = v27;
        uint64_t v7 = v167;
        goto LABEL_35;
      }
    }
    *(void *)&v218  = v26;
LABEL_55:
    if (v31 >= v10) {
      goto LABEL_74;
    }
    while (2)
    {
      char v40 = 0;
      uint64_t v41 = v31;
      while (2)
      {
        int v42 = *(_DWORD *)(v36 + 16 * v41 + 8);
        if (v42 <= 4)
        {
          if (v42 != 4)
          {
            if (v42) {
              goto LABEL_74;
            }
            goto LABEL_69;
          }
          if (v40) {
            goto LABEL_74;
          }
          ++v41;
          goto LABEL_64;
        }
        if (v42 == 26)
        {
          if (++v41 < v10 && *(_DWORD *)(v36 + 16 * v41 + 8) == 26) {
            goto LABEL_74;
          }
LABEL_64:
          char v40 = 1;
          if (v41 >= v10) {
            goto LABEL_74;
          }
          continue;
        }
        break;
      }
      if (v42 != 5) {
        break;
      }
LABEL_69:
      if (v40)
      {
        uint64_t v31 = v41 + 1;
        if (v41 + 1 < v10)
        {
          uint64_t v43 = v41 + 2;
          if (*(_DWORD *)(v36 + 16 * v31 + 8) == 9) {
            uint64_t v31 = v43;
          }
        }
        if (v31 < v10) {
          continue;
        }
      }
      break;
    }
LABEL_74:
    if (v31 == v10) {
      goto LABEL_75;
    }
    if (*(_DWORD *)(v36 + 16 * v31 + 8) == 4)
    {
      if (v31 + 1 >= v10)
      {
        int v29 = 1;
        uint64_t v10 = v31 + 1;
      }
      else
      {
        if (*(_DWORD *)(v36 + 16 * (v31 + 1) + 8) == 26) {
          uint64_t v10 = v31 + 2;
        }
        else {
          uint64_t v10 = v31 + 1;
        }
        int v29 = 1;
      }
LABEL_75:
      int64_t v3 = v27;
      uint64_t v7 = v167;
    }
    else
    {
      if (v31 >= v10) {
        goto LABEL_93;
      }
      unsigned int v44 = (_DWORD *)(v36 + 16 * v31 + 24);
      while (1)
      {
        int v45 = *(v44 - 4);
        if (v45 != 12) {
          break;
        }
        ++v31;
        v44 += 4;
        if (v10 == v31)
        {
          uint64_t v46 = v10;
          int64_t v3 = v27;
          uint64_t v7 = v167;
          goto LABEL_133;
        }
      }
      if (v45 == 13)
      {
        uint64_t v47 = v31 + 1;
        if (v31 + 1 < v10 && *v44 == 12) {
          uint64_t v47 = v31 + 2;
        }
      }
      else
      {
LABEL_93:
        uint64_t v47 = v31;
      }
      if (v47 < v10 && *(_DWORD *)(v36 + 16 * v47 + 8) == 14) {
        ++v47;
      }
      int64_t v3 = v27;
      uint64_t v7 = v167;
      if (v47 < v10 && *(_DWORD *)(v36 + 16 * v47 + 8) == 15) {
        ++v47;
      }
      if (v47 < v10 && *(_DWORD *)(v36 + 16 * v47 + 8) == 16) {
        ++v47;
      }
      if (v47 < v10 && *(_DWORD *)(v36 + 16 * v47 + 8) == 17) {
        ++v47;
      }
      if (v47 < v10 && *(_DWORD *)(v36 + 16 * v47 + 8) == 12) {
        ++v47;
      }
      if (v47 < v10)
      {
        while (*(_DWORD *)(v36 + 16 * v47 + 8) == 18)
        {
          uint64_t v48 = v47 + 1;
          if (v47 + 1 < v10)
          {
            uint64_t v49 = v47 + 2;
            if (*(_DWORD *)(v36 + 16 * v48 + 8) == 9) {
              uint64_t v48 = v49;
            }
          }
          uint64_t v47 = v48;
          if (v48 >= v10) {
            goto LABEL_117;
          }
        }
      }
      uint64_t v48 = v47;
LABEL_117:
      if (v48 < v10)
      {
        while (*(_DWORD *)(v36 + 16 * v48 + 8) == 19)
        {
          uint64_t v50 = v48 + 1;
          if (v48 + 1 < v10)
          {
            uint64_t v51 = v48 + 2;
            if (*(_DWORD *)(v36 + 16 * v50 + 8) == 9) {
              uint64_t v50 = v51;
            }
          }
          uint64_t v48 = v50;
          if (v50 >= v10) {
            goto LABEL_125;
          }
        }
      }
      uint64_t v50 = v48;
LABEL_125:
      if (v50 < v10)
      {
        while (*(_DWORD *)(v36 + 16 * v50 + 8) == 20)
        {
          uint64_t v46 = v50 + 1;
          if (v50 + 1 < v10)
          {
            uint64_t v52 = v50 + 2;
            if (*(_DWORD *)(v36 + 16 * v46 + 8) == 9) {
              uint64_t v46 = v52;
            }
          }
          uint64_t v50 = v46;
          if (v46 >= v10) {
            goto LABEL_133;
          }
        }
      }
      uint64_t v46 = v50;
LABEL_133:
      *((void *)&v218 + 1)  = v46;
      HasAnusvara(&v218, (uint64_t)v26, v10);
      while (1)
      {
        v216  = v218;
        if (*((uint64_t *)&v218 + 1) >= v10) {
          break;
        }
        uint64_t v53 = **(void **)(v216 + 104);
        if (*(_DWORD *)(v53 + 16 * *((void *)&v218 + 1) + 8) != 23) {
          break;
        }
        uint64_t v54 = *((void *)&v218 + 1) + 1;
        if (*((void *)&v218 + 1) + 1 < v10 && *(_DWORD *)(v53 + 16 * v54 + 8) == 9) {
          uint64_t v54 = *((void *)&v218 + 1) + 2;
        }
        if (v54 < v10 && *(_DWORD *)(v53 + 16 * v54 + 8) == 16) {
          ++v54;
        }
        if (v54 < v10 && *(_DWORD *)(v53 + 16 * v54 + 8) == 17) {
          ++v54;
        }
        if (v54 < v10)
        {
          unint64_t v55 = (int *)(v53 + 16 * v54 + 8);
          while (1)
          {
            int v56 = *v55;
            v55 += 4;
            if (v56 != 12) {
              break;
            }
            if (v10 == ++v54)
            {
              uint64_t v57 = v10;
              goto LABEL_158;
            }
          }
        }
        uint64_t v57 = v54;
        if (v54 < v10)
        {
          while (*(_DWORD *)(v53 + 16 * v54 + 8) == 19)
          {
            uint64_t v57 = v54 + 1;
            if (v54 + 1 < v10)
            {
              uint64_t v58 = v54 + 2;
              if (*(_DWORD *)(v53 + 16 * v57 + 8) == 9) {
                uint64_t v57 = v58;
              }
            }
            uint64_t v54 = v57;
            if (v57 >= v10) {
              goto LABEL_158;
            }
          }
          uint64_t v57 = v54;
        }
LABEL_158:
        *((void *)&v216 + 1)  = v57;
        HasAnusvara(&v216, (uint64_t)v26, v10);
        v218  = v216;
      }
      uint64_t v59 = *((void *)&v218 + 1);
      while (v59 < v10 && *(_DWORD *)(**(void **)(v218 + 104) + 16 * v59 + 8) == 24)
      {
        *((void *)&v218 + 1)  = v59 + 1;
        char v60 = HasAnusvara(&v218, (uint64_t)v26, v10);
        uint64_t v59 = *((void *)&v218 + 1);
        if ((v60 & 1) == 0 && *((uint64_t *)&v218 + 1) < v10)
        {
          uint64_t v61 = **(void **)(v218 + 104);
          if (*(_DWORD *)(v61 + 16 * *((void *)&v218 + 1) + 8) == 12)
          {
            uint64_t v62 = *((void *)&v218 + 1) + 1;
            if (*((void *)&v218 + 1) + 1 < v10)
            {
              uint64_t v63 = (int *)(v61 + 16 * *((void *)&v218 + 1) + 24);
              while (1)
              {
                int v64 = *v63;
                v63 += 4;
                if (v64 != 21) {
                  break;
                }
                if (v10 == ++v62)
                {
                  uint64_t v62 = v10;
                  break;
                }
              }
            }
            *((void *)&v218 + 1)  = v62;
            uint64_t v59 = v62;
          }
        }
      }
      if (v59 >= v10)
      {
        uint64_t v10 = v59;
      }
      else
      {
        uint64_t v65 = -v59;
        uint64_t v66 = (int *)(**(void **)(v218 + 104) + 16 * v59 + 8);
        while (1)
        {
          int v68 = *v66;
          v66 += 4;
          int v67 = v68;
          if (v68 != 25) {
            break;
          }
          if (-v10 == --v65) {
            goto LABEL_35;
          }
        }
        uint64_t v10 = (v67 == 26) - v65;
      }
    }
LABEL_35:
    *(void *)&v216  = v25;
    *((void *)&v216 + 1)  = v10 - v25;
    LODWORD(v218)  = v29;
    LOBYTE(v171)  = v28 != 0;
    if (!(void)v175) {
      std::__throw_bad_function_call[abi:nn180100]();
    }
    (*(void (**)(void))(*(void *)v175 + 48))();
    uint64_t v25 = v10;
  }
  while (v10 != v3);
LABEL_178:
  if ((uint64_t *)v175 == &StringIndex)
  {
    (*(void (**)(uint64_t *))(StringIndex + 32))(&StringIndex);
  }
  else if ((void)v175)
  {
    (*(void (**)(void))(*(void *)v175 + 40))();
  }
  *(void *)&long long v70 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v70 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  long long v181 = v70;
  long long v180 = v70;
  v179  = v70;
  long long v178 = v70;
  long long v177 = v70;
  long long v176 = v70;
  long long v175 = v70;
  p_p_StringIndeCGFloat x = 0;
  unsigned int v174 = 0;
  StringIndeCGFloat x = 0;
  *(void *)&long long v182 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v182 + 1)  = &v175;
  v216  = xmmword_184BA1E60;
  OTL::FeatureBuffer::FeatureBuffer<unsigned int const*>((char **)&p_StringIndex, &v216, v217);
  OTL::GCommon::GetLookups((uint64_t)v166, (uint64_t)&p_StringIndex, (uint64_t)&StringIndex, 0);
  *(void *)&v218  = &p_StringIndex;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v218);
  memset(v209, 170, sizeof(v209));
  long long v208 = 0uLL;
  p_StringIndeCGFloat x = 0;
  __int16 v210 = v209;
  uint64_t v71 = TRunGlue::length(*(TRunGlue **)(v7 + 8));
  int64_t v72 = (unsigned int *)StringIndex;
  unint64_t v73 = (unint64_t)p_p_StringIndex;
  if ((unsigned __int16 **)StringIndex != p_p_StringIndex)
  {
    uint64_t v74 = v71;
    do
    {
      unsigned int v75 = *v72++;
      uint64_t v10 = v10 & 0xFFFFFFFF00000000 | v75;
      OTL::GlyphLookups::SetLookupInRange<false>((uint64_t *)&p_StringIndex, v10, 0, v74);
    }
    while (v72 != (unsigned int *)v73);
  }
  OTL::GSUB::ApplyLookups(v166, *(TRunGlue **)(v167 + 8), *(_DWORD *)(*(void *)(v167 + 8) + 24), &p_StringIndex, &v169, 0, 0);
  *(void *)&v216  = &p_StringIndex;
  std::vector<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,TInlineBufferAllocator<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v216);
  p_StringIndeCGFloat x = (unsigned __int16 *)&StringIndex;
  std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&p_StringIndex);
  unsigned int v76 = v211;
  unsigned int v77 = v212;
  if (v211 == v212) {
    goto LABEL_276;
  }
  char v78 = 0;
  uint64_t v79 = 0;
  unint64_t v73 = 3;
  while (1)
  {
LABEL_188:
    int64_t v3 = *v76;
    int v80 = *((_DWORD *)v76 + 2);
    if (!v80)
    {
LABEL_198:
      v79 += v3;
      goto LABEL_270;
    }
    uint64_t v81 = *((unsigned char *)v76 + 12) ? 3 : 0;
    uint64_t v82 = v167;
    if (v80 == 3)
    {
      LOWORD(StringIndex)  = 9676;
      LOWORD(v216)  = -21846;
      uint64_t v83 = *(void *)(*(void *)(*(void *)(v167 + 8) + 616) + 400);
      if (!(*(uint64_t (**)(uint64_t, uint64_t *, long long *, uint64_t))(*(void *)v83 + 664))(v83, &StringIndex, &v216, 1))goto LABEL_270; {
      unsigned int v84 = *(TRunGlue **)(v167 + 8);
      }
      LOWORD(p_StringIndex)  = v216;
      char v85 = TRunGlue::DoGlyphInsertion(v84, (const unsigned __int16 *)&p_StringIndex, 1u, *((_DWORD *)v84 + 6) >= 0, 0, v79, v79, 1, 0);
      v169 |= v85;
      *(_DWORD *)(*v168 + 16 * v79 + 8)  = 3;
      ++*v76;
      ++v3;
      uint64_t v86 = 1;
    }
    else
    {
      uint64_t v86 = 1;
      if (v81 >= 1)
      {
        uint64_t v86 = v81 + 1;
        TRunGlue::Rotate(*(TRunGlue **)(v167 + 8), v79, v79 + v81, v81 + 1 + v79, v168);
        char v78 = 1;
      }
      if (v80 == 1) {
        goto LABEL_198;
      }
    }
    uint64_t v87 = v79;
    uint64_t v88 = v79 + v86;
    v79 += v3;
    if (v88 < v79)
    {
      uint64_t v89 = (16 * v88) | 8;
      while (1)
      {
        if (!TRunGlue::IsDeleted(*(TRunGlue **)(v167 + 8), v88))
        {
          unsigned int v90 = *(_DWORD *)(*v168 + v89);
          if (v90 > 0xE) {
            goto LABEL_205;
          }
          if (v90 == 14) {
            break;
          }
        }
        ++v88;
        v89 += 16;
        if (v88 >= v79)
        {
LABEL_205:
          uint64_t v82 = v167;
          goto LABEL_207;
        }
      }
      uint64_t v82 = v167;
      uint64_t v91 = TRunGlue::GlyphRangeForGlyphIndex(*(TRun ***)(v167 + 8), v88);
      uint64_t v88 = v91 + v92;
      TRunGlue::Rotate(*(TRunGlue **)(v167 + 8), v87, v91, v91 + v92, v168);
      char v78 = 1;
    }
LABEL_207:
    if (v88 < v79)
    {
      uint64_t v93 = 0;
      int64_t v3 = -1;
      do
      {
        unsigned int v94 = *(_DWORD *)(*v168 + 16 * v88 + 8);
        if (v94 > 0x12) {
          break;
        }
        if (v94 == 18 || v94 == 9)
        {
          uint64_t v96 = TRunGlue::GlyphRangeForGlyphIndex(*(TRun ***)(v82 + 8), v88);
          if (v96 >= v3) {
            int64_t v98 = v3;
          }
          else {
            int64_t v98 = v96;
          }
          uint64_t v99 = v3 + v93;
          if (v3 + v93 <= v96 + v97) {
            uint64_t v99 = v96 + v97;
          }
          uint64_t v100 = v99 - v98;
          BOOL v101 = v3 == -1;
          if (v3 == -1) {
            int64_t v3 = v96;
          }
          else {
            int64_t v3 = v98;
          }
          if (v101) {
            uint64_t v93 = v97;
          }
          else {
            uint64_t v93 = v100;
          }
          uint64_t v88 = v93 + v3 - 1;
        }
        ++v88;
      }
      while (v88 < v79);
      if (v3 != -1)
      {
        TRunGlue::Rotate(*(TRunGlue **)(v82 + 8), v87, v3, v93 + v3, v168);
        char v78 = 1;
      }
    }
    if (v88 >= v79) {
      break;
    }
    int64_t v3 = 0;
    uint64_t v102 = -1;
    do
    {
      if (!TRunGlue::IsDeleted(*(TRunGlue **)(v82 + 8), v88))
      {
        unsigned int v103 = *(_DWORD *)(*v168 + 16 * v88 + 8);
        if (v103 >= 0x14)
        {
          if (v103 != 20) {
            break;
          }
          uint64_t v104 = TRunGlue::GlyphRangeForGlyphIndex(*(TRun ***)(v82 + 8), v88);
          if (v104 >= v102) {
            uint64_t v106 = v102;
          }
          else {
            uint64_t v106 = v104;
          }
          uint64_t v107 = v102 + v3;
          if (v102 + v3 <= v104 + v105) {
            uint64_t v107 = v104 + v105;
          }
          int64_t v108 = v107 - v106;
          BOOL v109 = v102 == -1;
          if (v102 == -1) {
            uint64_t v102 = v104;
          }
          else {
            uint64_t v102 = v106;
          }
          if (v109) {
            int64_t v3 = v105;
          }
          else {
            int64_t v3 = v108;
          }
          uint64_t v88 = v3 + v102 - 1;
        }
      }
      ++v88;
    }
    while (v88 < v79);
    if (v102 == -1) {
      break;
    }
    v3 += v102;
    if (v3 >= v79) {
      break;
    }
    uint64_t v110 = 0;
    uint64_t v111 = -1;
    do
    {
      if (!TRunGlue::IsDeleted(*(TRunGlue **)(v82 + 8), v3))
      {
        if (*(_DWORD *)(*v168 + 16 * v3 + 8) != 21) {
          break;
        }
        uint64_t v112 = TRunGlue::GlyphRangeForGlyphIndex(*(TRun ***)(v82 + 8), v3);
        if (v112 >= v111) {
          uint64_t v114 = v111;
        }
        else {
          uint64_t v114 = v112;
        }
        uint64_t v115 = v111 + v110;
        if (v111 + v110 <= v112 + v113) {
          uint64_t v115 = v112 + v113;
        }
        uint64_t v116 = v115 - v114;
        BOOL v117 = v111 == -1;
        if (v111 == -1) {
          uint64_t v111 = v112;
        }
        else {
          uint64_t v111 = v114;
        }
        if (v117) {
          uint64_t v110 = v113;
        }
        else {
          uint64_t v110 = v116;
        }
        int64_t v3 = v110 + v111 - 1;
      }
      ++v3;
    }
    while (v3 < v79);
    if (v111 == -1) {
      break;
    }
    TRunGlue::Rotate(*(TRunGlue **)(v82 + 8), v102, v111, v110 + v111, v168);
    v76 += 2;
    char v78 = 1;
    unint64_t v73 = 3;
    if (v76 == v77) {
      goto LABEL_272;
    }
  }
  unint64_t v73 = 3;
LABEL_270:
  v76 += 2;
  if (v76 != v77) {
    goto LABEL_188;
  }
  if ((v78 & 1) == 0) {
    goto LABEL_276;
  }
LABEL_272:
  v169  = 1;
  if (*(void *)(*(void *)(v167 + 8) + 152))
  {
    uint64_t v118 = v211;
    uint64_t v119 = v212;
    if (v211 != v212)
    {
      CFIndex v120 = 0;
      do
      {
        CFIndex v121 = *v118;
        v118 += 2;
        v230.CFIndex location = v120;
        v230.CFIndex length = v121;
        TRunGlue::ClearSafeToBreakAfter(*(void *)(v167 + 8), v230);
        v120 += v121;
      }
      while (v118 != v119);
    }
  }
LABEL_276:
  memset(v209, 170, sizeof(v209));
  long long v208 = 0uLL;
  p_StringIndeCGFloat x = 0;
  __int16 v210 = v209;
  *(void *)&long long v122 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v122 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  long long v204 = v122;
  long long v205 = v122;
  long long v202 = v122;
  long long v203 = v122;
  long long v200 = v122;
  long long v201 = v122;
  long long v198 = v122;
  long long v199 = v122;
  long long v196 = v122;
  long long v197 = v122;
  long long v194 = v122;
  v195  = v122;
  long long v192 = v122;
  v193  = v122;
  v190  = v122;
  v191  = v122;
  long long v189 = v122;
  long long v188 = v122;
  long long v187 = v122;
  long long v186 = v122;
  long long v185 = v122;
  long long v184 = v122;
  long long v183 = v122;
  long long v182 = v122;
  long long v181 = v122;
  long long v180 = v122;
  v179  = v122;
  long long v178 = v122;
  long long v177 = v122;
  long long v176 = v122;
  uint64_t v123 = (uint64_t)v166;
  StringIndeCGFloat x = (uint64_t)v166;
  p_p_StringIndeCGFloat x = &p_StringIndex;
  uint64_t v124 = v211;
  id v125 = v212;
  long long v175 = 0uLL;
  unsigned int v174 = 0;
  uint64_t v206 = &v176;
  uint64_t v126 = (char *)v212 - (char *)v211;
  if (v212 != v211)
  {
    if (v126 < 0) {
      abort();
    }
    uint64_t v127 = v126 >> 4;
    unsigned int v128 = TInlineBufferAllocator<CGPoint,30ul>::allocate((uint64_t)&v176, v126 >> 4);
    uint64_t v129 = 0;
    unsigned int v174 = (uint64_t *)v128;
    *((void *)&v175 + 1)  = &v128[16 * v127];
    do
    {
      *(_OWORD *)&v128[v129 * 8]  = *(_OWORD *)&v124[v129];
      v129 += 2;
    }
    while (&v124[v129] != v125);
    *(void *)&long long v175 = &v128[v129 * 8];
    uint64_t v123 = StringIndex;
    *(void *)&long long v122 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v122 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  }
  v227  = 0xAAAAAAAAAAAAAAAALL;
  v226  = v122;
  long long v225 = v122;
  long long v224 = v122;
  long long v223 = v122;
  v222  = v122;
  v221  = v122;
  long long v220 = v122;
  v219  = 0;
  v218  = 0uLL;
  v170  = 1919969382;
  v228  = &v220;
  OTL::FeatureBuffer::FeatureBuffer<unsigned int const*>((char **)&v216, &v170, &v171);
  OTL::GCommon::GetLookups(v123, (uint64_t)&v216, (uint64_t)&v218, 0);
  uint64_t v171 = (void **)&v216;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](&v171);
  int v131 = v174;
  uint64_t v130 = (uint64_t *)v175;
  if (v174 != (uint64_t *)v175)
  {
    uint64_t v132 = 0;
    do
    {
      uint64_t v133 = *v131;
      unint64_t v134 = (unsigned int *)*((void *)&v218 + 1);
      uint64_t v135 = (unsigned int *)v218;
      if ((void)v218 != *((void *)&v218 + 1))
      {
        unint64_t v73 = (unint64_t)p_p_StringIndex;
        do
        {
          unsigned int v136 = *v135++;
          int64_t v3 = v3 & 0xFFFFFFFF00000000 | v136;
          OTL::GlyphLookups::SetLookupInRange<false>((uint64_t *)v73, v3, v132, v133);
        }
        while (v135 != v134);
      }
      v132 += v133;
      v131 += 2;
    }
    while (v131 != v130);
  }
  *(void *)&v216  = &v218;
  std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v216);
  *(void *)&long long v137 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v137 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  v226  = v137;
  long long v225 = v137;
  long long v224 = v137;
  long long v223 = v137;
  v222  = v137;
  v221  = v137;
  long long v220 = v137;
  v219  = 0;
  v218  = 0uLL;
  v227  = 0xAAAAAAAAAAAAAAAALL;
  v228  = &v220;
  uint64_t v138 = StringIndex;
  v170  = 1886545254;
  OTL::FeatureBuffer::FeatureBuffer<unsigned int const*>((char **)&v216, &v170, &v171);
  OTL::GCommon::GetLookups(v138, (uint64_t)&v216, (uint64_t)&v218, 0);
  uint64_t v171 = (void **)&v216;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](&v171);
  unint64_t v139 = (unint64_t)v174;
  unint64_t v140 = v175;
  if (v174 != (uint64_t *)v175)
  {
    uint64_t v141 = 0;
    do
    {
      uint64_t v142 = *(void *)v139;
      unint64_t v143 = (unsigned int *)*((void *)&v218 + 1);
      long long v144 = (unsigned int *)v218;
      if ((void)v218 != *((void *)&v218 + 1))
      {
        __int16 v145 = (uint64_t *)p_p_StringIndex;
        do
        {
          unsigned int v146 = *v144++;
          unint64_t v73 = v73 & 0xFFFFFFFF00000000 | v146;
          OTL::GlyphLookups::SetLookupInRange<false>(v145, v73, v141, v142);
        }
        while (v144 != v143);
      }
      v141 += v142;
      v139 += 16;
    }
    while (v139 != v140);
  }
  *(void *)&v216  = &v218;
  std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v216);
  *(void *)&long long v147 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v147 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  v226  = v147;
  long long v225 = v147;
  long long v224 = v147;
  long long v223 = v147;
  v222  = v147;
  v221  = v147;
  long long v220 = v147;
  v219  = 0;
  v218  = 0uLL;
  v227  = 0xAAAAAAAAAAAAAAAALL;
  v228  = &v220;
  v170  = 1651275622;
  uint64_t v148 = StringIndex;
  OTL::FeatureBuffer::FeatureBuffer<unsigned int const*>((char **)&v216, &v170, &v171);
  OTL::GCommon::GetLookups(v148, (uint64_t)&v216, (uint64_t)&v218, 0);
  uint64_t v171 = (void **)&v216;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](&v171);
  uint64_t v149 = v174;
  unsigned int v150 = (uint64_t *)v175;
  if (v174 != (uint64_t *)v175)
  {
    uint64_t v151 = 0;
    do
    {
      uint64_t v152 = *v149;
      int64_t v153 = (unsigned int *)*((void *)&v218 + 1);
      int64_t v154 = (unsigned int *)v218;
      if ((void)v218 != *((void *)&v218 + 1))
      {
        unint64_t v139 = (unint64_t)p_p_StringIndex;
        do
        {
          unsigned int v155 = *v154++;
          unint64_t v140 = v140 & 0xFFFFFFFF00000000 | v155;
          OTL::GlyphLookups::SetLookupInRange<false>((uint64_t *)v139, v140, v151, v152);
        }
        while (v154 != v153);
      }
      v151 += v152;
      v149 += 2;
    }
    while (v149 != v150);
  }
  *(void *)&v216  = &v218;
  std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v216);
  *(void *)&long long v156 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v156 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  v226  = v156;
  long long v225 = v156;
  long long v224 = v156;
  long long v223 = v156;
  v222  = v156;
  v221  = v156;
  long long v220 = v156;
  v219  = 0;
  v218  = 0uLL;
  v227  = 0xAAAAAAAAAAAAAAAALL;
  v228  = &v220;
  v157  = StringIndex;
  v170  = 1886614630;
  OTL::FeatureBuffer::FeatureBuffer<unsigned int const*>((char **)&v216, &v170, &v171);
  OTL::GCommon::GetLookups(v157, (uint64_t)&v216, (uint64_t)&v218, 0);
  uint64_t v171 = (void **)&v216;
  std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100](&v171);
  uint64_t v158 = v174;
  uint64_t v159 = (uint64_t *)v175;
  if (v174 != (uint64_t *)v175)
  {
    uint64_t v160 = 0;
    do
    {
      uint64_t v161 = *v158;
      unint64_t v162 = (unsigned int *)*((void *)&v218 + 1);
      unint64_t v163 = (unsigned int *)v218;
      if ((void)v218 != *((void *)&v218 + 1))
      {
        unsigned int v164 = (uint64_t *)p_p_StringIndex;
        do
        {
          unsigned int v165 = *v163++;
          unint64_t v139 = v139 & 0xFFFFFFFF00000000 | v165;
          OTL::GlyphLookups::SetLookupInRange<false>(v164, v139, v160, v161);
        }
        while (v163 != v162);
      }
      v160 += v161;
      v158 += 2;
    }
    while (v158 != v159);
  }
  *(void *)&v216  = &v218;
  std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v216);
  OTL::GSUB::ApplyLookups(v166, *(TRunGlue **)(v167 + 8), *(_DWORD *)(*(void *)(v167 + 8) + 24), &p_StringIndex, &v169, 0, 0);
  std::vector<TGlyphAuxDataListEntry,TInlineBufferAllocator<TGlyphAuxDataListEntry,30ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v174);
  StringIndeCGFloat x = (uint64_t)&p_StringIndex;
  std::vector<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,TInlineBufferAllocator<std::pair<std::pair<unsigned short,unsigned short>,TInlineVector<CFRange,4ul>>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&StringIndex);
  std::vector<TGlyphAuxDataListEntry,TInlineBufferAllocator<TGlyphAuxDataListEntry,30ul>>::__destroy_vector::operator()[abi:nn180100]((uint64_t)&v211);
  return v169;
}

void std::vector<TGlyphAuxDataListEntry,TInlineBufferAllocator<TGlyphAuxDataListEntry,30ul>>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 4;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8)  = *(void *)a1 + 16 * a2;
    }
  }
  else
  {
    std::vector<TGlyphAuxDataListEntry,TInlineBufferAllocator<TGlyphAuxDataListEntry,30ul>>::__append((char **)a1, a2 - v2);
  }
}

uint64_t IsGenericBase(int a1)
{
  uint64_t result = 1;
  if (a1 > 9675)
  {
    unsigned int v3 = a1 - 9676;
    if (v3 > 0x32 || ((1 << v3) & 0x7800000000001) == 0) {
      return 0;
    }
  }
  else if (((a1 - 8210) > 0x10 || ((1 << (a1 - 18)) & 0x1000F) == 0) && a1 != 160 && a1 != 215)
  {
    return 0;
  }
  return result;
}

void std::vector<TGlyphAuxDataListEntry,TInlineBufferAllocator<TGlyphAuxDataListEntry,30ul>>::__append(char **a1, unint64_t a2)
{
  uint64_t v5 = a1[1];
  uint64_t v4 = a1[2];
  if (a2 <= (v4 - v5) >> 4)
  {
    if (a2)
    {
      bzero(a1[1], 16 * a2);
      v5 += 16 * a2;
    }
    a1[1]  = v5;
  }
  else
  {
    uint64_t v6 = (uint64_t)(a1 + 3);
    uint64_t v7 = v5 - *a1;
    unint64_t v8 = a2 + (v7 >> 4);
    if (v8 >> 60) {
      abort();
    }
    uint64_t v9 = v7 >> 4;
    uint64_t v10 = v4 - *a1;
    if (v10 >> 3 > v8) {
      unint64_t v8 = v10 >> 3;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v11 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v8;
    }
    uint64_t v23 = (uint64_t *)(a1 + 3);
    if (v11) {
      uint64_t v12 = TInlineBufferAllocator<CGPoint,30ul>::allocate(v6, v11);
    }
    else {
      uint64_t v12 = 0;
    }
    uint64_t v13 = &v12[16 * v9];
    uint64_t v14 = &v12[16 * v11];
    bzero(v13, 16 * a2);
    unint64_t v15 = &v13[16 * a2];
    long long v16 = *a1;
    unint64_t v17 = (unint64_t)a1[1];
    if ((char *)v17 == *a1)
    {
      int64x2_t v18 = vdupq_n_s64(v17);
    }
    else
    {
      do
      {
        *((_OWORD *)v13 - 1)  = *(_OWORD *)(v17 - 16);
        v13 -= 16;
        v17 -= 16;
      }
      while ((char *)v17 != v16);
      int64x2_t v18 = *(int64x2_t *)a1;
    }
    *a1  = v13;
    a1[1]  = v15;
    int64x2_t v21 = v18;
    uint64_t v19 = a1[2];
    a1[2]  = v14;
    int64x2_t v22 = v19;
    uint64_t v20 = v18.i64[0];
    std::__split_buffer<std::tuple<unsigned short,unsigned short,long>,TInlineBufferAllocator<std::tuple<unsigned short,unsigned short,long>,30ul> &>::~__split_buffer((uint64_t)&v20);
  }
}

void std::__function::__func<MyanmarShapingEngine::AnalyzeCharacters(TInlineVector<std::tuple<long,MyanmarShapingEngine::ClusterType,BOOL>,30ul> *)::$_0,std::allocator<MyanmarShapingEngine::AnalyzeCharacters(TInlineVector<std::tuple<long,MyanmarShapingEngine::ClusterType,BOOL>,30ul> *)::$_0>,void ()(CFRange,MyanmarShapingEngine::ClusterType,BOOL)>::~__func()
{
}

void *std::__function::__func<MyanmarShapingEngine::AnalyzeCharacters(TInlineVector<std::tuple<long,MyanmarShapingEngine::ClusterType,BOOL>,30ul> *)::$_0,std::allocator<MyanmarShapingEngine::AnalyzeCharacters(TInlineVector<std::tuple<long,MyanmarShapingEngine::ClusterType,BOOL>,30ul> *)::$_0>,void ()(CFRange,MyanmarShapingEngine::ClusterType,BOOL)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1ED0616B8;
  result[1]  = v3;
  return result;
}

uint64_t std::__function::__func<MyanmarShapingEngine::AnalyzeCharacters(TInlineVector<std::tuple<long,MyanmarShapingEngine::ClusterType,BOOL>,30ul> *)::$_0,std::allocator<MyanmarShapingEngine::AnalyzeCharacters(TInlineVector<std::tuple<long,MyanmarShapingEngine::ClusterType,BOOL>,30ul> *)::$_0>,void ()(CFRange,MyanmarShapingEngine::ClusterType,BOOL)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2  = &unk_1ED0616B8;
  a2[1]  = v2;
  return result;
}

void std::__function::__func<MyanmarShapingEngine::AnalyzeCharacters(TInlineVector<std::tuple<long,MyanmarShapingEngine::ClusterType,BOOL>,30ul> *)::$_0,std::allocator<MyanmarShapingEngine::AnalyzeCharacters(TInlineVector<std::tuple<long,MyanmarShapingEngine::ClusterType,BOOL>,30ul> *)::$_0>,void ()(CFRange,MyanmarShapingEngine::ClusterType,BOOL)>::operator()(uint64_t a1, uint64_t a2, int *a3, char *a4)
{
  uint64_t v4 = *(void *)(a2 + 8);
  int v5 = *a3;
  char v6 = *a4;
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v9 = *(void **)(v7 + 8);
  unint64_t v8 = *(void *)(v7 + 16);
  if ((unint64_t)v9 >= v8)
  {
    unint64_t v11 = *(void **)v7;
    uint64_t v12 = ((uint64_t)v9 - *(void *)v7) >> 4;
    unint64_t v13 = v12 + 1;
    if ((unint64_t)(v12 + 1) >> 60) {
      abort();
    }
    uint64_t v14 = v8 - (void)v11;
    if (v14 >> 3 > v13) {
      unint64_t v13 = v14 >> 3;
    }
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v15 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v15 = v13;
    }
    if (v15)
    {
      long long v16 = TInlineBufferAllocator<CGPoint,30ul>::allocate(v7 + 24, v15);
      unint64_t v11 = *(void **)v7;
      uint64_t v9 = *(void **)(v7 + 8);
    }
    else
    {
      long long v16 = 0;
    }
    unint64_t v17 = &v16[16 * v12];
    *(void *)unint64_t v17 = v4;
    *((_DWORD *)v17 + 2)  = v5;
    v17[12]  = v6;
    int64x2_t v18 = v17;
    if (v9 != v11)
    {
      do
      {
        *((_OWORD *)v18 - 1)  = *((_OWORD *)v9 - 1);
        v18 -= 16;
        v9 -= 2;
      }
      while (v9 != v11);
      unint64_t v11 = *(void **)v7;
    }
    uint64_t v10 = v17 + 16;
    *(void *)uint64_t v7 = v18;
    *(void *)(v7 + 8)  = v17 + 16;
    uint64_t v19 = *(void *)(v7 + 16);
    *(void *)(v7 + 16)  = &v16[16 * v15];
    if (v11)
    {
      uint64_t v20 = (void *)(v7 + 504);
      if (v7 + 24 <= (unint64_t)v11 && v20 > v11)
      {
        if (v19 == *v20) {
          *uint64_t v20 = v11;
        }
      }
      else
      {
        operator delete(v11);
      }
    }
  }
  else
  {
    void *v9 = v4;
    *((_DWORD *)v9 + 2)  = v5;
    uint64_t v10 = (char *)(v9 + 2);
    *((unsigned char *)v9 + 12)  = v6;
  }
  *(void *)(v7 + 8)  = v10;
}

BOOL IsLooseFontNameMatchingDisabled(void)
{
  if (gDisableLooseFontNameMatchingOverride) {
    return 1;
  }
  if (IsLooseFontNameMatchingDisabled(void)::onceToken != -1) {
    dispatch_once(&IsLooseFontNameMatchingDisabled(void)::onceToken, &__block_literal_global_2);
  }
  return gDisableLooseFontNameMatchingOverride != 0;
}

uint64_t ___Z31IsLooseFontNameMatchingDisabledv_block_invoke()
{
  uint64_t result = objc_msgSend((id)objc_msgSend((id)CTFontGetPlistFromGSFontCache(@"CoreTextConfig.plist", 0), "objectForKey:", @"StrictMatch"), "BOOLValue");
  gDisableLooseFontNameMatchingOverride  = result;
  return result;
}

void CopyPostScriptNameForAliasLowercased(const __CFString *a1@<X0>, void *a2@<X8>)
{
  if (qword_1EB2CE8E8 != -1) {
    dispatch_once(&qword_1EB2CE8E8, &__block_literal_global_107);
  }
  if (qword_1EB2CE8E0
    && (CFDictionaryRef v4 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)qword_1EB2CE8E0, @"Aliases")) != 0)
  {
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v4, @"Faces");
    if (Value) {
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(Value, a1);
    }
  }
  else
  {
    CFDictionaryRef Value = 0;
  }
  id v6 = Value;
  *a2  = atomic_exchange((atomic_ullong *volatile)&v6, 0);
}

BOOL IsPostScriptNameAlias(const __CFString *a1, const __CFString *a2)
{
  id v8 = (id)0xAAAAAAAAAAAAAAAALL;
  CopyLowercasedString(a1, &v8);
  CopyPostScriptNameForAliasLowercased((const __CFString *)atomic_load_explicit((atomic_ullong *volatile)&v8, memory_order_acquire), &v7);
  CFStringRef v3 = (const __CFString *)(id)atomic_load_explicit((atomic_ullong *volatile)&v7, memory_order_acquire);
  CFDictionaryRef v4 = (__CFString *)v3;
  if (v3 == a2)
  {
    BOOL v5 = 1;
  }
  else
  {
    BOOL v5 = 0;
    if (a2 && v3) {
      BOOL v5 = CFStringCompare(v3, a2, 1uLL) == kCFCompareEqualTo;
    }
  }

  return v5;
}

BOOL IsInvisibleSystemFontName(const __CFString *a1)
{
  CopyAttributeForSystemFont(a1, @"CTFontInvisibleAttribute", (const __CFString **)&v4);
  CFNumberRef v1 = (const __CFNumber *)atomic_exchange((atomic_ullong *volatile)&v4, 0);

  if (v1)
  {
    int valuePtr = -1431655766;
    CFNumberGetValue(v1, kCFNumberIntType, &valuePtr);
    BOOL v2 = valuePtr != 0;
  }
  else
  {
    BOOL v2 = 0;
  }

  return v2;
}

const void *IsInvisibleSystemFontPostScriptNameWithoutPrecedingPeriod(const void *value)
{
  if (value)
  {
    CFNumberRef v1 = value;
    if (qword_1EB2CE8C8 != -1) {
      dispatch_once(&qword_1EB2CE8C8, &__block_literal_global_34);
    }
    value  = (const void *)qword_1EB2CE8C0;
    if (qword_1EB2CE8C0) {
      return (const void *)(CFSetContainsValue((CFSetRef)qword_1EB2CE8C0, v1) != 0);
    }
  }
  return value;
}

void ___Z57IsInvisibleSystemFontPostScriptNameWithoutPrecedingPeriodPK10__CFString_block_invoke()
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  long long v5 = xmmword_1E52903A0;
  long long v6 = *(_OWORD *)&off_1E52903B0;
  long long v7 = xmmword_1E52903C0;
  *(_OWORD *)id values = xmmword_1E5290360;
  long long v2 = *(_OWORD *)&off_1E5290370;
  long long v3 = xmmword_1E5290380;
  long long v4 = *(_OWORD *)&off_1E5290390;
  id v0 = CFSetCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)values, 14, MEMORY[0x1E4F1D548]);
  qword_1EB2CE8C0  = atomic_exchange((atomic_ullong *volatile)&v0, 0);
}

uint64_t GetFontFormat(const __CFString *a1)
{
  if (!a1) {
    return 0;
  }
  unsigned int valuePtr = 0;
  CopyAttributeForSystemFont(a1, @"NSCTFontFormatAttribute", (const __CFString **)&v4);
  CFNumberRef v1 = (const __CFNumber *)atomic_exchange((atomic_ullong *volatile)&v4, 0);

  if (v1) {
    CFNumberGetValue(v1, kCFNumberSInt32Type, &valuePtr);
  }
  uint64_t v2 = valuePtr;

  return v2;
}

BOOL GetStringEncodingSpecialCase(BOOL key, unsigned int *a2)
{
  if (key)
  {
    long long v3 = (const void *)key;
    if (qword_1EB2CE8D8 != -1) {
      dispatch_once_f(&qword_1EB2CE8D8, 0, (dispatch_function_t)GetStringEncodingSpecialCase(__CFString const*,unsigned int *)::$_0::__invoke);
    }
    value  = (void *)0xAAAAAAAAAAAAAAAALL;
    ValueIfPresent  = CFDictionaryGetValueIfPresent((CFDictionaryRef)qword_1EB2CE8D0, v3, (const void **)&value);
    kedouble y = ValueIfPresent != 0;
    if (ValueIfPresent) {
      *a2  = value;
    }
  }
  return key;
}

uint64_t ___ZL23FontServicesLibraryCorePPc_block_invoke()
{
  uint64_t result = _sl_dlopen();
  FontServicesLibraryCore(char **)::frameworkLibrardouble y = result;
  return result;
}

void GetStringEncodingSpecialCase(__CFString const*,unsigned int *)::$_0::__invoke()
{
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  id Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 29, MEMORY[0x1E4F1D530], 0);
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CFA0];
  long long v3 = &GetStringEncodingSpecialCase(__CFString const*,unsigned int *)::kPostScriptNameToEncodingMap;
  do
  {
    id v4 = (const void *)*((unsigned int *)v3 + 2);
    CFStringRef v5 = CFStringCreateWithCStringNoCopy(v0, *v3, 0x600u, v2);
    if (v5)
    {
      CFStringRef v6 = v5;
      CFDictionaryAddValue(Mutable, v5, v4);
      CFRelease(v6);
    }
    v3 += 2;
  }
  while (v3 != (char **)&xmmword_1E52905A0);
  qword_1EB2CE8D0  = (uint64_t)Mutable;
}

char *GetUncompressedBitmapRepresentation(char *result, uint64_t a2, int a3, char *__dst)
{
  int v5 = *((_DWORD *)result + 1);
  uint64_t v6 = a2 - (v5 & 1);
  long long v7 = result + 8;
  uint64_t v8 = &result[v6];
  while (v7 < v8)
  {
    unsigned int v11 = *(unsigned __int16 *)v7;
    uint64_t v10 = v7 + 2;
    uint64_t result = (char *)memcpy(__dst, v10, 2 * v11);
    long long v7 = &v10[2 * v11];
    __dst += 2 * v11;
    if (v7 < v8)
    {
      unsigned int v12 = *(unsigned __int16 *)v7;
      v7 += 2;
      uint64_t result = (char *)memset(__dst, a3, 2 * v12);
      __dst += 2 * v12;
    }
  }
  if (v5) {
    *__dst  = *v7;
  }
  return result;
}

void CreateFontWithData(const __CFData *a1@<X0>, atomic_ullong *a2@<X8>)
{
  *a2  = 0;
  long long v3 = CGDataProviderCreateWithCFData(a1);
  if (v3)
  {
    id v4 = v3;

    CFRelease(v4);
  }
}

void CreateMemorySafeFontWithData(const __CFData *a1@<X0>, atomic_ullong *a2@<X8>)
{
  *a2  = 0;
  if (!a1) {
    return;
  }
  MemorySafeFontsFromData  = (void *)FPFontCreateMemorySafeFontsFromData();
  CFArrayRef v4 = MemorySafeFontsFromData;
  if (!v4) {
    goto LABEL_5;
  }
  CFArrayRef v5 = v4;
  CFIndex Count = CFArrayGetCount(v4);

  if (Count)
  {
    CFArrayGetValueAtIndex((CFArrayRef)MemorySafeFontsFromData, 0);
    CFArrayRef v4 = (const __CFArray *)atomic_exchange(a2, CGFontCreateWithParserFont());
LABEL_5:
  }
}

void CopyPathFromInMemoryFontURL(const __CFURL *a1@<X0>, CFStringRef *a2@<X8>)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    *(void *)&long long v3 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v3 + 1)  = 0xAAAAAAAAAAAAAAAALL;
    v9[11]  = v3;
    v9[10]  = v3;
    v9[9]  = v3;
    v9[8]  = v3;
    v9[7]  = v3;
    v9[6]  = v3;
    v9[4]  = v3;
    void v9[5] = v3;
    v9[2]  = v3;
    v9[3]  = v3;
    v9[0]  = v3;
    v9[1]  = v3;
    memset(v8, 0, sizeof(v8));
    uint64_t v10 = v9;
    BytesForComponent  = GetBytesForComponent(a1, v8);
    if (BytesForComponent == -1) {
      CFStringRef v6 = 0;
    }
    else {
      CFStringRef v6 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &v8[0][BytesForComponent], v5, 0x8000100u, 0);
    }
    *a2  = v6;
    long long v7 = v8;
    std::vector<std::pair<OTL::LookupSubtable const*,OTL::Coverage>,TInlineBufferAllocator<std::pair<OTL::LookupSubtable const*,OTL::Coverage>,4ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v7);
  }
  else
  {
    *a2  = 0;
  }
}

void CreateMaskedPath(const CGPath *a1@<X0>, CGPathRef path@<X1>, CGFloat a3@<D0>, CGAffineTransform *a4@<X2>, char a5@<W3>, void *a6@<X8>)
{
  SeparateComponents  = CGPathCreateSeparateComponents(path, 0);
  CGMutablePathRef Mutable = CGPathCreateMutable();
  if (SeparateComponents)
  {
    CFIndex Count = CFArrayGetCount(SeparateComponents);
    if (Count)
    {
      CFIndex v12 = Count;
      for (CFIndex i = 0; i != v12; ++i)
      {
        CFArrayGetValueAtIndex(SeparateComponents, i);
        v30[1]  = (id)MEMORY[0x1E4F143A8];
        v30[2]  = (id)3321888768;
        id v30[3] = ___Z16CreateMaskedPathPK6CGPathS1_dP17CGAffineTransformb_block_invoke;
        v30[4]  = &__block_descriptor_48_8_32c21_ZTS6TCFRefIP6CGPathE_e40_v24__0r__CGPathElement_i__CGPoint__8_B16l;
        id v31 = Mutable;
        uint64_t v32 = a4;
        CGPathApplyWithBlock2();
      }
    }
  }
  v30[0]  = CGPathCreateCopyByStrokingPath(Mutable, 0, a3, kCGLineCapButt, kCGLineJoinRound, 0.0);
  uint64_t v14 = a1;
  if (a5)
  {
    BoundingBoCGFloat x = CGPathGetBoundingBox(a1);
    CGFloat x = BoundingBox.origin.x;
    CGFloat y = BoundingBox.origin.y;
    CGFloat width = BoundingBox.size.width;
    height  = BoundingBox.size.height;
    uint64_t v19 = CGPathCreateMutable();
    v34.origin.CGFloat x = x;
    v34.origin.CGFloat y = y;
    v34.size.CGFloat width = width;
    v34.size.height  = height;
    v35.origin.CGFloat x = CGRectGetMinX(v34);
    v35.origin.CGFloat y = y;
    v35.size.CGFloat width = a3;
    v35.size.height  = height;
    CGPathAddRect(v19, 0, v35);
    v36.origin.CGFloat x = x;
    v36.origin.CGFloat y = y;
    v36.size.CGFloat width = width;
    v36.size.height  = height;
    v37.origin.CGFloat x = CGRectGetMaxX(v36);
    v37.size.CGFloat width = -a3;
    v37.origin.CGFloat y = y;
    v37.size.height  = height;
    CGPathAddRect(v19, 0, v37);
    CopyBySubtractingPath  = CGPathCreateCopyBySubtractingPath((CGPathRef)atomic_load_explicit((atomic_ullong *volatile)v30, memory_order_acquire), v19, 0);
  }
  CopyBySubtractingPath  = CGPathCreateCopyByUnioningPath((CGPathRef)atomic_load_explicit((atomic_ullong *volatile)v30, memory_order_acquire), Mutable, 0);

  uint64_t v20 = CGPathCreateCopyBySubtractingPath(v14, (CGPathRef)atomic_load_explicit((atomic_ullong *volatile)v30, memory_order_acquire), 0);
  CFArrayRef v21 = CGPathCreateSeparateComponents(v20, 0);
  CopyBySubtractingPath  = CGPathCreateMutable();
  if (v21)
  {
    CFIndex v22 = CFArrayGetCount(v21);
    if (v22)
    {
      CFIndex v23 = v22;
      for (CFIndex j = 0; j != v23; ++j)
      {
        CFStringRef ValueAtIndex = (const CGPath *)CFArrayGetValueAtIndex(v21, j);
        PathBoundingBoCGFloat x = CGPathGetPathBoundingBox(ValueAtIndex);
        if (PathBoundingBox.size.width >= a3 || PathBoundingBox.size.height >= a3) {
          CGPathAddPath((CGMutablePathRef)atomic_load_explicit((atomic_ullong *volatile)&CopyBySubtractingPath, memory_order_acquire), 0, ValueAtIndex);
        }
      }
    }
  }
  *a6  = atomic_exchange((atomic_ullong *volatile)&CopyBySubtractingPath, 0);
}

void ___Z16CreateMaskedPathPK6CGPathS1_dP17CGAffineTransformb_block_invoke(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  switch(*(_DWORD *)a2)
  {
    case 0:
      CFDataRef explicit = (CGPath *)atomic_load_explicit((atomic_ullong *volatile)(a1 + 32), memory_order_acquire);
      CFArrayRef v4 = *(const CGAffineTransform **)(a1 + 40);
      CFIndex v5 = *(double **)(a2 + 8);
      CGFloat v6 = *v5;
      CGFloat v7 = v5[1];
      CGPathMoveToPoint(explicit, v4, v6, v7);
      break;
    case 1:
      uint64_t v8 = (CGPath *)atomic_load_explicit((atomic_ullong *volatile)(a1 + 32), memory_order_acquire);
      uint64_t v9 = *(const CGAffineTransform **)(a1 + 40);
      uint64_t v10 = *(double **)(a2 + 8);
      CGFloat v11 = *v10;
      CGFloat v12 = v10[1];
      CGPathAddLineToPoint(v8, v9, v11, v12);
      break;
    case 2:
      unint64_t v13 = (CGPath *)atomic_load_explicit((atomic_ullong *volatile)(a1 + 32), memory_order_acquire);
      uint64_t v14 = *(const CGAffineTransform **)(a1 + 40);
      unint64_t v15 = *(double **)(a2 + 8);
      CGFloat v16 = *v15;
      CGFloat v17 = v15[1];
      CGFloat v18 = v15[2];
      CGFloat v19 = v15[3];
      CGPathAddQuadCurveToPoint(v13, v14, v16, v17, v18, v19);
      break;
    case 3:
      uint64_t v20 = (CGPath *)atomic_load_explicit((atomic_ullong *volatile)(a1 + 32), memory_order_acquire);
      CFArrayRef v21 = *(const CGAffineTransform **)(a1 + 40);
      CFIndex v22 = *(double **)(a2 + 8);
      CGFloat v23 = *v22;
      CGFloat v24 = v22[1];
      CGFloat v25 = v22[2];
      CGFloat v26 = v22[3];
      CGFloat v27 = v22[4];
      CGFloat v28 = v22[5];
      CGPathAddCurveToPoint(v20, v21, v23, v24, v25, v26, v27, v28);
      break;
    case 4:
      CGPathCloseSubpath((CGMutablePathRef)atomic_load_explicit((atomic_ullong *volatile)(a1 + 32), memory_order_acquire));
      *a3  = 1;
      break;
    default:
      return;
  }
}

id __copy_helper_block_8_32c21_ZTS6TCFRefIP6CGPathE(uint64_t a1, uint64_t a2)
{
  id result = (id)atomic_load_explicit((atomic_ullong *volatile)(a2 + 32), memory_order_acquire);
  *(void *)(a1 + 32)  = result;
  return result;
}

void __destroy_helper_block_8_32c21_ZTS6TCFRefIP6CGPathE(uint64_t a1)
{
}

void TArabicJustEngine::PostcompTable(TArabicJustEngine *this@<X0>, unint64_t *a2@<X8>)
{
  id Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(*((void *)this + 1) + 56), memory_order_acquire);
  if (explicit) {
    GlyphCFIndex Count = TBaseFont::GetGlyphCount(*(TBaseFont **)(*(void *)(explicit + 40) + 400));
  }
  else {
    GlyphCFIndex Count = 0;
  }
  CGFloat v6 = NewLKTHandle(GlyphCount, 0);
  for (CFIndex i = (uint64_t **)*((void *)this + 6); i; CFIndex i = (uint64_t **)*i)
    LKTAddRange(v6, *((unsigned __int16 *)i + 8), *((unsigned __int16 *)i + 8), 1);
  LKTCreateLookupTable(v6, (atomic_ullong *)&v23);
  if (atomic_load_explicit((atomic_ullong *volatile)&v23, memory_order_acquire)) {
    CFIndex Length = CFDataGetLength((CFDataRef)atomic_load_explicit((atomic_ullong *volatile)&v23, memory_order_acquire));
  }
  else {
    CFIndex Length = 0;
  }

  for (CFIndex j = (uint64_t **)*((void *)this + 6); j; CFIndex j = (uint64_t **)*j)
    LKTAddRange(v6, *((unsigned __int16 *)j + 8), *((unsigned __int16 *)j + 8), Length);
  id v22 = (id)0xAAAAAAAAAAAAAAAALL;
  LKTCreateLookupTable(v6, (atomic_ullong *)&v22);
  DisposeLKTHandle(v6);
  unint64_t v10 = atomic_load_explicit((atomic_ullong *volatile)&v22, memory_order_acquire);
  if (v10)
  {
    CGFloat v11 = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
    BytePtr  = CFDataGetBytePtr((CFDataRef)atomic_load_explicit((atomic_ullong *volatile)&v22, memory_order_acquire));
    CFDataAppendBytes(v11, BytePtr, Length);
    unint64_t v13 = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
    *(_DWORD *)bytes  = 0x2000000;
    CFDataAppendBytes(v13, bytes, 4);
    __int16 v14 = 0;
    char v15 = 1;
    do
    {
      char v16 = v15;
      CGFloat v17 = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      *(_WORD *)bytes  = v14;
      CFDataAppendBytes(v17, bytes, 2);
      CGFloat v18 = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      *(_WORD *)bytes  = 1280;
      CFDataAppendBytes(v18, bytes, 2);
      CGFloat v19 = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      *(_DWORD *)bytes  = 201326592;
      CFDataAppendBytes(v19, bytes, 4);
      uint64_t v20 = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      *(_WORD *)bytes  = 0;
      CFDataAppendBytes(v20, bytes, 2);
      CFArrayRef v21 = (__CFData *)atomic_load_explicit((atomic_ullong *volatile)&Mutable, memory_order_acquire);
      *(_WORD *)bytes  = bswap32(*((unsigned __int16 *)this + 8)) >> 16;
      CFDataAppendBytes(v21, bytes, 2);
      char v15 = 0;
      __int16 v14 = 256;
    }
    while ((v16 & 1) != 0);
    unint64_t v10 = atomic_exchange((atomic_ullong *volatile)&Mutable, 0);
  }
  *a2  = v10;
}

uint64_t TArabicJustEngine::HasPostcompensation(TArabicJustEngine *this)
{
  return 1;
}

void TFallbacksSource::CopyDescriptorsForFamily(atomic_ullong **this@<X0>, const __CFString *a2@<X1>, atomic_ullong *a3@<X8>)
{
  *a3  = 0xAAAAAAAAAAAAAAAALL;
  TPurgeableCache::RetainedValueForKey(*this, a2, (atomic_ullong *)&v10);
  *a3  = atomic_exchange((atomic_ullong *volatile)&v10, 0);

  if (!atomic_load_explicit(a3, memory_order_acquire))
  {
    TDescriptorSource::TDescriptorSource((TDescriptorSource *)&v9);
    TDescriptorSource::CopyMatchingDescriptorsForFamily((TDescriptorSource *)&v9, a2, &v10);

    if (atomic_load_explicit(a3, memory_order_acquire))
    {
      CGFloat v6 = *this;
      unint64_t explicit = atomic_load_explicit(a3, memory_order_acquire);
      uint64_t v8 = (void *)atomic_load_explicit(v6, memory_order_acquire);
      if (explicit) {
        [v8 setObject:explicit forKey:a2];
      }
      else {
        [v8 removeObjectForKey:a2];
      }
    }
  }
}

void SyriacShapingEngine::SetFeatures(SyriacShapingEngine *this, const OTL::GSUB *a2, OTL::GlyphLookups *a3)
{
  uint64_t v3 = 0;
  uint64_t v102 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1)  = 0xAAAAAAAAAAAAAAAALL;
  v81[19]  = v4;
  v81[20]  = v4;
  v81[17]  = v4;
  v81[18]  = v4;
  v81[15]  = v4;
  v81[16]  = v4;
  v81[13]  = v4;
  v81[14]  = v4;
  v81[11]  = v4;
  v81[12]  = v4;
  v81[9]  = v4;
  v81[10]  = v4;
  v81[8]  = v4;
  v81[6]  = v4;
  v81[7]  = v4;
  v81[4]  = v4;
  v81[5]  = v4;
  v81[2]  = v4;
  v81[3]  = v4;
  v81[0]  = v4;
  v81[1]  = v4;
  do
  {
    CFIndex v5 = &v81[v3];
    *CFIndex v5 = 0;
    v5[1]  = 0;
    _OWORD v5[2] = 0;
    void v5[5] = (char *)&v81[v3 + 1] + 8;
    v3 += 3;
  }
  while (v3 != 21);
  CGFloat v6 = (TRunGlue *)*((void *)this + 2);
  uint64_t v7 = TRunGlue::length(v6);
  uint64_t v8 = (int *)*((void *)this + 2);
  uint64_t v70 = v8[6];
  if ((int)v70 < 1)
  {
    unint64_t v73 = v6;
    unsigned int v75 = (TRunGlue *)(v7 - 1);
    uint64_t v9 = (const char *)&SyriacShapingEngine::SetFeatures(OTL::GSUB const&,OTL::GlyphLookups &)::rtlTagArray;
    uint64_t v71 = -1;
  }
  else
  {
    uint64_t v71 = TRunGlue::length((TRunGlue *)v8);
    unint64_t v73 = (TRunGlue *)v8;
    unsigned int v75 = 0;
    uint64_t v9 = "lositinianifidem2dem2nif3niflosianif2nif3nifidem2demtini";
  }
  for (uint64_t i = 0; i != 7; ++i)
  {
    unint64_t v100 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v11 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v11 + 1)  = 0xAAAAAAAAAAAAAAAALL;
    v99[5]  = v11;
    v99[6]  = v11;
    v99[3]  = v11;
    v99[4]  = v11;
    v99[1]  = v11;
    v99[2]  = v11;
    v99[0]  = v11;
    uint64_t v97 = 0;
    uint64_t v98 = 0;
    uint64_t v96 = 0;
    BOOL v101 = v99;
    int v80 = *(_DWORD *)&v9[4 * i];
    OTL::FeatureBuffer::FeatureBuffer<unsigned int const*>((char **)&v83, &v80, v81);
    OTL::GCommon::GetLookups((uint64_t)a2, (uint64_t)&v83, (uint64_t)&v96, 0);
    StringIndeCGFloat x = (uint64_t)&v83;
    std::vector<std::pair<unsigned int,unsigned int>,TInlineBufferAllocator<std::pair<unsigned int,unsigned int>,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&StringIndex);
    unint64_t v12 = (unint64_t)v96;
    unint64_t v13 = v97;
    if (v96 != v97)
    {
      __int16 v14 = (char **)&v81[3 * i];
      char v15 = v14[1];
      do
      {
        int v16 = *(_DWORD *)v12;
        unint64_t v17 = (unint64_t)v14[2];
        if ((unint64_t)v15 >= v17)
        {
          uint64_t v18 = (v15 - *v14) >> 2;
          if ((unint64_t)(v18 + 1) >> 62) {
            abort();
          }
          uint64_t v19 = v17 - (void)*v14;
          uint64_t v20 = v19 >> 1;
          if (v19 >> 1 <= (unint64_t)(v18 + 1)) {
            uint64_t v20 = v18 + 1;
          }
          if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v21 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v21 = v20;
          }
          *((void *)&v85 + 1)  = v14 + 3;
          if (v21) {
            id v22 = (char *)TInlineBufferAllocator<std::pair<unsigned short,unsigned short>,4ul>::allocate((uint64_t)(v14 + 3), v21);
          }
          else {
            id v22 = 0;
          }
          id v23 = &v22[4 * v18];
          CGFloat v24 = &v22[4 * v21];
          *(void *)&long long v85 = v24;
          *(_DWORD *)id v23 = v16;
          char v15 = v23 + 4;
          v84.i64[1]  = (uint64_t)(v23 + 4);
          CGFloat v26 = *v14;
          unint64_t v25 = (unint64_t)v14[1];
          if ((char *)v25 == *v14)
          {
            int64x2_t v28 = vdupq_n_s64(v25);
          }
          else
          {
            do
            {
              int v27 = *(_DWORD *)(v25 - 4);
              v25 -= 4;
              *((_DWORD *)v23 - 1)  = v27;
              v23 -= 4;
            }
            while ((char *)v25 != v26);
            int64x2_t v28 = *(int64x2_t *)v14;
            char v15 = (char *)v84.i64[1];
            CGFloat v24 = (char *)v85;
          }
          *__int16 v14 = v23;
          v14[1]  = v15;
          int64x2_t v84 = v28;
          int v29 = v14[2];
          v14[2]  = v24;
          *(void *)&long long v85 = v29;
          uint64_t v83 = (TRunGlue **)v28.i64[0];
          std::__split_buffer<std::pair<unsigned short,unsigned short>,TInlineBufferAllocator<std::pair<unsigned short,unsigned short>,4ul> &>::~__split_buffer((uint64_t)&v83);
        }
        else
        {
          *(_DWORD *)char v15 = v16;
          v15 += 4;
        }
        v14[1]  = v15;
        v12 += 4;
      }
      while ((TRunGlue *)v12 != v13);
    }
    uint64_t v83 = &v96;
    std::vector<unsigned int,TInlineBufferAllocator<unsigned int,30ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v83);
  }
  for (uint64_t j = 0; j != 7; ++j)
  {
    uint64_t v31 = 0;
    while (*(_DWORD *)&v9[v31] != *(_DWORD *)&SyriacShapingEngine::SetFeatures(OTL::GSUB const&,OTL::GlyphLookups &)::ltrTagArray[4 * j + 28])
    {
      v31 += 4;
      if (v31 == 28)
      {
        uint64_t v32 = v9 + 28;
        goto LABEL_33;
      }
    }
    uint64_t v32 = &v9[v31];
LABEL_33:
    int v33 = (unsigned int **)&v81[3 * ((v32 - v9) >> 2)];
    CGRect v34 = *v33;
    CGRect v35 = v33[1];
    if (*v33 != v35)
    {
      do
      {
        unsigned int v36 = *v34++;
        unint64_t v12 = v12 & 0xFFFFFFFF00000000 | v36;
        OTL::GlyphLookups::SetLookupInRange<false>((uint64_t *)a3, v12, 0, 0);
      }
      while (v34 != v35);
    }
  }
  uint64_t v83 = (TRunGlue **)*((void *)this + 1);
  int64x2_t v84 = 0u;
  long long v85 = 0u;
  long long v86 = 0u;
  long long v87 = 0u;
  long long v88 = 0u;
  long long v89 = 0u;
  long long v90 = 0u;
  long long v91 = 0u;
  long long v92 = 0u;
  long long v93 = 0u;
  uint64_t v95 = 0;
  long long v94 = 0u;
  *(void *)&long long v94 = v83[2];
  uint64_t v96 = v73;
  uint64_t v97 = v75;
  unint64_t v37 = v71;
  if (v75 == (TRunGlue *)v71) {
    goto LABEL_78;
  }
  uint64_t v76 = 0;
  unint64_t v38 = 0;
  char v39 = 0;
  int v40 = 0;
  UChar32 v41 = 0;
  c  = 0;
  BOOL v42 = 0;
  BOOL v43 = 0;
  uint64_t v44 = v70;
  do
  {
    IsDeleted  = TRunGlue::TGlyph::IsDeleted((TRunGlue::TGlyph *)&v96);
    uint64_t v46 = v97;
    if (IsDeleted) {
      goto LABEL_62;
    }
    int v78 = v40;
    BOOL v47 = v43;
    StringIndeCGFloat x = TRunGlue::GetStringIndex(v96, (uint64_t)v97);
    UChar32 FullChar = TCharStreamIterator::GetFullChar((TCharStreamIterator *)&v83, &StringIndex, 0);
    IntPropertyCFDictionaryRef Value = u_getIntPropertyValue(FullChar, UCHAR_JOINING_TYPE);
    unsigned int v50 = JoiningScriptShapingEngine::shapeTypes[IntPropertyValue];
    if (v42)
    {
      int32_t v51 = IntPropertyValue;
      if (u_getIntPropertyValue(v41, UCHAR_JOINING_GROUP) == 2)
      {
        if (!v51)
        {
          UChar32 v74 = v41;
          if ((v39 & 1) == 0)
          {
            if (u_getIntPropertyValue(c, UCHAR_JOINING_GROUP) == 7) {
              unint64_t v38 = 6;
            }
            else {
              unint64_t v38 = 5;
            }
          }
          unsigned int v50 = 8;
          goto LABEL_47;
        }
        if (v39) {
          unint64_t v38 = 4;
        }
        else {
          unint64_t v38 = v38;
        }
      }
    }
    if ((v50 & 4) != 0)
    {
      uint64_t v46 = v97;
      if (!*((unsigned char *)this + 24))
      {
        GlyphID  = TRunGlue::GetGlyphID(v96, (uint64_t)v97);
        uint64_t v46 = v97;
        if (!GlyphID)
        {
          TRunGlue::Delete(*((void **)this + 2), (uint64_t)v97, 0);
          uint64_t v46 = v97;
        }
      }
      BOOL v43 = v47;
      int v58 = v78;
      goto LABEL_61;
    }
    UChar32 v74 = v41;
LABEL_47:
    BOOL v43 = (v50 & 8) == 0;
    if (v78 & v50) {
      unint64_t v52 = ((v50 & 8) >> 3) ^ 1u;
    }
    else {
      unint64_t v52 = 0;
    }
    if (v76 >= 1)
    {
      unsigned int v53 = (v78 & v50) & v47 ? v38 + 2 : v38;
      uint64_t v54 = (unsigned int **)&v81[3 * v53];
      unint64_t v55 = *v54;
      int v56 = v54[1];
      if (*v54 != v56)
      {
        do
        {
          unsigned int v57 = *v55++;
          unint64_t v38 = v38 & 0xFFFFFFFF00000000 | v57;
          OTL::GlyphLookups::SetLookupInRange<true>((uint64_t *)a3, v38, (uint64_t)v75, 1);
        }
        while (v55 != v56);
      }
    }
    int v58 = (v50 >> 1) & 1;
    uint64_t v46 = v97;
    c  = v74;
    UChar32 v41 = FullChar;
    unint64_t v38 = v52;
    unsigned int v75 = v97;
    uint64_t v76 = 1;
    uint64_t v44 = v70;
    unint64_t v37 = v71;
    BOOL v42 = v47;
    char v39 = v78;
LABEL_61:
    int v40 = v58;
LABEL_62:
    uint64_t v97 = (TRunGlue *)((char *)v46 + v44);
  }
  while ((TRunGlue *)((char *)v46 + v44) != (TRunGlue *)v37);
  if (v42)
  {
    char v60 = (u_getIntPropertyValue(v41, UCHAR_JOINING_GROUP) != 2) | v39;
    uint64_t v61 = (uint64_t *)a3;
    uint64_t v63 = (uint64_t)v75;
    uint64_t v62 = v76;
    if ((v60 & 1) == 0)
    {
      if (u_getIntPropertyValue(c, UCHAR_JOINING_GROUP) == 7) {
        LODWORD(v38)  = 6;
      }
      else {
        LODWORD(v38)  = 5;
      }
    }
  }
  else
  {
    uint64_t v61 = (uint64_t *)a3;
    uint64_t v63 = (uint64_t)v75;
    uint64_t v62 = v76;
  }
  if (v62 >= 1)
  {
    int v64 = (unsigned int **)&v81[3 * v38];
    uint64_t v65 = *v64;
    uint64_t v66 = v64[1];
    if (*v64 != v66)
    {
      do
      {
        unsigned int v67 = *v65++;
        unint64_t v37 = v37 & 0xFFFFFFFF00000000 | v67;
        OTL::GlyphLookups::SetLookupInRange<true>(v61, v37, v63, 1);
      }
      while (v65 != v66);
    }
  }
LABEL_78:
  for (uint64_t k = 18; k != -3; k -= 3)
  {
    uint64_t v83 = (TRunGlue **)&v81[k];
    std::vector<std::pair<UScriptCode,long>,TInlineBufferAllocator<std::pair<UScriptCode,long>,1ul>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v83);
  }
}